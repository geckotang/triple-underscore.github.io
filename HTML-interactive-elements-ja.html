<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Interactive elements（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/forms.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'interactive-elements',
		collectParts: Util.collectParts,
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: XXXXX spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		p: 'property',
		E: 'error',
		et: 'event-type',
		st: 'attr-state',
		v: 'value',
		M: 'method',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code', // IDL
		m: 'code', // IDL
		E: 'code', // err
		c: 'code', 
		e: 'code', // elem
		a: 'code', // attr
		M: 'code',
		et: 'code',
		st: 'span',
		p: 'code', // css prop
		v: 'code', // attr value
		t: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var context = '';
	
	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[\w\-~一-鿆]+|``?(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'dgm':
	return '<a id="_dgm-' + key + '"></a>';
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(match[1] === '`') {
	if(indicator === '^'){
		context = key;
	} else {
		klass = klass + '!' + context;
	}
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
	the-menu-element:menus
</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
HTMLinteraction:https://html.spec.whatwg.org/multipage/interaction.html

relatedTarget0:relatedTarget
此れ:<b>これ°</b>
positionT:<var class="type">&lt;position&gt;</var>

</script>

<script type="text/plain" id="words_table">
	●仕様
API:
UA:user agent:UA
algo:algorithm:::アルゴリズム
app:application:::アプリ
browser::::ブラウザ
model::::モデル
platform::::プラットフォーム
support::::サポート
事例:case:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
作者:author:~
依存-:depend:~
処理:processing:~
利用者:user:~
効果:effect:~
単独の:single:~
奨励-:encourage:~
孕む:involve する:~
定義-:define:~
定義:definition:~
実装-:implement:~
実際:actual:~
微妙:subtle:~
所与の:given:与えられた
手続き:steps:~
指定-:specify:~
指示-:indicate:~
提供-:provide:~
提供0-:offer:提供
明示的:explicit:~
正確:exact:~
決定-:determine:~
注釈文:prose:~
	特に:in particular
特定の:specific:~
特色機能:feature:~
目的0:purpose:目的
要件:requirement:~
要請:request:~
記述-:describe:~
許容-:allow:~
適切:appropriate:~
適用-:apply:~
重要:important:~
関係-:relate:~
関連する:relevant な:~


	-:immediately#1
	-:scope#1
	-:share#1
	1 個の:one#18
	3 番目の:third#1
	4 個の:four#6
	4 番目の:fourth#1
	〜に基づく:based#2
	〜の代わりに:instead#3
	いくつかの:several#1
	この:this#23
	これらの:these#4
	しかしながら，:however#1
	したがって:therefore#1
	すでに:already#3
	すべての:all#4
	その:that#32
	そのような:such#5
	それらの:their#2
	それらの:those#1
	とりわけ:especially#1
	べき:should#7
	より大きい:larger#1
	上:above#10
	下:below#3
結付けら:associate さ:結び付けら
規則:rule:~
規約:conventions:~
解釈-:interpret:~
	-:issue:~
	ある種の／ある:certain:~
一般:general:~
確保-:ensure:~
背後:behind:~
能:ability:機能
自前の:own:~
自明:trivial:~
側面:aspect:~
判定基準:criteria:~
取扱い:handling:~
取扱う／取扱い:handle:~
可用:available:~
可能0:possible:可能
影響-:affect:~
基本的:basic:~
宣言-:declare:~
尊守-:honor:~
情報:information:~
手段:means:~
技術的:technical:~
抽象化:abstraction:~
既定の:default:~
本質的:essential:~
検分-:examine:~
概して:typical に:~
理想:ideal:~
	用いて:using:~
用語:term:~
間接的:indirect:~
直接的:direct:~
示唆-:suggest:~
期待-:expect:~
特別:special :~
意味論:semantics:~
	見よ:see:~
	与-:give:~
	両者:both:~
	介:via:~
	他の:other:~
	他の場合:otherwise:~
	例:example:~
	依然として:still:~
	別の:another:~
	利用-:use:~
	各:each:~
	合間:between:~
	同じ:same:~
	多くの:many:~
	対応-:correspond:~
	対応:corresponding:~
	常に:always:~
	後:after:~
	得-:obtain:~
	必要とされ:necessary:~
	扱う:treat:~
	指せ:refer:~
	文脈上の:contextual:~
	最も近傍の:nearest:~
	最初の:first:~
	最後の:last:~
	決して:never:~
	異なる:different:~
	節:section:~
	結果:result:~
	自身:itself:~
	通:through:~
	除-:except:~


	●構文
error::::エラー
keyword::::キーワード
stack::::スタック
tag::::タグ
始端:start:~
文字:character:~
文字列:string:~
省略-:omit:~
空:empty:~
終了tag:end tag::終了 tag:終了タグ
省略-:omit:~
省略:omission:~
省略不可:omissible でない:~
構文解析-:parse::~::パース
妥当:valid:~
空白類:space characters:~
空白:whitespace:~
順序:order:~
既知の:knwon:~
制限-:limit:~
剥いで:strip して:~
剥いだ:strip した:~


	●UI
UI:
target::::ターゲット
window::::ウィンドウ
	要請元:subject:~
	要請元:for which the menu is being shown
locale::::ロケール
toolbar::::ツールバー
popup::::ポップアップ
modal::::モーダル
pan::::パン
scroll::::スクロール
inspector::::インスペクタ
bar::::バー
button::::ボタン
caption::::キャプション
click::::クリック
command::::コマンド
control::::コントロール
dialog::::ダイアログ
drop-down:drop down:::ドロップダウン
event::::イベント
field::::フィールド
focus::::フォーカス
form::::フォーム
group::::グループ
help::::ヘルプ
hint::::ヒント
item::::アイテム
key::::キー
label::::ラベル
menu::::メニュー
下位menu:submenu:::下位メニュー:サブメニュー
pop-up::::ポップアップ
radio::::ラジオ
toggle::::トグル
widget::::ウィジェット
editor::::エディタ
gesture::::ジェスチャ

access::::アクセス

割当てら:assign さ::あてがわ
	割当てられている~assigned

動作:action::~::アクション
作動中:active::~::アクティブ
作動化:activation::~::アクティブ化
作動化の:activation::~::アクティブ化の
作動化-:activate::~::アクティブ化
取消され:cancel され::~::キャンセルされ
取消す:cancel する::~::キャンセルする
可視:visible:~
合成:synthetic::~
報告-:report:~
対話-:interact:やりとり
対話:interaction:~
対話的:interactive:~
発火:firing:~
発火-:fire::~
縮退-:collapse:~
自動的:automatic:~
表示-:display:~
視覚的:visual:~
計算-:calculate:~
進捗:progress:~
選択-:select:~
選択:selection:~
選択肢:option::~::オプション
静的:static:~
併合-:merge:~
分離子:separator:~
右click:right-click:~
外観:appearance:~
告知-:advertise:~
提出:submission::~
提出-:submit::~
開閉式:disclosure:~
開閉三角印:disclosure triangle:~

facet:::側面
不能化-:disable::~
不能化:disabled::~
可能化-:enable::~
可能化:enabled::~
状態:state:~
展開-:expand:~
不活:inert::~
隠され:hidden::~
隠-:hide::~
隠す:hide する::~
示され:show され::~
示す:show する::~
示して:show して::~
通知:notification:~
阻んで:block して::~::ブロックして
閉じる:close する::~
閉じら:close さ::~
	畳まれ:close
	展開-:open:~
	開ける:open
	開いて:open
	覆って:over

構成子:construct::~
築いて:build して::~
築いた:build した::~
築く:build する::~
生成-:generate:~
指名-:designate::~
pointing::::ポインタ指示
mouse::::マウス
icon::::アイコン

	●呈示／CSS
CSS:
box::::ボックス
prop:property:::プロパティ
animate::::アニメート
animation::::アニメーション
色:color:~

包含塊:containing block:包含 block::包含ブロック
塊:block:::ブロック
下端:bottom:~
上端:top:~
左端:left:~
右端:right:~
上端層:top layer::~
最上端の:top-most:~

中心:center point:~
中央:center:~
	中心:center:~
中央寄せ:centered:~
magic:
位置:position:~
絶対位置:absolutely positioned:~
位置決め:positioning:~
百分率:percentage:~
算出-:compute:~
絶対:absolute:~
線:line:~
縦方向:vertical:~
隅:corner:~
区画:area:~
座標:coordinate:~
所在:location:~
整列:alignment:~
整列-:align:~
横方向:horizontal:~
匿名:anonymous:~
固定-:fix:~
	地点:point:~
	点:point:~
anchor::::
anchor-point:anchor point:anchor 点
border::::ボーダー
margin::::マージン
offset::::オフセット
首:principal:主
辺:edge:~
相殺:collapsing:~
使用値:used value:~
指定値:specified value:~
初期値:initial value:~
適用対象:applies to:~
継承-:inherit:~
百分率:percentage:~
媒体:media::~::メディア
算出値:computed value:~
正準的順序:canonical order:~
離散的:discrete:~
表示域:viewport:~
配置-:place:~
	-:hypothetical
	無限に伸びるhalf-infinite
	〜上:lie
	囲まれる域内:inside the area bounded
	位置が改められ:reposition
拡張子:extension:~

	●DOM／IDL／event／task
呼出す:invoke する:呼び出す
呼出せる:invoke できる:呼び出せる
呼出され:invoke され:呼び出され
呼出して:invoke して:呼び出して
呼出した:invoke した:呼び出した
被呼出時:被 invoke 時:~
被取得時:被 get 時:~
被設定時:被 set 時:~
引数:argument:~
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ
待入し:queue し::待ち行列に入れ::キューし
源:source::~::ソース

DOM:
IDL:
ID:
task::::タスク
interface::::インタフェース
method::::メソッド
node::::ノード
obj:object:::オブジェクト
handler::::ハンドラ
投出:throw:~
誘発-:trigger:~
配送-:dispatch:~
走らす:run する:~
走らせ:run し:~

	●内容
木:tree::~::ツリー
根:root::~::ルート
table:
footnote:
legend:
分類:category:~
列挙ed:enumerated:列挙
先祖:ancestors:~
入子に:nest:~
内容:content:~
反映-:reflect:~
子:child:~
子孫:descendants:~
大域:global::~::グローバル
句内容:phrasing content:phrasing 内容:~::フレージング内容
可触:palpable::~
属性:attribute:~
描画-:render:~
描画:rendering:~
具現化-:render:~
具現化:rendering:~
文書:document:~
文脈:context:~
横幅:width:~
画像:image:~
縦幅:height:~
要素:element:~
親:parent:~
要約-:summarize:~
要約:summary:~
見出し:heading:~
詳細:details:~
	細則事項:small print:~
媒体:media:~
在する:present する:在る
flow::::フロー
markup::::マークアップ
sectioning::::セクショニング
text::::テキスト

頁:page:::ページ
真偽:boolean:~
none::なし

	●未分類（動詞
mark-up::::マークアップ
不在:absent:~
付加-:append:~
作成-:create:~
	再~作成-:recreate
公開-:expose:~
包含-:contain:~
	満たす:match:~
完了-:complete:~
構築-:construct:~
置換-:replace:~
設定-:set:~
迂回-:bypass:~
追加-:add:~
追加の:additional:~
遂行-:perform:~
除去-:remove:~
挙動:behaviour:ふるまい:~
更新-:update:~
変化-:change:~
変更-:change:~
変更:change:~
変更点:changes:~
移動-:move:~
組合せ:combination:~
継続-:continue:~

初期化-:initialize:~

	●未分類
結果値:returnValue:~
待ち:pending:~
入力:input:~
出力:output:~
名:name:~
名前:name:~
新たな:new:~
有順序:ordered:~
無順序:unordered:~
	-:paragraph:~
相対的:relative:~
集合:set:~
閲覧文脈:browsing context:~
層:layer:~
所有者:owner::~
単純:simple:~
関係性:relationships:~
live:
値:value:~
型:type:~
変異不可:immutable:~
引数:argument:~
	渡-:pass:~
無視-:ignore:~
状況:situation:~
現在の:current:~

	押下げる:press する:~
	押下げながらの:depress
表現-:represent:~
装置:device:~
通常の:normal:~
	通常:normal:~
連列:sequence:~
長さ:length:~

DOM:
ID:
IDL:
URL:
Web:
block::::
check::::チェック
	~close::::
column::::
	~drop::::
	最終的eventual::::
	-:リテラル
link::::リンク
list::::リスト
mark::::マーク
mode::::モード
navigate::::ナビゲート
	open::::
積む:push する:~
script::::スクリプト
	~script:による:scripted
source::::ソース
style::::スタイル
stylesheet::::スタイルシート
	~previous::::
	~respective::::
	-:pixel
	●
	部位:part
	一部:part of
	各部品:parts
	見つかるfound
	giving::::
	labeled::::
	小さい／:small:~
	種類:kind:~
	絵／写真:picture:~
	行:line:~
	表:table:~
	起こる:happen:~
	返す:return:~
	選ぶ:pick:~
	followed
	たし:please
	rest:#1
	その後にsubsequently
	何回か続けて:several times in succession:#1
	~~集約:coalesce
	併用:use this in conjunction with
	だけ really just:
	-:generated
	-:follow
	~~反映するようにrespecting
	連続する複数の:two or more adjacent
	-:imagine
	-:called
	様々になる:vary
	一緒:together
	目立たなくする:de-emphasize
	正統的な:legitimacy
	使用感:feel like
	猫:cat
	~mouseで~~操作されるmouse-operated
	下向きの:downwards-pointing
	より長く／longer
	等々:and so forth
	u:#1
	先行／earlier:#2
	-:measured
	保た:remain:~
	有する:identified:#1
	-:annotating
	則って:accordingly
	live:
	注目:attention
	暫定的:interim basis
	まで:until
	残りの:the rest of
	その後に，Subsequently
	何回か続けて:several times in succession
	併用する:use this in conjunction with
	形をとる:in the form of
	連続する複数の:sequences of two or more adjacent
	複数箇所:many 〜 points
	行う:do
	~~区切り~~線:horizontal splitter
	でなくなった:ceaseする
	面したとき:in the face of
	引く:draw
	一点:just form a point
	言い換えれば:In other words,
	例として:for instance
	はっきりしない:not entirely clear
	通常の規則に代わって:rather than whatever it would otherwise compute to
	考える:consider
	伸びる:extend
	理想とは言えない:less than ideal
	食べる:eat
	水道の蛇口:water faucet
	依存-:depend:~
	通常:normal:~
	編集者:editor:~
	facet:
	差異:distinction:~
	ものになる:mark
オン／オフ:toggle
</script>

<!--%link  -->

<script type="text/plain" id="_link_map">

	●IDL／event
CEReactions:~HEcustom#cereactions
	DOMException:~WEBIDL#dfn-DOMException
E.InvalidStateError:~WEBIDL#invalidstateerror

I.HTMLMenuItemElement:#htmlmenuitemelement
I.HTMLDialogElement:#htmldialogelement
I.HTMLMenuElement:#htmlmenuelement
I.HTMLDetailsElement:#htmldetailselement
I.Document:~HTMLdom#document
文書:#_document
I.Element:~DOM4#interface-element
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#interface-eventtarget
I.HTMLConstructor:dom.html#htmlconstructor
I.HTMLElement:dom.html#htmlelement
I.MouseEvent:~UIEVENTS#interface-mouseevent
I.RelatedEvent:#relatedevent
I.RelatedEventInit:#relatedeventinit

m.contextMenu:#dom-contextmenu

m.relatedTarget:#dom-relatedevent-relatedtarget
m.textContent:~DOM4#dom-node-textcontent
m.~relatedTarget0:~UIEVENTS#dom-mouseevent-relatedtarget
	widl-MouseEvent-relatedTarget

m!details.open:#dom-details-open

m!menu.label:#dom-menu-label
m!menu.type:#dom-menu-type

m!menuitem.checked:#dom-menuitem-checked
m!menuitem.default:#dom-menuitem-default
m!menuitem.disabled:#dom-menuitem-disabled
m!menuitem.label:#dom-menuitem-label
m!menuitem.icon:#dom-menuitem-icon
m!menuitem.radiogroup:#dom-menuitem-radiogroup
m!menuitem.type:#dom-menuitem-type

m!dialog.close:#dom-dialog-close
m!dialog.open:#dom-dialog-open
m!dialog.show:#dom-dialog-show
m!dialog.showModal:#dom-dialog-showmodal
m!dialog.returnValue:#dom-dialog-returnvalue

m.cancelable:~DOM4#dom-event-cancelable
m.bubbles:~DOM4#dom-event-bubbles

et.cancel:~HTMLindex#event-cancel
et.click:~UIEVENTS#event-type-click
et.close:~HTMLindex#event-close
et.contextmenu:~HTMLindex#event-contextmenu
et.keyup:~UIEVENTS#event-type-keyup
et.mouseup:~UIEVENTS#event-type-mouseup
et.show:~HTMLindex#event-show
et.toggle:~HTMLindex#event-toggle


	●要素／属性／値
e.a:~HEtextlevel#the-a-element
e.button:~HEforms#the-button-element
e.details:#the-details-element
e.dialog:#the-dialog-element
e.fieldset:~HEforms#the-fieldset-element
e.hr:~HEgrouping#the-hr-element
e.input:~HEinput#the-input-element
e.label:~HEforms#the-label-element
e.legend:~HEforms#the-legend-element
e.menu:#the-menu-element
e.menuitem:#the-menuitem-element
e.option:~HEforms#the-option-element
e.select:~HEforms#the-select-element
e.summary:#the-summary-element
e.li:~HEgrouping#the-li-element
e.main:~HEgrouping#the-main-element

a.autofocus:~HTMLforms#attr-fe-autofocus
a.contextmenu:#attr-contextmenu
a.hidden:~HTMLinteraction#the-hidden-attribute
a.href:~HTMLlinks#attr-hyperlink-href
a.menu:~HEforms#attr-button-menu
a.multiple:~HEforms#attr-select-multiple
a.tabindex:~HTMLinteraction#attr-tabindex

a.label:#attr-menu-label
a.type:#attr-menu-type

a!menuitem.checked:#attr-menuitem-checked
a!menuitem.default:#attr-menuitem-default
a!menuitem.disabled:#attr-menuitem-disabled
a!menuitem.icon:#attr-menuitem-icon
a!menuitem.label:#attr-menuitem-label
a!menuitem.radiogroup:#attr-menuitem-radiogroup
a!menuitem.title:#attr-menuitem-title
a!menuitem.type:#attr-menuitem-type

a!details.open:#attr-details-open
a!dialog.open:#attr-dialog-open

a!input.type:~HEinput#attr-input-type
a!input.value:~HEinput#attr-input-value
a!option.label:~HEforms#attr-option-label
a!option.value:~HEforms#attr-option-value

v!menu.context:#attr-menu-type-context
v!menu.toolbar:#attr-menu-type-toolbar

st!input.Button:#button-state-(type=button)
st!input.Checkbox:#checkbox-state-(type=checkbox)
st!input.Image:#image-button-state-(type=image)
st!input.Radio:#radio-button-state-(type=radio)
st!input.Reset:#reset-button-state-(type=reset)
st!input.Submit:#submit-button-state-(type=submit)

st!menuitem.Checkbox:#attr-menuitem-type-state-checkbox
st!menuitem.Command:#attr-menuitem-type-state-command
st!menuitem.Radio:#attr-menuitem-type-state-radio

st.Menu:~HEforms#attr-button-type-menu-state
	~menu~button

st.popup menu:#popup-menu-state
st.toolbar:#toolbar-state

v!menuitem.command:#attr-menuitem-type-keyword-command
v!menuitem.checkbox:#attr-menuitem-type-keyword-checkbox
v!menuitem.radio:#attr-menuitem-type-keyword-radio

	●CSS
p.anchor-point:#'anchor-point'
p.border-collapse:~CSSWG/css-tables/#border-collapse-property
p.clear:~CSS2VISUREN#flow-control
p.display:~CSS2VISUREN#display-prop
p.float:~CSS2VISUREN#float-position
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.position:~CSSWG/css-position/#position-property
p.top:~CSSWG/css-position/#propdef-top

~positionT:~CSSBG#position

v.table-cell:~CSSWG/css-tables/#table-cell

	●

~command:#concept-command
~commandを定義する:#concept-command
現在~関連する~menu要素:#currently-relevant-menu-element
既定の~command:#default-command
~facet:#concept-facet
cF.~label:#command-facet-label
cF.~access~key:#command-facet-accesskey
cF.隠され状態:#command-facet-hiddenstate
cF.不能化~状態:#command-facet-disabledstate
cF.動作:#command-facet-action
	as for a elements:#using-the-a-element-to-define-a-command


v.absolute-anchored:#css-position-absolute-anchored


~menu構成子を築く:#build-a-menu-construct
~menu構成子を築いた:#build-a-menu-construct
~menuを築いて示す:#build-and-show-a-menu
割当てられている文脈~menu:#assigned-context-menu
文脈~menu:#attr-contextmenu
	has special semantics:#attr-menuitem-title
~menu構成子:#menu-construct
~menu~item構成子:#menu-item-construct
~menu~itemを生成する:#menu-item-generator
	~menu~item生成器:#menu-item-generator
	part of a popup menu:#the-menu-element
下位menu~label:#submenu-label
~label:#concept-menuitem-label

~magic整列:#magic-alignment
通常の整列:#normal-alignment
中央寄せ整列:#centered-alignment

	magically aligned:#magic-alignment

結果値:#_return-value

~dialogを閉じる:#close-the-dialog
~dialogとして~focusする:#dialog-focusing-steps
待ち~dialog~stack:#pending-dialog-stack

詳細~通知~task手続き:#details-notification-task-steps


不能化され:#concept-fe-disabled
opt.不能化され:#concept-option-disabled
終了tag:syntax.html#syntax-end-tag

	the section on footnotes:~HTML5/scripting.html#footnotes


分離子:#concept-separator
位置を設定しておく:#set-up-the-position

	rendering section:rendering.html#rendering




	●
選ぶ:~HEforms#concept-select-pick
~toggleする:~HEforms#concept-select-toggle
指名する~pop-up~menu:~HEforms#designated-pop-up-menu
~label先~control:~HEforms#labeled-control

~DOM~anchor:~HTMLinteraction#dom-anchor
~focus可能域:~HTMLinteraction#focusable-area
~focusする手続き:~HTMLinteraction#focusing-steps
不活:~HTMLinteraction#inert
割当てられている~access~key:~HTMLinteraction#assigned-access-key
阻んでいる~modal~dialog:~HTMLinteraction#blocked-by-a-modal-dialog
~modal~dialogにより~block:~HTMLinteraction#blocked-by-a-modal-dialog
~control群の所有者~obj:~HTMLinteraction#control-group-owner-object
~control群:~HTMLinteraction#control-group
作動化の挙動:~HTMLinteraction#activation-behaviour
~focusされ:~HTMLinteraction#focused
合成~click作動化~手続き:~HTMLinteraction#run-synthetic-click-activation-steps


示唆される既定の具現化を~support:~HTMLconform#renderingUA
無視-:~HTMLINFRA#ignore
相対的に構文解析-:~HTMLINFRA#parse-a-url
頭部と尾部の空白を剥いだ:~HTMLINFRA#strip-leading-and-trailing-whitespace
空白を剥いで縮退-:~HTMLINFRA#strip-and-collapse-whitespace
子~text内容:~HTMLINFRA#child-text-content
文書から除去され:~HTMLINFRA#remove-an-element-from-a-document
空白類:~HTMLINFRA#space-character
前後~空白~可の妥当かつ空でない~URL:~HTMLINFRA#valid-non-empty-url-potentially-surrounded-by-spaces
真偽~属性:~HTMLINFRA#boolean-attribute
列挙ed属性:~HTMLINFRA#enumerated-attribute
既知の値のみに制限され:~HTMLINFRA#limited-to-only-known-values
値なしに対する既定の状態:~HTMLINFRA#missing-value-default
反映-:~HTMLINFRA#reflect


分類:~HTMLdom#concept-element-categories
内容~属性:~HTMLdom#concept-element-attributes
内容~model:~HTMLdom#concept-element-content-model
この要素を利用できる文脈:~HTMLdom#concept-element-contexts
~DOM~interface:~HTMLdom#concept-element-dom
~flow内容:~HTMLdom#flow-content-2
大域~属性:~HTMLdom#global-attributes
対話的~内容:~HTMLdom#interactive-content-2
なし:~HTMLdom#concept-content-nothing
可触~内容:~HTMLdom#palpable-content-2
句内容:~HTMLdom#phrasing-content-2
text/html における~tag省略:~HTMLdom#concept-element-tag-omission
~text:~HTMLdom#text-content
見出し内容:~HTMLdom#heading-content-2
表現-:~HTMLdom#represents
~scriptを~supportする:~HTMLdom#script-supporting-elements-2

~DOM操作~task源:~WAPI#dom-manipulation-task-source
~click~eventを発火する:~WAPI#fire-a-click-event
合成~mouse~eventを発火する:~WAPI#fire-a-synthetic-mouse-event
~task源:~WAPI#task-source
~task:~WAPI#concept-task
~taskを待入する:~WAPI#queue-a-task
	~taskを待入し:~WAPI#queue-a-task
待入され:~WAPI#queue-a-task-
単純~eventを発火する:~WAPI#fire-a-simple-event


属する閲覧文脈:~BROWSERS#concept-document-bc
	＊閲覧文脈:~BROWSERS#browsing-context
~navigate:~HTML5/browsers.html#navigate

~sectioning根:~HEsections#sectioning-root
具現化され:~HTMLrendering#being-rendered

終了tag:~HTML5/syntax.html#syntax-end-tag

~ID:~DOM4#concept-id
文書~内:~DOM4#in-a-document
~node文書:~DOM4#concept-node-document
木~順序:~DOM4#concept-tree-order
木:~DOM4#concept-tree
発火-:~DOM4#concept-event-fire

~URL:~URLSpec#concept-url
絶対~URL:~URLSpec#syntax-url-absolute

tL.追加され:https://fullscreen.spec.whatwg.org/#top-layer-add
tL.除去され:https://fullscreen.spec.whatwg.org/#top-layer-remove
tL.上端層:https://fullscreen.spec.whatwg.org/#top-layer

	●CSS
	＊~CSS~pixel:~CSSVAL#px
~border~box:~CSS2BOX#x14
~border辺:~CSS2BOX#border-edge
~flow内:~CSS2VISUREN#x25
~margin~box:~CSS2BOX#x17
~margin相殺:~CSS2BOX#collapsing-margins
~margin辺:~CSS2BOX#margin-edge
算出値:~CASCADE#computed-value
包含塊:~CSS2VISUDET#containing-block-details
内容~区画:~CSS2BOX#box-content-area
表示域:~CSS2VISUREN#viewport
指定値:~CASCADE#specified-value
使用値:~CASCADE#used-value
静的~位置:~CSS2VISUDET#static-position
首~box:~CSS2VISUREN#principal-box

	the section of the CSS specification describing the relationships between 'display', 'position', and 'float':~CSS2VISUREN#dis-pos-flo

</script>

<!--%style -->
<style type="text/css">

/* property 定義表 */
table.propdef {
	border-spacing: 0;
/*	table-layout: fixed; */
	background-color: #ddeeff;
	border-left: 0.5em solid;
}

table.propdef {
	border-left-color: #8ccbf2;
}

table.propdef tr {
	border-top-color: #bbd7e9;
}

table.propdef th {
	white-space: nowrap;
}

table.propdef td {
	min-width: 12em;
	border-left: 1px solid #bbd7e9;
}

.type {
	color: #600;
	font-family: monospace0, monospace;
	font-style:italic;
}


</style>

</head>
<body>



<div style="display:none;">
	<input type="hidden" id="_page_config" value="" />

	<div id="_persisted_parts">
<img id="_dgm-sample-details-1"
	src="HTML-interactive-elements/sample-details-1.png"
	alt=""
	width="345" height="611"
>
<img id="_dgm-sample-details-2"
	src="HTML-interactive-elements/sample-details-2.png"
	alt=""
	width="345" height="666"
>
<img id="_dgm-sample-toolbar-1"
	src="HTML-interactive-elements/sample-toolbar-1.png"
	alt=""
	width="303" height="101"
>
<img id="_dgm-contextmenu-collapsed"
	src="HTML-interactive-elements/contextmenu-collapsed.png"
	alt=""
>
<img id="_dgm-contextmenu-expanded"
	src="HTML-interactive-elements/contextmenu-expanded.png"
	alt=""
>
	</div>

</div>

<aside class="trans-meta">
<h1>HTML — Interactive elements 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Forms</a>
章の Interactive elements 節を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-10-19</time>
（公開：<time>2016-10-08</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">
	<hgroup>
<h1>対話的な要素 — Interactive elements</h1>
<h2>HTML Living Standard — 最終更新 2016 年 10 月 18 日</h2>
	</hgroup>
</header>

<main id="MAIN" style="display:none;">


		<section id="interactive-elements">
<h2 title="Interactive elements">4.11 対話的~要素</h2>

			<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（ ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
このページにおける
`文書@
は、 `Document$I ~objを指す。
</p>
			</section>

			<section id="the-details-element">
<h3 title="The details element">4.11.1. ``details^e 要素</h3>
`25550^bug


<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$／`~sectioning根$／`対話的~内容$／`可触~内容$
◎
Flow content.
◎
Sectioning root.
◎
Interactive content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`~flow内容$が期待される所。
◎
Where flow content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
［
1 個の `summary$e 要素, `~flow内容$
］からなる並び
◎
One summary element followed by flow content.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
``open$a
— 詳細は可視であるかどうか
◎
open — Whether the details are visible
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
<pre class="idl">
[`HTMLConstructor$I]
interface `HTMLDetailsElement@I : `HTMLElement$I {
  [`CEReactions$] attribute boolean ``open$m;
};
</pre>
	</dd>
</dl>


<p>
`details$e 要素は、利用者が追加の情報や~controlを得られるような，開閉式~widgetを`表現-$する。
◎
The details element represents a disclosure widget from which the user can obtain additional information or controls.
</p>


<p class="note">注記：
`details$e 要素は、~footnoteには適切でない。
~footnoteを~mark-upする方法の詳細は、
<a href="~HTML5/scripting.html#footnotes">~footnoteに関する節</a>
を見られたし。
◎
The details element is not appropriate for footnotes. Please see the section on footnotes for details on how to mark up footnotes.
</p>

<p>
要素の最初の子が `summary$e 要素であるならば、それが詳細の［
要約 ／ ~legend
］を`表現-$する。
そのような子がなければ、~UAは，自前の~legend（例： “詳細” ）を提供するべきである。
◎
The first summary element child of the element, if any, represents the summary or legend of the details. If there is no child summary element, the user agent should provide its own legend (e.g. "Details").
</p>

<p>
要素の残りの内容は、追加の［
情報や~controlたち
］を`表現-$する。
◎
The rest of the element's contents represents the additional information or controls.
</p>

<p>
``open@a
内容~属性は`真偽~属性$である。
在する場合、要約, 追加の情報の両者とも利用者に示すことを指示する。
不在の場合、要約のみが示される。
◎
The open content attribute is a boolean attribute. If present, it indicates that both the summary and the additional information is to be shown to the user. If the attribute is absent, only the summary is to be shown.
</p>

<p>
追加の情報は、要素の作成-時には，この属性が［
不在ならば 隠-される ／
在するならば 示される
］べきである。
その後に，属性が［
除去された ／ 追加された
］場合、情報は［
隠-される ／ 示される
］べきである。
◎
When the element is created, if the attribute is absent, the additional information should be hidden; if the attribute is present, that information should be shown. Subsequently, if the attribute is removed, then the information should be hidden; if the attribute is added, the information should be shown.
</p>

<p>
~UAは
許容-
利用者が追加の情報を［
示す ／ 隠す
］よう要請できるようにするべきである。
そのような要請を尊守するためには、~UAには，要素の ``open$a 属性を［
示す場合は値 `open^v に設定する ／ 隠す場合は除去する
］ことが要求される。
◎
The user agent should allow the user to request that the additional information be shown or hidden. To honor a request for the details to be shown, the user agent must set the open attribute on the element to the value open. To honor a request for the information to be hidden, the user agent must remove the open attribute from the element.
</p>

<p class="algo-head">
~UAは、 ``open$a 属性が `details$e 要素 %details［
に追加- ／ から除去-
］される度に，
 %details に対し，
`詳細~通知~task手続き@
と称される次の手続きを走らす`~taskを待入する$~MUST：
◎
Whenever the open attribute is added to or removed from a details element, the user agent must queue a task that runs the following steps, which are known as the details notification task steps, for this details element:
</p>

<ol>
	<li>
<p>
~IF［
%details に対し`詳細~通知~task手続き$を走らす別の`~task$が`待入され$ている
］
⇒
~RET
◎
If another task has been queued to run the details notification task steps for this details element, then abort these steps.
</p>

<p class="note">注記：
``open$a 属性が何回か続けて~toggleされたときは、この手続きは，本質的に ~eventが 1 回だけ発火されるように~~集約される。
◎
When the open attribute is toggled several times in succession, these steps essentially get coalesced so that only one event is fired.
</p>
	</li>
	<li>
%details に向けて，名前 `toggle$et の`単純~eventを発火する$
◎
Fire a simple event named toggle at the details element.
</li>
</ol>

<p>
この~taskに対する`~task源$は、`~DOM操作~task源$で~MUST。
◎
The task source for this task must be the DOM manipulation task source.
</p>


<dl class="idl-def">
	<dt>``open@m</dt>
	<dd>
``open$a 内容~属性を`反映-$し~MUST。
◎
The open IDL attribute must reflect the open content attribute.
</dd>

</dl>


  <div class="example">

<p>
`details$e 要素を利用して，進捗~報告-内の技術的~詳細を隠す例：
◎
The following example shows the details element being used to hide technical details in a progress report.
</p>


<pre class="html-code">
&lt;section class="progress window"&gt;
 &lt;h1&gt;Copying "Really Achieving Your Childhood Dreams"&lt;/h1&gt;
 &lt;details&gt;
  &lt;summary&gt;複製中... &lt;progress max="375505392" value="97543282"&gt;&lt;/progress&gt; 25%&lt;/summary&gt;
  &lt;dl&gt;
   &lt;dt&gt;転送レート： &lt;/dt&gt; &lt;dd&gt;452KB/s&lt;/dd&gt;
   &lt;dt&gt;保存ディレクトリ： &lt;/dt&gt; &lt;dd&gt;/home/rpausch/raycd.m4v&lt;/dd&gt;
   &lt;dt&gt;転送元 URL： &lt;/dt&gt; &lt;dd&gt;/var/www/lectures/raycd.m4v&lt;/dd&gt;
   &lt;dt&gt;時間： &lt;/dt&gt; &lt;dd&gt;01:16:27&lt;/dd&gt;
   &lt;dt&gt;色プロファイル： &lt;/dt&gt; &lt;dd&gt;SD (6-1-6)&lt;/dd&gt;
   &lt;dt&gt;サイズ： &lt;/dt&gt; &lt;dd&gt;320×240&lt;/dd&gt;
  &lt;/dl&gt;
 &lt;/details&gt;
&lt;/section&gt;
</pre>
<!-- 
<section class="progress window">
 <h1>Copying "Really Achieving Your Childhood Dreams"</h1>
 <details>
  <summary>Copying... <progress max="375505392" value="97543282"></progress> 25%</summary>
  <dl>
   <dt>Transfer rate:</dt> <dd>452KB/s</dd>
   <dt>Local filename:</dt> <dd>/home/rpausch/raycd.m4v</dd>
   <dt>Remote filename:</dt> <dd>/var/www/lectures/raycd.m4v</dd>
   <dt>Duration:</dt> <dd>01:16:27</dd>
   <dt>Color profile:</dt> <dd>SD (6-1-6)</dd>
   <dt>Dimensions:</dt> <dd>320×240</dd>
  </dl>
 </details>
</section>
-->

  </div>

  <div class="example">


<p>
`details$e 要素を利用して，~controlを既定で隠す例：
◎
The following shows how a details element can be used to hide some controls by default:
</p>

<pre class="html-code">
&lt;details&gt;
 &lt;summary&gt;&lt;label for=fn&gt;名前と拡張子：&lt;/label&gt;&lt;/summary&gt;
 &lt;p&gt;&lt;input type=text id=fn name=fn value="Pillar Magazine.pdf"&gt;
 &lt;p&gt;&lt;label&gt;&lt;input type=checkbox name=ext checked&gt;拡張子を隠す&lt;/label&gt;
&lt;/details&gt;
</pre>
<!-- 
<details>
 <summary><label for=fn>Name & Extension:</label></summary>
 <p><input type=text id=fn name=fn value="Pillar Magazine.pdf">
 <p><label><input type=checkbox name=ext checked> Hide extension</label>
</details>

-->

<p>
これを ~list内で 他の `details$e と併用して、それぞれが~~展開する能を伴う~fieldの集合を，利用者が 小さい見出しの集合に縮退できるようにすることもできる。
◎
One could use this in conjunction with other details in a list to allow the user to collapse a set of fields down to a small set of headings, with the ability to open each one.
</p>


<figure>
`sample-details-1^dgm
`sample-details-2^dgm
</figure>

<p>
これらの例の要約は、~controlが何を変更できるかだけを要約する
— 実際の値を~~示すのは、理想とは言えない。
◎
In these examples, the summary really just summarizes what the controls can change, and not the actual values, which is less than ideal.
</p>

</div>

<div class="example">

<p>
``open$a 属性は、利用者が~controlと対話するに伴って，自動的に［
追加され／除去される
］ので、その状態に基づいて，~CSSを用いて要素に異なる~styleをあてがうことに利用できる。
ここでは、要素が~~展開されたり~~畳まれたときに，要約の色を~animateする~stylesheetの例を~~示す：
◎
Because the open attribute is added and removed automatically as the user interacts with the control, it can be used in CSS to style the element differently based on its state. Here, a stylesheet is used to animate the color of the summary when the element is opened or closed:
</p>

   
<pre class="html-code">
&lt;style&gt;
 details &gt; summary { transition: color 1s; color: black; }
 details[open] &gt; summary { color: red; }
&lt;/style&gt;
&lt;details&gt;
 &lt;summary&gt;Automated Status: Operational&lt;/summary&gt;
 &lt;p&gt;Velocity: 12m/s&lt;/p&gt;
 &lt;p&gt;Direction: North&lt;/p&gt;
&lt;/details&gt;</pre>

  </div>



			</section>
			<section id="the-summary-element">
<h3 title="The summary element">4.11.2. ``summary^e 要素</h3>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
~none。
◎
None.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`details$e 要素の最初の子として。
◎
As the first child of a details element.
</dd>

	<dt>`内容~model$</dt>
	<dd>
次のいずれかの一方
⇒
`句内容$, または 1 個の`見出し内容$ 要素
◎
Either: phrasing content.
◎
Or: one element of heading content.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>`大域~属性$
◎
Global attributes
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
`HTMLElement$I を利用する。
◎
Uses HTMLElement.
</dd>
</dl>

<p>
`summary$e 要素は、その親が `details$e 要素であれば，親の他の内容に対する［
要約 ／ ~caption ／~legend
］を`表現-$する。
◎
The summary element represents a summary, caption, or legend for the rest of the contents of the summary element's parent details element, if any.
</p>


			</section>
			<section id="the-menu-element">
<h3 title="The menu element">4.11.3. ``menu^e 要素</h3>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$。
◎
Flow content.
</dd>
	<dd>
要素の［
`type$a 属性の状態 ~EQ  `toolbar$st
］場合に限り，`可触~内容$。
◎
If the element's type attribute is in the toolbar state: Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`~flow内容$が期待される所。
◎
Where flow content is expected.
</dd>
	<dd>
要素の［
`type$a 属性の状態 ~EQ `popup menu$st
］の場合は：
［
`type$a 属性の状態 ~EQ `popup menu$st
］なる `menu$e 要素の子として。
◎
If the element's type attribute is in the popup menu state: as the child of a menu element whose type attribute is in the popup menu state.
</dd>

	<dt>`内容~model$</dt>
	<dd>
<p>
要素の `type$a 属性の状態に応じて：
</p>
		<dl class="switch">
			<dt>`toolbar$st</dt>
			<dd>
`~flow内容$, または
0 個~以上の［
`li$e ／ `~scriptを~supportする$
］要素。
◎
If the element's type attribute is in the toolbar state: either zero or more li and script-supporting elements, or, flow content.
</dd>

			<dt>`popup menu$st</dt>
			<dd>
<p>
それぞれが次のいずれかの要素である， 0 個~以上の並び：
</p>

<ul><li>`menuitem$e 要素
</li><li>`hr$e 要素
</li><li>
`menu$e 要素であって，［
その `type$a 属性の状態 ~EQ `popup menu$st
］なるもの
</li><li>`~scriptを~supportする$ 要素
</li></ul>

◎
If the element's type attribute is in the popup menu state: in any order, zero or more menuitem elements, zero or more hr elements, zero or more menu elements whose type attributes are in the popup menu state, and zero or more script-supporting elements.
</dd>
		</dl>
	</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>`大域~属性$
◎
Global attributes
</dd>
	<dd>
`type$a
— ~menuの型
◎
type — Type of menu
</dd>
	<dd>
`label$a
— 利用者から可視な~label
◎
label — User-visible label
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
<pre class="idl">
[`HTMLConstructor$I]
interface `HTMLMenuElement@I : `HTMLElement$I {
  [`CEReactions$] attribute DOMString ``type$m;
  [`CEReactions$] attribute DOMString ``label$m;
};
</pre>

</dd>
</dl>


<p>
`menu$e
要素は、~commandの~listを表現する。
◎
The menu element represents a list of commands.
</p>

<div>
<p>
`type@a
属性は、`列挙ed属性$であり，宣言されている~menuの種類を指示する。
次の~keyword値, および対応する状態をとり得る：
</p>

<dl>
	<dt>``context@v</dt>
	<dd>
`popup menu@st
状態に対応付けられる。
</dd>
	<dd>
要素は `Menu$st ~buttonに対する［
文脈~menu／~menu
］を宣言する。
</dd>
	<dd>
この状態にある要素は、ある~popup~menuの~command群を`表現-$する。
利用者は、その~popup~menuが何らかの他の要素を通して
— ［
`contextmenu$a 属性 ／ `button$e 要素の `menu$a 属性
］を介して —
作動化された場合に限り、~command群を検分して対話できる。
</dd>

	<dt>``toolbar@v</dt>
	<dd>
`toolbar@st
状態に対応付けられる。
</dd>
	<dd>
要素は~toolbarを宣言する。
</dd>
	<dd>
<p>
この状態にある要素は、その内容からなる~toolbarを`表現-$する
— 内容は、次のいずれかの形をとる：
</p>
		<ul>
			<li>
要素の子に `li$e 要素があるならば、それらからなる無順序~list
— そのそれぞれが，利用者が［
遂行-／作動化-
］できる~commandを表現する。
</li>
			<li>
他の場合、可用な~command群を記述する`~flow内容$。
</li>
		</ul>
	</dd>
</dl>

<p class="trans-note">【
`popup menu^st,  `toolbar^st
の違いは、前者は一時的に示される一方で，後者は常に示される点にある。
】</p>

<p>
この属性は省略されても~MAY
— `値なしに対する既定の状態$は、［
要素の親も `menu$e 要素であって，親の
`type$a 属性の状態 ~EQ `popup menu$st
ならば `popup menu$st ／
~ELSE_  `toolbar$st
］になる。
</p>

◎
The type attribute is an enumerated attribute indicating the kind of menu being declared. The attribute has two states. The "context" keyword maps to the popup menu state, in which the element is declaring a context menu or the menu for a menu button. The "toolbar" keyword maps to the toolbar state, in which the element is declaring a toolbar. The attribute may also be omitted. The missing value default is the popup menu state if the parent element is a menu element whose type attribute is in the popup menu state; otherwise, it is the toolbar state.
◎
If a menu element's type attribute is in the popup menu state, then the element represents the commands of a popup menu, and the user can only examine and interact with the commands if that popup menu is activated through some other element, either via the contextmenu attribute or the button element's menu attribute.
◎
If a menu element's type attribute is in the toolbar state, then the element represents a toolbar consisting of its contents, in the form of either an unordered list of items (represented by li elements), each of which represents a command that the user can perform or activate, or, if the element has no li element children, flow content describing available commands.
</div>

<p>
`label@a
属性は、~menuの~labelを与える。
それは、~UAが ~UI内で入子にされた~menuを表示するときに利用される
— すなわち，別の~menu %M を下位menuとして包含している文脈~menuは、 %M の `label$a 属性を下位menuの~labelに利用することになる。
この属性が指定される要素は、次をすべて満たす `menu$e 要素に限られ~MUST
⇒
親も `menu$e 要素であって，親の
`type$a 属性の状態 ~EQ `popup menu$st
◎
The label attribute gives the label of the menu. It is used by user agents to display nested menus in the UI: a context menu containing another menu would use the nested menu's label attribute for the submenu's menu label. The label attribute must only be specified on menu elements whose parent element is a menu element whose type attribute is in the popup menu state.
</p>

<hr>

<div class="p">
<p>
次のいずれかを満たす `menu$e は、
`現在~関連する~menu要素@
であるとされる：
</p>

<ul>
	<li>
`現在~関連する~menu要素$の子である
</li>
	<li>
<p>
［
次をすべて満たす `button$e 要素
］が`指名する~pop-up~menu$である：
</p>

<ul><li>`不活$でない 
</li><li>自身, または その先祖に `hidden$a 属性を有する要素はない
</li></ul>

	</li>
</ul>

◎
A menu is a currently relevant menu element if it is the child of a currently relevant menu element, or if it is the designated pop-up menu of a button element that is not inert, does not have a hidden attribute, and is not the descendant of an element with a hidden attribute.
</div>

  
<hr>

<p>
`~menu構成子@
は、 0 個~以上の`~menu~item構成子$からなる有順序~listである。
`~menu~item構成子@
は、次のいずれかである：
◎
A menu construct consists of an ordered list of zero or more menu item constructs, which can be any of:
</p>

<ul>
	<li>
`~command$（ `menuitem$e ）
—  ~commandは
`既定の~command@
にされ得る。
◎
Commands, which can be marked as default commands (menuitem)
</li>
	<li>
`分離子@
（ `hr$e ）
◎
Separators (hr)
</li>
	<li>
他の`~menu構成子$（ `menu$e ）
— それぞれには
`下位menu~label@
が結付けられる。
これは、~listを入子にできるようにする。
◎
Other menu constructs, each with an associated submenu label, which allows the list to be nested (menu)
</li>
</ul>

<p class="algo-head">
~UAは、
`~menuを築いて示す@
ときは，所与の
( `menu$e 要素 %~menu, 要請元~要素 %要請元 )
に対し，次の手続きを走らせ~MUST：
◎
To build and show a menu for a particular menu element source and with a particular element subject as a subject, the user agent must run the following steps:
</p>

  <ol>
	<li>
%~pop-up~menu ~LET
%~menu から`~menu構成子を築いた$結果
◎
Let pop-up menu be the menu construct created by the build a menu construct algorithm when passed the source element.
</li>
	<li>
<p>
%~pop-up~menu を利用者に表示する
— この手続きを呼出した~algoは継続させる（~RET）：
◎
Display pop-up menu to the user, and let the algorithm that invoked this one continue.
</p>
		<ul>
			<li>
利用者が`~menu~item構成子$を選択した時点で，それが依然として［
`~command$を表現する要素
］に対応するならば、~UAは次をし~MUST：
<ul>
	<li>
その~commandの`動作$cFを呼出す
</li>
	<li>
~commandに定義されている`動作$cFが［［
直接的に ／ `合成~click作動化~手続き$~algoを介して
］`~click~eventを発火する$もの
］である場合、その `click$et ~eventの `~relatedTarget0$m 属性は，
%要請元 に初期化する
</li>
</ul>

◎
If the user selects a menu item construct that corresponds to an element that still represents a command when the user selects it, then the UA must invoke that command's Action. If the command's Action is defined as firing a click event, either directly or via the run synthetic click activation steps algorithm, then the relatedTarget attribute of that click event must be initialized to subject.
</li>
			<li>
~pop-up~menuが示されている間は、~DOM内の変更が~menuに反映されては~MUST_NOT。
~menuは，示される前の~DOMから構築され, 変異不可とする。
◎
Pop-up menus must not, while being shown, reflect changes in the DOM. The menu is constructed from the DOM before being shown, and is then immutable.
</li>
		</ul>
	</li>
</ol>

<p class="algo-head">
~UAは、 `menu$e 要素 %要素 から
`~menu構成子を築く@
ときは，次を走らせた結果の`~menu構成子$を返さ~MUST：
◎
To build a menu construct for an element source, the user agent must run the following steps, which return a menu construct:
</p>

  <ol>
	<li>
%出力 ~LET 空の`~menu構成子$
◎
Let generated menu be an empty menu construct.
</li>
	<li>
<p>
( %要素, %出力 )
を与える下で，`~menu~itemを生成する$
◎
Run the menu item generator steps for the menu element using generated menu as the output.
</p>

<p class="algo-head">
`~menu~itemを生成する@
手続きは、所与の
( `menu$e 要素, %出力 )
に対し、次を走らす：
◎
The menu item generator steps for a menu element using a specific menu construct output as output are as follows: For each child node of the menu in tree order, run the appropriate steps from the following list:
</p>

		<ol>
			<li>
<p>
要素の ~EACH ( 子~node %子 ) に対し，`木~順序$で：
</p>
				<ol>
					<li>
<p>
%子 に応じて：
</p>

<dl class="switch">
	<dt>
`~commandを定義する$ `menuitem$e 要素である
◎
If the child is a menuitem element that defines a command
</dt>
	<dd>
%出力 に`~command$を付加する
— その各種`~facet$を~~反映するように
◎
Append the command to output, respecting the command's facets. If the menuitem element has a default attribute, mark the command as being a default command.
</dd>
	<dd>
加えて、 %子 が
<a href="#attr-menuitem-default">`default^a</a>
属性を有する場合は、~commandを`既定の~command$にする。
◎
↑</dd>

	<dt>
`hr$e 要素である
◎
If the child is an hr element
</dt>
	<dd>
%出力 に`分離子$を付加する
◎
Append a separator to output.
</dd>

	<dt>
`label$a 属性を有さない `menu$e 要素である
◎
If the child is a menu element with no label attribute
</dt>
	<dd>

<ol><li>%出力 に新たな`分離子$を付加する
</li><li>( %子, %出力 ) を与える下で，`~menu~itemを生成する$
</li><li>%出力 に新たな`分離子$を付加する
</li></ol>


◎
Append a separator to output, then run the menu item generator steps for this child menu element, using output as the output, then append another separator to output.
</dd>

	<dt>
`label$a 属性を有する `menu$e 要素である
◎
If the child is a menu element with a label attribute
</dt>
	<dd>

<ol><li>%下位menu ~LET %子 から`~menu構成子を築いた$結果
</li><li>%出力 に %下位menu を付加する
</li><li>%下位menu の`下位menu~label$ ~SET %子 の `label$a 属性の値
</li></ol>

◎
Let submenu be the result of running the build a menu construct steps for the child menu element. Then, append submenu to output, using the value of the child menu element's label attribute as the submenu label.
</dd>

	<dt>
他の場合
◎
Otherwise
</dt>
	<dd>
何もしない
— %子 は`無視-$する
◎
Ignore the child node.
</dd>

</dl>

					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%出力 内から，次のいずれかに該当する
`~menu構成子$すべてを除去する：
<ul>
	<li>［
`下位menu~label$ ~EQ 空~文字列
］なるもの
</li><li>［
`~label$cF ~EQ 空~文字列
］なる`~command$を表現するもの
</li></ul>

◎
Remove from output any menu construct whose submenu label is the empty string.
◎
Remove from output any menu item construct representing a command whose Label is the empty string.
</li>
	<li>
%出力 内の各［
連続する複数の`分離子$
］を 1 個の`分離子$に縮退する
◎
Collapse all sequences of two or more adjacent separators in output to a single separator.
</li>
	<li>
~IF［
%出力 内の最初の`~menu~item構成子$は`分離子$である
］
⇒
それを %出力 から除去する
◎
If the first menu item construct in output is a separator, then remove it.
</li>
	<li>
~IF［
%出力 内の最後の`~menu~item構成子$は`分離子$である
］
⇒
それを %出力 から除去する
◎
If the last menu item construct in output is a separator, then remove it.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>


<hr>



<dl class="idl-def">
	<dt>``type@m</dt>
	<dd>
`既知の値のみに制限され$る下で，同じ名前の内容~属性を`反映-$し~MUST。
◎
The type IDL attribute must reflect the content attribute of the same name, limited to only known values.
</dd>

	<dt>``label@m</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
◎
The label IDL attribute must reflect the content attribute of the same name.
</dd>
</dl>


<div class="example">

<p>
`menu$e 要素を利用して 3 個の~menu~buttonを備える~toolbarを記述する例
— 各~buttonは，一連の選択肢からなる~drop-down~menuを有する：
◎
In this example, the menu element is used to describe a toolbar with three menu buttons on it, each of which has a drop down menu with a series of options:
</p>

  
<pre class="html-code">
&lt;menu&gt; 
 &lt;li&gt;
  &lt;button type=menu value="File" menu="filemenu"&gt;
  &lt;menu id="filemenu" type="context"&gt;
   &lt;menuitem onclick="fnew()" label="New..."&gt;
   &lt;menuitem onclick="fopen()" label="Open..."&gt;
   &lt;menuitem onclick="fsave()" label="Save"&gt;
   &lt;menuitem onclick="fsaveas()" label="Save as..."&gt;
  &lt;/menu&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;button type=menu value="Edit" menu="editmenu"&gt;
  &lt;menu id="editmenu" type="context"&gt;
   &lt;menuitem onclick="ecopy()" label="Copy"&gt;
   &lt;menuitem onclick="ecut()" label="Cut"&gt;
   &lt;menuitem onclick="epaste()" label="Paste"&gt;
  &lt;/menu&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;button type=menu value="Help" menu="helpmenu"&gt;
  &lt;menu id="helpmenu" type="context"&gt;
   &lt;menuitem onclick="location='help.html'" label="Help"&gt;
   &lt;menuitem onclick="location='about.html'" label="About"&gt;
  &lt;/menu&gt;
 &lt;/li&gt;
&lt;/menu&gt;
</pre>

<p>
~supportする~UAにおいては、これは次の様な見かけになるであろう（利用者は，2 番目の~buttonを作動化したとする）：
◎
In a supporting user agent, this might look like this (assuming the user has just activated the second button):
</p>

<figure>`sample-toolbar-1^dgm
<figcaption>
~button［
"File", "Edit", "Help"
］を伴う~toolbar。
"Edit" ~buttonを選択すると、更なる選択肢として［
"Copy", "Cut", "Paste"
］を伴う~drop-down~menuが現れる
◎
A toolbar with three buttons, labeled 'File', 'Edit', and 'Help'; where if you select the 'Edit' button you get a drop-down menu with three more options, 'Copy', 'Cut', and 'Paste'.
</figcaption></figure>

</div>


			</section>
			<section id="the-menuitem-element">
<h3 title="The menuitem element">4.11.4. ``menuitem^e 要素</h3>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
~none。
◎
None.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
［
`type$a 属性の状態 ~EQ `popup menu$st
］なる `menu$e 要素の子として。
◎
As a child of a menu element whose type attribute is in the popup menu state.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`~text$。
◎
Text.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`menuitem$e 要素の`終了tag$は、［
直後に［
`menuitem$e ／ `hr$e ／ `menu$e
］要素が来る
］~OR［
親~要素~内に後続する内容が無い
］ならば，省略できる。
◎
A menuitem element's end tag can be omitted if the menuitem element is immediately followed by a menuitem, hr, or menu element, or if there is no more content in the parent element.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
``type$a
— ~commandの型
◎
type — Type of command
</dd>
	<dd>
``label$a
— 利用者から可視な~label
◎
label — User-visible label
</dd>
	<dd>
``icon$a
— ~commandに対する~icon
◎
icon — Icon for the command
</dd>
	<dd>
``disabled$a
— この~form~controlは不能化されるかどうか。
◎
disabled — Whether the form control is disabled
</dd>
	<dd>
``checked$a
— 当の~command／~controlは ~checkされるかどうか
◎
checked — Whether the command or control is checked
</dd>
	<dd>
``radiogroup$a
— 
~radio~button~groupとして扱う一群の~commandに付与する名前
◎
radiogroup — Name of group of commands to treat as a radio button group
</dd>
	<dd>
``default$a
— ~commandを既定の~commandとして~markする
◎
default — Mark the command as being a default command
</dd>
	<dd>
この要素~上の ``title$a 属性には、特別な意味論もある：
~commandの~hintを記述する。
◎
Also, the title attribute has special semantics on this element: Hint describing the command.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>


<pre class="idl">
[`HTMLConstructor$I]
interface `HTMLMenuItemElement@I : `HTMLElement$I {
  [`CEReactions$] attribute DOMString ``type$m;
  [`CEReactions$] attribute DOMString ``label$m;
  [`CEReactions$] attribute USVString ``icon$m;
  [`CEReactions$] attribute boolean ``disabled$m;
  [`CEReactions$] attribute boolean ``checked$m;
  [`CEReactions$] attribute DOMString ``radiogroup$m;
  [`CEReactions$] attribute boolean ``default$m;
};
</pre>

</dd></dl>

<p>
`menuitem$e
要素は、利用者が~popup~menuから呼出せる~commandを表現する（ `contextmenu$a により ／ `Menu$st ~buttonの~menuにより）。
◎
The menuitem element represents a command that the user can invoke from a popup menu (either a context menu or the menu of a menu button).
</p>

<div class="p">
<p>
次のいずれかを満たす `menuitem$e 要素は、新たな~commandを定義する：
</p>

<ul><li>次のいずれかの属性を有する
⇒
``type$a, ``icon$a, ``disabled$a, ``checked$a, ``radiogroup$a
</li><li>空でない`~label$を有する
</li></ul>

◎
A menuitem element that uses one or more of the type, icon, disabled, checked, and radiogroup attributes, or has a non-empty label, defines a new command.
</div>

<hr>

<div>
<p>
``type@a
属性は、~commandの種類を指示する`列挙ed属性$であり，次の 3 種の~keywordと対応する状態をとり得る：
</p>

<dl>
	<dt>``command@v</dt>
	<dd>
``Command@st 状態に対応付けられる。
</dd>
	<dd>
要素は、ある動作が結付けられた，通常の~commandを`表現-$する。
</dd>

	<dt>``checkbox@v</dt>
	<dd>
``Checkbox@st 状態に対応付けられる。
</dd>
	<dd>
要素は、~toggleできる 状態または選択肢を`表現-$する。
</dd>

	<dt>``radio@v</dt>
	<dd>
``Radio@st 状態に対応付けられる。
</dd>
	<dd>
要素は、一連の~itemから選択される 1 個の~itemを`表現-$する。
</dd>

</dl>

<p>
`値なしに対する既定の状態$は、 ``Command$st とする。
</p>
◎
The type attribute indicates the kind of command: either a normal command with an associated action, or a state or option that can be toggled, or a selection of one item from a list of items.
◎
The attribute is an enumerated attribute with three keywords and states. The "command" keyword maps to the Command state, the "checkbox" keyword maps to the Checkbox state, and the "radio" keyword maps to the Radio state. The missing value default is the Command state.

<dl lang="en"><dt>The Command state
</dt><dd>The element represents a normal command with an associated action.

</dd><dt>The Checkbox state
</dt><dd>The element represents a state or option that can be toggled.

</dd><dt>The Radio state
</dt><dd>The element represents a selection of one item from a list of items.
</dd></dl>
</div>


<p>
``label@a
属性は、利用者に示される~command名を与える。
この属性に指定する値は、空でない文字列で~MUST。
◎
The label attribute gives the name of the command, as shown to the user. If the label attribute is specified, it must have a value that is not the empty string.
</p>

<p>
`menuitem$e 要素の
`~label@
は、［
要素が ``label$a 内容~属性を有していて その値が空~文字列でないならば それ ／
~ELSE_ 要素の`子~text内容$から`空白を剥いで縮退-$した結果
］とする。
`~label$は、要素が<span>明示的~command</span>~modeにある場合，空~文字列になっては~MUST_NOT。
◎
The label of a menuitem element is the value of the label content attribute, if there is one and its value is not the empty string, or, otherwise, the result of stripping and collapsing whitespace from the child text content of the menuitem element. The label must not be the empty string if the element is in the explicit command mode.
</p>

<div class="p">
<p>
``icon@a
属性は、~commandを表現する絵を与える。
この属性に指定する値は、`前後~空白~可の妥当かつ空でない~URL$で~MUST。
~UAは、~iconの`絶対~URL$を得るときは，次に従わ~MUST：
</p> 

<ol>
	<li>
~IF［
要素はこの属性を有する
］~AND［
その値 %V は空~文字列でない
］~AND
%V を要素の `~node文書$に`相対的に構文解析-$した結果 ~NEQ ~error
］
⇒
~RET その結果
</li>
	<li>
~RET ε （~iconなし）
</li>
</ol>

◎
The icon attribute gives a picture that represents the command. If the attribute is specified, the attribute's value must contain a valid non-empty URL potentially surrounded by spaces. To obtain the absolute URL of the icon when the attribute's value is not the empty string, the attribute's value must be parsed relative to the element's node document. When the attribute is absent, or its value is the empty string, or parsing its value fails, there is no icon.
</div>


<p>
``disabled@a
属性は、`真偽~属性$であり，在するならば，~commandは 現在の状態においては可用でないことを指示する。
◎
The disabled attribute is a boolean attribute that, if present, indicates that the command is not available in the current state.
</p>

<p class="note">注記：
``disabled$a （不能化される）と `hidden$a （隠-される）との差異は微妙である。
~commandは、ある文脈において，状況のある側面が変化した場合には可能化できるならば、不能化されるものになるであろう。
その状況では，~commandは決して可能化されないならば、隠-されるものになるであろう。
例えば，水道の蛇口の文脈~menuにおいて、~command “開ける” は 蛇口がすでに開いていれば不能化されるであろうが，~command “食べる” は 隠-されるものになるであろう
— 蛇口が食べられることは決してないので。
◎
The distinction between disabled and hidden is subtle. A command would be disabled if, in the same context, it could be enabled if only certain aspects of the situation were changed. A command would be marked as hidden if, in that situation, the command will never be enabled. For example, in the context menu for a water faucet, the command "open" might be disabled if the faucet is already open, but the command "eat" would be marked hidden since the faucet could never be eaten.
</p>

<p>
``checked@a
属性は，`真偽~属性$であり、在するならば，~commandは選択-済みであることを指示する。
この属性は、［
``type$a 属性の状態 ~IN { ``Checkbox$st, ``Radio$st }
でない限り，省略され~MUST。
◎
The checked attribute is a boolean attribute that, if present, indicates that the command is selected. The attribute must be omitted unless the type attribute is in either the Checkbox state or the Radio state.
</p>

<p>
``radiogroup@a
属性は、［
``type$a 属性の状態 ~EQ ``Radio$st
］なる~command群に付与する名前を与える
— 同じ親を共有する同じ名前が付与された~commandたちは、どれかがオンにされたときに，他がオフにされることになる。
この属性は、［
``type$a 属性の状態 ~NEQ ``Radio$st
］の~commandに対しては、省略され~MUST。
この属性に指定する値は、空であっては~MUST_NOT。
◎
The radiogroup attribute gives the name of the group of commands that will be toggled when the command itself is toggled, for commands whose type attribute has the value "radio". The scope of the name is the child list of the parent element. The attribute must be omitted unless the type attribute is in the Radio state. When specified, the attribute's value must be a non-empty string.
</p>

<hr>

<p>
``title@a
属性は、~commandについて記述する~hintを与える
— それは、利用者向けの~helpとして示され得る。
◎
The title attribute gives a hint describing the command, which might be shown to the user to help them.
</p>

<p>
``default@a
属性は，`真偽~属性$であり、在するならば，［
その~commandは、［
利用者が ~menuを用いる代わりに ~menuの要請元を直接的に作動化した場合
］に，呼出されるものになる
］ことを指示する。
◎
The default attribute indicates, if present, that the command is the one that would have been invoked if the user had directly activated the menu's subject instead of using the menu. The default attribute is a boolean attribute.
</p>

<hr>

<dl class="idl-def">
	<dt>``type@m</dt>
	<dd>
`既知の値のみに制限され$る下で，同じ名前の内容~属性を`反映-$し~MUST。
◎
The type IDL attribute must reflect the content attribute of the same name, limited to only known values.
</dd>

	<dt>``label@m</dt>
	<dd>
被取得時には、［
要素が ``label$a 内容~属性を有するならば その属性の値 ／
~ELSE_ 要素の `~label$
］を返さ~MUST。
被設定時には、要素の ``label$a 内容~属性を所与の値に設定し~MUST。
◎
The label IDL attribute, on getting, if there is a label content attribute, must return that attribute's value; otherwise, it must return the element's label. On setting, the element's label content attribute must be set to the new value.
</dd>

	<dt>``icon@m</dt>
	<dt>``disabled@m</dt>
	<dt>``checked@m</dt>
	<dt>``radiogroup@m</dt>
	<dt>``default@m</dt>
	<dd>
これらの~IDL属性は、対応する同じ名前の内容~属性を`反映-$し~MUST。
◎
The icon, disabled, checked, and radiogroup, and default IDL attributes must reflect the respective content attributes of the same name.
</dd>

</dl>


<hr>

<p class="algo-head">
要素 %要素 の`不能化~状態$cF ~EQ ~F の下では（可能化される）、
%要素 の `作動化の挙動$は，
%要素 の ``type$a 属性の状態に応じて，次を走らせ~MUST：
◎
If the element's Disabled State is false (enabled) then the element's activation behavior depends on the element's type attribute, as follows:
</p>


<dl class="switch">

	<dt>``Checkbox$st
◎
If the type attribute is in the Checkbox state
</dt>
	<dd>
		<ol>
			<li>
~IF［
%要素 は ``checked$a 属性を有する
］
⇒
~その属性を除去する
</li>
			<li>
~ELSE
⇒
%要素 の ``checked$a 属性 ~SET `checked^l
</li>
		</ol>
◎
If the element has a checked attribute, the UA must remove that attribute. Otherwise, the UA must add a checked attribute, with the literal value "checked".
</dd>

	<dt>``Radio$st
◎
If the type attribute is in the Radio state
</dt>
	<dd>
		<ol>
			<li>
V( %E ) ~LET 要素 %E に対し［
%E は ``radiogroup$a 属性を有するならば その値 ／
~ELSE_ 空~文字列
］を返す関数
</li>
			<li>
~IF［
%要素 の親はない
］
⇒
~RET
</li>
			<li>
<p>
~FOR
%要素 の親の~EACH ( 子 %E ) に対し：
</p>
				<ol>
					<li>
~IF［
%E は `menuitem$e 要素でない
］
⇒
~CONTINUE
</li>
					<li>
~IF［
V( %E ) ~NEQ V( %要素 ) 
］
⇒
~CONTINUE
</li>
					<li>
~IF［
%E は ``checked$a 属性を有する
］
⇒
それを %E から除去する
</li>
				</ol>
			</li>
			<li>
%要素 の ``checked$a 属性 ~SET `checked^l
</li>
		</ol>
◎
If the element has a parent, then the UA must walk the list of child nodes of that parent element, and for each node that is a menuitem element, if that element has a radiogroup attribute whose value exactly matches the current element's (treating missing radiogroup attributes as if they were the empty string), and has a checked attribute, must remove that attribute.
◎
Then, the element's checked attribute must be set to the literal value "checked".
</dd>

	<dt>
他の場合
◎
Otherwise
</dt>
	<dd>
何もしない。
◎
The element's activation behavior is to do nothing.
</dd>

</dl>

<p class="note">注記：
要素に向けて合成 `click$et ~eventを発火しても，上で述べた動作は起こらない。
◎
Firing a synthetic click event at the element does not cause any of the actions described above to happen.
</p>

<p>
要素の `不能化~状態$cF ~EQ ~T（不能化されている）の下では、要素には`作動化の挙動$はない。
◎
If the element's Disabled State is true (disabled) then the element has no activation behavior.
</p>


<p class="note">注記：
`menuitem$e 要素は、
<a href="#the-menu-element">~popup~menuの一部</a>
として以外に具現化されることはない。
◎
The menuitem element is not rendered except as part of a popup menu.
</p>

<div class="example">
<p>
利用者が［
左端, 中央, 右端
］整列の間で~toggleできるような選択肢を伴う~pop-up~menu~buttonの例（例えば、~text~editorの一部を成す~toolbarなど）。
この~menuには分離子もあり，その後に不能化される~menu~item "掲載" が続いている。
◎
Here is an example of a pop-up menu button with three options that let the user toggle between left, center, and right alignment. One could imagine such a toolbar as part of a text editor. The menu also has a separator followed by another menu item labeled "Publish", though that menu item is disabled.
</p>


<pre class="html-code">
&lt;button type=menu menu=editmenu&gt;~command...&lt;/button&gt;
&lt;menu type="context" id="editmenu"&gt;
 &lt;menuitem type="radio" radiogroup="alignment" checked="checked"
          label="左端" icon="icons/alL.png" onclick="setAlign('left')"&gt;
 &lt;menuitem type="radio" radiogroup="alignment"
          label="中央" icon="icons/alC.png" onclick="setAlign('center')"&gt;
 &lt;menuitem type="radio" radiogroup="alignment"
          label="右端" icon="icons/alR.png" onclick="setAlign('right')"&gt;
 &lt;hr&gt;
 &lt;menuitem type="command" disabled
          label="掲載" icon="icons/pub.png" onclick="publish()"&gt;
&lt;/menu&gt;
</pre>
<!-- 
Commands...
"Left"
"Center"
Right"
"Publish"
 -->

</div>


			</section>
			<section id="context-menus">
<h3 title="Context menus">4.11.5. 文脈~menu</h3>

				<section id="declaring-a-context-menu">
<h4 title="Declaring a context menu">4.11.5.1. 文脈~menuの宣言-法</h4>

<div class="p">
<p>
`contextmenu@a
属性は、要素の文脈~menuを与える。
指定する値は、次をすべて満たす要素の`~ID$で~MUST：
</p>

<ul><li>要素と同じ`木$内にある
</li><li>`menu$e 要素である
</li><li>`type$a 属性の状態 ~EQ `popup menu$st
</li></ul>

◎
The contextmenu attribute gives the element's context menu. The value must be the ID of a menu element in the same tree whose type attribute is in the popup menu state.
</div>

<p class="note">注記：
利用者が `contextmenu$a 属性を有する要素~上で右clickしたときは、~UAは，先ず 要素に向けて `contextmenu$et ~eventを発火して、それが取消されなければ， `menu$e 要素に向けて `show$et ~eventを発火することになる。
◎
When a user right-clicks on an element with a contextmenu attribute, the user agent will first fire a contextmenu event at the element, and then, if that event is not canceled, a show event at the menu element.
</p>

<div class="example">

<p>
入力~controlに対する文脈~menuの例：
◎
Here is an example of a context menu for an input control:
</p>

<pre class="html-code">
&lt;form name="npc"&gt;
 &lt;label&gt;キャラクター名：
   &lt;input name=char type=text contextmenu=namemenu required&gt;&lt;/label&gt;
 &lt;menu type=context id=namemenu&gt;
  &lt;menuitem onclick="document.forms.npc.elements.char.value = getRandomName()"&gt;
   ランダムに名前を選ぶ
  &lt;menuitem onclick="prefillFields(document.forms.npc.elements.char.value)"&gt;
   名前に基づいて他の欄を埋める
 &lt;/menu&gt;
&lt;/form&gt;
</pre>

<!-- 
<form name="npc">
 <label>Character name: <input name=char type=text contextmenu=namemenu required></label>
 <menu type=context id=namemenu>
  <menuitem onclick="document.forms.npc.elements.char.value = getRandomName()">
   Pick random name
  <menuitem onclick="prefillFields(document.forms.npc.elements.char.value)">
   Prefill other fields based on name
 </menu>
</form>
 -->

<p>
これは、~controlの文脈~menuに 2 個の~item［
"ランダムに名前を選ぶ",
"名前に基づいて他の欄を埋める"
］を追加する。
それらは、（例には~~示されていない）ある~scriptを呼出す。
◎
This adds two items to the control's context menu, one called "Pick random name", and one called "Prefill other fields based on name". They invoke scripts that are not shown in the example above.
</p>

</div>


				</section>
				<section id="context-menu-processing-model">
<h4 title="Processing model">4.11.5.2. 処理~model</h4>

<span id="processing-model-4"></span>

<div class="p">
<p class="algo-head">
要素 %E に
`割当てられている文脈~menu@
とは、所与の時点で，次を走らせて得られる ［
`menu$e 要素, または~NULL
］である：
</p>

<ol>
	<li>
<p>
~IF［
%E は `contextmenu$a 属性を有する
］：
</p>

		<ol>
			<li>
%V ~LET その属性の値
</li>
			<li>
<p>
~IF［
次をすべて満たす要素がある
］
⇒
~RET その要素：
</p>

<ol><li>%E の`木$内にある
</li><li>~ID ~EQ %V
</li><li>前 2 項を満たす要素のうち，`木~順序$で最初の要素である
</li><li>`menu$e 要素である
</li><li>`type$a 属性の状態 ~EQ `popup menu$st
</li></ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
%E の親~要素 %P はある
］
⇒
~RET %P に`割当てられている文脈~menu$
</li>
	<li>
~RET ~NULL
</li>
</ol>
◎
Each element has an assigned context menu, which can be null. If an element A has a contextmenu attribute, and there is an element with the ID given by A's contextmenu attribute's value in A's tree, and the first such element in tree order is a menu element whose type attribute is in the popup menu state, then A's assigned context menu is that element. Otherwise, if A has a parent element, then A's assigned context menu is the assigned context menu of its parent element. Otherwise, A's assigned context menu is null.
</div>

<p class="algo-head">
要素 %E の文脈~menuが要請されたときは（例： 利用者が，要素を右clickしたとき ／ 文脈~menu~keyを押下げたとき）、~UAは，次の~listから適切な規則を適用し~MUST：
◎
When an element's context menu is requested (e.g. by the user right-clicking the element, or pressing a context menu key), the user agent must apply the appropriate rules from the following list:
</p>

<dl class="switch">
	<dt>
利用者は~pointing装置を用いて文脈~menuを要請した
◎
If the user requested a context menu using a pointing device
</dt>
	<dd>
<p>
%E に向けて， `MouseEvent$I ~interfaceを利用する名前 `contextmenu$et の~eventを，次のように属性を初期化した上で`発火-$する：
</p>

<ul><li>`bubbles$m 属性 ~SET ~T
</li><li>`cancelable$m 属性 ~SET ~T
</li><li>他の属性は、文脈~menuに対する要請として解釈された~gestureの一部として発火された，最後の `MouseEvent$I 利用者~対話~eventと同じ値に初期化する
</li></ul>

◎
The user agent must fire an event named contextmenu at the element for which the menu was requested, using MouseEvent, with the bubbles and cancelable attributes initialized to true, and other attributes initialized to the same values as the last MouseEvent user interaction event that was fired as part of the gesture that was interpreted as a request for the context menu.
</dd>

	<dt>
他の場合
◎
Otherwise
</dt>
	<dd>
%E に向けて，名前 `contextmenu^et の`合成~mouse~eventを発火する$
◎
The user agent must fire a synthetic mouse event named contextmenu at the element for which the menu was requested.

The user agent must fire a synthetic mouse event named contextmenu that bubbles and is cancelable at the element for which the menu was requested.
</dd>
</dl>



<p class="note">注記：
したがって `contextmenu$et ~eventの発火は、概して，［
`mouseup$et ／ `keyup$et
］~eventの既定の動作になる。
正確な~event連列は、~platform規約に基づいて様々になるので，~UAに依存する。
◎
Typically, therefore, the firing of the contextmenu event will be the default action of a mouseup or keyup event. The exact sequence of events is UA-dependent, as it will vary based on platform conventions.
</p>

<p class="algo-head">
`contextmenu$et ~eventの既定の動作は、次を走らせ~MUST：
◎
The default action of the contextmenu event depends on whether or not the element for which the menu was requested has a non-null assigned context menu when the event dispatch has completed, as follows.
</p>

<ol>
	<li>
%要請元 ~LET 当の~menuが要請された要素
</li>
	<li>
%~menu ~LET ~event配送-が完了した時点における
%要請元 に`割当てられている文脈~menu$
</li>
	<li>
<p>
~IF［
%~menu ~EQ ~NULL
］：
</p>
<ol><li>~UAの既定の文脈~menuがあれば、それを示す
</li><li>~RET
</li></ol>
◎
If the assigned context menu of the element for which the menu was requested is null, the default action must be for the user agent to show its default context menu, if it has one.
</li>
	<li>
<p>
%build ~LET %~menu に向けて、次のようにされた~eventを `発火-$した結果：
</p>

<ul ><li>名前 `show$et
</li><li>`RelatedEvent$I ~interfaceを利用する
</li><li>`cancelable$m  属性 ~SET ~T
</li><li>`relatedTarget$m 属性 ~SET %要請元
</li></ul>

◎
Otherwise, let subject be the element for which the menu was requested, and let menu be the assigned context menu of target immediately after the contextmenu event's dispatch has completed. The user agent must run these steps:
◎
Let build be the result of firing an event named show at menu, using RelatedEvent, with the cancelable attribute initialized to true and the relatedTarget attribute initialized to subject.
</li>
	<li>
~IF［
%build ~EQ ~T
］
⇒
( %~menu, %要請元 ) を与える下で，
`~menuを築いて示す$
◎
If build is true, then build and show the menu for menu with subject as the subject.
</li>
</ol>

<p>
~UAは、示される文脈~menuに 既定の文脈~menu（もしあれば）を伴わせて，それへの~accessを提供しても~MAY。
例えば、 2 つの~menuの~menu~itemたちを一緒に併合する，あるいは
既定の~menuの下位menuとして 頁の文脈~menuを提供することもできる。
一般に，~UAには、自前の文脈~menu~itemは目立たなくすることが奨励される
— 作者による文脈~menuに正統的な外観を与えて、文書を “単なる~Web頁” でない “~app” のような使用感が得られるようにするために。
◎
The user agent may also provide access to its default context menu, if any, with the context menu shown. For example, it could merge the menu items from the two menus together, or provide the page's context menu as a submenu of the default menu. In general, user agents are encouraged to de-emphasize their own contextual menu items, so as to give the author's context menu the appearance of legitimacy — to allow documents to feel like "applications" rather than "mere Web pages".
</p>

<p>
利用者が，~UAの既定の文脈~menuに常に~accessできることを確保するため、~UAは，文脈~menu処理~modelを迂回する手段を提供して~MAY。
例えば、~UAは
<kbd>Shift</kbd> ~keyを押下げながらの右clickに対し、常に，
`contextmenu$et ~eventを発火しない代わりに，既定の文脈~menuを示すような仕方で取扱うこともできる。
◎
User agents may provide means for bypassing the context menu processing model, ensuring that the user can always access the UA's default context menus. For example, the user agent could handle right-clicks that have the Shift key depressed in such a way that it does not fire the contextmenu event and instead always shows the default context menu.
</p>

<hr>


<dl class="idl-def">
	<dt>`contextMenu@m</dt>
	<dd>
`contextmenu$a 内容~属性を`反映-$し~MUST。
◎
The contextMenu IDL attribute must reflect the contextmenu content attribute.
</dd>

</dl>


<div class="example">

<p>
次の例の猫の画像（ "cats.jpg" ）には、可能0な~commandが 4 個ある文脈~menuが与えられている：
◎
In this example, an image of cats is given a context menu with four possible commands:
</p>

   
<pre class="html-code">
&lt;img src="cats.jpeg" alt="Cats" contextmenu=catsmenu&gt;
&lt;menu type="context" id="catsmenu"&gt;
 &lt;menuitem label="Pet the kittens" onclick="kittens.pet()"&gt;
 &lt;menuitem label="Cuddle with the kittens" onclick="kittens.cuddle()"&gt;
 &lt;menu label="Feed the kittens"&gt;
  &lt;menuitem label="Fish" onclick="kittens.feed(fish)"&gt;
  &lt;menuitem label="Chicken" onclick="kittens.feed(chicken)"&gt;
 &lt;/menu&gt;
&lt;/menu&gt;
</pre>

<p>
~mouseで~~操作される視覚的~Web~browserの利用者が，画像を右clickしたとき、~browserは、次の様な文脈~menuを~pop-upするであろう：
◎
When a user of a mouse-operated visual Web browser right-clicks on the image, the browser might pop up a context menu like this:
</p>

<figure>`contextmenu-collapsed^dgm

<figcaption>
猫の写真を覆って示される文脈~menu。
~menuは 4 個の~itemからなり、最初の 2 個は，上の~markupに記述された~menu~item（
"Pet the kittens",  "Cuddle with the kittens"
）を提供0している。
3 個目は、下位menu "Feed the kittens" を与えている。
4 個目は、~~区切り~~線の後にあり，
下向きの開閉三角印のみからなる。
◎
A context menu, shown over a picture of cats, with four lines: the first two offering the menu items described in the markup above ('Pet the kittens' and 'Cuddle with the kittens'), the third giving a submenu labeled 'Feed the kittens', and the fourth, after a horizontal splitter, consisting of only a downwards-pointing disclosure triangle.
</figcaption></figure>

<p>
そのような~UAは、利用者が開閉三角印を~clickしたなら，~browserの自前の~commandを示す文脈~menuを展開することになる：
◎
When the user clicks the disclosure triangle, such a user agent would expand the context menu in place, to show the browser's own commands:
</p>

<figure>`contextmenu-expanded^dgm
<figcaption>
結果は、基本的には同じ~UIになるが、~menuはより長くなる
— 開閉三角印は、
"View Image", "Copy Image", "Copy Image Location",
等々の~itemたちに置換される。
◎
This would result in the same basic interface, but with a longer menu; the disclosure triangle having been replaced by items such as 'View Image', 'Copy Image', 'Copy Image Location', and so forth.
</figcaption></figure>

</div>

				</section>
				<section id="the-relatedevent-interfaces">
<h4 title="The RelatedEvent interfaces">4.11.5.3. `RelatedEvent^I ~interface</h4>


<pre class="idl">
[Constructor(DOMString type, optional `RelatedEventInit$I %eventInitDict)]
interface `RelatedEvent@I : `Event$I {
  readonly attribute `EventTarget$I? `relatedTarget$m;
};

dictionary `RelatedEventInit@I : `EventInit$I {
  `EventTarget$I? relatedTarget = null;
};
</pre>

<dl class="domintro">
	<dt>%event . `relatedTarget$m</dt>
	<dd>
この~eventに孕まれる，他の~event~targetを返す。
例えば， `menu$e 要素に向けて `show$et ~eventが発火される場合のそれは、~menuの要請元の要素になる。
◎
Returns the other event target involved in this event. For example, when a show event fires on a menu element, the other event target involved in the event would be the element for which the menu is being shown.
</dd>

</dl>


<dl class="idl-def">
	<dt>`relatedTarget@m</dt>
	<dd>
被取得時には、初期化-時の値を返さ~MUST。
この~IDL属性は、この~eventに関係する他の~event~targetを表現する。
◎
The relatedTarget attribute must return the value it was initialized to. It represents the other event target that is related to the event.
</dd>
</dl>


				</section>
			</section>
			<section id="commands">
<h3 title="Commands">4.11.6. ~command</h3>

				<section id="facets-2">
<h4 title="Facets">4.11.6.1 ~facet</h4>

<p>
`~command@
とは、［
~menu~item ／ ~button ／ ~link
］の背後にある抽象化である。
~commandが定義されたなら、~UIの他の各部品は，同じ~commandを指せるようになる。
それにより、`不能化~状態$cFなどの各種~facetからなる単独の特色機能に，複数箇所から~accessできるようになる。
◎
A command is the abstraction behind menu items, buttons, and links. Once a command is defined, other parts of the interface can refer to the same command, allowing many access points to a single feature to share facets such as the Disabled State.
</p>

<p id="facets">
各~commandは、次の各種
`~facet@
を持つように定義される：
◎
Commands are defined to have the following facets:
</p>

<dl>
	<dt>`~label@cF</dt>
	<dd>
この~commandの，利用者から見える名前。
◎
The name of the command as seen by the user.
</dd>

	<dt>`~access~key@cF</dt>
	<dd>
この~commandを誘発する~keyの組合せであって，~UAにより選択される。
ない場合は ε とする。
◎
A key combination selected by the user agent that triggers the command. A command might not have an Access Key.
</dd>

	<dt>`隠され状態@cF</dt>
	<dd>
~T または ~F 。
この~commandは隠-される（ ~T のとき）かどうかを表す（基本的に，~menu内に示されるべきかどうか）。
◎
Whether the command is hidden or not (basically, whether it should be shown in menus).
</dd>

	<dt>`不能化~状態@cF</dt>
	<dd>
~T または ~F 。
この~commandは、関連していて誘発できる（ ~T のとき）かどうかを表す。
◎
Whether the command is relevant and can be triggered or not.
</dd>

	<dt>`動作@cF</dt>
	<dd>
この~commandを誘発したときに実際に生じる効果。
これは、［
~scriptによる~event~handler ／
`~navigate$先の`~URL$ ／
~form提出
］のいずれにもなり得る。
◎
The actual effect that triggering the command will have. This could be a scripted event handler, a URL to which to navigate, or a form submission.
</dd>
</dl>

<p id="expose-commands-in-ui">
~UAは、次の判定基準すべてを満たすならば，`要素が定義する^tnote
`~command$を公開して~MAY ：
◎
User agents may expose the commands that match the following criteria:
</p>


<ul>
	<li>
~commandの`隠され状態$cF ~EQ ~F（可視）
◎
The Hidden State facet is false (visible)
</li>
	<li>
要素は`文書~内$にある
~AND
その文書が`属する閲覧文脈$ ~NEQ ε
◎
The element is in a document that has an associated browsing context.
</li>
	<li>
要素, および その どの先祖にも， `hidden$a 属性は指定されていない。
◎
Neither the element nor any of its ancestors has a hidden attribute specified.
</li>
	<li>
<p>
要素は、次のいずれかを満たす：
</p>

<ul><li>`menuitem$e 要素でない
</li><li>`現在~関連する~menu要素$の子である
</li><li>`~access~key$cF ~NEQ ε
</li></ul>

◎
The element is not a menuitem element, or it is a child of a currently relevant menu element, or it has an Access Key.
</li>

</ul>

<p>
~UAには、これを行うことが奨励される
— とりわけ`~access~key$cFを有する~commandに対し、利用者にそれらの~keyを告知する仕方として。
◎
User agents are encouraged to do this especially for commands that have Access Keys, as a way to advertise those keys to the user.
</p>

  
<p class="example">
例えば、そのような~commandを~UAの~menu~bar内に~listすることもできる。
◎
For example, such commands could be listed in the user agent's menu bar.
</p>

				</section>
				<section id="using-the-a-element-to-define-a-command">
<h4 title="Using the a element to define a command">4.11.6.2. `a^e 要素を用いて~commandを定義する</h4>

<p>
`a$e 要素は、
`href$a 属性を有するならば，`~commandを定義する$。
この~commandの各種`~facet$は、次で与えられる：
◎
An a element with an href attribute defines a command.
</p>

<dl>
	<dt>`~label$cF</dt>
	<dd>
要素の `textContent$m ~IDL属性が返す文字列になる。
◎
The Label of the command is the string given by the element's textContent IDL attribute.
</dd>

	<dt>`~access~key$cF</dt>
	<dd>
要素に`割当てられている~access~key$があれば それになる。
◎
The AccessKey of the command is the element's assigned access key, if any.
</dd>

	<dt>`隠され状態$cF</dt>
	<dd>
要素が `hidden$a 属性を有するならば ~T ／
~ELSE_ ~F
になる。
◎
The Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.
</dd>

	<dt>`不能化~状態$cF</dt>
	<dd>
要素, または その いずれかの先祖が`不活$ならば ~T ／
~ELSE_ ~F
になる。
◎
The Disabled State facet of the command is true if the element or one of its ancestors is inert, and false otherwise.
</dd>

	<dt>`動作$cF</dt>
	<dd>
要素に`作動化の挙動$が定義されているならば、要素~上で`合成~click作動化~手続き$を走らす。
他の場合、単に，要素に向けて`~click~eventを発火する$。
◎
The Action of the command, if the element has a defined activation behavior, is to run synthetic click activation steps on the element. Otherwise, it is just to fire a click event at the element.
</dd>
</dl>



				</section>
				<section id="using-the-button-element-to-define-a-command">
<h4 title="Using the button element to define a command">4.11.6.3. `button^e 要素を用いて~commandを定義する</h4>

<p>
`button$e 要素は、常に`~commandを定義する$。
この~commandの各種`~facet$は、次で与えられる：
◎
A button element always defines a command.
</p>

<dl>
	<dt>`~label$cF</dt>
	<dt>`~access~key$cF</dt>
	<dt>`隠され状態$cF</dt>
	<dt>`動作$cF</dt>
	<dd>
これらは、
<a href="#using-the-a-element-to-define-a-command">`a^e 要素に対するとき</a>
と同様に決定される（前~節を見よ）。
◎
The Label, Access Key, Hidden State, and Action facets of the command are determined as for a elements (see the previous section).
</dd>

	<dt>`不能化~状態$cF</dt>
	<dd>
<p>
要素が次のいずれかを満たすならば ~T ／
~ELSE_ ~F
になる：
</p>

<ul><li>自身またはそのいずれかの先祖は`不活$である
</li><li>`不能化され$ている
</li></ul>

◎
The Disabled State of the command is true if the element or one of its ancestors is inert, or if the element's disabled state is set, and false otherwise.
</dd>
</dl>


				</section>
				<section id="using-the-input-element-to-define-a-command">
<h4 title="Using the input element to define a command">4.11.6.4. ``input^e 要素を用いて~commandを定義する</h4>

  
<p>
`input$e 要素 %E は、［
``type$a 属性の状態 ~IN
{ ``Submit$st, ``Reset$st, ``Image$st, ``Button$st, ``Radio$st, ``Checkbox$st }
］ならば，`~commandを定義する$。
この~commandの各種`~facet$は、次で与えられる：
◎
An input element whose type attribute is in one of the Submit Button, Reset Button, Image Button, Button, Radio Button, or Checkbox states defines a command.
</p>

<dl>
	<dt>`~label$cF</dt>
	<dd>
<p>
次に従って決定される：
◎
The Label of the command is determined as follows:
</p>

  <ul>
	<li>
~IF［
%E の ``type$a 属性の状態 ~IN { ``Submit$st, ``Reset$st, ``Image$st, ``Button$st }
］
⇒
~RET ［ 
%E は ``value$a 属性を有するならば その値 ／
~ELSE_ ~UAが~buttonに既定の~labelをあてがうときに利用する値
— 値は~UA, および~localeに依存する
］
◎
If the type attribute is in one of the Submit Button, Reset Button, Image Button, or Button states, then the Label is the string given by the value attribute, if any, and a UA-dependent, locale-dependent value that the UA uses to label the button itself if the attribute is absent.
</li>
	<li>
~IF［
%E を`~label先~control$とする `label$e 要素がある
］
⇒
~RET 該当するもののうち，`木~順序$で最初のものの `textContent$m が返す値
（これは，~DOMで述べるなら、 %E 上の `labels[0].textContent^c が返す文字列になる。）
◎
Otherwise, if the element is a labeled control, then the Label is the string given by the textContent of the first label element in tree order whose labeled control is the element in question. (In DOM terms, this is the string given by element.labels[0].textContent.)
</li>
	<li>
~RET ［
%E は ``value$a 属性を有するならば その値 ／
~ELSE_ 空~文字列
］
◎
Otherwise, if the value attribute is present, then the Label is the value of that attribute.
◎
Otherwise, the Label is the empty string.
</li>
</ul>

</dd>

	<dt>`~access~key$cF</dt>
	<dd>
要素に`割当てられている~access~key$があれば それになる。
◎
The AccessKey of the command is the element's assigned access key, if any.
</dd>

	<dt>`隠され状態$cF</dt>
	<dd>
要素は `hidden$a 属性を有するならば ~T ／
~ELSE_ ~F
になる。
◎
The Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.
</dd>

	<dt>`不能化~状態$cF</dt>
	<dd>
<p>
要素が次のいずれかを満たすならば ~T ／
~ELSE_ ~F
になる：
</p>

<ul><li>自身またはそのいずれかの先祖は`不活$である
</li><li>`不能化され$ている
</li></ul>

◎
The Disabled State of the command is true if the element or one of its ancestors is inert, or if the element's disabled state is set, and false otherwise.
</dd>

	<dt>`動作$cF</dt>
	<dd>
要素に`作動化の挙動$が定義されているならば、要素~上で`合成~click作動化~手続き$を走らす。
他の場合、単に，要素に向けて`~click~eventを発火する$。
◎
The Action of the command, if the element has a defined activation behavior, is to run synthetic click activation steps on the element. Otherwise, it is just to fire a click event at the element.
</dd>

</dl>



				</section>
				<section id="using-the-option-element-to-define-a-command">
<h4 title="Using the option element to define a command">4.11.6.5. ``option^e 要素を用いて~commandを定義する</h4>

<div >
<p>
`option$e 要素は、次を満たすならば，`~commandを定義する$：
</p>

<ul><li>
先祖に `select$e 要素がある ~AND
</li><li>［
``value$a 属性を有さない 
］~OR［
``value$a 属性を有していて その値 ~NEQ 空~文字列
］
</li></ul>

<p>
この~commandの各種`~facet$は、次で与えられる：
</p>
◎
An option element with an ancestor select element and either no value attribute or a value attribute that is not the empty string defines a command.
</div>

<dl>
	<dt>`~label$cF</dt>
	<dd>
要素は ``label$a 属性を有するならば その値になる。
~ELSE_ ［［
要素の `textContent$m ~IDL属性が返す値
］を `頭部と尾部の空白を剥いだ$結果
］内の各［
連続する複数の`空白類$
］を 1 個の U+0020 SPACE 文字に置換した結果になる。
◎
The Label of the command is the value of the option element's label attribute, if there is one, or else the value of option element's textContent IDL attribute, with leading and trailing whitespace stripped, and with any sequences of two or more space characters replaced by a single U+0020 SPACE character.
</dd>

	<dt>`~access~key$cF</dt>
	<dd>
要素に`割当てられている~access~key$があれば それになる。
◎
The AccessKey of the command is the element's assigned access key, if any.
</dd>

	<dt>`隠され状態$cF</dt>
	<dd>
要素は `hidden$a 属性を有するならば ~T ／
~ELSE_ ~F
になる。
◎
The Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.
</dd>

	<dt>`不能化~状態$cF</dt>
	<dd>
<p>
要素が次のいずれかを満たすならば ~T ／
~ELSE_ ~F
になる。
</p>

<ul ><li>`不能化され$optている
</li><li>最も近い先祖 `select$e 要素は`不能化され$ている
</li><li>自身またはいずれかの先祖は `不活$である
</li></ul>

◎
The Disabled State of the command is true if the element is disabled, or if its nearest ancestor select element is disabled, or if it or one of its ancestors is inert, and false otherwise.
</dd>

	<dt>`動作$cF</dt>
	<dd>
要素に最も近い先祖 `select$e 要素は `multiple$a 属性を有するならば、
要素を`選ぶ$。
他の場合、要素を`~toggleする$。
◎
If the option's nearest ancestor select element has a multiple attribute, the Action of the command is to pick the option element. Otherwise, the Action is to toggle the option element.
</dd>
</dl>


				</section>
				<section id="using-the-menuitem-element-to-define-a-command">
<h4 title="Using the menuitem element to define a command">4.11.6.6 `menuitem^e 要素を用いて~commandを定義する</h4>

<p>
`menuitem$e 要素は、常に `~commandを定義する$。
この~commandの各種`~facet$は、次で与えられる：
◎
A menuitem element always defines a command.
</p>

<dl>
	<dt>`~label$cF</dt>
	<dd>
要素の`~label$になる。
◎
The Label of the command is the element's label.
</dd>

	<dt>`~access~key$cF</dt>
	<dd>
要素に`割当てられている~access~key$があれば それになる。
◎
The AccessKey of the command is the element's assigned access key, if any.
</dd>

	<dt>`隠され状態$cF</dt>
	<dd>
要素は `hidden$a 属性を有するならば ~T／
~ELSE_ ~F
になる。
◎
The Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.
</dd>

	<dt>`不能化~状態$cF</dt>
	<dd>
<p>
要素が次のいずれかを満たすならば ~T ／
~ELSE_ ~F
になる：
</p>

<ul><li>自身またはそのいずれかの先祖は`不活$である
</li><li>`不能化され$ている
</li></ul>

◎
The Disabled State of the command is true if the element or one of its ancestors is inert, or if the element has a disabled attribute, and false otherwise.
</dd>

	<dt>`動作$cF</dt>
	<dd>
要素に`作動化の挙動$が定義されているならば、
要素~上で`合成~click作動化~手続き$を走らす。
他の場合、単に，要素に向けて`~click~eventを発火する$。
◎
The Action of the command, if the element has a defined activation behavior, is to run synthetic click activation steps on the element. Otherwise, it is just to fire a click event at the element.
</dd>

</dl>


				</section>
				<section id="using-the-accesskey-attribute-on-a-label-element-to-define-a-command">
<h4 title="Using the accesskey attribute on a label element to define a command">4.11.6.7. `label^e 要素の `accesskey^a 属性を用いて~commandを定義する</h4>

<div class="p">
<p>
次のすべてを満たす `label$e 要素は、`~commandを定義する$
</p>

<ul><li>`割当てられている~access~key$はある
</li><li>`~label先~control$ ~NEQ ε
</li><li>`~label先~control$は`~commandを定義する$
</li></ul>

<p>
この~commandの各種`~facet$は、次で与えられる：
</p>
◎
A label element that has an assigned access key and a labeled control and whose labeled control defines a command, itself defines a command.
</div>

<dl>
	<dt>`~label$cF</dt>
	<dd>
要素の `textContent$m ~IDL属性が返す値になる。
◎
The Label of the command is the string given by the element's textContent IDL attribute.
</dd>

	<dt>`~access~key$cF</dt>
	<dd>
要素に`割当てられている~access~key$になる。
◎
The AccessKey of the command is the element's assigned access key.
</dd>

	<dt>`隠され状態$cF</dt>
	<dt>`不能化~状態$cF</dt>
	<dt>`動作$cF</dt>
	<dd>
それぞれ、要素の`~label先~control$の対応する~facetと同じになる。
◎
The Hidden State, Disabled State, and Action facets of the command are the same as the respective facets of the element's labeled control.
</dd>
</dl>


				</section>
				<section id="using-the-accesskey-attribute-on-a-legend-element-to-define-a-command">
<h4 title="Using the accesskey attribute on a legend element to define a command">4.11.6.8. `legend^e 要素の `accesskey^a 属性を用いて~commandを定義する</h4>


<div class="p">
<p>
次のすべてを満たす `legend$e 要素は、`~commandを定義する$
</p>

<ul><li>`割当てられている~access~key$はある
</li><li>その親 %F は `fieldset$e 要素である
</li><li>次を全て満たす要素の集合 %S は空でない
	<ul><li>%F の子孫である
	</li><li>自身, および どの先祖も `legend$e 要素でない
	</li><li>`label$e 要素でない
	</li><li>`~commandを定義する$
	</li></ul>
</li></ul>

<p>
この~commandの各種`~facet$は、次で与えられる：
</p>
◎
A legend element that has an assigned access key and is a child of a fieldset element that has a descendant that is not a descendant of the legend element and is neither a label element nor a legend element but that defines a command, itself defines a command.
</div>

<dl>
	<dt>`~label$cF</dt>
	<dd>
要素の `textContent$m ~IDL属性が返す値になる。
◎
The Label of the command is the string given by the element's textContent IDL attribute.
</dd>

	<dt>`~access~key$cF</dt>
	<dd>
要素に `割当てられている~access~key$になる。
◎
The AccessKey of the command is the element's assigned access key.
</dd>

	<dt>`隠され状態$cF</dt>
	<dt>`不能化~状態$cF</dt>
	<dt>`動作$cF</dt>
	<dd>
それぞれ、［
上で与えられた集合 %S 内の要素のうち`木~順序$で最初の要素
］の対応する~facetと同じになる：
◎
The Hidden State, Disabled State, and Action facets of the command are the same as the respective facets of the first element in tree order that is a descendant of the parent of the legend element that defines a command but is not a descendant of the legend element and is neither a label nor a legend element.
</dd>
</dl>


				</section>
				<section id="using-the-accesskey-attribute-to-define-a-command-on-other-elements">
<h4 title="Using the accesskey attribute to define a command on other elements">4.11.6.9. 他の要素~上で `accesskey^a 属性を用いて~commandを定義する</h4>

<p>
要素は、`割当てられている~access~key$があるならば，`~commandを定義する$
— ただし
⇒
そのような要素に対し，これまでのいずれかの節にて［
要素は`~commandを定義する$ものと定義される
］ならば、その節の規則が要素に適用される。
この節が適用されるのは、他の場合に限られる。
◎
An element that has an assigned access key defines a command.
◎
If one of the earlier sections that define elements that define commands define that this element defines a command, then that section applies to this element, and this section does not. Otherwise, this section applies to that element.
</p>

<p>
この~commandの各種`~facet$は、次で与えられる：
</p>

<dl>
	<dt>`~label$cF</dt>
	<dd>
<p>
次で与えられる要素 %E の `textContent$m が返す値になる：
</p>
		<ol>
			<li>
要素を`~label先~control$とする `label$e 要素があるならば、
%E は，それらのうち `木~順序$で最初のもの。
（これは，~DOMで述べるなら、要素~上の `labels[0].textContent^c が返す文字列になる。）
</li>
			<li>
他の場合の %E は要素~自身
</li>
		</ol>

◎
The Label of the command depends on the element. If the element is a labeled control, the textContent of the first label element in tree order whose labeled control is the element in question is the Label (in DOM terms, this is the string given by element.labels[0].textContent). Otherwise, the Label is the textContent of the element itself.
</dd>

	<dt>`~access~key$cF</dt>
	<dd>
要素に`割当てられている~access~key$になる。
◎
The AccessKey of the command is the element's assigned access key.
</dd>

	<dt>`隠され状態$cF</dt>
	<dd>
要素は `hidden$a 属性を有するならば ~T／
~ELSE_ ~F
になる。
◎
The Hidden State of the command is true (hidden) if the element has a hidden attribute, and false otherwise.
</dd>

	<dt>`不能化~状態$cF</dt>
	<dd>
要素または，そのいずれかの先祖が`不活$であるならば ~T ／
~ELSE_ ~F
になる。
◎
The Disabled State of the command is true if the element or one of its ancestors is inert, and false otherwise.
</dd>

	<dt>`動作$cF</dt>
	<dd>
<p>
次の手続きを走らす：
◎
The Action of the command is to run the following steps:
</p>
		<ol>
			<li>
要素を`~focusする手続き$を走らす
◎
Run the focusing steps for the element.
</li>
			<li>
~IF［
要素には`作動化の挙動$が定義されている
］
⇒
要素に対する`合成~click作動化~手続き$を走らす
◎
If the element has a defined activation behavior, run synthetic click activation steps on the element.
</li>
			<li>
~ELSE
⇒
要素に向けて`~click~eventを発火する$
◎
Otherwise, if the element does not have a defined activation behavior, fire a click event at the element.
</li>
		</ol>
	</dd>
</dl> 


				</section>
			</section>
			<section id="the-dialog-element">
<h3 title="The dialog element">4.11.7. ``dialog^e 要素</h3>

`21770^bug


<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$ ／ `~sectioning根$。
◎
Flow content.
◎
Sectioning root.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`~flow内容$が期待される所。
◎
Where flow content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>`~flow内容$
。
◎
Flow content.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>
	<dt>`内容~属性$</dt>
	<dd>`大域~属性$
◎
Global attributes
</dd>
	<dd>
``open$a
— ~dialog~boxを示しているかどうか
◎
open — Whether the dialog box is showing
</dd>
	<dt>`~DOM~interface$</dt>
	<dd>


<pre class="idl">
[`HTMLConstructor$I]
interface `HTMLDialogElement@I : `HTMLElement$I {
  [`CEReactions$] attribute boolean ``open$m;
  attribute DOMString ``returnValue$m;
  [`CEReactions$] void ``show$m(optional (`MouseEvent$I or `Element$I) %anchor);
  [`CEReactions$] void ``showModal$m(optional (`MouseEvent$I or `Element$I) %anchor);
  [`CEReactions$] void ``close$m(optional DOMString %returnValue);
};
</pre>

	</dd>
</dl>

<p>
`dialog$e 要素は、利用者がある~taskを遂行するために対話する ~appの一部を表現する
— 例えば
~dialog~box ／ ~inspector ／ ~window
など。
◎
The dialog element represents a part of an application that a user interacts with to perform a task, for example a dialog box, inspector, or window.
</p>

<p>
`dialog$e 要素の
``open@a
属性は、`真偽~属性$であり、指定された場合，［
要素は 作動中であり，利用者は それと対話できる
］ことを指示する。
◎
The open attribute is a boolean attribute. When specified, it indicates that the dialog element is active and that the user can interact with it.
</p>

<p>
``open$a 属性を有さない
`dialog$e
要素は、利用者に示されるべきでない。
この要件は、~style層を通して間接的に実装されても~MAY。
例えば，`示唆される既定の具現化を~support$する~UAは、この要件を
<a href="~HTMLrendering#rendering">具現化~節</a>
に述べられる~CSS規則を用いて実装する。
◎
A dialog element without an open attribute specified should not be shown to the user. This requirement may be implemented indirectly through the style layer. For example, user agents that support the suggested default rendering implement this requirement using the CSS rules described in the rendering section.
</p>

<p>
`dialog$e 要素には、 `tabindex$a 属性は 指定されては~MUST_NOT。
◎
The tabindex attribute must not be specified on dialog elements.
</p>

<dl class="domintro">
	<dt>%dialog . ``show( [ anchor ] )$m</dt>
	<dd>
`dialog$e 要素を表示する。
◎
Displays the dialog element.
</dd>
	<dd>
提供された引数は、要素が固定される~anchor-pointを与える。
◎
The argument, if provided, provides an anchor point to which the element will be fixed.
</dd>

	<dt>%dialog . ``showModal( [ anchor ] )$m</dt>
	<dd>
`dialog$e 要素を表示して，それを最上端の~modal~dialogにする。
◎
Displays the dialog element and makes it the top-most modal dialog.
</dd>
	<dd>
%anchor 引数は、要素が固定される~anchor-pointを与える。
◎
The argument, if provided, provides an anchor point to which the element will be fixed.
</dd>
	<dd>
この~methodは `autofocus$a 属性を尊守する。
◎
This method honors the autofocus attribute.
</dd>

	<dt>%dialog . ``close$m( [ %result ] )</dt>
	<dd>
`dialog$e 要素を閉じる。
◎
Closes the dialog element.
</dd>
	<dd>
%result 引数は、 `dialog$e の`結果値$を与える。
◎
The argument, if provided, provides a return value.
</dd>

	<dt>%dialog . ``returnValue$m [ = %result ]</dt>
	<dd>
`dialog$e の`結果値$を返す。
◎
Returns the dialog's return value.
</dd>
	<dd>
設定して，`結果値$を更新できる。
◎
Can be set, to update the return value.
</dd>
</dl>


<dl class="idl-def">
	<dt>``show(anchor)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
When the show() method is invoked, the user agent must run the following steps:
</p>

`24718^bug

		<ol>
			<li>
~IF［
此れは ``open$a 属性を有する
］
⇒
~RET
◎
If the element already has an open attribute, then abort these steps.
</li>
			<li>
此れの ``open$a 属性 ~SET 空~文字列
◎
Add an open attribute to the dialog element, whose value is the empty string.
</li>
			<li>
~IF［
%anchor 引数は与えられている
］
⇒
%anchor を用いて
此れの`位置を設定しておく$
◎
↓</li>
			<li>
~ELSE
⇒
此れを`通常の整列$~modeにする
◎
If the show() method was invoked with an argument, set up the position of the dialog element, using that argument as the anchor. Otherwise, set the dialog to the normal alignment mode.
</li>
			<li>
此れを`~dialogとして~focusする$
◎
Run the dialog focusing steps for the dialog element.
</li>
		</ol>
	</dd>
</dl>


<hr>

<p>
各 `文書$は、何個かの `dialog$e 要素からなる~stack
—
`待ち~dialog~stack@
—
を持つ。
それは、`文書$の作成-時には，空に初期化され~MUST。
◎
Each Document has a stack of dialog elements known as the pending dialog stack. When a Document is created, this stack must be initialized to be empty.
</p>

<p>
要素が`待ち~dialog~stack$［
 に追加された／から除去された
］ときは、`上端層$tL［
にも`追加され$tL ／からも`除去され$tL
］~MUST。
`FULLSCREEN$r
◎
When an element is added to the pending dialog stack, it must also be added to the top layer. When an element is removed from the pending dialog stack, it must be removed from the top layer. [FULLSCREEN]
</p>

<dl class="idl-def">
	<dt>``showModal(anchor)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
When the showModal() method is invoked, the user agent must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れは ``open$a 属性を有する
］
⇒
~THROW `InvalidStateError$E
◎
Let subject be the dialog element on which the method was invoked.
◎
If subject already has an open attribute, then throw an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
~IF［
此れは`文書~内$にない
］
⇒
~THROW `InvalidStateError$E
◎
If subject is not in a document, then throw an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
此れの ``open$a 属性 ~SET 空~文字列
◎
Add an open attribute to subject, whose value is the empty string.
</li>
			<li>
~IF［
%anchor 引数は与えられている
］
⇒
%anchor を用いて 此れの`位置を設定しておく$
◎
↓</li>
			<li>
~ELSE
⇒
`dialog$e を`中央寄せ整列$~modeにする
◎
If the showModal() method was invoked with an argument, set up the position of subject, using that argument as the anchor. Otherwise, set the dialog to the centered alignment mode.
</li>
			<li>
此れの`~node文書$を`阻んでいる~modal~dialog$ ~SET 此れ
◎
Let subject's node document be blocked by the modal dialog subject.
</li>
			<li>
此れの`~node文書$の`待ち~dialog~stack$に，此れを積む
◎
Push subject onto subject's node document's pending dialog stack.
</li>
			<li>
此れを`~dialogとして~focusする$
◎
Run the dialog focusing steps for subject.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
所与の時点にて，所与の `dialog$e 要素 %D を
`~dialogとして~focusする@
ときは、次を走らす：
◎
The dialog focusing steps for a dialog element subject are as follows:
</p>

<ol>
	<li>
~IF［
%D は `~control群の所有者~obj$でない
］~OR［
%D は`不活$である
］
⇒
~RET
◎
If for some reason subject is not a control group owner object at this point, or if it is inert, abort these steps.
</li>
	<li>
%~control ~LET %D
</li>
	<li>
%S ~LET %D の`~control群$内の
`不活$でない`~focus可能域$からなる集合
</li>
	<li>
~IF［
%S は空でない
］
⇒
%~control ~SET ［
%S 内に［
`~DOM~anchor$が `autofocus$a 属性を有する
］ものが［
あれば，それらのうち最初のもの ／
なければ %S 内の最初のもの
］］
◎
Let control be the first non-inert focusable area in subject's control group whose DOM anchor has an autofocus attribute specified.
◎
If there isn't one, then let control be the first non-inert focusable area in subject's control group.
◎
If there isn't one of those either, then let control be subject.
</li>
	<li>
%~control を`~focusする手続き$を走らす
◎
Run the focusing steps for control.
</li>
</ol>

<p>
`文書$ %文書 の`待ち~dialog~stack$内にある
`dialog$e 要素 %D が`文書から除去され$たときは、次の手続きを走らせ~MUST：
◎
If at any time a dialog element is removed from a Document, then if that dialog is in that Document's pending dialog stack, the following steps must be run:
</p>

<ol>
	<li>
%D を %文書 の`待ち~dialog~stack$から除去する
◎
Let subject be that dialog element and document be the Document from which it is being removed.
◎
Remove subject from document's pending dialog stack.
</li>
	<li>
%文書 を`阻んでいる~modal~dialog$ ~SET ［
%文書 の`待ち~dialog~stack$は空でないならば ~stackの上端の~dialog ／
~ELSE_ ε
］
◎
If document's pending dialog stack is not empty, then let document be blocked by the modal dialog that is at the top of document's pending dialog stack. Otherwise, let document be no longer blocked by a modal dialog at all.
</li>
</ol>

<dl class="idl-def">
	<dt>``close(returnValue)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>

		<ol>
			<li>
~IF［
%returnValue 引数は与えられていない
］
⇒
%returnValue ~SET ε
</li>
			<li>
( 此れ, %returnValue )
を与える下で，`~dialogを閉じる$
</li>
		</ol>
◎
When the close() method is invoked, the user agent must close the dialog that the method was invoked on. If the method was invoked with an argument, that argument must be used as the return value; otherwise, there is no return value.
</dd>
</dl>


<p class="algo-head">
~UAは，
`~dialogを閉じる@
ときは、所与の
( `dialog$e 要素 %D, 結果値 %結果 （省略時は ε）)
に対し，次の手続きを走らせ~MUST：
◎
When a dialog element subject is to be closed, optionally with a return value result, the user agent must run the following steps:
</p>

<ol>
	<li>
~IF［
%D は ``open$a 属性を有さない
］
⇒
~RET
◎
If subject does not have an open attribute, then abort these steps.
</li>
	<li>
%D の ``open$a 属性を除去する
◎
Remove subject's open attribute.
</li>
	<li>
~IF［
%結果 ~NEQ ε
］
⇒
%D の `結果値$ ~SET %結果
◎
If the argument result was provided, then set the returnValue attribute to the value of result.
</li>
	<li>
%~stack ~LET %D の`~node文書$の`待ち~dialog~stack$
◎
↓</li>
	<li>
<p>
~IF［
%D ~IN %~stack
］：
◎
If subject is in its Document's pending dialog stack, then run these substeps:
</p>
		<ol>
			<li>
%~stack から %D を除去する
◎
Remove subject from that pending dialog stack.
</li>
			<li>
%文書 を`阻んでいる~modal~dialog$ ~SET ［
%文書 の`待ち~dialog~stack$は空でないならば ~stackの上端の~dialog ／
~ELSE_ ε（なし）
］
◎
If that pending dialog stack is not empty, then let subject's node document be blocked by the modal dialog that is at the top of the pending dialog stack. Otherwise, let document be no longer blocked by a modal dialog at all.
</li>
		</ol>
	</li>
	<li>
次を走らす`~taskを待入する$
⇒
%D に向けて名前 `close$et の`単純~eventを発火する$
◎
Queue a task to fire a simple event named close at subject.
</li>
</ol>

<dl class="idl-def">
	<dt>``returnValue@m</dt>
	<dd>
被取得時には、此れの`結果値$を返さ~MUST。
◎
The returnValue IDL attribute, on getting, must return the last value to which it was set. On setting, it must be set to the new value. When the element is created, it must be set to the empty string.
</dd>
	<dd>
被設定時には、此れの`結果値$を所与の値に設定し~MUST。
◎
↑</dd>
</dl>

<p>
各 `dialog$e 要素には，文字列である
`結果値@
が結付けられ、要素の作成-時には，空~文字列にされ~MUST。
</p>

<p class="trans-note">【
“結果値” は、この訳で導入した用語。
原文では、単に “return value” と記されていて，  “~methodの返り値” と区別がつかないので。
それに伴い， 空~文字列の要件も ``returnValue$m ~IDL属性の記述からここに移している。
】</p>


<hr>

<p><strong>~dialogを取消すとき</strong>：
~UAは、［
`文書$の`待ち~dialog~stack$が空でない
］ときは、［
その上端にある `dialog$e 要素 %D
］に対し， ［
%D の作動化-時に，次を走らす`~taskを待入する$
］ような~UIを提供して~MAY：
◎
Canceling dialogs: When a Document's pending dialog stack is not empty, user agents may provide a user interface that, upon activation, queues a task to run these steps:
◎
Let dialog be the top dialog element on the Document's pending dialog stack.
</p>

<ol>
	<li>
%close ~LET %D に向けて、名前 `cancel$et の~eventを，［
`cancelable$m  属性 ~SET ~T
］に初期化した上で `発火-$した結果
◎
Let close be the result of firing an event named cancel at dialog, with the cancelable attribute initialized to true.
</li>
	<li>
~IF［
%close ~EQ ~T
］~AND［
%D は ``open$a 属性を有する
］
⇒
( %D, ε )
を与える下で，`~dialogを閉じる$ 
◎
If close is true and dialog has an open attribute, then close the dialog with no return value.
</li>
</ol>

<p class="note">注記：
そのような~UI仕組みの例としては、利用者が <kbd>Escape</kbd> ~keyを押下げるときが挙げられる。
◎
An example of such a UI mechanism would be the user pressing the "Escape" key.
</p>


<hr>

<p>
どの `dialog$e 要素も、［
`通常の整列@,
`中央寄せ整列@,
`~magic整列@
］のうち，いずれかの~modeで配置される。
`dialog$e 要素の作成-時には、`通常の整列$~modeにされ~MUST。
この~mode下では、要素には通常の~CSS要件が適用される。
`中央寄せ整列$~modeが利用されるのは、`上端層$tLにある `dialog$e 要素に限られる。
`FULLSCREEN$r
`CSS$r
◎
All dialog elements are always in one of three modes: normal alignment, centered alignment, and magic alignment. When a dialog element is created, it must be placed in the normal alignment mode. In this mode, normal CSS requirements apply to the element. The centered alignment mode is only used for dialog elements that are in the top layer. [FULLSCREEN] [CSS]
</p>

<p>
~UAは、`中央寄せ整列$~modeの `dialog$e 要素に対しては：
</p>

<ul>
	<li>
<p>
描画~boxを新たに作成するときは、［
要素の`top$p ~propの`使用値$を計算する目的0
］における［
~boxの`静的~位置$の上端
］を，~boxが次を満たすように配置される値に設定しておか~MUST：
</p>

		<dl class="switch">
			<dt>~boxの縦幅 ~LT `表示域$の縦幅 の場合</dt>
			<dd>
［
`表示域$の上端から~boxの上端`~margin辺$までの距離
］~EQ［
`表示域$の下端から~boxの下端`~margin辺$までの距離
］
</dd>
			<dt>他の場合</dt>
			<dd>
~boxの上端`~margin辺$と`表示域$の上端とが一致する
</dd>
</dl>

◎
When an element subject is placed in centered alignment mode, and when it is in that mode and has new rendering boxes created, the user agent must set up the element such that its top static position, for the purposes of calculating the used value of the 'top' property, is the value that would place the element's top margin edge as far from the top of the viewport as the element's bottom margin edge from the bottom of the viewport, if the element's height is less than the height of the viewport, and otherwise is the value that would place the element's top margin edge at the top of the viewport.
</li>
	<li>
要素が<a href="rendering.html#being-rendered">具現化され</a>ている下で，`表示域$の横幅が変化したときは、前項に従って`静的~位置$の上端を再~計算して，要素の~boxを再~作成し~MUST。
 <!-- (as measured in CSS pixels) ＊不要
閲覧文脈 * 不要
 -->
◎
If there is a dialog element with centered alignment and that is being rendered when its browsing context changes viewport width (as measured in CSS pixels), then the user agent must recreate the element's boxes, recalculating its top static position as in the previous paragraph.
</li>
	<li>
この`静的~位置$の上端は、要素の~boxが再~作成されるまで，保たれ~MUST。
（要素の`静的~位置$は、 `top$p ~propの`使用値$を計算するときに限り利用される。
それは、ある種の状況では利用されない
— 例として、要素の位置が  `position$p ~propが `static^v に設定された場合。）
◎
This top static position of a dialog element with centered alignment must remain the element's top static position until its boxes are recreated. (The element's static position is only used in calculating the used value of the 'top' property in certain situations; it's not used, for instance, to position the element if its 'position' property is set to 'static'.)
</li>
</ul>

<p class="algo-head">
~UAは、~anchor %~anchor を用いて，要素 %D の
`位置を設定しておく@
ときは，次の手続きを走らせ~MUST：
◎
When a user agent is to set up the position of an element subject using an anchor anchor, it must run the following steps:
</p>


<ol>
	<li>
%~anchor要素 ~LET %~anchor
◎
↓</li>
	<li>
<p>
~IF［
%~anchor は `MouseEvent$I ~objである
］：
◎
If anchor is a MouseEvent object, then run these substeps:
</p>
		<ol>
			<li>
%~target ~LET %~anchor の~target要素
</li>
			<li>
~IF［
%~target には描画される~boxはない
］~OR［
%~target と %D は異なる文書~内にある
］
⇒
%D を`中央寄せ整列$~modeにする；<br />
~RET
◎
If anchor's target element does not have a rendered box, or is in a different document than subject, then let subject be in the centered alignment mode, and abort the set up the position steps.
</li>
	<li>
<p>
%~anchor要素 ~SET 次のように描画される~boxを生成する匿名 “要素”：
</p>

<ul><li>縦幅, 横幅 ともに 0 
（ `~margin~box$, `~border~box$ ともに一点になる)
</li><li>( 上端, 左端 ) は、~eventの座標（~eventが生じた地点）に位置する
</li><li>その各種~propは、すべて，それぞれの初期値に算出される
</li></ul>

◎
Let anchor element be an anonymous element rendered as a box with zero height and width (so its margin box and border box both just form a point), positioned so that its top and left are at the coordinate identified by the event, and whose properties all compute to their initial values.
</li>
		</ol>
	</li>
	<li>
%D を［
%~anchor要素 に対する`~magic整列$~mode
］にする
◎
Otherwise, let anchor element be anchor.
◎
Put subject in the magic alignment mode, aligned to anchor element.
</li>
</ol>

<p>
要素 %A が［
要素 %B に対する`~magic整列$~mode
］にされている間は、次の要件が適用される：
◎
While an element A has magic alignment, aligned to an element B, the following requirements apply:
</p>

<ul>
	<li>
<p>
どの時点であれ，次のいずれかが生じたときは、
%D を［
%D ~IN `待ち~dialog~stack$ ならば  `中央寄せ整列$~mode ／
~ELSE_ `通常の整列$~mode
］にする：
</p>

<ul ><li>%A, %B いずれかの~boxは描画されなくなった
</li><li>%A, %B が同じ`文書$内でなくなった
</li><li>%B は`木~順序$で %A に先行しなくなった
</li></ul>

◎
If at any time either A or B cease having rendered boxes, A and B cease being in the same Document, or B ceases being earlier than A in tree order, then, if subject is in the pending dialog stack, let subject's mode become centered alignment, otherwise, let subject's mode become normal alignment.
</li>
	<li>
<p>
%A の`position$p ~propは、 `absolute-anchored$v に算出され~MUST
— 通常の規則に代わって（すなわち、 `position$p ~propの`指定値$は無視される）。
◎
A's 'position' property must compute to the keyword 'absolute-anchored' rather than whatever it would otherwise compute to (i.e. the 'position' property's specified value is ignored).
</p>

<p class="note">注記：
`absolute-anchored$v ~keywordの要件は、下に述べる。
◎
The 'absolute-anchored' keyword's requirements are described below.
</p>

	</li>
	<li>
<p>
%A, %B の~anchor-pointは、次に従って定義される：
◎
The anchor points for A and B are defined as per the appropriate entry in the following list:
</p>

<ul><li>%pA ~LET %A の`anchor-point$p の`算出値$
</li><li>%pB ~LET %B の`anchor-point$p の`算出値$
</li><li>%boxA ~LET %A の`首~box$の`~margin~box$
</li><li>%boxB ~LET %B の`首~box$の`~border~box$
</li></ul>

<p>
%pA, %pB に応じて：
</p>

<dl class="switch">
	<dt>
%pA ~EQ `none^v
~AND
%pB ~EQ `none^v
</dt>
	<dd>
%A の~anchor-pointは、 %A の`首~box$の`~border~box$の中心になる。
◎
↓</dd>
	<dd>
%B の~anchor-pointは、 %boxB の中心になる。
◎
The anchor points of A and B are the center points of their respective first boxes' border boxes.
</dd>

	<dt>
%pA ~EQ `none^v
~AND
%pB ~NEQ `none^v
◎
If the computed value of 'anchor-point' is 'none' on A and a specific point on B
</dt>
	<dd>
まず、 %B の~anchor-pointは %pB になる
◎
The anchor point of B is the point given by its 'anchor-point' property.
</dd>
	<dd>
<p>
%boxB の中心から %boxB の［
左上, 右上, 右下, 左下
］隅へ無限に伸びる 4 本の半直線［
%L1, %L2, %L3, %L4
］（同順）を考える。
以下における語 “域内” は、境界は含まないとする。
◎
If the anchor point of B is the center point of B's first box's border box, then A's anchor point is the center point of its first box's margin box.
◎
Otherwise, A's anchor point is on one of its margin edges. Consider four hypothetical half-infinite lines L1, L2, L3, and L4 that each start in the center of B's first box's border box, and that extend respectively through the top left corner, top right corner, bottom right corner, and bottom left corner of B's first box's border box. A's anchor point is determined by the location of B's anchor point relative to these four hypothetical lines, as follows:
</p>

<p>
%A の~anchor-pointは、%pB の所在に応じて、次で与えられる：
◎
↑</p>

		<dl class="switch">
			<dt>%boxB の中心</dt>
			<dd>
%boxA の中心
◎
↑</dd>
			<dt>%L1, %L2 上</dt>
			<dt>%L1, %L2 で鋭角に囲まれる域内</dt>
			<dd>
%boxA の下端~辺の中点
◎
If the anchor point of B lies on L1 or L2, or inside the area bounded by L1 and L2 that also contains the points above B's first box's border box, then let A's anchor point be the horizontal center of A's bottom margin edge.
</dd>

			<dt>%L3, %L4 上</dt>
			<dt>%L3, %L4 で鋭角に囲まれる域内</dt>
			<dd>
%boxA の上端~辺の中点
◎
Otherwise, if the anchor point of B lies on L3 or L4, or inside the area bounded by L4 and L4 that also contains the points below B's first box's border box, then let A's anchor point be the horizontal center of A's top margin edge.
</dd>

			<dt>%L4, %L1 で鋭角に囲まれる域内</dt>
			<dd>
%boxA の右端~辺の中点
◎
Otherwise, if the anchor point of B lies inside the area bounded by L4 and L1 that also contains the points to the left of B's first box's border box, then let A's anchor point be the vertical center of A's right margin edge.
</dd>

	<dt>%L2, %L3 で鋭角に囲まれる域内</dt>
	<dd>
%boxA の左端~辺の中点
◎
Otherwise, the anchor point of B lies inside the area bounded by L2 and L3 that also contains the points to the right of B's first box's border box; let A's anchor point be the vertical center of A's left margin edge.
</dd>
		</dl>

	</dd>
	<dt>
%pA ~NEQ `none^v
~AND
%pB ~EQ `none^v
◎
If the computed value of 'anchor-point' is a specific point on A and 'none' on B
</dt>

	<dd>
%A の~anchor-pointは %pA になる
◎
The anchor point of A is the point given by its 'anchor-point' property.
</dd>
	<dd>
%B の~anchor-pointは、［
%pA ~EQ `none^v
~AND
%pB ~NEQ `none^v
］の場合において、 "A", "B" の役割を入れ替えたときと同じに決定される。
◎
If the anchor point of A is the center point of A's first box's margin box, then B's anchor point is the center point of its first box's border box.
◎
Otherwise, B's anchor point is on one of its border edges. Consider four hypothetical half-infinite lines L1, L2, L3, and L4 that each start in the center of A's first box's margin box, and that extend respectively through the top left corner, top right corner, bottom right corner, and bottom left corner of A's first box's margin box. B's anchor point is determined by the location of A's anchor point relative to these four hypothetical lines, as follows:
◎
If the anchor point of A lies on L1 or L2, or inside the area bounded by L1 and L2 that also contains the points above A's first box's margin box, then let B's anchor point be the horizontal center of B's bottom border edge.
◎
Otherwise, if the anchor point of A lies on L3 or L4, or inside the area bounded by L4 and L4 that also contains the points below A's first box's margin box, then let B's anchor point be the horizontal center of B's top border edge.
◎
Otherwise, if the anchor point of A lies inside the area bounded by L4 and L1 that also contains the points to the left of A's first box's margin box, then let B's anchor point be the vertical center of B's right border edge.
◎
Otherwise, the anchor point of A lies inside the area bounded by L2 and L3 that also contains the points to the right of A's first box's margin box; let B's anchor point be the vertical center of B's left border edge.
</dd>
	<dt>
%pA ~NEQ `none^v
~AND
%pB ~NEQ `none^v
◎
If the computed value of 'anchor-point' is a specific point on both A and B
</dt>
	<dd>
%A の~anchor-pointは %pA になる。
◎
↓</dd>
<dd >
%B の~anchor-pointは %pB になる。
◎
The anchor points of A and B are the points given by their respective 'anchor-point' properties.
</dd>
</dl>

<p class="note">注記：
上の規則では、一般に
%A に対しては その <em>~margin</em> ~boxを利用する一方で，
%B に対しては その <em>~border</em> ~boxを利用する。
そのわけは、
%A は常に`~margin~box$があり，`~margin~box$を用いれば~dialogを
%boxA  から~offsetして位置させれるようになる一方で、
%B の`~margin~box$はない（例：  `table-cell$v ）か，あっても その位置は はっきりしないこともある（例： `~margin相殺$や `~flow内$にある塊の `clear$p の取扱いに面したとき）。
◎
The rules above generally use A's margin box, but B's border box. This is because while A always has a margin box, and using the margin box allows for the dialog to be positioned offset from the box it is annotating, B sometimes does not have a margin box (e.g. if it is a 'table-cell'), or has a margin box whose position may be not entirely clear (e.g. in the face of margin collapsing and 'clear' handling of in-flow blocks).
</p>

<p>
%B が`~border~box$を持たない事例においては、~UAは，上の~algoに利用される `~border~box$ %boxB に %B の`首~box$の`内容~区画$を利用し~MUST（
これは特に、 `border-collapse$p が `collapse^v にされた~table内の~boxに該当する。）
◎
In cases where B does not have a border box but its border box is used by the algorithm above, user agents must use its first box's content area instead. (This is in particular an issue with boxes in tables that have 'border-collapse' set to 'collapse'.)
</p>

	</li>
	<li>
<p>
要素の `position$p ~propが
`absolute-anchored@v
に算出される場合：
</p>

		<ul>
			<li>
`float$p ~propは、適用されない
— それは `none^v に算出され~MUST。
</li>
			<li>
`display$p ~propの値は、~CSS  仕様の
<a href="~CSS2VISUREN#dis-pos-flo">`display^p, `position^p,  `float^p の関係性</a>節に述べられている表に従って算出され~MUST。
</li>
			<li>
要素の~boxは、絶対~位置決めの規則を用いて位置され~MUST
— その`静的~位置$を、次のように設定する下で
⇒
~boxが その`静的~位置$に位置された場合に，~boxの~anchor-pointは、`~magic整列$~modeにされている要素の~anchor-pointに正確に整列される
</li>
			<li>
この仕方で整列される要素は、絶対位置になる。
他の要素の`包含塊$を決定する目的0においては、~keyword `absolute-anchored$v は， `absolute^v と同様に扱われ~MUST。
</li>
</ul>
◎
When an element's 'position' property computes to 'absolute-anchored', the 'float' property does not apply and must compute to 'none', the 'display' property must compute to a value as described by the table in the section of the CSS specification describing the relationships between 'display', 'position', and 'float', and the element's box must be positioned using the rules for absolute positioning but with its static position set such that if the box is positioned in its static position, its anchor point is exactly aligned over the anchor point of the element to which it is magically aligned. Elements aligned in this way are absolutely positioned. For the purposes of determining the containing block of other elements, the 'absolute-anchored' keyword must be treated like the 'absolute' keyword.
</li>
</ul>

<p class="note">注記：
描画される~boxがない要素の自明な例には `display$p ~propが  `none^v に算出されるものが挙げられるが、他にも多くの事例がある
— 例えば ~table~columnは~boxを持たない（それらの~propは、単に他の~boxに影響するだけである）。
◎
The trivial example of an element that does not have a rendered box is one whose 'display' property computes to 'none'. However, there are many other cases; e.g. table columns do not have boxes (their properties merely affect other boxes).
</p>

<p class="note">注記：
要素の~anchor先の要素の描画が変化した場合、
~anchor元の要素も，それに則って位置が改められることになる（
言い換えれば、上の要件は~liveであり，その計算は一度だけで済むわけでない。）
◎
If an element to which another element is anchored changes rendering, the anchored element will be repositioned accordingly. (In other words, the requirements above are live, they are not just calculated once per anchored element.)
</p>

<p class="note">注記：
~keyword `absolute-anchored$v は、~CSS内には指定できない。
`position$p ~propがこの値に算出され得るのは、
`dialog$e 要素が 上で述べた~APIを介して位置される場合に限られる。
◎
The 'absolute-anchored' keyword is not a keyword that can be specified in CSS; the 'position' property can only compute to this value if the dialog element is positioned via the APIs described above.
</p>

<p>
視覚的かつ対話的な媒体の~UAは、利用者が `表示域$を~panして `dialog$e 要素の`~border~box$のすべての部位に~accessできるようにするべきである
— 要素が `表示域$より大きく，`表示域$に~scrollの仕組みがないときでも（例：`表示域$の `overflow$p ~propが `hidden^v に設定されている）。
◎
User agents in visual interactive media should allow the user to pan the viewport to access all parts of a dialog element's border box, even if the element is larger than the viewport and the viewport would otherwise not have a scroll mechanism (e.g. because the viewport's 'overflow' property is set to 'hidden').
</p>

<hr>

<dl class="idl-def">
	<dt>``open@m</dt>
	<dd>
~IDL属性は、 ``open$a 内容~属性を`反映-$し~MUST。
◎
The open IDL attribute must reflect the open content attribute.
</dd>
</dl>


<div class="example">
<p>
次の~dialog~boxには、細則事項（ `small^e ）がある。
より重要な部位へ利用者の注目を引くため， `main$e 要素が利用されている：
◎
This dialog box has some small print. The main element is used to draw the user's attention to the more important parts.
</p>

<pre class="html-code">
&lt;dialog&gt;
 &lt;h1&gt;Add to Wallet&lt;/h1&gt;
 &lt;main&gt;
  &lt;p&gt;How many gold coins do you want to add to your wallet?&lt;/p&gt;
  &lt;p&gt;&lt;input name=amt type=number min=0 step=0.01 value=100&gt;&lt;/p&gt;
 &lt;/main&gt;
 &lt;p&gt;&lt;small&gt;You add coins at your own risk.&lt;/small&gt;&lt;/p&gt;
 &lt;p&gt;&lt;label&gt;&lt;input name=round type=checkbox&gt; Only add perfectly round coins &lt;/label&gt;
 &lt;p&gt;&lt;input type=button onclick="submit()" value="Add Coins"&gt;&lt;/p&gt;
&lt;/dialog&gt;
</pre>

  </div>

				<section id="anchor-points">
<h4 title="Anchor points">4.11.7.1 ~anchor-point</h4>

`21581^bug

<p class="critical">
この節は、最終的には~CSS仕様へ移動されることになる
— 担当する編集者が見つかるまでは、暫定的にここに指定される。
◎
This section will eventually be moved to a CSS specification; it is specified here only on an interim basis until an editor can be found to own this.
</p>

`●名^ `anchor-point@p
`●値^ `none^v | `~positionT$
`●初^ `none^v
`●適^ すべての要素
`●継^ されない
`●百^ ~boxの横幅と縦幅を基準にする
— 注釈文を見よ。
◎
refer to width or height of box; see prose
<!--  -->
`●媒^ 視覚的
`●算^ `指定値$ — ただし，長さは絶対~化される
`●ア^ 離散的
`●順^ 文法に従う
`●表終^

<p>
`anchor-point$p
~propは、~dialog~boxが整列される地点を指定する。
各種 値の意味は：
◎
The 'anchor-point' property specifies a point to which dialog boxes are to be aligned.
</p>

<dl>
	<dt>`~positionT$</dt>
	<dd>
~anchor-pointを指示する。
この値は、要素の最初に描画される~boxの`~margin~box$ %B に相対的に解釈され~MUST。
百分率に対しては、横幅, 縦幅とも %B の同じ~~方向の寸法に相対的に計算され~MUST。
`CSSVALUES$r `CSS$r
◎
If the value is a &lt;position&gt;, the anchor point is the point given by the value, which must be interpreted relative to the element's first rendered box's margin box. Percentages must be calculated relative to the element's first rendered box's margin box (specifically, its width for the horizontal position and its height for the vertical position). [CSSVALUES] [CSS]
</dd>

	<dt>`none^v </dt>
	<dd>
明示的な~anchor-pointは定義されないことを指示する。
~UAは、必要とされる~anchor-pointを自動的に選ぶことになる（上述した`位置を設定しておく$手続きに従って）。
<!-- ＊#dom-dialog-open ~methodの定義 -->
◎
If the value is the keyword 'none', then no explicit anchor point is defined. The user agent will pick an anchor point automatically if necessary (as described in the definition of the open() method above).
</dd>
</dl>


				</section>
			</section>
		</section>
</main>

