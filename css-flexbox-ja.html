<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Flexible Box Layout Module Level 1 （日本語訳）</title>

<meta name="keywords" content="フレックス,flex,可変,整列,レイアウト,CSS,仕様,W3C">

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script >
var source_data;

COMMON_DATA.page_state_key = '___CSS';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://drafts.csswg.org/css-flexbox/',
		spec_status: 'ED',
		main: 'MAIN',
		fill_text_link: '#_versions > dd, #references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		val_prop_map: Util.getMapping('_val_prop_map'),
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 160301 spec

	return options;
}

function expand(mapping1){
	var link_map = this.link_map;
	var val_prop_map = this.val_prop_map;
//	var context_prop = '';

	var nesting = '';

	var class_map = {
		p: 'property',
		pe: 'pseudo',
		d: 'descriptor',
		v: 'value',
		t: 'type',
	};

	var tag_map = {
		p: 'code',
		pe: 'code',
		d: 'code',
		v: 'code',
		t: 'var',
		V: 'var',
	};

	if(!source_data.diagrams){
		source_data.diagrams = Object.create(null);
		repeat('#_resources > *[id]', function(e){
			source_data.diagrams[e.id] = e;
		});
	}
	Util.removeParts(source_data.diagrams);

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/【.*?】|⇒|◎[^<◎`]*|%[\w~一-鿆]+|`(.{1,40}?)([$@\^!])(\w*)(?::([\w\-]+))?/g,
			create_html
		),
		mapping1
	);

	Util.rebuildToc('MAIN0', '_toc_list0');// 目次構築
	Util.replaceParts(source_data.diagrams);// 挿入


	function create_html(match, key, indicator, klass, values){
if(!indicator) {
	switch(match.charAt(0)){
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '<\/span>';
		return '：<span class="block">';
	case '◎':
	default:
	}
	var result = nesting + '<span lang="en">' + match.slice(1) + '<\/span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'p': // property
	if( indicator === '@') {
//		context_prop = '#valdef-' + key + '-';
	}
	href = '#propdef-' + key;
	break;
// case 'tp': ＊
case 'pe': 
	text = '::' + key;
	break;
case 'v': // css values
	if(values){
		href = '#valdef-' + val_prop_map[values] + '-' + key
		values = '';
	}

///	href = context_prop + key;
	break;
case 't': // typedef
	text = '&lt;' + key + '&gt;';
	break;
/*
case 'e': // HTML element
	break;
case 'css': // css codes
	break;
*/
case 'V': // variables
	break;
case 'd': // 記述子
	break;
case 'cg':
//		id = 'cg-' + key;
	text = '変更箇所';
	href = '#' + key;
	break;
case 'dgm':
	return '<a id="_dgm-' + key + '">＊</a>'
default:
}


if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

if(values) {
	text = 
		'<span class="css">'
		+ text
		+ ': <code class="value">'
		+ values.replace(/_/g, ' ')
		+ '</code></span>'
}

return text;

	}
}



</script>


<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
feedback:
valdef-flex-basis-auto:auto
valdef-flex-basis-content:content

	valdef-order.integer:valdef-flex-wrap.integer
	valdef-align-items align-self.auto:valdef-justify-content.auto
</script>


<script type="text/plain" id="_val_prop_map">
min:min-width
d:display
f:flex
fd:flex-direction
fg:flex-grow
fs:flex-shrink
fb:flex-basis
fw:flex-wrap
ff:flex-flow
o:order
j:justify-content
ais:align-items
as:align-self
ac:align-content

</script>

<!--%置換データ -->
<script type="text/plain" id="words_table1">
CSSSPEECH:css-speech-ja.html
CSSFLEX:https://drafts.csswg.org/css-flexbox

ISSUES:https://drafts.csswg.org/css-flexbox-1/issues-cr-2012
ISSUES140325:https://drafts.csswg.org/css-flexbox-1/issues-lc-20140325
ISSUES140925:https://drafts.csswg.org/css-flexbox-1/issues-lc-20140925

auto_v:<code class="value">auto</code> 
min-height:min-height
min-width:min-width

●新値:</td></tr><tr><th>新たに定義される値</th><td class="prod">
●新初:</td></tr><tr><th>新たに定義される初期値</th><td>
●新算:</td></tr><tr><th>新たに定義される算出値</th><td>
</script>

<!-- 
	visuren:~CSS21/visuren.html
	visudet:~CSS21/visudet.html
	box:~CSS21/box.html
	page:~CSS21/page.html
	visufx:~CSS21/visufx.html
	cascade:~CSS21/cascade.html
	cascade:https://drafts.csswg.org/css-cascade-3/

	position:https://drafts.csswg.org/css-position-3/
	break0:~TR/css-break-3/
	syntax:https://drafts.csswg.org/css-syntax-3/
	values:https://drafts.csswg.org/css-values-3/
	align:https://drafts.csswg.org/css-align-3/
	overflow:https://drafts.csswg.org/css-overflow-3/
	css-box:https://drafts.csswg.org/css-box/
	mediaqueries:~TR/css3-mediaqueries/
	text:https://drafts.csswg.org/css-text-3/
 -->
<!--%語彙置換データ
英数_／漢字

-->

<script type="text/plain" id="words_table">

	●未解決
caption:
floor:
fraction:
col:column
row:
	縦筋／横筋
	table-row:
	table-column:
	table-cell:
table:
cell:

相殺-:collapse:~
collapse:
	collapsed::collapse 状態
	collapseされ-:collapsed
	uncollapsing: 1
	collapsing:~collapse 処理
	uncollapsed:collapse されない／collapseの逆
	collapseされるかどうか:collapsed and uncollapsed
	~collapse化／~collapsed／~
	開閉／畳む

	●
action:::アクション
accessibility:::アクセス容易性:アクセシビリティ
作動中の:activeな:~::アクティブな
animation:::アニメーション
app:application::アプリ
	counter:::カウンタ
	ツールバー:toolbar:~
sidebar:::サイドバー
bar:::バー
tab:::タブ
header:::ヘッダ
footer:::フッタ
pane:::ペイン
	タブ化された:tabbed
pattern:::パタン
hack:::ハック
browser::ブラウザ
markup:::マークアップ
screen:::スクリーン
	画面
stylesheet:style sheet::スタイルシート
style:::スタイル
	スタイル層:style layer
engine:::エンジン
link:::リンク
support:::サポート
道具:tool:~::ツール
再設定-:reset:~::リセット
木:tree::~:ツリー
	~~区画:entry:
model:::モデル
source:::ソース
code:::コード
module:::モジュール
group:::グループ
scroll:::スクロール
	scrolled:~scrollされ
	scrolling:~scroll
menu:::メニュー
	下位~menu:submenu
	ボタン:button:~
mode:::モード
navigation:::ナビゲーション
逐次的:sequential:~
	sequential navigation
web::::ウェブ
data:::データ
	ルビ:ruby:~

	●順序
序数:ordinal:~
順序:order:~
		 ordered:
順序付け:ordering:~
並替え:reordering:並び替え
並替える:reorder する:並び替える
	並替-:reorder:並び替え
	再順序付け

	reordered
	逆順:reverse
	配置替え:rearrangement／rearranged:

論理的:logical:~
論理:logical:~
視覚的:visual:~
	z ~~方向の順序付け:z-ordering
陳列:display:~
空間的:spatial:~

	●配分／空間／レイアウト
配分法:distributing:~
配分:distribute:~
分布:distribute:~
可用:available:~
矩形:rectangle:~

空間:space::~:スペース
	残された空間:space left
	空いた空間:empty space
収まる:fit する:~
収まら:fit し:~
収まり:fit し:~
	埋め:fill
受取る:receive する:受け取る
自由空間:free-space::free 空間:フリースペース
	余空間／残余空間／余白
	余った:extra
	残りの:remaining
	残された:leftover
	幅:wide
	正:positive
	負:negative
部屋:room:~
	部屋が尽きる:no more room
間隔:spacing:~
合間:between:~

距離:distance:~
左方:leftwards:~
右方:rightwards:~
下方:downwards:~
上方:upwards:~
二次元:two-dimensional:~
二次元の:two-dimensional:~
	二次元データ:2D data

支柱:strut:~
border:::ボーダー
padding:::パディング
margin:::マージン

縮短:shrink::縮短
伸長:grow::伸長
係数:factor:~

基底:basis::~

base:::基底
	均等:evenly
	比例するよう:proportional
	比例分:proportion
	比率:ratio
	等しく／等量:equally
	等しい／等:equal
	等量:equal／equal amount
接合:placed flush:~
伸張:stretch:~
領域:area:~
総和:sum:~
目標:target:~
吸収-:absorb:~
沿いの:方向の
沿いに:方向に
clearance:
節減-:reduce:~

	●レイアウト／整列

layout:::レイアウト
再layout:layout pass::再レイアウト
	反復:pass:~
lay-out:lay out::レイアウト
整形:formatting:~
構造:structure:~
	フォーマッティング
文脈:context:~
	コンテキスト
積層文脈:stacking context:~::スタッキング文脈
層:layer:~::レイヤ
堆積:stack:~::スタック
	積層／積まれて／
匿名:anonymous:~
box:::ボックス
	箱
折返す:wrap する:折り返す
折返し:wrapping:折り返し
折返され:wrap され:折り返され

整列-:align::~
	aligned:~alignされ
	揃える
整列:alignment::~
整列法:aligning::~
基底線:baseline::~:ベースライン
	基底線~整列:baseline alignment:基底線 整列::ベースライン整列

押出され:push され:押し出され
押出す:push する:押し出す
	押しやられ
遭遇-:encounter:~

切詰めた:clamp した:切り詰めた
切詰める:clamp する:切り詰める
切詰めら:clamp さ:切り詰めら
切詰め:clamping:切り詰め
切詰:clamped:切り詰め
切詰後:clamp 後:切り詰め後
転換:transferred:~

	●layout アルゴリズム
algo:algorithm::アルゴリズム
	手続き:steps
	下位手続き:substep
段:step:~
	実行:run
続行-:continue:~

再開始する:restart する:やり直す
	~restart:
	再実行:rerun／re-run
	飛ばす:skip
	先に進んで:skip past
補正-:fix:~
	解消fixing
	節減:reduce:~
違反:violation:~
無視-:ignore:~
凍結:freeze:~
	仮の:hypothetical
内縁:inner:~
外縁:outer:~

収納:pack:~
収納法:packing:~

拘束:constraint:~
不定:indefinite:~
確定的:definite:~
確定性:definiteness:~
無限:infinite:~
収集-:collect:~
未収集の:uncollected:~
	未~収集:uncollected
解決-:resolve:~
解決法:resolving:~
解決:resolution:~
	解決できない:unresolvable
	寄与:contribute:~
	寄与分:contribution:~
供与:contribution:~
	供与-:contribute:~
内在的:intrinsic:~
外在的:extrinsic:~
	固有の
縦横比:aspect-ratio:~::アスペクト比

最小内容:min-content:~
最大内容:max-content:~
min:min-:最小-
max:max-:最大-
	最大:maximum:~
	最小:minimum:~
	最小:smallest
	最大:largest
内容収納:fit-content:~

決定-:determine:~
決定:determination:~
	和:sum

flow:::フロー
	~flow内:in-flow

overflow:
	overflowing:
確立-:establish:~
正規化-:normalize:~
正規化済:normalized:~
拡縮済:scaled:~
昇格-:promote:~

	＊
最初最後の:［最初／最後］の

	●break／頁
頁:page:ページ
頁割付処理:pagination:ページ割り付け処理
頁割付:paginate:ページ割り付け
	割り付け（つつ／できる／られ／た／る／され）
頁先頭:the top of the page:ページ先頭

強制:force:~
強制分断:forced-break::~

分断:break::~
	分断ing:breaking::分断
機会:opportunity:~
	分断~処理:breaking
	分断~機会:break opportunities
	分断され:broken
	分断し得ない:unbreakable
	改行で折り返す:broken onto a new line

断片:fragment:~
	断片~化
断片化法:fragmenting:~
	fragmenter
断片化:fragmentation:~
	断片~化された:~fragmented
	移動:move:~
	~~移動:shift

合成:synthesize::~

	●幾何

縦:vertical:~
縦方向:vertical:~
	縦方向に:vertically
縦書き:vertical:~
横:horizontal:~
横方向:horizontal:~
	横方向に:horizontally
横書き:horizontal:~

横幅:width:~
縦幅:height:~

左端:left:~
上端:top:~
右端:right:~
下端:bottom:~

始端:start:~
終端:end:~
	両端:either end

位置:position:~
直交:orthogonal:~
垂直:perpendicular:~
平行:parallel:~

辺:edge:~

中央:center:~
	中央~寄せ:centered
	中央に寄せる
	中央~寄せ
	中央に据える:centering
	置く:place
配置-:place:~
長さ:length:~
方位:orientation:~
次元:dimension:~
方向:direction:~
	向き

軸:axis:~
size:::サイズ
sizing:::サイズ法
	固定size:fixed-size::固定

固定:fixed:~
延伸-:extend:~
増大-:increase:~

	●flex
level::レベル
行内:inline::~:インライン
行内始端:inline-start:inline-始端:~:インライン始端
行内終端:inline-end:inline-終端:~:インライン終端
行内軸:inline-axis:inline-軸:~:インライン軸
行内level:inline-level::行内レベル:インラインレベル
行内塊:inline-block::行内ブロック:インラインブロック

塊:block::ブロック
塊軸:block-axis:block-軸:ブロック軸
塊始端:block-start:block-始端:ブロック始端
塊終端:block-end:block-終端:ブロック終端
塊level:block-level:~:ブロックレベル
	塊~容器
包含塊:containing block::包含ブロック

包含-:contain:~
	包含している:containing
容器:container::コンテナ

主:main::主:メイン
主size:main-size::主サイズ:メインサイズ
主軸:main-axis:main 軸:主軸:メイン軸
主始端:main-start:main 始端:主始端:メイン始端
主終端:main-end:main 終端:主終端:メイン終端

交叉:cross::交叉:クロス
交叉size:cross-size::交叉サイズ:クロスサイズ
交叉軸:cross-axis:cross 軸:~:クロス軸
交叉始端:cross-start:cross 始端:~:クロス始端
交叉終端:cross-end:cross 終端:~:クロス終端
交叉方向:cross-wise:cross 方向:~

line:::ライン
単line:single-line:単 line:単ライン
複line:multi-line:複 line:複ライン
複柱:multi-column:複 column
行box:line box:行ボックス
包装:wrap::~
包装box:wrapper box:wrapper ボックス:包装ボックス


駒:item::アイテム

flex::::フレックス
	伸縮
flex-level:::flex レベル
flexible:
flex-lines:flex lines::flex ライン
	~flexibleでない:inflexible
		非~flexible
	flex処理:flexing
	flex性:flexibility
		伸縮不可


	●CSS
keyword:::キーワード
zero::ゼロ
font:::フォント
書字:writing:~
	writing-mode
書字mode:writing mode::書字モード
	種類:type
種別:type:~
型:type:~
空白:white-space:~

静的:static:~
媒体:media::~:メディア
query:::クエリ
伝播-:propagate:~

成分:component:~
算出値:computed value:~
使用値:used value:~
使用:used:~
使用-:use:~
指定値:specified value:~
初期値:initial value:~
百分率:percentage:~::パーセント
正準的順序:canonical order:~
被継承:inherited:継承
適用対象:applies to:~

浮動体:float:~
浮動-:float:~
	浮動:floating:~

文法:grammar:~

算出-:compute:~
算出過程:computation:~
計算-:calculate:~
計算:calculation:~

無効:invalid:~
	妥当でない

絶対位置の:absolutely-positioned:絶対位置にされた
絶対位置:absolutely-positioned:~
静的位置:static-position:~
位置決め:positioning:~
offset:::オフセット:~
発話:speech::読み上げ
	speech rendering:話声出力
描画-:render:~
描画:rendering:~
塗り:painting:~
塗られ:paint され:~
auto:
	自動
	~group分け:grouping


prop:property:プロパティ
shorthand::簡略形プロパティ
longhand::下位プロパティ
	簡略形:~shorthand:~
	冗長形:~longhand:~
値:value:~
名前:name:~

単位:unit:~
	単位の無い:unitless
呈示-:present:~
呈示:presentation:~

内容:content:~
文書:document:~
改変-:modify:~
改変文書順:order-modified document order:~
文書順:document order:~
同胞:sibling:~
要素:element:~
text:::テキスト
子:child:~
	一連の子:children
先祖:ancestor:~
子孫:descendant:~
親:parent:~
疑似要素:pseudo-element:~
遷移効果:transition:~
簡略形:shorthand:~

	●仕様
UA:user agent:UA::ユーザエージェント
version:::バージョン
作者:author:~
著作:authoring:~
tool:::ツール
editor:::エディタ
実装-:implement:~
実装:implementation:~
実装者:implementor:~
未定義:undefined:~
定義-:define:~
定義:definition:~
最終草案:Last Call Working Draft:~
勧告候補:Candidate Recommendation:~
単独の:single:~
規則:rule:~
用語:term:~
各種用語:terminology:~
判定基準:criteria:~
適合性:conformance:~
適合-:conform:~
	適合していない:non-conforming
適合:conforming:~
適合的:conformant:適合
仕様:spec:~
	specification
設計-:design:~
設計:design:~
将来:future:~
	参考である:not normative:~
参考:informative:~
正式な:normative:~
拡張:extension:~
拡張-:extend:~
	~~拡張:expand:~
拡幅-:expand:~
依存関係:dependency:~
見本:sample:~
相互作用:interaction:~
適応-:accommodate:~
適切:appropriate:~
方式:manner:~
受容-:accept:~
明示的:explicit:~
目的:purpose:~
直接的:direct:~
直接:direct:~
直接の:direct:~
効率的:efficient:~
導入-:introduce:~
強力:powerful:~
提供-:provide:~
	供する:provide
提供0-:offer:提供
推奨-:recommend:~
許容-:allow:~
概観:overview:~
注目-:focus:~
技法:technique:~
自明:trivial:~
一般用途:common uses:~
能力:capabilities:~
機能性:functionality:~
能:ability:機能
意図的:intentional:~
意図-:intend:~
意図:intent:~
依拠-:rely:~
依存-:depend:~
誂える:tailor する:あつらえる
概して:typical に:~
改良-:improve:~
改善-:improve:~
取組まれ:address され:取り組まれ
共通的に:common に:よく
共通的な:common:よくある
関係性:relationship:~
省略-:omit:~
解釈-:interpret:~
誤解釈:misinterpretation:~
避ける:avoid する:~
	要約-:summarize:~
挙動:behavior:ふるまい
挙動する:behave する:ふるまう
状況:situation:~
状況下:circumstances:~
可読性:readability:~
理論的簡潔さ:theoretical simplicity:~
不安定:fragile:~
複雑:complex:~
詳細:details:~
混同:confusion:~
高価:expensive:~
高度な:advanced:~
明確化-:clarify:~
明確化:clarifications:~
基本的な:basic:~
	~~帰結 corollary
	~~提示-:submit
	この~~目的のため、:To this end,
下層の:underlying:~
事例:case:~
	範囲:range:~
支援:aid:~
取扱う:handle する:取り扱う
取扱い:handling:取り扱い
取扱われ:handle され:取り扱われ
正す:correct する:~
正した:correct した:~
正しく:correct に:~
正しい:correct な:~
指示-:indicate:~
収束-:converge:~
訂正-:amend:~
前提:assumption:~
単純化-:simplify:~
問題:problem:~
困難:difficult:~
図式:diagram:~
側面:aspect:~
	意味:meaning:~
	意味-:mean:~
提案:proposal:~
働く:work する:~
演習:exercise:~
特典:bonus:~
見做して:assume して:~
解く:solve する:~
関連する:relevant な:~
表面的:superficial:~
保証-:guarantee:~
一般:general:~
改称-:rename:~
懸念:concern:~
処理能:performance:~
防止-:prevent:~
適度:reasonable:~
完璧:perfect:~
	insanely ひどく
要求-:require:~
	捉える:capture する
変更点:changes:~
変更:change:~
有意な:significant:~
主要な:substantive:~
	~~主要な:major
特別:special:~
合意:consensus:~
経験則:heuristic:~
考慮点:considerations:~
保安:security::セキュリティ
privacy:::プライバシー
誤り:error:~
見なさ:consider さ:~
技術:technology:~
制止-:preclude:~
特色機能:feature:~
技術的:technical:~
干渉-:interfere:~

	●未分類
選好:preferred:~
~~転化する:transmute

首の:primary:主となる
	変化:change
獲得-:acquire:~
漏洩:leaks:~
展開-:expand:~
近似:approximation:~
	退化する degenerate
hover:
drag-and-drop:::ドラッグ＆ドロップ
block:::ブロック
対応関係:mapping:~
入子:nesting:入れ子
一次元的:linear:~
既定の:default:~
既定:default:~
生成-:generate:~
生成:generation:~
具現化法:rendering:~::レンダリング
効果:effect:~
適用-:apply:~
	適用し得るかどうか:applicability:~
等価:equivalent:~
動的:dynamic:~
自動的:automatic:~
	自動:auto:~
指定-:specify:~
指定:specified:~
未指定の:unspecified:~
設定-:set:~
設定群:settings:~
初期設定:initial setup:~
生きた:live:~
外側:outside:~
内側:inside:~
	側:side
絶対的:absolute:~
絶対化:absolute 化:~
相対的:relative:~
相対する:relative な:~
影響-:affect:~
暗黙の:implied:~
関与-:participate:~
走査-:traverse:~
走査:traversal:~
到達-:reach:~
独立:independent:~
物理的:physical:~
誘発-:trigger:~
調整:adjustment:~
分割-:split:~
画像:image:~
再現-:reproduce:~
構文:syntax:~
妥当:valid:~
制御:control:~
継続-:continue:~
検査:check:~
最適化-:optimize:~
作成-:create:~
作成:creation:~
宣言:declaration:~
変換-:convert:~
変換:conversion:~
制限:limit:~
ゼロ:zero:~
全部的:full:~
単純:simple:~
相違:difference:~

切替える:switch する:切り替える
組合せる:combine する:組み合せる
空:empty:~
完全:complete:~
	完結した:completed
前置-:precede:~
実質的:effective:~
代用:substitute:~
既存の:existing:~
新たな:new:~
現在の:current:~
表現-:represent:~
正確:exact:~
正確0:accurate:正確
置換-:replace:~
合致-:match:~
維持:maintain:~
入換わる:swap される:入れ換わる
安定-:stable に keep:~
見出され:find され:~
見出して:find して:~
見出す:find する:~
侵入-:intrude:~
初期:initial:~
形成-:form:~
築く:build する:~
上書き:override:~
費やさ:consume さ:~
日本語:Japanese:~
英語:English:~

</script>

<!--%他の語
不連続性:discontinuity:~
公開-:expose:~
写真:photo:~
巡回:cycling:~
減算-:subtract:~
測定:measuring:~
目録:catalog:~
見出し:title:~
購入:purchase:~
部品:parts:~
勧める:encourage する:~
~~分岐variance
繰り返し
繰返され:repeat され:繰り返され
繰返す:repeat する:繰り返す
	関係する:relative:~

	~~現実の the world
	嫌らしいsucks
	すべからくentirely
		performing: 4
		respecting: 1
		後続する
	+:~PLUS
	Media Queries:media queries
	UI:interface
	則って:according to
	against: 8
	already: 10
	among: 3
	becomes: 5.001
	besides: 1
	box補完:box fixup, box-fixup
	cases: 1
	cause: 8.004
	causing: 1
	come:
	continue: 5
	doesn: 3
	due: 4
	ensure:
	ever: 1
	exactly
	followed:
	follows: 5
	gets: 1
	going: 4
	having: 3
	how: 10
	just: 3
	like: 10
	makes: 13.006
	means: 1
	most: 5
	much: 5
	とは限らない:necessarily: 1
	necessary: 4
	need: 4.001
	neither: 2
	none: 1
	once: 2
	onto: 4
	own: 3
	part: 5.002
	previously: 1
	respect:呼応する／~~尊守
	seen: 1
	share:
	showing: 2
	shows: 3
	sole: 1
	thereof: 1
	thread
	time: 2
	under: 4
	upon: 2
	using: 15
	ways: 3.001
	whichever: 10
	~following: 14
	~linear に:linearly
	~previous: 19
	~table状:tabular format
	~~主に:mainly
	~~先行する:prior
	~~取得:retrieve
	~~対象:subject
	~~明確な:very explicit
	−:minus
	−:~MINUS
	〜から:starting: 14
	見なす:consider
	〜と見なす:treat
	〜に基づく:based
	〜に従う:per 〜
	〜向けて:toward
	あてがう:assigning
	ある程度の制御を供する:exerts some control
	からなる:consists
	させないようにする:prevent
	さほど関わり無く:without much regard
	そのまま:raw
	そのままにされる:intact
	それぞれ／同順:respectively
	それ自身:itself
	できない:failing
	とりわけ:especially
	ほぼ:mostly
	まだ配置されていない:not already laid out
	まで:until
	まるごと／:entirely
	やり直す:redo
	より大:larger
	より小:less than
	より小さい:smaller
	より良い／好ましい:better
	一例:sample
	一部分:fraction
	不備:omission
	不足している:insufficient
	与えられた:given
	中段:middle
	主対象にする:centric
	乱れを最小限に留める:attempt to minimize distortation
	今や:no longer
	今や:now

	他の:other
	代わりに:instead
	以上の点:previous point
	作用:interacts with
	例:example
	依然として，:still
	保ちつつ:preserving
	保つ:keep
	個々の:individual
	元の:original
	先行の:preceding
	入った時点:upon entering
	全体:entire
	処理／取り扱う:handle
	~~扱う:deals
	出現:appearing
	分岐:dichotomy
	別々の…に分ける:separate … distinct
	別に:aside
	利用-:use
	半分:half
	単純なものも:simply
	占める:takes up
	原点:origin position
	反対:opposite
	取って代わられる:superseded
	取り除く／外される:remove
	可能な限り近く:as close to … as possible
	可能な限り／考え得る:possible
	可能にする:allow
	合致する:matches
	合計:combined
	同じ:same
	一致する:identical
	同時に:together
	同様に:likewise
	同様に，:similarly
	同様／類似／似る:similar
	含めた:including
	呼ばれる／称される:called
	問題があるproblematic
	囲う:around
	図:figure
	図示:illustration
	増加:incrementing
	変化:change
	奪う:stolen
	定義する側面がある:defining aspect
	実際の:actual
	容易:easily／easy
	対応する:corresponding
	対応する:respective
	対応付ける:map
	小さく:small
	少なくとも１つ:at least one
	尽きた:ran out
	居残る:leaves behind
	属する:belong to
	常に:always
	幅の狭い:narrow
	年月に渡り 様々な方法で取組まれ:addressed in many ways over the years
	引き上げる:pull-up
	形:shape
	に~~影響される:sensitive
	後方の／~~後の:later
	後続の:subsequent
	得る:achieve
	得る:gains
	応じて:respond
	意味のある:sensible: 1
	戻され:reverted … back
	戻る:return
	手法:method
	抜ける:exit:
	指す:refer
	指定値に従う:as-specified
	挙げられ:listed
	挙げる:list
	揺らがせる:wobble
	損なう:ruin
	操作:manipulate
	操作:operation
	操作中:target
	支援:aid
	改めら:altering
	数:number
	整合する:consistent になる
	書かれる:written
	書き出す:writes
	最低の:lowest
	最初:first
	最後:last
	最終的な:final／
	最終的にeventually
	有意な
	望ましい:desirable
	欲される:desired
	未使用:unused
	欠く:lacks
	次の:next
	残りの部分:rest
	比率:ratio
	気の利いた:intelligent
	決着:finalized:
	深い詳細を理解する強い動機:deep-seated urge to understand arcane details
	渡る:across
	無用に:gratuitously
	特に:In particular: 2
	特有:-specific
	現れる:appear
	生じる:occur
	産み出す:producing
	異なる:different
	真の意味の:true
	示す:illustrates
	種々の:various
	積をとる:multiply

	第二の:secondary
	策定を遅らせ:slow down advancement
	節:section
	終える／最後:finish
	組み替え:mangle
	結び付けられている:associated
	結果:result
	総:overall/total
	繰り返し:repeat し
	~~考慮-:with regards to
	色:color
	色分けされた:colored
	落とし込まれる:fall out
	行う／遂行する:perform:
	補助:helps
	複数の:multiple
	記録:note
	詳細を述べる:detailing
	認識:perception:~
	説明／記述:description
	読み取れる:readable
	読む:read
	課される:imposed／subject to
	調べられる:consulted
	負にならない所まで:down to, but not past, zero
	超えて:beyond
	述べる:described
	述べ易く:easier to talk
	追加して:adding
	追加の:additional
	追加の特典:added bonus
	通常の:normal
	通例的に:as usual
	連続している:contiguous
	連続する:consecutive
	進む:proceed
	遅らせる:slow down
	部分的:partway
	重きが置かれる:biased-to
	長い:long
	開始:starting
	開始:starting from
	間は:during
	関係なく:regardless
	隠す:hide
	隣接:adjacent
	離れた所:apart
	非:non
	順方向:forward direction
	順次に:one by one
	２周目の~layout回:second layout round
	２周目の~layout回:second layout round
addition: 2
bases 誤記？
beginning: 1
colum 誤記
designer: 1
honor:加味
leaving: 2
needed: 1
numbered: 1
operate: 1
produce:~~生成
served: 1
sign: 2
sketch: 1
test: 1
turn into: 1
unlike: 3
wish: 1
~compelling:

-->



<!--%links -->
<script type="text/plain" id="_link_map">

	valdef-order-integer:#<var>&lt;integer&gt;</var>//
	//valdef-number0
	valdef-flex-grow-number:#<var>&lt;number&gt;</var>
	//valdef-number
	valdef-flex-shrink-number:#<var>&lt;number&gt;</var>


確定的:#definite
不定:#definite
改変文書順:#order-modified-document-order

~flex整形~文脈:#flex-formatting-context
~flex~layout:#flex-layout
~flex基底:#flex-flex-basis
~flex~base~size:#flex-base-size
~flex容器:#flex-container
~flex伸長~係数:#flex-flex-grow-factor
~flex縮短~係数:#flex-flex-shrink-factor
~flex駒:#flex-item

~flex-lines:#flex-lines
~flex~line:#flex-line
~flexible長さ:#flexible-length
~flex-level:#flex-level

v.initial:#flex-initial
	~CASCADE#valdef-all-initial

仮の交叉size:#hypothetical-cross-size
仮の主size:#hypothetical-main-size

主軸:#main-axis
主軸 基底線~集合:#main-axis-baseline
主~次元:#main-dimension
主size~prop:#main-size-property
主size:#main-size
主終端:#main-end
主始端:#main-start

交叉軸:#cross-axis
交叉軸 基底線~集合:#cross-axis-baseline
交叉~次元:#cross-dimension
交叉size~prop:#cross-size-property
交叉size:#cross-size
交叉終端:#cross-end
交叉始端:#cross-start
	aligned:#alignment
	整列~prop:#propdef-align-items
	~collapseされた駒:#visibility-collapse
	common cases:#flex-common
	common uses:#flex-common
	~flow方向:#flex-direction-property
	have equal height:#align-self
	<span class="css">initial</span>:#flex-initial
	rearranged:#order-property
	resolve the flexible lengths:#resolve-flexible-lengths
	reverse:#valdef-row-reverse
	wrapped:#flex-wrap-property

~line分断~処理~段:#algo-line-break
	longhand:#flex-components

~flex~layout~algo:#layout-algorithm
主軸の整列:#main-alignment
交叉軸の整列:#cross-alignment
主sizeの決定:#main-sizing
交叉sizeの決定:#cross-sizing
~line~sizeの決定:#line-sizing

単line:#single-line
複line:#multi-line
~flex方向:#flex-direction
~collapseされた~flex駒:#collapsed-flex-item
基底線~整列に関与-:#baseline-participation
支柱~size:#strut-size
伸張:#stretched

~auto_v~margin:#auto-margins
静的位置 矩形:#static-position-rectangle


自動的~最小~size:#min-width-automatic-minimum-size
内容~size:#content-size
指定~size:#specified-size
転換~size:#transferred-size
全部的に非~flexible:#fully-inflexible
~flexible:#flexible


	■§9.7 flexible 長さの解決

V.目標~主~size:#target-main-size
V.自由空間:#free-space
	欲される自由空間:#desired-free-space
	拡縮済~flex係数の総和:#scaled-flex-factor-sum
	拡縮済~flex係数:#scaled-flex-factor
	正規化済~自由空間:#normalized-free-space
~target~主~size:#target-main-size
V.初期の自由空間:#initial-free-space
V.残りの自由空間:#remaining-free-space
V.拡縮済~flex縮短~係数:#scaled-flex-shrink-factor

	●外部
p.margin:~CSS2BOX#propdef-margin
p.margin-left:~CSS2BOX#propdef-margin-left
p.margin-top:~CSS2BOX#propdef-margin-top
	p.page-break-after:~CSS22/page.html#propdef-page-break-after
	p.page-break-before:~CSS22/page.html#propdef-page-break-before
p.max-height:~CSS2VISUDET#propdef-max-height
p.max-width:~CSS2VISUDET#propdef-max-width
p.min-height:~CSS2VISUDET#propdef-min-height
p.min-width:~CSS2VISUDET#propdef-min-width
p.~min-height:#min-size-auto
p.~min-width:#min-size-auto
p.vertical-align:~CSS2VISUDET#propdef-vertical-align
	p.vertical-align:~CSSINLINE#propdef-vertical-align
p.width:~CSS2VISUDET#propdef-width
p.height:~CSS2VISUDET#propdef-height
p.visibility:~CSS2VISUFX#propdef-visibility
p.float:~CSS2VISUREN#propdef-float
p.clear:~CSS2VISUREN#propdef-clear

	p.justify-content:~CSSALIGN#justify-content
	p.align-content:~CSSALIGN#align-content
p.break-after:~CSSBREAK#propdef-break-after
p.break-before:~CSSBREAK#propdef-break-before
p.break-*:~CSSBREAK#propdef-break-before

p.overflow:~CSS2VISUFX#propdef-overflow
	~CSSOVERFLOW#propdef-overflow
v.visible:~CSS2VISUFX#valdef-overflow-visible
	~CSSOVERFLOW#valdef-overflow-visible

v.horizontal-tb:~CSSWM#valdef-writing-mode-horizontal-tb
v.ltr:~CSSWM#valdef-direction-ltr
v.rtl:~CSSWM#valdef-direction-rtl
v.vertical-rl:~CSSWM#valdef-writing-mode-vertical-rl

	d.min-width:~TR/css3-mediaqueries/#min-width
d.min-width:~MQ4#width

p.position:~CSS2VISUREN#propdef-position
p.z-index:~CSS2VISUREN#propdef-z-index
	％~CSS2VISUREN#propdef-z-index

p.white-space:~CSSTEXT#propdef-white-space
	％white-space:~TR/css3-text/#white-space
p.box-sizing:~CSSUI#propdef-box-sizing
	％box-sizing:~TR/css3-ui/#box-sizing0
	％nav-index:~TR/css3-ui/#nav-index0

p.writing-mode:~CSSWM#propdef-writing-mode
p.direction:~CSSWM#propdef-direction
p.display:~CSSDISP#propdef-display

pe.first-line:~CSSWG/css-pseudo-4/#selectordef-first-line
pe.first-letter:~CSSWG/css-pseudo-4/#selectordef-first-letter


	ps.not:~SELECTOR4#

	inherit:~CSS21/cascade.html#value-def-inherit
	inherit:~CSSWG/css-cascade-3/#valdef-all-inherit
	＊
t.integer:~CSSVAL#integer-value
t.number:~CSSVAL#number-value
	％number:~TR/css3-values/#number-value
t.length:~CSSVAL#length-value
t.percentage:~CSSVAL#percentage-value

	＊
	~CSS21/text.html#white-space-prop

	●visuren
浮動体:~CSS2VISUREN#floats
浮動-:~CSS2VISUREN#floats
~clearance:~CSS2VISUREN#clearance
~flow内:~CSSDISP#in-flow
~flow外:~CSSDISP#out-of-flow
	~CSS2VISUREN#positioning-scheme
絶対位置の:~CSS2VISUREN#absolutely-positioned
~boxの寸法:~CSS2BOX#box-dimensions

静的~位置:~CSS2VISUDET#static-position
	#abs-non-replaced-width

	●display
塊~化:~CSSDISP#blockify
塊level:~CSSDISP#block-level
	~CSS2VISUREN#block-boxes
行内level:~CSSDISP#inline-level
	~CSS2VISUREN#inline-boxes
塊~容器:~CSSDISP#block-container
	~CSS2VISUREN#block-container-box
display 型:~CSSDISP#outer-display-type
	~CSS2VISUREN#propdef-display

	●cascade

	● writing
塊軸:~CSSWM#block-axis
塊終端:~CSSWM#block-end
塊始端:~CSSWM#block-start
始端:~CSSWM#start
終端:~CSSWM#end
行内軸:~CSSWM#inline-axis
行内終端:~CSSWM#inline-end
行内始端:~CSSWM#inline-start
合成:~CSSWM#inline-alignment
書字mode:~CSSWM#writing-mode
	論理~縦幅:~CSSWM#logical-height
塊~size:~CSSWM#block-size
	:~CSSWM#fit-content
	:~CSSWM#max-content
	~CSSWG/css-box/#fit-content
塊~flow方向:~CSSWM#block-flow-direction

	●break0
Class A の分断~機会:~CSSBREAK#btw-blocks
Class C の分断~機会:~CSSBREAK#end-block

	●break
	補完
断片化~文脈:~CSSBREAK#fragmentation-context
	断片~化された~flow:~CSSBREAK#fragmented-flow
断片化~容器:~CSSBREAK#fragmentation-container
	＊断片化~容器:~CSSBREAK#fragmentainer
断片化による分断:~CSSBREAK#fragmentation-break

	●SIZING
最小内容 拘束:~SIZING#min-content-constraint
最大内容 拘束:~SIZING#max-content-constraint
最小内容 供与:~SIZING#min-content-contribution
最大内容 供与:~SIZING#max-content-contribution
最小内容~size:~SIZING#min-content
最大内容~size:~SIZING#max-content

v.fit-content:~SIZING#valdef-width-fit-content
v.max-content:~SIZING#valdef-width-max-content
v.min-content:~SIZING#valdef-width-min-content
	#valdef-width-*

可用な空間:~SIZING#available
内容収納~行内~size:~SIZING#fit-content-inline-size
内在的~sizing:~SIZING#intrinsic-sizing


	●align
基底線~集合:~CSSALIGN#first-baseline-set
生成される:~CSSALIGN#generate-baselines
整列~基底線:~CSSALIGN#alignment-baseline
基底線を合成-:~CSSALIGN#synthesize-baselines

	●mediaqueries
	width:~mediaqueries#min-width

最初の整形される行:~CSSWG/css-pseudo-4/#first-formatted-line
</script>

<!--% id for propdef/valuedef -->

<!-- propdefs


	position.bottom:bottom
	position.left:left
	position.right:right
	position.top:top

 -->

<!--%style （例示用）
code.one-line { white-space: pre; }
:not(code) var { font-style: normal; color: #005A9C; }
a > i { font-style: normal; }
ol[start="0"] { counter-reset: list -1; }
ol[start="0"],
ol.continue { list-style: none; }
ol[start="0"] > li,
ol.continue > li { position: relative; counter-increment: list; }
ol[start="0"] > li::before,
ol.continue > li::before { content: counter(list) "."; position: absolute; left: -4.5em; width: 4em; text-align: right; }
.compact, .compact li {
  margin-top: 0;
  margin-bottom: 0;
}

-->
<style>
.code-and-figure {
	display: table;
	margin: 0 auto;
	border-spacing: 1em;
}
.code-and-figure > div {
	display: table-cell;
	vertical-align: middle;
}

/* Overview catalog example */
#_dgm-overview-example {
	display:table;
	margin: 0 auto 1em;
	border-spacing: .5em 0;
	min-width: 672px;
}
#_dgm-overview-example > .col {
	display: table-column;
	background: hsl(60,100%,90%);
}
#_dgm-overview-example > .desc {
	display: table-cell;
	vertical-align: top;
	width: 300px;
	padding: 1em 1em 0;
	text-align: left;
	border: thick solid hsl(60,80%,50%);
	border-radius: 1em 1em 0 0;
	border-bottom: none;
}
#_dgm-overview-example > .desc > img {
	margin: 0 auto;
	display: block;
}
#_dgm-overview-example > .desc > h1 {
	background: transparent;
}
#_dgm-overview-example > .buttons {
	display: table-row;
}
#_dgm-overview-example > .buttons > div {
	display: table-cell;
	border: thick solid hsl(60,80%,50%);
	border-radius: 0 0 1em 1em;
	border-top: none;
	text-align: center;
}
#_dgm-overview-example button {
	background-color: hsl(120,100%,40%);
	border: medium inset hsl(120,70%,40%);
	border-radius: 1em;
	padding: .5em;
	font-weight: bold;
	color: white;
	font-size: 1.6em;
	cursor: pointer;
	width: 90%;
	margin: 1em auto;
}

/* Visibility: Collapse example */
#_dgm-visibility-collapse-example {
	display: table;
	width: 100%;
	box-shadow: 3px 3px 10px #333;
}
#_dgm-visibility-collapse-example > article,
#_dgm-visibility-collapse-example > nav {
	display: table-cell;
}
#_dgm-visibility-collapse-example > article {
	width: 100%;
	background: white;
}
#_dgm-visibility-collapse-example ul,
#_dgm-visibility-collapse-example li {
	list-style: none;
	margin: 0;
	padding: 0;
}
#_dgm-visibility-collapse-example > nav > ul {
	background: #444;
	border-radius: 0.5em;
	padding: 0.075em;
}
#_dgm-visibility-collapse-example li {
	padding: 0 0.5em;
	background: #ddd;
	color: black;
	border-radius: 0.40em;
	border: #444 solid 0.075em;
}
#_dgm-visibility-collapse-example li li {
	background: #444;
	color: white;
	margin: 0 -0.5em;
	border-radius: 0;
}
#_dgm-visibility-collapse-example li li:first-child {
	border-radius: 0.375em 0.375em 0 0;
}
#_dgm-visibility-collapse-example a {
	background: transparent;
	color: inherit;
}
#_dgm-visibility-collapse-example > nav > ul > li:target,
#_dgm-visibility-collapse-example > nav > ul > li:hover {
	background: #888;
	color: white;
}
#_dgm-visibility-collapse-example > nav > ul > li:not(:target):not(:hover) > ul {
	height: 0;
	overflow: hidden;
}

#_dgm-auto-bar {
	overflow: hidden;
	padding: .25em 1em;
	background: #ddd;
	list-style: none ;
	margin: 0;
	border-radius: .3em;
}
#_dgm-auto-bar > li {
	float: left;
	color: black;
	margin: 0;
	list-style: none ; /* 追加 */
}
#_dgm-auto-bar > li:first-child:after,
#_dgm-auto-bar > li:first-child + li:after {
	content: " |  ";
	white-space: pre;
}
#_dgm-auto-bar > li > a {
	display: inline-block;
	padding: 0 .25em;
	border-radius: .3em;
}
#_dgm-auto-bar > li > a:not(:hover):not(:focus) {
	text-decoration: none;
}
#_dgm-auto-bar > li > a:hover {
	color: #ddd;
	background: #444;
}


#_dgm-cross-auto-figure > div > div {
	margin: 0 auto;
	width: 70px;
	background: #888;
	padding: 0 .5em;
	border-radius: 1em;
	border: 1px solid transparent;
}
#_dgm-cross-auto-figure > div > div > div {
	border-spacing: 0;
	display: table;
	background: #ddd;
	color: black;
	text-align: center;
	margin: .5em auto;
	padding: .5em;
	border-radius: .5em;
}

.axis { color: hsl(  0,80%,40%); }
.side { color: hsl(240,80%,50%); }
.size { color: hsl(120,80%,30%); }

#_dgm-flex-order-example { position: relative; height: 100px;}
#_dgm-flex-order-example > div {
	position: absolute;
	font-size: 16px;
	color: gray;
	border: solid gray 2px;
	background: white;
	width: 48px;
	height: 24px;
	padding-left: 10px;
	border-top-left-radius: 5px;
	border-top-right-radius: 5px;
	border-bottom: none;
}


#_dgm-flex-pack > div {
	margin-top: 2px;
	width: 500px;
	height: 45px;
	line-height: 50px;
	position: relative;
	border: solid gray 2px;
	background: gray;
	text-align: center;
	font-family: monospace;
}

#_dgm-flex-pack > div > div {
	position: absolute;
	top:0;
	bottom:0;
}
#_dgm-flex-pack > div > div:nth-child(1) {
	width:98px;
	background:#fcc;
}
#_dgm-flex-pack > div > div:nth-child(2) {
	width:78px;
	background:#cfc;
}
#_dgm-flex-pack > div > div:nth-child(3) {
	width:198px;
	background:#ccf;
}

#_dgm-flex-pack > div > div:nth-child(4) {
	left:0;
	right:0;
	background:transparent;
	font-size: 30px;
	color: black;
}


#_dgm-align-content-example > div {
	display: inline-block;
	width: 200px;
	height: 250px;
	position: relative;
	border: solid gray 2px;
	background: gray;
	text-align: center;
	font-family: monospace;
}

#_dgm-align-content-example > div > div {
	position: absolute;
	left:0;
	right:0;
	height:50px;
	background: url("data:image/png;base64,\
iVBORw0KGgoAAAANSUhEUgAAAFAAAAAyAgMAAAC2Q7RvAAAABGdBTUEAALGPC/xh\
BQAAAAFzUkdCAK7OHOkAAAAJUExURf/MzM3M/8z+zURRUVcAAAAaSURBVDjLY2AA\
glVgEAoHDKOCo4KjgiNbEABLjm1MVvs8tQAAAABJRU5ErkJggg==");
}
#_dgm-align-content-example > div > div:nth-child(1) {
	
}
#_dgm-align-content-example > div > div:nth-child(2) {
	background-position: left 40px top 0;
}
#_dgm-align-content-example > div > div:nth-child(3) {
	background-size: 100px 50px;
}
#_dgm-align-content-example > div > div:nth-child(4) {
	font-size: 24px;
	top:112px;
	background: transparent;
	color: black;
}



#_dgm-flex-align > div {
	display: inline-block;
	width: 45%;
	height: 6rem;
	margin-right: 1%;
	position: relative;
	border: solid gray 2px;
	background: #AAA;
	text-align: center;
	font-family: monospace;
}

#_dgm-flex-align > div > div {
	position: absolute;
	left:0;
	right:0;
	white-space: nowrap;
	overflow: hidden;
	line-height: 1em;
}

#_dgm-flex-align > div > div:nth-child(1) {
	background: #fcf;
	height: 5rem;
	left: 0%;
	width: 20%;
}
#_dgm-flex-align > div > div:nth-child(2) {
	background: #cfc;
	height: 3rem;
	left: 20%;
	width: 16%;
}
#_dgm-flex-align > div > div:nth-child(3) {
	background: #ccf;
	height: 4rem;
	left: 36%;
	width: 40%;
}
#_dgm-flex-align > div > div:nth-child(4) {
	background: #cff;
	height: 6rem;
	left: 76%;
	width: 24%;
}
#_dgm-flex-align > div > div:nth-child(5) {
	font-size: 2rem;
	top:2.3rem;
	background: transparent;
	color: black;
}

#_dgm-flex-align > div > div > div {
	border-bottom: dashed black 1px;
	line-height:0.9em;
	position: absolute;
	text-align: left;
	color: gray;
}


.flex-flow {
	background: #444;
	position: relative;
	border: solid #444 3px;
	border-radius: 6px;
	font-family: sans-serif;
	font-size: 30px;
	text-align: center;
	line-height: 40px;
	color: white;
}

.flex-flow > div {
	position: absolute;
	width: 40px;
	height: 40px;
	border-radius: 3px;
	background: #888;
}

.flex-flow.横組 > div:nth-child(2) {
	width: 50px;
}
.flex-flow.横組 > div:nth-child(4) {
	width: 60px;
}
.flex-flow.縦組 > div:nth-child(2) {
	height: 50px;
	line-height: 50px;
}
.flex-flow.縦組 > div:nth-child(4) {
	height: 60px;
	line-height: 60px;
}


#_dgm-flex-order-page {
	width:360px;
	height:300px;
	font-family: monospace;
	font-size: 18px;
}

#_dgm-flex-order-page > div {
	top:50px; bottom:50px;
	left:0; right:0;
	position: absolute;
	height:auto;
	width:auto;
}

#_dgm-multiline-flex > div {
	width: 93px;
}
#_dgm-multiline-no-flex > div {
	width: 77px;
}

.rel-vs-abs {
	margin: 10px;
	height: 4.5em;
}

.rel-vs-abs > div {
	background: gray;
	position: relative;
	border: solid gray 3px;
	border-radius: 6px;
	text-align: center;
	width: calc(25em + 6px) ;
	height: 1.8em;
	font-family: sans-serif;
	line-height: 1.8em;
}

.rel-vs-abs > div > div {
	position: absolute;
	height: 1.8em;
	border-radius: 3px;
	background: #DDD;
}

.rel-vs-abs > div > div > div {
	position: absolute;
	top:calc( 1.8em + 6px );
	height: 0.6em;
	left:0px;
	right:0px;
	border: solid 2px black;
	border-top: 0;
	line-height: 3em;
}

#flex-direction-terms text {
	fill: currentColor;
	stroke: none;
}
#flex-direction-terms path {
	stroke: currentColor;
	fill: none;
}

#_ex-flex-flow-table td {
	vertical-align: top;
}


.axis-mapping td,
.axis-mapping > thead th {
	white-space: nowrap;
}


#_dgm-flex-item-determination {
	background: #444;
	border: solid #444 3px;
	border-radius: 6px;
	display: inline-block;
	white-space: nowrap;
}
#_dgm-flex-item-determination > div {
	margin-right: 3px;
	padding: 0 3px;
	border-radius: 3px;
	background: #888;
	display: inline-block;
	vertical-align: top;
	color: white;
}


</style>


<!--%style  -->
<style>

.css {
	white-space: nowrap;
}

</style>

</head>

<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />

<!--%resource pool -->
	<div id="_resources">


<pre
	id="_dgm-overview-example-code"
	class="markup">&lt;section id="deals"&gt;
  &lt;section class="sale-item"&gt;
    &lt;h1&gt;入門用パソコン一式&lt;/h1&gt;
    &lt;p&gt;とにかく安い。
    &lt;ul&gt;
      &lt;li&gt;コンピュータ
      &lt;li&gt;モニタ
      &lt;li&gt;キーボード
      &lt;li&gt;マウス
    &lt;/ul&gt;
    &lt;img src="images/computer.jpg"
         alt="パソコン（白）と周辺機器一式"&gt;
    &lt;button&gt;今すぐ買う&lt;/button&gt;
  &lt;/section&gt;
  &lt;section class="sale-item"&gt;
    …
  &lt;/section&gt;
  …
&lt;/section&gt;</pre>


<div id="_dgm-overview-example">
	<div class="col"></div>
	<div class="col"></div>
	<div class="desc">
<img
	src="css-flexbox/computer.jpg"
	alt="パソコン（白）と周辺機器一式"
>
<!--
You get: a white computer with matching peripherals.
You get: a white computer with matching keyboard and monitor." -->
			<h1 style="font-size: 1.4em;">入門用パソコン一式</h1>
<p>
とにかく安い。
</p>
			<ul>
				<li>コンピュータ</li>
				<li>モニタ</li>
				<li>キーボード</li>
				<li>マウス</li>
			</ul>
		</div>
<!-- 
Computer Starter Kit

This is the best computer money can buy, if you don’t have much money.

    Computer
    Monitor
    Keyboard
    Mouse

BUY NOW
-->

	<div class="desc">
<img
	src="css-flexbox/printer.png"
	alt="You get: beautiful ASCII art."
>
			<h1 style="font-size: 1.4em;">プリンタ</h1>
<p>
ASCII アートしか印刷できない。
</p>

<ul><li>
紙とインクは付属しません。
</li></ul>
	</div>
	<div class="buttons">
		<div><button>今すぐ買う</button></div>
		<div><button>今すぐ買う</button></div>
	</div>
<!-- 
Printer

Only capable of printing ASCII art.

    Paper and ink not included.
-->
</div>


<!-- ＊
<img
	id="_dgm-flex-item-determination"
	src="css-flexbox/flex-item-determination.png"
>
-->

<div
	id="_dgm-flex-item-determination"
><div
>blcok</div
><div>float</div
><div>anonymous item 3</div
><div style="text-align: center; margin-right:0;">item 4<br><q>item 4</q><br>item 4</div></div>


<div
	id="_dgm-flex-flow1"
	class="flex-flow 横組"
	style="width:160px; height:40px;"
>
	<div style="left:0;">1</div>
	<div style="left: 43px;">2</div>
	<div style="left: 96px;">3</div>
	<div style="left: 139px;">4</div>
</div>

<div
	id="_dgm-flex-flow2"
	class="flex-flow 縦組"
	style="width:83px;height:160px;"
>
	<div style="top: 0;">1</div>
	<div style="top: 43px;">2</div>
	<div style="top: 96px;">3</div>
	<div style="top: 0; left:43px;">4</div>
</div>


<div
	id="_dgm-flex-flow3"
	class="flex-flow 横組"
	style="width:160px;height:83px;"
>
	<div style="right: 0; bottom:0;">1</div>
	<div style="right: 43px; bottom:0;">2</div>
	<div style="right: 96px; bottom:0;">3</div>
	<div style="right: 0;">4</div>
</div>

<div
	id="_dgm-flex-flow-english"
	class="flex-flow 横組"
	style="width:160px;height:83px;"
>
	<div style="left:0;">A</div>
	<div style="left: 43px;">B</div>
	<div style="left: 96px;">C</div>
	<div style="left: 0;top:43px;">D</div>
</div>

<div
	id="_dgm-flex-flow-japanese"
	class="flex-flow 縦組"
	style="width:83px;height:160px;"
>
	<div style="top: 0; right:0;">一</div>
	<div style="top: 43px; right:0;">二</div>
	<div style="top: 96px; right:0;">三</div>
	<div style="top: 0; left:0;">四</div>
</div>

<div id="_dgm-flex-order-example">
<div style="top: 0; left: 70px;">一番</div>
<div style="top: 0; left: 135px;">二番</div>
<div style="top: 0; left: 200px;">四番</div>
<div style="top: 24px; left: 0; width: 500px; height: 80px; border-color: black; color: black;">
<p style="padding: 20px;">三番のタブに結び付けられている内容</p></div>
<div style="top: 0; left: 5px; border-color: black; color: black;">三番</div>
</div>

<div id="_dgm-flex-order-page" class="flex-flow"
	title="このページでは、 header は上端に， footer は下端に位置し、 article は，左の nav, 右の aside に挟まれた中央に位置する／In this page the header is at the top and the footer at the bottom, but the article is in the center, flanked by the nav on the right and the aside on the left."
>
	<div style="height:47px;top:0; bottom:auto;">&lt;header&gt;</div>
	<div style="right:auto; width:80px;">&lt;nav&gt;</div>
	<div style="left:83px; right:83px;">&lt;article&gt;</div>
	<div style="left:auto; width:80px;">&lt;aside&gt;</div>
	<div style="height:47px;top:auto; bottom:0;">&lt;footer&gt;</div>
</div>


<div
	id="_dgm-multiline-flex"
	class="flex-flow 横組"
	style="width:285px; height:83px;"
>
	<div style="left:0;">1</div>
	<div style="left:96px;">2</div>
	<div style="left:192px;">3</div>
	<div style="left:0;width:auto;right:0;top:43px;">4</div>
</div>

<div
	id="_dgm-multiline-no-flex"
	class="flex-flow 横組"
	style="width:285px; height:83px;"
>
	<div style="left:0;">1</div>
	<div style="left:80px;">2</div>
	<div style="left:160px;">3</div>
	<div style="left:0;top:43px;">4</div>
</div>

<div
	id="_dgm-rel-vs-abs-flex-a"
	class="rel-vs-abs"
><div>
	<div style="left:0; width:6.25em;">短い<div>1</div></div>
	<div style="left:calc(6.25em + 3px); width:6.25em;">なが〜〜い<div>1</div></div>
	<div style="left:calc(12.5em + 6px); width:12.5em;">短い<div>2</div></div>
</div></div>

<div
	id="_dgm-rel-vs-abs-flex-b"
	class="rel-vs-abs"
><div>
	<div style="left:0; width:6em;">
<div style="width:calc(2em - 4px);right:auto;">1</div>
短い
<div style="width:calc(2em - 4px);left:auto;">1</div>
</div>
	<div style="left:calc(6em + 3px); width:9em;">
<div style="width:calc(2em - 4px);right:auto;">1</div>
なが〜〜い
<div style="width:calc(2em - 4px);left:auto;">1</div>
	</div>
	<div style="left:calc(15em + 6px); width:10em;">
<div style="width:calc(4em - 8px);right:auto;">2</div>
短い
<div style="width:calc(4em - 8px);left:auto;">2</div>
</div>
</div>
</div>


<ul id="_dgm-auto-bar">
	<li><a href="#_dummy">About</a></li>
	<li><a href="#_dummy">Projects</a></li>
	<li><a href="#_dummy">Interact</a></li>
	<li style="float: right;"><a href="#_dummy">Login</a></li>
</ul>


<div
	id="_dgm-cross-auto-figure"
	style="display:table; margin: 0 auto 1em;"
>
	<div style="display:table-cell; padding-right: 50px;">
		<div>
			<div>About</div>
			<div>Authoritarianism</div>
			<div>Blog</div>
		</div>
	</div>
	<div style="display:table-cell; padding-left: 50px;">
		<div>
			<div>About</div>
			<div style="margin-left: -31px;">Authoritarianism</div>
			<div>Blog</div>
		</div>
	</div>
</div>

<div id="_dgm-flex-pack">
<div>
<div style="left:0px;"></div>
<div style="left:100px;"></div>
<div style="left:180px;"></div>
<div>flex-start</div>
</div>
<div>
<div style="right:280px;"></div>
<div style="right:200px;"></div>
<div style="right:0px;"></div>
<div>flex-end</div>
</div>
<div>
<div style="left:61px;"></div>
<div style="left:161px;"></div>
<div style="right:61px;"></div>
<div>center</div>
</div>
<div>
<div style="left:0;"></div>
<div style="left:161px;"></div>
<div style="right:0;"></div>
<div>space-between</div>
</div>
<div>
<div style="left:31px;"></div>
<div style="left:161px;"></div>
<div style="right:31px;"></div>
<div>space-around</div>
</div>
</div>


<div id="_dgm-flex-align" style="min-width:20em; max-width: 50em;">

	<div>
<div style="top:0"></div>
<div style="top:0"></div>
<div style="top:0"></div>
<div style="top:0"></div>
<div>flex-start</div>
	</div><div>
<div style="bottom:0;"></div>
<div style="bottom:0;"></div>
<div style="bottom:0;"></div>
<div style="bottom:0;"></div>
<div>flex-end</div>
	</div>
	<div>
<div style="top:0.5rem"></div>
<div style="top:1.5rem"></div>
<div style="top:1rem"></div>
<div style="top:0"></div>
<div>center</div>

	</div><div>
<div style="height:6rem"></div>
<div style="height:6rem"></div>
<div style="height:6rem"></div>
<div style="height:6rem"></div>
<div>stretch</div>
	</div>
<!--
	bottom1 + bottom2 = 4.6,
	bottom2 + font-size = 5/3/4/6 − 0.3
-->
	<div style="width:91.6%; height:7rem;">
<div style="bottom:1.2rem;"><div style="bottom:3.4rem;font-size:1.3rem;">寿限無寿限無寿限無寿限無寿限無</div></div>
<div style="bottom:2.9rem;"><div style="bottom:1.7rem;font-size:0.9rem;">寿限無寿限無寿限無寿限無寿限無</div></div>
<div style="bottom:3.0rem;"><div style="bottom:1.6rem;font-size:2rem;">寿限無寿限無寿限無寿限無寿限無</div></div>
<div style="bottom:0;"><div style="bottom:4.6rem;font-size:1.1rem;">寿限無寿限無寿限無寿限無寿限無</div></div>
<div>baseline</div>
	</div>

</div>



<div id="_dgm-align-content-example">

	<div>
<div style="top:0"></div>
<div style="top:50px"></div>
<div style="top:100px"></div>
<div>flex-start</div>
	</div>
	<div>
<div style="bottom:100px"></div>
<div style="bottom:50px"></div>
<div style="bottom:0"></div>
<div>flex-end</div>
	</div>
	<div>
<div style="top:50px"></div>
<div style="top:100px"></div>
<div style="bottom:50px"></div>
<div>center</div>
	</div>
	<div>
<div style="top:0px"></div>
<div style="top:100px"></div>
<div style="bottom:0px"></div>
<div>space-between</div>
	</div>
	<div>
<div style="top:17px"></div>
<div style="top:100px"></div>
<div style="bottom:17px"></div>
<div>space-around</div>
	</div>
	<div>
<div style="height:83px;top:0"></div>
<div style="height:84px;top:83px"></div>
<div style="height:83px;bottom:0"></div>
<div>stretch</div>
	</div>
</div>


	</div>
</div>

<aside class="trans-meta">
<h1>CSS Flexible Box Layout Module Level 1 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong >編集者草案</strong>（ Last Call Working Draft ）として公開された
<a id="_SPEC_URL">CSS Flexible Box Layout Module Level 1</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
注記：
これは草案（発行版）の日本語訳ですが、他の仕様へのリンクは，概ね（原文と異なり，）最新の編集者草案を指しています。
</p>

<p>
更新：<time>2016-05-07</time>
（公開：<time>2013-10-13</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<div><a href="http://www.w3.org/" id="_W3C">W3C</a></div>

<h1 id="title">CSS 自在ボックス レイアウト — CSS Flexible Box Layout Module Level 1</h1>
<h2>2016 年 5 月 6 日付 編集者草案</h2>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dt title="Editors draft:">編集者草案</dt>
	<dd>https://drafts.csswg.org/css-flexbox/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>https://www.w3.org/TR/css3-flexbox/</dd>


	<dt title="Previous Versions:">以前のバージョン</dt>
	<dd>https://www.w3.org/TR/2016/CR-css-flexbox-1-20160105/</dd>
	<dd>https://www.w3.org/TR/2015/WD-css-flexbox-1-20150514/</dd>
	<dd>https://www.w3.org/TR/2014/WD-css-flexbox-1-20140925/</dd>
	<dd>https://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/</dd>
	<dd>https://www.w3.org/TR/2012/CR-css3-flexbox-20120918/</dd>
	<dd>https://www.w3.org/TR/2012/WD-css3-flexbox-20120612/</dd>
	<dd>https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/</dd>
	<dd>https://www.w3.org/TR/2011/WD-css3-flexbox-20111129/</dd>
	<dd>https://www.w3.org/TR/2011/WD-css3-flexbox-20110322/</dd>
	<dd>https://www.w3.org/TR/2009/WD-css3-flexbox-20090723/</dd>

	<dt title="Feedback:" id="feedback">フィードバック</dt>
	<dd><a href="mailto:www-style@w3.org?subject=%5Bcss-flexbox%5D%20YOUR%20TOPIC%20HERE">www-style@w3.org</a>
with subject line “<kbd>[css-flexbox] <i>… message topic …</i></kbd>”
(<a href="http://lists.w3.org/Archives/Public/www-style/">archives</a>)</dd>


	<dt title="Test Suite">テスト一式</dt>
	<dd>http://test.csswg.org/suites/css-flexbox-1_dev/nightly-unstable/</dd>

<!-- 
	<dt title="Issue Tracking:">最新の課題：</dt>
	<dd><a href="#issues-index">Inline In Spec</a>
 -->

	<dt title="Editors:">編集</dt>
	<dd><a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)</dd>
	<dd><a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Mozilla)</dd>
	<dd><a href="mailto:ratan@microsoft.com">Rossen Atanassov</a> (Microsoft)</dd>

	<dt title="Former Editors:">前任編集者</dt>
	<dd><a href="mailto:alexmog@microsoft.com">Alex Mogilevsky</a> (Microsoft Corporation)</dd>
	<dd><a href="mailto:dbaron@dbaron.org">L. David Baron</a> (Mozilla Corporation)</dd>
	<dd><a href="mailto:enndeakin@gmail.com">Neil Deakin</a> (Mozilla Corporation)</dd>
	<dd><a href="mailto:ian@hixie.ch">Ian Hickson</a> (formerly of Opera Software)</dd>
	<dd><a href="mailto:hyatt@apple.com">David Hyatt</a> (formerly of Netscape Corporation)</dd>

	<dt title="Issues list:">課題一覧</dt>
	<dd>https://drafts.csswg.org/css-flexbox-1/issues</dd>
</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
© 2016
<a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
<a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
<a href="http://www.keio.ac.jp/">Keio</a>,
<a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
<a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a>
rules apply.
</small>

</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、 UI 設計に最適化された CSS ~box~modelについて述べる。
~flex~layout~modelにおいては，
~flex容器の一連の子を任意の方向に~lay-outしつつ，それらの大きさも “flex （伸縮可能）” にする
—
すなわち，未使用の空間を埋めるように大きくしたり, 逆に 親からはみ出さない様に縮めたりすることができる。
また、縦横いずれの方向にも，一連の子の整列を容易に操作できる。
これらの~boxの入子（縦~boxの内側の横~box, あるいは その逆）も，二次元の~layoutを築くために利用できる。
<a href="~TR/CSS/">CSS</a>
は、（ HTML や XML などの）構造を備える文書から，
~screen, 紙, 発話, 等々
の媒体への具現化法を記述するための言語である。
<span lang="en">
The specification describes a CSS box model optimized for user interface design. In the flex layout model, the children of a flex container can be laid out in any direction, and can “flex” their sizes, either growing to fill unused space or shrinking to avoid overflowing the parent. Both horizontal and vertical alignment of the children can be easily manipulated. Nesting of these boxes (horizontal inside vertical, or vertical inside horizontal) can be used to build layouts in two dimensions. CSS is a language for describing the rendering of structured documents (such as HTML and XML) on screen, on paper, in speech, etc.
</span></p>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<span class="trans-note">【
以下，この節の他の内容は
<a href="css-common-ja.html#status" >CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>

	</section>


	<nav id="contents" class="toc">
<h2 title="Table of contents">目次</h2>
<ol id="_toc_list0"></ol></nav>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
CSS 2.1 にて定義される~layout~mode
—
~boxの~sizeと位置を，その同胞の~boxと, その先祖の~boxとの関係性に基づいて決定する~algo
—
には，次の４種がある：
◎
CSS 2.1 defined four layout modes — algorithms which determine the size and position of boxes based on their relationships with their sibling and ancestor boxes:
</p>

<ul class="compact">
	<li>
文書を~lay-outするために設計された塊~layout
◎
block layout, designed for laying out documents
</li>
	<li>
~textを~lay-outするために設計された行内~layout
◎
inline layout, designed for laying out text
</li>

	<li>
~~二次元~dataを~table状に~lay-outするために設計された~table~layout
◎
table layout, designed for laying out 2D data in a tabular format
</li>

	<li>
文書~内の他の要素にさほど関わり無く，~~明確な位置決めにより~lay-outするために設計された positioned ~layout
<span class="trans-note">【
`position$p:fixed
や
`position$p:absolute
等による ~layout
】</span>
◎
positioned layout, designed for very explicit positioning without much regard for other elements in the document
</li></ul>

<p>
この~moduleは，新たな~layout~mode
`~flex~layout@
を導入する。
それは，より複雑な~appや~web頁を~lay-outするために設計されたものである。
◎
This module introduces a new layout mode, flex layout, which is designed for laying out more complex applications and webpages.
</p>

		<section id="overview">
<h3 title="Overview">1.1. 概観</h3>

~INFORMATIVE

<p>
~flex~layoutは、表面的には塊~layoutに類似する。
それは、［
`float$p
や
<a href="~CSSMCOL">~col</a>
］などの，塊~layoutに利用できる［
より複雑な，~textや文書を~~主対象にする 多くの~prop
］は欠く一方で、~web~appや複雑な~web頁によく必要とされるような，種々の［
空間の配分法や内容の整列法
］のための，単純かつ強力な道具を得られる。
~flex容器の内容は：
◎
Flex layout is superficially similar to block layout. It lacks many of the more complex text- or document-centric properties that can be used in block layout, such as floats and columns. In return it gains simple and powerful tools for distributing space and aligning content in ways that web apps and complex web pages often need. The contents of a flex container:
</p>

<ul>
	<li>
どの
<a href="#flex-direction-property">~flow方向</a>
にも（左方, 右方, 下方, あるいは上方へも！）~lay-outし得る
◎
can be laid out in any flow direction (leftwards, rightwards, downwards, or even upwards!)
</li>

	<li>
それらの陳列~順序を~style層にて，
<a href="#valdef-flex-direction-row-reverse">逆順</a>にしたり,
<a href="#order-property">配置替え</a>できる（すなわち，~sourceや発話の順序とは独立に，視覚的~順序を与えられる）
◎
can have their display order reversed or rearranged at the style layer (i.e., visual order can be independent of source and speech order)
</li>

	<li>
単方向の軸（ `主軸$ ）沿いに一次元的に~lay-outしたり,
第二の軸（ `交叉軸$ ）沿いに, 複数の~lineに渡るように
<a href="#flex-wrap-property">折返す</a>ことができる。
◎
can be laid out linearly along a single (main) axis or wrapped into multiple lines along a secondary (cross) axis
</li>

	<li>
それらの~sizeは`可用な空間$に応じて
<a href="#flexibility">“~flex”</a>
（伸縮可能）になれる。
◎
can “flex” their sizes to respond to the available space
</li>

	<li>
それらを，それらの容器に対して, あるいは互いどうしを`交叉軸$沿いに<a href="#alignment">整列させ</a>られる。
【 整列 — この訳の中の語 “~~整列” はすべて， “ソート（ sort ）” ではなく “揃え（ align ）” の方を意味する。】
◎
can be aligned with respect to their container or each other on the secondary (cross)
</li>

	<li>
容器の`交叉size$は保ちつつ、`主軸$沿いに，動的に
<a href="#visibility-collapse">~collapse</a>（~~縮退）された~~状態にしたり, その逆にできる。
◎
can be dynamically collapsed or uncollapsed along the main axis while preserving the container’s cross size
</li></ul>


<div class="example">

<p>
ここに、各~駒が［
見出し, 写真, 説明, 購入ボタン
］を備えている，ある目録の例を示す。
~layoutの中の各~~区画は、駒の説明の長さに関係なく，どれも同じ総~sizeを持ち、~~区画の中では，写真が~textの上に~~位置し, 購入ボタンは下端に整列させたいとする。
~flex~layoutを用いれば，この設計の多くの側面を容易に実現できる：
◎
Here’s an example of a catalog where each item has a title, a photo, a description, and a purchase button. The designer’s intention is that each entry has the same overall size, that the photo be above the text, and that the purchase buttons aligned at the bottom, regardless of the length of the item’s description. Flex layout makes many aspects of this design easy:
</p>

<ul>
	<li>
目録では，一連の駒を いくつかの~rowに渡って横方向に~lay-outさせた上で、同じ~rowの中では それらの駒の縦幅をすべて等しくさせるために、~flex~layoutを利用する。
各~~~区画は、それ自身が 1 本の~colをなす~flex容器になり，その内容を縦方向に~lay-outする。
◎
The catalog uses flex layout to lay out rows of items horizontally, and to ensure that items within a row are all equal-height. Each entry is then itself a column flex container, laying out its contents vertically.
</li>

	<li>
各~~区画の中では，~source文書~内容の論理的~順序【 “文書順” 】は［
見出し, 説明, 写真
］の順にされる。
これは，発話や非 CSS ~browserにおいても意味のある順序付けを供する一方で、より~compellingな視覚的~呈示においては、
`order$p を用いて 内容の後方に在る画像を上端に引き上げ，
`align-self$p を用いて それを横方向の中央に~~位置させる。
◎
Within each entry, the source document content is ordered logically with the title first, followed by the description and the photo. This provides a sensible ordering for speech rendering and in non-CSS browsers. For a more compelling visual presentation, however, order is used to pull the image up from later in the content to the top, and align-self is used to center it horizontally.
</li>

	<li>
購入ボタンに対する上側の`~auto_v~margin$により、どの~~項目~boxの中でも，駒の説明の縦幅に関係なく，ボタンを下端に~~位置させられる。
◎
An auto margin above the purchase button forces it to the bottom within each entry box, regardless of the height of that item’s description.
</li></ul>

<pre class="lang-css">
#deals {
  `display$p:flex;
      /* <span class="comment">
~flex~layoutにより，一連の駒は <a href="#propdef-align-self">縦幅が等しくされる</a>
◎
Flex layout so items have equal height
</span> */

  `flex-flow$p:row_wrap;
      /* <span class="comment">
一連の駒を，複数~lineに渡って折返す
◎
Allow items to wrap into multiple lines
</span> */
}
.sale-item {
  `display$p:flex;
      /* <span class="comment">
~flex~layoutを用いて 各~駒を~lay-outする
◎
Lay out each item using flex layout
</span> */

  `flex-flow$p:column;
      /* <span class="comment">
駒の内容を縦方向に~lay-outする
◎
Lay out item’s contents vertically
</span> */
}
.sale-item &gt; img {
  `order$p:-1;
      /* <span class="comment">
画像を（視覚的~順序で）他の内容より前に~~移動する
◎
Shift image before other content (in visual order)
</span> */

  `align-self$p:center;
      /* <span class="comment">
画像を交叉方向（横方向）の中央に据える
◎
Center the image cross-wise (horizontally)
</span> */
}
.sale-item &gt; button {
  `margin-top$p:auto;
      /* <span class="comment">
上端の`~auto_v~margin$によりボタンは下端へ押しやられる
◎
Auto top margin pushes button to bottom
</span> */
}
</pre>

`overview-example-code^dgm

<figure>`overview-example^dgm
<figcaption><p><b>図 1.</b>
上の~codeの描画~例
◎
An example rendering of the code above.
</p></figcaption>

</figure>


</div>



		</section>
		<section id="placement">
<h3 title="Module interactions">1.2. ~module間の相互作用</h3>

<p>
この~moduleは、新たな［
`塊level$, `行内level$
］の `display 型$を追加し，新たな種類の整形~文脈を その~layoutを制御する~propと伴に定義することにより、
`CSS21$r による `display$p ~propの定義を<a href="#propdef-display" >拡張する</a>。
この~moduleにて定義される どの~propも，
`first-line$pe ／ `first-letter$pe
疑似要素には適用されない。
◎
This module extends the definition of the display property [CSS21], adding a new block-level and new inline-level display type, and defining a new type of formatting context along with properties to control its layout. None of the properties defined in this module apply to the ::first-line or ::first-letter pseudo-elements.
</p>

		</section>
	</section>
	<section id="box-model">
<h2 title="Flex Layout Box Model and Terminology">2. ~flex~layoutの~box~modelとその各種用語</h2>

<p>
`~flex容器@
とは、［
`display$p ~propの算出値が［
`flex$v:d または `inline-flex$v:d
］になる要素
］により生成される~boxである。
~flex容器の`~flow内$にある各~子は，
`~flex駒@
と呼ばれ、~flex~layout~modelの下で~lay-outされる。
◎
A flex container is the box generated by an element with a computed display of flex or inline-flex. In-flow children of a flex container are called flex items and are laid out using the flex layout model.
</p>

<p>
~layoutの計算は、
<a href="~CSSWM#abstract-box">［ 塊／行内 ］~flow方向</a>
に重きが置かれた［
塊／行内
］~layoutとは異なり，~flex~layoutでは
`~flex方向@
に重きが置かれる。
~flex~layoutについてより述べ易くするため、この節では~flex~flowに相対する一連の用語を定義する。
`flex-flow$p 値と`書字mode$は、これらの用語が，どのように物理的な［
方向（上端／右端／下端／左端）,
軸（縦／横）,
~size（横幅／縦幅）
］に対応付けられるかを決定する。
◎
Unlike block and inline layout, whose layout calculations are biased to the block and inline flow directions, flex layout is biased to the flex directions. To make it easier to talk about flex layout, this section defines a set of flex flow–relative terms. The flex-flow value and the writing mode determine how these terms map to physical directions (top/right/bottom/left), axes (vertical/horizontal), and sizes (width/height).
</p>



<figure>

<!--  flex-direction-terms^dgm -->

<svg
	id="flex-direction-terms"
	xmlns="http://www.w3.org/2000/svg"
	width="100%"
	style="max-width: 680px;"
	viewBox="-50 -40 680 280"

	font-family="sans-serif"
	text-anchor="middle"
	font-size="18"
	color="black"
>

	<g fill="#ddd" stroke="none">
<rect fill="#888" x="0" y="0" width="500" height="120" rx="10" ry="10" />
<rect x="5" y="5" width="150" height="110" rx="5" ry="5" />
<rect x="160" y="5" width="335" height="110" rx="5" ry="5" />
	</g>

	<g
color="white"
font-size="40"
font-weight="bold"
	>
<text x="75" y="75">1</text>
<text x="328" y="75">2</text>
	</g>

	<g
font-size="16"
font-style="italic"
fill="#444"
	>
<text x="150" y="110" text-anchor="end">~flex駒</text>
<text x="165" y="110" text-anchor="start">~flex駒</text>
<text x="155" y="136">~flex容器</text>
	</g>

	<g
class="side"
stroke-width="3"
stroke-dasharray="5 5"
	>
		<g transform="translate(1.5,120)">
<path d="M 0 -10 v 40"/>
<text x="0" y="40">主始端</text>
		</g>
		<g transform="translate(498.5,120)">
<path d="M 0 -10 v 40"/>
<text x="0" y="40">主終端</text>
		</g>
		<g transform="translate(503,1.5)">
<path d="M -10 0 h 40"/>
<text x="25" y="4" style="text-anchor: start;">交叉始端</text>
		</g>
		<g transform="translate(503,118.5)">
<path d="M -10 0 h 40"/>
<text x="25" y="4" style="text-anchor: start; ">交叉終端</text>
		</g>
	</g>

	<g
class="axis"
stroke-width="3"
	>
		<g transform="translate(0,60)">
<path
	d="
M7.5,0
a5,5 0,0,0 -10,0 a5,5 0,0,0 10,0
h 600
h-5 l0,-3 10,3 -10,3 0,-3"
/>
<text x="550" y="-8">主軸</text>
		</g>
		<g transform="translate(250,0)rotate(90)">
<path
	d="
M 7.5 0
a5,5 0,0,0 -10,0 a5,5 0,0,0 10,0
h 220
h-5 l0,-3 10,3 -10,3 0,-3"
/>
<text x="180" y="-8">交叉軸</text>
		</g>
	</g>

	<g
class="size"
stroke-width="2"
	>
		<g transform="translate(0,-15)">
<path d="M1,10 v-10 h498 v10" />
<text x="250" y="-4">主size</text>
		</g>
		<g transform="translate(-15,120) rotate(-90)">
<path d="M1,10 v-10 h118 v10" />
<text x="60" y="-4">交叉size</text>
		</g>
	</g>

</svg>


<figcaption>
<p><b>図 2.</b>
`row$v:fd ~flex容器に適用される種々の［
方向や~sizing
］のための用語の図示
◎
An illustration of the various directions and sizing terms as applied to a row flex container.
</p></figcaption>

</figure>

<dl id="main">
	<dt class="axis" title="main axis">主軸</dt>
	<dt class="axis" title="main dimension">主~次元</dt>
	<dd>
~flex容器の
`主軸@
とは、`~flex駒$がその軸~沿いに~lay-outされ,
`主~次元@
に延伸する，首の軸である。
◎
The main axis of a flex container is the primary axis along which flex items are laid out. It extends in the main dimension.
</dd>
	<dd class="trans-note">【
この仕様の “~~次元（ dimension ）” は、もっぱら，縦横いずれかの軸~方向の計量を意味する。
】</dd>

	<dt class="side" title="main-start">主始端</dt>
	<dt class="side" title="main-end">主終端</dt>
	<dd>
一連の`~flex駒$は，
`主始端@
側から
`主終端@
側へ向けて
容器~内に配置される。
◎
The flex items are placed within the container starting on the main-start side and going toward the main-end side.
</dd>

	<dt class="size" title="main size">主size</dt>
	<dt class="size" title="main size property">主size~prop</dt>
	<dd>
`~flex駒$の［
横幅, 縦幅
］のうち，`主~次元$に属する方が駒の
`主size@
になる。
`~flex駒$の
`主size~prop@
は、［
`width$p, `height$p
］のうち，`主~次元$に属する方の~propを指す。
◎
A flex item’s width or height, whichever is in the main dimension, is the item’s main size. The flex item’s main size property is either the width or height property, whichever is in the main dimension.
</dd>

	<dd>
【次を補足：】
“<em>~max</em>（<em>~min</em>）`主size~prop$”と記されたときは、［
`max-width$p, `max-height$p
（ `min-width$p, `min-height$p ）
］のうち，`主~次元$に属する方の~propを指す。
</dd>

</dl>

<dl id="cross">
	<dt class="axis" title="cross axis">交叉軸</dt>
	<dt class="axis" title="cross dimension">交叉~次元</dt>
	<dd>
`主軸$に垂直な軸は
`交叉軸@
と呼ばれ，
`交叉~次元@
に延伸する。
◎
The axis perpendicular to the main axis is called the cross axis. It extends in the cross dimension.
</dd>
	<dd class="trans-note">【
この訳では、 “cross” の対訳に “~~交差” ではなく “~~交叉” を用いる。
“~~叉” の方が視覚的イメージに合うこと, および
“~~交差” は “intersect” の対訳に利用される場合も多いので。
】</dd>

	<dt class="side" title="cross-start">交叉始端</dt>
	<dt class="side" title="cross-end">交叉終端</dt>
	<dd>
それぞれが一連の駒により埋められる，一連の`~flex-lines$は、~flex容器の
`交叉始端@
側から
`交叉終端@
側に向けて，容器~内に配置される
◎
Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.
</dd>

	<dt class="size" title="cross size">交叉size</dt>
	<dt class="size" title="cross size property">交叉size~prop</dt>
	<dd>
`~flex駒$の［
横幅, 縦幅
］のうち，`交叉~次元$に属する方が、駒の
`交叉size@
になる。
`交叉size~prop@
は、
`width$p, `height$p
のうち，`交叉~次元$に属する方の~propを指す。
◎
The width or height of a flex item, whichever is in the cross dimension, is the item’s cross size. The cross size property is whichever of width or height that is in the cross dimension.
</dd>

	<dd>
【次を補足：】
“<em>~max</em>（<em>~min</em>）`交叉size~prop$”と記されたときは、［
`max-width$p, `max-height$p
（ `min-width$p, `min-height$p ）
］のうち，`交叉~次元$に属する方の~propを指す。
</dd>

</dl>


<p>
この仕様に利用される，~sizingに関する追加の用語は、
<a href="~SIZING">CSS 内在的＆外在的~sizing</a>
仕様にて定義される。
`CSS3-SIZING$r 
◎
Additional sizing terminology used in this specification is defined in CSS Intrinsic and Extrinsic Sizing. [CSS3-SIZING]
</p>




	</section>
	<section id="flex-containers">
<h2 title="Flex Containers: the flex and inline-flex display values">3. ~flex容器： `display^p 値に対する `flex^v, `inline-flex^v </h2>

`●名^ <a id="propdef-display">`display$p</a>
`●新値^ `flex$v:d | `inline-flex$v:d
`●表終^


<dl>
	<dt>`flex@v:d</dt>
	<dd>
要素は，`塊level$の`~flex容器$~boxを生成するようになる。
◎
This value causes an element to generate a block-level flex container box.
</dd>

	<dt>`inline-flex@v:d</dt>
	<dd>
要素は，`行内level$の`~flex容器$~boxを生成するようになる。
◎
This value causes an element to generate an inline-level flex container box.
</dd>

</dl>

<p>
`~flex容器$は、その内容に対し，新たな
`~flex整形~文脈@
を確立する。
これは、その内容の~layoutおいては，塊~layoutに代わって~flex~layoutが用いられることを除き，塊~整形~文脈を確立することと同じになる：
例えば、`浮動体$が~flex容器~内に侵入することはなく，~flex容器の~marginとその内容の~marginとの間も相殺されることはない。
`~flex容器$は、自身の内容に対する包含塊を，
<a href="~CSS2VISUDET#containing-block-details">塊~容器と正確に同じ様に</a>
形成する
`CSS21$r
。
`overflow$p ~propは、`~flex容器$にも適用される。
◎
A flex container establishes a new flex formatting context for its contents. This is the same as establishing a block formatting context, except that flex layout is used instead of block layout. For example, floats do not intrude into the flex container, and the flex container’s margins do not collapse with the margins of its contents. Flex containers form a containing block for their contents exactly like block containers do. [CSS21] The overflow property applies to flex containers.
</p>

<p>
~flex容器は`塊~容器$ではないので、塊~layoutを前提に設計された一部の~propは，~flex~layoutの文脈~下では適用されない。
特に：
◎
Flex containers are not block containers, and so some properties that were designed with the assumption of block layout don’t apply in the context of flex layout. In particular:
</p>

<ul>
	<li>
Multi-column Layout ~module `CSS3COL$r の
`column-*^p ~propは、~flex容器~上では 効果を持たない。
◎
the column-* properties in the Multi-column Layout module [CSS3COL] have no effect on a flex container.
</li>

	<li id="cg-anonymous-fixup-1">
`float$p は、`~flex駒$を浮動させたり，<span id="cg-float-display">それを`~flow外$にすることはない。
`clear$p も~flex駒に対する`~clearance$を作成しない。
</span>
◎
float and clear do not create floating or clearance of flex item, and do not take it out-of-flow.
</li>

	<li>
 `vertical-align$p は、~flex駒~上では 効果を持たない。
◎
vertical-align has no effect on a flex item.
</li>

	<li>
<p>
疑似要素［
`first-line$pe ／ `first-letter$pe
］は，`~flex容器$には適用されず、`~flex容器$は，先祖に［
`最初の整形される行$や, 最初の字
］を供与しない。
◎
the ::first-line and ::first-letter pseudo-elements do not apply to flex containers, and flex containers do not contribute a first formatted line or first letter to their ancestors.
</p>

	</li>

</ul>

<p>
要素に指定された `display$p が `inline-flex$v:d である場合、その `display$p ~propの算出値は，一定の状況下で `flex$v:d になる —
<a href="~CSS2VISUREN#dis-pos-flo">CSS 2.1 の 9.7 節</a>
の表は、次のように訂正される：
［
“指定値” カラムの欄が `inline-flex$v:d,
“算出値” カラムの欄が `flex$v:d
］なる行を追加。
◎
If an element’s specified display is inline-flex, then its display property computes to flex in certain circumstances: the table in CSS 2.1 Section 9.7 is amended to contain an additional row, with inline-flex in the "Specified Value" column and flex in the "Computed Value" column.
</p>

	</section>
	<section id="flex-items">
<h2 title="Flex Items">4. ~flex駒</h2>

<p>
大雑把に言うなら、`~flex容器$の`~flex駒$とは，その`~flow内$にある内容を表現している~boxである。
◎
Loosely speaking, the flex items of a flex container are boxes representing its in-flow contents.
</p>

<p>
`~flex容器$の`~flow内$にある各~子は，`~flex駒$になり、［
`~flex容器$の内側に直接的に包含されている~textの連なり
］の それぞれが，匿名`~flex駒$で包装される。
ただし，
<a href="~CSS21/text.html#white-space-prop">空白</a>
<span id="cg-white-space">
（すなわち， `white-space$p ~propに影響され得る文字）
</span>
のみからなる匿名~flex駒は、描画されない（ `display$p:none にされていたかのように）。
◎
Each in-flow child of a flex container becomes a flex item, and each contiguous run of text that is directly contained inside a flex container is wrapped in an anonymous flex item. However, an anonymous flex item that contains only white space (i.e. characters that can be affected by the white-space property) is not rendered (just as if it were display:none).
</p>

<div class="example">
<p>
~flex駒のいくつかの例：
◎
Examples of flex items:
</p>

<pre class="markup">
&lt;div style="`display$p:flex"&gt;

    &lt;!-- <span class="comment"
>~flex駒：子~塊◎
flex item: block child</span> --&gt;
    &lt;div id="item1"&gt;block&lt;/div&gt;

    &lt;!-- <span class="comment"
>~flex駒： 浮動された要素 — その効果は無視される◎
flex item: floated element; floating is ignored</span> --&gt;
    &lt;div id="item2" style="`float$p:left;"&gt;float&lt;/div&gt;

    &lt;!-- <span class="comment"
>~flex駒： 行内~内容を囲う匿名~塊~box◎
flex item: anonymous block box around inline content</span> --&gt;
    anonymous item 3

    &lt;!-- <span class="comment"
>~flex駒： 行内の子◎
flex item: inline child</span> --&gt;
    &lt;span&gt;
        item 4
        &lt;!-- <span class="comment"
>~flex駒は塊の周囲で分割されることはない◎
flex items do not split around blocks</span> --&gt;
        &lt;q style="display: block" id=not-an-item&gt;item 4&lt;/q&gt;
        item 4
    &lt;/span&gt;
&lt;/div&gt;</pre>


<figure>
<figcaption>
上の~code~blockから決定される~flex駒
（<a href="~CSSWG/css-flexbox/examples/flex-item-determination.html">実演</a>）
◎
Flex items determined from above code block
</figcaption>
`flex-item-determination^dgm
</figure>

<p>
要素~間の空白は、消え去ることに注意：
要素たちの狭間の~textは，匿名~flex駒~内で <em>包装される</em>が、それでも空白のみが~flex駒を成すことはない。
◎
Note that the inter-element white space disappears: it does not become its own flex item, even though the inter-element text does get wrapped in an anonymous flex item.
</p>

<p>
匿名~駒の~boxには、~style規則をあてがう要素がないため，~styleをあてがえないことに注意。
しかしながら、その内容は，~flex容器から~styleを継承する（~font設定群など）。
◎
Note also that the anonymous item’s box is unstyleable, since there is no element to assign style rules to. Its contents will however inherit styles (such as font settings) from the flex container.
</p>

</div>

<p>
`~flex駒$は、その内容に対する新たな整形~文脈を確立する。
この整形~文脈の種別は，通例的に その `display$p 値から決定される。
しかしながら、~flex駒~自体は，`塊level$の~boxではなく，
`~flex-level@
の~boxになる：
それらは、塊~整形~文脈ではなく，容器の~flex整形~文脈に関与する。
◎
A flex item establishes a new formatting context for its contents. The type of this formatting context is determined by its display value, as usual. However, flex items themselves are flex-level boxes, not block-level boxes: they participate in their container’s flex formatting context, not in a block formatting context.
</p>

<hr />

<p class="note">注記：
この仕様を読む~web頁~作者【 以下，単に “作者” 】は、以下に述べる~box~~生成と静的~位置についての詳細を読み飛ばして，<a href="#item-margins">先に進んでも</a>よい。
◎
Note: Authors reading this spec may want to skip past the following box-generation and static position details.
</p>


<p id="cg-display-blockification">
`~flex駒$の `display$p 値は`塊~化$される：
`~flex容器$を生成している要素の`~flow内$にある子に指定された `display$p 値が`行内level$を表す場合、それは，`塊level$を表す等価な値に算出される。
（この種の `display^p 値の変換についての詳細は、
<a href="~CSS2VISUREN#dis-pos-flo">CSS2.1 の 9.7 節</a> `CSS21$r, および
<a href="~CSSDISP#transformations">CSS Display</a> `CSS3-DISPLAY$r
を見よ。）
◎
The display value of a flex item is blockified: if the specified display of an in-flow child of an element generating a flex container is an inline-level value, it computes to its block-level equivalent. (See CSS2.1§9.7 [CSS21] and CSS Display [CSS3-DISPLAY] for details on this type of display value conversion.)
</p>

<p class="note" id="cg-anonymous-fixup-2">注記：
`display$p の値のうち，一部のものは、通常は，元の~boxを囲う匿名~boxの作成を誘発する。
そのような~boxが`~flex駒$であった場合、最初に`塊~化$されるので，匿名~boxの作成は起こらない。
例えば，連続する二つの［
`display$p:table-cell にされた子~要素
］が与えられた下では、その二つが単独の匿名~table~boxに包装されることはなく，別々の `display$p:block にされた`~flex駒$になる。
◎
Note: Some values of display normally trigger the creation of anonymous boxes around the original box. If such a box is a flex item, it is blockified first, and so anonymous box creation will not happen. For example, two contiguous flex items with display: table-cell will become two separate display: block flex items, instead of being wrapped into a single anonymous table.
</p>

		<section id="abspos-items">
<h3 title="Absolutely-Positioned Flex Children">4.1. 絶対位置の子 ~flex</h3>

<p id="cg-2016-abspos-no-order">
`~flex容器$（以下，この節では単に %容器 と記す）の子のうち，`絶対位置の$もの（以下，単に %子 と記す）は、`~flow外$にあるので，~flex~layoutに関与することはない。
◎
As it is out-of-flow, an absolutely-positioned child of a flex container does not participate in flex layout.
</p>


<p>
%子 の`静的~位置$は、［
%子 と %容器 のいずれも，［
それらの使用~sizeによる固定~sizeの~boxである
］と見なした下で、 %子 を［
それが %容器 の中の唯一の`~flex駒$であった
］かのように位置させる
］ことにより，決定される。
この目的においては、 `align-self$p に対する値 `auto^v は， `start^v と同一に扱われる
◎
The static position of an absolutely-positioned child of a flex container is determined such that the child is positioned as if it were the sole flex item in the flex container, assuming both the child and the flex container were fixed-size boxes of their used size. For this purpose, a value of align-self: auto is treated identically to start.
</p>


<div class="note">

<p>注記：
言い換えれば、  %子 の`静的位置 矩形$は， %容器 の内容~boxになる。
ここで，
`静的位置 矩形@
とは、 %子 ~boxの 静的位置~offsetを決定するために用いられる
<a href="~CSSALIGN#alignment-container">整列~容器</a>
である。
◎
In other words, the static-position rectangle of an absolutely-positioned child of a flex container is the flex container’s content box, where the static-position rectangle is the alignment container used to determine the static-position offsets of an absolutely-positioned box.
</p>

<p>
（塊~layoutにおいては、静的位置 矩形は
<!-- 
<a href="~CSS2VISUDET#abs-non-replaced-width">CSS2.1 の 10.3.7 節</a>
 -->
CSS2.1 の`静的~位置$にて述べられている
“仮の~box（ hypothetical box ）”
の位置に対応する。
CSS2.1 の下では，整列~propは無いため、`静的位置 矩形$における 絶対位置の~boxの整列には，常に `塊始端$／`行内始端$ が用いられる。
この定義は、最終的には， `CSS-POSITION-3$r ~moduleに移行されることに注意。）
◎
(In block layout the static position rectangle corresponds to the position of the “hypothetical box” described in CSS2.1§10.3.7. Since it has no alignment properties, CSS2.1 always uses a block-start inline-start alignment of the absolutely-positioned box within the static-position rectangle. Note that this definition will eventually move to the CSS Positioning module.)
</p>

</div>


<div class="example">
<p>
このことから、例えば， %子 に `align-content$p:center を設定した場合、
%子 に対する `auto^v による~offsetは， %容器 の`交叉軸$において中央~寄せにすることになる。
◎
The effect of this is that if you set, for example, align-content: center; on an absolutely-positioned child of a flex container, auto offsets on the child will center it in the flex container’s cross axis.
</p>

<p>
しかしながら、 絶対位置の~boxは，
“固定~size”
と見なされるので、値 `stretch$v:ais は， `flex-start$v:ais と同じに扱われる。
◎
However, since the absolutely-positioned box is considered to be “fixed-size”, a value of stretch is treated the same as flex-start.
</p>

</div>


		</section>
		<section id="item-margins">
<h3 title="Flex Item Margins and Paddings">4.2. ~flex駒の~marginと~padding</h3>

<p>
隣接する 2 個の`~flex駒$の~marginは相殺されない。
◎
The margins of adjacent flex items do not collapse.
</p>

<p>
`~flex駒$上の百分率による［
~margin／~padding
］は、次のいずれかに対し解決される：
◎
Percentage margins and paddings on flex items can be resolved against either:
</p>

<ul id="cg-percentage-margins">
	<li>
それ自身の軸（［
左端, 右端
］［
~margin／~padding
］に対する百分率は 横幅に対し解決され，［
上端, 下端
］に対するそれは縦幅に対し解決される）。
◎
their own axis (left/right percentages resolve against width, top/bottom resolve against height), or,
</li>
	<li>
行内~軸（［
左端, 右端, 上端, 下端
］いずれにせよ、百分率は横幅【行内~size】に対し解決される）。
◎
the inline axis (left/right/top/bottom percentages all resolve against width)
</li>
</ul>

<p>
~UAは、上の挙動のうち，いずれかを選ばな~MUST。
◎
A User Agent must choose one of these two behaviors.
</p>

<p class="note">注記：
この~~分岐は嫌らしいが、~~現実の現在の状態を正確0に捉えるものである（各~実装~間, および CSSWG の中でも合意は形成されていない）。
CSSWG は，各~browser間の挙動が片方に収束することになるものと意図している
— そうなったなら、それを要求するように仕様は訂正されることになる。
◎
Note: This variance sucks, but it accurately captures the current state of the world (no consensus among implementations, and no consensus within the CSSWG). It is the CSSWG’s intention that browsers will converge on one of the behaviors, at which time the spec will be amended to require that.
</p>

<p><strong class="advisement">
作者は、`~flex駒$上では，［
~margin／~padding
］に対する百分率の利用はすべからく避けるべきである
— そうすると~browserごとに挙動が異なることになるので。
</strong>
◎
Authors should avoid using percentages in paddings or margins on flex items entirely, as they will get different behavior in different browsers.
</p>

<p>
~auto~marginは、対応する次元の余った空間を吸収するように拡幅される。
これを利用して、~flex駒に対し，互いを整列させたり, 隣接するものを離れた所へ押出すことができる。
`~auto_v~margin$による整列法を見よ。
◎
Auto margins expand to absorb extra space in the corresponding dimension. They can be used for alignment, or to push adjacent flex items apart. See Aligning with auto margins.
</p>


		</section>
		<section id="painting">
<h3 title="Flex Item Z-Ordering">4.3. ~flex駒の z ~~方向の順序付け</h3>

<p>
`~flex駒$は、［
そのままの文書順に代わって， `order$p による`改変文書順$が利用される
］こと，および［
`position$p
が `static^v であっても，［
`auto^v 以外の `z-index$p 値
］が積層文脈を作成する
］ことを除いて，行内~塊 `CSS21$r と正確に同じ様に塗られる。
◎
Flex items paint exactly the same as inline blocks [CSS21], except that order-modified document order is used in place of raw document order, and z-index values other than auto create a stacking context even if position is static.
</p>

<p class="note">注記：
~flex駒の子孫は、その外側に位置させられても，~flex駒により確立される積層文脈に関与する。
◎
Note: Descendants that are positioned outside a flex item still participate in any stacking context established by the flex item.
</p>

		</section>
		<section id="visibility-collapse">
<h3 title="Collapsed Items">4.4. ~collapseされる駒</h3>

<p>
~flex駒~上にて
`visibility$p:collapse
を指定することにより，~flex駒は
<dfn id="collapsed-flex-item" title="collapsed flex item|collapsed">~collapseされ</dfn>，
［
`table-row^v や `table-column^v 上の `visibility$p:collapse
］と似た効果を産み出す：
~collapseされた~flex駒は，描画~対象からは まるごと外されるが、~flex~lineの交叉sizeを安定させるため， “支柱【概念的な突っ支い棒】” だけ居残るようにされる。
従って，~flex容器の~flex~lineが一本だけの場合、駒における~collapseの有無が動的に~~変化しても，`~flex容器$の`主size$は変化し得るが，`交叉size$に対しては効果を持たず、頁の~layoutの残りの部分を “揺らがす” ことはないことが保証される。
一方で，複数~lineを伴う~flex容器の交叉sizeは、~flex~lineの折返しが~collapse 処理の後にも <em>再び行われる</em>ので，変化し得る。
【~collapse （“~~縮退” ） — ~marginの collapse（ “~~相殺” ）とは ある意味~~似て異なる。】
◎
Specifying visibility:collapse on a flex item causes it to become a collapsed flex item, producing an effect similar to visibility:collapse on a table-row or table-column: the collapsed flex item is removed from rendering entirely, but leaves behind a "strut" that keeps the flex line’s cross-size stable. Thus, if a flex container has only one flex line, dynamically collapsing or uncollapsing items may change the flex container’s main size, but is guaranteed to have no effect on its cross size and won’t cause the rest of the page’s layout to "wobble". Flex line wrapping is re-done after collapsing, however, so the cross-size of a flex container with multiple lines might or might not change.
</p>

<p>
~collapseされた~flex駒は描画されないが，
<a href="~CSS21/intro.html#formatting-structure">整形~構造</a>
には現れる。
従って，
`display$p:none `CSS21$r
の駒と異なり、
整形~構造の下で~boxの出現に依存する効果（ counter の増加, あるいは~animationや遷移効果【 CSS Animation, CSS Transition 】の実行, 等々）は、依然として，~collapseされた駒~上でも行われる。
◎
Though collapsed flex items aren’t rendered, they do appear in the formatting structure. Therefore, unlike on display:none items [CSS21], effects that depend on a box appearing in the formatting structure (like incrementing counters or running animations and transitions) still operate on collapsed items.
</p>

<div class="example">
<p>
次の例では、左に位置する~sidebarが，その内容を収めるように~sizeされる。
~navigation~sidebarの部品を
—
その最も幅広な駒 （ “Architecture” ）が~collapseされた区域に入ったとしても，~sidebarの横幅に影響しないように
—
動的に隠すために，
`visibility$p:collapse
が用いられる。
◎
In the following example, a sidebar is sized to fit its content. visibility: collapse is used to dynamically hide parts of a navigation sidebar without affecting its width, even though the widest item (“Architecture”) is in a collapsed section.
</p>

<figure>

<figcaption><p><b>図 3.</b>
下記の~code例の生きた描画~見本：
◎
Sample live rendering for example code below
</p></figcaption>


<div id="_dgm-visibility-collapse-example">
	<nav>
		<ul>
			<li id="nav-about"><a href="#nav-about">About</a>
				<ul>
<li><a href="#_dummy">History</a></li>
<li><a href="#_dummy">Mission</a></li>
<li><a href="#_dummy">People</a></li>
				</ul>
			</li>
			<li id="nav-projects"><a href="#nav-projects">Projects</a>
				<ul>
<li><a href="#_dummy">Art</a></li>
<li><a href="#_dummy">Architecture</a></li>
<li><a href="#_dummy">Music</a></li>
				</ul>
			</li>
				<li id="nav-interact"><a href="#nav-interact">Interact</a>
				<ul>
<li><a href="#_dummy">Blog</a></li>
<li><a href="#_dummy">Forums</a></li>
				</ul>
			</li>
		</ul>
	</nav>
	<article>
左の~menu上を~hoverすると：
~hoverされた~menu項目は，その下位~駒を示すように拡幅される。
~sidebarの横幅（および この主~区画の横幅）を安定させるため、
`display$p:none に代わって `visibility$p:collapse が利用される。
この結果，~sidebarは常に、普段は可視でない長めの単語 “Architecture” にも十分な幅がとられる。
◎
Hover over the menu to the left: each section expands to show its sub-items. In order to keep the sidebar width (and this main area width) stable, visibility: collapse is used instead of display: none. This results in a sidebar that is always wide enough for the word “Architecture”, even though it is not always visible.
	</article>
</div>

<p>【このページの実際の~codeでは、（~flex~~未対応~browserでも~~動作するように，）等価な挙動を模倣する~styleがあてがわれている。】</p>
</figure>


<pre class="lang-css">
@media (`min-width$d:60em) {
  /* <span class="comment">
（既定の~text~sizeに比して）十分な部屋があるときだけ， 2 本の~colで~layoutする◎
two column layout only when enough room (relative to default text size)
</span> */
  div { `display$p:flex; }
  #main {
    `flex$p:1;         /* <span class="comment"
title="Main takes up all remaining space"
>残りの空間すべては #main が占める
</span> */
    `order$p:1;        /* <span class="comment"
title="Place it after (to the right of) the navigation"
>~navigation（ nav ）の後ろ（右側）に配置する
</span> */
    `min-width$p:12em; /* <span class="comment"
title="Optimize main content area sizing"
>主~内容~領域の~sizingを最適化する
</span> */
  }
}
/* <span class="comment">
`visibility$p:collapse が働くよう，~menu項目には~flex~layoutを用いる
◎
menu items use flex layout so that visibility:collapse will work
</span> */
nav &gt; ul &gt; li {
  `display$p:flex;
  `flex-flow$p:column;
}
/* <span class="comment">
操作中でない下位~menuは，動的に~collapseする
◎
dynamically collapse submenus when not targetted
</span> */
nav &gt; ul &gt; li:not(:target):not(:hover) &gt; ul {
  `visibility$p:collapse;
}
</pre>

<pre class="markup">
&lt;/header&gt;
&lt;div&gt;
  &lt;article id="main"&gt;
    Interesting Stuff to Read
  &lt;/article&gt;
  &lt;nav&gt;
    &lt;ul&gt;
      &lt;li id="nav-about"&gt;&lt;a href="#nav-about"&gt;About&lt;/a&gt;
        …
      &lt;li id="nav-projects"&gt;&lt;a href="#nav-projects"&gt;Projects&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a href="…"&gt;Art&lt;/a&gt;
          &lt;li&gt;&lt;a href="…"&gt;Architecture&lt;/a&gt;
          &lt;li&gt;&lt;a href="…"&gt;Music&lt;/a&gt;
        &lt;/ul&gt;
      &lt;li id="nav-interact"&gt;&lt;a href="#nav-interact"&gt;Interact&lt;/a&gt;
        …
    &lt;/ul&gt;
  &lt;/nav&gt;
&lt;/div&gt;
&lt;footer&gt;
…
</pre>

</div>


<p>
支柱~sizeを算出するためには、最初に，すべての駒について~collapseされないものとした下で ~flex~layoutが遂行され、しかる後，~collapseされた各~駒が［
駒の元の~lineの元の交叉sizeを維持するような支柱
］に置換された上で，~flex~layoutが再実行される。
`visibility$p:collapse
が，どのように~flex~layoutに作用するかについての正式な定義は、`~flex~layout~algo$を見よ。
◎
To compute the size of the strut, flex layout is first performed with all items uncollapsed, and then re-run with each collapsed item replaced by a strut that maintains the original cross-size of the item’s original line. See the Flex Layout Algorithm for the normative definition of how visibility:collapse interacts with flex layout.
</p>

<p class="note">注記：
~flex駒~上における
`visibility$p:collapse
の利用は、最も高価な手続きである
~flex~layout~algoを，部分的に繰り返し再実行させることになる。
作者には、~collapseの有無が動的に~~変化しない駒を隠す際には、
`display$p:none
を利用し続けることが推奨される。
その方が~layout~engineにとってはより効率的になるので。
（しかしながら， `visibility$p が変化した際には，手続きの必要な部分のみが繰り返されるので、動的な場合には，依然として
`visibility$p:collapse
が推奨される。）
◎
Note: Using visibility:collapse on any flex items will cause the flex layout algorithm to repeat partway through, re-running the most expensive steps. It’s recommended that authors continue to use display:none to hide items if the items will not be dynamically collapsed and uncollapsed, as that is more efficient for the layout engine. (Since only part of the steps need to be repeated when visibility is changed, however, 'visibility: collapse' is still recommended for dynamic cases.)
</p>

		</section>
		<section id="min-size-auto">
<h3 title="Implied Minimum Size of Flex Items">4.5. ~flex駒に対する暗黙の最小~size</h3>

<p>
`~flex駒$に対する既定の最小~sizeとして，より適度なものを提供するため、この仕様では， CSS 2.1 にて定義された
`min-width$p, `min-height$p
~prop `CSS21$r に対する初期値として，新たな値 `auto$v:min を導入する。
◎
To provide a more reasonable default minimum size for flex items, this specification introduces a new auto value as the initial value of the min-width and min-height properties defined in CSS 2.1. [CSS21]
</p>

`●名^ `min-width$p, `min-height$p
`●新値^ `auto$v:min
`●新初^ `auto^v
`●新算^ 
百分率による指定値,
または絶対化された長さ,
または~keyword
◎
the percentage as specified or the absolute length or a keyword
`●表終^


<dl>
	<dt>`auto@v:min</dt>
	<dd id="cg-2016-reword-min-auto">
［
`overflow$p が`主軸$において `visible$v である，`~flex駒$
］の~min`主size~prop$に指定された場合、
`自動的~最小~size@
を指定する。
他の場合の算出値は（将来~仕様にて定義されない限り） `0^v になる。
◎
On a flex item whose overflow is visible in the main axis, when specified on the flex item’s main-axis min-size property, specifies an automatic minimum size. It otherwise computes to 0 (unless otherwise defined by a future specification).
</dd>
</dl>

<div class="p">

<p>
駒の`自動的~最小~size$は、次で与えられる：
</p>

<dl class="switch">
	<dt>当の~boxが，縦横比を有しつつ, `指定~size$は定義されない場合：</dt>
	<dd>
min( 駒の`内容~size$, 駒の`転換~size$ )
</dd>

	<dt>他の場合：</dt>
	<dd>
min( 駒の`内容~size$, 駒の`指定~size$ )
</dd>

</dl>

<p>
上の, および この節における［
各~引数の最小~値をとる関数 min(…) 
］は、~sizeが定義されない, または`不定$の引数については無視するものとする。
最大~値とる関数  max(…) についても，同様とする。
</p>

◎
In general, the automatic minimum size is the smaller of its content size and its specified size. However, if the box has an aspect ratio and no specified size, its automatic minimum size is the smaller of its content size and its transferred size.
</div>


<p>
上の計算に利用される［
`内容~size$, `指定~size$, `転換~size$
］は、以下に定義される
— これらには、`自動的~最小~size$が作者から提供された拘束に干渉しないように，関連する［
~min／~max／選好
］~size~propも織り込まれる。
◎
The content size, specified size, and transferred size used in this calculation account for the relevant min/max/preferred size properties so that the automatic minimum size does not interfere with any author-provided constraints, and are defined below:
</p>

<p>
以下では：
</p>

<ul>
	<li>
［
%主size ／ %~max主size ／ %~min主size
］は、駒の［
`主size~prop$ ／ ~max`主size~prop$ ／~min`主size~prop$
］の算出値を表すとする
— これらの値は、`不定$になり得る（次項も同様）。
</li>

	<li>
［
%交叉size ／ %~max交叉size ／ %~min交叉size
］は、駒の［
`交叉size~prop$ ／ ~max`交叉size~prop$ ／~min`交叉size~prop$
］の算出値を表すとする。
</li>
</ul>

<dl>
	<dt>`指定~size@</dt>
	<dd>
%主size が`確定的$であるときにのみ定義される
⇒
値は、
min( %主size, %~max主size )
で与えられる。
◎
If the item’s computed main size property is definite, then the specified size is that size (clamped by its max main size property if it’s definite). It is otherwise undefined.
</dd>

	<dt>`転換~size@</dt>
	<dd>
駒が［
内在的~縦横比を有する, かつ
%交叉size は`確定的$である
］場合にのみ定義される
⇒
値は、
max( min( %交叉size, %~max交叉size ), %~min交叉size )
を，縦横比で変換した結果で与えられる。
◎
If the item has an intrinsic aspect ratio and its computed cross size property is definite, then the transferred size is that size (clamped by its min and max cross size properties if they are definite), converted through the aspect ratio. It is otherwise undefined.
</dd>

	<dt>`内容~size@</dt>
	<dd>
<p>
値は、`主軸$における駒の`最小内容~size$を %s とするとき：
</p>
		<ol>
			<li>
まず，駒が内在的~縦横比を有するならば
⇒
［
max( min( %s を縦横比で変換した結果, %~max交叉size ), %~min交叉size ) 
］を縦横比で変換した結果を %s とする。
</li>
			<li>
結果は、
min( %s, %主size )
で与えられる。
</li>
		</ol>
◎
The content size is the min-content size in the main axis, clamped, if it has an aspect ratio, by any definite min and max cross size properties converted through the aspect ratio, and then further clamped by the max main size property if that is definite.
</dd>
</dl>


<p id="cg-2016-intrinsic-percentage-1">
要素の内在的~size（例： 要素の`最小内容~size$）を計算する目的においては、この `auto$v:min 値は，当の軸における要素の~sizeを不定にする（例えば要素の `width$p ~propが確定的~sizeを指定していても）。
これは、この~sizeに対し計算される百分率が `auto^v に扱われることを意味することに注意。
◎
For the purpose of calculating an intrinsic size of the element (e.g. the element’s min-content size), this value causes the element’s size in that axis to become indefinite (even if e.g. its width property specifies a definite size). Note this means that percentages calculated against this size will be treated as auto.
</p>

<p id="cg-min-auto-intrinsic-percentages">
<span id="cg-2016-intrinsic-percentage-2">いずれにせよ，</span>これは、一部の事例において百分率を再度~解決するために，追加の再layoutを要することもあるが、この値は，駒の中の百分率~sizeの解決を防止するものではない（ `CSS3-SIZING$r に定義される値［
`min-content$v, `max-content$v, `fit-content$v
］と同様に）。
◎
Nonetheless, although this may require an additional layout pass to re-resolve percentages in some cases, this value (like the min-content, max-content, and fit-content values defined in [CSS3-SIZING]) does not prevent the resolution of percentage sizes within the item.
</p>


<div class="note" id="min-size-opt">
<p>
大抵の場合、内容に基づく最小~sizeは適切であり，内容が重なり合ったり, その容器の外側にあふれないようにするが、一部の場合はそうならない：
◎
Note that while a content-based minimum size is often appropriate, and helps prevent content from overlapping or spilling outside its container, in some cases it is not:
</p>

<p>
特に、~flex~sizingが文書の~~主要な内容~領域に用いられる場合、~font~sizeに相対的な，最小の横幅（ `min-width$p:12em など）を明示的に設定した方がよい。
最小~横幅が内容に基づくものである場合、巨大な~table／画像があるときに，内容~領域~全体の~sizeを~overflowする地帯にまで伸張させ、~text行を無用に~~長く, 読みづらくさせることになる。
◎
In particular, if flex sizing is being used for a major content area of a document, it is better to set an explicit font-relative minimum width such as min-width: 12em. A content-based minimum width could result in a large table or large image stretching the size of the entire content area into an overflow zone, and thereby making lines of text gratuitously long and hard to read.
</p>

<p>
多量の内容を伴う駒に内容に基づく~sizingが用いられた場合、~layout~engineはその最小~sizeを見出す前に，その内容すべてを走査しなければならなくなる。
作者が明示的な最小~sizeを設定しておけば、これは不要になる。
（駒の内容が少量であれば、その走査は自明なので，処理能の懸念はない）
◎
Note also, when content-based sizing is used on an item with large amounts of content, the layout engine must traverse all of this content before finding its minimum size, whereas if the author sets an explicit minimum, this is not necessary. (For items with small amounts of content, however, this traversal is trivial and therefore not a performance concern.)
</p>

</div>

		</section>
	</section>
	<section id="flow-order">
<h2 title="Ordering and Orientation">5. 順序付けと方位</h2>

<p>
~flex容器の内容は、任意の方向, 任意の順序で~lay-outできる。
これにより、作者は，以前までは
`float$p, `clear$p
~propの併用による~hackなど，複雑, あるいは不安定な手法を要していた効果も、自明に得られるようになる。
この機能性は
`flex-direction$p,
`flex-wrap$p,
`order$p
~propを通して公開される。
◎
The contents of a flex container can be laid out in any direction and in any order. This allows an author to trivially achieve effects that would previously have required complex or fragile methods, such as hacks using the float and clear properties. This functionality is exposed through the flex-direction, flex-wrap, and order properties.
</p>

<p class="note">注記：
~flex~layoutによる並替えの能力は，意図的に
<em>視覚的~描画に対してのみ</em>
影響するようにされており、発話~順序や, ~source順序に基づく~navigationは，そのままにされる。
これにより，作者は、［
非 CSS の~UA, あるいは
発話や逐次的~navigationなどの一次元的~model
］のための~source順序には触れずに，視覚的~呈示を操作できるようになる。
この，~accessibilityを改善する分岐の用例については、
<a href="#order-accessibility">並替えと~accessibility</a>,
<a href="#overview">~flex~layoutの概観</a>
を見よ。
◎
Note: The reordering capabilities of flex layout intentionally affect only the visual rendering, leaving speech order and navigation based on the source order. This allows authors to manipulate the visual presentation while leaving the source order intact for non-CSS UAs and for linear models such as speech and sequential navigation. See Reordering and Accessibility and the Flex Layout Overview for examples that use this dichotomy to improve accessibility.
</p>

<p class="advisement">
作者は、
`flex-flow$p／`flex-direction$p
に対する `*-reverse^v 値を，~source順序付けを正すための代用として 利用しては<em>~MUST_NOT</em>。
文書の~accessibilityを損ないかねないので。
◎
Authors must not use order or the *-reverse values of flex-flow/flex-direction as a substitute for correct source ordering, as that can ruin the accessibility of the document.
</p>

		<section id="flex-direction-property">
<h3 title="Flex Flow Direction: the flex-direction property">5.1. ~flexの~flow方向： `flex-direction^p ~prop</h3>

`●名^ `flex-direction@p
`●値^
`row$v:fd |
`row-reverse$v:fd |
`column$v:fd |
`column-reverse$v:fd
`●初^ `row$v:fd
`●適^ `~flex容器$
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値
`●ア^ 不可
`●表終^

<p>
`flex-direction$p ~propは、~flex容器の`主軸$の方向を設定することにより，`~flex駒$が~flex容器の中で
どのように配置されるかを指定する。
これは、一連の~flex駒が~lay-outされていく方向を決定する：
◎
The flex-direction property specifies how flex items are placed in the flex container, by setting the direction of the flex container’s main axis. This determines the direction in which flex items are laid out.
</p>

<dl>
	<dt>`row@v:fd</dt>
	<dd>
~flex容器の`主軸$は、現在の`書字mode$の`行内軸$と同じ方位になるようにされる。
`主始端$／`主終端$
の方向は、現在の`書字mode$の
`行内始端$／`行内終端$
の方向に等価になる。
◎
The flex container’s main axis has the same orientation as the inline axis of the current writing mode. The main-start and main-end directions are equivalent to the inline-start and inline-end directions, respectively, of the current writing mode.
</dd>

	<dt>`row-reverse@v:fd</dt>
	<dd>
`主始端$と`主終端$
の方向が入換わることを除き， `row$v:fd と同じ。
◎
Same as row, except the main-start and main-end directions are swapped.
</dd>

		<dt>`column@v:fd</dt>
		<dd>
~flex容器の`主軸$は、現在の`書字mode$の`塊軸$と同じ方位になるようにされる。
`主始端$／`主終端$
の方向は、現在の`書字mode$の
`塊始端$／`塊終端$
の方向に等価になる。
◎
The flex container’s main axis has the same orientation as the block axis of the current writing mode. The main-start and main-end directions are equivalent to the block-start and block-end directions, respectively, of the current writing mode.
</dd>

		<dt>`column-reverse@v:fd</dt>
		<dd>
`主始端$と`主終端$
の方向が入換わることを除き， `column$v:fd と同じ。
◎
Same as column, except the main-start and main-end directions are swapped.
</dd>

</dl>

<p class="note">注記：
…`-reverse^v 値は、~boxの順序付けを “逆順” にするものではない
—
`writing-mode$p, `direction$p `CSS3-WRITING-MODES$r
と同様に，それらは~flowの方向のみを変化させる。
塗り,
発話,
逐次的~navigation
の順序は影響されない。
◎
Note: The reverse values do not reverse box ordering: like writing-mode and direction [CSS3-WRITING-MODES], they only change the direction of flow. Painting order, speech order, and sequential navigation orders are not affected.
</p>

		</section>
		<section id="flex-wrap-property">
<h3 title="Flex Line Wrapping: the flex-wrap property">5.2. ~flex~lineの折返し： `flex-wrap^p ~prop</h3>

`●名^ `flex-wrap@p
`●値^
`nowrap$v:fw |
`wrap$v:fw |
`wrap-reverse$v:fw
`●初^ `nowrap$v:fw
`●適^ `~flex容器$
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値
`●ア^ 不可
`●表終^

<p>
`flex-wrap$p ~propは、［
~flex容器が
`単line$, `複line$
のいずれになるか
］, および［
新たな~lineが堆積されていく方向（順方向か逆方向か）を決定する，`交叉軸$の向き
］
を制御する
◎
The flex-wrap property controls whether the flex container is single-line or multi-line, and the direction of the cross-axis, which determines the direction new lines are stacked in.
</p>

<dl>
	<dt>`nowrap@v:fw</dt>
	<dd>
~flex容器は`単line$になる。
◎
The flex container is single-line.
</dd>

	<dt>`wrap@v:fw</dt>
	<dd>
~flex容器は`複line$になる。
◎
The flex container is multi-line.
</dd>

	<dt>`wrap-reverse@v:fw</dt>
	<dd>
`wrap$v:fw と同じ。
◎
Same as wrap.
</dd>

</dl>

<p>
`wrap-reverse$v:fw 以外の値に対しては、`交叉始端$ 方向は，現在の`書字mode$の［
`行内始端$, `塊始端$
］方向のうち`交叉軸$に属する方と等価になり、`交叉終端$方向は，その反対~方向になる。
`flex-wrap$p が `wrap-reverse$v:fw のときは、［
`交叉始端$, `交叉終端$
］方向が入換わる。
◎
For the values that are not wrap-reverse, the cross-start direction is equivalent to either the inline-start or block-start direction of the current writing mode (whichever is in the cross axis) and the cross-end direction is the opposite direction of cross-start. When flex-wrap is wrap-reverse, the cross-start and cross-end directions are swapped.
</p>


		</section>
		<section id="flex-flow-property">
<h3 title="Flex Direction and Wrap: the flex-flow shorthand">5.3. ~flexの~flow方向と折返し： `flex-flow^p ~shorthand</h3>

`●名^ `flex-flow@p
`●値^
<var class="production">&lt;‘`flex-direction$p’&gt;</var> ||
<var class="production">&lt;‘`flex-wrap$p’&gt;</var>
`●初^ 個々の~propを見よ◎see individual properties
`●適^ 個々の~propを見よ
`●継^ 個々の~propを見よ
`●百^ 個々の~propを見よ
`●媒^ 個々の~propを見よ
`●算^ 個々の~propを見よ
`●ア^ 個々の~propを見よ
`●表終^

<p>
`flex-flow$p ~propは，［
`flex-direction$p, `flex-wrap$p
］~propを設定するための~shorthandであり，
~flex容器の［
主軸, 交叉軸
］を同時に定義する。
◎
The flex-flow property is a shorthand for setting the flex-direction and flex-wrap properties, which together define the flex container’s main and cross axes.
</p>

<div class="example">
<p>
英語~文書（ left-to-right<!-- ＊ -->, 横書き書字mode）の下での妥当な~flowの例：
◎
Some examples of valid flows in an English (left-to-right, horizontal writing mode) document:
</p>

<table style="margin: 0; border-spacing: 1em 0em;">


<tbody id="_ex-flex-flow-table"><tr><td>

`flex-flow$p:row

<p>
初期値。
主軸は行内, 折返しなし。
（駒たちは，容器に収まるように縮短されるか, または~overflowする。)
◎
Initial value. Main-axis is inline, no wrapping.
(Items will either shrink to fit or overflow.)
</p>

</td><td style="padding-right:40px;">`flex-flow1^dgm

</td></tr><tr><td>

`flex-flow$p:column_wrap

<p>
主軸は塊~方向（上端から下端へ）になり,
一連の~lineは行内~方向（右方）に折返される。
◎
Main-axis is block-direction (top to bottom)
and lines wrap in the inline direction (rightwards).
</p>

</td><td>`flex-flow2^dgm

</td></tr><tr><td>

`flex-flow$p:row-reverse_wrap-reverse

<p>
主軸は行内~方向の反対（右端から左端へ）。
新たな~lineは上方に折返される。
◎
Main-axis is the opposite of inline direction
(right to left). New lines wrap upwards.
</p>

</td><td>`flex-flow3^dgm

</td></tr></tbody></table>

</div>


<div class="note">
<p>注記：
`flex-flow$p 方向は、`書字mode$に~~影響される。
縦書き日本語の下では、 `row$v:fd ~flex容器は，例えば次の様に その内容を上端から下端へ~lay-outする。
◎
Note that the flex-flow directions are writing mode sensitive. In vertical Japanese, for example, a row flex container lays out its contents from top to bottom, as seen in this example:
</p>

<table>

<thead><tr><th title="English">英語
</th><th title="Japanese">日本語
</th></tr></thead>

<tbody><tr>
<td><pre class="lang-css">
`flex-flow$p:___row_wrap;
`writing-mode$p:horizontal-tb;</pre></td>
<td><pre class="lang-css">
`flex-flow$p:___row_wrap;
`writing-mode$p:vertical-rl;</pre></td>
		</tr>
		<tr style="text-align: center;">
<td>`flex-flow-english^dgm

</td><td>`flex-flow-japanese^dgm
</td>
		</tr>
	</tbody>
</table>


</div>





		</section>
		<section id="order-property">
<h3 title="Display Order: the order property">5.4. 陳列~順序： `order^p ~prop</h3>

<p>
`~flex駒$は，既定では、それらが~source文書に現れるのと同じ順序で，陳列され, ~lay-outされる。
`order$p ~propを，この順序付けの変更に利用できる。
◎
Flex items are, by default, displayed and laid out in the same order as they appear in the source document. The order property can be used to change this ordering.
</p>

`●名^ `order@p
`●値^
`integer$t
`●初^ `0^v
`●適^ 
`~flex駒$,
および `~flex容器$の子であって `絶対位置の$もの
◎
flex items and absolutely-positioned children of flex containers
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値
`●ア^ 可
`●表終^

<p>
`order$p ~propは、一連の~flex駒を序数が付与されたいくつかの~groupに仕分けることを通して，~flex容器の中で その一連の子が現れる順序を制御する。
それは、`~flex駒$がどの~groupに属するかを表す序数を指定する，単独の
<dfn id="valdef-order-integer">`integer$t</dfn>
を値にとる。
◎
The order property controls the order in which children of a flex container appear within the flex container, by assigning them to ordinal groups. It takes a single &lt;integer&gt; value, which specifies which ordinal group the flex item belongs to.
</p>

<p>
~flex容器は，その内容を序数が最低の~groupから順に~lay-outする。
この順序のことを
`改変文書順@
（
“`order^p ~propにより改変された文書順”
）と呼ぶ。
同じ序数の~groupに属する一連の駒が~lay-outされる順序は，~source文書に現れる順序に従う。
これは、
<a href="~CSS21/zindex.html">塗り順序</a>
`CSS21$r
にも，一連の~flex駒が~source文書~内で並替えが行われていたかのように影響する。
◎
A flex container lays out its content in order-modified document order, starting from the lowest numbered ordinal group and going up. Items with the same ordinal group are laid out in the order they appear in the source document. This also affects the painting order [CSS21], exactly as if the flex items were reordered in the source document.
</p>


<div class="example">

<p>
次の図に，単純な~tab化された UI を示す。
作動中の~paneに対する~tabは，常に最初に来るようにされる：
◎
The following figure shows a simple tabbed interface, where the tab for the active pane is always first:
</p>


<figure>`flex-order-example^dgm</figure>


<p>
これは，次の CSS にて実装できる（~codeの関連する部分のみを示す）：
◎
This could be implemented with the following CSS (showing only the relevant code):
</p>

<pre class="lang-css">
.tabs {
  `display$p:flex;
}
.tabs &gt; .current {
  `order$p:-1; /* <span class="comment">
既定の値 0 を下回る値
◎
Lower than the default of 0
</span> */
}</pre>

</div>

<p>
将来~仕様により 特に指定されない限り、この~propは，`~flex容器$の子でない~boxに対しては 効果を持たない。
◎
Unless otherwise specified by a future specification, this property has no effect on boxes that are not children of a flex container.
</p>

			<section id="order-accessibility">
<h4 title="Reordering and Accessibility">5.4.1 並替えと~accessibility</h4>

<p>
`order$p ~propは、非~視覚的~媒体（
<a href="~CSSSPEECH">発話</a>
など）の順序付けには<em>影響しない</em>。
同様に， `order$p は、逐次的~navigation~modeの下での既定の走査~順序（一連の~linkに渡る巡回など — 例えば
<a href="~HTML50/editing.html#sequential-focus-navigation-and-the-tabindex-attribute"><code>tabindex</code></a>
`HTML5$r
など）にも，影響しない。
作者は、もっぱら視覚的であって, 論理的でないような 内容の並替えに限って， `order$p を利用し<em>~MUST</em>。
`order$p を利用して論理的に並替えるような~stylesheetは、適合でない。
◎
The order property does not affect ordering in non-visual media (such as speech). Likewise, order does not affect the default traversal order of sequential navigation modes (such as cycling through links, see e.g. tabindex [HTML5]). Authors must use order only for visual, not logical, reordering of content. Style sheets that use order to perform logical reordering are non-conforming.
</p>

<p class="note">注記：
これは、視覚的~順序を誂えるために `order$p を利用しつつ（視覚的~認識は二次元であり, 一次元的ではないので、欲される視覚的~順序が常に論理的~順序に一致するとは限らない）、概して内容を一次元的に呈示する 非~視覚的~媒体や非 CSS ~UAが，~sourceの論理的~順序に依拠し得るようにするためである。
◎
Note: This is so that non-visual media and non-CSS UAs, which typically present content linearly, can rely on a logical source order, while order is used to tailor the visual order. (Since visual perception is two-dimensional and non-linear, the desired visual order is not always logical.)
</p>

<div class="example">
<p>
多くの~web頁は 似た様な形に~markupされている
—
上端に~header, 下端に~footerがあって，中段に内容~領域と 1 本か 2 本の追加の~colがある様なものなど。
一般に、~~主~内容は，追加の~colより前の, 頁の~source~codeの最初に来ることが望ましい。
しかしながら，これを得ることは、追加の~colが左に, 内容~領域が右に~~位置するような単純なものも含め，共通的に用いられる多くの設計において、困難である。
これは，年月に渡り 様々な方法で取組まれており、追加~colが 2 本~在るものは，しばしば “Holy Grail Layout” と称されている。
`order$p は これを自明にする。
例えば次の様な，頁の~code, および欲される~layoutがあるとする：
◎
Many web pages have a similar shape in the markup, with a header on top, a footer on bottom, and then a content area and one or two additional columns in the middle. Generally, it’s desirable that the content come first in the page’s source code, before the additional columns. However, this makes many common designs, such as simply having the additional columns on the left and the content area on the right, difficult to achieve. This has been addressed in many ways over the years, often going by the name "Holy Grail Layout" when there are two additional columns. order makes this trivial. For example, take the following sketch of a page’s code and desired layout:
</p>

<div class="code-and-figure">
<div><pre class="markup">
&lt;!DOCTYPE html&gt;
&lt;header&gt;...&lt;/header&gt;
&lt;main&gt;
   &lt;article&gt;...&lt;/article&gt;
   &lt;nav&gt;...&lt;/nav&gt;
   &lt;aside&gt;...&lt;/aside&gt;
&lt;/main&gt;
&lt;footer&gt;...&lt;/footer&gt;</pre></div>

<div>`flex-order-page^dgm</div>
</div>

<p>
この~layoutは，~flex~layoutにより容易に得られる：
◎
This layout can be easily achieved with flex layout:
</p>

<pre class="lang-css">
main { `display$p:flex; }
main &gt; article { `order$p:2; `min-width$p:12em; `flex$p:1; }
main &gt; nav     { `order$p:1; `width$p:200px; }
main &gt; aside   { `order$p:3; `width$p:200px; }</pre>

<p>
追加の特典として、一連の~colは，既定で
<a href="#valdef-align-items-stretch">縦幅が等しく揃えられる</a>ようになり、主~内容は，~screenを埋める必要に応じた幅にされる。
加えて，Media Queries と組合せることにより、狭い~screen幅の下では，すべてを縦方向に~layoutするように切替えることも可能になる：
◎
As an added bonus, the columns will all be equal-height by default, and the main content will be as wide as necessary to fill the screen. Additionally, this can then be combined with media queries to switch to an all-vertical layout on narrow screens:
</p>

<pre class="lang-css">
@media all and (`max-width$p:600px) {
  /* <span class="comment">
3 本の~colには狭過ぎるときの~support
◎
     Too narrow to support three columns
</span> */
  main { `flex-flow$p:column; }
  main &gt; article, #main &gt; nav, #main &gt; aside {
  /* <span class="comment">
文書順に戻す
◎
   Return them to document order
</span> */
    `order$p:0; `width$p:auto;
  }
}</pre>

<p><small>（
より気の利いた折返しを得るための，複line ~flex容器の更なる利用は、読者への演習として残しておく。
）</small>
◎
(Further use of multi-line flex containers to achieve even more intelligent wrapping left as an exercise for the reader.)
</p>

</div>

<p id="cg-a11y-tools-1">
作者が意図する順序付けを，すべての呈示~modeにわたって保全するため、著作~toolは（ WYSIWYG ~editorや~webに基づく著作~支援その他も含め），
`order$p を利用して並替えることなく，下層の文書~sourceを並替えることが要求される
— 作者から，（発話や~navigation順序を決定する）下層の文書~順序と視覚的~順序は <em>違えるべき</em> と明示的に指示された場合は別として。
◎
In order to preserve the author’s intended ordering in all presentation modes, authoring tools—including WYSIWYG editors as well as Web-based authoring aids—must reorder the underlying document source and not use order to perform reordering unless the author has explicitly indicated that the underlying document order (which determines speech and navigation order) should be out-of-sync with the visual order.
</p>

<div class="example" id="cg-a11y-tools-2">
<p>
例えば、［
~drag-and-dropによる~flex駒の並替え
］と［
~screen~sizeのある範囲ごとに~layoutを別々に~~用意するような媒体~queryの取扱い
］の両者を提供0する~toolもある。
◎
For example, a tool might offer both drag-and-drop reordering of flex items as well as handling of media queries for alternate layouts per screen size range.
</p>

<p>
ほとんどの場合、どの~screen~sizeに対しても，並替えは~navigation／発話 の順序にも同じように影響するべきであり、~toolは，~drag-and-dropによる視覚的~並替えに合わせて DOM 層における並替えを遂行する。
しかしながら、作者が~screen~sizeごとに異なる視覚的~順序付けを求める事例もある。
~toolは、媒体~queryと `order$p を併用して，この機能性を提供0することもできる
— 最小の~screen~sizeに対する順序付けは，（論理的な呈示~順序にほぼ近い）下層の DOM 順序に基づかせつつ、他の~size範囲に対しては， `order$p を利用して視覚的な呈示~順序を決定するなど。
◎
Since most of the time, reordering should affect all screen ranges as well as navigation and speech order, the tool would perform drag-and-drop reordering at the DOM layer. In some cases, however, the author may want different visual orderings per screen size. The tool could offer this functionality by using order together with media queries, but also tie the smallest screen size’s ordering to the underlying DOM order (since this is most likely to be a logical linear presentation order) while using order to determine the visual presentation order in other size ranges.
</p>

<p>
上述のようにする~toolであれば，適合的であろうが、~drag-and-dropによる並替えを取扱うときに `order$p のみを利用する~toolは，（その方が実装は~~簡単かもしれないが）適合的でないことになる。
◎
This tool would be conformant, whereas a tool that only ever used order to handle drag-and-drop reordering (however convenient it might be to implement it that way) would be non-conformant.
</p>

</div>

<p class="note" id="cg-2016-spatial-nav">注記：
［
~browser,  ~accessibility技術, 拡張
］も含め，~UAは、空間的~navigation特色機能を提供0してよい。
この節は、そのような空間的~navigation~modeにおける要素の順序付けを `order$p ~propも加味して決定することを制止するものではない
— ~~実際、そのような特色機能が働くためには必要と見なされている。
しかしながら、逐次的~navigationを決定するときに，
`order$p を利用しつつ, 要素どうしの（~flex~layoutに限らず CSS による種々の~layout特色機能で表される）空間的な関係性は織り込まない~UAは、適合でない。
◎
Note: User agents, including browsers, accessible technology, and extensions, may offer spatial navigation features. This section does not preclude respecting the order property when determining element ordering in such spatial navigation modes; indeed it would need to be considered for such a feature to work. However a UA that uses order in determining sequential navigation, but does not otherwise account for spatial relationships among elements (as expressed by the various layout features of CSS including and not limited to flex layout), is non-conforming.
</p>


			</section>
		</section>
	</section>
	<section id="flex-lines">
<h2 title="Flex Lines">6. ~flex~line</h2>

<p>
`~flex容器$内の一連の`~flex駒$は、一連の
`~flex~line@
（ “行” ）の中へ，~lay-outされ, 整列される
—
~layout~algoにおいては，仮の容器が
~group分けと整列に用いられる。
~flex容器は、 `flex-wrap$p ~propに依存して，`単line$にも`複line$にもなり得る。
◎
Flex items in a flex container are laid out and aligned within flex lines, hypothetical containers used for grouping and alignment by the layout algorithm. A flex container can be either single-line or multi-line, depending on the flex-wrap property:
</p>

<ul>

	<li>
`単line@
`~flex容器$（すなわち， `flex-wrap$p が `nowrap^v にされたもの）は、そのすべての子を，それらの内容が~overflowするかどうかに関わらず, 単独の~line内に~lay-outする。
◎
A single-line flex container (i.e. one with flex-wrap: nowrap) lays out all of its children in a single line, even if that would cause its contents to overflow.
</li>

	<li>
`複line@
`~flex容器$（すなわち， `flex-wrap$p が［
`wrap^v ／ `wrap-reverse^v
］にされたもの）は、その一連の`~flex駒$を，既存の~lineに収めるには幅が広過ぎるときには，~textが改行で折返されるのと同様に, 複数の~lineに分断する†。
追加の一連の~lineが作成される際には、 `flex-wrap$p ~propに則って，それらは~flex容器の中で `交叉軸$沿いに堆積されていく。
~flex容器~自身が完全に空でない限り、どの~lineも，少なくとも１個の`~flex駒$を包含する。
【† 1 本の~lineに収まるときでも，単lineと異なる扱いになる。】
◎
A multi-line flex container (i.e. one with flex-wrap: wrap or flex-wrap: wrap-reverse) breaks its flex items across multiple lines, similar to how text is broken onto a new line when it gets too wide to fit on the existing line. When additional lines are created, they are stacked in the flex container along the cross axis according to the flex-wrap property. Every line contains at least one flex item, unless the flex container itself is completely empty.
</li>

</ul>

<div class="example">
<p>
次の例に，横方向に収まり切らず 複数~lineに折返される，
4 個のボタンを示す：
◎
This example shows four buttons that do not fit side-by-side horizontally, and therefore will wrap into multiple lines.
</p>

<pre class="lang-css">
#flex {
  `display$p:flex;
  `flex-flow$p:row_wrap;
  `width$p:300px;
}
.item {
  `width$p:80px;
}
</pre>

<pre class="markup">
&lt;div id="flex"&gt;
  &lt;div class="item"&gt;1&lt;/div&gt;
  &lt;div class="item"&gt;2&lt;/div&gt;
  &lt;div class="item"&gt;3&lt;/div&gt;
  &lt;div class="item"&gt;4&lt;/div&gt;
&lt;/div&gt;</pre>

<p>
容器は 300px 幅なので、単独の~lineには 3 個までの駒しか収まらない。
それらは 240px を占め，残りの空間に 60px が残される。
 `flex-flow$p ~propの値には，`複line$ ~flex容器を指定する， `wrap$v:fw ~keywordが現れているので、~flex容器は，最後の駒を包含するための追加の~lineを作成することになる。
◎
Since the container is 300px wide, only three of the items fit onto a single line. They take up 240px, with 60px left over of remaining space. Because the flex-flow property specifies a multi-line flex container (due to the wrap keyword appearing in its value), the flex container will create an additional line to contain the last item.
</p>

<figure>`multiline-no-flex^dgm
<figcaption><p><b>図 4.</b>
複line ~flex容器の描画~例
◎
An example rendering of the multi-line flex container.
</p></figcaption>

</figure>

	</div>

<p>
内容が一連の~lineに分断されたなら，各~lineは独立に~lay-outされる。
`~flexible長さ$, および
`justify-content$p, `align-self$p
~propは、個別の~lineごとにその一連の駒に対し~~適用される。
◎
Once content is broken into lines, each line is laid out independently; flexible lengths and the justify-content and align-self properties only consider the items on a single line at a time.
</p>

<p>
`複line$ ~flex容器においては（~lineが 1 本だけであっても）、各~lineの`交叉size$は，その~line上の一連の`~flex駒$を（ `align-self$p による整列の後で）包含するために必要な最小の~sizeになり、一連の~lineは， `align-content$p ~propにより ~flex容器~内で整列される。
`単line$ ~flex容器においては、その~lineの`交叉size$は ~flex容器の`交叉size$になり， `align-content$p は効果を持たない。
~lineの`主size$は，~flex容器の内容~boxの`主size$と常に同じになる。
◎
In a multi-line flex container (even one with only a single line), the cross size of each line is the minimum size necessary to contain the flex items on the line (after alignment due to align-self), and the lines are aligned within the flex container with the align-content property. In a single-line flex container, the cross size of the line is the cross size of the flex container, and align-content has no effect. The main size of a line is always the same as the main size of the flex container’s content box.
</p>

<div class="example">
<p>
すべての~flex駒に
`flex$p:auto
が与えられていることを除いて，前と同じにされている例を、次に示す。
最初の~lineには残りの空間が 60px あり,
そのすべての駒に同じ~flex性が備わるので、~line上の 3 個の駒それぞれは，余った横幅から 20px ずつ受取る結果, 100px 幅になる。
残る１個の駒はそれのみで~lineを占め，その~lineの横幅~全体, すなわち 300px まで伸張されることになる。
◎
Here’s the same example as the previous, except that the flex items have all been given flex: auto. The first line has 60px of remaining space, and all of the items have the same flexibility, so each of the three items on that line will receive 20px of extra width, each ending up 100px wide. The remaining item is on a line of its own and will stretch to the entire width of the line, i.e. 300px.
</p>

<figure>`multiline-flex^dgm
<figcaption><p><b>図 5.</b>
すべての駒に
`flex$p:auto
が与えられていることを除いて，上と同じ描画
◎
A rendering of the same as above, but with the items all given flex: auto.
</p></figcaption>

</figure>
	</div>


	</section>
	<section id="flexibility">
<h2 title="Flexibility">7. ~flex性</h2>

<p>
~flex~layoutには、一連の`~flex駒$を “~flex” にして、`主~次元$において`可用な空間$を埋めるために，それらの横幅／縦幅を改めることを可能にする能を定義する側面がある。
これは， `flex$p ~propを通して行われる。
~flex容器は、自身を埋めるように，その駒たちに自由空間を（`~flex伸長~係数$に比例する分だけ）配分するか、または，自身を~overflowしないように駒たちを（各~駒の`~flex縮短~係数$に比例する分だけ）縮短する。
◎
The defining aspect of flex layout is the ability to make the flex items “flex”, altering their width/height to fill the available space in the main dimension. This is done with the flex property. A flex container distributes free space to its items (proportional to their flex grow factor) to fill the container, or shrinks them (proportional to their flex shrink factor) to prevent overflow.
</p>


<p id="cg-2016-inflexible-definite-1">
`~flex駒$は、［
`flex-grow$p, `flex-shrink$p
］いずれの値も~zeroならば
`全部的に非~flexible@
であるとされ，そうでないならば
`~flexible@
であるとされる。
◎
A flex item is fully inflexible if both its flex-grow and flex-shrink values are zero, and flexible otherwise.
</p>





		<section id="flex-property">
<h3 title="The flex Shorthand">7.1. `flex^p ~shorthand</h3>

`●名^ `flex@p
`●値^
`none$v:f | [
<var class="production">&lt;‘`flex-grow$p’&gt;</var>
<var class="production">&lt;‘`flex-shrink$p’&gt;</var>? ||
<var class="production">&lt;‘`flex-basis$p’&gt;</var>
]
`●初^ 個々の~propを見よ◎see individual properties
`●適^ `~flex駒$
`●継^ 個々の~propを見よ
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 個々の~propを見よ
`●ア^ 不可
`●順^ 文法に従う◎per grammar
`●表終^

<p>
`flex$p ~propは、
`~flexible長さ@
の各種~成分［
`~flex伸長~係数$,
`~flex縮短~係数$,
`~flex基底$
］を指定する。
~boxが`~flex駒$であるときの，その`主size$の決定には、`主size~prop$の<em>代わりに</em> `flex$p が調べられる。
~boxが`~flex駒$でない場合、 `flex$p は効果を持たない。
◎
The flex property specifies the components of a flexible length: the flex grow factor and flex shrink factor, and the flex basis. When a box is a flex item, flex is consulted instead of the main size property to determine the main size of the box. If a box is not a flex item, flex has no effect.
</p>


<dl>
	<dt class="value production" id="valdef-flex-grow">&lt;‘`flex-grow$p’&gt;</dt>
	<dd>
この `number^t 成分は、
`flex-grow$p <a href="#flex-components">~longhand</a>を設定して，
`~flex伸長~係数@
を指定する。
それは、~flex容器の中で正の自由空間が配分される際に，
`~flex駒$が他の一連の`~flex駒$に比して どれだけ伸長することになるのかを決定する。
省略されたときは、 `1^v に設定される。
◎
This &lt;number&gt; component sets flex-grow longhand and specifies the flex grow factor, which determines how much the flex item will grow relative to the rest of the flex items in the flex container when positive free space is distributed. When omitted, it is set to 1.
</dd>

	<dt class="value production" id="valdef-flex-shrink">&lt;‘`flex-shrink$p’&gt;</dt>
	<dd>
この `number^t 成分は、
`flex-shrink$p <a href="#flex-components">~longhand</a>を設定して，
`~flex縮短~係数@
を指定する。
それは、~flex容器の中で負の自由空間が配分される際に，
`~flex駒$が他の一連の`~flex駒$に比して どれだけ縮短することになるのかを決定する。
省略されたときは、 `1^v に設定される。
負の自由空間を配分する際には、`~flex縮短~係数$は，`~flex基底$との積がとられる。
◎
This &lt;number&gt; component sets flex-shrink longhand and specifies the flex shrink factor, which determines how much the flex item will shrink relative to the rest of the flex items in the flex container when negative free space is distributed. When omitted, it is set to 1.
</dd>
	<dd class="note">注記：
負の空間を配分する際には、`~flex縮短~係数$は，`~flex~base~size$との積がとられることに注意。
これにより、負の空間は，駒が縮短できる量に比例するように配分され、例えば，大きい駒が~~相当に縮短されない限り，小さい駒が~zeroまで縮短されないようにする。
◎
Note: The flex shrink factor is multiplied by the flex base size when distributing negative space. This distributes negative space in proportion to how much the item is able to shrink, so that e.g. a small item won’t shrink to zero before a larger item has been noticeably reduced.
</dd>

	<dt class="value production" id="valdef-flex-basis">&lt;‘`flex-basis$p’&gt;</dt>
	<dd>
この成分は、
`flex-basis$p <a href="#flex-components">~longhand</a>を設定して，
`~flex基底@
を指定する。
それは、一連の~flex係数に則って自由空間が配分される前の，`~flex駒$の初期`主size$を与える。
◎
This component sets the flex-basis longhand, which specifies the flex basis: the initial main size of the flex item, before free space is distributed according to the flex factors.
</dd>
	<dd>
<p>
この成分は、 `width$p, `height$p ~propと同じ値を受容する（ただし， `auto$v:fb の扱いは異なる）のに加えて，追加の~keyword `content$v:fb も受容する：
◎
&lt;‘flex-basis’&gt; accepts the same values as the width and height properties (except that auto is treated differently) plus the content keyword:
</p>

		<dl>
			<dt>`auto@v:fb</dt>
			<dd>
~flex駒にこの~keywordが指定された場合、
`flex-basis$p の使用値は，`主size~prop$の値から~~取得される。
その値も `auto$v:min である場合の使用値は， `content$v:fb になる。
◎
When specified on a flex item, the auto keyword retrieves the value of the main size property as the used flex-basis. If that value is itself auto, then the used value is content.
</dd>

			<dt>`content@v:fb</dt>
			<dd>
<p>
これは、~flex駒の内容に基づく自動的~sizingを指示する。
◎
Indicates automatic sizing, based on the flex item’s content.
</p>

<p class="note">注記：
この値はこの仕様の初期リリースには無かったものであり、一部の古い実装では~supportされない。
等価な効果は、`主size~prop$ に `auto^v をあてがった上で， `auto^v を用いることにより得られる。
◎
Note: This value was not present in the initial release of Flexible Box Layout, and thus some older implementations will not support it. The equivalent effect can be achieved by using auto together with a main size (width or height) of auto.
</p>
			</dd>

			<dt><var class="production">&lt;‘`width$p’&gt;</var></dt>
			<dd>
他のすべての値に対しては、 `width$p, `height$p に対するときと同じ方法で解決される。
◎
For all other values, flex-basis is resolved the same way as for width and height.
</dd>
		</dl>
	</dd>
	<dd id="cg-flex-basis-zero-1">
`flex$p 簡略形から省略された場合の指定値は、 `0^v になる。
◎
When omitted from the flex shorthand, its specified value is 0.
</dd>

	<dt>`none@v:f</dt>
	<dd>
~keyword `none$v:f は，`0 0 auto^v に展開される。
◎
The keyword none expands to 0 0 auto.
</dd>

</dl>

<hr />

<figure>

	<figure><figcaption>
すべての空間が配分される（ `flex-basis$p:0 ）：
◎
All Space Distributed (flex-basis:0)
</figcaption>
`rel-vs-abs-flex-a^dgm
</figure>

	<figure><figcaption>
余った空間が配分される（ `flex-basis$p:auto ）：
◎
Extra Space Distributed (flex-basis:auto)
</figcaption>
`rel-vs-abs-flex-b^dgm
</figure>

<figcaption><p><b>図 6.</b>
（基底~zeroによる） “絶対的” ~flexと,
（ 駒の内容~sizeから得られる基底による） “相対的” ~flex
との間の相違を示す図式。
3 個の駒の~flex係数は、順に `1^v, `1^v, `2^v にされているとする。
~flex係数 `2^v を伴う駒が他の二倍 伸長することに注目。
【前者の“絶対的” ~flexでは、各~駒が，いったん幅 0 の~~状態にされるので，可用な幅~全部が自由空間にあてがわれた上で、それが~flex係数に応じた比率で各~駒に配分される。】
<!-- （内容~sizeが配分された幅を超える駒については、内容がはみ出すことになる） -->
◎
A diagram showing the difference between "absolute" flex (starting from a basis of zero) and "relative" flex (starting from a basis of the item’s content size). The three items have flex factors of 1, 1, and 2, respectively: notice that the item with a flex factor of 2 grows twice as fast as the others.
</p></figcaption>

</figure>



<p>
`flex$p の個々の成分の初期値による値は、
<a href="#flex-initial">`flex$p:0_1_auto</a>
に等価になる。
◎
The initial values of the flex components are equivalent to flex: 0 1 auto.
</p>

<p class="note">注記：
`flex$p ~shorthandから省略されたときの，
`flex-grow$p, `flex-basis$p
の初期値は、いずれも，それらの個別の~longhandの既定~値とは異なる。
これは、<a href="#flex-common">最もよくある事例</a>に，`flex$p ~shorthandがより良く適応できるようにするために、そのようにされている。
◎
Note: The initial values of flex-grow and flex-basis are different from their defaults when omitted in the flex shorthand. This is so that the flex shorthand can better accommodate the most common cases.
</p>

<p>
［
2 個の~flex係数
］が前置されていない，単位の無い~zeroは、~flex係数として解釈され~MUST。
誤解釈や無効な宣言を避けるため、作者は，単位を伴う~zero
<span class="value production">&lt;‘`flex-basis$p’&gt;</span>
成分を指定するか, あるいは
その前に 2 個の~flex係数を置か~MUST。
◎
A unitless zero that is not already preceded by two flex factors must be interpreted as a flex factor. To avoid misinterpretation or invalid declarations, authors must specify a zero &lt;‘flex-basis’&gt; component with a unit or precede it by two flex factors.
</p>

			<section id="flex-common">
<h3 title="Basic Values of flex">7.1.1. 基本的な `flex^p 値</h3>

~INFORMATIVE

<p>
以下に、最も共通的に欲される効果を表現する，
4 つの `flex$p 値による効果を要約する：
◎
The list below summarizes the effects of the four flex values that respresent most commonly-desired effects:
</p>

<dl>
	<dt id="flex-initial">`flex$p:initial</dt>
	<dd>
`flex$p:0_1_auto に等価（これが初期値）。
駒を，その
`width$p ／ `height$p
~propに基づいて~sizeする。
（駒の`主size~prop$が `auto^v に算出される場合、これは，その駒をその内容に基づいて~sizeすることになる。）
正の自由空間があるときは，~flex駒を~flexibleでなくする一方で、空間が不足しているときは，その最小~sizeへの縮短を許容する。
<a href="#alignment">整列~能</a>や `~auto_v~margin$を利用すれば、一連の~flex駒を`主軸$沿いに整列させられる。
◎
Equivalent to flex: 0 1 auto. (This is the initial value.) Sizes the item based on the width/height properties. (If the item’s main size property computes to auto, this will size the flex item based on its contents.) Makes the flex item inflexible when there is positive free space, but allows it to shrink to its minimum size when there is insufficient space. The alignment abilities or auto margins can be used to align flex items along the main axis.
</dd>

	<dt>`flex$p:auto</dt>
	<dd>
`flex$p:1_1_auto に等価。
駒を，その
`width$p ／ `height$p
~propに基づいて駒を~sizeしつつ、`主軸$沿いの自由空間を吸収させるために，それらを全部的に~flexibleにする。
どの駒も， `flex$p が［
`auto^v, `initial^v, `none^v
］のいずれかである場合、それらの駒が~sizeされた後の正の自由空間は，
`flex$p:auto
を伴う駒に均等に配分されることになる。
◎
Equivalent to flex: 1 1 auto. Sizes the item based on the width/height properties, but makes them fully flexible, so that they absorb any free space along the main axis. If all items are either flex: auto, flex: initial, or flex: none, any positive free space after the items have been sized will be distributed evenly to the items with flex: auto.
</dd>

	<dt>`flex$p:none</dt>
	<dd>
`flex$p:0_0_auto に等価。
この値は、
`width$p ／ `height$p
~propに則って駒を~sizeしつつ，~flex駒を`全部的に非~flexible$にする。
これは、~overflowが生じる状況~下でも 一連の~flex駒に対する縮短が許容されないことを除いて，
`initial$v と同様になる。
◎
Equivalent to flex: 0 0 auto. This value sizes the item according to the width/height properties, but makes the flex item fully inflexible. This is similar to initial, except that flex items are not allowed to shrink, even in overflow situations.
</dd>

	<dt><span class="css">`flex$p: `positive-number^t</span></dt>
	<dd>
<span class="css" title="flex" id="cg-flex-basis-zero-2">flex: `positive-number^t `1 0^v</span>
に等価。
~flex駒を~flexibleにして，`~flex基底$を~zeroに設定する。
その結果、駒は，指定された比例分による［
~flex容器の中の自由空間
］を受取る。
~flex容器の中のすべての駒が この~patternを利用している下での，それらの~sizeは、~flex係数に指定された値に比例するようになる。
◎
Equivalent to flex: &lt;positive-number&gt; 1 0. Makes the flex item flexible and sets the flex basis to zero, resulting in an item that receives the specified proportion of the free space in the flex container. If all items in the flex container use this pattern, their sizes will be proportional to the specified flex factor.
</dd>

</dl>

<p>
既定では、~flex駒がその内容の最小~size（単語や固定~sizeの要素の最大の長さ）を下回るまで縮短することはない。
この挙動を変えるには、
`min-width$p や `min-height$p
~propを設定する（
<a href="#min-size-auto">~flex駒に対する暗黙の最小~size</a>
節を見よ）。
◎
By default, flex items won’t shrink below their minimum content size (the length of the longest word or fixed-size element). To change this, set the min-width or min-height property. (See §4.5 Implied Minimum Size of Flex Items.)
</p>



			</section>
		</section>
		<section id="flex-components">
<h3 title="Components of Flexibility">7.2. ~flex性の各~成分</h3>

<p>
~flex性の個々の成分は，~longhandにより独立に制御できる。
◎
Individual components of flexibility can be controlled by independent longhand properties.
</p>

<p class="advisement">
作者には、 `flex$p ~shorthandを用いて ~flex性を制御することを勧める
— その各種~longhand~propを直接的に用いるのでなく。
この~shorthandは、<a href="#flex-common">一般用途</a>に適応するように，未指定の成分を正しく再設定するので。
◎
Authors are encouraged to control flexibility using the flex shorthand rather than with its longhand properties directly, as the shorthand correctly resets any unspecified components to accommodate common uses.
</p>

			<section id="flex-grow-property">
<h4 title="The flex-grow property">7.2.1 `flex-grow^p ~prop</h4>

`●名^ `flex-grow@p
`●値^ `number$t
`●初^ `0^v
`●適^ `~flex駒$
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値
`●ア^ 可
`●表終^

<p class="advisement">
作者には、
`flex-grow$p を直接的に用いずに，
`flex$p ~shorthandを用いて ~flex性を制御することを勧める。
この~shorthandは、<a href="#flex-common">一般用途</a>に適応するように，未指定の成分を正しく再設定するので。
◎
Authors are encouraged to control flexibility using the flex shorthand rather than with flex-grow directly, as the shorthand correctly resets any unspecified components to accommodate common uses.
</p>

<dl>
	<dt id="valdef-flex-grow-number">`number$t</dt>
	<dd>
`flex-grow$p ~propは、`~flex伸長~係数$を 供された `number^t に設定する。
負~数は無効である。
◎
The flex-grow property sets the flex grow factor to the provided &lt;number&gt;. Negative numbers are invalid.
</dd>

</dl>


			</section>
			<section id="flex-shrink-property">
<h4 title="The flex-shrink property">7.2.2 `flex-shrink^p ~prop</h4>

`●名^ `flex-shrink@p
`●値^ `number$t
`●初^ `1^v
`●適^ `~flex駒$
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値
`●ア^ 可
`●表終^

<p class="advisement">
作者には、
`flex-shrink$p を直接的に用いずに，
`flex$p ~shorthandを用いて ~flex性を制御することを勧める。
この~shorthandは、<a href="#flex-common">一般用途</a>に適応するように，未指定の成分を正しく再設定するので。
◎
Authors are encouraged to control flexibility using the flex shorthand rather than with flex-shrink directly, as the shorthand correctly resets any unspecified components to accommodate common uses.
</p>


<dl>
	<dt id="valdef-flex-shrink-number">`number$t</dt>
	<dd>
`flex-shrink$p ~propは、`~flex縮短~係数$を 供された `number^t に設定する。
負~数は無効である。
◎
The flex-shrink property sets the flex shrink factor to the provided &lt;number&gt;. Negative numbers are invalid.
</dd>

</dl>

			</section>
			<section id="flex-basis-property">
<h4 title="The flex-basis property">7.2.3 `flex-basis^p ~prop</h4>

`●名^ `flex-basis@p
`●値^
`content$v:fb |
<var class="production">&lt;‘`width$p’&gt;</var>
`●初^ `auto$v:fb
`●適^ `~flex駒$
`●継^ されない
`●百^
`~flex容器$の<a href="#_def-inner-outer" >内縁</a> `主size$に相対的
◎
relative to the flex container’s inner main size
`●媒^ 視覚的
`●算^ 
指定値 — ただし，長さは絶対化される。
◎
as specified, with lengths made absolute
`●ア^ `width$p と同様
◎
as width
`●表終^

<p class="advisement">
作者には、
`flex-basis$p を直接的に用いずに，
`flex$p ~shorthandを用いて ~flex性を制御することを勧める。
この~shorthandは、<a href="#flex-common">一般用途</a>に適応するように，未指定の成分を正しく再設定するので。
◎
Authors are encouraged to control flexibility using the flex shorthand rather than with flex-basis directly, as the shorthand correctly resets any unspecified components to accommodate common uses.
</p>

<p>
`flex-basis$p ~propは、`~flex基底$を設定する。
それは `width$p ／ `height$p ~propと同じ範囲の値に加えて，値
`content$v:fb も受容する。
◎
The flex-basis property sets the flex basis. It accepts the same values as the width and height property, plus content.
</p>

<p id="cg-2016-auto-content-wording">
上に定義された
`auto$v:fb, `content$v:fb
以外のすべての値に対しては、横書き書字modeの下では，
`flex-basis$p は `width$p と同じ方法で解決される `CSS21$r 。
ただし、値が `width$p に対する `auto^v に解決される場合は，代わりに
`flex-basis$p に対する `content$v:fb に解決される。
例えば、
`flex-basis$p に対する百分率~値は，~flex駒の包含塊（すなわち，その~flex容器）に対し解決され、包含塊の~sizeが`不定$である場合の `flex-basis$p の使用値は， `content$v:fb になる。
別の~~帰結として、
`box-sizing$p `CSS3UI$r など 他から指定されない限り，
`flex-basis$p は内容~boxの~sizeを決定する。
◎
For all values other than auto and content (defined above), flex-basis is resolved the same way as width in horizontal writing modes [CSS21], except that if a value would resolve to auto for width, it instead resolves to content for flex-basis. For example, percentage values of flex-basis are resolved against the flex item’s containing block (i.e. its flex container); and if that containing block’s size is indefinite, the used value for flex-basis is content. As another corollary, flex-basis determines the size of the content box, unless otherwise specified such as by box-sizing [CSS3UI].
</p>

			</section>
		</section>
	</section>

	<section id="alignment">
<h2 title="Alignment">8. 整列</h2>

<p>
~flex容器の内容がそれらの~flex処理を終えて，すべての~flex駒について
両~次元とも【~flex~sizeを】決着させたなら、それらは，~flex容器~内で整列し得るようになる。
◎
After a flex container’s contents have finished their flexing and the dimensions of all flex items are finalized, they can then be aligned within the flex container.
</p>

<p>
`margin$p ~propを，塊~layoutの下で~marginが行えるものに類似しつつ, より強力な方式で駒を整列させるために利用できる。
`~flex駒$はまた、
<a href="~TR/css3-align/" >Box Alignment 仕様</a>
の整列~propも~~尊守する
— これにより，`主軸$, `交叉軸$ いずれについても、~keywordに基づく駒の整列は容易に可能になる。
これらの~propは、 CSS 2.1 の下では非常に困難であった，縦横 両~方向の中央~寄せなども含む，共通的にある型の整列を自明なものにする。
◎
The margin properties can be used to align items in a manner similar to, but more powerful than, what margins can do in block layout. Flex items also respect the alignment properties from CSS Box Alignment, which allow easy keyword-based alignment of items in both the main axis and cross axis. These properties make many common types of alignment trivial, including some things that were very difficult in CSS 2.1, like horizontal and vertical centering.
</p>

<p class="note">注記：
この節に述べる各種~整列~propは， Box Alignment 仕様 `CSS-ALIGN-3$r にて定義されているが、仕様の策定を遅らせないため，この仕様では、正式な依存関係は作成せずに，関連する部分の定義を ここに再現する。
これらの~propは、 Box Alignment Level 3 が策定を終え, 他の~layout~modeに対する効果を定義するまでは、~flex~layoutにのみ適用される。
加えて、Box Alignment ~moduleに定義される新たな値は，~flex~layoutにも適用される
— 言い換えれば、 Box Alignment ~moduleが完了した時点で，ここでの定義に取って代わることになる。
◎
Note: While the alignment properties are defined in CSS Box Alignment [CSS-ALIGN-3], Flexible Box Layout reproduces the definitions of the relevant ones here so as to not create a normative dependency that may slow down advancement of the spec. These properties apply only to flex layout until CSS Box Alignment Level 3 is finished and defines their effect for other layout modes. Additionally, any new values defined in the Box Alignment module will apply to Flexible Box Layout; in otherwords, the Box Alignment module, once completed, will supercede the definitions here.
</p>

		<section id="auto-margins">
<h3 title="Aligning with auto margins">8.1. `auto^v ~marginによる整列法</h3>

<p>
<em>この節は参考である。</em>
~marginが~flex駒にどのように影響するかについての正式な定義は、
`~flex~layout~algo$
節にて与えられる。
◎
This section is non-normative. The normative definition of how margins affect flex items is in the Flex Layout Algorithm section.
</p>

<p>
~flex駒~上の~auto~marginの効果は、塊~flowの下での~auto~marginととてもよく似る：
◎
Auto margins on flex items have an effect very similar to auto margins in block flow:
</p>

<ul>
		<li>
~flex基底, ~flexible長さの計算を行う間は，
~auto~marginは `0^v に扱われる。
◎
During calculations of flex bases and flexible lengths, auto margins are treated as 0.
</li>

	<li>
`justify-content$p, `align-self$p
による整列に先立って，
正の自由空間は、その次元に属する~auto~marginに配分される。
◎
Prior to alignment via justify-content and align-self, any positive free space is distributed to auto margins in that dimension.
</li>

	<li>
~overflowする一連の~boxは、それらの`終端$方向の ~auto~margin, ~overflow を無視する。
◎
Overflowing boxes ignore their auto margins and overflow in the end direction.
</li></ul>

<p class="note">注記：
自由空間が~auto~marginに配分される場合、各種 整列~propは，その次元においては効果を持たなくなる。
~marginは，~flex処理の後に残された すべての自由空間を奪うことになるので。
◎
Note: If free space is distributed to auto margins, the alignment properties will have no effect in that dimension because the margins will have stolen all the free space left over after flexing.
</p>

<div class="example">
<p>
`auto^v ~marginの用途の一つに、一連の~flex駒を，主軸の中で 別々の “一連の~group” に分けることが挙げられる。
これを用いて、共通的な UI ~pattern
—
左端に整列されるものと, 右端に整列されるものに分けられた，いくつかの~actionからなる単独の~bar
—
を再現する例を次に示す：
◎
One use of auto margins in the main axis is to separate flex items into distinct "groups". The following example shows how to use this to reproduce a common UI pattern - a single bar of actions with some aligned on the left and others aligned on the right.
</p>

<figure>

<figcaption><p><b>図 7.</b>
下の~codeの描画~見本：
◎
Sample rendering of the code below.
</p></figcaption>
`auto-bar^dgm
</figure>

<pre class="lang-css">
nav &gt; ul {
  `display$p:flex;
}
nav &gt; ul &gt; #login {
  `margin-left$p:auto;
}
</pre>

<pre class="markup">
&lt;nav&gt;
  &lt;ul&gt;
&lt;li&gt;&lt;a href=/about&gt;About&lt;/a&gt;
&lt;li&gt;&lt;a href=/projects&gt;Projects&lt;/a&gt;
&lt;li&gt;&lt;a href=/interact&gt;Interact&lt;/a&gt;
&lt;li id="login"&gt;&lt;a href=/login&gt;Login&lt;/a&gt;
  &lt;/ul&gt;
&lt;/nav&gt;</pre>
	</div>

	<div class="example">
<p>
~overflowが生じる状況~下で、`~auto_v~margin$を用いた場合と,
<a href="#propdef-align-items">整列~prop</a>
を用いた場合との間の，交叉軸~沿いの整列の相違を下の図に示す：
◎
The figure below illustrates the difference in cross-axis alignment in overflow situations between using auto margins and using the alignment properties.
</p>

<figure>`cross-auto-figure^dgm
<figcaption><p><b>図 8.</b>
図左の一連の駒は，~marginにより中央~寄せにされる一方、図右のものは `align-self$p により中央~寄せにされている。
この~col~flex容器が頁の左~辺に配置される場合、図左の，~~長い駒も全部的に読み取れる~marginによる挙動の方が，望ましいものになるであろう。
他の状況下では，図右の “真の意味の” 中央~寄せの挙動の方が好ましいものになり得る。
◎
The items in the figure on the left are centered with margins, while those in the figure on the right are centered with align-self. If this column flex container was placed against the left edge of the page, the margin behavior would be more desirable, as the long item would be fully readable. In other circumstances, the true centering behavior might be better.
</p></figcaption>

</figure>
	</div>



		</section>
		<section id="justify-content-property">
<h3 title="Axis Alignment: the justify-content property">8.2. 主軸~沿いの整列： `justify-content^p ~prop</h3>
<!--
align.justify-content
 -->

`●名^ `justify-content@p
`●値^
`flex-start$v:j |
`flex-end$v:j |
`center$v:j |
`space-between$v:j |
`space-around$v:j
`●初^ `flex-start$v:j
`●適^ `~flex容器$
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値
`●ア^ 不可
`●表終^

<p>
`justify-content$p ~propは、~flex容器の現在の~lineの`主軸$沿いに，`~flex駒$を整列する。
これは、~flexible長さおよび`~auto_v~margin$が解決された<em>後に</em>行われる。
これは概して、~line上の`~flex駒$すべてについて，それぞれが［
~flexibleでない, または
~flexibleであるが その最大~sizeに到達している
］ときの，残されて余った 自由空間の配分を補助する。
それはまた、~lineを~overflowする駒の整列について、ある程度の制御を供する。
◎
The justify-content property aligns flex items along the main axis of the current line of the flex container. This is done after any flexible lengths and any auto margins have been resolved. Typically it helps distribute extra free space leftover when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line.
</p>

<dl>
	<dt>`flex-start@v:j</dt>
	<dd>
`~flex駒$は~lineの始端に向けて収納される：
~line上の最初の`~flex駒$の`主始端$ ~margin辺は，~lineの`主始端$辺に接合され、後続の各`~flex駒$は，先行の駒に接合される。
◎
Flex items are packed toward the start of the line. The main-start margin edge of the first flex item on the line is placed flush with the main-start edge of the line, and each subsequent flex item is placed flush with the preceding item.
</dd>

	<dt>`flex-end@v:j</dt>
	<dd>
`~flex駒$は~lineの終端に向けて収納される：
~line上の最後の`~flex駒$の`主始端$ ~margin辺は，~lineの`主終端$辺に接合され、先行の各`~flex駒$は，後続の駒に接合される。
◎
Flex items are packed toward the end of the line. The main-end margin edge of the last flex item is placed flush with the main-end edge of the line, and each preceding flex item is placed flush with the subsequent item.
</dd>

	<dt>`center@v:j</dt>
	<dd>
`~flex駒$は~lineの中央に向けて収納される：
~line上の一連の`~flex駒$は、互いに接合された上で、［
~lineの`主始端$辺と~line上の最初の駒との間
］, および［
~lineの`主終端$辺と~line上の最後の駒との間
］の空間が等量になるように，~lineの中央に向けて整列される。
（残された自由空間が負の場合、`~flex駒$は両~方向に等しく~overflowすることになる。）
◎
Flex items are packed toward the center of the line. The flex items on the line are placed flush with each other and aligned in the center of the line, with equal amounts of space between the main-start edge of the line and the first item on the line and between the main-end edge of the line and the last item on the line. (If the leftover free-space is negative, the flex items will overflow equally in both directions.)
</dd>

	<dt>`space-between@v:j</dt>
	<dd>
`~flex駒$は~line内に均等に分布される：
残された自由空間が負の場合，あるいは
~line上に在る`~flex駒$ が 1 個だけの場合、この値の効果は `flex-start$v:j と一致する。
他の場合、~line上の［
最初／最後
］の`~flex駒$の［
`主始端$／`主終端$
］~margin辺が，~lineの［
`主始端$／`主終端$
］辺に接合され、~line上の残りの`~flex駒$については，隣接する２つの駒の間隔がすべて一致するように，自由空間が配分される。
◎
Flex items are evenly distributed in the line. If the leftover free-space is negative or there is only a single flex item on the line, this value is identical to flex-start. Otherwise, the main-start margin edge of the first flex item on the line is placed flush with the main-start edge of the line, the main-end margin edge of the last flex item on the line is placed flush with the main-end edge of the line, and the remaining flex items on the line are distributed so that the spacing between any two adjacent items is the same.
</dd>

	<dt>`space-around@v:j</dt>
	<dd>
一連の`~flex駒$は、両端には半分~sizeの空間を伴う様に，~line内に均等に分布される：
残された自由空間が負であるか, または
~line上に在る`~flex駒$が 1 個だけの場合、この値の効果は `center$v:j と一致する。
他の場合、~line上の隣接するどの２つの`~flex駒$の間隔も同じ~sizeになり，その半分~sizeが［
~line上の［
最初／最後
］の `~flex駒$と［
`~flex容器$辺
］との間隔
］に一致するように、自由空間が配分される。
◎
Flex items are evenly distributed in the line, with half-size spaces on either end. If the leftover free-space is negative or there is only a single flex item on the line, this value is identical to center. Otherwise, the flex items on the line are distributed such that the spacing between any two adjacent flex items on the line is the same, and the spacing between the first/last flex items and the flex container edges is half the size of the spacing between flex items.
</dd>

</dl>


<figure>
`flex-pack^dgm
<figcaption><p><b>図 9.</b>
5 種の `justify-content$p ~keywordによる，~flex容器~上の効果を、 3 色に色分けされた駒で図示
◎
An illustration of the five justify-content keywords and their effects on a flex container with three colored items.
</p></figcaption>

</figure>




		</section>
		<section id="align-items-property">
<h3 title="Cross-axis Alignment: the align-items and align-self properties">8.3. 交叉軸~沿いの整列： `align-items^p と `align-self^p ~prop</h3>

`●名^ `align-items@p
`●値^
`flex-start$v:ais |
`flex-end$v:ais |
`center$v:ais |
`baseline$v:ais |
`stretch$v:ais
`●初^ `stretch$v:ais
`●適^ `~flex容器$
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値
`●ア^ 不可
`●表終^


`●名^ `align-self@p
`●値^
`auto$v:as |
`flex-start$v:ais |
`flex-end$v:ais |
`center$v:ais |
`baseline$v:ais |
`stretch$v:ais
`●初^ `auto$v:as
`●適^ `~flex駒$
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 
`auto$v:as は 親の `align-items$p 値に算出される。
他の値については，指定値。
◎
auto computes to parent’s align-items value; otherwise as specified
`●ア^ 不可
`●表終^




<p>
~flex容器の~lineの中の一連の`~flex駒$は、方向が垂直にされることを除いて `justify-content$p と同様に，~lineの`交叉軸$~~方向に整列させることができる。
`align-items$p は、匿名`~flex駒$も含め，~flex容器の`~flex駒$すべてに対する既定の整列を設定する。
`align-self$p は、この既定の整列を，個々の`~flex駒$について上書きできるようにする。
（匿名~flex駒に対する `align-self$p は、それらに結び付けられている~flex容器~上の `align-items$p の値に常に合致する。）
◎
Flex items can be aligned in the cross axis of the current line of the flex container, similar to justify-content but in the perpendicular direction. align-items sets the default alignment for all of the flex container’s items, including anonymous flex items. align-self allows this default alignment to be overridden for individual flex items. (For anonymous flex items, align-self always matches the value of align-items on their associated flex container.)
</p>

<p>
`~flex駒$の交叉軸~marginがいずれも `auto^v である場合、
`align-self$p は効果を持たない。
◎
If either of the flex item’s cross-axis margins are auto, align-self has no effect.
</p>

<div>
<p>
`align-self$p に対する値
`auto@v:as
は、次に与える値に算出される：
</p>

<ul>
	<li id="cg-align-self-auto">
`絶対位置の$要素に対しては：
そのままの値。
<span class="trans-note">【
この場合の `auto^v 値の効果は、 `CSS-ALIGN-3$r による
<a href="~CSSALIGN#align-self-property">`align-self^p の定義</a>
にて述べられている（この仕様には述べられていない）。
】</span>

</li>
	<li>
他の場合，要素が親を持つならば：
その親~上の `align-items$p の値。
</li>
	<li>
他の場合：
`stretch$v:ais
</li>
</ul>

<p>
各種~整列は、次の様に定義される：
</p>
◎
On absolutely positioned elements, a value of auto computes to itself. On all other elements, a value of auto for align-self computes to the value of align-items on the element’s parent, or stretch if the element has no parent. The alignments are defined as:
</div>


<dl>
	<dt>`flex-start@v:ais</dt>
	<dd>
`~flex駒$の`交叉始端$ ~margin辺は，~lineの`交叉始端$辺に接合される。
◎
The cross-start margin edge of the flex item is placed flush with the cross-start edge of the line.
</dd>

	<dt>`flex-end@v:ais</dt>
	<dd>
`~flex駒$の`交叉終端$ ~margin辺は，~lineの`交叉終端$辺に接合される。
◎
The cross-end margin edge of the flex item is placed flush with the cross-end edge of the line.
</dd>

	<dt>`center@v:ais</dt>
	<dd>
`~flex駒$の~margin~boxは，~line内の`交叉軸$の中で中央~寄せにされる。
（
~flex~lineの`交叉size$が`~flex駒$のそれより小さい場合、
それは両~方向に等しく~overflowすることになる。
）
◎
The flex item’s margin box is centered in the cross axis within the line. (If the cross size of the flex line is less than that of the flex item, it will overflow equally in both directions.)
</dd>

	<dt>`baseline@v:ais</dt>
	<dd>
`~flex駒$の行内軸が`交叉軸$と同じである場合、この値の効果は `flex-start$v:ais と一致する。
◎
If the flex item’s inline axis is the same as the cross axis, this value is identical to flex-start.
</dd>
	<dd>
他の場合，それは
`基底線~整列に関与-@
する — 
すなわち、~line上の，関与しているすべての`~flex駒$は、それらの基底線が互いに整列するように, かつ それらのうち［［［
自身の［
基底線と［
`交叉始端$ ~margin辺
］］の間の距離
］が最大になる駒
］が，~lineの`交叉始端$ 辺に接合される
］ように，整列される。
◎
Otherwise, it participates in baseline alignment: all participating flex items on the line are aligned such that their baselines align, and the item with the largest distance between its baseline and its cross-start margin edge is placed flush against the cross-start edge of the line.
</dd>

	<dt>`stretch@v:ais</dt>
	<dd>
`交叉size~prop$の算出値が `auto^v であり,
かつ 交叉軸~marginの両~側とも `auto^v でない場合、
`~flex駒$<!-- も含めて＊ -->は
`伸張@
される。
その場合の使用値は，［
`min-height$p ／
`min-width$p ／
`max-height$p ／
`max-width$p
］により課される拘束の下で，［
その駒の~margin~boxの`交叉size$が，その~lineと同じ~sizeに可能な限り近くされる
］ような長さになる。
◎
If the cross size property of the flex item computes to auto, and neither of the cross-axis margins are auto, the flex item is stretched. Its used value is the length necessary to make the cross size of the item’s margin box as close to the same size as the line as possible, while still respecting the constraints imposed by min-height/min-width/max-height/max-width.
</dd>
	<dd class="note">注記：
~flex容器の縦幅が拘束されている場合、この値により，`~flex駒$の内容が駒を~overflowさせ得る。
◎
Note: If the flex container’s height is constrained this value may cause the contents of the flex item to overflow the item.
</dd>
	<dd>
`~flex駒$の`交叉始端$~margin辺は，その~lineの`交叉始端$辺に接合される。
◎
The cross-start margin edge of the flex item is placed flush with the cross-start edge of the line.
</dd>

</dl>



<figure>`flex-align^dgm
<figcaption><p>
~flex容器~上における， 5 種の `align-items$p ~keywordによる効果を、 4 色に色分けされた駒で図示。
◎
An illustration of the five align-items keywords and their effects on a flex container with four colored items.
</p></figcaption></figure>



		</section>
		<section id="align-content-property">
<h3 title="Packing Flex Lines: the align-content property">8.4. 一連の~flex~lineの収納法： `align-content^p ~prop</h3>

`●名^ `align-content@p
`●値^
`flex-start$v:ac |
`flex-end$v:ac |
`center$v:ac |
`space-between$v:ac |
`space-around$v:ac |
`stretch$v:ac
`●初^ `stretch$v:ac
`●適^ `複line$ `~flex容器$
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値
`●ア^ 不可
`●表終^

<p>
`align-content$p ~propは、`交叉軸$に余った空間があるときに，~flex容器の一連の~lineを~flex容器の中で整列する
—
`justify-content$p が個々の駒を`主軸$の中で整列するときと同様に。
この~propは，`単line$ ~flex容器には効果を持たないことに注意。
各種~値の意味は，次で与えられる：
◎
The align-content property aligns a flex container’s lines within the flex container when there is extra space in the cross-axis, similar to how justify-content aligns individual items within the main-axis. Note, this property has no effect on a single-line flex container. Values have the following meanings:
</p>

<dl>
	<dt>`flex-start@v:ac</dt>
	<dd>
一連の~lineは，~flex容器の始端に向けて収納される：
~flex容器の中の最初の~lineの`交叉始端$辺は，~flex容器の`交叉始端$辺に接合され、後続の各~lineは，先行の~lineに接合される。
◎
Lines are packed toward the start of the flex container. The cross-start edge of the first line in the flex container is placed flush with the cross-start edge of the flex container, and each subsequent line is placed flush with the preceding line.
</dd>

	<dt>`flex-end@v:ac</dt>
	<dd>
一連の~lineは，~flex容器の終端に向けて収納される：
~flex容器の中の最後の~lineの`交叉終端$辺は，~flex容器の`交叉終端$辺に接合され、後続の各~lineは，先行の~lineに接合される。
◎
Lines are packed toward the end of the flex container. The cross-end edge of the last line is placed flush with the cross-end edge of the flex container, and each preceding line is placed flush with the subsequent line.
</dd>

	<dt>`center@v:ac</dt>
	<dd>
一連の~lineは，~flex容器の中央に向けて収納される：
~flex容器の中の一連の~lineは、互いに接合された上で，~flex容器の中央に整列される
—［
~flex容器の`交叉始端$内容~辺と ~flex容器の最初の~lineの合間,
］, および［
~flex容器の`交叉終端$内容~辺と ~flex容器の最後の~lineの合間
］の空間が等量になるように（残された自由空間が負の場合，一連の~lineは両~方向に等しく~overflowすることになる）。
◎
Lines are packed toward the center of the flex container. The lines in the flex container are placed flush with each other and aligned in the center of the flex container, with equal amounts of space between the cross-start content edge of the flex container and the first line in the flex container, and between the cross-end content edge of the flex container and the last line in the flex container. (If the leftover free-space is negative, the lines will overflow equally in both directions.)
</dd>

	<dt>`space-between@v:ac</dt>
	<dd>
一連の~lineは、~flex容器の中で均等に分布される：
残された自由空間が負の場合、この値の効果は， `flex-start$v:ac と一致する。
他の場合、~flex容器の中の［
最初／最後
］の~lineの［
`交叉始端$／`交叉終端$
］辺が，~flex容器の［
`交叉始端$／`交叉終端$
］内容~辺に接合され，~flex容器の中の残りの~lineについては，隣接するどの 2 本の~lineの間隔も同じになるように、自由空間が配分される。
◎
Lines are evenly distributed in the flex container. If the leftover free-space is negative this value is identical to flex-start. Otherwise, the cross-start edge of the first line in the flex container is placed flush with the cross-start content edge of the flex container, the cross-end edge of the last line in the flex container is placed flush with the cross-end content edge of the flex container, and the remaining lines in the flex container are distributed so that the spacing between any two adjacent lines is the same.
</dd>

	<dt>`space-around@v:ac</dt>
	<dd>
一連の`~flex駒$は、両端には半分~sizeの空間を伴う様に，~flex容器の中で均等に分布される：
残された自由空間が負である場合、この値の効果は `center$v:ac と一致する。
他の場合、~flex容器の中の一連の~lineは［
隣接するどの 2 本の~lineの間隔も同じ~sizeになり，その半分~sizeが［［
最初／最後
］の~lineと［
`~flex容器$辺
］との間隔
］になるように、自由空間が配分される。
◎
Lines are evenly distributed in the flex container, with half-size spaces on either end. If the leftover free-space is negative this value is identical to center. Otherwise, the lines in the flex container are distributed such that the spacing between any two adjacent lines is the same, and the spacing between the first/last lines and the flex container edges is half the size of the spacing between flex lines.
</dd>

	<dt>`stretch@v:ac</dt>
	<dd>
一連の~lineは、残りの空間を占めるように伸張される：
残された自由空間が負の場合，この値の効果は `flex-start$v:ac に一致する。
他の場合、自由空間は，すべての~lineの合間が等しくになるように分割された上で
それらの交叉sizeを増大させる。
◎
Lines stretch to take up the remaining space. If the leftover free-space is negative, this value is identical to flex-start. Otherwise, the free-space is split equally between all of the lines, increasing their cross size.
</dd>

</dl>

<p class="note">注記：
`複line$~flex容器のみが、`交叉軸$~~方向に自由空間を持ち，一連の~lineは その中で整列されることになる。
`単line$~flex容器における唯一の~lineは，空間を埋めるために自動的に伸張されるので。
◎
Note: Only multi-line flex containers ever have free space in the cross-axis for lines to be aligned in, because in a single-line flex container the sole line automatically stretches to fill the space.
</p>

<figure>`align-content-example^dgm
<figcaption><p>
各種 `align-content$p ~keywordによる，`複line$ ~flex容器に対する効果の図示
◎
An illustration of the align-content keywords and their effects on a multi-line flex container.
</p></figcaption></figure>


		</section>
		<section id="flex-baselines">
<h3 title="Flex Baselines">8.5. ~flex容器の基底線</h3>


<p>
`~flex容器$自身を`基底線~整列に関与-$させるためには（例： `~flex容器$自身が，外縁の`~flex容器$にて`~flex駒$であるとき）、自身の内容を最も良く表現するような基底線の位置を~~提示させる必要がある。
この~~目的のため、（ `order$p による並替えの後に）以下の様にして，~flex容器（以下，単に %容器 と記す）の基底線が決定される：
◎
In order for a flex container to itself participate in baseline alignment (e.g. when the flex container is itself a flex item in an outer flex container), it needs to submit the position of the baselines that will best represent its contents. To this end, the baselines of a flex container are determined as follows (after reordering with order):
</p>


<dl class="def-list">
	<dt>`主軸 基底線~集合@</dt>
	<dd>
<p >
%容器 の最初最後の`主軸 基底線~集合$（以下，単に %S と記す）は、次にしたがって決定される：
◎
first/last main-axis baseline set
</p>
		<ol>
			<li>
%容器 内に`~flex駒$はないならば、最後の段へ。
◎
↓</li>
			<li>
<p>
%容器 内に次をいずれも満たすような`~flex駒$が在るならば：
</p>

<ul ><li>最初最後の`~flex~line$に配置される
</li><li>`基底線~整列に関与-$する
</li></ul>
<p>
%S は、そのような`~flex駒$たちが共有する`整列~基底線$から`生成される$。
</p>
◎
If any of the flex items on the flex container’s first/last flex line participate in baseline alignment, the flex container’s first/last main-axis baseline set is generated from the shared alignment baseline of those flex items.
</li>
			<li>
<p>
他の場合、 %容器 内の最初最後の`~flex駒$を %駒 とするとき：
◎
↓</p>
				<ol>
					<li>
%駒 の基底線は，~flex容器の`主軸$に平行であるならば、
%S は、その駒の`整列~基底線$から`生成される$。
◎
Otherwise, if the flex container has at least one flex item, and its first/last flex item has a baseline parallel to the flex container’s main axis, the flex container’s first/last main-axis baseline set is generated from its alignment baseline.
</li>
					<li>
他の場合、
%駒 の内容~boxから`基底線を合成-$できるならば、
%S は，その結果で与えられる。
◎
Otherwise, the flex container’s first/last main-axis baseline set is synthesized from the first/last item’s content box, or, failing that, from the flex container’s content box.
</li>
				</ol>
			</li>
			<li>
他の場合、
%S は， %容器 の内容~boxから`基底線を合成-$した結果で与えられる。
◎
↑</li>
		</ol>
	</dd>

	<dt>`交叉軸 基底線~集合@</dt>
	<dd>
<p>
%容器 の最初最後の`交叉軸 基底線~集合$（以下，単に %S と記す）は、次にしたがって決定される：
◎
first/last cross-axis baseline set
</p>

		<ol>
			<li>
%容器 内に`~flex駒$はないならば、最後の段へ
— 以下， %容器 内の最初最後の`~flex駒$を %駒 とする。
◎
↓</li>
			<li>
%駒 の`基底線~集合$は，~flex容器の`交叉軸$に平行であるならば、
%S は，その`基底線~集合$で与えられる。
◎
If the flex container has at least one flex item, and its first/last flex item has a first/last baseline set parallel to the flex container’s cross axis, the flex container’s first/last cross-axis baseline set is that baseline set.
</li>
			<li>
他の場合，
%駒 の内容~boxから`基底線を合成-$できるならば、
%S は，その結果で与えられる。
◎
Otherwise, the flex container’s cross-axis baseline set is synthesized from the first/last item’s content box, or, failing that, from the flex container’s content box.
</li>
			<li>
他の場合、
%S は， %容器 の内容~boxから`基底線を合成-$した結果で与えられる。
◎
↑</li>
		</ol>
	</dd>
</dl>


<p>
上述の規則に則って基底線を計算する際に，基底線を~~供与する~boxが ~scrollを許容する `overflow$p 値を持つ場合、その~boxは，その基底線の決定の目的においては，その初期~scroll位置にあるものと扱われ~MUST。
◎
When calculating the baseline according to the above rules, if the box contributing a baseline has an overflow value that allows scrolling, the box must be treated as being in its initial scroll position for the purpose of determining its baseline.
</p>

<p>
<a href="~CSS21/tables.html#height-layout">~table~cellの基底線の決定</a>
の際には、行boxや `table-row^v `CSS21$r のときとちょうど同じ様に，~flex容器が基底線を提供する。
◎
When determining the baseline of a table cell, a flex container provides a baseline just as a line box or table-row does. [CSS21]
</p>

<p>
基底線についての詳細は、
CSS Writing Modes 3 の
<a href="~CSSWM#intro-baselines">基底線 — 序論</a>,
および CSS Alingment Module の
<a href="~CSSALIGN#baseline-rules">基底線~整列の詳細</a>
各~節を見よ。
◎
See CSS Writing Modes 3 §4.1 Introduction to Baselines and [[css-align-3##baseline-rules]] for more information on baselines.

</p>
		</section>
	</section>
	<section id="layout-algorithm">
<h2 title="Flex Layout Algorithm">9. ~flex~layout~algo</h2>

<p>
この節には、~flex容器とその内容の正確な~layoutの挙動について詳細を述べる，正式な~algoが含められている。
~algoは，可読性と理論的簡潔さを最適化するように書かれているので、効率的とは限らない。
実装は，実際の~algoにどのようなものを用いてもよいが、ここに述べる~algoと同じ結果を~~生成し~MUST。
◎
This section contains normative algorithms detailing the exact layout behavior of a flex container and its contents. The algorithms here are written to optimize readability and theoretical simplicity, and may not necessarily be the most efficient. Implementations may use whatever actual algorithms they wish, but must produce the same results as the algorithms described here.
</p>

<p class="note">注記：
この節は、~~主に実装者~向けに意図されている。
~web頁~作者にとっては、一般に，個々の~propの記述にて十分になるべきであり、
 CSS ~layoutについての深い詳細を理解する強い~~動機がない限り，この節を読む必要はない。

◎
Note: This section is mainly intended for implementors. Authors writing web pages should generally be served well by the individual property descriptions, and do not need to read this section unless they have a deep-seated urge to understand arcane details of CSS layout.
</p>

<p>
以下の下位~節にて，~flex容器とその内容を~lay-outするための~algoを定義する。
◎
The following sections define the algorithm for laying out a flex container and its contents.
</p>

<p class="note">注記：
~flex~layoutは、論理~文書順ではなく `改変文書順$の下で，`~flex駒$たちに対し働く。
◎
Note: Flex layout works with the flex items in order-modified document order, not their original document order.
</p>



<div class="trans-note">
<p>【
以下の~algoの中の，
~IF, ~ELSE
等の記号の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照。
】
</p>

<p id="_def-inner-outer">【
以下に現れる語
“内縁” （ inner ）／ “外縁” （ outer ）
は、それぞれ， CSS の `~boxの寸法$ にて定義される
~boxの
内容~辺 ／ ~margin辺
を指す。
<!-- 
また、“使用〜” は
 -->
】</p>


<p>【
最小内容〜,
最大内容〜
等々の語（
<a href="~SIZING#terms">~~参照</a>
）, および
`min-content^v,
`max-content^v,
`fit-content^v
等々の値（
<a href="~SIZING#width-height-keywords">~~参照</a>
）は、 `CSS3-SIZING$r にて定義される（ 9.9 節の最初にもそのように記載）。
】</p>

</div>


		<section id="box-manip">
<h3 title="Initial Setup">9.1. 初期設定</h3>


<ol start="1">

<li id="algo-anon-box">
<a href="#flex-items">~flex駒</a>
節の記述に従って，
<strong>一連の匿名~flex駒を生成する</strong>。
◎
Generate anonymous flex items as described in §4 Flex Items.
</li>
</ol>

		</section>
		<section id="line-sizing">
<h3 title="Line Length Determination">9.2. ~line長さの決定</h3>

<ol class="continue">
	<li id="algo-available">
<div>

<p><strong>
［
主, 交叉
］沿いのそれぞれについて，一連の~flex駒に`可用な空間$を決定する
</strong>：</p>

<p>
それぞれの次元に対し、可用な空間は：
</p>

<p>
~IF［
その次元において，`~flex容器$の内容~boxの~sizeが`確定的$である
］
⇒
その~size。
</p>

<p id="cg-min-max-constraint">
~ELIF［
その次元において，`~flex容器$の内容~boxは［
`最小内容 拘束$または`最大内容 拘束$
］の下で~sizeされている
］
⇒
その拘束として与えられる。
</p>


<p>
~ELSE
⇒
その次元については、~flex容器に`可用な空間$から，`~flex容器$の［
~margin + ~border + ~padding
］の分を減算した結果の値。
</p>


<p class="note">注記：この値は無限にもなり得る。</p>

◎
Determine the available main and cross space for the flex items. For each dimension, if that dimension of the flex container’s content box is a definite size, use that; if that dimension of the flex container is being sized under a min or max-content constraint, the available space in that dimension is that constraint; otherwise, subtract the flex container’s margin, border, and padding from the space available to the flex container in that dimension and use that value. This might result in an infinite value.
</div>


<div class="example">
<p>
例えば，［
`auto^v で~sizeされていて,
`浮動-$している`~flex容器$
］の中の~flex駒に`可用な空間$は【横組の下では】：
◎
For example, the available space to a flex item in a floated auto-sized flex container is:
</p>

<ul>
	<li>
横~次元においては：
( `~flex容器$の包含塊の横幅 ) −
( `~flex容器$の横~次元の［
~margin + ~border + ~padding
］ )
◎
the width of the flex container’s containing block minus the flex container’s margin, border, and padding in the horizontal dimension
</li>

	<li>
縦~次元においては：無限
◎
infinite in the vertical dimension
</li>
</ul>

</div>

	</li>

	<li id="algo-main-item">
<p>
<strong>
各 `~flex駒$ %駒 に対する
`~flex~base~size@
と
`仮の主size@
を決定する
【いずれも主~次元の~size】
</strong>：
◎
Determine the flex base size and hypothetical main size of each item:
</p>

		<ol type="A">
			<li>
~IF［
%駒 の`~flex基底$の使用~sizeは`確定的$である
］
⇒
`~flex~base~size$は、その~sizeになる。
◎
If the item has a definite used flex basis, that’s the flex base size.
</li>

			<li>
<p>
~ELIF［
%駒 は次のいずれも満たす
］
◎
If the flex item has ...
</p>
				<ul>
					<li>
内在的~縦横比を有する
◎
an intrinsic aspect ratio,
</li>
					<li>
使用`~flex基底$は `content$v:fb
◎
a used flex basis of content, and
</li>

					<li>
`交叉size$は`確定的$である
◎
a definite cross size,
</li>
				</ul>

<p>
…ならば
⇒
`~flex~base~size$は、
%駒 の内縁 `交叉size$に %駒 の内在的~縦横比による積をとって主~次元に換算した結果になる
◎
then the flex base size is calculated from its inner cross size and the flex item’s intrinsic aspect ratio.
</p>
			</li>


			<li>
<p>
~ELIF
%駒 の`~flex基底$の使用値は［
`content$v:fb ~OR
%駒 に`可用な空間$に依存する
］：
</p>
				<ol>
					<li>
~IF［
~flex容器は［
`最小内容 拘束$または`最大内容 拘束$
］の下で~sizeされている（例えば
<a href="~CSS21/tables.html#auto-table-layout">自動的~table~layout</a>
`CSS21$r
を遂行するとき）
］
⇒
`~flex~base~size$は、 %駒 をその拘束の下で~sizeした結果の， %駒 の`主size$になる。
◎
If the used flex basis is content or depends on its available space, and the flex container is being sized under a min-content or max-content constraint (e.g. when performing automatic table layout [CSS21]), size the item under that constraint. The flex base size is the item’s resulting main size.
</li>

					<li>
<p>
~ELSE（すなわち， %駒 に可用な主sizeは無限であり, %駒 の行内軸は主軸に平行である）
⇒
%駒 を
<a href="~CSSWM#orthogonal-flows">直交~flowの下での~boxに対する規則</a>
`CSS3-WRITING-MODES$r
を用いて~lay-outする。
<br>
`~flex~base~size$は、 %駒 の最大内容 `主size$になる。
◎
Otherwise, if the used flex basis is content or depends on its available space, the available main size is infinite, and the flex item’s inline axis is parallel to the main axis, lay the item out using the rules for a box in an orthogonal flow [CSS3-WRITING-MODES]. The flex base size is the item’s max-content main size.
</p>

<p class="note">注記：
この事例は，例えば、横書き`書字mode$の英語~文書が包含している~col~flex容器が，縦書き日本語`~flex駒$を包含しているときに生じる。
◎
Note: This case occurs, for example, in an English document (horizontal writing mode) containing a column flex container containing a vertical Japanese (vertical writing mode) flex item.
</p>

					</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%駒 を，［
その`主size$に使用`~flex基底$を用い,
値 `content$v:fb は `max-content$v と見なした
］下で，`可用な空間$の中で~sizeする。
この計算において`主size$を決定する際に`交叉size$が必要であり（例えば %駒 の`主size$が %駒 の塊軸に沿うとき）, かつ［
%駒 の交叉sizeが `auto$v:min であって，`確定的$でない
］ならば、%駒 の`交叉size$として `fit-content$v を用いる。
<br>
`~flex~base~size$は、その結果の［
%駒 の`主size$
］になる。
◎
Otherwise, size the item into the available space using its used flex basis in place of its main size, treating a value of content as max-content. If a cross size is needed to determine the main size (e.g. when the flex item’s main size is in its block axis) and the flex item’s cross size is auto and not definite, in this calculation use fit-content as the flex item’s cross size. The flex base size is the item’s resulting main size.
</li>

		</ol>

<p>
`~flex~base~size$を決定するときは、
%駒 の［
~min, ~max
］`主size~prop$は無視される（切詰めは生じない）
◎
When determining the flex base size, the item’s min and max main size properties are ignored (no clamping occurs).
</p>

<p>
%駒 の`仮の主size$は，%駒 の`~flex~base~size$を
%駒 の［
~min, ~max
］`主size~prop$に則って切詰めた結果になる。
◎
The hypothetical main size is the item’s flex base size clamped according to its min and max main size properties.
</p>

	</li>

	<li id="algo-main-container">
<p><strong>
~flex容器の`主size$を、それが関与する整形~文脈の規則を利用して，決定する
</strong>：</p>

<p>
この算出過程の下では、~flex駒~上の `auto^v ~marginは `0^v に扱われる。
◎
Determine the main size of the flex container using the rules of the formatting context in which it participates. For this computation, auto margins on flex items are treated as 0.
</li>

</ol>



		</section>
		<section id="main-sizing">
<h3 title="Main Size Determination">9.3. 主sizeの決定</h3>

<ol class="continue">
	<li id="algo-line-break">
<p><strong>
一連の~flex~lineの中に，~flex駒を収集する
</strong>：
◎
Collect flex items into flex lines:
</p>

		<ul>
			<li>
~IF［
~flex容器は`単line$である
］
⇒
すべての~flex駒を単独の~flex~lineに収集する。
◎
If the flex container is single-line, collect all the flex items into a single flex line.
</li>

			<li>
<p>
~ELSE
⇒
まだ未収集の最初の駒から順に，連続する駒を，［
収集される <em>次の</em> 駒が，~flex容器の内縁 主sizeに収まらないような最初のものになる
］まで, または［
強制分断に遭遇する（
<a href="#pagination">~flex~layoutの断片化</a>
節を見よ）
］まで、順次 収集していく。
ただし，いきなり最初の未収集の駒が収まり切らないようであれば、単に，それのみを~~現在の~lineに収集する。
◎
Otherwise, starting from the first uncollected item, collect consecutive items one by one until the first time that the next collected item would not fit into the flex container’s inner main size, or until a forced break is encountered, see §10 Fragmenting Flex Layout). If the very first uncollected item wouldn’t fit, collect just it into the line.
</p>

<p>
この段においては、~flex駒の~sizeは，その外縁 `仮の主size$にされる。
◎
For this step, the size of a flex item is its outer hypothetical main size.
</p>

<p>
すべての~flex駒が，一連の~flex~lineに収集されるまで、上を繰り返す。
◎
Repeat until all flex items have been collected into flex lines.
</p>

<p class="note">注記：
“可能な限り収集する” ことにより、~size~zeroの~flex駒は，最後の非~zero~sizeの駒が~lineを正確に “埋めて” いたとしても，前の~lineの終端に収集されることになる。
◎
Note that the collect as many" line will collect zero-sized flex items onto the end of the previous line even if the last non-zero item exactly "filled up" the line.
</p>
			</li>
		</ul>
	</li>

	<li id="algo-flex">
<a href="#resolve-flexible-lengths">~flexible長さを解決-</a>して（ 9.7 節）、すべての~flex駒について，その使用`主size$を見出す。
◎
Resolve the flexible lengths of all the flex items to find their used main size. See §9.7 Resolving Flexible Lengths.
</li>

</ol>



		</section>
		<section id="cross-sizing">
<h3 title="Cross Size Determination">9.4. 交叉sizeの決定</h3>

<ol class="continue">
	<li id="algo-cross-item"><p>
`auto^v は `fit-content$v であると見なした下で，`可用な空間$において使用`主size$による~layoutを遂行することにより、
<strong>
各~駒に対し，
`仮の交叉size@
を決定する。
</strong>
◎
Determine the hypothetical cross size of each item by performing layout with the used main size and the available space, treating auto as fit-content.
</li>

	<li id="algo-cross-line">
<p>
<strong>
各~flex~lineに対し，その交叉sizeを計算する
</strong>：
◎
Calculate the cross size of each flex line.
</p>

<p>
~IF［
~flex容器は`単line$である
］~AND［
その`交叉size$は`確定的$である
］
⇒
`~flex~line$の`交叉size$ ~SET `~flex容器$の内縁 `交叉size$
◎
If the flex container is single-line and has a definite cross size, the cross size of the flex line is the flex container’s inner cross size.
</p>

<p>
~ELSE
⇒
各~flex~lineに対し：
◎
Otherwise, for each flex line:
</p>

		<ol>
			<li>
［
行内軸は主軸に平行である
］~AND［
`align-self$p は `baseline$v:ais であり
］~AND［
交叉軸~marginが両方とも `auto^v でない
］ような，すべての~flex駒を収集する。
その各~駒の［
基底線と仮の外縁 交叉始端~辺
］の合間の距離の中で最大のもの,
および
各~駒の［
基底線とその仮の外縁 交叉終端~辺
］の合間の距離の中で最大のものを見出して、これらの２つの値の和をとる。
◎
Collect all the flex items whose inline-axis is parallel to the main-axis, whose align-self is baseline, and whose cross-axis margins are both non-auto. Find the largest of the distances between each item’s baseline and its hypothetical outer cross-start edge, and the largest of the distances between each item’s baseline and its hypothetical outer cross-end edge, and sum these two values.
</li>

			<li>
前~段にて収集されていない すべての駒の中から，外縁 `仮の交叉size$が最大のものを見出す
◎
Among all the items not collected by the previous step, find the largest outer hypothetical cross size.
</li>

			<li>
<p>
`~flex~line$の使用~交叉sizeは、前の２つの段で見出された２数と~zeroの中で，最大のものになる
◎
The used cross-size of the flex line is the largest of the numbers found in the previous two steps and zero.
</p>

<p>
~flex容器が`単line$である場合、~lineの~交叉sizeを容器の［
~min, ~max
］`交叉size~prop$の算出値で切詰める。
<span class="note">
CSS 2.1 による `min/max-width/height^p の定義が より general に適用される場合、この挙動は自動的に fall out することに注意【？】。<!-- ＊ -->
</span>
◎
If the flex container is single-line, then clamp the line’s cross-size to be within the container’s computed min and max cross-size properties. Note that if CSS 2.1’s definition of min/max-width/height applied more generally, this behavior would fall out automatically.
</p>


			</li>
		</ol>
	</li>

	<li id="algo-line-stretch">
<p>
<strong>
`align-content$p:stretch
を処理する
</strong>：</p>

<p>
~IF［
~flex容器の交叉sizeは`確定的$である
］~AND［
`align-content$p は `stretch$v:ac
］~AND［
一連の~flex~lineの交叉sizeの総和 ~LT ~flex容器の内縁 交叉size
］
⇒
各~flex~lineの交叉sizeを［
それらの交叉sizeの総和が~flex容器の内縁 交叉sizeに正確に等しくなる
］ように，等量に増大させる。
◎
Handle 'align-content: stretch'. If the flex container has a definite cross size, align-content is stretch, and the sum of the flex lines' cross sizes is less than the flex container’s inner cross size, increase the cross size of each flex line by equal amounts such that the sum of their cross sizes exactly equals the flex container’s inner cross size.
</li>

	<li id="algo-visibility">
<p><strong>
`visibility$p:collapse
にされている駒を~collapseする
</strong>：</p>

<p>
~IF［
`visibility$p:collapse
にされている~flex駒がある
］
⇒
それらが属する~lineの交叉sizeを，それらの駒の
`支柱~size@
として記録した上で，~layoutを最初から再開始する：
◎
Collapse visibility:collapse items. If any flex items have visibility: collapse, note the cross size of the line they’re in as the item’s strut size, and restart layout from the beginning.
</p>

<p>
この２周目の~layout回においては、［
<a href="#algo-line-break">駒を一連の~lineに収集する</a>際に~collapseされた駒
］の`主size$は，~zeroとして扱う。
~algoのその段に後続する残りの部分では、~collapseされた駒については，まるごと（それらが
`display$p:none
であったかのように）無視する。
ただし，
<a href="#algo-cross-line">各~lineの交叉sizeの計算</a>
の後では、各~lineの交叉sizeを［
その~line内の~collapseされた すべての駒の中で最大の支柱~size
］以上になる様に切り上げる。
◎
In this second layout round, when collecting items into lines, treat the collapsed items as having zero main size. For the rest of the algorithm following that step, ignore the collapsed items entirely (as if they were display:none) except that after calculating the cross size of the lines, if any line’s cross size is less than the largest strut size among all the collapsed items in the line, set its cross size to that strut size.
</p>

<p>
２周目の~layout回においては，この段は飛ばす。
◎
Skip this step in the second layout round.
</p>

	</li>

	<li id="algo-stretch">
<div >
<p><strong>
各~flex駒 %駒 に対し，その使用~交叉sizeを決定する
</strong>：</p>

<p>
~IF［
%駒 は `align-self$p:stretch
にされている
<!-- 指定値？ -->
］~AND［
%駒 の`交叉size~prop$の算出値は `auto^v である
］~AND［
%駒 のいずれの交叉軸~marginも `auto^v でない
］
⇒
%駒 の使用 外縁 交叉size ~SET その~flex~lineの使用~交叉sizeを %駒 の［
~min, ~max
］`交叉size~prop$に則って切詰めた結果
</p>

<p>
~ELSE
⇒
%駒 の使用~交叉size ~SET %駒 の`仮の交叉size$
</p>

◎
Determine the used cross size of each flex item. If a flex item has align-self: stretch, its computed cross size property is auto, and neither of its cross-axis margins are auto, the used outer cross size is the used cross size of its flex line, clamped according to the item’s min and max cross size properties. Otherwise, the used cross size is the item’s hypothetical cross size.
</div>

<p>
~IF［
%駒 が `align-self$p:stretch にされている
］
⇒
~sizeが百分率の子を解決できるようにするため、この使用~sizeをその確定的 交叉sizeと見なした上で，その内容に対する~layoutをやり直す。
◎
If the flex item has align-self: stretch, redo layout for its contents, treating this used size as its definite cross size so that percentage-sized children can be resolved.
</p>

<p class="note">注記：
この段は %駒 の`主size$には影響しない。
それが内在的~縦横比を有していたとしても。
◎
Note: that this step does not affect the main size of the flex item, even if it has an intrinsic aspect ratio.
</p>

	</li>

</ol>



		</section>
		<section id="main-alignment">
<h3 title="Main-Axis Alignment">9.5. 主軸~沿いの整列</h3>

<ol class="continue">
	<li id="algo-main-align">
<p><strong>
自由空間を配分する
</strong>：</p>
<p>
各~flex~lineに対し：
◎
Distribute any remaining free space. For each flex line:
</p>

		<ol>
			<li>
<p>
~IF［
自由空間は正である
］~AND［
この~line上の少なくとも一方の主軸~marginは `auto^v である
］
⇒
自由空間を，これらの~marginに等量に配分する。
</p>

<p>
~ELSE
⇒
すべての `auto^v ~marginは~zeroにする。
</p>

◎
If the remaining free space is positive and at least one main-axis margin on this line is auto, distribute the free space equally among these margins. Otherwise, set all auto margins to zero.
</li>

			<li>
一連の駒を `justify-content$p に従って，主軸~沿いに整列させる
◎
Align the items along the main-axis per justify-content.
</li>
		</ol>
	</li>
</ol>



		</section>
		<section id="cross-alignment">
<h3 title="Cross-Axis Alignment">9.6. 交叉軸~沿いの整列</h3>

<ol class="continue">
	<li id="algo-cross-margins">
<p><strong>
交叉軸 `auto^v ~marginを解決する
</strong>：</p>

<p>
交叉軸~marginとして
<!-- cascade値が？ -->
`auto^v を持つような，各~flex駒 %I に対し：
◎
Resolve cross-axis auto margins. If a flex item has auto cross-axis margins:
</p>

		<ol>
			<li>
%L ~LET %I が属する~flex~lineの交叉size
</li>

			<li>
~IF［
（ `auto^v ~marginを~zeroと見なした下での） %I の外縁 交叉size
］ ~LT %L
］
⇒

その差分~sizeを `auto^v ~marginに等量に配分する
◎
If its outer cross size (treating those auto margins as zero) is less than the cross size of its flex line, distribute the difference in those sizes equally to the auto margins.
</li>

			<li>
~ELIF［
%I の始端（［
`塊始端$, `行内始端$
］のうち，交叉軸に属する方の）~margin
~EQ `auto^v
］
⇒
その~margin ~SET ~zero；<br />
反対側の~margin ~SET ［
%I の外縁 交叉size ~EQ %L
］になるように設定する。
◎
Otherwise, if the block-start or inline-start margin (whichever is in the cross axis) is auto, set it to zero. Set the opposite margin so that the outer cross size of the item equals the cross size of its flex line.
</li>
		</ol>
	</li>

	<li id="algo-cross-align"><p>
いずれの側の交叉軸~marginも `auto^v でないような，各~flex駒 %I に対し
⇒
%I の `align-self$p に従って，
<strong>
%I を交叉軸~沿いに整列する
</strong>
◎
Align all flex items along the cross-axis per align-self, if neither of the item’s cross-axis margins are auto.
</li>

	<li id="algo-cross-container">
<p>
<strong>
~flex容器の使用~交叉sizeを決定する
</strong>：
◎
Determine the flex container’s used cross size:
</p>

<p>
使用~交叉size ~SET［
`交叉size~prop$の~sizeが`確定的$ならば それ ／
~ELSE_ 一連の~flex~lineの交叉sizeの総和
］を，`~flex容器$の［
~min, ~max
］`交叉size~prop$で切詰めた結果
］
◎
If the cross size property is a definite size, use that, clamped by the min and max cross size properties of the flex container.
◎
Otherwise, use the sum of the flex lines' cross sizes, clamped by the min and max cross size properties of the flex container.
</p>
	</li>

	<li id="algo-line-align">
<p>
`align-content$p に従って
<strong>
すべての~flex~lineを整列する
</strong>
◎
Align all flex lines per align-content.
</p>
	</li>

</ol>



		</section>
		<section id="resolve-flexible-lengths">
<h3 title="Resolving Flexible Lengths">9.7. ~flexible長さの解決法</h3>


<p>
【簡潔に記すため、この節では，次を~~暗黙の前提とする：】
以下における “駒” とは、［［
処理対象の~flex~line
］上に在る`~flex駒$
］を意味する。
</p>

<p class="trans-note">【
~algoの中では，各~駒ごとに いくつかの一時的な %変数 が暗黙的に結び付けられている。
それらのうち，
`目標~主~size@V
が、最終的に各~駒の使用~sizeになる変数を表す。
】</p>

<p>
~flex~lineの中の一連の駒の~flexible長さを解決するためには：
◎
To resolve the flexible lengths of the items within a flex line:
</p>


<ol>
	<li>
<p><strong>
使用~flex係数を決定する
</strong>：</p>

<p>
駒の使用 %~flex係数 ~SET ［［［
すべての駒の外縁 `仮の主size$の総和
］ ~LT ［
~flex容器の内縁 `主size$
］］ならば 駒の`~flex伸長~係数$ ／
~ELSE_ 駒の`~flex縮短~係数$
］
</p>

<p>
この %~flex係数 を~algoの残りの部分に用いる。
</p>

◎
Determine the used flex factor. Sum the outer hypothetical main sizes of all items on the line. If the sum is less than the flex container’s inner main size, use the flex grow factor for the rest of this algorithm; otherwise, use the flex shrink factor.
</li>


	<li><!-- copy -->
<p><strong>
~flexibleでない駒を~sizeする
</strong>：</p>

<p>
~FOR
次のいずれかを満たす~EACH ( 駒 ) に対し
⇒
その
`目標~主~size$V をその`仮の主size$に凍結する：
◎
Size inflexible items. Freeze, setting its target main size to its hypothetical main size…
</p>

		<ul>
			<li>
~flex係数はゼロである
◎
any item that has a flex factor of zero
</li>

			<li>
`~flex伸長~係数$を使用している場合
⇒
`~flex~base~size$ ~GT `仮の主size$ 
◎
if using the flex grow factor: any item that has a flex base size greater than its hypothetical main size
</li>

			<li>
`~flex縮短~係数$を使用している場合
⇒
`~flex~base~size$ ~LT `仮の主size$ 
◎
if using the flex shrink factor: any item that has a flex base size smaller than its hypothetical main size
</li>
		</ul>
	</li>

	<li><!-- copy -->
<p><strong>
`初期の自由空間@V
を計算する：
</strong></p>

<p>
`自由空間@V
~SET ［
~flex容器の内縁 `主size$ − すべての駒の外縁~sizeの総和
］ — ここで、各~駒の外縁~sizeは
⇒
［
駒が<a href="#_freeze_" >凍結</a>されているならば その`目標~主~size$V ／
~ELSE_，駒の外縁 `~flex~base~size$
］
</p>

◎
Calculate initial free space. Sum the outer sizes of all items on the line, and subtract this from the flex container’s inner main size. For frozen items, use their outer target main size; for other items, use their outer flex base size.
</li>

	<li>
<p>
~WHILE ( 未~凍結なる駒がある )：
◎
Loop:
◎
Check for flexible items. If all the flex items on the line are frozen, free space has been distributed; exit this loop.
</p>


		<ol>
			<li>
<p><strong>
上の
`初期の自由空間$V に対する，
`残りの自由空間@V を計算する</strong>：
◎
Calculate the remaining free space as for initial free space, above.
</p>

				<ol >
					<li>
~IF［
未~凍結なる すべての~flex駒の~flex係数の総和 ~LT 1
］
⇒
`初期の自由空間$V に，この総和で積をとる
</li>

					<li>
~IF［
その結果の値 ~LT `残りの自由空間$V
］
⇒
`残りの自由空間$V ← その値
</li>

					<li lang="en">
Calculate the remaining free space as for initial free space, above. If the sum of the unfrozen flex items’ flex factors is less than one, multiply the initial free space by this sum. If the magnitude of this value is less than the magnitude of the remaining free space, use this as the remaining free space.
</li>

				</ol>

			</li>

			<li>
<p>
<strong>~flex係数に比例するように`自由空間$V を配分する：</strong>
◎
Distribute free space proportional to the flex factors.
</p>
				<dl >
					<dt>
`残りの自由空間$V ~EQ 0 の場合
◎
If the remaining free space is zero
</dt>
					<dd>
何もしない
◎
Do nothing.
</dd>

					<dt>
`~flex伸長~係数$を使用している場合
◎
If using the flex grow factor
</dt>

					<dd>
駒の `目標~主~size$V ~SET
その`~flex~base~size$ ~PLUS
`残りの自由空間$V × (
駒の `~flex伸長~係数$ ÷ 未~凍結なる すべての駒の`~flex伸長~係数$の総和
)
◎
Find the ratio of the item’s flex grow factor to the sum of the flex grow factors of all unfrozen items on the line. Set the item’s target main size to its flex base size plus a fraction of the remaining free space proportional to the ratio.
</dd>

					<dt>
`~flex縮短~係数$を使用している場合
◎
If using the flex shrink factor
</dt>
					<dd>
<p>
未~凍結なる ~EACH ( 駒 ) に対し
⇒
その
`拡縮済~flex縮短~係数@V
~LET `~flex縮短~係数$ × 内縁 `~flex~base~size$
</p>

<p>
駒の `目標~主~size$V ~SET
その`~flex~base~size$ ~MINUS
`残りの自由空間$V の絶対値 × (
駒の `拡縮済~flex縮短~係数$V ÷ 未~凍結なる すべての駒の `拡縮済~flex縮短~係数$V の総和
)
</p>

<p class="note">注記：
これにより、 内縁 `主size$は，一時的に負になり得るが，次の段で正される。
</p>

◎
For every unfrozen item on the line, multiply its flex shrink factor by its inner flex base size, and note this as its scaled flex shrink factor. Find the ratio of the item’s scaled flex shrink factor to the sum of the scaled flex shrink factors of all unfrozen items on the line. Set the item’s target main size to its flex base size minus a fraction of the absolute value of the remaining free space proportional to the ratio. Note this may result in a negative inner main size; it will be corrected in the next step. 
</dd>

					<dt>
~OTHER
◎
Otherwise
</dt>
					<dd>
何もしない
◎
Do nothing.
</dd>
				</dl>
			</li>

			<li>
<p><strong>
［
~min／~max
］違反を補正する：
</strong></p>

<p>
~EACH ( 未~凍結なる~駒 ) に対し
⇒
その `目標~主~size$V を，その［
~min, ~max
］`主size~prop$で切詰める
</p>

<p>
これにより， %目標~主size が［
より大きく ／ より小さく
］された駒は［
~min／~max
］違反とされる。
</p>

◎
Fix min/max violations. Clamp each non-frozen item’s target main size by its min and max main size properties. If the item’s target main size was made smaller by this, it’s a max violation. If the item’s target main size was made larger by this, it’s a min violation.
</li>

			<li><!-- copy -->
<p><strong>
~flexが効き過ぎている駒を凍結する：
</strong></p>

<p>
前~段による切詰め量の総和に応じて：
◎
Freeze over-flexed items. The total violation is the sum of the adjustments from the previous step ∑(clamped size - unclamped size). If the total violation is:
</p>

<dl>
	<dt>ゼロ◎Zero</dt>
	<dd>
すべての駒を凍結する
◎
Freeze all items. 
</dd>

	<dt>正◎Positive</dt>
	<dd>
~min違反とされた すべての駒の `目標~主~size$V を，切詰後の~sizeに凍結する
◎
Freeze all the items with min violations. 
</dd>

	<dt>負◎Negative</dt>
	<dd>
~max違反とされた すべての駒の `目標~主~size$V を，切詰後の~sizeに凍結する
◎
Freeze all the items with max violations.
</dd>
</dl>
			</li>
			<li>
( ~CONTINUE )
◎
Return to the start of this loop.
</li>

		</ol>
	</li>

	<li>
~FOR ~EACH ( 駒 ) に対し
⇒
その使用~主size ~SET `目標~主~size$V
◎
Set each item’s used main size to its target main size.
</li>

</ol>

		</section>
		<section id="definite-sizes">
<h3 title="Definite and Indefinite Sizes">9.8. 確定的~size／不定~size</h3>

<p id="cg-2016-definite-indefinite">
CSS Sizing `CSS3-SIZING$r では，長さが
<a href="~SIZING#definite">確定的</a> ／
<a href="~SIZING#indefinite">不定</a>
であることを定義しているが、
Flexbox においては、長さが
`確定的@
と見なされ得る，いくつかの追加の事例がある：
◎
Although CSS Sizing [CSS3-SIZING] defines definite and indefinite lengths, Flexbox has several additional cases where a length can be considered definite:
</p>

<ol>
	<li>
`単line$ `~flex容器$の`交叉size$が確定的である場合、`伸張$されているどの`~flex駒$についても，その外縁 `交叉size$は［
~flex容器の（`~flex駒$の［
~min, ~max
］`交叉size$に切詰められた）内縁 `交叉size$
］になり，`確定的$と見なされる。
◎
If a single-line flex container has a definite cross size, the outer cross size of any stretched flex items is the flex container’s inner cross size (clamped to the flex item’s min and max cross size) and is considered definite.
</li>
	<li>
`~flex駒$ %駒 の`~flex基底$が確定的であって, `~flex容器$の`主size$は確定的である場合、 %駒 の~flex後の`主size$は確定的と扱われる（技術的には、~flexされた`主size$を解決するときに，同胞の確定的でない~sizeに依拠し得るとしても）。
◎
If a flex item has a definite flex basis and the flex container has a definite main size, its post-flexing main size is treated as definite (even though it might technically rely on the sizes of indefinite siblings to resolve its flexed main size).
</li>
	<li id="cg-2016-definite-3">
`~flex~line$の`交叉size$が決定されたなら、
`auto^v で~sizeされている`~flex容器$内の各~駒も，~layoutの目的においては確定的と見なされる
— <a href="#algo-stretch">駒の交叉sizeを決定する段</a>
を見よ。
◎
Once the cross size of a flex line has been determined, items in auto-sized flex containers are also considered definite for the purpose of layout; see step 11. 
</li>

</ol>

<p class="note" id="cg-2016-inflexible-definite-2">注記：
駒の~sizeは、駒が`全部的に非~flexible$である, かつ`~flex基底$は確定的であるならば，定義により`確定的$になる。
◎
Note: The main size of a fully inflexible item with a definite flex basis is, by definition, definite.
</p>


		</section>
		<section id="intrinsic-sizes">
<h3 title="Intrinsic Sizes">9.9. 内在的~size</h3>

<p>
`~flex容器$の`内在的~sizing$は、種々の型の 内容に基づく自動的~sizingの基になる
— `内容収納~行内~size$（内容収納（ fit-content ）公式が利用される）や,
内容に基づく`塊~size$（`最大内容~size$が利用される）など。
◎
The intrinsic sizing of a flex container is used to produce various types of content-based automatic sizing, such as shrink-to-fit logical widths (which use the fit-content formula) and content-based logical heights (which use the max-content size).
</p>

<p>
この節に現れる各種~用語については、`CSS3-SIZING$r を見よ。
◎
See [CSS3-SIZING] for a definition of the terms in this section.
</p>


			<section id="intrinsic-main-sizes">
<h4 title="Flex Container Intrinsic Main Sizes">9.9.1. ~flex容器の内在的~主size</h4>


<p id="cg-intrinsic-items-1">
`~flex容器$の`主軸$沿いの`最大内容~size$は、`~flex容器$が，その一連の`~flex駒$による`最大内容 供与$を維持しつつ 占め得る最小の~sizeである：
◎
The max-content main size of a flex container is the smallest size the flex container can take while maintaining the max-content contributions of its flex items:
</p>

<ol>
	<li id="cg-intrinsic-items-2">
<p>
各`~flex駒$ %I ~IN %L に対し、その
<em>最大内容~flex~fraction</em>
は，次で与えられる %結果 として定義される：
</p>

		<ol>
			<li>
%結果 ~LET ( %I の`最大内容 供与$ ) − ( %I の`~flex~base~size$ )
</li>
			<li>
~IF［
%結果 ~GT ~zero
］
⇒
%結果 ~SET %結果 ÷ min( ( %I の `~flex伸長~係数$ ), 1 )
</li>
			<li>
~IF［
%結果 ~LT ~zero
］
⇒
%結果 ~SET %結果 ÷ min( ( %I の `拡縮済~flex縮短~係数$V ), 1 )
</li>
		</ol>

◎
For each flex item, subtract its outer flex base size from its max-content contribution size. If that result is not zero, divide it by (if the result was positive) its flex grow factor floored at 1, or (if the result was negative) by its scaled flex shrink factor, having floored the flex shrink factor at 1. This is the item’s max-content flex fraction.
</li>

	<li>
すべての`~flex駒$を，~lineの長さを無限にした下で，一連の~lineの中へ配置する。
◎
Place all flex items into lines of infinite length.
</li>

	<li>
<p>
各~line %L に対し，次を計算する：
</p>

	<ol>
		<li>
%f ~LET 
max( %I の最大内容~flex~fraction； %I ~IN %L )
</li>

		<li>
各~駒 %I ~IN %L に対し
⇒
size( %I ) ~LET min(［
%f ≥ 0 ならば %I の`~flex伸長~係数$／
%f &lt; 0 ならば %I の `拡縮済~flex縮短~係数$V
］ × %f + ［
%I の`~flex~base~size$
］,［
%I の~max`主size~prop$
］)


</li>

		<li>
size(%L) ~LET ( size( %I ) の総和 ； %I ~IN %L )
</li>

</ol>

◎
Within each line, find the largest max-content flex fraction among all the flex items. Add each item’s flex base size to the product of its flex grow factor (or scaled flex shrink factor, if the chosen max-content flex fraction was negative) and the chosen max-content flex fraction, then clamp that result by the max main size property.
</li>


	<li>
`~flex容器$の`最大内容~size$は、すべての~lineに対する size( ~line ) の最大で与えられる
◎
The flex container’s max-content size is the largest sum of the afore-calculated sizes of all items within a single line.
</li>

</ol>

<div class="p">
<p>
~flex容器の`主軸$沿いの`最小内容~size$は：
</p>
<ul>
	<li>
`単line$容器に対しては
⇒
［
`~flex駒$の`最小内容 供与$が その`最大内容 供与$に代わって利用される
］ことを除いて，`主軸$沿いの`最大内容~size$と同じに計算される。
</li>
	<li>
<em>`複line$</em> 容器に対しては
⇒
単に，`~flex容器$内のすべての`~flex駒$による`最小内容 供与$の最大になる。
</li>
</ul>

◎
The min-content main size of a single-line flex container is calculated identically to the max-content main size, except that the flex item’s min-content contribution is used instead of its max-content contribution. However, for a multi-line container, it is simply the largest min-content contribution of all the flex items in the flex container.
</div>



			</section>
			<section id="intrinsic-cross-sizes">
<h4 title="Flex Container Intrinsic Cross Sizes">9.9.2. ~flex容器の内在的~交叉size</h4>


<p >
`~flex容器$ %C の［
`交叉軸$沿いの`最小内容~size$
／
`交叉軸$沿いの`最大内容~size$
］（以下，同順）は、次で与えられる：
◎
↓</p>

<dl class="switch" id="cg-intrinsic-cross-container">
	<dt>%C は`単line$ならば：</dt>
	<dd>
%C の各`~flex駒$の［
`最小内容 供与$ ／ `最大内容 供与$
］の最大。
◎
The min-content/max-content cross size of a single-line flex container is the largest min-content contribution/max-content contribution (respectively) of its flex items.
</dd>

	<dt>%C は`複line$ならば：</dt>
	<dd>
%C を`交叉軸$~~方向の［
`最小内容 拘束$ ／ `最大内容 拘束$
］の下で~sizeした結果から得られる，各~flex~lineの`交叉size$の総和。
</dd>
	<dd>
<p>
ただし、 %C が `flex-flow$p:column_wrap にされている場合、
%C は次のように~sizeされる：
</p>

		<ol>
			<li>
先ず、 %C 内のすべての`~flex駒$にわたる`交叉軸$の［
`最小内容 供与$ ／ `最大内容 供与$
］のうち，最大のものを見出す。
</li>
			<li>
前~段の結果の~sizeを，~layout時において［
各`~flex駒$に対する，`交叉軸$の`可用な空間$
］に利用する。
</li>
		</ol>
◎
For a multi-line flex container, the min-content/max-content cross size is the sum of the flex line cross sizes resulting from sizing the flex container under a cross-axis min-content constraint/max-content constraint (respectively). However, if the flex container is flex-flow: column wrap;, then it’s sized by first finding the largest min-content/max-content cross-size contribution among the flex items (respectively), then using that size as the available space in the cross axis for each of the flex items during layout.
</dd>
	<dd>
<p class="note">注記：
この `column wrap^v にされた`~flex容器$に対する経験則は、次をいずれも満たすような，`~flex容器$のあるべき~sizeに対する適度な近似を与えるが：
</p>

<ul>
	<li>
各~flex駒の結果の~sizeは
⇒
min( ［
その駒の自前の最大内容~size
］, ［
すべての駒の最小内容~sizeのうちの最大
］ )
</li>
	<li>
各`~flex~line$は、その中の最大の`~flex駒$より大きくならない。
</li>
</ul>

<p>
が、一部の事例では，完璧に収まるもの<em>ではない</em>。
完全に正しくやるのは，ひどく高価であり、これでも適度に働く。
</p>
◎
Note: This heuristic for column wrap flex containers gives a reasonable approximation of the size that the flex container should be, with each flex item ending up as min(item’s own max-content, maximum min-content among all items), and each flex line no larger than its largest flex item. It’s not a perfect fit in some cases, but doing it completely correct is insanely expensive, and this works reasonably well.
</dd>

</dl>


			</section>
			<section id="intrinsic-item-contributions">
<h4 title="Flex Item Intrinsic Size Contributions">9.9.3. ~flex駒の内在的~size供与</h4>

<div class="p" id="cg-intrinsic-sizing">
<p>
`~flex駒$の %I の主size［
`最小内容 供与$ ／ `最大内容 供与$
］は、次で与えられる %~size として定義される：
</p>

<ol>
	<li>
%~size ~LET %I の<em>外縁</em>［
`最小内容~size$ ／ `最大内容~size$
］（同順）
</li>
	<li>
~IF［
%I は伸長できない
<span class="trans-note">【
すなわち， %I の `flex-grow$p 値は `0^v
】</span>
］
⇒
%~size ~SET max( %~size, %I の`~flex~base~size$ )
</li>
	<li>
~IF［
%I は縮短できない
<span class="trans-note">【
すなわち， %I の `flex-shrink$p 値は `0^v
】</span>
］
⇒
%~size ~SET min( %~size, %I の`~flex~base~size$ )
</li>
	<li>
%~size ~SET max( min( %~size, %I の~max`主size~prop$ ), %I の~min`主size~prop$)
</li>
</ol>
◎
The main-size min-content/max-content contribution of a flex item is its outer min-content/max-content size, clamped by its flex base size as a maximum (if it is not growable) and/or as a minimum (if it is not shrinkable), and then further clamped by its min/max main size properties.
</div>

			</section>
		</section>
	</section>
	<section id="pagination">
<h2 title="Fragmenting Flex Layout">10. ~flex~layoutの断片化法</h2>

<p>
~flex容器は、［
駒と駒の合間
］, あるいは［
（`複line$~mode下における）いくつかの駒からなる~lineと~lineの合間
］, あるいは［
駒の内側
］にて，何~頁かに渡って分断され得る。
各種 `break-*$p ~propは、通常の［
`塊level$／`行内level$
］の~boxに対するときと同様に，~flex容器にも適用される。
この節では、それらがどのように ~flex駒とその内容に適用されるかを定義する。
◎
Flex containers can break across pages between items, between lines of items (in multi-line mode), and inside items. The break-* properties apply to flex containers as normal for block-level or inline-level boxes. This section defines how they apply to flex items and the contents of flex items.
</p>

<p>
以下の分断~処理~規則の下での， “頁” とは、`断片化~容器$を指す。
同じ規則は，他の`断片化~文脈$においても適用される（必要に応じて， “頁” を適切な`断片化~容器$の種別に読み替える）
— `CSS3-BREAK$r を見よ。
可読性のため、この節の用語
“~row”, “~col”
は、`~flex容器$ 自身のそれではなく，［
`断片化~文脈$の`塊~flow方向$
］に相対的な~flex容器の方位を指すとする。
【 “~col” が塊~flow方向】
◎
The following breaking rules refer to the fragmentation container as the “page”. The same rules apply in any other fragmentation context. (Substitute “page” with the appropriate fragmentation container type as needed.) See the CSS3 Fragmentation Module [CSS3-BREAK]. For readability, in this section the terms "row" and "column" refer to the relative orientation of the flex container with respect to the block flow direction of the fragmentation context, rather than to that of the flex container itself.
</p>

<p>
~flex容器が断片~化されるときの正確な~layoutは、この仕様のこの~levelでは定義されない。
しかしながら，~flex容器の内側における分断には、次の規則が課される：
◎
The exact layout of a fragmented flex container is not defined in this level of Flexible Box Layout. However, breaks inside a flex container are subject to the following rules:
</p>

<ul>
	<li>
<p>
~row~flex容器においては：
</p>
		<ul>
			<li>
~flex駒~上の［
`break-before$p ／ `break-after$p
］~propは，~flex~lineに伝播する。
</li>
			<li>
［
最初の~line上の `break-before$p ~prop ／
最後の~line上の `break-after$p ~prop
］は、~flex容器に伝播する。
</li>
		</ul>
◎
In a row flex container, the break-before and break-after properties on flex items are propagated to the flex line. The break-before property on the first line and the break-after property on the last line are propagated to the flex container.
</li>

	<li>
<p>
~col~flex容器においては：
</p>
		<ul>
			<li>
［
最初の駒~上の`break-before$p ~prop ／
最後の駒~上の`break-after$p ~prop
］は、~flex容器に伝播する。
</li>
			<li>
他の駒~上の強制分断は、その駒~自身に適用される。
</li>
		</ul>
◎
In a column flex container, the break-before property on the first item and the break-after property on the last item are propagated to the flex container. Forced breaks on other items are applied to the item itself.
</li>

	<li>
~flex駒の内側の強制分断は、実質的に，その内容の~sizeを増大させる。
それは、他の同胞~駒の内側に強制分断を誘発することはない。
◎
A forced break inside a flex item effectively increases the size of its contents; it does not trigger a forced break inside sibling items.
</li>

	<li>
<p>
~row~flex容器においては：
</p>

<ul>
	<li>
一連の同胞~flex~lineの各~合間に，
`Class A の分断~機会$が生じる。
</li>
	<li>
［［
最初／最後
］の~flex~line
］と［
~flex容器の内容~辺
］との合間に，
`Class C の分断~機会$が生じる。
</li>
</ul>

<p>
~col~flex容器においては：
</p>

<ul>
	<li>
一連の同胞~flex駒の各~合間に，
`Class A の分断~機会$が生じる。
</li>
	<li>
［
~line上の［
最初／最後
］の~flex駒
］と［
~flex容器の内容~辺
］との合間に
`Class C の分断~機会$が生じる。
</li>
</ul>

<p>
`CSS3-BREAK$r
</p>

◎
In a row flex container, Class A break opportunities occur between sibling flex lines, and Class C break opportunities occur between the first/last flex line and the flex container’s content edges. In a column flex container, Class A break opportunities occur between sibling flex items, and Class C break opportunities occur between the first/last flex items on a line and the flex container’s content edges. [CSS3-BREAK]
</li>

	<li>
~flex容器が分断の後にも継続されるとき、その`~flex駒$に`可用な空間$は（`断片化~文脈$の塊~flow方向においては），それまでの一連の頁~上の一連の~flex容器~断片に費やされた空間により，節減される。
~flex容器~断片に費やされる空間が、当の頁~上のその内容~boxの~sizeになる。
この可用な空間の調整の結果が負になった場合、それは~zeroに設定される。
◎
When a flex container is continued after a break, the space available to its flex items (in the block flow direction of the fragmentation context) is reduced by the space consumed by flex container fragments on previous pages. The space consumed by a flex container fragment is the size of its content box on that page. If as a result of this adjustment the available space becomes negative, it is set to zero.
</li>

	<li id="cg-first-fragment">
~flex容器の最初の断片が頁の上端に来ない, かつ
頁~上の残りの空間に収まる~flex駒はない場合、その断片~全体が次の頁へ移動される。
◎
If the first fragment of the flex container is not at the top of the page, and none of its flex items fit in the remaining space on the page, the entire fragment is moved to the next page.
</li>

	<li>
`複line$の~col~flex容器が分断されるときは、［
複柱~要素の各~断片が自身の［
一連の~col~boxからなる~row
］を持つ
］のと同じ様に，各~断片がそれ自身の［
一連の~flex~lineからなる， “堆積”
］を持つ。
◎
When a multi-line column flex container breaks, each fragment has its own "stack" of flex lines, just like each fragment of a multi-column element has its own row of column boxes.
</li>

	<li>
以上により課される，一連の駒の配置替えとは別に、~UAは，~flowの断片~化をなるべく抑えるため，~flex容器の乱れを最小限に留めるべきである。
◎
Aside from the rearrangement of items imposed by the previous point, UAs should attempt to minimize distortion of the flex container with respect to unfragmented flow.
</li></ul>



		<section id="pagination-algo">
<h3 title="Sample Flex Fragmentation Algorithm">10.1. ~flex断片化~algoの一例</h3>

<p>
この参考節では、~flex容器の断片化~algoとして考え得る一例を示す。
実装者には，この~algoを改良して
CSS Working Group まで
<a href="#feedback">フィードバックを寄せられる</a>
よう願う。
◎
This informative section presents a possible fragmentation algorithm for flex containers. Implementors are encouraged to improve on this algorithm and provide feedback to the CSS Working Group.
</p>

<div class="example">

<p class="note">注記：
この~algoは、頁割付処理が常に順方向に進む（後戻りしない）ものと見做している。
したがって、頁割付処理に先行する整列は，ほぼ無視される。
より高度な~layout~engineは、複数の断片に渡る整列も加味し得る。
◎
This algorithm assumes that pagination always proceeds only in the forward direction; therefore, in the algorithms below, alignment is mostly ignored prior to pagination. Advanced layout engines may be able to honor alignment across fragments.
</p>

<dl>
	<dt>`単line$ ~col~flex容器</dt>
	<dd>
		<ol>
			<li>
~flex~layout~algoを，`交叉sizeの決定$の所まで実行する（頁割付処理は~~考慮せずに）
◎
Run the flex layout algorithm (without regards to pagination) through Cross Sizing Determination.
</li>

			<li>
できるだけ多くの（ただし，少なくとも１個以上, またはその断片の）連続する［
~flex駒 または駒~断片
］を、最初から順に，頁~上の部屋が尽きるか, または強制分断に遭遇するまで，~lay-outする
◎
Lay out as many consecutive flex items or item fragments as possible (but at least one or a fragment thereof), starting from the first, until there is no more room on the page or a forced break is encountered.
</li>

			<li>
<p>
~IF［
前~段により部屋が尽きた
］~AND［
自由空間は正である
］
⇒
~UAは，次の分断し得ない［
駒／断片
］のための部屋を作るために，この頁~上に配分される自由空間を節減しても~MAY（負にならない所まで）。
</p>

<p>
~ELSE
⇒
収まり切らない［
駒／断片
］は，次の頁に押出される。
~UAは，
50% より多くの断片が残りの空間に収まる場合は引き上げ,
そうでなければ押出すべきである。
</p>

◎
If the previous step ran out of room and the free space is positive, the UA may reduce the distributed free space on this page (down to, but not past, zero) in order to make room for the next unbreakable flex item or fragment. Otherwise, the item or fragment that does not fit is pushed to the next page. The UA should pull up if more than 50% of the fragment would have fit in the remaining space and should push otherwise.
</li>

			<li>
~IF［
これまでの手続きで~lay-outされなかった［
駒／断片
］が在る
］
⇒
~flex~layout~algoの，`~line~sizeの決定$から`交叉sizeの決定$までの部分を、次の頁の~sizeの下に, （すでに~lay-outされたものも含めた）内容 <em>すべて</em>により再実行した上で、まだ~lay-outされていない最初の［
駒／断片
］から開始する下で，前~段へ戻る。
◎
If there are any flex items or fragments not laid out by the previous steps, rerun the flex layout algorithm from Line Length Determination through Cross Sizing Determination with the next page’s size and all the contents (including those already laid out), and return to the previous step, but starting from the first item or fragment not already laid out.
</li>

			<li>
~flex容器~内の各~断片に対し、~flex~layout~algoの，`主軸の整列$から その最後までの部分を続行する。
◎
For each fragment of the flex container, continue the flex layout algorithm from Main-Axis Alignment to its finish.
</li>
		</ol>

<p class="note">注記：
この~algoでは意図的に、~col方向で`単line$の ~flex容器が，塊~flowとごく似る様に頁割付させている。
その test の意図は、［
`justify-content$p:start にされていて, ~flexible駒を伴わない
］ような~flex容器による頁割付と，［
`~flow内$にある子を伴い, 同じ［
内容, 使用~size, 使用~margin
］を伴う
］ような塊による頁割付が，一致するべきである所に由来する。
◎
It is the intent of this algorithm that column-direction single-line flex containers paginate very similarly to block flow. As a test of the intent, a flex container with justify-content:start and no flexible items should paginate identically to a block with in-flow children with same content, same used size and same used margins.
</p>
	</dd>

	<dt>`複line$ ~col~flex容器</dt>
	<dd>
		<ol>
			<li>
頁割付処理を~~考慮した<em>上で</em>（~flex容器の最大~line長さを頁~上に残された空間に制限した下で）、~flex~layout~algoの，`交叉sizeの決定$の所までを実行する。
◎
Run the flex layout algorithm with regards to pagination (limiting the flex container’s maximum line length to the space left on the page) through Cross Sizing Determination.
</li>

			<li>
<p>
できるだけ多く（ただし，少なくとも 1 本以上）の~flex~lineを、交叉~次元にて~flex容器の部屋が尽きるか, または 強制分断に遭遇するまで，~lay-outする：
◎
Lay out as many flex lines as possible (but at least one) until there is no more room in the flex container in the cross dimension or a forced break is encountered:
</p>
				<ol>
					<li>
できるだけ多く（ただし，少なくとも 1 つ以上）の連続する~flex駒を、最初のものから順に，頁~上の部屋が尽きるか, または 強制分断に遭遇するまで，~lay-outする。
ただし，~flex駒の <em>内部の</em> 強制分断は無視する。
◎
Lay out as many consecutive flex items as possible (but at least one), starting from the first, until there is no more room on the page or a forced break is encountered. Forced breaks within flex items are ignored.
</li>

					<li>
~IF［
これが最初の~flex容器~断片である
］~AND［
この~lineは 頁~上に残された空間より大きい単独の~flex駒のみを包含する
］~AND［
この~flex容器はすでに頁先頭に来ているのではない
］
⇒
その~flex容器を次の頁に移動した上で，~flex容器~layout全体を再開始する
◎
If this is the first flex container fragment, this line contains only a single flex item that is larger than the space left on the page, and the flex container is not at the top of the page already, move the flex container to the next page and restart flex container layout entirely.
</li>

					<li>
~IF［
最初の段にて~lay-outされていない~flex駒がある
］
⇒
~flex~layout~algoの，`主sizeの決定$から`交叉sizeの決定$までの部分を、前の~line上に~lay-outされていない駒のみを用いて，再実行した上で、まだ~lay-outされていない最初の駒から開始する下で，前~段へ戻る。
◎
If there are any flex items not laid out by the first step, rerun the flex layout algorithm from Main Sizing Determination through Cross Sizing Determination using only the items not laid out on a previous line, and return to the previous step, starting from the first item not already laid out.
</li>
				</ol>
			</li>

			<li>
~IF［
前~段で~lay-outされていない~flex駒が在る
⇒
次の頁の~size, および まだ~lay-outされていない駒のみを用いて
~flex~layout~algoの
`~line~sizeの決定$から`交叉sizeの決定$までの部分を再実行した上で、まだ~lay-outされていない最初の駒から開始する下で，前~段へ戻る。
◎
If there are any flex items not laid out by the previous step, rerun the flex layout algorithm from Line Sizing Determination through Cross Sizing Determination with the next page’s size and only the items not already laid out, and return to the previous step, but starting from the first item not already laid out.
</li>

			<li>
~flex容器の各~断片に対し、~flex~layout~algoの，`主軸の整列$から その最後までの部分を続行する。
◎
For each fragment of the flex container, continue the flex layout algorithm from Main-Axis Alignment to its finish.
</li>

</ol>

<p class="note">注記：
単独の頁~上に~flex駒の全体が収まり切らない場合、
`複line$ ~col~flex容器の中に
頁割付されることは<em>ない</em>。
◎
If a flex item does not entirely fit on a single page, it will not be paginated in multi-line column flex containers.
</p>
	</dd>

	<dt>`単line$ ~row~flex容器</dt>
	<dd>
		<ol>
			<li>
［
`flex-start$v:ais, `baseline$v:ais
］以外のどの `align-self$p 値も `flex-start$v:ais と見なした下で、~flex~layout~algo全体を（頁割付処理は~~考慮せずに）実行する。
◎
Run the entire flex layout algorithm (without regards to pagination), except treat any align-self other than flex-start or baseline as flex-start.
</li>

			<li>
~IF［
分断し得ない駒が頁~上に残された空間に収まり切らない
］~AND［
この~flex容器が頁先頭に来てはいない
］
⇒
その~flex容器を次の頁へ移動した上で，~flex容器~layout全体を再開始する。
◎
If an unbreakable item doesn’t fit within the space left on the page, and the flex container is not at the top of the page, move the flex container to the next page and restart flex container layout entirely.
</li>

			<li>
<p>
各~駒に対し、その内容を頁~上に残された空間に収まる限り，~lay-outする。
残りの内容を次の頁~上に断片~化する
—
<em>すべての</em>内容（前の頁~上で完結した駒も含む）を用いて，新たな頁~sizeの下で，~flex~layout~algoの，`~line~sizeの決定$から`主軸の整列$までの部分を再実行した上で。
◎
For each item, lay out as much of its contents as will fit in the space left on the page, and fragment the remaining content onto the next page, rerunning the flex layout algorithm from Line Length Determination through Main-Axis Alignment into the new page size using all the contents (including items completed on previous pages).
</p>

<p class="note">注記：
それまでの断片たちの中に全体が収まる~flex駒は、依然として，後方の断片たちにおける主軸の空間を占める。
◎
Any flex items that fit entirely into previous fragments still take up space in the main axis in later fragments.
</li>

			<li>
~flex容器の各~断片に対し、~flex~layout~algoの，`交叉軸の整列$から 最後までの部分を再実行する。
最初のもの以外のすべての断片に対し，［
すべての駒~断片と~lineに対する［
`align-self$p, `align-content$p
］は `flex-start$v:ais に扱う
］。
◎
For each fragment of the flex container, rerun the flex layout algorithm from Cross-Axis Alignment to its finish. For all fragments besides the first, treat align-self and align-content as being flex-start for all item fragments and lines.
</li>

			<li>
~IF［
駒を、その元の `align-self$p 値に則って［［
すべての~flex容器~断片
］の`交叉size$の合計
］の中で整列させたとするときに，［
単独の~flex容器~断片~内に全体が収まる
］ことになる
］
⇒
その駒を，その断片の中に~~移動して, 適切に整列して~MAY。
◎
If any item, when aligned according to its original align-self value into the combined cross size of all the flex container fragments, would fit entirely within a single flex container fragment, it may be shifted into that fragment and aligned appropriately.
</li>
		</ol>
	</dd>

	<dt>`複line$ ~row~flex容器</dt>
	<dd>
		<ol>
			<li>
~flex~layout~algoの，`交叉sizeの決定$の所までを（頁割付処理は~~考慮せずに）実行する。
◎
Run the flex layout algorithm (without regards to pagination), through Cross Sizing Determination.
</li>

			<li>
<p>
できるだけ多く（ただし，少なくとも 1 本以上）の~flex~lineを，
最初から順に，頁~上の部屋が尽きるか, または 強制分断に遭遇するまで，~lay-outする。
◎
Lay out as many flex lines as possible (but at least one), starting from the first, until there is no more room on the page or a forced break is encountered.
</p>

<p>
~IF［
~lineは［
頁に収まり切らない
］~AND［
頁先頭に来てはいない
］］
⇒
~lineを次の頁に移動させた上で、それらの駒のみを用いて，この~lineに後続するように
~flex~layout~algo全体を再開始する。
◎
If a line doesn’t fit on the page, and the line is not at the top of the page, move the line to the next page and restart the flex layout algorithm entirely, using only the items in and following this line.
</p>

<p>
~IF［
~flex駒それ自身が強制分断を生じさせている
］
⇒
この~lineと後続の~line上の駒のみを用いて, ［
`~line分断~処理~段$において自動的な分断により新たな~lineを開始させた駒
］は用いずに、
~flex~layout~algoの，`主sizeの決定$から`主軸の整列$までの部分を再実行した上で，この段を継続する。
~flex駒 <em>内の</em>強制分断は無視される。
◎
If a flex item itself causes a forced break, rerun the flex layout algorithm from Main Sizing Determination through Main-Axis Alignment, using only the items on this and following lines, but with the item causing the break automatically starting a new line in the line breaking step, then continue with this step. Forced breaks within flex items are ignored.
</li>

			<li>
~IF［
前~段により~lay-outされなかった~flex駒がある
］
⇒
次の頁の~sizeおよび
まだ~lay-outされていない駒のみを用いて、~flex~layout~algoの，`~line~sizeの決定$から`主軸の整列$までの部分を再実行した上で，まだ~lay-outされていない最初の~lineから開始する下で，前~段へ戻る。
◎
If there are any flex items not laid out by the previous step, rerun the flex layout algorithm from Line Length Determination through Main-Axis Alignment with the next page’s size and only the items not already laid out. Return to the previous step, but starting from the first line not already laid out.
</li>

			<li>
~flex容器の各~断片に対し、~flex~layout~algoの，`交叉軸の整列$から その最後までの部分を続行する。
◎
For each fragment of the flex container, continue the flex layout algorithm from Cross Axis Alignment to its finish.
</li>
		</ol>
	</dd>

</dl>
</div>


		</section>
	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">11. ~privacyと保安~上の考慮点</h2>

<p>
この仕様により、新たな~privacy漏洩や,［
“正しく実装すること” を超えるような保安~上の考慮点
］が導入されることはない。
◎
Flexbox introduces no new privacy leaks, or security considerations beyond "implement it correctly".
</p>


	</section>
	<section id="axis-mapping">
<h2 title="Appendix A: Axis Mappings">付録 A. 各~軸の対応関係</h2>

~INFORMATIVE

<div style="overflow: auto;">

<table border class="axis-mapping" id="axis-mapping-table-en">
<caption>
［
`ltr$v + `horizontal-tb$v
］`書字mode$（例： 英語）における各~軸の対応関係
◎
Axis Mappings for ltr + horizontal-tbWriting Mode (e.g. English)
</caption>

<colgroup span="1"></colgroup>
<colgroup span="3"></colgroup>
<colgroup span="3"></colgroup>

<thead><tr><th>`flex-flow$p
</th><th>`主軸$
</th><th>`始端$
</th><th>`終端$
</th><th>`交叉軸$
</th><th>`始端$
</th><th>`終端$
</th></tr></thead>

<tbody><tr><th>`row$v:fd + `wrap$v:fw
</th><td rowspan="4">横方向
</td><td>左端
</td><td>右端
</td><td rowspan="4">縦方向
</td><td rowspan="2">上端
</td><td rowspan="2">下端

</td></tr><tr><th>`row-reverse$v:fd + `wrap$v:fw
</th><td>右端
</td><td>左端

</td></tr><tr><th>`row$v:fd + `wrap-reverse$v:fw
</th><td>左端
</td><td>右端
</td><td rowspan="2">下端
</td><td rowspan="2">上端

</td></tr><tr><th>`row-reverse$v:fd + `wrap-reverse$v:fw
</th><td>右端
</td><td>左端

</td></tr><tr><th>`column$v:fd + `wrap$v:fw
</th><td rowspan="4">縦方向
</td><td>上端
</td><td>下端
</td><td rowspan="4">横方向
</td><td rowspan="2">左端
</td><td rowspan="2">右端

</td></tr><tr><th>`column-reverse$v:fd + `wrap$v:fw
</th><td>下端
</td><td>上端

</td></tr><tr><th>`column$v:fd + `wrap-reverse$v:fw
</th><td>上端
</td><td>下端
</td><td rowspan="2">右端
</td><td rowspan="2">左端

</td></tr><tr><th>`column-reverse$v:fd + `wrap-reverse$v:fw
</th><td>上端
</td><td>下端
</td></tr></tbody></table>

<table border class="axis-mapping" id="axis-mapping-table-fa">
<caption>
［
`rtl$v + `horizontal-tb$v 
］`書字mode$（例： ペルシャ語）における各~軸の対応関係
◎
Axis Mappings for rtl + horizontal-tbWriting Mode (e.g. Farsi)
</caption>
<colgroup span="1"></colgroup>
<colgroup span="3"></colgroup>
<colgroup span="3"></colgroup>

<thead><tr><th>`flex-flow$p
</th><th>`主軸$
</th><th>`主始端$
</th><th>`主終端$
</th><th>`交叉軸$
</th><th>`交叉始端$
</th><th>`交叉終端$
</th></tr></thead>

<tbody><tr><th>`row$v:fd + `wrap$v:fw
</th><td rowspan="4">横方向
</td><td>右端
</td><td>左端
</td><td rowspan="4">縦方向
</td><td rowspan="2">上端
</td><td rowspan="2">下端

</td></tr><tr><th>`row-reverse$v:fd + `wrap$v:fw
</th><td>左端
</td><td>右端

</td></tr><tr><th>`row$v:fd + `wrap-reverse$v:fw
</th><td>右端
</td><td>左端
</td><td rowspan="2">下端
</td><td rowspan="2">上端

</td></tr><tr><th>`row-reverse$v:fd + `wrap-reverse$v:fw
</th><td>左端
</td><td>右端

</td></tr><tr><th>`column$v:fd + `wrap$v:fw
</th><td rowspan="4">縦方向
</td><td>上端
</td><td>下端
</td><td rowspan="4">横方向
</td><td rowspan="2">右端
</td><td rowspan="2">左端

</td></tr><tr><th>`column-reverse$v:fd + `wrap$v:fw
</th><td>下端
</td><td>上端

</td></tr><tr><th>`column$v:fd + `wrap-reverse$v:fw
</th><td>上端
</td><td>下端
</td><td rowspan="2">左端
</td><td rowspan="2">右端

</td></tr><tr><th>`column-reverse$v:fd + `wrap-reverse$v:fw
</th><td>上端
</td><td>下端
</td></tr></tbody></table>

<table border class="axis-mapping" id="axis-mapping-table-ja">
<caption>
［
`ltr$v + `vertical-rl$v
］`書字mode$（例： 日本語）における各~軸の対応関係
◎
Axis Mappings for ltr + vertical-rlWriting Mode (e.g. Japanese)
</caption>
<colgroup span="1"></colgroup>
<colgroup span="3"></colgroup>
<colgroup span="3"></colgroup>

<thead><tr><th>`flex-flow$p
</th><th>`主軸$
</th><th>`始端$
</th><th>`終端$
</th><th>`交叉軸$
</th><th>`始端$
</th><th>`終端$
</th></tr></thead>

<tbody><tr><th>`row$v:fd + `wrap$v:fw
</th><td rowspan="4">縦方向
</td><td>上端
</td><td>下端
</td><td rowspan="4">横方向
</td><td rowspan="2">右端
</td><td rowspan="2">左端

</td></tr><tr><th>`row-reverse$v:fd + `wrap$v:fw
</th><td>下端
</td><td>上端

</td></tr><tr><th>`row$v:fd + `wrap-reverse$v:fw
</th><td>上端
</td><td>下端
</td><td rowspan="2">左端
</td><td rowspan="2">右端

</td></tr><tr><th>`row-reverse$v:fd + `wrap-reverse$v:fw
</th><td>下端
</td><td>上端

</td></tr><tr><th>`column$v:fd + `wrap$v:fw
</th><td rowspan="4">縦方向
</td><td>右端
</td><td>左端
</td><td rowspan="4">横方向
</td><td rowspan="2">上端
</td><td rowspan="2">下端

</td></tr><tr><th>`column-reverse$v:fd + `wrap$v:fw
</th><td>左端
</td><td>右端

</td></tr><tr><th>`column$v:fd + `wrap-reverse$v:fw
</th><td>右端
</td><td>左端
</td><td rowspan="2">下端
</td><td rowspan="2">上端

</td></tr><tr><th>`column-reverse$v:fd + `wrap-reverse$v:fw
</th><td>右端
</td><td>左端
</td></tr></tbody></table>

</div>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
次の方々からのフィードバックと貢献に謝意を：
◎
Thanks for feedback and contributions to
</p>

<div>
Erik Anderson,
Christian Biesinger,
Tony Chang,
Phil Cupp,
Arron Eicholz,
James Elmore,
Andrew Fedoniouk,
Brian Heuston,
Shinichiro Hamaji,
Daniel Holbert,
Ben Horst,
John Jansen,
Brad Kemper,
Kang-hao Lu,
Markus Mielke,
Peter Moulder,
Robert O’Callahan,
Christoph Päper,
Ning Rogers,
Peter Salas,
Elliott Sprehn,
Morten Stenshorne,
Christian Stockwell,
Ojan Vafai,
Eugene Veselov,
Greg Whitworth,
Boris Zbarsky.
</div>



	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p class="trans-note">【
この訳では、原文の修正箇所の引用の記述を，この訳の当該箇所へのリンク：《変更箇所》に置換している。
その直後の “（追加）” は新たに追記されたことを表し, “（更新）” は変更前の~~内容（詳細は原文参照）から新たな~~内容に更新されたことを表す。
】</p>

<p>
この節は、前回の発行からの変更点を文書化する。
◎
This section documents the changes since previous publications.
</p>

		<section id="changes-20160301">
<h3 title="Changes since the 1 March 2016 CR">2016 年 3 月 1 日付 勧告候補からの変更点</h3>

<p>
<a href="~CSSFLEX/issues-cr-20160301">Disposition of Comments</a>
も用意されている。
◎
A Disposition of Comments is also available.
</p>



			<section id="change-201603-substantive">
<h4 title="Substantive Changes and Bugfixes">主要な変更点とバグ修正</h4>

<ul>
	<li id="change-2016-intrinsic-percentage">
内在的`自動的~最小~size$を計算するときの百分率の取扱い方を定義した。
（ <a href="~CSSFLEX/issues-cr-20160301#issue-3">Issue 3</a> ）
《`cg-2016-intrinsic-percentage-1$cg, `cg-2016-intrinsic-percentage-2$cg（追加）》
◎
Define how percentages are handled when calculating intrinsic automatic minimum sizes. (Issue 3)
</li>

	<li id="change-2016-definite-indefinite">
［
`確定的$, `不定$
］の定義を，この~module内に直に記す代わりに
`CSS3-SIZING$r による（より正しい）定義を指すようにした。
（ <a href="~CSSFLEX/issues-cr-20160301#issue-10">Issue 10</a> ）
《`cg-2016-definite-indefinite$cg（更新）》
◎
Switched definite and indefinite to refer to the (more correct) definitions in [CSS3-SIZING] instead of defining them inline in this module. (Issue 10)
</li>

	<li id="change-2016-abspos-no-order">
~flex~boxにおける絶対位置の子は、もはや
`order$p ~propから影響されなくなった。
（ <a href="~CSSFLEX/issues-cr-20160301#issue-12">Issue 13</a> ）
《`cg-2016-abspos-no-order$cg（更新）》
◎
Abspos children of a flexbox no longer respond to the order property. (Issue 13))
</li>

	<li id="change-2016-baseline-sets">
<a href="#flex-baselines">~flex容器の基底線</a>
節を，`基底線~集合$と
<a href="~CSSALIGN#last-baseline-alignment">最後の基底線による整列</a>
も織り込むように更新した。
（ <a href="~CSSFLEX/issues-cr-20160301#issue-12">Issue 13</a>）
◎
Updated §8.5 Flex Container Baselines to account for baseline sets and last-baseline alignment. (Issue 13)) 
</li>
</ul>



			</section>
			<section id="change-201604-clarify">
<h4 title=" Clarifications">明確化</h4>

<ul>

	<li id="change-2016-spatial-nav">
空間的~navigation~modeにおいて `order$p を取扱うことが許容されることを明確化した
（ <a href="~CSSFLEX/issues-cr-20160301#issue-1">Issue 1</a> ）
《`cg-2016-spatial-nav$cg（追加）》
◎
Clarify that spatial navigation modes are allowed to handle order. (Issue 1)
</li>

	<li id="change-2016-definite-3">
<a href="#definite-sizes">確定的~size／不定~size</a>
節における確定性についての追加の事例に対する相互参照を~~追加。
（ <a href="~CSSFLEX/issues-cr-20160301#issue-2">Issue 2</a> ）
《`cg-2016-definite-3$cg（追加）》
◎
Cross-reference an additional case of definiteness in §9.8 Definite and Indefinite Sizes (Issue 2)
</li>

	<li id="change-2016-auto-content-wording">
百分率による解決できない`~flex基底$値が，
`content$v:fb に~~転化されることについての言い回しを改善した。
（ <a href="~CSSFLEX/issues-cr-20160301#issue-6">Issue 6</a> ）
◎
Improve wording for how unresolveable percentage flex basis values transmute to content. (Issue 6)
《`cg-2016-auto-content-wording$cg（更新）》
</li>

	<li id="change-2016-inflexible-definite">
`~flex基底$が`確定的$である非~flexible駒の~sizeは`確定的$になることを明確化した。
（ <a href="~CSSFLEX/issues-cr-20160301#issue-8">Issue 8</a>,
<a href="~CSSFLEX/issues-cr-20160301#issue-11">Issue 11</a> ）
《`cg-2016-inflexible-definite-1$cg, `cg-2016-inflexible-definite-2$cg（追加）》
◎
Clarify that inflexible items with a definite flex basis have a definite size. (Issue 8, Issue 11)
</li>

	<li id="change-2016-reword-min-auto">
`auto$v:min 値の定義をより理解しやすい定義に言い換えた。
（ <a href="~CSSFLEX/issues-cr-20160301#issue-9">Issue 9</a> ）
《`cg-2016-reword-min-auto$cg（更新）》
◎
Reworded definition of the auto value to be easier to understand. (Issue 9)
</li>

	<li>
その他の自明な編集上の改善。
◎
Miscellaneous trivial editorial improvements.
</li>
</ul>


			</section>
		</section>
		<section id="changes-201505">
<h3 title="Changes since the 14 May 2015 LCWD">2015 年 5 月 14 日付 最終草案からの変更点</h3>


<p>
<a href="~CSSWG/css-flexbox-1/issues-lc-20150514">Disposition of Comments</a>
も用意されている。
◎
A Disposition of Comments is also available.
</p>

			<section id="change-201505-substantive">
<h4 title="Substantive Changes and Bugfixes">主要な変更点とバグ修正</h4>

<ul>
	<li id="change-2015-flex-basis-zero">
`flex$p 簡略形に対する，［
`flex-basis$p 省略-時における
<a href="#change-2012-flex-basis-zero">変更</a>
］は、~~元の `0^v に戻された
— それは、内在的~sizeの問題を解くにあたって hacky な仕方であり、
<a href="#intrinsic-sizes">内在的~size 節</a>
の正しい実装の下では，不必要であった（また 不良な結果を与えてもいた）ので。
（ <a href="~CSSWG/css-flexbox/issues-lc-20150514#issue-13">Issue 13</a> ）
《`cg-flex-basis-zero-1$cg, `cg-flex-basis-zero-2$cg（更新）》
◎
Revert flex shorthand change of omitted flex-basis back to 0, since that was a hacky way of solving an intrinsic size problem, and isn’t needed (and gives bad results) given a correct implementation of §9.9 Intrinsic Sizes. (Issue 13)
</li>

	<li id="change-2015-anonymous-fixup">
`~flex駒$を決定する際は、各~要素ごとに直接的に演算するように変更した
— その匿名~包装~boxではなく。 
（ <a href="~CSSWG/css-flexbox/issues-lc-20150514#issue-6">Issue 6</a> ）
《`cg-anonymous-fixup-1$cg, `cg-anonymous-fixup-2$cg（更新）》
◎
Changed flex item determination to operate on each element directly, and not on its anonymous wrapper box, if any. (Issue 6)
</li>

	<li id="change-2015-min-auto-intrinsic-percentages">
~boxの内容に対する百分率による~sizingは、［
~box上の `~min-width$p:auto により課される~size調整
］も織り込むものと定義した。
（ <a href="~CSSWG/css-flexbox/issues-lc-20150514#issue-3">Issue 3</a> ）
《`cg-min-auto-intrinsic-percentages$cg（更新）》
◎
Defined that any size adjustment imposed by a box’s min-width: auto is consulted when percentage-sizing any of its contents. (Issue 3)
</li>

	<li id="change-2015-intrinsic-sizing">
~flexibleでない駒を取扱うための内在的~sizingの規則を正した。
（ <a href="~CSSFLEX/issues-lc-20150514#issue-1">Issue 1</a> ）
《`cg-intrinsic-sizing$cg（更新）》
◎
Correct instrinsic sizing rules to handle inflexible items. (Issue 1).
</li>

    <li id="change-2015-intrinsic-items">
~flex容器の主軸~沿いの内在的~sizingにおける誤りを正した。
（ <a href="~CSSFLEX/issues-lc-20150514#issue-1">Issue 1</a> ）
《`cg-intrinsic-items-1$cg, `cg-intrinsic-items-2$cg（更新）》
◎
Correct errors in flex container main-axis intrinsic sizing. (Issue 1)
</li>

	<li id="change-2015-intrinsic-cross-container">
`~flex容器$の交叉軸~沿いの内在的~sizingにおける誤りを正した。
加えて、複line ~col~flex容器に対し 共通して実装されている 最小内容~sizingの経験則を指定した。
（ <a href="~CSSFLEX/issues-lc-20150514#issue-12">Issue 12</a> ）
《`cg-intrinsic-cross-container$cg（更新）》
◎
Correct errors in flex container cross-axis intrinsic sizing, and specify commonly-implemented min-content sizing heuristic for multi-line column flex containers. (Issue 12)
</li>


	<li id="change-2015-a11y-tools">
著作~toolに対する明示的な適合性の判定基準
— 作者から明示的に指示されない限り，呈示と DOM 順序との同期を保つとする —
を追加した。
《`cg-a11y-tools-1$cg, `cg-a11y-tools-2$cg（更新）》
◎
Add explicit conformance criteria on authoring tools to keep presentation and DOM order in sync unless author explicitly indicates a desire to make them out-of-sync.
</li>

	<li id="change-2015-align-self-auto">
`align-self$p ／ `justify-self$p
に対する値 `auto^v は、
`CSS-ALIGN-3$r によるこれらの~propの将来の拡張との整合性をとるため，
絶対位置の要素に対しては，そのままの値に算出されるものと定義した。
（ <a href="~CSSFLEX/issues-lc-20150514#issue-5">Issue 5</a> ）
《`cg-align-self-auto$cg（更新）》
◎
Defined that an align-self or justify-self value of auto computes to itself on absolutely-positioned elements, for consistency with future extensions of these properties in [CSS-ALIGN-3]. (Issue 5)
</li>

	<li id="change-2015-percentage-margins">
百分率による
~margin／~padding
は、元の，個々の軸に相対的とするよう戻した。
《`cg-percentage-margins$cg（更新）》
◎
Revert change to make percentage margins and padding relative to their own axes; instead allow both behaviors. (Issue 11, Issue 16)
</li>

    <li id="change-2015-min-max-constraint">
~flex駒の~sizingにおける［
最小内容／最大内容
］拘束の取扱いを追加した。
《`cg-min-max-constraint$cg（追加）》
◎
Handle min/max constraints in sizing flex items.
</li>

    <li id="changes-2015-first-fragment">
~flex容器の断片化 規則における折衝を正した。
以前の定義では、どの事例でも
`break-inside$p に対しては暗黙に `avoid^v の挙動とされていた。
（<a href="~CSSFLEX/issues-lc-20150514#issue-5">Issue 5</a>）
《`cg-first-fragment$cg（更新）》
◎
Correct negation in flex container fragmentation rule: previous definition implied break-inside: avoid behavior in all cases. (Issue 5)
</li>

</ul>

			</section>
			<section id="change-201505-clarify">
<h4 title="Clarifications">明確化</h4>
<ul>
	<li>
小さな編集上の改善と例の中の誤りの修正。
◎
Miscellaneous minor editorial improvements and fixes to errors in examples. 
</ul>

			</section>
		</section>
	</section>

</main></div><!-- id="MAIN" -->

	<section id="conformance">
<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="css-common-ja.html#conformance" >CSS 日本語訳 共通ページ</a>
に委譲
】</p>
	</section>


	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>


<dl>

	<dt>[CSS-ALIGN-3]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Box Alignment Module Level 3. 18 December 2014. WD.</dd>
	<dd>http://dev.w3.org/csswg/css-align/</dd>

	<dt>[CSS-CASCADE-4]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-cascade/</dd>

	<dt>[CSS-OVERFLOW-4]</dt>
	<dd>CSS Overflow Module Level 4</dd>
	<dd>https://drafts.csswg.org/css-overflow-4/</dd>

	<dt>[CSS-POSITION-3]</dt>
	<dd>CSS Positioned Layout Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-position-3/</dd>

	<dt>[CSS-PSEUDO-4]</dt>
	<dd>Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. 15 January 2015. WD.</dd>
	<dd>http://dev.w3.org/csswg/css-pseudo-4/</dd>

	<dt>[CSS-SIZING-3]</dt>
	<dd>CSS Intrinsic &amp; Extrinsic Sizing Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-sizing-3/</dd>

	<dt>[CSS-SIZING-4]</dt>
	<dd>CSS Intrinsic &amp; Extrinsic Sizing Module Level 4</dd>
	<dd>https://drafts.csswg.org/css-sizing-4/</dd>

	<dt>[CSS-TEXT-3]</dt>
	<dd>Elika Etemad; Koji Ishii. CSS Text Module Level 3. 10 October 2013. LCWD.</dd>
	<dd>http://dev.w3.org/csswg/css-text-3/</dd>

	<dt>[CSS-VALUES]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 11 June 2015. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-values/</dd>

	<dt>[CSS21]</dt>
	<dd>Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC.</dd>
	<dd>http://www.w3.org/TR/CSS2</dd>

	<dt>[CSS3-BREAK]</dt>
	<dd>Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 3. 14 January 2016. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-break/</dd>

	<dt>[CSS3-DISPLAY]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 15 October 2015. WD.</dd>
	<dd>http://dev.w3.org/csswg/css-display/</dd>

	<dt>[CSS3-SIZING]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Intrinsic &amp; Extrinsic Sizing Module Level 3. 27 September 2012. WD.</dd>
	<dd>http://www.w3.org/TR/css3-sizing/</dd>

	<dt>[CSS3-WRITING-MODES]</dt>
	<dd>Elika Etemad; Koji Ishii. CSS Writing Modes Level 3. 15 December 2015. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-writing-modes-3/</dd>

	<dt>[CSS3COL]</dt>
	<dd>Håkon Wium Lie. CSS Multi-column Layout Module. 12 April 2011. CR.</dd>
	<dd>http://www.w3.org/TR/css3-multicol</dd>

	<dt>[CSS3UI]</dt>
	<dd>Tantek Çelik; Florian Rivoal. CSS Basic User Interface Module Level 3 (CSS3 UI). 7 July 2015. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-ui/</dd>

<!-- 
	<dt>[RFC2119]</dt>
 -->
</dl>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>


<dl>
	<dt>[HTML5]</dt>
	<dd>Ian Hickson; et al. HTML5. 28 October 2014. REC.</dd>
	<dd>http://www.w3.org/TR/html5/</dd>
</dl>

		</section>
	</section>
	<section id="index">
<h2 title="Index">索引</h2>

<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>
	</section>
	<section id="property-index">
<h2 title="Property index" data-cycling=".propdef">プロパティ索引</h2>

<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>

	</section>
	<section id="issues-index">
<h2 title="Issues index" data-cycling=".issue">課題索引</h2>

<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>

	</section>

</body>
</html>

<!-- 

flexが効き過ぎた:over-flexed
取得retrieve:~
解消fixing
後方互換のback-compat
~~相当にnoticeably
不用意:accidental:~
位置付けをnormative status
戻したRestore
消え去る disappearする
公式formula
基になるused to produce
~~実際 indeed
-->
