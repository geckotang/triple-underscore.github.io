<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Loading Web pages（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/browsers.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'browsers',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170223 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		sc: 'scheme',
		E: 'error',
		h: 'header',
		sl: 'js-slot',
		jI: 'js-intrinsic',
		jA: 'abstract',
		U: 'code-point',
		v: 'value',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		sc: 'code',
		et: 'code',
		h: 'code',
		E: 'code',
		sl: 'span',
		jI: 'span',
		jA: 'span',
		U: 'span',
		v: 'code',
		V: 'var',
		i: 'i',
		sub: 'sub',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var ctx_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[\w~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	if(indicator === '@') {
		ctx_ifc = '#dom-' + key.toLowerCase() + '-';
	}
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text = text.replace(/_/, ':');
	break;
case 'sbox': // sandboxing flags
	text = '閲覧文脈~sandbox化( ' + key + ' )~flag';
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'sl': // JS internal slot
	text = '[[' + key + ']]';
	break;
case 'jI': // JS intrinsic objects
	text = '%' + key + '%';
	break;
case 'bP': //
	text = key + '<code>BarProp</code> ~obj';
	break;
case 'U': // Unicode code point
	text = 'U+' + key;
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">


此れ:<b>これ°</b>
API:
ASCII:
	COLON:
DOM:
	FULL-STOP:
HTML:
Unicode:
Web:
block::::ブロック
bookmark:
browser::::ブラウザ
buffer::::バッファ
bug::::バグ
code::::コード
comma::::カンマ
command::::コマンド
data::::データ
database::::データベース
error::::エラー
filter::::フィルタ
flag::::フラグ
clear:
cloned:
game::::ゲーム
mode::::モード
logic::::ロジック
index::
inline::::インライン
item::::アイテム
key::
keyword::::キーワード
link::::リンク
list::::リスト

group::::グループ
literal::::リテラル
	主な／主となる~main
mark::::マーク
open:
	＊~opener:
選択肢:option:~:::オプション

	切離す:sever する／Lose:切り離す
pointer::::ポインタ
pointing::::ポインタ指示
被support:supported::被 support:被サポート
prop:property:::プロパティ
prototype-chain:prototype chain
pull:
push:
responsible:

source::::ソース

	srcdoc:
storage::::ストレージ


	表:~table
timer::::タイマー
token::::トークン
underscore:
	~~益はないunfortunate:

web::
zero::::ゼロ
代入:assignment:~

	ある種の:certain:~
上書き:override:~
上書state:state override:上書き state
state:
下層の:underlying:~
不在:absent:~
不能化-:disable:~





	●仕様（動詞
伝える:inform する:~
依存-:depend:~
依拠-:rely:~
奨励-:encourage:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
指定-:specify:~
	unspecified
指示-:indicate:~
挙動:behavior:ふるまい
提供-:provide:~
提供0-:offer:提供
最適化:optimization:~
望む:wish する:~
	欲-:desire:~
決定-:determine:~
波及-:influence:~
濫用-:abuse:~
無視-:ignore:~
相違-:differ:~
省略-:omit:~
確保-:ensure:~
確認-:confirm:~
示唆-:suggest:~
策定中:underdefined:~
統合-:integrate:~
解放-:free:~
要求-:require:~
要約-:summarize:~
見做され:assume され:~
見做す:assume する:~
解釈-:interpret:~
記述-:describe:~
記述:description:~
試みな:attempt しな:~
試みて:attempt して:~
試みる:attempt する:~
試み:attempt:~
試験-:test:~
説明-:explain:~
達成-:achieve:~
選好:preference:~
避ける:avoid する:~
働く:work する:~
利用-:use:~
再利用:reuse:~
利用者:user:~
制約-:restrict:~
制約:restriction:~
制限-:limit:~
	食い違いが生じる:disagree
影響-:affect:~
意味-:mean:~
意味:meaning:~
意図-:intend:~
意図的:intentional:~
拒否-:refuse:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
結付けて:associate して:結び付けて
取扱う:handle する:取り扱う
取扱って:handle して:取り扱って
	取扱い:handling:取り扱い
辞退-:decline:~
督促-:urge:~
見なさ:consider さ:~
	考える:consider する:~
	あたられ:consult

	●仕様
UA:user agent:UA
approach::::アプローチ
support::::サポート
system::::システム
tool::::ツール
platform::::プラットフォーム
algo:algorithm:::アルゴリズム
app:application:::アプリ
model::::モデル
metaphor::::メタファー
customize::::カスタマイズ
well-defined:
一意:unique:~
一般:general:~
不完全な:imperfect:~
不正:incorrect:~
不透明な:opaque:~
不透明:opaque:~
不適切:inappropriate:~
事例:case:~
事実:fact:~
事由:reason:~
互換性:compatibility:~
互換:compatible:~
仕事:work:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
代表的:typical:~
作者:author:~
便宜性:facilities:~
基礎的な:fundamental:~
	場合によっては:possibly:~
実際:actual:~
	actually:~
既存の:existing:~
既定の:default:~
既定:default:~
	最新の:newest:~
有意義な:meaningful:~

正確0:accurate:正確
歴史的:historical:~
概して:typical に:~
概念:concept:~

標準の:standard:~
活動:activity::~::アクティビティ
特別:special:~
特定0の:particular:ある特定の
特徴:characteristics:~
特定の:specific:~
特色機能:feature:~
状況:situation:~
目的0:purpose:目的
直接的:direct:~
	やりとり:interact:~
通例的:usual:~
	通常は:normal では:~
適用-:apply:~
	適用し得る:applicable:
方式:manner:~
明示的:explicit:~
暗黙の:implied:~
漠然:nebulous:~
本質的:essential:~
条件:condition:~
簡便:convenient:~
体験:experience:~
能:ability:~
自明:trivial:~
要件:requirements:~
規範的:normative:~
適切:appropriate:~
共通の:common:~
可用:available:~
効果:effect:~
問題:problem:~
所与の:given:与えられた
下位手続き:substeps:~
手続き:steps:~
段:step:~
助言的:advisory:~
適格:eligible:~
手動:manual:~
一貫した:consistent な:一貫性のある
旧来の:legacy:~
理由:reason:~
適合性:conformance:~
非公式:informal:~
	あるいは:alternately
	自身:itself:~
	常に:always:~
	当の:in question:~
	とは限らない:necessarily:~
	必要-:need:~

	●network／保安
CORS:
	CORS-cross-origin
	CORS-same-origin
	IPv4
	IPv6
HTTP:
HTTP_S:HTTP(S) 
IP:
HTTPS:
cannot-be-a-base-URL::基底 URL 不可用
address::::アドレス
cache::::キャッシュ
entry::::エントリ
逃れる:escape:~:::エスケープする
allowX:allow〜
fetch:
service-worker:service worker
URL:
url:
record::::レコード
domain::::ドメイン
下位domain:subdomain:::下位ドメイン
host::::ホスト
port::::ポート
username::::ユーザ名
password::::パスワード
scheme::::スキーム
hostname::::ホスト名
navigate::::ナビゲート
	navigating:
navi:navigation:::ナビ
navigator::::ナビゲータ
network::::ネットワーク
path::::パス
protocol::::プロトコル
query::::クエリ
referrer::::リファラ
server::::サーバ
serve::::サービス供与
site::::サイト
transaction::::トランザクション
unload::::
load::::
unloading:
suffix:

保安化-:secure に::~:セキュア化
保安:security::~:セキュリティ
保安的:secure::~:セキュア
session::::セッション
sandbox::::サンドボックス
sandboxed:::sandbox 化:サンドボックス化
sandboxing:::sandbox 処理:サンドボックス処理
施策:policy::~:ポリシー
暗号化-:encrypt:~
第三者主体:third-party:~
素片:fragment::~::フラグメント
要請:request::~::リクエスト
証明書:certificate:~
資源:resource::~:リソース
追跡-:track:~
送信-:send:~
通信-:communicate:~
隔離-:isolate:~
非冪等:non-idempotent:~
保護-:protect:~
保護:protection:~
信用-:trust:~
	信用できない:untrusted
偽装:spoof:~
敵対的:hostile:~
指令:directive::~::ディレクティブ
基底:base:~
媒体:media::~:メディア
権限:authority:~
基本:basic:~
主体:party:~
阻止-:block::~::ブロック
強制-:force:~
強制:forced:~
抹消-:evict:~
	eviction
不許可に:disallow:~
許可済み:permitted:~
許可-:permit:~
登録可能な:registrable:~

	●環境 ／ 閲覧
id:
環境:environment:~
大域:global::~::グローバル
設定子:setter:~
設定群:settings:~
現在:currently:~
現在の:current:~
状態:state:~
視野:scope:~
遷移:transition:~
関連する:relevant な:~
予約済み:reserved:~
探索-:search:~
転送-:transfer:~

target:
top-level::::トップレベル
delta:
一足飛びに:jump して:~
jump::::ジャンプ
閲覧文脈:browsing context::~
補助:auxiliary::~
閲覧:browsing::~
互関係:related:互いに関係する
類似生成元の:similar-origin:origin も類似する:生成元も類似する::オリジンも類似する
生成元:origin::~::オリジン
非同一生成元:cross-origin::~::クロスオリジン
同一生成元:same origin::~::同一オリジン
直接到達可能:directly-reachable:~
破棄-:discard:~

近しい:familiar with:~
再読込み:reload::再読み込み::リロード
読込まれ:load され::読み込まれ::ロードされ
読込む:load する::読み込む::ロードする
読込み:loading::読み込み::ローディング
読込:load::読み込み::ロード
読込後:post-load::読み込み後
成分:component:~
成分組:tuple:~
成熟-:mature:~
所在:location:~
頁:page:::ページ
	一~頁だけ:one-page
	走査-:traverse:~
走査する:traverse する::辿る
走査した:traverse した::辿った
走査され:traverse され::辿られ
走査:traversal::辿り
非相対:non-relative:~
入子に:nest:入れ子に
入子の:nested:入れ子の
族:family:~
回復可能:salvageable:~

埋込まれ:embed され:埋め込まれ
埋込む:embed する:埋め込む

閉じる:close する::~
閉じた:close した::~
閉じら:close さ::~
閉じれ:close でき::~
	閉じるとき~closing:
開く:open する::~
開いた:open した::~
開いて:open して::~
開かれ:open され::~
開こう:open しよう::~
	開ける:~openでき::~

子:child:~
親:parent:~
子孫:descendant:~
容器:container:::コンテナ
木:tree::~::ツリー
根:root::~::ルート
文書:document:~

作動中の:active な::~::アクティブな
作動中:active::~::アクティブ
作動化:activation::~::アクティブ化
作動化-:activate::~::アクティブ化
	再び作動化-:reactivate

履歴:history::~
先進する:go forward する:先へ進む
後戻-:go back:後戻り
	backward:~
	戻る:back:~
	進む:forward:~
片付け:cleanup:~
中止-:abort:~

	●IDL / js / event
collection::::コレクション
garbage::::ガーベジ
収集:collection::~::コレクション
handler::::ハンドラ
exotic:
現任の:incumbent:~
realm:
Realm:
宛先:target::~
event-loop:event loop:::イベントループ
event::::イベント
field::::フィールド
内部:internal:~
内部的:internal:~
slot::::スロット
method::::メソッド
IDL:
JS:JavaScript
member::::メンバ
access::::アクセス
accessor::::アクセサ
call::
module::::モジュール
instance::::インスタンス
interface::::インタフェース
listener::::リスナ
lock::::ロック
map:
node::::ノード
shadow:
obj:object:::オブジェクト
script::::スクリプト
scripting::::スクリプト処理
task::::タスク
源:source::~::ソース
window::
worker::

抽象:abstract:~
例外:exception:~
例外投出あり:rethrow any exceptions:~
取得子:getter:~
列挙不可:unenumerable:~
	呼び出し:invocation:
	呼出ing:invoking:~
呼出した:invoke した:呼び出した
呼出され:invoke され:呼び出され
被呼出時:被 invoke 時:~
初期:initial:~
初期化-:initialize:~

並列的:parallel:~
投出:throw:~
	~~投出:raise
発火-:fire:~
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ
待行列:queue::待ち行列::キュー
待機-:wait:~
配送-:dispatch:~
記述子:descriptor:~
強い:strong な:~
引数:argument:~
属性:attribute:~
配列:array:~
普通の:ordinary:~
包装-:wrap:~

	●UI
UI:user interface:UI
scrollbar:
toolbar:
location-bar:
menu-bar:
personal-bar:
scroll-bar:
status-bar:
animate::::アニメート
applet:
	around:
button::::ボタン
click::::クリック
dialog::::ダイアログ
drop-down:drop down:::ドロップダウンメニュー
focus::::フォーカス
form::::フォーム
frame::::フレーム
media::::メディア
resize::::リサイズ
menu::::メニュー
modal::::モーダル
plugin::::プラグイン
popup:
prompt:
scroll::::スクロール
scrolling:
tab::::タブ
	~tab付き:tabbed
title::::タイトル
text::::テキスト
動画:video::~::ビデオ
書字方向性:directionality:~
書字:writing:~
方位:orientation:~
画像:image:~
聴覚:aural:~
装置:device:~
表示-:display:~
外縁:outer:~
内縁:inner:~

可視の:visible:~
可視性:visibility:~
手入力-:enter:~
form::::フォーム
control::::コントロール
	制御
Ctrl:<kbd><kbd>Control</kbd></kbd>
	Control key
呈示-:present:~
呈示:presentation:~
描画:rendering:~


	●未分類（動詞
作成-:create:~
作成:creation:~
作成時の:creation:~
作成元:creator:~
作成元の:creator:~
保つ:keep する:~
再構築-:reconstruct:~
予約-:reserve:~
伝播-:propagate:~
給-:supply:~
出自の:originating:~
公開-:expose:~
共有-:share:~
保持-:hold:~
配備済みの:deployed:~
再設定-:reset:~
処理-:process:~
処理:processing:~
分割-:split:~
到達-:reach:~
再処理-:reprocess:~
変異-:mutate:~
	変異しない:immutable
動作-:act:~
動作:action:~
動作者:actor:~
区切って:separate して:~
協調-:coordinate:~
参照-:reference:~
参照:references:~
反映-:reflect:~
取得-:get:~
	getting
取消す:cancel する::取り消す::キャンセルする
可能0:possible:可能
可能化-:enable:~
可能化:enabled:~
合致-:match:~
包含-:contain:~
増加-:increase:~
変化-:change:~
変更-:change:~
失敗-:fail:~
失敗:failure:~
存在-:exist:~
実行-:execute:~
実行:execution:~
導出-:derive:~
差挟む:interleave する:差し挟む
形成-:form:~
復旧-:restore:~
復旧:restoration:~
拡充-:populate:~
持続化-:persist:~
持続的:persisted:~
挿入-:insert:~
接続:connection:~
操作-:manipulate:~
操作:manipulation:~
改変:modification:~
改変-:modify:~
更新-:update:~
指名-:designate:~
格納-:store:~
検査-:check:~
検査:check:~
比較-:compare:~
比較:comparison:~
演算:operation:~
環境設定-:configure:~
環境設定:configuration:~
生成-:generate:~
生産-:produce:~
継承-:inherit:~
表現-:represent:~
表現:representation:~
設定-:set:~
置換-:replace:~
置換え:replacement:置き換え
見出さな:find しな:~
見出され:find され:~
見出す:find する:~
見出して:find して:~
許容-:allow:~
試行-:try:~
誘発-:trigger:~
読取る:read する:読み取る
書込む:write する:書き込む
走せず:run せず:走らせず
走らさ:run さ:走らさ
走らす:run する:走らせる
走らせ:run し:~
走って:run して:~
起動-:initiate:~
追加-:add:~
	追加の:additional
	加えて:in addition
付加-:append:~
遂行-:perform:~
遅延:delay:~
	遅延~中:delaying:~
選定-:select:~
選定:selection:~
	連結-:concatenate:~
進行中:ongoing:~
関係:relation:~
関係-:relate:~
開始-:start:~
防止-:prevent:~
除去-:remove:~
隠す:hide する:~
順序:order:~
順序付けら:order さ:~
提出:submission::~
在する:present する:在る
対応関係:mapping:~
	対応付け:map
集析:mining::~::マイニング
複製:copy:~
	始-:begin:~
	孕む:involve する:~
	絡んで:involve する:~
	課す:place:~
	繰返-:repeat:~
	選んだ／選ばれ:pick
	~~意図するものではない:not meant
	抵触する:hit
	代替わりする:bring 〜 into being to take the place of
	調べ-:examine
	述べ-:describe
	元々利用者から渡された:passed around by users
	切る:severe
	紛らわしい所がある:misleading
	要注意:extra care
	引き受ける:take care
	〜に基づく:based
	含-:include
	含めて:including
	あてがう:assign
	もたらす:lead
	対応-:correspond
	後続-／従う:follow
	得-:obtain
	-:prefixed
	生-:occur
	示す:show
	緩めら:relax さ
	緩め方:relaxing
	見よ:see
	起こる:happen
	返す:return
	選ばれ
	選ぶ:choose する
	除-:except
	呼応して:in-response-to
	存続させ続ける~keep both alive
	塗りなおす:repaint:~
	bookmarking
	de-aliasing
	grouping
	having
	乗っ取らせ:hijack
	再生:play
	meant
	購入:purchase
	入れる／put
	said
	束ねられ:tie
	取出して:pull して
	与-:give
	渡-:pass

	●未分類

offline::::オフライン
種別:type:~

位置:position:~
余分の:extra:~
	押され続け:hold〜down
値:value:~
先祖:ancestor:~
	先頭の:leading:~
入力:input:~
screen::::スクリーン
全部的:full:~
共同:joint:~
内側:inside:~
内容:content:~
過去互換:quirks::~
準備済み:ready::~
出力:output:~
動的:dynamic:~
	区別できない:indistinguishable:~
	域:area:~
即時:immediate:~
単独の:single:~
単純:simple:~
同一:identical:~

同期:synchronization:~
同等:equal:~
同等性:equality:~
同胞:sibling:~

名:name:~
名前:name:~
有名:named:~

和集合:union:~
型:type:~
妥当な:valid:~
妥当:valid:~
	妥当でない:invalid:~
完全:complete:~
	まったく:complete
実効:effective:~
宣言的:declarative:~



	座標:coordinate:~
式:expression:~
成功裡:successful:~
	~~手入力:type:~
情報:information:~
担当の:responsible:~
	責を負う:responsible:~
	担当して
接尾辞:suffix:~
推移閉包:transitive closure:~
	数:number:~
整数:integer:~
文脈:context:~
新たな:new:~
時系列的:chronological:~


有順序:ordered:~
空白:whitespace:~
文字:character:~
colon::::コロン
文字列:string:~
大小無視:case-insensitive:~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
直列化-:serialize::~::シリアライズ
直列化:serialization::~::シリアル化
直列形の:serialized::~::シリアル形の
直列化器:serializer::~::シリアライザ
逆直列化-:deserialize::~::逆シリアライズ
識別子:identifier:~
相対的:relative:~
空:empty:~
符号化方式:encoding::~::エンコーディング

段落:paragraph:~
	種類:kind:~
等価:equivalent:~
範囲:range:~
精確:precise:~
	精確を期すため:for precision:~
絶対:absolute:~
自前の:own:~
自動的:automatic:~
自動:automatic:~
要素:element:~

規則:rule:~
角括弧:square-bracket:~
	複数の:multiple:~

通貨:currency:~
連列:sequence:~
	順々に／連続する:consecutive
連続的:contiguous:~
重複:duplicate:~
長さ:length:~
関数:function:~
集合:set:~
静的:static:~
	同様:similar:~
近過去:recent:~
最近の:latest:~
mode::::モード
	~blocker
対象0:subject:対象

	因り:due to
	結果:result
	結果になる:end-up
	結果の:resulting
	見かけ:look
	壊れやすい~brittle
	分ける:divide
	させ易く:help


	~vary
	~~協調する:if they do the same thing
	等し:equal


	組にして:couple
	〜の代わりに:instead
	あらためて:afresh
	しかしながら，:however
	したがって:therefore
	したがって:thus
	すでに:already
	べき:should

	より高速:faster
	介:via
	例:example
	最も小さい:smallest
	最も近傍の:nearest
	最も近過去に:most-recently
	正確に／だけに限られる:exactly
	求め:want
	決して:never
	特に:in particular
	節:section
	通:through
	FIFO
	LIFO
	とは言え:Having said that
	~Location~obj設定子により~Location-object-setter
	~Location~objにより:~Location-object
	と違って:contrary to
	近く:closely
	“お気に入り”:favorite
	~force-close
	更には~furthermore
	hosting
	時間:hour
	~~記憶:memory
	およそ:likely
	線:line
	一本道:linear
	long:
	非:non:
	ok:
	~optionally
	~per
	please
	point
	potentially
	立て続けに:rapid succession
	~respect
	~respective:
	ten:
	naïve:素朴
	いくぶんsomewhat
	〜から:perspective
	できるだけ早く:as soon as possible
	もっぱら:purely
	単に:merely
	小さな:minor
	平坦:flat
	当面の間は:in the meantime
	形:form
	様々な程度:varying degrees
	潜在的に:potentially
	組:tuple
	にもかかわらず:nonetheless
	所与の時点:at any moment
	頻繁過ぎる:too-frequent
	巨大過ぎる:over-large
	本当の:real
	明白な:clear な
	寄せ集め:mishmash
	よい:ok
	~~実際，:Indeed

	●指示語
	末尾／尾部:end
	最初の:first
	最後の:last
	-:subsequent
	後者:latter
	ほとんど:most
	いくつかの:several
	この:this
	これらの:these
	すべての:all
	その:that
	そのような:such
	それら:they
	それらの:their
	それらの:those
	それらを:them
	もの:thing
	一部:part of
	上:above
	下:below
	両者:both
	二つ:two
	二番目の:second
	他の:other
	他の場合:otherwise
	以前の／一つ前の:previous
	任意に:arbitrarily
	任意の:arbitrary
	何か:something
	依然として:still
	個々の:individual
	元々:originally
	元の:original
	再度:again
	別々の:separate
	別の:another
	別個の:distinct
	前:before
	十分:enough
	各:each
	同じ:same
	後:after
	新たに:newly
	更なる:further
	次:next
	異なる:different
	種々の:various
	等々:etc
	あらゆるもの:everything
	全体:whole
	後で／:later
	最も早期の:earliest
	最新の:latest
	に類するもの:or some similar interface concept
	隔たれた:apart from
	直に:straight
	時点:moment
	直上／直下に:immediately below or after

</script>

<!--%id -->
<script type="text/plain" id="_original_id_map">
	number-of-document-tree-child-browsing-contexts:number-of-child-browsing-contexts
</script>



<!--% 置換データ -->
<script type="text/plain" id="words_table1">
HTMLWPROXY:HTML-windowproxy-ja.html

	Assert:<b>Assert</b>

document-domain:<code>document.domain</code> 
length0:length
location0:location
	sub.生成元
	oRigin:<sub><a href="#same-origin">生成元</a></sub>
	sub.~domain:#same-origin-domain
	dOmain:<sub>~domain</sub>
iframe: <code class="element">iframe</code> 
srcdoc: <code class="attr">srcdoc</code> 
Location:<code>Location</code> 
</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">

	●IDL Interface/Dictionary
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
	~HTMLconform#domhighrestimestamp
I.ApplicationCache:~HTML5/browsers.html#applicationcache
I.BarProp:#barprop
I.Document:~HTMLdom#document
I.Element:~DOM4#interface-element
I.Event:~DOM4#interface-event
I.EventHandler:~WAPI#eventhandler
I.GlobalEventHandlers:~WAPI#globaleventhandlers
I.WindowEventHandlers:~WAPI#windoweventhandlers
I.EventInit:~DOM4#dictdef-eventinit
I.EventSource:~HTMLcomms#eventsource
I.EventTarget:~DOM4#interface-eventtarget
I.FrameRequestCallback:#framerequestcallback
I.History:#history-3
I.HTMLCollection:~DOM4#interface-htmlcollection
I.Location:#location
I.MessageEvent:~HTMLcomms#messageevent
I.Navigator:~HTMLnavigator#navigator
I.ScrollRestoration:#scrollrestoration
I.Window:#window
I.WindowProxy:#windowproxy
I.object:~WEBIDL#idl-object

I.CustomElementRegistry:~HEcustom#customelementregistry
I.DOMStringList:~HTMLINFRA#dom-location-ancestororigins

	●Error
E.SecurityError:~WEBIDL#securityerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror
E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror


	■#dom-member
l.auto:#dom-scrollrestoration-auto
l.manual:#dom-scrollrestoration-manual


m.alert:~HTMLGAPI#dom-alert
m.ancestorOrigins:#dom-location-ancestororigins
m.applicationCache:~HTML5/browsers.html#dom-applicationcache
m.assign:#dom-location-assign
m.back:#dom-history-back
m.blur:~HTMLinteraction#dom-window-blur
m.cancelAnimationFrame:~HTMLGAPI#dom-window-cancelanimationframe
m.close:#dom-window-close
m.closed:#dom-window-closed
m.confirm:~HTMLGAPI#dom-confirm
m.createDocument:~DOM4#dom-domimplementation-createdocument
m.customElements:~HEcustom#dom-window-customelements
m.defaultView:#dom-document-defaultview
m.document.domain:#dom-document-domain
m.document.open:~HTML5/webappapis.html#dom-document-open
m.document:#dom-document-2
m.domain:#dom-document-domain
m.Document.domain:#dom-document-domain
m.external:~HTML5/webappapis.html#dom-external
m.focus:~HTMLinteraction#dom-window-focus
m.forward:#dom-history-forward
m.frameElement:#dom-frameelement
m.frames:#dom-frames
m.getter:#dom-window-nameditem
m.go:#dom-history-go
m.hash:#dom-location-hash
m.history.state:#dom-history-state
m.history:#dom-history
m.host:#dom-location-host
m.hostname:#dom-location-hostname
m.href:#dom-location-href
m.isTrusted:~DOM4#dom-event-istrusted
m.length:#dom-history-length
m.~length0:#dom-length
m.localStorage:webstorage.html#dom-localstorage
m.location.reload:#dom-location-reload
m.location:#dom-location
m.~location0:#dom-document-location
m.locationbar:#dom-window-locationbar
m.menubar:#dom-window-menubar
m.name:#dom-name
m.navigator:~HTMLnavigator#dom-navigator
m.open:#dom-open
m.opener:#dom-opener
m.opener:#dom-opener
m.origin:#dom-location-origin
m.parent:#dom-parent
m.pathname:#dom-location-pathname
m.personalbar:#dom-window-personalbar
m.port:#dom-location-port
m.postMessage:~HTMLcomms#dom-window-postmessage
m.print:~HTMLGAPI#dom-print
m.prompt:~HTMLGAPI#dom-prompt
m.protocol:#dom-location-protocol
m.pushState:#dom-history-pushstate
m.reload:#dom-location-reload
m.replace:#dom-location-replace
m.replaceState:#dom-history-replacestate
m.requestAnimationFrame:~HTMLGAPI#dom-window-requestanimationframe
m.requestFullscreen:https://fullscreen.spec.whatwg.org/#dom-element-requestfullscreen
m.getUserMedia:https://w3c.github.io/mediacapture-main/#dom-mediadevices-getusermedia
m.scrollRestoration:#dom-history-scroll-restoration
m.scrollbars:#dom-window-scrollbars
m.search:#dom-location-search
m.self:#dom-self
m.state:#dom-history-state
m.status:#dom-window-status
m.statusbar:#dom-window-statusbar
m.stop:#dom-window-stop
m.toolbar:#dom-window-toolbar
m.top:#dom-top
m.visible:#dom-barprop-visible
m.window.alert:~HTMLGAPI#dom-alert
m.window.confirm:~HTMLGAPI#dom-confirm
m.window.print:~HTMLGAPI#dom-print
m.window.prompt:~HTMLGAPI#dom-prompt
m.window.open:#dom-open
m.window:#dom-window

m.document.location:#dom-document-location
m.window.location:#dom-location

l.HTMLDocument:#htmldocument

	●event
et.abort:~HTMLindex#event-abort
et.beforeunload:~HTMLindex#event-beforeunload
et.click:~UIEVENTS#event-type-click
et.hashchange:~HTMLindex#event-hashchange
et.load:~HTMLindex#event-load
et.offline:~HTMLindex#event-offline
et.online:~HTMLindex#event-online
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow
et.popstate:~HTMLindex#event-popstate
et.resize:~CSSOMVIEW#eventdef-window-resize
	＊~HTMLconform#event-resize
et.unload:~HTMLindex#event-unload

	●要素
e.a:~HEtextlevel#the-a-element
e.div:~HEgrouping#the-div-element
e.body:~HEsections#the-body-element

e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.title:~HEmetadata#the-title-element

e.area:~HEimages#the-area-element
e.audio:~HTMLemb#the-audio-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.embed:~HEembed#the-embed-element
e.object:~HEembed#the-object-element
e.video:~HTMLemb#the-video-element

e.input:~HEinput#the-input-element
e.form:~HEforms#the-form-element
e.textarea:~HEforms#the-textarea-element

e.script:~HEscripting#the-script-element

e.frame:~HTML5/obsolete.html#frame
e.frameset:~HTML5/obsolete.html#frameset
e.applet:~HTML5/obsolete.html#the-applet-element


	●内容属性
a.dir:~HTMLdom#the-dir-attribute
a.href:~HTMLlinks#attr-hyperlink-href
a.manifest:~HEmetadata#attr-html-manifest
a.name:~HTML5/obsolete.html#attr-a-name
a.off:~HTMLforms#attr-fe-autocomplete-off
	a.src:~HEembed#attr-embed-src
	a.src:~HEembed#attr-iframe-src
	a.src:~HEimages#attr-img-src
	a.src:~HTMLemb#attr-media-src
a.type:~HEinput#attr-input-type
a.autoplay:~HTMLemb#attr-media-autoplay
a.sandbox:~HEembed#attr-iframe-sandbox
a.seamless:~HEembed#attr-iframe-seamless
a.target:~HTMLlinks#attr-hyperlink-target
a.id:~HTMLdom#the-id-attribute


v.allow-popups:#attr-iframe-sandbox-allow-popups
v.allow-top-navigation:#attr-iframe-sandbox-allow-top-navigation
v.allow-top-navigation-by-user-activation:#attr-iframe-sandbox-allow-top-navigation-by-user-activation
v.allow-same-origin:#attr-iframe-sandbox-allow-same-origin
v.allow-forms:#attr-iframe-sandbox-allow-forms
v.allow-pointer-lock:#attr-iframe-sandbox-allow-pointer-lock
v.allow-scripts:#attr-iframe-sandbox-allow-scripts
v.allow-popups-to-escape-sandbox:#attr-iframe-sandbox-allow-popups-to-escape-sandbox
v.allow-modals:#attr-iframe-sandbox-allow-modals
v.allow-orientation-lock:#attr-iframe-sandbox-allow-orientation-lock
v.allow-presentation:#attr-iframe-sandbox-allow-presentation

	●code
	m.onclick
sc.javascript_:~NAVI#javascript-protocol
sc.data_:https://tools.ietf.org/html/rfc2397#section-2
sc.about_blank:~HTMLconform#about:blank

sl.Window:~HTMLWPROXY#concept-windowproxy-window
sl.GetOwnProperty:~HTMLWPROXY#windowproxy-getownproperty

	application/atom+xml:~HTMLindex#application/atom+xml
	application/json:~HTMLindex#application/json
	mailto::https://tools.ietf.org/html/rfc6068#section-2
	multipart/x-mixed-replace:iana.html#multipart/x-mixed-replace
	text/cache-manifest:iana.html#text/cache-manifest
	text/css:~HTMLindex#text/css
	text/html:iana.html#text/html
	text/json:~HTMLindex#text/json
	text/plain:https://tools.ietf.org/html/rfc2046#section-4.1.3
	text/vtt:~HTMLindex#text/vtt

	●
~window:#_window
文書:#_document
disown:#disowned-its-opener

有名~obj:#dom-window-nameditem-filter
有名~要素:#_named-element
要素~名:#_element-name
文書~木に属する子~閲覧文脈~名~prop集合:#document-tree-child-browsing-context-name-property-set

	●sandbox
~sandbox用~flag集合:#sandboxing-flag-set
作動中の~sandbox用~flag集合:#active-sandboxing-flag-set
強制~sandbox用~flag集合:#forced-sandboxing-flag-set
~popup~sandbox用~flag集合:#popup-sandboxing-flag-set
~iframe~sandbox用~flag集合:#iframe-sandboxing-flag-set
~sandboxingを実装する:#implement-the-sandboxing
~sandbox用~指令を構文解析する:#parse-a-sandboxing-directive

sbox.~document-domain:#sandboxed-document.domain-browsing-context-flag
sbox.~form:#sandboxed-forms-browsing-context-flag
sbox.~navi:#sandboxed-navigation-browsing-context-flag
許可済み~navigator:#one-permitted-sandboxed-navigator
sbox.~plugin:#sandboxed-plugins-browsing-context-flag
sbox.~pointer~lock:#sandboxed-pointer-lock-browsing-context-flag
sbox.~script:#sandboxed-scripts-browsing-context-flag
sbox.非~利用者~作動化~top-level~navi:#sandboxed-top-level-navigation-without-user-activation-browsing-context-flag
sbox.利用者~作動化~top-level~navi:#sandboxed-top-level-navigation-with-user-activation-browsing-context-flag
sbox.生成元:#sandboxed-origin-browsing-context-flag
sbox.自動~特色機能:#sandboxed-automatic-features-browsing-context-flag
sbox.補助~navi:#sandboxed-auxiliary-navigation-browsing-context-flag
sbox.方位~lock:#sandboxed-orientation-lock-browsing-context-flag
sbox.呈示:#sandboxed-presentation-browsing-context-flag
~sandbox化( ~modal )~flag:#sandboxed-modals-flag
~sandbox化( ~storage域~URL )~flag:#sandboxed-storage-area-urls-flag
~sandboxは補助~閲覧文脈に伝播する~flag:#sandbox-propagates-to-auxiliary-browsing-contexts-flag



	~naviを通して，~pluginを~instance化する:~NAVI#sandboxPluginNavigate
	内容を一意~生成元~内に強制する:#sandboxOrigin
	~script実行を阻止する:~WAPI#sandboxScriptBlocked
	埋込-要素:~HEembed#sandboxPluginEmbed
	~obj要素:~HEembed#sandboxPluginObject
	~applet要素:~HTML5/obsolete.html#sandboxPluginApplet
	~form提出を阻止する:~HTMLforms#sandboxSubmitBlocked
	動画を自動的に再生する:~HTMLemb#attr-media-autoplay
	~form~controlを自動的に~focusする:~HTMLforms#attr-fe-autofocus

	●閲覧文脈
閲覧文脈:#browsing-context

閲覧文脈~名:#browsing-context-name
名前:#browsing-context-name
妥当な閲覧文脈~名:#valid-browsing-context-name
妥当な閲覧文脈~名または~keyword:#valid-browsing-context-name-or-keyword
閲覧文脈に属する:#concept-document-bc
属する閲覧文脈:#concept-document-bc
属する文書:#concept-document-bc
	閲覧文脈を~close:#close-a-browsing-context
開いた閲覧文脈:#opener-browsing-context
~top-level閲覧文脈:#top-level-browsing-context

閲覧文脈~容器:#browsing-context-container
内容~文書:#concept-bcc-content-document
入子の閲覧文脈:#nested-browsing-context
入子にしている閲覧文脈:#nested-browsing-context
:#browsing-context-nested-through
通して入子にされ:#browsing-context-nested-through

子~閲覧文脈:#child-browsing-context
文書~木に属する子~閲覧文脈:#document-tree-child-browsing-context
	文書~木に属する子~閲覧文脈の個数:#number-of-document-tree-child-browsing-contexts
子~閲覧文脈~list:#_list-of-the-child-browsing-contexts
子孫~閲覧文脈~list:#list-of-the-descendant-browsing-contexts
親~閲覧文脈:#parent-browsing-context
先祖:#ancestor-browsing-context
先祖~閲覧文脈:#ancestor-browsing-context

新たな閲覧文脈を作成-:#creating-a-new-browsing-context
新たに作成-:#creating-a-new-browsing-context
直接到達可能:#directly-reachable-browsing-contexts
閲覧文脈を破棄-:#a-browsing-context-is-discarded
破棄-:#a-browsing-context-is-discarded
補助~閲覧文脈:#auxiliary-browsing-context
互関係~閲覧文脈~群:#unit-of-related-browsing-contexts
互関係かつ類似生成元の閲覧文脈~群:#unit-of-related-similar-origin-browsing-contexts

閲覧文脈~視野~生成元:#browsing-context-scope-origin
	閲覧文脈の作成-時にあてがわれたそれら:#about-blank-origin
名前から閲覧文脈を選ぶ規則:#the-rules-for-choosing-a-browsing-context-given-a-browsing-context-name
閲覧文脈を選ぶ規則:#the-rules-for-choosing-a-browsing-context-given-a-browsing-context-name
閲覧文脈~用に環境~設定群~objを設定して:#set-up-a-browsing-context-environment-settings-object

作成元~閲覧文脈:#creator-browsing-context
作成元の生成元:#creator-origin
作成元の~URL:#creator-url
作成元の基底~URL:#creator-base-url
作成元の~referrer施策:#creator-referrer-policy
作成元の文脈~保安:#creator-context-security

~scriptから閉じれる:#script-closable
閉じる:#close-a-browsing-context
	閲覧文脈を閉じる:#close-a-browsing-context
近しい:#familiar-with


	●文書
doc.結付けられる:#concept-document-window
	~windowの文書:#concept-document-window
結付けられている文書:#concept-document-window
対応する閲覧文脈:#_concept-window-bc
	最新の文書
	現在の文書
	結付けられている
作動中の文書:#active-document
作動中:#active-document
文書~族:#document-family
doc.破棄-:#discard-a-document
全部的に作動中:#fully-active

	●~session履歴
作動中でない:#_is-inactive
~session履歴:#session-history
~session履歴~entry:#session-history-entry
~session履歴~event-loop:#session-history-event-loop
~session履歴~走査~待行列:#session-history-traversal-queue
共同~session履歴:#joint-session-history
共同~session履歴の現在の~entry:#current-entry-of-the-joint-session-history
現在の~entry:#current-entry
1.現在の~entry:#current-entry-of-the-joint-session-history
持続的~利用者~状態を伴う:#an-entry-with-persisted-user-state
直列形の状態:#serialized-state
~scroll復旧~mode:#scroll-restoration-mode
最近の~entry:#latest-entry
履歴を前／後に走査する:#traverse-the-history-by-a-delta

	●Location
Loc.~navigate:#location-object-navigate
Loc.~url:#concept-location-url
Loc.対応する閲覧文脈:#_concept-location-bc
Loc.関連する文書:#relevant-document
先祖~生成元~list:#concept-location-ancestor-origins-array
生成元~domainを検査する:#_location-security-check
~Location~obj設定子により~navigateする:#location-object-setter-navigate
~Location~objにより~navigateする:#location-object-navigate


	●BarProp
bP.~location-bar:#the-location-bar-barprop-object
bP.~menu-bar:#the-menu-bar-barprop-object
bP.~personal-bar:#the-personal-bar-barprop-object
bP.~scrollbar:#the-scrollbar-barprop-object
bP.~status-bar:#the-status-bar-barprop-object
bP.~toolbar:#the-toolbar-barprop-object


	●nav
~load~event遅延~中~mode:#delaying-load-events-mode
~navigateが許容され:#allowed-to-navigate

~navigate:~NAVI#navigate
~navi:~NAVI#navigate
置換え可能化~flag:~NAVI#replacement-enabled
例外~可能化~flag:~NAVI#exceptions-enabled
~source閲覧文脈:~NAVI#source-browsing-context
~unload:~NAVI#unload-a-document
文書を~unload:~NAVI#unload-a-document
~unloadを~prompt:~NAVI#prompt-to-unload-a-document
~unloadを拒否-:~NAVI#refused-to-allow-the-document-to-be-unloaded
文書~unload時の片付け手続き:~NAVI#unloading-document-cleanup-steps
中止-:~NAVI#abort-a-document
中止する:~NAVI#abort-a-document
新たな文書を初期化する:~NAVI#initialise-the-document-object
回復可能~状態:~NAVI#concept-document-salvageable
履歴を走査する:~NAVI#traverse-the-history
履歴の走査:~NAVI#traverse-the-history
再読込みにより誘発され:~NAVI#reload-triggered-navigation
成熟-:~NAVI#concept-navigate-mature
~entry更新-:~NAVI#entry-update


	●生成元
不透明な生成元:#concept-origin-opaque
~scheme:#concept-origin-scheme
~host:#concept-origin-host
~port:#concept-origin-port
成分組~生成元:#concept-origin-tuple
~domain:#concept-origin-domain
同一生成元:#same-origin
sub.生成元:#same-origin
同じ生成元~domain:#same-origin-domain
sub.~domain:#same-origin-domain
実効~domain:#concept-origin-effective-domain

生成元:#concept-origin
生成元の~ASCII直列化:#ascii-serialisation-of-an-origin
生成元の~Unicode直列化:#unicode-serialisation-of-an-origin
~Unicode直列化:#unicode-serialisation-of-an-origin

登録可能な~domain~suffixまたは同等:#is-a-registrable-domain-suffix-of-or-is-equal-to

	●INFRA
~ASCII大小無視:~INFRA#ascii-case-insensitive
~commaで分割-:~INFRA#split-on-commas
~ASCII空白で分割-:~INFRA#split-on-ascii-whitespace
~list:~INFRA#list
付加-:~INFRA#list-append

	●HTMLINFRA
相対的に構文解析-:~HTMLINFRA#parse-a-url
結果の~URL~record:~HTMLINFRA#resulting-url-record
結果の~URL文字列:~HTMLINFRA#resulting-url-string
doc.基底~URL:~HTMLINFRA#document-base-url

適用し得る仕様:~HTMLconform#other-applicable-specifications
~CORS非同一生成元:~HTMLINFRA#cors-cross-origin
~CORS同一生成元:~HTMLINFRA#cors-same-origin
~HTML要素:~HTMLINFRA#html-elements
~plugin:~HTMLINFRA#plugin
保安化-:~HTMLINFRA#concept-plugin-secure
並列的:~HTMLINFRA#in-parallel
強い参照:~HTMLINFRA#implied-strong-reference
文書から除去され:~HTMLINFRA#remove-an-element-from-a-document

jA.StructuredSerialize:~HTMLcloning#structuredserialize
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
逆直列化-:~HTMLcloning#structureddeserialize

	●WAPI
~entry設定群~obj:~WAPI#entry-settings-object
現任の設定群~obj:~WAPI#incumbent-settings-object
現在の設定群~obj:~WAPI#current-settings-object
大域~obj:~WAPI#concept-settings-object-global
	~WAPI#global-object
~Realm:~WAPI#environment-settings-object's-realm
	'
関連する設定群~obj:~WAPI#relevant-settings-object
関連する~Realm:~WAPI#concept-relevant-realm
関連する大域~obj:~WAPI#concept-relevant-global
~script:~WAPI#concept-script
~task:~WAPI#concept-task
現在~走っている~task:~WAPI#currently-running-task
~taskを待入する:~WAPI#queue-a-task
待入され:~WAPI#queue-a-task
~task源:~WAPI#task-source
履歴~走査~task源:~WAPI#history-traversal-task-source
~event-loop:~WAPI#event-loop

設定群~obj:~WAPI#settings-object
環境:~WAPI#environment
enV.~id:~WAPI#concept-environment-id
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
enV.作動中の~service-worker:~WAPI#concept-environment-active-service-worker
環境~設定群~obj:~WAPI#environment-settings-object
enV.~realm実行~文脈:~WAPI#realm-execution-context
enV.~API基底~URL:~WAPI#api-base-url
enV.担当の文書:~WAPI#responsible-document
enV.担当の閲覧文脈:~WAPI#responsible-browsing-context
enV.担当の~event-loop:~WAPI#responsible-event-loop
enV.~API~URL文字~符号化方式:~WAPI#api-url-character-encoding
enV.~HTTPS状態:~WAPI#https-state
enV.生成元:~WAPI#concept-settings-object-origin
enV.~module~map:~WAPI#concept-settings-object-module-map
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.実行~準備済み~flag:~WAPI#concept-environment-execution-ready-flag

relem.大域~obj:~WAPI#concept-realm-global

	●URLSpec
~URL:~URLSpec#concept-url
~URL~record:~URLSpec#concept-url-record
~hostとして同等:~URLSpec#concept-host-equals
~URL構文解析器:~URLSpec#concept-url-parser
基本~URL構文解析器:~URLSpec#concept-basic-url-parser
~host直列化器:~URLSpec#concept-host-serializer
~host構文解析器:~URLSpec#concept-host-parser
~URL直列化器:~URLSpec#concept-url-serializer
~domainから~Unicodeへ変換-:~URLSpec#concept-domain-to-unicode
~cannot-be-a-base-URL~flag:~URLSpec#url-cannot-be-a-base-url-flag
~username／~password／~portを持てない:~URLSpec#cannot-have-a-username-password-port

x.~host:~URLSpec#concept-host
url.~domain:~URLSpec#concept-domain
url.~host:~URLSpec#concept-url-host
url.~path:~URLSpec#concept-url-path
url.~port:~URLSpec#concept-url-port
url.~query:~URLSpec#concept-url-query
url.~scheme:~URLSpec#concept-url-scheme
url.素片:~URLSpec#concept-url-fragment
url.生成元:~URLSpec#concept-url-origin
url.~URL生成元:~URLSpec#concept-url-origin
url.IPv4 ~address:~URLSpec#concept-ipv4
url.IPv6 ~address:~URLSpec#concept-ipv6
url.~hostname~state:~URLSpec#hostname-state
url.~host~state:~URLSpec#host-state
url.~path開始-~state:~URLSpec#path-start-state
url.既定の~port:~URLSpec#default-port
url.~port~state:~URLSpec#port-state
url.~query~state:~URLSpec#query-state
url.~scheme開始-~state:~URLSpec#scheme-start-state
url.整数として直列化-:~URLSpec#serialize-an-integer
url.素片~state:~URLSpec#fragment-state

~network~scheme:~FETCH#network-scheme
~HTTP_S~scheme:~FETCH#http-scheme

	●
jA.InitializeHostDefinedRealm():~TC39#sec-initializehostdefinedrealm
~JS実行~文脈:~TC39#sec-execution-contexts

上書きされた再読込み:~HTMLdom#an-overridden-reload
再読込み上書き~flag:~HTMLdom#reload-override-flag
doc.~HTTPS状態:~HTMLdom#concept-document-https-state
doc.~module~map:~HTMLdom#concept-document-module-map
doc.~referrer:~HTMLdom#the-document's-referrer
	'
doc.~referrer施策:~HTMLdom#concept-document-referrer-policy

画像~data:~HEimages#img-req-data
~iframe~srcdoc文書:~HEembed#an-iframe-srcdoc-document
~allowX~flagを設定する:~HEembed#set-the-allow*-flags

~media~data:~HTMLemb#media-data
~media要素:~HTMLemb#media-element

読込後~taskは準備済み:~HTMLsyntax#ready-for-post-load-tasks
完全に読込まれ:~HTMLsyntax#completely-loaded
~load~eventを遅延する:~HTMLsyntax#delay-the-load-event

~workerの文書~list:~WORKERS#the-worker's-documents
	'

利用者による作動化から誘発されて:~HTMLinteraction#triggered-by-user-activation


doc.種別:~DOM4#concept-document-type
doc.過去互換~mode:~DOM4#concept-document-quirks
doc.内容~型:~DOM4#concept-document-content-type
doc.文字~符号化方式:~DOM4#concept-document-encoding
doc.~URL:~DOM4#concept-document-url

	~HTML文書:~DOM4#html-document
~node文書:~DOM4#concept-node-document
~eventを発火する:~DOM4#concept-event-fire
木~内にある:~DOM4#in-a-document
文書~木~内:~DOM4#in-a-document
木~順序:~DOM4#tree-order
接続されて:~DOM4#connected
~shadowも含む根:~DOM4#concept-shadow-including-root
根:~DOM4#concept-tree-root
作動化の挙動:~DOM4#eventtarget-activation-behavior

~interface~obj:~WEBIDL#dfn-interface-object
有名~propを~supportする:~WEBIDL#dfn-support-named-properties
有名~propの値を決定する:~WEBIDL#dfn-determine-the-value-of-a-named-property
被support~prop名:~WEBIDL#dfn-supported-property-names
設定群は保安的~文脈であるか？:~SECURE-CONTEXT#settings-object
	~scriptに返される:~HTMLindex#event-popstate
	~iframe属性を再処理する:~HEembed#process-the-iframe-attributes


</script>

<!--%style -->
<style type="text/css">
.js, .js-slot, .js-value, .js-intrinsic, .js-symbol, .js-class, .js-method {
	color: green;
}

*[lang="en"] {
	white-space: pre-line;
}

#_nav-table tr > *:first-child {
	max-width: 50vw;
}
</style>

<body>


<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Standard — 7. Loading Web pages 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Loading Web pages</a>
章の一部分を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-03-16</time>
（公開：<time>2016-07-12</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>
	<hgroup>
<h1>7. Web ページの読み込み — Loading Web pages</h1>
<h2>HTML Living Standard — 最終更新 2017 年 3 月 22 日</h2>
	</hgroup>
</header>

<hr>

<main id="MAIN" style="display:none;">

<section id="browsers">
<h1 title="Loading Web pages">7. Web ページの読み込み</h1>

<p>
この節は、~Web~browserに最も直接的に適用される特色機能を述べる。
とは言え，~web~browserかどうかにかかわらず、この節に定義される要件は，<em>すべての~UA</em>に適用される
— 他が指定されない限り。
◎
This section describes features that apply most directly to Web browsers. Having said that, except where specified otherwise, the requirements defined in this section do apply to all user agents, whether they are Web browsers or not.
</p>

	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, 此れ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<ul>
	<li>
用語［
`文書@
,
`~window@
］は、順に［
`Document$I,
`Window$I
］~interfaceを実装する~objの略記である。
</li>
</ul>

	</section>
	<section id="windows">
<h2 title="Browsing contexts">7.1 閲覧文脈</h2>

<p>
`閲覧文脈@
とは、利用者に対し`文書$を呈示する環境である。
◎
A browsing context is an environment in which Document objects are presented to the user.
</p>

<p class="note">注記：
~Web~browser内の［
~tab／~window
］は、概して`閲覧文脈$を包含する。
［
`iframe$e ／ `frameset$e
］内の `frame$e も同様である。
◎
A tab or window in a Web browser typically contains a browsing context, as does an iframe or frames in a frameset.
</p>

<p>
各 `閲覧文脈$は、対応する `WindowProxy$I ~objを持つ。
◎
A browsing context has a corresponding WindowProxy object.
</p>

<div class="p">
<p>
各 `閲覧文脈$は、`~session履歴$を持つ。
それは、`閲覧文脈$が呈示-［
した／している／することになる
］`文書$たちからなる。
各 `閲覧文脈$においては、どの時点においても，この履歴~内のある一つの`文書$が
`作動中の文書@
として指名される。
</p>

<p class="trans-note">【
作動中の文書は常にある
— `新たな閲覧文脈を作成-$する時点で、内容が空の`文書$（ `about_blank$sc ）が履歴に追加され，暗黙的にその時点での作動中の文書に指名される。
】</p>

<p>
`文書$ %文書 が
`属する閲覧文脈@
は、次で与えられる：
</p>

<ul><li>`破棄-$されていない`閲覧文脈$ %B があって，［
%文書 ~IN %B の`~session履歴$
］ならば %B である†。
</li><li>他の場合 ε （~~存在しない）。
</li></ul>

<p class="trans-note">【†
同じ`文書$が複数の`~session履歴$に含まれることはない。
】</p>

◎
A browsing context has a session history, which lists the Document objects that the browsing context has presented, is presenting, or will present. At any time, one Document in each browsing context is designated the active document. A Document's browsing context is the browsing context whose session history contains the Document, if any such browsing context exists and has not been discarded.
</div>


<div class="note">

<p>注記：
一般に，`~window$から`閲覧文脈に属する$`文書$へは一対一に対応するが、例外が二つある：
</p>

<ul>
	<li>
一つは、`~window$は，同じ`閲覧文脈$内で二番目の`文書$を呈示するために再利用されることもあり、その場合，対応関係は一対二になる†。
これは、［
`置換え可能化~flag$ ~SET ~ON
］の下で，`閲覧文脈$が初期 `about_blank$sc `文書$から別の文書へ`~navigate$されるときに生じる。
</li>
	<li>
もう一つは、 `document.open()$m ~methodが利用される結果として，いくつかの`~window$間で同じ`文書$が再利用される††こともある
— この場合、対応関係は多対一になる。
</li>
</ul>

<p class="trans-note">【†
この一対二は，異なる時点も含めてのことであり、任意のある時点では，一義的に対応する
— そのため、仕様の記述では、文書と~windowは，他の~objとの~~関係を述べるときに同一視されることも多い
— 例えば “~windowの閲覧文脈” は、実際には
“~windowに結付けられている文書が属する閲覧文脈”
の略記である（そう解釈する下で，和訳している）。
】【††
再利用されると言っても、文書の内容は ~openした資源で一新される。
】</p>

◎
In general, there is a 1-to-1 mapping from the Window object to the Document object, as long as the Document object has a browsing context. There are two exceptions. First, a Window can be reused for the presentation of a second Document in the same browsing context, such that the mapping is then 1-to-2. This occurs when a browsing context is navigated from the initial about:blank Document to another, with replacement enabled. Second, a Document can end up being reused for several Window objects when the document.open() method is used, such that the mapping is then many-to-1.
</div>

<p class="note">注記：
`文書$は必ずしも`閲覧文脈$に属するとは限らない。
特に，~data集析~toolは、およそ閲覧文脈を~instance化することはないであろう。
`createDocument()$m などの ~APIを利用して作成された`文書$は、`閲覧文脈に属する$ことは決してない。
また、 `iframe$e 要素に対し作成された`文書$があって，後にその要素が`文書から除去され$たときは、その文書が`属する閲覧文脈$は`破棄-$され，文書が`属する閲覧文脈$は ε になる。
◎
A Document does not necessarily have a browsing context associated with it. In particular, data mining tools are likely to never instantiate browsing contexts. A Document created using an API such as createDocument() never has a browsing context. And the Document originally created for an iframe element, which has since been removed from the document, has no associated browsing context, since that browsing context was discarded.
</p>

<hr>

<div class="p">
<p>
`閲覧文脈$ %B の
`作成元~閲覧文脈@
とは、 %B の作成を担当していたとされる`閲覧文脈$であり，次で定義される：
</p>

<ol ><li>%B の`親~閲覧文脈$ ~NEQ ε ならば、それ。
</li><li>他の場合， %B を`開いた閲覧文脈$ ~NEQ ε ならば、それ。
</li><li>他の場合、 ε。
</li></ol>

◎
A browsing context can have a creator browsing context, the browsing context that was responsible for its creation. If a browsing context has a parent browsing context, then that is its creator browsing context. Otherwise, if the browsing context has an opener browsing context, then that is its creator browsing context. Otherwise, the browsing context has no creator browsing context.
</div>

<p>
`閲覧文脈$ %B の`作成元~閲覧文脈$ %作成元 ~NEQ ε ならば、
%B には次のものが結付けられる（ %作成元 ~EQ ε の場合、これらは いずれも ε とする）。
以下における %作成元~文書 は %B の作成-時に %作成元 にて`作動中の文書$であった`文書$とする：
◎
If a browsing context context has a creator browsing context creator, it also has the following properties. In what follows, let creator document be creator's active document at the time context is created:
</p>

<dl class="def-list">
	<dt>`作成元の生成元@</dt>
	<dd>
%作成元~文書 の`生成元$
◎
creator document's origin
</dd>

	<dt>`作成元の~URL@</dt>
	<dd>
%作成元~文書 の`~URL$doc
◎
creator document's URL
</dd>

	<dt>`作成元の基底~URL@</dt>
	<dd>
%作成元~文書 の`基底~URL$doc
◎
creator document's base URL
</dd>

	<dt>`作成元の~referrer施策@</dt>
	<dd>
%作成元~文書 の`~referrer施策$doc
◎
creator document's referrer policy
</dd>

	<dt>`作成元の文脈~保安@</dt>
	<dd>
%作成元~文書 に`関連する設定群~obj$に対し，`設定群は保安的~文脈であるか？$を実行した結果
◎
The result of executing Is environment settings object a secure context? on creator document's relevant settings object
</dd>

</dl>



<p class="algo-head">
`新たな閲覧文脈を作成-@
するときは：
◎
To create a new browsing context:
</p>

<!-- ＊
https://github.com/whatwg/html/issues/2455
-->

<ol>
	<li>
%B ~LET 新たな`閲覧文脈$
◎
Let browsingContext be a new browsing context.
</li>
	<li>
%window ~LET 新たな`~window$
◎
↓</li>
	<li>
<p>
%windowProxy ~LET 新たな `WindowProxy$I ~obj 
◎
↓</li>
	<li>
<p>
%~realm実行~文脈 ~LET 
次のように~customizeする下で~JS `InitializeHostDefinedRealm()$jA 抽象~演算を~callして作成される`~JS実行~文脈$：
◎
Call the JavaScript InitializeHostDefinedRealm() abstract operation with the following customizations:
</p>

		<ul>
			<li>
大域~obj には %window を利用する
◎
For the global object, create a new Window object window.
</li>
			<li>
大域 `this^js 値 には %windowProxy を利用する
◎
For the global this value, use browsingContext's WindowProxy object.
◎
Let realm execution context be the created JavaScript execution context.
</li>
		</ul>
	</li>
	<li>
%設定群~obj ~LET
%~realm実行~文脈 で`閲覧文脈~用に環境~設定群~objを設定して$おいた結果
◎
Set up a browsing context environment settings object with realm execution context, and let settingsObject be the result.
</li>
	<li>
<p>
%文書 ~LET 次のようにされた新たな`文書$：
</p>

<ul ><li>`過去互換~mode$docにおいては
⇒
%文書 の`種別$doc ~SET `html^l
</li><li>`内容~型$doc ~SET `text/html^l
</li><li>即時に，`読込後~taskは準備済み$になる
</li><li>即時に，`完全に読込まれ$る
</li></ul>
◎
Let document be a new Document, marked as an HTML document in quirks mode, whose content type is "text/html", and which is both ready for post-load tasks and completely loaded immediately.
</li>
	<li>
%文書 は、単独の子 `html$e ~nodeを持ち，その~nodeは二つの空の子~node［
`head$e 要素, `body$e 要素
］を持つことを確保する
◎
Ensure that document has a single child html node, which itself has two empty child nodes: a head element, and a body element.
</li>
	<li>
%window に`結付けられている文書$ ~SET %文書
◎
Set window's associated Document to document.
</li>
	<li>
<p>
%windowProxy の `Window$sl 内部~slot値 ~SET %window
◎
Set browsingContext's WindowProxy object's [[Window]] internal slot value to window.
</p>

<p class="note">注記：
この内部~slot値は、~naviが生じるに伴い，更新される。
◎
The internal slot value is updated when navigations occur.
</p>
	</li>
	<li id="about-blank-origin">
<p>
~IF［
%B の`作成元~閲覧文脈$ ~NEQ ε
］
⇒
%文書 の
( `生成元$, `~referrer$doc, `~referrer施策$doc )
~SET
%B の
( `作成元の生成元$, `作成元の~URL$を`~URL直列化器$にかけた結果, `作成元の~referrer施策$)
</p>

<p>
~ELSE
⇒
%文書 の`生成元$ ~SET `不透明な生成元$
</p>

◎
Set the origin of document:
• If browsingContext has a creator browsing context, then the origin of document is the creator origin.
• Otherwise, the origin of document is a unique opaque origin.
◎
If browsingContext has a creator browsing context, then set document's referrer to the serialization of creator URL.
◎
If browsingContext has a creator browsing context, then set document's referrer policy to the creator referrer policy.
</li>
	<li>
%文書 に対し`~sandboxingを実装する$
◎
Implement the sandboxing for document.
</li>
	<li>
%文書 に対し`~allowX~flagを設定する$
◎
Set the allow* flags for document.
</li>
	<li>
%設定群~obj の`実行~準備済み~flag$enV ~SET ~ON
◎
Set settingsObject's execution ready flag.
</li>
	<li>
%B の`~session履歴$に %文書 を追加する
◎
Add document to browsingContext's session history.
</li>
	<li>
~RET %B
◎
Return browsingContext.
</li>
</ol>


		<section id="nested-browsing-contexts">
<h3 title="Nested browsing contexts">7.1.1. 入子の閲覧文脈</h3>


<p>
ある種の要素（例えば `iframe$e 要素）は、更に`閲覧文脈$を~instance化し得る。
そのような要素 %要素 は
`閲覧文脈~容器@
と呼ばれる。
◎
Certain elements (for example, iframe elements) can instantiate further browsing contexts. These elements are called browsing context containers.
</p>

<p>
%要素 が
`入子にしている閲覧文脈@
は、そのような`閲覧文脈$ %B が存在するならば それ ／
存在しなければ  ~NULL と定義される。
前者の場合：
◎
Each browsing context container has a nested browsing context, which is either a browsing context or null.
</p>

<div class="p">
<ul>
	<li>
%B は`入子の閲覧文脈$である，ともいう（すなわち、この言い回しは非 ~NULL も含意する）。
</li>
	<li>
%B は %要素 を
`通して入子にされ@
ているという。
加えて、 %要素 の`~node文書$を %文書 とするとき、
%B は %文書 を`通して入子にされ$ているともいう。
</li>
</ul>

<p class="trans-note">【
同じ要素が複数の閲覧文脈を（直に）入子にしたり，複数の要素が同じ閲覧文脈を入子にすることはない。
】</p>

◎
If a browsing context is the nested browsing context of a browsing context container, then the browsing context is said to be nested through the browsing context container's node document.
</div>


<p>
`閲覧文脈$ %子 は、次の条件すべてを満たすならば，別の`閲覧文脈$ %親 の
`子~閲覧文脈@
とされる：
◎
A browsing context child is said to be a child browsing context of another browsing context parent, if all of the following conditions hold:
</p>

<!-- %子 ~NEQ ε -->

<ul>
	<li>
ある`閲覧文脈~容器$ %要素 があって，
%子 ~EQ %要素 が`入子にしている閲覧文脈$
◎
child is a nested browsing context of a browsing context container element
</li>
	<li>
%要素 は`接続されて$いる
◎
element is connected
</li>
	<li>
%親 ~EQ %要素 の`~shadowも含む根$が`属する閲覧文脈$
◎
element's shadow-including root's browsing context is parent
</li>
</ul>

<!-- 従って、 親~子~関係は、入子より強い -->

<p>
更には， %親 の`子~閲覧文脈$ %子 は、
%子 の`閲覧文脈~容器$が`文書~木~内$にあるならば，
%親 の`文書~木に属する子~閲覧文脈@
であるという。
◎
A browsing context child is then a document-tree child browsing context of parent if it is a child browsing context and its browsing context container is not just connected, but also in a document tree.
</p>


<p>
`閲覧文脈$ %子 が`子~閲覧文脈$であるならば、前述の
%親 は %要素 から %文書 を通して一意に定まる。
この %親 を指して， %子 の
`親~閲覧文脈@
という。
%子 が`子~閲覧文脈$でないならば、
%子 の`親~閲覧文脈$ ~EQ ε （存在しない）と定義される。
◎
A browsing context child may have a parent browsing context. This is the unique browsing context that has child as a child browsing context, if any such browsing context exists. Otherwise, the browsing context has no parent browsing context.
</p>


<div class="p">
<p>
`閲覧文脈$ %A, %B が次のいずれかを満たすとき、
%A は %B の
`先祖@
であるという：
</p>

<ul ><li>%A は %B の`親~閲覧文脈$である
</li><li>%A は %B の ある`先祖$の`親~閲覧文脈$である
</li></ul>

◎
A browsing context A is said to be an ancestor of a browsing context B if there exists a browsing context A' that is a child browsing context of A and that is itself an ancestor of B, or if the browsing context A is the parent browsing context of B.
</div>


<p>
`入子の閲覧文脈$でない`閲覧文脈$ %B の`親~閲覧文脈$は ε である。
このとき、 %B は，［
%B を`先祖$とするような閲覧文脈
］すべての
`~top-level閲覧文脈@
になる。
◎
A browsing context that is not a nested browsing context has no parent browsing context, and is the top-level browsing context of all the browsing contexts for which it is an ancestor browsing context.
</p>

<p class="trans-note">【
“`~top-level閲覧文脈$である”
ことに`子~閲覧文脈$の存在が要求されるわけではない。
~top-level閲覧文脈 %B 自身の~top-level閲覧文脈も %B である。
（例えば`補助~閲覧文脈$）
】</p>

<p>
`閲覧文脈$に対する，非 ε の`親~閲覧文脈$による推移閉包
`親を順々に辿って得られる先祖たち^tnote
は、`先祖~閲覧文脈$の~listを成す。
◎
The transitive closure of parent browsing contexts for a browsing context that is a nested browsing context gives the list of ancestor browsing contexts.
</p>



<p class="algo-head">
`文書$ %文書 の
`子孫~閲覧文脈~list@
は、次の~algoが返す有順序~listで与えられる：
◎
The list of the descendant browsing contexts of a Document d is the (ordered) list returned by the following algorithm:
</p>


<ol>
	<li>
%~list ~LET 空~list
◎
Let list be an empty list.
</li>
	<li>
%L ~LET %文書 `木~内にある$各 要素を`通して入子にされ$ている`閲覧文脈$からなる，要素たちの`木~順序$による~list
◎
For each child browsing context of d that is nested through an element that is in the Document d, in the tree order of the elements nesting those browsing contexts, run these substeps:
</li>
	<li>
<p>
~FOR
%L 内の ~EACH ( `閲覧文脈$ %B ) に対し：
◎
↑</p>
		<ol>
			<li>
%~list の末尾に %B を付加する
◎
Append that child browsing context to the list list.
</li>
			<li>
%~list の末尾に［
%B にて`作動中の文書$の `子孫~閲覧文脈~list$
］を付加する
◎
Append the list of the descendant browsing contexts of the active document of that child browsing context to the list list.
</li>
		</ol>
	</li>
	<li>
~RET %~list
◎
Return the constructed list.
</li>
</ol>


<div class="p">
<p>
`作動中の文書$は、自身が`属する閲覧文脈$ %B が次を満たすならば，
`全部的に作動中@
であるという：
</p>

<ul ><li>%B は`~top-level閲覧文脈$であるか，または
</li><li>%B の`親~閲覧文脈$ %P ~NEQ ε
~AND
%B は %P において`全部的に作動中$である文書を`通して入子にされ$ている
</li></ul>

◎
A Document is said to be fully active when it has a browsing context and it is the active document of that browsing context, and either its browsing context is a top-level browsing context, or it has a parent browsing context and the Document through which it is nested is itself fully active.
</div>

<p>
`子~閲覧文脈$ %B は，要素に結付けられるので、常にその`親~閲覧文脈$に属する特定の`文書$ %文書 に束ねられる。
~UAは、 %文書 が`全部的に作動中$でない下では、<!-- ＊ -->利用者による %B とのやりとりを許容しては~MUST_NOT。
◎
Because they are associated with an element, child browsing contexts are always tied to a specific Document in their parent browsing context. User agents must not allow the user to interact with child browsing contexts of elements that are in Documents that are not themselves fully active.
</p>


<p>
`入子の閲覧文脈$は、
`~load~event遅延~中~mode@
下に置かれ得る。
この~modeは、`~navigate$に際して新たな`文書$が作成される前に，その`閲覧文脈~容器$向けの`~load~eventを遅延する$ために利用される。
◎
A browsing context that is a nested browsing context can be put into a delaying load events mode. This is used when it is navigated, to delay the load event of its browsing context container before the new Document is created.
</p>

<p>
`閲覧文脈$ %B の
`文書~族@
は、［
%B の`~session履歴$内にある`文書$
］すべてと, ［
それらの各`文書$の`文書~族$
］すべての和集合からなる。
`文書$ %文書 の`文書~族$は、［
%文書 を`通して入子にされ$ている各 `閲覧文脈$の`文書~族$
］すべての和集合からなる。
◎
The document family of a browsing context consists of the union of all the Document objects in that browsing context's session history and the document families of all those Document objects. The document family of a Document object consists of the union of all the document families of the browsing contexts that are nested through the Document object.
</p>

<p class="algo-head">
`閲覧文脈~容器$ %C の
`内容~文書@
は、次の~algoの結果で与えられる：
◎
The content document of a browsing context container container is the result of the following algorithm:
</p>

<ol>
	<li>
%B ~LET %C が`入子にしている閲覧文脈$
</li>
	<li>
~IF［
%B ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If container's nested browsing context is null, then return null.
◎
Let context be container's nested browsing context.
</li>
	<li>
%文書 ~LET %B にて`作動中の文書$
◎
Let document be context's active document.
</li>
	<li>
~IF［
%文書 の`生成元$
~NEQ`~domain$sub
`現在の設定群~obj$により指定される`生成元$enV
］
⇒
~RET ~NULL
◎
If document's origin and the origin specified by the current settings object are not same origin-domain, then return null.
</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>




			<section id="navigating-nested-browsing-contexts-in-the-dom">
<h4 title="Navigating nested browsing contexts in the DOM">7.1.1.1. ~DOM内の入子の閲覧文脈を~navigateするとき</h4>

<dl class="domintro">
	<dt>%window . `top$m</dt>
	<dd>
`~top-level閲覧文脈$の `WindowProxy$I を返す。
◎
Returns the WindowProxy for the top-level browsing context.
</dd>

	<dt>%window . `parent$m</dt>
	<dd>
`親~閲覧文脈$の `WindowProxy$I を返す。
◎
Returns the WindowProxy for the parent browsing context.
</dd>

	<dt>%window . `frameElement$m</dt>
	<dd>
`閲覧文脈~容器$に対する `Element$I を返す。
◎
Returns the Element for the browsing context container.
</dd>
	<dd>
そのようなものがない, または
“非同一生成元 状況”
にある場合、 ~NULL を返す。
◎
Returns null if there isn't one, and in cross-origin situations.
</dd>
</dl>


<!-- `Window@I -->

<dl class="idl-def">
	<dt>`top@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The top IDL attribute, on getting, must run the following algorithm:
</p>

		<ol>
			<li>
%B ~LET 此れに`対応する閲覧文脈$
◎
↓</li>
			<li>
~IF［
%B ~EQ ε
］
⇒
~RET ~NULL
◎
Let windowProxy be this Window object's WindowProxy object.
◎
If there is no browsing context with windowProxy as its WindowProxy object, then return null.
◎
Let context be that browsing context.
</li>
			<li>
~RET %B の`~top-level閲覧文脈$の `WindowProxy$I ~obj
◎
If context is a top-level browsing context, then return context's WindowProxy object.
◎
Otherwise, context must have a top-level browsing context (i.e. an ancestor browsing context with no parent browsing context). Return that top-level browsing context's WindowProxy object.
</li>
		</ol>
	</dd>

	<dt>`parent@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
%B ~LET 此れに`対応する閲覧文脈$
◎
↓</li>
			<li>
~IF［
%B ~EQ ε
］
⇒
~RET ~NULL
◎
Let windowProxy be this Window object's WindowProxy object.
◎
If there is no browsing context with windowProxy as its WindowProxy object, then return null.
◎
Let context be that browsing context.
</li>
			<li>
~RET［
%B の`親~閲覧文脈$ ~NEQ ε ならば それ ／
~ELSE_ %B
］の `WindowProxy$I ~obj
◎
If context is a child browsing context of another browsing context parent, then return parent's WindowProxy object.
◎
Otherwise, context must be a top-level browsing context. Return context's WindowProxy object.
</li>
		</ol>
	</dd>

	<dt>`frameElement@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The frameElement IDL attribute, on getting, must run the following algorithm:
</p>
		<ol>
			<li>
%B ~LET 此れに`対応する閲覧文脈$
◎
↓</li>
			<li>
~IF［
%B ~EQ ε
］
⇒
~RET ~NULL
◎
Let windowProxy be this Window object's WindowProxy object.
◎
If there is no browsing context with windowProxy as its WindowProxy object, then return null.
◎
Let context be that browsing context.
</li>
			<li>
~IF［
%B は`入子の閲覧文脈$でない
］
⇒
~RET ~NULL
◎
If context is not a nested browsing context, then return null.
</li>
			<li>
%C ~SET %B の`閲覧文脈~容器$
◎
Let container be context's browsing context container.
</li>
			<li>
~IF［［
%C の`~node文書$の`生成元$
］~NEQ`~domain$sub［
`現在の設定群~obj$の`生成元$enV
］］
⇒
~RET ~NULL
◎
If container's node document's origin is not same origin-domain with the current settings object's origin, then return null.
</li>
			<li>
~RET %C
◎
Return container.
</li>
		</ol>
	</dd>
</dl>



<div class="example">
<p>
これらの~IDL属性が ~NULL を返し得る例：
◎
An example of when these IDL attributes can return null is as follows:
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;iframe&gt;&lt;/iframe&gt;

&lt;script&gt;
"use strict";
const %element = document.querySelector("iframe");
const %iframeWindow = %element.contentWindow;
%element.remove();

console.assert(%iframeWindow.top === null);
console.assert(%iframeWindow.parent === null);
console.assert(%iframeWindow.frameElement === null);
&lt;/script&gt;
</pre>

<p>
この例の %iframeWindow に対応する`閲覧文脈$は、
%element が文書から除去されたとき`破棄-$される。
◎
Here the browsing context corresponding to iframeWindow was discarded when element was removed from the document.
</p>

</div>


			</section>
		</section>
		<section id="auxiliary-browsing-contexts">
<h3 title="Auxiliary browsing contexts">7.1.2. 補助~閲覧文脈</h3>

<p>
新たな閲覧文脈を、要素を`通して入子にされ$ないが，ある`~top-level閲覧文脈$には関係するように作成することも可能0である。
そのような閲覧文脈は、
`補助~閲覧文脈@
と呼ばれる。
補助~閲覧文脈は、常に`~top-level閲覧文脈$である。
◎
It is possible to create new browsing contexts that are related to a top-level browsing context without being nested through an element. Such browsing contexts are called auxiliary browsing contexts. Auxiliary browsing contexts are always top-level browsing contexts.
</p>

<p>
`補助~閲覧文脈$ %B を作成させた`閲覧文脈$を指して、 %B を
`開いた閲覧文脈@
という（そのようなものがなければ、開いた閲覧文脈は ε とする）。
◎
An auxiliary browsing context has an opener browsing context, which is the browsing context from which the auxiliary browsing context was created.
</p>


			<section id="navigating-auxiliary-browsing-contexts-in-the-dom">
<h4 title="Navigating auxiliary browsing contexts in the DOM">7.1.2.1. ~DOM内の補助~閲覧文脈を~navigateするとき</h4>

<div class="p">

<p class="idl-def">
`Window$I 上の
`opener@m
属性は：
</p>

<ul>
	<li>
<p>
此れの作成-時には、次の結果に設定され~MUST：
</p>
		<ol>
			<li>
%B ~LET 此れに`対応する閲覧文脈$
</li>
			<li>
~IF［
%B ~EQ ε
］
⇒
~RET ~NULL
</li>
			<li>
%X ~LET %B を`開いた閲覧文脈$
</li>
			<li>
~RET ［
%X ~NEQ ε ならば %X の `WindowProxy$I ~obj ／
~ELSE_ ~NULL
］
</li>
		</ol>
	</li>
	<li>
<p>
上に与えた %X が可用でなくなった時点で ~NULL に設定される。
（ “`disown@” ）
</p>

<p class="trans-note">【
この訳では、この用語 “`disown$” を利用しない
— 代わりに `opener$m を直接 ~NULL に設定するように記述する。
（この用語は、 ~JS “own property” に由来すると見られる。）
】【
この節の記述は，原文から大きく再構成し直している。
】</p>
	</li>
	<li>
取得子は、最後に設定された値を返さ~MUST。
</li>
	<li>
<p>
設定子は、次の手続きを走らせ~MUST：
</p>
		<ol>
			<li>
%V ~LET 所与の値
</li>
			<li>
此れの `opener$m の値 ~SET %V
</li>
			<li>
~IF［
%V ~EQ ~NULL
］
⇒
~RET
</li>
			<li>
次を渡して，此れ上の
`DefineOwnProperty^sl 内部~methodを~callする
⇒
~prop~key： `opener^l,<br />
<!-- Property Descriptor -->~prop記述子：{
<span class="block" style="white-space:pre-line"
>`Value^sl: %V,
`Writable^sl: ~T,
`Enumerable^sl: ~T,
`Configurable^sl: ~T
</span>
}
</li>
		</ol>
	</li>
</ul>

◎
The opener IDL attribute on the Window object, on getting, must return the WindowProxy object of the browsing context from which the current browsing context was created (its opener browsing context), if there is one, if it is still available, and if the current browsing context has not disowned its opener; otherwise, it must return null. On setting, if the new value is null then the current browsing context must disown its opener; if the new value is anything else then the user agent must call the [[DefineOwnProperty]] internal method of the Window object, passing the property name "opener" as the property key, and the Property Descriptor { [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } as the property descriptor, where value is the new value.
</div>

<div class="note">

<p>注記：
`閲覧文脈$ %B の`~window$の `opener$m が ~NULL にされて以降は、
%B 内の~scriptは，それを`開いた閲覧文脈$の`~window$（すなわち， %B を作成した~window）のどの~propも変更できなくなる。
◎
If a browsing context has disowned its opener, the value of its window.opener is null. That prevents scripts in the browsing context from changing any properties of its opener browsing context's Window (i.e., the window from which the browsing context was created).
</p>

<p>
他の場合、 %B 内の~scriptは `opener$m を利用して，`開いた閲覧文脈$の`~window$の~propを変更できる。
例えば、%B 内で走っている~scriptは、 `window.opener.location^m の値を変更して，`開いた閲覧文脈$をまったく別の文書に~navigateできる。
◎
Otherwise, if a browsing context has not disowned its opener, then scripts in that browsing context can use window.opener to change properties of its opener browsing context's Window. For example, a script running in the browsing context can change the value of window.opener.location, causing the opener browsing context to navigate to a completely different document.
</p>
</div>


			</section>
		</section>
		<section id="security-nav">
<h3 title="Security">7.1.3. 保安</h3>

<p id="security-1">
所与の`閲覧文脈$ %A, %B に対し，
%A が %B に
`近しい@
（ “ %A is familiar with %B ” ）とは、次のいずれかが満たされることを意味する：
◎
A browsing context A is familiar with a second browsing context B if one of the following conditions is true:
</p>

<ul>
	<li>
［
%A にて`作動中の文書$の`生成元$
］~EQ`生成元$sub［
%B にて`作動中の文書$の`生成元$
］
◎
Either the origin of the active document of A is the same as the origin of the active document of B, or
</li>
	<li>
%A の`~top-level閲覧文脈$ ~EQ %B
◎
The browsing context A is a nested browsing context with a top-level browsing context, and its top-level browsing context is B, or
</li>
	<li>
［
%B は`補助~閲覧文脈$である
］~AND［
%A は %B を`開いた閲覧文脈$に`近しい$
］
◎
The browsing context B is an auxiliary browsing context and A is familiar with B's opener browsing context, or
</li>
	<li>
%B のある`先祖~閲覧文脈$ %X が存在して
⇒
［
%A にて`作動中の文書$の`生成元$
］~EQ`生成元$sub［
%X にて`作動中の文書$の`生成元$
］
◎
The browsing context B is not a top-level browsing context, but there exists an ancestor browsing context of B whose active document has the same origin as the active document of A (possibly in fact being A itself).
</li>
</ul>

<p class="trans-note">【
最初と最後の条件から、特に，［
%A ~EQ %B, または
%A は %B の`先祖~閲覧文脈$である
］ならば、
%A は %B に`近しい$ことになる。
】</p>


<hr>

<p class="algo-head">
所与の`閲覧文脈$ %A, %B に対し、次の手続きが `許容される^i を返すならば，
%A は %B に対する
`~navigateが許容され@
るとされる：
◎
A browsing context A is allowed to navigate a second browsing context B if the following algorithm terminates positively:
</p>

<ol>
	<li>
~IF［
%A ~EQ %B
］
⇒
~RET `許容される^i
◎
↓</li>
	<li>
%S ~LET［
%A にて`作動中の文書$
］の`作動中の~sandbox用~flag集合$
◎
↓</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `許容されない^i
</p>
		<ul>
			<li>
［
%B は`~top-level閲覧文脈$ではない
］~AND［
%A は %B の`先祖~閲覧文脈$でない
］~AND［
`~navi$sbox ~IN %S
］
◎
If A is not the same browsing context as B, and A is not one of the ancestor browsing contexts of B, and B is not a top-level browsing context, and A's active document's active sandboxing flag set has its sandboxed navigation browsing context flag set, then abort these steps negatively.
</li>
			<li>
<p>
［
%B は %A の`~top-level閲覧文脈$である
］~AND［
次のいずれかが満たされる
］：
◎
Otherwise, if B is a top-level browsing context, and is one of the ancestor browsing contexts of A, then:
</p>
				<ul>
					<li>
［
この~algoは`利用者による作動化から誘発されて$いる
］~AND［
`利用者~作動化~top-level~navi$sbox ~IN %S
］
◎
If this algorithm is triggered by user activation and A's active document's active sandboxing flag set has its sandboxed top-level navigation with user activation browsing context flag set, then abort these steps negatively.
</li>
					<li>
［
この~algoは`利用者による作動化から誘発されて$いない
］~AND［
`非~利用者~作動化~top-level~navi$sbox ~IN %S
］
◎
Otherwise, If this algorithm is not triggered by user activation and A's active document's active sandboxing flag set has its sandboxed top-level navigation without user activation browsing context flag set, then abort these steps negatively.
</li>
				</ul>
			</li>
			<li>
［
%B は`~top-level閲覧文脈$である
］~AND［
%B は %A の`先祖~閲覧文脈$でない
］~AND［
`~navi$sbox ~NIN %S
］~AND［
%A は %B の`許可済み~navigator$でない
］
◎
Otherwise, if B is a top-level browsing context, and is neither A nor one of the ancestor browsing contexts of A, and A's Document's active sandboxing flag set has its sandboxed navigation browsing context flag set, and A is not the one permitted sandboxed navigator of B, then abort these steps negatively.
</li>
		</ul>
	</li>
	<li>
~RET `許容される^i
◎
Otherwise, terminate positively!
</li>
</ol>

<p class="trans-note">【
最初の 2 つの段は、 3 番目の段を簡潔に記すための，訳者による追加。
】【
論理的には、 %A が %B を~navigateする機会が生じ得ないような場合（ “互いに無縁な” 閲覧文脈など）も `許容されない^i を返すべきだが、不要なので省略されていると見られる。
】</p>


<hr>

<div class="p">
<p>
要素 %E の
`閲覧文脈~視野~生成元@
は、次を走らせた結果で与えられる：
</p>

<ol>
	<li>
%文書 ~LET %E の`~node文書$
</li>
	<li>
%B ~LET %文書 が`属する閲覧文脈$
</li>
	<li>
~IF［
%B ~EQ ε
］
⇒
~RET ε
</li>
	<li>
%生成元 ~LET %文書 の`生成元$
</li>
	<li>
~FOR
%B の ~EACH ( `先祖~閲覧文脈$ %A ) に対し
⇒
~IF［
%A にて`作動中の文書$の`生成元$ ~NEQ`生成元$sub %生成元
］
⇒
~RET ε
</li>
	<li>
~RET %生成元
</li>
</ol>

◎
An element has a browsing context scope origin if its Document's browsing context is a top-level browsing context or if all of its Document's ancestor browsing contexts all have active documents whose origin are the same origin as the element's node document's origin. If an element has a browsing context scope origin, then its value is the origin of the element's node document.
</div>

		</section>
		<section id="groupings-of-browsing-contexts">
<h3 title="Groupings of browsing contexts">7.1.4. 閲覧文脈の~group分け</h3>

<p>
所与の`閲覧文脈$ %A に対し，次のいずれかを満たす`閲覧文脈$ %B は、 %A から
`直接到達可能@
とされる：
◎
Each browsing context is defined as having a list of one or more directly reachable browsing contexts. These are:
</p>

<ul>
	<li>
%B ~EQ %A
◎
The browsing context itself.
</li>
	<li>
%B の`親~閲覧文脈$ ~EQ %A
◎
All the browsing context's child browsing contexts.
</li>
	<li>
%B ~EQ %A の`親~閲覧文脈$
◎
The browsing context's parent browsing context.
</li>
	<li>
%B を`開いた閲覧文脈$ ~EQ %A
◎
All the browsing contexts that have the browsing context as their opener browsing context.
</li>
	<li>
%B ~EQ %A を`開いた閲覧文脈$
◎
The browsing context's opener browsing context.
</li>
</ul>

<p class="trans-note">【
この関係は、反射律と対称律を満たす（そのことが明白になるよう，ここでは 原文を等価な形に言い換えている）。
】</p>

<p>
`直接到達可能$な関係による推移閉包は、
`互関係~閲覧文脈~群@
を形成する。
◎
The transitive closure of all the browsing contexts that are directly reachable browsing contexts forms a unit of related browsing contexts.
</p>

<p class="trans-note">【
すなわち、推移律も満たすように
— したがって，同値律を満たすように —
“直接到達可能” を拡張した関係に基づく，同値類。
】</p>


<div class="p">
<p>
各 `互関係~閲覧文脈~群$は，更に、各~groupが次を満たすような，最も少数の~groupに分けられる
⇒
~groupのどの~memberも，その`作動中の文書$の`生成元$は，［
`document.domain$m 属性に対する適切な操作
］を通して，~groupの他の~memberにて`作動中の文書$のそれと`同じ生成元~domain$にできる一方で、他の~groupの~memberとは同じにできない。
</p>

<p>
そのような各~groupを
`互関係かつ類似生成元の閲覧文脈~群@
という。
</p>

<p class="trans-note">【
この定義が~well-definedになるためには，
“適切な操作〜”
が 対称律を満たす（可逆になる）必要があるが、それを確かめるためには，この仕様~全体を精査する必要がある。
おそらく、［
2 つの~memberが同じ~groupに属するのは、<em>両者</em> に対し ある適切な操作を施した結果が`同じ生成元~domain$になるとき
］と解釈されるべきに思われる（そう解釈すれば精査する必要もなくなる）。
】</p>

◎
Each unit of related browsing contexts is then further divided into the smallest number of groups such that every member of each group has an active document with an origin that, through appropriate manipulation of the document.domain attribute, could be made to be same origin-domain with other members of the group, but could not be made the same as members of any other group. Each such group is a unit of related similar-origin browsing contexts.
</div>


<p class="note">注記：
各 `互関係かつ類似生成元の閲覧文脈~群$ が持ち得る`~event-loop$は高々一つまでである（一方で、複数の`互関係かつ類似生成元の閲覧文脈~群$は，同じ`~event-loop$を共有し得る）。
◎
There is also at most one event loop per unit of related similar-origin browsing contexts (though several units of related similar-origin browsing contexts can have a shared event loop).
</p>



		</section>
		<section id="browsing-context-names">
<h3 title="Browsing context names">7.1.5. 閲覧文脈~名</h3>

<p>
各 `閲覧文脈$は、
`閲覧文脈~名@
を持つ。
他から指定されない限り，空~文字列とする（名前がないことを表す）。
◎
Browsing contexts can have a browsing context name. Unless stated otherwise, it is the empty string.
</p>

<p>
`妥当な閲覧文脈~名@
とは、［
空でない ~AND 最初の文字 ~NEQ `005F^U ( `_^l )
］を満たす文字列である。
（最初の文字 ~EQ `005F^U ( `_^l ) なる文字列は、次に述べる特別な~keyword用に予約される。）
◎
A valid browsing context name is any string with at least one character that does not start with a U+005F LOW LINE character. (Names starting with an underscore are reserved for special keywords.)
</p>

<div class="p">
<p>
`妥当な閲覧文脈~名または~keyword@
とは、次のいずれかを満たす文字列である：
</p>
<ul>
	<li>
`妥当な閲覧文脈~名$である
</li>
	<li>
次のいずれかに`~ASCII大小無視$で合致する
⇒
`_blank^l, `_self^l, `_parent^l, `_top^l
</li>
</ul>

◎
A valid browsing context name or keyword is any string that is either a valid browsing context name or that is an ASCII case-insensitive match for one of: _blank, _self, _parent, or _top.
</div>

<div class="p">
<p>
頁の “~link等” （
~link, ~script, ~form提出
等々）が指定する，`妥当な閲覧文脈~名または~keyword$ 値
— 以下，単に %名前 と記す —
は、頁が~sandbox化されているか否かに応じて、下の規範的でない
“表 A”
の 2 列目以降に要約されるような，それぞれに異なる意味を持つ：
</p>

<p class="trans-note">【
原文による表は、説明が省略され過ぎているので、この訳ではかなり加筆している。
】</p>

<ul>
	<li>
表の 1 列目には、 %名前, および追加の条件が示される。
</li>
	<li>
表の~~見出し［
“普通” ／ “無” ／ “有”
］の列は、表の 1 列目の条件の下で，どの`閲覧文脈$が~navigateされるかを与える（ `なし^i と記されている場合、~navigateされる閲覧文脈はない）。
</li>
	<li>
［
“無” ／ “有”
］の列は、当の “~link等” が `iframe$e 内にあって，その `iframe^e は
`sandbox$a 属性を有しているときの，その属性~値に
`allow-top-navigation$v ~keywordが［
無いとき ／ 有るとき
］の効果を与える。
</li>
	<li>
“普通” の列は、
“無” ／ “有”
に該当しないときの効果を与える。
</li>
</ul>

<p>
加えて、 “表 A” に利用される~~記号の意味を次の表に示す：
</p>

<table><thead><tr><th>記号
<th>意味
</thead>

<tbody><tr><td>`現^i<!-- current -->
<td>
%名前 を指定している “~link等” が所属している`文書$が`属する閲覧文脈$を指す。

<tr><td>`親^i<!-- parent -->
<td>
`現^i の`親~閲覧文脈$を指す。

<tr><td>`top^i
<td>
`現^i の`~top-level閲覧文脈$を指す。

<tr><td>`新^i<!-- new -->
<td>
新たな`~top-level閲覧文脈$（`補助~閲覧文脈$の場合もある）が作成されることを意味する。
これは、種々の［
利用者による選好／~UAによる施策
］の対象0になる。

<tr><td>`なし^i<!-- none -->
<td>
何も起きないことを意味する。

<tr><td>`新？^i<!-- maybe new -->
<td>
（ “無” ／ “有” の場合のみ）
`iframe^e の `sandbox$a 属性~上に
`allow-popups$v ~keywordも指定されているならば `新^i と同じ。
他の場合は `なし^i と同じ（ただし，利用者が~sandboxingを上書きした（していた）場合は、 `新^i になり得る）。

</tbody></table>

◎
These values have different meanings based on whether the page is sandboxed or not, as summarized in the following (non-normative) table. In this table, "current" means the browsing context that the link or script is in, "parent" means the parent browsing context of the one the link or script is in, "top" means the top-level browsing context of the one the link or script is in, "new" means a new top-level browsing context or auxiliary browsing context is to be created, subject to various user preferences and user agent policies, "none" means that nothing will happen, and "maybe new" means the same as "new" if the "allow-popups" keyword is also specified on the sandbox attribute (or if the user overrode the sandboxing), and the same as "none" otherwise.
</div>


<table id="_nav-table">
<caption>表 A</caption>

<thead><tr><th>
%名前, および追加の条件
<th>普通
<th>無
<th>有
</thead>

<!-- 
<thead ><tr><th rowspan="2">Keyword
<th rowspan="2">Ordinary effect
<th colspan="2">Effect in an iframe with...
<tr><th>sandbox=""
<th>sandbox="allow-top-navigation"
</thead>
-->

<tbody><tr><td>
%名前 は指定されていない
◎
none specified, for links and form submissions
<td>`現^i
<td>`現^i
<td>`現^i

<tr><td>空~文字列
<td>`現^i
<td>`現^i
<td>`現^i

</tbody>

<tbody><tr><th colspan="4" scope="rowgroup">
以下、~keywordによる %名前 の場合

<tr><td>`_blank^l
<td>`新^i
<td>`新？^i
<td>`新？^i

<tr><td>`_self^l
<td>`現^i
<td>`現^i
<td>`現^i

<tr><td>
`_parent^l ~AND
`親^i ~EQ ε
◎
_parent if there isn't a parent
<td>`現^i
<td>`現^i
<td>`現^i

<tr><td>
`_parent^l ~AND
`親^i ~EQ `top^i
◎
_parent if parent is also top
<td>`親^i （ ~EQ `top^i ）◎parent/top
<td>`なし^i
<td>`親^i◎parent/top

<tr><td>
`_parent^l ~AND
`親^i ~NIN { ε, `top^i }
◎
_parent if there is one and it's not top
<td>`親^i
<td>`なし^i
<td>`なし^i

<tr><td>
`_top^l ~AND
`top^i ~EQ `現^i
◎
_top if top is current
<td>`現^i （ ~EQ `top^i ）
<td>`現^i
<td>`現^i

<tr><td>
`_top^l ~AND
`top^i ~NEQ `現^i
◎
_top if top is not current
<td>`top^i
<td>`なし^i
<td>`top^i

</tbody>

<tbody><tr><th colspan="4" scope="rowgroup">
以下、非~keywordによる %名前 の場合
— 記号 %B は、 %名前 を`名前$とする`閲覧文脈$を表すとする。

<tr><td>
%B は存在しない
◎
name that doesn't exist
<td>`新^i
<td>`新？^i
<td>`新？^i

<tr><td>
%B は `現^i の子孫である
◎
name that exists and is a descendant
<td>%B◎specified descendant
<td>%B◎specified descendant
<td>%B◎specified descendant

<tr><td>
%B ~EQ `現^i
◎
name that exists and is current
<td>%B （ ~EQ `現^i ）
<td>%B
<td>%B

<tr><td>
%B は `現^i の先祖である
~AND
%B ~EQ `top^i
◎
name that exists and is an ancestor that is top
<td>%B （ ~EQ `top^i ）◎specified ancestor
<td>`なし^i
<td>%B◎specified ancestor/top

<tr><td>
%B は `現^i の先祖である
~AND
%B ~NEQ `top^i
◎
name that exists and is an ancestor that is not top
<td>%B◎specified ancestor
<td>`なし^i
<td>`なし^i

<tr><td>
%B は上に該当しない ~AND
%B の`~top-level閲覧文脈$ ~EQ `top^i
◎
other name that exists with common top
<td>%B◎specified
<td>`なし^i
<td>`なし^i

</tbody>

<tbody><tr><th colspan="4" scope="rowgroup">
以下、 %B の`~top-level閲覧文脈$ ~NEQ `top^i の場合

<tr><td>
%B は `現^i に`近しい$
~AND
`現^i は %B の`許可済み~navigator$である
◎
name that exists with different top, if familiar and one permitted sandboxed navigator
<td>%B◎specified
<td>%B◎specified
<td>%B◎specified

<tr><td>
%B は `現^i に`近しい$
~AND
`現^i は %B の`許可済み~navigator$でない
◎
name that exists with different top, if familiar but not one permitted sandboxed navigator
<td>%B◎specified
<td>`なし^i
<td>`なし^i

<tr><td>
%B は `現^i に`近しい$でない
◎
name that exists with different top, not familiar
<td>`新^i
<td>`新？^i
<td>`新？^i

</tbody></table>

<p class="tablenote"><small>
~sandbox化された閲覧文脈に対する制約のほとんどは、他の~algo
— 例えば `~navi$~algo —
により適用される。
`名前から閲覧文脈を選ぶ規則$ではなく。
</small>
◎
Most of the restrictions on sandboxed browsing contexts are applied by other algorithms, e.g. the navigation algorithm, not the rules for choosing a browsing context given a browsing context name given below.
</p>

<!-- 
Keyword 	Ordinary effect 	Effect in an iframe with...
sandbox="" 	sandbox="allow-top-navigation"
none specified, for links and form submissions 	current 	current 	current
empty string 	current 	current 	current
_blank 	new 	maybe new 	maybe new
_self 	current 	current 	current
_parent if there isn't a parent 	current 	current 	current
_parent if parent is also top 	parent/top 	none 	parent/top
_parent if there is one and it's not top 	parent 	none 	none
_top if top is current 	current 	current 	current
_top if top is not current 	top 	none 	top
name that doesn't exist 	new 	maybe new 	maybe new
name that exists and is a descendant 	specified descendant 	specified descendant 	specified descendant
name that exists and is current 	current 	current 	current
name that exists and is an ancestor that is top 	specified ancestor 	none 	specified ancestor/top
name that exists and is an ancestor that is not top 	specified ancestor 	none 	none
other name that exists with common top 	specified 	none 	none
name that exists with different top, if familiar and one permitted sandboxed navigator 	specified 	specified 	specified
name that exists with different top, if familiar but not one permitted sandboxed navigator 	specified 	none 	none
name that exists with different top, not familiar 	new 	maybe new 	maybe new

Most of the restrictions on sandboxed browsing contexts are applied by other algorithms, e.g. the navigation algorithm, not the rules for choosing a browsing context given a browsing context name given below.
-->

<hr>

<p class="algo-head">
所与の %名前 から
`閲覧文脈を選ぶ規則@
は、次で与えられる。
この規則は、ある`閲覧文脈$ %B の文脈~下で，ある`~task$ %~task の実行の一部として適用されることを~~前提とし、［
既存の`閲覧文脈$, 新たな`閲覧文脈$, ε（何も選ばれない）
］のいずれかを返す：
◎
The rules for choosing a browsing context given a browsing context name are as follows. The rules assume that they are being applied in the context of a browsing context, as part of the execution of a task.
</p>

<ol>
	<li>
<p>
%名前 に応じて：
◎
↓</p>

		<dl class="switch">
			<dt>空~文字列</dt>
			<dt>`_self^l</dt>
			<dd>
~RET %B
◎
If the given browsing context name is the empty string or _self, then the chosen browsing context must be the current one.
</dd>

			<dt>`_parent^l</dt>
			<dd>
~RET ［
%B の`親~閲覧文脈$ ~NEQ ε ならば それ ／
~ELSE_ %B
］
◎
If the given browsing context name is _parent, then the chosen browsing context must be the parent browsing context of the current one, unless there isn't one, in which case the chosen browsing context must be the current browsing context.
</dd>

			<dt>`_top^l</dt>
			<dd>
~RET ［
%B の`~top-level閲覧文脈$ ~NEQ ε ならば それ ／
~ELSE_ %B
］
◎
If the given browsing context name is _top, then the chosen browsing context must be the top-level browsing context of the current one, if there is one, or else the current browsing context.
</dd>

			<dt>`_blank^l</dt>
			<dd>
~GOTO `NEW^i
</dd>

			<dt>その他</dt>
			<dd>
<p>
~IF［
次のいずれも満たすような閲覧文脈 %B1 は存在する
］…
</p>

<ul><li>%B1 の`名前$ ~EQ %名前
</li><li>%B は %B1 に`近しい$
</li><li>~UAは， %B, %B1 が互いに到達してもよいほどに十分~関係すると決定した
</li></ul>

<p>
…ならば
⇒
~RET そのような閲覧文脈のうちのいずれか
⇒
該当する %B1 が複数ある場合、~UAは，そのうち一つを［
何らかの，一貫した, 任意の方式
］で選定するべきである
— 例えば［
最も近過去に開いたもの ／
最も近過去に~focusされたもの ／
より近く関係するもの
］など。
</p>

<p>
~ELSE
⇒
~GOTO `NEW^i
</p>

◎
If the given browsing context name is not _blank and there exists a browsing context whose name is the same as the given browsing context name, and the current browsing context is familiar with that browsing context, and the user agent determines that the two browsing contexts are related enough that it is ok if they reach each other, then that browsing context must be the chosen one. If there are multiple matching browsing contexts, the user agent should select one in some arbitrary consistent manner, such as the most recently opened, most recently focused, or more closely related.
</dd>

		</dl>
	</li>
	<li>
<p>
`NEW^i （新たな閲覧文脈が要請されている
— 何が起こるかは、~UAの環境設定と能に依存する）：
◎
Otherwise, a new browsing context is being requested, and what happens depends on the user agent's configuration and abilities — it is determined by the rules given for the first applicable option from the following list:
</p>

		<ol>
			<li>
%新~閲覧文脈 ~LET ε
◎
↓</li>
			<li>
%S ~LET［
%B にて`作動中の文書$
］の`作動中の~sandbox用~flag集合$
◎
↓</li>
			<li id="popup-blocker">
~IF［
%~task は、`利用者による作動化から誘発されて$いない
］~AND［
~UAは~popupを示さないよう環境設定されている（すなわち，~UAは “popup blocker” が可能化されている）
］
⇒
~RET ε
— ~UAは、~popupを阻止したことを利用者に伝えてよい。
◎
If the algorithm is not triggered by user activation and the user agent has been configured to not show popups (i.e. the user agent has a "popup blocker" enabled)
◎
There is no chosen browsing context. The user agent may inform the user that a popup has been blocked.
</li>
			<li id="sandboxWindowOpen">
<p>
~IF［
`補助~navi$sbox ~IN %S
］（概して，閲覧文脈は選ばれていない）：
◎
If the current browsing context's active document's active sandboxing flag set has the sandboxed auxiliary navigation browsing context flag set.
◎
Typically, there is no chosen browsing context.
</p>
				<ol>
					<li>
~UAの任意選択で
⇒
~RET ε
◎
↓</li>
					<li>
<div class="p">
<p>
利用者に，次の選択肢を提供0する：
</p>

<ul ><li>新たな~top-level閲覧文脈
⇒
%新~閲覧文脈 ~SET `新たに作成-$した`~top-level閲覧文脈$
</li><li>既存のものを再利用する
⇒
~RET %B
` “既存のもの” が何を指すか原文に明記されていないが，おそらく。^tnote 
</li><li>辞退する
⇒
~RET ε
</li></ul>

<p>
辞退しなかった場合でも、選ばれた閲覧文脈の`名前$には %名前 は設定されない。
</p>
◎
The user agent may offer to create a new top-level browsing context or reuse an existing top-level browsing context. If the user picks one of those options, then the designated browsing context must be the chosen one (the browsing context's name isn't set to the given browsing context name). The default behavior (if the user agent doesn't offer the option to the user, or if the user declines to allow a browsing context to be used) must be that there must not be a chosen browsing context.
</div>

<p class="warning">
この事例が生じた場合、作者は，~linkを開こうと試行している文書を明示的に~sandbox化していることを意味する。
◎
If this case occurs, it means that an author has explicitly sandboxed the document that is trying to open a link.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
%~task に対する~UAの環境設定に応じて：
</p>
				<dl class="switch">
					<dt id="noopener">
新たな閲覧文脈を作成するように環境設定されている
◎
If the user agent has been configured such that in this instance it will create a new browsing context:
</dt>
					<dd>
<p>
%新~閲覧文脈 ~SET 次のようにされた新たな閲覧文脈
⇒
`開いた閲覧文脈$ ~SET %B；<br>
`名前$ ~SET ［
%名前 ~NEQ `_blank^l ならば %名前 ／
~ELSE_ 空~文字列
］
◎
A new auxiliary browsing context must be created, with the opener browsing context being the current one. If the given browsing context name is not _blank, then the new auxiliary browsing context's name must be the given browsing context name (otherwise, it has no name). The chosen browsing context must be this new browsing context.
</p>

<p class="note">注記：
新たに作成された`閲覧文脈$が即時に`~navigate$される場合、その~naviは，［
`置換え可能化~flag$ ~SET ~ON
］の下で行われることになる。
◎
If the newly created browsing context is immediately navigated, then the navigation will be done with replacement enabled.
</p>
					</dd>

					<dt>
%B を再利用するように環境設定されている
◎
If the user agent has been configured such that in this instance it will reuse the current browsing context
</dt>
					<dd>
~RET %B
◎
The chosen browsing context is the current browsing context.
</dd>

					<dt>
閲覧文脈を見出さないように環境設定されている
◎
If the user agent has been configured such that in this instance it will not find a browsing context
</dt>
					<dd>
~RET ε
◎
There must not be a chosen browsing context.
</dd>
				</dl>
			</li>
		</ol>

<p>
~UA実装者には、利用者に［
~UAが常に %B を再利用するように環境設定する仕方
］を提供することが奨励される。
◎
User agent implementors are encouraged to provide a way for users to configure the user agent to always reuse the current browsing context.
</p>

	</li>
	<li>
~IF［
`~navi$sbox ~IN %S
］
⇒
%新~閲覧文脈 の`許可済み~navigator$ ~SET %B 
◎
If the chosen browsing context picked above, if any, is a new browsing context, then:
◎
Let flagSet be the current browsing context's active document's active sandboxing flag set.
◎
If flagSet's sandboxed navigation browsing context flag is set, then the current browsing context must be set as the new browsing context's one permitted sandboxed navigator.
</li>
	<li>
~IF［
`~sandboxは補助~閲覧文脈に伝播する~flag$ ~IN %S
］
⇒
%新~閲覧文脈 の`~popup~sandbox用~flag集合$ ~SET %S ∪ %X の`~popup~sandbox用~flag集合$
◎
If flagSet's sandbox propagates to auxiliary browsing contexts flag is set, then all the flags that are set in flagSet must be set in the new browsing context's popup sandboxing flag set.
</li>
	<li>
~RET %新~閲覧文脈
◎
↑</li>
</ol>


		</section>
		<section id="script-settings-for-browsing-contexts">
<h3 title="Script settings for browsing contexts">7.1.6. 閲覧文脈に対する~script設定群</h3>

<p class="algo-head">
~UAは，
`閲覧文脈~用に環境~設定群~objを設定して@
おくことが要求されたときは、所与の
( `~JS実行~文脈$ %実行~文脈, `環境$ `予約済み環境^V （省略時は ε ） )
に対し，次を走らせ~MUST：
◎
When the user agent is required to set up a browsing context environment settings object, given a JavaScript execution context execution context and an optional environment reserved environment, it must run the following steps:
</p>

<ol>
	<li>
%realm ~LET %実行~文脈 の Realm 成分の値
◎
Let realm be the value of execution context's Realm component.
</li>
	<li>
%window ~LET %realm の`大域~obj$relem
◎
Let window be realm's global object.
</li>
	<li>
%url ~LET %window に`結付けられている文書$の`~URL$docの複製
◎
Let url be a copy of the URL of window's associated Document.
</li>
	<li>
<p>
%設定群~obj ~LET
各種~algoが次のように定義される，新たな`環境~設定群~obj$
— 以下における %現~文書 とは、~algoが呼出された時点で
%window に`結付けられている文書$を表すとする：
◎
Let settings object be a new environment settings object whose algorithms are defined as follows:
</p>

		<dl>
			<dt>
`~realm実行~文脈$enV
◎
The realm execution context
</dt>
			<dd>
~RET %実行~文脈
◎
Return execution context.
</dd>

			<dt>
`~module~map$enV
◎
The module map
</dt>
			<dd>
~RET 
%現~文書 の`~module~map$doc
◎
Return the module map of window's associated Document.
</dd>

			<dt>
`担当の閲覧文脈$enV
◎
The responsible browsing context
</dt>
			<dd>
~RET %window に`対応する閲覧文脈$
◎
Return the browsing context with which window is associated.
</dd>

			<dt>
`担当の~event-loop$enV
◎
The responsible event loop
</dt>
			<dd>
~RET `担当の閲覧文脈$enVが所属している［
`互関係かつ類似生成元の閲覧文脈~群$
］に結付けられている`~event-loop$
◎
Return the event loop that is associated with the unit of related similar-origin browsing contexts to which window's browsing context belongs.
</dd>

			<dt>
`担当の文書$enV
◎
The responsible document
</dt>
			<dd>
~RET %現~文書
◎
Return window's associated Document.
</dd>
			<dt>
`~API~URL文字~符号化方式$enV
◎
The API URL character encoding
</dt>
			<dd>
~RET %現~文書 の現在の`文字~符号化方式$doc
◎
Return the current character encoding of window's associated Document.
</dd>

			<dt>
`~API基底~URL$enV
◎
The API base URL
</dt>
			<dd>
~RET %現~文書 の現在の`基底~URL$doc
◎
Return the current base URL of window's associated Document.
</dd>

			<dt>
`生成元$enV
◎
The origin
</dt>
			<dd>
~RET %現~文書 の`生成元$
◎
Return the origin of window's associated Document.
</dd>
			<dt>
`~HTTPS状態$enV
◎
The HTTPS state
</dt>
			<dd>
~RET %現~文書 の`~HTTPS状態$doc
◎
Return the HTTPS state of window's associated Document.
</dd>
			<dt>
`~referrer施策$enV
◎
The referrer policy
</dt>
			<dd>
				<ol>
					<li>
%文書 ~LET %現~文書
◎
Let document be the Document with which window is currently associated.
</li>
					<li>
~WHILE［
%文書 は`~iframe~srcdoc文書$である
］~AND［
%文書 の`~referrer施策$doc ~EQ 空~文字列
］
⇒
%文書 ~SET %文書 が`属する閲覧文脈$の`閲覧文脈~容器$の`~node文書$
◎
While document is an iframe srcdoc document and document's referrer policy is the empty string, set document to document's browsing context's browsing context container's node document.
</li>
					<li>
~RET %文書 の`~referrer施策$doc
◎
Return document's referrer policy.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
<p>
~IF［
`予約済み環境^V ~NEQ ε
］：
◎
If reserved environment is given, then:
</p>
		<ol>
			<li>
%設定群~obj の
( `~id$enV, `作成時の~URL$enV, `~target閲覧文脈$enV, `作動中の~service-worker$enV )
~SET `予約済み環境^V の ( それら )
◎
Set settings object's id to reserved environment's id, settings object's creation URL to reserved environment's creation URL, settings object's target browsing context to reserved environment's target browsing context, and settings object's active service worker to reserved environment's active service worker.
</li>
			<li>
<p>
`予約済み環境^V の`~id$enV ~SET 空~文字列
◎
Set reserved environment's id to the empty string.
</p>

<p class="note">注記：
この時点から、 `予約済み環境^V の~id（ identity ）は %設定群~obj に全部的に転送されたものと見なされ、`環境$の`~id$enVにより探索し得なくなる。
◎
The identity of the reserved environment is considered to be fully transferred to the created environment settings object. The reserved environment is not searchable by the environment’s id from this point on.
</p>
 			</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%設定群~obj の
( `~id$enV, `作成時の~URL$enV, `~target閲覧文脈$enV, `作動中の~service-worker$enV )
~SET
( 新たな一意かつ不透明な文字列, %~url, ~NULL, ~NULL )
◎
Otherwise, set settings object's id to a new unique opaque string, settings object's creation URL to url, settings object's target browsing context to null, and settings object's active service worker to null.
</li>
	<li>
%realm の `HostDefined^sl ~field ~SET %設定群~obj
◎
Set realm's [[HostDefined]] field to settings object.
</li>
	<li>
~RET %設定群~obj
◎
Return settings object.
</li>
</ol>

		</section>
	</section>

	<section id="cross-origin-objects">
<h2 title="Security infrastructure for Window, WindowProxy, and Location objects">7.2. `Window^I, `WindowProxy^I, `Location^I ~objのための保安~基盤</h2>

<p class="trans-note">【
この節の内容は、
<a href="~HTMLWPROXY#cross-origin-objects">別ページ</a>
にて。
】</p>


	</section>
	<section id="the-window-object">
<h2 title="The Window object">7.3. `Window^I ~obj</h2>


<pre class="idl">
[PrimaryGlobal, LegacyUnenumerableNamedProperties]
interface `Window@I : `EventTarget$I {
  /* <span class="comment"
>現在の閲覧文脈
◎
the current browsing context
</span> */
  [Unforgeable] readonly attribute `WindowProxy$I `window$m;
  [Replaceable] readonly attribute `WindowProxy$I `self$m;
  [Unforgeable] readonly attribute `Document$I `document$m;
  attribute DOMString `name$m; 
  [PutForwards=`href$m, Unforgeable] readonly attribute `Location$I `location$m;
  readonly attribute `History$I `history$m;
  readonly attribute `CustomElementRegistry$I `customElements$m;
  [Replaceable] readonly attribute `BarProp$I `locationbar$m;
  [Replaceable] readonly attribute `BarProp$I `menubar$m;
  [Replaceable] readonly attribute `BarProp$I `personalbar$m;
  [Replaceable] readonly attribute `BarProp$I `scrollbars$m;
  [Replaceable] readonly attribute `BarProp$I `statusbar$m;
  [Replaceable] readonly attribute `BarProp$I `toolbar$m;
  attribute DOMString `status$m;
  void `close$m();
  readonly attribute boolean `closed$m;
  void `stop$m();
  void `focus$m();
  void `blur$m();

  /* <span class="comment"
>他の閲覧文脈
◎
other browsing contexts
</span> */
  [Replaceable] readonly attribute `WindowProxy$I `frames$m;
  [Replaceable] readonly attribute unsigned long `~length0$m;
  [Unforgeable] readonly attribute `WindowProxy$I? `top$m;
  attribute any `opener$m;
  [Replaceable] readonly attribute `WindowProxy$I? `parent$m;
  readonly attribute `Element$I? `frameElement$m;
  `WindowProxy$I? `open$m(
      optional USVString %url = "about:blank",
      optional DOMString %target = "_blank",
      [TreatNullAs=EmptyString] optional DOMString %features = ""
  );
  `getter$m `object$I (DOMString %name);  /* <span class="comment"
>これは大域~objなので、 IDL 有名~prop取得子は，~prototype-chain上に `NamedPropertiesObject^I ~exotic~objを追加する。
~~実際、これが大域~objを~exotic~objにすることはない。
~indexによる~accessは `WindowProxy$I ~exotic~objが引き受ける。
◎
Since this is the global object, the IDL named getter adds a NamedPropertiesObject exotic object on the prototype chain. Indeed, this does not make the global object an exotic object. Indexed access is taken care of by the WindowProxy exotic object.
</span> */

  /* <span class="comment"
>~UA
◎
the user agent
</span> */
  readonly attribute `Navigator$I `navigator$m; 
  readonly attribute `ApplicationCache$I `applicationCache$m;

  /* <span class="comment"
>利用者~向けの~prompt
◎
user prompts
</span> */
  void `alert$m();
  void `alert$m(DOMString %message);
  boolean `confirm$m(optional DOMString %message = "");
  DOMString? `prompt$m(
      optional DOMString %message = "",
      optional DOMString %default = ""
  );
  void `print$m();

  unsigned long `requestAnimationFrame$m(`FrameRequestCallback$I %callback);
  void `cancelAnimationFrame$m(unsigned long %handle);

  void `postMessage$m(
      any %message,
      USVString %targetOrigin,
      optional sequence&lt;`object$I&gt; %transfer =[]
  );
};
`Window$I implements `GlobalEventHandlers$I;
`Window$I implements `WindowEventHandlers$I;

callback `FrameRequestCallback@I = void (`DOMHighResTimeStamp$I %time);
</pre>

<!-- `Window@I -->

<dl class="domintro">
	<dt>%window . `window$m</dt>
	<dt>%window . `frames$m</dt>
	<dt>%window . `self$m</dt>
	<dd>
これらの属性はいずれも %window を返す。
◎
These attributes all return window.
</dd>

	<dt>%window . `document$m</dt>
	<dd>
%window に`結付けられている文書$を返す。
◎
Returns the Document associated with window.
</dd>

	<dt>%document . `defaultView$m</dt>
	<dd>
`作動中の文書$の `~window$ を返す。
◎
Returns the Window object of the active document.
</dd>
</dl>


<p>
各`~window$には、`文書$が
`結付けられる@doc
。
それは、`~window$の作成-時に初期 `about_blank$sc `文書$に設定され、`~navi$の間に限り，そこから変化する。
◎
The Window has an associated Document, which is a Document object. It is set when the Window object is created, and only ever changed during navigation from the initial about:blank Document.
</p>

<p>
`~window$ %W に`結付けられている文書$が`属する閲覧文脈$を指して、単に，
%W に
`対応する閲覧文脈@
という
— それは、 %W を包装している `WindowProxy$I ~objを結付けている`閲覧文脈$と言っても同じである。
</p>

<p class="trans-note">【
この語は、簡便に記すため，この訳にて導入したもの。
】</p>



<dl class="idl-def">
	<dt>`window@m</dt>
	<dt>`frames@m</dt>
	<dt>`self@m</dt>
	<dd>
これらの属性の取得子は、此れに`対応する閲覧文脈$の `WindowProxy$I ~objを返さ~MUST。
<!-- ＊ ε？ -->
◎
The window, frames, and self IDL attributes, on getting, must all return this Window object's browsing context's WindowProxy object.
</dd>

	<dt>`document@m</dt>
	<dd>
取得子は、此れに`結付けられている文書$を返さ~MUST。
◎
The document IDL attribute, on getting, must return this Window object's associated Document.
</dd>

	<dd class="note">注記：
`~window$に`結付けられている文書$が変化し得る事例は、唯一，［
`~navigate$ ~algoが，`閲覧文脈$内に最初の頁を読込むために`新たな文書を初期化する$
］ときに限られる。
その事例では、元の `about_blank$sc 頁の `~window$が再利用され，新たな`文書$を取得する。
◎
The Document object associated with a Window object can change in exactly one case: when the navigate algorithm initializes a new Document object for the first page loaded in a browsing context. In that specific case, the Window object of the original about:blank page is reused and gets a new Document object.
</dd>
</dl>

<p>
`Document$I 上の
`defaultView@m
取得子は、［
此れが`属する閲覧文脈$ ~NEQ ε ならば その `WindowProxy$I ~obj ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The defaultView IDL attribute of the Document interface, on getting, must return this Document's browsing context's WindowProxy object, if this Document has an associated browsing context, or null otherwise.
</p>

<hr>


<div class="p">
<p>
歴史的~事由から、各`~window$は、次の特徴を備える~propを持た~MUST：
</p>

<ul ><li>writable, configurable, 非 enumerable
</li><li>名前： `HTMLDocument@l
</li><li>値： `Document$I interface object
</li></ul>
◎
For historical reasons, Window objects must also have a writable, configurable, non-enumerable property named HTMLDocument whose value is the Document interface object.
</div>

		<section id="apis-for-creating-and-navigating-browsing-contexts-by-name">
<h3 title="APIs for creating and navigating browsing contexts by name">7.3.1 閲覧文脈を名前で作成-／~navigateするための~API</h3>

<dl class="domintro">
	<dt>%window = %window . `open$m( [ %url [, %target [, %features ] ] ] )</dt>
	<dd>
~windowを開いて %url （省略時は `about_blank$sc ）を示した上で、それを返す。
%target 引数には，新たな~windowの名前を与える。
その名前の~windowがすでに存在する場合、それが再利用される。
%features 引数を利用すれば、新たな~windowの描画に波及させられる。
◎
Opens a window to show url (defaults to about:blank), and returns it. The target argument gives the name of the new window. If a window exists with that name already, it is reused. The features argument can be used to influence the rendering of the new window.
</dd>

	<dt>%window . `name$m [ = %value ]</dt>
	<dd>
この~windowの名前を返す。
◎
Returns the name of the window.
</dd>
	<dd>
設定して，名前を変更できる。
◎
Can be set, to change the name.
</dd>

	<dt>%window . `close$m()</dt>
	<dd>
この~windowを閉じる。
◎
Closes the window.
</dd>

	<dt>%window . `closed$m</dt>
	<dd>
この~windowは［
すでに閉じられたなら ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the window has been closed, false otherwise.
</dd>

	<dt>%window . `stop$m()</dt>
	<dd>
文書の読込を取消す。
◎
Cancels the document load.
</dd>
</dl>


<dl class="idl-def">
	<dt>`open(url, target, features)@m</dt>
	<dd>
この~methodは、［
既存の`閲覧文脈$を`~navigate$する ／
`補助~閲覧文脈$を開いて~navigateする
］ための仕組みを提供する。
◎
The open(url, target, features) method on Window objects provides a mechanism for navigating an existing browsing context or opening and navigating an auxiliary browsing context.
</dd>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
When the method is invoked, the user agent must run the following steps:
</p>

<ol>
	<li>
%~entry設定群 ~LET `~entry設定群~obj$
◎
Let entry settings be the entry settings object.
</li>
	<li>
%~source閲覧文脈 ~LET
%~entry設定群 により指定される`担当の閲覧文脈$enV
◎
Let source browsing context be the responsible browsing context specified by entry settings.
</li>
	<li>
~IF［
%target ~EQ 空~文字列
］
⇒
%target ~LET `_blank^l
◎
If target is the empty string, let it be the string "_blank" instead.
</li>
	<li>
<p>
~IF［
利用者から，何らかの`閲覧文脈$へ~navigateする選好が指示されている
］：
◎
If the user has indicated a preference for which browsing context to navigate, follow these substeps:
</p>


		<ol>
			<li>
%~target閲覧文脈 ~LET 利用者から指示されている`閲覧文脈$
◎
Let target browsing context be the browsing context indicated by the user.
</li>
			<li>
~IF［
%~target閲覧文脈 は新たな`~top-level閲覧文脈$である
］
⇒
%~target閲覧文脈 の`許可済み~navigator$ ~SET %~source閲覧文脈
◎
If target browsing context is a new top-level browsing context, let the source browsing context be set as target browsing context's one permitted sandboxed navigator.
</li>
		</ol>

<p class="example">
例えば~UAが、~linkに対し［
~Ctrl ＆ ~click
］で新たな~tabに開くことを~supportしていて，その~UAの利用者が要素を~clickしたとき、対する `onclick^m ~handlerは ~iframe内に頁を開くために `window.open()$m ~APIを利用していたとする。
この~click時に ~Ctrl ~keyも押され続けていた場合、~UAは，~target閲覧文脈の選定を上書きして，新たな~tabを~targetにすることもできる。
◎
For example, suppose there is a user agent that supports control-clicking a link to open it in a new tab. If a user clicks in that user agent on an element whose onclick handler uses the window.open() API to open a page in an iframe, but, while doing so, holds the control key down, the user agent could override the selection of the target browsing context to instead target a new tab.
</p>

	</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
%~target閲覧文脈 ~LET ［
%~source閲覧文脈 の文脈~下で，名前 %target から`閲覧文脈を選ぶ規則$を適用して得られる`閲覧文脈$
］
</li>
			<li>
~IF［
%~target閲覧文脈 ~EQ ε
］
⇒
~RET ~NULL
</li>
		</ol>

◎
Otherwise, apply the rules for choosing a browsing context given a browsing context name using target as the name and source browsing context as the context in which the algorithm is executed. If this results in there not being a chosen browsing context, then return null. Otherwise, let target browsing context be the browsing context so obtained.
</li>
	<li>
%new ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%~target閲覧文脈 は、［
`名前から閲覧文脈を選ぶ規則$の一部
］として, または［
新たな`~top-level閲覧文脈$へ~navigateする選好が，利用者から指示されている
］ことに因り，作成されたものである
◎
If target browsing context was just created, either as part of the rules for choosing a browsing context given a browsing context name or due to the user indicating a preference for navigating a new top-level browsing context, then let new be true. Otherwise, let it be false.
</li>
	<li>
`CSSOMVIEW$r に定義されるように
<a href="~CSSOMVIEW#the-features-argument-to-the-open()-method">%features を解釈する</a>
◎
Interpret features as defined in the CSSOM View specification. [CSSOMVIEW]
</li>
	<li>
%資源~URL ~LET "`about_blank$sc"
◎
↓</li>
	<li>
<p>
~IF［
%url ~EQ 空~文字列
］
⇒
~IF［
%new ~EQ ~T
］
⇒
~GOTO `End^i
◎
If url is the empty string, run the appropriate steps from the following list:
• If new is false
•• Jump to the step labeled end.
• If new is true
•• Let resource be the URL "about:blank".
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
%url ~LET %url を %~entry設定群 に`相対的に構文解析-$した`結果の~URL文字列$
</li>
			<li>
~IF［
%url ~NEQ ~error
］
⇒
%資源~URL ~SET %url
</li>
			<li>
<p>
~ELSE
⇒
~UAの任意選択で、次のいずれかを行う：
</p>
				<ul>
					<li>
<ol><li>%資源~URL ~SET ~inline~error頁を表現する資源~URL
</li></ol>
					</li>
					<li>
<ol><li>~IF［
%new ~EQ ~F
］
⇒
~GOTO `End^i
</li></ol>
					</li>
				</ul>
			</li>
		</ol>
◎
Otherwise, parse url relative to entry settings, and let resource be the resulting URL record, if any. If the parse a URL algorithm failed, then run one of the following two steps instead:
• Let resource be a resource representing an inline error page.
• If new is false, jump to the step labeled end, otherwise, let resource be the URL "about:blank".
</li>
	<li>
~IF［
%資源~URL ~EQ "`about_blank^sc"
］~AND［
%new ~EQ ~T
］
⇒
次を走らす`~taskを待入する$
⇒
%~target閲覧文脈 の`~window$に向けて，名前 `load$et の`~eventを発火する$
— ［
`旧来の上書き~target~flag^V ~SET ~ON
］にした下で
◎
If resource is "about:blank" and new is true, then queue a task to fire an event named load at target browsing context's Window object, with legacy target override flag set.
</li>
	<li>
<p>
~ELSE
⇒
次を与える下で，
%~target閲覧文脈 を %資源~URL へ`~navigate$する（例外投出あり）
</p>

<ul><li>`例外~可能化~flag$ ~SET ~ON
</li><li>`置換え可能化~flag$ ~SET ［
%new ~EQ ~T ならば ~ON ／ ~ELSE_ ~OFF
］
</li><li>`~source閲覧文脈$ ~SET %~source閲覧文脈
</li></ul>

◎
Otherwise, navigate target browsing context to resource, with the exceptions enabled flag set. If new is true, then replacement must be enabled. The source browsing context is source browsing context. Rethrow any exceptions.
</li>
	<li>
`End^i：
<p>
~IF［
`noopener^l ~IN ［
%features を`~commaで分割-$した結果
］］：
</p>
		<ol>
			<li>
此れの `opener$m の値 ~SET ~NULL
<!--＊ disown target browsing context's opener  -->
</li>
			<li>
~RET ~NULL
</li>
		</ol>
◎
End:
◎
If the result of splitting features on commas contains the token "noopener", then disown target browsing context's opener and return null.
</li>
	<li>
~RET %~target閲覧文脈 の `WindowProxy$I ~obj
◎
Otherwise, return the WindowProxy object of target browsing context.
</li>
</ol>

	</dd>

	<dt>`name@m</dt>
	<dd>
取得子は、`閲覧文脈$の現在の`名前$を返さ~MUST。
設定子は、`閲覧文脈$の`名前$を新たな値に設定し~MUST。
◎
The name attribute of the Window object must, on getting, return the current name of the browsing context; and, on setting, set the name of the browsing context to the new value.
</dd>
	<dd class="note">注記：
`名前$は、閲覧文脈が別の`生成元$へ`~navigate$されたときは，
<a href="~NAVI#resetBCName">再設定される</a>
。
◎
The name gets reset when the browsing context is navigated to another origin.
</dd>

	<dt>`close()@m</dt>
	<dd>
<p>
被呼出時には、次の条件がいずれも満たされるならば，`閲覧文脈$ %B を`閉じる$べきである：
◎
The close() method on Window objects should, if all the following conditions are met, close the browsing context A:
</p>

<ul>
	<li>
%B は`~scriptから閉じれる$。
◎
The corresponding browsing context A is script-closable.
</li>
	<li>
<p>
`現任の設定群~obj$により指定される`担当の閲覧文脈$enVを %B1 とするとき：
</p>

<ul><li>%B1 は %B に`近しい$, かつ
</li><li id="sandboxClose">%B1 は %B に対する`~navigateが許容され$ている
</li></ul>

◎
The responsible browsing context specified by the incumbent settings object is familiar with the browsing context A.
◎
The responsible browsing context specified by the incumbent settings object is allowed to navigate the browsing context A.
</li>
</ul>
	</dd>
	<dd>
<p>
次のいずれかを満たす`閲覧文脈$ %B は、
`~scriptから閉じれる@
とされる：
</p>

<ul>
	<li>
%B は、~scriptが作成した`補助~閲覧文脈$である（利用者による動作ではなく）
</li>
	<li>
%B は`~top-level閲覧文脈$である
~AND
%B の`~session履歴$に含まれる`文書$は 1 つだけである
</li>
</ul>

◎
A browsing context is script-closable if it is an auxiliary browsing context that was created by a script (as opposed to by an action of the user), or if it is a top-level browsing context whose session history contains only one Document.
</dd>

	<dt>`closed@m</dt>
	<dd>
取得子は、［
`閲覧文脈$はすでに`破棄-$されたならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The closed attribute on Window objects must return true if the Window object's browsing context has been discarded, and false otherwise.
</dd>

	<dt>`stop()@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせる~SHOULDである：
</p>

<ol>
	<li>
~IF［
`閲覧文脈$を`~navigate$しようとする既存の試みがある
］~AND［
その試みは`文書を~unload$する~algoを現在~走らせていない
］
⇒
此れの`閲覧文脈$にて`作動中の文書$を`中止-$して、その`~navi$を取消す
</li>
</ol>

◎
The stop() method on Window objects should, if there is an existing attempt to navigate the browsing context and that attempt is not currently running the unload a document algorithm, cancel that navigation; then, it must abort the active document of the browsing context of the Window object on which it was invoked.
</dd>

</dl>


		</section>
		<section id="accessing-other-browsing-contexts">
<h3 title="Accessing other browsing contexts">7.3.2. 他の閲覧文脈への~access法</h3>

<dl class="domintro">
	<dt>%window . `~length0$m</dt>
	<dd>
`文書~木に属する子~閲覧文脈$の個数を返す。
◎
Returns the number of document-tree child browsing contexts.
</dd>

	<dt>%window[%index]</dt>
	<dd>
`文書~木に属する子~閲覧文脈$のうち，
%index で指示されるものを返す。
◎
Returns the indicated document-tree child browsing context.
</dd>
</dl>

<dl class="idl-def">
	<dt>`~length0@m</dt>
	<dd id="number-of-document-tree-child-browsing-contexts">
取得子は、此れに`結付けられている文書$が`属する閲覧文脈$の`文書~木に属する子~閲覧文脈$たちの個数を返さ~MUST
◎
The number of document-tree child browsing contexts of a Window object W is the number of document-tree child browsing contexts of W's associated Document's browsing context.
◎
The length IDL attribute's getter must return the number of document-tree child browsing contexts of this Window object.
</dd>
</dl>

<p class="note">注記：
~indexによる`文書~木に属する子~閲覧文脈$への~accessは、
`WindowProxy$I ~objの `GetOwnProperty$sl 内部~methodを通して定義される
◎
Indexed access to document-tree child browsing contexts is defined through the [[GetOwnProperty]] internal method of the WindowProxy object.
</p>

		</section>
		<section id="named-access-on-the-window-object">
<h3 title="Named access on the Window object">7.3.3. `Window^I ~objに対する名前による~access</h3>

<dl class="domintro">
	<dt>%window[%name]</dt>
	<dd>
指示された要素（たち）の~collectionを返す。
◎
Returns the indicated element or collection of elements.
</dd>
	<dd>
一般に、これに依拠すると，~codeは壊れやすくなる。
例えば、~Web~platformに新たな特色機能が追加されるに伴い，どの ID がこの~APIに対応付けられるかは時を経るに伴い変わり得るので。
代わりに，
`document.getElementById()^m ／
`document.querySelector()^m
を利用すること。
◎
As a general rule, relying on this will lead to brittle code. Which IDs end up mapping to this API can vary over time, as new features are added to the Web platform, for example. Instead of this, use document.getElementById() or document.querySelector().
</dd>
</dl>


<p>
`~window$ %W の
`文書~木に属する子~閲覧文脈~名~prop集合@
は、次の手続きの結果で与えられる：
◎
The document-tree child browsing context name property set of a Window object window is the return value of running these steps:
</p>

<ol>
	<li>
%名前~list ~LET 空~list
◎
↓</li>
	<li>
%文書 ~LET %W に`対応する閲覧文脈$にて`作動中の文書$
◎
Let activeDocument be window's browsing context's active document.
</li>
	<li>
%子~閲覧文脈~list ~LET %文書 が`属する閲覧文脈$の`文書~木に属する子~閲覧文脈$たちからなる~list
<!-- ＊通して入子に？ -->
◎
↓</li>
	<li>
<p>
%子~閲覧文脈~list 内の ~EACH ( %B ) に対し：
</p>
		<ol>
			<li>
%名前 ~LET %B の`閲覧文脈~名$
</li>
			<li>
~IF［
%名前 ~EQ 空~文字列
］
⇒
~CONTINUE
</li>
			<li>
%子~閲覧文脈~list から， %B 以外の［
`閲覧文脈~名$ ~EQ %名前
］なる`閲覧文脈$すべてを除去する
（除去されたものに対する反復は飛ばすことになる）
</li>
			<li>
~IF［
%名前 ~NEQ %B の`閲覧文脈~容器$の `name^a 内容~属性~値
］~AND［
%B にて`作動中の文書$の`生成元$ ~NEQ`生成元$sub %文書 の`生成元$
］
⇒
~CONTINUE
</li>
			<li>
%名前~list に %名前 を付加する
</li>
		</ol>
◎
Let childBrowsingContexts be all document-tree child browsing contexts of activeDocument's browsing context whose browsing context name is not the empty string, in order, and including only the first document-tree child browsing context with a given name if multiple document-tree child browsing contexts have the same one.
◎
Remove each browsing context from childBrowsingContexts whose active document's origin is not same origin with activeDocument's origin and whose browsing context name does not match the name of its browsing context container's name content attribute value.
</li>
	<li>
~RET %名前~list
◎
Return the browsing context names of childBrowsingContexts, in the same order.
</li>
</ol>


<div class="example">

<p>
例えば次の頁が
`https://example.org/^c
にて~hostされていて，
`https://elsewhere.example/^c
の `iframe^e の `name$m が `spices^l に設定されたとするとき、すべてが読込まれた後に `window.spices^c を評価した結果は undefined <!-- ＊ -->になる：
◎
This means that in the following example, hosted on https://example.org/, assuming https://elsewhere.example/ sets window.name to "spices", evaluating window.spices after everything has loaded will yield undefined:
</p>

<pre>
&lt;iframe src=https://elsewhere.example.com/&gt;&lt;/iframe&gt;
&lt;iframe name=spices&gt;&lt;/iframe&gt;
</pre>

</div>


<p>
各`~window$は、`有名~propを~supportする$。
所与の任意の時点における`~window$ %W の`被support~prop名$は、次のものからなる：
◎
The Window object supports named properties. The supported property names of a Window object window at any moment consist of the following, in tree order according to the element that contributed them, ignoring later duplicates:
</p>

<ul>
	<li>
%W の`文書~木に属する子~閲覧文脈~名~prop集合$
◎
window's document-tree child browsing context name property set;
</li>
	<li>
［
%W に`対応する閲覧文脈$にて`作動中の文書$
］内の`有名~要素$
— `要素~名$が同じものが複数あるときは、`木~順序$で最初のもの以外は無視する。
◎
the value of the name content attribute for all applet, embed, form, frameset, img, and object elements that have a non-empty name content attribute and are in a document tree with window's browsing context's active document as their root; and
◎
the value of the id content attribute for all HTML elements that have a non-empty id content attribute and are in a document tree with window's browsing context's active document as their root.
</li>
</ul>


<p class="algo-head" id="dom-window-nameditem">
`~window$ %W において，所与の %名前 に対し`有名~propの値を決定する$ときは、次の手続きの結果を返さ~MUST：
◎
To determine the value of a named property name in a Window, the user agent must return the value obtained using the following steps:
</p>


<ol>
		<li>
~Assert：
%名前 は %W の`被support~prop名$である
`この段は、この訳による補完。^tnote
</li>
	<li>
<p>
%~obj~list ~LET %W に`対応する閲覧文脈$にて`作動中の文書$内の［
名前 %名前 の`有名~obj$
］からなる~list
◎
Let objects be the list of named objects with the name name in the active document.
</p>

<p class="note">注記：
定義により、 %~obj~list は空でない。
◎
There will be at least one such object, by definition.
</p>
	</li>
	<li>
~IF［
%~obj~list 内に`入子の閲覧文脈$はある
］
⇒
~RET［
それらのうち，`閲覧文脈~容器$の`木~順序$で最初のもの
］の `WindowProxy$I ~obj
◎
If objects contains a nested browsing context, then return the WindowProxy object of the nested browsing context corresponding to the first browsing context container in tree order whose nested browsing context is in objects, and abort these steps.
</li>
	<li>
~IF［
%~obj~list 内の要素~数 ~EQ 1
］
⇒
~RET その要素
◎
Otherwise, if objects has only one element, return that element and abort these steps.
</li>
	<li>
~RET
次のようにされた `HTMLCollection$I
⇒
根： `Document$I ~node；<br />
~filter： 名前 %名前 の`有名~obj$のみに合致する（定義により，これらはすべて要素になる）
◎
Otherwise return an HTMLCollection rooted at the Document node, whose filter matches only named objects with the name name. (By definition, these will all be elements.)
</li>
</ol>

<p>
この節の目的0における，`文書$ %文書 内の［
名前 %名前 の
`有名~obj@
］は、次に挙げるものからなる：
◎
Named objects with the name name, for the purposes of the above algorithm, consist of the following:
</p>

<ul>
	<li>
%文書 が`属する閲覧文脈$の`文書~木に属する子~閲覧文脈$のうち，［
その`閲覧文脈~名$ ~EQ %名前
］なるもの
◎
document-tree child browsing contexts of the active document whose name is name;
</li>
	<li>
%文書 内の`有名~要素$のうち，［
その`要素~名$ ~EQ %名前
］なるもの
</li>
</ul>

<p>
所与の`文書$ %文書 内の
`有名~要素@,
およびその
`要素~名@
は、次で与えられる：
</p>

<ul>
	<li>
%文書 を`根$とする`文書~木~内$にある［
<!-- ＊`a$e,  被support~prop名 と合致しない-->
`applet$e,
<!--  ＊`area$e,  -->
`embed$e, `form$e, `frameset$e, `img$e, `object$e
］要素のうち，［
`name^a 内容~属性を有する
］~AND［
その属性~値 ~NEQ 空~文字列
］なるもの
— その属性~値が`要素~名$を与える
◎
a, applet, area, embed, form, frameset, img, or object elements that have a name content attribute whose value is name and are in a document tree with the active document as their root; and
</li>
	<li>
%文書 を`根$とする`文書~木~内$にある`~HTML要素$のうち，［
`id$a 内容~属性を有する
］~AND［
その属性~値 ~NEQ 空~文字列
］なるもの
— その属性~値が`要素~名$を与える
◎
HTML elements that have an id content attribute whose value is name and are in a document tree with the active document as their root.
</li>
</ul>

<p class="trans-note">【
`有名~要素$, `要素~名$は、記述を論理的に集約するためにこの訳に導入した用語である。
】</p>

		</section>
		<section id="garbage-collection-and-browsing-contexts">
<h3 title="Garbage collection and browsing contexts">7.3.4. ~garbage収集と閲覧文脈</h3>

<p>
~UAは、自身の`~top-level閲覧文脈$たちへの強い参照を持つ。
◎
↓</p>

<p>
各 `閲覧文脈$は、［
それに属する各`文書$, および
その `WindowProxy$I ~obj
］への強い参照を持つ。
◎
A browsing context has a strong reference to each of its Documents and its WindowProxy object, and the user agent itself has a strong reference to its top-level browsing contexts.
</p>

<p>
各`文書$は、自身の`~window$への強い参照を持つ。
◎
A Document has a strong reference to its Window object.
</p>

<p class="note">注記：
`~window$は、その `document$m 属性を通して，それに`結付けられている文書$への`強い参照$を持つ。
したがって、他の~scriptからの，それらいずれかの~objへの参照は、両者とも存続させ続けることになる。
同様に、［
`文書$, `~window$
］のいずれも， `WindowProxy$I ~objへの暗黙の`強い参照$を持つ。
◎
A Window object has a strong reference to its Document object through its document attribute. Thus, references from other scripts to either of those objects will keep both alive. Similarly, both Document and Window objects have implied strong references to the WindowProxy object.
</p>

<p>
各`~script$は、自身の`設定群~obj$への強い参照を持つ。
各 `環境~設定群~obj$は、自身の［
`大域~obj$, `担当の閲覧文脈$enV, `担当の文書$enV
］への強い参照を持つ（もしあれば）。
◎
Each script has a strong reference to its settings object, and each environment settings object has strong references to its global object, responsible browsing context, and responsible document (if any).
</p>

<p class="algo-head">
`閲覧文脈$ %B に`属する文書$ %文書 を
`破棄-@doc
するときは、~UAは，次の手続きを走らせ~MUST：
◎
When a browsing context is to discard a Document, the user agent must run the following steps:
</p>

 
<ol>
	<li>
%文書 の`回復可能~状態$ ~SET ~F
◎
Set the Document's salvageable state to false.
</li>
	<li>
この仕様も含む`適用し得る仕様$に定義される，
%文書 に対する`文書~unload時の片付け手続き$があれば、それを走らす
◎
Run any unloading document cleanup steps for the Document that are defined by this specification and other applicable specifications.
</li>
	<li>
%文書 を`中止する$
◎
Abort the Document.
</li>
	<li>
待入された`~task$のうち，［
それに結付けられている`文書$ ~EQ %文書
］なるものは、どの`~task源$からの~taskであれ，走らすことなく除去する
◎
Remove any tasks associated with the Document in any task source, without running those tasks.
</li>
	<li>
%文書 を`通して入子にされ$ている`子~閲覧文脈$は、すべて`破棄-$する
◎
Discard all the child browsing contexts of the Document.
</li>
	<li>
%B から %文書 への強い参照を切り離す
◎
Lose the strong reference from the Document's browsing context to the Document.
</li>
</ol>

<p class="note">注記：
%文書 が`破棄-$docされたときは、 %文書 を含んでいる各［
`~workerの文書~list$
］からも除去される。
◎
Whenever a Document object is discarded, it is also removed from the list of the worker's Documents of each worker whose list contains that Document.
</p>


<div class="p">
<p class="algo-head">
閲覧文脈 %B を
`破棄-@
するときは、次を行わ~MUST：
</p>

<ul><li>~UA自身から %B への強い参照を切る。
</li><li>%B の~session履歴~内のすべての~entryに対するすべての`文書$を`破棄-$docする。
</li></ul>
◎
When a browsing context is discarded, the strong reference from the user agent itself to the browsing context must be severed, and all the Document objects for all the entries in the browsing context's session history must be discarded as well.
</div>

<div class="p">
<p>
~UAは：
</p>

<ul>
	<li>
`~top-level閲覧文脈$をいつでも`破棄-$してよい（概して，利用者からの要請に呼応して
— 例えば、利用者が，`~top-level閲覧文脈$たちを包含している~window~UIを強制的に閉じたとき）。
</li>
	<li>
<p>
他の`閲覧文脈$に対しては、次のときには破棄し~MUST：
</p>
<ul ><li>その`WindowProxy$I ~objが~garbage収集に適格になったとき
</li><li>この仕様が他所にて破棄するよう要求する所
</li></ul>
	</li>
</ul>

◎
User agents may discard top-level browsing contexts at any time (typically, in response to user requests, e.g. when a user force-closes a window containing one or more top-level browsing contexts). Other browsing contexts must be discarded once their WindowProxy object is eligible for garbage collection, in addition to the other places where this specification requires them to be discarded.
</div>

<p>
`WindowProxy$I ~obj %P は、 %P を伴って作成された`閲覧文脈$への強い参照は<em>持たない</em>。
特に、~JS~codeが %P への参照を保持していても，`入子の閲覧文脈$は`破棄-$され得る。
◎
A WindowProxy does not have a strong reference to the browsing context it was created alongside. In particular, it is possible for a nested browsing context to be discarded even if JavaScript code holds a reference to its WindowProxy object.
</p>

		</section>
		<section id="closing-browsing-contexts">
<h3 title="Closing browsing contexts">7.3.5. 閲覧文脈を閉じるとき</h3>

<p class="algo-head">
~UAは、`閲覧文脈$ %B を
`閉じる@
よう要求されたときは、次の手続きを走らせ~MUST：
◎
When the user agent is required to close a browsing context, it must run the following steps:
</p>

<ol>
	<li>
%文書 ~LET %B にて`作動中の文書$
</li>
	<li>
%文書 の`~unloadを~prompt$する
⇒
~IF［
利用者は %文書 の`~unloadを拒否-$した
］
⇒
~RET
◎
Let specified browsing context be the browsing context being closed.
◎
Prompt to unload the active document of the specified browsing context. If the user refused to allow the document to be unloaded, then abort these steps.
</li>
	<li>
［
%recycle ~SET ~F
］の下で， %文書 を`~unload$する
◎
Unload the active document of the specified browsing context with the recycle parameter set to false.
</li>
	<li>
~UIから %B を除去する（例： ~tab付き~browserにて当の~tabを閉じる／隠すなど）。
◎
Remove the specified browsing context from the user interface (e.g. close or hide its tab in a tabbed browser).
</li>
	<li>
%B を`破棄-$する
◎
Discard the specified browsing context.
</li>
</ol>

<p>
~UAは、どの`~top-level閲覧文脈$に対しても，利用者が任意に`閉じる$能を提供0するべきである。
◎
User agents should offer users the ability to arbitrarily close any top-level browsing context.
</p>


		</section>
		<section id="browser-interface-elements">
<h3 title="Browser interface elements">7.3.6. ~browser~UI要素</h3>

<p>
~Web頁を~Web~browserに統合できるようにするため、ある種の~Web~browser~UI要素は，~Web頁~内の~scriptに対し制限された仕方で公開される。
◎
To allow Web pages to integrate with Web browsers, certain Web browser interface elements are exposed in a limited way to scripts in Web pages.
</p>

<p>
各~UI要素は、 `BarProp$I ~objにより表現される：
◎
Each interface element is represented by a BarProp object:
</p>

<pre class="idl">
interface `BarProp@I {
  readonly attribute boolean `visible$m;
};
</pre>

<!-- `Window@I -->

<div >
<dl class="domintro">
	<dt>%window . `locationbar$m . `visible$m</dt>
	<dt>%window . `menubar$m . `visible$m</dt>
	<dt>%window . `personalbar$m . `visible$m</dt>
	<dt>%window . `scrollbars$m . `visible$m</dt>
	<dt>%window . `statusbar$m . `visible$m</dt>
	<dt>%window . `toolbar$m . `visible$m</dt>
	<dd>
順に，［
location-, menu-, personal-, scroll-, status-, tool-
］bar が［
可視ならば ~T ／ 可視でないならば ~F
］を返す。
</dd>
</dl>

◎
window . locationbar . visible
• Returns true if the location bar is visible; otherwise, returns false.
window . menubar . visible
• Returns true if the menu bar is visible; otherwise, returns false.
window . personalbar . visible
• Returns true if the personal bar is visible; otherwise, returns false.
window . scrollbars . visible
• Returns true if the scroll bars are visible; otherwise, returns false.
window . statusbar . visible
• Returns true if the status bar is visible; otherwise, returns false.
window . toolbar . visible
• Returns true if the toolbar is visible; otherwise, returns false.
</div>


<dl class="idl-def">
	<dt>`visible@m</dt>
	<dd>
取得子は、 ~T または，下に述べるように，当の~objが表現する~UI要素の可視性~状態を最も正確0に表現するような，~UAにより決定される値を返さ~MUST。
◎
The visible attribute, on getting, must return either true or a value determined by the user agent to most accurately represent the visibility state of the user interface element that the object represents, as described below.
</dd>
	<dd>
<p>
以下に挙げる各種 `BarProp$I ~objは、`閲覧文脈$に属する各`文書$に存在する。
これらの~objにより表現される~UI要素のうち一部は、~UAによっては等価なものがないこともある。
そのような~UAであっても、他から指定されない限り，~objは在するかつ可視であるかのように動作し~MUST（すなわち，その `visible$m 属性は ~T を返さ~MUST）。
◎
The following BarProp objects exist for each Document object in a browsing context. Some of the user interface elements represented by these objects might have no equivalent in some user agents; for those user agents, except when otherwise specified, the object must act as if it was present and visible (i.e. its visible attribute must return true).
</p>

		<dl class="def-list">
			<dt>`~location-bar@bP
◎
The location bar BarProp object
</dt>
			<dd>
［
`作動中の文書$の`~URL$を表示する~control
］を包含するような~UI要素に類するものを表現する。
◎
Represents the user interface element that contains a control that displays the URL of the active document, or some similar interface concept.
</dd>

			<dt>`~menu-bar@bP
◎
The menu bar BarProp object
</dt>
			<dd>
［
~menu~form内の~commandの~list
］を包含するような~UI要素に類するものを表現する。
◎
Represents the user interface element that contains a list of commands in menu form, or some similar interface concept.
</dd>

			<dt>`~personal-bar@bP
◎
The personal bar BarProp object
</dt>
			<dd>
［
利用者の “お気に入り（ favorite ）” 頁を指す~link
］を包含するような~UI要素に類するものを表現する。
◎
Represents the user interface element that contains links to the user's favorite pages, or some similar interface concept.
</dd>

			<dt>`~scrollbar@bP
◎
The scrollbar BarProp object
</dt>
			<dd>
［
~scrollするための仕組み
］を包含するような~UI要素に類するものを表現する。
◎
Represents the user interface element that contains a scrolling mechanism, or some similar interface concept.
</dd>

			<dt>`~status-bar@bP
◎
The status bar BarProp object
</dt>
			<dd>
利用者の媒体に応じて適切に，文書の直上／直下に見出される~UI要素を表現する。
それは概して，［
進行中の~network活動や, 利用者の~pointing装置が現在の指示している要素
］についての情報を提供する。
そのような~UI要素を持たない~UAは、~objに対応する~UI要素は不在であったかのように動作してよい（すなわち，その `visible$m 属性は ~F を返してよい）。
◎
Represents a user interface element found immediately below or after the document, as appropriate for the user's media, which typically provides information about ongoing network activity or information about elements that the user's pointing device is current indicating. If the user agent has no such user interface element, then the object may act as if the corresponding user interface element was absent (i.e. its visible attribute may return false).
</dd>

			<dt>`~toolbar@bP
◎
The toolbar BarProp object
</dt>
			<dd>
利用者の媒体に応じて適切に，文書の直上／直下に見出される~UI要素を表現する。
それは概して，`~session履歴$の走査~control（戻る／進む~button, 再読込み~button, 等々）を提供する。
そのような~UI要素を持たない~UAは、~objに対応する~UI要素は不在であったかのように動作してよい（すなわち，その `visible$m 属性は ~F を返してよい）。
◎
Represents the user interface element found immediately above or before the document, as appropriate for the user's media, which typically provides session history traversal controls (back and forward buttons, reload buttons, etc). If the user agent has no such user interface element, then the object may act as if the corresponding user interface element was absent (i.e. its visible attribute may return false).
</dd>
		</dl>
	</dd>

	<dt>`locationbar@m</dt>
	<dd>
取得子は、`~location-bar$bPを返さ~MUST。
◎
The locationbar attribute must return the location bar BarProp object.
</dd>

	<dt>`menubar@m</dt>
	<dd>
取得子は、`~menu-bar$bPを返さ~MUST。
◎
The menubar attribute must return the menu bar BarProp object.
</dd>

	<dt>`personalbar@m</dt>
	<dd>
取得子は、`~personal-bar$bPを返さ~MUST。
◎
The personalbar attribute must return the personal bar BarProp object.
</dd>

	<dt>`scrollbars@m</dt>
	<dd>
取得子は、`~scrollbar$bPを返さ~MUST。
◎
The scrollbars attribute must return the scrollbar BarProp object.
</dd>

	<dt>`statusbar@m</dt>
	<dd>
取得子は、`~status-bar$bPを返さ~MUST。
◎
The statusbar attribute must return the status bar BarProp object.
</dd>

	<dt>`toolbar@m</dt>
	<dd>
取得子は、`~toolbar$bPを返さ~MUST。
◎
The toolbar attribute must return the toolbar BarProp object.
</dd>

	<dt>`status@m</dt>
	<dd>
この属性は、歴史的~理由から存在する。
取得子は、最後に設定された文字列を返さ~MUST。
設定子は、自身を新たな値に設定し~MUST。
`~window$の作成-時には、属性は空~文字列に設定され~MUST。
この属性は、他に何もしない。
◎
For historical reasons, the status attribute on the Window object must, on getting, return the last string it was set to, and on setting, must set itself to the new value. When the Window object is created, the attribute must be set to the empty string. It does not do anything else.
</dd>
</dl>


		</section>
	</section>

	<section id="the-windowproxy-exotic-object">
<h2 title="The WindowProxy exotic object">7.4. `WindowProxy^I ~exotic~obj</h2>

<p>
各 `閲覧文脈$ %B には、
`WindowProxy@I
~obj %P が結付けられる。
それは、普通の~objである `Window$I ~obj %W を，次のように包装する~exotic~objである：
</p>

<ul ><li>%P 上のほとんどの演算は、 %W へ指し向けられる。
</li><li>%B が`~navigate$されたときは、 %W も別の `Window$I ~objに変更される。
</li><li>%P の `Window$sl 内部~slotが， %W を表現する。
</li><li>%P に対応する`~interface~obj$はない。
</li></ul>

<p class="trans-note">【
以下，この節と その各 下位節の内容は、
<a href="~HTMLWPROXY#the-windowproxy-exotic-object">別ページ</a>
にて。
上述は、便宜のため，その冒頭部のみを再掲したものである。
】</p>


	</section>
	<section id="origin">
<h2 title="Origin">7.5. 生成元</h2>

`28374$bug

<p>
生成元は ~Webの保安~modelにおける基礎的な通貨である。
~Web~platformにおける，ある生成元を共有する動作者たちは、互いを信用し，同じ権限を有するものと見做される。
互いの生成元が相違する動作者たちは、潜在的に敵対的にあると見なされ，様々な程度で互いに隔離される。
◎
Origins are the fundamental currency of the Web's security model. Two actors in the Web platform that share an origin are assumed to trust each other and to have the same authority. Actors with differing origins are considered potentially hostile versus each other, and are isolated from each other to varying degrees.
</p>

<p class="example">
例えば
`bank.example.com^c
にて~hostされている X 銀行の ~Web~siteが
`charity.example.org^c
にて~hostされている Y 事業体の~Web~siteの~DOMを調べようと試行した場合、
`SecurityError$E 例外が~~投出されることになる。
◎
For example, if Example Bank's Web site, hosted at bank.example.com, tries to examine the DOM of Example Charity's Web site, hosted at charity.example.org, a "SecurityError" DOMException will be raised.
</p>

<hr>

<p id="origin-2">
`生成元@
は、次のいずれかとして与えられる：
◎
An origin is one of the following:
</p>


<dl class="def-list">
	<dt>`不透明な生成元@</dt>
	<dd>
直列化して再度~作成し直せないような（`生成元の~ASCII直列化$においては `null^l に直列化される），内部的な値であって、有意義な演算は，同等性を試験することに限られる。
◎
An internal value, with no serialization it can be recreated from (it is serialized as "null" per ASCII serialization of an origin), for which the only meaningful operation is testing for equality.
</dd>
	<dt>`成分組~生成元@</dt>
	<dd>
<p>
次のものからなる：
◎
A tuple consists of:
</p>

		<ul>
			<li>
`~scheme@（ `~scheme$url ）
◎
A scheme (a scheme).
</li>
			<li>
`~host@ （ `~host$url ）
◎
A host (a host).
</li>
			<li>
`~port@ （ `~port$url ）
◎
A port (a port).
</li>
			<li>
<p>
`~domain@ （ ~NULL または `~domain$url ）。
他が定められない限り， ~NULL 。
◎
A domain (null or a domain). Null unless stated otherwise.
</p>
			</li>
		</ul>

<p class="note">注記：
`生成元$は共有され得る
— 例えば、複数の`文書$間で。
加えて、`生成元$は，一般に変異しない。
`成分組~生成元$の`~domain$のみ，それも
`document.domain$m ~APIを通してのみ，変更され得る。
◎
Origins can be shared, e.g., among multiple Document objects. Furthermore, origins are generally immutable. Only the domain of a tuple origin can be changed, and only through the document.domain API.
</p>
	</dd>
</dl>


<p class="algo-head">
`生成元$ %生成元 の
`実効~domain@
は、次に従って計算される：
◎
The effective domain of an origin origin is computed as follows:
</p>

<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET ~NULL
◎
If origin is an opaque origin, then return null.
</li>
	<li>
~IF［
%生成元 の`~domain$ ~NEQ ~NULL
］
⇒
~RET %生成元 の`~domain$
◎
If origin's domain is non-null, then return origin's domain.
</li>
	<li>
~RET %生成元 の`~host$
◎
Return origin's host.
</li>
</ol>

<p>
仕様が定義する様々な~objは，`生成元$を有するように定義される。
これらの`生成元$は、次のうち，最初に該当する項目に従って決定される：
◎
Various specification objects are defined to have an origin. These origins are determined as follows:
</p>

<dl>
	<dt>`文書$ %文書 に対しては：◎For Document objects</dt>
	<dd>
		<dl class="switch">
			<dt id="sandboxOrigin">
`生成元$sbox ~IN %文書 の`作動中の~sandbox用~flag集合$の場合：
◎
If the Document's active sandboxing flag set has its sandboxed origin browsing context flag set
</dt>
			<dt>
%文書 は `data_$sc ~URLから生成されたものである場合：
◎
If the Document was generated from a data: URL
</dt>
			<dd>
%文書 の作成-時にあてがわれた，一意かつ`不透明な生成元$。
◎
A unique opaque origin assigned when the Document is created.
</dd>

			<dt>
%文書 の`~URL$docの`~scheme$urlは`~network~scheme$である場合：
◎
If the Document's URL's scheme is a network scheme
</dt>
			<dd>
%文書 の作成-時にあてがわれた， %文書 の`~URL$docの`生成元$urlの複製
◎
A copy of the Document's URL's origin assigned when the Document is created.
</dd>
			<dd class="note">注記：
`document.open()$m ~methodは、
%文書 の`~URL$docを `about_blank$sc に変更し得る。
したがって、`生成元$は作成-時にあてがわれる。
◎
The document.open() method can change the Document's URL to "about:blank". Therefore the origin is assigned when the Document is created.
</dd>

			<dt>
%文書 は初期 "`about_blank$sc" 文書である場合：
◎
If the Document is the initial "about:blank" document
</dt>
			<dd>
%文書 が`属する閲覧文脈$の
<a href="#about-blank-origin">作成-時にあてがわれたもの</a>。
◎
The one it was assigned when its browsing context was created.
</dd>

			<dt>
%文書 は 初期でない "`about_blank$sc" 文書である場合：
◎
If the Document is a non-initial "about:blank" document
</dt>
			<dd>
<p>
`~script$が孕まれるかどうかに応じて：
</p>

<dl class="switch"><dt>孕まれる場合：
</dt><dd>`~navigate$~algoが呼出された時点での`現任の設定群~obj$の`生成元$enV
</dd><dt>孕まれない場合：
</dt><dd>当の`~URL$への`~navi$を起動させた要素の`~node文書$の`生成元$
</dd></dl>

◎
The origin of the incumbent settings object when the navigate algorithm was invoked, or, if no script was involved, the origin of the node document of the element that initiated the navigation to that URL.
</dd>

			<dt>
%文書 は 
`javascript_$sc ~URLの処理の一部として作成されたものである場合：
◎
If the Document was created as part of the processing for javascript: URLs
</dt>
			<dd>
~navigateされている`閲覧文脈$の［
`~navigate$~algoが呼出された時点で`作動中の文書$
］の`生成元$
◎
The origin of the active document of the browsing context being navigated when the navigate algorithm was invoked.
</dd>

			<dt>
%文書 は `~iframe~srcdoc文書$である場合：
◎
If the Document is an iframe srcdoc document
</dt>
			<dd>
［［［
%文書 が`属する閲覧文脈$
］の`閲覧文脈~容器$
］の`~node文書$
］の`生成元$
◎
The origin of the Document's browsing context's browsing context container's node document.
</dd>

			<dt>
%文書 は 何らかの他の方式で得られたものである場合：
◎
If the Document was obtained in some other manner (e.g. a Document created using the createDocument() API, etc)
</dt>
			<dd>
WHATWG `DOM$r 標準に定義される既定の挙動が適用される。
◎
The default behavior as defined in the WHATWG DOM standard applies. [DOM].
</dd>
			<dd class="note">注記：
`生成元$は %文書 の作成-時にあてがわれた，一意かつ`不透明な生成元$になる。
◎
The origin is a unique opaque origin assigned when the Document is created.
</dd>
			<dd class="example">
例えば、 `createDocument()$m ~API, 等々を利用して作成された`文書$。
◎
↑</dd>
		</dl>
	</dd>

	<dt>
`img$e 要素による画像に対しては：
◎
For images of img elements
</dt>
	<dd>
<p>
その`画像~data$に応じて：
</p>

		<dl class="switch">
			<dt>
`~CORS非同一生成元$である場合：
◎
If the image data is CORS-cross-origin
◎
</dt>
			<dd>
一意かつ`不透明な生成元$
— これは、画像の作成-時にあてがわれる。
◎
A unique opaque origin assigned when the image is created.
</dd>
			<dt>
`~CORS同一生成元$である場合：
◎
If the image data is CORS-same-origin
</dt>
			<dd>
要素の`~node文書$の`生成元$
◎
The img element's node document's origin.
</dd>
		</dl>
	</dd>

	<dt>
`~media要素$（ `audio$e ／ `video$e ）に対しては：
◎
For audio and video elements
</dt>
		<dd>
<p>
その`~media~data$に応じて：
</p>

			<dl class="switch">
			<dt>
`~CORS非同一生成元$である場合：
◎
If the media data is CORS-cross-origin
</dt>
			<dd>
一意かつ`不透明な生成元$
— これは、~media~dataの~fetch時にあてがわれる。
◎
A unique opaque origin assigned when the media data is fetched.
</dd>
			<dt>
`~CORS同一生成元$である場合：
◎
If the media data is CORS-same-origin
</dt>
			<dd>
要素の`~node文書$の`生成元$
◎
The media element's node document's origin.
</dd>
		</dl>
	</dd>
</dl>

<p>
他の仕様は、特定0の［
`文書$ ／ 画像 ／ `~media要素$
］の`生成元$を指定して上の定義を上書きし得る。
◎
Other specifications can override the above definitions by themselves specifying the origin of a particular Document object, image, or media element.
</p>

<hr>

<p class="algo-head">
`生成元の~Unicode直列化@
は、所与の`生成元$ %生成元 に対し，次の~algoを適用して得られる文字列である：
◎
The Unicode serialization of an origin is the string obtained by applying the following algorithm to the given origin origin:
</p>


<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET `null^l
◎
If origin is an opaque origin, then return "null".
</li>
	<li>
%~host ~LET %生成元 の`~host$
◎
Let host be origin's host.
</li>
	<li>
%~Unicode~host ~LET ［
%~host は`~domain$urlでないならば %~host ／
~ELSE_ %~host に対し`~domainから~Unicodeへ変換-$した結果
］
◎
Let unicodeHost be host if host is not a domain, and the result of applying domain to Unicode to host otherwise.
</li>
	<li>
%~Unicode生成元 ~LET 新たな`成分組~生成元$
( %生成元 の`~scheme$, %~Unicode~host, %生成元 の`~port$ )
◎
Let unicodeOrigin be a new tuple origin consisting origin's scheme, unicodeHost, and origin's port.
</li>
	<li>
<p >
~RET %~Unicode生成元 に対する`生成元の~ASCII直列化$
◎
Return the ASCII serialization of an origin, given unicodeOrigin.
</p>

<p class="note">注記：
`生成元の~ASCII直列化$という名称は，紛らわしい所がある。
それは、`~URL構文解析器$に因り既定で すべて~ASCIIにされている生成元を，単に直列化するだけなので。
◎
The name ASCII serialization of an origin is misleading, as it merely serializes an origin, which are all ASCII by default due to the URL parser.
</p>

	</li>
</ol>

<p class="example">
`成分組~生成元$
( `https^l, `xn--maraa-rta.example^l, ~NULL, ~NULL ) 
の`~Unicode直列化$は、
`https://maraña.example^l
になる。
◎
The Unicode serialization of ("https", "xn--maraa-rta.example", null, null) is "https://maraña.example".
</p>



<p class="algo-head">
`生成元の~ASCII直列化@
は、所与の`生成元$ %生成元 に対し，次の~algoを適用して得られる文字列である：
◎
The ASCII serialization of an origin is the string obtained by applying the following algorithm to the given origin origin:
</p>

<ol>
	<li>
~IF［
%生成元 は`不透明な生成元$である
］
⇒
~RET `null^l
◎
If origin is an opaque origin, then return "null".
</li>
	<li>
<p>
%結果 ~LET 次を順に連結した結果：
</p>

<ol><li>
%生成元 の`~scheme$
</li><li>`://^l
</li><li>%生成元 の`~host$を`~host直列化器$にかけた結果
</li></ol>

◎
Otherwise, let result be origin's scheme.
◎
Append "://" to result.
◎
Append origin's host, serialized, to result.
</li>
	<li>
~IF［
%生成元 の`~port$ ~EQ ~NULL
］
⇒
~RET %結果
◎
↓</li>
	<li>
<p>
~RET 次を順に連結した結果：
</p>

<ol ><li>%結果
</li><li>`003A^U ( `:^l )
</li><li>%生成元 の`~port$を`整数として直列化-$urlした結果
</li></ol>

◎
If origin's port is non-null, append a U+003A COLON character (:), and origin's port, serialized, to result.
◎
Return result.
</li>
</ol>


<hr>

<p>
次のいずれかを満たすような 2 つの`生成元$ %A, %B は、
`同一生成元@
とされる：
◎
Two origins, A and B, are said to be same origin if the following algorithm returns true:
</p>

<ul>
	<li>
［
%A, %B とも`不透明な生成元$である
］~AND［
%A ~EQ %B
］
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
［
%A, %B とも`成分組~生成元$である
］~AND［
%A, %B の ( `~scheme$, `~host$, `~port$ ) は各~成分ごとに一致する
］
◎
If A and B are both tuple origins and their schemes, hosts, and port are identical, then return true.
◎
Return false.
</li>
</ul>

<p>
このことを、
%A ~EQ`生成元$sub %B
とも記す。
その否定を
%A ~NEQ`生成元$sub %B
と記す。
</p>

<p>
次のいずれかを満たすような 2 つの`生成元$ %A, %B は、
`同じ生成元~domain@
とされる：
◎
Two origins, A and B, are said to be same origin-domain if the following algorithm returns true:
</p>

<ul>
	<li>
［
%A, %B とも`不透明な生成元$である
］~AND［
%A ~EQ %B
］
◎
If A and B are the same opaque origin, then return true.
</li>
	<li>
<p>
［
%A, %B とも`成分組~生成元$である
］~AND［
%A, %B は次のいずれかを満たす
］：
</p>
		<ul>
			<li>
［
%A の`~domain$ ~EQ %B の`~domain$ ~NEQ ~NULL
］~AND［
%A の`~scheme$ ~EQ %B の`~scheme$
］
</li>
			<li>
［
%A の`~domain$ ~EQ %B の`~domain$ ~EQ ~NULL
］~AND［
%A ~EQ`生成元$sub %B
］
</li>
		</ul>
◎
If A and B are both tuple origins, run these substeps:
• If A and B's schemes are identical, and their domains are identical and non-null, then return true.
• Otherwise, if A and B are same origin and their domains are identical and null, then return true.
◎
Return false.
	</li>
</ul>

<p>
このことを、
%A ~EQ`~domain$sub %B
とも記す。
その否定を
%A ~NEQ`~domain$sub %B
と記す。
</p>

<p class="trans-note">【
これらの下付き~~文字による表記は、簡潔に記述するためにこの訳に導入したものである。
】</p>


<div class="example">

<table>
<thead><tr style="white-space:nowrap;"><th>%A
<th>%B
<th>~EQ`生成元$sub？
<th>~EQ`~domain$sub？
</thead>

<tbody><tr><td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>✅
<td>✅

<tr><td>(`https^l, `example.org^l, 314, ~NULL)
<td>(`https^l, `example.org^l, 420, ~NULL)
<td>❌
<td>❌

<tr><td>(`https^l, `example.org^l, 314, `example.org^l)
<td>(`https^l, `example.org^l, 420, `example.org^l)
<td>❌
<td>✅

<tr><td>(`https^l, `example.org^l, ~NULL, ~NULL)
<td>(`https^l, `example.org^l, ~NULL, `example.org^l)
<td>✅
<td>❌

<tr><td>(`https^l, `example.org^l, ~NULL, `example.org^l)
<td>(`http^l, `example.org^l, ~NULL, `example.org^l)
<td>❌
<td>❌
</tbody></table>

</div>


		<section id="relaxing-the-same-origin-restriction">
<h3 title="Relaxing the same-origin restriction">7.5.1.同一生成元 制約の緩め方</h3>

<dl class="domintro">
	<dt>%document . `domain$m [ = %domain ]</dt>
	<dd>
保安~検査のために利用される現在の~domainを返す。
◎
Returns the current domain used for security checks.
</dd>
	<dd>
下位domainを除去するような値に設定して，`生成元$の`~domain$を変更できる
— そうすることにより，
同じ~domainにおける他の下位domain上の頁と互いに~accessできるようになる（それらも，同じことをしたならば）。
（ただし，~sandbox化された `iframe$e においては設定できない。）
◎
Can be set to a value that removes subdomains, to change the origin's domain to allow pages on other subdomains of the same domain (if they do the same thing) to access each other. (Can't be set in sandboxed iframes.)
</dd>
</dl>


<p class="algo-head">
文字列 %~host~suffix文字列 は`~host$x %元~host に対し
`登録可能な~domain~suffixまたは同等@
であるかどうか決定するときは、次を走らす：
◎
To determine if a string hostSuffixString is a registrable domain suffix of or is equal to a host originalHost, run these steps:
</p>

<ol>
	<li>
~IF［
%~host~suffix文字列 ~EQ 空~文字列
］
⇒
~RET ~F
◎
If hostSuffixString is the empty string, then return false.
</li>
	<li>
%~host ~LET %~host~suffix文字列 を`~host構文解析器$にかけた結果
◎
Let host be the result of parsing hostSuffixString.
</li>
	<li>
~IF［
%~host ~EQ `失敗^i
］
⇒
~RET ~F
◎
If host is failure, then return false.
</li>
	<li>
<p>
~IF［［
%~host と %元~host は`~hostとして同等$
］ではない
］：
◎
If host is not equal to originalHost, then run these substeps:
</p>
		<ol>
			<li>
<p>
~IF［
%~host , %元~host のいずれかは`~domain$urlでない 
］
⇒
~RET ~F
◎
If host or originalHost is not a domain, then return false.
</p>

<p class="note">注記：
すなわち、
`IPv4 ~address$url ／ `IPv6 ~address$url
による`~host$xは除外する。
◎
This is meant to exclude hosts that are an IPv4 address or an IPv6 address.
</p>
			</li>
			<li>
%~host片 ~LET ［
`002E^U ( `.^l ) , %~host
］を連結した結果
◎
↓</li>
			<li>
<div class="p">
~IF［
次のいずれかが満たされる
］…：

<ul ><li>%~host片 は %元~host の尾部に<!-- 正確に＊ -->合致しない
</li><li>%~host は Public Suffix List `PSL$r 内のある suffix に合致する
</li><li>%~host片 は Public Suffix List 内のある suffix の尾部に合致する
</li></ul>

…ならば
⇒
~RET ~F

◎
If host, prefixed by a U+002E FULL STOP (.), does not exactly match the end of originalHost, then return false.
◎
If host matches a suffix in the Public Suffix List, or, if host, prefixed by a U+002E FULL STOP (.), matches the end of a suffix in the Public Suffix List, then return false. [PSL]
</div>

<p>
~suffixとの比較は、~suffixを`~host構文解析器$にかけた後で~MUST。
◎
Suffixes must be compared after applying the host parser algorithm.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>


<p class="idl-def">
`Document$I 上の
`domain@m
属性は、次で定義される：
</p>

<ul>
	<li>
<p>
取得子は、次を走らせ~MUST：
◎
The domain attribute's getter must run these steps:
</p>

		<ol>
			<li>
~IF［
此れが`属する閲覧文脈$ ~EQ ε
］
⇒
~RET 空~文字列
◎
If this Document object does not have a browsing context, then return the empty string.
</li>
			<li>
%実効~domain ~LET 
此れの`生成元$の`実効~domain$
◎
Let effectiveDomain be this Document's origin's effective domain.
</li>
			<li>
~IF［
%実効~domain ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If effectiveDomain is null, then return the empty string.
</li>
			<li>
~RET %実効~domain を`~host直列化器$にかけた結果
◎
Return effectiveDomain, serialized.
</li>
		</ol>
	</li>
	<li>
<p>
設定子は、次を走らせ~MUST：
◎
The domain attribute's setter must run these steps:
</p>

		<ol>
			<li>
~IF［
此れが`属する閲覧文脈$ ~EQ ε
］
⇒
~THROW `SecurityError$E
◎
If this Document object has no browsing context, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
`~document-domain$sbox ~IN
此れの`作動中の~sandbox用~flag集合$
］
⇒
~THROW `SecurityError$E
◎
If this Document object's active sandboxing flag set has its sandboxed document.domain browsing context flag set, then throw a "SecurityError" DOMException.
</li>
			<li>
%実効~domain ~LET 此れの`生成元$の`実効~domain$
◎
Let effectiveDomain be this Document's origin's effective domain.
</li>
			<li>
~IF［
%実効~domain ~EQ ~NULL
］
⇒
~THROW `SecurityError$E
◎
If effectiveDomain is null, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
所与の値は %実効~domain に対し`登録可能な~domain~suffixまたは同等$でない
］
⇒
~THROW `SecurityError$E
◎
If the given value is not a registrable domain suffix of and is not equal to effectiveDomain, then throw a "SecurityError" DOMException.
</li>
			<li>
此れの`生成元$の`~domain$ ~SET 所与の値を`~host構文解析器$にかけた結果
◎
Set this Document object's origin's domain to the result of parsing the given value.
</li>
		</ol>
	</li>
</ul>


<p class="note">注記：
`domain$m 属性は、同じ~domain上の異なる~host上の頁どうしが互いの
DOM に~accessすることを可能化するために利用される。
◎
The document.domain attribute is used to enable pages on different hosts of a domain to access each other's DOMs.
</p>

<p class="warning">
他者と~hostを共有しているときは、`document.domain$m 属性を利用しないこと。
信用できない第三者主体が、［
同じ~IP~address上の~portだけ異なる~HTTP~server
］を~hostできる場合、通常は 同じ~host上の互いに異なる~siteを保護する，同一生成元による保護は、失敗することになる
— `document.domain$m 属性が利用されて以降は、生成元の比較-時に，その~portは無視されるので。
◎
Do not use the document.domain attribute when using shared hosting. If an untrusted third party is able to host an HTTP server at the same IP address but on a different port, then the same-origin protection that normally protects two different sites on the same host will fail, as the ports are ignored when comparing origins after the document.domain attribute has been used.
</p>


		</section>
	</section>
	<section id="sandboxing">
<h2 title="Sandboxing">7.6. ~sandboxing</h2>

<p>
`~sandbox用~flag集合@
は、以下に挙げる各種~flagのうち，いくつかからなる集合である。
この集合は、それが含む各種~flagを通して，信用できない資源が持ち得る能を制約するために利用される：
◎
A sandboxing flag set is a set of zero or more of the following flags, which are used to restrict the abilities that potentially untrusted resources have:
</p>

<!-- 
S = ~sandbox用~flag集合
A ~IN S 同値↔ A ~EQ ~ON
-->

<p class="trans-note">【
“~sandbox”
— 字義通り， “（こどもの）砂場” 。
】【
以下に現れる各種
“`X^sbox”
は、
“［
X について，閲覧文脈を~sandbox化する（ X の機能を抑止する）
］ことを指示する~flag”
と解釈する
— そのように解釈し易いよう、この訳では，関数的に記している。
】【
以下における “内容” とは、これらの~flagが適用される閲覧文脈~内の内容を指す。
】</p>

<dl>
	<dt>
`~navi@sbox
◎
The sandboxed navigation browsing context flag
</dt>
	<dd>
<p>
この~flagは、~sandbox化されている当の閲覧文脈を %B とするとき，
次に挙げるもの以外の`閲覧文脈$ %C に対しては，
%B の内容が %C を
<a href="~NAVI#sandboxLinks">~navigateするのを防止する</a>
：
</p>
		<ul>
			<li>
%B 自身
</li>
			<li>
%B が更に内側に入子にしている閲覧文脈
`再帰的に？^tnote
</li>
			<li>
%B が開いた`補助~閲覧文脈$（これは、`補助~navi$sboxにより保護される）†
</li>
			<li>
%B の`~top-level閲覧文脈$（これは、
`利用者~作動化~top-level~navi$sbox,
`非~利用者~作動化~top-level~navi$sbox
により保護される）
</li>
		</ul>
◎
This flag prevents content from navigating browsing contexts other than the sandboxed browsing context itself (or browsing contexts further nested inside it), auxiliary browsing contexts (which are protected by the sandboxed auxiliary navigation browsing context flag defined next), and the top-level browsing context (which is protected by the sandboxed top-level navigation without user activation browsing context flag and sandboxed top-level navigation with user activation browsing context flag defined below).
</dd>
	<dd>†
ここに述べた制約にもかかわらず、［
`補助~navi$sbox ~NIN `~sandbox用~flag集合$
］の下では、ある種の事例においては，新たな`~top-level閲覧文脈$として %~popup ††を開くことが許容される。
そのような %~popup の作成-時には、それを作成した`閲覧文脈$が，
%~popup の
`許可済み~navigator@†††
として設定される
— それは、（ ~naviに関して~sandbox化されていても）実際には %~popup に対する~navigateが許可される。
（他の場合、 %~popup に対する~navigateは，`~navi$sboxにより防止される。）
◎
If the sandboxed auxiliary navigation browsing context flag is not set, then in certain cases the restrictions nonetheless allow popups (new top-level browsing contexts) to be opened. These browsing contexts always have one permitted sandboxed navigator, set when the browsing context is created, which allows the browsing context that created them to actually navigate them. (Otherwise, the sandboxed navigation browsing context flag would prevent them from being navigated even if they were opened.)
</dd>
	<dd class="trans-note">【††
すなわち、`補助~閲覧文脈$。
】【†††
“one permitted sandboxed navigator”
— この “one” は、［
%~popup に対し`許可済み~navigator$とされるものは、きっかり 1 個ある
］ことを表していると見受けられる。
】</dd>

	<dt>
`補助~navi@sbox
◎
The sandboxed auxiliary navigation browsing context flag
</dt>
	<dd>
この~flagは、内容が
<a href="#sandboxWindowOpen">新たな補助~閲覧文脈を作成することを防止する</a>
—
例えば［
`target$a 属性 ／
`window.open()$m ~method
］を利用して。
◎
This flag prevents content from creating new auxiliary browsing contexts, e.g. using the target attribute or the window.open() method.
</dd>

	<dt>`非~利用者~作動化~top-level~navi@sbox</dt>
	<dt>`利用者~作動化~top-level~navi@sbox</dt>
	<dd>
両~flagとも、内容が その~top-level閲覧文脈を［
<a href="~NAVI#sandboxLinks">~navigateすることを防止する</a> ／
<a href="#sandboxClose">閉じることを防止する</a>
］。
これらは順に、`利用者による作動化から誘発されて$［
<em>いない</em>, <em>いる</em>
］~algoからのみ，あたられる。
◎
The sandboxed top-level navigation without user activation browsing context flag
◎
This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level browsing context. It is consulted only from algorithms that are not triggered by user activation.
</dd>
	<dd>
両~flagとも、影響するのは`~top-level閲覧文脈$に限られる
— ［
この~flag ~NIN `~sandbox用~flag集合$
］の下では、内容は，その`~top-level閲覧文脈$を~navigateできる（~flagは`利用者による作動化から誘発されて$いるかどうかに応じて適切な方とする）。
が、他の`閲覧文脈$は，依然として他の~flag
— `~navi$sboxや, （場合によっては）`補助~navi$sbox —
により保護される。
◎
When the sandboxed top-level navigation without user activation browsing context flag is not set, content can navigate its top-level browsing context, but other browsing contexts are still protected by the sandboxed navigation browsing context flag and possibly the sandboxed auxiliary navigation browsing context flag.
◎
The sandboxed top-level navigation with user activation browsing context flag
◎
This flag prevents content from navigating their top-level browsing context and prevents content from closing their top-level browsing context. It is consulted only from algorithms that are triggered by user activation.
◎
As with the sandboxed top-level navigation without user activation browsing context flag, this flag only affects the top-level browsing context; if it is not set, other browsing contexts might still be protected by other flags.
</dd>

	<dt>
`~plugin@sbox
◎
The sandboxed plugins browsing context flag
</dt>
	<dd>
この~flagは、内容が［［
<a href="~HEembed#sandboxPluginEmbed">`embed^e 要素</a> ／ 
<a href="~HEembed#sandboxPluginObject">`object^e 要素</a> ／
<a href="~HTML5/obsolete.html#sandboxPluginApplet">~applet要素</a>
］を利用して, あるいは
`入子の閲覧文脈$
<a href="~NAVI#sandboxPluginNavigate">に対する~naviを通して</a>
］，~pluginを~instance化することを防止する
— それらの`~plugin$を`保安化-$できない限り。
◎
This flag prevents content from instantiating plugins, whether using the embed element, the object element, the applet element, or through navigation of a nested browsing context, unless those plugins can be secured.
</dd>

	<dt>
`生成元@sbox
◎
The sandboxed origin browsing context flag
</dt>
	<dd>
この~flagは、
<a href="#sandboxOrigin">内容を一意`かつ不透明？^tnoteな生成元~内に強制する</a>
— したがって，内容が<!-- ＊ -->同じ`生成元$からの他の内容へ~accessすることを防止する。
◎
This flag forces content into a unique origin, thus preventing it from accessing other content from the same origin.
</dd>
	<dd>
この~flagはまた、~scriptが `document.cookie^m ~IDL属性を
<!-- ~accessを防止する -->
<a href="~HTMLdom#sandboxCookies">読取る／書込むことを防止する</a>
ことに加え， `localStorage$m への~accessも阻止する。
◎
This flag also prevents script from reading from or writing to the document.cookie IDL attribute, and blocks access to localStorage.
</dd>

	<dt>
`~form@sbox
◎
The sandboxed forms browsing context flag
</dt>
	<dd>
この~flagは、
<a href="~HTMLforms#sandboxSubmitBlocked">~form提出を阻止する</a>
。
◎
This flag blocks form submission.
</dd>

	<dt>
`~pointer~lock@sbox
◎
The sandboxed pointer lock browsing context flag
</dt>
	<dd>
この~flagは、 Pointer Lock ~APIを不能化する。
`POINTERLOCK$r
◎
This flag disables the Pointer Lock API. [POINTERLOCK]
</dd>

	<dt>
`~script@sbox
◎
The sandboxed scripts browsing context flag
</dt>
	<dd>
この~flagは、
<a href="~WAPI#sandboxScriptBlocked">~script実行を阻止する</a>。
◎
This flag blocks script execution.
</dd>

	<dt>
`自動~特色機能@sbox
◎
The sandboxed automatic features browsing context flag
</dt>
	<dd>
<p >
この~flagは、次に挙げるような自動的に誘発される特色機能を阻止する：
</p>

<ul ><li><a href="~HTMLemb#attr-media-autoplay">動画を自動的に再生する</a>
</li><li><a href="~HTMLforms#attr-fe-autofocus">~form~controlを自動的に~focusする</a>
</li></ul>

◎
This flag blocks features that trigger automatically, such as automatically playing a video or automatically focusing a form control.
</dd>

	<dt>
`~sandbox化( ~storage域~URL )~flag@
◎
The sandboxed storage area URLs flag
</dt>
	<dd>
この~flagは、［
~storage域を利用するような ~URL~scheme†
］が，生成元の~dataに~accessすることを防止する。
◎
This flag prevents URL schemes that use storage areas from being able to access the origin's data.
</dd>
	<dd class="trans-note">【†
例えば `filesystem_^sc ~scheme？（
<a href="~FETCH#sandboxed-storage-area-urls-flag">参考</a>
）
】</dd>

	<dt>
`~document-domain@sbox
◎
The sandboxed document.domain browsing context flag
</dt>
	<dd>
この~flagは、 `document.domain$m 設定子の利用を防止する。
◎
This flag prevents content from using the document.domain setter.
</dd>

	<dt>
`~sandboxは補助~閲覧文脈に伝播する~flag@
◎
The sandbox propagates to auxiliary browsing contexts flag
</dt>
	<dd>
この~flagは、［
内容にて`作動中の~sandbox用~flag集合$
］を［
内容が作成する`補助~閲覧文脈$
］に継承させることにより，内容が ~sandboxから逃れることを防止する。
◎
This flag prevents content from escaping the sandbox by ensuring that any auxiliary browsing context it creates inherits the content's active sandboxing flag set.
</dd>

	<dt>
`~sandbox化( ~modal )~flag@
◎
The sandboxed modals flag
</dt>
	<dd>
<p>
この~flagは、［
内容が，次のいずれかの特色機能を利用して~modal~dialogを生産する
］ことを防止する：
◎
This flag prevents content from using any of the following features to produce modal dialogs:
</p>

<ul><li>`window.alert()$m
</li><li>`window.confirm()$m
</li><li>`window.print()$m
</li><li>`window.prompt()$m
</li><li>`beforeunload$et ~event
</li></ul>

	</dd>

	<dt>
`方位~lock@sbox
◎
The sandboxed orientation lock browsing context flag
</dt>
	<dd>
この~flagは、~screen方位を~lockする能を不能化する。
`SCREENORIENTATION$r
◎
This flag disables the ability to lock the screen orientation. [SCREENORIENTATION]
</dd>
	<dt>
`呈示@sbox
◎
The sandboxed presentation browsing context flag
</dt>
	<dd>
この~flagは、 Presentation API を不能化する。
`PRESENTATION$r
◎
This flag disables the Presentation API. [PRESENTATION]
</dd>

</dl>

<p class="algo-head">
`~sandbox用~指令を構文解析する@
手続きは、所与の (
文字列 %入力,
`~sandbox用~flag集合$ %出力
)
に対し，次を走らせ~MUST：
◎
When the user agent is to parse a sandboxing directive, given a string input, a sandboxing flag set output, it must run the following steps:
</p>

 
<ol>
	<li>
%tokens ~LET %入力 を`~ASCII空白で分割-$した結果
◎
Split input on ASCII whitespace, to obtain tokens.
</li>
	<li>
%出力 を空にする
◎
Let output be empty.
</li>
	<li>

<p>
以下に挙げる各種~flagを，対応する記述の条件が満たされるならば
%出力 に追加する：
◎
Add the following flags to output:
</p>
		<ul>
			<li>
`~navi$sbox
⇒
無条件
◎
The sandboxed navigation browsing context flag.
</li>
			<li>
`補助~navi$sbox
⇒
`allow-popups@v ~NIN %tokens
◎
The sandboxed auxiliary navigation browsing context flag, unless tokens contains the allow-popups keyword.
</li>
			<li>
`非~利用者~作動化~top-level~navi$sbox
⇒
`allow-top-navigation@v
~NIN %tokens
◎
The sandboxed top-level navigation without user activation browsing context flag, unless tokens contains the allow-top-navigation keyword.
</li>
			<li>
<p>
`利用者~作動化~top-level~navi$sbox
⇒
［
`allow-top-navigation-by-user-activation@v
~NIN %tokens
］~AND［
`allow-top-navigation$v ~NIN %tokens
］
◎
The sandboxed top-level navigation with user activation browsing context flag, unless tokens contains either the allow-top-navigation-by-user-activation keyword or the allow-top-navigation keyword.
</p>

<p class="note">注記：
したがって、［
`allow-top-navigation$v ~IN %tokens
］の場合、
`allow-top-navigation-by-user-activation$v
の効果はなくなる。
この理由から、両~keywordとも指定するのは，文書~適合性の~errorになる。
◎
This means that if the allow-top-navigation is present, the allow-top-navigation-by-user-activation keyword will have no effect. For this reason, specifying both is a document conformance error.
</p>
			</li>
			<li>
`~plugin$sbox
⇒
無条件
◎
The sandboxed plugins browsing context flag.
</li>
			<li>
<p>
`生成元$sbox
⇒
`allow-same-origin@v ~NIN %tokens
◎
The sandboxed origin browsing context flag, unless the tokens contains the allow-same-origin keyword.
</p>

<div class="note">

<p>注記：
`allow-same-origin$v ~keywordは、次の二つ事例に意図されている：
◎
The allow-same-origin keyword is intended for two cases.
</p>

<ul>
	<li>
<p>
一つは、同じ~siteからの内容を，次のように~sandbox化するための利用：
</p>

<ul ><li>内容による~scriptingは不能化する。
</li><li>内容の~DOMへの~accessは許容する。
</li></ul>
◎
First, it can be used to allow content from the same site to be sandboxed to disable scripting, while still allowing access to the DOM of the sandboxed content.
</li>
	<li>
<p>
もう一つは、第三者主体~siteからの内容を埋込むときに，その内容を次のように~sandbox化するための利用：
</p>

<ul ><li>その~siteが ~popup~windowを開く, 等々は防止する。
</li><li>［
埋込まれた頁が、~dataを格納するための~database~API, 等を利用して，その出自の~siteと通信する
］ことは防止しない。
</li></ul>

◎
Second, it can be used to embed content from a third-party site, sandboxed to prevent that site from opening pop-up windows, etc, without preventing the embedded page from communicating back to its originating site, using the database APIs to store data, etc.
</li>
</ul>
</div>


			</li>
			<li>
`~form$sbox
⇒
`allow-forms@v ~NIN %tokens
◎
The sandboxed forms browsing context flag, unless tokens contains the allow-forms keyword.
</li>
			<li>
`~pointer~lock$sbox
⇒
`allow-pointer-lock@v ~NIN %tokens
◎
The sandboxed pointer lock browsing context flag, unless tokens contains the allow-pointer-lock keyword.
</li>
			<li>
`~script$sbox
⇒
`allow-scripts@v ~NIN %tokens
◎
The sandboxed scripts browsing context flag, unless tokens contains the allow-scripts keyword.
</li>
			<li>
<p>
`自動~特色機能$sbox
⇒
`allow-scripts$v ~NIN %tokens
◎
The sandboxed automatic features browsing context flag, unless tokens contains the allow-scripts keyword (defined above).
</p>

<p class="note">注記：
この~flagは、`~script$sboxと同じ~keywordで緩められる
— この~flagにより許容されなくなる宣言的~特色機能は、~scriptが可能化されている下では自明に可能0になるので。
◎
This flag is relaxed by the same keyword as scripts, because when scripts are enabled these features are trivially possible anyway, and it would be unfortunate to force authors to use script to do them when sandboxed rather than allowing them to use the declarative features.
</p>
			</li>
			<li>
`~sandbox化( ~storage域~URL )~flag$
⇒
無条件
◎
The sandboxed storage area URLs flag.
</li>
			<li>
`~document-domain$sbox
⇒
無条件
◎
The sandboxed document.domain browsing context flag.
</li>
			<li>
`~sandboxは補助~閲覧文脈に伝播する~flag$
⇒
`allow-popups-to-escape-sandbox@v ~NIN %tokens
◎
The sandbox propagates to auxiliary browsing contexts flag, unless tokens contains the allow-popups-to-escape-sandbox keyword.
</li>
			<li>
`~sandbox化( ~modal )~flag$
⇒
`allow-modals@v ~NIN %tokens
◎
The sandboxed modals flag, unless tokens contains the allow-modals keyword.
</li>
			<li>
`方位~lock$sbox
⇒
`allow-orientation-lock@v ~NIN %tokens
◎
The sandboxed orientation lock browsing context flag, unless tokens contains the allow-orientation-lock keyword.
</li>
			<li>
`呈示$sbox
⇒
`allow-presentation@v ~NIN %tokens
◎
The sandboxed presentation browsing context flag, unless tokens contains the allow-presentation keyword.
</li>
		</ul>
	</li>
</ol>

<hr>


<p>
`~sandbox用~flag集合$には、次に挙げる種類のものがある：
</p>


<ul>
	<li>
<p>
どの`~top-level閲覧文脈$も，
`~popup~sandbox用~flag集合@
を有する
— それは：
</p>

<ul ><li>`閲覧文脈$の作成-時には空~集合で~MUST。
</li><li>`名前から閲覧文脈を選ぶ規則$により拡充される。
</li></ul>
◎
Every top-level browsing context has a popup sandboxing flag set, which is a sandboxing flag set. When a browsing context is created, its popup sandboxing flag set must be empty. It is populated by the rules for choosing a browsing context given a browsing context name.
</li>
	<li>
<p>
どの`入子の閲覧文脈$も，
`~iframe~sandbox用~flag集合@
を有する
— それは：
</p>

<ul ><li>与えられた特定0の時点に，どの~flagが含められるかは、
`iframe$e 要素の`sandbox$a 属性により決定される。
</li></ul>

◎
Every browsing context that is a nested browsing context has an iframe sandboxing flag set, which is a sandboxing flag set. Which flags in a nested browsing context's iframe sandboxing flag set are set at any particular time is determined by the iframe element's sandbox attribute.
</li>
	<li>
<p>
どの`文書$も，
`作動中の~sandbox用~flag集合@
を有する
— それは：
</p>

<ul><li>`文書$の作成-時には空~集合で~MUST。
</li><li>`~navi$~algoにより拡充される。
</li></ul>

◎
Every Document has an active sandboxing flag set, which is a sandboxing flag set. When the Document is created, its active sandboxing flag set must be empty. It is populated by the navigation algorithm.
</li>
	<li>
<div class="p">
<p>
`~navi$~algoにより得られるどの資源も、
`強制~sandbox用~flag集合@
を有する
— それは：
</p>

<ul ><li>既定では空~集合である。
</li><li>他の仕様は，ある種の~flagをこの集合に入れるように定義し得る。
</li></ul>

◎
Every resource that is obtained by the navigation algorithm has a forced sandboxing flag set, which is a sandboxing flag set. A resource by default has no flags set in its forced sandboxing flag set, but other specifications can define that certain flags are set.
</div>

<p class="note">注記：
`強制~sandbox用~flag集合$は、特に，
Content Security Policy `CSP$r により利用される。
◎
In particular, the forced sandboxing flag set is used by Content Security Policy. [CSP]
</p>
	</li>
</ul>


<hr>

<p class="algo-head">
`文書$ %文書 に対し
`~sandboxingを実装する@
ときは、
%文書 の`作動中の~sandbox用~flag集合$ %S を，次のように
各種`~sandbox用~flag集合$の和集合で拡充する：
◎
To implement the sandboxing for a Document object document, populate document's active sandboxing flag set with the union of the flags that are present in the following sandboxing flag sets:
</p>

<ol>
	<li>
%B ~LET %文書 が`属する閲覧文脈$
◎
↓</li>
	<li>
~IF［
%B は`~top-level閲覧文脈$である
］
⇒
%S ~SET %S ∪ ［
%B の`~popup~sandbox用~flag集合$
］
◎
If document's browsing context is a top-level browsing context, then: the flags set on the browsing context's popup sandboxing flag set.
</li>
	<li>
~IF［
%B は`入子の閲覧文脈$である
］
⇒
%S ~SET %S ∪ ［
%B の`~iframe~sandbox用~flag集合$
］ ∪ ［［
%B の`親~閲覧文脈$にて`作動中の文書$
］の`作動中の~sandbox用~flag集合$
］
◎
If document's browsing context is a nested browsing context, then: the flags set on the browsing context's iframe sandboxing flag set.
◎
If document's browsing context is a nested browsing context, then: the flags set on the browsing context's parent browsing context's active document's active sandboxing flag set.
</li>
	<li>
~IF［
%文書 の資源には`強制~sandbox用~flag集合$ %T がある
］
⇒
%S ~SET %S ∪ %T
◎
The flags set on document's resource's forced sandboxing flag set, if it has one.
</li>
</ol>


	</section>
	<section id="history">
<h2 title="Session history and navigation">7.7. ~session履歴と~navi</h2>


		<section id="the-session-history-of-browsing-contexts">
<h3 title="The session history of browsing contexts">7.7.1. 閲覧文脈の~session履歴</h3>

<div class="p">
<p>
`閲覧文脈$ %B に`属する文書$たちからなる連列は、
%B の`~session履歴$を成す†。
`入子の閲覧文脈$を含め，どの`閲覧文脈$も、互いに別個の`~session履歴$を有する。
各
`~session履歴@
は，何個かの`~session履歴~entry$からなる平坦な~listである。
</p>

<p class="trans-note">【†
この記述は、文書と~session履歴~entryとを同一視している。
しかしながら、複数の~entryが同じ文書に対応し得る。
】</p>

<p>
各
`~session履歴~entry@
は，次のものからなる：
</p>

<ul ><li>`~URL$
</li><li>`直列形の状態$
</li><li>~title
</li><li>`文書$
</li><li>~form~data
</li><li>`~scroll復旧~mode$
</li><li>~scroll位置
</li><li>`閲覧文脈~名$
</li></ul>

<p>
これらのうち，`~URL$のみが必須とされる。
~entryには、これら以外の情報も結付けられ得る。
</p>

◎
The sequence of Documents in a browsing context is its session history. Each browsing context, including nested browsing contexts, has a distinct session history. A browsing context's session history consists of a flat list of session history entries. Each session history entry consists, at a minimum, of a URL, and each entry may in addition have serialized state, a title, a Document object, form data, a scroll restoration mode, a scroll position, a browsing context name, and other information associated with it.
</div>


<p class="note">注記：
各~entryは、最初に作成された時点で`文書$が結付けられるが、`文書$が`作動中$でないときは，資源を解放するため`破棄-$docされることもある。
`~session履歴~entry$内の`~URL$その他の~dataは、~UAが その`文書$を再び作動化する必要があると見出した場合に，元のものから新たな`文書$に代替わりするときに利用される。
◎
Each entry, when first created, has a Document. However, when a Document is not active, it's possible for it to be discarded to free resources. The URL and other data in a session history entry is then used to bring a new Document into being to take the place of the original, in case the user agent finds itself having to reactivate that Document.
</p>

<p class="note">注記：
`~session履歴~entry$の~titleは、`文書$の現在の `title$e に関係する必要はない。
この~titleが意図する所は、利用者が文書の履歴を~navigateできるよう，その時点での文書の状態を説明するためにある。
◎
Titles associated with session history entries need not have any relation with the current title of the Document. The title of a session history entry is intended to explain the state of the document at that point, so that the user can navigate the document's history.
</p>

<p>
`直列形の状態$が結付けらていない~URLは、利用者が（または~scriptにより）頁から頁へ~navigateするに伴い，~session履歴に追加される。
◎
URLs without associated serialized state are added to the session history as the user (or script) navigates from page to page.
</p>


<hr>

<p>
`閲覧文脈$の`~session履歴$内の各 `文書$には、一意な `History$I ~objが結付けられる
— そのいずれも、同じ下層の`~session履歴$を~model化し~MUST。
◎
Each Document object in a browsing context's session history is associated with a unique History object which must all model the same underlying session history.
</p>


<p class="idl-def">
`~window$上の
`history@m
属性の取得子は、此れに`結付けられている文書$に結付けられている `History$I ~objを返さ~MUST。
◎
The history attribute of the Window interface must return the object implementing the History interface for this Window object's associated Document.
</p>


<hr>

<p>
`直列形の状態@
は、~UI状態を表現している~objを（ `StructuredSerialize$jA を介して）直列化したものである。
非公式には、
“状態~obj”
と呼ばれることもある
— それは、［
作者から給された，~UI状態を表現している~obj
］，あるいは［
`直列形の状態$を（ `StructuredDeserialize$jA を介して）逆直列化して作成される~obj
］を表す。
◎
Serialized state is a serialization (via StructuredSerialize) of an object representing a user interface state. We sometimes informally refer to "state objects", which are the objects representing user interface state supplied by the author, or alternately the objects created by deserializing (via StructuredDeserialize) serialized state.
</p>


<p>
頁は、~session履歴に`直列形の状態$を<a href="#dom-history-pushstate">追加できる</a>。
これは、利用者（または~script）が履歴~内を後戻したときに，`逆直列化-$された上で
<a href="~HTMLindex#event-popstate">~scriptに返される</a>。
したがって、 1 頁だけの~appにおいても，作者が “~navi” の~metaphorを利用できるようにする。
◎
Pages can add serialized state to the session history. These are then deserialized and returned to the script when the user (or script) goes back in the history, thus enabling authors to use the "navigation" metaphor even in one-page applications.
</p>

<div class="note">

<div class="p">
<p>注記：
`直列形の状態$には、主に 二つの用途が意図されている：
</p>

<ul>
	<li>
一つは、予め構文解析した状態の記述を `~URL$と一緒に格納して，単純な事例では 作者が構文解析せずに済むようにすること（元々利用者から渡された`~URL$を取扱うときは，依然として それを構文解析する必要があるので、これは小さな最適化に過ぎない）。
</li>
	<li>
もう一つは、他からは格納されない状態
— 現在の`文書$~instanceにのみ適用され，同じ~URLの`文書$が新たに開かれるときには再構築される必要があるような、状態 —
を，作者が ~URLと一緒に格納できるようにすること。
</li>
</ul>

◎
Serialized state is intended to be used for two main purposes: first, storing a preparsed description of the state in the URL so that in the simple case an author doesn't have to do the parsing (though one would still need the parsing for handling URLs passed around by users, so it's only a minor optimization). Second, so that the author can store state that one wouldn't store in the URL because it only applies to the current Document instance and it would have to be reconstructed if a new Document were opened.
</div>

<div class="p">
<p>
後者の用例には、次が挙げられる：
</p>

<ul>
	<li>
利用者が後戻するときに、以前に~animateさせていた~popup `div$e を，同じ所在から~animateし続けれるよう，精確に協調するように追跡する。
</li>
	<li>
［［
`~URL$ 内の情報に基づいて~serverから~fetchされるような~data
］の~cache
］の中への~pointerを保っておいて、後戻する／先進するときに，その情報を再度~fetchせずに済むようにする。
</li>
</ul>

◎
An example of the latter would be something like keeping track of the precise coordinate from which a pop-up div was made to animate, so that if the user goes back, it can be made to animate to the same location. Or alternatively, it could be used to keep a pointer into a cache of data that would be fetched from the server based on the information in the URL, so that when going back and forward, the information doesn't have to be fetched again.
</div>


</div>

<hr>

<p>
どの時点においても，`~session履歴$内のある一つの~entryが
`現在の~entry@
になる。
これは、`閲覧文脈$にて`作動中の文書$を表現している~entryになる。
どの~entryが`現在の~entry$になるかは、この仕様に定義される~algo
— 例えば`履歴を走査する$間など —
により変更される。
◎
At any point, one of the entries in the session history is the current entry. This is the entry representing the active document of the browsing context. Which entry is the current entry is changed by the algorithms defined in this specification, e.g. during session history traversal.
</p>

<p class="trans-note">【
`作動中の文書$は常にあるので、~session履歴が空になることはない。
】</p>

<p class="note">注記：
`現在の~entry$は，通例的には`文書$の`~URL$docに対する~entryであるが、その文書により履歴に追加されたいずれかの`直列形の状態$に対する~entryにもなり得る。
◎
The current entry is usually an entry for the URL of the Document. However, it can also be one of the entries for serialized state added to the history by that document.
</p>

<p>
~UAにより定義される状態も持つような~entryは、
`持続的~利用者~状態を伴う@
とされる。
どのような種類の状態を格納し得るかは、この仕様では，指定しない。
◎
An entry with persisted user state is one that also has user-agent defined state. This specification does not specify what kind of state can be stored.
</p>

<p class="example">
例えば、~scroll位置や，~form~controlの値を持続化しようと求める~UAもある。
◎
For example, some user agents might want to persist the scroll position, or the values of form controls.
</p>

<p class="note">注記：
~form~controlの値を持続化する~UAには、それらの書字方向性（要素の `dir$a 属性~値）も持続化することが奨励される。
これは、明示的かつ非~既定の書字方向性の下で，利用者が元々手入力した値が，履歴の走査~後に不正に表示されることを防止する。
◎
User agents that persist the value of form controls are encouraged to also persist their directionality (the value of the element's dir attribute). This prevents values from being displayed incorrectly after a history traversal when the user had originally entered the values with an explicit, non-default directionality.
</p>

<p>
~entryの
`~scroll復旧~mode@
は、~UAがその~entryへ走査したとき，持続的~scroll位置（もしあれば）を復旧するべきかどうかを指示する。
~scroll復旧~modeは次のいずれかをとり得る：
◎
An entry's scroll restoration mode indicates whether the user agent should restore the persisted scroll position (if any) when traversing to it. The scroll restoration mode may be one of the following:
</p>

<dl class="def-list">
	<dt>`auto@l</dt>
	<dd>
~UAが、~naviに際して~scroll位置を復旧する責を負う。
◎
The user agent is responsible for restoring the scroll position upon navigation.
</dd>

	<dt>`manual@l</dt>
	<dd>
頁が、~naviに際して~scroll位置を復旧する責を負う。
~UAは、それを自動的に試みない。
◎
The page is responsible for restoring the scroll position and the user agent does not attempt to do so automatically
</dd>
</dl>

<p>
指定されていない場合、新たな~entryの`~scroll復旧~mode$は `auto$l に設定され~MUST。
◎
If unspecified, the scroll restoration mode of a new entry must be set to "auto".
</p>

<p>
`直列形の状態$を包含する各~entryは、その追加-時に作動中であった頁に対する~entryと同じ`文書$を共有する。
◎
Entries that contain serialized state share the same Document as the entry for the page that was active when they were added.
</p>

<p>
`~URL$の`素片$urlのみ相違するような，連続的な各~entryも、同じ`文書$を共有する。
◎
Contiguous entries that differ just by their URLs' fragments also share the same Document.
</p>

<p id="_contiguous" class="note">注記：
同じ`文書$を共有するすべての~entryは、定義により連続的になる（それらは、単に，特定0の文書の異なる状態たちである）。
◎
All entries that share the same Document (and that are therefore merely different states of one particular document) are contiguous by definition.
</p>

<p>
`閲覧文脈$ %B に`属する文書$ %文書 の
`最近の~entry@
とは、［
%B の`~session履歴$内の~entry
］のうち［
~entryの`文書$ ~EQ %文書
］なるもの
］があれば、それらのうち最も近過去に走査された~entryである。
そのような~entryがなければ（`文書$の作成-時）、
ε （なし）とする。
◎
Each Document in a browsing context can also have a latest entry. This is the entry for that Document to which the browsing context's session history was most recently traversed. When a Document is created, it initially has no latest entry.
</p>

<p>
~UAは、`~session履歴$内の~entry %entry に対しては：
</p>

<ul>
	<li>
［
%entry は`現在の~entry$でない
］~AND［
%entry は どの~scriptからも参照されていない
］ならば、 %entry の`文書$を，`破棄-$docしてよい
— 利用者／~scriptがそのような頁に~navigateして戻ったときは，頁を再読込みすることになる。
この仕様は、~UAがいつ`文書$を［
破棄する／~cacheする
］べきかについては指定しない。
◎
User agents may discard the Document objects of entries other than the current entry that are not referenced from any script, reloading the pages afresh when the user or script navigates back to such pages. This specification does not specify when user agents should discard Document objects and when they should cache them.
</li>
	<li>
前項により %entry の`文書$が破棄されたとしても、下に与える各種~algoの目的0においては，そうでなかったかのように動作し~MUST。
利用者あるいは~scriptが，~DOM~objを~~記憶していない頁へ~navigateして戻った／進んだときは、同じ`文書$を共有していた他の~entryも，その新たな文書~objを共有し~MUST。
◎
Entries that have had their Document objects discarded must, for the purposes of the algorithms given below, act as if they had not. When the user or script navigates back or forwards to a page which has no in-memory DOM objects, any other entries that shared the same Document object with it must share the new object as well.
</li>
</ul>


		</section>
		<section id="the-history-interface">
<h3 title="The History interface">7.7.2. `History^I ~interface</h3>

<pre class="idl">
enum `ScrollRestoration@I { `auto$l, `manual$l };

interface `History@I {
  readonly attribute unsigned long `length$m;
  attribute `ScrollRestoration$I `scrollRestoration$m;
  readonly attribute any `state$m;
  void `go$m(optional long %delta = 0);
  void `back$m();
  void `forward$m();
  void `pushState$m(any %data, DOMString %title, optional USVString? %url = null);
  void `replaceState$m(any %data, DOMString %title, optional USVString? %url = null);
};
</pre>

<dl class="domintro">
	<dt>%window . `history$m . `length$m</dt>
	<dd>
`共同~session履歴$内の~entryの個数を返す。
◎
Returns the number of entries in the joint session history.
</dd>

	<dt>%window . `history$m . `scrollRestoration$m [ = %value ]</dt>
	<dd>
`~session履歴$内の現在の~entryの`~scroll復旧~mode$を返す。
◎
Returns the scroll restoration mode of the current entry in the session history.
</dd>
	<dd>
設定して、`~session履歴$内の現在の~entryの`~scroll復旧~mode$を変更できる。
◎
Can be set, to change the scroll restoration mode of the current entry in the session history.
</dd>

	<dt>%window . `history$m . `state$m</dt>
	<dd>
現在の`直列形の状態$を逆直列化した結果の~objを返す。
◎
Returns the current serialized state, deserialized into an object.
</dd>

	<dt>%window . `history$m . `go$m( [ %delta ] )</dt>
	<dd>
`共同~session履歴$内で，指定された段~数だけ後戻する／先進する。
◎
Goes back or forward the specified number of steps in the joint session history.
</dd>
	<dd>
%delta に対する~zeroは、現在の頁を再読込みさせることになる。
◎
A zero delta will reload the current page.
</dd>
	<dd>
%delta が範囲~外を指す場合は何もしない。
◎
If the delta is out of range, does nothing.
</dd>

	<dt>%window . `history$m . `back$m()</dt>
	<dd>
`共同~session履歴$内で 1 段だけ後戻する。
◎
Goes back one step in the joint session history.
</dd>
	<dd>
前~頁がない場合は何もしない。
◎
If there is no previous page, does nothing.
</dd>

	<dt>%window . `history$m . `forward$m()</dt>
	<dd>
`共同~session履歴$内で 1 段だけ先進する。
◎
Goes forward one step in the joint session history.
</dd>
	<dd>
次~頁がない場合は何もしない。
◎
If there is no next page, does nothing.
</dd>

	<dt>%window . `history$m . `pushState$m(%data, %title [, %url ] )</dt>
	<dd>
%data, %title を~session履歴に~pushする
— %url が与えられていて ~NULL でなければ それも伴わせて。
◎
Pushes the given data onto the session history, with the given title, and, if provided and not null, the given URL.
</dd>

	<dt>%window . `history$m . `replaceState$m(%data, %title [, %url ] )</dt>
	<dd>
［
%data, %title, %url（省略時は ~NULL ）
］で，~session履歴~内の現在の~entryのそれらを更新する。
◎
Updates the current entry in the session history to have the given data, title, and, if provided and not null, URL.
</dd>
</dl>

<div class="p">
<p>
`~top-level閲覧文脈$ %B の
`共同~session履歴@
とは、［
次を満たす各 `閲覧文脈$ %B1 の`~session履歴$内の~entryうち，その`現在の~entry$以外のもの
］すべての和集合に，`共同~session履歴の現在の~entry$を加えたものである：
</p>

<ul ><li>%B1 の`~top-level閲覧文脈$ ~EQ %B
</li><li>%B1 にて`作動中の文書$は、`全部的に作動中$である
</li></ul>

◎
The joint session history of a top-level browsing context is the union of all the session histories of all browsing contexts of all the fully active Document objects that share that top-level browsing context, with all the entries that are current entries in their respective session histories removed except for the current entry of the joint session history.
</div>


<p>
`共同~session履歴の現在の~entry@
は、それを成す`~session履歴$たちの`現在の~entry$のうち，最も近過去にそうなったものを指す。
◎
The current entry of the joint session history is the entry that most recently became a current entry in its session history.
</p>

<p>
`共同~session履歴$内の各~entryは，各自が属する`~session履歴$に追加された時刻により時系列的に順序付けられ、その順に 1 ずつ増加する整数~indexが付与される
— 最も早期の~entryに付与される~indexは 0 とする。
◎
Entries in the joint session history are ordered chronologically by the time they were added to their respective session histories. Each entry has an index; the earliest entry has index 0, and the subsequent entries are numbered with consecutively increasing integers (1, 2, 3, etc).
</p>

<p class="note">注記：
同じ`閲覧文脈$に`属する文書$たち それぞれの`~event-loop$は，互いに異なり得るので、`共同~session履歴$の実際の状態は，いくぶん漠然としたものになり得る。
例えば、<!-- one unique origin＊ -->同じ生成元に属していた二つの同胞 `iframe$e 要素が，同時に別の生成元へ`履歴を走査する$こともあるので、それらの精確な順序は~well-definedにならないかもしれない。
同様に，互いが他方を後と見出すこともあるため、それぞれにとっての`共同~session履歴$の長さには，食い違いが生じるかもしれない。
◎
Since each Document in a browsing context might have a different event loop, the actual state of the joint session history can be somewhat nebulous. For example, two sibling iframe elements could both traverse from one unique origin to another at the same time, so their precise order might not be well-defined; similarly, since they might only find out about each other later, they might disagree about the length of the joint session history.
</p>


<!-- History -->
<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
</li>
			<li>
~RET `~top-level閲覧文脈$の`共同~session履歴$内の~entryの個数
</li>
		</ol>

◎
The length attribute of the History interface, on getting, must return the number of entries in the top-level browsing context's joint session history. If this History object is associated with a Document that is not fully active, getting must instead throw a "SecurityError" DOMException.
</dd>
	<dd>
~scriptからは、実際の各~entryに~accessし得ない。
◎
The actual entries are not accessible from script.
</dd>

	<dt>`scrollRestoration@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
</li>
			<li>
~RET `~session履歴$内の`現在の~entry$の`~scroll復旧~mode$
</li>
		</ol>

<p>
設定子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
</li>
			<li>
`~session履歴$内の`現在の~entry$の`~scroll復旧~mode$ ~SET 所与の値
</li>
		</ol>
◎
The scrollRestoration attribute of the History interface, on getting, must return the scroll restoration mode of the current entry in the session history. On setting, the scroll restoration mode of the current entry in the session history must be set to the new value. If this History object is associated with a Document that is not fully active, both getting and setting must instead throw a "SecurityError" DOMException.
</dd>

	<dt>`state@m</dt>
	<dd>
<p>
この属性は、初期~時には、値は~NULL にされ~MUST。
</p>
<p>
取得子は、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
</li>
			<li>
~RET ~UAにより設定された最後の値
</li>
		</ol>
◎
The state attribute of the History interface, on getting, must return the last value it was set to by the user agent. If this History object is associated with a Document that is not fully active, getting must instead throw a "SecurityError" DOMException. Initially, its value must be null.
</dd>

	<dt>`go(delta)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れを結付けている文書は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
</li>
			<li>
~IF［
%delta ~NEQ 0
］
⇒
%delta だけ`履歴を前／後に走査する$
</li>
			<li>
~ELSE
⇒
`location.reload()$m ~methodが~callされたかのように動作する
</li>
		</ol>
◎
When the go(delta) method is invoked, if delta is zero, the user agent must act as if the location.reload() method was called instead. Otherwise, the user agent must traverse the history by a delta whose value is delta. If this History object is associated with a Document that is not fully active, invoking must instead throw a "SecurityError" DOMException.
</dd>

	<dt>`back()@m</dt>
	<dd>
被呼出時には、 −1 を引数に `go()$m が~callされたかのように動作し~MUST。
◎
When the back() method is invoked, the user agent must traverse the history by a delta −1. If this History object is associated with a Document that is not fully active, invoking must instead throw a "SecurityError" DOMException.
</dd>

	<dt>`forward()@m</dt>
	<dd>
被呼出時には、 +1 を引数に `go()$m が~callされたかのように動作し~MUST。
◎
When the forward() method is invoked, the user agent must traverse the history by a delta +1. If this History object is associated with a Document that is not fully active, invoking must instead throw a "SecurityError" DOMException.
</dd>
</dl>


<hr>

<p>
各`~top-level閲覧文脈$は、初期~時には空の
`~session履歴~走査~待行列@
を持ち，`~task$を追加できる。
◎
Each top-level browsing context has a session history traversal queue, initially empty, to which tasks can be added.
</p>

<p class="algo-head">
各`~top-level閲覧文脈$ %B の作成-時には、その時点から`並列的$に，次の~algoを走らせ~MUST
— この~algoは， %B に対する
`~session履歴~event-loop@
と呼ばれる：
◎
Each top-level browsing context, when created, must begin running the following algorithm, known as the session history event loop for that top-level browsing context, in parallel:
</p>

<ol>
	<li>
%待行列 ~LET %B の`~session履歴~走査~待行列$
◎
↓</li>
	<li>
<p >
~WHILE 無条件
</p>
		<ol>
			<li>
%待行列 が空でなくなるまで待機する
◎
Wait until this top-level browsing context's session history traversal queue is not empty.
</li>
			<li>
%待行列 から最初の`~task$を取出して、それを実行する
◎
Pull the first task from this top-level browsing context's session history traversal queue, and execute it.
◎
Return to the first step of this algorithm.
</li>
		</ol>
	</li>
</ol>

<p>
`~session履歴~event-loop$は、`共同~session履歴$内の各 閲覧文脈~間の遷移を協調させ易くするためにある。
特定0の時点に，各 `閲覧文脈$が有する`~event-loop$は、互いに異なり得るので（これは、~UAが`互関係~閲覧文脈~群$ごとに複数の`~event-loop$を有するときに起こり得る）、さもなければ，遷移に際し各~event-loop間の同期をとる必要が生じる。
◎
The session history event loop helps coordinate cross-browsing-context transitions of the joint session history: since each browsing context might, at any particular time, have a different event loop (this can happen if the user agent has more than one event loop per unit of related browsing contexts), transitions would otherwise have to involve cross-event-loop synchronization.
</p>

<hr>

<p class="algo-head">
%delta だけ`履歴を前／後に走査する@
ときは、~UAは，当の`~top-level閲覧文脈$の`~session履歴~走査~待行列$に，次の手続きを走らす`~task$を付加し~MUST：
◎
To traverse the history by a delta delta, the user agent must append a task to this top-level browsing context's session history traversal queue, the task consisting of running the following steps:
</p>

 
<ol>
	<li>
%履歴 ~LET `共同~session履歴$
◎
↓</li>
	<li>
%index ~LET ( `共同~session履歴の現在の~entry$の~index ) ~PLUS %delta
◎
↓</li>
	<li>
~IF［
%index ~LT ~zero
］~OR［
%index ~GTE %履歴 内の~entry数
］
⇒
~RET
◎
If the index of the current entry of the joint session history plus delta is less than zero or greater than or equal to the number of items in the joint session history, then abort these steps.
</li>
	<li>
%~entry ~LET %履歴 内の［
~index ~EQ %index
］なる~entry
◎
Let specified entry be the entry in the joint session history whose index is the sum of delta and the index of the current entry of the joint session history.
</li>
	<li>
%B ~LET %~entry の文書が`属する閲覧文脈$<!-- ＊ -->
◎
Let specified browsing context be the browsing context of the specified entry.
</li>
	<li>
~IF［
%B にて`作動中の文書$において、現在，`文書を~unload$する~algoは走っている
］
⇒
~RET
◎
If the specified browsing context's active document's unload a document algorithm is currently running, abort these steps.
</li>
	<li>
<div class="p">
<p>
次のようにされた`~taskを待入する$：
</p>

<ul ><li>関連する`~event-loop$： %B にて`作動中の文書$のそれ
</li><li>`~task源$： `履歴~走査~task源$
</li><li>走らす手続き： 下に与える手続き
</li></ul>

◎
Queue a task that consists of running the following substeps. The relevant event loop is that of the specified browsing context's active document. The task source for the queued task is the history traversal task source.
</div>

<p>
手続きは次で与えられる：
</p>

		<ol>
			<li>
~IF［
%B を~navigateしようとする進行中の試みがある
］~AND［
%B はまだ`成熟-$していない（すなわち、 %B はまだ，その`文書$を`作動中$にする段を~~終えていない）
］
⇒
その試みを取消す
◎
If there is an ongoing attempt to navigate specified browsing context that has not yet matured (i.e. it has not passed the point of making its Document the active document), then cancel that attempt to navigate the browsing context.
</li>
			<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
			<li>
<p>
~IF［
%文書 ~NEQ %~entry の`文書$
］：
◎
If the specified browsing context's active document is not the same Document as the Document of the specified entry, then run these substeps:
</p>

				<ol>
					<li>
%文書 の`~unloadを~prompt$する
⇒
~IF［
利用者は %文書 の`~unloadを拒否-$した
］
⇒
~RET
◎
Prompt to unload the active document of the specified browsing context. If the user refused to allow the document to be unloaded, then abort these steps.
</li>
					<li>
［
%recycle ~SET ~F
］の下で， %文書 を`~unload$する
◎
Unload the active document of the specified browsing context with the recycle parameter set to false.
</li>
				</ol>
			</li>
			<li>
%~entry へ %B の`履歴を走査する$
◎
Traverse the history of the specified browsing context to the specified entry.
</li>
		</ol>
	</li>
</ol>

<p>
利用者が`閲覧文脈$を通して~navigateするとき（例えば~browserの戻る／進む~buttonを利用して）、~UAは，利用者により指定される動作に等価な分だけ`履歴を前／後に走査する$ことが要求される。
◎
When the user navigates through a browsing context, e.g. using a browser's back and forward buttons, the user agent must traverse the history by a delta equivalent to the action specified by the user.
</p>

<hr id="history-1"> 

<dl class="idl-def">
	<dt>`pushState(data, title, url)@m</dt>
	<dt>`replaceState(data, title, url)@m</dt>
	<dd>
`pushState()^m は、状態~obj~entryを履歴に追加する。
◎
The pushState(data, title, url) method adds a state object entry to the history.
</dd>
	<dd>
`replaceState()^m は、履歴~内の`現在の~entry$の［
状態~obj, ~title, （ %url が与えられていれば）`~URL$
］を更新する。
◎
The replaceState(data, title, url) method updates the state object, title, and optionally the URL of the current entry in the history.
</dd>
	<dd>
<p>
これらの~methodの被呼出時には、次の手続きを走らせ~MUST：
◎
When either of these methods is invoked, the user agent must run the following steps:
</p>

<ol>
	<li>
%文書 ~LET 此れを結付けている`文書$
◎
Let document be the unique Document object this History object is associated with.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~THROW `SecurityError$E
◎
If document is not fully active, throw a "SecurityError" DOMException.
</li>
	<li>
<p>
~UAの任意選択で
⇒
~RET
</p>

<p>
（例えば~UAは、これらの~methodの~callを，［
~timer ／
利用者による明白な動作に呼応して誘発されたものではない~event~listener
］によるものである場合や,
立て続けに呼出された場合には、不許可にできる。）
</p>
◎
Optionally, abort these steps. (For example, the user agent might disallow calls to these methods that are invoked on a timer, or from event listeners that are not triggered in response to a clear user action, or that are invoked in rapid succession.)
</li>
	<li>
%宛先~Realm ~LET 此れに`関連する~Realm$
◎
Let targetRealm be this History object's relevant Realm.
</li>
	<li>
`直列形の~data^V ~LET `StructuredSerialize$jA( %data )
（例外投出あり）
◎
Let serializedData be StructuredSerialize(data). Rethrow any exceptions.
</li>
	<li>
%新~URL ~LET ε
◎
↓</li>
	<li>
<p>
~IF［
%url ~NEQ ~NULL
］：
◎
If the third argument is not null, run these substeps:
</p>

		<ol>
			<li>
%新~URL ~SET %url を，此れに`関連する設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse the value of the third argument, relative to the relevant settings object of this History object.
</li>
			<li>
~IF［
%新~URL ~EQ ~error
］
⇒
~THROW `SecurityError$E
◎
If that fails, throw a "SecurityError" DOMException and abort these steps.
◎
Let new URL be the resulting URL record.
</li>
			<li>
%文書~URL ~LET %文書 の`~URL$doc
◎
↓</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~THROW `SecurityError$E
：
◎
↓</p>
				<ul>
					<li>
［
%新~URL, %文書~URL
］の［
`~path$url, `~query$url, `素片$url
］以外のある成分が相違する
◎
Compare new URL to document's URL. If any component of these two URL records differ other than the path, query, and fragment components, then throw a "SecurityError" DOMException and abort these steps.
</li>
					<li>
<p>
次の両者が満たされる：
</p>

<ul ><li>［
%新~URL の`生成元$url
］~NEQ`生成元$sub［
%文書 の`生成元$
］
</li><li>［
%新~URL, %文書~URL
］の［
`~path$url, `~query$url
］いずれかの成分は相違する
</li></ul>

<p>
（これは、~sandbox化された内容が 同一生成元~上の他の頁を偽装することを防止する。）
</p>
◎
If the origin of new URL is not same origin with the origin of document, and either the path or query components of the two URL records compared in the previous step differ, throw a "SecurityError" DOMException and abort these steps. (This prevents sandboxed content from spoofing other pages on the same origin.)
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
%履歴 ~LET %文書 が`属する閲覧文脈$の`~session履歴$
◎
↓</li>
	<li>
%現~entry ~LET %履歴 内の`現在の~entry$
◎
↓</li>
	<li>
~IF［
%url ~EQ ~NULL
］
⇒
%新~URL ~SET %現~entry の`~URL$
◎
If the third argument is null, then let new URL be the URL of the current entry.
</li>
	<li>
<p>
~IF［
呼出された~methodは `pushState()$m である
］：
◎
If the method invoked was the pushState() method:
</p>
		<ol>
			<li>
<p>
%履歴 内に %現~entry より後に~entryがあれば，それらすべてを除去する
◎
Remove all the entries in the browsing context's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.
</p>

<p class="note">注記：
これは、~UAの~UIに
<a href="#history-notes">影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
			</li>
			<li>
~FOR
`~top-level閲覧文脈$の`文書~族$内の~EACH ( 文書 %D )に対し
⇒
`履歴~走査~task源$から待入された`~task$のうち，
%D に結付けられているものすべてを除去する
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
			<li>
適切になるなら、~UAが持続化しようと望む状態を反映するように，
%現~entry を更新する
— この~entryは、`持続的~利用者~状態を伴う$ものとされる。
◎
If appropriate, update the current entry to reflect any state that the user agent wishes to persist. The entry is then said to be an entry with persisted user state.
</li>
			<li>
%新~entry ~LET 新たな~entry
◎
↓</li>
			<li>
%新~entry の~scroll復旧~mode ~SET %現~entry の`~scroll復旧~mode$
◎
↓</li>
			<li>
%新~entry を %履歴 の中の %現~entry の後に追加する
◎
↓</li>
			<li>
%履歴 の`現在の~entry$ ~SET %新~entry
◎
↓</li>
			<li>
%現~entry ~SET %新~entry
◎
Add a session history entry entry to the session history, after the current entry, with serializedData as the serialized state, the given title as the title, new URL as the URL of the entry, and the scroll restoration mode of the current entry in the session history as the scroll restoration mode.
◎
Update the current entry to be this newly added entry.
</li>
		</ol>
	</li>
	<li>
<p>
%現~entry を次のように更新する：
</p>

<ul ><li>`直列形の状態$ ~SET `直列形の~data^V
</li><li>~title ~SET %title
</li><li>`~URL$ ~SET %新~URL
</li></ul>

◎
Otherwise, if the method invoked was the replaceState() method:
◎
Update the current entry in the session history so that serializedData is the entry's new serialized state, the given title is the new title, and new URL is the entry's new URL.
</li>
	<li>
~IF［
%現~entry は非 `GET^h 要請を表現する（例：
それは `POST^h 提出の結果であった）
］
⇒
%現~entry を `GET^h 要請を表現するものに更新する
◎
If the current entry in the session history represents a non-GET request (e.g. it was the result of a POST submission) then update it to instead represent a GET request.
</li>
	<li>
<p>
%文書 の`~URL$doc ~SET %新~URL
◎
Set document's URL to new URL.
</p>

<p class="note">注記：
これは，［
`閲覧文脈$の`~navi$ ／ `履歴の走査$
］ではないので、
`hashchange$et ~eventは発火されない。
◎
Since this is neither a navigation of the browsing context nor a history traversal, it does not cause a hashchange event to be fired.
</p>
	</li>
	<li>
此れの `state$m 属性 ~SET
`StructuredDeserialize$jA( `直列形の~data^V, %宛先~Realm )
— ただし，例外が投出された場合は ~NULL （再~投出しない）
◎
Let state be StructuredDeserialize(serializedData, targetRealm). If this throws an exception, ignore the exception and set state to null.
◎
Set history.state to state.
</li>
	<li>
%現~entry の`文書$の`最近の~entry$ ~SET %現~entry
◎
Set the current entry's Document object's latest entry to the current entry.
</li>
</ol>

	</dd>
</dl>

<p class="note">注記：
%title は、もっぱら助言的でしかない。
~UAは，~titleを~UIに利用するかもしれない。
◎
The title is purely advisory. User agents might use the title in the user interface.
</p>

<p>
~UAは、頁ごとに，その~session履歴に追加される状態~objの個数を制限してよい。
頁がこの制限-に抵触した場合、~UAは，新たな~entryが追加された後に，［
その~session履歴~内の~entryのうち，［
当の`文書$
`新たな~entryの文書？^tnote<!-- ＊ -->
に対する最初の~entry
］の直後の~entryを除去し~MUST（したがって，状態~履歴は、先に入れたものから抹消されるように動作する（ FIFO ）一方で、~naviに対しては，先に入れたものが最後に残るように動作する（ LIFO ））。
◎
User agents may limit the number of state objects added to the session history per page. If a page hits the UA-defined limit, user agents must remove the entry immediately after the first entry for that Document object in the session history after having added the new entry. (Thus the state history acts as a FIFO buffer for eviction, but as a LIFO buffer for navigation.)
</p>

<div class="example">

<p>
~gameを考える：
利用者は常に，ある “線” 上のある座標に位置していて、線に沿って~navigateでき、特定0の座標に対応する頁を~bookmarkすれば後でそこへ戻れるとする。
◎
Consider a game where the user can navigate along a line, such that the user is always at some coordinate, and such that the user can bookmark the page corresponding to a particular coordinate, to return to it later.
</p>

<p>
そのような~gameの，位置 x=5 を実装している静的な頁として、次の様なものがあるとする：
◎
A static page implementing the x=5 position in such a game could look like the following:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 5 に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"&gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"&gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
</pre>
<!-- 
<!DOCTYPE HTML>
<!-&45; this is https://example.com/line?x=5 -&45;>
<title>Line Game - 5</title>
<p>You are at coordinate 5 on the line.</p>
<p>
 <a href="?x=6">Advance to 6</a> or
 <a href="?x=4">retreat to 4</a>?
</p>
-->
<p>
そのような~systemにおいて問題になるのは、利用者が~clickするたびに，頁~全体の再読込みを要することである。
次に、~scriptを利用して同じことをする別の仕方を示す：
◎
The problem with such a system is that each time the user clicks, the whole page has to be reloaded. Here instead is another way of doing it, using script:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;!-- ここは https://example.com/line?x=5 --&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;Line Game - 5&lt;/title&gt;
&lt;p&gt;あなたは線~上の座標 &lt;span id="coord"&gt;5&lt;/span&gt; に居ます。&lt;/p&gt;
&lt;p&gt;
 &lt;a href="?x=6"
   onclick="go(1); return false;"
 &gt;6 へ進む&lt;/a&gt; ・
 &lt;a href="?x=4"
   onclick="go(-1); return false;"
 &gt;4 へ戻る&lt;/a&gt;
&lt;/p&gt;
&lt;script&gt;
 var %currentPage = 5; /* <span class="comment"
>~serverからあてがわれる
◎
prefilled by server
</span> */
 function go(%d) {
   setupPage(%currentPage + %d);
   history.pushState(%currentPage, document.title, '?x=' + %currentPage);
 }
 onpopstate = function(%event) {
   setupPage(%event.state);
 }
 function setupPage(%page) {
   %currentPage = %page;
   document.title = 'Line Game - ' + %currentPage;
   document.getElementById('coord').textContent = %currentPage;
   document.links[0].href = '?x=' + (%currentPage + 1);
   document.links[0].textContent = 'Advance to ' + (%currentPage + 1);
   document.links[1].href = '?x=' + (%currentPage - 1);
   document.links[1].textContent = 'retreat to ' + (%currentPage - 1);
 }
&lt;/script&gt;
</pre>

<!-- 
<!DOCTYPE HTML>
&lt;!-&45; this starts off as https://example.com/line?x=5 &45;-&gt;
<title>Line Game - 5</title>
<p>You are at coordinate <span id="coord">5</span> on the line.</p>
<p>
 <a href="?x=6" onclick="go(1); return false;">Advance to 6</a> or
 <a href="?x=4" onclick="go(-1); return false;">retreat to 4</a>?
</p>
<script>
 var currentPage = 5; // prefilled by server

-->

<p>
これは、~scriptの~supportを切っている~systemにおいても，依然として先掲の例の様に働くが、
<em>切っていない</em> 利用者は，ずっと高速に~navigateできるようになる
— 同じ体験に対し~network~accessはないので。
更には、~scriptに基づく素朴な~approachによる利用者~体験と違って，~session履歴を
~bookmarkする／~navigateする
のも依然として働く。
◎
In systems without script, this still works like the previous example. However, users that do have script support can now navigate much faster, since there is no network access for the same experience. Furthermore, contrary to the experience the user would have with just a naïve script-based approach, bookmarking and navigating the session history still work.
</p>

<p>
上の例において、
`pushState()$m ~methodに対する %data 引数は，~serverへ送信されることになる情報と同じになるが、利用者が~navigateするたびに~scriptが~URLを構文解析しなくとも済むような，より簡便な形になる。
◎
In the example above, the data argument to the pushState() method is the same information as would be sent to the server, but in a more convenient form, so that the script doesn't have to parse the URL each time the user navigates.
</p>
</div>

<br />

<div class="example">
<p>
~appは、その時点の`~session履歴~entry$に対する~titleに，文書の `title$e 要素の値と同じ値を利用しないこともできる。
例えばここに、 `title$e 要素~内に，ある~blockを示す単純な頁があるとする。
~navigateして以前の状態に後戻しても，利用者の時間は後戻しないので、~session履歴~title内に時刻を入れるのは不適切になるであろう。
◎
Applications might not use the same title for a session history entry as the value of the document's title element at that time. For example, here is a simple page that shows a block in the title element. Clearly, when navigating backwards to a previous state the user does not go back in time, and therefore it would be inappropriate to put the time in the session history title.
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;HTML LANG=EN&gt;
&lt;TITLE&gt;Line&lt;/TITLE&gt;
&lt;SCRIPT&gt;
 setInterval(function () {
   document.title = 'Line - ' + new Date();
 }, 1000);
 var %i = 1;
 function inc() {
   set(%i+1);
   history.pushState(%i, 'Line - ' + i);
 }
 function set(%newI) {
   %i = %newI;
   document.forms.F.I.value = %newI;
 }
&lt;/SCRIPT&gt;
&lt;BODY ONPOPSTATE="set(%event.state)"&gt;
&lt;FORM NAME=F&gt;
   State:
   &lt;OUTPUT NAME=I&gt;1&lt;/OUTPUT&gt;
   &lt;INPUT VALUE="Increment" TYPE=BUTTON ONCLICK="inc()"&gt;
&lt;/FORM&gt;
</pre>

</div>

<div class="example">
<p>
ほとんどの~appは、自身の履歴~entryのすべてに対し，同じ`~scroll復旧~mode$値を利用したいと求める。
そのためには、できるだけ早く `scrollRestoration$m 属性を設定して（例えば、文書の `head$e 要素~内の `script$e 要素で），［
履歴~sessionに追加された~entryが，欲される~scroll復旧~modeを取得する
］ことを確保することにより，達成できる。
◎
Most applications want to use the same scroll restoration mode value for all of their history entries. To achieve this they can set the scrollRestoration attribute as soon as possible (e.g., in the first script element in the document's head element) to ensure that any entry added to the history session gets the desired scroll restoration mode.
</p>

<pre>
&lt;head&gt;
  &lt;script&gt;
       if ('scrollRestoration' in history)
            history.scrollRestoration = 'manual';
  &lt;/script&gt;
&lt;/head&gt;
</pre>
</div>


		</section>
		<section id="history-notes">
<h3 title="Implementation notes for session history">7.7.3 ~session履歴に対する実装~上の注記</h3>

~INFORMATIVE

<p>
`History$I ~interfaceは、実装が~session履歴を利用者に向けてどう表現するかについて制約を課すものではない。
◎
The History interface is not meant to place restrictions on how implementations represent the session history to the user.
</p>


<p>
例えば~session履歴を，各~頁が，複数の “~~前方へ~~枝分かれする” 頁を持つ様な方式で実装することもできる。
この仕様は、 `history$m ~obj内の各~頁からなる一本道の~listが利用者からどう見えるかについて，実際の~session履歴から導出する方法は定義しない。
◎
For example, session history could be implemented in a tree-like manner, with each page having multiple "forward" pages. This specification doesn't define how the linear list of pages in the history object are derived from the actual session history as seen from the user's perspective.
</p>

<p>
同様に，ある頁が二つの `iframe$e を包含しているとき，頁は各 `iframe$e の `history$m ~objとは別個の `history$m ~objを持つ
— ［
二つの内縁~frameと外縁~頁の~navi
］を互いに差挟むような~session履歴を伴うような。
代表的な~Web~browserは、利用者に一つしか “戻る” ~buttonを呈示しない事実があるにもかかわらず。
◎
Similarly, a page containing two iframes has a history object distinct from the iframes' history objects, despite the fact that typical Web browsers present the user with just one "Back" button, with a session history that interleaves the navigation of the two inner frames and the outer page.
</p>


<p>
<strong>保安</strong>：
ある頁が `pushState()$m を濫用して，~UAの履歴~navi便宜性を
“乗っ取る” のを避けるため、~UAには，以前の頁へ一足飛びに戻る仕方を利用者に提供することが示唆される（単に一つ前の状態へ後戻するのでなく）。
例えば、戻る~buttonは，~session履歴~内の頁たちだけを示し，他のどの状態も示さないような ~drop-downを持たせることもできる。
同様に，聴覚~browserは、二つ前へ “戻る” ~command
— 一つ前の状態へ後戻するもの, 以前の頁へ一足飛びに戻るもの —
を持たせることもできる。
◎
Security: It is suggested that to avoid letting a page "hijack" the history navigation facilities of a UA by abusing pushState(), the UA provide the user with a way to jump back to the previous page (rather than just going back to the previous state). For example, the back button could have a drop down showing just the pages in the session history, and not showing any of the states. Similarly, an aural browser could have two "back" commands, one that goes back to the previous state, and one that jumps straight back to the previous page.
</p>


<p>
`pushState()$m, `replaceState()$m
いずれに対しても，~UAには、頻繁過ぎる~callや巨大過ぎる状態~objを介するような，
これらの~APIの濫用-を防止することが奨励される。
上に詳細を与えたように，~algoでは、適切になるときは，~UAがそのような~callを無視することも 明示的に許容されている。
◎
For both pushState() and replaceState(), user agents are encouraged to prevent abuse of these APIs via too-frequent calls or over-large state objects. As detailed above, the algorithm explicitly allows user agents to ignore any such calls when appropriate.
</p>



		</section>
		<section id="the-location-interface">
<h3 title="The Location interface">7.7.4. `Location^I ~interface</h3>

<p>
各 `~window$には、その作成-時に，新たな `Location$I ~objが結付けられる。
<!-- unique instance of 〜 allocated -->
</p>

<p class="trans-note">【
以下，ここでは、この節の内容のうち，~APIに関する部分のみ述べる。
他の内容は、
<a href="~HTMLWPROXY#the-location-interface">別ページ</a>
にて。
】</p>


<dl class="domintro">
	<dt>%document . `~location0$m [ = %value ]</dt>
	<dt>%window . `location$m [ = %value ]</dt>
	<dd>
現在の頁の所在を伴う `Location$I ~objを返す。
◎
Returns a Location object with the current page's location.
</dd>
	<dd>
設定して，別の頁へ~navigateできる。
◎
Can be set, to navigate to another page.
</dd>
</dl>


<dl class="idl-def">
	<dt>`document.location@m</dt>
	<dd>
取得子は、［
此れが`全部的に作動中$ならば，此れに`関連する大域~obj$の `Location$I ~obj ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The Document object's location attribute's getter must return this Document object's relevant global object's Location object, if this Document object is fully active, and null otherwise.
</dd>

	<dt>`window.location@m</dt>
	<dd>
取得子は、此れの `Location$I ~objを返さ~MUST。
◎
The Window object's location attribute's getter must return this Window object's Location object.
</dd>

</dl>



<p>
`Location$I ~objは、それに`対応する閲覧文脈$Locにて`作動中の文書$の`~URL$docを表現し、`閲覧文脈$の~session履歴の`現在の~entry$を，
`history$m ~obj内［
に~entryを追加する ／
の~entryを置換する
］ことを通して 変更できるようにする。
◎
Location objects provide a representation of the URL of the active document of their Document's browsing context, and allow the current entry of the browsing context's session history to be changed, by adding or replacing entries in the history object.
</p>

<pre class="idl">
[Unforgeable] interface `Location@I { /* <span class="comment">
ただし、
<a href="~HTMLWPROXY#the-location-interface">追加の作成~手続き</a>
と
<a href="~HTMLWPROXY#location-internal-methods">上書きされた内部~method</a>
も見よ。
◎
but see also additional creation steps and overridden internal methods
</span> */

  [Unforgeable] stringifier attribute USVString `href$m;
  [Unforgeable] readonly attribute USVString `origin$m;
  [Unforgeable] attribute USVString `protocol$m;
  [Unforgeable] attribute USVString `host$m;
  [Unforgeable] attribute USVString `hostname$m;
  [Unforgeable] attribute USVString `port$m;
  [Unforgeable] attribute USVString `pathname$m;
  [Unforgeable] attribute USVString `search$m;
  [Unforgeable] attribute USVString `hash$m;

  [Unforgeable] void `assign$m(USVString %url);
  [Unforgeable] void `replace$m(USVString %url);
  [Unforgeable] void `reload$m();

  [Unforgeable, SameObject] readonly attribute `DOMStringList$I `ancestorOrigins$m;
};
</pre>




<dl class="domintro">
	<dt>%location . `toString()^m</dt>
	<dt>%location . `href$m</dt>
	<dd>
`~url$Locを返す。
◎
Returns the Location object's URL.
</dd>
	<dd>
設定して，所与の~URLへ~navigateできる。
◎
Can be set, to navigate to the given URL.
</dd>

	<dt>%location . `origin$m</dt>
	<dd>
`~url$Locの生成元を返す。
◎
Returns the Location object's URL's origin.
</dd>

	<dt>%location . `protocol$m</dt>
	<dd>
`~url$Locの~schemeを返す。
◎
Returns the Location object's URL's scheme.
</dd>
	<dd>
設定して，`~url$Locの~schemeだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed scheme.
</dd>

	<dt>%location . `host$m</dt>
	<dd>
`~url$Locの［
~host,
~port（~schemeに対する`既定の~port$urlと異なるならば）
］を返す。
◎
Returns the Location object's URL's host and port (if different from the default port for the scheme).
</dd>
	<dd>
設定して，`~url$Locの
~host, ~port
だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host and port.
</dd>

	<dt>%location . `hostname$m</dt>
	<dd>
`~url$Locの~hostを返す。
◎
Returns the Location object's URL's host.
</dd>
	<dd>
設定して，`~url$Locの~hostだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed host.
</dd>

	<dt>%location . `port$m</dt>
	<dd>
`~url$Locの~port を返す。
◎
Returns the Location object's URL's port.
</dd>
	<dd>
設定して，`~url$Locの~portだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed port.
</dd>

	<dt>%location . `pathname$m</dt>
	<dd>
`~url$Locの~path を返す。
◎
Returns the Location object's URL's path.
</dd>
	<dd>
設定して，`~url$Locの~pathだけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed path.
</dd>

	<dt>%location . `search$m</dt>
	<dd>
`~url$Locの~queryを返す（空でないならば 先頭の `?^l も含する）。
◎
Returns the Location object's URL's query (includes leading "?" if non-empty).
</dd>
	<dd>
設定して，`~url$Locの~query（先頭の `?^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed query (ignores leading "?").
</dd>

	<dt>%location . `hash$m</dt>
	<dd>
`~url$Locの素片を返す（空でないならば
先頭の `#^l を含する）。
◎
Returns the Location object's URL's fragment (includes leading "#" if non-empty).
</dd>
	<dd>
設定して，`~url$Locの素片（先頭の `#^l は無視する）だけ変更した~URLへ~navigateできる。
◎
Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").
</dd>

	<dt>%location . `assign$m(%url)</dt>
	<dd>
%url へ~navigateする。
◎
Navigates to the given URL.
</dd>

	<dt>%location . `replace$m(%url)</dt>
	<dd>
~session履歴から現在の頁を除去した上で，所与の %url へ~navigateする。
◎
Removes the current page from the session history and navigates to the given URL.
</dd>

	<dt>%location . `reload$m()</dt>
	<dd>
現在の頁を再読込みする。
◎
Reloads the current page.
</dd>

	<dt>%location . `ancestorOrigins$m</dt>
	<dd>
`親~閲覧文脈$から`~top-level閲覧文脈$までの各［
先祖`閲覧文脈$の生成元の値
］からなる， `DOMStringList$I ~objを返す。
◎
Returns a DOMStringList object listing the origins of the ancestor browsing contexts, from the parent browsing context to the top-level browsing context.

Returns an array whose values are 
</dd>
</dl>



<p>
各 `Location$I ~obj %L には、次が定義される：
◎
↓</p>

<dl class="def-list">
	<dt>`対応する閲覧文脈@Loc</dt>
	<dd>
%L を結付けている`~window$に`対応する閲覧文脈$を指す。
</dd>
	<dd class="trans-note">【
この定義は、訳者の推定による。
原文では，
“%L の文書の閲覧文脈” あるいは単に “the 閲覧文脈”
等々としか記されていないが、
%L は`~window$に結付けられるものと定義されているので。
】</dd>

	<dt>`関連する文書@Loc</dt>
	<dd>
%L に`対応する閲覧文脈$Locにて`作動中の文書$を指す。
◎
A Location object has an associated relevant Document, which is this Location object's associated Document object's browsing context's active document.
</dd>

	<dt>`~url@Loc</dt>
	<dd>
%L に`関連する文書$Locの`~URL$docを指す。
◎
A Location object has an associated url, which is this Location object's relevant Document's address.
</dd>

	<dt>`先祖~生成元~list@</dt>
	<dd>
<p>
%L の作成-時に，次の手続きから得られる文字列の~listが結付けられた
`DOMStringList$I ~objに設定され~MUST：
◎
A Location object has an associated ancestor origins list. When a Location object is created, its ancestor origins list must be set to a DOMStringList object whose associated list is the list of strings that the following steps would produce:
</p>

<ol>
	<li>
%~list ~LET 新たな空`~list$
◎
Let output be a new list of strings.
</li>
	<li>
%L に`対応する閲覧文脈$Loc %B の
~EACH( `先祖~閲覧文脈$ %先祖 ) に対し， %B に近い先祖から順に
⇒
［［［
%先祖 にて`作動中の文書$
］の`生成元$
］を`~Unicode直列化$した結果
］を %~list に`付加-$する
◎
Let current be the browsing context of the Document with which this Location object is associated.
◎
Loop: If current has no parent browsing context, jump to the step labeled end.
◎
Let current be current's parent browsing context.
◎
Append the Unicode serialization of current's active document's origin to output.
◎
Return to the step labeled loop.
</li>
	<li>
~RET %~list
◎
End: Return output.
</li>
</ol>
	</dd>
	<dd class="trans-note">【
`ancestorOrigins$m のみから利用される。
作成-時~以降は変化しないと見られる。
】</dd>
</dl>


<p class="algo-head">
`~Location~obj設定子により~navigateする@
ときは、所与の
( `Location$I ~obj %L, `~URL~record$ %url )
に対し，次を走らす：
◎
A Location object has an associated Location-object-setter navigate algorithm, which given a url, runs these steps:
</p>

<ol>
	<li>
<p>
`置換え~flag^V ~LET［
次のいずれかが満たされるならば ~OFF ／
~ELSE_ ~ON
］：
◎
If any of the following conditions are met, let replacement flag be unset; otherwise, let it be set:
</p>
		<ul>
			<li>
%L に`関連する文書$Locは、`完全に読込まれ$ている
◎
This Location object's relevant Document has completely loaded, or
</li>
			<li><!-- ＊？ -->
この~algoを走らせている`~task$は、次を満たす~eventに対する［
`作動化の挙動$を現在~処理して ／ ~event~listenerを取扱って
］いる
⇒
名前 `click$et ~AND
`isTrusted$m ~EQ ~T
◎
In the task in which the algorithm is running, an activation behavior is currently being processed whose click event's isTrusted attribute is true, or
◎
In the task in which the algorithm is running, the event listener for a click event, whose isTrusted attribute is true, is being handled.
</li>
		</ul>
	</li>
	<li>
次を与える下で，`~Location~objにより~navigateする$
⇒
( %L, %url, `置換え~flag^V )
◎
Location-object navigate, given url and replacement flag.
</li>
</ol>


<p class="algo-head">
`~Location~objにより~navigateする@
ときは、所与の
( `Location$I ~obj %L, `~URL~record$ %url, `置換え~flag^V )
に対し，次を走らす：
◎
To Location-object navigate, given a url and replacement flag, run these steps:
</p>

<ol>
	<li>
%B ~LET %L に`対応する閲覧文脈$Loc
◎
↓</li>
	<li>
<p>
次を与える下で， %url へ %B を`~navigate$する（例外投出あり）：
</p>

		<ul>
			<li>
`~source閲覧文脈$は、`現任の設定群~obj$により指定される`担当の閲覧文脈$enV
</li>
			<li>
`例外~可能化~flag$ ~SET ~ON
</li>
			<li>
<p>
次のいずれかに該当する場合は、`置換え可能化~flag$ ~SET ~ON：
</p>

<ul ><li>`置換え~flag^V ~EQ ~ON
</li><li>%B の`~session履歴$は、 %B の作成-時に作成された `about_blank$sc `文書$のみからなる
</li></ul>

			</li>
		</ul>

◎
• The source browsing context is the responsible browsing context specified by the incumbent settings object.
• Navigate the browsing context to url, with the exceptions enabled flag set. Rethrow any exceptions.
• If the replacement flag is set or the browsing context's session history contains only one Document, and that was the about:blank Document created when the browsing context was created, then the navigation must be done with replacement enabled.
</li>
</ol>

<p class="algo-head">
`Location$I ~obj %L の
`生成元~domainを検査する@
ときは、次を走らす：
</p>

<ol>
	<li>
~IF［
%L に`関連する文書$Locの`生成元$
~NEQ`~domain$sub
`~entry設定群~obj$の`生成元$enV
］
⇒
~THROW `SecurityError$E
<!-- 
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
 -->
</li>
</ol>

<p class="trans-note">【
この手続きは、以下を簡潔に記すためにこの訳に導入したもの。
】</p>



<dl class="idl-def">

	<dt>`href@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The href attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET 此れが指す`~url$Locを`~URL直列化器$にかけた結果
◎
Return this Location object's url, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The href attribute's setter must run these steps:
</p>

		<ol>
			<li>
%~URL~record ~LET 所与の値を，`~entry設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse the given value relative to the entry settings object. If that failed, throw a TypeError exception.
</li>
			<li>
~IF［
%~URL~record ~EQ ~error
］
⇒
~THROW `TypeError$E
◎
↑</li>
			<li>
次を与える下で，`~Location~obj設定子により~navigateする$
⇒
( 此れ, %~URL~record )
◎
Location-object-setter navigate to the resulting URL record.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`href$m 属性~設定子に対しては、意図的に保安~検査は行われない。
◎
The href attribute setter intentionally has no security check.
</dd>


	<dt>`origin@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The origin attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET 此れが指す`~url$Locの`生成元$urlの`~Unicode直列化$
◎
Return the Unicode serialization of this Location object's url's origin.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`MessageEvent$I との互換性をとるため、これは，~ASCII直列化ではなく~Unicodeを返す。
◎
It returns the Unicode rather than the ASCII serialization for compatibility with MessageEvent.
</dd>


	<dt>`protocol@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The protocol attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET 次を順に連結した結果
⇒
此れが指す`~url$Locの`~scheme$url,<br>
`:^l
◎
Return this Location object's url's scheme, followed by ":".
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The protocol attribute's setter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
%~protocol文字列 ~LET 次を順に連結した結果
⇒
所与の値,<br>
`:^l
◎
↓</li>
			<li>
<p>
%possibleFailure ~LET 次を与える下で， %~protocol文字列 を`基本~URL構文解析器$にかけた結果
⇒
~URLと上書stateの組：
( %複製~URL, `~scheme開始-~state$url )
◎
Let possibleFailure be the result of basic URL parsing the given value, followed by ":", with copyURL as url and scheme start state as state override.
</p>
<p class="note">注記：
~URL構文解析器は，連続する~colonを無視するので、値に `https:^l を与えても（あるいは `https::::^l でさえ），
`https^l を与えるのと同じことになる。
◎
Because the URL parser ignores multiple consecutive colons, providing a value of "https:" (or even "https::::") is the same as providing a value of "https".
</p>
			</li>
			<li>
~IF［
%possibleFailure ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If possibleFailure is failure, then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%複製~URL の `~scheme$urlは`~HTTP_S~scheme$である
］
⇒
~RET
◎
If copyURL's scheme is not an HTTP(S) scheme, then terminate these steps.
</li>
			<li>
次を与える下で，`~Location~obj設定子により~navigateする$
⇒
( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>


	<dt>`host@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The host attribute's getter must run these steps:
</p>


		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%url ~LET 此れが指す`~url$Loc
◎
Let url be this Location object's url.
</li>
			<li>
~IF［
%url の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If url's host is null, return the empty string.
</li>
			<li>
%~host文字列 ~LET %url の`~host$urlを`~host直列化器$にかけた結果
◎
↓</li>
			<li>
~IF［
%url の`~port$url ~EQ ~NULL
］
⇒
~RET %~host文字列
◎
If url's port is null, return url's host, serialized.
</li>
			<li>
~RET 次を順に連結した結果
⇒
%~host文字列,<br>
`:^l,<br>
%url の`~port$urlを`整数として直列化-$urlした結果
◎
Return url's host, serialized, followed by ":" and url's port, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The host attribute's setter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
~IF［
%複製~URL の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~host~state$url )
◎
Basic URL parse the given value, with copyURL as url and host state as state override.
</li>
			<li>
次を与える下で，`~Location~obj設定子により~navigateする$
⇒
( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>


	<dt>`hostname@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The hostname attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
此れが指す`~url$Locの
`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this Location object's url's host is null, return the empty string.
</li>
			<li>
~RET 此れが指す`~url$Locの`~host$urlを`~host直列化器$にかけた結果
◎
Return this Location object's url's host, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The hostname attribute's setter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
~IF［
%複製~URL の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~hostname~state$url )
◎
Basic URL parse the given value, with copyURL as url and hostname state as state override.
</li>
			<li>
次を与える下で，`~Location~obj設定子により~navigateする$
⇒
( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>


	<dt>`port@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The port attribute's getter must run these steps:
</p>
		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
此れが指す`~url$Locの
`~port$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If this Location object's url's port is null, return the empty string.
</li>
			<li>
~RET 此れが指す`~url$Locの`~port$urlを`整数として直列化-$urlした結果
◎
Return this Location object's url's port, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The port attribute's setter must run these steps:
</p>


		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
~IF［
%複製~URL は `~username／~password／~portを持てない$
］
⇒
~RET
◎
If copyURL cannot have a username/password/port, then return.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~port$url ~SET ~NULL
◎
If the given value is the empty string, then set copyURL's port to null.
</li>
			<li>
~ELSE
⇒
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~port~state$url )
◎
Otherwise, basic URL parse the given value, with copyURL as url and port state as state override.
</li>
			<li>
次を与える下で，`~Location~obj設定子により~navigateする$
⇒
( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>

	<dt>`pathname@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The pathname attribute's getter must run these steps:
</p>
		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%url ~LET 此れが指す`~url$Loc
◎
Let url be this Location object's url.
</li>
			<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET %url の`~path$url内の最初の文字列
◎
If url's cannot-be-a-base-URL flag is set, return the first string in url's path.
</li>
			<li>
~IF［
%url の`~path$urlは空である
］
⇒
~RET 空~文字列
◎
If url's path is empty, then return the empty string.
</li>
			<li>
~RET 次を順に連結した結果
⇒
`/^l,<br>
［
%url の`~path$url内の各~文字列（空~文字列も含めて）を `/^l で区切って連結した結果
］
◎
Return "/", followed by the strings in url's path (including empty strings), separated from each other by "/".
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The pathname attribute's setter must run these steps:
</p>
		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
~IF［
%複製~URL の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If copyURL's cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
%複製~URL の`~path$url ~SET 空~list
◎
Set copyURL's path to the empty list.
</li>
			<li>
次を与える下で，所与の値を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~path開始-~state$url )
◎
Basic URL parse the given value, with copyURL as url and path start state as state override.
</li>
			<li>
次を与える下で，`~Location~obj設定子により~navigateする$
⇒
( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>

	<dt>`search@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The search attribute's getter must run these steps:
</p>


		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
此れが指す`~url$Locの`~query$url
~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this Location object's url's query is either null or the empty string, return the empty string.
</li>
			<li>
~RET 次を順に連結した結果
⇒
`?^l,<br>
此れが指す`~url$Locの`~query$url
◎
Return "?", followed by this Location object's url's query.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The search attribute's setter must run these steps:
</p>


		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%複製~URL の`~query$url ~SET ~NULL
◎
If the given value is the empty string, set copyURL's query to null.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise, run these substeps:
</p>


				<ol>
					<li>
%入力 ~LET 所与の値
◎
↓</li>
					<li>
~IF［
%入力 の最初の文字 ~EQ `?^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "?" removed, if any.
</li>
					<li>
%複製~URL の`~query$url ~SET 空~文字列
◎
Set copyURL's query to the empty string.
</li>
					<li>
次を与える下で，%入力 を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `~query~state$url ),<br>
`上書き符号化方式^V： 此れに`関連する文書$Locの`文字~符号化方式$doc
◎
Basic URL parse input, with copyURL as url and query state as state override, and the relevant Document's document's character encoding as encoding override.
</li>
				</ol>
			</li>
			<li>
次を与える下で，`~Location~obj設定子により~navigateする$
⇒
( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>
	</dd>


	<dt>`hash@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The hash attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~IF［
此れが指す`~url$Locの`素片$url
~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If this Location object's url's fragment is either null or the empty string, return the empty string.
</li>
			<li>
~RET 次を順に連結した結果
⇒
`#^l,<br>
此れが指す`~url$Locの`素片$url
◎
Return "#", followed by this Location object's url's fragment.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次の手続きを走らせ~MUST：
◎
The hash attribute's setter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
%複製~URL ~LET 此れが指す`~url$Locの複製
◎
Let copyURL be a copy of this Location object's url.
</li>
			<li>
%入力 ~LET 所与の値
◎
↓</li>
			<li>
~IF［
%入力 の最初の文字 ~EQ `#^l
］
⇒
%入力 から最初の文字を除去する
◎
Let input be the given value with a single leading "#" removed, if any.
</li>
			<li>
%複製~URL の`素片$url ~SET 空~文字列
◎
Set copyURL's fragment to the empty string.
</li>
			<li>
次を与える下で， %入力 を`基本~URL構文解析器$にかける
⇒
~URLと上書stateの組：
( %複製~URL, `素片~state$url )
◎
Basic URL parse input, with copyURL as url and fragment state as state override.
</li>
			<li>
次を与える下で，`~Location~obj設定子により~navigateする$
⇒
( 此れ, %複製~URL )
◎
Location-object-setter navigate to copyURL.
</li>
		</ol>


<p class="note">注記：
`a$e, `area$e 要素に対する等価な~APIと違って，
`hash$m 属性の設定子は、［
空~文字列を，配備済みの~scriptと互換にするよう特別に扱う
］ことはない。
◎
Unlike the equivalent API for the a and area elements, the hash attribute's setter does not special case the empty string to remain compatible with deployed scripts.
</p>
	</dd>


	<dt>`assign(url)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
When the assign(url) method is invoked, the user agent must run the following steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
<p>
%~URL~record ~LET %url を，`~entry設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse url relative to the entry settings object. If that failed, throw a "SyntaxError" DOMException.
</p>

<p>
~IF［
%~URL~record ~EQ ~error
］
⇒
~THROW `SyntaxError$E
◎
↑</p>
	</li>
			<li>
次を与える下で，`~Location~objにより~navigateする$
⇒
( 此れ, %~URL~record )
◎
Location-object navigate to the resulting URL record.
</li>
		</ol>
	</dd>


	<dt>`replace(url)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
When the replace(url) method is invoked, the user agent must run the following steps:
</p>

		<ol>
			<li>
%~URL~record ~LET 
%url を，`~entry設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse url relative to the entry settings object. If that failed, throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%~URL~record ~EQ ~error
］
⇒
~THROW `SyntaxError$E
◎
↑</li>
			<li>
次を与える下で，`~Location~objにより~navigateする$
⇒
( 此れ, %~URL~record, ~ON )
◎
Location-object navigate to the resulting URL record with the replacement flag set.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`replace()$m ~methodに対しては、意図的に保安~検査は行われない。
◎
The replace() method intentionally has no security check.
</dd>

	<dt>`reload()@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
When the reload() method is invoked, the user agent must run the appropriate steps from the following list:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin
• throw a "SecurityError" DOMException.
</li>
			<li>
%B ~LET 此れに`対応する閲覧文脈$Loc
</li>
			<li>
<p>
~IF［
現在~実行-中の`~task$†は、利用者による %B の~resizeに呼応して配送された `resize$et ~eventによるものである††
］
⇒
%B を塗りなおす†††
◎
If the currently executing task is the dispatch of a resize event in response to the user resizing the browsing context
• Repaint the browsing context and abort these steps.
</p>

<p class="trans-note">【†<!-- ＊ -->
`現在~走っている~task$？
】【††
すなわち，この~methodが `resize^et ~event~handlerの中から呼出されたとき？
】【†††
“repaint”
— 単に再~描画するだけ？
】</p>

			</li>
			<li>
~ELIF［
%B にて`作動中の文書$は`~iframe~srcdoc文書$である
］
⇒
%B の`閲覧文脈~容器$の
<a href="~HEembed#process-the-iframe-attributes">~iframe属性を再処理する</a>
◎
If the browsing context's active document is an iframe srcdoc document
• Reprocess the iframe attributes of the browsing context's browsing context container.
</li>
			<li>
<p>
~ELIF［
%B にて`作動中の文書$の`再読込み上書き~flag$ ~EQ ~ON
］
⇒
%B を`担当の閲覧文脈$enV†とする下で，`上書きされた再読込み$を遂行する
（例外投出あり）
◎
If the browsing context's active document has its reload override flag set
• Perform an overridden reload, with the browsing context being navigated as the responsible browsing context. Rethrow any exceptions.
</p>

<p class="trans-note">【†
`~source閲覧文脈$の誤記？
】</p>

			</li>
			<li>
<p >
~ELSE
⇒
次を与える下で， %B を此れが指す`~url$Locへ`~navigate$して（例外投出あり）、`閲覧文脈$の`現在の~entry$の`~entry更新-$を遂行する：
</p>

<ul ><li>`例外~可能化~flag$ ~SET ~ON
</li><li>`~source閲覧文脈$ ~SET %B
</li></ul>

<p>
この~naviは、`再読込みにより誘発され$たものとされる。
</p>

◎
Otherwise
• Navigate the browsing context to this Location object's relevant Document's URL to perform an entry update of the browsing context's current entry, with the exceptions enabled flag set. The source browsing context must be the browsing context being navigated. This is a reload-triggered navigation. Rethrow any exceptions.
</li>
		</ol>

	</dd>
	<dd>
<p>
利用者から ~UI要素†を通して［
`閲覧文脈$ %B にて`作動中の文書$ %文書 を再読込みする
］よう要請されたときは、~UAは：
</p>

<p class="trans-note">【†
~browserの “再読込み~button” 等を指すと思われるが，~DOM内の要素も含まれる？
】</p>

<ul>
	<li>
%B を %文書 と同じ資源へ`~navigate$して，`閲覧文脈$の`現在の~entry$の`~entry更新-$を遂行するべきである。
この~naviは、`再読込みにより誘発され$たものとされる。
</li>
	<li>
非冪等~method（例： ~HTTP `POST^meth ）の事例では、~UAは先ず，利用者にその演算を確認してもらうよう~promptするべきである
— さもなければ~transaction（例：購入や~database改変）が繰返され得るので。
</li>
	<li>
［
再読込み時に~cacheを明示的に上書きする
］ことを，利用者に許容してよい。
</li>
	<li>
［
%文書 の`再読込み上書き~flag$ ~EQ ~ON
］の場合、この段落に述べた~naviに代わって，`上書きされた再読込み$を遂行してよい（`~source閲覧文脈$として %B を与える下で）。
</li>
</ul>

◎
When a user requests that the active document of a browsing context be reloaded through a user interface element, the user agent should navigate the browsing context to the same resource as that Document, to perform an entry update of the browsing context's current entry. This is a reload-triggered navigation. In the case of non-idempotent methods (e.g. HTTP POST), the user agent should prompt the user to confirm the operation first, since otherwise transactions (e.g. purchases or database modifications) could be repeated. User agents may allow the user to explicitly override any caches when reloading. If browsing context's active document's reload override flag is set, then the user agent may instead perform an overridden reload rather than the navigation described in this paragraph (with the browsing context being reloaded as the source browsing context).
</dd>

	<dt>`ancestorOrigins@m</dt>
	<dd>
<p>
取得子は、次の手続きを走らせ~MUST：
◎
The ancestorOrigins attribute's getter must run these steps:
</p>

		<ol>
			<li>
此れの`生成元~domainを検査する$
◎
If this Location object's relevant Document's origin is not same origin-domain with the entry settings object's origin, then throw a "SecurityError" DOMException.
</li>
			<li>
~RET 此れの`先祖~生成元~list$
◎
Otherwise, return this Location object's ancestor origins list.
</li>
		</ol>
	</dd>
</dl>


<hr>

<p class="trans-note">【
以下，この節, およびその各 下位節の内容は、
<a href="~HTMLWPROXY#the-location-interface">別ページ</a>
にて。
】</p>


		</section>
	</section>

	<section id="browsing-the-web">
<h2 title="Browsing the Web">7.8. ~webの閲覧</h2>

<p class="trans-note">【
この節の内容は
<a href="~NAVI#browsing-the-web">別ページ</a>にて。
】</p>

	</section>

	<section id="offline">
<h2 title="Offline Web applications">7.9. ~offline~web~app</h2>

<p class="trans-note">【
この節の内容は未訳。
】</p>

	</section>

</section></main>
