<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — 8.1. Scripting</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/webappapis.html',
		main: 'MAIN',
//		alt_refs: 'references',
//		ref_id_prefix: 'refs',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160412 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		sc: 'scheme',
		jA: 'abstract',
		sl: 'js-slot',
		h: 'header',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		hd: 'code',
		c: 'code',
		s: 'samp',
		e: 'code',
		a: 'code',
		sc: 'code',
		et: 'code',
		h: 'code',
		jA: 'span',
		sl: 'span',
		v: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
//	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|%[\w~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN', '_toc_list0');


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		if(match[1]){
			in_idl = true;
			nesting += '</pre>';
			return '<pre class="idl">';
		} else {
			nesting += '</span>';
			return '：<span class="block">';
		}
	case '⇒！':
	}//◎
	if(in_idl) {
		result = nesting;
		in_idl = false;
	} else {
		result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	}
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
//var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	if(in_idl) tag = '';
	break;
case 'm': // IDL member
case 'hd': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	if(in_idl) tag = '';
	break;
case 'sc': // url scheme
	text += ':';
	break;
case 'sl': // JS internal slot
	text = '[[' + text + ']]';
	break;
case 'et': // event type
	break;
case 'i': // model constants
	break;
case 'v': // variables
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
	prepare-to-run-script:prepare-to-run-a-callback
	clean-up-after-running-script:clean-up-after-running-a-callback
	scripting-processing-model:processing-model-7
	event-loop-processing-model:processing-model-8
</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">
	●IDL
I.GlobalEventHandlers:#globaleventhandlers
I.WindowEventHandlers:#windoweventhandlers
I.DocumentAndElementEventHandlers:#documentandelementeventhandlers
I.PromiseRejectionEvent:#promiserejectionevent
I.PromiseRejectionEventInit:#promiserejectioneventinit
I.ErrorEvent:#errorevent
I.ErrorEventInit:#erroreventinit
I.EventHandler:#eventhandler
I.EventHandlerNonNull:#eventhandlernonnull
I.OnBeforeUnloadEventHandler:#onbeforeunloadeventhandler
I.OnBeforeUnloadEventHandlerNonNull:#onbeforeunloadeventhandlernonnull
I.OnErrorEventHandler:#onerroreventhandler
I.OnErrorEventHandlerNonNull:#onerroreventhandlernonnull

I.BeforeUnloadEvent:~HTML-BROWSE#beforeunloadevent
I.Document:~HTMLDOM#document
I.HTMLElement:~HTMLDOM#htmlelement
I.MessagePort:~HTML-COMMS#messageport

I.Window:~HTML-BROWSE#window
I.WindowProxy:~HTML-BROWSE#windowproxy
I.WorkerGlobalScope:~WORKERS#workerglobalscope

I.Error:~WEBIDL#idl-error
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#interface-eventtarget
I.Function:~WEBIDL#common-Function
I.MouseEvent:~UIEVENTS#interface-mouseevent
	~UIEVENTS#interface-MouseEvent＊？
I.Performance:~HRTIME#the-performance-interface
I.QuotaExceededError:~WEBIDL#quotaexceedederror
I.NetworkError:~WEBIDL#networkerror

I.Navigator:~HTML5/webappapis.html#navigator

m.getBattery:https://w3c.github.io/battery/#widl-Navigator-getBattery-Promise-BatteryManager
m.print:~HTML5/webappapis.html#dom-print

	m.Performance.now

	ErrorEvent
m.colno:#dom-errorevent-colno
m.error:#dom-errorevent-error
m.filename:#dom-errorevent-filename
m.lineno:#dom-errorevent-lineno
m.message:#dom-errorevent-message

	PromiseRejectionEvent
m.promise:#dom-promiserejectionevent-promise
m.reason:#dom-promiserejectionevent-reason

m.document.open:~HTML-WAPI#dom-document-open
m.document.write:~HTML-WAPI#dom-document-write
m.window.alert:~HTML-WAPI##dom-alert

	DOM4
m.addEventListener:~DOM4#dom-eventtarget-addeventlistener
m.currentTarget:~DOM4#dom-event-currenttarget

m.relatedTarget:~UIEVENTS#dom-mouseevent-relatedtarget
m.view:~UIEVENTS#dom-uievent-view
m.now:~HRTIME#dom-performance-now

m.assign:~HTML-BROWSE#dom-location-assign
m.history.back:~HTML-BROWSE#dom-history-back
m.history.pushState:~HTML-BROWSE#dom-history-pushstate
m.opener:~HTML-BROWSE#dom-opener
m.returnValue:~HTML-BROWSE#dom-beforeunloadevent-returnvalue

m.click:~HTML-INTERACT#dom-click
m.onmessage:~HTML-COMMS#handler-messageport-onmessage


	~UIEVENTS#dom-mouseevent-XXXXX
		screenX, screenY, clientX, clientY, button, relatedTarget
		ctrlKey, shiftKey, altKey, metaKey, getModifierState
	~UIEVENTS#dom-uievent-XXXXX
		view, detail

	●handler
hd.onabort:#handler-onabort
hd.onautocomplete:#handler-onautocomplete
hd.onautocompleteerror:#handler-onautocompleteerror
hd.onblur:#handler-onblur
hd.oncancel:#handler-oncancel
hd.oncanplay:#handler-oncanplay
hd.oncanplaythrough:#handler-oncanplaythrough
hd.onchange:#handler-onchange
hd.onclick:#handler-onclick
hd.onclose:#handler-onclose
hd.oncontextmenu:#handler-oncontextmenu
hd.oncuechange:#handler-oncuechange
hd.ondblclick:#handler-ondblclick
hd.ondrag:#handler-ondrag
hd.ondragend:#handler-ondragend
hd.ondragenter:#handler-ondragenter
hd.ondragexit:#handler-ondragexit
hd.ondragleave:#handler-ondragleave
hd.ondragover:#handler-ondragover
hd.ondragstart:#handler-ondragstart
hd.ondrop:#handler-ondrop
hd.ondurationchange:#handler-ondurationchange
hd.onemptied:#handler-onemptied
hd.onended:#handler-onended
hd.onerror:#handler-onerror
hd.onfocus:#handler-onfocus
hd.oninput:#handler-oninput
hd.oninvalid:#handler-oninvalid
hd.onkeydown:#handler-onkeydown
hd.onkeypress:#handler-onkeypress
hd.onkeyup:#handler-onkeyup
hd.onload:#handler-onload
hd.onloadeddata:#handler-onloadeddata
hd.onloadedmetadata:#handler-onloadedmetadata
hd.onmousedown:#handler-onmousedown
hd.onmouseenter:#handler-onmouseenter
hd.onmouseleave:#handler-onmouseleave
hd.onmousemove:#handler-onmousemove
hd.onmouseout:#handler-onmouseout
hd.onmouseover:#handler-onmouseover
hd.onmouseup:#handler-onmouseup
hd.onpause:#handler-onpause
hd.onplay:#handler-onplay
hd.onplaying:#handler-onplaying
hd.onprogress:#handler-onprogress
hd.onratechange:#handler-onratechange
hd.onreadystatechange:#handler-onreadystatechange
hd.onreset:#handler-onreset
hd.onresize:#handler-onresize
hd.onscroll:#handler-onscroll
hd.onseeked:#handler-onseeked
hd.onseeking:#handler-onseeking
hd.onselect:#handler-onselect
hd.onshow:#handler-onshow
hd.onstalled:#handler-onstalled
hd.onsubmit:#handler-onsubmit
hd.onsuspend:#handler-onsuspend
hd.ontimeupdate:#handler-ontimeupdate
hd.ontoggle:#handler-ontoggle
hd.onvolumechange:#handler-onvolumechange
hd.onwaiting:#handler-onwaiting
hd.onwheel:#handler-onwheel
hd.onloadstart:#handler-onloadstart
hd.oncut:#handler-oncut
hd.oncopy:#handler-oncopy
hd.onpaste:#handler-onpaste

	●handler-window
hd.onafterprint:#handler-window-onafterprint
hd.onbeforeprint:#handler-window-onbeforeprint
hd.onbeforeunload:#handler-window-onbeforeunload
hd.onhashchange:#handler-window-onhashchange
hd.onlanguagechange:#handler-window-onlanguagechange
hd.onmessage:#handler-window-onmessage
hd.onoffline:#handler-window-onoffline
hd.ononline:#handler-window-ononline
hd.onpagehide:#handler-window-onpagehide
hd.onpageshow:#handler-window-onpageshow
hd.onpopstate:#handler-window-onpopstate
hd.onrejectionhandled:#handler-window-onrejectionhandled
hd.onstorage:#handler-window-onstorage
hd.onunhandledrejection:#handler-window-onunhandledrejection
hd.onunload:#handler-window-onunload

	●event
et.abort:~HTML-IND#event-abort
et.afterprint:~HTML-IND#event-afterprint
et.autocomplete:~HTML-IND#event-autocomplete
et.autocompleteerror:~HTML-IND#event-autocompleteerror
et.beforeprint:~HTML-IND#event-beforeprint
et.beforeunload:~HTML-IND#event-beforeunload
et.blur:~HTML-IND#event-blur
et.cancel:~HTML-IND#event-cancel
et.change:~HTML-IND#event-change
et.close:~HTML-IND#event-close
et.contextmenu:~HTML-IND#event-contextmenu
et.error:~HTML-IND#event-error
et.focus:~HTML-IND#event-focus
et.hashchange:~HTML-IND#event-hashchange
et.input:~HTML-IND#event-input
et.invalid:~HTML-IND#event-invalid
et.languagechange:~HTML-IND#event-languagechange
et.load:~HTML-IND#event-load
et.message:~HTML-IND#event-message
et.offline:~HTML-IND#event-offline
et.online:~HTML-IND#event-online
et.pagehide:~HTML-IND#event-pagehide
et.pageshow:~HTML-IND#event-pageshow
et.popstate:~HTML-IND#event-popstate
et.readystatechange:~HTML-IND#event-readystatechange
et.rejectionhandled:~HTML-IND#event-rejectionhandled
et.reset:~HTML-IND#event-reset
et.select:~HTML-IND#event-select
et.show:~HTML-IND#event-show
et.storage:~HTML-IND#event-storage
et.submit:~HTML-IND#event-submit
et.toggle:~HTML-IND#event-toggle
et.unhandledrejection:~HTML-IND#event-unhandledrejection
et.unload:~HTML-IND#event-unload
et.cut:~HTML-IND#event-cut
et.copy:~HTML-IND#event-copy
et.paste:~HTML-IND#event-paste

	//~HTMLCONFORM#event-XXXXX
et.click:~UIEVENTS#event-type-click
et.dblclick:~UIEVENTS#event-type-dblclick
et.keydown:~UIEVENTS#event-type-keydown
et.keypress:~UIEVENTS#event-type-keypress
et.keyup:~UIEVENTS#event-type-keyup
et.mousedown:~UIEVENTS#event-type-mousedown
et.mouseenter:~UIEVENTS#event-type-mouseenter
et.mouseleave:~UIEVENTS#event-type-mouseleave
et.mousemove:~UIEVENTS#event-type-mousemove
et.mouseout:~UIEVENTS#event-type-mouseout
et.mouseover:~UIEVENTS#event-type-mouseover
et.mouseup:~UIEVENTS#event-type-mouseup
et.wheel:~UIEVENTS#event-type-wheel
et.resize:~CSSOMVIEW#eventdef-window-resize
et.scroll:~CSSOMVIEW#eventdef-document-scroll

et.canplay:~HTML-EMB#event-media-canplay
et.canplaythrough:~HTML-EMB#event-media-canplaythrough
et.cuechange:~HTML-EMB#event-media-cuechange
et.durationchange:~HTML-EMB#event-media-durationchange
et.emptied:~HTML-EMB#event-media-emptied
et.ended:~HTML-EMB#event-media-ended
et.loadeddata:~HTML-EMB#event-media-loadeddata
et.loadedmetadata:~HTML-EMB#event-media-loadedmetadata
et.loadstart:~HTML-EMB#event-media-loadstart
et.pause:~HTML-EMB#event-media-pause
et.play:~HTML-EMB#event-media-play
et.playing:~HTML-EMB#event-media-playing
et.progress:~HTML-EMB#event-media-progress
et.ratechange:~HTML-EMB#event-media-ratechange
et.seeked:~HTML-EMB#event-media-seeked
et.seeking:~HTML-EMB#event-media-seeking
et.stalled:~HTML-EMB#event-media-stalled
et.suspend:~HTML-EMB#event-media-suspend
et.timeupdate:~HTML-EMB#event-media-timeupdate
et.volumechange:~HTML-EMB#event-media-volumechange
et.waiting:~HTML-EMB#event-media-waiting

et.drag:~HTMLDND#event-dnd-drag
et.dragend:~HTMLDND#event-dnd-dragend
et.dragenter:~HTMLDND#event-dnd-dragenter
et.dragexit:~HTMLDND#event-dnd-dragexit
et.dragleave:~HTMLDND#event-dnd-dragleave
et.dragover:~HTMLDND#event-dnd-dragover
et.dragstart:~HTMLDND#event-dnd-dragstart
et.drop:~HTMLDND#event-dnd-drop


	●scheme
sc.blob:~FILEAPI#DefinitionOfScheme
sc.javascript:~HTML-BROWSE#javascript-protocol

	●要素
e.body:~HTML-SEM#the-body-element
e.iframe:~HTML-EMB#the-iframe-element
e.script:~HTMLSCRIPT#the-script-element
e.frameset:~HTML-OBS#frameset

a.type:~HTMLSCRIPT#attr-script-type

	●HTTP header
h.Referer:~RFC7231#section-5.5.2
h.User-Agent


i.Anonymous:~HTMLINFRA#attr-crossorigin-anonymous
i.Use Credentials:~HTMLINFRA#attr-crossorigin-none
i.No CORS:~HTMLINFRA#attr-crossorigin-none


	●
非同期に完了-:#_asynchronously-complete
文書:#_document
	~HTMLDOM#document
~window:#_window

~scriptingは不能化され:#concept-bc-noscript
~scriptingは可能化され:#concept-bc-script
	可能化-:#concept-bc-script
~nodeに対し，~scriptingは可能化され:#concept-n-script
~nodeに対し，~scriptingは不能化され:#concept-n-noscript

~script:#concept-script
資格証~mode:#concept-module-script-credentials-mode
暗号用~nonce:#concept-module-script-nonce
構文解析器~状態:#concept-module-script-parser

~classic~script:#classic-script
~classic~scriptを作成-:#creating-a-classic-script
~classic~scriptを~fetchする:#fetch-a-classic-script
~classic~scriptを走らす:#run-a-classic-script
~classic~worker~scriptを~fetchする:#fetch-a-classic-worker-script

~module~script:#module-script
~module~scriptを走らす:#run-a-module-script
~module~scriptを作成-:#creating-a-module-script
~module~script木を~fetchする:#fetch-a-module-script-tree
~module指定子を解決-:#resolve-a-module-specifier
~module~record:#concept-module-script-module-record
~module~map:#module-map
子孫を~fetchする:#fetch-the-descendants-of-a-module-script
単独の~module~scriptを~fetchする:#fetch-a-single-module-script

~scriptは走れるかどうか検査-:#check-if-we-can-run-script
走中の~script:#running-script
走中の~scriptを中止-:#abort-a-running-script
中止-:#abort-a-running-script
~source~text:#concept-classic-script-source-text
基底~URL:#concept-module-script-base-url

黙秘error~flag:#muted-errors
設定群~obj:#settings-object
現在の設定群~obj:#current-settings-object
環境~設定群~obj:#environment-settings-object
~realm実行~文脈:#realm-execution-context
担当の閲覧文脈:#responsible-browsing-context
担当の文書:#responsible-document
担当の~event~loop:#responsible-event-loop
~API~URL文字~符号化方式:#api-url-character-encoding
~API基底~URL:#api-base-url
作成~URL:#creation-url
~HTTPS状態:#https-state

通知待ちの却下済み~promise~list:#about-to-be-notified-rejected-promises-list
未決の却下済み~promiseへの弱参照~集合:#outstanding-rejected-promises-weak-set



大域~obj:#global-object
1.大域~obj:#concept-realm-global
	~Realmの大域~obj
関連する設定群~obj:#relevant-settings-object
	#relevant-settings-object-for-a-global-object
0.大域~obj:#concept-settings-object-global
~Realm:#environment-settings-object's-realm
	'
1.設定群~obj:#concept-realm-settings-object
	~Realmの設定群~obj
0.~Realm:#concept-global-object-realm
	大域~objの~Realm:#concept-global-object-realm

現在の〜:#concept-current-everything
~entry:#concept-entry-everything
~incumbent:#concept-incumbent-everything
〜に関連する:#concept-relevant-everything

~entry~Realm:#concept-entry-realm
~entry実行~文脈:#entry-execution-context
~entry大域~obj:#entry-global-object
~entry設定群~obj:#entry-settings-object
~entrance~counter:#entrance-counter

~incumbent設定群~obj:#incumbent-settings-object
~incumbent大域~obj:#concept-incumbent-global
~incumbent~Realm:#concept-incumbent-realm

関連する大域~obj:#concept-relevant-global
関連する~Realm:#concept-relevant-realm
現在の大域~obj:#current-global-object


要請を設定しておく:#fetching-scripts-set-up-request
応答を処理する:#fetching-scripts-process-response

~scriptを走らすために準備する:#prepare-to-run-script
走らせた~scriptを片付ける:#clean-up-after-running-script
	clean-up-after-running-a-script


大域~script片付け~job~list:#global-script-clean-up-jobs-list
大域~script片付け~jobを走らす:#run-the-global-script-clean-up-jobs

例外を報告する:#report-the-exception
~error報告~mode下:#in-error-reporting-mode
~errorを報告する:#report-the-error
err.取扱済み~flag:#concept-error-handled
err.取扱済みでない:#concept-error-nothandled
rej.取扱済み~flag:#concept-promise-rejection-handled
rej.取扱済みでない:#concept-promise-rejection-nothandled
実行時~script~error:#runtime-script-errors
却下済み~promiseについて通知-:#notify-about-rejected-promises
	未取扱いの~promise却下:#unhandled-promise-rejections

~event~loop:#event-loop
閲覧文脈~event~loop:#_browsing-context-event-loop
~worker~event~loop:#_worker-event-loop
~event~loopを回す:#spin-the-event-loop
	~event~loopの~spinning:#spin-the-event-loop
同期区間:#synchronous-section

~task:#concept-task
~task待行列:#task-queue
~task源:#task-source
現在~走中の~task:#currently-running-task
極小task~task源:#microtask-task-source
DOM 操作~task源:#dom-manipulation-task-source
履歴~走査~task源:#history-traversal-task-source
利用者対話~task源:#user-interaction-task-source
~network用~task源:#networking-task-source
~taskを待入する:#queue-a-task
待入する:#queue-a-task
待入され:#queue-a-task
極小taskを待入する:#queue-a-microtask
極小task:#microtask
極小task待行列:#microtask-queue
極小task~checkpoint遂行-中~flag:#performing-a-microtask-checkpoint
極小task~checkpointを遂行する:#perform-a-microtask-checkpoint
孤立~callback極小task:#solitary-callback-microtask
複合~極小task:#compound-microtask
複合~極小task下位task:#compound-microtask-subtask
複合~極小task下位taskを実行する:#execute-a-compound-microtask-subtask
~callbackを包装する:#execute-a-compound-microtask-subtask
安定~状態を待受ける:#await-a-stable-state
一時停止-:#pause


~event~handler:#event-handlers
内部的な生の未compileの~handler:#internal-raw-uncompiled-handler
~event~handler~IDL属性:#event-handler-idl-attributes
~event~handler内容~属性:#event-handler-content-attributes
~event~handler~event型:#event-handler-event-type
~event~handler処理~algo:#the-event-handler-processing-algorithm
~event~handlerの現在の値を取得-:#getting-the-current-value-of-the-event-handler
	呼出す:#concept-invoke-event-handler

click ~eventを発火する:#fire-a-click-event
単純~eventを発火する:#fire-a-simple-event
合成~mouse~eventを発火する:#fire-a-synthetic-mouse-event
	最初の段:#step1


全screen描画~手続き:#run-the-fullscreen-rendering-steps
CSS ~animationを走らせて~eventを送信する:#run-css-animations-and-send-events
~animation~frame~callbackたちを走らす:~HTML-WAPI#run-the-animation-frame-callbacks

	●~HTMLINFRA
HTML 要素:~HTMLINFRA#html-elements
並列的:~HTMLINFRA#in-parallel
~CORS非同一生成元:~HTMLINFRA#cors-cross-origin
~CORS同一生成元:~HTMLINFRA#cors-same-origin
~CORSになり得る要請を作成-:~HTMLINFRA#create-a-potential-cors-request
~URLを構文解析-:~HTMLINFRA#parse-a-url
Content Type ~metadata:~HTMLINFRA#content-type
~trusted:~HTMLINFRA#concept-events-trusted

x.基底~URL:~HTMLINFRA#document-base-url
x.文書の中へ挿入-:~HTMLINFRA#insert-an-element-into-a-document

	●URLSpec, ENCODING
x.~URL:~URLSpec#concept-url
x.絶対~URL:~URLSpec#syntax-url-absolute
x.相対~URL:~HTMLCONFORM#relative-url
x.~URL構文解析器:~URLSpec#concept-url-parser

x.UTF-8 復号-:~ENCODING#utf-8-decode
x.Unicode に復号-:~ENCODING#decode

	●DOM4
x.配送-:~DOM4#concept-event-dispatch
x.配送する:~DOM4#concept-event-dispatch
x.DOM ~event配送-~logic:~DOM4#concept-event-listener-invoke
x.要素:~DOM4#concept-element
x.~event~listener:~DOM4#concept-event-listener
	＊x.文字~符号化方式:~DOM4#concept-document-encoding
	~HTMLCONFORM#document%27s-character-encoding
x.木~順序:~DOM4#concept-tree-order
x.~address:~DOM4#concept-document-url
	https://dom.spec.whatwg.org/#concept-document-url
x.~node文書:~DOM4#concept-node-document
	https://dom.spec.whatwg.org/#concept-node-document

	●WEBIDL
x.~callback this 値:~WEBIDL#dfn-callback-this-value
x.Web IDL ~callback関数を呼出す:~WEBIDL#es-invoking-callback-functions
x.~platform~obj:~WEBIDL#dfn-platform-object
x.属する大域~環境:~WEBIDL#es-platform-objects

	●UIEVENTS
取消可能:~UIEVENTS#event-flow-default-cancel
取消不可:~UIEVENTS#event-flow-default-cancel
	浮上-:~UIEVENTS#

	●CSSOMVIEW
x.~resize手続き:~CSSOMVIEW#run-the-resize-steps
x.~scroll手続き:~CSSOMVIEW#run-the-scroll-steps
x.媒体~queriesを評価して変化を報告する:~CSSOMVIEW#evaluate-media-queries-and-report-changes

	●WORKERS
x.~worker:~WORKERS#workers
	x.~worker~event~loop:~WORKERS#worker-event-loop
x.~closing~flag:~WORKERS#dom-workerglobalscope-closing
x.~workerを走らす:~WORKERS#run-a-worker
x.~worker処理~model:~WORKERS#run-a-worker

	●FETCH
x.~fetchする:~FETCH#concept-fetch
	x.~fetching:~FETCH#concept-fetch
x.~MIME型を抽出-:~FETCH#concept-header-extract-mime-type
x.応答を処理する:~FETCH#process-response
x.応答:~FETCH#concept-response
x.終了-:~FETCH#concept-fetch-terminate
x.要請:~FETCH#concept-request
rq.~client:~FETCH#concept-request-client
rq.~mode:~FETCH#concept-request-mode
rq.~url:~FETCH#concept-request-url
rq.種別:~FETCH#concept-request-type
rq.~referrer:~FETCH#concept-request-referrer
rq.行先:~FETCH#concept-request-destination
rq.要請~URL:~FETCH#concept-request-url
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.暗号用~nonce~metadata:~FETCH#concept-request-nonce-metadata
rq.構文解析器~metadata:~FETCH#concept-request-parser-metadata
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.~ok~status:~FETCH#ok-status
rs.~status:~FETCH#concept-response-status
rs.~url:~FETCH#concept-response-url
rs.応答~URL:~FETCH#concept-response-url
rs.種別:~FETCH#concept-response-type

	●HTML-BROWSE
x.作動中の文書:~HTML-BROWSE#active-document
x.作動中の~sandboxing~flag集合:~HTML-BROWSE#active-sandboxing-flag-set
x.閲覧文脈~容器:~HTML-BROWSE#browsing-context-container
x.閲覧文脈:~HTML-BROWSE#browsing-context
x.属する閲覧文脈:~HTML-BROWSE#concept-document-bc
	doc.閲覧文脈:~HTML-BROWSE#concept-document-bc
x.実効~script生成元:~HTML-BROWSE#effective-script-origin
x.全部的に作動中の:~HTML-BROWSE#fully-active
x.全部的に作動中:~HTML-BROWSE#fully-active
x.~navigate:~HTML-BROWSE#navigate
x.入子の閲覧文脈:~HTML-BROWSE#nested-browsing-context
x.生成元:~HTML-BROWSE#concept-origin
x.~sandboxed~script閲覧文脈~flag:~HTML-BROWSE#sandboxed-scripts-browsing-context-flag
x.~source閲覧文脈:~HTML-BROWSE#source-browsing-context
x.~windowの文書:~HTML-BROWSE#concept-document-window
x.~top-level閲覧文脈:~HTML-BROWSE#top-level-browsing-context
x.互関係~閲覧文脈~群:~HTML-BROWSE#unit-of-related-browsing-contexts
x.互関係かつ類似生成元の閲覧文脈~群:~HTML-BROWSE#unit-of-related-similar-origin-browsing-contexts
	＊
x.通して入子に:~HTML-BROWSE#browsing-context-nested-through

	●ES6
js.初期化-:~ES6#sec-initializehostdefinedrealm
js.~JS~realm:~ES6#sec-code-realms
js.現在の~Realm~Record:~ES6#current-realm
js.自動的~semicolon挿入:~ES6#sec-automatic-semicolon-insertion
js.早期の~error:~ES6#early-error-rule
js.~JS実行~文脈~stack:~ES6#execution-context-stack
js.~JS実行~文脈:~ES6#sec-execution-contexts
js.走中の~JS実行~文脈:~ES6#running-execution-context
js.Use Strict Directive:~ES6#use-strict-directive
js.Directive Prologue:~ES6#directive-prologue
js.Script:~ES6#prod-Script
js.Source Text Module Record:~ES6#sec-source-text-module-records
js.List:~ES6#sec-list-and-record-specification-type
js.TypeError:~ES6#sec-native-error-types-used-in-this-standard-typeerror

	●ES6 抽象演算
jA.EnqueueJob:~ES6#sec-enqueuejob
jA.FunctionBody:~ES6#prod-FunctionBody
jA.FunctionCreate:~ES6#sec-functioncreate
jA.GetActiveScriptOrModule():~ES6#sec-getactivescriptormodule
jA.HostEnsureCanCompileStrings:~ES6#sec-hostensurecancompilestrings
jA.HostPromiseRejectionTracker:~ES6#sec-host-promise-rejection-tracker
jA.HostResolveImportedModule:~ES6#sec-hostresolveimportedmodule
jA.ModuleDeclarationInstantiation:~ES6#sec-moduledeclarationinstantiation
jA.ModuleEvaluation:~ES6#sec-moduleevaluation
jA.NewObjectEnvironment:~ES6#sec-newobjectenvironment
jA.ParseModule:~ES6#sec-parsemodule
jA.ParseScript:~ES6#sec-parse-script
jA.RunJobs:~ES6#sec-runjobs
jA.ScriptEvaluation:~ES6#sec-runtime-semantics-scriptevaluation

jA.EnsureCSPDoesNotBlockStringCompilation:~CSP3#can-compile-strings
	https://w3c.github.io/webappsec-csp/#can-compile-strings

	●外部~HTML
x.HTML 構文解析器:~HTML-SYNTAX#html-parser
x.~form所有者:~HTML-FORMS#form-owner
x.故意的な違反:~HTML-INTRO#willful-violation
x.~script:~HTMLSCRIPT#the-script-element
x.~JS~MIME型:~HTMLSCRIPT#javascript-mime-type

	要素の~inline型の挙動は~CSPにより阻止されるべきか？:~CSP3#should-block-inline

</script>


<!--% 置換データ -->
<script type="text/plain" id="words_table1">
ES6:https://tc39.github.io/ecma262/
	~HTML5/infrastructure.html
RFC7231:RFC7231-ja.html
HRTIME:hr-time-2-ja.html
HTMLSCRIPT:HTML-scripting-ja.html


HTML-WAPI:https://html.spec.whatwg.org/multipage/webappapis.html
HTML-IND:https://html.spec.whatwg.org/multipage/indices.html
HTML-COMMS:https://html.spec.whatwg.org/multipage/comms.html
HTML-OBS:https://html.spec.whatwg.org/multipage/obsolete.html
HTML-FORMS:https://html.spec.whatwg.org/multipage/forms.html
	HTML-TABLES:https://html.spec.whatwg.org/multipage/tables.html
HTML-EMB:https://html.spec.whatwg.org/multipage/embedded-content.html
HTML-SEM:https://html.spec.whatwg.org/multipage/semantics.html
HTML-INTERACT:https://html.spec.whatwg.org/multipage/interaction.html
HTML-BROWSE:https://html.spec.whatwg.org/multipage/browsers.html
HTML-SYNTAX:https://html.spec.whatwg.org/multipage/syntax.html
HTML-INTRO:https://html.spec.whatwg.org/multipage/introduction.html

Assert:<b>Assert</b>

</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">
API:
URL:
HTTPS:
IDL:

CSP:Content Security Policy:CSP
JS:JavaScript
	Document
	ECMAScript
	DOM
	CSS
	File API
	HTML
	SVG
	Hz

Web:
	Window::::~
	Worker::::~
	base64:

sandboxing:
sandboxed:
Record:
field:
	:::フィールド
interface::::インタフェース
flag::::フラグ
obj:object:::オブジェクト
method::::メソッド
window:
	:::ウィンドウ
worker:
	:::ワーカ
	:::スクリプト
algo:algorithm:::アルゴリズム
animation::::アニメーション
block::::ブロック
	~boolean::::~
browser::::ブラウザ
byte::::バイト
button::::ボタン
click::::クリック
comment:
閉じる:close する:~
	~~空にする~clear する
	まだはっきりしない not be immediately clear
	~clean::::~
型強制-:coerce::強制
	来る~coming::::~
custom::::カスタム
customize::::カスタマイズ
file::::ファイル
form::::フォーム
frame::::フレーム
頻度:frequency:~
更新率:refresh rate:~
消去る:go away する:消え去る

group::::グループ
hash::::ハッシュ
header::::ヘッダ
	モノ:instrument:もの
interpreter::::インタプリタ
key::::キー
keyboard::::キーボード
list::::リスト
markup::::マークアップ
mouse::::マウス
	UI:user interface:UI
	~UI mouse and key ／ keyboard and mouse
member::::メンバ
mode::::モード
message::::メッセージ
node::::ノード
privacy::::プライバシー
private::::プライベート
出自に:originate::~
program::::プログラム
	半分以上three quarters of the time
queries::::クエリ
quota::::クォータ
抑制-:reduce:~
	、~~能力は抑制されることになる albeit in reduced capacity
referrer::::リファラ
	~releasing::::~
resize::::リサイズ
scroll::::スクロール
semicolon::::セミコロン
	~series::::~
size::::サイズ
text::::テキスト
内部slot:internal slot:内部 slot::内部スロット
slot::::スロット
top-level::::トップレベル

保安:security::~::セキュリティ
保安上の:security::~::セキュリティ上の
特性:property::~
検査:check::~
	点検
suite::::スイート
暗号:cypher:~
漏洩-:leak:~

	●処理モデル
script::::スクリプト
	~scriptによる:scripted
scripting::::スクリプト処理
本体:body::~::ボディ

module::::モジュール
classic::::クラシック
map::::マップ
bootstrap:
import:
closing:
record::::レコード
子孫:descendants:~
先祖:ancestor:~
指定子:specifier::~
検査-:check::~::チェック
失敗-:fail::~
失敗:failure::~
成功-:succeed:~
成功:success:~
成功裡:successful:~
	成功しな:unsuccessful

片付け:clean-up::~
	cleanup
片付ける:clean-up する::~
console::::コンソール
alert:
source::::ソース
強制終了:killing::~
prompt:
checkpoint:
	検点
job::::ジョブ

entrance:
enter:
entry:
realm:
Realm:
counter:
	:::エントリ
incumbent:

loop::::ループ
callback:
call:
	~call元:caller::::~
	~call法~calling::::~
stack::::スタック
push:
promise:
複合:compound:~
孤立:solitary::~
	単生
走るな:do not run:~
走れ:run:~
走らす:run する:走らせる
走らせ:run し:~
走らさ:run さ:走らさ
走れる:run できる:走れる
走せず:run せず:走らせず
走中の:running:走っている

	稼働
標的:target:::ターゲット
task::::タスク
下位task:subtask::下位 task:下位タスク:サブタスク
極小task:microtask::極小 task:極小タスク:マイクロタスク
源:source::~::ソース
	待入-:queue::~
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ
待入し:queue し::待ち行列に入れ::キューし
待行列:queue::待ち行列::キュー
待加えら:enqueue さ::待ち行列に加えら::エンキューさ

error::::エラー
通知-:notify:~
通知:notification:~
通知待ちの:about-to-be-notified:~
黙秘-:mute::~
黙秘error:muted error::error 黙秘:エラー黙秘
再投出error:rethrow error::error 再投出:エラー再投出
再投出-:rethrow::~
投出-:throw::~
未決の:outstanding::~
一時停止-:pause::~::ポーズ
例外:exception:~
投出-:throw:~
catch:
問題箇所:problematic position:~
	箇所:position:~
列番号:column number:~
行番号:line number:~
行0:line:行
却下-:reject:~
却下:rejection:~
却下済み:rejected:~
取扱う:handle する:取り扱う
取扱われ:handle され:取り扱われ
取扱って:handle して:取り扱って
取扱い:handling:取り扱い
未取扱いの:unhandled:~
取扱済み:handled:取り扱い済み
	not-handled
	handled

code::::コード
compile::::コンパイル
未compileの:uncompiled:::未コンパイルの
落とす:drop する:~
早期の:early::~
再入性:reentrancy::~
再入的:reentrant::~
再設定-:reset:~
再開:resume:~
処理-:process:~
処理:processing:~
包装-:wrap:~
反復-:iterate:~
timer::::タイマー
回す:spin する::~
	spinning
安定:stable::~
待受ける:await する::待ち受ける
停止-:stop::~
担当の:responsible:~
	に対する責を負う:~responsibility:~
	を担う
	の責を負う:に~responsibleな
	応答性を保~responsive::::~
	応答性を保ち続けremain responsive
協調-:coordinate::~
中止-:abort:~
	aborting
中途完了:abrupt completion:~
正常完了:normal completion:~

阻止-:block::~::ブロック
阻止ed:Blocked::阻止される::ブロックされる
阻まれ:block され:~:::ブロックされ
阻む:block する:~:::ブロックする
	他を阻むことなく:non-blocking fashion

伝播-:propagate:~
作動中の:active な::~::アクティブな
作動中:active::~::アクティブ
活動:activity::~::アクティビティ
動作-:act::~::アクト
動作:action::~::アクション
同期的:synchronous:~
同期区間:synchronous section::~
同期的な:synchronous::~
非同期的な:asynchronous::~
	古い:old:~
近過去:recent:~
遠過去:old:~
	最新:most recent:~
	最古:oldest:~
遂行-:perform:~
実行-:execute:~
実行:execution:~
実行ing:executing:実行
実行可能な:executable:~
実行時:runtime:~
並列的:parallel:~
待機-:wait:~

現在の:current:~
環境:environment:~
解決-:resolve:~
解決:resolution:~
解決済:resolved:解決済み
評価-:evaluate:~
評価:evaluation:~
準備-:prepare:~

呼出-:invoke:呼び出
	呼出され／呼出した
呼出す:invoke する:呼び出す
	invocation
呼出ing:invoking:呼び出し
呼出:invocation:呼び出し
維持0-:sustain:維持
	〜し易いsustainable
時刻印:timestamp:~
時間:time:~
破壊-:destroy:~
継続-:continue:~
継続:continuation:~
継続ing:continuing:~
断続的:continual:~

弱参照:weak reference:weak 参照:弱い参照の
強い:strong な:~
弱い:weak な:~
参照:reference:~
参照元:referencing:~
可能化-:enable:~
可能化:enabling:~
不能化-:disable:~
不能化:disabling:~
入子に:nest:入れ子に
入子の:nested:入れ子の
生の:raw::~
内部的な:internal:~
大域:global::~::グローバル
大域的:global::~::グローバル
存続期間:lifetime:~
実効:effective:~
全部的:full:~
公開-:expose:~
共有-:share:~
共用:shared:~
所有-:own:~
所有者:owner:~
初期:initial:~
	初期~時:initially
初期化-:initialise:~
	初期化-時:initialise されたとき:~
状態:state:~

設定群:settings:~
追跡-:track:~
送信-:send:~
互関係:related:互いに関係する
閲覧文脈:browsing context::~
生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン
非同一生成元:cross-origin::~::クロスオリジン
類似生成元の:similar-origin:origin も類似する:生成元も類似する::オリジンも類似する
変化-:change:~
依存関係:dependencies:~
再帰的:recursive:~
重複:deduplicate:~
instantiate::instance 化::インスタンス化
instantiation::instance 化::インスタンス化

system::::システム
構文:syntax:~
非同期:asynchronous:~
完了-:complete:~
無視-:ignore:~
	BOM
	parameter::::パラメタ
続行-:continue:~
hook::::フック
option::::オプション
差挟まれ:interleaveされ:差し挟まれ
結合-:coalesce:~
飛ばす:skip する:~
	~~連続してimmediately after each other



	●event
event::::イベント
listener::::リスナ
handler::::ハンドラ
trusted:
capture:
取消す:cancel する::取り消す::キャンセルする
取消され:cancel され::取り消され::キャンセルされ
取消可能:cancelable:~
取消不可:not cancelable:~
浮上-:bubble:~
誘発-:trigger:~
配送-:dispatch:~
発火-:fire:~
発火:firing:~
登録-:register:~
	registering
合成:synthetic::~
unload:

	●network, nav
MIME:
CORS:
client:
終了-:terminate::~
行先:destination::~
抽出-:extract::~
種別:type::~
url:
fetch:
status::::ステータス
ok:
metadata::::メタデータ

fetching:fetch 処理
scheme::::スキーム
address::::アドレス
network::::ネットワーク
networking::::ネットワーク処理
network-channel:network channel:::ネットワークチャンネル
navigate::::ナビゲート
	navigating
nonce::::ナンス
頁:page:::ページ
読込まれ:load され::読み込まれ::ロードされ
読込む:load する::読み込む::ロードする
読込み:loading::読み込み::ローディング
読込器:loader::読み込み器::ローダ
資源:resource::~:リソース
送達-:deliver:~
要請:request::~::リクエスト
応答:response::~::レスポンス
資格証:credentials::資格証明情報::クレデンシャル
暗号用:cryptographic::~

	●仕様
platform::::プラットフォーム
logic::::ロジック
model::::モデル
support::::サポート
host::::ホスト
	FINGERPRINTING
UA:user agent:UA
	序論:introduction:~
実装-:implement:~
	implementing
実装:implementation:~
実装定義の:implementation-defined:~
実装定義:implementation-defined:~
理想的:ideal:~
最終的:eventual:~
強く:strong に:~
意味-:mean:~
意味:meaning:~
意図-:intend:~
所与の:given:与えられた
手続き:steps:~
指定-:specify:~
特定0の:particular:ある特定の
特定の:specific:~
	特に~specifically::::~
明示的:explicit:~
方式:manner:~
	どう:how:~
挙動:behavior:ふるまい
技術:technologies:~
	必要:need:~
	必要とされ:necessary:~
故意的な:willful:故意による
定めら:state さ:~
	一定の／ある種の:certain:~
一般:general:~
事例:case:~
事由:reason:~
理由:reason:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
下位手続き:substeps:~
概して:typical に:~
概念:concept:~
概念0:notion:概念
正確:exact:~
歴史的:historical:~
段:step:~
汎用の:generic:~
決める:decide する:~
決定-:determine:~
無関係:irrelevant:~
	関係ない~unrelated::::~
管理-:manage:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
総計:total:~
義務付けな:mandate しな:~
考える:consider する:~
自前の:own:~
自動的:automatic:~
自明:trivial:~
自由:free:~
	自身:itself:~
表現-:represent:~
能力:capabilities:~
要件:requirements:~
要求-:require:~
試みて:attempt して:~
試みる:attempt する:~
課-:impose:~
通常は:normal には:~
通常の:normal な:~
達成-:achieve:~
違反:violation:~
適切:appropriate:~
不適切:inappropriate:~
選好:preference:~
避ける:avoid する:~
関連する:relevant な:~
	関連付ける:correlate:~
直面-:face:~
任意:arbitrary:~
任意選択:optional:~
省略可:optional:~
選択肢:option:~::オプション
相互作用-:interact:~
作者:author:~
利用者:user:~
利用者対話:user-interaction:~
制限-:limit:~
制限:limitation:~
特徴:characteristic:~
特色機能:feature:~
開発者:developer:~
複雑問題:complication:複雑な問題
再度:again:~
定例の:regular:~
定義-:define:~
定義:definition:~
	きちんと定義:well-defined::::~
意図的:intentional:~
制約:restriction:~
将来:future:~
特別:special:~
許容-:allow:~
依存-:depend:~
非依存な:agnostic な:~
	host-agnostic
	対照的に:in contrast,
	前者:former
	後者:latter
回避策:workaround:~
	遠回しでとっ散らかった回避策であふれる:mass of messy indirection and workarounds
導入-:introduce:~
尚早:premature:~
成分:component:~
技術的:technical:~
抽象化:abstraction:~
是認-:sanction:~
本質的:essential:~
柔軟:flexible:~
特有の:specific な:~
統合-:integrate:~
統合:integration:~
適正:proper:~
自由度:liberal advantage:~
確保-:ensure:~
不変則:invariants:~
影響-:affect:~
波及-:influence:~
提供-:provide:~
提供0-:offer:提供
織込んで:account して:織り込んで

組込みの:built-in:~
導出-:derive:~
適用-:apply:~
公式的:formal:~
現代の:modern:~
用語:term:~
期待-:expect:~
指示-:indicate:~
重要:important:~
影響0-:impact:影響
間違った:wrong:~
略称-:abbreviate:~
例証-:demonstrate:~
例証:demo:~
限定句:qualification:~
移行期間:transitional period:~
奨励-:encourage:~
妥当:valid:~
専用:dedicated:~
専用の:dedicated:~
要因:factor:~
共通する:common である:~
可用:available:~
可能0:possible:可能
可能性:possibility:~
目標:goal:~
目的0:purpose:目的
防止-:prevent:~

	●未分類（動詞）
包含-:contain:~
付加-:append:~
作成-:create:~
作成:creation:~
作成法:creating:~
持続的な:persisted:~
格納-:store:~
切替える:switch する:~
反応-:react:~
反応:reacting:~
反映-:reflect:~
取得-:get:~
	getting
合致-:match:~
報告-:report::~
報告:reporting::~
変異-:mutate:~
存在-:exist:~
挿入-:insert:~
挿入:insertion:~
構築-:construct:~

被取得時:被 get 時:~
被設定時:被 set 時:~
設定-:set:~
設定:setting:~
	設定しておく:setup／set upする
検知-:detect:~
置換-:replace:~
複製:copy:~
解放-:release:~
生成-:generate:~
走査:traversal:~
超過-:exceed:~
追加-:add:~
追加の:additional:~
選択-:select:~
除去-:remove:~
返値:return value:返り値
返す:return する:~
返され:return され:~
返さ:return し:~
返した:return した:~
返して:return して:~
上書き:override:~
移動-:move:~
移動:movements:~
起動-:initiate:~
迂回-:bypass:~


	●未分類
parameter::::パラメタ
token::::トークン
	~token化-:tokenize:~
void:
zero::::ゼロ
inline::::インライン

値:value:~
仕事:work:~
入力:input:~
全screen:fullscreen:::全スクリーン
内容:content:~

恒久的:permanent:~
内側:inside:~
動的:dynamic:~
区切る:separate:~
単位:unit:~

単独の:single:~
単純:simple:~
即時:immediate:~
名前:name:~
型:type:~
基底:base::~
変更点:changes:~
外部:external:~
媒体:media::~::メディア

容器:container:::コンテナ
履歴:history:~
帯域幅:bandwidth:~
並行する:parallel な:~
引数:argument:~
	後:after:~
情報:information:~
所在:location:~
所属-:belong:~
押下げ:pressing:~
描画:rendering:~
操作:manipulation:~
	感知し得ない:cannot be sensitive:~
文脈:context:~

木:tree::~::ツリー
根:root::~::ルート
要素:element:~
親:parent:~
文書:document::文書
文書s:document たち::文書たち
属性:attribute:~


断片:fragment:~
新たな:new:~
既定:default:~:::デフォルト

更新:update:~
有順序:ordered:~
条件:condition:~


演算:operation:~
抽象演算:abstract operation:~
現在:currently:~
	現時点では:currently:~

文字:character:~
文字列:string:~
構文解析-:parse::~::パース
構文解析処理:parsing::~::パース処理
構文解析器:parser::~::パーサ
構文解析可能:parsable::~::パース可能

生成規則:production:~
復号-:decode::~::デコード
符号化-:encode::~::エンコード
符号化方式:encoding::~::エンコーディング
fallback::::フォールバック

画像:image:~
直接的:direct:~
間接的:indirect:~
相対:relative:~
絶対:absolute:~
秒:seconds:~
	種類:kind:~
空:empty:~
背後:background:~
装置:device:~
言語:language:~
記憶域:memory:~
計算資源:resource:~
	開始-:start:~
関数:function:~
集合:set:~
順序:order:~
構造:structure:~
厳密:strict:~
基盤:infrastructure:~
範囲内:bounds 内:~

第三者主体:third-party:~
可視:visible:~
拘束-:constrain:~
改変-:modify:~


	●その他
	vend
	defining
	deal
	費やす:spend する
	~~分別のある:sensible
	真っ先に挙がる:prominent
	これからの:going forward
	覆され:reverse
	対応-:correspond
	考える:consider
	望ましくない:undesirable
	これをもって:With this in hand
	書き直せるre-cast:#1
	全体を通して:throughout
	同じことだが、:equivalently
	利用できる:usable
	昔ながらの:olden days
	すぐに:right away
	以降:the rest
	ひねくりまわすcontort:
	十分:sufficient:~
	増減-:incremented and decremented
	省略-:omit
	end up
	両者:both:~
	止め-:cease
	並行して:alongside
	出くわす:experience:~
	~resuming::::~
	名前のみの:bare
	~say
	~saying
	~opposed
	~lead::::~
	行先に:destined
	別個の:distinct
	doc
	emphatical
	everything
	~~全面的にまたは~~細部的に:~globally, or in a ~finer-grained manner
	~~最後に~finally::::~

	follow
	等々 and so forth
	~four
	helpful
	~long
	主となる:main
	~manually
	付与／~mark
	~marked
	~anything
	発生~arise
	当然、~naturally
	その他諸々:amongst other things
	見込まれる:believe
	益:benefit
	とる~take
	~take-care
	選んで:pick
	ずっと遅い:much slower
	-:~sort
	またがって:span
	放置:starving
	絞る:throttle する:~
	組:tuple
	保ち続ける:to keep careful track of
	保ち続ける:keep track
	~~正しい~right
	正しく:correct で
	respective
	〜に則って:according:~
	〜に関わらず:regardless:~
	〜の代わりに:instead:~

	あてがう:assign:~
	この:this:~
	これらの:these:~
	しかしながら，:however:~
	したがって:thus:~
	すべての:all:~
	その:that:~
	そのような:such:~
	それらの:their:~
	それら自身:themselves:~
	べき:should:~
	ほぼ:mostly:~
	まるごと:entirely:~
	もの:thing:~
	より長い:longer:~
	三つ:three:~
	上の:above:~
	下:below:~
	与-:give:~
	二つの:two:~
	秒a second:~
	今や:now:~
	介:via:~
	他の:other:~
	以前の:previous:~
	仮の:tentative:~
	何か:somewhat:~
	例:example:~
	依然として:still:~
	保-:keep:~
	元々:originally:~
	元の:original:~
	別の:another:~
	利用-:use:~
	利用して:using:~
	前:before:~
	各:each:~
	同じ:same:~
	含-:include:~
	加えて，:addition:~
	呼応して:in response to
	多い:often:~
	多くの／多々:many:~
	始-:begin:~
	孕む:involve:~
	常に:always:~
	当の:in question
	後で:subsequently:~
	従って，:therefore:~
	得-:obtain:~
	戻-:back:~
	数:number:~
	時々:occasionally:~
	更なる:further:~
	最も:most:~
	最初の:first:~
	初回:first time
	最後の:last:~
	案:ideas:~
	決して:never:~
	渡-:pass:~
	特に:in-particular:~
	生-:occur:~
	異なる:different:~
	示-:mention:~
	示-:show:~
	種々の:various:~
	節:section:~
	結果:result:~
	結果の:resulting:~
	置-:place:~
	複数の:multiple:~
	見よ:see:~
	起こる／起きる:happen:~
	述-:describe:~
	通:through:~
	類似する:similar:~
	同様に:similarly:~

	ただ／他に何もせず~just
	道:path
	検討中:considering:~
	採らず:take しない
	真:true
	結果になる:end up
	事実:fact
	受け持つ:take care
	多量の:mass of
	手間をかける:take extra care
	版:version
	結局:end result
	譲る:yield
	status

	役立つ~~情報~helpful manner
	存続する限りas long as it exists
	~~存続する限り走らせ続けcontinually run through



</script>

<!--%style -->
<style type="text/css">

.js-slot {
	color: green;
}
</style>

</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Standard — 8.1. Scripting 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Web application APIs</a>
の一部である
<cite>8.1 Scripting 節</cite>
を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-05-03</time>
（公開：<time>2016-01-08</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">

	<hgroup>
<h1 id="scripting">8.1. Scripting — スクリプト処理</h1>
<h2>HTML Living Standard — 最終更新 2016 年 5 月 2 日</h2>
	</hgroup>

</header>


<nav class="toc" id="toc">
<h2>目次</h2>
<ol id="_toc_list0"></ol></nav>


<hr>

<main id="MAIN" style="display:none;">

	<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>


<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~GOTO 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<ul>
	<li>
用語
`文書@
は、（ DOM により定義され， HTML により拡張された）
`Document$I ~interfaceを実装する~objの略記である。
</li>
	<li>
用語
`~window@
は、 `Window$I ~interfaceを実装する~objの略記である。
</li>
	<li>
用語 “中途完了（ abrupt completion ）” は、 `JAVASCRIPT$r にて定義される。
</li>
	<li>
<p>
各種~algoのうち一部のものは、
`非同期に完了-@
する（ asynchronously complete ）ものと規定される。
その種の~algoは：
</p>
		<ul>
			<li>
その結果を，それを呼出した~algoに直接的に返すことはなく、
“ %X を結果として，非同期に完了する”
と記される所で、字義通り非同期にその実行を終える。
この句は，暗黙的に ~RET も含み、~algoはそこで終了するものとする。
</li>
			<li>
その結果は、それを呼出した~algoの中で
“（〜の~algoが）非同期に完了したときは…”
という句に後続する手続きで取扱われる。
</li>
		</ul>
	</li>
</ul>

	</section>
	<section id="introduction-11">
<h3 title="Introduction">8.1.1. 序論</h3>


<p>
作者から提供された実行可能な~codeは、種々の仕組みにより，文書の文脈において走らす。
これらの仕組みには、（少なくとも）次のものが含まれる：
◎
Various mechanisms can cause author-provided executable code to run in the context of a document. These mechanisms include, but are probably not limited to:
</p>

<ul>
	<li>
`script$e 要素の処理。
◎
Processing of script elements.
</li>
	<li>
`javascript$sc ~URLへ~navigateするとき。
◎
Navigating to javascript: URLs.
</li>
	<li>
<p>
次による~event~handler：
</p>
		<ul>
			<li>
DOM の `addEventListener()^m を利用して登録されたもの
</li>
			<li>
明示的な`~event~handler内容~属性$
</li>
			<li>
`~event~handler~IDL属性$
</li>
			<li>
その他
</li>
		</ul>

◎
Event handlers, whether registered through the DOM using addEventListener(), by explicit event handler content attributes, by event handler IDL attributes, or otherwise.
</li>
	<li>
SVG の様な，自前の~scripting特色機能を有する技術の処理。
◎
Processing of technologies like SVG that have their own scripting features.
</li>

</ul>


	</section>
	<section id="enabling-and-disabling-scripting">
<h3 title="Enabling and disabling scripting">8.1.2. ~scriptingの可能化と不能化</h3>


<p>
`閲覧文脈$x %B において，
`~scriptingは可能化され@
ているとは、次のすべての条件が満たされることを意味する：
◎
Scripting is enabled in a browsing context when all of the following conditions are true:
</p>

<ul>
	<li>
~UAは~scriptingを~supportする。
◎
The user agent supports scripting.
</li>
	<li>
利用者は、 %B に対しこの時点で~scriptingを不能化していない。
（~UAは、利用者に~scriptingを
~~全面的に, あるいは~~細部的に
— 例えば，個別の生成元ごとに — 
不能化する選択肢を提供してよい）
~FINGERPRINTING
◎
The user has not disabled scripting for this browsing context at this time. (User agents may provide users with the option to disable scripting globally, or in a finer-grained manner, e.g. on a per-origin basis.
(This is a fingerprinting vector.)
</li>
	<li id="sandboxScriptBlocked">
［［［
%B の`作動中の文書$x
］の［
`作動中の~sandboxing~flag集合$x
］］の`~sandboxed~script閲覧文脈~flag$x
］ ~EQ ~OFF
◎
The browsing context's active document's active sandboxing flag set does not have its sandboxed scripts browsing context flag set.
</li>

</ul>

<p>
`~scriptingは不能化され@
ているとは、上の否定
— `~scriptingは可能化され$ていない —
ことを意味する。
<!-- 
この訳では、単に “~scriptingは可能化されていない” と記すことにする。
 -->
◎
Scripting is disabled in a browsing context when any of the above conditions are false (i.e. when scripting is not enabled).
</p>

<hr>

<p>
`~nodeに対し，~scriptingは可能化され@
ているとは、［
その~nodeの`~node文書$xが`属する閲覧文脈$xはある
］, かつ［
その閲覧文脈において`~scriptingは可能化され$ている
］ことを意味する。
◎
Scripting is enabled for a node if the node's node document has a browsing context, and scripting is enabled in that browsing context.
</p>


<p>
`~nodeに対し，~scriptingは不能化され@
ているとは、上の否定を意味する。
◎
Scripting is disabled for a node if there is no such browsing context, or if scripting is disabled in that browsing context.
</p>

	</section>
	<section id="scripting-processing-model">
<h3 title="Processing model">8.1.3. 処理~model</h3>

		<section id="definitions-2">
<h4 title="Definitions">8.1.3.1. 各種~定義</h4>

<p>
`~script@
は、構造~的に 2 種に分けられる。
いずれにせよ、各~scriptは次のものを有する：
◎
A script is one of two possible structures. All scripts have:
</p>

<dl class="def-list">
	<dt>
`設定群~obj@
◎
A settings object
</dt>
	<dd>
`環境~設定群~obj$
— 同じ文脈に属する他の~scriptと共有されるような，種々の設定を包含する。
◎
An environment settings object, containing various settings that are shared with other scripts in the same context.
</dd>

</dl>

<p>
`~classic~script@
は、上に加えて次のものを有する：
◎
A classic script additionally has:
</p>


<dl class="def-list">
	<dt>
`~source~text@
◎
Source text
</dt>
	<dd>
実行可能な~codeの~blockを，~JS `Script$js として包含している文字列。
◎
A string containing a block of executable code to be evaluated as a JavaScript Script.
</dd>

	<dt>`黙秘error~flag@
◎
Optionally, a muted errors flag
</dt>
	<dd>
~flag値。
~ON ならば、この~scriptにおける~errorに対しては，~error情報は提供されなくなる（~private情報を漏洩し得る非同一生成元~scriptに対し、~errorを黙秘するために利用される）。
◎
A flag which, if set, means that error information will not be provided for errors in this script (used to mute errors for cross-origin scripts, since that can leak private information).
</dd>
</dl>


<p>
`~module~script@
は、`設定群~obj$に加えて次のものを有する：
◎
A module script additionally has:
</p>

<dl class="def-list">
	<dt>
`~module~record@
◎
A module record
</dt>
	<dd>
`Source Text Module Record$js
— 構文解析され，実行する準備が整った~moduleを表現する。
◎
A Source Text Module Record representing the parsed module, ready to be evaluated.
</dd>

	<dt>
`基底~URL@
◎
A base URL
</dt>
	<dd>
`~module指定子を解決-$するときに利用される基底~URL。
これは、外部~module~scriptに対しては，~scriptが得られた~URLになり、~inline~module~scriptに対しては，それを包含している文書の`基底~URL$xになる。
◎
A base URL used for resolving module specifiers when resolving a module specifier. This will either be the URL from which the script was obtained, for external module scripts, or the document base URL of the containing document, for inline module scripts.
</dd>

	<dt>
`資格証~mode@
◎
A credentials mode
</dt>
	<dd>
~importされた~moduleを~fetchするときに利用される，`資格証~mode$rq
◎
A credentials mode used to fetch imported modules.
</dd>

	<dt>
`暗号用~nonce@
◎
A cryptographic nonce
</dt>
	<dd>
~importされた~moduleを~fetchするときに利用される，`暗号用~nonce~metadata$rq
◎
A cryptographic nonce used to fetch imported modules.
</dd>

	<dt>
`構文解析器~状態@
◎
A parser state
</dt>
	<dd>
~importされた~moduleを~fetchするときに利用される，`構文解析器~metadata$rq
◎
The parser metadata used to fetch imported modules.
</dd>

</dl>

<hr>

<p>
各
`環境~設定群~obj@
%設定群 は、次を得るための各種~algoを指定する：
◎
An environment settings object specifies algorithms for obtaining the following:
</p>


<dl class="def-list">
	<dt>`~realm実行~文脈@
◎
A realm execution context
</dt>
	<dd>
%設定群 を利用するすべての `~script$x から共有されるような，`~JS実行~文脈$js。
すなわち、これらの~scriptは，この`~JS~realm$js内にある。
［
`~classic~script$ ／ `~module~script$
］を走らすときは、この実行~文脈が`~JS実行~文脈~stack$jsの一番上になり，その上に当の~scriptに特有の別の実行~文脈が~pushされる。
（こう設定しておけば、［
`ParseScript$jA ／ `ModuleEvaluation$jA
］は，どの~realmを利用するかを知れるようになる。）
◎
A JavaScript execution context shared by all scripts that use this settings object, i.e. all scripts in a given JavaScript realm. When we run a classic script or run a module script, this execution context becomes the top of the JavaScript execution context stack, on top of which another execution context specific to the script in question is pushed. (This setup ensures ParseScript and ModuleEvaluation know which Realm to use.)
</dd>

	<dt>
`~module~map$
◎
A module map
</dt>
	<dd>
~JS~moduleを~importするときに利用される。
◎
Used when importing JavaScript modules.
</dd>
	<dt>
`担当の閲覧文脈@
◎
A responsible browsing context
</dt>
	<dd>
［
%設定群 を利用する各~scriptがとる動作
］に対する責を負うものとされている`閲覧文脈$x。
◎
A browsing context that is assigned responsibility for actions taken by the scripts that use this environment settings object.
</dd>
	<dd class="example">
例えば、~scriptが新たな`~top-level閲覧文脈$xを作成して`~navigate$xするとき、新たな`閲覧文脈$xの`~window$の `opener$m 属性は，`担当の閲覧文脈$の `WindowProxy$I ~objに設定されることになる。
◎
When a script creates and navigates a new top-level browsing context, the opener attribute of the new browsing context's Window object will be set to the responsible browsing context's WindowProxy object.
</dd>

	<dt>
`担当の~event~loop@
◎
A responsible event loop
</dt>
	<dd>
［
どの~event~loopを利用するか，まだはっきりしない
］ときに利用される，`~event~loop$。
`はっきりした時点で、特定0の~event~loopに振り分けられる（不定な~event~loopであって，他の処理に影響する前に何らかの~event~loopに確定される）ことを意味すると見られる。^tnote
◎
An event loop that is used when it would not be immediately clear what event loop to use.
</dd>

	<dt>
`担当の文書@
◎
A responsible document
</dt>
	<dd>
［
%設定群 を利用する各~scriptがとる動作
］に対する責を負うものとされている`文書$。
◎
A Document that is assigned responsibility for actions taken by the scripts that use this environment settings object.
</dd>
	<dd class="example">
例えば、`担当の文書$の`~address$xは、`文書$の`~address$xを設定するために利用される
— それが `document.open()$m を利用して再設定された後に。
◎
For example, the address of the responsible document is used to set the address of the Document after it has been reset using document.open().
</dd>
	<dd>
`担当の~event~loop$が`閲覧文脈~event~loop$でない場合、
%設定群 は，`担当の文書$を持たない。
◎
If the responsible event loop is not a browsing context event loop, then the environment settings object has no responsible document.
</dd>

	<dt>
`~API~URL文字~符号化方式@
◎
An API URL character encoding
</dt>
	<dd>
［
%設定群 を利用している~script
］により~callされる~APIが，~URLを符号化するときに利用する、文字~符号化方式。
◎
A character encoding used to encode URLs by APIs called by scripts that use this environment settings object.
</dd>

	<dt>
`~API基底~URL@
◎
An API base URL
</dt>
	<dd>
［
%設定群 を利用している~script
］により~callされる~APIが，`~URLを構文解析-$するときに利用する、`~URL$x。
◎
A URL used by APIs called by scripts that use this environment settings object to parse URLs.
</dd>

	<dt>`生成元$x
◎
An origin
</dt>
	<dd>
保安~検査に利用される。
◎
An instrument used in security checks.
</dd>

	<dt>
`作成~URL@
◎
A creation URL
</dt>
	<dd>
%設定群 が結付けらている資源の所在を表現している`絶対~URL$x。
この~URLは、 `history.pushState()$m などの仕組みに因り，`担当の文書$の`~address$xとは別個のものにもなり得ることに注意。
◎
An absolute URL representing the location of the resource with which the environment settings object is associated. Note that this URL might be distinct from the responsible document's address, due to mechanisms such as history.pushState().
</dd>

	<dt>
`~HTTPS状態@
◎
An HTTPS state
</dt>
	<dd>
［［
%設定群 が結付けらている資源
］を送達するために利用されている~network-channel
］の，保安上の特性を表現している値。
この値は、次のいずれかになる
⇒
`modern^l ／ `deprecated^l ／ `none^l
◎
A value representing the security properties of the network channel used to deliver the resource with which the environment settings object is associated. The value will be one of "modern", "deprecated", or "none".
</dd>
	<dd class="note">注記：
~HTTPSを通じて送達される資源の`~HTTPS状態$は、一般に `modern^l になる。
~UAは、移行期間の間は（例： ~hash関数や暗号~suiteに対する~supportを除去している間など）、応答をまるごと却下することが不適切になる所では， `deprecated^l を利用できる。
◎
Resources delivered over HTTPS will generally have an HTTPS state of "modern". A user agent can use "deprecated" during transitional periods where rejecting the response entirely would be inappropriate (e.g., while removing support for a hash function or cypher suite).
</dd>
</dl>

<p>
各 `環境~設定群~obj$に対しては、次も定義される：
◎
↓</p>

<dl class="def-list">
	<dt>`通知待ちの却下済み~promise~list@
◎
↓</dt>
	<dd>
次の項目とともに，
<a href="#unhandled-promise-rejections">未取扱いの~promise却下</a>
を追跡するために利用される。
◎
↓</dd>

	<dt>`未決の却下済み~promiseへの弱参照~集合@
◎
↓</dt>
	<dd>
~promiseへの弱い参照からなる集合
— これらのどの参照も強い参照であっては~MUST_NOT。
実装はまた、含まれる参照の個数を自由に制限してよい
— 例えば、新たな~entryが追加されたとき，古いものを除去するなど。
◎
An environment settings object also has an outstanding rejected promises weak set and an about-to-be-notified rejected promises list, used to track unhandled promise rejections. The outstanding rejected promises weak set must not create strong references to any of its members, and implementations are free to limit its size, e.g. by removing old entries from it when new ones are added.
</dd>


</dl>


		</section>
		<section id="fetching-scripts">
<h4 title="Fetching scripts">8.1.3.2. ~scriptの~fetching</h4>

<p>
下に示す，~scriptを~fetchする種々の~algoには、~call元により~customizeできる 2 つの~hookがある：
◎
The various script-fetching algorithms below have two hooks that may be customized by their callers:
</p>

<ul>
	<li>
`要請を設定しておく@
手続きにより、~algoを続行する前に`要請$xを改変できる。
◎
Set up the request, which takes a request which it may modify before the algorithm continues
</li>
	<li>
`応答を処理する@
手続きは、与えられた`応答$xに対し，［
成功／失敗
］を指示する［
~T／~F
］を返す。
◎
Process the response, which takes a response and must either return true or false to indicate success or failure, respectively
</li>
</ul>

<p class="note">注記：
<cite>Service Workers</cite> `SW$r
は、これらの~hookに自前の~optionを与えて，これらの~algoを走らす仕様の例である。
◎
Service Workers is an example of a specification that runs these algorithms with its own options for the hooks. [SW]
</p>

<p class="algo-head">
( %~url, %~CORS設定, %暗号用~nonce, %構文解析器~状態, %設定群~obj, %文字~符号化方式 )
が与えられた下で，
`script$e 要素 %要素 に対し
`~classic~scriptを~fetchする@
ときは、次を走らす。
この~algoは、［
（失敗~時には）~NULL ／
（成功~時には）新たな`~classic~script$
］いずれかを結果として，`非同期に完了-$する：
◎
To fetch a classic script for a script element element, given a url, a CORS setting, a cryptographic nonce, a parser state, a settings object, and a character encoding, run these steps. The algorithm will asynchronously complete with either null (on failure) or a new classic script (on success).
</p>

<ol>
	<li>
%要請 ~LET
( %~url, %~CORS設定 )
を与える下で
`~CORSになり得る要請を作成-$した結果
◎
Let request be the result of creating a potential-CORS request given url and CORS setting.
</li>
	<li>
<p>
%要請 の：
</p>

<ul ><li>`~client$rq ~SET %設定群~obj
</li><li>`種別$rq ~SET `script^l
</li><li>`行先$rq ~SET `script^l
</li><li>`暗号用~nonce~metadata$rq ~SET %暗号用~nonce
</li><li>`構文解析器~metadata$rq ~SET %構文解析器~状態
</li></ul>
◎
Set request's client to settings object, its type to "script", its destination to "script", its cryptographic nonce metadata to cryptographic nonce, and its parser metadata to parser state.
</li>
	<li>
~IF［
この~algoの~call元にて，`要請を設定しておく$~custom手続きが指定されている
］
⇒
%要請 に対し，それを遂行する
◎
If the caller specified custom steps to set up the request, perform them on request.
</li>
	<li>
%要請 を`~fetchする$x
◎
Fetch request.
</li>

	<li>
<p>
~RET
— ただし，以降の手続きは、［
~fetchした結果の`応答$x %応答に対し`応答を処理する$x
］一部として走らす：
◎
Return from this algorithm, and run the remaining steps as part of the fetch's process response for the response response.
</p>

<p class="note">注記：
%応答 は、［
`~CORS同一生成元$, `~CORS非同一生成元$
］のいずれかになり得る。
これは、~error報告がどう起こるかにのみ影響する。
◎
response can be either CORS-same-origin or CORS-cross-origin. This only affects how error reporting happens.
</p>

	</li>
	<li>
<p>
~IF［
次のいずれかに該当する
］
⇒
~NULL を結果として，`非同期に完了-$する
</p>

		<ul>
			<li>
%応答 の`種別$rs ~EQ `error^l
</li>
			<li>
%応答 の`~status$rsは`~ok~status$rsでない
</li>
			<li>
［
~call元にて`応答を処理する$手続きが指定されている
］~AND［
%応答 に対しそれを遂行した結果 ~EQ ~F
］
</li>
		</ul>

◎
If response's type is "error", or response's status is not an ok status, asynchronously complete this algorithm with null, and abort these steps.
◎
If the caller specified custom steps to process the response, perform them on response. If they return false, complete this algorithm with null, and abort these steps.
</li>


	<li>
~IF［
%応答 には`Content Type ~metadata$があって，それは
文字~符号化方式 %符号化方式 を指定する
］~AND［
~UAは %符号化方式 を~supportする
］
⇒
%文字~符号化方式 ~SET %符号化方式
（渡された %文字~符号化方式 は無視する）
◎
If response's Content Type metadata, if any, specifies a character encoding, and the user agent supports that encoding, then set character encoding to that encoding (ignoring the passed-in value).
</li>
	<li>
<p>
%~source~text ~LET
%文字~符号化方式 を~fallback符号化方式に利用して，
%応答 の`本体$rsを `Unicode に復号-$xした結果
◎
Let source text be the result of decoding response's body to Unicode, using character encoding as the fallback encoding.
</p>

<p class="note">注記：
~fileに BOM がある場合、
`Unicode に復号-$xする~algoは， %文字~符号化方式 を上書きする。
◎
The decode algorithm overrides character encoding if the file contains a BOM.
</p>
	</li>
	<li>
%黙秘error~flag ~LET ［
%応答 は`~CORS非同一生成元$であるならば ~ON ／
~ELSE_ ~OFF
］
◎
↓</li>
	<li>
%~script ~LET
( %~source~text, %設定群~obj, %黙秘error~flag )
を与える下で，`~classic~scriptを作成-$した結果
◎
Let script be the result of creating a classic script using source text and settings object.
◎
If response was CORS-cross-origin, then pass the muted errors flag to the create a classic script algorithm as well.
</li>
	<li>
%~script を結果として，`非同期に完了-$する
◎
Asynchronously complete this algorithm with script.
</li>
</ol>


<p class="algo-head">
( %~url, %~referrer, %設定群~obj, %行先 )
が与えられた下で，
`~classic~worker~scriptを~fetchする@
ときは、次を走らす。
この~algoは、［
（失敗~時には）~NULL ／
（成功~時には）新たな`~classic~script$
］いずれかを結果として，`非同期に完了-$する：
◎
To fetch a classic worker script given a url, a referrer, a settings object, and a destination, run these steps. The algorithm will asynchronously complete with either null (on failure) or a new classic script (on success).
</p>


<ol>
	<li>
<p>
%要請 ~LET 次のようにされた新たな`要請$x
</p>

<ul><li>`~url$rq ~SET %~url
</li><li>`~client$rq ~SET %設定群~obj 
</li><li>`種別$rq ~SET `script^l
</li><li>`行先$rq ~SET %行先
</li><li>`~referrer$rq ~SET %~referrer
</li><li>`~mode$rq ~SET `same-origin^l
</li><li>`資格証~mode$rq ~SET `same-origin^l
</li><li>`構文解析器~metadata$rq ~SET `not parser-inserted^l
</li><li>`~URL資格証~利用~flag$rq ~SET ~ON
</li></ul>
◎
Let request be a new request whose url is url, client is settings object, type is "script", destination is destination, referrer is referrer, mode is "same-origin", credentials mode is "same-origin", parser metadata is "not parser-inserted", and whose use-URL-credentials flag is set.
</li>
	<li>
~IF［
この~algoの~call元にて，`要請を設定しておく$~custom手続きが指定されている
］
⇒
%要請 に対し，それを遂行する
◎
If the caller specified custom steps to set up the request, perform them on request.
</li>
	<li>
%要請 を`~fetchする$x
◎
Fetch request.
</li>
	<li>
~RET
— ただし，以降の手続きは、［
~fetchした結果の`応答$x %応答に対し`応答を処理する$x
］一部として走らす：
◎
Return from this algorithm, and run the remaining steps as part of the fetch's process response for the response response.
</li>
	<li>
<p>
~IF［
次のいずれかに該当する
］
⇒
~NULL を結果として，`非同期に完了-$する
</p>

		<ul>
			<li>
%応答 の`種別$rs ~EQ `error^l
</li>
			<li>
%応答 の`~status$rsは`~ok~status$rsでない
</li>
			<li>
［
この~algoの~call元にて`応答を処理する$手続きが指定されている
］~AND［
%応答 に対しそれを遂行した結果 ~EQ ~F
］
</li>
		</ul>

◎
If response's type is "error", or response's status is not an ok status, asynchronously complete this algorithm with null, and abort these steps.
◎
If the caller specified custom steps to process the response, perform them on response. If they return false, complete this algorithm with null, and abort these steps.
</li>
	<li>
%~source~text ~LET
%応答 の`本体$rsを `UTF-8 復号-$xした結果
◎
Let source text be the result of UTF-8 decoding response's body.
</li>

	<li>
%~script ~LET
( %~source~text, %設定群~obj, %黙秘error~flag )
を与える下で，`~classic~scriptを作成-$した結果
◎
Let script be the result of creating a classic script using source text and settings object.
</li>

	<li>
%~script を結果として，`非同期に完了-$する
◎
Asynchronously complete this algorithm with script.
</li>
</ol>

<p class="algo-head">
( %~url, %資格証~mode, %暗号用~nonce, %構文解析器~状態, %行先, %設定群~obj, %先祖~list（省略可） )
が与えられた下で
`~module~script木を~fetchする@
ときは、次を走らす。
この~algoは、［
（失敗~時には）~NULL ／
（成功~時には）`~module~script$
］いずれかを結果として，`非同期に完了-$する：
◎
To fetch a module script tree given a url, a credentials mode, a cryptographic nonce, a parser state, a destination, a settings object, and an optional ancestor list, run these steps. The algorithm will asynchronously complete with either null (on failure) or a module script (on success).
</p>

<ol>
	<li>
~IF［
%先祖~list は与えられていない
］
⇒
%先祖~list ~SET 空~list
◎
If ancestor list is not given, let it be an empty list.
</li>
	<li>
<p>
( %~url, %資格証~mode, %暗号用~nonce, %構文解析器~状態, %行先, %設定群~obj )
を与える下で，`単独の~module~scriptを~fetchする$
— この~algoの~call元にて［
`要請を設定しておく$ ／ `応答を処理する$
］手続きが指定されている場合は、それらも~fetchする~algoに渡す。
◎
Fetch a single module script given url, credentials mode, cryptographic nonce, parser state, destination, and settings object. If the caller of this algorithm specified custom set up the request or process the response steps, pass those along while fetching a single module script.
</p>

<p>
この~fetchが`非同期に完了-$したときは、その結果 %結果 に応じて：
◎
Return from this algorithm and run the following steps when fetching a single module script asynchronously completes with result:
</p>

		<dl class="switch">
			<dt>~NULL</dt>
			<dd>
~NULL を結果として，`非同期に完了-$する
◎
If result is null, asynchronously complete this algorithm with null and abort these steps.
</dd>
			<dt>`~module~script$である</dt>
			<dd>
				<ol>
					<li>
%先祖~list に %~url を付加する
◎
↓</li>
					<li>
<p>
( %行先, %先祖~list )
を与える下で， %結果 の`子孫を~fetchする$
◎
Otherwise, result is a module script. Fetch the descendants of result given destination and an ancestor list obtained by appending url to ancestor list.
</p>

<p>
この~fetchが［
%子孫~結果 を結果として，`非同期に完了-$した
］ときは
⇒
%子孫~結果 を結果として，`非同期に完了-$する
◎
When fetching the descendants of a module script asynchronously completes with descendants result, asynchronously complete this algorithm with descendants result.
</p>
					</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

<p>
次の~algoは、`~module~script木を~fetchする$ときに利用される
— 他の仕様（または、この仕様の他所）からの直接的な利用は意図されていない。
◎
The following algorithms are used when fetching a module script tree, and are not meant to be used directly by other specifications (or by other parts of this specification).
</p>

<p class="algo-head">
( %行先, %先祖~list )
が与えられた下で，
%~module~script の
`子孫を~fetchする@
ときは、次を走らす。
この~algoは、［
（失敗~時には）~NULL ／
（成功~時には）`~module~script$
］いずれかを結果として，`非同期に完了-$する：
◎
To fetch the descendants of a module script module script, given a destination and an ancestor list, run these steps. The algorithm will asynchronously complete with either null (on failure) or with module script (on success).
</p>

<ol>
	<li>
%~record ~LET
%~module~script の`~module~record$
◎
Let record be module script's module record.
</li>
	<li>
~IF［
%~record . `RequestedModules^sl は空である
］
⇒
%~module~script を結果として，`非同期に完了-$する
◎
If record.[[RequestedModules]] is empty, asynchronously complete this algorithm with module script.
</li>
	<li>
%~url~list ~LET 新たな空~list
◎
Let urls be a new empty list.
</li>
	<li>
<p>
~FOR
%~record . `RequestedModules^sl 内の ~EACH ( 文字列 %requested ) に対し：
◎
For each string requested of record.[[RequestedModules]],
</p>

		<ol>
			<li>
%~url ~LET
( %~module~script, %requested )
を与える下で，`~module指定子を解決-$した結果
◎
Let url be the result of resolving a module specifier given module script and requested.
</li>
			<li>
<p>
~IF［
%~url ~EQ `失敗^i
］：
◎
If the result is error:
</p>

				<ol>
					<li>
%~error ~LET 新たな `TypeError$js 例外
◎
Let error be a new TypeError exception.
</li>
					<li>
( %~module~script, %~error )
に対し，`例外を報告する$
◎
Report the exception error for module script.
</li>
					<li>
~NULL を結果として，`非同期に完了-$する
◎
Abort this algorithm, and asynchronously complete it with null.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%~url ~NIN %先祖~list
］
⇒
%~url~list に %~url を追加する
◎
Otherwise, if url is not in ancestor list, add url to urls.
</li>
		</ol>
	</li>
	<li>
<p>
~FOR
%~url~list 内の~EACH ( %~url ) に対し
⇒
( %~url, %~module~script の`資格証~mode$, %~module~script の`暗号用~nonce$, %~module~script の`構文解析器~状態$, %行先, %~module~script の`設定群~obj$, %先祖~list )
を与える下で，`~module~script木を~fetchする$：
◎
For each url in urls, fetch a module script tree given url, module script's credentials mode, module script's cryptographic nonce, module script's parser state, destination, module script's settings object, and ancestor list.
</p>

<p class="note">注記：
ここでは意図的に，［
`要請を設定しておく$／`応答を処理する$
］手続きは渡さない。
これらの~hookは、~module~script木の根における~top-levelの~fetchにのみ適用される。
◎
It is intentional that no custom set up the request or process the response steps are passed along here. Those hooks only apply to the top-level fetch at the root of the module script tree.
</p>

		<ul>
			<li>
これらの~fetchのうち，いずれかが［
~NULL を結果として，`非同期に完了-$した
］ときは
⇒
~UAは、他のすべての~fetchを`終了-$xしてよい
— その場合は
⇒
~NULL を結果として，`非同期に完了-$し~MUST
◎
If any of the fetch a module script tree invocations asynchronously complete with null, the user agent may terminate any or all of the other fetches, and must then asynchronously complete this algorithm with null.
</li>
			<li>
これらの~fetchすべてが［
`~module~script$を結果として，`非同期に完了-$した
］ときは
⇒
%~module~script を結果として，`非同期に完了-$する
◎
Once all of the fetch a module script tree invocations asynchronously complete with a module script, asynchronously complete this algorithm with module script.
</li>
		</ul>
	</li>
</ol>

<p class="algo-head">
( %~url, %資格証~mode, %暗号用~nonce, %構文解析器~状態, %行先, %設定群~obj )
が与えられた下で，
`単独の~module~scriptを~fetchする@
するときは、次を走らす。
この~algoは、［
（失敗~時には）~NULL ／
（成功~時には）`~module~script$
］いずれかを結果として，`非同期に完了-$する：
◎
To fetch a single module script, given a url, a credentials mode, a cryptographic nonce, a parser state, a destination, and a settings object, run these steps. The algorithm will asynchronously complete with either null (on failure) or a module script (on success).
</p>

<ol>
	<li>
%~module~map ~LET %設定群 の`~module~map$
◎
Let module map be settings's module map.
</li>
	<li>
~IF［
%~module~map 内に［
( ~key, 値 ) ~EQ  ( %~url, `fetching^l )
］なる~entryがある
］
⇒
その~entryの値が変化するまで，この段で待機する（`並列的$に）
◎
If module map contains an entry with key url whose value is "fetching", wait (in parallel) until that entry's value changes, then proceed to the next step.
</li>
	<li>
~IF［
%~module~map 内に［
~key ~EQ %~url 
］なる~entryがある
］
⇒
その~entryの値を結果として，`非同期に完了-$する
◎
If module map contains an entry with key url, asynchronously complete this algorithm with that entry's value, and abort these steps.
</li>
	<li>
%~module~map 内に，次のようにされた新たな~entryを作成する
⇒
( ~key, 値 ) ~SET ( %~url, `fetching^l )
◎
Create an entry in module map with key url and value "fetching".
</li>
	<li>
<p>
%要請 ~LET 次のようにされた新たな`要請$x
</p>

<ul><li>`~url$rq ~SET %~url
</li><li>`行先$rq ~SET %行先
</li><li>`種別$rq ~SET `script^l
</li><li>`~mode$rq ~SET `cors^l
</li><li>`資格証~mode$rq ~SET %資格証~mode
</li><li>`暗号用~nonce~metadata$rq ~SET %暗号用~nonce
</li><li>`構文解析器~metadata$rq ~SET %構文解析器~状態
</li><li>`~client$rq ~SET %設定群~obj 
</li></ul>

◎
Let request be a new request whose url is url, destination is destination, type is "script", mode is "cors", credentials mode is credentials mode, cryptographic nonce metadata is cryptographic nonce, parser metadata is parser stateand client is settings object.
</li>
	<li>
~IF［
この~algoの~call元にて，`要請を設定しておく$~custom手続きが指定されている
］
⇒
%要請 に対し，それを遂行する
◎
If the caller specified custom steps to set up the request, perform them on request.
</li>
	<li>
%要請 を`~fetchする$x
◎
Fetch request.
</li>
	<li>
<p>
~RET
— ただし，以降の手続きは、［
~fetchした結果の`応答$x %応答に対し`応答を処理する$x
］一部として走らす：
◎
Return from this algorithm, and run the remaining steps as part of the fetch's process response for the response response.
</p>

<p class="note">注記：
%応答 は常に`~CORS同一生成元$である。
◎
response is always CORS-same-origin.
</p>

	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…
◎
If any of the following conditions are met, set the value of the entry in module map whose key is url to null, asynchronously complete this algorithm with null, and abort these steps:
</p>

		<ul>
			<li>
%応答 の`種別$rs ~EQ `error^l
◎
response's type is "error"
</li>
			<li>
%応答 の`~status$rsは`~ok~status$rsでない
◎
response's status is not an ok status
</li>
			<li>
<p>
%応答 の`~header~list$rsから`~MIME型を抽出-$xした結果 ~NIN `~JS~MIME型$x
（~MIME~parameterは無視して）
◎
The result of extracting a MIME type from response's header list (ignoring parameters) is not a JavaScript MIME type.
</p>

<p class="note">注記：
歴史的~理由から、`~classic~scriptを~fetchする$ときは，~MIME型は検査されない。
対照的に~module~scriptは、~MIME型が正しくなければ，読込みに失敗することになる。
◎
For historical reasons, fetching a classic script does not include MIME type checking. In contrast, module scripts will fail to load if they are not of a correct MIME type.
</p>
			</li>
			<li>
<p>
［
この~algoの~call元にて`応答を処理する$手続きが指定されている
］~AND［
%応答 に対しそれを遂行した結果 ~EQ ~F
］
◎
The caller specified custom steps to process the response, which when performed on response return false.
</li>
		</ul>

<div>
<p>
…ならば：
</p>
		<ol>
			<li>
%~module~map 内の［
~key ~EQ %~url
］なる~entryの値 ~SET ~NULL；<br>
</li>
			<li>
~NULL を結果として，`非同期に完了-$する
</li>
		</ol>
◎
↑</div>

	</li>
	<li>
%~source~text ~LET
%応答 の`本体$rsを `UTF-8 復号-$xした結果
◎
Let source text be the result of UTF-8 decoding response's body.
</li>
	<li>
%~module~script ~LET
( %~source~text, %設定群~obj, %応答 の`~url$rs, %資格証~mode, %暗号用~nonce )
を与える下で，`~module~scriptを作成-$した結果
◎
Let module script be the result of creating a module script given source text, settings object, response's url, credentials mode, and cryptographic nonce.
</li>
	<li>
<p>
%~module~map 内の［
~key ~EQ %~url
］なる~entryの値 ~SET %~module~script；<br>
%~module~script を結果として，`非同期に完了-$する
◎
Set the value of the entry in module map whose key is url to module script, and asynchronously complete this algorithm with module script.
</p>

<p class="note">注記：
`~module~map$が`要請~URL$rqで~keyされる一方で，`~module~script$に対する`基底~URL$は`応答~URL$rsに設定されるのは、意図的である。
前者は~fetchを重複する`させなくする？^tnoteために利用される一方で、後者は~URL解決に利用される。
◎
It is intentional that the module map is keyed by the request URL, whereas the base URL for the module script is set to the response URL. The former is used to deduplicate fetches, while the latter is used for URL resolution.
</p>
	</li>
</ol>

		</section>
		<section id="creating-scripts">
<h4 title="Creating scripts">8.1.3.3. ~scriptの作成法</h4>

<p class="algo-head">
( %~script~source, %環境~設定群~obj, %黙秘error~flag )
が与えられた下で，
`~classic~scriptを作成-@
するときは：
◎
To create a classic script, given some script source, an environment settings object, and an optional muted errors flag:
</p>

<ol>
	<li>
%~script ~LET 新たな`~classic~script$（以下にしたがって初期化される）
◎
Let script be a new classic script that this algorithm will subsequently initialise.
</li>
	<li>
%~script の`設定群~obj$ ~SET %環境~設定群~obj
◎
Set script's settings object to the environment settings object provided.
</li>
	<li>
%~script の`~source~text$ ~SET［
%環境~設定群~obj の`担当の閲覧文脈$に対し
`~scriptingは不能化され$ているならば 空~文字列 ／
~ELSE_ %~script~source
］
◎
If scripting is disabled for the given environment settings object's responsible browsing context, then set script's source text to the empty string. Otherwise, set script's source text to the supplied script source.
</li>
	<li>
~IF［
%黙秘error~flag ~EQ ~ON
］
⇒
%~script の`黙秘error~flag$ ~SET ~ON
◎
If the muted errors flag was set, then set script's muted errors flag.
</li>
	<li>
~RET %~script 
◎
Return script.
</li>
</ol>

<p class="algo-head">
( %~script~source, %環境~設定群~obj, %~script基底~URL, %資格証~mode, %暗号用~nonce, %構文解析器~状態 )
が与えられた下で，
`~module~scriptを作成-@
するときは：
◎
To create a module script, given some script source, an environment settings object, a script base URL, a credentials mode, a cryptographic nonce, and a parser state:
</p>


<ol>
	<li>
%~script ~LET 新たな`~module~script$（以下にしたがって初期化される）
◎
Let script be a new module script that this algorithm will subsequently initialise.
</li>
	<li>
%~script の`設定群~obj$ ~SET %環境~設定群~obj
◎
Set script's settings object to the environment settings object provided.
</li>
	<li>
%~realm ~LET %環境~設定群~obj の`~Realm$
◎
Let realm be the provided environment settings object's Realm.
</li>
	<li>
~IF［
%環境~設定群~obj の`担当の閲覧文脈$に対し
`~scriptingは不能化され$ている
］
⇒
%~script~source ~SET 空~文字列
◎
If scripting is disabled for the given environment settings object's responsible browsing context, then let script source be the empty string. Otherwise, let script source be the provided script source.
</li>
	<li>
%結果 ~LET
`ParseModule$jA( %~script~source, %~realm, %~script )
◎
Let result be ParseModule(script source, realm, script).
</li>
	<li>
~IF［
%結果 は ~errorたちの `List$js である
］
⇒
( %~script, %結果 の最初の要素 )
に対し，`例外を報告する$；<br>
~RET ~NULL
◎
If result is a List of errors, report the exception given by the first element of result for script, return null, and abort these steps.
</li>
	<li>
%~script の`~module~record$ ~SET %結果
◎
Set script's module record to result.
</li>
	<li>
%~script の`基底~URL$ ~SET %~script基底~URL
◎
Set script's base URL to the script base URL provided.
</li>
	<li>
%~script の`資格証~mode$ ~SET %資格証~mode
◎
Set script's credentials mode to the credentials mode provided.
</li>
	<li>
%~script の`暗号用~nonce$ ~SET %暗号用~nonce
◎
Set script's cryptographic nonce to the cryptographic nonce provided.
</li>
	<li>
%~script の`構文解析器~状態$ ~SET %構文解析器~状態
◎
Set script's parser state to the parser state.
</li>
	<li>
~RET %~script
◎
Return script.
</li>

</ol>

		</section>
		<section id="calling-scripts">
<h4 title="Calling scripts">8.1.3.4. ~scriptの~call法</h4>

<p class="algo-head">
( `~classic~script$ %~script, %再投出error~flag )
が与えられた下で，
`~classic~scriptを走らす@
ときは：
◎
To run a classic script given a classic script s and an optional rethrow errors flag:
</p>

<ol>
	<li>
%設定群 ~LET %~script の`設定群~obj$
◎
Let settings be the settings object of s.
</li>
	<li>
~IF［
%設定群 を用いて`~scriptは走れるかどうか検査-$した結果 ~EQ `走るな^i 
］
⇒
~RET undefined<!--＊-->
◎
Check if we can run script with settings. If this returns "do not run", then return undefined and abort these steps.
</li>
	<li>
%~realm ~LET %設定群 の`~Realm$
◎
Let realm be settings's Realm.
</li>
	<li>
%設定群 を用いて`~scriptを走らすために準備する$
◎
Prepare to run script with settings.
</li>
	<li>
%結果 ~LET `ParseScript$jA( %~script の`~source~text$, %~realm, %~script )
◎
Let result be ParseScript(s's source text, realm, s).
</li>
	<li>
~IF［
%結果 は ~errorたちの `List$js である
］
⇒
%結果 ~SET %結果 の最初の要素；<br>
~GOTO `~error^i
◎
If result is a List of errors, set result to the first element of result and go to the step labeled error.
</li>
	<li>
%評価~status ~LET `ScriptEvaluation$jA( %結果 )
◎
Let evaluationStatus be ScriptEvaluation(result).
</li>
	<li>
<p>
%評価~status に応じて：
</p>
		<dl class="switch">
			<dt>中途完了である</dt>
			<dd>
%結果 ~SET %評価~status . `Value^sl；<br>
~GOTO `~error^i
</dd>

			<dt>正常完了である</dt>
			<dt>存在しない（~UAは`走中の~scriptを中止-$したため `ScriptEvaluation^jA は完了しなかった）</dt>
			<dd>
~GOTO `片付け^i
</dd>
		</dl>
◎
If evaluationStatus is an abrupt completion, set result to evaluationStatus.[[Value]] and go to the next step (labeled error). If evaluationStatus is a normal completion, or if ScriptEvaluation does not complete because the user agent has aborted the running script, skip to the step labeled cleanup.
</li>
	<li>
<p>
`~error^i （この時点で %結果 は例外である）：
◎
Error: At this point result must be an exception. Perform the following steps:
</p>

		<ol>
			<li>
<p>
~IF［
%再投出error~flag ~EQ ~ON
］：
</p>
				<ol>
					<li>
~IF［
%~script の %黙秘error~flag ~EQ ~ON
］
⇒
`NetworkError$I を投出する†
</li>
					<li>
~ELSE
⇒
%結果 を再投出する†
</li>
				</ol>

<p class="trans-note">【†
この手続きの最後の段の記述から、例外を投出した後も，この手続きは続行すると見られる。
】</p>
◎
If the rethrow errors flag is set and s's muted errors flag is not set, rethrow result.
◎
If the rethrow errors flag is set and s's muted errors flag is set, throw a NetworkError exception.
</li>
	<li>
~ELSE
⇒
( %~script，%結果 )
に対し，`例外を報告する$
◎
If the rethrow errors flag is not set, report the exception given by result for the script s.
</li>

		</ol>
	</li>
	<li>
`片付け^i：
%設定群 を用いて，`走らせた~scriptを片付ける$
◎
Cleanup: Clean up after running script with settings.
</li>
	<li>
~IF［
%評価~status は正常完了である
］
⇒
~RET %評価~status . `Value^sl
◎
↓</li>
	<li>
~ELSE
⇒
~script実行は、次のいずれかのため，成功しなかったことになる
⇒
構文解析-時に~errorが生じた ／
評価の間に例外が生じた ／
尚早に`中止-$された
◎
If evaluationStatus exists and is a normal completion, return evaluationStatus.[[Value]]. Otherwise, script execution was unsuccessful, either because an error occurred during parsing, or an exception occurred during evaluation, or because it was aborted prematurely.
</li>
</ol>

<p class="algo-head">
( `~module~script$ %~script )
が与えられた下で，
`~module~scriptを走らす@
ときは：
◎
To run a module script given a module script s:
</p>

<ol>
	<li>
%設定群 ~LET %~script の`設定群~obj$
◎
Let settings be the settings object of s.
</li>
	<li>
~IF［
%設定群 を用いて`~scriptは走れるかどうか検査-$した結果 ~EQ `走るな^i 
］
⇒
~RET
◎
Check if we can run script with settings. If this returns "do not run" then abort these steps.
</li>
	<li>
%~record ~LET %~script の`~module~record$
◎
Let record be s's module record.
</li>
	<li>
<p>
%~instantiation~status ~LET
%~record . `ModuleDeclarationInstantiation$jA()
◎
Let instantiationStatus be record.ModuleDeclarationInstantiation().
</p>

<p class="note">注記：
この段は、~moduleの依存関係すべてを再帰的に~instantiateすることになる。
◎
This step will recursively instantiate all of the module's dependencies.
</p>

	</li>
	<li>
~IF［
%~instantiation~status は中途完了である
］
⇒
( %~script, %~instantiation~status . `Value^sl )
に対し，`例外を報告する$；<br>
~RET
◎
If instantiationStatus is an abrupt completion, report the exception given by instantiationStatus.[[Value]] for s and abort these steps.
</li>
	<li>
%設定群 を用いて`~scriptを走らすために準備する$
◎
Prepare to run script given settings.
</li>
	<li>
<p>
%評価~status ~LET %~record . `ModuleEvaluation$jA()
◎
Let evaluationStatus be record.ModuleEvaluation().
</p>

<p class="note">注記：
この段は、~moduleの依存関係すべてを再帰的に評価することになる。
◎
This step will recursively evaluate all of the module's dependencies.
</p>

	</li>
	<li>
~IF［
%評価~status は中途完了である
］
⇒
( %~script, %評価~status . `Value^sl )
に対し，`例外を報告する$
（~UAが`走中の~scriptを中止-$したため `ScriptEvaluation$jA は完了しなかった場合には、この段は遂行しないこと。）
◎
If evaluationStatus is an abrupt completion, report the exception given by evaluationStatus.[[Value]] for s. (Do not perform this step if ScriptEvaluation fails to complete as a result of the user agent aborting the running script.)
</li>
	<li>
%設定群 を用いて，`走らせた~scriptを片付ける$
◎
Clean up after running script with settings.
</li>
</ol>

<p>
`環境~設定群~obj$ %設定群 を用いて
`~scriptは走れるかどうか検査-@
する手続きは、次で与えられ，［
`走れ^i, `走るな^i
］のいずれかを返す：
◎
The steps to check if we can run script with an environment settings object settings are as follows. They return either "run" or "do not run".
</p>

<ol>
	<li>
~IF［
%設定群 の`大域~obj$0
は`~window$である
］~AND［
%設定群 の`文書$は`全部的に作動中$xでない
］
⇒
~RET `走るな^i
◎
If the global object specified by settings is a Window object whose Document object is not fully active, then return "do not run" and abort these steps.
</li>
	<li>
~IF［
%設定群 により指定される`担当の閲覧文脈$に対する
`~scriptingは不能化され$ている
］
⇒
~RET `走るな^i
◎
If scripting is disabled for the responsible browsing context specified by settings, then return "do not run" and abort these steps.
</li>
	<li>
~RET `走れ^i
◎
Return "run".
</li>
</ol>

<p class="algo-head">
`環境~設定群~obj$ %設定群 を用いて，
`~scriptを走らすために準備する@
手続きは、次で与えられる：
◎
The steps to prepare to run script with an environment settings object settings are as follows:
</p>

<ol>
	<li>
%設定群 の`~realm実行~文脈$の`~entrance~counter$ ~INCBY 1
◎
Increment settings's realm execution context's entrance counter by one.
</li>
	<li>
%設定群 の`~realm実行~文脈$を`~JS実行~文脈~stack$jsに~pushする
— この時点で、それが`走中の~JS実行~文脈$jsになる。
◎
Push settings's realm execution context onto the JavaScript execution context stack; it is now the running JavaScript execution context.
</li>

</ol>

<p class="algo-head">
`環境~設定群~obj$ %設定群 を用いて，
`走らせた~scriptを片付ける@
手続きは、次で与えられる：
◎
The steps to clean up after running script with an environment settings object settings are as follows:
</p>

<ol>
	<li>
~Assert：
%設定群 の`~realm実行~文脈$は、`走中の~JS実行~文脈$jsである
◎
Assert: settings's realm execution context is the running JavaScript execution context.
</li>
	<li>
%設定群 の`~realm実行~文脈$の`~entrance~counter$ ~DECBY 1
◎
Decrement settings's realm execution context's entrance counter by one.
</li>
	<li>
`~JS実行~文脈~stack$jsから， %設定群 の`~realm実行~文脈$を除去する
◎
Remove settings's realm execution context from the JavaScript execution context stack.
</li>
	<li>
~IF［
`~JS実行~文脈~stack$jsは空になった
］
⇒
`大域~script片付け~jobを走らす$
（これが~scriptを走らすことはない。）
◎
If the JavaScript execution context stack is now empty, run the global script clean-up jobs. (These cannot run scripts.)
</li>
	<li>
~IF［
`~JS実行~文脈~stack$jsは空になった
］
⇒
`極小task~checkpointを遂行する$
（これが~scriptを走らす場合、この~algoは，再入的に呼出されることになる。）
◎
If the JavaScript execution context stack is now empty, perform a microtask checkpoint. (If this runs scripts, these algorithms will be invoked reentrantly.)
</li>
</ol>

<p class="note">注記：
これらの~algoは、ある~scriptが別の~scriptを直接的に~callすることにより呼出されることはないが、間接的な方式で再入的に呼出され得る
— 例えば、~scriptが~eventを配送したとき，その~eventに対し~event~listenerが登録されている場合。
◎
These algorithms are not invoked by one script directly calling another, but they can be invoked reentrantly in an indirect manner, e.g. if a script dispatches an event which has event listeners registered.
</p>

<p>
`走中の~script@
とは、`走中の~JS実行~文脈$jsの `ScriptOrModule^jA 成分の `HostDefined^sl ~field内の `script$e である。
◎
The running script is the script in the [[HostDefined]] field in the ScriptOrModule component of the running JavaScript execution context.
</p>

<hr>


<p>
各［
`互関係かつ類似生成元の閲覧文脈~群$x
］は、
`大域~script片付け~job~list@
を持つ。
それは、初期~時には空で~MUST。
大域~script片付け~jobは、~scriptを走らすことはできず，他の片付け~jobが実行される順序を感知し得ない。
`FILEAPI$r は、 `blob$sc ~URLを解放するためにこれを利用する。
◎
Each unit of related similar-origin browsing contexts has a global script clean-up jobs list, which must initially be empty. A global script clean-up job cannot run scripts, and cannot be sensitive to the order in which other clean-up jobs are executed. The File API uses this to release blob: URLs. [FILEAPI]
</p>


<p class="algo-head">
~UAは、
`大域~script片付け~jobを走らす@
ときは，`大域~script片付け~job~list$内の各~jobを遂行した上で、その~listを空にし~MUST。
◎
When the user agent is to run the global script clean-up jobs, the user agent must perform each of the jobs in the global script clean-up jobs list and then empty the list.
</p>


		</section>
		<section id="realms-settings-objects-global-objects">
<h4 title="Realms, settings objects, and global objects">8.1.3.5. ~realm, 設定群~obj, 大域~obj</h4>


<p>
`大域~obj@
とは、`~JS~realm$jsの `GlobalObject^sl ~fieldである~JS~objである。
◎
A global object is a JavaScript object that is the [[GlobalObject]] field of a JavaScript realm.
</p>

<p class="note">
この仕様では、すべての`~JS~realm$jsは，［［
`Window$I, `WorkerGlobalScope$I 
］いずれかの~objである`大域~obj$
］で`初期化-$jsされる。
◎
In this specification, all JavaScript realms are initialized with global objects that are either Window or WorkerGlobalScope objects.
</p>

<p>
［
`~JS~realm$js %R, `大域~obj$ %G, `環境~設定群~obj$ %S
］は、常に，互いに 1:1:1 に対応する。
◎
There is always a 1:1:1 mapping between JavaScript realms, global objects, and environment settings objects:
</p>

<ul>
	<li>
<p>
%R 視点からは：
</p>
		<ul>
			<li>
%R の `HostDefined^sl ~fieldが，対応する %S を与える
— %S を指して ~Realm %R の
`設定群~obj@1
という。
</li>
			<li>
%R の `GlobalObject^sl ~fieldが，対応する %G を与える
— %G を指して ~Realm %R の
`大域~obj@1
という。
</li>
		</ul>

◎
A JavaScript realm has a [[HostDefined]] field, which contains the Realm's settings object.
◎
A JavaScript realm has a [[GlobalObject]] field, which contains the Realm's global object.
</li>

	<li>
<p>
%G 視点からは：
</p>
		<ul>
			<li>
%G は，対応する %R が`初期化-$jsされる間に作成される。
%R を指して %G の
`~Realm@0
という。
</li>
			<li id="relevant-settings-object-for-a-global-object">
%G は，対応する %S と並行して作成される。
%S は %G に`関連する設定群~obj$と呼ばれる。
</li>
		</ul>

◎
Each global object in this specification is created during the initialization of a corresponding JavaScript realm, known as the global object's Realm.
◎
Each global object in this specification is created alongside a corresponding environment settings object, known as its relevant settings object.
</li>

	<li>
<p>
%S 視点からは：
</p>
		<ul>
			<li>
%S の`~realm実行~文脈$の~Realm成分が，対応する %R を与える
— %R を指して %S の
`~Realm@
という。
</li>
			<li>
対応する %G （すなわち， %S の`~Realm$ の `GlobalObject^sl ~field）を指して %S の
`大域~obj@0
という。
</li>
		</ul>
◎
An environment settings object's realm execution context's Realm component is the environment settings object's Realm.
◎
An environment settings object's Realm then has a [[GlobalObject]] field, which contains the environment settings object's global object.
</li>
</ul>


<hr>

<p>
この仕様~全体を通して、~algoの手続きを定義するときに，どの`~JS~realm$jsが利用されるか
— あるいは，同じことだが、どの`大域~obj$／`環境~設定群~obj$が利用されるか —
を指示することが重要になることは、よくある。
一般に、少なくとも次の 4 種いずれかで指示され得る：
◎
When defining algorithm steps throughout this specification, it is often important to indicate what JavaScript realm is to be used—or, equivalently, what global object or environment settings object is to be used. In general, there are at least four possibilities:
</p>

<dl>
	<dt>`~entry@</dt>
	<dd>
これは、現在~走中の~script動作を起動した~scriptに対応する：
すなわち、~UAが，中へ~callした［
関数／~script
］— それ`どれ？^tnoteが作者~codeの中へ~callしたときの。
◎
This corresponds to the script that initiated the currently running script action: i.e., the function or script that the user agent called into when it called into author code.
</dd>

	<dt>`~incumbent@</dt>
	<dd>
これは、~stack上で最も近過去に~enterした作者［
関数／~script
］に対応する。
◎
This corresponds to the most-recently-entered author function or script on the stack.
</dd>

	<dt>`現在の〜@</dt>
	<dd>
これは、現在~走中の関数~objに対応する。
これには、~JSとして実装されていないかもしれないような，~UAに組込みの関数も含まれる（それは<span>現在の~JS~realm</span>から導出される）。
◎
This corresponds to the currently-running function object, including built-in user-agent functions which might not be implemented as JavaScript. (It is derived from the current JavaScript realm.)
</dd>

	<dt>`〜に関連する@</dt>
	<dd>
どの`~platform~obj$xも`関連する~Realm$を持つ。
~algoを書くときに，［
`関連する~Realm$が重要になり得るような`~platform~obj$x
］として，真っ先に挙がるのは、現在~走中の関数~objの <b>this</b> 値になる。
<!-- ＊ -->
一部の事例では、引数のそれなど，`関連する~Realm$が重要になるものが他にもあり得る。
◎
Every platform object has a relevant Realm. When writing algorithms, the most prominent platform object whose relevant Realm might be important is the this value of the currently-running function object. In some cases, there can be other important relevant Realms, such as those of any arguments.
</dd></dl>

 
<p>
［
`~entry$, `~incumbent$, `現在の〜$
］の概念は，限定句なしに利用できる一方で、`〜に関連する$の概念は，特定0の`~platform~obj$xに適用され~MUSTことに注意。
◎
Note how the entry, incumbent, and current concepts are usable without qualification, whereas the relevant concept must be applied to a particular platform object.
</p>

<div class="example">

<p>
次の各~頁を考える。
ここでは、
`a.html^s は~browser~window内に読込まれていて，
`b.html^s は 示されているように `iframe$e 内に読込まれていて，
`c.html^s, `d.html^s は省略されている（単純に，空~文書でもよい）
とする：
◎
Consider the following pages, with a.html being loaded in a browser window, b.html being loaded in an iframe as shown, and c.html and d.html omitted (they can simply be empty documents):
</p>

<!-- 
Entry page
Incumbent page
-->
<pre>
&lt;!-- a.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;~entry頁&lt;/title&gt;

&lt;iframe src="b.html"&gt;&lt;/iframe&gt;
&lt;button onclick="frames[0].hello()"&gt;Hello&lt;/button&gt;

&lt;!--b.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;~incumbent頁&lt;/title&gt;

&lt;iframe src="c.html" id="c"&gt;&lt;/iframe&gt;
&lt;iframe src="d.html" id="d"&gt;&lt;/iframe&gt;

&lt;script&gt;
  const %c = document.querySelector("#c").contentWindow;
  const %d = document.querySelector("#d").contentWindow;

  window.hello = () =&gt; {
    %c.print.call(%d);
  };
&lt;/script&gt;
</pre>

<p>
各~頁は、自前の`閲覧文脈$xを有し，したがって自前の［
`~JS~realm$js, `大域~obj$, `環境~設定群~obj$
］を有する。
◎
Each page has its own browsing context, and thus its own JavaScript realm, global object, and environment settings object.
</p>


<p>
`a.html^s 内の~buttonの押下げに呼応して
`print()$m ~methodが~callされたときは：
◎
When the print() method is called in response to pressing the button in a.html, then:
</p>

<ul>
	<li>
`~entry~Realm$は、
`a.html^s のそれになる。
◎
The entry Realm is that of a.html.
</li>
	<li>
`~incumbent~Realm$は、
`b.html^s のそれになる。
◎
The incumbent Realm is that of b.html.
</li>
	<li>
`現在の~Realm~Record$jsは、 `c.html^s のそれになる（走中の~codeは、 `c.html^s に属する `print()$m ~methodなので）。
◎
The current Realm is that of c.html (since it is the print() method from c.html whose code is running).
</li>
	<li>
`print()$m ~methodが~callされている~objに`関連する~Realm$は、
`d.html^s のそれになる。
◎
The relevant Realm of the object on which the print() method is being called is that of d.html.
</li>
</ul>

</div>

<p class="warning">
`~incumbent$, `~entry$
の概念は、新たな仕様には利用されるべきでない概念であり，既存の利用をほぼ除去できるかどうか検討中にある。
`~incumbent$については，
<a href="~SPECBUGS?id=26603">Bugzilla bug 26603</a>
を、`~entry$については，
<a href="~SPECBUGS?id=27203">Bugzilla bug 27203</a>
を見よ。
◎
The incumbent and entry concepts should not be used by new specifications, and we are considering whether we can remove almost all existing uses. See Bugzilla bug 26603 for incumbent, and Bugzilla bug 27203 for entry.
</p>

<p class="note">注記：
現在、`~incumbent$の概念は，一部の保安~検査に利用されており、`~entry$の概念は，［［［
`互関係かつ類似生成元の閲覧文脈~群$x
］内で走中の各~scriptにて利用される `~URLを構文解析-$する
］ための`~API基底~URL$
］, その他諸々を得るために利用されている。
◎
Currently, the incumbent concept is used in some security checks, and the entry concept is sometimes used to obtain, amongst other things, the API base URL to parse a URL, used in scripts running in that unit of related similar-origin browsing contexts.
</p>

 
<p>
一般に、これからの仕様が利用すべきは，`現在の〜$の概念である。
ただし、重要な例外がある。
~algoが，［
複数回にわたり返されるような，持続的な~obj
］を作成している場合（単純に、作成したそれを作者~codeにすぐに返して，決して~~内部に~~保持しないのではなく）、`〜に関連する$の概念が，［
実行されている当の~methodを持つ~obj
］に対し利用されるべきである。
これにより、~realmをまたがる~callにより，~objに［
“間違った” ~realmで作成された~obj
］が格納されることは、防止される。
◎
In general, the current concept is what should be used by specifications going forward. There is an important exception, however. If an algorithm is creating an object that is to be persisted and returned multiple times (instead of simply returned to author code right away, and never vended again), it should use the relevant concept with regard to the object on which the method in question is being executed. This prevents cross-realm calls from causing an object to store objects created in the "wrong" realm.
</p>

<div class="example">
<p>
`getBattery()$m ~method `BATTERY$r
は、それが呼出された `Navigator$I ~objに`関連する~Realm$内に~promiseを作成する。
これは、次に影響0する：
◎
The navigator.getBattery() method creates promises in the relevant Realm for the Navigator object on which it is invoked. This has the following impact: [BATTERY]
</p>

<pre>&lt;!-- outer.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;関連する~Realmの例証： outer 頁&lt;/title&gt;
&lt;script&gt;
  function doTest() {
    const %promise = navigator.getBattery.call(frames[0].navigator);

    console.log(%promise instanceof Promise);           // logs false
    console.log(%promise instanceof frames[0].Promise); // logs true

    frames[0].hello();
  }
&lt;/script&gt;
&lt;iframe src="inner.html" onload="doTest()"&gt;&lt;/iframe&gt;

&lt;!-- inner.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;関連する~Realmの例証： inner 頁&lt;/title&gt;
&lt;script&gt;
  function hello() {
    const %promise = navigator.getBattery();

    console.log(%promise instanceof Promise);        // logs true
    console.log(%promise instanceof parent.Promise); // logs false
  }
&lt;/script&gt;
</pre>

<p>
`getBattery()$m ~methodの~algoが，代わりに`現在の~Realm~Record$jsを利用した場合、すべての結果が覆されることになる。
すなわち、 `outer.html^s 内の `getBattery()$m に対する最初の~callの後、
`inner.html^s 内の `Navigator$I ~objは，
`outer.html^s の`~JS~realm$jsにて作成された
`Promise^c ~objを恒久的に格納することになる結果、
`hello()^c 関数の内側における同様の~callは， “間違った” ~realmからの~promiseを返すことになる。
これは望ましくないので、~algoは、上の~commentで指示されるような~~分別のある結果を与える，`関連する~Realm$を代わりに利用する。
◎
If the algorithm for the getBattery() method had instead used the current Realm, all the results would be reversed. That is, after the first call to getBattery() in outer.html, the Navigator object in inner.html would be permanently storing a Promise object created in outer.html's JavaScript realm, and calls like that inside the hello() function would thus return a promise from the "wrong" realm. Since this is undesirable, the algorithm instead uses the relevant Realm, giving the sensible results indicated in the comments above.
</p>

</div>


<hr>


<p>
この節の以降では、公式的に，［
`~entry$, `~incumbent$, `現在の〜$, `〜に関連する$
］の概念について定義する。
◎
The rest of this section deals with formally defining the entry, incumbent, current, and relevant concepts.
</p>

			<section id="entry">
<h5 title="Entry">8.1.3.5.1. ~entry</h5>

<p>
すべての`~realm実行~文脈$は、自身の~code評価~状態の一部として，
`~entrance~counter@
値
— 初期時は~zero —
を包含し~MUST。
この値は、
<a href="#calling-scripts">~callしている~script</a>
の処理-において，増減されることになる。
◎
All realm execution contexts must contain, as part of their code evaluation state, an entrance counter value, which is initially zero. In the process of calling scripts, this value will be incremented and decremented.
</p>

<p>
これをもって，
`~entry実行~文脈@
は、`~JS実行~文脈~stack$js内の［
`~entrance~counter$ 値 ~GT ~zero
］なる~entryのうち，最も近過去に~pushされたものとして定義される。
`~entry~Realm@
は、`~entry実行~文脈$の~Realm成分で与えられる。
◎
With this in hand, we define the entry execution context to be the most recently pushed entry in the JavaScript execution context stack whose entrance counter value is greater than zero. The entry Realm is the entry execution context's Realm component.
</p>

<p>
これにより、次も定義される：
◎
↓</p>

<ul>
	<li>
`~entry設定群~obj@
は、`~entry~Realm$の`設定群~obj$1である。
◎
Then, the entry settings object is the environment settings object of the entry Realm.
</li>
	<li>
`~entry大域~obj@
は、`~entry~Realm$の`大域~obj$1である。
◎
Similarly, the entry global object is the global object of the entry Realm.
</li>
</ul>

			</section>
			<section id="incumbent">
<h5 title="Incumbent">8.1.3.5.2. ~incumbent</h5>


<p class="algo-head">
`~incumbent設定群~obj@
は、次に従って決定される：
◎
The incumbent settings object is determined as follows:
</p>

  <ol>
	<li>
%scriptOrModule ~LET
~JS `GetActiveScriptOrModule()$jA 抽象演算の結果
◎
Let scriptOrModule be the result of JavaScript's GetActiveScriptOrModule() abstract operation.
</li>
	<li>
~IF［
%scriptOrModule ~EQ ~NULL
］
⇒
~RET
— `~incumbent設定群~obj$はない。
◎
If scriptOrModule is null, abort these steps; there is no incumbent settings object.
</li>
	<li>
~RET ［［
%scriptOrModule の `HostDefined^sl ~field
］内の`~script$x
］の`設定群~obj$
◎
Return the settings object of the script in scriptOrModule's [[HostDefined]] field.
</li>

</ol>

<p>
これにより、次も定義される：
◎
↓</p>

<ul>
	<li>
`~incumbent~Realm@
は、`~incumbent設定群~obj$の`~Realm$である。
◎
Then, the incumbent Realm is the Realm of the incumbent settings object.
</li>
	<li>
`~incumbent大域~obj@
は、`~incumbent設定群~obj$の`大域~obj$0である。
◎
Similarly, the incumbent global object is the global object of the incumbent settings object.
</li>
</ul>

			</section>
			<section id="current">
<h5 title="Current">8.1.3.5.3. 現在の〜</h5>

 
<p>
~JS仕様は、
`現在の~Realm~Record$jsを定義している
— “現在の~Realm” と略称されることもある。
`JAVASCRIPT$r
◎
The JavaScript specification defines the current Realm Record, sometimes abbreviated to "the current Realm". [JAVASCRIPT]
</p>

<p>
これにより、次も定義される：
◎
↓</p>

<ul>
	<li>
`現在の設定群~obj@
は、`現在の~Realm~Record$jsの`設定群~obj$1である。
◎
Then, the current settings object is the environment settings object of the current Realm Record.
</li>
	<li>
`現在の大域~obj@
は、`現在の~Realm~Record$jsの`大域~obj$1である。
◎
Similarly, the current global object is the global object of the current Realm Record.
</li>
</ul>

			</section>
			<section id="relevant">
<h5 title="Relevant">8.1.3.5.4. 〜に関連する</h5>

<p>
`~platform~obj$xに
`関連する設定群~obj@
は、次に従って定義される：
◎
The relevant settings object for a platform object is defined as follows:
</p>

  <dl class="switch">

	<dt>~objが`大域~obj$である場合：</dt>
	<dd>
この仕様における各`大域~obj$は、［
それに`関連する設定群~obj$である，対応する`環境~設定群~obj$
］に並行して，作成される。
◎
Each global object in this specification is created alongside a corresponding environment settings object; that is its relevant settings object.
</dd>

	<dt>他の場合：</dt>
	<dd>
<p>
~objが`属する大域~環境$xに`関連する設定群~obj$。
◎
The relevant settings object for a non-global platform object o is the environment settings object whose global object is the global object of the global environment associated with o.
</p>



<p class="note">注記：
“〜が`属する大域~環境$x”
（ global environment associated with 〜 ）
の概念は、現代の~JS仕様と その`~JS~realm$jsの概念が~~出現する以前の，昔ながらのものである。
~Web~IDL仕様が更新されたときには、どの`~platform~obj$xにも `~JS~realm$jsが結付けられ、この定義は，それらの用語で書き直せるようになることが期待されている。
`JAVASCRIPT$r
`WEBIDL$r
◎
The "global environment associated with" concept is from the olden days, before the modern JavaScript specification and its concept of realms. We expect that as the Web IDL specification gets updated, every platform object will have a Realm associated with it, and this definition can be re-cast in those terms. [JAVASCRIPT] [WEBIDL]
</p>
   </dd></dl>

<p>
これにより、次も定義される：
◎
↓</p>

<ul>
	<li>
`~platform~obj$xに
`関連する~Realm@
は、それに`関連する設定群~obj$の`~Realm$である。
◎
Then, the relevant Realm for a platform object is the Realm of its relevant settings object.
</li>
	<li>
`~platform~obj$xに
`関連する大域~obj@
は、それに`関連する設定群~obj$の`大域~obj$0である。
◎
Similarly, the relevant global object for a platform object is the global object of its relevant settings object.
</li>
</ul>

			</section>
		</section>
		<section id="killing-scripts">
<h4 title="Killing scripts">8.1.3.6. ~scriptの強制終了</h4>

<p>
`走中の~scriptを中止-@
する必要が生じることはときどきある
— ~JS仕様はその可能性について織込んでいないが。
これは、どの
`ScriptEvaluation$jA ／ `ModuleEvaluation$jA
も即時に止めた上で，
`finally^c ~blockの様な通常の仕組みを誘発することなく，`~JS実行~文脈~stack$jsを空にする。
`JAVASCRIPT$r
◎
Although the JavaScript specification does not account for this possibility, it's sometimes necessary to abort a running script. This causes any ScriptEvaluation or ModuleEvaluation to cease immediately, emptying the JavaScript execution context stack without triggering any of the normal mechanisms like finally blocks. [JAVASCRIPT]
</p>


<div>
<p>
~UAは、~scriptに~~割り振る計算資源に制限を課してよい
— 例えば［
CPU ~quota ／
記憶域 ／
実行~時間の総計 ／
帯域幅
］に対する制限など。
~scriptがこれらの制限-を超過したときは、~UAは，次のいずれかをしてよい：
</p>

<ul>
	<li>
`QuotaExceededError$I 例外を投出する
</li>
	<li>
例外を投出せずに~scriptを`中止-$する
</li>
	<li>
利用者に~promptする
</li>
	<li>
~script実行を絞る
</li>
</ul>

◎
User agents may impose resource limitations on scripts, for example CPU quotas, memory limits, total execution time limits, or bandwidth limitations. When a script exceeds a limit, the user agent may either throw a QuotaExceededError exception, abort the script without an exception, prompt the user, or throttle script execution.
</div>

<div class="example">
<p>
例えば、次の~scriptは，決して終了しない。
~UAは、数~秒~待機した後に，利用者に［
~scriptを終了するか，そのまま継続させるか
］を~promptすることもできる。
◎
For example, the following script never terminates. A user agent could, after waiting for a few seconds, prompt the user to either terminate the script or let it continue.
</p>


<pre>
&lt;script&gt;
 while (true) { /* loop */ }
&lt;/script&gt;
</pre>

</div>


<div class="p">
<p>
~UAには、次のときには，利用者が~scriptingを不能化できるようにすることが奨励される：
</p>

<ul>
	<li>
~scriptが利用者に~promptしたとき（例えば `window.alert()$m ~APIを利用して）。
</li>
	<li>
~scriptの動作が何らかの制限-を超過したとき（例えば、時間~制限-）。
</li>
</ul>

◎
User agents are encouraged to allow users to disable scripting whenever the user is prompted either by a script (e.g. using the window.alert() API) or because of a script's actions (e.g. because it has exceeded a time limit).
</div>


<p>
~scriptが実行-中の間に，~scriptingが不能化された場合、~scriptは即時に終了されるべきである。
◎
If scripting is disabled while a script is executing, the script should be terminated immediately.
</p>


<p>
~UAは、利用者が［
`閲覧文脈$xを何もさせずに閉じる目的0で，特に~scriptを不能化する
］ことを許容してよい。
◎
User agents may allow users to specifically disable scripts just for the purposes of closing a browsing context.
</p>


<p class="example">
例えば上の例に示された~promptは、［
`unload$et ~event~handlerを走せず，ただ頁~全体を閉じる仕組み
］を利用者に提供0することもできる。
◎
For example, the prompt mentioned in the example above could also offer the user with a mechanism to just close the page entirely, without running any unload event handlers.
</p>



		</section>
		<section id="integration-with-the-javascript-job-queue">
<h4 title="Integration with the JavaScript job queue">8.1.3.7. ~JS~job待行列との統合</h4>

<p>
~JS仕様は、［
clean な
`手が加えられていない^tnote
`~JS実行~文脈~stack$jsによる~promise演算を，一定の順序でどう実行するか
］についての ある種の不変則を指定するために、［
~JS~job, および ~job待行列
］の抽象化を定義している。
しかしながら，この仕様を書いている時点では、
~JS仕様 `JAVASCRIPT$r の `EnqueueJob$jA の定義は， HTML を~host環境として統合できるほど十分に柔軟でない。
◎
The JavaScript specification defines the JavaScript job and job queue abstractions in order to specify certain invariants about how promise operations execute with a clean JavaScript execution context stack and in a certain order. However, as of the time of this writing the definition of EnqueueJob in that specification is not sufficiently flexible to integrate with HTML as a host environment. [JAVASCRIPT]
</p>

<p class="note">注記：
これは厳密には真でない。
事実、それらの~algoの多くの
“実装定義”
とされている各~節に与えられる自由度を利用して、この目的0のために それをひねくりまわすことも可能0ではある。
しかしながら、技術的には，実装定義の挙動の範囲内として是認される仕方ではあっても、結局は，本質的に~job待行列の基盤をまるごと迂回するような，遠回しでとっ散らかった回避策であふれることになる。
ここでは、この道は採らない代わりに，以下の各~下位~節に与える`故意的な違反$xを導入する。
◎
This is not strictly true. It is in fact possible, by taking liberal advantage of the many "implementation defined" sections of the algorithm, to contort it to our purposes. However, the end result is a mass of messy indirection and workarounds that essentially bypasses the job queue infrastructure entirely, albeit in a way that is technically sanctioned within the bounds of implementation-defined behaviour. We do not take this path, and instead introduce the following willful violation.
</p>

<p>
そのようなわけで、~UAは，~JS仕様~内のそれに代わって，以下に述べる定義を利用し~MUST。
これらは、~JS仕様により待加えられる~promise~jobが，~UAの`~event~loop$の中に適正に統合されることを確保する。
◎
As such, user agents must instead use the following definition in place of that in the JavaScript specification. These ensure that the promise jobs enqueued by the JavaScript specification are properly integrated into the user agent's event loops.
</p>

<p>
~UAは、~JS仕様の `RunJobs$jA 抽象演算を利用しては~MUST_NOT。
◎
The RunJobs abstract operation from the JavaScript specification must not be used by user agents.
</p>



			<section id="enqueuejob(queuename,-job,-arguments)">
<h5>8.1.3.7.1. `EnqueueJob^jA(%queueName , %job , %arguments )</h5>

<p class="algo-head">
~JS仕様の `EnqueueJob$jA 抽象演算を~callすると記されている所では、それに代わって，次の~algoが利用され~MUST：
◎
When the JavaScript specification says to call the EnqueueJob abstract operation, the following algorithm must be used in place of JavaScript's EnqueueJob:
</p>


<ol>
	<li>
~Assert：
%queueName ~EQ `PromiseJobs^l
（ ~UAは、 `ScriptJobs^l を利用してはならない）
◎
Assert: queueName is "PromiseJobs". ("ScriptJobs" must not be used by user agents.)
</li>
	<li>
%設定群 ~LET %job . `Realm^sl の`設定群~obj$1
◎
Let settings be the settings object of job.[[Realm]].
</li>
	<li>
<p>
%設定群 の`担当の~event~loop$上に，次の手続きを遂行する`極小taskを待入する$：
◎
Queue a microtask, on settings's responsible event loop, to perform the following steps:
</p>

		<ol>
			<li>
~IF［
%設定群 を用いて`~scriptは走れるかどうか検査-$した結果 ~EQ `走るな^i 
］
⇒
~RET
◎
Check if we can run script with settings. If this returns "do not run" then abort these steps.
</li>
			<li>
%設定群 を用いて，`~scriptを走らすために準備する$
◎
Prepare to run script with settings.
</li>
			<li>
%結果 ~LET %arguments を引数たちに用いて
%job により指定される抽象演算を遂行した結果
◎
Let result be the result of performing the abstract operation specified by job, using the elements of arguments as its arguments.
</li>
			<li>
%設定群 を用いて，`走らせた~scriptを片付ける$
◎
Clean up after running script with settings.
</li>
			<li>
~IF［
%結果 は中途完了である
］
⇒
%結果 . `Value^sl で与えられる例外を報告する
◎
If result is an abrupt completion, report the exception given by result.[[Value]].
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>

		<section id="integration-with-the-javascript-module-system">
<h4 title="Integration with the JavaScript module system">8.1.3.8 ~JS~module~systemとの統合</h4>



<p>
~JS仕様は、~moduleのための構文, および
その処理~modelにおける ~hostに非依存な部分を定義する。
この仕様は、その処理~modelの残りの部分
— ~module~systemが［
`type$a 属性が `module^l に設定された `script$e 要素
］を介して~bootstrapされる方法，および
~moduleが［
~fetchされ, 解決され, 実行される
］方法
— を定義する。
`JAVASCRIPT$r
◎
The JavaScript specification defines a syntax for modules, as well as some host-agnostic parts of their processing model. This specification defines the rest of their processing model: how the module system is bootstrapped, via the script element with type attribute set to "module", and how modules are fetched, resolved, and executed. [JAVASCRIPT]
</p>

<p class="note">注記：
~JS仕様は，［
“script” vs. “module”
］の用語を通して記されているが、この仕様は，一般に［
`~classic~script$ vs. `~module~script$
］の用語を通して記される
— 両者とも `script$e 要素を利用するので。
◎
Although the JavaScript specification speaks in terms of "scripts" versus "modules", in general this specification speaks in terms of classic scripts versus module scripts, since both of them use the script element.
</p>

<div class="p">
<p>
`~module~map@
とは、`絶対~URL$xから［
次のいずれかとして与えられる値
］への~mapである。
</p>

<ul ><li>`~module~script$
</li><li>~NULL
</li><li>placeholder 値である， `fetching^l
`後で前 2 項のいずれかの値に確定される “仮の” 値^tnote
</li></ul>

<p>
`~module~map$は、~importされた~JS~moduleが［
~fetchされ, 構文解析され, 評価される
］のは、［
`文書$／`~worker$x
］ごとに一度限りになることを確保するために利用される。
</p>
◎
A module map is a map of absolute URLs to values that are either a module script, null, or a placeholder value "fetching". Module maps are used to ensure that imported JavaScript modules are only fetched, parsed, and evaluated once per Document or worker.
</div>


<p class="algo-head">
( `~module~script$ %~script, 文字列 %指定子 )
が与えられた下で，
`~module指定子を解決-@
する手続きは、次で与えられ，［
`絶対~URL$x, `失敗^i
］のいずれかを返す：
◎
To resolve a module specifier given a module script script and a string specifier, perform the following steps. It will return either an absolute URL or failure.
</p>

<ol>
	<li>
~IF［
%指定子 を`~URL構文解析器$xにかけた結果 ~NEQ `失敗^i
］
⇒
~RET その結果
◎
Apply the URL parser to specifier. If the result is not failure, return the result.
</li>
	<li>
<p>
~IF［
%指定子 の頭部は［
`/^l, `./^l, `../^l
］のいずれにも一致しない（文字 `/^l は U+002F SOLIDUS, 文字 `.^l は U+002E FULL STOP ）
］
⇒
~RET `失敗^i
◎
If specifier does not start with the character U+002F SOLIDUS (/), the two-character sequence U+002E FULL STOP, U+002F SOLIDUS (./), or the three-character sequence U+002E FULL STOP, U+002E FULL STOP, U+002F SOLIDUS (../), return failure and abort these steps.
</p>

<p class="note">注記：
この制約は、将来に，“~~名前のみの” ~import指定子
—
<samp>import `jquery^l</samp>
や
<samp>import `web/crypto^l</samp>
の様な指定子 —
に特別な意味を与えるような，~custom~module読込器を許容できるようにするためにある。
今の所は、そのような~importは，相対~URLとして扱われることなく失敗することになる。
◎
This restriction is in place so that in the future we can allow custom module loaders to give special meaning to "bare" import specifiers, like import "jquery" or import "web/crypto". For now any such imports will fail, instead of being treated as relative URLs.
</p>

	</li>
	<li>
~RET ［
基底~URL： %~script の`基底~URL$
］の下で
%指定子 を`~URL構文解析器$xにかけた結果
◎
Return the result of applying the URL parser to specifier with script's base URL as the base URL.
</li>

</ol>

			<section id="hostresolveimportedmodule(referencingmodule,-specifier)">
<h5>8.1.3.8.1 `HostResolveImportedModule^jA(%referencingModule , %specifier)</h5>

<p class="algo-head">
~JS `JAVASCRIPT$r は、その抽象演算
`HostResolveImportedModule$jA( %参照元~module , %指定子 )
を，実装定義であると~~規定している。
~UAは、次の実装を利用し~MUST：
◎
JavaScript contains an implementation-defined HostResolveImportedModule abstract operation. User agents must use the following implementation: [JAVASCRIPT]
</p>

<ol>
	<li>
%参照元~module~script ~LET %参照元~module . `HostDefined^sl
◎
Let referencing module script be referencingModule.[[HostDefined]].
</li>
	<li>
%~module~map ~LET
%参照元~module~script の`設定群~obj$の`~module~map$
◎
Let module map be referencing module script's settings object's module map.
</li>
	<li>
%~url ~LET
( %参照元~module~script, %指定子 )
を与える下で，`~module指定子を解決-$した結果
◎
Let url be the result of resolving a module specifier given referencing module script and specifier. If the result is failure, throw a TypeError exception and abort these steps.
</li>
			<li>
~IF［
%~url ~EQ `失敗^i
］
⇒
~THROW `TypeError$js
◎
↑</li>
	<li>
~IF［
%~module~map 内に［
~key ~EQ %~url
］なる~entryはある
］
⇒
%解決済~module~script ~LET その~entry
◎
Let resolved module script be the value of the entry in module map whose key is url. If no such entry exists, or if the value is null or "fetching", throw a TypeError exception and abort these steps.
</li>
	<li>
~ELSE
⇒
~THROW `TypeError$js
◎
↑</li>
	<li>
~IF［
%解決済~module~script の値 ~IN { ~NULL, `fetching^l }
］
⇒
~THROW `TypeError$js
◎
↑</li>
	<li>
~RET
%解決済~module~script の`~module~record$
◎
Return resolved module script's module record.
</li>

</ol>


			</section>
		</section>
		<section id="runtime-script-errors">
<h4 title="Runtime script errors">8.1.3.9. 実行時~script~error</h4>

<div class="p">
<p class="algo-head">
~UAは、次が与えられた下で，
`~errorを報告する@
よう要求されたときは：
</p>

<ul>
	<li>
`~script$： %~script
</li>
	<li>
問題箇所： ( %行番号, %列番号 )
</li>
	<li>
`大域~obj$： %標的
</li>
</ul>

<p>
以下を走らせ~MUST。
この手続きは、その結果として，~errorの
`取扱済み~flag@err
を ~ON にし得る
— 各~errorには，この~flagが結付けられ、初期~時は ~OFF （すなわち，~errorは
`取扱済みでない@err
）にされる。
</p>

◎
When the user agent is required to report an error for a particular script script with a particular position line:col, using a particular target target, it must run these steps, after which the error is either handled or not handled:
</div>


<ol>
	<li>
~IF［
%標的 は`~error報告~mode下$にある
］
⇒
~RET
<!-- 
~errorの取扱済み~flag$err ~SET ~OFF；<br>
 -->
◎
If target is in error reporting mode, then abort these steps; the error is not handled.
</li>
	<li>
%標的 を
`~error報告~mode下@
におく
◎
Let target be in error reporting mode.
</li>
	<li>
%~message ~LET 
~errorについて役立つ~~情報を述べるような，~UAにより定義される文字列
~FINGERPRINTING
◎
Let message be a user-agent-defined string describing the error in a helpful manner.
(This is a fingerprinting vector.)
</li>
	<li>
<p>
%~error~obj ~LET 次の様な，~errorを表現する~obj：
</p>

		<ul>
			<li>
~catchされなかった例外の事例では、投出された~objになるであろう。
</li>
			<li>
~JS~errorの事例では、 `Error$I ~objになるであろう。
対応する~objがない場合、代わりに ~NULL値が利用され~MUST。
</li>
		</ul>
◎
Let error object be the object that represents the error: in the case of an uncaught exception, that would be the object that was thrown; in the case of a JavaScript error that would be an Error object. If there is no corresponding object, then the null value must be used instead.
</li>
	<li>
<p>
%所在 ~LET
%~script が得られた資源に対応する`絶対~URL$x
◎
Let location be an absolute URL that corresponds to the resource from which script was obtained.
</p>

<p class="note">注記：
~scriptを包含している資源は、概して，例えば［
~inline `script$e 要素 ／
`~event~handler内容~属性$
］に対しては，構文解析した`文書$の~fileになり、外部~scriptに対しては，それを含んでいる~JS~fileになる。
動的に生成される~scriptに対するときでも、~UAには，~scriptの元の~sourceを保ち続けるよう試みることが強く奨励される。
例えば、 HTML の構文解析-時に，外部~scriptが `document.write()$m ~APIを利用して~inline `script$e 要素を挿入した場合、当の~scriptとして［
その~scriptを包含している資源の~URL
］が報告され，行番号として［
`document.write()$m ~callの所, あるいは
その~callに渡された文字列が最初に構築された所
］の行0が報告されるのが、理想的になる。
当然、これを実装するには，自明でない部分もある。
◎
The resource containing the script will typically be the file from which the Document was parsed, e.g. for inline script elements or event handler content attributes; or the JavaScript file that the script was in, for external scripts. Even for dynamically-generated scripts, user agents are strongly encouraged to attempt to keep track of the original source of a script. For example, if an external script uses the document.write() API to insert an inline script element during parsing, the URL of the resource containing the script would ideally be reported as being the external script, and the line number might ideally be reported as the line with the document.write() call or where the string passed to that call was first constructed. Naturally, implementing this can be somewhat non-trivial.
</p>

<p class="note">注記：
同様に，~UAには、文書が構文解析されるに伴い文書を変異させるような
`document.write()$m ~callや，複数~行0にまたがっている`~event~handler内容~属性$に直面したとしても、元の行番号を保ち続けることが奨励される。
◎
User agents are similarly encouraged to keep careful track of the original line numbers, even in the face of document.write() calls mutating the document as it is parsed, or event handler content attributes spanning multiple lines.
</p>
	</li>

	<li>
<p>
~IF［
%~script の`黙秘error~flag$ ~EQ ~ON
］：
</p>
		<ol>
			<li>
%~message ~SET `Script error.^l
</li>
			<li>
%所在 ~SET 空~文字列
</li>
			<li>
%行番号 ~SET 0
</li>
			<li>
%列番号 ~SET 0
</li>
			<li>
%~error~obj ~SET ~NULL
</li>
		</ol>
◎
If script has muted errors, then set message to "Script error.", set location to the empty string, set line and col to 0, and set error object to null.
</li>
	<li>
<p>
%~event ~LET 次のようにされた新たな `ErrorEvent$I ~obj：
</p>

<ul ><li>`~trusted$
</li><li>浮上しない
</li><li>取消可能
</li><li>~event名 `error$et
</li></ul>

◎
Let event be a new trusted ErrorEvent object that does not bubble but is cancelable, and which has the event name error.
</li>
	<li>
<p>
%~eventの各種~属性を次のように初期化する：
</p>

		<ul>
			<li>
`message$m ~SET %~message
◎
Initialise event's message attribute to message.
</li>
			<li>
`filename$m ~SET %所在
◎
Initialise event's filename attribute to location.
</li>
			<li>
`lineno$m ~SET %行番号
◎
Initialise event's lineno attribute to line.
</li>
			<li>
`colno$m ~SET %列番号
◎
Initialise event's colno attribute to col.
</li>
			<li>
`error$m ~SET %~error~obj
◎
Initialise event's error attribute to error object.
</li>
		</ul>
	</li>
	<li>
%標的 に向けて %~event を`配送する$x
◎
Dispatch event at target.
</li>
	<li>
%標的 を`~error報告~mode下$から外す
◎
Let target no longer be in error reporting mode.
</li>
	<li>
~IF［
%~event は取消された
］
⇒
~errorの`取扱済み~flag$err ~SET ~ON
◎
If event was canceled, then the error is handled. Otherwise, the error is not handled.
</li>
</ol>

<p class="note">注記：
~event~handlerが ~T を返した場合、`~event~handler処理~algo$に従って， %~event は取消されることになる。
◎
Returning true cancels event per the event handler processing algorithm.
</p>


			<section id="runtime-script-errors-in-documents">
<h5 title="Runtime script errors in documents">8.1.3.9.1. 文書における実行時~script~error</h5>


<div class="p">
<p class="algo-head">
~UAは、所与の
( `~script$ %~script, 例外 %E )
に対し，
`例外を報告する@
ときは、次を走らせ~MUST：
</p>

<ol>
	<li>
<p>
次を与える下で，その`~errorを報告する$：
</p>

		<ul>
			<li>
~script： %~script
</li>
			<li>
問題箇所： %~script を包含している資源~内の問題箇所 ( 行番号, 列番号 )
</li>
			<li>
標的： %~script の`設定群~obj$の`大域~obj$0
</li>
		</ul>

	</li>
	<li>
~IF［
%E の`取扱済み~flag$err ~EQ ~OFF
］
⇒
任意選択で、 %E を~UAの開発者~consoleに報告する
</li>
</ol>

◎
When the user agent is to report an exception E, the user agent must report the error for the relevant script, with the problematic position (line number and column number) in the resource containing the script, using the global object specified by the script's settings object as the target. If the error is still not handled after this, then the error may be reported to a developer console.
</div>


			</section>
			<section id="the-errorevent-interface">
<h5 title="The ErrorEvent interface">8.1.3.9.2. `ErrorEvent^I ~interface</h5>


⇒！
[Constructor(DOMString type, optional `ErrorEventInit$I %eventInitDict),
Exposed=(Window,Worker)]
interface `ErrorEvent@I : `Event$I {
  readonly attribute DOMString `message$m;
  readonly attribute DOMString `filename$m;
  readonly attribute unsigned long `lineno$m;
  readonly attribute unsigned long `colno$m;
  readonly attribute any `error$m;
};

dictionary `ErrorEventInit@I : `EventInit$I {
  DOMString %message = "";
  DOMString %filename = "";
  unsigned long %lineno = 0;
  unsigned long %colno = 0;
  any %error = null;
};
◎


<p>
`message@m
属性は、初期化-時の値を返さ~MUST。
これは、~error~messageを表現する。
◎
The message attribute must return the value it was initialised to. It represents the error message.
</p>

<p>
`filename@m
属性は、初期化-時の値を返さ~MUST。
これは、~scriptにおいて~errorが元々生じた所の`絶対~URL$xを表現する。
◎
The filename attribute must return the value it was initialised to. It represents the absolute URL of the script in which the error originally occurred.
</p>


<p>
`lineno@m
属性は、初期化-時の値を返さ~MUST。
これは、~scriptにおいて~errorが元々生じた所の行番号を表現する。
◎
The lineno attribute must return the value it was initialised to. It represents the line number where the error occurred in the script.
</p>


<p>
`colno@m
属性は、初期化-時の値を返さ~MUST。
これは、~scriptにおいて~errorが元々生じた所の列番号を表現する。
◎
The colno attribute must return the value it was initialised to. It represents the column number where the error occurred in the script.
</p>


<p>
`error@m
属性は、初期化-時の値を返さ~MUST。
適切になる所では、これは，~errorを表現している~objに設定される（例：
~catchされなかった DOM 例外の事例では、例外~objになる）。
◎
The error attribute must return the value it was initialised to. Where appropriate, it is set to the object representing the error (e.g., the exception object in the case of an uncaught DOM exception).
</p>


			</section>
		</section>
		<section id="unhandled-promise-rejections">
<h4 title="Unhandled promise rejections">8.1.3.10. 未取扱いの~promise却下</h4>


<p>
同期的な`実行時~script~error$に加えて、~scriptは，非同期的な~promise却下に出くわすこともある
— それは、［
`unhandledrejection$et, `rejectionhandled$et
］~eventを介して追跡される。
◎
In addition to synchronous runtime script errors, scripts may experience asynchronous promise rejections, tracked via the unhandledrejection and rejectionhandled events.
</p>


<p class="algo-head">
( `環境~設定群~obj$ %設定群~obj )
が与えられた下で，
`却下済み~promiseについて通知-@
するときは、次を走らせ~MUST：
◎
When the user agent is to notify about rejected promises on a given environment settings object settings object, it must run these steps:
</p>


<ol>
	<li>
%~list ~LET
%設定群~obj の`通知待ちの却下済み~promise~list$の複製
◎
Let list be a copy of settings object's about-to-be-notified rejected promises list.
</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET
◎
If list is empty, abort these steps.
</li>
	<li>
%設定群~obj の`通知待ちの却下済み~promise~list$を~~空にする
◎
Clear settings object's about-to-be-notified rejected promises list.
</li>
	<li>
<p>
次の下位手続きを走らす`~taskを待入する$：
◎
Queue a task to run the following substep:
</p>


		<ol>
			<li>
<p>
~FOR
%~list 内の~EACH ( ~promise  %p ) に対し：
◎
For each promise p in list:
</p>


				<ol>
					<li>
~IF［
%p の `PromiseIsHandled^sl 内部slot ~EQ ~T
］
⇒
~CONTINUE
◎
If p's [[PromiseIsHandled]] internal slot is true, continue to the next iteration of the loop.
</li>
					<li>
<p>
%~event ~LET 次のようにされた新たな~event：
</p>
<ul ><li>`PromiseRejectionEvent$I ~interfaceを利用する
</li><li>`~trusted$
</li><li>浮上しない
</li><li>取消可能
</li><li>~event名 `unhandledrejection$et
</li></ul>
◎
Let event be a new trusted PromiseRejectionEvent object that does not bubble but is cancelable, and which has the event name unhandledrejection.
</li>
					<li>
%~eventの `promise$m 属性 ~SET %p に初期化する
◎
Initialise event's promise attribute to p.
</li>
					<li>
%~eventの `reason$m 属性 ~SET
%p の `PromiseResult^sl 内部slotの値に初期化する
◎
Initialise event's reason attribute to the value of p's [[PromiseResult]] internal slot.
</li>
					<li>
%設定群~objの`大域~obj$0に向けて %~event を`配送する$x
◎
Dispatch event at settings object's global object.
</li>
					<li>
~IF［
~eventは取消された
］
⇒
この~promise却下の`取扱済み~flag$rej ~SET ~ON
◎
If the event was canceled, then the promise rejection is handled. Otherwise, the promise rejection is not handled.
</li>
					<li>
~IF［
%p の `PromiseIsHandled^sl 内部slot ~EQ ~F
］
⇒
%設定群~objの`未決の却下済み~promiseへの弱参照~集合$に %p を追加する
◎
If p's [[PromiseIsHandled]] internal slot is false, add p to settings object's outstanding rejected promises weak set.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>


<p>
この~algoは，~promise却下の
`取扱済み~flag@rej
を ~ON にし得る
— 各~promise却下には，この~flagが結付けられ、初期~時は ~OFF （すなわち，~promise却下は
`取扱済みでない@rej
）にされる。
これは、~script~errorに対する`取扱済み~flag$errと並行する概念である。
この~algoの結果、却下の`取扱済み~flag$rejが依然として ~OFF ならば、その却下は，~UAの開発者~consoleに報告されてよい。
◎
This algorithm results in promise rejections being marked as handled or not handled. These concepts parallel handled and not handled script errors. If a rejection is still not handled after this, then the rejection may be reported to a developer console.
</p>



			<section id="the-hostpromiserejectiontracker-implementation">
<h5 title="HostPromiseRejectionTracker(promise, operation)">8.1.3.10.1. `HostPromiseRejectionTracker^jA (%promise, %operation)</h5>


<p class="algo-head">
~JS `JAVASCRIPT$r は、その抽象演算
`HostPromiseRejectionTracker$jA( %promise, %演算 )
を，実装定義であると~~規定している。
~UAは、次の実装を利用し~MUST：
◎
JavaScript contains an implementation-defined HostPromiseRejectionTracker(promise, operation) abstract operation. User agents must use the following implementation: [JAVASCRIPT]
</p>


<ol>
	<li>
<p>
%~script ~LET `走中の~script$
◎
Let script be the running script.
</li>
	<li>
~IF［
%~script の`黙秘error~flag$ ~EQ ~ON
］
⇒
~RET
◎
If script has muted errors, terminate these steps.
</li>
	<li>
%設定群~obj ~LET %~scriptの`設定群~obj$
◎
Let settings object be script's settings object.
</li>
	<li>
<p>
~IF［
%演算 ~EQ `reject^l
］
⇒
%設定群~objの`通知待ちの却下済み~promise~list$に %promise を追加する
◎
If operation is "reject",
◎
	Add promise to settings object's about-to-be-notified rejected promises list.
</li>
	<li>
<p>
~ELIF［
%演算 ~EQ `handle^l
］：
◎
If operation is "handle",
</p>
		<ol>
			<li>
~IF［
%promise ~IN %設定群~objの`通知待ちの却下済み~promise~list$
］
⇒
その~listから %promise を除去する；<br>
~RET
◎
If settings object's about-to-be-notified rejected promises list contains promise, remove promise from that list and abort these steps.
</li>
			<li>
~IF［
%promise ~NIN %設定群~objの`未決の却下済み~promiseへの弱参照~集合$
］
⇒
~RET
◎
If settings object's outstanding rejected promises weak set does not contain promise, abort these steps.
</li>
			<li>
%設定群~objの`未決の却下済み~promiseへの弱参照~集合$から
%promise を除去する
◎
Remove promise from settings object's outstanding rejected promises weak set.
</li>
			<li>
<p>
次の下位手続きを走らす`~taskを待入する$：
◎
Queue a task to run the following steps:
</p>
				<ol>
					<li>
<p>
%~event ~LET 次のようにされた新たな~event：
</p>
<ul ><li>`PromiseRejectionEvent$I ~interfaceを利用する
</li><li>`~trusted$
</li><li>浮上しない
</li><li>取消不可
</li><li>~event名 `rejectionhandled$et
</li></ul>

◎
Let event be a new trusted PromiseRejectionEvent object that does not bubble and is not cancelable, and which has the event name rejectionhandled.
</li>
					<li>
%~eventの`promise$m
属性 ~SET %promise に初期化する
◎
Initialise event's promise attribute to promise.
</li>
					<li>
%~event の `reason$m 属性 ~SET
%promise の `PromiseResult^sl 内部slotの値に初期化する
◎
Initialise event's reason attribute to the value of promise's [[PromiseResult]] internal slot.
</li>
					<li>
%設定群~obj の`大域~obj$0に向けて
%~event を`配送する$x
◎
Dispatch event at settings object's global object.
</li>
				</ol>
			</li>
		</ol>
   </li>
</ol>


			</section>
			<section id="the-promiserejectionevent-interface">
<h5 title="The PromiseRejectionEvent interface">8.1.3.10.2. `PromiseRejectionEvent^I ~interface</h5>


⇒！
[Constructor(DOMString type, `PromiseRejectionEventInit$I %eventInitDict),
Exposed=(Window,Worker)]
interface `PromiseRejectionEvent@I : `Event$I {
  readonly attribute Promise&lt;any&gt; `promise$m;
  readonly attribute any `reason$m;
};

dictionary `PromiseRejectionEventInit@I : `EventInit$I {
  required Promise&lt;any&gt; %promise;
  any %reason;
};
◎


<p>
`promise@m
属性は、初期化-時の値を返さ~MUST。
これは、この通知が~~対象にしている~promiseを表現する。
◎
The promise attribute must return the value it was initialised to. It represents the promise which this notification is about.
</p>


<p>
`reason@m
属性は、初期化-時の値を返さ~MUST。
これは、~promiseの却下~事由を表現する。
◎
The reason attribute must return the value it was initialised to. It represents the rejection reason for the promise.
</p>



			</section>
		</section>
		<section id="hostensurecancompilestrings(callerrealm,-calleerealm)">
<h5>8.1.3.11. `HostEnsureCanCompileStrings^A(%callerRealm, %calleeRealm)</h5>

<p class="algo-head">
~JS `JAVASCRIPT$r は、その抽象演算
`HostEnsureCanCompileStrings$jA( %callerRealm, %calleeRealm )
を，実装定義であると~~規定している。
~UAは、次の実装を利用し~MUST：
◎
JavaScript contains an implementation-defined HostEnsureCanCompileStrings(%callerRealm, %calleeRealm) abstract operation. User agents must use the following implementation: [JAVASCRIPT]
</p>

<ol>
	<li>
Perform ? `EnsureCSPDoesNotBlockStringCompilation$jA( %callerRealm, %calleeRealm)
`CSP$r
◎
Perform ? EnsureCSPDoesNotBlockStringCompilation(%callerRealm, %calleeRealm). [CSP]
</li>
</ol>



  		</section>
	</section>
	<section id="event-loops">
<h3 title="Event loops">8.1.4. ~event~loop</h3> 


		<section id="definitions-3">
<h4 title="Definitions">8.1.4.1. 各種~定義</h4>


<div class="p">
<p>
~UAは、この節に述べる
`~event~loop@
を利用して，［
~event, 利用者対話, ~script, 描画, ~networking, 等々
］を互いに協調させ~MUST。
~event~loopには、次の 2 種類がある：
</p>

<dl class="def-list">
	<dt>`閲覧文脈~event~loop@</dt>
	<dd>
`閲覧文脈$xに対するもの。
</dd>

	<dt>`~worker~event~loop@</dt>
	<dd>
`~worker$xに対するもの（すなわち，
`WorkerGlobalScope$I に対し走中の
<a href="~WORKERS#worker-event-loop">~event~loop</a>
）
</dd>
</dl>

◎
To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. There are two kinds of event loops: those for browsing contexts, and those for workers.
</div>

<div>
<p>
`閲覧文脈~event~loop$は：
</p>

<ul>
	<li>
~UAごとに，一つ以上~MUST。
</li>
	<li>
各［
`互関係かつ類似生成元の閲覧文脈~群$x
］ごとに，一つ以下で~MUST。
</li>
</ul>

◎
There must be at least one browsing context event loop per user agent, and at most one per unit of related similar-origin browsing contexts.
</div>

<p class="note">注記：
［
`互関係~閲覧文脈~群$x
］ %U に対し，`~event~loop$が二つ以上あるとすると、［
%U 内のある［
`互関係かつ類似生成元の閲覧文脈~群$x
］から，
%U 内の別の［
それ
］へ切替える
］ように`閲覧文脈$xが`~navigate$xされたときに、複雑問題が発生する。
この仕様は、現時点では，この複雑問題をどう取扱うかは述べていない。
◎
When there is more than one event loop for a unit of related browsing contexts, complications arise when a browsing context in that group is navigated such that it switches from one unit of related similar-origin browsing contexts to another. This specification does not currently describe how to handle these complications.
</p>

<p>
`閲覧文脈~event~loop$は、常に，一つ以上の`閲覧文脈$xに属する
— そのような`閲覧文脈$xすべてが消去ると同時に，`~event~loop$も消去る。
`閲覧文脈$xは、常に，その活動に協調している`~event~loop$を持つ。
◎
A browsing context event loop always has at least one browsing context. If such an event loop's browsing contexts all go away, then the event loop goes away as well. A browsing context always has an event loop coordinating its activities.
</p>


<p>
`~worker~event~loop$は，より単純であり、各~workerごとに，一つの`~event~loop$を持つ。
`~worker処理~model$xが、その`~event~loop$の存続期間を管理する。
◎
Worker event loops are simpler: each worker has one event loop, and the worker processing model manages the event loop's lifetime.
</p>


<hr>

<p>
`~event~loop$は
一つ以上の
`~task待行列@
を持つ。
`~task待行列$は何個かの
`~task@
からなる有順序~listである。
その各~taskは、次に挙げるような仕事の責を負う~algoである：
◎
An event loop has one or more task queues. A task queue is an ordered list of tasks, which are algorithms that are responsible for such work as:
</p>


<dl>
	<dt>
~eventの配送-
◎
Events
</dt>
	<dd>
特定0の `EventTarget$I ~objに向けて `Event$I ~objを`配送する$xときは、専用の~taskで行われることが多い。
◎
Dispatching an Event object at a particular EventTarget object is often done by a dedicated task.
</dd>
	<dd class="note">注記：
すべての~eventが`~task待行列$を利用して配送されるわけではない。
他の~taskの中で配送されるものも多々ある。
◎
Not all events are dispatched using the task queue, many are dispatched during other tasks.
</dd>

	<dt>
構文解析処理
◎
Parsing
</dt>
	<dd>
`HTML 構文解析器$xにより，~byte列を~token化して結果の~token列を処理することは、概して~taskになる。
◎
The HTML parser tokenizing one or more bytes, and then processing any resulting tokens, is typically a task.
</dd>

	<dt>
~callback
◎
Callbacks
</dt>
	<dd>
~callbackに対する~callは、専用の~taskで行われることが多い。
◎
Calling a callback is often done by a dedicated task.
</dd>

	<dt>
資源の利用
◎
Using a resource
</dt>
	<dd>
ある~algoが，他を阻むことなく資源を`~fetchする$x場合、［
資源の一部または~~全部が可用になったときの資源の処理
］は，何らかの~taskにより遂行される。
◎
When an algorithm fetches a resource, if the fetching occurs in a non-blocking fashion then the processing of the resource once some or all of the resource is available is performed by a task.
</dd>

	<dt>
DOM 操作に対する反応
◎
Reacting to DOM manipulation
</dt>
	<dd>
一部の要素は、要素が`文書の中へ挿入-$xされるときなど， DOM 操作に呼応して誘発されるような~taskを有する。
◎
Some elements have tasks that trigger in response to DOM manipulation, e.g. when that element is inserted into the document.
</dd>
</dl>

<div >
<p>
`閲覧文脈~event~loop$内の各`~task$には、`文書$が結付けられる
— それは、~taskに応じて次で与えられる文書になる：
</p>

<dl class="switch">
	<dt>~taskは 要素の文脈において待入されたものである場合</dt>
	<dd>
要素の`~node文書$x。
</dd>

	<dt>~taskは `閲覧文脈$xの文脈において待入されたものである場合</dt>
	<dd>
待入された時点での，`閲覧文脈$xの`作動中の文書$x。
</dd>

	<dt>~taskは `~script$［ により／に対し ］待入されたものである場合</dt>
	<dd>
~scriptの`設定群~obj$により指定される`担当の文書$。
</dd>

</dl>

◎
Each task in a browsing context event loop is associated with a Document; if the task was queued in the context of an element, then it is the element's node document; if the task was queued in the context of a browsing context, then it is the browsing context's active document at the time the task was queued; if the task was queued by or for a script then the document is the responsible document specified by the script's settings object.
</div>


<p>
`~task$は、特定の`~event~loop$向けに意図される。
それは、`~task$に結付けられている［
`文書$ ／ `~worker$x
］に対し，`~task$を取扱っている`~event~loop$である。
◎
A task is intended for a specific event loop: the event loop that is handling tasks for the task's associated Document or worker.
</p>


<p class="algo-head">
~UAは、
( ~task %~task )
が与えられた下で，
`待入する@
ときは
⇒
%~task を，関連する`~event~loop$のいずれかの`~task待行列$に追加し~MUST。
◎
When a user agent is to queue a task, it must add the given task to one of the task queues of the relevant event loop.
</p>


<p>
どの`~task$も，特定の
`~task源@
から来るものとして定義される。
［
特定0の`~task源$からの，特定0の`~event~loop$を行先にする
］ような，すべての~taskは、常に同じ`~task待行列$に追加され~MUST（例：
`文書$の~timerにより生成される各~callback ／
`文書$上での~mouse移動により発火される各~event ／
`文書$の構文解析器により待入される各~task）。
一方で、異なる`~task源$からの`~task$は，異なる`~task待行列$に入れられてよい。
◎
Each task is defined as coming from a specific task source. All the tasks from one particular task source and destined to a particular event loop (e.g. the callbacks generated by timers of a Document, the events fired for mouse movements over that Document, the tasks queued for the parser of that Document) must always be added to the same task queue, but tasks from different task sources may be placed in different task queues.
</p>


<p class="example">
例えば~UAは、［
~mouse／~key
］~eventのためとして，一つの`~task待行列$（ `利用者対話~task源$ ）を有し、他のすべてに対しては，別のものをあてがうこともできる。
その上で，~UAは、~interfaceの応答性を保ちつつ,
他の~task待行列も放置しないよう，［
~keyboard／~mouse
］~eventに時間の半分以上をあてがいつつ, 残りを他の~taskにあてがうこともできる
— どの`~task源$に対しても，その中の各~eventは必ず順序通りに処理しつつ。
◎
For example, a user agent could have one task queue for mouse and key events (the user interaction task source), and another for everything else. The user agent could then give keyboard and mouse events preference over other tasks three quarters of the time, keeping the interface responsive but not starving other task queues, and never processing events from any one task source out of order.
</p>


<p>
各`~event~loop$は、
`現在~走中の~task@
（初期~時は ~NULL ）を持つ。
これは、再入性を取扱うために利用される。
各`~event~loop$は、
`極小task~checkpoint遂行-中~flag@
（初期~時は ~OFF ）も持つ。
これは、`極小task~checkpointを遂行する$~algoが再入的に呼出されるのを防止するために利用される。
◎
Each event loop has a currently running task. Initially, this is null. It is used to handle reentrancy. Each event loop also has a performing a microtask checkpoint flag, which must initially be false. It is used to prevent reentrant invocation of the perform a microtask checkpoint algorithm.
</p>



		</section>
		<section id="event-loop-processing-model">
<h4 title="Processing model">8.1.4.2. 処理~model</h4> 


<p class="algo-head">
`~event~loop$ %~loop は、次の手続きを断続的に走らせ続け~MUST：
◎
An event loop must continually run through the following steps for as long as it exists:
</p>


<ol>
	<li id="step1">
<p>
%~task ~LET 次を満たすように選ばれる`~task$
</p>

		<ul>
			<li>
%~task は、 %~loop に属する ある`~task待行列$ %待行列 に属する
— ~UAはどの`~task待行列$を~~選んでもよい。
</li>
			<li>
%~loop は`閲覧文脈~event~loop$であるならば、
%~task に結付けらている`文書$は`全部的に作動中$xである。
</li>
			<li>
%~task は、上述に該当する~taskのうち，%待行列 内で最も遠過去のもの。
</li>
</ul>

◎
Select the oldest task on one of the event loop's task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the microtasks step below.
</li>
	<li>
<p>
~IF［
該当する %~task はある
］：
◎
↑</p>
		<ol>
			<li>
%~loop の`現在~走中の~task$ ~SET %~task
◎
Set the event loop's currently running task to the task selected in the previous step.
</li>
			<li>
<!-- ＊Run： -->
%~task を走らす
◎
Run: Run the selected task.
</li>
			<li>
%~loop の`現在~走中の~task$ ~SET ~NULL
◎
Set the event loop's currently running task back to null.
</li>
			<li>
%~task を %待行列 から除去する
◎
Remove the task that was run in the run step above from its task queue.
</li>
		</ol>
	</li>
	<li>
<!-- ＊Microtasks：-->
`極小task~checkpointを遂行する$
◎
Microtasks: Perform a microtask checkpoint.
</li>
	<li>
<p>
~IF［
%~loop は`閲覧文脈~event~loop$である
］
⇒
以下に従って`描画を更新する^i：
◎
Update the rendering: If this event loop is a browsing context event loop (as opposed to a worker event loop), then run the following substeps.
</p>


		<ol>
			<li>
%now ~LET
`Performance$I ~objの `now()$m ~methodから返される値
`HRT$r
◎
Let now be the value that would be returned by the Performance object's now() method. [HRT]
</li>
			<li>
<p>
%文書s ~LET
%~loop に結付けられている`文書$の~list
— それらの順序は、次の条件を満たさ~MUST（条件~以外は任意）
⇒
~list内のどの二つの`文書$ %A, %B に対しても：
◎
Let docs be the list of Document objects associated with the event loop in question, sorted arbitrarily except that the following conditions must be met:
</p>

				<ul>
					<li>
%B が %A を`通して入子に$xされているならば、
%B は %A の後に~listされ~MUST。
<!-- 
<span>nested through</span>
-->
◎
Any Document B that is nested through a Document A must be listed after A in the list.
</li>
					<li>
［
%A, %B が`属する閲覧文脈$xは，いずれも`入子の閲覧文脈$xである
］, かつ［
%A, %B の`閲覧文脈~容器$x %A1, %B1 （同順）はいずれも同じある`文書$ %C 内の要素である
］ならば、［
~listにおける %A, %B の順序
］は，［
%C における`木~順序$xによる %A1, %B1 の順序
］に合致し~MUST
◎
If there are two documents A and B whose browsing contexts are both nested browsing contexts and their browsing context containers are both elements in the same Document C, then the order of A and B in the list must match the relative tree order of their respective browsing context containers in C.
</li>

				</ul>

<p>
以下において %文書s 内の ~EACH ( `文書$ ) にわたって反復する手続きでは、~list順に処理され~MUST。
◎
In the steps below that iterate over docs, each Document must be processed in the order it is found in the list.
</p>
			</li>
			<li>
<p>
%文書s 内の`文書$のうち，［
それが`属する閲覧文脈$x %B が，次のいずれかに該当するもの
］すべてを %文書s から除去する：
◎
↓</p>

				<ul>
					<li>
<p>
%B の`~top-level閲覧文脈$xは、この時点で描画を更新しても益はないと見込まれる。
◎
If there are top-level browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context's top-level browsing context is in B.
</p>

<div class="note">
<p>注記：
`~top-level閲覧文脈$xの描画を更新しても益はないかどうかは、更新~頻度など，種々の要因に依存する。
例えば~browserは、更新率 60Hz を達成しようと試みている場合、この手続きは、毎 1/60 秒（およそ 16.7ms ）ごとのみに必要とされる。
~browserは、`~top-level閲覧文脈$xはこの更新率を維持0できないときは，その`文書$の集合に対しては，~frameを時々落とすのではなく，より維持0し易い 30Hz に落とすこともある。
（この仕様は、描画をいつ更新するかについて，特定0の~modelを何ら義務付けない。）
同様に、`~top-level閲覧文脈$xが背後に~~回されている場合、~UAは，その頁をずっと遅い 4Hz あるいは，もっと落とすよう決めることもある。
◎
Whether a top-level browsing context would benefit from having its rendering updated depends on various factors, such as the update frequency. For example, if the browser is attempting to achieve a 60Hz refresh rate, then these steps are only necessary every 60th of a second (about 16.7ms). If the browser finds that a top-level browsing context is not able to sustain this rate, it might drop to a more sustainable 30Hz for that set of Documents, rather than occasionally dropping frames. (This specification does not mandate any particular model for when to update the rendering.) Similarly, if a top-level browsing context is in the background, the user agent might decide to drop that page to a much slower 4Hz, or even less.
</p>

<p>
~browserが描画の更新を飛ばす他の~~理由として、ある種の`~task$たちを~~連続して実行して，間に差挟まれるのは`極小task~checkpointを遂行する$ことにのみになることを確保することが挙げられる（例えば，`~animation~frame~callbackたちを走らす$こともなく）。 
例えば~UAは、描画の更新を挟まずに，複数の~timer~callbackを結合したいと望むかもしれない。
◎
Another example of why a browser might skip updating the rendering is to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). For example, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates.
</p>
</div>
					</li>
					<li>
<p>
%B は、`入子の閲覧文脈$xであって，この時点で描画を更新しても益はないと見込まれる。
◎
If there are a nested browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context is in B.
</p>

<p class="note">注記：
`~top-level閲覧文脈$xと同様、`入子の閲覧文脈$xの描画を更新しても益はないかどうかは、種々の要因に依存する。
例えば，~UAは、第三者主体の内容の描画に費やす資源を減らしたいと望むかもしれない
— とりわけ利用者から現在~可視でない, あるいは資源が拘束されている下では。
その場合、~browserは，その種の内容に対する描画の更新を，頻度を落とすか やめるよう決めることもある。
◎
As with top-level browsing contexts, a variety of factors can influence whether it is profitable for a browser to update the rendering of nested browsing contexts. For example, a user agent might wish to spend less resources rendering third-party content, especially if it is not currently visible to the user or if resources are constrained. In such cases, the browser could decide to update the rendering for such content infrequently or never.
</p>
					</li>
				</ul>
			</li>
			<li>
<p >以下の各~段における %作動中~文書~list は、%文書s 内の`文書$のうち，［
当の段が実行される時点において，`全部的に作動中$xである
］ものからなる同順の~listとする：
◎
↓
</p>
				<ol>
					<li>
~FOR
%作動中~文書~list 内の ~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する`~resize手続き$xを走らす
`CSSOMVIEW$r
◎
For each fully active Document in docs, run the resize steps for that Document, passing in now as the timestamp. [CSSOMVIEW]
</li>
					<li>
~FOR
%作動中~文書~list 内の ~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する`~scroll手続き$xを走らす
`CSSOMVIEW$r
◎
For each fully active Document in docs, run the scroll steps for that Document, passing in now as the timestamp. [CSSOMVIEW]
</li>
					<li>
~FOR
%作動中~文書~list 内の ~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`媒体~queriesを評価して変化を報告する$x
`CSSOMVIEW$r
◎
For each fully active Document in docs, evaluate media queries and report changes for that Document, passing in now as the timestamp. [CSSOMVIEW]
</li>
					<li>
~FOR
%作動中~文書~list 内の ~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`CSS ~animationを走らせて~eventを送信する@
`CSSANIMATIONS$r
◎
For each fully active Document in docs, run CSS animations and send events for that Document, passing in now as the timestamp. [CSSANIMATIONS]
</li>
					<li>
<p>
~FOR
%作動中~文書~list 内の ~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`全screen描画~手続き@
を走らす
`FULLSCREEN$r
◎
For each fully active Document in docs, run the fullscreen rendering steps for that Document, passing in now as the timestamp. [FULLSCREEN]
</p>
`28001$bug
</li>
					<li>
~FOR
%作動中~文書~list 内の ~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`~animation~frame~callbackたちを走らす$
◎
For each fully active Document in docs, run the animation frame callbacks for that Document, passing in now as the timestamp.
</li>
					<li>
~FOR
%作動中~文書~list 内の ~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
<a href="https://rawgit.com/WICG/IntersectionObserver/master/index.html#run-the-update-intersection-observations-steps">update intersection observations 手続きを走らす</a>
`INTERSECTIONOBSERVER$r
◎
For each fully active Document in docs, run the update intersection observations steps for that Document, passing in now as the timestamp. [INTERSECTIONOBSERVER]
</li>
					<li>
~FOR
%作動中~文書~list 内の ~EACH( %文書 ) に対し
⇒
［
%文書, および それが`属する閲覧文脈$x
］の［
描画／利用者~interface
］を，現在の状態を反映するように更新する。
◎
For each fully active Document in docs, update the rendering or user interface of that Document and its browsing context to reflect the current state.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p >
~ELIF［
%~loop は`~worker~event~loop$である
］~AND［
%~loop 内のどの`~task待行列$も空である
］~AND［
`WorkerGlobalScope$I ~objの`~closing~flag$x  ~EQ ~ON
］：
</p>
		<ol>
			<li>
この手続きは中止した上で， %~loop を破壊する
</li>
			<li>
<a href="~WORKERS#workers">~Web~worker 節</a>
にて述べられる`~workerを走らす$x手続きを再開する
</li>
		</ol>
◎
If this is a worker event loop (i.e. one running for a WorkerGlobalScope), but there are no tasks in the event loop's task queues and the WorkerGlobalScope object's closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps described in the Web workers section below.
</li>
	<li>
~GOTO <a href="#step1">最初の段</a>
◎
Return to the first step of the event loop.
</li>
</ol>


<hr>

<p>
各`~event~loop$は、
`極小task待行列@
を有する。
`極小task@
とは、元々は，`~task待行列$ではなく，`極小task待行列$に入れられた`~task$である。
`極小task$には、
`孤立~callback極小task@,
`複合~極小task@
の 2 種類がある。
◎
Each event loop has a microtask queue. A microtask is a task that is originally to be queued on the microtask queue rather than a task queue. There are two kinds of microtasks: solitary callback microtasks, and compound microtasks.
</p>


<p class="note">注記：
この仕様は、`孤立~callback極小task$のみを定義する。
`複合~極小task$を利用する各~仕様は、`~event~loopを回す$~algoを取扱うために，`~callbackを包装する$手間をかける必要がある。
◎
This specification only has solitary callback microtasks. Specifications that use compound microtasks have to take extra care to wrap callbacks to handle spinning the event loop.
</p>


<p class="algo-head">
~algoにて
`極小taskを待入する@
ことが要求される所では、当の`極小task$を，関連する`~event~loop$の`極小task待行列$に付加し~MUST
— 
`極小task~task源@
が、そのような`極小task$の`~task源$である。
◎
When an algorithm requires a microtask to be queued, it must be appended to the relevant event loop's microtask queue; the task source of such a microtask is the microtask task source.
</p>


<p class="note">注記：
`極小task$は、定例の`~task待行列$に移動されることもある
— その初期 `初回の？^tnote 実行の間に，それが`~event~loopを回す$場合には。
その事例では、`極小task~task源$が`~task源$として利用される。
通常は、`極小task$の`~task源$は無関係である。
◎
It is possible for a microtask to be moved to a regular task queue, if, during its initial execution, it spins the event loop. In that case, the microtask task source is the task source used. Normally, the task source of a microtask is irrelevant.
</p>


<p class="algo-head">
~UAは、
`極小task~checkpointを遂行する@
ときは，次を走らせ~MUST：
◎
When a user agent is to perform a microtask checkpoint, if the performing a microtask checkpoint flag is false, then the user agent must run the following steps:
</p>


<ol>
	<li>
~IF［
`極小task~checkpoint遂行-中~flag$ ~EQ ~ON
］
⇒
~RET
◎
↑</li>
	<li>
%~loop ~LET 当の`~event~loop$
</li>
	<li>
`極小task~checkpoint遂行-中~flag$ ~SET ~ON
◎
Let the performing a microtask checkpoint flag be true.
</li>
	<li>
<p>
<!-- Microtask queue handling: -->
~WHILE［
%~loop の`極小task待行列$は空でない
］：
◎
Microtask queue handling: If the event loop's microtask queue is empty, jump to the done step below.
</p>
		<ol>
			<li>
%極小task ~LET %~loop の`極小task待行列$上の最も遠過去の`極小task$
◎
Select the oldest microtask on the event loop's microtask queue.
</li>
			<li>
%~loop の`現在~走中の~task$ ~SET
以前の段で選択された`~task$
◎
Set the event loop's currently running task to the task selected in the previous step.
</li>
			<li>
<p>
<!-- ＊Run： -->
%極小task を走らす
◎
Run: Run the selected task.
</p>

<p class="note">注記：
これは、~scriptによる~callbackの呼出ingを孕むかもしれず，最終的に `走らせた~scriptを片付ける$手続きを~callする結果、この~algoが再度~callされることになる。
`極小task~checkpoint遂行-中~flag$を利用しているのは、その再入性を避けるためである。
◎
This might involve invoking scripted callbacks, which eventually calls the clean up after running script steps, which call this perform a microtask checkpoint algorithm again, which is why we use the performing a microtask checkpoint flag to avoid reentrancy.
</p>
			</li>
			<li>
%~loop の`現在~走中の~task$ ~SET ~NULL
◎
Set the event loop's currently running task back to null.
</li>
	<li>
%極小task を`極小task待行列$から除去する；<br>
<!-- ＊GOTO Microtask queue handling -->
◎
Remove the microtask run in the step above from the microtask queue, and return to the microtask queue handling step.
</li>
		</ol>
	</li>
	<li>
<!-- ＊Done： -->
~FOR ~EACH( `環境~設定群~obj$ %設定群 ) に対し
⇒
~IF［
%設定群 の`担当の~event~loop$ ~EQ %~loop
］
⇒
%設定群 に対し，`却下済み~promiseについて通知-$する
◎
Done: For each environment settings object whose responsible event loop is this event loop, notify about rejected promises on that environment settings object.
</li>
	<li>
`極小task~checkpoint遂行-中~flag$ ~SET ~OFF
◎
Let the performing a microtask checkpoint flag be false.
</li>
</ol>


<p class="algo-head">
~UAは、`複合~極小task$が走中の間に，所与の `手続き^v を走らすような
`複合~極小task下位taskを実行する@
ことが要求される場合、次を走らせ~MUST：
◎
If, while a compound microtask is running, the user agent is required to execute a compound microtask subtask to run a series of steps, the user agent must run the following steps:
</p>


<ol>
	<li>
%親 ~LET %~loop の`現在~走中の~task$
（現在~走中の`複合~極小task$）。
◎
Let parent be the event loop's currently running task (the currently running compound microtask).
</li>
	<li>
%下位task ~LET
`極小task~task源$を`~task源$とする， `手続き^v を走らす新たな`~task$
— この`極小task$を指して，
`複合~極小task下位task@
という。
◎
Let subtask be a new task that consists of running the given series of steps. The task source of such a microtask is the microtask task source. This is a compound microtask subtask.
</li>
	<li>
%~loop の`現在~走中の~task$ ~SET %下位task 
◎
Set the event loop's currently running task to subtask.
</li>
	<li>
%下位task を走らす
◎
Run subtask.
</li>
	<li>
%~loop の`現在~走中の~task$ ~SET %親 
◎
Set the event loop's currently running task back to parent.
</li>
</ol>


<hr>


<p class="algo-head">
~UAは、所与の %~algo を，
`安定~状態を待受ける@
ために，`並列的$に走らすときは、次を走らせ~MUST：
◎
When an algorithm running in parallel is to await a stable state, the user agent must queue a microtask that runs the following steps, and must then stop executing (execution of the algorithm resumes when the microtask is run, as described in the following steps):
</p>


<ol>
	<li>
<p>
次の手続きを走らす`極小taskを待入する$：
◎
↑
</p>
		<ol>
			<li>
%~algo 内の
`同期区間@
を走らす
◎
Run the algorithm's synchronous section.
</li>
		<li>
適切になるなら、
<!-- ＊
~algo の手続きに述べるように，
-->
%~algo の実行を`並列的$に再開する
◎
Resumes execution of the algorithm in parallel, if appropriate, as described in the algorithm's steps.
</li>
		</ol>
	</li>

	<li>
%~algo の実行ingを停止する（実行は、前~段に述べたように，極小taskが走らすとき再開される）。
◎
↑</li>
</ol>

<p class="note">注記：
%~algo 内の`同期区間$は、~~記号 ⌛ が付与される段として与えられる。
◎
Steps in synchronous sections are marked with ⌛.
</p>


<hr>


<p class="algo-head">
~algoにて，所与の条件 %目標 が満たされるまで
`~event~loopを回す@
と記されている所では、~UAは，次を走らせ~MUST：
◎
When an algorithm says to spin the event loop until a condition goal is met, the user agent must run the following steps:
</p>


<ol>
	<li>
<p>
%~task ~LET `~event~loop$の`現在~走中の~task$
◎
Let task be the event loop's currently running task.
</p>


<p class="note">注記：
これは、`極小task$の場合もある
— その事例では、`孤立~callback極小task$になる。
これは、［
`複合~極小task下位task$ ／
`極小task$でない定例の`~task$
］の場合もある。
これが`複合~極小task$になることは、<em>ない</em>。
◎
This might be a microtask, in which case it is a solitary callback microtask. It could also be a compound microtask subtask, or a regular task that is not a microtask. It will not be a compound microtask.
</p>
	</li>
	<li>
%~task源 ~LET %~task の`~task源$
◎
Let task source be task's task source.
</li>
	<li>
%旧~stack ~LET 
`~JS実行~文脈~stack$jsの複製
◎
Let old stack be a copy of the JavaScript execution context stack.
</li>
	<li>
`~JS実行~文脈~stack$jsを空にする
◎
Empty the JavaScript execution context stack.
</li>
	<li>
`大域~script片付け~jobを走らす$
◎
Run the global script clean-up jobs.
</li>
	<li>
`極小task~checkpointを遂行する$
◎
Perform a microtask checkpoint.
</li>
	<li>
<p>
%~task を停止して，それを呼出した~algoを何であれ再開できるようにする一方で、この手続きは`並列的$に継続する
◎
Stop task, allowing whatever algorithm that invoked it to resume, but continue these steps in parallel.
</p>

<div class="note">
<p>注記：
これは、次のいずれかの~algoを継続させる：
</p>
<ul>
	<li>
`~event~loop$の~~主~手続き
`<a href="#processing-model-8">処理~model節</a>^tnote
</li>
	<li>
`極小task~checkpointを遂行する$
</li>
	<li>
`複合~極小task下位taskを実行する$
</li>
</ul>

◎
This causes one of the following algorithms to continue: the event loop's main set of steps, the perform a microtask checkpoint algorithm, or the execute a compound microtask subtask algorithm to continue.
</div>

	</li>
	<li>
%目標 が満たされるまで待機する
◎
Wait until the condition goal is met.
</li>
	<li>
%継続~task ~LET 新たな何もしない`~task$
◎
↓</li>
	<li>
%~task源 を`~task源$に利用して， %継続~task を`待入する$
◎
↓</li>
	<li>
%継続~task が走らされるまで待機する
◎
Queue a task to continue running these steps, using the task source task source. Wait until this new task runs before continuing these steps.
</li>
	<li>
`~JS実行~文脈~stack$jsを %旧~stack で置換する
◎
Replace the JavaScript execution context stack with the old stack.
</li>
	<li>
~RET
— ~call元へ~~制御を返す
◎
Return to the caller.
</li>
</ol>

<p class="trans-note">【
上で停止された %~task はどうなる？
自動的に再開されるのか？
次の`一時停止-$に関連付けられているのか？
】</p>

<hr>

<p class="algo-head">
歴史的~理由から、この仕様の~algoのうち一部は，`~task$ %~task が走中の間，所与の %目標 が満たされるまで、~UAに
`一時停止-@
することを要求する。
これは、次の手続きを走らすことを意味する：
◎
Some of the algorithms in this specification, for historical reasons, require the user agent to pause while running a task until a condition goal is met. This means running the following steps:
</p>


<ol>
	<li>
必要とされるなら、［
`文書$ ／ `閲覧文脈$x
］の［
描画, 利用者~interface
］を，現在の状態を反映するように更新する
◎
If necessary, update the rendering or user interface of any Document or browsing context to reflect the current state.
</li>
	<li>
<p>
%目標 が満たされるまで待機する
— ~UAが %~task を`一時停止-$している間は：
</p>
		<ul>
			<li>
%~task が属している`~event~loop$は、他の`~task$を走らせては~MUST_NOT。
</li>
			<li>
`現在~走中の~task$における~script実行は、阻まれ~MUST。
</li>
			<li>
~UAは、利用者~入力に対する応答性は保ち続けるべきである
— しかしながら、`~event~loop$は何もしなくなるので，~~能力は抑制されることになる。
</li>
		</ul>
◎
Wait until the condition goal is met. While a user agent has a paused task, the corresponding event loop must not run further tasks, and any script in the currently running task must block. User agents should remain responsive to user input while paused, however, albeit in a reduced capacity since the event loop will not be doing anything.
</li>
</ol>

		</section>
		<section id="generic-task-sources">
<h4 title="Generic task sources">8.1.4.3. 汎用の~task源</h4>

<p>
次に挙げる`~task源$は、［
この／他の
］仕様における，互いにほぼ関係ない，いくつもの特色機能により利用される：
◎
The following task sources are used by a number of mostly unrelated features in this and other specifications.
</p>


<dl class="def-list">
	<dt>
`DOM 操作~task源@
◎
The DOM manipulation task source
</dt>
	<dd>
この`~task源$は、 DOM 操作に反応する特色機能のために利用される
— 要素が`文書の中へ挿入-$xされるときなど，他を阻むことなく起きるものなど。
◎
This task source is used for features that react to DOM manipulations, such as things that happen in a non-blocking fashion when an element is inserted into the document.
</dd>

	<dt>
`利用者対話~task源@
◎
The user interaction task source
</dt>
	<dd>
<p>
この`~task源$は、利用者対話に反応する特色機能のために利用される
— 例えば［
~keyboard／~mouse
］入力。
◎
This task source is used for features that react to user interaction, for example keyboard or mouse input.
</p>

<p>
利用者~入力に呼応して送信される~event（例： `click$et ~event `UIEVENTS$r ）は、`利用者対話~task源$により`待入され$る`~task$を利用して発火され~MUST。
◎
Events sent in response to user input (e.g. click events) must be fired using tasks queued with the user interaction task source. [UIEVENTS]
</p></dd>

	<dt>
`~network用~task源@
◎
The networking task source
</dt>
	<dd>
この`~task源$は、~network活動に呼応して誘発される特色機能のために利用される。
◎
This task source is used for features that trigger in response to network activity.
</dd>

	<dt>
`履歴~走査~task源@
◎
The history traversal task source
</dt>
	<dd>
この`~task源$は、
`history.back()$m
や, それに類似する~APIへの~callを待入するために利用される。
◎
This task source is used to queue calls to history.back() and similar APIs.
</dd>
</dl>









		</section>
	</section>
	<section id="events">
<h3 title="Events">8.1.5. ~event</h3>




		<section id="event-handler-attributes">
<h4 title="Event handlers">8.1.5.1. ~event~handler</h4>

<p>
多くの~objには
`~event~handler@
が指定され得る。
これらは、指定された~objに対する，非~capture~event~listenerとして動作する。
`DOM$r
◎
Many objects can have event handlers specified. These act as non-capture event listeners for the object on which they are specified. [DOM]
</p>


<p>
`~event~handler$の名前は、常に `on^l から開始し，~handlerに意図される~event名が後続する。
◎
An event handler has a name, which always starts with "on" and is followed by the name of the event for which it is intended.
</p>


<p>
`~event~handler$の値は［
~NULL,
~callback~obj,
`内部的な生の未compileの~handler$
］いずれかをとる。
`EventHandler$I ~callback関数~型は、これが~scriptに どう公開されるかを述べる。
初期~時には、 `~event~handler$の値は~NULLに設定され~MUST。
◎
An event handler has a value, which is either null, or is a callback object, or is an internal raw uncompiled handler. The EventHandler callback function type describes how this is exposed to scripts. Initially, an event handler's value must be set to null.
</p>


<p>
各~event~handlerは、次の二つの仕方で公開される：
◎
Event handlers are exposed in one of two ways.
</p>

<ul>
	<li>
`~event~handler~IDL属性$として：
この仕方は、すべての~event~handlerに共通する。
◎
The first way, common to all event handlers, is as an event handler IDL attribute.
</li>
	<li>
`~event~handler内容~属性$として：
［
`HTML 要素$ ／ `~window$
］上の~event~handlerのうち一部は、この仕方でも公開される。
◎
The second way is as an event handler content attribute. Event handlers on HTML elements and some of the event handlers on Window objects are exposed in this way.
</li>
</ul>


<hr>


<p>
`~event~handler~IDL属性@
は、~obj上の特定の`~event~handler$に対応する，同じ~obj上の~IDL属性である。
その名前は、`~event~handler$の名前と同じである。
◎
An event handler IDL attribute is an IDL attribute for a specific event handler. The name of the IDL attribute is the same as the name of the event handler.
</p>


<div class="p">
<p class="algo-head">
`~event~handler~IDL属性$は：
</p>

<ul>
	<li>
被設定時には、対応している`~event~handler$を，所与の新たな値に設定し~MUST。
</li>
	<li>
被取得時には、対応している`~event~handlerの現在の値を取得-$した結果を返さ~MUST（これは、例外を投出し得る
— その場合、~catchされない限り，例外は~call元まで伝播する）。
</li>
</ul>
◎
Event handler IDL attributes, on setting, must set the corresponding event handler to their new value, and on getting, must return the result of getting the current value of the event handler in question (this can throw an exception, in which case the getting propagates it to the caller, it does not catch it).
</div>

<div class="p">

<p class="algo-head">
`~event~handler~IDL属性$が、存在しない~objの`~event~handler$を公開する場合：
</p>

<ul>
	<li>
被取得時には常に~NULLを返さ~MUST。
</li>
	<li>
被設定時には何もしては~MUST_NOT。
</li>
</ul>

◎
If an event handler IDL attribute exposes an event handler of an object that doesn't exist, it must always return null on getting and must do nothing on setting.
</div>


<p class="note">注記：
これは特に、対応している`~window$を有さない `body$e 要素~上の`~event~handler~IDL属性$に起こり得る。
`~windowのそれを反映する~IDL属性^tnote
◎
This can happen in particular for event handler IDL attribute on body elements that do not have corresponding Window objects.
</p>


<p class="note">注記：
ある種の~event~handler~IDL属性には追加の要件がある
— 特に `MessagePort$I ~objの `onmessage$m 属性。
◎
Certain event handler IDL attributes have additional requirements, in particular the onmessage attribute of MessagePort objects.
</p>


<hr>

<p>
`~event~handler内容~属性@
は、~obj上の特定の`~event~handler$に対応する，同じ~obj上の内容~属性である。
その名前は、`~event~handler$の名前と同じである。
◎
An event handler content attribute is a content attribute for a specific event handler. The name of the content attribute is the same as the name of the event handler.
</p>


<p>
`~event~handler内容~属性$に指定される値は、［
`自動的~semicolon挿入$js後に，
`FunctionBody$jA 生成規則に合致するように構文解析される
］ような，妥当な~JS~codeを包含し~MUST。
◎
Event handler content attributes, when specified, must contain valid JavaScript code which, when parsed, would match the FunctionBody production after automatic semicolon insertion.
</p>




<p class="algo-head">
`~event~handler内容~属性$ %属性 の被設定時には、次の手続きを実行する：
◎
When an event handler content attribute is set, execute the following steps:
</p>


<ol>
	<li>
~IF［［
( %属性 を有している`要素$x, `script attribute^l, 所与の値 )
を与える下で，
<a href="~CSP3#should-block-inline">要素の~inline型の挙動は~CSPにより阻止されるべきか？</a>
`CSP$r
］を実行した結果 ~EQ `阻止ed^i
］
⇒
~RET
◎
If the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the attribute's element, "script attribute", and the attribute's value, then abort these steps. [CSP]
</li>
	<li>
対応している`~event~handler$ ~SET
次の組からなる，`内部的な生の未compileの~handler$
⇒
~script本体： %属性 に対する新たな値；<br />
~script本体の所在： %属性 の所在
◎
Set the corresponding event handler to an internal raw uncompiled handler consisting of the attribute's new value and the script location where the attribute was set to this value
</li>
</ol>


<p class="algo-head">
`~event~handler内容~属性$が除去されるときは、~UAは，対応する`~event~handler$を~NULLに設定し~MUST。
◎
When an event handler content attribute is removed, the user agent must set the corresponding event handler to null.
</p>

<hr>

<div class="p">
<p class="algo-head">
`EventTarget$I ~interfaceを実装している~obj（例えば要素） %T 上の`~event~handler$ %H が，最初に非 ~NULL 値に設定されるときは、
~UAは、 %T に結付けられている［
`~event~listener$xの~list
］に，次の組からなる`~event~listener$xを付加し~MUST：
</p>

<ul>
	<li>
`type^i ： %H に対応する `~event~handler~event型@
</li>
	<li>
`callback^i ： 下に定義される`~event~handler処理~algo$
`DOM$r
</li>
</ul>

◎
When an event handler H of an element or object T implementing the EventTarget interface is first set to a non-null value, the user agent must append an event listener to the list of event listeners associated with T with type set to the event handler event type corresponding to H and callback set to the event handler processing algorithm defined below. [DOM]
</div>


<p class="note">注記：
`callback^i は、 %H 自身<em>ではない</em>ことに注意。
どの`~event~handler$も、下に定義される~algoとして，同じ `~callback^i を登録する結果になる。
その~algoが、~~正しい~callbackを呼出すこと, および
その~callbackが返す値の処理を受け持つ。
◎
The callback is emphatically not the event handler itself. Every event handler ends up registering the same callback, the algorithm defined below, which takes care of invoking the right callback, and processing the callback's return value.
</p>

<div class="note">
<p>注記：
~event~listenerの付加-が起こるのは、 %H の値が初回に設定されるときに限られる。
~listenerたちは、登録-順に~callされるので、 %T 上の特定0の~event型に対する~event~listenerたちは，常に次の順序で~callされる：
</p>

<ol>
	<li>
%H が最初に非 ~NULL 値に設定される前に，
%T 上の `addEventListener()$m で登録された~listenerたち
</li>
	<li>
現在， %H に設定されている~callbackがあれば，その~listener
</li>
	<li>
%H が最初に非 ~NULL 値に設定された<em>後に</em>，
%T 上の `addEventListener()$m で登録された~listenerたち
</li>
</ol>

◎
This only happens the first time the event handler's value is set. Since listeners are called in the order they were registered, the order of event listeners for a particular event type will always be first the event listeners registered with addEventListener() before the first time the event handler was set to a non-null value, then the callback to which it is currently set, if any, and finally the event listeners registered with addEventListener() after the first time the event handler was set to a non-null value.
</div>


<div class="example">

<p>
~event~listenerが呼出される順序を，次の~codeで例証する。
利用者がこの例の~buttonを~clickしたとき、頁は，順に~text［
`一^l, `二^l, `三^l, `四^l
］を伴う 4 回の~alertを示すことになる。
◎
This example demonstrates the order in which event listeners are invoked. If the button in this example is clicked by the user, the page will show four alerts, with the text "ONE", "TWO", "THREE", and "FOUR" respectively.
</p>


<pre>
&lt;button id="test"&gt;Start Demo&lt;/button&gt;
&lt;script&gt;
  var %button = document.getElementById('test');
  %button.addEventListener(
    'click', function(){ alert('一') }, false
  );
  %button.setAttribute(
    'onclick', "alert('この~alertは呼ばれない')"
  ); /* <span class="comment">
~event~handler~listenerはこの時点で登録される。
◎
event handler listener is registered here</span> */

  %button.addEventListener(
    'click', function(){ alert('三') }, false
  );
  %button.onclick = function(){ alert('二'); };
  %button.addEventListener(
    'click', function(){ alert('四') }, false
  );
&lt;/script&gt;
</pre>

</div>


<p class="note">注記：
~event~objが実装する~interfaceは、`~event~handler$が誘発されるかどうかには波及しない。
◎
The interfaces implemented by the event object do not influence whether an event handler is triggered or not.
</p>


<p class="algo-head">
`~event~handler処理~algo@
は、
( `~event~handler$ %H , `Event$I ~obj %E )
に対し，次を行う：
◎
The event handler processing algorithm for an event handler H and an Event object E is as follows:
</p>


<ol>
	<li>
%~callback ~LET %H に対し，`~event~handlerの現在の値を取得-$した結果
◎
Let callback be the result of getting the current value of the event handler H.
</li>
	<li>
~IF［
%~callback ~EQ ~NULL
］
⇒
~RET
◎
If callback is null, then abort these steps.
</li>
	<li>
<p>
%返値 ~LET 次を与える下で %~callback を
<a id="concept-invoke-event-handler" href="~WEBIDL#es-invoking-callback-functions">Web IDL ~callback関数として呼出した</a>
結果：
◎
Process the Event object E as follows:
</p>

		<ul>
			<li>
`~callback this 値$x ~SET %E の`currentTarget$m
◎
↓</li>
			<li>
<p>
引数 ~SET 次で与えられる引数：
◎
↓</p>
				<dl class="switch">
					<dt>
［
%E は `ErrorEvent$I ~objである
］~AND［
%H に対する`~event~handler~IDL属性$の型 ~EQ `OnErrorEventHandler$I
］の場合：
◎
If E is an ErrorEvent object and the event handler IDL attribute's type is OnErrorEventHandler
</dt>
					<dd>
順に， %E の (
`message$m,
`filename$m,
`lineno$m,
`colno$m,
`error$m
)
属性~値
◎
Invoke callback with five arguments, the first one having the value of E's message attribute, the second having the value of E's filename attribute, the third having the value of E's lineno attribute, the fourth having the value of E's colno attribute, the fifth having the value of E's error attribute, and with the callback this value set to E's currentTarget. Let return value be the callback's return value. [WEBIDL]
</dd>

					<dt>
他の場合：
◎
Otherwise
</dt>
					<dd>
%E のみ
◎
Invoke callback with one argument, the value of which is the Event object E, with the callback this value set to E's currentTarget. Let return value be the callback's return value. [WEBIDL]
</dd>
				</dl>
			</li>
		</ul>
<p>
~IF［
%~callback から例外が投出された
］
⇒
~RET
— 例外は伝播させる（それは、
`DOM ~event配送-~logic$x
へ伝播し，その`例外を報告する$ことになる）。
◎
In this step, invoke means to invoke the Web IDL callback function.
◎
If an exception gets thrown by the callback, end these steps and allow the exception to propagate. (It will propagate to the DOM event dispatch logic, which will then report the exception.)
</p>
	</li>

	<li>
<p>
%返値 を処理する
— ~event型に応じて：
◎
Process return value as follows:
</p>


<dl class="switch">
	<dt>`mouseover$et
◎
If the event type is mouseover
</dt>
	<dd>
~IF［
%返値 ~EQ ~T
］
⇒
~eventを取消す
◎
↓</dd>
	<dt>`error$et
◎
If the event type is error and E is an ErrorEvent object
</dt>
	<dd>
<p>
~IF［
%E は `ErrorEvent$I ~objである
］
⇒
~IF［
%返値 ~EQ ~T
］
⇒
~eventを取消す
</p>

<p>
~ELSE
⇒
~GOTO 下の “その他” の段
</p>
◎
If return value is a Web IDL boolean true value, then cancel the event.
</dd>

	<dt>`beforeunload$et
◎
If the event type is beforeunload
</dt>
	<dd class="note">注記：
`~event~handler~IDL属性$の型は，
`OnBeforeUnloadEventHandler$I
であり、従って， %返値 は［
~NULL または `DOMString^I
］型に型強制されている。
◎
The event handler IDL attribute's type is OnBeforeUnloadEventHandler, and the return value will therefore have been coerced into either the value null or a DOMString.
</dd>
	<dd>
~IF［
%返値 ~EQ ~NULL
］
⇒
~eventを取消す
◎
If the return value is null, then cancel the event.
</dd>
	<dd>
~ELIF［
%E は `BeforeUnloadEvent$I ~objである
］~AND［
%E の `returnValue$m 属性~値 ~EQ 空~文字列
］
⇒
%E の `returnValue$m 属性~値 ~SET %返値
◎
Otherwise, If the Event object E is a BeforeUnloadEvent object, and the Event object E's returnValue attribute's value is the empty string, then set the returnValue attribute's value to return value.
</dd>

	<dt>その他
◎
Otherwise
</dt>
	<dd>
~IF［
%返値 ~EQ ~F
］
⇒
~eventを取消す
◎
If return value is a Web IDL boolean false value, then cancel the event.
</dd>
		</dl>

<p>
この段の ~T／~F は、 Web IDL boolean 型のそれを表す。
◎
↑</p>

   </li>
</ol>


<hr>


<p>
`EventHandler$I ~callback関数~型は、~event~handlerに利用される~callbackを表現する。
それは、次の Web IDL で表現される：
◎
The EventHandler callback function type represents a callback used for event handlers. It is represented in Web IDL as follows:
</p>


⇒！
[TreatNonObjectAsNull]
callback `EventHandlerNonNull@I = any (`Event$I event);
typedef `EventHandlerNonNull$I? `EventHandler@I;
◎


<p class="note">注記：
~JSにおいては、どの `Function$I ~objもこの~interfaceを実装する。
◎
In JavaScript, any Function object implements this interface.
</p>


<div class="example">

<p>
例えば、次の文書~断片で：
◎
For example, the following document fragment:
</p>


<pre>
&lt;body onload="alert(this)" onclick="alert(this)"&gt;
</pre>


<p>
文書が読込まれたときは
`[object Window]^l
が~alertされ、利用者が頁~内のどこかを~clickしたなら
`[object HTMLBodyElement]^l
が~alertされる。
◎
...leads to an alert saying "[object Window]" when the document is loaded, and an alert saying "[object HTMLBodyElement]" whenever the user clicks something in the page.
</p>

</div>


<p class="note">注記：
関数の返値は、上で述べたように，~eventが取消されるかどうかに影響する：
［
返値 ~EQ ~F
］の場合、~eventは取消される（ただし、
`mouseover$et ~eventに対しては、~eventが取消されるためには返値 ~T になる必要がある）。
`beforeunload$et ~eventにおいては、値は，代わりに［
文書が~unloadされることを~promptするかどうか
］を決定するために利用される。
◎
The return value of the function affects whether the event is canceled or not: as described above, if the return value is false, the event is canceled (except for mouseover events, where the return value has to be true to cancel the event). With beforeunload events, the value is instead used to determine whether or not to prompt about unloading the document.
</p>


<p>
歴史的~理由から、
`onerror$hd ~handlerは，異なる引数をとる:
◎
For historical reasons, the onerror handler has different arguments:
</p>


⇒！
[TreatNonObjectAsNull]
callback `OnErrorEventHandlerNonNull@I = any (
    (`Event$I or DOMString) %event,
    optional DOMString %source,
    optional unsigned long %lineno,
    optional unsigned long %column,
    optional any %error
);
typedef `OnErrorEventHandlerNonNull$I? `OnErrorEventHandler@I;
◎


<p>
同様に、
`onbeforeunload$hd ~handlerは，異なる値を返す：
◎
Similarly, the onbeforeunload handler has a different return value:
</p>


⇒！
[TreatNonObjectAsNull]
callback `OnBeforeUnloadEventHandlerNonNull@I = DOMString? (`Event$I %event);
typedef `OnBeforeUnloadEventHandlerNonNull$I? `OnBeforeUnloadEventHandler@I;
◎



<hr>


<p>
`内部的な生の未compileの~handler@
は、次の情報の組である：
◎
An internal raw uncompiled handler is a tuple with the following information:
</p>


<ul class="brief">
	<li>
未compileの~script本体
◎
An uncompiled script body
</li>
	<li>
~script本体が出自にしている所在
— ~errorを報告する必要がある場合に限り。
◎
A location where the script body originated, in case an error needs to be reported
</li>

</ul>


<p class="algo-head">
~UAが
~event~handler %H に対し
`~event~handlerの現在の値を取得-@
するときは、次を走らせ~MUST：
◎
When the user agent is to get the current value of the event handler H, it must run these steps:
</p>


<ol>
	<li>
~IF［
%H の値は、`内部的な生の未compileの~handler$でない
］
⇒
~RET %H の値
◎
If H's value is an internal raw uncompiled handler, run these substeps:
</li>
	<li>
~IF［
%H は、ある要素 %E の`~event~handler$である
］
⇒
%要素 ~LET %E；<br>
%文書 ~LET %E の`~node文書$x
◎
If H is an element's event handler, then let element be the element, and document be the element's node document.
</li>
	<li>
~ELSE — すなわち %H は、ある`~window$ %W の`~event~handler$である
⇒
%要素 ~LET ~NULL；<br>
%文書 ~LET
%W に最も近過去に結付けられている`文書$
◎
Otherwise, H is a Window object's event handler: let element be null, and let document be the Document most recently associated with that Window object.
</li>
	<li>
~IF［
%文書 が`属する閲覧文脈$xはない
］~OR［
%文書 が`属する閲覧文脈$xにおいて，`~scriptingは不能化され$ている
］
⇒
~RET ~NULL
◎
If document does not have a browsing context, or if scripting is disabled for document's browsing context, then return null.
</li>
	<li>
%~script ~LET %H の値
◎
↓</li>
	<li>
%本体 ~LET %~script の未compileの~script本体
◎
Let body be the uncompiled script body in the internal raw uncompiled handler.
</li>
	<li>
%所在 ~LET %~script の~script本体が出自にしている所在
◎
Let location be the location where the script body originated, as given by the internal raw uncompiled handler.
</li>
	<li>
%~form所有者 ~LET ~NULL
◎
↓</li>
	<li>
~IF［
%要素 ~NEQ ~NULL 
］~AND［
%要素 には`~form所有者$x %F がある
］
⇒
%~form所有者 ~LET %F
◎
If element is not null and element has a form owner, let form owner be that form owner. Otherwise, let form owner be null.
</li>
	<li>
%~script設定群 ~LET ［
現在， %文書 が結付けらている`~window$
］に対し作成された`環境~設定群~obj$
◎
Let script settings be the environment settings object created for the Window object with which document is currently associated.
</li>
	<li>
<p>
~IF［
%本体 は `FunctionBody$jA として構文解析可能でない
］~OR［
構文解析-時に`早期の~error$jsが検知された
］：
◎
If body is not parsable as FunctionBody or if parsing detects an early error, then follow these substeps:
</p>

		<ol>
			<li>
%H の値 ~SET ~NULL
◎
Set H's value to null.
</li>
			<li>
<p>
次を与える下で，`~errorを報告する$
</p>

		<ul>
			<li>
~script： 適切な `~script$ `？^tnote
</li>
			<li>
問題箇所： %所在 における適切な問題箇所 ( 行番号, 列番号 )
</li>
			<li>
標的：［
%~script設定群 の`大域~obj$0
］
</li>
		</ul>
<p >
~IF［
~errorの`取扱済み~flag$err ~EQ ~OFF
］
⇒
~errorは~UAの開発者~consoleに報告されてよい
</p>
◎
Report the error for the appropriate script and with the appropriate position (line number and column number) given by location, using the global object specified by script settings as the target. If the error is still not handled after this, then the error may be reported to a developer console.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>

	<li>
%strict ~LET［［
%本体 は［
`Use Strict Directive$js を包含する `Directive Prologue$js
］から始まる
］ならば ~T ／
~ELSE_ ~F
］
◎
If body begins with a Directive Prologue that contains a Use Strict Directive then let strict be true, otherwise let strict be false.
</li>
	<li>
<p>
%関数 ~LET 次を引数に `FunctionCreate$jA を~callした結果：
◎
Let function be the result of calling FunctionCreate, with arguments:
</p>


		<dl>
			<dt>%kind</dt>
			<dd>Normal</dd>

			<dt>%ParameterList</dt>
			<dd>
				<dl class="switch">
					<dt>
%H は`~window$の `onerror$hd `~event~handler$である場合：
◎
If H is an onerror event handler of a Window object
</dt>
					<dd>
関数は、次に与える名前の 5 個の引数をとる
⇒
(
`event^c,
`source^c,
`lineno^c,
`colno^c,
`error^c
)
◎
Let the function have five arguments, named event, source, lineno, colno, and error.
</dd>

					<dt>
他の場合：
◎
Otherwise
</dt>
					<dd>
関数は、単独の引数
( `event^c )
をとる
◎
Let the function have a single argument called event.
</dd>
				</dl>
			</dd>

			<dt>%Body</dt>
			<dd>
%本体 を構文解析した結果
◎
The result of parsing body above.
</dd>

			<dt>%Scope</dt>
			<dd>
				<ol>
					<li>
~IF［
%H は要素の`~event~handler$である
］
⇒
%Scope ~LET
`NewObjectEnvironment$jA( %文書, %大域~環境 )
◎
If H is an element's event handler, then let Scope be NewObjectEnvironment(document, the global environment).
</li>

					<li>
~ELSE （すなわち %H は`~window$の`~event~handler$である）
⇒
%Scope ~LET %大域~環境
◎
Otherwise, H is a Window object's event handler: let Scope be the global environment.
</li>
					<li>
~IF［
%~form所有者 ~NEQ ~NULL
］
⇒
%Scope ~SET `NewObjectEnvironment$jA(%~form所有者, %Scope )
◎
If form owner is not null, let Scope be NewObjectEnvironment(form owner, Scope).
</li>
					<li>
~IF［
%要素 ~NEQ ~NULL
］
⇒
%Scope ~SET `NewObjectEnvironment$jA( %要素, %Scope )
◎
If element is not null, let Scope be NewObjectEnvironment(element, Scope).
</li>
				</ol>
			</dd>

			<dt>%Strict</dt>
			<dd>
%strict
◎
The value of strict.
</dd>
		</dl>
	</li>
	<li>
%H の値 ~SET %関数
◎
Set H's value to function.
</li>
	<li>
~RET %関数
◎
Return H's value.
</li>
</ol>


		</section>
		<section id="event-handlers-on-elements,-document-objects,-and-window-objects">
<h4 title="Event handlers on elements, Document objects, and Window objects">8.1.5.2. ［ 要素 ／ 文書 ／ ~window ］上の各種~event~handler</h4>


<div class="p">
<p>
以下に挙げる各種`~event~handler$, および
対応する各種`~event~handler~event型$は：
</p>

<ul>
	<li>
`HTML 要素$においては、［
`~event~handler内容~属性$,
`~event~handler~IDL属性$
］の両者として，~supportされ~MUST。
</li>
	<li>
［
`文書$ ／ `~window$
］においては、`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
</ul>

◎
The following are the event handlers (and their corresponding event handler event types) that must be supported by all HTML elements, as both event handler content attributes and event handler IDL attributes; and that must be supported by all Document and Window objects, as event handler IDL attributes:
</div>

<table><thead><tr><th>`~event~handler$
</th><th>`~event~handler~event型$
</th></tr></thead>

<tbody><tr><td>`onabort@hd
</td><td>`abort$et
</td></tr><tr><td>`onautocomplete@hd
</td><td>`autocomplete$et 
</td></tr><tr><td>`onautocompleteerror@hd
</td><td>`autocompleteerror$et 
</td></tr><tr><td>`oncancel@hd
</td><td>`cancel$et
</td></tr><tr><td>`oncanplay@hd
</td><td>`canplay$et
</td></tr><tr><td>`oncanplaythrough@hd
</td><td>`canplaythrough$et
</td></tr><tr><td>`onchange@hd
</td><td>`change$et 
</td></tr><tr><td>`onclick@hd
</td><td>`click$et 
</td></tr><tr><td>`onclose@hd
</td><td>`close$et 
</td></tr><tr><td>`oncontextmenu@hd
</td><td>`contextmenu$et 
</td></tr><tr><td>`oncuechange@hd
</td><td>`cuechange$et
</td></tr><tr><td>`ondblclick@hd
</td><td>`dblclick$et 
</td></tr><tr><td>`ondrag@hd
</td><td>`drag$et
</td></tr><tr><td>`ondragend@hd
</td><td>`dragend$et
</td></tr><tr><td>`ondragenter@hd
</td><td>`dragenter$et
</td></tr><tr><td>`ondragexit@hd
</td><td>`dragexit$et
</td></tr><tr><td>`ondragleave@hd
</td><td>`dragleave$et
</td></tr><tr><td>`ondragover@hd
</td><td>`dragover$et
</td></tr><tr><td>`ondragstart@hd
</td><td>`dragstart$et 
</td></tr><tr><td>`ondrop@hd
</td><td>`drop$et
</td></tr><tr><td>`ondurationchange@hd
</td><td>`durationchange$et
</td></tr><tr><td>`onemptied@hd
</td><td>`emptied$et
</td></tr><tr><td>`onended@hd
</td><td>`ended$et
</td></tr><tr><td>`oninput@hd
</td><td>`input$et
</td></tr><tr><td>`oninvalid@hd
</td><td>`invalid$et
</td></tr><tr><td>`onkeydown@hd
</td><td>`keydown$et 
</td></tr><tr><td>`onkeypress@hd
</td><td>`keypress$et 
</td></tr><tr><td>`onkeyup@hd
</td><td>`keyup$et 
</td></tr><tr><td>`onloadeddata@hd
</td><td>`loadeddata$et
</td></tr><tr><td>`onloadedmetadata@hd
</td><td>`loadedmetadata$et
</td></tr><tr><td>`onloadstart@hd
</td><td>`loadstart$et
</td></tr><tr><td>`onmousedown@hd
</td><td>`mousedown$et 
</td></tr><tr><td>`onmouseenter@hd
</td><td>`mouseenter$et 
</td></tr><tr><td>`onmouseleave@hd
</td><td>`mouseleave$et 
</td></tr><tr><td>`onmousemove@hd
</td><td>`mousemove$et 
</td></tr><tr><td>`onmouseout@hd
</td><td>`mouseout$et 
</td></tr><tr><td>`onmouseover@hd
</td><td>`mouseover$et 
</td></tr><tr><td>`onmouseup@hd
</td><td>`mouseup$et 
</td></tr><tr><td>`onwheel@hd
</td><td>`wheel$et 
</td></tr><tr><td>`onpause@hd
</td><td>`pause$et
</td></tr><tr><td>`onplay@hd
</td><td>`play$et
</td></tr><tr><td>`onplaying@hd
</td><td>`playing$et
</td></tr><tr><td>`onprogress@hd
</td><td>`progress$et
</td></tr><tr><td>`onratechange@hd
</td><td>`ratechange$et
</td></tr><tr><td>`onreset@hd
</td><td>`reset$et
</td></tr><tr><td>`onseeked@hd
</td><td>`seeked$et
</td></tr><tr><td>`onseeking@hd
</td><td>`seeking$et
</td></tr><tr><td>`onselect@hd
</td><td>`select$et  
</td></tr><tr><td>`onshow@hd
</td><td>`show$et
</td></tr><tr><td>`onstalled@hd
</td><td>`stalled$et
</td></tr><tr><td>`onsubmit@hd
</td><td>`submit$et 
</td></tr><tr><td>`onsuspend@hd
</td><td>`suspend$et
</td></tr><tr><td>`ontimeupdate@hd
</td><td>`timeupdate$et
</td></tr><tr><td>`ontoggle@hd
</td><td>`toggle$et
</td></tr><tr><td>`onvolumechange@hd
</td><td>`volumechange$et
</td></tr><tr><td>`onwaiting@hd
</td><td>`waiting$et

</td></tr></tbody></table>


<hr>

<div class="p">
<p>
以下に挙げる各種`~event~handler$, および
対応する各種`~event~handler~event型$は：
</p>

<ul>
	<li>
［
`body$e, `frameset$e
］要素を除く `HTML 要素$においては、［
`~event~handler内容~属性$,
`~event~handler~IDL属性$
］の両者として，~supportされ~MUST。
</li>
	<li>
`文書$においては、`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
	<li>
`~window$においては、`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
	<li>
`~windowの文書$xが所有する［
`body$e ／ `frameset$e
］要素においては、当の`~window$が公開する［
`~event~handler内容~属性$,
`~event~handler~IDL属性$
］として，~supportされ~MUST。
</li>
</ul>

◎
The following are the event handlers (and their corresponding event handler event types) that must be supported by all HTML elements other than body and frameset elements, as both event handler content attributes and event handler IDL attributes; that must be supported by all Document objects, as event handler IDL attributes; and that must be supported by all Window objects, as event handler IDL attributes on the Window objects themselves, and with corresponding event handler content attributes and event handler IDL attributes exposed on all body and frameset elements that are owned by that Window object's Documents:
</div>


<table><thead><tr><th>`~event~handler$
</th><th>`~event~handler~event型$
</th></tr></thead><tbody><tr><td>`onblur@hd
</td><td>`blur$et 
</td></tr><tr><td>`onerror@hd
</td><td>`error$et
</td></tr><tr><td>`onfocus@hd
</td><td>`focus$et 
</td></tr><tr><td>`onload@hd
</td><td>`load$et
</td></tr><tr><td>`onresize@hd
</td><td>`resize$et
</td></tr><tr><td>`onscroll@hd
</td><td>`scroll$et
</td></tr></tbody></table>


<hr>


<div class="p">
<p>
以下に挙げる各種`~event~handler$, および
対応する各種`~event~handler~event型$は：
</p>

<ul>
	<li>
`~window$においては，`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
	<li>
`~windowの文書$xが所有する［
`body$e ／ `frameset$e
］要素においては、当の`~window$が公開する［
`~event~handler内容~属性$,
`~event~handler~IDL属性$
］として，~supportされ~MUST。
</li>
</ul>

◎
The following are the event handlers (and their corresponding event handler event types) that must be supported by Window objects, as event handler IDL attributes on the Window objects themselves, and with corresponding event handler content attributes and event handler IDL attributes exposed on all body and frameset elements that are owned by that Window object's Documents:
</div>



<table><thead><tr><th>`~event~handler$
</th><th>`~event~handler~event型$
</th></tr></thead>

<tbody><tr><td>`onafterprint@hd
</td><td>`afterprint$et
</td></tr><tr><td>`onbeforeprint@hd
</td><td>`beforeprint$et
</td></tr><tr><td>`onbeforeunload@hd
</td><td>`beforeunload$et
</td></tr><tr><td>`onhashchange@hd
</td><td>`hashchange$et 
</td></tr><tr><td>`onlanguagechange@hd
</td><td>`languagechange$et 
</td></tr><tr><td>`onmessage@hd
</td><td>`message$et 
</td></tr><tr><td>`onoffline@hd
</td><td>`offline$et 
</td></tr><tr><td>`ononline@hd
</td><td>`online$et 
</td></tr><tr><td>`onpagehide@hd
</td><td>`pagehide$et 
</td></tr><tr><td>`onpageshow@hd
</td><td>`pageshow$et 
</td></tr><tr><td>`onpopstate@hd
</td><td>`popstate$et 
</td></tr><tr><td>`onrejectionhandled@hd
</td><td>`rejectionhandled$et
</td></tr><tr><td>`onstorage@hd
</td><td>`storage$et 
</td></tr><tr><td>`onunhandledrejection@hd
</td><td>`unhandledrejection$et
</td></tr><tr><td>`onunload@hd
</td><td>`unload$et 
</td></tr></tbody></table>


<hr>


<div class="p">
<p>
以下に挙げる各種`~event~handler$, および
対応する各種`~event~handler~event型$は：
</p>

<ul>
	<li>
`HTML 要素$においては、［
`~event~handler内容~属性$,
`~event~handler~IDL属性$
］の両者として，~supportされ~MUST。
</li>
	<li>
`文書$においては、`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
</ul>

◎
The following are the event handlers (and their corresponding event handler event types) that must be supported by all HTML elements, as both event handler content attributes and event handler IDL attributes; and that must be supported by all Document objects, as event handler IDL attributes:
</div>

<table><thead><tr><th>`~event~handler$
</th><th>`~event~handler~event型$
</th></tr></thead>

<tbody><tr><td>`oncut@hd
</td><td>`cut$et
</td></tr><tr><td>`oncopy@hd
</td><td>`copy$et
</td></tr><tr><td>`onpaste@hd
</td><td>`paste$et
</td></tr></tbody></table>

<div class="p">
<p>
以下に挙げる各種`~event~handler$, および
対応する各種`~event~handler~event型$は：
</p>

<ul>
	<li>
`文書$においては、`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
</ul>

◎
The following are the event handlers (and their corresponding event handler event types) that must be supported on Document objects as event handler IDL attributes:
</div>

<table><thead><tr><th>`~event~handler$
</th><th>`~event~handler~event型$
</th></tr></thead><tbody><tr><td>`onreadystatechange@hd
</td><td>`readystatechange$et
</td></tr></tbody></table>


			<section id="idl-definitions">
<h5 title="IDL definitions">8.1.5.2.1. IDL 定義</h5>

<!-- 
#handler-xxx
 -->

⇒！
[NoInterfaceObject]
interface `GlobalEventHandlers@I {
  attribute EventHandler `onabort$hd;
  attribute EventHandler `onautocomplete$hd;
  attribute EventHandler `onautocompleteerror$hd;
  attribute EventHandler `onblur$hd;
  attribute EventHandler `oncancel$hd;
  attribute EventHandler `oncanplay$hd;
  attribute EventHandler `oncanplaythrough$hd;
  attribute EventHandler `onchange$hd;
  attribute EventHandler `onclick$hd;
  attribute EventHandler `onclose$hd;
  attribute EventHandler `oncontextmenu$hd;
  attribute EventHandler `oncuechange$hd;
  attribute EventHandler `ondblclick$hd;
  attribute EventHandler `ondrag$hd;
  attribute EventHandler `ondragend$hd;
  attribute EventHandler `ondragenter$hd;
  attribute EventHandler `ondragexit$hd;
  attribute EventHandler `ondragleave$hd;
  attribute EventHandler `ondragover$hd;
  attribute EventHandler `ondragstart$hd;
  attribute EventHandler `ondrop$hd;
  attribute EventHandler `ondurationchange$hd;
  attribute EventHandler `onemptied$hd;
  attribute EventHandler `onended$hd;
  attribute `OnErrorEventHandler$I `onerror$hd;
  attribute EventHandler `onfocus$hd;
  attribute EventHandler `oninput$hd;
  attribute EventHandler `oninvalid$hd;
  attribute EventHandler `onkeydown$hd;
  attribute EventHandler `onkeypress$hd;
  attribute EventHandler `onkeyup$hd;
  attribute EventHandler `onload$hd;
  attribute EventHandler `onloadeddata$hd;
  attribute EventHandler `onloadedmetadata$hd;
  attribute EventHandler `onloadstart$hd;
  attribute EventHandler `onmousedown$hd;
  [LenientThis] attribute EventHandler `onmouseenter$hd;
  [LenientThis] attribute EventHandler `onmouseleave$hd;
  attribute EventHandler `onmousemove$hd;
  attribute EventHandler `onmouseout$hd;
  attribute EventHandler `onmouseover$hd;
  attribute EventHandler `onmouseup$hd;
  attribute EventHandler `onwheel$hd;
  attribute EventHandler `onpause$hd;
  attribute EventHandler `onplay$hd;
  attribute EventHandler `onplaying$hd;
  attribute EventHandler `onprogress$hd;
  attribute EventHandler `onratechange$hd;
  attribute EventHandler `onreset$hd;
  attribute EventHandler `onresize$hd;
  attribute EventHandler `onscroll$hd;
  attribute EventHandler `onseeked$hd;
  attribute EventHandler `onseeking$hd;
  attribute EventHandler `onselect$hd;
  attribute EventHandler `onshow$hd;
  attribute EventHandler `onstalled$hd;
  attribute EventHandler `onsubmit$hd;
  attribute EventHandler `onsuspend$hd;
  attribute EventHandler `ontimeupdate$hd;
  attribute EventHandler `ontoggle$hd;
  attribute EventHandler `onvolumechange$hd;
  attribute EventHandler `onwaiting$hd;
};
◎
<!-- #handler-window-xxxx -->
⇒！
[NoInterfaceObject]
interface `WindowEventHandlers@I {
  attribute EventHandler `onafterprint$hd;
  attribute EventHandler `onbeforeprint$hd;
  attribute `OnBeforeUnloadEventHandler$I `onbeforeunload$hd;
  attribute EventHandler `onhashchange$hd;
  attribute EventHandler `onlanguagechange$hd;
  attribute EventHandler `onmessage$hd;
  attribute EventHandler `onoffline$hd;
  attribute EventHandler `ononline$hd;
  attribute EventHandler `onpagehide$hd;
  attribute EventHandler `onpageshow$hd;
  attribute EventHandler `onpopstate$hd;
  attribute EventHandler `onrejectionhandled$hd;
  attribute EventHandler `onstorage$hd;
  attribute EventHandler `onunhandledrejection$hd;
  attribute EventHandler `onunload$hd;
};

[NoInterfaceObject]
interface `DocumentAndElementEventHandlers@I {
  attribute EventHandler `oncopy$hd;
  attribute EventHandler `oncut$hd;
  attribute EventHandler `onpaste$hd;
};
◎



			</section>
		</section>
		<section id="event-firing">
<h4 title="Event firing">8.1.5.3. ~eventの発火</h4>


<p>
ある種の演算や~methodは、要素に向けて~eventを発火するものとして定義される。
例えば、
`HTMLElement$I ~interface上の `click()$m ~methodは、要素に向けて `click$et ~eventを発火するものとして定義される。
`UIEVENTS$r
◎
Certain operations and methods are defined as firing events on elements. For example, the click() method on the HTMLElement interface is defined as firing a click event on the element. [UIEVENTS]
</p>

<div class="p">
<p class="algo-head">
名前 %e の
`単純~eventを発火する@
ときは、次のようにされた~eventを作成した上で，所与の標的に向けて`配送-$xし~MUST：
</p>

<ul ><li>名前 %e
</li><li>`~trusted$
</li><li>浮上しない（他が定められない限り）
</li><li>取消不可（他が定められない限り）
</li><li>`Event$I ~interfaceを利用する
</li></ul>

◎
Firing a simple event named e means that a trusted event with the name e, which does not bubble (except where otherwise stated) and is not cancelable (except where otherwise stated), and which uses the Event interface, must be created and dispatched at the given target.
</div>


<div class="p">
<p class="algo-head">
名前 %e の
`合成~mouse~eventを発火する@
ときは、次のようにされた~eventを作成した上で，所与の標的に向けて`配送-$xし~MUST：
</p>

<ul ><li>名前 %e
</li><li>`~trusted$（他が定められない限り）
</li><li>浮上しない（他が定められない限り）
</li><li>取消不可（他が定められない限り）
</li><li>`MouseEvent$I ~interfaceを利用する
</li><li>
<p>
~event~objの各種~属性は，次のように初期化する：
</p>
		<ul>
			<li>
( `screenX^m, `screenY^m, `clientX^m, `clientY^m, `button^m )
~SET ( 0, 0, 0, 0, 0 )
</li>
			<li>
［
`ctrlKey^m,
`shiftKey^m,
`altKey^m,
`metaKey^m
］ ~SET ~key入力~装置の現在の状態に則って初期化する（可用でない~keyに対しては ~F にする）
</li>
			<li>
`detail^m ~SET 1
</li>
			<li>
`relatedTarget$m ~SET ~NULL（他が定められない限り）
</li>
			<li>
`view$m ~SET 
所与の標的~nodeの`文書$の`~window$が［
あれば それ／
なければ ~NULL
］
</li>
		</ul>
	</li>
	<li>
~obj上の `getModifierState()^m ~methodは、~eventの作成-時における，~key入力~装置の状態を適切に述べる値を返す
</li>
</ul>

◎
Firing a synthetic mouse event named e means that an event with the name e, which is trusted (except where otherwise stated), does not bubble (except where otherwise stated), is not cancelable (except where otherwise stated), and which uses the MouseEvent interface, must be created and dispatched at the given target. The event object must have its screenX, screenY, clientX, clientY, and button attributes initialised to 0, its ctrlKey, shiftKey, altKey, and metaKey attributes initialised according to the current state of the key input device, if any (false for any keys that are not available), its detail attribute initialised to 1, its relatedTarget attribute initialised to null (except where otherwise stated), and its view attribute initialised to the Window object of the Document object of the given target node, if any, or else null. The getModifierState() method on the object must return values appropriately describing the state of the key input device at the time the event is created.
</div>


<div class="p">
<p class="algo-head">
`click ~eventを発火する@
とは、次のようにされた`合成~mouse~eventを発火する$ことを意味する：
</p>

<ul ><li>名前 `click^et
</li><li>浮上する
</li><li>取消可能
</li></ul>

◎
Firing a click event means firing a synthetic mouse event named click, which bubbles and is cancelable.
</div>


<p>
これらの~eventの既定~動作は、他が定められない限り何もしない。
◎
The default action of these events is to do nothing except where otherwise stated.
</p>

		</section>
	</section>

</main><!-- id="MAIN" -->
