<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Transforms Module Level 1 （日本語訳）</title>

<meta name="keywords" content="変形,座標系,変換,transform,トランスフォーム,CSS,仕様,W3C">

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script >
var source_data;

COMMON_DATA.page_state_key = '___CSS';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://drafts.csswg.org/css-transforms/',
		spec_status: 'ED',
		main: 'MAIN',
//		toc: 'contents',
		fill_text_link: '#_versions > dd, #references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // verified for: 2014-03-24 spec

	return options;
}

function expand(mapping1){
	var link_map = this.link_map;
	var unicode_map = this.unicode_map;
	var class_map = {
		r: 'ref', // 参照文献
		p: 'property', // prop
		svg: 'element', // element
		css: 'css',
		f: 'func', // funcdef
		t: 'type',
		v: 'value',
		vt: 'value',
		vp: 'value',
		vb: 'value',
		NOTE: 'trans-note'
	};
	var tag_map = {
		p: 'code', // prop
		svg: 'code', // element
		css: 'code',
		svg: 'code',
		svgdom: 'code',
		svgattr: 'code',
		m: 'var',
		t: 'var',
		b: 'b',
		f: 'code', // funcdef
		v: 'code',
		vt: 'code',
		vp: 'code',
		vb: 'code',
		V: 'var',
		NOTE: 'span'
	}

	if(!source_data.diagrams){
		source_data.diagrams = Object.create(null);
		repeat('#_resources > *[id]', function(e){
			source_data.diagrams[e.id] = e;
		});
		generate_matrix_markup(source_data.diagrams);
	}
	Util.removeParts(source_data.diagrams);

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/◎[^`<◎]*|【.*?】|%[\wα-ε]+|`(.*?)([$@^!])(\w*)/g,
			create_html
		),
		mapping1
	);

	Util.rebuildToc('MAIN', '_toc_list0');// 目次構築
	Util.replaceParts(source_data.diagrams);// 挿入

	function create_html(match, key, indicator, klass){
if(!indicator) {
	switch(match.charAt(0)){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '◎':
	default:
	}
	return '<span lang="en">' + match.slice(1) + '</span>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'p': // property
/*
	if( indicator === '@') {
		context_prop = '#valdef-' + key + '-';
	}
*/
	href = '#propdef-' + key;
	break;
case 'pe': 
	text = '::' + key;
	break;
case 't': // typedef
	text = '&lt;' + key + '&gt;';
	href= '#typedef-' + key;
	break;
case 'v': // css values
///	href = context_prop + key;
	break;
case 'vt': // transform-origin
	href='#valdef-transform-origin-' + key;
	break;
case 'vp': // perspective-origin
	href='#valdef-perspective-origin-' + key;
	break;
case 'vb': // transform-box
	href='#valdef-transform-box-' + key;
	break;
case 'f': // funcdef
	href = '#funcdef-' + key.toLowerCase();
	text += '()';
	break;
case 'svg': //
	break;
case 'svgdom':
case 'svgattr':
	break;
case 'm': // 行列成分
	text = 'm<sub>' + key + '</sub>';
	break;
case 'b': // css codes
	break;
case 'css': // css codes
	break;
case 'V': // variables
	break;
case 'code': // code
	break;
case 'e': // HTML element
	break;
case 'css': // css codes
	break;
case 'V': // variables
	break;
case 'dgm':
	return '<a id="_dgm-' + key + '">＊</a>';
	break;
case 'cmt':
	return '/* <span class="comment">' + key + '</span> */'
	break;
case 'bug':
	return (
'<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id='
+ key + '">Bug ' + key + '</a>'
	);
default:
//		console.log(match);
//	return match;
}


if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}

	function generate_matrix_markup(diagrams){
		var data = Util.textData('_matrix_data')
.replace( /\s*●(.+)/g,
	'</tbody></table><table id="_dgm-$1" class="_matrix"><tbody>' )
.replace(/[\s\S]*?<\/table>/, '')
.replace(/\n(?=[^<\s])/g, '<tr><td>')
.replace(/,[ \t]*/g, '<td>')
.replace(/%m(\d+)/g, '<var>m<sub>$1</sub></var>')
.replace(/%([\wα-ε]+)/g, '<var>$1</var>')
+ '</tbody></table>';

		var div = C('div');
		div.innerHTML = data;
		for(var e = div.firstElementChild; e; e = e.nextElementSibling){
			if(e.id){
				diagrams[e.id] = e;
			}
		}
	}
}
</script>


<!--%置換語
TODO 文法記号 CSSVAL

-->
<script type="text/plain" id="words_table1">
FXTF:https://drafts.fxtf.org
WIKIJ:http://ja.wikipedia.org/wiki
	BUGS:https://www.w3.org/Bugs/Public/show_bug.cgi
	none:<a class="value" href="#none">none</a>
</script>

<!--%語彙 -->
<script type="text/plain" id="words_table">

	●座標系／行列演算／変形関数
座標空間:coordinate space::~
座標系:coordinate system::~
初期座標系:initial coordinate system::~
利用単位:user unit::~
	座標

変形:transform::~
変換-:transform::~
変換:transformation::~

変換行列:transformation matrix:transformation 行列:~
変形関数:transform function:transform 関数:~
変形要素:transformed element:transformed 要素:~
行列:matrix:~
行列式:determinant:~
転置行列:transpose matrix:~
逆行列:inverse:~
透視投影行列:perspective projection matrix:perspective projection 行列:~
透視行列:perspective matrix:perspective 行列:~
変換原点:transform-origin:transform-原点:変換の原点
恒等:identity:~
	identity transform function:恒等~変形関数
不可逆:non-invertible:~
	項:item:~
変形可能:transformable::~
	~untransformed:未~変形の
	変形が与えられていない
	~transformed:変形され

回転-:rotate::~
回転:rotation::~
回転角:angle:~
角度:angle:~

並進:translation::~
並進-:translate::~
拡縮:scale::~:スケール
拡縮ing:scaling::拡縮:スケーリング
拡縮率:scale::~:スケール
拡大:scale up::~
縮小:scale down::~
斜傾:skew::~:スキュー
斜傾率:shear::~:シアー

写像:mapping:~::マッピング
写像-:map:~::マップ
利用座標系:user coordinate system:user 座標系:~
利用空間:user space::利用座標系
線型:linear:~

補助関数:supporting function:~
遠近法:perspective::~
補間:interpolation:~
補間-:interpolate:~

	飛び出す／映し出す:project:~
射影:projection:~
射影行列:projection matrix:projection 行列:~
射影空間:projective space:~
局所:local:~
局所座標系:local coordinate system:local 座標系:~
累積:accumulation::~
累積-:accumulate::~
	累積して:accumulating
累積3D:accumulated 3D::~
累積的:cumulative::~
累積行列:accumulated matrix:accumulated 行列:~
単位元:neutral element:~
単位行列:identity matrix:~
特異的:singular::~
特異性:singularity::~

再合成-:recompose::~
再合成法:recomposing::~
複合的:composite:~
合成-:composite:~

分解-:decompose::~
分解:decomposition::~
分解法:decomposing::~
派生:derivative::~
派生-:derive::~
派生関数:derived transform function:derived transform 関数:~
原始関数:primitive:~
二乗根:root square:~
余弦:cosine:~
正弦:sine:~
逆余弦:inverse cosine:~
換算-:convert:~
換算:conversion:~
	converting
	後置積:post-multiplied
	前置積:pre-multiply
四元数:quaternions::~
等式:equation:~
	右辺:right hand side
直交:orthogonal::~
直交-:orthogonalize::~
	unflip

原点:origin:~
斉次:homogeneous::~
有限:finite:~
次元:dimension:~
寸法:dimension:~
正規化:normalize::~
無限:infinite:~
無限小:infinitesimal:~
	無限小:infinitesimal small／thickness
無限遠:infinitely far:~
球面:spherical::~
vector:::ベクトル
scalar:::スカラー
実数:number:~
点乗積:dot product::~
演算:operation:~
作用-:operate:~
作用:operation:~
	~~作用／干渉:interact


	●幾何
3D:
2D:
交差-:intersect::~
交差:intersection::~
	交錯
	位置:location:~
裏側:reverse side:~
裏返す:flip する:~
裏返され:flip され:~
裏表に:back-to-back に:~
	貼り合わせる:place 〜 back-to-back
裏面:back:~
裏面可視性:backface visibility:裏面の可視性
表側:front side:~
表面:front:~
	前面
	~front-to-back
	上方:upward:~
上端:top:~
左端:left:~
下端:bottom:~
右端:right:~
	右端:rightmost:~
	中心:center:~
	左:left:~
	右:right:~
	右上:top-right:~
	右下:lower right:~
	左:left:~
	中心に位置する:centered:~
五角形:pentagon:~
三角形:triangle:~
四辺形:quadrilateral:~
矩形:rectangle:~
多角形:polygon:~
四角錐:pyramid:~
	円:circle:~
	四半周:quarter turn:~
時計回り:clockwise:~

垂直:perpendicular:~
平面:plane:~
不可視:invisible:~
可視:visible:~
可視性:visibility:~
領域:area:~
消失点:vanishing point:~
深度:depth:~
	深度~順に基づいてdepth-sort
奥行き:depth:~
横幅:width:~
縦幅:height:~
度数:degree:~
	°

横:horizontal:~
	~ly
縦:vertical:~
	~ly
横縦:horizontal and vertical:横＆縦
横位置:horizontal position:~
縦位置:vertical position:~


放射型:radial:~
無視-:ignore:~

空間:space:~

視点:viewer:~
	視点:viewer’s eye:~

距離:distance:~
軸:axis:~
	axes
座標軸:axes:~
座標:coordinate:~
辺:edge:~
隅:corner:~
頂点:vertex:~



	●アニメーション
加法:addition::~
加法的:additive::~
効果:effect:~
基底値:base value::~
呈示属性:presentation attribute:presentation 属性:~:プレゼンテーション属性

反転:flip:~
離散的:discrete::~
始値:source:始値-
終値:destination:終値-
値域:domain:~

animation:::アニメーション
animate:::アニメート
	animating:している
	animate可能:animatable
遷移:transition:~

	●CSS レイアウト
grouping::グループ化
group::グループ

layout:::レイアウト
容器:container::コンテナ
flow:::フロー
overflow:::過フロー:オーバーフロー
塊:block::ブロック
塊level:block-level::ブロックレベル
行内level:inline-level::行内レベル:インラインレベル
不可分な:atomic:~
canvas:::キャンバス
頁:page::ページ
box:::ボックス
限界:bounding
	限界~box:bounding box
基準:reference:~
	基準~box:reference box
確立-:establish:~
	establishing
整形:formatting:~
包装:wrapper:~
包含:containing:~
包含-:contain:~
包含塊:containing block:包含 block:包含ブロック
統制:govern:~
border:::ボーダー
描画-:render::~
描画:rendering::~
描画文脈:rendering context:rendering 文脈:~
表示域:viewport:~
積層文脈:stacking context:~
積層順:layering:~
文脈:context:~
size:::サイズ
scroll:::スクロール
	scrolling
scrollbar:::スクロールバー
関与:participation:~
関与-:participate:~
	関与している:participating:~
固定位置:fixed positioned:~
位置決:positioning:位置決め
装飾:decoration:~

	●CSS

space:::スペース
comma:::カンマ
丸括弧:parenthesis:~
	〜に限定された機能:subset:~
style:::スタイル
	スタイルing:styling:~
	~style付け:styling:~
	~style付けされた:styled:~
stylesheet:style sheet::スタイルシート

単位:unit:~

成分:component:~
単純:simple:~


名前:name:~
名前空間:namespace:~
文書:document:~
構文:syntax:~
構文解析-:parse:~::パース
無効:invalid:~
	分量:quantity:~
初期時:initial 時:~
制御:control:~
妥当:valid:~
根:root::~:ルート
子孫:descendant:~
	子:child:~
入子に:nest:入れ子に::ネスト
親:parent:~
要素:element:~
属性:attribute:~
table:::テーブル
fall-back:fall back::フォールバック
fallback:::フォールバック
cascade:::カスケード
keyword:::キーワード
prop:property:プロパティ
利用不可:N/A:~
長さ:length:~
省略可:optional:~
画素:pixel:ピクセル
百分率:percentage:~
背後:behind:~

空白:whitespace:~
	whitespace characters
算出-:compute:~
算出:computation:~
算出style:computed style:算出 style:算出スタイル
絶対値:absolute value:~

絶対:absolute:~
絶対長:absolute length:~
相対:relative:~
相対的:relative:~
相対長:relative length:~
置換-:replace:~
背景:background:~
背景画:backdrop:~
色:color:~
詳細度:specificity:~
識別子:identifier:~

関数:function:~
	関数名:function name:~
関数記法:functional notation:~

視覚:visual:~
視覚的:visual:~
表示-:display:~
表示:display:~
解決値:resolved value:~
使用値:used value:~
算出値:computed value:~
指定値:specified value:~
下層値:underlying value:~
初期値:initial value:~
継承:inherit:~
適用対象:applies to:~
利用不可:N/A:~

呈示hint:presentational hint:呈示ヒント::プレゼンテーション上のヒント
媒体:media::~:メディア

値:value:~
先祖:ancestor:~
作成-:create:~
	作成して:creating:~
	全体:entire:~
内容:content:~
hover:
列主導:column-major:~

	●仕様
値単位Module:CSS Values and Units Module: “CSS の値と単位” モジュール
client:
仕様:spec:~
作者:author:~
互換性:compatibility:~
後方互換性:backwards compatibility:~
定義-:define:~
定義:definition:~
未定義:undefined:~
実装-:implement:~
実装:implementation:~
実装依存:implementation-dependent:~
依存-:depend:~
依存:dependent:~
実装者:implementer:~
利用者:user:~
UA:
feedback:::フィードバック
module:::モジュール
support:::サポート
version:::バージョン
指定-:specify:~
既定:default:~
旧来の:legacy:~
変更点:changes:~
将来:future:~
相互作用:interactions:~
規約:conventions:~
上書き:override:~
現在の:current:~
	現在:currently

	●一般語
封入-:enclose:~
連鎖:chain:~
文法:grammar:~
直列化-:serialize:~
直列化:serialization:~
数学的:mathematical:~
数値的:numerical:~
風景:scene:~
事例:case:~
基底:base:~
記数法:notation:~
	点:point:~
stroking:::ストローク法
手法:method:~
同胞:sibling:~
外観:appearance:~
導入-:introduce:~
技法:technique:~
挿入-:insert:~
提供-:provide:~
決定-:determine:~
通常:normal:~
適用-:apply:~
	applying

平坦:flat:~
平坦化-:flatten:~
平坦的:flattening:~

不透明度:opacity:~
filter:::フィルタ
clipping:::クリッピング
gradient:::グラデーション
model:::モデル
screen:::スクリーン
	スクリーン外:off-screen:~
member:::メンバ
radian:::ラジアン
	利用中:active:~
	インスタンス:instance:~
	〜化:instantiated
interface:::インタフェース
公開-:expose:~
offset:::オフセット
object:::オブジェクト
graphics:::グラフィックス
擬似code:pseudo code:擬似コード
click:::クリック
ゼロ:zero:~
text:::テキスト
data:::データ
dot:::ドット
	パタン:pattern:~
parameter:::パラメタ
list:::リスト
アルゴリズム:algorithm::~
access:::アクセス
狭小:narrow:~
共有-:share:~
	同じ〜に共存:share a common〜
順序:order:~
科学的:scientific:~
環境:environment:~
等価:equivalent:~

	交換:switch:~
	側:side:~
	不在:absence:~
	引数:argument:~
拡張-:extend:~
拡張:extension:~
	上段:top:~
絵図:drawing:~
階層:hierarchy:~
表記:notation:~

図式:diagram:~
固定:anchor:~
固定長:fixed length:~
型:type:~

	基本的:basic:~
	基本~data型:Basic data types:~
方向:direction:~
明示的:explicit:~
遠近感:foreshortening:~

即時:immediate:~
概念的:conceptual:~
概念0:notion:概念
機能性:functionality:~
機能的:functional:~
正確:exact:~
	続行:proceed:~

交互:alternate:~
展開-:expand:~
期待-:expect:~
精確:precise:~
舞台:stage:~
	遊戯用カード:playing card:~
card:::カード
規則:rule:~
受容:accept:~
合致:match:~
寄与:contribute:~
	対:pair:~
	対応している:corresponding:~
	対応付け:mapping:~
解決-:resolve:~
解釈-:interpret:~
言語:language:~
	計算:calculate:~
記述:description:~
許容-:allow:~
論拠:reasoning:~
	参照:reference:~
	参照元:referencing:~
反映-:reflect:~
影響-:affect:~
競合-:conflict:~
要件:requirement:~
表現-:represent:~
表現:representation:~
情報:information:~
	混成:mixture:~
	理想的:ideal:~
強制-:force:~
生成-:generate:~
texture:::テクスチャ
memory:::メモリ
構築:construction:~
構築-:construct:~
特別な:special:~
特定の:specific:~
特殊:special:~
汎的:generic:~
状態:state:~
状況:situation:~
組合せ:combination:組み合せ
挙動:behavior:ふるまい
巻上げら:hoist up さ:巻き上げら
新たな:new:~

</script>

<!--%他の語

web
指す:address
下段:bottom:~
おいて:~duration
ごとに固有:-specific

first pass at an attempt to precisely specify how exactly
どの程度~正確に〜を精確に指定するための最初の試案
~animateされる属性:~target attribute

積をとる:~multiply
	1:~multiple
	1:~multiplication
	2:~multiplying
	4:~multiply
	multiplied
	using
	~aboutおよそ
	~factor
	~parameter引数
	~processing処理
	全部:whole thing

〜からなる:consists
〜に向かって:towards
〜に従って:according
〜の代わりに:instead
〜下の:contained
〜倍に:factor
いくつかの:several
いずれにせよ:anyway
おそらく:perhaps
ずっと:much
ずっと困難:much harder
ずれ:offset
の効力により:by virtue of
動作する
ふるまう:act
もの:one
ゆえに:consequence
より大きい:greater
より大きい:larger
より容易く:easier
より小さく:smaller
より近く:closer
より遠い:further away
十分に遠いvery far
非常に広大enormous
中央middle

カメラ: 1
テスト:test 1
扉が開く様に:swings closer
一定位置: 1
一方: 3
一時変数: 1
一時的:temporarily
一般に
一連: 9
一連のcollection
一部: 5
一部分:part
上段: 1
上述: 4
下位節:subsections
下向き:downwards 1
下図: 2
下方: 1
不可: 3
不可分: 1
不変: 5
不要: 1
与えられ:given
両側: 1
両者:both 3
中心: 7
中程度:moderate 1
仕方／方法way
他方: 1
付録: 1
以下: 11
以外: 12
仮想: 1
任意: 7
位置:position 22
位置取り:located 1

作用:operate 1
例:example
例示:demonstration 1
依然として:still
修正: 1
俯瞰:looking at
個数の:number of
傾けられて:tilting out
元々は:originally
元の:original
先立: 1
先頭: 1
入力:input 6
出力:output 5
全体:complete 1
共存: 2
共通の:common 4
内側の:inner
内面inside~faces
再度: 1
処理: 1
分量: 1
分離:isolate 1
	切り取った:cut out
	切り取られて:chopped off
	切り取り:truncating
	切り取る:slice away
初期化: 3
判明tested 1
別の:another
利用-:use
利用: 37
〜量に関わらず，:No matter how far
前の例:previous example
前後: 1
前段落: 1
前節: 2
前節による:former
前者: 1
前面から後面への
手前から奥~front-to-back 1
後面から前面
奥から手前back-to-front

加えられる変更:modifications
加算added 1
効力を発揮する:comes into play 1
動的:live 1
勧める:advised／suggested
区切: 2
半分:half 1
単独の:single 1
単純化-:simplify 1
	原点:origin of point
	原点:point of origin
参照: 7
参照元: 2
参考: 1
取り込む:incorporate
可能:possible 10
可能性:possibility:~
可読性:readability:~
右向: 1
右方: 1
右辺: 1
各節: 1
各行: 1
合間:between 2
同じ:same
一致する／同じに:identical
向く 3.001faces
向上させる:improve
含む:includes
周:turns
周囲: 1
呼ばれる:called
呼応: 1
問題:problem 1
三次元: 1
二次元: 1
四次元:four-dimensional 1
2D:two-dimensional
3D:three-dimensional
四隅: 1
困難: 1
固定
固有: 2
地点: 2
埋めるfills
基づくbased
基本: 2
基準: 3
場合: 52
塗り:painting
増大:increase ２
正の:increases
変動: 1
変化: 1
変更:change 5
変更を加える:modify
外側:outside 2
大きく越えて:far past
大抵: 1
失われ:get lost
子schildren
存在-:exist
定速:paced
実線:solid outline 1
実行:execute 1
実行:run

実質的:effective:~
実際:actual 1
容易に／簡単に:easily
対応: 8
対象: 1
小さいsmall
属している:live in
属する
左上:upper-left 5
左上隅:top-left／top-left corner 2
常に:always
干渉: 1
平面的:as flat planes 1
flat surface
序論: 1
引き延ばされる:stretched over／stretch~out
当該の:in question／respective
影響を受ける:influenced波及
~~影響impact
後者: 2
後述: 3
得られるobtained
必要なnecessary／
想定: 2
意味-:mean:~／
感:feeling
成分:parameter
成分値: 2
手前:in front 2
~~手続きprocedure: 1
手続き:steps
改め:alter:
扱われ:treated
抜けている
抽出: 1
拡張:enhanced 1
指す先からend
指示:instruction 1
挙げられ:listed
据えるsits
換算: 1
操作:working with 1
方法: 3
既存の:existing 1
既知の:known
明確さに欠ける:needs clarification
時点: 2
最初の:first 11
最後の:last 1
最大値: 1
最終的な:final: 2
有効:effective:~／in effect
有用:useful
望まれ:desired
望まれる:desirable
末尾: 1
本物らしく:realistic
極小very~small
極度の:extreme 1
様子: 1

橙色:orange
水色:light blue 1
青色:blue
黄緑色:lime
黄色の:yellow
機能: 2
次元の:dimensional
次節: 1
次項: 1
歓迎するencouraged 1
正の:positive
正味の効果:net effect 1
正方向: 2
残りの部分rest
段落:paragraphs
比例する:proportional 1
決定: 1
注意: 1
渡され:passed
満たす:fulfill
滑らかな:smooth
点線:dashed 1
無限大: 1
無限遠点: 1
片方: 3
特に:in particular
特定: 1

現れる:appear する
理由: 1
用法:usage
用語: 2
画面:drawing plane 6
画面:plane of the screen
番目: 9
異なる:different
手法:method
省略: 2
真正面: 1
確保-:ensure 1
移動: 2
移動量: 9
移動／変動するmoves
程度: 1
等しい:equal
等しく:equally
節:section
簡便な:convenient 1
細分: 1
結果:result 8
結果の:resulting
統合:convergence 1
統合:integration
編集上の:editorial
縮退: 1
織り込まれるtakes~into~account
織り込みaccounting
繰り返され:repeated
繰り返し模様:repeating
考えられる:thought
自体: 1
自身: 2
薄さ:thickness
遂行:perform:~
行って:performing
行われ:performed
表され:expressed
補完: 1
複数: 1
複数個: 2
複製: 1
要する:require
要求-:require:~
覆う:cover
覆う:obscure
見なされ:assumed
見なすconsidered
規定: 1
視点:the same place the viewer is looking from
視聴者の目の位置
視覚的にvisibly
視野:field of vision
解く:solve
言い回し:wording
計算結果: 1
記す:write
設定して:by setting 2
試案: 1
詳細: 1
誇張:pronounced 1
調べる:looking at
負の:negative
近さclose
近付: 2
近似: 1
述べられ:described
述べる:describes
追加の:additional 1
逆方向: 2
遠く:far
遠く離れた:faraway
適切な:appropriate 1
選ばれる:chosen
避ける:avoid
部分:part 2
配列:array 1
量:amount
鏡:sheet of glass
鏡像:mirror-image 1
鏡像をとるmirroring
開始: 1
限りなく近付ける:bringing the box closer and closer
限定: 2
除去: 1
隣接: 1
集合: 3
面積:typical geometric size 1
領域を更に細分:subdividing
類似する:similar
検査: 1
検証: 1

飛び出すpop out
実質的:effective:~
考慮-:consider:~
帰結としてConsequently
それぞれが所有するown
関連するrelevant
同一~平面にあるcoplanar
浸出interpenetrate
厳密化 tightening up
効率的なefficient
割り当てるallocate
-->

<!-- 
http://www.w3.org/TR/css3-values/
→~CSSWG/css-values-3/
http://www.w3.org/TR/css-overflow-3/#overflow
→~CSSWG/css-overflow-3/#propdef-overflow
http://www.w3.org/TR/css3-positioning/
→~CSSWG/css-position-3/
http://www.w3.org/TR/filter-effects/
→http://dev.w3.org/fxtf/filters/
http://www.w3.org/TR/css-masking/
→http://dev.w3.org/fxtf/masking/
http://www.w3.org/TR/compositing-1/
→http://dev.w3.org/fxtf/compositing-1/
http://www.w3.org/TR/svg2/
→https://svgwg.org/svg2-draft/

(id=funcdef-\w+)\s+title=[^>]*
→$1

http://dev.w3.org/fxtf/
	https://drafts.fxtf.org/
 -->

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
viewer:
notes-on-accumulation:
</script>

<!--%links -->
<script type="text/plain" id="_link_map">

	●types `t
	t.transform-function:#typedef-transform-function
	t.transform-list:#typedef-transform-list

	●types `t external
t.angle:~CSSVAL#angle-value
t.length:~CSSVAL#length-value
t.number:~CSSVAL#number-value
t.percentage:~CSSVAL#percentage-value
t.position:~CSSBG#position

	●property `p
	p.backface-visibility:#propdef-backface-visibility
	p.perspective-origin:#propdef-perspective-origin
	p.perspective:#propdef-perspective
	p.transform-origin:#propdef-transform-origin
	p.transform-style:#preserve-3d:#propdef-transform-style
	p.transform-style:#propdef-transform-style
	p.transform:#propdef-transform

	●property `p external
p.fill:~SVG11/painting.html#FillProperty
p.stroke:~SVG11/painting.html#StrokeProperty
	SVG2
p.display:~CSS2VISUREN#propdef-display
p.filter:~FXTF/filters/#propdef-filter
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.position:~CSSWG/css-position-3/#propdef-position
p.z-index:~CSSWG/css-position-3/#propdef-z-index
p.vector-effect:~SVG2/painting.html#VectorEffectProperty
p.opacity:~CSSCOLOR#propdef-opacity
	opacity:~CSSWG/css-color-3/#opacity
	※
p.background-attachment:~CSSBG#background-attachment
p.clip-path:~FXTF/masking/#propdef-clip-path
p.clip:~FXTF/masking/#propdef-clip
p.isolation:~COMPOSITING#propdef-isolation
p.mask-image:~FXTF/masking/#propdef-mask-image
p.mask-border-source:~FXTF/masking/#propdef-mask-border-source
p.mix-blend-mode:~COMPOSITING#propdef-mix-blend-mode


	●values external
	v.hidden:~CSSBG#hidden
	v.none:~CSSBG#fixed
	v.none:~CSSWG/css-animations-1/#valdef-animation-name-none
	v.scroll:~CSSBG#scroll
	v.auto:~CSSWG/css-align-3/#valdef-justify-content-auto
	v.isolate:~CSSWG/css-writing-modes-3/#valdef-unicode-bidi-isolate
	v.visible:~CSSOVERFLOW3#valdef-overflow-visible
	v.normal:~COMPOSITING#valdef-blend-mode-normal
	v.linear:~TRANSITION#valdef-transition-timing-function-linear
	block-level:~CSS2VISUREN#block-level
	atomic inline-level element:~CSS2VISUREN#x13
	p.display:~CSS2VISUREN#propdef-display

	＊
	v.table-row:~CSSDISP#valdef-display-table-row
	v.table-row-group:~CSSDISP#valdef-display-table-row-group
	v.table-header-group:~CSSDISP#valdef-display-table-header-group
	v.table-footer-group:~CSSDISP#valdef-display-table-footer-group
	v.table-cell:~CSSDISP#valdef-display-table-cell
	v.table-caption:~CSSDISP#valdef-display-table-caption


	●funcdef `f
	f.matrix():#funcdef-matrix
	f.matrix3d():#funcdef-matrix3d
	f.perspective():#funcdef-perspective
	f.rotate():#funcdef-rotate
	f.rotate3d():#funcdef-rotate3d
	f.rotateX():#funcdef-rotatex
	f.rotateY():#funcdef-rotatey
	f.rotateZ():#funcdef-rotatez
	f.scale():#funcdef-scale
	f.scale3d():#funcdef-scale3d
	f.scaleX():#funcdef-scalex
	f.scaleY():#funcdef-scaley
	f.scaleZ():#funcdef-scalez
	f.skew():#funcdef-skew
	f.skewX():#funcdef-skewx
	f.skewY():#funcdef-skewy
	f.translate():#funcdef-translate
	f.translate3d():#funcdef-translate3d
	f.translateX():#funcdef-translatex
	f.translateY():#funcdef-translatey
	f.translateZ():#funcdef-translatez

	v.none:#none
	~center:valuedef-center
	~center:valuedef-center0

f.calc:~CSSVAL#funcdef-calc

		● local
~2D 3x2 行列:#MatrixDefined
~2D回転:#RotateDefined
~2D拡縮:#ScaleDefined
	~2D斜傾 transformation along the Y axis:#SkewYDefined
~2D斜傾:#SkewDefined
~2D並進:#TranslateDefined
~3D変形による描画:#3d-transform-rendering
~3D回転:#Rotate3dDefined
~3D拡縮:#Scale3dDefined
~3D並進:#Translate3dDefined
X 軸~不変の~2D斜傾:#SkewXDefined
Y 軸~不変の~2D斜傾:#SkewYDefined
透視投影行列:#PerspectiveDefined

	transformation matrix:#MatrixDefined
並進ion:#TranslateDefined

変形の補間:#interpolation-of-transforms
行列の補間:#matrix-interpolation
変形関数の補間:#interpolation-of-transform-functions
変形関数の数学的~記述:#mathematical-description
SVG ~animation:#svg-animation
	SVG ~data型:#svg-data-types
	~Transitions~and~Animations~between~Transform~Values:#interpolation-of-transforms

	below:#accumulated-3d-transformation-matrix-computation
	below:#perspective-matrix-computation
	below:#transformation-matrix-computation

平坦的~要素:#flattening-elements
平坦的:#flattening-elements
基準~box:#reference-box
変形可能:#transformable-element
利用座標系:#user-coordinate-system
局所座標系:#local-coordinate-system
変形要素:#transformed-element
~3D変形要素:#3d_transformed-element

透視行列:#perspective-matrix
変換行列:#transformation-matrix
現在の変換行列:#current-transformation-matrix-ctm
累積~3D変換行列:#accumulated-3d-transformation-matrix
累積~3D変換行列の算出:#accumulated-3d-transformation-matrix-computation
~2D行列:#2d-matrix
~3D行列:#3d-matrix
恒等~変形関数:#identity-transform-function
~3D描画文脈:#3d-rendering-context
~grouping~prop値:#grouping-property-values

関数記法:#svg-functional-notation
~interpolation~of~two~2D~matrices:#interpolation-of-2d-matrices
~interpolation~of~two~matrices:#interpolation-of-3d-matrices

実数:#svg-number

	~primitive:#transform-primitives
	~rotate~with~three~arguments:#svg-transform-functions

構文:#svg-syntax
~3D変形:#three-d-transform-functions
~3D変形関数:#three-d-transform-functions
変形関数:#transform-functions
	~transform:#interpolation-of-transforms
視点:#viewer

原始関数:#transform-primitives
	派生関数:#transform-primitives

	●SVG `svg
		//SVG element
svg.a:~SVG11/linking.html#AElement
svg.animate:~SVG11/animate.html#AnimateElement
svg.animateColor:~SVG11/animate.html#AnimateColorElement
svg.animateTransform:~SVG11/animate.html#AnimateTransformElement
svg.clipPath:~SVG11/masking.html#ClipPathElement
svg.foreignObject:~SVG11/extend.html#ForeignObjectElement
svg.g:~SVG11/struct.html#GElement
svg.linearGradient:~SVG11/pservers.html#LinearGradientElement
svg.mask:~SVG11/masking.html#MaskElement
svg.pattern:~SVG11/pservers.html#PatternElement
svg.radialGradient:~SVG11/pservers.html#RadialGradientElement
svg.rect:~SVG11/shapes.html#RectElement
svg.set:~SVG11/animate.html#SetElement
svg.svg:~SVG11/struct.html#SVGElement

		//SVG dom `svgdom
svgdom.SVGAnimatedTransformList:~SVG11/coords.html#InterfaceSVGAnimatedTransformList
svgdom.SVGMatrix:~SVG11/coords.html#InterfaceSVGMatrix
svgdom.SVGTransform:~SVG11/coords.html#InterfaceSVGTransform
svgdom.SVG_TRANSFORM_UNKNOWN:~SVG11/coords.html#__svg__SVGTransform__SVG_TRANSFORM_UNKNOWN
svgdom.matrix:~SVG11/coords.html#__svg__SVGTransform__matrix
svgdom.type:~SVG11/coords.html#__svg__SVGTransform__type

		//SVG attr `svgattr
svgattr.gradientTransform:~SVG11/pservers.html#LinearGradientElementGradientTransformAttribute
svgattr.gradientUnits:~SVG11/pservers.html#LinearGradientElementGradientUnitsAttribute
svgattr.maskUnits:~SVG11/masking.html#MaskElementMaskUnitsAttribute
svgattr.patternTransform:~SVG11/pservers.html#PatternElementPatternTransformAttribute
svgattr.patternUnits:~SVG11/pservers.html#PatternElementPatternUnitsAttribute
svgattr.patternTransform:~SVG11/pservers.html#PatternElementPatternTransformAttribute
svgattr.attributeName:~SVG11/animate.html#TargetAttributes
svgattr.transform:~SVG11/coords.html#TransformAttribute
svgattr.calcMode:~SVG11/animate.html#CalcModeAttribute
svgattr.viewBox:~SVG11/coords.html#ViewBoxAttribute

		//SVG term
容器~要素:~SVG11/intro.html#TermContainerElement
~graphics要素:~SVG11/intro.html#TermGraphicsElement
~graphics参照~要素:~SVG11/intro.html#TermGraphicsReferencingElement
呈示属性:~SVG11/intro.html#TermPresentationAttribute
新たな作者~stylesheet:~SVG11/styling.html#UsingPresentationAttributes
基本~data型:~SVG11/types.html#DataTypeNumber
	number:~SVG11/types.html#DataTypeNumber
~animate可能な要素, 属性, ~prop:~SVG11/animate.html#complexDistances
初期座標系:~SVG11/coords.html#InitialCoordinateSystem
基底値:~SVG11/animate.html#
利用単位:~SVG11/intro.html#TermUserUnits
~object限界~box:~SVG11/types.html#__svg__SVGLocatable__getBBox
	~SVG2/coords.html#TermObjectBoundingBox
	~SVG11/intro.html#TermUserUnits
	下層値
SVG 表示域:~SVG11/intro.html#TermSVGViewport

	●css2
	付録 E:~CSS22/zindex.html
CSS ~prop定義~規約:~CSS22/about.html#property-defs
視覚~整形~model:~CSS2VISUREN


	塊level~box:block-level-box
	塊level:block-level
	塊~容器:block-container
	塊~容器~box:block-container
	塊~box:block-box
	塊:block
	包含塊:containing-block
	初期~包含塊:initial-containing-block
	行内level~box:inline-level-box
	行内level:inline-level
	行内:inline
	不可分な行内:atomic-inline


包含塊:~CSSDISP#containing-block
包含している塊:~CSSDISP#containing-block
	~CSS2VISUREN#containing-block
塊level:~CSSDISP#block-level
	~CSS2VISUREN#block-level
不可分な行内level:~CSSDISP#atomic-inline
	~CSS2VISUREN#x13

積層文脈の順序:~CSS22/zindex.html#painting-order
積層文脈:~CSS2VISUREN#x44
~table包装~box:~CSS22/tables.html#model
	使用値:~CSS22/cascade.html#used-value
inherit:~CASCADE#value-def-inherit
使用値:~CASCADE#used-value
算出値:~CASCADE#computed-value

固定された背景:~CSSBG#fixed0
根~要素に対する背景~塗り領域:~CSSBG#special-backgrounds
~border~box:~CSS2BOX#box-dimensions

		//Transitions css3-transitions
CSS3 Transitions:http://www.w3.org/TR/css-transitions/
長さ, 百分率, calc 式:~TRANSITION#animtype-lpcalc
長さ:~TRANSITION#animtype-length
単純~list:~TRANSITION#animtype-simple-list

	//cssom
	getBoundingClientRect():~CSSOMVIEW#dom-element-getboundingclientrect
	getClientRects():~CSSOMVIEW#dom-element-getclientrects
解決値:~CSSOM#resolved-value

	詳細度:http://www.w3.org/TR/2013/CR-css-cascade-3-20131003/css-cascade-ja.html#preshint

射影平面:~WIKIJ/%E5%B0%84%E5%BD%B1%E5%B9%B3%E9%9D%A2
射影空間:~WIKIJ/%E5%B0%84%E5%BD%B1%E7%A9%BA%E9%96%93
ジンバルロック:~WIKIJ/%E3%82%B8%E3%83%B3%E3%83%90%E3%83%AB
オイラー角:~WIKIJ/%E3%82%AA%E3%82%A4%E3%83%A9%E3%83%BC%E8%A7%92
四元数:~WIKIJ/%E5%9B%9B%E5%85%83%E6%95%B0
Newell のアルゴリズム:http://en.wikipedia.org/wiki/Newell%27s_algorithm
	http://en.wikipedia.org/wiki/Gimbal_lock
	http://en.wikipedia.org/wiki/Euler_angles
	http://en.wikipedia.org/wiki/Quaternion


</script>


<!--%links


		//SVG misc
SVG 1.1 Animation:~SVG11/animate.html
transform 属性:~SVG11/coords.html#TransformAttribute
新たな作者~stylesheet:~SVG11/styling.html#UsingPresentationAttributes

attributeName:https://svgwg.org/svg2-draft/animate.html#AttributeNameAttribute
	//external
無限遠:http://en.wikipedia.org/wiki/Plane_at_infinity

-->


<!--%style -->
<style>
small.cp {
	color: gray;
}

td[colspan] {
	text-align:center;
}

.proddefs > dt {
	color: #005a9c;
	font-family: monospace0, monospace;
}


#supporting-functions-table > tr > td:first-child {
	font-family: monospace0, monospace;
}

.upper-alpha > li {
	list-style-type: upper-alpha;
}

._matrix tr {
	border: none;
}
._matrix td {
	text-align: center;
}
._matrix {
	border-collapse: separate;
	border-spacing: 0;
	border:solid black 1px;
	border-style: none solid;
	border-radius: 5px;
}

</style>

<script type="text/plain" id="_matrix_data">
●3x3matrix
%a, %c, %e
%b, %d, %f
0, 0, 1

●4x4matrix
%m11, %m21, %m31, %m41
%m12, %m22, %m32, %m42
%m13, %m23, %m33, %m43
%m14, %m24, %m34, %m44

●matrix
%a, %c, 0, %e
%b, %d, 0, %f
0, 0, 1, 0
0, 0, 0, 1

●skew
1, tan( %α ), 0, %e
tan( %β ), 1, 0, %f
0, 0, 1, 0
0, 0, 0, 1

●skewX
1, tan( %α ), 0, 0
0, 1, 0, 0
0, 0, 1, 0
0, 0, 0, 1

●skewY
1, 0, 0, 0
tan( %β ), 1, 0, 0
0, 0, 1, 0
0, 0, 0, 1 

●translate3d
1, 0, 0, %tx
0, 1, 0, %ty
0, 0, 1, %tz
0, 0, 0, 1 

●scale3d
%sx, 0, 0, 0
0, %sy, 0, 0
0, 0, %sz, 0
0, 0, 0, 1

●rotate3dmatrix
1 − 2⋅( %y⋅%y + %z⋅%z )⋅%ss, 2⋅( %x⋅%y⋅%ss − %z⋅%sc ), 2⋅( %x⋅%z⋅%ss + %y⋅%sc ), 0
2⋅( %x⋅%y⋅%ss + %z⋅%sc ), 1 − 2⋅( %x⋅%x + %z⋅%z )⋅%ss, 2⋅( %y⋅%z⋅%ss − %x⋅%sc ), 0
2⋅( %x⋅%z⋅%ss − %y⋅%sc ), 2⋅( %y⋅%z⋅%ss + %x⋅%sc ), 1 − 2⋅( %x⋅%x + %y⋅%y )⋅%ss, 0
0, 0, 0, 1

●perspective
1, 0, 0, 0
0, 1, 0, 0
0, 0, 1, 0
0, 0, −1/%d, 1
</script>
<!-- 
	●rotate3dvariables
newline sc = sin (%α/2)⋅cos (%α/2) newline sq = sin^2 (\alpha/2)

 -->


</head>

<body>


<div style="display:none;">
<input type="hidden" id="_page_config" value="" />

<!--%resource pool -->
	<div id="_resources">

<img id="_dgm-coordinates"
	src="css-transforms/coordinates.svg"
	height="240" width="270"
	alt="Demonstration of the initial coordinate space"
>

<img id="_dgm-translate1"
	src="css-transforms/translate1.svg"
	height="250" width="470"
	alt="The 100px translation in X and Y"
>

<img id="_dgm-origin1"
	src="css-transforms/origin1.svg"
	height="250" width="735"
	alt="The point of origin gets translated temporary"
>

<img id="_dgm-compound_transform"
	height="270" width="270"
	src="css-transforms/compound_transform.svg"
	alt="The transform specified above"
>

<img id="_dgm-simple-3d-example"
	height="190" width="210"
	src="css-transforms/simple-3d-example.png"
	alt="Div with a rotateY transform."
>

<img id="_dgm-perspective_distance"
	height="600" width="600"
	src="css-transforms/perspective_distance.svg"
	alt="Diagram of scale vs. Z position"
>

<img id="_dgm-perspective_origin"
	height="300" width="600"
	src="css-transforms/perspective_origin.svg"
	alt="Diagram of different perspective-origin"
>

<img id="_dgm-simple-perspective-example"
	src="css-transforms/simple-perspective-example.png"
	height="190" width="210"
	alt="Div with a rotateY transform, and perspective on its container"
>

<img id="_dgm-3d-intersection"
	src="css-transforms/3d-intersection.png"
	height="198" width="210"
	alt="Intersecting sibling elements."
>
<img id="_dgm-3d-rendering-context-flat"
	src="css-transforms/3d-rendering-context-flat.png"
	height="200" width="240"
	alt="Nested 3D transforms, with flattening"
>

<img id="_dgm-3d-rendering-context-3d"
	src="css-transforms/3d-rendering-context-3d.png"
	height="200" width="240"
	alt="Nested 3D transforms, with preserve-3d."
>

<img id="_dgm-svg-translate1"
	src="css-transforms/svg-translate1.svg"
	height="240" width="470"
	alt="Translated SVG container element."
>


	</div>
</div>

<aside class="trans-meta">
<h1>CSS Transforms Module Level 1 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong>編集者草案</strong>として公開された
<a id="_SPEC_URL">CSS Transforms Module Level 1</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2015-10-15</time>
（公開：<time>2014-04-04</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>
<div><a href="http://www.w3.org/" id="_W3C">W3C</a></div>

<h1 id="title">CSS による座標系変換 — CSS Transforms Module Level 1</h1>
<h2 id="subtitle">2015 年 8 月 19 日付 W3C 編集者草案</h2>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dt title="Editor’s Draft:">編集者草案</dt>
	<dd>https://drafts.csswg.org/css-transforms/</dd>

	<dt title="Latest version:">最新発行バージョン</dt>
	<dd>http://www.w3.org/TR/css3-transforms/</dd>

	<dt title="Previous Versions:">以前のバージョン</dt>
	<dd>http://www.w3.org/TR/2012/WD-css3-transforms-20120911/</dd>
	<dd>http://www.w3.org/TR/2012/WD-css3-transforms-20120403/</dd>

	<dt title="Test Suite:">テスト一式</dt>
	<dd>http://test.csswg.org/suites/css-transforms-1_dev/nightly-unstable/</dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="https://github.com/w3c/csswg-drafts/issues/">GitHub</a></dd>
	<dd><a href="#issues-index">仕様内</a></dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="mailto:simon.fraser@apple.com">Simon Fraser</a> (Apple Inc)</dd>
	<dd><a href="mailto:dino@apple.com">Dean Jackson</a> (Apple Inc)</dd>
	<dd><a href="mailto:eoconnor@apple.com">Edward O’Connor</a> (Apple Inc)</dd>
	<dd><a href="mailto:dschulze@adobe.com">Dirk Schulze</a> (Adobe Systems Inc)</dd>

	<dt title="Former Editors:">前任編集者</dt>
	<dd><a href="mailto:hyatt@apple.com">David Hyatt</a> (Apple Inc)</dd>
	<dd><a href="mailto:cmarrin@apple.com">Chris Marrin</a> (Apple Inc)</dd>
	<dd><a href="mailto:ayg@aryeh.name">Aryeh Gregor</a> (Mozilla)</dd>

	<dt title="Issues List:">課題一覧</dt>
	<dd><a href="https://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;product=CSS&amp;component=Transforms&amp;resolution=---&amp;cmdtype=doit">in Bugzilla</a></dd></dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2015
<a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
<a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
<a href="http://www.keio.ac.jp/">Keio</a>,
<a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and
<a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
</small>

</header>



	<section id="abstract">
<h2 title="Abstract">要約</h2>
<p>
CSS Transform （変形, 変換（座標系変換））は、要素を 二次元あるいは三次元 空間の中で変形させられるようにするための， CSS によるスタイル付けを規定する。
この仕様は、
<a href="http://www.w3.org/TR/css3-2d-transforms/">CSS 2D transforms</a>,
<a href="http://www.w3.org/TR/css3-3d-transforms/">CSS 3D transforms</a>,
<a href="http://www.w3.org/TR/2009/WD-SVG-Transforms-20090320/">SVG transforms</a>
仕様の統合である。
<span lang="en">
CSS transforms allows elements styled with CSS to be transformed in two-dimensional or three-dimensional space. This specification is the convergence of the CSS 2D transforms, CSS 3D transforms and SVG transforms specifications.
</span></p>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<span class="trans-note">【
以下、この節の内容は
<a href="css-common-ja.html#status" >CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>

	</section>

<nav class="toc" id="contents">
<h2 class="toc">目次</h2>
<ol id="_toc_list0"></ol></nav>

<main id="MAIN" style="display:none;">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
CSS の`視覚~整形~model$は、各 要素が位置される座標系について述べている。
この座標空間における位置と~sizeは、原点から右方／下方に向かって増大する画素~数による正の値で表されるものと捉え得る。
◎
The CSS visual formatting model describes a coordinate system within each element is positioned. Positions and sizes in this coordinate space can be thought of as being expressed in pixels, starting in the origin of point with positive values proceeding to the right and down.
</p>

<p>
この座標空間は， `transform$p ~propにより変更できる。
この変形により，要素を~2D（二次元）／~3D（三次元）空間の中で並進させ, 回転させ, 拡縮させられる。
【以下、“~2D” ／ “~3D” に表記を統一する。】
◎
This coordinate space can be modified with the transform property. Using transform, elements can be translated, rotated and scaled in two or three dimensional space.
</p>

<p>
変形の操作をより容易くするための，追加の~propもあり、作者は，入子にされた~3D変形の~~作用についての制御も可能になる。
◎
Additional properties make working with transforms easier, and allow the author to control how nested three-dimensional transforms interact.
</p>

<ul>
	<li>
`transform-origin$p ~propは、要素~上に適用される変形の原点について制御する，簡便な方法を提供する。
◎
The transform-origin property provides a convenient way to control the origin about which transforms on an element are applied.
</li>

	<li>
`perspective$p ~propにより、~3D変形を伴う一連の子~要素を，共通の~3D~空間に属しているかのように現れさせられる。
`perspective-origin$p ~propは、遠近法が適用される原点についての制御を提供し，それにより実質的な “消失点” の位置を変えられる。
◎
The perspective property allows the author to make child elements with three-dimensional transforms appear as if they live in a common three-dimensional space. The perspective-origin property provides control over the origin at which perspective is applied, effectively changing the location of the "vanishing point".
</li>

	<li>
`transform-style$p ~propは、~3D変形されたいくつかの要素とその~3D変形された子孫たちを，同じ~3D~空間に共存させ、~3D~object階層の構築を可能にする。
◎
The transform-style property allows 3D-transformed elements and their 3D-transformed descendants to share a common three-dimensional space, allowing the construction of hierarchies of three-dimensional objects.
</li>
	<li>
`backface-visibility$p ~propは、要素が，その裏側が`視点$から可視になるように，~3D変形を通して反転されているときに、効力を発揮する。
その種の要素は，隠される方が望ましい状況もあるが、この~propに対する値 `hidden^v の利用が，それを可能にする。
◎
The backface-visibility property comes into play when an element is flipped around via three-dimensional transforms such that its reverse side is visible to the viewer. In some situations it is desirable to hide the element in this situation, which is possible using the value of hidden for this property.
</li>
</ul>

<p class="note">注記：
`transform$p ~propの一部の値は，要素を ~3D~座標系において変形させるが、その要素~自身は~3D~objectにはされない。
それらは~2D~平面~内に存在し，奥行きを持たない。
◎
Note: While some values of the transform property allow an element to be transformed in a three-dimensional coordinate system, the elements themselves are not three-dimensional objects. Instead, they exist on a two-dimensional plane (a flat surface) and have no depth.
</p>

<p>
<span class="trans-note">【訳者補足】</span>
`視点@
とは、想定されている，（一定位置にある）頁~閲覧者の目の位置、言い換えれば仮想のカメラ位置を意味する。
遠近法が不在の~2D描画文脈の下では、これは意味を持たない（実質的に画面から垂直に閲覧者~側へ向かう，無限遠点に位置する）。
`~3D描画文脈$の下では、画面から視点までの距離, および その文脈~下の~boxの中心から視点への X, Y 軸~方向のずれ量が，実際の描画に織り込まれることになる。
また、後述される様に，視点は頁の部分ごとに設定できる。
ただし，視点の位置は~boxに相対的になる — ~screenに相対的にする機能（~boxが~scrollされても “画面外では固定的な” 現実の閲覧者の目の位置に合わせて動的に描画を変える）は，特に用意されていない。
</p>

	</section>
	<section id="module-interactions">
<h2 title="Module Interactions">2. ~module間の相互作用</h2>

<p>
この~moduleは、適用-対象の要素の視覚的~描画に影響する，一連の CSS ~propを定義する —
これらの効果は、 `CSS21$r の`視覚~整形~model$に従って，要素の~sizeと位置が~~決定された後に適用される。
これらの~propの一部の値に対しては、新たな`包含塊$が設置されたり, `積層文脈$が確立される。
◎
This module defines a set of CSS properties that affect the visual rendering of elements to which those properties are applied; these effects are applied after elements have been sized and positioned according to the Visual formatting model from [CSS21]. Some values of these properties result in the creation of a containing block, and/or the creation of a stacking context.
</p>

<p>
~3D変形は，要素の視覚的な積層順にも影響し、
`CSS21$r の
<a href="~CSS22/zindex.html" title="Elaborate description of Stacking Contexts">付録 E</a>
に述べられている，奥から手前にかけての塗り順序を上書きする。
◎
Three-dimensional transforms can also affect the visual layering of elements, and thus override the back-to-front painting order described in Appendix E of [CSS21].
</p>

<p>
変形は、 `CSS3BG$r にて指定される `background-attachment$p ~propに値 `fixed^v を伴う要素~上の背景~描画にも影響する。
◎
Transforms affect the rendering of backgrounds on elements with a value of fixed for the background-attachment property, which is specified in [CSS3BG].
</p>

<p>
変形は、 `CSSOM-VIEW$r による `Element^code ~interface拡張：
<a href="~CSSOMVIEW#dom-element-getclientrects">`getClientRects()^code</a>,
<a href="~CSSOMVIEW#dom-element-getboundingclientrect">`getBoundingClientRect()^code</a>
が返す~client矩形にも影響する。
◎
Transforms affect the client rectangles returned by the Element Interface Extensions getClientRects() and getBoundingClientRect(), which are specified in [CSSOM-VIEW].
</p>

	</section>

	<section id="css-values">
<h2 title="CSS Values">3. CSS 値</h2>

<p class="trans-note">【
この節の内容は
<a href="css-common-ja.html#values" >CSS 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>

	<section id="terminology">
<h2 title="Terminology">4. 各種用語</h2>

<p>
この節では、この仕様にて利用される用語を定義する：
◎
When used in this specification, terms have the meanings assigned in this section.
</p>

<!-- 
3D 変形： 3 次元の座標系変換により 3 次元座標系の中の物体の形が表示上が変化して見える様にされること
 -->

<dl>
	<dt>`変形可能@な要素◎transformable element</dt>
	<dd><p>
次に挙げるものが変形可能な要素である：
◎
A transformable element is an element in one of these categories:
</p>

		<ul>
			<li>
<p>
~layoutが ［
`塊level$の, または`不可分な行内level$の要素
］のいずれかの CSS ~box~modelにより統制される要素、または
</p>

<p>
`display$p ~propの算出値が［
`table-row^v,
`table-row-group^v,
`table-header-group^v,
`table-footer-group^v,
`table-cell^v,
`table-caption^v
］のいずれかになる要素。
`CSS21$r
</p>

<p lang="en">
an element whose layout is governed by the CSS box model which is either a block-level or atomic inline-level element, or whose display property computes to table-row, table-row-group, table-header-group, table-footer-group, table-cell, or table-caption [CSS21]
</p>
			</li>

			<li>
SVG 名前空間に属する, かつ
CSS ~box~modelにより統制されない, かつ［
`transform$svgattr,<!-- prop → attr -->
`patternTransform$svgattr,
`gradientTransform$svgattr
］のいずれかの属性を持つ要素。
`SVG11$r
◎
an element in the SVG namespace and not governed by the CSS box model which has the attributes transform, ‘patternTransform‘ or gradientTransform [SVG11].
</li>
		</ul>
	</dd>


	<dt>`変形要素@◎transformed element</dt>
	<dd>
`transform$p ~propの算出値に `none^v 以外の値を伴う要素。
◎
An element with a computed value other than none for the transform property.
</dd>

	<dt>`~3D変形要素@◎3D-transformed element</dt>
<dd>
`transform$p ~propの算出値に `~3D変形関数$を伴う要素。
◎
An element whose computed value for the transform property includes one of the 3D transform functions
</dd>



	<dt>`利用座標系@◎user coordinate system</dt>
	<dt>`局所座標系@◎local coordinate system</dt>
	<dd>

<p>
一般に，現在の~canvas上の位置と距離を定義する座標系を指す。
現在の局所座標系（利用座標系とも呼ばれる）とは、現在の~canvas上の 座標や長さを算出する方法を定義する，現在~利用中の座標系を意味する。
◎
In general, a coordinate system defines locations and distances on the current canvas. The current local coordinate system (also user coordinate system) is the coordinate system that is currently active and which is used to define how coordinates and lengths are located and computed, respectively, on the current canvas.
</p>

<!-- 
<p class="trans-note">【
“現在の（ current ）” — 
変換が適用される要素は、概念的には，（変換が適用されない状態の）一時的な~canvas上に描画された上で、その~canvasに変換が適用されて実際の描画に反映される。
この一時的な仮想~canvasを指している。
】</p>
 -->
<p>
現在の利用座標系の原点は、 `transform-box$p ~propにより指定される`基準~box$の左上隅に位置する。
百分率~値は、この基準~boxの寸法に相対的になる。
1 単位は 1 CSS 画素に等しい。
◎
The current user coordinate system has its origin at the top-left of a reference box specified by the transform-box property. Percentage values are relative to the dimension of this reference box. One unit equals one CSS pixel.
</p>

	</dd>

	<dt>`透視行列@◎perspective matrix</dt>
	<dd><p>
`perspective$p, `perspective-origin$p
~propの値から，
<a href="#perspective-matrix-computation">後述の様に</a>
算出される行列。
◎
A matrix computed from the values of the perspective and perspective-origin properties as described below.
</p></dd>

	<dt>`変換行列@◎transformation matrix</dt>
	<dd><p>
ある座標系から別の座標系への数学的な写像を定義する行列。
`transform$p, `transform-origin$p ~propの値から，
<a href="#transformation-matrix-computation">後述の様に</a>
算出される。
◎
A matrix that defines the mathematical mapping from one coordinate system into another. It is computed from the values of the transform and transform-origin properties as described below.
</p></dd>

	<dt>`現在の変換行列@（ CTM ）◎CTM — current transformation matrix）</dt>
	<dd><p>
局所座標系から表示域 座標系への写像を定義する行列。
◎
A matrix that defines the mapping from the local coordinate system into the viewport coordinate system.
</p></dd>

	<dt>`累積~3D変換行列@◎accumulated 3D transformation matrix</dt>
	<dd><p>
要素に対し，その`~3D描画文脈$の根に相対的に算出される行列
— 詳細は`累積~3D変換行列の算出$ 節に。
◎
A matrix computed for an element relative to the root of its 3D rendering context, as described below.
</p></dd>

	<dt>`~2D行列@◎2D matrix</dt>
	<dd><p>
6 項からなる 3x2 の変換行列であるか、または
16 項からなる 4x4 の変換行列であって，項［
`31^m, `32^m, `13^m, `23^m, `43^m, `14^m, `24^m, `34^m
］が 0 に等しく, 項［
`33^m, `44^m
］が 1 に等しいもの。
◎
A 3x2 transformation matrix with 6 items or a 4x4 matrix with 16 items, where the items m31, m32, m13, m23, m43, m14, m24, m34 are equal to 0 and m33, m44 are equal to 1.
</p>

<p class="trans-note">【
前者は、実質的には 3x3 の変換行列であり，各元が 3 成分~vectorで表現される`射影平面$（すなわち，~2D `射影空間$）に作用する。
後者は、~3D射影空間に埋め込まれた，同じ射影平面に作用する。
】</p>

	</dd>

	<dt>`~3D行列@◎3D matrix</dt>
	<dd><p>
`~2D行列$ の要件を満たさない 4x4 行列。
◎
A 4x4 matrix which does not fulfill the requirements of an 2D matrix.
</p></dd>
	<dt>`恒等~変形関数@◎identity transform function</dt>
	<dd><p>
4x4 の単位行列に等価な`変形関数$（`変形関数の数学的~記述$を見よ）。
恒等~変形関数の例には次が挙げられる：
</p>

<div style="white-space:pre-wrap; margin-left: 2em;"
>`translate(0)^v,
`translate3d(0, 0, 0)^v,
`translateX(0)^v,
`translateY(0)^v,
`translateZ(0)^v,
`scale(1)^v,
`scaleX(1)^v,
`scaleY(1)^v,
`scaleZ(1)^v,
`rotate(0)^v,
`rotate3d(1, 1, 1, 0)^v,
`rotateX(0)^v,
`rotateY(0)^v,
`rotateZ(0)^v,
`skew(0, 0)^v,
`skewX(0)^v,
`skewY(0)^v,
`matrix(1, 0, 0, 1, 0, 0)^v
`matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)^v
</div>

<p >
遠近法の特殊な事例として：
`perspective(infinity)^v
がある — この場合、 `34^m の値は無限小になり，したがって変形関数は単位行列に等しいものと見なされる。
</p>

<p lang="en">
A transform function that is equivalent to a identity 4x4 matrix (see Mathematical Description of Transform Functions). Examples for identity transform functions are translate(0), translate3d(0, 0, 0), translateX(0), translateY(0), translateZ(0), scale(1), scaleX(1), scaleY(1), scaleZ(1), rotate(0), rotate3d(1, 1, 1, 0), rotateX(0), rotateY(0), rotateZ(0), skew(0, 0), skewX(0), skewY(0), matrix(1, 0, 0, 1, 0, 0) and matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1). A special case is perspective: perspective(infinity). The value of m34 becomes infinitesimal small and the transform function is therefore assumed to be equal to the identity matrix.
</p>
	</dd>

	<dt>`~3D描画文脈@◎3D rendering context</dt>
	<dd><p>
同じ~3D~座標系に共存するような、先祖が共通する要素の集合。
詳細は
<a href="#3d-rendering-contexts">~3D 描画文脈</a>
節に。
◎
A set of elements with a common ancestor which share a common three-dimensional coordinate system, as described below
</p></dd>
</dl>


	</section>
	<section id="two-dimensional-subset">
<h2 title="Two Dimensional Subset">5. ~2Dに限定された機能</h2>

<div >
<p>
~UA は~3D変形を描画できるとは限らず，この仕様の~2Dに限定された機能のみを~supportすることもある。
この場合：
</p>

<ul>
	<li>
`~3D変形$, および［
`transform-style$p,
`perspective$p,
`perspective-origin$p,
`backface-visibility$p
］~propは、~supportされてはならない。
</li>

	<li>
`~3D変形による描画$の節は適用されない。
</li>

	<li>
行列の分解法は
“Graphics Gems II, edited by Jim Arvo”
による “unmatrix” 手法を~2Dの場合に単純化した技法を利用する。
</li>

	<li>
<p>
`変形関数の数学的~記述$の節は，依然として有効であるが、下図に示すような 3x3 変換行列を利用して~~縮退させ得る
— ここで図の %a 〜 %f は：
%a ~EQ `11^m,
%b ~EQ `12^m,
%c ~EQ `21^m,
%d ~EQ `22^m,
%e ~EQ `41^m,
%f ~EQ `42^m
（ 6 成分からなる `~2D 3x2 行列$を見よ）：
</p>

<figure>`3x3matrix^dgm
<figcaption>
~2D~変換に対する 3x3 行列
</figcaption></figure>

	</li>
</ul>

	<div lang="en">
<p>
UAs may not always be able to render three-dimensional transforms and then just support a two-dimensional subset of this specification. In this case three-dimensional transforms and the properties transform-style, perspective, perspective-origin and backface-visibility must not be supported. Section 3D Transform Rendering does not apply. Matrix decomposing uses the technique taken from the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo", simplified for the 2D case. Section Mathematical Description of Transform Functions is still effective but can be reduced by using a 3x3 transformation matrix where a equals m11, b equals m12, c equals m21, d equals m22, e equals m41 and f equals m42 (see A 2D 3x2 matrix with six parameter).
</p>
<p>3x3 matrix for two-dimensional transformations.</p>
	</div>
</div>

<div class="example">

<p>
~UAが~3D変形を~supportしない場合の~fallbackも容易に供せる。
次の例に 2 つの `transform$p ~prop定義を示す。
最初のものは 2 個の~2D~変形関数からなり， 2 番目のものは ~2Dと~3Dの変形関数を持つ。
◎
Authors can easily provide a fallback if UAs do not provide support for three-dimensional transforms. The following example has two property definitions for transform. The first one consists of two two-dimensional transform functions. The second one has a two-dimensional and a three-dimensional transform function.
</p>

<pre>
div {
  transform: scale(2) rotate(45deg);
  transform: scale(2) rotate3d(0, 0, 1, 45deg);
}</pre>


<p>
~3D~supportがあれば， 2 番目の定義が最初のものを上書きすることになる。
~3D~supportが無ければ， 2 番目の定義は無効になり，~UAは最初の定義に~fall-backする。
◎
With 3D support, the second definition will override the first one. Without 3D support, the second definition is invalid and a UA falls back to the first definition.
</p>
</div>

	</section>
	<section id="transform-rendering">
<h2 title="The Transform Rendering Model">6. 変形の描画~model</h2>

<p>
<em>この節は規定である。</em>
◎
This section is normative.
</p>

<p>
`transform$p ~propに対する `none^v 以外の値の指定は、適用-対象の要素において，新たな`局所座標系$を確立させる。
この~propにより指定される`変換行列$は、要素の描画~先の座標系から，その局所座標系への写像を与える【†】。
変換は累積的である。
すなわち、要素はその親の座標系の中で局所座標系を確立する。
利用者~側からは、要素は，実質的に，それに適用される局所~変形のみならず，その先祖のすべての `transform$p ~propが累積されたように見える。
要素に対する`現在の変換行列$（ CTM ）が、これらの変形の累積により定義される。
◎
Specifying a value other than none for the transform property establishes a new local coordinate system at the element that it is applied to. The mapping from where the element would have rendered into that local coordinate system is given by the element’s transformation matrix. Transformations are cumulative. That is, elements establish their local coordinate system within the coordinate system of their parent. From the perspective of the user, an element effectively accumulates all the transform properties of its ancestors as well as any local transform applied to it. The accumulation of these transforms defines a current transformation matrix (CTM) for the element.
</p>


<p class="trans-note">【
† 厳密には，逆向きの写像を定義する（例えば `scale(0)^v は、要素の局所座標系のすべての座標を描画~先の一点に写像する — その逆~写像は定義できない）。
<a href="#notes-on-accumulation">詳細は後述</a>。
】</p>


<p>
座標空間は、2 本の軸
— `視点$から見て、右向きが正方向の X 軸, 下向きが正方向の Y 軸 —
を伴う座標系である。
~3D~変形関数のときは、画面に垂直で, 視点に向けて増大する Z 軸が加わり，この座標空間が~3Dに拡張される。
◎
The coordinate space is a coordinate system with two axes: the X axis increases horizontally to the right; the Y axis increases vertically downwards. Three-dimensional transform functions extend this coordinate space into three dimensions, adding a Z axis perpendicular to the plane of the screen, that increases towards the viewer.
</p>

<figure>`coordinates^dgm
<figcaption>
初期時の座標空間の例示。
◎
Demonstration of the initial coordinate space.
</figcaption></figure>



<p id="transformation-matrix-computation">
`変換行列$は、
`transform$p, `transform-origin$p
~propから，次の様にして算出される：
◎
The transformation matrix is computed from the transform and transform-origin properties as follows:
</p>

<ol>
	<li>
単位行列から開始。
◎
Start with the identity matrix.
</li>

	<li>
<p>
`transform-origin$p の算出値による X, Y, Z で並進させる — (A)
◎
Translate by the computed X, Y and Z values of transform-origin
</p>

<p class="trans-note">【
すなわち，［
移動量 X, Y, Z による`~3D並進$
］で積をとる。
局所座標系の (0, 0, 0) は，`基準~box$がなす座標系（原点は~boxの左上隅）の (X, Y, Z) に写像される。
】</p>
	</li>

	<li>
<p>
左から右の順に，［
`transform$p ~propで与えられる変形関数~list
］の各~変形関数により積をとる。
◎
Multiply by each of the transform functions in transform property from left to right
</p>

<p class="trans-note">【
すなわち、対応する変換行列により，同じ順序で積をとる
】</p>
	</li>

	<li>
<p>
(A) と同じ移動量だけ逆方向に，並進させる。
◎
Translate by the negated computed X, Y and Z values of transform-origin
</p>

<p class="trans-note">【
すなわち、(A) の逆行列により，積をとる
】</p>

	</li>

</ol>

<p>
変形は、`変形可能$な要素に適用される。
◎
Transforms apply to transformable elements.
</p>



<p class="note">注記：
変換は、~canvas上の描画には影響するが、 CSS ~layout自体には，overflowを除いて影響しない。
変形は、 `CSSOM-VIEW$r にて指定される［
`Element^code ~interface拡張により公開される
<a href="~CSSOMVIEW#dom-element-getclientrects">`getClientRects()^code</a>,
<a href="~CSSOMVIEW#dom-element-getboundingclientrect">`getBoundingClientRect()^code</a>
］による~client矩形の算出にも織り込まれる。
◎
Note: Transformations do affect the visual rendering, but have no affect on the CSS layout other than affecting overflow. Transforms are also taken into account when computing client rectangles exposed via the Element Interface Extensions, namely getClientRects() and getBoundingClientRect(), which are specified in [CSSOM-VIEW].
</p>

<div class="example">
<pre>
div {
  transform: translate(100px, 100px);
}</pre>

<p>
この変形は、要素を X, Y 両方向に 100 画素~移動させる（図左が変形~前, 図右が変形~後）。
◎
This transform moves the element by 100 pixels in both the X and Y directions.
</p>

<figure>`translate1^dgm</figure>

</div>

<div class="example">
<pre>
div {
  height: 100px; width: 100px;
  transform-origin: 50px 50px;
  transform: rotate(45deg);
}</pre>

<p>
`transform-origin$p ~propにより，原点を X, Y 両方向に 50 画素ずつずらす。
`transform^p は，原点を中心に要素を時計回りに 45° 回転させる。
すべての変形関数が適用された後、原点は， X, Y 両方向に -50 画素だけ並進されて引き戻される。
◎
The transform-origin property moves the point of origin by 50 pixels in both the X and Y directions. The transform rotates the element clockwise by 45° about the point of origin. After all transform functions were applied, the translation of the origin gets translated back by -50 pixels in both the X and Y directions.
</p>


<figure>`origin1^dgm</figure>

	<div class="trans-note">
<p>【
上の例による効果は、次と等価になる：
】</p>

<pre >
div {
  height: 100px; width: 100px;
  transform-origin: 0px 0px;
  transform: translate(50px, 50px) rotate(45deg) translate(-50px, -50px);
}
</pre>

	</div>

</div>

<div class="example">
<pre>
div {
  height: 100px; width: 100px;
  transform: translate(80px, 80px) scale(1.5, 1.5) rotate(45deg);
}</pre>

<p>
この変形は、要素を
X, Y 両方向に 80 画素~移動させ,
150% に拡大してから,
Z 軸を中心に時計回りに 45° 回転させる。
拡縮と回転は、要素の既定の変換原点（ `transform-origin$p ）が `50% 50%^v なので，要素の中心を軸に作用することに注意。
◎
This transform moves the element by 80 pixels in both the X and Y directions, then scales the element by 150%, then rotates it 45° clockwise about the Z axis. Note that the scale and rotation operate about the center of the element, since the element has the default transform-origin of 50% 50%.
</p>

<figure>`compound_transform^dgm</figure>

<div class="trans-note">

<p>【
この例では、各~変形関数が適用される際に基準にしている座標系について，原点のみの言及で足りているが、一般の場合も含めた意味では，言及されていない行間がある：
</p>

<p>
要素に，自身の局所座標系を表す X, Y 軸が（この例では要素の中心を原点にとる）描かれていると考えたとき、それぞれの変形関数は，この描かれている（すなわち，要素に固着している）座標軸を基準にする。
例えば：
</p>

<pre >
transform: rotate(45deg) translate(80px, 80px);
</pre>

<p>
は、
“要素を 45° 回転してから, その<em >45° 回転された座標軸</em> を基準に ( 80px, 80px ) 移動”
を意味する
— すなわち、見かけ上の移動~方向は，（右下ではなく）真下になる（ “45° 回転~眼鏡” を通して眺めている <em>向こう側の世界</em> では， ( 80px, 80px ) 移動している）。
同様に：
</p>

<pre >
transform: scale(2) translate(80px, 80px);
</pre>

<p>
では、倍に拡大された座標軸を基準に並進が適用されるので，見かけ上の移動量は (160px, 160px) になる。
また：
</p>

<pre >
transform: skewX(30deg) rotate(90deg);
</pre>

<p>
では、 Y 軸だけが 30° 傾いた座標軸を基準に 90° の回転が適用されるので，見かけ上は X 軸が 60°, Y 軸が 120° 回転される。
</p>

<p>
あるいは、<a href="#notes-on-accumulation">後述の注釈</a>に沿う形で述べるなら、各~変形関数を，常に一定の座標軸
— 変換が適用される前に，要素に描かれている座標軸を背景に固着させた座標軸（これは、［［
`transform-origin^p や CSS ~layout
］による並進や, 要素の先祖に指定されている変換
］が織り込まれた座標系を表す） —
を基準に，<em >逆順に</em> 適用することに等価になる。
上の図式の例で言えば、この座標軸を基準に，
“要素は、 45° 回転され, 150% に拡大され, 両~軸とも 80 画素~移動された状態で，表示される”
と記すこともできる。
】</p>

</div>


<p>
要素を入子にした上で，等価な変形を与えても、一致する描画~結果を得られることに注意：
◎
Note that an identical rendering can be obtained by nesting elements with the equivalent transforms:
</p>

<pre>
&lt;div style="transform: translate(80px, 80px)"&gt;
  &lt;div style="transform: scale(1.5, 1.5)"&gt;
      &lt;div style="transform: rotate(45deg)"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>

</div>


<p>
~layoutが CSS ~box~modelにより統制される要素においては、変形~propは，`変形要素$の周囲の内容の~flowには影響しない。
しかしながら、~overflow領域<!-- の~extent -->には，`変形要素$も織り込まれる。
この挙動は、要素が相対的な位置決（
<span class="css">`position$p: `relative^v</span>
）を通してずらされるときに類似する。
したがって， `overflow$p ~propの値が
`scroll^v ／ `auto^v
の下では、可視~領域の外側に変形された内容も見れるようにするための~scrollbarが，必要に応じて現れることになる。
◎
For elements whose layout is governed by the CSS box model, the transform property does not affect the flow of the content surrounding the transformed element. However, the extent of the overflow area takes into account transformed elements. This behavior is similar to what happens when elements are offset via relative positioning. Therefore, if the value of the overflow property is scroll or auto, scrollbars will appear as needed to see content that is transformed outside the visible area.
</p>

<p>
~layoutが CSS ~box~modelにより統制される要素においては、変形に対する `none^v 以外のどの値も，`積層文脈$と`包含塊$の両者を作成させる。
~objectは，固定位置にされた子孫に対する包含塊としてふるまう。
◎
For elements whose layout is governed by the CSS box model, any value other than none for the transform results in the creation of both a stacking context and a containing block. The object acts as a containing block for fixed positioned descendants.
</p>

<p class="issue">
これは固定位置（
<span class="css">`position$p: `fixed^v</span>
）にも効果を及ぼす必要があるだろうか？
そうであれば、固定位置にされた~objectがこれをすべき理由について詳細を述べる必要がある
— その実装はずっと困難になるので。
`16328$bug を見よ。
◎
Is this effect on position: fixed necessary? If so, need to go into more detail here about why fixed positioned objects should do this, i.e., that it’s much harder to implement otherwise. See Bug 16328.
</p>

<p>
根~要素~上に`固定された背景$は、その要素に指定されたどの変形からも影響される。
変形から影響される（すなわち，自身または先祖の要素に変形が適用されている）他のすべての要素に対しては、 `background-attachment$p ~propに対する値 `fixed^v は，値 `scroll^v を持つかのように扱われる。
`background-attachment$p の算出値は影響されない。
◎
Fixed backgrounds on the root element are affected by any transform specified for that element. For all other elements that are effected by a transform (i.e. have a transform applied to them, or to any of their ancestor elements), a value of fixed for the background-attachment property is treated as if it had a value of scroll. The computed value of background-attachment is not affected.
</p>

<p class="note">注記：
根~要素が変形された場合、変換は，根~要素に指定されている背景も含めて，~canvas全体に適用される。
`根~要素に対する背景~塗り領域$は ~canvas全体であり無限なので、変換により，元々は~screen外に在った背景の一部分が現れるようになり得る。
例えば，根~要素の背景が~dotの繰り返し模様であって，
根~要素~上に変換
`scale(0.5)^v
が指定されていたなら、~dotの大きさは半分になるが，その個数は 2 × 2 倍になり，依然として表示域の全面を覆うことになる。
◎
Note: If the root element is transformed, the transformation applies to the entire canvas, including any background specified for the root element. Since the background painting area for the root element is the entire canvas, which is infinite, the transformation might cause parts of the background that were originally off-screen to appear. For example, if the root element’s background were repeating dots, and a transformation of scale(0.5) were specified on the root element, the dots would shrink to half their size, but there will be twice as many, so they still cover the whole viewport.
</p>


		<section id="notes-on-accumulation">
<h3 class="trans-note">【 変換の累積について（訳者補足） 】</h3>

<p>
この仕様の中の［
“並進させる”, “変換（変形関数）を適用する” , “積をとる”, “後置積（ post-multiplied ）”
］等々の言い回し, あるいは変換の適用についての記述の順序が，具体的にどの様な作用を意味するのか 述べられていないので、補足する。
</p>
<p>
一般に、変換の入れ子~階層における，各 `transform^p （加えて，［
`transform-origin^p による原点の移動や CSS による~boxの~layout
］による並進）は、それが確立する局所座標系から親の局所座標系への写像を与える。
それらの写像を，最も <em >子孫~側</em> から順に：

%F1, %F2, … %Fn

とするなら、最も子孫~側の点（すなわち，座標系~変換が施されずに直接的に表示されたとするときの位置） %P は，最も外側の座標系では（すなわち，実際の表示においては），点：
</p>

<pre >
%Q = %Fn( … %F2( %F1(%P))…)
</pre>

<p>
に写像される。
これが変換の累積である（仕様の中では、 
“%Fn を適用して, … %F1 を適用する”
の様に，逆順で記されている）。
</p>

<p>
%F1 … %Fn に対応する各~変換行列を %M1, %M2 … %Mn とするとき、点 %Q は，（ %P を~~縦~vectorと見なした下で）次の式で得られる：
</p>

<pre >
%Q = %Mn ( … ( %M2 (%M1 %P))…) = (%Mn … %M2 %M1) %P
</pre>

<p >
行列の積をとった結果 (%Mn … %M2 %M1) が，`現在の変換行列$と呼ばれるものになる。
“積をとる” と記されたときは、通例，この意味で右から積をとることを意味し、それは，写像の~~合成を意味する。
`transform$p 値による変形関数の~listについても，<a href="#transform-function-lists">実質的に同様になる</a>。
</p>

		</section>

		<section id="3d-transform-rendering">
<h3 title="3D Transform Rendering">6.1. ~3D変形による描画</h3>

<p>
通常は、要素は平面的に，それを`包含している塊$と同じ平面に埋め込まれる様に描画される。
大抵の場合，それは頁の残りの部分と共有される平面になる。
~2D~変形関数は要素の外観を改め得るが、依然として，描画される平面は 要素を`包含している塊$と同じである。
◎
Normally, elements render as flat planes, and are rendered into the same plane as their containing block. Often this is the plane shared by the rest of the page. Two-dimensional transform functions can alter the appearance of an element, but that element is still rendered into the same plane as its containing block.
</p>

<p>
~3D変形の変換行列は，ゼロでない Z 成分を伴い得る（ Z 軸は~screenの平面から飛び出す軸）。
その結果、要素を`包含している塊$の平面と異なる平面~上に描画され、他の要素に相対的な，手前から奥への要素の描画~順序にも影響するのみならず，他の要素と交差し得る。
◎
Three-dimensional transforms can result in transformation matrices with a non-zero Z component (where the Z axis projects out of the plane of the screen). This can result in an element rendering on a different plane than that of its containing block. This may affect the front-to-back rendering order of that element relative to other elements, as well as causing it to intersect with other elements.
</p>

<div class="example">


<p>
要素に適用される~3D変形の効果を，次の例に示す：
◎
This example shows the effect of three-dimensional transform applied to an element.
</p>

<pre>
&lt;style&gt;
div {
  height: 150px;
  width: 150px;
}
.container {
  border: 1px solid black;
}
.transformed {
  transform: rotateY(50deg);
}
&lt;/style&gt;

&lt;div class="container"&gt;
  &lt;div class="transformed"&gt;&lt;/div&gt;
&lt;/div&gt;</pre>

<figure>`simple-3d-example^dgm</figure>



<p>
変形は 縦方向の Y 軸を中心に 50° 回転させる。
これにより，青色の~boxは狭小に現れるが、~3Dではない。
◎
The transform is a 50° rotation about the vertical, Y axis. Note how this makes the blue box appear narrower, but not three-dimensional.
</p>
</div>

			<section id="perspective">
<h4 title="Perspective">6.1.1. 遠近法</h4>

<p>
`perspective$p, `perspective-origin$p 
~propを利用すれば、風景に奥行き感を与えられる
—
要素は、その Z 座標（以下 %z ）を高くする（`視点$に近付ける）ほど，より大きく現れ、低くする（`視点$から遠ざける）ほど，より小さく現れる。
拡縮率は［
%d ∕ ( %d − %z )
］に比例する。
ここで， %d は `perspective$p の値であり，画面から視点と見なされる地点（下図の “Assumed Eye Position”）までの距離を与える。
◎
The perspective and perspective-origin properties can be used to add a feeling of depth to a scene by making elements higher on the Z axis (closer to the viewer) appear larger, and those further away to appear smaller. The scaling is proportional to d/(d − Z) where d, the value of perspective, is the distance from the drawing plane to the the assumed position of the viewer’s eye.
</p>

<figure>`perspective_distance^dgm
<figcaption>
拡縮ingが `perspective$p ~propと Z 位置に依存する様子を示す図式。
上段の図式では， %z が %d の半分にされている。
元の円（実線）が %z （点線の円）の所に現れるようにするため、円は 2 倍に拡大され，水色の円で示されるものになる。
下段の図式では、円は 2 ∕ 3 倍に縮小されて，元の位置の背後に現れる。
◎
Diagrams showing how scaling depends on the perspective property and Z position. In the top diagram, Z is half of d. In order to make it appear that the original circle (solid outline) appears at Z (dashed circle), the circle is scaled up by a factor of two, resulting in the light blue circle. In the bottom diagram, the circle is scaled down by a factor of one-third to make it appear behind the original position.
</figcaption></figure>

<p>
通常は、`視点$と見なされる地点は，絵図の中心（真正面）に位置する。
必要なら `perspective-origin$p を設定して，この位置を移動させることもできる
—
例えば、頁~内の複数の絵図が，同じ遠近法を共有すべき場合など。
◎
Normally the assumed position of the viewer’s eye is centered on a drawing. This position can be moved if desired – for example, if a web page contains multiple drawings that should share a common perspective – by setting perspective-origin.
</p>

<figure>`perspective_origin^dgm
<figcaption>
遠近法の原点を上方に移動させる効果を示す図式。
◎
Diagram showing the effect of moving the perspective origin upward.
</figcaption></figure>

<p id="perspective-matrix-computation">
`透視行列$は、次の様にして算出される：
◎
The perspective matrix is computed as follows:
</p>


<ol>
	<li>
（単位行列に対し、以下の変換を累積する）
◎
Start with the identity matrix.
</li>

	<li>
<p>
`perspective-origin$p の算出値による X, Y 値により，並進させる — (A)
◎
Translate by the computed X and Y values of perspective-origin
</p>

<p class="trans-note">【
すなわち， X, Y による`~2D並進$で右から積をとる（現在の座標系の原点が親の座標系の (X, Y, 0) に写像される）。
】</p>

	</li>

	<li>
<p>
`perspective$f 変形関数から得られる行列により積をとる
— 引数の長さ値は `perspective$p ~propの値から供される
◎
Multiply by the matrix that would be obtained from the perspective() transform function, where the length is provided by the value of the perspective property
</p>

<p class="trans-note">【
すなわち，`透視投影行列$により右から積をとる。
】</p>

	</li>

	<li>
<p>
(A) と同じ移動量だけ逆方向に，並進させる。
◎
Translate by the negated computed X and Y values of perspective-origin
</p>

<p class="trans-note">【
すなわち、(A) の逆行列により，右から積をとる
】</p>

	</li>
</ol>


<div class="example">

<p>
次の例に、~3D変形が より本物らしく現れるようにするための， `perspective^p の用法を示す：
◎
This example shows how perspective can be used to cause three-dimensional transforms to appear more realistic.
</p>

<pre>
&lt;style&gt;
div {
  height: 150px;
  width: 150px;
}
.container {
  perspective: 500px;
  border: 1px solid black;
}
.transformed {
  transform: rotateY(50deg);
}
&lt;/style&gt;

&lt;div class="container"&gt;
  &lt;div class="transformed"&gt;&lt;/div&gt;
&lt;/div&gt;</pre>

<figure>`simple-perspective-example^dgm</figure>

<p>
内側の要素は，前の例と同じ変形を持つが、その描画は今や，その親~要素~上の `perspective^p ~propから~~影響を受けている。
`perspective^p により、絵図の中の点の X, Y 座標は、その Z 座標が（`視点$により近い）正の所では，拡大される一方，（`視点$からより遠い）負の所では縮小され、外観に奥行き感が与えられる。
◎
The inner element has the same transform as in the previous example, but its rendering is now influenced by the perspective property on its parent element. Perspective causes vertices that have positive Z coordinates (closer to the viewer) to be scaled up in X and Y, and those further away (negative Z coordinates) to be scaled down, giving an appearance of depth.
</p>
</div>

			</section>
			<section id="3d-rendering-contexts">
<h4 title="3D Rendering Contexts">6.1.2. ~3D 描画文脈</h4>

<p>
この節では、~3D変形, および `transform-style$p ~propを利用する内容を描画するための~modelを指定する。
この~modelを述べるため、 “~3D描画文脈” の概念を導入する。
◎
This section specifies the rendering model for content that uses 3D-transforms and the transform-style property. In order to describe this model, we introduce the concept of a "3D rendering context".
</p>

<p>
`~3D描画文脈$とは、［
~3D変形を描画する目的において 同じ~3D座標系に共存するものと見なされるような，共通の先祖
］を根とする要素の集合である。
~3D描画文脈における要素の手前から奥への描画は，その~3D空間における z-位置に依存し、~3D変形により 要素が互いに交差するときは，その交差~~状態で描画される。
◎
A 3D rendering context is a set of elements rooted in a common ancestor that, for the purposes of 3D-transform rendering, are considered to share a common three-dimensional coordinate system. The front-to-back rendering of elements in the a 3D rendering context depends on their z-position in that three-dimensional space, and, if the 3D transforms on those elements cause them to intersect, then they are rendered with intersection.
</p>

<div >
<p>
~3D描画文脈は、 `transform-style$p の使用値が `flat^v である要素により確立される。
その子孫のうち：
</p>

<ul>
	<li>
`transform-style^p の使用値が `auto^v ／ `preserve-3d^v の要素たちは、それらを封入している~3D描画文脈を共有する。
</li>
	<li>
`transform-style^p の使用値が `flat^v の要素は、それを包含している~3D描画文脈に関与しつつ，その要素の子孫に対し 新たな~3D描画文脈を確立する
— それは、それを包含している~3D描画文脈における描画の目的においては，平坦な平面としてふるまう。
</li>
</ul>

◎
A 3D rendering context is established by an element which has a used value for transform-style of "flat". Descendant elements with a used value for transform-style of "auto" or "preserve-3d" share their enclosing 3D rendering context. A descendant with a used value for transform-style of "flat" participates in its containing 3D rendering context, but establishes a new 3D rendering context for its descendants. For the purposes of rendering in its containing 3D rendering context, it behaves like a flat plane.
</div>

<p class="note">注記：
これは、 CSS 積層文脈に概念的に類似する。
明示的な `z-index$p を伴う位置指定された要素は、先祖の積層文脈に関与しつつ，積層文脈を確立する。
同様に、要素は，先祖の~3D描画文脈に関与しつつ，その子孫のための~3D描画文脈を確立できる。
ちょうど，積層文脈~下の要素が `z-index^p 順序で描画されるのと似るように、
~3D描画文脈に属する要素は， z-深度の順序で描画され，交差し得る。
◎
Note: This is conceptually similar to CSS stacking contexts. A positioned element with explicit z-index establishes a stacking context, while participating in the stacking context of an ancestor. Similarly, an element can establish a 3D rendering context for its descendants, while participating in the 3D rendering context of an ancestor. Just as elements within a stacking context render in z-index order, elements in a 3D-rendering context render in z-depth order and can intersect.
</p>

<p>
CSS ~propには、要素が他の要素と合成される前に，要素 およびその子孫たちを~groupとして描画することを要するような、 “~grouping” を強制する値をとるものがある。
これらには、不透明度, ~filter, ~clippingに影響する~propも含まれる。
これに関連する~prop値は、`~grouping~prop値$に挙げる。
これらの~grouping~prop値は、 `transform-style$p の使用値を `flat^v に強制する。
その種の要素は、
`平坦的~要素@
と呼ばれる。
その帰結として、それらは常に，新たな~3D描画文脈を確立する。
根~要素は常に， `transform-style^p の使用値に `flat^v をとる。
◎
Some CSS properties have values that are considered to force "grouping": they require that their element and its descendants are rendered as a group before being composited with other elements; these include opacity, filters and properties that affect clipping. The relevant property values are listed under grouping property values. These grouping property values force the used value for transform-style to be "flat", and such elements are referred to as flattening elements. Consequently, they always establish a new 3D rendering context. The root element always has a used value of "flat" for transform-style.
</p>

<p>
~3D描画文脈に属する要素の描画は、次の様になる
— 以下、その~3D描画文脈を確立している要素を %R と記す（括弧内の “step `数字^V” は
<a href="~CSS22/zindex.html#painting-order">CSS 2.1, Appendix E.2 塗り順序</a>
のそれを表す）：
◎
The rendering of elements in a 3D rendering context is as follows (numbers refer to items in CSS 2.1, Appendix E, Section E.2 Painting Order):
</p>

<ol class="upper-alpha">
	<li>
%R の背景, ~border, 他の~box装飾が描画される（ step 1, 2 ）
◎
The background, borders and other box decorations of the establishing element are rendered (steps 1 and 2)
</li>
	<li>
3D 変形を伴わない［
内容, および子孫~要素
］は、 step 3 〜 7 に従って順序~付けられ，
%R に相対的な z=0 平面に描画される
◎
The content and descendant elements without 3D transforms, ordered according to steps 3—7, are rendered into a plane at z=0 relative to to the establishing element.
</li>
	<li>
`~3D変形要素$は，それぞれが所有する平面に`累積~3D変換行列$により変形されて描画される。
◎
3D-transformed elements are each rendered into their own plane, transformed by the accumulated 3D transformation matrix.
</li>
	<li>
`Newell のアルゴリズム$に従って，段 B, C で生成された平面の集合~間で，交差が行われる。
◎
Intersection is performed between the set of planes generated by steps B and C, according to Newell’s algorithm.
</li>
	<li>
結果の平面の集合が、段 A にて描画された背景と~box装飾の上に，描画される。
同一~平面にある`~3D変形要素$たちは、塗り順序で描画される。
◎
The resulting set of planes is rendered on top of the backgrounds and box decorations rendered in this step A. Coplanar 3D transformed elements are rendered in painting order.
</li>
</ol>

<p class="issue">
~2D`変形要素$たちを それぞれが所有する平面の中へ pop しなくて大丈夫か？
◎
is it OK to not pop 2D-transformed elements into their own planes?
</p>

<p class="issue">
未~変形の内容とその子孫に交差が要求されるとした場合、~UAは，追加の~textureを割り当てなければならなくなる（~memory消費が倍になり得る）。
内容と未~変形の子孫を，単に背景と~borderに従って描画する方がより効率的になるであろう。
◎
requiring intersection with non-transformed content and descendants requires UAs to allocate additional textures (possibly doubling memory use). Would be more efficient to simply render content and untransformed descendants along with background and borders.
</p>


<p>
z-成分が負にされた変形を伴う要素は，［
内容, および %R の非~変形 子孫
］の背後に描画されることに注意。
したがって `~3D変形要素$は、内容と非`変形要素$に浸出し得る。
◎
Note that elements with transforms which have a negative z-component will render behind the content and untransformed descendants of the establishing element, and that 3D transformed elements may interpenetrate with content and untransformed elements.
</p>

<p class="note">注記：
~3D描画文脈における`~3D変形要素$は、深度~順に基づいて互いに交差し得るので、実質的に，互いに同胞であるかのように描画される。
<samp class="css">`transform-style^p: `preserve-3d^v</samp>
による効果は、~3D描画文脈に属する どの`~3D変形要素$も，
%R の下に巻上げられつつ，依然として自身の`累積~3D変換行列$により描画されるようになるものと，捉えられる。
◎
Note: Because the 3D-transformed elements in a 3D rendering context can all depth-sort and intersect with each other, they are effectively rendered as if they were siblings. The effect of transform-style: preserve-3d can then be thought of as causing all the 3D transformed elements in a 3D rendering context to be hoisted up into the establishing element, but still rendered with their accumulated 3D transformation matrix.
</p>

<div class="example">
<pre>
&lt;style&gt;
.container {
    background-color: rgba(0, 0, 0, 0.3);
    perspective: 500px;
}
.container &gt; div {
    position: absolute;
    left: 0;
}
.container &gt; :first-child {
    transform: rotateY(45deg);
    background-color: orange; /* <span class="comment">橙色</span> */
    top: 10px;
    height: 135px;
}
.container &gt; :last-child {
    transform: translateZ(40px);
    background-color: rgba(0, 0, 255, 0.6); /* <span class="comment">半透明な青色</span> */
    top: 50px;
    height: 100px;
}
&lt;/style&gt;

&lt;div class="container"&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>

<p>
この例は、~3D描画文脈~内の要素が互いに交差し得ることを示す。
容器~要素（ `.container^css ）は、自身とその 2 個の子孫に対する~3D描画文脈を確立する。
子は互いに交差し、橙色にされた要素は，容器と互いに交差する。
◎
This example shows show elements in a 3D rendering context can intersect. The container element establishes a 3D rendering context for itself and its two children. The children intersect with each other, and the orange element also intersects with the container.
</p>

<figure>`3d-intersection^dgm</figure>

</div>

<p>
`perspective$p ~propを利用すれば、結果の~3D描画文脈に属する子孫~memberに共通する，`透視行列$を供することができ、それらの`~3D変形要素$を，奥行きを伴う共通の~3D空間に属するかのように現れさせられる。
その行列は、`累積~3D変換行列の算出$に織り込まれる。
◎
The perspective property can be used to ensure that 3D transformed elements in the resulting 3D rendering context appear to live in a common three-dimensional space with depth, by suppling a common perspective matrix to descendant transformed members of its 3D rendering context, which is taken into account in the accumulated 3D matrix computation.
</p>

<p>
既定では、
`perspective$p に `none^v 以外の値をとる要素は、`平坦的$, したがって~3D描画文脈を確立する。
しかしながら， `transform-style$p を `preserve-3d^v に設定すれば、その種の要素が（他に有効な`~grouping~prop値$がない限り，）それを包含している~3D描画文脈を拡張できるようになる。
◎
By default, elements with value for perspective other than none are flattening, and thus establish a 3D rendering context. However, setting transform-style to preserve-3d allows the perspective element to extend its containing 3D rendering context (provided no other grouping property values are in effect).
</p>


<div class="example">
<pre>
&lt;style&gt;
div {
  height: 150px;
  width: 150px;
}
.container {
  perspective: 500px;
  border: 1px solid black;
}
.transformed {
  transform: rotateY(50deg);
  background-color: blue; /* <span class="comment">青色</span> */
}
.child {
  transform-origin: top left;
  transform: rotateX(40deg);
  background-color: lime; /* <span class="comment">黄緑色</span> */
}
&lt;/style&gt;

&lt;div class="container"&gt;
  &lt;div class="transformed"&gt;
      &lt;div class="child"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>

<p>
この例は、入子にされた~3D変形の描画の様子を示すものである。
青色の `div^code は，前の例の様に、その描画が その親~要素~上の遠近法（ `perspective^p ）の~~影響を受けて，変形される。
黄緑色の要素も，（ `transform-origin^p の効力により，青色の `div^code の上端に固定された） X 軸を中心に回転される，~3D変形を持つ —
しかしながら，同じ~3D描画文脈には属さないので、親は “平坦” になる。
そのため、黄緑色の要素は短く現れ，青色の要素から “飛び出す” ことはない。
◎
This example shows how nested 3D transforms are rendered. The blue div is transformed as in the previous example, with its rendering influenced by the perspective on its parent element. The lime element also has a 3D transform, which is a rotation about the X axis (anchored at the top, by virtue of the transform-origin). However, the lime element is being rendered into the plane of its parent because it is not a member of the same 3D rendering context; the parent is "flattening". Thus the lime element only appears shorter; it does not "pop out" of the blue element.
</p>

<figure>`3d-rendering-context-flat^dgm</figure>

</div>

			</section>
			<section id="transformed-element-hierarchies">
<h4 title="Transformed element hierarchies">6.1.3. 変形要素の階層</h4>

<p>
既定では、`変形要素$は`平坦的$であり，したがって`~3D描画文脈$を確立する。
この平坦的~挙動は、他に`~grouping~prop値$が無ければ，
`transform-style$p ~propに値 `preserve-3d^v を指定して上書きできる。
それは、共通の~3D空間を共有する，変形された~objectからなる階層を構築するために有用になる。
これにより、`変形要素$の子孫たちが，同じ~3D描画文脈を共有できるようになる。
その種の要素の~3D変形されていない子孫たちは、上述の段 C における要素の平面に描画される一方、同じ~3D描画文脈に共存する`~3D変形要素$は、それぞれが所有する平面から “飛び出す” 。
◎
By default, transformed elements are flattening, and thus establish a 3D rendering context. However, since it is useful to construct hierarchies of transformed objects that share a common 3-dimensional space, this flattening behavior may be overridden by specifying a value of preserve-3d for the transform-style property, provided no other grouping property values are in effect. This allows descendants of the transformed element to share the same 3D rendering context. Non-3D-transformed descendants of such elements are rendered into the plane of the element in step C above, but 3D-transformed elements in the same 3D rendering context will "pop out" into their own planes.
</p>


<div class="example">
<pre>
&lt;style&gt;
div {
  height: 150px;
  width: 150px;
}
.container {
  perspective: 500px;
  border: 1px solid black;
}
.transformed {
  `transform-style^p: `preserve-3d^v;
  transform: rotateY(50deg);
  background-color: blue; /* <span class="comment">青色</span> */
}
.child {
  transform-origin: top left;
  transform: rotateX(40deg);
  background-color: lime; /* <span class="comment">黄緑色</span> */
}
&lt;/style&gt;</pre>


<p>
この例は、青色の要素~上に
<span class="css">`transform-style$p: `preserve-3d^v</span>
が追加されたことを除いて，前の例と同じになる。
青色の要素は今や，その容器の~3D描画文脈を拡張する。
それにより，青色と黄緑色の両~要素が同じ~3D~空間に共存するので、黄緑色の要素は，容器~上の遠近法の~~影響を受け，その親から【~3D的に】傾けられて描画される。
◎
This example is identical to the previous example, with the addition of transform-style: preserve-3d on the blue element. The blue element now extends the 3D rendering context of its container. Now both blue and lime elements share a common three-dimensional space, so the lime element renders as tilting out from its parent, influenced by the perspective on the container.
</p>

<figure>`3d-rendering-context-3d^dgm</figure>

</div>

			</section>
			<section id="accumulated-3d-transformation-matrix-computation">
<h4 title="Accumulated 3D Transformation Matrix Computation">6.1.4. 累積3D 変換行列の算出</h4>

<p class="trans-note">【
この節に用いられる
~IF, ~WHILE
その他の記号は ~SYMBOL_DEF_REFを参照。
掛け算（ × ）は、行列の積を意味する。
】【
原文の実行制御ロジックを一部 整理／改変している（明らかにおかしいところもあるので）
】【
行列の積のとり方など原文の~~解釈がはっきりしないので、想像で補完している。
】</p>

<p>
［
`~3D描画文脈$に属する要素を描画する際に利用される変形
］の最終的な値は、次の様に，~3D変換行列を累積して算出される：
◎
The final value of the transform used to render an element in a 3D rendering context is computed by accumulating an accumulated 3D transformation matrix as follows:
</p>


<ol>
	<li>
`変換^V ~LET 単位行列
◎
Let transform be the identity matrix.
</li>
	<li>
`現在の要素^V ~LET 対象の変形要素
◎
Let current element be the transformed element.
</li>
	<li>
`根~要素^V ~LET `現在の要素^V の`~3D描画文脈$を確立した要素
◎
↓</li>
	<li>
<p>
~WHILE ( `現在の要素^V ~NEQ `根~要素^V )：
◎
Let ancestor block be the element that establishes the transformed element’s containing block.
◎
While current element is not the element that establishes the transformed element’s 3D rendering context:
<p>

		<ol>
			<li>
~IF
`現在の要素^V に対する `transform$p の値が `none^v でない：
<br />&nbsp;&nbsp;
`変換^V ~SET ( `現在の要素^V の`変換行列$ ) × `変換^V
◎
If current element has a value for transform which is not none, pre-multiply current element’s transformation matrix with the transform.
</li>

			<li>
`先祖~塊^V ~LET `現在の要素^V の`包含塊$を確立した要素
◎
↓</li>

			<li>
`変換^V ~SET (
`現在の要素^V の `先祖~塊^V からの~offsetを表現する並進~行列
) × `変換^V
◎
Compute a translation matrix which represents the offset of current element from its ancestor block, and pre-multiply that matrix into the transform.
</li>
			<li>
~IF
`先祖~塊^V に対する `perspective$p の値が `none^v でない：
<br />&nbsp;&nbsp;
`変換^V ~SET ( `先祖~塊^V の`透視行列$ ) × `変換^V
◎
If ancestor block has a value for perspective which is not none, pre-multiply the ancestor block’s perspective matrix into the transform.
</li>
			<li>
`現在の要素^V ~SET `先祖~塊^V
◎
Let ancestor block be the element that establishes the current element’s containing block.
◎
Let current element be the ancestor block.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
ここに述べたように，`累積~3D変換行列$は、［
変形要素~上の`視覚~整形~model$, および［
変形要素から それの`~3D描画文脈$を確立した要素までにある，先祖の連鎖~内の要素
］］により生成された~offset織り込む。
◎
Note: as described here, the accumulated 3D transformation matrix takes into account offsets generated by the visual formatting model on the transformed element, and elements in the ancestor chain between the transformed element and the element that establishes the its 3D rendering context.
</p>

			</section>
			<section id="backface-visibility">
<h4 title="Backface Visibility">6.1.5. 裏面可視性</h4>

<p>
~3D変形を利用すれば、要素を，その裏側が可視になるように変形させられる。
`~3D変形要素$は，その両側にて同じ内容を示すので、裏側は表側の鏡像に見えるようになる（要素を鏡に映し出したかのように）。
通常は、裏側を向けている要素は，視点から可視~のままであるが、
`backface-visibility$p ~propの利用により，要素を その裏側が視点に向いているときには不可視にさせられる。
この挙動は “動的（ live ）” である
—
例えば，
<span class="css">`backface-visibility$p: `hidden^v</span>
にされた要素が，その表側と裏側が交互に可視になる様に~animateされている場合、表側が視点に向くときにのみ可視になる
◎
Using three-dimensional transforms, it’s possible to transform an element such that its reverse side is visible. 3D-transformed elements show the same content on both sides, so the reverse side looks like a mirror-image of the front side (as if the element were projected onto a sheet of glass). Normally, elements whose reverse side is towards the viewer remain visible. However, the backface-visibility property allows the author to make an element invisible when its reverse side is towards the viewer. This behavior is "live"; if an element with backface-visibility: hidden were animating, such that its front and reverse sides were alternately visible, then it would only be visible when the front side were towards the viewer.
</p>

<p>
要素の裏側の可視性は，`累積~3D変換行列$を用いて考慮されるので、それを封入している`平坦的~要素$に相対的になる。
【可視性は平坦的~要素の平面に垂直な方向から決まる？】
◎
Visibility of the reverse side of an element is considered using the accumulated 3D transformation matrix, and is thus relative to the enclosing flattening element.
</p>


<p class="note">注記：
この~propは、遊戯用~cardを作成するときのように， 2 個の要素を裏表に貼り合わせるときに有用になる。
この~propが無ければ、表面と裏面の要素は，~animationで~cardが裏返される度に互いの位置を交換することになる【従って、常に片方しか見えない】。
別の例として、 6 要素で囲まれた直方体の内面だけを見せたいときが挙げられる。
◎
Note: This property is useful when you place two elements back-to-back, as you would to create a playing card. Without this property, the front and back elements could switch places at times during an animation to flip the card. Another example is creating a box out of 6 elements, but where you want to see only the inside faces of the box.
</p>

<div class="example">

<p>
次の例に、 "#card" 要素が~clickされたときに裏返されるように見せる方法を示す。
裏返すときに平坦的にならないようにするため、
#card 上には
<samp class="css">`transform-style^p: `preserve-3d^v</samp>
を要することに注意。
◎
This example shows how to make a "card" element that flips over when clicked. Note the "transform-style: preserve-3d" on #card which is necessary to avoid flattening when flipped.
</p>

<pre>
&lt;style&gt;
.body { perspective: 500px; }
#card {
    position: relative;
    height: 300px; width: 200px;
    transition: transform 1s;
    transform-style: preserve-3d;
}
#card.flipped {
    transform: rotateY(180deg);
}
.face {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: silver;
    border-radius: 40px;
    backface-visibility: hidden;
}
.back {
    transform: rotateY(180deg);
}
&lt;/style&gt;
&lt;div id="card" onclick="this.classList.toggle('flipped')"&gt;
    &lt;div class="front face"&gt;Front&lt;/div&gt;
    &lt;div class="back face"&gt;Back&lt;/div&gt;
&lt;/div&gt;
</pre>

</div>

<p class="issue">
`backface-visibility^p は
非~変形要素／ ~2D`変形要素$には どう~~影響する？
それぞれが所有する平面の中へ <!-- ＊ -->pop され, 交差するのか？【？】
◎
what is the impact of backface-visibility on non-transformed or 2D-transformed elements? Do they get popped into their own planes and intersect?
</p>

			</section>
		</section>
		<section id="processing-of-perspective-transformed-boxes">
<h3 title="Processing of Perspective-Transformed Boxes">6.2. 遠近法により変形された~boxの処理</h3>

<p class="issue">
これは、供された行列を利用して 要素をどの程度~正確に変形するかを，精確に指定するための最初の試案である。
それは，理想的なものではないかもしれない
— 実装者からの~feedbackを歓迎する。
`15605$bug
参照。
◎
This is a first pass at an attempt to precisely specify how exactly to transform elements using the provided matrices. It might not be ideal, and implementer feedback is encouraged. See bug 15605.
</p>

<p>
`累積~3D変換行列$は、`perspective$p ~prop, および
`transform$p ~prop値の中に在る `perspective()^v 変形関数から影響される。
◎
The accumulated 3D transformation matrix is affected both by the perspective property, and by any perspective() transform function present in the value of the transform property.
</p>

<p>
この`累積~3D変換行列$は 4×4 行列であるが，変形される~objectは~2D~boxである。
~boxの各~隅
( %a, %b )
を変形するためには、行列はまず，
( %a, %b, 0 ,1 ) †
に，適用され~MUST
— これにより，四次元の点
( %x, %y, %z, %w ) ††
が得られることになる。
これは，次の様に変換されて ~3Dの点
( %x′, %y′, %z′) †††
に戻される：
◎
This accumulated 3D transformation matrix is a 4×4 matrix, while the objects to be transformed are two-dimensional boxes. To transform each corner (a, b) of a box, the matrix must first be applied to (a, b, 0, 1), which will result in a four-dimensional point (x, y, z, w). This is transformed back to a three-dimensional point (x′, y′, z′) as follows:
</p>

<p class="trans-note">【
すなわち、~2D空間を~3D射影空間に埋め込んだ上で（†），4 次~行列により写像した結果（††）を，~3D空間（†††）に戻す。
】</p>

<dl >
	<dt>%w &gt; 0 の場合：</dt>
	<dd><p>
( %x′, %y′, %z′)
=
( %x ∕ %w, %y ∕ %w, %z ∕ %w )
◎
If w &gt; 0, (x′, y′, z′) = (x/w, y/w, z/w).
</p>
</dd>

	<dt>%w = 0 の場合：</dt>
	<dd>
<p>
( %x′, %y′, %z′) = 
( %x × %n, %y × %n, %z × %n )
</p>

<p>
%n
は実装依存の値であり、なるべく［
%x′ または %y′
が表示域~sizeに比して，ずっと大きくなる
］ように選ばれるべきである。
例えば， %n = 1000 にした場合、
(5px, 22px, 0px, 0)
に対しては
(5000px, 22000px, 0px)
になるが、この %n の値は
(0.1px, 0.05px, 0px, 0)
に対しては 小さ過ぎることになる。
この仕様は、 %n についての正確な値は定義しない。
概念的には、
( %x′, %y′, %z′)
は
( %x, %y, %z )
方向の<a href="http://en.wikipedia.org/wiki/Plane_at_infinity">無限遠</a>に位置する。
◎
If w = 0, (x′, y′, z′) = (x ⋅ n, y ⋅ n, z ⋅ n). n is an implementation-dependent value that should be chosen so that x′ or y′ is much larger than the viewport size, if possible. For example, (5px, 22px, 0px, 0) might become (5000px, 22000px, 0px), with n = 1000, but this value of n would be too small for (0.1px, 0.05px, 0px, 0). This specification does not define the value of n exactly. Conceptually, (x′, y′, z′) is infinitely far in the direction (x, y, z).
</p>

<p class="trans-note">【
すなわち、射影空間の中の，実~3D空間では表現し得ない無限遠点については、なるべく近い表示になるような近似的な値で代用する。
】</p>

	</dd>
</dl>

<p>
変形された~boxの 4 隅すべてで %w &lt; 0 の場合、~boxは描画されない。
◎
If w &lt; 0 for all four corners of the transformed box, the box is not rendered.
</p>

<p>
変形された~boxの 1 〜 3 個の隅で %w &lt; 0 の場合、~boxは［
%w &lt; 0 の領域
］により隅を切り取った多角形に置換され~MUST。
これは一般に頂点が 3 〜 5 個の多角形であって, そのうち 2 個の隣接する頂点では %w = 0, 残りの頂点では %w &gt; 0 になる。
しかる後，これらの頂点は
前段落の規則を利用して，~3Dの点に変形される。
概念的には，%w &lt; 0 の点は`視点$の “背後” に位置し，従って可視でなくなるべきである。
◎
If w &lt; 0 for one to three corners of the transformed box, the box must be replaced by a polygon that has any parts with w &lt; 0 cut out. This will in general be a polygon with three to five vertices, of which exactly two will have w = 0 and the rest w &gt; 0. These vertices are then transformed to three-dimensional points using the rules just stated. Conceptually, a point with w &lt; 0 is "behind" the viewer, so should not be visible.
</p>

<div class="example">
<pre>
&lt;style&gt;
.transformed {
  height: 100px;
  width: 100px;
  background: lime;
  transform: perspective(50px) translateZ(100px);
}
&lt;/style&gt;</pre>


<p>
~boxのどの隅の %z 座標も，`perspective$f に与えた視点の Z 座標より大きい。
これは~boxが視点の背後にあって表示されないことを意味する。
数学的には、点
( %x, %y )
は，まず
( %x, %y, 0, 1)
にされた後，
( %x, %y, 100, 1)
に並進され，遠近法が適用されて
( %x, %y, 100, −1)
になる。
この座標の %w 成分が負になるため，表示されない。
実装は %w &lt; 0 の事例を分けて取り扱う必要がある。
さもなければ、この座標を −1 で割った
( − %x, − %y, −100 )
による，不正な表示（~boxの鏡像）になり得る。
◎
All of the box’s corners have z-coordinates greater than the perspective. This means that the box is behind the viewer and will not display. Mathematically, the point (x, y) first becomes (x, y, 0, 1), then is translated to (x, y, 100, 1), and then applying the perspective results in (x, y, 100, −1). The w-coordinate is negative, so it does not display. An implementation that doesn’t handle the w &lt; 0 case separately might incorrectly display this point as (−x, −y, −100), dividing by −1 and mirroring the box.
</p>
</div>

<div class="example">
<pre>
&lt;style&gt;
.transformed {
  height: 100px;
  width: 100px;
  background: radial-gradient(yellow, blue);     /* <span class="comment">黄色, 青色</span> */
  transform: perspective(50px) translateZ(50px);
}
&lt;/style&gt;</pre>


<p>
ここでは、~boxは，中心が視点と同じ所に据えられように，上層へ並進される。
これは，視野~全体が埋まるまで，~boxを限りなく視点に近付けるようにする。
既定の `transform-origin$p は，~boxの中心の黄色に塗られる部分に位置するので、~screenは黄色で埋められることになる。
◎
Here, the box is translated upward so that it sits at the same place the viewer is looking from. This is like bringing the box closer and closer to one’s eye until it fills the entire field of vision. Since the default transform-origin is at the center of the box, which is yellow, the screen will be filled with yellow.
</p>



<p>
数学的には、点
( %x, %y )
は，最初に
( %x, %y, 0, 1)
としてから,
( %x, %y, 50, 1)
に並進され,
遠近法を適用した結果，
( %x, %y, 50, 0)
になる。
左上~隅（ p とする）は、中心に~~位置する変換原点から相対的に
(−50, −50)
の所にあるので， p は
(−50, −50, 50, 0)
に~~位置する。
これは左上から十分に遠い ある地点，例えば
(−5000, −5000, 5000)
に変形される。
同様に、他の隅も十分に遠い所に移される。
~box全体に引き延ばされる放射型~gradient（ `radial-gradient^p ）は，今や非常に広大になるので、可視~部分は，~scrollを伴わないとするなら，中央の画素の色, 黄色になる筈である。
しかしながら，~boxは実際には無限でないので、利用者は依然として，周辺まで~scrollして青色~部分を見ることも可能である。
◎
Mathematically, the point (x, y) first becomes (x, y, 0, 1), then is translated to (x, y, 50, 1), then becomes (x, y, 50, 0) after applying perspective. Relative to the transform-origin at the center, the upper-left corner was (−50, −50), so it becomes (−50, −50, 50, 0). This is transformed to something very far to the upper left, such as (−5000, −5000, 5000). Likewise the other corners are sent very far away. The radial gradient is stretched over the whole box, now enormous, so the part that’s visible without scrolling should be the color of the middle pixel: yellow. However, since the box is not actually infinite, the user can still scroll to the edges to see the blue parts.
</p>
</div>

<div class="example">
<pre>
&lt;style&gt;
.transformed {
  height: 50px;
  width: 50px;
  background: lime;
  border: 25px solid blue;
  transform-origin: left;
  transform: perspective(50px) rotateY(-45deg);
}
&lt;/style&gt;</pre>


<p>
~boxの左~辺は固定され、右~辺は扉が開く様に，`視点$に向かって 45° 回転されることになる。
右~辺は、遠近法の値 `50px^v より大きい
%z = `70.7px^v
の所に位置させられるので，（視点の “背後” に）消失することになり、可視~部分は，右方へ無限に遠くまで引き延ばされることになる。
◎
The box will be rotated toward the viewer, with the left edge staying fixed while the right edge swings closer. The right edge will be at about z = 70.7px, which is closer than the perspective of 50px. Therefore, the rightmost edge will vanish ("behind" the viewer), and the visible part will stretch out infinitely far to the right.
</p>

<p>
数学的には、元々の~~位置が変換原点から相対的に
(100, −50)
の所にあった~boxの右上~頂点は、最初に
(100, −50, 0, 1)
に展開された上で，指定された変形が適用され、およそ
(70.71, −50, 70.71, −0.4142)
の所に写像される。
この %w 座標 −0.4142 は &lt; 0
なので，~boxから［
%w &lt; 0 の領域
］に入る部分を切り取る必要がある。
その結果，新たな右上~頂点は
(50, −50, 50, 0)
になる。
しかる後、これは同じ方向の, 変換原点から上の右方の，遠く離れたある点（例えば
(5000, −5000, 5000)
）に写像される。
右下~隅についても同様の演算が行われ，遠く右下方へ写像される。
結果の~boxは、~screenの辺を大きく越えて延ばされる。
◎
Mathematically, the top right vertex of the box was originally (100, −50), relative to the transform-origin. It is first expanded to (100, −50, 0, 1). After applying the transform specified, this will get mapped to about (70.71, −50, 70.71, −0.4142). This has w = −0.4142 &lt; 0, so we need to slice away the part of the box with w &lt; 0. This results in the new top-right vertex being (50, −50, 50, 0). This is then mapped to some faraway point in the same direction, such as (5000, −5000, 5000), which is up and to the right from the transform-origin. Something similar is done to the lower right corner, which gets mapped far down and to the right. The resulting box stretches far past the edge of the screen.
</p>


<p>
ここでも、描画される~boxは依然として有限であり，利用者は~scrollして全部を見れる。
しかしながら、右側部分
— 元の~boxの右~端から `30px^v 程の部分 —
は，すでに切り取られており、利用者の~scroll量に関わらず，可視でなくなる。
幅 `25px^v の青色の~borderについては、左端, 上端, 下端は可視になるが，右端はそうでない。
◎
Again, the rendered box is still finite, so the user can scroll to see the whole thing if he or she chooses. However, the right part has been chopped off. No matter how far the user scrolls, the rightmost 30px or so of the original box will not be visible. The blue border was only 25px wide, so it will be visible on the left, top, and bottom, but not the right.
</p>



<p>
1 個／ 3 個の頂点で %w &lt; 0 になる場合も、同じ基本的~~手続きが適用されることになる。
ただし、この場合の［
%w &lt; 0 領域
］の切り取りによる結果は、四辺形ではなく, 三角形／五角形になる。
◎
The same basic procedure would apply if one or three vertices had w &lt; 0. However, in that case the result of truncating the w &lt; 0 part would be a triangle or pentagon instead of a quadrilateral.
</p>
</div>

		</section>
	</section>
	<section id="transform-property">
<h2 title="The transform Property">7. `transform^p ~prop</h2>

<p>
変換は、 `transform$p ~propを通して要素が描画される座標系に適用される。
この~propは`変形関数$の~listを包含する。
座標系に対する最終的な変換の結果は、`変形関数の数学的~記述$にて定義されるように，~listの中の各~関数を対応する行列に換算した上で，それらの行列の積をとることにより得られる。
◎
A transformation is applied to the coordinate system an element renders in through the transform property. This property contains a list of transform functions. The final transformation value for a coordinate system is obtained by converting each function in the list to its corresponding matrix like defined in Mathematical Description of Transform Functions, then multiplying the matrices.
</p>


`●名^ `transform@p
`●値^
`none^v | `transform-list$t
`●初^ `none^v
`●適^ `変形可能$な要素
`●継^ されない
`●百^
`基準~box$の~sizeに相対的
◎
refer to the size of reference box
`●媒^ 視覚的
`●算^
指定値。ただし，相対長は絶対長に換算される。
◎
As specified, but with relative lengths converted into absolute lengths.
`●ア^ <a href="#interpolation-of-transforms">変形</a>として補間される
`●表終^

<p>
`transform^p に対する `none^v 以外のどの算出値も，積層文脈と`包含塊$の両者を作成させる。
~objectは、固定位置にされた子孫に対し，包含塊としてふるまう。
◎
Any computed value other than none for the transform results in the creation of both a stacking context and a containing block. The object acts as a containing block for fixed positioned descendants.
</p>

<pre class="prod">`transform-list@t = `transform-function$t+</pre>


		<section id="serialization-of-transform-functions">
<h3 title="Serialization of &lt;transform-function&gt;s">7.1. `transform-function^t の直列化</h3>

<p>
`transform-function$t を直列化するためには、文法に記された順序に従って，それらの個々の文法に従って直列化する
— その際には、
可能な所では `calc$f 式を避け【？】,
`calc$f 変換は避け【？】,
可能な所では意味を変えずに成分を省略し,
~space区切りのトークンは 1 個の~spaceで区切り,
直列化される各~commaごとに 1 個の~spaceを後続させる。
◎
To serialize the &lt;transform-function&gt;s, serialize as per their individual grammars, in the order the grammars are written in, avoiding &lt;calc()&gt; expressions where possible, avoiding &lt;calc()&gt; transformations, omitting components when possible without changing the meaning, joining space-separated tokens with a single space, and following each serialized comma with a single space.
</p>
		</section>


		<section id="serialization-of-the-computed-value">
<h3 title="Serialization of the computed value of &lt;transform-list&gt;">7.2. `transform-list^t の算出値の直列化</h3>

<div>
<p>
`transform-list$t の`算出値$を直列化するときは、その中のすべての `transform-function$t を 4x4 行列に換算して積をとった結果が`~2D行列$の場合は、その結果を
`matrix$f
として直列化し，他の場合は
`matrix3d$f
として直列化する。
</p>

	<div lang="en">
<p>
A &lt;transform-list&gt; for the computed value is serialized to either one &lt;matrix()&gt; or one &lt;matrix3d()&gt; function by the following algorithm:
</p>

<ol>
	<li>
Let transform be a 4x4 matrix initialized to the identity matrix. The elements m11, m22, m33 and m44 of transform must be set to 1 all other elements of transform must be set to 0.
</li>
	<li>
Post-multiply all &lt;transform-function&gt;s in &lt;transform-list&gt; to transform.
</li>
	<li>
<p>
Chose between &lt;matrix()&gt; or &lt;matrix3d()&gt; serialization:
</p>
		<dl class="switch">
			<dt>If transform is a 2D matrix</dt>
			<dd>Serialize transform to a &lt;matrix()&gt; function.</dd>
			<dt>Otherwise</dt>
			<dd>Serialize transform to a &lt;matrix3d()&gt; function.</dd>
		</dl>
	</li>
</ol>

	</div>
</div>

<!-- 

<a class="production css-code" data-link-type=function href=#funcdef-matrix title=matrix()>&lt;matrix()&gt;</a> or one 
<a class="production css-code" data-link-type=function href=#funcdef-matrix3d title=matrix3d()>&lt;matrix3d()&gt;</a> function by the following algorithm:
 -->


		</section>

	</section>
	<section id="transform-origin-property">
<h2 title="The transform-origin Property">8. `transform-origin^p ~prop</h2>

`●名^ `transform-origin@p
`●値^
[ `left$vt | `center$vt | `right$vt | `top$vt | `bottom$vt | `percentage$t | `length$t ]
<br>|<br>
[ `left$vt | `center$vt | `right$vt | `percentage$t | `length$t ]<br>
[ `top$vt | `center$vt | `bottom$vt | `percentage$t | `length$t ] `length$t?
<br>|<br>
[ [ `center$vt | `left$vt | `right$vt ] &amp;&amp; [ `center$vt | `top$vt | `bottom$vt ] ] `length$t?
`●初^ `50% 50%^v
`●適^ `変形可能$な要素
`●継^ されない
`●百^
`基準~box$の~sizeに相対的
◎
refer to the size of reference box
`●媒^ 視覚的
`●算^
`length$t に対しては絶対値, 他の場合は百分率
◎
For &lt;length&gt; the absolute value, otherwise a percentage.
`●ア^
`長さ, 百分率, calc 式$の`単純~list$として補間される
◎
as simple list of length, percentage, or calc
`●表終^


<p>
CSS ~layout~~boxが結び付けられていない SVG 要素に対する初期時の`使用値$は `0 0^v である。
◎
The initial used value for SVG elements without associated CSS layout box is 0 0.
</p>

<p>
`transform$p, `transform-origin$p
~propの値は、上述に従って`変換行列$を算出するために利用される。
◎
The values of the transform and transform-origin properties are used to compute the transformation matrix, as described above.
</p>

<p>
指定された（成分）値が 1 個だけの場合、 2 番目の値は `center$vt と見なされる。
指定された値が 2 個~以下の場合、 3 番目の値は `0px^v と見なされる。
◎
If only one value is specified, the second value is assumed to be center. If one or two values are specified, the third value is assumed to be 0px.
</p>

<p>
この補完により得られた 3 値のうち，最初の 2 個の値のいずれにも
`center$vt 以外の~keywordが利用されていない場合、最初の値が
横位置（または~offset）を表現し，
2 番目の値は
縦位置（または~offset）を表現する。
<!-- 
他の場合、~keywordが対応する［横／縦］位置（または~offset）を表現し，もう片方の値が他方の次元の位置（または~offset）を表現する。
 -->
3 番目の値は常に Z 位置（または~offset）を表現し， `length$t 型で~MUST。
◎
If two or more values are defined and either no value is a keyword, or the only used keyword is center, then the first value represents the horizontal position (or offset) and the second represents the vertical position (or offset). A third value always represents the Z position (or offset) and must be of type &lt;length&gt;.
</p>

<dl data-dfn-for="transform-origin">
	<dt>`percentage$t</dt>
	<dd><p>
百分率~値は、`基準~box$の左上~隅からの［
横／縦
］~offsetを表現し，`基準~box$の［
横幅／縦幅
］に相対的になる。
◎
A percentage for the horizontal offset is relative to the width of the reference box. A percentage for the vertical offset is relative to height of the reference box. The value for the horizontal and vertical offset represent an offset from the top left corner of the reference box.
</p></dd>

	<dt>`length$t</dt>
	<dd><p>
長さ値は、固定長による`基準~box$の左上~隅からの［
横／縦 【 および Z 方向の】
］~offsetを表現する。
◎
A length value gives a fixed length as the offset. The value for the horizontal and vertical offset represent an offset from the top left corner of the reference box.
</p></dd>

	<dt>`top@vt</dt>
	<dd><p>
縦位置に対する `0%^v に算出される。
◎
Computes to 0% for the vertical position.
</p></dd>

	<dt>`right@vt</dt>
	<dd><p>
横位置に対する `100%^v に算出される。
◎
Computes to 100% for the horizontal position.
</p></dd>

	<dt>`bottom@vt</dt>
	<dd><p>
縦位置に対する `100%^v に算出される。
◎
Computes to 100% for the vertical position.
</p></dd>

	<dt>`left@vt</dt>
	<dd><p>
横位置に対する `0%^v に算出される。
◎
Computes to 0% for the horizontal position.
</p></dd>

	<dt>`center@vt</dt>
	<dd><p>
横位置が指定されていない場合、横位置に対する 50% （したがって［
<code class="value">50% `&lt;縦位置の指定&gt;^V …</code>
］†）に算出される。
他の場合、縦位置に対する 50% （したがって［
<code class="value">`&lt;横位置の指定&gt;^V 50% …</code>
］†）に算出される。
【 † 原文の記述は変だったので修正】
◎
Computes to 50% (left 50%) for the horizontal position if the horizontal position is not otherwise specified, or 50% (top 50%) for the vertical position if it is.
</p></dd>

</dl>

<p>
`transform-origin$p の`解決値$は`使用値$で与えられる（すなわち，百分率は絶対長に解決される）。
◎
The resolved value of transform-origin is the used value (i.e., percentages are resolved to absolute lengths).
</p>

	</section>
	<section id="transform-box">

<h2 title="Transform reference box: the transform-box ~prop">9. 変形~基準~box： `transform-box^p ~prop</h2>


`●名^ `transform-box@p
`●値^
`border-box$vb | `fill-box$vb | `view-box$vb
`●初^ `border-box^v
`●適^ `変形可能$な要素
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値
`●ア^ 不可
`●表終^

<p>
`transform$p, `transform-origin$p 
~propにより定義される すべての変換に対し，その位置と寸法は、次のいずれかの
`基準~box@
に相対的になる：
◎
All transformations defined by the transform and transform-origin property are relative to the position and dimension of one of the following reference boxes:
</p>

<dl>
	<dt>`border-box@vb</dt>
	<dd><p>
`~border~box$を基準~boxに利用する。
~tableの基準~boxは、その~table~boxではなく，その`~table包装~box$の~border~boxになる。
◎
Uses the border box as reference box. The reference box of a table is the border box of its table wrapper box, not its table box. 
</p></dd>

	<dt>`fill-box@vb</dt>
	<dd><p>
`~object限界~box$を基準~boxに利用する。
◎
Uses the object bounding box as reference box. 
</p></dd>

	<dt>`view-box@vb</dt>
	<dd>
<p>
最も近い `SVG 表示域$（ viewport ）を基準~boxに利用する。
◎
Uses the nearest SVG viewport as reference box.
</p>

<p class="trans-note">【
“最も近い表示域” — 
要素の先祖†の中で
<a href="~SVG11/coords.html#EstablishingANewViewport" >SVG 表示域を確立する</a>
様な要素のうち，要素に最も近い先祖が確立した表示域（†
要素~自身も含めるかどうかは，はっきりしない）。
】</p>


<p>
`SVG 表示域$を作成している【確立している】要素に
`viewBox$svgattr 属性が指定されている場合：
◎
If a ‘viewBox‘ attribute is specified for the SVG viewport creating element:
</p>

      <ul>
			<li>
基準~boxは
`viewBox$svgattr 属性により確立される座標系の原点に位置される。
◎
The reference box is positioned at the origin of the coordinate system established by the ‘viewBox‘ attribute.
</li>
			<li>
基準~boxの寸法は
`viewBox$svgattr 属性の <em>width</em>, <em>height</em> 成分~値に設定される。
◎
The dimension of the reference box is set to the width and height values of the ‘viewBox‘ attribute.
</li>
		</ul>
	</dd>
</dl>

<p>
基準~boxは、
`transform-origin$p ~propにより指定される原点に対し，追加の~offsetを加える
◎
A reference box adds an additional offset to the origin specified by the transform-origin property.
</p>

<p>
CSS ~layout~boxが結び付けられていない SVG 要素に対しては、
`border-box$vb に対する`使用値$は `view-box$vb になる。
◎
For SVG elements without an associated CSS layout box, the used value for border-box is view-box.
</p>

<p>
CSS ~layout~boxが結び付けられている要素に対しては、
`fill-box$vb ／ `view-box$vb に対する`使用値$は `border-box$vb になる。
◎
For elements with an associated CSS layout box, the used value for fill-box and view-box is border-box.
</p>




	</section>
	<section id="transform-style-property">
<h2 title="The transform-style Property">10. `transform-style^p ~prop</h2>

`●名^ `transform-style@p
`●値^ `auto^v | `flat^v | `preserve-3d^v
`●初^ `flat^v
`●適^ `変形可能$な要素
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値と同じ◎Same as specified value.
`●ア^ 不可
`●表終^

<p>
`transform-style$p に対する値 `flat^v は、積層文脈を確立し，`~3D描画文脈$を確立する。
使用値に `auto^v を伴う要素は、~3D描画文脈を算出する目的においては，無視される。
使用値に `preserve-3d^v を伴う要素は、それが属する~3D描画文脈を拡張する
— そうでないときに `transform$p ／ `perspective$p ~propの値が`平坦的$を指示する場合でも。
値 `preserve-3d^v は積層文脈, および包含塊を確立させる。
◎
A value of "flat" for transform-style establishes a stacking context, and establishes a 3D rendering context. Elements with a used value of "auto" are ignored for the purposes of 3D rendering context computation, and those with a used value of "preserve-3d" extend the 3D rendering context to which they belong, even if values for the transform or perspective properties would otherwise cause flattening. A value of "preserve-3d" establishes a stacking context, and a containing block.
</p>

		<section id="grouping-property-values">
<h3 title="Grouping property values">10.1. ~grouping~prop値</h3>

<p>
以下の CSS ~prop値は、適用し得る様になる前に，~UAによる［
子孫~要素の平坦化された表現
］の作成-を要する。
したがって `transform-style$p の使用値を `flat^v に強制する：
◎
The following CSS property values require the user agent to create a flattened representation of the descendant elements before they can be applied, and therefore force the used value of transform-style to flat:
</p>

<table><tbody><tr><td>`overflow$p</td><td>
`visible^v 以外の任意の値
◎
overflow: any value other than visible.

</td></tr><tr><td>`opacity$p</td><td>
1 より小さい任意の値
◎
opacity: any value less than 1.

</td></tr><tr><td>`filter$p</td><td>
`none^v 以外の任意の値
◎
filter: any value other than none.

</td></tr><tr><td>`clip$p</td><td>
`auto^v 以外の任意の値
◎
clip: any value other than auto.

</td></tr><tr><td>`clip-path$p</td><td>
`none^v 以外の任意の値
◎
clip-path: any value other than none.

</td></tr><tr><td>`isolation$p</td><td>
使用値 `isolate^v
◎
isolation: used value of isolate.

</td></tr><tr><td>`mask-image$p</td><td>
`none^v 以外の任意の値
◎
mask-image: any value other than none.

</td></tr><tr><td>`mask-border-source$p</td><td>
`none^v 以外の任意の値
◎
mask-border-source: any value other than none.

</td></tr><tr><td>`mix-blend-mode$p</td><td>
`normal^v
以外の任意の値
◎
mix-blend-mode: any value other than normal.

</td></tr></tbody></table>

<p>
以下の CSS ~prop値は、
`transform-style$p に対する使用値を `flat^v に強制する：
◎
The following CSS property values cause an auto value of transform-style to become flat:
</p>

<table><tbody><tr><td>`transform$p</td><td>
`none^v 以外の任意の値
◎
transform: any value other than none.

</td></tr><tr><td>`perspective$p</td><td>
`none^v 以外の任意の値
◎
perspective: any value other than none.
</td></tr></tbody></table>

<p>
いずれの場合も， `transform-style$p の算出値は影響されない。
◎
In both cases the computed value of transform-style is not affected.
</p>

<p class="issue">
`overflow^p が非 `visible^v にされた どの要素も、
`transform-style$p が `flat^v に強制される結果，積層文脈になってしまう
— それは、求められていない。
`28252$bug を見よ。
◎
Having overflow imply transform-style: flat causes every element with non-visible overflow to become a stacking context, which is unwanted. See Bug 28252.
</p>

		</section>
	</section>
	<section id="perspective-property">
<h2 title="The perspective Property">11. `perspective^p ~prop</h2>

`●名^ `perspective@p
`●値^
`none^v | `length$t
`●初^ `none^v
`●適^ `変形可能$な要素
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^
絶対長または `none^v
◎
Absolute length or "none".
`●ア^ `長さ$として補間される
`●表終^

<p>
`length$t 値は正で~MUST。
◎
Where &lt;length&gt; values must be positive.
</p>

<dl data-dfn-for="perspective">
	<dt>`length$t</dt>
	<dd>
<p>
射影の中心からの距離。
◎
Distance to the center of projection.
Issue: Verify that projection is the distance to the center of projection.
</p>

<p class="issue">
射影が射影の中心までの距離であることの検証。【？】
◎
Verify that projection is the distance to the center of projection.
</p>
	</dd>

	<dt><dfn id="none">none</dfn></dt>
	<dd><p>
遠近法による変形は適用されない。
その効果は、数学的には，無限大の `length$t 値に近似する。
すべての~objectは、~canvas上に平坦に現れる。

◎
No perspective transform is applied. The effect is mathematically similar to an infinite &lt;length&gt; value. All objects appear to be flat on the canvas.
</p></dd>
</dl>

<p>
この~propに対する `none^v 以外の値は、積層文脈を確立する。
それは、 `transform$p ~propのときとちょうど同じ様に，（ある意味
<span class="css">`position$p: `relative^v</span>
に似た）包含塊も確立する。
◎
The use of this property with any value other than none establishes a stacking context. It also establishes a containing block (somewhat similar to position: relative), just like the transform property does.
</p>

<p>
`perspective$p,
`perspective-origin$p
~propの値は、上述に従って`透視行列$の算出に利用される。
◎
The values of the perspective and perspective-origin properties are used to compute the perspective matrix, as described above.
</p>

	</section>
	<section id="perspective-origin-property">
<h2 title="The perspective-origin Property">12. `perspective-origin^p ~prop</h2>

<p>
`perspective-origin$p ~propは， `perspective$p ~propのための原点を確立する。
それは、実質的に，想定される［
要素の一連の子を俯瞰する`視点$
］の X, Y 位置を設定する。
◎
The perspective-origin property establishes the origin for the perspective property. It effectively sets the X and Y position at which the viewer appears to be looking at the children of the element.
</p>

`●名^ `perspective-origin@p
`●値^ `position$t
`●初^ `50% 50%^v
`●適^ `変形可能$な要素
`●継^ されない
`●百^
`基準~box$の~sizeに相対的
◎
refer to the size of the reference box.
`●媒^ 視覚的
`●算^
`length$t に対しては絶対値, 他の場合は百分率
◎
For &lt;length&gt; the absolute value, otherwise a percentage.
`●ア^
`長さ, 百分率, calc 式$の`単純~list$として補間される
◎
as simple list of length, percentage, or calc
`●表終^

<p>
`perspective$p, `perspective-origin$p
~propの値は、上述に従って`透視行列$の算出に利用される。
◎
The values of the perspective and perspective-origin properties are used to compute the perspective matrix, as described above.
</p>

<p>
`perspective-origin$p に対する値は、遠近法の原点の，
`基準~box$
の左上~隅からの~offsetを表現する。
◎
The values for perspective-origin represent an offset of the perspective origin from the top left corner of the reference box.
</p>

<dl data-dfn-for="perspective-origin">
	<dt>`percentage$t</dt>
	<dd>
遠近法~offsetに対する［
横／縦
］の百分率~値は，`基準~box$の［
横幅／縦幅
］に相対的になる。
【絶対化された結果の】~offset値は，`基準~box$の左上~隅からの横縦~offsetを表現する。
◎
A percentage for the horizontal perspective offset is relative to the width of the reference box. A percentage for the vertical offset is relative to height of the reference box. The value for the horizontal and vertical offset represent an offset from the top left corner of the reference box.
</dd>

	<dt>`length$t</dt>
	<dd>
長さ値は固定長を~offsetとして与える。
~offset値は、`基準~box$ の左上~隅からの横縦~offsetを表現する。
◎
A length value gives a fixed length as the offset. The value for the horizontal and vertical offset represent an offset from the top left corner of the reference box.
</dd>

	<dt>`top@vp</dt>
	<dt>`right@vp</dt>
	<dt>`bottom@vp</dt>
	<dt>`left@vp</dt>
	<dd>
		<ul>
			<li>
与えられた成分~値の個数が 3 個 以上ある下で，これらの~keywordの次の成分として［
`percentage^t ／ `length^t
］値が与えられているならば、その値は，上に挙げられた順に［
上端, 右端, 下端, 左端
］辺からの~offsetを表現することになる。
</li>
			<li>
他の場合、これらの~keywordは，上に挙げられた順に［
縦位置に対する `0%^v,
横位置に対する `100%^v,
縦位置に対する `100%^v,
横位置に対する `0%^v,
］に算出される。
</li>
		</ul>

◎
Computes to 0% for the vertical position if one or two values are given, otherwise specifies the top edge as the origin for the next offset.
◎
Computes to 100% for the horizontal position if one or two values are given, otherwise specifies the right edge as the origin for the next offset.
◎
Computes to 100% for the vertical position if one or two values are given, otherwise specifies the bottom edge as the origin for the next offset.
◎
Computes to 0% for the horizontal position if one or two values are given, otherwise specifies the left edge as the origin for the next offset.
</dd>

	<dt>`center@vp</dt>
	<dd>
横位置が指定されていない場合、横位置に対する 50% （ `left 50%^v ）に算出される。
他の場合、縦位置に対する 50% （ `top 50%^v ）に算出される。
◎
Computes to 50% (left 50%) for the horizontal position if the horizontal position is not otherwise specified, or 50% (top 50%) for the vertical position if it is.
</dd>

</dl>

<p>
`perspective-origin$p の`解決値$は`使用値$になる（すなわち，百分率は絶対長に解決される）。
◎
The resolved value of perspective-origin is the used value (i.e., percentages are resolved to absolute lengths).
</p>

	</section>
	<section id="backface-visibility-property">
<h2 title="The backface-visibility Property">13. `backface-visibility^p ~prop</h2>

`●名^ `backface-visibility@p
`●値^ `visible^v | `hidden^v
`●初^ `visible^v
`●適^ `変形可能$な要素
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値と同じ◎Same as specified value.
`●ア^ 不可
`●表終^

<p>
<span class="css">`backface-visibility$p: `hidden^v</span>
を伴う要素の可視性は、次の様にして決定される：
◎
The visibility of an element with backface-visibility: hidden is determined as follows:
</p>

<ol>
	<li>
要素の`累積~3D変換行列$を算出する。
◎
Compute the element’s accumulated 3D transformation matrix.
</li>

	<li>
行列の `33^m 成分が負の場合、要素は見えなくされるべきである。
他の場合は可視である。
◎
If the component of the matrix in row 3, column 3 is negative, then the element should be hidden. Otherwise it is visible.
</li>
</ol>


<p class="issue">
裏面可視性は `33^m を調べるだけでは判明しない。
`23014$bug を見よ。
◎
Backface-visibility cannot be tested by only looking at m33. See Bug 23014.
</p>

<p class="trans-note">【
すなわち、下に述べられている論拠の中の %z 値の大きさ比較と, 視点からの距離の比較は、必ずしも整合しない（例えば、矩形が Y 軸を中心に 90° 近く回転された状態で，右方／左方に位置するとき）。
】</p>

<p class="note">注記：
この定義の論拠は次で与えられる：
要素が，薄さ無限小の x–y 平面に埋め込まれた矩形であるとする。
要素が変形されないときの［
表面／裏面
］の座標は，ある極小の %ε に対し
( %x, %y, %ε ) ／ ( %x, %y, − %ε )
になる。
変換の後，要素の表面が裏面よりも
`視点$に近くなる（ %z 値がより高くなる）か, 視点から遠くなるか
どうかを調べればよい。
表面の %z 座標は、遠近法を織り込む前の段階で
`13^m × %x + `23^m × %y + `33^m × %ε + `43^m
になり，裏面は
`13^m × %x + `23^m × %y − `33^m × %ε + `43^m
になる。
前者の量が後者より大きくなるのは、 `33^m &gt; 0 のとき, そのときに限る。
（ゼロに等しいときは，視点からの表面と裏面の近さは等しくなる。
これはおそらく 90° 回転の様な何かを意味する
—
それは，いずれにせよ要素を不可視にするので、消失するかどうかを考慮する必要はない）
◎
Note: The reasoning for this definition is as follows. Assume elements are rectangles in the x–y plane with infinitesimal thickness. The front of the untransformed element has coordinates like (x, y, ε), and the back is (x, y, −ε), for some very small ε. We want to know if after the transformation, the front of the element is closer to the viewer than the back (higher z-value) or further away. The z-coordinate of the front will be m13x + m23y + m33ε + m43, before accounting for perspective, and the back will be m13x + m23y − m33ε + m43. The first quantity is greater than the second if and only if m33 &gt; 0. (If it equals zero, the front and back are equally close to the viewer. This probably means something like a 90-degree rotation, which makes the element invisible anyway, so we don’t really care whether it vanishes.)
</p>

	</section>
	<section id="svg-transform">
<h2 title="The SVG transform Attribute">14. SVG `transform^svgattr 属性</h2>

<p>
SVG 1.1 仕様は、［
`transform$svgattr,
`gradientTransform$svgattr,
`patternTransform$svgattr
］属性を，`呈示属性$ `SVG11$r
として指定していない。
SVG と HTML の統合を向上させるため、この仕様は，これらの SVG 属性を呈示属性として， `transform$p ~propを［
SVG 名前空間における`変形可能$な要素
］にも適用し得るものにする。
◎
The SVG 1.1 specification did not specify the attributes transform, gradientTransform or ‘patternTransform‘ as presentation attributes [SVG11]. In order to improve the integration of SVG and HTML, this specification makes these SVG attributes presentation attributes and makes the transform property one that applies to transformable elements in the SVG namespace.
</p>

<p>
この仕様は、新たな呈示属性として：
`transform-origin$p,
`perspective$p,
`perspective-origin$p,
`transform-style$p,
`backface-visibility$p
も導入する。
◎
This specification will also introduce the new presentation attributes transform-origin, perspective, perspective-origin, transform-style and backface-visibility.
</p>

<p>
新たに導入された呈示属性の値は
<a href="#svg-data-types">SVG ~data型</a>
`SVG11$r
の構文~規則に従って構文解析される。
◎
Values on new introduced presentation attributes get parsed following the syntax rules on SVG Data Types [SVG11].
</p>

		<section id="transform-attribute-specificity">
<h3 title="SVG transform attribute specificity">14.1. SVG `transform^svgattr 属性の詳細度</h3>

<p>
先に挙げた SVG 属性は呈示属性とされたので、それらの CSS ~cascadeへの関与†は， SVG 仕様の`呈示属性$の詳細度により決定される。
◎
Since the previously named SVG attributes become presentation attributes, their participation in the CSS cascade is determined by the specificity of presentation attributes in the SVG specification.
</p>

<p class="trans-note">【
† 具体的には、 SVG 仕様の当該箇所，あるいは
CSS ~cascade仕様の
<a href="~CSSWG/css-cascade-3/#preshint">非 CSS 呈示hintの優先順位</a>
を参照
】</p>

<div class="example">
<p>
`transform$p ~style~propと
`transform$svgattr 呈示属性の組合せを示す例：
◎
This example shows the combination of the transform style property and the transform presentation attribute.
</p>

<pre>
&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;style&gt;
  .container {
      transform: translate(100px, 100px);
  }
  &lt;/style&gt;

  &lt;g class="container" transform="translate(200 200)"&gt;
      &lt;rect width="100" height="100" fill="blue" /&gt;
  &lt;/g&gt;
&lt;/svg&gt;</pre>

<figure>`svg-translate1^dgm</figure>

<p>
CSS ~cascadeに関与することから、 `transform$p ~style~propは， `transform$svgattr 呈示属性を上書きする。
従って，容器は横と縦いずれの方向にも `200px^v ではなく `100px^v 並進される。
◎
Because of the participation to the CSS cascade, the transform style property overrides the transform presentation attribute. Therefore the container gets translated by 100px in both the horizontal and the vertical directions, instead of 200px.
</p>
</div>

		</section>
		<section id="svg-syntax">
<h3 title="Syntax of the SVG transform attribute">14.2. SVG `transform^svgattr 属性の構文</h3>

<p>
後方互換性を保つため、 `transform$svgattr 呈示属性の構文は，上の例に示された様に
`transform$p ~style~propの構文と異なる。
しかしながら、
`transform$p ~style~propに利用される構文は， `transform$svgattr 呈示属性の値にも利用できる。
作者には、
値単位Module `CSS3VAL$r
の規則に従うことを勧める。
従って、作者は，例えば
<samp>`transform^svgattr="`translate (200 200)^v"</samp>
の代わりに
<samp>`transform^svgattr="`translate(200px, 200px)^v"</samp>
と記すべきである。
［
開き丸括弧（ '<code>(</code>' ）の前の~space,
引数の合間の~commaの省略,
値における明示的な単位~表記の省略
］が妥当になるのは、属性においてのみなので。
◎
To provide backwards compatibility, the syntax of the transform presentation attribute differs from the syntax of the transform style property as shown in the example above. However, the syntax used for the transform style property can be used for a transform presentation attribute value. Authors are advised to follow the rules of CSS Values and Units Module [CSS3VAL]. Therefore an author should write ''transform="translate(200px, 200px)" instead of transform="translate (200 200)" because the second example with the spaces before the ('', the missing comma between the arguments and the values without the explicit unit notation would be valid for the attribute only.
</p>

			<section id="svg-transform-list">
<h4 title="Transform List">14.2.1. 変形~list</h4>

<p>
`transform$svgattr 属性に対する値は，ゼロ個~以上の［
`関数記法$を利用した変形関数
］からなる，変形~listである。
変形~listが複数個の変形関数からなる場合、これらの関数は［
空白,
1 個の~comma（ `,^v ）,
空白
］の並び（いずれも省略可）で互いに区切られ、~listの先頭や末尾に空白（省略可）があってもよい。
◎
The value for the transform attribute consists of a transform list with zero or more transform functions using functional notation. If the transform list consists of more than one transform function, these functions are separated by optional whitespace, an optional comma (,) and optional whitespace. The transform list can have optional whitespace characters before and after the list.
</p>

			</section>
			<section id="svg-functional-notation">
<h4 title="Functional Notation">14.2.2. 関数記法</h4>

<p>
関数記法の構文は［
関数の名前 ,
<!-- (空白), -->
左~丸括弧 ,
(空白) ,
関数の引数の並び,
(空白) ,
右~丸括弧
］の並びである（ (空白) はいずれも省略可）。
関数が複数個の引数をとる場合、それらの引数は［
前後に空白（省略可）を伴い得る~comma（ <code>,</code> ）
］または［
1 個~以上の空白
］により，互いに区切られる。
◎
The syntax starts with the name of the function followed by a left parenthesis followed by optional whitespace followed by the argument(s) to the notation followed by optional whitespace followed by a right parenthesis. If a function takes more than one argument, the arguments are either separated by a comma (,) with optional whitespace characters before and after the comma, or by one or more whitespace characters.
</p>


<p class="note">注記：
SVG 1.1 と異なり，この仕様では、関数の名前と左~丸括弧の間には空白は 許容されない。
◎
Note: Unlike SVG 1.1, this specification does not allow optional whitespace between the name of the function and the left parenthesis.
</p>


			</section>
			<section id="svg-data-types">
<h4 title="SVG Data Types">14.2.3. SVG ~data型</h4>

<p>
新たに導入された呈示属性~上のすべての引数は，値単位Module `CSS3VAL$r による~data型からなる。
値単位Moduleの~data型の定義は、以下の様に~~拡張される：
◎
Arguments on all new introduced presentation attributes consist of data types in the sense of CSS Values and Units Module [CSS3VAL]. The definitions of data types in CSS Values and Units Module are enhanced as follows:
</p>

				<section id="svg-transform-value">
<h5 title="The &lt;length&gt; type">14.2.3.1. 長さ： `length^t 型</h5>
<p>
`length$t は，単位~識別子を伴わない実数 — `number$t にもなり得る。
この場合の`実数$は、 “`利用単位$” による値として解釈される。
`初期座標系$の下での利用単位は、親の環境の画素~単位と等価な概念0になる。
◎
A &lt;length&gt; can be a &lt;number&gt; without an unit identifier. In this case the number gets interpreted as "user unit". A user unit in the the initial coordinate system is equivalent to the parent environment’s notion of a pixel unit.
</p>

				</section>
				<section id="svg-angle">
<h5 title="The <angle> type">14.2.3.2. 角度： `angle^t 型</h5>

<p>
角度は，単位~識別子を伴わない `number$t にもなり得る。
この場合の`実数$は、度数（ degree ）による値として解釈される。
◎
An angle can be a &lt;number&gt; without an unit identifier. In this case the number gets interpreted as a value in degrees.
</p>

				</section>
				<section id="svg-number">
<h5 title="The &lt;number&gt; type">14.2.3.3. 実数： `number^t 型</h5>

<p>
SVG は科学的~記数法による実数を~supportする。
従って実数は、 SVG 属性に対する SVG の基本~data型
<a href="~SVG11/types.html#DataTypeNumber">number</a>
による構文に従って構文解析される。
◎
SVG supports scientific notations for numbers. Therefore a number gets parsed like described in SVG Basic data types for SVG attributes.
</p>

				</section>
			</section>
		</section>
		<section id="svg-gradient-transform-pattern-transform">
<h3 title="The SVG gradientTransform and patternTransform attributes">14.3. SVG `gradientTransform^svgattr, `patternTransform^svgattr 属性</h3>

<p>
この仕様は、 SVG にて指定される
`gradientTransform$svgattr,
`patternTransform$svgattr
属性を`呈示属性$とする。
両~属性とも，SVG `transform$svgattr 属性の`構文$と同じ構文を利用する。
この仕様は，対応する CSS ~style~propは導入しない。
両~属性とも `transform$p ~propのための呈示属性である。
◎
SVG specifies the attributes gradientTransform and ‘patternTransform‘. This specification makes both attributes presentation attributes. Both attributes use the same syntax as the SVG transform attribute. This specification does not introduce corresponding CSS style properties. Both, the gradientTransform and the ‘patternTransform‘ attribute, are presentation attributes for the transform property.
</p>

		</section>
		<section id="svg-transform-functions">
<h3 title="SVG transform functions">14.4. SVG 変形関数</h3>

<p>
既存の SVG 内容との後方互換性のため、この仕様は，
`transform$svgattr 属性 `SVG11$r にて定義されるすべての変形関数を~supportする。
したがって~2D~変形関数
<span class="css">rotate(`angle^t)</span>
は，次の様に拡張される：
◎
For backwards compatibility with existing SVG content, this specification supports all transform functions defined by The ‘transform’ attribute in [SVG11]. Therefore the two-dimensional transform function rotate(&lt;angle&gt;) is extended as follows:
</p>

<dl class="proddefs">
	<dt id="rotate-three-function">`rotate$f = rotate( `angle$t [, `length$t, `length$t]? )</dt>
	<dd><p >
`transform-origin$p ~propにて定義される要素の原点を中心とする, 引数に指定された度数による`~2D回転$を指定する。
省略可の 2 個の並進~引数が指定されている場合、 `transform-origin^p は，回転~演算において（現在の変換行列を通して）その分量だけ並進される。
例えば
`rotate(90deg, 100px, 100px)^v
は、変換原点を横縦 ~両~方向に 100 画素ずつ並進させた上で，要素を時計回りに 90° 回転させて現れるようにする。
◎
specifies a 2D rotation by the angle specified in the parameter about the origin of the element, as defined by the transform-origin property. If the optional translation values are specified, the transform origin is translated by that amount (using the current transformation matrix) for the duration of the rotate operation. For example rotate(90deg, 100px, 100px) would cause elements to appear rotated one-quarter of a turn in the clockwise direction after a translation of the transform-origin of 100 pixel in the horizontal and vertical directions.
</p></dd>
</dl>

<p>
~UAには、 SVG 名前空間に属する要素~上の並進についてのみ，並進~引数の~supportが要求される。
◎
User agents are just required to support the two optional arguments for translation on elements in the SVG namespace.
</p>

		</section>
		<section id="svg-three-dimensional-functions">
<h3 title="SVG and 3D transform functions">14.5. SVG と~3D変形関数</h3>

<p>
この仕様は、次に挙げる要素に対し，~3D~変形関数の適用-を明示的に要求する：
［
`容器~要素$
— `a$svg, `g$svg, `svg$svg
］,
すべての`~graphics要素$,
すべての`~graphics参照~要素$,
SVG の `foreignObject$svg 要素
◎
This specification explicitly requires three-dimensional transform functions to apply to the container elements: &lt;a&gt;, &lt;g&gt;, &lt;svg&gt;, all graphics elements, all graphics referencing elements and the SVG &lt;foreignObject&gt; element.
</p>

<p>
~3D~変形関数, および 次の~prop：
`perspective$p,
`perspective-origin$p,
`transform-style$p,
`backface-visibility$p
は、次の要素には利用できない：
`clipPath$svg,
`linearGradient$svg,
`radialGradient$svg,
`pattern$svg
。
それらに対し，変形~listに~3D~変形関数が含まれている場合、変形~list全体が無視され~MUST。
また、先に挙げたどの~propの値も無視され~MUST。
これらの要素に包含されている`変形可能$な要素は、~3D~変形関数を持ち得る。
`clipPath$svg ／ `mask$svg ／ `pattern$svg
要素は、その適用-に先立って，~UAによる［
子孫~要素の平坦化された表現
］の作成-を要するので、
<span class="css">`transform-style$p: `preserve-3d^v</span>
の挙動を上書きする。
◎
Three-dimensional transform functions and the properties perspective, perspective-origin, transform-style and backface-visibility can not be used for the elements: &lt;clipPath&gt;, &lt;linearGradient&gt;, &lt;radialGradient&gt; and &lt;pattern&gt;. If a transform list includes a three-dimensional transform function, the complete transform list must be ignored. The values of every previously named property must be ignored. Transformable elements that are contained by one of these elements can have three-dimensional transform functions. The &lt;clipPath&gt;, &lt;mask&gt;, &lt;pattern&gt; elements require the user agent to create a flattened representation of the descendant elements before they can be applied, and therefore override the behavior of transform-style: preserve-3d.
</p>

<p>
`~3D描画文脈$に属する~objectに対しては、 `vector-effect$p ~propが `non-scaling-stroke^v にされていても，~objectの~strokingには影響しない。
◎
If the vector-effect property is set to non-scaling-stroke and an object is within a 3D rendering context the property has no affect on stroking the object.
</p>

		</section>
		<section id="svg-user-coordinate-space">
<h3 title="User coordinate space">14.6. 利用空間</h3>

<p>
`pattern$svg,
`linearGradient$svg,
`radialGradient$svg,
`clipPath$svg
要素に対しては、
`transform$svgattr,
`patternTransform$svgattr,
`gradientTransform$svgattr
`呈示属性$は、これらの要素の参照元における現在の利用座標系（すなわち，
`fill$p ／ `stroke$p
~propを通して `pattern$svg 要素を参照している要素の利用座標系）における値を表現する。
百分率~値は、その参照元の要素の`基準~box$に相対的になる。
◎
For the &lt;pattern&gt;, &lt;linearGradient&gt;, &lt;radialGradient&gt; and &lt;clipPath&gt; elements the transform, patternTransform, gradientTransform presentation attributes represents values in the current user coordinate system in place at the time when these elements are referenced (i.e., the user coordinate system for the element referencing the &lt;pattern&gt; element via a fill or stroke property). Percentage values are relative to the reference box of the referencing element.
</p>

<p>
特に，
`patternUnits$svgattr,
`gradientUnits$svgattr,
`maskUnits$svgattr
属性 `SVG11$r は、変換に利用される利用座標系に影響しない。
◎
In particular the patternUnits, gradientUnits and maskUnits attributes don’t affect the user coordinate system used for transformations [SVG11].
</p>

<p>
他のすべての`変形可能$な要素に対しては、
`transform$svgattr 呈示属性は，親の［
現在の利用座標系
］における値を表現する。
`transform$svgattr 呈示属性の百分率~値は、要素の`基準~box$に相対的になる。
◎
For all other transformable elements the transform presentation attribute represents values in the current user coordinate system of the parent. All percentage values of the transform presentation attribute are relative to the element’s reference box.
</p>

<div class="example">


<p>
次の例の `pattern^code 上の `transform-origin$p ~propは、原点の横縦 次元に `50%^v の並進を指定する。
`transform$p ~propも並進を指定するが，絶対長である。
◎
The transform-origin property on the pattern in the following example specifies a 50% translation of the origin in the horizontal and vertical dimension. The transform property specifies a translation as well, but in absolute lengths.
</p>

<pre>
&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;style&gt;
  pattern {
      transform: rotate(45deg);
      transform-origin: 50% 50%;
  }
  &lt;/style&gt;

  &lt;defs&gt;
  &lt;pattern id="pattern-1"&gt;
      &lt;rect id="rect1" width="100" height="100" fill="blue" /&gt;
  &lt;/pattern&gt;
  &lt;/defs&gt;

  &lt;rect width="200" height="200" fill="url(#pattern-1)" /&gt;
&lt;/svg&gt;</pre>


<p>
SVG
`pattern$svg 要素は限界~boxを持たないので、 `transform-origin$p ~propを相対的な値に解決する際に，参照元の `rect$svg 要素の`基準~box$が代わりに利用される。
したがって原点は，`pattern$svg 要素~内容の利用空間を回転させる前に，一時的に 100 画素だけ並進されることになる。
◎
An SVG &lt;pattern&gt; element doesn’t have a bounding box. The reference box of the referencing &lt;rect&gt; element is used instead to solve the relative values of the transform-origin property. Therefore the point of origin will get translated by 100 pixels temporarily to rotate the user space of the &lt;pattern&gt; elements content.
</p>
</div>



		</section>
		<section id="transform-attribute-dom">
<h3 title="SVG DOM interface for the transform attribute">14.7. `transform^svgattr 属性に対する SVG DOM ~interface</h3>

<p>
SVG 仕様では，SVG DOM にて SVG 
`transform$svgattr,
`gradientTransform$svgattr,
`patternTransform$svgattr
属性の~animate, および その`基底値$への~accessを提供するための
`SVGAnimatedTransformList$svgdom ~interfaceが定義されている。
後方互換性を確保するため，この API は依然として~UAから~supportされ~MUST。
◎
The SVG specification defines the 'SVGAnimatedTransformList' interface in the SVG DOM to provide access to the animated and the base value of the SVG transform, gradientTransform and ‘patternTransform‘ attributes. To ensure backwards compatibility, this API must still be supported by user agents.
</p>

<p>
`transform$p ~propは CSS ~cascadeに寄与する。
SVG 1.1 に倣い、~UAは、`呈示属性$のための
<a href="~SVG11/styling.html#UsingPresentationAttributes">新たな作者~stylesheet</a>
を概念的に挿入する。
それは、一連の作者~stylesheetの中で最初のものになる。
`baseVal^svgdom により，作者は SVG `transform$svgattr 属性の値に対する~accessと変更が可能になる。
SVG DOM に必要な後方互換性を提供するため、 `baseVal^svgdom は，この作者~stylesheetの値を反映し~MUST。
SVG DOM ~object `baseVal^svgdom に加えられるすべての変更は、即時にこの作者~stylesheetに反映され~MUST。
◎
The transform property contributes to the CSS cascade. According to SVG 1.1 user agents conceptually insert a new author style sheet for presentation attributes, which is the first in the author style sheet collection. baseVal gives the author the possibility to access and modify the values of the SVG transform attribute. To provide the necessary backwards compatibility to the SVG DOM, baseVal must reflect the values of this author style sheet. All modifications to SVG DOM objects of baseVal must affect this author style sheet immediately.
</p>

<p>
`animVal^svgdom は， `transform$p ~propの算出styleを表現する。
したがって それには、適用されている
<a href="http://www.w3.org/TR/css3-transitions/">CSS3 Transitions</a>,
<a href="http://www.w3.org/TR/css3-animations/">CSS3 Animations</a>,
<a href="#svg-animation">SVG ~animation</a>
すべての効果も含められる。
算出styleと SVG DOM ~object `animVal^svgdom に変更を加えることはできない。
◎
animVal represents the computed style of the transform property. Therefore it includes all applied CSS3 Transitions, CSS3 Animations or SVG Animations if any of those are underway. The computed style and SVG DOM objects of animVal can not be modified.
</p>

<p>
`SVGTransform$svgdom の `type$svgdom 属性は、`変形関数$や，この~interfaceにより~supportされる単位~型に対しては， `SVG_TRANSFORM_UNKNOWN$svgdom を返さ~MUST。
~2D~変形関数が~supportされていない場合でも、 `matrix$svgdom 属性は，`変形関数の数学的~記述$ 節の記述に従って，その関数と等価な変換を表現する 3x2 `SVGMatrix$svgdom を返さ~MUST。
◎
The attribute 'type' of 'SVGTransform' must return 'SVG_TRANSFORM_UNKNOWN' for Transform Functions or unit types that are not supported by this interface. If a two-dimensional transform function is not supported, the attribute 'matrix' must return a 3x2 'SVGMatrix' with the corresponding values as described in the section Mathematical Description of Transform Functions.
</p>

		</section>
	</section>
	<section id="svg-animation">
<h2 title="SVG Animation">15. SVG ~animation</h2>

		<section id="svg-animate-element">
<h3 title="The &lt;animate&gt; and &lt;set&gt; element">15.1. `animate^svg, `set^svg 要素</h3>

<p>
この仕様は、 `animate$svg, `set$svg 要素が，~data型 `transform-list$t を~animateし得るものと定める。
◎
With this specification, the &lt;animate&gt; element and the &lt;set&gt; element can animate the data type &lt;transform-list&gt;.
</p>

<p>
`transform-list$t ~animationに固有の挙動から、加法的 `animate$svg ~animation（後述）による効果は，下層値に対する加算ではなく, 後置積になる。
◎
The animation effect is post-multiplied to the underlying value for additive &lt;animate&gt; animations (see below) instead of added to the underlying value, due to the specific behavior of &lt;transform-list&gt; animations.
</p>

<p class="trans-note">【
下層値（ underlying value ） — 他の~animationを適用した結果の値
】【
後置積（ post-multiply ）
— 変換 %T を元の変換 %T0 に~~合成する
— その結果、図形は， %T で変形されてから %T0 で変形されて表示に現れる
— 対応する行列~演算においては，変換行列により右から積をとることに対応する。
】</p>

<p>
`from-to^b, `from-by^b, `by^b
~animationは、 SMIL の対応する `values^b ~animationに等価なものとして，定義される。
しかしながら， `to^b ~animationは、加法的／非~加法的 な挙動の混成になる。
`SMIL3$r
◎
From-to, from-by and by animations are defined in SMIL to be equivalent to a corresponding values animation. However, to animations are a mixture of additive and non-additive behavior [SMIL3].
</p>

<p class="trans-note">【
参考： SMIL Animation 仕様によるこれらの~animationの定義の<a href="https://triple-underscore.github.io/SVG/smil_animation-ja.html#AnimFuncValues" >和訳</a>
】</p>

<p>
`animate$svg 上の `to^b ~animationは、下層値から `to^svgattr 属性~値への滑らかな変化を得るような特定の機能性を提供する。
それは、加法的 変形~animationに対する後置積の要件と数学的に競合する。
ゆえに、 `animate$svg に対する `to^b ~animationの挙動は未定義である。
作者には、望ましい変形~animationを得る際には，
`from-to^b, `from-by^b, `by^b, `values^b
~animationの利用を勧める。
◎
To animations on &lt;animate&gt; provide specific functionality to get a smooth change from the underlying value to the to attribute value, which conflicts mathematically with the requirement for additive transform animations to be post-multiplied. As a consequence, the behavior of to animations for &lt;animate&gt; is undefined. Authors are suggested to use from-to, from-by, by or values animations to achieve any desired transform animation.
</p>

<p>
`animate$svg 要素~上の `calcMode$svgattr 属性に対する値 `paced^v （定速）は、
`transform-list$t ~data型の~animationに対しては未定義である。
指定された場合、~UA は，代わりに値 `linear^v を選んでもよい。
この仕様の将来~versionは `transform-list$t 上で定速~animationをどう遂行するかを定義し得る。
◎
The value paced is undefined for the attribute calcMode on &lt;animate&gt; for animations of the data type &lt;transform-list&gt;. If specified, UAs may choose the value linear instead. Future versions of this specification may define how paced animations can be performed on &lt;transform-list&gt;.
</p>

<p class="note">注記：
次の段落は
`~animate可能な要素, 属性, ~prop$ `SVG11$r
を拡張する。
◎
Note: The following paragraphs extend Elements, attributes and properties that can be animated [SVG11].
</p>

<p>
この仕様により`呈示属性$とされる~prop［
`transform$p ,
`transform-origin$p,
`perspective$p,
`perspective-origin$p,
`transform-style$p,
`backface-visibility$p
］は，~animate可能である。
`transform-style$p,
`backface-visibility$p 
は，非~加法的である。
◎
The introduce presentation attributes transform, transform-origin, perspective, perspective-origin, transform-style and backface-visibility are animatable. transform-style and backface-visibility are non-additive.
</p>

<p>
この仕様により、 SVG 基本~data型 `transform-list$t は， `transform-function$t の~listに等価であるとされる。
`transform-list$t は，~animate可能かつ加法的である。
この~data型は SVG `animate$svg 要素と SVG `set$svg 要素を利用して~animateできる。
SVG ~animationは，
<a href="#interpolation-of-transforms">変形どうしの補間</a>
節による手続きに従って 実行され~MUST。
<!-- 
表の構成から yes/no が何を意味するのか曖昧だが，おそらく加法的かどうか？
 -->
◎
With this specification the SVG basic data type &lt;transform-list&gt; is equivalent to a list of &lt;transform-function&gt;s. &lt;transform-list&gt; is animatable and additive. The data type can be animated using the SVG &lt;animate&gt; element and the SVG &lt;set&gt; element. SVG animations must run the same animation steps as described in section Transitions and Animations between Transform Values.
</p>

<table class="data">
	<caption>~animate可能な~data型◎Animatable data types</caption>
	<thead><tr>
<th title="Data type">~data型</th>
<th title="Additive?">加法的？</th>
<th>`animate$svg</th>
<th>`set$svg</th>
<th>`animateColor$svg</th>
<th>`animateTransform$svg</th>
<!-- 
<th>Notes</th>
 -->
	</tr></thead>
	<tbody>
    <tr>
<th>`transform-list$t</th>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<!-- 
<td>Additive for animateTransform means ...</td>
-->
    </tr>
	</tbody>
</table>

<p>
`animateTransform$svg における加法的とは、基底の変換~列に対し，変換による後置積をとることを意味する。
◎
Additive for animateTransform means that a transformation is post-multiplied to the base set of transformations.
</p>


		</section>
		<section id="neutral-element">
<h3 title="Neutral element for addition">15.2. 加法における単位元</h3>

<div >
<p>
一部の~animationは、加法における単位元を要する。
変形関数に対しては、これは 0 値の~scalarまたはその~listである。
変形関数に対する単位元の例には，次のものが挙げられる：
</p>

<ul>
<li>`translate(0)^v</li>
<li>`translate3d(0, 0, 0)^v</li>
<li>`translateX(0)^v</li>
<li>`translateY(0)^v</li>
<li>`translateZ(0)^v</li>
<li>`scale(0)^v</li>
<li>`scaleX(0)^v</li>
<li>`scaleY(0)^v</li>
<li>`scaleZ(0)^v</li>
<li>`rotate(0)^v</li>
<li><span class="value">rotate3d(v<sub>x</sub>, v<sub>y</sub>, v<sub>z</sub>, 0)</span>（ここで %v は文脈~依存~vector）</li>
<li>`rotateX(0)^v</li>
<li>`rotateY(0)^v</li>
<li>`rotateZ(0)^v</li>
<li>`skew(0, 0)^v</li>
<li>`skewX(0)^v</li>
<li>`skewY(0)^v</li>
<li>`matrix(0, 0, 0, 0, 0, 0)^v</li>
<li>`matrix3d(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)^v</li>
<li>`perspective(0)^v</li>
</ul>

◎
Some animations require a neutral element for addition. For transform functions this is a scalar or a list of scalars of 0. Examples of neutral elements for transform functions are translate(0), translate3d(0, 0, 0), translateX(0), translateY(0), translateZ(0), scale(0), scaleX(0), scaleY(0), scaleZ(0), rotate(0), rotate3d(vx, vy, vz, 0) (where v is a context dependent vector), rotateX(0), rotateY(0), rotateZ(0), skew(0, 0), skewX(0), skewY(0), matrix(0, 0, 0, 0, 0, 0), matrix3d(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) and perspective(0).
</div>


<p class="note">注記：
［
`matrix$f, `matrix3d$f, `perspective$f
］による単位元［
からの（ `from^b ） ／への（ `to^b ）
］~animationは、離散的な~animationに~fall-backする（`行列の補間$を見よ）。
◎
Note: Animations to or from the neutral element of additions matrix(), matrix3d() and perspective() fall back to discrete animations (See Interpolation of Matrices).
</p>

<div class="example">


<p>
`by^b 値 %by を伴う `by^b ~animationは、
%O を［
~animate対象の属性の値域に対する，加法の単位元
］とするとき、［
%O, %by
］の 2 値からなる `values^b ~list, および［
`additive="sum"^code
］］による同じ~animation `SMIL3$r と等価である。
◎
A by animation with a by value vb is equivalent to the same animation with a values list with 2 values, the neutral element for addition for the domain of the target attribute (denoted 0) and vb, and ''additive="sum"''. [SMIL3]
</p>

<pre>
&lt;rect width="100" height="100"&gt;
&lt;animateTransform attributeName="transform" attributeType="XML"
type="scale" by="1" dur="5s" fill="freeze"/&gt;
&lt;/rect&gt;</pre>


<p>
<code>type="scale"</code> を伴う
`by^b ~animationを遂行する際の，加法における単位元は値 0 である。
従って，上の例に対する~animationでは、矩形は 0 秒の時点では不可視であり（~animateされる変形~list値は `scale(0)^v になるので），
5 秒 経過後に，拡縮されて元の~sizeに戻される（~animateされる変形~list値は `scale(1)^v になるので）。
◎
The neutral element for addition when performing a by animation with ''type="scale" is the value 0. Thus, performing the animation of the example above causes the rectangle to be invisible at time 0s (since the animated transform list value is scale(0)), and be scaled back to its original size at time 5s (since the animated transform list value is scale(1)'').
</p>
</div>



		</section>
		<section id="svg-attribute-name">
<h3 title="The SVG attributeName attribute">15.3. SVG `attributeName^svgattr 属性</h3>

<p>
<a href="~SVG11/animate.html">SVG 1.1 ~animation</a>
では、~animateされる属性の名前を指定するための `attributeName$svgattr 属性が定義されている（ SVG2 ：
<a href="https://svgwg.org/svg2-draft/animate.html#AttributeNameAttribute"><code >attributeName</code></a>
）。
`呈示属性$である
`gradientTransform$svgattr ／ `patternTransform$svgattr
に対しては、代わりに `transform^v を値に利用することもできる。
同じ `transform$p ~propが~animateされることになる。
◎
SVG 1.1 Animation defines the 'attributeName' attribute to specify the name of the target attribute. For the presentation attributes gradientTransform and ‘patternTransform‘ it will also be possible to use the value transform. The same transform property will get animated.
</p>

<div class="example">
<p>
この例では、［
線型~gradientによる~gradient変換<!-- ※ -->
］が~animateされる。
◎
In this example the gradient transformation of the linear gradient gets animated.
</p>

<pre>
&lt;linearGradient gradientTransform="scale(2)"&gt;
&lt;animate attributeName="gradientTransform"
    from="scale(2)"
    to="scale(4)"
    dur="3s"
    additive="sum"
/&gt;
&lt;animate attributeName="transform"
    from="translate(0, 0)"
    to="translate(100px, 100px)"
    dur="3s"
    additive="sum"
/&gt;
&lt;/linearGradient&gt;</pre>


<p>
`linearGradient$svg 要素には，呈示属性 `gradientTransform$svgattr が指定されている。
2 つの `animate$svg 要素は、~animateする対象の属性として，それぞれ
`gradientTransform$svgattr, `transform$svgattr
を指すが、両~animationとも， `gradientTransform$svgattr 呈示属性から値を得た上で，同じ~gradient変換に対し適用される
— 最初の~animationによる拡縮ingが適用されてから,
2 番目の~animationによる並進が適用される。
◎
The &lt;linearGradient&gt; element specifies the gradientTransform presentation attribute. The two &lt;animate&gt; elements address the target attribute gradientTransform and transform. Even so all animations apply to the same gradient transformation by taking the value of the gradientTransform presentation attribute, applying the scaling of the first animation and applying the translation of the second animation one after the other.
</p>
</div>


		</section>
	</section>
	<section id="transform-functions">
<h2 title="The Transform Functions">16. 変形関数</h2>

<p>
`transform$p ~propの値は
`transform-function@t の~listである。
許容される変形関数の集合は以下に与えられる。
この仕様にて `angle$t が利用される所では、ゼロに等しい `number$t も許容され，角度ゼロとして扱われる。
並進に対する［
横／縦
］の `percentage$t 値は，`基準~box$の［
横幅／縦幅
］に相対的になる。
◎
The value of the transform property is a list of &lt;transform-function&gt;. The set of allowed transform functions is given below. Wherever &lt;angle&gt; is used in this specification, a &lt;number&gt; that is equal to zero is also allowed, which is treated the same as an angle of zero degrees. A percentage for horizontal translations is relative to the width of the reference box. A percentage for vertical translations is relative to the height of the reference box.
</p>

		<section id="two-d-transform-functions">
<h3 title="2D Transform Functions">16.1. ~2D変形関数</h3>

<dl class="proddefs">
	<dt>`matrix@f = matrix( `number$t [, `number$t ]{5,5} )</dt>
	<dd><p>
与えられた 6 個の成分値による`~2D 3x2 行列$の`変換行列$で表現される，~2D変換を指定する。
◎
specifies a 2D transformation in the form of a transformation matrix of the six values a-f.
</p></dd>

	<dt>`translate@f = translate( `length$t | `percentage$t [, `length$t | `percentage$t ]? )</dt>
	<dd><p>
%tx, %ty を与えられた順による `translation-value^t 値とするとき、移動量~vector
[ %tx, %ty ]
による，`~2D並進$を指定する。
%ty は省略可であり、供されていない場合はゼロと見なされる。
◎
specifies a 2D translation by the vector [tx, ty], where tx is the first translation-value parameter and ty is the optional second translation-value parameter. If &lt;ty&gt; is not provided, ty has zero as a value.
</p></dd>

	<dt>`translateX@f = translateX( `length$t | `percentage$t )</dt>
	<dd><p>
与えられた `translation-value^t 値による， X 方向の`~2D並進$を指定する。
◎
specifies a translation by the given amount in the X direction.
</p></dd>

	<dt>`translateY@f = translateY( `length$t | `percentage$t )</dt>
	<dd><p>
与えられた `translation-value^t 値による， Y 方向の`~2D並進$を指定する。
◎
specifies a translation by the given amount in the Y direction.
</p></dd>

	<dt>`scale@f = scale( `number$t [, `number$t ]? )</dt>
	<dd><p>
%sx, %sy をそれぞれ，与えられた順による `number^t 値とするとき、拡縮率~vector
[ %sx, %sy ]
による，`~2D拡縮$を指定する。
%sy は省略可であり、供されていない場合は %sy と同じ値と見なされる。
例えば `scale(1, 1)^v は 要素を変形しないが， `scale(2, 2)^v は X, Y 両~軸に 2 倍の~~長さに（すなわち 面積を 4 倍に）する。
◎
specifies a 2D scale operation by the [sx,sy] scaling vector described by the 2 parameters. If the second parameter is not provided, it takes a value equal to the first. For example, scale(1, 1) would leave an element unchanged, while scale(2, 2) would cause it to appear twice as long in both the X and Y axes, or four times its typical geometric size.
</p></dd>

	<dt>`scaleX@f = scaleX( `number$t )</dt>
	<dd><p>
%sx を与えられた `number^t 値とするとき、拡縮率~vector
[ %sx, 1 ]
による，`~2D拡縮$を指定する。
◎
specifies a 2D scale operation using the [sx,1] scaling vector, where sx is given as the parameter.
</p></dd>

	<dt>`scaleY@f = scaleY( `number$t )</dt>
	<dd><p>
%sy を与えられた `number^t 値とするとき、拡縮率~vector
[ 1, %sx ]
による，`~2D拡縮$を指定する。
◎
specifies a 2D scale operation using the [1,sy] scaling vector, where sy is given as the parameter.
</p></dd>

	<dt>`rotate@f = rotate( `angle$t )</dt>
	<dd><p>
`transform-origin$p ~propにより定義される［
要素の原点
］を中心とする, 回転角 `angle^t による，`~2D回転$を指定する。
例えば `rotate(90deg)^v は、要素は，時計回りに 90° 回転されて現れることになる。
◎
specifies a 2D rotation by the angle specified in the parameter about the origin of the element, as defined by the transform-origin property. For example, rotate(90deg) would cause elements to appear rotated one-quarter of a turn in the clockwise direction.
</p></dd>

	<dt>`skew@f = skew( `angle$t [, `angle$t ]? )</dt>
	<dd><p>
%ax, %ay を与えられた順による `angle^t 値とするとき、
[ %ax, %ay ]
による， X 軸, Y 軸に対する`~2D斜傾$を指定する。
%ay は省略可であり、供されていない場合はゼロと見なされる。
◎
specifies a 2D skew by [ax,ay] for X and Y. If the second parameter is not provided, it has a zero value.
</p>

<p class="note">注記：
`skew$f の挙動は、`skewX$f と `skewY$f の積とは異なる。
旧来の内容との互換性のため、実装は この関数を~supportし~MUST。
◎
Note that the behavior of skew() is different from multiplying skewX() with skewY(). Implementations must support this function for compatibility with legacy content.
</p>
	</dd>
	<dt>`skewX@f = skewX( `angle$t )</dt>
	<dd><p>
与えられた角度による， `X 軸~不変の~2D斜傾$を指定する。
【 与えられた角度だけ Y 軸が傾くように， X 座標を Y 座標に比例する量だけずらす（ “skew” する）。 】
◎
specifies a 2D skew transformation along the X axis by the given angle.
</p></dd>

	<dt>`skewY@f = skewY( `angle$t )</dt>
	<dd><p>
与えられた角度による， `Y 軸~不変の~2D斜傾$を指定する。
【 与えられた角度だけ Y 軸が傾くように， Y 座標を X 座標に比例する量だけずらす（ “skew” する）。】
◎
specifies a 2D skew transformation along the Y axis by the given angle.
</p></dd>
</dl>



		</section>
		<section id="three-d-transform-functions">
<h3 title="3D Transform Functions">16.2. ~3D変形関数</h3>

<dl class="proddefs">
	<dt>`matrix3d@f = matrix3d( `number$t [, `number$t ]{15,15} )</dt>
	<dd><p>
16 個の成分値からなる，列主導の順序による 4x4 斉次~行列として、~3D変換を指定する。
◎
specifies a 3D transformation as a 4x4 homogeneous matrix of 16 values in column-major order.
</p></dd>

	<dt>`translate3d@f = translate3d( `length$t | `percentage$t , `length$t | `percentage$t , `length$t )</dt>
	<dd><p>
与えられた順による `translation-value^t 値からなる移動量~vector
[ %tx, %ty, %tz ]
による，`~3D並進$を指定する。
◎
specifies a 3D translation by the vector [tx,ty,tz], with tx, ty and tz being the first, second and third translation-value parameters respectively.
</p></dd>

	<dt>`translateZ@f = translateZ( `length$t )</dt>
	<dd><p>
%tz を与えられた `length^t 値とするとき、移動量~vector
[ 0, 0, %tz ]
による， Z 方向の`~3D並進$を指定する。
◎
specifies a 3D translation by the vector [0,0,tz] with the given amount in the Z direction.
</p></dd>

	<dt>`scale3d@f = scale3d( `number$t , `number$t, `number$t )</dt>
	<dd><p>
与えられた順による `number^t 値からなる移動量~vector
[ %sx, %sy, %sz ]
による，`~3D拡縮$を指定する。
◎
specifies a 3D scale operation by the [sx,sy,sz] scaling vector described by the 3 parameters.
</p></dd>

	<dt>`scaleZ@f = scaleZ( `number$t )</dt>
	<dd><p>
%sz を与えられた `number^t 値とするとき、拡縮率~vector
[ 0, 0, %sz ]
による，`~3D拡縮$を指定する。
◎
specifies a 3D scale operation using the [1,1,sz] scaling vector, where sz is given as the parameter.
</p></dd>

	<dt>`rotate3d@f = rotate3d( `number$t , `number$t , `number$t , `angle$t )</dt>
	<dd><p>
与えられた順による 3 個の `number^t 値からなる方向~vector
[ %x, %y, %z ]
を軸とする, 回転角 `angle^t による，`~3D回転$を指定する。
[ 0, 0, 0 ]
のような 正規化できない方向~vectorに対しては、回転は適用されない。
◎
specifies a 3D rotation by the angle specified in last parameter about the [x,y,z] direction vector described by the first three parameters. A direction vector that cannot be normalized, such as [0,0,0], will cause the rotation to not be applied.
</p>

<p class="note">注記：
回転は、~vectorが指す先から原点を見たときに時計回りになる。
◎
Note that the rotation is clockwise as one looks from the end of the vector toward the origin.
</p>
	</dd>

	<dt>`rotateX@f = rotateX( `angle$t )</dt>
	<dd><p>
`rotate3d(1, 0, 0, &lt;angle&gt;)^v
と同じ。
◎
same as rotate3d(1, 0, 0, &lt;angle&gt;).
</p></dd>

	<dt>`rotateY@f = rotateY( `angle$t )</dt>
	<dd><p>
`rotate3d(0, 1, 0, &lt;angle&gt;)^v
と同じ。
◎
same as rotate3d(0, 1, 0, &lt;angle&gt;).
</p></dd>

	<dt>`rotateZ@f = rotateZ( `angle$t )</dt>
	<dd><p>
`rotate3d(0, 0, 1, &lt;angle&gt;)^v
と同じ。
`rotate(&lt;angle&gt;)^v
とも同じ。
◎
same as rotate3d(0, 0, 1, &lt;angle&gt;), which is also the same as rotate(&lt;angle&gt;).
</p></dd>

	<dt>`perspective@f = perspective( `length$t )</dt>
	<dd><p>
`透視投影行列$を指定する。
この行列は、空間の点を，その Z 値に基づいて X, Y 方向に拡縮させる
—
正の Z 値を伴う点は，（画面~上では）原点から離れる方向に拡大させ、負の Z 値を伴う点は，原点に近付く方向に縮小させる。
z=0 平面~上の点は不変になる。
`length^t ~parameterは、`視点$から画面（ z=0 平面）までの距離を表現する。
この値を小さくする程、視点と画面の四隅を頂点とする四角錐は，より平たくなり、遠近法の効果が誇張されるようになる。
例えば，値 `1000px^v は中程度の遠近感を与え、値 `200px^v は極度の遠近感を与える。
この深度を与える値は正でなければならず，さもなければ関数は無効になる。
◎
specifies a perspective projection matrix. This matrix scales points in X and Y based on their Z value, scaling points with positive Z values away from the origin, and those with negative Z values towards the origin. Points on the z=0 plane are unchanged. The parameter represents the distance of the z=0 plane from the viewer. Lower values give a more flattened pyramid and therefore a more pronounced perspective effect. For example, a value of 1000px gives a moderate amount of foreshortening and a value of 200px gives an extreme amount. The value for depth must be greater than zero, otherwise the function is invalid.
</p></dd>
</dl>




		</section>
	</section>
	<section id="transform-function-lists">
<h2 title="The Transform Function Lists">17. 変形関数の~list</h2>

<p>
`transform-function$t の~listが提供された場合、その正味の効果は，各~変形関数が供された順序により別々に指定されていたかのようになる。
例えば：
◎
If a list of &lt;transform-function&gt; is provided, then the net effect is as if each transform function had been specified separately in the order provided. For example,
</p>

<pre>
&lt;div style="transform:
    translate(-10px,-20px)
    scale(2)
    rotate(45deg)
    translate(5px,10px)"/&gt;
</pre>

<p>
は、機能的に次に等価になる：
◎
is functionally equivalent to:
</p>

<pre>&lt;div style="transform:translate(-10px,-20px)"&gt;
  &lt;div style="transform:scale(2)"&gt;
    &lt;div style="transform:rotate(45deg)"&gt;
      &lt;div style="transform:translate(5px,10px)"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>

<p>
すなわち，他の［
位置や寸法に影響する~style付け
］が不在の下では、一連の入子にされた変形は，［
外側から順に適用される変形関数からなる，単独の~list
］に等価になる。
結果の変形は、変形の~listにより与えられる各~行列の積になる。
◎
That is, in the absence of other styling that affects position and dimensions, a nested set of transforms is equivalent to a single list of transform functions, applied from the outside in. The resulting transform is the matrix multiplication of the list of transforms.
</p>

<p>
変形関数が表現する ~objectに対する`現在の変換行列$（ CTM ）が，不可逆である場合、その~objectやその内容は表示されなくなる。
◎
If a transform function causes the current transformation matrix (CTM) of an object to be non-invertible, the object and its content do not get displayed.
</p>

<div class="example">


<p>
次の例における~objectは， 0 倍に拡縮される：
◎
The object in the following example gets scaled by 0.
</p>

<pre>
&lt;style&gt;
.box {
transform: scale(0);
}
&lt;/style&gt;

&lt;div class="box"&gt;
Not visible
&lt;/div&gt;</pre>


<p>
この拡縮ingは、`div^code ~boxの座標空間に対する`現在の変換行列$を不可逆にする。
したがって、 `div^code ~boxもその中の~textも表示されない。
◎
The scaling causes a non-invertible CTM for the coordinate space of the div box. Therefore neither the div box, nor the text in it get displayed.
</p>
</div>


	</section>
	<section id="interpolation-of-transforms">
<h2 title="Interpolation of Transforms">18. 変形~間の補間</h2>

<p>
変形を~animate／遷移させている間、変形関数の~listが補間され~MUST。
変形の 2 つの状態， %from と %to の補間においては、以下に述べる規則が適用される。
◎
When animating or transitioning transforms, the transform function lists must be interpolated. For interpolation between one transform from-transform and a second transforms to-transform, the rules described below are applied.
</p>

<dl>
	<dt id="none-none-animation">
%from, %to いずれも `none^v の場合
◎
If both the from- and to-transform are none:
</dt>

	<dd><p>
補間は不要であり、算出値は `none^v のままになる。
◎
There is no interpolation necessary. The computed value stays none.
</p></dd>

	<dt id="none-transform-animation">
%from, %to の片方のみが `none^v の場合
◎
If one of the from- or to-transforms is none.
</dt>
	<dd><p>
その `none^v 値を，もう片方の変形関数の~listに呼応するような，`恒等~変形関数$の~listに置換した上で、次項の規則に従って，両者の変形関数~listを補間する。
◎
The value none is replaced by an equivalent identity transform function list for the corresponding transform function list. Both transform function lists get interpolated following the next rule.
</p>

<div class="example">
<p>
例えば， %from が `scale(2)^v で %to が `none^v の場合、~animationは，後者が `scale(1)^v に置換された上で 続行されることになる 。
同様に、 %from が `none^v で %to が `scale(2) rotate(50deg)^v の場合、~animationは，前者が `scale(1) rotate(0)^v であったかのように 実行されることになる。
◎
For example, if from-transform is scale(2) and to-transform is none then the value scale(1) will be used for to-transform and animation will proceed using the next rule. Similarly, if from-transform is none and to-transform is scale(2) rotate(50deg) then the animation will execute as if from-transform is scale(1) rotate(0).
</p>
</div>

	</dd>

	<dt id="transform-transform-animation">
［
%from と %to が同じ個数の変形関数からなる
］, かつ［
対応する変形関数の対が［
同じ名前を持つ, または
同じ `原始関数$
からの派生である
］］場合：
◎
If from- and to-transform have the same number of transform functions, each transform function pair has either the same name, or is a derivative of the same primitive.
</dt>
		<dd><p>
`変形関数の補間$にて述べられるように、各~変形関数の対を補間する。
その結果の変形関数の~listが，算出値になる。
◎
Interpolate each transform function pair as described in Interpolation of transform functions. The computed value is the resulting transform function list.
</p>

<div class="example">
<p>
例えば， %from が `scale(1) translate(0)^v で %to が `translate(100px) scale(2)^v の場合、 `scale(1)^v と `translate(100px)^v （あるいは `translate(0)^v と `scale(2)^v ）は，共通の`原始関数$から派生しないので、この規則による補間は 行われ得ない。
◎
For example, if from-transform is scale(1) translate(0) and to-transform is translate(100px) scale(2) then scale(1) and translate(100px) as well as translate(0) and scale(2) don’t share a common primitive and therefore can not get interpolated following this rule.
</p>
</div>
	</dd>

	<dt id="other-animation">
他の場合：
◎
In all other cases:
</dt>
	<dd><p>
%from, %to のそれぞれに対し，その変形関数~listの各~変形関数による後置積をとって 4x4 行列に換算する。
それぞれの行列は、`行列の補間$による指示に従って，補間される。
算出値は、両者の初期時の行列とも 3x2 行列で表現し得る場合は 変形関数 `matrix$f になり、他の場合は `matrix3d$f になる。
◎
The transform functions of each transform function list on the from- and to-transform get post multiplied and converted into 4x4 matrices. Each of the matrices gets interpolated following the instructions in Interpolation of matrices. The computed value is the transform function matrix if both initial matrices can be represented by a correlating 3x2 matrix and matrix3d otherwise.
</p></dd>

</dl>


<p>
一部の~animationにおいては，変換行列が特異的 — 言い換えれば不可逆になる。
例えば，拡縮率が 1 から −1 へ変動する~animationなど。
行列がその種の状態に陥った時点では、`変形要素$は描画されない。
◎
In some cases, an animation might cause a transformation matrix to be singular or non-invertible. For example, an animation in which scale moves from 1 to -1. At the time when the matrix is in such a state, the transformed element is not rendered.
</p>

	</section>
	<section id="transform-primitives">
<h2 title="Transform function primitives and derivatives">19. 原始関数とその派生</h2>

<p>
一部の変形関数は、より汎的な変形関数の特殊な場合として表現し得る。
後者は
<dfn >~~原始関数</dfn>（ generic transform functions primitive, または単に primitive ），前者はその
<dfn >~~派生関数</dfn>（ derived transform function ）と呼ばれる。
以下に挙げられるものが、~2Dと~3Dにおける原始関数と, その派生関数である。
◎
Some transform functions can be represented by more generic transform functions. These transform functions are called derived transform functions, the generic transform functions primitives. Primitives for two-dimensional and three-dimensional transform functions are listed below.
</p>

<p>
~2Dにおける原始関数と, その派生関数は：
◎
Two-dimensional primitives with derived transform functions are:
</p>

<table>
	<thead><tr><th>原始関数</th><th>派生関数</th></tr></thead>
	<tbody>

<tr><td id="translate-primitive">`translate$f
</td><td>
`translateX$f, `translateY$f, `translate$f
◎
for translateX(), translateY() and translate().
</td></tr>

<tr><td id="rotate-three-primitive"><a href="#rotate-three-function">3 引数をとる `rotate^f</a>
</td><td>1 個または 3 個の引数を伴う `rotate$f （後者は
<a href="#svg-transform-functions">3 引数をとる回転</a>
が~supportされている場合のみ）
◎
for rotate() with one or three arguments if rotate with three arguments is supported.
</td></tr>

<tr><td id="scale-primitive">`scale$f
</td><td>
`scaleX$f, `scaleY$f, `scale$f
◎
for scaleX(), scaleY() and scale().
</td></tr>
	</tbody>
</table>

<p>
~3Dにおける原始関数と, その派生関数は：
◎
Three-dimensional primitives with derived transform functions are:
</p>

<table>
	<thead><tr><th>原始関数</th><th>派生関数</th></tr></thead>
	<tbody>

<tr><td id="translate3d-primitive">`translate3d$f
</td><td>
`translateX$f,
`translateY$f,
`translateZ$f,
`translate$f
◎
for translateX(), translateY(), translateZ() and translate().
</td></tr>

<tr><td id="scale3d-primitive">`scale3d$f
</td><td>
`scaleX$f,
`scaleY$f,
`scaleZ$f,
`scale$f
◎
for scaleX(), scaleY(), scaleZ() and scale().
</td></tr>

<tr><td id="rotate3d-primitive">`rotate3d$f
</td><td>
`rotate$f,
`rotateX$f,
`rotateY$f,
`rotateZ$f
◎
for rotate(), rotateX(), rotateY() and rotateZ().
</td></tr>

	</tbody>
</table>



<p id="interpolation-two-three-dimensional-function">
~2D原始関数と~3D原始関数の両者から派生し得る変形関数に対し，（次節の`変形関数の補間$にて）利用される原始関数は、文脈から決まる。
◎
For derived transform functions that have a two-dimensional primitive and a three-dimensional primitive, the context decides about the used primitive. See Interpolation of primitives and derived transform functions.
</p>


	</section>
	<section id="interpolation-of-transform-functions">
<h2 title="Interpolation of primitives and derived transform functions">20. 原始関数と派生関数の補間</h2>

<p>
同じ名前の 同じ個数の引数を伴う ２つの変形関数は、前節による換算を要することなく，数値的に補間し得る。
その計算結果の値は、同じ個数の引数を伴う同じ型の変形関数になる。
`rotate3d$f,
`matrix$f,
`matrix3d$f,
`perspective$f
については、特別な規則が適用される：
◎
Two transform functions with the same name and the same number of arguments are interpolated numerically without a former conversion. The calculated value will be of the same transform function type with the same number of arguments. Special rules apply to rotate3d(), matrix(), matrix3d() and perspective().
</p>

<div class="example">

<p>
2 つの変形関数
`translate(0)^v,
`translate(100px)^v
は、同じ型であり, 引数の個数も同じなので，数値的に補間し得る。
`translateX(100px)^v や `translate(100px, 0)^v は，それらとは 型が異なる／引数の個数が異なるので、それらの変形関数と補間するためには，その前に前節による換算を要する。
◎
The two transform functions translate(0) and translate(100px) are of the same type, have the same number of arguments and therefore can get interpolated numerically. translateX(100px) is not of the same type and translate(100px, 0) does not have the same number of arguments, therefore these transform functions can not get interpolated without a former conversion step.
</p>
</div>

<p>
2 つの変形関数は、型が異っていても，同じ原始関数から派生しているならば、補間し得る。
個数の引数が異なる 2 つの変形関数も，型が同じならば補間し得る。
いずれにせよ、両 ~変形関数は，最初に前節による共通の原始関数への換算を要し、しかる後，数値的に補間される。
算出値は、補間した結果の引数を伴う原始関数になる。
◎
Two different types of transform functions that share the same primitive, or transform functions of the same type with different number of arguments can be interpolated. Both transform functions need a former conversion to the common primitive first and get interpolated numerically afterwards. The computed value will be the primitive with the resulting interpolated arguments.
</p>

<div class="example">


<p>
次の例は、`div^code ~box上で~hoverされている間， 3 秒間かけて
`translateX(100px)^v から `translateY(100px)^v
へ遷移させる。
いずれの変形関数も，同じ原始関数 `translate$f から派生するので、補間が可能になる。
◎
The following example describes a transition from translateX(100px) to translateY(100px) in 3 seconds on hovering over the div box. Both transform functions derive from the same primitive translate() and therefore can be interpolated.
</p>

<pre>
div {
  transform: translateX(100px);
}

div:hover {
  transform: translateY(100px);
  transition: transform 3s;
}</pre>


<p>
遷移が生じたとき、両~変形関数は，共通の原始関数に変形される。
`translateX(100px)^v は `translate(100px, 0)^v に換算され、
`translateY(100px)^v は `translate(0, 100px)^v に換算される。
しかる後、両~変形関数は，数値的に補間し得るようになる。
◎
For the time of the transition both transform functions get transformed to the common primitive. translateX(100px) gets converted to translate(100px, 0) and translateY(100px) gets converted to translate(0, 100px). Both transform functions can then get interpolated numerically.
</p>
</div>

<p>
両~変形関数が，~2Dの原始関数を共有する場合、それらは~2D原始関数に換算される。
少なくとも一方が~3Dの~変形関数であるときは、共通の~3D原始関数が利用される。
◎
If both transform functions share a primitive in the two-dimensional space, both transform functions get converted to the two-dimensional primitive. If one or both transform functions are three-dimensional transform functions, the common three-dimensional primitive is used.
</p>

<div class="example">


<p>
この例では、~2D~変形関数が~3D~変形関数にされた上で，~animateされる。
共通の原始関数は `translate3d$f になる。
◎
In this example a two-dimensional transform function gets animated to a three-dimensional transform function. The common primitive is translate3d().
</p>

<pre>
div {
  transform: translateX(100px);
}

div:hover {
  transform: translateZ(100px);
  transition: transform 3s;
}</pre>


<p>
最初の
`translateX(100px)^v
は
`translate3d(100px, 0, 0)^v
に換算され、
`translateZ(100px)^v
は
`translate3d(0, 0, 100px)^v
に換算される。
換算された両~変形関数は，数値的に補間される。
◎
First translateX(100px) gets converted to translate3d(100px, 0, 0) and translateZ(100px) to translate3d(0, 0, 100px) respectively. Then both converted transform functions get interpolated numerically.
</p>
</div>

<p>
変形関数
`matrix$f ／ `matrix3d$f ／ `perspective$f
は、最初に 4x4 行列に換算された上で，`行列の補間$ 節の定義に従って補間される。
◎
The transform functions matrix(), matrix3d() and perspective() get converted into 4x4 matrices first and interpolated as defined in section Interpolation of Matrices afterwards.
</p>

<p>
原始関数 `rotate3d$f の補間のためには、最初に変形関数の方向~vectorが正規化される。
正規化された~vectorが等しい場合、回転~角度が数値的に補間される。
他の場合、変形関数は，まず 4x4 行列に換算された上で、`行列の補間$ 節の定義に従って補間される。
◎
For interpolations with the primitive rotate3d(), the direction vectors of the transform functions get normalized first. If the normalized vectors are equal, the rotation angle gets interpolated numerically. Otherwise the transform functions get converted into 4x4 matrices first and interpolated as defined in section Interpolation of Matrices afterwards.
</p>

	</section>
	<section id="matrix-interpolation">
<h2 title="Interpolation of Matrices">21. 二つの行列の補間</h2>


<p>
2 つの行列の合間を補間するためには、まず，それぞれの行列を 対応している並進, 回転, 拡縮, 斜傾
— `~3D行列$の場合は，それに加えて遠近法の成分
— に分解する。
しかる後、この分解された 2 つの［
一連の行列
］の間で、互いに対応する行列を，数値的に補間する。
最後に、その結果の一連の行列を，一つの行列に再合成する。
◎
When interpolating between two matrices, each matrix is decomposed into the corresponding translation, rotation, scale, skew and (for a 3D matrix) perspective values. Each corresponding component of the decomposed matrices gets interpolated numerically and recomposed back to a matrix in a final step.
</p>

<div class="example">

<p>
次の例では、~hoverされている間に，要素を
X, Y 両方向に 100 画素~並進させた上で, 1170° 回転させる。
初期時の変換は 45° の回転にされていて，遷移を利用して~animateされる。
作者は、時計回りに, 3 ＋四半周（ 1170° ）回転するものと期待するかもしれないが…
◎
In the following example the element gets translated by 100 pixel in both the X and Y directions and rotated by 1170° on hovering. The initial transformation is 45°. With the usage of transition, an author might expect a animated, clockwise rotation by three and a quarter turns (1170°).
</p>

<pre>
&lt;style&gt;
div {
  transform: rotate(45deg);
}
div:hover {
  transform: translate(100px, 100px) rotate(1215deg);
  transition: transform 3s;
}
&lt;/style&gt;

&lt;div&gt;&lt;/div&gt;</pre>


<p>
［
始値~変形:
`rotate(45deg)^v
］に含まれる変形関数の個数は，［
終値~変形:
`translate(100px, 100px) rotate(1125deg)^v
］に含まれる変形関数の個数と異なるので、`変形の補間$の最後の規則に従って，両~変形とも 行列~補間により補間され~MUST。
その結果、変換~関数から行列への換算の際に， 3 周分（ 1080° ）についての情報は失われ、要素は四半周（ 90° ）だけ回転される。
◎
The number of transform functions on the source transform rotate(45deg) differs from the number of transform functions on the destination transform translate(100px, 100px) rotate(1125deg). According to the last rule of Interpolation of Transforms, both transforms must be interpolated by matrix interpolation. With converting the transformation functions to matrices, the information about the three turns gets lost and the element gets rotated by just a quarter turn (90°).
</p>

<p>
上の例で 3 ＋四半周を得るためには、［
始値~変形と終値~変形
］が［
`変形の補間$の 3 番目の規則
］を満たすように、始値~変形を，次の様な形にする必要がある：
`translate(0, 0) rotate(45deg)^v
。
◎
To achieve the three and a quarter turns for the example above, source and destination transforms must fulfill the third rule of Interpolation of Transforms. Source transform could look like translate(0, 0) rotate(45deg) for a linear interpolation of the transform functions.
</p>
</div>

<p>
以下の各節では、
<a href="#interpolation-of-2d-matrices">2 つの~2D行列の補間</a>
と，少なくとも片方は`~2D行列$でないような
<a href="#interpolation-of-3d-matrices">2 つの行列の補間</a>
を別々に扱う。
◎
In the following we differ between the interpolation of two 2D matrices and the interpolation of two matrices where at least one matrix is not a 2D matrix.
</p>

<p>
補間~対象のいずれかの行列が不可逆である場合、利用される~animation関数は、当該の~animation仕様の規則に従って，離散的~animationに~fall-backし~MUST。
◎
If one of the matrices for interpolation is non-invertible, the used animation function must fall-back to a discrete animation according to the rules of the respective animation specification.
</p>

		<section id="supporting-functions">
<h3 title="Supporting functions">21.1. 補助関数</h3>

<p>
以下の節における擬似codeでは、次の補助関数が利用される：
◎
The pseudo code in the next subsections make use of the following supporting functions:
</p>

<div>

<p>
値~型［
double, point, matrix, vector
］は，順に［
~scalar,
3 成分~vector,
4x4 行列,
4 成分~vector
］を表す。
◎
Supporting functions (point is a 3 component vector, matrix is a 4x4 matrix, vector is a 4 component vector):
</p>

<table><tbody id="supporting-functions-table">

<tr><td>double determinant(matrix)
</td><td>行列式
</td></tr>
<tr><td>matrix inverse(matrix)
</td><td>逆行列
</td></tr>
<tr><td>matrix transpose(matrix)
</td><td>転置行列
</td></tr>
<tr><td>matrix multiply(matrix, matrix)
</td><td>行列の積
</td></tr>
<tr><td>point multVecMatrix(point, matrix)
</td><td>~vectorに対し行列による積をとる（写像する）。
</td></tr>
<tr><td>double length(point)
</td><td>~vectorの~~長さ
</td></tr>
<tr><td>point normalize(point)
</td><td>~vectorを~~長さ 1 に正規化
</td></tr>
<tr><td>double dot(point, point)
</td><td>2 ~vectorの点乗積
</td></tr>
<tr><td>double sqrt(double)
</td><td>~scalarの二乗根
</td></tr>
<tr><td>double max(double, double)
</td><td>2 ~scalarの最大値
</td></tr>
<tr><td>double dot(vector, vector)
</td><td>2 ~vectorの点乗積
</td></tr>
<tr><td>vector multVector(vector, vector)
</td><td>2 ~vectorの積【利用されていない】
</td></tr>
<tr><td>double cos(double)
</td><td>余弦
</td></tr>
<tr><td>double sin(double)
</td><td>正弦
</td></tr>
<tr><td>double acos(double)
</td><td>逆余弦
</td></tr>
<tr><td>double abs(double)
</td><td>絶対値
</td></tr>
<tr><td>double rad2deg(double)
</td><td>~radianを度数に換算する
</td></tr>
<tr><td>double deg2rad(double)
</td><td>度数を~radianに換算する
</td></tr>

<tr><td>point combine(point, point, double, double)
</td><td>下を参照（ ~3D行列~分解にて利用される）
</td></tr>

</tbody></table>

<pre>
point combine(point %a, point %b, double %ascl, double %bscl)
   %result[0] = (%ascl * %a[0]) + (%bscl * %b[0])
   %result[1] = (%ascl * %a[1]) + (%bscl * %b[1])
   %result[2] = (%ascl * %a[2]) + (%bscl * %b[2])
   return %result
</pre>

<pre lang="en">
Supporting functions (point is a 3 component vector, matrix is a 4x4 matrix, vector is a 4 component vector):
  double  determinant(matrix)          returns the 4x4 determinant of the matrix
  matrix  inverse(matrix)              returns the inverse of the passed matrix
  matrix  transpose(matrix)            returns the transpose of the passed matrix
  point   multVecMatrix(point, matrix) multiplies the passed point by the passed matrix
                                       and returns the transformed point
  double  length(point)                returns the length of the passed vector
  point   normalize(point)             normalizes the length of the passed point to 1
  double  dot(point, point)            returns the dot product of the passed points
  double  sqrt(double)                 returns the root square of passed value
  double  max(double y, double x)      returns the bigger value of the two passed values
  double  dot(vector, vector)         returns the dot product of the passed vectors
  vector  multVector(vector, vector)  multiplies the passed vectors
  double  sqrt(double)                returns the root square of passed value
  double  max(double y, double x)     returns the bigger value of the two passed values
  double  min(double y, double x)     returns the smaller value of the two passed values
  double  cos(double)                 returns the cosines of passed value
  double  sin(double)                 returns the sine of passed value  
  double  acos(double)                returns the inverse cosine of passed value
  double  abs(double)                  returns the absolute value of the passed value
  double  rad2deg(double)              transforms a value in radian to degree and returns it
  double  deg2rad(double)              transforms a value in degree to radian and returns it

Decomposition also makes use of the following function:
  point combine(point a, point b, double ascl, double bscl)
      result[0] = (ascl * a[0]) + (bscl * b[0])
      result[1] = (ascl * a[1]) + (bscl * b[1])
      result[2] = (ascl * a[2]) + (bscl * b[2])
      return result
</pre>

</div>


		</section>
		<section id="interpolation-of-2d-matrices">
<h3 title="Interpolation of 2D matrices">21.2. 二つの~2D行列の補間</h3>

			<section id="decomposing-a-2d-matrix">
<h4 title="Decomposing a 2D matrix">21.2.1. ~2D行列の分解法</h4>

<p>
以下の擬似codeは
“Graphics Gems II, edited by Jim Arvo”
による “unmatrix” 手法に基づく：
◎
The pseudo code below is based upon the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo".
</p>

<pre>
入力:
   %matrix      ; 4x4 行列
出力:
   %translation ; 2 成分~vector
   %scale       ; 2 成分~vector
   %angle       ; 回転
   %m11, %m12, %m21, %m22   ; 2x2 行列の各~成分

`行列の分解が［ 可能なら true ／ 不可なら false ］を返す。^cmt

double %row0x = %matrix[0][0]
double %row0y = %matrix[0][1]
double %row1x = %matrix[1][0]
double %row1y = %matrix[1][1]

%translation[0] = %matrix[3][0]
%translation[1] = %matrix[3][1]

%scale[0] = sqrt(%row0x * %row0x + %row0y * %row0y)
%scale[1] = sqrt(%row1x * %row1x + %row1y * %row1y)

`行列式が負の場合は，一方の軸を反転する^cmt
double %determinant = %row0x * %row1y - %row0y * %row1x
if (%determinant &lt; 0) {
    `小さい方の単位~vector点乗積により，軸を反転^cmt
    if (%row0x &lt; %row1y) {
        %scale[0] = -%scale[0]
    } else {
        %scale[1] = -%scale[1]
    }
}
`行列から拡縮~分を除去して正規化^cmt
if (%scale[0]) {
    %row0x *= 1 / %scale[0]
    %row0y *= 1 / %scale[0]
}
if (%scale[1]) {
    %row1x *= 1 / %scale[1]
    %row1y *= 1 / %scale[1]
}
`回転を算出して行列を再度~正規化^cmt
%angle = atan2(%row0y, %row0x); 

if (%angle) {
    // -%angle 回転    = [cos(%angle), sin(%angle), -sin(%angle), cos(%angle)]
    //                = [%row0x, -%row0y, %row0y, %row0x]
    // Thanks to the normalization above.
    double %sn = -%row0y
    double %cs = %row0x
    double %m11 = %row0x
    double %m12 = %row0y
    double %m21 = %row1x
    double %m22 = %row1y
    %row0x = %cs * %m11 + %sn * %m21
    %row0y = %cs * %m12 + %sn * %m22
    %row1x = -%sn * %m11 + %cs * %m21
    %row1y = -%sn * %m12 + %cs * %m22
}
<!-- 
 c s 11 12
-s d 21 22
 -->
%m11 = %row0x
%m12 = %row0y
%m21 = %row1x
%m22 = %row1y

`回転~関数のために度数に換算する^cmt
%angle = rad2deg(%angle)

return true
</pre>
<!-- 
Input:  matrix      ; a 4x4 matrix
Output: translation ; a 2 component vector
        scale       ; a 2 component vector
        angle       ; rotation
        m11         ; 1,1 coordinate of 2x2 matrix
        m12         ; 1,2 coordinate of 2x2 matrix
        m21         ; 2,1 coordinate of 2x2 matrix
        m22         ; 2,2 coordinate of 2x2 matrix
Returns false if the matrix cannot be decomposed, true if it can


double row0x = matrix[0][0]
double row0y = matrix[0][1]
double row1x = matrix[1][0]
double row1y = matrix[1][1]

translate[0] = matrix[3][0]
translate[1] = matrix[3][1]

scale[0] = sqrt(row0x * row0x + row0y * row0y)
scale[1] = sqrt(row1x * row1x + row1y * row1y)

// If determinant is negative, one axis was flipped.
double determinant = row0x * row1y - row0y * row1x
if (determinant &lt; 0)
    // Flip axis with minimum unit vector dot product.
    if (row0x &lt; row1y)
        scale[0] = -scale[0]
    else
        scale[1] = -scale[1]

// Renormalize matrix to remove scale. 
if (scale[0])
    row0x *= 1 / scale[0]
    row0y *= 1 / scale[0]
if (scale[1]) 
    row1x *= 1 / scale[1]
    row1y *= 1 / scale[1]

// Compute rotation and renormalize matrix. 
angle = atan2(row0y, row0x); 

if (angle)
    // Rotate(-angle) = [cos(angle), sin(angle), -sin(angle), cos(angle)]
    //                = [row0x, -row0y, row0y, row0x]
    // Thanks to the normalization above.
    double sn = -row0y
    double cs = row0x
    double m11 = row0x
    double m12 = row0y
    double m21 = row1x
    double m22 = row1y
    row0x = cs * m11 + sn * m21
    row0y = cs * m12 + sn * m22
    row1x = -sn * m11 + cs * m21
    row1y = -sn * m12 + cs * m22

m11 = row0x
m12 = row0y
m21 = row1x
m22 = row1y

// Convert into degrees because our rotation functions expect it.
angle = rad2deg(angle)

return true
 -->

			</section>
			<section id="interpolation-of-decomposed-2d-matrix-values">
<h4 title="Interpolation of decomposed 2D matrix values">21.2.2. 二つの［ 分解された~2D行列~値 ］の補間</h4>

<p>
2 個の 分解された~2D行列~値を補間する前に，次を行う：
◎
Before two decomposed 2D matrix values can be interpolated, the following
</p>

<pre>
入力:
   %translationA ; 2 成分~vector
   %scaleA       ; 2 成分~vector
   %angleA       ; 回転
   %mA11, %mA12, %mA21, %mA22   ; 2x2 行列の各~成分

   %translationB ; 2 成分~vector
   %scaleB       ; 2 成分~vector
   %angleB       ; 回転
   %mB11, %mB12, %mB21, %mB22   ; 2x2 行列の各~成分

`一方の x-軸と他方の y-軸が反転されている場合、回転を反転されていない形に戻す。^cmt

if ((%scaleA[0] &lt; 0 &amp;&amp; %scaleB[1] &lt; 0) || (%scaleA[1] &lt; 0 &amp;&amp; %scaleB[0] &lt; 0))
    %scaleA[0] = -%scaleA[0]
    %scaleA[1] = -%scaleA[1]
    %angleA += %angleA &lt; 0 ? 180 : -180

`回転は弧が短い方を選ぶ^cmt
if (!%angleA)
    %angleA = 360
if (!%angleB)
    %angleB = 360

if (abs(%angleA - %angleB) &gt; 180)
    if (%angleA &gt; %angleB)
        %angleA -= 360
    else 
        %angleB -= 360
</pre>
<!-- 
Input: translationA ; a 2 component vector
       scaleA       ; a 2 component vector
       angleA       ; rotation
       m11A         ; 1,1 coordinate of 2x2 matrix
       m12A         ; 1,2 coordinate of 2x2 matrix
       m21A         ; 2,1 coordinate of 2x2 matrix
       m22A         ; 2,2 coordinate of 2x2 matrix
       translationB ; a 2 component vector
       scaleB       ; a 2 component vector
       angleB       ; rotation
       m11B         ; 1,1 coordinate of 2x2 matrix
       m12B         ; 1,2 coordinate of 2x2 matrix
       m21B         ; 2,1 coordinate of 2x2 matrix
       m22B         ; 2,2 coordinate of 2x2 matrix


// If x-axis of one is flipped, and y-axis of the other,
// convert to an unflipped rotation.
if ((scaleA[0] &lt; 0 &amp;&amp; scaleB[1] &lt; 0) || (scaleA[1] &lt; 0 &amp;&amp; scaleB[0] &lt; 0))
    scaleA[0] = -scaleA[0]
    scaleA[1] = -scaleA[1]
    angleA += angleA &lt; 0 ? 180 : -180

// Don’t rotate the long way around.
if (!angleA)
    angleA = 360
if (!angleB)
    angleB = 360

if (abs(angleA - angleB) &gt; 180)
    if (angleA &gt; angleB)
        angleA -= 360
    else 
        angleB -= 360
-->

<p>
以下、始値~行列を分解して得られた各~成分~値［
並進, 拡縮, 角度, [ `11^m 〜 `22^m ]
］は、対応する終値~行列の各~成分との間で，線型に補間される。
◎
Afterwards, each component of the decomposed values translation, scale, angle, m11 to m22 of the source matrix get linearly interpolated with each corresponding component of the destination matrix.
</p>

			</section>
			<section id="recomposing-to-a-2d-matrix">
<h4 title="Recomposing to a 2D matrix">21.2.3. ~2D行列への再合成法</h4>

<p>
補間~後の結果の値が，要素の利用空間を変形するときに利用される。
これらの値は 4x4 行列に再合成するために利用される。
これは、次の擬似codeにより行える：
◎
After interpolation, the resulting values are used to transform the elements user space. One way to use these values is to recompose them into a 4x4 matrix. This can be done following the pseudo code below:
</p>

<pre>
入力:
   %translation ; 2 成分~vector
   %scale       ; 2 成分~vector
   %angle       ; 回転
   %m11, %m12, %m21, %m22   ; 2x2 行列の各~成分
出力:
   %matrix      ; 単位行列に初期化された 4x4 行列


%matrix[0][0] = %m11
%matrix[0][1] = %m12
%matrix[1][0] = %m21
%matrix[1][1] = %m22

`並進~行列^cmt
%matrix[3][0] = %translation[0] * %m11 + %translation[1] * %m21
%matrix[3][1] = %translation[0] * %m12 + %translation[1] * %m22

`回転~行列^cmt
%angle = deg2rad(%angle);
double %cosAngle = cos(%angle);
double %sinAngle = sin(%angle);

`単位行列に初期化された， 4x4 行列による新たな一時変数 rotateMatrix^cmt
%rotateMatrix[0][0] = %cosAngle
%rotateMatrix[0][1] = %sinAngle
%rotateMatrix[1][0] = -%sinAngle
%rotateMatrix[1][1] = %cosAngle

%matrix = multiply(%matrix, %rotateMatrix)

`matrix を拡縮^cmt
%matrix[0][0] *= %scale[0]
%matrix[0][1] *= %scale[0]
%matrix[1][0] *= %scale[1]
%matrix[1][1] *= %scale[1]
</pre>

<!-- 
Input:  translation ; a 2 component vector
        scale       ; a 2 component vector
        angle       ; rotation
        m11         ; 1,1 coordinate of 2x2 matrix
        m12         ; 1,2 coordinate of 2x2 matrix
        m21         ; 2,1 coordinate of 2x2 matrix
        m22         ; 2,2 coordinate of 2x2 matrix
Output: matrix      ; a 4x4 matrix initialized to identity matrix


matrix[0][0] = m11
matrix[0][1] = m12
matrix[1][0] = m21
matrix[1][1] = m22

// Translate matrix.
matrix[3][0] = translate[0] * m11 + translate[1] * m21
matrix[3][1] = translate[0] * m12 + translate[1] * m22

// Rotate matrix.
angle = deg2rad(angle);
double cosAngle = cos(angle);
double sinAngle = sin(angle);

// New temporary, identity initialized, 4x4 matrix rotateMatrix
rotateMatrix[0][0] = cosAngle
rotateMatrix[0][1] = sinAngle
rotateMatrix[1][0] = -sinAngle
rotateMatrix[1][1] = cosAngle

matrix = multiply(matrix, rotateMatrix)

// Scale matrix.
matrix[0][0] *= scale[0]
matrix[0][1] *= scale[0]
matrix[1][0] *= scale[1]
matrix[1][1] *= scale[1]

 -->

			</section>
		</section>
		<section id="interpolation-of-3d-matrices">
<h3 title="Interpolation of 3D matrices">21.3. 二つの~3D行列の補間</h3>



			<section id="decomposing-a-3d-matrix">
<h4 title="Decomposing a 3D matrix">21.3.1. ~3D行列の分解法</h4>

<p>
下の擬似codeは
“Graphics Gems II, edited by Jim Arvo”
による “unmatrix” 手法に基づくが、`ジンバルロック$（ Gimbal Locks ）の問題を避けるため、`オイラー角$（ Euler angle ）の代わりに`四元数$（ Quaternions ）を利用するように修正を加えている。
◎
The pseudo code below is based upon the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo", but modified to use Quaternions instead of Euler angles to avoid the problem of Gimbal Locks.
</p>

<p>
次の擬似codeは 4x4 斉次~行列に対して働く：
<!-- 
homogeneous transformation matrix
斉次~行列
同次変換行列
 -->
◎
The following pseudocode works on a 4x4 homogeneous matrix:
</p>

<pre>
入力:
   %matrix      ; 4x4 行列
出力:
   %translation ; 3 成分~vectorで表現される並進~成分
   %scale       ; 3 成分~vectorで表現される拡縮~成分
   %skew        ; 3 成分~vectorで表現される XY, XZ, YZ 斜傾~成分
   %perspective ; 4 成分~vectorで表現される遠近法~成分
   %quaternion  ; 4 成分~vectorで表現される四元数による 回転~成分

返り値:
   行列が分解し得るなら true, し得ないなら false


`行列を正規化^cmt
    double %m33 = %matrix[3][3]
if (%m33 == 0)
    return false

for (%i = 0; %i &lt; 4; %i++)
    for (%j = 0; %j &lt; 4; %j++)
        %matrix[%i][%j] /= %m33


`perspective を解くためには perspectiveMatrix が用いられるが，それは upper 3x3 成分の特異性を簡単にテストする方法も与える^cmt

%PM = %matrix; `透視行列, 複製^cmt

%PM[0][3] = %PM[1][3] = %PM[2][3] = 0
%PM[3][3] = 1

if (determinant(%PM) == 0)
    return false

`最初に, 遠近法を分離^cmt
if (%matrix[0][3] != 0 || %matrix[1][3] != 0 || %matrix[2][3] != 0)
    `rightHandSide は等式の右辺^cmt
    %rightHandSide[0] = %matrix[0][3]
    %rightHandSide[1] = %matrix[1][3]
    %rightHandSide[2] = %matrix[2][3]
    %rightHandSide[3] = %matrix[3][3]

    `PM の逆行列をとって，それに rightHandSide に対し積をとることにより，等式を解く^cmt
    %perspective = multVecMatrix(%rightHandSide, transposeMatrix4(inverse(%PM)))
else
    `遠近法なし^cmt
    %perspective[0] = %perspective[1] = %perspective[2] = 0
    %perspective[3] = 1

`次に並進を得る^cmt
for (%i = 0; %i &lt; 3; %i++)
    %translation[%i] = %matrix[3][%i]

`次は拡縮と斜傾率を得る。 'row' は 3 個の 3 成分~vectorからなる配列^cmt
for (%i = 0; %i &lt; 3; %i++)
    row[%i][0] = matrix[%i][0]
    row[%i][1] = matrix[%i][1]
    row[%i][2] = matrix[%i][2]

`X 拡縮率を算出して最初の row を正規化^cmt
%scale[0] = length(%row[0])
%row[0] = normalize(%row[0])

`XY 斜傾率を算出して 2 番目の row を最初の row に直交させる^cmt
%skew[0] = dot(%row[0], %row[1])
%row[1] = combine(%row[1], %row[0], 1.0, -%skew[0])

`Y 拡縮率を算出した上で 2 番目の row を正規化^cmt
%scale[1] = length(%row[1])
%row[1] = normalize(%row[1])
%skew[0] /= %scale[1];

`XZ, YZ の斜傾率を算出して， 3 番目の row を直交させる^cmt
%skew[1] = dot(%row[0], %row[2])
%row[2] = combine(%row[2], %row[0], 1.0, -%skew[1])
%skew[2] = dot(%row[1], %row[2])
%row[2] = combine(%row[2], %row[1], 1.0, -%skew[2])

`Z 拡縮率を得て, 3 番目の row を正規化^cmt
%scale[2] = length(%row[2])
%row[2] = normalize(%row[2])
%skew[1] /= %scale[2]
%skew[2] /= %scale[2]

`この時点で, 行列は直交（各~行~vectorが互いに直交する単位~vector）。座標系が反転されているかどうかを検査する。 行列式が −1 なら 行列と拡縮率を −1 倍する^cmt
%pdum3 = cross(%row[1], %row[2])
if (dot(%row[0], %pdum3) &lt; 0)
    for (%i = 0; %i &lt; 3; %i++)
        %scale[%i] *= -1;
        %row[%i][0] *= -1
        %row[%i][1] *= -1
        %row[%i][2] *= -1

`回転を抽出^cmt
%quaternion[0] = 0.5 * sqrt(max(1 + %row[0][0] - %row[1][1] - %row[2][2], 0))
%quaternion[1] = 0.5 * sqrt(max(1 - %row[0][0] + %row[1][1] - %row[2][2], 0))
%quaternion[2] = 0.5 * sqrt(max(1 - %row[0][0] - %row[1][1] + %row[2][2], 0))
%quaternion[3] = 0.5 * sqrt(max(1 + %row[0][0] + %row[1][1] + %row[2][2], 0))

if (%row[2][1] &gt; %row[1][2])
    %quaternion[0] = -%quaternion[0]
if (%row[0][2] &gt; %row[2][0])
    %quaternion[1] = -%quaternion[1]
if (%row[1][0] &gt; %row[0][1])
    %quaternion[2] = -%quaternion[2]

return true
</pre>

<!-- 

Input:  matrix      ; a 4x4 matrix
Output: translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Returns false if the matrix cannot be decomposed, true if it can


// Normalize the matrix.
if (matrix[3][3] == 0)
    return false

for (i = 0; i &lt; 4; i++)
    for (j = 0; j &lt; 4; j++)
        matrix[i][j] /= matrix[3][3]

// perspectiveMatrix is used to solve for perspective, but it also provides
// an easy way to test for singularity of the upper 3x3 component.
perspectiveMatrix = matrix

for (i = 0; i &lt; 3; i++)
    perspectiveMatrix[i][3] = 0

perspectiveMatrix[3][3] = 1

if (determinant(perspectiveMatrix) == 0)
    return false

// First, isolate perspective.
if (matrix[0][3] != 0 || matrix[1][3] != 0 || matrix[2][3] != 0)
    // rightHandSide is the right hand side of the equation.
    rightHandSide[0] = matrix[0][3]
    rightHandSide[1] = matrix[1][3]
    rightHandSide[2] = matrix[2][3]
    rightHandSide[3] = matrix[3][3]

    // Solve the equation by inverting perspectiveMatrix and multiplying
    // rightHandSide by the inverse.
    inversePerspectiveMatrix = inverse(perspectiveMatrix)
    transposedInversePerspectiveMatrix = transposeMatrix4(inversePerspectiveMatrix)
    perspective = multVecMatrix(rightHandSide, transposedInversePerspectiveMatrix)
else
    // No perspective.
    perspective[0] = perspective[1] = perspective[2] = 0
    perspective[3] = 1

// Next take care of translation
for (i = 0; i &lt; 3; i++)
    translate[i] = matrix[3][i]

// Now get scale and shear. 'row' is a 3 element array of 3 component vectors
for (i = 0; i &lt; 3; i++)
    row[i][0] = matrix[i][0]
    row[i][1] = matrix[i][1]
    row[i][2] = matrix[i][2]

// Compute X scale factor and normalize first row.
scale[0] = length(row[0])
row[0] = normalize(row[0])

// Compute XY shear factor and make 2nd row orthogonal to 1st.
skew[0] = dot(row[0], row[1])
row[1] = combine(row[1], row[0], 1.0, -skew[0])

// Now, compute Y scale and normalize 2nd row.
scale[1] = length(row[1])
row[1] = normalize(row[1])
skew[0] /= scale[1];

// Compute XZ and YZ shears, orthogonalize 3rd row
skew[1] = dot(row[0], row[2])
row[2] = combine(row[2], row[0], 1.0, -skew[1])
skew[2] = dot(row[1], row[2])
row[2] = combine(row[2], row[1], 1.0, -skew[2])

// Next, get Z scale and normalize 3rd row.
scale[2] = length(row[2])
row[2] = normalize(row[2])
skew[1] /= scale[2]
skew[2] /= scale[2]

// At this point, the matrix (in rows) is orthonormal.
// Check for a coordinate system flip.  If the determinant
// is -1, then negate the matrix and the scaling factors.
pdum3 = cross(row[1], row[2])
if (dot(row[0], pdum3) &lt; 0)
    for (i = 0; i &lt; 3; i++)
        scale[i] *= -1;
        row[i][0] *= -1
        row[i][1] *= -1
        row[i][2] *= -1

// Now, get the rotations out
quaternion[0] = 0.5 * sqrt(max(1 + row[0][0] - row[1][1] - row[2][2], 0))
quaternion[1] = 0.5 * sqrt(max(1 - row[0][0] + row[1][1] - row[2][2], 0))
quaternion[2] = 0.5 * sqrt(max(1 - row[0][0] - row[1][1] + row[2][2], 0))
quaternion[3] = 0.5 * sqrt(max(1 + row[0][0] + row[1][1] + row[2][2], 0))

if (row[2][1] &gt; row[1][2])
    quaternion[0] = -quaternion[0]
if (row[0][2] &gt; row[2][0])
    quaternion[1] = -quaternion[1]
if (row[1][0] &gt; row[0][1])
    quaternion[2] = -quaternion[2]

return true
 -->

			</section>
			<section id="interpolation-of-decomposed-3d-matrix-values">
<h4 title="Interpolation of decomposed 3D matrix values">21.3.2. 二つの［ 分解された~3D行列~値 ］の補間</h4>

<p>
始値~行列を分解して得られた各~成分~値［
並進, 拡縮, 斜傾, 遠近法
］は、対応する 終値~行列の各~成分との間で，線型に補間される。
◎
Each component of the decomposed values translation, scale, skew and perspective of the source matrix get linearly interpolated with each corresponding component of the destination matrix.
</p>

<p class="note">注記：
例えば、始値~行列の
<code>translate[0]</code>
と終値~行列の
<code>translate[0]</code>
は数値的に補間され，その結果が~animateしている要素の並進を設定するために利用される。
◎
Note: For instance, translate[0] of the source matrix and translate[0] of the destination matrix are interpolated numerically, and the result is used to set the translation of the animating element.
</p>

<p>
分解された始値／終値~行列の四元数は、下の擬似codeにて述べられる球面~線型~補間（ Slerp ）を利用して，補間される。
<!-- 
<a href="http://en.wikipedia.org/wiki/Slerp" >Slerp</a>
-->
◎
Quaternions of the decomposed source matrix are interpolated with quaternions of the decomposed destination matrix using the spherical linear interpolation (Slerp) as described by the pseudo code below:
</p>

<pre>
入力:
   %quaternionA   ; 4 成分~vector
   %quaternionB   ; 4 成分~vector
   %t             ; 補間~parameter, 0 &lt;= %t &lt;= 1
出力:
   %quaternionDst ; 4 成分~vector


%product = dot(%quaternionA, %quaternionB)

`-1.0 &lt;= product &lt;= 1.0 になるように切り詰める^cmt
%product = max(%product, 1.0)
%product = min(%product, -1.0)

if (%product == 1.0)
   %quaternionDst = %quaternionA
   return

%theta = acos(%product)
%w = sin(%t * %theta) * 1 / sqrt(1 - %product * %product)

for (%i = 0; %i &lt; 4; %i++)
  %quaternionA[%i] *= cos(%t * %theta) - %product * %w
  %quaternionB[%i] *= %w
  %quaternionDst[%i] = %quaternionA[%i] + %quaternionB[%i]

</pre>

<!-- 
Input:  quaternionA   ; a 4 component vector
        quaternionB   ; a 4 component vector
        t             ; interpolation parameter with 0 &lt;= t &lt;= 1
Output: quaternionDst ; a 4 component vector


product = dot(quaternionA, quaternionB)

// Clamp product to -1.0 &lt;= product &lt;= 1.0
product = max(product, 1.0)
product = min(product, -1.0)

if (product == 1.0)
   quaternionDst = quaternionA
   return

theta = acos(dot)
w = sin(t * theta) * 1 / sqrt(1 - product * product)

for (i = 0; i &lt; 4; i++)
  quaternionA[i] *= cos(t * theta) - product * w
  quaternionB[i] *= w
  quaternionDst[i] = quaternionA[i] + quaternionB[i]

return
 -->

			</section>
			<section id="recomposing-to-a-3d-matrix">
<h4 title="Recomposing to a 3D matrix">21.3.3. ~3D行列への再合成法</h4>


<p>
補間の結果の値が、要素の利用空間を変形するときに利用される。
これらの値は 4x4 行列に再合成するために利用される。
これは、次の擬似codeにより行える：
◎
After interpolation, the resulting values are used to transform the elements user space. One way to use these values is to recompose them into a 4x4 matrix. This can be done following the pseudo code below:
</p>

<pre>
入力:
   %translation ; 3 成分~vector
   %scale       ; 3 成分~vector
   %skew        ; 3 成分~vectorで表現される斜傾~率 XY,XZ,YZ
   %perspective ; 4 成分~vector
   %quaternion  ; 4 成分~vector
出力:
   %matrix      ; 4x4 行列

`遠近法を適用する^cmt
for (%i = 0; %i &lt; 4; %i++)
   %matrix[%i][3] = %perspective[%i]

`並進を適用する^cmt
for (%i = 0; %i &lt; 3; %i++)
   for (%j = 0; %j &lt; 3; %j++)
      %matrix[3][%i] += %translation[%j] * %matrix[%j][%i]

`回転を適用する^cmt
%x = %quaternion[0]
%y = %quaternion[1]
%z = %quaternion[2]
%w = %quaternion[3]

`四元数による値から複合的な回転~行列を構築する。 rotationMatrix は、初期時は 4x4 単位行列^cmt
%rotationMatrix[0][0] = 1 - 2 * (%y * %y + %z * %z)
%rotationMatrix[0][1] =     2 * (%x * %y - %z * %w)
%rotationMatrix[0][2] =     2 * (%x * %z + %y * %w)
%rotationMatrix[1][0] =     2 * (%x * %y + %z * %w)
%rotationMatrix[1][1] = 1 - 2 * (%x * %x + %z * %z)
%rotationMatrix[1][2] =     2 * (%y * %z - %x * %w)
%rotationMatrix[2][0] =     2 * (%x * %z - %y * %w)
%rotationMatrix[2][1] =     2 * (%y * %z + %x * %w)
%rotationMatrix[2][2] = 1 - 2 * (%x * %x + %y * %y)

%matrix = multiply(%matrix, %rotationMatrix)

`斜傾を適用する。 temp は初期時は 4x4 の単位行列^cmt
if (%skew[2])
    %temp[2][1] = %skew[2]
    %matrix = multiply(%matrix, %temp)

if (%skew[1])
    %temp[2][1] = 0
    %temp[2][0] = %skew[1]
    %matrix = multiply(%matrix, %temp)

if (%skew[0])
    %temp[2][0] = 0
    %temp[1][0] = %skew[0]
    %matrix = multiply(%matrix, %temp)

`拡縮を適用する^cmt
for (%i = 0; %i &lt; 3; %i++)
   for (%j = 0; %j &lt; 3; %j++)
      %matrix[%i][%j] *= %scale[%i]

return
</pre>
<!-- 
Input:  translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Output: matrix      ; a 4x4 matrix

Supporting functions (matrix is a 4x4 matrix):
  matrix  multiply(matrix a, matrix b)   returns the 4x4 matrix product of a * b  

// apply perspective
for (i = 0; i &lt; 4; i++)
  matrix[i][3] = perspective[i]

// apply translation
for (i = 0; i &lt; 3; i++)
  for (j = 0; j &lt; 3; j++)
    matrix[3][i] += translation[j] * matrix[j][i]

// apply rotation
x = quaternion[0]
y = quaternion[1]
z = quaternion[2]
w = quaternion[3]

// Construct a composite rotation matrix from the quaternion values
// rotationMatrix is a identity 4x4 matrix initially
rotationMatrix[0][0] = 1 - 2 * (y * y + z * z)
rotationMatrix[0][1] = 2 * (x * y - z * w)
rotationMatrix[0][2] = 2 * (x * z + y * w)
rotationMatrix[1][0] = 2 * (x * y + z * w)
rotationMatrix[1][1] = 1 - 2 * (x * x + z * z)
rotationMatrix[1][2] = 2 * (y * z - x * w)
rotationMatrix[2][0] = 2 * (x * z - y * w)
rotationMatrix[2][1] = 2 * (y * z + x * w)
rotationMatrix[2][2] = 1 - 2 * (x * x + y * y)

matrix = multiply(matrix, rotationMatrix)

// apply skew
// temp is a identity 4x4 matrix initially
if (skew[2])
    temp[2][1] = skew[2]
    matrix = multiply(matrix, temp)

if (skew[1])
    temp[2][1] = 0
    temp[2][0] = skew[1]
    matrix = multiply(matrix, temp)

if (skew[0])
    temp[2][0] = 0
    temp[1][0] = skew[0]
    matrix = multiply(matrix, temp)

// apply scale
for (i = 0; i &lt; 3; i++)
  for (j = 0; j &lt; 3; j++)
    matrix[i][j] *= scale[i]

return
 -->



			</section>
		</section>
	</section>
	<section id="mathematical-description">
<h2 title="Mathematical Description of Transform Functions">22. ~変形関数の数学的~記述</h2>

<p class="trans-note">【
この仕様における行列は、座標を~~縦~vectorと見なして左から作用し、子の局所座標系から親の局所座標系への変換を与える。
】</p>

<!-- 
function make_matrix(data){
	return (
		'<math xmlns="http://www.w3.org/1998/Math/MathML">'
		+ '<mfenced open="[" close="]"><mtable>'
		+ data.split('／').map(func(row){
			return '<mtr><mtd>' + row.replace(/｜/g, '</mtd><mtd>') + '</mtd></mtr>'
		}).join('')
		+ '</mtable></mfenced></math>'
	);
}

<math xmlns="http://www.w3.org/1998/Math/MathML"
><mfenced open="[" close="]"><mtable>
<mtr><mtd>x</mtd><mtd>y</mtd></mtr>
<mtr><mtd>x</mtd><mtd>y</mtd></mtr>
</mtable></mfenced></math>

 -->


<p>
すべての変形関数は、次のような形の 4x4 変換行列として数学的に表現できる：
◎
Mathematically, all transform functions can be represented as 4x4 transformation matrices of the following form:
</p>

<figure>`4x4matrix^dgm</figure>

<p>
行列~上の並進の 1 単位は、要素の局所座標系の 1 画素に等価になる。
◎
One translation unit on a matrix is equivalent to 1 pixel in the local coordinate system of the element.
</p>

<ul>
	<li>
<p>
6 成分
%a, %b, %c, %d, %e, %f
からなる
`~2D 3x2 行列@
は，次の行列に等価になる：
◎
A 2D 3x2 matrix with six parameters a, b, c, d, e and f is equivalent to the matrix:
</p>

<figure>`matrix^dgm</figure>
	</li>

	<li>
移動量
[ %tx, %ty ]
による
`~2D並進@
は，移動量
[ %tx, %ty, 0 ]
による`~3D並進$に等価。
◎
A 2D translation with the parameters tx and ty is equivalent to a 3D translation where tz has zero as a value.
</li>

	<li>
拡縮率
[ %sx, %sy ]
による
`~2D拡縮@
は，拡縮率
[ %sx, %sy, 1 ]
による`~3D拡縮$に等価。
◎
A 2D scaling with the parameters sx and sy is equivalent to a 3D scale where sz has one as a value.
</li>

	<li>
回転角 %α による
`~2D回転@
は、軸~vector
[ 0, 0, 1 ]
と回転角 %α による`~3D回転$に等価。
◎
A 2D rotation with the parameter alpha is equivalent to a 3D rotation with vector [0,0,1] and parameter alpha.
</li>

	<li id="SkewDefined">
<p>
~parameter
%α, %β による
~2D斜傾~的な変換は、次の行列に等価になる：
◎
A 2D skew like transformation with the parameters alpha and beta is equivalent to the matrix:
</p>

<figure>`skew^dgm</figure>
	</li>

	<li>
<p>
角度 %α による
`X 軸~不変の~2D斜傾@
は、次の行列に等価になる：
◎
A 2D skew transformation along the X axis with the parameter alpha is equivalent to the matrix:
</p>

<figure>`skewX^dgm</figure>
	</li>

	<li>
<p>
角度 %β による
`Y 軸~不変の~2D斜傾@
は、次の行列に等価になる：
◎
A 2D skew transformation along the Y axis with the parameter beta is equivalent to the matrix:
</p>

<figure>`skewY^dgm</figure>
	</li>

	<li>
<p>
移動量
%tx, %ty, %tz
による
`~3D並進@
は、次の行列に等価になる：
◎
A 3D translation with the parameters tx, ty and tz is equivalent to the matrix:
</p>

<figure>`translate3d^dgm</figure>
	</li>

	<li>
<p>
拡縮率
[ %sx, %sy, %sz ]
による
`~3D拡縮@
は、次の行列に等価になる：
◎
A 3D scaling with the parameters sx, sy and sz is equivalent to the matrix:
</p>

<figure>`scale3d^dgm</figure>
	</li>

	<li>
<p>
軸~vector
[ %x, %y, %z ]
と回転角 %α による
`~3D回転@
は、次の行列に等価になる：
◎
A 3D rotation with the vector [x,y,z] and the parameter alpha is equivalent to the matrix:
</p>

<figure>`rotate3dmatrix^dgm</figure>

<p>
ここで：
◎
where:
</p>

<ul>
	<li>
%sc = sin (%α/2) ⋅ cos (%α/2)
</li>
	<li>
%ss = sin (%α/2) ⋅ sin (%α/2)
</li>
</ul>

<!-- 
rotate3dvariables^dgm
-->

	</li>

	<li>
<p>
~parameter %d による
`透視投影行列@
は、次の行列に等価になる：
◎
A perspective projection matrix with the parameter d is equivalent to the matrix:
</p>

<figure>`perspective^dgm</figure>

<!-- 
[ x, y, z, 1 ] → [ x, y, z, 1 − z/d ] 〜 [ x/s, y/s, z/s, 1 ];  s = 1 − z/d
 -->

	</li>
</ul>


	</section>
	<section id="changes">
<h2 title="Changes since last publication">最新の発行からの変更点</h2>

<p class="issue">
すべての変更点を追加する。
◎
Add all changes.
</p>

	</section>
</main><!-- MAIN -->

	<section>
<h2 id=acknowledgments title="Acknowledgments">謝辞</h2>

<p>
次の方々による注意深い考査, コメント, 修正に。
</p>

<p>
The editors would like to thank Robert O’Callahan, Cameron McCormack, Tab Atkins, Gérard Talbot, L. David Baron, Rik Cabanier, Brian Birtles, Benoit Jacob, Ken Shoemake, Alan Gresley, Maciej Stochowiak, Sylvain Galineau, Rafal Pietrak, Shane Stephens, Matt Rakow, XiangHongAi, Fabio M. Costa, Nivesh Rajbhandari, Rebecca Hauck, Gregg Tavares, Graham Clift, Erik Dahlström, Alexander Zolotov and Boris Zbarsky for their careful reviews, comments, and corrections.
</p>

	</section>
	<section id="conformance">
<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="css-common-ja.html#conformance" >CSS 日本語訳 共通ページ</a>
に委譲
】</p>


	</section>
	<section id="references">
<h2 title="References"> 参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範的）</h3>


<dl>

	<dt>[CSS21]</dt>
	<dd>Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC.</dd>
	<dd>http://www.w3.org/TR/CSS2</dd>

	<dt>[CSS3BG]</dt>
	<dd>Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 9 September 2014. CR.</dd>
	<dd>http://www.w3.org/TR/css3-background/</dd>

	<dt>[CSS3VAL]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 11 June 2015. CR.</dd>
	<dd>http://www.w3.org/TR/css-values/</dd>

	<dt>[SVG11]</dt>
	<dd>Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC.</dd>
	<dd>http://www.w3.org/TR/SVG11/</dd>

	<dt>[SVG2]</dt>
	<dd>Nikos Andronikos; et al. Scalable Vector Graphics (SVG) 2. 15 September 2015. WD.</dd>
	<dd>http://www.w3.org/TR/SVG2/</dd>

	<dt>[COMPOSITING-1]</dt>
	<dd>Rik Cabanier; Nikos Andronikos. Compositing and Blending Level 1. 13 January 2015. CR.</dd>
	<dd>http://www.w3.org/TR/compositing-1/</dd>

	<dt>[CSS-ALIGN-3]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Box Alignment Module Level 3. 19 May 2016. WD.</dd>
	<dd>http://www.w3.org/TR/css-align-3/</dd>

	<dt>[CSS-ANIMATIONS-1]</dt>
	<dd>CSS Animations Module Level 1</dd>
	<dd>http://www.w3.org/TR/css3-animations/</dd>

	<dt>[CSS-BACKGROUNDS-3]</dt>
	<dd>CSS Backgrounds and Borders Module Level 3</dd>
	<dd>http://www.w3.org/TR/css3-background/</dd>

	<dt>[CSS-CASCADE-4]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. WD.</dd>
	<dd>http://www.w3.org/TR/css-cascade-4/</dd>

	<dt>[CSS-COLOR-4]</dt>
	<dd>CSS Color Module Level 4</dd>
	<dd>https://drafts.csswg.org/css-color-4/</dd>

	<dt>[CSS-DISPLAY-3]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 15 October 2015. WD.</dd>
	<dd>http://www.w3.org/TR/css-display-3/</dd>

	<dt>[CSS-MASKING-1]</dt>
	<dd>Dirk Schulze; Brian Birtles; Tab Atkins Jr.. CSS Masking Module Level 1. 26 August 2014. CR.</dd>
	<dd>http://www.w3.org/TR/css-masking-1/</dd>

	<dt>[CSS-OVERFLOW-3]</dt>
	<dd>David Baron. CSS Overflow Module Level 3. 18 April 2013. WD.</dd>
	<dd>http://www.w3.org/TR/css-overflow-3/</dd>

	<dt>[CSS-POSITION-3]</dt>
	<dd>Rossen Atanassov; Arron Eicholz. CSS Positioned Layout Module Level 3. 17 May 2016. WD.</dd>
	<dd>http://www.w3.org/TR/css-position-3/</dd>

	<dt>[CSS-TRANSITIONS-1]</dt>
	<dd>CSS Transitions Module Level 1</dd>
	<dd>http://www.w3.org/TR/css3-transitions/</dd>

	<dt>[CSS-VALUES]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 11 June 2015. CR.</dd>
	<dd>http://www.w3.org/TR/css-values/</dd>

	<dt>[CSS-WRITING-MODES-3]</dt>
	<dd>Elika Etemad; Koji Ishii. CSS Writing Modes Level 3. 15 December 2015. CR.</dd>
	<dd>http://www.w3.org/TR/css-writing-modes-3/</dd>

	<dt>[FILTERS-1]</dt>
	<dd>Filter Effects Level 1</dd>
	<dd>http://www.w3.org/TR/filter-effects-1/</dd>

<!-- 
	<dt>[RFC2119]</dt>
 -->

</dl>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>



<dl>
	<dt>[SMIL3]</dt>
	<dd>Dick Bulterman. Synchronized Multimedia Integration Language (SMIL 3.0). 1 December 2008. REC.</dd>
	<dd>http://www.w3.org/TR/SMIL3/</dd>

	<dt>[CSSOM-VIEW]</dt>
	<dd>Simon Pieters; Glenn Adams. CSSOM View Module. 17 December 2013. WD.</dd>
	<dd>http://www.w3.org/TR/cssom-view/</dd>
</dl>


		</section>
	</section>
	<section id="index">
<h2 title="Index">索引</h2>

<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>

	</section>
	<section id="property-index">
<h2 title="Property index" data-cycling=".propdef">プロパティ索引</h2>

<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>


	</section>
	<section id="issues-index">
<h2 title="Issues Index" data-cycling=".issue">課題 索引</h2>

<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>


	</section>

<!-- 

<a class="svg">&lt;([\w\-]+)&gt;</a> → `svg!$1
<a>\[([\w\-]+)\]</a> → `r$$1



 -->



<!--%他の語

 11.001:~follows
 14.007:~make
 16.001:~note
 17:~back
 19:~following
 1:	~onto
 1:~
 1:~adding
 1:~again
 1:~allowing
 1:~around
 1:~assigned
 1:~assume
 1:~backface
 1:~bringing
 1:~care
 1:~categories
 1:~causing
 1:~changing
 1:~child
 1:~comes
 1:~compared
 1:~correlating
 決まる:~decides
 1:~denoted
 1:~describing
 1:~detail
 1:~did
 割る:~dividing
 1:~due
 1:~during
 1:~extent
 1:~facing
 1:~filled
 1:~five
 1:~giving
 1:~handle
 1:~happens
 見えなくされる:~hidden
 1:~hide
 1:~image
 1:~including
不正な:incorrectly
 1:~issues
 1:~know
 1:~leave
 1:~likewise
 1:~located
 1:~long
 1:~making
 1:~meanings
 1:~moved
 1:~moving
 1:~needed
 1:~needs
 1:~neither
 1:~nesting
 1:~nor
 1:~open
 1:~paced
 1:~pass
 1:~per
 1:~probably
 1:~really
 1:~remain
 1:~row
 1:in the sense of
 移され:~sent
 1:~sets
 1:~she
 1:~shown
 1:~shrink
 1:~sine
 1:~somewhat
 1:~speech
 1:~starting
 1:~stated
 1:~status
 1:~staying
 1:~stays
 1:~sum
 1:~surrounding
 1:~taking
 1:~terms
 1:~themselves
 1:~thing
 1:~transitioning
 1:~underway
 1:~until
 1:~vanish
 1:~verify
 1:~why
 1:~wide
 2.001:~choose
 20.002:~returns
 2:in~general
 2:~achieve
 2:~allowed
 2:~base
 2:~bigger
 2:~form
 2:~higher
 ~hoverされている間に:~hovering
 2:~intersecting
 2:~least
 −1 倍:~negated
 2:~off
 先に挙げた:~previously named
 2:~product
 2:~separated
 2:~separately
 2:~showing
 2:~similarly
 2:~twice
 2:~upon
 2:~upper
 2:~want
 2:~webkit
 働く:~works
 3.001:~adds
 3.001:~changes
 3.001:~differs
 3.001:~drawing
 3.001:~step
 3:~causes
 3:~doesn
 3:~don
 3:~edited
 3:~looking
 3:~missing
 3:~modified
 3:~next
 3:~refer
 3:~refer
 3:~something
 3:~takes
 3:“unmatrix”
 3:~you
 4.001:~place
 4.001:~start
 4.002:~look
 41.019:~get
 4:~afterwards
 が結び付けられて:~associated
 4:~down
 4:~itself
 4:~now
 4:~post
 4:~similar
 5.002:~time
 6.001:~gives
 6:~away
 6:~fixed
 6:~followed
 7.002:~becomes
 7.002:~shows
 7:~closer
 8:~non


affect？:~effected


	3 個の:~three
	2 個の:two
	2 番目の:second
	2:taken
	2:unchanged
	3 番目の:third
	4 個の:four
	6 個の:six
	90°:one-quarter:

-->

