<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Color Module Level 4 （日本語訳）</title>


<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script >
var source_data;

COMMON_DATA.page_state_key = '___CSS';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://drafts.csswg.org/css-color/',
		spec_status: 'ED',
		main: 'MAIN',
//		toc: 'contents',
		fill_text_link: '#references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};


	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		diagrams: Object.create(null),
		level: 2,
		generate: expand
	};

	create_color_table(source_data.diagrams);
	source_data.diagrams['_dgm_HSL-HWB-color-table'] = E('_HSL-HWB-color-table');

	Util.switchWordsInit(source_data);
	Util.DEFERRED.push(initColorDraw);

//	Util.del_j(); //checked 160221 spec

	return options;

	function create_color_table(diagrams){
		var id = '_named-color-table-body';
		var data = Util.textData('_named-colors-data');
		var tbody = C('tbody');
		tbody.id = id;
		diagrams[id] = tbody;
		tbody.innerHTML = 
		data.replace(/(\w+):([0-9a-f]+)/g, function(match, name, hex){
			return(
				'<tr><td style="background:'
				+ name
				+ ';">&nbsp;</td><td style="background:#'
				+ hex
				+ '">&nbsp;</td><th scope="row">'
				+ '<dfn id="valdef-color-'
				+ name
				+ '" ><code class="value">'
				+ name
				+'</code></dfn>'
				+ '</th><td><code class="value">#'
				+ hex
				+ '</code></td><td>'
				+ parseInt(hex.slice(0, 2), 16)
				+ ','
				+ parseInt(hex.slice(2, 4), 16)
				+ ','
				+ parseInt(hex.slice(4, 6), 16)
				+ '</td></tr>'
			);
		});
	}
}

function expand(mapping1){
	var link_map = this.link_map;
//	var prop_context = '';
	var class_map = {
		r: 'ref', // 参照文献
		p: 'property', // prop
		g: 'production', // production
		css: 'css',
		e: 'element',
		f: 'func',
		fv: 'func',
		t: 'type',
		l: 'literal',
		v: 'value',
		vk: 'value',
		m: 'idl',
		I: 'idl',
		NOTE: 'trans-note'
	};
	var tag_map = {
		p: 'code',
		t: 'var',
		css: 'code',
		c: 'code',
		e: 'code',
		f: 'code',
		fv: 'samp',
		v: 'code',
		vk: 'code',
		m: 'code',
		I: 'code',
		V: 'var',
		NOTE: 'span'
	};
	var context_ifc = '';

	Util.removeParts(source_data.diagrams);

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/◎[^`<◎]*|【.*?】|%\w+|`(.*?)([$@^])(\w*)/g,
			create_html
		),
		mapping1
	);

// 目次構築
	Util.rebuildToc('MAIN0', '_toc_list0');
	Util.replaceParts(source_data.diagrams);// 挿入

	function create_html(match, key, indicator, klass){
if(!indicator) {
	switch(match.charAt(0)){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '◎':
	default:
	}
	return '<span lang="en">' + match.slice(1) + '</span>';
}

var text = key;
var href = '';
//var href = link_map[klass ? (klass + '.' + key) : key] || '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 't': // typedef
	href = '#typedef-' + key;
	text = '&lt;' + key + '&gt;';
	break;
case 'p': // property
	href = '#propdef-' + key;
	break;
case 'f': // func
	text = key + '()';
	href = '#funcdef-' + key;
	break;
case 'fv': // func
	text = text.replace(/#?\w+%?(?=[,\) ])/g, '<code class="value">$&</code>');
	break;
case 'v': // css values
	href = '#valdef-color-' + key;
	break;
case 'vk': // 廃用keyword
	href = '#' + key.toLowerCase();
	break;
case 'I': // IDL defs
	if(indicator === '@'){
		context_ifc = '#dom-' + key.toLowerCase() + '-';
	}
	break;
case 'm': // IDL member
	href = context_ifc + key.toLowerCase();
	break;
case 'e': // HTML element
	break;
case 'l': // string literal
	text = '"<code>' + key + '</code>"'
	break;
case 'css': // css codes
	break;
case 'V': // variables
	break;
default:
//		console.log(match);
//	return match;
}


if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}

</script>

<script >

function initColorDraw(){
	var sW = 100;
	var sH = 100;
	var sImage = new ImageData(sW, sH);
	var scale = 10; // 階調数
	var current_hue = NaN; // 
	var isFixed = false; // 色値表示 一時固定
	var rgb_val = {
		r: 0,
		g: 0,
		b: 0,
		toRgb: function(){
			return ( 'rgb('
+ Math.round(this.r * 100 / 255) + '%,'
+ Math.round(this.g * 100 / 255) + '%,'
+ Math.round(this.b * 100 / 255) + '%)'
			);
		},
		toHex: function(){
			return '#' + (
0x1000000 | (this.r << 16) | (this.g << 8) | this.b
			).toString(16).slice(1);
		},
	};

	(function(buf){
		for(var i = 3; i < buf.length; i += 4){
			buf[i] = 0xFF;
		}
	})(sImage.data);

	drawHSL();

	E('_EX_hue_control').addEventListener('change', drawHSL, false);
	E('_EX_hue_control').addEventListener('input', drawHSL, false);
	E('_EX_scale').addEventListener('change', drawHSL, false);
	E('_EX_HSL_canvas').addEventListener('mousemove', updateRGBValue, false);
	E('_EX_HWB_canvas').addEventListener('mousemove', updateRGBValue, false);
	E('_EX_HSL_canvas').addEventListener('click', fixVal, false);
	E('_EX_HWB_canvas').addEventListener('click', fixVal, false);
	E('_EX_rgbtext_hex').addEventListener('click', updateRGBText, false);
	E('_EX_rgbtext').addEventListener('click', function(event){
		event.target.select();
	}, false);

	function drawHSL(event){
//		console.log(111)
		var hue = E('_EX_hue_control').valueAsNumber;
		if(event
			&& (event.target.id === '_EX_hue_control')
			&& (hue === current_hue)
		) {
			return;
		}
		fillImage(hue, false);
		drawImage('_EX_HSL_canvas');
		fillImage(hue, true);
		drawImage('_EX_HWB_canvas');
		E('_EX_hue_value').textContent = hue;
		E('_EX_rgbtext').value = '　';
		current_hue = hue;
	}

	function fillImage(hue, isHWB){
		hue = ((hue & 0xFFFFFFF) % 360 ) / 60;
		var buffer = sImage.data;
		var W = sW;
		var H = sH;
		var R = Math.max(parseInt(E('_EX_scale').value) & 0xFF, 2);
		var r, g, b
		var r0, g0, b0; // HWB の基底色
		var toRGB = isHWB ? hwbToRgb : hslToRgb;
		if(isHWB){
			hslToRgb(hue, 1, .5); // 最大彩度
			r0 = r;
			g0 = g;
			b0 = b;
		}

		for(var S = 0; S < H; S++){
			var address = S * W * 4;
			sat = Math.floor((S / H) * R + 0.5 ) / R;
			for(var L = 0; L < W; L++){
				toRGB(hue, sat, Math.floor((L / W) * R + 0.5 ) / R );
				buffer[address++ ]  = r * 255;
				buffer[address++ ]  = g * 255;
				buffer[address++ ]  = b * 255;
				address++;
			}
		}

		function hwbToRgb(hue, white, black) {
			var wb = white + black;
			if(wb > 1){
				r = g = b = white / wb;
				return;
			}
			r = r0 * (1 - wb) + white;
			g = g0 * (1 - wb) + white;
			b = b0 * (1 - wb) + white;
		}

		function hslToRgb(hue, sat, light) {
			if( light <= .5 ) {
				var t2 = light * (sat + 1);
			} else {
				var t2 = light + sat - (light * sat);
			}
			var t1 = light * 2 - t2;
			r = hueToRgb(t1, t2, hue + 2);
			g = hueToRgb(t1, t2, hue);
			b = hueToRgb(t1, t2, hue + 4);
		}
		function hueToRgb(t1, t2, hue) {
			if(hue > 6 ) hue -= 6;
			if(hue < 1) return (t2 - t1) * hue + t1;
			else if(hue < 3) return t2;
			else if(hue < 4) return (t2 - t1) * (4 - hue) + t1;
			else return t1;
		}
	}

	function drawImage(canvas_id){
		var dCanvas = E(canvas_id);
		var dW = dCanvas.width;
		var dH = dCanvas.height;
		var dContext = dCanvas.getContext('2d');
		dContext.putImageData(sImage, 0,0);
		dContext.drawImage(dCanvas, 0, 0, sW, sH, 0, 0, dW, dH);
	}

	function updateRGBValue(event){
		if(isFixed) return;
		var canvas = event.target;
		if(canvas.tagName !== 'CANVAS') return;
		var rect = canvas.getBoundingClientRect();
		var x = Math.floor(event.clientX - rect.left);
		var y = Math.floor(event.clientY - rect.top);
		var pixel = canvas.getContext('2d').getImageData(x, y, 1, 1).data;
		rgb_val.r = pixel[0];
		rgb_val.g = pixel[1];
		rgb_val.b = pixel[2];
		updateRGBText();
	}
	function updateRGBText(){
		E('_EX_rgbtext').value =
			E('_EX_rgbtext_hex').checked ? 
				rgb_val.toHex() : rgb_val.toRgb();
	}
	
	function fixVal(event){
		if(isFixed) return;
		if(event.target.tagName !== 'CANVAS') return;
		isFixed = true;
		setTimeout(function(){isFixed = false;}, 1000);
	}
}

</script>

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
dom-hexcolor-hexcolor:dom-hexcolor-hexcolor-clamp-octet-r-clamp-octet-g-clamp-octet-b-optional-clamp-octet-a255
</script>

<!--%links -->
<script type="text/plain" id="_link_map">
色相~角度:#_hue-angle
~null:#hue-angle-is-null

無彩色:#achromatic
~contrast比:#contrast-ratio
~hex色:#hex-color
輝度:#luminance
~CMYKから~RGBAへ素朴に変換-:#naively-convert-from-cmyk-to-rgba
~RGBAから~CMYKへ素朴に変換-:#naively-convert-from-rgba-to-cmyk
有名~色:#named-color
無tag画像:#untagged-image

色相環:https://ja.wikipedia.org/wiki/%E8%89%B2%E7%9B%B8#.E8.89.B2.E7.9B.B8.E7.92.B0

I.CMYKColor:#cmykcolor
I.CMYKColorInit:#dictdef-cmykcolorinit
I.CSSColor:#csscolor
I.ColorStringifierCallback:#callbackdef-colorstringifiercallback
I.ColorStringifierType:#enumdef-colorstringifiertype
I.ColorStringifiers:#dictdef-colorstringifiers
I.HSLColor:#hslcolor
I.HSLColorInit:#dictdef-hslcolorinit
I.HWBColor:#hwbcolor
I.HWBColorInit:#dictdef-hwbcolorinit
I.HexColor:#hexcolor
I.HexColorInit:#dictdef-hexcolorinit
I.RGBColor:#rgbcolor
I.RGBColorInit:#dictdef-rgbcolorinit
I.Element:http://dom.spec.whatwg.org/#element

m.parse():#dom-csscolor-parse
m.forward():#dom-csscolor-forward
m.forwardToSameClass():#dom-csscolor-forwardtosameclass


t.angle:~CSSVAL#angle-value
t.hash-token:~CSSSYN#typedef-hash-token
t.ident:~MQ4#typedef-ident
	~CSSSYN#identifier
t.integer:~CSSVAL#integer-value
t.number:~CSSVAL#number-value
t.percentage:~CSSVAL#percentage-value

p.text-emphasis-color:~CSSTEXTDECOR#propdef-text-emphasis-color
p.z-index:~CSS2VISUREN#propdef-z-index
	~CSSWG/css-position-3/#propdef-z-index
p.color-interpolation:~SVG2/painting.html#ColorInterpolationProperty
p.color-rendering:~SVG2/painting.html#ColorRenderingProperty
f.contrast:http://dev.w3.org/fxtf/filters/#funcdef-contrast


v.economy:#valdef-color-adjust-economy
v.exact:#valdef-color-adjust-exact

成分~値を構文解析-:~CSSSYN#parse-a-component-value

	Appendix E:~TR/CSS21/zindex.html
	CSS1:~TR/CSS1
	CSS2:~TR/CSS2/
	CSS:~TR/CSS/

	HSV:https://en.wikipedia.org/wiki/HSL_and_HSV
	Simple alpha compositing:~TR/SVG/masking.html#SimpleAlphaBlending
	named colors defined by SVG 1.1:~TR/SVG/types.html#ColorKeywords
	rendering model:~TR/SVG11/render.html
	section 9.9:~CSS2VISUREN#layers

積層文脈:~CSS2VISUREN#x44
</script>

<!--%置換語
-->
<script type="text/plain" id="words_table1">
XXXError:<a href="#_XXXError"><code>XXXError</code></a>

</script>


<!--%語彙 -->
<script type="text/plain" id="words_table">

	●色
CMYK:::
HSL:::
HSLA:::
HWB:::
RGB:::
RGBA:::
sRGB:::
Lab:::
LCH:::
	CIELab
	CCIR

黒味:blackness::~
白味:whiteness::~
黒い:black::~
白い:white::~
黒:black::~
白:white::~
	純~white:pure-white:~
純:pure:~
channel:::チャンネル

green:
red:
blue:
gray:
yellow:
black:
white:
lime:::
magenta:::
orange:::
purple:::
cyan:::

	~greenがかった~gray:greenish-gray
alpha:::

不透明:opaque::~
	~~把握しにくい
不透明度:opacity::~
全に:fully:全
反復:iteration:~
反対:opposite:~
	もう片方

調和する:matching:~
調和:matching:~
埋める:fill:~
塗られ:paint され:~
塗って:paint して:~
塗った:paint した:~
色:color::~
色域:gamut::~
空間:space::~
成分:component:~

	度0:degree:度
	度合い:degree／percentage
体系:scheme::~:スキーム

彩度:saturation:~
有彩色:chromatic color::~
無彩色:achromatic color::~
最大彩度の:fully-saturated::~
	彩度なしにされた:fully-unsaturated:~
	彩度がないfully desaturated:::
	彩度を上げる-:saturate:~

色相:hue::~
色相環:color circle::~
色空間:colorspace::~
	環:circle:~
	環:wheel:~
	cycle

明度:lightness::~
線形明度::linear-light:~
	明るさ:lightness:~
	明度の上げ／下げ:tint and shade
明るく:lighten::~
明るい:light な::~
	明るめのlight:::
暗く:darker に::~
暗い:dark な::~

contrast:::コントラスト
	contrasting
	contrast比:contrast ratio:~

鮮やか:bright::~
	鮮明にする:brighten:~
	より鮮明にする:brighter:~
濃淡:shade::~
splash:::

寒色化-:cooler:~
暖色化-:warmer:~
寒色:cool color:~
暖色:warm color:~

透明:transparent::~
透明度:transparency::~
輝度:luminance::~

角度:angle::~

解像度:resolution:~

前景:foreground::~
背景:background::~
後景:backdrop::~

仮想の:virtual:~
muted:刺激を弱めた
profile:::プロファイル
無tag:untagged:tag 無し:タグ無し


	色の調和をとる:color-matching:
	色~profile:color-profile:
	色~~関連の:color-related:

温度:temperature:~
補色:complementary color:~

矩形の:rectangular:~
座標系:coordinate system:~
極座標:polar coordinates:~
	極座標:polar:~
知覚的:perceptual:~
視覚経験:vision experiments:~
視覚:visual:~

一様:uniform:~
	中心:central:~
	明るさ皆無 no light at all:~
	漆黒:deep black:~
	有用にするため:Usefully:~
	情報を与える:convey:~
	~~成分:portion:~

計測:measurement:~
計測-:measure:~
日光:daylight:~
波長分布:spectrum:~
光環境:lighting condition:~
分光計:spectrometer:~

	●色演算

生産-:produce:~
補間-:interpolate:~
補間:interpolation:~

調節-:tweak:~
twisted:::
素朴:naive::~
naive:::
power:::
scaling:
	tint:::

単調非増加:monotonically non-increasing:~
hex:16 進
	10 進数:decimal:~
	16 進:hexadecimal:~
途中の:intermediate:~
	中間:intermediary:~
	中間の:medium:~
	中間段階:intermediate step
	真中の:mid
	真中~lives exactly between
丸めら:round さ:~
丸めた:round した:~
公式:formula:~
切詰:clipping:切り詰め
切詰-:clip:~
切詰され:clip され:切り詰めら
切詰する:clip する:切り詰める
切詰めら:clamp さ:切り詰めら
切詰めた:clamp した:切り詰めた
反時計回り:counter-clockwise:~
時計回り:clockwise:~
反転-:invert:~
反転法:inverting:~
合成-:composite::~
合成:compositing::~
合成先:composite rendering::~
合成法:compositing::~
混色-:blend::~
混色:blending::~
混色法:blending::~
混合:mixture::~
混合-:mix::~
基底:base:~
減分-:decrement:~
増分-:increment:~
増加-:increase:~
変形-:transform:変換
変形:transform:変換
	transformation
変換-:convert::~
変換:conversion::~
変換法:converting::~
変換子:converter::~
平均:average:~
操作-:manipulate:~
操作:manipulation:~
改める:alter する:~
改せる:alter できる:改められる

改変-:modify:~
改変法:modifying:~

曲線:curve:~
最大:maximum:~
最小:minimum:~
演算:operation:~
演算子:operator:~
行列:matrix:~
乗算-:multiply:~
乗算:multiplication:~
和:sum:~
線形:linear:~
調整-:adjust::~
調整:adjustment::~
	adjusting
調整子:adjuster::~
調正済み:calibrate 済み:~
距離:distance:~
軸:axis:~
遷移-:transition:~
	重み:weight:~
経路:path:~
精度:precision:~
二分探索:binary search:~
保全-:preserve:~
保全法:preserving:~

数学的:mathematical:~
	逆変換を行う:reverse:~
	量:amount:~
結合-:combine:~
接続:connection:~
	上限も下限もない~~unbounded
順応-:adapt:~
順応:adaptation:~

白色点:whitepoint::~
gamma:::ガンマ
補正:correction::~
補正-:correct::~


	●CSS
prop:property::プロパティ
border:::ボーダー
box:::ボックス
canvas:::キャンバス


無効:invalid:~
無視-:ignore:~
百分率:percentage:~
積層文脈:stacking context:~::スタッキングコンテキスト
多層化-:layer:~
層:layer:~::レイヤ
算出-:compute:~
算出値:computed value:~
初期値:initial value:~
指定値:specified value:~
適用対象:applies to:~
利用不可:N/A:~
媒体:media::~:メディア
animation:::アニメーション

継承-:inherit:~
使用:used:~
使用値:used value:~


範囲:range:~
関数:function:~
関数形:functional:~
静的:static:~
	~~面:surface:~
頁:page::ページ

描く:draw する:~
描かれ:draw され:~
描画-:render:~::レンダー
描画:rendering:~::レンダリング
具現化法:rendering:~::レンダリング

文書:document:~
文脈:context:~::コンテキスト
表示-:display:~

値:value:~
子:child:~
子たち:children:~
子孫:descendant:~
	数:number:~
	数による:numeric:~
復号-:decode:~
	:scale:~
有名:named:~
名:name:~
名前:name:~
根:root::~:ルート
style:::スタイル
	style付け:styling:~
stylesheet:::スタイルシート
型:type:~
error:::エラー
妥当な:valid:~
level:::レベル
紙:paper:~
要素:element:~
規則:rule:~
視覚的:visual:~
解決-:resolve:~
発話:speech:~::スピーチ
識別-:identify:~
	見つかる:identify:~
上位集合:superset:~
	多層化:layered:~
呈示:presentation:~

	●構文
数字:digit:~
桁:digit:~
文字:character:~
文字大小無視:case-insensitive:~
形式:format:~
形:form:~
形成-:form:~
構文:syntax:~
構文的:syntactic:~
構文解析-:parse:~::パース
構文解析器:parser:~::パーサ
token:::トークン
hash:::ハッシュ
hyphen:::ハイフン
space:::スペース
keyword:::キーワード
英字:letter:~
展開-:expand:~
展開:expansion:~
識別子:identifier:~
省略-:omit:~



	●IDL
class:::クラス
下位class:subclass::下位クラス:サブクラス
上位class:super-class::上位クラス:スーパークラス
prototype:::
method:::メソッド
引数:argument:~
	arg
整数:integer:~
文字列:string:~
文字列化-:stringify:~
文字列化子:stringifier:~
投出-:throw:~
構築-:construct:~
構築子:constructor:~::コンストラクタ
構築可能:constructable:~

正準的な:canonical:~
正規化-:normalize:~
	正規化:normalization:~
転送-:forward:~
転送:forwarding:~
配列:array:~
script:::スクリプト
object:::オブジェクト
instance:::インスタンス
interface:::インタフェース
属性:attribute:~
code:::コード
custom:::カスタム
型検査:type-testing:~
作成-:create:~
無符号:unsigned:~
有符号:signed:~

	●仕様
model:::モデル
module:::モジュール
access:::アクセス
	access容易性:accessibility:~
risk:::リスク
support:::サポート
system:::システム
version:::バージョン
機能拡張:additions:~
支援-:aid:~
algo:algorithm::アルゴリズム
UA:user agent:UA
主たる:primary:~
期待-:expect:~
予期-:expect:~
予期:expectation:~
期待:expectation:~
事例:case:~
事実:fact:~
互換:compatible:~
人:human:~
	人に馴染み易い:human-friendly:~
今や:now:~
仕方:way:~
仕様:spec:~
指定:specification:~
指定法:specifying:~
指定-:specify:~
付随-:accompany:~
別法:alternative:~
	別法としてalternately:::
任意選択:optional:~
	optionally
作者:author:~
依存-:depend:~
便宜:convenience:~
保証-:guarantee:~
確保-:ensure:~
公開-:expose:~
共有:share:~
共通的な:common な:よくある

再解釈-:reinterpret:~
冗長な:redundant:~
切替える:switch する:~
利点:advantage:~
利用-:use:~
利用事例:use-case:~
利用者:user:~
制御-:control:~
制約-:restrict:~
制限:limitation:~
前提:assumption:~
効率的:efficient:~
単独の:single:~
単純:simple:~
単純化-:simplify:~
参考の:informative:~
取扱わ:handle し:取り扱わ
取扱う:handle する:取り扱う
取扱い:handling:取り扱い
受容-:accept:~
可用:available:~
可能0:possible:可能
可能性:possibilities:~
問題:problem:~
回答:answer:~
不十分:insufficient:~
十分:sufficient:~
	~~十分:enough:~
	必要十分な:adequate:::
困難:difficult:~
	難い
困難さ:difficulties:~
基本的:basic:~
基本の:basic:~
変更点:changes:~
変種:variant:~
	委譲-:delegate:~
存在-:exist:~
安全:safe:~
完全に:complete に:~
完全0:perfect:完全
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
実際の:actual:~
容易:easy:~
容易く:easy に:~
	easier／easily:~
専門家:expert:~
将来の:future:~
将来:future:~
後処理:postprocessing:~
非推奨に:deprecate:~
応答:response:~
情報:information:~
意味-:mean:~
意図-:intend:~
手引き:guidance:~
手段:means:~
手続き:steps:~
扱う:treat する:~
扱われ:treat され:~
	技術的には:in technical terms:~
技術的:technical:~
把握-:grasp:~
成功-:succeed:~
所与の:given:与えられた
拡張-:extend:~
	拡張でき:extensible:~
拡張法:extending:~
指示-:indicate:~
指針:guideline:~
挙動する:behave する:ふるまう
挙動:behavior:ふるまい
推奨-:recommend:~
推測-:guess:~
提供-:provide:~
提供0-:offer:提供
提案:proposal:~
新たな:new:~
方向:direction:~
明示的:explicit:~
普通の:ordinary:~
有害な:deleterious:~
有意:significant:~
有用:useful:~
歴史的:historical:~
正しく:correct に:~
正しい:correct な:~
不正:incorrect:~
正確:exact:~
正確a:accurate:正確
段:step:~
段落:paragraph:~
比率:ratio:~
決定-:determine:~
注記:note:~
注意点:notes:~
概して:typical に:~
概ね:roughly:~
概念的:conceptual:~
無関係:irrelevant:~
特別な:special:~
特別:special:~
特化-:specialize:~
特定0の:particular:ある特定の
特定の:specific:~
特性:characteristic:~
特色機能:feature:~
	~~特質:peculiarities:~
状況:circumstances:~
	依存しない:independent:~
理想:ideal:~
理由:reason:~
理論:theory:~
既存の:existing:~
既定:default:~::デフォルト
既定の:default:~::デフォルト
既知:known:~
既知の:known:~
相違:difference:~
相違点:differences:~
目的0:purpose:目的
目立つ:noticable である:~
直感性:intuitiveness:~
直感的:intuitive:~
簡便:convenient:~
精確:precise:~
綴られ:spell され:~
	英語:English:~
考慮-:consider:~
能力:capability:~
自前の:own:~
専用の:own:~
自動化-:automate:~
自動的:automatic:~
自明:trivial:~
表現-:represent:~
表現:representation:~
表現法:representing:~
	規定:normative:~
理解
解-:understand:~
複雑な:complex:~
要求-:require:~
	注意点がある＊~requires some care
要請-:request:~
見做され:assume され:~
熟慮-:well-thought-out:~
見出す:find する:~
見出して:find して:~
解釈-:interpret:~
解釈:interpretation:~
計算-:calculate:~
記憶-:remember:~
	~~注意:remember:~
一式:set:~
設定-:set:~
設定ing:setting:設定
環境設定:settings:~
記述:description:~
記述-:describe:~
設計-:design:~
許容-:allow:~
評価:evaluation:~
詳細:detail:~
認識-:recognize:~
説明-:explain:~
記法:notation:~
表記:notation:~
重要:important:~
関係-:relate:~
	関係する:related:~
非一貫性:inconsistency:~
順応-:accommodate:~
取込む:take する:取り込む
読易い:readable:読み易い
読易く:readableに:読み易く
通例の:usual:~
通例的に:usually:~
通常の:normal:~
通常通りに:as normal に:通常どおりに
正規の:normal:~
	連なり:run:~
運ぶ:convey する:~
違反-:violate:~
適切:appropriate:~
適正:proper:~
適用-:apply:~
適用可能:applicable:~
選ばれ:choose され:~
選好-:prefer:~
選好:preference:~
選択-:select:~
避ける:avoid する:~
組込みの:built-in:~
尊重-:respect:~
無分別:unwise:~
一般:general:~
一般的:general:~
一貫する:consistent になる:~
一貫性:consistency:~
上書き:override:~
導入-:introduce:~
直接的:direct:~
	~~認識するaware:::
配慮:care:~
著述時:authoring:~
	新規に:brand new
	前項:previous clause:~
側面:aspect:~
働き-:work:~
働く:work する:~
向上-:improve:~
恣意的:arbitrary:~
多義的:ambiguous:~
一義的:unambiguous:~
早期の:earlier:~
判別-:distinguish:~
賢明:prudent:~
判断-:deem:~
充足-:satisfy:~
手法:method:~
常駐の:resident:~
明快:clear:~
開発-:develope:~
混同-:confuse:~
導出-:derive:~
創出-:create:~

	便益:usability benefit:~
	additionally:::
	against:::
	OS:
	Unix 系の:Unix-derived:~
	因り:due:~
	介:via:~
	例:example:~
	再度:again:~
	依然として:still:~
	呼ばれ:call され:~
	落と:drop:~
	照らし合せる:Check with:~
	知-:know:~
	示-:mention:~
	示-:show:~
	種々の:various:~
	章:chapter:~
	等々:etc:~
	自身:itself:~
	良:good:~
	表す:express:~
	見よ:see:~
	明らかにするfigure out
	行う:perform
	施す:perform する:~
	~~選択:choice:~
	適度／理に適った:reasonable:~
	~~機能する:functional:~
	試みる:attempt する:~
	述べる:describe する:~
	除-:except:~
	類似度:similarity:~
	類似的／類似する:similar:~
	類似的に:similarly:~
	更なる:further:~
	書-／記す:write:~
	望む:wish する:~
	欲され:desire され:~
	求む:want する:~
	方法:how:~
	対応-:correspond:~
	対応ing:corresponding:~
	従って，:therefore:~
	得-:obtain:~
	得る:achieve:~
	強く:strong に:~
	必要-:need:~
	必要:necessary:~
	とは限らない:necessarily:~
	平易な:easy-to-understand:~
	総てを併せた:in-total
	取り込まれ:pulled:::
	hope:::
	illustrate:::
	purposely:::
opt-in:
	気にする必要はないdoesn’t matter
	~~意図された~meant~to:::
	裏付けるmotivate:::
	~~明らかにobviously:::
	本当にreally
	~~経験的に:empirical:~
	通知notifying 
	要するrequire
依拠-:rely
理論的:theoretic:~
工業規格:industry standard:~
実施:practice:~

	●付録／例

frame:::フレーム
ink:::インク
item:::アイテム
library:::ライブラリ
menu:::メニュー
offscreen:::オフスクリーン
machine:::マシン
monitor:::モニタ
native:::ネイティブ
control:::コントロール
computer:::コンピュータ
console:::コンソール
dialog:::ダイアログ
display:::ディスプレイ
driver:::ドライバ
scrollbar:::スクロールバー
	scroll bar
押button:push button::プッシュボタン
security:::セキュリティ
site:::サイト
偽装-:spoof:~
text:::テキスト
theme:::テーマ
tooltip:::ツールチップ
click:::クリック
desktop:::デスクトップ
engine:::エンジン
graphic:::グラフィック
picker:::
color-picker:
plugin:::プラグイン
screen:::スクリーン
screenshot:::スクリーンショット
	頁webpage:::ウェブページ
	site:website
地図site:mapping website:地図 site:地図サイト
window:::ウィンドウ
concentric:::
caption:::キャプション

光源:light source:~
光:light:~
	照らされている facing
	立体的:3-D
	離れた:away

	失う:lose する:~
	ひどい:ugly
作動中の:active:~
作動中:active:~
	作動中でない:inactive:~
作動化-:activate:~
縞模様:zebra-stripe:~
三角形:triangle:~
内縁:inner:~
外縁:outer:~
	単色の solid 〜 color
	読み取る:read する:~
不能化-:disable:~
矢印:arrow:~
	~~相当する見かけlook like counterparts:::
	~~車の~~運転時:when distracted in a car
	~~表面のface:::
区画:area:~
周囲の:surrounding:~
hyperlink:::ハイパーリンク

	●未分類
browser:::ブラウザ
app:application::アプリ
web:::ウェブ
byte:::バイト
Web:::
cost:::コスト
fallback:::
feedback:::
size:::サイズ
table:::
group:::グループ
hint:::ヒント
video:::ビデオ
zero:::ゼロ
null:::
mode:::モード
list:::リスト
parameter:::パラメタ

二重に:duplicate:~
editor:::エディタ
編集:editing:~

	~gain:::
	~~派生-:generated off:~

	取得:get:~
半開区間:half-open range:~


	回す:spinする:~
対数的:logarithmic:~

補助:helper:~
国際的:international:~
機械的:mechanical:~
百万:million:~
対応付ける:map する:~
	map:::
	mapping:::
促す:prompt する:~
品質:quality:~
三組:triplet:三つ組
下層:underlying:~
下層の:underlying:~
中核の:core:~
保持-:hold:~
側:side:~
元の:original:~
入力:input:~
傾向:tend:~
入替える:swap する:~
全体:entire:~

内側:inside:~
外側:outside:~
内部的:internal:~
出力:output:~

内容:content:~
初期時には:initially:~
初期化-:initialize:~
効果:effect:~
動作-:act:~
動作:action:~
包含-:contain:~

	区切る:separate する:~
間隔:interval:~
単語:word:~
印刷-:print:~::プリント
印刷費:printing cost:~::プリント代
	印刷時:printing:~
印刷機:printer:~::プリンタ
印刷用途:print-based:~::プリント用途
合致-:match:~
	matching:~
	mismatch

即時:immediate:~
変更-:change:~
変化-:change:~
格納-:store:~
機器:device:~
	出力~機器に特有の output-device-specific 
物理的:physical:~
現在の:current:~
	現在:currently:~
画像:image:~
画素:pixel:~
相対的:relative:~
	真:true:~
移動-:move:~
等価:equivalent:~
管理:management:~
	節:section:~

築く:build する:~

組合せ:combination:~
維持-:maintain:~
背後:behind:~

記憶形式:storage format:~

	高価:expensive:~
	費やす:expend する:~
	spend

超過-:exceed:~
	近似-:approximate:~
追加-:add:~
追加法:adding:~
	追加の:additional:~
送信-:send:~
開始-:start:~
間接的:indirect:~
経由-:indirect:~
順序:order:~
快適:appreciate:~
選出-:pick up:選び出
普及した:popular な:~



================


	広:wide:~
	go
	Grayed
	harder
	rainbow
	printed
	producing
	starting
	storing
	Additionally
	BG
	CSS
	Chrome
	Color
	Closure CSS Compiler
	FG
	JavaScript
	Javascript
	Level
	MUST:must:~
	SVG
	X11
	XHTML
	~~周:~around
	~~配置:arrange
	〜したいと~~考える~ask
	attention
	bare
	become
	believe
	超えるboost
	できるcapable
	~~大文字化は~~意味を為さなくなった:stopped~mattering capitalization
	close
	closer
	closest
	refer
	rescale
	rescaled
	戻す~~変換reversing
	saying
	scaling
	~~乗算scaling
	長い目で見ればin the long run
	に関してin terms of
	相乗効果value
	Color Correction 提案から
	未発行の:unpublished:~
	six
	少しだけ／少しばかりslight
	slightly-transparent:slightly-transparent:~
	賢い:smart な:~
	~~唯一のsole
	somehow
	sometime
	結果:result:~
	結果の:resulting:~
	複数の:multiple:~
	等し:equal:~
	等しく:equally:~
	含-:include:~
	含めて:including:~
	常に:always:~
	別の:another:~
	加えて，:addition:~
	助:help:~
	~pair
	live
	常にlock
	long
	長大な
	似た見かけ~look~like
	looking
	made
	主なmain
	making
	~mark
	maybe
	multi-word:multi-word:~
	non-null:non-null:~
	塞ぐoccluding
	OS:operating system
	opposed
	part
	pay
	~~人々people
	per
	知覚される:perceptual
	~~断片piece
	点:point
	presume

	~~簡潔に:simplicity:~
	~~簡潔:compact:~
	~cycle
	間隔を詰めdenser
	区分法:division
	disclaimer


	~effort
	emphasis
	目eye
	fairly
	さほど違いはないfairly small differences
	可能にするfix
	起-:happen:~
	時点:time:~
	項:term:~
	慣用法／:usage:#4
	周に~~分布するspread around:#1


	taking
	thought
	捉えられる~thought of
	~~難を覚える~have~trouble
	turn
	転換-:~turn into


	成り立たないuntrue
	変える:vary させる
	跳ね上がる vastly increased
	言うまでもなく not to mention
	unequal
	unpublished
	予想通り:unsurprising manner で
	usable
	very
	vice versa
	何であれwhichever
	written
	生み出すyield
	悪化worse
	一定の:certain:~
	~~固有の:unique:~
	のみに~~固有truly unique
	~~一目で:quick-glance:~
	guaranteeing
	ひいき:bias:~
	互いの間をback and forth
	他所で~elsewhere
	加減算 adding／subtracting
	風にa la
	目的の you’re interested in
	ほぼ
	最も小さい:smallest:~
	最も近傍の:nearest:~
	最初の:first:~
	~~抑える:minimize:~
	最後の:last:~
	最終的:final:~
	~~最後の:final:~
	次:next:~
	残り:rest:~
	渡-:pass:~
	全くquite
	~~見なされるregard
	~~離れるapart
	around
	良くないbad
	ちょうどexactly
	後続follow
	followed
	後の／later
	上の:above:~
	下:below:~
	三つ:three:~
	最初の
	2 番目の:second:~
	3 番目の:third:~
	4 番目の:fourth:~
	5 番目の:fifth:~
	6 番目の:sixth:~
	5-tuple:5-tuple:~
	API
	与-:give:~
	両者:both:~
	二つの:two:~
	他の:other:~
	他の場合:otherwise:~

	以前の:previous:~
	任意の:arbitrary:~
	各:each:~
	間:between:~
	同じ:same:~
	一致:identical:~
	~~同じに:identical:~
	同時:simultaneous:~
	多い:often:~
	多くの:many:~
	後:after:~
	戻-:back:~
	大きい:large:~
殆どの:most:ほとんどの
	小さい:small:~
	少なくとも:least:~
	伝-:tell:~
	何か:something:~
	保-:keep:~
	個々の／ごとに:individual:~
	現れる:appear する:~
	異なる:different:~
	返す:return:~
	通:through:~
	〜に則って／従って:according:~
	〜に向かって:toward:~
	〜に基づいて:based:~
	〜に関わらず:regardless:~
	〜の代わりに:instead:~
	あいにく:unfortunately:~
	あてがう:assign:~
	いくつかの:several:~
	おそらく:probably:~
	この:this:~
	これらの:these:~
	しかしながら，:however:~
	したがって:thus:~
	すべての:all:~
	その:that:~
	そのような:such:~
	その他:others:~
	それら:they:~
	それらの:their:~
	それらの:those:~
	それらを:them:~
	それら自身:themselves:~
	とりわけ:especially:~
	べき:should:~
	より低い:lower:~
	より大きい:greater:~
	より短い:shorter:~
	より良く:better:~
	より高い:higher:~
	より高速:faster:~

</script>




<script type="text/plain" id="_named-colors-data">
aliceblue:f0f8ff
antiquewhite:faebd7
aqua:00ffff
aquamarine:7fffd4
azure:f0ffff
beige:f5f5dc
bisque:ffe4c4
black:000000
blanchedalmond:ffebcd
blue:0000ff
blueviolet:8a2be2
brown:a52a2a
burlywood:deb887
cadetblue:5f9ea0
chartreuse:7fff00
chocolate:d2691e
coral:ff7f50
cornflowerblue:6495ed
cornsilk:fff8dc
crimson:dc143c
cyan:00ffff
darkblue:00008b
darkcyan:008b8b
darkgoldenrod:b8860b
darkgray:a9a9a9
darkgreen:006400
darkgrey:a9a9a9
darkkhaki:bdb76b
darkmagenta:8b008b
darkolivegreen:556b2f
darkorange:ff8c00
darkorchid:9932cc
darkred:8b0000
darksalmon:e9967a
darkseagreen:8fbc8f
darkslateblue:483d8b
darkslategray:2f4f4f
darkslategrey:2f4f4f
darkturquoise:00ced1
darkviolet:9400d3
deeppink:ff1493
deepskyblue:00bfff
dimgray:696969
dimgrey:696969
dodgerblue:1e90ff
firebrick:b22222
floralwhite:fffaf0
forestgreen:228b22
fuchsia:ff00ff
gainsboro:dcdcdc
ghostwhite:f8f8ff
gold:ffd700
goldenrod:daa520
gray:808080
green:008000
greenyellow:adff2f
grey:808080
honeydew:f0fff0
hotpink:ff69b4
indianred:cd5c5c
indigo:4b0082
ivory:fffff0
khaki:f0e68c
lavender:e6e6fa
lavenderblush:fff0f5
lawngreen:7cfc00
lemonchiffon:fffacd
lightblue:add8e6
lightcoral:f08080
lightcyan:e0ffff
lightgoldenrodyellow:fafad2
lightgray:d3d3d3
lightgreen:90ee90
lightgrey:d3d3d3
lightpink:ffb6c1
lightsalmon:ffa07a
lightseagreen:20b2aa
lightskyblue:87cefa
lightslategray:778899
lightslategrey:778899
lightsteelblue:b0c4de
lightyellow:ffffe0
lime:00ff00
limegreen:32cd32
linen:faf0e6
magenta:ff00ff
maroon:800000
mediumaquamarine:66cdaa
mediumblue:0000cd
mediumorchid:ba55d3
mediumpurple:9370db
mediumseagreen:3cb371
mediumslateblue:7b68ee
mediumspringgreen:00fa9a
mediumturquoise:48d1cc
mediumvioletred:c71585
midnightblue:191970
mintcream:f5fffa
mistyrose:ffe4e1
moccasin:ffe4b5
navajowhite:ffdead
navy:000080
oldlace:fdf5e6
olive:808000
olivedrab:6b8e23
orange:ffa500
orangered:ff4500
orchid:da70d6
palegoldenrod:eee8aa
palegreen:98fb98
paleturquoise:afeeee
palevioletred:db7093
papayawhip:ffefd5
peachpuff:ffdab9
peru:cd853f
pink:ffc0cb
plum:dda0dd
powderblue:b0e0e6
purple:800080
rebeccapurple:663399
red:ff0000
rosybrown:bc8f8f
royalblue:4169e1
saddlebrown:8b4513
salmon:fa8072
sandybrown:f4a460
seagreen:2e8b57
seashell:fff5ee
sienna:a0522d
silver:c0c0c0
skyblue:87ceeb
slateblue:6a5acd
slategray:708090
slategrey:708090
snow:fffafa
springgreen:00ff7f
steelblue:4682b4
tan:d2b48c
teal:008080
thistle:d8bfd8
tomato:ff6347
turquoise:40e0d0
violet:ee82ee
wheat:f5deb3
white:ffffff
whitesmoke:f5f5f5
yellow:ffff00
yellowgreen:9acd32
</script>

<!--%style -->

<style>

.idl-def > dt {
	font-family: monospace0, monospace;
}

dt.prod::before {
	content: "• ";
	color: gray;
}

#named-color-table > thead th {
	color: white;
	background: black;
	border: none;
	border-right: solid 1px white;
}
#named-color-table > tbody > tr > td:first-child {
	border-right: solid white 1px;
	min-width: 3em;
}
#named-color-table > tbody > tr > td:nth-child(2) {
	min-width: 3em;
}

.lang-javascript {
	background: #FFD;
}


#_HSL-HWB-color-table {
	background:#757575;
	color: yellow;
	padding: 10px;
}
#_HSL-HWB-color-table > figure {
	display: inline-block;
	margin: 0;
	padding: 0;
}
#_HSL-HWB-color-table canvas {
	padding: 0;
	margin: 0;
	border: 0;
	cursor: crosshair;
}

</style>

<!-- 
	/*＊*/
#named-hue-table * {
	color: inherit;
}

-->
</head>

<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />

	<div id="_HSL-HWB-color-table">
<label>
色相：
<input
	id="_EX_hue_control"
	type="range"
	min="0"
	max="359"
	step="1"
	value="0"
	style="min-width:180px;"
	title="hue"
></label>
<span id="_EX_hue_value"></span>°
<select id="_EX_scale" size="1" >
	<option value="100" selected="selected" >連続</option>
	<option value="33">51 段階</option>
	<option value="32">32 段階</option>
	<option value="24">24 段階</option>
	<option value="16">17 段階</option>
	<option value="15">15 段階</option>
	<option value="12">12 段階</option>
	<option value="10">10 段階</option>
	<option value="8">8 段階</option>
	<option value="6">6 段階</option>
	<option value="5">5 段階</option>
</select>
<input id="_EX_rgbtext_hex" type="checkbox"/>
<input id="_EX_rgbtext" type="text" readonly
	style=" background: transparent; border: none; color:yellow;"
/>

<br />
<figure>
<canvas id="_EX_HSL_canvas" width="250" height="250"></canvas>
<figcaption>
HSL 色（彩度↓→明度）
</figcaption></figure>
&nbsp;
<figure>
<canvas id="_EX_HWB_canvas" width="250" height="250"></canvas>
<figcaption>
HWB 色（白味↓→黒味）
</figcaption></figure>

	</div>


</div>

<aside class="trans-meta">
<h1>CSS Color 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">CSS Color Module Level 4</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2016-04-03</time>
（公開：<time>2015-06-24</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>



<header>

<h1 id="title">CSS Color Module Level 4</h1>
<h2 id="subtitle">2016 年 4 月 24 日付 編集者草案</h2>

<dl>
	<dt title="This version:">このバージョン</dt>
	<dd><a href="https://drafts.csswg.org/css-color/">https://drafts.csswg.org/css-color/</a>
</dd>

<!-- 
	<dt title="Latest version:">最新発行バージョン</dt>
	<dt title="Editor’s Draft:">編集者草案</dt>
	<dt title="Previous versions:">以前のバージョン</dt>
 -->
	<dt title="Feedback:">フィードバック</dt>
	<dd><span><a href="mailto:www-style@w3.org?subject=%5Bcss-color%5D%20YOUR%20TOPIC%20HERE">www-style@w3.org</a> with subject line “<kbd>[css-color] <i>…message topic…</i></kbd>” (<a href="http://lists.w3.org/Archives/Public/www-style/" rel="discussion">archives</a>)</span>
</dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="#issues-index">Inline In Spec</a></dd>

<!-- 
	<dt title="Test suite:">テストスイート</dt>
 -->
	<dt title="Editors:">編集</dt>
	<dd><a href="http://xanthir.com/contact">Tab Atkins Jr.</a> (Google)</dd>
	<dd><a href="mailto:chris@w3.org">Chris Lilley</a> (W3C)</dd>

	<dt title="Former editors:">前任編集者</dt>
	<dd><a href="mailto:dbaron@dbaron.org">L. David Baron</a> (Mozilla Corporation)</dd>

</dl>

<small class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
</small>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、前景~色と~group不透明度のための
CSS `color$t 値と各種~propについて述べる。
◎
This specification describes CSS &lt;color&gt; values and properties for foreground color and group opacity.
</p>

<p>
<a href="http://www.w3.org/TR/CSS/">CSS</a>
は、（ HTML や XML などの）構造を備える文書から，
~screen, 紙, 発話, 等々
の媒体への具現化法を記述するための言語である。
◎
CSS is a language for describing the rendering of structured documents (such as HTML and XML) on screen, on paper, in speech, etc.
</p>


	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>
<!-- 
 This is a public copy of the editors’ draft. It is provided for discussion only and may change at any moment. Its publication here does not imply endorsement of its contents by W3C. Don’t cite this document other than as work in progress.

The (archived) public mailing list www-style@w3.org (see instructions) is preferred for discussion of this specification. When sending e-mail, please put the text “css-color” in the subject, preferably like this: “[css-color] …summary of comment…”

This document was produced by the CSS Working Group (part of the Style Activity).

This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.

This document is governed by the 1 August 2014 W3C Process Document. 
-->

	</section>

<nav class="toc" id="contents">
<h2 title="Table of Contents">目次</h2>
<ol id="_toc_list0"></ol></nav>


<main id="MAIN0">


	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
この~moduleは、作者が，要素の~text内容の前景~色と不透明度を指定できるようにする CSS ~propについて述べる。
また、 CSS `color$t 値~型についても詳細に述べる。
◎
This module describes CSS properties which allow authors to specify the foreground color and opacity of the text content of an element. This module also describes in detail the CSS &lt;color&gt; value type.
</p>

<p>
この~moduleは、
<a href="~TR/CSS1">CSS1</a>,
<a href="~TR/CSS2/">CSS2</a>
にすでに存在する，色に関係する各種~propと値について定義するのみならず，新たな~propと値も定義する。
◎
It not only defines the color-related properties and values that already exist in CSS1 and CSS2, but also defines new properties and values.
</p>


	</section>
	<section id="the-color-property">
<h2 title="Foreground Color: the color property">2. 前景~色： `color^p ~prop</h2>

`●名^ `color@p
`●値^ `color$t
`●初^
UA により定義される。
注釈文を見よ。
◎
UA-defined, see prose
`●適^ すべての要素
`●継^ される
`●百^ 利用不可
`●媒^ 視覚的
`●算^ ~RGBA色
`●ア^ 不可
`●表終^


<p>
この~propは、要素の~text内容の前景を埋める色を述べる。
加えて、 `currentcolor$v が解決される値も提供する。
`color$p ~prop自身にも `currentcolor$v ~keywordが設定されている場合、
`color$p: `inherit^v として扱われる。
◎
This property describes the foreground fill color of an element’s text content. In addition, it provides the value that currentcolor resolves to. If the currentcolor keyword is set on the color property itself, it is treated as color: inherit.
</p>


<p>
この~propの初期値は `black$v である。
【何故 上の初期値の欄にそう記されない？】
◎
The initial value of this property is black.
</p>

<p>
所与の色を指定する仕方には、いくつかの構文が~~用意されている。
◎
There are several different ways to syntactically specify a given color.
</p>

<p>
例えば、~lime~greenを指定するには：
◎
For example, to specify lime green:
</p>

<div class="example">

<pre class="lang-css">
em { color: lime; }             /* <span class="comment">色~keywordで指定する</span> */
em { color: rgb(0,255,0); }     /* <span class="comment">RGB 範囲 0 〜 255 で指定する</span> */
em { color: rgb(0%,100%,0%); }  /* <span class="comment">RGB 範囲 0% 〜 100% で指定する</span> */
</pre>
</div>

<!--
原文の百分率の指定
color: rgb(0.0,100.0,0.0)
は誤記 -->

<p>
`color$t 型については、後の節にて定義される。
◎
color
◎
The &lt;color&gt; type is defined in a later section.
</p>

	</section>
	<section id="color-type">
<h2 title="Representing sRGB Colors: the &lt;color&gt; type">3. ~sRGB色： `color$t 型の表現法</h2>


<p>
~sRGB色~空間による CSS 色は、値の三組
— ~red, ~green, ~blue —
により表現され，~sRGB色~空間 `SRGB$r 内のある点を識別する。
この色~空間は、国際的に認識される，機器に依存しない色~空間であり、~computer~screen上で表示される色を指定するときのみならず，印刷機の様な他の型の機器~上で色を指定するときにも有用にもなる（ `COLORIMETRY$r を見よ）。
加えて、どの色にも，不透明度
— 後景が色の背後からどの程度透けて見えるか —
を指示する~alpha成分が付随する。
各~成分は “~channel” と呼ばれることもある。
各~channelがとり得る値の範囲には，最小と最大があり，その範囲~内のどの値もとれる。
◎
CSS colors in the sRGB color space are represented by a triplet of values—red, green, and blue—identifying a point in the sRGB color space [SRGB]. This is an internationally-recognized, device-independent color space, and so is useful for specifying colors that will be displayed on a computer screen, but is also useful for specifying colors on other types of devices, like printers. (See [COLORIMETRY].) Additionally, every color is accompanied by an alpha component, indicating how transparent it is, and thus how much of the backdrop one can see behind the color. The components are also sometimes called "channels". Each channel has a minimum and maximum value, and can take any value between those two.
</p>


<p>
すべての色は、下層においては同じ記憶形式を共有する：
CSS には、 `color$t 値を<em>指定する</em>ためとして，いくつかの構文が~~用意されている。
`rgb$f, `rgba$f 関数 や~hex記法など，~sRGB色を直接的に指定するものあれば、
`hsl$f, `hsla$f 関数や, CSS が定義する各種 `有名~色$の長大な~listなど，より人に馴染み易く書いたり理解でき, かつ CSS により~sRGB色に変換されるものもある。
◎
While all colors share an underlying storage format, CSS contains several syntaxes for specifying &lt;color&gt; values. Some directly specify the sRGB color, such as the rgb() and rgba() functions and the hex notation. Others are more human-friendly to write and understand, and are converted to an sRGB color by CSS, such as the hsl() and hsla() functions, or the long list of named colors defined by CSS.
</p>


<p>
総てを併せた `color$t の定義は次で与えられる：
◎
In total, the definition of &lt;color&gt; is:
</p>

<pre class="prod">
`color@t
    = &lt;`rgb$f&gt;
    | &lt;`rgba$f&gt;
    | &lt;`hsl$f&gt;
    | &lt;`hsla$f&gt;
    | &lt;`hwb$f&gt;
    | &lt;`gray$f&gt;
    | &lt;`device-cmyk$f&gt;
    | &lt;`color-mod$f&gt;
    | `hex-color$t
    | `named-color$t
    | `currentcolor$v
    | `deprecated-system-color$t
</pre>


<p>
演算によっては、
`無彩色@
に対する働きが異なることがある。
`無彩色$とは、~grayの濃淡である：
~RGB色空間においては，［
~red, ~green, ~blue
］~channelのいずれも同じ値をとる色が `無彩色$とされ、
~HSL色空間においては，彩度 `0%^v の色が `無彩色$とされ、
~HWB色空間においては，白味と黒味の和が `100%^v 以上になる色が `無彩色$とされる。
◎
Some operations work differently on achromatic colors. An achromatic color is a shade of gray: in the RGB colorspace, a color is achromatic if the red, green, and blue channels are all the same value; in the HSL colorspace, a color is achromatic if the saturation is 0%; in the HWB colorspace, a color is achromatic if the sum of the whiteness and blackness is at least 100%.
</p>


		<section id="notes">
<h3 title="Notes On Using Colors">3.1. 色を利用するときの注意点</h3>

<p>
色は、文書をより読易くし，有意~な量の情報を追加できるが、色それ自体が
重要な情報を運ぶ~~唯一の手段になるべきでない。
文書に色を含ませるときには、
W3C Web Content Accessibility Guidelines `WCAG20$r
（ Web 内容~access容易性のための指針）を考慮するように。
◎
Although colors can add significant amounts of information to documents and make them more readable, color by itself should not be the sole means to convey important information. Please consider the W3C Web Content Accessibility Guidelines [WCAG20] when including color in your documents.
</p>

<blockquote>
<a href="~TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-without-color"><em>1.4.1 Use of Color</em></a>（色の利用）：
［
情報を運ぶ／動作を指示する／応答を促す／視覚的~要素を判別する
］ための視覚的~手段として，色のみに~~頼らないこと。
◎
1.4.1 Use of Color: Color is not used as the only visual means of conveying information, indicating an action, prompting a response, or distinguishing a visual element
</blockquote>

		</section>
		<section id="sRGB">
<h3 title="Colors in sRGB">3.2. sRGB における色</h3>

<p>
CSS ／ HTML ／ `無tag画像$
にて指定される色は、 sRGB 色~空間（ `SRGB$r ）に属する。
◎
Colors specified in CSS, HTML, and untagged images are in the sRGB color space ([SRGB]).
</p>

<p class="note">注記：
これはまだ，実装~間で依拠できるほどに実装されていない
— 実装-可能なことは示されているが。
互換に実装するためには、色が頁~内で互いに合致しない課題を避けるため，~pluginに無tag色を同じ仕方で扱うよう通知することを要するであろう。
◎
This is not yet reliably implemented across implementations, though it has been shown to be implementable. Implementing it compatibly may require notifying plugins to treat untagged colors in the same way to avoid issues with colors not matching each other within a page.
</p>

<p>
`無tag画像@
とは、［
当該の画像~形式による定義に従って，色~profileが明示的にあてがわれている画像
］ではない画像を指す。
◎
An untagged image is an image that is not explicitly assigned a color profile, as defined by the image format.
</p>

<p>
この規則は~videoには適用されないことに注意。
無tag~videoは、 CCIR 601 にて presume されるべき【？】なので。
◎
Note that this rule does not apply to videos, since untagged video should be presumed to be in CCIR 601.
</p>

<p class="issue">
本当か？
Rec.709 による HD ~videoと画像は一貫するべきでないのか？
実装は、これを本当に異なるように行っているのか？
◎
Really? Isn’t HD video in Rec.709? Shouldn’t video be consistent with images? Or do implementations really do this differently?
</p>

		</section>
	</section>
	<section id="numeric-rgb">
<h2 title="RGB Colors">4. ~RGB色</h2>

<p>
色をその~RGBA各~channelを通して直接的に指定するような，いくつかの手法がある。
◎
There are several methods of directly specifying a color in terms of its RGBA channels.
</p>



		<section id="rgb-functions">
<h3 title="The RGB functions: rgb() and rgba()">4.1. ~RGB関数： `rgb^f, `rgba^f</h3>

<p>
`rgb$f 関数は、［
~red, ~green, ~blue
］~channelを直接的に指定して~RGB色を定義する。
その構文は次で与えられる：
◎
The rgb() function defines an RGB color by specifying the red, green, and blue channels directly. Its syntax is:
</p>

<pre class="prod">
`rgb@f = rgb( `rgb-component$t#{3} )
`rgba@f = rgba( `rgb-component$t#{3} , `alpha-value$t )
`rgb-component@t = `number$t | `percentage$t
`alpha-value@t = `number$t | `percentage$t
</pre>


<p>
三つの `rgb-component$t は、順に，色の［
~red, ~green, ~blue
］~channelを指定する。
`percentage$t に対する
`0%^v は、~sRGB色域においてその色~channelの最小~値を表現し，
`100%^v は最大~値を表現する。
`number$t は `percentage$t に等価であるが，とる範囲は異なる：
ここでも `0^v は色~channelの最小~値を表現するが，最大~値は `255^v が表現する。
これらの値は、多くの~graphic~engineが，色~channelを［
0 〜 255 の整数を保持できる単独の~byte
］として内部的に格納する事実から来る。
しかしながら， CSS の構文では、著述時の便宜を図るため，
`integer$t のみならず全 `number$t も許容される。
◎
The three &lt;rgb-component&gt;s specify the red, green, and blue channels of the color, respectively. 0% represents the minimum value for that color channel in the sRGB gamut, and 100% represents the maximum value. A &lt;number&gt; is equivalent to a &lt;percentage&gt;, but with a different range: 0 again represents the minimum value for the color channel, but 255 represents the maximum. These values come from the fact that many graphics engines store the color channels internally as a single byte, which can hold integers between 0 and 255. However, the CSS syntax allows full &lt;number&gt;s, not just &lt;integer&gt;s, for authoring convenience.
</p>


<p>
機器によっては、技術的に，~sRGB色域~外
— ~channel値が `0%^v 〜 `100%^v の範囲~外 —
で表現される色を出力できるものもある。
この理由から，この範囲の外の値も許容されるが、機器の色域に切詰められる。
◎
Some devices can output colors technically outside of the sRGB gamut, represented by channels with values less than 0% or greater than 100%. For this reason, values outside of the 0%-100% range are allowed, but are clamped to the device’s gamut.)
</p>


<p>
~~最後の引数の `alpha-value$t は、色の~alphaを指定する。
`number$t 値の有用な範囲は、
`0^v （全に透明な色を表現する） 〜
`1^v （全に不透明な色を表現する）である。
`percentage$t 値の範囲は、
`0%^v （全に透明な色を表現する） 〜
`100%^v （全に不透明な色を表現する）である。
これらの範囲~外の値も無効ではないが、算出値の時点で ここで定義した範囲に切詰められる。
省略された場合の既定は `100%^v になる。
◎
The final argument, the &lt;alpha-value&gt;, specifies the alpha of the color. If given as a &lt;number&gt;, the useful range of the value is 0 (representing a fully transparent color) to 1 (representing a fully opaque color). If given as a &lt;percentage&gt;, 0% represents a fully transparent color, while 100% represents a fully opaque color. Values outside these ranges are not invalid, but are clamped to the ranges defined here at computed-value time. If omitted, it defaults to 100%.
</p>


		</section>
		<section id="hex-notation">
<h3 title="The RGB hexadecimal notations: #RRGGBB">4.2. RGB ~hex~記法： `#RRGGBB^v</h3>

<p>
CSS の
`~hex色@
記法により、各~channelに~hex~数を与えて色を指定できるようになる。
それは、~computer~codeで色を直接的に与えるときによくある書き方に類似する。
また、 `rgb$f 記法より短く書ける。
◎
The CSS hex color notation allows a color to be specified by giving the channels as hexadecimal numbers, which is similar to how colors are often written directly in computer code. It’s also shorter than writing the same color out in rgb() notation.
</p>


<p>
`hex-color@t
の構文は、［［
3 ／ 4 ／ 6 ／ 8
］個の~hex~数字の並び
］を値にとる `hash-token$t ~tokenである。
言い換えれば、~hex色は，［
~hash文字 `#^l, ［
3 ／ 4 ／ 6 ／ 8
］個の［
0 〜 9 の数字, A 〜 F の英字
］］の並びで記される（英字は大小無視なので， `#00ff00^v は `#00FF00^v と~~同じになる）。
◎
The syntax of a &lt;hex-color&gt; is a &lt;hash-token&gt; token whose value consists of 3, 4, 6, or 8 hexadecimal digits. In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
</p>

<p>
~hex記法を~RGB色に復号する方法は、与えられた~hex数字の個数で決まる：
◎
The number of hex digits given determines how to decode the hex notation into an RGB color:
</p>


<dl>
	<dt>6 桁</dt>
	<dd>
2 桁ごとに~hex~数として解釈され、順に，色の［
~red, ~green, ~blue
］~channelを指定する。

ここで，
`00^v, `ff^v （ 10 進数で255 ）が順に色の
最小~値, 最大~値
を表現する。
色の~alpha~channelは全に不透明になる。
◎
The first pair of digits, interpreted as a hexadecimal number, specifies the red channel of the color, where 00 represents the minimum value and ff (255 in decimal) represents the maximum. The next pair of digits, interpreted in the same way, specifies the green channel, and the last pair specifies the blue. The alpha channel of the color is fully opaque.
</dd>
	<dd class="example">
例えば `#00ff00^v は、
`rgb(0, 255, 0)^fv と同じ色（~lime~green）を表現する。
◎
In other words, #00ff00 represents the same color as rgb(0, 255, 0) (a lime green).
</dd>

	<dt>8 桁</dt>
	<dd>
最初の 6 桁は、 6 桁~記法と~~同じに解釈される。
最後の 2 桁も~hex数に解釈され、色の~alpha~channelを指定する。
ここで， `00^v は 全に透明な色, `ff^v は 全に不透明な色を表現する。
◎
The first 6 digits are interpreted identically to the 6-digit notation. The last pair of digits, interpreted as a hexadecimal number, specifies the alpha channel of the color, where 00 represents a fully transparent color and ff represent a fully opaque color.
</dd>
	<dd class="example">
したがって、 `#0000ffcc^v は，
`rgba(0, 0, 100%, 80%)^fv と同じ色（少しばかり透明な~blue）を表現する。
◎
In other words, #0000ffcc represents the same color as rgba(0, 0, 100%, 80%) (a slightly-transparent blue).
</dd>

	<dt>3 桁</dt>
	<dd>
これは、 6 桁~記法を短く記す変種である。
1 桁ごとに~hex数として解釈され、順に，色の［
~red, ~green, ~blue
］~channelを指定する。
ここで、 `0^v は色の最小~値を, 
`f^v は最大~値を表現する。
色の~alpha~channelは全に不透明になる。
◎
This is a shorter variant of the 6-digit notation. The first digit, interpreted as a hexadecimal number, specifies the red channel of the color, where 0 represents the minimum value and f represents the maximum. The next two digits represent the green and blue channels, respectively, in the same way. The alpha channel of the color is fully opaque.
</dd>
	<dd class="example">
この構文は、［
すべての桁を “二重に” して得られる 6 桁~記法と~~同じになる
］と説明されることも多い。
例えば、 `#123^v による表記は， `#112233^v による表記と同じ色を指定する。
この手法は、 6 桁~記法より “解像度” が低い。
3 桁の~hex構文では 4096 色しか表せない一方で，
6 桁の~hex構文では およそ 17 百万~色が可能0になる。
◎
This syntax is often explained by saying that it’s identical to a 6-digit notation obtained by "duplicating" all of the digits. For example, the notation #123 specifies the same color as the notation #112233. This method of specifying a color has lower "resolution" than the 6-digit notation; there are only 4096 possible colors expressible in the 3-digit hex syntax, as opposed to approximately 17 million in 6-digit hex syntax.
</dd>

	<dt>4 桁</dt>
	<dd>
これは、 8 桁~記法を短くした変種であり，
3 桁~記法と同じ仕方で “展開される” 。
最初の 3 桁は 3 桁~記法と同様に解釈され、最後の桁は~alpha~channelを表現し，同様に `0^v が最小~値, `f^v が最大~値に解釈される。
◎
This is a shorter variant of the 8-digit notation, "expanded" in the same way as the 3-digit notation is. The first digit, interpreted as a hexadecimal number, specifies the red channel of the color, where 0 represents the minimum value and f represents the maximum. The next three digits represent the green, blue, and alpha channels, respectively.
</dd>

</dl>

		</section>
	</section>
	<section id="named-colors">
<h2 title="Named Colors">5. 有名~色</h2>


<p>
`color$t に対する数による種々の構文に加え、
CSS では，代わりに利用できる 長大な
`有名~色@
の集合
—
`named-color@t
—
も定義する。
これらにより、共通的な色をより容易く書いたり読んだりできるようになる。
`named-color$t は、 `ident$t として記され，
`color$t が受容される所ならどこでも利用できる。
CSS により定義される通例の `ident$t と同様に、これらの~keywordは，すべて文字大小無視である。
◎
In addition to the various numeric syntaxes for &lt;color&gt;s, CSS defines a large set of named colors that can be used instead, so that common colors can be written and read more easily. A &lt;named-color&gt; is written as an &lt;ident&gt;, accepted anywhere a &lt;color&gt; is. As usual for CSS-defined &lt;ident&gt;s, all of these keywords are case-insensitive.
</p>


<p>
CSS の有名~色のうち 16 色は、元々は HTML に由来する：
`aqua^v, `black^v, `blue^v, `fuchsia^v, `gray^v, `green^v, `lime^v, `maroon^v, `navy^v, `olive^v, `purple^v, `red^v, `silver^v, `teal^v, `white^v, `yellow^v
。
残りの大部分は、 Unix 系の~systemで~consoleの色を指定するときに利用されている
X11 色~systemのある~versionに由来する。
（二つの特別な色~値 `transparent$v と `currentcolor$v は、それ専用の節にて特別に定義される。）
◎
16 of CSS’s named colors come from HTML originally: aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, and yellow. Most of the rest come from one version of the X11 color system, used in Unix-derived systems to specify colors for the console. (Two special color values, transparent and currentcolor, are specially defined in their own sections.)
</p>

<p class="note">注記：
X11 色~systemの歴史は興味深く，
Alex Sexton 氏による優れた公演
<a href="https://www.youtube.com/watch?v=HmStJQzclHc">“Peachpuffs and Lemonchiffons”</a>
に要約されている。
◎
Note: The history of the X11 color system is interesting, and was excellently summarized by Alex Sexton in his talk “Peachpuffs and Lemonchiffons”.
</p>


<p>
次の一覧に、定義される すべての（不透明な）有名~色を挙げる：
◎
The following table defines all of the opaque named colors, by giving equivalent numeric specifications in the other color syntaxes.
</p>


<table id="named-color-table">
<caption>
色~名の左の二列には、その色による背景~色~styleが，順に［
色~名~keyword, ~hex記法
］を用いて指定されている。
色~名の右の二列に、その色に等価な 6 桁~hex表記と その 10 進~表現を示す。
</caption>

<thead>
<tr><th colspan="2">~style
</th><th rowspan="2">色~名
</th><th colspan="2">値

</th></tr><tr><th>色~名
</th><th>~hex
</th><th>#RRGGBB
</th><th>10 進 R, G, B
</th></tr></thead><tbody id="_named-color-table-body"></tbody></table>

<!-- 

<table class="named-color-table">

<thead>
<tr><th style="background:black">Named
</th><th>Numeric
</th><th>Color&nbsp;name
</th><th>Hex&nbsp;rgb
</th><th>Decimal
</th></tr></thead><tbody>

COLORNAME:RRGGBB =
<tr><td style="background:COLORNAME">&nbsp;
</td><td style="background:#RRGGBB">&nbsp;
</td><th scope="row">`COLORNAME@v
</th><td>#RRGGBB
</td><td>R,G,B
</td></tr>

R = decimal,
RR = hex

<tr>\s*<td style="background:(\w+)">&nbsp;\s*</td><td style="background:#(\w+)">&nbsp;\s*</td><th scope="row">`\1@v\s*</th><td>#\2\s*</td><td>\d+,\d+,\d+\s*</td></tr>

$1:$2


-->




<p class="note">注記：
この色の~listとそれらの定義は、 SVG 1.1 にて定義される
<a href="~TR/SVG/types.html#ColorKeywords">有名~色</a>
~listの上位集合である。
<span class="trans-note">【
SVG 1.1 に無い色~名は `rebeccapurple$v のみ。
】</span>
◎
Note: this list of colors and their definitions is a superset of the list of named colors defined by SVG 1.1.
</p>

<p>
歴史的~理由から、これは X11 色~集合とも呼ばれている。
◎
For historical reasons, this is also referred to as the X11 color set.
</p>

		<section id="transparent-color">
<h3 title="The transparent keyword">5.1. `transparent^v ~keyword</h3>

<p>
~keyword
`transparent@v
は、透明~black色を指定する
— すなわち、色は，その［
~red, ~green, ~blue
］~channelは最小~値に，~alpha~channelは全に透明に設定される
— すなわち， `rgba(0, 0, 0, 0)^fv に等価になる。
これは、 `named-color$t の一種である。
◎
The keyword transparent specifies a transparent black color; that is, a color with its red, green, and blue channels all set to the minimum value and its alpha channel set to full transparency, equivalent to rgba(0, 0, 0, 0). It is a type of &lt;named-color&gt;.
</p>

		</section>
		<section id="currentcolor-color">
<h3 title="The currentcolor keyword">5.2. `currentcolor^v ~keyword</h3>


<p>
~keyword
`currentcolor@v
は、その値を同じ要素~上の `color$p ~propから取込む。
これは、<strong>使用値の時点</strong>に起こる：
すなわち、値が継承される場合、 `color$p ~propの値としてではなく， `currentcolor$v として継承されることを意味する
— この値を継承した子孫は、それを使用値に解決する時点で<em>自前の</em> `color$p ~propを利用することになる。
◎
The keyword currentcolor takes its value from the value of the color property on the same element. This happens at used-value time, which means that if the value is inherited, it’s inherited as currentcolor, not as the value of the color property, so descendants will use their own color property to resolve it.
</p>

<p>
`color$p ~propの値に `currentcolor$v が利用されていた場合、代わりに，継承される `color$p ~propの値から取込む。
◎
If currentcolor is used as the value of the color property, it instead takes its value from the inherited value of the color property.
</p>

<div class="example">
<p>
`currentcolor$v ~keywordの用法を示す単純な例をここに示す：
◎
Here’s a simple example showing how to use the currentcolor keyword:
</p>

<pre class="lang-css">
.foo {
  color: red;
  background-color: currentcolor;
}
</pre>

<p>
これは、次の様に書くことに等価になる：
◎
This is equivalent to writing:
</p>

<pre class="lang-css">
.foo {
  color: red;
  background-color: red;
}
</pre>
</div>

<div class="example">
<p>
例えば、初期値が `currentcolor$v である
`text-emphasis-color$p ~prop
`CSS3-TEXT-DECOR$r
は、既定でその~text色に合致する
— `color$p ~propが要素にわたって変化するときでも。
◎
For example, the text-emphasis-color property [CSS3-TEXT-DECOR], whose initial value is currentcolor, by default matches the text color even as the color property changes across elements.
</p>

<pre class="language-markup">
&lt;p&gt;&lt;em&gt;ある&lt;strong&gt;本当に&lt;/strong&gt;強調された~text。&lt;/em&gt;
&lt;style&gt;
p { color: black; }
em { text-emphasis: dot; }
strong { color: red; }
&lt;/style&gt;
</pre>

<!-- 
&lt;p&gt;&lt;em&gt;Some &lt;strong&gt;really&lt;/strong&gt; emphasized text.&lt;/em&gt;
&lt;style&gt;
p { color: black; }
em { text-emphasis: dot; }
strong { color: red; }
&lt;/style&gt;
-->

<p>
上の例における `em^e の内容のうち，~text［
"ある" , "強調された~text"
］は~blackになるが、 ~text "本当に" は~redになる。
◎
In the above example, the emphasis marks would be black over the text "Some" and "emphasized text", but red over the text "really".
</p>
</div>


<p class="note">注記：
CSS における，複数の単語からなる~keywordは、通例的に，その各~成分~単語を~hyphenで区切るが、 `currentcolor$v はそうでない
— 元々は、 CSS 値としてではなく
SVG にて "currentColor" と綴られる特別な属性~値として導入されたので。
後に CSS がそれを選出した時点で、~~大文字化は~~意味を為さなくなった
— CSS ~keywordは文字大小無視なので。
◎
Note: Multi-word keywords in CSS usually separate their component words with hyphens. currentcolor doesn’t, because it was originally introduced in SVG as a special attribute value spelled "currentColor", rather than a CSS value. Only later did CSS pick it up, at which point the capitalization stopped mattering, as CSS keywords are case-insensitive.
</p>


		</section>
	</section>
	<section id="the-hsl-notation">
<h2 title="HSL Colors: hsl() and hsla() functions">6. HSL 色： `hsl^f, `hsla^f 関数</h2>


<p>
色を指定するための ~RGB~systemは、~machineや~graphic~libraryにとっては簡便な一方で、人には，直感的に把握し難いと~~見なされることも多い。
例えば、ある~RGB色から同じ色相のより明るい変種を生産する方法を~~説明するのは容易でない。
◎
The RGB system for specifying colors, while convenient for machines and graphic libraries, is often regarded as very difficult for humans to gain an intuitive grasp on. It’s not easy to tell, for example, how to alter an RGB color to produce a lighter variant of the same hue.
</p>


<p>
可能0な色~体系は他にもいくつかある。
そのような一つは ~HSLによる色~体系であり、ずっと直感的に利用でき，かつ
~RGB色に対応付けるのも容易である。
◎
There are several other color schemes possible. One such is the HSL color scheme, which is much more intuitive to use, but still maps easily back to RGB colors.
</p>


<p>
~HSL色は、［
色相, 彩度, 明度
（ ＝ Hue, Saturation, Lightness ）
］からなる三組で指定される。
`hsl$f 関数の構文は次で与えられる：
◎
HSL colors are specified as a triplet of hue, saturation, and lightness. The syntax of the hsl() function is:
</p>


<pre class="prod">
`hsl@f = hsl( `hue$t, `percentage$t, `percentage$t )
`hsla@f = hsla( `hue$t, `percentage$t, `percentage$t, `alpha-value$t )
`hue@t = `number$t | `angle$t
</pre>


<p>
1 番目の引数は色相を指定する。
色相は、`色相環$における角度として表現される。
角度 `0deg^v は ~redを表現し（ `360deg^v , `720deg^v, 等々も同様）、他の色相は，それを~~起点に環の周に~~分布する
— 例えば
`120deg^v は~green,
`240deg^v は~blue
を表現する，等々。
この値は， `deg^css 単位（度（°）, degree ）で与えられることが多いので、単位なしの数でも与えることができ，その単位として解釈される。
◎
The first argument specifies the hue. Hue is represented as an angle of the color circle (the rainbow, twisted around into a circle). The angle 0deg represents red (as does 360deg, 720deg, etc.), and the rest of the hues are spread around the circle, so 120deg represents green, 240deg represents blue, etc. Because this value is so often given in degrees, the argument can also be given as a number, which is interpreted as a number of degrees. 
</p>


<p>
その次の二つの引数は、順に，彩度, 明度を与える。
彩度に対する
`100%^v は 最大彩度の鮮やかな色であり，
`0%^v は 彩度なしにされた~grayである。
明度に対する
`50%^v は “通常の” 色を表現する一方で
`100%^v は ~white,
`0%^v は~blackを表現する。
［
この範囲~外の明度／ `0%^v より小さい彩度
］は、~RGB色に変換される前に切詰される。
`100%^v より大きい ~RGB値を~supportする出力~機器があるのと同じ様に，
`100%^v より大きい彩度を~supportする出力~機器もある。
出力~機器の色域を超過する彩度は、~RGB色に変換される前に，その機器の色域に切詰され~MUST。
この切詰は、色の色相を保全する<em>べき</em>である（すなわち、~RGBを成分ごとに機器の色域に切詰するのとは同じでない）が、この仕様は，その方法については定義しない。
◎
The next two arguments are the saturation and lightness, respectively. For saturation, 100% is a fully-saturated, bright color, and 0% is a fully-unsaturated gray. For lightness, 50% represents the "normal" color, while 100% is white and 0% is black. If the saturation or lightness is less than 0% or the lightness is greater than 100%, they are clipped to those values before being converted to an RGB color. Some output devices may support saturations greater than 100%, just as they support RGB values greater than 100%. If the saturation exceeds the output device’s gamut, it must be clipped to that device’s gamut before being converted to an RGB color. This clipping should preserve the hue of the color (that is, it’s shouldn’t be the same thing as clipping an RGB component to the device’s gamut), but this specification does not define how to do so.
</p>


<p>
~~最後の引数は、色の~alpha~channelを指定する。
それは `rgba$f 関数の 4 番目の引数と~~同じに解釈される。
省略された場合の既定は `100%^v になる。
◎
The final argument specifies the alpha channel of the color. It’s interpreted identically to the fourth argument of the rgba() function. If omitted, it defaults to 100%.
</p>

<div class="example">
<p>
例えば、［
~keyword `red$v ／ ~hex記法 `#f00^v
］と同じ色を表す普通の~redは，~HSLにおいては `hsl(0, 100%, 50%)^fv で表現される。
◎
For example, an ordinary red, the same color you would see from the keyword red or the hex notation #f00, is represented in HSL as hsl(0, 100%, 50%).
</p>
</div>


<p>
~HSLの~RGBに対する利点は、ずっと直感的なことにある
— 求める色を推測しながら調節できるほどに。
また、調和する色~一式を作成するのもより容易になる（色相を同じに保ちつつ，彩度や明度を変えることにより）。
◎
The advantage of HSL over RGB is that it is far more intuitive: one can guess at the colors they want, and then tweak. It is also easier to create sets of matching colors (by keeping the hue the same and varying the saturation and lightness).
</p>

<div class="example">
<p>
例えば、次のどの色も，単に他の二つの引数を変えることにより，基本の “~green” 色相から~~派生したものである：
◎
For example, the following colors can all be generated off of the basic "green" hue, just by varying the other two arguments:
</p>

<pre>
hsl(120, 100%, 50%) <span style="color:black; background:hsl(120,100%,50%);">lime green</span>
hsl(120, 100%, 25%) <span style="color:white; background:hsl(120,100%,25%);">dark green</span>
hsl(120, 100%, 75%) <span style="color:black; background:hsl(120,100%,75%);">light green</span>
hsl(120, 75%, 85%)  <span style="color:black; background:hsl(120,75%,85%);">pastel green</span>
</pre>
</div>

		<section id="hsl-to-rgb">
<h3 title="Converting HSL colors to RGB colors">6.1. ~HSL色から RGB 色への変換法</h3>

<p>
~HSL色から RGB 色への変換法は、数学的に簡単に行える。
ここに， ECMAScript による変換~algoの単純な実装を与える。
~~簡潔にするため、~algoでは，
色相（ %hue ）は 半開区間 [0, 6) 内の数に正規化されていて，彩度（ %sat ）と明度（ %light ）は 範囲 0 〜 1 に正規化されているとする。
これは、範囲 0 〜 1 に正規化された［
色の［
~red, ~green, ~blue
］~channelを表現する三~数
］からなる配列を返す。
◎
Converting an HSL color to RGB is straightforward mathematically. Here’s a simple implementation of the conversion algorithm in JavaScript. For simplicity, this algorithm assumes that the hue has been normalized to a number in the half-open range [0, 6), and the saturation and lightness have been normalized to the range [0, 1]. It returns an array of three numbers representing the red, green, and blue channels of the colors, normalized to the range [0, 1].
</p>

<pre class="lang-javascript">
function hslToRgb(%hue, %sat, %light) {
  if( %light &lt;= .5 ) {
    var %t2 = %light * (%sat + 1);
  } else {
    var %t2 = %light + %sat - (%light * %sat);
  }
  var %t1 = %light * 2 - %t2;
  var %r = hueToRgb(%t1, %t2, %hue + 2);
  var %g = hueToRgb(%t1, %t2, %hue);
  var %b = hueToRgb(%t1, %t2, %hue - 2);
  return [%r,%g,%b];
}

function hueToRgb(%t1, %t2, %hue) {
  if(%hue &lt; 0) %hue += 6;
  if(%hue &gt;= 6) %hue -= 6;

  if(%hue &lt; 1) return (%t2 - %t1) * %hue + %t1;
  else if(%hue &lt; 3) return %t2;
  else if(%hue &lt; 4) return (%t2 - %t1) * (4 - %hue) + %t1;
  else return %t1;
}
</pre>


		</section>
		<section id="hsl-examples">
<h3 title="Examples of HSL colors">6.2. ~HSL色の例</h3>


<p class="trans-note">【
この訳では、原文の［
30°ごとの間隔で選択された各~色相による一連の~HSL色の表
］ではなく，任意の色相から~scriptにより生成して表すことにする。
また、次節の~HWB色の例も同時に示す。
（ Canvas API を~supportしない／対応が古い~browserでは~~機能しない。）
】
◎
The tables below illustrate a wide range of possible HSL colors. Each table represents one hue, selected at 30° intervals, to illustrate the common "core" hues: red, yellow, green, cyan, blue, magenta, and the six intermediary colors between these.
◎
In each table, the X axis represents the saturation while the Y axis represents the lightness.
</p>


<!-- HSL color tables -->

<p>
下の図に、特定0の色相の下で表現し得る，
HSL 色と次節の HWB 色を順に示す。
色相はスライダで調節できる。
HSL 色の彩度は下方向に, 明度は右方向に増大し，
HWB 色の白味は下方向に, 黒味は右方向に増大する。
</p>

<div id="_dgm_HSL-HWB-color-table"></div>

		</section>
	</section>
	<section id="the-hwb-notation">
<h2 title="HWB Colors: hwb() function">7. ~HWB色： `hwb^f 関数</h2>

<p>
~HWB（ Hue-Whiteness-Blackness の略称）は、色を指定する別の手法であり，~HSLに類似するが、人にとって更に使い易いことが多い。
それは、色を，基底となる色相を与える色と, その色に混合される白味と黒味の度合いで述べる。
◎
HWB (short for Hue-Whiteness-Blackness) is another method of specifying colors, similar to HSL, but often even easier for humans to work with. It describes colors with a starting hue, then a degree of whiteness and blackness to mix into that base hue.
</p>


<p>
~color-pickerは、その直感性に因り~HWB色~systemに基づいているものが多い。
◎
Many color-pickers are based on the HWB color system, due to its intuitiveness.
</p>


<figure>
<img
	style="float:left; margin-right: 1em;"
	src="css-color/color-picker.png"
>
<figcaption>
<p>
これは、利用者が
<samp class="element">input type="color"</samp>
を作動化したときに示される，（ある~versionの）
Chrome ~browserにおける~color-pickerの~screenshot（一部分）である。
外縁の環を~clickして 色相を選択し、~whiteと~blackの相対的~量は，内縁の三角形を~clickして選択するようになっている。
◎
This is a screenshot of Chrome’s color picker, shown when a user activates an &lt;input type="color"&gt;. The outer wheel is used to select the hue, then the relative amounts of white and black are selected by clicking on the inner triangle.
</p>
<div style="clear:both;"></div>
</figcaption></figure>


<p>
`hwb$f 関数の構文は次で与えられる：
◎
The syntax of the hwb() function is:
</p>


<pre class="prod">
`hwb@f = hwb( `hue$t, `percentage$t, `percentage$t [, `alpha-value$t ]? )
</pre>


<p>
1 番目の引数は色相を指定し，
`hsl$f と~~同じに解釈される。
◎
The first argument specifies the hue, and is interpreted identically to hsl().
</p>


<p>
2 番目の引数は、白味の度合いを表す範囲
`0%^v 〜 `100%^v
の百分率として，混合する~whiteの量を指定する。
同様に， 3 番目の引数も、黒味の度合いを表す範囲
`0%^v 〜 `100%^v
の百分率として，混合する~blackの量を指定する。
範囲~外の値は、関数を無効にする。
この二つの引数の和が 100% より大きい場合、算出値の時点で
それらの引数は二つの和が 100% になるように同じ比率で正規化される。
◎
The second argument specifies the amount of white to mix in, as a percentage from 0% (no whiteness) to 100% (full whiteness). Similarly, the third argument specifies the amount of black to mix in, also from 0% (no blackness) to 100% (full blackness). Values outside of these ranges make the function invalid. If the sum of these two arguments is greater than 100%, then at computed-value time they are normalized to add up to 100%, with the same relative ratio.
</p>


<p>
4 番目の引数は、色の~alpha~channelを指定する。
`rgba$f 関数に対する 4 番目の引数と同じに解釈される。
省略された場合の既定は `100%^v になる。
◎
The fourth argument specifies the alpha channel of the color. It’s interpreted identically to the fourth argument of the rgba() function. If omitted, it defaults to 100%.
</p>


<p>
結果の色は、概念的には，選ばれた色相を塗ってから, 百分率で決定される相対的~量により~whiteを塗って, ~black塗った混合と捉えることができる。
~whiteと~blackの和が（正規化-後に） `100%^v に等しいならば、`無彩色$
すなわち ある~grayの濃淡を定義し，選ばれた色相の~hintは伴わないことになる（ `~null$ になる）。
◎
The resulting color can be thought of conceptually as a mixture of paint in the chosen hue, white paint, and black paint, with the relative amounts of each determined by the percentages. If white+black is equal to 100% (after normalization), it defines an achromatic color, or some shade of gray, without any hint of the chosen hue.
</p>

		<section id="hwb-to-rgb">
<h3 title="Converting HWB colors to RGB colors">7.1. ~HWB色から~RGB色への変換法</h3>

<p>
~HWB色から~RGB色への変換法は、簡単であり,
~HSLから~RGBへ変換する方法に関係する。
~algoは次の ECMAScript 実装で与えられる
— ~whiteと~black成分は，予め その和が 100% 以下に正規化された上で，範囲 0 〜 1 に変換されているとする。
◎
Converting an HWB color to RGB is straightforward, and related to how one converts HSL to RGB. The following Javascript implementation of the algorithm assumes that the white and black components have already been normalized, so their sum is no larger than 100%, and have been converted into numbers in the range [0,1].
</p>

<pre class="lang-javascript">
function hwbToRgb(%hue, %white, %black) {
  var %rgb = hslToRgb(%hue, 1, .5);
  for(var %i = 0; %i &lt; 3; %i++) {
    rgb[%i] *= (1 - %white - %black);
    rgb[%i] += %white;
  }
  return %rgb;
}
</pre>


		</section>
		<section id="hwb-examples">
<h3 title="Examples of HWB Colors">7.2. ~HWB色の例</h3>

<p class="trans-note">【
この節の内容は
<a href="#hsl-examples">~HSL色の例</a>
節に委譲。
】</p>

		</section>
	</section>
	<section id="grays">
<h2 title="Specifying Grays: the gray() functional notation">8.  ~grayの指定法： `gray^f 関数形~記法</h2>


<p>
~grayは、彩度がない（実際の色を全く欠いている）点で特別な色の集合である。
~gray色を
`rgb$f で指定する場合，三つの~channelはすべて~~同じになり、
`hsl$f で指定する場合，色相は無関係で 彩度は常に `0%^v になる
— すなわち，冗長な情報を指定することが要求される。
◎
Grays are a very special set of colors. They’re fully desaturated (lacking any actual color at all), which means that specifying a gray with any of the other notations requires specifying some redundant information: if specifying the color with rgb(), all three channels are identical; if specifying the color with hsl(), the hue is irrelevant and the saturation is locked to 0%.
</p>


<p>
`gray$f
関数形~記法は、必要な情報のみが要求されるように，この共通的な色の集合に対する指定法を単純化する。
◎
The gray() functional notation simplifies specifying this common set of colors, so that only the necessary information is required.
</p>

	
<pre class="prod">
`gray@f = gray( [`number$t | `percentage$t] [, `alpha-value$t]? )
</pre>


<p>
1 番目の引数は~grayの濃淡を指定する。
省略可能な 2 番目の引数は、色の~alpha~channelを指定する
。
◎
The first argument specifies the shade of gray, while the second optional argument specifies the alpha channel of the color.
</p>


<p>
<code class="func">gray(%A)</code>
は
<code class="func">rgb(%A,%A,%A)</code>
と同じ色を表現する。
<code class="func">gray(%A,%B)</code>
は
<code class="func">rgb(%A,%A,%A,%B)</code>
と同じ色を表現する。
◎
gray(A) represents the same color as rgb(A,A,A). gray(A,B) represents the same color as rgb(A,A,A,B).
</p>


<div class="issue">
<p>
`gray$f は、より賢い~modeも~opt-inする~keyword引数もとれるべきである。
例えば、
"`luminance^v" （“輝度”）をとれるようになれば、単純に `rgb$f 形に展開する代わりに，実際に指定された輝度による~grayを算出することもできる。
sRGB ~power曲線を見れば、~grayは
“あるべき色”
よりずっと暗いことがわかる
— 例えば、 50% ~grayの輝度は .5 でなく .21 になる。
◎
gray() should have a keyword arg that opts it into smarter modes. "luminance", for example, instead of being a simple expansion to rgb(), could actually compute the gray with the specified luminance. The sRGB power curve means that grays are much darker than they "should" be; 50% gray has a luminance of .21, for example, rather than .5.
</p>

<p>
~grayに関しては，輝度から色へ戻す~~変換は容易である：
結果は、［
%L &lt; .0774 ならば
( %x × 12.92 ) ／
他の場合は
( ( %x ^ (5 ÷ 12)) × 1.055 − .055 )
］になる。
【？】
◎
Reversing luminance to color is easy for grays: if L &lt; .0774, x * 12.92; otherwise, (x ^ (5/12)) * 1.055 - .055.
</p>

<p>
別法として、相対的~contrast比に基づくような方法も考えられる
— ~contrast比~空間において， `#757575^v が ~whiteと~blackの真中の~grayになるような。
◎
Alternately, base it on relative contrast ratios somehow? #757575 is the gray that lives exactly between white and black, in contrast-ratio space.
</p>

<p>
あるいは~Labの L ~~成分を利用する
— L=50 が真中の~grayになる。
◎
Or use the L portion of Lab, where L=50 is a mid gray.
</p>
<p>
［
0% が~black, 100% が~white, 50% が #757575
］に対応するような~contrast比~空間と, 輝度~空間との間では，
( 輝度 = 21 ^ p )【？】
で変換した上で、その輝度を持つ~grayを見出す。
◎
Taking 0% to be black, 100% to be white, and 50% to be #757575, you convert between contrast-ratio space and luminance space with L = 21^p, then find the gray with that luminance.
</p>
</div>

	</section>
	<section id="lab-colors">
<h2 title="Device-independent Colors">9. 機器に依存しない色： ~Labと~LCH</h2>

<p>
色の物理的~計測は、概して~Lab
— 1976 年に
<abbr title="Commission Internationale de l’Eclairage">CIE</abbr>
により創出された色~空間 —
で表される。
ある機器から別の機器への色~変換でも，その中間段階に~Labが利用される。
~Labは人の視覚経験から導出されており，人が見れる色の全~範囲を表現する。
◎
Physical measurements of a color are typically expressed in a color space created in 1976 by the CIE, Lab. Color conversions from one device to another also use Lab as an intermediate step. Derived from human vision experiments, Lab represents the entire range of color that humans can see.
</p>

<p>
~Labは中心に明度~軸を伴う矩形の座標系である。
L=0 は漆黒（明るさ皆無）,
L=100 は~white（ D50 ~white
— 標準化された色~温度 5000K による日光の波長分布）を表す。
有用にするため， L=50 が真中の~grayになるように設計されている
— ~Lab色~空間は，<em>知覚的に一様</em> になる†ように意図されている。
a, b 軸は色相~情報を与える。
a 軸における正の値は~redになる一方, 負の値は補色の~greenになる。
同様に， b 軸における正の値は~yellowになる一方, 負の値は補色である紫色になる。
<!--  ~blue/~violet＊ -->
彩度の低い色の a, b 値は小さくなる
— すなわち、彩度を落とせば L 軸 に近づき，彩度を上げれば L 軸から離れる。
◎
Lab is a rectangular coordinate system with a central Lightness axis. L=0 is deep black (no light at all) while L=100 is white (D50 white, a standardized daylight spectrum with a color temperature of 5000K). Usefully, L=50 is mid gray, by design: the Lab color space is intended to be perceptually uniform. The a and b axes convey hue; positive values along the a axis are red while negative values are the complementary color, green. Similarly positive values along the b axis are yellow and negative are the complementary blue/violet. Desaturated colors have small values of a and b and are close to the L axis; saturated colors lie far from the L axis.
</p>

<p class="trans-note">【†
人の感覚による色の近さの度合いが、色の座標に依らず，空間における色の距離におよそ比例する（
<a href="https://en.wikipedia.org/wiki/Color_difference#Tolerance">参考</a>
）。
】</p>

<p>
D50 はまた、 ICC 色~間の変換における~profile接続~空間（ PCS, profile connection space ）の白色点として利用される。
これは、~Lab編集を提供0する画像~editorや, 分光計などの物理的~計測~機器が，計測された色を~Labで報告するときに利用される値である。
他の白色点を利用して指定された色からの変換†は，有彩色~順応~変形（ chromatic adaptation transform ）と呼ばれ、新たな光環境に人が順応するときの，人の視覚~systemにおける変化を~modelにしている。
Bradford ~algoは，有彩色~順応~変形の工業規格であり、単純な行列の乗算により，容易に計算できる。
◎
D50 is also the whitepoint used for the profile connection space in ICC color interconversion, the values used in image editors which offer Lab editing, and the value used by physical measurement devices such as spectrometers, when they report measured colors in Lab. Conversion from colors specified using other white points is called a chromatic adaptation transform, which models the changes in the human visual system as we adapt to a new lighting condition. The Bradford algorithm is the industry standard chromatic adaptation transform, and is easy to calculate as it is a simple matrix multiplication.
</p>

<p class="trans-note">【†
白色点（波長分布と強さ）が異なる光源の下で撮影された画像の色を，
D50 （ “標準の光源” ）の下で撮影されたかのように補正することを意味すると思われる（
<a href="http://w3.kcua.ac.jp/~fujiwara/infosci/colorspace/bradford.html">参考</a>
）。
】</p>

<p>
~Labでは、2 つの色は，視覚的に同じ明度であれば、色相にかかわらず，同じ L 値になり、この点で~HSLと異なる。
例えば，~yellow（ `#FF0^v ）は ~blue（ `#00F^v ）より明らかに~~明るいが、これらの~HSL明度は，同じになる。
◎
In Lab if two colors have the same L value, they appear to have the same visual lightness – regardless of how different their hues are. This is different from HSL, where for example blue (#00F) and yellow (#FF0) have the same HSL lightness despite yellow being obviously far lighter than blue.
</p>

<p>
~LCHは、~Labと同じ L 軸を利用しつつ，極座標 ( C, H )
（ ＝ ( Chroma, Hue ) ＝ ( 純色度, 彩度 ) ）を利用する。
C は L 軸からの距離であり，
H は a 軸~正~~方向からの角度（ ° ）である。
◎
LCH has the same L axis as Lab, but uses polar coordinates C (chroma) and H (hue). C is the geometric distance from the L axis and H is the angle, in degrees, from the positive a axis.
</p>

<p class="note">注記：
~Labにおける明度~軸と~HSLにおける L 軸とを混同すべきでない。
例えば~HSLにおいては、 sRGB 色~blue（ `#00F^v ）は視覚的には~yellow（ `#FF0^v ）よりずっと暗いが，それらの L 値は同じになる。
~Labにおいては、同じ L 値に計測される 2 つの色の視覚的~明度は一致する。
~HSL, および関係する極座標~RGB~modelは，
~LCHが~Labにもたらしたものに類似する便益を，~RGBにももたらすために開発された。
◎
The Lightness axis in Lab should not be confused with the L axis in HSL. For example, in HSL, the sRGB colors blue (#00F) and yellow (#FF0) have the same value of L even though visually, blue is much darker. In Lab, if two colors have the same measured L value, they have identical visual lightness. HSL and related polar RGB models were developed to give similar usability benefits for RGB that LCH gave to Lab.
</p>

		<section id="specifying-lab-lch">
<h3 title="Specifying Lab and LCH: the lab() and lch() functional notations">9.1. ~Lab, ~LCH の指定法： `lab^f, `lch^f 関数形~記法</h3>


<p>
CSS では、~Lab／~LCHで直接的に色を表せる：
◎
CSS allows colors to be directly expressed in Lab and LCH.
</p>

<pre class="prod">
`lab@f = lab( `number$t, `number$t, `number$t )
</pre>

<p>
引数は順に
L, a, b
（ L は CIE 明度）を指定する。
L は範囲 [0, 100] に拘束される一方で、
a, b は有符号~値であり，理論的には上限も下限もないが、実施においては， ±160 を超過しない。
◎
The first argument specifies the CIE Lightness, the second argument is a and the third is b. L is constrained to the range [0, 100] while a and b are signed values and theoretically unbounded but in practice do not exceed ±160.
</p>

<pre class="prod">
`lch@f = lch( `number$t, `number$t, `number$t )
</pre>

<p>
引数は順に
L, C, H
（ L は CIE 明度）を指定する。
L は範囲 [0, 100] に拘束される。
C は無符号~実数である一方，
H は範囲 [0, 360) に拘束される。
◎
The first argument specifies the CIE Lightness, the second argument is C and the third is H. L is constrained to the range [0, 100]. C is an unsigned number while H is constrained to the range [0, 360).
</p>



		</section>
		<section id="rgb-to-lab">
<h3 title="Converting sRGB colors to Lab colors">9.2. ~sRGB色から~Lab色への変換法</h3>

<p>
~sRGBから~Labへの変換には、何~段か要する。
実施においては，最初の段を除くすべては、線形の計算であり，結合できるが。
◎
Conversion from sRGB to Lab requires several steps, although in practice all but the first step are linear calculations and can be combined.
</p>

<ol>
	<li>
~sRGBから線形明度~sRGBへ変換する（~gamma補正を外す）
◎
Convert from sRGB to linear-light sRGB (undo gamma correction)
</li>

	<li>
線形~sRGBから CIE XYZ へ変換する
◎
Convert from linear sRGB to CIE XYZ
</li>

	<li>
Bradford 変形で，
（~sRGBが利用する） D65 白色点から
（~Labが利用する） D50 白色点へ変換する
◎
Convert from a D65 whitepoint (used by sRGB) to the D50 whitepoint used in Lab, with the Bradford transform
</li>

	<li>
（ D50 に順応された） XYZ から~Labへ変換する
◎
Convert D50-adapted XYZ to Lab
</li>

</ol>

		</section>
		<section id="lab-to-rgb">
<h3 title="Converting Lab colors to sRGB colors">9.3. ~Lab色から~sRGB色へのへ変換法</h3>

<p>
~Labから~sRGBへの変換には、何~段か要する。
実施においては，最後の段を除くすべては、線形の計算であり，結合できるが。
◎
Conversion from Lab to sRGB also requires multiple steps, and again in practice all but the last step are linear calculations and can be combined.
</p>

<ol>

	<li>
（ D50 に順応された）~Labから XYZ へ変換する
◎
Convert Lab to (D50-adapted) XYZ
</li>

	<li>
Bradford 変形で，
（~Labが利用する） D50 白色点から
（~sRGBが利用する） D65 白色点へ変換する
◎
Convert from a D50 whitepoint (used by Lab) to the D65 whitepoint used in sRGB, with the Bradford transform
</li>

	<li>
（ D65 に順応された） CIE XYZ から線形~sRGBへ変換する
◎
Convert from (D65-adapted) CIE XYZ to linear sRGB
</li>

	<li>
線形明度~sRGBから~sRGBへ変換する（~gamma補正を施す）
◎
Convert from linear-light sRGB to sRGB (do gamma correction)
</li></ol>



		</section>
		<section id="lab-to-lch">
<h3 title="Converting Lab colors to LCH colors">9.4. ~Lab色から~LCH色へのへ変換法</h3>

<p>
~LCHへの変換は自明である：
◎
Conversion to LCH is trivial:
</p>

<ol ><li>%H ~SET atan2( %b, %a )
</li><li>%C ~SET sqrt( %a × %b + %b × %b )
</li><li>%L はそのまま同じ
</li></ol>

		</section>
		<section id="lch-to-lab">
<h3 title="Converting LCH colors to Lab colors">9.5. ~LCH色から~Lab色へのへ変換法</h3>

<p>
~Labへの変換は自明である：
◎
Conversion to Lab is trivial:
</p>

<ol ><li>%a ~SET %C × cos( %H )
</li><li>%b ~SET %C × sin( %H )
</li><li>%L はそのまま同じ
</li></ol>

		</section>


	</section>
	<section id="cmyk-colors">
<h2 title="Device-dependent CMYK Colors: the device-cmyk() function">10. 機器に依存する~CMYK色： `device-cmyk^f 関数</h2>


<p>
~screenは概して，色を~RGB画素で直接的に表示するが、印刷機では異なる仕方で
色を表現することが多い。
特に、印刷用途において最も共通的な仕方では、色を~CMYK
— ~cyan, ~magenta, ~yellow, ~black —
の組合せで表現し，その機器~上の特定0の色を生み出す。
`device-cmyk$f
関数により、作者は，この仕方で色を指定できるようになる：
◎
While screens typically display colors directly with RGB pixels, printers often represent colors in different ways. In particular, one of the most common print-based ways of representing colors is with CMYK: a combination of cyan, magenta, yellow, and black which yields a particular color on that device. The device-cmyk() function allows authors to specify a color in this way:
</p>

<pre class="prod">
`device-cmyk@f =
    device-cmyk( `cmyk-component$t#{4} , `alpha-value$t? , `color$t? )
`cmyk-component@t
    = `number$t | `percentage$t
</pre>


<p>
`device-cmyk$f の関数の最初から 4 個の引数は、順に，［
~cyan, ~magenta, ~yellow, ~black
］成分を
範囲 0 〜 1 の数, または
範囲 0% 〜 100% の百分率で指定する。
これらの二つの用法は等価であり，互いの対応関係は線形になる。
この範囲~外の値も無効ではないが、それらは範囲内に切詰められる。
◎
The arguments of the device-cmyk() function specify the cyan, magenta, yellow, and black components, in order, as a number between 0 and 1 or a percentage between 0% and 100%. These two usages are equivalent, and map to each other linearly. Values less than 0 or 0%, or greater than 1 or 100%, are not invalid; instead, they are clamped to 0/0% or 1/100%.
</p>


<p>
5 番目の引数は、色の~alpha~channelを指定し，
`rgba$f 関数の 4 番目の引数と~~同じに解釈される。
省略された場合の既定は `100%^v になる。
◎
The fifth argument specifies the alpha channel of the color. It’s interpreted identically to the fourth argument of the rgba() function. If omitted, it defaults to 100%.
</p>


<p>
6 番目の引数は、~fallback色を指定する。
~UAが~CMYK色から~RGBへ正確aに変形する方法を知らないときに利用される。
省略された場合の既定は，`~CMYKから~RGBAへ素朴に変換-$した結果の~RGB色になる。
◎
The sixth argument specifies the fallback color, used when the user agent doesn’t know how to accurately transform the CMYK color to RGB. If omitted, it defaults to the CMYK color naively converted to RGBA.
</p>


<p>
概して、印刷用途の~appは、実際に利用する色を~CMYKとして格納し, それを そのままの形で印刷機へ送信するが、あいにく， CSS は それをできない。
種々の CSS 特色機能は、色の合成や混色, 等々
を行うときに，~RGB色を要する。
そのようなわけで、~CMYK色は，等価な~RGB色に変換され~MUST。
これは、~HSL／~HWBから~RGBへ変換するときほど自明ではない
— 精確な変換は、出力~機器の精確な特性に依存する。
◎
Typically, print-based applications will actually store the used colors as CMYK, and send them to the printer in that form. Unfortunately, CSS cannot do that; various CSS features require an RGB color, so that compositing/blending/etc. can be done. As such, CMYK colors must be converted to an equivalent RGB color. This is not trivial, like the conversion from HSL or HWB to RGB; the precise conversion depends on the precise characteristics of the output device.
</p>


<p>
~UAが
~CMYK色から正しい~RGB色へ正確aに変換できるような
出力~機器についての情報を得られるならば、
`device-cmyk$f 関数の算出値は、~RGBA色で~MUST。
他の場合、算出値は~fallback色で~MUST。
◎
If the user agent has information about the output device such that it believes it can accurately convert the CMYK color to a correct RGB color, the computed value of the device-cmyk() function must be that RGBA color. Otherwise, the computed value must be the fallback color.
</p>

<div class="example">
<p>
例えば、次の色は、（上に挙げた既定の変換の下で）等価になる：
◎
For example, the following colors are equivalent (under the default conversion listed above):
</p>

<pre class="lang-css">
color: device-cmyk(0, 81%, 81%, 30%);
color: rgb(178, 34, 34);
color: firebrick;
</pre>


<p class="note">注記：
これらの色は、~browserが，~CMYKと~RGBとの間の より精確な変換を知るならば、精確に合致しないかもしれない。
自身の文書にて~CMYK色を<strong>少しでも</strong>利用する作者には、色の調和をとる困難さを避けるため，~CMYK色<strong>のみ</strong>を利用することが推奨される。
◎
Note: these colors might not match precisely if the browser knows a more precise conversion between CMYK and RGB colors. It’s recommended that if authors use any CMYK colors in their document, that they use only CMYK colors in their document to avoid any color-matching difficulties.
</p>
</div>


		<section id="cmyk-rgb">
<h3 title="Converting Between CMYK and RGB-Based Colors">10.1. ~CMYK色と~RGB色の間の変換法</h3>

<p>
この節では、（ icc に基づく）調正済みの色と機器による調正済みでない~CMYKとをはっきり~~区別する必要がある。
これは特に~RGBとの間の変換に影響する。
◎
This section now needs to clearly distinguish between calibrated (icc-based) color on the one hand, and uncalibrated device-cmyk on the other. This particularly affects conversion to and from RGB.
</p>

<p>
この仕様にて定義される殆どの色は、~RGBAと直接的に互換であり，したがって
互いの間を機械的かつ一貫するように変換できる一方で、~CMYK色は，直接的に互換にならない。
所与の~CMYK色に対応付けられる~RGBA色は、出力~機器の物理的~特性に依存することになる。
◎
While most colors defined in this specification are directly compatible with RGBA, and thus can be mechanically and consistently converted back and forth with it, CMYK colors are not directly compatible; a given CMYK color will map to various RGBA colors depending on the physical characteristics of the output device.
</p>


<p>
~UAが，~RGBAと~CMYKに対し出力~機器の色~profileを~~認識するのが，理想である
— そうであれば、~UAは，~CMYK色と~RGBA色を相互に変換し~MUST —
先ず対象の色を［
CIELab などの，機器に依存しない適切な色~空間
］へ変換した上で、各~演算に対し，適切な色~profileを利用して出力~色~空間に変換することにより。
◎
Ideally, the user agent will be aware of the output device’s color profiles for RGBA and CMYK. If this is true, then the user agent must convert between CMYK and RGBA colors (and vice versa) by first converting the color into an appropriate device-independent color space, such as CIELab, and then converting into the output color space, using the appropriate color profiles for each operation.
</p>


<p>
しかしながら、これは常に可能0になるとは限らない。
その場合、~UAは 次の “素朴な” 変換~algoを利用し~MUST。
◎
This is not always possible, however. In that case, the user agent must use the following naive conversion algorithms.
</p>

<p>
`~CMYKから~RGBAへ素朴に変換-@
するときは：
◎
To naively convert from CMYK to RGBA:
</p>


<p>
~fallback色が指定されていた場合、その色を返す（必要なら~RGBへ変換するときも）。
他の場合：
◎
If a fallback color was specified, return that color (converting it to RGB as well, if necessary). Otherwise:
</p>


<pre class="lang-javascript">
red   = 1 - min(1, cyan    * (1 - black) + black)
green = 1 - min(1, magenta * (1 - black) + black)
blue  = 1 - min(1, yellow  * (1 - black) + black)
</pre>

<p>
~alphaについては入力~色と同じ。
◎
Alpha is same as for input color.
</p>

<p>
`~RGBAから~CMYKへ素朴に変換-@
するときは：
◎
To naively convert from RGBA to CMYK:
</p>


<pre class="lang-javascript">
black = 1 - max(red, green, blue)
cyan    = (1 - red - black)   / (1 - black), or 0 if black is 1
magenta = (1 - green - black) / (1 - black), or 0 if black is 1
yellow  = (1 - blue - black)  / (1 - black), or 0 if black is 1
</pre>


<ul>
	<li>
~alphaについては入力~色と同じ。
◎
alpha is the same as the input color
</li>
	<li>
~fallback色は、入力~色に設定され~MUST
◎
fallback color must be set to the input color
</li>

</ul>



<div class="trans-note">
<p >【
次の様に式を簡略化できる：
】</p>

<pre class="lang-javascript">
// CMYK → RGB
%v = 1 - black;
red   = max(0, (1 -    cyan) * %v);
green = max(0, (1 - magenta) * %v);
blue  = max(0, (1 -  yellow) * %v);

// RGB → CMYK
%v = max(red, green, blue);
black = 1 - %v;
if(%v !== 0){
    cyan    = 1 - (   red / %v );
    magenta = 1 - ( green / %v );
    yellow  = 1 - (  blue / %v );
} else {
    cyan = magenta = yellow = 0;
}
</pre>

</div>

		</section>
	</section>
	<section id="modifying-colors">
<h2 title="Modifying Colors: the color-mod() function">11. 色の改変法： `color-mod^f 関数</h2>

<p>
~siteに用いる色~体系を指定するとき、ある色に近いが, 少しばかり異なる色が求められることが多い。
これは、 CSS Variable が利用されるときには，より重要になる
— そこでは、作者は先ず “基底の” 色を定義して上で、他所で利用するため 少しだけ改変された一連の色を生産することを望むであろう。
◎
When specifying a color scheme for a site, one often wants a color that is close to another color, but slightly different. This becomes more important when CSS Variables are used, where an author may wish to define a "base" color, and then produce an array of slightly modified colors to use elsewhere.
</p>


<p>
`color-mod$f 関数は、既存の色を取込んで，それに~zero個以上の［
何らかの仕方で色を操作する方法を指定するような
“色~調整子（ color adjuster ）”
］を~~順次~適用していく。
◎
The color-mod() function takes an existing color, and applies zero or more "color adjusters" to it, which specify how to manipulate the color in some way.
</p>


<p>
色~調整子のうちいくつかは、色を［
~RGB／~HSL／~HWB
］色として簡単に操作する
— 対応する構文で色を指定したときに，引数の一つを少しだけ改変するのと似た形で。
他のものは、混色したり, ~contrastをとる色を見出すなど，より複雑な操作を色に施す。
◎
Several of the color adjusters straightforwardly manipulate the color as an RGB, HSL, or HWB color, as if you’d specified a color in the appropriate syntax with one argument slightly modified. Others perform more complex manipulations of the color, such as blending it or finding contrasting colors.
</p>


<p>
加えて、 `color-mod$f 関数は，有名~色を指定するための，より直感的な，
<abbr title="Color Naming System">CNS</abbr>
【<a href="https://en.wikipedia.org/wiki/Color_Naming_System">Color Naming System</a>】
に基づく新たな構文を定義する。
◎
Additionally, the color-mod() function defines a new, more intuitive syntax for specifying named colors, based on CNS.
</p>

<p class="issue">
実際に CNS のものを追加する。
◎
Actually add the CNS thing.
</p>


<pre class="prod">
`color-mod@f = color( [ `color$t | `hue$t ] `color-adjuster$t* )
`color-adjuster@t
    = [red( | green( | blue( | alpha( | a(]
          ['+' | '-']? [`number$t | `percentage$t] )
    | [red( | green( | blue( | alpha( | a(]
          '*' `percentage$t )
    | rgb( ['+' | '-'] [`number$t | `percentage$t]{3} )
    | rgb( ['+' | '-'] `hash-token$t )
    | rgb( '*' `percentage$t )

    | [hue( | h(]
          ['+' | '-' | '*']? `angle$t )
    | [saturation( | s(]
          ['+' | '-' | '*']? `percentage$t )
    | [lightness( | l(]
          ['+' | '-' | '*']? `percentage$t )
    | [whiteness( | w(]
          ['+' | '-' | '*']? `percentage$t )
    | [blackness( | b(]
          ['+' | '-' | '*']? `percentage$t )

    | tint( `percentage$t )
    | shade( `percentage$t )

    | blend( `color$t `percentage$t [`rgb^v | `hsl^v | `hwb^v]? )
    | blenda( `color$t `percentage$t [`rgb^v | `hsl^v | `hwb^v]? )

    | contrast( `percentage$t? )
</pre>


<p>
1 番目の引数は、 `基底~色^V を指定する。
`hue$t が与えられているならば,
`基底~色^V
は、所与の `hue$t を伴う
彩度 100%, 明度 50% の~HSL色になる（言い換えれば，所与の色相による最大彩度の色）。
◎
The first argument specifies the base color. If a &lt;hue&gt; is given, the base color is the HSL color with the given &lt;hue&gt;, 100% saturation, and 50% lightness (in other words, the fully-saturated color with the given hue).
</p>


<p>
`基底~色^V の後に，~zero個以上の `color-adjuster$t を指定できる。
各 `color-adjuster$t は、 `基底~色^V をある仕方で改変した上で，~list内の次の `color-adjuster$t に結果の `基底~色^V を渡す。
~list内には `color-adjuster$t を，同じものも含め，いくつでも指定できる
— 
`color(red s(- 10%) s(- 10%))^fv など。
色は、各~instanceごとに，適切に改変される（この事例では、 `hsl(0deg, 80%, 50%)^fv を生産する）。
◎
After the base color, zero or more &lt;color-adjuster&gt;s can be specified. Each &lt;color-adjuster&gt; modifies the color in some way, passing a new base color to the next &lt;color-adjuster&gt; in the list. The same &lt;color-adjuster&gt; can be specified more than once in the list, such as color(red s(- 10%) s(- 10%)); each instance just modifies the color appropriately (in this case, producing hsl(0deg, 80%, 50%)).
</p>


<p>
`color-adjuster$t は、その効果により，~~何種類かに~~分類される。
それらは、次~節にて定義される。
◎
There are several classes of &lt;color-adjuster&gt;s with various effects, defined in the following sections.
</p>


<p>
`color-mod$f 関数の算出値は、 `基底~色^V にすべての
`color-adjuster$t を適用して生産された色になる。
◎
The computed value of a color-mod() function is the color produced by applying all the &lt;color-adjuster&gt;s to the base color.
</p>


<p class="note">注記：
~~乗算記号 `*^css は
`lightness(*150%)^fv
の様に~spaceを挟まずに指定できるが、加減算の場合の符号
`+^css／`-^css
の後には~spaceを挟ま~MUST
— さもなければ、符号は CSS 構文解析器により数の一部と解釈されるので。
◎
Note: While scaling can be specified without any spaces, like lightness(*150%), adding/subtracting must be done with spaces after the +/-, or else the +/- will be interpreted as part of the number by the CSS parser.
</p>

<p>
`無彩色$は~~固有の色相を持たないので、色を`無彩色$にしないような
`color-adjuster$t （ `s(50%)^fv など ）は、その調整子の定義に述べられるような，`無彩色$に対する特別な挙動を持つ。
しかしながら、単独の `color-mod$f 関数の中で，有彩色の `基底~色^V が調整子により`無彩色$にされてから, 再び有彩色にする調整子が後続していることもあり得る。
そのような下では、【特別に挙動することなく】色相が維持される方が，作者の期待に沿うであろう。
◎
An achromatic color doesn’t have a unique hue, so some &lt;color-adjuster&gt;s that would make the color no longer achromatic (such as s(50%)) have special behavior for achromatic colors, as described in each adjuster’s description. However, it is possible for, within the space of a single color-mod() function, for the base color to be chromatic, an adjuster to make it achromatic, and a following adjuster to make it chromatic again, with an author having the reasonable expectation that the hue is maintained.
</p>

<p>
これを許容するため、
`color-mod$f 関数の各 `color-adjuster$t を評価する間の途中の色~情報として（ CSS 色において通例の） 4-tuple［
~red, ~green, ~blue, ~alpha
］に加えて，
`色相~角度@
も格納され~MUST
— この色相~角度は、何らかの［
色に対して／演算の後に
］は，
`~null@
にもなり得る。
◎
To allow this, during the evaluation of a color-mod() function’s &lt;color-adjuster&gt;s, rather than storing intermediate colors as a 4-tuple of red, green, blue, and alpha, as usual for CSS colors, intermediate colors must be stored as a 5-tuple of red, green, blue, alpha, and hue angle, where the hue angle may be null for some colors and after some operations.
</p>


<div >
<p>
演算が
~HSL／~HWB
空間~内の`無彩色$を解釈するときは、その色の`色相~角度$が：
</p>
<ul>
	<li>
非`~null$の場合：
演算のために その無彩色を ~HSL／~HWB に解釈する際には、その色相~角度が利用され~MUST。
</li>
	<li>
`~null$の場合：
それを取扱う方法は，個々の演算にて定義される。
</li>
</ul>

◎
Whenever an operation interprets an achromatic color in HSL or HWB space, if the color has a non-null hue angle, that hue must be used for the color’s HSL/HWB interpretation. (Individual operations define how to handle null hue angles.)
</div>


<p>
`基底~色^V が`無彩色$の場合の初期時の`色相~角度$は、`~null$とする。
◎
If the base color is achromatic, the hue angle is initially null.
</p>

<div class="example">
<p>
例えば、
`基底~色^V を明るくして鮮やかにする `color-mod$f 関数があるとき：
◎
For example, here’s a possible color-mod() function that lightens and brightens the base color:
</p>

<pre class="lang-css">
color( %X w(+ 20%) s(+ 20%))
</pre>

<p>
%X が `blue$v の様な色であれば、これは期待されるように働く
—
各~演算の後も，色は依然として有彩色（結果の値は `#33f^v になる）。
◎
If X is a color like blue, this works in the expected way - after each operation, the color is still chromatic (and the return value is #33f).
</p>

<p>
一方で、 %X が `#787^v の様な~greenがかった~grayである場合（~HWB では `hwb(120deg, 44%, 50%)^fv
で表現される）、最初の演算が~whiteと~blackの和を `100%^v を超える値にするので，それを`無彩色$ ~gray（ `#8f8f8f^v ）にする。
◎
On the other hand, if X is a greenish gray like #787, which is represented in HWB as hwb(120deg, 44%, 50%), the first operation will boost the sum of white and black to greater than 100%, making it an achromatic gray (#8f8f8f, to be specific).
</p>

<p>
しかしながら、 `color-mod$f 関数は，元の色の色相 120° を記憶するので、 2 番目の演算が色の彩度を上げた結果は，再び~greenがかった~grayになる（
`hsl(120deg, 20%, 56%)^fv
— 意図された，元の色より少し明るい, 鮮やかな）。
◎
However, the color-mod() function remembers that the hue of the color was originally 120deg, so when the second operation saturates the color, it will result in a greenish-gray again (hsl(120deg, 20%, 56%), slightly lighter and brighter than the original color, which is what was intended).
</p>
</div>


<div class="issue">
<p>
更なる可能性：
◎
More possibilities:
</p>

<ul>
	<li>
~muted（ “muted” ）色。
Closure CSS Compiler 【？】は、~muted色を前景~色と背景~色から算出する：
前景の色相を取込んで,
前景の彩度をいくぶん落として,
前景と背景の明度を平均する。
更なる利用事例と，これを利用する視覚的~例を求む。
◎
Muted colors. Closure CSS Compiler computes a muted color from a FG and BG color: take the FG’s hue, drop the FG saturation some amount, average FG and BG lightness. I want more use-cases and visual examples of this being used.
</li>

	<li>
色の反転法。
どんな利用事例がある？
単に［
~red, ~green, ~blue
］各~channelを反転するだけで済むのか？
`contrast$f 調整子は、~~人々が色を反転したいと~~考えるとき，本当に~~意図しているものなのか？
◎
Inverting a color. Use-cases? Is this just done by inverting the r/g/b channels? Is the contrast() adjuster what people really mean when they ask for invert?
</li>

	<li>
暖色化-／寒色化-。
どう定義する？
何が暖色とされる？ — ~red？~yellow？
何が寒色とされる？ — ~blue？~green？
◎
Warmer/cooler. How to define? What’s warmer, red or yellow? What’s cooler, blue or green?
</li>

</ul>

</div>

		<section id="rgba-adjusters">
<h3 title="RGBA Adjustment">11.1. ~RGBAの調整</h3>

<p>
基本的な `color-adjuster$t のほとんどは、色の個々の［
~red／~green／~blue／~alpha
］~channelを直接的に改変して改める。
◎
The most basic set of &lt;color-adjuster&gt;s modify the color’s channels directly, altering the amount of red, green, blue, or alpha in the color.
</p>


<dl>
	<dt class="prod">[red( | green( | blue( | alpha( | a(] ['+' | '-']? [`number$t | `percentage$t] )</dt>
	<dt class="prod">[red( | green( | blue( | alpha( | a(] * `percentage$t )</dt>

	<dd>
`基底~色^V の［
~red／~blue／~green／~alpha
］いずれかの~channelを設定-あるいは調整する。
◎
Sets or adjust the red, blue, green, or alpha channels of the base color.
</dd>
	<dd>
演算子がない場合、所与の~channelは，所与の値に設定される。
◎
If there is no operator, the given channel is set to the given value.
</dd>
	<dd>
演算子が［
`+^css／`-^css
］ならば、所与の~channelは，所与の値に合致する型（ `number$t または `percentage$t ）に解釈した下で，所与の値で［
増分-／減分-
］される。
◎
If the operator is + or -, the given channel is interpreted as the matching type (&lt;number&gt; or &lt;percentage&gt;) and then incremented or decremented by the given value.
</dd>
	<dd>
演算子 `*^css は、所与の~channelを所与の値で乗算する。
◎
If the operator is *, the given channel is multipled by the given value.
</dd>

	<dt class="prod">rgb( ['+' | '-']? [`number$t | `percentage$t]{3} )</dt>
	<dd>
所与の三~値は順に `基底~色^V の［
~red, ~green, ~blue
］~channelを設定-あるいは調整する。
各~channelは前項と同様に，所与の値で［
増分-／減分-
］される。
◎
Adjusts the base color in the red, green, and blue channels simultaneously. All three channels are interpreted as the matching type (&lt;number&gt; or &lt;percentage&gt;) and then incremented or decremented by the given values, with the first value adjusting the red channel, the second value adjusting the green channel, and the third value adjusting the blue channel.
</dd>

	<dt class="prod">rgb( ['+' | '-'] `hash-token$t )</dt>
	<dd>
三つの~channelへの調整は、
~hex形式で指定されることを除いて，前項と~~同じ。
`hash-token$t
は `~hex色$として解釈した下で、その［
~red, ~green, ~blue
］各~channelが `基底~色^V に対する調整として適用される。
◎
Identical to the previous clause, except that the adjustments to the three channels are specified in hexadecimal format; the &lt;hash-token&gt; is interpreted as a hex color, then the red, green, and blue channels of the color are applied as adjustments to the base color.
</dd>
	<dd class="example">
例えば，
`color(red rgb(+ #004400))^fv
ならば、
`基底~色^V は `red$v （ `#ff0000^v ）であり，その［
~red, ~blue
］~channelは全く調整されない（それらの~channelは所与の色においては，いずれも 0 ）一方で、~green~channelは 44（~hex）だけ増加され，結果の最終的な色は `#ff4400^v になる。
◎
For example, in color(red rgb(+ #004400)), the base color is red (#ff0000). The red and blue channels aren’t adjusted at all (those channels in the given color are both 0), and the green channel is increased by 4416, resulting in a final color of #ff4400.
</dd>

	<dt class="prod">rgb( * `percentage$t )</dt>
	<dd>
`基底~色^V の［
~red, ~green, ~blue
］~channelは、所与の値で乗算される。
◎
The red, green, and blue channels of the base color are multiplied by the given value.
</dd>

</dl>

<p>
`alpha^f ／ `a^f を除いて
この節におけるすべての `color-adjuster$t は、結果の色が`無彩色$になる場合には，`色相~角度$も`~null$に設定する。
◎
All &lt;color-adjuster&gt;s in this section, except for alpha() and a(), set the hue angle to null if the resulting color is achromatic.
</p>


		</section>
		<section id="hsl-hwb-adjusters">
<h3 title="HSL/HWB Adjustment">11.2. ~HSL／~HWBの調整</h3>


<p>
`hsl$f ／ `hwb$f
関数は、人にとって容易かつ直感的になるよう意図されており，色を数により指定する別法を提供する。
`color-mod$f 関数は、色をこれらによる “仮想の~channel” 内で調整できるようにする。
◎
The hsl() and hwb() functions provide alternative ways to specify colors numerically, intended to be easier and more intuitive for humans. Similarly, the color-mod() function allows a color to be adjusted in these "virtual channels".
</p>


<dl>

	<dt class="prod">[hue( | h(] ['+' | '-' | *]? `angle$t )</dt>
	<dd>
`基底~色^V を~HSL色として解釈する下で，
`基底~色^V の色相を設定-／調整する。
◎
Sets or adjusts the hue of the base color, when base color is interpreted as an HSL color.
</dd>
	<dd>
演算子なしの場合、色相は，その前の`色相~角度$に関わらず所与の値に設定される。
◎
If there is no operator, the hue is set to the given value, regardless of what the hue angle was previously.
</dd>
	<dd>
他の場合、色相は，所与の値により適切に［
増分-／減分-
］される。
`色相~角度$が`~null$の場合、調整子は何もしない。
◎
Otherwise, the hue is incremented or decremented, as appropriate, by the given value. If the hue angle is null, the adjuster instead does nothing.
</dd>

	<dt class="prod">[saturation( | s(] ['+' | '-' | *]? `percentage$t )</dt>
	<dt class="prod">[lightness( | l(] ['+' | '-' | *]? `percentage$t )</dt>
	<dt class="prod">[whiteness( | w(] ['+' | '-' | *]? `percentage$t )</dt>
	<dt class="prod">[blackness( | b(] ['+' | '-' | *]? `percentage$t )</dt>
	<dd>
順に， `基底~色^V の［
彩度, 明度, 白味, 黒味
］を設定-／調整する
— `基底~色^V を
~HSL, ~HWB
のうち適切な方による色として解釈する下で。
◎
Sets or adjusts the saturation, lightness, whiteness, or blackness of the base color, when base color is interpreted as an HSL or HWB color, as appropriate.
</dd>
	<dd>
演算子がない場合、所与の~channelは、所与の値に設定される。
◎
If there is no operator, the given channel is set to the given value.
</dd>
	<dd>
演算子［
`+^css ／ `-^css
］は、所与の~channelを所与の値で［
増分-／減分-
］する。
◎
If the operator is + or -, the given channel is incremented or decremented by the given value.
</dd>
	<dd>
演算子 `*^css は、所与の~channelを所与の値で乗算する。
◎
If the operator is *, the given channel is multiplied by the given value.
</dd>
	<dd>
<p>
`基底~色^V の`色相~角度$が`~null$の場合：
◎
↓</p>

<ul>
	<li>
演算
`s^f ／ `saturation^f
は、何もしない
— 調整子が彩度を増分させるものであっても。
◎
If the hue angle is null, the operation is s() or saturation(), and the adjuster would make the saturation greater than 0%, it instead does nothing.
</li>
	<li>
演算
`w^f ／ `white^f ／ `b^f ／ `black^f
は、結果の［
白味と黒味の和
］が 100% を下回ったなら、和が 100% に等しくなるように，もう片方の~HWB~channel【白味を調整したなら黒味】
も調整する。
すなわち、 `color(white w(- 20%))^fv は，
`hwb(0, 80%, 20%)^fv と同じ色を表現することになる）。
◎
If the hue angle is null, the operation is w(), white(), b(), or black(), and the adjuster would make the sum of whiteness and blackness less than 100%, it additionally adjusts the opposite HWB channel to make the sum equal to 100%. (That is, color(white w(- 20%)) would represent the same color as hwb(0, 80%, 20%).)
</li>
</ul>

	</dd>
</dl>

		</section>
		<section id="tint-shade-adjusters">
<h3 title="Tints and Shades: the tint and shade adjusters">11.3. 明度の上げ／下げ： `tint^f ／ `shade^f 調整子</h3>

<p>
`color-mod$f 関数は ~HWB色を調整できるようにするが、~HWBの定義の~~特質から，単に色の明度を変えた色を作るのは困難である。
［
`tint^v ／ `shade^v
］調整子は、単純に `基底~色^V を［
~white／~black
］と混合することにより，これを可能にする。
◎
While the color-mod() function does allow HWB adjustment of colors, the peculiarities of how HWB is defined make it more difficult than it should be to just define a lighter or darker version of a color. The tint and shade adjusters fix this, by simply mixing the base color with white or black.
</p>


<dl>

	<dt class="prod">tint( `percentage$t )</dt>
	<dd>
`基底~色^V と純~whiteを混合して，より明るい~versionを生産する。
◎
Mixes the base color with pure white to produce a lighter version of the base color.
</dd>
	<dd>
`0%^v 〜 `100%^v の範囲~外の
`percentage$t は構文~errorであり、関数は無効になる。
◎
Specifying a &lt;percentage&gt; less than 0% or greater than 100% is a syntax error, and makes the function invalid.
</dd>
	<dd>
`基底~色^V の［
~red, ~green, ~blue
］各~channelと純~white (
`rgb(255,255,255)^fv
) の［
~red, ~green, ~blue
］~channelとで線形に, かつ［
`0%^v ／ `100%^v
］は［
`基底~色^V ／純~white
］を返すように，補間する。
◎
Linearly interpolate the red, green, and blue channels of the base color with the red, green, and blue channels of pure white (rgb(255,255,255)), where 0% returns the base color and 100% returns pure white.
</dd>
	<dd class="note">注記：
`tint(<var>X</var>%)^fv は `blend(white <var>X</var>% rgb)^fv と~~同じである。
◎
Note: tint(X%) is identical to blend(white X% rgb).
</dd>

	<dt class="prod">shade( `percentage$t )</dt>
	<dd>
`基底~色^V と純~blackを混合して，
`基底~色^V の暗くした~versionを生産する。
◎
Mixes the base color with pure black to produce a darker version of the base color.
</dd>
	<dd>
`基底~色^V は純~black（ `rgb(0,0,0)^fv ）と混合されることを除いて，前項と~~同じになる。
◎
Identical to the previous clause, except the base color is mixed with pure black (rgb(0,0,0)) rather than pure white.
</dd>

</dl>


		</section>
		<section id="blend-adjuster">
<h3 title="Color Blending: the blend and blenda adjusters">11.4. 色の混色法： `blend^f, `blenda^f 調整子</h3>

<p>

`blend^f 調整子は、
`tint^f ／ `shade^f 調整子を一般化して，
`基底~色^V を任意の色と混合できるようにしたものである。
◎
The tint() and shade() adjusters are common cases of the more general blend() adjuster, which mixes the base color with an arbitrary color.
</p>


<dl>
	<dt class="prod">blend( `color$t `percentage$t [rgb | hsl | hwb]? )</dt>
	<dd>
`基底~色^V と所与の色を混合して，
`基底~色^V との中間~色を生産する。
◎
Mixes the base color with the given color to produce an intermediate color.
</dd>
	<dd>
`0%^v 〜 `100%^v の範囲~外の
`percentage$t は構文~errorであり、関数は無効になる。
◎
Specifying a &lt;percentage&gt; less than 0% or greater than 100% is a syntax error, and makes the function invalid.
</dd>
	<dd>
~~最後の引数は
色をどの色~空間で混色するかを指定する。
指定されなかった場合の既定は `rgb^v 。
`基底~色^V と所与の色は、両者とも
所与の色~空間の色として解釈した下で、各~成分が混色される。
◎
The final argument specifies which color space to blend the colors in, defaulting to rgb if not specified. Both the base color and the given color are interpreted as colors in the given color space, then the components are blended.
</dd>
	<dd class="example">
<p>
例えば、
`color(yellow blend(blue 50%))^fv
は，~yellow（ `#ffff00^v ）と~blue（ `#0000ff^v ）を等しく混色する。
結果は~~中間の~gray `#808080^v になる。
◎
For example, color(yellow blend(blue 50%)) blends yellow (#ffff00) with blue (#0000ff) equally, resulting in #808080, a medium gray.
</p>

<p>
一方で、
`color(yellow blend(blue 50% hsl))^fv
は，上と同じ色を~HSL空間で混色する。
~yellowは `hsl(60, 100%, 50%)^fv,
~blueは `hsl(240, 100%, 50%)^fv
なので、その結果は，~greenの 最大彩度の濃淡
`hsl(150, 100%, 50%)^fv
になる。
◎
On the other hand, color(yellow blend(blue 50% hsl)) blends the same colors in HSL space, where yellow is hsl(60, 100%, 50%) and blue is hsl(240, 100%, 50%), which results in hsl(150, 100%, 50%), a fully-saturated shade of green.
</p>
	</dd>
	<dd>
結果の色を決定するときは、
`基底~色^V と所与の色を適切な色~空間（~RGB／~HSL／~HWB）に解釈した下で、各~色の各~channelを 所与の `percentage$t に従って，線形に, かつ［
`0%^v からは指定された `color$t が生産され，
`100%^v からは `基底~色^V が生産される
］ように補間する。
◎
To determine the resulting color, interpret the base color and the given color in the appropriate color space (RGB, HSL, or HWB). Linearly interpolate each of the channels of the colors according to the given &lt;percentage&gt;, where 0% produces the specified &lt;color&gt; and 100% produces the base color.
</dd>
	<dd>
色~空間が
`hsl^v ／ `hwb^v
の場合、色相~channelは，［
時計回り, 反時計回り
］のうち二つの`色相~角度$の“経路” がより短いになる方で補間する。
二つの色相~角度が、色相環の（ 180° 離れた）ちょうど反対~側に位置する場合は、時計回りの経路をとる。
◎
If the color space is hsl or hwb, interpolate the hue channel either clockwise or counterclockwise, whichever results in a shorter "path" between the two hue angles. If the two hue angles are on opposite sides of the hue circle (separated by 180 degrees), take the clockwise path.
</dd>
	<dd>
いずれか一方だけ色の`色相~角度$が`~null$の場合、この調整子の目的0においては、その~null色相~角度を，もう片方の`色相~角度$と等しいものと扱う。
両者とも色相~角度が`~null$の場合、結果の色の色相~角度も`~null$になる。
◎
If the hue angle is null for one of the colors but not the other, treat the null hue angle as being equal to the non-null hue angle for the purpose of this adjuster. If both hue angles are null, the resulting color’s hue angle is null as well.
</dd>
	<dd class="note">注記：
二つの色相~角度が 180° ~~離れているときに経路を時計回りにとっているのは、単に一義的にするためであり，恣意的である。
反時計回りの挙動は、一方の色の色相~角度を，欲する方向へほんの少し調整すれば得られる。
◎
Note: The choice of how to transition when the difference is 180deg is arbitrary, and was chosen merely to provide an unambiguous answer. To achieve counter-clockwise behavior, adjust either color’s hue angle by a small amount toward the desired direction.
</dd>
	<dd class="example">
例えば、
`yellow$v （色相~角度 60°）に
`purple$v （色相~角度 300°）を 50% 混色した結果は、
`red$v （色相~角度 0°）になり，
`cyan$v （色相~角度 180°）にはならない。
二つの色の距離は、反時計回りでは 120° になる一方，時計回りに行くと 240° になるので。
◎
For example, blending yellow (hue angle 60deg) with 50% purple (hue angle 300deg) results in red (hue angle 0deg), not cyan (hue angle 180deg), even though 60*50% + 300*50% == 180, because the distance between the two colors when moving counter-clockwise is only 120 degrees, as opposed to 240 degrees when going clockwise.
</dd>

	<dt class="prod">blenda( `color$t `percentage$t [rgb | hsl | hwb]? )</dt>
	<dd>
~alpha~channelについても調整を加えることを除いて，前項と~~同じになる（ `blend^f は単に `基底~色^V の~alpha~channelはそのままにする）。
◎
Identical to the previous clause, except it pays attention to the alpha channel of the two colors (blend() just preserves the alpha channel of the base color).
</dd>
	<dd>
<p>
結果の色は、以下の様に計算される：
</p>

		<ol>
			<li>
%color ~LET `color$t に指定された色
</li>
			<li>
%w ~LET
`percentage$t に指定された百分率~値を，［
`0%^v → −1, `100%^v → 1
］に対応するように，範囲 −1 〜 1 に換算した結果
◎
↓</li>
			<li>
%a ~LET
( ( `基底~色^V の~alpha ) − ( %color の~alpha ) )
— ここで、 ~alphaは範囲 0 〜 1 をとるものと見なす（ %a の範囲は −1 〜 1 になる）
◎
Let w be the specified &lt;percentage&gt;, rescaled to the range [-1,1], where 0% maps to -1 and 100% maps to 1. Let a be the difference of the alpha channels of the base color and the specified &lt;color&gt;, also rescaled to the range [-1,1], where -100% (0% base color alpha and 100% specified color alpha) maps to -1 and 100% maps to 1.
</li>
			<li>
%w ~SET
( %w × %a ~EQ −1 )
ならば %w ／
他の場合は
( (%w + %a) ÷ (1 + %w × %a) )
◎
If w * a == -1, let new weight equal w. Otherwise, let new weight equal (w + a) / (1 + w*a).
</li>
			<li>
%w ~SET %w を［
−1 → `0%^v, 1 → `100%^v
］に対応するように，範囲 0% 〜 100% の百分率に換算した結果
◎
↓</li>
			<li>
同じ入力で `blend^f が指定されていたかのように，ただし
`percentage$t には %w を利用して、結果の色を計算する
◎
↓</li>
			<li>
結果の色の~alpha~channelは、
`基底~色^V と %color
の~alpha~channelの平均に設定する。
◎
Reinterpret new weight as a percentage in the range [0%, 100%], where -1 maps to 0% and 1 maps to 100%. Calculate the result color as if blend() had been specified, using the new weight percentage instead of the specified &lt;percentage&gt;, and set the alpha channel of the result color to the average of the alpha channels of the base color and the specified &lt;color&gt;.
</li>
		</ol>
	</dd>
	<dd class="issue">
これは、合成法と類似するように，二つの色を~alphaも織り込んだ上で混色する。
もっと良い公式があるだろうか？
現在のものは、良い結果が得られるように~~経験的に決定されているが、それを裏付ける理論は~~存在しない。
◎
This blends the two colors in a way that pays attention to alpha, similar to how compositing does. Is there a better formula? The current one was determined empirically to give good results, but isn’t motivated by any theory.
</dd>

</dl>


<p class="issue">
既定を入替えるべきか？
`blend^f の方が~alpha混色も行うことにして，別の名前のもの（あるいは別の~parameterもありかもしれない）が、現在の `blend^f のように~alphaを無視することにする様な？
<a href="~COMPOSITING">CSS 合成法と混色法~module</a>
による定義と照らし合せる必要がある。
◎
Should we swap the defaults, so blend() does the alpha blending, and another name (or maybe another parameter) ignores alpha like blend() currently does? Check with definitions in CSS compositing and blending module.
</p>


		</section>
		<section id="contrast-adjuster">
<h3 title="Guaranteeing Adequate Contrast: the contrast adjuster">11.5. 必要十分な~contrastを保証する： `contrast^f 調整子</h3>

<p>
前景~色と背景~色との十分な~contrastを保証することは，重要であるが、仮に
“適切な~contrast” の数学的な定義を知り得たとしても，任意に与えられた二つの色の~contrastが十分~良いかどうかを，計算して明らかにすることは自明でない。
<!-- 
http://dev.w3.org/fxtf/filters/#funcdef-contrast">contrast()</a>？
-->
`contrast^f 調整子は、 `基底~色^V との~contrastが
— ~access容易性~指針 `WCAG20$r を充足させる程に —
~~十分にとられた色を自動的に算出して，これを容易にする。
◎
Guaranteeing that foreground and background colors contrast sufficiently is important, but even if one knows the mathematical definition of "appropriate contrast", it’s not trivial to calculate and figure out whether two arbitrary colors are good enough. The contrast() adjuster makes this easy, automatically computing a color that is sufficiently contrasting with the base color to satisfy accessibility guidelines.
</p>


<dl>
	<dt class="prod">contrast( `percentage$t? )</dt>
	<dd>
<a href="~TR/WCAG/#visual-audio-contrast-contrast">WCAG 2.0 Guideline 1.4.3</a>
にて与えられる
“~contrast” の定義に従って、
`基底~色^V との~contrastを~access容易性~指針を充足するに十分にとるような色を見出す。
◎
Finds a color that contrasts with the base color suffficiently to satisfy accessibility guidelines, using the definition of "contrast" given by WCAG 2.0 Guideline 1.4.3.
</dd>
	<dd>
<p>
`percentage$t は
`基底~色^V
と返される色との間に欲される類似度を指定する。
`0%^v は `最小~contrast色^V
（~contrastを十分にとりつつ `基底~色^V に最も近い色）を返し，
`100%^v は `最大~contrast色^V
（~white, ~blackのうち， `基底~色^V との~contrastが高くなる方）を返す。
`0%^v 〜 `100%^v の範囲~外の値が指定された場合、構文~errorであり無効になる。
省略された場合の既定の `percentage$t は `100%^v 。
◎
The &lt;percentage&gt; specifies the desired similarity between the base color and the returned color. 0% will return the minimum-contrast color (the closest color to the base color that still contrasts sufficiently), while 100% will return the maximum-contrast color (white or black, whichever contrasts the base color more) Specifying a value less than 0% or greater than 100% is invalid and a syntax error. If omitted, the &lt;percentage&gt; defaults to 100%.
</p>


		<ol>
			<li>

<p>
`最大~contrast色^V は，［
`基底~色^V の`輝度$が .5 より小さいならば `hwb(<var>X</var>, 100%, 0%)^fv ／
他の場合は `hwb(<var>X</var>, 0%, 100%)^fv
］
— ここで， %X は `基底~色^V の`色相~角度$。
◎
Compute the luminance of the base color. If it’s less than .5, the maximum-contrast color is hwb(X, 100%, 0%), where X is the hue angle of the base color. Otherwise, the maximum-contrast color is hwb(X, 0%, 100%), where X is the hue angle of the base color.
</p>

<p class="note">注記：
言い換えれば、 `最大~contrast色^V は~whiteか~blackになるが，次~段の線形~補間における色相も正しく設定されるようにする。
◎
Note: In other words, the maximum-contrast color is either white or black, but with the hue set up correctly for the next step’s linear interpolation.
</p>

			</li>
			<li>
<p>
［
`基底~色^V と `最大~contrast色^V とを，~HWB空間において線形に（ `blend^f 調整子~風に）補間して得られる色
］のうち，［
`基底~色^V との`~contrast比$が最も小さく, かつ 4.5 以上になる
］ような色を見出す。
これが、 `最小~contrast色^V になる。
~contrast比 4.5 以上にする色がない場合、即時に `最大~contrast色^V を返す。
◎
Looking only at colors that are linear interpolations in HWB space (a la the blend() adjuster) between the base color and the maximum-contrast color, find the color with the smallest contrast ratio with the base color that is greater than 4.5. This is the minimum-contrast color. If there is no color with contrast ratio greather than 4.5, return the maximum-contrast color immediately.
</p>

<p class="note">注記：
4.5 は、 WCAG の Level AA の~contrastに要求される~contrast比である。
◎
Note: 4.5 is the contrast ratio required by WCAG for Level AA contrast.
</p>

<p class="note">注記：
この手法を利用するとき、~contrast比は，
`最大~contrast色^V から `基底~色^V へ単調非増加に推移するので、
`最小~contrast色^V は，単純な二分探索を少し反復すれば見つかる。
◎
Note: Using this method, the contrast ratio will be monotonically non-increasing as you go from the maximum-contrast color to the base color, so a simple binary search will identify the minimum-contrast color in a small number of iterations.
</p>

			</li>
			<li>
<p>
次が指定されていたかのように、
`最小~contrast色^V と `最大~contrast色^V を指定された `percentage$t で混色した結果の色を返す：
</p>

<pre class="css">
color( `最大~contrast色^V blend( `最小~contrast色^V `percentage$t `hwb^v))
</pre>

◎
Blend the minimum-contrast color and maximum-contrast color according to the specified &lt;percentage&gt;, as if ''color(maximum-contrast color blend(minimum-contrast color &lt;percentage&gt; hwb))'' were specified. Return the blended color.

			</li>
		</ol>
	</dd>

</dl>

<p>
色の
`輝度@
を算出するときは：
◎
To compute the luminance of a color:
</p>

<ol>

	<li>
［
%R, %G, %B
］を，順に色の［
~red, ~green, ~blue
］各~channelを
範囲 [0,1] に換算した結果とする。
◎
Scale the red, green, and blue channels of the color to the range [0,1].
</li>

	<li>
<p>
［
%R, %G, %B
］それぞれに対し,
その値 V を［
V ≦ 0.03928 ならば ( V ÷ 12.92 ) ／
他の場合
( (( V + 0.055) / 1.055) ^ 2.4 )
］にする。
◎
For each channel, if the channel’s value is less than or equal to 0.03928, set the channel’s value to channel / 12.92. Otherwise, set the channel’s value to ((channel + 0.055) / 1.055) ^ 2.4.
</p>

<p class="note">注記：
これは、~channelの値と, 色を表現するために要する光~量との関係が線形に近似するように，~sRGB色域の対数的~power~scalingの逆変換を行う。
◎
Note: This reverses the logarithmic power scaling of the sRGB gamut, so the value of the channel is approximately linear related to the amount of light required to represent it.
</p>
	</li>

	<li>
結果の輝度は、
( 0.2126 × %R + 0.7152 × %G + 0.0722 × %B )
で与えられる。
◎
The luminance is:
◎
0.2126*R + 0.7152*G + 0.0722*B
◎
where R, G, and B are the adjusted red, green, and blue channels from the previous step.
</li>

</ol>

<p class="note">注記：
~sRGB色域の色に対しては、その輝度は，
0 （~black） 〜 1 （~white）の範囲に入る。
◎
Note: The luminance of a color within the sRGB gamut is contained within the range [0,1], where black is 0 and white is 1.
</p>

<div>
<p>
二つの色の
`~contrast比@
は、それらの色の`輝度$を %L1, %L2 とするとき、次の式で与えられる：
</p>

<pre>
( (max(%L1, %L2)  + 0.05) ÷ ( min(%L1, %L2) + 0.05) )
</pre>

◎
To compute the contrast ratio of two colors:
◎
Compute the luminance of both colors.
◎
The contrast ratio is:
◎
(L1 + 0.05) / (L2 + 0.05)
◎
where L1 is the larger of the two luminances, and L2 is the smaller.
</div>


<p class="note">注記：
二つの色の~contrast比
は、 0 （同~色） 〜 21 （~black対~white）の範囲に入る。
◎
Note: The contrast ratio of two colors is contained within the range [1,21], where two identical colors are 1 and the ratio of white and black is 21.
</p>

		</section>
	</section>
	<section id="transparency">
<h2 title="Transparency: the opacity property">12. 透明度： `opacity^p ~prop</h2>

<p>
不透明度は、後処理~演算と捉えることができる。
概念的には、要素（その子孫も含めて）が~RGBA~offscreen画像に描画されてから，不透明度の設定ingが その描画を 現在の合成先へ混色する方法を指定する。
詳細は
<a href="#alpha">単純~alpha合成法</a>
を見よ。
◎
Opacity can be thought of as a postprocessing operation. Conceptually, after the element (including its descendants) is rendered into an RGBA offscreen image, the opacity setting specifies how to blend the offscreen rendering into the current composite rendering. See simple alpha compositing for details.
</p>


`●名^ `opacity@p
`●値^ `alpha-value$t
`●初^ `1^v
`●適^ すべての要素
`●継^ されない
`●百^ 利用不可
`●媒^ 視覚的
`●算^
指定値を範囲 0 〜 1 に切詰めた結果
◎
The specified value, clamped to the range [0,1].
`●ア^ 不可
`●表終^


<dl>
	<dt>`alpha-value$t</dt>
	<dd>
要素に適用される不透明度。
結果の不透明度が 特定0の色とではなく，要素~全体に適用されることを除いて、
`rgba$f におけるその定義と~~同じに解釈される。
◎
The opacity to be applied to the element. It is interpreted identically to its definition in rgba(), except that the resulting opacity is applied to the entire element, rather than a particular color.
</dd>

</dl>


<p>
`opacity$p ~propは、指定された不透明度を，要素にその内容も含めて <em>全体として</em> 適用する。
各~子孫ごとに適用するのでなく。
これは例えば、要素の `opacity$p が 1 より小さいときでも，要素の不透明な子が要素の背景を塞ぐ部分は そうあり続けるが、全体としての要素とその子は，それら自身を透かして下層の頁を示すことになることを意味する。
◎
The opacity property applies the specified opacity to the element as a whole, including its contents, rather than applying it to each descendant individually. This means that, for example, an opaque child occluding part of the element’s background will continue to do so even when opacity is less than 1, but the element and child as a whole will show the underlying page through themselves.
</p>


<p>
`opacity$p の値が 1 より小さい場合、要素は，その子たちに対する`積層文脈$を形成する。
これは、z-順序により，要素の 外側と内側の内容が互いに多層化されることは なくなることを意味する。
要素~上の `z-index$p ~propに対する `auto^v 値は， `0^v に扱われる【算出値として？】
。
<!-- ＊？
is in a context where...
 -->
積層文脈についての更なる情報は、
`CSS21$r の［
<a href="~CSS2VISUREN#layers">多層化による呈示</a>,
<a href="~TR/CSS21/zindex.html">付録 E</a>
］を見よ。
この段落の規則は、 SVG 要素には適用されない
— SVG は自前の
<a href="~TR/SVG11/render.html">描画~model</a>
を備えているので（ `SVG11$r, 3 章）。
◎
If opacity has a value less than 1, the element forms a stacking context for its children. This means that any content outside of it cannot be layered in z-order between pieces of content inside of it, and vice versa. If the element is in a context where the z-index property applies, the auto value is treated as 0 for the element. See section 9.9 and Appendix E of [CSS21] for more information on stacking contexts. The rules in this paragraph do not apply to SVG elements, since SVG has its own rendering model ([SVG11], Chapter 3).
</p>


		<section id="alpha">
<h3 title="Simple alpha compositing">12.1. 単純~alpha合成法</h3>

<p>
色を描くとき、実装は，~alphaを
`SVG11$r による
<a href="~TR/SVG/masking.html#SimpleAlphaBlending">単純~alpha合成法</a>
の規則に則って取扱わ~MUST（その節にて示される
`color-interpolation$p ／ `color-rendering$p
~propが［
実装されていない／適用されない
］場合、実装は，それらが初期値をとっていたかのように動作し~MUST。）
◎
When drawing, implementations must handle alpha according to the rules in Section 14.2 Simple alpha compositing of [SVG11]. (If the color-interpolation or color-rendering properties mentioned in that section are not implemented or do not apply, implementations must act as though they have their initial values.)
</p>


		</section>
	</section>
	<section id="color-adjust">
<h2 title="Preserving Colors in Different-Capability Devices: the color-adjust property">13. 能力が様々な機器~間での色の保全法： `color-adjust^p ~prop</h2>

<p>
殆どの~monitor上では、作者が何~色を選ぼうが，機器がどう描画するかに関して，有意な相違が生じることはない。
文書の背景が~white／~blackどちらであろうが，表示する容易さは ほぼ等しい。
◎
On most monitors, the color choices that authors make have no significant difference in terms of how the device performs; displaying a document with a white background or a black background is approximately equally easy.
</p>

<p>
しかしながら、この前提が成り立たないような機器も中にはあり，制限があったり, 品質が変わることがある。
例えば、印刷機は，白い紙に印刷する傾向にあるので、白い背景の文書は，さして~inkを費やすことなく，その背景~上に描く一方で、背景が黒い文書は，背景~色を埋めるために多量の~inkを費やす。
これは、印刷費を跳ね上げるのは言うまでもなく，紙に有害な物理的~効果をもたらすこともある。
~text色を黒にするか暗い~grayにするか のような，さほど違いはない場合でも、印刷~時には全く異なることはある
— 利用する~inkを単独の黒~inkから［
~cyan, ~magenta, ~yellow
］~inkの混合に切替えるので、~inkを余計に費やしたり, 解像度が低下する。
◎
However, some devices have limitations and other qualities that make this assumption untrue. For example, printers tend to print on white paper; a document with a white background thus has to spend no ink on drawing that background, while a document with a black background will have to expend a large amount of ink filling in the background color. This tends to look fairly bad, and sometimes has deleterious physical effects on the paper, not to mention the vastly increased printing cost from expending the extra ink. Even fairly small differences, such as coloring text black versus dark gray, can be quite different when printing, as it switches from using a single black ink to a mixture of cyan, magenta, and yellow ink, resulting in higher ink usage and lower resolution.
</p>


<p>
その結果、状況によっては、~UAは，特定0の文脈~下では，作者が指定した~styleを改めることもある
— それらを出力~機器に より適切に調整して，利用者が選好すると見做されるものに順応するように。
しかしながら、一部の事例では、文書は，利用者に快適になるように，重要かつ熟慮された仕方で色を利用していることもあり、そのような頁では，選ばれた色が尊重されるよう，何らかの仕方で~UAに~hintすることが求められるであろう。
`color-adjust$p ~propは、これを制御する。
◎
As a result, in some circumstances user agents will alter the styles an author specifies in some particular context, adjusting them to be more appropriate for the output device and to accommodate what they assume the user would prefer. However, in some cases the document may be using colors in important, well-thought-out ways that the user would appreciate, and so the document would like some way to hint to the user agent that it might want to respect the page’s color choices. The color-adjust property controls this.
</p>


`●名^ `color-adjust@p
`●値^ `economy$v | `exact$v
`●初^ `economy$v
`●適^ すべての要素
`●継^ される
`●百^ 利用不可
`●媒^ 視覚的
`●算^ 指定値
`●ア^ 不可
`●表終^


<p>
`color-adjust$p ~propは、所与の機器~上で，高価に, より一般的には無分別になり得るようなときに
— 文書における 暗い背景に明るい~textを利用して印刷するなど —
色や~styleの~~選択をどう扱うべきかについての~hintを，~UAに提供する。
~UAが，文書~表示のこの側面を 利用者が制御できるようにする場合、利用者の選好は，この~propにて提供される~hintより強く尊重され<strong>~MUST</strong>。
次の値をとり得る:
◎
The color-adjust property provides a hint to the user-agent about how it should treat color and style choices that might be expensive or generally unwise on a given device, such as using light text on a dark background in a printed document. If user agents allow users to control this aspect of the document’s display, the user preference must be respected more strongly than the hint provided by color-adjust. It has the following values:
</p>


<dl>
	<dt>`economy@v</dt>
	<dd>
~UAは、頁の~style付けに対し，出力~機器に必要かつ賢明と判断される調整を施すべきである。
◎
The user agent should make adjustments to the page’s styling as it deems necessary and prudent for the output device.
</dd>
	<dd>
例えば，文書が印刷されるとき、~UAは，費やす~ink量を~~抑えるため，背景を無視して ~textを十分~暗い色になるよう調整することもあり得る。
◎
For example, if the document is being printed, a user agent might ignore any backgrounds and adjust text color to be sufficiently dark, to minimize ink usage.
</dd>

	<dt>`exact@v</dt>
	<dd>
この値は、頁は，重要かつ有意な仕方で 要素の色や~style付けを指定していて、利用者から要請されない限り，調節されたり変更されるべきでないことを指示する。
◎
This value indicates that the page is using color and styling on the specified element in a way which is important and significant, and which should not be tweaked or changed except at the user’s request.
</dd>
	<dd>
例えば、 printed directions 【方向指示？】を提供0している地図siteは、 directions 内の各 step の背景が ~whiteと明るめの~grayが交互になるよう “縞模様に” することもある。
この縞模様が失われて背景が純~whiteにされると，~~車の~~運転時に direction を~~一目で読み取るのも難しくなる。
◎
For example, a mapping website offering printed directions might "zebra-stripe" the steps in the directions, alternating between white and light gray backgrounds. Losing this zebra-striping and having a pure-white background would make the directions harder to read with a quick glance when distracted in a car.
</dd>

</dl>



	</section>
	<section id="sample">
<h2 title="Default Style Rules">14. 既定の~style規則</h2>

<p>
次の~stylesheetは参考であり，規定ではない。
実装は、この~stylesheetを各種 HTML／XHTML Family 文書（ HTML4, XHTML1, XHTML1.1, XHTML Basic, 他）にて既定~style付けの一部として利用できる。
◎
The following stylesheet is informative, not normative. This style sheet could be used by an implementation as part of its default styling of HTML4, XHTML1, XHTML1.1, XHTML Basic, and other XHTML Family documents.
</p>


<pre class="lang-css">
html {
  color: black;
}

/* <span class="comment">
~hyperlinkに対しては、伝統的な~desktop~UA色
◎
traditional desktop user agent colors for hyperlinks
</span> */
:link    { color: blue; }
:visited { color: purple; }
</pre>


<p>
根~要素に対する既定の背景は、 `transparent$v で~MUST。
~canvas（文書が塗られる~~面）の既定の色は~UAに依存するが、
`white$v にすることが推奨される。
とりわけ，上の
`color$p: `black$v
規則が利用されるときは。
◎
The default background of the root element must be transparent. The default color of the canvas (the surface on which the document is painted) is UA-dependent, but is recommended to be white, especially if the above color rules are used.
</p>

	</section>
	<section id="apis">
<h2 title="APIs for Parsing and Manipulating Colors">15. 色を構文解析-／操作する各種 API</h2>

<p>
多くの~appにおいて、作者は，色を利用したり操作する必要がある。
CSS では、色に対し，多種の有用な構文が許容されるが、これらを利用できるのは
~stylesheet内に限られ，~script内では利用できない。
◎
In many applications, authors have to use and manipulate colors. CSS allows many different useful syntaxes for colors, but these are only usable in stylesheets, not in script.
</p>


<p>
この節では、~scriptにて色を作成したり操作するための，いくつかの API を定義する：
◎
This section defines a number of APIs for creating and manipulating colors in script:
</p>


<ul>
	<li>
<p>
CSS 色を構文解析して JS ~object化できる：
</p>
		<ul>
			<li>
対応する色~objectを取得したいときは、
<code>CSSColor.parse("`rebeccapurple$v")</code>
のように~methodを利用できる。
</li>
			<li>
特定の型の色~classを取得したいときは、
<code>new HSLColor("`rebeccapurple$v")</code>
のように，いずれかの色~構築子を利用できる。
</li>
		</ul>

◎
It allows CSS colors to be parsed into JS objects—use the CSSColor.parse("rebeccapurple") method to get a corresponding color object, or one of the specific color constructors, like new HSLColor("rebeccapurple"), to get back a specific type of color class.
</li>

	<li>
<div class="p">
<p>
CSS が公開する どの構文の下でも色を操作できる：
</p>

		<ul>
			<li>
~RGBA色に対しては、各~成分が［
0 〜 1 の範囲にされた `RGBColor$I ／
0 〜 255 の範囲にされた `HexColor$I
］
</li>
			<li>
~HSLA色に対しては、
`hsla$f 構文に対応している `HSLColor$I
</li>
			<li>
~CMYK色に対しては、
`device-cmyk$f 構文に対応している `CMYKColor$I
</li>
		</ul>

◎
It allows colors to be manipulated in any of the syntaxes that CSS exposes: RGBColor for RGBA colors, with components ranging from 0-1; HexColor for RGBA colors, with components ranging from 0-255; HSLColor for HSLA colors, corresponding to the hsla() syntax; and CMYKColor for CMYK colors, corresponding to the device-cmyk() syntax.
</div>

<p>
これらすべては、各~成分を属性として公開し，直接的に操作できる。
また、色は
`toRGB()^m や `toHSL()^m
の様な~methodで，各種~class間を容易に相互~変換できる。
◎
All of these expose their components as attributes you can manipulate directly, and colors can be easily converted between any of the classes with methods like toRGB() and toHSL().
</p>

</li>
	<li>

<p>
色を CSS が解する形に自動的に文字列化したり, 戻すことができる。
例えば次の様な~codeも書ける：
◎
It allows colors to be automatically stringified back into a form that CSS understands, so you can write code like:
</p>

<pre class="lang-javascript">
var %c = new HSLColor("red");
%c.l += .1;
%element.style.backgroundColor = %c;
/* <span class="comment">
%c は自動的に文字列
`hsla(0deg, 100%, 60%, 100%)^l
に転換される
◎
c is automatically turned into the string "hsla(0deg, 100%, 60%, 100%)"
</span> */
</pre>


<p>
望むなら、文字列化する際に構文の型も制御できる
— 
<samp >%c.toString(`hsl^l)</samp>
の様に。
◎
If you wish, you can control what type of syntax it stringifies as, like c.toString("hsl").
</p>


</li>
	<li>
新たな~methodや新たな色~型で 容易に拡張できるように，明示的に設計されている。
<a href="#api-extending">色~classの拡張法</a>
節にて、それを正しく行うための一助となる手引きを与える。
◎
It’s explicitly designed to be easy to extend with new methods and new color types, and gives guidance to help you do it correctly (see §15.6 Extending the Color Classes).
</li>

</ul>

		<section id="api-RGBColor">
<h3 title="The RGBColor Object">15.1. `RGBColor^I ~object</h3>

<p>
`RGBColor$I ~classが “主たる” 色~classである
— すべての CSS 色は、~RGBに互換で~MUST（すなわち，概ね等価な~RGB色に変換できる）ので。
その結果、~UAにより定義される色~class（および，適正に設計された
<a href="#api-extending">作者により定義される色~class</a>
）を等価な `RGBColor$I ~instanceへ変換することは常に可能0になる。
この事実は、すべての色~classに共通的ないくつかの~methodの自動的な取扱いを支援するために利用される。
◎
The RGBColor class is the "primary" color class, because all CSS colors must be RGB-compatible (that is, capable of being converted into a roughly equivalent RGB color). As a result, it’s always possible to convert a UA-defined color class (and any properly-designed author-defined color classes, see §15.6 Extending the Color Classes) into an equivalent RGBColor instance. This fact is used to aid in automatic handling of several methods common to all color classes.
</p>


<pre class="idl">
[<a href="#dom-rgbcolor-rgbcolor">Constructor</a>(double %r, double %g, double %b, optional double %a=1),
 <a href="#dom-rgbcolor-rgbcolor-rgb">Constructor</a>(`RGBColor$I %rgb),
 <a href="#dom-rgbcolor-rgbcolor-css">Constructor</a>(`CSSColor$I %css),
 <a href="#dom-rgbcolor-rgbcolor-color">Constructor</a>(optional `RGBColorInit$I %color),
 <a href="#dom-rgbcolor-rgbcolor-cssstring">Constructor</a>(DOMString %cssstring)]
interface `RGBColor@I : `CSSColor$I {
  attribute double `r$m;
  attribute double `g$m;
  attribute double `b$m;
  attribute double `a$m;

  `RGBColor$I   `toRGB$m();
  `HSLColor$I   `toHSL$m();
  `HexColor$I   `toHex$m();
  `CMYKColor$I  `toCMYK$m();
  DOMString? `toName$m();

  static attribute `ColorStringifiers$I `stringifiers$m;
  attribute `ColorStringifierType$I `defaultStringifier$m;

};
</pre><pre class="idl">
dictionary `RGBColorInit@I {
  double `r@m = 0;
  double `g@m = 0;
  double `b@m = 0;
  double `a@m = 1;
};
</pre><pre class="idl">
enum `ColorStringifierType@I {
  "rgb",
  "hsl",
  "hex",
  "cmyk"
};
</pre><pre class="idl">
dictionary `ColorStringifiers@I {
  `ColorStringifierCallback$I `rgb@m;
  `ColorStringifierCallback$I `hsl@m;
  `ColorStringifierCallback$I `hex@m;
  `ColorStringifierCallback$I `cmyk@m;
};

callback <dfn id="callbackdef-colorstringifiercallback">ColorStringifierCallback</dfn> = DOMString (`CSSColor$I %color, any ...%args);
</pre>

<!-- `RGBColor@I -->

<dl class="idl-def">
	<dt id="dom-rgbcolor-rgbcolor">RGBColor(double %r, double %g, double %b, optional double %a=1)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%r, %g, %b, %a) {
  this.r = %r;
  this.g = %g;
  this.b = %b;
  this.a = %a === undefined ? 1 : %a;
  return this;
}
</pre>

	</dd>
	<dd class="note">注記：
`RGBColor$I ~classの各~属性は、
0 〜 255 でなく， 0 〜 1 を正規の範囲にする。
0 〜 255 の範囲を選好するなら `HexColor$I ~classを見よ。
◎
Note: The RGBColor class’s attributes have a normal range of 0 to 1, not 0 to 255. See the HexColor class if you prefer working in the 0-255 range.
</dd>

	<dt id="dom-rgbcolor-rgbcolor-rgb">RGBColor(`RGBColor$I %rgb)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%rgb) {
  this.r = %rgb.r;
  this.g = %rgb.g;
  this.b = %rgb.b;
  this.a = %rgb.a;
  return this;
}
</pre>
</dd>

	<dt id="dom-rgbcolor-rgbcolor-css">RGBColor(`CSSColor$I %css)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%css) {
  const %color = %css.toRGB();
  this.r = %color.r;
  this.g = %color.g;
  this.b = %color.b;
  this.a = %color.a;
  return this;
}
</pre>
</dd>

	<dt id="dom-rgbcolor-rgbcolor-color">RGBColor(optional `RGBColorInit$I %color)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%color) {
  if(%color === undefined) %color = {r:0, g:0, b:0, a:1};
  this.r = %color.r === undefined ? 0 : %color.r;
  this.g = %color.g === undefined ? 0 : %color.g;
  this.b = %color.b === undefined ? 0 : %color.b;
  this.a = %color.a === undefined ? 1 : %color.a;
  return this;
}
</pre>
</dd>

	<dt id="dom-rgbcolor-rgbcolor-cssstring">RGBColor(DOMString %cssstring)</dt>
	<dd>
渡された文字列から`成分~値を構文解析-$する。
この演算が成功して結果が妥当な CSS 色になる場合、各~属性がその色を表現するように初期化された `RGBColor$I ~classの~instanceを構築して返す。
◎
Parse a component value from the passed string. If this operation succeeds and the result is a valid CSS color, construct an instance of the RGBColor class with attributes initialized to represent that color.
</dd>
	<dd>
他の場合は ~XXXError †を投出する。
◎
Otherwise, throw an XXXError.
</dd>
	<dd class="trans-note">【†
<dfn id="_XXXError"><code>XXXError</code></dfn>：
~~正式な~error名は未策定の模様。
】</dd>

	<dt>`toRGB@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function() {
  return new RGBColor(this);
}
</pre>
</dd>

	<dt>`toHSL@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function() {
  return new HSLColor(this);
}
</pre>
</dd>

	<dt>`toHex@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function() {
  return new HexColor(this);
}
</pre>
</dd>

	<dt>`toCMYK@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function() {
  return new CMYKColor(this);
}
</pre>
</dd>

	<dt>`toName@m()</dt>
	<dd>
<!-- 此れ＊ -->
この~objectの［
`r^m, `g^m, `b^m, `a^m
］各~属性の値を 255 で乗算して最も近傍の整数に丸めた結果が，ある`有名~色$にあてがわれている［
~red, ~green, ~blue, ~alpha
］の~hex値（ ~alpha の~hex値は `transparent$v に対しては 0，それ以外は 255 ）に等しいならば、その色の名前を `DOMString^I として返す。
◎
Let thisObject be the object this method was called on.
◎
If thisObject’s r, g, b, and a attributes, when multiplied by 255 and rounded to the nearest integer, are equal to the r, g, b, and a values assigned to a named color, return that color’s name as a DOMString.
</dd>
	<dd>
他の場合、 ~NULL を返す。
◎
Otherwise, return null.
</dd>

	<dt>double `r@m</dt>
	<dt>double `g@m</dt>
	<dt>double `b@m</dt>
	<dt>double `a@m</dt>
	<dd>
これらの属性は、順に
この `RGBColor$I ~instanceが表現する~RGB色の［
~red, ~green, ~blue, ~alpha
］~channelを表現する。
◎
The r, g, b, and a attributes represent the red, green, blue, and alpha channels of the RGB color that the RGBColor instance represents.
</dd>
	<dd class="note">注記：
`RGBColor$I ~classの各~属性は、
0 〜 255 でなく， 0 〜 1 を正規の範囲にする。
0 〜 255 の範囲を選好するならば `HexColor$I ~classを見よ。
◎
Note: The RGBColor class’s attributes have a normal range of 0 to 1, not 0 to 255. See the HexColor class if you prefer working in the 0-255 range.
</dd>

	<dt>`ColorStringifiers$I `stringifiers@m</dt>
	<dd>
<p>
初期時には、次の ECMAScript ~objectに設定され~MUST：
◎
Must be initially set to the following ECMAScript object:
</p>

<pre class="lang-javascript">
{
  "rgb": function(%color) {
    const %r = %color.r*100 + "%";
    const %g = %color.g*100 + "%";
    const %b = %color.b*100 + "%";
    const %a = %color.a*100 + "%";
    return "rgba(" + [%r,%g,%b,%a].join(", ") + ")";
  },
  "hsl": function(%color) {
    return "" + %color.toHSL();
  },
  "hex": function(%color) {
    return "" + %color.toHex();
  },
  "cmyk": function(%color) {
    return "" + %color.toCMYK();
  }
}
</pre>
	</dd>

	<dt>`ColorStringifierType$I `defaultStringifier@m</dt>
	<dd>
この属性は、初期時には `rgb^l に設定され~MUST。
◎
The defaultStringifier attribute must be initially set to "rgb".
</dd>

</dl>


		</section>
		<section id="api-HSLColor">
<h3 title="The HSLColor Class">15.2. `HSLColor^I ~class</h3>

	
<pre class="idl">
[<a href="#dom-hslcolor-hslcolor">Constructor</a>(double %h, double %s, double %l, optional double %a=1),
 <a href="#dom-hslcolor-hslcolor-rgb">Constructor</a>(`RGBColor$I %rgb),
 <a href="#dom-hslcolor-hslcolor-hsl">Constructor</a>(`HSLColor$I %hsl),
 <a href="#dom-hslcolor-hslcolor-css">Constructor</a>(`CSSColor$I %css),
 <a href="#dom-hslcolor-hslcolor-color">Constructor</a>(optional `HSLColorInit$I %color),
 <a href="#dom-hslcolor-hslcolor-cssstring">Constructor</a>(DOMString %cssstring)]
interface `HSLColor@I : `CSSColor$I {
  attribute double `h$m;
  attribute double `s$m;
  attribute double `l$m;
  attribute double `a$m;

  `RGBColor$I `toRGB$m();
  `HSLColor$I `toHSL$m();

  static attribute `ColorStringifiers$I `stringifiers$m;
  attribute `ColorStringifierType$I `defaultStringifier$m;
};
</pre><pre class="idl">
dictionary `HSLColorInit@I {
  double `h@m = 0;
  double `s@m = 0;
  double `l@m = 0;
  double `a@m = 1;
};
</pre>

<!-- `HSLColor@I -->
<dl class="idl-def">
	<dt id="dom-hslcolor-hslcolor">HSLColor(double %h, double %s, double %l, optional double %a=1)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%h, %s, %l, %a) {
  this.h = %h;
  this.s = %s;
  this.l = %l;
  this.a = %a === undefined ? 1 : %a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hslcolor-hslcolor-rgb">HSLColor(`RGBColor$I %rgb)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%rgb) {
  const {%r,%g,%b,%a} = %rgb;
  this.a = %a;

  const %max = Math.max(%r, %g, %b);
  const %min = Math.min(%r, %g, %b);
  const %chroma = %max - %min;
  if(%chroma == 0) {
    this.h = 0;
  } else if(%r == %max) {
    this.h = (((%g - %b) / %chroma) % 6) * 360;
  } else if(%g == %max) {
    this.h = ((((%b - %r) / %chroma) + 2) % 6) * 360;
  } else {
    this.h = ((((%r - %g) / %chroma) + 4) % 6) * 360;
  }

  this.l = (%min + %max)/2;

  if(this.l == 0 || this.l == 1) {
    this.s = 0;
  } else {
    this.s = %chroma / (1 - Math.abs(2 * this.l - 1));
  }

  return this;
}
</pre>
	</dd>

	<dt id="dom-hslcolor-hslcolor-hsl">HSLColor(`HSLColor$I %hsl)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%hsl) {
  this.h = %hsl.h;
  this.s = %hsl.s;
  this.l = %hsl.l;
  this.a = %hsl.a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hslcolor-hslcolor-css">HSLColor(`CSSColor$I %css)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%css) {
  const %color = %css.toHSL();
  this.h = %color.h;
  this.s = %color.s;
  this.l = %color.l;
  this.a = %color.a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hslcolor-hslcolor-color">HSLColor(optional `HSLColorInit$I %color)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%color) {
  if(%color === undefined) %color = {h:0, s:0, l:0, a:1};
  this.h = %color.h === undefined ? 0 : %color.h;
  this.s = %color.s === undefined ? 0 : %color.s;
  this.l = %color.l === undefined ? 0 : %color.l;
  this.a = %color.a === undefined ? 1 : %color.a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hslcolor-hslcolor-cssstring">HSLColor(DOMString %cssstring)</dt>
	<dd>
渡された文字列から`成分~値を構文解析-$する。
この演算が成功して結果が妥当な CSS 色になる場合、各~属性がその色を表現するように初期化された
`HSLColor$I ~classの~instanceを構築して返す。
◎
Parse a component value from the passed string. If this operation succeeds and the result is a valid CSS color, construct an instance of the HSLColor class with attributes initialized to represent that color.
</dd>
	<dd>
他の場合は ~XXXError を投出する。
◎
Otherwise, throw an XXXError.
</dd>

	<dt>`toRGB@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function() {
  const %max = (1 - Math.abs(2 * this.l - 1)) * this.s;
  const %h_ = ((this.h / 60 % 6) + 6) % 6;
  const %mid = %max * (1 - Math.abs((%h_ % 2) - 1));

  if(%h_ &gt;= 0 &amp;&amp; %h_ &lt; 1) {
    return new RGBColor(%max, %mid, 0);
  } else if(%h_ &gt;= 1 &amp;&amp; %h_ &lt; 2) {
    return new RGBColor(%mid, %max, 0);
  } else if(%h_ &gt;= 2 &amp;&amp; %h_ &lt; 3) {
    return new RGBColor(0, %max, %mid);
  } else if(%h_ &gt;= 3 &amp;&amp; %h_ &lt; 4) {
    return new RGBColor(0, %mid, %max);
  } else if(%h_ &gt;= 4 &amp;&amp; %h_ &lt; 5) {
    return new RGBColor(%mid, 0, %max);
  } else {
    return new RGBColor(%max, 0, %mid);
  }
}
</pre>
	</dd>

	<dt>`toHSL@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function() {
  return new HSLColor(this);
}
</pre>
	</dd>

	<dt>double `h@m</dt>
	<dt>double `s@m</dt>
	<dt>double `l@m</dt>
	<dt>double `a@m</dt>
	<dd>
これらの属性は、順に
この `HSLColor$I ~instanceが表現する~HSL色の［
色相, 彩度, 明度, ~alpha
］~channelを表現する。
◎
The h, s, l, and a attributes represent the hue, saturation, lightness, and alpha channels of the HSL color that the HSLColor instance represents.
</dd>
	<dd class="note">注記：
`HSLColor$I ~classの色相~属性（ `h$m ）は、
0 〜 360 （ `deg^css 単位）を正規の範囲にする。
他の属性は 0 〜 1 を正規の範囲にする。
◎
Note: The HSLColor class’s hue attribute has a normal range of 0 to 360 (denoted in degrees), and its other attributes have a normal range of 0 to 1.
</dd>

	<dt>`ColorStringifiers$I `stringifiers@m</dt>
	<dd>
<p>
初期時には、次の ECMAScript ~objectに設定され~MUST：
◎
Must be initially set to the following ECMAScript object:
</p>

<pre class="lang-javascript">
{
  "hsl": function(%color) {
    const %h = %color.h + "deg";
    const %s = %color.s*100 + "%";
    const %l = %color.l*100 + "%";
    const %a = %color.a*100 + "%";
    return "hsla(" + [%h,%s,%l,%a].join(", ") + ")";
  }
}
</pre>
	</dd>

	<dt>`ColorStringifierType$I `defaultStringifier@m</dt>
	<dd>
この属性は、初期時には `hsl^l に設定され~MUST。
◎
The defaultStringifier attribute must be initially set to "hsl".
</dd>

</dl>

		</section>
		<section id="api-HWBColor">
<h3 title="The HWBColor Class">15.3. `HWBColor^I ~class</h3>

<pre class="idl">
[<a href="#dom-hwbcolor-hwbcolor">Constructor</a>(double %h, double %w, double %b, optional double %a=1),
 <a href="#dom-hwbcolor-hwbcolor-rgb">Constructor</a>(`RGBColor$I %rgb),
 <a href="#dom-hwbcolor-hwbcolor-hsl">Constructor</a>(`HSLColor$I %hsl),
 <a href="#dom-hwbcolor-hwbcolor-hwb">Constructor</a>(`HWBColor$I %hwb),
 <a href="#dom-hwbcolor-hwbcolor-css">Constructor</a>(`CSSColor$I %css),
 <a href="#dom-hwbcolor-hwbcolor-color">Constructor</a>(optional `HWBColorInit$I %color),
 <a href="#dom-hwbcolor-hwbcolor-cssstring">Constructor</a>(DOMString %cssstring)]
interface `HWBColor@I : `CSSColor$I {
  attribute double `h$m;
  attribute double `w$m;
  attribute double `b$m;
  attribute double `a$m;

  RGBColor `toRGB$m();
  HSLColor `toHSL$m();
  HWBColor `toHWB$m();

  static attribute `ColorStringifiers$I `stringifiers$m;
  attribute `ColorStringifierType$I `defaultStringifier$m;
};
</pre>

};

<pre class="idl">
dictionary `HWBColorInit@I {
  double `h@m = 0;
  double `w@m = 0;
  double `b@m = 0;
  double `a@m = 1;
};
</pre>


<!-- `HWBColor@I -->
<dl class="idl-def">

	<dt id="dom-hwbcolor-hwbcolor">HWBColor(double %h, double %w, double %b, optional double %a=1)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%h, %w, %b, %a) {
  this.h = %h;
  this.w = %w;
  this.b = %b;
  this.a = %a === undefined ? 1 : %a;
  return this;
}</pre>
	</dd>

	<dt id="dom-hwbcolor-hwbcolor-rgb">HWBColor(`RGBColor$I %rgb)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%rgb) {
  const {%r,%g,%b,%a} = %rgb;
  this.a = %a;

  const %max = Math.max(%r, %g, %b);
  const %min = Math.min(%r, %g, %b);
  const %chroma = %max - %min;
  if(%chroma == 0) {
    this.h = 0;
  } else if(%r == %max) {
    this.h = (((%g - %b) / %chroma) % 6) * 360;
  } else if(%g == %max) {
    this.h = ((((%b - %r) / %chroma) + 2) % 6) * 360;
  } else {
    this.h = ((((%r - %g) / %chroma) + 4) % 6) * 360;
  }
  this.w = %min;
  this.b = 1 - %max;
  return this;
}</pre>
	</dd>

	<dt id="dom-hwbcolor-hwbcolor-hsl">HWBColor(`HSLColor$I %hsl)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%hsl) {
  this.h = %hsl.h;
  this.a = %hsl.a;
  ... // <span class="comment">【未策定】</span>

  return this;
}
</pre>
	</dd>

	<dt id="dom-hwbcolor-hwbcolor-hwb">HWBColor(`HWBColor$I %hwb)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%hwb) {
  this.h = %hwb.h;
  this.w = %hwb.w;
  this.b = %hwb.b;
  this.a = %hwb.a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hwbcolor-hwbcolor-css">HWBColor(`CSSColor$I %css)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>


<pre class="lang-javascript">
function(%css) {
  const %color = %css.toHWB();
  this.h = %color.h;
  this.w = %color.w;
  this.b = %color.b;
  this.a = %color.a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hwbcolor-hwbcolor-color">HWBColor(optional `HWBColorInit$I %color)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>


<pre class="lang-javascript">
function(%color) {
  if(%color === undefined) %color = {h:0, w:0, b:0, a:1};
  this.h = %color.h === undefined ? 0 : %color.h;
  this.w = %color.w === undefined ? 0 : %color.w;
  this.b = %color.b === undefined ? 0 : %color.b;
  this.a = %color.a === undefined ? 1 : %color.a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hwbcolor-hwbcolor-cssstring">HWBColor(DOMString %cssstring)</dt>
	<dd>
渡された文字列から`成分~値を構文解析-$する。
この演算が成功して結果が妥当な CSS 色になる場合、各~属性がその色を表現するように初期化された
`HWBColor$I ~classの~instanceを構築して返す。
◎
Parse a component value from the passed string. If this operation succeeds and the result is a valid CSS color, construct an instance of the HWBColor class with attributes initialized to represent that color.
</dd>
	<dd>
他の場合は ~XXXError を投出する。
◎
Otherwise, throw an XXXError.
</dd>

	<dt>`toRGB@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>


<pre class="lang-javascript">
function() {
  let %w = this.w;
  let %b = this.b;
  if(%w+%b &gt; 1) {
    const %sum = %w+%b;
    %w /= %sum;
    %b /= %sum;
  }

  const %h = ((this.h / 60 % 6) + 6) % 6;
  const %max = 1 - %b;
  const %mid = 1 - Math.abs((%h % 2) - 1);
  const %min = %w;

  if(%h &gt;= 0 &amp;&amp; %h_ &lt; 1) {
    return new RGBColor(%max, %mid, %min);
  } else if(%h &gt;= 1 &amp;&amp; %h &lt; 2) {
    return new RGBColor(%mid, %max, %min);
  } else if(%h &gt;= 2 &amp;&amp; %h &lt; 3) {
    return new RGBColor(%min, %max, %mid);
  } else if(%h &gt;= 3 &amp;&amp; %h &lt; 4) {
    return new RGBColor(%min, %mid, %max);
  } else if(%h &gt;= 4 &amp;&amp; %h &lt; 5) {
    return new RGBColor(%mid, %min, %max);
  } else {
    return new RGBColor(%max, %min, %mid);
  }
</pre>
	</dd>

	<dt>`toHSL@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
... // <span class="comment">【未策定】</span>
</pre>
	</dd>

	<dt>`toHWB@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>


<pre class="lang-javascript">
function() {
  return new HWBColor(this);
}
</pre>
	</dd>

	<dt>double `h@m</dt>
	<dt>double `w@m</dt>
	<dt>double `b@m</dt>
	<dt>double `a@m</dt>
	<dd>
これらの属性は、順に
この `HWBColor$I ~instanceが表現する~HWB色の［
色相, 白味, 黒味, ~alpha
］~channelを表現する。
◎
The h, w, b, and a attributes represent the hue, whiteness, blackness, and alpha channels of the HWB color that the HWBColor instance represents.
</dd>
	<dd class="note">注記：
`HWBColor$I ~classの色相~属性（ `h$m ）は、
0 〜 360 （ `deg^css 単位）を正規の範囲にする。
他の属性は 0 〜 1 を正規の範囲にする。
◎
Note: The HWBColor class’s hue attribute has a normal range of 0 to 360 (denoted in degrees), and its other attributes have a normal range of 0 to 1.
</dd>

	<dt>`ColorStringifiers$I `stringifiers@m</dt>
	<dd>
<p>
初期時には、次の ECMAScript ~objectに設定され~MUST：
◎
Must be initially set to the following ECMAScript object:
</p>

<pre class="lang-javascript">
{
  "hwb": function(%color) {
    const %h = %color.h + "deg";
    const %w = %color.w*100 + "%";
    const %b = %color.b*100 + "%";
    const %a = %color.a*100 + "%";
    return "hwb(" + [%h,%w,%b,%a].join(", ") + ")";
  }
}
</pre>
	</dd>

	<dt>`ColorStringifierType$I `defaultStringifier@m</dt>
	<dd>
この属性は、初期時には `hex^l に設定され~MUST。
◎
The defaultStringifier attribute must be initially set to "hwb".
</dd>

</dl>

		</section>
		<section id="api-HexColor">
<h3 title="The HexColor Class">15.4. `HexColor^I ~class</h3>


<pre class="idl">
[<a href="#dom-hexcolor-hexcolor">Constructor</a>(
    [Clamp] octet %r,
    [Clamp] octet %g,
    [Clamp] octet %b,
    optional [Clamp] octet %a = 255
 ),
 <a href="#dom-hexcolor-hexcolor-rgb">Constructor</a>(`RGBColor$I %rgb),
 <a href="#dom-hexcolor-hexcolor-hex">Constructor</a>(`HexColor$I %hex),
 <a href="#dom-hexcolor-hexcolor-css">Constructor</a>(`CSSColor$I %css),
 <a href="#dom-hexcolor-hexcolor-color">Constructor</a>(optional `HexColorInit$I %color),
 <a href="#dom-hexcolor-hexcolor-cssstring">Constructor</a>(DOMString %cssstring)]
interface `HexColor@I : `CSSColor$I {
  [Clamp] attribute octet `r$m;
  [Clamp] attribute octet `g$m;
  [Clamp] attribute octet `b$m;
  [Clamp] attribute octet `a$m;

  `RGBColor$I `toRGB$m();
  `HexColor$I `toHex@m();

  static attribute `ColorStringifiers$I `stringifiers$m;
  attribute `ColorStringifierType$I `defaultStringifier$m;
};
</pre><pre class="idl">
dictionary `HexColorInit@I {
  [Clamp] octet `r@m = 0;
  [Clamp] octet `g@m = 0;
  [Clamp] octet `b@m = 0;
  [Clamp] octet `a@m = 255;
};
</pre>

<!-- `HexColor@I -->
<dl class="idl-def">
	<dt id="dom-hexcolor-hexcolor">HexColor([Clamp] octet %r, [Clamp] octet %g, [Clamp] octet %b, optional [Clamp] octet %a=255)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%r, %g, %b, %a) {
  this.r = %r;
  this.g = %g;
  this.b = %b;
  this.a = %a === undefined ? 255 : %a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hexcolor-hexcolor-rgb">HexColor(`RGBColor$I %rgb)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%rgb) {
  var %normalize = function(%num) {
    return Math.max(0, Math.min(255, Math.round(%num)));
  }
  this.r = %normalize(rgb.r * 255);
  this.g = %normalize(rgb.g * 255);
  this.b = %normalize(rgb.b * 255);
  this.a = %normalize(rgb.a * 255);
  return this;
}
</pre>
	</dd>

	<dt id="dom-hexcolor-hexcolor-hex">HexColor(`HexColor$I %hex)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%hex) {
  this.r = hex.r;
  this.g = hex.g;
  this.b = hex.b;
  this.a = hex.a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hexcolor-hexcolor-css">HexColor(`CSSColor$I %css)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%css) {
  const %color = %css.toHex();
  this.r = %color.r;
  this.g = %color.g;
  this.b = %color.b;
  this.a = %color.a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hexcolor-hexcolor-color">HSLColor(optional `HexColorInit$I %color)</dt>
<!-- 誤 dom-hexcolor-hslcolorcolor -->
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%color) {
  if(%color === undefined) %color = {r:0, g:0, b:0, a:255};
  this.r = %color.r === undefined ? 0 : %color.r;
  this.g = %color.g === undefined ? 0 : %color.g;
  this.b = %color.b === undefined ? 0 : %color.b;
  this.a = %color.a === undefined ? 255 : %color.a;
  return this;
}
</pre>
	</dd>

	<dt id="dom-hexcolor-hexcolor-cssstring">HexColor(DOMString %cssstring)</dt>
	<dd>
渡された文字列から`成分~値を構文解析-$する。
この演算が成功して結果が妥当な CSS 色になる場合、各~属性がその色を表現するように初期化された
`HexColor$I ~classの~instanceを構築して返す。
◎
Parse a component value from the passed string. If this operation succeeds and the result is a valid CSS color, construct an instance of the HexColor class with attributes initialized to represent that color.
</dd>
	<dd>
他の場合は ~XXXError を投出する。
◎
Otherwise, throw an XXXError.
</dd>

	<dt>`toRGB@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function() {
  return new RGBColor(this.r/255, this.g/255, this.b/255, this.a/255);
}
</pre>
	</dd>

	<dt>octet `r@m</dt>
	<dt>octet `g@m</dt>
	<dt>octet `b@m</dt>
	<dt>octet `a@m</dt>
	<dd>
これらの属性は、順に
この `HexColor$I ~instanceが表現する~RGB色の［
~red, ~green, ~blue, ~alpha
］~channelを表現する。
◎
The r, g, b, and a attributes represent the red, blue, green, and alpha channels of the RGB color that the HexColor instance represents.
</dd>
	<dd class="note">注記：
`HexColor$I ~classの属性は、いずれも 0 〜 255 の整数に制約される。
被~設定-時に，与えられた値が整数でない場合は，最も近傍†の整数に丸められ、範囲~外の数は，範囲~内に切詰められる。
◎
Note: The HexColor class’s attributes are all restricted to integers between 0 and 255. Setting them to a non-integer will round them to the nearest integer, and setting them to a number less than 0 or greater than 255 will set them to 0 or 255, respectively.
</dd>
	<dd class="trans-note">【†
これらの属性は [Clamp] 拡張属性~付きなので、 %X.5 のような小数は，
<a href="WebIDL-ja.html#es-integers">WebIDL に規定される</a>
ように，偶数の近傍に丸められる。
】</dd>

	<dt>`ColorStringifiers$I `stringifiers@m</dt>
	<dd>
<p>
初期時には、次の ECMAScript ~objectに設定され~MUST：
◎
Must be initially set to the following ECMAScript object:
</p>

<pre class="lang-javascript">
{
  "hex": function(%color) {
    const %r = (%color.r &lt; 16 ? "0" : "") + %color.r.toString(16);
    const %g = (%color.g &lt; 16 ? "0" : "") + %color.g.toString(16);
    const %b = (%color.b &lt; 16 ? "0" : "") + %color.b.toString(16);
    const %a = (%color.a &lt; 16 ? "0" : "") + %color.a.toString(16);
    return "#" + %r + %g + %b + %a;
  }
}
</pre>
	</dd>

	<dt>`ColorStringifierType$I `defaultStringifier@m</dt>
	<dd>
この属性は、初期時には `hex^l に設定され~MUST。
◎
The defaultStringifier attribute must be initially set to "hex".
</dd>

</dl>


   


		</section>
		<section id="api-CMYKColor">
<h3 title="The CMYKColor Class">15.5. `CMYKColor^I ~class</h3>

<!-- ＊原文誤記
    optional fallback RGBColor?=null
-->
<pre class="idl">
[<a href="#dom-cmykcolor-cmykcolor">Constructor</a>(
    double %c, double %m, double %y, double %k,
    optional double %a=1,
    optional `RGBColor$I? %fallback=null
 ),
 <a href="#dom-cmykcolor-cmykcolor-rgb">Constructor</a>(`RGBColor$I %rgb),
 <a href="#dom-cmykcolor-cmykcolor-cmyk">Constructor</a>(`CMYKColor$I %cmyk),
 <a href="#dom-cmykcolor-cmykcolor-css">Constructor</a>(`CSSColor$I %css),
 <a href="#dom-cmykcolor-cmykcolor-color">Constructor</a>(optional `CMYKColorInit$I %color),
 <a href="#dom-cmykcolor-cmykcolor-cssstring">Constructor</a>(DOMString %cssstring)]
interface `CMYKColor@I : `CSSColor$I {
  attribute double `c$m;
  attribute double `m$m;
  attribute double `y$m;
  attribute double `k$m;
  attribute double `a$m;
  attribute `RGBColor$I? `fallback$m;

  `RGBColor$I `toRGB$m();

  static attribute `ColorStringifiers$I `stringifiers$m;
  attribute `ColorStringifierType$I `defaultStringifier$m;
};
</pre><pre class="idl">
dictionary `CMYKColorInit@I {
  double `c@m = 0;
  double `m@m = 0;
  double `y@m = 0;
  double `k@m = 0;
  double `a@m = 1;
  `RGBColor$I? `fallback@m = null;
};
</pre>


<!-- `CMYKColor@I -->
<dl class="idl-def">
	<dt id="dom-cmykcolor-cmykcolor">CMYKColor(double %c, double %m, double %y, double %k, optional double %a=1, optional `RGBColor$I? %fallback=null)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%c, %m, %y, %k, %a, %fallback) {
  this.c = %c;
  this.m = %m;
  this.y = %y;
  this.k = %k;
  this.a = %a === undefined ? 1 : %a;
  this.fallback = %fallback === undefined ? null : %fallback;
}
</pre>
	</dd>

	<dt id="dom-cmykcolor-cmykcolor-rgb">CMYKColor(`RGBColor$I %rgb)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%rgb) {
  const {%r,%g,%b,%a} = %rgb;
  this.a = %a;

  const %k = 1 - Math.max(%r, %g, %b);
  this.k = %k;

  if(%k == 1) {
    this.c = 0;
    this.m = 0;
    this.y = 0;
  } else {
    this.c = (1 - %r - %k) / (1 - %k);
    this.m = (1 - %g - %k) / (1 - %k);
    this.y = (1 - %b - %k) / (1 - %k);
  }

  this.fallback = new RGBColor(%rgb);

  return this;
}
</pre>
	</dd>

	<dt id="dom-cmykcolor-cmykcolor-cmyk">CMYKColor(`CMYKColor$I %cmyk)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%cmyk) {
  this.c = %cmyk.c;
  this.m = %cmyk.m;
  this.y = %cmyk.y;
  this.k = %cmyk.k;
  this.a = %cmyk.a;
  this.fallback = %cmyk.fallback;
  return this;
}
</pre>
	</dd>

	<dt id="dom-cmykcolor-cmykcolor-css">CMYKColor(`CSSColor$I %css)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%css) {
  const %color = %css.toCMYK();
  this.c = %color.c;
  this.m = %color.m;
  this.y = %color.y;
  this.k = %color.k;
  this.a = %color.a;
  this.fallback = %color.fallback;
  return this;
}
</pre>
	</dd>

	<dt id="dom-cmykcolor-cmykcolor-color">CMYKColor(optional `CMYKColorInit$I %color)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%color) {
  if(%color === undefined) %color = {c:0, m:0, y:0, k:0, a:1, fallback:null};
  this.c = %color.c === undefined ? 0 : %color.c;
  this.m = %color.m === undefined ? 0 : %color.m;
  this.y = %color.y === undefined ? 0 : %color.y;
  this.k = %color.k === undefined ? 0 : %color.k;
  this.a = %color.a === undefined ? 1 : %color.a;
  this.fallback = %color.fallback === undefined ? null : %color.fallback;
}
</pre>
	</dd>

	<dt id="dom-cmykcolor-cmykcolor-cssstring">CMYKColor(DOMString %cssstring)</dt>
	<dd>
渡された文字列から`成分~値を構文解析-$する。
この演算が成功して結果が妥当な `device-cmyk$f 関数になる場合、各~属性がその色を表現するように初期化された
`CMYKColor$I ~classの~instanceを構築して返す。
◎
Parse a component value from the passed string. If this operation succeeds and the result is a valid device-cmyk() function, construct an instance of the CMYKColor class with attributes initialized to represent that color.
</dd>
	<dd>
他の場合、この演算が成功して結果が他の型の妥当な CSS 色になる場合、各~属性が［
<a href="#cmyk-rgb">~CMYK色と~RGB色の間の変換法</a>
節に従って~CMYKに変換された色
］を表現するように初期化された
`CMYKColor$I ~classの~instanceを構築して返す。
◎
Otherwise, if the operation succeeds and the result is any other type of valid CSS color, construct an instance of the CMYKColor class with attributes initialized to represent that color converted to CMYK, per §10.1 Converting Between CMYK and RGB-Based Colors.
</dd>
	<dd>
他の場合は ~XXXError を投出する。
◎
Otherwise, throw an XXXError.
</dd>

	<dt>`toRGB@m()</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function() {
  const %k_ = 1 - this.k;
  const %r = 1 - Math.min(1, this.c * %k_ + this.k);
  const %g = 1 - Math.min(1, this.m * %k_ + this.k);
  const %b = 1 - Math.min(1, this.y * %k_ + this.k);
  return new RGBColor(%r, %g, %b, this.a);
}
</pre>
	</dd>

	<dt>double `c@m</dt>
	<dt>double `m@m</dt>
	<dt>double `y@m</dt>
	<dt>double `k@m</dt>
	<dt>double `a@m</dt>
	<dt>`RGBColor$I? `fallback@m</dt>
	<dd>
これらの属性は、順に
この `CMYKColor$I ~instanceが表現する~CMYK色の［
~cyan, ~magenta, ~yellow, ~black, ~alpha
］~channelを表現する。
【原文 red, blue, green, alpha は明らかに誤記 】
◎
The c, m, y, k, a, and fallback attributes represent the red, blue, green, and alpha channels of the CMYK color that the CMYKColor instance represents.
</dd>
	<dd class="note">注記：
`CMYKColor$I ~classの［
`c^m／`m^m／`y^m／`k^m／`a^m
］属性は、 0 〜 1 を正規の範囲にする。
`fallback^m 属性は、常に
`RGBColor^I または ~NULL をとる（後者は
<a href="#cmyk-rgb">~CMYK色と~RGB色の間の変換法</a>
節に従って `RGBColor^I に変換されるべきことを指示する）。
◎
Note: The CMYKColor class’s c, m, y, k, and a attributes have a normal range of 0 to 1. Its fallback attribute is always an RGBColor, or null (indicating it should convert itself to an RGBColor per §10.1 Converting Between CMYK and RGB-Based Colors).
</dd>

	<dt>`ColorStringifiers$I `stringifiers@m</dt>
	<dd>
<p>
初期時には、次の ECMAScript ~objectに設定され~MUST：
◎
Must be initially set to the following ECMAScript object:
</p>

<pre class="lang-javascript">
{
  "cmyk": function(%color) {
    const %c = color.c;
    const %m = color.m;
    const %y = color.y;
    const %k = color.k;
    const %a = color.a;
    if(/* <span class="comment">
~UAは，出力~機器の色~profileを知っているならば
◎
UA knows the output device’s color profile
</span> */) {
      fallback = "" + (/* <span class="comment">
等価な `RGBColor$I ~object
◎
Equivalent RGBColor object
</span> */)
    } else {
      %fallback = "" %color.toRGB();<!-- ＊ -->
    }
    return "cmyk(" + [%c,%m,%y,%k,%a,%fallback].join(", ") + ")";
  }
}
</pre>
	</dd>

	<dt>`ColorStringifierType$I `defaultStringifier@m</dt>
	<dd>
この属性は、初期時には `cmyk^l に設定され~MUST。
◎
The defaultStringifier attribute must be initially set to "cmyk".
</dd>

</dl>

		</section>
		<section id="api-extending">
<h3 title="Extending the Color Classes">15.6. 色~classの拡張法</h3>

<p>
この仕様にて定義される各種~色~classは、作者が容易に［
色~classに新たな~methodを追加して ／
新たな色~classを作成して
］拡張できるよう，特に設計されている。
次~節にて、色~classを~~予想通り正しく挙動するように拡張する方法についての，手引きを与える。
◎
The color classes defined in this spec are specifically designed to be extensible by authors; their design makes it easy to both add new methods to colors, and to create new color classes entirely. The following sections give guidance on how to correctly extend the color classes, so that they behave correctly and in an unsurprising manner.
</p>


			<section id="api-adding-methods">
<h4 title="Adding New Color-Manipulating Methods">15.6.1. 色を操作する新たな~methodの追加法</h4>

<p>
新たな~methodが，特定0の色~classのみに~~固有であるならば、通常通りに，それを~classの~prototypeに追加する。
◎
If a new method is truly unique to a particular color class, add it to the class’s prototype, as normal.
</p>


<p>
しかしながら、ほとんどの色~操作~methodは，一般的に、色が表される特定0の形式に関わらず適用可能になる。
この型の~methodを追加するときは、次の手続きに従う:
◎
However, most color-manipulation methods are applicable to colors in general, regardless of the particular format the color may be expressed in. To add a method of this type, follow these steps:
</p>


<ol>

	<li>
`RGBColor$I に対し，~methodを定義する
— ~methodをその~prototypeに追加することにより。
◎
Define the method for RGBColors, by adding it to RGBColor.prototype.
</li>

	<li>
<p>
他のすべての色~classに対しては、~method名を引数に `CSSColor$I の［
`forward()$m または `forwardToSameClass()$m
］を呼び出して，転送~methodを定義する
— その~methodが 数などの色でない値を返すのであれば，
`forward()$m を利用し、変換~関数の様に 特定0の型の色~値を返すのであれば，
`forwardToSameClass()$m を利用する。
後者にて返される色の精確な型を気にする必要はない
— これは、それが呼ばれた色~classと同じ型を返すことを確保するので。
◎
Define a forwarding method for all other color classes, by calling CSSColor.forward("myMethodName") or CSSColor.forwardToSameClass("myMethodName"). Use forward() if the method returns a non-color value, such as a number, or if it purposely returns a color value of a particular type, like a conversion function. Use forwardToSameClass() if the method returns a color, and the precise type of color returned doesn’t matter, as this will ensure it returns the same type of color as it was called on.
</p>

<p>
（これらの既定~実装は、効率的とは言えないが，すべての色~classに対し自動的に働く
— 作者が定義した~classや~UAが将来に追加するものも含めて）
◎
(These default implementations are not very efficient, but they automatically work for all color classes, including ones you define or that a UA adds in the future.)
</p>

</li>
	<li>
任意選択で、~methodのより効率的な~versionを，目的の色~classの~prototype上に直接的に定義する。
◎
Optionally, define a more efficient version of the method directly on the prototype of the color classes you’re interested in.
</li>

</ol>

<div class="example">
<p>
例えば、すべての色~classに， `lightness()^m ~method
— 知覚される色の明度の近似を算出する~method —
を追加する方法は、次の様になる
【数値 2.2 は、おそらく，~gamma補正】
：
◎
For example, here’s how you would add a lightness() method to all color classes, which computes the approximate perceptual lightness of a color:
</p>

<pre class="lang-javascript">
RGBColor.prototype.lightness = function() {
  return .2126 * Math.pow(this.r, 2.2) +
    .7152 * Math.pow(this.g, 2.2) +
    .0722 * Math.pow(this.b, 2.2);
};

CSSColor.forward("lightness");
</pre>

<p>
`lightness()^m ~methodは、今や
`CMYKColor$I の~instanceなど，他の色~classでも可用になる。
それ以上 何もする必要なく。
◎
Without any further effort, the lightness() method is now available for other color classes, like instances of CMYKColor.
</p>
</div>

			</section>
			<section id="api-adding-classes">
<h4 title="Adding New Color Classes">15.6.2.  新たな色~classの追加法</h4>

<p>
各~色~classは、欲される色~空間において色を容易に操作できるようにするため，色の特定0の表現に特化されている。
例えば、~HSL色は，概念的には~RGB色と等価であるが、色の`色相~角度$を直接的に改せる方が有用になることは 依然としてある。
`HSLColor$I ~classがそれを可能にする。
◎
Each color class is specialized to a particular representation of a color, to allow easy manipulationg of the color in the desired color space. For example, even though HSL colors are conceptually equivalent to RGB colors, it is still sometimes useful to be able to directly alter the hue angle of the color, which the HSLColor class allows.
</p>


<p>
作者は、 CSS が直接的に~supportしない色~空間における色の~~演算を望むなら，自前の色~classを容易に追加できる。
しかしながら、これを正しく行うためには，いくつかの注意点がある。
◎
If, as an author, you wish to work with colors in your application in a color space that CSS does not directly support, you can easily add your own color class. Doing this correctly, however, requires some care.
</p>


<p>
他の色~classとの間で正しく働くようにするためには、新たな色~classは，<em>次に従わ~MUST</em>：
◎
To work correctly with the rest of the color classes, a new color class must:
</p>


<ol>

	<li>
<p>
`CSSColor$I の下位classにする
— 次のような~codeにより：
◎
Subclass CSSColor, such as via:
</p>

<pre class="lang-javascript">
MyNewColor.prototype = Object.create(CSSColor.prototype);
</pre>

</li>
	<li>
自身と等価な `RGBColor$I ~instanceを返すような，引数なしで呼べる， `toRGB()^m ~methodを実装する。
◎
Implement a toRGB() method, which can be called without any arguments and which returns an equivalent RGBColor instance. (Remember that the normal range of RGBColor components is between 0 and 1, not 0 and 255.)
</li>

	<li>
構築子を実装する
— その唯一の引数に `RGBColor$I ~instanceが渡されたとき，等価な色を生産するような。
◎
Implement a constructor that, when passed an RGBColor instance as its sole argument, will produce a color equivalent to the RGBColor. (Same disclaimer as previous item.)
</li>

</ol>

<p>
`RGBColor$I の各~成分の正規の範囲は、 0 〜 255 でなく 0 〜 1 であることに~~注意。
</p>


<div class="example">
<p>
<a href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSV</a>
色~classを正しく実装するときに要求される，最小限の~code例を以下に示す：
◎
For example, here is the bare minimum of code required to correctly implement an HSV color class:
</p>

<pre class="lang-javascript">
function HSVColor(...%args) {
  if(%args.length == 1 &amp;&amp; %args[0] instanceof RGBColor) {
    let {%r, %g, %b, %a} = %args[0];
    %r = ((%r % 1) + 1) % 1;
    %g = ((%g % 1) + 1) % 1;
    %b = ((%b % 1) + 1) % 1;
    %a = Math.min(1, Math.max(0, %a));

    this.a = %a;

    const %max = Math.max(%r, %g, %b);
    const %min = Math.min(%r, %g, %b);
    const %chroma = %max - %min;
    if(%chroma == 0) {
      this.h = 0;
    } else if(%r == %max) {
      this.h = (((%g - %b) / %chroma) % 6) * 360;
    } else if(%g == %max) {
      this.h = ((((%b - %r) / %chroma) + 2) % 6) * 360;
    } else {
      this.h = ((((%r - %g) / %chroma) + 4) % 6) * 360;
    }

    this.v = %max;

    if(%chroma == 0) {
      this.s = 0;
    } else {
      this.s = %chroma/this.v;
    }

    return this;
  }
  throw XXXError();
}

HSVColor.prototype = Object.create(CSSColor.prototype);

HSVColor.prototype.toRGB = function() {
  const %max = this.v * this.s;
  const %h_ = ((this.h / 60 % 6) + 6) % 6;
  const %mid = %max * (1 - Math.abs((%h_ % 2) - 1));

  if(%h_ &gt;= 0 &amp;&amp; %h_ &lt; 1) {
    return new RGBColor(%max, %mid, 0);
  } else if(%h_ &gt;= 1 &amp;&amp; %h_ &lt; 2) {
    return new RGBColor(%mid, %max, 0);
  } else if(%h_ &gt;= 2 &amp;&amp; %h_ &lt; 3) {
    return new RGBColor(0, %max, %mid);
  } else if(%h_ &gt;= 3 &amp;&amp; %h_ &lt; 4) {
    return new RGBColor(0, %mid, %max);
  } else if(%h_ &gt;= 4 &amp;&amp; %h_ &lt; 5) {
    return new RGBColor(%mid, 0, %max);
  } else {
    return new RGBColor(%max, 0, %mid);
  }
}
</pre>


<p>
これにより：
<span class="block">
`HSVColor^I ~instanceを作成して（間接的に，先ず `RGBColor^I を作成して），<br />
それを他の色~classに変換して（ `RGBColor^I を経由して自動的に），<br />
すべての色~型に定義されている任意の~methodを何か選出して（同上），<br />
CSS ~propに直接的にあてがう（文字列化して `rgba$f 構文にすることにより）
</span>
ことも可能になる。
◎
This allows you to create an HSVColor instance (indirectly, by first creating an RGBColor), convert it into any other color class (by automatically indirecting to RGBColor), pick up any methods defined for all color types (same), and even assign it directly to a CSS property (by stringifying into the rgba() syntax).
</p>
</div>


<p>
作者が定義する<em>べき</em>である追加の~methodは，他にもいくつかあるが、
CSS に定義される各種~色~classとの相乗効果と一貫性を最大限に得るためには、以下を定義する：
◎
There are several additional methods you should define, however, to get maximum value and consistency with the CSS-defined color classes:
</p>


<ul>

	<li>
複数の引数（概して，何らかの順序による色の~propと,
最後の省略可能な~alphaをとる引数）から色を築く，構築子。
◎
A constructor that builds the color with multiple arguments (typically the color’s properties, in some order, with alpha optional and last).
</li>

	<li>
［
当の~classと同じ~propを伴う~objectや, 当の~classの~instance
］を引数にとれる構築子。
◎
A constructor that can take an object with the same properties as the class, or an instance of the class.
</li>

	<li>
`CSSColor$I のどの下位classも引数にとれ，かつ
当の~classによる等価な色を返すような，構築子（おそらく，単に 引数の `toRGB()^m を呼んで得られる `RGBColor$I ~instanceを，当の~classに変換することにより
— この~methodは，どの組込みの~classにも定義され、また，どの~custom~classも，自身が正しく働くためには この~methodを定義するべきである）。
◎
A constructor that can take *any* subclass of CSSColor and return an equivalent color in your class (probably by just calling toRGB() on it, which all built-in classes define and all custom classes should define in order to work correctly, and then converting it into your class).
</li>

	<li>
CSS 色~値を包含している文字列を引数にとれ，それを当の~classの~instanceに転換するような構築子。
◎
A constructor that can take a string containing a CSS color value, and turn it into an instance of your class.
</li>

	<li>
任意の型の色を当の色~classに変形するような，
`toMyColor()^m ~method
— これは、 `RGBColor$I の~prototype上に定義する。
◎
A toMycolor-mod() method on RGBColor.prototype, that transforms any type of color into your color class.
</li>

	<li>
当の~classが既存の~classによく似ている場合、先ず `RGBColor$I を通すより 既存の~classと当の~classとの間で直接的に変換する方が
より良く／より高速に
なるのであれば、
`TheOtherColor.prototype^c 上の `toMyColor()^m ~method, および
`MyNewColor.prototype^c 上の `TheOtherColor()^m
~method。
当の~classの構築子には、これらの~classを取扱う事例も併せて追加する。
◎
If your class is very similar to an existing class, such that you can do a better/faster conversion between the existing class and yours directly rather than doing through RGBColor first, a toMycolor-mod() method on TheOtherColor.prototype, and a toTheOthercolor-mod() method on MyNewColor.prototype. Add cases to your constructor to handle these classes as well.
</li>

	<li>
<p>
~UAにより定義されるいずれかの色~classに対する
`stringifiers^m ~object上の~custom文字列化子
— 当の色~classを，~UAにより定義されるいずれかの型に直接的に変換する方が，
`RGBColor$I に先ず変換するより 正確a／効率的 になるのなら。
◎
Custom stringifiers on the stringifiers object for one of the UA-defined color classes, if it’s more accurate/efficient to convert your color class into one of the UA-defined types directly than it is to first convert it into an RGBColor.
</p>

<p class="note">注記：
当の~class自身に，特別な文字列化子を定義することは、一般的には<strong>有用でない</strong>
— 文字列化子の主な目的0は、~objectを CSS ~propに利用できるようにすることであり，~UAにより定義される色~classのみが妥当な CSS 構文に対応するので。
◎
Note: It is not generally useful to define a special stringifier for your class itself; the main purpose of the stringifier is to allow the object to be used in a CSS property, and only the UA-defined color classes correspond to valid CSS syntaxes.
</p>
	</li>
</ul>


<p>
これらすべてを、先に示した HSV 色~class例に適用した結果は、以下の様になる：
◎
All of these apply to our example HSV color class, so let’s see what it looks like with all of these additions:
</p>

<div class="example">

<pre class="lang-javascript">
function HSVColor(...%args) {
  const undefined = void 0;

  if(%args.length == 1 &amp;&amp; %args[0] instanceof RGBColor) {
    /* <span class="comment">
`RGBColor$I 構築子
◎
RGBColor constructor
</span> */
    let {%r, %g, %b, %a} = %rgbcolor;
    %r = ((+%r % 1) + 1) % 1;
    %g = ((+%g % 1) + 1) % 1;
    %b = ((+%b % 1) + 1) % 1;
    %a = Math.min(1, Math.max(0, +%a));

    this.a = %a;

    const %max = Math.max(%r, %g, %b);
    const %min = Math.min(%r, %g, %b);
    const chroma = %max - %min;
    if(%chroma == 0) {
      this.h = 0;
    } else if(%r == %max) {
      this.h = (((%g - %b) / %chroma) % 6) * 360;
    } else if(%g == %max) {
      this.h = ((((%b - %r) / %chroma) + 2) % 6) * 360;
    } else {
      this.h = ((((%r - %g) / %chroma) + 4) % 6) * 360;
    }

    this.v = %max;

    if(%chroma == 0) {
      this.s = 0;
    } else {
      this.s = %chroma/this.v;
    }
    return this;
  } else if(%args.length == 1 &amp;&amp; typeof %args[0] == "string") {
    /* <span class="comment">
文字列を構文解析する構築子
◎
String-parsing constructor
</span> */
    return RGBColor.parse(%args[0]).toHSV();
  } else if(%args.length &lt;= 1) {
    /* <span class="comment">
HSVA に似た~object構築子
◎
HSVA-like object constructor
</span> */
    const {%h, %s, %v, %a} = %args[0];
    this.h = %h === undefined ? 0 : +%h;
    this.s = %s === undefined ? 0 : +%s;
    this.v = %v === undefined ? 0 : +%v;
    this.a = %a === undefined ? 1 : +%a;
    return this;
  } else if(%args.length == 3 || %args.length == 4) {
    /* <span class="comment">
直接的な
<code >(%h, %s, %v, %a)</code>
引数による構築子
◎
Direct (h, s, v, a) arguments constructor
</span> */
    this.h = +%args[0];
    this.s = +%args[1];
    this.v = +%args[2];
    this.a = %args[3] === undefined ? 1 : +%args[3];
    return this;
  }
  throw XXXError();
}

HSVColor.prototype = Object.create(CSSColor.prototype);

HSVColor.prototype.asRGB = function() {
  const %max = this.v * this.s;
  const %h_ = ((this.h / 60 % 6) + 6) % 6;
  const %mid = %max * (1 - Math.abs((%h_ % 2) - 1));

  if(%h_ &gt;= 0 &amp;&amp; %h_ &lt; 1) {
    return new RGBColor(%max, %mid, 0);
  } else if(%h_ &gt;= 1 &amp;&amp; %h_ &lt; 2) {
    return new RGBColor(%mid, %max, 0);
  } else if(%h_ &gt;= 2 &amp;&amp; %h_ &lt; 3) {
    return new RGBColor(0, %max, %mid);
  } else if(%h_ &gt;= 3 &amp;&amp; %h_ &lt; 4) {
    return new RGBColor(0, %mid, %max);
  } else if(%h_ &gt;= 4 &amp;&amp; %h_ &lt; 5) {
    return new RGBColor(%mid, 0, %max);
  } else {
    return new RGBColor(%max, 0, %mid);
  }
}

RGBColor.prototype.asHSV = function(%rgbcolor) {
  return new HSVColor(%rgbcolor);
}
CSSColor.forward("asHSV");

HSVColor.prototype.asHSL = function() {
  /* <span class="comment">
既定の変換子は，先ず RGB を得てから HSL を得るが、それでは，色相~角度の精度が失われ，ひどい 10 進数にしてしまう。
◎
The default converter will first go to RGB,
     then to HSL, which will lose precision in
     the hue angle, making an ugly decimal.
</span> */
  let %h = this.h;
  let %a = this.a;

  let %max = this.v;
  let %chroma = this.v * this.s;
  let %min = %max - %chroma;
  let %l = (%max + %min) / 2;

  let %s;
  if(%chroma == 0) {
    s = 0;
  } else {
    s = %chroma / (1 - Math.abs(2 * %l - 1));
  }

  return new HSLColor(%h, %s, %l, %a);
}

HSLColor.prototype.asHSV = function() {
  /* <span class="comment">
前と同じ
—  HSL → RGB → HSV は、色相の精度を失うことになる。
◎
Same as before; going HSL -&gt; RGB -&gt; HSV
     would lose precision in the hue.
</span> */
    let %h = this.h;
    let %a = this.a;

    const %templ = this.l * 2;
    const %temps = this.s * (%templ &lt;= 1) ? %templ : 2 - %templ;
    const v = (%templ + %temps) / 2;

    let %s;
    if(%templ + %temps == 0) {
      %s = 0;
    } else {
      %s = (2 * %temps) / (%templ + %temps);
    }

    return new HSVColor(%h, %s, %v, %a);
}

HSVColor.stringifiers = {
  "hsl": function(%hsv) {
    return %hsv.toHSL().toString("hsl");
  }
  /* <span class="comment">
`hsv^l 文字列化子 型を定義しないこと。
CSS はそれを解さないので。
◎
Don’t define an "hsv" stringifier type,
     because CSS won’t understand it.
</span> */
}
</pre>


<p>
今や、完全に~~機能する HSV 色~classが得られたことになる。
◎
You now have a complete and functional HSV color class!
</p>
</div>


			</section>
			<section id="api-CSSColor">
<h4 title="The CSSColor Object">15.6.3. `CSSColor^I ~object</h4>

<p>
`CSSColor$I ~objectは、［
すべての色~objectに対する上位classを提供する ／
型検査を支援する ／
種々の~methodに対する既定の実装を提供する
］ために存在する。
その~instanceを構築することはできない。
◎
The CSSColor object exists to provide a super-class for all color objects, to aid in type-testing and to provide default implementations for various methods. It is impossible to construct an instance of it.
</p>

<div class="p">
<p>
加えて、二つの静的~methodも提供する：
</p>

<ul>
	<li>
`parse()$m は、
CSS 色~値を包含している文字列を引数にとり，その値を表現する適切な色~class
返す。
</li>
	<li>
`forward()$m は、すべての色~classに新たな~methodを追加するときに利用できる補助~関数である（この関数の用法についての詳細は、
<a href="#api-adding-methods">色を操作する新たな~methodの追加法</a>
節を見よ）。
</li>
</ul>

◎
In addition, it provides two static methods: parse(), which takes a string containing a CSS color value and returns an appropriate color class representing that value; and forward(), which is a helper function for adding new methods to all color classes (see §15.6.1 Adding New Color-Manipulating Methods for more detail on using this function).
</div>

<div class="example">
<p>
この~interfaceの最も共通的な利用は、色~文字列を構文解析して，適切な色~objectを得ることである。
◎
The most common use of this interface is to parse color strings into an appropriate color object.
</p>

<p>
次の~codeは
%color を `HexColor$I ~objectに設定する：
◎
The following code sets color to a HexColor object:
</p>

<pre class="lang-javascript">
var %color = CSSColor.parse("#96c");
</pre>


<p>
一方で，次の~codeは、 %color を `HSLColor$I ~objectに設定する：
◎
While this code sets color to an HSLColor object:
</p>


<pre class="lang-javascript">
var %color = CSSColor.parse("hsl(120deg, 100%, 50%)");
</pre>

<p>
これは、提供された入力に合致する型の色~classを返すことに注意。
特定0の色~classが欲される場合、代わりに
その~classの構築子に文字列を渡す。
例えば，次の~codeは、 `hsl$f 関数を利用しているが，
%color を `RGBColor$I ~objectに設定する：
◎
Note that this returns a color class matching the type of input provided to it. If a particular color class is desired, the class’s constructor can be passed a string instead. For example, the following will set color to an RGBColor object, even though it uses the hsl() function:
</p>

<pre class="lang-javascript">
var %color = new RGBColor("hsl(120deg, 100%, 50%)")
</pre>
</div>


<pre class="idl">
[<a href="#dom-csscolor-csscolor">Constructor</a>()]
interface `CSSColor@I {
  `RGBColor$I `toRGB$m();

  static `CSSColor$I `parse$m(DOMString %css, optional `Element$I %el);

  DOMString `toString$m(optional `ColorStringifierType$I %type, any... %args);

  static void `forward$m(DOMString %methodName);
  static void `forwardToSameClass$m(DOMString %methodName);

  /* <span class="comment">
既定では転送される変換子
◎
Default, forwarded converters
</span> */
  `HSLColor$I  `toHSL$m();
  `HexColor$I   `toHex$m();
  `CMYKColor$I  `toCMYK$m();
  DOMString? `toName$m();
};
</pre>


<dl class="idl-def">
	<dt id="dom-csscolor-csscolor">CSSColor()</dt>
	<dd>
~XXXError を投出する。
◎
Throw an XXXError.
</dd>
	<dd class="note">注記：
`CSSColor$I は、構築可能なものとして設計されていない
— この節の冒頭の注記を見よ。
◎
Note: CSSColor is not designed to be constructable; see the note at the top of this section.
</dd>

	<dt>`toRGB@m()</dt>
	<dd>
~XXXError を投出する。
◎
Throw an XXXError.
</dd>
	<dd class="note">注記：
すべての
`CSSColor$I
下位classは、この~methodを自身に実装する必要がある。
◎
Note: All CSSColor subclasses have to implement this method themselves.
</dd>

	<dt>`parse@m(DOMString %css, Element %el)</dt>
	<dd class="issue">
文字列を構文解析して，色がどの記法で記されたかに依存して適切な `CSSColor$I 下位classを返すべきである
— 例えば
`CSSColor.parse("hsl(120deg, 100%, 50%");^m を呼んだときは，
`HSLColor$I を返すなど。
%el 引数は、［
`currentcolor^v あるいは［
今後 導入され得る，要素に対し解決される必要があるような将来の色
］］を解決するときに利用される。
文字列から色を構文解析できない場合や,
`currentcolor^v が与えられつつ，その解決-元になる要素がない場合、例外を投出する。
◎
Should parse the string, returning the appropriate CSSColor subclass depending on how the color was written. E.g., return an HSLColor if you call CSSColor.parse("hsl(120deg, 100%, 50%");. The el argument is used to resolve "currentcolor" and any future colors we introduce that need to be resolved against an element. Throws if it can’t parse a color out of the string, or if you give it "currentcolor" but no element to resolve against.
</dd>

	<dt>`toString@m(optional `ColorStringifierType$I %type, any... %args)</dt>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%type, ...%args) {
  var %undefined = void 0;

  if(type !== %undefined) {
    %type = "" + %type;
  } else if(this.constructor.defaultStringifier !== %undefined) {
    %type = "" + this.constructor.defaultStringifier;
  } else {
    %type = "rgb";
  }

  if(/* %type is not a {{ColorStringifierType}} value */) {
    throw XXXError("Invalid stringifier type: " + %type);
  }

  if(this.constructor.stringifiers
    &amp;&amp; this.constructor.stringifiers[%type]) {
    return this.constructor.stringifiers[%type](this, ...%args);
  } else {
    return RGBColor.stringifiers[%type](this.toRGB(), ...%args);
  }
}
</pre>
	</dd>

	<dt>`forward@m(DOMString %methodName)</dt>
	<dd>
この関数は、引数により与えられた名前の~methodを
`RGBColor$I における正準的な定義へ “転送する” ことを自動化する
— 作者は、すべての色~classごとに明示的に~methodの変種を追加することなく，色~objectに新たな~methodを追加できるようになる。
これは、 `CSSColor$I の prototype に~methodの既定の~versionを追加する（明示的に上書きされない限り，すべての下位classから選出されることになる）
— 色を `RGBColor$I に変換して ~methodをそこで呼ぶような。
◎
This function automates "forwarding" methods to a canonical definition in RGBColor, so that authors can add new methods to color objects without having to explicitly add variants of the method to every single color class. It adds a default version of a method to CSSColor.prototype (which will get picked up by all subclasses, unless explicitly overridden) that converts the color into an RGBColor and calls the method there.
</dd>
	<dd class="note">注記：
これが正しく働くためには、作者により定義される色~classは，
<a href="#api-extending">色~classの拡張法</a>
にて定義されるような一定の~methodと挙動を備えてい~MUST。
これらの期待に違反する場合、既定の~methodは，不正に働くか~errorを投出するであろう。
◎
Note: For this to work correctly, author-defined color classes must have certain methods and behavior, as defined in §15.6 Extending the Color Classes. If an author-defined class violates these expectations, defaulted methods might work incorrectly or throw errors.
</dd>
	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%methodName) {
  %methodName = "" + %methodName;
  this.prototype[%methodName] = function(...%args) {
    return this.toRGB()[%methodName](...%args);
  }
}
</pre>
	</dd>

	<dt>`forwardToSameClass@m(DOMString %methodName)</dt>
	<dd>
`forward()$m
~methodと類似するが、［
名前 %methodName の~method
］が色~objectを返すとき，その~methodを呼んだ色~objectと同じ型を返すようにしたいとき、利用される。
◎
Similar to the forward() method, but used when the method returns a color object, and you’d like it to return the same type of color object as you called the method on.
</dd>
	<dd class="example">
<p>
~method上で `forward()$m を利用することは常に安全である
— それが色を返すならば、単に `RGBColor$I になる。
例えば、すべての色~型に
“色を明るくする”
`lighten()^m ~methodを転送させるべく，
`CSSColor.forward("lighten");^c
を利用した場合、
`HSLColor$I ~object上で
`c.lighten(.2)^c
を呼んだときは，明るくされた色が `RGBColor$I ~objectとして戻って来ることになる。
◎
It is always safe to use forward() on a method; if it returns a color, it will just be an RGBColor. For example, if you use CSSColor.forward("lighten"); to forward a lighten(%) method to all color types, when you call c.lighten(.2) on an HSLColor object, you’ll get back the lightened color as an RGBColor object.
</p>

<p>
しかしながら，
`lighten()^m が `HSLColor$I ~object上で呼ばれたときは、おそらく，別の `HSLColor$I ~objectを返すことが 求められるであろう。
`CSSColor.forwardToSameClass("lighten");^c
を利用すれば、これが自動的に起こるようになる。
◎
However, you probably want lighten() called on an HSLColor object to return another HSLColor object. Using CSSColor.forwardToSameClass("lighten"); will make this happen automatically.
</p>

<p>
~~明らかに、~methodが色を返さない場合には，
`forwardToSameClass()$m
を利用するべきでない。
結果は，おそらく求められたものでなくなる
— それは、何であれ，返す値をその色~classの~instanceへ変換しようと試みるので。
◎
Obviously, if a method does not return a color you should not use forwardToSameClass(); the results will probably not be what you want, as it will attempt to convert whatever the return value is into an instance of the color class.
</p>
	</dd>

	<dd>
<p>
次の ECMAScript で定義される：
◎
Defined as follows in ECMAScript:
</p>

<pre class="lang-javascript">
function(%methodName) {
  %methodName = "" + %methodName;
  this.prototype[%methodName] = function(...%args) {
    let %result = this.toRGB()[%methodName](...%args);
    return this.constructor(%result);
  }
}
</pre>
	</dd>

	<dt>`toHSL@m()</dt>
	<dt>`toHex@m()</dt>
	<dt>`toCMYK@m()</dt>
	<dt>`toName@m()</dt>
	<dd>
これらの~methodすべてが `RGBColor$I 上の適切な~methodへ委譲する
— ちょうど
`CSSColor.forward("asHSL")^m,
等々を呼んで作成されたかのように。
◎
All of these methods delegate to the appropriate methods on RGBColor, exactly as if created by calling CSSColor.forward("asHSL"), etc.
</dd>

</dl>


			</section>
		</section>
	</section>
	<section id="system-colors">
<h2 title="Deprecated CSS System Colors">付録 A： 非推奨にされた CSS ~system色</h2>

<div class="p">
<p>
CSS のより早期の~versionは、追加の有名~色~keyword
`deprecated-system-color@t
【非推奨にされた~system色】
をいくつか定義していた。
それらは、 OS の~themeから色を取込むためとして~~意図されていた。
しかしながら、これらの色~名は，次の~~理由から<strong>非推奨にされた</strong>：
</p>
<ul>
	<li>
その元々の目的0（~web~siteの要素を ~native OS に~~相当する見かけにする）には不十分である。
</li>
	<li>
~web頁が~native OS の~dialogを “偽装する” のも容易になり，~security~riskになる。
</li>
</ul>

◎
Earlier versions of CSS defined several additional named color keywords, the &lt;deprecated-system-color&gt;s, which were meant to take their value from operating system themes. These color names have been deprecated, however, as they are insufficient for their original purpose (making website elements look like their native OS counterparts), and represent a security risk, as it makes it easier for a webpage to "spoof" a native OS dialog.
</div>


<p>
~UAは、これらの~keywordを~supportし~MUSTが，それらを
利用者 OS の環境設定に基づかないような “既定の” 値に対応付けるべきである（例えば、すべての “背景” 色は~whiteに, “前景” 色は~blackに対応付けるなど）。
作者は、これらの~keywordを利用しては~MUST_NOT。
◎
User agents must support these keywords, but should map them to "default" values, not based on the user’s OS settings (for example, mapping all the "background" colors to white and "foreground" colors to black). Authors must not use these keywords.
</p>


<dl>
	<dt>`ActiveBorder@vk</dt>
	<dt>`ActiveCaption@vk</dt>
	<dd>
順に、作動中の~windowの［
~border,
~caption
］の色。
◎
Active window border.
◎
Active window caption.
</dd>

	<dt>`AppWorkspace@vk</dt>
	<dd>
複数の文書~interfaceの背景~色。
◎
Background color of multiple document interface.
</dd>

	<dt>`Background@vk</dt>
	<dd>
~desktop背景。
◎
Desktop background.
</dd>

	<dt>`ButtonFace@vk</dt>
	<dt>`ButtonHighlight@vk</dt>
	<dt>`ButtonShadow@vk</dt>
	<dd>
順に、周囲の~border層に因り立体的に現れるような要素の［
~~表面の背景,
光源に照らされている方の~border,
光源から離れた方の~border
］の色。
◎
The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.
◎
The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.
◎
The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.
</dd>

	<dt>`ButtonText@vk</dt>
	<dd>
押buttonの~text。
◎
Text on push buttons.
</dd>

	<dt>`CaptionText@vk</dt>
	<dd>
［
~caption, ~size~box, ~scrollbar矢印~box
］内の~text。
◎
Text in caption, size box, and scrollbar arrow box.
</dd>

	<dt>`GrayText@vk</dt>
	<dd>
不能化-（~grayに）された~text。
この色は、現在の~display~driverが単色の~grayを~supportしない場合には， `#000^v に設定される。
◎
Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.
</dd>

	<dt>`Highlight@vk</dt>
	<dt>`HighlightText@vk</dt>
	<dd>
順に、~control内で選択されている［
~item,
~itemの~text
］の色。
◎
Item(s) selected in a control.
◎
Text of item(s) selected in a control.
</dd>

	<dt>`InactiveBorder@vk</dt>
	<dt>`InactiveCaption@vk</dt>
	<dt>`InactiveCaptionText@vk</dt>
	<dd>
順に，作動中でない~windowの［
~border, ~caption, ~caption内の~text
］の色。
◎
Inactive window border.
◎
Inactive window caption.
◎
Color of text in an inactive caption.
</dd>

	<dt>`InfoBackground@vk</dt>
	<dt>`InfoText@vk</dt>
	<dd>
順に、~tooltip~controlの［
背景, ~text
］の色。
◎
Background color for tooltip controls.
◎
Text color for tooltip controls.
</dd>

	<dt>`Menu@vk</dt>
	<dt>`MenuText@vk</dt>
	<dd>
順に，~menuの［
背景, ~text
］の色。
◎
Menu background.
◎
Text in menus.
</dd>

	<dt>`Scrollbar@vk</dt>
	<dd>
~scrollbarの~gray区画。
◎
Scroll bar gray area.
</dd>

	<dt>`ThreeDDarkShadow@vk</dt>
	<dt>`ThreeDFace@vk</dt>
	<dt>`ThreeDHighlight@vk</dt>
	<dt>`ThreeDLightShadow@vk</dt>
	<dt>`ThreeDShadow@vk</dt>
	<dd>
順に、周囲の~borderの二つの~concentric層に因り立体的に現れるような要素の［
光源から離れた方の二本の~borderのうち 暗い方（一般に外縁）,
~~表面の背景,
光源に照らされている方の二本の~borderのうち 明るい方（一般に外縁）,
光源に照らされている方の二本の~borderのうち 暗い方（一般に内縁）,
光源から離れた方の二本の~borderのうち 明るい方（一般に内縁）
］の色。
◎
The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.
◎
The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.
◎
The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.
◎
The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.
◎
The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.
</dd>

	<dt>`Window@vk</dt>
	<dt>`WindowFrame@vk</dt>
	<dt>`WindowText@vk</dt>
	<dd>
順に、~windowの［
背景,
~frame,
中の~text
］の色。
◎
Window background.
◎
Window frame.
◎
Text in windows.
</dd>
</dl>



	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
各種 色~profileを書き上げて 実装された
Brad Pettit 氏に。
HSL色を書き上げた Steven Pemberton 氏に。
次の方々からの~feedbackに：
</p>


<div>
Thanks to Brad Pettit both for writing up color-profiles, and for implementing it. Thanks to Steven Pemberton for his write up on HSL colors. Thanks especially to the feedback from Marc Attinasi, Bert Bos, Joe Clark, fantasai, Patrick Garies, Tony Graham, Ian Hickson, Susan Lesch, Alex LeDonne, Cameron McCormack, Krzysztof Maczyński, Chris Moschini, Chris Murphy, Christoph Päper, David Perrell, Jacob Refstrup, Dave Singer, Jonathan Stanley, Andrew Thompson, Russ Weakley, Etan Wexler, David Woolley, Boris Zbarsky, Steve Zilles, the XSL FO subgroup of the XSL working group, and all the rest of the www-style community.
</div>

<p>
常駐の CSS Color 専門家である Chris Lilley 氏に。
◎
And thanks to Chris Lilley for being the resident CSS Color expert.
</p>


	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

		<section id="changes-from-3">
<h3 title="Changes from Colors 3">CSS Colors 3 からの変更点</h3>


<ol>

	<li>
`rgb$f ／ `rgba$f
関数は、今や， `integer$t のみならず `number$t を受容する。
◎
rgb() and rgba() functions now accept &lt;number&gt; rather than &lt;integer&gt;.
</li>

	<li>
`hsl$f ／ `hsla$f 
関数は、今や，その色相に対し
`number$t のみならず `angle$t も受容する。
◎
hsl() and hsla() functions now accept &lt;angle&gt; as well as &lt;number&gt; for hues.
</li>

	<li>
`alpha-value$t のすべての利用は、今や，
`number$t のみならず `percentage$t も受容する。
◎
All uses of &lt;alpha-value&gt; now accept &lt;percentage&gt; as well as &lt;number&gt;.
</li>

	<li>
透明度を指定できる 4 桁／8 桁による~hex色が追加された。
◎
4 and 8-digit hex colors have been added, to specify transparency.
</li>

	<li>
未発行の Color Correction 提案が取り込まれたが、正しい挙動を opt-in する~propはまだ。
<!-- ＊https://drafts.csswg.org/css-color-correction-1/ -->
◎
Parts of the unpublished Color Correction proposal, but the property to opt-in to correct behavior was not.
</li></ol>


<p>
新規に，いくつかの特色機能が追加された：
◎
Several brand new features have been added:
</p>

<ol>

	<li>
~grayを~~簡潔に指定する（および，輝度を介する指定もおそらく可能にする）ための
`gray$f 関数。
◎
gray() function, for specifying grays compactly. (And maybe allowing specification via luminance.)
</li>

	<li>
~HWB記法による色を指定する `hwb$f 関数。
◎
hwb() function, for specifying colors in the HWB notation.
</li>

	<li>
色を操作するための `color-mod$f 関数。
◎
color-mod() function, for manipulating colors.
</li>

	<li>
出力~機器に特有の CMYK 色空間に属する色を指定するための `device-cmyk$f 関数。
◎
device-cmyk() function, for specifying colors in an output-device-specific CMYK colorspace.
</li>

	<li>
有名~色に `rebeccapurple$v を追加。
◎
Addition of named color rebeccapurple.
</li></ol>

		</section>
	</section>

</main></div>

	<section id="conformance">
<h2 title="Conformance">適合性</h2>
<p class="trans-note">【
この節の内容は
<a href="css-common-ja.html#conformance">CSS 日本語訳 共通ページ</a>
に委譲
】</p>

<!-- 
 Conformance
Document conventions

Conformance requirements are expressed with a combination of descriptive assertions and RFC 2119 terminology. The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in RFC 2119. However, for readability, these words do not appear in all uppercase letters in this specification.

All of the text of this specification is normative except sections explicitly marked as non-normative, examples, and notes. [RFC2119]

Examples in this specification are introduced with the words "for example" or are set apart from the normative text with class="example", like this:

This is an example of an informative example.

Informative notes begin with the word "Note" and are set apart from the normative text with class="note", like this:

Note, this is an informative note.

Advisements are normative sections styled to evoke special attention and are set apart from other normative text with <strong class="advisement">, like this:
UAs MUST provide an accessible alternative.
Conformance classes

Conformance to this specification is defined for three conformance classes:

style sheet
    A CSS style sheet. 
renderer
    A UA that interprets the semantics of a style sheet and renders documents that use them. 
authoring tool
    A UA that writes a style sheet. 

A style sheet is conformant to this specification if all of its statements that use syntax defined in this module are valid according to the generic CSS grammar and the individual grammars of each feature defined in this module.

A renderer is conformant to this specification if, in addition to interpreting the style sheet as defined by the appropriate specifications, it supports all the features defined by this specification by parsing them correctly and rendering the document accordingly. However, the inability of a UA to correctly render a document due to limitations of the device does not make the UA non-conformant. (For example, a UA is not required to render color on a monochrome monitor.)

An authoring tool is conformant to this specification if it writes style sheets that are syntactically correct according to the generic CSS grammar and the individual grammars of each feature in this module, and meet all other conformance requirements of style sheets as described in this module.
Partial implementations

So that authors can exploit the forward-compatible parsing rules to assign fallback values, CSS renderers must treat as invalid (and ignore as appropriate) any at-rules, properties, property values, keywords, and other syntactic constructs for which they have no usable level of support. In particular, user agents must not selectively ignore unsupported component values and honor supported values in a single multi-value property declaration: if any value is considered invalid (as unsupported values must be), CSS requires that the entire declaration be ignored.
Experimental implementations

To avoid clashes with future CSS features, the CSS2.1 specification reserves a prefixed syntax for proprietary and experimental extensions to CSS.

Prior to a specification reaching the Candidate Recommendation stage in the W3C process, all implementations of a CSS feature are considered experimental. The CSS Working Group recommends that implementations use a vendor-prefixed syntax for such features, including those in W3C Working Drafts. This avoids incompatibilities with future changes in the draft.
Non-experimental implementations

Once a specification reaches the Candidate Recommendation stage, non-experimental implementations are possible, and implementors should release an unprefixed implementation of any CR-level feature they can demonstrate to be correctly implemented according to spec.

To establish and maintain the interoperability of CSS across implementations, the CSS Working Group requests that non-experimental CSS renderers submit an implementation report (and, if necessary, the testcases used for that implementation report) to the W3C before releasing an unprefixed implementation of any CSS features. Testcases submitted to W3C are subject to review and correction by the CSS Working Group.

Further information on submitting testcases and implementation reports can be found from on the CSS Working Group’s website at http://www.w3.org/Style/CSS/Test/. Questions should be directed to the public-css-testsuite@w3.org mailing list. 
-->



	</section>
	<section id="references">
<h2 title="References">参照文献</h2>


		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>




<dl>

	<dt>[CSS-POSITION-3]</dt>
	<dd>CSS Positioned Layout Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-position-3/</dd>

	<dt>[CSS-SYNTAX-3]</dt>
	<dd>Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-syntax/</dd>

	<dt>[CSS-VALUES]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 11 June 2015. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-values/</dd>

	<dt>[CSS21]</dt>
	<dd>Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC.</dd>
	<dd>http://www.w3.org/TR/CSS2</dd>

	<dt>[FILTERS-1]</dt>
	<dd>Filter Effects Level 1</dd>
	<dd>https://drafts.fxtf.org/filters-1/</dd>

	<dt>[MEDIAQUERIES-4]</dt>
	<dd>Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4. 26 January 2016. WD.</dd>
	<dd>http://dev.w3.org/csswg/mediaqueries4/</dd>

	<dt>[RFC2119]</dt>
	<dd>S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc2119</dd>

	<dt>[SELECTORS-4]</dt>
	<dd>Selectors Level 4</dd>
	<dd>https://drafts.csswg.org/selectors-4/</dd>

	<dt>[SRGB]</dt>
	<dd>Multimedia systems and equipment - Colour measurement and management - Part 2-1: Colour management - Default RGB colour space - sRGB. IEC 61966-2-1 (1999-10). ISBN: 2-8318-4989-6 - ICS codes: 33.160.60, 37.080 - TC 100 - 51 pp.</dd>
	<dd>http://www.iec.ch/nr1899.htm</dd>

	<dt>[SVG11]</dt>
	<dd>Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC.</dd>
	<dd>http://www.w3.org/TR/SVG11/</dd>

	<dt>[SVG2]</dt>
	<dd>Nikos Andronikos; et al. Scalable Vector Graphics (SVG) 2. 15 September 2015. WD.</dd>
	<dd>https://svgwg.org/svg2-draft/</dd>
	
	<dt>[WebIDL-1]</dt>
	<dd>Cameron McCormack; Boris Zbarsky. WebIDL Level 1. 8 March 2016. CR.</dd>
	<dd>https://heycam.github.io/webidl/</dd>


	<dt>[WHATWG-DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>
</dl>




		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>




<dl>

	<dt>[COLORIMETRY]</dt>
	<dd><cite>Colorimetry, Second Edition.</cite> CIE Publication 15.2-1986. ISBN 3-900-734-00-3
   </dd>

	<dt>[CSS3-TEXT-DECOR]</dt>
	<dd>Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 3. 1 August 2013. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-text-decor-3/</dd>

	<dt>[WCAG20]</dt>
	<dd>Ben Caldwell; et al. Web Content Accessibility Guidelines (WCAG) 2.0. 11 December 2008. REC.</dd>
	<dd>http://www.w3.org/TR/WCAG20/</dd>
</dl>

		</section>
	</section>

	<section id="index">
<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>


<!-- 
		<section id="index-defined-here">
<h3 title="Terms defined by this specification"></h3>

		</section>
-->

	</section>
	<section>
<h2 id="property-index" title="Property index" data-cycling=".propdef">プロパティ索引</h2>
<h2 id="idl-index" title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<h2 id="issues-index" title="Issues Index" data-cycling=".issue">課題索引</h2>

<p class="trans-note">【
これらの節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>

