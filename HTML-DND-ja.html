<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Drag and drop （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/interaction.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160323 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		ps: 'pseudo',
		P: 'production',
		p: 'property',
		st: 'attr-state',
		css: 'css',
		v: 'value',
		E: 'error',
		uc: 'unicode-category', // Unicode character class
		h: 'header',
		cm: 'comment',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		hd: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		ps: 'code',
		st: 'span',
		h: 'code',
		P: 'code',
		p: 'code',
		css: 'code',
		uc: 'span',
		V: 'var',
		v: 'code',
		cm: 'span',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
//	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN', '_toc_list0');


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
//var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'tE':
case 'tD':
case 'op':
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a': // event type
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'et': // event type
	break;
case 'i': // model constants
	break;
case 'h': // http header
	text = '<code class="header">' + text + '</code>';
	break;
case 'v': // attr value
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
</script>


<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">

I.DataTransfer:#datatransfer
I.DataTransferItem:#datatransferitem
I.DataTransferItemList:#datatransferitemlist
I.DragEvent:#dragevent
I.DragEventInit:#drageventinit
I.Element:~DOM4#interface-element
I.Document:~HTMLDOM#document
I.File:~FILEAPI#file
I.FileList:~FILEAPI#filelist-section
I.FunctionStringCallback:#functionstringcallback
I.MouseEvent:~UIEVENTS#interface-MouseEvent
I.MouseEventInit:~UIEVENTS#idl-def-MouseEventInit
I.Text:~DOM4#interface-text
I.Window:~BROWSERS#window
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotSupportedError:~WEBIDL#notsupportederror

■DOM
m.add:#dom-datatransferitemlist-add
m.clear:#dom-datatransferitemlist-clear
m.clearData:#dom-datatransfer-cleardata
m.dataTransfer:#dom-dragevent-datatransfer
m.draggable:#dom-draggable
m.dropzone:#dom-dropzone
m.dropEffect:#dom-datatransfer-dropeffect
m.effectAllowed:#dom-datatransfer-effectallowed
m.files:#dom-datatransfer-files
m.getAsFile:#dom-datatransferitem-getasfile
m.getAsString:#dom-datatransferitem-getasstring
m.getData:#dom-datatransfer-getdata
m.getter:#dom-datatransferitemlist-item

m.items:#dom-datatransfer-items
m.kind:#dom-datatransferitem-kind
m.length:#dom-datatransferitemlist-length

m.remove:#dom-datatransferitemlist-remove
m.setData:#dom-datatransfer-setdata
m.setDragImage:#dom-datatransfer-setdragimage
m.type:#dom-datatransferitem-type
m.types:#dom-datatransfer-types
	＊
m.relatedTarget:~UIEVENTS#dom-mouseevent-relatedtarget
	widl-MouseEvent-relatedTarget
m.detail:~UIEVENTS#dom-uievent-detail
	widl-UIEvent-detail
m.view:~UIEVENTS#dom-uievent-view
	widl-UIEvent-view
m.dataset:~HTMLDOM#dom-dataset

tE.all:#dom-datatransfer-effectallowed-all
tE.copy:#dom-datatransfer-effectallowed-copy
tE.copyLink:#dom-datatransfer-effectallowed-copylink
tE.copyMove:#dom-datatransfer-effectallowed-copymove
tE.link:#dom-datatransfer-effectallowed-link
tE.linkMove:#dom-datatransfer-effectallowed-linkmove
tE.move:#dom-datatransfer-effectallowed-move
tE.none:#dom-datatransfer-effectallowed-none
tE.uninitialized:#dom-datatransfer-effectallowed-uninitialized

tD.copy:#dom-datatransfer-dropeffect-copy
tD.link:#dom-datatransfer-dropeffect-link
tD.move:#dom-datatransfer-dropeffect-move
tD.none:#dom-datatransfer-dropeffect-none

op.copy:#concept-current-drag-operation-copy
op.link:#concept-current-drag-operation-link
op.move:#concept-current-drag-operation-move
op.none:#concept-current-drag-operation-none

	■elem
e.a:~HTMLtextlevel#the-a-element
e.div:~HTMLgrouping#the-div-element
e.img:~HTML-EMB#the-img-element
e.input:~HTML-FORMS#the-input-element
e.object:~HTML-EMB#the-object-element
e.textarea:~HTML-FORMS#the-textarea-element

	■attr
a.contenteditable:~HTML-INTERACTION#attr-contenteditable
a.href:~HTMLlinks#attr-hyperlink-href
a.src:~HTML-EMB#attr-img-src
a.title:~HTMLDOM#attr-title
a.type:~HTML-FORMS#attr-input-type

a.draggable:#the-draggable-attribute
a.accesskey:#the-accesskey-attribute
a.dropzone:#the-dropzone-attribute
a.aria-describedby:https://w3c.github.io/aria/aria/aria.html#aria-describedby

v.copy:#attr-dropzone-copy
v.link:#attr-dropzone-link
v.move:#attr-dropzone-move

■event
et.drag:#event-dnd-drag
et.dragend:#event-dnd-dragend
et.dragenter:#event-dnd-dragenter
et.dragexit:#event-dnd-dragexit
et.dragleave:#event-dnd-dragleave
et.dragover:#event-dnd-dragover
et.dragstart:#event-dnd-dragstart
et.drop:#event-dnd-drop
	et.blur:~HTML5/indices.html#event-blur
et.mousedown:~UIEVENTS#event-type-mousedown
et.mousemove:~UIEVENTS#event-type-mousemove

st.E-mail:~HTML-FORMS#e-mail-state-(type=email)
st.Number:~HTML-FORMS#number-state-(type=number)
st.Password:~HTML-FORMS#password-state-(type=password)
st.Search:~HTML-FORMS#text-(type=text)-state-and-search-state-(type=search)
st.Tel:~HTML-FORMS#telephone-state-(type=tel)
st.Text:~HTML-FORMS#text-(type=text)-state-and-search-state-(type=search)
st.URL:~HTML-FORMS#url-state-(type=url)

l.application/microdata+json:~HTML5/iana.html#application/microdata+json
l.application/octet-stream:~IETF/rfc2046#section-4.5.1
l.text/plain:~IETF/rfc2046#section-4.1.3
l.text/uri-list:~HTML5/indices.html#text/uri-list

	●
~text編集域:#_text-edit
正規化-:#_normalize-a-format
~drag演算の最終回~手続き:#_the-last-DND-steps
~drag演算の継続~手続き:#_continuation-DND-steps

現在の標的~要素:#current-target-element
有index~propを決定-:#dom-datatransferitemlist-item
x.有index~propを決定-:~WEBIDL#dfn-determine-the-value-of-an-indexed-property

~DnD演算が起動され:#initiate-the-drag-and-drop-operation
起動され:#initiate-the-drag-and-drop-operation
~drag-data~store:#drag-data-store
1.~drag-data~store:#_drag-data-store

dS.作成-:#create-a-drag-data-store
dS.許容される効果state:#drag-data-store-allowed-effects-state
dS.既定の~feedback:#drag-data-store-default-feedback
dS.~bitmap:#drag-data-store-bitmap
dS.~hot-spot座標:#drag-data-store-hot-spot-coordinate
dS.~item~list:#drag-data-store-item-list

dS.~mode:#drag-data-store-mode
~store~mode:#_store-mode
1.~store~mode:#_item-list-mode
~item~mode:#_item-mode
外部のもの:#_external

i.被保護~mode:#concept-dnd-p
i.読専~mode:#concept-dnd-ro
i.可書~mode:#concept-dnd-rw
i.不能化~mode:#_dnd-disabled


~drag-data~item:#_drag-data-item
~item:#_drag-data-item
	＊dI.~drag-data~item種類:#the-drag-data-item-kind
dI.種類:#the-drag-data-item-kind
	＊dI.~kind:#the-drag-data-item-kind
	＊dI.~drag-data~item型~文字列:#the-drag-data-item-type-string
dI.型~文字列:#the-drag-data-item-type-string
	~type:#the-drag-data-item-type-string
dI.実data:#_the-drag-data-item-actual-data

~DND~eventを発火-:#fire-a-dnd-event
現在の~drag演算:#current-drag-operation
V.~source~node:#source-node
V.被~drag~node~list:#list-of-dragged-nodes
V.~store:#_store
代替の選択肢:#concept-platform-dropeffect-override
直の利用者~選択:#immediate-user-selection

~dropzone処理~手続き:#dropzone-processing-steps
	合致する:#concept-dropzone-match
~dropzone合致する:#concept-dropzone-match
指定する~drag演算:#concept-dropzone-operation

読専の配列:~HTMLCONFORM#dfn-read-only-array
~ASCII大小無視:~HTMLINFRA#ascii-case-insensitive
配送-:~HTMLINFRA#concept-event-dispatch
~HTML要素:~HTMLINFRA#html-elements
~ASCII小文字化:~HTMLINFRA#converted-to-ascii-lowercase
列挙~属性:~HTMLINFRA#enumerated-attribute
~MIME型:~HTMLINFRA#mime-type
妥当でない値に対する既定:~HTMLINFRA#invalid-value-default
値なしに対する既定:~HTMLINFRA#missing-value-default
相対的に構文解析-:~HTMLINFRA#parse-a-url
結果の~URL文字列:~HTMLINFRA#resulting-url-string
反映-:~HTMLINFRA#reflect
空白類:~HTMLINFRA#space-character
空白並びで分割-:~HTMLINFRA#split-a-string-on-spaces
~trusted:~HTMLINFRA#concept-events-trusted
空白区切りの一意な~tokenからなる無順序~集合:~HTMLINFRA#unordered-set-of-unique-space-separated-tokens
~live:~HTMLINFRA#live

文書:~HTMLDOM#document
~body要素:~HTMLDOM#the-body-element-2
閲覧文脈:~BROWSERS#browsing-context
~taskを待入する:~WAPI#queue-a-task
待入する:~WAPI#queue-a-task
表現-:~HTMLDOM#represents

x.絶対~URL:~URLSpec#syntax-url-absolute
x.相対~URL:~URLSpec#syntax-url-relative
x.~node文書:~DOM4#concept-node-document
x.被support~token:~DOM4#concept-supported-tokens
x.木~順序:~DOM4#concept-tree-order
x.範囲~obj:~DOM4#concept-range

x.内在的~size:~CSS2CONFORM#intrinsic
x.被support~prop~index:~WEBIDL#dfn-supported-property-indices
x.表示域:~CSS2VISUREN#viewport
x.CSS ~pixel単位:~CSSVAL#px

編集可能:~EXEC-COMMAND#editable
編集中の~host:~EXEC-COMMAND#editing-host
	作動範囲:~EXEC-COMMAND#active-range
選択を削除-:~EXEC-COMMAND#delete-the-selection

</script>


<!--% 置換データ -->
<script type="text/plain" id="words_table1">
HTML-FORMS:https://html.spec.whatwg.org/multipage/forms.html
HTML-EMB:https://html.spec.whatwg.org/multipage/embedded-content.html
HTML-INTERACTION:https://html.spec.whatwg.org/multipage/interaction.html
EXEC-COMMAND:https://w3c.github.io/editing/execCommand.html

此れ:<b>これ°</b>
</script>


<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">
API:
ASCII:
CSS:
DOM:
HTML:
IDL:
JSON:
MIME:
Unicode:
URL:

body::::
call::::
callback::::
code::::コード
custom::::カスタム
形:form:~
	missed frame
token::::トークン
	ふるいにかける:filter

keyword::::キーワード
	-:label
	時点:moment::::
	time::::

list::::リスト
markup::::マークアップ
microdata:

index:
有index:indexed::有 index
interface::::インタフェース
prop:property:::プロパティ
method::::メソッド
script::::スクリプト

zero::::ゼロ
url:
Web::::
window:

	●DnD
DND::::
DnD:drag-and-drop::drag＆drop
drag-data:drag data:::drag データ
dragging:
draggable:::drag 可能
drag:
drop::::
dropped::::
dropzone::::
	dragged:::drag 対象

source::::ソース
	源:source::~::ソース
text::::テキスト
mode::::モード

読専:read-only::~
可書:read/write::~
被保護:protected::保護

store::::ストア
	格納
item::::アイテム
entry::::エントリ
実data:actual data::実 data:実データ
data::::データ
種類:kind:~

binary::::バイナリ
field::::フィールド
control::::コントロール
file::::ファイル

複製-:copy:~
移動-:move:~
link::::リンク

演算:operation:操作
feedback::::フィードバック
座標:coordinate:~
画像:image:~
hot-spot::::
bitmap::::ビットマップ

選択-:select:~
選択:selection:~

起動-:initiate:~

編集中の:editing:~
編集可能:editable:~
編集域:edit 域:~
host::::ホスト

下層の:underlying:~
下層にあ:underlie す:~
不能化:disabled:~
可能化-:enable:~
受容-:accept:~
合致-:match:~

	●UI／CSS
UI:
size::::サイズ
pixel::::ピクセル
key::::キー
keyboard::::キーボード
animate::::アニメート
button::::ボタン
cursor::::カーソル
mouse::::マウス
pointing::::ポインタ指示
scroll::::スクロール
scrollable::::スクロール可能
copy::::コピー
paste::::ペースト
上端:top:~
左端:left:~
下端:bottom:~
視覚的:visual:~
集合:set:~
表示域:viewport:~
辺:edge:~
領域:region:~
交差-:intersect:~
距離:distance:~
描画:rendering:~
報告-:report:~
媒体:media::~::メディア
	medium
対話:interaction:~
所在:location:~
表示-:display:~
表示:display:~
解放-:release:~
入力方式:input modality:~
内在的:intrinsic:~
閲覧文脈:browsing context:~
押下げら:depress さ:~
押下げて:depress して:~
入力:input:~
通過-:cross:~
直の:immediate:~


	●event
trusted:
composed:
event::::イベント
click::::クリック
標的:target::~::ターゲット
浮上-:bubble::~
配送-:dispatch::~
handler::::ハンドラ
listener::::リスナ
listen:
task::::タスク

待入する:queue する::待ち行列に入れる::キューする
取消:cancel:~
取消して:cancel して:取り消して
取消され:cancel され:取り消され
取消ion:cancelation:取り消し
取消可能:cancelable:取り消し可能
取消可否:cancelable:~
誘発-:trigger:~
発火-:fire:~
既定の:default:~:::デフォルト
既定:default:~:::デフォルト


live::::

	●
木:tree::~::ツリー
node::::ノード
obj:object:::オブジェクト
先祖:ancestor:~
文書:document:~


上書き:override:~
開始:start:~
代替:alternative:~
代替の:alternate:~
位置-:position:~
作動中の:active:~
作動化-:activate:~
作成-:create:~
依存-:depend:~
	押しながらの-:hold:~
値:value:~


停止-:stop:~
公開-:expose:~
内容:content:~
再設定-:reset:~
分断-:break:~
	-:separate:~
削除-:delete:~

包含-:contain:~
単純:simple:~
参照:reference:~

	合間:between:~
名前:name:~
命名-:name:~
型:type:~
	基づく:basis:~

変更-:change:~
変化-:change:~
	変更されないまま:left unchanged
外側:outside:~
有効:valid:~
妥当:valid:~
始点:starting point:~
終点:end point:~
地点:point:~
完全:complete:~
属性:attribute:~

引数:argument:~
形式:format::~::フォーマット
挿入-:insert:~
更新-:update:~

文字:character:~
文字列:string:~
小文字:lowercase:~
小文字化:lowercase 化:~

文脈:context:~
新たな:new:~
	新たに:newly:~
検査-:check:~
生成-:generate:~
生産-:produce:~

登録-:register:~
省略-:omit:~
省略可:optional:~

確立-:establish:~
設定-:set:~
追加-:add:~
連結-:concatenate:~
除去-:remove:~
分割-:split:~
抽出-:extract:~

構文解析-:parse::~::パース
大小無視:case-insensitive:~
順序:order:~
無順序:unordered:~
空白並び:spaces:~
空白区切りの:space-separated:~
空白類:space characters:~

要請-:request:~
置換-:replace:~
表現-:represent:~

見出され:find され:~
読取れる:read できる:読み取れる

状態:state:~
現在:currently:~
現在の:current:~
環境:environment:~
直接的:direct:~
頁:page:::ページ
列挙:enumerated:~
列挙-:enumerate:~
反映-:reflect:~
構築子:constructor::~::コンストラクタ
空:empty:~

範囲:range:~
組合せ:combination:~

相対的:relative:~
相対:relative:~
絶対:absolute:~

自動:auto:~
装置:device:~
要素:element:~

部分的:partial:~
配列:array:~
範囲:range:~

	●
継続-:continue:~
継続:continuation:~
処理:processing:~
段:step:~
手続き:steps:~
下位手続き:substeps:~
抑止-:suppress:~
失敗-:fail:~
成功:success:~
	成功した:successful:~
	成功しなかった:unsuccessful::~
algo:algorithm:::アルゴリズム
hint::::ヒント
制御-:control:~
被取得時:被 get 時:~
被呼出時:被 invoke 時:~
被設定時:被 set 時:~
	進行中:ongoing:~
走らす:run する:走らせる
走らせ:run し:走らせ
走って:run して:~
遂行-:perform:~
飛ばす:skip する:~
初期化-:initialize:~
初期:initial:~
判別-:distinguish:~
動作-:act:~
動作:action:~:::アクション
	反復:iteration:~
反応-:react:~
呼出す:invoke する:呼び出す
呼出され:invoke され:呼び出され
待機-:wait:~

	●保安
security::::セキュリティ
risk::::リスク
site::::サイト
sensitive::::
XSS:cross-site scripting
攻撃:attack:~
敵対的:hostile:~
特権:privilege:~
同意:consent:~
安全:safe:~
安全な:safe:~
	安全でない:unsafe
	既知の安全:known-safe
傍受-:intercept:~
被害:victim:~

予期-:expect:~
	予期されない:unexpected

	●仕様
version::::バージョン
UA:user agent:UA
app:application:::アプリ
browser::::ブラウザ
model::::モデル
platform::::プラットフォーム
	platform特有の:platform-specific#4
program::::プログラム
support::::サポート
被support:supported:::被サポート
system::::システム
選択肢:option:~
述べる:describe する:~
防止-:prevent:~
孕む:involve する:~
孕まれ:involve され:~
整合する:consistent な:~
適切:appropriate:~
選好-:prefer:~
	選好:preference:~
利用者:user:~
一意:unique:~
一意な:unique:~
対応付ける:map する:~
効果:effect:~
効果state:effect state:効果
作者:author:~
	であろう:likely
制限-:limit:~
可能0:possible:可能
指定-:specify:~
指示-:indicate:~
挙動:behavior:ふるまい
提供-:provide:~
規約:conventions:~
取扱う:handle する:~
取扱って:handle して:~
可用:available:~
	可用でない:unavailable
定義-:define:~
定義:definition:~
実装-:implement:~
実質的に:effectively:~
実際:actual:~
尊守-:honor:~
協調-:coordinate:~
影響-:affect:~
情報:information:~
意味-:mean:~
意図:intention:~
奨励-:encourage:~
一般:general:~
一貫性:consistency:~
事例:case:~
理由:reason:~
仕方:way:~
仕様:spec:~
仕様化-:specify:~
仕組み:mechanism:~

重要:important:~
関係-:relate:~
	当の:relevant:~
含意-:imply:~
感知-:aware:~
所与の:与えられた
指図-:dictate:~
駆動の:-driven:~

方式:manner:~
強制-:enforce:~
既知の:known:~
既知:known:~
旧来の:legacy:~
明示的:explicit:~
暗黙の:implied:~
有用:useful:~
概して:typical に:~
無視-:ignore:~
特別:special:~
	特別に扱われる:special-cased
特定0の:particular:ある特定の
特有の:-specific な:~
特色機能:feature:~
状況:situation:~
独立:independent:~
正確:exact:~
決定-:determine:~
	目的0:purpose:目的
確保-:ensure:~
結付ける:associate する:結び付ける
結付けら:associate さ:結び付けら
結付けて:associate して:結び付けて
考慮-:consider:~
見なさ:consider さ:~
	考える:consider する:~
	~~管理:manager:~
要求-:require:~
	要覧:summary:~
許容-:allow:~
試みた:attempt した:~
試行-:try:~
特色機能:feature:~


</script>

<!--%style -->
<style type="text/css">
*[lang="en"] {
	white-space: pre-line;
}

pre {
	white-space: pre-wrap;
}

.attr-state {
	font-family: sans-serif0, sans-serif;
}

</style>
<!-- 

.unicode-category {
	color: green;
}

.category-list > li {
	display: inline;
}
.category-list > li::before {
	content: "• ";
}
-->
</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML — Drag and drop 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">User interaction</a>
章の 6.7 節 Drag and drop を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-09-02</time>
（公開：<time>2016-03-24</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header id="head">
	<hgroup>
<h1>Drag and drop</h1>
<h2>HTML Living Standard — 最終更新 2016 年 9 月 1 日</h2>
	</hgroup>
</header>

<nav class="toc" id="toc">
<h2>目次</h2>
<ol id="_toc_list0"></ol></nav>

<hr>

<main id="MAIN" style="display:none;">


		<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW, 此れ, 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
“ε” と記される特殊~値は、存在しないことを表現し，自身以外のどの値とも異なる値として用いられる。
</p>

		</section>
		<section id="dnd">
<h2 title="Drag and drop">6.7. ~DnD</h2>

<p>
この節では、~eventに基づく~DnDの仕組みを定義する。
◎
This section defines an event-based drag-and-drop mechanism.
</p>


<p>
この仕様は、実際の<em>~DnD演算</em>（ “引きずって落とす” ）が正確に何であるかは，定義しない：
◎
This specification does not define exactly what a drag-and-drop operation actually is.
</p>

<ul>
	<li>
~pointing装置を備える視覚的~媒体では、~drag演算は［
`mousedown$et ~eventに~~後続する一連の `mousemove$et ~event
］に対する既定~動作にもなり得る~dropは、~mouseを解放して誘発し得る。
◎
On a visual medium with a pointing device, a drag operation could be the default action of a mousedown event that is followed by a series of mousemove events, and the drop could be triggered by the mouse being released.
</li>

	<li>
~pointing装置~以外の入力方式を利用する下で~DnD演算を遂行するためには、利用者はおそらく，何を~dragして，どこへ~dropしたいか定めるため，自身の意図を明示的に指示する必要がある。
◎
When using an input modality other than a pointing device, users would probably have to explicitly indicate their intention to perform a drag-and-drop operation, stating what they wish to drag and where they wish to drop it, respectively.
</li>

</ul>

<div class="p">

<p>
どう実装されていようが、~DnD演算では：
</p>

<ol>
	<li>
まず、始点が~~存在し~MUST（例：
~mouseが~clickされた所 ／
~dragに先立って選択されていた［
要素, または［
選択~部分の開始
］］）。
</li>
	<li>
次に， 0 回以上の中間的な段が生じる（例：［
~drag中に~mouseが~~重なった要素 ／
利用者が可能0な~drop地点を巡回するに伴い，選んだ要素
］に対し）。
</li>
	<li>
最後に、取消されるか, または
終点が~~存在し~MUST（例：
~mouse~buttonが解放された所の要素 ／
最終的に選択された要素
）。
終点は、~dropが生じる前の可能0な~drop地点として，最後の要素が選択され~MUST（よって，演算が取消されなかった場合、前項の中間的な段が 1 回は生じ~MUST）。
</li>

</ol>
◎
However it is implemented, drag-and-drop operations must have a starting point (e.g. where the mouse was clicked, or the start of the selection or element that was selected for the drag), may have any number of intermediate steps (elements that the mouse moves over during a drag, or elements that the user picks as possible drop points as they cycle through possibilities), and must either have an end point (the element above which the mouse button was released, or the element that was finally selected), or be canceled. The end point must be the last element selected as a possible drop point before the drop occurs (so if the operation is not canceled, there must be at least one element in the middle step).
</div>





			<section id="event-drag">
<h3 title="Introduction">6.7.1. 序論</h3>

~INFORMATIVE

<p>
要素を~draggableにすることは単純である
— 要素に `draggable$a 属性を付与した上で，
`dragstart$et ~eventに対する~event~listenerを設定するだけである。
~dragされている~dataは、この~eventに~storeされる。
◎
To make an element draggable is simple: give the element a draggable attribute, and set an event listener for dragstart that stores the data being dragged.
</p>

<div class="p">
<p>
~event~handlerは、概して，次をする必要がある：
</p>

<ol ><li>~drag対象が~text選択でないことを検査して，
</li><li>~dataを `DataTransfer$I ~objの中に~storeして，
</li><li>許容される効果（複製-, 移動-, ~link, これらの組合せ）を設定する。
</li></ol>

◎
The event handler typically needs to check that it's not a text selection that is being dragged, and then needs to store data into the DataTransfer object and set the allowed effects (copy, move, link, or some combination).
</div>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre>
&lt;p&gt;好きな果物は？&lt;/p&gt;
&lt;ol ondragstart="dragStartHandler(event)"&gt;
 &lt;li draggable="true" data-value="果物.林檎"&gt;りんご&lt;/li&gt;
 &lt;li draggable="true" data-value="果物.蜜柑"&gt;みかん&lt;/li&gt;
 &lt;li draggable="true" data-value="果物.桃"&gt;もも&lt;/li&gt;
&lt;/ol&gt;
&lt;script&gt;
  var %internalDNDType
      = 'text/x-example'; // `~site特有の何かに設定する^cm
  function dragStartHandler(%event) {
    if (%event.target instanceof HTMLLIElement) {
      // `要素の data-value 属性を，~dragされる値に利用する：^cm
      %event.dataTransfer.setData(
          %internalDNDType,
          %event.target.`dataset$m.value
      );
      %event.dataTransfer.effectAllowed
          = 'move'; // `移動-のみ許容する^cm
    } else {
      %event.preventDefault(); // `選択の~dragは許容しない^cm
    }
  }
&lt;/script&gt;
</pre>

<!-- 
What fruits do you like?
data-value="fruit-apple">Apples</li>
data-value="fruit-orange">Oranges</li>
data-value="fruit-pear">Pears</li>

// set this to something specific to your site
// use the element's data-value="" attribute as the value to be moving:
// only allow moves
// don't allow selection to be dragged

-->

</div>

<hr>


<p>
~drop標的が~dropを受容するためには、
`dropzone$a 属性を有していて，かつ
`drop$et ~eventを~listenする必要がある。
◎
To accept a drop, the drop target has to have a dropzone attribute and listen to the drop event.
</p>


<p>
`dropzone$a 属性の値は、受容する~dataの種類を指定した上で（例： 
~~任意の~text文字列を受容させたければ，
`string:text/plain^l ／
PNG 画像~fileを受容させたければ，
`file:image/png^l
など），~feedbackの種類を与える（例：
~dataを移動することを指示したければ `move^l ）。
◎
The value of the dropzone attribute specifies what kind of data to accept (e.g. "string:text/plain" to accept any text strings, or "file:image/png" to accept a PNG image file) and what kind of feedback to give (e.g. "move" to indicate that the data will be moved).
</p>


<p class="note">注記：
`dropzone$a 属性を利用する代わりに、~drop標的にて［
`dragenter$et, `dragover$et
］~eventを取扱うこともできる（前者により，当の~drop標的は~dropを受容するかどうか報告し、後者により，利用者にどのような~feedbackを示すかを指定する）。
◎
Instead of using the dropzone attribute, a drop target can handle the dragenter event (to report whether or not the drop target is to accept the drop) and the dragover event (to specify what feedback is to be shown to the user).
</p>


<p>
`drop$et ~eventにより、実際の~dropを遂行できるようになる。
~sourceが `dropEffect$m 属性~値を利用できるようになるためには、この~eventは，取消される必要がある（他の場合、それは再設定される）†。
◎
The drop event allows the actual drop to be performed. This event needs to be canceled, so that the dropEffect attribute's value can be used by the source (otherwise it's reset).
</p>

<p class="trans-note">【†
さもなければ、代わりに，~UAによる既定の動作が行われる
— ~dropされた~fileを開く，~textを~text~controlに挿入するなど。
】</p>


<div class="example">

<p>
例えば:
◎
For example:
</p>


<pre>
&lt;p&gt;好みの果物を下に~dropしてください。&lt;/p&gt;
&lt;ol dropzone="move string:text/x-example" ondrop="dropHandler(%event)"&gt;
 &lt;!--  `"text/x-example" 型を ~site特有の何かに変更し忘れないこと。^cm
  --&gt;
&lt;/ol&gt;
&lt;script&gt;
  var %internalDNDType
      = 'text/x-example'; // `~site特有の何かに設定する^cm
  function dropHandler(%event) {
    var %li = document.createElement('li');
    var %data = %event.dataTransfer.getData(%internalDNDType);
    if (%data == '果物.林檎') {
      %li.textContent = 'りんご';
    } else if (%data == '果物.蜜柑') {
      %li.textContent = 'みかん';
    } else if (%data == '果物.桃') {
      %li.textContent = 'もも';
    } else {
      %li.textContent = '未知の果物';
    }
    %event.target.appendChild(%li);
  }
&lt;/script&gt;
</pre>

<!-- 
don't forget to change the "text/x-example" type to something
 specific to your site
  var internalDNDType = 'text/x-example'; // set this to something specific to 

'fruit-apple'
'Apples'
'fruit-orange'
'Oranges'
'fruit-pear'
'Pears'
'Unknown Fruit'
    }

-->

</div>

<hr>

<p>
`dragend$et ~eventを利用すれば、元の要素（~dragされていたもの）を表示から除去できる。
◎
To remove the original element (the one that was dragged) from the display, the dragend event can be used.
</p>


<div class="example">

<p>
これまでの例で言えば、その~eventを取扱うために，元の~markupを更新することを意味する：
◎
For our example here, that means updating the original markup to handle that event:
</p>


<pre>
&lt;p&gt;好きな果物は？&lt;/p&gt;
&lt;ol ondragstart="dragStartHandler(%event)" ondragend="dragEndHandler(%event)"&gt;
 // `...前と同じ...^cm
&lt;/ol&gt;
&lt;script&gt;
  function dragStartHandler(%event) {
    // `...前と同じ...^cm
  }
  function dragEndHandler(%event) {
    if (%event.dataTransfer.dropEffect == 'move') {
      // `~dragされている要素を除去する^cm
      %event.target.parentNode.removeChild(%event.target);
    }
  }
&lt;/script&gt;
</pre>

<!-- 
<p>What fruits do you like?</p>
<ol ondragstart="dragStartHandler(event)" ondragend="dragEndHandler(event)">
 ...as before...
</ol>
<script>
  function dragStartHandler(event) {
    // ...as before...
  }
  function dragEndHandler(event) {
    if (event.dataTransfer.dropEffect == 'move') {
      // remove the dragged element
      event.target.parentNode.removeChild(event.target);
    }
  }
</script>
 -->
 
</div>


		</section>
		<section id="the-drag-data-store">
<h3 title="The drag data store">6.7.2. ~drag-data~store</h3>


<p>
~DnD演算に下層にある~dataは，
`~drag-data~store@
と呼ばれ、次に挙げる各種~情報からなる
`括弧内には対応する IDL 属性も示す^tnote
：
◎
The data that underlies a drag-and-drop operation, known as the drag data store, consists of the following information:
</p>

<dl class="def-list">
	<dt>`~item~list@dS （ `items$m ）</dt>
	<dd class="trans-note">【
原文による正式な呼称は “drag data store item list” 。
この訳では， “drag data store” の部分は省略する（この頁の中では、 “~item~list” が他の意味に用いられることはない）。
他の項目についても同様。
】</dd>
	<dd>
<p>
~dragされた~dataを表現している一連の
`~item@
（ ~drag-data~item ）からなる~listであり，各~itemは次の情報からなる：
◎
A drag data store item list, which is a list of items representing the dragged data, each consisting of the following information:
</p>

		<dl class="def-list">
			<dt>`種類@dI （ `kind$m ）
◎
The drag data item kind
</dt>
			<dd>
<p>
次のいずれかとして表される，~dataの種類：
</p>

<dl><dt>`Plain Unicode string^i
</dt><dd>~text
</dd><dt>`File^i
</dt><dd>~file名も伴われる~binary~data。
</dd></dl>

◎
The kind of data:
◎
• Plain Unicode string
•• Text.
• File
•• Binary data with a file name.
</dd>

			<dt>`型~文字列@dI （ `type$m ）
◎
The drag data item type string
</dt>
			<dd>
~dataの型や形式を与える~Unicode文字列であり、一般には`~MIME型$で与えられる。
`~MIME型$でない一部の値は、旧来の理由のため，特別に扱われる。
API では`~MIME型$の利用は強制されないので、他の値も利用できる。
いずれにせよ、値は API により`~ASCII小文字化$される。
◎
A Unicode string giving the type or format of the data, generally given by a MIME type. Some values that are not MIME types are special-cased for legacy reasons. The API does not enforce the use of MIME types; other values can be used as well. In all cases, however, the values are all converted to ASCII lowercase by the API.
</dd>
			<dd class="note">注記：
`dropzone$a 属性には、`空白類$を包含する文字列は利用できない。
作者には、`~MIME型$か（ 空白類を含まない）~custom文字列のみを利用することが奨励される。
◎
Strings that contain space characters cannot be used with the dropzone attribute, so authors are encouraged to use only MIME types or custom strings (without spaces).
</dd>
			<dd>
`種類$dI が `Plain Unicode string^i の`~item$は、その`型~文字列$dIごとに一つまでとする制限-がある。
<span class="trans-note">【
すなわち，この種類の~itemの`型~文字列$dIは、同じ`~item~list$dS内で一意になる。
】</span>
◎
There is a limit of one Plain Unicode string item per item type string.
</dd>


			<dt>`実data@dI
◎
The actual data
</dt>
			<dd>
~Unicodeまたは~binary文字列であり，
一部の事例では、`~item$の`種類$dIに応じて，~file名（それ自体も~Unicode文字列）も伴われる。
◎
A Unicode or binary string, in some cases with a file name (itself a Unicode string), as per the drag data item kind.
</dd>
		</dl>

<p>
`~item~list$dSにおける各`~item$の順序は、`~item$が~listに追加された順序になる。
◎
The drag data store item list is ordered in the order that the items were added to the list; most recently added last.
</p>
	</dd>

	<dt>`既定の~feedback@dS （ `dropEffect$m ）
◎
↓</dt>
	<dd>
~UAにより定義される，既定の~feedbackを供する情報。
次項とともに，~drag中に~UI~feedbackを生成するときに利用される。
◎
The following information, used to generate the UI feedback during the drag:
◎
User-agent-defined default feedback information, known as the drag data store default feedback.
</dd>

	<dt>`~bitmap@dS と `~hot-spot座標@dS （ `setDragImage()$m ）
◎
↓</dt>
	<dd>
順に、~bitmap画像, および
その中のある地点を指す座標。
いずれも省略可。
◎
Optionally, a bitmap image and the coordinate of a point within that image, known as the drag data store bitmap and drag data store hot spot coordinate.
</dd>
	<dd class="trans-note">【
例えば~cursor画像と，その~hot-spot。
】</dd>

	<dt>`~mode@dS
◎
A drag data store mode, which is one of the following:
</dt>
	<dd>
<p>
`~drag-data~store$に対し行える演算は、~modeに依存する。
次のいずれかを値にとる：
◎
↓</p>

		<dl class="def-list">
			<dt>`可書~mode@i
◎
Read/write mode
</dt>
			<dd>
`dragstart$et ~event専用。
この~modeの下では、新たな~dataを`~item~list$dSに追加できる。
◎
For the dragstart event. New data can be added to the drag data store.
</dd>
			<dt>`読専~mode@i
◎
Read-only mode
</dt>
			<dd>
`drop$et ~event専用。
この~modeの下では、`~item~list$dS内の各`~item$を，その`実data$dIも含め読取れるが，新たな~dataは追加できない。
◎
For the drop event. The list of items representing dragged data can be read, including the data. No new data can be added.
</dd>

			<dt>`被保護~mode@i
◎
Protected mode
</dt>
			<dd>
他のすべての~event用。
この~modeの下では、`~item~list$dS内の各`~item$の形式と種類は，列挙できるが、それらの`実data$dIは可用でなく，新たな~dataも追加できない。
◎
For all other events. The formats and kinds in the drag data store list of items representing dragged data can be enumerated, but the data itself is unavailable and no new data can be added.
</dd>
		</dl>
	</dd>

	<dt>`許容される効果state@dS （ `effectAllowed$m ）
◎
A drag data store allowed effects state, which is a string.
</dt>
	<dd>
文字列。
`<a href="#_allowed-effect">詳細</a>^tnote
</dd>
</dl>

<div>
<p class="algo-head">
どの`~drag-data~store$も，その
`作成-@dS
時には、次のように初期化され~MUST：
</p>

<ul><li>`~item~list$dS ~SET 空
</li><li>`既定の~feedback$dS ~SET ε（なし）
</li><li>`~bitmap$dS ~SET ε
</li><li>`~hot-spot座標$dS ~SET ε
</li><li>`~mode$dS ~SET `被保護~mode$i
</li><li>`許容される効果state$dS ~SET `uninitialized$tE
</li></ul>
◎
When a drag data store is created, it must be initialized such that its drag data store item list is empty, it has no drag data store default feedback, it has no drag data store bitmap and drag data store hot spot coordinate, its drag data store mode is protected mode, and its drag data store allowed effects state is the string "uninitialized".
</div>

		</section>
		<section id="the-datatransfer-interface">
<h3 title="The DataTransfer interface">6.7.3. `DataTransfer^I ~interface</h3>


<p>
`DataTransfer$I ~objは、~DnD演算の下層にある`~drag-data~store$を，（ `DragEvent$I ~obj上の `dataTransfer$m 属性を通して）公開する。
◎
DataTransfer objects are used to expose the drag data store that underlies a drag-and-drop operation.
</p>


<pre class="idl">
interface `DataTransfer@I {
  attribute DOMString `dropEffect$m;
  attribute DOMString `effectAllowed$m;

  [SameObject] readonly attribute `DataTransferItemList$I `items$m;

  void `setDragImage$m(Element %image, long %x, long %y);

  /* old interface */
  [SameObject] readonly attribute DOMString[] `types$m;
  DOMString `getData$m(DOMString %format);
  void `setData$m(DOMString %format, DOMString %data);
  void `clearData$m(optional DOMString %format);
  [SameObject] readonly attribute `FileList$I `files$m;
};
</pre>

<dl class="domintro">
	<dt>%dataTransfer . `dropEffect$m [ = %value ]</dt>
	<dd>
現在~選択されている演算の種類を返す。
演算の種類が `effectAllowed$m 属性に許容されるものでない場合、演算は失敗することになる。
◎
Returns the kind of operation that is currently selected. If the kind of operation isn't one of those that is allowed by the effectAllowed attribute, then the operation will fail.
</dd>
	<dd>
設定して、選択されている演算を変更できる。
◎
Can be set, to change the selected operation.
</dd>
	<dd>
次のいずれかの値をとり得る
⇒
`none$tD, `copy$tD, `link$tD, `move$tD
◎
The possible values are "none", "copy", "link", and "move".
</dd>

	<dt>%dataTransfer . `effectAllowed$m [ = %value ]</dt>
	<dd>
許容されている演算の種類を返す。
◎
Returns the kinds of operations that are to be allowed.
</dd>
	<dd>
（ `dragstart$et ~eventの間に）設定して、許容される演算を変更できる。
◎
Can be set (during the dragstart event), to change the allowed operations.
</dd>
	<dd>
次のいずれかの値をとり得る
⇒
`none$tE, `copy$tE, `copyLink$tE, `copyMove$tE, `link$tE, `linkMove$tE, `move$tE, `all$tE, `uninitialized$tE,
◎
The possible values are "none", "copy", "copyLink", "copyMove", "link", "linkMove", "move", "all", and "uninitialized",
</dd>

	<dt>%dataTransfer . `items$m</dt>
	<dd>
~drag~dataが伴われている
`DataTransferItemList$I ~objを返す。
◎
Returns a DataTransferItemList object, with the drag data.
</dd>

	<dt>%dataTransfer . `setDragImage(element, x, y)$m</dt>
	<dd>
所与の要素を~drag~feedbackを更新するために利用する
— 以前に指定された~feedbackは置換される。
◎
Uses the given element to update the drag feedback, replacing any previously specified feedback.
</dd>

	<dt>%dataTransfer . `types$m</dt>
	<dd>
`dragstart$et ~eventにて設定された形式を~listする配列を返す。
加えて，何らかの~fileが~dragされている場合、 ~list内の型のうちいずれかは文字列 `Files^l になる。
◎
Returns an array listing the formats that were set in the dragstart event. In addition, if any files are being dragged, then one of the types will be the string "Files".
</dd>

	<dt>%data = %dataTransfer . `getData(format)$m</dt>
	<dd>
指定された形式の~dataを返す。
そのような形式の~dataがなければ空~文字列を返す。
◎
Returns the specified data. If there is no such data, returns the empty string.
</dd>

	<dt>%dataTransfer . `setData(format, data)$m</dt>
	<dd>
指定された形式の~dataを追加する。
◎
Adds the specified data.
</dd>

	<dt>%dataTransfer . `clearData( [ format ] )$m</dt>
	<dd>
指定された形式の~dataを除去する。
引数が省略された場合はすべての~dataを除去する。
◎
Removes the data of the specified formats. Removes all data if the argument is omitted.
</dd>

	<dt>%dataTransfer . `files$m</dt>
	<dd>
~fileたちが~dragされているならば，それらからなる `FileList$I を返す。
◎
Returns a FileList of the files being dragged, if any.
</dd>

</dl>

<p>
`DataTransfer$I ~objは、
<a href="#dndevents">~DnD~event</a>
の間に利用される。
◎
DataTransfer objects are used during the drag-and-drop events, and are only valid while those events are being fired.
</p>

<p>
`DataTransfer$I ~objが有効であるのは、当の~eventが発火されている間に限られる
— その間に限り，`~drag-data~store$が結付けられる。
◎
A DataTransfer object is associated with a drag data store while it is valid.
</p>

<p class="trans-note">【
~eventの配送-後は、特殊~値 ε が結付けられる（そのように、この訳では形式化して記述する）。
それ以降、~drag-data~storeが新たに結付けられ直されることはない。
】【
加えて、共通する記述を整理集約するため，次の定義（
`~store~mode$, `不能化~mode$i, `正規化-$
）も導入する。
】</p>

<p>
`DataTransfer$I ~objの
`~store~mode@
は、~objの`~drag-data~store$ ~NEQ ε ならば その`~mode$dS ／
~ELSE_
`不能化~mode@i
］を返す。
</p>

<p class="algo-head">
所与の文字列 %形式 を
`正規化-@
するときは、次を走らす：
</p>

<ol>
	<li>
%形式 ~LET %形式 を`~ASCII小文字化$した結果
</li>
	<li>
<p>
~RET %形式 に応じて，次で与えられる値：
</p>
<dl class="switch"
	><dt>`text^l
</dt><dd>`text/plain^l
</dd><dt>`url^l
</dt><dd>`text/uri-list^l
</dd><dt>その他
</dt><dd>%形式
</dd></dl>
	</li>
</ol>


<dl class="idl-def">
	<dt>`dropEffect@m</dt>
	<dd>
<p>
この属性は、~DnD演算の間に利用者に示される~feedbackを制御する。
この属性は、此れの作成-時に，ある文字列~値（下の “被設定時” に示されるいずれか）に設定される。
</p>

<p>
被取得時には、最後に設定された値を返さ~MUST。
</p>

<p>
被設定時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
所与の値 ~NIN
{ `none@tD, `copy@tD, `link@tD, `move@tD }
］
⇒
~RET
</li>
			<li>
属性の値 ~SET 所与の値
</li>
		</ol>

◎
The dropEffect attribute controls the drag-and-drop feedback that the user is given during a drag-and-drop operation. When the DataTransfer object is created, the dropEffect attribute is set to a string value. On getting, it must return its current value. On setting, if the new value is one of "none", "copy", "link", or "move", then the attribute's current value must be set to the new value. Other values must be ignored.
</dd>

	<dt>`effectAllowed@m</dt>
	<dd>
<p>
この属性は、~DnD処理~modelにおいて［
`dragenter$et ／ `dragover$et
］~eventの間に，此れの `dropEffect$m 属性を初期化するときに利用される。
この属性は、此れの作成-時に，ある文字列~値（下の “被設定時” に示されるいずれか）に設定される。
<!-- 
この属性は、許容される効果state$dSを与える。
 -->
</p>

<p>
被取得時には、最後に設定された値を返さ~MUST。
</p>

<p>
被設定時には、次を走らせ~MUST
</p>

		<ol>
			<li>
~IF［
此れの`~store~mode$ ~NEQ `可書~mode$i
］
⇒
~RET
</li>
			<li>
~IF［
所与の値 ~NIN
{ `none@tE, `copy@tE, `copyLink@tE, `copyMove@tE, `link@tE, `linkMove@tE, `move@tE, `all@tE, `uninitialized@tE }
］
⇒
~RET
</li>
			<li>
属性の値 ~SET 所与の値
</li>
		</ol>
◎
The effectAllowed attribute is used in the drag-and-drop processing model to initialize the dropEffect attribute during the dragenter and dragover events. When the DataTransfer object is created, the effectAllowed attribute is set to a string value. On getting, it must return its current value. On setting, if drag data store's mode is the read/write mode and the new value is one of "none", "copy", "copyLink", "copyMove", "link", "linkMove", "move", "all", or "uninitialized", then the attribute's current value must be set to the new value. Otherwise it must be left unchanged.
</dd>

	<dt>`items@m</dt>
	<dd>
被取得時には、此れに結付けられている
`DataTransferItemList$I ~objを返さ~MUST。
◎
The items attribute must return a DataTransferItemList object associated with the DataTransfer object.
</dd>

	<dt>`setDragImage(element, x, y)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The setDragImage(element, x, y) method must run the following steps:
</p>

<ol>
			<li>
~IF［
此れの`~store~mode$ ~NEQ `可書~mode$i
］
⇒
~RET
◎
If the DataTransfer object is no longer associated with a drag data store, abort these steps. Nothing happens.
◎
If the drag data store's mode is not the read/write mode, abort these steps. Nothing happens.
</li>
			<li>
%~store ~LET 此れの`~drag-data~store$
</li>
			<li>
%~store の`~bitmap$dS ~SET［
%element は `img$e 要素であるならば %element の画像（その~sizeは画像の`内在的~size$xによる）／
~ELSE_  %element から生成される画像（そうするための正確な仕組みは、まだ仕様化されていない）
］
◎
If the element argument is an img element, then set the drag data store bitmap to the element's image (at its intrinsic size); otherwise, set the drag data store bitmap to an image generated from the given element (the exact mechanism for doing so is not currently specified).
</li>
			<li>
%~store の`~hot-spot座標$dS ~SET 座標 ( %x, %y )
◎
Set the drag data store hot spot coordinate to the given x, y coordinate.
</li>

		</ol>
	</dd>

	<dt>`types@m</dt>
	<dd>
<p>
被取得時には、［
次の手続きから生産される一連の文字列
］からなる，`~live$かつ`読専の配列$を返さ~MUST。
◎
The types attribute must return a live read only array giving the strings that the following steps would produce.
</p>

		<ol>
			<li>
~IF［
此れの`~store~mode$ ~EQ `不能化~mode$i
］
⇒
~RET 空~list
◎
Start with an empty list L.
◎
If the DataTransfer object is no longer associated with a drag data store, the array is empty. Abort these steps; return the empty list L.
</li>
			<li>
%L ~LET 空~list
◎
↑</li>
			<li>
%~item~list ~LET 此れの`~drag-data~store$の`~item~list$dS
◎
↓</li>
			<li>
~FOR
%~item~list 内の
~EACH( `~item$ %~item ) に対し
⇒
~IF［
%~item の`種類$dI ~EQ `Plain Unicode string^i
］
⇒
%~item の`型~文字列$dIを %L に追加する
◎
For each item in the drag data store item list whose kind is Plain Unicode string, add an entry to the list L consisting of the item's type string.
</li>
			<li>
~IF［
%~item~list 内に［
`種類$dI ~EQ `File^i
］なる %~itemがある
］
⇒
文字列 `Files^l を %L に追加する（この値は、小文字でないので %L 内の他の値と判別できる）
◎
If there are any items in the drag data store item list whose kind is File, then add an entry to the list L consisting of the string "Files". (This value can be distinguished from the other values because it is not lowercase.)
</li>
			<li>
~RET %L
◎
The strings produced by these steps are those in the list L.
</li>
		</ol>
	</dd>

	<dt>`getData(format)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The getData(format) method must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れの`~store~mode$ ~IN { `不能化~mode$i, `被保護~mode$i }
］
⇒
~RET 空~文字列
◎
If the DataTransfer object is no longer associated with a drag data store, return the empty string and abort these steps.
◎
If the drag data store's mode is the protected mode, return the empty string and abort these steps.
</li>
			<li>
<p>
%~item ~LET 此れの`~drag-data~store$の`~item~list$dS内の`~item$のうち，次を満たすもの（在れば一意に定まる）：
</p>

<ul ><li>`種類$dI ~EQ `Plain Unicode string^i ~AND
</li><li>`型~文字列$dI ~EQ %format を`正規化-$した結果
</li></ul>

◎
Let format be the first argument, converted to ASCII lowercase.
◎
Let convert-to-URL be false.
◎
If format equals "text", change it to "text/plain".
◎
If format equals "url", change it to "text/uri-list" and set convert-to-URL to true.
◎
If there is no item in the drag data store item list whose kind is Plain Unicode string and whose type string is equal to format, return the empty string and abort these steps.
</li>
			<li>
~IF［
%~item ~EQ ε
］
⇒
~RET 空~文字列
◎
↑</li>
			<li>
%結果 ~LET %~item の`実data$dI
◎
Let result be the data of the item in the drag data store item list whose kind is Plain Unicode string and whose type string is equal to format.
</li>
			<li>
~IF［
%format を`~ASCII小文字化$した結果 ~EQ `url^l
］
⇒
~RET ［［
%結果 を `RFC2483$r に則って， `text/uri-list^l に対し適切に構文解析した結果の~list
］が空でなければ その中の最初の~URL ／
~ELSE_ 空~文字列
］†
◎
If convert-to-URL is true, then parse result as appropriate for text/uri-list data, and then set result to the first URL from the list, if any, or the empty string otherwise. [RFC2483]
</li>
			<li>
~RET %結果
◎
Return result.
</li>
		</ol>

<p class="trans-note">【†
%format に `text/uri-list^l が渡された場合と（正規化した結果は同じでも）ふるまいが異なる。
】</p>

	</dd>

	<dt>`setData(format, data)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The setData(format, data) method must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れの`~store~mode$ ~NEQ `可書~mode$i
］
⇒
~RET
◎
If the DataTransfer object is no longer associated with a drag data store, abort these steps. Nothing happens.
◎
If the drag data store's mode is not the read/write mode, abort these steps. Nothing happens.
</li>
			<li>
%形式 ~LET %format を`正規化-$した結果
◎
Let format be the first argument, converted to ASCII lowercase.
◎
If format equals "text", change it to "text/plain".
◎
If format equals "url", change it to "text/uri-list".
</li>
			<li>
%~item~list ~LET 此れの`~drag-data~store$の`~item~list$dS
◎
↓</li>
			<li>
%~item~list から次を満たす`~item$を除去する
⇒
［
`種類$dI ~EQ `Plain Unicode string^i
］~AND［
`型~文字列$dI ~EQ %形式
］
◎
Remove the item in the drag data store item list whose kind is Plain Unicode string and whose type string is equal to format, if there is one.
</li>
			<li>
%~item~list に，次のようにされた新たな`~item$を追加する
⇒
`種類$dI ~SET `Plain Unicode string^i；<br>
`型~文字列$dI ~SET %形式；<br>
`実data$dI ~SET %data
◎
Add an item to the drag data store item list whose kind is Plain Unicode string, whose type string is equal to format, and whose data is the string given by the method's second argument.
</li>
		</ol>

<p class="trans-note">【
除去した上で，追加するので、
%~item~list 内での当の~itemの~indexも変化することになる（本当か？）。
】</p>
	</dd>

	<dt>`clearData(format)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The clearData() method must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れの`~store~mode$ ~NEQ `可書~mode$i
］
⇒
~RET
◎
If the DataTransfer object is no longer associated with a drag data store, abort these steps. Nothing happens.
◎
If the drag data store's mode is not the read/write mode, abort these steps. Nothing happens.
</li>
			<li>
<p>
此れの`~drag-data~store$の`~item~list$dSから
次を満たす`~item$すべてを除去する：
</p>

<ul><li>
`種類$dI ~EQ `Plain Unicode string^i ~AND
</li><li>
%format は与えられていないならば 無条件 ／
~ELSE_ ［
`型~文字列$dI ~EQ %format を`正規化-$した結果
］
</li></ul>

◎
If the method was called with no arguments, remove each item in the drag data store item list whose kind is Plain Unicode string, and abort these steps.
◎
Let format be the first argument, converted to ASCII lowercase.
◎
If format equals "text", change it to "text/plain".
◎
If format equals "url", change it to "text/uri-list".
◎
Remove the item in the drag data store item list whose kind is Plain Unicode string and whose type string is equal to format, if there is one.
</li>
		</ol>

<p class="note">注記：
~drag内に~fileが含まれている場合、この~methodを~callしても それらの~fileには影響しないので， `types$m 属性が返す~listは依然として 文字列 `Files^l を包含することになる。
◎
The clearData() method does not affect whether any files were included in the drag, so the types attribute's list might still not be empty after calling clearData() (it would still contain the "Files" string if any files were included in the drag).
</p>
	</dd>

	<dt>`files@m</dt>
	<dd>
<p>
被取得時には、［
次の手続きから返される， `File$I ~objの~list
］を表現する，`~live$ `FileList$I ~objを返さ~MUST。
加えて、所与の
( `FileList$I ~obj, 下層の~file )
に対しては，毎回~同じ `File$I ~objが利用され~MUST。
◎
The files attribute must return a live FileList sequence consisting of File objects representing the files found by the following steps. Furthermore, for a given FileList object and a given underlying file, the same File object must be used each time.
</p>

		<ol>
			<li>
~IF［
此れの`~store~mode$ ~IN { `不能化~mode$i, `被保護~mode$i }
］
⇒
~RET 空~list
◎
Start with an empty list L.
◎
If the DataTransfer object is no longer associated with a drag data store, the FileList is empty. Abort these steps; return the empty list L.
◎
If the drag data store's mode is the protected mode, abort these steps; return the empty list L.
</li>
			<li>
%L ~LET 空~list
◎
↑</li>
			<li>
~FOR
此れの`~drag-data~store$の`~item~list$dS内の~EACH( `~item$ %~item ) に対し
⇒
~IF［
%~item の`種類$dI ~EQ `File^i
］
⇒
%~item の`実data$dI（ ~file, 特にその名前と内容, および
その`型~文字列$dI）を表現する `File$I ~objを %L に追加する
◎
For each item in the drag data store item list whose kind is File , add the item's data (the file, in particular its name and contents, as well as its type) to the list L.
</li>
			<li>
~RET %L
◎
The files found by these steps are those in the list L.
</li>
		</ol>
	</dd>
</dl>

<p class="note">注記：
この~versionの~APIは、~drag中は，~fileの型を公開しない。
◎
This version of the API does not expose the types of the files during the drag.
</p>


			<section id="the-datatransferitemlist-interface">
<h4 title="The DataTransferItemList interface">6.7.3.1. `DataTransferItemList^I ~interface</h4>


<p>
各 `DataTransfer$I ~objには、
`DataTransferItemList$I ~objが結付けられる。
◎
Each DataTransfer object is associated with a DataTransferItemList object.
</p>


<pre class="idl">
interface `DataTransferItemList@I {
  readonly attribute unsigned long `length$m;
  `getter$m `DataTransferItem$I (unsigned long %index);
  `DataTransferItem$I? `add$m(DOMString %data, DOMString %type);
  `DataTransferItem$I? `add$m(`File$I %data);
  void `remove$m(unsigned long %index);
  void `clear$m();
};
</pre>


<dl class="domintro">
	<dt>%items . `length$m</dt>
	<dd>
`~drag-data~store$内の`~item$数を返す。
◎
Returns the number of items in the drag data store.
</dd>

	<dt>%items[%index]</dt>
	<dd>
`~drag-data~store$内の %index 番の~entryを表現している
`DataTransferItem$I
~objを返す。
◎
Returns the DataTransferItem object representing the indexth entry in the drag data store.
</dd>

	<dt>%items . `remove(index)$m</dt>
	<dd>
`~drag-data~store$内の
%~index 番の~entryを除去する。
◎
Removes the indexth entry in the drag data store.
</dd>

	<dt>%items . `clear()$m</dt>
	<dd>
`~drag-data~store$内のすべての~entryを除去する。
◎
Removes all the entries in the drag data store.
</dd>

	<dt>%items . `add(data)$m</dt>
	<dt>%items . `add(data, type)$m</dt>
	<dd>
所与の %data に対する新たな~entryを，`~drag-data~store$に追加する。
%data が素の~textの場合は， %type 文字列も提供される必要がある。
◎
Adds a new entry for the given data to the drag data store. If the data is plain text then a type string has to be provided also.
</dd>

</dl>


<p>
`DataTransferItemList$I ~obj %L の
`~store~mode@1
は、 %L を結付けている `DataTransfer$I ~objの`~store~mode$を参照する。
◎
While the DataTransferItemList object's DataTransfer object is associated with a drag data store, the DataTransferItemList object's mode is the same as the drag data store mode. When the DataTransferItemList object's DataTransfer object is not associated with a drag data store, the DataTransferItemList object's mode is the disabled mode. The drag data store referenced in this section (which is used only when the DataTransferItemList object is not in the disabled mode) is the drag data store with which the DataTransferItemList object's DataTransfer object is associated.
</p>

<dl class="idl-def">

	<dt>`length@m</dt>
	<dd>
<p>
被取得時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
~IF［
此れの`~store~mode$1 ~EQ `不能化~mode$i
］
⇒
~RET 0
</li>
			<li>
~RET 此れが表現する`~item~list$dS内の`~item$数
</li>
		</ol>

◎
The length attribute must return zero if the object is in the disabled mode; otherwise it must return the number of items in the drag data store item list.
</dd>

	<dt>`getter^m</dt>
	<dd>
此れの`被support~prop~index$xの範囲は、［
0 〜 ( 此れの `length$m 属性を~~取得した結果 − 1 )
］である。
◎
When a DataTransferItemList object is not in the disabled mode, its supported property indices are the numbers in the range 0 .. n-1, where n is the number of items in the drag data store item list.
</dd>
	<dd>
<p id="dom-datatransferitemlist-item">
`DataTransferItemList$I ~obj %L 上の~index %i に対し，`有index~propを決定-$xするときは、次の拘束を満たすような， `DataTransferItem$I ~obj %I を返さ~MUST：
</p>
		<ul>
			<li>
%I は、`~item~list$dS内の %i 番の`~item$を表現する。
</li>
			<li>
同じ`~item$に対しては，毎回 %I として同じ~objを返す。
</li>
			<li>
%I に結付けられている `DataTransfer$I ~obj ~EQ %L を結付けているそれ。
</li>
<!-- 
			<li>
%I が所属する `DataTransferItemList$I ~objは %L 。
</li>

 -->
		</ul>
◎
To determine the value of an indexed property i of a DataTransferItemList object, the user agent must return a DataTransferItem object representing the ith item in the drag data store. The same object must be returned each time a particular item is obtained from this DataTransferItemList object. The DataTransferItem object must be associated with the same DataTransfer object as the DataTransferItemList object when it is first created.
</dd>

	<dt>`add(data, type)@m</dt>
	<dt>`add(data)$m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The add() method must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れの`~store~mode$1 ~NEQ `可書~mode$i
］
⇒
~RET ~NULL
◎
If the DataTransferItemList object is not in the read/write mode, return null and abort these steps.
</li>
			<li>
%~item~list ~LET 此れが表現する`~item~list$dS
◎
↓</li>
			<li>
%新~item ~LET ε
◎
↓</li>
			<li>
<p>
%data の型に応じて：
◎
Jump to the appropriate set of steps from the following list:
</p>

				<dl class="switch">
				<dt>文字列
◎
If the first argument to the method is a string
</dt>
				<dd>
					<ol>
						<li>
%type ~SET %type を`~ASCII小文字化$した結果
◎
↓</li>
				<li>
~IF［
%~item~list 内に［［
`種類$dI ~EQ `Plain Unicode string^i
］~AND［
`型~文字列$dI ~EQ %type
］］を満たす`~item$がある
］
⇒
~THROW `NotSupportedError$E
◎
If there is already an item in the drag data store item list whose kind is Plain Unicode string and whose type string is equal to the value of the method's second argument, converted to ASCII lowercase, then throw a NotSupportedError DOMException and abort these steps.
</li>
				<li>
<p>
%新~item ~SET 次のようにされた`~item$：
</p>

<ul ><li>`種類$dI ~SET `Plain Unicode string^i
</li><li>`型~文字列$dI ~SET %type
</li><li>`実data$dI ~SET %data
</li></ul>

◎
Otherwise, add an item to the drag data store item list whose kind is Plain Unicode string, whose type string is equal to the value of the method's second argument, converted to ASCII lowercase, and whose data is the string given by the method's first argument.
</li>
					</ol>
				</dd>

				<dt>`File$I
◎
If the first argument to the method is a File
</dt>
				<dd>
<p>
%新~item ~SET 次のようにされた`~item$：
</p>

<ul ><li>`種類$dI ~SET `File^i
</li><li>`型~文字列$dI ~SET %data の
<a href="~FILEAPI#dfn-type">`type^m</a>
を`~ASCII小文字化$した結果；<br>
</li><li>`実data$dI ~SET %data の~data
</li></ul>

◎
Add an item to the drag data store item list whose kind is File, whose type string is the type of the File, converted to ASCII lowercase, and whose data is the same as the File's data.
</dd>
				</dl>
			</li>
			<li>
%新~item を %~item~list に追加する
◎
↑</li>
			<li>
~RET %新~item を表現する，新たな `DataTransferItem$I ~obj
— `有index~propを決定-$するときは、この~objが利用されることになる。
◎
Determine the value of the indexed property corresponding to the newly added item, and return that value (a newly created DataTransferItem object).
</li>

		</ol>
	</dd>

	<dt>`remove(index)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The remove() method, when invoked with the argument i, must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの`~store~mode$1 ~NEQ `可書~mode$i
］
⇒
~THROW `InvalidStateError$E
◎
If the DataTransferItemList object is not in the read/write mode, throw an InvalidStateError DOMException and abort these steps.
</li>
			<li>
此れが表現する`~item~list$dSから %index 番の`~item$を除去する
◎
Remove the ith item from the drag data store.
</li>
		</ol>
	</dd>

	<dt>`clear()@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
</p>

		<ol>
			<li>
~IF［
此れの`~store~mode$1 ~NEQ `可書~mode$i
］
⇒
~RET
</li>
			<li>
此れが表現する`~item~list$dSからすべての`~item$を除去する
</li>
		</ol>
◎
The clear method, if the DataTransferItemList object is in the read/write mode, must remove all the items from the drag data store. Otherwise, it must do nothing.
</dd>
</dl>


			</section>
			<section id="the-datatransferitem-interface">
<h4 title="The DataTransferItem interface">6.7.3.2. `DataTransferItem^I ~interface</h4>


<p>
各 `DataTransferItem$I ~objには `DataTransfer$I ~objが結付けられる。
◎
Each DataTransferItem object is associated with a DataTransfer object.
</p>


<pre class="idl">
interface `DataTransferItem@I {
  readonly attribute DOMString `kind$m;
  readonly attribute DOMString `type$m;
  void `getAsString$m(`FunctionStringCallback$I? %_callback);
  `File$I? `getAsFile$m();
};

callback `FunctionStringCallback@I = void (DOMString %data);
</pre>

<dl class="domintro">
	<dt>%item . `kind$m</dt>
	<dd>
`~item$の`種類$dI
を返す。
次のいずれか
⇒
`string^l, `file^l
◎
Returns the drag data item kind, one of: "string", "file".
</dd>

	<dt>%item . `type$m</dt>
	<dd>
`~item$の`型~文字列$dIを返す。
◎
Returns the drag data item type string.
</dd>

	<dt>%item . `getAsString(callback)$m</dt>
	<dd>
`~item$の`種類$dIが `Plain Unicode string^i であれば、文字列~dataを引数に %callback を呼出す。
◎
Invokes the callback with the string data as the argument, if the drag data item kind is Plain Unicode string.
</dd>

	<dt>%file = %item . `getAsFile()$m</dt>
	<dd>
`~item$の`種類$dI ~EQ `File^i であれば
`File$I ~objを返す。
◎
Returns a File object, if the drag data item kind is File.
</dd>
</dl>

<div class="p">
<p>
`DataTransferItem$I ~obj %I の
`~item~mode@
は、次を走らせた結果を返す：
</p>

<ol>
	<li>
%L ~LET %I に結付けられている `DataTransfer$I ~objに結付けられている `DataTransferItemList$I ~obj
</li>
	<li>
~IF［
%L の`~store~mode$1 ~EQ `不能化~mode$i
］~OR［
%I が表現する`~item$は %L が表現する`~item~list$dSから除去されている
］
⇒
~RET `不能化~mode$i
</li>
	<li>
~RET %L の`~store~mode$1
</li>
</ol>

◎
While the DataTransferItem object's DataTransfer object is associated with a drag data store and that drag data store's drag data store item list still contains the item that the DataTransferItem object represents, the DataTransferItem object's mode is the same as the drag data store mode. When the DataTransferItem object's DataTransfer object is not associated with a drag data store, or if the item that the DataTransferItem object represents has been removed from the relevant drag data store item list, the DataTransferItem object's mode is the disabled mode. The drag data store referenced in this section (which is used only when the DataTransferItem object is not in the disabled mode) is the drag data store with which the DataTransferItem object's DataTransfer object is associated.
</div>



<dl class="idl-def">
	<dt>`kind@m</dt>
	<dd>
<p>
被取得時には、次を走らせ~MUST：
</p>

		<ol>
			<li>
~IF［
此れの`~item~mode$ ~EQ `不能化~mode$i
］
⇒
~RET 空~文字列
</li>
			<li>
<p>
~RET 此れが表現する`~item$の`種類$dIに応じて，次の表の二列目に与えられる文字列：
</p>

<table><thead><tr><th>種類</th><th>文字列
</th></tr></thead>

<tbody><tr><td>`Plain Unicode string^i
</td><td>`string^l

</td></tr><tr><td>`File^i
</td><td>`file^l

</td></tr></tbody></table>

			</li>
		</ol>

◎
The kind attribute must return the empty string if the DataTransferItem object is in the disabled mode; otherwise it must return the string given in the cell from the second column of the following table from the row whose cell in the first column contains the drag data item kind of the item represented by the DataTransferItem object:

Kind 	String
Plain Unicode string 	"string"
File 	"file"
</dd>

	<dt>`type@m</dt>
	<dd>
<p>
被取得時には、次を走らせ~MUST：
</p>

		<ol>
			<li>
~IF［
此れの`~item~mode$ ~EQ `不能化~mode$i
］
⇒
~RET 空~文字列
</li>
			<li>
~RET 此れが表現する`~item$の`型~文字列$dI
</li>
		</ol>

◎
The type attribute must return the empty string if the DataTransferItem object is in the disabled mode; otherwise it must return the drag data item type string of the item represented by the DataTransferItem object.
</dd>

	<dt>`getAsString(callback)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The getAsString(callback) method must run the following steps:
</p>

<ol>
			<li>
~IF［
%callback ~EQ ~NULL
］
⇒
~RET
◎
If the callback is null, abort these steps.
</li>
			<li>
~IF［
此れの`~item~mode$ ~NIN { `可書~mode$i, `読専~mode$i }
］
⇒
~RET
◎
If the DataTransferItem object is not in the read/write mode or the read-only mode, abort these steps. The callback is never invoked.
</li>
			<li>
~IF［
此れが表現する`~item$の`種類$dI ~NEQ `Plain Unicode string^i
］
⇒
~RET
◎
If the drag data item kind is not Plain Unicode string, abort these steps. The callback is never invoked.
</li>
			<li>
<p >
次を走らす`~taskを待入する$：
</p>

<ol><li>此れが表現する`~item$の`実data$dIを引数に渡して %callback を呼出す
</li></ol>

◎
Otherwise, queue a task to invoke callback, passing the actual data of the item represented by the DataTransferItem object as the argument.
</li>
		</ol>
	</dd>

	<dt>`getAsFile()@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The getAsFile() method must run the following steps:
</p>

<ol>
			<li>
~IF［
此れの`~item~mode$ ~NIN { `可書~mode$i, `読専~mode$i }
］
⇒
~RET ~NULL
◎
If the DataTransferItem object is not in the read/write mode or the read-only mode, return null and abort these steps.
</li>
			<li>
~IF［
此れが表現する`~item$の`種類$dI ~NEQ `File^i
］
⇒
~RET ~NULL
◎
If the drag data item kind is not File, then return null and abort these steps.
</li>
			<li>
~RET 
此れが表現する`~item$の`実data$dIを表現している，新たな† `File$I ~obj
◎
Return a new File object representing the actual data of the item represented by the DataTransferItem object.
</li>
		</ol>

<p class="trans-note">【†
毎回~新たな~objを返すことになる。
】</p>

	</dd>
</dl>

			</section>
		</section>
		<section id="the-dragevent-interface">
<h3 title="The DragEvent interface">6.7.4. `DragEvent^I ~interface</h3>


<p>
~DnD処理~modelには、いくつかの~eventが孕まれる。
それらはいずれも `DragEvent$I ~interfaceを利用する。
◎
The drag-and-drop processing model involves several events. They all use the DragEvent interface.
</p>


<pre class="idl">
[Constructor(DOMString %type, optional `DragEventInit$I %eventInitDict)]
interface `DragEvent@I : `MouseEvent$I {
  readonly attribute `DataTransfer$I? `dataTransfer$m;
};

dictionary `DragEventInit@I : `MouseEventInit$I {
  `DataTransfer$I? dataTransfer = null;
};
</pre>


<dl class="domintro">
	<dt>%event . `dataTransfer$m</dt>
	<dd>
~eventに対する
`DataTransfer$I ~objを返す。
◎
Returns the DataTransfer object for the event.
</dd>
	<dd>
</dd></dl>


<p class="note">注記：
他の~event~interfaceとの一貫性をとるため，
`DragEvent$I ~interfaceには構築子があるが、それはまったく有用でない。
特に、~scriptが有用な `DataTransfer$I ~objを作成する仕方はない
— `DataTransfer$I ~objには、~DnDの間に，~browserが その処理と~security~modelを協調する~~仕組みがあるので。
◎
Although, for consistency with other event interfaces, the DragEvent interface has a constructor, it is not particularly useful. In particular, there's no way to create a useful DataTransfer object from script, as DataTransfer objects have a processing and security model that is coordinated by the browser during drag-and-drops.
</p>

<p>
`DragEvent$I ~interfaceの
`dataTransfer@m
属性は、初期化-時の値を返さ~MUST。
それは、当の~eventの文脈~情報を表現する。
◎
The dataTransfer attribute of the DragEvent interface must return the value it was initialized to. It represents the context information for the event.
</p>



<p>
~UAは、関係する標的として %relatedTarget（省略可）が与えられた下で，要素 %要素 に向けて 名前 %e の
`~DND~eventを発火-@
することが要求されたときは、次の手続きを走らせ~MUST：
◎
When a user agent is required to fire a DND event named e at an element, using a particular drag data store, and optionally with a specific related target, the user agent must run the following steps:
</p>

<p class="trans-note">【
~DnD演算に関わるすべての~eventは、この手続きを通して発火される。
】【
以下における `~store$V は、
<a href="#drag-and-drop-processing-model">~DnD処理~model節</a>
にて作成される`~drag-data~store$を指す（同じ~DnD演算から生じる各~event間で共有される）。
】</p>

<ol>
	<li>
~IF［
%relatedTarget は与えられていない
］
⇒
%relatedTarget ~SET ~NULL
◎
If no specific related target was provided, set related target to null.
</li>
	<li>
%~window ~LET %要素 の `Document$I ~objの `Window$I ~obj
◎
Let window be the Window object of the Document object of the specified target element.
</li>
	<li>
<p>
`~store$V の`~mode$dS ~SET %e に応じて，次で与えられる値：
</p>

<dl class="switch"
	><dt>`dragstart$et
</dt><dd>`可書~mode$i

</dd><dt>`drop$et
</dt><dd>`読専~mode$i

</dd><dt>その他
</dt><dd>`被保護~mode$i（`作成-$dS時のそれ）

</dd></dl>

◎
If e is dragstart, set the drag data store mode to the read/write mode.
◎
If e is drop, set the drag data store mode to the read-only mode.
</li>
	<li>
<p>
%dataTransfer ~LET 新たな `DataTransfer$I ~obj
</p>

<p class="trans-note">【
`DataTransfer$I ~objは各~eventごとに別々になることになる。
】</p>
◎
↓</li>
	<li>
%dataTransfer の`~drag-data~store$ ~SET `~store$V
◎
Let dataTransfer be a newly created DataTransfer object associated with the given drag data store.
</li>
	<li id="effectAllowed-initialisation">
`effectAllowed$m 属性 ~SET `~store$V に`許容される効果state$dS
◎
Set the effectAllowed attribute to the drag data store's drag data store allowed effects state.
</li>
	<li>

<div>
<p id="dropEffect-initialisation">
`dropEffect$m 属性 ~SET %e に応じて，次で与えられる値：
</p>

<dl class="switch"
	><dt>`dragstart$et
</dt><dt>`drag$et
</dt><dt>`dragexit$et
</dt><dt>`dragleave$et
</dt><dd>
`none$tD

</dd><dt>`drop$et
</dt><dt>`dragend$et
</dt><dd>`現在の~drag演算$

</dd><dt>`dragenter$et
</dt><dt>`dragover$et
</dt><dd id="_allowed-effect">

<p>
下の表の［
1 列目に示される `effectAllowed$m 属性の値
］に応じて、同じ行の：
</p>

<ul ><li>2 列目に示される値, または、場合によっては
</li><li>3 列目の`代替の選択肢$（空欄は選択肢なし）に与えられるいずれかの値
</li></ul>

</dd></dl>

◎
Set the dropEffect attribute to "none" if e is dragstart, drag, dragexit, or dragleave; to the value corresponding to the current drag operation if e is drop or dragend; and to a value based on the effectAllowed attribute's value and the drag-and-drop source, as given by the following table, otherwise (i.e. if e is dragenter or dragover):
</div>

<table><thead><tr><th>`effectAllowed$m
</th><th>`dropEffect$m
</th><th>`代替の選択肢$
</th></tr></thead>

<tbody><tr><td>`none$tE
</td><td>`none$tD
</td><td>

</td></tr><tr><td>`copy$tE
</td><td>`copy$tD
</td><td>

</td></tr><tr><td>`copyLink$tE
</td><td>`copy$tD
</td><td>`link$tD

</td></tr><tr><td>`copyMove$tE
</td><td>`copy$tD
</td><td>`move$tD

</td></tr><tr><td>`all$tE
</td><td>`copy$tD
</td><td>`link$tD, `move$tD

</td></tr><tr><td>`link$tE
</td><td>`link$tD
</td><td>

</td></tr><tr><td>`linkMove$tE
</td><td>`link$tD
</td><td>`move$tD

</td></tr><tr><td>`move$tE
</td><td>`move$tD
</td><td>

</td></tr><tr><td>`uninitialized$tE (1)
◎
"uninitialized" when what is being dragged is a selection from a text control
</td><td>`move$tD
</td><td>`copy$tD, `link$tD

</td></tr><tr><td>`uninitialized$tE (2)
◎
"uninitialized" when what is being dragged is a selection
</td><td>`copy$tD
</td><td>`link$tD, `move$tD

</td></tr><tr><td>`uninitialized$tE (3)
◎
"uninitialized" when what is being dragged is an a element with an href attribute
</td><td>`link$tD
</td><td>`copy$tD, `move$tD

</td></tr><tr><td>他の場合
◎
Any other case
</td><td>`copy$tD
</td><td>`link$tD, `move$tD

</td></tr></tbody></table>


<div >
<p>
`uninitialized$tE に対する
(1), (2), (3) は、順に，~DnD~sourceが次に該当する場合に限られる：
</p>

<ul ><li>(1) ~text~controlからの選択
</li><li>(2) 選択の場合
</li><li>(3) `href$a 属性を有する `a$e 要素
</li>
</ul>
◎
↑</div>


<p>
上の表にて
`代替の選択肢@
が提供されている所では、［
~platform規約から，［
利用者が，挙げられたいずれかの代替による効果を要請した
］ことが指図される
］ならば，~UAはその代替~値を代わりに利用してもよい。
◎
Where the table above provides possibly appropriate alternatives, user agents may instead use the listed alternative values if platform conventions dictate that the user has requested those alternate effects.
</p>


<p class="example">
例えば、Windows ~platform規約では、
"alt" ~keyを押しながら~dragしたときは、移動-や複製-でなく，~dataへ~linkすることが選好されている。
したがって Windows ~system上では、`代替の選択肢$に `link$tD がある所では、
"alt" ~keyが押下げられている間，~UAは `copy$tD や `move$tD の代わりにそれを選択することもできる。
◎
For example, Windows platform conventions are such that dragging while holding the "alt" key indicates a preference for linking the data, rather than moving or copying it. Therefore, on a Windows system, if "link" is an option according to the table above while the "alt" key is depressed, the user agent could select that instead of "copy" or "move".
</p>

	</li>
	<li>
<p>
%~event ~LET 次のようにされた新たな `DragEvent$I ~obj：
</p>

<ul><li>`~trusted$
</li><li>名前 ~SET %e
</li><li>浮上する
</li><li>%e ~NIN { `dragexit$et, `dragleave$et, `dragend$et } ならば取消可能
</li><li>
<p>
各種~属性は、次のように初期化する：
</p>
	<ul><li>`view$m ~SET %~window
	</li><li>`detail$m ~SET ~zero
	</li><li>`relatedTarget$m ~SET %relatedTarget
	</li><li>`dataTransfer$m ~SET %dataTransfer
	</li><li>
各種~mouse／~key属性は、入力~装置の状態に則って，利用者~対話~event `UIEVENTS$r に対するときと同様に初期化する
	</li></ul>
</li><li>
<p>
加えて、関連する~pointing装置がない場合は，次の属性も初期化する：
</p>
	<ul><li>`screenX^m ~SET 0
	</li><li>`screenY^m ~SET 0
	</li><li>`clientX^m ~SET 0
	</li><li>`clientY^m ~SET 0
	</li><li>`button^m ~SET 0
	</li></ul>
</li></ul>

◎
Create a trusted DragEvent object and initialize it to have the given name e, to bubble, to be cancelable unless e is dragexit, dragleave, or dragend, and to have the view attribute initialized to window, the detail attribute initialized to zero, the mouse and key attributes initialized according to the state of the input devices as they would be for user interaction events, the relatedTarget attribute initialized to related target, and the dataTransfer attribute initialized to dataTransfer, the DataTransfer object created above.
◎
If there is no relevant pointing device, the object must have its screenX, screenY, clientX, clientY, and button attributes set to 0.
</li>

	<li>
%要素 に向けて %~event を`配送-$する
◎
Dispatch the newly created DragEvent object at the specified target element.
</li>
	<li>
`~store$V に`許容される効果state$dS ~SET %dataTransfer の`effectAllowed$m 属性の現在の値（この属性の値が変更されるのは、 %e ~EQ `dragstart$et のときに限られる）
◎
Set the drag data store allowed effects state to the current value of dataTransfer's effectAllowed attribute. (It can only have changed value if e is dragstart.)
</li>
	<li>
`~store$V の`~mode$dS ~SET `被保護~mode$i
◎
Set the drag data store mode back to the protected mode if it was changed in the first step.
</li>
	<li>
%dataTransfer の`~drag-data~store$ ~SET ε
◎
Break the association between dataTransfer and the drag data store.
</li>
	<li>
~RET %~event
</li>

</ol>

		</section>
		<section id="drag-and-drop-processing-model">
<h3 title="Processing model">6.7.5. 処理~model</h3>


<p>
利用者が~drag演算を始めようと試みたときは、~UAは，次の手続きを走らせ~MUST。
~UAは、当の~dragが実際には別の文書または~app内から開始されていて，~UAは自身から見える~~範囲の下で，~dragが文書に交差するまで それを感知できなかった場合でも、この手続きが走っていたかのように動作し~MUST。
◎
When the user attempts to begin a drag operation, the user agent must run the following steps. User agents must act as if these steps were run even if the drag actually started in another document or application and the user agent was not aware that the drag was occurring until it intersected with a document under the user agent's purview.
</p>

<ol>

	<li>
<p>
次に従って， %~drag対象 を決定する：
◎
Determine what is being dragged, as follows:
</p>

		<ol>
			<li>
~IF［
~drag演算は、選択~上で呼出された
］
⇒
%~drag対象 ~SET その選択
◎
If the drag operation was invoked on a selection, then it is the selection that is being dragged.
</li>

			<li>
<p>
~ELIF［
~drag演算は、 `Document$I 上で呼出された
］：
</p>
				<ol>
					<li>
%~node ~LET 利用者が~dragし始めようとしている~node
</li>
					<li>
~IF［［
%~node, および その先祖
］のうち［
`draggable$m ~IDL属性 ~EQ ~T
］なる要素はある
］
⇒
%~drag対象 ~SET そのような要素のうち， %~node に最も近いもの
</li>
					<li>
~RET 
— 何も~dragされていないので、~DnD演算は開始されない。
</li>
				</ol>

◎
Otherwise, if the drag operation was invoked on a Document, it is the first element, going up the ancestor chain, starting at the node that the user tried to drag, that has the IDL attribute draggable set to true. If there is no such element, then nothing is being dragged; abort these steps, the drag-and-drop operation is never started.
</li>
			<li>
~ELSE（ ~drag演算は、~UAの外側から呼出された）
⇒
%~drag対象 ~SET
~dragが開始された所の~app（または，その中の文書等）により定義されるもの
— 以下、
`外部のもの@
と記すことにする。
◎
Otherwise, the drag operation was invoked outside the user agent's purview. What is being dragged is defined by the document or application where the drag was started.
</li>

		</ol>

<p class="note">注記：
［
`img$e 要素 ／
`href$a 属性を有する `a$e 要素
］の `draggable$m 属性 は既定で ~T に設定される。
◎
img elements and a elements with an href attribute have their draggable attribute set to true by default.
</p>

	</li>

	<li>
`~store@V ~LET 新たな`~drag-data~store$を`作成-$dSした結果
— この節の手続きにて発火される すべての~DND~eventは、この `~store$V を利用し~MUST。
◎
Create a drag data store. All the DND events fired subsequently by the steps in this section must use this drag data store.
</li>
	<li>
<p>
`~source~node@V ~SET %~drag対象 に応じて、次で与えられる~node：
◎
Establish which DOM node is the source node, as follows:
</p>

		<dl class="switch">
			<dt>選択</dt>
			<dd>
利用者が~dragを開始した `Text$I ~node
◎
↓</dd>
			<dd>
これは概して，利用者が最初に~clickした `Text$I ~nodeになるが、利用者が特定0の~nodeを指定しなかった場合には（例えば利用者は、単に， “現在の選択” を~dragし始めるよう~UAに伝えた場合）、
“現在の選択”
のある部分を包含しているような，最初の `Text$I ~nodeになる。
◎
If it is a selection that is being dragged, then the source node is the Text node that the user started the drag on (typically the Text node that the user originally clicked). If the user did not specify a particular node, for example if the user just told the user agent to begin a drag of "the selection", then the source node is the first Text node containing a part of the selection.
</dd>
			<dd class="trans-note">【
何が選択を表現するのか定義されていないが、選択された範囲を表現する~DOM`範囲~obj$xと考えればよいであろう。
】</dd>

			<dt>要素</dt>
			<dd>
%~drag対象
◎
Otherwise, if it is an element that is being dragged, then the source node is the element that is being dragged.
</dd>

			<dt>`外部のもの$</dt>
			<dd>
なし（ %~drag対象 は別の~appの一部である ）
— この仕様が `~source~node$V に向けて~eventを発火するよう要求する所では、~UAは，代わりに その状況に関連する~platform特有の規約に従わ~MUST。
◎
Otherwise, the source node is part of another document or application. When this specification requires that an event be dispatched at the source node in this case, the user agent must instead follow the platform-specific conventions relevant to that situation.
</dd>
		</dl>

<p class="note">注記：
~DnD演算の最中には、 `~source~node$V に向けて複数の~eventが発火される。
◎
Multiple events are fired on the source node during the course of the drag-and-drop operation.
</p>

	</li>
	<li>
<p>
`被~drag~node~list@V
~SET %~drag対象 に応じて、次で与えられる~list：
◎
Determine the list of dragged nodes, as follows:
</p>

		<dl class="switch">
			<dt>選択</dt>
			<dd>
［
その選択~内に部分的にまたは完全に含まれている†
］すべての~nodeを包含する，`木~順序$xによる~list。
◎
If it is a selection that is being dragged, then the list of dragged nodes contains, in tree order, every node that is partially or completely included in the selection (including all their ancestors).
</dd>
			<dd class="trans-note">【†
その選択を表現する`範囲~obj$xに
<a href="~DOM4#partially-contained">部分的に</a>
または
<a href="~DOM4#contained">全部的に</a>
包含されている~node。
】</dd>
			<dt>要素</dt>
			<dd>
`~source~node$V のみを包含する~list
◎
Otherwise, the list of dragged nodes contains only the source node, if any.
</dd>

			<dt>`外部のもの$</dt>
			<dd>
空~list
◎
↑</dd>
		</dl>
	</li>
	<li>
<p>
%~drag対象 に応じて：
</p>

		<dl class="switch">
			<dt>選択</dt>
			<dd>
<p>
次のようにされた`~item$を `~store$V の`~item~list$dSに追加する：
</p>

<ul><li>`型~文字列$dI ~SET `text/plain$l
</li><li>`種類$dI ~SET `Plain Unicode string^i
</li><li>`実data$dI ~SET 選択の~text
</li></ul>

◎
If it is a selection that is being dragged, then add an item to the drag data store item list, with its properties set as follows:
• The drag data item type string
•• "text/plain"
• The drag data item kind
•• Plain Unicode string
• The actual data
•• The text of the selection
</dd>

			<dt>~fileたち（`外部のもの$）</dt>
			<dd>
<p>
次のようにされた`~item$を `~store$V の`~item~list$dSに追加する：
</p>

<ul><li>`型~文字列$dI ~SET ~fileの~MIME型が既知ならば それ ／
~ELSE_ `application/octet-stream$l
</li><li>`種類$dI ~SET `File^i
</li><li>`実data$dI ~SET ~fileの内容と名前
</li></ul>

◎
Otherwise, if any files are being dragged, then add one item per file to the drag data store item list, with their properties set as follows:
• The drag data item type string
•• The MIME type of the file, if known, or "application/octet-stream" otherwise.
• The drag data item kind
•• File
• The actual data
•• The file's contents and name.
</dd>
			<dd class="note">注記：
~fileたちが~dragされるのは、現在の`閲覧文脈$の外側から
— 例えば ~file~system~~管理~appから —
に限られる。
◎
Dragging files can currently only happen from outside a browsing context, for example from a file system manager application.
</dd>
		</dl>

<div class="p">
<p>
%~drag対象 が`外部のもの$である場合、次が~UAに要求される：
</p>

		<ul>
			<li>
~platform規約を適切に尊守する下で、~dragされている~dataに適切な`~item$を， `~store$V の`~item~list$dSに追加する。
</li>
			<li>
~platform規約が［
~dragされた~dataの型として`~MIME型$を利用していない
］場合、その型から~MIME型へ対応付けるよう極力努める。
</li>
			<li>
いずれにせよ、`~item$の`型~文字列$dIは，`~ASCII小文字化$され~MUST。
</li>
		</ul>

◎
If the drag initiated outside of the application, the user agent must add items to the drag data store item list as appropriate for the data being dragged, honoring platform conventions where appropriate; however, if the platform conventions do not use MIME types to label dragged data, the user agent must make a best-effort attempt to map the types to MIME types, and, in any case, all the drag data item type strings must be converted to ASCII lowercase.
</div>

<p>
~UAは、選択／~dragされた要素（たち）を表現するような，他の形による
— 例：~HTMLとして —
いくつかの`~item$を追加してもよい。
◎
User agents may also add one or more items representing the selection or dragged element(s) in other forms, e.g. as HTML.
</p>

	</li>
	<li>
<p>
~IF［
`被~drag~node~list$V は空でない
］：
</p>
		<ol>
			<li>
%~JSON文字列 ~LET ~list内の~nodeから
<a href="~HTML5/microdata.html#extracting-json">~microdataを抽出して~JSON形に</a>
した結果
</li>
			<li>
<p>
次のようにされた`~item$を `~store$V の`~item~list$dSに追加する：
</p>

<ul><li>`型~文字列$dI ~SET `application/microdata+json$l
</li><li>`種類$dI ~SET `Plain Unicode string^i
</li><li>`実data$dI ~SET %~JSON文字列
</li></ul>

			</li>
		</ol>
◎
If the list of dragged nodes is not empty, then extract the microdata from those nodes into a JSON form, and add one item to the drag data store item list, with its properties set as follows:
• The drag data item type string
•• "application/microdata+json"
• The drag data item kind
•• Plain Unicode string
• The actual data
•• The text of the selection
</li>
	<li>
<p>
次を走らす：
◎
Run the following substeps:
</p>
		<ol>
			<li>
%~url~list ~LET 空~list
◎
Let urls be an empty list of absolute URLs.
</li>
			<li>
<p>
~FOR
`被~drag~node~list$V 内の ~EACH( %~node ) に対し：
◎
For each node in the list of dragged nodes:
</p>
				<ol>
					<li>
~IF［
%~node は `href$a 内容~属性を有する `a$e 要素である
］
⇒
要素の `href$a 内容~属性~値を %~url~list に追加する
◎
If the node is an a element with an href attribute
• Add to urls the result of parsing the element's href content attribute relative to the element's node document.
</li>
			<li>
~ELIF［
%~node は `src$a 属性を有する `img$e 要素である
］
⇒
要素の `src$a 内容~属性~値を %~url~list に追加する

◎
If the node is an img element with a src attribute
• Add to urls the result of parsing the element's src content attribute relative to the element's node document.
</li>
				</ol>
			</li>
			<li>
~IF［
%~url~list は空である
］
⇒
~GOTO `(A)^i
◎
If urls is still empty, abort these substeps.
</li>
			<li>
%~url~list 内の各~文字列を［
要素の`~node文書$xに`相対的に構文解析-$した`結果の~URL文字列$
］に置換する
◎
↑</li>
			<li>
%~url文字列 ~LET %~url~list 内の各~文字列を CRLF （ U+000D, U+000A 並び） で区切って連結した結果
◎
Let url string be the result of concatenating the strings in urls, in the order they were added, separated by a U+000D CARRIAGE RETURN U+000A LINE FEED character pair (CRLF).
</li>
			<li>
<p>
次のようにされた`~item$を `~store$V の`~item~list$dSに追加する：
</p>

<ul><li>`型~文字列$dI ~SET `text/uri-list$l
</li><li>`種類$dI ~SET `Plain Unicode string^i
</li><li>`実data$dI ~SET %~url文字列
</li></ul>

◎
Add one item to the drag data store item list, with its properties set as follows:
• The drag data item type string
•• "text/uri-list"
• The drag data item kind
•• Plain Unicode string
• The actual data
•• url string
</li>
		</ol>
	</li>
	<li>
<p>
`(A)^i：
`~store$V の`既定の~feedback$dSを，適切に更新する
— %drag~対象 に応じて：
</p>

<ul ><li>選択である場合、~feedbackは，その選択に基づくことになるであろう。
</li><li>要素である場合、その要素の描画が利用されることになるであろう。
</li><li>`外部のもの$である場合、~UAは，~platform規約を利用して~feedbackを決定するべきである。
</li>
</ul>

◎
Update the drag data store default feedback as appropriate for the user agent (if the user is dragging the selection, then the selection would likely be the basis for this feedback; if the user is dragging an element, then that element's rendering would be used; if the drag began outside the user agent, then the platform conventions for determining the drag feedback should be used).
</li>
	<li>
%~event ~LET
`~source~node$V に向けて，名前 `dragstart$et の`~DND~eventを発火-$した結果
◎
Fire a DND event named dragstart at the source node.
</li>
	<li>
<p>
~IF［
%~event は取消された
］
⇒
~RET
— ~DnD演算は生じるべきでない
◎
If the event is canceled, then the drag-and-drop operation should not occur; abort these steps.
</p>


<p class="note">注記：
~event~listenerが登録されていない~eventは、ほぼ定義により，決して取消されないので、~DnDは，作者が特に防止しない限り常に利用者に可用になる。
◎
Since events with no event listeners registered are, almost by definition, never canceled, drag-and-drop is always available to the user if the author does not specifically prevent it.
</p>

   </li>
	<li>
<p>
~platform規約に整合する方式で，下に述べるように`~DnD演算が起動され$る：
◎
Initiate the drag-and-drop operation in a manner consistent with platform conventions, and as described below.
</p>

<p id="base-dnd-feedback">
~DnD~feedbackは、［
`~store$V の`~bitmap$dSが可用ならば それ ／
~ELSE_ `~store$V の`既定の~feedback$dS
］から生成され~MUST
⇒
前者の場合、 `~store$V の`~hot-spot座標$dSも，結果の画像の中で~cursorをどこに置くかの~hintとして利用されるべきである。
値は、画像の ( 左端, 上端 ) からの `CSS ~pixel単位$xによる距離とする。
`CSS$r
◎
The drag-and-drop feedback must be generated from the first of the following sources that is available:
◎
The drag data store bitmap, if any. In this case, the drag data store hot spot coordinate should be used as hints for where to put the cursor relative to the resulting image. The values are expressed as distances in CSS pixels from the left side and from the top side of the image respectively. [CSS]
◎
The drag data store default feedback.
</p>
	</li>
</ol>



<p>
~UAは、
`~DnD演算が起動され@
た時点から それが終わるまでの間は：
◎
↓</p>


<ul>
	<li>
装置~入力~event（例： ~mouseや~keyboard~event）は、抑止し~MUST。
◎
From the moment that the user agent is to initiate the drag-and-drop operation, until the end of the drag-and-drop operation, device input events (e.g. mouse and keyboard events) must be suppressed.
</li>
	<li>
<p>
次のものを保持する
— これらは、以下に与える手続きに述べるように，~UAにより更新される：
◎
↓</p>

		<dl class="def-list">
			<dt>`現在の標的~要素@</dt>
			<dd>
~DnD演算の~dropに関して，現在~選択されている要素。
初期~時は ~NULL。
◎
↓</dd>

			<dt>`直の利用者~選択@</dt>
			<dd>
~drag演算の間に，利用者により直接的に~drop標的として指示されている要素
`初期~時は~NULL。^tnote
（利用者により選択され得るのは要素のみであり、他の~nodeが~drop標的として可用にされては~MUST_NOT
`が、下に述べるように，直の利用者~選択が要素に限られるわけではない。^tnote
）。
しかしながら，`直の利用者~選択$は、`現在の標的~要素$になるとは限らない。
◎
During the drag operation, the element directly indicated by the user as the drop target is called the immediate user selection. (Only elements can be selected by the user; other nodes must not be made available as drop targets.) However, the immediate user selection is not necessarily the current target element, which is the element currently selected for the drop part of the drag-and-drop operation.
</dd>

			<dd>
`直の利用者~選択$は、利用者が異なる要素を選択するに伴い変化する（~pointing装置によりそれらを指すことにより, あるいは他の何らかの仕方で選択することにより）。
`直の利用者~選択$が変化するに伴い、下に述べるように，文書~内の~event~listenerによる結果に基づいて，`現在の標的~要素$も変化する。
◎
The immediate user selection changes as the user selects different elements (either by pointing at them with a pointing device, or by selecting them in some other way). The current target element changes when the immediate user selection changes, based on the results of event listeners in the document, as described below.
</dd>
			<dd>
`現在の標的~要素$, `直の利用者~選択$
の両者とも，途中で ~NULL になり得る
— その場合、どの標的~要素も選択されていないことを意味する。
また、いずれも［
同じ~UA内の他の（~DOMに基づく）文書~内の要素, あるいは
~UA外の~program内の何か
］にもなり得る（例えば利用者は、~textを~text編集~programに~dragすることもできる。）
◎
Both the current target element and the immediate user selection can be null, which means no target element is selected. They can also both be elements in other (DOM-based) documents, or other (non-Web) programs altogether. (For example, a user could drag text to a word-processor.) The current target element is initially null.
</dd>

			<dt>`現在の~drag演算@</dt>
			<dd>
とり得る値は、次のいずれか：
`none@op （初期~時の値）,
`copy@op,
`link@op,
`move@op
◎
In addition, there is also a current drag operation, which can take on the values "none", "copy", "link", and "move". Initially, it has the value "none". It is updated by the user agent as described in the steps below.
</dd>
		</dl>
	</li>
</ul>


<div>
<p class="algo-head">
~UAは、`~DnD演算が起動され$たときは，次の手続きを並列的に走らせ~MUST：
</p>

<ol>
	<li>
%停止 ~LET ~F
</li>
	<li>
<p>
%~task ~LET 次の手続きを遂行する~task：
</p>
		<ol>
			<li>
%~event ~LET
`~source~node$V に向けて，名前 `drag$et の`~DND~eventを発火-$した結果：
</li>
			<li>
<p >
~IF［
%~event は取消された
］~OR［
利用者は~DnD演算を終わらせた（例：~mouse駆動による~DnD~UIの下で ~mouse~buttonを解放したなど）
］
</p>
				<ol>
					<li>
~IF［
%~event は取消された
］
⇒
`現在の~drag演算$ ~SET `none$op
</li>
					<li>
%停止 ~SET ~T
</li>
					<li>
`~drag演算の最終回~手続き$を走らす
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
`~drag演算の継続~手続き$を走らす
</li>

		</ol>
	</li>

	<li>
<p>
~WHILE %停止 ~EQ ~F：
</p>
		<ol>
			<li>
~IF［
この反復は初回でない
］~AND［
前回の反復の開始から約 350ms (±200ms）以上 経過していない
］
⇒
経過するまで待機する
</li>
			<li>
%~task を`待入する$
</li>
			<li>
%~task を遂行し終えるまで待機する
</li>
		</ol>
	</li>
</ol>

◎
User agents must, as soon as the drag operation is initiated and every 350ms (±200ms) thereafter for as long as the drag operation is ongoing, queue a task to perform the following steps in sequence:
• If the user agent is still performing the previous iteration of the sequence (if any) when the next iteration becomes due, abort these steps for this iteration (effectively "skipping missed frames" of the drag-and-drop operation).
• Fire a DND event named drag at the source node. If this event is canceled, the user agent must set the current drag operation to "none" (no drag operation).
• If the drag event was not canceled and the user has not ended the drag-and-drop operation, check the state of the drag-and-drop operation, as follows:
↓
</div>

<p class="algo-head">
`~drag演算の継続~手続き@
は、次を走らす：
◎
↓</p>


<ol>
	<li>
%S ~LET （現時点での）`直の利用者~選択$
◎
↓</li>
	<li>
~IF［
%S は前回の それから変化していない
］
⇒
~RET
◎
↓</li>
	<li>
%前~標的 ~SET `現在の標的~要素$
◎
↓</li>
	<li>
~IF［
%S ~EQ %前~標的
］
⇒
~RET
◎
↓</li>
	<li>
~IF［
%前~標的 は~DOM要素である
］
⇒
%前~標的 に向けて名前 `dragexit$et の`~DND~eventを発火-$する
◎
If the user is indicating a different immediate user selection than during the last iteration (or if this is the first iteration), and if this immediate user selection is not the same as the current target element, then fire a DND event named dragexit at the current target element, and then update the current target element as follows:
</li>
	<li>
<p>
`現在の標的~要素$ ~SET 次の下位手続きを走らせた結果：
◎
↑</p>

		<ol>
			<li>
~IF［
%S は~DOM要素でない
］
⇒
~RET %S
◎
If the new immediate user selection is null
• Set the current target element to null also.
◎
If the new immediate user selection is in a non-DOM document or application
• Set the current target element to the immediate user selection.
</li>
			<li>
%~event ~LET
%S に向けて，名前 `dragenter$et の`~DND~eventを発火-$した結果
◎
Otherwise
◎
Fire a DND event named dragenter at the immediate user selection.
</li>

			<li>
~IF［
%~event は取消された
］
⇒
~RET %S
◎
If the event is canceled, then set the current target element to the immediate user selection.
◎
Otherwise, run the appropriate step from the following list:
</li>
			<li>
<p>
~IF［
次のいずれも満たされる
］…：
</p>

<ul ><li>%S は`~text編集域$である
</li><li>`~store$V の`~item~list$dS内に［
`型~文字列$dI ~EQ `text/plain$l
］~AND［
`種類$dI ~EQ `Plain Unicode string^i
］なる`~item$がある
</li></ul>

<p >
…ならば
⇒
~RET %S
</p>
◎
If the immediate user selection is a text control (e.g. textarea, or an input element whose type attribute is in the Text state) or an editing host or editable element, and the drag data store item list has an item with the drag data item type string "text/plain" and the drag data item kind Plain Unicode string
• Set the current target element to the immediate user selection anyway.
</li>
			<li>
<p>
~IF［
%S は `~store$V に`~dropzone合致する$
］
⇒
~RET %S
◎
If the immediate user selection is an element with a dropzone attribute that matches the drag data store
• Set the current target element to the immediate user selection anyway.
</li>
			<li>
<p>
~IF［
%S のある先祖~要素は， `~store$V に`~dropzone合致する$
］：
◎
If the immediate user selection is an element that itself has an ancestor element with a dropzone attribute that matches the drag data store
</p>

				<ol>
					<li>
%T ~LET そのような先祖~要素のうち， %S に最も近い（最も深い）もの
◎
Let new target be the nearest (deepest) such ancestor element.
</li>
					<li>
<p>
~IF［
%S ~EQ %T
］
⇒
~RET %前~標的
</p>

<p class="trans-note">【
？ %S ~EQ %T はあり得ない筈
】</p>
◎
If the immediate user selection is new target, then leave the current target element unchanged.
</li>
					<li>
%T に向けて，名前 `dragenter$et の`~DND~eventを発火-$する
— 関係する標的として， %前~標的 も与える
◎
Otherwise, fire a DND event named dragenter at new target, with the current current target element as the specific related target. Then, set the current target element to new target, regardless of whether that event was canceled or not.
</li>
					<li>
~RET %T
◎
↑</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
%文書 ~LET %S が属する `Document$I ~obj
◎
↓</li>
					<li>
%body ~LET %文書 の`~body要素$
◎
↓</li>
					<li>
~IF［
%S ~EQ %body
］
⇒
~RET %前~標的
◎
If the immediate user selection is the body element
• Leave the current target element unchanged.
</li>
					<li>
［
%body ~NEQ ~NULL ならば %body ／
~ELSE_ %文書
］に向けて，名前 `dragenter$et の`~DND~eventを発火-$する
◎
Otherwise
• Fire a DND event named dragenter at the body element, if there is one, or at the Document object, if not. Then, set the current target element to the body element, regardless of whether that event was canceled or not.
</li>
					<li>
~RET %body
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%現~標的 ~SET `現在の標的~要素$
◎
↓</li>
	<li>
~IF［
%前~標的 は~DOM要素である
］~AND［
%現~標的 ~NEQ %前~標的 
］
⇒
%前~標的 に向けて，名前 `dragleave$et の`~DND~eventを発火-$する
— 関係する標的として， %現~標的 も与える
◎
If the previous step caused the current target element to change, and if the previous target element was not null or a part of a non-DOM document, then fire a DND event named dragleave at the previous target element, with the new current target element as the specific related target.
</li>

	<li>
<p>
~IF［
%現~標的 は~DOM要素である
］：
◎
↓</p>
		<ol>
			<li>
%~event ~LET
%現~標的 に向けて，名前 `dragover$et の`~DND~eventを発火-$した結果
◎
If the current target element is a DOM element, then fire a DND event named dragover at this current target element.
</li>
			<li>
<p>
~IF［
%~event は取消されなかった
］：
◎
If the dragover event is not canceled, run the appropriate step from the following list:
</p>
				<ol>
					<li>
~IF［
%現~標的 は`~text編集域$である
］~AND［
`~store$V の`~item~list$dS内に［
`型~文字列$dI ~EQ `text/plain$l
］~AND［
`種類$dI ~EQ `Plain Unicode string^i
］なる`~item$がある
］
⇒
`現在の~drag演算$ ~SET ［
`copy$op, `move$op
］のうち，~platform規約に適切な方
◎
If the current target element is a text control (e.g. textarea, or an input element whose type attribute is in the Text state) or an editing host or editable element, and the drag data store item list has an item with the drag data item type string "text/plain" and the drag data item kind Plain Unicode string
• Set the current drag operation to either "copy" or "move", as appropriate given the platform conventions.
</li>
					<li>
~ELSE
⇒
`現在の~drag演算$ ~SET %現~標的 が `指定する~drag演算$
◎
If the current target element is an element with a dropzone attribute that matches the drag data store and specifies an operation
• Set the current drag operation to the operation specified by the dropzone attribute of the current target element.
• If the current target element is an element with a dropzone attribute that matches the drag data store and does not specify an operation
• Set the current drag operation to "copy".
◎
Otherwise
• Reset the current drag operation to "none".
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %~event は取消された）
⇒
`現在の~drag演算$ ~SET
%~event の `dataTransfer$m 属性~値の
( `effectAllowed$m, `dropEffect$m )
属性~値に応じて，次の表の 3 列目に与えられる値：
◎
Otherwise (if the dragover event is canceled), set the current drag operation based on the values of the effectAllowed and dropEffect attributes of the DragEvent object's dataTransfer object as they stood after the event dispatch finished, as per the following table:
</p>

<table><thead><tr><th>`effectAllowed$m
</th><th>`dropEffect$m
</th><th>~drag演算
</th></tr></thead>

<tbody><tr><td>`uninitialized$tE, `copy$tE, `copyLink$tE, `copyMove$tE, `all$tE
</td><td>`copy$tD
</td><td>`copy$op

</td></tr><tr><td>`uninitialized$tE, `link$tE, `copyLink$tE, `linkMove$tE, `all$tE
</td><td>`link$tD
</td><td>`link$op

</td></tr><tr><td>`uninitialized$tE, `move$tE, `copyMove$tE, `linkMove$tE, `all$tE
</td><td>`move$tD
</td><td>`move$op

</td></tr><tr><td colspan="2">
その他の場合
◎
Any other case
</td><td>`none$op

</td></tr></tbody></table>

			</li>
		</ol>
	</li>
	<li>
~ELSE（ %現~標的 は~DOM要素でない）
⇒
`現在の~drag演算$ ~SET
~platform特有の仕組みを利用して，どの~drag演算を遂行するかを決定した結果（ `none^l, `copy^l, `link^l, `move^l のいずれか）
◎
Otherwise, if the current target element is not a DOM element, use platform-specific mechanisms to determine what drag operation is being performed (none, copy, link, or move), and set the current drag operation accordingly.
</li>
<li>
<p>
次に従って、`現在の~drag演算$に合致するように
~drag~feedback（例： ~mouse~cursor）を更新する：
◎
Update the drag feedback (e.g. the mouse cursor) to match the current drag operation, as follows:
</p>

<table><thead><tr><th>
~drag演算
◎
Drag operation
</th><th>
~feedback
◎
Feedback
</th></tr></thead>

<tbody><tr><td>`copy$op</td><td>
ここに~dropされた~dataは複製される。
◎
Data will be copied if dropped here.


</td></tr><tr><td>`link$op</td><td>
ここに~dropされた~dataは~linkされる。
◎
Data will be linked if dropped here.


</td></tr><tr><td>`move$op</td><td>
ここに~dropされた~dataは移動される。
◎
Data will be moved if dropped here.


</td></tr><tr><td>`none$op</td><td>
許容される演算はない。
ここに~dropされたときには，~DnD演算は取消される。
◎
No operation allowed, dropping here will cancel the drag-and-drop operation.

</td></tr></tbody></table>

	</li>
</ol>

<div class="p">
<p>
この節に述べる~DnD演算の［
継続／最終回
］手続きの目的においては、次に該当するものが
`~text編集域@
とされる
</p>

<ul ><li>~text~control（例：
`textarea$e, ［
`type$a 属性の状態 ~EQ `Text$st
］なる `input$e 要素など）
</li><li>`編集中の~host$
</li><li>`編集可能$な要素
</li></ul>
◎
↑↓</div>



<p class="algo-head">
`~drag演算の最終回~手続き@
は、次を走らす：
◎
Otherwise, if the user ended the drag-and-drop operation (e.g. by releasing the mouse button in a mouse-driven drag-and-drop interface), or if the drag event was canceled, then this will be the last iteration. Run the following steps, then stop the drag-and-drop operation:
</p>

<ol>
	<li>
%現~標的 ~SET `現在の標的~要素$
◎
↓</li>
	<li>
<p >
%~dropped ~LET ［
次のいずれかが満たされるならば ~F ／
~ELSE_ ~T
］
</p>

<ul><li>`現在の~drag演算$ ~EQ `none$op
</li><li>利用者が~DnD演算を取消して終わらせた（例： <kbd>Escape</kbd> ~keyを叩いたなど）
</li><li>%現~標的 ~EQ ~NULL（~drag演算は失敗した）
</ul>

◎
If the current drag operation is "none" (no drag operation), or, if the user ended the drag-and-drop operation by canceling it (e.g. by hitting the Escape key), or if the current target element is null, then the drag operation failed. Run these substeps:
</li>

	<li>
<p>
~IF［
%~dropped ~EQ ~F
］：
◎
Let dropped be false.
</p>

		<ol>
			<li>
~IF［
%現~標的 は~DOM要素である
］
⇒
%現~標的 に向けて，名前 `dragleave$et の`~DND~eventを発火-$する
◎
↓</li>
			<li>
~ELIF［
%現~標的 ~NEQ ~NULL
］
⇒
~drag取消ionに対する~platform特有の規約を利用する
◎
If the current target element is a DOM element, fire a DND event named dragleave at it; otherwise, if it is not null, use platform-specific conventions for drag cancelation.
</li>
			<li>
`現在の~drag演算$ ~SET `none$op
◎
Set the current drag operation to "none".
</li>
		</ol>
	</li>

	<li>
<p>
~ELSE（~drag演算はおよそ成功した）：
◎
Otherwise, the drag operation might be a success; run these substeps:
◎
Let dropped be true.
</p>

		<ol>
			<li>
<p>
~IF［
%現~標的 は ~DOM要素である
］：
◎
↓</p>
				<ol>
					<li>
%~event ~LET
%現~標的 に向けて，名前 `drop$et の`~DND~eventを発火-$した結果
◎
If the current target element is a DOM element, fire a DND event named drop at it; otherwise, use platform-specific conventions for indicating a drop.
</li>
					<li>
~IF［
%~event は取消された
］
⇒
`現在の~drag演算$ ~SET %~event の `dataTransfer$m 属性~値の `dropEffect$m 属性~値
◎
If the event is canceled, set the current drag operation to the value of the dropEffect attribute of the DragEvent object's dataTransfer object as it stood after the event dispatch finished.
</li>
					<li>
<p>
~ELIF［
次のいずれも満たされる
］：
◎
Otherwise, the event is not canceled; perform the event's default action, which depends on the exact target as follows:
</p>

<div >
<ul ><li>%現~標的 は`~text編集域$である
</li><li>`~store$V の`~item~list$dS内に［
`型~文字列$dI ~EQ `text/plain$l
］~AND［
`種類$dI ~EQ `Plain Unicode string^i
］なる`~item$がある
</li></ul>

◎
If the current target element is a text control (e.g. textarea, or an input element whose type attribute is in the Text state) or an editing host or editable element, and the drag data store item list has an item with the drag data item type string "text/plain" and the drag data item kind Plain Unicode string
</div>

<p>
…ならば（ %~event の既定~動作を遂行する）
⇒
［
そのような`~item$のうち，`~store$V の`~item~list$dS内で最初のもの
］の`実data$dIを，~platform特有の規約に整合する方式で， %現~標的 の中に挿入する
（例： 現在の~mouse~cursor位置-の所に挿入する ／ ~fieldの末尾に挿入する。）
◎
Insert the actual data of the first item in the drag data store item list to have a drag data item type string of "text/plain" and a drag data item kind that is Plain Unicode string into the text control or editing host or editable element in a manner consistent with platform-specific conventions (e.g. inserting it at the current mouse cursor position, or inserting it at the end of the field).
</p>
					</li>
					<li>
~ELSE
⇒
`現在の~drag演算$ ~SET `none$op
◎
Otherwise
• Reset the current drag operation to "none".
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
~platform特有の規約を利用して，~dropを指示する
◎
↑</li>
		</ol>
	</li>
	<li>
<p >
`~source~node$V に向けて，名前 `dragend$et の`~DND~eventを発火-$する
— ~eventの既定~動作として以下を行う：
◎
Fire a DND event named dragend at the source node.
◎
Run the appropriate steps from the following list as the default action of the dragend event:
</p>

		<ol>
			<li>
<p>
~IF［
次のいずれも満たされる
］…
</p>

<ul ><li>%~dropped ~EQ ~T
</li><li>`現在の~drag演算$ ~EQ `move$op
</li><li>%現~標的 は~text~controlである（下を見よ）
</li></ul>

<p>
…ならば：
</p>
				<ol>
					<li>
~IF［
~DnD演算の~sourceは，ある`編集中の~host$の中に全体が包含されているような，~DOM内の選択である
］
⇒
`選択を削除-$する
</li>
					<li>
~ELIF［
~DnD演算の~sourceは ある~text~control内の選択である
］
⇒
~UAは~dragされた選択を，当の~text~controlから削除するべきである
</li>
				</ol>
◎
If dropped is true, the current target element is a text control (see below), the current drag operation is "move", and the source of the drag-and-drop operation is a selection in the DOM that is entirely contained within an editing host
• Delete the selection.
◎
If dropped is true, the current target element is a text control (see below), the current drag operation is "move", and the source of the drag-and-drop operation is a selection in a text control
• The user agent should delete the dragged selection from the relevant text control.
</li>
			<li>
~ELIF［
%~dropped ~EQ ~F
］~OR［
`現在の~drag演算$ ~EQ `none$op
］
⇒
~dragは取消された —
~platform規約にて，取消されたことを利用者に対し表現する（例： ~dragされた選択を，~DnD演算の~sourceに戻すように~animateするなど）ように指図されているならば、そうする
◎
If dropped is false or if the current drag operation is "none"
◎
The drag was canceled. If the platform conventions dictate that this be represented to the user (e.g. by animating the dragged selection going back to the source of the drag-and-drop operation), then do so.
</li>
			<li>
~ELSE
⇒
（既定~動作なし）
◎
Otherwise
◎
The event has no default action.
</li>
		</ol>

<p>
この段の目的における~text~controlとは、［
`textarea$e 要素であるか, または［
`input$e 要素であって，その `type$a 属性の状態 ~IN
{ `Text$st, `Search$st, `Tel$st, `URL$st, `E-mail$st, `Password$st, `Number$st }
］なるもの
］である。
◎
For the purposes of this step, a text control is a textarea element or an input element whose type attribute is in one of the Text, Search, Tel, URL, E-mail, Password, or Number states.
</p>

<!-- ＊
この~text~controlと~text編集域$の~text~controlが同じものを指すのかどうかは、はっきりしない。
 -->

	</li>
</ol>


<p class="note">注記：
~UAには、~scrollable領域の辺に近い~dragに対し，どう反応するか考慮することが奨励される。
例えば、利用者がある~drag対象を長い頁の`表示域$xの下端~近くに~dragした場合、頁を~scrollして，利用者がその対象を頁の~~下方へ~dropできるようにすることには~~意味があろう。
◎
User agents are encouraged to consider how to react to drags near the edge of scrollable regions. For example, if a user drags a link to the bottom of the viewport on a long page, it might make sense to scroll the page so that the user can drop the link lower on the page.
</p>


<p class="note">注記：
この~modelは、~nodeを孕んでいる `Document$I ~objからは，独立である
— 演算に孕まれている文書の個数に~~関係なく、上述したとおりに，~eventは発火され，処理~modelを走らす。
◎
This model is independent of which Document object the nodes involved are from; the events are fired as described above and the rest of the processing model runs as described above, irrespective of how many documents are involved in the operation.
</p>


		</section>
		<section id="dndevents">
<h3 title="Events summary">6.7.6. ~event要覧</h3>

~INFORMATIVE

<p>
~DnD~modelに孕まれる~eventを次の一覧に要約する：
◎
The following events are involved in the drag-and-drop model.
</p>

<div >
<table><thead><tr><th>~event名
</th><th>標的
</th><th>取消可否
</th><th>`~mode$dS
</th><th>`dropEffect$m
</th><th>既定~動作
</th></tr></thead>

<tbody><tr><td>`dragstart@et
</td><td>`~source~node$V
</td><td>可
</td><td>`可書~mode$i
</td><td>`none$tD
</td><td>~DnD演算を起動する

</td></tr><tr><td>`drag@et
</td><td>`~source~node$V
</td><td>可
</td><td>`被保護~mode$i
</td><td>`none$tD
</td><td>~DnD演算を継続する

</td></tr><tr><td>`dragenter@et
</td><td>`直の利用者~選択$, または`~body要素$
</td><td>可
</td><td>`被保護~mode$i
</td><td>`effectAllowed$m の<a href="#dropEffect-initialisation">値に基づく</a>
</td><td>`現在の標的~要素$になり得るものとして，`直の利用者~選択$は却下する

</td></tr><tr><td>`dragexit@et
</td><td>前回の，`現在の標的~要素$
</td><td>不可
</td><td>`被保護~mode$i
</td><td>`none$tD
</td><td>なし

</td></tr><tr><td>`dragleave@et
</td><td>前回の，`現在の標的~要素$
</td><td>不可
</td><td>`被保護~mode$i
</td><td>`none$tD
</td><td>なし

</td></tr><tr><td>`dragover@et
</td><td>`現在の標的~要素$
</td><td>可
</td><td>`被保護~mode$i
</td><td>`effectAllowed$m の<a href="#dropEffect-initialisation">値に基づく</a>
</td><td>`現在の~drag演算$を `none$op に再設定する

</td></tr><tr><td>`drop@et
</td><td>`現在の標的~要素$
</td><td>可
</td><td>`読専~mode$i
</td><td>`現在の~drag演算$
</td><td>文脈依存

</td></tr><tr><td>`dragend@et
</td><td>`~source~node$V
</td><td>不可
</td><td>`被保護~mode$i
</td><td>`現在の~drag演算$
</td><td>文脈依存

</td></tr></tbody></table>

◎
Event Name 	Target 	Cancelable? 	Drag data store mode 	dropEffect 	Default Action
dragstart	Source node	✓ Cancelable	Read/write mode 	"none"	Initiate the drag-and-drop operation
drag	Source node	✓ Cancelable	Protected mode 	"none"	Continue the drag-and-drop operation
dragenter	Immediate user selection or the body element	✓ Cancelable	Protected mode 	Based on effectAllowed value	Reject immediate user selection as potential target element
dragexit	Previous target element	—	Protected mode 	"none"	None
dragleave	Previous target element	—	Protected mode 	"none"	None
dragover	Current target element	✓ Cancelable	Protected mode 	Based on effectAllowed value	Reset the current drag operation to "none"
drop	Current target element	✓ Cancelable	Read-only mode 	Current drag operation	Varies
dragend	Source node	—	Protected mode 	Current drag operation	Varies
</div>

<div class="p">

<p>
これらのどの~eventも：
</p>

<ul ><li>浮上する。
</li><li>~composed。
</li><li>`effectAllowed$m 属性の値は、
`dragstart$et ~eventを配送した結果の値をとり続ける。
配送-前は既定の `uninitialized$tE をとる。
</li></ul>
◎
Not shown in the above table: all these events bubble, are composed, and the effectAllowed attribute always has the value it had after the dragstart event, defaulting to "uninitialized" in the dragstart event.
</div>



		</section>
		<section id="the-draggable-attribute">
<h3 title="The draggable attribute">6.7.7. `draggable^a 属性</h3>

`26024^bug

<div class="p">
<p>
`draggable$a 内容~属性は、すべての
`~HTML要素$に設定できる。
この属性は`列挙~属性$であり、次の 3 つの状態をとり得る：
</p>

<dl ><dt>`~T^st
</dt><dd>属性~値に対する~keyword `true^v は、この状態に対応する。
</dd><dd>要素は~draggableになることを意味する。

</dd><dt>`~F^st
</dt><dd>属性~値に対する~keyword `false^v は、この状態に対応する。
</dd><dd>要素は~draggableにならないことを意味する。

</dd><dt>`自動^st
</dt><dd>`値なしに対する既定$は、この状態に対応する。
</dd><dd>~UAによる既定の挙動を利用することを意味する。

</dd></dl>

<p class="trans-note">【
`妥当でない値に対する既定$は定義されていないので、定義により， `自動^st 状態に対応することになる。
】</p>


◎
All HTML elements may have the draggable content attribute set. The draggable attribute is an enumerated attribute. It has three states. The first state is true and it has the keyword true. The second state is false and it has the keyword false. The third state is auto; it has no keywords but it is the missing value default.
◎
The true state means the element is draggable; the false state means that it is not. The auto state uses the default behavior of the user agent.
</div>


<p>
`draggable$a 属性を有する要素は、視覚的でない対話~用に，
`title$a 属性で命名されるべきである。
◎
An element with a draggable attribute should also have a title attribute that names the element for the purpose of non-visual interactions.
</p>

<dl class="domintro">
	<dt>%element . `draggable$m [ = %value ]</dt>
	<dd>
［
要素は~draggableならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element is draggable; otherwise, returns false.
</dd>
	<dd>
設定して既定の値を上書きした上で
`draggable$a 内容~属性を設定できる。
◎
Can be set, to override the default and set the draggable content attribute.
</dd>
</dl>


<dl class="idl-def">
	<dt>`draggable@m</dt>
	<dd>
この~IDL属性は、要素が~draggableになるかどうかを制御する。
その値は、下に述べるように要素の `draggable$a 内容~属性に依存する。
~draggableになるものは，一般には~text選択のみになるが、この~IDL属性が ~T に設定された要素も~draggableになる。
◎
The draggable IDL attribute, whose value depends on the content attribute's in the way described below, controls whether or not the element is draggable. Generally, only text selections are draggable, but elements whose draggable IDL attribute is true become draggable as well.
</dd>

	<dd>
<p>
被取得時には、此れの `draggable$a 内容~属性の状態に応じて，次で与えられる値を返さ~MUST：
</p>

<dl class="switch">
<dt>`~T^st
</dt><dd>~T

</dd><dt>`~F^st
</dt><dd>~F

</dd><dt>`自動^st
</dt><dd>

<p>
［
此れは次のいずれかに該当するならば ~T ／
~ELSE_ ~F
］
</p>

<ul ><li>`img$e 要素である
</li><li>画像を`表現-$する `object$e 要素である
</li><li>`href$a 内容~属性を有する `a$e 要素である
</li></ul>

</dd>
</dl>
◎
If an element's draggable content attribute has the state true, the draggable IDL attribute must return true.
◎
Otherwise, if the element's draggable content attribute has the state false, the draggable IDL attribute must return false.
◎
Otherwise, the element's draggable content attribute has the state auto. If the element is an img element, an object element that represents an image, or an a element with an href content attribute, the draggable IDL attribute must return true; otherwise, the draggable IDL attribute must return false.
</dd>

	<dd>
被設定時には、此れ上の `draggable$a 内容~属性を，所与の値に応じて［
~F ならば `false^l ／
~T ならば `true^l
］に設定し~MUST
◎
If the draggable IDL attribute is set to the value false, the draggable content attribute must be set to the literal value "false". If the draggable IDL attribute is set to the value true, the draggable content attribute must be set to the literal value "true".
</dd>
</dl>

		</section>
		<section id="the-dropzone-attribute">
<h3 title="The dropzone attribute">6.7.8. `dropzone^a 属性</h3>


<p>
`dropzone$a 内容~属性は、すべての`~HTML要素$に設定できる。
指定される値は、`空白区切りの一意な~tokenからなる無順序~集合$で~MUST。
値は`~ASCII大小無視$で比較される。
`~ASCII小文字化$した形による，各~tokenに許容される値は：
◎
All HTML elements may have the dropzone content attribute set. When specified, its value must be an unordered set of unique space-separated tokens that are ASCII case-insensitive. The allowed values are the following:
</p>


<dl>
	<dt>`copy@v</dt>
	<dd>
要素~上に受容される`~item$を~dropしたときの結果は、~dragされていた~dataが 複製されることを指示する。
◎
Indicates that dropping an accepted item on the element will result in a copy of the dragged data.
</dd>

	<dt>`move@v</dt>
	<dd>
要素~上に受容される`~item$を~dropしたときの結果は、~dragされていた~dataが 新たな所在へ移動されることを指示する。
◎
Indicates that dropping an accepted item on the element will result in the dragged data being moved to the new location.
</dd>

	<dt>`link@v</dt>
	<dd>
要素~上に受容される`~item$を~dropしたときの結果は、元の~dataへの~linkになることを指示する。
◎
Indicates that dropping an accepted item on the element will result in a link to the original data.
</dd>
	<dt>
文字列 `string:^l から始まる 8 文字~以上の任意の~keyword
◎
Any keyword with eight characters or more, beginning with an ASCII case-insensitive match for the string "string:"
</dt>
	<dd>
要素は、次を満たす`~item$を受容することを指示する
⇒
［
`種類$dI ~EQ `Plain Unicode string^i
］~AND［
`型~文字列$dI ~EQ ［
~keywordから先頭の 7 文字を除去した結果
］］
◎
Indicates that items with the drag data item kind Plain Unicode string and the drag data item type string set to a value that matches the remainder of the keyword are accepted.
</dd>
	<dt>
文字列 `file:^l から始まる 6 文字~以上の任意の~keyword
◎
Any keyword with six characters or more, beginning with an ASCII case-insensitive match for the string "file:"
</dt>
	<dd>
要素は、次を満たす`~item$を受容することを指示する
⇒
［
`種類$dI ~EQ `File^i
］~AND［
`型~文字列$dI ~EQ ［
~keywordから先頭の 5 文字を除去した結果
］］
◎
Indicates that items with the drag data item kind File and the drag data item type string set to a value that matches the remainder of the keyword are accepted.
</dd>

</dl>

<p>
`dropzone$a 内容~属性の値に、複数の~feedback値（ `copy$v, `move$v, `link$v ）が指定されては~MUST_NOT。
いずれも指定されていない場合、値 `copy$v が含意されることになる。
◎
The dropzone content attribute's values must not have more than one of the three feedback values (copy, move, and link) specified. If none are specified, the copy value is implied.
</p>

<p>
`dropzone$a 内容~属性を有する要素は、視覚的でない対話~用に， `title$a 属性で命名されるべきである。
◎
An element with a dropzone attribute should also have a title attribute that names the element for the purpose of non-visual interactions.
</p>


<div>
<p class="algo-head">
所与の要素は、次の~algoが ~T を返すならば
`~drag-data~store$ %~store に
`~dropzone合致する@
とされる：
</p>

<ol>
	<li>
~IF［
要素は `dropzone$a 属性を有さない
］
⇒
~RET ~F
</li>
	<li>
<p>
~FOR［［［
要素の `dropzone$a 属性の値
］を`~ASCII小文字化$した結果
］を`空白並びで分割-$した結果
］内の~EACH( %~keyword ) に対し，順に：
</p>

		<ol>
			<li>
~IF［
%~keyword は U+003A COLON 文字（ `:^l ）を含まない
］
⇒
~CONTINUE
</li>
			<li>
( %種類~code, %型 ) ~LET %~keyword 内の最初の COLON より
( 前の文字列, 後の文字列 )
</li>
			<li>
~IF［
%型 ~EQ 空~文字列
］~OR［
%種類~code ~NIN { `string^l, `file^l }
］
⇒
~CONTINUE
</li>
			<li>
%種類 ~LET %種類~code に応じて［
`string^l ならば `Plain Unicode string^i ／
`file^l ならば `File^i
］
</li>
			<li>
~IF［
%~store の`~item~list$dS内に［［
`種類$dI ~EQ %種類
］~AND［
`型~文字列$dI ~EQ %型
］］を満たす`~item$がある
⇒
~RET ~T
</li>
		</ol>
	</li>
	<li>
~RET ~F
</li>
</ol>
◎
A dropzone attribute matches a drag data store if the dropzone processing steps result in a match.
◎
↓↓</div>

<div>

<p class="algo-head">
要素が
`指定する~drag演算@
は、次の手続きの結果で与えられる。
</p>

<ol>
	<li>
~IF［
要素は `dropzone$a 属性を有さない
］
⇒
~RET `none$op
</li>
	<li>
~FOR［［［
要素の `dropzone$a 属性の値
］を`~ASCII小文字化$した結果
］を`空白並びで分割-$した結果
］内の~EACH( %~keyword ) に対し，順に
⇒
~IF［
%~keyword ~IN { `copy$v, `move$v, `link$v }
］
⇒
~RET %~keyword と同じ名前の演算
</li>
	<li>
~RET `copy$op
</li>
</ol>

◎
A dropzone attribute specifies an operation if the dropzone processing steps result in a specified operation. The specified operation is as given by those steps.
◎
↓</div>

<div class="p">
<p class="algo-head">
`~dropzone処理~手続き@
は、要素は`~drag-data~store$に`~dropzone合致する$かどうか, および
要素が`指定する~drag演算$を得る手続きを行う。
</p>

<p class="trans-note">【
この訳では、この手続きは利用しない（他からの参照用のみに残す）。
原文によるこの手続きの記述は、上述の 2 つの手続きに分けた上で，
`dropzone$a 属性はでなく，要素を入力にとるように定義し直している。
】</p>

◎
The dropzone processing steps are as follows. They either result in a match or not, and separate from this result either in a specified operation or not, as defined below.

• Let value be the value of the dropzone attribute.
• Let keywords be the result of splitting value on spaces.
• Let matched be false.
• Let operation be unspecified.
• For each value in keywords, if any, in the order that they were found in value, run the following steps.
•• Let keyword be the keyword.
•• If keyword is one of "copy", "move", or "link", then: run the following substeps:
••• If operation is still unspecified, then let operation be the string given by keyword.
••• Skip to the step labeled end of keyword below.
•• If keyword does not contain a U+003A COLON character (:), or if the first such character in keyword is either the first character or the last character in the string, then skip to the step labeled end of keyword below.
•• Let kind code be the substring of keyword from the first character in the string to the last character in the string that is before the first U+003A COLON character (:) in the string, converted to ASCII lowercase.
•• Jump to the appropriate step from the list below, based on the value of kind code:
••• If kind code is the string "string"
•••• Let kind be Plain Unicode string.
••• If kind code is the string "file"
•••• Let kind be File.
•• Otherwise
••• Skip to the step labeled end of keyword below.
•• Let type be the substring of keyword from the first character after the first U+003A COLON character (:) in the string, to the last character in the string, converted to ASCII lowercase.
•• If there exist any items in the drag data store item list whose drag data item kind is the kind given in kind and whose drag data item type string is type, then let matched be true.
•• End of keyword: Go on to the next keyword, if any, or the next step in the overall algorithm, if there are no more.
• The algorithm results in a match if matched is true, and does not otherwise.
• The algorithm results in a specified operation if operation is not unspecified. The specified operation, if one is specified, is the one given by operation.
</div>


<dl class="idl-def">
	<dt>`dropzone@m</dt>
	<dd>
この~IDL属性は、 `dropzone$a 内容~属性を`反映-$し~MUST。
◎
The dropzone IDL attribute must reflect the content attribute of the same name.
</dd>
	<dd>
`被support~token$xは、 `dropzone$a 内容~属性に許容されるものと定義された値のうち，~UAにより~supportされるものである。
◎
The supported tokens for dropzone are the allowed values defined for the dropzone attribute that are supported by the user agent.
</dd>

</dl>


<div class="example">

<p>
次の例の `div$e 要素は、 `dropzone$a 属性を利用して，画像~fileに対する~drop標的にされている。
画像は、標的の中に~dropされたときに表示される。
◎
In this example, a div element is made into a drop target for image files using the dropzone attribute. Images dropped into the target are then displayed.
</p>


<pre>
&lt;div dropzone="copy file:image/png file:image/gif file:image/jpeg" ondrop="receive(event, this)"&gt;
 &lt;p&gt;表示させる画像をここに~dropしてください。&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
 function receive(event, element) {
   var data = event.dataTransfer.items;
   for (var i = 0; i &lt; data.length; i += 1) {
     if ((data[i].kind == 'file') &amp;&amp; (data[i].type.match('^image/'))) {
       var img = new Image();
       img.src = window.createObjectURL(data[i].getAsFile());
       element.appendChild(img);
     }
   }
 }
&lt;/script&gt;
</pre>
<!-- 
Drop an image here to have it displayed.
-->
</div>

		</section>
		<section id="security-risks-in-the-drag-and-drop-model">
<h3 title="Security risks in the drag-and-drop model">6.7.9. ~DnD~modelにおける~security~risk</h3>


<p>
~UAは、 `drop$et ~eventを配送するまで，［
`dragstart$et ~eventの間に `DataTransfer$I ~objに追加された~data
］を~scriptから可用にしては~MUST_NOT
— さもなければ、利用者がある文書から別の文書へ~sensitive情報を~dragしていて，その途上で また別の敵対的な文書を通過するときに、~dataが傍受され得ることになるので。
◎
User agents must not make the data added to the DataTransfer object during the dragstart event available to scripts until the drop event, because otherwise, if a user were to drag sensitive information from one document to a second document, crossing a hostile third document in the process, the hostile document could intercept the data.
</p>


<p>
同じ理由から，~UAは、特に利用者が~drag演算を終わらせた場合に限り，~dropは成功したと見なすことが要求される。
— ~scriptが終わらせたどの~drag演算も，成功しなかった（取消された）ものと見なした上で、 `drop$et ~eventは発火しないことが要求される。
◎
For the same reason, user agents must consider a drop to be successful only if the user specifically ended the drag operation — if any scripts end the drag operation, it must be considered unsuccessful (canceled) and the drop event must not be fired.
</p>


<p>
~UAは、~DnD演算が，~script動作に呼応して開始されないように~~注意を払うべきである。
例えば、~mouseと~windowがある環境の下で，利用者が~mouse~button押下げている間に ~scriptが~windowを移動させた場合、~UAはそれを~dragの開始と見なさないようにすることが重要になる。
さもなければ、利用者の同意なしに，~sensitive~sourceから~dataが~dragされ，敵対的~文書の中へ~dropされかねないので。
◎
User agents should take care to not start drag-and-drop operations in response to script actions. For example, in a mouse-and-window environment, if a script moves a window while the user has their mouse button depressed, the UA would not consider that to start a drag. This is important because otherwise UAs could cause data to be dragged from sensitive sources and dropped into hostile documents without the user's consent.
</p>

<p>
~UAは、~drag／~drop時に、既知の安全な特色機能~listを利用して，（~scriptなどが）作動化され得る内容（例：~HTML）をふるいにかけるべきである。
同様に，`相対~URL$xに対しては、その参照~先が予期されない仕方で変化しないよう，`絶対~URL$xに転化するべきである。
この仕様は、これをどう遂行するかについては指定しない。
◎
User agents should filter potentially active (scripted) content (e.g. HTML) when it is dragged and when it is dropped, using a safelist of known-safe features. Similarly, relative URLs should be turned into absolute URLs to avoid references changing in unexpected ways. This specification does not specify how this is performed.
</p>

<p class="example">
敵対的な頁が、ある内容を提供していて，利用者にその内容を選択させた上で 被害~頁の `contenteditable$a 領域へ ~DnDさせる（または ~~実際に~copy＆~pasteする）ことを考える。
~browserが，安全な内容のみが~dragされることを確保しなかった場合、被害~siteの中に~dropされた（または ~pasteされた）選択~内の~scriptや~event~handlerなど，安全でないかもしれない内容は、被害~siteの特権を取得することになり、 XSS 攻撃を可能化することになる。
◎
Consider a hostile page providing some content and getting the user to select and drag and drop (or indeed, copy and paste) that content to a victim page's contenteditable region. If the browser does not ensure that only safe content is dragged, potentially unsafe content such as scripts and event handlers in the selection, once dropped (or pasted) into the victim site, get the privileges of the victim site. This would thus enable a cross-site scripting attack.
</p>

		</section>
	</section>
</main>


<!--%他の語
~~後続:follow:#1
指す:point
~middle:#1
中間的な:intermediate:~
-:possibilitie
選んだ:pick した
~consisting:#2
convert-to-URL
cell
まったく:particularly
going:#2
~almost:#1
~part:#1
~text編集~program:~word-processor:#1
~become:#1
~due:#1
~miss:#1
~anyway:#2
~caused:#1
~stood:#2
~per:#1
matched
安全~list:safelist
かもしれない／~potentially:#2
~~実際に:~indeed
却下-:reject:~
-:cell
PNG
同じ行の:row:#1
依然として:still
に基づく:based
代わりに:instead
~~下方:lower
~~関係なく:irrespective
~~注意を払う:take care
~~由来する:comes from
~dragされ:dragged
~mouse＆~window:mouse-and-window
6:six
8:eight
いくつかの:several#1
おそらく:probably
	-:regardless#2
この:this#21
これらの:these#5
しかしながら，:however#2
したがって:therefore#1
すでに:already#1
すべての:all#11
その:that#22
そのような:such#3
それら:they#1
それらの:their#1
それらの:those#3
それらを:them#2
一列目 first column
一連の:series of
一部:part of
三つ:three#2
また別の:third#1
上:above#6
下:below#7
与-:give#7
両方とも:both altogether
両者:both#1
二列目 second column
他の:other#12
他の場合:otherwise#10
以前の:previous#5
伝えた:told
何もしては:do nothing
例:example#2
側:side#2
最初に:originally#1
元の:original#3
全体が:entirely
別の:another#2
利用-:use#25
利用者:user#31
則って:according to
前:before#1
加えて:Furthermore
加えて:in-addition#2
取得-:get#1
叩いた:hit
各:each#5
同じ:same#6
含-:include#3
含めて:including#1
場合によっては:possibly#1
始-:begin#2
始まった:began
始まる:beginning
始め:starting
定める:state
容易く:easily
対応ing:corresponding#2
少なくとも:at least
巡回-:cycle through
常に:always#2
序論:introduction#1
後:after#4
得-:obtain#1
とは限らない:necessarily#1
必要-:need#2
戻-:back#1
所与の:given#11
最も深い:deepest:#1
最初の:first#9
最後の:last#3
最早:no longer
最終的に:finally
したい:wish#1
極力努める:make a best-effort attempt:#1
次回:next#1
次第 as soon as
残りの部分:remainder
残りの部分:rest
決して:never#2
渡-:pass#1
特に:specifically:#1
生-:occur#3
示す:show#2
節:section#4
素の:plain#1
終え／終わる:end
末尾:end:#2
終えた:finished
結果:result#17
結果の:resulting#2
置く:put
自身:itself#1
表:table
表され:express
複数の:multiple#1
見える~~範囲:purview
起こる:happen#1
転化-:turn into
近い:near
返す:return#27
長い:long
間:during:#1
~~意味があろうmight make sense

存在:
序論:
文脈依存:Varies
最終的: 2
未知: 1
正規化: 5
-:sequence:~
-:subsequent に
異なる:different:~
-:chain:~

-->