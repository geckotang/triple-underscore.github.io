<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Feature Policy （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style>
pre.http-code {
	background: #EEE;
}

.feature {
	color: gray;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const link_map = this.link_map;
	const class_map = {
		P: 'production', // protocol element
		e: 'element',
		a: 'attr',
		aF: 'attr',
		dir: 'directive',
		ft: 'feature',
		h: 'header',
		U: 'code-point',
	};
	const tag_map = {
		p: 'var',
		P: 'code',
		dir: 'code',
		h: 'code',
		I: 'code',
		m: 'code',
		v: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		ft: 'code',
		aF: 'code',
		s: 'samp',
		U: 'span',
		i: 'i',
	}

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return '<var>' + match.slice(1) + '</var>';
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // 文献
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'l': //literal
	return '"<code class="literal">' + key +'</code>"'
	break;
case 'm' : // interface member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U': // 
	text = 'U+' + key;
	break;
case 'en': // english words
	return '<span lang="en-x-a0">' + key + '</span>'
	break;
}

if(tag) {
	text = '<' + tag +
		(classname ? ' class="' + classname + '">' : '>') +
		text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Feature Policy
spec_date:2018-07-10
trans_update:2018-07-15
page_state_key:WEBAPPSEC
original_url:https://wicg.github.io/feature-policy/
spec_status:EDCG
ref_id_prefix:biblio-
ref_id_lowercase:true
	site_nav:
conformance:w3c
	copyright:2018,wicg
trans_1st_pub:2018-07-15


●●original_id_map


●●link_map

	●IDL
CEReactions:~HEcustom#cereactions
I.HTMLIFrameElement:~HEembed#htmliframeelement
I.PaymentRequest:https://w3c.github.io/payment-request/#dom-paymentrequest

m.getUserMedia:https://w3c.github.io/mediacapture-main/#dom-mediadevices-getusermedia
	m.getUserMedia():~HTMLINFRA#dom-mediadevices-getusermedia
m.requestFullscreen:~FULLSCREEN#dom-element-requestfullscreen
m.allow:~HEembed#dom-iframe-allow
	m.allow:#dom-htmliframeelement-allow

e.iframe:~HEembed#the-iframe-element

a.allow:#iframe-allow-attribute

aF.sandbox:~HEembed#attr-iframe-sandbox
aF.src:~HEembed#attr-iframe-src
aF.allow:~HEembed#attr-iframe-allow
aF.allowfullscreen:~HEembed#attr-iframe-allowfullscreen
	#iframe-allowfullscreen-attribute
aF.allowpaymentrequest:~HEembed#attr-iframe-allowpaymentrequest
	#iframe-allowpaymentrequest-attribute
aF.allowusermedia:~HEembed#attr-iframe-allowusermedia
	#iframe-allowusermedia-attribute

dir.sandbox:~CSP3#sandbox

P.*:#the-special-value
i.全~生成元:#_any-origin
P.serialized-feature-policy:#serialized-feature-policy
P.serialized-policy-directive:#serialized-policy-directive
直列形の特色機能~施策:#serialized-policy-directive
P.feature-identifier:#feature-identifier
P.allow-list:#allow-list
P.allow-list-value:#allow-list-value
P.serialized-origin:#serialized-origin

h.Feature-Policy:#feature-policy-header

	●用語


特色機能~施策を初期化する:#initialize-for-document
応答からの特色機能~施策で文書のそれを初期化する:#initialize-from-response
	~allow属性を構文解析する:#parse-allow-attribute
指令を宣言-済み施策に併合する:#merge-directive-with-declared-policy
値と生成元から~headerを構文解析する:#parse-header
値と生成元から施策~指令を構文解析する:#parse-policy-directive
特色機能~施策~属性を処理する:#process-feature-policy-attributes
応答~施策を処理する:#process-response-policy
pd.~ASCII直列化:#ascii-serialization
継承される施策を特色機能~用に定義する:#define-inherited-policy

利用は許容される:~HEembed#allowed-to-use
	利用は許容される:#allowed-to-use
許容list:#allowlist
	§許容-属性:#iframe-allow-attribute
容器~施策:#container-policy
宣言された特色機能~施策:#declared-policy
宣言-済み施策:#declared-policy
既定の許容list:#default-allowlist

空の特色機能~施策:#empty-feature-policy
特色機能は施策により生成元~用に可能化されるか？:#is-feature-enabled

施行する:#enforce
施行-:#enforce
許容listは生成元に合致する:#matches

特色機能:#policy-controlled-feature
特色機能~施策:#feature-policy
~header施策:#header-policy
継承される施策:#inherited-policy
継承した施策:#inherited-policy
特色機能~用に継承される施策:#inherited-policy-for-a-feature

施策により制御される特色機能:#policy-controlled-feature
特色機能:#policy-controlled-feature
施策~指令:#policy-directive
~support済み特色機能:#supported-features

	●外部
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
~commaで分割する:~INFRA#split-on-commas
区切子で厳密に分割する:~INFRA#strictly-split
有順序~集合:~INFRA#ordered-set
有順序~map:~INFRA#ordered-map
構造体:~INFRA#struct

doc.特色機能~施策:~HTMLdom#concept-document-feature-policy

文書:~HTMLdom#the-document-object
	文書:~DOM4#concept-document

作動中の文書:~BROWSERS#active-document
入子の閲覧文脈:~BROWSERS#nested-browsing-context
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
閲覧文脈~容器:~BROWSERS#browsing-context-container
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
属する文書:~BROWSERS#concept-document-bc
親~閲覧文脈:~BROWSERS#parent-browsing-context
新たな閲覧文脈を作成する:~BROWSERS#creating-a-new-browsing-context

文書を初期化する:~NAVI#initialise-the-document-object

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元の直列化:~ORIGIN#ascii-serialisation-of-an-origin
同じ生成元~domain:~ORIGIN#same-origin-domain

応答:~FETCH#concept-response
	応答:~FETCH#concept-response-response＊原文誤

~URL構文解析する:~URL1#concept-url-parser
url.生成元:~URL1#concept-url-origin

rs.~header~list:~FETCH#concept-response-header-list
名前に持つ~header:~FETCH#_headers-of-name
hd.値:~FETCH#concept-header-value
hd.結合-済みの値:~FETCH#concept-header-value-combined

●●words_table1


●●words_table

	●施策／feature
特色機能:feature::~::フィーチャ
	特色機能~名:feature-name:~
	~support済み特色機能:recognized feature 
許容-:allow::~
	許容されない:disallow:~
許容list:allowlist::許容 list:許容リスト
指令:directive::~::ディレクティブ
提出-:submit::~
施策:policy::~:ポリシー
	施策により制御される:policy-controlled
施行-:enforce::~

camera::::カメラ
microphone::::マイクロフォン
script::::スクリプト
form::::フォーム

Vibration:
Geolocation:

	地理情報／^en:geolocation

	●環境
Worker:
Worklet:
frame::::フレーム
下位frame:subframe::下位 frame:下位フレーム
	~frame化され:framed
	`iframe^e:iframe
top-level::::トップレベル
入子の:nested:入れ子の
入子に:nest:入れ子に
内容:content::~
埋込む:embed する::埋め込む
埋込んで:embed して::埋め込んで
埋込んだ:embed した::埋め込んだ
埋込まれ:embed され::~
	自身が埋込む〜~host:embedee
	埋込んだ側／埋込む側:embedder
容器:container:::コンテナ
文書:document::~
閲覧文脈:browsing context::~
	閲覧:browsing::~
文脈:context::~
継承-:inherit::~
資源:resource::~
読込まれ:load され::~
要素:element::~
親:parent::~
子:child::~
木:tree::~::ツリー
作動中の:active な::~::アクティブな
非同一生成元:cross-origin::~::クロスオリジン
同一生成元:same-origin::~::同一オリジン
生成元:origin::~::オリジン
第三者主体:third-party::~
可能化-:enable::~
	`可能化される^i:"Enabled"
不能化-:disable::~
	`不能化される^i:"Disabled"
	不能化-:off
不透明:opaque::~

頁:page:::ページ
site::::サイト
検索engine:search engine:::検索エンジン
plugin::::プラグイン
social-network:social network:::ソーシャルネットワーク


	●network
client::::クライアント
domain::::ドメイン
header::::ヘッダ
host::::ホスト
message::::メッセージ
server::::サーバ
serve::::サービス供与
social::::ソーシャル
送達-:deliver::~
送達:delivery::~
通信-:communicate::~
受信-:receive::~
応答:response::~::レスポンス
protocol::::プロトコル
redirect::::リダイレクト

	●保安
privacy::::プライバシー
risk::::リスク
sandbox::::サンドボックス
	~sandbox法:sandboxing
security::::セキュリティ
access::::アクセス
予防策:precaution::~
注入-:inject::~
	監禁:lock down
抽出-:extract::~
検出:detection::~
検分-:examine::~
検査:check::~
安全:safe::~
懸念:concern::~
推定-:infer::~
攻撃者:attacker::~
是認-:grant::~
特権:privilege::~
脆弱:vulnerable::~
許可:permission::~
軽減-:mitigate::~
迂回-:bypass::~
違反:violation::~
log-in:log in:::ログイン
強制-:force::~
	強制-法:forcing
予想外の:unanticipated:~
不自然な:contrived:~
予期-:expect:~
	予期することなく書かれた:not written with the expectation
公表-:publish::~
公開-:expose::~
公開:exposure::~
明示-:express:~
信用-:trust::~
	信用できない:potentially untrusted
care::::ケア

	~~影響は抑えられる:increase the chance that
	悪化させ:make worse
	無用に:needlessly
	最も重大な:biggest
	長期に存在していた:existing, long-standing


	●データ／構文
ASCII:
item::::アイテム
list::::リスト
map::::マップ
key::::キー
comma::::カンマ
keyword::::キーワード
percent-::: %-
token::::トークン
error::::エラー
大小無視:case-insensitive::~
小文字:lowercase::~
空白:whitespace::~
宣言-:declare::~
宣言:declaration::~
空:empty::~
符号位置:code point::~
符号化-:encode::~::エンコード
直列化-:serialize::~::シリアル化
直列形の:serialized::~::シリアル形の
直列化:serialization::~::シリアル化
	直列化された宣言:serialized-declaration
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構造体:struct::~
有順序:ordered::~
属性:attribute::~
初期:initial::~
初期化-:initialize::~
文字:character::~
文字列:string::~
	文字列:character strings
失敗:failure::~
失敗-:fail::~
区切子:delimiter::~
分割-:split::~
厳密:strict::~
形成-:form:~
名:name:~
名前:name:~
値:value:~
入力:input::~
条件:condition:~
格納-:store::~
改変-:modify::~
拡充-:populate::~
構築-:construct::~
設定-:set::~
除去-:remove::~
付加-:append::~
作成-:create::~
置換-:replace::~
表現-:represent::~
表現:representation::~
識別-:identify::~
併合-:merge::~
結合-:combine::~
追加-:add:~
包含-:contain:~
	初期化-:initialise:~
集合:set::~
対応付ける:map する:~

	-:separated
	-:concatenation

	●仕様
API:
UA:user agent:UA
app:application:::アプリ
browser::::ブラウザ
custom::::カスタム
	~custom化:customize
framework::::フレームワーク
platform::::プラットフォーム
algo:algorithm:::アルゴリズム
web:

一貫して:consistentに:~
不可能:impossible:~
事例:case:~
互換性:compatibility:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
処理能:performance:~
効果:effect:~
単純:simple:~
	単純に:simply:~

供-:provide:~
保守-:maintain:~
処理-:process:~
利用者:user:~
	利用-:use:~
制御:control:~
制約:restriction:~
制約的:restrictive:~
制限:limitation:~
制限-:limit:~
動作-:act:~
取組む:address する:取り組む
受持って:cover して:~

可用:available:~
可能性:possibility:~
困難:hard:~
多彩:rich:~
	より多彩な:richer
多義性:ambiguity:~
姉妹:companion:~
将来:future:~
情報:information:~
手続き:steps:~
旧来の:legacy な:~
明確さ:clarity:~
明示的:explicit:~
最適化:optimization:~
有意:significant:~
概念的:conceptual:~
機能性:functionality:~
特定の:specific な:~
特別:special:~
用語:term:~
直に:direct に:~
能:ability:~
能力:capability:~
自動的:automatic:~
要件:requirements:~
	要約:abstract:~
規範的:normative:~
	規範的でない:non-normative
間接的:indirect:~
アリ:possible:可能
局面:scenario:~
標準:standard:~
	標準~化-:standardize:~
一般:general:~
正しく:correct に:~
課題:issue:~
適切:appropriate:~
手引き:guidance:~
任意選択で:optional に:~
	任意選択で元に戻す:opt back in
	種類:kind:~

	使い勝手:ergonomics:~
	関わらず:regardless
	欠如:lack of thereof
	現時点では:currently
	べき:should
	しかしながら，:however
	この仕様:Feature~Policy
	ために:in order to
	絶えず発展し続ける:ever-expanding
	これまで無かった:missing piece
	より良い:better:#1
	任意選択で外す:opt-out
	例:example
	例えば:for example
	因り:due
	多い:often
	簡潔にするため:for brevity
	そのようなわけで:As such
	ある程度:to a degree
	に足る:sufficient
	注意:note that
	具体例として:for instance
	少なくとも:at least
	仮に，ある:hypothetical

	●仕様（動詞
support::::サポート
	support済み:supported
定義-:define:~
	定義し直す:redefine:~
	〜で定義されている:〜-defined
実装-:implement:~
導入-:introduce:~
序論:introduction:~
意図-:intend:~
抑制-:reduce:~
拡張-:extend:~
	拡張-可能:extensible:~
指定-:specify:~
指示-:indicate:~
挙動:behavior:~
挙動:behaviour:~
提供-:offer:~
改善-:improve:~
改訂:revision:~
期待-:expect:~
	期待されない:unexpected
求める:want する:~
求めら:want さ:~
求めて:want して:~
	求められない:unwanted
決定-:determine:~
波及-:influence:~
約束:promise:~
統合-:integrate:~
統合:integration:~
考慮点:considerations:~
考える:consider する:~
見なさ:consider さ:~
要旨-:outline:~
要求-:require:~
解釈-:interpret:~
言明-:assert:~
詳細な:detailed:~
述べる:describe する:~
適合性:conformance:~
適用-:apply:~
選択的:selective:~
避ける:avoid する:~
開発者:developer:~
関係-:relate:~
防止-:prevent:~
組合せて:combine して:~
策定者:author:~
裁定-:decide:~
設計:design:~
試みた:attempt した:~
試みる:attempt する:~
制限-:limit:~
依存-:depend:~
取扱う:handle する:取り扱う
取扱って:handle して:取り扱って
意味-:mean:~
実用的:practical:~
依頼-:ask:~
参照-:reference::~
	指す／~~参照:refer
	詳細はそれらを参照すること。:references which ought to be consulted for detailed information
認識-:recognize:~
前提:assumption:~
	重複-:duplicate

	この仕様:Feature Policy
	もたらす／:caused
	用立てる make use
	知り:learn
	組合せて:in combination with
	見よ:see
	課す:impose
	略称され:referred to 〜 simply as 
	織り込む:account
	〜に基づく:based
	対処:deals with
	可能性も含みにする言い回しを見つける:figure out how to word this to include the possibility of
	に加えて:in addition to
	他が指示されない限り:unless otherwise indicated
	現時点で定義されている:currently-defined
	追加の:additional:~

	●未分類（動詞
call:
合致-:match::~
在する:present する:在る
実行-:execute::~
更新-:update::~
走らす:run する:~
	返す:return
登録:registration::~
移譲-:delegate::~
観測-:observe::~
	観測-可能:observable
発火-:fire::~
event::::イベント
listen::::リッスン
投出-:throw::~
存在-:exist:~
変更-:change:~
変化:changes:~
継続-:continue:~
	含-:include
	含めて:including
	対応-:correspond
	-:expand
	現れ:appear
	除-:except:~

	●未分類
mode::::モード
Geolocation:
HTML:
HTTP:
IANA:
URL:
W3C:
CSP:
FastCorp:
SecureCorp:

interface::::インタフェース
node::::ノード
obj:object:::オブジェクト
registry::::レジストリ
target:
	~target~list:targetlist

text::::テキスト
外部:external::~
既定の:default::~::デフォルト
既定:default::~::デフォルト
状態:state:~
段:step:~
恒久的:permanent:~
例外:exception::~
同期的:synchronous:~
既知:known:~

	を有するならば:presence
	対象:subject
	-:documented
	-:property
	類似する／同様に:similar
	節:section
	DOMString
	~web~platform:web-platform
	^en:fast path
	~RET:abort these steps
	^r:Fullscreen
	^I:XMLHttpRequest
	社:Inc.

	●指示語
全部的:full:~
新たな:new:~
既存の:existing:~
自前の:own:~
特定0の:particular:ある特定の
	あらゆる:every
	一定の／ある種の:certain
	ある種の:certain type:~
	いくつかの:several
	および:as well as
	ここ:here
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	その他:others
	それら:they
	それらの:their
	それらの:those
	それらを:them
	それら自身:themselves
	にわたって:across
	も:as well
	一連の／の集合:set of
	上:above
	介:via
	他の:other
	他の場合:otherwise
	他方:the other
	以上の~or~more
	各:each
	同じ:same
	常に:always
	後:after
	所与の:given
	様々な:various
	次の:the-following
	異なる:different
	等々:and so on
	結果:result
	結果の:resulting
	通:through
	長い方の:longer
	間:during
	同様に:similarly
	個別に:individual:~
	両者:both:~
	何か:something
	個々の:individual
	前:before
	別の:another
	個の:one／:two
	別に:alongside
	nor
	thereof
	類の:sort of
	一部:part of／:some of


●●ref_normative

[CSP-3]
    Content Security Policy Level 3 URL: https://www.w3.org/TR/CSP3/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[FULLSCREEN]
    Philip Jägenstedt. Fullscreen API Standard. Living Standard. URL: https://fullscreen.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC3864]
    G. Klyne; M. Nottingham; J. Mogul. Registration Procedures for Message Header Fields. September 2004. Best Current Practice. URL: https://tools.ietf.org/html/rfc3864 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSP2]
    Mike West; Adam Barth; Daniel Veditz. Content Security Policy Level 2. 15 December 2016. REC. URL: https://www.w3.org/TR/CSP2/ 
[HTML5]
    Ian Hickson; et al. HTML5. 27 March 2018. REC. URL: https://www.w3.org/TR/html5/ 


●●trans_metadata
<p>
~THIS_PAGEは、
Web Platform Incubator Community Group
により
Draft Community Group Report として公開された
<a href="~SPEC_URL">Feature Policy</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

このバージョン
	https://wicg.github.io/feature-policy/

最新の課題
	<a href="https://github.com/wicg/feature-policy/issues/">GitHub</a>

編集
	<a href="mailto:iclelland@google.com">Ian Clelland</a> (Google)

commit 履歴
	https://github.com/WICG/feature-policy/commits/master

</script>

</head><body>

<header>
	<hgroup>
<h1 id="title">特色機能施策 — Feature Policy</h1>
	</hgroup>

<details><summary>©</summary><small class="copyright" lang="en-x-a0">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2018 the Contributors to the Feature Policy Specification, published by the <a href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a> under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>.
A human-readable <a href="http://www.w3.org/community/about/agreements/cla-deed/">summary</a> is available.
</small></details>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、~browserに備わる様々な［
特色機能や~API
］の利用を選択的に［
可能化する／不能化する
］ことを，開発者に許容する仕組みを定義する。
◎
This specification defines a mechanism that allows developers to selectively enable and disable use of various browser features and APIs.
</p>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p lang="en-x-a0">
This specification was published by the <a href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a>.
It is not a W3C Standard nor is it on the W3C Standards Track.
Please note that under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a> there is a limited opt-out and other conditions apply.
Learn more about <a href="http://www.w3.org/community/">W3C Community and Business Groups</a>.
</p>

	</section>

<main id="MAIN0">

	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoの記述に利用されている各種記号（ε, 此れ, ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
一部の箇所では、既存の用語を利用して記述を簡約している。
</p>

	</section>

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>


<p>
~web~platformは、絶えず発展し続ける一連の［
特色機能や~API
］を供して，より［
多彩な機能性, 開発者にとって使い勝手の良さ, 改善された処理能
］を提供する。
しかしながら、開発者が，~browserに備わるこれらの［
特色機能や~API
］のうち一部の挙動を 自身の~appの中で選択的に［
可能化- ／ 不能化- ／ 改変-
］する能は、これまで無かった：
◎
The web-platform provides an ever-expanding set of features and APIs, offering richer functionality, better developer ergonomics, and improved performance. However, a missing piece is the ability for the developer to selectively enable, disable, or modify the behavior of some of these browser features and APIs within their application:
</p>

<ol>
	<li>
開発者は、~browserに備わる ある種の［
特色機能や~API
］への~accessを 選択的に<em>不能化-</em>したいと求めることもある
— ~securityや処理能のための予防策として，［
自前の, あるいは第三者主体の
］内容が，自身の~appの中で実行されるのを防止して、［
求められない／期待されない
］挙動を導入しないように，自身の~appを “監禁する” ために。
◎
The developer may want to selectively disable access to certain browser features and APIs to "lock down" their application, as a security or performance precaution, to prevent own and third-party content executing within their application from introducing unwanted or unexpected behaviors within their application.
</li>
	<li>
開発者は、［
既定では不能化され得るような，~browserに備わる ある種の［
特色機能や~API
］］への~accessを，選択的に<em>可能化-</em>したいと求めることもある
— 例：一部の特色機能は、［
埋込まれた文脈においては，明示的に可能化されない限り 既定で不能化されたり、他の施策~要件の対象になる
］こともある。
◎
The developer may want to selectively enable access to certain browser features and APIs which may be disabled by default - e.g. some features may be disabled by default in embedded context unless explicitly enabled; some features may be subject to other policy requirements.
</li>
	<li>
<p>
開発者は、［
ある種の［
特色機能や~API
］の利用
— または その欠如 —
について，自身の~app［
の~client／を埋込む側
］に約束する
］ことを言明する施策を利用したいと求めることもある。
例えば：
</p>
		<ul>
			<li>
~browserにおいて ある種の “`fast path^en”† 最適化を可能化するため。
【†よくある事例~用の “優先路”（短期滞在者用の入出国手続きのような）】
</li>
			<li>
埋込む側
— 例：様々な~social-network, 検索engine, 等々 —
が設定した一部の要件に対する適合性についての約束を言明するため。
</li>
		</ul>
◎
The developer may want to use the policy to assert a promise to a client or an embedder about the use—or lack of thereof—of certain features and APIs. For example, to enable certain types of "fast path" optimizations in the browser, or to assert a promise about conformance with some requirements set by other embedders - e.g. various social networks, search engines, and so on.
</li>
</ol>

<p>
この仕様は、上の利用~事例に取組む特色機能~施策の仕組みを定義する。
◎
This specification defines a feature policy mechanism that addresses the above use cases.
</p>


	</section>
	<section id="examples">
<h2 title="Examples">2. 例</h2>

<div class="example">

<p>
~SecureCorp社は、自身の~appの中では［
~Vibration／~Geolocation
］~APIの利用を不能化したいと求めているとする。
次のような特色機能~施策を定義する~HTTP応答~headerを送達すれば、それを行える：
◎
SecureCorp Inc. wants to disable use of Vibration and Geolocation APIs within their application. It can do so by delivering the following HTTP response header to define a feature policy:
</p>


<pre class="http-code">
`Feature-Policy$h: vibrate 'none'; geolocation 'none'
</pre>

<p>
生成元~list用の~keyword `'none'^l を指定することにより、指定された特色機能は
— どの閲覧文脈においても，その生成元に関わらず —
不能化されることになる。
◎
By specifying the "'none'"keyword for the origin list, the specified features will be disabled for all browsing contexts, regardless of their origin.
</p>

</div>

<div class="example">

<p>
~SecureCorp社は、［
自前の生成元／ 生成元 `https://example.com^l 
］用を除くどの閲覧文脈の中でも~Geolocation~APIの利用を不能化したいと求めているとする。
次のような特色機能~施策を定義する~HTTP応答~headerを送達すれば、それを行える：
◎
SecureCorp Inc. wants to disable use of Geolocation API within all browsing contexts except for its own origin and those whose origin is "https://example.com". It can do so by delivering the following HTTP response header to define a feature policy:
</p>


<pre class="http-code">
`Feature-Policy$h: geolocation 'self' https://example.com
</pre>

<p>
`許容list$は、 1 個~以上の生成元からなる~listである
— その各~生成元には、次のいずれかを与えれる
⇒＃
任意選択で ~keyword `'self'^l を伴う，~appの生成元 ／
任意の第三者主体~生成元
◎
The allowlist is a list of one or more origins, which can include the application’s origin, optionally with the keyword "'self'", and any third-party origin.
</p>
</div>

<div class="example">

<p>
~SecureCorp社は、
`https://example.com^l にて ある~appを~hostしていて，自前の生成元~上では［
~camera／~microphone
］入力を不能化したいが，自身が埋込む特定の~host（ `https://other.com^l ）用には可能化したいと求めているとする。
次のような特色機能~施策を定義する~HTTP応答~headerを送達すれば、それを行える：
◎
SecureCorp Inc. is hosting an application on "https://example.com" and wants to disable camera and microphone input on its own origin but enable it for a specific embedee ("https://other.com"). It can do so by delivering the following HTTP response header to define a feature policy:
</p>


<pre class="http-code">
`Feature-Policy$h: camera https://other.com; microphone https://other.com
</pre>

<p>
一部の特色機能は、埋込まれた文脈~内では既定で不能化される。
施策は、そのような特色機能を，指定された生成元~用に選択的に可能化することを，~appに許容する。
◎
Some features are disabled by default in embedded contexts. The policy allows the application to selectively enable such features for specified origins.
</p>

</div>

<div class="example">

<p>
~FastCorp社は、特定の `iframe^e 用を除く，すべての非同一生成元の子~frame用には，地理情報（ `geolocation^en ）を不能化したいと求めているとする。
次のような特色機能~施策を定義する~HTTP応答~header：
◎
FastCorp Inc. wants to disable geolocation for all cross-origin child frames, except for a specific iframe. It can do so by delivering the following HTTP response header to define a feature policy:
</p>


<pre class="http-code">
`Feature-Policy$h: geolocation 'self'
</pre>

<p>
を送達した上で，
`iframe^e 要素に `allow^a 属性を含めることで，それを行える：
◎
and including an "allow" attribute on the iframe element:
</p>


<pre class="http-code">
&lt;iframe src="https://other.com/map" <a href="#iframe-allow-attribute">allow</a>="geolocation"&gt;&lt;/iframe&gt;
</pre>


<p>
各種 `iframe^e 用の属性は、一定の~frame内に限り，選択的に特色機能を可能化できる
— 他では，同じ生成元からの文書を包含する場合でも可能化しないように。
◎
Iframe attributes can selectively enable features in certain frames, and not in others, even if those contain documents from the same origin.
</p>

</div>


	</section>
	<section id="other-and-related-mechanisms">
<h2 title="Other and related mechanisms">3. 他の／関係する仕組み</h2>

<p>
`HTML5$r が `iframe$e 要素~用に定義する `sandbox$aF 属性は、［
内容の能に制約を課すことにより，信用できない内容が含まれることによる~riskを抑制する
］ことを，開発者に許容する
— 例：［
~formを提出する／~scriptや~pluginを走らす／その他
］を防止するなど。
`CSP2$r が定義する `sandbox$dir 指令は、同じ一連の制約を依頼するために，この能力を どの資源にも
— ~frame化されるかどうかを問わず —
拡張する
— 例： ~HTTP応答~headerを介することにより（ `Content-Security-Policy: sandbox^l ）。
これらの仕組みは、開発者に次を可能化する：
◎
[HTML5] defines a sandbox attribute for iframe elements that allows developers to reduce the risk of including potentially untrusted content by imposing restrictions on content’s abilities - e.g. prevent it from submitting forms, running scripts and plugins, and more. The sandbox directive defined by [CSP2] extends this capability to any resource, framed or not, to ask for the same set of restrictions - e.g. via an HTTP response header (Content-Security-Policy: sandbox). These mechanisms enable the developer to:
</p>

<ul>
	<li>
どの資源に対しても，~CSPを介して~sandbox施策を［
設定する／~custom化する
］。
◎
Set and customize a sandbox policy on any resource via CSP.
</li>
	<li>
自身の~appの中の各 `iframe^e 要素に対し，個別に~sandbox施策を［
設定する／ ~custom化する
］。
◎
Set and customize individual sandbox policies on each iframe element within their application.
</li>
</ul>


<p>
しかしながら，上の仕組みには、いくつかの制限がある：
◎
However, there are several limitations to the above mechanism:＼
</p>
<ul>
	<li>
開発者は、すべての文脈にわたって施策を自動的には適用できないため、一部の事例では，一貫して施行することが困難または不可能である（例：第三者主体からの内容が，開発者が制御しない~frameを注入することに因るものなど）
◎
the developer cannot automatically apply a policy across all contexts, which makes it hard or impossible to enforce consistently in some cases (e.g. due to third-party content injecting frames, which the developer does not control);＼
</li>
	<li>
既定では不能化され得るような特色機能を，選択的に可能化する仕組みが無い
◎
there is no mechanism to selectively enable features that may be off by default;＼
</li>
	<li>
~sandboxの仕組みは、すべての~sandbox特色機能を自動的に不能化して，そのそれぞれを任意選択で元に戻すことを，開発者に要求するので、有意な互換性~riskなしに一連の~sandbox特色機能を拡張することは不可能である。
◎
the sandbox mechanism automatically disables all sandbox features, and requires the developer to opt back in to each of them, so it is impossible to extend the set of sandbox features without significant compatibility risk.
</li>
</ul>

<p>
特色機能~施策は、~sandboxの仕組みと組合せて利用することが意図されており（すなわち、すでに~sandboxが受持っている特色機能~制御とは重複しない），上の制限に取組む拡張-可能な仕組みを供する。
◎
Feature Policy is intended to be used in combination with the sandbox mechanism (i.e. it does not duplicate feature controls already covered by sandbox), and provides an extensible mechanism that addresses the above limitations.
</p>


	</section>
	<section id="framwork">
<h2 title="Framework">4. ~framework</h2>

		<section id="features">
<h3 title="Policy-controlled Features">4.1. 施策により制御される特色機能</h3>


<p>
`施策により制御される特色機能@
は、`特色機能~施策$を~~参照することにより，文書において［
可能化-／不能化-
］できる［
~APIや挙動
］である。
◎
A policy-controlled feature is an API or behaviour which can be enabled or disabled in a document by referring to it in a feature policy.
</p>


<p class="note">注記：
簡潔にするため，この文書においては、施策により制御される特色機能は “特色機能” と略称されることが多い。
他が指示されない限り，用語 “特色機能” は`施策により制御される特色機能$を指す。
そのような特色機能を定義する他の仕様は、多義性を避けるため，長い方の用語を利用するべきである。
◎
For brevity, policy-controlled features will often be referred to in this document simply as "Features". Unless otherwise indicated, the term "feature" refers to policy-controlled features. Other specifications, defining such features, should use the longer term to avoid any ambiguity.
</p>


<p class="issue">
この仕様は、現時点では，文書~内に定義される特色機能しか対処していない。
これについて，~Workerや~Worklet内の［
特色機能／特色機能~施策
］の可能性も含みにする言い回しを見つけるべきである。
◎
This spec currently only deals with features defined in Documents. We should figure out how to word this to include the possibility of features and feature policies in Workers and Worklets as well.
</p>


<p>
`施策により制御される特色機能$は、［
`施策~指令$内で利用される，文字列による~token
］により識別される。
◎
Policy-controlled features are identified by tokens, which are character strings used in policy directives.
</p>

<p>
各 `特色機能$には、`既定の許容list$がある
— それは、次の 2 つを定義する
⇒＃
その特色機能は `~top-level閲覧文脈$に`属する文書$内で可用かどうか／
その特色機能への~accessは `入子の閲覧文脈$にはどう継承されるか
◎
Each policy-controlled feature has a default allowlist, which defines whether that feature is available in documents in top-level browsing contexts, and how access to that feature is inherited in nested browsing contexts.
</p>

<p>
`特色機能$のうち，~UAが施策を通して制御することを許容するものは、
`~support済み特色機能@
と呼ばれる。
~UAには、あらゆる`特色機能$を~supportすることは要求されない。
◎
A user agent has a set of supported features, which is the set of features which it allows to be controlled through policies. User agents are not required to support every feature.
</p>


<p class="note">注記：
`施策により制御される特色機能$自体は、この~frameworkの一部を成すものではない。
現時点で定義されている規範的でない特色機能の~listは、この仕様とは別に，
<a href="https://github.com/WICG/feature-policy/blob/master/features.md">姉妹~文書</a>
にて保守されている。
◎
The policy-controlled features themselves are not themselves part of this framework. A non-normative list of currently-defined features is maintained as a companion document alongside this specification.
</p>

		</section>
		<section id="policies">
<h3 title="Policies">4.2. 施策</h3>

<p>
`特色機能~施策@
は、次の~itemからなる`構造体$である
⇒＃
`継承した施策$,
`宣言-済み施策$
◎
A feature policy is a struct with the following items:
• An inherited policy.
• A declared policy.
</p>

<div class="p">
<p>
`空の特色機能~施策@
は、次をいずれも満たす`特色機能~施策$である：
</p>

<ul>
	<li>
どの`~support済み特色機能$ %特色機能 に対しても
⇒
`継承した施策$[ %特色機能 ] ~EQ `可能化される^i
</li>
	<li>
`宣言-済み施策$は空~mapである
</li>
</ul>

◎
An empty feature policy is a feature policy that has an inherited policy which contains "Enabled" for every supported feature, and a declared policy which is an empty map.
</div>


		</section>
		<section id="inherited-policies">
<h3 title="Inherited policies">4.3. 継承した施策</h3>

<p>
`継承した施策@
は、各 `特色機能$を［
`可能化される^i ／ `不能化される^i
］に対応付ける`有順序~map$である。
◎
An inherited policy is an ordered map from features to either "Enabled" or "Disabled".
</p>


<p>
`特色機能~用に継承される施策@
は、所与の %特色機能 に対し，`継承した施策$[ %特色機能 ] で与えられる。
`特色機能~施策$が初期化された後には、それが`継承した施策$は，各`~support済み特色機能$用に何らかの値を包含することになる。
◎
The inherited policy for a feature feature is the value in the inherited policy whose key is feature. After a feature policy has been initialized, its inherited policy will contain a value for each supported feature.
</p>

<div class="note" role="note">
<p>注記：
~frame木を成す各 文書は、一連の施策を継承する
— ［
~top-level文書は 各`特色機能$用に定義される既定のものから ／
他の文書は その親~frameから
］。
この継承した施策は、次を決定する
⇒＃
各~特色機能の初期~状態（ `可能化される^i ／ `不能化される^i ） ／
文書~内で`宣言-済み施策$により制御できるかどうか。
◎
Each document in a frame tree inherits a set of policies from its parent frame, or in the case of the top-level document, from the defined defaults for each policy-controlled feature. This inherited policy determines the initial state ("Enabled" or "Disabled") of each feature, and whether it can be controlled by a declared policy in the document.
</p>

<p>
`~top-level閲覧文脈$に`属する文書$に継承される施策は、各~特色機能~用に定義される既定の施策に基づく。
◎
In a Document in a top-level browsing context, the inherited policy is based on defined defaults for each feature.
</p>

<p>
`入子の閲覧文脈$に`属する文書$に継承される施策は、［
親~文書の特色機能~施策, および`入子の閲覧文脈$の`容器~施策$
］に基づく。
◎
In a Document in a nested browsing context, the inherited policy is based on the parent document’s feature policy, as well as the nested browsing context's container policy.
</p>

</div>


		</section>
		<section id="declared-policies">
<h3 title="Declared policies">4.4. 宣言-済み施策</h3>

<p>
`宣言-済み施策@
は、各 `特色機能$を ある`許容list$に対応付ける`有順序~map$である。
◎
A declared policy is an ordered map from features to allowlists.
</p>

		</section>
		<section id="header-policies">
<h3 title="Header policies">4.5. ~header施策</h3>


<p>
`~header施策@
は、文書に伴う~HTTP~headerを介して送達された`施策~指令$からなる~listである。
これは、文書の`特色機能~施策$の`宣言-済み施策$を形成する。
◎
A header policy is a list of policy directives delivered via an HTTP header with a document. This forms the document’s feature policy’s declared policy.
</p>

		</section>
		<section id="container-policies">
<h3 title="Container policies">4.6. 容器~施策</h3>

<p>
各`入子の閲覧文脈$は、`~header施策$に加えて，
`容器~施策@
を持つ。
それは、`施策~指令$であり，空にもなり得る。
`容器~施策$は、`閲覧文脈~容器$上の属性により設定できる。
◎
In addition to the header policy, each nested browsing context has a container policy, which is a policy directive, which may be empty. The container policy can set by attributes on the browsing context container.
</p>

<p>
`入子の閲覧文脈$用の`容器~施策$は、その文脈の中に読込まれた文書に`継承される施策$に波及する（`継承される施策を特色機能~用に定義する$を見よ）。
◎
The container policy for a nested browsing context influences the inherited policy of any document loaded into that context. (See §8.9 Define an inherited policy for feature)
</p>

<p class="note">注記：
現時点では，`容器~施策$は直には設定できないが、
`iframe^l の
<a href="#iframe-allowfullscreen-attribute">`allowfullscreen^a</a>,
<a href="#iframe-allowpaymentrequest-attribute">`allowpaymentrequest^a</a>,
<a href="#iframe-allowusermedia-attribute">`allowusermedia^a</a>,
<a href="#iframe-allow-attribute">`allow^a</a>
属性により，間接的に設定される。
この仕様の将来の改訂は、全部的な`容器~施策$を明示的に宣言する仕組みを導入し得る~MAY。
◎
Currently, the container policy cannot be set directly, but is indirectly set by iframe "allowfullscreen", "allowpaymentrequest", "allowusermedia", and "allow" attributes. Future revisions to this spec may introduce a mechanism to explicitly declare the full container policy.
</p>


		</section>
		<section id="policy-directives">
<h3 title="Policy directives">4.7. 施策~指令</h3>

<p>
`施策~指令@
は、各 `特色機能$を ある`許容list$に対応付ける`有順序~map$である。
◎
A policy directive is an ordered map, mapping policy-controlled features to corresponding allowlists of origins.
</p>


<p>
`施策~指令$は、［
~HTTP~header／~HTML属性
］内では，`~ASCII直列化$pdとして表現される。
◎
A policy directive is represented in HTTP headers and HTML attributes as its ASCII serialization.
</p>

		</section>
		<section id="allowlists">
<h3 title="Allowlists">4.8. 許容list</h3>

<p>
特色機能~施策
`許容list@
は、概念的には，いくつかの`生成元$からなる集合である。
`許容list$は、次のいずれかをとり得る：
◎
A feature policy allowlist is conceptually a set of origins. An allowlist may be either:
</p>

<ul>
	<li>
あらゆる生成元を表現する，特別な値
"`*@P"
。
この仕様における
`全~生成元@i
は、この値を表す別名として利用される。
【 この別名は、表記的／意味的に明快にするために，この訳に導入している。】
◎
The special value *, which represents every origin, or
</li>
	<li>
`生成元$たちが成す`有順序~集合$
◎
An ordered set of origins
</li>
</ul>


<p class="note">注記：
［
~headerや属性
］内の文字列による許容listの~text表現には、~keyword［
`'self'^l, `'src'^l, `'none'^l
］も現れ得る。
これらの各~keywordは，常に構文解析の間に文脈~内で解釈され、それぞれが指す生成元のみが，許容list~内に格納される。
~keyword自身は、許容listの一部を成すことはない。
◎
The keywords 'self', 'src', and 'none' can appear in the text representation of allowlists in headers and attribute strings. These keywords are always interpreted in context during parsing, and only the origins which they refer to are stored in the allowlist. The keywords themselves are not part of the allowlist.
</p>

<p>
`許容listは生成元に合致する@
かどうか決定するときは、所与の
( `許容list$ %許容list, 生成元 %生成元 )
に対し，次の手続きを走らす:
◎
To determine whether an allowlist matches an origin origin, run these steps:
</p>

<ol>
	<li>
~IF［
%許容list ~EQ `全~生成元$i
］
⇒
~RET ~T
◎
If the allowlist is the special value *, then return true.
</li>
	<li>
%許容list 内の
~EACH( %~item )
に対し
⇒
~IF［
( %~item, %生成元 ) 
は`同じ生成元~domain$である
］
⇒
~RET ~T
◎
Otherwise, for each item in the allowlist:
• If item is same origin-domain with origin, then return true.
</li>
	<li>
~RET ~F
◎
return false.
</li>
</ol>


		</section>
		<section id="default-allowlists">
<h3 title="Default Allowlists">4.9. 既定の許容list</h3>


<p>
各 `特色機能$には、
`既定の許容list@
がある。
`既定の許容list$は、次を決定する
⇒＃
`~top-level閲覧文脈$内に宣言された施策は無い下で，所与の特色機能は文書において許容されるかどうか ／
特色機能への~accessは自動的に`入子の閲覧文脈$に`属する文書$に移譲されるかどうか
◎
Every policy-controlled feature has a default allowlist. The default allowlist determines whether the feature is allowed in a document with no declared policy in a top-level browsing context, and also whether access to the feature is automatically delegated to documents in nested browsing contexts.
</p>

<p>
`特色機能$用の`既定の許容list$は、次のいずれかの値をとる：
◎
The default allowlist for a feature is one of these values:
</p>

<dl>
	<dt>`全~生成元$i</dt>
	<dd>
特色機能は、既定では，`~top-level閲覧文脈$に`属する文書$において許容されることに加え、許容されるときは，
`入子の閲覧文脈$に`属する文書$においても既定で許容される。
◎
The feature is allowed in documents in top-level browsing contexts by default, and when allowed, is allowed by default to documents in nested browsing contexts.
</dd>

	<dt>`'self'^l</dt>
	<dd>
特色機能は、既定では，`~top-level閲覧文脈$に`属する文書$において許容されることに加え、許容されるときは：
`入子の閲覧文脈$に`属する文書$のうち，同じ生成元~domainのものにおいては既定で許容されるが、非同一生成元の文書においては，既定では許容されない。
◎
The feature is allowed in documents in top-level browsing contexts by default, and when allowed, is allowed by default to same-origin domain documents in nested browsing contexts, but is disallowed by default in cross-origin documents in nested browsing contexts.
</dd>

	<dt>`'none'^l</dt>
	<dd>
特色機能は、既定では，`~top-level閲覧文脈$に`属する文書$において許容されないことに加え、`入子の閲覧文脈$に`属する文書$においても，既定では許容されない。
◎
The feature is disallowed in documents in top-level browsing contexts by default, and is also disallowed by default to documents in nested browsing contexts.
</dd>
</dl>

		</section>
	</section>
	<section id="serialization">
<h2 title="Feature Policy Serialization">5. 特色機能~施策の直列化</h2>

		<section id="ascii-serialization">
<h3 title="ASCII serialization">5.1. ~ASCII直列化</h3>


<p>
`施策~指令$は［
~HTTP~header／~HTML属性
］内では、~ASCII~textとして表現される。
◎
Policy Directives are represented in HTTP headers and in HTML attributes as ASCII text.
</p>


<pre class="ABNF">
`serialized-feature-policy@P = `serialized-policy-directive$P *(";" `serialized-policy-directive$P)
`serialized-policy-directive@P = `feature-identifier$P RWS `allow-list$P
`feature-identifier@P = 1*( ALPHA / DIGIT / "-")
`allow-list@P = `allow-list-value$P *(RWS `allow-list-value$P)
`allow-list-value@P = `serialized-origin$P / "*" / "'self'" / "'src'" / "'none'"
</pre>

<p>
`serialized-origin@P
は、`生成元の直列化$である。
しかしながら，符号位置［
`0027^U (') ／
`0021^U (*) ／
`002C^U (,) ／
`003B^U (;)
］は、直列化~内に現れては~MUST_NOT
— それらが要求される場合には、［
`%27^l ／ `%2A^l ／ `%2C^l ／ `%3B^l
］として~percent-符号化され~MUST。
◎
serialized-origin is the serialization of an origin. However, the code points U+0027 ('), U+0021 (*), U+002C (,) and U+003B (;) MUST NOT appear in the serialization. If they are required, they must be percent-encoded as "%27", "%2A", "%2C" or "%3B", respectively.
</p>

<p class="note">注記：
文字列 `'self'^l は、許容list内の生成元として利用されても~MAY。
この仕方で利用されたときは、当の特色機能~施策を包含する文書の生成元を指すことになる。
◎
The string "'self'" may be used as an origin in an allowlist. When it is used in this way, it will refer to the origin of the document which contains the feature policy.
</p>

		</section>
	</section>
	<section id="delivery">
<h2 title="Delivery">6. 送達</h2>

		<section id="feature-policy-http-header-field">
<h3 title="Feature-Policy HTTP Header Field">6.1. `Feature-Policy^h ~HTTP~header</h3>

<p>
［
~clientにより施行されるべきである`特色機能~施策$
］を（ ~serverから~clientへ ）通信するときには、~HTTP応答~内に
`Feature-Policy@h
~headerを利用できる。
◎
The `Feature-Policy` HTTP header field can be used in the response (server to client) to communicate the feature policy that should be enforced by the client.
</p>

<p>
この~headerの値は、 1 個~以上の［
`施策~指令$の`~ASCII直列化$pd
］からなる。
◎
The header’s value is the §5.1 ASCII serialization of one or more policy directives:.
</p>

<pre class="ABNF">
FeaturePolicy = `serialized-feature-policy$P *("," `serialized-feature-policy$P)
</pre>

<p>
`Feature-Policy$h ~headerを受信した~UAは、
<a href="#integration-with-html">~HTMLとの統合</a>
に従って，
<a href="#process-response-policy">応答~施策を処理して</a>
`施行-$し~MUST。
◎
When the user agent receives a `Feature-Policy` header field, it MUST process and enforce the serialized policy as described in §7.1 Integration with HTML.
</p>


		</section>
		<section id="iframe-allow-attribute">
<h3 title="The allow attribute of the iframe element">6.2. `iframe^e 要素の `allow^a 属性</h3>


<pre class="idl">
partial interface `HTMLIFrameElement$I {
    [`CEReactions$] attribute DOMString `allow$m;
};
</pre>

【この~interfaceは、すでに~HTML仕様に統合された。】

<p>
`iframe$e 要素の `allow$aF 属性は、`直列形の特色機能~施策$を包含する。
◎
iframe elements have an "allow" attribute, which contains an ASCII-serialized policy directive.
</p>

<p>
この属性~内に挙げられた名前の特色機能~用の`許容list$は、空になることもある。
その事例では、当の許容list用の既定の値は `'src'^l とする
— この値は、 `iframe^e 要素の `src$aF 属性に与えられた~URLの`生成元$urlを表現する。
◎
The allowlist for the features named in the attribute may be empty; in that case, the default value for the allowlist is 'src', which represents the origin of the URL in the iframe’s src attribute.
</p>

<p>
空でないときは、 `allow^aF 属性により，それを有する `iframe^e 要素が`入子にしている閲覧文脈$が構築されるときに，その`容器~施策$に［
認識される各`特色機能$用の`許容list$
］が追加されることになる。
◎
When not empty, the "allow" attribute will result in adding an allowlist for each recognized feature to the nested browsing context's container policy, when it is constructed.
</p>


		</section>
		<section id="legacy-attributes">
<h3 title="Additional attributes to support legacy features">6.3. 旧来の特色機能を~supportする追加の属性</h3>

<p>
この仕様により制御される一部の`特色機能$に対しては、それ用の既存の属性が `iframe^e 要素~上に定義されている。
この仕様は、これらの属性を `iframe^e 要素~用に宣言された施策として動作するように定義し直す。
◎
Some features controlled by Feature Policy have existing iframe attributes defined. This specification redefines these attributes to act as declared policies for the iframe element.
</p>

			<section id="iframe-allowfullscreen-attribute">
<h4 title="allowfullscreen">6.3.1. `allowfullscreen^a</h4>

<p>
`iframe^e 要素~上の `allowfullscreen$aF 属性は、
`requestFullscreen()$m への~accessを制御する。
◎
The "allowfullscreen" iframe attribute controls access to requestFullscreen().
</p>


<p>
`iframe^e 要素が `allow$aF 属性を有していて，その値は ~token `fullscreen^l を包含する場合、
`allowfullscreen$aF 属性は効果を及ぼしては~MUST_NOT。
◎
If the iframe element has an "allow" attribute whose value contains the token "fullscreen", then the "allowfullscreen" attribute must have no effect.
</p>

<p>
他の場合， `iframe^e 要素が `allowfullscreen$aF 属性を有するならば、要素が`入子にしている閲覧文脈$が構築されるときに，その`容器~施策$に `fullscreen^l 特色機能~用の`許容list$として `全~生成元$i が追加されることになる。
◎
Otherwise, the presence of an "allowfullscreen" attribute on an iframe will result in adding an allowlist of * for the "fullscreen" feature to the nested browsing context's container policy, when it is constructed.
</p>


<p class="note">注記：
これは、
`&lt;iframe allow="fullscreen"&gt;^c
の挙動から異なるが、既存の `allowfullscreen^a の利用と互換性を得るためにある。
`allow="fullscreen"^c,
`allowfullscreen^c
の両者とも `iframe^e 要素~上に在する場合、より制約的な方の許容listを成す `allow="fullscreen"^c が利用されることになる。
◎
This is different from the behaviour of &lt;iframe allow="fullscreen"&gt;, and is for compatibility with existing uses of allowfullscreen. If allow="fullscreen" and allowfullscreen are both present on an iframe element, then the more restrictive allowlist of allow="fullscreen" will be used.
</p>

			</section>
			<section id="iframe-allowpaymentrequest-attribute">
<h4 title="allowpaymentrequest">6.3.2. `allowpaymentrequest^a</h4>

<p>
`iframe^e 要素~上の `allowpaymentrequest$aF 属性は
`PaymentRequest$I への~accessを制御する。
◎
The "allowpaymentrequest" iframe attribute controls access to paymentrequest.
</p>

<p>
`iframe^e 要素は `allow$aF 属性を有していて，その値は `payment^l を包含する場合、
`allowpaymentrequest$aF 属性は効果を及ぼしては~MUST_NOT。
◎
If the iframe element has an "allow" attribute whose value contains the token "payment", then the "allowpaymentrequest" attribute must have no effect.
</p>


<p>
他の場合， `iframe^e 要素が `allowpaymentrequest$aF 属性を有するならば、要素が`入子にしている閲覧文脈$が構築されるときに，その`容器~施策$に `payment^l 特色機能~用の`許容list$として `全~生成元$i が追加されることになる。
◎
Otherwise, the presence of an "allowpaymentrequest" attribute on an iframe will result in adding an allowlist of * for the "payment" feature to the nested browsing context's container policy, when it is constructed.
</p>


<p class="note">注記：
これは、 `&lt;iframe allow="payment"&gt;^c の挙動と異なるが、既存の `allowpaymentrequest^a の利用と互換性を得るためにある。
`allow="payment"^c,
`allowpaymentrequest^a
の両者とも `iframe^e 要素~上に在する場合、より制約的な方の許容listを成す `allow="payment"^c が利用されることになる。
◎
This is different from the behaviour of &lt;iframe allow="payment"&gt;, and is for compatibility with existing uses of allowpaymentrequest. If allow="payment" and allowpaymentrequest are both present on an iframe element, then the more restrictive allowlist of allow="payment" will be used.
</p>

			</section>
			<section id="iframe-allowusermedia-attribute">
<h4 title="allowusermedia">6.3.3. `allowusermedia^a</h4>


<p>
`iframe^e 要素~上の `allowusermedia$aF 属性は、
`getUserMedia()$m への~accessを制御する。
◎
The "allowusermedia" iframe attribute controls access to getUserMedia().
</p>

<p>
`iframe^e 要素が `allow$aF 属性を有していて，その値は~token `payment^l を包含する場合、
`allowusermedia$aF 属性は効果を及ぼしては~MUST_NOT。
◎
If the iframe element has an "allow" attribute whose value contains the token "payment", then the "allowusermedia" attribute must have no effect.
</p>


<p>
他の場合， `iframe^e 要素が `allowusermedia$aF 属性を有するならば、要素が`入子にしている閲覧文脈$が構築されるときに，その`容器~施策$に［
`camera^l, `microphone^l
］各~特色機能~用の`許容list$として `全~生成元$i が追加されることになる。
◎
Otherwise, the presence of an "allowusermedia" attribute on an iframe will result in adding an allowlist of * for each of the "camera" and "microphone" features to the nested browsing context's container policy, when it is constructed.
</p>


<p class="note">注記：
これは
`&lt;iframe allow="camera; microphone"&gt;^c
の挙動と異なるが、既存の `allowusermedia^a の利用と互換性を得るためにある。
`allow="camera; microphone"^c,
`allowusermedia^a
の両者とも `iframe^e 要素~上に在る場合、より制約的な方の許容listを成す `allow="camera; microphone"^c が利用されることになる。
同様に，［
`allow="camera"^c,
`allow="microphone"^c
］の片方だけが在する場合、その特色機能~用には より制約的な方の許容listが利用されることになる一方で、
他方には より制約的でない方の許容listを成す `全~生成元$i を利用することになる。
◎
This is different from the behaviour of &lt;iframe allow="camera; microphone"&gt;, and is for compatibility with existing uses of allowusermedia. If allow="camera; microphone" and allowusermedia are both present on an iframe element, then the more restrictive allowlist of allow="camera; microphone" will be used. Similarly, if only one of allow="camera" or allow="microphone" is present, then the more restrictive allowlist will be used for that feature, while the other will use the less restrictive *.
</p>

			</section>
		</section>
	</section>
	<section id="integrations">
<h2 title="Integrations">7. 統合</h2>

<p>
この文書は、一連の~algoを定義する
— 他の仕様は、この仕様が定義する制約を実装するために，それらを利用することになる。
統合については，明確さを得るためここで要旨するが†、それらの外部~仕様が規範的であり，詳細はそれらを参照すること。
◎
This document defines a set of algorithms which other specifications will use in order to implement the restrictions which Feature Policy defines. The integrations are outlined here for clarity, but those external documents are the normative references which ought to be consulted for detailed information.
</p>

		<section id="integration-with-html">
<h3 title="Integration with HTML">7.1. ~HTMLとの統合</h3>

<p class="trans-note">【†
この訳では、原文をさらに簡約して，該当する変更点とその参照先を挙げるにとどめる（原文の “引用” による記述は、~HTML仕様の更新に伴い，次第に乖離していくと予想されるので）。
】</p>

<ol>
	<li>
`文書$用の`特色機能~施策$は、各 `文書$が持つ`特色機能~施策$doc（初期~時は空）を設定することにより，
`施行-@
されることになる。
【具体的には、次項に挙げる~algo, および`特色機能~施策~属性を処理する$ことを通して。】
◎
Document objects have a Feature Policy, which is initially empty.
◎
↓</li>
	<li>
次に挙げる~algoは改変された
⇒＃
`新たな閲覧文脈を作成する$／
`文書を初期化する$／
特色機能の`利用は許容される$かどうかを決定する
◎
Replace the existing step 12 of "Create a new browsing context" with with the following step:
• Execute the Initialize document’s Feature Policy algorithm on the Document object. 
◎
Replace the existing step 8 of "Initialising a new Document object" with the following step:
• Execute the Initialize document’s Feature Policy from response algorithm on the Document object and the response used to generate the document. 
◎
A feature policy is enforced for a Document by setting it as the Document's Feature Policy.
◎
The "allowed to use" algorithm is replaced with the following:
• 以下略
</li>
	<li>
`iframe$e 要素に `allow$aF 属性が追加された。
◎
The allow attribute is added to the IDL for the iframe element, with the description:
• 以下略
</li>
	<li>
`allowfullscreen$aF,
`allowpaymentrequest$aF,
`allowusermedia$aF
属性の挙動は変更された。
◎
The description of the behavior of the allowfullscreen, allowpaymentrequest and allowusermedia attributes is changed to refer to this specification:
• 以下略
</li>
	<li>
もはや参照されなくなった “`set the allow* flags^en” ~algoは除去された。
◎
The set the allow* flags algorithm is removed, as it is no longer referenced.
</li>
</ol>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">8. 各種~algo</h2>

		<section id="process-response-policy">
<h3 title="Process response policy">8.1. 応答~施策を処理する</h3>

<p>
この~algoは、所与の
( `応答$ %応答, `生成元$ %生成元 )
に対し，`宣言-済み施策$を返す：
◎
Given a response (response) and an origin (origin), this algorithm returns a declared feature policy.
</p>

<ol>
	<li>
~IF［
%応答 の`~header~list$rs内に `Feature-Policy^h を`名前に持つ~header$は無い
］
⇒
~RET
◎
Abort these steps if the response’s header list does not contain a header whose name is "Feature-Policy".
</li>
	<li>
%~header値 ~LET %応答 の`~header~list$rs内の `Feature-Policy^h に対する`結合-済みの値$hd
◎
Let header be the concatenation of the values of all header fields in response’s header list whose name is "Feature-Policy", separated by U+002C (,) (according to [RFC7230, 3.2.2]).
</li>
	<li>
%特色機能~施策 ~LET `値と生成元から~headerを構文解析する$( %~header値, %生成元 )
◎
Let feature policy be the result of executing §8.2 Parse header from value and origin on header and origin.
</li>
	<li>
~RET %特色機能~施策
◎
Return feature policy.
</li>
</ol>

		</section>
		<section id="parse-header">
<h3 title="Parse header from value and origin">8.2. %値 と %生成元 から~headerを構文解析する</h3>

<p>
この~algoは、所与の
( 文字列 %値, `生成元$ %生成元 )
に対し，`宣言-済み施策$を返す：
◎
Given a string (value) and an origin (origin) this algorithm will return a declared feature policy.
</p>

<ol>
	<li>
%施策 ~LET 新たな`有順序~map$
◎
Let policy be an empty ordered map.
</li>
	<li>
<p>
`~commaで分割する$( %値 ) の結果を成す
~EACH( %要素 )
に対し：
◎
For each element returned by splitting value on commas:
</p>
		<ol>
			<li>
%指令 ~LET `値と生成元から施策~指令を構文解析する$( %要素, %生成元 )
◎
Let directive be the result of executing §8.3 Parse policy directive from value and origin on element and origin
</li>
			<li>
`指令を宣言-済み施策に併合する$( %指令, %施策 )
◎
Run §8.4 Merge directive with declared policy on directive and policy.
</li>
		</ol>
	</li>
	<li>
~RET %施策
◎
Return policy.
</li>
</ol>

		</section>
		<section id="parse-policy-directive">
<h3 title="Parse policy directive from value and origin">8.3. %値 と %生成元 から施策~指令を構文解析する</h3>

<p>
この~algoは、所与の
( 文字列 %値, `生成元$ %生成元 )
に対し，`施策~指令$を返す：
◎
Given a string (value) and an origin (origin) this algorithm will return a policy directive.
</p>

<ol>
	<li>
%指令 ~LET 新たな`有順序~map$
◎
Let directive be an empty ordered map.
</li>
	<li>
<p>
`区切子で厳密に分割する$( %値, `003B^U (;) )
の結果を成す
~EACH( %直列形の宣言 )
に対し：
◎
For each serialized-declaration returned by strictly splitting value on the delimiter U+003B (;):
</p>
		<ol>
			<li>
%~token~list ~LET `~ASCII空白で分割する$( %直列形の宣言 )
◎
Let tokens be the result of splitting serialized-declaration on ASCII whitespace.
</li>
			<li>
~IF［
%~token~list は空である
］
⇒
~CONTINUE
◎
If tokens is an empty list, then continue.
</li>
			<li>
%特色機能~名 ~LET %~token~list[0]
◎
Let feature-name be the first element of tokens.
</li>
			<li>
%特色機能 ~LET %特色機能~名 により識別される`~support済み特色機能$が［
在るならば それ ／
無いならば ε
］
◎
If feature-name does not identify any recognized policy-controlled feature, then continue.
</li>
			<li>
~IF［
%特色機能 ~EQ ε
］
⇒
~CONTINUE
◎
Let feature be the policy-controlled feature identified by feature-name.
</li>
			<li>
%~target~list ~LET %~token~list から最初の~itemを除去して得られる~list
◎
Let targetlist be the remaining elements, if any, of tokens.
</li>
			<li>
%許容list ~LET 新たな`許容list$
◎
Let allowlist be a new allowlist.
</li>
			<li>
~IF［
`全~生成元$i ~IN %~target~list
］
⇒
%許容list ~SET `全~生成元$i
◎
If any element of targetlist is the string "*", set allowlist to the special value *.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%許容list ~SET 新たな `有順序~集合$
◎
Set allowlist to an new ordered set.
</li>
					<li>
<p>
%~target~list 内の
~EACH( %要素 )
に対し：
◎
For each element in targetlist:
</p>
						<ol>
							<li>
%結果 ~LET ［
%要素 は 文字列 `'self'^l に`~ASCII大小無視$で合致するならば %生成元 ／
~ELSE_ `~URL構文解析する$( %要素 )
］
◎
If element is an ASCII case-insensitive match for the string "'self'", let result be origin.
◎
Otherwise, let result be the result of executing the URL parser on element.
</li>
							<li>
<p>
~IF［
%結果 ~NEQ `失敗^i：
］
⇒
◎
If result is not failure:
</p>
								<ol>
									<li>
%~target ~LET %結果 の`生成元$url
◎
Let target be the origin of result.
</li>
									<li>
~IF［
%~target は`不透明な生成元$でない
］
⇒
%許容list に %~target を付加する
◎
If target is not an opaque origin, append target to allowlist.
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%指令[ %特色機能 ] ~SET %許容list
◎
Set directive[feature] to allowlist.
</li>
		</ol>
	</li>
	<li>
~RET %指令
◎
Return directive
</li>
</ol>

		</section>
		<section id="merge-directive-with-declared-policy">
<h3 title="Merge directive with declared policy">8.4. 指令を宣言-済み施策に併合する</h3>

<p>
この~algoは、所与の
( 施策~指令 %指令, `宣言-済み施策$ %施策 )
に対し，新たな指令を織り込むように %施策 を改変する：
◎
Given a policy directive (directive) and a declared policy (policy), this algorithm will modify policy to account for the new directive.
</p>

<ol>
	<li>
<p>
%指令 を成す
~EACH( %特色機能 → %許容list )
に対し：
◎
For each feature → allowlist of directive:
</p>
		<ol>
			<li>
~IF［
%施策[ %特色機能 ] ~EQ ε
］
⇒
%施策[ %特色機能 ] ~SET %許容list
◎
If policy does not contain an allowlist for feature, then set policy[feature] to allowlist.
</li>
		</ol>
	</li>
</ol>


		</section>
		<section id="process-feature-policy-attributes">
<h3 title="Process feature policy attributes">8.5. 特色機能~施策~属性を処理する</h3>

<p>
この~algoは、所与の
( 要素 %要素 )
に対し，`容器~施策$を返す（空にもなり得る）：
◎
Given an element (element), this algorithm returns a container policy, which may be empty.
</p>

<ol>
	<li>
%施策 ~LET 新たな`施策~指令$
◎
Let policy be a new policy directive.
</li>
	<li>
%容器~施策 ~LET 
<a href="#parse-allow-attribute">`allow^a 属性を構文解析する</a>(
%要素 の `allow$aF 属性の値,
%要素 の~node文書の生成元,
%要素 の `src$aF 属性に与えられた~URLの`生成元$url
)

◎
Let container policy be the result of running Parse allow attribute on the value of element’s allow attribute, with container origin set to the origin of element’s node document, and target origin set to the origin of the URL in element’s src attribute.
</li>
	<li>
~IF［
%要素 は `iframe$e 要素でない
］
⇒
~RET %容器~施策
【 `allow^a 属性が定義されているのは `iframe^e しかないので、この記述はおかしい。】
◎
If element is an iframe element:
</li>
	<li>
~IF［
%要素 は `allowfullscreen$aF 属性を有する
］~AND［
%容器~施策[ `fullscreen^ft ] ~EQ ε
］
⇒
%容器~施策[ `fullscreen^ft ] ~SET `全~生成元$i
◎
If element’s allowfullscreen attribute is specified, and container policy does not contain an allowlist for fullscreen,
• Construct a new declaration for fullscreen, whose allowlist is the special value *.
• Add declaration to container policy.
</li>
	<li>
~IF［
%要素 は `allowpaymentrequest$aF 属性を有する
］~AND［
%容器~施策[ `payment^ft ] ~EQ ε
］
⇒＃
%容器~施策[ `payment^ft ] ~SET `全~生成元$i
◎
If element’s allowpaymentrequest attribute is specified, and container policy does not contain an allowlist for payment,
• Construct a new declaration for payment, whose allowlist is the special value *.
• Add declaration to container policy.
</li>
	<li>
<p>
~IF［
%要素 は `allowusermediarequest$aF 属性を有する
］
⇒
◎
If element’s allowusermediarequest attribute is specified:
</p>
		<ol>
			<li>
~IF［
%容器~施策[ `camera^ft ] ~EQ ε
］
⇒
%施策[ `camera^ft ]† ~SET `全~生成元$i
◎
If container policy does not contain an allowlist for camera,
• Construct a new declaration for camera, whose allowlist is the special value *.
• Add declaration to policy.
</li>
			<li>
~IF［
%施策[ `microphone^ft ]† ~EQ ε
］
⇒
%容器~施策[ `microphone^ft ] ~SET `全~生成元$i
◎
If policy does not contain an allowlist for microphone,
• Construct a new declaration for microphone, allowlist is the special value *.
• Add declaration to container policy.
</li>
		</ol>

【† おそらく、 %施策 ではなく， %容器~施策 （したがって最初の段も不要）】
	</li>
	<li>
~RET %容器~施策
◎
Return container policy.
</li>
</ol>


		</section>
		<section id="parse-allow-attribute">
<h3 title="Parse allow attribute">8.6. `allow^a 属性を構文解析する</h3>


<p>
この~algoは、所与の
( 文字列 %値, 生成元 %容器~生成元, 生成元 %~target生成元 )
に対し，`施策~指令$を返す：
◎
Given a string (value), and two origins (container origin and target origin), this algorithm returns a policy directive.
</p>

<ol>
	<li>
%指令 ~LET 新たな`有順序~map$
◎
Let directive be an empty ordered map.
</li>
	<li>
<p>
`区切子で厳密に分割する$( %値, `003B^U (;) )
の結果を成す
~EACH( %直列形の宣言 )
に対し：
◎
For each serialized-declaration returned by strictly splitting value on the delimiter U+003B (;):
</p>
		<ol>
			<li>
%~token~list ~LET `~ASCII空白で分割する$( %直列形の宣言 )
◎
Let tokens be the result of splitting serialized-declaration on ASCII whitespace.
</li>
			<li>
~IF［
%~token~list は空である
］
⇒
~CONTINUE
◎
If tokens is an empty list, then continue.
</li>
			<li>
%特色機能~名 ~LET %~token~list[0]
◎
Let feature-name be the first element of tokens.
</li>
			<li>
%特色機能 ~LET %特色機能~名 により識別される`~support済み特色機能$が［
在るならば それ ／
無いならば ε
］
◎
If feature-name does not identify any recognized policy-controlled feature, then continue.
</li>
			<li>
~IF［
%特色機能 ~EQ ε
］
⇒
~CONTINUE
◎
Let feature be the policy-controlled feature identified by feature-name.
</li>
			<li>
%~target~list ~LET %~token~list から最初の~itemを除去して得られる~list
◎
Let targetlist be the remaining elements, if any, of tokens.
</li>
			<li>
%許容list ~LET 新たな`許容list$
◎
Let allowlist be a new allowlist.
</li>
			<li>
~IF［
`全~生成元$i ~IN %~target~list
］
⇒
%許容list ~SET `全~生成元$i
◎
If any element of targetlist is the string "*", set allowlist to the special value *.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%許容list ~SET 新たな `有順序~集合$
◎
Set allowlist to an new ordered set.
</li>
					<li>
~IF［
%~target~list は空である
］
⇒
%許容list に %~target生成元 を付加する
◎
If targetlist is empty, append target origin to allowlist.
</li>
					<li>
<p>
%~target~list を成す
~EACH( %要素 )
に対し：
◎
For each element in targetlist:
</p>
						<ol>
							<li>
%結果 ~LET %要素 は`~ASCII大小無視$で何に合致するかに応じて
⇒＃
`'self'^l に合致するならば %容器~生成元 ／
`'src'^l に合致するならば %~target生成元 ／
~ELSE_ `~URL構文解析する$( %要素 )
◎
If element is an ASCII case-insensitive match for "'self'", let result be container origin.
◎
If element is an ASCII case-insensitive match for "'src'", let result be target origin.
◎
Otherwise, let result be the result of executing the URL parser on element.
</li>
							<li>
<p>
~IF［
%結果 ~NEQ `失敗^i
］：
◎
If result is not failure:
</p>
								<ol>
									<li>
%~target ~LET %結果 の`生成元$url
◎
Let target be the origin of result.
</li>
									<li>
~IF［
%~target は不透明~生成元でない
］
⇒
%許容list に %~target を付加する
◎
If target is not an opaque origin, append target to allowlist.
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%指令[ %特色機能 ] ~SET %許容list
◎
Set directive[feature] to allowlist.
</li>
		</ol>
	</li>
	<li>
~RET %指令
◎
Return directive
</li>
</ol>


		</section>
		<section id="initialize-for-document">
<h3 title="Initialize document’s Feature Policy">8.7. %文書 の特色機能~施策を初期化する</h3>

<p>
この~algoは、所与の
( 文書~obj %文書 )
に対し， %文書 の`特色機能~施策$docを初期化する：
◎
Given a Document object (document), this algorithm initialises document’s Feature Policy
</p>

<ol>
	<li>
%継承した施策 ~LET 新たな`有順序~map$
◎
Let inherited policy be a new ordered map.
</li>
	<li>
%宣言-済み施策 ~LET 新たな`有順序~map$
◎
Let declared policy be a new ordered map.
</li>
	<li>
~EACH( `~support済み特色機能$ %特色機能 )
に対し
⇒
%継承した施策[ %特色機能 ] ~SET ~LET `継承される施策を特色機能~用に定義する$( %特色機能, %文書 が`属する閲覧文脈$ )
◎
For each feature supported,
• Let isInherited be the result of running §8.9 Define an inherited policy for feature on feature and document’s browsing context.
• Set inherited policy[feature] to isInherited.
</li>
	<li>
%施策 ~LET 次のようにされた新たな`特色機能~施策$
⇒＃
`継承した施策$ ~SET %継承した施策,
`宣言-済み施策$ ~SET %宣言-済み施策
◎
Let policy be a new feature policy, with inherited policy inherited policy and declared policy declared policy.
</li>
	<li>
%文書 の`特色機能~施策$doc ~SET %施策
（すなわち、 %施策 を`施行する$）
◎
Enforce the policy policy on document.
</li>
</ol>

		</section>
		<section id="initialize-from-response">
<h3 title="Initialize document’s Feature Policy from response">8.8. %応答 からの特色機能~施策で %文書 のそれを初期化する</h3>

<p>
この~algoは、所与の
( `応答$ %応答, 文書 %文書 )
に対し，
%文書 の`特色機能~施策$を拡充する：
◎
Given a response (response) and a Document (document), this algorithm populates document’s Feature Policy
</p>

<ol>
	<li>
%文書 の`特色機能~施策を初期化する$
◎
Initialize document’s Feature Policy
</li>
	<li>
%継承した施策 ~LET %文書 の特色機能~施策が`継承した施策$
◎
Let inherited policy be document’s Feature Policy’s inherited policy.
</li>
	<li>
%宣言-済み施策 ~LET 新たな`有順序~map$
◎
Let declared policy be a new ordered map.
</li>
	<li>
%施策~指令 ~LET `応答~施策を処理する$( %応答, %文書 の生成元 )
◎
Let d be the result of running Process response policy on response and document’s origin.
</li>
	<li>
%施策~指令 を成す
~EACH( %特色機能 → %許容list )
に対し
⇒
~IF［
%継承した施策[ %特色機能 ] ~EQ ~T
］
⇒
%宣言-済み施策[ %特色機能 ] ~SET %許容list
◎
For each feature → allowlist of d:
• If inherited policy[feature] is true, then set declared policy[feature] to allowlist.
</li>
	<li>
%施策 ~LET 次のようにされた新たな`特色機能~施策$
⇒＃
`継承した施策$ ~SET %継承した施策,
`宣言-済み施策$ ~SET %宣言-済み施策
◎
Let policy be a new feature policy, with inherited policy inherited policy and declared policy declared policy.
</li>
	<li>
%文書 上で施策 %施策 を`施行する$
◎
Enforce the policy policy on document.
</li>
</ol>

		</section>
		<section id="define-inherited-policy">
<h3 title="Define an inherited policy for feature">8.9. %特色機能 用に継承される施策を定義する</h3>

<p>
この~algoは、所与の
( 特色機能 %特色機能, 閲覧文脈 %文脈 )
に対し， %特色機能 用に`継承した施策$を返す：
◎
Given a feature (feature) and a browsing context (context), this algorithm returns the inherited policy for that feature.
</p>

<ol>
	<li>
<p>
~IF［
%文脈 は`入子の閲覧文脈$である
］：
◎
If context is a nested browsing context:
</p>
		<ol>
			<li>
%親 ~LET %文脈 の`親~閲覧文脈$にて`作動中の文書$
◎
Let parent be context’s parent browsing context’s active document.
</li>
			<li>
%生成元 ~LET %親 の`生成元$
◎
Let origin be parent’s origin
</li>
			<li>
%容器~施策 ~LET `特色機能~施策~属性を処理する$( %文脈 の`閲覧文脈~容器$ )
◎
Let container policy be the result of running §8.5 Process feature policy attributes on context’s browsing context container.
</li>
			<li>
<p>
~IF［
%容器~施策[ %特色機能 ] ~NEQ ε
］：
◎
If feature is a key in container policy:
</p>
				<ol>
					<li>
~IF［
`許容listは生成元に合致する$( %容器~施策[ %特色機能 ], %生成元 )
］~AND［
%親 が`継承した施策$[ %特色機能 ] ~EQ `可能化される^i
］
⇒
~RET `可能化される^i
◎
If the allowlist for feature in container policy matches origin, and parent’s inherited policy for feature is "Enabled", return "Enabled".
</li>
					<li>
~RET `不能化される^i
◎
Otherwise return "Disabled".
</li>
				</ol>
			</li>
			<li>
~IF［
`特色機能は施策により生成元~用に可能化されるか？$( %特色機能, %親, %生成元 )
］
⇒
~RET `可能化される^i
◎
Otherwise, if feature is enabled in parent for origin, return "Enabled".
</li>
			<li>
~RET `不能化される^i
◎
Otherwise, return "Disabled".
</li>
		</ol>
	</li>
	<li>
~RET `可能化される^i
◎
Otherwise, return "Enabled".
</li>
</ol>

		</section>
		<section id="is-feature-enabled">
<h3 title="Is feature enabled in document for origin?">8.10. %文書 内の %特色機能 は %生成元 用に可能化されるか？</h3>

<p>
この~algoは、所与の
( 特色機能 %特色機能, `文書$ %文書, `生成元$ %生成元 )
に対し，［
%特色機能 は不能化されるべきものと見なされるならば `不能化される^i ／
~ELSE_  `可能化される^i
］を返す：
◎
Given a feature (feature), a Document object (document), and an origin (origin), this algorithm returns "Disabled" if feature should be considered disabled, and "Enabled" otherwise.
</p>

<ol>
	<li>
%施策 ~LET %文書 の`特色機能~施策$
◎
Let policy be document’s Feature Policy
</li>
	<li>
~IF［
%施策 が`継承した施策$[ %特色機能 ] ~EQ `不能化される^i
］
⇒
~RET `不能化される^i
◎
If policy’s inherited policy for feature is Disabled, return "Disabled".
</li>
	<li>
<p>
~IF［
%施策 の`宣言-済み施策$[ %特色機能 ] ~NEQ ε
］：
◎
If feature is present in policy’s declared policy:
</p>
		<ol>
			<li>
~IF［
`許容listは生成元に合致する$( %施策 の`宣言-済み施策$[ %特色機能 ], %生成元 )
］
⇒
~RET `可能化される^i
◎
If the allowlist for feature in policy’s declared policy matches origin, then return "Enabled".
</li>
			<li>
~RET `不能化される^i
◎
Otherwise return "Disabled".
</li>
		</ol>
	</li>
	<li>
~IF［
%特色機能 の`既定の許容list$ ~EQ `全~生成元$i
］
⇒
~RET `可能化される^i
◎
If feature’s default allowlist is *, return "Enabled".
</li>
	<li>
~IF［
%特色機能 の`既定の許容list$ ~EQ `'self'^l
］~AND［
( %生成元, %文書 の生成元 )
は`同じ生成元~domain$である
］
⇒
~RET `可能化される^i
◎
If feature’s default allowlist is 'self', and origin is same origin-domain with document’s origin, return "Enabled".
</li>
	<li>
~RET `不能化される^i
◎
Return "Disabled".
</li>
</ol>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">9. ~IANA 考慮点</h2>

<p>
恒久的~message~header~registryは、次の登録で更新されるべきである
`RFC3864$r
：
◎
The permanent message header field registry should be updated with the following registration [RFC3864]:
</p>

<div>

<dl>
	<dt>~header名</dt>
	<dd>`Feature-Policy^h</dd>

	<dt>適用-可能な~protocol</dt>
	<dd>http</dd>

	<dt>位置付け</dt>
	<dd>標準</dd>

	<dt>Author/Change controller</dt>
	<dd>W3C</dd>

	<dt>仕様~文書</dt>
	<dd>
<a href="https://wicg.github.io/feature-policy/">Feature Policy API</a>
【この仕様】
</dd>
</dl>

◎
Header field name
• Feature-Policy
Applicable protocol
• http
Status
• standard
Author/Change controller
• W3C
Specification document
• Feature Policy API
</div>

	</section>
	<section id="privacy-and-security">
<h2 title="Privacy and Security">10. ~privacyと~security</h2>

<p>
この仕様は、埋込まれる頁~上で施行することになる施策を設定するための仕組みを標準~化する。
`iframe^e 要素の `sandbox$aF 属性と同様に、これは，埋込まれる頁から許可が明示されなくとも行える。
それは、すでに公表された~web~site内に存在している特色機能の挙動を変更できることを意味する
— 別の文書~内で、それらの頁を，適切な容器~施策を伴わせて埋込むことにより。
◎
This specification standardizes a mechanism for an embedding page to set a policy which will be enforced on an embedded page. Similar to iframe sandbox, this can be done without the express permission of the embedded page, which means that behaviors of existing features can be changed in published web sites, by embedding them in another document with an appropriate container policy.
</p>


<p>
そのようなわけで、最も重大な
~privacy／~security
上の懸念は：
◎
As such, the biggest privacy and security concerns are:
</p>

<ul>
	<li>
非同一生成元 下位frame内の挙動が，それを埋込んでいる側に公開されること
◎
Exposure of behavior in a cross-origin subframe to its embedder
</li>
	<li>
埋込んだ側が制御することによる、下位frameにおける挙動の予想外の変化
◎
Unanticipated behavior changes in subframes controlled by the embedder
</li>
</ul>

<p>
これらの懸念は、すでにある程度~web~platformに在する。
この仕様は、少なくとも それを無用に悪化させないよう試みる。
◎
To a degree, these concerns are already present in the web platform, and this specification attempts to at least not make them needlessly worse.
</p>


<p>
個々の特色機能の設計も，~securityと~privacyの課題をもたらし得るので、この仕様と統合するときには，~careされ~MUST。
この節は、どの種類の挙動がそのような課題をもたらし得るかについて，いくつかの手引きを供することを試みる。
◎
Security and privacy issues may also be caused by the design of individual features, so care must be taken when integrating with this specification. This section attempts to provide some guidance as to what kinds of behaviors could cause such issues.
</p>



		<section id="privacy-expose-behavior">
<h3 title="Exposure of cross-origin behavior">10.1. 埋込まれた非同一生成元の挙動の公開</h3>

<p>
特色機能は、［
~frame化された文書における施策の違反は、他の~frame内の文書からは観測-可能にならない
］ように，設計されるべきである。
具体例として、仮に，ある特色機能が［
施策により不能化されている下で利用されたときは、埋込んでいる文書に向けて~eventを発火させる
］となると、埋込まれた文書の状態についての情報を抽出することにも利用できることになる。
具体例として，［
その特色機能は，利用者が~siteに~log-inしている間に限り利用される
］ことが既知である場合、埋込んだ側は
— その特色機能を当の~frameに対し不能化した上で，結果の~eventを~listenすることにより —
利用者が~log-inしているかどうか決定することもできる。
◎
Features should be designed such that a violation of the policy in a framed document is not observable by documents in other frames. For instance, a hypothetical feature which caused a event to be fired in the embedding document if it is used while disabled by policy, could be used to extract information about the state of an embedded document. If the feature is known only to be used while a user is logged in to the site, for instance, then the embedder could disable that feature for the frame, and then listen for the resulting events to determine whether or not the user is logged in.
</p>



		</section>
		<section id="privacy-alter-behavior">
<h3 title="Unanticipated behavior changes">10.2. 予想外の挙動の変化</h3>

<p>
特色機能~施策は、［
ある下位frameが読込まれる時点で，［
その~frame内で，どの特色機能が可用になるか, ならないか
］を制御する能
］を，文書に是認する。
当の特色機能が，~web~platformに長期に存在していた挙動を表現しているならば、このことは［
~web上に公表された既存の内容において，特定0の~APIが失敗し得る
］ことを意味する（内容がそれを予期することなく書かれたならば）。
◎
Feature policy grants a document the ability to control which features will and will not be availble in a subframe at the time it is loaded. When a feature represents an existing, long-standing behavior of the web platform, this may mean that existing published content on the web was not written with the expectation that a particular API could fail.
</p>

<div class="example">

<p>
（不自然だが）実用的な例として、［
利用者が頁に~accessするに足る特権を有するかどうか
］を，同期的 `XMLHttpRequest^I を利用して決定している文書を考える：
◎
As a practical (though contrived) example, consider a document which uses synchronous XMLHttpRequest to determine whether a user has sufficient privileges to access the page:
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;h1&gt;Welcome to SecureCorp!&lt;/h1&gt;
&lt;script&gt;
  var req = new XMLHttpRequest();
  req.open("GET", "/api/security_check.json", false);
  req.send();
  if (req.response == "untrusted user") {
	/* <span class="comment">
利用者は~log-inしていない
— 安全な頁へ~redirectする
◎
User is not logged in; redirect to a safe page
</span> */
    location.href = "/security_check_failed.html";
  }
&lt;/script&gt;
&lt;!-- <span class="comment">
頁は、利用者が~log-inした前提の下で継続する
◎
Page continues with assumption that user is logged in
</span> --&gt;
</pre>

<p>
この文書がある頁に埋込まれ，その頁が `sync-xhr^l 特色機能を不能化した場合、
`XMLHttpRequest.open()^m の~callは失敗して，~security検査は迂回されることになる。
◎
If this document is embedded by a page which disables the "sync-xhr" feature, the call to XMLHttpRequest.open() would fail, and the security check would be bypassed.
</p>

</div>

<p>
~web上では、この類の挙動の強制-法はすでにアリなことに注意。
特色機能には、 `iframe^e には許容されず，~top-level文書~内に限り許容されるものもある。
また， `iframe^e ~sandbox法は、類似する仕方で，~frameを
— それが依存し得る特色機能に~accessすることなく —
埋込むときに利用できる。
◎
Note that this sort of behavior forcing is already possible on the web: some features are only allowed in top-level documents, and not in any iframes, and iframe sandboxing can be used in a similar way to embed a frame without access to features which it may be depending on.
</p>


<p>
一般に，この懸念を軽減するには、 2 つの仕方がある：
◎
In general, this concern is mitigated in two ways:
</p>

<ul>
	<li>
脆弱な頁は、 `X-Frame-Options^h ~HTTP~headerを伴わせて ~serveできる
— そうすれば、攻撃者が~frame化するのは許容されなくなるので。
◎
The vulnerable page may be served with an X-Frame-Options HTTP header which does not allow it to be framed by an attacker.
</li>
	<li>
~siteは、~APIや挙動を利用しようと試みる前に，それが可用かどうかを特色機能~検出を利用して決定した上で、返された~errorや ~callした~APIから投出された例外を取扱うべきである。
◎
Sites should use feature detection to determine whether an API or behavior is available before attempting to use it, and should handle any documented errors returned or exceptions thrown by the APIs they call.
</li>
</ul>

<p>
自身による特色機能を この仕様と統合している策定者は、［
当の特色機能が不能化されている下で，文書がそれを利用しようと試みたとき、それが いつどのように失敗することになるか
］を裁定できる。
策定者は、既存の失敗~mode【既存の例外~名など】が存在するならば，それを用立てることを試みるべきである
— そうすれば、そのような失敗をすでに正しく取扱っている既存の内容への~~影響は抑えられるので。
◎
Authors integrating their features with Feature Policy can decide when and how the feature will fail when a document attempts to use it while it is disabled. Authors should attempt to make use of existing failure modes, when they exist, to increase the chance that existing content will already be correctly handling such failures.
</p>

		</section>
		<section id="privacy-expose-policy">
<h3 title="Exposure of embedding policy">10.3. 埋込んでいる側の施策の公開</h3>

<p>
ある頁が非同一生成元~頁を埋込んでいるとき
— 埋込んだ側が，埋込まれた側の挙動について推定できる情報を制限するよう~careされていたとしても —
一部の局面においては、埋込まれた側が，埋込んだ側の情報について推定することも
— ［
自身に対し，埋込んだ側が施行した施策
］を検分することにより —
アリになり得る。
◎
Care has been taken to limit the information which an page can infer about the behavior of cross-origin pages which it embeds. It may be possible in some scenarios however, for the embedded page to infer information about its embedder, by examining the policy which the embedder has enforced on it.
</p>

<p>
これは既存の `document.fullscreenEnabled^m に類似する。
それは、埋込まれた側の文書が［
埋込んだ側は、埋込まれた側に `FULLSCREEN$r ~APIを利用する能を是認したかどうか
］を推定するために利用できる。
これが ある種の事例
— 具体例として，利用者が埋込んだ側の~siteに~log-inしたとき —
に限り是認される場合、埋込まれた側の~siteは，埋込んだ側の状態について何かを知り得るようになる。
◎
This is similar to the existing document.fullscreenEnabled property, which can be used by the embedded document to infer whether its embedder has granted it the ability to use the Fullscreen API. If this is only granted in certain cases — when the user is logged in to the embedding site, for instance — then the embedded site can learn something about the state of its embedder.
</p>
		</section>
	</section>
</main></div>
