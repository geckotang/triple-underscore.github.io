<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Common infrastructure（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/infrastructure.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'infrastructure',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 151224 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		st: 'attr-state',
		et: 'event-type',
		sc: 'scheme',
		ps: 'pseudo',
		p: 'production',
		dir: 'directive',
		v: 'value',
		E: 'error',
		js: 'js',
		jA: 'abstract',
//		h: 'header',
		t: 'type',
		U: 'code-point',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		sL: 'code',
		E: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		st: 'span',
		sc: 'code',
		et: 'code',
		v: 'code',
		p: 'code',
		ps: 'code',
		dir: 'code',
//		h: 'code',
		js: 'span',
		jA: 'span',
		V: 'var',
		t: 'var',
		mark: 'mark',
		dfn: 'dfn',
		i: 'i',
		U: 'span',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|❝.|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '❝':
		return ( '<span class="code-point">U+00'
			+ match[1].charCodeAt(0).toString(16).toUpperCase()
			+ '</span> ( "<code class="literal">' + match[1] + '</code>" )'
		);
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	break;
case 'm': // IDL member
case 'sL': 
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text = key.replace(/_/, ':');
	break;
case 'ps': // pseudo
	text = ':' + key;
	break;
case 'h': // http header
	text = '`<code class="header">' + text + '</code>`';
	break;
case 't': // css production
	text = '&lt;' + key + '&gt;'
	break;
case 'jI': // JS intrinsic objects
	text = '%' + key + '%';
	break;
case 'U': // Unicode code point
	text = 'U+' + key;
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<!--% -->
<script type="text/plain" id="_original_id_map">
	conformance-requirements:conformance-classes
	conformance-requirements:dependencies
	conformance-requirements:extensibility-2
	conformance-requirements:interactions-with-xpath-and-xslt
	safe-passing-of-structured-data:cloneable-objects
	safe-passing-of-structured-data:transferable-objects
	safe-passing-of-structured-data:structuredclonewithtransfer
	safe-passing-of-structured-data:structuredclone
	safe-passing-of-structured-data:istransferable
	safe-passing-of-structured-data:performing-structured-clones-from-other-specifications
	safe-passing-of-structured-data:monkey-patch-for-blob-and-filelist-objects

	becomes-connected:node-is-connected
	becomes-disconnected:node-is-disconnected

	廃

	url-record:parsed-url
	parse-a-url:resolve-a-url
	resulting-url-string:resulting-absolute-url
	resulting-url-record:resulting-parsed-url
</script>

<!--% リンク置換データ -->

<script type="text/plain" id="_link_map">

	●idl
CEReactions:~HEcustom#cereactions

I.Uint8ClampedArray:~WEBIDL#idl-Uint8ClampedArray
I.boolean:~WEBIDL#idl-boolean
I.double:~WEBIDL#idl-double
I.long:~WEBIDL#idl-long
I.unsigned long:~WEBIDL#idl-unsigned-long
I.unrestricted double:~WEBIDL#idl-unrestricted-double
I.DOMString:~WEBIDL#idl-DOMString
I.USVString:~WEBIDL#idl-USVString
I.Error:~WEBIDL#idl-Error
I.RegExp:~WEBIDL#idl-RegExp
I.HTMLElement:~HTMLdom#htmlelement
I.Window:~BROWSERS#window
I.Document:~HTMLdom#document
I.Comment:~DOM4#comment
I.Node:~DOM4#node
I.Text:~DOM4#text
I.DOMTokenList:~DOM4#interface-domtokenlist
I.DocumentFragment:~DOM4#interface-documentfragment
I.Element:~DOM4#interface-element
I.NodeList:~DOM4#interface-nodelist
I.HTMLCollection:~DOM4#interface-htmlcollection

I.HTMLFormControlsCollection:#htmlformcontrolscollection
I.HTMLOptGroupElement:~HEforms#htmloptgroupelement
I.HTMLOptionElement:~HEforms#htmloptionelement
I.HTMLOptionsCollection:#htmloptionscollection
I.RadioNodeList:#radionodelist
I.HTMLAllCollection:~HTML5/infrastructure.html#htmlallcollection
I.DOMStringList:#domstringlist

	E.DOMException:~WEBIDL#dfn-DOMException
E.HierarchyRequestError:~WEBIDL#hierarchyrequesterror
E.NotFoundError:~WEBIDL#notfounderror



	●err
E.IndexSizeError:~WEBIDL#indexsizeerror

	●idl member
■member

sL.item:#dom-domstringlist-item
sL.length:#dom-domstringlist-length
sL.contains:#dom-domstringlist-contains

m.window.document:~BROWSERS#dom-document-2
m.src:~HTMLemb#dom-img-src

m.data:~HEcanvas#dom-imagedata-data
m.width:~HEcanvas#dom-imagedata-width
m.height:~HEcanvas#dom-imagedata-height

m.getElementById:~DOM4#dom-nonelementparentnode-getelementbyid
	＊m.isTrusted:~DOM4#dom-event-istrusted

m.dataset:~HTMLdom#dom-dataset

m.~length0:~DOM4#dom-htmlcollection-length
m.~namedItem0:~DOM4#dom-htmlcollection-nameditem
m.item:~DOM4#dom-htmlcollection-item

m.value:#dom-radionodelist-value
m.add:#dom-htmloptionscollection-add
m.length:#dom-htmloptionscollection-length
m.namedItem:#dom-htmlformcontrolscollection-nameditem
m.remove:#dom-htmloptionscollection-remove
m.selectedIndex:#dom-htmloptionscollection-selectedindex
m.setter:#dom-htmloptionscollection-setter


	●element
e.del:~HEedits#the-del-element
e.ins:~HEedits#the-ins-element

e.base:~HEmetadata#the-base-element
e.blockquote:~HEgrouping#the-blockquote-element
e.meta:~HEmetadata#the-meta-element
e.q:~HEtextlevel#the-q-element

e.input:~HEinput#the-input-element
e.button:~HEforms#the-button-element
e.form:~HEforms#the-form-element
e.progress:~HEforms#the-progress-element
e.optgroup:~HEforms#the-optgroup-element
e.option:~HEforms#the-option-element
e.select:~HEforms#the-select-element

e.iframe:~HTMLemb#the-iframe-element
e.img:~HTMLemb#the-img-element

	●attr
a.checked:~HEinput#attr-input-checked
a.type:~HEinput#attr-input-type
a.value:~HEinput#attr-input-value

a.disabled:~HTMLforms#attr-fe-disabled
a.href:~HTMLlinks#attr-hyperlink-href
a.~hrefM:~HEmetadata#attr-base-href
a.id:~HTMLdom#the-id-attribute
a.ping:~HTMLlinks#ping
a.sandbox:~HTMLemb#attr-iframe-sandbox

a.max:~HEforms#attr-progress-max
a.~nameM:~HEmetadata#attr-meta-name
a.name:#_attr-*-name
a.~nameF:~HTMLforms#attr-fe-name
a.~nameO:~HTML5/obsolete.html#attr-option-name


a.aria-*:~HTMLconform#attr-aria-*
a.role:~HTMLconform#attr-aria-role
a.data-*:~HTMLdom#attr-data-*


	●keywords, etc.
sc.about_:~HTMLconform#about-protocol
sc.about_blank:~HTMLconform#about:blank
sc.about_legacy-compat:#about:legacy-compat
sc.about_html-kind:#about:html-kind
sc.about_srcdoc:#about:srcdoc


st.Anonymous:#attr-crossorigin-anonymous
st.Use Credentials:#attr-crossorigin-use-credentials
st.No CORS:#attr-crossorigin-none

st.Number:~HEinput#number-state-(type=number)
st.Radio:~HEinput#radio-button-state-(type=radio)

v.anonymous:#attr-crossorigin-anonymous-keyword
v.use-credentials:#attr-crossorigin-use-credentials-keyword

v.noreferrer:~HTMLlinks#link-type-noreferrer
v.referrer:~HEmetadata#meta-referrer

h.Referrer-Policy:~REFERRER-POLICY#referrer-policy-header-dfn

c.text/html:~HTML5/iana.html#text/html
c.text/plain:~IETF/rfc2046#section-4.1.3
c.application/octet-stream:~IETF/rfc2046#section-4.5.1
c.text/xml:~HTMLindex#text/xml
c.application/xml:~HTMLindex#application/xml

	t.media-condition:~HTMLconform#media-condition

ps.link:~HTMLselectors#selector-link
ps.visited:~HTMLselectors#selector-visited

p.Name:~TR/xml/#NT-Name


	＊&lt;?xml-stylesheet?&gt;:~HTMLconform#xml-stylesheet


	●js clone／転送
jA.ToString:~TC39#sec-tostring


	●
Base10:#_base-ten-integer
String10:#_base-ten-string
Power10:#_base-ten-power
V.~IDL属性:#_reflecting-attr
V.要素:#_element
V.内容~属性:#_reflected-attr
V.内容~値:#_content-attr-value
V.既定~値:#_attr-default-value
V.指定~値:#_specified-value

内容~属性:#_content-attribute
~IDL属性:#_idl-attribute
文書:#_document
0.文書:~HTMLdom#document
資源:#_resource

並列的に:#in-parallel
即時に:#immediately

必須の下位資源:#critical-subresources
~HTML要素:#html-elements
要素~型:#element-type
~XML互換:#xml-compatible
文書~内に挿入された:#insert-an-element-into-a-document
文書から除去された:#remove-an-element-from-a-document
無視される:#ignore
node.挿入される:#nodes-are-inserted
node.除去される:#nodes-are-removed
~liveである:#live
子~text内容:#child-text-content
接続された:#becomes-connected
切断された:#becomes-disconnected
閲覧文脈に接続されて:#browsing-context-connected
閲覧文脈に接続された:#becomes-browsing-context-connected
閲覧文脈から切断された:#becomes-browsing-context-disconnected

~plugin:#plugin
保安化-:#concept-plugin-secure

文字~符号化方式:#encoding
符号化方式:#encoding
符号化方式~名:#encoding-name
符号化方式~label:#encoding-label
UTF-16:#utf-16-encoding


~ASCII互換:#ascii-compatible-encoding
符号単位:#code-unit
~Unicode符号位置:#unicode-code-point
文字:#character
~Unicode文字:#unicode-character
符号単位~長さ:#code-unit-length

	●Encoding
符号化方式を取得-:~ENCODING#concept-encoding-get
UTF-16BE:~ENCODING#utf-16be
UTF-16LE:~ENCODING#utf-16le

	●Fetch
~fetch:~FETCH#concept-fetch
応答:~FETCH#concept-response
rs.種別:~FETCH#concept-response-type
rs.内部~応答:~FETCH#concept-internal-response
要請:~FETCH#concept-request
rq.~url:~FETCH#concept-request-url
rq.行先:~FETCH#concept-request-destination
rq.~mode:~FETCH#concept-request-mode
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.~URL資格証~利用~mode:~FETCH#concept-request-use-url-credentials-flag
	＊rq.~referrer:~FETCH#concept-request-referrer

	●DOM
~ID:~DOM4#concept-id
	＊文書の~address:~DOM4#concept-document-url
x.~URL:~DOM4#concept-document-url
~data:~DOM4#concept-cd-data
文書~符号化方式:~DOM4#concept-document-encoding
根:~DOM4#concept-tree-root
木:~DOM4#concept-tree
木~順序:~DOM4#concept-tree-order
~node文書:~DOM4#concept-node-document

~collection:~DOM4#concept-collection
前挿入-:~DOM4#concept-node-pre-insert
付加-:~DOM4#concept-node-append
置換-:~DOM4#concept-node-replace
表現され:~DOM4#represented-by-the-collection
挿入-時の手続き:~DOM4#concept-node-insert-ext
除去-時の手続き:~DOM4#concept-node-remove-ext
~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document
文書~木~内:~DOM4#in-a-document-tree
接続されて:~DOM4#connected
~shadowも含む根:~DOM4#concept-shadow-including-root


基底~URL変更-手続き:~HTMLconform#base-url-change-steps
基底~URLの変化により影響される:~HTMLconform#affected-by-a-base-url-change

	●CSS
疑似類:~SELECTORS4#pseudo-class
特定0の~CSS文法に則って構文解析する:~CSSSYN#css-parse-something-according-to-a-css-grammar
~CSS色~値として構文解析する:~HTMLconform#parsed-as-a-css-color-value
有名~色:~CSSCOLOR#named-color


	●文字列
位置~変数:~INFRA#string-position-variable
~ASCII空白:~INFRA#ascii-whitespace
~ASCII数字:~INFRA#ascii-digit
~ASCII~hex数字:~INFRA#ascii-hex-digit
小文字~ASCII~hex数字:~INFRA#ascii-lower-hex-digit-lower
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII大文字~化:~INFRA#ascii-uppercase
~ASCII小文字~化:~INFRA#ascii-lowercase
~ASCII空白を読飛ばす:~INFRA#skip-ascii-whitespace
符号位置~並びを収集-:~INFRA#collect-a-sequence-of-code-points
頭部と尾部の~ASCII空白を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
頭部と尾部の~ASCII空白を剥いだ:~INFRA#strip-leading-and-trailing-ascii-whitespace
~commaで分割-:~INFRA#split-on-commas


文字大小区別:#case-sensitive
先頭一致:#prefix-match

White_Space 文字:#white_space
制御~文字:#control-characters


真偽~属性:#boolean-attribute
真偽~内容~属性:#boolean-attribute
列挙ed属性:#enumerated-attribute
妥当でない値に対する既定の状態:#invalid-value-default
値なしに対する既定の状態:#missing-value-default
妥当な整数:#valid-integer
整数として構文解析-:#rules-for-parsing-integers
妥当な非~負~整数:#valid-non-negative-integer
非~負~整数として構文解析-:#rules-for-parsing-non-negative-integers
妥当な浮動小数点数:#valid-floating-point-number
浮動小数点数として最良の表現:#best-representation-of-the-number-as-a-floating-point-number
浮動小数点数として構文解析-:#rules-for-parsing-floating-point-number-values
寸法~値として構文解析-:#rules-for-parsing-dimension-values
非~zero寸法~値として構文解析-:#rules-for-parsing-non-zero-dimension-values
妥当な浮動小数点数~list:#valid-list-of-floating-point-numbers
浮動小数点数~listとして構文解析-:#rules-for-parsing-a-list-of-floating-point-numbers
寸法~listとして構文解析-:#rules-for-parsing-a-list-of-dimensions
単純~色:#simple-colour
妥当な単純~色:#valid-simple-colour
妥当な小文字~単純~色:#valid-lowercase-simple-colour
単純~色として構文解析-:#rules-for-parsing-simple-colour-values
単純~色として直列化する規則:#rules-for-serialising-simple-colour-values
旧来の色~値として構文解析-:#rules-for-parsing-a-legacy-colour-value
空白区切りの~token集合:#set-of-space-separated-tokens
空白区切りの一意な~tokenからなる無順序~集合:#unordered-set-of-unique-space-separated-tokens
空白区切りの一意な~tokenからなる有順序~集合:#ordered-set-of-unique-space-separated-tokens

~comma区切りの~token集合:#set-of-comma-separated-tokens
妥当な~hash名~参照:#valid-hash-name-reference
~hash名~参照として構文解析-:#rules-for-parsing-a-hash-name-reference
妥当な媒体~query~list:#valid-media-query-list
利用者の環境に合致する:#matches-the-environment


	●URL / FETCH
~URL:~URLSpec#concept-url
~URL~record:~URLSpec#concept-url
絶対~URL:~URLSpec#absolute-url-string
~URL構文解析器:~URLSpec#concept-url-parser
~URL直列化器:~URLSpec#concept-url-serializer
妥当な~URL文字列:~URLSpec#valid-url-string

妥当かつ空でない~URL:#valid-non-empty-url
前後~空白~可の妥当な~URL:#valid-url-potentially-surrounded-by-spaces
前後~空白~可の妥当かつ空でない~URL:#valid-non-empty-url-potentially-surrounded-by-spaces
~fallback基底~URL:#fallback-base-url
文書~基底~URL:#document-base-url
相対的に構文解析-:#parse-a-url
結果の~URL~record:#resulting-url-record
結果の~URL文字列:#resulting-url-string

~CORS同一生成元:#cors-same-origin
~CORS非同一生成元:#cors-cross-origin
非安全~応答:#unsafe-response

Content-Type ~metadata:#content-type
~CORSになり得る要請を作成する:#create-a-potential-cors-request
meta 要素から符号化方式を抽出する:#algorithm-for-extracting-a-character-encoding-from-a-meta-element
~CORS設定群~属性:#cors-settings-attribute
~referrer施策~属性:#referrer-policy-attribute

	●属性
反映-:#reflect
反映:#reflect

既知の値のみに制限され:#limited-to-only-known-values
非~負数のみに制限され:#limited-to-only-non-negative-numbers
非~zero数に制限され:#limited-to-only-non-negative-numbers-greater-than-zero
~fallbackありの下で非~zero数に制限され:#limited-to-only-non-negative-numbers-greater-than-zero-with-fallback
正数に制限され:#limited-to-numbers-greater-than-zero

	limited to numbers greater than zero
	limited to only non-negative numbers greater than zero
	"all"-named要素:#all-named-elements
有index~prop:#dom-htmloptionscollection-setter

暗黙の強い参照:#implied-strong-reference



	●HTML5
新たな空option:#_new-blank-option
~IDか名前が一致する要素たち:#_matches-id-or-name

	＊生成元:~BROWSERS#concept-origin
作成元の基底~URL:~BROWSERS#creator-base-url
作成元~閲覧文脈:~BROWSERS#creator-browsing-context
子~閲覧文脈:~BROWSERS#child-browsing-context
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
閲覧文脈~容器:~BROWSERS#browsing-context-container

~API~URL符号化方式:~WAPI#api-url-character-encoding
~API基底~URL:~WAPI#api-base-url
	設定群~obj:~WAPI#settings-object
環境~設定群~obj:~WAPI#environment-settings-object
~event-loop:~WAPI#event-loop

DOCTYPE:~HTML-SYNTAX#syntax-doctype
~HTML構文:~HTML-SYNTAX#syntax
~XML構文:~HTML5/xhtml.html#the-xhtml-syntax

凍結~基底~URL:~HEmetadata#frozen-base-url
~hyperlink:~HTMLlinks#hyperlink

~iframe~srcdoc文書:~HTMLemb#an-iframe-srcdoc-document

~checkedness:~HTMLforms#concept-fe-checked
~listされる要素:~HEforms#category-listed


	●他
~list:~INFRA#list
包含-:~INFRA#list-contain
~size:~INFRA#list-size
~HTML名前空間:~INFRA#html-namespace

~XML~MIME型:~MIMESNIFF#xml-mime-type
~HTML~MIME型:~MIMESNIFF#html-mime-type
~MIME型:~MIMESNIFF#mime-type

被support~prop名を収集-:#_collect-supported-property-names

x.被support~prop~index:~WEBIDL#dfn-supported-property-indices
x.被support~prop名:~WEBIDL#dfn-supported-property-names
x.~IDL列挙~型:~WEBIDL#idl-enums
x.新たな有index~propの値を設定する:~WEBIDL#dfn-set-the-value-of-a-new-indexed-property
x.既存の有index~propの値を設定する:~WEBIDL#dfn-set-the-value-of-an-existing-indexed-property
x.~referrer施策:~REFERRER-POLICY#referrer-policy#referrer-policy
</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
FULLSCREEN:https://fullscreen.spec.whatwg.org/
HTML-SYNTAX:https://html.spec.whatwg.org/multipage/syntax.html

ACI:<a href="~INFRA#ascii-case-insensitive"><sub>大小無視</sub></a>
hrefM:href
nameM:name
nameO:name
nameF:name
namedItem0:namedItem
length0:length
this:<b class="js">this</b>
此れ:<b>これ°</b>
</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">
API::::
ASCII::::
CSP:
CSS:
CPU::::
DOM::::
HTML::::
HTTP::::
HTTPS::::
IDL::::
JS:JavaScript
MIME::::
UA:user agent:UA
UI::::
URL::::
Unicode::::
Web::::
WebIDL:Web IDL
WebSocket::::
WebVTT::::
XML::::

	ID:
	Object:
	Origin:
	PDF:
	CSS2:
	Color:
	Content-Type:
	Converting:
	DOCTYPE:
	Date:
	Document:
	JavaScript:
	Map:
	NaN:
	Content Security Policy:
	RFC:
	Radio:
	Set:
	Strict:
	System:
	ToString:
	White_Space
	XPath:
	ARIA
	Absolute
	Button
	IEEE
	MARK
	UTF-16
	UTF-8

	●DOM／event
ID:
target::::
task::::タスク
listener::::リスナ
handler::::ハンドラ
event::::イベント
event-loop:event loop:::イベントループ
shadow:
node::::ノード
空option:blank option:空 option
要素:element:~
comment::::コメント
木:tree::~::ツリー
入子の:nested:~
根:root::~::ルート
親:parent:~
子:child:~
子孫:descendant:~
先祖:ancestor:~
視野:scope::~

発火-:fire::~
伝播-:propagate:~
除去-:remove:~
除去:removing:~
前挿入-:pre-insert:~
挿入-:insert:~
挿入:insertion:~
付加-:append:~
置換-:replace:~
置換:replaced:~
接続-:connect::~
切断-:disconnect::~

文書:document:~
名前空間:namespace:~
変異-:mutate::~
属性:attribute:~
反映-:reflect::~
反映:reflection::~
列挙ed:enumerated:列挙
列挙:enumeration:~
値なし:missing value:~
継承-:inherit::~
隠蔽-:shadow::~

	前順, 深さ優先の走査:pre-order, depth-first traversal
	removedNode


	●CSS
font::::フォント
style::::スタイル
styling::::スタイル付け
stylesheet:style sheet:::スタイルシート
pixel::::ピクセル
size::::サイズ
呈示:presentation:~
媒体:media::~:メディア
	medium:~
寸法:dimension:~
疑似類:pseudo-class::疑似 class:疑似クラス

色:color:~
視覚的:visual:~
具現化-:render:~
具現化:rendering:~
百分率:percentage::~
表示:display:~
可視の:visible:~
不透明度:opacity:~
黒地透明:transparent black:~
空間:space:~
単位:unit:~


	●構文
scalar::::スカラー
hash::::ハッシュ
	hash-name
keyword::::キーワード
literal::::リテラル
surrogate::::サロゲート
comma::::カンマ
percent::::パーセント
	space::::
token::::トークン
backslash::::バックスラッシュ
escape::::エスケープ
record::::レコード
wrapper:
hex::16 進

区切りの:-separated:~
空白区切りの:space-separated:~
空白:whitespace:~
読飛ばす:skip する:読み飛ばす
分割-:split:~
	区切られ-:separate:~
区切子:delimiter:~
	-:truncate
	削る:truncate
	切捨てて:truncate して:~
	単語:word:~
厳密に:strict に:~
実数:number:~
数字:digit:~
小数:fraction:~
整数:integer:~
文字:character:~
文字列:string:~
文字大小:case:~
文字大小区別:case-sensitive:~
	文字大小区別の有無:case-sensitivity:~
大小無視:case-insensitive:~
大文字:uppercase:~
小文字:lowercase:~
仮数:significand:~
基数:base:~
	基数 10:base-ten:~
基本多言語面:basic multilingual plane::~
妥当な:valid:~
妥当:valid:~
	妥当でない:invalid:~
指数:exponent:~
浮動小数点:floating-point:~
浮動小数点数:floating-point number:~
除数:divisor:~

文法:grammar:~

小構文:microsyntax::~
尾部:trailing:~
頭部:leading:~
	無用な文字~並び:garbage
	Advance position to the next character
	close-parenthesis:
	micro-parser:

符号単位:code unit::~
符号位置:code point::~

符号:sign:~
有符号:signed:~
無符号:unsigned:~

構文:syntax::~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ

直列化-:serialize::~::シリアライズ
直列化:serialization::~::シリアル化
	直列化:serialized:~
直列化器:serializer::~::シリアライザ

符号化-:encode::~::エンコード
符号化方式:encoding::~::エンコーディング
label::::ラベル
復号-:decode::~::デコード

収集-:collect:~
収集:collection:~
抽出-:extract:~
合致-:match:~
生成規則:production:~

剥ぐ:strip する:~
剥いだ:strip した:~
連結-:concatenate:~
連結:concatenation:~
連続する:consecutive:~
	並び:sequence:~
位置:position:~
倍精度:double-precision:~
正準的な:canonical:~
	正規化済みの:normalized:~

	●network／fetch／URL
fetch:
fetching:::fetch 処理
header:
close:
address::::アドレス
url::::
資格証:credentials::資格証明情報::クレデンシャル

query::::クエリ
host::::ホスト
navigate::::ナビゲート
navi:navigation:::ナビ
network::::ネットワーク
protocol::::プロトコル
server::::サーバ
CORS::::
	potential-CORS
	CORS-cross-origin
	CORS-same-origin
相対:relative::~
絶対:absolute::~
相対的:relative::~
	＊生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン
非同一生成元:cross-origin::~::クロスオリジン
行先:destination::~
表現-:represent:~
表現:representation:~
要請:request::~::リクエスト
応答:response::~::レスポンス
解決不能な:unresolvable:~
資源:resource::~:リソース
下位資源:subresource::~:下位リソース
遠隔操作の:remote::~::リモート
送達-:deliver:~
送信-:send:~

	●処理
	multitasking, fibers, threads, processes
	hyperthread, core, CPU, machine
native::::ネイティブ
instance::::インスタンス
snapshot::::スナップショット
zero::::ゼロ
bit::::ビット
byte::::バイト
octet::::オクテット
class::::クラス
code::::コード
collection::::コレクション
flag::::フラグ
block::::ブロック
interface::::インタフェース
live::::
error::::エラー
list::::リスト
nullable::::
obj:object:::オブジェクト
pointer::::ポインタ
primitive::::プリミティブ
read-only::::
read-write::::
typedef::::
garbage::::ガーベジ
stack::::スタック
logic::::ロジック
algo:algorithm:::アルゴリズム
阻止-:block::~::ブロック
call::::
callback::::
script::::スクリプト
scripting::::スクリプト処理
処理-:process:~
処理:processing:~
入力:input:~
初期化-:initialize:~
内部:internal:~
内部的な:internal:~
再帰的:recursive:~
失敗-:fail:~
失敗:failure:~

変換-:convert:~
変換器:converter:~
動作-:act:~
動的:dynamic:~
協調的:cooperative:~
即時に:immediate に:~
変数:variable:~
変更-:change:~
変化:changes:~
変化-:change:~
上書き:override:~

再開-:resume:~
例外:exception:~
	継続-:continue:~

呼出す:invoke する:呼び出す
呼出した:invoke した:呼び出した
呼出して:invoke して:呼び出して
呼出され:invoke され:呼び出され
被呼出時:被 invoke 時:~
取得-:get:~
	取得ing:getting:~
取得子:getter:~
設定子:setter:~
設定-:set:~
設定群:settings:~
走らせ:run し:~
走らす:run する:走らせる
透過的:transparent:~
	返す:return:~
並列的:parallel:~
中断-:interrupt:~
中止-:abort:~
事由:reason:~
段:step:~
新たな:new:~
	新たに:newly:~
投出:throw:~
停止-:stop:~

演算-:operate:~
演算:operation:~
情報0:signal:情報

	●仕様
app:application:::アプリ
model::::モデル
module::::モジュール
version::::バージョン
	同様に:similarly:~
同義:synonymous:~
同義語:synonym:~
	与-:give:~
	両者:both:~
	前者:former:~
	後者:latter:~
一定の:certain:~
一般:general:~
主体:party:~
予期-:expect:~
予期せず:unexpected に:~
予約済み:reserved:~
事例:case:~
互換:compatible:~
	-compatible
互換性:compatibility:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
理由:reason:~
作者:author:~

依存-:depend:~
依存関係:dependencies:~
保全-:preserve:~
保持-:hold:~
修復-:fixup:~
側面:aspect:~
傾向:tend:~
公式化:formalize:~
公式的:official:~
共通の:common:~
共通的に:common に:よく
判定基準:criteria:~
	別個の:distinct:~
	利用-:use:~
利用者:user:~
制御:control:~
制約:restriction:~
制約-:restrict:~
制限-:limit:~
単純化:simplicity:~
危険に:dangerous に:~
取扱う:handle する:取り扱う
取扱わず:handle せず:取り扱わず
取扱われ:handle され:取り扱われ
取扱い:handling:取り扱い
可能0:possible:可能
受容-:accept:~
可用:available:~
可読性:readability:~
各種用語:terminology:~
含意-:imply:~
多義的:ambiguous:~
奨励-:encourage:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
実際:actual:~
	容易:ease:~
	対応-:correspond:~
尊守-:honor:~
導入-:introduce:~
導出-:derive:~
廃用:obsoleted:~
廃用に:obsolete:~
強く:strong に:~
影響-:affect:~
影響0:impact:影響
所与の:given:与えられた
手段:means:~
手続き:steps:~
下位手続き:substeps:~
指名-:designate:~
指定-:specify:~
指定:specified:~
指示-:indicate:~
挙動:behavior:ふるまい
提供-:provide:~
最良の:best な:~
有意義な:meaningful:~
方式:manner:~
既存の:existing:~
既定の:default:~
既定:default:~
既知の:known:~
日付:date:~
旧来の:legacy:~
明示的:explicit:~
定めら:state さ:~
	明記
	明白:clear:~
検分-:examine:~
検証-:validate:~
概して:typical に:~
正確:exact:~

標準:standard:~
機会:chance:~
正しく:correct に:~
歴史的:historical:~
無視-:ignore:~
混同-:confuse:~
永続的:permanent:~
汎用:generic:~
決定-:determine:~
決定法:determining:~
決断:decision:~
注意深く:careful に:~
	特に:specifically:~
	特段の注意を払うtake extreme care:
特別:special:~
特定0の:particular:ある特定の
特有:-specific:~
特定の:specific:~
特権:privilege:~
特色機能:feature:~
目的0:purpose:目的
督促-:urge:~
確立-:establish:~
禁制-:prohibit:~
移行:migration:~
考慮-:consider:~
見なす:consider する:~
見なして:consider して:~
見なされ:consider され:~
複雑さ:complexity:~
要件:requirements:~
要求-:require:~
見做して:assume して:~
達成-:achieve:~
違反:violation:~
適切:appropriate:~
適合-:conform:~
適合:conforming:~
適合性:conformance:~
適用-:apply:~
適用可能:applicable:~
選好-:prefer:~
関係-:relate:~
	関係性:relationship:~
関連する:relevant:~
規範的:normative:~
解釈-:interpret:~
許容-:allow:~
第三者主体:third-party:~
状況:situation:~
狭義の:narrower:~
用語:term:~
意味-:mean:~
意味:meaning:~
意味論:semantics:~:::セマンティクス
暗黙の:implied:~
暗黙的:implicit:~
拡張:extension:~
拡張性:extensibility:~
文献:literature:~
必須:critical:~
必須の:critical:~
絶対必要:imperative:~
経験則:heuristics:~
整合する:consistent な:~
有用:useful:~
寄与-:contribute:~
概念:concept:~

	●未分類（動詞
読取る:read する:読み取る
検査-:check:~
選択-:select:~
選択:selection:~
操作-:manipulate:~
closed:
access::::アクセス
check::::チェック
	~checked
挙動する:behave する:ふるまう
変異:mutation:~
指紋収集:fingerprinting::~
	fingerprinting vector:指紋収集の~~手段
sandbox::::サンドボックス
scroll::::スクロール
保安化-:secured に::~:セキュアに
保安上の:security::~:セキュリティ

support::::サポート
消毒:sanitization::~
	混在させて~mixして
在する:present する:在る
	不在:absence:~
	不在:absent:~
不能化-:disable:~
不能化:disabled:~
可能化:enabled:~
削除-:delete:~
算出-:compute:~
共有-:share:~
	共有できない:unsharable:~
内側:inside:~
内容:content:~
凍結:frozen:~
包含-:contain:~
地域化-:localize:~
増やす:increase する:~
	変更点:changes:~
存在-:exist:~
存在0:presence:存在
実行-:execute:~
実行:execution:~
参照:reference:~
比較-:compare:~
比較:comparison:~
比較法:comparing:~
更新-:update:~
構造:structure:~
有構造:structured::~
登録-:register:~
登録済みの:registered:~
登録:registration:~
意図-:intend:~
派生-:derive:~
減算:subtract:~
	渡-:pass:~
	-:past する
相互作用-:interact:~
	やりとり
相互作用:interaction:~
	類する:analogous:~
相違-:differ:~
省略-:omit:~
	省略可:optional:~
組込みの:built-in:~
	結付け:association:~
結付けら:associate さ:結び付けら
被support:supported::被 support:被サポート
記述-:describe:~
記述:description:~
認識-:recognize:~
	論じ:discuss:~
識別-:identify:~
識別子:identifier:~
走査:traversal:~
追加-:add:~
追加の:additional:~
開始-:start:~
起動-:launch:~
見出す:find する:~
見出した:find した:~
見出され:find され:~
検知:detection:~
判別-:distinguish:~
作成-:create:~
作成:creation:~
作成元:creator:~

	●未分類
member::::メンバ
item::::アイテム
native::::ネイティブ
red:
green:
blue:
alpha:
animation::::アニメーション
boolean::::
bitmap::::ビットマップ
browser::::ブラウザ
caption::::キャプション
chapter::::チャプター
channel::::チャンネル
checkedness::::チェック有無
checkbox::::チェックボックス
radio-button:radio button:::ラジオボタン
link::::リンク
	列目:column
cue::::
custom::::カスタム
data::::データ
day::::
fallback::::フォールバック
file::::ファイル
下層の:underlying:~


graphics::::グラフィックス
prop:property:::プロパティ
home::::
hyperlink::::ハイパーリンク
iframe::::
index::::
	index:indices
inline::::インライン
	instance化:instantiate
	instant::::
library::::ライブラリ
	~low::::
mark::::
memory::::
metadata::::メタデータ
method::::メソッド
mode::::モード
multimedia::::マルチメディア
offset::::オフセット
origin-clean:
pattern::::パタン
platform::::プラットフォーム
web:
plugin::::プラグイン
referrer::::リファラ
施策:policy::~:ポリシー
pop-up-window:pop-up window:::ポップアップウィンドウ



	~readiness:
role:
	sRGB
	-:sort
	across
	missing
	mix
	point
	open
	optionally
	outline
	part
	middle
	trimming
	÷ 1000 ÷ 1000:millionth
	ミリ秒:milliseconds
	table
	template::::
	time::::

sniff::::
software::::ソフトウェア
source::::ソース
srcdoc:
status:
stream::::ストリーム
subtitle::::サブタイトル
tag::::タグ
text::::テキスト
binary::::バイナリ
touch::::タッチ
	text的:textual#1
title::::タイトル
tool::::ツール
media-track:media track:::メディアトラック
特殊:special:~
	~~適正な~viable::::
動画:video::~::ビデオ
	動画:movie
音声:audio::~::オーディオ
view::::ビュー
viewer::::ビューア
week-number::::
week::::
抽象演算:abstract operation:~
	Desc:
局所:local::~::ローカル
大域的:global::~::グローバル
	＊全部的な:full:~
文脈:context:~
部品:component:~
時刻:time:~
	大きく変わる:greatly vary
真偽:boolean:~
名:name:~
名前:name:~
値:value:~
名値:name-value:名値
pair::::ペア
不可分:atomic:~
一意:unique:~
一意な:unique:~
	一部:part-of:~

候補:candidate:~

	全~screen:fullscreen:~
	再度:again:~
単純:simple:~
同一性:identity:~
圧縮:compression:~
型:type:~
基底:base:~
基本:basic:~
外部:external:~
容器:container:::コンテナ
対応関係:mapping:~
引数:argument:~
強い:strong:~

形式:format:~
	後続の:subsequent:~



成分:component:~
	所-:place:~
	早い:earlier:~
	時間を共有する:time-sharing:~
有index:indexed::有 index
有名:named:~
有限:finite:~
順序:order:~
無順序:unordered::~
有順序:ordered:~
状態:state:~
現在:currently:~
現在の:current:~
環境:environment:~
画像:image:~
疎な:sparse::~

直接的:direct:~
	秒:second:~
時間帯:time-zone:~
暦:calendar:~

種別:type:~
空:empty:~

等価:equivalent:~
範囲:range:~
精確:precise:~
終端:end:~


脆弱性:vulnerabilities:~
自前の:own:~
自動的:automatic:~
	自身:itself:~
規則:rule:~
言語:language:~
言語束縛:language binding:~
読取専用:read-only:~
	負数:negative number
	正数:numbers greater than zero
	負:negative:~
重複:duplicate:~
長さ:length:~
関数:function:~
閲覧文脈:browsing context:~

集合:set:~
安全:safe:~
非安全:unsafe:~
多彩な:rich:~
本格的な:fully-fledged:~
静的な:static:~
小論:essay:~
報告書:report:~
対話的:interactive:~
	ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications
	知識を有さない~unbeknownst:
	成句的な~idiom:
詳細:details:~
	供-:supply
	毎回:periodic

	●
	~beginning:
	能力を有する~capable:
	~categorize:
	prototype chain
	~counterpart:
	~cross-boundary:
	~drop:
	~duration:
	~early:
	~ending:
	~got:
	~high:
	言及-:mention:
	month:
	~negated:
	~oldParent:
	potentially surrounded by space:
	~pre-existing:
	qualified:
	raw:

	~regular:
	~remaining:
	各:each:~
	合間:between:~
	同じ:same:~
	除-:except:~
	対にされてない:isolated:~
	多い:often:~
	記し方~style~s
	概要Brief description
	文字大小を保全する~case-preserving
	指す~point
	後:after:~
	後続-／従う:follow:~
	得-:obtain:~
	必要-:need:~
	必要とされ:necessary:~
	~~選択的に組み込める~opt
	具体的には~for~instance
	更なる:further:~
	最も小さい:smallest:~
	最初の:first:~
	最後の:last:~
	混み入った:complicated:~
	異なる:different:~
	知られ
	短い:short:~
	等々:etc:~
	等し:equal:~
	等しく:equally:~
	節:section:~
	結果:result:~
	結果の:resulting:~
	見よ:see:~
	通:through:~
	起こる:happen:~
	示す:show:~
	種々の:various:~
	次0:next:~
	正確0:accurate:正確
	類似する
	類似的:similar:~
	逆にas opposed to
	指す:refer する:~
	扱う:treat:~
	扱われ:treated:~
	常に:always:~
	広く:widely:~
	孕む／得る:involve:~
	場合によっては:possibly:~
	含-:include:~
	含めて:including:~
	:four:~
	別の:another:~
	3 個:three:~
	上:above:~
	top:~
	下:below:~
	2 個／二つ:two:~
	個目:second／third／fifth
	今や:now:~
	他の:other:~
	他の場合:otherwise:~
	以前の:previous:~
	任意の／恣意的な:arbitrary:~
	何か:something:~
	例:example:~
	依然として:still:~
	元の:original:~
	前:before:~
	昔風の:non-fashionable retro


	~~分類:category:~
	~~区別:distinction
	~~可能性が高い:likely:~
	~~実際:indeed:~
	~~意図:meant:~
	〜に基づく:based:~
	〜の代わりに:instead:~
	あてがわれ:assign:~
	いくつかの:several:~
	この:this:~
	これらの:these:~
	させなく:prevent:~
	しかしながら，:however:~
	したがって:thus:~
	すでに:already:~
	すべての:all:~
	その:that:~
	そのような:such:~
	それら:they:~
	それらの:their:~
	それらの:those:~
	それら自身:themselves:~
	べき:should:~
	
		満たない~fewer:#1
	少数の~few:#1
	~~由来する~inspire
	にもかかわらず，~nonetheless:#2
	関わらず~regardless
	に関する~regard:#5
	に関する~regarding:#3
	偏向されbiased toward
	略称~abbreviated:#1
	に則って~according:#17
	特段の~extreme
	数えられ~count
	~few:
	~fewer:
	~fit:
	~followed by:
	~greater:
	~greatly:
	~having:
	~furthest:
	~leaving:
	~left:
	~opt:
	~orphaned:
	~passing:
	~pointing:
	regard:
	regarding:
	regardless:
	~respective:
	~retrieve:
	~said:
	~say:
	~series:
	~sniff:
	~sometime:
	~started:
	~substep:
	~surrounded:
	~using:
	~vary:
	辿る:walk
	~zero-padding:
	rounded-value:

</script>


<!--%style -->
<style type="text/css">
*[lang="en"] {
	white-space: pre-line;
}

.js {
	color: green;
}

</style>

</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Standard — Common infrastructure 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Common infrastructure</a>
章を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-02-16</time>
（公開：<time>2016-01-28</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">

	<hgroup>
<h1>共通基盤 — Common infrastructure</h1>
<h2>HTML Living Standard — 最終更新 2017 年 2 月 15 日</h2>
	</hgroup>

</header>

<main id="MAIN" style="display:none;">

<section id="infrastructure">
<h1 title="Common infrastructure">2. 共通基盤</h1>

	<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
“ε” と記される特殊~値は、存在しないことを表現し，自身以外のどの値とも異なる値として用いられる。
</p>

<p>
この仕様が定義する一部の構文解析器で利用される %位置↗ という表記は、
%位置 が指す文字を表す（詳細は`位置~変数$を参照されたし）。
</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">2.1. 各種用語</h2>

<p>
この仕様は、同じ文脈~内で［
~HTML／~XML
］属性, および~IDL属性（ ~IDL~interfaceに定義される属性）の両者を指すことが多い。
どちらを指すか明白でない所では、［
~HTML／~XML
］属性を指すときは
`内容~属性@
と記され、~IDL属性を指すときは
`~IDL属性@
と記される。
同様に、用語 “~prop” も［
~JS~obj~prop, ~CSS~prop
］の両者に利用される。
多義的になる所では、順に
`~obj~prop^dfn,
`~CSS~prop^dfn
と記される。
◎
This specification refers to both HTML and XML attributes and IDL attributes, often in the same context. When it is not clear which is being referred to, they are referred to as content attributes for HTML and XML attributes, and IDL attributes for those defined on IDL interfaces. Similarly, the term "properties" is used for both JavaScript object properties and CSS properties. When these are ambiguous they are qualified as object properties and CSS properties respectively.
</p>

<p>
一般に、仕様にて，ある特色機能を［
`~HTML構文$, `~XML構文$
］のいずれかに適用するよう定められる所では、他方も含まれる。
特色機能を，この二つの言語の片方にのみ特に適用する所では、次のように，他方の形式には適用されないものと定められる
⇒
“~HTML に対しては、 ... （これは~XMLには適用されない）”。
◎
Generally, when the specification states that a feature applies to the HTML syntax or the XML syntax, it also includes the other. When a feature specifically only applies to one of the two languages, it is called out by explicitly stating that it does not apply to the other format, as in "for HTML, ... (this does not apply to XML)".
</p>

<p>
この仕様における用語
`文書@
は、~HTMLの~~任意の利用を指す
— 短い静的な文書から 多彩な~multimediaを伴う長い小論や報告書，更には本格的な対話的~appまでににわたるような。
この用語は、文脈に依存して［
`文書$0とその 子孫~DOM木,
］, ［
`~HTML構文$ ／ `~XML構文$ を利用して直列化された~byte~stream
］のいずれかを指す：
◎
This specification uses the term document to refer to any use of HTML, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications. The term is used to refer both to Document objects and their descendant DOM trees, and to serialized byte streams using the HTML syntax or the XML syntax, depending on context.
</p>

<ul>
	<li>
~DOM構造の文脈における用語
`~HTML文書$ ／ `~XML文書$
は、~DOM仕様 `DOM$r にて定義される，二つの異なる~modeを指す。
`文書$0は、このいずれかの~mode下に属する。
（そのような利用は、常にその定義に~hyperlinkされる）
◎
In the context of the DOM structures, the terms HTML document and XML document are used as defined in the DOM specification, and refer specifically to two different modes that Document objects can find themselves in. [DOM] (Such uses are always hyperlinked to their definition.)
</li>
	<li>
~byte~streamの文脈における用語［
~HTML文書 ／ ~XML文書
］は、［
`~HTML~MIME型$ ／ `~XML~MIME型$
］の資源を指す。
◎
In the context of byte streams, the term HTML document refers to resources labeled as text/html, and the term XML document refers to resources labeled with an XML MIME type.
</li>
</ul>

<hr>

<p>
~~記述を単純にするため、利用者~向けに文書を具現化する仕方を指す際に［
“示される（ shown ）” ／ “表示される（ displayed ）” ／ “可視の（ visible ）”
］などの語が利用されることもある。
これらの用語は、視覚的~媒体のみを含意するものではなく、他の媒体にも，等価な仕方で適用されるものと見なされ~MUST。
◎
For simplicity, terms such as shown, displayed, and visible might sometimes be used when referring to the way a document is rendered to the user. These terms are not meant to imply a visual medium; they must be considered to apply to other media in equivalent ways.
</p>

<p>
ある~algo %A が~algo %B を~callしている下で，~algo %B にて［
~RET ／ “〜を返す”
］と記された所では、実装は， %A において %B を~callした所から継続し~MUST。
◎
↓</p>

<p>
一部の~algoにおいては、［
`並列的に@
走らす
］と記される所がある
— これは、その~algoの後続の手続きを，仕様~内の他の~logic（例えば `~event-loop$）と同時並行的に走らすことを意味する。
この仕様は、これが達成される精確な仕組みは定義しない
— 例えば、時間を共有する協調的［
multitasking, fibers, threads, processes
］, あるいは異なる［
hyperthread, core, CPU, machine
］の利用, 等々。
対照的に、
`即時に@
走らすような演算は、現在~走らせている~taskを中断して,
その演算を走らせ終えてから, 中断した~taskを再開し~MUST。
◎
When an algorithm B says to return to another algorithm A, it implies that A called B. Upon returning to A, the implementation must continue from where it left off in calling B. Some algorithms run in parallel; this means that the algorithm's subsequent steps are to be run, one after another, at the same time as other logic in the specification (e.g. at the same time as the event loop). This specification does not define the precise mechanism by which this is achieved, be it time-sharing cooperative multitasking, fibers, threads, processes, using different hyperthreads, cores, CPUs, machines, etc. By contrast, an operation that is to run immediately must interrupt the currently running task, run itself, and then resume the previously running task.
</p>

<p>
用語 “黒地透明” は、
( ~red, ~green, ~blue, ~alpha )
各~channelがすべて 0 にされた色を指す。
◎
The term "transparent black" refers to the color with red, green, blue, and alpha channels all set to zero.
</p>



		<section id="resources">
<h3 title="Resources">2.1.1. 資源</h3>

<p>
資源に対する用語
`~support^dfn
される, 〜されている, 〜する, 等々は、~UAの実装が当の外部~資源の意味論を復号する能力を有することを指す。
実装は、外部~資源の［
形式／型
］を，その形式／型において必須とされる側面を無視することなく処理できるならば、~supportするという。
特定の資源が~supportされるかどうかは、その資源の形式に備わる どの特色機能が利用-中にあるかにも依存し得る。
◎
The specification uses the term supported when referring to whether a user agent has an implementation capable of decoding the semantics of an external resource. A format or type is said to be supported if the implementation can process an external resource of that format or type without critical aspects of the resource being ignored. Whether a specific resource is supported can depend on what features of the resource's format are in use.
</p>

<p class="example">
例えば PNG 画像は、その~pixel~dataを復号して具現化できるならば、その画像に，実装が知識を有さない~animation~dataが包含されていたとしても、~supportされる形式と見なされるであろう。
◎
For example, a PNG image would be considered to be in a supported format if its pixel data could be decoded and rendered, even if, unbeknownst to the implementation, the image also contained animation data.
</p>

<p class="example">
実装は、 MPEG-4 動画~fileの~metadataから動画の寸法を決定できたとしても，利用されている圧縮~形式を~supportしないならば、その形式を~supportするとは見なされないことになる。
◎
An MPEG-4 video file would not be considered to be in a supported format if the compression format used was not supported, even if the implementation could determine the dimensions of the movie from the file's metadata.
</p>

<p>
一部の他の仕様
— 特に~HTTP仕様 —
において `表現^i （ representation ）と称されるもの
`<a href="~RFC7231#section-3" >参照先</a>^tnote
は、この仕様では
`資源@
と称される。
`HTTP$r
◎
What some specifications, in particular the HTTP specification, refer to as a representation is referred to in this specification as a resource. [HTTP]
</p>

<p>
資源の
`必須の下位資源@
とは、その資源を正しく処理するためには，可用になる必要がある資源である。
どの資源が必須（ critical ）と見なされるかは、当の資源の形式を定義する仕様により定義される。
◎
A resource's critical subresources are those that the resource needs to have available to be correctly processed. Which resources are considered critical or not is defined by the specification that defines the resource's format.
</p>

		</section>
		<section id="xml">
<h3 title="XML compatibility">2.1.2. ~XMLとの互換性</h3>

<p id="html-namespace">
~HTMLから~XMLへの移行を容易にするため、この仕様に適合している~UAは、少なくとも ~DOM／~CSSの目的0において，~HTMLにおける要素を
`~HTML名前空間$（
`http://www.w3.org/1999/xhtml^l
）に属させることになる。
この仕様の用語
`~HTML要素@
は、その名前空間に属する~~任意の要素を指す
— 要素が~XML文書~内にある場合でも。
◎
To ease migration from HTML to XML, UAs conforming to this specification will place elements in HTML in the http://www.w3.org/1999/xhtml namespace, at least for the purposes of the DOM and CSS. The term "HTML elements", when used in this specification, refers to any element in that namespace, even in XML documents.
</p>


<div class="p">
<p>
他から定められない限り、この仕様に現れる：
</p>

<ul>
	<li>
どの要素も， `~HTML名前空間$に属する。
</li>
	<li>
どの属性も，属する名前空間はない。
</li>
</ul>

◎
Except where otherwise stated, all elements defined or mentioned in this specification are in the HTML namespace ("http://www.w3.org/1999/xhtml"), and all attributes defined or mentioned in this specification have no namespace.
</div>

<div class="p">
<p>
用語
`要素~型@
とは、［
所与の局所~名を持つ, かつ
所与の名前空間に属する
］ような要素からなる集合を指す。
例えば `button$e 要素の要素~型は `button$e であり、次を意味する：
</p>

<ul>
	<li>
その局所~名は `button^l である，かつ
</li>
	<li>
（上述にて暗黙的に定義したように） `~HTML名前空間$に属する。
</li>
</ul>

◎
The term element type is used to refer to the set of elements that have a given local name and namespace. For example, button elements are elements with the element type button, meaning they have the local name "button" and (implicitly as defined above) the HTML namespace.
</div>


<div class="p">
<p>
次を満たす属性~名は、
`~XML互換@
とされる：
</p>

<ul>
	<li>
`XML$r にて定義される `Name$p 生成規則に合致する，かつ
</li>
	<li>
❝: は包含しない。
</li>
</ul>

◎
Attribute names are said to be XML-compatible if they match the Name production defined in XML and they contain no U+003A COLON characters (:). [XML]
</div>


		</section>
		<section id="dom-trees">
<h3 title="DOM trees">2.1.3. DOM 木</h3>


<p>
要素または属性
が［
`無視される@
／
何か他の値として扱われる ／
それが他の何かであったかのように取扱われる
］ものと定められる所は、［
当の~nodeが~DOM内にある後における~nodeの処理
］のみを指す。
~UAは、そのような状況において~DOMを変異させては~MUST_NOT。
◎
When it is stated that some element or attribute is ignored, or treated as some other value, or handled as if it was something else, this refers only to the processing of the node after it is in the DOM. A user agent must not mutate the DOM in such situations.
</p>

<p>
内容~属性が所与の値 %V に
`変更される／変化した^dfn
と記されるのは、
%V が元の値と異なる場合に限られる
— 属性に その元の値と同じ値を設定しても，それは変化しない。
◎
A content attribute is said to change value only if its new value is different than its previous value; setting an attribute to a value it already has does not change it.
</p>

<p>
［
属性~値 ／
`Text$I ~node ／
文字列
］に対し利用される用語
`空^dfn
は、~textの長さが 0 であることを意味する（すなわち、~ASCII空白や`制御~文字$も包含しない）。
◎
The term empty, when used for an attribute value, Text node, or string, means that the length of the text is zero (i.e. not even containing spaces or control characters).
</p>

<p>
要素の
`子~text内容@
は、要素の子である `Text$I ~nodeすべての`~data$を，~nodeの`木~順序$で連結した結果である（ ~commentや要素など，他種の~nodeは無視する）。
◎
An element's child text content is the concatenation of the data of all the Text nodes that are children of the element (ignoring any other nodes such as comments or elements), in tree order.
</p>

<div class="p">
<p>
所与の~node %A, %B に対し：
</p>

<ul>
	<li>
%A が %B の中へ
`挿入される@node
とは、
( ~node %A, 新たな親 %B )
を引数に`挿入-時の手続き$が呼出されることをいう。
</li>
	<li>
逆に，
%A が %B から
`除去される@node
とは、
( 除去される~node %A, ~nodeの元の親 %B )
を引数に`除去-時の手続き$が呼出されることをいう。
</li>
</ul>

◎
A node A is inserted into a node B when the insertion steps are invoked with A as the argument and A's new parent is B. Similarly, a node A is removed from a node B when the removing steps are invoked with A as the removedNode argument and B as the oldParent argument.
</div>


<div class="p">
<p>
所与の~node %N に対し：
</p>

<ul>
	<li>
<p>
%N は
`文書~内に挿入された@
とは
⇒
%N は`文書~木~内$にない下で、
%N を引数に`挿入-時の手続き$が呼出され，
%N は`文書~木~内$にあるようになったことをいう。
</li>
	<li>
%N は
`文書から除去された@
とは、逆に
⇒
%N は`文書~木~内$にある下で、
%N を引数に`除去-時の手続き$が呼出され，
%N は`文書~木~内$にないようになったことをいう。
</li>
</ul>

<p class="trans-note">【
~nodeが元々`文書~木~内$にあったとしても，
“挿入し直される”
ような処理-時には、除去-, 挿入- 2 つの~eventが連続して生じるかもしれない。
】【
この定義が、変化させる手段も含めているのか，［
単に，状態の変化のみに基づくものであって、状態を変化させる手段は述べられたものに限られる
］ことを述べているのか、判別できない。
下の定義も同様。
】</p>

◎
A node is inserted into a document when the insertion steps are invoked with it as the argument and it is now in a document tree. Analogously, a node is removed from a document when the removing steps are invoked with it as the argument and it is now no longer in a document tree.
</div>


<div class="p">
<p>
所与の~node %N に対し：
</p>

<ul>
	<li>
%N は
`接続された@
（ becomes connected ）とは
⇒
%N は`接続されて$いない下で、
%N を引数に`挿入-時の手続き$が呼出され，
%N は`接続されて$いるようになったことをいう。
</li>
	<li>
%N は
`切断された@
（ becomes disconnected ）とは、逆に
⇒
%N は`接続されて$いる下で、
%N を引数に`除去-時の手続き$が呼出され，
%N は`接続されて$いないようになったことをいう。
</li>
</ul>

<p class="trans-note">【
~nodeが元々`接続されて$いたとしても，
“接続し直される”
ような処理-時には、切断-, 接続- 2 つの~eventが連続して生じるかもしれない。
】</p>

◎
A node becomes connected when the insertion steps are invoked with it as the argument and it is now connected. Analogously, a node becomes disconnected when the removing steps are invoked with it as the argument and it is now no longer connected.
</div>


<div class="p">
<p>
所与の~node %N に対し：
</p>

<ul>
	<li>
<p>
%N は
`閲覧文脈に接続されて@
いるとは、 %N が次を満たすことをいう：
</p>

<ul ><li>%N は`接続されて$いる~AND
</li><li>%N の`~shadowも含む根$が`属する閲覧文脈$ ~NEQ ε
</li></ul>
</li>
	<li>
%N は
`閲覧文脈に接続された@
（ becomes browsing-context connected ）とは
⇒
%N は`閲覧文脈に接続されて$いない下で、
%N を引数に`挿入-時の手続き$が呼出され，
%N は`閲覧文脈に接続されて$いるようになったことをいう。
</li>
	<li>
%N は
`閲覧文脈から切断された@
（ becomes browsing-context disconnected ）とは、逆に
⇒
%N は`閲覧文脈に接続されて$いる下で、［
%N を引数に`除去-時の手続き$が呼出された
］か, または［
%N の`~shadowも含む根$が`属する閲覧文脈$ ~EQ ε
］になった結果，
%N は`閲覧文脈に接続されて$いないようになったことをいう。
</li>
</ul>

◎
A node is browsing-context connected when it is connected and its shadow-including root has a browsing context. A node becomes browsing-context connected when the insertion steps are invoked with it as the argument and it is now browsing-context connected. A node becomes browsing-context disconnected either when the removing steps are invoked with it as the argument and it is now no longer browsing-context connected, or when its shadow-including root no longer has a browsing context. 
</div>



		</section>
		<section id="scripting-2">
<h3 title="Scripting">2.1.4. ~scripting</h3>

<p>
所与の~interface `Foo^I に対する句
“`Foo^I ~obj”
は、
“~interface `Foo^I を実装している~obj”
の略記である。
◎
The construction "a Foo object", where Foo is actually an interface, is sometimes used instead of the more accurate "an object implementing the interface Foo".
</p>

<p class="trans-note">【
`Foo^I を継承する~interfaceを実装している~objも含まれる。
】</p>


<div>
<p>
~IDL属性に対し、（例えば作者~scriptから）［
その値を得ようと／新たな値をあてがおうと
］~~試みられるときの挙動を記すときは、［
`取得子は…^dfn ／
`設定子は…^dfn
］のように表記される。
</p>

<p class="trans-note">【
“~~取得子（ ...’s getter ）” は，原文では “On getting, ...” 
（訳すなら “被取得時” ）であるが、同じ文脈で前者の getter も利用されている。
設定子（ “...’s setter” ／ “On setting, ...” ）についても同様。
~web~platform全般にわたり，この 2 種類のどちらで表記しても特に違いはない／区別を要する箇所はないと見られるので、和訳では “取得子”, “設定子” の表記に統一している。
】【
~IDL~methodにおける対応する表記（ “..., when invoked, ...” ）は、
“被呼出時には…”
と記される。
】</p>

◎
An IDL attribute is said to be getting when its value is being retrieved (e.g. by author script), and is said to be setting when a new value is assigned to it.
</div>

<p>
`~liveである@
とされた~DOM~objに対しては、その~obj上の［
属性, ~method
］は、~dataの~snapshotではなく，実際の
`すなわち，現在の^tnote
下層の~dataに対し演算され~MUST。
◎
If a DOM object is said to be live, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.
</p>

		</section>
		<section id="plugins">
<h3 title="Plugins">2.1.5. ~plugin</h3>

<p>
用語
`~plugin@
は、~UAが利用し，~UAにより定義される内容~handlerであって、~UAによる
`文書$0の具現化の一部をなし得るが，［
`文書$0の`子~閲覧文脈$として動作する
］ことも, ［
`文書$0の~DOMに `Node$I ~objを導入する
］こともないものを指す。
◎
The term plugin refers to a user-agent defined set of content handlers used by the user agent that can take part in the user agent's rendering of a Document object, but that neither act as child browsing contexts of the Document nor introduce any Node objects to the Document's DOM.
</p>

<p>
そのような内容~handlerは、概して
第三者主体から提供される
— ~UAも，自身に組込みの内容~handlerを~pluginとして指名できるが。
◎
Typically such content handlers are provided by third parties, though a user agent can also designate built-in content handlers as plugins.
</p>


<p>
~UAは、~MIME型［
`text/plain$c ／ `application/octet-stream$c
］に対しては、登録済みの`~plugin$があるものと見なしては~MUST_NOT。
◎
A user agent must not consider the types text/plain and application/octet-stream as having a registered plugin.
</p> 

<p class="example">
~pluginの一例として、利用者が PDF ~fileへ~navigateしたときに`閲覧文脈$内で~instance化される PDF ~viewerが挙げられる。
これは、~UA自身が PDF ~viewer部品を実装した主体であるかどうかに関わらず，~pluginに数えられることになる。
一方で、~UAが（自身の~UIを利用するのではなく，）別々の PDF ~viewer~appを起動させる場合、その~appは，この定義においては~pluginではない。
◎
One example of a plugin would be a PDF viewer that is instantiated in a browsing context when the user navigates to a PDF file. This would count as a plugin regardless of whether the party that implemented the PDF viewer component was the same as that which implemented the user agent itself. However, a PDF viewer application that launches separate from the user agent (as opposed to using the same interface) is not a plugin by this definition.
</p>

<p class="note">注記：
この仕様は、~pluginとやりとりする仕組みは定義しない
— それは［
~UA／~platform
］特有と予期されているので。
~UAには、
Netscape Plugin ~API などの~pluginを~~選択的に組み込める仕組みを~supportするものもあれば、遠隔操作の内容~変換器を利用するものや, 一定の内容~型に対しては組込みの~pluginで~supportするものもある。
~~実際、この仕様では，~UAによる~pluginの~supportは全く要求されない。
`NPAPI$r
◎
This specification does not define a mechanism for interacting with plugins, as it is expected to be user-agent- and platform-specific. Some UAs might opt to support a plugin mechanism such as the Netscape Plugin API; others might use remote content converters or have built-in support for certain types. Indeed, this specification doesn't require user agents to support plugins at all. [NPAPI]
</p>

<p>
~pluginは、 `sandbox$a 属性の意味論を尊守するならば，
`保安化-@
し得る。
◎
A plugin can be secured if it honors the semantics of the sandbox attribute.
</p>

<p class="example">
例えば，保安化された~pluginは、~sandbox化された `iframe$e の内側で~instance化されたときには，その内容は~pop-up-windowを作成できなくされることになる。
◎
For example, a secured plugin would prevent its contents from creating pop-up windows when the plugin is instantiated inside a sandboxed iframe.
</p>

<p class="warning">
~browserは、`~plugin$用に意図される外部~内容とやりとりするときには，特段の注意を払うべきである。
第三者主体の手による~softwareを~UA自身と同じ特権で走らせた場合、その~software内の脆弱性は，~UA内のそれと同等に危険になる。
◎
Browsers should take extreme care when interacting with external content intended for plugins. When third-party software is run with the same privileges as the user agent itself, vulnerabilities in the third-party software become as dangerous as those in the user agent.
</p>

<p>
利用者が有する`~plugin$の集合は利用者ごとに異なり、利用者が一意に識別されるような機会を増やすような指紋収集の~~手段を提供するので、~UAには，どの利用者に対しても 正確に同じ`~plugin$の集合を~supportすることが奨励される。
~FINGERPRINTING
◎
Since different users having different sets of plugins provides a fingerprinting vector that increases the chances of users being uniquely identified, user agents are encouraged to support the exact same set of plugins for each user.
</p>


		</section>
		<section id="encoding-terminology">
<h3 title="Character encodings">2.1.6. 文字~符号化方式</h3>

<p>
`文字~符号化方式@（
<a href="~ENCODING#encoding">参照先</a>
）は、~byte~streamと~Unicode文字列との間で相互に変換する仕方であり，
WHATWG Encoding 標準 `ENCODING$r にて定義される。
多義的にならない所では、単に “符号化方式” とも称される。
各 `符号化方式$には、［
`符号化方式~名@（
<a href="~ENCODING#name">参照先</a>
）と 1 個以上の
`符号化方式~label@（
<a href="~ENCODING#label">参照先</a>
）
］が~~定義されている。
◎
A character encoding, or just encoding where that is not ambiguous, is a defined way to convert between byte streams and Unicode strings, as defined in the WHATWG Encoding standard. An encoding has an encoding name and one or more encoding labels, referred to as the encoding's name and labels in the Encoding standard. [ENCODING]
</p>

<p>
`UTF-16@
符号化方式とは、`符号化方式~名$が［
`UTF-16BE$, または `UTF-16LE$
］である符号化方式を指す。
`ENCODING$r
◎
A UTF-16 encoding is UTF-16BE or UTF-16LE. [ENCODING]
</p>

<p>
`UTF-16$ でない`符号化方式$は、
`~ASCII互換@
であるという。
`ENCODING$r
◎
An ASCII-compatible encoding is any encoding that is not a UTF-16 encoding. [ENCODING]
</p>

<p class="note">注記：
WHATWG Encoding 標準にて定義されていない`符号化方式$に対する~supportは禁制されるので、この仕様が`~ASCII互換$でないものとして扱う必要がある符号化方式は、 `UTF-16$ に限られる。
◎
Since support for encodings that are not defined in the WHATWG Encoding standard is prohibited, UTF-16 encodings are the only encodings that this specification needs to treat as not being ASCII-compatible encodings.
</p>

<p>
用語
`符号単位@
は、 `DOMString$I の最小の不可分な成分である， 16~bit無符号~整数であり、~WebIDL仕様にて定義される。
（これは、~Unicodeによるものより狭義の定義であり，符号位置と<em>同じではない</em>。）
`WEBIDL$r
◎
The term code unit is used as defined in the Web IDL specification: a 16 bit unsigned integer, the smallest atomic component of a DOMString. (This is a narrower definition than the one used in Unicode, and is not the same as a code point.) [WEBIDL]
</p>

<div>
<p>
用語
`~Unicode符号位置@
は、次に述べるように，［
可能0な所では `~Unicode~scalar値^i ／
そうでない所では 対にされてない~surrogate符号位置（代用符号位置）
］を意味する
`UNICODE$r
。
文字／~Unicode符号位置
の用語を通して適合性~要件が定義されるときは：
</p>

<ul>
	<li>
［
上位~surrogate, 下位~surrogate
］の並びからなる`符号単位$の対（代用対）は，その対で表現される 1 個の符号位置として扱われ~MUST。
</li>
	<li>
一方で，対にされてない~surrogateは、その~surrogate値を伴う 1 個の符号位置として扱われ~MUST。
</li>
</ul>
◎
The term Unicode code point means a Unicode scalar value where possible, and an isolated surrogate code point when not. When a conformance requirement is defined in terms of characters or Unicode code points, a pair of code units consisting of a high surrogate followed by a low surrogate must be treated as the single code point represented by the surrogate pair, but isolated surrogates must each be treated as the single code point with the value of the surrogate. [UNICODE]
</div>

<p>
この仕様における用語
`文字@
は、特に`~Unicode文字$と記されない所では、`~Unicode符号位置$と同義である。
◎
In this specification, the term character, when not qualified as Unicode character, is synonymous with the term Unicode code point.
</p>

<p>
一方で，用語
`~Unicode文字@
は、`~Unicode~scalar値^i を意味するときに利用される（すなわち，~surrogate符号位置でない~Unicode符号位置）。
`UNICODE$r
◎
The term Unicode character is used to mean a Unicode scalar value (i.e. any Unicode code point that is not a surrogate code point). [UNICODE]
</p>

<p>
文字列の
`符号単位~長さ@
は、その文字列~内に含まれる`符号単位$の個数である。
◎
The code-unit length of a string is the number of code units in that string.
</p>

<p class="note">注記：
この複雑さは、~DOM~APIを`~Unicode文字$の用語を通してではなく，16~bit `符号単位$（ UTF-16 ）の用語を通して定義することにした、歴史的~決断による結果である。
◎
This complexity results from the historical decision to define the DOM API in terms of 16 bit (UTF-16) code units, rather than in terms of Unicode characters.
</p>


		</section>
		<section id="conformance-classes">
<h3 title="Conformance classes">2.1.7. 各種~適合性~class</h3>

<p class="trans-note">【
この節の和訳は
<a href="~HTMLconform#conformance-classes">別ページにて</a>
】</p>

		</section>
		<section id="dependencies">
<h3 title="Dependencies">2.1.8. 依存関係</h3>

<p class="trans-note">【
この節の和訳は
<a href="~HTMLconform#dependencies">別ページにて</a>
】</p>

		</section>
		<section id="extensibility-2">
<h3 title="Extensibility">2.1.9. 拡張性</h3>

<p class="trans-note">【
この節の和訳は
<a href="~HTMLconform#extensibility-2">別ページにて</a>
】</p>
		</section>
		<section id="interactions-with-xpath-and-xslt">
<h3 title="Interactions with XPath and XSLT">2.1.10. XPath＆XSLT との相互作用</h3>

<p class="trans-note">【
この節の和訳は
<a href="~HTMLconform#interactions-with-xpath-and-xslt">別ページにて</a>
】</p>
		</section>
	</section>
	<section id="case-sensitivity-and-string-comparison">
<h2 title="Case-sensitivity and string comparison">2.2. 文字大小区別の有無と文字列の比較</h2>


<p class="algo-head">
2 つの文字列を
`文字大小区別@
で比較するとは、符号位置ごとに正確に比較することを意味する。
◎
Comparing two strings in a case-sensitive manner means comparing them exactly, code point for code point.
</p>


<p>
他から定められない限り，文字列は`文字大小区別$で比較され~MUST。
◎
Except where otherwise stated, string comparisons must be performed in a case-sensitive manner.
</p>

<p class="trans-note">【
この訳（または他の仕様の和訳）では、`文字大小区別$による比較は，単に “~EQ” で表現する（特に明示する必要がある場合を除いて）。
】</p>

<p class="algo-head">
文字列 %~pattern が文字列 %S に
`先頭一致@
するとは、
%L を %~pattern の文字~数とするとき，［
%~pattern ~EQ ［
%S の中の，先頭から %L 個までの文字が成す文字列
］］であることを意味する。
◎
A string pattern is a prefix match for a string s when pattern is not longer than s and truncating s to pattern's length leaves the two strings as matches of each other.
</p>


	</section>
	<section id="common-microsyntaxes">
<h2 title="Common microsyntaxes">2.3. 共通の小構文</h2>

<p>
~HTMLでは，種々の所で，日付や数などを表現する特定0の~data型を受容する。
この節では、それらの形式による内容に対する適合性の判定基準, および
それらを構文解析する方法について述べる。
◎
There are various places in HTML that accept particular data types, such as dates or numbers. This section describes what the conformance criteria for content in those formats is, and how to parse them.
</p>

<p class="note">注記：
実装者には、以下に述べる構文の構文解析を実装するにあたり，第三者主体による~libraryの利用を考慮するときは、注意深く検分することが強く督促される。
例えば、日付~libraryにおける~errorの取扱いは、この仕様にて要求されるものから相違する挙動を実装している~~可能性が高い。
~error取扱いの挙動は、この仕様にて利用される構文に類似する日付~構文を述べる仕様では，定義されていないことが多いため、実装によって大きく異なる傾向にある。
◎
Implementors are strongly urged to carefully examine any third-party libraries they might consider using to implement the parsing of syntaxes described below. For example, date libraries are likely to implement error handling behavior that differs from what is required in this specification, since error-handling behavior is often not defined in specifications that describe date syntaxes similar to those used in this specification, and thus implementations tend to vary greatly in how they handle errors.
</p>


		<section id="common-parser-idioms">
<h3 title="Common parser idioms">2.3.1. 共通の成句的な構文解析器</h3>

<p>
この仕様の目的0においては、次に挙げる各種~文字~範囲が定義される：
◎
↓
</p>

<dl class="def-list">
	<dt>`White_Space 文字@</dt>
	<dd>
~Unicode `PropList.txt^c ~data~fileにおいて
~Unicode~prop  "White_Space" を有するもの。
`UNICODE$r
◎
The White_Space characters are those that have the Unicode property "White_Space" in the Unicode PropList.txt data file. [UNICODE]
</dd>
	<dd class="note">注記：
これを `Unicode.txt^c ~data~fileの "Bidi_Class" ~propに対する
"White_Space" 値（略称 "WS" ）と混同しないように。
◎
This is not to be confused with the "White_Space" value (abbreviated "WS") of the "Bidi_Class" property in the Unicode.txt data file.
</dd>

	<dt>`制御~文字@</dt>
	<dd>
~Unicode `UnicodeData.txt^c ~data~fileにおいて，
~Unicode "General_Category" ~propの値が "Cc" であるもの。
`UNICODE$r
◎
The control characters are those whose Unicode "General_Category" property has the value "Cc" in the Unicode UnicodeData.txt data file. [UNICODE]
</dd>
</dl>

<p>
以下に述べる一部の構文解析器は、構文解析される文字列を保持する変数 %入力,
および 次に構文解析される文字を指す変数 %位置 を用いる~patternに従う。
◎
Some of the micro-parsers described below follow the pattern of having an input variable that holds the string being parsed, and having a position variable pointing at the next character to parse in input.
</p>

<p class="trans-note">【
以下に現れる %位置↗ という表記は、
%位置 が指す文字を表す（詳細は`位置~変数$を参照されたし）。
】</p>


		</section>
		<section id="boolean-attributes">
<h3 title="Boolean attributes">2.3.2. 真偽~属性</h3>

<p>
一部の内容~属性は、
`真偽~属性@
とされている。
要素~上の真偽~属性の存在0は ~T 値を表現し、不在は ~F 値を表現する：
◎
A number of attributes are boolean attributes. The presence of a boolean attribute on an element represents the true value, and the absence of the attribute represents the false value.
</p>

<p>
真偽~属性は、在するならば，［
その値 ~IN~ACI { 空~文字列, 属性の正準的な名前 }
］で~MUST（ 属性~値の 頭部／尾部 に空白は許容されない）。
◎
If the attribute is present, its value must either be the empty string or a value that is an ASCII case-insensitive match for the attribute's canonical name, with no leading or trailing whitespace.
</p>

<p class="note">注記：
真偽~属性に対する、値［
`true^l, `false^l
］は許容されない。
~F 値を表現するためには、属性~自体も省略される必要がある。
◎
The values "true" and "false" are not allowed on boolean attributes. To represent a false value, the attribute has to be omitted altogether.
</p>

<div class="example">

<p>
~checkされ, かつ不能化されている（ checked ＆ disabled ）~checkboxの例をここに示す。
`checked$a, `disabled$a
属性はいずれも真偽~属性である。
◎
Here is an example of a checkbox that is checked and disabled. The checked and disabled attributes are the boolean attributes.
</p>

<pre class="html-code">
&lt;label&gt;&lt;input
    type=checkbox
    `checked^mark
    name=cheese
    `disabled^mark
&gt; Cheese&lt;/label&gt;
</pre>

<p>
これは、次のように書いても等価になる：
◎
This could be equivalently written as this:
</p>

<pre class="html-code">
&lt;label&gt;&lt;input
    type=checkbox
    `checked=checked^mark
    name=cheese
    `disabled=disabled^mark
&gt; Cheese&lt;/label&gt;
</pre>

<p>
次のように書き方を混在させても依然として等価になる：
◎
You can also mix styles; the following is still equivalent:
</p>

<pre class="html-code">
&lt;label&gt;&lt;input
    type='checkbox'
    `checked^mark
    name=cheese
    `disabled=""^mark
&gt; Cheese&lt;/label&gt;
</pre>

</div>

		</section>
		<section id="keywords-and-enumerated-attributes">
<h3 title="Keywords and enumerated attributes">2.3.3. ~keyword, 列挙ed属性</h3>

<div class="p">
<p>
一部の内容~属性は、とり得る値の範囲が，いくつかの~keywordの有限~集合として定義されている。
そのような属性は、
`列挙ed属性@
呼ばれる。
各~keywordは、特定0の <em>状態</em> に対応付けられるものと定義される（複数の~keywordが、同じ状態に対応付けられることもある
— そのような~keywordは，互いに同義語になる。
加えて，~keywordのうち一部には、歴史的~理由のためのみ仕様に残されているものもある
— その種のものは非~適合とされる）。
加えて、次の二つの既定~状態が定義されることもある：
</p>

<ul ><li>`妥当でない値に対する既定の状態@
</li><li>`値なしに対する既定の状態@
</li></ul>


◎
Some attributes are defined as taking one of a finite set of keywords. Such attributes are called enumerated attributes. The keywords are each defined to map to a particular state (several keywords might map to the same state, in which case some of the keywords are synonyms of each other; additionally, some of the keywords can be said to be non-conforming, and are only in the specification for historical reasons). In addition, two default states can be given. The first is the invalid value default, the second is the missing value default.
</div>

<p>
要素が`列挙ed属性$を有する場合、［
その値 ~IN~ACI { 所与の~keyword集合のうち，非~適合とされていないもの }
］で~MUST（ 属性~値の 頭部／尾部 に空白は許容されない）。
◎
If an enumerated attribute is specified, the attribute's value must be an ASCII case-insensitive match for one of the given keywords that are not said to be non-conforming, with no leading or trailing whitespace.
</p>

<div>
<p class="algo-head">
( `列挙ed属性$ %A, ~keyword集合 %S )
が与えられた下で，要素において %A が表現する状態は、次の手続きで与えられる：
</p>

<ol>
	<li>
<p>
~IF［
要素は %A を有する
］：
</p>
		<ol>
			<li>
~IF［
%A の値 ~IN~ACI %S
］
⇒
~RET その値に対応する状態
</li>
			<li>
~IF［
%A には `妥当でない値に対する既定の状態$が定義されている
］
⇒
~RET その状態
</li>
		</ol>
	</li>
	<li>
~IF［
%A には `値なしに対する既定の状態$が定義されている
］
⇒
~RET その状態
</li>
	<li>
~RET ε （表現される状態はない）
</li>
</ol>

◎
When the attribute is specified, if its value is an ASCII case-insensitive match for one of the given keywords then that keyword's state is the state that the attribute represents. If the attribute value matches none of the given keywords, but the attribute has an invalid value default, then the attribute represents that state. Otherwise, if the attribute value matches none of the keywords but there is a missing value default state defined, then that is the state represented by the attribute. Otherwise, there is no default, and invalid values mean that there is no state represented.
◎
When the attribute is not specified, if there is a missing value default state defined, then that is the state represented by the (missing) attribute. Otherwise, the absence of the attribute means that there is no state represented.
</div>

<p class="note">注記：
空~文字列も妥当な~keywordになり得る。
◎
The empty string can be a valid keyword.
</p>


		</section>
		<section id="numbers">
<h3 title="Numbers">2.3.4. 実数</h3>


<p>
`この訳では、簡潔に記述するため，次を定義する：^tnote
</p>

<ul>
	<li>
`Base10@ ( %s ) は、所与の`~ASCII数字$列 %s に対し［
%s ~EQ 空~文字列 ならば 0 ／
~ELSE_ %s を 10 進~数字~列として整数に解釈した結果
］を表す。
</li>
	<li>
`String10@ ( %n ) は、所与の整数 %n を表現するような`妥当な整数$（文字列）のうち，可能0な限り最短の文字列を表す（ %n が負でないなら `妥当な非~負~整数$になる）。
</li>
	<li>
`Power10@ ( %n ) は、所与の整数 %n に対する
( 10 の %n 乗 )
を表す。
</li>
</ul>


			<section id="signed-integers">
<h4 title="Signed integers">2.3.4.1. 有符号~整数</h4>


<div class="p">
<p>
次の並びからなる文字列は
`妥当な整数@
とされる：
</p>

<ol>
	<li>
0 〜 1 個の文字 ❝-
</li>
	<li>
1 個以上の`~ASCII数字$
</li>
</ol>

◎
A string is a valid integer if it consists of one or more ASCII digits, optionally prefixed with a U+002D HYPHEN-MINUS character (-).
</div>

<p>
`妥当な整数$は
⇒
❝- を［
伴わないならば 1 ／
伴うならば −1
］ × `Base10$( その中の数字~列 ) を表現する。
◎
A valid integer without a U+002D HYPHEN-MINUS (-) prefix represents the number that is represented in base ten by that string of digits. A valid integer with a U+002D HYPHEN-MINUS (-) prefix represents the number represented in base ten by the string of digits that follows the U+002D HYPHEN-MINUS, subtracted from zero.
</p>

<p class="algo-head">
所与の文字列 %入力 を
`整数として構文解析-@
する規則は、次の~algoで与えられ，［
整数, ~error
］のいずれかを返す：
<!-- すべて略
When invoked, the steps must be followed in the order given, aborting at the first step that returns a value
 -->
◎
The rules for parsing integers are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either an integer or an error.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%符号 ~LET 1
◎
Let sign have the value "positive".
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
	<li>
<p>
%位置↗ に応じて：
◎
If position is past the end of input, return an error.
</p>
		<dl class="switch">
			<dt>❝-
◎
If the character indicated by position (the first character) is a U+002D HYPHEN-MINUS character (-):</dt>
			<dd>
				<ol>
					<li>
%符号 ~LET −1
◎
Let sign be "negative".
</li>
					<li>
%位置 ~INCBY 1
◎
Advance position to the next character.
◎
If position is past the end of input, return an error.
</li>
				</ol>
			</dd>

			<dt>❝+
◎
Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN character (+):
</dt>
			<dd>
				<ol>
					<li>
%位置 ~INCBY 1
（ `+^l は無視されるが適合ではない。）
◎
Advance position to the next character. (The "+" is ignored, but it is not conforming.)
◎
If position is past the end of input, return an error.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~RET ~error
◎
If the character indicated by position is not an ASCII digit, then return an error.
</li>
	<li>
~RET %符号 × `Base10$(
%入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集-$した結果
)
◎
Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Let value be that integer.
◎
If sign is "positive", return value, otherwise return the result of subtracting value from zero.
</li>
</ol>


			</section>
			<section id="non-negative-integers">
<h4 title="Non-negative integers">2.3.4.2. 非~負~整数</h4>

<p>
1 個以上の`~ASCII数字$からなる文字列は
`妥当な非~負~整数@
とされる。
◎
A string is a valid non-negative integer if it consists of one or more ASCII digits.
</p>

<p>
`妥当な非~負~整数$は、
`Base10$( その数字~列 )
を表現する。
◎
A valid non-negative integer represents the number that is represented in base ten by that string of digits.
</p>


<p class="algo-head">
所与の文字列 %入力 を
`非~負~整数として構文解析-@
する規則は、次の~algoで与えられ，［
非~負~整数, ~error
］のいずれかを返す：
◎
The rules for parsing non-negative integers are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either zero, a positive integer, or an error.
</p>

<ol>
	<li>
%値 ~LET %入力 を`整数として構文解析-$した結果
◎
Let input be the string being parsed.
◎
Let value be the result of parsing input using the rules for parsing integers.
</li>
	<li>
~IF［
%値 ~EQ ~error
］~OR［
%値 ~LT 0
］
⇒
~RET ~error
◎
If value is an error, return an error.
◎
If value is less than zero, return an error.
</li>
	<li>
~RET %値
◎
Return value.
</li>
</ol>






			</section>
			<section id="floating-point-numbers">
<h4 title="Floating-point numbers">2.3.4.3. 浮動小数点数</h4>

<p>
次の並びからなる文字列は、
`妥当な浮動小数点数@
とされる：
◎
A string is a valid floating-point number if it consists of:
</p>

<ol>
	<li>
“符号~部” ：
0 〜 1 個の ❝-
◎
Optionally, a U+002D HYPHEN-MINUS character (-).
</li>
	<li>
<p>
次の両方, または片方のみによる並び：
◎
One or both of the following, in the given order:
</p>
		<ol>
			<li>
“整数~部” ：
1 個以上の`~ASCII数字$からなる並び
◎
A series of one or more ASCII digits.
</li>
			<li>
<p>
次の並び：
◎
Both of the following, in the given order:
</p>
				<ol>
					<li>
1 個の ❝.
◎
A single U+002E FULL STOP character (.).
</li>
					<li>
“小数~部” ：
1 個以上の`~ASCII数字$からなる並び
◎
A series of one or more ASCII digits.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
“指数~部” ：
空~文字列, または
次の並び：
◎
Optionally:
</p>

		<ol>
			<li>
1 個の［
❝e, または ❝E
］
◎
Either a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E).
</li>
			<li>
“指数~部の符号~部” ：
0 〜 1 個の［
❝-, または ❝+
］
◎
Optionally, a U+002D HYPHEN-MINUS character (-) or U+002B PLUS SIGN character </li>
			<li>
“指数~部の数字~列” ：
1 個以上の`~ASCII数字$からなる並び
◎
A series of one or more ASCII digits.
</li>
		</ol>
	</li>
</ol>


<div class="p">
<p>
`妥当な浮動小数点数$は、
( %符号 × %仮数 × `Power10$( %指数 ) )
で得られる数を表現する
— ここで：
</p>

<ul>
	<li>
%符号 ~EQ ［
前述の “符号~部” ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
</li>
	<li>
<p>
%仮数 ~EQ %整数 + %小数
— ここで：
</p>
		<ul>
			<li>
%整数 ~EQ 前述の “整数~部” が［
あれば `Base10$( “整数~部” ) ／
なければ 0
］
</li>
			<li>
%小数 ~EQ 前述の “小数~部” が［
あれば `Base10$( “小数~部” ) ÷ 
`Power10$( “小数~部” の文字~数 ) ／
なければ 0
］
</li>
		</ul>
	</li>
	<li>
<p >
%指数 ~EQ ［
前述の “指数~部” ~NEQ 空~文字列ならば
( %符号 × %指数 ) ／
~ELSE_ 0
］
— ここで：
</p>
		<ul>
			<li >
%符号 ~EQ ［
前述の “指数~部の符号~部” ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
</li>
			<li >
%指数 ~EQ `Base10$( 前述の “指数~部の数字~列” )
</li>
		</ul>
	</li>
</ul>

◎
A valid floating-point number represents the number obtained by multiplying the significand by ten raised to the power of the exponent, where the significand is the first number, interpreted as base ten (including the decimal point and the number after the decimal point, if any, and interpreting the significand as a negative number if the whole string starts with a U+002D HYPHEN-MINUS character (-) and the number is not zero), and where the exponent is the number after the E, if any (interpreted as a negative number if there is a U+002D HYPHEN-MINUS character (-) between the E and the number and the number is not zero, or else ignoring a U+002B PLUS SIGN character (+) between the E and the number if there is one). If there is no E, then the exponent is treated as zero.
</div>

<p class="note">注記：
Infinity, NaN（ Not-a-Number ）いずれの値も，`妥当な浮動小数点数$ではない。
◎
The Infinity and Not-a-Number (NaN) values are not valid floating-point numbers.
</p>

<p class="note">注記：
`妥当な浮動小数点数$の概念は、概して，作者に許容されるものを制約する利用に限られる。
一方で、~UAに課される要件には，`浮動小数点数として構文解析-$する規則が利用される（例： `progress$e 要素の `max$a 属性 ）。
しかしながら，一部の事例では、文字列が`妥当な浮動小数点数$かどうか検査することも~UA要件に含まれる（例：
`Number$st 状態にある `input$e 要素に対する
<a href="~HEinput#value-sanitization-algorithm">値の消毒</a> ／
`srcset^a 属性を
<a href="~HTMLemb#parse-a-srcset-attribute">構文解析する</a>
~algo）。
◎
The valid floating-point number concept is typically only used to restrict what is allowed for authors, while the user agent requirements use the rules for parsing floating-point number values below (e.g., the max attribute of the progress element). However, in some cases the user agent requirements include checking if a string is a valid floating-point number (e.g., the value sanitization algorithm for the Number state of the input element, or the parse a srcset attribute algorithm).
</p>


<p>
実数 %n に対する
`浮動小数点数として最良の表現@
は、 `ToString$jA( %n ) を走らせて得られる文字列である。
`ToString()^jA 抽象演算の結果は一意に決定されるとは限らない
— 特定0の値に対する `ToString()^jA の結果として複数の文字列が可能0な場合、~UAは常に同じ結果を返さ~MUST（他の~UAは相違する値を利用するかもしれないが）。
◎
The best representation of the number n as a floating-point number is the string obtained from running ToString(n). The abstract operation ToString is not uniquely determined. When there are multiple possible strings that could be obtained from ToString for a particular value, the user agent must always return the same string for that value (though it may differ from the value used by other user agents).
</p>

<p class="algo-head">
所与の文字列 %入力 を
`浮動小数点数として構文解析-@
する規則は、次の~algoで与えられ，［
実数, ~error
］のいずれかを返す：
◎
The rules for parsing floating-point number values are as given in the following algorithm. This algorithm must be aborted at the first step that returns something. This algorithm will return either a number or an error.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
◎
Let value have the value 1.
◎
Let divisor have the value 1.
◎
Let exponent have the value 1.
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
◎
If position is past the end of input, return an error.
↓</li>
	<li>
%符号 ~SET ［
%位置↗ ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
◎
If the character indicated by position is a U+002D HYPHEN-MINUS character (-):
• Change value and divisor to −1.
• Advance position to the next character.
• If position is past the end of input, return an error.
↓</li>
	<li>
~IF［
%位置↗ ~IN { ❝-, ❝+ }
］
⇒
%位置 ~INCBY 1
（ `+^l は適合でないが無視される）
◎
Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN character (+):
• Advance position to the next character. (The "+" is ignored, but it is not conforming.)
• If position is past the end of input, return an error.
</li>
	<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~IF［
%位置↗ ~NEQ ❝.
］~OR［
( %位置 + 1 )↗ ~NIN `~ASCII数字$
］
⇒
~RET ~error
◎
↑↓
</li>
	<li>
%値 ~SET `Base10$(
%入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集-$した結果
)
◎
If the character indicated by position is a U+002E FULL STOP (.), and that is not the last character in input, and the character after the character indicated by position is an ASCII digit, then set value to zero and jump to the step labeled fraction.
◎
If the character indicated by position is not an ASCII digit, then return an error.
◎
Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Multiply value by that integer.
◎
If position is past the end of input, jump to the step labeled conversion.
</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝.
]：
</p>
		<ol>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%小数 ~LET
%入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集-$した結果
</li>
			<li>
%値 ~INCBY `Base10$( %小数 ) ÷ `Power10$( %小数 の文字数 )
</li>
		</ol>

◎
Fraction: If the character indicated by position is a U+002E FULL STOP (.), run these substeps:
• Advance position to the next character.
• If position is past the end of input, or if the character indicated by position is not an ASCII digit, U+0065 LATIN SMALL LETTER E (e), or U+0045 LATIN CAPITAL LETTER E (E), then jump to the step labeled conversion.
• If the character indicated by position is a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E), skip the remainder of these substeps.
•• Fraction loop: Multiply divisor by ten.
••Add the value of the character indicated by position, interpreted as a base-ten digit (0..9) and divided by divisor, to value.
••Advance position to the next character.
••If position is past the end of input, then jump to the step labeled conversion.
••If the character indicated by position is an ASCII digit, jump back to the step labeled fraction loop in these substeps.
</li>
	<li>
<p>
~IF［
%位置↗ ~IN { ❝e, ❝E }
］：
◎
If the character indicated by position is a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E), run these substeps:
</p>

		<ol>
			<li>
%位置 ~INCBY 1
◎
Advance position to the next character.
◎
If position is past the end of input, then jump to the step labeled conversion.
</li>
			<li>
%指数 ~SET ［
%位置↗ ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
◎
If the character indicated by position is a U+002D HYPHEN-MINUS character (-):
• Change exponent to −1.
• Advance position to the next character.
• If position is past the end of input, then jump to the step labeled conversion.
</li>
			<li>
~IF［
%位置↗ ~IN { ❝-, ❝+ }
］
⇒
%位置 ~INCBY 1
◎
Otherwise, if the character indicated by position is a U+002B PLUS SIGN character (+):
• Advance position to the next character.
• If position is past the end of input, then jump to the step labeled conversion.
</li>
			<li>
%指数 ~SET %指数 × `Base10$(
%入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集-$した結果
)
◎
If the character indicated by position is not an ASCII digit, then jump to the step labeled conversion.
◎
Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Multiply exponent by that integer.
</li>
			<li>
%値 ~SET %値 × `Power10$( %指数 )
◎
Multiply value by ten raised to the exponentth power.
</li>
		</ol>
	</li>
	<li>
%値 ~SET %値 × %符号
◎
↑↑</li>
	<li>
%S ~LET ［［
有限 IEEE 754倍精度 浮動小数点数の集合
］から −0 を除いた集合
］に 2 個の特別な値［
%max ~EQ ( 2 の 1024  乗 ),
%min ~EQ −( 2 の 1024 乗 )
］を追加した集合
◎
Conversion: Let S be the set of finite IEEE 754 double-precision floating-point values except −0, but with two special values added: 21024 and −21024.
</li>
	<li>
%結果 ~LET
%S 内の数であって， %値 に最も近いもの
— ここで、%値 が %S 内の 2 個の数に等しく近い場合は、仮数が偶数である方を選ぶ（この目的0においては、 %max, %min の仮数は偶数と見なす）。
◎
Let rounded-value be the number in S that is closest to value, selecting the number with an even significand if there are two equally close values. (The two special values 21024 and −21024 are considered to have even significands for this purpose.)
</li>
	<li>
~IF［
%結果 ~IN { %max, %min }
］
⇒
~RET ~error
◎
If rounded-value is 21024 or −21024, return an error.
</li>
	<li>
~RET %結果
◎
Return rounded-value.
</li>
</ol>

<p class="trans-note">【
この訳では、等価な結果が得られるように，原文の~algoをかなり単純化している。
】</p>

			</section>
			<section id="percentages-and-dimensions">
<h4 title="Percentages and lengths">2.3.4.4. 百分率, 長さ</h4>

<p class="algo-head">
所与の文字列 %入力 を
`寸法~値として構文解析-@
する規則は、次の~algoで与えられ，
［
( 実数, 種別 ) の組, ~error
］のいずれかを返す
— ここで、実数は 0.0 以上,
種別は［
`百分率^i, `長さ^i
］のいずれかである：
◎
The rules for parsing dimension values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than or equal to 0.0, or an error; if a number is returned, then it is further categorized as either a percentage or a length.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
	<li>
~IF［
%位置↗ ~EQ ❝+
］
⇒
%位置 ~INCBY 1
◎
If position is past the end of input, return an error.
◎
If the character indicated by position is a U+002B PLUS SIGN character (+), advance position to the next character.
</li>
	<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~RET ~error
◎
If position is past the end of input, return an error.
◎
If the character indicated by position is not an ASCII digit, then return an error.
</li>
	<li>
%値 ~LET `Base10$(
%入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集-$した結果
)
◎
Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Let value be that number.
◎
If position is past the end of input, return value as a length.
↓</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝.
］：
◎
If the character indicated by position is a U+002E FULL STOP character (.):
</p>

		<ol>
			<li>
%位置 ~INCBY 1
◎
Advance position to the next character.
</li>
			<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~RET ( %値, `長さ^i )
◎
If position is past the end of input, or if the character indicated by position is not an ASCII digit, then return value as a length.
</li>
			<li>
%小数 ~LET
%入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集-$した結果
◎
↓</li>
			<li>
%値 ~INCBY `Base10$( %小数 ) ÷ `Power10$( %小数 の文字数 )
◎
Let divisor have the value 1.
◎
Fraction loop: Multiply divisor by ten.
◎
Add the value of the character indicated by position, interpreted as a base-ten digit (0..9) and divided by divisor, to value.
◎
Advance position to the next character.
◎
If position is past the end of input, then return value as a length.
◎
If the character indicated by position is an ASCII digit, return to the step labeled fraction loop in these substeps.
</li>
		</ol>
	</li>
	<li>
~IF［
%位置↗ ~EQ ❝%
］
⇒
~RET ( %値, `百分率^i )
◎
If position is past the end of input, return value as a length.
◎
If the character indicated by position is a U+0025 PERCENT SIGN character (%), return value as a percentage.
</li>
	<li>
~RET ( %値, `長さ^i )
◎
Return value as a length.
</li>
</ol>



			</section>
			<section id="non-zero-percentages-and-lengths">
<h4 title="Non-zero percentages and lengths">2.3.4.5. 非~zeroの百分率と長さ</h4>

<p class="algo-head">
所与の文字列 %入力 を
`非~zero寸法~値として構文解析-@
する規則は、次の~algoで与えられ，［［
( 0.0 以上の実数, 種別（`百分率^i または `長さ^i ）) の組
］, ~error
］のいずれかを返す：
◎
The rules for parsing non-zero dimension values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than 0.0, or an error; if a number is returned, then it is further categorized as either a percentage or a length.
</p>

<ol>
	<li>
%V ~LET %入力 を`寸法~値として構文解析-$した結果
◎
Let input be the string being parsed.
◎
Let value be the result of parsing input using the rules for parsing dimension values.
</li>
	<li>
~IF［
%V ~EQ ~error
］~OR ［
%V ~EQ 0
］
⇒
~RET ~error
◎
If value is an error, return an error.
◎
If value is zero, return an error.
</li>
	<li>
~RET %V
◎
If value is a percentage, return value as a percentage.
◎
Return value as a length.
</li>
</ol>



			</section>
			<section id="lists-of-floating-point-numbers">
<h4 title="Lists of floating-point numbers">2.3.4.6. 浮動小数点数~list</h4>

<p>
❝, で互いに区切られた，
0 個以上の`妥当な浮動小数点数$からなる文字列は、
`妥当な浮動小数点数~list@
とされる。
区切りには他の文字（`~ASCII空白$など）は含まない。
加えて，許容される 浮動小数点数の個数 には、制約が課されることもある。
◎
A valid list of floating-point numbers is a number of valid floating-point numbers separated by U+002C COMMA characters, with no other characters (e.g. no space characters). In addition, there might be restrictions on the number of floating-point numbers that can be given, or on the range of values allowed.
</p>

<p class="algo-head">
所与の文字列 %入力 を
`浮動小数点数~listとして構文解析-@
する規則は、次で与えられる：
◎
The rules for parsing a list of floating-point numbers are as follows:
</p>


<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%実数~list ~LET 空~list
— この~listが~algoの結果になる。
◎
Let numbers be an initially empty list of floating-point numbers. This list will be the result of this algorithm.
</li>
	<li>
%区切子 ~LET { `0020^U ( SPACE ), ❝,, ❝; }
◎
↓</li>
	<li>
%入力 内の %位置 から
%区切子 からなる`符号位置~並びを収集-$する
— これは、頭部の区切子を読飛ばす。
◎
Collect a sequence of code points that are space characters, U+002C COMMA, or U+003B SEMICOLON characters from input given position. This skips past any leading delimiters.
</li>
	<li>
<p>
~WHILE ( %位置↗ ~NEQ ε )：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%入力 内の %位置 から
{ %区切子, `~ASCII数字$, ❝., ❝- }
以外の`符号位置~並びを収集-$する
— これは、頭部の無用な文字~並びを読飛ばす。
◎
Collect a sequence of code points that are not space characters, U+002C COMMA, U+003B SEMICOLON, ASCII digits, U+002E FULL STOP, or U+002D HYPHEN-MINUS characters from input given position. This skips past leading garbage.
</li>
			<li>
%実数~文字列 ~LET 
%入力 内の %位置 から
%区切子 以外の`符号位置~並びを収集-$した結果
◎
Collect a sequence of code points that are not space characters, U+002C COMMA, or U+003B SEMICOLON characters from input given position, and let unparsed number be the result.
</li>
			<li>
%実数 ~LET %実数~文字列 を`浮動小数点数として構文解析-$した結果
◎
Let number be the result of parsing unparsed number using the rules for parsing floating-point number values.
</li>
			<li>
~IF［
%実数 ~EQ ~error
］
⇒
%実数 ~SET 0
◎
If number is an error, set number to zero.
</li>
			<li>
%実数~list に %実数 を付加する
◎
Append number to numbers.
</li>
			<li>
%入力 内の %位置 から
%区切子 からなる`符号位置~並びを収集-$する
— これは、次の区切子を読飛ばす。
◎
Collect a sequence of code points that are space characters, U+002C COMMA, or U+003B SEMICOLON characters from input given position. This skips past the delimiter.
</li>
		</ol>
	<li>
~RET %実数~list
◎
Return numbers.
</li>
</ol>



			</section>
			<section id="lists-of-dimensions">
<h4 title="Lists of dimensions">2.3.4.7. 寸法~list</h4>


<p class="algo-head">
所与の文字列 %生~入力 を
`寸法~listとして構文解析-@
する規則は、次で与えられ，［
0 個以上の［
( 実数, 単位 ) の組
］からなる~listを返す
— ここで、単位は［
`百分率^i, `相対^i, `絶対^i
］のいずれかである：
◎
The rules for parsing a list of dimensions are as follows. These rules return a list of zero or more pairs consisting of a number and a unit, the unit being one of percentage, relative, and absolute.
</p>

<ol>
	<li>
~IF［
%生~入力 の最後の文字 ~EQ ❝,
］
⇒
%生~入力 から最後の文字を除去する
◎
Let raw input be the string being parsed.
◎
If the last character in raw input is a U+002C COMMA character (,), then remove that character from raw input.
</li>
	<li>
%~token列 ~LET %生~入力 を`~commaで分割-$した結果
◎
Split the string raw input on commas. Let raw tokens be the resulting list of tokens.
</li>
	<li>
%結果 ~LET 空~list
◎
Let result be an empty list of number/unit pairs.
</li>
	<li>

<p>
~FOR
%~token列 内の ~EACH ( ~token %入力 ) に対し：
◎
For each token in raw tokens, run the following substeps:
</p>

		<ol>
			<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the token.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
			<li>
%値 ~LET 0
◎
Let value be the number 0.
◎
Let unit be absolute.
</li>
			<li>
<p>
%位置↗ に応じて：
</p>
				<dl class="switch">
					<dt>ε</dt>
					<dd>
%結果 に組 ( %値, `相対^i ) を追加する；<br>
~CONTINUE
◎
If position is past the end of input, set unit to relative and jump to the last substep.
</dd>
					<dt>`~ASCII数字$</dt>
					<dd>
%値 ~INCBY
`Base10$(
%入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集-$した結果
)
◎
If the character at position is an ASCII digit, collect a sequence of code points that are ASCII digits from input given position, interpret the resulting sequence as an integer in base ten, and increment value by that integer.
</dd>
					<dt>❝.
◎
If the character at position is a U+002E FULL STOP character (.), run these substeps:
</dt>
					<dd>
						<ol>
							<li>
%s ~LET
%入力 内の %位置 から
{ `~ASCII空白$, `~ASCII数字$ }
からなる`符号位置~並びを収集-$した結果
◎
Collect a sequence of code points consisting of space characters and ASCII digits from input given position. Let s be the resulting sequence.
</li>
							<li>
%s から`~ASCII空白$すべてを除去する
◎
Remove all space characters in s.
</li>
							<li>
%値 ~INCBY ( `Base10$( %s ) ÷ `Power10$( %s の文字~数 ) )
◎
If s is not the empty string, run these subsubsteps:
• Let length be the number of characters in s (after the spaces were removed).
• Let fraction be the result of interpreting s as a base-ten integer, and then dividing that number by 10length.
• Increment value by fraction.
</li>
						</ol>
					</dd>
				</dl>
			</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
			<li>
<p>
%単位 ~LET %位置↗ に応じて，次で与えられる単位：
</p>
				<dl class="switch">
					<dt>❝%</dt>
					<dd>
`百分率^i
◎
If the character at position is a U+0025 PERCENT SIGN character (%), then set unit to percentage.
</dd>
					<dt>❝*</dt>
					<dd>
`相対^i
◎
Otherwise, if the character at position is a U+002A ASTERISK character (*), then set unit to relative.
</dd>
					<dt>その他</dt>
					<dd>
`絶対^i
</dd>
				</dl>
			</li>
			<li>
%結果 に組 ( %値, %単位 )
を追加する
◎
Add an entry to result consisting of the number given by value and the unit given by unit.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return the list result.
</li>
</ol>





			</section>
		</section>
		<section id="dates-and-times">
<h3 title="Dates and times">2.3.5. 日付と時刻</h3>

<p class="trans-note">【
この節の内容の和訳は、
<a href="~HTMLdate#dates-and-times">別ページにて</a>
】</p>

		</section>
		<section id="colors">
<h3 title="Colors">2.3.6. 色</h3>

<p>
`単純~色@
は、3 個の［
範囲 0 〜 255 の 8-bit数
］からなり，順に sRGB 色~空間~内の色の
( ~red, ~green, ~blue )
成分を表現する。
`SRGB$r
◎
A simple color consists of three 8-bit numbers in the range 0..255, representing the red, green, and blue components of the color respectively, in the sRGB color space. [SRGB]
</p>

<div class="p">
<p>
次をすべて満たす文字列 %s は、
`妥当な単純~色@
とされる：
</p>

<ul>
	<li>
%s の文字~数 ~EQ 7
</li>
	<li>
%s の最初の文字 ~EQ ❝#
</li>
	<li>
%s の残りの 6 文字は すべての `~ASCII~hex数字$
— この 6 文字を成す各 2 文字ずつが、順に
( ~red, ~green, ~blue )
成分を~hex数字による整数で表現する。
</li>
</ul>

◎
A string is a valid simple color if it is exactly seven characters long, and the first character is a U+0023 NUMBER SIGN character (#), and the remaining six characters are all ASCII hex digits, with the first two digits representing the red component, the middle two digits representing the green component, and the last two digits representing the blue component, in hexadecimal.
</div>

<p>
`妥当な単純~色$であって，範囲 ❝A 〜 ❝F 内の文字は含まれていない文字列は
`妥当な小文字~単純~色@
とされる。
◎
A string is a valid lowercase simple color if it is a valid simple color and doesn't use any characters in the range U+0041 LATIN CAPITAL LETTER A to U+0046 LATIN CAPITAL LETTER F.
</p>


<p class="algo-head">
所与の文字列 %入力 を
`単純~色として構文解析-@
する規則は、次の~algoで与えられ，［
`単純~色$, ~error
］のいずれかを返す：
◎
The rules for parsing simple color values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a simple color or an error.
</p>

<ol>
	<li>
~IF［
%入力 は`妥当な単純~色$でない
］
⇒
~RET ~error
◎
Let input be the string being parsed.
◎
If input is not exactly seven characters long, then return an error.
◎
If the first character in input is not a U+0023 NUMBER SIGN character (#), then return an error.
◎
If the last six characters of input are not all ASCII hex digits, then return an error.
</li>
	<li>
~RET %入力 の
( 2 〜 3 個目, 4 〜 5 個目, 6 〜 7 個目 )
の文字を~hex数字として整数に解釈した結果を，
( ~red, ~green, ~blue )
成分とする`単純~色$
◎
Let result be a simple color.
◎
Interpret the second and third characters as a hexadecimal number and let the result be the red component of result.
◎
Interpret the fourth and fifth characters as a hexadecimal number and let the result be the green component of result.
◎
Interpret the sixth and seventh characters as a hexadecimal number and let the result be the blue component of result.
◎
Return result.
</li>
</ol>

<p class="algo-head">
所与の`単純~色$ %C を
`単純~色として直列化する規則@
は、次の~algoで与えられ，`妥当な小文字~単純~色$を返す：
◎
The rules for serializing simple color values given a simple color are as given in the following algorithm:
</p>

<ol>
	<li>
%結果 ~LET
1 個の ❝# からなる文字列
◎
Let result be a string consisting of a single U+0023 NUMBER SIGN character (#).
</li>
	<li>
~FOR
%C 内の~EACH ( 成分 %成分 ) に対し，［
~red, ~green, ~blue
］の順に
⇒
%結果 に［
%成分 を ( 2 個の~hex数字 ) に変換した結果
］を付加する
— ここで、数字には`小文字~ASCII~hex数字$を利用し，必要なら先頭に~zeroを付け加えるとする。
◎
Convert the red, green, and blue components in turn to two-digit hexadecimal numbers using ASCII lower hex digits, zero-padding if necessary, and append these numbers to result, in the order red, green, blue.
</li>
	<li>
~RET %結果
◎
Return result, which will be a valid lowercase simple color.
</li>
</ol>

<hr>

<p class="algo-head">
一部の廃用にされた旧来の属性は、色を構文解析するときに，より混み入った
`旧来の色~値として構文解析-@
する規則を利用する。
それは，次の~algoで与えられ、所与の文字列 %入力 に対し［
`単純~色$, ~error
］のいずれかを返す：
◎
Some obsolete legacy attributes parse colors in a more complicated manner, using the rules for parsing a legacy color value, which are given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a simple color or an error.
</p>

<ol>
	<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒
~RET ~error
◎
Let input be the string being parsed.
◎
If input is the empty string, then return an error.
</li>
	<li>
%入力 から`頭部と尾部の~ASCII空白を剥ぐ$
◎
Strip leading and trailing ASCII whitespace from input.
</li>
	<li>
~IF［
%入力 ~EQ~ACI `transparent^l
］
⇒
~RET ~error
◎
If input is an ASCII case-insensitive match for the string "transparent", then return an error.
</li>
	<li>

<p>
~IF［
%入力 ~IN~ACI `有名~色$
］
⇒
~RET その~keywordに対応する`単純~色$
`CSSCOLOR$r
◎
If input is an ASCII case-insensitive match for one of the named colors, then return the simple color corresponding to that keyword. [CSSCOLOR]
</p>

<p class="note">注記：
<a href="~TR/css3-color/#css2-system">CSS2 System Color</a>
は認識されない。
◎
CSS2 System Colors are not recognized.
</p>
	</li>
	<li>
<p>
~IF［
%入力 は［
❝#, 3 個の`~ASCII~hex数字$
］の並びである
］
⇒
~RET 次のようにされた`単純~色$
⇒
( ~red, ~green, ~blue )
成分 ~SET 順に，
%入力 の (2, 3, 4) 個目の文字を［
(~hex数字として整数に解釈した結果 ) × 17
］
◎
If input is four characters long, and the first character in input is a U+0023 NUMBER SIGN character (#), and the last three characters of input are all ASCII hex digits, then run these substeps:
• Let result be a simple color.
• Interpret the second character of input as a hexadecimal digit; let the red component of result be the resulting number multiplied by 17.
• Interpret the third character of input as a hexadecimal digit; let the green component of result be the resulting number multiplied by 17.
• Interpret the fourth character of input as a hexadecimal digit; let the blue component of result be the resulting number multiplied by 17.
• Return result.
</li>
	<li>
%入力 内の U+FFFF を超える~Unicode符号位置（すなわち，基本多言語面に含まれない文字）すべてを `00^l に置換する
◎
Replace any characters in input that have a Unicode code point greater than U+FFFF (i.e. any characters that are not in the basic multilingual plane) with the two-character string "00".
</li>
	<li>
%入力 ~SET %入力 の最初の 128 文字までの文字列
◎
If input is longer than 128 characters, truncate input, leaving only the first 128 characters.
</li>
	<li>
~IF［
%入力 の最初の文字 ~EQ ❝#
］
⇒
%入力 から最初の文字を除去する
◎
If the first character in input is a U+0023 NUMBER SIGN character (#), remove it.
</li>
	<li>
%入力 内の非`~ASCII~hex数字$はすべて ❝0 に置換する
◎
Replace any character in input that is not an ASCII hex digit with the character U+0030 DIGIT ZERO (0).
</li>
	<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒
%入力 ~SET `000^l
◎
↓
</li>
	<li>
~WHILE ( %入力 の長さは 3 の倍数でない )
⇒
%入力 に ❝0 を付加する
◎
While input's length is zero or not a multiple of three, append a U+0030 DIGIT ZERO (0) character to input.
</li>
	<li>
( %R, %G, %B ) ~LET %入力 を等しい長さの 3 個の文字列に分割した結果
◎
↓
</li>
	<li>
%L ~LET %R の長さ
◎
Split input into three strings of equal length, to obtain three components. Let length be the length of those components (one third the length of input).
</li>
	<li>
<p>
~IF［
%L ~GT 8
］
</p>
		<ol>
			<li>
( %R, %G, %B ) の ~EACH( %成分 ) に対し
⇒
%成分 から頭部の ( %L ~MINUS 8 ) 個の文字を除去する
</li>
			<li>
%L ~SET 8
</li>
		</ol>
◎
If length is greater than 8, then remove the leading length-8 characters in each component, and let length be 8.
</li>
	<li>
~WHILE (
［
%L ~GT 2
］~AND［
( %R, %G, %B ) の最初の文字はいずれも ~EQ ❝0
］
)
⇒
( %R, %G, %B ) の最初の文字をいずれも除去する；<br>
%L ~DECBY 1
◎
While length is greater than two and the first character in each component is a U+0030 DIGIT ZERO (0) character, remove that character and reduce length by one.
</li>
	<li>
~IF［
%L ~GT 2
］
⇒
( %R, %G, %B ) の ~EACH( %成分 ) に対し
⇒
%成分 ~SET %成分 の最初の 2 文字までの文字列
◎
If length is still greater than two, truncate each component, leaving only the first two characters in each.
</li>
	<li>
~RET 次のようにされた`単純~色$
⇒
( ~red, ~green, ~blue )
成分 ~SET 順に，
( %R, %G, %B ) を~hex数字~列として整数に解釈した結果
◎
Let result be a simple color.
◎
Interpret the first component as a hexadecimal number; let the red component of result be the resulting number.
◎
Interpret the second component as a hexadecimal number; let the green component of result be the resulting number.
◎
Interpret the third component as a hexadecimal number; let the blue component of result be the resulting number.
◎
Return result.
</li>
</ol>


<hr>

<p class="note">注記：
<a href="~HEcanvas#canvas-context-2d">2D ~graphics文脈</a>
は、不透明度も取扱う別々の色~構文を有する。
◎
The 2D graphics context has a separate color syntax that also handles opacity.
</p>





		</section>
		<section id="space-separated-tokens">
<h3 title="Space-separated tokens">2.3.7. 空白区切りの~token列</h3>

<p>
`空白区切りの~token集合@
とは、［
1 個以上の`~ASCII空白$並び
］で互いに区切られた， 0 個以上の~tokenからなる文字列である
— ここでの~tokenとは
⇒
［
`~ASCII空白$でない 1 個以上の文字
］からなる~~任意の文字列である。
◎
A set of space-separated tokens is a string containing zero or more words (known as tokens) separated by one or more space characters, where words consist of any string of one or more characters, none of which are space characters.
</p>

<p>
`空白区切りの~token集合$は：
◎
↓</p>

<ul>
	<li>
［
頭部／尾部
］に`~ASCII空白$並びがあってもよい。
◎
A string containing a set of space-separated tokens may have leading or trailing space characters.
</li>
	<li>
その中の どの~tokenも重複していないならば、
`空白区切りの一意な~tokenからなる無順序~集合@
という。
◎
An unordered set of unique space-separated tokens is a set of space-separated tokens where none of the tokens are duplicated.
</li>
	<li>
その中の どの~tokenも重複していない, かつ
順序も有意義とされるならば、
`空白区切りの一意な~tokenからなる有順序~集合@
という。
◎
An ordered set of unique space-separated tokens is a set of space-separated tokens where none of the tokens are duplicated but where the order of the tokens is meaningful.
</li>
	<li>
文脈によっては、各~tokenに許容される集合が定義されることもある。
そのような場合、どの~tokenも，この集合に入ってい~MUST
— さもなければ、値は非~適合になる。
そのような集合が特に供されていない場合、どの~tokenも適合することになる。
◎
Sets of space-separated tokens sometimes have a defined set of allowed values. When a set of allowed values is defined, the tokens must all be from that list of allowed values; other values are non-conforming. If no such set of allowed values is provided, then all values are conforming.
</li>
</ul>

<p class="note">注記：
`空白区切りの~token集合$内の各~tokenを比較する方法（文字大小区別かどうかなど）は、~token集合ごとに定義される。
◎
How tokens in a set of space-separated tokens are to be compared (e.g. case-sensitively or not) is defined on a per-set basis.
</p>

		</section>
		<section id="comma-separated-tokens">
<h3 title="Comma-separated tokens">2.3.8. ~comma区切りの~token列</h3>

<div class="p">
<p>
`~comma区切りの~token集合@
とは、
1 個の ❝, で互いに区切られた， 0 個以上の前後~空白~可の~tokenからなる文字列である
— ここでの前後~空白~可の~tokenとは、次の並びで与えられる~~任意の文字列である：
</p>

<ol>
	<li>
0 個以上の`~ASCII空白$
</li>
	<li>
<p>
［
空であるか, または次のいずれも満たす
］ような文字列（ “~token” ）：
</p>
		<ul>
			<li>
どの文字も ❝, でない
</li>
			<li>
最初の文字 ~NIN `~ASCII空白$
</li>
			<li>
最後の文字 ~NIN `~ASCII空白$
</li>
		</ul>
	</li>
	<li>
0 個以上の`~ASCII空白$
</li>
</ol>

◎
A set of comma-separated tokens is a string containing zero or more tokens each separated from the next by a single U+002C COMMA character (,), where tokens consist of any string of zero or more characters, neither beginning nor ending with space characters, nor containing any U+002C COMMA characters (,), and optionally surrounded by space characters.
</div>


<p class="example">
具体的には、文字列 
` a ,b,,d d ^l
は、 4 個の~token［
`a^l, `b^l, 空~文字列, `d d^l
］からなる。
各~tokenの頭部と尾部の空白は、~tokenの一部をなさず，空~文字列も~tokenとされる。
◎
For instance, the string " a ,b,,d d " consists of four tokens: "a", "b", the empty string, and "d d". Leading and trailing whitespace around each token doesn't count as part of the token, and the empty string can be a token.
</p>

<p>
`~comma区切りの~token集合$には、何が妥当な~tokenを成すかについて，更なる制約が~~課されることもあり、その場合の各~tokenはその制約を満たさ~MUST。
さもなければ値は非~適合とされる。
<!-- ＊
制約が指定されていなければ，すべての値適合。
 -->
◎
Sets of comma-separated tokens sometimes have further restrictions on what consists a valid token. When such restrictions are defined, the tokens must all fit within those restrictions; other values are non-conforming. If no such restrictions are specified, then all values are conforming.
</p>

		</section>
		<section id="syntax-references">
<h3 title="References">2.3.9. 参照</h3>

<div class="p">
<p>
次の並びからなる文字列は、 %文書 内の［
`要素~型$ %型 の要素
］への
`妥当な~hash名~参照@
とされる：
</p>

<ol>
	<li>
❝#
</li>
	<li>
次を満たす %文字列
⇒
同じ`木$内に次を満たすような %要素 がある
⇒
［
%要素 の`要素~型$ ~EQ %型
］~AND［
%文字列 ~EQ %要素 の `name^a 属性の値
］
</li>
</ol>

◎
A valid hash-name reference to an element of type type is a string consisting of a U+0023 NUMBER SIGN character (#) followed by a string which exactly matches the value of the name attribute of an element with type type in the same tree.
</div>

<p class="algo-head">
文脈~node %視野 が与えられた下で，所与の文字列 %入力 を`要素~型$ %型 の要素への
`~hash名~参照として構文解析-@
する規則は、次で与えられる：
◎
The rules for parsing a hash-name reference to an element of type type, given a context node scope, are as follows:
</p>

<ol>
	<li>
~IF［
%入力 内に ❝# はない
］
⇒
~RET ~NULL
◎
↓
</li>
	<li>
%~hash ~LET %入力 内の最初の ❝# より後の文字すべてからなる文字列
◎
↓
</li>
	<li>
~IF［
%~hash ~EQ 空~文字列
］
⇒
~RET ~NULL
◎
If the string being parsed does not contain a U+0023 NUMBER SIGN character, or if the first such character in the string is the last character in the string, then return null and abort these steps.
◎
Let s be the string from the character immediately after the first U+0023 NUMBER SIGN character in the string being parsed up to the end of that string.
</li>
	<li>
<div class="p">
<p>
~IF［
次の条件すべてを満たす要素はある
］…：
</p>

<ul ><li>［
%視野 を根とする木
］内にある
</li><li>`要素~型$ ~EQ %型
</li><li>%~hash ~IN { 要素の `id$a 属性~値, 要素の `name^a 属性~値 }
</li></ul>

<p>
…ならば
⇒
~RET それらのうち `木~順序$で最初のもの
</p>

◎
Return the first element of type type in scope's tree, in tree order, that has an id or name attribute whose value is s, or null if there is no such element.
</div>

<p class="note">注記：
`id$a 属性は、構文解析-時には織り込まれるが，その値が`妥当な~hash名~参照$かどうか決定するときには利用されない。
すなわち， `id$a 属性に基づいて要素を指すような~hash名~参照は、（その要素が同じ値をとる `name^a 属性も有していない限り）適合性~errorとされる。
◎
Although id attributes are accounted for when parsing, they are not used in determining whether a value is a valid hash-name reference. That is, a hash-name reference that refers to an element based on id is a conformance error (unless that element also has a name attribute with the same value).
</p>
	</li>
	<li>
~RET ~NULL
◎
↑</li>

</ol>




		</section>
		<section id="mq">
<h3 title="Media queries">2.3.10. 媒体~query</h3>

<p>
Media Queries 仕様 `MQ$r の
`media-query-list^t <!-- ＊ -->
生成規則に合致する文字列は
`妥当な媒体~query~list@
とされる。
◎
A string is a valid media query list if it matches the &lt;media-query-list&gt; production of the Media Queries specification. [MQ]
</p>

<div class="p">
<p>
次のいずれかに該当する文字列は、
`利用者の環境に合致する@
とされる：
</p>

<ul ><li>0 個以上の`~ASCII空白$のみからなる文字列
</li><li>Media Queries 仕様による定義に則って，利用者の環境に合致するような
媒体~query~list
</li>
</ul>

◎
A string matches the environment of the user if it is the empty string, a string consisting of only space characters, or is a media query list that matches the user's environment according to the definitions given in the Media Queries specification. [MQ]
</div>


		</section>
	</section>
	<section id="urls">
<h2 title="URLs">2.4. ~URL</h2>

		<section id="terminology-2">
<h3 title="Terminology">2.4.1. 各種用語</h3>

<p>
`妥当かつ空でない~URL@
とは、空~文字列でない，`妥当な~URL文字列$である。
◎
A string is a valid non-empty URL if it is a valid URL string but it is not the empty string.
</p>

<p>
`前後~空白~可の妥当な~URL@
とは、`頭部と尾部の~ASCII空白を剥いだ$結果が`妥当な~URL文字列$になる文字列である。
◎
A string is a valid URL potentially surrounded by spaces if, after stripping leading and trailing ASCII whitespace from it, it is a valid URL string.
</p>

<p>
`前後~空白~可の妥当かつ空でない~URL@
とは、`頭部と尾部の~ASCII空白を剥いだ$結果が`妥当かつ空でない~URL$になる文字列である
。
◎
A string is a valid non-empty URL potentially surrounded by spaces if, after stripping leading and trailing ASCII whitespace from it, it is a valid non-empty URL.
</p>

<p>
この仕様は、予約済みかつ解決不能な `about_$sc ~URL `ABOUT$r として、次の~URLを定義する：
◎
↓
</p>

<dl class="def-list">
	<dt>`about_legacy-compat@sc</dt>
	<dd>
これは、~XML~toolとの互換性に必要なとき，`~HTML文書$内の `DOCTYPE$ にて利用される。
◎
This specification defines the URL about:legacy-compat as a reserved, though unresolvable, about: URL, for use in DOCTYPEs in HTML documents when needed for compatibility with XML tools. [ABOUT]
</dd>

	<dt>`about_html-kind@sc</dt>
	<dd>
これは、~media-trackの種類のための識別子として利用される。
◎
This specification defines the URL about:html-kind as a reserved, though unresolvable, about: URL, that is used as an identifier for kinds of media tracks. [ABOUT]
</dd>


	<dt>`about_srcdoc@sc</dt>
	<dd>
これは、`~iframe~srcdoc文書$の`~URL$xに利用される。
◎
This specification defines the URL about:srcdoc as a reserved, though unresolvable, about: URL, that is used as the URL of iframe srcdoc documents. [ABOUT]
</dd>
</dl>

<p class="algo-head">
`文書$0 %文書 の
`~fallback基底~URL@
は、次を走らせて得られる`~URL~record$である：
◎
The fallback base URL of a Document object document is the URL record obtained by running these substeps:
</p>

<ol>
	<li>
%閲覧文脈 ~LET %文書 が`属する閲覧文脈$
◎
↓</li>
	<li>
~IF［
%文書 は`~iframe~srcdoc文書$である
］
⇒
~RET ［［
%閲覧文脈 の`閲覧文脈~容器$
］の`~node文書$
］の`文書~基底~URL$
◎
If document is an iframe srcdoc document, then return the document base URL of document's browsing context's browsing context container's node document.
</li>
	<li>
~IF［
%文書 の`~URL$x ~EQ `about_blank$sc
］~AND［
%閲覧文脈 の`作成元~閲覧文脈$ ~NEQ ε
］
⇒
~RET %文書 の`作成元の基底~URL$
◎
If document's URL is about:blank, and document's browsing context has a creator browsing context, then return the creator base URL.
</li>
	<li>
~RET %文書 の`~URL$x
◎
Return the document's address.
</li>
</ol>

<p class="algo-head">
`文書$0 %文書 の
`文書~基底~URL@
は、次の手続きを走らせて得られる`絶対~URL$である：
◎
The document base URL of a Document object is the absolute URL obtained by running these substeps:
</p>

<ol>

	<li>
%base ~LET %文書 内の `~hrefM$a 属性を有するような `base$e 要素のうち，`木~順序$で最初のもの
◎
If there is no base element that has an href attribute in the Document, then the document base URL is the Document's fallback base URL; abort these steps.
</li>
	<li>
~RET ［
%base ~EQ ε ならば %文書 の`~fallback基底~URL$ ／
~ELSE_ %base の`凍結~基底~URL$
◎
Otherwise, the document base URL is the frozen base URL of the first base element in the Document that has an href attribute, in tree order.
</li>
</ol>



		</section>
		<section id="resolving-urls">
<h3 title="Parsing URLs">2.4.2. ~URLの構文解析</h3>

<p>
~URLの構文解析は、文字列を入力に，それが表現する`~URL~record$を得る処理-である。
この処理は WHATWG `URL$r 標準にて定義されているが、簡便にするため，~HTML標準では，それに対する~wrapperを定義する。
◎
Parsing a URL is the process of taking a string and obtaining the URL record that it represents. While this process is defined in the WHATWG URL standard, the HTML standard defines a wrapper for convenience. [URL]
</p>

<p class="note">注記：
この~wrapperは、旧来の理由から，`~URL構文解析器$に用いる文字~符号化方式を［
文書／環境~設定群~obj
］に合致させる必要がある場合にのみ有用になる。
該当しない事例では、`~URL構文解析器$を直接的に利用できる。
◎
This wrapper is only useful when the character encoding for the URL parser has to match that of the document or environment settings object for legacy reasons. When that is not the case the URL parser can be used directly.
</p>

<div class="p">
<p class="algo-head">
所与の`~URL$ %~url を，所与の %基底~obj に
`相対的に構文解析-@
するときは、以下に述べる手続きを利用し~MUST
— ここで：
</p>

<ul>
	<li>
%基底~obj は、次のいずれかである
⇒
`文書$0 ／ `環境~設定群~obj$
</li>
	<li>
`結果の~URL~record@
は、この手続きの結果として定義され，［
~error, または`~URL~record$
］になる。
</li>
	<li>
`結果の~URL文字列@
は、この手続きの結果が［
~errorならば ~error ／
~ELSE_ 結果を`~URL直列化器$にかけた結果
］として定義される。
</li>
</ul>

◎
To parse a URL url, relative to either a document or environment settings object, the user agent must use the following steps. Parsing a URL either results in failure or a resulting URL string and resulting URL record.
</div>


<ol>
	<li>
<p>
( %符号化方式, %基底~URL ) ~LET
%基底~obj に応じて，次で与えられる値：
</p>

		<dl class="switch">
			<dt>`文書$0</dt>
			<dd>
%基底~obj の
( `文書~符号化方式$, `文書~基底~URL$ )
</dd>

			<dt>`環境~設定群~obj$</dt>
			<dd>
%基底~obj により指定される
( `~API~URL符号化方式$, `~API基底~URL$ )
</dd>
		</dl>

◎
Let encoding be document's character encoding, if document was given, and environment settings object's API URL character encoding otherwise.
◎
Let baseURL be document's base URL, if document was given, and environment settings object's API base URL otherwise.
</li>
	<li>
%~URL~record ~LET
( 基底~URL：%基底~URL, 符号化方式： %符号化方式 )
を与える下で，
%~url を`~URL構文解析器$にかけた結果
◎
Let urlRecord be the result of applying the URL parser to url, with baseURL and encoding.
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~RET ~error
◎
If urlRecord is failure, then abort these steps with an error.
</li>
	<li>
~RET %~URL~record
◎
Let urlString be the result of applying the URL serializer to urlRecord.
◎
Return urlString as the resulting URL string and urlRecord as the resulting URL record.
</li>
</ol>

		</section>
		<section id="dynamic-changes-to-base-urls">
<h3 title="Dynamic changes to base URLs">2.4.3. 基底~URLに対する動的な変化</h3>

<p>
文書の
`文書~基底~URL$
が変化したとき、その文書~内のすべての要素は，その`基底~URLの変化により影響される$ `DOM$r。
◎
When a document's document base URL changes, all elements in that document are affected by a base URL change.
</p>

<p class="algo-head">
要素 %要素 が`基底~URLの変化により影響される$ときに走らす`基底~URL変更-手続き$ `DOM$r は、次で与えられる：
◎
The following are base URL change steps, which run when an element is affected by a base URL change (as defined by the DOM specification):
</p>

<dl class="switch">
	<dt>
%要素 は`~hyperlink$を作成するものである場合：
◎
If the element creates a hyperlink
</dt>
	<dd>
<p>
~IF［
その~hyperlinkにより識別される`~URL$から導出される~dataは表示に影響している（~URLは利用者に示されているなど）
］
⇒
~UAは次を行うべきである
⇒
当の `href$a 属性を %要素 の`~node文書$に`相対的に構文解析-$し直した上で，該当する~UIを適切に更新する。
◎
If the URL identified by the hyperlink is being shown to the user, or if any data derived from that URL is affecting the display, then the href attribute should be reparsed relative to the element's node document and the UI updated appropriately.
</p>

<p class="example">
例えば~CSS
`link$ps ／ `visited$ps
`疑似類$は、影響され得る。
◎
For example, the CSS :link/:visited pseudo-classes might have been affected.
</p>

<p>
~IF［
その~hyperlinkは `ping$a 属性を有する
］~AND［
その`~URL$（たち）は利用者に示されている
］
⇒
~UAは次を行うべきである
⇒
当の `ping$a 属性の各~tokenを %要素 の`~node文書$に`相対的に構文解析-$し直した上で，該当する~UIを適切に更新する。
◎
If the hyperlink has a ping attribute and its URL(s) are being shown to the user, then the ping attribute's tokens should be reparsed relative to the element's node document and the UI updated appropriately.
</p>
	</dd>

	<dt>
%要素 は `cite^a 属性を有する［
`q$e ／ `blockquote$e ／ `ins$e ／ `del$e
］要素である場合：
◎
If the element is a q, blockquote, ins, or del element with a cite attribute
</dt>
	<dd>
~IF［
`cite^a 属性から識別される`~URL$から導出される~dataは表示に影響している（~URLは利用者に示されているなど）
］
⇒
~UAは次を行うべきである
⇒
当の`~URL$を %要素 の`~node文書$に`相対的に構文解析-$し直した上で，該当する~UIを適切に更新する。
◎
If the URL identified by the cite attribute is being shown to the user, or if any data derived from that URL is affecting the display, then the URL should be reparsed relative to the element's node document and the UI updated appropriately.
</dd>

	<dt>他の場合：</dt>
	<dd>
 %要素 は直接的に影響されない。
◎
The element is not directly affected.
</dd>
	<dd class="example">
具体的には、基底~URLを変更しても，
`img$e 要素により表示されている画像には影響しない
— ~scriptからの `src$m ~IDL属性に対する後続の~accessに対しては，新たな`絶対~URL$が返されることになるが、示されている画像には対応しなくなるであろう。
◎
For instance, changing the base URL doesn't affect the image displayed by img elements, although subsequent accesses of the src IDL attribute from script will return a new absolute URL that might no longer correspond to the image being shown.
</dd>
</dl>




		</section>
	</section>
	<section id="fetching-resources">
<h2 title="Fetching resources">2.5. 資源の~fetching</h2>

`11235^bug

		<section id="terminology-3">
<h3 title="Terminology">2.5.1. 各種用語</h3>

<div>
<p>
`<a href="~FETCH#concept-network-error">~network~error</a>でない^tnote
`応答$は、次の種類に大別される
`FETCH$r ：
</p>

<dl>
	<dt>`~CORS同一生成元@</dt>
	<dd>
`種別$rs ~IN { `basic^l, `cors^l, `default^l }
なるもの。
</dd>

	<dt>`~CORS非同一生成元@</dt>
	<dd>
`種別$rs ~IN
{ `opaque^l, `opaqueredirect^l }
なるもの。
</dd>
</dl>

◎
A response whose type is "basic", "cors", or "default" is CORS-same-origin. [FETCH]
◎
A response whose type is "opaque" or "opaqueredirect" is CORS-cross-origin.
</div>


<p>
`応答$の
`非安全~応答@
は、その`内部~応答$rsが［
あれば それ ／
なければ`応答$自身
］である。
◎
A response's unsafe response is its internal response if it has one, and the response itself otherwise.
</p>

<p class="algo-head">
`~CORSになり得る要請を作成する@
ときは、所与の
( %~url, %行先, %~CORS属性~状態, %同一生成元~fallback~flag（省略時は ~OFF ）)
に対し，次を走らす：
◎
To create a potential-CORS request, given a url, destination, corsAttributeState, and an optional same-origin fallback flag, run these steps:
</p>

<ol>
	<li>
%~mode ~LET ［
%~CORS属性~状態 ~EQ `No CORS$st ならば `no-cors^l ／
~ELSE_ `cors^l
］
◎
Let mode be "no-cors" if corsAttributeState is No CORS, and "cors" otherwise.
</li>
	<li>
~IF［
%同一生成元~fallback~flag ~EQ ~ON
］~AND［
%~mode ~EQ `no-cors^l
］
⇒
%~mode ~SET `same-origin^l
◎
If same-origin fallback flag is set and mode is "no-cors", set mode to "same-origin".
</li>
	<li>
%資格証~mode ~LET `include^l
◎
Let credentialsMode be "include".
</li>
	<li>
~IF［
%~CORS属性~状態 ~EQ `Anonymous$st
］
⇒
%資格証~mode ~SET `same-origin^l
◎
If corsAttributeState is Anonymous, set credentialsMode to "same-origin".
</li>
	<li>
<p>
%要請 ~LET 次のようにされた新たな`要請$
</p>
		<ul>
			<li>
`~url$rq ~SET %~url
</li>
			<li>
`行先$rq ~SET %行先
</li>
			<li>
`~mode$rq ~SET %~mode
</li>
			<li>
`資格証~mode$rq ~SET %資格証~mode
</li>
			<li>
`~URL資格証~利用~mode$rq ~SET ~ON
</li>
		</ul>
◎
Let request be a new request whose url is url, destination is destination, mode is mode, credentials mode is credentialsMode, and whose use-URL-credentials flag is set.
</li>
</ol>

		</section>
		<section id="content-type-sniffing">
<h3 title="Determining the type of a resource">2.5.2. 資源の型の決定法</h3>

<p>
資源の
`Content-Type ~metadata@
は、
WHATWG MIME Sniffing 標準 `MIMESNIFF$r による要件に整合する方式で，得られ, 解釈-され~MUST。
◎
The Content-Type metadata of a resource must be obtained and interpreted in a manner consistent with the requirements of the WHATWG MIME Sniffing standard. [MIMESNIFF]
</p>

<p>
資源から
<a href="~MIMESNIFF#computed-mime-type"
><dfn id="computed-mime-type"
>算出される~MIME型</dfn></a>
は、 `MIMESNIFF$r に与えられる［
関連する~octet列から `sniffed media type^i を見出すための要件
］に整合する方式で，見出され~MUST。
◎
The computed MIME type of a resource must be found in a manner consistent with the requirements given in the WHATWG MIME Sniffing standard. [MIMESNIFF]
</p>

<div class="p">
<p>
次に挙げる規則も `MIMESNIFF$r にて定義され、`~MIME型$を返す：
</p>

<ul>
	<li>
<a href="~MIMESNIFF#rules-for-sniffing-images-specifically"
><dfn id="content-type-sniffing:-image"
>特に画像を~sniffする規則</dfn></a>
</li>
	<li>
<a href="~MIMESNIFF#rules-for-text-or-binary"
><dfn id="content-type-sniffing:-text-or-binary"
>資源は~textか~binaryかを判別する規則</dfn></a>
</li>
	<li>
<a href="~MIMESNIFF#rules-for-sniffing-audio-and-video-specifically"
><dfn id="content-type-sniffing:-video"
>特に音声, 動画を~sniffする規則</dfn></a>
</li>
</ul>

◎
The rules for sniffing images specifically, the rules for distinguishing if a resource is text or binary, and the rules for sniffing audio and video specifically are also defined in the WHATWG MIME Sniffing standard. These rules return a MIME type as their result. [MIMESNIFF]
</div>

<p class="warning">
`MIMESNIFF$r による規則には正確に従うことが絶対必要である。
内容~型~検知に対し，~serverが予期するものと異なる経験則を利用するような~UAにおいては、保安上の問題が生じ得る。
更なる詳細は、その仕様を見よ。
◎
It is imperative that the rules in the WHATWG MIME Sniffing standard be followed exactly. When a user agent uses different heuristics for content type detection than the server expects, security problems can occur. For more details, see the WHATWG MIME Sniffing standard. [MIMESNIFF]
</p>


		</section>
		<section id="extracting-character-encodings-from-meta-elements">
<h3 title="Extracting character encodings from meta elements">2.5.3. `meta^e 要素から文字~符号化方式を抽出する</h3>

<p class="algo-head">
`meta 要素から符号化方式を抽出する@
~algoは、所与の文字列 %入力 に対し［
`文字~符号化方式$, ε<!-- nothing  -->
］のいずれかを返す。
◎
The algorithm for extracting a character encoding from a meta element, given a string s, is as follows. It either returns a character encoding or nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let position be a pointer into s, initially pointing at the start of the string.
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
~IF［
%入力 の %位置 以降の部分に`~ASCII大小無視$で `charset^l に合致する文字列がある
］
⇒
%位置 ~SET 該当する文字列のうち，最初のものの直後を指す位置
</li>
			<li>
~ELSE
⇒
~RET ε
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
</li>
			<li>
~IF［
%位置↗ ~EQ ❝=
］
⇒
~BREAK
</li>
		</ol>
◎
Loop: Find the first seven characters in s after position that are an ASCII case-insensitive match for the word "charset". If no such match is found, return nothing and abort these steps.
◎
Skip any space characters that immediately follow the word "charset" (there might not be any).
◎
If the next character is not a U+003D EQUALS SIGN (=), then move position to point just before that next character, and jump back to the step labeled loop.
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip any space characters that immediately follow the equals sign (there might not be any).
</li>
	<li>
%符号化方式 ~LET ε
</li>
	<li>
<p>
%位置↗ に応じて：
</p>

		<dl class="switch">
			<dt>ε</dt>
			<dd>
~RET ε
</dd>
			<dt>❝"</dt>
			<dd>
				<ol>
					<li>
%符号化方式 ~SET
%入力 内の %位置 から
❝" 以外の`符号位置~並びを収集-$した結果
</li>
					<li>
~IF［
%位置↗ ~NEQ ❝"
］
⇒
~RET ε
</li>
				</ol>
</dd>
			<dt>❝'</dt>
			<dd>
				<ol>
					<li>
%符号化方式 ~SET
%入力 内の %位置 から
❝' 以外の`符号位置~並びを収集-$した結果
</li>
					<li>
~IF［
%位置↗ ~NEQ ❝"
］
⇒
~RET ε
</li>
					</ol>
</dd>
			<dt>その他</dt>
	<dd>
%符号化方式 ~SET 
%入力 内の %位置 から
{ `~ASCII空白$, ❝; }
以外の`符号位置~並びを収集-$した結果
</dd>
		</dl>
◎
Process the next character as follows:
• If it is a U+0022 QUOTATION MARK character (") and there is a later U+0022 QUOTATION MARK character (") in s
• If it is a U+0027 APOSTROPHE character (') and there is a later U+0027 APOSTROPHE character (') in s
•• Return the result of getting an encoding from the substring that is between this character and the next earliest occurrence of this character.
• If it is an unmatched U+0022 QUOTATION MARK character (")
• If it is an unmatched U+0027 APOSTROPHE character (')
• If there is no next character
•• Return nothing.
•• Return the result of getting an encoding from the substring that consists of this character up to but not including the first space character or U+003B SEMICOLON character (;), or the end of s, whichever comes first.
	</li>
	<li>
~RET ［
%符号化方式 から`符号化方式を取得-$した結果 ~NEQ `失敗^i ならば その結果 ／
~ELSE_ ε
］
◎
↑
</li>
</ol>

<p class="note">
この~algoは、~HTTP仕様のものとは別個の形をとる（例えば、~HTTPでは，一重引用符（ ❝' ）の利用は許容されず、また，この~algoが~supportしない ~backslashによる~escapeの仕組みを~supportすることが要求されている）。
この~algoは，歴史的に~HTTPに関係する文脈で利用されていたが、実装により~supportされる構文は，あるときから分岐した。
`HTTP$r
◎
This algorithm is distinct from those in the HTTP specification (for example, HTTP doesn't allow the use of single quotes and requires supporting a backslash-escape mechanism that is not supported by this algorithm). While the algorithm is used in contexts that, historically, were related to HTTP, the syntax as supported by implementations diverged some time ago. [HTTP]
</p>



		</section>
		<section id="cors-settings-attributes">
<h3 title="CORS settings attributes">2.5.4. ~CORS 設定群~属性</h3>

<p>
`~CORS設定群~属性@
は、`列挙ed属性$である。
次の表にその属性に対する，各種［
~keyword, 状態
］を挙げる。
表の一列目の~keywordは、同じ行の二列目の状態に対応付けられる。
◎
A CORS settings attribute is an enumerated attribute. The following table lists the keywords and states for the attribute — the keywords in the left column map to the states in the cell in the second column on the same row as the keyword.
</p>


<table>

<thead><tr><th>~keyword
<th>状態
<th>概要
</thead>
<!-- 
Keyword
State
Brief description
-->
<tbody><tr><td>`anonymous@v
<td>`Anonymous@st （ “匿名” ）
<td>
要素に対する`要請$の
`~mode$rqを `cors^l に,
`資格証~mode$rqを `same-origin^l
に設定する。
◎
Requests for the element will have their mode set to "cors" and their credentials mode set to "same-origin".

<tr><td>`use-credentials@v
<td>`Use Credentials@st （ “資格証を利用” ）
<td>
要素に対する`要請$の
`~mode$rqを `cors^l に,
`資格証~mode$rqを `include^l
に設定する。
◎
Requests for the element will have their mode set to "cors" and their credentials mode set to "include".
</tbody></table>

<p>
空~文字列も妥当な~keywordであり、
`Anonymous$st 状態に対応付けられる。
属性の`妥当でない値に対する既定の状態$は、 `Anonymous$st 状態である。
`反映$の目的0においては、
`Anonymous$st 状態に対する正準的な文字大小は `anonymous$v である。
属性の省略-時に利用される`値なしに対する既定の状態$は、
`No CORS@st
状態である。
◎
The empty string is also a valid keyword, and maps to the Anonymous state. The attribute's invalid value default is the Anonymous state. For the purposes of reflection, the canonical case for the Anonymous state is the anonymous keyword. The missing value default, used when the attribute is omitted, is the No CORS state.
</p>


		</section>
		<section id="referrer-policy-attributes">
<h3 title="Referrer policy attributes">2.5.5 ~referrer施策~属性</h3>

<p>
`~referrer施策~属性@
は、`列挙ed属性$である。
各 `~referrer施策$xは、空~文字列も含め，この属性に対する~keywordであり，同じ名前の状態に対応付けられる。
◎
A referrer policy attribute is an enumerated attribute. Each referrer policy, including the empty string, is a keyword for this attribute, mapping to a state of the same name.
</p>

<p>
［
`妥当でない値に対する既定の状態$,
`値なしに対する既定の状態$
］は、いずれも，空~文字列~状態とされる。
◎
The attribute's invalid value default and missing value default are both the empty string state.
</p>

<p>
これらの状態による各種`~fetch$の処理~modelへの影響0については、この仕様を通して, および
`FETCH$r `REFERRERPOLICY$r
にてより詳細に定義される。
◎
The impact of these states on the processing model of various fetches is defined in more detail throughout this specification, in the WHATWG Fetch standard, and in Referrer Policy. [FETCH] [REFERRERPOLICY]
</p>


<div class="note">
<p>注記：
所与の`~fetch$に利用される処理~modelに寄与し得る情報0には，いくつかあり、`~referrer施策~属性$は，その一つである。
一般に、これらの情報0は，次の順序で処理される：
◎
Several signals can contribute to which processing model is used for a given fetch; a referrer policy attribute is only one of them. In general, the order in which these signals are processed are:
</p>

<ol>
	<li>
先ず、~link型 `noreferrer$v の存在0。
◎
First, the presence of a noreferrer link type;
</li>
	<li>
次に、`~referrer施策~属性$の値。
◎
Then, the value of a referrer policy attribute;
</li>
	<li>
最後に、［
`Referrer-Policy$h ~headerや，
`~nameM$a 属性が `referrer$v に設定された `meta$e 要素
］を介して送達される，大域的な施策。
◎
Finally, a global policy, delivered via the `Referrer-Policy` header or a meta element with name attribute set to referrer.
</li>
</ol>

</div>



		</section>
	</section>
	<section id="common-dom-interfaces">
<h2 title="Common DOM interfaces">2.6. 共通の DOM ~interface</h2>



		<section id="reflecting-content-attributes-in-idl-attributes">
<h3 title="Reflecting content attributes in IDL attributes">2.6.1. ~IDL属性による内容~属性の反映-法</h3>

<!-- 

<div id></div>

id は指定されているのか？在するのか？

-->


<p>
一部の~IDL属性は、特定0の内容~属性を
`反映-@
するものと定義される。
これは、その~IDL属性の［
取得子 ／ 設定子
］は，内容~属性の［
現在の値を返す ／
値を所与の値に変更する
］ことを意味する。
◎
Some IDL attributes are defined to reflect a particular content attribute. This means that on getting, the IDL attribute returns the current value of the content attribute, and on setting, the IDL attribute changes the value of the content attribute to the given value.
</p>

<p>
以下，この節における
`~IDL属性@V
は、ある
`要素@V
上の，ある
`内容~属性@V
を`反映-$しているものとする。
加えて：
</p>

<ul>
	<li>
`内容~値@V
は、 `要素$V が `内容~属性$V を［
有するならば その値 ／
有さないならば ε
］とする。
</li>
	<li>
`既定~値@V
は、 `~IDL属性$V に対する既定の値が定義されて［
いるならば その値 ／
いなければ ε
］とする。
</li>
	<li>
`指定~値@V
は、 `~IDL属性$V の設定子に渡された値（~WebIDLに則って， `~IDL属性$V の型に変換された結果の値）を表すとする。
</li>
</ul>


<div class="p">
<p>
一般に，［
`内容~値$V ~EQ ε
］の下では、
`~IDL属性$V は：
</p>

<ul>
	<li>
取得子は、（他が指定されない限り）［
`内容~値$V ~EQ 空~文字列
］であったかのように動作し~MUST。
</li>
	<li>
設定子は、先ず， `要素$V に `内容~属性$V を追加し~MUST。
</li>
</ul>

◎
In general, on getting, if the content attribute is not present, the IDL attribute must act as if the content attribute's value is the empty string; and on setting, if the content attribute is not present, it must first be added.
</div>


<div class="p">

<p>
`USVString$I 型の `~IDL属性$V の挙動は、［
`内容~属性$V が 1 個の`~URL$を値にとる
］ものと定義されているならば，以下の定義に従わ~MUST：
</p>

<ul>
	<li>
<p>
取得子は、次を走らす：
</p>
		<ol>
			<li>
~IF［
`内容~値$V ~EQ ε
］
⇒
~RET 空~文字列
</li>
			<li>
%~url ~LET `内容~値$V を `要素$V の`~node文書$に`相対的に構文解析-$した`結果の~URL文字列$
</li>
			<li>
~IF ［
%~url ~NEQ ~error
］
⇒
~RET %~url
］
</li>
			<li>
~RET `内容~値$V を `USVString$I 型に変換した結果
</li>
		</ol>
</li>
	<li>
<p>
設定子は、次を走らす：
</p>
		<ol>
			<li>
`内容~属性$V の値 ~SET `指定~値$V
</li>
		</ol>
	</li>
</ul>
◎
If a reflecting IDL attribute is a USVString attribute whose content attribute is defined to contain a URL, then on getting, if the content attribute is absent, the IDL attribute must return the empty string. Otherwise, the IDL attribute must parse the value of the content attribute relative to the element's node document and if that is successful, return the resulting URL string. If parsing fails, then the value of the content attribute must be returned instead, converted to a USVString. On setting, the content attribute must be set to the specified new value.
</div>


<p>
`DOMString$I 型の `~IDL属性$V の挙動は、［
`内容~属性$V が`列挙ed属性$である
］ならば，以下の定義に従わ~MUST：
◎
↓</p>

<dl class="switch">
	<dt>
`~IDL属性$V は、ある集合 %S 内の
`既知の値のみに制限され@
ている場合：</dt>
	<dd>
<p>
取得子は、次を走らす：
</p>
		<ol>
			<li>
~IF［
`内容~値$V は［
%S 内の ある値 %V に結付けられている状態
］を表現している
］
⇒
~RET %V （ %V の文字大小は、正準的なそれとする）
</li>
			<li>
~RET 空~文字列
</li>
		</ol>

<p>
設定子は、次を走らす：
</p>
		<ol>
			<li>
`内容~属性$V の値 ~SET `指定~値$V
</li>
		</ol>
◎
If a reflecting IDL attribute is a DOMString attribute whose content attribute is an enumerated attribute, and the IDL attribute is limited to only known values, then, on getting, the IDL attribute must return the conforming value associated with the state the attribute is in (in its canonical case), if any, or the empty string if the attribute is in a state that has no associated keyword value or if the attribute is not in a defined state (e.g. the attribute is missing and there is no missing value default). On setting, the content attribute must be set to the specified new value.
</dd>

	<dt>`~IDL属性$V は~nullableである場合：</dt>
	<dd>
<p>
取得子は、次を走らす：
</p>
		<ol>
			<li>
~IF［
`内容~属性$V の状態 ~EQ `値なしに対する既定の状態$
］
⇒
~RET ~NULL
</li>
			<li>
~RET
`内容~属性$V の状態に結付けられている適合~値（正準的な文字大小とする）
</li>
		</ol>

<p>
設定子は、次を走らす：
</p>
		<ol>
			<li>
~IF［
`指定~値$V  ~EQ ~NULL
］
⇒
`要素$V から `内容~属性$V を除去する
</li>
			<li>
~ELSE
⇒
`内容~属性$V の値 ~SET `指定~値$V 
</li>
		</ol>
◎
If a reflecting IDL attribute is a nullable DOMString attribute whose content attribute is an enumerated attribute, then, on getting, if the corresponding content attribute is in its missing value default then the IDL attribute must return null, otherwise, the IDL attribute must return the conforming value associated with the state the attribute is in (in its canonical case). On setting, if the new value is null, the content attribute must be removed, and otherwise, the content attribute must be set to the specified new value.
</dd>

</dl>


<p>
上述に該当しない
`DOMString$I 型, または `USVString$I 型の `~IDL属性$V の［
取得子／設定子
］は、文字大小を保全するように透過的に［
取得する／設定する
］とする。
`すなわち、この節の冒頭に示した，一般~規則にそのまま従う。^tnote
◎
If a reflecting IDL attribute is a DOMString or USVString attribute but doesn't fall into any of the above categories, then the getting and setting must be done in a transparent, case-preserving manner.
</p>


<div class="p">
<p>
`~IDL列挙~型$xの`~IDL属性$V の挙動は、以下の定義に従わ~MUST：
</p>

<ul>
	<li>
取得子は、［
`内容~値$V ~IN ［
その列挙~型がとり得る値
］ならば その値 ／
~ELSE_ `既定~値$V 
］を返す
`したがって、既定~値は，常に定義されることになる^tnote
</li>
	<li>
設定子は、［
`内容~属性$V の値 ~SET `指定~値$V
］にする
</li>
</ul>

◎
If a reflecting IDL attribute is an IDL enumeration attribute, then, on getting, if the corresponding content attribute's value case-sensitively matches one of the enumerated values, then the IDL attribute must return the content attribute's value; otherwise it must return the content attribute's default value. On setting, the content attribute must be set to the specified new value.
</div>




<div class="p">
<p>
`boolean$I 型の `~IDL属性$V の挙動は、以下の定義に従わ~MUST：
</p>

<ul>
	<li>
<p>
取得子は、次を走らす：
</p>
		<ol>
			<li>
~IF［
`内容~値$V ~NEQ ε
］
⇒
~RET ~T
</li>
			<li>
~RET ~F
</li>
		</ol>
	</li>
	<li>
<p>
設定子は、次を走らす：
</p>
		<ol>
			<li>
~IF［
`指定~値$V ~EQ ~F
］
⇒
`要素$V 上から `内容~属性$V を除去する
</li>
			<li>
~ELSE
⇒
`内容~属性$V の値 ~SET 空~文字列
</li>
		</ol>
	</li>
</ul>

<p>
（これらは、`真偽~内容~属性$の規則に対応する。）
</p>

◎
If a reflecting IDL attribute is a boolean attribute, then on getting the IDL attribute must return true if the content attribute is set, and false if it is absent. On setting, the content attribute must be removed if the IDL attribute is set to false, and must be set to the empty string if the IDL attribute is set to true. (This corresponds to the rules for boolean content attributes.)
</div>



<p>
実数~型の `~IDL属性$V の挙動は、以下の定義に従わ~MUST：
◎
↓
</p>


<dl class="switch">
	<dt>
有符号~整数~型（ `long$I ）の `~IDL属性$V に対しては：
</dt>
	<dd>
この種の `~IDL属性$V には、
`非~負数のみに制限され@
るものもある。
◎
↓</dd>
	<dd>
<p>
取得子は、次を走らす：
</p>
		<ol>
			<li>
~IF［
`内容~値$V ~NEQ ε
］：
				<ol>
					<li>
%V ~LET `内容~値$V
</li>
					<li>
~IF［
`~IDL属性$V は`非~負数のみに制限され$ている
］
⇒
%V ~SET %V を`非~負~整数として構文解析-$した結果
</li>
					<li>
~ELSE
⇒
%V ~SET %V を`整数として構文解析-$した結果
</li>
					<li>
~IF［
%V ~NEQ ~error
］~AND［
%V ~IN `~IDL属性$V の型がとり得る範囲
］
⇒
~RET %V
</li>
				</ol>
			<li>
~IF ［
`既定~値$V ~NEQ ε
］
⇒
~RET `既定~値$V
</li>
			<li>
~RET ［
`~IDL属性$V は`非~負数のみに制限され$ているならば −1 ／
~ELSE_ 0
］
</li>
		</ol>

<p>
設定子は、次を走らす：
</p>
		<ol>
			<li>
~IF［
`~IDL属性$V は`非~負数のみに制限され$ている
］~AND［
`指定~値$V ~LT 0
］
⇒
~THROW `IndexSizeError$E
</li>
			<li>
`内容~属性$V の値 ~SET `String10$( `指定~値$V )
</li>
		</ol>
◎
If a reflecting IDL attribute has a signed integer type (long) then, on getting, the content attribute must be parsed according to the rules for parsing signed integers, and if that is successful, and the value is in the range of the IDL attribute's type, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, then the default value must be returned instead, or 0 if there is no default value. On setting, the given value must be converted to the shortest possible string representing the number as a valid integer and then that string must be used as the new content attribute value.
◎
If a reflecting IDL attribute has a signed integer type (long) that is limited to only non-negative numbers then, on getting, the content attribute must be parsed according to the rules for parsing non-negative integers, and if that is successful, and the value is in the range of the IDL attribute's type, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or −1 if there is no default value. On setting, if the value is negative, the user agent must throw an "IndexSizeError" DOMException. Otherwise, the given value must be converted to the shortest possible string representing the number as a valid non-negative integer and then that string must be used as the new content attribute value.
</dd>

	<dt>
無符号~整数~型（ `unsigned long$I ）の `~IDL属性$V に対しては：
</dt>
	<dd>
この種の `~IDL属性$V には：

<ul ><li>(A) `非~zero数に制限され@る, あるいは
</li><li>(B) `~fallbackありの下で非~zero数に制限され@る
</li></ul>

ものもある。
(B) に該当する場合、当の~fallbackが何らかの
`既定~値$V ~IN { 1 〜 2147483647 }
を与えているものとして，以下を適用する。
◎
↓</dd>

	<dd>
<p>
取得子は、次を走らす：
</p>
		<ol>
			<li>
%下限 ~LET ［
`~IDL属性$V は上述の (A), (B) いずれかに該当するならば 1 ／
~ELSE_ 0
］
</li>
			<li>
<p>
~IF［
`内容~値$V ~NEQ ε
］：
</p>
				<ol>
					<li>
%V ~LET `内容~値$V を`非~負~整数として構文解析-$した結果
</li>
					<li>
~IF［
%V ~NEQ ~error
］~AND［
%V ~IN { %下限 〜 2147483647 }
］
⇒
~RET %V
</li>
				</ol>
			</li>
			<li>
~RET［
`既定~値$V ~NEQ ε ならば `既定~値$V ／
~ELSE_ %下限
］
</li>
		</ol>

<p>
設定子は、次を走らす：
</p>
		<ol>
			<li>
%V ~LET `指定~値$V
</li>
			<li>
~IF［
`~IDL属性$V は`非~zero数に制限され$ている
］~AND［
%V ~EQ 0
］
⇒
~THROW `IndexSizeError$E
</li>
			<li>
%下限 ~LET ［
`~IDL属性$V は上述の (A), (B) いずれかに該当するならば 1 ／
~ELSE_ 0
］
</li>
			<li>
~IF［
%V ~NIN { %下限 〜 2147483647 }
］
⇒
%V ~SET ［
`既定~値$V ~NEQ ε ならば `既定~値$V ／
~ELSE_ %下限
］
</li>
			<li>
`内容~属性$V の値 ~SET `String10$( %V )
</li>
		</ol>
◎
If a reflecting IDL attribute has an unsigned integer type (unsigned long) then, on getting, the content attribute must be parsed according to the rules for parsing non-negative integers, and if that is successful, and the value is in the range 0 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 0 if there is no default value. On setting, first, if the new value is in the range 0 to 2147483647, then let n be the new value, otherwise let n be the default value, or 0 if there is no default value; then, n must be converted to the shortest possible string representing the number as a valid non-negative integer and that string must be used as the new content attribute value.
◎
If a reflecting IDL attribute has an unsigned integer type (unsigned long) that is limited to only non-negative numbers greater than zero, then the behavior is similar to the previous case, but zero is not allowed. On getting, the content attribute must first be parsed according to the rules for parsing non-negative integers, and if that is successful, and the value is in the range 1 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 1 if there is no default value. On setting, if the value is zero, the user agent must throw an "IndexSizeError" DOMException. Otherwise, first, if the new value is in the range 1 to 2147483647, then let n be the new value, otherwise let n be the default value, or 1 if there is no default value; then, n must be converted to the shortest possible string representing the number as a valid non-negative integer and that string must be used as the new content attribute value.
◎
If a reflecting IDL attribute has an unsigned integer type (unsigned long) that is limited to only non-negative numbers greater than zero with fallback, then the behavior is similar to the previous case, but disallowed values are converted to the default value. On getting, the content attribute must first be parsed according to the rules for parsing non-negative integers, and if that is successful, and the value is in the range 1 to 2147483647 inclusive, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead. On setting, first, if the new value is in the range 1 to 2147483647, then let n be the new value, otherwise let n be the default value; then, n must be converted to the shortest possible string representing the number as a valid non-negative integer and that string must be used as the new content attribute value.
</dd>

	<dt>
浮動小数点数~型（ `double$I ／ `unrestricted double$I ）の `~IDL属性$V に対しては：
</dt>
	<dd>
この種の `~IDL属性$V には、
`正数に制限され@
るものもある。
◎
↓</dd>

	<dd>
<p>
取得子は、次を走らす：
</p>
		<ol>
			<li>
<p>
~IF［
`内容~値$V ~NEQ ε
］：
</p>
				<ol>
					<li>
%V ~LET `内容~値$V を`浮動小数点数として構文解析-$した結果
</li>
					<li>
<p >
~IF［
%V ~NEQ ~error
］：
</p>
						<ol>
							<li>
~IF［
`~IDL属性$V は`正数に制限され$ていない
］~OR［
%V ~GT 0.0
］
⇒
~RET %V
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~IF ［
`既定~値$V ~NEQ ε
］
⇒
~RET `既定~値$V
</li>
			<li>
~RET 0.0
</li>
		</ol>

<p>
設定子は、次を走らす：
</p>
		<ol>
			<li>
~IF［
`~IDL属性$V は`正数に制限され$ている
］~AND［
`指定~値$V ~LTE 0
］
⇒
~RET （無視する）
</li>
			<li>
`内容~属性$V の値 ~SET `指定~値$V を`浮動小数点数として最良の表現$に変換した結果
</li>
		</ol>
◎
If a reflecting IDL attribute has a floating-point number type (double or unrestricted double), then, on getting, the content attribute must be parsed according to the rules for parsing floating-point number values, and if that is successful, the resulting value must be returned. If, on the other hand, it fails, or if the attribute is absent, the default value must be returned instead, or 0.0 if there is no default value. On setting, the given value must be converted to the best representation of the number as a floating-point number and then that string must be used as the new content attribute value.
◎
If a reflecting IDL attribute has a floating-point number type (double or unrestricted double) that is limited to numbers greater than zero, then the behavior is similar to the previous case, but zero and negative values are not allowed. On getting, the content attribute must be parsed according to the rules for parsing floating-point number values, and if that is successful and the value is greater than 0.0, the resulting value must be returned. If, on the other hand, it fails or returns an out of range value, or if the attribute is absent, the default value must be returned instead, or 0.0 if there is no default value. On setting, if the value is less than or equal to zero, then the value must be ignored. Otherwise, the given value must be converted to the best representation of the number as a floating-point number and then that string must be used as the new content attribute value.
</dd>

</dl>


<p class="note">注記：
~WebIDL仕様にて定義されるように、実数~型の~IDL属性の設定子に対する値
Infinity,  NaN（ Not-a-Number ）は、例外を投出させる。
`WEBIDL$r
◎
The values Infinity and Not-a-Number (NaN) values throw an exception on setting, as defined in the Web IDL specification. [WEBIDL]
</p>

<div class="p">
<p>
`DOMTokenList$I 型の `~IDL属性$V の挙動は、以下の定義に従わ~MUST：
</p>

<ul>
	<li>
<p>
取得子は、次を満たすような `DOMTokenList$I ~obj %O を返す：
</p>
		<ul>
			<li>
%O に
<a href="~DOM4#dtl-element">結付けられている要素</a>
~EQ `要素$V
</li>
			<li>
%O に結付けられている
<a href="~DOM4#dtl-localname">属性の局所~名</a>
~EQ `内容~属性$V の名前
</li>
		</ul>
	</li>
</ul>

◎
If a reflecting IDL attribute has the type DOMTokenList, then on getting it must return a DOMTokenList object whose associated element is the element in question and whose associated attribute's local name is the name of the attribute in question.
</div>


<p>
`HTMLElement$I 型（またはその派生型）の `~IDL属性$V の挙動は、以下の定義に従わ~MUST：
◎
If a reflecting IDL attribute has the type HTMLElement, or an interface that descends from HTMLElement, then, on getting, it must run the following algorithm (stopping at the first point where a value is returned):
</p>

<ul>
	<li>
<p>
取得子は、次を走らす：
◎
↑
</p>
		<ol>
			<li>
~IF［
`内容~値$V ~EQ ε
］
⇒
~RET ~NULL
◎
If the corresponding content attribute is absent, then the IDL attribute must return null.
</li>
			<li>
%候補 ~LET
現在の `内容~値$V を引数に渡して，［
`要素$V の`~node文書$上の `getElementById()$m ~method
］を~callした結果
◎
Let candidate be the element that the document.getElementById() method would find when called on the content attribute's element's node document if it were passed as its argument the current value of the corresponding content attribute.
</li>
			<li>
~RET ［
%候補 の型は `~IDL属性$V の型に互換ならば %候補 ／
~ELSE_ ~NULL
］
◎
If candidate is null, or if it is not type-compatible with the IDL attribute, then the IDL attribute must return null.
◎
Otherwise, it must return candidate.
</li>
		</ol>
	</li>
	<li>
<p>
設定子は、次を走らす：
</p>
		<ol>
			<li>
%新~要素 ~LET `指定~値$V
</li>
			<li>
%木 ~LET `要素$V の`木$
</li>
			<li>
~IF［
%新~要素 の`木$ ~EQ  %木
］~AND［
%新~要素 は `id$a 属性 %ID属性 を有する
］~AND［
%新~要素 ~EQ %木 内の［
`~ID$ ~EQ %ID属性 の値
］なる最初の要素
］
⇒
`内容~属性$V の値 ~SET %ID属性 の値
</li>
			<li>
~ELSE
⇒
`内容~属性$V の値 ~SET 空~文字列
</li>
		</ol>

◎
On setting, if the given element has an id attribute, and has the same tree as the element of the attribute being set, and the given element is the first element in that tree whose ID is the value of that id attribute, then the content attribute must be set to the value of that id attribute. Otherwise, the content attribute must be set to the empty string.
</li>
</ul>

		</section>
		<section id="collections">
<h3 title="Collections">2.6.2. ~collection</h3>

<p>
［
`HTMLFormControlsCollection$I ／
`HTMLOptionsCollection$I
］~interfaceは、 `HTMLCollection$I ~interfaceから派生する`~collection$である。
`HTMLAllCollection$I ~interfaceは、`~collection$であるが，そのように派生されるものではない。
◎
The HTMLFormControlsCollection and HTMLOptionsCollection interfaces are collections derived from the HTMLCollection interface. The HTMLAllCollection interface is a collection, but is not so derived.
</p>


				<section id="_collections-common-defs">
<h4 class="trans-note">2.6.2.X. 共通の定義</h4>

<p class="trans-note">【
この節は、共通の記述を集約するために，この訳に導入したものである。
】</p>

<p>
所与の［
`HTMLFormControlsCollection$I ／
`HTMLOptionsCollection$I
］~obj %C に対し：
</p>

<ul>
	<li>
“%N 番” という表記は、
%C で`表現され$る要素のうち，`木~順序$で,
0 から数えて %N 個目にある~nodeを指す。
</li>
	<li>
<p>
所与の文字列 %name に
`~IDか名前が一致する要素たち@
とは、
%C で`表現され$る要素のうち，次のいずれかを満たすものからなる `木~順序$による~listを意味する：
</p>

<ul ><li>`id$a 属性を有していて その値 ~EQ %name
</li><li>`name$a 属性を有していて その値 ~EQ %name
</li></ul>
	</li>
	<li>
<p>
`被support~prop名を収集-@
するときは、次を走らす：
</p>
		<ol>
			<li>
%~list ~LET 空~list
</li>
			<li>
<p>
%C により`表現され$る ~EACH ( %要素 ) に対し，`木~順序$で：
</p>
				<ol>
					<li>
~IF［
%要素 は `id$a 属性を有する
］~AND［
その値 %V ~NIN %~list
］~AND［
%V ~NEQ 空~文字列
］
⇒
%~list に %V を付加する
</li>
					<li>
~IF［
%要素 は `name$a 属性を有する
］~AND［
その値 %V ~NIN %~list
］~AND［
%V ~NEQ 空~文字列
］
⇒
%~list に %V を付加する
</li>
				</ol>
			</li>
			<li>
~RET %~list
</li>
		</ol>
	</li>
</ul>

<p>
`name@a
属性は、［
`option$e 要素に対しては，その `~nameO$a 属性 ／
他の要素に対しては，その `~nameF$a 属性
］を指すとする。
</p>

<p>
`新たな空option@
とは、
新たに作成される `option$e 要素であって，属性も子~nodeも伴わないものとする。
</p>



				</section>
				<section id="the-htmlallcollection-interface">
<h4 title="The HTMLAllCollection interface">2.6.2.1. `HTMLAllCollection^I ~interface</h4>

<p class="trans-note">【
この節の和訳は、省略する。
】</p>


				</section>
				<section id="the-htmlformcontrolscollection-interface">
<h4 title="The HTMLFormControlsCollection interface">2.6.2.2. `HTMLFormControlsCollection^I ~interface</h4>



<p>
`HTMLFormControlsCollection$I ~interfaceは `form$e 要素~内に`~listされる要素$からなる`~collection$に利用される。
◎
The HTMLFormControlsCollection interface is used for collections of listed elements in form elements.
</p>

<pre class="idl">
interface `HTMLFormControlsCollection@I : `HTMLCollection$I {
  // <span class="comment">`~length0$m, `item()$m を継承する</span>
  getter (`RadioNodeList$I or `Element$I)? `namedItem$m(DOMString name); // <span class="comment">継承された `~namedItem0()$m を隠蔽する</span>
};

interface `RadioNodeList@I : `NodeList$I {
  attribute DOMString `value$m;
};</pre>

<dl class="domintro">

	<dt>%collection . `length$m</dt>
	<dd>
%collection 内の要素の個数を返す。
◎
Returns the number of elements in the collection.
</dd>

	<dt>%element = %collection . `item(index)$m</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
%collection 内の %index 番の~itemを返す。
◎
Returns the item with index index from the collection. The items are sorted in tree order.
</dd>

	<dt>%element = %collection . `namedItem(name)$m</dt>
	<dt>%radioNodeList = %collection . `namedItem(name)$m</dt>
	<dt>%element = %collection[%name]</dt>
	<dt>%radioNodeList = %collection[%name]</dt>
	<dd>
%collection 内で， %name に`~IDか名前が一致する要素たち$を返す。
◎
Returns the item with ID or name name from the collection.
</dd>
	<dd>
合致する要素が複数ある場合、それらすべてからなる `RadioNodeList$I ~objが返される。
◎
If there are multiple matching items, then a RadioNodeList object containing all those elements is returned.
</dd>

	<dt>%radioNodeList . `value$m [ = %value ]</dt>
	<dd>
この~objにより表現される~radio-buttonであって，~checkされているもののうち，最初のものの値を返す。
◎
Returns the value of the first checked radio button represented by the object.
</dd>
	<dd>
設定して，~objにより表現される~radio-buttonであって， `value$a に %value を伴うもののうち，最初のものを~checkできる。
◎
Can be set, to check the first radio button with the given value represented by the object.
</dd>

</dl>


<p>
`HTMLFormControlsCollection$I ~obj %C に対しては：
</p>

<ul>
	<li>
%C の`被support~prop~index$xは、
`HTMLCollection$I ~objに対し定義されるそれになる。
◎
The object's supported property indices are as defined for HTMLCollection objects.
</li>
	<li>
%C の`被support~prop名$xは、その時点で， %C に対し`被support~prop名を収集-$した結果として定義される。
◎
The supported property names consist of the non-empty values of all the id and name attributes of all the elements represented by the collection, in tree order, ignoring later duplicates, with the id of an element preceding its name if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.
</li>
</ul>

<dl class="idl-def">
	<dt>`namedItem(name)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The namedItem(name) method must act according to the following algorithm:
</p>
		<ol>
			<li>
~IF［
%name ~EQ 空~文字列
］
⇒
~RET ~NULL
◎
If name is the empty string, return null and stop the algorithm.
</li>
			<li>
~IF［
此れ内で， %name に`~IDか名前が一致する要素たち$は 1 個だけある
］
⇒
~RET その要素
◎
If, at the time the method is called, there is exactly one node in the collection that has either an id attribute or a name attribute equal to name, then return that node and stop the algorithm.
</li>
			<li>
~IF［
此れ内で， %name に`~IDか名前が一致する要素たち$はない
］
⇒
~RET ~NULL
◎
Otherwise, if there are no nodes in the collection that have either an id attribute or a name attribute equal to name, then return null and stop the algorithm.
</li>
			<li>
~RET ［
此れ内で， %name に`~IDか名前が一致する要素たち$
］の~viewを表現するような，新たな［
`~liveである$ `RadioNodeList$I ~obj
］
◎
Otherwise, create a new RadioNodeList object representing a live view of the HTMLFormControlsCollection object, further filtered so that the only nodes in the RadioNodeList object are those that have either an id attribute or a name attribute equal to name. The nodes in the RadioNodeList object must be sorted in tree order.
◎
Return that RadioNodeList object.
</li>
		</ol>
	</dd>
</dl>


<hr>

<p>
`RadioNodeList$I ~interfaceが `NodeList$I ~interfaceから継承する~memberは、
`NodeList$I ~obj上にあるかのようにふるまわ~MUST。
◎
Members of the RadioNodeList interface inherited from the NodeList interface must behave as they would on a NodeList object.
</p>


<dl class="idl-def">
	<dt>`value@m</dt>
	<dd>
<p>
この~IDL属性の目的0においては、次に与える “下位手続き (A)” が用いられる。
それは、所与の %条件 に対し，要素 または ε を返す：
</p>
		<ol>
			<li>
<p>
~IF［
次の条件すべてを満たす要素はある
］…：
</p>

<ul ><li>この `RadioNodeList$I ~objにより`表現され$る要素である
</li><li>`input$e 要素である
</li><li>`type$a 属性は `Radio$st 状態にある
</li><li>%条件 を満たす
</li></ul>

<p>
…ならば
⇒
~RET 該当する要素のうち，`木~順序$で最初の要素
</p>
			</li>
			<li>
~RET ε
</li>
		</ol>

◎
↓</dd>
	<dd>
<p>
取得子は、次を走らせた結果を返さ~MUST：
</p>
		<ol>
			<li>
%要素 ~LET 上の下位手続き (A) に条件［
要素の`~checkedness$ ~EQ ~T
］を渡して走らせた結果
</li>
			<li>
~IF［
%要素 ~EQ ε
］
⇒
~RET ~NULL
</li>
			<li>
~RET ［
%要素 は `value$a 属性を有するならば その値 ／
~ELSE_ 文字列 `on^l
］
</li>
		</ol>
◎
The value IDL attribute on the RadioNodeList object, on getting, must return the value returned by running the following steps:
• Let element be the first element in tree order represented by the RadioNodeList object that is an input element whose type attribute is in the Radio Button state and whose checkedness is true. Otherwise, let it be null.
• If element is null, return the empty string.
• If element is an element with no value attribute, return the string "on".
• Otherwise, return the value of element's value attribute.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
</p>

		<ol>
			<li>
%要素 ~LET 上の下位手続き (A) に条件［
要素は `value$a 内容~属性を［
有する ~AND その値 ~EQ 所与の値
］~OR［
有さない ~AND 所与の値 ~EQ `on^l
］］を渡して走らせた結果
</li>
			<li>
~IF［
%要素 ~NEQ ε
］
⇒
%要素 の `~checkedness$ ~SET ~T
</li>
	</ol>

◎
On setting, the value IDL attribute must run the following steps:
• If the new value is the string "on": let element be the first element in tree order represented by the RadioNodeList object that is an input element whose type attribute is in the Radio Button state and whose value content attribute is either absent, or present and equal to the new value, if any. If no such element exists, then instead let element be null.
• Otherwise: let element be the first element in tree order represented by the RadioNodeList object that is an input element whose type attribute is in the Radio Button state and whose value content attribute is present and equal to the new value, if any. If no such element exists, then instead let element be null.
• If element is not null, then set its checkedness to true.
</dd>

</dl>


				</section>
				<section id="the-htmloptionscollection-interface">
<h4 title="The HTMLOptionsCollection interface">2.6.2.3. `HTMLOptionsCollection^I ~interface</h4>

<p>
`HTMLOptionsCollection$I ~interfaceは、
`option$e 要素たちの`~collection$に利用される。
その根は，常に `select$e 要素にされ、その子孫を操作する属性や~methodを備える。
◎
The HTMLOptionsCollection interface is used for collections of option elements. It is always rooted on a select element and has attributes and methods that manipulate that element's descendants.
</p>

  
<pre class="idl">
interface `HTMLOptionsCollection@I : `HTMLCollection$I {
  // <span class="comment">`item()$m, `~namedItem0()$m を継承する</span>
  [`CEReactions$] attribute unsigned long `length$m; // <span class="comment">継承された `~length0$m を隠蔽する</span>
  [`CEReactions$] `setter$m void (unsigned long index, `HTMLOptionElement$I? option);
  [`CEReactions$] void `add$m((`HTMLOptionElement$I or `HTMLOptGroupElement$I) element, optional (`HTMLElement$I or long)? before = null);
  [`CEReactions$] void `remove$m(long index);
  attribute long `selectedIndex$m;
};</pre>

<dl class="domintro">

	<dt>%collection . `length$m [ = %value ]</dt>
	<dd>
<p>
%collection 内の要素の個数 %N を返すことに加え：
◎
Returns the number of elements in the collection.
</p>
		<ul>
			<li>
%value ~LT %N の場合、
%collection の根~内から最後の ( %N − %value ) 個の `option$e 要素を~~削る。
◎
When set to a smaller number, truncates the number of option elements in the corresponding container.
</li>
			<li>
%value ~GT %N の場合、
%collection の根~内に ( %value − %N ) 個の`新たな空option$を追加する。
◎
When set to a greater number, adds new blank option elements to that container.
</li>
		</ul>

	</dd>

	<dt>%element = %collection . `item(index)$m</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
%collection 内の %index 番の~itemを返す。
◎
Returns the item with index index from the collection. The items are sorted in tree order.
</dd>

	<dt>%collection[%index] = %element</dt>
	<dd>
%index ~GT ( %collection 内の~itemの個数 )
の場合、
%collection の根~内に`新たな空option$を追加する。
◎
When index is a greater number than the number of items in the collection, adds new blank option elements in the corresponding container.
</dd>
	<dd>
%element ~EQ ~NULL の場合、 %collection から %index 番の~itemを除去する。
◎
When set to null, removes the item at index index from the collection.
</dd>
	<dd>
%element が `option$e 要素である場合、
%element を %collection の %index 番の~itemとして追加するか，または
%collection の %index 番の~itemを %element に置換する。
◎
When set to an option element, adds or replaces it at index index from the collection.
</dd>

	<dt>%element = %collection . `namedItem(name)$m</dt>
	<dt>%element = %collection[%name]</dt>
	<dd>
［
%collection 内で， %name に`~IDか名前が一致する要素たち$
］のうち，最初のものを返す。
◎
Returns the item with ID or name name from the collection.
◎
If there are multiple matching items, then the first is returned.
</dd>

	<dt>%collection . `add(element [, before ] )$m</dt>
	<dd>
<p>
%before 引数が指す~nodeの前に %element を挿入する：
</p>
		<ul>
			<li>
%before が数の場合、 %element は，
%collection 内の %before 番の~itemの前に挿入される
</li>
			<li>
%before が %collection 内の要素である場合、
%element はその要素の前に挿入される。
</li>
			<li>
%before が［
省略されている ／ ~NULL ／ 範囲~外の数である
］場合、 %element は~listの末尾に追加される。
</li>
		</ul>
◎
Inserts element before the node given by before.
◎
The before argument can be a number, in which case element is inserted before the item with that number, or an element from the collection, in which case element is inserted before that element.
◎
If before is omitted, null, or a number out of range, then element will be added at the end of the list.
</dd>
	<dd>
%element が 挿入-先の要素（ %collection の根）の先祖である場合、
`HierarchyRequestError$E を投出する。
◎
This method will throw a "HierarchyRequestError" DOMException if element is an ancestor of the element into which it is to be inserted.
</dd>
	<dd class="trans-note">【
%before が %collection 内にない要素である場合、
`NotFoundError$E を投出する。
】</dd>

	<dt>%collection . `remove(index)$m</dt>
	<dd>
%collection から %index 番の~itemを除去する。
◎
Removes the item with index index from the collection.
</dd>

	<dt>%collection . `selectedIndex$m [ = %value ]</dt>
	<dd>
選択されている~itemが［
あれば それらのうち最初の~itemの~index ／
なければ −1
］を返す。
◎
Returns the index of the first selected item, if any, or −1 if there is no selected item.
</dd>
	<dd>
設定して，選択を変更できる。
◎
Can be set, to change the selection.
</dd>
</dl>


<p>
`HTMLOptionsCollection$I ~objの`被support~prop~index$xは、
`HTMLCollection$I ~objに対し定義されるそれになる。
◎
The object's supported property indices are as defined for HTMLCollection objects.
</p>


<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
<p>
取得子は、此れにより`表現され$る~nodeの個数を返さ~MUST。
◎
On getting, the length attribute must return the number of nodes represented by the collection.
</p>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
</p>

		<ol>
			<li>
%select ~LET 此れの根である `select$e 要素
</li>
			<li>
%n ~LET 所与の値 − ( 此れにより`表現され$る~nodeの個数 )
</li>
			<li>
<p>
%n に応じて：
</p>
				<dl class="switch">
					<dt>%n ~EQ 0</dt>
					<dd>
何もしない
</dd>
					<dt>%n ~GT 0</dt>
					<dd>
%n 個の`新たな空option$を %select に付加した上で，
`新たな空option$を包含する `DocumentFragment$I が挿入されたかのように，変異~eventを発火する
</dd>
					<dt>%n ~LT 0</dt>
					<dd>
此れ内の最後の ( − %n ) 個の~nodeを親~nodeから除去する
</dd>
				</dl>
			</li>
		</ol>

◎
On setting, the behavior depends on whether the new value is equal to, greater than, or less than the number of nodes represented by the collection at that time. If the number is the same, then setting the attribute must do nothing. If the new value is greater, then n new option elements with no attributes and no child nodes must be appended to the select element on which the HTMLOptionsCollection is rooted, where n is the difference between the two numbers (new value minus old value). Mutation events must be fired as if a DocumentFragment containing the new option elements had been inserted. If the new value is lower, then the last n nodes in the collection must be removed from their parent nodes, where n is the difference between the two numbers (old value minus new value).
	</dd>
	<dd class="note">注記：
`optgroup$e 要素に関しては、
`length$m に何かを設定しても，［
%select 内のそれが除去される ／
%select にそれが追加される ／
%select 内のそれに新たな子が追加される
］ことは、決してない（ %select 内のそれの子は除去され得るが）。
◎
Setting length never removes or adds any optgroup elements, and never adds new children to existing optgroup elements (though it can remove children from them).
</dd>

</dl>

<p>
`HTMLOptionsCollection$I ~obj %C に対する`被support~prop名$xは、その時点で， %C に対し`被support~prop名を収集-$した結果として定義される。
◎
The supported property names consist of the non-empty values of all the id and name attributes of all the elements represented by the collection, in tree order, ignoring later duplicates, with the id of an element preceding its name if it contributes both, they differ from each other, and neither is the duplicate of an earlier entry.
</p>

<p id="dom-htmloptionscollection-setter">
~UAは、 `HTMLOptionsCollection$I ~obj %C 上で［
`新たな有index~propの値を設定する$x ／
`既存の有index~propの値を設定する$x
］ときは，所与の
( ~prop~index %index, 新たな値 %値 )
に対し、次を走らせ~MUST：
◎
When the user agent is to set the value of a new indexed property or set the value of an existing indexed property for a given property index index to a new value value, it must run the following algorithm:
</p>

<ol>
	<li>
<p>
~IF［
%値 ~EQ ~NULL
］：
</p>

<ol ><li>%index を引数に， %C 上の `remove()$m ~methodの手続きを呼出す
</li><li>~RET
</li></ol>

◎
If value is null, invoke the steps for the remove method with index as the argument, and abort these steps.
</li>
	<li>
%select ~LET %C の根である `select$e 要素
◎
↓</li>
	<li>
%n ~LET %index − ( %C により`表現され$る~nodeの個数 )
◎
Let length be the number of nodes represented by the collection.
◎
Let n be index minus length.
</li>
	<li>
~IF［
%n ~GT 0
］
⇒
( %n-1 ) 個の`新たな空option$を子に持つ `DocumentFragment$I を %select に`付加-$する
◎
If n is greater than zero, then append a DocumentFragment consisting of n-1 new option elements with no attributes and no child nodes to the select element on which the HTMLOptionsCollection is rooted.
</li>
	<li>
~IF［
%n ~GTE 0
］
⇒
%値 を %select に`付加-$する
◎
↓</li>
	<li>
~ELSE
⇒
%C 内の %index 番の要素を %値 に`置換-$する
◎
If n is greater than or equal to zero, append value to the select element. Otherwise, replace the indexth element in the collection by value.
</li>
</ol>

<dl>
	<dt>`add(element, before)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST
◎
The add(element, before) method must act according to the following algorithm:
</p>

<ol>
			<li>
%select ~LET 此れの根である `select$e 要素
</li>
			<li>
~IF［
%element は %select の先祖である
］
⇒
~THROW `HierarchyRequestError$E
◎
If element is an ancestor of the select element on which the HTMLOptionsCollection is rooted, then throw a "HierarchyRequestError" DOMException and abort these steps.
</li>
			<li>
<p>
~IF［
%before は要素である
］：
◎
↓</p>
				<ol>
					<li>
~IF［
%before は %select の子孫でない
］
⇒
~THROW `NotFoundError$E
◎
If before is an element, but that element isn't a descendant of the select element on which the HTMLOptionsCollection is rooted, then throw a "NotFoundError" DOMException and abort these steps.
</li>
					<li>
~IF［
%element ~EQ %before
］
⇒
~RET
◎
If element and before are the same element, then return and abort these steps.
</li>
				</ol>
			</li>
			<li>
~ELSE（ %before は整数である）
⇒
%before ~SET ［
此れ内に %before 番の~nodeはあるならば それ ／
~ELSE_ ~NULL
］
◎
If before is a node, then let reference be that node. Otherwise, if before is an integer, and there is a beforeth node in the collection, let reference be that node. Otherwise, let reference be null.
</li>
			<li>
%親 ~LET［
%before ~NEQ ~NULL ならば %before の親~node ／
~ELSE_ %select
］
◎
If reference is not null, let parent be the parent node of reference. Otherwise, let parent be the select element on which the HTMLOptionsCollection is rooted.
</li>
			<li>
%親 の中で， %element を %before の前に`前挿入-$する
◎
Pre-insert element into parent node before reference.
</li>
</ol>

</dd>

	<dt>`remove(index)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The remove(index) method must act according to the following algorithm:
</p>

		<ol>
			<li>
~IF［
0 ~LTE %index ~LT ( 此れにより`表現され$る~nodeの個数 )
］
⇒
此れ内の %index 番の要素をその親から除去する
◎
If the number of nodes represented by the collection is zero, abort these steps.
◎
If index is not a number greater than or equal to 0 and less than the number of nodes represented by the collection, abort these steps.
◎
Let element be the indexth element in the collection.
◎
Remove element from its parent node.
</li>
		</ol>
	</dd>

	<dt>`selectedIndex@m</dt>
	<dd>
取得子は、此れの根である `select$e 要素~上の同じ名前の~IDL属性と同様に動作し~MUST。
◎
The selectedIndex IDL attribute must act like the identically named attribute on the select element on which the HTMLOptionsCollection is rooted
</dd>
</dl>

			</section>
			</section>
			<section id="the-domstringlist-interface">
<h3 title="The DOMStringList interface">2.6.3. `DOMStringList$I ~interface</h3>

<p>
`DOMStringList$I ~interfaceは、文字列の~listを昔風の仕方で表現する。
◎
The DOMStringList interface is a non-fashionable retro way of representing a list of strings.
</p>

<pre class="idl">[Exposed=(Window,Worker)]
interface `DOMStringList@I {
  readonly attribute unsigned long `length$sL;
  getter DOMString? `item$sL(unsigned long %index);
  boolean `contains$sL(DOMString %string);
};</pre>


<p class="warning">
新たな~APIは、 `DOMStringList$I ではなく，
`sequence&lt;DOMString&gt;^c または それに等価なものを利用し~MUST。
◎
New APIs must use sequence&lt;DOMString&gt; or equivalent rather than DOMStringList.
</p>

<dl class="domintro">
	<dt>%strings . `length$sL</dt>
	<dd>
%strings が包含している文字列の個数を返す。
◎
Returns the number of strings in strings.
</dd>

	<dt>%strings[%index]</dt>

	<dt>%strings . `item(index)$sL</dt>
	<dd>
%strings 内の~index %index 番の文字列を返す。
◎
Returns the string with index index from strings.
</dd>

	<dt>%strings . `contains(string)$sL</dt>
	<dd>
%strings が %string を［
包含するならば ~T ／
~ELSE_ ~F
］を返す
◎
Returns true if strings contains string, and false otherwise.
</dd>
</dl>

<p>
各 `DOMStringList$I ~objには`~list$が結付けられる。
◎
Each DOMStringList object has an associated list.
</p>

<p>
`DOMStringList$I ~objの`被support~prop~index$xは、
{ 0  〜 ( その~listの`~size$ − 1 ) }
とする（~listが空ならば空）。
◎
The supported property indices for a DOMStringList object are the numbers zero to the associated list's size minus one. If its associated list is empty, it has no supported property indices.
</p>

<dl class="idl-def">
	<dt>`length@sL</dt>
	<dd>
取得子は、此れの~listの`~size$を返さ~MUST。
◎
The length attribute's getter must this DOMStringList object's associated list's size.
</dd>

	<dt>`item(index)@sL</dt>
	<dd>
被呼出時には、［［
%index ~LT 此れの~listの`~size$
］ならば 此れの~listの %index 番の~item ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The item(index) method, when invoked, must return the indexth item in this DOMStringList object's associated list, or null if index plus one is less than this DOMStringList object's associated list's size.
</dd>

	<dt>`contains(string)@sL</dt>
	<dd>
被呼出時には、［
此れの~listが %string を`包含-$するならば ~T ／
~ELSE_ ~F
］返さ~MUST。
◎
The contains(string) method, when invoked, must return true if this DOMStringList object's associated list contains string, and false otherwise.
</dd>
</dl>

 		</section>
		<section id="garbage-collection">
<h3 title="Garbage collection">2.6.4. ~garbage収集</h3>

<p>
存在していた（ pre-existing ） ~objを返す~IDL属性からは、その~objへの
`暗黙の強い参照@
がある。
◎
There is an implied strong reference from any IDL attribute that returns a pre-existing object to that object.
</p>

<p class="example">
例えば `window.document$m 属性は、`Window$I ~objから その `Document$I ~objへの強い参照があることを意味する。
同様に，`文書$0から子孫~nodeへの, および
~nodeから その`~node文書$への強い参照が常にある。
◎
For example, the window.document attribute means that there is a strong reference from a Window object to its Document object. Similarly, there is always a strong reference from a Document to any descendant nodes, and from any node to its node document.
</p>

		</section>
	</section>
	<section id="safe-passing-of-structured-data">
<h2 title="Safe passing of structured data">2.7. 有構造~dataの安全な渡し方</h2>

<p class="trans-note">【
この節とその下位節の和訳は
<a href="~HTMLcloning#safe-passing-of-structured-data">別ページにて</a>
】</p>


	</section>
</section>
</main><!-- id="MAIN" -->
