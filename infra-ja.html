<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Infra（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

//COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://infra.spec.whatwg.org/',
		main: 'MAIN',
		fill_text_link: '#references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170110 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		U: 'code-point',
		X: 'hex-value',
		tnote: 'trans-note'
	};

	var tag_map = {
		c: 'code',
		U: 'span',
		X: 'span',
		V: 'var',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'bl': // byte literal
	text = '`<code class="literal">' + text + '</code>`';
	break;
case 'U': // Unicode code point
	text = 'U+' + text;
	break;
case 'X': // byte value
	text = '0x' + text;
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<!--% -->
<script type="text/plain" id="_original_id_map">

</script>

<!--% リンク置換データ -->

<script type="text/plain" id="_link_map">

~byte:#byte
~byte列:#byte-sequence
文字列:#string
~ASCII~byte:#ascii-byte
符号位置:#code-point
~scalar値:#scalar-value
~ASCII符号位置:#ascii-code-point
~ASCII英字:#ascii-alpha
~ASCII英数字:#ascii-alphanumeric
~ASCII英大文字:#ascii-upper-alpha
~ASCII英小文字:#ascii-lower-alpha

~ASCII数字:#ascii-digit
~ASCII空白:#ascii-whitespace
~ASCII~tabや~ASCII改行文字:#ascii-tab-or-newline
~C0制御文字:#c0-control
~C0制御文字や~space:#c0-control-or-space
~ASCII~hex数字:#ascii-hex-digit
~ASCII~hex数字（大文字）:#ascii-upper-hex-digit
~ASCII~hex数字（小文字）:#ascii-lower-hex-digit

~ASCII文字列:#ascii-string
~ASCII大小無視:#ascii-case-insensitive
~ASCII大文字~化:#ascii-uppercase
~ASCII小文字~化:#ascii-lowercase
~byte大文字~化:#byte-uppercase
~byte小文字~化:#byte-lowercase

位置~変数:#string-position-variable
符号位置~並びを収集-:#collect-a-sequence-of-code-points
~ASCII空白を読飛ばす:#skip-ascii-whitespace
~ASCII空白で分割-:#split-on-ascii-whitespace
~commaで分割-:#split-on-commas
厳密に分割-:#strictly-split
~ASCII空白を剥いで縮約-:#strip-and-collapse-ascii-whitespace
頭部と尾部の~ASCII空白を剥ぐ:#strip-leading-and-trailing-ascii-whitespace
頭部と尾部の~ASCII空白を剥いだ:#strip-leading-and-trailing-ascii-whitespace
改行文字を剥ぐ:#strip-newlines
改行文字を剥いだ:#strip-newlines


~list:#list
~size:#list-size
~item:#list-item
包含-:#list-contain
空:#list-is-empty
~listを反復する:#list-iterate
除去-:#list-remove
付加-:#list-append
前付加-:#list-prepend

反復する:#list-iterate
反復-:#list-iterate
~EACH:#list-iterate

有順序~集合:#ordered-set
set.付加-:#set-append
set.前付加-:#set-prepend


~stack:#stack
~push:#stack-push
~pop:#stack-pop

待行列:#queue
~dequeue:#dequeue
~enqueue:#enqueue

有順序~map:#ordered-map
map.~key:#map-key
map.値:#map-value
map.~entry:#map-entry
~keyたちを取得-:#map-getting-the-keys
map.~size:#map-size
map.空:#map-is-empty
map.反復-:#map-iterate
map.~EACH:#map-iterate
map.存在-:#map-exists
map.包含-:#map-exists

~map内に存在する:#map-exists
map.取得-:#map-get
map.設定-:#map-set
map.除去-:#map-remove

継続-:#iteration-continue
~CONTINUE:#iteration-continue
~BREAK:#iteration-break


~HTML名前空間:#html-namespace
~MathML名前空間:#mathml-namespace
~SVG名前空間:#svg-namespace
~XLink名前空間:#xlink-namespace
~XML名前空間:#xml-namespace
~XMLNS名前空間:#xmlns-namespace

List:~TC39#sec-list-and-record-specification-type
</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">

</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">

	●制御
制御-:control:~
制御:control:~
終了-:terminate:~
自動的:automatic:~
再投出-:rethrow:~
投出:throw:~
継続-:continue:~
演算:operation:~
flow::::フロー
所与の:given:与えられた
call:
	~call元:caller
	~call元の:calling
例外:exception:~
遂行-:perform:~
動作:action:~
catch:
反復:iteration:~
反復-:iterate:~
手続き:steps:~
飛ばす:skip する:~
飛ばして:skip して:~
	残りの:remaining
停止-:stop:~
	各:each
条件:condition:~
合致-:match:~
演算-:operate:~
操作-:manipule:~
block::::ブロック


	●未分類
API::::
JS:JavaScript
HTML:
MathML:
SVG:
XLink:
XML:
XMLNS:
HTTP:
header::::ヘッダ
browser::::ブラウザ
mark-up:mark up:::マークアップ
名前空間:namespace::~

	●表記
二重引用符:double quotes:~
等幅:monospace::~
font::::フォント
backtick::::バッククォート
引用符:quotation marks:~
丸括弧:parentheses:~
接頭-:prefix:~
有限個の:finite:~
角括弧:square brackets:~
内側:inside:~
literal::::リテラル
comma::::カンマ
具現化-:render:~
具現化形:rendered form:~
表記法:notation:~
	表現-:represent:~
	表記-:represent:~
区切子:delimiter:~
	括って:surrounding

	●文字列
ASCII::::
Unicode:
C0:
space:
data::::データ
byte::::バイト
bit::::ビット
制御文字:control:~
数字:digit:~
hex::16 進
符号位置:code point::~
符号化方式:encoding::~
tab:
scalar::::スカラー
surrogate::::サロゲート
英字:alpha::~
英大文字:upper alpha::~
英小文字:lower alpha::~
英数字:alphanumeric::~
改行文字:newline::~
空白:whitespace::~
大小無視:case-insensitive:~
大文字:uppercase::~
小文字:lowercase::~
	~~大文字:capital letter
	~~大文字化:capitalize
構文:syntax::~
文字:character::~
文字列:string::~

構文解析-:parse::~::パース
読飛ばす:skip する:読み飛ばす
token::::トークン
縮約-:collapse::~
位置:position::~
収集-:collect::~
剥ぐ:strip する::~
剥いで:strip して::~
剥いだ:strip した::~
厳密:strict::~
緩く:lenient に:~
散在-:intersperse:~
分割-:split::~
尾部:trailing:~
頭部:leading:~
変数:variable::~
追跡-:track:~
	連続する:consecutive な／
	1 個の:single
	を満たす:meet
	1 個~以上:one or more
	先頭の文字を指している pointing at the start of 

	に加え、in addition to



	●data 構造
primitive:
data::::データ
map::::マップ
list::::リスト
stack::::スタック
待行列:queue::待ち行列::キュー
entry::::エントリ
item::::アイテム
record::::レコード
mapping::::マッピング
key::::キー
pair::::ペア
size::::サイズ
index:
indexing::::index アクセス
IDL:
push:
pop:
enqueue:
dequeue:
構造:structure::~
型:type::~
無順序:unordered::~
有順序:ordered::~
順序:order::~
空:empty::~
連列:sequence::~
集合:set::~
付加-:append::~
前付加-:prepend::~
追加-:add::~
追加の:additional::~
除去-:remove::~
更新-:update::~
取得-:get::~
設定-:set::~
存在-:exist::~
列挙:enumeration::~
検索-:look up::~
包含-:contain::~
作成-:create::~
新たな:new::~
内容:content::~
値:value::~
範囲:range::~
名前:name::~
名:name::~

	最後の:last:~
	最初の:first:~
	重ねて現れ:twice
	末尾:the end of
	先頭:the beginning of
	上の:above
	開始-:start:~
	0 番から数える:zero-based


	●仕様
algo:algorithm:::アルゴリズム

規範的:normative:~
	規範的でない:non-normative
図式:diagram:~
明示的:explicit:~
keyword::::キーワード
解釈-:interpret:~
出現-:appear:~
命令的:imperative:~
導入-:introduce:~
	意味-:mean:~
	意味:meaning:~
等価:equivalent:~
一般:general:~
実装-:implement:~
実装:implementation:~
意図-:intend:~
処理能:performance::~::パフォーマンス
		処理能を高めるperformant
排他的:exclusive:~
要件:requirements:~
注釈文:prose:~
各種用語:terminology:~
目標:goal:~
規約:conventions:~
用法:usage:~
依存-:depend:~
避ける:avoid する:~
多義性:ambiguity:~
各種用語:terminology:~
相互参照:cross-reference:~
奨励-:encourage:~
表記規約:conventions:~
適合性:conformance:~
制限-:limit:~
	読み易い:readable
	考えられる:considered
含意-:imply:~
仕様:spec:~
level::::レベル
意味論:semantics:~
際どい:edge:~
	とりわけ:especially
複雑な:complex:~
提供-:provide:~
共通の:common:~
共通して:common に:~
共通的に:common に:よく
変種:variant:~
	ある種の:certain
文脈:context:~
定義:definition:~
定義-:define:~
改変-:modify:~
特定0の:particular:ある特定の
相互運用性:interoperability:~
開発者:developer:~
公開:expose:~
最適化-:optimize:~
観測-:observe:~
	観測し得ない:not observable
事実:fact:~
	に基づいて:based on
	依然として:still
通常の:normal な:~
見做され:assume され:~
既定:default:~
指名-:designate:~
事例:case:~
web:
platform::::プラットフォーム
示唆:suggestion:~
	歓迎する:welcome
不明確:vague:~
共有-:share:~
理解:understanding:~
働いて:work して:~
上手く:well に:~
語彙:vocabulary:~
期待-:expect:~
慣例的:conventional:~
慣例:conventional:~
要求-:require:~
推奨-:recommend:~
任意選択:optional:~
文書:document:~
多義性:ambiguities:~
地盤:ground:~
一貫する:consistentになる:~
概念:concept:~
定型文:boilerplate:~
集約-:deduplicate:~
混同-:confuse:~
	confusion
既存の:existing:~
揃える:align する:~
簡便:convenient:~
	表記を簡便にする:notational convenience
由来-:originate:~
特定の:specific:~
方式:manner:~
目指す:aim する:~
築かれ:build され:~
標準:standard:~
基礎的:fundamental:~
適切:appropriate:~
策定者:author:~
正しく:correct に:~
反映-:reflect:~
依存仕様:dependencies:~
変更:changes:~
将来非互換な:future breaking:~
仕方:way:~
孕む:involve する:~

	対して，:as opposed to
	易くなる:in order to help
	-:editors
	-:ensure
	再掲:repeat:~
	用立てる:make use
	加えて:additionally:~
	別の:another
	-:ability:~
	介して:via
	複数の:multiple
	後続の:subsequent
	同じ:same
	ほとんど:almost
	表す:express
	少数の:small:~
	働きかける:working with
	言い回し:phrasing
	句され:phrase され:記され
	-:titled
	-:statement
	item
	もたらし:lead to
	~~拡張-:expand:~
	種々の:variety of
	-:explain:~
	元の:original
	置き場:place
	帰属させるには そぐわない:without a good home
	様々にしている:divergent
	-:mark

</script>


<!--%style -->
<style type="text/css">

.hex-value {
	font-family: sans-serif0, sans-serif;
}


</style>

</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>Infra — 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における
<a id="_SPEC_URL">Infra Standard</a>
を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-02-26</time>
（公開：<time>2016-11-25</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZwoJeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIKCXN0cm9rZT0iIzNjNzkwYSIKPgo8c3R5bGU+CmNpcmNsZSB7CglmaWxsOiB3aGl0ZTsKCXN0cm9rZS13aWR0aDogMTA7Cn0KcGF0aCB7CglmaWxsOiB0cmFuc3BhcmVudDsKfQpwYXRoLmRhc2hlZCB7CglzdHJva2UtZGFzaGFycmF5OiAzLDE7Cn0KPC9zdHlsZT4KCjxjaXJjbGUgY3g9IjUwIiBjeT0iNTAiIHI9IjQ1Ii8+Cgo8cGF0aCBkPSJNNTAsMTUgTDE1LDUwIEw1MCw4NSBMODUsNTAgWiIvPgo8cGF0aCBkPSJNMTUsNTAgTDQ1LDU1IEw4NSw1MCIvPgo8cGF0aCBkPSJNNTAsMTUgTDQ1LDU1IEw1MCw4NSIvPgoKPHBhdGggZD0iTTE1LDUwIEw1NSw0NSBMODUsNTAiIGNsYXNzPSJkYXNoZWQiLz4KPHBhdGggZD0iTTUwLDE1IEw1NSw0NSBMNTAsODUiIGNsYXNzPSJkYXNoZWQiLz4KPC9zdmc+Cg=="
></a>

	<hgroup>
<h1 id="title">基盤 — Infra</h1>
<h2 id="subtitle">Living Standard — 最終更新 2017 年 2 月 23 日</h2>
	</hgroup>

<dl>
	<dt>Participate:</dt>
	<dd><a href="https://github.com/whatwg/infra">GitHub whatwg/infra</a> (<a href="https://github.com/whatwg/infra/issues/new">new issue</a>, <a href="https://github.com/whatwg/infra/issues">open issues</a>)
</dd><dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>
</dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/infra/commits">GitHub whatwg/infra/commits</a>
</dd>
	<dd><a href="/commit-snapshots/8e8d83d4035e82b82e007ec26c1feecb565fb871/" id="commit-snapshot-link">Snapshot as of this commit</a>
</dd>
	<dd><a href="https://twitter.com/infrastandard">@infrastandard</a></dd>

	<dt>各国語翻訳（非規範的）</dt>
	<dd>日本語（このページ）</dd>

</dl>
</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
Infra Standard は、それを基に築かれる標準の基礎的な概念を定義することを目指す。
◎
The Infra Standard aims to define the fundamental concepts upon which standards are built.
</p>

	</section>


<main id="MAIN0">

	<section id="goals">
<h2 title="Goals">目標</h2>

<ul>
	<li>
各種 標準における定型文を集約する。
◎
Deduplicate boilerplate in standards.
</li>
	<li>
各種 標準における
規約, 各種用語, ~data構造
を揃える。
◎
Align standards on conventions, terminology, and data structures.
</li>
	<li>
複数の標準から利用されている概念のうち，それらの標準に帰属させるには そぐわないものの置き場とする。
◎
Be a place for concepts used by multiple standards without a good home.
</li>
</ul>

<p>
他にも目標の示唆があれば歓迎する。
◎
Suggestions for more goals welcome.
</p>


	</section>
	<section id="usage">
<h2 title="Usage">1. 用法</h2>

<p>
文書 %X にて Infra Standard を用立てるときは、
<q>%X  は Infra Standard に依存する。</q>
等と記す。
加えて，多義性を避けるため、各種用語を相互参照することも奨励される。
◎
To make use of the Infra Standard in a document titled X, use X depends on the Infra Standard. Additionally, cross-referencing terminology is encouraged to avoid ambiguity.
</p>

<p>
仕様の策定者には、自身の仕様を
<a href="https://github.com/whatwg/infra/wiki/Dependent-specs">この仕様に依存している仕様の~list</a>
に追加しておくことも奨励される。
そうしておけば、この仕様に将来非互換な変更が加えられても，そのような依存仕様に正しく反映させ易くなるので。
◎
Specification authors are also encouraged to add their specification to the list of dependent specifications in order to help the editors ensure that any future breaking changes to the Infra Standard are correctly reflected by any such dependencies. 
</p>

	</section>
	<section id="conventions">
<h2 title="Conventions">2. 表記規約</h2>

		<section id="conformance">
<h3 title="Conformance">2.1. 適合性</h3>

<p>
規範的でないものと明示的に記された節に加え，すべての図式, 例, 注記は、規範的ではない。
他のすべては規範的である。
◎
All diagrams, examples, and notes are non-normative, as are all sections explicitly marked non-normative. Everything else is normative.
</p>

<div class="p">
<p>
次の各種~keywordは、 `RFC2119$r に則って解釈されるものとする：
</p>

<table>
<thead><tr><th>和訳表記
<th>原語
</thead>

<tbody><tr><td>〜しなければ<em class="rfc2119">ならない</em>
<td>MUST
<tr><td>〜しては<em class="rfc2119">ならない</em>
<td>MUST NOT
<tr><td><em class="rfc2119">要求され</em>る
<td>REQUIRED
<tr><td>〜する<em class="rfc2119">ものとする</em>
<td>SHALL
<tr><td>〜しない<em class="rfc2119">ものとする</em>
<td>SHALL NOT
<tr><td>〜する<em class="rfc2119">べき</em>である
<td>SHOULD
<tr><td>〜しない<em class="rfc2119">べき</em>である
<td>SHOULD NOT
<tr><td>〜する<em class="rfc2119">べき</em>でない
<td>SHOULD NOT
<tr><td>〜することが<em class="rfc2119">推奨され</em>る
<td> RECOMMENDED
<tr><td>〜しないことが<em class="rfc2119">推奨され</em>る
<td>NOT RECOMMENDED
<tr><td><em class="rfc2119">推奨され</em>ない
<td>NOT RECOMMENDED
<tr><td>〜しても<em class="rfc2119">よい</em>
<td>MAY
<tr><td><em class="rfc2119">任意選択</em>で〜
<td>OPTIONAL

</tbody></table>

◎
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" are to be interpreted as described in RFC 2119. [RFC2119]
</div>

<p>
これらの~keywordは，小文字で記されても等価な意味になり、規範的でない内容に現れることはない†。
各種 標準は、~keywordの利用を［
"must", "must not", "should", "may"
］のみに制限すること, および それらを小文字で記す††ことが奨励される
— その方が一般に読み易いと考えられるので。
◎
These keywords have equivalent meaning when written in lowercase and cannot appear in non-normative content. Standards are encouraged to limit themselves to "must", "must not", "should", and "may", and to use these in their lowercase form as that is generally considered to be more readable.
</p>

<p class="trans-note">【†
より厳密には、現れたとしても，その内容が規範的とされるわけではない。
】【††
和訳では、これらの~keywordは ~mark-upされずに記される。
】【
和訳に固有の詳細は、
<a href="index.html#rfc2119-phrase">RFC 2119 が規定する句に利用される対訳</a>
も参照されたし。
】</p>

		</section>
		<section id="algorithms">
<h3 title="Algorithms">2.2. ~algo</h3>

<p>
~algo, あるいは ~algoの一部として命令的†に句される要件（
“頭部の空白~並びを取り除く”, “~F を返す”
など）は、当の~algoや手続きを導入するときに利用された~keyword（ “~MUST”, 等）を意味するものと解釈するものとする。
そのような~keywordが用いられていない所では “~MUST” が含意される。
◎
Algorithms, and requirements phrased in the imperative as part of algorithms (such as "strip any leading spaces" or "return false") are to be interpreted with the meaning of the keyword (e.g., "must") used in introducing the algorithm or step. If no such keyword is used, must is implied.
</p>

<p class="trans-note">【†
英語では命令形であるが、和訳では単に “現在形”。
】</p>


<div class="example" id="example-algorithms">
<p>
例えば、仕様にて，次のように記されている所では…：
◎
For example, were the spec to say:
</p>

<blockquote>
<p>
オレンジを食べるときは、次をし~MUST：
◎
To eat an orange, the user must:
</p>
<ol>
	<li>
オレンジの皮を剥く
◎
Peel the orange.
</li>
	<li>
オレンジを切り分ける
◎
Separate each slice of the orange.
</li>
	<li>
切り分けたオレンジを食べる
◎
Eat the orange slices.
</li>
</ol>
</blockquote>

<p>
…次に等価になる：
◎
it would be equivalent to the following:
</p>

<blockquote>
<p>
オレンジを食べるときは：
◎
To eat an orange:
</p>
<ol>
	<li>
オレンジの皮を剥か~MUST
◎
The user must peel the orange.
</li>
	<li>
オレンジを切り分け~MUST
◎
The user must separate each slice of the orange.
</li>
	<li>
切り分けたオレンジを食べ~MUST
◎
The user must eat the orange slices.
</li>
</ol>

</blockquote>

<p>
ここでの~keywordは “~MUST” である。
◎
Here the key word is "must".
</p>

<p>
上の例で ~algoの導入-時に，単に
“オレンジを食べるときは、次を行う”
等と記されたときも、同じく “~MUST” が含意される。
◎
Modifying the above example, if the algorithm was introduced only with "To eat an orange:", it would still have the same meaning, as "must" is implied.
</p>

</div>

<p>
~algoや特定の手続きとして句されている適合性~要件は、~~最終的な結果が等価になる限り，どのような方式で実装されても~MAY（特に、各種~algoは，追い易いように意図されており、処理能を高めることは意図されていない。）
◎
Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms are intended to be easy to follow, and not intended to be performant.)
</p>

			<section id="algorithm-control-flow">
<h4 title="Control flow">2.2.1. 制御~flow</h4>


<p class="trans-note">【
この節の内容は、和訳における ~SYMBOL_DEF_REFと重複する。
その表記規約は，この仕様が作成される以前からあり、この仕様を参照する仕様のみならず，このサイトの大多数の和訳に利用されている。
そのため、この節に定義される一部の原文~keywordは，その表記規約に整合するように違えている。
加えて、和訳では より幅広い文脈でも利用されている（例えば 下に定義される ~BREAK は、“`~EACH$(…)” 以外の反復（ ~WHILE ~blockの中など）にも利用される）。
】</p>

<p>
~algoの制御~flowにて
“~RET” ／ “~THROW （例外の投出）”
`原文では “return” ／ “throw”^tnote
として記される要件は、それが記されている~algoを終了させる。
“~RET” に値が与えられている場合、その値が~call元に渡される。
“~THROW” は，~call元でも自動的に所与の値を再投出させ，~call元の~algoも終了させる。
~call元においては、注釈文により，例外を “~catchして” 別の動作を遂行することもある。
◎
The control flow of algorithms is such that a requirement to "return" or "throw" terminates the algorithm the statement was in. "Return" will hand the given value, if any, to its caller. "Throw" will make the caller automatically rethrow the given value, if any, and thereby terminate the caller’s algorithm. Using prose the caller has the ability to "catch" the exception and perform another action.
</p>

<p>
反復の~flowは、
`~CONTINUE@
／
`~BREAK@
`原文では “continue” ／ “break”^tnote
と記される要件を介して制御できる。
`~CONTINUE$は、反復における残りの手続きを飛ばして，次の~itemの~~処理に~~移行する
— 次の~itemがなければ，そこで反復は停止する。
`~BREAK$は、反復における残りの手続きを飛ばすことに加えて，反復も停止する。
◎
An iteration’s flow can be controlled via requirements to continue or break. Continue will skip over any remaining steps in an iteration, proceeding to the next item. If no further items remain, the iteration will stop. Break will skip over any remaining steps in an iteration, and skip over any remaining items as well, stopping the iteration.
</p>


<div class="example" id="example-break-continue">

<p>
`~list$ « 1, 2, 3, 4 » 
— 以下 %list  と記す —
が与えられた下では、次の注釈文は［
1, 2, 3, 4
］の順に %演算 を遂行することになる：
◎
Let example be the list « 1, 2, 3, 4 ». The following prose would perform operation upon 1, then 2, then 3, then 4:
</p>

<ol>
	<li>
<p>
%list 内の`~EACH$( %item ) に対し：
◎
For each item in example:
</p>
		<ol>
			<li>
%item 上で %演算 を遂行する
◎
Perform operation on item.
</li>
		</ol>
	</li>
</ol>

<p>
次の注釈文は、［
1, 2, 4
］の順に %演算 を遂行し， 3 は飛ばすことになる：
◎
The following prose would perform operation upon 1, then 2, then 4. 3 would be skipped.
</p>

<ol>
	<li>
<p>
%list 内の`~EACH$( %item ) に対し：
◎
For each item in example:
</p>
		<ol>
			<li>
~IF［
%item ~EQ 3
］
⇒
`~CONTINUE$
◎
If item is 3, then continue.
</li>
			<li>
%item 上で %演算 を遂行する
◎
Perform operation on item.
</li>
		</ol>
	</li>
</ol>

<p>
次の注釈文は、［
1, 2
］の順に %演算 を遂行し，［
3, 4
］は飛ばすことになる：
◎
The following prose would perform operation upon 1, then 2. 3 and 4 would be skipped.
</p>

<ol>
	<li>
<p>
%list 内の`~EACH$( %item ) に対し：
◎
For each item in example:
</p>
		<ol>
			<li>
~IF［
%item ~EQ 3
］
⇒
`~BREAK$
◎
If item is 3, then break.
</li>
			<li>
%item 上で %演算 を遂行する
◎
Perform operation on item.
</li>
		</ol>
	</li>
</ol>

</div>


			</section>
		</section>
		<section id="terminology">
<h3 title="Terminology">2.3. 各種用語</h3>

<p>
“または”, “いずれか”
などの句（ “or” ）は、特に断らない限り，あるいは排他的としか解釈し得ない場合を除き、排他的でないとする。
排他的になるときは、
“片方”, “いずれかのみ”
等々の句でそう記される。
◎
The word "or", in cases where both inclusive "or" and exclusive "or" are possible (e.g., "if either width or height is zero"), means an inclusive "or" (implying "or both"), unless it is called out as being exclusive (with "but not both").
</p>

		</section>
	</section>
	<section id="primitive-data-types">
<h2 title="Primitive data types">3. ~primitive~data型</h2>

		<section id="bytes">
<h3 title="Bytes">3.1. ~byte</h3>

<p>
`~byte@
は、範囲 { `00^X 〜 `FF^X } に入る数を表す 8 個の~bitの並びであり、
2 桁の 16 進数で表記される，
◎
A byte is a sequence of eight bits, represented as a double-digit hexadecimal number in the range 0x00 to 0xFF, inclusive.
</p>


<p>
`~ASCII~byte@
は、範囲 { `00^X 〜 `7F^X } に入る`~byte$である。
◎
An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.
</p>

		</section>
		<section id="byte-sequences">
<h3 title="Byte sequences">3.2. ~byte列</h3>


<p>
`~byte列@
は、一連の~byteを~spaceで区切って表記される。
どの~byteも範囲 { `00^X 〜 `7F^X } 内に入る~byte列は，文字列としても記され得るが、実際の`文字列$と混同されないよう，引用符に代えて ~backtick（ backtick, "`" ）で括られる。
◎
A byte sequence is a sequence of bytes, represented as a space-separated sequence of bytes. Byte sequences with bytes in the range 0x00 to 0x7F, inclusive, can alternately be written as a string, but using backticks instead of quotation marks, to avoid confusion with an actual string.
</p>

<div class="example" id="example-byte-sequence-notation">

<p>
~byte列［
`48^X `49^X
］は、 `HI^bl とも表記される。
◎
0x48 0x49 can also be represented as `HI`.
</p>

<p>
`Content-Type^bl などの~HTTP~headerは、`~byte列$である。
◎
Headers, such as `Content-Type`, are byte sequences.
</p>

<p class="trans-note">【
和訳では，~HTTP~header名のような英語~keywordに対しては、`文字列$との区別が重要でない所では，~backtickは省略することもある。
特に，日本語~表記の下では、地の文との区別は容易なので。
】</p>

</div>


<ul>
	<li>
`~byte列$を
`~byte小文字~化@
するときは、 { `41^X 〜 `5A^X } に入る ~EACH ( ~byte ) に対し， `20^X を加算する。
◎
To byte-lowercase a byte sequence, increase each byte it contains, in the range 0x41 to 0x5A, inclusive, by 0x20.
</li>
	<li>
`~byte列$を
`~byte大文字~化@
するときは、 { `61^X 〜 `7A^X } に入る ~EACH ( ~byte ) に対し， `20^X を減算する。
◎
To byte-uppercase a byte sequence, subtract each byte it contains, in the range 0x61 to 0x7A, inclusive, by 0x20.
</li>
</ul>

<p class="trans-note">【
（参考） ~byte列による値は、~IDLにおいては `ByteString^c 型で表現される。
】</p>

		</section>
		<section id="code-points">
<h3 title="Code points">3.3. 符号位置</h3>

<p>
`符号位置@
（ code point ）†は~Unicode符号位置であり， 4 〜 6 桁の 16 進数で表記される††。
概して "U+" が前置されるが、後続して［
~~大文字による`符号位置$の名前†††, および
丸括弧で括られた`符号位置$の具現化形
］も与えられることが多い。
`UNICODE$r
◎
A code point is a Unicode code point and is represented as a four-to-six digit hexadecimal number, typically prefixed with "U+". Often the name of the code point is also included in capital letters afterward, potentially with the rendered form of the code point in parentheses. [UNICODE]
</p>

<p class="trans-note">【†
訳語の “~~符号位置” は~Unicode特有であり，他の符号化方式の “符号点” に該当する。
】【††
範囲は `0000^U 〜 `10FFFF^U
】【†††
和訳では，特に~ASCII範囲の可視の`符号位置$については、その名前（例 ： "LATIN CAPITAL LETTER A" ）は，ほとんどの箇所では省略して 具現化形のみにしている。
やたら長いものが多く, 同じ箇所に繰り返し現れることも多く，可読性を損なうので。
】</p>


<p class="example" id="example-code-point-notation">
🤔 と具現化される`符号位置$は、 `1F914^U と表記される。
この`符号位置$を指すときは、
"`1F914^U THINKING FACE (🤔)"
とも表記される。
◎
The code point rendered as 🤔 is represented as U+1F914.
◎
When referring to that code point, we might instead say "U+1F914 THINKING FACE (🤔)", instead of just "U+1F914", to provide extra context.
</p>

<p>
文脈によっては、`符号位置$には "U+" に代えて "0x" が接頭される。
◎
In certain contexts code points are prefixed with "0x" instead of "U+".
</p>

<p>
次の各種 符号位置の集合が定義される：
◎
↓</p>

<dl class="def-list">
	<dt>
`~scalar値@
◎
A scalar value
</dt>
	<dd>
範囲
{ `D800^U 〜 `DFFF^U }
に入らない`符号位置$
◎
is a code point that is not in the range U+D800 to U+DFFF, inclusive.
</dd>
	<dd class="trans-note">【
すなわち，代用対（ surrogate pair ）を成さない`符号位置$
】</dd>

	<dt>
`~ASCII符号位置@
◎
An ASCII code point
</dt>
	<dd>
{ `0000^U 〜 `007F^U }
◎
is a code point in the range U+0000 to U+007F, inclusive.
</dd>

	<dt>
`~ASCII~tabや~ASCII改行文字@
◎
An ASCII tab or newline
</dt>
	<dd>
{ `0009^U, `000A^U, `000D^U }
◎
is U+0009, U+000A, or U+000D.
</dd>

	<dt>
`~ASCII空白@
◎
An ASCII whitespace
</dt>
	<dd>
{ `0009^U, `000A^U, `000C^U, `000D^U, `0020^U }
◎
is U+0009, U+000A, U+000C, U+000D, or U+0020.
</dd>
	<dd class="note">注記：
空白（ whitespace ）は数えられない名詞（ mass noun ）である。
`したがって、複数個あり得る場合でも原文では単数形で記される。^tnote
◎
"Whitespace" is a mass noun. 
</dd>

	<dt>
`~C0制御文字@
◎
A C0 control
</dt>
	<dd>
{ `0000^U 〜 `001F^U }
◎
is a code point in the range U+0000 to U+001F, inclusive.
</dd>

	<dt>
`~C0制御文字や~space@
◎
A C0 control or space
</dt>
	<dd>
{ `~C0制御文字$, `0020^U }
◎
is a C0 control or U+0020.
</dd>

	<dt>
`~ASCII数字@
◎
An ASCII digit
</dt>
	<dd>
{ `0030^U 〜 `0039^U }
◎
is a code point in the range U+0030 to U+0039, inclusive.
</dd>

	<dt>
`~ASCII~hex数字（大文字）@
◎
An ASCII upper hex digit
</dt>
	<dd>
{ `~ASCII数字$, `0041^U 〜 `0046^U }
◎
is an ASCII digit or a code point in the range U+0041 to U+0046, inclusive.
</dd>

	<dt>
`~ASCII~hex数字（小文字）@
◎
An ASCII lower hex digit
</dt>
	<dd>
{ `~ASCII数字$, `0061^U 〜 `0066^U }
◎
is an ASCII digit or a code point in the range U+0061 to U+0066, inclusive.
</dd>

	<dt>
`~ASCII~hex数字@
◎
An ASCII hex digit
</dt>
	<dd>
{ `~ASCII数字$, `0041^U 〜 `0046^U , `0061^U 〜 `0066^U }
◎
is an ASCII upper hex digit or ASCII lower hex digit.
</dd>

	<dt>
`~ASCII英大文字@
◎
An ASCII upper alpha
</dt>
	<dd>
{ `0041^U 〜 `0046^U }
◎
is a code point in the range U+0041 to U+005A, inclusive.
</dd>

	<dt>
`~ASCII英小文字@
◎
An ASCII lower alpha
</dt>
	<dd>
{ `0061^U 〜 `0066^U }
◎
is a code point in the range U+0061 to U+007A, inclusive.
</dd>

	<dt>
`~ASCII英字@
◎
An ASCII alpha
</dt>
	<dd>
{ `~ASCII英小文字$, `~ASCII英大文字$ }
◎
is an ASCII upper alpha or ASCII lower alpha.
</dd>

	<dt>
`~ASCII英数字@
◎
An ASCII alphanumeric
</dt>
	<dd>
{ `~ASCII数字$, `~ASCII英字$ }
◎
is an ASCII digit or ASCII alpha.
</dd>
</dl>

		</section>
		<section id="strings">
<h3 title="Strings">3.4. 文字列</h3>

<p>
`文字列@
とは、符号位置の並びである。
`文字列$は二重引用符で括って記され，等幅~fontで表される。
◎
A string is a sequence of code points. Strings are denoted by double quotes and monospace font.
</p>

<p class="example" id="example-string-notation">
`Hello, world!^l は文字列である。
◎
"Hello, world!" is a string.
</p>

<p>
`~ASCII文字列@
は、すべての文字が`~ASCII符号位置$のみからなる`文字列$である。
◎
An ASCII string is a string whose code points are all ASCII code points.
</p>

<ul>
	<li>
`文字列$を
`~ASCII小文字~化@
するときは、`文字列$内の各`~ASCII英大文字$を，それぞれに対応する`~ASCII英小文字$に置換する。
◎
To ASCII lowercase a string, replace all ASCII upper alphas in the string with their corresponding code point in ASCII lower alpha.
</li>
	<li>
`文字列$を
`~ASCII大文字~化@
するときは、`文字列$内の各`~ASCII英小文字$を，それぞれに対応する`~ASCII英大文字$に置換する。
◎
To ASCII uppercase a string, replace all ASCII lower alphas in the string with their corresponding code point in ASCII upper alpha.
</li>
	<li>
<p>
2 つの`文字列$が
`~ASCII大小無視@
で合致するとは、それぞれを`~ASCII小文字~化$した結果が同じになることを意味する。
◎
A string A is an ASCII case-insensitive match for a string B, if the ASCII lowercase of A is the ASCII lowercase of B.
</p>

<p class="trans-note">【
和訳では、`文字列$ %A, %B が`~ASCII大小無視$で合致することを，
“ %A ~EQ<sub>大小無視</sub> %B ”
とも表記する。
】【
和訳では、`~ASCII大小無視$の代わりに`~ASCII小文字~化$（または大文字~化）を利用して，等価な記述に変形することもある（そうした方が記述が簡潔になる所など）。
】</p>
	</li>
</ul>

<hr>

<p class="algo-head">
`文字列$ %S から
`改行文字を剥ぐ@
ときは、
{ `000A^U LINE FEED, `000D^U CARRIAGE RETURN }
に入る`符号位置$すべてを
%S から除去する。
◎
To strip newlines from a string, remove any U+000A LINE FEED and U+000D CARRIAGE RETURN code points from the string.
</p>

<p class="algo-head">
`文字列$ %S から
`頭部と尾部の~ASCII空白を剥ぐ@
ときは、 %S の［
先頭, 末尾
］から連続するすべての`~ASCII空白$を除去する。
◎
To strip leading and trailing ASCII whitespace from a string, remove all ASCII whitespace that are at the start or the end of the string.
</p>

<p class="algo-head">
`文字列$ %S に対し
`~ASCII空白を剥いで縮約-@
するときは、 %S 内の［
1 個~以上~連続する`~ASCII空白$並び
］すべてを，それぞれ［
1 個の`符号位置$ `0020^U SPACE
］に置換した上で、
%S の［
先頭／末尾
］に `0020^U SPACE があれば，それを除去する。
◎
To strip and collapse ASCII whitespace in a string, replace any sequence of one or more consecutive ASCII whitespace in the string with a single U+0020 SPACE code pooint, and then remove any leading and trailing ASCII whitespace from that string.
</p>

<p class="trans-note">【
“`~ASCII大文字~化$した結果” ／
“`~ASCII小文字~化$した結果” ／
“`改行文字を剥いだ$結果” ／
“`頭部と尾部の~ASCII空白を剥いだ$結果”  ／
“`~ASCII空白を剥いで縮約-$した結果” 
と記されたときは、元の文字列は改変せずに，その複製に対し演算した結果を返す。
】</p>

<hr>

<div >
<p>
この仕様, および
この仕様を参照する仕様が定義する，文字列を構文解析する いくつかの~algoは、次の変数を利用する：
</p>

<ul>
	<li>
通例的に %入力 と命名される，構文解析される文字列を保持する変数。
</li>
	<li>
通例的に %位置 と命名される
`位置~変数@
は、 %入力 の中の位置を追跡し，次に構文解析する文字を指す。
それは、内部的には整数であり，増減操作の対象になる。
</li>
	<li>
<span class="trans-note">【
加えて、和訳では次の表記も用いる：
】</span>
%位置↗ という表記は、 %位置 が指している文字を表すとする。
%位置 が %入力 の外を指している場合の
%位置↗ は、特殊~値 ε をとるものとする。
</li>
</ul>

◎
↓</div>

<p class="algo-head">
`文字列$ %入力 内の［
~call元~algoの`位置~変数$ %位置
］から条件 %条件 を満たす
`符号位置~並びを収集-@
するときは：
◎
To collect a sequence of code points meeting a condition condition from a string input, given a position variable position tracking the position of the calling algorithm within input:
</p>

<ol>
	<li>
%結果 ~LET 空`文字列$
◎
Let result be the empty string.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］~AND［
%位置↗ は %条件 を満たす
］：
◎
While position doesn’t point past the end of input and the code point at position within input meets the condition condition:
</p>
		<ol>
			<li>
%結果 の末尾に %位置↗ を付加する
◎
Append that code point to the end of result.
</li>
			<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="note">注記：
収集された`符号位置$を返すことに加え、この~algoは，~call元~algoの`位置~変数$を更新する。
◎
Note how in addition to returning the collected code points, this algorithm updates the position variable in the calling algorithm.
</p>

<p class="trans-note">【
この~algoに対する %入力, %位置 は省略して~callされることもある。
その場合、~call元の同じ名前の変数を暗黙的に指すことになる。
次の`~ASCII空白を読飛ばす$についても同様。
】</p>

<p class="algo-head">
`文字列$ %入力 内の［
~call元~algoの`位置~変数$ %位置
］から
`~ASCII空白を読飛ばす@
ときは、
%入力 内の %位置 から
`~ASCII空白$からなる`符号位置~並びを収集-$する。
収集された結果は利用されないが、 %位置 は更新される。
◎
To skip ASCII whitespace within a string input given a position variable position, collect a sequence of code points that are ASCII whitespace from input given position. The collected code points are not used, but position is still updated.
</p>

<hr>

<p class="algo-head">
`文字列$ %入力 を［
特定0の`符号位置$である区切子 %区切子
］で
`厳密に分割-@
するときは：
◎
To strictly split a string input on a particular delimiter code point delimiter:
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%~token~list ~LET 新たな空`~list$（`文字列$からなる）
◎
Let tokens be a list of strings, initially empty.
</li>
	<li>
%~token ~LET 
%入力 内の %位置 から
%区切子 以外の`符号位置~並びを収集-$した結果
◎
Let token be the result of collecting a sequence of code points that are not equal to delimiter from input, given position.
</li>
	<li>
%~token~list に %~token を`付加-$する
◎
Append token to tokens.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%位置 ~INCBY 1
— これは、区切子を読飛ばす。
◎
Advance position to the next code point in input. (This skips past the delimiter.)
</li>
			<li>
%~token ~LET
%入力 内の %位置 から
%区切子 以外の`符号位置~並びを収集-$した結果
◎
Let token be the result of collecting a sequence of code points that are not equal to delimiter from input, given position.
</li>
			<li>
%~token~list に %~token を`付加-$する
◎
Append token to tokens.
</li>
		</ol>
	</li>
	<li>
~RET %~token~list
◎
Return tokens.
</li>
</ol>

<p class="note">注記：
この~algoは、 “厳密に” 分割する
— 対して，後述の共通的に利用される変種［
`~ASCII空白で分割-$,
`~commaで分割-$
］は いずれも、散在する`~ASCII空白$を種々の仕方で孕むように，より “緩く” 分割する。
◎
This algorithm is a "strict" split, as opposed to the commonly-used variants for ASCII whitespace and for commas below, which are both more lenient in various ways involving interspersed ASCII whitespace.
</p>

<p class="algo-head">
`文字列$ %入力 を
`~ASCII空白で分割-@
するときは：
◎
To split a string input on ASCII whitespace:
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%~token~list ~LET 新たな空`~list$（`文字列$からなる）
◎
Let tokens be a list of strings, initially empty.
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
	<li>
%~token~list に %~token を`付加-$する
◎
Append token to tokens.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%~token ~LET 
%入力 内の %位置 から
`~ASCII空白$以外の`符号位置~並びを収集-$した結果
◎
Let token be the result of collecting a sequence of code points that are not ASCII whitespace from input, given position.
</li>
			<li>
%~token~list に %~token を`付加-$する
◎
Append token to tokens.
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
		</ol>
	</li>
	<li>
~RET %~token~list
◎
Return tokens.
</li>
</ol>

<p class="algo-head">
`文字列$ %入力 を
`~commaで分割-@
するときは：
◎
To split a string input on commas:
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%~token~list ~LET 新たな空`~list$（`文字列$からなる）
◎
Let tokens be a list of strings, initially empty.
</li>
	<li>

<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>

<p>
%~token ~LET 
%入力 内の %位置 から
`002C^U （ `,^l ）でない
`符号位置~並びを収集-$した結果
◎
Let token be the result of collecting a sequence of code points that are not U+002C COMMA (,) from input, given position.
</p>

<p class="note">注記：
%~token は、空~文字列にもなり得る。
◎
token might be the empty string.
</li>
			<li>
%~token から`頭部と尾部の~ASCII空白を剥ぐ$
</li>
			<li>
%~token~list に %~token を`付加-$する
◎
Append token to tokens.
</li>
			<li>
<p>
~IF［
%位置↗ ~NEQ ε
］：
◎
If position is not past the end of input, then:
</p>
				<ol>
					<li>
~Assert：
%位置↗ ~EQ `002C^U （ `,^l ）
◎
Assert: the code point at position within input is U+002C COMMA (,).
</li>
					<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~token~list
◎
Return tokens.
</li>
</ol>

		</section>
	</section>

	<section id="data-structures">
<h2 title="Data structures">4. ~data構造</h2>

<p class="trans-note">【
<a href="#algorithm-control-flow">制御~flow</a>
節の冒頭に述べたのと同じ理由で、この節に現れる記号［
ε , ~EACH( … ), ~IN, ~NIN, ~SET
］は，和訳に固有の表記である。
】</p>

<p>
仕様は、慣例的に，共有されている意味論の理解に基づいて
種々の不明確な仕様~levelの~data構造に対し演算していた。
これは，一般に上手く働いているが、際どい事例では多義性をもたらし得る
— 反復の順序，あるいは
~itemを`有順序~集合$に`付加-$setするとき，その集合が`~item$をすでに`包含-$していた場合に何が起こるかなど。
それはまた、表記法や言い回しを様々にしている
— とりわけ，`有順序~map$のような より複雑な~data構造の周りで。
◎
Conventionally, specifications have operated on a variety of vague specification-level data structures, based on shared understanding of their semantics. This generally works well, but can lead to ambiguities around edge cases, such as iteration order or what happens when you append an item to an ordered set that the set already contains. It has also led to a variety of divergent notation and phrasing, especially around more complex data structures such as maps.
</p>

<p>
この標準は、共通の地盤を作成するため，共通して用いられる 少数の~data構造，および それらに働きかけるための 表記法や言い回しを提供する。
◎
This standard provides a small set of common data structures, along with notation and phrasing for working with them, in order to create common ground.
</p>

		<section id="lists">
<h3 title="Lists">4.1. ~list</h3>

<p>
`~list@
は、有限個の
`~item@
からなる有順序~連列を表す，仕様~levelの型である。
◎
A list is a specification type consisting of a finite ordered sequence of items.
</p>

<p>
表記を簡便にするため、`~list$を表す~literal構文も利用できる
— そのためには、各~list`~item$どうしを~commaで区切った上で, 全体を «, » で括る。
~listに対する ~indexing構文も利用できる
— そのためには，角括弧（ [, ] ）の内側に 0 番から数える~indexを与える。
◎
For notational convenience, a literal syntax can be used to express lists, by surrounding the list contents by « » characters and separating list items with a comma. An indexing syntax can be used by providing a zero-based index into a list inside square brackets.
</p>

<p class="example" id="example-list-notation">
%example ~EQ
`~list$ « `a^l, `b^l, `c^l, `a^l »
が与えられた下では、
%example[1] は `文字列$ `b^l を表す。
◎
Let example be the list « "a", "b", "c", "a" ». Then example[1] is the string "b".
</p>

<hr>

<ul>
	<li>
所与の`~item$ %item を`有順序~集合$でない`~list$ %L に
`付加-@
するときは、%item を %L の末尾に追加する。
◎
To append to a list that is not an ordered set is to add the given item to the end of the list.
</li>
	<li>
<p>
所与の`~item$ %item を`有順序~集合$でない`~list$ %L に
`前付加-@
するときは、%item を %L の先頭に追加する。
◎
To prepend to a list that is not an ordered set is to add the given item to the beginning of the list.
</p>

<p class="note">注記：
`~list$が`有順序~集合$でもあるときには、上の定義は改変される
— 下に与える［
`付加-$set ／ `前付加-$set
］を見よ。
◎
The above definitions are modified when the list is an ordered set; see below for ordered set append and ordered set prepend.
</p>
	</li>
	<li>
<p>
`~list$ %L から所与の %条件 に合致する`~item$ %item を
`除去-@
するときは、 %L から %条件 に合致する %item すべてを除去する。
◎
To remove an item from a list is to remove all items from the list that match a given condition, or do nothing if none do.
</p>

<div class="example" id="example-list-remove">
<p>
%L ~EQ `~list$ « %x, %y, %z, %x »
から %x を`除去-$するときは、
%L から %x に等しいすべての~itemを除去する。
結果の %L は、 « %y, %z » に等価になる。
◎
Removing x from the list « x, y, z, x » is to remove all items from the list that are equal to x. The list now is equivalent to « y, z ».
</p>

<p>
%L ~EQ `~list$ « `a^l, `b^l, `ab^l, `ba^l »
から［
`文字列$ `a^l で開始する~item
］すべてを`除去-$するときは、~item［
`a^l,  `ab^l
］を除去する。
結果の %L は、 « `b^l, `ba^l » に等価になる。
◎
Removing all items that start with the string "a" from the list « "a", "b", "ab", "ba" » is to remove the items "a" and "ab". The list is now equivalent to « "b", "ba" ».
</p>
</div>
 	</li>
	<li>
<p>
`~list$ %L が`~item$ %item を
`包含-@
するとは、 %L 内に %item が現れることをいう。
</p>

<p>
“ %item ~IN %L ”
とも表記される。
その否定は、
“ %item ~NIN %L ”
と表記される。
</p>

◎
A list contains an item if it appears in the list.
</li>
	<li>
`~list$ %L の
`~size@
とは、 %L が`包含-$する`~item$の個数をいう。
`重複するものも別々に数える。^tnote
◎
A list’s size is the number of items the list contains.
</li>
	<li>
`~list$ %L が
`空@
であるとは、［
%L の`~size$ ~EQ 0
］であることをいう。
◎
A list is empty if its size is zero.
</li>
	<li>
`~list$ %L 内の各`~item$に対し~list順に，一連の段を遂行するように
`反復-@
するときは、
“ %L 内の`~EACH$( %item ) に対し：”
という句の下で，後続の注釈文にて %item に対し演算する。
◎
To iterate over a list, performing a set of steps on each item in order, use phrasing of the form "For each item of list", and then operate on item in the subsequent prose.
</li>
</ul>


<hr>

<p>
`~list$型は、~JS仕様に由来する（その仕様では、 "`List$" と~~大文字化されている）。
ここでは、参照し易くするため，その定義を再掲して、`~list$を操作するための語彙を~~拡張する。
~JSが`List$を期待する所では、ここに定義される`~list$を利用できる
— それらは同じ型である。
`ECMA-262$r
◎
The list type originates from the JavaScript specification (where it is capitalized, as List); we repeat some elements of its definition here for ease of reference, and provide an expanded vocabulary for manipulating lists. Whenever JavaScript expects a List, a list as defined here can be used; they are the same type. [ECMA-262]
</p>

			<section id="stacks">
<h4 title="Stacks">4.1.1. ~stack</h4>

<p>
`~list$は，
`~stack@
であると指名されることもある。
~stackは`~list$であるが、［
`付加-$ ／ `前付加-$ ／ `除去-$
］を用いる代わりに，以下に定義する句を用いて演算するのが慣例である。
◎
Some lists are designated as stacks. A stack is a list, but conventionally, the following operations are used to operate on it, instead of using append, prepend, or remove.
</p>

<ul>
	<li>
`~stack$ %S に %item を
`~push@
するときは、 %item を %S に`付加-$する
◎
To push onto a stack is to append to it.
</li>
	<li>
`~stack$ %S から
`~pop@
するときは、
%S が`空$でないならば %S の最後の`~item$ %item を`除去-$した上で，
%item を返す。
%S が`空$の場合は，何もせず ε を返す†。
◎
To pop from a stack is to remove its last item and return it, if the stack is not empty, or to return nothing otherwise.
</li>
</ul>

<p class="trans-note">【†
原文では “return nothing” 。
通例的には “何も返さない” と訳される所であるが、あたかも，  “ε（ nothing ）” という何もないことを表現する特別な定数があって，それを返すものと解釈しても矛盾することはなく、そうした方が表記するに都合が良いので，そのようにしている。
】</p>

			</section>
			<section id="queues">
<h4 title="Queues">4.1.2. 待行列</h4>

<p>
`~list$は
`待行列@
（ queue ）であると指名されることもある。
待行列は`~list$であるが、［
`付加-$ ／ `前付加-$ ／ `除去-$
］を用いる代わりに，以下に定義する句を用いて演算するのが慣例である。
◎
Some lists are designated as queues. A queue is a list, but conventionally, the following operations are used to operate on it, instead of using append, prepend, or remove.
</p>

<ul>
	<li>
`待行列$ %Q に %item を
`~enqueue@
するときは、 %item を %Q に`付加-$する
◎
To enqueue in a queue is to append to it.
</li>
	<li>
`待行列$ %Q から
`~dequeue@
するときは、
%Q が`空$でないばらば， %Q から最初の`~item$ %item を`除去-$した上で
%item を返す。
%Q が`空$ならば、何もせず ε 返す。
◎
To dequeue from a queue is to remove its first item and return it, if the queue is not empty, or to return nothing if it is.
</li>
</ul>

			</section>
			<section id="sets">
<h4 title="Sets">4.1.3. 集合</h4>

<p>
`~list$は
`有順序~集合@
であると指名されることもある。
有順序~集合は、`~list$であって，かつ
同じ`~item$が重ねて現れては~MUST_NOTとする，追加の意味論を伴う。
◎
Some lists are designated as ordered sets. An ordered set is a list with the additional semantic that it must not contain the same item twice.
</p>

<p class="note">注記：
~web~platformにおける ほとんどすべての事例では、無順序ではなく<em>有順序</em>集合が要求される
— 相互運用性のため、集合の内容が開発者に公開されるときの列挙~順序は，各~browser間で一貫することが要求されるので。
また，順序が要求されない事例でも、有順序~集合が利用される
— その場合、実装は，順序が観測され得ない事実に基づいて最適化できる。
◎
Almost all cases on the web platform require an ordered set, instead of an unordered one, since interoperability requires that any developer-exposed enumeration of the set’s contents be consistent between browsers. In those cases where order is not required, we still use ordered sets; implementations can optimize based on the fact that the order is not observable.
</p>

<ul>
	<li>
`有順序~集合$ %S に所与の `~item$ %item を
`付加-@set
するときは、
%S が %item を`包含-$しているならば 何もしない。
他の場合は `~list$に対する通常の`付加-$演算を遂行する。
◎
To append to an ordered set is to do nothing if the set already contains the given item, or to perform the normal list append operation otherwise.
</li>
	<li>
`有順序~集合$ %S に所与の`~item$ %item を
`前付加-@set
するときは、
%S が %item を`包含-$しているならば 何もしない。
他の場合は `~list$に対する通常の`前付加-$演算を遂行する。
◎
To prepend to an ordered set is to do nothing if the set already contains the given item, or to perform the normal list prepend operation otherwise.
</li>
</ul>

			</section>
		</section>
		<section id="maps">
<h3 title="Maps">4.2. ~map</h3>

<p>
`有順序~map@
は、仕様~levelの型であり、有限個の
`~key@map
/
`値@map
~pairからなる有順序~連列であり, かつ
同じ`~key$mapが重ねて現れないものである。
これらの各~pairは、
`~entry@map
と呼ばれる。
`順序が重要でない場合は^tnote 単に “~map” と称されることもある。
◎
An ordered map, or sometimes just "map", is a specification type consisting of a finite ordered sequence of key/value pairs, with no key appearing twice. Each key/value pair is called an entry.
</p>

<p class="note">注記：
`有順序~集合$と同様に，実装~間での相互運用性のため、~mapも既定で有順序であるものと見做され~MUST。
◎
As with ordered sets, by default we assume that maps must also be ordered for interoperability among implementations.
</p>

<p>
`有順序~map$は、~literal構文を利用して表すこともできる
— そのためには、各 `~entry$mapを
"%~key → %値"
の形に記し, 各 ~entryどうしは~commaで区切り, 全体を区切子 «[, ]» で括る。
`値$mapを［
検索する／設定する
］ための~indexing構文も利用できる
— そのためには，角括弧の内側に`~key$mapを与える。
◎
A literal syntax can be used to express ordered maps, by surrounding the contents with «[ ]» delimiters, denoting each entry as key → value, and separating entries with a comma. An indexing syntax can be used to look up and set values by providing a key inside square brackets.
</p>


<p class="example" id="example-map-notation">
%M ~EQ `有順序~map$ «[ `a^l → `x^bl, `b^l → `y^bl ]»
が与えられた下では、
%M[`a^l] は `~byte列$ `x^bl を表す。
◎
Let example be the ordered map «[ "a" → `x`, "b" → `y` ]». Then example["a"] is the byte sequence `x`.
</p>


<hr>

<ul>
	<li>
<p>
`有順序~map$ %M 内の 所与の`~key$map %K に対応する値を
`取得-@map
するときは、［
%M が %K を`~key$mapとする`~entry$mapを`包含-$mapするならば その`値$map ／
~ELSE_ ε （ “なし” ）
］を返す。
</p>

<p>
この演算は、
“ %M[ %K ] ”
とも表記される。
</p>
◎
To get the value of an entry in an ordered map given a key is to retrieve the value of any existing entry if the map contains an entry with the given key, or if to return nothing otherwise. We can also use the indexing syntax explained above.


To get the value of an entry in an ordered map given a key is to retrieve the value of any existing key/value pair if the map contains an entry with the given key, or if to return nothing otherwise. We can also use the indexing syntax explained above.
</li>
	<li>
<p>
`有順序~map$ %M 内の 所与の`~key$map %K に対応する値を，所与の`値$map %V に
`設定-@map
するときは：
</p>

<ol><li>%M が［
%K を`~key$mapとする`~entry$mapを`包含-$mapする
］ならば その`値$mapを %V に更新する
</li><li>~ELSE_ 新たな`~entry$map ( %K → %V ) を %M の末尾に追加する
</li></ol>

<p>
この演算は、
“ %M[ %K ] ~SET  %V ”
とも表記される。
</p>
◎
To set the value of an entry in an ordered map to a given value is to update the value of any existing entry if the map contains an entry with the given key, or if none such exists, to add a new entry with the given key/value to the end of the map. We can also denote this by saying, for an ordered map map, key key, and value value, "set map[key] to value".
</li>
	<li>
<p>
`有順序~map$ %M から
所与の %条件 に合致する`~entry$mapを
`除去-@map
するときは、 %条件 を満たす`~entry$mapすべてを %M から除去する（満たすものがなければ何もしない）。
</p>

<p>
“ %M[ %K ] ~SET ε ”
という表記は、条件［
%K を`~key$mapとする
］に合致する`~entry$mapを %M から`除去-$mapすることを意味する。
</p>
◎
To remove an entry from an ordered map is to remove all entries from the map that match a given condition, or do nothing if none do. If the condition is having a certain key, then we can also denote this by saying, for an ordered map map and key key, "remove map[key]".
</li>
	<li>
<p>
`有順序~map$ %M が，`~entry$map %entry を
`包含-@map
するとは、
%entry の`~key$map %K を`~key$mapとする`~entry$mapが %M 内に存在することを意味する。
</p>

<p>
この条件は、`取得-$mapの表記を用いて
“ %M[ %K ] ~NEQ ε ”
と記しても同じなので，そう表記されることもある（否定~条件は
“ %M[ %K ] ~EQ ε ”
とも表記される）。
</p>
◎
An ordered map contains an entry with a given key if there exists an entry with that key. We can also denote this by saying that, for an ordered map map and key key, "map[key] exists".
</li>
	<li>
`有順序~map$ %M の
`~keyたちを取得-@
するときは、新たな`有順序~集合$であって，［
その`~item$たちは， %M 内のすべての`~entry$mapの各`~key$mapからなる
］, かつ［
`~item$たちの順序は対応する`~entry$mapの %M における順序と同じ
］にされたものを返す。
◎
To get the keys of an ordered map, return a new ordered set whose items are each of the keys in the map’s entries.
</li>
	<li>
`有順序~map$ %M の
`~size@map
は、 %M の`~keyたちを取得-$した結果の`~size$とする。
◎
An ordered map’s size is the size of the result of running get the keys on the map.
</li>
	<li>
`有順序~map$ %M は，［
%M の`~size$map ~EQ 0
］であるとき
`空@map
であるという。
◎
An ordered map is empty if its size is zero.
</li>
	<li>
`有順序~map$ %M を
`反復-@map
するときは、
“ %M 内の`~EACH$map( `~entry$map %K → %V ) に対し：”
という句の下で，後続の注釈文にて［
%K, %V
］に対し演算する。
◎
To iterate over an ordered map, performing a set of steps on each entry in order, use phrasing of the form "For each key → value of map", and then operate on key and value in the subsequent prose.
</li>
</ul>

		</section>
	</section>
	<section id="namespaces">
<h2 title="Namespaces">5. 名前空間</h2>

<div>
<p>
次の名前空間が定義される：
</p>

<table><tbody><tr><th>`~HTML名前空間@
<td>`http://www.w3.org/1999/xhtml^l

<tr><th>`~MathML名前空間@
<td>`http://www.w3.org/1998/Math/MathML^l

<tr><th>`~SVG名前空間@
<td>`http://www.w3.org/2000/svg^l

<tr><th>`~XLink名前空間@
<td>`http://www.w3.org/1999/xlink^l

<tr><th>`~XML名前空間@
<td>`http://www.w3.org/XML/1998/namespace^l

<tr><th>`~XMLNS名前空間@
<td>`http://www.w3.org/2000/xmlns/^l

</tbody></table>

◎
The HTML namespace is "http://www.w3.org/1999/xhtml".
◎
The MathML namespace is "http://www.w3.org/1998/Math/MathML".
◎
The SVG namespace is "http://www.w3.org/2000/svg".
◎
The XLink namespace is "http://www.w3.org/1999/xlink".
◎
The XML namespace is "http://www.w3.org/XML/1998/namespace".
◎
The XMLNS namespace is "http://www.w3.org/2000/xmlns/".
</div>
	</section>

</main></div><!-- id="MAIN" -->

	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
次の方々からの協力に感謝する：
</p>

<p>
Many thanks to

Jungkee Song,
Malika Aubakirova,
Michael™ Smith,
Mike West,
Philip Jägenstedt,
Sergey Shekyan,
Simon Pieters,
Tab Atkins,
Tobie Langel,
and Xue Fuqiao

for being awesome!
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>(
<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>
)
and
<a href="https://domenic.me/">Domenic Denicola</a>(
<a href="https://www.google.com/">Google</a>,
<a href="mailto:d@domenic.me">d@domenic.me</a>
).
</p>

<p>
Per <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>, to the extent possible under law, the editors have waived all copyright and related or neighboring rights to this work.
</p>

	</section>
	<section id="index">

<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>
	</section>


	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>

<dl>
	<dt>[ECMA-262]</dt>
	<dd>ECMAScript Language Specification.</dd>
	<dd>https://tc39.github.io/ecma262/</dd>

	<dt>[RFC2119]</dt>
	<dd>S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc2119</dd>

	<dt>[UNICODE]</dt>
	<dd>The Unicode Standard.</dd>
	<dd>http://www.unicode.org/versions/latest/</dd>

	<dt>[WEBIDL]</dt>
	<dd>Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL.</dd>
	<dd>https://heycam.github.io/webidl/</dd>
</dl>

		</section>
	</section>
