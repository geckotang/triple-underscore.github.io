<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Living Standard — Semantics, structure, and APIs of HTML documents（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/dom.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 151224 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		ps: 'pseudo',
		P: 'production',
		p: 'property',
		st: 'attr-state',
		css: 'css',
		v: 'value',
		E: 'error',
		jA: 'abstract',
		uc: 'unicode-category', // Unicode character class
		h: 'header',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		hd: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		ps: 'code',
		st: 'span',
		h: 'code',
		P: 'code',
		p: 'code',
		css: 'code',
		jA: 'span',
		uc: 'span',
		v: 'code',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
//	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|❝.|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN', '_toc_list0');


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '❝':
		return ( 'U+00'
			+ match[1].charCodeAt(0).toString(16).toUpperCase()
			+ ' ( "<code class="literal">' + match[1] + '</code>" )'
		);
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
//var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a': // event type
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'et': // event type
	break;
case 'i': // model constants
	break;
case 'h': // http header
	text = '<code class="header">' + text + '</code>';
	break;
case 'v': // attr value
	break;
case '0x': // %x escape
	return '%x' + key
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">

	●要素
e.a:~HTML5/semantics.html#the-a-element
e.abbr:~HTML5/semantics.html#the-abbr-element
e.address:~HTML5/semantics.html#the-address-element
e.applet:~HTML5/obsolete.html#the-applet-element
e.area:~HTML5/embedded-content.html#the-area-element
e.article:~HTML5/semantics.html#the-article-element
e.aside:~HTML5/semantics.html#the-aside-element
e.audio:~HTML5/embedded-content.html#the-audio-element
e.b:~HTML5/semantics.html#the-b-element
e.base:~HTML5/semantics.html#the-base-element
e.bdi:~HTML5/semantics.html#the-bdi-element
e.bdo:~HTML5/semantics.html#the-bdo-element
e.blockquote:~HTML5/semantics.html#the-blockquote-element
e.body:~HTML5/semantics.html#the-body-element
e.br:~HTML5/semantics.html#the-br-element
e.button:~HTML5/forms.html#the-button-element
e.canvas:~SCRIPTING#the-canvas-element
e.cite:~HTML5/semantics.html#the-cite-element
e.code:~HTML5/semantics.html#the-code-element
e.data:~HTML5/semantics.html#the-data-element
e.datalist:~HTML5/forms.html#the-datalist-element
e.del:~HTML5/semantics.html#the-del-element
e.details:~HTML5/forms.html#the-details-element
e.dfn:~HTML5/semantics.html#the-dfn-element
e.dialog:~HTML5/forms.html#the-dialog-element
e.div:~HTML5/semantics.html#the-div-element
e.dl:~HTML5/semantics.html#the-dl-element
e.em:~HTML5/semantics.html#the-em-element
e.embed:~HTML5/embedded-content.html#the-embed-element
e.fieldset:~HTML5/forms.html#the-fieldset-element
e.figure:~HTML5/semantics.html#the-figure-element
e.footer:~HTML5/semantics.html#the-footer-element
e.footers:~HTML5/semantics.html#the-footer-element
e.form:~HTML5/forms.html#the-form-element
e.frameset:~HTML5/obsolete.html#frameset
e.head:~HTML5/semantics.html#the-head-element
e.header:~HTML5/semantics.html#the-header-element
e.hgroup:~HTML5/semantics.html#the-hgroup-element
e.hr:~HTML5/semantics.html#the-hr-element
e.html:~HTML5/semantics.html#the-html-element
e.i:~HTML5/semantics.html#the-i-element
e.iframe:~HTML5/embedded-content.html#the-iframe-element
e.img:~HTML5/embedded-content.html#the-img-element
e.input:~HTML5/forms.html#the-input-element
e.ins:~HTML5/semantics.html#the-ins-element
e.kbd:~HTML5/semantics.html#the-kbd-element
e.keygen:~HTML5/forms.html#the-keygen-element
e.label:~HTML5/forms.html#the-label-element
e.li:~HTML5/semantics.html#the-li-element
e.link:~HTML5/semantics.html#the-link-element
e.main:~HTML5/semantics.html#the-main-element
e.map:~HTML5/embedded-content.html#the-map-element
e.mark:~HTML5/semantics.html#the-mark-element
e.menu:~HTML5/forms.html#the-menu-element
e.menuitem:~HTML5/forms.html#the-menuitem-element
e.meta:~HTML5/semantics.html#the-meta-element
e.meter:~HTML5/forms.html#the-meter-element
e.nav:~HTML5/semantics.html#the-nav-element
e.noscript:~HTMLSCRIPT#the-noscript-element
e.object:~HTML5/embedded-content.html#the-object-element
e.ol:~HTML5/semantics.html#the-ol-element
e.output:~HTML5/forms.html#the-output-element
e.optgroup:~HTML5/forms.html#the-optgroup-element
e.option:~HTML5/forms.html#the-option-element
e.p:~HTML5/semantics.html#the-p-element
e.picture:~HTML5/embedded-content.html#the-picture-element
e.pre:~HTML5/semantics.html#the-pre-element
e.progress:~HTML5/forms.html#the-progress-element
e.q:~HTML5/semantics.html#the-q-element
e.rt:~HTML5/semantics.html#the-rt-element
e.ruby:~HTML5/semantics.html#the-ruby-element
e.s:~HTML5/semantics.html#the-s-element
e.samp:~HTML5/semantics.html#the-samp-element
e.script:~HTMLSCRIPT#the-script-element
e.section:~HTML5/semantics.html#the-section-element
e.select:~HTML5/forms.html#the-select-element
e.small:~HTML5/semantics.html#the-small-element
e.slot:~HTMLSCRIPT#the-slot-element
e.span:~HTML5/semantics.html#the-span-element
e.strong:~HTML5/semantics.html#the-strong-element
e.style:~HTML5/semantics.html#the-style-element
e.table:~HTML5/tables.html#the-table-element
e.td:~HTML5/tables.html#the-td-element
e.template:~HTMLSCRIPT#the-template-element
e.textarea:~HTML5/forms.html#the-textarea-element
e.th:~HTML5/tables.html#the-th-element
e.time:~HTML5/semantics.html#the-time-element
e.title:~HTML5/semantics.html#the-title-element
e.tr:~HTML5/tables.html#the-tr-element
e.track:~HTML5/embedded-content.html#the-track-element
e.u:~HTML5/semantics.html#the-u-element
e.ul:~HTML5/semantics.html#the-ul-element
e.var:~HTML5/semantics.html#the-var-element
e.video:~HTML5/embedded-content.html#the-video-element
e.wbr:~HTML5/semantics.html#the-wbr-element

~SVG-svg:~SVG11/struct.html#SVGElement
~SVG-title:~SVG11/struct.html#TitleElement
~SVG-script:~SVG11/script.html#ScriptElement
~MathML-math:https://www.w3.org/Math/draft-spec/chapter2.html#interf.toplevel


e.h1:~HTML5/semantics.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h2:~HTML5/semantics.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h3:~HTML5/semantics.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h4:~HTML5/semantics.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h5:~HTML5/semantics.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h6:~HTML5/semantics.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.sub:~HTML5/semantics.html#the-sub-and-sup-elements
e.sup:~HTML5/semantics.html#the-sub-and-sup-elements


e.acronym:~HTML5/obsolete.html#acronym
e.basefont:~HTML5/obsolete.html#basefont
e.bgsound:~HTML5/obsolete.html#bgsound
e.big:~HTML5/obsolete.html#big
e.blink:~HTML5/obsolete.html#blink
e.center:~HTML5/obsolete.html#center
e.isindex:~HTML5/obsolete.html#isindex
e.listing:~HTML5/obsolete.html#listing
e.multicol:~HTML5/obsolete.html#multicol
e.nextid:~HTML5/obsolete.html#nextid
e.nobr:~HTML5/obsolete.html#nobr
e.noembed:~HTML5/obsolete.html#noembed
e.noframes:~HTML5/obsolete.html#noframes
e.plaintext:~HTML5/obsolete.html#plaintext
e.rb:~HTML5/obsolete.html#rb
e.rtc:~HTML5/obsolete.html#rtc
e.spacer:~HTML5/obsolete.html#spacer
e.strike:~HTML5/obsolete.html#strike
e.tt:~HTML5/obsolete.html#tt
e.xmp:~HTML5/obsolete.html#xmp

	●attr
a.class:#classes
a.id:#the-id-attribute
a.slot:#attr-slot

a.aria-label:https://w3c.github.io/aria/aria/aria.html#aria-label
	~HTML5/
a.accesskey:~HTML5/interaction.html#the-accesskey-attribute
a.dir:#the-dir-attribute
a.draggable:~HTMLDND#the-draggable-attribute
a.dropzone:~HTMLDND#the-dropzone-attribute
a.hidden:~HTML5/interaction.html#the-hidden-attribute
a.is:~HTMLCUSTOM#attr-is
a.itemprop:~HTML5/microdata.html#names:-the-itemprop-attribute
a.style:#the-style-attribute

a.th.abbr:~HTML5/tables.html#attr-th-abbr
a.area.alt:~HTML5/embedded-content.html#attr-area-alt
a.aria-*:~HTMLINFRA#attr-aria-*
a.dir.auto:#attr-dir-auto
a.meta.content:~HTML5/semantics.html#attr-meta-content
a.contenteditable:~HTML5/interaction.html#attr-contenteditable
a.contextmenu:~HTML5/forms.html#attr-contextmenu
a.controls:~HTML5/embedded-content.html#attr-media-controls
a.data-*:#attr-data-*
a.data-:#attr-data-*
a.download:~HTML5/semantics.html#attr-hyperlink-download
a.href:~HTML5/semantics.html#attr-hyperlink-href
a.img.alt:~HTML5/embedded-content.html#attr-img-alt
a.input.alt:~HTML5/forms.html#attr-input-alt
a.input.placeholder:~HTML5/forms.html#attr-input-placeholder
a.itemid:~HTML5/microdata.html#attr-itemid
a.itemref:~HTML5/microdata.html#attr-itemref
a.itemscope:~HTML5/microdata.html#attr-itemscope
a.itemtype:~HTML5/microdata.html#attr-itemtype
a.lang:#attr-lang
a.menu.label:~HTML5/forms.html#attr-menu-label
a.menuitem.label:~HTML5/forms.html#attr-menuitem-label
a.meta.name:~HTML5/semantics.html#attr-meta-name
a.optgroup.label:~HTML5/forms.html#attr-optgroup-label
a.option.label:~HTML5/forms.html#attr-option-label
a.role:~HTMLINFRA#attr-aria-role
a.sandbox:~HTML5/embedded-content.html#attr-iframe-sandbox
a.scoped:~HTML5/semantics.html#attr-style-scoped
a.spellcheck:~HTML5/interaction.html#attr-spellcheck
a.srcdoc:~HTML5/embedded-content.html#attr-iframe-srcdoc
a.tabindex:~HTML5/interaction.html#attr-tabindex
a.textarea.placeholder:~HTML5/forms.html#attr-textarea-placeholder
a.title:#attr-title
a.track.label:~HTML5/embedded-content.html#attr-track-label
a.translate:#attr-translate
a.type:~HTML5/forms.html#attr-input-type
a.menu.type:~HTML5/forms.html#attr-menu-type
a.usemap:~HTML5/embedded-content.html#attr-hyperlink-usemap
a.value:~HTML5/forms.html#attr-input-value
	a.xml:lang:#attr-xml-lang
a.~xml_space:~HTMLCONFORM#attr-xml-space

	●IDL
I.CSSStyleDeclaration:~CSSOM#the-cssstyledeclaration-interface
I.DOMStringMap:~HTMLINFRA#domstringmap
I.DOMTokenList:~DOM4#interface-domtokenlist
I.Document:#document
	I.Document:~DOM4#interface-document
I.Element:~DOM4#interface-element
I.NodeList:~DOM4#interface-nodelist
	I.ProcessingInstruction:~DOM4#processinginstruction
I.Text:~DOM4#interface-text
I.XMLDocument:~DOM4#xmldocument
I.DocumentAndElementEventHandlers:~WAPI#documentandelementeventhandlers
I.DocumentFragment:~DOM4#interface-documentfragment
I.DocumentReadyState:#documentreadystate
I.ElementContentEditable:~HTML5/interaction.html#elementcontenteditable
I.EventHandler:~WAPI#eventhandler
I.GlobalEventHandlers:~WAPI#globaleventhandlers
I.HTMLCollection:~DOM4#interface-htmlcollection
I.HTMLElement:#htmlelement
I.HTMLPreElement:#htmlpreelement
I.HTMLHeadElement:~HTML5/semantics.html#htmlheadelement
I.HTMLMenuElement:~HTML5/forms.html#htmlmenuelement
I.HTMLScriptElement:~HTMLSCRIPT#htmlscriptelement
I.SVGScriptElement:~SVG11/script.html#InterfaceSVGScriptElement
I.HTMLOrSVGScriptElement:#htmlorsvgscriptelement

I.HTMLUnknownElement:#htmlunknownelement
I.Location:~BROWSERS#location
I.Window:~BROWSERS#window
I.WindowProxy:~BROWSERS#windowproxy

I.CustomElementsRegistry:~HTMLCUSTOM#customelementsregistry

E.InvalidStateError:~WEBIDL#invalidstateerror
E.TypeError:~ES6#sec-native-error-types-used-in-this-standard-typeerror
E.HierarchyRequestError:~WEBIDL#hierarchyrequesterror
E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror

CEReactions:~HTMLCUSTOM#cereactions

	●on-
m.onabort:~WAPI#handler-onabort
m.onautocomplete:~WAPI#handler-onautocomplete
m.onautocompleteerror:~WAPI#handler-onautocompleteerror
m.onblur:~WAPI#handler-onblur
m.oncancel:~WAPI#handler-oncancel
m.oncanplay:~WAPI#handler-oncanplay
m.oncanplaythrough:~WAPI#handler-oncanplaythrough
m.onchange:~WAPI#handler-onchange
m.onclick:~WAPI#handler-onclick
m.onclose:~WAPI#handler-onclose
m.oncontextmenu:~WAPI#handler-oncontextmenu
m.oncuechange:~WAPI#handler-oncuechange
m.ondblclick:~WAPI#handler-ondblclick
m.ondrag:~WAPI#handler-ondrag
m.ondragend:~WAPI#handler-ondragend
m.ondragenter:~WAPI#handler-ondragenter
m.ondragexit:~WAPI#handler-ondragexit
m.ondragleave:~WAPI#handler-ondragleave
m.ondragover:~WAPI#handler-ondragover
m.ondragstart:~WAPI#handler-ondragstart
m.ondrop:~WAPI#handler-ondrop
m.ondurationchange:~WAPI#handler-ondurationchange
m.onemptied:~WAPI#handler-onemptied
m.onended:~WAPI#handler-onended
m.onerror:~WAPI#handler-onerror
m.onfocus:~WAPI#handler-onfocus
m.oninput:~WAPI#handler-oninput
m.oninvalid:~WAPI#handler-oninvalid
m.onkeydown:~WAPI#handler-onkeydown
m.onkeypress:~WAPI#handler-onkeypress
m.onkeyup:~WAPI#handler-onkeyup
m.onload:~WAPI#handler-onload
m.onloadeddata:~WAPI#handler-onloadeddata
m.onloadedmetadata:~WAPI#handler-onloadedmetadata
m.onloadstart:~WAPI#handler-onloadstart
m.onmousedown:~WAPI#handler-onmousedown
m.onmouseenter:~WAPI#handler-onmouseenter
m.onmouseleave:~WAPI#handler-onmouseleave
m.onmousemove:~WAPI#handler-onmousemove
m.onmouseout:~WAPI#handler-onmouseout
m.onmouseover:~WAPI#handler-onmouseover
m.onmouseup:~WAPI#handler-onmouseup
m.onpause:~WAPI#handler-onpause
m.onplay:~WAPI#handler-onplay
m.onplaying:~WAPI#handler-onplaying
m.onprogress:~WAPI#handler-onprogress
m.onratechange:~WAPI#handler-onratechange
m.onreadystatechange:~WAPI#handler-onreadystatechange
m.onreset:~WAPI#handler-onreset
m.onresize:~WAPI#handler-onresize
m.onscroll:~WAPI#handler-onscroll
m.onseeked:~WAPI#handler-onseeked
m.onseeking:~WAPI#handler-onseeking
m.onselect:~WAPI#handler-onselect
m.onshow:~WAPI#handler-onshow
m.onstalled:~WAPI#handler-onstalled
m.onsubmit:~WAPI#handler-onsubmit
m.onsuspend:~WAPI#handler-onsuspend
m.ontimeupdate:~WAPI#handler-ontimeupdate
m.ontoggle:~WAPI#handler-ontoggle
m.onvolumechange:~WAPI#handler-onvolumechange
m.onwaiting:~WAPI#handler-onwaiting
m.onwheel:~WAPI#handler-onwheel

	●IDL member
m.accessKey:~HTML5/interaction.html#dom-accesskey
m.accessKeyLabel:~HTML5/interaction.html#dom-accesskeylabel
m.activeElement:~HTML5/interaction.html#dom-document-activeelement
m.blur:~HTML5/interaction.html#dom-blur
m.body:#dom-document-body

m.click:~HTML5/interaction.html#dom-click
m.close:~HTML5/webappapis.html#dom-document-close
m.contextMenu:~HTML5/forms.html#dom-contextmenu
m.cookie:#dom-document-cookie
m.createDocument:~DOM4#dom-domimplementation-createdocument
	~HTMLINFRA
m.createHTMLDocument:~DOM4#dom-domimplementation-createhtmldocument
	~HTMLINFRA
m.currentScript:#dom-document-currentscript
m.dataset:#dom-dataset
m.defaultView:~BROWSERS#dom-document-defaultview
m.dir:#dom-dir
m.~document-dir:#dom-document-dir
m.domain:~BROWSERS#dom-document-domain
m.draggable:~HTMLDND#dom-draggable
m.dropzone:~HTMLDND#dom-dropzone
m.embeds:#dom-document-embeds
m.focus:~HTML5/interaction.html#dom-focus
m.forceSpellCheck:~HTML5/interaction.html#dom-forcespellcheck
m.forms:#dom-document-forms
m.getElementsByClassName:~DOM4#dom-document-getelementsbyclassname
m.getElementsByName:#dom-document-getelementsbyname
m.getter:#dom-document-nameditem
m.hasFocus:~HTML5/interaction.html#dom-document-hasfocus
m.head:#dom-document-head
m.hidden:~HTML5/interaction.html#dom-hidden
m.href:~BROWSERS#dom-location-href
m.images:#dom-document-images
m.lang:#dom-lang
m.lastModified:#dom-document-lastmodified
m.links:#dom-document-links
m.load:#dom-xmldocument-load
m.location:~BROWSERS#dom-document-location
m.open:~HTML5/webappapis.html#dom-document-open
m.plugins:#dom-document-plugins
m.pushState:~BROWSERS#dom-history-pushstate
m.queryCommandEnabled:~HTML5/interaction.html#dom-document-querycommandenabled
m.queryCommandIndeterm:~HTML5/interaction.html#dom-document-querycommandindeterm
m.queryCommandState:~HTML5/interaction.html#dom-document-querycommandstate
m.queryCommandSupported:~HTML5/interaction.html#dom-document-querycommandsupported
m.queryCommandValue:~HTML5/interaction.html#dom-document-querycommandvalue
m.readyState:#dom-document-readystate
m.referrer:#dom-document-referrer
m.scripts:#dom-document-scripts
m.spellcheck:~HTML5/interaction.html#dom-spellcheck
m.style:#dom-style
m.tabIndex:~HTML5/interaction.html#dom-tabindex
m.title:#dom-title
m.~document-title:#document.title
m.translate:#dom-translate
m.value:~DOM4#dom-domtokenlist-value
m.write:~HTML5/webappapis.html#dom-document-write
m.writeln:~HTML5/webappapis.html#dom-document-writeln
m.designMode:~HTML5/interaction.html#designMode
m.execCommand:~HTML5/interaction.html#execCommand
m.textContent:~DOM4#dom-node-textcontent

m.HTMLElement:#_dom-htmlelement-htmlelement

	●event
et.volumechange:~HTML5/embedded-content.html#event-media-volumechange
et.load:~HTML5/indices.html#event-load
et.readystatechange:~HTML5/indices.html#event-readystatechange


	●内容属性状態
st.翻訳不可:#no-translate
st.可翻訳:#translate-enabled
st.未定義:#_undef-state

st.~ltr:#attr-dir-ltr-state
st.~rtl:#attr-dir-rtl-state
st.自動:#attr-dir-auto-state
st.Button:~HTML5/forms.html#button-state-(type=button)
st.E-mail:~HTML5/forms.html#e-mail-state-(type=email)
st.Hidden:~HTML5/forms.html#hidden-state-(type=hidden)
st.Reset Button:~HTML5/forms.html#reset-button-state-(type=reset)
st.Search:~HTML5/forms.html#text-(type=text)-state-and-search-state-(type=search)
st.Telephone:~HTML5/forms.html#telephone-state-(type=tel)
st.Text:~HTML5/forms.html#text-(type=text)-state-and-search-state-(type=search)
st.URL:~HTML5/forms.html#url-state-(type=url)
st.toolbar:~HTML5/forms.html#toolbar-state


v.ltr:#attr-dir-ltr
v.rtl:attr-dir-rtl
v.auto:attr-dir-auto

p.direction:~CSSWM#direction
p.unicode-bidi:~CSSWM#unicode-bidi
p.content:~CSS21/generate.html#content


jA.GetFunctionRealm:~ES6#sec-getfunctionrealm


	●
名前:#_named-element-name
文書:#_document
~custom~data属性:#custom-data-attribute
~address:#the-document's-address
	'
~HTTPS状態:#concept-document-https-state
内容~model:#content-models
内容:#concept-html-contents
見出し内容:#heading-content-2
埋込みの内容:#embedded-content-category
~fallback内容:#fallback-content
~flow内容:#flow-content-2
対話的~内容:#interactive-content-2
~metadata内容:#metadata-content-2
句内容:#phrasing-content-2
章節ing内容:#sectioning-content-2
~palpable内容:#palpable-content-2
~text内容:#text-content
~Text:#text-content
~text:#text-content

~CSP~list:#concept-document-csp-list
分類:#content-categories
分類-:#content-categories
~module~map:#concept-document-module-map


	類別:concept-element-categories
	この要素を利用できる文脈:#concept-element-contexts
	text/htmlにおける~tag省略:#concept-element-tag-omission
	内容~model:#concept-element-content-model
	内容~属性:#concept-element-attributes
	~DOM~interface:#concept-element-dom

作動中の構文解析器:#active-parser

言語:#language
~propを検索取得するために~index~access:#dom-document-nameditem
~scriptを~supportする要素:#script-supporting-elements-2

	＊
なし:#concept-content-nothing

方向性:#the-directionality


参考情報:#advisory-information
双向algo整形~文字~範囲:#bidirectional-algorithm-formatting-character-ranges


反cookie文書:#cookie-averse-document-object
現在の準備度:#current-document-readiness
~custom~data属性:#custom-data-attribute
属性の方向性:#directionality-of-the-attribute
方向性有りの属性:#directionality-capable-attribute
方向性:#the-directionality
公開されている:#exposed
	＊双向algoを孕むような具現化~要件が課される:#bidireq


見出し:#heading-content-2
~html0要素:#the-html-element-2
~body0要素:#the-body-element-2
~head0要素:#the-head-element-2
~incumbent~body0要素:#the-body-element-2
~title0要素:#the-title-element-2

要素間~空白:#inter-element-whitespace
~XML名前空間に属する~lang属性:#attr-xml-lang
~XML~lang属性:#attr-xml-lang
素の~lang属性:#attr-lang
~ltr:#concept-ltr
~rtl:#concept-rtl
有名~要素:#dom-document-nameditem-filter
翻訳不可~状態:#no-translate
上書きされた再読込み:#an-overridden-reload
段落:#paragraph
再読込み上書き~buffer:#reload-override-buffer
再読込み上書き~flag:#reload-override-flag
表現-:#represents
	＊資源~metadata管理:#resource-metadata-management

方向性:#the-directionality
~referrer:#the-document's-referrer
	'

翻訳可能な属性:#translatable-attributes
	翻訳可能:#translatable-attributes
可翻訳:#translate-enabled
翻訳~mode:#translation-mode
透過的:#transparent




	●INFRA
~HTML要素:~HTMLINFRA#html-elements
~HTML名前空間:~HTMLINFRA#html-namespace-2
~SVG名前空間:~HTMLINFRA#svg-namespace
~XML名前空間:~HTMLINFRA#xml-namespace
~ASCII数字:~HTMLINFRA#ascii-digits
x.~ASCII文字大小無視:~HTMLINFRA#ascii-case-insensitive
x.Content-Type ~metadata:~HTMLINFRA#content-type
相対的に構文解析-:~HTMLINFRA#parse-a-url
空白を剥いで縮退-:~HTMLINFRA#strip-and-collapse-whitespace
子~text内容:~HTMLINFRA#child-text-content
要素~型:~HTMLINFRA#element-type
~Unicode文字:~HTMLINFRA#unicode-character
~XML~MIME型:~HTMLINFRA#xml-mime-type
~XML互換:~HTMLINFRA#xml-compatible
	x.~case-sensitive:~HTMLINFRA#case-sensitive
制御~文字:~HTMLINFRA#control-characters
~ASCII小文字~化:~HTMLINFRA#converted-to-ascii-lowercase
~ASCII大文字~化:~HTMLINFRA#converted-to-ascii-uppercase
列挙~属性:~HTMLINFRA#enumerated-attribute
	列挙ed属性
無視-:~HTMLINFRA#ignore
並列的:~HTMLINFRA#in-parallel
妥当でない値に対する既定の状態:~HTMLINFRA#invalid-value-default
値なしに対する既定の状態:~HTMLINFRA#missing-value-default
既知の値のみに制限される:~HTMLINFRA#limited-to-only-known-values
~ASCII小文字:~HTMLINFRA#lowercase-ascii-letters
~ASCII大文字:~HTMLINFRA#uppercase-ascii-letters
~live:~HTMLINFRA#live
反映-:~HTMLINFRA#reflect
結果の~URL~record:~HTMLINFRA#resulting-url-record
根~要素:~HTMLINFRA#root-element

空白区切りの~token集合:~HTMLINFRA#set-of-space-separated-tokens
空白類:~HTMLINFRA#space-character
空白並びで分割-:~HTMLINFRA#split-a-string-on-spaces
名値~pairの~listを取得-:~HTMLINFRA#getting-the-list-of-name-value-pairs
名前に対応する値を設定-:~HTMLINFRA#setting-names-to-certain-values
対応する名値~pairを削除-:~HTMLINFRA#deleting-names

	●CONFORM
P.cookie-string:~HTMLCONFORM#cookie-string
	h.Last-Modified:~RFC7232#section-2.2
	~HTMLCONFORM#http-last-modified
適用し得る仕様:~HTMLCONFORM#other-applicable-specifications


x.~CSS~styling属性:~CSSSTYLEATTR#style-attribute

x.有名~propの値を決定する:~WEBIDL#dfn-determine-the-value-of-a-named-property
x.被support~prop名:~WEBIDL#dfn-supported-property-names
x.有名~propを~supportする:~WEBIDL#dfn-support-named-properties

	推薦される既定の具現化を~supportする:~HTMLCONFORM#renderingUA
	x.set-cookie-string を受信-:~HTMLCONFORM#receives-a-set-cookie-string

	●DOM4
文書~要素:~DOM4#document-element
x.~node文書:~DOM4#concept-node-document
x.~ID:~DOM4#concept-id
x.要素~interface:~DOM4#concept-element-interface
	~HTMLINFRA#concept-id
	x.文書の~address:~DOM4#concept-document-url
	x.~address:~DOM4#concept-document-url
x.~HTML文書:~DOM4#html-document
x.~XML文書:~DOM4#xml-document
x.木:~DOM4#concept-tree
x.木~順序:~DOM4#concept-tree-order
x.属性~list:~DOM4#concept-element-attribute
x.要素:~DOM4#interface-element
x.置換する:~DOM4#concept-node-replace
x.付加する:~DOM4#concept-node-append
x.~shadow木:~DOM4#concept-shadow-tree
x.要素を作成-:~DOM4#concept-create-element

	●URL, ENCODING
x.UTF-8 符号化-:~ENCODING#utf-8-encode
x.BOM を取り扱わずに UTF-8 復号-:~ENCODING#utf-8-decode-without-bom

x.~URL:~URLSpec#concept-url
x.絶対~URL:~URLSpec#syntax-url-absolute
url.素片:~URLSpec#concept-url-fragment
url.生成元:~URLSpec#concept-url-origin
url.~scheme:~URLSpec#concept-url-scheme
x.~network~scheme:~URLSpec#network-scheme

	●FETCH
rq.~client:~FETCH#concept-request-client
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.行先:~FETCH#concept-request-destination
rq.~mode:~FETCH#concept-request-mode
x.要請:~FETCH#concept-request
rq.~url:~FETCH#concept-request-url
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.同期~flag:~FETCH#synchronous-flag
rs.~CSP~list:~FETCH#concept-response-csp-list
rs.~HTTPS状態:~FETCH#concept-response-https-state
rs.本体:~FETCH#concept-response-body
x.~fetch:~FETCH#concept-fetch
x.応答:~FETCH#concept-response

	●WAPI
~taskを待入する:~WAPI#queue-a-task
	＊
~entry設定群~obj:~WAPI#entry-settings-object
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler内容~属性:~WAPI#event-handler-content-attributes
~event~handler:~WAPI#event-handlers
単純~eventを発火-:~WAPI#fire-a-simple-event
担当の文書:~WAPI#responsible-document
~script:~WAPI#concept-script
設定群~obj:~WAPI#settings-object
x.~module~map:~WAPI#module-map
~classic~script:~WAPI#classic-script
~module~script:~WAPI#module-script
大域~obj:~WAPI#concept-realm-global

	●syntax
x.~HTML構文解析器:~HTML5/syntax.html#html-parser
x.~HTML構文:~HTML5/syntax.html#syntax
x.中止-:~HTML5/syntax.html#abort-a-parser
x.完全に読込まれる:~HTML5/syntax.html#completely-loaded
x.終了tag:~HTML5/syntax.html#syntax-end-tag
	x.省略可能~tag:~HTML5/syntax.html#syntax-tag-omission
x.読込後~taskの準備が整う:~HTML5/syntax.html#ready-for-post-load-tasks
x.開始tag:~HTML5/syntax.html#syntax-start-tag
x.停止-:~HTML5/syntax.html#stop-parsing
x.~void要素:~HTML5/syntax.html#void-elements
	●browsers
~navigate:~BROWSERS#navigate
~navigation~algo:~BROWSERS#navigate
作動中の文書:~BROWSERS#active-document
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
素片:~BROWSERS#scroll-to-fragid
不透明な生成元:~BROWSERS#concept-origin-opaque
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
~source閲覧文脈:~BROWSERS#source-browsing-context
生成元:~BROWSERS#concept-origin
上書き~URL:~BROWSERS#override-url
x.例外~可能化~flag:~BROWSERS#exceptions-enabled
x.置換あり:~BROWSERS#replacement-enabled
x.一意~生成元に~sandbox化され:~BROWSERS#sandboxed-origin-browsing-context-flag
~addressを設定する:~BROWSERS#set-the-document's-address
	'

	●scripting
~prototype:~HTMLCUSTOM#concept-custom-element-definition-prototype
構築~stack:~HTMLCUSTOM#concept-custom-element-definition-construction-stack
すでに構築済みの~marker:~HTMLCUSTOM#concept-already-constructed-marker
構築子:~HTMLCUSTOM#concept-custom-element-definition-constructor
~custom要素~構築子:~HTMLCUSTOM#custom-element-constructor
局所~名:~HTMLCUSTOM#concept-custom-element-definition-local-name
昇格:~HTMLCUSTOM#upgrades
妥当な~custom要素~名:~HTMLCUSTOM#valid-custom-element-name
自律的~custom要素:~HTMLCUSTOM#autonomous-custom-element

~template内容:~HTMLSCRIPT#template-contents

	●
x.~CSP~obj:~CSP3#policy
x.要素の~inline挙動は~CSPにより阻止されるべきか？:~CSP3#should-block-inline

	§見出しと節:~HTML5/semantics.html#headings-and-sections
c.noreferrer:~HTML5/semantics.html#link-type-noreferrer
x.~outline:~HTML5/semantics.html#outline
x.章節ing根:~HTML5/semantics.html#sectioning-root
x.~body0内に許容される:~HTML5/semantics.html#allowed-in-the-body


x.値:~HTML5/forms.html#concept-fe-value
x.~XML構文解析器:~HTML5/xhtml.html#xml-parser
x.媒体~要素:~HTML5/embedded-content.html#media-element
x.~microdata:~HTML5/microdata.html#microdata
x.具現化 節:~HTMLRENDERING#rendering
c.text/html:~HTML5/iana.html#text/html

x.user interaction:~HTML5/interaction.html#editing
x.~pragmaにより設定される既定の言語:~HTML5/semantics.html#pragma-set-default-language


	x.利用者~対話:~HTML5/interaction.html#editing
	x.動的~markup挿入:~HTML5/webappapis.html#dynamic-markup-insertion

双向-字種:#_Bidirectional_Character_Types


</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
RFC7232:RFC7232-ja.html
HTMLSCRIPT:HTML-scripting-ja.html
HTMLCUSTOM:HTML-custom-ja.html
SCRIPTING:https://html.spec.whatwg.org/multipage/scripting.html
BROWSERS:https://html.spec.whatwg.org/multipage/browsers.html
ES6:https://tc39.github.io/ecma262/

xml_space:xml:space
xml_lang:xml:lang
head0:<code class="attr">head</code> 
html0:<code class="attr">html</code> 
body0:<code class="attr">body</code> 
title0:<code class="attr">title</code> 
lang: <code class="attr">lang</code> 
此れ:<b>これ°</b>
document-dir:dir
document-title:title
SVG-title:SVG <code class="element">title</code>
SVG-script:SVG <code class="element">script</code>
SVG-svg:SVG <code class="element">svg</code>
MathML-math:MathML <code class="element">math</code>

	text/html:text/html
</script>

<!-- 
ES6:https://tc39.github.io/ecma262/
IETF:https://tools.ietf.org/html
RFC7231:RFC7231-ja.html

BROWSERS:https://html.spec.whatwg.org/multipage/browsers.html
HTML-EMB:https://html.spec.whatwg.org/multipage/embedded-content.html
HTML-SEM:https://html.spec.whatwg.org/multipage/semantics.html
	HTML-IND:https://html.spec.whatwg.org/multipage/indices.html
HTML-COMMS:https://html.spec.whatwg.org/multipage/comms.html
	HTML-OBS:https://html.spec.whatwg.org/multipage/obsolete.html
HTML-DOM:https://html.spec.whatwg.org/multipage/dom.html
HTML-FORMS:https://html.spec.whatwg.org/multipage/forms.html
	HTML-TABLES:https://html.spec.whatwg.org/multipage/tables.html
	HTML-INTERACT:https://html.spec.whatwg.org/multipage/interaction.html
HTML-SYNTAX:https://html.spec.whatwg.org/multipage/syntax.html
	HTML-INTRO:https://html.spec.whatwg.org/multipage/introduction.html
HTML-SCRIPTING:https://html.spec.whatwg.org/multipage/scripting.html

SPACE:U+0020 ( SPACE )

href0:href

-->
<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">

CSP:::
CSS:::
Document:
HTTPS:::
ID:::
MIME:
SVG:
XHTML:::
XML:::
home:
live:
ltr:
rtl:
API::::
ASCII::::
DOM::::
HTML::::
HTTP::::
IDL::::
UA::::
URL::::
Unicode::::
Web::::
access::::アクセス
accessibility::::アクセス容易性
accessor::::アクセサ
address::::アドレス
algo:algorithm:::アルゴリズム
app:application:::アプリ
bar::::バー
body:
block::::ブロック
browser::::ブラウザ
buffer::::バッファ
button::::ボタン
call::::
channel::::チャンネル
control::::コントロール
cell::::セル
class::::クラス
subclass:::下位クラス:サブクラス
closure::::
code::::コード
comment::::コメント
computer::::コンピュータ
cookie::::
反cookie:cookie-averse::反 cookie
custom::::カスタム
customize::::カスタム化
classic::::クラシック

data::::データ
desktop::::デスクトップ
辞書:dictionary:~
	download::::ダウンロード
engine::::エンジン
entry::::エントリ
error::::エラー
event::::イベント
fallback::::フォールバック
fetch::::
file::::ファイル
filter::::フィルタ
flag::::フラグ
flow::::フロー
font::::フォント
form::::フォーム
frame::::フレーム
game::::ゲーム
group::::グループ
handler::::ハンドラ
header::::ヘッダ
incumbent::::
index::::
inline::::インライン
instance::::インスタンス
interface::::インタフェース
item::::アイテム
key::::
keyboard::::キーボード
touch::::タッチ
keyword::::キーワード
label::::ラベル
level::::レベル
library::::ライブラリ
link::::リンク
list::::リスト
literal::::リテラル
lock::::ロック
対応付けら:map さ:~
対応付け:mapping:~
module::::モジュール
map::::マップ
markup::::マークアップ
member::::メンバ
metadata::::メタデータ
method::::メソッド
mode::::モード
model::::モデル
mouse::::マウス
navigate::::ナビゲート
navigation::::ナビゲーション
network::::ネットワーク
networking::::ネットワーク処理
node::::ノード
obj:object:::オブジェクト
	online::::オンライン
platform::::プラットフォーム
program::::プログラム
prop:property:::プロパティ
特質:property::~::プロパティ
protocol::::プロトコル
referrer::::リファラ
risk::::リスク
sandbox::::
script::::スクリプト
scripting::::スクリプト処理
保安:security::~::セキュリティ
server::::サーバ
	~server側:server-side
service::::サービス
session::::セッション
shadow:
site::::サイト
software::::ソフト
source::::ソース
space::::
stylesheet::::スタイルシート
support::::サポート
system::::システム
table::::テーブル
	~table用の:tabular:::
tablet::::タブレット
tag::::タグ
	~tag付け~tagged:::

終了tag:end tag::終了 tag:終了タグ
開始tag:start tag::開始 tag:開始タグ
target::::ターゲット
task::::タスク
text::::テキスト
time::::
title::::タイトル
token::::トークン
tool::::ツール
tooltip::::ツールチップ
typography::::タイポグラフィ
underscore::::
url::::
version::::バージョン
view::::ビュー
window::::ウィンドウ
zero::::ゼロ

German::::ドイツ語
Arabic::::アラビア語
Belarusian::::ベラルーシ語
album::::アルバム
camel-case::::
hyphenate::::ハイフン化

dash::::ダッシュ
headphone::::ヘッドホン
loaded:::
mark-up::::マークアップ
microdata::::マイクロデータ
nothing:::
outline::::アウトライン
palpable:

句:phrase:~
句内容:phrasing content:phrasing 内容:~::フレージング内容

placeholder:::
pragma:::
	~pragmaにより設定される:pragma-set
prop:property:::プロパティ
screen::::スクリーン
	simulator::::シミュレータ
size::::サイズ
不明瞭に:straddle:~
style::::スタイル
styling::::スタイル付け
template:::
時間切れ:timeout::~
曲:track::曲::トラック
void:


整列-:sort:~

下位節:subsection:~

Blocked:::阻止される::ブロックされる
阻止-:block::~::ブロック
下位資源:sub-resource::~::下位リソース
資源:resource::~:リソース

不在:absence:~
不透明な:opaque:~
並列的:parallel:~
中止-:abort:~
付加-:append:~
作動中の:active:~
作成-:create:~
作者:author:~
例外:exception:~
保持-:hold:~
値:value:~
停止-:stop:~
入力:input:~
入子に:nest:~
	入子の:nested:~
公開-:expose:~
共有-:share:~
具現化-:render:~
具現化:rendering:~
内側:inside:~
内在的:intrinsic:~
内容:content:~
再帰的:recursive:~
処理-:process:~
処理:processing:~
処理命令:processing instruction:~
処理器:processor:~
出力:output:~
分割-:split:~
改行:line break:~
分断-:break:~
分離-:separate:~
列挙:enumerated:~
初期化-:initialise:~
	初期時には:initially:~
初期時:initial 時:~
動的:dynamic:~
包含-:contain:~
包装-:wrap:~
単語:word:~
即時:immediate:~
双向algo:bidirectional-algorithm::双向 algorithm:双向アルゴリズム
双向的:bidirectional::~
双向-:bidirectional::~
反復的:iterative:~
反映-:reflect:~
取得-:get:~
取得ing:getting:~
取得子:getter:~
検索取得-:retrieve:~
受容-:accept:~
可用:available:~
可能0:possible:可能
可能化-:enable:~
可能化:enabled::~
合致-:match:~
同期的:synchronous:~
同期:synchronous:~
成功:success:~
同胞:sibling:~
名:name:~
名前:name:~
命名:naming:~
名前空間:namespace:~
	名前空間に属さない:namespace-less
呈示-:present:~
呈示:presentation:~
呼出し:invoke:呼び出し
呼出され:invoke され:呼び出され
呼出せな:invoke できな:呼び出せな
問題0:matter:問題

地域標準時:local time zone::~
時間帯:time-zone:~
最終改変:last-modification:~
日付:date:~
日時:date and time:~
時刻:time:~
年成分:year component:~
日成分:day component:~
月成分:month component:~
時成分:hours component:~
秒成分:seconds component:~
分成分:minutes component:~

型:type:~
字種:character type:~
埋めら:fill さ:~
埋込み:embedding:埋め込み
埋込みの:embedded:埋め込み

基本的:basic:~
報告-:report:~
境界:boundary:~
増分:increment:~
声:voice:~
変形:transform:変換
変数:variable:~
変更-:change:~
	unchanged
変更点:changes:~
大域:global::~::グローバル
大域的:global::~::グローバル
局所:local::~::ローカル
局所名:localname::~::ローカル名

失敗-:fail:~
文書:document:~
要素:element:~
要素間:inter-element:~
子:child:~
子たち:children:~
子孫:descendant:~
先祖:ancestor:~
部分木:subtree::~::サブツリー
木:tree::~::ツリー
根:root::~::ルート

妥当な:valid:~
妥当:valid:~
	妥当でない:invalid:~

媒体:media::~:メディア
有名:named:~

存在-:exist:~
宣言:declaration:~
対応関係:mapping:~
対話的:interactive:~
	~respect:~
属性:attribute:~
引数:argument:~
強い:strong な:~
強く:strong に:~
形式:format:~
往来:round-tripping:~
待入する:queue する::待行列に入れる::キューする
	後続の:subsequent:~
復号-:decode:~
要請:request::~::リクエスト
応答:response::~::レスポンス
情報:information:~
	惑わせる:confuse:~

成分:component:~
投出:throw:~
抽出-:extract:~
担当の:responsible:~
挿入-:insert:~
挿入:insertion:~
描画:rendering:~

改変-:modify:~
整列-:align:~
整列:alignment:~
整形-:format:~
整形:formatting:~
文:sentence:~
文字:character:~
文字列:string:~
文字大小無視:case-insensitive:~

文脈:context:~
	片:fragment:~
新たな:new:~
方向:direction:~
方向性:directionality:~
方向性有りの:directionality-capable:~

画像:image:~

	implied:~
更新-:update:~
格納-:store:~
検査-:check:~
検査器:checker:~
検索:search:~


構文:syntax::~::シンタックス
構文上:syntactical::~::シンタック上
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ

構造:structure:~
権限:authority:~
装置:device:~
段:step:~
段落:paragraph:~
	段落~内:intra-paragraph
比較-:compare:~
被取得時:被 get 時:~
被設定時:被 set 時:~
被呼出時:被 invoke 時:~

状態:state:~
現在:currently:~
現在の:current:~
生成-:generate:~
生成元:origin::~::オリジン
素片:fragment:~
scheme::::スキーム
	略称:abbreviation:~
発火-:fire::~
発話:speech::~
目的0:purpose:目的
直列化:serialisation::~::シリアル化
直列化-:serialise::~::シリアライズ
	~~作用-:interact:~
対話-:interact:やりとり
対話:interaction:~
相似的:analogous:~
相対的:relative:~
	基準に:relative:~
省略-:omit:~
省略:omission:~
省略可能:optional:~
種類:kind:~
空:empty:~
	空でない:non-empty
空白:whitespace:~
空白類:space characters:~
空白並び:spaces:~
空白区切りの:space-separated:~
符号化法:encoding::~::エンコーディング
等価:equivalent:~

範囲:range:~
素早く:quick に:~
	直に飛べる
終端-:terminate:~
終端0:end:終端
開始-:start:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
絶対:absolute:~
継承-:inherit:~
	し続ける:continue:~
置換-:replace:~
置換あり:replacement enabled:置き換えあり
翻訳-:translate:~
翻訳:translation:~
可翻訳:translate-enabled:~
翻訳可能:translatable:~
翻訳不可:no-translate:~
考慮-:consider:~
自前の:own:~
自動的:automatic:~
色:colour:~
行先:destination::~
表現-:represent:~
表示-:display:~

見出し:heading:~
見出す:find:~
規則:rule:~
視覚的:visual:~
視野:scope:~
親:parent:~
言語:language:~
設定-:set:~
設定子:setter::~
設定群:settings::~
認識-:recognise:~
読上げる:read する:~
読取って:read して:読み取って
読取器:reader::~::リーダ
	読込-:load::~::ロード
再読込み:reload::再読み込み::リロード
読込んで:load して::読み込んで::ロードして
読込まれ:load され::読み込まれ::ロードされ
読込み:loading::読み込み::ローディング
読込後:post-load:load 後:読込み後::ロード後
資格証:credentials::資格証明情報::クレデンシャル

論理的:logical:~
識別-:identify:~
識別子:identifier:~
走らす:run する:~
走らせ:run し:~
走って:run して:~
	起こる:happen:~

追加-:add:~
送信-:send:~
送達-:deliver:~
透過的:transparent:~
連なり:run:~
連結-:concatenate:~

選定:selection:~
選択子:selector::~::セレクタ
	避ける:avoid する:~
	配-:place:~
	類似する:similar:~
	類似的に／同様に:similarly:~
重なる:overlap する:重なり合う
重なって:overlap して:重なり合って
重複:duplicate:~
長さ:length:~
閲覧文脈:browsing context::~
除去-:remove:~
隔離-:isolate:~
隔離:isolation:~
	隠す:hide する:~
集合:set:~
音量:volume:~
頁:page:::ページ
有順序:ordered:~
順序:order:~
順序付け:ordering:~
分類-:categorise:~
分類:category:~
	類別
	categories
大分類:broad categories:~
約物:punctuation:~
右横書き:right-to-left:~
左横書き:left-to-right:~
	ltr:::左横書き
	rtl:::右横書き


不可視:non-visible:~
	人名:person's name:~
	'
企業:corporate:~
会話:conversation:~
作品:work:~
	便宜のため／簡便に記せるようにconvenience:~
公共用途の:publicly-usable:~
再入的:reentrant::~
冗長:redundant:~
削除-:delete:~
剥いで:stripして:~
受信-:receive:~
合成:synthesis:~
困難:difficult:~
地域化-:localize:~
変異:mutation:~
外部:external:~
大文字:uppercase:~
小文字:lowercase:~
太字:bold:~
始端辺:start edge:~
実行:executing:~
帯域外の:out of band:~
数字:digit:~
数的:numeric:~
整形式:well-formedness:~

方向的:directional:~
本体:body::~::ボディ

照合:matching:~
生成規則:production:~
	異種の:disparate:~
発音:pronunciation:~
章節ing:sectioning::章節::
章節:section::~::
	章·節
	簡略化するため~for~simplicity
縮退-:collapse:~
署名行:byline:~
衝突:clash:~
被support:supported:::被サポート
製品:product:~
複合されたcompound:~
見出され~found:~
詩:poem:~
近過去:recent:~
進捗:progress:~
音楽:music:~

改行文字:newline:~
準備度:readiness:~
取込む:import する:取り込む

割込まれ:interrupt され:割り込まれ
通信:communicating:~
展開-:expand:~
	expansion
携帯端末:mobile phone:~
並列処理:multiprocess:~
名値:name-value:名-値
pair::::ペア
path::::パス
pointing::::ポインタ指示
record::::レコード
参考情報:advisory information:~
支援技術:assistive technology:~
自動:auto::~
blind:::目の不自由な
引用文:citation:~
client::::クライアント
連結:concatenation:~
伝達-:convey:~
credit:::
符号化-:encode::~::エンコード
自由形式:free-form:~
形成-:form:~

prototype:
chain:
stack::::スタック
marker::::マーカ
自律的:autonomous::~
昇格:upgrade::~
構築:construction::~::コンストラクション
構築済みの:constructed::~::コンストラクト済みの
構築-:construct::~::コンストラクト
構築子:constructor::~::コンストラクタ

	●
依存-:depend:~
依拠-:rely:~
充足-:fulfill:~
保全-:preserve:~
余分の:extra:追加の
thematic::::テーマによる
不測の:unforeseen:~
正当:legitimate:~
経験則:heuristic:~
混成的:hybrid:~
指示書き:instructions:~
応用:application:~
私的な:private:~
一定の:certain:~
	ある種の
第一:primary:~
第一の:primary な:主な

一意:unique:~
一般的な:general:~
一般:general:~
上書き:override:~
事例:case:~
事実:fact:~
互換:compatible:~
	mutually compatible:::
仕方:way:~
仕様:specification:~
仕組み:mechanism:~
未定義:undefined:~
未知の:unknown:~
未知:unknown:~
条件:condition:~
標準の:standard:~
標準:standard:~
標準化-:standardise:~
機能性:functionality:~
不正:incorrect:~
正しい:correct な:~
正しく:correct に:~
正確:exact:~
殆どの:ほとんどの
著作補助:authoring aid:~
著作:authoring:~
維持管理-:maintain:~
関係-:relate:~
関係性:relationship:~
不許可に:disallow:~
注釈:annotation:~
注釈-:annotate:~
孕む:involve する:~
完全:complete:~
実装-:implement:~
実装:implementation:~
実際:actual:~
定義-:define:~
定義:definition:~
実行-:execute:~
実行:execution:~
導出-:derive:~
影響-:affect:~
含意-:imply:~
有意:significant:~
	意味を持つ:meaningful:~
有用:useful:~
期待-:expect:~
期待:expectation:~
概して:typical に:~
概念:concept:~
意味-:mean:~
意味-:mean:~
意味:meaning:~
意味論:semantics:~
意味論上の:semantic:~
意図-:intend:~
所与の:given:与えられた
手動:manual:~
手続き:steps:~
技術:technology:~
荒削り:crude:~
木目細かい:fine-grained:~
語彙:vocabulary:~
護符:talisman:~
資質:nature:~
除外-:exclude:~
方式:manner:~
拘束:constraints:~
拡張-:extend:~
拡張:extension:~
指定-:specify:~
指示-:indicate:~
挙動:behavior:ふるまい
	behaviour:~
接頭辞:prefix:~
推薦-:suggest:~
提供-:provide:~
既定の:default:~
既知の:known:~
定めら:state さ:~
	explicitly state:明示的に定められ
明示的:explicit:~
暗黙的:implicit:~
最善:best:~
汎的:generic:~
決定-:determine:~
決定:determination:~
注意深く:careful に:~
特定0の:particular:ある特定の
特徴:characteristic:~
特有の:specific な:~
特定的な:specific な:詳細度の高い:~
特定の:specific な:~
特色機能:feature:~
状況:situation:~
独立:independent:~
現代の:modern:~
用語:term:~
相応しい:suitable な:~
相違:differences:~
管理-:manage:~
管理:management:~
管理者:administrator:~
	簡便:convenient:~
	節:section:~
精確:precise:~
混同-:confuse:~
	confusingly
混同:confusion:~
無視-:ignore:~
	無関係:not relevant:~
要件:requirement:~
要件:requirements:~
要求-:require:~
督促-:urge:~
移行:migration:~
恒久的:permanent:~
想定-:suppose:~
抑制-:reduce:~
遂行-:perform:~
判定基準:criteria:~
	別個の:distinct:~
再利用:reuse:~
利用:use:~
利用者:user:~
将来的:future:~
将来:future:~
奨励-:encourage:~
	しないことが奨励~discourage:::
制御:control:~
制約-:restrict:~
制約:restriction:~
制限-:limit:~
効果:effect:~
効果的:effective:~
単独の:single:~
単純:simple:~
原則:principle:~
共通して:common に:~
共通する:common:~
動作-:act:~
見本:sample:~
規範的:normative:~
	規範的でない:non-normative:~
解釈-:interpret:~
記述-:describe:~
記述:description:~
述べら:describe さ:~
述べる:describe する:~
述べた:describe した:~
設計-:design:~
許可-:permit:~
許容-:allow:~
試みて:attempt して:~
試行-:try:~
詳細:details:~
誤用-:mis-use:~
誤解釈-:misinterpret:~
論じる:discuss する:~
論題:topic:~
警告-:warn:~
追加の:additional:~
適切:appropriate:~
適合-:conform:~
適合:conforming:~
	適合しない／適合でない:non-conforming:~
適合性:conformance:~
適正:proper:~
適用-:apply:~
適用可能:applicable:~
間接的:indirect:~
関連の:relevant:~
関連する:relevant な:~
破壊的:disastrous:~
機械:machine:~
解決策:solution:~
community::::コミュニティ
通常は:normal には:~
既存の:existing:~
到達-:reach:~
働く:work する:~
確保-:ensure:~
関係ない:unrelated:~
	真っ直ぐ:linear
直接的:direct:~
便宜:convenience:~

	●未分類
	そらす~lateral
	在-:present:~
	両者:both:~
	供-:contribute:~
	合間:between:~
	同じ:same:~

	-:hyphen#1
	-:space ship
	5 ~five
	AL
	ARIA
	BCP:#4
	BOM
	Browser:#1
	Content-Type
	E-mail
	Embedded
	Ernest
	LF
	LINE FEED
	MathML
	Mellblom
	Metadata
	MyTrans
	Paragraph Level
	Paragraph:#1
	Reset Button
	SPACE
	Search
	UTF-8
	XSLT
	ABNF
	Button
	POP DIRECTIONAL FORMATTING
	POP DIRECTIONAL ISOLATE
	R
	RDF
	anywhere
	case-sensitive:#1
	compared
	consisting
	despite
	ever
	everything
	imposing
	knew
	know
	letting
	moment:
	孤立している:orphan
	potential
	potentially
	proud
	~additionally:#1
	~alternative:#1
	~alternatively
	~anyone
	~anything
	~around:
	~basically
	~become
	~broad:::
	~called:::
	~changing:::
	~come:::
	~communicated:::
	~doing:::
	~don:::
	~drop::::
	~fall:::
	~followed:::
	~footer::::フッター
	~goes:::
	~group分け~grouping:::
	~having:::
	~hidden:::
	~included:#1
	~indeed:::
	~interrupt:::
	~involving:::
	~left:::
	~line:::
	~making:::
	~merely:::
	~mildly:::
	~missing:::
	~my:::
	~neither:::
	~non-HTML:::
	~noncharacter:::
	~nor:::
	~note:#1
	~noted:::
	~notice:::
	~onto:::
	~part:::
	~per:::
	~picked:::
	~play:::
	~ready:::
	~remain:::
	~remainder:::
	~rest:::
	~right:::
	~said:::
	~say:::
	~scriptを~supportする:script-supporting
	~span:::
	~strip:::
	~treating:::
	~true:::
	~tuple:::
	~twice:::
	~unknowingly:::
	~very:::
	~wanted:::
	~wide:::
	~zeroを前置:zero-padded
	~~らしきもの~sense:::
事故:incidences:~
	~~内側の~inner-most:::
	~~区切り:scope closure
	~~参照:refer:::
	~~情報を~~交換しあって working in unison communicated:::
	~~手段:resort:#1
	~~文章~quote:::
	~~最後の~final:::
	~~追加~push::::
	~~選択~picker:::
	~~隣接する:preceded or followed
	†:asterisk
	〜に基づく:based#1
	〜の代わりに:instead#6
	あてがう:assign#5
	いくつかの:several#1
	かかわらず:regardless:#1
	この:this#67
	これらの:these#18
	しかしながら，:however#7
	したがって:therefore#2
	したがって:thus#7
	すでに:already#1
	すなわち~namely:::
	すべての:all#30
	そうすることに~~意味があるならWhere it makes sense
	その:that#56
	そのような:such#20
	それら:they#4
	それらの:their#11
	それらの:those#13
	それらを:them#3
	それら自身:themselves#1
	とりわけ:especially#1
	の他にも~beyond:#1
	の他にも~even~beyond
	ふりをする~impersonate:::
	べき:should#6
	またがって／~across:#2
	まったくtruly:#1
	まとめるtogether:#1
	ままleave:#1
	もの:thing#1
	より低速:slower#1
	より良い:better:#1
	より高~levelの:higher-level:#2
	アップグレード~upgrade:::
	一助tool to help
	一節:stanza:#1
	万能:panacea:#1
	三つ:three:~
	三番目の:third#1
	上:above#5
	下:below#2
	与-:give#11
	乏しい:poorly:#1
	二つ:two#6
	二番目の:second#6
	人から読まれるhuman-readable:#1
	介:via#1
	他にもあるThat's not all, either	'
	他の:other#29
	他の部分~the~rest
	以前の:previous#3
	伝える:inform#1
	伝えるtell:#3
	何か:something#1
	何ら~absolutely~no:#1
	例:example#15
	依然として:still#3
	個々の:individual#1
	働いて~working:::
	元々:originally#1
	元の:original#1
	先掲の~the~earlier
	先頭:at the front:::
	全体:entire／entirely
	具体例~for instance,
	判るように~would not be discoverable
	別々の:separate0#2
	別の:another#8
	利用でき~usable:#3
	則って:according-to:#2
	前:before#2
	前述の:aforementioned:~
	半分:half of:#2
	各:each#18
	同じ節の副~見出し:subheading or subtitle (a subordinate heading for the same section)
	含-:include#12
	含めて:including#4
	四つ:four#1
	多くの:many#3
	多様な~wide~variety:#2
	大きい:large#2
	始-:begin#1
	字~letter:::
	存続する~lifetime:::
	容易:ease／easier
	容易く~mildly~easier
	対応ing:corresponding#2
	小さい:small#1
	属する:belong:#2
	巡回~navigate~around
	常に:always#1
	形:form
	後:after#3
	後でlater:#1
	後続-／従う:follow#1
	必要-:need#2
	必要とされ:necessary#2
	戻-:back#1
	扱う:treat#2
	括って~put
	支援~aid:::
	数:number#4
	明らかに:clearly:#1
	易くする~help:::
	時点~instant~in~time:~
	更なる:further#4
	書-:write#3
	最も近傍の:nearest#2
	最初の:first#25
	最後の:last#3
	次:next#4
	欲-:desire#1
	残りのremaining:#1
	注意すべき点があるCaution is advised with:::
	渡-:pass#2
	渡され~passed:::
	焦点をあてている~focused~on
	特に~most notably:::
	猫~cat:::
	現れさせ~appear:::
	理解でき:comprehensible:
	生-:occur#1
	用立てmake use
	異なる:different#5
	示す:show#12
	種々の:various#3
	等々:etc#1
	等々~and~so~forth:#1
	等しく:equally:#2
	終えてfinish:#2
	結果:result#1
	結果になる~end up
	結果の:resulting#6
	聴ける~hear:::
	脚注~footnote:::
	自身:itself#4
	著しく~quite
	複数の:multiple#4
	複雑に:complicate:~
	見~looking:::
	見かけ:look #3
	見かけ:look like
	見よ:see#2
	解説~commentary
	言えない~admittedly:::
	記す~denote:::
	調べ~examine::::
	返す:return#44
	通:through#4
	開く:open する:~
	除-:except#5
	難しくharder:#1
	難しく~hard:#1
	飛ぶ~jump

</script>


<!--%style -->
<style type="text/css">
*[lang="en"] {
	white-space: pre-line;
}

.unicode-category {
	color: green;
}

.category-list > li {
	display: inline;
}
.category-list > li::before {
	content: "• ";
}

pre {
	white-space: pre-wrap;
}

.attr-state {
	font-family: sans-serif0, sans-serif;
}

</style>
<!-- 
.category-list > li:first-child::before {
	content: "";
}
-->
</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Living Standard — Semantics, structure, and APIs of HTML documents 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Semantics, structure, and APIs of HTML documents</a>
章を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-05-03</time>
（公開：<time>2016-03-11</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">
	<hgroup>
<h1>HTML Living Standard</h1>
<h2>HTML 文書の意味論, 構造, API</h2>
<h2>Semantics, structure, and APIs of HTML documents</h2>
<h3>最終更新 2016 年 5 月 2 日</h3>
	</hgroup>

</header>

<nav class="toc" id="toc">
<h2>目次</h2>
<ol id="_toc_list0"></ol></nav>

<hr>

<main id="MAIN" style="display:none;">

	<section id="dom">
<h2 title="Semantics, structure, and APIs of HTML documents">3. ~HTML文書の意味論, 構造, ~API</h2>

		<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="documents">
<h2 title="Documents">3.1 文書</h2>

<p>
~HTML~UAにおける どの
~XML／~HTML 文書
も， `Document$I ~objにより表現される†。
`DOM$r
◎
Every XML and HTML document in an HTML UA is represented by a Document object. [DOM]
</p>

<p class="trans-note">【
以下，この訳では、 `Document$I ~objを単に
`文書@
と略記する。
】</p>

<p>
`文書$ %文書 の
`~address@
とは、~DOM標準に定義される， %文書 に
<a href="~DOM4#concept-document-url">結付けられている~URL</a>
である。
それは、
%文書 の作成-時に設定されるが，
%文書 が存続する間に変化し得る
— 例えば、利用者が頁~上の`素片$へ`~navigate$するときや，新たな `~URL$x を渡して `pushState()$m ~methodが~callされるときに、変更される。
`DOM$r
◎
The document's address is the URL associated with a Document (as defined in the DOM standard). It is initially set when the Document is created, but that can change during the lifetime of the Document; for example, it changes when the user navigates to a fragment on the page and when the pushState() method is called with a new URL. [DOM]
</p>

<p class="warning">
対話的~UAは、概して，その利用者~interfaceに文書の`~address$を公開する。
これは、~siteが別の何かのふりをしようと試みている場合に，それを利用者に伝えれるようにする第一の仕組みである。
◎
Interactive user agents typically expose the document's address in their user interface. This is the primary mechanism by which a user can tell if a site is attempting to impersonate another.
</p>

<div class="p">
<p>
`文書$ %文書 が`~script$により［
`createDocument()$m ／
`createHTMLDocument()$m
］~APIを利用して作成されるときは：
</p>

<ul>
	<li>
%文書 の`~address$は，その~scriptの`設定群~obj$により指定される`担当の文書$の`~address$と同じになる。
</li>
	<li>
%文書 は即時に，`読込後~taskの準備が整う$x, かつ`完全に読込まれる$x。
</li>
</ul>

◎
When a Document is created by a script using the createDocument() or createHTMLDocument() APIs, the document's address is the same as the document's address of the responsible document specified by the script's settings object, and the Document is both ready for post-load tasks and completely loaded immediately.
</div>

<p>
文書の
`~referrer@
とは、`文書$の作成-時に設定され得る`絶対~URL$xである。
明示的に設定されない場合の値は空~文字列である。
◎
The document's referrer is an absolute URL that can be set when the Document is created. If it is not explicitly set, then its value is the empty string.
</p>

<p>
各
`文書$は、
`再読込み上書き~flag@
を持つ（初期時~OFF）。
この~flagは、ある種の状況においては，`文書$の
`open()$m ／ `write()$m
~methodにより ~ON にされる。
この~flagが ~ON にされたときは、
`文書$は，
`再読込み上書き~buffer@
も持つ
— それは、~Unicode文字列であり，文書の再読込み時に~sourceとして利用される。
◎
Each Document object has a reload override flag that is originally unset. The flag is set by the document.open() and document.write() methods in certain situations. When the flag is set, the Document also has a reload override buffer which is a Unicode string that is used as the source of the document when it is reloaded.
</p>

<p>
~UAは、`~source閲覧文脈$ %B が与えられた下で
`上書きされた再読込み@
を遂行するときは、次に従って動作し~MUST：
◎
When the user agent is to perform an overridden reload, given a source browsing context, it must act as follows:
</p>

<ol>
	<li>
%文書 ~LET  %B の`作動中の文書$
</li>
	<li>
%~source ~LET %文書 の`再読込み上書き~buffer$の値
◎
Let source be the value of the browsing context's active document's reload override buffer.
</li>
	<li>
%~address ~LET %文書 の`~address$
◎
Let address be the browsing context's active document's address.
</li>
	<li>
%~HTTPS状態 ~LET %文書 の`~HTTPS状態$
◎
Let HTTPS state be the HTTPS state of the browsing context's active document.
</li>
	<li>
%~CSP~list ~LET %文書 の`~CSP~list$
◎
Let CSP list be the CSP list of the browsing context's active document.
</li>
	<li>

<div class="p">
<p>
%応答 ~LET 次のようにされた，新たな`応答$x
</p>

<ul>
<li>`本体$rs ~SET %~source
<li>`~CSP~list$rs ~SET %~CSP~list
<li>`~HTTPS状態$rs ~SET %~HTTPS状態
</ul>


<p>
次を与える下で，
%B を %応答 へ`~navigate$する（例外投出あり）：
</p>

<ul>
<li>`例外~可能化~flag$x ~SET ~ON
<li>`置換あり$x
<li>`~source閲覧文脈$ ~SET %B
</ul>

<p>
`~navigation~algo$が，この目的0で新たな`文書$を作成したときは、次のようにする
⇒
文書の`再読込み上書き~flag$ ~SET ~ON；<br />
文書の`再読込み上書き~buffer$ ~SET %~source
</p>

◎
Navigate the browsing context to a new response whose body is source, CSP list is CSP list and HTTPS state is HTTPS state, with the exceptions enabled flag set and replacement enabled. The source browsing context is that given to the overridden reload algorithm. When the navigate algorithm creates a Document object for this purpose, set that Document's reload override flag and set its reload override buffer to source. Rethrow any exceptions.
</div>

<p>
`~navigation~algo$において，文書の`~addressを設定する$所では、`上書き~URL$に %~address を利用する
◎
When it comes time to set the document's address in the navigation algorithm, use address as the override URL.
</p>

	</li>
</ol>


			<section id="the-document-object">
<h3 title="The Document object">3.1.1. `Document^I ~obj</h3>

<p>
この仕様は、
WHATWG DOM 標準にて定義される
<a href="~DOM4#interface-document">`Document^I</a>
~interfaceを有意に拡張する：
◎
The WHATWG DOM standard defines a Document interface, which this specification extends significantly:
</p>


<pre class="idl">
enum `DocumentReadyState@I { "loading", "interactive", "complete" };
typedef (`HTMLScriptElement$I or `SVGScriptElement$I) `HTMLOrSVGScriptElement@I;

[OverrideBuiltins]
partial /*sealed*/ interface `Document@I {
  // <span class="comment">
<a href="#resource-metadata-management">資源~metadata管理</a>
◎
// resource metadata management
</span>
  [PutForwards=`href$m, Unforgeable] readonly attribute `Location$I? `location$m;
  attribute USVString `domain$m;
  readonly attribute USVString `referrer$m;
  attribute USVString `cookie$m;
  readonly attribute DOMString `lastModified$m;
  readonly attribute `DocumentReadyState$I `readyState$m;

  // <span class="comment">
<a href="#dom-tree-accessors">~DOM~木~accessor</a>
◎
// DOM tree accessors
</span>
  `getter$m object (DOMString name);
  [`CEReactions$] attribute DOMString `~document-title$m;
  [`CEReactions$] attribute DOMString `~document-dir$m;
  [`CEReactions$] attribute `HTMLElement$I? `body$m;
  readonly attribute `HTMLHeadElement$I? `head$m;
  [SameObject] readonly attribute `HTMLCollection$I `images$m;
  [SameObject] readonly attribute `HTMLCollection$I `embeds$m;
  [SameObject] readonly attribute `HTMLCollection$I `plugins$m;
  [SameObject] readonly attribute `HTMLCollection$I `links$m;
  [SameObject] readonly attribute `HTMLCollection$I `forms$m;
  [SameObject] readonly attribute `HTMLCollection$I `scripts$m;
  NodeList `getElementsByName$m(DOMString elementName);
  readonly attribute `HTMLOrSVGScriptElement$I? `currentScript$m;  // <span class="comment">
文書~内の`~classic~script$のみ
◎
classic scripts in a document only
</span>

  // <span class="comment">
<a href="~HTML5/webappapis.html#dynamic-markup-insertion">動的~markup挿入</a>
◎
// dynamic markup insertion
</span>
  [`CEReactions$] `Document$I `open$m(optional DOMString type = "text/html", optional DOMString replace = "");
  `WindowProxy$I `open$m(DOMString url, DOMString name, DOMString features, optional boolean replace = false);
  [`CEReactions$] void `close$m();
  [`CEReactions$] void `write$m(DOMString... text);
  [`CEReactions$] void `writeln$m(DOMString... text);

  // <span class="comment">
<a href="~HTML5/interaction.html#editing">利用者~対話</a>
</span>
  readonly attribute `WindowProxy$I? `defaultView$m;
  readonly attribute `Element$I? `activeElement$m;
  boolean `hasFocus$m();
  [`CEReactions$] attribute DOMString `designMode$m;
  [`CEReactions$] boolean `execCommand$m(DOMString commandId, optional boolean showUI = false, optional DOMString value = "");
  boolean `queryCommandEnabled$m(DOMString commandId);
  boolean `queryCommandIndeterm$m(DOMString commandId);
  boolean `queryCommandState$m(DOMString commandId);
  boolean `queryCommandSupported$m(DOMString commandId);
  DOMString `queryCommandValue$m(DOMString commandId);

<!-- 
  // special event handler IDL attributes that only apply to Document objects
 -->
  // <span class="comment">
`文書$のみに適用される特別な`~event~handler~IDL属性$
</span>
  [LenientThis] attribute `EventHandler$I `onreadystatechange$m;
};
`Document$I implements `GlobalEventHandlers$I;
`Document$I implements `DocumentAndElementEventHandlers$I;
</pre>


<p>
各 `文書$は
`~HTTPS状態@
を持つ。
それは、`文書$の~dataを送達するときに利用される~network~channelの，保安~上の~propを表現する。
その値は、［
`modern^l ／ `deprecated^l ／ `none^l
］のいずれかである。
明示的に設定されない場合、値 `none^l をとる。
◎
The Document has an HTTPS state, which represents the security properties of the network channel used to deliver the Document's data. The value will be one of "modern", "deprecated", or "none". If it is not explicitly set, then its value is "none".
</p>

<p>
各 `文書$は
`~CSP~list@
を持つ。
それは、この文脈において作動中の`~CSP~obj$xの~listである。
この~listは、他から指定されない限り空とする。
◎
The Document has a CSP list, which is a list of Content Security Policy objects active in this context. The list is empty unless otherwise specified.
</p>

<p>
各 `文書$は、初期時は空の`~module~map$xである
`~module~map@
を持つ。
◎
The Document has a module map, which is a module map, initially empty.
</p>



			</section>
			<section id="resource-metadata-management">
<h3 title="Resource metadata management">3.1.2. 資源~metadataの管理</h3>

  <dl class="domintro">

	<dt>%document . `referrer$m</dt>
	<dd>
利用者がこの文書へ~navigateした元の`文書$の`~address$を返す。
~navigateが阻止されていたときや，そのような文書がなければ空~文字列を返す。
◎
Returns the address of the Document from which the user navigated to this one, unless it was blocked or there was no such document, in which case it returns the empty string.
</dd>
	<dd>
~referrerを阻止したければ `noreferrer$c ~link型を利用できる。
◎
The noreferrer link type can be used to block the referrer.
</dd>

</dl>

<p>
`referrer@m
属性は、文書の`~referrer$を返さ~MUST
◎
The referrer attribute must return the document's referrer.
</p>

<hr>

<dl class="domintro">

	<dt>%document . `cookie$m [ = %value ]</dt>
	<dd>
`文書$に適用されている一連の~HTTP~cookieを返す。
~cookieが無い, もしくはこの資源に適用できない場合、空~文字列が返される。
◎
Returns the HTTP cookies that apply to the Document. If there are no cookies or cookies can't be applied to this resource, the empty string will be returned.
</dd>
	<dd>
設定して，要素の~HTTP~cookieの集合に新たな~cookieを追加できる。
◎
Can be set, to add a new cookie to the element's set of HTTP cookies.
</dd>
	<dd>
内容が`一意~生成元に~sandbox化され$xている場合（例： `sandbox$a 属性を有する `iframe$e の中）、被取得時, 被設定時のいずれに対しても，
`SecurityError$E 例外が投出されることになる。
◎
If the contents are sandboxed into a unique origin (e.g. in an iframe with the sandbox attribute), a SecurityError exception will be thrown on getting and setting.
</dd>

</dl>


<dl class="idl-def">
	<dt>`cookie@m</dt>
	<dd>
この属性は、文書の`~address$で識別される資源の~cookieを表現する。
◎
The cookie attribute represents the cookies of the resource identified by the document's address.
</dd>
	<dd>
<p>
次のいずれかの条件を満たすような`文書$ %文書 は、
`反cookie文書@
とされる：
◎
A Document object that falls into one of the following conditions is a cookie-averse Document object:
</p>

<ul>
	<li>
%文書 が`属する閲覧文脈$はない
◎
A Document that has no browsing context.
</li>
	<li>
%文書 の`~address$の`~scheme$urlは、`~network~scheme$xではない。
◎
A Document whose address's scheme is not a network scheme.
</li>

</ul>

</dd>
	<dd>
<p id="sandboxCookies">
被取得時には、次を走らせ~MUST
~FINGERPRINTING
</p>

		<ol>
			<li>
~IF［
此れは、`反cookie文書$である
］
⇒
~RET 空~文字列
</li>
			<li>
~IF［
此れの`生成元$は`不透明な生成元$である
］
⇒
~THROW `SecurityError$E
</li>
			<li>
%~cookie値 ~LET “非~HTTP” ~APIに対する，［
此れの`~address$に対する `cookie-string$P
］
`COOKIES$r
◎
↓</li>
			<li>
~RET
%~cookie値 を， `BOM を取り扱わずに UTF-8 復号-$xした結果
</li>
		</ol>
◎
On getting, if the document is a cookie-averse Document object, then the user agent must return the empty string. Otherwise, if the Document's origin is an opaque origin, the user agent must throw a SecurityError exception. Otherwise, the user agent must return the cookie-string for the document's address for a "non-HTTP" API, decoded using UTF-8 decode without BOM. [COOKIES]


 not a scheme/host/port tuple, 
</dd>
	<dd>
<p>
被設定時には、次を走らせ~MUST：
</p>

		<ol>
			<li>
~IF［
此れは、`反cookie文書$である
］
⇒
~RET
</li>
			<li>
~IF［
此れの`生成元$は`不透明な生成元$である
］
⇒
~THROW `SecurityError$E
</li>
			<li>
%~cookie値 ~LET 新たな値を `UTF-8 符号化-$xした結果
`ENCODING$r
◎
↓</li>
			<li>
“非~HTTP” ~APIを介して，［
此れの`~address$に対する，
<a href="~HTMLCONFORM#receives-a-set-cookie-string"
>%~cookie値 からなる `set-cookie-string^P を受信した</a>
］かのように動作する

`COOKIES$r
</li>
		</ol>

◎
On setting, if the document is a cookie-averse Document object, then the user agent must do nothing. Otherwise, if the Document's origin is an opaque origin, the user agent must throw a SecurityError exception. Otherwise, the user agent must act as it would when receiving a set-cookie-string for the document's address via a "non-HTTP" API, consisting of the new value encoded as UTF-8. [COOKIES] [ENCODING]
</dd>

</dl>

<p class="note">注記：
`cookie$m 属性は、~frame間をまたがって~access可能なので、~cookieに対する~path制約は、~cookieが~siteのどの部分に送信されたか管理する一助になるに過ぎない
— それは，どのような保安~上の特色機能でもない。
◎
Since the cookie attribute is accessible across frames, the path restrictions on cookies are only a tool to help manage which cookies are sent to which parts of the site, and are not in any way a security feature.
</p>

<p class="warning">
`cookie$m 属性の取得子／設定子は、共有される状態に同期的に~accessする。
~lockするための仕組みはないので、並列処理~UAにおいては，他の閲覧文脈が~scriptを走らせている間に~cookieを改変し得る。
具体例として、~siteは，~sessionの一意~識別子として
~cookieを読取って, 値を増分してから，
~cookieの新たな値として書き戻そうと試行することもできるが、その~siteがこれを二つの~browser~windowで同時に行った場合、両~sessionに同じ “一意” 識別子を利用する結果になり，破壊的な効果をもたらし得る。
◎
The cookie attribute's getter and setter synchronously access shared state. Since there is no locking mechanism, other browsing contexts in a multiprocess user agent can modify cookies while scripts are running. A site could, for instance, try to read a cookie, increment its value, then write it back out, using the new value of the cookie as a unique identifier for the session; if the site does this twice in two different browser windows at the same time, it might end up using the same "unique" identifier for both sessions, with potentially disastrous effects.
</p>

<hr>

<dl class="domintro">

	<dt>%document . `lastModified$m</dt>
	<dd>
~serverから報告された文書の最終改変~日時を 利用者の地域標準時に換算した結果を，
`MM/DD/YYYY&nbsp;hh:mm:ss^l の形にして返す。
◎
Returns the date of the last modification to the document, as reported by the server, in the form "MM/DD/YYYY hh:mm:ss", in the user's local time zone.
</dd>
	<dd>
最終改変~日時が既知でない場合、代わりに現在の時刻が返される。
◎
If the last modification date is not known, the current time is returned instead.
</dd>

</dl>

<p>
`lastModified@m
属性の被取得時には、`文書$の~source~fileの最終改変~日時を 利用者の地域標準時に換算した結果を，次の並びによる形式にして返さ~MUST：
◎
The lastModified attribute, on getting, must return the date and time of the Document's source file's last modification, in the user's local time zone, in the following format:
</p>

<div>
<ol>
<li>日付の月成分
<li>❝/
<li>日付の日成分
<li>❝/
<li>日付の年成分
<li>U+0020 SPACE
<li>時刻の時成分
<li>❝:
<li>時刻の分成分
<li>❝:
<li>時刻の秒成分
</ol>

◎
• The month component of the date.
• A U+002F SOLIDUS character (/).
• The day component of the date.
• A U+002F SOLIDUS character (/).
• The year component of the date.
• A U+0020 SPACE character.
• The hours component of the time.
• A U+003A COLON character (:).
• The minutes component of the time.
• A U+003A COLON character (:).
• The seconds component of the time.
</div>


<p>
上の各~成分のうち，［
年成分は 4 桁~以上かつ最短の, 他の成分すべては 2 桁の
］`~ASCII数字$列で，必要なら~zeroを前置して、当の成分を基数 10 の数で表現するように与えられ~MUST。
◎
All the numeric components above, other than the year, must be given as two ASCII digits representing the number in base ten, zero-padded if necessary. The year must be given as the shortest possible string of four or more ASCII digits representing the number in base ten, zero-padded if necessary.
</p>

<p>
`文書$の~source~fileの最終改変~日時は、利用-中の~networking~protocolに関連する特色機能から導出され~MUST
—
例えば、文書の~HTTP 
<a href="~RFC7232#section-2.2">`Last-Modified^h</a>
~headerの値から, あるいは
局所~fileに対しては~file~system内の~metadataから。
最終改変~日時が未知の場合、この属性は，上の形式による現在の日時を返さ~MUST。
◎
The Document's source file's last modification date and time must be derived from relevant features of the networking protocols used, e.g. from the value of the HTTP `Last-Modified` header of the document, or from metadata in the file system for local files. If the last modification date and time are not known, the attribute must return the current date and time in the above format.
</p>

<hr>

<dl class="domintro">

	<dt>%document . `readyState$m</dt>
	<dd>
`文書$を読込んでいる間は `loading^l を返す。
構文解析を終えて後, かつ下位資源を読込んでいる間は
`interactive^l を返す。
読込まれて以降は、 `complete^l を返す。
◎
Returns "loading" while the Document is loading, "interactive" once it is finished parsing but still loading sub-resources, and "complete" once it has loaded.
</dd>
	<dd>
この値が変化したときは、`文書$に向けて
`readystatechange$et ~eventが発火される。
◎
The readystatechange event fires on the Document object when this value changes.
</dd>

</dl>

<p>
各 `文書$は、
`現在の準備度@
を持つ。
`文書$の作成-時には、［
文書が［
`~HTML構文解析器$x ／ `~XML構文解析器$x ／ XSLT 処理器
］のいずれかに結付けらているならば 文字列 `loading^l ／
~ELSE_ `complete^l
］に設定され~MUST。
頁を読込んでいる間、種々の~algoがこの値に影響する。
値が設定されたときは、~UAは，`文書$に向けて名前 `readystatechange$et の`単純~eventを発火-$し~MUST。
◎
Each document has a current document readiness. When a Document object is created, it must have its current document readiness set to the string "loading" if the document is associated with an HTML parser, an XML parser, or an XSLT processor, and to the string "complete" otherwise. Various algorithms during page loading affect this value. When the value is set, the user agent must fire a simple event named readystatechange at the Document object.
</p>

<p>
まだ［
`停止-$xされても, `中止-$xされても
］いない［
`~HTML構文解析器$x ／ `~XML構文解析器$x
］に結付けられている`文書$は、
`作動中の構文解析器@
を持つとされる。
◎
A Document is said to have an active parser if it is associated with an HTML parser or an XML parser that has not yet been stopped or aborted.
</p>

<p>
`readyState@m
~IDL属性の被取得時には、此れの`現在の準備度$を返さ~MUST。
◎
The readyState IDL attribute must, on getting, return the current document readiness.
</p>

			</section>
			<section id="dom-tree-accessors">
<h3 title="DOM tree accessors">3.1.3. ~DOM木~accessor</h3>

<p>
文書の
`~html0要素@
は、［
文書の`文書~要素$が `html$e 要素であるならば それ ／
~ELSE_ ~NULL
］である。
◎
The html element of a document is its document element, if it's an html element, and null otherwise.
</p>

<hr>

<dl class="domintro">

	<dt>%document . `head$m</dt>
	<dd>
`~head0要素$を返す。
◎
Returns the head element.
</dd>
</dl>



<p>
文書の
`~head0要素@
は、［
文書の`~html0要素$ ~NEQ ~NULL であって，その子に `head$e 要素が あれば それらのうち最初のもの ／
~ELSE_ ~NULL
］である。
◎
The head element of a document is the first head element that is a child of the html element, if there is one, or null otherwise.
</p>

<p>
`head@m
属性の被取得時には、此れの`~head0要素$を返さ~MUST。
◎
The head attribute, on getting, must return the head element of the document (a head element or null).
</p>

<hr>

<dl class="domintro">

	<dt>%document . `~document-title$m [ = %value ]</dt>
	<dd>
文書の~titleを返す
— ~titleは：
~HTMLに対しては，`~title0要素$にて与えられ、
~SVGに対しては，`~SVG-title$ 要素にて与えられる。
◎
Returns the document's title, as given by the title element for HTML and as given by the SVG title element for SVG.
</dd>
	<dd>
設定して文書の~titleを更新できる。
更新する適切な要素がない場合、新たな値は無視される。
◎
Can be set, to update the document's title. If there is no appropriate element to update, the new value is ignored.
</dd>

</dl>

<p>
文書の
`~title0要素@
は、文書~内に `title$e 要素が［
あれば それらのうち（`木~順序$xで）最初のもの ／
なければ ~NULL
］である。
◎
The title element of a document is the first title element in the document (in tree order), if there is one, or null otherwise.
</p>

<p>
`~document-title@m
属性の被取得時には、次の~algoを走らせ~MUST：
◎
The title attribute must, on getting, run the following algorithm:
</p>

<ol>
	<li>
%値 ~LET 空~文字列
◎
↓</li>
	<li>
~IF［
此れの`文書~要素$ は `~SVG-svg$ 要素である
］
⇒
%値 ~SET ［
此れの`文書~要素$の子であるような，最初の `~SVG-title$ 要素
］の`子~text内容$
◎
If the document element is an SVG svg element, then let value be the child text content of the first SVG title element that is a child of the document element.
</li>
	<li>
~ELSE［
此れの`~title0要素$ ~NEQ ~NULL
］
⇒
%値 ~SET その`子~text内容$
◎
Otherwise, let value be the child text content of the title element, or the empty string if the title element is null.
</li>
	<li>
~RET %値 の`空白を剥いで縮退-$した結果
◎
Strip and collapse whitespace in value.
◎
Return value.
</li>
</ol>

<p>
被設定時には、次の手続きを走らせ~MUST：
◎
On setting, the steps corresponding to the first matching condition in the following list must be run:
</p>


<ol>
	<li>
%文書~要素 ~LET 此れの`文書~要素$
◎
↓</li>
	<li>
<p>
~IF［
%文書~要素 は `~SVG-svg$ 要素である
］：
◎
If the document element is an SVG svg element
</p>

		<ol>
			<li>
%title ~LET ~NULL
</li>
			<li>
~IF［
%文書~要素 の子に `~SVG-title$ 要素はある
］
⇒
%title ~SET それらのうち最初のもの
◎
If there is an SVG title element that is a child of the document element, let element be the first such element.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%title ~SET 次を与える下で，`要素を作成-$xした結果
⇒
( 此れ, `title^l, `~SVG名前空間$ )
<!-- 文書~要素 の~node文書 -->
◎
Let element be the result of creating an element given the document element's node document, title, and the SVG namespace.
</li>
					<li>
%文書~要素 の最初の子として， %title を挿入する
◎
Insert element as the first child of the document element.
</li>
				</ol>
			</li>
			<li>
%title の `textContent$m ~IDL属性を 所与の値に設定するかのように動作する
◎
Act as if the textContent IDL attribute of element was set to the new value being assigned.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%文書~要素 は`~HTML名前空間$に属する
］：
◎
If the document element is in the HTML namespace
</p>

		<ol>
			<li>
%title ~LET 此れの`~title0要素$
◎
↓</li>
			<li>
%head ~LET 此れの`~head0要素$
◎
↓</li>
			<li>
~IF［
%title ~EQ ~NULL
］~AND［
%head ~EQ ~NULL
］
⇒
~RET
◎
If the title element is null and the head element is null, then abort these steps.
</li>
			<li>
<p>
~IF［
%title ~EQ ~NULL
］：
◎
If the title element is non-null, let element be the title element.
◎
Otherwise:
</p>
				<ol>
					<li>
%title ~SET 次を与える下で，`要素を作成-$xした結果
⇒
( 此れ, `title^l, `~HTML名前空間$ )
<!-- 文書~要素 の~node文書 -->
◎
Let element be the result of creating an element given the document element's node document, title, and the HTML namespace.
</li>
					<li>
%title を %head に`付加する$x†
◎
Append element to the head element.
</li>
				</ol>

<p class="trans-note">【†
%head ~EQ ~NULL の場合は？
】</p>

			</li>
			<li>
%title の `textContent$m ~IDL属性を 所与の値に設定するかのように動作する
◎
Act as if the textContent IDL attribute of element was set to the new value being assigned.
</li>

		</ol>
	</li>
	<li>
~ELSE
⇒
何もしない
◎
Otherwise
◎
Do nothing.
</li>
</ol>

<hr>

  <dl class="domintro">

	<dt>%document . `body$m [ = %value ]</dt>
	<dd>
`~body0要素$を返す。
◎
Returns the body element.
</dd>
	<dd>
設定して`~body0要素$を置換できる。
◎
Can be set, to replace the body element.
</dd>
	<dd>
所与の要素が `body$e でも `frameset$e でもない場合、
`HierarchyRequestError$E 例外が投出される。
◎
If the new value is not a body or frameset element, this will throw a HierarchyRequestError exception.
</dd>
</dl>

<p>
文書の
`~body0要素@
は、［［
文書の`~html0要素$ %html ~NEQ ~NULL
］~AND［
%html の子に［
`body$e 要素, または `frameset$e 要素
］がある
］ならば それらのうち最初のもの ／
~ELSE_ ~NULL
］である。
◎
The body element of a document is the first child of the html element that is either a body element or a frameset element. If there is no such element, it is null.
</p>

<p>
`body@m
属性の被取得時には、文書の`~body0要素$を返さ~MUST。
被設定時には、次の~algoを走らせ~MUST：
◎
The body attribute, on getting, must return the body element of the document (either a body element, a frameset element, or null). On setting, the following algorithm must be run:
</p>

<ol>
	<li>
%要素 ~LET 与えられた値
</li>
	<li>
~IF［
%要素 は `body$e でも `frameset$e でもない
］
⇒
~THROW `HierarchyRequestError$E
◎
If the new value is not a body or frameset element, then throw a HierarchyRequestError exception and abort these steps.
</li>
	<li>
%文書~要素 ~LET 此れの`文書~要素$
◎
↓</li>
	<li>
~IF［
%文書~要素 ~EQ ~NULL
］
⇒
~THROW `HierarchyRequestError$E
◎
↓</li>
	<li>
%body ~LET 此れの`~body0要素$
</li>
	<li>
~IF［
%要素 ~EQ %body
］
⇒
~RET
◎
Otherwise, if the new value is the same as the body element, do nothing. Abort these steps.
</li>
	<li>
~IF［
%body ~NEQ ~NULL
］
⇒
%body の親の中で， %body を %要素 に`置換する$x；<br>
~RET
◎
Otherwise, if the body element is not null, then replace the body element with the new value within the body element's parent and abort these steps.
◎
Otherwise, if there is no document element, throw a HierarchyRequestError exception and abort these steps.
</li>
	<li>
~ELSE
⇒
%文書~要素 に %要素 を`付加する$x
◎
Otherwise, the body element is null, but there's a document element. Append the new value to the document element.
</li>

</ol>




<hr>

<dl class="domintro">

	<dt>%document . `images$m</dt>
	<dd>
`文書$内の `img$e 要素たちからなる `HTMLCollection$I を返す。
◎
Returns an HTMLCollection of the img elements in the Document.
</dd>

	<dt>%document . `embeds$m</dt>

	<dt>%document . `plugins$m</dt>
	<dd>
`文書$内の `embed$e 要素たち
からなる `HTMLCollection$I を返す。
◎
Return an HTMLCollection of the embed elements in the Document.
</dd>

	<dt>%document . `links$m</dt>
	<dd>
<p>
`文書$内の `a$e, `area$e 要素のうち，
`href$a 属性を有するもの
からなる `HTMLCollection$I を返す。
◎
Returns an HTMLCollection of the a and area elements in the Document that have href attributes.
</p></dd>

	<dt>%document . `forms$m</dt>
	<dd>
<p>
`文書$内の `form$e 要素たち
からなる `HTMLCollection$I を返す。
◎
Return an HTMLCollection of the form elements in the Document.
</p></dd>

	<dt>%document . `scripts$m</dt>
	<dd>
<p>
`文書$内の `script$e 要素たち
からなる `HTMLCollection$I を返す。
◎
Return an HTMLCollection of the script elements in the Document.
</p></dd>

</dl>


<div class="p">
<p>
［
`images@m ／ `embeds@m ／ `plugins@m ／ `links@m ／ `forms@m ／ `scripts@m
］属性の被取得時には、次のようにされた `HTMLCollection$I を返さ~MUST：
</p>

<ul>
<li>根： 此れ
<li>~filter： 属性に応じて次の表で与えられる~filter
</ul>


<table><tbody>

<tr><th>~IDL属性
<th>~filter

<tr><td>`images$m
<td>`img$e 要素のみに合致する

<tr><td>`embeds$m, `plugins$m
<td>`embed$e 要素のみに合致する

<tr><td>`links$m
<td>［
`a$e, `area$e
］要素のうち，`href$a 属性を有するもののみに合致する

<tr><td>`forms$m
<td>`form$e 要素のみに合致する

<tr><td>`scripts$m
<td>`script$e 要素のみに合致する

</tbody></table>

◎
The images attribute must return an HTMLCollection rooted at the Document node, whose filter matches only img elements.
◎
The embeds attribute must return an HTMLCollection rooted at the Document node, whose filter matches only embed elements.
◎
The plugins attribute must return the same object as that returned by the embeds attribute.
◎
The links attribute must return an HTMLCollection rooted at the Document node, whose filter matches only a elements with href attributes and area elements with href attributes.
◎
The forms attribute must return an HTMLCollection rooted at the Document node, whose filter matches only form elements.
◎
The scripts attribute must return an HTMLCollection rooted at the Document node, whose filter matches only script elements.
</div>

<hr>

<dl class="domintro">

	<dt>%collection = %document . `getElementsByName$m(%name)</dt>
	<dd>
`文書$内の要素のうち，［
`name^a 属性を有する, かつその値 ~EQ %name なるもの
］からなる `NodeList$I を返す
◎
Returns a NodeList of elements in the Document that have a name attribute with the value name.
</dd>

</dl>

<p>
`getElementsByName(name)@m
~methodの被呼出時には、此れ内にある `~HTML要素$のうち，［
`name^a 属性を有していて，その値 ~EQ %name
］なる~nodeすべてを包含している，`木~順序$xによる`~live$ `NodeList$I を返さ~MUST。
~UAは、同じ引数による複数の呼出しに対しては、同じ~objを返してよい。
そうでなければ，新たな~objを返さ~MUST。
◎
The getElementsByName(name) method takes a string name, and must return a live NodeList containing all the HTML elements in that document that have a name attribute whose value is equal to the name argument (in a case-sensitive manner), in tree order. When the method is invoked on a Document object again with the same argument, the user agent may return the same as the object returned by the earlier call. In other cases, a new NodeList object must be returned.
</p>

<hr>

<dl class="domintro">

	<dt>%document . `currentScript$m</dt>
	<dd>
現在~実行している［
`script$e ／ `~SVG-script$
］要素を返す
— その要素が`~classic~script$を表現する限りにおいて。
再入的 `script$e 実行の事例では、まだ実行し終えてないそれらのうち，最も近過去に実行し始めたものを返す。
◎
Returns the script element, or the SVG script element, that is currently executing, as long as the element represents a classic script. In the case of reentrant script execution, returns the one that most recently started executing amongst those that have not yet finished executing.
</dd>
	<dd>
`文書$が現在~実行している［
`script$e ／ `~SVG-script$
］要素が［
ない（例：走っている~scriptは~event~handlerであるか, 時間切れになった）, または`~module~script$を実行している
］場合は、~NULLを返す。
◎
Returns null if the Document is not currently executing a script or SVG script element (e.g., because the running script is an event handler, or a timeout), or if the currently executing script or SVG script element represents a module script.
</dd>
</dl>

<p>
`currentScript@m
属性の被取得時には、最も近過去に設定された値を返さ~MUST。
此れの作成-時には、~NULLに初期化され~MUST。
◎
The currentScript attribute, on getting, must return the value to which it was most recently set. When the Document is created, the currentScript must be initialised to null.
</p>


<p class="note">
この~APIは、
`script$e ／ `~SVG-script$
要素を大域的に公開するので、［
実装者, 標準
］の~communityからの支持を失っている。
そのようなわけで、`~module~script$や`~shadow木$x内の~scriptを走らすときのような，より新たな文脈の下では可用ではない。
そのような文脈で走っている~scriptを，大域的に公開させることなく識別するための
新たな解決策を探している所である。
issue <a href="https://github.com/whatwg/html/issues/1013">#1013</a> を見よ。
◎
This API has fallen out of favor in the implementor and standards community, as it globally exposes script or SVG script elements. As such, it is not available in newer contexts, such as when running module scripts or when running scripts in a shadow tree. We are looking into creating a new solution for identifying the running script in such contexts, which does not make it globally available: see issue #1013.
</p>



<hr>

<div class="p">
<p id="dom-document-namedItem-which">
`Document$I ~interfaceは、`有名~propを~supportする$x。
所与の時点における`文書$の`被support~prop名$xは：
</p>

<ul>
	<li>
`文書$内のすべての`有名~要素$の`名前$からなる
</li>
	<li>
<p>
その順序は、`名前$を供する要素の`木~順序$xに従わ~MUST
— ここで
</p>
		<ul>
			<li>
同じ要素の
`id$a, `name^a
両~属性が`名前$を供する場合は `id$a が先になる。
</li>
			<li>
`名前$の重複に際しては、後から供される`名前$は無視する。
</li>
		</ul>
	</li>
</ul>

◎
The Document interface supports named properties. The supported property names at any moment consist of the values of the name content attributes of all the applet, exposed embed, form, iframe, img, and exposed object elements in the Document that have non-empty name content attributes, and the values of the id content attributes of all the applet and exposed object elements in the Document that have non-empty id content attributes, and the values of the id content attributes of all the img elements in the Document that have both non-empty name content attributes and non-empty id content attributes. The supported property names must be in tree order, ignoring later duplicates, with values from id attributes coming before values from name attributes when the same element contributes both.
</div>



<p>
~UAは、所与の %名前 に対応する`文書$ %文書 の
`~propを検索取得するために~index~access@
されたときに，`有名~propの値を決定する$xときは、次の手続きを走らせ~MUST：
◎
To determine the value of a named property name when the Document object is indexed for property retrieval, the user agent must return the value obtained using the following steps:
</p>

<ol>
	<li>
%要素~list ~LET %文書 内の［
`名前$ ~EQ %名前
］なる`有名~要素$からなる~list
◎
Let elements be the list of named elements with the name name in the Document.
◎
There will be at least one such element, by definition.
</li>
	<li>
<p>
~IF［
%要素~list は唯一の要素 %要素 からなる
］
</p>
		<ol>
			<li>
~IF［
%要素 は `iframe$e 要素である
］
⇒
~RET %要素 が`入子にしている閲覧文脈$の `WindowProxy$I ~obj
◎
If elements has only one element, and that element is an iframe element, then return the WindowProxy object of the nested browsing context represented by that iframe element, and abort these steps.
</li>
			<li>
~RET %要素
◎
Otherwise, if elements has only one element, return that element and abort these steps.
</li>
		</ol>
	</li>
	<li>
~RET 次のようにされた `HTMLCollection$I
⇒
根： `文書$；<br>
~filter： ［
`名前$ ~EQ %名前
］なる`有名~要素$のみに合致する
◎
Otherwise return an HTMLCollection rooted at the Document node, whose filter matches only named elements with the name name.
</li>
</ol>

<div class="p">
<p>
次をすべて満たす要素が、`文書$の
`有名~要素@
とされる：
</p>

<ul>
<li>要素は、文書~内にある
<li>要素は、下の表の 1 列目に挙げるいずれかである
<li>要素は、同じ行の 2 列目に挙げる内容~属性 %A を有している
<li>要素は、同じ行の 3 列目の条件を満たす
<li>%A の値 ~NEQ 空~文字列
</ul>

<p>
%A の値が、`有名~要素$の
`名前@
を供する。
</p>

<table><thead><tr><th>要素
<th>内容~属性
<th>追加の条件
</thead>

<tbody><tr>
<td>`applet$e, `form$e, `iframe$e, `img$e
<td>`name^a
<td>なし

<tr><td>`object$e
<td>`name^a
<td>`公開されている$

<tr><td>`object$e
<td>`id$a
<td>`公開されている$

<tr><td>`embed$e
<td>`name^a
<td>`公開されている$

<tr><td>`applet$e
<td>`id$a
<td>なし

<tr><td>`img$e
<td>`id$a
<td>`name^a 内容~属性を有する, かつ その値 ~NEQ 空~文字列

</tbody></table>

◎
Named elements with the name name, for the purposes of the above algorithm, are those that are either:
◎
applet, exposed embed, form, iframe, img, or exposed object elements that have a name content attribute whose value is name, or
◎
applet or exposed object elements that have an id content attribute whose value is name, or
◎
img elements that have an id content attribute whose value is name, and that have a non-empty name content attribute present also.
</div>


<div class="p">
<p>
［
`embed$e ／ `object$e
］要素は、次のいずれも満たすならば，
`公開されている@
という：
</p>

<ul>
	<li>
どの先祖も，`公開されている$ `object$e ではない
</li>
	<li>
<p>
`embed$e 要素であるか, または
次のいずれかを満たす `object$e 要素である：
</p>
		<ul>
			<li>
`~fallback内容$を示していない
</li>
			<li>
どの子孫も，
`object$e 要素でも `embed$e 要素でもない
</li>
		</ul>
	</li>
</ul>

◎
An embed or object element is said to be exposed if it has no exposed object ancestor, and, for object elements, is additionally either not showing its fallback content or has no object or embed descendants.
</div>

<hr>

<p class="note">注記：
`Document$I ~interfaceの `~document-dir$m 属性は、 `dir$a 内容~属性とともに定義される。
◎
The dir attribute on the Document interface is defined along with the dir content attribute.
</p>

			</section>
			<section id="loading-xml-documents">
<h3 title="Loading XML documents">3.1.4. ~XML文書の読込み</h3>

<pre class="idl">
partial interface `XMLDocument$I {
  [`CEReactions$] boolean `load$m(DOMString url);
};
</pre>

<p>
`load(url)@m
~methodの被呼出時には、次の手続きを走らせ~MUST：
◎
The load(url) method must run the following steps:
</p>

<ol>
	<li>
%~url~record ~LET %url を`~entry設定群~obj$に`相対的に構文解析-$した`結果の~URL~record$
</li>
	<li>
~IF［
%~url~record ~EQ ~error
］
⇒
~THROW `SyntaxError$E
◎
Let document be the XMLDocument object on which the method was invoked.
◎
Parse url, relative to the entry settings object. If this is not successful, throw a SyntaxError exception and abort these steps. Otherwise, let urlRecord be the resulting URL record.
</li>
	<li>
~IF［
%~url~record の`生成元$url ~NEQ 此れの`生成元$
］
⇒
~THROW `SecurityError$E
◎
If urlRecord's origin is not the same as the origin of document, throw a SecurityError exception and abort these steps.
</li>
	<li>
此れのすべての子を除去する
— ただし、変異~eventは発火しない
◎
Remove all child nodes of document, without firing any mutation events.
</li>
	<li>
此れの`現在の準備度$ ~SET `loading^l
◎
Set the current document readiness of document to "loading".
</li>
	<li>
~RET ~T
— ただし、この手続きの残りは`並列的$に走らす
◎
Run the remainder of these steps in parallel, and return true from the method.
</li>
	<li>
%文書 ~LET 新たな`文書$
◎
Let result be a Document object.
</li>
	<li>
%成功 ~LET ~F
◎
Let success be false.
</li>
	<li>
<p>
%要請 ~LET 次のようにされた新たな`要請$x
</p>

<ul><li>`~url$rq ~SET %~url~record
<li>`~client$rq ~SET `~entry設定群~obj$
<li>`行先$rq ~SET `subresource^l
<li>`同期~flag$rq ~SET ~ON
<li>`~mode$rq ~SET `same-origin^l
<li>`資格証~mode$rq ~SET `same-origin^l
<li>`~URL資格証~利用~flag$rq ~SET ~ON
</ul>

◎
Let request be a new request whose url is urlRecord, client is entry settings object, destination is "subresource", synchronous flag is set, mode is "same-origin", credentials mode is "same-origin", and whose use-URL-credentials flag is set.
</li>
	<li>
%応答 ~LET %要請 を`~fetch$xした結果
`同期~flag ~ON なので、応答が受信されるまで，同期的に待機することになる。^tnote
◎
Let response be the result of fetching request.
</li>
	<li>
<p>
~IF［
%応答 の`Content-Type ~metadata$xは`~XML~MIME型$である
］：
◎
If response's Content-Type metadata is an XML MIME type, then run these substeps:
</p>

		<ol>
			<li>
%構文解析器 ~LET 新たな `~XML構文解析器$x
</li>
			<li>
%構文解析器 を %文書 に結付ける
◎
Create a new XML parser associated with the result document.
</li>
			<li>
%応答 の`本体$rsを %構文解析器 に渡す
`その結果で文書を拡充する^tnote
◎
Pass this parser response's body.
</li>
			<li>
~IF［
%構文解析器 から［
~XML~整形式~error ／ ~XML名前空間~整形式~error
］が返された
］
⇒
%文書 からすべての子~nodeを除去する
◎
↓</li>
			<li>
~ELSE
⇒
%成功 ~LET ~T
◎
If there is an XML well-formedness or XML namespace well-formedness error, then remove all child nodes from result. Otherwise let success be true.
</li>

		</ol>
	</li>
	<li>
<p>
次の手続きを走らす`~taskを待入する$：
◎
Queue a task to run the following steps.
</p>

		<ol>
			<li>
此れの`現在の準備度$ ~SET `complete^l
◎
Set the current document readiness of document to "complete".
</li>
			<li>
%文書 の子すべてを此れの子として挿入する
— %文書 の子すべてを包含している `DocumentFragment$I を挿入したかのように —
とともに，変異~eventを発火する
◎
Replace all the children of document by the children of result (even if it has no children), firing mutation events as if a DocumentFragment containing the new children had been inserted.
</li>
			<li>
此れに向けて名前 `load$et の`単純~eventを発火-$する
◎
Fire a simple event named load at document.
</li>
		</ol>
	</li>
	<li class="trans-note">【
~RET %成功
】</li>
</ol>

			</section>
		</section>
		<section id="elements">
<h2 title="Elements">3.2. 要素</h2>

			<section id="semantics-2">
<h3 title="Semantics">3.2.1. 意味論</h3>

<p>
~HTMLにおける［
要素, 属性, 属性~値
］は、（この仕様により）ある種の意味（意味論）を有するものと定義される。
例えば、 `ol$e 要素は 有順序~listを表現し，
`lang$a 属性は 要素~内容の言語を表現する。
◎
Elements, attributes, and attribute values in HTML are defined (by this specification) to have certain meanings (semantics). For example, the ol element represents an ordered list, and the lang attribute represents the language of the content.
</p>

<p>
これらの定義は、［
~Web~browserや検索~engineなどの，~HTML処理器
］が［
文書を呈示したり, 利用すること
］, および［
作者が考慮していないものも含む，多様な文脈における応用
］を許容する。
◎
These definitions allow HTML processors, such as Web browsers or search engines, to present and use documents and applications in a wide variety of contexts that the author might not have considered.
</p>


<div class="example">
<p>
単純な例として、作者が~desktop~computer~Web~browserのみを考慮して書いた~Web頁を考える：
◎
As a simple example, consider a Web page written by an author who only considered desktop computer Web browsers:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;html lang="ja"&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;俺の頁&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;俺の頁に来たか。&lt;/h1&gt;
  &lt;p&gt;俺はでかいの好きやねん！アレとか持ってるで。&lt;/p&gt;
  &lt;h2&gt;俺の住処&lt;/h2&gt;
  &lt;p&gt;ちっこい山小屋…。&lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<!-- 
My Page
Welcome to my page
I like cars and lorries and have a big Jeep!
Where I live
I live in a small hut on a mountain!
-->

<p>
~HTMLは，呈示ではなく <em>意味</em> を伝達するので、同じ頁は，何ら変更することなく携帯端末~上の小さい~browserからも利用され得る。
携帯端末~上の~browserは，例えば、~desktop上のときのような字の大きい見出しの代わりに，頁~全体に同じ~sizeの~textを利用した上で，見出しを太字にすることもあり得る。
◎
Because HTML conveys meaning, rather than presentation, the same page can also be used by a small browser on a mobile phone, without any change to the page. Instead of headings being in large letters as on the desktop, for example, the browser on the mobile phone might use the same size text for the whole the page, but with the headings in bold.
</p>

<p>
単なる~screen~sizeの相違のみならず、同じ頁は，発話~合成に基づく~browserを利用している~blind利用者からも等しく利用され得る
— そこでは、例えば~headphoneを利用している利用者に向けて，頁を~screen上に表示する代わりに頁を読上げる。
そのような発話~browserは、~textを大きくする代わりに 異なる音量やより低速な声を見出しに利用するであろう。
◎
But it goes further than just differences in screen size: the same page could equally be used by a blind user using a browser based around speech synthesis, which instead of displaying the page on a screen, reads the page to the user, e.g. using headphones. Instead of large text for the headings, the speech browser might use a different volume or a slower voice.
</p>

<p>
他にもある。
~browserは，頁のどの部分が見出しであるか知るので、［
利用者が 
“次の／前の見出しまで飛ぶ”
ためのキーを利用して，文書を素早く~~巡回する
］ときに利用できるような，文書の~outlineを作成できる。
そのような特色機能は、とりわけ発話~browserに共通してある
— さもなければ，利用者は、頁を素早く~navigateする~~方法を見出すことが著しく困難になるような。
◎
That's not all, either. Since the browsers know which parts of the page are the headings, they can create a document outline that the user can use to quickly navigate around the document, using keys for "jump to next heading" or "jump to previous heading". Such features are especially common with speech browsers, where users would otherwise find quickly navigating a page quite difficult.
</p>

<p>
~browserの他にも，~softwareはこの情報を用立てられる。
検索~engineは、より効果的に，見出しを［
頁を~indexしたり、その結果から，頁の下位節へ直に飛べる~linkを提供する
］ために利用できる。
各種~toolは、目次を作成するときに見出しを利用できる（事実，この仕様~自身もそうやって目次を生成している）。
◎
Even beyond browsers, software can make use of this information. Search engines can use the headings to more effectively index a page, or to provide quick links to subsections of the page from their results. Tools can use the headings to create a table of contents (that is in fact how this very specification's table of contents is generated).
</p>

<p>
この例では，見出しに焦点をあてていたが、同じ原則は，~HTMLにおけるすべての意味論に適用される。
◎
This example has focused on headings, but the same principle applies to all of the semantics in HTML.
</p>

</div>

<p>
作者は、［
要素／属性／属性~値
］を，それらに意図された意味論上の目的0に適切な目的0以外に利用しては~MUST_NOT
— そうすると，~softwareは頁を正しく処理できなくなるので。
◎
Authors must not use elements, attributes, or attribute values for purposes other than their appropriate intended semantic purpose, as doing so prevents software from correctly processing the page.
</p>


<div class="example">

<p>
例えば，次の~code片は，ある企業~siteの見出しを表現するために意図されているが、その二行目は，下位節の見出しに意図されたものではなく、単に同じ節の副~見出しに過ぎないので、適合でない。
◎
For example, the following snippet, intended to represent the heading of a corporate site, is non-conforming because the second line is not intended to be a heading of a subsection, but merely a subheading or subtitle (a subordinate heading for the same section).
</p>

<pre class="bad">
&lt;body&gt;
 &lt;h1&gt;ACME （株）&lt;/h1&gt;
 &lt;h2&gt;創業 1920 年、業界一の迅速配達&lt;/h2&gt;
 ...
</pre>
<!-- 
ACME Corporation
The leaders in arbitrary fast delivery since 1920

 -->
<p>
この種の状況に意図されている要素は `hgroup$e である：
◎
The hgroup element is intended for these kinds of situations:
</p>

<pre>
&lt;body&gt;
 &lt;hgroup&gt;
  &lt;h1&gt;ACME （株）&lt;/h1&gt;
  &lt;h2&gt;創業 1920 年、業界一の迅速配達&lt;/h2&gt;
 &lt;/hgroup&gt;
 ...
</pre>

</div>

<div class="example">

<p>
同様に、次の例における文書は，構文上は正しくても適合でない
— 各~cell内に配されている~dataは，明らかに~table用の~dataではなく， `cite$e 要素は誤用されているので：
◎
The document in this next example is similarly non-conforming, despite being syntactically correct, because the data placed in the cells is clearly not tabular data, and the cite element mis-used:
</p>

<pre class="bad">
&lt;!DOCTYPE HTML&gt;
&lt;html lang="ja"&gt;
 &lt;head&gt; &lt;title&gt; 実例 &lt;/title&gt; &lt;/head&gt;
 &lt;body&gt;
  &lt;table&gt;
   &lt;tr&gt; &lt;td&gt; 私は猫好きである。 &lt;/td&gt; &lt;/tr&gt;
   &lt;tr&gt;
    &lt;td&gt;
     —&lt;a href="http://example.org/~ernest/"&gt;&lt;cite&gt;アーネスト&lt;/cite&gt;&lt;/a&gt;,
     1992 年の随筆から
    &lt;/td&gt;
   &lt;/tr&gt;
  &lt;/table&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<!-- 
Demonstration
My favourite animal is the cat.
—Ernest
in an essay from 1992
-->

<p>
これは、これらの意味論に依拠する~softwareを失敗させるであろう：
例えば文書~内の~tableを~blind利用者が~navigateできるようにする発話~browserは、上の~~文章を~tableとして報告することになり，利用者を惑わすことなる。
同様に，頁から各 作品の~titleを抽出する~toolは、 "アーネスト" を，実際には人名であって ~titleではないのに，作品の~titleとして抽出することになる。
◎
This would make software that relies on these semantics fail: for example, a speech browser that allowed a blind user to navigate tables in the document would report the quote above as a table, confusing the user; similarly, a tool that extracted titles of works from pages would extract "Ernest" as the title of a work, even though it's actually a person's name, not a title.
</p>

<p>
上の文書を正した~versionは、次のようになるであろう：
◎
A corrected version of this document might be:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;html lang="ja"&gt;
 &lt;head&gt; &lt;title&gt; 実例 &lt;/title&gt; &lt;/head&gt;
 &lt;body&gt;
  &lt;blockquote&gt;
   &lt;p&gt; 私は猫好きである。 &lt;/p&gt;
  &lt;/blockquote&gt;
  &lt;p&gt;
   —&lt;a href="http://example.org/~ernest/"&gt;アーネスト&lt;/a&gt;,
   1992 年の随筆から
  &lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

</div>

<p>
作者は、この仕様も含む`適用し得る仕様$により許可されていない［
要素, 属性, 属性~値
］を利用しては~MUST_NOT。
そうすると、~HTMLの将来の拡張が有意に難くなるので。
◎
Authors must not use elements, attributes, or attribute values that are not permitted by this specification or other applicable specifications, as doing so makes it significantly harder for the language to be extended in the future.
</p>

<div class="example">

<p>
次の例には、この仕様により許可されていない，適合しない［
属性~値（ `carpet^l ）, 属性（ `texture^a ）
］がある：
◎
In the next example, there is a non-conforming attribute value ("carpet") and a non-conforming attribute ("texture"), which is not permitted by this specification:
</p>

<pre class="bad">
&lt;label&gt;カーペット： &lt;input type="carpet" name="c" texture="deep pile"&gt;&lt;/label&gt;
</pre>
<!-- Carpet: -->
<p>
これを~mark-upする別の正しい仕方は：
◎
Here would be an alternative and correct way to mark this up:
</p>

<pre>
&lt;label&gt;カーペット： &lt;input type="text" class="carpet" name="c" data-texture="deep pile"&gt;&lt;/label&gt;
</pre>

</div>

<p>
［
属性の値, ~text, 更には文書の構造~全体
］は、~UAがそれを処理している間に，~scriptingを通して／他の仕組みを利用して 動的に変更され得る。
ある時点における文書の意味論は，その時点の文書の状態により表現され、したがって文書の意味論は 時経過に伴って変化し得る。
~UAは、文書の呈示を，変化が生じる度に更新し~MUST。
◎
Through scripting and using other mechanisms, the values of attributes, text, and indeed the entire structure of the document may change dynamically while a user agent is processing it. The semantics of a document at an instant in time are those represented by the state of the document at that instant in time, and the semantics of a document can therefore change over time. User agents must update their presentation of the document as this occurs.
</p>

<p class="example">
~HTMLには、進捗~barを記述する `progress$e 要素がある。
その `value^a 属性が~scriptにより動的に更新された場合、~UAは，進捗の変化を示すように描画を更新することになる。
◎
HTML has a progress element that describes a progress bar. If its "value" attribute is dynamically updated by a script, the UA would update the rendering to show the progress changing.
</p>

			</section>
			<section id="elements-in-the-dom">
<h3 title="Elements in the DOM">3.2.2. ~DOM内の要素</h3>

<p>
~DOM内の`~HTML要素$を表現している~nodeは、この仕様の関連する節にて挙げられる~interfaceを実装して~scriptに公開し~MUST。
これには、`~XML文書$x内の`~HTML要素$も含まれる
— それらの文書が別の文脈~内にあるときでも（例： XSLT 変形の内側）。
◎
The nodes representing HTML elements in the DOM must implement, and expose to scripts, the interfaces listed for them in the relevant sections of this specification. This includes HTML elements in XML documents, even when those documents are in another context (e.g. inside an XSLT transform).
</p>

<p>
~DOM内の要素は、それが内在的に有する<em>意味</em>
— 意味論とも呼ばれる —
を
`表現-@
する。
◎
Elements in the DOM represent things; that is, they have intrinsic meaning, also known as semantics.
</p>

<p class="example">
例えば `ol$e 要素は、有順序~listを表現する。
◎
For example, an ol element represents an ordered list.
</p>

<p>
`HTMLElement$I ~interfaceは、すべての`~HTML要素$~interfaceが継承する基本的~interfaceであり，追加の要件を持たない要素に利用され~MUST。
◎
The basic interface, from which all the HTML elements' interfaces inherit, and which must be used by elements that have no additional requirements, is the HTMLElement interface.
</p>

<pre class="idl">
[Constructor]
interface `HTMLElement@I : `Element$I {
  // <span class="comment">
~metadata属性
◎
// metadata attributes
</span>
  attribute DOMString `title$m;
  attribute DOMString `lang$m;
  attribute boolean `translate$m;
  attribute DOMString `dir$m;
  [SameObject] readonly attribute `DOMStringMap$I `dataset$m;

  // <span class="comment">
<a href="~HTML5/interaction.html#editing">利用者~対話</a>
◎
// user interaction
</span>
  attribute boolean `hidden$m;
  void `click$m();
  attribute long `tabIndex$m;
  void `focus$m();
  void `blur$m();
  attribute DOMString `accessKey$m;
  readonly attribute DOMString `accessKeyLabel$m;
  attribute boolean `draggable$m;
  [SameObject, PutForwards=`value$m] readonly attribute `DOMTokenList$I `dropzone$m;
  attribute `HTMLMenuElement$I? `contextMenu$m;
  attribute boolean `spellcheck$m;
  void `forceSpellCheck$m();
};
`HTMLElement$I implements `GlobalEventHandlers$I;
`HTMLElement$I implements `DocumentAndElementEventHandlers$I;
`HTMLElement$I implements `ElementContentEditable$I;

interface `HTMLUnknownElement@I : `HTMLElement$I { };
</pre>

<p>
`HTMLElement$I ~interfaceは，いくつもの異種の特色機能に関係する
~methodや属性
を保持するので、この~interfaceの~memberは，この仕様の種々の異なる節にて述べられる。
その構築子の被呼出時には、次の手続きを遂行し~MUST：
◎
The HTMLElement interface holds methods and attributes related to a number of disparate features, and the members of this interface are therefore described in various different sections of this specification. Its constructor, when invoked, must perform the following steps:
</p>


<ol>
	<li>
%realm ~LET
`GetFunctionRealm$jA( 現在~実行している `HTMLElement()^m 関数 ) の結果
◎
Let realm be the result of GetFunctionRealm(the currently executing HTMLElement function).
</li>
	<li>
%registry ~LET %realm の`大域~obj$の `CustomElementsRegistry$I ~obj
◎
Let registry be realm's global object's CustomElementsRegistry object.
</li>
	<li>
%定義 ~LET %registry 内の［
`構築子$ ~EQ  NewTarget `？^tnote
］なる~entry
◎
↓</li>
	<li>
~IF［
そのような %定義 はない
］
⇒
~THROW `TypeError$E
◎
Let definition be the entry in registry with constructor equal to NewTarget. If there is no such definition, then throw a TypeError and abort these steps.
</li>
	<li>
%prototype ~LET %定義 の `~prototype$
◎
Let prototype be definition's prototype.
</li>
	<li>
<p>
~IF［
%定義 の`構築~stack$は空である
］：
◎
If definition's construction stack is empty, then:
</p>

		<ol>
			<li>
%局所~名 ~LET %定義 の`局所~名$
◎
Let localName be the definition's local name.
</li>
			<li>
<p>
%要素 ~LET 次のようにされた新たな要素：
</p>

<ul><li>`HTMLElement$I ~interfaceを実装する
</li><li>属性は持たない
</li><li>名前空間 ~SET `~HTML名前空間$
</li><li>局所~名 ~SET %局所~名
</li><li>`~node文書$x ~SET %document `？^tnote
</li></ul>

◎
Let element be a new element that implements the HTMLElement interface, with no attributes, namespace set to the HTML namespace, local name set to localName, and node document set to document.
</li>
			<li>
%要素 . [[SetPrototypeOf]]( %prototype ) を遂行する
（例外投出あり）
◎
Perform element.[[SetPrototypeOf]](prototype). Rethrow any exceptions.
</li>
			<li>
~RET %要素
◎
Return element.
</li>
		</ol>

<p class="note">注記：
これは、作者~scriptが，新たな~custom要素を
— 例えば `new MyCustomElement()^c を介して —
直接的に構築したときに生じる。
◎
This occurs when author script constructs a new custom element directly, e.g. via new MyCustomElement().
</p>
	</li>
	<li>
%~instance ~LET %定義 の`構築~stack$内の最後の~entry
◎
Let instance be the last entry in definition's construction stack.
</li>
	<li>
<p>
~IF［
%~instance は`すでに構築済みの~marker$である
］
⇒
~THROW `InvalidStateError$E
◎
If instance is an already constructed marker, then throw an InvalidStateError and abort these steps.
</p>

<p class="note">注記：
これは、`~custom要素~構築子$の内側の作者~codeが
`super()^c を複数回 呼出したときに生じ得る。
◎
This can occur when the author code inside the custom element constructor invokes super() multiple times.
</p>
   </li>
	<li>
%要素 . [[SetPrototypeOf]]( %prototype ) を遂行する
（例外投出あり）
◎
Perform element.[[SetPrototypeOf]](prototype). Rethrow any exceptions.
</li>
	<li>
%定義 の`構築~stack$内の最後の~entryを，`すでに構築済みの~marker$で置換する
◎
Replace the last entry in definition's construction stack with an already constructed marker.
</li>
	<li>
<p>
~RET %~instance
◎
Return instance.
</p>

<p class="note">注記：
この段に到達するのは、通常は，~custom要素を`昇格$するときである。
`~custom要素~構築子$の内側からの `super()^c ~callにて，
<b>this</b> に既存の要素をあてがうようにするため、その既存の要素を返す。
◎
This step is normally reached when upgrading a custom element; the existing element is returned, so that the super() call inside the custom element constructor assigns that existing element to this.
</p>

	</li>
</ol>

<p class="note">注記：
`HTMLElement$I 構築子は、直接的には呼出せない。
それは、`~custom要素~構築子$の内側の `super()^c ~callを介して利用されるときにのみ働く。
◎
The HTMLElement constructor cannot be invoked directly. It only works when used via a super() call inside a custom element constructor.
</p>

<hr>

<p>
( `~HTML名前空間$, %名前 )
対応する`要素~interface$xは、次に従って決定される：
◎
The element interface for an element with name name in the HTML namespace is determined as follows:
</p>

<ol>
	<li>
~IF［
%名前 ~IN {
`bgsound$e, `blink$e, `isindex$e, `multicol$e, `nextid$e, `spacer$e
}
］
⇒
~RET `HTMLUnknownElement$I
◎
If name is bgsound, blink, isindex, multicol, nextid, or spacer, then return HTMLUnknownElement.
</li>

	<li>
~IF［
%名前 ~IN {
`acronym$e, `basefont$e, `big$e, `center$e, `nobr$e, `noembed$e, `noframes$e, `plaintext$e, `rb$e, `rtc$e, `strike$e, `tt$e
}
］
⇒
~RET `HTMLElement$I
◎
If name is acronym, basefont, big, center, nobr, noembed, noframes, plaintext, rb, rtc, strike, or tt, then return HTMLElement.
</li>
	<li>
~IF［
%名前 ~IN { `listing$e, `xmp$e }
］
⇒
~RET `HTMLPreElement$I
◎
If name is listing or xmp, then return HTMLPreElement.
</li>
	<li>
~IF［
局所~名 %名前 に対応する`要素~型$に対する適切な~interfaceが，この仕様に定義されている
］
⇒
~RET その~interface
◎
Otherwise, if this specification defines an interface appropriate for the element type corresponding to the local name name, then return that interface.
</li>
	<li>
~IF［
%名前 に対する適切な~interfaceが，`適用し得る仕様$に定義されている
］
⇒
~RET それが定義している~interface
◎
If other applicable specifications define an appropriate interface for name, then return the interface they define.
</li>
	<li>
~IF［
%名前 は`妥当な~custom要素~名$である
］
⇒
~RET `HTMLElement$I
◎
If name is a valid custom element name, then return HTMLElement.
</li>
	<li>
~RET `HTMLUnknownElement$I
◎
Return HTMLUnknownElement.
</li>

</ol>

<p class="note">注記：
`妥当な~custom要素~名$の場合に，
`HTMLUnknownElement$I ではなく `HTMLElement$I を利用するのは、将来あり得る`昇格$に際し，要素の~prototype~chainは `HTMLElement$I から その~subclassへ真っ直ぐ翻訳するだけで済むようにするためにある
— `HTMLUnknownElement$I から関係ない~subclassへそらすような翻訳を要することなく。
◎
The use of HTMLElement instead of HTMLUnknownElement in the case of valid custom element names is done to ensure that any potential future upgrades only cause a linear transition of the element's prototype chain, from HTMLElement to a subclass, instead of a lateral one, from HTMLUnknownElement to an unrelated subclass.
</p>


			</section>
			<section id="element-definitions">
<h3 title="Element definitions">3.2.3. 要素~定義</h3>

<p>
この仕様~内の各種~要素は、次の情報を含む定義が与えられる：
◎
Each element in this specification has a definition that includes the following information:
</p>

<dl>
	<dt id="concept-element-categories">分類（ Categories ）</dt>
	<dd>
要素が属するとされる`分類$の~list。
これらの`分類$は、要素の`内容~model$を定義するときに利用される。
◎
A list of categories to which the element belongs. These are used when defining the content models for each element.
</dd>

	<dt id="concept-element-contexts">この要素を利用できる文脈（ Contexts in which this element can be used ）</dt>
	<dd>
要素をどこで利用できるかについての，<em>規範的でない</em>記述。
この情報は、冗長であり，もっぱら便宜のため提供される
— 自身または他の要素の，内容~model（次項）にて提供される情報と~~重複するので。
◎
A non-normative description of where the element can be used. This information is redundant with the content models of elements that allow this one as a child, and is provided only as a convenience.
</dd>
	<dd class="note">注記：
簡略化するため、ここには期待される分類のうち，最も特定的なもののみが挙げられる。
例えば、`~flow内容$であって, `句内容$でもある要素は、［
`~flow内容$ ／ `句内容$
］が期待されるどこでも利用できるが、すべての`句内容$は`~flow内容$なので、
“`句内容$が期待される所”
のみが挙げられることになる。
◎
For simplicity, only the most specific expectations are listed. For example, an element that is both flow content and phrasing content can be used anywhere that either flow content or phrasing content is expected, but since anywhere that flow content is expected, phrasing content is also expected (since all phrasing content is flow content), only "where phrasing content is expected" will be listed.
</dd>

	<dt id="concept-element-content-model">内容~model（ Content model ）</dt>
	<dd>
要素の子孫として含められ~MUST内容についての，規範的な記述。
◎
A normative description of what content must be included as children and descendants of the element.
</dd>

	<dt id="concept-element-tag-omission">`text/html^c における~tag省略（ Tag omission in text/html ）</dt>
	<dd>
`text/html$c 構文において，［
`開始tag$x／`終了tag$x
］を省略できるかどうかについての，<em>規範的でない</em>記述。
この情報は冗長であり，もっぱら便宜のために提供される
— 規範的~要件は、
<a href="~HTML5/syntax.html#syntax-tag-omission">省略可能~tag節</a>
にて与えられる。
◎
A non-normative description of whether, in the text/html syntax, the start and end tags can be omitted. This information is redundant with the normative requirements given in the optional tags section, and is provided in the element definitions only as a convenience.
</dd>

	<dt id="concept-element-attributes">内容~属性（ Content attributes ）</dt>
	<dd>
要素に指定されてよい属性を挙げる，規範的な~list（他から不許可にされるものは除く）。
加えて、それらの属性についての規範的でない記述（ ~dashの左側の内容は規範的であり，右側の内容はそうでない）。
◎
A normative list of attributes that may be specified on the element (except where otherwise disallowed), along with non-normative descriptions of those attributes. (The content to the left of the dash is normative, the content to the right of the dash is not.)
</dd>

	<dt id="concept-element-dom">~DOM~interface（ DOM interface ）</dt>
	<dd>
当の要素が実装し~MUST ~DOM~interfaceについての，規範的~定義。
◎
A normative definition of a DOM interface that such elements must implement.
</dd>

</dl>

<p>
上述の定義には、要素が何を`表現-$するかについての記述, および
作者／実装
に適用され得る，追加の規範的な適合性~判定基準も後続する。
例が含められることもある。
◎
This is then followed by a description of what the element represents, along with any additional normative conformance criteria that may apply to authors and implementations. Examples are sometimes also included.
</p>

				<section id="attributes">
<h4 title="Attributes">3.2.3.1. 属性</h4>

<p id="attribute-text">
属性~値は文字列である。
他から指定されない限り、`~HTML要素$上の属性~値は，空~文字列も含め，どのような文字列~値もとり得る
— そのような属性に指定し得る~textに制約はない。
◎
An attribute value is a string. Except where otherwise specified, attribute values on HTML elements may be any string value, including the empty string, and there is no restriction on what text can be specified in such attribute values.
</p>


				</section>
			</section>
			<section id="content-models">
<h3 title="Content models">3.2.4. 内容~model</h3>

<p>
この仕様にて定義される各~要素は、要素に期待される`内容$を記述する，内容~modelを有する。
`~HTML要素$の内容は、要素の内容~modelに述べられる要件に合致し~MUST。
要素の
`内容@
とは、~DOMにおける要素の子たちである。
ただし、 `template$e 要素は除く
— その子たちは，`~template内容$（要素の作成-時に要素にあてがわれる，別々の `DocumentFragment$I ）のそれらになる。
◎
Each element defined in this specification has a content model: a description of the element's expected contents. An HTML element must have contents that match the requirements described in the element's content model. The contents of an element are its children in the DOM, except for template elements, where the children are those in the template contents (a separate DocumentFragment assigned to the element when the element is created).
</p>

<p>
要素たちの合間には，`空白類$が常に許容される。
~UAは、~source~markup内の要素の合間にある空白類を，~DOM内では `Text$I ~nodeとして表現する。
0 個以上の`空白類$のみからなる `Text$I ~nodeは、
`要素間~空白@
と見なされる。
◎
The space characters are always allowed between elements. User agents represent these characters between elements in the source markup as Text nodes in the DOM. Empty Text nodes and Text nodes consisting of just sequences of those characters are considered inter-element whitespace.
</p>

<div class="p">
<p>
［
`要素間~空白$ ／
~comment~node ／
処理命令~node
］は、次の文脈においては，無視され~MUST：
</p>
<ul>
	<li>
要素の内容が要素の内容~modelに合致するかどうか確かめるとき。
</li>
	<li>
文書や要素の意味論を定義する~algoに従うとき。
</li>
</ul>

◎
Inter-element whitespace, comment nodes, and processing instruction nodes must be ignored when establishing whether an element's contents match the element's content model or not, and must be ignored when following algorithms that define document and element semantics.
</div>

<p class="note">注記：
したがって要素 %A, %B に対し、［
%A, %B の親~nodeが同じである
］~AND［
それらの合間に［
他の要素~nodeや, （`要素間~空白$以外の） `Text$I ~node
］が無いならば、
`上述の文脈においては，^tnote
%A と %B は <i>~~隣接する</i> とされる。
同様に，要素の子~nodeは、その要素が［
`要素間~空白$, ~comment~node, 処理命令~node
］以外の~nodeを他に包含しないならば，要素の唯一の子になる。
◎
Thus, an element A is said to be preceded or followed by a second element B if A and B have the same parent node and there are no other element nodes or Text nodes (other than inter-element whitespace) between them. Similarly, a node is the only child of an element if that element contains no other nodes other than inter-element whitespace, comment nodes, and processing instruction nodes.
</p>

<p>
作者は、［
各~要素に定義される ／
他の仕様から明示的に要求される
］ような，明示的に許容される所を除いて、`~HTML要素$を利用しては~MUST_NOT。
~XMLが複合されている文書に対しては、他の名前空間に属する要素の内側であっても，
その種の要素が，関連する文脈を提供するものとして定義されているならば、この文脈になり得る。
◎
Authors must not use HTML elements anywhere except where they are explicitly allowed, as defined for each element, or as explicitly required by other specifications. For XML compound documents, these contexts could be inside elements from other namespaces, if those elements are defined as providing the relevant contexts.
</p>

<p class="example">
例えば， Atom 仕様 `ATOM$r では、
`content^e 要素が定義されていて，その `type^a 属性の値が `xhtml^l のときには単独の~HTML `div$e 要素を包含することが要求される。
したがって， `div$e 要素は、この仕様により明示的に規範的であるものと定められていなくとも，その文脈においては許容される。
◎
For example, the Atom specification defines a content element. When its type attribute has the value xhtml, the Atom specification requires that it contain a single HTML div element. Thus, a div element is allowed in that context, even though this is not explicitly normatively stated by this specification. [ATOM]
</p>

<p>
加えて，`~HTML要素$は、孤立している
— すなわち，親~nodeがない —
場合もある。
◎
In addition, HTML elements may be orphan nodes (i.e. without a parent node).
</p>


<div class="example">

<p>
例えば、［
`td$e 要素を利用できる場所は `tr$e 要素の内側のみ
］と想定されているが、［
~scriptで `td$e 要素を作成して，大域的~変数に格納する
］ことは，適合である。
◎
For example, creating a td element and storing it in a global variable in a script is conforming, even though td elements are otherwise only supposed to be used inside tr elements.
</p>

<pre>
var data = {
  name: "バナナ",
  cell: document.createElement('td'),
};
</pre>
<!-- Banana -->

</div>


				<section id="the-nothing-content-model">
<h4 title="The &quot;nothing&quot; content model">3.2.4.1. “なし” 内容~model</h4>

<p>
内容~modelが
`なし@
（ nothing ）とされている要素は、［［
`要素間~空白$以外の `Text$I ~node
］ ／ 要素~node
］を包含しては~MUST_NOT。
◎
When an element's content model is nothing, the element must contain no Text nodes (other than inter-element whitespace) and no element nodes.
</p>

<p class="note">注記：
内容~modelが “なし” とされている殆どの~HTML要素は、簡便に記せるように，`~void要素$x（`~HTML構文$xにおいて `終了tag$xがない要素）にされているが、これらは，全く別々の概念である。
◎
Most HTML elements whose content model is "nothing" are also, for convenience, void elements (elements that have no end tag in the HTML syntax). However, these are entirely separate concepts.
</p>

				</section>
				<section id="kinds-of-content">
<h4 title="Kinds of content">3.2.4.2. 内容の種類</h4>

<p>
~HTMLにおける各種~要素は、互いに特徴が類似するいくつかの~groupに
`分類-@
される。
各~要素は，これらのうち~zero個以上のものに該当する。
この仕様では，次の大分類が利用される：
◎
Each element in HTML falls into zero or more categories that group elements with similar characteristics together. The following broad categories are used in this specification:
</p>


<ul><li>`~metadata内容$（ Metadata content ）
<li>`~flow内容$（ Flow content ）
<li>`章節ing内容$（ Sectioning content ）
<li>`見出し内容$（ Heading content ）
<li>`句内容$（ Phrasing content ）
<li>`埋込みの内容$（ Embedded content ）
<li>`対話的~内容$（ Interactive content ）
</ul>

<p class="note">注記：
要素には、他の分類にも該当するものがある。
それらは，この仕様の他所にて定義される。
◎
Some elements also fall into other categories, which are defined in other parts of this specification.
</p>

<p>
これらの分類は、次のように関係する：
◎
These categories are related as follows:
</p>

<div style="min-height: 600px;">
<object data="HTML-dom/content-venn.svg" height="600" width="500"><img src="HTML-dom/content-venn.png" alt="" height="600" width="500"></object>
</div>


<p>
［
章節ing内容,
見出し内容,
句内容,
埋込みの内容,
対話的~内容
］は、いずれも~flow内容の一種である。
~metadataには，~flow内容になるものもある。
［
~metadata／対話的~内容
］には，句内容になるものもある。
埋込みの内容は、句内容の一種であり，対話的~内容になるものもある。
◎
Sectioning content, heading content, phrasing content, embedded content, and interactive content are all types of flow content. Metadata is sometimes flow content. Metadata and interactive content are sometimes phrasing content. Embedded content is also a type of phrasing content, and sometimes is interactive content.
</p>

<p>
他の分類も特定の目的0に利用される。
例えば~form~controlは、共通する要件を定義するために，いくつかの分類を利用して指定される。
一部の要素には，一意な要件があり、どの特定0の分類にもあてはまらない。
◎
Other categories are also used for specific purposes, e.g. form controls are specified using a number of categories to define common requirements. Some elements have unique requirements and do not fit into any particular category.
</p>

					<section id="metadata-content">
<h5 title="Metadata content">3.2.4.2.1. ~metadata内容</h5>

<p>
`~metadata内容@
は、［
内容の他の部分の呈示や挙動を設定しておく ／
当の文書と他の文書との関係性を設定しておく ／
その他の “帯域外の” 情報を伝達する
］ような内容である：
◎
Metadata content is content that sets up the presentation or behaviour of the rest of the content, or that sets up the relationship of the document with other documents, or that conveys other "out of band" information.
</p>

<ul class="brief category-list">
<li>`base$e
<li>`link$e
<li>`meta$e
<li>`noscript$e
<li>`script$e
<li>`style$e
<li>`template$e
<li>`title$e
</ul>

<p>
他の名前空間に属する要素であって，その意味論が第一に~metadataに関係するもの（例： RDF ）も、`~metadata内容$である。
◎
Elements from other namespaces whose semantics are primarily metadata-related (e.g. RDF) are also metadata content.
</p>


<div class="example">

<p>
したがって，~XML直列化においては、 RDF を次の様に利用できる：
◎
Thus, in the XML serialisation, one can use RDF, like this:
</p>

<pre>
&lt;html
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:r="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
      xml:lang="en"
&gt;
 &lt;head&gt;
  &lt;title&gt;Hedral's Home Page&lt;/title&gt;
  &lt;r:RDF&gt;
   &lt;Person xmlns="http://www.w3.org/2000/10/swap/pim/contact#"
           r:about="http://hedral.example.com/#"&gt;
    &lt;fullName&gt;Cat Hedral&lt;/fullName&gt;
    &lt;mailbox r:resource="mailto:hedral@damowmow.com"/&gt;
    &lt;personalTitle&gt;Sir&lt;/personalTitle&gt;
   &lt;/Person&gt;
  &lt;/r:RDF&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;My home page&lt;/h1&gt;
  &lt;p&gt;I like playing with string, I guess. Sister says squirrels are fun
  too so sometimes I follow her to play with them.&lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
しかしながら，これは、~HTML直列化においては可能0でない。
◎
This isn't possible in the HTML serialisation, however.
</p>

</div>

					</section>
					<section id="flow-content">
<h5 title="Flow content">3.2.4.2.2. ~flow内容</h5>

<p>
文書の~bodyや~appにて利用される殆どの要素は、
`~flow内容@
に分類される：
◎
Most elements that are used in the body of documents and applications are categorised as flow content.
</p>


<ul class="brief category-list">
<li>`a$e
<li>`abbr$e
<li>`address$e
<li>`area$e （ `map$e 要素の子孫であれば）
◎
area (if it is a descendant of a map element)
<li>`article$e
<li>`aside$e
<li>`audio$e
<li>`b$e
<li>`bdi$e
<li>`bdo$e
<li>`blockquote$e
<li>`br$e
<li>`button$e
<li>`canvas$e
<li>`cite$e
<li>`code$e
<li>`data$e
<li>`datalist$e
<li>`del$e
<li>`details$e
<li>`dfn$e
<li>`dialog$e
<li>`div$e
<li>`dl$e
<li>`em$e
<li>`embed$e
<li>`fieldset$e
<li>`figure$e
<li>`footer$e
<li>`form$e
<li>`h1$e
<li>`h2$e
<li>`h3$e
<li>`h4$e
<li>`h5$e
<li>`h6$e
<li>`header$e
<li>`hgroup$e
<li>`hr$e
<li>`i$e
<li>`iframe$e
<li>`img$e
<li>`input$e
<li>`ins$e
<li>`kbd$e
<li>`keygen$e
<li>`label$e
<li>`link$e （ `~body0内に許容される$xものに限る）
◎
link (if it is allowed in the body)
<li>`main$e
<li>`map$e
<li>`mark$e
<li>`~MathML-math$
<li>`menu$e
<li>`meta$e （ `itemprop$a 属性を有するものに限る）
◎
meta (if the itemprop attribute is present)
<li>`meter$e
<li>`nav$e
<li>`noscript$e
<li>`object$e
<li>`ol$e
<li>`output$e
<li>`p$e
<li>`picture$e
<li>`pre$e
<li>`progress$e
<li>`q$e
<li>`ruby$e
<li>`s$e
<li>`samp$e
<li>`script$e
<li>`section$e
<li>`select$e
<li>`slot$e
<li>`small$e
<li>`span$e
<li>`strong$e
<li>`style$e （ `scoped$a 属性を有するものに限る）
◎
style (if the scoped attribute is present)
<li>`sub$e
<li>`sup$e
<li>`~SVG-svg$
<li>`table$e
<li>`template$e
<li>`textarea$e
<li>`time$e
<li>`u$e
<li>`ul$e
<li>`var$e
<li>`video$e
<li>`wbr$e
<li>`~text$
<li>`自律的~custom要素$
</ul>

					</section>
					<section id="sectioning-content">
<h5 title="Sectioning content">3.2.4.2.3. 章節ing内容</h5>

<p>
`章節ing内容@
は［
`見出し$／ `footer$e
］の視野を定義する内容である：
◎
Sectioning content is content that defines the scope of headings and footers.
</p>

<ul class="brief category-list">
<li>`article$e
<li>`aside$e
<li>`nav$e
<li>`section$e
</ul>

<p>
各`章節ing内容$要素は、見出しや`~outline$xを持ち得る。
更なる詳細は、
<a href="~HTML5/semantics.html#headings-and-sections">見出しと章節</a>
の節を見よ。
◎
Each sectioning content element potentially has a heading and an outline. See the section on headings and sections for further details.
</p>

<p class="note">注記：
要素には、`章節ing根$xになるものもある。
これらは`章節ing内容$とは別個のものだが、`~outline$xを持ち得る。
◎
There are also certain elements that are sectioning roots. These are distinct from sectioning content, but they can also have an outline.
</p>

					</section>
					<section id="heading-content">
<h5 title="Heading content">3.2.4.2.4. 見出し内容</h5>

<p>
`見出し内容@
は、章節の~headerを定義する（章節は、`章節ing内容$要素を利用して明示的に, または 見出し内容~自身により暗黙的に，~mark-upされる）：
◎
Heading content defines the header of a section (whether explicitly marked up using sectioning content elements, or implied by the heading content itself).
</p>


<ul class="brief category-list">
<li>`h1$e
<li>`h2$e
<li>`h3$e
<li>`h4$e
<li>`h5$e
<li>`h6$e
<li>`hgroup$e
</ul>

					</section>
					<section id="phrasing-content">
<h5 title="Phrasing content">3.2.4.2.5. 句内容</h5>

`25493$bug

<p>
`句内容@
は、文書の~text, および
その~textを段落~内の~levelで~mark-upする要素である。
`句内容$の連なりは、`段落$を形成する：
◎
Phrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of phrasing content form paragraphs.
</p>

<ul class="brief category-list">
<li>`a$e
<li>`abbr$e
<li>`area$e （ `map$e 要素の子孫であるものに限る）
◎
area (if it is a descendant of a map element)
<li>`audio$e
<li>`b$e
<li>`bdi$e
<li>`bdo$e
<li>`br$e
<li>`button$e
<li>`canvas$e
<li>`cite$e
<li>`code$e
<li>`data$e
<li>`datalist$e
<li>`del$e
<li>`dfn$e
<li>`em$e
<li>`embed$e
<li>`i$e
<li>`iframe$e
<li>`img$e
<li>`input$e
<li>`ins$e
<li>`kbd$e
<li>`keygen$e
<li>`label$e
<li>`link$e （ `~body0内に許容される$xものに限る）
◎
link (if it is allowed in the body)
<li>`map$e
<li>`mark$e
<li>`~MathML-math$
<li>`meta$e （ `itemprop$a 属性を有するものに限る）
◎
meta (if the itemprop attribute is present)
<li>`meter$e
<li>`noscript$e
<li>`object$e
<li>`output$e
<li>`picture$e
<li>`progress$e
<li>`q$e
<li>`ruby$e
<li>`s$e
<li>`samp$e
<li>`script$e
<li>`select$e
<li>`slot$e
<li>`small$e
<li>`span$e
<li>`strong$e
<li>`sub$e
<li>`sup$e
<li>`~SVG-svg$
<li>`template$e
<li>`textarea$e
<li>`time$e
<li>`u$e
<li>`var$e
<li>`video$e
<li>`wbr$e
<li>`自律的~custom要素$
<li>`~text$
</ul>

<p class="note">注記：
句内容に分類される殆どの要素は、句内容に分類される要素のみを包含し得る
— ~~任意の~flow内容ではなく。
◎
Most elements that are categorised as phrasing content can only contain elements that are themselves categorised as phrasing content, not any flow content.
</p>

<p>
内容~modelの文脈における
`~text@
は、［
`なし$, または `Text$I ~node
］を意味する。
`~text$は，内容~modelに利用されることもあるが、分類としては，`句内容$や`要素間~空白$（ 0 個以上の`空白類$のみからなる `Text$I ~node）にもなり得る。
◎
Text, in the context of content models, means either nothing, or Text nodes. Text is sometimes used as a content model on its own, but is also phrasing content, and can be inter-element whitespace (if the Text nodes are empty or contain just space characters).
</p>


<div class="p">
<p>
［
`Text$I ~nodeを成す文字列 ／ 内容~属性の値
］は、次を満たさ~MUST：
</p>

<ul >
<li>`~Unicode文字$のみからなる
<li>U+0000 文字は包含しない
<li>恒久的に未定義とされる~Unicode文字（ noncharacters ）は包含しない
<li>`空白類$以外の`制御~文字$は包含しない
</ul>

<p>
この仕様は、精確な文脈に依存して，［
`Text$I ~nodeを成す文字列 ／ 内容~属性の値
］がとり得る~~範囲に 余分の拘束を課すこともある。
</p>

◎
Text nodes and attribute values must consist of Unicode characters, must not contain U+0000 characters, must not contain permanently undefined Unicode characters (noncharacters), and must not contain control characters other than space characters. This specification includes extra constraints on the exact value of Text nodes and attribute values depending on their precise context.
</div>


					</section>
					<section id="embedded-content-2">
<h5 title="Embedded content">3.2.4.2.6. 埋込みの内容</h5>

<p>
`埋込みの内容@
は、文書の中に［
別の資源を取込む ／
別の語彙に属する内容を挿入する
］ような内容である：
◎
Embedded content is content that imports another resource into the document, or content from another vocabulary that is inserted into the document.
</p>

<ul class="brief category-list">
<li>`audio$e
<li>`canvas$e
<li>`embed$e
<li>`iframe$e
<li>`img$e
<li>`~MathML-math$
<li>`object$e
<li>`picture$e
<li>`~SVG-svg$
<li>`video$e
</ul>

<p>
`~HTML名前空間$以外の名前空間に属する要素, および
その~metadataでない内容を伝達するものは、この仕様にて定義される内容~modelの目的0においては，`埋込みの内容$になる（例： MathML, ~SVG ）。
◎
Elements that are from namespaces other than the HTML namespace and that convey content but not metadata, are embedded content for the purposes of the content models defined in this specification. (For example, MathML, or SVG.)
</p>

<p>
埋込みの内容を与える要素には、外部~資源を利用できないとき（例：~supportされない形式であるため）に利用される，
`~fallback内容@
を持つものもある。
何が~fallbackにあたるのかは、それぞれの要素~定義にて定められる。
◎
Some embedded content elements can have fallback content: content that is to be used when the external resource cannot be used (e.g. because it is of an unsupported format). The element definitions state what the fallback is, if any.
</p>

					</section>
					<section id="interactive-content">
<h5 title="Interactive content">3.2.4.2.7. 対話的~内容</h5>


<p>
`対話的~内容@
は、利用者~対話のために特に意図されている内容である：
◎
Interactive content is content that is specifically intended for user interaction.
</p>

<ul class="brief category-list">
<li>`a$e （ `href$a 属性を有するものに限る）
◎
a (if the href attribute is present)
<li>`audio$e （ `controls$a 属性を有するものに限る）
◎
audio (if the controls attribute is present)
<li>`button$e
<li>`details$e
<li>`embed$e
<li>`iframe$e
<li>`img$e （ `usemap$a 属性を有するものに限る）
◎
img (if the usemap attribute is present)
<li>`input$e （ `type$a 属性の状態 ~NEQ `Hidden$st なるものに限る）
◎
input (if the type attribute is not in the Hidden state)
<li>`keygen$e
<li>`label$e
<li>`object$e （ `usemap$a 属性を有するものに限る）
◎
object (if the usemap attribute is present)
<li>`select$e
<li>`textarea$e
<li>`video$e （ `controls$a 属性を有するものに限る）
◎
video (if the controls attribute is present)
</ul>

<p>
`tabindex$a
属性は、どの要素も`対話的~内容$にし得る。
◎
The tabindex attribute can also make any element into interactive content.
</p>

					</section>
					<section id="palpable-content">
<h5 title="Palpable content">3.2.4.2.8. ~palpable内容</h5>

<p>
一般~規則として、内容~modelにて，何らかの`~flow内容$や`句内容$が許容されるような要素は、その`内容$内に 1 個以上の［
`~palpable内容$であって, `hidden$a 属性が指定されていない
］ような~nodeを持つべきである。
◎
As a general rule, elements whose content model allows any flow content or phrasing content should have at least one node in its contents that is palpable content and that does not have the hidden attribute specified.
</p>

<p class="trans-note">【
“~palpable”
— “触れれる”
】</p>


<div class="note">
<p>注記：
`~palpable内容$は、次のいずれかを提供して要素を空でなくする：
</p>

<ul >
<li>何らかの子孫
<li>空でない`~text$
<li>利用者が［
聴ける（ `audio$e 要素）／
見れる（ `video$e, `img$e, `canvas$e 要素）／
対話できる（対話的~form~controlなど）
］ような何か
</ul>

◎
Palpable content makes an element non-empty by providing either some descendant non-empty text, or else something users can hear (audio elements) or view (video or img or canvas elements) or otherwise interact with (for example, interactive form controls).
</div>


<p>
この要件は難しいものではないが、要素が正当に空になり得るような多くの事例がある。
例えば、要素が~scriptにより後で埋められるような~placeholderとして利用されるときや、要素は~templateの一部であって，殆どの頁では埋められるが，ある頁では無関係になるときなど。
◎
This requirement is not a hard requirement, however, as there are many cases where an element can be empty legitimately, for example when it is used as a placeholder which will later be filled in by a script, or when the element is part of a template and would on most pages be filled in but on some pages is not relevant.
</p>

<p>
適合性~検査器には、この要件を充足できない要素を見出す仕組みを，作者の著作補助として提供することが奨励される。
◎
Conformance checkers are encouraged to provide a mechanism for authors to find elements that fail to fulfill this requirement, as an authoring aid.
</p>

<p>
次の要素が
`~palpable内容@
とされる：
◎
The following elements are palpable content:
</p>


<ul class="brief category-list">
<li>`a$e
<li>`abbr$e
<li>`address$e
<li>`article$e
<li>`aside$e
<li>`audio$e （ `controls$a 属性を有するものに限る）
◎
audio (if the controls attribute is present)
<li>`b$e
<li>`bdi$e
<li>`bdo$e
<li>`blockquote$e
<li>`button$e
<li>`canvas$e
<li>`cite$e
<li>`code$e
<li>`data$e
<li>`details$e
<li>`dfn$e
<li>`div$e
<li>`dl$e （ `dt^e, `dd^e ~groupを子に持つものに限る）
◎
dl (if the element's children include at least one name-value group)
<li>`em$e
<li>`embed$e
<li>`fieldset$e
<li>`figure$e
<li>`footer$e
<li>`form$e
<li>`h1$e
<li>`h2$e
<li>`h3$e
<li>`h4$e
<li>`h5$e
<li>`h6$e
<li>`header$e
<li>`hgroup$e
<li>`i$e
<li>`iframe$e
<li>`img$e
<li>`input$e （ `type$a 属性の状態 ~NEQ `Hidden$st なるものに限る）
◎
input (if the type attribute is not in the Hidden state)
<li>`ins$e
<li>`kbd$e
<li>`keygen$e
<li>`label$e
<li>`main$e
<li>`map$e
<li>`mark$e
<li>`~MathML-math$
<li>`menu$e （`menu.type$a 属性の状態 ~NEQ `toolbar$st なるものに限る）
◎
menu (if the type attribute is in the toolbar state)
<li>`meter$e
<li>`nav$e
<li>`object$e
<li>`ol$e （ 1 個以上の `li$e 要素を子に持つものに限る）
◎
ol (if the element's children include at least one li element)
<li>`output$e
<li>`p$e
<li>`pre$e
<li>`progress$e
<li>`q$e
<li>`ruby$e
<li>`s$e
<li>`samp$e
<li>`section$e
<li>`select$e
<li>`small$e
<li>`span$e
<li>`strong$e
<li>`sub$e
<li>`sup$e
<li>`~SVG-svg$
<li>`table$e
<li>`textarea$e
<li>`time$e
<li>`u$e
<li>`ul$e （要素が 1 個以上の `li$e 要素を子に持つものに限る）
◎
ul (if the element's children include at least one li element)
<li>`var$e
<li>`video$e
<li>`自律的~custom要素$
<li>`~text$ （`要素間~空白$でないものに限る）
◎
Text that is not inter-element whitespace
</ul>


					</section>
					<section id="script-supporting-elements">
<h5 title="Script-supporting elements">3.2.4.2.9. ~scriptを~supportする要素</h5>

<p>
`~scriptを~supportする要素@
は、それ自身は何も`表現-$しない（すなわち，具現化されない）が，例えば 利用者に機能性を提供するためとして、~scriptを~supportするために利用されるものである。
◎
Script-supporting elements are those that do not represent anything themselves (i.e. they are not rendered), but are used to support scripts, e.g. to provide functionality for the user.
</p>

<p>
次の要素が~scriptを~supportする：
◎
The following elements are script-supporting elements:
</p>

<ul class="brief category-list">
<li>`script$e
<li>`template$e
</ul>


					</section>
				</section>
				<section id="transparent-content-models">
<h4 title="Transparent content models">3.2.4.3. 透過的な内容~model</h4>

<p>
一部の要素は、その内容~modelにおいて “透過的（ transparent ）” と記述される部分を持つ
— そのような要素は、
`透過的@
と呼ばれる。
`透過的$な要素 %要素 の内容~modelは、その親~要素の内容~modelから導出される。
すなわち、 %要素 の内容~modelにおいて “透過的” とされている所では、［
%要素 の親の内容~modelにおいて， %要素 が許容される所
］に要求されるものと同じ要素が要求される。
◎
Some elements are described as transparent; they have "transparent" in the description of their content model. The content model of a transparent element is derived from the content model of its parent element: the elements required in the part of the content model that is "transparent" are the same elements as required in the part of the content model of the parent of the transparent element in which the transparent element finds itself.
</p>

<div class="example">

<p>
具体例として， `ins$e 要素は透過的であり、 `ruby$e 要素の子であるときは， `rt$e 要素を包含できない
— `ruby$e 要素の内容~modelにおいて `ins$e 要素が許容される部分は，`句内容$を許容する部分であり、 `rt$e 要素は`句内容$ではないので。
◎
For instance, an ins element inside a ruby element cannot contain an rt element, because the part of the ruby element's content model that allows ins elements is the part that allows phrasing content, and the rt element is not phrasing content.
</p>

</div>

<p class="note">注記：
一部の事例では、透過的な要素が互いに入子にされている所では，処理-は反復的に適用される必要がある。
◎
In some cases, where transparent elements are nested in each other, the process has to be applied iteratively.
</p>


<div class="example">

<p>
次の~markup片を考える：
◎
Consider the following markup fragment:
</p>

<pre>
&lt;p&gt;&lt;object&gt;&lt;param&gt;&lt;ins&gt;&lt;map&gt;&lt;a href="/"&gt;りんご&lt;/a&gt;&lt;/map&gt;&lt;/ins&gt;&lt;/object&gt;&lt;/p&gt;
</pre>

<p>
"りんご" が `a$e 要素の内側に許容されるか検査するため、内容~modelが調べられる。
`a$e 要素,
その親の `map$e 要素,
そのまた親の `ins$e 要素の内容~modelは透過的であり、そのまた親の `object$e 要素の内容~modelにおいて `ins$e 要素が現れ得る部分もまた， “透過的” である。
`object$e 要素の親は `p$e 要素であり， `p$e の内容~modelは`句内容$であり，~textは句内容であり， "りんご" は~textであるので、 "りんご" は許容されることになる。
◎
To check whether "Apples" is allowed inside the a element, the content models are examined. The a element's content model is transparent, as is the map element's, as is the ins element's, as is the part of the object element's in which the ins element is found. The object element is found in the p element, whose content model is phrasing content. Thus, "Apples" is allowed, as text is phrasing content.
</p>

</div>

<p>
透過的な要素が親を持たない場合、その内容~modelにおいて “透過的” な部分は，どの`~flow内容$も受容するものと扱われ~MUST。
◎
When a transparent element has no parent, then the part of its content model that is "transparent" must instead be treated as accepting any flow content.
</p>

				</section>
				<section id="paragraphs">
<h4 title="Paragraphs">3.2.4.4. 段落</h4>

<p class="note">注記：
この節に定義される用語 `段落$は、単なる `p$e 要素の定義より広い概念であり，文書をどう解釈するかを述べるために利用される。
`p$e 要素は、`段落$を~mark-upするいくつかの仕方の一つに過ぎない。
◎
The term paragraph as defined in this section is used for more than just the definition of the p element. The paragraph concept defined here is used to describe how to interpret documents. The p element is merely one of several ways of marking up a paragraph.
</p>

<p>
`段落@
は，概して、~typographyにおけるような，特定0の論題をいくつかの文で論じる`句内容$の連なりからなる，~textの~blockを形成するが、より一般的な~thematic~group分けにも利用し得る。
具体例として、~addressも段落の一種であり，［
~form／署名行／詩の一節
］の一部分も同様である。
◎
A paragraph is typically a run of phrasing content that forms a block of text with one or more sentences that discuss a particular topic, as in typography, but can also be used for more general thematic grouping. For instance, an address is also a paragraph, as is a part of a form, a byline, or a stanza in a poem.
</p>


<div class="example">

<p>
次の例には、 `section^e 内に二つの段落がある。
また、段落でない句内容を包含する見出しもある。
~commentや`要素間~空白$は、段落を形成しないことに注意。
◎
In the following example, there are two paragraphs in a section. There is also a heading, which contains phrasing content that is not a paragraph. Note how the comments and inter-element whitespace do not form paragraphs.
</p>

<pre>
&lt;section&gt;
  &lt;h1&gt;段落の例&lt;/h1&gt;
  この例の&lt;em&gt;最初の&lt;/em&gt;段落がここにある。
  &lt;p&gt;これは二番目の段落。&lt;/p&gt;
  &lt;!-- これは段落でない。 --&gt;
&lt;/section&gt;
</pre>

<!-- 
  <h1>Example of paragraphs</h1>
  This is the <em>first</em> paragraph in this example.
  <p>This is the second.</p>
  &lt;!ー This is not a paragraph. ー&gt;
-->

</div>

<p>
`~flow内容$における段落は、文書から［
`a$e, `ins$e, `del$e, `map$e
］要素を除いたときの見かけを基準に定義される。
これらの要素の内容~modelは，混成的であり、下の最初の二つの例に示されるように，段落~境界を不明瞭にし得るため、問題0を複雑にするので。
◎
Paragraphs in flow content are defined relative to what the document looks like without the a, ins, del, and map elements complicating matters, since those elements, with their hybrid content models, can straddle paragraph boundaries, as shown in the first two examples below.
</p>

<p class="note">注記：
一般に，要素~間の段落~境界は、不明瞭にしないのが最善である。
そのような~markupを維持管理するのは困難にもなり得る。
◎
Generally, having elements straddle paragraph boundaries is best avoided. Maintaining such markup can be difficult.
</p>


<div class="example">

<p>
次の例は、先掲の例と同じ~markupの一部分を `ins$e, `del$e 要素で括って，~textが変更されたことを示している（この~markupは、変更らしきものとは言えないが）。
この例では、 `ins$e, `del$e 要素があるにもかかわらず，先掲の例と正確に同じ段落を成すことに注意
— `ins$e 要素は，見出しと最初の段落を不明瞭にしていて、
`del$e 要素は，二つの段落の合間の境界を不明瞭にしている。
◎
The following example takes the markup from the earlier example and puts ins and del elements around some of the markup to show that the text was changed (though in this case, the changes admittedly don't make much sense). Notice how this example has exactly the same paragraphs as the previous one, despite the ins and del elements — the ins element straddles the heading and the first paragraph, and the del element straddles the boundary between the two paragraphs.
</p>

<pre>
&lt;section&gt;
  &lt;ins&gt;&lt;h1&gt;段落の例&lt;/h1&gt;
  この例の&lt;em&gt;最初の&lt;/em&gt;段落が&lt;/ins&gt;ここにある&lt;del&gt;。
  &lt;p&gt;これは二番目の段落。&lt;/p&gt;&lt;/del&gt;
  &lt;!-- これは段落でない。 --&gt;
&lt;/section&gt;
</pre>

<!-- 
  <h1>Example of paragraphs</h1>
  This is the <em>first</em> paragraph in this example.
  <p>This is the second.</p>
  ーー This is not a paragraph. ーー
-->

</div>

<p>
文書~内のすべての［
`a$e, `ins$e, `del$e, `map$e
］要素を，それぞれの`内容$に置換した結果の~DOMにおける、［
`句内容$も`句内容$以外の内容も受容する要素
］における、［
他の型の内容に割込まれないような，互いに同胞の`句内容$~nodeの連なり
］であって，［
`埋込みの内容$でも`要素間~空白$でもない~nodeを 1 個以上含むもの
］を考える。
元の~DOMにおける段落は、そのような各~連なりの［
最初の~nodeの直前から, 最後の~nodeの直後まで
］に存在する（段落は，したがって［
`a$e ／ `ins$e ／ `del$e ／ `map$e
］要素をまたがり得る）。
◎
Let view be a view of the DOM that replaces all a, ins, del, and map elements in the document with their contents. Then, in view, for each run of sibling phrasing content nodes uninterrupted by other types of content, in an element that accepts content other than phrasing content as well as phrasing content, let first be the first node of the run, and let last be the last node of the run. For each such run that consists of at least one node that is neither embedded content nor inter-element whitespace, a paragraph exists in the original DOM from immediately before first to immediately after last. (Paragraphs can thus span across a, ins, del, and map elements.)
</p>

<p>
適合性~検査器は、段落どうしが互いに重なる事例に際し，作者に警告してよい（これは［
`object$e ／ `video$e ／ `audio$e ／ `canvas$e
］要素にて起こり得る。
また，［
`~SVG-svg$ ／ `~MathML-math$
］などの、その中で更なる埋込みの~HTMLを許容するような，他の名前空間に属する要素を通しても、間接的に起こり得る。
◎
Conformance checkers may warn authors of cases where they have paragraphs that overlap each other (this can happen with object, video, audio, and canvas elements, and indirectly through elements in other namespaces that allow HTML to be further embedded therein, like SVG svg or MathML math).
</p>

<p>
`段落$はまた， `p$e 要素により明示的に形成される。
◎
A paragraph is also formed explicitly by p elements.
</p>

<p class="note">注記：
互いの段落を分離するような，句内容~以外の内容がない所では、
`p$e 要素を利用して個々の段落を包装できる。
◎
The p element can be used to wrap individual paragraphs when there would otherwise not be any content other than phrasing content to separate the paragraphs from each other.
</p>


<div class="example">

<p>
次の例では、~linkは［
最初の段落の半分,
二つの段落を分離している見出しすべて,
二番目の段落の半分
］に渡る。
それは、段落と見出しを不明瞭にする。
◎
In the following example, the link spans half of the first paragraph, all of the heading separating the two paragraphs, and half of the second paragraph. It straddles the paragraphs and the heading.
</p>

<pre>
&lt;header&gt;
 Welcome!
 &lt;a href="about.html"&gt;
  This is home of...
  &lt;h1&gt;The Falcons!&lt;/h1&gt;
  The Lockheed Martin multirole jet fighter aircraft!
 &lt;/a&gt;
 This page discusses the F-16 Fighting Falcon's innermost secrets.
&lt;/header&gt;
</pre>

<p>
これを~mark-upする別の仕方を次に示す
— 今度は、段落を明示的に示した上で， 1 個の~link要素を，3 つに分割する：
◎
Here is another way of marking this up, this time showing the paragraphs explicitly, and splitting the one link element into three:
</p>

<pre>
&lt;header&gt;
 &lt;p&gt;Welcome! &lt;a href="about.html"&gt;This is home of...&lt;/a&gt;&lt;/p&gt;
 &lt;h1&gt;&lt;a href="about.html"&gt;The Falcons!&lt;/a&gt;&lt;/h1&gt;
 &lt;p&gt;&lt;a href="about.html"&gt;The Lockheed Martin multirole jet
 fighter aircraft!&lt;/a&gt; This page discusses the F-16 Fighting
 Falcon's innermost secrets.&lt;/p&gt;
&lt;/header&gt;
</pre>

</div>

<div class="example">

<p>
~fallback内容を定義する，ある種の要素を利用しているときには、段落どうしが重なることもある。
例えば、次の `section^e には：
◎
It is possible for paragraphs to overlap when using certain elements that define fallback content. For example, in the following section:
</p>

<pre>
&lt;section&gt;
 &lt;h1&gt;猫で遊ぼう&lt;/h1&gt;
 猫シミュレータで遊びませんか。
 &lt;object data="cats.sim"&gt;
  猫シミュレータは、次のリンクから遊べます：
  &lt;ul&gt;
   &lt;li&gt;&lt;a href="cats.sim"&gt;シミュレータ ファイルをダウンロードする&lt;/a&gt;
   &lt;li&gt;&lt;a href="http://sims.example.com/watch?v=LYds5xY4INU"&gt;オンライン シミュレータを~~利用する&lt;/a&gt;
  &lt;/ul&gt;
  Mellblom ブラウザは最新版にアップグレードすることをすすめます。
 &lt;/object&gt;
 面白いから是非！
&lt;/section&gt;
</pre>

<p>
5 個の段落がある：
◎
There are five paragraphs:
</p>

<!-- 
You can play with my cat simulator.
To see the cat simulator, use one of the following links:
Download simulator file
Use online simulator
Alternatively, upgrade to the Mellblom Browser.
I'm quite proud of it.

-->
<ol class="brief">
	<li>
次が記された段落：
"猫シミュレータで遊びませんか。 <i>object</i> 面白いから是非！
— ここで、 <i>object</i> は `object$e 要素である。
◎
The paragraph that says "You can play with my cat simulator. object I'm quite proud of it.", where object is the object element.
</li>
	<li>
次が記された段落：
"猫シミュレータは、次のリンクから遊べます："
◎
The paragraph that says "To see the cat simulator, use one of the following links:".
</li>
	<li>
次が記された段落：
"シミュレータ ファイルをダウンロードする"
◎
The paragraph that says "Download simulator file".
</li>
	<li>
次が記された段落：
"オンライン シミュレータを~~利用する"
。
◎
The paragraph that says "Use online simulator".
</li>
	<li>
次が記された段落：
"Mellblom ブラウザは最新版にアップグレードすることをすすめます。"
◎
The paragraph that says "Alternatively, upgrade to the Mellblom Browser.".
</li></ol>

<p>
最初の段落は、他の 4 つと重なっている。
"cats.sim" 資源を~supportする~UAは，最初のもののみを示すことになる。
一方で，~fallbackを示す~UAは、最初の段落の最初の文を，それが二番目のものと同じ段落であるかのように混同して示すことになり、最後の段落を，それが最初の段落の二番目の文の開始であったかのように示すことになる。
◎
The first paragraph is overlapped by the other four. A user agent that supports the "cats.sim" resource will only show the first one, but a user agent that shows the fallback will confusingly show the first sentence of the first paragraph as if it was in the same paragraph as the second one, and will show the last paragraph as if it was at the start of the second sentence of the first paragraph.
</p>

<p>
この混同を避けるには、明示的 `p$e 要素を利用できる。
例えば：
◎
To avoid this confusion, explicit p elements can be used. For example:
</p>

<pre>
&lt;section&gt;
 &lt;h1&gt;猫で遊ぼう&lt;/h1&gt;
 &lt;p&gt;猫シミュレータで遊びませんか。&lt;/p&gt;
 &lt;object data="cats.sim"&gt;
  &lt;p&gt;猫シミュレータは、次のリンクから遊べます：&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;&lt;a href="cats.sim"&gt;シミュレータ ファイルをダウンロードする&lt;/a&gt;
   &lt;li&gt;&lt;a href="http://sims.example.com/watch?v=LYds5xY4INU"&gt;オンライン シミュレータを~~利用する&lt;/a&gt;
  &lt;/ul&gt;
  &lt;p&gt;Mellblom ブラウザは最新版にアップグレードすることをすすめます。&lt;/p&gt;
 &lt;/object&gt;
 &lt;p&gt;面白いから是非！&lt;/p&gt;
&lt;/section&gt;
</pre>

</div>

				</section>
			</section>
			<section id="global-attributes">
<h3 title="Global attributes">3.2.5. 各種~大域的~属性</h3>

<p>
次の属性は，すべての`~HTML要素$（この仕様に定義されていないものも含む）に共通して，指定されてよい：
◎
The following attributes are common to and may be specified on all HTML elements (even those not defined in this specification):
</p>

<ul class="category-list">
<li>`accesskey$a
<!-- 
<li>`class$a
 -->
<li>`contenteditable$a
<li>`contextmenu$a
<li>`dir$a
<li>`draggable$a
<li>`dropzone$a
<li>`hidden$a
<li>`is$a
<li>`itemid$a
<li>`itemprop$a
<li>`itemref$a
<li>`itemscope$a
<li>`itemtype$a
<li>`lang$a
<li>`spellcheck$a
<li>`style$a
<li>`tabindex$a
<li>`title$a
<li>`translate$a
</ul>


<p>
これらの属性は、この仕様により，`~HTML要素$のみに対する属性として定義される。
この仕様がこれらの属性を有する要素を~~参照する所では、他の名前空間に属する要素は，これらの属性を有せるものと定義されていない限り，これらの属性を有するものと見なされては~MUST_NOT。
◎
These attributes are only defined by this specification as attributes for HTML elements. When this specification refers to elements having these attributes, elements from namespaces that are not defined as having these attributes must not be considered as being elements with these attributes.
</p>

<div class="example">

<p>
例えば、次の~XML片における `bogus^l 要素は、~literalとして名前 `dir^l の属性を有しているが、にもかかわらず，この仕様にて定義される `dir$a 属性は有さないとされる。
したがって，~~内側の `span$e 要素の`方向性$は、
`div$e 要素から `bogus^l 要素を通して間接的に継承される結果，
`~rtl$ になる。
◎
For example, in the following XML fragment, the "bogus" element does not have a dir attribute as defined in this specification, despite having an attribute with the literal name "dir". Thus, the directionality of the inner-most span element is 'rtl', inherited from the div element indirectly through the "bogus" element.
</p>

<pre class="bad">&lt;div xmlns="http://www.w3.org/1999/xhtml" dir="rtl"&gt;
 &lt;bogus xmlns="http://example.net/ns" dir="ltr"&gt;
  &lt;span xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;/span&gt;
 &lt;/bogus&gt;
&lt;/div&gt;
</pre>

</div>

<hr>


<p>
WHATWG DOM 標準は、名前空間を問わず，どの要素に対しても［
`class@a ／ `id@a ／ `slot@a
］属性に対する~UA要件を定義している。
`DOM$r
◎
The WHATWG DOM standard defines the user agent requirements for the class, id, and slot attributes for any element in any namespace. [DOM]
</p>

<p>
［
`class$a ／ `id$a ／ `slot$a
］属性は、どの`~HTML要素$にも指定できる。
◎
The class, id, and slot attributes may be specified on all HTML elements.
</p>

<p>
`~HTML要素$上に指定される `class$a 属性の値は，`空白区切りの~token集合$で~MUST
— 要素が属する種々の~classを表現するような。
◎
When specified on HTML elements, the class attribute must have a value that is a set of space-separated tokens representing the various classes that the element belongs to.
</p>


<div class="note">
<p>注記：
要素に~classをあてがうことは、［
~CSSにおける選択子の~class照合 ／
~DOMにおける `getElementsByClassName()$m ~method ／
他のその種の特色機能
］に影響する。
◎
Assigning classes to an element affects class matching in selectors in CSS, the getElementsByClassName() method in the DOM, and other such features.
</p>

<p>
作者が `class$a 属性に利用できる~tokenに追加の制約はないが、作者には，内容に欲される呈示ではなく，内容の資質を述べる値を利用することが奨励される。
◎
There are no additional restrictions on the tokens authors can use in the class attribute, but authors are encouraged to use values that describe the nature of the content, rather than values that describe the desired presentation of the content.
</p>
</div>


<div class="p">
<p>
`~HTML要素$上に指定される `id$a 属性の値は、次のいずれも満たさ~MUST：
</p>

<ul><li>要素の`木$x内のすべての要素の`~ID$xにわたって一意である
<li>1 個以上の文字を包含する
<li>`空白類$を包含しない
</ul>
◎
When specified on HTML elements, the id attribute value must be unique amongst all the IDs in the element's tree and must contain at least one character. The value must not contain any space characters.
</div>


<div class="note">
<p>注記：
`id$a 属性は、要素の`~ID$x（一意な識別子）を指定する。
`DOM$r
◎
The id attribute specifies its element's unique identifier (ID).
</p>

<p>
~IDがとり得る形に他の制約は無い。
特に，~IDは、［
数字のみからなる ／
数字や~underscoreから開始する ／
約物のみからなる
］等々にもなり得る。
◎
There are no other restrictions on what form an ID can take; in particular, IDs can consist of just digits, start with a digit, start with an underscore, consist of just punctuation, etc.
</p>

<p>
要素の`~ID$xは、様々な目的0に利用され得る。
特に、［
`素片$urlを利用して 文書の特定の部位へ~linkする ／
~scripting時に要素を~targetする ／
特定の要素を~CSSで~styleする
］仕方としての利用が多い。
◎
An element's unique identifier can be used for a variety of purposes, most notably as a way to link to specific parts of a document using fragments, as a way to target an element when scripting, and as a way to style a specific element from CSS.
</p>

</div>


<p>
`id$a 属性の値による識別子は、不透明な文字列であり，特定0の意味が導出されるべきでない。
◎
Identifiers are opaque strings. Particular meanings should not be derived from the value of the id attribute.
</p>


<p>
`slot$a 属性に対する`~HTML要素$に特有の適合性~要件はない。
◎
There are no conformance requirements for the slot attribute specific to HTML elements.
</p>


<hr>



<p>
支援技術~製品が，~HTMLの
要素／属性
で可能0なものより木目細かい~interfaceを公開できるようにするため、
<a href="#wai-aria">支援技術~製品のための注釈</a>
の集合（ ARIA `role$a, `aria-*$a 属性）が指定できる／され得る。
`ARIA$r
◎
To enable assistive technology products to expose a more fine-grained interface than is otherwise possible with HTML elements and attributes, a set of annotations for assistive technology products can be specified (the ARIA role and aria-* attributes). [ARIA]
</p>

<hr>

<p>
次に挙げる`~event~handler内容~属性$は、どの`~HTML要素$上にも指定されてよい：
◎
The following event handler content attributes may be specified on any HTML element:
</p>


<ul class="category-list">
<li>`onabort$m
<li>`onautocomplete$m
<li>`onautocompleteerror$m
<li>`onblur$m†
<li>`oncancel$m
<li>`oncanplay$m
<li>`oncanplaythrough$m
<li>`onchange$m
<li>`onclick$m
<li>`onclose$m
<li>`oncontextmenu$m
<li>`oncuechange$m
<li>`ondblclick$m
<li>`ondrag$m
<li>`ondragend$m
<li>`ondragenter$m
<li>`ondragexit$m
<li>`ondragleave$m
<li>`ondragover$m
<li>`ondragstart$m
<li>`ondrop$m
<li>`ondurationchange$m
<li>`onemptied$m
<li>`onended$m
<li>`onerror$m†
<li>`onfocus$m†
<li>`oninput$m
<li>`oninvalid$m
<li>`onkeydown$m
<li>`onkeypress$m
<li>`onkeyup$m
<li>`onload$m†
<li>`onloadeddata$m
<li>`onloadedmetadata$m
<li>`onloadstart$m
<li>`onmousedown$m
<li>`onmouseenter$m
<li>`onmouseleave$m
<li>`onmousemove$m
<li>`onmouseout$m
<li>`onmouseover$m
<li>`onmouseup$m
<li>`onwheel$m
<li>`onpause$m
<li>`onplay$m
<li>`onplaying$m
<li>`onprogress$m
<li>`onratechange$m
<li>`onreset$m
<li>`onresize$m†
<li>`onscroll$m†
<li>`onseeked$m
<li>`onseeking$m
<li>`onselect$m
<li>`onshow$m
<li>`onstalled$m
<li>`onsubmit$m
<li>`onsuspend$m
<li>`ontimeupdate$m
<li>`ontoggle$m
<li>`onvolumechange$m
<li>`onwaiting$m
</ul>

<p class="note">注記：
†付きの属性は、 `body$e 要素~上に指定されたときには，異なる意味になる
— その要素は、 `Window$I ~objの同じ名前の`~event~handler$を公開するので。
◎
The attributes marked with an asterisk have a different meaning when specified on body elements as those elements expose event handlers of the Window object with the same names.
</p>

<p class="note">注記：
これらの属性は，すべての要素に適用されるとしても、すべての要素~上で有用になるわけではない。
例えば，~UAにより発火される `volumechange$et ~eventを受取れるのは、`媒体~要素$xに限られる。
◎
While these attributes apply to all elements, they are not useful on all elements. For example, only media elements will ever receive a volumechange event fired by the user agent.
</p>

<hr>

<p>
どの `~HTML要素$上にも，`~custom~data属性$（例： `data-foldername^a, `data-msgid^a 等々）を指定して，頁に特有の~custom~dataを格納できる。
◎
Custom data attributes (e.g. data-foldername or data-msgid) can be specified on any HTML element, to store custom data specific to the page.
</p>

<hr>

<p>
`~HTML文書$xにおいては、`~HTML名前空間$に属する要素には，
`xmlns^a 属性が指定されてよい
— ただし，その値が正確に
`http://www.w3.org/1999/xhtml^l
である場合，その場合に限り。
このことは、`~XML文書$xには適用されない。
◎
In HTML documents, elements in the HTML namespace may have an xmlns attribute specified, if, and only if, it has the exact value "http://www.w3.org/1999/xhtml". This does not apply to XML documents.
</p>

<p class="note">注記：
~HTMLにおいては、 `xmlns^a 属性は，何ら効果はない。
それは、基本的に護符のようなものである。
それは単に，~HTMLと~XHTMLとの間の移行を容易くするために許容されている。
`~HTML構文解析器$xにより構文解析されるときには、この属性は
どの名前空間にも属さないようにされる
— ~XMLにおける名前空間~宣言~属性の様な，
`http://www.w3.org/2000/xmlns/^l
名前空間ではなく。
◎
In HTML, the xmlns attribute has absolutely no effect. It is basically a talisman. It is allowed merely to make migration to and from XHTML mildly easier. When parsed by an HTML parser, the attribute ends up in no namespace, not the "http://www.w3.org/2000/xmlns/" namespace like namespace declaration attributes in XML do.
</p>

<p class="note">注記：
~XMLにおいては、
`xmlns^a 属性は，名前空間~宣言の仕組みの一部であり、要素は，［
実際には名前空間が指定されていないような `xmlns^a 属性
］を有し得ない。
◎
In XML, an xmlns attribute is part of the namespace declaration mechanism, and an element cannot actually have an xmlns attribute in no namespace specified.
</p>

<hr>

<p>
~XML仕様はまた、`~XML文書$x内のどの要素に対しても，`~XML名前空間$に属する `~xml_space$a 属性の利用を許容する。
この属性は、`~HTML要素$に対しては効果はない
— ~HTMLにおける既定の挙動は，空白を保全するので。
`XML$r
◎
The XML specification also allows the use of the xml:space attribute in the XML namespace on any element in an XML document. This attribute has no effect on HTML elements, as the default behaviour in HTML is to preserve whitespace. [XML]
</p>

<p class="note">注記：
`text/html$c 構文の下で`~HTML要素$上の
`~xml_space$a 属性を直列化する仕方はない。
◎
There is no way to serialise the xml:space attribute on HTML elements in the text/html syntax.
</p>


				<section id="the-title-attribute">
<h4 title="The title attribute">3.2.5.1. `title^a 属性</h4>


<div class="p">
<p>
`title@a
属性は、~tooltipに適切になるような，要素に対する参考情報を`表現-$する。
その値は~textであり：
</p>

<ul>
<li>~linkにおいては、~target資源の~titleや記述にもなり得る。
<li>画像においては，画像~creditや画像の記述にもなり得る。
<li>段落においては，その~textの脚注や解説にもなり得る。
<li>引用文においては，その~sourceについての更なる情報にもなり得る。
<li>`対話的~内容$においては，要素の利用についての ~labelや指示書きにもなり得る。
</ul>

<p>
…等々。
</p>

◎
The title attribute represents advisory information for the element, such as would be appropriate for a tooltip. On a link, this could be the title or a description of the target resource; on an image, it could be the image credit or a description of the image; on a paragraph, it could be a footnote or commentary on the text; on a citation, it could be further information about the source; on interactive content, it could be a label for, or instructions for, use of the element; and so forth. The value is text.
</div>

<p class="note">注記：
現時点では、 `title$a 属性には依拠しないことが奨励される
— 多くの~UAは、この属性を，この仕様に要求されるように~access可能な方式で公開していない（例：~tooltipを現れさせるために，~mouseなどの~pointing装置を要求することは、現代の携帯端末や~tabletを用いている，~keyboard／~touchのみの利用者たちを除外することになる）。
◎
Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by this specification (e.g. requiring a pointing device such as a mouse to cause a tooltip to appear, which excludes keyboard-only users and touch-only users, such as anyone with a modern phone or tablet).
</p>

<p>
この属性が要素から省略されている場合、最も近傍の，`title$a 属性を有する先祖`~HTML要素$が，この要素に関連することを含意する。
この属性を設定すれば、それを上書きして，どの先祖の参考情報も この要素に関連しないことが明示的に定められることになる。
この属性を空~文字列に設定した場合、当の要素には参考情報は無いことを指示する。
◎
If this attribute is omitted from an element, then it implies that the title attribute of the nearest ancestor HTML element with a title attribute set is also relevant to this element. Setting the attribute overrides this, explicitly stating that the advisory information of any ancestors is not relevant to this element. Setting the attribute to the empty string indicates that the element has no advisory information.
</p>

<p>
`title$a 属性の値の中の 各 LF 文字（ U+000A LINE FEED ）は、改行を表現し，もしあれば、内容は複数の行に分割される。
◎
If the title attribute's value contains U+000A LINE FEED (LF) characters, the content is split into multiple lines. Each U+000A LINE FEED (LF) character represents a line break.
</p>

<div class="example">
<p>
`title$a 属性における改行文字の利用には、注意すべき点がある。
◎
Caution is advised with respect to the use of newlines in title attributes.
</p>

<p>
具体例として，次の片の略称（ `abbr^e ）の中の改行は、<em>実際に展開される</em>ことになる：
◎
For instance, the following snippet actually defines an abbreviation's expansion with a line break in it:
</p>

<pre class="bad">&lt;p&gt;今日における &lt;abbr title="Hypertext
Transport Protocol"&gt;HTTP&lt;/abbr&gt; には、多方からの関心があることがログから見て取れる。&lt;/p&gt;
</pre>

<!-- 
My logs show that there was some interest in HTTP today
 -->

</div>

<p>
［
`link$e, `abbr$e, `input$e
］など，要素には、 `title$a 属性に対し，上に述べた意味論を超える追加の意味論を定義するものもある。
◎
Some elements, such as link, abbr, and input, define additional semantics for the title attribute beyond the semantics described above.
</p>

<p>
要素の %要素 の
`参考情報@
は、次の~algoが返す値である
— 結果が空~文字列の場合、参考情報はない。
◎
The advisory information of an element is the value that the following algorithm returns, with the algorithm being aborted once a value is returned. When the algorithm returns the empty string, then there is no advisory information.
</p>

<ol>
	<li>
~IF［
%要素 は［
`link$e ／ `style$e ／ `dfn$e ／ `abbr$e ／ `menuitem$e
］要素である
］
⇒
~RET［
%要素 は `title^a 属性を有するならば その属性の値 ／
~ELSE_ 空~文字列
］
◎
If the element is a link, style, dfn, abbr, or menuitem element, then: if the element has a title attribute, return the value of that attribute, otherwise, return the empty string.
</li>
	<li>
~IF［
%要素 は `title$a 属性を有する
］
⇒
~RET その属性~値
◎
Otherwise, if the element has a title attribute, then return its value.
</li>
	<li>
~IF［
%要素 には親~要素がある
］
⇒
~RET 親~要素の`参考情報$
◎
Otherwise, if the element has a parent element, then return the parent element's advisory information.
</li>
	<li>
~RET 空~文字列
◎
Otherwise, return the empty string.
</li>

</ol>

<p>
~UAは、要素に`参考情報$があるときには，そのことが利用者に判るように伝えるべきである。
◎
User agents should inform the user when elements have advisory information, otherwise the information would not be discoverable.
</p>

<hr>

<p>
`title@m
~IDL属性は、此れの `title$a 内容~属性を`反映-$し~MUST。
◎
The title IDL attribute must reflect the title content attribute.
</p>

				</section>
				<section id="the-lang-and-xml:lang-attributes">
<h4 title="The lang and xml:lang attributes">3.2.5.2. `lang^a, `~xml_lang^a 属性</h4>

<p>
どの名前空間にも属さない `lang^a 属性
— 以下、
`素の~lang属性@
と略記する —
は、［
要素の内容, および
~textを包含するような要素の属性
］に対する第一~言語†を指定する。
その値は妥当な BCP 47 言語~tagか, 空~文字列で~MUST。
空~文字列は、第一~言語が未知であることを指示する。
`BCP47$r
◎
The lang attribute (in no namespace) specifies the primary language for the element's contents and for any of the element's attributes that contain text. Its value must be a valid BCP 47 language tag, or the empty string. Setting the attribute to the empty string indicates that the primary language is unknown. [BCP47]
</p>

<p class="trans-note">【†
この節の “言語” は、もっぱら自然言語（人が話す言語）を意味する。
】</p>

<p>
`~XML名前空間$に属する `lang^a 属性
— 以下
`~XML~lang属性@
と略記する —
は、~XMLにて定義される。
`XML$r
◎
The lang attribute in the XML namespace is defined in XML. [XML]
</p>

<p>
要素からこれらの属性が省略された場合、この要素の言語は，その親~要素があれば それの言語と同じになる。
◎
If these attributes are omitted from an element, then the language of this element is the same as the language of its parent element, if any.
</p>

<p>
`素の~lang属性$は、どの`~HTML要素$にも利用してよい。
◎
The lang attribute in no namespace may be used on any HTML element.
</p>

<p>
`~XML~lang属性$は、他の名前空間に属する要素のみならず，`~XML文書$x内の`~HTML要素$にも利用できる
— 関連の仕様がそれを許容するならば（特に， MathML, ~SVGは、それらの要素~上に指定される`~XML~lang属性$を許容する）。
同じ要素~上に［
`素の~lang属性$, 
`~XML~lang属性$
］の両者が指定されている場合、それらは，`~ASCII文字大小無視$xで正確に同じ値をとら~MUST。
◎
The lang attribute in the XML namespace may be used on HTML elements in XML documents, as well as elements in other namespaces if the relevant specifications allow it (in particular, MathML and SVG allow lang attributes in the XML namespace to be specified on their elements). If both the lang attribute in no namespace and the lang attribute in the XML namespace are specified on the same element, they must have exactly the same value when compared in an ASCII case-insensitive manner.
</p>

<div class="p">
<p>
作者は、`~HTML文書$x内の`~HTML要素$に，`~XML~lang属性$を利用しては~MUST_NOT。
~XHTMLへの／からの移行を容易くするため、作者は，`~HTML文書$x内の`~HTML要素$に対しては、［
要素~上に，`素の~lang属性$も指定されている
］場合に限り，次をすべて満たす属性を指定してよい：
</p>

<ul>
<li>接頭辞を持たない
<li>~literalとして `~xml_lang^l を局所名に持つ
<li>どの名前空間にも属さない
<li>その値は，素の~lang属性の値と`~ASCII文字大小無視$xで同じある
</ul>

◎
Authors must not use the lang attribute in the XML namespace on HTML elements in HTML documents. To ease migration to and from XHTML, authors may specify an attribute in no namespace with no prefix and with the literal localname "xml:lang" on HTML elements in HTML documents, but such attributes must only be specified if a lang attribute in no namespace is also specified, and both attributes must have the same value when compared in an ASCII case-insensitive manner.
</div>

<p class="note">注記：
そのような属性が、言語~処理に効果を及ぼすことはない。
◎
The attribute in no namespace with no prefix and with the literal localname "xml:lang" has no effect on language processing.
</p>

<hr>

<p>
~UAは、~node %~nodeの
`言語@
を決定するときは、次の手続きから返される言語~tag値に基づか~MUST：
◎
↓</p>

<ol>
	<li>
%要素 ~LET ［
%~node は要素ならば %~node ／
~ELSE_ %~node の親~要素
］
</li>
	<li>
<p>
~IF［
<!-- 広義~先祖 -->
%要素 または その ある先祖~要素に，次のいずれかを満たすものがある
］…：
</p>

<ul>
<li>`~XML~lang属性$を有する
<li>`~HTML要素$であって `素の~lang属性$を有する
</ul>

<p>
…ならば：
</p>

		<ol>
			<li>
%先祖 ~LET そのような要素のうち %要素 に最も近いもの
</li>
			<li>
~IF［
%先祖 には`~XML~lang属性$が設定されている
］
⇒
~RET その属性の値
— `素の~lang属性$も有していても，`無視-$する。
</li>
			<li>
~RET %先祖 の`素の~lang属性$の値
</li>

		</ol>
◎
To determine the language of a node, user agents must look at the nearest ancestor element (including the element itself if the node is an element) that has a lang attribute in the XML namespace set or is an HTML element and has a lang in no namespace attribute set. That attribute specifies the language of the node (regardless of its value).
◎
If both the lang attribute in no namespace and the lang attribute in the XML namespace are set on an element, user agents must use the lang attribute in the XML namespace, and the lang attribute in no namespace must be ignored for the purposes of determining the element's language.
</li>

	<li>
~IF［
`~pragmaにより設定される既定の言語$xが設定されている
］
⇒
~RET それに対応する言語~tag
◎
↓</li>
	<li>
~IF［
より高~levelの~protocol（~HTTPなど）から，単独の言語~情報が報告される
］
⇒
~RET それに対応する言語~tag
◎
↓</li>
	<li>
~RET 空~文字列
— ~nodeの言語は未知とされる。
より高~levelの~protocolから複数の言語が報告される場合も含む。
◎
If node's inclusive ancestors do not have have either attribute set, but there is a pragma-set default language set, then that is the language of the node. If there is no pragma-set default language set, then language information from a higher-level protocol (such as HTTP), if any, must be used as the final fallback language instead. In the absence of any such language information, and in cases where the higher-level protocol reports multiple languages, the language of the node is unknown, and the corresponding language tag is the empty string.
</li>
</ol>

<p>
上の結果が認識できる言語~tagでない場合、~UAは，結果を，その言語~tagを持つ未知の言語として扱わ~MUST
— 他のすべての言語からは別個の形の。
言語~tagを期待する，往来や他の~serviceとの通信の目的0においては、未知の言語~tagを改変せずに渡すべきであり、後続の~serviceが，その~dataを別の型の言語~記述として解釈しないように BCP 47 言語~tagであるものと~tag付けるべきである
`BCP47$r
◎
If the resulting value is not a recognised language tag, then it must be treated as an unknown language having the given language tag, distinct from all other languages. For the purposes of round-tripping or communicating with other services that expect language tags, user agents should pass unknown language tags through unmodified, and tagged as being BCP 47 language tags, so that subsequent services do not interpret the data as another type of language description. [BCP47]
</p>

<p class="example">
したがって，具体例として、
`lang="xyzzy"^a
を伴う要素は、（例えば~CSSにより）選択子
`:lang(xyzzy)^css
に合致するが，
`:lang(abcde)^css
には合致しない
— 両者とも等しく妥当でないが。
同様に、~Web~browserと~screen読取器が，要素の言語について~~情報を~~交換しあっている下では、~browserは，［
妥当でないと知っていたとしても，言語は `xyzzy^l であった
］ものと~screen読取器に伝えることになる
— ~screen読取器が，実際に その~tagの言語を~supportしている場合のために。
~screen読取器が、 BCP 47 に加えて，別の構文による言語~名の符号化法も~supportしていて，そこでは文字列 `xyzzy^l が~Belarusianの言語~tagであったとしても、~screen読取器が~textを~Belarusianとして扱い始めるのは，<em>不正</em>になる
— `xyzzy^l は， BCP 47 ~codeにおいては~Belarusianとされていないので（ BCP 47 は、~Belarusianに~code `be^l を利用する）。
◎
Thus, for instance, an element with lang="xyzzy" would be matched by the selector :lang(xyzzy) (e.g. in CSS), but it would not be matched by :lang(abcde), even though both are equally invalid. Similarly, if a Web browser and screen reader working in unison communicated about the language of the element, the browser would tell the screen reader that the language was "xyzzy", even if it knew it was invalid, just in case the screen reader actually supported a language with that tag after all. Even if the screen reader supported both BCP 47 and another syntax for encoding language names, and in that other syntax the string "xyzzy" was a way to denote the Belarusian language, it would be incorrect for the screen reader to then start treating text as Belarusian, because "xyzzy" is not how Belarusian is described in BCP 47 codes (BCP 47 uses the code "be" for Belarusian).
</p>

<p>
上の結果が空~文字列の場合、~nodeの言語は 明示的に未知であるものと解釈され~MUST。
◎
If the resulting value is the empty string, then it must be interpreted as meaning that the language of the node is explicitly unknown.
</p>

<hr>

<p>
~UAは、要素の言語を，適正な処理や具現化を決定する際に利用してよい（例えば、適切な［
~font／発音／辞書
］の選定や、日付~~選択などの~form~controlの利用者~interfaceなど）。
◎
User agents may use the element's language to determine proper processing or rendering (e.g. in the selection of appropriate fonts or pronunciations, for dictionary selection, or for the user interfaces of form controls such as date pickers).
</p>

<hr>

<p>
`lang@m
~IDL属性は、此れの`素の~lang属性$を`反映-$し~MUST。
◎
The lang IDL attribute must reflect the lang content attribute in no namespace.
</p>

				</section>
				<section id="the-translate-attribute">
<h4 title="The translate attribute">3.2.5.3. `translate^a 属性</h4>

<p>
`translate@a
属性は、`列挙~属性$であり，当の要素の［
属性~値／ 子である `Text$I ~nodeの値
］を［
頁を地域化する際に翻訳するか，変えないままにするか
］どうかを指定するために利用される。
◎
The translate attribute is an enumerated attribute that is used to specify whether an element's attribute values and the values of its Text node children are to be translated when the page is localized, or whether to leave them unchanged.
</p>

<p>
属性がとり得る~keywordは，［
空~文字列, `yes^c, `no^c
］のいずれかである。
［
空~文字列 ／ `yes^c 
］はいずれも <i>yes</i> 状態に対応付けられる。
`no^c は <i>no</i> 状態に対応付けられる。
加えて、三番目の状態 <i>inherit</i> 状態もある
— それは，`値なしに対する既定の状態$である（また，`妥当でない値に対する既定の状態$でもある）。
◎
The attribute's keywords are the empty string, yes, and no. The empty string and the yes keyword map to the yes state. The no keyword maps to the no state. In addition, there is a third state, the inherit state, which is the missing value default (and the invalid value default).
</p>

<div class="p">
<p>
各~要素は（非~HTML要素であっても），
`翻訳~mode@
を持つ。
それは［
`可翻訳$st ／ `翻訳不可$st
］のいずれかであり、要素の `translate$a 属性の状態に応じて，次のようになる：
</p>

<dl class="switch">
	<dt><i>yes</i> 状態</dt>
	<dd>
`可翻訳$st になる
</dd>

	<dt><i>no</i> 状態</dt>
	<dd>
`翻訳不可$st になる。
</dd>

	<dt><i>inherit</i> 状態</dt>
	<dd>
要素に親~要素が［
あれば 親と同じ状態 ／
なければ（要素は`文書~要素$）`可翻訳$st
］になる。
</dd>
	<dd>
要素が`~HTML要素$でない場合も， `translate$a 属性を有さないのでこの場合に該当する。
</dd>

</dl>

◎
Each element (even non-HTML elements) has a translation mode, which is in either the translate-enabled state or the no-translate state. If an HTML element's translate attribute is in the yes state, then the element's translation mode is in the translate-enabled state; otherwise, if the element's translate attribute is in the no state, then the element's translation mode is in the no-translate state. Otherwise, either the element's translate attribute is in the inherit state, or the element is not an HTML element and thus does not have a translate attribute; in either case, the element's translation mode is in the same state as its parent element's, if any, or in the translate-enabled state, if the element is a document element.
</div>

<p>
要素が
`可翻訳@st
状態にある下では、［
要素の`翻訳可能な属性$, および
要素の子である `Text$I ~nodeの値
］は，頁が地域化される際に翻訳されることになる。
◎
When an element is in the translate-enabled state, the element's translatable attributes and the values of its Text node children are to be translated when the page is localized.
</p>

<p>
要素が
`翻訳不可@st
状態にある下では、［
要素の属性~値, および
要素の子である `Text$I ~nodeの値
］は、頁が地域化される際に そのままにされる
— 例えば、要素は，人名や~computer~programの名前を包含しているとき。
◎
When an element is in the no-translate state, the element's attribute values and the values of its Text node children are to be left as-is when the page is localized, e.g. because the element contains a person's name or a name of a computer program.
</p>

<p>
次の表の 1 列目に挙げる要素~上の，同じ行の 2 列目に示される（かつ 3 列目の条件があれば，それも満たす）属性が
`翻訳可能な属性@
とされる：
◎
The following attributes are translatable attributes:
</p>


<div >
<table>
<thead><tr><th>要素
</th><th>内容~属性
</th><th>追加の条件／備考
</th></thead>

<tbody>
<tr><td>`th$e
<td>`th.abbr$a
<td>

<tr><td>`area$e
<td>`area.alt$a
<td>

<tr><td>`img$e
<td>`img.alt$a
<td>

<tr><td>`input$e
<td>`input.alt$a
<td>

<tr><td>`meta$e
<td>`meta.content$a
<td>要素の `meta.name$a 属性の値が，翻訳可能なことが既知である~metadata名を指定する場合に限る。

<tr><td>`a$e, `area$e
<td>`download$a
<td>

<tr><td>`menuitem$e
<td>`menuitem.label$a
<td>

<tr><td>`menu$e
<td>`menu.label$a
<td>

<tr><td>`optgroup$e
<td>`optgroup.label$a
<td>

<tr><td>`option$e
<td>`option.label$a
<td>

<tr><td>`track$e
<td>`track.label$a
<td>

<tr><td>`~HTML要素$
<td>`lang$a
<td>翻訳に利用されている言語に合致するように “翻訳され” ~MUST。

<tr><td>`input$e
<td>`input.placeholder$a
<td>

<tr><td>`textarea$e
<td>`textarea.placeholder$a
<td>

<tr><td>`iframe$e
<td>`srcdoc$a
<td>属性は、構文解析された上で，再帰的に処理され~MUST。

<tr><td>`~HTML要素$
<td>`style$a
<td>属性は、構文解析された上で，再帰的に処理され~MUST。
（例： `content$p ~propの値に対し）

<tr><td>すべての`~HTML要素$
<td>`title$a
<td>

<tr><td>`input$e
<td>`value$a
<td>要素の `type$a 属性の状態 ~IN
{ `Button$st, `Reset Button$st }
の場合に限る。

</tbody></table>

◎
• abbr on th elements
• alt on area, img, and input elements
• content on meta elements, if the name attribute specifies a metadata name whose value is known to be translatable
• download on a and area elements
• label on menuitem, menu, optgroup, option, and track elements
• lang on HTML elements; must be "translated" to match the language used in the translation
• placeholder on input and textarea elements
• srcdoc on iframe elements; must be parsed and recursively processed
• style on HTML elements; must be parsed and recursively processed (e.g. for the values of 'content' properties)
• title on all HTML elements
• value on input elements with a type attribute in the Button state or the Reset Button state
</div>


<p>
他の仕様も他の属性を`翻訳可能な属性$として定義してよい。
例えば， ARIA は、 `aria-label$a 属性を翻訳可能として定義するであろう。
◎
Other specifications may define other attributes that are also translatable attributes. For example, ARIA would define the aria-label attribute as translatable.
</p>

<hr>

<p>
`translate@m
~IDL属性の被取得時には、［
此れの`翻訳~mode$ ~EQ `可翻訳$st ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
被設定時には、此れの `translate$a 内容~属性の値を［
新たな値 ~EQ ~T ならば `yes^l ／
~ELSE_ `no^l
］に設定し~MUST。
◎
The translate IDL attribute must, on getting, return true if the element's translation mode is translate-enabled, and false otherwise. On setting, it must set the content attribute's value to "yes" if the new value is true, and set the content attribute's value to "no" otherwise.
</p>


<div class="example">

<p>
この例では、［
<mark>見本~keyboard入力，見本~program出力</mark>
］を除く，文書~内のすべては、頁が地域化される際に翻訳される：
◎
In this example, everything in the document is to be translated when the page is localized, except the sample keyboard input and sample program output:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;html lang="en"&gt; &lt;!-- 文書~要素~上では `translate=yes^a --&gt;
 &lt;head&gt;
  &lt;title&gt;The Bee Game&lt;/title&gt; &lt;!-- 暗黙的に `translate=yes^a が先祖から継承される --&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;The Bee Game is a text adventure game in English.&lt;/p&gt;
  &lt;p&gt;When the game launches, the first thing you should do is type
  &lt;kbd <mark>translate=no</mark>&gt;eat honey&lt;/kbd&gt;. The game will respond with:&lt;/p&gt;
  &lt;pre&gt;&lt;samp <mark>translate=no</mark>&gt;Yum yum! That was some good honey!&lt;/samp&gt;&lt;/pre&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

</div>
<!-- 


— default on the document element is translate=yes —
The Bee Game
— implied translate=yes inherited from ancestors —
 </head>
 <body>
  <p>The Bee Game is a text adventure game in English.</p>
  <p>When the game launches, the first thing you should do is type
  <kbd translate=no>eat honey</kbd>. The game will respond with:</p>
  <pre><samp translate=no>Yum yum! That was some good honey!</samp></pre>
 </body>
</html>
-->

				</section>
				<section id="the-dir-attribute">
<h4 title="The dir attribute">3.2.5.4. `dir^a 属性</h4>

<p>
`dir$a 属性は、要素の~text方向性を指定する。
この属性は`列挙~属性$であり，次の~keyword, 状態をとり得る：
◎
The dir attribute specifies the element's text directionality. The attribute is an enumerated attribute with the following keywords and states:
</p>

<dl>
	<dt>`ltr@v （ “left-to-right” ）</dt>
	<dd>
`~ltr@st
状態に対応付けられる。
◎
The ltr keyword, which maps to the ltr state
</dd>
	<dd>
要素の内容は、明示的に，左横書き~textとして方向的に隔離されることを指示する。
◎
Indicates that the contents of the element are explicitly directionally isolated left-to-right text.
</dd>

	<dt>`rtl@v （ “right-to-left” ）</dt>
	<dd>
`~rtl@st
状態に対応付けられる。
◎
The rtl keyword, which maps to the rtl state
</dd>
	<dd>
要素の内容は、明示的に，右横書き~textとして方向的に隔離されることを指示する。
◎
Indicates that the contents of the element are explicitly directionally isolated right-to-left text.
</dd>

	<dt>`auto@v</dt>
	<dd>
`自動@st
状態に対応付けられる。
◎
The auto keyword, which maps to the auto state
</dd>
	<dd>
要素の内容は、明示的に，方向的に隔離される~textであること、および
その方向は，当の要素の内容を利用して，（下に述べるように）~program的に決定されることを指示する。
◎
Indicates that the contents of the element are explicitly directionally isolated text, but that the direction is to be determined programmatically using the contents of the element (as described below).
</dd>
	<dd class="note">注記：
この状態の下で利用される経験則は、ごく荒削りなものである（それは、双向algoにおける Paragraph Level 決定に相似的な方式で，強い方向性†を持つ最初の文字を見るだけである）。
作者には、この値を当の~textの方向が，まったく未知で，適用できるより良い~server側~経験則もないときの，最後の~~手段としてのみ利用することが督促される。
`BIDI$r
◎
The heuristic used by this state is very crude (it just looks at the first character with a strong directionality, in a manner analogous to the Paragraph Level determination in the bidirectional algorithm). Authors are urged to only use this value as a last resort when the direction of the text is truly unknown and no better server-side heuristic can be applied. [BIDI]
</dd>
	<dd class="trans-note">【†
`双向-字種$の大分類が `Strong^uc に該当する文字。
概ね、文字~自身から，それを利用している~textの方向性を推定できるような文字
— ~Arabicのみに利用される文字であれば、右横書き，等々。
】</dd>
	<dd class="trans-note">【
この節に現れる
`双向-字種@
とは、 Unicode
<a href="http://unicode.org/reports/tr9/#Bidirectional_Character_Types">bidirectional character type</a>
を指す。
】</dd>

	<dd class="note">注記：
`textarea$e ／ `pre$e
要素に対しては、この経験則は，段落ごとの~levelで適用される。
◎
For textarea and pre elements, the heuristic is applied on a per-paragraph level.
</dd>

	<dt>属性の値は妥当でない場合</dt>
	<dt>要素はこの属性を有さない場合</dt>
	<dd>
この属性には、［
`妥当でない値に対する既定の状態$ ／ `値なしに対する既定の状態$
］はない。
◎
The attribute has no invalid value default and no missing value default.
</dd>
	<dd class="trans-note">【
以下を簡潔に記すため、この訳では，これらの場合は
`未定義@st
状態に対応付けられるものと定義する。
】</dd>
</dl>



<hr>

<p>
要素（`~HTML要素$でない要素も含む） %要素 の
`方向性@
は、［
`~ltr@,
`~rtl@
］のいずれかであり、は、次の手続きに従って決定される：
◎
The directionality of an element (any element, not just an HTML element) is either 'ltr' or 'rtl', and is determined as per the first appropriate set of steps from the following list:
</p>

<ol>
	<li>
%状態 ~LET %要素 の `dir$a 属性の状態
</li>
	<li>
~IF［
%状態 ~EQ `~ltr$st
］
⇒
~RET `~ltr$
◎
If the element's dir attribute is in the ltr state
• ↓
</li>
	<li>
<p >
~IF［
%状態 ~EQ `未定義$st
］~AND［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
%要素 は`文書~要素$である
</li>
			<li>
［
%要素 は `input$e 要素である
］~AND［
%要素 の `type$a 属性の状態 ~EQ `Telephone$st
］
</li>

		</ul>
<p>
…ならば
⇒
~RET `~ltr$
◎
If the element is a document element and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
◎
If the element is an input element whose type attribute is in the Telephone state, and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
◎
• The directionality of the element is 'ltr'.
</p>

	</li>
	<li>
~IF［
%状態 ~EQ `~rtl$st
］
⇒
~RET `~rtl$
◎
If the element's dir attribute is in the rtl state
• The directionality of the element is 'rtl'.
</li>
	<li>
<p >
~IF［
%状態 ~EQ `自動$st
］~AND［
次のいずれかが満たされる
］…：
◎
↓</p>

		<ul>
			<li>
［
%要素 は `input$e 要素である
］~AND［
%要素 の `type$a 属性の状態 ~IN {
`Text$st,
`Search$st,
`Telephone$st,
`URL$st,
`E-mail$st
}
］
◎
If the element is an input element whose type attribute is in the Text, Search, Telephone, URL, or E-mail state, and the dir attribute is in the auto state
</li>
			<li>
%要素 は `textarea$e 要素である
◎
If the element is a textarea element and the dir attribute is in the auto state
</li>
		</ul>
<p>
…ならば：
</p>

		<ol>
			<li>
%文字列 ~LET %要素 の`値$x
◎
↓</li>
			<li>
~IF［
%文字列 内に［
`双向-字種$ ~IN
{ `L^uc, `AL^uc, `R^uc }
］なる文字がある `BIDI$r
］
⇒
~IF［
そのような最初の文字の`双向-字種$ ~NEQ `L^uc
］
⇒
~RET `~rtl$
◎
If the element's value contains a character of bidirectional character type AL or R, and there is no character of bidirectional character type L anywhere before it in the element's value, then the directionality of the element is 'rtl'. [BIDI]
</li>
			<li>
~IF［
%文字列 ~NEQ 空~文字列
］~OR［
%要素 は`文書~要素$である
］
⇒
~RET `~ltr$
◎
Otherwise, if the element's value is not the empty string, or if the element is a document element, the directionality of the element is 'ltr'.
</li>
			<li>
~RET %要素 の親~要素の`方向性$
◎
Otherwise, the directionality of the element is the same as the element's parent element's directionality.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

		<ul>
			<li>
%状態 ~EQ `自動$st
◎
If the element's dir attribute is in the auto state
</li>
			<li>
［
%状態 ~EQ `未定義$st
］~AND［
%要素 は `bdi$e 要素である
］
◎
If the element is a bdi element and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
</li>
		</ul>
<p>
…ならば：
</p>

		<ol>
			<li>
<p>
%文字 ~LET 次のいずれも満たすような`木~順序$xで最初の文字：
◎
Find the first character in tree order that matches the following criteria:
</p>
				<ul>
					<li>
%文字 は［
%要素 のある子孫 `Text$I ~node %T
］内にある
◎
The character is from a Text node that is a descendant of the element whose directionality is being determined.
</li>
					<li>
%文字 の`双向-字種$ ~IN { `L^uc, `AL^uc, `R^uc }
`BIDI$r
◎
The character is of bidirectional character type L, AL, or R. [BIDI]
</li>

					<li>
<p>
%T の先祖であって, %要素 の子孫でもある，どの要素も：
◎
The character is not in a Text node that has an ancestor element that is a descendant of the element whose directionality is being determined and that is either:
</p>

						<ul>
							<li>
［
`bdi$e ／ `script$e ／ `style$e ／ `textarea$e
］要素でない, かつ
◎
• A bdi element.
• A script element.
• A style element.
• A textarea element.
</li>
							<li>
その `dir$a 属性の状態 ~EQ `未定義$st
◎
An element with a dir attribute in a defined state.
</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
~IF［
そのような %文字 はある
］
⇒
~RET %文字 の`双向-字種$ に応じて
⇒
`AL^uc, `R^uc ならば `~rtl$ ／
`L^uc ならば `~ltr$
◎
If such a character is found and it is of bidirectional character type AL or R, the directionality of the element is 'rtl'.

◎
If such a character is found and it is of bidirectional character type L, the directionality of the element is 'ltr'.
</li>

			<li>
~IF［
%要素 は`文書~要素$である
］
⇒
~RET `~ltr$
◎
Otherwise, if the element is a document element, the directionality of the element is 'ltr'.
</li>

			<li>
~RET %要素 の親~要素の`方向性$
◎
Otherwise, the directionality of the element the same as the element's parent element's directionality.
</li>

		</ol>
	</li>

	<li>
~ELSE（ %状態 ~EQ `未定義$st ~AND %要素 には親~要素がある）
⇒
~RET %要素 の親~要素の`方向性$
◎
If the element has a parent element and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
• The directionality of the element is the same as the element's parent element's directionality.
</li>

</ol>

<p class="note">注記：
`dir$a 属性は`~HTML要素$に対してのみ定義されているので、他の名前空間に属する要素は，それを有することはなく，自身の`方向性$を，親~要素から継承するか, 親がなければ既定の`~ltr$になる。
◎
Since the dir attribute is only defined for HTML elements, it cannot be present on elements from other namespaces. Thus, elements from other namespaces always just inherit their directionality from their parent element, or, if they don't have one, default to 'ltr'.
</p>

<p class="note">注記：
この属性には、
<a href="#bidireq">双向algoを孕むような具現化~要件が課される</a>。
◎
This attribute has rendering requirements involving the bidirectional algorithm.
</p>

<hr>

<p>
`~HTML要素$ %要素 の
`属性の方向性@
は、その属性 %属性 の~textが ある方式で具現化されるときに利用され，次の手続きにより決定される：
◎
The directionality of an attribute of an HTML element, which is used when the text of that attribute is to be included in the rendering in some manner, is determined as per the first appropriate set of steps from the following list:
</p>

<ol>
	<li>
<p>
~IF［
%属性 は`方向性有りの属性$である
］~AND［
%要素 の `dir$a 属性の状態 ~EQ `自動$st
］：
◎
If the attribute is a directionality-capable attribute and the element's dir attribute is in the auto state
</p>
		<ol>
			<li>
~IF［
%属性 の値~内に，［
`双向-字種$ ~IN { `L^uc, `AL^uc, `R^uc }
］なる文字がある
］］
⇒
~IF［［
そのような文字のうち，（論理的~順序で）最初の文字
］の`双向-字種$ ~NEQ `L^uc
］
⇒
~RET `~rtl$
`BIDI$r
◎
Find the first character (in logical order) of the attribute's value that is of bidirectional character type L, AL, or R. [BIDI]
◎
If such a character is found and it is of bidirectional character type AL or R, the directionality of the attribute is 'rtl'.
</li>
			<li>
~RET `~ltr$
◎
Otherwise, the directionality of the attribute is 'ltr'.
</li>
		</ol>
	</li>

	<li>
~RET %要素 の`方向性$
◎
Otherwise
◎
The directionality of the attribute is the same as the element's directionality.
</li>
</ol>


<div class="p">
<p>
次の表の左列に挙げる要素~上の，同じ行の右列に挙げる属性は、
`方向性有りの属性@
とされる：
</p>

<table>
<thead><tr><th>要素
</th><th>内容~属性
</th></thead>

<tbody>
<tr><td>`th$e
<td>`th.abbr$a

<tr><td>`area$e
<td>`area.alt$a

<tr><td>`img$e
<td>`img.alt$a

<tr><td>`input$e
<td>`input.alt$a

<tr><td>`meta$e
<td>`meta.content$a†

<tr><td>`menuitem$e
<td>`menuitem.label$a

<tr><td>`menu$e
<td>`menu.label$a

<tr><td>`optgroup$e
<td>`optgroup.label$a

<tr><td>`option$e
<td>`option.label$a

<tr><td>`track$e
<td>`track.label$a

<tr><td>`input$e
<td>`input.placeholder$a

<tr><td>`textarea$e
<td>`textarea.placeholder$a

<tr><td>すべての`~HTML要素$
<td>`title$a

</tbody></table>

<p>†
要素~上の `meta.name$a 属性が~metadata名を指定していて，その値は 機械からではなく人から読まれる用途が第一に意図されている場合に限る。
</p>

◎
The following attributes are directionality-capable attributes:
・ abbr on th elements
・ alt on area, img, and input elements
・ content on meta elements, if the name attribute specifies a metadata name whose value is primarily intended to be human-readable rather than machine-readable
・ label on menuitem, menu, optgroup, option, and track elements
・ placeholder on input and textarea elements
・ title on all HTML elements 
</div>


<hr>

<dl class="domintro">
	<dt>%document . `dir$m [ = %value ]</dt>
	<dd>
`~html0要素$があって，その `dir$a 属性を有するならば、その値を返す。
◎
Returns the html element's dir attribute's value, if any.
</dd>
	<dd>
設定して，`~html0要素$ の `dir$a 属性の値を［
`ltr^l, `rtl^l, `auto^l
］のいずれかに置換できる。
◎
Can be set, to either "ltr", "rtl", or "auto" to replace the html element's dir attribute's value.
</dd>
	<dd>
`~html0要素$がなければ，
空~文字列を返す ／
新たな値は無視する。
◎
If there is no html element, returns the empty string and ignores new values.
</dd>

</dl>

<p>
要素~上の
`dir@m
~IDL属性は、此れの `dir$a 内容~属性を，`既知の値のみに制限される$下で`反映-$し~MUST。
◎
The dir IDL attribute on an element must reflect the dir content attribute of that element, limited to only known values.
</p>

<div class="p">
<p>
`文書$上の
`~document-dir@m
~IDL属性は：
</p>

<ul>
	<li>
被取得時には、此れの`~html0要素$ %要素 ~EQ ~NULL ならば、空~文字列を返さ~MUST。
~ELSE_ %要素 の `dir$a 内容~属性を，`既知の値のみに制限される$下で`反映-$し~MUST。
</li>
	<li>
被設定時には，何もしては~MUST_NOT。
</li>
</ul>

◎
The dir IDL attribute on Document objects must reflect the dir content attribute of the html element, if any, limited to only known values. If there is no such element, then the attribute must return the empty string and do nothing on setting.
</div>

<p class="note">注記：
作者には、~text方向を指示するときは，~CSSを利用するのではなく， `dir$a 属性を利用することが強く奨励される。
その仕方であれば、~CSSが不在のときでも（例： 検索~engineに解釈されるとき），文書は正しく具現化し続けられるようになるので。
◎
Authors are strongly encouraged to use the dir attribute to indicate text direction rather than using CSS, since that way their documents will continue to render correctly even in the absence of CSS (e.g. as interpreted by search engines).
</p>

<div class="example">

<p>
この~markup片は、 Instant messaging による会話のものである：
◎
This markup fragment is of an IM conversation.
</p>

<pre>
&lt;p dir=auto class="u1"&gt;&lt;b&gt;&lt;bdi&gt;Student&lt;/bdi&gt;:&lt;/b&gt; How do you write "What's your name?" in Arabic?&lt;/p&gt;
&lt;p dir=auto class="u2"&gt;&lt;b&gt;&lt;bdi&gt;Teacher&lt;/bdi&gt;:&lt;/b&gt; ما اسمك؟&lt;/p&gt;
&lt;p dir=auto class="u1"&gt;&lt;b&gt;&lt;bdi&gt;Student&lt;/bdi&gt;:&lt;/b&gt; Thanks.&lt;/p&gt;
&lt;p dir=auto class="u2"&gt;&lt;b&gt;&lt;bdi&gt;Teacher&lt;/bdi&gt;:&lt;/b&gt; That's written "شكرًا".&lt;/p&gt;
&lt;p dir=auto class="u2"&gt;&lt;b&gt;&lt;bdi&gt;Teacher&lt;/bdi&gt;:&lt;/b&gt; Do you know how to write "Please"?&lt;/p&gt;
&lt;p dir=auto class="u1"&gt;&lt;b&gt;&lt;bdi&gt;Student&lt;/bdi&gt;:&lt;/b&gt; "من فضلك", right?&lt;/p&gt;
</pre>



<p>
`p$e 要素に対し，相応しい~stylesheet, および 既定の整列~style
— すなわち，~textを段落の始端辺に整列する —
が与えられた下では、結果の描画は次のようにもなる：
◎
Given a suitable style sheet and the default alignment styles for the p element, namely to align the text to the start edge of the paragraph, the resulting rendering could be as follows:
</p>

<div style="min-height: 157px;"><img
	src="HTML-dom/im.png"
	alt="各~段落は，別々の~blockとして描画され、二番目と最後の段落は右寄せに，他は左寄せにされる。各~段落の先頭の利用者名（この例では 'Student' , 'Teacher' ）は、右寄せの段落では右端に接合され, その左に~colon, その左に~textが来る。／ Each paragraph rendered as a separate block, with the paragraphs left-aligned except the second paragraph and the last one, which would  be right aligned, with the usernames ('Student' and 'Teacher' in this example) flush right, with a colon to their left, and the text first to the left of that."
	height="157" width="366"
></div>

<p>
先に注記したように， `dir.auto$a 値は万能ではない。
この例における~~最後の段落は，~Arabic文字から始まるので、右横書き~textに誤解釈され， "right?" を~Arabic~textの左側に置く。
◎
As noted earlier, the auto value is not a panacea. The final paragraph in this example is misinterpreted as being right-to-left text, since it begins with an Arabic character, which causes the "right?" to be to the left of the Arabic text.
</p>
</div>


				</section>
				<section id="the-style-attribute">
<h4 title="The style attribute">3.2.5.5. `style^a 属性</h4>

<p>
`style$a 内容~属性はすべての`~HTML要素$に設定できる。
これは、
CSS Styling Attribute Syntax `CSSATTR$r
仕様に定義される，`~CSS~styling属性$xである。
◎
All HTML elements may have the style content attribute set. This is a CSS styling attribute as defined by the CSS Styling Attribute Syntax specification. [CSSATTR]
</p>

<p>
~CSSを~supportする~UAは：
</p>

<ul>
	<li>
`要素$x %要素 に この属性が追加された, あるいは その値が変更されたときには、`~CSS~styling属性$xに課される規則に則って，属性の値を構文解析し~MUST。
`CSSATTR$r
◎
In user agents that support CSS, the attribute's value must be parsed when the attribute is added or has its value changed, according to the rules given for CSS styling attributes. [CSSATTR]
</li>
	<li>
ただし，［
( %要素, `style attribute^l, 属性の値 )
を与える下で，［
`要素の~inline挙動は~CSPにより阻止されるべきか？$xを実行した結果
］ ~EQ `~Blocked^i
］になる場合、この属性の値により定義される~style規則を %要素 に適用しては~MUST_NOT。
`CSP$r
◎
However, if the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the attribute's element, "style attribute", and the attribute's value, then the style rules defined in the attribute's value must not be applied to the element. [CSP]

 and "style attribute", 
</li>
</ul>

<p>
要素~上で `style$a 属性を利用する文書は、それらの属性が除去されても，依然として理解でき, 利用でき~MUST。
◎
Documents that use style attributes on any of their elements must still be comprehensible and usable if those attributes were removed.
</p>

<p class="note">注記：
特に， `style$a 属性を利用して内容を隠す／示す, あるいは［
さもなければ文書~内に含まれないような意味を伝達する
］ものは、適合でない。
（内容を隠す／示すときは、 `hidden$a 属性を利用せよ。）
◎
In particular, using the style attribute to hide and show content, or to convey meaning that is otherwise not included in the document, is non-conforming. (To hide and show content, use the hidden attribute.)
</p>

<hr>

<dl class="domintro">
	<dt>%element . `style$m</dt>
	<dd>
要素の `style$a 属性に対する
`CSSStyleDeclaration$I ~objを返す。
◎
Returns a CSSStyleDeclaration object for the element's style attribute.
</dd>

</dl>

<p>
`style@m
~IDL属性は、 CSSOM（ CSS Object Model ）仕様 `CSSOM$r に定義される。
◎
The style IDL attribute is defined in the CSS Object Model (CSSOM) specification. [CSSOM]
</p>

<div class="example">

<p>
次の例では、色を指す単語が，視覚的~媒体において関連の色で示されるようにするため、 `span$e 要素と `style$a 属性を利用して~mark-upされている：
◎
In the following example, the words that refer to colours are marked up using the span element and the style attribute to make those words show up in the relevant colours in visual media.
</p>

<pre>
&lt;p&gt;私の服は&lt;span style="color: green; background:
transparent"&gt;緑色&lt;/span&gt;で、目は&lt;span style="color: blue;
background: transparent"&gt;青色&lt;/span&gt;です。&lt;/p&gt;
</pre>

<!-- 
My sweat suit is green and my eyes are blue
 -->

</div>


				</section>
				<section id="embedding-custom-non-visible-data-with-the-data-*-attributes">

<h4 title="Embedding custom non-visible data with the data-* attributes">3.2.5.6. `data-*^a 属性による~custom不可視~dataの埋込み</h4>


<div class="p">
<p>
`~custom~data属性@
は、どの名前空間にも属さない属性であって，その名前が次のいずれも満たすものである：
</p>

<ul><li>文字列
"`data-@a"
で開始される
<li>`data-^l の後に 1 個以上の文字がある
<li>`~XML互換$である
<li>`~ASCII大文字$を包含しない
</ul>

◎
A custom data attribute is an attribute in no namespace whose name starts with the string "data-", has at least one character after the hyphen, is XML-compatible, and contains no uppercase ASCII letters.
</div>

<p class="note">注記：
`~HTML文書$xにおいては、`~HTML要素$上のすべての属性~名は 自動的に~ASCII小文字~化されるので，~ASCII大文字の制約は影響しない。
◎
All attribute names on HTML elements in HTML documents get ASCII-lowercased automatically, so the restriction on ASCII uppercase letters doesn't affect such documents.
</p>

<p>
`~custom~data属性$は、適切な属性や要素が無いような，［
頁／~app
］に私的な~custom~dataを格納するために意図されている。
◎
Custom data attributes are intended to store custom data private to the page or application, for which there are no more appropriate attributes or elements.
</p>

<p>
これらの属性は、それを利用する~siteの管理者に既知でない~software用途に意図されるものではない。
複数の独立な~tool用途の汎的~拡張のためには、この仕様が拡張されて，その種の特色機能が明示的に提供されるようになるか，または
`~microdata$x の様な（標準化された語彙を伴う）技術が利用されるべきである。
◎
These attributes are not intended for use by software that is not known to the administrators of the site that uses the attributes. For generic extensions that are to be used by multiple independent tools, either this specification should be extended to provide the feature explicitly, or a technology like microdata should be used (with a standardised vocabulary).
</p>

<div class="example">

<p>
具体例として，音楽~siteは、~album内の各~曲を表現する一連の~list~itemに，曲の長さを包含する~custom~data属性で注釈することもできる。
~site自身は、この情報を，［
利用者が~listを曲の長さで整列したり，~listをある長さの曲に~filterできる
］ようにする用途に利用できる。
◎
For instance, a site about music could annotate list items representing tracks in an album with custom data attributes containing the length of each track. This information could then be used by the site itself to allow the user to sort the list by track length, or to filter the list for tracks of certain lengths.
</p>

<pre>
&lt;ol&gt;
 &lt;li data-length="2m11s"&gt;海の彼方に&lt;/li&gt;
 ...
&lt;/ol&gt;
</pre>

<!-- Beyond The Sea -->

<p>
しかしながら，利用者がその音楽~siteに結付けられてない汎的~softwareを利用して，この~dataに基づいて，ある長さの曲を検索するような用途は、適切でなくなる。
◎
It would be inappropriate, however, for the user to use generic software not associated with that music site to search for tracks of a certain length by looking at this data.
</p>

<p>
これらの属性は、公共用途の~metadataのための汎的な拡張の仕組みでなく，~siteの自前の~script用途に意図されているので。
◎
This is because these attributes are intended for use by the site's own scripts, and are not a generic extension mechanism for publicly-usable metadata.
</p>

</div>


<div class="example">

<p>
同様に，頁~作者は、利用を意図する翻訳~tool用の情報を提供する~markupを書くこともある：
◎
Similarly, a page author could write markup that provides information for a translation tool that they are intending to use:
</p>

<pre>
&lt;p&gt;The third &lt;span data-mytrans-de="Anspruch"&gt;claim&lt;/span&gt; covers the case of &lt;span
translate="no"&gt;HTML&lt;/span&gt; markup.&lt;/p&gt;
</pre>

<p>
この例では、 `data-mytrans-de^l 属性は、句 "claim" を~Germanに翻訳するときに，利用する MyTrans 製品に特有の~textを与えている。
しかしながら，標準の `translate$a 属性がすべての言語にわたり，それを伝えるために利用される
— “HTML” は変えないまま。
標準の属性が可用なときは、`~custom~data属性$を利用する必要はない。
◎
In this example, the "data-mytrans-de" attribute gives specific text for the MyTrans product to use when translating the phrase "claim" to German. However, the standard translate attribute is used to tell it that in all languages, "HTML" is to remain unchanged. When a standard attribute is available, there is no need for a custom data attribute to be used.
</p>

</div>

<p>
`~custom~data属性$は、どの`~HTML要素$にも，いくつでも，どの値にも指定できる。
◎
Every HTML element may have any number of custom data attributes specified, with any value.
</p>

<hr>

<dl class="domintro">

	<dt>%element . `dataset$m</dt>
	<dd>
要素~上の一連の `data-*$a 属性に対する簡便な~accessorを
`DOMStringMap$I ~objとして返す。
◎
Returns a DOMStringMap object for the element's data-* attributes.
</dd>
	<dd>
~hyphenateされた名前は、~camel-case化される。
例えば、
`data-foo-bar=""^a
は、
%element`.dataset.fooBar^c
になる。
◎
Hyphenated names become camel-cased. For example, data-foo-bar="" becomes element.dataset.fooBar.
</dd>
</dl>

<p>
`dataset@m
~IDL属性の被取得時には、此れ上の `data-*$a 属性を公開するような，［
次の各種~algoが結付けられた `DOMStringMap$I ~obj
］を返さ~MUST：
◎
The dataset IDL attribute provides convenient accessors for all the data-* attributes on an element. On getting, the dataset IDL attribute must return a DOMStringMap object, associated with the following algorithms, which expose these attributes on their element:
</p>

<dl>
	<dt>
`名値~pairの~listを取得-$する~algo：
◎
The algorithm for getting the list of name-value pairs
</dt>
	<dd>
		<ol>
			<li>
%~list ~LET 空~list
◎
Let list be an empty list of name-value pairs.
</li>
	<li>
<p>
此れの`属性~list$x内の ~EACH ( 内容~属性 %属性 ) に対し，順に
</p>

		<ol>
			<li>
%名前 ~LET %属性 の名前
</li>
			<li>
~IF［
%属性 の名前の最初の 5 文字 ~NEQ `data-^l
］
⇒
~CONTINUE
</li>
			<li>
%名前 ~LET %名前 から最初の 5 文字を除去した結果
</li>
			<li>
~IF［
%名前 内に`~ASCII大文字$がある
］
⇒
~CONTINUE
</li>
			<li>
%名前 ~SET %名前 の中の各［
❝-, `~ASCII小文字$ %C
］並びを［
%C を`~ASCII大文字~化$した結果
］に置換した結果
</li>
			<li>
名値~pair
( %名前, %属性 の値 )
を %~list に追加する
</li>
		</ol>

◎
For each content attribute on the element whose first five characters are the string "data-" and whose remaining characters (if any) do not include any uppercase ASCII letters, in the order that those attributes are listed in the element's attribute list, add a name-value pair to list whose name is the attribute's name with the first five characters removed and whose value is the attribute's value.
◎
For each name in list, for each U+002D HYPHEN-MINUS character (-) in the name that is followed by a lowercase ASCII letter, remove the U+002D HYPHEN-MINUS character (-) and replace the character that followed it by the same character converted to ASCII uppercase.
</li>
			<li>
~RET %~list
◎
Return list.
</li>
		</ol>
	</dd>

	<dt>
所与の`名前に対応する値を設定-$する~algo：
◎
The algorithm for setting names to certain values
</dt>
	<dd>
		<ol>
			<li>
( %名前, %値 ) ~LET 所与の ( 名前, 値 )
◎
Let name be the name passed to the algorithm.
◎
Let value be the value passed to the algorithm.
</li>
			<li>
~IF［
%名前 内に［
❝-, `~ASCII小文字$
］並びがある
］
⇒
~THROW `SyntaxError$E
◎
If name contains a U+002D HYPHEN-MINUS character (-) followed by a lowercase ASCII letter, throw a SyntaxError exception and abort these steps.
</li>
			<li>
%名前 ~SET %名前 内の各`~ASCII大文字$ %C を［
❝-,
%C を`~ASCII小文字~化$した結果
］並びに置換した結果
◎
For each uppercase ASCII letter in name, insert a U+002D HYPHEN-MINUS character (-) before the character and replace the character with the same character converted to ASCII lowercase.
</li>
	<li>
%名前 ~SET %名前 の先頭に文字列 `data-^l を挿入した結果
◎
Insert the string data- at the front of name.
</li>
			<li>
<p >
此れ上の名前 %名前 の属性の値 ~SET %値
— ここで：
</p>

<ul >
<li>必要なら此れ上に属性を作成する。
<li>%名前 を引数に，此れ上の `setAttribute()^m を呼んだときに例外が投出される場合は、同じ例外を投出し~MUST。
</ul>

◎
Set the value of the attribute with the name name, to the value value, replacing any previous value if the attribute already existed. If setAttribute() would have thrown an exception when setting an attribute with the name name, then this must throw the same exception.
</li>
		</ol>
	</dd>
	<dt>
所与の %名前 に`対応する名値~pairを削除-$する~algo：
◎
The algorithm for deleting names
</dt>
	<dd>
		<ol>
			<li>
%名前 ~SET %名前 内の各`~ASCII大文字$ %C を［
❝-,
%C を`~ASCII小文字~化$した結果
］並びに置換した結果
◎
Let name be the name passed to the algorithm.
◎
For each uppercase ASCII letter in name, insert a U+002D HYPHEN-MINUS character (-) before the character and replace the character with the same character converted to ASCII lowercase.
</li>
			<li>
%名前 ~SET %名前 の先頭に文字列 `data-^l を挿入した結果
◎
Insert the string data- at the front of name.
</li>
			<li>
~IF［
此れは［
名前 ~EQ %名前
］なる属性を有する
］
⇒
要素から，それを除去する
◎
Remove the attribute with the name name, if such an attribute exists. Do nothing otherwise.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
この~algoは、［［
先掲の`名値~pairの~listを取得-$する~algo
］で与えられる名前
］を取得するために限って、 `WEBIDL$r 仕様から呼出される。
◎
This algorithm will only get invoked by the Web IDL specification for names that are given by the earlier algorithm for getting the list of name-value pairs. [WEBIDL]
</dd>

</dl>


<div class="example">
<p>
~gameの一部として， `data-*$a 属性とともに `class$a 属性も利用する~Web頁の例：
◎
If a Web page wanted an element to represent a space ship, e.g. as part of a game, it would have to use the class attribute along with data-* attributes:
</p>

<pre>
&lt;div class="spaceship"
     data-ship-id="92432"
     data-weapons="laser 2"
     data-shields="50%"
     data-x="30"
     data-y="10"
     data-z="90"
&gt;
 &lt;button class="fire"
     onclick="spaceships[this.parentNode.dataset.shipId].fire()"
 &gt;撃つ&lt;/button&gt;
&lt;/div&gt;
</pre>

<p>
~hyphenateされた属性~名は，~APIにおいては~camel-case化されることに注意。
◎
Notice how the hyphenated attribute name becomes camel-cased in the API.
</p>

</div>

<p>
作者は、そのような拡張を注意深く設計するべきである
— 当の属性が無視され，~CSSも~~無効にされても、頁は依然として利用できるように。
◎
Authors should carefully design such extensions so that when the attributes are ignored and any associated CSS dropped, the page is still usable.
</p>

<p>
~UAは、これらの属性や値から，どのような実装の挙動も導出しては~MUST_NOT。
~UA用に意図される仕様は、これらの属性がとる値にどのような意味も定義しては~MUST_NOT。
◎
User agents must not derive any implementation behaviour from these attributes or values. Specifications intended for user agents must not define these attributes to have any meaningful values.
</p>

<p>
JavaScript ~libraryは、それを利用している頁の一部と見なされるので，`~custom~data属性$を利用してよい。
多くの作者から再利用される~libraryの作者には、属性~名に何らかの~~固有の文字列を含ませて，衝突の~riskを抑制することが奨励される。
~library作者には、そうすることに~~意味があるなら，属性~名に利用される正確な名前を~customizeできるようにすることも奨励される
— そうすれば、~library作者が選んだ名前が 頁に利用され得る~~未知の名前と同じになるときでも，~libraryを利用でき、また，特定0の~libraryの複数の~versionどうしが互換でないときでも，同じ頁に利用できるようになるので。
◎
JavaScript libraries may use the custom data attributes, as they are considered to be part of the page on which they are used. Authors of libraries that are reused by many authors are encouraged to include their name in the attribute names, to reduce the risk of clashes. Where it makes sense, library authors are also encouraged to make the exact name used in the attribute names customizable, so that libraries whose authors unknowingly picked the same name can be used on the same page, and so that multiple versions of a particular library can be used on the same page even when those versions are not mutually compatible.
</p>

<div class="example">

<p>
例えば、 "DoQuery" ~libraryが利用する属性~名は `data-doquery-range^a の様にする一方で， "jJo" ~libraryは `data-jjo-range^a にすることが~~想定される。
~libraryは、利用する接頭辞を設定する~APIを提供することもできる（例：
`jJo.setDataPrefix('j2')^c のように，属性~名を `data-j2-range^a の様な名前にするものなど）。
◎
For example, a library called "DoQuery" could use attribute names like data-doquery-range, and a library called "jJo" could use attributes names like data-jjo-range. The jJo library could also provide an API to set which prefix to use (e.g. J.setDataPrefix('j2'), making the attributes have names like data-j2-range).
</p>

</div>


				</section>
			</section>
			<section id="requirements-relating-to-the-bidirectional-algorithm">
<h3 title="Requirements relating to the bidirectional algorithm">3.2.6. 双向algoに関係する要件</h3>

				<section id="authoring-conformance-criteria-for-bidirectional-algorithm-formatting-characters">
<h4 title="Authoring conformance criteria for bidirectional-algorithm formatting characters">3.2.6.1. 双向algo整形~文字に対する著作~適合性の判定基準</h4>


<div class="p">
<p>
`~HTML要素$における，［
`~text内容$
— `Text$I ~nodeを含むような`内容$
］／［
自由形式の~textを許容するような属性~内の~text
］は、範囲［
U+202A 〜 U+202E, U+2066 〜 U+2069
］（双向algo整形~文字）に入る文字を包含してもよいが、これらの文字の利用は，それにより生成されるどの双向-［
埋込み／上書き
］も 次を満たすように制約される：
</p>

<ul>
	<li>
ある要素~内から開始して，別の要素~内で終端0することはない。
</li>
	<li>
明示的に［
U+202C POP DIRECTIONAL FORMATTING 文字
］で終端される。
</li>
</ul>

<p>
これは、~textが，双向algoにおける不測の効果をもたらす方式で再利用される事故を抑制し易くするためである。
`BIDI$r
</p>
◎
Text content in HTML elements with Text nodes in their contents, and text in attributes of HTML elements that allow free-form text, may contain characters in the ranges U+202A to U+202E and U+2066 to U+2069 (the bidirectional-algorithm formatting characters). However, the use of these characters is restricted so that any embedding or overrides generated by these characters do not start and end with different parent elements, and so that all such embeddings and overrides are explicitly terminated by a U+202C POP DIRECTIONAL FORMATTING character. This helps reduce incidences of text being reused in a manner that has unforeseen effects on the bidirectional algorithm. [BIDI]
</div>

<p>
前述の制約は、［
文書の一定の部分が`双向algo整形~文字~範囲$を形成する
］ものと指定した上で，［
そのような範囲に要件を課す
］ことを通して，定義される：
◎
The aforementioned restrictions are defined by specifying that certain parts of documents form bidirectional-algorithm formatting character ranges, and then imposing a requirement on such ranges.
</p>


<p>
`~HTML要素$ %要素 に対し，次の~algoを適用して得られる文字列の~listは、`双向algo整形~文字~範囲$を成す：
◎
The strings resulting from applying the following algorithm to an HTML element element are bidirectional-algorithm formatting character ranges:
</p>

<ol>

	<li>
%出力 ~LET 空~list
◎
Let output be an empty list of strings.
</li>
	<li>
%文字列 ~LET 空~文字列
◎
Let string be an empty string.
</li>
	<li>
%~node ~LET %要素 に子~nodeが［
あれば それらのうち最初のもの ／
なければ ~NULL
］
◎
Let node be the first child node of element, if any, or null otherwise.
</li>
	<li>
<p>
~WHILE %~node ~NEQ ~NULL
：
◎
Loop: If node is null, jump to the step labeled end.
• Process node according to the first matching step from the following list:
</p>

		<ol>
			<li>
~IF［
%~node は `Text$I ~nodeである
］
⇒
%文字列 に%~node の~text~dataを付加する
◎
If node is a Text node
• Append the text data of node to string.
</li>
			<li>
<p>
~ELIF［
%文字列 ~NEQ 空~文字列
］~AND［
%~node は、次のいずれかを満たす
］
</p>
				<ul>
					<li>
`br$e 要素である
◎
If node is a br element
</li>
					<li>
［
`~HTML要素$である
］~AND［
`~flow内容$である
］~AND［
`句内容$でない
］
◎
If node is an HTML element that is flow content but that is not also phrasing content
</li>
				</ul>
<p>
ならば：
</p>
				<ol>
					<li>
%出力 に %文字列 を~~追加する
</li>
					<li>
%文字列 ~SET 空~文字列
◎
If string is not the empty string, push string onto output, and let string be empty string.
◎
Otherwise
• Do nothing.
</li>
				</ol>
			</li>
			<li>
%~node ~SET %~node の次の同胞が［
あれば それ ／
なければ ~NULL
］
◎
Let node be node's next sibling, if any, or null otherwise.
◎
Jump to the step labeled loop.
</li>
		</ol>
	</li>

	<li>
~IF［
%文字列 ~NEQ 空~文字列
］
⇒
%出力 に %文字列 を~~追加する
◎
End: If string is not the empty string, push string onto output.
</li>
	<li>
~RET %出力
◎
Return output as the bidirectional-algorithm formatting character ranges.
</li>

</ol>

<p>
`~HTML要素$が有する属性のうち，名前空間に属さないものの値は、`双向algo整形~文字~範囲$を成す。
◎
The value of a namespace-less attribute of an HTML element is a bidirectional-algorithm formatting character range.
</p>

<p>
上で述べた
`双向algo整形~文字~範囲@
を成す，どの文字列も、次の ABNF による `string^P 生成規則に合致し~MUST
— この ABNF の文字~集合は、~Unicodeとする。
`ABNF$r
◎
Any strings that, as described above, are bidirectional-algorithm formatting character ranges must match the string production in the following ABNF, the character set for which is Unicode. [ABNF]
</p>

<pre>
string        = *( plaintext ( embedding / override / isolation ) ) plaintext
embedding     = ( lre / rle ) string pdf
override      = ( lro / rlo ) string pdf
isolation     = ( lri / rli / fsi ) string pdi
lre           = `202A^0x ; U+202A LEFT-TO-RIGHT EMBEDDING
rle           = `202B^0x ; U+202B RIGHT-TO-LEFT EMBEDDING
lro           = `202D^0x ; U+202D LEFT-TO-RIGHT OVERRIDE
rlo           = `202E^0x ; U+202E RIGHT-TO-LEFT OVERRIDE
pdf           = `202C^0x ; U+202C POP DIRECTIONAL FORMATTING
lri           = `2066^0x ; U+2066 LEFT-TO-RIGHT ISOLATE
rli           = `2067^0x ; U+2067 RIGHT-TO-LEFT ISOLATE
fsi           = `2068^0x ; U+2068 FIRST STRONG ISOLATE
pdi           = `2069^0x ; U+2069 POP DIRECTIONAL ISOLATE
plaintext     = *( `0000-2029^0x / `202F-2065^0x / `206A-10FFFF^0x )
                ; <span class="comment">
双向algo整形~文字を含まない，~~任意の文字列
◎
; any string with no bidirectional-algorithm formatting characters
</span>
</pre>

<p class="note">注記：
U+2069 POP DIRECTIONAL ISOLATE 文字はまた，暗黙的に［
埋込みを開く／上書きを終端0させる
］が、そのような暗黙的な~~区切りに依拠する~textは，この仕様に適合しない。
この節の要件に適合するためには、すべての双向-［
埋込み, 上書き, 隔離
］文字列は，明示的に終端される必要がある。
◎
While the U+2069 POP DIRECTIONAL ISOLATE character implicitly also ends open embeddings and overrides, text that relies on this implicit scope closure is not conforming to this specification. All strings of embeddings, overrides, and isolations need to be explicitly terminated to conform to this section's requirements.
</p>

<p class="note">注記：
作者には、［
`dir$a 属性,
`bdo$e 要素,
`bdi$e 要素
］を利用することが奨励される
— 双向algo整形~文字を手動で維持管理するのでなく。
双向algo整形~文字は、~CSSに対する~~作用に乏しい。
◎
Authors are encouraged to use the dir attribute, the bdo element, and the bdi element, rather than maintaining the bidirectional-algorithm formatting characters manually. The bidirectional-algorithm formatting characters interact poorly with CSS.
</p>

				</section>
				<section id="user-agent-conformance-criteria">
<h4 title="User agent conformance criteria">3.2.6.2. ~UAに課される適合性~判定基準</h4>

<p>
~UAは、文書や その一部を具現化する際に，文字たちの適正な順序付けを決定するときには、~Unicode双向algoを実装し~MUST。
`BIDI$r
◎
User agents must implement the Unicode bidirectional algorithm to determine the proper ordering of characters when rendering documents and parts of documents. [BIDI]
</p>

<div class="p">
<p>
~UAは、~HTMLから~Unicode双向algoへの対応付けを，次のいずれかの仕方で行わ~MUST：
</p>

<ul>
	<li>
~CSS
— 特に，~CSS［
`unicode-bidi$p, `direction$p, `content$p
］~propを実装した上で、［
`具現化 節$xに与えられる，これらの~propを利用している規則
］を，自身の~UA~stylesheetに含める。
</li>
	<li>
前項であったかのように動作しつつ、文書に指定される~stylesheetには，それを上書きさせない。
</li>
	<li>
等価な意味論を伴うような別の~styling言語を実装する。
</li>
</ul>

`CSSWM$r `CSSGC$r
◎
The mapping of HTML to the Unicode bidirectional algorithm must be done in one of three ways. Either the user agent must implement CSS, including in particular the CSS 'unicode-bidi', 'direction', and 'content' properties, and must have, in its user agent style sheet, the rules using those properties given in this specification's rendering section, or, alternatively, the user agent must act as if it implemented just the aforementioned properties and had a user agent style sheet that included all the aforementioned rules, but without letting style sheets specified in documents override them, or, alternatively, the user agent must implement another styling language with equivalent semantics. [CSSWM] [CSSGC]
</div>


<p id="bidireq">
次の要素／属性には，`具現化 節$xにより定義される要件が課されるが、この節における要件に因り，すべての~UAに課される要件にもなる（
<a href="~HTMLCONFORM#renderingUA">推薦される既定の具現化を~supportする~UA</a>
のみならず）：
◎
The following elements and attributes have requirements defined by the rendering section that, due to the requirements in this section, are requirements on all user agents (not just those that support the suggested default rendering):
</p>

<div >
<ul><li>`dir$a 属性, および
<li>`bdi$e, `bdo$e, `br$e, `pre$e, `textarea$e, `wbr$e 要素
</ul>

◎
• dir attribute
• bdi element
• bdo element
• br element
• pre element
• textarea element
• wbr element
</div>


				</section>
			</section>
			<section id="wai-aria">
<h3 title="Requirements related to ARIA and to platform accessibility APIs">3.2.7. ARIA, および~platform~accessibility~APIに関係する要件</h3>

<p>
`~HTML要素$に対する Accessibility API の意味論を実装するにあたって，~UAに課される要件は、
<cite>HTML Accessibility API Mappings</cite>
にて定義される。
`HTMLAAM$r
◎
User agent requirements for implementing Accessibility API semantics on HTML elements are defined in HTML Accessibility API Mappings. [HTMLAAM]
</p>

<p>
`~HTML要素$上の ARIA ［
`role$a ／ `aria-*$a
］属性の利用を検査する適合性~検査器に課される要件は、
<cite>ARIA in HTML</cite>
にて定義される。
`ARIAHTML$r
◎
Conformance checker requirements for checking use of ARIA role and aria-* attributes on HTML elements are defined in ARIA in HTML. [ARIAHTML]
</p>

			</section>
		</section>
	</section>
</main>

