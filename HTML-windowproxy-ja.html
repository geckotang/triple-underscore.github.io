<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Loading Web pages（ 7.2, 7.4, 7.7.4 日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/browsers.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160707 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		E: 'error',
		sl: 'js-slot',
		jS: 'js-symbol',
		jI: 'js-intrinsic',
		jA: 'abstract',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		c: 'code',
		E: 'code',
		sl: 'span',
		jI: 'span',
		jS: 'span',
		jA: 'span',
		V: 'var',
		i: 'i',
		sub: 'sub',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var ctx_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[\w~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN', '_toc_list0');


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
//var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	if(indicator === '@') {
		ctx_ifc = '#dom-' + key.toLowerCase() + '-';
	}
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text += ':';
	break;
case 'et': // event type
	break;
case 'i': // model constants
	break;
case 'v': // variables
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'sl': // JS internal slot
	text = '[[' + key + ']]';
	break;
case 'jI': // JS intrinsic objects
	text = '%' + key + '%';
	break;
case 'jS': // JS well-known symbol
	text = '@@' + key;
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">


IDL:
JS:JavaScript
取得子:getter:~
設定子:setter:~

	●仕様
UA:user agent:UA
bug::::バグ
algo:algorithm:::アルゴリズム
不変則:invariant:~
意味-:mean:~
手続き:steps:~
挙動:behaviour:ふるまい
方式:manner:~
旧来の:legacy:~
概して:typically:~
	決して:never:~
	更なる:further:~
最適化:optimize:~
	optimization
違反-:violate:~
論点:discussion:~
統合:integration:~
comment::::コメント
custom::::カスタム
説明-:explain:~
	追加の:additional:~
logic::::ロジック
要求-:require:~
自前の:own:~
表現-:represent:~

	見よ:see:~
	異なる:different:~
	後続-／従う:follow:~
	後続の／従って:following:~
	必要-:need:~
	両者:both:~
	他の場合:otherwise:~
	この:this#3
	したがって:therefore#1
	すべての:all#1
	その:that#4
	それらの:those#1
	べき:should#1
	一部:part-of#2
	上:above#1
	例えば:for-example:~


	●未分類
Realm:
Record:
field::::フィールド
access::::アクセス
call:
collection::::コレクション
domain::::ドメイン
entry::::エントリ
exotic:
garbage::::ガーベジ
収集:collection::~
収集-:collect::~
検分-:inspect:~
整列-:sort:~
結付けら:associate さ:結び付けら
index:
key:
list::::リスト
map:
method::::メソッド
obj:object:::オブジェクト
pair::::ペア
遂行-:perform:~
platform::::プラットフォーム
prop:property:::プロパティ
script::::スクリプト
slot::::スロット
web:
	組:tuple
上書き:override:~
不在:absent:~
余分の:extra:~
作成-:create:~
例外:exception:~
保安:security:~
保持-:hold:~
値:value:~
入子に:nest:入れ子に
入子の:nested:入れ子の
共用:shared:~
内部:internal:~
	再び:again:~
初期:initial:~
包含-:contain:~
普通の:ordinary:~
包装-:wrap:~
匿名:anonymous:~
参照:reference:~
連結-:concatenate:~
	concatenation
可視の:visible:~
	同じ:same:~
名:name:~
名前:name:~
呼出:invocation:~
呼出した:invoke した:呼び出した
呼出され:invoke され:呼び出され
埋めら:fill さ:~
子:child:~

依存-:depend:~
取扱われ:handle され:取り扱われ
定義-:define:~
実装-:implement:~


実効:effective:~
容器:container:::コンテナ
	対応ing:corresponding:~
引数:argument:~

投出:throw:~
抽象:abstract:~
属性:attribute:~
挿入-:insert:~
	数:number:~
新たな:new:~
	過去の:earlier:~
再訪問:revisit:~
観測可能:observable:~
最後の:last:~
有名:named:~
未来:future:~
検査:check:~
演算:operation:~
現在の:current:~
生成元:origin::~::オリジン
直接的:direct:~
空:empty:~
自身:itself:~
要素:element:~
規則:rule:~
記述子:descriptor:~
設定-:set:~
設定群:settings:~
許容-:allow:~
	返す:return:~
追加-:add:~
	通:through:~

配列:array:~
関数:function:~
匿名:anonymous:~
組込み:built-in:~
関連する:relevant な:~
閲覧文脈:browsing context:~
除去-:remove:~
集合:set:~
非同一生成元:cross-origin:~
順序:order:~
session::::セッション
履歴:history::~
navi:navigation:::ナビ
navigate::::ナビゲート
interface::::インタフェース
target:
	記憶しておく:memoization
	後から:lazily
	あたられる:consult
近過去:recent:~
safelist:
excrescence:
scary:
post-creation:
	指し向けるindirecting
命名-:name:~
保安:security::~:セキュリティ
施策:policy::~:ポリシー

</script>


<script type="text/plain" id="_original_id_map">
</script>



<!--% 置換データ -->
<script type="text/plain" id="words_table1">
ES6:https://tc39.github.io/ecma262/
	https://html.spec.whatwg.org/multipage/infrastructure.html
NAVI:https://html.spec.whatwg.org/multipage/browsers.html


this:<span class="js-value">this</span>
true:<span class="js-value">true</span>
false:<span class="js-value">false</span>
undefined:<span class="js-value">undefined</span>
Foo:<var>Foo</var>
</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">

I.Document:~HTMLDOM#document
I.Location:~BROWSERS#location
I.Window:~BROWSERS#window
I.WindowProxy:#windowproxy

E.SecurityError:~WEBIDL#securityerror

m.document.domain:~BROWSERS#dom-document-domain

	●js
	jA.GetOwnProperty:#windowproxy-getownproperty
	jA.GetOwnProperty:#location-getownproperty

jA.CrossOriginGet:#crossoriginget-(-o,-p,-receiver-)
jA.CrossOriginGetOwnPropertyHelper:#crossorigingetownpropertyhelper-(-o,-p-)
jA.CrossOriginOwnPropertyKeys:#crossoriginownpropertykeys-(-o-)
jA.CrossOriginProperties:#crossoriginproperties-(-o-)
jA.CrossOriginSet:#crossoriginset-(-o,-p,-v,-receiver-)
jA.IsPlatformObjectSameOrigin:#isplatformobjectsameorigin-(-o-)

jA.Call:~ES6#sec-call
jA.IsAccessorDescriptor:~ES6#sec-isaccessordescriptor
jA.IsCallable:~ES6#sec-iscallable
jA.IsDataDescriptor:~ES6#sec-isdatadescriptor
jA.OrdinaryDefineOwnProperty:~ES6#sec-ordinarydefineownproperty
jA.OrdinaryDelete:~ES6#sec-ordinarydelete
jA.OrdinaryGet:~ES6#sec-ordinaryget
jA.OrdinaryGetOwnProperty:~ES6#sec-ordinarygetownproperty
jA.OrdinaryGetPrototypeOf:~ES6#sec-ordinarygetprototypeof
jA.OrdinaryOwnPropertyKeys:~ES6#sec-ordinaryownpropertykeys
jA.OrdinarySet:~ES6#sec-ordinaryset
jA.SameValue:~ES6#sec-samevalue
jA.ToString:~ES6#sec-tostring
jA.ToUint32:~ES6#sec-touint32

sl.Window:#concept-windowproxy-window
sl.CrossOriginPropertyDescriptorMap:#crossoriginpropertydescriptormap
sl.DefaultProperties:#defaultproperties

js.List:~ES6#sec-list-and-record-specification-type
jS.hasInstance:~HTMLCONFORM#@@hasinstance
jS.isConcatSpreadable:~HTMLCONFORM#@@isconcatspreadable
jS.toStringTag:~HTMLCONFORM#@@tostringtag
jS.toPrimitive:~HTMLCONFORM#@@toprimitive
x.PropertyDescriptor:~ES6#sec-property-descriptor-specification-type
	Property Descriptor


	●
子~閲覧文脈:~BROWSERS#child-browsing-context
子~閲覧文脈~list:~BROWSERS#_list-of-the-child-browsing-contexts
子~閲覧文脈~名~prop集合:~BROWSERS#child-browsing-context-name-property-set
実効~domain:~BROWSERS#concept-origin-effective-domain
子~閲覧文脈の個数:~BROWSERS#number-of-child-browsing-contexts
有名~obj:~BROWSERS#dom-window-nameditem-filter
生成元:~BROWSERS#concept-origin
通して入子にされ:~BROWSERS#browsing-context-nested-through
閲覧文脈:~BROWSERS#browsing-context
閲覧文脈~容器:~BROWSERS#browsing-context-container
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
sub.~domain:~BROWSERS#same-origin-domain
結付けられている文書:~BROWSERS#concept-document-window

~navigate:~NAVI#navigate

現在の設定群~obj:~WAPI#current-settings-object
関連する設定群~obj:~WAPI#relevant-settings-object

x.現在の~Realm~Record:~ES6#current-realm
x.配列~index~prop名:~WEBIDL#dfn-array-index-property-name
x.保安~検査を遂行する:~WEBIDL#dfn-perform-a-security-check
x.~interface~obj:~WEBIDL#dfn-interface-object
x.内にある:~DOM4#in-a-document


</script>


<!--%style -->
<style type="text/css">
.js, .js-slot, .js-value, .js-intrinsic, .js-symbol, .js-class, .js-method {
	color: green;
}

.js-value {
	font-family: sans-serif0, sans-serif;
}

*[lang="en"] {
	white-space: pre-line;
}

</style>

<body>


<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Standard — 7. Loading Web pages 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Loading Web pages</a>
章の一部分を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-07-28</time>
（公開：<time>2016-07-12</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>
	<hgroup>
<h1>Web ページの読み込み — Loading Web pages： 7.2, 7.4, 7.7.4 節</h1>
<h2>HTML Living Standard — 最終更新 2016 年 7 月 27 日</h2>
	</hgroup>
</header>


<nav class="toc" id="toc">
<h2>目次</h2>
<ol id="_toc_list0"></ol></nav>


<hr>

<main id="MAIN" style="display:none;">

	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, 此れ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<ul>
	<li>
抽象~演算の前に現れる記号［
"?", "!"
］の意味は、~JS仕様にて定義される。
（大雑把に言えば、 "?" は 例外が投出され得ることを表し， "!" は 例外は決して投出されないことを表す）。
</li>
	<li>
`~Foo^sl という表記は、名前 "~Foo" の［
内部~slot／内部~method
］を表す。
</li>
	<li>
“%O.`~Foo^sl ~NEQ ε”
という表記は、
%O は，名前 `~Foo^l の［
内部~slot／内部~method／~Record~field
］を持つことを意味する。
“%O.`~Foo^sl ~EQ ε”
はその否定を意味する。
</li>

</ul>

	</section>
	<section id="cross-origin-objects">
<h2 title="Security infrastructure for Window, WindowProxy, and Location objects">7.2. `Window^I, `WindowProxy^I, `Location^I ~objのための保安~基盤</h2>

<p>
概して，~objは`生成元$を超えて~accessされることはないが、~webは，この規則に対するいくつかの旧来の例外に依存しているため、それらの例外を~web~platformから取り除くことはできない。
◎
Although typically objects cannot be accessed across origins, the web platform would not be true to itself if it did not have some legacy exceptions to that rule that the web depends upon.
</p>

		<section id="integration-with-idl">
<h3 title="Integration with IDL">7.2.1. ~IDLとの統合</h3>

<p>
所与の
( %platformObject, %realm, %identifier,  %type )
に対し，`保安~検査を遂行する$xときは、次の手続きを走らす：
◎
When perform a security check is invoked, with a platformObject, realm, identifier, and type, run these steps:
</p>

<ol>
	<li>
<p>
~IF［
%platformObject は［
`Window$I ／ `Location$I
］~objである
］：
◎
If platformObject is a Window or Location object, then:
</p>

	<ol>
		<li>
<p>
~FOR
`CrossOriginProperties$jA( %platformObject ) 内の ~EACH ( %e ) に対し：
◎
Repeat for each e that is an element of CrossOriginProperties(platformObject):
</p>

			<ol>
				<li>
~IF［
`SameValue$jA( %e . `Property^sl, %identifier ) ~NEQ ~true
］
⇒
~CONTINUE
◎
If SameValue(e.[[Property]], identifier) is true, then:
</li>
				<li>
<p>
%type に応じて：
</p>

<dl class="switch">
	<dt>`method^l</dt>
	<dd>
~IF［
%e . `NeedsGet^sl ~EQ ε
］~AND［
%e . `NeedsSet^sl ~EQ ε
］
⇒
~RET
</dd>

	<dt>`getter^l</dt>
	<dd>
~IF［
%e . `NeedsGet^sl ~EQ ~true
］
⇒
~RET
</dd>

	<dt>`setter^l</dt>
	<dd>
~IF［
%e . `NeedsSet^sl ~EQ ~true
］
⇒
~RET
</dd>
</dl>

◎
If type is "method" and e has neither [[NeedsGet]] nor [[NeedsSet]], then return.
◎
Otherwise, if type is "getter" and e.[[NeedsGet]] is true, then return.
◎
Otherwise, if type is "setter" and e.[[NeedsSet]] is true, then return.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( %platformObject ) ~EQ ~false
］
⇒
~THROW `SecurityError$E
◎
If IsPlatformObjectSameOrigin(platformObject) is false, then throw a "SecurityError" DOMException.
</li>
</ol>

		</section>
		<section id="shared-internal-slot:-[[crossoriginpropertydescriptormap]]">
<h3>7.2.2. 共用~内部~slot： `CrossOriginPropertyDescriptorMap^sl</h3>

<p>
`Window$I, `Location$I
~objのいずれも
`CrossOriginPropertyDescriptorMap@sl
内部~slotを持つ
— その初期~時の値は、空~mapである。
◎
Window and Location objects both have a [[CrossOriginPropertyDescriptorMap]] internal slot, whose value is initially an empty map.
</p>

<p class="note">注記：
`CrossOriginPropertyDescriptorMap$sl 内部~slotは、次のような~entryたちからなる~mapを包含する：
~entryの~keyたちは
( %currentOrigin, %objectOrigin, %propertyKey )
からなる。
これらの~entryの値は，［［
%currentOrigin が
`Window$I ／ `Location$I ~obj %objectOrigin を検分するとき
］に，~scriptから可視になるもの
］を記憶しておくような~prop記述子である。
それらは、 `CrossOriginGetOwnPropertyHelper$jA() により後から埋められ，未来の検索に際し あたられる。
◎
The [[CrossOriginPropertyDescriptorMap]] internal slot contains a map with entries whose keys are (currentOrigin, objectOrigin, propertyKey)-tuples and values are property descriptors, as a memoization of what is visible to scripts when currentOrigin inspects a Window or Location object from objectOrigin. It is filled lazily by CrossOriginGetOwnPropertyHelper, which consults it on future lookups.
</p>

<p>
~UAは、この~mapに保持されている値が，［
値のある部分への参照を保持しているものがない
］ときは、［
それに対応する~keyとともに~garbage収集される
］ことを，許容するべきである。
すなわち、~garbage収集が観測可能でない限り。
◎
User agents should allow a value held in the map to be garbage collected along with its corresponding key when nothing holds a reference to any part of the value. That is, as long as garbage collection is not observable.
</p>

  <p class="example">
例えば，
<samp>const href = Object.getOwnPropertyDescriptor( %crossOriginLocation, `href^l ).set</samp>
とした下では、~map内の値とそれに対応する~keyは，観測可能なので~garbage収集できない。
◎
For example, with const href = Object.getOwnPropertyDescriptor(crossOriginLocation, "href").set the value and its corresponding key in the map cannot be garbage collected as that would be observable.
</p>

<p>
~UAは、 `document.domain$m が設定されたとき，それにより ~mapから
( ~key, 値 ) ~pairを除去するように最適化してもよい。
`document.domain$m は~~過去の値を再訪問できないので、これは観測可能でない。
◎
User agents may have an optimization whereby they remove key-value pairs from the map when document.domain is set. This is not observable as document.domain cannot revisit an earlier value.
</p>

<p class="example">
例えば
<samp>www.example.com</samp> 上の
`document.domain$m を `example.com^l に設定した場合、~UAは，~map内の
( ~key, 値 ) ~pairのうち，［
~keyの一部が <samp>www.example.com</samp> であるもの
］すべてを除去できることになる
— それが再び`生成元$の一部になることは決してないので、対応する値が~mapから検索取得されることも決してない。
◎
For example, setting document.domain to "example.com" on www.example.com means user agents can remove all key-value pairs from the map where part of the key is www.example.com, as that can never be part of the origin again and therefore the corresponding value could never be retrieved from the map.
</p>
		</section>
		<section id="shared-abstract-operations">
<h3 title="Shared abstract operations">7.2.3. 各種 共用~抽象~演算</h3>

			<section id="crossoriginproperties-(-o-)">
<h4>7.2.3.1. `CrossOriginProperties^jA( %O )</h4>

<ol>
	<li>
~Assert：
%O は `Location$I ／ `Window$I ~objである
◎
Assert: O is a Location or Window object.
</li>
	<li>
~IF［
%O は `Location$I ~objである
］
⇒
~RET «
{ `Property^sl: `href^l, `NeedsGet^sl: ~false, `NeedsSet^sl: ~true },
{ `Property^sl: `replace^l }
»
◎
If O is a Location object, then return « { [[Property]]: "href", [[NeedsGet]]: false, [[NeedsSet]]: true }, { [[Property]]: "replace" } ».
</li>
	<li>
%crossOriginWindowProperties ~LET «
{ `Property^sl: `window^l, `NeedsGet^sl: ~true, `NeedsSet^sl: ~false },
{ `Property^sl: `self^l, `NeedsGet^sl: ~true, `NeedsSet^sl: ~false },
{ `Property^sl: `location^l, `NeedsGet^sl: ~true, `NeedsSet^sl: ~true },
{ `Property^sl: `close^l },
{ `Property^sl: `closed^l, `NeedsGet^sl: ~true, `NeedsSet^sl: ~false },
{ `Property^sl: `focus^l },
{ `Property^sl: `blur^l },
{ `Property^sl: `frames^l, `NeedsGet^sl: ~true, `NeedsSet^sl: ~false },
{ `Property^sl: `length^l, `NeedsGet^sl: ~true, `NeedsSet^sl: ~false },
{ `Property^sl: `top^l, `NeedsGet^sl: ~true, `NeedsSet^sl: ~false },
{ `Property^sl: `opener^l, `NeedsGet^sl: ~true, `NeedsSet^sl: ~false },
{ `Property^sl: `parent^l, `NeedsGet^sl: ~true, `NeedsSet^sl: ~false },
{ `Property^sl: `postMessage^l }
»
◎
Let crossOriginWindowProperties be « { [[Property]]: "window", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "self", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "location", [[NeedsGet]]: true, [[NeedsSet]]: true }, { [[Property]]: "close" }, { [[Property]]: "closed", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "focus" }, { [[Property]]: "blur" }, { [[Property]]: "frames", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "length", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "top", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "opener", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "parent", [[NeedsGet]]: true, [[NeedsSet]]: false }, { [[Property]]: "postMessage" } ».
</li>
	<li>
<p>
~FOR %O の`子~閲覧文脈~名~prop集合$内の ~EACH ( %e ) に対し：
◎
Repeat for each e that is an element of O's child browsing context name property set:
</p>

		<ol>
			<li>
%crossOriginWindowProperties の末尾に
{ `Property^sl: %e }
を追加する
◎
Add { [[Property]]: e } as the last element of crossOriginWindowProperties.
</li>
		</ol>
	</li>
	<li>
~RET %crossOriginWindowProperties
◎
Return crossOriginWindowProperties.
</li>
</ol>


<p class="note">注記：
各 有index~propは、~safelistされる必要はない
— `WindowProxy$I ~objにより直接的に取扱われるので。
◎
Indexed properties do not need to be safelisted as they are handled directly by the WindowProxy object.
</p>



			</section>
			<section id="isplatformobjectsameorigin-(-o-)">
<h4>7.2.3.2. `IsPlatformObjectSameOrigin^jA( %O )</h4>

<ol>
	<li>
~RET ［
次を満たすならば ~true ／
~ELSE_ ~false
］
⇒
［
`現在の設定群~obj$の`生成元$
］~EQ`~domain$sub［
%O に`関連する設定群~obj$の`生成元$
］
◎
Return true if the current settings object's origin is same origin-domain with O's relevant settings object's origin, and false otherwise.
</li>
</ol>




			</section>
			<section id="crossorigingetownpropertyhelper-(-o,-p-)">
<h4>7.2.3.3. `CrossOriginGetOwnPropertyHelper^jA( %O, %P )</h4>

<p class="note">注記：
この抽象~演算が ~undefined を返す ~AND
~custom化する挙動もない場合、~call元は `SecurityError$E 例外を投出する必要がある。
◎
If this abstract operation returns undefined and there is no custom behaviour, the caller needs to throw a "SecurityError" DOMException.
</p>

<ol>
	<li>
~IF［
%P ~IN { `toStringTag$jS, `hasInstance$jS, `isConcatSpreadable$jS }
］
⇒
~RET `PropertyDescriptor$x {
`Value^sl: ~undefined,
`Writable^sl: ~false,
`Enumerable^sl: ~false,
`Configurable^sl: ~true
}
◎
If P is @@toStringTag, @@hasInstance, or @@isConcatSpreadable, then return PropertyDescriptor{ [[Value]]: undefined, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.
</li>
	<li>
<p>
%crossOriginKey ~LET 次のものからなる組：
</p>
<ul><li>`現在の設定群~obj$の`生成元$の`実効~domain$
</li><li>%O に`関連する設定群~obj$の`生成元$の`実効~domain$
</li><li>%P
</li></ul>
◎
Let crossOriginKey be a tuple consisting of the current settings object's origin's effective domain, O's relevant settings object's origin's effective domain, and P.
</li>

	<li>
<p>
~FOR `CrossOriginProperties$jA( %O ) 内の ~EACH ( %e ) に対し：
◎
Repeat for each e that is an element of CrossOriginProperties(O):
</p>

		<ol>
			<li>
<p>
~IF［
`SameValue$jA( %e . `Property^sl, %P ) ~EQ ~true
］：
◎
If SameValue(e.[[Property]], P) is true, then:
</p>

				<ol>
					<li>
~IF［
%O . `CrossOriginPropertyDescriptorMap$sl 内部~slotの値は，［
~key ~EQ %crossOriginKey
］なる~entryを包含する
］
⇒
~RET その~entryの値
◎
If the value of the [[CrossOriginPropertyDescriptorMap]] internal slot of O contains an entry whose key is crossOriginKey, then return that entry's value.
</li>
					<li>
%originalDesc ~LET `OrdinaryGetOwnProperty$jA( %O, %P )
◎
Let originalDesc be OrdinaryGetOwnProperty(O, P).
</li>
					<li>
%crossOriginDesc ~LET ~undefined
◎
Let crossOriginDesc be undefined.
</li>
					<li>
<p>
~IF［
%e . `NeedsGet^sl ~EQ ε
］~AND［
%e . `NeedsSet^sl ~EQ ε
］：
◎
If e.[[NeedsGet]] and e.[[NeedsSet]] are absent, then:
</p>

						<ol>
							<li>
%value ~LET %originalDesc . `Value^sl
◎
Let value be originalDesc.[[Value]].
</li>
							<li>
~IF［
`IsCallable$jA( %value ) ~EQ ~true
］
⇒
%value ~SET ［
`現在の~Realm~Record$x内に作成される匿名~組込み関数
］であって，［
~obj %O 上の~IDL演算 %P
］と同じ手続きを遂行するもの
◎
If IsCallable(value) is true, then set value to an anonymous built-in function, created in the current Realm Record, that performs the same steps as the IDL operation P on object O.
</li>
							<li>
%crossOriginDesc ~SET `PropertyDescriptor$x {
`Value^sl: %value,
`Enumerable^sl: ~false,
`Writable^sl: ~false,
`Configurable^sl: ~true
}
◎
Set crossOriginDesc to PropertyDescriptor{ [[Value]]: value, [[Enumerable]]: false, [[Writable]]: false, [[Configurable]]: true }.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
%crossOriginGet ~LET ~undefined
◎
Let crossOriginGet be undefined.
</li>
							<li>
~IF［
%e . `NeedsGet^sl ~EQ ~true
］
⇒
%crossOriginGet ~SET［
`現在の~Realm~Record$x内に作成される匿名~組込み関数
］であって，［
~obj %O 上の~IDL属性 %P の取得子
］と同じ手続きを遂行するもの
◎
If e.[[NeedsGet]] is true, then set crossOriginGet to an anonymous built-in function, created in the current Realm Record, that performs the same steps as the getter of the IDL attribute P on object O.
</li>
							<li>
%crossOriginSet ~LET ~undefined
◎
Let crossOriginSet be undefined.
</li>
							<li>
~IF［
%e.`NeedsSet^sl ~EQ ~true
］
⇒
%crossOriginSet ~SET［
`現在の~Realm~Record$x内に作成される匿名~組込み関数
］であって，［
~obj %O 上の~IDL属性 %P の設定子
］と同じ手続きを遂行するもの
◎
If e.[[NeedsSet]] is true, then set crossOriginSet to an anonymous built-in function, created in the current Realm Record, that performs the same steps as the setter of the IDL attribute P on object O.
</li>
							<li>
%crossOriginDesc ~SET `PropertyDescriptor$x{
`Get^sl: %crossOriginGet,
`Set^sl: %crossOriginSet,
`Enumerable^sl: ~false,
`Configurable^sl: ~true
}
◎
Set crossOriginDesc to PropertyDescriptor{ [[Get]]: crossOriginGet, [[Set]]: crossOriginSet, [[Enumerable]]: false, [[Configurable]]: true }.
</li>
						</ol>
					</li>
					<li>
%O の `CrossOriginPropertyDescriptorMap$sl 内部~slotの値~内に
新たな~entry
( ~key %crossOriginKey, 値 %crossOriginDesc )
を作成する
◎
Create an entry in the value of the [[CrossOriginPropertyDescriptorMap]] internal slot of O with key crossOriginKey and value crossOriginDesc.
</li>
					<li>
~RET %crossOriginDesc
◎
Return crossOriginDesc.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET ~undefined
◎
Return undefined.
</li>
</ol>

			</section>
			<section id="crossoriginget-(-o,-p,-receiver-)">
<h4>7.2.3.4. `CrossOriginGet^jA( %O, %P, %Receiver )</h4>

<ol>
	<li>
%desc ~LET ? %O . `GetOwnProperty^sl( %P )
◎
Let desc be ? O.[[GetOwnProperty]](P).
</li>
	<li>
~Assert：
%desc ~NEQ ~undefined
◎
Assert: desc is not undefined.
</li>
	<li>
~IF［
`IsDataDescriptor$jA( %desc ) ~EQ ~true
］
⇒
~RET %desc . `Value^sl
◎
If IsDataDescriptor(desc) is true, then return desc.[[Value]].
</li>
	<li>
~Assert：
`IsAccessorDescriptor$jA( %desc ) ~EQ ~true
◎
Assert: IsAccessorDescriptor(desc) is true.
</li>
	<li>
%getter ~LET %desc . `Get^sl
◎
Let getter be desc.[[Get]].
</li>
	<li>
~IF［
%getter ~EQ ~undefined
］
⇒
~THROW `SecurityError$E
◎
If getter is undefined, throw a "SecurityError" DOMException.
</li>
	<li>
~RET ? `Call$jA( %getter, %Receiver )
◎
Return ? Call(getter, Receiver).
</li>
</ol>

			</section>
			<section id="crossoriginset-(-o,-p,-v,-receiver-)">
<h4>7.2.3.5. `CrossOriginSet^jA( %O, %P, %V, %Receiver )</h4>

<ol>
	<li>
%desc ~LET ? %O . `GetOwnProperty^sl( %P )
◎
Let desc be ? O.[[GetOwnProperty]](P).
</li>
	<li>
~Assert：
%desc ~NEQ ~undefined
◎
Assert: desc is not undefined.
</li><li>
<p>
~IF［
`IsAccessorDescriptor$jA( %desc ) ~EQ ~true
］：
◎
If IsAccessorDescriptor(desc) is true, then:
</p>

<ol>
	<li>
%setter ~LET %desc . `Set^sl
◎
Let setter be desc.[[Set]].
</li>
	<li>
~IF［
%setter ~EQ ~undefined
］
⇒
~RET ~false
◎
If setter is undefined, return false.
</li>
	<li>
? `Call$jA( %setter, %Receiver, «%V»)
を遂行する
◎
Perform ? Call(setter, Receiver, «V»).
</li>
	<li>
~RET ~true
◎
Return true.
</li>
		</ol>
	</li>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>


			</section>
			<section id="crossoriginownpropertykeys-(-o-)">
<h4>7.2.3.6. `CrossOriginOwnPropertyKeys^jA( %O )</h4>

<ol>
	<li>
%keys ~LET 新たな空 `List$js
◎
Let keys be a new empty List.
</li>
	<li>
<p>
~FOR
`CrossOriginProperties$jA( %O ) 内の ~EACH ( %e ) に対し：
◎
Repeat for each e that is an element of CrossOriginProperties(O):
</p>

		<ol>
			<li>
%keys の末尾に
%e . `Property^sl
を追加する
◎
Add e.[[Property]] as the last element of keys.
</li>
		</ol>
	</li>
	<li>
~RET %keys
◎
Return keys.
</li>
</ol>


			</section>
		</section>
	</section>
	<section id="the-windowproxy-exotic-object">
<h3 title="The WindowProxy exotic object">7.4. `WindowProxy^I ~exotic~obj</h3>

<div>
<p>
各`閲覧文脈$ %B には、
`WindowProxy@I
~obj %P が結付けられる。
それは、普通の~objである `Window$I ~obj %W を，次のように包装する~exotic~objである：
</p>

<ul>
	<li>
%P 上のほとんどの演算は、
%W へ指し向けられる。
</li>
	<li>
%B が`~navigate$されたときは、
%W も別の `Window$I ~objに変更される。
</li>
	<li>
%P の
`Window@sl
内部~slotが， %W を表現する。
</li>
	<li>
%P に対応する`~interface~obj$xはない。
</li>
</ul>

◎
A WindowProxy is an exotic object that wraps a Window ordinary object, indirecting most operations through to the wrapped object. Each browsing context has an associated WindowProxy object. When the browsing context is navigated, the Window object wrapped by the browsing context's associated WindowProxy object is changed.
◎
There is no WindowProxy interface object.
◎
Every WindowProxy object has a [[Window]] internal slot representing the wrapped Window object.
</div>

<p>
`WindowProxy$I
~objの各種~内部~methodは、以下の各~下位節に述べられる。
◎
The WindowProxy object internal methods are described in the subsections below.
</p>

<p class="note">注記：
`WindowProxy$I は、 “proxy（代理）” と命名されているが、本当の proxy がするような，~targetの内部~methodへ polymorphic に配送するものではない
— それは、 `WindowProxy$I ~objと `Location$I ~objとの間の machinery
`機構？^tnote
の再利用が欲されることに因る。
`Window$I ~objが普通の~objのままであり続ける限り、これは観測し得ず，どちらの仕方でも実装し得る。
◎
Although WindowProxy is named as a "proxy", it does not do polymorphic dispatch on its target's internal methods as a real proxy would, due to a desire to reuse machinery between WindowProxy and Location objects. As long as the Window object remains an ordinary object this is unobservable and can be implemented either way.
</p>


		<section id="windowproxy-getprototypeof">
<h3>7.4.1. `GetPrototypeOf^sl()</h3>

<ol>
	<li>
%W ~LET ~this の `Window$sl 内部~slotの値
◎
Let W be the value of the [[Window]] internal slot of this.
</li>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( %W ) ~EQ ~true
］
⇒
~RET ! `OrdinaryGetPrototypeOf$jA( %W )
◎
If IsPlatformObjectSameOrigin(W) is true, then return ! OrdinaryGetPrototypeOf(W).
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

		</section>
		<section id="windowproxy-setprototypeof">
<h3>7.4.2. `SetPrototypeOf^sl( %V )</h3>

<ol>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>

		</section>
		<section id="windowproxy-isextensible">
<h3>7.4.3. `IsExtensible^sl()</h3>

<ol>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>


		</section>
		<section id="windowproxy-preventextensions">
<h3>7.4.4. `PreventExtensions^sl()</h3>

<ol>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>




		</section>
		<section id="windowproxy-getownproperty">
<h3>7.4.5. `GetOwnProperty^sl( %P )</h3>

<ol>
	<li>
%W ~LET ~this の `Window$sl 内部~slotの値
◎
Let W be the value of the [[Window]] internal slot of this.
</li>

	<li>
<p>
~IF［
%P は`配列~index~prop名$xである
］：
◎
If P is an array index property name, then:
</p>

		<ol>
			<li>
%index ~LET `ToUint32$jA( %P )
◎
Let index be ToUint32(P).
</li>
			<li>
%maxProperties ~LET %W の`子~閲覧文脈の個数$
◎
Let maxProperties be the number of child browsing contexts of W.
</li>
			<li>
%value ~LET ~undefined
◎
Let value be undefined.
</li>
			<li>
<p>
~IF［
%maxProperties ~GT 0
］~AND［
%index ~LT %maxProperties
］：
</p>
				<ol>
					<li>
%文書 ~LET %W に`結付けられている文書$
</li>
					<li>
<p>
%容器 ~LET 次を満たす`閲覧文脈~容器$のうち，最も近過去に %文書 内に挿入されたもの
</p>
<ul ><li> %文書 `内にある$x
</li><li>`入子にしている閲覧文脈$ ~NEQ ~NULL
</li></ul>
					</li>
					<li>
%value ~SET %容器 が`入子にしている閲覧文脈$の `WindowProxy$I ~obj
</li>
				</ol>
◎
If maxProperties is greater than 0 and index is less than maxProperties, then:
◎
Set value to the WindowProxy object of the indexth child browsing context of the Document that is nested through an element that is in W's Document, sorted in the order that the elements nesting those browsing contexts were most recently inserted into the Document, the WindowProxy object of the most recently inserted browsing context container's nested browsing context being last.
</li>
			<li>
~RET `PropertyDescriptor$x{
`Value^sl: %value,
`Writable^sl: ~false,
`Enumerable^sl: ~false,
`Configurable^sl: ~true
}
◎
Return PropertyDescriptor{ [[Value]]: value, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`IsPlatformObjectSameOrigin$jA( %W ) ~EQ ~true
］
⇒
~RET `OrdinaryGetOwnProperty$jA( %W, %P )
◎
If IsPlatformObjectSameOrigin(W) is true, then return OrdinaryGetOwnProperty(W, P).
</p>

<p class="note">注記：
これは、~JSの内部~method不変則に違反する。
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1197958#c4">Gecko ~bug 1197958 の 4 番目の~comment</a>
に、その方式についての更なる論点を見れる。
◎
This violates JavaScript's internal method invariants. Gecko bug 1197958 comment 4 has further discussion on the manner.
</p>
	</li>
	<li>
%property ~LET `CrossOriginGetOwnPropertyHelper$jA( %W, %P )
◎
Let property be CrossOriginGetOwnPropertyHelper(W, P).
</li>
	<li>
~IF［
%property ~NEQ ~undefined
］
⇒
~RET %property
◎
If property is not undefined, return property.
</li>
	<li>
<p>
~IF［
%property ~EQ ~undefined
］~AND［
%P ~IN %W の`子~閲覧文脈~名~prop集合$
］：
◎
If property is undefined and P is in W's child browsing context name property set, then:
</p>

		<ol>
			<li>
%value ~LET 名前 %P の`有名~obj$である `WindowProxy$I ~obj
◎
Let value be the WindowProxy object of the named object with the name P.
</li>
			<li>
~RET `PropertyDescriptor$x{
`Value^sl: %value,
`Enumerable^sl: ~false,
`Writable^sl: ~false,
`Configurable^sl: ~true
}
◎
Return PropertyDescriptor{ [[Value]]: value, [[Enumerable]]: false, [[Writable]]: false, [[Configurable]]: true }.
</li>
		</ol>
	</li>
	<li>
~THROW `SecurityError$E
◎
Throw a "SecurityError" DOMException.
</li>
</ol>


		</section>
		<section id="windowproxy-defineownproperty">
<h3>7.4.6. `DefineOwnProperty^sl( %P, %Desc )</h3>

<ol>
	<li>
~IF［
%P は`配列~index~prop名$x
］
⇒
~RET ~false
◎
If P is an array index property name, return false.
</li>
	<li>
%W ~LET ~this の `Window$sl 内部~slotの値
◎
Let W be the value of the [[Window]] internal slot of this.
</li>
	<li>
<p>
~IF［
`IsPlatformObjectSameOrigin$jA( %W ) ~EQ ~true
］
⇒
~RET ? `OrdinaryDefineOwnProperty$jA( %W, %P, %Desc )
◎
If IsPlatformObjectSameOrigin(W) is true, then return ? OrdinaryDefineOwnProperty(W, P, Desc).
</p>

<p class="note">注記：
これが~JSの内部~method不変則にどう違反するについては、上を見よ。
◎
See above about how this violates JavaScript's internal method invariants.
</p>
	</li>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>




		</section>
		<section id="windowproxy-get">
<h3>7.4.7. `Get^sl( %P, %Receiver )</h3>

<ol>
	<li>
%W ~LET ~this の `Window$sl 内部~slotの値
◎
Let W be the value of the [[Window]] internal slot of this.
</li>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( %W ) ~EQ ~true
］
⇒
~RET ? `OrdinaryGet$jA( ~this, %P, %Receiver )
◎
If IsPlatformObjectSameOrigin(W) is true, then return ? OrdinaryGet(this, P, Receiver).
</li>
	<li>
~RET ? `CrossOriginGet$jA( ~this, %P, %Receiver )
◎
Return ? CrossOriginGet(this, P, Receiver).
</li>
</ol>


		</section>
		<section id="windowproxy-set">
<h3>7.4.8. `Set^sl( %P, %V, %Receiver )</h3>

<ol>
	<li>
%W ~LET ~this の `Window$sl 内部~slotの値
◎
Let W be the value of the [[Window]] internal slot of this.
</li>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( %W ) ~EQ ~true
］
⇒
~RET ? `OrdinarySet$jA( %W, ~this, %Receiver )
◎
If IsPlatformObjectSameOrigin(W) is true, then return ? OrdinarySet(W, this, Receiver).
</li>
	<li>
~RET ? `CrossOriginSet$jA( ~this, %P, %V, %Receiver )
◎
Return ? CrossOriginSet(this, P, V, Receiver).
</li>
</ol>


		</section>
		<section id="windowproxy-delete">
<h3>7.4.9. `Delete^sl( %P )</h3>

<ol>
	<li>
~IF［
%P は`配列~index~prop名$xである
］
⇒
~RET ~false
◎
If P is an array index property name, return false.
</li>
	<li>
%W ~LET ~this の `Window$sl 内部~slotの値
◎
Let W be the value of the [[Window]] internal slot of this.
</li>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( %W ) ~EQ ~true
］
⇒
~RET ? `OrdinaryDelete$jA( %W, %P )
◎
If IsPlatformObjectSameOrigin(W) is true, then return ? OrdinaryDelete(W, P).
</li>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>

		</section>
		<section id="windowproxy-ownpropertykeys">
<h3>7.4.10. `OwnPropertyKeys^sl()</h3>

<ol>
	<li>
%W ~LET ~this の `Window$sl 内部~slotの値
◎
Let W be the value of the [[Window]] internal slot of this.
</li>
	<li>
%keys ~LET 新たな空 `List$js
◎
Let keys be a new empty List.
</li>
	<li>
%maxProperties ~LET %W の`子~閲覧文脈の個数$
◎
Let maxProperties be the number of child browsing contexts of W.
</li>
	<li>
%index ~LET 0
◎
Let index be 0.
</li>
	<li>
<p>
~WHILE［
%index ~LT %maxProperties
］：
◎
Repeat while index &lt; maxProperties,
</p>
		<ol>
			<li>
%keys の末尾に
! `ToString$jA( %index )
を追加する
◎
Add ! ToString(index) as the last element of keys.
</li>
			<li>
%index ~INCBY 1
◎
Increment index by 1.
</li>
		</ol>
	</li>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( %W ) ~EQ ~true
］
⇒
~RET 次を連結した結果
⇒
%keys,<br>
! `OrdinaryOwnPropertyKeys$jA( %W )
◎
If IsPlatformObjectSameOrigin(W) is true, then return the concatenation of keys and ! OrdinaryOwnPropertyKeys(W).
</li>
	<li>
~RET 次を連結した結果
⇒
%keys,<br>
! `CrossOriginOwnPropertyKeys$jA( %W )
◎
Return the concatenation of keys and ! CrossOriginOwnPropertyKeys(W).
</li>
</ol>

		</section>
	</section>
	<section id="history">
<h2 title="Session history and navigation">7.7. ~session履歴と~navi</h2>

<p class="trans-note">【
この節の他の内容は
<a href="~BROWSERS#history">別ページ</a>
にて。
】</p>

		<section id="the-location-interface">
<h3 title="The Location interface">7.7.4. `Location^I ~interface</h3>


<p class="trans-note">【
この節の内容のうち，~APIに関する部分は、
<a href="~HTMLWPROXY#the-location-interface">別ページ</a>
にて。
】</p>

<p>
各 `Window$I ~objには、その作成-時に，新たな `Location$I ~objが結付けられる。
<!-- unique instance of 〜 allocated -->
◎
Each Window object is associated with a unique instance of a Location object, allocated when the Window object is created.
</p>


<p class="warning">
`Location$I ~exotic~objは、~IDLの寄せ集めであり，［
~JS~内部~method~post-creationの呼び出し, および
~JS~内部~methodの上書き
］を通して，それの~scary保安~施策と組にして定義される。
この~excrescenceを実装するときは、要注意。
◎
The Location exotic object is defined through a mishmash of IDL, invocation of JavaScript internal methods post-creation, and overridden JavaScript internal methods. Coupled with its scary security policy, please take extra care while implementing this excrescence.
</p>

<p>
`Location$I ~objを~作成するときは、次の~手続きを走らす:
◎
To create a Location object, run these steps:
</p>

<ol>
	<li>
%L ~LET 新たな `Location$I ~obj
◎
Let location be a new Location platform object.
</li>
	<li>
<p>
次を順に遂行する：
</p>

<ol ><li>! %L . `DefineOwnProperty^sl(`toString^l, { `Value^sl: `ObjProto_toString^jI, `Writable^sl: ~~false, `Enumerable^sl: ~false, `Configurable^sl: ~false })
◎
Perform ! location.[[DefineOwnProperty]]("toString", { [[Value]]: %ObjProto_toString%, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).

</li><li>! %L . `DefineOwnProperty^sl(`toJSON^l, { `Value^sl: ~undefined, `Writable^sl: ~false, `Enumerable^sl: ~false, `Configurable^sl: ~false })
◎
Perform ! location.[[DefineOwnProperty]]("toJSON", { [[Value]]: undefined, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).

</li><li>! %L . `DefineOwnProperty^sl(`valueOf^l, { `Value^sl: `ObjProto_valueOf^jI, `Writable^sl: ~false, `Enumerable^sl: ~false, `Configurable^sl: ~false })
◎
Perform ! location.[[DefineOwnProperty]]("valueOf", { [[Value]]: %ObjProto_valueOf%, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).

</li><li>! %L . `DefineOwnProperty^sl(`toPrimitive$jS, { `Value^sl: ~undefined, `Writable^sl: ~false, `Enumerable^sl: ~false, `Configurable^sl: ~false })
◎
Perform ! location.[[DefineOwnProperty]](@@toPrimitive, { [[Value]]: undefined, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).
</li></ol>

	</li>
	<li>
%L の `DefaultProperties$sl 内部~slot値 ~SET %L . `OwnPropertyKeys^sl()
◎
Set the value of the [[DefaultProperties]] internal slot of location to location.[[OwnPropertyKeys]]().
</li>
	<li>
~RET %L
◎
Return location.
</li>
</ol>

<hr>

<p>
先に説明したように， `Location$I ~exotic~objは、保安~目的のため，~IDLを超える追加の~logicが要求される。
`Location$I ~objが実装し~MUST［
内部~slotと内部~method
］は、以下に定義される。
◎
As explained earlier, the Location exotic object requires additional logic beyond IDL for security purposes. The internal slot and internal methods Location objects must implement are defined below.
</p>

<p>
どの `Location$I ~objも，
`DefaultProperties@sl
内部~slotを持つ
— それは，~objの作成-時における~objの自前の~propを表現する。
◎
Every Location object has a [[DefaultProperties]] internal slot representing its own properties at time of its creation.
</p>

			<section id="location-getprototypeof">
<h4>7.7.4.1. `GetPrototypeOf^sl()</h4>

<ol>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( ~this ) ~EQ ~true
］
⇒
~RET ! `OrdinaryGetPrototypeOf$jA( ~this )
◎
If IsPlatformObjectSameOrigin(this) is true, then return ! OrdinaryGetPrototypeOf(this).
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>




			</section>
			<section id="location-setprototypeof">
<h4>7.7.4.2. `SetPrototypeOf^sl( %V )</h4>

<ol>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>

			</section>
			<section id="location-isextensible">
<h4>7.7.4.3. `IsExtensible^sl()</h4>

<ol>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="location-preventextensions">
<h4>7.7.4.4. `PreventExtensions^sl()</h4>

<ol>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>

			</section>
			<section id="location-getownproperty">
<h4>7.7.4.5. `GetOwnProperty^sl( %P )</h4>

<ol>
	<li>
<p>
~IF［
`IsPlatformObjectSameOrigin$jA( ~this ) ~EQ ~true
］：
◎
If IsPlatformObjectSameOrigin(this) is true, then:
</p>

		<ol>
			<li>
%desc ~LET `OrdinaryGetOwnProperty$jA( ~this, %P )
◎
Let desc be OrdinaryGetOwnProperty(this, P).
</li>
	<li>
~IF［
%P ~IN ~this の `DefaultProperties$sl 内部~slotの値
］
⇒
%desc . `Configurable^sl ~SET ~true
◎
If the value of the [[DefaultProperties]] internal slot of this contains P, then set desc.[[Configurable]] to true.
</li>
			<li>
~RET %desc
◎
Return desc.
</li>
		</ol>
	</li>
	<li>
%property ~LET
 !
`CrossOriginGetOwnPropertyHelper$jA( ~this, %P )
。
◎
Let property be ! CrossOriginGetOwnPropertyHelper(this, P).
</li>
	<li>
~IF［
%property ~NEQ ~undefined
］
⇒
~RET %property
◎
If property is not undefined, return property.
</li>
	<li>
~THROW `SecurityError$E
◎
Throw a "SecurityError" DOMException.
</li>
</ol>


			</section>
			<section id="location-defineownproperty">
<h4>7.7.4.6. `DefineOwnProperty^sl( %P, %Desc )</h4>

<ol>
	<li>
<p>
~IF［
`IsPlatformObjectSameOrigin$jA( ~this ) ~EQ ~true
］：
◎
If IsPlatformObjectSameOrigin(this) is true, then:
</p>

		<ol>
			<li>
~IF［
%P ~IN ~this の `DefaultProperties$sl 内部~slotの値
］
⇒
~RET ~false
◎
If the value of the [[DefaultProperties]] internal slot of this contains P, then return false.
</li>
			<li>
~RET ? `OrdinaryDefineOwnProperty$jA( ~this, %P, %Desc )
◎
Return ? OrdinaryDefineOwnProperty(this, P, Desc).
</li>
		</ol>
	</li>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>




			</section>
			<section id="location-get">
<h4>7.7.4.7. `Get^sl( %P, %Receiver )</h4>

<ol>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( ~this ) ~EQ ~true
］
⇒
~RET ? `OrdinaryGet$jA( ~this, %P, %Receiver )
◎
If IsPlatformObjectSameOrigin(this) is true, then return ? OrdinaryGet(this, P, Receiver).
</li>
	<li>
~RET ? `CrossOriginGet$jA( ~this, %P, %Receiver )
◎
Return ? CrossOriginGet(this, P, Receiver).
</li>
</ol>




			</section>
			<section id="location-set">
<h4>7.7.4.8. `Set^sl( %P, %V, %Receiver )</h4>

<ol>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( ~this ) ~EQ ~true
］
⇒
~RET ? `OrdinarySet$jA( ~this, %P, %Receiver )
◎
If IsPlatformObjectSameOrigin(this) is true, then return ? OrdinarySet(this, P, Receiver).
</li>
	<li>
~RET ? `CrossOriginSet$jA( ~this, %P, %V, %Receiver )
◎
Return ? CrossOriginSet(this, P, V, Receiver).
</li>
</ol>


			</section>
			<section id="location-delete">
<h4>7.7.4.9. `Delete^sl( %P )</h4>

<ol>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( ~this ) ~EQ ~true
］
⇒
~RET ? `OrdinaryDelete$jA( ~this, %P )
◎
If IsPlatformObjectSameOrigin(this) is true, then return ? OrdinaryDelete(this, P).
</li>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>


			</section>
			<section id="location-ownpropertykeys">
<h4>7.7.4.10. `OwnPropertyKeys^sl()</h4>

<ol>
	<li>
~IF［
`IsPlatformObjectSameOrigin$jA( ~this ) ~EQ ~true
］
⇒
~RET ! `OrdinaryOwnPropertyKeys$jA( ~this )
◎
If IsPlatformObjectSameOrigin(this) is true, then return ! OrdinaryOwnPropertyKeys(this).
</li>
	<li>
~RET ! `CrossOriginOwnPropertyKeys$jA( ~this )
◎
Return ! CrossOriginOwnPropertyKeys(this).
</li>
</ol>


			</section>
		</section>
	</section>

</main>

