<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Content Security Policy Level 3</title>
<meta name="keywords" content="CSP,セキュリティ,ポリシー,リソース,仕様,W3C">

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<!--%script -->
<script >
var source_data;

COMMON_DATA.page_state_key = 'webappsec';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://w3c.github.io/webappsec-csp/',
//		original_url: 'https://www.w3.org/TR/CSP3/',
		spec_status: 'ED',
		main: 'MAIN',
		fill_text_link: '#_versions > dd, #references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:英語+漢字:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked 160620 spec

	return options;
}

function expand(mapping1){
	var link_map = this.link_map;
	var idl_context = '';
	var nesting = '';
	var class_map = {
//		r: 'ref', // 参照文献
		p: 'production', // protocol element
		P: 'production', // protocol element
		dir: 'directive',
		h: 'header',
		e: 'element',
		a: 'attr',
		et: 'event-type',
		I: 'idl',
		m: 'idl',
		AO: 'abstract',
		E: 'error',
		sc: 'scheme',
		at: 'css',
		f: 'css',
//		fl: 'sandboxing',
		pl: 'literal',
	};
	var tag_map = {
		p: 'var',
		P: 'code',
		dir: 'code',
		h: 'code',
		css: 'code',
		sc: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		I: 'code',
		m: 'code',
		AO: 'span',
		E: 'code',
		at: 'code',
		f: 'code',
		v: 'var',
		c: 'code',
		s: 'samp',
		i: 'i',
		pl: 'code',
//		fl: 'code',
		NOTE: 'span'
	}

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/◎[^`<◎]*|⇒|【.*?】|%[\u4E00-\u9FFF~\w\-]+|`(.*?)([$@^])(\w*)/g,
			create_html
		),
		mapping1
	);

// 目次構築
	Util.rebuildToc('MAIN0', '_toc_list0');

	function create_html(match, key, indicator, klass){

if(!indicator) {
	switch(match.charAt(0)){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '【':
		return '<span class="trans-note">' + match + '<\/span>'
	case '⇒':
		nesting += '<\/span>';
		return '：<span class="block">';
	}
	//◎
	var result = nesting + '<span lang="en">' + match.slice(1).trim() + '<\/span>';
	nesting = '';
	return result;
}


var text = key;
var href = '';
//	var href = link_map[klass ? (klass + '.' + key) : key] || '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // 文献
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'P': // protocol 要素
	break;
case 'pl': //protocol literal
	text = '\'' + key + '\'';
	href = '#grammardef-' + key;
	break;
case 'p': // protocol 要素
	href = '#grammardef-' + key;
	break;
case 'dir': // 指令
	href = '#' + key;
	break;
case 'sc': // scheme
	text = key + ':';
	break;
case 'hex': // hex 
	text = '%x' + key;
	break;
case 'I': // idl def
	if( indicator === '@') {
		idl_context = '#dom-' + key + '-';
	}
	break;
case 'd': // idl dict member
	break;
case 'm': // idl member
	href = href || (idl_context + key).toLowerCase();
	break;
case 'l': //literal
	return '"<code class="literal">' + key +'</code>"'
	break;
	break;
case 'lt': //protocol literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'IssW3C':
	return '<a href="https://github.com/w3c/html/issues/' + key + '">&lt;https://github.com/w3c/html/issues/' + key + '&gt;</a>';
	break;

case 'sec': //節
case 'u': // 
case 'url': // 
case 'et': // 
case 'i': // 定数
case 'h': // HTTP header
case 'rq': // 要請
case 'rs': // 応答
case 'sec':
case 'x': // plain
case 'vr': // 違反報告
case 'e': // HTML 要素
case 's': //samp
case 'c': //code
case 'v': // variables
case 'a': // HTML 内容属性
default:
//		console.log(match);
	break;
//	return match;
}

if(tag) {
	text = '<' + tag +
		(classname ? ' class="' + classname + '">' : '>') +
		text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>


<!--%語彙 -->
<script type="text/plain" id="words_table">

ABNF:
CSP:
	Content-Security-Policy
	Content-Security-Policy-Report-Only
	Document
HTTP-network:
HTTP:
URL:
JS:JavaScript
	API
	Content Security Policy
	CSSOM
	Fetch
	HTML
	CSS
	IDL
	IP
	IPv4
	IPv6
	JSON
	Level
	MIME
	Main
	Service Worker
	W3C
	XSLT
	ASCII
	ASTERISK
	SEMICOLON
	SOLIDUS
	FULLSTOP
	COMMA
	STOP
	base64

access::::アクセス
addon::::アドオン
algo:algorithm:::アルゴリズム
alias::::エイリアス
bit::::ビット
call::::
callable:
block::::ブロック
bookmarklet::::ブックマークレット
browser::::ブラウザ
cache::::キャッシュ
	明らかでない:not clear
	unclear::::
code::::コード
信用-:trust:~
manifest::::マニフェスト
	XSS:cross-site scripting
	abstract:
	case-sensitive:
束縛-:bind:~
flow::::フロー
通過制御-:gate:~
	subject:::
送信0:submission:送信
	substantial:::
	十分:sufficient:
	suspect:::
	tempting:
	〜に置き換えたもの~variant:
	その逆vice-versa:
	走査してwalking:
	~~注視-:watching:
	仕事~work:::
厳密:strict:~
protocol::::プロトコル

行番号:line number::~
列番号:column number::~

console::::コンソール
data::::データ
	decision:
	demonstrate::::
event::::イベント
handler::::ハンドラ

file::::ファイル
flag::::フラグ
font::::フォント
強制:forced::~
form::::フォーム
frame::::フレーム
group::::グループ
hook::::フック
iframe::::
index::::
instance::::インスタンス
	instance化:instantiate:~
interface::::インタフェース
item::::アイテム
level::::レベル
list::::リスト
lock::::ロック
logic::::ロジック
mode::::モード
obj:object:::オブジェクト
	open::::
	opener:
page::::ページ
pair::::ペア
	成分:part:~
percent::::パーセント
	~plugin-type:
	popping:
	~~源になる:produce:~
	~produce:
property::::プロパティ
push::::プッシュ
random::::ランダム

scalable::::スケーラブル
	skip::::
sort::::ソート
	splitting::::
	srcdoc::::
剥ぐ:strip する:~
剥いだ:strip した:~
tag::::タグ
trusted::::
window::::ウィンドウ
worker::::ワーカ

	●network/HTTP/fetch
target::::ターゲット
url::::
fetch::::
	~fetch~~処理:fetching
port::::ポート
事前fetch:prefetch::事前 fetch
site::::サイト
website::::サイト
server::::サーバ
serve::::サービス供与
path::::パス
scheme::::スキーム
局所:local::~::ローカル
redirect::::リダイレクト
回数:count:~
	~redirect回数~redirect~count
referrer::::リファラ
client::::クライアント
address::::アドレス
国際化:internationalized:~
domain::::ドメイン
下位domain:subdomain:::下位ドメイン
field::::フィールド
header::::ヘッダ
host::::ホスト
hostname::::ホスト名
main:
message::::メッセージ
method::::メソッド
network::::ネットワーク
error::::エラー
web::::ウェブ
伝送-:transmit::~
受信-:receive::~
層:layer::~::レイヤ
接続-:connect::~::コネクト
接続:connection::~::コネクション
所在:location:~
応答:response::~::レスポンス
要請:request::~::リクエスト
要請前:pre-request::~::リクエスト前
要請後:post-request::~::リクエスト後
解決-:resolve:~
資格証:credentials::資格証明情報::クレデンシャル
起動元:initiator::~
資源:resource::~:リソース
送信-:send::~
送信:sending::~
送達-:deliver::~
送達:delivery::~
通知-:notify::~
通知:notification::~
配備-:deploy::~::デプロイ
	配備:deployment:~
配置-:place:~
状態0:status::状態°::ステータス
状態code:status code::状態°code:状態°コード:ステータスコード
状態:state:~
生成元:origin::~::オリジン
本体:body:~:::ボディ
素片除外:exclude fragment:~
行先:destination:~
凍結-:freeze:~
	frozen:~
	●保安
保安:security::~:セキュリティ
保安的:secure::~:セキュア
保安上の:security::~:セキュリティ上の
	保安施策:security policy::~:セキュリティポリシー
非保安的:insecure::~:非セキュア
	保安的でない:insecure:~
保護-:protect:~
信用-:trust:~
安全:safe:~
攻撃:attack:~
攻撃者:attacker:~
敵対的:hostile:~
注入:injection:~
注入-:inject:~
暗号的:cryptographic:~
暗号用:cryptographic:~
脅威:threat:~
迂回-:bypass:~
軽減-:mitigate:~
防止-:prevent:~
中止-:abort:~
予測-:predict:~
悪用-:exploit:~
推測不能:unguessable:~
欠陥:flaw:~
	exfiltration:::
sink:
whitelist::::ホワイトリスト
双方向通信channel:bidirectional communication channel:双方向通信 channel::双方向通信チャンネル
監禁-:lock down:~
投入-:feed:~
検証0-:verify:検証
検証:validation:~
乱数生成器:random number generator:~
前線防御:first line of defense:~
多層防御:defense-in-depth:~
脆弱性:vulnerabilities:~

大規模な:extensive:~
	壊れ易く, 扱い難い:brittle, awkward
自信:confidence:~
	自信がない:low confidence
	自信がある:high degree of confidence
大変:tough:~
迂回:bypass:~
sniffing:
	持ち込む:bring する
	構文解析-時に挿入され:parser-inserted
完全性:integrity::~
特権:privilege:~

	●CSP 対象
text::::テキスト
track::::トラック
inline::::インライン
navigation::::ナビゲーション
script::::スクリプト
style::::スタイル
stylesheet::::スタイルシート
sandbox::::サンドボックス
	~sandbox化:sandboxed
	~sandbox用:sandboxing
pop-up:pop-up
plugin::::プラグイン
音声:audio:~
動画:video:~
画像:image:~
宣言-:declare:~
宣言:declaration:~
選択子:selector:~
閲覧文脈:browsing context:~
作動中の:active な:~
	作動中:active:~
先祖:ancestor:~
入子に:nest:入れ子に
入子の:nested:入れ子の
埋込んで:embed して::埋め込んで
埋込んだ:embed した::埋め込んだ
埋込む:embed する::埋め込む
埋込まれ:embed され::埋め込まれ
埋込める:embed できる::埋め込める
埋込み:embedding::埋め込み
	埋込-:embed:~
	読込-:load:~
読込み:loading::読み込み::ローディング
読込まれ:load され::読み込まれ::ロードされ
読込む:load する::読み込む::ロードする
読込める:load できる::読み込める::ロードできる
読込んで:load して::読み込んで::ロードして
読込もう:load しよう::読み込もう::ロードしよう
誘発-:trigger:~
要素:element:~
能力:capabilities:~
開いた:open した::~
開く:open する::~
開かれ:open され::~

	●CSP
hash::::ハッシュ
nonce::::ナンス
metadata::::メタデータ
source::::ソース
fall-back:fall back:::フォールバック
fallback::::フォールバック
digest::::ダイジェスト

処分先:disposition:~
施策:policy::~:ポリシー
式:expression::~
報告:report::~
報告処理:reporting::~
報告先:reporting endpoint::~
端点:endpoint::~::エンドポイント
施行-:enforce::~
施行:enforcement::~
	施行ing:enforcing:施行
監視-:monitor::~
監視:monitoring::~
検査:check::~::チェック

制御:control:~
制約-:restrict:~
制約:restriction:~
制限-:limit:~
被保護:protected:~
	被設定時:被 set 時:~
合格-:pass::~::パス

阻止-:block::~::ブロック
	阻止する:block する::阻む::ブロックする
	阻止され:block され::阻まれ::ブロックされ
	阻止でき:block でき::阻め::ブロックでき
阻止ed:Blocked::阻止される::ブロックされる

合致:match::~::マッチ
非合致:Does Not Match::合致しない::マッチしない
合致es:Matches::合致する::マッチする
照合:matching::~::マッチング
照合-:match::~::マッチ

許容-:allow:~
許容ed:Allowed::許容される

違反-:violate::~
違反:violation::~
違反ed:violated::違反
非違反:Does Not Violate::違反しない


指令:directive::~::ディレクティブ
発火-:fire:~
	発行-:make:~
大域:global::~::グローバル
稼働中の:running:~
	稼働-:run:~
処理命令:processing-instruction:~

	●他
環境:environment:~
realm:
compilation::::コンパイル
投出-:throw:~
抽象演算:abstract operation:~

	●一般
netowrk::::ネットワーク
除外-:exclude:~
検知-:detect:~
不許可に:disallow:~
上書き:override:~
昇格:upgrade:~
文脈:context:~
抽出-:extract:~
拡充-:populate:~
抑制-:reduce:~
初期:initial:~
初期化-:initialize:~
	initialising:~
初期化:initialization:~
作成-:create:~
作成:creation:~
作成法:creating:~
動作-:act:~
動作:action:~
包含-:contain:~
収集-:collect:~
分割-:split:~
取得-:get:~
成功-:succeed:~
挿入-:insert:~
改変-:modify:~
格納-:store:~
構築-:construct:~
準備-:prepare:~
生成-:generate:~
除去-:remove:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
取扱われ:handle され:取り扱われ
可能化-:enable:~
置換-:replace:~
表現-:represent:~
表現:representation:~
識別-:identify:~
評価-:evaluate:~
維持-:maintain:~
先行-:precede:~
完了-:complete:~
処理-:process:~
処理:processing:~
評価0:estimate:評価
追加-:add:~
	追加の:additional:~


事例:case:~
値:value:~
元の:original:~
入力:input:~
	全体:entire:~
内容:content:~
内側:inside:内部
	再利用-:reuse:~
出力:output:~
	から生じて:originate:~
効果:effect:~
動的:dynamic:~
参照:reference:~
可能0:possible:可能
名前:name:~
名:name:~
命名-:name:~
呼出:invocation:呼び出し
困難:difficult:~
在する:present する:在る
	在しな:present しな:無
	在する下:presence
型:type::~
種別:type::~
基底:base:~
属性:attribute:~
引数:argument:~
	数:number:~
整数:integer:~
文書:document:~
新たな:new:~
既定:default:~
既定の:default:~
更新:update:~
	最初の:first:~
有効な:effective:~
条件:condition:~
	残りの:remaining:~
	渡す:pass する:~

運用:operation:~
直接的:direct:~
相対的:relative:~
	簡単:straightforward:~
組合せ:combination:~
継承:inheritance:~
種類:kind:~
細かい:granular な:~
現在:currently:~
現在の:current:~
空:empty:~
自明:trivial:~
自前の:own:~
	複数の:multiple:~
設定-:set:~
設定子:setter:~
設定群:settings:~
被設定時:被 set 時:~
incumbent:
	量:amount:~
関連する:relevant な:~
	関連の
集合:set:~
非負:non-negative:~
単独の:single:~
依存関係:dependencies:~
生産-:produce:~
走らす:run する:走らせる
保守-:maintain:~
既存の:existing:~
能:ability:機能

	●構文
space::::スペース
keyword::::キーワード
literal::::リテラル
構成子:constructs:~
構文:syntax:~
構文解析-:parse::~::パース
構文解析処理:parsing::~::パース処理
構文解析器:parser::~::パーサ
生成規則:production:~
復号-:decode::~::デコード
符号化-:encode::~::エンコード
符号化方式:encoding::~::エンコーディング
文字:character:~
文字列:string:~
文字大小無視:case-insensitive:~
小文字化:lowercase 化:~
文法:grammar:~
直列化:serialization::~::シリアル化
直列化-:serialize::~::シリアライズ
直列化器:serializer::~::シリアライザ
直列化形の:serialized::~::シリアライズされた

空白:whitespace:~
space::空白
空白類:space characters:~
規則:rule:~
区切りの:-delimited:~
区切って:delimit して:~
asterisk::::アスタリスク
semicolon::::セミコロン
slash::::スラッシュ
period::::ピリオド
comma::::カンマ
token::::トークン

schedule::::スケジュール

	●仕様
相互作用:interactions:~
形成-:form:~
bug::::バグ
noise::::ノイズ
選好-:prefer:~
概説-:outline:~
support::::サポート
UA:user agent:UA
model::::モデル
risk::::リスク
tool::::ツール
UI::::
見なさ:consider さ:~
不可欠:critical:~
	取り扱う:deal with
公式的:formal:~
	課題:issue:::
	fashion:
基盤:infrastructure:~
安定的:stable:~
波及-:influence:~
	has no influence
module::::モジュール
modular::::モジュール式
vendor::::ベンダ
version::::バージョン
技術的:technical:~
	~~公開の問い~open~questions:
	理にかなうreasonably:
	意義sense:
	素描するsketching:
	強くstrongly:
適切:appropriate:~
適合的:conformant:適合
適合性:conformance:~
適用-:apply:~
適用:application:~
避ける:avoid する:~
避けて:avoid して:~
期待-:expect:~
期待:expectations:~
一意な:unique:~
一意的:unique:~
一般:general:~
一般的:general:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
任意の:arbitrary:~
作者:author:~
	例:example:~
	供-:provide:~
依存-:depend:~
保持-:hold:~
側面:aspect:~
	別個:distinct:~
	利用:use:~
判定基準:criteria:~
利用者:user:~:::ユーザ
	前者:former:~
取止める:drop する:取り止める
	古い:old:~
	基づく:based:~
変更点:changes:~
変更-:change:~
外部:external:~
外部化-:externalize:~
奨励-:encourage:~
妥当な:valid:~
妥当:valid:~
存在-:exist:~
定義-:define:~
定義:definition:~
実施:practice:~
実装-:implement:~
実装:implementation:~
実際:actual:~
将来:future:~
干渉-:interfere:~
序論:introduction:~
非推奨に:deprecate:~
非推奨:deprecated:~
強力:powerful:~
影響0:impact:影響
後方互換性:backwards-compatibility:~
後方互換:backwards compatible:~
恒久的:permanent:~
悪意的な:malicious:悪意のある
情報:information:~
意味-:mean:~
意味:meaning:~
意味論的:semantic:~
意図的:intentional:~
手続き:steps:~
拡張:extension:~
	拡張性:extensibility:~
拡張-:extend:~
指定-:specify:~
挙動する:behave する:ふるまう
挙動:behavior:ふるまい
明確さ:clarity:~
明確:clear:~
明確化-:clarify:~
明示的:explicit:~
暗黙的:implicit:~
最善:best:~
実質的:effective:~
有意:significant:~
有用:useful:~
望む:wish する:~
段:step:~
正確:exact:~
本当に:really:~
概観:overview:~
標準:standard:~
機能性:functionality:~
欠く:lack する:~
求める:want する:~
決定-:determine:~
無傷で:unscathed:~
無視-:ignore:~
特定0の:particular:ある特定の
	個々の
特定の:specific:~
特有の:-specific:~
特色機能:feature:~
提供-:provide:~
提供0-:offer:提供
改善:improvement:~
実行-:execute:~
実行:execution:~
	-:perform
具現化-:render:~
枠組み:framework:~:::フレームワーク
理由:reason:~
用法:usage:~
用語:term:~
発展:evolution:~
目指す:aim する:~
目指して:aim して:~
目標:goal:~
相応しい:suitable な:~
確保-:ensure:~
	必ず
等価:equivalent:~
答え:answer:~
	節:section:~
築く:build する:~
築ける:build できる:~
築上げる:build up する:築き上げる
実験-:experiment:~
結付けら:associate さ:結び付けら
統合-:integrate:~
統合:integration:~
統治-:govern:~
補助-:help:~
要件:requirements:~
要求-:require:~
	見出-:find:~
規制-:regulate:~
規範的:normative:~
規約:convention:~
詳細:detail:~
詳細な:detailed:~
app:application:::アプリ
考慮点:consideration:~
調整-:adjust:~
	論じら:discuss され
	討論:discussion:~
	謝辞:acknowledgement:~
警告:warning:~
登記簿:registry:::レジストリ
登録:registration:~
登録-:register:~
開発者:developer:~
関係:relation:~
関係する:related:~
	比してin relation to
需要:demand:~
	類似する:similar:~
	類似的:similar:~
駆動-:drive:~
	相応に:fairly:
待入する:queue する::待ち行列に入れる::キューする
含意:implications:~
著作上の:authoring:~
代用:replacement:~
提出:submission:~
信奉-:espouse:~
優先権:priority:~
	優先権を与える:advance the user’s priority
中核:core:~
	調節-:tweak:
反復的に:iterative fashion で:~
説明-:explain:~
単純:simple:~
手入力-:enter:~
特質:properties:~
疑義:suspect:~
所与の:given:与えられた
補佐的な:ancillary:~
勧める:suggest する:~
概念:concept:~
適度:reasonable:~
	策定-:land:~
状況:situations:~
旧来の:legacy:~
依拠-:rely:~
尊守-:honor:~
視野:scope:~
特別:special:~
先送り:defer:~
移譲-:delegate:~
正す:correct する:~
注意深い:careful な:~

	好例:good examples
	~~正しく保つ:get right
	すてき:lovely
	拡げ:expand
	広範:wide:~
	反した~goes against
	例えば,~for instance
	手短に言えば~In~short
	上手く~well
	価値が損われる significantly reducing their value
	そのため To that end
	整える set up
	~~述べられ:spell out
	策定中:in-flight
	それ自身のために／に利するために~behalf-ofに
	従う-:adhere:~
	~~決定を下す~make decisions
	~~決定:decisions
	~~外部wild:
	相当量substantial amount
	相当に:pretty
	判断が付いた~gained~confidence:::
	効果を~~発揮するgains meaning
	土台 ground up:
	いずれかに~~分類されるfall into one of several categories
	関わらず:regardless
	高次の:high-level
	緩め:loosen
	更なる:further
	書き直されrewritten:
	必要:need
	必要とされる:necessary
	同様に，:likewise
	今や:now
	今日:today
	何故なら:because
	~~働くserve
	に利するために ~behalf
	~~置き換えて~substituteして
	関わる＊~interesting
	あたられるべきought to be consulted:

	●
	寛容な permissive
	諸刃の剣:big hammer
	まとまりのない~sprawlings
	調べて~examine
	部位~portion
	繰り返し~iteration
	自身:itself:~
	呼び出し元~caller
	外部からの入力に対する注意深い検証／出力の安全な形への符号化-:careful input validation and output encoding
	~~渡し~~返すhanding the response back to

	その一片that bit
	尾部:trailing:~
	~~尾部の:rightmost::::
	頭部:leading:~
	一部:part-of:~
	両者:both:~
	各:each:~
	各種:various:~
	ある種の:certain:~
	いくつかの a number of
	おそらく:perhaps:~
	この:this:~
	これらの:these:~
	しかしながら:however:~
	すべての:all:~
	その:that:~
	それらの:those:~
	べき:should:~
	もっと良いbetter:
	より:more:~
	上:above:~
	与えて:giving:~
	二つの:two:~
	二番目の:second:~
	介:via:~
	他の:other:~
	他の場合:otherwise:~
	代わりに:instead:~
	何らかの仕方でin one way or another
	例えば，:for-example:~
	依然として:still:~
	別の:another:~
	則って:according:~
	前:before:~
	同じ:same:~
	含-:include:~
	含めて:including:~
	多くの:many:~
	始-:begin:~
	対抗:against:~
	少数の:few:~
	弱:weak:~
	後:after:~
	後者:latter:~
	得る:obtain:~
	手渡す:hand:~
	新たに:newly:~
	次の:the-following:~
	満たされ:met:~
	満たす:meet:~
	異なる:different:~
	結果:result:~
	結果の:resulting:~
	考-:think:~
	良い:good:~
	見よ:see:~
	返-:return:~
	述-:describe:~
	長い:long:~
	note::::
	respective:
	short:
	spell:
	time::::
	top::::
	true::::
	An:
	Can:
	Even:
	For:
	To:
	We:
	Moreover:
	When:
	accordingly:
	anyone:
	anything:
	avenue:
	awesome:
	back:
	behalf:::
	categories:
	consist:
	consisting:
	count:
	during:
	e-mail:e-mail:~
	end:
	everything:
	fall:
	feed:::
	~~最後のfinal:::
	finish:
	人々folks:
	gained:
	~~収集gather:
	get:
	having:
	叩くhit:
	implication:
	in-order-to:
	informative:
	least:
	looked:
	lot:
	moreover:
	moving:
	named:::
	nothing:::
	people:
	perfect:
	片:piece:::
	potential:::
	あり得る／得る:potentially:::
	preferably:::
	priority:
	おそらくprobably:
	public:::
	put:::
	neither:
	ought:::
	please:::
	redressing:
	remain:::
	said:
	seem:
	sequence:::
	一連のseries-of:
	several:::
	shouldn:
	something:
	stubbing:
	後続してsubsequent:
	such:::
	themselve:
	thing:::
	together:
	we:
	通じ:over:~

</script>

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
default-source-list:
restrict-activities:
allowed-sources:
ascii-case_insensitive:
element-attrdef-nonce:
any-source:
</script>

<!--%置換語 -->
<script type="text/plain" id="words_table1">
ES6:https://tc39.github.io/ecma262
	http://www.ecma-international.org/ecma-262/6.0/index.html
REPORTING:reporting1-ja.html
	https://w3c.github.io/reporting/
	https://mikewest.github.io/error-reporting/
SRI1:webappsec-subresource-integrity-ja.html

ACI:<a href="#ascii-case_insensitive" ><sub>大小無視</sub></a>

meta:<code class="element">meta</code> 
iframe-srcdoc:<code class="element">iframe</code> <code class="attr">srcdoc</code>

</script>

<!--%links -->

<!-- 

serialized policy
	serialized CSP
-->
<script type="text/plain" id="_link_map">

	grammardef
	pl.none:#grammardef-none
	pl.self:#grammardef-self
	pl.unsafe-eval:#grammardef-unsafe-eval
	pl.strict-dynamic:#grammardef-strict-dynamic
	pl.unsafe-inline:#grammardef-unsafe-inline
	p.ancestor-source-list:#grammardef-ancestor-source-list
	p.ancestor-source:#grammardef-ancestor-source
	p.base64-value:#grammardef-base64-value
	p.directive-name:#grammardef-directive-name
	p.directive-value:#grammardef-directive-value
	p.hash-algorithm:#grammardef-hash-algorithm
	p.hash-source:#grammardef-hash-source
	p.host-char:#grammardef-host-char
	p.host-part:#grammardef-host-part
	p.host-source:#grammardef-host-source
	p.keyword-source:#grammardef-keyword-source
	p.nonce-source:#grammardef-nonce-source
	p.path-part:#grammardef-path-part
	p.port-part:#grammardef-port-part
	p.scheme-part:#grammardef-scheme-part
	p.scheme-source:#grammardef-scheme-source
	p.serialized-directive:#grammardef-serialized-directive
	p.serialized-policy:#grammardef-serialized-policy
	p.serialized-source-list:#grammardef-serialized-source-list
	p.source-expression:#grammardef-source-expression

p.path:~IETF/rfc3986#section-3.3
p.scheme:~IETF/rfc3986#section-3.1
p.IPv4address:~IETF/rfc3986#section-3.2.2
p.uri-reference:~IETF/rfc3986#section-4.1
	~IETF/rfc5234#appendix-B.1
p.token:~IETF/rfc7230#section-3.2.6
	~IETF/rfc7230#section-3.2.3
P.ALPHA:#_ALPHA
P.DIGIT:#_DIGIT
P.VCHAR:#_VCHAR
P.OWS:#_OWS
P.RWS:#_RWS

~asterisk:#_asterisk
~semicolon:#_semicolon
~slash:#_slash
~period:#_period
	COMMA:#_COMMA

	dom

I.SecurityPolicyViolationEventInit:#dictdef-securitypolicyviolationeventinit
I.SecurityPolicyViolationEvent:#securitypolicyviolationevent
I.ServiceWorker:http://www.w3.org/TR/service-workers/#service-worker-interface
I.SharedWorker:~WORKERS#sharedworker
I.Worker:~WORKERS#worker
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.Window:~BROWSERS#dom-window
I.WebSocket:~WEBSOCKET#websocket
I.EventSource:~HTML5/comms.html#eventsource
I.XMLHttpRequest:~XHR#xmlhttprequest

要素:~DOM4#interface-element
	I.Element:~DOM4#interface-element
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
文書:~HTMLDOM#document
I.Document:~HTMLDOM#document

d.blockedURI:#dom-securitypolicyviolationeventinit-blockeduri
d.columnNumber:#dom-securitypolicyviolationeventinit-columnnumber
d.documentURI:#dom-securitypolicyviolationeventinit-documenturi
d.effectiveDirective:#dom-securitypolicyviolationeventinit-effectivedirective
d.lineNumber:#dom-securitypolicyviolationeventinit-linenumber
d.originalPolicy:#dom-securitypolicyviolationeventinit-originalpolicy
d.referrer:#dom-securitypolicyviolationeventinit-referrer
d.sourceFile:#dom-securitypolicyviolationeventinit-sourcefile
d.statusCode:#dom-securitypolicyviolationeventinit-statuscode
d.violatedDirective:#dom-securitypolicyviolationeventinit-violateddirective

m.Constructor:#dom-securitypolicyviolationevent-securitypolicyviolationevent
m.blockedURI:#dom-securitypolicyviolationevent-blockeduri
m.columnNumber:#dom-securitypolicyviolationevent-columnnumber
m.documentURI:#dom-securitypolicyviolationevent-documenturi
m.effectiveDirective:#dom-securitypolicyviolationevent-effectivedirective
m.lineNumber:#dom-securitypolicyviolationevent-linenumber
m.originalPolicy:#dom-securitypolicyviolationevent-originalpolicy
m.referrer:#dom-securitypolicyviolationevent-referrer
m.sourceFile:#dom-securitypolicyviolationevent-sourcefile
m.statusCode:#dom-securitypolicyviolationevent-statuscode
m.violatedDirective:#dom-securitypolicyviolationevent-violateddirective

	m.referrer:~HTMLDOM#dom-document-referrer
m.text:~HTMLSCRIPT#dom-script-text
m.textContent:http://www.w3.org/TR/dom/#dom-node-textcontent
	＊~DOM4
m.setInterval():~HTMLGAPI#dom-setinterval
m.setTimeout():~HTMLGAPI#dom-settimeout
m.document:~BROWSERS#dom-document-2
m.fetch():~FETCH#fetch-method

	m.cssText
	m.insertRule()

	v.type:#dom-securitypolicyviolationevent-securitypolicyviolationevent-type-eventinitdict-type
	v.eventInitDict:#dom-securitypolicyviolationevent-securitypolicyviolationevent-type-eventinitdict-eventinitdict

et.securitypolicyviolation:#_event-type-securitypolicyviolation

	dirctive
	dir.base-uri:#base-uri
	dir.child-src:#child-src
	dir.connect-src:#connect-src
	dir.default-src:#default-src
	dir.font-src:#font-src
	dir.form-action:#form-action
	dir.frame-ancestors:#frame-ancestors
	dir.img-src:#img-src
	dir.media-src:#media-src
	dir.object-src:#object-src
	dir.plugin-types:#plugin-types
	dir.report-uri:#report-uri
	dir.report-to:#report-to
	dir.sandbox:#sandbox
	dir.script-src:#script-src
	dir.style-src:#style-src

	dir.block-all-mixed-content
	dir.base-uri
	dir.form-action
	dir.frame-ancestors
	dir.plugin-types
	dir.sandbox
	dir.upgrade-insecure-requests


	■attr
a.content:~HTML50/document-metadata.html#attr-meta-content
a.data:~HTML5/embedded-content.html#attr-object-data
a.href:~HTML5/semantics.html#attr-base-href
a.http-equiv:~HTML50/document-metadata.html#attr-meta-http-equiv
a.nonce:~HTMLSCRIPT#attr-script-nonce
a.sandbox:~HTML5/embedded-content.html#attr-iframe-sandbox
	a.src:~HTML50/scripting-1.html#attr-script-src
a.ping:~HTML5/semantics.html#ping

	■elem
e.a:~HTML50/text-level-semantics.html#the-a-element
e.applet:~HTML50/obsolete.html#the-applet-element
e.base:~HTML50/document-metadata.html#the-base-element
e.embed:~HTML50/embedded-content-0.html#the-embed-element
e.iframe:~HTML50/embedded-content-0.html#the-iframe-element
e.link:~HTML50/document-metadata.html#the-link-element
e.meta:~HTML50/document-metadata.html#the-meta-element
e.object:~HTML50/embedded-content-0.html#the-object-element
e.script:~HTMLSCRIPT#the-script-element
e.style:~HTML50/document-metadata.html#the-style-element
e.frame:~HTML50/obsolete.html#frame

	■header
h.Content-Security-Policy:#header-content-security-policy
h.Content-Security-Policy-Report-Only:#header-content-security-policy-report-only
h.Link:~IETF/rfc5988#section-5

	■https://url.spec.whatwg.org/
u.IPv6~address:~URLSpec#concept-ipv6
u.~percent復号-:~URLSpec#percent-decode
u.~URL構文解析器:~URLSpec#concept-url-parser
u.~URL直列化器:~URLSpec#concept-url-serializer
	url.~URL:~URLSpec#url
u.URL:~URLSpec#url
u.既定~port:~URLSpec#default-port
u.生成元:~URLSpec#concept-url-origin
u.~host:~URLSpec#concept-url-host
u.~path:~URLSpec#concept-url-path
u.~port:~URLSpec#concept-url-port
u.~scheme:~URLSpec#concept-url-scheme
u.局所~scheme:~URLSpec#local-scheme
u.~network~scheme:~URLSpec#network-scheme

	■

	~CSP:#content-security-policy
~CSP~list:#global-object-csp-list
~fetch指令:#fetch-directives

処分先:#policy-disposition
違反~報告:#violation-report
vr.~referrer:#violation-referrer
vr.~source~file:#violation-source-file
vr.~url:#violation-url
vr.大域~obj:#violation-global-object
vr.施策:#violation-policy
vr.有効な指令:#violation-effective-directive
vr.状態code:#violation-status
vr.資源:#violation-resource
vr.列番号:#violation-column-number
vr.行番号:#violation-line-number

指令:#directives
指令~集合:#policy-directive-set
有効な指令:#request-effective-directive


埋込んでいる文書:#embedding-document
施行され:#enforced

~source~listに合致する:#matches-a-source-list
監視され:#monitored
名前:#directive-name
施策:#policy
直列化形の~source~list:#serialized-source-list
直列化形の指令:#serialized-directive
直列化形の~CSP:#serialized-csp
直列化-:#serialized-csp
~source式:#source-expression
~source~list:#source-lists
値:#directive-value
違反:#violation


~ABNF:#biblio-RFC5234

構文解析-時に挿入され:~HTMLSCRIPT#parser-inserted
	~HTML50/scripting-1.html#parser-inserted

■

施行-:#enforced
施行され:#enforced
監視-:#monitored
報告:#reports
~source式:#source-expression
報告先:~REPORTING#endpoint
	#directive-report-uri
報告先~group:~REPORTING#dom-report-group
	https://mikewest.github.io/error-reporting/#group
	端点:https://w3c.github.io/reporting/#endpoint


A.要請前~検査:#directive-pre-request-check
A.要請後~検査:#directive-post-request-check
A.応答~検査:#directive-response-check
A.~inline検査:#directive-inline-check
A.初期化:#directive-initialization
A.構文解析-:#parse-serialized-policy
A.直列化形の~CSPとして構文解析-:#parse-serialized-policy

A.直列化形の~CSP~listとして構文解析-:#parse-serialized-policy-list
A1.違反~objを作成-:#create-violation-for-global
A.違反~objを作成-:#create-violation-for-request
A.応答の~CSP~listを設定する:#set-response-csp-list

	sec.~CSP HTTP 応答~header:#csp-header
	sec.~Content-Security-Policy-Report-Only HTTP 応答~header:#cspro-header
	sec.~&lt;meta&gt; 要素:#meta-element
Fetch との統合:#fetch-integration
HTML との統合:#html-integration

A.要請は~CSPにより阻止されるべきか？:#should-block-request
A.要請に対する応答は~CSPにより阻止されるべきか？:#should-block-response
A.大域~objの~CSP~listを初期化する:#initialize-global-object-csp
A.要素における~inline型の挙動は~CSPにより阻止されるべきか？:#should-block-inline
A.直列化-（非推奨）:#deprecated-serialize-violation
A.違反を報告する:#report-violation
	＊A.~CSP指令:#csp-directives
A.~urlは~source~listに合致するか？:#match-url-to-source-list
A.~nonceは~source~listに合致するか？:#match-nonce-to-source-list
A.~urlは ( 生成元, ~redirect回数 ) について式に合致するか？:#match-url-to-source-expression
	A.要請に対する有効な指令を取得する:#effective-directive-for-a-request
A.有効な指令を取得-:#effective-directive-for-a-request
A.要素 は ( 型, ~source ) について~source~listに合致するか？:#match-element-to-source-list

A.基底は文書に対し許容されるか？:#allow-base-for-document
	複数の施策による効果:#multiple-policies
A.要請は施策に違反するか？:#does-request-violate-policy
A.文書の~CSP~listを初期化する:#initialize-document-csp
A.報告先~groupに対する~dataを待入する:~REPORTING#queue-report
	https://w3c.github.io/reporting/#queue-report
	https://mikewest.github.io/error-reporting/#queue-report


AO.HostEnsureCanCompileStrings:~ES6#sec-hostensurecancompilestrings
~realm:~ES6#realm

	@import:~CSSWG/css-cascade-4/#at-ruledef-import
doc.~CSP~list:~HTMLDOM#concept-document-csp-list
~CSP http-equiv 処理命令:~HTML5/#attr-meta-http-equiv-content-security-policy
base64 符号化-:~IETF/rfc4648#section-4

c.Function():http://www.ecma-international.org/ecma-262/6.0/index.html#sec-function-objects
c.JSON.stringify():http://www.ecma-international.org/ecma-262/6.0/index.html#sec-json.stringify
c.eval():http://www.ecma-international.org/ecma-262/6.0/index.html#sec-eval-x

	●fetch
~fetch:~FETCH#concept-fetch
~HTTP~fetch:~FETCH#http-fetch
~HTTP-network~fetch:~FETCH#http-network-fetch
~main~fetch:~FETCH#main-fetch
~header~list:~FETCH#concept-header-list
~network~error:~FETCH#concept-network-error
A.~header値を構文解析-:~FETCH#concept-header-parse

応答:~FETCH#concept-response
rs.~CSP~list:~FETCH#concept-response-csp-list
rs.~header~list:~FETCH#concept-response-header-list
rs.~url:~FETCH#concept-response-url

要請:~FETCH#concept-request
rq.本体:~FETCH#concept-request-body
rq.~cache~mode:~FETCH#concept-request-cache-mode
rq.~client:~FETCH#concept-request-client
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.現在の~url:~FETCH#concept-request-current-url
rq.行先:~FETCH#concept-request-destination
	＊
rq.大域~obj:~FETCH#concept-request-global-object
rq.~header~list:~FETCH#concept-request-header-list
rq.起動元:~FETCH#concept-request-initiator
rq.~method:~FETCH#concept-request-method
rq.生成元:~FETCH#concept-request-origin
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.種別:~FETCH#concept-request-type
rq.~url:~FETCH#concept-request-url
rq.~window:~FETCH#concept-request-window
rq.~target閲覧文脈:~FETCH#concept-request-target-browsing-context
rq.暗号用~nonce~metadata:~FETCH#concept-request-nonce-metadata
rq.構文解析器~metadata:~FETCH#concept-request-parser-metadata
rq.完全性~metadata:~FETCH#concept-request-integrity-metadata

~URL:~DOM4#concept-document-url

CSS 規則を挿入する:~CSSOM#insert-a-css-rule
CSS 規則を構文解析する:~CSSOM#parse-a-css-rule
選択子の~groupを構文解析する:~CSSOM#parse-a-group-of-selectors
CSS 宣言~blockを構文解析する:~CSSOM#parse-a-css-declaration-block


閲覧文脈:~BROWSERS#browsing-context
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-context
開いた閲覧文脈:~BROWSERS#opener-browsing-context
通して入子に:~BROWSERS#browsing-context-nested-through
Unicode 直列化-:~BROWSERS#unicode-serialisation-of-an-origin
作動中の文書:~BROWSERS#active-document
~sandbox用~指令を構文解析-:~BROWSERS#parse-a-sandboxing-directive
強制~sandbox用~flag集合:~BROWSERS#forced-sandboxing-flag-set
閲覧文脈~sandbox化( 生成元 )~flag:~BROWSERS#sandboxed-origin-browsing-context-flag
閲覧文脈~sandbox化( ~script )~flag:~BROWSERS#sandboxed-scripts-browsing-context-flag


~iframe-srcdoc文書:~HTML5/embedded-content.html#an-iframe-srcdoc-document

x.文書:~WORKERS#the-worker's-documents
	'
	~HTML5/#the-workers-documents

~incumbent設定群~obj:~WAPI#incumbent-settings-object
大域~obj:~WAPI#concept-settings-object-global
realm.大域~obj:~WAPI#concept-realm-global
	~WAPI#concept-realm-global-object

新たな文書~objを初期化する:~HTML5/browsers.html#initialise-the-document-object
	#initialising-a-new-document-object


生成元:~IETF/rfc6454#section-3.2
	＊
~scriptを準備する:~HTML50/scripting-1.html#prepare-a-script
	＊~WAPI#prepare-to-run-a-callback
~event~handler内容~属性:~WAPI#event-handler-content-attributes
~event~handler IDL 属性:~WAPI#event-handler-idl-attributes
関連する設定群~obj:~WAPI#relevant-settings-object
	~HTML50/webappapis.html#relevant-settings-object-for-a-global-object
表現:~IETF/rfc7231#section-3
資源~表現:~IETF/rfc7231#section-3

~workerを走らす:~WORKERS#run-a-worker
凍結された基底~URLを設定する:~HTML5/semantics.html#set-the-frozen-base-url
	/document-metadata.html#set-the-frozen-base-url

ASCII 文字大小無視:~HTMLINFRA#ascii-case-insensitive
ASCII 小文字化:~HTMLINFRA#converted-to-ascii-lowercase
発火-:~HTMLINFRA#concept-event-fire
頭部と尾部の空白を剥いだ:~HTMLINFRA#strip-leading-and-trailing-whitespace
	~case-sensitive:~HTMLINFRA#case-sensitive
文字~並びを収集-:~HTMLINFRA#collect-a-sequence-of-characters
空白類:~HTMLINFRA#space-character
~commaで分割-:~HTMLINFRA#split-a-string-on-commas
~spaceで分割-:~HTMLINFRA#split-a-string-on-spaces
厳密に分割-:~HTMLINFRA#strictly-split-a-string
~trusted:~HTMLINFRA#concept-event-trusted

~style~blockを更新する:~HTML5/semantics.html#update-a-style-block
	https://html.spec.whatwg.org/#update-a-style-block

SHA-256:http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf#
SHA-384:http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf#
SHA-512:http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf#

~metadataを構文解析-:~SRI1#parse-metadata
	http://www.w3.org/TR/SRI/#parse-metadata
	https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata

~HTTP状態code
~HTTP要請
~HTTP応答~header

</script>

<!--%style -->
<style>
*[lang="en"] {
	white-space: pre-line;
}

.directive {
	color: #824;
}

.report {
	color: green;
}

.scheme {
	color: #006633;
}

.abstract {
	color: green;
}

.error {
	color: green;
}

samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

pre.http-code {
	background: #EEE;
}
pre.html-code {
	background: #FFE;
}

.idl-def > dt {
	font-family: monospace0, monospace;
}

i {
	color: purple;
}

</style>

</head>

<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>Content Security Policy Level 3 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">Content Security Policy Level 3</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2016-07-07</time>
（公開：<time>2015-12-12</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>
	<hgroup>
<h1 id="title">Content Security Policy Level 3</h1>
<h2 id="subtitle">2016 年 7 月 7 日付 編集者草案</h2>
	</hgroup>
<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dt title="Editor’s Draft:">編集者草案</dt>
	<dd>https://w3c.github.io/webappsec-csp/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>https://www.w3.org/TR/CSP3/</dd>

	<dt title="Previous Versions:">以前のバージョン</dt>
	<dd>http://www.w3.org/TR/2016/WD-CSP3-20160621/</dd>

	<dt title="Version History:">バージョン履歴</dt>
	<dd>https://github.com/w3c/webappsec-csp/commits/master/index.src.html</dd>

	<dt title="Feedback:">フィードバック</dt>
	<dd><a href="mailto:public-webappsec@w3.org?subject=%5BCSP3%5D%20YOUR%20TOPIC%20HERE">public-webappsec@w3.org</a> with subject line “<kbd>[CSP3] <i data-lt="">… message topic …</i></kbd>” (<a href="http://lists.w3.org/Archives/Public/public-webappsec/" rel="discussion">archives</a>)</dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="mailto:mkwst@google.com">Mike West</a> (Google Inc.)</dd>

	<dt>Participate:</dt>
	<dd><a href="https://github.com/w3c/webappsec-csp/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-csp/issues">open issues</a>)</dd>
</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
</small>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この文書は、特定0の~pageが どの資源を~fetchあるいは実行できるか，および
保安に関連する数々の施策~~決定について，~web開発者が制御できる仕組みを定義する。
◎
This document defines a mechanism by which web developers can control the resources which a particular page can fetch or execute, as well as a number of security-relevant policy decisions.
</p>


	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<!-- 
この節では、発行時点における…
-->
これは編集者草案の~~公開の複製です…
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>
に委譲
】</span></p>

<p>
<strong>
この文書に対する変更点は、
<a href="https://github.com/w3c/webappsec">https://github.com/w3c/webappsec</a>
に。
</strong>
◎
Changes to this document may be tracked at https://github.com/w3c/webappsec.
</p>

<p>
この仕様に関する討論の場は、冒頭の “フィードバック” に挙げた ML にて。
◎
The (archived) public mailing list public-webappsec@w3.org (see instructions) is preferred for discussion of this specification. When sending e-mail, please put the text “CSP3” in the subject, preferably like this: “[CSP3] …summary of comment…”
</p>

<p>
この文書は、
<a href="http://www.w3.org/2011/webappsec/">Web Application Security Working Group</a>
作業草案として制作されました。
◎
This document was produced by the Web Application Security Working Group.
</p>


	</section>


<nav class="toc" id="contents">
<h2 class="toc">目次</h2>
<ol id="_toc_list0"></ol></nav>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
この文書は、
<dfn id="content-security-policy">Content Security Policy</dfn>
 （略称 CSP
— “内容~保安~施策”, または単に “施策”
）を定義する†。
それは、開発者が自身の~appを種々の仕方で監禁して，［
XSS （ cross-site scripting ）などに対する内容~注入~脆弱性の~riskを軽減する ／ ~appを実行する際に用いる特権を抑制する
］ために利用できる~toolである。
◎
This document defines Content Security Policy (CSP), a tool which developers can use to lock down their applications in various ways, mitigating the risk of content injection vulnerabilities such as cross-site scripting, and reducing the privilege with which their applications execute.
</p>

<p class="trans-note">【†
この訳では、原文の［
“Content Security Policy” ／ “content security policy” ／ “CSP”
］を，一律に “CSP” と記すことにする。
】</p>

<p>
~CSPは、内容~注入の脆弱性に対抗する前線防御として意図されたものではなく、多層防御としての利用に最も適する。
【すなわち、注入そのものを防ぐのでなく，注入されたものが効果を及ぼすのを防ぐ。】
それは、悪意的な注入により生じ得る被害を抑制するが、外部からの入力に対する注意深い検証や，出力の安全な形への符号化-
【すなわち，前線防御】
の代用になるものではない。
◎
CSP is not intended as a first line of defense against content injection vulnerabilities. Instead, CSP is best used as defense-in-depth. It reduces the harm that a malicious injection can cause, but it is not a replacement for careful input validation and output encoding.
</p>

<div class="p">
<p>
この文書は，~CSP Level 2 の繰り返しであるが、次の二点を目標にしている：
</p>

<ul>
	<li>
CSP, HTML, Fetch
間の相互作用を より明確に説明する。
</li>
	<li>
~modularに拡張するための明確な各種~hookを提供する。
</li>
</ul>

<p>
これは、理想的には、安定的な中核を形成して，その上に新たな機能性を築けるようにする。
</p>

◎
This document is an iteration on Content Security Policy Level 2, with the goal of more clearly explaining the interactions between CSP, HTML, and Fetch on the one hand, and providing clear hooks for modular extensibility on the other. Ideally, this will form a stable core upon which we can build new functionality.
</div>

		<section id="examples">
<h3 title="Examples">1.1. 例</h3>

			<section id="example-basic">
<h4 title="Control Execution">1.1.1. 実行~制御</h4>

<div class="example">

<p>
MegaCorp Inc の~web開発者たちは、 XSS 攻撃に対抗して保護することが求められているとする。
彼らが信用する CDN の生成元から読込まれる~scriptのみ，実行-可能にすることにより、~script注入による~riskを軽減できる。
加えて、彼らの~pageの文脈~下では，どの~pluginも実行させなくしたいとする。
そのような効果は、次の施策で得られる：
◎
MegaCorp Inc’s developers want to protect themselves against cross-site scripting attacks. They can mitigate the risk of script injection by ensuring that their trusted CDN is the only origin from which script can load and execute. Moreover, they wish to ensure that no plugins can execute in their pages' contexts. The following policy has that effect:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `script-src$dir https://cdn.example.com/scripts/;
    `object-src$dir `none$pl
</pre>

<p class="trans-note">【
長い行を~page横幅に収める都合により、この訳~全体を通して， HTTP ~headerの例示~codeでは、一律に，長い行は折り返した上で，字下げした形で示す
— HTTP/1.1 の構文としては、折返しは許容されないことに注意。
】</p>

</div>



			</section>
		</section>
		<section id="goals">
<h3 title="Goals">1.2. 目標</h3>

<p>
~CSPが目指すものは：
◎
Content Security Policy aims to do to a few related things:
</p>

<ol>
	<li>
<p>
内容~注入~攻撃による~riskを軽減するような，次についての相応に細かい制御を、~web開発者に与える：
◎
Mitigate the risk of content-injection attacks by giving developers fairly granular control over
</p>
		<ul>
			<li>
特定の `文書$ や `Worker$I が，それ自身のために どの資源を要請できるか（および，後続して 自身に埋込めるか／実行できるか）について。
◎
The resources which can be requested (and subsequently embedded or executed) on behalf of a specific Document or Worker
</li>
			<li>
~inline~scriptの実行。
◎
The execution of inline script
</li>
			<li>
動的な（ `eval()^c その他の類似する構成子を介する）~code実行。
◎
Dynamic code execution (via eval() and similar constructs)
</li>
			<li>
~inline~styleの適用。
◎
The application of inline style
</li>
		</ul>
	</li>
	<li>
所与の資源を埋込めるような生成元についての細かい制御を，~web開発者に与えて、資源が悪意的な文脈~内に埋込まれることを要するような攻撃（ `TIMING$r に述べられた “Pixel Perfect” 攻撃, 等々）による~riskを軽減する。
◎
Mitigate the risk of attacks which require a resource to be embedded in a malicious context (the "Pixel Perfect" attack described in [TIMING], for example) by giving developers granular control over the origins which can embed a given resource.
</li>
	<li>
［
開発者が自身の~appの特権を抑制できるようにする
］ための，施策の枠組みを提供する。
◎
Provide a policy framework which allows developers to reduce the privilege of their applications.
</li>
	<li>
［
~~外部から悪用されている欠陥を，~web開発者が検知できるようにする
］ための，報告処理の仕組みを提供する。
◎
Provide a reporting mechanism which allows developers to detect flaws being exploited in the wild.
</li>

</ol>



		</section>
		<section id="changes-from-level-2">
<h3 title="Changes from Level 2">1.3. ~level 2 からの変更点</h3>

<p>
この文書は、~CSP Level 2 仕様からの発展を述べる。
`CSP2$r からの変更点についての，高次からの概観は：
◎
This document describes an evolution of the Content Security Policy Level 2 specification [CSP2]. The following is a high-level overview of the changes:
</p>

<ol>
	<li>
仕様は、他の仕様（特に Service Worker ）が，~CSPの各種 要件と制約を より単純に統合できるようにすべく、
`FETCH$r 仕様の用語を通して，~~土台から書き直された。
◎
The specification has been rewritten from the ground up in terms of the [FETCH] specification, which should make it simpler to integrate CSP’s requirements and restrictions with other specifications (and with Service Workers in particular).
</li>
	<li>
CSP Level 2 で非推奨にされた `frame-src$dir 指令は，非推奨でなくなり、 `worker-src$dir が追加された。
両者とも無い場合は `child-src$dir に先送りする（それも無い場合は `default-src$dir に先送りする）。
◎
The frame-src directive, which was deprecated in CSP Level 2, has been undeprecated, and a worker-src directive added. Both defer to child-src if not present (which defers to default-src in turn).
</li>
	<li>
<p>
~URL照合~algoは、今や
非保安的［
~scheme／~port
］を その保安的~scheme版に合致するように扱う。
すなわち、`~source式$
`http://example.com:80^s
は
`http://example.com:80^s,
`https://example.com:443^s
の両者に合致することになる。
◎
The URL matching algorithm now treats insecure schemes and ports as matching their secure variants. That is, the source expression http://example.com:80 will match both http://example.com:80 and https://example.com:443.
</p>

<p>
同様に `self$pl は、
`http^sc ~schemeの~page上であっても，［
~pageの生成元の~schemeを［
`https^sc ／ `wss^sc
］に置き換えた生成元
］にも合致するようにされた。
◎
Likewise, 'self' now matches https: and wss: variants of the page’s origin, even on pages whose scheme is http.
</p>
	</li>


<li>
~inlineの［
~script／~style
］から生成される違反~報告は、今や 阻止された`資源$vrとして `inline^l を報告するようになった。
同様に，阻止された `eval()^c 実行は、阻止された`資源$vrとして `eval^l を報告するようになった。
◎
Violation reports generated from inline script or style will now report "inline" as the blocked resource. Likewise, blocked eval() execution will report "eval" as the blocked resource.
</li>
	<li>
`manifest-src$dir 指令が追加された。
◎
The manifest-src directive has been added.
</li>
	<li>
新たな `report-to$dir 指令への支持を受けて、
`report-uri$dir 指令は非推奨にされた。
`report-to^dir は、基盤として `OOB-REPORTING$r に依拠する。
◎
The report-uri directive is deprecated in favor of the new report-to directive, which relies on [OOB-REPORTING] as infrastructure.
</li>
	<li>
`strict-dynamic^pl ~source式は、今や［
~page上で実行する~scriptが、`構文解析-時に挿入され$たものでない `script$e 要素を介して，更に~scriptを読込む
］ことを許容する。
詳細は
<a href="#strict-dynamic-usage">`strict-dynamic^pl の用法</a>
節に。
◎
The 'strict-dynamic' source expression will now allow script which executes on a page to load more script via non-parser-inserted script elements. Details are in §8.2 Usage of "'strict-dynamic'".
</li>
	<li>
`unsafe-hashed-attributes$pl ~source式は、今や［
~event~handlerや~style属性が，~hash~source式に合致する
］ことを許容する。
詳細は
<a href="#unsafe-hashed-attributes-usage">`unsafe-hashed-attributes^pl の用法</a>
節に。
◎
The 'unsafe-hashed-attributes' source expression will now allow event handlers and style attributes to match hash source expressions. Details in §8.3 Usage of "'unsafe-hashed-attributes'".
</li>
	<li>
`~source式$の照合では、`局所~scheme$uのみならず，どの非`~network~scheme$uも，明示的に~whitelist化することが要求されるようになった
— `~urlは ( 生成元, ~redirect回数 ) について式に合致するか？$A
を見よ。
◎
The source expression matching has been changed to require explicit whitelisting of any non-network scheme, rather than local scheme, as described in §6.1.13.4 Does url match expression in origin with redirect count?.
</li>
	<li>
~hashに基づく~source式は、今や，外部~scriptを~whitelist化できる
— 要請を誘発する当の `script$e 要素に［
現在の施策により~whitelist化されている完全性~metadataの集合
］を指定することで。
詳細は、
<a href="#external-hash">外部~JSに対する~hashによる~whitelist化</a>
節を見よ。
◎
Hash-based source expressions may now whitelist external scripts if the script element that triggers the request specifies a set of integrity metadata which is whitelisted by the current policy. Details in §8.4 Whitelisting external JavaScript with hashes.
</li>

</ol>


		</section>
		<section id="open-questions">
<h3 title="Open Questions">1.4. ~~公開の問い</h3>

<p class="issue">
報告-時には，依然として値を剥ぐ必要はあるのか？
編集者は、阻止された`資源$vrに対しては，その元の~URLを利用することにより，~~大方の~riskは除去されたと考えている
— 報告 JSON 内には、［
~scriptが~~自前で DOM を~~走査して~~収集できないもの
］はないはずである。
◎
Do we still need to strip values when reporting? I think we’ve removed much of the risk by using the original URL of a blocked resource; there shouldn’t be anything in the report JSON that script can’t gather on its own by walking the DOM.
</p>

		</section>
	</section>
	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
記号［
~EQ, ~NEQ, ~IN, ~NIN
］に添えられる
“<dfn id="ascii-case_insensitive"><sub>大小無視</sub></dfn>”
は、記号の意味を `ASCII 文字大小無視$による比較に基づくように改めることを表す。
</p>

<p>
特に断らない限り、文字列の比較は文字大小区別とする。
</p>

<p>
~protocol要素
`ALPHA@P,
`DIGIT@P,
`VCHAR@P
は、
`RFC5234$r
<a href="~IETF/rfc5234#appendix-B.1">B.1 節</a>
にて定義される。
~protocol要素
`OWS@P,
`RWS@P,
は、 `RFC7230$r
<a href="~IETF/rfc7230#section-3.2.3">3.2.3 節</a>
にて定義される。
</p>


<p>
次の符号位置も利用される：
</p>

<table>
<thead><tr><th>表記
</th><th>符号位置

<tbody><tr><th>`~asterisk@
</th><td>U+002A ASTERISK ( `*^l )

</td></tr><tr><th>`~semicolon@
</th><td>U+003B SEMICOLON ( `;^l )

</td></tr><tr><th>`~slash@
</th><td>U+002F SOLIDUS ( `/^l )

</td></tr><tr><th>`~period@
</th><td>U+002E FULL STOP ( `.^l )

<!-- 
</td></tr><tr><th>~comma
</th><td>U+002C COMMA ( `,^l )

</td></tr><tr><th>~space
</th><td>U+0020 SPACE ( `,^l )
 -->

</td></tr></tbody></table>

<p>
次の~styleが表記に用いられる：
</p>

<ul>
	<li>
`production^p
— ~protocol要素（ ABNF 生成規則）
</li>
	<li>
`example-directive$dir
— ~CSP `指令$
</li>
	<li>
`literal^lt
— 文字列~literal（引用符は~dataに含まれない）
</li>
	<li>
`literal^pl
— 文字列~literal。
引用符も~dataに<em >含まれる</em>。
</li>
	<li>
`Example-Header^h
— HTTP ~header名
</li>
	<li>
`element^e
— HTML 要素
</li>
	<li>
`attribute^a
— HTML 内容~属性
</li>
	<li>
`idl-construct^I
— 他の~code類（ IDL 属性など）
</li>
	<li>
`sample-code^s
— （地の文の中の）見本~code類
</li>
</ul>

<p>
長い行を~page横幅に収める都合により、 HTTP ~headerの例示~codeでは、長い行は折り返した上で，字下げした形で示される
— HTTP/1.1 の構文としては、折返しは許容されないことに注意。
</p>

	</section>
	<section id="framework">
<h2 title="Framework">2. 枠組み</h2>

		<section id="framework-policy">
<h3 title="Policies">2.1. 施策</h3>

<p>
`施策@
は、［
許容される／制約される
］挙動の集合を定義する。
それは、［
`大域~objの~CSP~listを初期化する$A~algo
］に従って［
`Window$I ／ `WorkerGlobalScope$I
］に適用し得る。
◎
A policy defines a set of allowed and restricted behaviors, and may be applied to a Window or WorkerGlobalScope as described in §4.2.2 Initialize a global object’s CSP list.
</p>

<p>
各~施策には、次のものが結付けられる：
◎
↓</p>

<dl>
	<dt>`指令~集合@ （ directive set ）</dt>
	<dd>
この施策が適用されるときの含意を定義する，`指令$の集合。
◎
Each policy has an associated directive set, which is a set of directives that define the policy’s implications when applied.
</dd>

	<dt>`処分先@ （ disposition ）</dt>
	<dd>
次のいずれか：
`enforce^l ／ `report^l
◎
Each policy has an associated disposition , which is either "enforce" or "report".
</dd>
	<dd class="trans-note">【
順に，施策を［
施行する／報告する
］ことに対応する。
】</dd>

	<dt>`直列化形の~CSP@ （ serialized CSP ）</dt>
	<dd>
一連の`直列化形の指令$を`~semicolon$で区切って連結した， ASCII 文字列であり、次の`~ABNF$文法に従う：
◎
A serialized CSP is an ASCII string, consisting of a semicolon-delimited series of serialized directives, adhering to the following ABNF grammar [RFC5234]:
</dd>

</dl>

<pre class="ABNF">
`serialized-policy@p =
      `serialized-directive$p
      *( `OWS$P ";" [ `OWS$P `serialized-directive$p ] )
; OWS is defined in section 3.2.3 of RFC 7230
</pre>

			<section id="parse-serialized-policy">
<h4 title="Parse a serialized CSP as disposition">2.1.1. `直列化形の~CSP^v を %処分先 向けに構文解析する</h4>

<p>
次の~algoは、所与の
( `直列化形の~CSP$ `直列化形の~CSP^v, `処分先$ %処分先 )
に対し，`施策$ ~objを返す。
構文解析できない場合、結果の`施策$の`指令~集合$は空になる：
◎
Given a serialized CSP (serialized CSP), and a disposition (disposition), this algorithm will return a policy object. If the string cannot be parsed, the resulting policy’s directive set will be empty.
</p>

<ol>
	<li>
%施策 ~LET 次のようにされた，新たな`施策$
⇒
`指令~集合$ ~SET 空,<br>
`処分先$ ~SET %処分先
◎
Let policy be a new policy with an empty directive set, and a disposition of disposition.
</li>
	<li>
<p>
~FOR ［
`直列化形の~CSP^v を`~semicolon$で`厳密に分割-$した結果
］内の ~EACH ( %~token ) に対し：
◎
For each token returned by strictly splitting serialized CSP on the U+003B SEMICOLON character (;):
</p>
		<ol>
			<li>
%~token ~SET %~token から`頭部と尾部の空白を剥いだ$結果
◎
Strip leading and trailing whitespace from token.
</li>
			<li>
~IF［
%~token ~EQ 空~文字列
］
⇒
~CONTINUE
◎
If token is an empty string, skip the remaining substeps and continue to the next item.
</li>
			<li>
%指令~名 ~LET
%~token から`空白類$でない`文字~並びを収集-$した結果
◎
Let directive name be the result of collecting a sequence of characters from token which are not space characters.
</li>
			<li>
<p>
~IF［
%施策 の
`指令~集合$は［
`名前$ ~EQ %指令~名
］なる`指令$を包含する
］
⇒
~CONTINUE
◎
If policy’s directive set contains a directive whose name is directive name, skip the remaining substeps and continue to the next item.
</p>

<p>
~UAは、指令が無視されたことを~web開発者に通知する~SHOULDである。
例えば，~consoleによる警告が適切になるであろう。
◎
The user agent SHOULD notify developers that a directive was ignored. A console warning might be appropriate, for example.
</p>
			</li>
			<li>
%指令~値 ~LET %~token を`~spaceで分割-$した結果
◎
Let directive value be the result of splitting token on spaces.
</li>
			<li>
次のようにされた新たな `指令$を %施策 の`指令~集合$に追加する
⇒
`名前$ ~SET %指令~名,<br />
`値$ ~SET %指令~値
◎
Let directive be a new directive whose name is directive name, and value is directive value.
◎
Add directive to policy’s directive set.
</li>
		</ol>
	</li>
	<li>
~RET %施策
◎
Return policy.
</li>
</ol>



			</section>
			<section id="parse-serialized-policy-list">
<h4 title="Parse a serialized CSP list as disposition">2.1.2. 直列化形の %~CSP~listを %処分先 向けに構文解析する</h4>

<p>
次の~algoは、所与の
( 一連の`直列化形の~CSP$文字列からなる~comma区切りの文字列 %~list, `処分先$ %処分先 )
に対し，`施策$~objの~listを返す：
◎
Given a string (list) and a disposition (disposition) which contains a comma-delimited series of serialized CSP strings, the following algorithm will return a list of policy objects:
</p>

<ol>
	<li>
`施策たち^v ~LET 空~list
◎
Let policies be an empty list.
</li>
	<li>
<p>
~FOR ［
%~list を`~commaで分割-$した結果
］内の ~EACH ( %~token ) に対し：
◎
For each token returned by splitting list on commas:
</p>
		<ol>
			<li>
%施策 ~LET［
( %~token, %処分先 )
を入力に，`直列化形の~CSPとして構文解析-$Aした結果
］
◎
Let policy be the result of executing §2.1.1 Parse a serialized CSP as disposition on token with disposition.
</li>
			<li>
~IF［
%施策 の`指令~集合$は空である
］
⇒
~CONTINUE
◎
If policy’s directive set is empty, skip the remaining substeps, and continue to the next item.
</li>
			<li>
%施策 を `施策たち^v に追加する
◎
Add policy to policies.
</li>
		</ol>
	</li>
	<li>
~RET `施策たち^v
◎
Return policies.
</li>
</ol>



			</section>
		</section>
		<section id="framework-directives">
<h3 title="Directives">2.2. 指令</h3>

<p>
各`施策$は、いくつかの
`指令@
からなる集合を包含する
— そのそれぞれは、特定の挙動を制御する。
この文書にて定義される各種~指令の詳細は、
<a href="#csp-directives">~CSP指令</a>
節にて述べられる。
◎
Each policy contain a set of directives, each of which controls a specific behavior. The directives defined in this document are described in detail in §6 Content Security Policy Directives.
</p>

<p>
各
`指令$は［
`名前@,
`値@
］の~pairである。
`名前$は 空でない文字列であり，`値$は［
空でない文字列
］からなる集合である。
`値$は空~集合でも~MAY。
◎
Each directive is a name / value pair. The name is a non-empty string, and the value is a set of non-empty strings. The value set MAY be empty.
</p>

<p>
`直列化形の指令@
は、次の`~ABNF$文法に従うような，空白~区切りの，一個以上の~tokenからなる ASCII 文字列である：
◎
A serialized directive is an ASCII string, consisting of one or more whitespace-delimited tokens, and adhering to the following ABNF [RFC5234]:
</p>

<pre class="ABNF">
`serialized-directive@p = `directive-name$p [ `RWS$P `directive-value$p ]
`directive-name@p       = 1*( `ALPHA$P / `DIGIT$P / "-" )
`directive-value@p      = *( `09^hex / `20^hex-`2B^hex / `2D^hex-`3A^hex / `3C^hex-`7E^hex )

; Directive values may contain whitespace and VCHAR characters,
; excluding ";" and ","
; RWS is defined in section 3.2.3 of RFC7230. ALPHA, DIGIT, and
; VCHAR are defined in Appendix B.1 of RFC 5234.
</pre>

<p>
指令~値（ `directive-value$p ）は、空白, および［
`;^l, `,^l
を除く `VCHAR$P
］を包含し得る。
</p>

<p>
各 `指令$には、【その種別ごとに】次の~algoが結付けられる：
◎
Directives have five associated algorithms:
</p>

<dl class="def-list">
	<dt>`要請前~検査@A</dt>
	<dd>
( `要請$, `施策$ )
を引数にとり，
`要請は~CSPにより阻止されるべきか？$A
の間に実行される。
他から指定されない限り†，この~algoは `許容ed^i を返す。
【†当の指令に対し，~algoが定義されていない場合には。以下同様。】
◎
A pre-request check, which takes a request and a policy as an argument, and is executed during §4.1.3 Should request be blocked by Content Security Policy?. This algorithm returns "Allowed" unless otherwise specified.
</dd>

	<dt>`要請後~検査@A</dt>
	<dd>
( `要請$, `応答$, `施策$ )
を引数にとり,
`要請に対する応答は~CSPにより阻止されるべきか？$A
の間に実行される。
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
A post-request check, which takes a request, a response, and a policy as arguments, and is executed during §4.1.4 Should response to request be blocked by Content Security Policy?. This algorithm returns "Allowed" unless otherwise specified.
</dd>

	<dt>`応答~検査@A</dt>
	<dd>
( `要請$, `応答$, `施策$ )
を引数にとり，
`要請に対する応答は~CSPにより阻止されるべきか？$A
の間に実行される。
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
A response check, which takes a request, a response, and a policy as arguments, and is executed during §4.1.4 Should response to request be blocked by Content Security Policy?. This algorithm returns "Allowed" unless otherwise specified.
</dd>

	<dt>`~inline検査@A</dt>
	<dd>
( `要素$, 型~文字列, ~source文字列 )
を引数にとり，
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
の間に実行される。
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
An inline check, which takes an Element a type string, and a soure string as arguments, and is executed during §4.2.3 Should element’s inline type behavior be blocked by Content Security Policy?. This algorithm returns "Allowed" unless otherwise specified.
</dd>

	<dt>`初期化@A</dt>
	<dd>
( ［
`文書$または `大域~obj$
］, `応答$ , `施策$ )
を引数にとり，`文書の~CSP~listを初期化する$A間に実行される。
他から指定されない限り，この~algoは何もしない。
◎
An initialization, which takes a Document or global object, a response, and a policy as arguments. This algorithm is executed during §4.2.1 Initialize a Document's CSP list, and has no effect unless otherwise specified.
</dd>

</dl>



			<section id="framework-directive-source-list">
<h4 title="Source Lists">2.2.1. ~source~list</h4>

<p>
各種 `指令$のうち，多くのものは、
`~source~list@
（ `serialized-source-list$p ）をその`値$にとる。
各`~source~list$は、~tokenの集合である
— その各~tokenは、［
~fetchし得る内容であって［
埋込まれ得る／実行され得る
］もの
］を識別するような，次のいずれかの型の
`~source式@
（ `source-expression$p ）を表現する：
◎
Many directives' values consist of source lists: sets of tokens which identify content that can be fetched and potentially embedded or executed. These tokens represent one of the following types of source expression:
</p>


<ul>
	<li>
~keyword `none$pl （何にも合致しない）
◎
↓</li>
	<li>
他の~keyword（ `keyword-source$p ）
— 例えば
⇒
`self$pl （現在の~URLの生成元に合致する）
◎
Keywords such as 'none' and 'self' (which match nothing and the current URL’s origin, respectively)
</li>
	<li>
直列化形の~URL（ `scheme-part$p を伴う `host-source$p ）
— 例えば
⇒
`https://example.com/path/to/file.js^s
（特定の資源に合致する）や,
`https://example.com/^s
（その生成元に属する どの資源にも合致する）
◎
Serialized URLs such as https://example.com/path/to/file.js (which matches a specific file) or https://example.com/ (which matches everything on that origin)
</li>
	<li>
~scheme（ `scheme-source$p ）は、指定された~schemeを持つ どの資源にも合致する
— 例えば
⇒
`https:^s
◎
Schemes such as https: (which matches any resource having the specified scheme)
</li>
	<li>
~host（ `scheme-part$p を伴わない `host-source$p ）
— 例えば
⇒
`example.com^s （~schemeに関わらず，その~host上の どの資源にも合致する）や,
`*.example.com^s （その［
~host, および その下位domain（下位domainの下位domain, 等々も含む）
］上の どの資源にも合致する）

◎
Hosts such as example.com (which matches any resource on the host, regardless of scheme) or *.example.com (which matches any resource on the host or any of its subdomains (and any of its subdomains' subdomains, and so on))
</li>
	<li>
~nonce（ `nonce-source$p ）は、~page上の特定の要素に合致し得る
— 例えば
⇒
`nonce-qwertyu12345^pl
◎
Nonces such as 'nonce-qwertyu12345' (which can match specific elements on a page)
</li>
	<li>
~digest（ `hash-source$p ）は、~page上の特定の要素に合致し得る
— 例えば
⇒
`sha256-abcd...^pl などの，
◎
Digests such as 'sha256-abcd...' (which can match specific elements on a page)
</li>
</ul>

<p>
`直列化形の~source~list@
（ `serialized-source-list$p ）
は、次の`~ABNF$文法に従うような，~space区切りの，一連の`~source式$からなる ASCII 文字列である：
◎
A serialized source list is an ASCII string, consisting of a space-delimited series of source expressions, adhering to the following ABNF grammar [RFC5234]:
</p>

<pre class="ABNF">
`serialized-source-list@p
                  = ( `source-expression$p *( `RWS$P `source-expression$p ) )
                  / "`none@pl"

`source-expression@p = `scheme-source$p
                  / `host-source$p
                  / `keyword-source$p
                  / `nonce-source$p
                  / `hash-source$p

; <span class="comment">~scheme ~source式：</span>
;          `https:^l
;        / `custom-scheme:^l
;        / `another.custom-scheme:^l
`scheme-source@p     = `scheme-part$p ":"

; <span class="comment">~host ~source式：</span>
;          `example.com^s
;        / `*.example.com^s
;        / `https://*.example.com:12/path/to/file.js^s
`host-source@p       = [ `scheme-part$p "://" ]
                    `host-part$p
                    [ `port-part$p ]
                    [ `path-part$p ]
`scheme-part@p       = `scheme$p
                  ; scheme is defined in section 3.1 of RFC 3986.
`host-part@p         = "*"
                  / [ "*." ] 1*`host-char$p *( "." 1*`host-char$p )
`host-char@p         = `ALPHA$P / `DIGIT$P / "-"
`port-part@p         = ":" ( 1*`DIGIT$P / "*" )
`path-part@p         = `path$p
                  ; path is defined in section 3.3 of RFC 3986.

; <span class="comment">~keyword ~source式：</span>
`keyword-source@p    = "`self@pl"
                  / "`unsafe-inline@pl"
                  / "`unsafe-eval@pl"
                  / "`strict-dynamic@pl"
                  / "`unsafe-hashed-attributes@pl"

; <span class="comment">~nonce ~source式：</span>
; `'nonce-[nonce goes here]'^s
`nonce-source@p      = "'nonce-" `base64-value$p "'"
`base64-value@p      = 1*( `ALPHA$P / `DIGIT$P / "+" / "/" / "-" / "_" )*2( "=" )

; <span class="comment">~digest ~source式：</span>
; `'sha256-[digest goes here]'^s
`hash-source@p       = "'" `hash-algorithm$p "-" `base64-value$p "'"
`hash-algorithm@p    = "sha256" / "sha384" / "sha512"
</pre>


<p>
`host-char$p 生成規則は、意図的に ASCII 文字のみを包含するようにされている。
国際化~domain名は，`直列化形の~CSP$の一部として直接的に手入力できないので、代わりに
Punycode `RFC3492$r で符号化され~MUST。
例えば，
~domain `üüüüüü.de^s
は、
`xn--tdaaaaaa.de^s
として表現され~MUST。
◎
The host-char production intentionally contains only ASCII characters; internationalized domain names cannot be entered directly as part of a serialized CSP, but instead MUST be Punycode-encoded [RFC3492]. For example, the domain üüüüüü.de MUST be represented as xn--tdaaaaaa.de.
</p>

<p class="note">注記：
IP ~addressは，上の文法に合致するが、~source式~内に利用されるときに 実際に合致する~URLは，
`127.0.0.1^s
のみである（詳細は
`~urlは~source~listに合致するか？$A
を見よ）。
IP ~addressが備える保安上の特質には疑義があるので、可能0なら~hostnameが選好されるべきである。
◎
Note: Though IP address do match the grammar above, only 127.0.0.1 will actually match a URL when used in a source expression (see §6.1.13.3 Does url match source list? for details). The security properties of IP addresses are suspect, and authors ought to prefer hostnames whenever possible.
</p>

<p>
`URL$u は、
`~urlは~source~listに合致するか？$A
の結果が `合致es^i であるとき，
`~source~listに合致する@
とされる。
◎
A URL matches a source list if the algorithm in §6.1.13.3 Does url match source list? returns Matches.
</p>



			</section>
		</section>
		<section id="framework-violation">
<h3 title="Violations">2.3. 違反</h3>

<p>
`違反@
は、`大域~obj$に結付けられている`施策$~objの集合に反した［
動作／資源
］を表現する。
◎
A violation represents an action or resource which goes against the set of policy objects associated with a global object.
</p>


<p>
各 `違反$は、次のものを持つ：
◎
↓</p>

<dl class="def-list">

	<dt>`大域~obj@vr</dt>
	<dd>
違反された`施策$を持つ`大域~obj$
◎
Each violation has a global object, which is the global object whose policy has been violated.
</dd>

	<dt>`~url@vr</dt>
	<dd>
この違反の`大域~obj$vrの`URL$u
◎
Each violation has a url which is its global object’s URL.
</dd>

	<dt>`状態code@vr</dt>
	<dd>
［
大域~objを~instance化させた資源
］の~HTTP状態codeを表現する，非負~整数
◎
Each violation has a status which is a non-negative integer representing the HTTP status code of the resource for which the global object was instantiated.
</dd>

	<dt>`資源@vr</dt>
	<dd>
施策に違反した資源を表現する
— 次のいずれか
⇒
`null^l ／ `inline^l ／ `eval^l ／ `URL$u
◎
Each violation has a resource, which is either null, "inline", "eval", or a URL. It represents the resource which violated the policy.
</dd>

	<dt>`~referrer@vr</dt>
	<dd>
施策に違反した資源の~referrerを表現する
— 次のいずれか
⇒
~NULL ／ `URL$u
◎
Each violation has a referrer, which is either null, or a URL. It represents the referrer of the resource whose policy was violated.
</dd>

	<dt>`施策@vr</dt>
	<dd>
違反された`施策$。
◎
Each violation has a policy, which is the policy that has been violated.
</dd>

	<dt>`有効な指令@vr</dt>
	<dd>
［
施行により この違反を生じさせた，`施策$vr内の`指令$
］を表現する，空でない文字列。
◎
Each violation has an effective directive which is a non-empty string representing the directive whose enforcement caused the violation.
</dd>

	<dt>`~source~file@vr</dt>
	<dd>
次のいずれか
⇒
~NULL ／ `URL$u
◎
Each violation has a source file, which is either null or a URL.
</dd>

	<dt>`行番号@vr</dt>
	<dd>
非負~整数。
◎
Each violation has a line number, which is a non-negative integer.
</dd>

	<dt>`列番号@vr</dt>
	<dd>
非負~整数。
◎
Each violation has a column number, which is a non-negative integer.
</dd>

</dl>


			<section id="create-violation-for-global">
<h4 title="Create a violation object for global, policy, and directive">2.3.1. ( %大域~obj, %施策, %指令~名 ) から違反~objを作成する</h4>

<p>
次の~algoは、所与の
( `大域~obj$ %大域~obj, `施策$ %施策, 文字列 %指令~名 )
から 新たな`違反$~objを作成して，それを初期~dataの集合で拡充する：
◎
Given a global object (global), a policy (policy), and a string (directive), the following algorithm creates a new violation object, and populates it with an initial set of data:
</p>

<ol>
	<li>
%違反 ~LET 次のようにされた新たな `違反$
⇒
`大域~obj$vr ~SET %大域~obj,<br>
`施策$vr ~SET %施策,<br>
`有効な指令$vr ~SET %指令~名,<br>
`資源$vr ~SET `null^l
◎
Let violation be a new violation whose global object is global, policy is policy, effective directive is directive, and resource is null.
</li>
	<li>
<p>
~IF［
~UAは，現在~scriptを実行している
］~AND［
%大域~obj から ~scriptの~source~fileの
( ~URL, 行番号, 列番号 )
を抽出できる
］
⇒
%違反 の
( `~source~file$vr, `行番号$vr, `列番号$vr )
~SET それら
◎
If the user agent is currently executing script, and can extract a source file’s URL, line number, and column number from the global, set violation’s source file, line number, and column number accordingly.
</p>

<p class="issue">
この種のものは，どこかで指定されているのか？
`ECMA262$r には，有用な~~記述は見当たらない。
◎
Is this kind of thing specified anywhere? I didn’t see anything that looked useful in [ECMA262].
</p>

	</li>
	<li>
~IF［
%大域~obj は `Window$I ~objである
］
⇒
%違反 の`~referrer$vr ~SET
%大域~obj の `document$m の
<a href="~HTMLDOM#dom-document-referrer">`referrer^m</a>
◎
If global is a Window object, set violation’s referrer to global’s document's referrer.
</li>
	<li>
<p>
%違反 の`状態code$vr ~SET
%違反 の`大域~obj$vrに結付けられている資源の~HTTP状態code
◎
Set violation’s status to the HTTP status code for the resource associated with violation’s global object.
</p>

<p class="issue">
状態codeは，正確にはどうやって取得する？
— 実際には どこにも格納されていない。
◎
How, exactly, do we get the status code? We don’t actually store it anywhere.
</p>
	</li>
	<li>
~RET %違反
◎
Return violation.
</li>
</ol>



			</section>
			<section id="create-violation-for-request">
<h4 title="Create a violation object for request, policy, and directive">2.3.2. ( %要請, %施策, %指令~名 ) から 違反~objを作成する</h4>

<p>
次の~algoは、所与の
( `要請$ %要請, `施策$ %施策, 文字列 %指令~名 )
から 新たな`違反$~objを作成して，それを 初期~dataの集合で拡充する：
◎
Given a request (request), a policy (policy), and a string (directive), the following algorithm creates a new violation object, and populates it with an initial set of data:
</p>

<ol>
	<li>
%違反 ~LET［
(
%要請 の`~client$rqの`大域~obj$
%施策,
%指令~名
)
から，`違反~objを作成-$A1した結果
］
◎
Let violation be the result of executing §2.3.1 Create a violation object for global, policy, and directive on request’s client’s global object, policy, and directive.
</li>
	<li>
<p>
%違反 の`資源$vr ~SET %要請 の`~url$rq
◎
Set violation’s resource to request’s url.
</p>

<p class="note">注記：
ここでは
%要請 の`~url$rqを利用する
— 
その`現在の~url$rq<em >ではなく</em>
—
後者は、［
~pageから~accessされては~MUST_NOTような，~redirect~target
］についての情報を包含することもあるので。
◎
Note: We use request’s url, and not its current url, as the latter might contain information about redirect targets to which the page MUST NOT be given access.
</p>
	</li>
	<li>
~RET %違反
◎
Return violation.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="policy-delivery">
<h2 title="Policy Delivery">3. 施策の送達</h2>

<p>
~serverは、個々の`資源~表現$に対し，`施策$を宣言して~MAY
— `施策$を`直列化-$した上で，~HTTP応答~headerの値に与えることにより。
この仕組みは、［
<a href="#csp-header">`Content-Security-Policy^h</a> ／
<a href="#cspro-header">`Content-Security-Policy-Report-Only^h</a>
］HTTP 応答~header節にて詳細に定義される。
また、［
`Fetch との統合$ ／ `HTML との統合$
］節にて［
Fetch ／ HTML
］との統合が述べられる。
◎
A server MAY declare a policy for a particular resource representation via an HTTP response header field whose value is a serialized CSP. This mechanism is defined in detail in §3.1 The Content-Security-Policy HTTP Response Header Field and §3.2 The Content-Security-Policy-Report-Only HTTP Response Header Field, and the integration with Fetch and HTML is described in §4.1 Integration with Fetch and §4.2 Integration with HTML.
</p>

<p>
`施策$は、
<a href="#meta-element">`meta^e 要素</a>
節に述べるように，［
`meta$e 要素の `http-equiv$a 属性を介して
HTML 文書~内に~inlineに宣言する
］こともできる。
◎
A policy may also be declared inline in an HTML document via a meta element’s http-equiv attribute, as described in §3.3 The &lt;meta&gt; element.
</p>


		<section id="csp-header">
<h3 title="The Content-Security-Policy HTTP Response Header Field">3.1. `Content-Security-Policy^h HTTP 応答~header</h3>

<p>
`Content-Security-Policy@h
~HTTP応答~headerが、~serverから~clientへ施策を送達するときに選好される仕組みである。
この~headerの値は、次の`~ABNF$で表現される：
◎
The Content-Security-Policy HTTP response header field is the preferred mechanism for delivering a policy from a server to a client. The header’s value is represented by the following ABNF [RFC5234]:
</p>


<pre class="ABNF">
Content-Security-Policy = 1#`serialized-policy$p
</pre>

<div class="example">

<pre class="http-code">
`Content-Security-Policy$h:
    `script-src$dir `self$pl;
    `report-to$dir csp-reporting-endpoint
</pre>
</div>

<p>
~serverは、同じ資源の異なる`表現$ごとに，異なる
`Content-Security-Policy^h ~header値を送信して~MAY。
◎
A server MAY send different Content-Security-Policy header field values with different representations of the same resource.
</p>

<p>
~serverは、`資源~表現$を送信する際に，複数の
`Content-Security-Policy^h ~headerを伴わせる~SHOULDでない。
◎
A server SHOULD NOT send more than one HTTP response header field named "Content-Security-Policy" with a given resource representation.
</p>

<p>
`Content-Security-Policy^h ~headerを受信した~UAは、それが包含する各 `直列化形の~CSP$を`構文解析-$Aした上で，［
`Fetch との統合$ ／ `HTML との統合$
］節にしたがって それを`施行-$し~MUST。
◎
When the user agent receives a Content-Security-Policy header field, it MUST parse and enforce each serialized CSP it contains as described in §4.1 Integration with Fetch, §4.2 Integration with HTML.
</p>



		</section>
		<section id="cspro-header">
<h3 title="The Content-Security-Policy-Report-Only HTTP Response Header Field">3.2. `Content-Security-Policy-Report-Only^h HTTP 応答~header</h3>

<p>
`Content-Security-Policy-Report-Only@h
~HTTP応答~headerは、~web開発者が，施策による効果を（~~実際に施行することなく）監視して，実験できるようにする。
この~headerの値は、次の`~ABNF$ で表現される：
◎
The Content-Security-Policy-Report-Only HTTP response header field allows web developers to experiment with policies by monitoring (but not enforcing) their effects. The header’s value is represented by the following ABNF [RFC5234]:
</p>

<pre class="ABNF">
Content-Security-Policy-Report-Only = 1#`serialized-policy$p
</pre>

<p>
この~headerにより、~web開発者は，自身の手による保安~施策を，すでに施行-中のものと同時に，報告のみ行わせて、反復的に開発することが可能になる
— その違反~報告から得られる，~siteの挙動についての最善の評価0に基づいて、挙動が適切であると判断がついた時点で，施策を施行-へ移すように。
◎
This header field allows developers to piece together their security policy in an iterative fashion, deploying a report-only policy based on their best estimate of how their site behaves, watching for violation reports, and then moving to an enforced policy once they’ve gained confidence in that behavior.
</p>

<div class="example">

<pre class="http-code">
`Content-Security-Policy-Report-Only$h:
    `script-src$dir `self$pl;
    `report-to$dir csp-reporting-endpoint
</pre>
</div>

<p>
~serverは、同じ資源の異なる`表現$ごとに，異なる
`Content-Security-Policy-Report-Only^h ~header値を送信して~MAY。
◎
A server MAY send different Content-Security-Policy-Report-Only header field values with different representations of the same resource.
</p>

<p>
~serverは、`資源~表現$を送信する際に，複数の［
`Content-Security-Policy-Report-Only^h ~header
］を伴わせる~SHOULDでない。
◎
A server SHOULD NOT send more than one HTTP response header field named "Content-Security-Policy-Report-Only" with a given resource representation.
</p>

<p>
`Content-Security-Policy-Report-Only^h ~headerを受信した~UAは、それが包含する各 `直列化形の~CSP$を`構文解析-$Aした上で，［
`Fetch との統合$ ／ `HTML との統合$
］節にしたがって，それを`監視-$し~MUST。
◎
When the user agent receives a Content-Security-Policy-Report-Only header field, it MUST parse and monitor each serialized CSP it contains as described in §4.1 Integration with Fetch and §4.2 Integration with HTML.
</p>

<p class="note">注記：
`Content-Security-Policy-Report-Only^h 
~headerは、
`meta$e 要素の内側では~support<strong>されない</strong>。
◎
Note: The Content-Security-Policy-Report-Only header is not supported inside a meta element.
</p>



		</section>
		<section id="meta-element">
<h3 title="The &lt;meta&gt; element">3.3. `meta^e 要素</h3>

<p>
`文書$は、いくつかの［
HTML `meta$e 要素であって, ［
その `http-equiv$a 属性~値 ~EQ~ACI `Content-Security-Policy^l
］なるもの
］を介して，施策を送達することもできる<!-- may -->。
例えば：
◎
A Document may deliver a policy via one or more HTML meta elements whose http-equiv attributes are an ASCII case-insensitive match for the string "Content-Security-Policy". For example:
</p>

<div class="example">

<pre class="html-code">
&lt;meta
  http-equiv="Content-Security-Policy"
  content="script-src `self$pl"
&gt;
</pre>
</div>

<p>
実装の詳細は HTML の
`~CSP http-equiv 処理命令$ `HTML$r
にて見出せる。
◎
Implementation details can be found in HTML’s Content-Security-Policy http-equiv processing instructions [HTML].
</p>

<p class="note">注記：
`Content-Security-Policy-Report-Only^h ~headerは、
`meta$e 要素の内側では~support<strong>されない</strong>
— ［
`report-uri$dir,
`frame-ancestors^dir,
`sandbox^dir
］指令も含め。
◎
Note: The Content-Security-Policy-Report-Only header is not supported inside a meta element. Neither are the report-uri, frame-ancestors, and sandbox directives.
</p>

<p>
`meta$e 要素~内の施策は、それに先行する内容には適用されない。
したがって，作者には、［
`meta$e 要素を 可能0な限り文書の始めの方に配置する
］ことが<em>強く奨励される</em>。
特に、［
`Link$h HTTP 応答~header ／
施策を送達する `meta$e に先行する［
`link$e ／ `script$e
］要素
］を利用して，~fetchあるいは事前fetchされる資源は、阻止されないことに注意。
◎
Authors are strongly encouraged to place meta elements as early in the document as possible, because policies in meta elements are not applied to content which precedes them. In particular, note that resources fetched or prefetched using the Link HTTP response header field, and resources fetched or prefetched using link and script elements which precede a meta-delivered policy will not be blocked.
</p>

<p class="note">注記：
`meta$e 要素を介して指定される`施策$は、被保護~資源にて作動中の他の施策とともに
— 他の施策がどこで指定されたかに関わらず —
施行される。
複数の施策が施行されるときの一般的な影響0は、
<a href="#multiple-policies">複数の施策による効果</a>
節にて述べる。
◎
Note: A policy specified via a meta element will be enforced along with any other policies active for the protected resource, regardless of where they’re specified. The general impact of enforcing multiple policies is described in §8.1 The effect of multiple policies.
</p>

<p class="note">注記：
要素が構文解析された後に，
`meta$e 要素の `content$a 属性を改変しても、無視される。
◎
Note: Modifications to the content attribute of a meta element after the element has been parsed will be ignored.
</p>

		</section>
	</section>
	<section id="integrations">
<h2 title="Integrations">4. 他の仕様との統合</h2>

~INFORMATIVE

<p>
この文書は、~CSPの機能性を実装するために，他の仕様から利用される~algoの集合を定義する。
明確さのため、これらの統合は，ここで概説されるが、詳細な情報への規範的な参照は，それらの外部~文書にあたるべきである。
◎
This document defines a set of algorithms which are used in other specifications in order to implement the functionality. These integrations are outlined here for clarity, but those external documents are the normative references which ought to be consulted for detailed information.
</p>



		<section id="fetch-integration">
<h3 title="Integration with Fetch">4.1. Fetch との統合</h3>

<p>
`指令$のうち一部は、何らかの仕方で，資源の読込みを制御する。
この仕様は、 `FETCH$r にて［
特定0の`要請$を阻止するべきか許容するべきか ／
特定0の`応答$を`~network~error$に置換するべきかどうか
］についての~~決定を下すときに利用される，いくつかの~algoを提供する。
◎
A number of directives control resource loading in one way or another. This specification provides algorithms which allow Fetch to make decisions about whether or not a particular request should be blocked or allowed, and about whether a particular response should be replaced with a network error.
</p>

<ol>
	<li>
`要請は~CSPにより阻止されるべきか？$Aは、`~main~fetch$~algoの中<!-- step #5 -->から~callされる。
◎
§4.1.3 Should request be blocked by Content Security Policy? is called as part of step #5 of its Main Fetch algorithm.
</li>
	<li>
<p>
`要請に対する応答は~CSPにより阻止されるべきか？$Aは、`~main~fetch$~algoの中<!-- step #13 -->から~callされる
◎
§4.1.4 Should response to request be blocked by Content Security Policy? is called as part of step #13 of its Main Fetch algorithm.
</p>
	</li>
</ol>

<p>
`施策$は，一般に `大域~obj$に対し施行されるが、［
`応答$の詳細についての知識も要求する指令
］を取扱うため、~UAは，［
~HTTP応答~headerを介して送達される どの施策も，`大域~obj$が作成される前に`構文解析-$Aする
］必要がある。
よって：
◎
A policy is generally enforced upon a global object, but the user agent needs to parse any policy delivered via an HTTP response header field before any global object is created in order to handle directives that require knowledge of a response’s details. To that end:
</p>

<ol>
	<li>
`応答$には、`~CSP~list$rsが結付けられる
— この~listは、`応答$の`~header~list$rs内に送達される施策~objたちを包含する。
◎
A response has an associated CSP list which contains any policy objects delivered in the response’s header list.
</li>
	<li>
<p>
`応答の~CSP~listを設定する$A手続きが，［
`~HTTP~fetch$ ／ `~HTTP-network~fetch$
］~algoの中から~callされる
◎
§4.1.1 Set response’s CSP list is called in the HTTP fetch and HTTP-network fetch algorithms.
</p>

<p class="note">注記：
`応答$がどう作成されたかに関わらず、これらの二つの~callにより，`応答$の`~CSP~list$rsは必ず設定されるようにするべきである。
~networkを（ `~HTTP-network~fetch$を介して）叩いたのなら、応答に伴われる施策を， `Set-Cookie^h ~headerを取扱う前に構文解析することになる。
応答を（`~HTTP~fetch$を介して） Service Worker から取得したのなら、応答を呼び出し元に~~渡し~~返す前に，その`~CSP~list$rsを処理することになる。
◎
Note: These two calls should ensure that a response’s CSP list is set, regardless of how the response is created. If we hit the network (via HTTP-network fetch, then we parse the policy before we handle the Set-Cookie header. If we get a response from a Service Worker (via HTTP fetch, we’ll process its CSP list before handing the response back to our caller.
</p>
	</li>
</ol>



			<section id="set-response-csp-list">
<h4 title="Set response’s CSP list">4.1.1. %応答 の~CSP~listを設定する</h4>

<p>
次の~algoは、所与の
( `応答$ %応答 )
に対し，［
その`~header~list$rsを，一連の`直列化形の~CSP$値として評価した結果
］に基づいて， %応答 の`~CSP~list$rsを拡充する：
◎
Given a response (response), this algorithm evaluates its header list for serialized CSP values, and populates its CSP list accordingly:
</p>


<ol>
	<li>
%応答 の`~CSP~list$rs ~SET 空~list
◎
Set response’s CSP list to the empty list.
</li>
	<li>
%~header値 ~LET %応答 の`~header~list$rs内で，名前
`Content-Security-Policy^h 
に対する`~header値を構文解析-$Aした結果
◎
↓</li>
	<li>
`施策たち^v ~LET［
( %~header値, `enforce^l )
を入力に，`直列化形の~CSP~listとして構文解析-$Aした結果
］
◎
Let policies be the result of executing §2.1.2 Parse a serialized CSP list as disposition on the result of parsing Content-Security-Policy in response’s header list, with a disposition of "enforce".
</li>
	<li>
%~header値 ~LET %応答 の`~header~list$rs内で，名前
`Content-Security-Policy-Report-Only^h
に対する`~header値を構文解析-$Aした結果
◎
↓</li>
	<li>
`施策たち^v に［
( %~header値, `report^l )
を入力に，`直列化形の~CSP~listとして構文解析-$Aした結果
］を付加する
◎
Append to policies the result of executing §2.1.2 Parse a serialized CSP list as disposition on the result of parsing Content-Security-Policy-Report-Only in response’s header list, with a disposition of "report".
</li>
	<li>
<p>
~FOR
`施策たち^v 内の ~EACH ( %施策 ) に対し：
◎
For each policy in policies:
</p>
		<ol>
			<li>
%施策 を %応答 の`~CSP~list$rsの中に挿入する
◎
Insert policy into response’s CSP list.
</li>
		</ol>
	</li>
</ol>



			</section>
			<section id="report-for-request">
<h4 title="Report Content Security Policy violations for request">4.1.2.  %要請 に対する~CSP違反を報告する</h4>

<p>
次の~algoは、所与の
( `要請$ %要請 )
に対し，
`~client$rqの “報告のみ” の施策に基づいて違反を報告する：
◎
Given a request (request), this algorithm reports violations based on client’s "report only" policies.
</p>

<ol>
	<li>
%~CSP~list ~LET
%要請 の`~client$rqの`大域~obj$の`~CSP~list$
◎
Let CSP list be request’s client’s global object’s CSP list.
</li>
	<li>
<p>
~FOR
%~CSP~list 内の ~EACH ( %施策 ) に対し：
◎
For each policy in CSP list:
</p>
		<ol>
			<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l
］
⇒
~CONTINUE
◎
If policy’s disposition is "enforce", then skip to the next policy.
</li>
			<li>
%違反ed指令 ~LET 
( %要請, %施策 )
に対する，
`要請は施策に違反するか？$A
の結果
◎
Let violates be the result of executing §6.1.13.1 Does request violate policy? on request and policy.
</li>
			<li>
~IF［
%違反ed指令 ~NEQ `非違反^i
］
⇒
［
( %要請, %施策, %違反ed指令 )
から，`違反~objを作成-$Aした結果
］を用いて，`違反を報告する$A
◎
If violates is not "Does Not Violate", then execute §5.3 Report a violation on the result of executing §2.3.2 Create a violation object for request, policy, and directive on request, policy, and violates.
</li>
		</ol>
	</li>
</ol>


			</section>
			<section id="should-block-request">
<h4 title="Should request be blocked by Content Security Policy?">4.1.3. %要請 は~CSPにより阻止されるべきか？</h4>

<p>
次の~algoは、所与の
( `要請$ %要請 )
に対し，［
`阻止ed^i ／ `許容ed^i
］を返した上で、
%要請 の`~client$rqの~CSPに基づいて違反を報告する：
◎
Given a request (request), this algorithm returns Blocked or Allowed and reports violations based on request’s client’s Content Security Policy.
</p>

<ol>
	<li>
%~CSP~list ~LET
%要請 の`~client$rqの`大域~obj$の`~CSP~list$
◎
Let CSP list be request’s client’s global object’s CSP list.
</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
~FOR
%~CSP~list 内の ~EACH ( %施策 ) に対し：
◎
For each policy in CSP list:
</p>
		<ol>
			<li>
~IF［
%施策 の`処分先$ ~EQ `report^l
］
⇒
~CONTINUE
◎
If policy’s disposition is "report", then skip to the next policy.
</li>
			<li>
%違反ed指令 ~LET
( %要請, %施策 )
に対する，
`要請は施策に違反するか？$A
の結果
◎
Let violates be the result of executing §6.1.13.1 Does request violate policy? on request and policy.
</li>
			<li>
<p>
~IF［
%違反ed指令 ~NEQ `非違反^i
］：
◎
If violates is not "Does Not Violate", then:
</p>
				<ol>
					<li>
［
( %要請, %施策, %違反ed指令 )
から，`違反~objを作成-$Aした結果
］を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on the result of executing §2.3.2 Create a violation object for request, policy, and directive on request, policy, and violates.
</li>
					<li>
%結果 ~SET `阻止ed^i
◎
Set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>



			</section>
			<section id="should-block-response">
<h4 title="Should response to request be blocked by Content Security Policy?">4.1.4. %要請 に対する %応答 は~CSPにより阻止されるべきか？</h4>

<p>
次の~algoは、所与の
( `応答$ %応答, `要請$ %要請 )
に対し，［
`阻止ed^i ／ `許容ed^i
］を返した上で、
%要請 の
`~client$rqの~CSPに基づいて違反を報告する：
◎
Given a response (response) and a request (request), this algorithm returns Blocked or Allowed, and reports violations based on request’s client’s Content Security Policy.
</p>

<ol>
	<li>
%~CSP~list ~LET
%要請 の`~client$rqの`大域~obj$の`~CSP~list$
◎
Let CSP list be request’s client’s global object’s CSP list.
</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
~FOR
%~CSP~list 内の ~EACH ( %施策 ) に対し：
◎
For each policy in CSP list:
</p>
		<ol>
			<li>
<p>
~FOR
%施策 内の ~EACH ( %指令 ) に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
<p>
~IF［
%指令 の`要請後~検査$Aを実行した結果 ~EQ `阻止ed^i
］：
◎
If the result of executing directive’s post-request check is "Blocked", then:
</p>
						<ol>
							<li>
［
( %要請, %施策, %指令 )
から，`違反~objを作成-$Aした結果
］を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on the result of executing §2.3.2 Create a violation object for request, policy, and directive on request, policy, and directive.
</li>
							<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l

］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
<p class="note">注記：
検査のこの部位は、~pageが応答を読込めるかどうかを検証0する。
すなわち， Service Worker が、~pageの~CSPに違反するような~fileに~~置き換えていないかどうかを。
◎
Note: This portion of the check verifies that the page can load the response. That is, that a Service Worker hasn’t substituted a file which would violate the page’s CSP.
</p>
	</li>
	<li>
<p>
~FOR
%応答 の`~CSP~list$ 内の ~EACH ( %施策 ) に対し：
◎
For each policy in response’s CSP list:
</p>
		<ol>
			<li>
<p>
~FOR
%施策 内の ~EACH ( %指令 ) に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
<p>
~IF［
( %要請, %応答, %施策 )
に対し，%指令 の`応答~検査$Aを実行した結果 ~EQ `阻止ed^i
］：
◎
If the result of executing directive’s response check on request, response, and policy is "Blocked", then:
</p>
						<ol>
							<li>
［
( %要請, %施策, %指令 )
から，`違反~objを作成-$Aした結果
］を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on the result of executing §2.3.2 Create a violation object for request, policy, and directive on request, policy, and directive.
</li>
							<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
検査のこの部位は、応答に伴って送達されてきた施策が，応答の送達を許容するかどうかを決定できるようにする。
◎
Note: This portion of the check allows policies delivered with the response to determine whether the response is allowed to be delivered.
</p>

	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

			</section>
		</section>
		<section id="html-integration">
<h3 title="Integration with HTML">4.2. HTML との統合</h3>

<ol>
	<li>
<p>
各［
`Document$I ／ `WorkerGlobalScope$I
］~objは、
`~CSP~list@
を持つ
—
それは、所与の文脈で作動中の`施策$~objすべてを保持する。
この~listは、指定されない限り空であり，
`大域~objの~CSP~listを初期化する$A
~algoを介して拡充される。
◎
The Document and WorkerGlobalScope objects have a CSP list, which holds all the policy objects which are active for a given context. This list is empty unless otherwise specified, and is populated via the §4.2.2 Initialize a global object’s CSP list algorithm.
</p>

<p class="issue">
この概念は、
WHATWG 版の HTML には追加されたが、
W3C 版にはない（ `187^IssW3C ）。
◎
This concept has been added to WHATWG’s HTML, but is missing from W3C’s version. &lt;https://github.com/w3c/html/issues/187&gt;
</p>
	</li>
	<li>
`施策$は、`大域~obj$の`~CSP~list$内に挿入されることにより，`大域~obj$に対し［
`施行-@
／
`監視-@
］されることになる。
◎
A policy is enforced or monitored for a global object by inserting it into the global object’s CSP list.
</li>
	<li>
<p>
`大域~objの~CSP~listを初期化する$A手続きは、［
`応答$に結付けられた`施策$~objの集合
］を［
新たに作成された`大域~obj$に束縛する
］ために，［
`新たな文書~objを初期化する$ ／
`~workerを走らす$
］~algoの中から~callされる。
◎
§4.2.2 Initialize a global object’s CSP list is called during the initialising a new Document object and run a worker algorithms in order to bind a set of policy objects associated with a response to a newly created global object.
</p>

<p class="issue">
これは、
WHATWG 版の HTML には策定されたが、
W3C 版にはない（ `188^IssW3C ）。
◎
This landed in WHATWG’s HTML, but is missing from W3C’s version. &lt;https://github.com/w3c/html/issues/188&gt;
</p>
	</li>
	<li>
<p>
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
は、［
~inline~script ／ ~inline~style
］~blockに対し［
その実行- ／ それによる具現化-
］が許容されるかどうかを決定するために［
<del>`~scriptを準備する$</del>
<ins>`~event~handler内容~属性$の被設定時</ins> ／
`~style~blockを更新する$
］~algoの中から~callされる。
◎
§4.2.3 Should element’s inline type behavior be blocked by Content Security Policy? is called during the prepare a script and update a style block algorithms in order to determine whether or not an inline script or style block is allowed to execute/render.
</p>

<p class="issue">
［
`script$e ／ `style$e
］の `nonce^a 属性は、
WHATWG 版 HTML に追加されたが（
<a href="https://github.com/whatwg/html/commit/882803c4cc8fba2fa5472b76f628d95cc82c421d">whatwg/html@882803c</a>
），
W3C 版 HTML ではまだである（ `186^IssW3C ）。
◎
The nonce attribute for script and style were added to WHATWG’s HTML in whatwg/html@882803c. They have not yet been added to W3C’s HTML. &lt;https://github.com/w3c/html/issues/186&gt;
</p>

<p class="issue">
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
への~hookは、
WHATWG 版 HTML に追加されたが（
<a href="https://github.com/whatwg/html/commit/ee3486eb129bc350b5ca684d0c91dff23453ac1a">whatwg/html@ee3486e</a>
），
W3C 版 HTML ではまだである（ `185^IssW3C ）。
◎
The §4.2.3 Should element’s inline type behavior be blocked by Content Security Policy? hooks were added to WHATWG’s HTML in whatwg/html@ee3486e. They aren’t yet in W3C’s HTML.
&lt;https://github.com/w3c/html/issues/185&gt;
</p>

	</li>
	<li>
<p>
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$Aは、［
~inline~event~handler（ `onclick^c など）／
~inline `style^c 属性
］を取扱う間に，［
その［
実行- ／ 具現化-
］が許容されるべきかどうか
］を決定するために~callされる。
◎
§4.2.3 Should element’s inline type behavior be blocked by Content Security Policy? is called during handling of inline event handlers (like onclick) and inline style attributes in order to determine whether or not they ought to be allowed to execute/render.
</p>

<p class="issue">
この~hookは、
WHATWG 版 HTML では策定された
— W3C 版では部分的に追加されている（ `185^IssW3C ）。
◎
This hook landed in WHATWG’s HTML in whatwg/html@920c918. It has been partially added to W3C’s HTML. &lt;https://github.com/w3c/html/issues/185&gt;
</p>

	</li>
	<li>
<p>
各`施策$は、 `meta$e 要素の `http-equiv$a 属性を処理する間に`施行され$る。
◎
Policy is enforced during processing of the meta element’s http-equiv.
</p>

<p class="issue">
この処理は、
WHATWG 版 HTML には追加されたが（
<a href="https://github.com/whatwg/html/commit/5064a629f22bef29839ab4dc6f1ceef17f010bc5">whatwg/html@5064a62</a>
），
W3C 版 HTML ではまだである（ `184^IssW3C ）。
◎
This processing was added to WHATWG’s HTML in whatwg/html@5064a62. It has not yet been added to W3C’s HTML. &lt;https://github.com/w3c/html/issues/184&gt;
</p>

	</li>
	<li>
所与の`文書$ %C に対し、［
ある`文書$ %D の`閲覧文脈$が， %C の`閲覧文脈$を
%D を`通して入子に$している
］とき、
%D を指して， %C を
`埋込んでいる文書@
という。
◎
A Document's embedding document is the Document through which the Document's browsing context is nested.
</li>
	<li>
<p>
HTML は、資源の読込みに責を負う要素からの 関連する~dataで，各`要請$の［
`暗号用~nonce~metadata$rq,
`構文解析器~metadata$rq
］を拡充する。
◎
HTML populates each request’s cryptographic nonce metadata and parser metadata with relevant data from the elements responsible for resource loading.
</p>

<p class="issue">
この処理は
WHATWG 版 HTML には追加されたが（
<a href="https://github.com/whatwg/html/commit/5479e07a6f6e01062b85b5fe6799752b0370336c">whatwg/html@5479e07</a>
），
W3C 版ではまだである（ `183^IssW3C ）。
◎
This processing was added to WHATWG’s HTML in whatwg/html@5479e07. It has not yet been added to W3C’s HTML. &lt;https://github.com/w3c/html/issues/183&gt;
</p>

<p class="issue">
構文解析器~metadataは、
WHATWG 版 HTML における Fetch には pass through されたが、
W3C 版 HTML における Fetch にはまだ pass through されていない
（ `197^IssW3C ）。
◎
Parser metadata is passed through to Fetch in WHATWG’s HTML, but not in W3C’s HTML. &lt;https://github.com/w3c/html/issues/197&gt;
</p>

<p class="issue">
~stylesheetの読込みは、まだ
W3C 版 HTML における Fetch には統合されていない（
<a href="https://github.com/whatwg/html/issues/198">&lt;https://github.com/whatwg/html/issues/198&gt;</a>
）
◎
Stylesheet loading is not yet integrated with Fetch in W3C’s HTML. &lt;https://github.com/whatwg/html/issues/198&gt;
</p>

<p class="issue">
~stylesheetの読込みは、まだ
WHATWG 版 HTML における Fetch には統合されていない（
<a href="https://github.com/whatwg/html/issues/968">&lt;https://github.com/whatwg/html/issues/968&gt;</a>
）
◎
Stylesheet loading is not yet integrated with Fetch in WHATWG’s HTML. &lt;https://github.com/whatwg/html/issues/968&gt;
</p>
	</li>
	<li>
<p>
<a href="#allow-base-for-document">%文書 に対する %基底 は許容されるか？</a> は、
`href$a 属性の値が妥当になることを確保するため，
`base$e の`凍結された基底~URLを設定する$間に~callされる
◎
§6.2.1.1 Is base allowed for document? is called during base's set the frozen base URL algorithm to ensure that the href attribute’s value is valid.
</p>

<p class="issue">
WHATWG 文書~内の参照を正す。
W3C 文書に~bugを~fileする。
◎
Correct the reference in WHATWG’s document. File a bug against W3C’s document.
</p>


</ol>



			<section id="initialize-document-csp">
<h4 title="Initialize a Document's CSP list">4.2.1. 文書の~CSP~listを初期化する</h4>

<p>
所与の
( `文書$ %文書, `応答$ %応答 )
の下で， %文書 の`~CSP~list$docを初期化する手続きは、次で与えられる：
◎
Given a Document (document), and a response (response), the user agent performs the following steps in order to initialize document’s CSP list:
</p>

<ol>
	<li>
<p>
~IF［
%応答 の`~url$rsの`~scheme$uは `局所~scheme$uである
］：
◎
If response’s url’s scheme is a local scheme:
</p>
		<ol>
			<li>
`文書たち^v ~LET 空~list
◎
Let documents be an empty list.
</li>
			<li>
~IF［
%文書 を`埋込んでいる文書$ %D がある
］
⇒
%D を `文書たち^v に追加する
◎
If document has an embedding document (embedding), then add embedding to documents.
</li>
			<li>
~IF［
%文書 を`開いた閲覧文脈$ %B がある
］
⇒
%B にて`作動中の文書$を `文書たち^v に追加する
◎
If document has an opener browsing context, then add its active document to documents.
</li>
			<li>
<p>
~FOR
`文書たち^v 内の ~EACH ( %D ) に対し：
◎
For each doc in documents:
</p>
				<ol>
					<li>
<p>
~FOR
%D の`~CSP~list$doc内の ~EACH ( %施策 ) に対し：
◎
For each policy in doc’s CSP list:
</p>
						<ol>
							<li>
%施策 への~aliasを，%文書 の`~CSP~list$docの中に挿入する
◎
Insert an alias to policy in document’s CSP list.
</li>
					</ol>
				</li>
			</ol>
		</li>
	</ol>

<p class="note">注記：
`局所~scheme$uには `about^sc も含まれる。
したがってこの~algoは、
`~iframe-srcdoc文書$を`埋込んでいる文書$の施策を~aliasする。
◎
Note: local scheme includes about:, and this algorithm will therefore alias the embedding document’s policies for an iframe srcdoc Document.
</p>

<p class="note">注記：
この段は、［
~pageにて［
~frameを埋込む ／ 新たな~windowを~pop-upする
］ことにより，それが制御する内容（
`blob^sc 資源や, `document.write()^c
）が~pageの`施策$を迂回すること
］は、できないようにすることを確保する。
◎
Note: We do all this to ensure that a page cannot bypass its policy by embedding a frame or popping up a new window containing content it controls (blob: resources, or document.write()).
</p>
	</li>
	<li>
~FOR
%応答 の`~CSP~list$rs内の ~EACH ( %施策 ) に対し
⇒
%施策 を %文書 の`~CSP~list$docの中に挿入する
◎
For each policy in response’s CSP list, insert policy into document’s CSP list.
</li>
	<li>
~FOR
%文書 の`~CSP~list$内の ~EACH ( %施策 ) に対し
⇒
~FOR
%施策 内の ~EACH ( %指令 ) に対し
⇒
( %文書, %応答 )
に対し， %指令 の`初期化$A~algoを実行する
◎
For each policy in document’s CSP list:
• For each directive in policy:
•• Execute directive’s initialization algorithm on document and response.
</li>

</ol>

			</section>
			<section id="initialize-global-object-csp">
<h4 title="Initialize a global object’s CSP list">4.2.2. 大域~objの~CSP~listを初期化する</h4>

<p>
所与の`応答$ %応答 で 所与の`大域~obj$ %大域~obj の`~CSP~list$を初期化する手続きは、次で与えられる：
◎
Given a global object (global), and a response (response), the user agent performs the following steps in order to initialize global’s CSP list:
</p>

<ol>
	<li>
<p>
~IF［
%応答 の`~url$rsの`~scheme$uは `局所~scheme$uである
］：
◎
If response’s url’s scheme is a local scheme:
</p>
		<ol>
			<li>
`文書たち^v ~LET 空~list
◎
Let documents be an empty list.
</li>
			<li>
~FOR
%大域~obj の~EACH ( `文書$x %文書 ) に対し
⇒
%文書 を `文書たち^v に追加する
◎
Add each of global’s documents to documents.
</li>
			<li>
<p>
~FOR
`文書たち^v 内の ~EACH ( %文書 ) に対し：
◎
For each document in documents:
</p>
				<ol>
					<li>
<p>
~FOR
%文書 の`大域~obj$の`~CSP~list$内の ~EACH ( %施策 ) に対し：
◎
For each policy in document’s global object’s CSP list:
</p>
						<ol>
							<li>
%施策 への~aliasを，
%大域~obj の`~CSP~list$の中に挿入する
◎
Insert an alias to policy in global’s CSP list.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
`局所~scheme$uには `about^sc も含まれる。
— したがってこの~algoは、`~iframe-srcdoc文書$を`埋込んでいる文書$の施策を~aliasする。
◎
Note: local scheme includes about:, and this algorithm will therefore alias the embedding document’s policies for an iframe srcdoc Document.
</p>
	</li>
	<li>
~FOR
%応答 の`~CSP~list$rs内の ~EACH ( %施策 ) に対し
⇒
%施策 を %大域~obj の`~CSP~list$の中に挿入する
◎
For each policy in response’s CSP list, insert policy into global’s CSP list.
</li>
</ol>



			</section>
			<section id="should-block-inline">
<h4 title="Should element’s inline type behavior be blocked by Content Security Policy?">4.2.3. %要素 における~inline型の挙動は~CSPにより阻止されるべきか？</h4>

<p>
次の~algoは、所与の
( `要素$ %要素, 文字列 %型, 文字列 %~source )
に対し， %要素 における［
~inline定義による特定0の型の挙動（
~script実行, ~styleの適用, ~event~handler,
等々）
］が［
許容されるならば `許容ed^i ／
許容されないならば `阻止ed^i
］を返す：
◎
Given an Element (element), a string (type), and a string (source) this algorithm returns "Allowed" if the element is allowed to have inline definition of a particular type of behavior (script execution, style application, event handlers, etc.), and "Blocked" otherwise:
</p>



<ol>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
~FOR
%要素 の`文書$の`大域~obj$の`~CSP~list$
内の ~EACH ( %施策 ) に対し：
◎
For each policy in element’s Document's global object’s CSP list:
</p>
		<ol>
			<li>
<p>
~FOR
%施策 内の ~EACH ( %指令 ) に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
~IF［
( %要素, %型, %~source )
に対し，%指令 の`~inline検査$Aを実行した結果 ~EQ `許容ed^i 
］
⇒
~CONTINUE
◎
If directive’s inline check returns "Allowed" when executed upon element, type, and source, skip to the next directive.
</li>
					<li>
%指令~名 ~LET ［
%型 ~IN { `style^l, `style-attribute^l } ならば `style-src^l ／
~ELSE_ `script-src^l
］
◎
↓</li>
					<li>
%違反 ~LET
( `~incumbent設定群~obj$, %施策, %指令~名 )
から，`違反~objを作成-$A1した結果
◎
Otherwise, let violation be the result of executing §2.3.1 Create a violation object for global, policy, and directive on the incumbent settings object, policy, and "style-src" if type is "style" or "style-attribute", or "script-src" otherwise.
</li>
					<li>
%違反 の`資源$vr ~SET `inline^l
◎
Set violation’s resource to "inline".
</li>
					<li>
%違反 を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on violation.
</li>
					<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>


			</section>
		</section>
		<section id="ecma-integration">
<h3 title="Integration with ECMAScript">4.3. ECMAScript との統合</h3>


<p>
ECMAScript では、~host環境が 文字列から ECMAScript ~codeへの~compilationを阻止できるようにする
`HostEnsureCanCompileStrings$AO()
抽象演算が定義されている。
この文書は、その抽象演算の実装を定義する
— それは、関連する`~CSP~list$を調べて，そのような~compilationは阻止されるべきかどうか決定する。
◎
ECMAScript defines a HostEnsureCanCompileStrings() abstract operation which allows the host environment to block the compilation of strings into ECMAScript code. This document defines an implementation of that abstract operation thich examines the relevant CSP list to determine whether such compilation ought to be blocked.
</p>

<p class="issue">
これは、
WHATWG 版 HTML では策定されたが，
W3C 版ではまだである（ `189^IssW3C ）。
◎
This has landed in WHATWG’s HTML, but hasn’t yet made it to W3C’s version. &lt;https://github.com/w3c/html/issues/189&gt;
</p>



			<section id="can-compile-strings">
<h4>4.3.1. `EnsureCSPDoesNotBlockStringCompilation^AO(%callerRealm, %calleeRealm)</h4>

<p>
所与の 2 つの`~realm$
( %callerRealm, %calleeRealm )
に対し、この~algoは，文字列の~compilationが許容されないならば `EvalError^E を投出し，他の場合は何もしない：
◎
Given two realms (callerRealm and calleeRealm), this algorithm returns normally if string compilation is allowed, and throws an "EvalError" if not:
</p>

<ol>
	<li>
%大域~obj~list ~LET ［
%callerRealm の`大域~obj$realm, %calleeRealm の`大域~obj$realm
］からなる~list
◎
Let globals be a list containing callerRealm’s global object and calleeRealm’s global object.
</li>
	<li>
<p>
~FOR
%大域~obj~list 内の ~EACH ( %大域~obj ) に対し：
◎
For each global in globals:
</p>
		<ol>
			<li>
<p>
~FOR
%大域~obj の`~CSP~list$内の ~EACH ( %施策 ) に対し：
◎
For each policy in global’s CSP list:
</p>
				<ol>
					<li>
%~source~list ~LET ~NULL
◎
Let source-list be null.
</li>
					<li>
~IF［
%施策 は［
`名前$ ~EQ `script-src^l
］なる`指令$を包含する
］
⇒
%~source~list ~SET その`指令$の`値$
◎
If policy contains a directive whose name is "script-src", then set source-list to that directive’s value.
</li>
					<li>
~ELIF［
%施策 は［
`名前$ ~EQ `default-src^l
］なる`指令$を包含する
］
⇒
%~source~list ~SET その`指令$の`値$
◎
Otherwise if policy contains a directive whose name is "default-src", then set source-list to that directive’s value.
</li>
					<li>
~IF［
%~source~list ~NEQ ~NULL
］~AND［
%~source~list は［
`~source式$ ~EQ~ACI `unsafe-eval$pl
］を包含しない
］
⇒
~THROW `EvalError^E
◎
If source-list is non-null, and does not contain a source expression which is an ASCII case-insensitive match for the string "'unsafe-eval'", then throw an EvalError exception.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
	</section>
	<section id="reporting">
<h2 title="Reporting">5. 報告処理</h2>

<p>
一つ以上の`施策$の指令が違反されたときは、
`違反~報告@
が生成され，［
`施策$に結付けられている`報告先$（ reporting endpoint ）
］に向けて送信される。
<!-- ＊may be -->
◎
When one or more of a policy’s directives is violated, a violation report may be generated and sent out to a reporting endpoint associated with the policy.
</p>



		<section id="violation-events">
<h3 title="Violation DOM Events">5.1. 違反 DOM ~event</h3>

<pre class="idl">
[`Constructor@m(
  DOMString %type,
  optional `SecurityPolicyViolationEventInit$I %eventInitDict
)]
interface `SecurityPolicyViolationEvent@I : `Event$I {
    readonly    attribute DOMString      `documentURI@m;
    readonly    attribute DOMString      `referrer@m;
    readonly    attribute DOMString      `blockedURI@m;
    readonly    attribute DOMString      `violatedDirective@m;
    readonly    attribute DOMString      `effectiveDirective@m;
    readonly    attribute DOMString      `originalPolicy@m;
    readonly    attribute DOMString      `sourceFile@m;
    readonly    attribute unsigned short `statusCode@m;
    readonly    attribute long           `lineNumber@m;
    readonly    attribute long           `columnNumber@m;
};

dictionary `SecurityPolicyViolationEventInit@I : `EventInit$I {
    DOMString      `documentURI@d;
    DOMString      `referrer@d;
    DOMString      `blockedURI@d;
    DOMString      `violatedDirective@d;
    DOMString      `effectiveDirective@d;
    DOMString      `originalPolicy@d;
    DOMString      `sourceFile@d;
    unsigned short `statusCode@d;
    long           `lineNumber@d;
    long           `columnNumber@d;
};
</pre>


		</section>
		<section id="deprecated-serialize-violation">
<h3 title="Obtain the deprecated serialization of violation">5.2. %違反 の直列化を得る（非推奨）</h3>

<p>
次の~algoは、所与の
( `違反$ %違反 )
に対し，%違反 を表現する JSON ~text文字列を［［
非推奨にされた `report-uri$dir 指令
］に結付けられている`報告先$への提出に相応しい形
］にして返す。
◎
Given a violation (violation), this algorithm returns a JSON text string representation of the violation, suitable for submission to a reporting endpoint associated with the deprecated report-uri directive.
</p>

<ol>
	<li>
<p>
%~obj ~LET
各種~propertyが次のように初期化された，新たな~JS ~obj
◎
Let object be a new JavaScript object with properties initialized as follows:
</p>
		<ul>
			<li>
`document-uri^l ~SET ［
%素片除外~flag ~SET ~ON
］の下で，
%違反 の`~url$vrを`~URL直列化器$uにかけた結果
◎
"document-uri"
◎
The result of executing the URL serializer on violation’s url, with the exclude fragment flag set.
</li>
			<li>
`referrer^l ~SET ［
%素片除外~flag ~SET ~ON
］の下で，
%違反 の`~referrer$vrを`~URL直列化器$uにかけた結果
◎
"referrer"
◎
The result of executing the URL serializer on violation’s referrer, with the exclude fragment flag set.
</li>
			<li>
`blocked-uri^l ~SET ［
%素片除外~flag ~SET ~ON
］の下で，
%違反 の`資源$vrを`~URL直列化器$uにかけた結果
◎
"blocked-uri"
◎
The result of executing the URL serializer on violation’s resource, with the exclude fragment flag set.
</li>
			<li>
`effective-directive^l ~SET 
%違反 の`有効な指令$vr
◎
"effective-directive"
◎
violation’s effective directive
</li>
			<li>
`violated-directive^l ~SET
%違反 の`有効な指令$vr
◎
"violated-directive"
◎
violation’s effective directive
</li>
			<li>
`original-policy^l ~SET
%違反 の`施策$vrを`直列化-$した結果
◎
"original-policy"
◎
The serialization of violation’s policy
</li>
			<li>
`status-code^l ~SET
%違反 の`状態code$vr
◎
"status-code"
◎
violation’s status
</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%違反 の`~source~file$vr ~NEQ ~NULL
］
⇒
%~obj の各種~propertyを次のように設定する：
◎
If violation’s source file is not null:
</p>
		<ul>
			<li>
`source-file^l ~SET［
［
%素片除外~flag ~SET ~ON
］の下で，
%違反 の`~source~file$vrを`~URL直列化器$uにかけた結果
］
◎
Set object’s "source-file" property to the result of executing the URL serializer on violation’s source file, with the exclude fragment flag set.
</li>
			<li>
`line-number^l ~SET %違反 の`行番号$vr
◎
Set object’s "line-number" property to violation’s line number.
</li>
			<li>
`column-number^l ~SET %違反 の`列番号$vr
◎
Set object’s "column-number" property to violation’s column number.
</li>
		</ul>
	</li>
	<li>
~RET
［
%~obj に対し
`JSON.stringify()$c
を実行した結果
］
◎
Return the result of executing JSON.stringify() on object.
</li>
</ol>



		</section>
		<section id="report-violation">
<h3 title="Report a violation">5.3. %違反 を報告する</h3>

<p>
次の~algoは、所与の
( `違反$ %違反 )
に対し，それを［
%違反 の`施策$vrに指定されている`報告先$
］へ報告するとともに，
%違反 の`大域~obj$vrに向けて
`securitypolicyviolation@et
~eventを発火する。
◎
Given a violation (violation), this algorithm reports it to the endpoint specified in violation’s policy, and fires a SecurityPolicyViolationEvent at violation’s global object.
</p>

<ol>
	<li>
<p>
`SecurityPolicyViolationEvent$I ~interfaceを利用し，その各種~属性が次のように初期化された，名前 `securitypolicyviolation$et の`~trusted$~eventを`発火-$する：
◎
Fire a trusted event with the name securitypolicyviolation that uses the SecurityPolicyViolationEvent interface, with its attributes initialized as follows:
</p>
		<ul>
			<li>
`documentURI$m ~SET
%違反 の`~url$vr
◎
documentURI
• violation’s url
</li>
			<li>
`referrer$m ~SET
%違反 の`~referrer$vr
◎
referrer
• violation’s referrer
</li>
			<li>
`blockedURI$m ~SET
%違反 の`資源$vr
◎
blockedURI
• violation’s resource
</li>
			<li>
`effectiveDirective$m ~SET
%違反 の`有効な指令$vr
◎
effectiveDirective
• violation’s effective directive
</li>
			<li>
`violatedDirective$m ~SET
%違反 の`有効な指令$vr
◎
violatedDirective
• violation’s effective directive
</li>
			<li>
`originalPolicy$m ~SET
%違反 の`施策$vr
◎
originalPolicy
• violation’s policy
</li>
			<li>
`sourceFile$m ~SET
%違反 の`~source~file$vr
◎
sourceFile
• violation’s source file
</li>
			<li>
`statusCode$m ~SET
%違反 の`状態code$vr
◎
statusCode
• violation’s status
</li>
			<li>
`lineNumber$m ~SET
%違反 の`行番号$vr
◎
lineNumber
• violation’s line number
</li>
			<li>
`columnNumber$m ~SET
%違反 の`列番号$vr
◎
columnNumber
• violation’s column number
</li>
		</ul>

<p class="note">注記：
［
`effectiveDirective$m, `violatedDirective$m
］の両者とも同じ値にされる。
これは，後方互換性を維持するためであり、意図的である。
◎
Note: Both effectiveDirective and violatedDirective are the same value. This is intentional to maintain backwards compatibility.
</p>
	</li>
	<li>
<p>
~IF［
%違反 の`施策$vrの`指令~集合$は［
名前 "`report-uri$dir" の`指令$ %指令
］を包含する
］：
◎
If violation’s policy’s directive set contains a directive named "report-uri" (directive):
</p>
		<ol>
			<li>
~IF［
%違反 の`施策$の`指令~集合$は
名前 `report-to$dir の`指令$を包含する
］
⇒
~GOTO `END^i
◎
If violation’s policy’s directive set contains a directive named "report-to", skip the remaining substeps.
</li>
			<li>
%報告先 ~LET［
%指令 の`値$を`~URL構文解析器$uにかけた結果
］
◎
Let endpoint be the result of executing the URL parser on directive’s value.
</li>
			<li>
~IF［
%報告先 は妥当な~URLでない
］
⇒
~GOTO `END^i
◎
If endpoint is not a valid URL, skip the remaining substeps.
</li>
			<li>
<p>
%要請 ~LET
次のように初期化された新たな`要請$：
◎
Let request be a new request, initialized as follows:
</p>
				<ul>
					<li>
`~method$rq ~SET `POST^l
◎
method$
• "POST"
</li>
					<li>
`~url$rq ~SET %違反 の`~url$vr
◎
url
• violation’s url
</li>
					<li>
`生成元$rq ~SET
%違反 の`大域~obj$vrの`生成元$
◎
origin
• violation’s global object’s origin
</li>
					<li>
`~window$rq ~SET `no-window^l
◎
window
• "no-window"
</li>
					<li>
`~client$rq ~SET
%違反 の`大域~obj$vrに`関連する設定群~obj$
◎
client
• violation’s global object’s relevant settings object
</li>
					<li>
`行先$rq ~SET 空~文字列
◎
destination
• ""
</li>
					<li>
`起動元$rq ~SET 空~文字列
◎
initiator
• ""
</li>
					<li>
`種別$rq ~SET 空~文字列
◎
type
• ""
</li>
					<li>
`~cache~mode$rq ~SET `no-cache^l
◎
cache mode
• "no-cache"
</li>
					<li>
`資格証~mode$rq ~SET `same-origin^l
◎
credentials mode
• "same-origin"
</li>
					<li>
`~header~list$rq ~SET ［
( 名前 ~SET `Content-Type^h / 値 ~SET `application/csp-report^l )
にされた単独の~header
］を包含する`~header~list$
◎
header list
• A header list containing a single header whose name is "Content-Type", and value is "application/csp-report"
</li>
					<li>
`本体$rq ~SET %違反 を`直列化-（非推奨）$Aした結果
◎
body
• The result of executing §5.2 Obtain the deprecated serialization of violation on violation
</li>
					<li>
`~redirect~mode$rq ~SET `error^l
◎
redirect mode
• "error"
</li>
				</ul>
			</li>

			<li>
%要請 を`~fetch$する
— その結果は無視する。
◎
Fetch request. The result will be ignored.
</li>

		</ol>

<p class="note">注記：
この段のすべては、非推奨にされたものと見なされるべきである。
これは，違反ごとに単独の要請を送信するため、単純に~scalableでないので。
この挙動は、~UAから除去できるようになり次第，除去される。
◎
Note: All of this should be considered deprecated. It sends a single request per violation, which simply isn’t scalable. As soon as this behavior can be removed from user agents, it will be.
</p>

<p class="note">注記：
`report-uri^dir は `report-to^dir が不在のときにのみ効果を発揮する。
すなわち、後者は前者を上書きし，新たな仕組みを~supportしない~browserとの後方互換性をとれるようにする。
◎
Note: report-uri only takes effect if report-to is not present. That' is, the latter overrides the former, allowing for backwards compatibility with browsers that don’t support the new mechanism.
</p>
	</li>

	<li>`END^i：
<p>
~IF［
%違反 の`施策$の`指令~集合$は
名前 `report-to$dir の`指令$ %指令 を包含する
］：
◎
If violation’s policy’s directive set contains a directive named "report-to" (directive):
</p>
		<ol>
			<li>
%~group ~LET %指令 の`値$
◎
Let group be directive’s value.
</li>
			<li>
%設定群~obj ~LET
%違反 の`大域~obj$に`関連する設定群~obj$
◎
Let settings object be violation’s global object’s relevant settings object.
</li>
			<li>
<p>
次を与える下で，`報告先~groupに対する~dataを待入する$A `OOB-REPORTING$r：
◎
Execute [OOB-REPORTING]'s Queue data as type for endpoint group on settings algorithm with the following arguments:
</p>

<ul><li>%~data ~SET %違反
◎
data
• violation
</li><li>%種別 ~SET `CSP^l
◎
type
• "CSP"
</li><li>%報告先~group ~SET %~group
◎
endpoint group
• group
</li><li>%設定群 ~SET %設定群~obj
◎
settings
• settings object
</li></ul>
			</li>
		</ol>
	</li>
</ol>

		</section>
	</section>
	<section id="csp-directives">
<h2 title="Content Security Policy Directives">6. ~CSP指令</h2>

<div class="p">
<p>
この仕様は、~web開発者が、自身の~siteの挙動のある種の側面を制御できるようにするための，いくつかの型の`指令$を定義する：
</p>

<ul><li>資源の~fetch~~処理を統治する指令（
<a href="#directives-fetch">~fetch指令</a>
節）
</li><li>文書の状態を統治する指令（
<a href="#directives-document">文書~指令</a>
節）
</li><li>~navigationの側面を統治する指令（
<a href="#directives-navigation">~navigation指令</a>
節）
</li><li>報告処理を統治する指令を定義する（
<a href="#directives-reporting">指令の報告処理</a>
節）
</li></ul>

<p>
これらは，~CSPの中核を形成し、他の指令は補佐的な文書にて~modularに定義される（
<a href="#directives-elsewhere">他の文書にて定義される指令</a>
節にて例を見れる）。
</p>

◎
This specification defines a number of types of directives which allow developers to control certain aspects of their sites' behavior. This document defines directives which govern resource fetching (in §6.1 Fetch Directives), directives which govern the state of a document (in §6.2 Document Directives), directives which govern aspects of navigation (in §6.3 Navigation Directives), and directives which govern reporting (in §6.4 Reporting Directives). These form the core of Content Security Policy; other directives are defined in a modular fashion in ancillary documents (see §6.5 Directives Defined in Other Documents for examples).
</div>

<p>
~web開発者は、
XSS 攻撃による~riskを軽減するため，次のいずれかの指令を含ませて［
~script／~plugin
］の~sourceを規制する~SHOULDである：
◎
To mitigate the risk of cross-site scripting attacks, web developers SHOULD include directives that regulate sources of script and plugins. They can do so by including:
</p>

<ul>
	<li>
［
`script-src$dir, `object-src$dir
］両~指令
◎
Both the script-src and object-src directives, or
</li>
	<li>
`default-src$dir 指令
◎
a default-src directive
</li>
</ul>

<p>
いずれの場合も、~web開発者は，自身による施策~内に妥当な~sourceとして
`unsafe-inline$pl ／ `data^sc
を含ませる~SHOULDでない。
両者とも，［
文書~自身~内に~codeを直接的に含めることを許容する
］ため， XSS 攻撃を可能化するので。
それらは完全に避けるのが最善である。
◎
In either case, developers SHOULD NOT include either 'unsafe-inline', or data: as valid sources in their policies. Both enable XSS attacks by allowing code to be included directly in the document itself; they are best avoided completely.
</p>



		<section id="directives-fetch">
<h3 title="Fetch Directives">6.1. ~fetch指令</h3>

<p>
この節の各~下位~節に述べる指令は、
`~fetch指令@
と総称される。
`~fetch指令$は、ある種の型の資源を，どの所在から読込んでよいかを制御する。
例えば、 `script-src$dir 指令は，~web開発者が信用する~sourceからの~scriptを~whitelist化して，~page上で実行できるようにする。
また、 `font-src$dir 指令は，~web~fontの~sourceを制御する。
◎
Fetch directives control the locations from which certain resourc types may be loaded. For instance, script-src allows developers to whitelist trusted sources of script to execute on a page, while font-src controls the sources of web fonts.
</p>



			<section id="directive-child-src">
<h4>6.1.1. `child-src^dir</h4>

<p>
`child-src@dir
指令は、［
`入子の閲覧文脈$（例： `iframe$e ／ `frame$e ~navigation ） ／
`Worker^I 実行~文脈
］の作成を統治する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The child-src directive governs the creation of nested browsing contexts (e.g. iframe and frame navigations) and Worker execution contexts. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "child-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
この指令は、［
~frame／~worker
］を拡充するような`要請$
— 公式的には，次に該当する`要請$ —
を制御する：
◎
This directive controls requests which will populate a frame or a worker. More formally, requests falling into one of the following categories:
</p>

<ul>
	<li>
［
`行先$rq ~EQ `document^l
］~AND［
その`~target閲覧文脈$rqは `入子の閲覧文脈$である
］
（例：
`iframe$e ／ `frame$e
要素を拡充するような要請）。
◎
destination is "document", and whose target browsing context is a nested browsing context (e.g. requests which will populate an iframe or frame element)
</li>
	<li>
`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
（順に，［
`ServiceWorker$I,
`SharedWorker$I,
`Worker$I
］に対する，`~workerを走らす$~algoに投入される）。
◎
destination is either "serviceworker", "sharedworker", or "worker" (which are fed to the run a worker algorithm for ServiceWorker, SharedWorker, and Worker, respectively).
</li>
</ul>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
Content-Security-Policy: `child-src$dir https://example.com/
</pre>

<p>
次の~codeによる どの~fetchも，~network~errorを返す
— 供された~URLは，どれも
`child-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will all return network errors, as the URLs provided do not match child-src's source list:
</p>

<pre class="html-code">
&lt;iframe src="https://not-example.com"&gt;&lt;/iframe&gt;
&lt;script&gt;
  var %blockedWorker = new Worker("data:application/javascript,...");
&lt;/script&gt;
</pre>

</div>


				<section id="child-src-algorithms">
<h5 title="Algorithms">6.1.1.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請 )
に対し：
◎
Given a request (request):
</p>

<p class="issue">
~UNSPECIFIED
◎
TODO.
</p>

<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p class="issue">
~UNSPECIFIED
◎
TODO.
</p>


				</section>
			</section>
			<section id="directive-connect-src">
<h4>6.1.2. `connect-src^dir</h4>

<p>
`connect-src@dir
指令は、［
~script~interfaceを利用して読込める~URL
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The connect-src directive restricts the URLs which can be loaded using script interfaces. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "connect-src"
`directive-value$p = `serialized-source-list$p
</pre>


<p>
この指令は、~dataを他の生成元［
へ伝送する／から受信する
］ような`要請$を制御する。
それらには、次の API が含まれる：［
`fetch()$m,
`XHR$r,
`EVENTSOURCE$r,
`BEACON$r,
［
`a$e 要素の `ping$a 属性
］］。
この指令は<em>また</em>、 `WEBSOCKETS$r 接続も制御する
— それは技術的には Fetch の一部ではないが。
◎
This directive controls requests which transmit or receive data from other origins. This includes APIs like fetch(), [XHR], [EVENTSOURCE], [BEACON], and a's ping. This directive also controls WebSocket [WEBSOCKETS] connections, though those aren’t technically part of Fetch.
</p>

<div class="example">

<div class="p">
<p>
~JSは、［
情報を送受信するために外部~serverへ直接的に接続する
］ための，少数の仕組みを提供0する：
</p>

<ul>
	<li>
`EventSource$I は、［
~push通知を受信するために，~serverへ開いた HTTP 接続
］を，維持する。
</li>
	<li>
`WebSocket$I は、~browser↔~server間で，双方向通信channelを開く。
</li>
	<li>
`XMLHttpRequest$I は、任意の ~HTTP要請を，~web開発者に利するために発行する。
</li>
</ul>

<p>
これらは，有用な機能性を可能化する強力な API だが、
exfiltration （内部から外へ秘密裏に~dataを転送する）へ誘う道も提供する。
</p>
◎
JavaScript offers a few mechanisms that directly connect to an external server to send or receive information. EventSource maintains an open HTTP connection to a server in order to receive push notifications, WebSockets open a bidirectional communication channel between your browser and a server, and XMLHttpRequest makes arbitrary HTTP requests on your behalf. These are powerful APIs that enable useful functionality, but also provide tempting avenues for data exfiltration.
</div>


<p>
`connect-src$dir
指令は、［
これらの類の接続は，~web開発者が信用する生成元に限って開かれる
］ことを確保できるようにする。
［
この指令に対する~source式の~listを定義する施策
］の送信は、簡単である。
例えば，接続を
`https://example.com^s
のみに制限するときは、次の~headerを送信する：
◎
The connect-src directive allows you to ensure that these and similar sorts of connections are only opened to origins you trust. Sending a policy that defines a list of source expressions for this directive is straightforward. For example, to limit connections to only https://example.com, send the following header:
</p>

<pre class="http-code">
Content-Security-Policy: `connect-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，いずれも~network~errorを返すことになる
— 供された~URLは，どれも
`connect-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will all return network errors, as the URLs provided do not match connect-src's source list:
</p>

<pre class="html-code">
&lt;a ping="https://not-example.com"&gt;...
&lt;script&gt;
  var %xhr = new XMLHttpRequest();
  %xhr.open('GET', 'https://not-example.com/');
  %xhr.send();

  var %ws = new WebSocket("https://not-example.com/");

  var %es = new EventSource("https://not-example.com/");

  navigator.sendBeacon("https://not-example.com/", { ... });
&lt;/script&gt;
</pre>
</div>



				<section id="connect-src-algorithms">
<h5 title="Algorithms">6.1.2.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`起動元$rq ~EQ `fetch^l
］~OR［［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`行先$rq ~EQ `subresource^l
］］：
◎
If request’s initiator is "fetch", or its type is "" and destination is "subresource":
</p>
		<ol>
			<li>
~IF［
( %要請 の`~url$rq, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on request’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`起動元$rq ~EQ `fetch^l
］~OR［［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`行先$rq ~EQ `subresource^l
］］：
◎
If request’s initiator is "fetch", or its type is "" and destination is "subresource":
</p>
		<ol>
			<li>
~IF［
( %応答 の`~url$rs, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on response’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-default-src">
<h4>6.1.3. `default-src^dir</h4>

<p>
`default-src@dir
指令は、他の`~fetch指令$に対する~fallbackとして~~働く。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The default-src directive serves as a fallback for the other fetch directives. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "default-src"
`directive-value$p = `serialized-source-list$p
</pre>


<p>
施策~内に `default-src$dir 指令が在する場合、その値は，施策の既定の`~source~list$として利用されることになる。
すなわち、
`default-src 'none'; script-src 'self'^s
が与えられたなら、~script要請は，照合する`~source~list$として，
`self$pl を利用する。
他の要請は， `none$pl を利用することになる。
これは、［
`要請は~CSPにより阻止されるべきか？$A,
`要請に対する応答は~CSPにより阻止されるべきか？$A
］~algoにてより詳細に~~述べられる。
◎
If a default-src directive is present in a policy, its value will be used as the policy’s default source list. That is, given default-src 'none'; script-src 'self', script requests will use 'self' as the source list to match against. Other requests will use 'none'. This is spelled out in more detail in the §4.1.3 Should request be blocked by Content Security Policy? and §4.1.4 Should response to request be blocked by Content Security Policy? algorithms.
</p>

<div class="example">

<p>
次の~headerは：
◎
The following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h: `default-src$dir `self$pl
</pre>

<p>
次の~headerと同じ挙動になる：
◎
will have the same behavior as the following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `child-src$dir `self$pl;
    `connect-src$dir `self$pl;
    `font-src$dir `self$pl;
    `img-src$dir `self$pl;
    `manifest-src$dir `self$pl;
    `media-src$dir `self$pl;
    `object-src$dir `self$pl;
    `script-src$dir `self$pl;
    `style-src$dir `self$pl;
</pre>

<p>
すなわち、 `default-src$dir が設定されているときは，明示的に設定されていない どの`~fetch指令$も， `default-src$dir が指定する値に~fall-backすることになる。
◎
That is, when default-src is set, every fetch directive that isn’t explicitly set will fall back to the value default-src specifies.
</p>
</div>

<div class="example">

<p>
継承はない。
例えば， `script-src$dir 指令が明示的に指定されている場合、
`default-src$dir の値は
~script要請には波及しない。
すなわち、次の~headerは：
◎
There is no inheritance. If a script-src directive is explicitly specified, for example, then the value of default-src has no influence on script requests. That is, the following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `default-src$dir `self$pl;
    `script-src$dir https://example.com
</pre>

<p>
次の~headerと同じ挙動になる：
◎
will have the same behavior as the following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `child-src$dir `self$pl;
    `connect-src$dir `self$pl;
    `font-src$dir `self$pl;
    `img-src$dir `self$pl;
    `manifest-src$dir `self$pl;
    `media-src$dir `self$pl;
    `object-src$dir `self$pl;
    `script-src$dir https://example.com;
    `style-src$dir `self$pl;
</pre>

<p>
この挙動の下で，~siteのために施策を築く良い仕方の一つは、まず， `default-src$dir を `none$pl にする所から始め、［
施策が適用される特定0の~pageに必要とされる資源~型
］のみが許容されるように，施策を築上げるものになるであろう。
◎
Given this behavior, one good way to build a policy for a site would be to begin with a default-src of 'none', and to build up a policy from there which allowed only those resource types which are necessary for the particular page the policy will apply to.
</p>
</div>



				<section id="default-src-algorithms">
<h5 title="Algorithms">6.1.3.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
%名前 ~LET
%要請 に対する`有効な指令を取得-$Aした結果
◎
Let name be the result of executing §6.1.13.5 Get the effective directive for request on request.
</li>
	<li>
~IF［
%名前 ~EQ ~NULL
］
⇒
~RET `許容ed^i
◎
If name is null, return "Allowed".
</li>
	<li>
~IF［
%施策 は［
`名前$ ~EQ %名前
］なる`指令$を包含する
］
⇒
~RET `許容ed^i
◎
If policy contains a directive whose name is name, return "Allowed".
</li>
	<li>
<p>
~IF［［
%名前 ~IN { `frame-src^l, `worker-src^l }
］~AND［
%施策 は［
`名前$ ~EQ `child-src^l
］なる`指令$を包含する
］
⇒
~RET `許容ed^i
◎
If name is "frame-src" or "worker-src", and policy contains a directive whose name is "child-src", return "Allowed".
</p>

<p class="note">注記：
この特別な事例を除去できればすてきなのだが。
おそらく、 “有効な指令” は `child-src^l を返すようにして、何らかの仕方で，この~algoが行うことを外へ移譲することもできるのでは？
◎
Note: It would be lovely to remove this special case. Perhaps "effective directive" could return "child-src" and that could delegate out in the same way this algorithm does?
</p>
	</li>
	<li>
~RET
( %要請, %施策 )
を与える下で，［
`名前$ ~EQ %名前
］なる`指令$に対し，`要請前~検査$Aを実行した結果
◎
Otherwise, return the result of executing the pre-request check for the directive whose name is name on request and policy, using this directive’s value for the comparison.
</li>
</ol>



<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
%名前 ~LET %要請 に対する`有効な指令を取得-$Aした結果
◎
Let name be the result of executing §6.1.13.5 Get the effective directive for request on request.
</li>
	<li>
~IF［
%名前 ~EQ ~NULL
］
⇒
~RET `許容ed^i
◎
If name is null, return "Allowed".
</li>
	<li>
~IF［
%施策 は［
`名前$ ~EQ %名前
］なる`指令$を包含する
］
⇒
~RET `許容ed^i
◎
If policy contains a directive whose name is name, return "Allowed".
</li>
	<li>
<p>
~IF［［
%名前 ~IN { `frame-src^l, `worker-src^l }
］~AND［
%施策 は［
`名前$ ~EQ `child-src^l
］なる`指令$を包含する
］
⇒
~RET `許容ed^i
◎
If name is "frame-src" or "worker-src", and policy contains a directive whose name is "child-src", return "Allowed".
</p>

<p class="note">注記：
この特別な事例を除去できればすてきなのだが。
おそらく、 “有効な指令” は `child-src^l を返すようにして、何らかの仕方で，この~algoが行うことを外へ移譲することもできるのでは？
◎
Note: It would be lovely to remove this special case. Perhaps "effective directive" could return "child-src" and that could delegate out in the same way this algorithm does?
</p>
	</li>
	<li>
~RET
( %要請, %施策 )
を与える下で，［
`名前$ ~EQ %名前
］なる`指令$に対し，`要請前~検査$Aを実行した結果
◎
Otherwise, return the result of executing the pre-request check for the directive whose name is name on request and policy, using this directive’s value for the comparison.
</li>
</ol>




				</section>
			</section>
			<section id="directive-font-src">
<h4>6.1.4. `font-src^dir</h4>

<p>
`font-src@dir
指令は、［
どの~URLから~font資源を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The font-src directive restricts the URLs from which font resources may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "font-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">
<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
Content-Security-Policy: `font-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`font-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match font-src's source list:
</p>

<pre class="html-code">
&lt;style&gt;
  @font-face {
    font-family: "Example Font";
    src: url("https://not-example.com/font");
  }
  body {
    font-family: "Example Font";
  }
&lt;/style&gt;
</pre>
</div>



				<section id="font-src-algorithms">
<h5 title="Algorithms">6.1.4.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `font^l
］：
◎
If request’s type is "font":
</p>
		<ol>
			<li>
~IF［
( %要請 の`~url$rq, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on request’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `font^l
］：
◎
If request’s type is "font":
</p>
		<ol>
			<li>
~IF［
( %応答 の`~url$rs, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on response’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-frame-src">
<h4>6.1.5. `frame-src^dir</h4>

<p>
`frame-src@dir
指令は、［
どの~URLを`入子の閲覧文脈$内に読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The frame-src directive restricts the URLs which may be loaded into nested browsing contexts. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "frame-src"
`directive-value$p = `serialized-source-list$p
</pre>


<div class="example">
<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
Content-Security-Policy: `frame-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは、~network~errorを返すことになる
— 供された~URLは，
`frame-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match frame-src's source list:
</p>

<pre class="html-code">
&lt;iframe src="https://not-example.com/"&gt;
&lt;/iframe&gt;
</pre>
</div>


				<section id="frame-src-algorithms">
<h5 title="Algorithms">6.1.5.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>

	<li>
<p>
~IF［
%要請 の`種別$rq† ~EQ `document^l
］~AND［
%要請 の`~target閲覧文脈$rqは`入子の閲覧文脈$である
］：
◎
If request’s type is "document" and target browsing context is a nested browsing context:
</p>

<p class="trans-note">【†
`行先$rqの誤記？（下の要請後~検査の “種別” も同様）
】</p>

		<ol>
			<li>
~IF［
( %要請 の`~url$rq, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on request’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>


<ol>

	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `document^l
］~AND［
%要請 の`~target閲覧文脈$rqは`入子の閲覧文脈$である
］：
◎
If request’s type is "document" and target browsing context is a nested browsing context:
</p>

		<ol>
			<li>
~IF［
( %応答 の`~url$rs, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on response’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>

</ol>



				</section>
			</section>
			<section id="directive-img-src">
<h4>6.1.6. `img-src^dir</h4>

<p>
`img-src@dir
指令は、［
どの~URLから画像~資源を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The img-src directive restricts the URLs from which image resources may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "img-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
この指令は、画像を読込む`要請$
— 公式的には，次に該当する`要請$ —
を制御する
`FETCH$r
⇒
`種別$rq ~EQ `image^l
◎
This directive controls requests which load images. More formally, this includes requests whose type is "image" [FETCH].
</p>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
Content-Security-Policy: `img-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは、~network~errorを返すことになる
— 供された~URLは，
`img-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match img-src's source list:
</p>

<pre class="html-code">
&lt;img src="https://not-example.com/img"&gt;
</pre>
</div>


				<section id="img-src-algorithms">
<h5 title="Algorithms">6.1.6.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `image^l
］：
◎
If request’s type is "image":
</p>
		<ol>
			<li>
~IF［
( %要請 の`~url$rq, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on request’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `image^l
］：
◎
If request’s type is "image":
</p>
		<ol>
			<li>
~IF［
( %応答 の`~url$rs, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on response’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-manifest-src">
<h4>6.1.7. `manifest-src^dir</h4>

<p>
`manifest-src@dir
指令は、［
~app~manifest `APPMANIFEST$r を読込んでもよい URL
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The manifest-src directive restricts the URLs from which application manifests may be loaded [APPMANIFEST]. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "manifest-src"
`directive-value$p = serialized-source-list
</pre>

<div class="example">
<p >
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
Content-Security-Policy: manifest-src https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`manifest-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match manifest-src's source list:
</p>

<pre class="html-code">
&lt;link rel="manifest" href="https://not-example.com/manifest"&gt;
</pre>

</div>

				<section id="manifest-src-algorithms">
<h5 title="Algorithms">6.1.7.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`起動元$rq ~EQ `manifest^l
］：
◎
If request’s type is "", and its initiator is "manifest":
</p>
		<ol>
			<li>
~IF［
( %要請 の`~url$rq, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on request’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`起動元$rq ~EQ `manifest^l
］：
◎
If request’s type is "", and its initiator is "manifest":
</p>
		<ol>
			<li>
~IF［
( %応答 の`~url$rs, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on response’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-media-src">
<h4>6.1.8. `media-src^dir</h4>

<p>
`media-src@dir
指令は、［
どの~URLから［
動画, 音声 および
結付けられている~text~track
］資源を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The media-src directive restricts the URLs from which video, audio, and associated text track resources may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "media-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
Content-Security-Policy: `media-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`media-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match media-src's source list:
</p>

<pre class="html-code">
&lt;audio src="https://not-example.com/audio"&gt;&lt;/audio&gt;
&lt;video src="https://not-example.com/video"&gt;
    &lt;track kind="subtitles" src="https://not-example.com/subtitles"&gt;
&lt;/video&gt;
</pre>
</div>



				<section id="media-src-algorithms">
<h5 title="Algorithms">6.1.8.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`種別$rq ~IN { `audio^l, `video^l, `track^l }
］：
◎
If request’s type is one of "audio", "video", or "track":
</p>
		<ol>
			<li>
~IF［
( %要請 の`~url$rq, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on request’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`種別$rq ~IN { `audio^l, `video^l, `track^l }
］：
◎
If request’s type is one of "audio", "video", or "track":
</p>
		<ol>
			<li>
~IF［
( %応答 の`~url$rs, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on response’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-object-src">
<h4>6.1.9. `object-src^dir</h4>

<p>
`object-src@dir
指令は、［
どの~URLから~plugin内容を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The object-src directive restricts the URLs from which plugin content may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "object-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
Content-Security-Policy: `object-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`object-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match object-src's source list:
</p>

<pre class="html-code">
&lt;embed src="https://not-example.com/flash"&gt;&lt;/embed&gt;
&lt;object data="https://not-example.com/flash"&gt;&lt;/object&gt;
&lt;applet archive="https://not-example.com/flash"&gt;&lt;/applet&gt;
</pre>
</div>

<p>
~URLを伴わない~pluginにより内容が読込まれる場合（おそらく、 `object$e 要素は `data$a 属性を欠いていて，指定された `type^a に基づいて何らかの既定~pluginを読込もうとしている）、
`object-src$dir の値が `none$pl ならば，阻止され~MUST
— 他の場合、許容されることになる。
◎
If plugin content is loaded without an associated URL (perhaps an object element lacks a data attribute, but loads some default plugin based on the specified type), it MUST be blocked if object-src's value is 'none', but will otherwise be allowed.
</p>

<p class="note">注記：
`object-src$dir 指令は、［
`object$e ／ `embed$e ／ `applet$e
］要素がそれ自身のために発行する どの要請に対しても動作する。
これには、前者の二つ（~navigationも含む）により生成される
`入子の閲覧文脈$を拡充させるような要請も含まれる。
このことは、［
MIME 型が `text/html^c であるような `object$e 要素
］など，~dataが［
さもなければ別の指令により制約されるような内容
］に意味論的に等価であるときにも該当する。
◎
Note: The object-src directive acts upon any request made on behalf of an object, embed, or applet element. This includes requests which would populate the nested browsing context generated by the former two (also including navigations). This is true even when the data is semantically equivalent to content which would otherwise be restricted by another directive, such as an object element with a text/html MIME type.
</p>



				<section id="object-src-algorithms">
<h5 title="Algorithms">6.1.9.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`行先$rq ~EQ `unknown^l
］：
◎
If request’s type is "", and its destination is "unknown":
</p>
		<ol>
			<li>
~IF［
( %要請 の`~url$rq, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on request’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`行先$rq ~EQ `unknown^l
］：
◎
If request’s type is "", and its destination is "unknown":
</p>
		<ol>
			<li>
~IF［
( %応答 の`~url$rs, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on response’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
			</section>
			<section id="directive-script-src">
<h4>6.1.10. `script-src^dir</h4>

<p>
`script-src@dir
指令は、［
どの所在からの~scriptを実行してよいか
］を制約する。
これには、［
`script$e 要素の中に直接的に読込まれる~URL
］のみならず，［
~inline~script~blockや XSLT ~stylesheet `XSLT$r の様な，~script実行を誘発し得るもの
］も含まれる。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The script-src directive restricts the locations from which scripts may be executed. This includes not only URLs loaded directly into script elements, but also things like inline script blocks and XSLT stylesheets [XSLT] which can trigger script execution. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "script-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
`script-src$dir
指令は、次について統治する：
◎
The script-src directive governs four things:
</p>

<ul>
	<li>
~script`要請$は、
`要請は~CSPにより阻止されるべきか？$A
に合格し~MUST
◎
Script requests MUST pass through §4.1.3 Should request be blocked by Content Security Policy?.
</li>
	<li>
~script`応答$は、
`要請に対する応答は~CSPにより阻止されるべきか？$A
に合格し~MUST。
◎
Script responses MUST pass through §4.1.4 Should response to request be blocked by Content Security Policy?.
</li>
	<li>
<p >
~inline `script$e 要素~blockは、
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
合格し~MUST。
その挙動は、どの施策も 次のいずれかにより~inline~scriptを許容していない限り，阻止されることになる：
</p>

<ul ><li>`script-src$dir （または `default-src$dir ）指令を指定しないことにより、暗黙的に。
</li><li>その~inline~blockに合致する［
`unsafe-inline$pl ／
`nonce-source$p ／
`hash-source$p
］で，明示的に~whitelist化することにより。
</li></ul>

◎
Inline script blocks MUST pass through §4.2.3 Should element’s inline type behavior be blocked by Content Security Policy?. Their behavior will be blocked unless every policy allows inline script, either implicitly by not specifying a script-src (or default-src) directive, or explicitly, by whitelisting "unsafe-inline", a nonce-source or a hash-source that matches the inline block.
</li>
	<li>
<p>
次の~JS実行~sink†は、
`unsafe-eval$pl ~source式で通過制御される：
◎
The following JavaScript execution sinks are gated on the "unsafe-eval" source expression:
</p>
		<ul>
			<li>
`eval()$c
◎
eval()
</li>
			<li>
`Function()$c
◎
Function()
</li>
			<li>
第一~引数は~callableでない，
`setTimeout()$m
◎
setTimeout() with an initial argument which is not callable.
</li>
			<li>
第一~引数は~callableでない，
`setInterval()$m
◎
setInterval() with an initial argument which is not callable.
</li>
	</ul>

<p class="note">注記：
`setImmediate()^m や `execScript()^m
の様な非~標準~sinkを実装する~UAは、それらも
`unsafe-eval$pl 上で通過制御する~SHOULDである。
◎
Note: If a user agent implements non-standard sinks like setImmediate() or execScript(), they SHOULD also be gated on "unsafe-eval".
</p>
	</li>
</ul>

<p class="trans-note">【†
保安~文脈における~sink（ “槽” ）とは、~data~flowにおいて，最初に~app層に渡される，外部からの信用できない~data源を意味する（
<a href="https://code.google.com/p/domxsswiki/wiki/Sinks" >参考</a>
）。
実行~sink（ execution sink ）とは、~scriptの~sourceとして構文解析された上で実行され得る（したがって脆弱性の源になり得る）ような文字列~data源となる~sinkを意味する。
】</p>
<!-- 
~callable
Iscallable
-->



				<section id="script-src-algorithms">
<h5 title="Algorithms">6.1.10.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `script^l
］~AND［
%要請 の`行先$rq ~EQ `subresource^l
］：
◎
If request’s type is "script", and its destination is "subresource":
</p>
		<ol>
			<li>
~IF［
( %要請 の`暗号用~nonce~metadata$rq, %~list )
に対する，
`~nonceは~source~listに合致するか？$A
の結果 ~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.1.13.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>



			<li>
<p>
~IF［
この指令の`値$は［
`hash-source$p 文法に合致するような `~source式$
］を 1 個以上~包含する
］~AND［
%要請 の `完全性~metadata$rq ~NEQ 空~文字列
］：
◎
If this directive’s value contains one or more source expressions that match the hash-source grammar, and request’s integrity metadata is not the empty string, then:
</p>

				<ol>
					<li>
`完全性~sourceたち^v ~LET
%要請 の`完全性~metadata$rqを渡して，
`~metadataを構文解析-$した結果 `SRI$r
◎
Let integrity sources be the result of executing the Subresource Integrity §parse-metadata algorithm on request’s integrity metadata. [SRI]
</li>

					<li>
~Assert：
`完全性~sourceたち^v ~NEQ `~metadataなし^i
◎
Assert: integrity sources is not "no metadata".
</li>

					<li>
<p>
~IF［
`完全性~sourceたち^v 内のどの %~source に対しても，［
次の両者を満たす `~source式$ %式
］が %~list に包含されている
］…：
</p>

<ul ><li>%~source の `hash-algo^P 成分 ~EQ %式 の `hash-algorithm$p 成分
</li><li>%~source の `base64-value^P 成分 ~EQ %式 の `base64-value$p 成分
</li></ul>

<p>
…ならば
⇒
~RET `許容ed^i
— 完全性~合致に因り。
◎
Let bypass due to integrity match be true.
◎
For each source in integrity sources:
◎
If this directive’s value does not contain a source expression whose hash-algorithm is a case-sensitive match for source’s hash-algo component, and whose base64-value is a case-sensitive match for source’s base64-value, then set bypass due to integrity match to false.
◎
If bypass due to integrity match is true, return "Allowed".
</li>

				</ol>

<p class="note">注記：
ここで検証0するのは、［
%要請 の`完全性~metadata$rqで与えられる~metadataの集合
］が［
この指令により~whitelist化された `hash-source$p `~source式$たちの集合
］に包含されているかどうかまでである。
これは、応答において合致しない資源を阻止するときに，~browserによる Subresource Integrity `SRI$r の施行に依拠している。
◎
Note: Here, we verify only that the request contains a set of integrity metadata which is a subset of the hash-source source expressions whitelisted by this directive. We rely on the browser’s enforcement of Subresource Integrity [SRI] to block non-matching resources upon response.
</p>

			</li>
			<li>
<p>
~IF［
%~list は［
`~source式$ ~EQ~ACI `strict-dynamic$pl
］を包含する
］：
◎
If this directive’s value contains a source expression that is an ASCII case-insensitive match for the "'strict-dynamic'" keyword-source:
</p>

				<ol>
					<li>
<p>
~IF［
%要請 の`構文解析器~metadata$rq ~EQ `parser-inserted^l
］
⇒
~RET `阻止ed^i
◎
If the request’s parser metadata is "parser-inserted", return "Blocked".
</p>

<p>
~ELSE
⇒
~RET `許容ed^i
◎
Otherwise, return "Allowed".
</p>

<p class="note">注記：
`strict-dynamic$pl についての詳細は
<a href="#strict-dynamic-usage">`strict-dynamic^pl の用法</a>
節に。
◎
Note: "'strict-dynamic'" is explained in more detail in §8.2 Usage of "'strict-dynamic'".
</p>

					</li>
				</ol>
			<li>
~IF［
( %要請 の`~url$rq, %~list )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on request’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>



<ol>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `script^l
］~AND［
%要請 の`行先$rq ~EQ `subresource^l
］：
◎
If request’s type is "script", and its destination is "subresource":
</p>
		<ol>
			<li>
~IF［
( %要請 の`暗号用~nonce~metadata$rq, %~list )
に対する，
`~nonceは~source~listに合致するか？$A
の結果 ~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.1.13.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>
			<li>
~Assert：［
%~list は `strict-dynamic$pl を包含しない
］~OR［
%要請 の`構文解析器~metadata$rq ~NEQ `parser-inserted^l
］
◎
Assert: This directive’s value does not contain "'strict-dynamic'", or request’s parser metadata is not "parser-inserted".
</li>

			<li>
~IF［
( %応答 の`~url$rs, %~list )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on response’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


<p>
この指令の`~inline検査$A~algoは、次で与えられる：
◎
This directive’s inline check algorithm is as follows:
</p>

<p>
所与の
( `要素$ %要素, 文字列 %型, 文字列 %~source )
に対し：
◎
Given an Element (element), a string (type), and a string (source):
</p>

<ol>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%型 ~EQ `script attribute^l
］：
◎
If type is "script attribute":
</p>
		<ol>
			<li>
~IF［
%~list 内には［
`~source式$ ~EQ~ACI `strict-dynamic$pl
］がある
］~AND［
%~list 内には［
`~source式$ ~EQ~ACI `unsafe-hashed-attributes$pl
］はない
］
⇒
~RET `阻止ed^i
◎
If list contains a source expression which is an ASCII case-insensitive match for the keyword-source "'strict-dynamic'", and does not contain a source expression which is an ASCII case-insensitive match for the keyword-source "'unsafe-hashed-attributes'", return "Blocked".
</li>

			<li>
~IF［
( %要素, %~list, %型, %~source )
を与える下で，
`要素 は ( 型, ~source ) について~source~listに合致するか？$A
を実行した結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.14.1 Does element match source list for type and source? on element, this directive’s value, and type is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>


	<li>
<p>
~IF［
%型 ~EQ `script^l
］：
◎
If type is "script":
</p>
		<ol>
			<li>
<p >
~IF［
%~list 内に［
`~source式$ ~EQ~ACI `strict-dynamic$pl
］がある
⇒
~RET `阻止ed^i
◎
If list contains a source expression which is an ASCII case-insensitive match for the keyword-source "'strict-dynamic'", return "Blocked".
</p>

<p class="note">注記：
`strict-dynamic$pl についての詳細は
<a href="#strict-dynamic-usage">`strict-dynamic^pl の用法</a>
節に。
◎
Note: "'strict-dynamic'" is explained in more detail in §8.2 Usage of "'strict-dynamic'".
</p>
			</li>
			<li>
~IF［
( %要素, %~list, %型, %~source )
を与える下で，
`要素 は ( 型, ~source ) について~source~listに合致するか？$A
を実行した結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.14.1 Does element match source list for type and source? on element, this directive’s value, and type is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-style-src">
<h4>6.1.11. `style-src^dir</h4>

<p>
`style-src@dir
指令は、［
どの所在からの~styleを`文書$に適用してよいかどうか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The style-src directive restricts the locations from which style may be applied to a Document. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "style-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
`style-src$dir 指令は、次について統治する：
◎
The style-src directive governs several things:
</p>

<ul>
	<li>
<p>
~style`要請$は、
`要請は~CSPにより阻止されるべきか？$A
に合格し~MUST。
これには、次のものが含まれる：
◎
Style requests MUST pass through §4.1.3 Should request be blocked by Content Security Policy?. This includes:
</p>
		<ul>
			<li>
`link$e 要素から生じている~stylesheet要請
◎
Stylesheet requests originating from a link element.
</li>
			<li>
<a href="~CSSWG/css-cascade-4/#at-ruledef-import"><code class="css">@import</code></a>
規則から生じている~stylesheet要請
◎
Stylesheet requests originating from the @import rule.
</li>
			<li>
`Link$h ~HTTP応答~headerから生じている~stylesheet要請
`RFC5988$r
◎
Stylesheet requests originating from a Link HTTP response header field [RFC5988].
</li>
		</ul>
	</li>
	<li>
~style要請に対する`応答$は、
`要請に対する応答は~CSPにより阻止されるべきか？$A
に合格し~MUST。
◎
Responses to style requests MUST pass through §4.1.4 Should response to request be blocked by Content Security Policy?.
</li>
	<li>
<p>
~inline `style$e 要素~blockは、
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
に合格し~MUST。
その~styleは、どの施策も 次のいずれかにより~inline~styleを許容していない限り，阻止されることになる：
</p>

		<ul>
			<li>
`style-src$dir （または `default-src$dir ）指令を指定しないことにより、暗黙的に。
</li>
			<li>
その~inline~blockに合致する［
`unsafe-inline$pl ／
`nonce-source$p ／
`hash-source$p
］で，明示的に~whitelist化することにより。
</li>
</ul>

◎
Inline style blocks MUST pass through §4.2.3 Should element’s inline type behavior be blocked by Content Security Policy?. The styles will be blocked unless every policy allows inline style, either implicitly by not specifying a style-src (or default-src) directive, or explicitly, by whitelisting "unsafe-inline", a nonce-source or a hash-source that matches the inline block.
</li>
	<li>
<p>
次の CSS ~algoは、 `unsafe-eval$pl ~source式で通過制御される：
◎
The following CSS algorithms are gated on the unsafe-eval source expression:
</p>
		<ul>
			<li>
`CSS 規則を挿入する$
◎
insert a CSS rule
</li>
			<li>
`CSS 規則を構文解析する$
◎
parse a CSS rule,
</li>
			<li>
`CSS 宣言~blockを構文解析する$
◎
parse a CSS declaration block
</li>
			<li>
`選択子の~groupを構文解析する$
◎
parse a group of selectors
</li>
	</ul>

<p>
これには、例えば， CSSOM の各種~interface上の［
`cssText^m 設定子 ／ `insertRule()^m ~method
］に対する すべての呼出が含まれることになる。
`CSSOM$r `HTML5$r
◎
This would include, for example, all invocations of CSSOM’s various cssText setters and insertRule methods [CSSOM] [HTML5].
</p>

<p class="issue">
これは、もっと良く説明される必要がある。
◎
This needs to be better explained.
</p>
	</li>
</ul>


				<section id="style-src-algorithms">
<h5 title="Algorithms">6.1.11.1. ~algo</h5>

<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `style^l
］：
◎
If request’s type is "style":
</p>

		<ol>
			<li>
~IF［
( %要請 の`暗号用~nonce~metadata$rq, %~list )
に対する，
`~nonceは~source~listに合致するか？$A
の結果 ~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.1.13.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>

			<li>
~IF［
( %要請 の`~url$rq, %~list )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on request’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `style^l
］：
◎
If request’s type is "style":
</p>

		<ol>
			<li>
~IF［
( %要請 の`暗号用~nonce~metadata$rq, %~list )
に対する，
`~nonceは~source~listに合致するか？$A
の結果 ~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.1.13.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>
			<li>
~IF［
( %応答 の`~url$rs, %~list )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on response’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

<p>
この指令の`~inline検査$A~algoは、次で与えられる：
◎
This directive’s inline check algorithm is as follows:
</p>

<p>
所与の
( `要素$ %要素, 文字列 %型, 文字列 %~source )
に対し：
◎
Given an Element (element), a string (type), and a string (source):
</p>

<ol>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%型 ~IN { `style^l, `style attribute^l }
］：
◎
If type is "style" or "style attribute":
</p>
		<ol>
			<li>
~IF［
( %要素, %~list, %型, %~source )
を与える下で，
`要素 は ( 型, ~source ) について~source~listに合致するか？$A
を実行した結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.14.1 Does element match source list for type and source? on element, this directive’s value, type, and source, is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


<p>
この指令の`初期化$A
~algoは、次で与えられる：
◎
This directive’s initialization algorithm is as follows:
</p>

<p class="issue">
CSSOM の~algoを監禁するために，実行~文脈に関わる何かをする。
CSSOM がこのための~hookを与えることは見込めないので、
<!-- ＊ -->
let’s work with them to put something reasonable together.
◎
Do something interesting to the execution context in order to lock down interesting CSSOM algorithms. I don’t think CSSOM gives us any hooks here, so let’s work with them to put something reasonable together.
</p>
				</section>
			</section>
			<section id="directive-worker-src">
<h4>6.1.12. `worker-src^dir</h4>

<p>
`worker-src@dir
指令は、［
どの~URLを［
`Worker$I ／ `SharedWorker$I ／ `ServiceWorker$I
］として読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The worker-src directive restricts the URLs which may be loaded as a Worker, SharedWorker, or ServiceWorker. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "worker-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
Content-Security-Policy: `worker-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`worker-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match worker-src's source list:
</p>


<pre class="html-code">
&lt;script&gt;
  var blockedWorker = new Worker("data:application/javascript,...");
  blockedWorker = new SharedWorker("https://not-example.com/");
  navigator.serviceWorker.register('https://not-example.com/sw.js');
&lt;/script&gt;</pre>

</div>

				<section id="worker-src-algorithms">
<h5 title="Algorithms">6.1.12.1. ~algo</h5>


<p>
この指令の`要請前~検査$Aは、次で与えられる：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>


<ol>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
］：
◎
If request’s destination is one of "serviceworker", "sharedworker", or "worker":
</p>

		<ol>
			<li>
~IF［
( %要請 の`~url$rs, %~list )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on request’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

<p>
この指令の`要請後~検査$Aは、次で与えられる：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
］：
◎
If request’s destination is one of "serviceworker", "sharedworker", or "worker":
</p>

		<ol>
			<li>
~IF［
( %応答 の`~url$rs, %~list )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.1.13.3 Does url match source list? on response’s url and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
			</section>
			<section id="fetch-directive-matching-url">
<h4 title="URL Matching Algorithms">6.1.13. URL 照合~algo</h4>


				<section id="does-request-violate-policy">
<h5 title="Does request violate policy?">6.1.13.1. %要請 は%施策 に違反するか？</h5>

<p>
次の~algoは、所与の
( `要請$ %要請, `施策$ %施策 )
に対し，［
%要請 が %施策 に違反するならば 違反された`指令$ ／
違反しないならば `非違反^i
］を返す：
◎
Given a request (request) and a policy (policy), this algorithm returns the violated directive if the request violates the policy, and "Does Not Violate" otherwise.
</p>

<ol>
	<li>
%違反ed指令 ~LET `非違反^i
◎
Let violates be "Does Not Violate".
</li>
	<li>
<p>
~FOR
%施策 内の ~EACH ( %指令 ) に対し：
◎
For each directive in policy:
</p>
		<ol>
			<li>
%結果 ~LET
( %要請, %施策 )
に対し，
%指令 の`要請前~検査$Aを実行した結果
◎
Let result be the result of executing directive’s pre-request check on request and policy.
</li>
			<li>
~IF［
%結果 ~EQ `阻止ed^i
］
⇒
%違反ed指令 ~LET %指令
◎
If result is "Blocked", then let violates be directive.
</li>
		</ol>
	</li>
	<li>
~RET %違反ed指令
◎
Return violates.
</li>
</ol>

				</section>
				<section id="match-nonce-to-source-list">
<h5 title="Does nonce match source list?">6.1.13.2. %~nonce は %~source~list に合致するか？</h5>

<p>
次の~algoは、所与の
( `要請$の`暗号用~nonce~metadata$rq %~nonce, `~source~list$ %~source~list )
に対し，［
%~nonce が %~source~list 内のいずれかの式に合致するならば `合致es^i ／
合致しないならば `非合致^i
］を返す：
◎
Given a request’s cryptographic nonce metadata (nonce) and a source list (source list), this algorithm returns "Matches" if the nonce matches one or more source expressions in the list, and "Does Not Match" otherwise:
</p>

<ol>
	<li>
~Assert：
%~source~list ~NEQ ~NULL
◎
Assert: source list is not null.
</li>
	<li>
~IF［
%~nonce ~EQ 空~文字列
］
⇒
~RET `非合致^i
◎
If nonce is the empty string, return "Does Not Match".
</li>
	<li>
<p>
~FOR
%~source~list 内の ~EACH ( %式 ) に対し：
◎
For each expression in source list:
</p>
		<ol>
			<li>
~IF［［
%式 は `nonce-source$p 文法に合致する
~AND
%~nonce ~EQ %式 の `base64-value$p 成分
］
⇒
~RET `合致es^i
◎
If expression matches the nonce-source grammar, and nonce is a case-sensitive match for expression’s base64-value part, return "Matches".
</li>
		</ol>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>

				</section>
				<section id="match-url-to-source-list">
<h5 title="Does url match source list?">6.1.13.3. %~url は %~source~list に合致するか？</h5>


<p>
次の~algoは、所与の
( `URL$u %~url, `~source~list$ %~source~list )
に対し，
%~url は %~source~list 内のいずれかの`~source式$に［
合致するならば `合致es^i ／
合致しないならば `非合致^i
］を返す：
◎
Given a URL (url), and a source list (source list), this algorithm returns "Matches" if the URL matches one or more source expressions in source list, or "Does Not Match" otherwise:
</p>

<ol>
	<li>
~Assert：
%~source~list ~NEQ ~NULL
◎
Assert: source list is not null.
</li>
	<li>
~IF［
%~source~list は空である
］
⇒
~RET `非合致^i
◎
If source list is an empty list, return "Does Not Match".
</li>
	<li>
<p >
~IF［
%~source~list は単独の文字列 %s のみからなる
］~AND［
%s ~EQ~ACI "`none$pl"
］
⇒
~RET `非合致^i
◎
If source list contains a single item which is an ASCII case-insensitive match for the string "'none'", return "Does Not Match".
</p>

<p class="note">注記：
空の %~source~list （すなわち、（
<samp>`script-src^dir host1</samp>
とは対照的に）値を伴わない指令
<samp>`script-src$dir</samp>
）は、 `none$pl を包含している %~source~list に等価になり，どの~URLにも合致しない。
◎
Note: An empty source list (that is, a directive without a value: script-src, as opposed to script-src host1) is equivalent to a source list containing 'none', and will not match any URL.
</p>
	</li>
	<li>
<p>
~FOR
%~source~list 内の ~EACH ( %式 ) に対し：
◎
For each expression in source list:
</p>
		<ol>
			<li>
~IF［［
( %~url, %式 ) 
に対する，
`~urlは ( 生成元, ~redirect回数 ) について式に合致するか？$A
の結果
］ ~EQ `合致es^i
］
⇒
~RET `合致es^i
◎
If §6.1.13.4 Does url match expression in origin with redirect count? returns "Matches" when executed upon url and expression, return "Matches".
</li>
		</ol>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>

				</section>
				<section id="match-url-to-source-expression">
<h5 title="Does url match expression in origin with redirect count?">6.1.13.4. %~url は ( %生成元, %~redirect回数 ) について %式 に合致するか？</h5>

<p>
次の~algoは、
( `URL$u %~url, `~source式$ %式, `生成元$ %生成元, 整数 %~redirect回数 )
が与えられた下で，
%~url が %式 に［
合致するならば `合致es^i ／
合致しないならば `非合致^i
］を返す：
◎
Given a URL (url), a source expression (expression), an origin (origin), and a number (redirect count), this algorithm returns "Matches" if url matches expression, and "Does Not Match" otherwise.
</p>

<p class="note">注記：
%生成元 は［
%式 が相対的に解決されるべき資源
］の`生成元$である
— 例えば "`self$pl" は、文脈の その一片に依存して別個の意味になる。
◎
Note: origin is the origin of the resource relative to which the expression should be resolved. "'self'", for instance, will have distinct meaning depending on that bit of context.
</p>


<ol>
	<li>
<p>
~IF［
%式 ~EQ `~asterisk$
］~AND［
%~url の`~scheme$uは`~network~scheme$uである
］
⇒
~RET `合致es^i
◎
If expression is the string "*", and url’s scheme is a network scheme, return "Matches".
</p>

<p class="note">注記：
この~logicは、［
非`~network~scheme$uからの資源を許容するためには，明示的に~whitelist化する必要がある
］ことを意味する
— 例：
`default-src * data: custom-scheme-1: custom-scheme-2:^s
。
言い換えれば、意味論的に最も寛容な %式 の表現は，ない。
◎
Note: This logic means that in order to allow resource from non-network scheme, it has to be explicitly whitelisted: default-src * data: custom-scheme-1: custom-scheme-2:. In other words, there is no semantic representation of most permissive expression.
</p>
	</li>
	<li>
<p>
~IF［
%式 は `scheme-source$p 文法に合致する (A)
］~OR［
%式 は `host-source$p 文法に合致する (B)
］：
◎
If expression matches the scheme-source or host-source grammar:
</p>
		<ol>
			<li>
%~scheme成分 ~LET ［
(A) ならば %式 ／
(B) ならば %式 の `scheme-part$p
］
◎
↓</li>
			<li>
<p>
~IF［
%~scheme成分 ~NEQ~ACI %~url の `~scheme$u
］~AND［
次のいずれの条件も満たされない
］
⇒
~RET `非合致^i
：
◎
If expression has a scheme-part that is not an ASCII case-insensitive match for url’s scheme, then return "Does Not Match" unless one of the following conditions is met:
</p>
				<ul>
					<li>
［
%~scheme成分 ~EQ~ACI `http^l
］~AND［
%~url の `~scheme$u ~EQ `https^l
］
◎
expression’s scheme-part is an ASCII case-insensitive match for "http" and url’s scheme is "https"
</li>
					<li>
［
%~scheme成分 ~EQ~ACI `ws^l
］~AND［
%~url の `~scheme$u ~IN
{ `wss^l, `http^l, `https^l }
］
◎
expression’s scheme-part is an ASCII case-insensitive match for "ws" and url’s scheme is "wss", "http" or "https"
</li>
					<li>
［
%~scheme成分 ~EQ~ACI `wss^l
］~AND［
%~url の `~scheme$u ~EQ `https^l
］
◎
expression’s scheme-part is an ASCII case-insensitive match for "wss" and url’s scheme is "https"
</li>
			</ul>
		</li>
		<li>
~IF［
(A)
］
⇒
~RET `合致es^i
◎
If expression matches the scheme-source grammar, return "Matches".
</li>
	</ol>

<p class="note">注記：
この~logicは、実質的に，［
`script-src http:^s
は
`script-src http: https:^s
に等価
<!-- ＊？
script-src http
script-src http https
-->
］, ［
`script-src http://example.com/^s
は
`script-src http://example.com https://example.com^s
に等価
］になることを意味する。
同様に，WebSocket ~schemeは、対応する HTTP ~schemeに等価になる。
手短に言えば、明示的に保安的~schemeでない式は，保安的~schemeへの昇格を常に許容する。
◎
Note: This logic effectively means that script-src http: is equivalent to script-src http: https:, and script-src http://example.com/ is equivalent to script-src http://example.com https://example.com. As well as WebSocket schemes are equivalent to corresponding HTTP schemes. In short, we always allow a secure upgrade from an explicitly insecure expression.
</p>
	</li>
	<li>
<p>
~IF［
%式 は `host-source$p 文法に合致する
］：
◎
If expression matches the host-source grammar:
</p>
		<ol>
			<li>
~IF［
%~url の`~host$u ~EQ ~NULL
］
⇒
~RET `非合致^i
◎
If url’s host is null, return "Does Not Match".
</li>
			<li>
<p>
~IF［
%式 は `scheme-part$p を持たない
］~AND［
次のいずれの条件も満たされない
］
⇒
~RET `非合致^i
：
◎
If expression does not have a scheme-part, then return "Does Not Match" unless one of the following conditions is met:
</p>
				<ol>
					<li>
%生成元 の`~scheme$u ~EQ %~url の`~scheme$u
◎
origin’s scheme is url’s scheme
</li>
					<li>
［
%生成元 の`~scheme$u ~EQ `http^l
］~AND［
%~url の`~scheme$u ~IN
{ `https^l, `ws^l, `wss^l }
］
◎
origin’s scheme is "http", and url’s scheme one of "https", "ws", or "wss".
</li>
					<li>
［
%生成元 の`~scheme$u ~EQ `https^l
］~AND［
%~url の`~scheme$u ~EQ `wss^l
］
◎
origin’s scheme is "https", and url’s scheme is "wss".
</li>
			</ol>

<p class="note">注記：
上の `scheme-part$p に対するときと同様に、~schemeを伴わない `host-source$p 式は，非保安的~schemeから保安的~schemeへの昇格を許容する。
◎
Note: As with scheme-part above, we allow schemeless host-source expressions to be upgraded from insecure schemes to secure schemes.
</p>
			</li>
			<li>
%~host成分 ~LET %式 の `host-part$p
◎
↓</li>
			<li>
<p>
~IF［
%~host成分 の最初の文字 ~EQ `~asterisk$
］：
◎
If the first character of expression’s host-part is an U+002A ASTERISK character (*):
</p>
				<ol>
					<li>
%残 ~SET %式 から先頭の`~asterisk$を除去した結果
◎
Let remaining be the result of removing the leading "*" from expression.
</li>
					<li>
~IF［
%残 ~NEQ~ACI［
%~url の`~host$uの（ %残 と同じ長さの）~~尾部
］］
⇒
~RET `非合致^i
◎
If remaining (including the leading U+002E FULL STOP character (.)) is not an ASCII case-insensitive match for the rightmost characters of url’s host, then return "Does Not Match".
</li>
				</ol>
			</li>
			<li>
~ELIF［
%~host成分 ~NEQ~ACI %~url の`~host$u
］
⇒
~RET `非合致^i
◎
If the first character of expression’s host-part is not an U+002A ASTERISK character (*), and url’s host is not an ASCII case-insensitive match for expression’s host-part, return "Does Not Match".
</li>
			<li>
<div>
<p>
~IF［
次のいずれかの条件が満たされる
］
⇒
~RET `非合致^i
</p>
				<ul>
					<li>
［
%~host成分 は `IPv4address$p 規則 `RFC3986$r に合致する
］~AND［
%~host成分 ~NEQ `127.0.0.1^l
］
</li>
					<li>
%~host成分 は `IPv6~address$uである
</li>
				</ul>

◎
If expression’s host-part matches the IPv4address rule from [RFC3986], and is not "127.0.0.1"; or if expression’s host-part is an IPv6 address, return "Does Not Match".
</div>

<p class="note">注記：
この仕様の将来~versionは、用法や需要に依存して，~literalによる［
IPv6 ／ IPv4
］~addressを許容するかもしれない。
しかしながら、 IP ~addressの保安上の特質は，名前を有する~hostに比して弱いので、作者には，可能0なら後者を選好することが奨励される。
◎
Note: A future version of this specification may allow literal IPv6 and IPv4 addresses, depending on usage and demand. Given the weak security properties of IP addresses in relation to named hosts, however, authors are encouraged to prefer the latter whenever possible.
</p>
			</li>
			<li>
%~port成分 ~LET 
%式 は `port-part$p を［
包含するならば それ ／
包含しないならば ~NULL
］
◎
↓</li>
			<li>
~IF［
%~port成分 ~EQ ~NULL
］~AND［
%~url の`~port$u ~NEQ %~url の`~scheme$uに対する`既定~port$u
］
⇒
~RET `非合致^i
◎
If expression does not contain a port-part, and url’s port is not the default port for url’s scheme, return "Does Not Match".
</li>
			<li>
~IF［
%~port成分 ~NIN { ~NULL, `~asterisk$ }
］~AND［
%~port成分 が表現する整数 ~NEQ %~url の`~port$u
］
⇒
~RET `非合致^i
◎
If expression does contain a port-part:
◎
	If expression’s port-part is not "*", and is not the same number as url’s port, return "Does Not Match".
</li>
			<li>
<p>
~IF［
%式 は
空でない `path-part$p を包含する
］~AND［
%~redirect回数 ~EQ 0
］：
◎
If expression contains a non-empty path-part, and redirect count is 0, then:
</p>
				<ol>
					<li>
%正確~合致 ~LET ［
%式 の `path-part$p の~~最後の文字 ~EQ `~slash$
ならば ~F ／
~ELSE_ ~T
］
◎
Let exact match be false if the final character of expression’s path-part is the U+002F SOLIDUS character (/), and true otherwise.
</li>
					<li>
%~path~list ~LET
%式 の `path-part$p を`~slash$で`厳密に分割-$した結果
◎
Let path list be the result of strictly splitting expression’s path-part on the U+002F SOLIDUS character (/).
</li>
					<li>
~IF［
%~path~list の~item数 ~GT %~url の`~path$uの~item数
］
⇒
~RET `非合致^i
◎
If path list has more items than url’s path, return "Does Not Match".
</li>
					<li>
~IF［
%正確~合致 ~EQ ~T
］~AND［
%~path~list の~item数 ~NEQ %~url の`~path$uの~item数
］
⇒
~RET `非合致^i
◎
If exact match is true, and path list does not have the same number of items as url’s path, return "Does Not Match".
</li>
					<li>
<p>
~FOR
%~path~list 内の ~EACH ( %式~path片 ) に対し：
◎
For each expression piece in path list:
</p>
						<ol>
							<li>
%~url~path片 ~LET %~url の`~path$u内の［
%式~path片 と同じ~index
］に位置する~item
◎
Let url piece be the next item in url’s path.
</li>
							<li>
~IF［
［
%式~path片 を`~percent復号-$uした結果
］ ~NEQ ［
%~url~path片 を`~percent復号-$uした結果
］
］
⇒
~RET `非合致^i
◎
Percent decode expression piece.
◎
Percent decode url piece.
◎
If expression piece is not a case-sensitive match for url piece, return "Does Not Match".
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~RET `合致es^i
◎
Return "Matches".
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%式 ~EQ~ACI "`self$pl"
］~AND［
次のいずれかの条件は満たされる
］
⇒
~RET `合致es^i
：
◎
If expression is an ASCII case-insensitive match for "'self'", return "Matches" if one or more of the following conditions is met:
</p>
		<ul>
			<li>
%生成元 と［
%~url の`生成元$u
］は同じである
◎
origin is the same as url’s origin
</li>
			<li>

<p>
次のどの条件も満たされる：
◎
↓</p>
				<ul>
					<li>
%生成元 の`~host$u ~EQ %~url の`~host$u
◎
↓</li>
					<li>
%生成元 の`~port$u ~EQ %~url の`~port$u
— この比較においては
⇒
両~urlのそれぞれに対し、その`~port$uに対する~NULL値は，その`~scheme$uに対する`既定~port$uと見なす。
◎
↓</li>
					<li>
<p>
次のいずれかの条件は満たされる：
◎
origin’s host is the same as url’s host, origin’s port and url’s {{URL/port} are either the same or the default ports for their respective schemes, and one or more of the following conditions is met:
</p>

						<ul>
							<li>
%~url の`~scheme$u ~IN
{ `https^l, `wss^l }
◎
url’s scheme is "https" or "wss"
</li>
							<li>
%生成元 の`~scheme$u ~EQ `http^l
◎
origin’s scheme is "http"
</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>

<p class="note">注記：
上の `scheme-part$p の~logicと同様に、
"`self$pl" 照合~algoは、そうするのが安全なときには，保安的~schemeへの昇格を許容する。
これらの昇格は、［
特定0の~schemeに対する既定の~port ／
被保護~資源の生成元に合致する~port
］上で稼働中の報告先に，制限される
— 昇格の成功-が理にかなうと期待されるものについて取り扱うには、これで十分と見られるので。
◎
Note: Like the scheme-part logic above, the "'self'" matching algorithm allows upgrades to secure schemes when it is safe to do so. We limit these upgrades to endpoints running on the default port for a particular scheme or a port that matches the origin of the protected resource, as this seems sufficient to deal with upgrades that can be reasonably expected to succeed.
</p>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>



				</section>
				<section id="effective-directive-for-a-request">
<h5 title="Get the effective directive for request">6.1.13.5. %要請 に対する有効な指令を取得する</h5>

<p>
各`~fetch指令$は、特定の型の`要請$を制御する。
次の~algoは、所与の
( `要請$ %要請 )
に対し，［
~NULL, または
`有効な指令@
の`名前$
］を返す：
◎
Each fetch directive controls a specific type of request. Given a request (request), the following algorithm returns either null or the name of the request’s effective directive:
</p>

<!-- ＊表形式化 -->

<ol>
	<li>
<p>
%要請 の`種別$rqに応じて：
◎
Switch on request’s type, and execute the associated steps:
</p>
		<dl class="switch">
			<dt>空~文字列</dt>
			<dd>
				<ol>
					<li>
~IF［
%要請 の`起動元$rq ~EQ `fetch^l
］
⇒
~RET `connect-src$dir
◎
If the request’s initiator is "fetch", return connect-src.
</li>
					<li>
~IF［
%要請 の`起動元$rq ~EQ `manifest^l
］
⇒
~RET `manifest-src$dir
◎
If the request’s initiator is "manifest", return manifest-src.
</li>
					<li>
~IF［
%要請 の`行先$rq ~EQ `subresource^l
］
⇒
~RET `connect-src$dir
◎
If the request’s destination is "subresource", return connect-src.
</li>
					<li>
~IF［
%要請 の`行先$rq ~EQ `unknown^l
］
⇒
~RET `object-src$dir
◎
If the request’s destination is "unknown", return object-src.
</li>
					<li>
~IF［
%要請 の`行先$rq ~EQ `document^l
］~AND［
%要請 の`~target閲覧文脈$rqは`入子の閲覧文脈$である
］
⇒
~RET `frame-src$dir
◎
If the request’s destination is "document" and the request’s target browsing context is a nested browsing context, return frame-src.
</li>
				</ol>
			</dd>

			<dt>`audio^l</dt>
			<dt>`track^l</dt>
			<dt>`video^l</dt>
			<dd>
<ol><li>~RET `media-src$dir
◎
Return media-src.
</li></ol>
			</dd>

			<dt>`font^l</dt>
			<dd>
<ol><li>~RET `font-src$dir
◎
Return font-src.
</li></ol>
			</dd>

			<dt>`image^l</dt>
			<dd>
<ol><li>~RET `image-src$dir
◎
Return image-src.
</li></ol>
			</dd>

			<dt>`style^l</dt>
			<dd>
<ol><li>~RET `style-src$dir
◎
Return style-src.
</li></ol>
			</dd>

			<dt>`script^l</dt>
			<dd>
				<ol>
					<li>
<p>
%要請 の`行先$rqに応じて：
◎
Switch on request’s destination, and execute the associated steps:
</p>
						<dl>
							<dt>`script^l</dt>
							<dt>`subresource^l</dt>
							<dd>
<ol><li>~RET `script-src$dir
◎
Return script-src.
</li></ol>
							</dd>

							<dt>`serviceworker^l</dt>
							<dt>`sharedworker^l</dt>
							<dt>`worker^l</dt>
							<dd>
<ol><li>~RET `worker-src$dir
◎
Return worker-src.
</li></ol>
							</dd>
						</dl>
					</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

				</section>
			</section>
			<section id="fetch-directive-matching-element">
<h4 title="Element Matching Algorithms">6.1.14. 要素に対する照合~algo</h4>

				<section id="match-element-to-source-list">
<h5 title="Does element match source list for type and source?">6.1.14.1. %要素 は ( %型, %~source ) について %~source~list に合致するか？</h5>

<p>
次の~algoは、
( `要素$ %要素, `~source~list$ %~list, 文字列 %型, 文字列 %~source )
が与えられた下で，［
`合致es^i または `非合致^i
］を返す：
◎
Given an Element (element), a source list (list), a string (type), and a string (source), this algorithm returns "Matches" or "Does Not Match".
</p>

<ol>
	<li>
<div class="p">
<p>
~Assert：
%~source は次のいずれか IDL 属性~値を包含する：
</p>

<ul ><li>`script$e 要素の `text$m 属性
</li><li>`style$e 要素の `textContent$m 属性
</li><li>`script$e 要素のいずれかの`~event~handler IDL 属性$
</li></ul>

◎
Assert: source contains the value of a script element’s text IDL attribute, the value of a style element’s textContent IDL attribute, or the value of one of a script element’s event handler IDL attribute.
</div>


<p class="note">注記：
このことは、 %~source は，自身が埋込まれている~pageの符号化方式で解釈されることを意味する。
詳細は、
<a href="#html-integration">HTML との統合</a>
節における統合~点を見よ。
◎
Note: This means that source will be interpreted with the encoding of the page in which it is embedded. See the integration points in §4.2 Integration with HTML for more detail.
</p>
	</li>
	<li>
~IF［
%型 %要素 は、［
名前 ~IN~ACI { `&lt;script^l, `&lt;style^l }
］なる属性を有する【？意味不明】
］
⇒
~RET `非合致^i
◎
If type element has an attribute whose name is an ASCII case-insensitive match for the string "&lt;script", or the string "&lt;style", then return "Does Not Match".
</li>
	<li>
( `~nonceか~hashを包含する^v , `~hashと属性を照合する^v )
~LET ( ~F, ~F )
◎
Let contains nonce or hash and hashes match attributes be false.
</li>
	<li>
<p>
~FOR
%~list 内の ~EACH ( %式 ) に対し：
◎
For each expression in list:
</p>
		<ol>
			<li>
~IF［
%式 は［
`nonce-source$p, `hash-source$p
］いずれかの文法に合致する
］
⇒
`~nonceか~hashを包含する^v ~SET ~T
◎
If expression matches the nonce-source or hash-source grammar, set contains nonce or hash to true.
</li>
			<li>
~IF［
%式 ~EQ~ACI `unsafe-hashed-attributes$pl
］
⇒
`~hashと属性を照合する^v ~SET ~T
◎
If expression is an ASCII case-insensitive match for the keyword-source "'unsafe-hashed-attributes'", set hashes match attributes to true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~nonceか~hashを包含する^v ~EQ ~F
］~AND［
%~list 内に［
`~source式$ ~EQ~ACI `unsafe-inline^pl
］がある
］
⇒
~RET `合致es^i
◎
If contains nonce or hash is false, and list contains a source expression which is an ASCII case-insensitive match for the string "'unsafe-inline'", then return "Matches".
</p>

<p class="note">注記：
この~logicは、 %~list が `unsafe-inline^pl に加えて［
`nonce-source$p, `hash-source$p
］のいずれかを包含している場合には、
`unsafe-inline^pl の効果はなくなることを意味する。
◎
Note: This logic means that if list contains both "'unsafe-inline'" and either nonce-source or hash-source, "'unsafe-inline'" will have no effect.
</p>
	</li>
	<li>
<p>
~IF［
%型 ~IN { `script^l, `style^l }
］：
◎
If type is "script" or "style":
</p>
		<ol>
			<li>
<p>
~FOR
%~list 内の ~EACH ( %式 ) に対し：
◎
For each expression in list:
</p>

				<ol>
					<li>
~IF［
%式 は `nonce-source$p 文法に合致する
］~AND［［
%要素 は `nonce$a 属性を有する
］~AND［
その値 ~EQ［
%式 の `base64-value$p 成分
］］
⇒
~RET `合致es^i
◎
If expression matches the nonce-source grammar, and element has a nonce attribute whose value is a case-sensitive match for expression’s base64-value part, return "Matches".
</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
~nonceは、~inlineの［
`script$e ／ `style$e
］要素には適用されるが、いずれの要素の属性にも適用されない。
◎
Note: Nonces only apply to inline script and inline style, not to attributes of either element.
</p>

	</li>
	<li>
<p>
~IF［
%型 ~IN { `script^l, `style^l }
］~OR［
`~hashと属性を照合する^v ~EQ ~T
］：
◎
If type is "script" or "style", or hashes match attributes is true:
</p>
		<ol>
			<li>
<p>
~FOR
%~list 内の ~EACH ( %式 ) に対し：
◎
For each expression in list:
</p>
				<ol>
					<li>
<p>
~IF［
%式 は `hash-source$p 文法に合致しない
］
⇒
~CONTINUE
◎
If expression matches the hash-source grammar:
</p>
					<li>
<p>
%~algo ~LET ［
%式 の`hash-algorithm$p 成分を `ASCII 小文字化$した結果
］に応じて，次で与えられる~algo：
◎
Let algorithm be null.
</p>

<dl class="switch">
	<dt>`sha256^l</dt>
	<dd>
`SHA-256$
◎
If expression’s hash-algorithm part is an ASCII case-insensitive match for "sha256", set algorithm to SHA-256.
</dd>

	<dt>`sha384^l</dt>
	<dd>
`SHA-384$
◎
If expression’s hash-algorithm part is an ASCII case-insensitive match for "sha384", set algorithm to SHA-384.
</dd>

	<dt>`sha512^l</dt>
	<dd>
`SHA-512$
◎
If expression’s hash-algorithm part is an ASCII case-insensitive match for "sha512", set algorithm to SHA-512.
</dd>

	<dt>その他</dt>
	<dd>
~NULL
◎
↓</dd>
</dl>
					</li>
					<li>
~IF［
%~algo ~EQ ~NULL
］
⇒
~CONTINUE
◎
If algorithm is not null:
</li>
					<li>
~IF［
%式 の `base64-value$p 成分 ~EQ［
%~source に %~algo を適用した結果
］を `base64 符号化-$した結果
］］
⇒
~RET `合致es^i
◎
Let actual be the result of base64 encoding the result of applying algorithm to source.
◎
If actual is a case-sensitive match for expression’s base64-value part, return "Matches".
</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
~hashは、~inlineの［
`script$e ／ `style$e
］に適用される。
`unsafe-hashed-attributes$pl ~source式が在する場合、それらも［
~event~handler ／ ~style属性
］に適用される。
◎
Note: Hashes apply to inline script and inline style. If the "'unsafe-hashed-attributes'" source expression is present, they will also apply to event handlers and style attributes.
</p>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>


				</section>
			</section>
		</section>
		<section id="directives-document">
<h3 title="Document Directives ">6.2. 文書~指令</h3>

<p>
この節の指令は、施策が適用される［
文書／~worker
］環境の~propertyを統治する。
◎
The following directives govern the properties of a document or worker environment to which a policy applies.
</p>

			<section id="directive-base-uri">
<h4 title="base-uri">6.2.1. `base-uri^dir</h4>

<p>
`base-uri@dir
指令は、`文書$の `base$e 要素に利用できる `URL$u を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The base-uri directive restricts the URLs which can be used in a Document's base element. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "base-uri"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
次の~algoは、この指令を
監視する／施行する
ために，［
HTML の，`凍結された基底~URLを設定する$~algo
］の間に~callされる：
◎
The following algorithm is called during HTML’s set the frozen base url algorithm in order to monitor and enforce this directive:
</p>



				<section id="allow-base-for-document">
<h5 title="Is base allowed for document? " data-algorithm="Is base allowed for document?">6.2.1.1. %文書 に対する %基底 は許容されるか？</h5>

<p>
次の~algoは、
( `URL$u %基底, `文書$ %文書 )
が与えられた下で，［
%基底 を `base$e 要素の `href$a 属性の値として利用できるならば `許容ed^i ／
~ELSE_ `阻止ed^i
］を返す：
◎
Given a URL (base), and a Document (document), this algorithm returns "Allowed" if base may be used as the value of a base element’s href attribute, and "Blocked" otherwise:
</p>

<ol>
	<li>
<p>
~FOR
%文書 の`大域~obj$の`~CSP~list$内の ~EACH( %施策 ) に対し：
◎
For each policy in document’s global object’s csp list:
</p>

<ol>
	<li>
%~source~list ~LET ~NULL
◎
Let source list be null.
</li>
	<li>
~IF［
%施策 の`指令~集合$内に［
`名前$ ~EQ `base-uri^l
］なる`指令$は在する
］
⇒
%~source~list ~SET ~その`指令$の`値$
◎
If a directive whose name is "base-uri" is present in policy’s directive set, set source list to that directive’s value.
</li>
	<li>
~IF［
%~source~list ~EQ ~NULL
］
⇒
~CONTINUE
◎
If source list is null, skip to the next policy.
</li>
	<li>
<p>
~IF［
( %基底, %~source~list )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］：
◎
If the result of executing §6.1.13.3 Does url match source list? on base and source list is "Does Not Match":
</p>
		<ol>
	<li>
%違反 ~LET
( %文書 の`大域~obj$, %施策, `base-uri$dir ) から
`違反~objを作成-$A1した結果
◎
Let violation be the result of executing §2.3.1 Create a violation object for global, policy, and directive on document’s global object, policy, and "base-uri".
</li>
	<li>
%違反 の`資源$vr ~SET `inline^l
◎
Set violation’s resource to "inline".
</li>
	<li>
%違反 を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on violation.
</li>
	<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l
］
⇒
~RET `阻止ed^i
◎
If policy’s disposition is "enforce", return "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li></ol>


				</section>
			</section>
			<section id="directive-plugin-types">
<h4 title="plugin-types">6.2.2. `plugin-types^dir</h4>

<p>
`plugin-types@dir
◎
plugin-types
</p>

<p class="issue">
HTML の~plugin読込み~algoの中への~hookを定義する。
◎
Define the hooks into HTML’s plugin loading algorithms.
</p>



			</section>
			<section id="directive-sandbox">
<h4 title="sandbox">6.2.3. `sandbox^dir</h4>

<p>
`sandbox@dir
指令は、［
それが `sandbox$a ~propertyを有する `iframe$e 内に含されていた
］かのように，~UAが資源に適用することになる HTML ~sandbox施策を指定する。
◎
The sandbox directive specifies an HTML sandbox policy which the user agent will apply to a resource, just as though it had been included in an iframe with a sandbox property.
</p>

<p>
この指令の名前と値の構文は、次の`~ABNF$で述べられる。
加えて，その各 `token^p 値は、
`HTML$r により［
`iframe$e の `sandbox$a 属性に許容される値
］として定義される，いずれかの~keywordで~MUST：
◎
The directive’s syntax is described by the following ABNF grammar, with the additional requirement that each token value MUST be one of the keywords defined by HTML specification as allowed values for the iframe sandbox attribute [HTML].
</p>

<pre class="ABNF">
`directive-name$p  = "sandbox"
`directive-value$p = "" / `token$p *( `RWS$P `token$p )
</pre>

<p>
この指令には、報告処理の要件はない
— この指令が［
`Content-Security-Policy-Report-Only$h ~header内で送達された ／
`meta$e 要素の中にある
］ときは、まるごと無視されることになる。
◎
This directive has no reporting requirements; it will be ignored entirely when delivered in a Content-Security-Policy-Report-Only header, or within a meta element.
</p>



				<section id="sandbox-algorithms">
<h5 title="Algorithms">6.2.3.1. ~algo</h5>

<p>
この指令の`応答~検査$Aは、次で与えられる：
◎
This directive’s response check algorithm is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
］：
◎
If request’s destination is one of "serviceworker", "sharedworker", or "worker":
</p>

<ol>
	<li>
%出力 ~LET この指令の`値$を入力に，`~sandbox用~指令を構文解析-$した結果
◎
↓</li>
	<li>
<p>
~IF［
`閲覧文脈~sandbox化( ~script )~flag$ ~IN %出力
］~OR［
`閲覧文脈~sandbox化( 生成元 )~flag$ ~IN %出力
］
⇒
~RET `阻止ed^i
◎
If the result of the Parse a sandboxing directive algorithm using this directive’s value as the input contains either the sandboxed scripts browsing context flag or the sandboxed origin browsing context flag flags, return "Blocked".
</p>

<p class="note">注記：
この段は、~workerを一意的~生成元<!-- ＊ -->の中に~sandbox化できるようにした場合には，変更する必要がある。
そうするのは、相当に理に適うものに見える。
◎
Note: This will need to change if we allow Workers to be sandboxed into unique origins, which seems like a pretty reasonable thing to do.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

<p>
この指令の`初期化$A~algoは、その施策~内に `sandbox$dir 値が在するかどうかに則って，
`文書$の`強制~sandbox用~flag集合$を次に従って調整する責を負う：
◎
This directive’s initialization algorithm is responsible for adjusting a Document's forced sandboxing flag set according to the sandbox values present in its policies, as follows:
</p>

<p>
所与の
( `文書$または`大域~obj$ %文脈, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a Document or global object (context), a response (response), and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%施策 の`処分先$ ~NEQ `Enforce^l
］~OR［
%文脈 は`文書$でない
］
⇒
~RET
◎
If policy’s disposition is not "Enforce", or context is not a Document, then abort this algorithm.
</p>

<p class="note">注記：
この段は、~workerを~sandbox化できるようにした場合には，変更する必要がある。
そうするのは、相当に理に適うものに見える。
◎
Note: This will need to change if we allow Workers to be sandboxed, which seems like a pretty reasonable thing to do.
</p>
	</li>
	<li>
この指令の`値$を入力に,
%文脈 の`強制~sandbox用~flag集合$を出力とする下で，
`~sandbox用~指令を構文解析-$する
◎
Parse a sandboxing directive using this directive’s value as the input, and context’s forced sandboxing flag set as the output.
</li>

</ol>

				</section>
			</section>
		</section>
		<section id="directives-navigation">
<h3 title="Navigation Directives ">6.3. ~navigation指令</h3>



			<section id="directive-form-action">
<h4 title="form-action">6.3.1. `form-action^dir</h4>

<p>
`form-action@dir
指令は、~form送信0の~targetに利用できる `URL$u を制約する。
◎
The form-action directive restricts the URLs which can be used as the target of a form submissions.
</p>

<p class="issue">
HTML の［
~navigation／~form送信0
］~algoの中への~hookを定義する。
◎
Define the hooks into HTML’s navigation and form submission algorithms.
</p>



			</section>
			<section id="directive-frame-ancestors">
<h4 title="frame-ancestors">6.3.2. `frame-ancestors^dir</h4>

<p>
`frame-ancestors@dir
指令は、［
`frame$e／`iframe$e／`object$e／`embed$e／`applet$e
］要素を利用して埋込める資源の `URL$u を制約する。
この指令を利用すれば、敵対的になり得る文脈の中に資源が埋込まれる~riskを避けることで、多くの UI Redressing 【 UI の着せ替え】 攻撃 `UISECURITY$r 避けることができる。
◎
The frame-ancestors directive restricts the URLs which can embed the resource using frame, iframe, object, embed, or applet element. Resources can use this directive to avoid many UI Redressing [UISECURITY] attacks, by avoiding the risk of being embedded into potentially hostile contexts.
</p>

<p>
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The directive’s syntax is described by the following ABNF grammar:
</p>

<pre class="ABNF">
`directive-name$p  = "frame-ancestors"
`directive-value$p = `ancestor-source-list$p

`ancestor-source-list@p
              = ( `ancestor-source$p *( `RWS$P `ancestor-source$p) )
              / "`none$pl"
`ancestor-source@p
              = `scheme-source$p
              / `host-source$p
              / "`self$pl"
</pre>

<p>
`meta$e 要素を介して宣言された施策~内に包含されている `frame-ancestors^dir 指令は、無視され~MUST。
◎
The frame-ancestors directive MUST be ignored when contained in a policy declared via a meta element.
</p>

<p class="note">注記：
`frame-ancestors^dir 指令は、構文は`~source~list$に類似するが，
`default-src^dir 指令が指定されていても その値に~fall-backしない。
すなわち、施策が
<samp>`default-src^dir `none$pl</samp>
を宣言していても、依然として，資源はどこからでも埋込まれることが許容される。
◎
Note: The frame-ancestors directive’s syntax is similar to a source list, but frame-ancestors will not fall back to the default-src directive’s value if one is specified. That is, a policy that declares default-src 'none' will still allow the resource to be embedded by anyone.
</p>



				<section id="frame-ancestors-algorithms">
<h5 title="Algorithms">6.3.2.1. ~algo</h5>

<p>
この指令の`応答~検査$Aは、次で与えられる：
◎
This directive’s response check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `document^l
］~AND［
%要請 の`~target閲覧文脈$rqは`入子の閲覧文脈$である
］：
◎
If request’s destination is "document" and the request’s target browsing context is a nested browsing context:
</p>

<ol>
	<li>
<p>
~FOR
%要請 の`~target閲覧文脈$rqの ~EACH( `先祖~閲覧文脈$ %先祖 ) に対し：
◎
For each ancestor of the request’s target browsing context’s ancestor browsing contexts:
</p>

<ol>
	<li>
%生成元~url ~LET ［［［
%先祖 にて`作動中の文書$
］の生成元
］を `Unicode 直列化-$した結果
］を，`~URL構文解析器$uにかけた結果
◎
Let origin-as-url be the result of executing the URL parser on the unicode serialization of ancestor’s active document’s origin.
</li>
	<li>
<p>
~IF［
( %生成元~url, この指令の`値$ )
に対する，
`~urlは~source~listに合致するか？$A
の結果 ~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If §6.1.13.3 Does url match source list? returns Does Not Match when executed upon origin-as-url and this directive’s value, return "Blocked".
</p>

<p class="issue">
一意的~生成元への合致を許容するような構文は必要か？
◎
Do we need syntax to allow matching a unique origin?
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

<p class="issue">
この~algoを HTML の~navigation~algoの用語で書き直す。
◎
Rewrite this in terms of HTML’s navigation algorithm.
</p>



				</section>
			</section>
		</section>
		<section id="directives-reporting">
<h3 title="Reporting Directives">6.4. 指令の報告処理</h3>

<p>
この文書~内の各種~algoは、報告処理~処理の中に~hookされる
—
［
( %大域~obj, … ) から`違反~objを作成-$Aする ／
( %要請, … ) から`違反~objを作成-$A1する
］手続きを介して`違反$~objを構築した上で、報告を送達するときに，その~objを
`違反を報告する$A手続きに渡すことにより。
◎
Various algorithms in this document hook into the reporting process by constructing a violation object via §2.3.2 Create a violation object for request, policy, and directive or §2.3.1 Create a violation object for global, policy, and directive, and passing that object to §5.3 Report a violation to deliver the report.
</p>

			<section id="directive-report-uri">
<h4 title="report-uri">6.4.1. `report-uri^dir</h4>

<div class="note">
<p>注記：
`report-uri$dir 指令は、非推奨にされた。
代わりに `report-to$dir を利用されたし。
後者が在する場合、この指令は無視されることになる。
後方互換性を確保するためには、次のように両者とも指定することを勧める：
◎
Note: The report-uri directive is deprecated. Please use the report-to directive instead. If the latter directive is present, this directive will be ignored. To ensure backwards compatibility, we suggest specifying both, like this:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    ...;
    `report-uri$dir https://endpoint.com;
    `report-to$dir groupname
</pre>
</div>





<p>
`report-uri@dir
指令は、`報告先$
— 特定0の挙動が防止されたとき，`違反~報告$の送信-先になる~netowrk端点 —
の集合を定義する。
◎
The report-uri directive defines a set of endpoints to which violation reports will be sent when particular behaviors are prevented.
</p>

<pre class="ABNF">
`directive-name$p  = "report-uri"
`directive-value$p = `uri-reference$p *( `RWS$P `uri-reference$p )
; The uri-reference grammar is defined in Section 4.1 of RFC 3986.
</pre>

<p>
この指令は、それ自身は効果を持たず，他の指令との組合せにおいてのみ効果を~~発揮する。
◎
The directive has no effect in and of itself, but only gains meaning in combination with other directives.
</p>

			</section>
			<section id="directive-report-to">
<h4 title="report-to">6.4.2. `report-to^dir</h4>

<p>
`report-to@dir
指令は、違反~報告の送信-先とされるべき`報告先~group$ `OOB-REPORTING$r
を定義する。
この指令の挙動は、`違反を報告する$A~algoにて定義される。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The report-to directive defines a reporting group to which violation reports ought to be sent [OOB-REPORTING]. The directive’s behavior is defined in §5.3 Report a violation. The directive’s name and value are described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "report-to"
`directive-value$p = `token$p
</pre>

			</section>
		</section>
		<section id="directives-elsewhere">
<h3 title="Directives Defined in Other Documents">6.5. 他の文書にて定義される指令</h3>

<p>
この文書は、中核を成す指令の集合を定義し、他の仕様が~modularに拡張するための枠組みを整える。
この文書が~~発行された時点では、次の安定的な文書が~CSPを拡張している：
◎
This document defines a core set of directives, and sets up a framework for modular extension by other specifications. At the time this document was produced, the following stable documents extend CSP:
</p>

<ul>
	<li>
`MIX$r は、
`block-all-mixed-content^dir 指令を定義する。
◎
[MIX] defines block-all-mixed-content
</li>
	<li>
`UPGRADE-INSECURE-REQUESTS$r は、
`upgrade-insecure-requests^dir 指令を定義する。
◎
[UPGRADE-INSECURE-REQUESTS] defines upgrade-insecure-requests
</li>
	<li>
`SRI$r は、
`require-sri-for^dir 指令を定義する【参照先不明】。
◎
[SRI] defines require-sri-for
</li>
</ul>

<p>
~CSPに対する拡張は、 `RFC7762$r に従って登録され~MUST。
特に、その文書の 4.2 節に論じられている判定基準に注意。
◎
Extensions to CSP MUST register themselves via the process outlined in [RFC7762]. In particular, note the criteria discussed in Section 4.2 of that document.
</p>

<p>
新たな指令は、各種~hook
—
`要請前~検査$A,
`要請後~検査$A,
`応答~検査$A,
`初期化$A —
を利用して，自身を Fetch／HTML に統合する~SHOULDである。
◎
New directives SHOULD use the pre-request check, post-request check, response check, and initialization hooks in order to integrate themselves into Fetch and HTML.
</p>


		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">7. 保安上の考慮点</h2>



		<section id="security-nonces">
<h3 title="Nonce Reuse">7.1. ~nonceの再利用-</h3>

<p>
~nonceは、それが送達された指令~内に在する他の制約を，上書きする。
ゆえに、推測不能であり続けることが不可欠になる
— さもなければ、資源の施策を迂回することは，自明になるので。
◎
Nonces override the other restrictions present in the directive in which they’re delivered. It is critical, then, that they remain unguessable, as bypassing a resource’s policy is otherwise trivial.
</p>

<p>
`施策$の一部として
`nonce-source$p 式を送達する~serverは、施策の各~伝送-ごとに一意な値を生成し~MUST。
生成される値は、攻撃者による予測-が困難になる~SHOULDであり，［
（符号化する前の時点で） 128 ~bit以上
］, かつ［
暗号的に保安的な乱数生成器を介して生成される
］~SHOULDである。
◎
If a server delivers a nonce-source expression as part of a policy, the server MUST generate a unique value each time it transmits a policy. The generated value SHOULD be at least 128 bits long (before encoding), and SHOULD be generated via a cryptographically secure random number generator in order to ensure that the value is difficult for an attacker to predict.
</p>

<p class="note">注記：
<span class="trans-note">【
`script-src$dir／`style-src$dir
指令において
】</span>
~nonceを利用して~inlineの［
~script／~style
］を~whitelist化するのは、~nonceを利用しないでそうするときより保安的でない
— ~nonceは、それが在する指令~内の制約を上書きするので。
~nonceへの~accessを得られる攻撃者は、~~任意の~scriptを~~任意に実行できる。
とは言え、古い~code上に~CSP層を重ねるとき，~nonceの利用は `unsafe-inline$pl を大きく改善する。
作者には、 `unsafe-inline$pl を検討するときは，代わりに~nonce（または~hash）を検討することが奨励される。
◎
Note: Using a nonce to whitelist inline script or style is less secure than not using a nonce, as nonces override the restrictions in the directive in which they are present. An attacker who can gain access to the nonce can execute whatever script they like, whenever they like. That said, nonces provide a substantial improvement over 'unsafe-inline' when layering a content security policy on top of old code. When considering 'unsafe-inline', authors are encouraged to consider nonces (or hashes) instead.
</p>

		</section>
	</section>
	<section id="authoring-considerations">
<h2 title="Authoring Considerations">8. 著作上の考慮点</h2>

		<section id="multiple-policies">
<h3 title="The effect of multiple policies">8.1. 複数の施策による効果</h3>

~INFORMATIVE

<p>
上の節【どの節？】では、施策が複数~在するときは、それぞれが，その型に則って［
施行-／報告-
］され~MUSTと記されている。
実施において，これがどう働くものとされるべきか、明確化する例を示す。
何らかの理由で、ある~siteから【の資源に伴って】次の HTTP ~headerが送達されてきたとする：
◎
The above sections note that when multiple policies are present, each must be enforced or reported, according to its type. An example will help clarify how that ought to work in practice. The behavior of an XMLHttpRequest might seem unclear given a site that, for whatever reason, delivered the following HTTP headers:
</p>

<div class="example">

<pre class="http-code">
Content-Security-Policy:
    `default-src$dir `self$pl http://example.com http://example.net;
    `connect-src$dir `none$pl;

Content-Security-Policy:
    `connect-src$dir http://example.com/;
    `script-src$dir http://example.com/
</pre>
</div>

<p>
このとき、【この資源における】
`XMLHttpRequest$I
<!-- 
の挙動は，はっきりしないように見えるかもしれない
 -->
による
`example.com^s
への接続は許容されるか？
— 答えは、許容されない，である。
両~施策の施行は、［
起こりうる接続が，両者ともに無傷で合格しなければならない
］ことを意味する。
二番目の施策がこの接続を許容するとしても，最初の施策が
<samp>`connect-src$dir `none$pl</samp>
を包含するので、その施行により接続は阻止される。
施行する施策の~listに，施策を追加することによる影響0は、被保護~資源の能力に制約を追加しこそすれ，それを~~緩めることはない。
◎
Is a connection to example.com allowed or not? The short answer is that the connection is not allowed. Enforcing both policies means that a potential connection would have to pass through both unscathed. Even though the second policy would allow this connection, the first policy contains connect-src 'none', so its enforcement blocks the connection. The impact is that adding additional policies to the list of policies to enforce can only further restrict the capabilities of the protected resource.
</p>

<p>
更に~~説明するため、この~page上の~script~tagを考える。
最初の施策は，~scriptを `default-src$dir 指令による
{ `self$pl, `http://example.com^s, `http://example.net^s }
の枠内に絞る一方、二番目の施策は，
`http://example.com/^s
からの~scriptのみを許容する。
~scriptが読込まれるのは，両~施策の判定基準を満たす場合に限られるので、合致し得る生成元は
`http://example.com^s
のみになる。
◎
To demonstrate that further, consider a script tag on this page. The first policy would lock scripts down to 'self', http://example.com and http://example.net via the default-src directive. The second, however, would only allow script from http://example.com/. Script will only load if it meets both policy’s criteria: in this case, the only origin that can match is http://example.com, as both policies allow it.
</p>

		</section>
		<section id="strict-dynamic-usage">
<h3 title="Usage of &quot;'strict-dynamic'&quot;">8.2. `strict-dynamic^pl の用法</h3>

<p>
~whitelistを~~正しく保つことは、とりわけ CDN の様な まとまりのない生成元では，大変になる。
<a href="https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it%27s-CSP!%22#107-bytes">solutions to Cure53’s H5SC Minichallenge 3: "Sh*t, it’s CSP!"</a>
`H5SC3$r
は，~whitelistが可能化し得る迂回の好例であり、~CSPが，大規模な~whitelistを介して これらの迂回を軽減する能力を有するとしても、壊れ易く, 扱い難く, 実装する／保守するのが困難になりがちである。
◎
Whitelists are tough to get right, especially on sprawling origins like CDNs. The solutions to Cure53’s H5SC Minichallenge 3: "Sh*t, it’s CSP!" [H5SC3] are good examples of the kinds of bypasses which whitelists can enable, and though CSP is capable of mitigating these bypasses via extensive whitelists, those end up being brittle, awkward, and difficult to implement and maintain.
</p>

<p>
`strict-dynamic$pl ~source式は、既存の~appが，自身が直接的に読込む~scriptについては自信があるが，適度に保安的な~whitelistを提供する能については自信がない場合に、~CSPをより単純に配備できるようにすることを目指している。
◎
The "'strict-dynamic'" source expression aims to make Content Security Policy simpler to deploy for existing applications who have a high degree of confidence in the scripts they load directly, but low confidence in their ability to provide a reasonably secure whitelist.
</p>

<p>
`script-src$dir ／ `default-src$dir
指令~内に在する場合、 2 つの主な効果がある：
◎
If present in a script-src or default-src directive, it has two main effects:
</p>

<ul>
	<li>
<p>(A)：
式［
`host-source$p, `scheme-source$p
］, および `keyword-source$p［
`unsafe-inline$pl, `self$pl
］は、~scriptの読込み時には無視される。
◎
host-source and scheme-source expressions, as well as the "'unsafe-inline'" and "'self' keyword-sources will be ignored when loading script.
</p>

<p>
式［
`hash-source$p, `nonce-source$p
］は、尊守されることになる。
◎
hash-source and nonce-source expressions will be honored.
</p>
	</li>

	<li>(B)：
`構文解析-時に挿入され$たものではない `script$e 要素により誘発される~script要請は、許容される。
◎
Script requests which are triggered by non-parser-inserted script elements are allowed.
</li>

</ul>

<div class="p">
<p>
(A) は、後方互換な仕方で，~UAによる~~推定（ sniffing ）を要することなく
`strict-dynamic$pl を配備できるようにする。
例えば施策
<samp>`unsafe-inline$pl https: 'nonce-abcdefg' `strict-dynamic$pl</samp>
は、~browserが~supportする~CSPの~versionに応じて，次であるかの様に動作することになる：
</p>

<ul ><li>CSP1 ならば
<samp>`unsafe-inline^pl https:</samp>
</li><li>CSP2 ならば
<samp>https: 'nonce-abcdefg'</samp>
</li><li>CSP3 ならば
<samp>'nonce-abcdefg' `strict-dynamic^pl</samp>
</li></ul>

◎
The first change allows you to deploy "'strict-dynamic' in a backwards compatible way, without requiring user-agent sniffing: the policy 'unsafe-inline' https: 'nonce-abcdefg' 'strict-dynamic' will act like 'unsafe-inline' https: in browsers that support CSP1, https: 'nonce-abcdefg' in browsers that support CSP2, and 'nonce-abcdefg' 'strict-dynamic' in browsers that support CSP3.
</div>

<p>
(B) は、［
~nonce／~hash
］を介して~pageへの~accessが与えられた~scriptが、~pageの施策に明示的に追加することなく，他との依存関係を持ち込めるようにする。
◎
The second allows scripts which are given access to the page via nonces or hashes to bring in their dependencies without adding them explicitly to the page’s policy.
</p>

<div class="example">
<p>
MegaCorp 社は、次の施策を配備していて：
◎
Suppose MegaCorp, Inc. deploys the following policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `script-src$dir 'nonce-abcdefg' `strict-dynamic$pl
</pre>

<p>
作動中の施策を伴う，次の HTML を~serveしているとする：
◎
And serves the following HTML with that policy active:
</p>

<pre>
...
&lt;script
    src="https://cdn.example.com/script.js"
    nonce="abcdefg"
&gt;&lt;/script&gt;
...
</pre>

<p>
これは
`https://cdn.example.com/script.js^s
に対する要請を生成することになり、それは
`nonce$a 属性に合致するので阻止されないことになる。
◎
This will generate a request for https://cdn.example.com/script.js, which will not be blocked because of the matching nonce attribute.
</p>

<p>
`script.js^s が次の~codeを包含するならば：
◎
If script.js contains the following code:
</p>

<pre>
var %s = document.createElement('script');
%s.src = 'https://othercdn.not-example.net/dependency.js';
document.head.appendChild('s');

document.write('&lt;scr' + 'ipt src='/sadness.js'&gt;&lt;/scr' + 'ipt&gt;');
</pre>

<p>
`dependency.js^s
は読込まれることになる
— `createElement()^c により作成される `script$e 要素は、`構文解析-時に挿入され$るものではないので。
◎
dependency.js will load, as the script element created by createElement() is not parser-inserted.
</p>

<p>
一方で、 `sadness.js^c は<em>読込まれない</em>
— `document.write()^c は，`構文解析-時に挿入され$る `script$e 要素を生産するので。
◎
sadness.js will not load, however, as document.write() produces script elements which are parser-inserted.
</p>

</div>

		</section>
		<section id="unsafe-hashed-attributes-usage">
<h3 title="Usage of &quot;'unsafe-hashed-attributes'&quot;">8.3. `unsafe-hashed-attributes^pl の用法</h3>

~INFORMATIVE

<p>
［
旧来の~website ／ 旧来の依存関係を伴う~website
］では、~event~handlerをまるごと外部化するのが困難なこともある。
これらの~siteは、その種の~handlerを `unsafe-inline^pl で~whitelist化して可能化することもできるが、それは，多数の~riskを抱える諸刃の剣である（また、~nonceや~hashと共には利用できない）。
◎
Legacy websites and websites with legacy dependencies might find it difficult to entirely externalize event handlers. These sites could enable such handlers by whitelisting 'unsafe-inline', but that’s a big hammer with a lot of associated risk (and cannot be used in conjunction with nonces or hashes).
</p>

<p>
~source式 `unsafe-hashed-attributes$pl は、そのような状況~下で，［
~hashを介して特定の~handlerを~whitelist化できる
］ようにすることで、開発者が，~CSPをより単純かつ安全に配備できるようにすることを目指している。
◎
The "'unsafe-hashed-attributes'" source expression aims to make CSP deployment simpler and safer in these situations by allowing developers to whitelist specific handlers via hashes.
</p>

<div class="example">
<p>
MegaCorp 社は、次の HTML を適度な~scheduleで取り去れないので：
◎
MegaCorp, Inc. can’t quite get rid of the following HTML on anything resembling a reasonable schedule:
</p>


<pre>
&lt;button id="action" onclick="doSubmit()"&gt;
</pre>

<p>
`unsafe-inline^pl で~whitelist化するのでなく，［
~hash~source式と `unsafe-hashed-attributes^pl
］を利用することに決めた：
◎
Rather than whitelisting "'unsafe-inline'", they decide to use "'unsafe-hashed-attributes'" along with a hash source expression, as follows:
</p>

<pre>
`Content-Security-Policy$h:
    `unsafe-hashed-attributes$pl 'sha256-jzgBGA4UWFFmpOBq0JpdsySukE1FrEN5bUpoK8Z29fY='
</pre>

</div>


		</section>
		<section id="external-hash">
<h3 title="Whitelisting external JavaScript with hashes ">8.4. 外部~JSに対する~hashによる~whitelist化</h3>

~INFORMATIVE

<p>
`CSP2$r では、~hash`~source式$は，~inlineの~scriptに限って~whitelist化できていたが、今や Subresource Integrity `SRI$r が広範に配備されたので，外部化された~JSも可能化するように視野を拡げられる。
◎
In [CSP2], hash source expressions could only whitelist inlined script, but now that Subresource Integrity is widely deployed, we can expand the scope to enable externalized JavaScript as well.
</p>

<p>
ある `script$e に対し，複数の完全性~metadataからなる集合が指定された場合、［
要請が施策の `hash-source$p たちに合致する
］ための必要十分条件は，［
`script$e の完全性~metadata内の <em>各</em> ~itemが当の施策に合致する
］ときになる。
◎
If multiple sets of integrity metadata are specified for a script, the request will match a policy’s hash-sources if and only if each item in a script's integrity metadata matches the policy.
</p>

<div class="example">
<p >
MegaCorp 社は，内容が期待に合致することを確保するため、~page上の 2 個の特定の~scriptを~whitelist化したいとする
— 次の施策を設定したとするとき：
◎
MegaCorp, Inc. wishes to whitelist two specific scripts on a page in a way that ensures that the content matches their expectations. They do so by setting the following policy:
</p>


<pre>
`Content-Security-Policy$h:
    script-src 'sha256-abc123' 'sha512-321cba'
</pre>

<p>
この施策が在する下では、次の各 `script$e 要素は，~whitelist化されることになる
— いずれも，施策に合致する完全性~metadataのみを包含するので：
◎
In the presence of that policy, the following script elements would be whitelisted because they contain only integrity metadata that matches the policy:
</p>

<pre>
&lt;script integrity="sha256-abc123" ...&gt;&lt;/script&gt;
&lt;script integrity="sha512-321cba" ...&gt;&lt;/script&gt;
&lt;script integrity="sha256-abc123 sha512-321cba" ...&gt;&lt;/script&gt;
</pre>

<p>
一方で，次の各 `script$e 要素は，施策に合致しない~metadataを包含するので、いずれも（他の~metadataは合致していても）~whitelist化されない：
◎
While the following script elements would not be whitelisted because they contain metadata that does not match the policy (even though other metadata does match):
</p>

<pre>
&lt;script integrity="<mark>sha384-xyz789</mark>" ...&gt;&lt;/script&gt;
&lt;script integrity="<mark>sha384-xyz789</mark> sha512-321cba" ...&gt;&lt;/script&gt;
&lt;script integrity="sha256-abc123 <mark>sha384-xyz789</mark> sha512-321cba" ...&gt;&lt;/script&gt;
</pre>

</div>

		</section>
	</section>
	<section id="implementation-considerations">
<h2 title="Implementation Considerations">9. 実装にあたっての考慮点</h2>



		<section id="extensions">
<h3 title="Vendor-specific Extensions and Addons">9.1. ~vendor特有の拡張／~addon</h3>

<p>
資源~上に施行される`施策$は、［
~addon, 拡張, ~bookmarklet
］などの，~UA特色機能の運用には、干渉する~SHOULDでない。
`HTML-DESIGN$r にて信奉されているように、この種の特色機能は，一般に~page作者より利用者に優先権を与えるものなので。
◎
Policy enforced on a resource SHOULD NOT interfere with the operation of user-agent features like addons, extensions, or bookmarklets. These kinds of features generally advance the user’s priority over page authors, as espoused in [HTML-DESIGN].
</p>

<p>
更には、この種の特色機能に~CSPを適用すると，その違反~報告において相当量の~noise~~源になり、結果として，~web開発者にとっての価値は損われることになる。
◎
Moreover, applying CSP to these kinds of features produces a substantial amount of noise in violation reports, significantly reducing their value to developers.
</p>

<p>
例えば Chromeでは， `chrome-extension^sc ~schemeを~CSP検査から除外しており、~pageの施策に関わらず，拡張により駆動される注入は許容するような 何らかの仕事を行っている。
◎
Chrome, for example, excludes the chrome-extension: scheme from CSP checks, and does some work to ensure that extension-driven injections are allowed, regardless of a page’s policy.
</p>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">10. IANA 考慮点</h2>

		<section id="iana-registry">
<h3 title="Directive Registry">10.1. 指令の登記簿</h3>

<p>
Content Security Policy Directive
（~CSP 指令）登記簿は、次の登録と参照により更新されるべきである
`RFC7762$r
【参照先は指令のリンク先と同じなので省略する】
：
◎
The Content Security Policy Directive registry should be updated with the following directives and references [RFC7762]:
</p>

<div >
<ul ><li>`base-uri$dir
</li><li>`child-src$dir
</li><li>`connect-src$dir
</li><li>`default-src$dir
</li><li>`font-src$dir
</li><li>`form-action$dir
</li><li>`frame-ancestors$dir
</li><li>`frame-src$dir
</li><li>`img-src$dir
</li><li>`manifest-src$dir
</li><li>`media-src$dir
</li><li>`object-src$dir
</li><li>`plugin-types$dir
</li><li>`report-uri$dir
</li><li>`report-to$dir
</li><li>`sandbox$dir
</li><li>`script-src$dir
</li><li>`style-src$dir
</li><li>`worker-src$dir
</li></ul>

◎
base-uri
• This document (see §6.2.1 base-uri)
child-src
• This document (see §6.1.1 child-src)
connect-src
• This document (see §6.1.2 connect-src)
default-src
• This document (see §6.1.3 default-src)
font-src
• This document (see §6.1.4 font-src)
form-action
• This document (see §6.3.1 form-action)
frame-ancestors
• This document (see §6.3.2 frame-ancestors)
frame-src
• This document (see §6.1.5 frame-src)
img-src
• This document (see §6.1.6 img-src)
manifest-src
• This document (see §6.1.7 manifest-src)
media-src
• This document (see §6.1.8 media-src)
object-src
• This document (see §6.1.9 object-src)
plugin-types
• This document (see §6.2.2 plugin-types)
report-uri
• This document (see §6.4.1 report-uri)
report-to
• This document (see §6.4.2 report-to)
sandbox
• This document (see §6.2.3 sandbox)
script-src
• This document (see §6.1.10 script-src)
style-src
• This document (see §6.1.11 style-src)
worker-src
• This document (see §6.1.12 worker-src)
</div>



		</section>
		<section>
<h3 id="iana-headers">10.2. ~header登録</h3>

<p>
恒久的~message~header登記簿は、次の登録により更新されるべきである：
`RFC3864$r
◎
The permanent message header field registry should be updated with the following registrations: [RFC3864]
</p>


<div>
<table><tbody><tr><th>~header名
</th><td>
<span id="iana-csp">`Content-Security-Policy$h</span>,<br>
<span id="iana-cspro">`Content-Security-Policy-Report-Only$h</span>
</td></tr><tr><th>適用し得る~protocol
</th><td>http

</td></tr><tr><th>位置付け
</th><td>standard

</td></tr><tr><th>~~作成／~~変更 ~~管理者
</th><td>W3C

</td></tr><tr><th>仕様~文書
</th><td>この仕様

</td></tr></tbody></table>

◎
Content-Security-Policy
◎
Header field name
• Content-Security-Policy 
Applicable protocol
• http 
Status
• standard 
Author/Change controller
• W3C 
Specification document
• This specification (See §3.1 The Content-Security-Policy HTTP Response Header Field) 

◎
Content-Security-Policy-Report-Only
◎
Header field name
• Content-Security-Policy-Report-Only 
Applicable protocol
• http 
Status
• standard 
Author/Change controller
• W3C 
Specification document
• This specification (See §3.2 The Content-Security-Policy-Report-Only HTTP Response Header Field)
</div>



		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">11. 謝辞</h2>

<p>
~~協力された多数の方々に。
具体的には：
◎
Lots of people are awesome. For instance:
</p>

<ul>
	<li>
Mario and all of Cure53.
</li>
	<li>
Artur Janc, Michele Spagnuolo, Lukas Weichselbaum, Jochen Eisinger, and the
rest of Google’s CSP Cabal.
</li>
</ul>

	</section>

	<section id="conformance">
<h2 title="Conformance">適合性</h2>
<h3 id="conformant-algorithms" title="Conformant Algorithms">適合的~algo</h3>
<h3 id="conventions" title="Document conventions">文書における表記規約</h3>


<p class="trans-note">【
これらの節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>
	</section>

</main></div><!-- MAIN/MAIN0 -->

	<section id="index">
<h2 title="Index">索引</h2>

		<section id="index-defined-here">
<h3 title="Terms defined by this specification">この仕様により定義される用語</h3>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>

		</section>
		<section id="index-defined-elsewhere">
<h3 title="Terms defined by reference">他の仕様で定義される用語</h3>
<p class="trans-note">【
この節の内容は省略。
】</p>

		</section>
	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>





<dl>

	<dt>[CSS-CASCADE-4]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-cascade/</dd>

	<dt>[CSSOM]</dt>
	<dd>Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD.</dd>
	<dd>https://drafts.csswg.org/cssom/</dd>

	<dt>[ECMA262]</dt>
	<dd>Brian Terlson; Allen Wirfs-Brock. ECMAScript® Language Specification.</dd>
	<dd>https://tc39.github.io/ecma262/</dd>

	<dt>[FETCH]</dt>
	<dd>Anne van Kesteren. Fetch Standard. Living Standard.</dd>
	<dd>https://fetch.spec.whatwg.org/</dd>

	<dt>[HTML]</dt>
	<dd>Ian Hickson. HTML Standard. Living Standard.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

	<dt>[HTML5]</dt>
	<dd>Ian Hickson; et al. HTML5. 28 October 2014. REC.</dd>
	<dd>https://www.w3.org/html/wg/drafts/html/master/</dd>

	<dt>[OOB-REPORTING]</dt>
	<dd>Ilya Gregorik; Mike West. Out-of-band Reporting.</dd>
	<dd>https://mikewest.github.io/error-reporting/</dd>

<!-- 
	<dt>[RFC2119]</dt>
 -->

	<dt>[RFC3492]</dt>
	<dd>A. Costello. Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA). March 2003. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc3492</dd>

	<dt>[RFC3864]</dt>
	<dd>G. Klyne; M. Nottingham; J. Mogul. Registration Procedures for Message Header Fields. September 2004. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc3864</dd>

	<dt>[RFC3986]</dt>
	<dd>T. Berners-Lee; R. Fielding; L. Masinter. Uniform Resource Identifier (URI): Generic Syntax. January 2005. Internet Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc3986</dd>

	<dt>[RFC4648]</dt>
	<dd>S. Josefsson. The Base16, Base32, and Base64 Data Encodings. October 2006. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc4648</dd>

	<dt>[RFC5234]</dt>
	<dd>D. Crocker, Ed.; P. Overell. Augmented BNF for Syntax Specifications: ABNF. January 2008. Internet Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc5234</dd>

	<dt>[RFC5988]</dt>
	<dd>M. Nottingham. Web Linking. October 2010. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc5988</dd>

	<dt>[RFC6454]</dt>
	<dd>A. Barth. The Web Origin Concept. December 2011. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc6454</dd>

	<dt>[RFC7230]</dt>
	<dd>R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc7230</dd>

	<dt>[RFC7231]</dt>
	<dd>R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc7231</dd>

	<dt>[RFC7762]</dt>
	<dd>M. West. Initial Assignment for the Content Security Policy Directives Registry. January 2016. Informational.</dd>
	<dd>https://tools.ietf.org/html/rfc7762</dd>

	<dt>[SERVICE-WORKERS]</dt>
	<dd>Alex Russell; Jungkee Song; Jake Archibald. Service Workers. 25 June 2015. WD.</dd>
	<dd>https://slightlyoff.github.io/ServiceWorker/spec/service_worker/</dd>

	<dt>[SHA2]</dt>
	<dd>FIPS PUB 180-4, Secure Hash Standard.</dd>
	<dd>http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf</dd>

	<dt>[SRI]</dt>
	<dd>Devdatta Akhawe; et al. Subresource Integrity. 10 May 2016. PR.</dd>
	<dd>https://w3c.github.io/webappsec-subresource-integrity/</dd>

	<dt>[WHATWG-DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>

	<dt>[WHATWG-URL]</dt>
	<dd>Anne van Kesteren; Sam Ruby. URL Standard. Living Standard.</dd>
	<dd>https://url.spec.whatwg.org/</dd>

	<dt>[WORKERS]</dt>
	<dd>Ian Hickson. Web Workers. 24 September 2015. WD.</dd>
	<dd>https://html.spec.whatwg.org/multipage/workers.html</dd>
</dl>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>


<dl>

	<dt>[APPMANIFEST]</dt>
	<dd>Marcos Caceres; et al. Web App Manifest. 9 June 2016. WD.</dd>
	<dd>https://w3c.github.io/manifest/</dd>

	<dt>[BEACON]</dt>
	<dd>Ilya Grigorik; et al. Beacon. 25 February 2016. WD.</dd>
	<dd>https://w3c.github.io/beacon/</dd>

	<dt>[CSP2]</dt>
	<dd>Mike West; Adam Barth; Daniel Veditz. Content Security Policy Level 2. 21 July 2015. CR.</dd>
	<dd>https://w3c.github.io/webappsec/specs/CSP2/</dd>

	<dt>[EVENTSOURCE]</dt>
	<dd>Ian Hickson. Server-Sent Events. 3 February 2015. REC.</dd>
	<dd>http://dev.w3.org/html5/eventsource/</dd>

	<dt>[H5SC3]</dt>
	<dd>Mario Heiderich. H5SC Minichallenge 3: "Sh*t, it's CSP!".</dd>
	<dd>https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it%27s-CSP!%22</dd>

	<dt>[HTML-DESIGN]</dt>
	<dd>Anne Van Kesteren; Maciej Stachowiak. HTML Design Principles.</dd>
	<dd>https://www.w3.org/TR/html-design-principles/</dd>

	<dt>[MIX]</dt>
	<dd>Mike West. Mixed Content. 8 October 2015. CR.</dd>
	<dd>https://w3c.github.io/webappsec/specs/mixedcontent/</dd>

	<dt>[TIMING]</dt>
	<dd>Paul Stone. Pixel Perfect Timing Attacks with HTML5.</dd>
	<dd>http://www.contextis.com/documents/2/Browser_Timing_Attacks.pdf</dd>

	<dt>[UISECURITY]</dt>
	<dd>Brad Hill. User Interface Security and the Visibility API. 7 June 2016. WD.</dd>
	<dd>https://w3c.github.io/webappsec-uisecurity/index.html</dd>

	<dt>[UPGRADE-INSECURE-REQUESTS]</dt>
	<dd>Mike West. Upgrade Insecure Requests. 8 October 2015. CR.</dd>
	<dd>https://w3c.github.io/webappsec-upgrade-insecure-requests/</dd>

	<dt>[WEBSOCKETS]</dt>
	<dd>Ian Hickson. The WebSocket API. 20 September 2012. CR.</dd>
	<dd>https://www.w3.org/TR/websockets/</dd>

	<dt>[XHR]</dt>
	<dd>Anne van Kesteren. XMLHttpRequest Standard. Living Standard.</dd>
	<dd>https://xhr.spec.whatwg.org/</dd>

	<dt>[XSLT]</dt>
	<dd>James Clark. XSL Transformations (XSLT) Version 1.0. 16 November 1999. REC.</dd>
	<dd>https://www.w3.org/TR/xslt</dd>
</dl>



	</section>
	<section id="idl-index">
<h2 title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>
	<section id="issues-index">
<h2 title="Issues Index">課題 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>

	</section>
</section>

</body></html>
