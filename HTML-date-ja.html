<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Dates and times （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/infrastructure.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160718 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		tnote: 'trans-note'
	};

	var tag_map = {
		e: 'code',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|❝.|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '❝':
		return ( '<span class="code-point">U+00'
			+ match[1].charCodeAt(0).toString(16).toUpperCase()
			+ '</span> ( "<code class="literal">' + match[1] + '</code>" )'
		);
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<!--% -->
<script type="text/plain" id="_original_id_map">
</script>

<!--% リンク置換データ -->

<script type="text/plain" id="_link_map">

e.time:~HEtextlevel#the-time-element

	●date＆time
偏差:#concept-timezone
時間帯:#time-zones
偏差~成分を構文解析-:#parse-a-time-zone-offset-component
偏差~文字列として構文解析-:#parse-a-time-zone-offset-string
日時:#concept-datetime
大域的~日時:#concept-datetime
大域的~日時~文字列として構文解析-:#parse-a-global-date-and-time-string
妥当な偏差~文字列:#valid-time-zone-offset-string
妥当な大域的~日時~文字列:#valid-global-date-and-time-string
妥当な局所的~日時~文字列:#valid-local-date-and-time-string
妥当な月日t文字列:#valid-yearless-date-string
妥当な日付~文字列:#valid-date-string
妥当な省略あり日時~文字列:#valid-date-string-with-optional-time
妥当な時刻~文字列:#valid-time-string
妥当な時間長~文字列:#valid-duration-string
妥当な年月t文字列:#valid-month-string
妥当な正規化済みの局所的~日時~文字列:#valid-normalised-local-date-and-time-string
妥当な年週t文字列:#valid-week-string
局所的~日時:#concept-datetime-local
局所的~日時~文字列として構文解析-:#parse-a-local-date-and-time-string
月日t:#concept-yearless-date
月日t成分を構文解析-:#parse-a-yearless-date-component
月日t文字列として構文解析-:#parse-a-yearless-date-string
日付:#concept-date
省略あり日時~文字列として構文解析-:#parse-a-date-or-time-string
日付~成分を構文解析-:#parse-a-date-component
日付~文字列として構文解析-:#parse-a-date-string
時刻:#concept-time
時刻~成分を構文解析-:#parse-a-time-component
時刻~文字列として構文解析-:#parse-a-time-string
時間長~成分:#duration-time-component
時間長~成分の縮尺:#duration-time-component-scale
時間長:#concept-duration
時間長~文字列として構文解析-:#parse-a-duration-string
週t数:#week-number-of-the-last-day
最後の日tの週t番号:#week-number-of-the-last-day
年月t:#concept-month
月tの日t数:#number-of-days-in-month-month-of-year-year
年月t成分を構文解析-:#parse-a-month-component
年月t文字列として構文解析-:#parse-a-month-string
年週t:#concept-week
年週t文字列として構文解析-:#parse-a-week-string
遡及~Gregorian日付:#proleptic-gregorian-date
遡及~Gregorian暦:#proleptic-gregorian-calendar


Base10:~HTMLINFRA#_base-ten-integer
	String10:~HTMLINFRA#_base-ten-string
Power10:~HTMLINFRA#_base-ten-power

~ASCII数字:~HTMLINFRA#ascii-digits
文字~並びを収集-:~HTMLINFRA#collect-a-sequence-of-characters
空白を読飛ばす:~HTMLINFRA#skip-whitespace
空白類:~HTMLINFRA#space-character
厳密に分割-:~HTMLINFRA#strictly-split-a-string

</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
FORMSintro:HTML-forms-intro-ja.html
</script>
<!-- 
SPACE:U+0020 ( SPACE )
 -->


<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">

	●仕様
algo:algorithm:::アルゴリズム
version::::バージョン
互換性:compatibility:~
仕様:spec:~
作者:author:~
	例:example:~
依存-:depend:~
	依然として:still:~
保証:guarantee:~
公式的な:formal:~
処理-:process:~
協調-:coordinate:~
可能0:possible:可能
奨励-:encourage:~
孕む:involve:~
定義-:define:~
定義:definition:~
実施:practice:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
実際:actual:~
実際の:actual:~
対応-:correspond:~
将来:future:~
導入-:introduce:~
恣意的:arbitrary:~
情報:information:~
意味-:mean:~
意味:meaning:~
意図-:intend:~
政治的:policy:~
政治的駆け引き:political-football:~
文化的:cultural:~
方式:manner:~
明示的:explicit:~
最善:best:~
歴史的:historical:~
永劫:forever:~
決断:decision:~
注意深く:careful に:~
注目:notable:~
特定0の:particular:ある特定の
特定の:specific:~
現代の:modern:~
許容-:allow:~
詳細:details:~
詳細に:detail:~
誤解釈:misinterpreting:~
読み易い~readable::~
論じる:discuss する:~
論点:discussion:~
適切:appropriate:~
用法:usage:~
用語:term:~
	異なる:different:~
目的0:purpose:目的
	節:section:~
精確:precise:~
結付けら:associate さ:結び付けら
解釈-:interpret:~
記述-:describe:~
述べる:describe する:~
所与の:given:与えられた
指定-:specify:~

検分-:examine:~

	●暦
Gregorian::::グレゴリオ
Julian::::ユリウス
London::::ロンドン
ISO8601:ISO 8601
Roman-Emperor:Roman Emperor::ローマ皇帝
Nero::::ネロ
UT1::::
UTC::::
	February
	October
	SI
	USA
遡及:proleptic::~
	proleptic-Gregorian:~
閏:leap::~

年t:year::年
月t:month::月
年月t:year＆month::年＆月
月日t:month＆date::月＆日
日t:day::日
週t:week::週
年週t:year＆week::年＆週
時t:hour::時
分t:minute::分
秒t:second::秒
週年t:week-year::週年
年なし:yearless::~
日付:date::~
日時:date＆time::~

時刻:time::~
	時刻:moments in time
時間帯:time zone::~
	時間帯:offset:~
偏差:time-zone offset::~

milli::::ミリ
	~milli秒t:millisecond
夏時間:daylight saving time::~
太陽時:Earth solar time::~
時間長:duration::~
	時間長~成分:duration time component:
暦:calendar::~
暦付け:calendaring::~
最大日数:maxday::~
最大週数:maxweek::~

番号:number:~

水曜:Wednesday::~
火曜:Thursday::~
月曜:Monday::~
七日間:seven-day period:~

地域:area:~
地域化-:localize::~
大域的:global::~::グローバル
局所的:local::~::ローカル

単位:unit:~
生誕:birth:~
誕生日:birthday:~
真昼:noon:~
期間:period:~
東海岸:east-coast:~
真夜中:midnight:~
経度:longitude:~
縮尺:scale:~
外部補間-:extrapolate:~
前近代:ancient times:~
比較的近代:relatively recent decades:~
世紀:century:~
中頃:mid:~
制定:formation:~

	●構文
SPACE:
ASCII:
pointer::::ポインタ
有符号:signed:~
符号:sign:~
	順々に:consecutive〜sequentially

構文:syntax::~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ

直列化-:serialize::~::シリアライズ

正規化済みの:normalized:~
比較可能:comparable:~
	数:number:~
数字:digit:~
数的:numeric:~
整数:integer:~
文字:character:~
文字列:string:~
空白類:space characters:~
空白:whitespace:~
読飛ばす:skip する:読み飛ばす
収集-:collect:~

位置:position:~

小数:fractional:~
小数部:fraction:~

空:empty:~
形式:format:~
成分:component:~
下位成分:subcomponent:~
小構文:microsyntax:~
	ε:fail
一義化子:-disambiguator:~
一義化-:disambiguate:~

	●未分類
HTML::::
form::::フォーム
control::::コントロール
flag::::フラグ
library::::ライブラリ
system::::システム
zero::::ゼロ
	literal
一義的:unambiguous:~
	substep:~
下位集合:subset:~
乗数:multiplier:~
人:human:~
代替:alternative:~
伝送路:wire:~
位置-:position:~
値:value:~
入力:input:~
	利用-:use:~
刻む:tick する:~
包含-:contain:~
受渡し:round-tripping:受け渡し
増分:increment:~
変換-:convert:~

妥当な:valid:~
当地域:place:~
成功裡:successful:~
所在:location:~
文脈:context:~
正確:exact:~
減算-:subtract:~
	subtracting
測定-:measure:~
相違-:differ:~
相違:difference:~
省略-:omit:~
省略可:optional:~
等価:equivalent:~
範囲:range:~
置換-:replace:~
表現-:represent:~
表示-:display:~
要素:element:~
規則:rule:~
観測-:observe:~
解析済み:parsed:~
設定-:set:~
識別-:identify:~
近似-:approximate:~
近似:approximation:~
長さ:length:~
開始-:start:~
関係-:relate:~
順序:order:~
偏向:bias:~

	-:arbitrary:~
	常に:always:~
	後:after:~
	得-:obtain:~
	現在:currently:~
	見よ:see:~
	今や:now:~
	以前の:previous／predate
	下:below:~
	他の:other:~
	他の場合:otherwise:~
	前:before:~
	〜の倍数:divisible:~
	間:between:~
	各:each:~
	同じ:same:~
	含-:include:~
	:four
	在-:present:~
	場合によっては:possibly:~
	更なる:further:~
	最初の:first:~
	最後の:last:~
	最短の:shortest:~
	順々:sequential:~
	表す:express:~
	等し:equal:~
	結果:result:~
	走-:run:~
	返す:return:~
	避け:avoid:~
	当時の:contemporary:~

	進んでいる:ahead of
	遡って:backward
	その逆も同様:vice versa
	2 個の:two
	1 月:January
	12 月:December
	INCBY:advance position
	:care
	:count
	まるごと:entirely
	:followed-by
	:forcibly
	~moment:moment
	~zero詰めされ:zero-padded
	:part
	:past
	:refer
	対象:subject
	:sum
	timezone
	timezonehour
	timezoneminute
	〜に基づく:based
	〜の代わりに:instead
	あり続ける:remain
	いくつかの:several
	この:this
	これらの:these
	しかしながら，:however
	したがって:therefore
	したがって:thus
	すべての:all
	する限りにおいて:insofar
	その:that
	そのような:such
	それらを:them
	もの:thing


	織り込んだ:takes into account
	ずっと:much more
	きちんと:well
	掛けた:scaleした
	漠然とした:vaguer moments
	時刻:moments in time
	気まぐれな:very whimsical
	出来事:event
	~~実用されている:real

</script>


<!--%style -->
<style type="text/css">
*[lang="en"] {
	white-space: pre-line;
}

</style>

</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Standard —  Dates and times 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Common infrastructure</a>
章の Dates and times 節を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-01-20</time>
（公開：<time>2016-07-19</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header id="head">
	<hgroup>
<h1>日付と時刻 — Dates and times</h1>
<h2>HTML Living Standard — 最終更新 2017 年 1 月 20 日</h2>
	</hgroup>
</header>


<main id="MAIN" hidden>

			<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>

<ul>
	<li>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~WHILE 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</li>
	<li>
各種 構文解析器に利用される変数や記号［
%入力, %位置, %位置↗, ε
］の意味は、
<a href="~HTMLINFRA#_conventions">共通基盤 章の表記規約</a>
を参照されたし。
</li>
	<li>
~SPACE は <span class="code-point">U+0020</span> ( SPACE ) の略記である。
</li>
	<li>
Base10( %s ), Power10( %s )
という表記も利用する（詳細は
<a href="~HTMLINFRA#numbers">共通基盤 章の実数</a>
節に）。
</li>
</ul>

			</section>
			<section id="dates-and-times">
<h3 title="Dates and times">2.3.5. 日時（日付と時刻）</h3>

<div>
<p>
以下の各種~algoにおける，所与の
( %年t, %月t )
に対する
`月tの日t数@
は、次で与えられる：
</p>

<dl class="switch">
	<dt>%月t ~IN { 1, 3, 5, 7, 8, 10, 12 } の場合：</dt>
	<dd>31</dd>

	<dt>%月t ~IN { 4, 6, 9, 11 } の場合：</dt>
	<dd>30</dd>

	<dt>%月t ~EQ 2 の場合：</dt>
	<dd>
<p>
次のいずれかが満たされるならば 29：
</p>

<ul ><li>%年t ~EQ ε
</li><li>%年t は 400 の倍数
</li><li>［
%年t は 4 の倍数
~AND
%年t は 100 の倍数でない
］
</li></ul>
	</dd>
	<dd>
~ELSE_ 28
</dd>
</dl>

<p>
これは~Gregorian暦による閏~年tを織り込んだものである。
`GREGORIAN$r
</p>

◎
In the algorithms below, the number of days in month month of year year is: 31 if month is 1, 3, 5, 7, 8, 10, or 12; 30 if month is 4, 6, 9, or 11; 29 if month is 2 and year is a number divisible by 400, or if year is a number divisible by 4 but not by 100; and 28 otherwise. This takes into account leap years in the Gregorian calendar. [GREGORIAN]
</div>

<p>
この節にて定義される 日時~構文に利用される
`~ASCII数字$列は、基数 10 の数を表す。
◎
When ASCII digits are used in the date and time syntaxes defined in this section, they express numbers in base ten.
</p>


<p class="note">注記：
ここに述べる各種~形式は，~ISO8601形式の下位集合に対応するものとして意図されるが、この仕様は，~ISO8601よりずっと詳細に構文解析~規則を定義する。
したがって実装者には、下に述べる構文解析~規則を実装するときに日付~構文解析~libraryを利用する際には，その前に，注意深く検分することが奨励される
— その種の~ISO8601~libraryは、日時を正確に同じ方式で構文解析していないかもしれないので。
`ISO8601$r
◎
While the formats described here are intended to be subsets of the corresponding ISO8601 formats, this specification defines parsing rules in much more detail than ISO8601. Implementors are therefore encouraged to carefully examine any date parsing libraries before using them to implement the parsing rules described below; ISO8601 libraries might not parse dates and times in exactly the same manner. [ISO8601]
</p>


<p>
この仕様における
`遡及~Gregorian暦@
とは、現代の~Gregorian暦を 0001 年tまで遡って外部補間したものを意味する。
`遡及~Gregorian暦$における日付は、その暦が当時（または当地域）にて利用されていなかったとしても，その暦を利用して記述され、明示的に
`遡及~Gregorian日付@
と称されることもある。
`GREGORIAN$r
◎
Where this specification refers to the proleptic Gregorian calendar, it means the modern Gregorian calendar, extrapolated backwards to year 1. A date in the proleptic Gregorian calendar, sometimes explicitly referred to as a proleptic-Gregorian date, is one that is described using that calendar even if that calendar was not in use at the time (or place) in question. [GREGORIAN]
</p>

<p class="note">注記：
この仕様における伝送路~形式としての~Gregorian暦の利用は、文化的な偏向に孕まれるものによる決断の結果，恣意的に選ばれたものである。
~formにおける（作者向けの）
<a href="~FORMSintro#input-author-notes">日付, 時刻, 数の形式</a>
を論じる節, および
<a href="~HEinput#input-impl-notes">~form~controlを地域化する際の実装上の注記</a>,
`time$e 要素も見よ。
◎
The use of the Gregorian calendar as the wire format in this specification is an arbitrary choice resulting from the cultural biases of those involved in the decision. See also the section discussing date, time, and number formats in forms (for authors), implementation notes regarding localization of form controls, and the time element.
</p>


				<section id="months">
<h4 title="Months">2.3.5.1. 年月t</h4>

<p>
`年月t@
（ month ）は、日t 成分を伴わない（日t 成分は ε にされた）`日付$である。
◎
A month consists of a specific proleptic-Gregorian date with no time-zone information and no date information beyond a year and a month. [GREGORIAN]
</p>

<p class="trans-note">【
原文の語 “month” には、暗黙的に年tも含まれている（ “暦の中のある年tの中のある月t” ）。
単独の月t 成分と混同されないよう、この定義を指す month は， “年月t” と表記することにする。
】</p>

<p>
次の並びからなる文字列は、`年月t$を表現している
`妥当な年月t文字列@
とされる：
◎
A string is a valid month string representing a year year and month month if it consists of the following components in the given order:
</p>

<ol>
	<li>
年t 成分を表現する，次を満たす文字列 %年t
⇒
%年t は 4 個以上の`~ASCII数字$並びである
~AND
`Base10$( %年t ) ~NEQ 0
◎
Four or more ASCII digits, representing year, where year &gt; 0
</li>
	<li>
❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
月t 成分を表現する，次を満たす文字列 %月t
⇒
%月t は 2 個の`~ASCII数字$並びである
~AND
`Base10$( %月t ) ~IN { 1 〜 12 }
◎
Two ASCII digits, representing the month month, in the range 1 ≤ month ≤ 12
</li>
</ol>


<p class="algo-head">
所与の %入力 を
`年月t文字列として構文解析-@
する規則は、［
`年月t$, ε
］のいずれかを返す：
◎
The rules to parse a month string are as follows. This will return either a year and month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `年月t成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
Parse a month component to obtain year and month. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %日付
◎
Return year and month.
</li>
</ol>

<p class="algo-head">
所与の
(  %入力, %位置 )
から
`年月t成分を構文解析-@
する規則は、［
`年月t$, ε
］のいずれかを返す。
◎
The rules to parse a month component, given an input string and a position, are as follows. This will return either a year and a month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%年t ~LET［
`~ASCII数字$からなる`文字~並びを収集-$した結果
］
◎
↓</li>
	<li>
~IF［
%年t の文字~数 ~LT 4
］
⇒
~RET ε
◎
↓</li>
	<li>
%年t ~SET `Base10$( %年t )
◎
Collect a sequence of characters that are ASCII digits. If the collected sequence is not at least four characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the year.
</li>
	<li>
~IF［
%年t ~EQ 0
］
⇒
~RET ε
◎
If year is not a number greater than zero, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET ε
◎
↓</li>
	<li>
%位置 ~INCBY 1
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move position forwards one character.
</li>
	<li>
%月t ~LET ［
`~ASCII数字$からなる`文字~並びを収集-$した結果
］
◎
↓</li>
	<li>
~IF［
%月t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
↓</li>
	<li>
%月t数 ~SET `Base10$( %月t )
◎
Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the month.
</li>
	<li>
~IF［
%月t数 ~NIN { 1 〜 12 }
］
⇒
~RET ε
◎
If month is not a number in the range 1 ≤ month ≤ 12, then fail.
</li>
	<li>
~RET `日付$( %年t数, %月t数, ε )
◎
Return year and month.
</li>
</ol>


				</section>
				<section id="dates">
<h4 title="Dates">2.3.5.2. 日付</h4>


<div class="p">

<p>
`日付@
（ date ）は、時間帯~情報は伴わない特定の`遡及~Gregorian日付$ `GREGORIAN$r
を表し， 3 個の正~整数
( 年t, 月t, 日t )
成分からなる。
</p>

<p>
“日付( %年t, %月t, %日t )”
という表記は、
( 年t, 月t, 日t )
成分が，順に
( %年t, %月t, %日t )
にされた`日付$を表すとする。
同様に、
“日付( %年t, %月t, ε )”
という表記は `年月t$を表し，
“日付( ε, %月t, %日t )”
という表記は `月日t$を表すとする。
</p>

◎
A date consists of a specific proleptic-Gregorian date with no time-zone information, consisting of a year, a month, and a day. [GREGORIAN]
</div>


<p>
次の並びからなる文字列は、`日付$を表現している
`妥当な日付~文字列@
とされる：
◎
A string is a valid date string representing a year year, month month, and day day if it consists of the following components in the given order:
</p>

<ol>
	<li>
( 年t, 月t ) 成分を表現する，`妥当な年月t文字列$
◎
A valid month string, representing year and month
</li>
	<li>
1 個の ❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
日t 成分を表現する，次を満たす文字列 %日t
⇒
2 個の`~ASCII数字$並びである
~AND
`Base10$( %日t ) ~IN { 1 〜 `月tの日t数$( %年t数, %月t数 ) }
◎
Two ASCII digits, representing day, in the range 1 ≤ day ≤ maxday where maxday is the number of days in the month month and year year
</li>
</ol>


<p class="algo-head">
所与の %入力 を
`日付~文字列として構文解析-@
する規則は、［
`日付$, ε
］のいずれかを返す：
◎
The rules to parse a date string are as follows. This will return either a date, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
Parse a date component to obtain year, month, and day. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %日付
◎
Let date be the date with year year, month month, and day day.
◎
Return date.
</li>
</ol>

<p class="algo-head">
所与の
( %入力, %位置 )
から
`日付~成分を構文解析-@
する規則は、［
`日付$, ε
］のいずれかを返す：
◎
The rules to parse a date component, given an input string and a position, are as follows. This will return either a year, a month, and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%日付 ~LET `年月t成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
Parse a month component to obtain year and month. If this returns nothing, then fail.
</li>
	<li>
%最大日数 ~LET `月tの日t数$( %日付 の年t 成分, %日付 の月t 成分 )
◎
Let maxday be the number of days in month month of year year.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET ε
◎
↓</li>
	<li>
%位置 ~INCBY 1
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move position forwards one character.
</li>
	<li>
%日t ~LET ［
`~ASCII数字$からなる`文字~並びを収集-$した結果
］
◎
↓</li>
	<li>
~IF［
%日t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
↓</li>
	<li>
%日t数 ~SET `Base10$( %日t )
◎
Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the day.
</li>
	<li>
~IF［
%日t数 ~NIN { 1 〜 %最大日数 }
］
⇒
~RET ε
◎
If day is not a number in the range 1 ≤ day ≤ maxday, then fail.
</li>
	<li>
%日付 の 日t 成分 ~SET %日t数
</li>
	<li>
~RET %日付
◎
Return year, month, and day.
</li>
</ol>


				</section>
				<section id="yearless-dates">
<h4 title="Yearless dates">2.3.5.3. 月日t</h4>

<p>
`月日t@
（ yearless date, “年なし日付” ）は、年t 成分を伴わない（年t 成分は ε にされた）`日付$である。
◎
A yearless date consists of a Gregorian month and a day within that month, but with no associated year. [GREGORIAN]
</p>

<p class="trans-note">【
この訳では、他と表記法を一貫させるため， “月日t” と表記する。
】</p>

<p>
次の並びからなる文字列は、`月日t$を表現している
`妥当な月日t文字列@
とされる：
◎
A string is a valid yearless date string representing a month month and a day day if it consists of the following components in the given order:
</p>

<ol>
	<li>
0 個または 2 個の ❝-
◎
Optionally, two U+002D HYPHEN-MINUS characters (-)
</li>
	<li>
月t 成分を表現する，次を満たす文字列 %月t
⇒
%月t は 2 個の`~ASCII数字$並びである
~AND
`Base10$( %月t ) ~IN { 1 〜 12 }
◎
Two ASCII digits, representing the month month, in the range 1 ≤ month ≤ 12
</li>
	<li>
1 個の ❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
日t 成分を表現する，次を満たす文字列 %日t
⇒
%日t は 2 個の`~ASCII数字$並びである
~AND
`Base10$( %日t ) ~IN { 1 〜 `月tの日t数$( ε, `Base10$( %月t ) ) }
◎
Two ASCII digits, representing day, in the range 1 ≤ day ≤ maxday where maxday is the number of days in the month month and any arbitrary leap year (e.g. 4 or 2000)
</li>
</ol>

<p class="note">注記：
言い換えれば、［
%月t ~EQ `02^l
］ならば、年t数が閏~年tであったかのように，日t数は 29 もとり得る。
◎
In other words, if the month is "02", meaning February, then the day can be 29, as if the year was a leap year.
</p>


<p class="algo-head">
所与の %入力 を
`月日t文字列として構文解析-@
する規則は、［
`月日t$, ε
］のいずれかを返す：
◎
The rules to parse a yearless date string are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `月日t成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
Parse a yearless date component to obtain month and day. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %日付
◎
Return month and day.
</li>
</ol>

<p class="algo-head">
所与の
( %入力, %位置 )
から
`月日t成分を構文解析-@
する規則は、［
`月日t$, ε
］のいずれかを返す：
◎
The rules to parse a yearless date component, given an input string and a position, are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%seq ~LET ［
❝- からなる`文字~並びを収集-$した結果
］。
◎
↓</li>
	<li>
~IF［
%seq の文字~数 ~NIN { 0, 2 }
］
⇒
~RET ε
◎
Collect a sequence of characters that are U+002D HYPHEN-MINUS characters (-). If the collected sequence is not exactly zero or two characters long, then fail.
</li>
	<li>
%月t ~LET ［
`~ASCII数字$からなる`文字~並びを収集-$した結果
］
◎
↓</li>
	<li>
~IF［
%月t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
↓</li>
	<li>
%月t数 ~SET `Base10$( %月t )
◎
Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the month.
</li>
	<li>
~IF［
%月t数 ~NIN { 1 〜 12 }
］
⇒
~RET ε
◎
If month is not a number in the range 1 ≤ month ≤ 12, then fail.
◎
Let maxday be the number of days in month month of any arbitrary leap year (e.g. 4 or 2000).
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET ε
◎
↓</li>
	<li>
%位置 ~INCBY 1
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move position forwards one character.
</li>
	<li>
%日t ~LET ［
`~ASCII数字$からなる`文字~並びを収集-$した結果
］
◎
↓</li>
	<li>
~IF［
%日t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
↓</li>
	<li>
%日t数 ~SET `Base10$( %日t )
◎
Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the day.
</li>
	<li>
~IF［
%日t数 ~NIN { 1 〜 `月tの日t数$( ε, %月t数 ) }
］
⇒
~RET ε
◎
If day is not a number in the range 1 ≤ day ≤ maxday, then fail.
</li>
	<li>
~RET `日付$( ε, %月t数, %日t数 )
◎
Return month and day.
</li>
</ol>





				</section>
				<section id="times">
<h4 title="Times">2.3.5.4. 時刻</h4>

<div class="p">

<p>
`時刻@
（ time ）は、時間帯~情報を伴わない特定の時刻を表す，
( 時t, 分t, 秒t )
成分からなる。
時t, 分t
成分は整数であり、秒t 成分は 小数部も伴われ得る数である。
</p>

<p>
“時刻( %時t, %分t, %秒t )”
という表記は、
( 時t, 分t, 秒t )
成分が，順に
( %時t, %分t, %秒t )
にされた`時刻$を表すとする。
</p>

◎
A time consists of a specific time with no time-zone information, consisting of an hour, a minute, a second, and a fraction of a second.
</div>


<p>
次の並びからなる文字列は、`時刻$を表現している
`妥当な時刻~文字列@
とされる：
◎
A string is a valid time string representing an hour hour, a minute minute, and a second second if it consists of the following components in the given order:
</p>

<ol>
	<li>
時t 成分を表現する，次を満たす文字列 %時t
⇒
%時t は 2 個の`~ASCII数字$並びである
~AND
`Base10$( %時t ) ~IN { 0 〜 23 }
◎
Two ASCII digits, representing hour, in the range 0 ≤ hour ≤ 23
</li>
	<li>
1 個の ❝:
◎
A U+003A COLON character (:)
</li>
	<li>
分t 成分を表現する，次を満たす文字列 %分t
⇒
%分t は 2 個の`~ASCII数字$並びである
~AND
`Base10$( %分t ) ~IN { 0 〜 59 }
◎
Two ASCII digits, representing minute, in the range 0 ≤ minute ≤ 59
</li>
	<li>
<p>
空~文字列（秒t 成分 0 を表現する）, または
秒t 成分を表現する次の並び：
◎
If second is non-zero, or optionally if second is zero:
</p>
		<ol>
			<li>
1 個の ❝:
◎
A U+003A COLON character (:)
</li>
			<li>
秒t 成分の整数~部を表現する，次を満たす文字列 %秒t
⇒
%秒t は 2 個の`~ASCII数字$並びである
~AND
`Base10$( %秒t ) ~IN { 0 〜 59 }
◎
Two ASCII digits, representing the integer part of second, in the range 0 ≤ s ≤ 59
</li>
			<li>
<p>
空~文字列（ 秒t 成分は整数である）, または
秒tの小数~部を表現する 次の並び：
◎
If second is not an integer, or optionally if second is an integer:
</p>
				<ol>
					<li>
1 個の ❝.
◎
A U+002E FULL STOP character (.)
</li>
					<li>
1 〜 3 個の`~ASCII数字$
◎
One, two, or three ASCII digits, representing the fractional part of second
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
秒t 成分は 60, 61 にはなり得ないので、閏~秒tは表現できない。
◎
The second component cannot be 60 or 61; leap seconds cannot be represented.
</p>

<p class="trans-note">【
秒t 成分の小数部は、`妥当な時刻~文字列$としては 3 桁までにされているが，以下の構文解析-規則の中では 上限はない。
】</p>


<p class="algo-head">
所与の %入力 を
`時刻~文字列として構文解析-@
する規則は、［
`時刻$, ε
］のいずれかを返す：
◎
The rules to parse a time string are as follows. This will return either a time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%時刻 ~LET `時刻~成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%時刻 ~EQ ε
］
⇒
~RET ε
◎
Parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %時刻
◎
Let time be the time with hour hour, minute minute, and second second.
◎
Return time.
</li>
</ol>

<p class="algo-head">
所与の
( %入力, %位置 )
から
`時刻~成分を構文解析-@
する規則は、［
`時刻$, ε
］のいずれかを返す：
◎
The rules to parse a time component, given an input string and a position, are as follows. This will return either an hour, a minute, and a second, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%時t ~LET ［
`~ASCII数字$からなる`文字~並びを収集-$した結果
］
◎
↓</li>
	<li>
~IF［
%時t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
↓</li>
	<li>
%時t数 ~SET `Base10$( %時t )
◎
Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the hour.
</li>
	<li>
~IF［
%時t数 ~NIN { 0 〜 23 }
］
⇒
~RET ε
◎
If hour is not a number in the range 0 ≤ hour ≤ 23, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝:
］
⇒
~RET ε
◎
↓</li>
	<li>
%位置 ~INCBY 1
◎
If position is beyond the end of input or if the character at position is not a U+003A COLON character, then fail. Otherwise, move position forwards one character.
</li>
	<li>
%分t ~LET ［
`~ASCII数字$からなる`文字~並びを収集-$した結果
］
◎
↓</li>
	<li>
~IF［
%分t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
↓</li>
	<li>
%分t数 ~SET `Base10$( %分t )
◎
Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the minute.
</li>
	<li>
~IF［
%分t数 ~NIN { 0 〜 59 }
］
⇒
~RET ε
◎
If minute is not a number in the range 0 ≤ minute ≤ 59, then fail.
</li>
	<li>
%秒t数 ~LET 0
◎
Let second be 0.
</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝:
］：
</p>

		<ol>
			<li>
%位置 ~INCBY 1
</li>
			<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］~OR［
( %位置 + 1 )↗ ~NIN `~ASCII数字$
］
⇒
~RET ε
</li>
			<li>
%秒t数 ~SET `Base10$( ［
%位置↗, ( %位置 + 1 )↗
］並びからなる文字列
)
</li>
			<li>
%位置 ~INCBY 2
</li>
			<li>
%小数部 ~LET { `~ASCII数字$, ❝. } からなる`文字~並びを収集-$した結果
</li>
			<li>
<p >
~IF［
%小数部 ~NEQ 空~文字列
］：
</p>
				<ol>
					<li>
~IF［
%小数部 は［
1 個の ❝., 1 個以上の`~ASCII数字$
］並びでない
］
⇒
~RET ε
</li>
					<li>
%小数部 から先頭の文字を除去する
</li>
					<li>
%秒t数 ~INCBY `Base10$( %小数部 ) ÷ `Power10$( %小数部 の文字数 )
</li>
				</ol>
			</li>
<!-- 
浮動小数点数として構文解析 
rules-for-parsing-floating-point-number-values
 -->
		</ol>

◎
If position is not beyond the end of input and the character at position is a U+003A COLON, then run these substeps:
• Advance position to the next character in input.
• If position is beyond the end of input, or at the last character in input, or if the next two characters in input starting at position are not both ASCII digits, then fail.
• Collect a sequence of characters that are either ASCII digits or U+002E FULL STOP characters. If the collected sequence is three characters long, or if it is longer than three characters long and the third character is not a U+002E FULL STOP character, or if it has more than one U+002E FULL STOP character, then fail. Otherwise, interpret the resulting sequence as a base-ten number (possibly with a fractional part). Set second to that number.
</li>
	<li>
~IF［
%秒t数 ~LT 0
］~OR［
60 ~LTE %秒t数
］
⇒
~RET ε
◎
If second is not a number in the range 0 ≤ second &lt; 60, then fail.
</li>
	<li>
~RET `時刻$( %時t数, %分t数, %秒t数 )
◎
Return hour, minute, and second.
</li>
</ol>





				</section>
				<section id="local-dates-and-times">
<h4 title="Local dates and times">2.3.5.5. 局所的~日時</h4>

<p>
`局所的~日時@
（ local date and time ）は、時間帯は伴わない，
( `日付$, `時刻$ )
成分の組からなる。
`GREGORIAN$r
形式的には、偏差~成分が ε にされた`日時$として表される。
◎
A local date and time consists of a specific proleptic-Gregorian date, consisting of a year, a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of a second, but expressed without a time zone. [GREGORIAN]
</p>

<p>
次の並びからなる文字列は、`局所的~日時$を表現している
`妥当な局所的~日時~文字列@
とされる：
◎
A string is a valid local date and time string representing a date and time if it consists of the following components in the given order:
</p>

<ol>
	<li>
日付 成分を表現する，`妥当な日付~文字列$
◎
A valid date string representing the date
</li>
	<li>
1 個の［
❝T, または ~SPACE
］
◎
A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character
</li>
	<li>
時刻 成分を表現する，`妥当な時刻~文字列$
◎
A valid time string representing the time
</li>
</ol>

<p>
`妥当な局所的~日時~文字列$は、［
その時刻 成分を表現する文字列が，それが表現する時刻を可能0な限り最短の文字列で表現する
］ならば、
`妥当な正規化済みの局所的~日時~文字列@
とされる（例えば，時刻の 秒t 成分が~zeroならば、秒t 成分を表現する文字列を まるごと省略する）。
◎
A string is a valid normalized local date and time string representing a date and time if it consists of the following components in the given order:
• A valid date string representing the date
• A U+0054 LATIN CAPITAL LETTER T character (T)
• A valid time string representing the time, expressed as the shortest possible string for the given time (e.g. omitting the seconds component entirely if the given time is zero seconds past the minute)
</p>

<p class="algo-head">
所与の %入力 を
`局所的~日時~文字列として構文解析-@
する規則は、［
`局所的~日時$, ε
］のいずれかを返す：
◎
The rules to parse a local date and time string are as follows. This will return either a date and time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
Parse a date component to obtain year, month, and day. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NIN { ❝T, ~SPACE }
］
⇒
~RET ε
◎
↓</li>
	<li>
%位置 ~INCBY 1
◎
If position is beyond the end of input or if the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail. Otherwise, move position forwards one character.
</li>
	<li>
%時刻 ~LET `時刻~成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%時刻 ~EQ ε
］
⇒
~RET ε
◎
Parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
◎
Let date be the date with year year, month month, and day day.
◎
Let time be the time with hour hour, minute minute, and second second.
</li>
	<li>
~RET `日時$( %日付, %時刻, ε )
◎
Return date and time.
</li>
</ol>

				</section>
				<section id="time-zones">
<h4 title="Time zones">2.3.5.6. 時間帯</h4>

<div class="p">

<p>
`偏差@
（ time-zone offset ）は、 2 個の有符号~整数
( 時t, 分t )
成分からなる。
</p>

<p class="trans-note">【
偏差は、~UTCからの偏差
— すなわち，時間帯（ time zone ） —
を表す。
データとしては，時間帯も偏差も同じであり、何が念頭に置かれるか以外に違いはない。
】</p>

<p>
“偏差( %時t, %分t )”
という表記は、
( 時t, 分t )
成分が，順に
( %時t, %分t )
にされた`偏差$を表すとする。
</p>

◎
A time-zone offset consists of a signed number of hours and minutes.
</div>

<p>
次のいずれかで与えられる文字列は、
偏差を表現している
`妥当な偏差~文字列@
とされる：
◎
A string is a valid time-zone offset string representing a time-zone offset if it consists of either:
</p>


<ul>
	<li>
時間帯が~UTC
`すなわち，偏差( 0, 0 )^tnote
の場合に限り
⇒
1 個の ❝Z
◎
A U+005A LATIN CAPITAL LETTER Z character (Z), allowed only if the time zone is UTC
</li>
	<li>
<p>
または、次の並びからなる文字列：
◎
Or, the following components, in the given order:
</p>

		<ol>
	<li>
偏差の各~成分の符号を表現する，
❝+ , または ❝-
— ただし，偏差の両~成分とも~zeroの場合、後者は許容されない。
◎
Either a U+002B PLUS SIGN character (+) or, if the time-zone offset is not zero, a U+002D HYPHEN-MINUS character (-), representing the sign of the time-zone offset
</li>
	<li>
偏差の時t 成分を表現する，次を満たす文字列 %時t
⇒
%時t は 2 個の`~ASCII数字$並びである
~AND
`Base10$( %時t ) ~IN { 0 〜 23 }
◎
Two ASCII digits, representing the hours component hour of the time-zone offset, in the range 0 ≤ hour ≤ 23
</li>
	<li>
0 〜 1 個の ❝:
◎
Optionally, a U+003A COLON character (:)
</li>
	<li>
偏差の分t 成分を表現する，次を満たす文字列 %分t
⇒
%分t は 2 個の`~ASCII数字$並びである
~AND
`Base10$( %分t ) ~IN { 0 〜 59 }
◎
Two ASCII digits, representing the minutes component minute of the time-zone offset, in the range 0 ≤ minute ≤ 59
</li>
		</ol>
	</li>
</ul>

<p class="note">注記：
この形式は、範囲
{ −23:59 〜 +23:59 }
の偏差を許容する。
今現在，実施においては、実際の時間帯の範囲は
{ −12:00 〜 +14:00 }
であり，実際の時間帯の分t 成分は、常に ［
00, 30, 45
］のいずれかにされている。
しかしながら、永劫にそうあり続ける保証はない
— 時間帯は政治的駆け引きにも利用されており、気まぐれな政治的~決断の対象になるので。
◎
This format allows for time-zone offsets from -23:59 to +23:59. Right now, in practice, the range of offsets of actual time zones is -12:00 to +14:00, and the minutes component of offsets of actual time zones is always either 00, 30, or 45. There is no guarantee that this will remain so forever, however, since time zones are used as political footballs and are thus subject to very whimsical policy decisions.
</p>

<p class="note">注記：
偏差を［
公式的な時間帯の制定~以前の歴史的~時刻
］と併用する際の詳細については、下の`大域的~日時$ 節における用法についての注記, および例も見よ。
◎
See also the usage notes and examples in the global date and time section below for details on using time-zone offsets with historical times that predate the formation of formal time zones.
</p>


<p class="algo-head">
所与の %入力 を
`偏差~文字列として構文解析-@
する規則は、［
偏差, ε
］のいずれかを返す：
◎
The rules to parse a time-zone offset string are as follows. This will return either a time-zone offset, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%偏差 ~LET `偏差~成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%偏差 ~EQ ε
］
⇒
~RET ε
◎
Parse a time-zone offset component to obtain timezonehours and timezoneminutes. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %偏差
◎
Return the time-zone offset that is timezonehours hours and timezoneminutes minutes from UTC.
</li>
</ol>

<p class="algo-head">
所与の
( %入力, %位置 )
から
`偏差~成分を構文解析-@
する規則は、［
`偏差$, ε
］のいずれかを返す：
◎
The rules to parse a time-zone offset component, given an input string and a position, are as follows. This will return either time-zone hours and time-zone minutes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%符号 ~LET %位置↗
◎
↓</li>
	<li>
~IF［
%符号 ~NIN { ❝+, ❝-, ❝Z }
］
⇒
~RET ε
◎
↓↓</li>
	<li>
%位置 ~INCBY 1
◎
↓</li>
	<li>
<p>
~IF［
%符号 ~EQ ❝Z
］
⇒
~RET `偏差$( 0, 0 )
◎
If the character at position is a U+005A LATIN CAPITAL LETTER Z character (Z), then:
• Let timezonehours be 0.
• Let timezoneminutes be 0.
• Advance position to the next character in input.
</li>
	<li>
( %時t, %分t ) ~LET
( `~ASCII数字$からなる`文字~並びを収集-$した結果, ε )
◎
↑↑Otherwise, if the character at position is either a U+002B PLUS SIGN (+) or a U+002D HYPHEN-MINUS (-), then:
◎
↓If the character at position is a U+002B PLUS SIGN (+), let sign be "positive". Otherwise, it's a U+002D HYPHEN-MINUS (-); let sign be "negative".
◎
↑Advance position to the next character in input.
◎
Collect a sequence of characters that are ASCII digits. Let s be the collected sequence.
</li>
	<li>
<p>
~IF［
%時t の文字~数 ~EQ 2
］：
</p>

		<ol>
			<li>
~IF［
%位置↗ ~NEQ ❝:
］
⇒
~RET ε
</li>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%分t ~SET `~ASCII数字$からなる`文字~並びを収集-$した結果
</li>
			<li>
~IF［
%分t の文字~数 ~NEQ 2
］
⇒
~RET ε
</li>
		</ol>
◎
If s is exactly two characters long, then run these substeps:
• Interpret s as a base-ten integer. Let that number be the timezonehours.
• If position is beyond the end of input or if the character at position is not a U+003A COLON character, then fail. Otherwise, move position forwards one character.
• Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the timezoneminutes.
</li>
	<li>
~ELIF［
%時t の文字~数 ~EQ 4
］
⇒
( %時t, %分t ) ~SET  %時t の ( 最初の 2 文字, 最後の 2 文字 )
◎
If s is exactly four characters long, then run these substeps:
• Interpret the first two characters of s as a base-ten integer. Let that number be the timezonehours.
• Interpret the last two characters of s as a base-ten integer. Let that number be the timezoneminutes.
</li>
	<li>
~ELSE
⇒
~RET ε
◎
Otherwise, fail.
</li>
	<li>
( %時t数, %分t数 ) ~LET ( `Base10$( %時t ), `Base10$( %分t ) )
◎
↑</li>
	<li>
~IF［
%時t数 ~NIN { 0 〜 23 }
］~OR［
%分t数 ~NIN { 0 〜 59 }
］
⇒
~RET ε
◎
If timezonehours is not a number in the range 0 ≤ timezonehours ≤ 23, then fail.
◎
If sign is "negative", then negate timezonehours.
◎
If timezoneminutes is not a number in the range 0 ≤ timezoneminutes ≤ 59, then fail.
◎
If sign is "negative", then negate timezoneminutes.
</li>
	<li>
~IF［
%符号 ~EQ ❝-
］
⇒
~RET `偏差$( %時t数 × −1, %分t数 × −1 )
◎
↑</li>
	<li>
~RET `偏差$( %時t数, %分t数 )
◎
↑↑Otherwise, fail.
◎
Return timezonehours and timezoneminutes.
</li>
</ol>





				</section>
				<section id="global-dates-and-times">
<h4 title="Global dates and times">2.3.5.7. 大域的~日時</h4>

<div class="p">

<p>
`大域的~日時@
（ global date and time ）は、
( `日付$, `時刻$, `偏差$ )
成分の組で表される。
</p>

<p class="trans-note">【
［
`日付$, `時刻$
］成分のみで，~UTC世界時（地域に依存しない日時）が表現される。
`偏差$ 成分は、［
利用者に呈示する（`局所的~日時$に変換するなど） ／
文字列に直列化して外部に渡す
］ときに利用される付帯~情報になる。
】</p>

<p>
“日時( %日付, %時刻, %偏差 )”
という表記は、
( `日付$, `時刻$, `偏差$ )
成分が，順に
( %日付, %時刻, %偏差 )
にされた`大域的~日時$を表す（ %偏差 ~NEQ ε ならば）。
同様に、
“日時( %日付, %時刻, ε )”
という表記は `局所的~日時$を表すとする。
</p>

◎
A global date and time consists of a specific proleptic-Gregorian date, consisting of a year, a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of a second, expressed with a time-zone offset, consisting of a signed number of hours and minutes. [GREGORIAN]
</div>


<p>
次の並びからなる文字列は、`大域的~日時$を表現している
`妥当な大域的~日時~文字列@
とされる：
◎
A string is a valid global date and time string representing a date, time, and a time-zone offset if it consists of the following components in the given order:
</p>

<ol>
	<li>
日付 成分を表現する，`妥当な日付~文字列$
◎
A valid date string representing the date
</li>
	<li>
1 個の［
❝T または ~SPACE
］
◎
A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character
</li>
	<li>
時刻 成分を表現する，`妥当な時刻~文字列$
◎
A valid time string representing the time
</li>
	<li>
偏差 成分を表現する，`妥当な偏差~文字列$
◎
A valid time-zone offset string representing the time-zone offset
</li>
</ol>

<div >
<p>
20 世紀~中頃における~UTCの制定~以前の日付による時刻は、~UT1世界時の用語（経度 0° の地点における当時の太陽時）を通して表され, 解釈され~MUST
— ~UTC（ SI 単位による秒t数で刻む ~UT1の，近似）ではなく。
時間帯の制定~以前の時刻は、次の 2 つを伴う~UT1時刻として表され, 解釈され~MUST：
</p>

<ul ><li>適切な局所的~時刻
</li><li>London Greenwich の所在にて観測される時刻との間の 当時の相違を近似するような，明示的な時間帯
</li></ul>

◎
Times in dates before the formation of UTC in the mid twentieth century must be expressed and interpreted in terms of UT1 (contemporary Earth solar time at the 0° longitude), not UTC (the approximation of UT1 that ticks in SI seconds). Time before the formation of time zones must be expressed and interpreted as UT1 times with explicit time zones that approximate the contemporary difference between the appropriate local time and the time observed at the location of Greenwich, London.
</div>


<div class="example">
<p>
`妥当な大域的~日時~文字列$として記される日付の例を以下に挙げる：
◎
The following are some examples of dates written as valid global date and time strings.
</p>

<dl>
	<dt>`0037-12-13 00:00Z^l</dt>
	<dd>
~London時刻を利用している地域における，~Nero（~Roman-Emperor）の誕生日の真夜中。
これに実際に対応する日付についての更なる論点については下を見よ。
◎
Midnight in areas using London time on the birthday of Nero (the Roman Emperor). See below for further discussion on which date this actually corresponds to.
</dd>

	<dt>`1979-10-14T12:00:00.001-04:00^l</dt>
	<dd>
USA 東海岸の夏時間に利用-中の時間帯における，［
1979 年 10 月 14 日
］の真昼から 1 ~milli秒t後。
◎
One millisecond after noon on October 14th 1979, in the time zone in use on the east coast of the USA during daylight saving time.
</dd>

	<dt>`8592-01-01T02:09+02:09^l</dt>
	<dd>
~UTCによる［
8592 年 1 月 1 日
］の真夜中。
この時刻には、~UTCより 2 時間 9 分 進んでいる時間帯が結付けられている
— それは、現在~~実用されている時間帯ではないが，許容される。
◎
Midnight UTC on the 1st of January, 8592. The time zone associated with that time is two hours and nine minutes ahead of UTC, which is not currently a real time zone, but is nonetheless allowed.
</dd></dl>

<p>
これらの日付について注目すべき点は：
◎
Several things are notable about these dates:
</p>

<ul>
	<li>
4 桁に満たない年tは~zero詰めされる必要がある。
`37-12-13^l は妥当な日付でない。
◎
Years with fewer than four digits have to be zero-padded. The date "37-12-13" would not be a valid date.
</li>
	<li>
`T^l に代えて~SPACEが用いられる場合、 1 個の~SPACEで~MUST。
文字列
`2001-12-21&nbsp;&nbsp;12:00Z^l
（成分~間に 2 個の~SPACEがある）は、成功裡に構文解析されない。
◎
If the "T" is replaced by a space, it must be a single space character. The string "2001-12-21 12:00Z" (with two spaces between the components) would not be parsed successfully.
</li>
	<li>
~Gregorian暦が導入される以前の時刻を一義的に識別するため（~UTCの制定~以前の時刻を一義的に識別できるようにする限りにおいて）、日付は、先ず当の時刻が利用している暦（例： ~Julian暦 ）から，~Gregorian暦に変換される必要がある。
~Nero生誕の日付は、~Julian暦においては
37 年 12 月 15 日
であり，`遡及~Gregorian暦$においては
37 年 12 月 13 日
になる。
◎
To unambiguously identify a moment in time prior to the introduction of the Gregorian calendar (insofar as moments in time before the formation of UTC can be unambiguously identified), the date has to be first converted to the Gregorian calendar from the calendar in use at the time (e.g. from the Julian calendar). The date of Nero's birth is the 15th of December 37, in the Julian Calendar, which is the 13th of December 37 in the proleptic Gregorian calendar.
</li>
	<li>
時刻, 偏差 いずれの成分も省略可ではない。
◎
The time and time-zone offset components are not optional.
</li>
	<li>
0001 年t より前の日付は、この~versionの~HTMLにおいては，日時として表現できない。
◎
Dates before the year one can't be represented as a datetime in this version of HTML.
</li>
	<li>
前近代における特定の出来事の時刻は、最善でも近似である
— 時刻は比較的近代まで，きちんと協調されても測定されてもいなかったので。
◎
Times of specific events in ancient times are, at best, approximations, since time was not well coordinated or measured until relatively recent decades.
</li>
	<li>
偏差は、夏時間に基づいて相違する。
◎
Time-zone offsets differ based on daylight savings time.
</li>
</ul>

</div>

<p class="algo-head">
所与の %入力 を
`大域的~日時~文字列として構文解析-@
する規則は、［
`大域的~日時$, ε
］のいずれかを返す：
<!-- 
受渡しや表示-目的0に~UTCからに偏差~情報も伴う ＊時刻,
-->
◎
The rules to parse a global date and time string are as follows. This will return either a time in UTC, with associated time-zone offset information for round-tripping or display purposes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
Parse a date component to obtain year, month, and day. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NIN { ❝T, ~SPACE }
］
⇒
~RET ε
◎
↓</li>
	<li>
%位置 ~INCBY 1
◎
If position is beyond the end of input or if the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail. Otherwise, move position forwards one character.
</li>
	<li>
%時刻 ~LET `時刻~成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%時刻 ~EQ ε
］
⇒
~RET ε
◎
Parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET ε
◎
If position is beyond the end of input, then fail.
</li>
	<li>
%偏差 ~LET `偏差~成分を構文解析-$した結果
◎
↓</li>
	<li>
~IF［
%偏差 ~EQ ε
］
⇒
~RET ε
◎
Parse a time-zone offset component to obtain timezonehours and timezoneminutes. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
( %日付, %時刻 ) ~LET ( %日付, %時刻 ) から %偏差 を減算した結果†
— この結果が~UTC時間帯における時刻を表す。
◎
Let time be the moment in time at year year, month month, day day, hours hour, minute minute, second second, subtracting timezonehours hours and timezoneminutes minutes. That moment in time is a moment in the UTC time zone.
</li>
	<li>
~RET `日時$( %日付, %時刻, %偏差 )
◎
Let timezone be timezonehours hours and timezoneminutes minutes from UTC.
◎
Return time and timezone.
</li>
</ol>


<p class="trans-note">【†
“減算する” ための具体的な~algoは、この仕様には述べられていない。
%入力 においては，年t 成分に対する
<a href="#parse-a-month-component">~zeroは許容されていない</a>
が、減算した結果の年tは，~zeroになり得る。
】</p>


				</section>
				<section id="weeks">
<h4 title="Weeks">2.3.5.8. 年週t</h4>

<div class="p">

<p>
`年週t@
（ week ）は、 2 個の正~整数
( 週年t, 週t )
成分からなり，`遡及~Gregorian暦$における ある［
月曜から開始する七日間
］を表現する。
この暦付け~systemにおける各 週年tは、そのような七日間を 52 回または 53 回 有する
— 下に定義されるように。
~Gregorian日付［
1969 年 12 月 29 日の月曜（ 1969-12-29 ）
］から開始する七日間は、［
週年t 1970 における第 1 週t
］として定義される。
ある週年tにおける各 週tは、 1 から順々に付番される。
ある週年tにおける第 1 週tより前の週tは、その前の週年tにおける最後の週tであり，その逆も同様である。
`GREGORIAN$r
</p>

<p class="trans-note">【
`年月t$のときと同様に、この訳では “年週t” と表記する。
】</p>

<p>
“年週t( %週年t, %週t )”
という表記は、
( 週年t, 週t )
成分が，順に
( %週年t, %週t )
にされた`年週t$を表すとする。
</p>

◎
A week consists of a week-year number and a week number representing a seven-day period starting on a Monday. Each week-year in this calendaring system has either 52 or 53 such seven-day periods, as defined below. The seven-day period starting on the Gregorian date Monday December 29th 1969 (1969-12-29) is defined as week number 1 in week-year 1970. Consecutive weeks are numbered sequentially. The week before the number 1 week in a week-year is the last week in the previous week-year, and vice versa. [GREGORIAN]
</div>


<div class="p">

<p>
週年t %Y の
`最後の日tの週t番号@
— “週t数( %Y )” とも表記される —
は、次のいずれかが満たされるならば 53 とされ，他の場合は 52 とされる：
</p>

<ul>
	<li>
［［
`遡及~Gregorian暦$における年t %Y
］の最初の日t（ 1 月 1 日 ）の曜日
］は、火曜である
</li>
	<li>
<p>
前項の曜日は 水曜である ~AND
%Y は 次のいずれかを満たす：
</p>

<ul ><li>400 の倍数である
</li><li>4 の倍数であって 100 の倍数でない
</li></ul>

	</li>
</ul>

◎
A week-year with a number year has 53 weeks if it corresponds to either a year year in the proleptic Gregorian calendar that has a Thursday as its first day (January 1st), or a year year in the proleptic Gregorian calendar that has a Wednesday as its first day (January 1st) and where year is a number divisible by 400, or a number divisible by 4 but not by 100. All other week-years have 52 weeks.
◎
The week number of the last day of a week-year with 53 weeks is 53; the week number of the last day of a week-year with 52 weeks is 52.
</div>

<p class="note">注記：
年末年始の特定0の日tにおける週年tと，`遡及~Gregorian暦$における その日tを包含する年tとは、異なることもある。
週年t %Y における最初の週tは、~Gregorian年t %Y の最初の火曜を包含する週tである
`そうなるように、年週tは定義されている^tnote
。
◎
The week-year number of a particular day can be different than the number of the year that contains that day in the proleptic Gregorian calendar. The first week in a week-year y is the week that contains the first Thursday of the Gregorian year y.
</p>

<p class="note">注記：
現代の目的0においては、ここに定義される`年週t$は、
`ISO8601$r に定義される週tと等価になる。
◎
For modern purposes, a week as defined here is equivalent to ISO weeks as defined in ISO 8601. [ISO8601]
</p>

<p>
次の並びからなる文字列は、`年週t$を表現している
`妥当な年週t文字列@
とされる：
◎
A string is a valid week string representing a week-year year and week week if it consists of the following components in the given order:
</p>

<ol>
	<li>
年週tの週年t 成分を表現する，次を満たす文字列 %週年t
⇒
%週年t は 4 個以上の`~ASCII数字$並びである
~AND
`Base10$( %週年t ) ~NEQ 0
◎
Four or more ASCII digits, representing year, where year &gt; 0
</li>
	<li>
1 個の ❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
1 個の ❝W
◎
A U+0057 LATIN CAPITAL LETTER W character (W)
</li>
	<li>
年週tの週t 成分を表現する，次を満たす文字列 %週t
⇒
%週t は 2 個の`~ASCII数字$並びである
~AND
`Base10$( %週t ) ~IN { 1 〜 `週t数$( %週年t が表現する週年t )
}
◎
Two ASCII digits, representing the week week, in the range 1 ≤ week ≤ maxweek, where maxweek is the week number of the last day of week-year year
</li>
</ol>


<p class="algo-head">
所与の %入力 を
`年週t文字列として構文解析-@
する規則は、［
`年週t$, ε
］のいずれかを返す：
◎
The rules to parse a week string are as follows. This will return either a week-year number and week number, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%年t ~LET ［
`~ASCII数字$からなる`文字~並びを収集-$した結果
］
◎
↓</li>
	<li>
~IF［
%年t の文字~数 ~LT 4
］
⇒
~RET ε
◎
↓</li>
	<li>
%年t数 ~SET `Base10$( %年t )

◎
Collect a sequence of characters that are ASCII digits. If the collected sequence is not at least four characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the year.
</li>
	<li>
~IF［
%年t数 ~EQ 0
］
⇒
~RET ε
◎
If year is not a number greater than zero, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET ε
◎
↓</li>
	<li>
%位置 ~INCBY 1
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail. Otherwise, move position forwards one character.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝W
］
⇒
~RET ε
◎
↓</li>
	<li>
%位置 ~INCBY 1
◎
If position is beyond the end of input or if the character at position is not a U+0057 LATIN CAPITAL LETTER W character (W), then fail. Otherwise, move position forwards one character.
</li>
	<li>
%週t ~LET ［
`~ASCII数字$からなる`文字~並びを収集-$した結果
］
◎
↓</li>
	<li>
~IF［
%週t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
↓</li>
	<li>
%週t数 ~SET `Base10$( %週t )
◎
Collect a sequence of characters that are ASCII digits. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the week.
</li>
	<li>
~IF［
%週t数 ~NIN { 1 〜 `週t数$( %年t数 ) }
］
⇒
~RET ε
◎
Let maxweek be the week number of the last day of year year.
◎
If week is not a number in the range 1 ≤ week ≤ maxweek, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET 
`年週t$( %年t数, %週t数 )
◎
Return the week-year number year and the week number week.
</li>
</ol>





				</section>
				<section id="durations">
<h4 title="Durations">2.3.5.9. 時間長</h4>

<p>
`時間長@
（ duration ）は、（負でない）秒t数である。
◎
A duration consists of a number of seconds.
</p>

<p class="note">注記：
月t数と秒t数は，比較可能でないので（月tは精確な秒t数を表さない
— その正確な長さは，測定し始める精確な日tに依存する期間である）、この仕様にて定義される`時間長$には，月tは含められない（したがって月t数 12 に等価な年tも）。
特定の秒t数を述べる時間長のみ，記述できる。
◎
Since months and seconds are not comparable (a month is not a precise number of seconds, but is instead a period whose exact length depends on the precise day from which it is measured) a duration as defined in this specification cannot include months (or years, which are equivalent to twelve months). Only durations that describe a specific number of seconds can be described.
</p>

<p>
次のいずれかからなる文字列は、`時間長$を表現している
`妥当な時間長~文字列@
とされる：
◎
A string is a valid duration string representing a duration t if it consists of either of the following:
</p>

<ul>
	<li>
<p>
次の並びからなる 長さ 2 以上の文字列
— その中で与えられる
( 日t数, 時t数, 分t数, 秒t数 )
に対する
( 日t数 × 86400 + 時t数  × 3600 + 分t数 × 60 + 秒t数 )
が、`時間長$を与える（どの空~文字列も 0 に解釈する）：
◎
A literal U+0050 LATIN CAPITAL LETTER P character followed by one or more of the following subcomponents, in the order given, where the number of days, hours, minutes, and seconds corresponds to the same number of seconds as in t:
</p>

		<ol>
			<li>
1 個の ❝P
◎
↑</li>
			<li>
日t数を表現する，空~文字列 または 次の並び
⇒
1 個以上の`~ASCII数字$,
1 個の ❝D
◎
One or more ASCII digits followed by a U+0044 LATIN CAPITAL LETTER D character, representing a number of days.
</li>
			<li>
<p>
( 時t数, 分t数, 秒t数 ) いずれも 0 を表現する空~文字列, または
次の並びからなる 長さ 2 以上の文字列：
◎
↓</p>

				<ol>
					<li>
1 個の ❝T
◎
A U+0054 LATIN CAPITAL LETTER T character followed by one or more of the following subcomponents, in the order given:
</li>
					<li>
時t数を表現する，空~文字列 または 次の並び
⇒
1 個以上の`~ASCII数字$,
1 個の ❝H
◎
One or more ASCII digits followed by a U+0048 LATIN CAPITAL LETTER H character, representing a number of hours.
</li>
					<li>
分t数を表現する，空~文字列 または 次の並び
⇒
1 個以上の`~ASCII数字$,
1 個の ❝M
◎
One or more ASCII digits followed by a U+004D LATIN CAPITAL LETTER M character, representing a number of minutes.
</li>
					<li>
<p>
秒t数を表現する，空~文字列 または 次の並び：
◎
The following components:
</p>

		  				<ol>
							<li>
1 個以上の`~ASCII数字$
◎
One or more ASCII digits, representing a number of seconds.
</li>
							<li>
秒tの小数部を表現する，空~文字列 または 次の並び
⇒
1 個の ❝., ［
1 〜 3 個の`~ASCII数字$
］
◎
Optionally, a U+002E FULL STOP character (.) followed by one, two, or three ASCII digits, representing a fraction of a second.
</li>
							<li>
1 個の ❝S
◎
A U+0053 LATIN CAPITAL LETTER S character.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
これは、この仕様にて 日時に関係する他の各種 小構文に定義されるように，
`ISO8601$r にて定義される各種~形式のいずれかに基づく。
◎
This, as with a number of other date- and time-related microsyntaxes defined in this specification, is based on one of the formats defined in ISO 8601. [ISO8601]
</p>
	</li>
	<li>
<p>
任意の順序による， 1 個以上の各種 `時間長~成分$
— それぞれの`時間長~成分の縮尺$は互いに異なるような。
それぞれが表現する秒t数の総和が、`時間長$を与える。
◎
One or more duration time components, each with a different duration time component scale, in any order; the sum of the represented seconds being equal to the number of seconds in t.
</p>

<p>
次の並びからなる文字列が
`時間長~成分@
（ duration time component ）とされる：
◎
A duration time component is a string consisting of the following components:
</p>

<ol>
	<li>
0 個以上の`空白類$
◎
Zero or more space characters.
</li>
	<li>
1 個以上の `~ASCII数字$
— 時間~単位~数を表現し、
( この数 × 下に指定される`時間長~成分の縮尺$ )
が，この時間長~成分の秒t数を表現する。
◎
One or more ASCII digits, representing a number of time units, scaled by the duration time component scale specified (see below) to represent a number of seconds.
</li>
	<li>
`時間長~成分の縮尺$ ~EQ 1 の場合（すなわち，単位は秒t）に限り
⇒
空~文字列, または 秒tの小数部を表現する次の並び
⇒
1 個の ❝.,
1 〜 3 個の`~ASCII数字$
◎
If the duration time component scale specified is 1 (i.e. the units are seconds), then, optionally, a U+002E FULL STOP character (.) followed by one, two, or three ASCII digits, representing a fraction of a second.
</li>
	<li>
0 個以上の`空白類$
◎
Zero or more space characters.
</li>
	<li>
<p>
次の表の最初の列に与えるいずれかの文字
— 同じ行の “縮尺” の列が
`時間長~成分の縮尺@
を与える：
</p>

<table>
<thead><tr><th>文字
</th><th>単位
</th><th>縮尺
</th></tr></thead>

<tbody><tr><td>❝W, ❝w
</td><td>週t
</td><td>604800

</td></tr><tr><td>❝D, ❝d
</td><td>日t
</td><td>86400

</td></tr><tr><td>❝H, ❝h
</td><td>時t
</td><td>3600

</td></tr><tr><td>❝M, ❝m
</td><td>分t
</td><td>60

</td></tr><tr><td>❝S, ❝s
</td><td>秒t
</td><td>1
</td></tr></tbody></table>

◎
One of the following characters, representing the duration time component scale of the time unit used in the numeric part of the duration time component:
• U+0057 LATIN CAPITAL LETTER W character
• U+0077 LATIN SMALL LETTER W character
•• Weeks. The scale is 604800.
• U+0044 LATIN CAPITAL LETTER D character
• U+0064 LATIN SMALL LETTER D character
•• Days. The scale is 86400.
• U+0048 LATIN CAPITAL LETTER H character
• U+0068 LATIN SMALL LETTER H character
•• Hours. The scale is 3600.
• U+004D LATIN CAPITAL LETTER M character
• U+006D LATIN SMALL LETTER M character
•• Minutes. The scale is 60.
• U+0053 LATIN CAPITAL LETTER S character
• U+0073 LATIN SMALL LETTER S character
•• Seconds. The scale is 1.
</li>
	<li>
0 個以上の`空白類$
◎
Zero or more space characters.
</li>
</ol>

<p class="note">注記：
これは、~ISO8601のどの形式に基づくものでもない。
これは、~ISO8601時間長~形式より，人から読み易い代替を与えるために意図されている。
◎
This is not based on any of the formats in ISO 8601. It is intended to be a more human-readable alternative to the ISO 8601 duration format.
</p>

	</li>
</ul>

<p class="algo-head">
所与の %入力 を
`時間長~文字列として構文解析-@
する規則は、［
`時間長$, ε
］のいずれかを返す：
◎
The rules to parse a duration string are as follows. This will return either a duration or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
( %月t数, %秒t数, %空 )
~LET ( 0, 0, ~T )
◎
Let months, seconds, and component count all be zero.
</li>
	<li>

<p>
%M一義化子 ~LET `分t^i
◎
Let M-disambiguator be minutes.
</p>

<p class="note">注記：
%M一義化子 が他にとり得る値は `月t^i である。
これは、月t数と分t数に同じ単位を利用している
~ISO8601時間長における "M" 単位を一義化するために利用される。
月t数は %入力 に許容されないが、将来との互換性をとるため, および
他の文脈においては妥当になるような~ISO8601時間長の誤解釈を避けるために構文解析される。
◎
This flag's other value is months. It is used to disambiguate the "M" unit in ISO8601 durations, which use the same unit for months and minutes. Months are not allowed, but are parsed for future compatibility and to avoid misinterpreting ISO8601 durations that would be valid in other contexts.
</p>

	</li>
	<li>
`空白を読飛ばす$
◎
Skip whitespace.
◎
If position is past the end of input, then fail.
</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝P 
］：
</p>
		<ol>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%M一義化子 ~SET `月t^i
</li>
			<li>
`空白を読飛ばす$
</li>
		</ol>

◎
If the character in input pointed to by position is a U+0050 LATIN CAPITAL LETTER P character, then advance position to the next character, set M-disambiguator to months, and skip whitespace.
</li>
	<li>

<p>
~WHILE %位置↗ ~NEQ ε：
<!-- ＊ -->
◎
Run the following substeps in a loop, until a step requiring the loop to be broken or the entire algorithm to fail is reached:
• Let units be undefined. It will be assigned one of the following values: years, months, weeks, days, hours, minutes, and seconds.
• Let next character be undefined. It is used to process characters from the input.
• If position is past the end of input, then break the loop.
</p>

		<ol>
			<li>
( %N, %単位, %縮尺 ) ~LET ( 0, ε, ε )
◎
↑</li>
			<li>
<p>
~IF［
%位置↗ ~EQ ❝T 
］：
</p>
				<ol>
					<li>
%位置 ~INCBY 1
</li>
					<li>
%M一義化子 ~SET `分t^i
</li>
					<li>
`空白を読飛ばす$
</li>
					<li>
~CONTINUE
</li>
				</ol>

<!-- 
T が複数個連続していても許容される
-->

◎
If the character in input pointed to by position is a U+0054 LATIN CAPITAL LETTER T character, then advance position to the next character, set M-disambiguator to minutes, skip whitespace, and return to the top of the loop.
</li>
			<li>
~IF［
%位置↗ ~NIN { `~ASCII数字$, ❝. }
］
⇒
~RET ε
◎
↓</li>
			<li>
%N ~SET `Base10$( `~ASCII数字$からなる`文字~並びを収集-$した結果 )
◎
Set next character to the character in input pointed to by position.
• If next character is a U+002E FULL STOP character (.), then let N equal zero. (Do not advance position. That is taken care of below.)
• Otherwise, if next character is an ASCII digit, then collect a sequence of characters that are ASCII digits, interpret the resulting sequence as a base-ten integer, and let N be that number.
• Otherwise next character is not part of a number; fail.
• If position is past the end of input, then fail.
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ ❝.
］：
◎
Set next character to the character in input pointed to by position, and this time advance position to the next character. (If next character was a U+002E FULL STOP character (.) before, it will still be that character this time.)
◎
If next character is a U+002E FULL STOP character (.), then run these substeps:
</p>

				<ol>
					<li>
%位置 ~INCBY 1
</li>
					<li>
%s ~LET ［
`~ASCII数字$からなる`文字~並びを収集-$した結果
］
◎
Collect a sequence of characters that are ASCII digits. Let s be the resulting sequence.
</li>
					<li>
~IF［
%s ~EQ 空~文字列
］
⇒
~RET ε
◎
If s is the empty string, then fail.
</li>
					<li>
%N ~INCBY ( `Base10$( %s ) ÷ `Power10$( %s の文字~数 ) )
◎
Let length be the number of characters in s.
◎
Let fraction be the result of interpreting s as a base-ten integer, and then dividing that number by 10length.
◎
Increment N by fraction.
</li>
					<li>
`空白を読飛ばす$
◎
Skip whitespace.
</li>
					<li>
%s ~SET %位置↗
</li>
					<li>
%位置 ~INCBY 1
</li>
					<li>
~IF［
%s ~NIN { ❝S, ❝s }
］
⇒
~RET ε
◎
If position is past the end of input, then fail.
◎
Set next character to the character in input pointed to by position, and advance position to the next character.
◎
If next character is neither a U+0053 LATIN CAPITAL LETTER S character nor a U+0073 LATIN SMALL LETTER S character, then fail.
</li>
					<li>
%単位 ~SET `秒t^i
◎
Set units to seconds.
</li>
				</ol>

			</li>
			<li>
<p>
~ELSE：
◎
Otherwise, run these substeps:
</p>

				<ol>
					<li>
`空白を読飛ばす$
◎
If next character is a space character, then skip whitespace, set next character to the character in input pointed to by position, and advance position to the next character.
</li>
					<li>
<p>
( %単位, %縮尺, %M一義化子 ) ~SET 
%位置↗ に応じて，次の表で与えられる値：
</p>

<table>
<thead><tr><th>%位置↗
</th><th>%単位
</th><th>%縮尺
</th><th>%M一義化子
</th></tr></thead>

<tbody><tr><td>❝Y, ❝y
</td><td>`年t^i
</td><td>ε
</td><td>`月t^i

</td></tr><tr><td>❝M, ❝m
</td><td>%M一義化子
</td><td>60
</td><td>%M一義化子

</td></tr><tr><td>❝W, ❝w
</td><td>`週t^i
</td><td>604800
</td><td>`分t^i

</td></tr><tr><td>❝D, ❝d
</td><td>`日t^i
</td><td>86400
</td><td>`分t^i

</td></tr><tr><td>❝H, ❝h
</td><td>`時t^i
</td><td>3600
</td><td>`分t^i

</td></tr><tr><td>❝S, ❝s
</td><td>`秒t^i
</td><td>1
</td><td>`分t^i

</td></tr><tr><td>その他
</td><td>ε
</td><td>ε
</td><td>ε

</td></tr></tbody></table>

◎
If next character is a U+0059 LATIN CAPITAL LETTER Y character, or a U+0079 LATIN SMALL LETTER Y character, set units to years and set M-disambiguator to months.
◎
If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and M-disambiguator is months, then set units to months.
◎
If next character is a U+0057 LATIN CAPITAL LETTER W character or a U+0077 LATIN SMALL LETTER W character, set units to weeks and set M-disambiguator to minutes.
◎
If next character is a U+0044 LATIN CAPITAL LETTER D character or a U+0064 LATIN SMALL LETTER D character, set units to days and set M-disambiguator to minutes.
◎
If next character is a U+0048 LATIN CAPITAL LETTER H character or a U+0068 LATIN SMALL LETTER H character, set units to hours and set M-disambiguator to minutes.
◎
If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and M-disambiguator is minutes, then set units to minutes.
◎
If next character is a U+0053 LATIN CAPITAL LETTER S character or a U+0073 LATIN SMALL LETTER S character, set units to seconds and set M-disambiguator to minutes.
</li>
					<li>
%位置 ~INCBY 1
◎
↑</li>
					<li>
~IF［
%単位 ~EQ ε
］
⇒
~RET ε
◎
Otherwise if next character is none of the above characters, then fail.
</li>
				</ol>
			</li>
			<li>
%空 ~SET ~F
◎
Increment component count.
</li>
			<li>
<p>
%単位 に応じて：
</p>

<dl class="switch">
	<dt>`年t^i</dt>
	<dd>
%月t数 ~INCBY %N × 12
</dd>

	<dt>`月t^i</dt>
	<dd>
%月t数 ~INCBY %N
</dd>

	<dt>その他</dt>
	<dd>
%秒t数 ~INCBY %N × %縮尺
</dd>
</dl>

◎
Let multiplier be 1.
◎
If units is years, multiply multiplier by 12 and set units to months.
◎
If units is months, add the product of N and multiplier to months.
◎
Otherwise, run these substeps:
• If units is weeks, multiply multiplier by 7 and set units to days.
• If units is days, multiply multiplier by 24 and set units to hours.
• If units is hours, multiply multiplier by 60 and set units to minutes.
• If units is minutes, multiply multiplier by 60 and set units to seconds.
• Forcibly, units is now seconds. Add the product of N and multiplier to seconds.
</li>
			<li>
`空白を読飛ばす$
◎
Skip whitespace.
</li>
		</ol>
	</li>
	<li>
~IF［
%空 ~EQ ~T
］
⇒
~RET ε
◎
If component count is zero, fail.
</li>
	<li>
~IF［
%月t数 ~NEQ 0
］
⇒
~RET ε
◎
If months is not zero, fail.
</li>
	<li>
~RET `時間長$( %秒t数 )
◎
Return the duration consisting of seconds seconds.
</li>
</ol>


				</section>
				<section id="vaguer-moments-in-time">
<h4 title="Vaguer moments in time">2.3.5.10. 漠然とした時刻</h4>

<p>
次のいずれかの文字列は
`妥当な省略あり日時~文字列@
とされる：
◎
A string is a valid date string with optional time if it is also one of the following:
</p>

<ul>
	<li>
`妥当な日付~文字列$
◎
A valid date string
</li>
	<li>
`妥当な大域的~日時~文字列$
◎
A valid global date and time string
</li></ul>


<hr>

<p class="algo-head">
所与の %入力 を
`省略あり日時~文字列として構文解析-@
する規則は、［
`日付$, `時刻$, `大域的~日時$, ε
］のいずれかを返す：
◎
The rules to parse a date or time string are as follows. The algorithm will return either a date, a time, a global date and time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している~pointer
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%開始-位置- ~SET %位置 と同じ位置
◎
Set start position to the same position as position.
</li>
	<li>
%時刻 ~LET ε
◎
Set the date present and time present flags to true.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析-$した結果
◎
Parse a date component to obtain year, month, and day. If this fails, then set the date present flag to false.
</li>
	<li>
<p>
~IF［
%日付 ~EQ ε
］~OR［
%位置↗ ~IN { ❝T, ~SPACE }
］：
</p>
		<ol>
			<li>
~IF［
%日付 ~EQ ε
］
⇒
%位置 ~SET %開始-位置
</li>
			<li>
~ELSE
⇒
%位置 ~INCBY 1
</li>
			<li>
%時刻 ~LET `時刻~成分を構文解析-$した結果
</li>
			<li>
~IF［
%時刻 ~EQ ε
］
⇒
~RET ε
</li>
		</ol>
◎
If date present is true, and position is not beyond the end of input, and the character at position is either a U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character, then advance position to the next character in input.
◎
Otherwise, if date present is true, and either position is beyond the end of input or the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then set time present to false.
◎
Otherwise, if date present is false, set position back to the same position as start position.
◎
If the time present flag is true, then parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.
</li>
	<li>
<p>
~IF［
%日付 ~NEQ ε
~AND
%時刻 ~NEQ ε
］：
</p>
		<ol>
			<li>
%偏差 ~LET `偏差~成分を構文解析-$した結果
</li>
			<li>
~IF［
%偏差 ~EQ ε
］
⇒
~RET ε
</li>
		</ol>
◎
If the date present and time present flags are both true, but position is beyond the end of input, then fail.
◎
If the date present and time present flags are both true, parse a time-zone offset component to obtain timezonehours and timezoneminutes. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~IF［
%時刻 ~EQ ε
］
⇒
~RET %日付
◎
If the date present flag is true and the time present flag is false, then let date be the date with year year, month month, and day day, and return date.
</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET %時刻
◎
Otherwise, if the time present flag is true and the date present flag is false, then let time be the time with hour hour, minute minute, and second second, and return time.
</li>
	<li>
( %日付, %時刻 ) ~LET ( %日付, %時刻 ) から %偏差 を減算した結果
◎
↓</li>
	<li>
~RET `日時$( %日付, %時刻, %偏差 )
◎
Otherwise, let time be the moment in time at year year, month month, day day, hours hour, minute minute, second second, subtracting timezonehours hours and timezoneminutes minutes, that moment in time being a moment in the UTC time zone; let timezone be timezonehours hours and timezoneminutes minutes from UTC; and return time and timezone.
</li>
</ol>



				</section>
			</section>

</main>


