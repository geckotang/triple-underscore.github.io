<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Encoding Standard — 符号化方式 標準（日本語訳）</title>
<meta name="keywords" content="文字符号化,符号化,エンコーディング,標準,仕様,WHATWG">

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://encoding.spec.whatwg.org/',
		main: 'MAIN',
		alt_refs: 'references',
		ref_id_prefix: 'refs'
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked 160331 spec.

	return options;
}


function expand(mapping1){

	var link_map = this.link_map;
	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[~\w\-一-鿆]+|([`@$][\^!@$%]?)([~\w\-\.:]+)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN');

function create_html(t, t0, key){

	if(!t0) {
		switch(t[0]){
		case '%':
			return '<var>' + t.slice(1) + '</var>';
		case '⇒':
			nesting += '<\/span>';
			return  '：<span class="block">';
		}
		var result = nesting + '<span lang="en">' + t.slice(1) + '<\/span>';
		nesting = '';
		return result;
	}

	switch(t0){
	case '`':
		return '<code>' + key + '</code>';
	case '`%':
		return '"<code class="label">' + key + '</code>"';
	case '`!': // IDL object model property
		return '<b class="coder">' + key.replace(/\-/g, ' ') + '</b>';
	case '`^': // literal 定数
		return '"<code class="literal">' + key + '</code>"';
	case '$!': // 各種リソース
		return '<a href="https://encoding.spec.whatwg.org/' +
			key + '">' + key + '</a>';
	}

	var text = link_map[key] || key;
//	if(!text) return t;

	switch(t0){
	case '`$':
	case '$':
		t = '<a href="#' + key + '">' + text + '</a>';
		break;
//	case '%@':
	case '`@':
	case '@':
		t = '<dfn id="' + key + '">' + text + '</dfn>';
		break;
	default:
		return t;
	}

	switch(t0.charAt(0)){
	case '`':
		return '<code>' + t + '</code>';
	}
	return t;
}

}

</script>


<!--% 置換データ -->

<script type="text/plain" id="words_table1">
BR:；<br>
FAIL:<i>failure</i>
TA:http://www.khronos.org/registry/typedarray/specs/latest/
Assert:<b>Assert</b>
</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">
byte:~byte
ascii-byte:ASCII ~byte
code-point:~cp
scalar-value:~scalar値
string:文字列
ascii-code-point:ASCII ~cp
ascii-whitespace:ASCII 空白類
ascii-digits:ASCII 数字
ascii-case-insensitive:ASCII 文字大小無視
ascii-lowercase:ASCII 小文字化
encoding:~encoding
name:名前
label:~label
decoder:~decoder
decode:~decode
utf-8-decode:UTF-8 ~decode
utf-8-decode-without-bom:BOM を取扱わずに UTF-8 ~decode
utf-8-decode-without-bom-or-fail:BOM も失敗も取扱わずに UTF-8 ~decode
utf-8-encode:UTF-8 ~encode
encode:~encode
encoder:~encoder
handler:~handler
error-mode:~error~mode
error:~error
finished:完遂
continue:継続
end-of-stream:~EoS

concept-encoding-get:~encodingを取得
get-an-output-encoding:出力~encodingを取得
concept-token:~token
concept-stream:~stream
concept-stream-read:読取った結果
concept-stream-prepend:挿込む
concept-stream-push:押込む
concept-encoding-run:走らす
concept-encoding-process:処理
concept-td-serialize:直列化-
concept-te-serialize:直列化-

index:索引
index-code-point:索引~cp
index-pointer:索引~pointer
index-big5-pointer:索引 Big5 ~pointer
index-big5:索引 Big5
index-euc-kr:索引 EUC-KR
index-jis0208:索引 jis0208
index-jis0212:索引 jis0212
index-shift_jis-pointer:索引 Shift_JIS ~pointer
index-gb18030-ranges:索引 gb18030 範囲集
index-gb18030-ranges-code-point:索引 gb18030 範囲集 ~cp
index-gb18030-ranges-pointer:索引 gb18030 範囲集~pointer

index-gb18030:索引 gb18030

utf-8-code-point:UTF-8 ~cp
utf-8-bytes-seen:UTF-8 出現~byte数
utf-8-bytes-needed:UTF-8 要~byte数
utf-8-lower-boundary:UTF-8 下限
utf-8-upper-boundary:UTF-8 上限

single-byte-encoding:単byte~encoding
index-single-byte:単byte索引


	●名前＊
utf-8:UTF-8
ibm866:IBM866
iso-8859-2:ISO-8859-2
iso-8859-3:ISO-8859-3
iso-8859-4:ISO-8859-4
iso-8859-5:ISO-8859-5
iso-8859-6:ISO-8859-6
iso-8859-7:ISO-8859-7
iso-8859-8:ISO-8859-8
iso-8859-8-i:ISO-8859-8-I
iso-8859-10:ISO-8859-10
iso-8859-13:ISO-8859-13
iso-8859-14:ISO-8859-14
iso-8859-15:ISO-8859-15
iso-8859-16:ISO-8859-16
koi8-r:KOI8-R
koi8-u:KOI8-U
macintosh:macintosh
windows-874:windows-874
windows-1250:windows-1250
windows-1251:windows-1251
windows-1252:windows-1252
windows-1253:windows-1253
windows-1254:windows-1254
windows-1255:windows-1255
windows-1256:windows-1256
windows-1257:windows-1257
windows-1258:windows-1258
x-mac-cyrillic:x-mac-cyrillic
gbk:GBK
gb18030:gb18030
big5:Big5
euc-jp:EUC-JP
iso-2022-jp:ISO-2022-JP
shift_jis:Shift_JIS
euc-kr:EUC-KR
replacement:~replacement
utf-16le:UTF-16LE
utf-16be:UTF-16BE
x-user-defined:x-user-defined


	●

utf-8-decoder:UTF-8 ~decoder
utf-8-encoder:UTF-8 ~encoder
shared-utf-16-decoder:共用 UTF-16 ~decoder
replacement-decoder:~replacement~decoder
replacement-error-returned-flag:~replacementによる~errorはすでに返した~flag

single-byte-decoder:単byte~decoder
single-byte-encoder:単byte~encoder

gbk-flag:GBK ~flag

gb18030-first:gb1
gb18030-second:gb2
gb18030-third:gb3
gb18030-decoder:gb18030 ~decoder
gb18030-encoder:gb18030 ~encoder

big5-lead:Big5 ~lead
big5-decoder:Big5 ~decoder
big5-encoder:Big5 ~encoder

euc-jp-lead:EUC-JP ~lead
euc-jp-jis0212-flag:EUC-JP jis0212 ~flag
euc-jp-decoder:EUC-JP ~decoder
euc-jp-encoder:EUC-JP ~encoder

iso-2022-jp-decoder:ISO-2022-JP ~decoder
iso-2022-jp-encoder:ISO-2022-JP ~encoder

iso-2022-jp-decoder-state:ISO-2022-JP ~decoder状態
iso-2022-jp-decoder-output-state:ISO-2022-JP ~decoder出力~状態
iso-2022-jp-lead:ISO-2022-JP ~lead
iso-2022-jp-output-flag:ISO-2022-JP 出力~flag

iso-2022-jp-decoder-ascii:<i>ASCII</i>
iso-2022-jp-decoder-roman:<i>Roman</i>
iso-2022-jp-decoder-katakana:<i>Katakana</i>
iso-2022-jp-decoder-lead-byte:<i>~lead~byte</i>
iso-2022-jp-decoder-trail-byte:<i>~trail~byte</i>
iso-2022-jp-decoder-escape-start:<i>~escape開始</i>
iso-2022-jp-decoder-escape:<i>~escape</i>

iso-2022-jp-encoder-state:ISO-2022-JP ~encoder状態
iso-2022-jp-encoder-ascii:<i>ASCII</i>
iso-2022-jp-encoder-roman:<i>Roman</i>
iso-2022-jp-encoder-jis0208:<i>jis0208</i>

shift_jis-lead:Shift_JIS ~lead
shift_jis-decoder:Shift_JIS ~decoder
shift_jis-encoder:Shift_JIS ~encoder

euc-kr-lead:EUC-KR ~lead
euc-kr-decoder:EUC-KR ~decoder
euc-kr-encoder:EUC-KR ~encoder

utf-16-lead-byte:UTF-16 ~lead~byte
utf-16-lead-surrogate:UTF-16 ~lead~surrogate
utf-16-decoder:UTF-16 ~decoder
utf-16le-decoder:UTF-16LE ~decoder
utf-16be-decoder:UTF-16BE ~decoder
utf-16be-decoder-flag:UTF-16BE ~decoder~flag

x-user-defined-decoder:x-user-defined ~decoder
x-user-defined-encoder:x-user-defined ~encoder

convert-a-code-unit-to-bytes:~byte列に変換

textdecoderoptions:TextDecoderOptions
textdecodeoptions:TextDecodeOptions
textdecoder:TextDecoder
textencodeoptions:TextEncodeOptions
textencoder:TextEncoder

dom-textdecoder:TextDecoder
dom-textdecoder-encoding:encoding
dom-textdecoder-fatal:fatal
dom-textdecoder-ignorebom:ignoreBOM

dom-textdecoder-decode:decode
dom-textencoder:TextEncoder
dom-textencoder-encoding:encoding
dom-textencoder-encode:encode

</script>

<!-- ＊廃
	shared-utf-16-encoder:共用 UTF-16 ~encoder
	replacement-encoder:~replacement~encoder
	utf-16-encoder:UTF-16 ~encoder
	utf-16le-encoder:UTF-16LE ~encoder
	utf-16be-encoder:UTF-16BE ~encoder
	utf-16be-encoder-flag:UTF-16BE ~encoder~flag

-->

<!--% 語彙置換データ 
英数_, または漢字のみ
-->
<script type="text/plain" id="words_table">

	●仕様
algo:algorithm::アルゴリズム
手続き:steps:~
段:step:~
UA:user agent:UA::ユーザエージェント
利用者:user:~
利用-:use:~
利用:use:~
利用中の:in use の:~
技術的には:technical には:形の上では
波及-:influence:~
意図的:intentional:~
意図-:intend:~
排他的:exclusive:~
既存の:existing:~
作者:author:~
歴史的:historical:~
規範的:normative:~
	規範的でない:non-normative:~
	参考:non-normative
統一的:universal:~
適切:appropriate:~
提供-:provide:~
提供0-:offer:提供
収束:converge:~
相互運用可能:interoperable:~
互換性:compatibility:~
互換:compatible:~
理由:reason:~
究明:investigation:~
末端利用者:end user:~
特色機能:feature:~
可能化-:enable:~
不能化-:disable:~
課題:issue:~
報告:report:~
問題:problem:~
違法:illegal:~
解釈:interpretation:~
非互換:incompatible:~
未知の:unknown:~
明示的:explicit:~
自明:trivial:~
制御:control:~
拘束:constraints:~
拘束-:constrain:~
単純:simple:~
制約的:restrictive:~
奨励:encourage:~
	促す
拡散-:spread:~
網羅的:exhaustive:~
逸脱-:deviate:~
判別-:distinguish:~
開発者:developer:~
共通の:common:~
基盤:infrastructure:~
義務付けら:mandate さ:~
要件:requirements:~
要求-:require:~
有意:significant:~
取組む:address する:取り組む
概して:typical には:~
保守的:conservative:~
合法:legitimate:~
移行-:move:~
重要:important:~
特別な:special:~
完全さ:completeness:~
仕組み:mechanism:~
事例:case:~
適合性:conformance:~
適合性の:conformance:~
処理能:performance:~
制限-:limit:~
制限:limitations:~
各種用語:terminology:~
働く:work する:~
意味論:semantics:~
旧来の:legacy:~
標準:standard:~
拡張-:extend:~
拡張:extension:~
既定:default:~
fallback:::フォールバック
無関係:irrelevant:関係ない
仕様:spec:~
実装-:implement:~
実装:implementation:~
定義-:define:~
定義:definition:~
未定義:undefined:~
省略可:optional:~
文脈:context:~
browser:::ブラウザ
proprietary:::プロプライエタリ
platform:::プラットフォーム
リバースエンジニア:reverse engineer:~
security:::セキュリティ
効率的:efficient:~
最適化-:optimize:~
依存-:depend:~
公開-:expose:~
共用:shared::~
共有-:share:~
流布-:deploy:~
配備済みの:deployed:~
許可-:permit:~
除外-:exclude:~
除外:exclusion:~
生産側:producer:生産側
生産-:produce:生産
消費側:consumer:~
消費者:consumer:~
背景:background:~
誘発-:trigger:~
違反:violation:~
有用:useful:~
取扱い:handling:取り扱い
取扱わず:handle せず:取り扱わず
取扱う:handle する:取り扱う
強く:strong に:~
仕方:way:~
特定の:specific:~
特有の:-specific:~
簡明:clear:~
要旨した:outline した:要旨を述べた
隔たり:gap:~
詳細:details:~
進行中:ongoing:~
霧消-:go away:~
自前の:own:~
過去:past:~

	●network／保安
protocol:::プロトコル
server:::サーバ
client:::クライアント
資源:resource::リソース
form:::フォーム
submission:::送信
手入力:enter:~
攻撃:attack:~
攻撃者:attacker:~
防止-:prevent:~
防ぐ:prevent する:~
注入-:inject:~
注意深く:careful に:~
細工:craft:~
情報喪失:information loss:~
安全:safe:~
上書き:override:~
合意:agree:~
不一致:mismatch:~
交換:interchange:~
隠す:mask する:~
隠せな:mask できな:~

	●
obj:object::オブジェクト
method::メソッド
interface::インタフェース
構築子:constructor::~:コンストラクタ
属性:attribute:~
取得子:getter:~
取得:get:~
設定子:setter:~
被呼出時:被 invoke 時:~
投出:throw:~
member:::メンバ

結果:result:~

呼出して:invoke して:呼び出して
呼出す:invoke する:呼び出す
呼出時:invoke 時:呼び出し時
	invocation
list:::リスト
support:::サポート
table:::テーブル
entry:::エントリ

byte:::バイト
単byte:single-byte::単バイト:シングルバイト
複byte:multi-byte::複バイト:マルチバイト
surrogate:::サロゲート
scalar:::スカラー
flag:::フラグ
cp:code point::符号位置:コードポイント
cu:code unit::符号単位:コードユニット
encode:::符号化:エンコード
encoding:::符号化方式:エンコーディング
encoder:encoder::符号化器:エンコーダ
decode:::復号:デコード
decoder:::復号器:デコーダ
label:::ラベル
索引:index::~:インデックス
index:::索引:インデックス
pointer:::ポインタ
error:::エラー
正準的:canonical::~
名前:name::~
下限:lower boundary::~
上限:upper boundary::~
offset:
token:::トークン
stream:::ストリーム
streaming:::ストリーム処理
no_flush:do not flush:状態維持
EoS:end-of-stream::ストリーム終端
utf-16be:

状態:state::~:ステート
escape:escape 
lead:::頭部
trail:::尾部
	頭部と尾部:leading and trailing
handler:::ハンドラ
instance:::インスタンス
mode:::モード
継続:continue::~
完遂:finished::~
実行:execution:~
走らす:run する:走らせる
走らせ:run し:~
所与の:given:与えられた
返す:return する:~
返さ:return し:~
返され:return され:~
返した:return した:~
繰返:繰り返
読取れる:read できる:読み取れる
読取る:read する:読み取る
読取られ:read され:読み取られ
読取った:read した:読み取った
	読取結果:読み取った結果
押込む:に push する::の末尾に付加する:にプッシュする
挿込む:に prepend する::の先頭に挿入する:にプリペンドする
付加-:append:~
挿入-:insert:~

構文解析:parsing::~:パース処理
直列化-:serialize::~:シリアライズ
処理:process::~
処理器:processor::~:プロセッサ
coder:
入力:input:~
出力:output:~
output:::出力
	~~出力:emit
	~output
	%input
	%入力
BOMseen:BOM seen:BOM 確認済み
BOMignore:ignore BOM:BOM 無視
replacement:
	fatal:
	失敗＊fail／failure

BOM:byte order mark::バイト順マーク
合致-:match:~

形式:format::データ形式:フォーマット
簡体字:simplified:~
繁体字:traditional:~
文字列:string:~
文字:character:~
小文字化:lowercase 化:~
内容:content:~
範囲集:ranges:~
空白類:whitespace:~
文字大小無視:case-insensitive:~
数字:digit:~
layout:::レイアウト
literal:::リテラル
data:::データ
bit:::ビット
shift:::シフト
hook:::フック
buffer:::バッファ
option:::オプション
script:::スクリプト
field:::フィールド

論理:logical:~
断片化:fragment 化:~
対応関係:mapping:~
対応付ける:map する:~
対応付けて:map して:~
対応付けら:map さ:~

範囲:range:~
範囲検査:limit check:~
変換:convert:~
区画:area:~
複製:copy:~

表現-:represent:~
表現:representation:~
一意:unique:~
一覧:table:~
値:value:~
	〜が返す値:〜の return value
配列:array:~
識別-:identify:~
除去-:remove:~
	算術式:equation:~
前置-:prefix:~
重複-:duplicate:~
順序:order:~
有順序:ordered:~
分割:split:~
設定-:set:~
符号化文字集合:coded character set:~
加算:addition:~
減算:subtraction:~
乗算:multiplication:~
除算:division:~
剰余:remainder:~
開始:start:~
包含-:contain:~
生成-:generate:~
区切子:delimiter:~
結付けら:associate さ:結び付けら
新たな:new:~
見出す:find する:~
見出され:find され:~

整数:integer:~
基数:base:~
終了-:terminate:~
初期:initial:~
単独の:single:~

保全-:preserve:~
往来-:roundtrip:~
header:::ヘッダ

正確:exact:~
正確a:accurate:正確
等価:equivalent:~
精度:precision:~
置換-:replace:~
包装-:wrap:~
引数:argument:~
方向:direction:~
最初の:first:~
最後の:last:~
全体的な:overall:~
参照-:reference:~
存在-:exist:~
在する:present する:在る
	伴われない no 〜 present

</script>

<!--%他の語

全くの:fully
別名:alias:~
~~検知されることなく:silent
~~標準の:The
~~考慮
ある程度:some extent
より小さい:less than
一つ
一
一式で:in combination with
一新-:set anew:~
一方
一致-
より~~一般的には:larger
一連の
一部
万
上
下
下位:least significant
下記
不要
与え
並び
中
主に
今や
他
他の
その他の:miscellaneous
以上
以下
以外
任意選択
伴-
何か
何も
何らか
使い切り
例
例えば
供-
促す
保護
個
個数
備える
備考
優先される:has priority over／more authoritative
元の
先の
先頭
入らない
入る
入手できる:available
内
冒頭
出現~byte数:byte seen
列:sequence
列目
別
則って
前
前の
前述の:aforementioned
加え
化
化-
~~十分:fine
取り
可読性:readability:~
右／左シフト
右辺
左辺
各
各種
各行を
合致-
同じ
含まれ
含められ
含んで
周知の:known:
呼び
呼ぶ
回
回避
図式
埋める
場合
場所
壊す
変わって
変化:changes
変更:change
変換-
外字
多くの
失わせ
対:combination
対し／対する
対処-:deal with
対応-:corresponding
対象
少なくとも:at least
尾部の:trailing
属する
常に
年
広く:widespread
序:Preface
後は
後続の:subsequent／later
後者
得られ
得る
必要:necessary／need／
応じて
意味
意味-
成立-
戻す:back
扱い:dealing with
括弧内
持つ
指-
挙げ-
数
数値:number
方
時
最も
最初
最大の
最短:shortest
最終的:the end
有-
有無
末尾
桁:digit:~
様に
次
次の
次回
比較comparing
決して
法
注記
済む
準ずる
演算
点で
無い
無けれ
片
特に
	用い
番目
異な
的
相互
省略-:without
知られ:known／
示され
私用領域
種の
空
空いた:newly-vacated
空行:empty string 1
突く:abuse
等
等々と続く:and so on
等しい
算術式:equations
節
終える
組
統合ハングルコード
総数
至らせ
若干の:slight
若干:slighty
行:row／line
行-
表
表す
表記
表記規約
被
被せた:Layering 〜  on top
複数
要
要-
見えない
見かけ上:superficially
見よ
記され
記す
該当-
語
説明:Notes
超え
	追い易く:easy to follow
追加
逆方向:vice versa
進数
進~表記
部分
長さ:length:~
間
関-
限らない
除いて／除き／除く
際し
非
面
項
項目数
頭部の:leading
香港増補字符集
メモリ:
にもかかわらず~nonetheless
あいにく:unfortunately
レイアウト
かつての:former
推奨され

	●訳注
参照
参照先
代入
代用対
含意-
固有の
保持-
内部状態
出現-
初期化
制約されることが
区点番号
参考
大小比較
大文字:uppercase
実行制御
所属
数値的
数字列
日付
時系列的
有効
構造
機能
正規化され
特有
~~符号位置
符号点
範囲
見なせる
角括弧
記号
記法
記述
記述され
訳
訳者
訳語
試す
課-:impose
識別子
集合
静的
変数

-->

<!--% style -->

<style>
#encoding-labels td + td {
	white-space: pre;
	white-space: pre-line;
}


.algo {
	color:#404;
	font-style: italic;
}

i {
	color: #808;
}
.coder {
	color: maroon;
	font-family: serif0, serif;
}

.label {
	color: #666;
}

code > dfn {
	color: inherit;
}

</style>

</head>

<body>

<!--%UI -->
<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">

<h1>Encoding Standard 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/" >WHATWG</a>
による，副題の日付の
<a href="https://encoding.spec.whatwg.org/" >Encoding Standard</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-07-29</time>
（公開： <time>2012-10-22</time>）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxwYXRoIGQ9Im01MCwwbDUwLDUwLTUwLDUwLTUwLTUwIiBmaWxsPSIjM2M3OTBhIi8+DQo8cGF0aCBkPSJtMzgsNDBjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iI2ZmZiIvPg0KPC9zdmc+DQo="
></a>


<h1>Encoding — 符号化方式</h1>
<h2>Living Standard — 最終更新 2016 年 7 月 29 日</h2>

<dl>
	<dt>Participate:</dt>
	<dd>
<a href="https://github.com/whatwg/encoding">GitHub whatwg/encoding</a>
(<a href="https://github.com/whatwg/encoding/issues/new">file an issue</a>,
<a href="https://github.com/whatwg/encoding/issues">open issues</a>)</dd>
	<dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/encoding/commits">GitHub whatwg/encoding/commits</a></dd>
	<dd><a href="https://twitter.com/encodings">@encodings</a></dd>

	<dt>各国語翻訳（非規範的）</dt>
	<dd>日本語（このページ）</dd>

</dl>


</header>


<nav class="toc" id="table-of-contents">
<h2 title="Table of Contents">目次</h2>
<ol id="_toc_list"></ol>

<ol><li><a href="#references">参照文献</a></li><li
><a href="#acknowledgments">謝辞</a></li></ol>
</nav>


<main id="MAIN" style="display:none;">

	<section id="preface">

<h2 title="Preface">1. 序</h2>

<p>
UTF-8 ~encodingは、統一的な符号化文字集合である Unicode の交換に最も適切な~encodingである。
よって，この仕様は、新たな［
~protocolと形式
］, および［
新たな文脈~下で流布される既存の形式
］に対し、 UTF-8 ~encodingを要求する（また，定義する）。
◎
The UTF-8 encoding is the most appropriate encoding for interchange of Unicode, the universal coded character set. Therefore for new protocols and formats, as well as existing formats deployed in new contexts, this specification requires (and defines) the UTF-8 encoding.
</p>

<p>
~encodingには，他のもの（旧来の~encoding）もあり，過去にある程度までは定義されているが、~UA間で常に同じように実装されているとは限らない。
また、常に同じ~labelを利用してるわけでもなく、~encodingの中の未定義の区画, あるいは かつての~proprietaryな区画についての扱いも，しばしば異なっている。
この仕様は、新たな実装が~encoding実装をリバースエンジニアせずに済むように，また, 既存の~UAが一つに収束し得るようにするため、これらの隔たりを埋めることに取組む。
◎
The other (legacy) encodings have been defined to some extent in the past. However, user agents have not always implemented them in the same way, have not always used the same labels, and often differ in dealing with undefined and former proprietary areas of encodings. This specification addresses those gaps so that new user agents do not have to reverse engineer encoding implementations and existing user agents can converge.
</p>

<p>
特に，この仕様は、それらの~encodingと，そのそれぞれにおける［
~byte列と$scalar-value 列を相互に変換する~algo
］, および［
一連の$labelを識別する正準的な名前
］を定義する。
また、~encodingの各種~algoのうち一部を JavaScript に公開する API も定義する。
◎
In particular, this specification defines all those encodings, their algorithms to go from bytes to scalar values and back, and their canonical names and identifying labels. This specification also defines an API to expose part of the encoding algorithms to JavaScript.
</p>

<p>
~UAは，すでに
<a href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">IANA Character Sets registry</a>
に挙げられている~labelからも 有意に逸脱している。
旧来の~encodingを これ以上~拡散させないため、この仕様は，前述の詳細について網羅的であり， registry はもう不要である。
特に、この仕様は，~encodingを拡張するための仕組みは提供しない。
◎
User agents have also significantly deviated from the labels listed in the IANA Character Sets registry. To stop spreading legacy encodings further, this specification is exhaustive about the aforementioned details and therefore has no need for the registry. In particular, this specification does not provide a mechanism for extending any aspect of encodings.
</p>

	</section>
	<section id="security-background">

<h2 title="Security background">2. ~securityに関する背景</h2>

<p>
~encodingには、いくつかの~security上の課題がある
— 生産側と消費側の間で，［
利用中の~encoding, あるいは所与の~encodingの実装-法
］について合意されてないときに。
例えば 2011 年には、次のような攻撃が報告されている：
そこでは、［
攻撃者が何らかの~fieldを制御し得るような， JSON 資源
］内の 0x22 ~trail~byteを “隠す” ために，$shift_jis の~lead~byte 0x82 が利用された。
生産側からは，これが違法な~byte対であっても問題が見えない一方で、消費側では，この~byte対を単独の U+FFFD として~decodeする~~結果、全体的な解釈が変わってしまう — U+0022 は重要な区切子なので。
［
$scalar-valueに対し複数~byteを利用する~encoding
］の~decoderには、今や，違法な~byte対の事例では，［
範囲 U+0000 〜 U+007F に入る~scalar値
］を “隠せない” ようにすることが要求される
— 前述の~byte対に対しては、出力が［
U+FFFD U+0022
］になるように。
◎
There is a set of encoding security issues when the producer and consumer do not agree on the encoding in use, or on the way a given encoding is to be implemented. For instance, an attack was reported in 2011 where a Shift_JIS lead byte 0x82 was used to “mask” a 0x22 trail byte in a JSON resource of which an attacker could control some field. The producer did not see the problem even though this is an illegal byte combination. The consumer decoded it as a single U+FFFD and therefore changed the overall interpretation as U+0022 is an important delimiter. Decoders of encodings that use multiple bytes for scalar values now require that in case of an illegal byte combination, a scalar value in the range U+0000 to U+007F, inclusive, cannot be “masked”. For the aforementioned sequence the output would be U+FFFD U+0022.
</p>

<p>
これは、より~~一般的には，［
~lead~byteが伴われないときに，$ascii-byteを$ascii-code-pointでない何かに対応付ける
］ような~encodingにおける課題である。
これらは， “ASCII 非互換” の~encodingであり、あいにく，すでに流布された内容のために要求されるが、［
$iso-2022-jp, $utf-16be, $utf-16le
］以外のものは，~supportされない。
（その種の 他の~encoding$labelについても、未知の~encodingへ~fallbackせずに，$replacement ~encodingに対応付けてよいかどうかの究明が
<a href="https://github.com/whatwg/encoding/issues/8" title="Add more labels to the replacement encoding">進行中にある</a>
。）
攻撃の一~例として、注意深く細工された内容を資源の中へ注入して，利用者に~encodingを上書きするよう促す~~結果、例えば~scriptの実行に至らせるものがある。
◎
This is a larger issue for encodings that map anything that is an ASCII byte to something that is not an ASCII code point, when there is no lead byte present. These are “ASCII-incompatible” encodings and other than ISO-2022-JP, UTF-16BE, and UTF-16LE, which are unfortunately required due to deployed content, they are not supported. (Investigation is ongoing whether more labels of other such encodings can be mapped to the replacement encoding, rather than the unknown encoding fallback.) An example attack is injecting carefully crafted content into a resource and then encouraging the user to override the encoding, resulting in e.g. script execution. 
</p>

<p>
HTML や HTML の~form特色機能に見出される URL に利用される~encoderも、すべての~scalar値を表現できない~encodingが利用されるときに，若干の情報喪失につながり得る。
例えば，資源が $windows-1252 ~encodingを利用しているとき、~serverは，末端利用者が~formに手入力した “&#128169;” と “&amp;#128169;” とを判別できなくなる。
◎
Encoders used by URLs found in HTML and HTML's form feature can also result in slight information loss when an encoding is used that cannot represent all scalar values. E.g. when a resource uses the windows-1252 encoding a server will not be able to distinguish between an end user entering “&#128169;” and “&amp;#128169;” into a form.
</p>

<p>
ここに要旨した問題は、 UTF-8 を排他的に利用しているときは，霧消する。
それが、今やすべてに対し UTF-8 ~encodingが義務付けられている理由の一つである。
◎
The problems outlined here go away when exclusively using UTF-8, which is one of the many reasons that is now the mandatory encoding for all things.
</p>

<p class="note">注記：
<a href="#browser-ui">~browser UI</a> 節も見よ。
◎
See also the Browser UI chapter.
</p>

	</section>
	<section id="conformance">

<h2 title="Conformance">3. 適合性</h2>

<p>
明示的に参考（規範的でない）と記された節に加え，この仕様におけるすべての図式, 例, 注記は規範的ではない。
他のすべては規範的である。
◎
All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
</p>

<p>
この仕様の規範的~部分におけるキーワード：
「〜しなければ（〜しては）<em class="rfc2119">ならない</em>」 = “MUST (NOT)”,
「<em class="rfc2119">要求される</em>」= REQUIRED,
「〜す<em class="rfc2119">べき</em>である（でない）」 = “SHOULD (NOT)”,
「<em class="rfc2119" title="recommended">推奨される</em>」 = “RECOMMENDED”,
「〜しても<em class="rfc2119">よい</em>」 = “MAY”,
「<em class="rfc2119" title="optional">任意選択</em> 」 = “OPTIONAL”,
は、 RFC 2119 に則って解釈されるものとする。
可読性のため，この仕様ではこれらの語が大文字で出現することはない。
<a href="#refsRFC2119">[RFC2119]</a>
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in RFC2119. For readability, these words do not appear in all uppercase letters in this specification. [RFC2119]
</p>

<p>
~algoまたは特定の手続きとして記される適合性の要件は、最終的な結果が等価になるならば，どのように実装されてもよい。
（特に、この仕様で定義される~algoは追い易くなるように記述されており，処理能は~~考慮されていない。）
◎
Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant.)
</p>
<p id="hardwareLimitations">
~UA は拘束が課されていない入力に実装~特有の制限-を課してもよい。
例えば、 DoS 攻撃の防止-, メモリ使い切りに抗する~~保護, ~platform特有の制限の回避など。
◎
User agents may impose implementation-specific limits on otherwise unconstrained inputs, e.g. to prevent denial of service attacks, to guard against running out of memory, or to work around platform-specific limitations.
</p>

	</section>
	<section id="terminology">

<h2 title="Terminology">4. 各種用語</h2>

<p>
16 進数には "0x" が前置される。
◎
Hexadecimal numbers are prefixed with "0x".
</p>

<div class="p">
<p>
算術式の中のすべての数値は整数であり、各種~演算は次の記号で表現される：
</p>

<!-- 
PLUS:
MINUS:
MUL:
DIV:
MOD:
-->

<table>
<thead><tr><th>記号
</th><th>意味
</th></tr></thead>

<tbody><tr><th>+
</th><td>加算

</td></tr><tr><th>−
</th><td>減算

</td></tr><tr><th>~INCBY
</th><td>左辺~値に対する右辺~値による加算

</td></tr><tr><th>~DECBY
</th><td>左辺~値に対する右辺~値による減算

</td></tr><tr><th>×
</th><td>乗算

</td></tr><tr><th>÷
</th><td>除算

</td></tr><tr><th>%
</th><td>除算の剰余（ modulo ）

</td></tr><tr><th>&lt;&lt;
</th><td>論理~左~shift

</td></tr><tr><th>&gt;&gt;
</th><td>論理~右~shift

</td></tr><tr><th>&amp;
</th><td>~bit AND

</td></tr><tr><th>|
</th><td>~bit OR

</td></tr><tr><th>floor( %x )
</th><td>%x を超えない最大の整数

</td></tr></tbody></table>

<p class="trans-note">【
記号 ~INCBY, ~DECBY は訳者による追加。
】</p>

◎
In equations, all numbers are integers, addition is represented by "+", subtraction by "−", multiplication by "×", division by "/", calculating the remainder of a division (also known as modulo) by "%", logical left shifts by "&lt;&lt;", logical right shifts by "&gt;&gt;", bitwise AND by "&amp;", and bitwise OR by "|". floor(x) is the largest integer not greater than x.
</div>

<p>
論理~右~shiftの演算~対象の精度は、少なくとも 21 ~bit以上で~MUST。
◎
For logical right shifts operands must have at least twenty-one bits precision.
</p>

<p>
@byte
は 8 個の~bitの並びであり、 2 桁の 16 進数で表現される，範囲 { 0x00 〜 0xFF } に入る数をとる。
◎
A byte is a sequence of eight bits, represented as a double-digit hexadecimal number in the range 0x00 to 0xFF, inclusive.
</p>

<p>
@ascii-byte
は、範囲 { 0x00 〜 0x7F } に入る$byteである。
◎
An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive. 
</p>

<p>
@code-point
は Unicode ~cpであり， 4 〜 6 桁の 16 進数で表現される。
概して "U+" が前置されるが、算術式や$indexの中では "0x" が前置される。
<a href="#refsUNICODE">[UNICODE]</a>
◎
A code point is a Unicode code point and is represented as a four-to-six digit hexadecimal number, typically prefixed with "U+". In equations and indexes code points are prefixed with "0x". [UNICODE]
</p>

<p class="trans-note">【
範囲は 0x0 〜 0x10FFFF
】【
訳語の “~~符号位置（ code point ）” は Unicode 特有であり，他の~encodingの “符号点” に該当する。
】</p>

<p>
@scalar-value
とは、範囲
{ U+D800 〜 U+DFFF }
に入らない
<span class="trans-note">【すなわち，代用対（ surrogate ）を除く】</span>
$code-pointである。
◎
A scalar value is a code point that is not in the range U+D800 to U+DFFF, inclusive.
</p>

<p>
@ascii-code-point
とは、範囲
{ U+0000 〜 U+007F }
に入る~cpである。
◎
An ASCII code point is a code point in the range U+0000 to U+007F, inclusive.
</p>

<p>
@ascii-whitespace
とは、範囲
{ U+0009, U+000A, U+000C, +U+000D, U+0020 }
に入る~cpである。
◎
The ASCII whitespace are code points U+0009, U+000A, U+000C, U+000D, and U+0020.
</p>

<p>
@ascii-digits
とは、範囲
{ U+0030 〜 U+0039 }
に入る~cpである。
◎
The ASCII digits are code points in the range U+0030 to U+0039, inclusive.
</p>

<p>
@string
とは、~cpの並びである。
◎
A string is a sequence of code points.
</p>

<p>
２つの文字列の
@ascii-case-insensitive
による比較とは、
{ U+0041 〜 U+005A }
（すなわち LATIN CAPITAL LETTER A 〜 LATIN CAPITAL LETTER Z ）の範囲の文字と対応する
{ U+0061 〜 U+007A }
（すなわち LATIN SMALL LETTER A 〜 LATIN SMALL LETTER Z ）の範囲の文字は合致させることを除き、それぞれの文字の~cpごとに正確に比較することを意味する。
◎
Comparing two strings in an ASCII case-insensitive manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z), inclusive, and the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z), inclusive, are considered to also match.
</p>

<p>
文字列を
@ascii-lowercase
するときは、範囲
{ U+0041 〜 U+005A }
に入るすべての~cpのそれぞれを，対応する範囲
{ U+0061 〜 U+007A }
に入る~cpに置換する。
◎
To ASCII lowercase a string, replace all code points in the range U+0041 to U+005A, inclusive, with the corresponding code points in the range U+0061 to U+007A, inclusive.
</p>

<hr>

<p>
@concept-token
は、$byteや$code-pointなどの， 1 個の~data片である。
◎
A token is a piece of data, such as a byte or code point.
</p>

<p>
@concept-stream
は、有順序$concept-token列を表現する。
@end-of-stream
は、$concept-streamが空である（それ以上 読取れる$concept-tokenが無い）ことを意味する，特別な$concept-tokenである。
◎
A stream represents an ordered sequence of tokens. End-of-stream is a special token that signifies no more tokens are in the stream.
</p>

<p class="trans-note">【
~streamと~token列は（ “静的な” ）~data構造としては同じでも，
 “~stream” には，そのアクセスが
先頭（入力として与えられた場合）／末尾（出力~先の場合）
に（ “時系列的に” ）制約されることが含意される。
】</p>

<div class="algo-head">
<p>
$concept-streamから$concept-tokenを
<dfn id="concept-stream-read">読取る</dfn>
ときは、次を走らせ~MUST：
</p>
<ol>
	<li>
~IF［
~streamは空である
］
⇒
~RET $end-of-stream
</li>
	<li>
~streamの先頭から 1 個の~tokenを除去する
</li>
	<li>
~RET 前~段で除去した~token
</li>
</ol>

<!-- this means read is blocking on e.g. networking activity;
     SimonSapin thinks this is fine, curse him if not -->
◎
When a token is read from a stream, the first token in the stream must be returned and subsequently removed, and end-of-stream must be returned otherwise.
</div>

<p>
1 個~以上の$concept-tokenを$concept-stream
@concept-stream-prepend
ときは、それらの~tokenを，~streamの先頭に, 所与の順序で挿入し~MUST。
◎
When one or more tokens are prepended to a stream, those tokens must be inserted, in given order, before the first token in the stream.
</p>

<p class="example">
~token列 "<code>&amp;#128169;</code>" を~stream "<code> hello world</code>" の先頭に挿入した結果は，~stream "<code>&amp;#128169; hello world</code>" になり、次回に読取られる~tokenは <code>&amp;</code> になる。
<!-- 💩 --><!-- #x1F4A9 = 128169 decimal -->
◎
Inserting the sequence of tokens &amp;#128169; in a stream " hello world", results in a stream "&amp;#128169; hello world". The next token to be read would be &amp;.
</p>

<p>
1 個~以上の$concept-tokenを$concept-stream
@concept-stream-push
ときは、それらの~tokenを，~streamの末尾に, 所与の順序で付加し~MUST。
◎
When one or more tokens are pushed to a stream, those tokens must be inserted, in given order, after the last token in the stream.
</p>



	</section>

	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳では，アルゴリズムの記述に次の記号を用いる：
</p>

<div style="margin-left:2em">
~LET （初期化-）, ~SET （代入）, ~ON, ~OFF （~flag値）,<br />
~EQ, ~NEQ （比較）, ~LT, ~GT, ~LTE, ~GTE （大小比較）,<br />
〜 （~~範囲）, { <var>…</var> } （集合）, ~IN, ~NIN （集合への所属）,<br />
~IF, ~ELSE, ~WHILE, ~RET, ~THROW（実行制御）
</div>

<p>
これらの意味や定義の詳細は，~SYMBOL_DEF_REFを参照。
加えて、次の記法も用いられる：
</p>


<table><thead><tr><th style="min-width: 10em;">記法
</th><th >意味
</th></tr></thead>

<tbody>
<tr><th style="white-space:nowrap;">~byte列 [ %value1, %value2, … ]
</th><td><p>
数値的に %value1, %value2 … と同じ値をとる一連の$byteからなる, 所与の順序による，新たな$concept-token列の~instanceを意味する。
角括弧の中が空
— “~byte列 [] ” —
と記されたときは，空の$concept-token列を意味する。
</p></td></tr>

<tr><th style="white-space:nowrap;">~cp [ %value ]
</th><td><p>
数値的に %value と同じ値をとる 1 個の$code-pointからなる，新たな$concept-token列の~instanceを意味する。
</p></td></tr>

</tbody></table>


	</section>
	<section id="encodings">

<h2 title="Encodings">5. ~encoding</h2>



<p>
@encoding
は、$scalar-value 列から~byte列への対応関係
<span class="trans-note">【~encode】</span>,
および逆方向への対応関係
<span class="trans-note">【~decode】</span>
を定義する。
それぞれの$encodingには、
@name
および， 1 個~以上の
@label
が<a href="#encoding-labels">あてがわれている</a>。
◎
An encoding defines a mapping from a scalar value sequence to a byte sequence (and vice versa). Each encoding has a name, and one or more labels.
</p>

		<section id="encoders-and-decoders">
<h3 title="Encoders and decoders">5.1. ~encoderと~decoder</h3>

<div class="p">
<p>
各種 $encodingには、
@decoder
と
@encoder
が結付けられる。
各 $decoder ／ 各 $encoderには、
@handler
が結付けられる。
$handlerは、
( $concept-stream, 1 個の$concept-token )
を入力にとり，次のいずれかを返す~algoである：
</p>

<ul>
 <li>@finished</li>
 <li>
<p>
空でない$concept-token列
</p>

<p class="trans-note">【
ほとんどの~decoderの~handlerは， 1 個の~cpからなる~token列を返すが、
$big5-decoderの~handlerだけ， 2 個の~cpを返す場合がある。
】</p>
 </li>

 <li>
<p>
~optionで$code-pointも伴い得る，@error
</p>
<p class="trans-note">【
~encoderの~handlerのみが、常に，~cpも伴う~errorを返す。
】</p>
 </li>
 <li>@continue</li>
</ul>

◎
Each encoding has an associated decoder and most of them have an associated encoder. Each decoder and encoder have a handler algorithm. A handler algorithm takes an input stream and a token, and returns finished, one or more tokens, error optionally with a code point, or continue.
</div>


<p class="note">注記：
［
$replacement, $utf-16be, $utf-16le
］$encodingには、$encoderはない。
◎
The replacement, UTF-16BE, and UTF-16LE encodings have no encoder.
</p>


<div class="p">

<p>
@error-mode
は、以下で用いられる様に：
</p>

<ul>
 <li>
$decoderに対しては，［
`^replacement（既定）,
`^fatal
］のいずれかをとる。
</li>

 <li>
$encoderに対しては，［
`^fatal（既定） ,
`^html
］のいずれかをとる。
</li>

</ul>

◎
An error mode as used below is "replacement" (default) or "fatal" for a decoder and "fatal" (default) or "html" for an encoder.
</div>

<p class="note">注記：
XML 処理器は、その$decoderの$error-modeを `^fatal に設定することになる。
<a href="#refsXML">[XML]</a>
◎
An XML processor would set error mode to "fatal". [XML]
</p>

<p class="note">注記：
$error-modeに `^html が存在する理由は、
URL や HTML form においては，$errorに際し旧来の$encoderを終了させないようにする取扱いを要するためである。
`^html $error-modeは、合法な入力と判別できない列を~~出力させ，~~検知されることなく~dataを失わせる。
これを防ぐため、開発者には $utf-8 $encodingの利用が強く奨励される。
<a href="#refsURL">[URL]</a>
<a href="#refsHTML">[HTML]</a>
◎
"html" exists as error mode due to URLs and HTML forms requiring a non-terminating legacy encoder. The "html" error mode causes a sequence to be emitted that cannot be distinguished from legitimate input and can therefore lead to silent data loss. Developers are strongly encouraged to use the UTF-8 encoding to prevent this from happening. [URL] [HTML]
</p>

<div class="algo-head">
<p>
次が与えられた下で：
</p>

<ul ><li>入力$concept-stream : %入力
</li><li>出力$concept-stream : %出力
</li><li>$error-mode : %~mode （省略可）
</li></ul>

<p>
$encodingの［
$decoder ／ $encoder
］ %~coder を
@concept-encoding-run
ときは、次を走らす：
</p>
◎
To run an encoding's decoder or encoder encoderDecoder with input stream input, output stream output, and optional error mode mode, run these steps:
</div>

<ol>
 <li>
~IF［
%~mode は与えられていない
］
⇒
%~mode ~SET %~coder に応じて
⇒
$decoderであるならば `^replacement ~BR
$encoderであるならば `^fatal
◎
If mode is not given, set it to "replacement", if encoderDecoder is a decoder, and "fatal" otherwise.
</li>

 <li>
%~coder~instance ~LET 新たな %~coder の~instance
◎
Let encoderDecoderInstance be a new encoderDecoder.
</li>

 <li>
<p>
~WHILE ( true )
◎
While true:
</p>

  <ol>
   <li>
%結果 ~LET
( %~coder~instance, %入力, %出力, %~mode )
を与える下で，［
%入力 から$concept-stream-read
］を$concept-encoding-processした結果
◎
Let result be the result of processing the result of reading from input for encoderDecoderInstance, input, output, and mode.
</li>

   <li>
~IF［
%結果 ~NEQ $continue
］
⇒
~RET %結果
◎
If result is not continue, return result.
◎
Otherwise, do nothing. 
</li>
  </ol>
</ol>

<div class="algo-head">
<p>
次が与えられた下で：
</p>

<ul><li>$encodingの［
$encoder／$decoder
］の~instance : %~coder~instance
</li><li>
入力$concept-stream : %入力
</li><li>
出力$concept-stream : %出力
</li><li>
$error-mode : %~mode（省略可）
</li></ul>

<p>
$concept-token %~token を
@concept-encoding-process
するときは、次を走らす：
</p>
◎
To process a token token for an encoding's encoder or decoder instance encoderDecoderInstance, stream input, output stream output, and optional error mode mode, run these steps:
</div>

<ol>
 <li>
~IF［
%~mode は与えられていない
］
⇒
%~mode ~SET %~coder~instance に応じて
⇒
$decoderの~instanceであるならば `^replacement ~BR
$encoderの~instanceであるならば `^fatal
◎
If mode is not given, set it to "replacement", if encoderDecoderInstance is a decoder instance, and "fatal" otherwise.
</li>

 <li>
%結果 ~LET
( %入力, %~token )
に対し， %~coder~instance による$handlerを走らせた結果
◎
Let result be the result of running encoderDecoderInstance's handler on input and token.
</li>

 <li>
~IF［
%結果 ~IN { $continue, $finished }
］
⇒
~RET %結果
◎
If result is continue or finished, return result.
</li>

 <li>
~IF［
%結果 に 1 個~以上の$concept-tokenがある
］
⇒
%結果 を %出力 $concept-stream-push
◎
Otherwise, if result is one or more tokens, push result to output.
</li>

 <li>
<p>
~ELIF［
%結果 ~EQ $error
］
⇒
%~mode に応じて：
◎
Otherwise, if result is error, switch on mode and run the associated steps:
</p>

  <dl class="switch">
   <dt>`^replacement</dt>
   <dd>
U+FFFD を %出力 $concept-stream-push
◎
Push U+FFFD to output.
</dd>

   <dt>`^html</dt>
   <dd>
~cp列［
U+0026, U+0023, ［
%結果 の$code-pointを基数 10 により最短で表現する$ascii-digits列
］, U+003B
］
<span class="trans-note">【 "<code>&amp;#<var>数字列</var>;</code>" 】</span>
を
%入力 $concept-stream-prepend
◎
Prepend U+0026, U+0023, followed by the shortest sequence of ASCII digits representing result's code point in base ten, followed by U+003B to input.
</dd>

   <dt>`^fatal</dt>
   <dd>
~RET $error
◎
Return error.
</dd>
  </dl>
 </li>

 <li>
~RET $continue
◎
Return continue.
</li>

</ol>



		</section>
		<section id="names-and-labels">

<h3 title="Names and labels">5.2. 名前と~label</h3>

<p>
下の一覧に、~UAが~supportし~MUST，すべての$encodingとそれらの$labelを挙げる。
~UA は、他の$encodingや$labelを~supportしては~MUST_NOT。
◎
The table below lists all encodings and their labels user agents must support. User agents must not support any other encodings or labels.
</p>

<p>
作者は、 $utf-8 $encodingを利用した上で，その利用が識別されるように［
$ascii-case-insensitive で `%utf-8 に~~合致する$label
］を利用し~MUST。
◎
Authors must use the UTF-8 encoding and must use the ASCII case-insensitive "utf-8" label to identify it.
</p>

<p>
新たな［
~protocolと形式
］, あるいは［
新たな文脈~下で流布される既存の形式
］には、 $utf-8 $encodingが排他的に利用され~MUST。
これらの［
~protocolや形式
］の$encodingの［
$nameや$label
］は、 `%utf-8 として公開され~MUST。
◎
New protocols and formats, as well as existing formats deployed in new contexts, must use the UTF-8 encoding exclusively. If these protocols and formats need to expose the encoding's name or label, they must expose it as "utf-8".
</p>

<p class="algo-head">
文字列 %~label から
@concept-encoding-get
するときは、次を走らす：
◎
To get an encoding from a string label, run these steps:
</p>

<ol>
 <li>
%~label から頭部と尾部の$ascii-whitespaceを除去する
◎
Remove any leading and trailing ASCII whitespace from label.
</li>

 <li>
~IF［
%~label が下の一覧のいずれかの$labelに$ascii-case-insensitiveで合致する
］
⇒
~RET 合致した$labelに対応する$encoding
◎
If label is an ASCII case-insensitive match for any of the labels listed in the table below, return the corresponding encoding, and failure otherwise.
</li>

 <li>
~RET ~FAIL
◎
↑</li>

</ol>

<p class="note">注記：
配備済みの内容と互換にする必要から、この［
$labelを$encodingに対応付ける~algo
］は，
<a href="http://www.unicode.org/reports/tr22/tr22-7.html#Charset_Alias_Matching">Unicode Technical Standard #22, 1.4 節</a>
によるものよりもずっと単純かつ制約的なものである。
◎
This is a much simpler and more restrictive algorithm of mapping labels to encodings than section 1.4 of Unicode Technical Standard #22 prescribes, as that is found to be necessary to be compatible with deployed content.
</p>

<table id="encoding-labels">
 <thead>
  <tr><th>$name◎Name</th><th>$label◎Labels</th></tr>
 </thead>
 <tbody>

  <tr><th colspan="2"><a href="#the-encoding">~~標準の~encoding</a>◎The Encoding</th></tr>

  <tr><td>$utf-8</td><td
>`%unicode-1-1-utf-8
`%utf-8
`%utf8</td></tr>
 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-single-byte-encodings">旧来の単byte~encoding</a>◎Legacy single-byte encodings</th></tr>

  <tr><td>$ibm866</td><td
>`%866
`%cp866
`%csibm866
`%ibm866</td></tr>

  <tr><td>$iso-8859-2</td><td
>`%csisolatin2
`%iso-8859-2
`%iso-ir-101
`%iso8859-2
`%iso88592
`%iso_8859-2
`%iso_8859-2:1987
`%l2
`%latin2</td></tr>

  <tr><td>$iso-8859-3</td><td
>`%csisolatin3
`%iso-8859-3
`%iso-ir-109
`%iso8859-3
`%iso88593
`%iso_8859-3
`%iso_8859-3:1988
`%l3
`%latin3</td></tr>

  <tr><td>$iso-8859-4</td><td
>`%csisolatin4
`%iso-8859-4
`%iso-ir-110
`%iso8859-4
`%iso88594
`%iso_8859-4
`%iso_8859-4:1988
`%l4
`%latin4</td></tr>

  <tr><td>$iso-8859-5</td><td
>`%csisolatincyrillic
`%cyrillic
`%iso-8859-5
`%iso-ir-144
`%iso8859-5
`%iso88595
`%iso_8859-5
`%iso_8859-5:1988</td></tr>

  <tr><td>$iso-8859-6</td><td
>`%arabic
`%asmo-708
`%csiso88596e
`%csiso88596i
`%csisolatinarabic
`%ecma-114
`%iso-8859-6
`%iso-8859-6-e
`%iso-8859-6-i
`%iso-ir-127
`%iso8859-6
`%iso88596
`%iso_8859-6
`%iso_8859-6:1987</td></tr>

  <tr><td>$iso-8859-7</td><td
>`%csisolatingreek
`%ecma-118
`%elot_928
`%greek
`%greek8
`%iso-8859-7
`%iso-ir-126
`%iso8859-7
`%iso88597
`%iso_8859-7
`%iso_8859-7:1987
`%sun_eu_greek</td></tr>

  <tr><td>$iso-8859-8</td><td
>`%csiso88598e
`%csisolatinhebrew
`%hebrew
`%iso-8859-8
`%iso-8859-8-e
`%iso-ir-138
`%iso8859-8
`%iso88598
`%iso_8859-8
`%iso_8859-8:1988
`%visual</td></tr>

  <tr><td>$iso-8859-8-i</td><td
>`%csiso88598i
`%iso-8859-8-i
`%logical</td></tr>

  <tr><td>$iso-8859-10</td><td
>`%csisolatin6
`%iso-8859-10
`%iso-ir-157
`%iso8859-10
`%iso885910
`%l6
`%latin6</td></tr>

  <tr><td>$iso-8859-13</td><td
>`%iso-8859-13
`%iso8859-13
`%iso885913</td></tr>

  <tr><td>$iso-8859-14</td><td
>`%iso-8859-14
`%iso8859-14
`%iso885914</td></tr>

  <tr><td>$iso-8859-15</td><td
>`%csisolatin9
`%iso-8859-15
`%iso8859-15
`%iso885915
`%iso_8859-15
`%l9</td></tr>

  <tr><td>$iso-8859-16</td><td
>`%iso-8859-16</td></tr>

  <tr><td>$koi8-r</td><td
>`%cskoi8r
`%koi
`%koi8
`%koi8-r
`%koi8_r</td></tr>

  <tr><td>$koi8-u</td><td
>`%koi8-ru
`%koi8-u</td></tr>

  <tr><td>$macintosh</td><td
>`%csmacintosh
`%mac
`%macintosh
`%x-mac-roman</td></tr>

  <tr><td>$windows-874</td><td
>`%dos-874
`%iso-8859-11
`%iso8859-11
`%iso885911
`%tis-620
`%windows-874</td></tr>

  <tr><td>$windows-1250</td><td
>`%cp1250
`%windows-1250
`%x-cp1250</td></tr>

  <tr><td>$windows-1251</td><td
>`%cp1251
`%windows-1251
`%x-cp1251</td></tr>

  <tr><td>$windows-1252</td><td
>`%ansi_x3.4-1968
`%ascii
`%cp1252
`%cp819
`%csisolatin1
`%ibm819
`%iso-8859-1
`%iso-ir-100
`%iso8859-1
`%iso88591
`%iso_8859-1
`%iso_8859-1:1987
`%l1
`%latin1
`%us-ascii
`%windows-1252
`%x-cp1252</td></tr>

  <tr><td>$windows-1253</td><td
>`%cp1253
`%windows-1253
`%x-cp1253</td></tr>

  <tr><td>$windows-1254</td><td
>`%cp1254
`%csisolatin5
`%iso-8859-9
`%iso-ir-148
`%iso8859-9
`%iso88599
`%iso_8859-9
`%iso_8859-9:1989
`%l5
`%latin5
`%windows-1254
`%x-cp1254</td></tr>

  <tr><td>$windows-1255</td><td
>`%cp1255
`%windows-1255
`%x-cp1255</td></tr>

  <tr><td>$windows-1256</td><td
>`%cp1256
`%windows-1256
`%x-cp1256</td></tr>

  <tr><td>$windows-1257</td><td
>`%cp1257
`%windows-1257
`%x-cp1257</td></tr>

  <tr><td>$windows-1258</td><td
>`%cp1258
`%windows-1258
`%x-cp1258</td></tr>

  <tr><td>$x-mac-cyrillic</td><td
>`%x-mac-cyrillic
`%x-mac-ukrainian</td></tr>
 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-multi-byte-chinese-(simplified)-encodings">旧来の複byte Chinese （簡体字） ~encoding</a>◎Legacy multi-byte Chinese (simplified) encodings</th></tr>

  <tr><td>$gbk</td><td
>`%chinese
`%csgb2312
`%csiso58gb231280
`%gb2312
`%gb_2312
`%gb_2312-80
`%gbk
`%iso-ir-58
`%x-gbk</td></tr>

  <tr><td>$gb18030</td><td
>`%gb18030
</td></tr>
 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-multi-byte-chinese-(traditional)-encodings">旧来の複byte Chinese （繁体字）~encoding</a>◎Legacy multi-byte Chinese (traditional) encodings</th></tr>

  <tr><td>$big5</td><td
>`%big5
`%big5-hkscs
`%cn-big5
`%csbig5
`%x-x-big5</td></tr>
 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-multi-byte-japanese-encodings">旧来の複byte Japanese ~encoding</a>◎Legacy multi-byte Japanese encodings</th></tr>

  <tr><td>$euc-jp</td><td
>`%cseucpkdfmtjapanese
`%euc-jp
`%x-euc-jp</td></tr>

  <tr><td>$iso-2022-jp</td><td
>`%csiso2022jp
`%iso-2022-jp</td></tr>

  <tr><td>$shift_jis</td><td
>`%csshiftjis
`%ms932
`%ms_kanji
`%shift-jis
`%shift_jis
`%sjis
`%windows-31j
`%x-sjis</td></tr>
 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-multi-byte-korean-encodings">旧来の複byte Korean ~encoding</a>◎Legacy multi-byte Korean encodings</th></tr>

  <tr><td>$euc-kr</td><td
>`%cseuckr
`%csksc56011987
`%euc-kr
`%iso-ir-149
`%korean
`%ks_c_5601-1987
`%ks_c_5601-1989
`%ksc5601
`%ksc_5601
`%windows-949</td></tr>

 </tbody><tbody>

  <tr><th colspan="2"><a href="#legacy-miscellaneous-encodings">旧来のその他の~encoding</a>◎Legacy miscellaneous encodings</th></tr>
  <tr><td>$replacement</td><td
>`%csiso2022kr
`%hz-gb-2312
`%iso-2022-cn
`%iso-2022-cn-ext
`%iso-2022-kr</td></tr>

  <tr><td>$utf-16be</td><td
>`%utf-16be</td></tr>

  <tr><td>$utf-16le</td><td
>`%utf-16
`%utf-16le</td></tr>

  <tr><td>$x-user-defined</td><td
>`%x-user-defined</td></tr>
 </tbody>
</table>

<p class="note">注記：
すべての$encodingとそれらの$labelは、規範的でない資源
$!encodings.json
からも入手できる。
◎
All encodings and their labels are also available as non-normative encodings.json resource.
</p>

<p class="trans-note">【
名前は正規化された~labelと見なせる —
“replacement” を除く上の一覧のどの名前も，~labelとして有効になる（小文字化した結果は，対応する~labelの集合に含まれている）。
】</p>

		</section>
		<section id="output-encodings">

<h3 title="Output encodings">5.3 出力~encoding</h3>

<p>
$encoding %~encoding から
@get-an-output-encoding
するときは、次を走らす：
◎
To get an output encoding from an encoding encoding, run these steps:
</p>

<ol>
 <li>
~IF［
%~encoding ~IN
{ $replacement, $utf-16be, $utf-16le }
］
⇒
~RET $utf-8
◎
If encoding is replacement, UTF-16BE, or UTF-16LE, return UTF-8.
</li>

 <li>
~RET %~encoding
◎
Return encoding.
</li>
</ol>

<p class="note">注記：
$get-an-output-encodingする~algoは、それを必要とする［
URL の構文解析 ／ HTML ~form~submission
］にて有用になる。
◎
The get an output encoding algorithm is useful for URL parsing and HTML form submission, which both need exactly this.
</p>

		</section>
	</section>
	<section id="indexes">

<h2 title="Indexes">6. 索引</h2>

<p>
ほとんどの旧来の$encodingでは、
<span class="trans-note">【~encodingごとに固有の】</span>
@index
が利用される。
$indexとは、一連の~entryからなる有順序~listであり、各~entryは［
~pointerと, それに対応する~cp
］からなる組である。
$indexの中では、~pointerは一意であり，~cpは重複し得る。
◎
Most legacy encodings make use of an index. An index is an ordered list of entries, each entry consisting of a pointer and a corresponding code point. Within an index pointers are unique and code points can be duplicated.
</p>

<p class="note">注記：
効率的な実装は、$encodingごとに，その$decoderと$encoderのそれぞれに最適化された， 2 つの$indexを備えることになるであろう。
◎
An efficient implementation likely has two indexes per encoding. One optimized for its decoder and one for its encoder.
</p>

<div class="p">

<p class="algo-head">
$index
<span class="trans-note">【の~dataを供する下記の資源】</span>
から，~pointerとそれに対応する~cpを見出すためには：
</p>

<ol >
	<li>
まず、 %lines をその資源の内容を U+000A で一連の “行” に分割した結果とする。
</li>
	<li>
空行や, U+0023 で開始される行は， %lines から除去する。
</li>
	<li>
%lines の各~行を U+0009 で分割したときの、最初の項が~pointer（ 10 進表記）であり，２番目の項が対応する~cp（ 16 進表記）になる。
他の項は無関係。
</li>
</ol>

◎
To find the pointers and their corresponding code points in an index, let lines be the result of splitting the resource's contents on U+000A. Then remove each item in lines that is the empty string or starts with U+0023. Then the pointers and their corresponding code points are found by splitting each item in lines on U+0009. The first subitem is the pointer (as a decimal number) and the second is the corresponding code point (as a hexadecimal number). Other subitems are not relevant.
</div>

<p class="note">注記：
各$indexの冒頭には、変更の有無を記すため，
<i>Identifier</i> と <i>Date</i>
<span class="trans-note">【識別子と日付】</span>
が記されている。
<i>Identifier</i> の変化は、$indexに変更が加えられたことを表す。
◎
To signify changes an index includes an Identifier and a Date. If an Identifier has changed, so has the index.
</p>

<p>
%索引 の中で %~pointer が指す
@index-code-point
とは、
%索引 内に %~pointer が［
在るならば，それに対応する~cp ／
無ければ ~NULL
］である。
◎
The index code point for pointer in index is the code point corresponding to pointer in index, or null if pointer is not in index.
</p>

<p>
%索引 の中で %~cp を指す
@index-pointer
とは、
%索引 内に %~cp に対応する~pointerが［
在るならば，それらのうちの <em>最初の</em> ~pointer ／
無ければ ~NULL
］である。
◎
The index pointer for code point in index is the first pointer corresponding to code point in index, or null if code point is not in index.
</p>

<p>
以下は、$index-single-byteは除外した，この仕様で定義される$indexであり，それぞれに自前の~tableがある：
◎
These are the indexes defined by this specification, excluding index single-byte, which have their own table:
</p>

<table id="_index_list">
<col style="min-width:8em;"/>
<col style="min-width:9em;"/>
<col/>

<thead><tr><th>$index
</th><th>参照先
</th><th>備考
</th></tr></thead>

<tbody><tr><td>@index-big5
</td><td>$!index-big5.txt
</td><td>
これは、香港増補字符集（ Hong Kong Supplementary Character Set ）, および他の共通の拡張と一式で、
Big5 標準に合致する。
◎
This matches the Big5 standard in combination with the Hong Kong Supplementary Character Set and other common extensions.

</td></tr><tr><td>@index-euc-kr
</td><td>$!index-euc-kr.txt
</td><td>
これは Windows Codepage 949 としてより広く知られている，
KS X 1001 標準と 統合ハングルコード（ Unified Hangul Code ）に合致する。
◎
This matches the KS X 1001 standard and the Unified Hangul Code, more commonly known together as Windows Codepage 949.

</td></tr><tr><td>@index-gb18030
</td><td>$!index-gb18030.txt
</td><td>
これは、［
配備済みの内容と互換にする必要から， 0xA3 0xA0 は U+3000 に対応付けられる
］ことを除いて、各~cpが 2 ~byteに~encodeされる GB18030-2005 標準に合致する。
  <!-- https://bugzilla.mozilla.org/show_bug.cgi?id=131837
       https://bugs.webkit.org/show_bug.cgi?id=17014
       https://www.w3.org/Bugs/Public/show_bug.cgi?id=25396
       https://github.com/whatwg/encoding/issues/17 -->
◎
This matches the GB18030-2005 standard for code points encoded as two bytes, except for 0xA3 0xA0 which maps to U+3000 to be compatible with deployed content.

</td></tr><tr><td>@index-gb18030-ranges
</td><td>$!index-gb18030-ranges.txt
</td><td>
この$indexは、すべての~cpを挙げていくと項目数が 100 万を超えてしまう点で，他のすべてと異なる（ 207 面の範囲と自明な範囲検査により，きれいに表現し得るが）。
したがって、 4 ~byte に~encodeされる~cpについてのみ，見かけ上 GB18030-2005 標準に合致する。
下の［
$index-gb18030-ranges-code-point ／
$index-gb18030-ranges-pointer
］も見よ。
◎
This index works different from all others. Listing all code points would result in over a million items whereas they can be represented neatly in 207 ranges combined with trivial limit checks. It therefore only superficially matches the GB18030-2005 standard for code points encoded as four bytes. See also index gb18030 ranges code point and index gb18030 ranges pointer below.

</td></tr><tr><td>@index-jis0208
</td><td>$!index-jis0208.txt
</td><td>
IBM と NEC によるかつての~proprietary拡張も含まれている， JIS X 0208 標準。
◎
This is the JIS X 0208 standard including formerly proprietary extensions from IBM and NEC.
<!-- NEC = Nippon Electronics Corporation -->

</td></tr><tr><td>@index-jis0212
</td><td>$!index-jis0212.txt
</td><td>
JIS X 0212 標準。
これは、広く~supportされていないので，$euc-jp-decoderでのみ利用される（~encoderからは利用されない）。
◎
This is the JIS X 0212 standard. It is only used by the EUC-JP decoder due to lack of widespread support elsewhere.
  <!--
   No JIX X 0212 euc-jp encoder support:
     https://bugzilla.mozilla.org/show_bug.cgi?id=600715
     https://code.google.com/p/chromium/issues/detail?id=78847

   No JIX X 0212 iso-2022-jp support:
     https://www.w3.org/Bugs/Public/show_bug.cgi?id=26885
  -->

</td></tr></tbody></table>


<p class="algo-head">
%~pointer が指す
@index-gb18030-ranges-code-point
は、次の手続きが返す~cpである：
◎
The index gb18030 ranges code point for pointer is the return value of these steps:
</p>

<ol>
 <li>
~IF［
39419 ~LT %~pointer ~LT 189000
］~OR［
1237575 ~LT %~pointer
］
⇒
~RET ~NULL
◎
If pointer is greater than 39419 and less than 189000, or pointer is greater than 1237575, return null.
</li>

 <li>
~IF［
%~pointer ~EQ 7457
］
⇒
~RET ~cp [ U+E7C7 ]
◎
If pointer is 7457, return code point U+E7C7. 
</li>

 <li>
%~offset ~LET $index-gb18030-ranges の中で %~pointer を超えない最後の~pointer ◎
Let offset be the last pointer in index gb18030 ranges that is equal to or less than pointer and let code point offset be its corresponding code point.
</li>

 <li>
%~cp~offset ~LET %~offset が指している~cp
◎
↑</li>

 <li>
~RET 値が［
%~cp~offset + %~pointer − %~offset
］なる~cp
◎
Return a code point whose value is code point offset + pointer − offset.
</li>
</ol>

<p class="algo-head">
%~cp を指す
@index-gb18030-ranges-pointer
は、次の手続きが返す~pointerである：
◎
The index gb18030 ranges pointer for code point is the return value of these steps:
</p>

<ol>
 <li>
%~offset ~LET $index-gb18030-ranges の中で %~cp を超えない最後の~cp
◎
Let offset be the last code point in index gb18030 ranges that is equal to or less than code point and let pointer offset be its corresponding pointer.
</li>

 <li>
%~pointer~offset ~LET %~offset に対応する~pointer
◎
↑</li>

 <li>
~RET 値が［
%~pointer~offset + %~cp − %~offset
］なる~pointer
◎
Return a pointer whose value is pointer offset + code point − offset.
</li>
</ol>

<p class="algo-head">
%~cp を指す
@index-shift_jis-pointer
は、次の手続きが返す~pointerである：
◎
The index Shift_JIS pointer for code point is the return value of these steps:
</p>

<ol>
 <li>
<p>
%索引 ~LET $index-jis0208 から，［
~pointerが範囲 { 8272 〜 8835 } に入る~entry
］すべてを除外した索引
◎
Let index be index jis0208 excluding all entries whose pointer is in the range 8272 to 8835, inclusive.
</p>
 <!-- selected NEC duplicates from IBM extensions later in the index; need to use IBM
      extensions when going back to bytes -->

<p class="note">
$index-jis0208は、重複する~cpを包含するので、これらの~entryの除外により，後続の~cpが利用されるようになる。
◎
The index jis0208 contains duplicate code points so the exclusion of these entries causes later code points to be used.
</p>
 </li>

 <li>
~RET %索引 の中で %~cp を指す$index-pointer
◎
Return the index pointer for code point in index.
</li>
</ol>

<p class="algo-head">
%~cp を指す
@index-big5-pointer
は、次の手続きが返す~pointerである：
◎
The index Big5 pointer for code point is the return value of these steps:
</p>


<ol>
 <li>
<p>
%索引 ~LET $index-big5から［
~pointerが (0xA1 − 0x81) × 157 より小さい~entry
］すべてを除外した索引
◎
Let index be index Big5 excluding all entries whose pointer is less than (0xA1 - 0x81) × 157. 
</p>

<p class="note">注記：
香港増補字符集（ Hong Kong Supplementary Character Set ）拡張を~literalとして返さないようにする。
◎
Avoid returning Hong Kong Supplementary Character Set extensions literally.
</p>
 </li>

 <li>
<p >~IF［
%~cp ~IN 
{ U+2550, U+255E, U+2561, U+256A, U+5341, U+5345 }
］
⇒
~RET
%索引 の中で %~cp に対応する <em>最後の</em> ~pointer
<!-- https://www.w3.org/Bugs/Public/show_bug.cgi?id=27878 -->
◎
If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345, return the last pointer corresponding to code point in index.
</p>

<p class="note">注記：
他にも重複している~cpはあるが、それらに対しては，<em>最初の</em> ~pointerが利用されることになる。
◎
There are other duplicate code points, but for those the first pointer is to be used.
</p>
 </li>

 <li>
~RET
%索引 の中で %~cp を指す$index-pointer
◎
Return the index pointer for code point in index.
</li>

</ol>



<hr>


<p class="note">注記：
すべての$indexは規範的でない資源
$!indexes.json
からも入手できる（ $index-gb18030-ranges の形式は、範囲を表現できるようにするため，若干~異なるものにされている）。
◎
All indexes are also available as non-normative indexes.json resource. (index gb18030 ranges has a slightly different format here, to be able to represent ranges.)
</p>

	</section>
	<section id="specification-hooks">

<h2 title="Specification hooks">7. 他の仕様のための~hook</h2>

<div class="note">
<p>注記：
次に挙げる各種~algoは、他の仕様からの~~利用が意図されている：
</p>

<ul ><li>$decode
</li><li>$utf-8-decode
</li><li>$utf-8-decode-without-bom
</li><li>$utf-8-decode-without-bom-or-fail
</li><li>$encode
</li><li>$utf-8-encode
</li></ul>

<p>
新たな形式には、$utf-8-decodeが利用されることになる。
最初に$labelを$encodingに~~変換するときは、$concept-encoding-getする~algoを利用できる。
</p>
◎
The algorithms decode, UTF-8 decode, UTF-8 decode without BOM, UTF-8 decode without BOM or fail, encode, and UTF-8 encode are intended for usage by other specifications. UTF-8 decode is to be used by new formats. The get an encoding algorithm can be used first to turn a label into an encoding.
</div>

<p class="algo-head">
~fallback~encoding %~encoding を利用して，~byte~stream %~stream を
@decode
するときは、次を走らす：
◎
To decode a byte stream stream using fallback encoding encoding, run these steps:
</p>

<ol>
 <li>
%buffer ~LET ~byte列 []
◎
Let buffer be an empty byte sequence.
</li>

 <li>
%~BOMseen~flag ~LET ~OFF
◎
Let BOM seen flag be unset.
</li>

 <li>
次を 3 回 繰返す
⇒
%~stream から$concept-stream-readを %buffer に付加する
— ただし，$end-of-stream が返されたときは、付加せずに繰返しを終える
◎
Read bytes from stream into buffer until either buffer contains three bytes or read returns end-of-stream.
</li>

 <li>
<p>
~IF［
次の表の中で， 1 列目に示された~byte列が %buffer の先頭の~byte列に合致する行がある
］
⇒
%~encoding ~SET その行の 2 列目に与えられる $encoding ~BR
%~BOMseen~flag ~LET ~ON
◎
For each of the rows in the table below, starting with the first one and going down, if the first bytes of buffer match all the bytes given in the first column, then set encoding to the encoding given in the cell in the second column of that row and set BOM seen flag.
</p>


<table>

<thead><tr><th>~BOM◎Byte order mark
</th><th>~encoding◎Encoding
</th></tr></thead>

<tbody><tr><td>0xEF 0xBB 0xBF
</td><td>$utf-8

</td></tr><tr><td>0xFE 0xFF
</td><td>$utf-16be

</td></tr><tr><td>0xFF 0xFE
</td><td>$utf-16le

</td></tr></tbody></table>

<p class="note">注記：
配備済みの内容と互換性をとるため、~BOM（ BOM ）は他より~~優先される。
HTTP が利用される文脈~下では、これは，
`<code class="header">Content-Type</code>`
~headerの意味論に対する違反である。
◎
For compatibility with deployed content, the byte order mark (also known as BOM) is more authoritative than anything else. In a context where HTTP is used this is in violation of the semantics of the `Content-Type` header.
</li>

 <li>
~IF［
%~BOMseen~flag ~EQ ~OFF
］
⇒
%buffer を %~stream $concept-stream-prepend
◎
If BOM seen flag is unset prepend buffer to stream.
</li>

 <li>
~ELIF ［
%~encoding ~NEQ $utf-8
］~AND［
%buffer の長さ ~EQ 3
］
⇒
%buffer の最後の~byteを %~stream $concept-stream-prepend
◎
Otherwise, if BOM seen flag is set, encoding is not UTF-8, and buffer contains three bytes, prepend the last byte of buffer to stream.
</li>

 <li>
%出力 ~LET ~cp$concept-stream
◎
Let output be a code point stream.
</li>

 <li>
( %~stream, %出力 )
を与える下で，
%~encoding の$decoderを$concept-encoding-run
◎
Run encoding's decoder with stream and output.
</li>

 <li>
~RET %出力
◎
Return output.
</li>

</ol>

<p class="algo-head">
~byte~stream %~stream を
@utf-8-decode
するときは、次を走らす：
◎
To UTF-8 decode a byte stream stream, run these steps:
</p>

<ol>
 <li>
%buffer ~LET ~byte列 []
◎
Let buffer be an empty byte sequence.
</li>

 <li>
次を 3 回 繰返す
⇒
%~stream から$concept-stream-readを %buffer に付加する
<span class="trans-note">【
— ただし，$end-of-stream が返されたときは、付加せずに繰返しを終える
】</span>
◎
Read three bytes from stream into buffer.
</li>

 <li>
~IF［
%buffer ~NEQ ~byte列 [ 0xEF, 0xBB, 0xBF ]
］
⇒
%buffer を %~stream $concept-stream-prepend
◎
If buffer does not match 0xEF 0xBB 0xBF, prepend buffer to stream.
</li>

 <li>
%出力 ~LET ~cp$concept-stream
◎
Let output be a code point stream.
</li>

 <li>
( %~stream, %出力 )
を与える下で，
$utf-8 の$decoderを$concept-encoding-run
◎
Run UTF-8's decoder with stream and output.
</li>

 <li>
~RET %出力
◎
Return output.
</li>

</ol>

<p class="algo-head">
~byte~stream %~stream を
@utf-8-decode-without-bom
するときは、次を走らす：
◎
To UTF-8 decode without BOM a byte stream stream, run these steps:
</p>

<ol>
 <li>
%出力 ~LET ~cp$concept-stream
◎
Let output be a code point stream.
</li>

 <li>
( %~stream, %出力 )
を与える下で，
$utf-8 の$decoderを$concept-encoding-run
◎
Run UTF-8's decoder with stream and output.
</li>

 <li>
~RET %出力
◎
Return output.
</li>

</ol>


<p class="algo-head">
~byte~stream %~stream を
@utf-8-decode-without-bom-or-fail
するときは、次を走らす：
◎
To UTF-8 decode without BOM or fail a byte stream stream, run these steps:
</p>

<ol>
 <li>
%出力 ~LET ~cp$concept-stream
◎
Let output be a code point stream.
</li>

 <li>
( %~stream, %出力, `^fatal )
を与える下で，
$utf-8 の$decoderを$concept-encoding-run
◎
Let potentialError be the result of running UTF-8's decoder with stream, output, and "fatal".
</li>

 <li>
~IF［
前~段の結果 ~EQ $error
］
⇒
~RET ~FAIL
◎
If potentialError is error, return failure.
</li>

 <li>
~RET %出力
◎
Return output.
</li>

</ol>


<p class="algo-head">
~encoding %~encoding を利用して ~cp~stream %~stream を
@encode
するときは、次を走らす：
◎
To encode a code point stream stream using encoding encoding, run these steps:
</p>

<ol>
 <li>
~Assert：
%~encoding ~NIN 
{ $replacement, $utf-16be, $utf-16le }
◎
Assert: encoding is not replacement, UTF-16BE or UTF-16LE.
</li>

 <li>
%出力 ~LET ~byte$concept-stream
◎
Let output be a byte stream.
</li>

 <li>
( %~stream, %出力, `^html )
を与える下で，
 %~encoding の$encoderを$concept-encoding-run
◎
Run encoding's encoder with stream, output, and "html".
</li>

 <li>
~RET %出力
◎
Return output.
</li>
</ol>


<p class="note">注記：
これは、主に URL と HTML ~formのための旧来の~hookである。
$utf-8-encodeを被せた方が、決して$errorを誘発させないので安全である。
<a href="#refsURL">[URL]</a>
<a href="#refsHTML">[HTML]</a>
◎
This is mostly a legacy hook for URLs and HTML forms. Layering UTF-8 encode on top is safe as it never triggers errors. [URL] [HTML]
</p>

<p class="algo-head">
~cp~stream %~stream を
@utf-8-encode
するときは
⇒
$utf-8 を~encodingに利用して %~stream を$encodeした結果を返す。
◎
To UTF-8 encode a code point stream stream, return the result of encoding stream using encoding UTF-8.
</p>

	</section>
	<section id="api">

<h2 title="API">8. API</h2>

<!-- https://wiki.whatwg.org/wiki/StringEncoding  -->

<p>
この節では DOM, Web IDL の各種用語が用いられる。
非~browser~UAに対しては、この API の~supportは要求されない。
<a href="#refsDOM">[DOM]</a>
<a href="#refsWEBIDL">[WEBIDL]</a>
◎
This section uses terminology from the DOM and Web IDL. Non-browser user agents are not required to support this API. [DOM] [WEBIDL]
</p>

<div class="example">
<p>
次の例は、 `$textencoder ~objを利用して，文字列の配列を `ArrayBuffer に~encodeする。
結果は次を内容とする `Uint8Array になる：
<span class="block">
先頭が（ `Uint32Array としての）文字列の個数，その後は：
<span class="block">
最初の文字列の（ `Uint32Array としての）長さ,
$utf-8 に~encodeされたその文字列~data，<br />
２番目の文字列の（ `Uint32Array としての）長さ,
その文字列~data，<br />
…
</span>
等々と続く。
</span>
◎
The following example uses the TextEncoder object to encode an array of strings into an ArrayBuffer. The result is a Uint8Array containing the number of strings (as a Uint32Array), followed by the length of the first string (as a Uint32Array), the UTF-8 encoded string data, the length of the second string (as a Uint32Array), the string data, and so on.
</p>

<pre>
function encodeArrayOfStrings(%strings) {
  var %encoder, %encoded, %len, %bytes, %view, %offset;

  %encoder = new TextEncoder();
  %encoded = [];

  %len = Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %strings.length; %i++) {
    %len += Uint32Array.BYTES_PER_ELEMENT;
    %encoded[%i] = %encoder.encode(%strings[%i]);
    %len += %encoded[%i].byteLength;
  }

  %bytes = new Uint8Array(%len);
  %view = new DataView(%bytes.buffer);
  %offset = 0;

  %view.setUint32(%offset, %strings.length);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %encoded.length; %i++) {
    %len = %encoded[%i].byteLength;
    %view.setUint32(%offset, %len);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %bytes.set(%encoded[%i], %offset);
    %offset += %len;
  }
  return %bytes.buffer;
}</pre>

<p>
次の例は、［［
前の例, または $utf-8 以外の~encodingに等価な~algo
］により生産される形式に~encodeされた~data
］を含んでいる `ArrayBuffer を~decodeして、元の，一連の文字列からなる配列に戻す。
◎
The following example decodes an ArrayBuffer containing data encoded in the format produced by the previous example, or an equivalent algorithm for encodings other than UTF-8, back into an array of strings.
</p>

<pre>
function decodeArrayOfStrings(%buffer, %encoding) {
  var %decoder, %view, %offset, %num_strings, %strings, %len;

  %decoder = new TextDecoder(%encoding);
  %view = new DataView(%buffer);
  %offset = 0;
  %strings = [];

  %num_strings = %view.getUint32(%offset);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %num_strings; %i += 1) {
    %len = %view.getUint32(%offset);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %strings[%i] = %decoder.decode(
      new DataView(%view.buffer, %offset, %len));
    %offset += %len;
  }
  return %strings;
}</pre>
</div>

		<section id="interface-textdecoder">

<h3 title="Interface TextDecoder">8.1. ~interface `TextDecoder</h3>

<pre class="idl">
dictionary @textdecoderoptions {
  boolean fatal = false;
  boolean ignoreBOM = false;
};

dictionary @textdecodeoptions {
  boolean stream = false;
};

[<a href="#dom-textdecoder" title="dom-TextDecoder">Constructor</a>(
    optional DOMString %label = "utf-8",
    optional $textdecoderoptions %options
),
 Exposed=(Window,Worker)]
interface @textdecoder {
  readonly attribute DOMString $dom-textdecoder-encoding;
  readonly attribute boolean $dom-textdecoder-fatal;
  readonly attribute boolean $dom-textdecoder-ignorebom;
  USVString $dom-textdecoder-decode(
      optional BufferSource %input,
      optional $textdecodeoptions %options
  );
};</pre>

<p class="trans-note">【
<a href="Encoding-test.html" >利用中の~browserでこの特色機能を試す</a>
】</p>

<div class="p">
<p>
各 `$textdecoder ~objには、次のものが結付けられる（括弧内は初期~値）：
</p>

<ul>
	<li>`!~encoding</li>
	<li>`!~decoder
<p class="trans-note">【
`!~encodingに対応する$decoderの，~instance。
$decoderには，内部状態を保持する変数たちを伴うものもあるので、~objごとに~instanceを要する。
】</p>
</li>
	<li>`!~stream</li>
	<li>`!~BOMignore~flag（ ~OFF ）</li>
	<li>`!~BOMseen~flag（ ~OFF ）</li>
	<li>`!~error~mode（ `^replacement ）</li>
	<li>`!~no_flush~flag（ ~OFF ）</li>
</ul>

◎
A TextDecoder object has an associated encoding, decoder, stream, ignore BOM flag (initially unset), BOM seen flag (initially unset), error mode (initially "replacement"), and do not flush flag (initially unset).
</div>


<p class="algo-head">
各 `$textdecoder ~objには、~streamを
@concept-td-serialize
する~algoも結付けられる。
それは、所与の$concept-stream %~stream に対し，次を走らす：
◎
A TextDecoder object also has an associated serialize stream algorithm, that given a stream stream, runs these steps:
</p>

<ol>
 <li>
%出力 ~LET 空$string
◎
Let output be the empty string.
</li>

 <li>
<p>
~WHILE ( true )
◎
While true:
</p>


  <ol>
   <li>
%~token ~LET %~stream から$concept-stream-read
◎
Let token be the result of reading from stream.
</li>

   <li>
<p>
~IF［
`!~encoding ~IN { $utf-8, $utf-16be, $utf-16le }
］~AND［
`!~BOMignore~flag ~EQ ~OFF
］~AND［
`!~BOMseen~flag ~EQ ~OFF
］：
◎
If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore BOM flag and BOM seen flag are unset, run these subsubsteps:
</p>

    <ol>
     <li>
~IF［
%~token ~EQ U+FEFF
］
⇒
`!~BOMseen~flag ~SET ~ON
◎
If token is U+FEFF, set BOM seen flag.
</li>

     <li>
~ELIF［
%~token ~NEQ $end-of-stream
］
⇒
`!~BOMseen~flag ~SET ~ON ~BR
%~token を %出力 に付加する
◎
Otherwise, if token is not end-of-stream, set BOM seen flag and append token to output.
</li>

     <li>
~ELSE
⇒
~RET %出力
◎
Otherwise, return output.
</li>
    </ol>
   </li>

   <li>
~ELIF［
%~token ~NEQ $end-of-stream
］
⇒
%~token を %出力 に付加する
◎
Otherwise, if token is not end-of-stream, append token to output.
</li>

   <li>
~ELSE
⇒
~RET %出力
◎
Otherwise, return output.
</li>
  </ol>
 </li>
</ol>

<p class="note">注記：
この~algoは、 API の利用者に より多くの制御を供するため，~platformの他の場所で利用される$decode ~algoとは、BOM の取扱いの点で意図的に異なるものにされている。
◎
This algorithm is intentionally different with respect to BOM handling from the decode algorithm used by the rest of the platform to give API users more control.
</p>

<hr>

<dl class="domintro">
 <dt><code>%decoder = new $dom-textdecoder([%label = "utf-8" [, %options]])</code></dt>
 <dd>
<p>
新たな `$textdecoder ~obj を返す。
◎
Returns a new TextDecoder object.
</p>

<p>
%label が$labelでない, または
%label が$replacementである場合、
`RangeError が<a href="~WEBIDL#dfn-throw">投出</a>される。
◎
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

 <dt><code>%decoder . $dom-textdecoder-encoding</code></dt>
 <dd>
`!~encodingの$nameを小文字化して返す。
◎
Returns encoding's name, lowercased.
</dd>


 <dt><code>%decoder . $dom-textdecoder-fatal</code></dt>
 <dd>
`!~error~modeが `^fatal ならば ~T を, 他の場合は ~F を返す。
◎
Returns true if error mode is "fatal", and false otherwise.
</dd>

 <dt><code>%decoder . $dom-textdecoder-ignorebom</code></dt>
 <dd>
`!~BOMignore~flagが ~ON ならば ~T を, 他の場合は ~F を返す。
◎
Returns true if ignore BOM flag is set, and false otherwise.
</dd>


 <dt><code>%decoder . $dom-textdecoder-decode([%input [, %options]])</code></dt>
 <dd>
<p>
%input を `!~encodingの$decoderにかけた結果を返す。
~streamを断片化して処理するときは、
%options の `stream ~memberを ~T にした下で，この~method 0 回~以上~呼出してから， %options を省略して（または その `stream ~memberを ~F にして）
1 回だけ呼出すことで行える。
後者の呼出時に %input もないならば、両~引数とも省略するのが最も簡明になる。
◎
Returns the result of running encoding's decoder. The method can be invoked zero or more times with options's stream set to true, and then once without options's stream (or set to false), to process a fragmented stream. If the invocation without options's stream (or set to false) has no input, it's clearest to omit both arguments.
</p>

<pre class="example">
var %string = "", %decoder = TextDecoder(%encoding), %buffer;
while(%buffer = next_chunk()) {
  %string += %decoder.decode(%buffer, {stream:true});
}
%string += %decoder.decode(); // ~EoS
</pre>

<p>
`!~error~mode ~EQ `^fatal の下で，
`!~encodingの$decoderが$errorを返した場合、
`TypeError が<a href="~WEBIDL#dfn-throw">投出</a>される。
◎
If the error mode is "fatal" and encoding's decoder returns error, throws a TypeError.
</p>
 </dd>
</dl>



<p>
<code >@dom-textdecoder(%label, %options)</code>
構築子の被呼出時には、次を走らせ~MUST：
◎
The TextDecoder(label, options) constructor, when invoked, must run these steps:
</p>

<ol>
 <li>
%~encoding ~LET %label から$concept-encoding-getした結果
◎
Let encoding be the result of getting an encoding from label.
</li>

 <li>
~IF［
%~encoding ~IN { ~FAIL, $replacement }
］
⇒
~THROW `RangeError
◎
If encoding is failure or replacement, throw a RangeError.
</li>

 <li>
%dec ~LET 新たな `$textdecoder ~obj
◎
Let dec be a new TextDecoder object.
</li>

 <li>
%dec の `!~encoding ~SET %~encoding
◎
Set dec's encoding to encoding.
</li>

 <li>
~IF［
%options の `fatal ~member ~EQ ~T
］
⇒
%dec の `!~error~mode ~SET `^fatal
◎
If options's fatal member is true, set dec's error mode to "fatal".
</li>

 <li>
~IF［
%options の `ignoreBOM ~member ~EQ ~T
］
⇒
%dec の `!~BOMignore~flag ~SET `^fatal
◎
If options's ignoreBOM member is true, set dec's ignore BOM flag.
</li>

 <li>
~RET %dec
◎
Return dec.
</li>
</ol>

<p>
`@dom-textdecoder-encoding
属性の取得子は、
`!~encodingの$nameを$ascii-lowercaseした結果を返さ~MUST。
◎
The encoding attribute's getter must return encoding's name in ASCII lowercase.
</p>

<p>
`@dom-textdecoder-fatal
属性の取得子は、［
`!~error~mode ~EQ `^fatal ならば ~T ／ ~ELSE_ ~F
］を返さ~MUST。
◎
The fatal attribute's getter must return true if error mode is "fatal", and false otherwise.
</p>

<p>
`@dom-textdecoder-ignorebom
属性の取得子は、［
`!~BOMignore~flag ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The ignoreBOM attribute's getter must return true if ignore BOM flag is set, and false otherwise.
</p>

<p>
<code >@dom-textdecoder-decode(%input, %options)</code>
~methodの被呼出時には、次を走らせ~MUST：
◎
The decode(input, options) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
`!~no_flush~flag ~EQ ~OFF
］
⇒
`!~decoder ~SET 新たな［
`!~encoding の$decoder
］ ~BR
`!~stream ~SET 新たな$concept-stream ~BR
`!~BOMseen~flag ~SET ~OFF
◎
If the do not flush flag is unset, set decoder to a new encoding's decoder, set stream to a new stream, and unset the BOM seen flag.
</li>

 <li>
`!~no_flush~flag ~SET［
%options の `stream ~EQ ~T ならば ~ON ／
~ELSE_ ~OFF
］
◎
If options's stream is true, set the do not flush flag, and unset the do not flush flag otherwise.
</li>

 <li>
~IF［
%input は与えられている
］
⇒
%input の<a href="~WEBIDL#dfn-get-buffer-source-copy">複製</a>を `!~stream$concept-stream-push
◎
If input is given, push a copy of input to stream.
</li>

 <li>
%出力 ~LET 新たな$concept-stream
◎
Let output be a new stream.
</li>

 <li>
<p>
~WHILE ( true )
◎
While true:
</p>


  <ol>
   <li>
%~token ~LET `!~streamから$concept-stream-read
◎
Let token be the result of reading from stream.
</li>

   <li>
<p>
~IF［
%~token ~EQ $end-of-stream
］~AND［
`!~no_flush~flag ~EQ ~ON
］
⇒
~RET %出力 を$concept-td-serializeした結果
◎
If token is end-of-stream and the do not flush flag is set, return output, serialized.
</p>

<p class="note">
~streamingでは、［
`!~no_flush~flag ~EQ ~ON
］のときに，ここで$end-of-streamを取扱うことなく，その~flagを ~OFF にしない仕方で働く。
この仕方により、後続の呼出時には，この~algoの最初の段で `!decoderは一新されず、その状態は保全される。
◎
The way streaming works is to not handle end-of-stream here when the do not flush flag is set and to not unset that flag. That way in a subsequent invocation decoder is not set anew in the first step of the algorithm and its state is preserved.
</p>
   </li>

   <li>
%結果 ~LET
( `!~decoder, `!~stream, %出力, `!~error~mode )
を与える下で，
%~token を$concept-encoding-processした結果
◎
Otherwise, run these subsubsteps:
◎
Let result be the result of processing token for decoder, stream, output, and error mode.
</li>

   <li>
~IF［
%結果 ~EQ $finished
］
⇒
~RET %出力 を$concept-td-serializeした結果
◎
If result is finished, return output, serialized.
</li>

   <li>
~ELIF［
%結果 ~EQ $error
］
⇒
~THROW `TypeError
◎
Otherwise, if result is error, throw a TypeError.
◎
Otherwise, do nothing.
</li>
  </ol>
 </li>
</ol>


		</section>
		<section id="interface-textencoder">

<h3 title="Interface TextEncoder">8.2. ~interface `TextEncoder</h3>

<pre class="idl">
[<a href="#dom-textencoder" title="dom-TextEncoder">Constructor</a><!--
We cannot add an argument here that is not the label argument it had previously. That would break content.
-->, Exposed=(Window,Worker)]
interface @textencoder {
  readonly attribute DOMString $dom-textencoder-encoding;
  [NewObject] Uint8Array $dom-textencoder-encode(optional USVString %input = "");
};</pre>


<p>
各 `$textencoder ~objには、 `!~encoder が結付けられる：
◎
A TextEncoder object has an associated encoder.
</p>

<p class="note">注記：
`$textencoder ~objの構築子には、 %label 引数はなく，~supportするのは $utf-8 のみである。
また、~scalar値~bufferを要する$encoderは無いので， `stream の~optionもない。
◎
A TextEncoder object offers no label argument as it only supports UTF-8. It also offers no stream option as no encoder requires buffering of scalar values.
</p>

<hr>

<dl class="domintro">
 <dt><code>%encoder = new $dom-textencoder()</code></dt>
 <dd>
新たな `$textencoder ~obj を返す。
◎
Returns a new TextEncoder object.
</dd>

 <dt><code>%encoder . $dom-textencoder-encoding</code></dt>
 <dd>
`^utf-8 を返す。
◎
Returns "utf-8".
</dd>

 <dt><code>%encoder . $dom-textencoder-encode([%input = ""])</code></dt>
 <dd>
%input を $utf-8 の$encoderにかけた結果を返す。
◎
Returns the result of running UTF-8's encoder.
</dd>

</dl>



<p>
<code>@dom-textencoder()</code>
構築子の被呼出時には、次を走らせ~MUST：
◎
The TextEncoder() constructor, when invoked, must run these steps:
</p>

<ol>
 <li>
%enc ~LET 新たな `$textencoder ~obj
◎
Let enc be a new TextEncoder object.
</li>
 <li>
%enc の `!~encoder ~SET $utf-8 の$encoder
◎
Set enc's encoder to UTF-8's encoder.
</li>
 <li>
~RET %enc
◎
Return enc.
</li>
</ol>

<p>
`@dom-textencoder-encoding
属性の取得子は、 `^utf-8 を返さ~MUST。
◎
The encoding attribute's getter must return "utf-8".
</p>

<p>
<code >@dom-textencoder-encode(%input)</code>
~methodの被呼出時には、次を走らせ~MUST：
◎
The encode(input) method, when invoked, must run these steps:
</p>


<ol>
 <li>
%入力 ~LET %input を$concept-streamに変換した結果
◎
Convert input to a stream.
</li>

 <li>
%出力 ~LET 新たな$concept-stream
◎
Let output be a new stream.
</li>

 <li>
<p>
~WHILE ( true ) ：
◎
While true, run these substeps:
</p>

  <ol>
   <li>
%~token ~LET %入力 から$concept-stream-read
◎
Let token be the result of reading from input.
</li>

   <li>
%結果 ~LET 
( `!~encoder, %入力, %出力 )
を与える下で，
%~token を$concept-encoding-processした結果
◎
Let result be the result of processing token for encoder, input, output.
</li>

   <li>
~IF［
%結果 ~EQ $finished
］
⇒
~RET ［［
%出力 を~byte列に変換した結果
］を包含する `ArrayBuffer
］を包装するような，新たな `Uint8Array ~obj
<!-- XXX https://www.w3.org/Bugs/Public/show_bug.cgi?id=26966 -->
◎
If result is finished, convert output into a byte sequence, and then return a Uint8Array object wrapping an ArrayBuffer containing output.
</li>

  </ol>

<p class="note">注記：
これらの$encodingが$errorを返すことはない。
◎
These encodings cannot return error.
</p>

 </li>
</ol>

		</section>
	</section>
	<section id="the-encoding">

<h2 title="The encoding">9. ~~標準の~encoding</h2>

<p class="trans-note">【
この “~~標準の” は “The” の対訳であり、およそ，
“規範とされるべき唯一無二の”
を意味する。
】</p>

		<section id="utf-8">

<h3>9.1. <b>UTF-8</b></h3>

			<section id="utf-8-decoder">
<h4 title="UTF-8 decoder">9.1.1. UTF-8 ~decoder</h4>


<p>
$utf-8 の$decoderの各~instanceには、次のものが結付けられる
⇒
@utf-8-code-point（初期~時 0 ）~BR
@utf-8-bytes-seen（初期~時 0 ）~BR
@utf-8-bytes-needed（初期~時 0 ）~BR
@utf-8-lower-boundary（初期~時 0x80 ）~BR
@utf-8-upper-boundary（初期~時 0xBF ）
◎
UTF-8's decoder's has an associated UTF-8 code point, UTF-8 bytes seen, and UTF-8 bytes needed (all initially 0), a UTF-8 lower boundary (initially 0x80), and a UTF-8 upper boundary (initially 0xBF).
</p>

<p>
$utf-8 の$decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
UTF-8's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
~IF［
%~byte ~EQ $end-of-stream
］~AND［
$utf-8-bytes-needed ~NEQ 0
］
⇒
$utf-8-bytes-needed ~SET 0 ~BR
~RET $error
◎
If byte is end-of-stream and UTF-8 bytes needed is not 0, set UTF-8 bytes needed to 0 and return error.
</li>

 <li>
~IF［
%~byte ~EQ $end-of-stream
］
⇒
~RET $finished
◎
If byte is end-of-stream, return finished.
</li>

 <li>
<p>
~IF［
$utf-8-bytes-needed ~EQ 0
］：
◎
If UTF-8 bytes needed is 0, based on byte:
</p>

  <ol>
   <li>
<p>
%~byte に応じて：
◎
↑</p>

    <dl class="switch">
     <dt>$ascii-byte</dt>
     <dd>
~RET ~cp [ %~byte ]
◎
Return a code point whose value is byte.
</dd>

     <dt>0xC2 〜 0xDF</dt>
     <dd>
      <ol>
       <li>
$utf-8-bytes-needed ~SET 1
◎
Set UTF-8 bytes needed to 1.
</li>
       <li>
$utf-8-code-point ~SET %~byte &amp; 0x1F
<span class="note">（ %~byte の下位 5 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0x1F.
◎
The five least significant bits of byte.
</li>
      </ol>
     </dd>

     <dt>0xE0 〜 0xEF</dt>
     <dd>
      <ol>
       <li>
~IF［
%~byte ~EQ 0xE0
］
⇒
$utf-8-lower-boundary ~SET 0xA0
◎
If byte is 0xE0, set UTF-8 lower boundary to 0xA0.
</li>

       <li>
~IF［
%~byte ~EQ 0xED
］
⇒
$utf-8-upper-boundary ~SET 0x9F
◎
If byte is 0xED, set UTF-8 upper boundary to 0x9F.
</li>

       <li>
$utf-8-bytes-needed ~SET 2
◎
Set UTF-8 bytes needed to 2.
</li>

       <li>
$utf-8-code-point ~SET %~byte &amp; 0xF
<span class="note">（ %~byte の下位 4 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0xF.
◎
The four least significant bits of byte.
</li>
      </ol>
     </dd>

     <dt>0xF0 〜 0xF4</dt>
     <dd>
      <ol>
       <li>
~IF［
%~byte ~EQ 0xF0
］
⇒
$utf-8-lower-boundary ~SET 0x90
◎
If byte is 0xF0, set UTF-8 lower boundary to 0x90.
</li>
       <li>
~IF［
%~byte ~EQ 0xF4
］
⇒
$utf-8-upper-boundary ~SET 0x8F
◎
If byte is 0xF4, set UTF-8 upper boundary to 0x8F.
</li>
       <li>
$utf-8-bytes-needed ~SET 3
◎
Set UTF-8 bytes needed to 3.
</li>

       <li>
$utf-8-code-point ~SET %~byte &amp; 0x7
<span class="note">（ %~byte の下位 3 ~bit ）</span>
◎
Set UTF-8 code point to byte & 0x7.
◎
The three least significant bits of byte.
</li>
      </ol>
     </dd>

     <dt>~OTHER◎Otherwise</dt>
     <dd>
~RET $error
◎
Return error.
</dd>
    </dl>
   </li>
   <li>
~RET $continue
◎
Return continue.
</li>
  </ol>
 </li>

 <li>
<p>
~IF［
%~byte ~NIN { $utf-8-lower-boundary 〜 $utf-8-upper-boundary }
：
◎
If byte is not in the range UTF-8 lower boundary to UTF-8 upper boundary, inclusive, run these substeps:
</p>

  <ol>
   <li>
( $utf-8-code-point, $utf-8-bytes-needed, $utf-8-bytes-seen ) ~SET ( 0, 0, 0 ) ~BR
( $utf-8-lower-boundary, $utf-8-upper-boundary ) ~SET ( 0x80, 0xBF )
◎
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0, set UTF-8 lower boundary to 0x80, and set UTF-8 upper boundary to 0xBF.
</li>

 <li>
%~byte を %~stream $concept-stream-prepend
◎
Prepend byte to stream.
</li>

 <li>
~RET $error
◎
Return error.
</li>
  </ol>
 </li>

 <li>
( $utf-8-lower-boundary, $utf-8-upper-boundary ) ~SET ( 0x80, 0xBF )
◎
Set UTF-8 lower boundary to 0x80 and UTF-8 upper boundary to 0xBF.
</li>

 <li>
<p>
$utf-8-code-point ~SET ($utf-8-code-point &lt;&lt; 6) | (%~byte &amp; 0x3F)
◎
Set UTF-8 code point to (UTF-8 code point &lt;&lt; 6) | (byte &amp; 0x3F)
</p>

<p class="note">
$utf-8-code-point内の既存の~bitを左へ 6 ~bit ~shiftして，空いた下位 6 ~bitに %~byte の下位 6 ~bitをあてがう。
◎
Shift the existing bits of UTF-8 code point left by six places and set the newly-vacated six least significant bits to the six least significant bits of byte.
</p>
 </li>

 <li>
<p>
$utf-8-bytes-seen ~INCBY 1
◎
Increase UTF-8 bytes seen by one.
</li>

 <li>
~IF［
$utf-8-bytes-seen ~NEQ $utf-8-bytes-needed
］
⇒
~RET $continue
◎
If UTF-8 bytes seen is not equal to UTF-8 bytes needed, return continue.
</li>

 <li>
%~cp ~LET $utf-8-code-point
◎
Let code point be UTF-8 code point.
</li>

 <li>
( $utf-8-code-point, $utf-8-bytes-needed, $utf-8-bytes-seen ) ~SET ( 0, 0, 0 ) 
◎
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0.
</li>

 <li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
</ol>

<p class="note">注記：
上の$utf-8-decoderにおける拘束は、 Unicode 標準の
“Best Practices for Using U+FFFD”
に準ずる。
他のふるまいは Encoding 標準の下では許可されない（同じ結果が得られるなら，他の~algoでも もちろん~~十分であり、むしろ奨励される）。
<a href="#refsUNICODE">[UNICODE]</a>
◎
The constraints in the UTF-8 decoder above match “Best Practices for Using U+FFFD” from the Unicode standard. No other behavior is permitted per the Encoding Standard (other algorithms that achieve the same result are obviously fine, even encouraged). [UNICODE]
</p>

			</section>
			<section id="utf-8-encoder">
<h4 title="UTF-8 encoder">9.1.2. UTF-8 ~encoder</h4>

<p>
$utf-8 の$encoderの$handlerは、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
UTF-8's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
~IF［
%~cp ~EQ $end-of-stream
］
⇒
~RET $finished
◎
If code point is end-of-stream, return finished.
</li>

 <li>
~IF［
%~cp ~IN $ascii-code-point
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
<p>
( %count, %~offset ) ~SET %~cp が属する範囲に応じて，次で与えられる値：
◎
Set count and offset based on the range code point is in:
</p>
  <dl class="switch">
   <dt>U+0080 〜 U+07FF</dt>
   <dd>
( 1, 0xC0 )
◎
1 and 0xC0
</dd>
   <dt>U+0800 〜 U+FFFF</dt>
   <dd>
( 2, 0xE0 )
◎
2 and 0xE0
</dd>
   <dt>U+10000 〜 U+10FFFF</dt>
   <dd>
( 3, 0xF0 )
◎
3 and 0xF0
</dd>
  </dl>
<!--
   <dt>U+0080 to U+07FF, inclusive</dt>
   <dd>1 and 0xC0
   </dd><dt>U+0800 to U+FFFF, inclusive</dt>
   <dd>2 and 0xE0
   </dd><dt>U+10000 to U+10FFFF, inclusive</dt>
   <dd>3 and 0xF0
 -->

 </li>

 <li>
%~byte列 ~LET ~byte列 [ ( %~cp &gt;&gt; ( 6 × %count ) ) + %~offset ]
◎
Let bytes be a byte sequence whose first byte is (code point &gt;&gt; (6 × count)) + offset.
</li>

 <li>
<p>
~WHILE %count ~GT 0
：
◎
Run these substeps while count is greater than 0:
</p>

  <ol>
   <li>
%temp ~SET %~cp &gt;&gt; ( 6 × ( %count − 1 ) )
◎
Set temp to code point &gt;&gt; (6 × (count − 1)).
</li>

 <li>
( 0x80 | ( %temp &amp; 0x3F ) ) を %~byte列 に付加する
◎
Append to bytes 0x80 | (temp &amp; 0x3F).
</li>

 <li>
%count ~DECBY 1
◎
Decrease count by one.
</li>
  </ol>
 </li>

 <li>
~RET %~byte列
◎
Return bytes bytes, in order.
</li>
</ol>

<p class="note">
この~algoは、 Unicode 標準に述べられるものと一致する結果を得るが、完全さのためここに含められている。
<a href="#refsUNICODE">[UNICODE]</a>
◎
This algorithm has identical results to the one described in the Unicode standard. It is included here for completeness. [UNICODE]
</p>


			</section>
		</section>
	</section>
	<section id="legacy-single-byte-encodings">

<h2 title="Legacy single-byte encodings">10. 旧来の単byte~encoding</h2>

<p>
各~byteが［
１個の~cpに対応するか, または対応する~cpは無い
］ような$encodingを
@single-byte-encoding
と呼ぶ。
すべての$single-byte-encodingが、同じ［
$decoder, $encoder
］を共有する。
$single-byte-decoder／$single-byte-encoderから参照される
@index-single-byte
は、利用される$single-byte-encodingに依存し，次の一覧で定義される。
２つ
<span class="trans-note">【 ISO-8859-8, ISO-8859-8-I 】</span>
を除くすべての$single-byte-encodingは、それぞれに一意な$indexを持つ。
◎
An encoding where each byte is either a single code point or nothing, is a single-byte encoding. Single-byte encodings share the decoder and encoder. Index single-byte, as referenced by the single-byte decoder and single-byte encoder, is defined by the following table, and depends on the single-byte encoding in use. All but two single-byte encodings have a unique index.
</p>
<table>

<thead><tr><th>$name◎Name
</th><th>$index◎Index
</th></tr></thead>

<tbody>
<tr><td>@ibm866</td><td>$!index-ibm866.txt</td></tr>
<tr><td>@iso-8859-2</td><td>$!index-iso-8859-2.txt</td></tr>
<tr><td>@iso-8859-3</td><td>$!index-iso-8859-3.txt</td></tr>
<tr><td>@iso-8859-4</td><td>$!index-iso-8859-4.txt</td></tr>
<tr><td>@iso-8859-5</td><td>$!index-iso-8859-5.txt</td></tr>
<tr><td>@iso-8859-6</td><td>$!index-iso-8859-6.txt</td></tr>
<tr><td>@iso-8859-7</td><td>$!index-iso-8859-7.txt</td></tr>
<tr><td>@iso-8859-8</td><td rowspan="2">$!index-iso-8859-8.txt</td></tr>
<tr><td>@iso-8859-8-i</td></tr>
<tr><td>@iso-8859-10</td><td>$!index-iso-8859-10.txt</td></tr>
<tr><td>@iso-8859-13</td><td>$!index-iso-8859-13.txt</td></tr>
<tr><td>@iso-8859-14</td><td>$!index-iso-8859-14.txt</td></tr>
<tr><td>@iso-8859-15</td><td>$!index-iso-8859-15.txt</td></tr>
<tr><td>@iso-8859-16</td><td>$!index-iso-8859-16.txt</td></tr>
<tr><td>@koi8-r</td><td>$!index-koi8-r.txt</td></tr>
<tr><td>@koi8-u</td><td>$!index-koi8-u.txt</td></tr>
<tr><td>@macintosh</td><td>$!index-macintosh.txt</td></tr>
<tr><td>@windows-874</td><td>$!index-windows-874.txt</td></tr>
<tr><td>@windows-1250</td><td>$!index-windows-1250.txt</td></tr>
<tr><td>@windows-1251</td><td>$!index-windows-1251.txt</td></tr>
<tr><td>@windows-1252</td><td>$!index-windows-1252.txt</td></tr>
<tr><td>@windows-1253</td><td>$!index-windows-1253.txt</td></tr>
<tr><td>@windows-1254</td><td>$!index-windows-1254.txt</td></tr>
<tr><td>@windows-1255</td><td>$!index-windows-1255.txt</td></tr>
<tr><td>@windows-1256</td><td>$!index-windows-1256.txt</td></tr>
<tr><td>@windows-1257</td><td>$!index-windows-1257.txt</td></tr>
<tr><td>@windows-1258</td><td>$!index-windows-1258.txt</td></tr>
<tr><td>@x-mac-cyrillic</td><td>$!index-x-mac-cyrillic.txt</td></tr>
</tbody>
</table>

<p class="note">注記：
~layout方向に波及することから、 $iso-8859-8 と $iso-8859-8-i の$encodingの$nameは異なるものにされている。
歴史的に、このことは $iso-8859-6 と "iso-8859-6-i" についても該当していたが、それは今や成立しない。
<!-- https://www.w3.org/Bugs/Public/show_bug.cgi?id=19505 -->
◎
ISO-8859-8 and ISO-8859-8-I are distinct encoding names, because ISO-8859-8 has influence on the layout direction. And although historically this might have been the case for ISO-8859-6 and "iso-8859-6-i" as well, that is no longer true.
</p>



		<section id="single-byte-decoder">
<h3 title="single-byte decoder">10.1. 単byte~decoder</h3>

<p>
$single-byte-encodingの$decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
Single-byte encodings's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
~IF［
%~byte ~EQ $end-of-stream
］
⇒
~RET $finished
◎
If byte is end-of-stream, return finished.
</li>


 <li>
~IF［
%~byte ~IN $ascii-byte
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>

 <li>
%~cp ~LET
$index-single-byte の中で
( %~byte − 0x80 )
が指す$index-code-point
◎
Let code point be the index code point for byte − 0x80 in index single-byte.
</li>

 <li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET $error
◎
If code point is null, return error.
</li>

 <li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
</ol>

		</section>
		<section id="single-byte-encoder">
<h3 title="single-byte encoder">10.2. 単byte~encoder</h3>

<p>
$single-byte-encoding の$encoderの$handlerは、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
Single-byte encodings's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
~IF［
%~cp ~EQ $end-of-stream
］
⇒
~RET $finished
◎
If code point is end-of-stream, return finished.
</li>

 <li>
~IF［
%~cp ~IN $ascii-code-point
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
%~pointer ~LET
$index-single-byte の中で
%~cp を指す$index-pointer
◎
Let pointer be the index pointer for code point in index single-byte.
</li>

 <li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う$error
◎
If pointer is null, return error with code point.
</li>

 <li>
~RET ~byte列 [ %~pointer + 0x80 ]
◎
Return a byte whose value is pointer + 0x80.
</li>
</ol>

		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(simplified)-encodings">

<h2 title="Legacy multi-byte Chinese (simplified) encodings">11. 旧来の複byte Chinese （簡体字） ~encoding</h2>

		<section id="gbk">
<h3 title="GBK">11.1 <b>GBK</b></h3>

			<section id="gbk-decoder">
<h4 title="GBK decoder">11.1.1 GBK ~decoder</h4>

<p>
$gbk の$decoderは， $gb18030 の$decoderである。
◎
GBK's decoder is gb18030's decoder.
</p>

			</section>
			<section id="gbk-encoder">
<h4 title="GBK encoder">11.1.2 GBK ~encoder</h4>

<p>
GBK の~encoderは，［
$gbk-flag ~SET ~ON
］にされた $gb18030 の$encoderである。
◎
GBK's encoder is gb18030's encoder with its GBK flag set.
</p>


<p class="note">注記：
$gbk を $gb18030 に対する全くの別名にしないのは、
$gbk の$encoderにより生成された内容を，旧来の~serverや他の消費者をなるべく壊すことなく，保守的に移行するためである。
◎
Not fully aliasing GBK with gb18030 is a conservative move to decrease the chances of breaking legacy servers and other consumers of content generated with GBK's encoder.
</p>
			</section>
		</section>


		<section id="gb18030">

<h3 title="gb18030">11.2. <b>gb18030</b></h3>


			<section id="gb18030-decoder">
<h4 title="gb18030 decoder">11.2.1. gb18030 ~decoder</h4>

<p>
$gb18030 の$decoderの各~instanceには、次のものが結付けられる
⇒
@gb18030-first（初期~時 0 ）~BR
@gb18030-second（初期~時 0 ）~BR
@gb18030-third（初期~時 0 ）
◎
gb18030's decoder has an associated gb18030 first, gb18030 second, and gb18030 third (all initially 0x00).
</p>

<p>
$gb18030 の$decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
gb18030's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
~IF［
%~byte ~EQ $end-of-stream
］：
◎
↓</p>

  <ol>
   <li>
~IF［
( $gb18030-first, $gb18030-second, $gb18030-third ) ~EQ ( 0x00, 0x00, 0x00 )
］
⇒
~RET $finished
◎
If byte is end-of-stream and gb18030 first, gb18030 second, and gb18030 third are 0x00, return finished.
</li>

   <li>
( $gb18030-first, $gb18030-second, $gb18030-third ) ~SET ( 0x00, 0x00, 0x00 ) ~BR
~RET $error
◎
If byte is end-of-stream, and gb18030 first, gb18030 second, or gb18030 third is not 0x00, set gb18030 first, gb18030 second, and gb18030 third to 0x00, and return error.
</li>

  </ol>
 </li>

 <li>
<p>
~IF［
$gb18030-third ~NEQ 0x00
］：
◎
If gb18030 third is not 0x00, run these substeps:
</p>

  <ol>
   <li>
%~cp ~LET ~NULL
◎
Let code point be null.
</li>

   <li>
~IF［
%~byte ~IN { 0x30 〜 0x39 }
］
⇒
%~cp ~SET ［
((( $gb18030-first − 0x81 ) × 10 + $gb18030-second − 0x30 ) × 126 + $gb18030-third − 0x81 ) × 10 + %~byte − 0x30
］が指す$index-gb18030-ranges-code-point
◎
If byte is in the range 0x30 to 0x39, inclusive, set code point to the index gb18030 ranges code point for (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) × 126 + gb18030 third − 0x81) × 10 + byte − 0x30.
</li>

   <li>
%buffer ~LET ~byte列 [ $gb18030-first, $gb18030-second, %~byte ]
◎
Let buffer be a byte sequence consisting of gb18030 second, gb18030 third, and byte, in order.
</li>

   <li>
( $gb18030-first, $gb18030-second, $gb18030-third ) ~SET ( 0x00, 0x00, 0x00 )
◎
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>

   <li>
~IF［
%~cp ~EQ ~NULL
］
⇒
%buffer を %~stream $concept-stream-prepend ~BR
~RET $error
◎
If code point is null, prepend buffer to stream and return error.
</li>

   <li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>

  </ol>

 </li>

 <li>
<p>
~IF［
$gb18030-second ~NEQ 0x00
］：
◎
If gb18030 second is not 0x00, run these substeps:
</p>

  <ol>
   <li>
~IF［
%~byte ~IN { 0x81 〜 0xFE }
］
⇒
$gb18030-third ~SET %~byte ~BR
~RET $continue
◎
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 third to byte and return continue.
</li>

   <li>
~byte列 [ $gb18030-second, %~byte ] を %~stream $concept-stream-prepend ~BR
( $gb18030-first, $gb18030-second ) ~SET ( 0x00, 0x00 ) ~BR
~RET $error
◎
Prepend gb18030 second followed by byte to stream, set gb18030 first and gb18030 second to 0x00, and return error.
</li>

  </ol>

 </li>

 <li>
<p>
~IF［
$gb18030-first ~NEQ 0x00
］：
◎
If gb18030 first is not 0x00, run these substeps:
</p>

  <ol>
   <li>
~IF［
%~byte ~IN { 0x30 〜 0x39 }
］
⇒
$gb18030-second ~SET %~byte ~BR
~RET $continue
◎
If byte is in the range 0x30 to 0x39, inclusive, set gb18030 second to byte and return continue.
</li>

   <li>
%~lead ~LET $gb18030-first ~BR
%~pointer ~LET ~NULL ~BR
$gb18030-first ~SET 0x00
◎
Let lead be gb18030 first, let pointer be null, and set gb18030 first to 0x00.
</li>

   <li>
%~offset ~LET ［
%~byte ~IN { 0x00 〜 0x7E } ならば 0x40 ／
~ELSE_ 0x41
］
◎
Let offset be 0x40 if byte is less than 0x7F and 0x41 otherwise.
</li>

   <li>
~IF［
%~byte ~IN { 0x40 〜 0x7E, 0x80 〜 0xFE }
］
⇒
%~pointer ~SET ( %~lead − 0x81 ) × 190 + ( %~byte − %~offset )
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 + (byte − offset).
</li>

   <li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_
$index-gb18030 の中で %~pointer が指す$index-code-point
］
◎
Let code point be null if pointer is null and the index code point for pointer in index gb18030 otherwise.
</li>

   <li>
~IF［
%~cp ~EQ ~NULL
］~AND［
%~byte ~IN $ascii-byte
］
⇒
%~byte を %~stream $concept-stream-prepend
◎
If code point is null and byte is an ASCII byte, prepend byte to stream.
</li>

   <li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET $error
◎
If code point is null, return error.
</li>

   <li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>

  </ol>

 </li>

 <li>
<p>
%~byte に応じて：
◎
↓</p>

  <dl class="switch">
   <dt>$ascii-byte</dt>
   <dd>
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</dd>

   <dt>0x80</dt>
   <dd>
~RET ~cp [ U+20AC ]
◎
If byte is 0x80, return code point U+20AC.
</dd>

   <dt>0x81 〜 0xFE</dt>
   <dd>
$gb18030-first ~SET %~byte ~BR
~RET $continue
◎
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 first to byte and return continue.
</dd>

   <dt>その他（ 0xFF ）</dt>
   <dd>
~RET $error
◎
Return error.
</dd>

  </dl>
 </li>
</ol>


			</section>
			<section id="gb18030-encoder">
<h4 title="gb18030 encoder">11.2.2. gb18030 ~encoder</h4>

<p>
$gb18030の $encoderの各~instanceには、次のものが結付けられる
⇒
@gbk-flag（初期~時 ~OFF ）
◎
gb18030's encoder has an associated GBK flag (initially unset).
</p>

<p>
$gb18030 の$encoderの$handlerは、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
gb18030's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
~IF［
%~cp ~EQ $end-of-stream
］
⇒
~RET $finished
◎
If code point is end-of-stream, return finished.
</li>

 <li>
~IF［
%~cp ~IN $ascii-code-point
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
<p>
~IF［
%~cp ~EQ U+E5E5
］
⇒
~RET %~cp を伴う$error
◎
If code point is U+E5E5, return error with code point.
</p>

<p class="note">注記：
配備済みの内容との互換性をとるため、 $index-gb18030 は［
0xA3 0xA0
］を U+E5E5 ではなく U+3000 に対応付けている。
したがって往来できない。
◎
Index gb18030 maps 0xA3 0xA0 to U+3000 rather than U+E5E5 for compatibility with deployed content. Therefore it cannot roundtrip.
</p>

</li>

 <li>
~IF［
$gbk-flag ~EQ ~ON
］~AND［
%~cp ~EQ U+20AC
］
⇒
~RET ~byte列 [ 0x80 ]
◎
If the GBK flag is set and code point is U+20AC, return byte 0x80.
</li>

 <li>
%~pointer ~LET
$index-gb18030 の中で
%~cp を指す$index-pointer
◎
Let pointer be the index pointer for code point in index gb18030.
</li>

 <li>
<p>
~IF［
%~pointer ~NEQ ~NULL
］：
◎
If pointer is not null, run these substeps:
</p>

  <ol>
   <li>
%~lead ~LET floor( %~pointer ÷ 190 ) + 0x81
◎
Let lead be floor(pointer / 190) + 0x81.
</li>

   <li>
%~trail ~LET %~pointer % 190
◎
Let trail be pointer % 190.
</li>

   <li>
%~offset ~LET ［
%~trail  ~IN { 0x00 〜 0x3E } ならば 0x40<!--0x7F-0x40--> ／
~ELSE_ 0x41
］
◎
Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.
</li>

   <li>
~RET ~byte列 [ %~lead, ( %~trail + %~offset ) ]
◎
Return two bytes whose values are lead and trail + offset.
</li>

  </ol>
 </li>

 <li>
~IF［
$gbk-flag ~EQ ~ON
］
⇒
~RET %~cp を伴う$error
◎
If GBK flag is set, return error with code point.
</li>

 <li>
%~pointer ~SET
%~cp
を指す$index-gb18030-ranges-pointer
◎
Set pointer to the index gb18030 ranges pointer for code point.
</li>

 <li>
%byte1 ~LET floor( %~pointer ÷ 10 ÷ 126 ÷ 10 )
◎
Let byte1 be floor(pointer / 10 / 126 / 10).
</li>

 <li>
%~pointer ~SET %~pointer − %byte1 × 10 × 126 × 10
◎
Set pointer to pointer − byte1 × 10 × 126 × 10.
</li>

 <li>
%byte2 ~LET floor( %~pointer ÷ 10 ÷ 126 )
◎
Let byte2 be floor(pointer / 10 / 126).
</li>

 <li>
%~pointer ~SET %~pointer − %byte2 × 10 × 126
◎
Set pointer to pointer − byte2 × 10 × 126.
</li>

 <li>
%byte3 ~LET floor( %~pointer ÷ 10 )
◎
Let byte3 be floor(pointer / 10).
</li>

 <li>
%byte4 ~LET %~pointer − %byte3 × 10
◎
Let byte4 be pointer − byte3 × 10.
</li>

 <li>
~RET ~byte列 [
( %byte1 + 0x81 ),
( %byte2 + 0x30 ),
( %byte3 + 0x81 ),
( %byte4 + 0x30 )
]
◎
Return four bytes whose values are byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(traditional)-encodings">

<h2 title="Legacy multi-byte Chinese (traditional) encodings">12. 旧来の複byte Chinese （繁体字）~encoding</h2>

<!--
 Lead:  0x81 to 0xFE
 Trail: 0x40 to 0x7E or 0xA1 to 0xFE
-->


		<section id="big5">

<h3 title="Big5">12.1. <b>Big5</b></h3>

			<section id="big5-decoder">
<h4 title="Big5 decoder">12.1.1. Big5 ~decoder</h4>

<div class="p">
<p>
$big5 の$decoderの各~instanceには、次のものが結付けられる
⇒
@big5-lead（初期~時 0x00 ）
</p>
<p>
$big5 の$decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，次を走らす：
</p>
◎
Big5's decoder has an associated Big5 lead (initially 0x00). Big5's decoder's handler, given a stream and byte, runs these steps:
</div>

<ol>
 <li>
<p>
~IF［
%~byte ~EQ $end-of-stream
］：
◎
↓</p>

  <ol>
   <li>
~IF［
$big5-lead ~NEQ 0x00
］
⇒
$big5-lead ~SET 0x00 ~BR
~RET $error
◎
If byte is end-of-stream and Big5 lead is not 0x00, set Big5 lead to 0x00 and return error.
</li>

   <li>
~RET $finished
◎
If byte is end-of-stream and Big5 lead is 0x00, return finished.
</li>

  </ol>
 </li>

 <li>
<p>
~IF［
$big5-lead ~NEQ 0x00
］：
◎
If Big5 lead is not 0x00, let lead be Big5 lead, let pointer be null, set Big5 lead to 0x00, and then run these substeps:
</p>

  <ol>
   <li>
%~lead ~LET $big5-lead ~BR
%~pointer ~LET ~NULL ~BR
$big5-lead ~SET 0x00
◎
↑</li>

   <li>
%~offset ~LET ［
%~byte ~IN { 0x00 〜 0x7E } ならば 0x40 ／
~ELSE_ 0x62 <!-- 0x62 = 0xA1-0x7E+1+0x40 -->
］
◎
Let offset be 0x40 if byte is less than 0x7F and 0x62 otherwise.
</li>

   <li>
~IF［
%~byte ~IN { 0x40 〜 0x7E, 0xA1 〜 0xFE }
］
⇒
%~pointer ~SET ( %~lead − 0x81 ) × 157 + ( %~byte − %~offset )
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1 to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 + (byte − offset).
</li>

   <li>
<p>
~IF［
下の表の中で， 1 列目が %~pointer に等しい行がある
］
⇒
~RET 同じ行の 2 列目の <em>2 個の</em> ~cpからなる$concept-token列
◎
If there is a row in the table below whose first column is pointer, return the two code points listed in its second column (the third column is irrelevant):
</p>

<!-- http://www.unicode.org/Public/UNIDATA/NamedSequences.txt -->
<table><thead><tr><th>~pointer◎Pointer
</th><th>~cp◎Code points
</th><th>説明（この段には無関係）◎Notes
</th></tr></thead>

<tbody><tr><td>1133<!-- 0x88 0x62 -->
</td><td>U+00CA U+0304
</td><td>Ê̄ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON)

</td></tr><tr><td>1135<!-- 0x88 0x64 -->
</td><td>U+00CA U+030C
</td><td>Ê̌ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON)

</td></tr><tr><td>1164<!-- 0x88 0xA3 -->
</td><td>U+00EA U+0304
</td><td>ê̄ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON)

</td></tr><tr><td>1166<!-- 0x88 0xA5 -->
</td><td>U+00EA U+030C
</td><td>ê̌ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON)

</td></tr></tbody></table>
<!-- we do this to avoid PUA -->


<p class="note">注記：
$index は単独の~cpに制限されるので、これらの~pointerにはこの表が利用される。
◎
Since indexes are limited to single code points this table is used for these pointers.
</li>

   <li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ $index-big5 の中で %~pointer が指す$index-code-point
］
◎
Let code point be null if pointer is null and the index code point for pointer in index Big5 otherwise.
</li>

   <li>
~IF［
%~cp ~EQ ~NULL
］~AND［
%~byte ~IN $ascii-byte
］
⇒
%~byte を %~stream $concept-stream-prepend
◎
If code point is null and byte is an ASCII byte, prepend byte to stream.
</li>

   <li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET $error
◎
If code point is null, return error.
</li>

   <li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>

  </ol>

 </li>

 <li>
~IF［
%~byte ~IN $ascii-byte
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>

 <li>
~IF［
%~byte ~IN { 0x81 〜 0xFE }
］
⇒
$big5-lead ~SET %~byte ~BR
~RET $continue
◎
If byte is in the range 0x81 to 0xFE, inclusive, set Big5 lead to byte and return continue.
</li>

 <li>
~RET $error
◎
Return error.
</li>
</ol>

			</section>
			<section id="big5-encoder">
<h4 title="Big5 encoder">12.1.2. Big5 ~encoder</h4>

<p>
$big5 の$encoderの$handlerは、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
Big5's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
~IF［
%~cp ~EQ $end-of-stream
］
⇒
~RET $finished
◎
If code point is end-of-stream, return finished.
</li>

 <li>
~IF［
%~cp ~IN $ascii-code-point
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
%~pointer ~LET %~cp を指す$index-big5-pointer
◎
Let pointer be the index Big5 pointer for code point.
</li>

 <li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う$error
◎
If pointer is null, return error with code point.
</li>

 <li>
%~lead ~LET floor( %~pointer ÷ 157 ) + 0x81
◎
Let lead be floor(pointer / 157) + 0x81.
</li>

 <li>
%~trail ~LET %~pointer % 157
◎
Let trail be pointer % 157.
</li>

 <li>
%~offset ~LET ［
%~trail ~IN { 0x00 〜 0x3E } ならば 0x40<!--0x7F-0x40--> ／
~ELSE_ 0x62<!--0xA1-0x3F-->
］
◎
Let offset be 0x40 if trail is less than 0x3F and 0x62 otherwise.
</li>

 <li>
~RET ~byte列 [ %~lead, ( %~trail + %~offset) ]
◎
Return two bytes whose values are lead and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-japanese-encodings">

<h2 title="Legacy multi-byte Japanese encodings">13. 旧来の複byte Japanese ~encoding</h2>


		<section id="euc-jp">

<h3 title="EUC-JP">13.1. <b>EUC-JP</b></h3>

<!-- https://www.iana.org/assignments/charset-reg/CP51932 -->

			<section id="euc-jp-decoder">
<h4 title="EUC-JP decoder">13.1.1. EUC-JP ~decoder</h4>

<p>
$euc-jp の$decoderの各~instanceには、次のものが結付けられる
⇒
@euc-jp-jis0212-flag（初期~時 ~OFF ）~BR
@euc-jp-lead（初期~時 0x00）
◎
EUC-JP's decoder has an associated EUC-JP jis0212 flag (initially unset) and EUC-JP lead (initially 0x00).
</p>

<p>
$euc-jp の$decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
EUC-JP's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
~IF［
%~byte ~EQ $end-of-stream
］：
◎
↓</p>

  <ol >
   <li>
~IF［
$euc-jp-lead ~NEQ 0x00
］
⇒
$euc-jp-lead ~SET 0x00 ~BR
~RET $error
◎
If byte is end-of-stream and EUC-JP lead is not 0x00, set EUC-JP lead to 0x00, and return error.
</li>

   <li>
~ELSE
⇒
~RET $finished
◎
If byte is end-of-stream and EUC-JP lead is 0x00, return finished.
</li>
  </ol>
 </li>

 <li>
~IF［
$euc-jp-lead ~EQ 0x8E
］~AND［
%~byte ~IN { 0xA1 〜 0xDF }
］
⇒
$euc-jp-lead ~SET 0x00 ~BR
~RET ~cp [ 0xFF61 − 0xA1 + %~byte ]
   <!-- katakana; subtraction is done first to avoid upsetting compilers -->
◎
If EUC-JP lead is 0x8E and byte is in the range 0xA1 to 0xDF, inclusive, set EUC-JP lead to 0x00 and return a code point whose value is 0xFF61 − 0xA1 + byte.
</li>

 <li>
~IF［
$euc-jp-lead ~EQ 0x8F
］~AND［
%~byte ~IN { 0xA1 〜 0xFE }
］
⇒
$euc-jp-jis0212-flag ~SET ~ON ~BR
$euc-jp-lead ~SET %~byte ~BR
~RET $continue
◎
If EUC-JP lead is 0x8F and byte is in the range 0xA1 to 0xFE, inclusive, set the EUC-JP jis0212 flag, set EUC-JP lead to byte, and return continue.
</li>

 <li>
<p>
~IF［
$euc-jp-lead ~NEQ 0x00
］：
◎
If EUC-JP lead is not 0x00, let lead be EUC-JP lead, set EUC-JP lead to 0x00, and run these substeps:
</p>

  <ol>
   <li>
%~lead ~LET $euc-jp-lead ~BR
$euc-jp-lead ~SET 0x00
◎
↑</li>

   <li>
%~cp ~LET ~NULL
◎
Let code point be null.
</li>

   <li>
~IF［
%~lead, %~byte がいずれも ~IN { 0xA1 〜 0xFE }
］
⇒
%索引 ~LET ［
$euc-jp-jis0212-flag ~EQ ~OFF ならば$index-jis0208 ／
~ON ならば［
$index-jis0212
］~BR
%~cp ~SET %索引 の中で
( ( %~lead − 0xA1 ) × 94 + %~byte − 0xA1 )
が指す$index-code-point
◎
If lead and byte are both in the range 0xA1 to 0xFE, inclusive, set code point to the index code point for (lead − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the EUC-JP jis0212 flag is unset and in index jis0212 otherwise.
</li>

   <li>
$euc-jp-jis0212-flag ~SET ~OFF
◎
Unset the EUC-JP jis0212 flag.
</li>

   <li>
~IF［
%~byte ~NIN { 0xA1 〜 0xFE }
］
⇒
%~byte を %~stream $concept-stream-prepend
◎
If byte is not in the range 0xA1 to 0xFE, inclusive, prepend byte to stream.
</li>

   <li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET $error
◎
If code point is null, return error.
</li>

   <li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>

  </ol>

 </li>

 <li>
~IF［
%~byte ~IN $ascii-byte
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>

 <li>
~IF［
%~byte ~IN { 0x8E, 0x8F, 0xA1 〜 0xFE }
］
⇒
$euc-jp-lead ~SET %~byte ~BR
~RET $continue
◎
If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, inclusive, set EUC-JP lead to byte and return continue.
</li>

 <li>
~RET $error
◎
Return error.
</li>

</ol>


			</section>
			<section id="euc-jp-encoder">
<h4 title="EUC-JP encoder">13.1.2. EUC-JP ~encoder</h4>

<p>
$euc-jp の$encoderの$handlerは、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
EUC-JP's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
<p>
%~cp に応じて：
◎
↓</p>
  <dl class="switch">
   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
◎
If code point is end-of-stream, return finished.
</dd>

   <dt>$ascii-code-point</dt>
   <dd>
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

   <dt>U+00A5</dt>
   <dd>
~RET ~byte列 [ 0x5C ]
◎
If code point is U+00A5, return byte 0x5C.
</dd>

   <dt>U+203E</dt>
   <dd>
~RET ~byte列 [ 0x7E ]
◎
If code point is U+203E, return byte 0x7E.
</dd>

   <dt>U+FF61 〜 U+FF9F</dt>
   <dd>
~RET ~byte列 [ 0x8E, ( %~cp − 0xFF61 + 0xA1 ) ]
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, return two bytes whose values are 0x8E and code point − 0xFF61 + 0xA1.
</dd>

   <dt>~OTHER</dt>
   <dd>何もしない</dd>
  </dl>
 </li>

 <li>
~IF［
%~cp ~EQ U+2212
］
⇒
%~cp ~SET U+FF0D
◎
If code point is U+2212, set it to U+FF0D.
</li>

 <li>
%~pointer ~LET $index-jis0208 の中で
%~cp を指す$index-pointer
◎
Let pointer be the index pointer for code point in index jis0208.
</li>

 <li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う$error
◎
If pointer is null, return error with code point.
</li>

 <li>
%~lead ~LET floor( %~pointer ÷ 94 ) + 0xA1
◎
Let lead be floor(pointer / 94) + 0xA1.
</li>

 <li>
%~trail ~LET ( %~pointer % 94 ) + 0xA1
◎
Let trail be pointer % 94 + 0xA1.
</li>

 <li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="iso-2022-jp">

<h3 title="ISO-2022-JP">13.2. <b>ISO-2022-JP</b></h3>

<!--
 https://tools.ietf.org/html/rfc1468
 https://tools.ietf.org/html/rfc2237 (iso-2022-jp-1; not used)
 "ESC ) I" is from iso-2022-jp-3 reportedly
-->

			<section id="iso-2022-jp-decoder">
<h4 title="ISO-2022-JP decoder">13.2.1. ISO-2022-JP ~decoder</h4>

<p>
$iso-2022-jp の$decoderの各~instanceには、次のものが結付けられる
⇒
@iso-2022-jp-decoder-state（初期~時 $iso-2022-jp-decoder-ascii）~BR
@iso-2022-jp-decoder-output-state（初期~時 $iso-2022-jp-decoder-ascii ）~BR
@iso-2022-jp-lead（初期~時 0x00 ）~BR
@iso-2022-jp-output-flag（初期~時 ~OFF ）
◎
ISO-2022-JP's decoder has an associated ISO-2022-JP decoder state (initially ASCII), ISO-2022-JP decoder output state (initially ASCII), ISO-2022-JP lead (initially 0x00), and ISO-2022-JP output flag (initially unset).
</p>

<p>
$iso-2022-jp の$decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，$iso-2022-jp-decoder-stateに応じて 次を走らす：
◎
ISO-2022-JP's decoder's handler, given a stream and byte, runs these steps, switching on ISO-2022-JP decoder state:
</p>

<dl class="switch">
 <dt>@iso-2022-jp-decoder-ascii</dt>
 <dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

  <dl class="switch">
   <dt>0x1B</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape-start ~BR
~RET $continue
◎
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

   <dt>$ascii-byte — ただし， 0x0E, 0x0F, 0x1B は除く</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET ~cp [ %~byte ]
◎
Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</dd>

   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
◎
Return finished.
</dd>

   <dt>~OTHER</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET $error
◎
Unset the ISO-2022-JP output flag and return error.
</dd>
  </dl>
 </dd>

 <dt>@iso-2022-jp-decoder-roman</dt>
 <dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

  <dl class="switch">
   <dt>0x1B</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape-start ~BR
~RET $continue
◎
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

   <dt>0x5C</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET ~cp [ U+00A5 ]
◎
Unset the ISO-2022-JP output flag and return code point U+00A5.
</dd>

   <dt>0x7E</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET ~cp [ U+203E ]
◎
Unset the ISO-2022-JP output flag and return code point U+203E.
</dd>

   <dt>$ascii-byte — ただし， 0x0E, 0x0F, 0x1B, 0x5C, 0x7E は除く</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET a ~cp [ %~byte ]
◎
Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</dd>

   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
◎
Return finished.
</dd>

   <dt>~OTHER</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET $error
◎
Unset the ISO-2022-JP output flag and return error.
</dd>
  </dl>
 </dd>

 <dt>@iso-2022-jp-decoder-katakana</dt>
 <dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

  <dl class="switch">
   <dt>0x1B</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape-start ~BR
~RET $continue
◎
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

   <dt>0x21 〜 0x5F</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET ~cp [ 0xFF61 − 0x21 + %~byte ]
   <!-- katakana; subtraction is done first to avoid upsetting compilers -->
◎
Unset the ISO-2022-JP output flag and return a code point whose value is 0xFF61 − 0x21 + byte.
</dd>

   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
◎
Return finished.
</dd>

   <dt>~OTHER</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET $error
◎
Unset the ISO-2022-JP output flag and return error.
</dd>
  </dl>
 </dd>

 <dt>@iso-2022-jp-decoder-lead-byte</dt>
 <dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

  <dl class="switch">
   <dt>0x1B</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape-start ~BR
~RET $continue
◎
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

   <dt>0x21 〜 0x7E</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
$iso-2022-jp-lead ~SET %~byte ~BR
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-trail-byte ~BR
~RET $continue
◎
Unset the ISO-2022-JP output flag, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to trail byte, and return continue.
</dd>

   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
◎
Return finished.
</dd>

   <dt>~OTHER</dt>
   <dd>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
~RET $error
◎
Unset the ISO-2022-JP output flag and return error.
</dd>
  </dl>
 </dd>

 <dt>@iso-2022-jp-decoder-trail-byte</dt>
 <dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

  <dl class="switch">
   <dt>0x1B</dt>
   <dd>
<p>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape-start ~BR
~RET $error
<!-- iso-2022-jp decoder output state is still lead byte -->
◎
Set ISO-2022-JP decoder state to escape start and return error.
</p>

   <dt>0x21 〜 0x7E</dt>
   <dd>
    <ol>
     <li>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-lead-byte
◎
Set the ISO-2022-JP decoder state to lead byte.
</li>

     <li>
%pointer ~LET ( $iso-2022-jp-lead − 0x21 ) × 94 + %~byte − 0x21
◎
Let pointer be (ISO-2022-JP lead − 0x21) × 94 + byte − 0x21.
</li>
     <li>
%~cp ~LET
$index-jis0208 の中で %~pointer が指す$index-code-point
◎
Let code point be the index code point for pointer in index jis0208.
</li>
     <li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET $error
◎
If code point is null, return error.
</li>
     <li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
    </ol>
   </dd>

   <dt>$end-of-stream</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-lead-byte ~BR
%~byte を %~stream $concept-stream-prepend ~BR
~RET $error
◎
Set the ISO-2022-JP decoder state to lead byte, prepend byte to stream, and return error.
</dd>

   <dt>~OTHER</dt>
   <dd>
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-lead-byte ~BR
~RET $error
<!-- iso-2022-jp decoder output state is still lead byte -->
◎
Set ISO-2022-JP decoder state to lead byte and return error.
</dd>
  </dl>
 </dd>

 <dt>@iso-2022-jp-decoder-escape-start</dt>
 <dd>
  <ol>
   <li>
~IF［
%~byte ~IN { 0x24<!--＄-->, 0x28<!--(--> }
］
⇒
$iso-2022-jp-lead ~SET %~byte ~BR
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-escape ~BR
~RET $continue
◎
If byte is either 0x24 or 0x28, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to escape, and return continue.
</li>

   <li>
%~byte を %~stream $concept-stream-prepend
◎
Prepend byte to stream.
</li>

   <li>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-output-state ~BR
~RET $error
◎
Unset the ISO-2022-JP output flag, set ISO-2022-JP decoder state to ISO-2022-JP decoder output state, and return error.
</li>
  </ol>
 </dd>

 <dt>@iso-2022-jp-decoder-escape</dt>
 <dd>
  <ol>
   <li>
%~lead ~LET $iso-2022-jp-lead ~BR
$iso-2022-jp-lead ~SET 0x00
◎
Let lead be ISO-2022-JP lead and set ISO-2022-JP lead to 0x00.
</li>

   <li>
%状態 ~LET ~NULL
◎
Let state be null.
</li>

   <li>
~IF［
%~lead ~EQ 0x28
］~AND［
%~byte ~EQ 0x42<!--B-->
］
⇒
%状態 ~SET $iso-2022-jp-decoder-ascii
◎
If lead is 0x28 and byte is 0x42, set state to ASCII.
</li>

   <li>
~IF［
%~lead ~EQ 0x28
］~AND［
%~byte ~EQ 0x4A<!--J-->
］
⇒
%状態 ~SET $iso-2022-jp-encoder-roman
◎
If lead is 0x28 and byte is 0x4A, set state to Roman.
</li>

   <li>
~IF［
%~lead ~EQ 0x28
］~AND［
%~byte ~EQ 0x49<!--I-->
］
⇒
%状態 ~SET $iso-2022-jp-decoder-katakana
◎
If lead is 0x28 and byte is 0x49, set state to Katakana.
</li>

   <li>
~IF［
%~lead ~EQ 0x24
］~AND［
%~byte ~IN { 0x40<!--＠-->, 0x42<!--B--> }
］
⇒
%状態 ~SET $iso-2022-jp-decoder-lead-byte
◎
If lead is 0x24 and byte is either 0x40 or 0x42, set state to lead byte.
</li>

   <li>
<p>
~IF［
%状態 ~NEQ ~NULL
］：
◎
If state is non-null, run these substeps:
</p>

    <ol>
     <li>
$iso-2022-jp-decoder-state ~SET %状態 ~BR
$iso-2022-jp-decoder-output-state ~SET %状態
◎
Set ISO-2022-JP decoder state and ISO-2022-JP decoder output state to state.
</li>

     <li>
%出力~flag ~LET $iso-2022-jp-output-flag
◎
Let output flag be the ISO-2022-JP output flag.
</li>

     <li>
$iso-2022-jp-output-flag ~SET ~ON
◎
Set the ISO-2022-JP output flag.
</li>

     <li>
~RET ［
%出力~flag ~EQ ~OFF ならば $continue ／
~ELSE_ $error
］
◎
Return continue, if output flag is unset, and error otherwise.
</li>
    </ol>
   </li>

   <li>
~byte列 [ %~lead, %~byte ] を %~stream $concept-stream-prepend
◎
Prepend lead and byte to stream.
</li>

   <li>
$iso-2022-jp-output-flag ~SET ~OFF ~BR
$iso-2022-jp-decoder-state ~SET $iso-2022-jp-decoder-output-state ~BR
~RET $error
◎
Unset the ISO-2022-JP output flag, set ISO-2022-JP decoder state to ISO-2022-JP decoder output state and return error.
</li>
  </ol>
 </dd>
</dl>

			</section>
			<section id="iso-2022-jp-encoder">
<h4 title="ISO-2022-JP encoder">13.2.2. ISO-2022-JP ~encoder</h4>

<p>
$iso-2022-jp の$encoderの各~instanceには、次のものが結付けられる
⇒
@iso-2022-jp-encoder-state
— これは，［
@iso-2022-jp-encoder-ascii ／
@iso-2022-jp-encoder-roman ／
@iso-2022-jp-encoder-jis0208
］のいずれかをとり得る（初期~時 $iso-2022-jp-encoder-ascii ）。
◎
ISO-2022-JP's encoder has an associated ISO-2022-JP encoder state which is ASCII, Roman, or jis0208 (initially ASCII).
</p>

<p>
$iso-2022-jp の$encoderの$handlerは、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
ISO-2022-JP's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
<p>
~IF［
%~cp ~EQ $end-of-stream
］：
◎
↓</p>

  <ol>
   <li>
~IF［
$iso-2022-jp-encoder-state ~NEQ $iso-2022-jp-encoder-ascii
］
⇒
%~cp を %~stream $concept-stream-prepend ~BR
$iso-2022-jp-encoder-state ~SET $iso-2022-jp-encoder-ascii ~BR
~RET ~byte列 [ 0x1B, 0x28, 0x42 ]
◎
If code point is end-of-stream and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>

   <li>
~RET $finished
◎
If code point is end-of-stream and ISO-2022-JP encoder state is ASCII, return finished.
</li>
  </ol>
 </li>

 <li>
<p>
~IF［
$iso-2022-jp-encoder-state ~IN
{ $iso-2022-jp-encoder-ascii, $iso-2022-jp-encoder-roman }
］~AND［
%~cp ~IN { U+000E, U+000F, U+001B }
］
⇒
~RET U+FFFD を伴う$error
◎
If ISO-2022-JP encoder state is ASCII or Roman, and code point is U+000E, U+000F, or U+001B, return error with U+FFFD.
</p>

<p class="note">
攻撃を防ぐため、これは %~cp ではなく， U+FFFD を返す。
◎
This returns U+FFFD rather than the code point to prevent attacks.
</p>
  <!-- https://github.com/whatwg/encoding/issues/15 -->

 <li>
~IF［
$iso-2022-jp-encoder-state ~EQ $iso-2022-jp-encoder-ascii
］~AND［
%~cp ~IN $ascii-code-point
］
⇒
~RET ~byte列 [ %~cp ]
◎
If ISO-2022-JP encoder state is ASCII and code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
<p>
~IF［
$iso-2022-jp-encoder-state ~EQ $iso-2022-jp-encoder-roman
］
⇒
%~cp に応じて：
◎
If ISO-2022-JP encoder state is Roman and code point is an ASCII code point, excluding U+005C and U+007E, or is U+00A5 or U+203E, run these substeps:
</p>

  <dl class="switch">
   <dt>$ascii-code-point — ただし， U+005C, U+007E は除外する</dt>
   <dd>
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

   <dt>U+00A5</dt>
   <dd>
~RET ~byte列 [ 0x5C ]
◎
If code point is U+00A5, return byte 0x5C.
</dd>

   <dt>U+203E</dt>
   <dd>
~RET ~byte列 [ 0x7E ]
◎
If code point is U+203E, return byte 0x7E.
</dd>

   <dt>~OTHER</dt>
   <dd>何もしない</dd>
  </dl>
 </li>

 <li>
~IF［
%~cp ~IN $ascii-code-point
］~AND［
$iso-2022-jp-encoder-state ~NEQ $iso-2022-jp-encoder-ascii
］
⇒
%~cp を %~stream $concept-stream-prepend ~BR
$iso-2022-jp-encoder-state ~SET $iso-2022-jp-encoder-ascii ~BR
~RET ~byte列 [ 0x1B, 0x28, 0x42 ]
◎
If code point is an ASCII code point, and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>

 <li>
~IF［
%~cp ~NIN { U+00A5, U+203E }
］~AND［
$iso-2022-jp-encoder-state ~NEQ $iso-2022-jp-encoder-roman
］
⇒
%~cp を %~stream $concept-stream-prepend ~BR
$iso-2022-jp-encoder-state ~SET $iso-2022-jp-encoder-roman ~BR
~RET ~byte列 [ 0x1B, 0x28, 0x4A ]
◎
If code point is either U+00A5 or U+203E, and ISO-2022-JP encoder state is not Roman, prepend code point to stream, set ISO-2022-JP encoder state to Roman, and return three bytes 0x1B 0x28 0x4A.
</li>

 <li>
~IF［
%~cp ~EQ U+2212
］
⇒
%~cp ~SET U+FF0D
◎
If code point is U+2212, set it to U+FF0D.
</li>

 <li>
%~pointer ~LET
$index-jis0208 の中で
%~cp を指す$index-pointer
◎
Let pointer be the index pointer for code point in index jis0208.
</li>

 <li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う$error
◎
If pointer is null, return error with code point.
</li>

 <li>
~IF［
$iso-2022-jp-encoder-state ~NEQ $iso-2022-jp-encoder-jis0208
］
⇒
%~cp を %~stream $concept-stream-prepend ~BR
$iso-2022-jp-encoder-state ~SET $iso-2022-jp-encoder-jis0208 ~BR
~RET ~byte列 [ 0x1B, 0x24, 0x42 ]
◎
If ISO-2022-JP encoder state is not jis0208, prepend code point to stream, set ISO-2022-JP encoder state to jis0208, and return three bytes 0x1B 0x24 0x42.
</li>

 <li>
%~lead ~LET floor( %~pointer ÷ 94 ) + 0x21
◎
Let lead be floor(pointer / 94) + 0x21.
</li>

 <li>
%~trail ~LET ( %~pointer % 94 ) + 0x21
◎
Let trail be pointer % 94 + 0x21.
</li>

 <li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="shift_jis">

<h3 title="Shift_JIS">13.3. <b>Shift_JIS</b></h3>


			<section id="shift_jis-decoder">
<h4 title="Shift_JIS decoder">13.3.1. Shift_JIS ~decoder</h4>


<p>
$shift_jis の$decoderの各~instanceには、次のものが結付けられる
⇒
@shift_jis-lead（初期~時 0x00 ）
◎
Shift_JIS's decoder has an associated Shift_JIS lead (initially 0x00).
</p>

<p>
$shift_jis の$decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
Shift_JIS's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
~IF［
%~byte ~EQ $end-of-stream
］：
◎
↓</p>

  <ol>
   <li>
~IF［
$shift_jis-lead ~NEQ 0x00
］
⇒
$shift_jis-lead ~SET 0x00 ~BR
~RET $error
◎
If byte is end-of-stream and Shift_JIS lead is not 0x00, set Shift_JIS lead to 0x00 and return error.
</li>

   <li>
~ELSE
⇒
~RET $finished
◎
If byte is end-of-stream and Shift_JIS lead is 0x00, return finished.
</li>

  </ol>
 </li>

 <li>
<p>
~IF［
$shift_jis-lead ~NEQ 0x00
］：
◎
If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead, let pointer be null, set Shift_JIS lead to 0x00, and then run these substeps:
</p>

  <ol>
   <li>
%~lead ~LET $shift_jis-lead ~BR
%~pointer ~LET ~NULL ~BR
$shift_jis-lead ~SET 0x00
◎
↑</li>

   <li>
%~offset ~LET ［
%~byte ~IN { 0x00 〜 0x7E } ならば 0x40 ／
~ELSE_ 0x41
］
◎
Let offset be 0x40, if byte is less than 0x7F, and 0x41 otherwise.
</li>

   <li>
%~lead~offset ~LET ［
%~lead ~IN { 0x00 〜 0xBF } ならば 0x81 ／
~ELSE_ 0xC1
］
◎
Let lead offset be 0x81, if lead is less than 0xA0, and 0xC1 otherwise.
</li>

   <li>
~IF［
%~byte ~IN { 0x40 〜 0x7E, 0x80 〜 0xFC }
］
⇒
%~pointer ~SET ( %~lead − %~lead~offset ) × 188 + %~byte − %~offset
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFC, inclusive, set pointer to (lead − lead offset) × 188 + byte − offset.
</li>
   <li>
<p>
~IF［
%~pointer ~IN { 8836 〜 10715 }
］
⇒
~RET ~cp [ 0xE000 − 8836 + %~pointer ]
<!-- subtraction is done first to avoid upsetting compilers -->
◎
If pointer is in the range 8836 to 10715, inclusive, return a code point whose value is 0xE000 − 8836 + pointer.
</p>

<p class="note">注記：
これは EUDC として周知の，旧来の Windows によるものと相互運用可能にする。
<!-- PUA -->
◎
This is interoperable legacy from Windows known as EUDC.
</p>


<p class="trans-note">【
EUDC — いわゆる外字のための機能。
】【
8836 = 94 × 94 は Shift_JIS（ JIS X 0208 ）の
<a href="http://ja.wikipedia.org/wiki/%E5%8C%BA%E7%82%B9%E7%95%AA%E5%8F%B7" >区点番号</a>
の総数。
結果の~cpは Unicode 私用領域に入る。
】</p>

   </li>

   <li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ $index-jis0208 の中で %~pointer が指す$index-code-point
］
◎
Let code point be null, if pointer is null, and the index code point for pointer in index jis0208 otherwise.
</li>

   <li>
~IF［
%~cp ~EQ ~NULL
］~AND［
%~byte ~IN $ascii-byte
］
⇒
%~byte を %~stream $concept-stream-prepend
◎
If code point is null and byte is an ASCII byte, prepend byte to stream.
</li>

   <li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET $error
◎
If code point is null, return error.
</li>

   <li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>

  </ol>

 </li>

 <li>
~IF［
%~byte ~IN { $ascii-byte, 0x80}
］
⇒
~RET ~cp [ %~byte ]
<!-- Opera has 0x7E -->
◎
If byte is an ASCII byte or 0x80, return a code point whose value is byte.
</li>

 <li>
~IF［
%~byte ~IN { 0xA1 〜 0xDF }
］
⇒
~RET ~cp [ 0xFF61 − 0xA1 + %~byte ]
 <!-- katakana; subtraction is done first to avoid upsetting compilers -->
◎
If byte is in the range 0xA1 to 0xDF, inclusive, return a code point whose value is 0xFF61 − 0xA1 + byte.
</li>

 <li>
~IF［
%~byte ~IN { 0x81 〜 0x9F, 0xE0 〜 0xFC }
］
⇒
$shift_jis-lead ~SET %~byte ~BR
~RET $continue
◎
If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0 to 0xFC, inclusive, set Shift_JIS lead to byte and return continue.
</li>

 <li>
~RET $error
◎
Return error.
</li>
</ol>

			</section>
			<section id="shift_jis-encoder">
<h4 title="Shift_JIS encoder">13.3.2. Shift_JIS ~encoder</h4>

<p>
$shift_jis の$encoderの$handlerは、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
Shift_JIS's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
<p>
%~cp に応じて：
◎
↓</p>
  <dl class="switch">
   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
◎
If code point is end-of-stream, return finished.
</dd>

   <dt>$ascii-code-point</dt>
   <dt>U+0080</dt>
   <dd>
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point or U+0080, return a byte whose value is code point.
</dd>

   <dt>U+00A5</dt>
   <dd>
~RET ~byte列 [ 0x5C ]
◎
If code point is U+00A5, return byte 0x5C.
</dd>

   <dt>U+203E</dt>
   <dd>
~RET ~byte列 [ 0x7E ]
◎
If code point is U+203E, return byte 0x7E.
</dd>

   <dt>U+FF61 〜 U+FF9F</dt>
   <dd>
~RET ~byte列 [ %~cp − 0xFF61 + 0xA1 ]
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, return a byte whose value is code point − 0xFF61 + 0xA1.
</dd>

   <dt>~OTHER</dt>
   <dd>何もしない</dd>
  </dl>
 </li>

 <li>
~IF［
%~cp ~EQ U+2212
］
⇒
%~cp ~SET U+FF0D
◎
If code point is U+2212, set it to U+FF0D.
</li>

 <li>
%~pointer ~LET
%~cp を指す$index-shift_jis-pointer
◎
Let pointer be the index Shift_JIS pointer for code point.
</li>

 <li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う$error
◎
If pointer is null, return error with code point.
</li>

 <li>
%~lead ~LET floor( %~pointer ÷ 188 )
◎
Let lead be floor(pointer / 188).
</li>

 <li>
%~lead~offset ~LET ［
%~lead ~IN { 0x00 〜 0x1E } ならば 0x81 ／
~ELSE_ 0xC1<!-- 0xA0-0x81 -->
］
◎
Let lead offset be 0x81, if lead is less than 0x1F, and 0xC1 otherwise.
</li>

 <li>
%~trail ~LET %~pointer % 188
◎
Let trail be pointer % 188.
</li>

 <li>
%~offset ~LET ［
%~trail ~IN { 0x00 〜 0x3E } ならば 0x40 ／
~ELSE_ 0x41
］
◎
Let offset be 0x40, if trail is less than 0x3F, and 0x41 otherwise.
</li>

 <li>
~RET ~byte列 [ ( %~lead + %~lead~offset ), ( %~trail + %~offset ) ]
◎
Return two bytes whose values are lead + lead offset and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-korean-encodings">

<h2 title="Legacy multi-byte Korean encodings">14. 旧来の複byte Korean ~encoding</h2>


		<section id="euc-kr">

<h3 title="EUC-KR">14.1. <b>EUC-KR</b></h3>

			<section id="euc-kr-decoder">
<h4 title="EUC-KR decoder">14.1.1. EUC-KR ~decoder</h4>

<p>
$euc-kr の$decoderの各~instanceには、次のものが結付けられる
⇒
@euc-kr-lead（初期~時 0x00 ）
◎
EUC-KR's decoder has an associated EUC-KR lead (initially 0x00).
</p>

<p>
$euc-kr の$decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
EUC-KR's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
~IF［
%~byte ~EQ $end-of-stream
］：
◎
↓</p>

  <ol>
   <li>
~IF［
$euc-kr-lead ~NEQ 0x00
］
⇒
$euc-kr-lead ~SET 0x00 ~BR
~RET $error
◎
If byte is end-of-stream and EUC-KR lead is not 0x00, set EUC-KR lead to 0x00 and return error.
</li>

   <li>
~ELSE
⇒
~RET $finished
◎
If byte is end-of-stream and EUC-KR lead is 0x00, return finished.
</li>
  </ol>
 </li>

 <li>
<p>
~IF［
$euc-kr-lead ~NEQ 0x00
］：
◎
If EUC-KR lead is not 0x00, let lead be EUC-KR lead, let pointer be null, set EUC-KR lead to 0x00, and then run these substeps:
</p>

  <ol>
   <li>
%~lead ~LET $euc-kr-lead ~BR
%~pointer ~LET ~NULL ~BR
$euc-kr-lead ~SET 0x00
◎
↑</li>

   <li>
~IF［
%~byte ~IN { 0x41 〜 0xFE }
］
⇒
%~pointer ~SET ( %~lead − 0x81 ) × 190 + ( %~byte − 0x41 )
◎
If byte is in the range 0x41 to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 + (byte − 0x41).
</li>

   <li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ $index-euc-kr の中で %~pointer が指す$index-code-point
］
◎
Let code point be null, if pointer is null, and the index code point for pointer in index EUC-KR otherwise.
</li>

   <li>
~IF［
%~cp ~EQ ~NULL
］~AND［
%~byte ~IN $ascii-byte
］
⇒
%~byte を %~stream $concept-stream-prepend
◎
If code point is null and byte is an ASCII byte, prepend byte to stream.
</li>

   <li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET $error
◎
If code point is null, return error.
</li>

   <li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
  </ol>

 <li>
~IF［
%~byte ~IN $ascii-byte
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>


 <li>
~IF［
%~byte ~IN { 0x81 〜 0xFE }
］
⇒
$euc-kr-lead ~SET %~byte ~BR
~RET $continue
◎
If byte is in the range 0x81 to 0xFE, inclusive, set EUC-KR lead to byte and return continue.
</li>

 <li>
~RET $error
◎
Return error.
</li>
</ol>

			</section>
			<section id="euc-kr-encoder">
<h4 title="EUC-KR encoder">14.1.2. EUC-KR ~encoder</h4>

<p>
$euc-kr の$encoderの$handlerは、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
EUC-KR's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>
 <li>
~IF［
%~cp ~EQ $end-of-stream
］
⇒
~RET $finished
◎
If code point is end-of-stream, return finished.
</li>

 <li>
~IF［
%~cp ~IN $ascii-code-point
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>

 <li>
%~pointer ~LET
$index-euc-kr の中で
%~cp を指す$index-pointer
◎
Let pointer be the index pointer for code point in index EUC-KR.
</li>

 <li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う$error
◎
If pointer is null, return error with code point.
</li>

 <li>
%~lead ~LET floor( %~pointer ÷ 190 ) + 0x81
◎
Let lead be floor(pointer / 190) + 0x81.
</li>


   <li>
%~trail ~LET ( %~pointer % 190 ) + 0x41
◎
Let trail be pointer % 190 + 0x41.
</li>

 <li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>

<!-- removed from the spec 20130823
13.2 iso-2022-kr id="iso-2022-kr"
-->

	</section>
	<section id="legacy-miscellaneous-encodings">

<h2 title="Legacy miscellaneous encodings">15. その他の旧来の~encoding</h2>

		<section id="replacement">
<h3 title="replacement">15.1. ~replacement</h3>

<p class="note">注記：
$replacement $encodingは、~serverと~clientにおける $encodingの~supportの不一致を突く，ある種の攻撃を防ぐためのものである。
◎
The replacement encoding exists to prevent certain attacks that abuse a mismatch between encodings supported on the server and the client.
</p>

			<section id="replacement-decoder">
<h4 title="replacement decoder">15.1.1. ~replacement~decoder</h4>

<p>
$replacement の$decoderの各~instanceには、次のものが結付けられる
⇒
@replacement-error-returned-flag（初期~時 ~OFF ）
◎
replacement's decoder has an associated replacement error returned flag (initially unset).
</p>

<p>
$replacement の$decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
replacement's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
~IF［
%~byte ~EQ $end-of-stream
］
⇒
~RET $finished
◎
If byte is end-of-stream, return finished.
</li>

 <li>
~IF［
$replacement-error-returned-flag ~EQ ~OFF
］
⇒
$replacement-error-returned-flag ~SET ~ON ~BR
~RET $error
◎
If replacement error returned flag is unset, set the replacement error returned flag and return error.
</li>

 <li>
~RET $finished
◎
Return finished.
</li>
</ol>

<p class="trans-note">【
$replacement には、$encoderはない。
】</p>


			</section>
		</section>
		<section id="common-infrastructure-for-utf-16be-and-utf-16le">

<h3 title="Common infrastructure for UTF-16BE and UTF-16LE">15.2. <span >UTF-16BE</span> と <span >UTF-16LE</span> に共通の基盤</h3>

			<section id="shared-utf-16-decoder">
<h4 title="shared UTF-16 decoder">15.2.1. 共用 UTF-16 ~decoder</h4>

<p class="note">注記：
~BOM（ BOM ）は$labelより優先される。
それは，配備済みの内容において、どの$labelよりも正確aであることが見出されているので。
したがって それは、$shared-utf-16-decoderの一部ではなく，$decode ~algoの一部になる。
◎
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the shared UTF-16 decoder algorithm but rather the decode algorithm.
</p>

<p>
$shared-utf-16-decoderの各~instanceには、次のものが結付けられる
⇒
@utf-16-lead-byte（初期~時 ~NULL ）~BR
@utf-16-lead-surrogate（初期~時 ~NULL ）~BR
@utf-16be-decoder-flag（初期~時 ~OFF ）
◎
shared UTF-16 decoder has an associated UTF-16 lead byte and UTF-16 lead surrogate (both initially null), and UTF-16BE decoder flag (initially unset).
</p>

<p>
$shared-utf-16-decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
shared UTF-16 decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
~IF［
%~byte ~EQ $end-of-stream
］：
◎
↓</p>

  <ol>
   <li>
~IF［
$utf-16-lead-byte ~NEQ ~NULL
］~OR［
$utf-16-lead-surrogate ~NEQ ~NULL
］
⇒
( $utf-16-lead-byte, $utf-16-lead-surrogate ) ~SET ( ~NULL, ~NULL ) ~BR
~RET $error
◎
If byte is end-of-stream and either UTF-16 lead byte or UTF-16 lead surrogate is not null, set UTF-16 lead byte and UTF-16 lead surrogate to null, and return error.
</li>

   <li>
~ELSE
⇒
~RET $finished
◎
If byte is end-of-stream and UTF-16 lead byte and UTF-16 lead surrogate are null, return finished.
</li>
  </ol>
 </li>

 <li>
~IF［
$utf-16-lead-byte ~EQ ~NULL
］
⇒
$utf-16-lead-byte ~SET %~byte ~BR
~RET $continue
◎
If UTF-16 lead byte is null, set UTF-16 lead byte to byte and return continue.
</li>

 <li>
<p>
%~cu ~LET $utf-16be-decoder-flagに応じて，次で与えられる値：
◎
Let code unit be the result of:
</p>
  <dl class="switch">
   <dt>~ON◎UTF-16BE decoder flag is set</dt>
   <dd>
( $utf-16-lead-byte &lt;&lt; 8 ) + %~byte
◎
(UTF-16 lead byte &lt;&lt; 8) + byte.
</dd>
   <dt>~OFF◎UTF-16BE decoder flag is unset</dt>
   <dd>
( %~byte &lt;&lt; 8 ) + $utf-16-lead-byte
◎
(byte &lt;&lt; 8) + UTF-16 lead byte.
</dd>
  </dl>
 </li>

 <li>
$utf-16-lead-byte ~SET ~NULL
◎
Then set UTF-16 lead byte to null.
</li>

 <li>
<p>
~IF［
$utf-16-lead-surrogate ~NEQ ~NULL
］：
◎
If UTF-16 lead surrogate is not null, let lead surrogate be UTF-16 lead surrogate, set UTF-16 lead surrogate to null, and then run these substeps:
</p>

  <ol>
   <li>
%~lead~surrogate ~LET $utf-16-lead-surrogate ~BR
$utf-16-lead-surrogate ~SET ~NULL
◎
↑</li>

   <li>
~IF［
%~cu ~IN { U+DC00 〜 U+DFFF }
］
⇒
~RET ~cp [
0x10000 + ( ( %~lead~surrogate − 0xD800 ) &lt;&lt; 10 ) + ( %~cu − 0xDC00 )
]
◎
If code unit is in the range U+DC00 to U+DFFF, inclusive, return a code point whose value is 0x10000 + ((lead surrogate − 0xD800) &lt;&lt; 10) + (code unit − 0xDC00).
</li>
   <li>
%byte1 ~LET %~cu &gt;&gt; 8
◎
Let bytes be the return value of running these subsubsteps:
◎
Let byte1 be code unit &gt;&gt; 8.
</li>
   <li>
%byte2 ~LET %~cu &amp; 0x00FF
◎
Let byte2 be code unit &amp; 0x00FF.
</li>
   <li>
<p>
［
%~utf-16be~flag に応じて，次で与えられる~byte列
］を %~stream $concept-stream-prepend：
◎
Then return the bytes in order, switching on UTF-16BE decoder flag:
</p>
     <dl class="switch">
      <dt>~ON◎Set</dt>
      <dd>
~byte列 [ %byte1, %byte2 ]
◎
byte1, then byte2.
</dd>
      <dt>~OFF◎Unset</dt>
      <dd>
~byte列 [ %byte2, %byte1 ]
◎
byte2, then byte1.
</dd>
     </dl>
   </li>
   <li>
~RET $error
◎
Prepend the bytes to stream and return error.
</li>
   <!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->

  </ol>
 </li>

 <li>
~IF［
%~cu ~IN { U+D800 〜 U+DBFF }
］
⇒
$utf-16-lead-surrogate ~SET %~cu ~BR
~RET $continue
◎
If code unit is in the range U+D800 to U+DBFF, inclusive, set UTF-16 lead surrogate to code unit and return continue.
</li>

 <li>
~IF［
%~cu ~IN { U+DC00 〜 U+DFFF }
］
⇒
~RET $error
<!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->
◎
If code unit is in the range U+DC00 to U+DFFF, inclusive, return error.
</li>

 <li>
~RET ~cp [ %~cu ]
◎
Return code point code unit.
</li>
</ol>


			</section>
		</section>
		<section id="utf-16be">

<h3 title="UTF-16BE">15.3. <b>UTF-16BE</b></h3>


			<section id="utf-16be-decoder">
<h4 title="UTF-16BE decoder">15.3.1. UTF-16BE ~decoder</h4>


<p>
$utf-16be の$decoderは、［
$utf-16be-decoder-flag ~SET ~ON
］にされた$shared-utf-16-decoderである。
◎
UTF-16BE's decoder is shared UTF-16 decoder with its UTF-16BE decoder flag set.
</p>


			</section>
		</section>

		<section id="utf-16le">

<h3 title="UTF-16LE">15.4. <b>UTF-16LE</b></h3>

<p class="note">注記：
配備済みの内容に対処するため、 `%utf-16, `%utf-16le のいずれも $utf-16le のための$labelにされている。
◎
Both "utf-16" and "utf-16le" are labels for UTF-16LE to deal with deployed content.
</p>

			<section id="utf-16le-decoder">
<h4 title="UTF-16LE decoder">15.4.1. UTF-16LE ~decoder</h4>


<p>
$utf-16be の$decoderは、$shared-utf-16-decoderである。
◎
UTF-16LE's decoder is shared UTF-16 decoder.
</p>

			</section>
		</section>

		<section id="x-user-defined">

<h3 title="x-user-defined">15.5. <b>x-user-defined</b></h3>

<p class="note">注記：
これは技術的には$single-byte-encodingであるが、~algo的に実装し得るので，別々に定義される。
<!--
This encoding is silly, however, the web depends on it:

http://krijnhoetmer.nl/irc-logs/whatwg/20121003#l-461
http://krijnhoetmer.nl/irc-logs/whatwg/20121010#l-812

https://stackoverflow.com/questions/6986789/why-are-some-bytes-prefixed-with-0xf7-when-using-charset-x-user-defined-with-xm
-->
◎
While technically this is a single-byte encoding, it is defined separately as it can be implemented algorithmically.
</p>

			<section id="x-user-defined-decoder">
<h4 title="x-user-defined decoder">15.5.1. x-user-defined ~decoder</h4>

<p>
$x-user-defined の$decoderの$handlerは、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
x-user-defined's decoder's handler, given a stream and byte, runs these steps:
</p>

<ol>
 <li>
<p>
%~byte に応じて：
◎
↓</p>
  <dl class="switch">
   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
◎
If byte is end-of-stream, return finished.
</dd>

   <dt>$ascii-byte</dt>
   <dd>
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</dd>

   <dt>~OTHER</dt>
   <dd><p >
~RET ~cp [ 0xF780 + %~byte − 0x80 ]
◎
Return a code point whose value is 0xF780 + byte − 0x80.
</dd>
  </dl>
 </li>
</ol>

			</section>
			<section id="x-user-defined-encoder">
<h4 title="x-user-defined encoder">15.5.2. x-user-defined ~encoder</h4>

<p>
$x-user-defined の$encoderの$handlerは、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
x-user-defined's encoder's handler, given a stream and code point, runs these steps:
</p>

<ol>

 <li>
<p>
%~cp に応じて：
◎
↓</p>
  <dl class="switch">
   <dt>$end-of-stream</dt>
   <dd>
~RET $finished
◎
If code point is end-of-stream, return finished.
</dd>

   <dt>$ascii-code-point</dt>
   <dd>
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

   <dt>U+F780 〜 U+F7FF</dt>
   <dd>
~RET ~byte列 [ %~cp − 0xF780 + 0x80 ]
◎
If code point is in the range U+F780 to U+F7FF, inclusive, return a byte whose value is code point − 0xF780 + 0x80.
</dd>

   <dt>~OTHER</dt>
   <dd>
~RET %~cp を伴う$error
◎
Return error with code point.
</dd>
  </dl>
 </li>
</ol>

			</section>
		</section>
	</section>
	<section id="browser-ui">

<h2 title="Browser UI">16. ~browser UI</h2>

<p>
~browserには、資源の~encodingに対する上書きを可能化させないことが奨励される。
にもかかわらず，その種の特色機能が在する場合、前述の
<a href="#security-background">~security上の課題</a>
から，~browserは， $utf-16be／$utf-16le を~optionとして提供0する~SHOULDでない。
~browserは、資源が$utf-16be／$utf-16leを利用して~decodeされた場合でも，この特色機能を不能化する~SHOULDである。
◎
Browsers are encouraged to not enable overriding the encoding of a resource. If such a feature is nonetheless present, browsers should not offer either UTF-16BE or UTF-16LE as option due to aforementioned security issues. Browsers also should disable this feature if the resource was decoded using either UTF-16BE or UTF-16LE.
</p>

	</section>

</main><!-- id="MAIN" -->

	<section id="references">

<h2 title="References">参照文献</h2>

<dl>
 <dt>[DOM]</dt>
 <dd>
<cite><a href="https://dom.spec.whatwg.org/">DOM</a></cite>, Anne van Kesteren, Aryeh Gregor and Ms2ger. WHATWG.</dd>

 <dt>[HTML]</dt>
 <dd>
(Non-normative) <cite><a href="https://html.spec.whatwg.org/multipage/">HTML</a></cite>, Ian Hickson. WHATWG.</dd>

 <dt>[RFC2119]</dt>
 <dd>
<cite><a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a></cite>, Scott Bradner. IETF.</dd>

 <dt>[UNICODE]</dt>
 <dd>
<cite><a href="http://www.unicode.org/versions/latest/">Unicode Standard</a></cite>. Unicode Consortium.</dd>

 <dt>[URL]</dt>
 <dd>
(Non-normative) <cite><a href="https://url.spec.whatwg.org/">URL</a></cite>, Anne van Kesteren. WHATWG.</dd>

 <dt>[WEBIDL]</dt>
 <dd>
<cite><a href="https://heycam.github.io/webidl/">Web IDL</a></cite>, Cameron McCormack. W3C.
 </dd>

 <dt>[XML]</dt>
 <dd>
(Non-normative) <cite><a href="https://www.w3.org/TR/xml/">Extensible Markup Language</a></cite>, Tim Bray, Jean Paoli, C. M. Sperberg-McQueen et al.. W3C.</dd>

</dl>

	</section>
	<section id="acknowledgments">

<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り、符号化方式を相互運用可能なものにするために，たくさんの方々が助力され、この標準の目標へ近付けてきた。
同様に多くの方々の助力が，この標準を現在の姿に仕立て上げてきた。
特に，次の方々に感謝する：
<span lang="en">
There have been a lot of people that have helped make encodings more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</span></p>

<p>
With that, many thanks to

Adam Rice,
Alan Chaney,
Alexander Shtuchkin,
Allen Wirfs-Brock,
Aneesh Agrawal,
Arkadiusz Michalski,
Asmus Freytag,
Ben Noordhuis,
Boris Zbarsky,
Cameron McCormack,
Charles McCathieNeville,
David Carlisle,
Domenic Denicola,
Dominique Hazaël-Massieux,
Doug Ewell,
Erik van der Poel,
譚永鋒 (Frank Yung-Fong Tang),
Geoffrey Sneddon,
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
James Graham,
Jeffrey Yasskin,
John Tamplin,
Joshua Bell,
村井純 (Jun Murai),
신정식 (Jungshik Shin),
Jxck,
강 성훈 (Kang Seonghoon),<!-- space is intentional: https://www.w3.org/Bugs/Public/show_bug.cgi?id=27675#c2 -->
川幡太一 (Kawabata Taichi),
Ken Lunde,
Ken Whistler,
Kenneth Russell,
田村健人 (Kent Tamura),
Leif Halvard Silli,
Makoto Kato,
Mark Callow,
Mark Crispin,
Mark Davis,
Martin Dürst,
Masatoshi Kimura,
Ms2ger,
Nigel Megitt,
Nigel Tao,
Norbert Lindenberg,
Øistein E. Andersen,
Peter Krefting,
Philip Jägenstedt,
Philip Taylor,
Richard Ishida,
Robbert Broersma,
Robert Mustacchi,
Ryan Dahl,
Shawn Steele,
Simon Montagu,
Simon Pieters,
Simon Sapin,
寺田健 (Takeshi Terada),
Vyacheslav Matva, and
成瀬ゆい (Yui Naruse)

for being awesome.
</p>

	</section>

<p>
この標準は、
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a> （
<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>
）により書かれた。
当初の <a href="#api">API</a> 節は、
Joshua Bell （
<a href="https://www.google.com/">Google</a>)
）により書かれた。
<span lang="en">
This standard is written by Anne van Kesteren (Mozilla, annevk@annevk.nl). The API chapter was initially written by Joshua Bell (Google).
</span></p>

<p>
Per <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>, to
the extent possible under law, the editors have waived all copyright and related or
neighboring rights to this work.
</p>

</body>
