<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Encoding Standard — 符号化方式 標準（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://encoding.spec.whatwg.org/',
		main: 'MAIN',
		ref_data: '.ref_data',
		ref_id_prefix: 'refs'
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked 170505 spec.

	return options;
}

function expand(mapping1){

	var class_map = {
		E: 'error',
		n: 'ename',
		U: 'code-point',
		X: 'hex-value',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		n: 'b',
		U: 'span',
		X: 'span',
		i: 'i',
		i1: 'i',
		V: 'var',
	};

	var link_map = this.link_map;
	var index_template = '\
<a href="~ENCSPEC/index-ｎ.txt">index-ｎ.txt</a>\
<td><a href="~ENCSPEC/ｎ.html">索引 <b class="ename">Ｎ</b> 視覚化</a>\
<td><a href="~ENCSPEC/ｎ-bmp.html">索引 <b class="ename">Ｎ</b> BMP 被覆域</a>\
';

	E('MAIN').innerHTML = Util.generateSource(this, mapping1, function(source){
		return source.replace(
			/%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		);
	});
	return;

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return '<var>' + match.slice(1) + '</var>'
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'lb': // label
	text = '"<code class="label">' + text + '</code>"';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'n': // encoding name
	href = '#' + key.toLowerCase();
	break;
case 'U': // Unicode code point
	text = 'U+' + key;
	break;
case 'X': // byte value
	text = '0x' + key;
	break;
case 'idx':
	return ( index_template
		.replace(/ｎ/g, key.toLowerCase())
		.replace(/Ｎ/g, key)
	);
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<!--% リンク置換データ -->

<script type="text/plain" id="_link_map">
	●IDL
E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.TypeError:~WEBIDL#exceptiondef-typeerror

I.TextDecoderOptions:#textdecoderoptions
I.TextDecodeOptions:#textdecodeoptions
I.TextDecoder:#textdecoder
I.TextEncodeOptions:#textencodeoptions
I.TextEncoder:#textencoder
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.Uint32Array:~WEBIDL#idl-Uint32Array

Uint8Array:~WEBIDL#idl-Uint8Array
USVString:~WEBIDL#idl-USVString
DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean


m.TextDecoder:#dom-textdecoder
m.encoding:#dom-textdecoder-encoding
m.fatal:#dom-textdecoder-fatal
m.ignoreBOM:#dom-textdecoder-ignorebom

m.decode:#dom-textdecoder-decode
m.TextEncoder:#dom-textencoder
m.~encoding0:#dom-textencoder-encoding
m.encode:#dom-textencoder-encode

	●
投出-:~WEBIDL#dfn-throw

~byte:~INFRA#byte
~ASCII~byte:~INFRA#ascii-byte
~cp:~INFRA#code-point
~scalar値:~INFRA#scalar-value
~ASCII~cp:~INFRA#ascii-code-point
~ASCII空白:~INFRA#ascii-whitespace
~ASCII数字:~INFRA#ascii-digit
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化:~INFRA#ascii-lowercase

~encoding:#encoding
名前:#name
~label:#label
~decoder:#decoder
~decode:#decode
~UTF-8~decode:#utf-8-decode
~BOMはそのままに~UTF-8~decode:#utf-8-decode-without-bom
~BOMも失敗-もそのままに~UTF-8~decode:#utf-8-decode-without-bom-or-fail
~UTF-8~encode:#utf-8-encode
~encode:#encode
~encoder:#encoder
~handler:#handler
~error~mode:#error-mode
~error:#error
完遂:#finished
継続:#continue
~EoS:#end-of-stream

~encodingを取得-:#concept-encoding-get
出力~encodingを取得-:#get-an-output-encoding
~token:#concept-token
~stream:#concept-stream
読取った結果:#concept-stream-read
前付加する:#concept-stream-prepend
前付加-:#concept-stream-prepend
~pushする:#concept-stream-push
走らす:#concept-encoding-run
~tokenを処理-:#concept-encoding-process

	●
索引:#index
索引~cp:#index-code-point
索引~pointer:#index-pointer
索引~Big5~pointer:#index-big5-pointer
索引~Big5:#index-big5
索引~EUC-KR:#index-euc-kr
索引~jis0208:#index-jis0208
索引~jis0212:#index-jis0212
索引~Shift_JIS~pointer:#index-shift_jis-pointer
索引~ISO-2022-JP~katakana:#index-iso-2022-jp-katakana
索引~gb18030範囲集:#index-gb18030-ranges
索引~gb18030範囲集~cp:#index-gb18030-ranges-code-point
索引~gb18030範囲集~pointer:#index-gb18030-ranges-pointer

索引~gb18030:#index-gb18030

~UTF-8~cp:#utf-8-code-point
~UTF-8出現~byte数:#utf-8-bytes-seen
~UTF-8要~byte数:#utf-8-bytes-needed
~UTF-8下限:#utf-8-lower-boundary
~UTF-8上限:#utf-8-upper-boundary

単byte~encoding:#single-byte-encoding
単byte索引:#index-single-byte


	●名前
	n.UTF-8:#utf-8
	n.IBM866:#ibm866
	n.ISO-8859-2:#iso-8859-2
	n.ISO-8859-3:#iso-8859-3
	n.ISO-8859-4:#iso-8859-4
	n.ISO-8859-5:#iso-8859-5
	n.ISO-8859-6:#iso-8859-6
	n.ISO-8859-7:#iso-8859-7
	n.ISO-8859-8:#iso-8859-8
	n.ISO-8859-8-I:#iso-8859-8-i
	n.ISO-8859-10:#iso-8859-10
	n.ISO-8859-13:#iso-8859-13
	n.ISO-8859-14:#iso-8859-14
	n.ISO-8859-15:#iso-8859-15
	n.ISO-8859-16:#iso-8859-16
	n.KOI8-R:#koi8-r
	n.KOI8-U:#koi8-u
	n.macintosh:#macintosh
	n.windows-874:#windows-874
	n.windows-1250:#windows-1250
	n.windows-1251:#windows-1251
	n.windows-1252:#windows-1252
	n.windows-1253:#windows-1253
	n.windows-1254:#windows-1254
	n.windows-1255:#windows-1255
	n.windows-1256:#windows-1256
	n.windows-1257:#windows-1257
	n.windows-1258:#windows-1258
	n.x-mac-cyrillic:#x-mac-cyrillic

	n.GBK:#gbk
	n.gb18030:#gb18030
	n.Big5:#big5
	n.EUC-JP:#euc-jp
	n.ISO-2022-JP:#iso-2022-jp
	n.Shift_JIS:#shift_jis
	n.EUC-KR:#euc-kr
	n.replacement:#replacement
	n.UTF-16LE:#utf-16le
	n.UTF-16BE:#utf-16be
	n.x-user-defined:#x-user-defined

	●encoder／decoder IDL
dec.~encoding:#textdecoder-encoding
dec.~decoder:#textdecoder-decoder
dec.~stream:#textdecoder-stream
dec.~BOMignore~flag:#textdecoder-ignore-bom-flag
dec.~BOMseen~flag:#textdecoder-bom-seen-flag
dec.~error~mode:#textdecoder-error-mode
dec.~no_flush~flag:#textdecoder-do-not-flush-flag
dec.直列化-:#concept-td-serialize

enc.~encoder:#textencoder-encoder

	●各種 encoder／decoder

~UTF-8~decoder:#utf-8-decoder
~UTF-8~encoder:#utf-8-encoder
共用~UTF-16~decoder:#shared-utf-16-decoder
~replacement~decoder:#replacement-decoder
~replacementによる~errorはすでに返した~flag:#replacement-error-returned-flag

単byte~decoder:#single-byte-decoder
単byte~encoder:#single-byte-encoder

~GBK~flag:#gbk-flag

~gb1:#gb18030-first
~gb2:#gb18030-second
~gb3:#gb18030-third

~gb18030~decoder:#gb18030-decoder
~gb18030~encoder:#gb18030-encoder

~Big5~lead:#big5-lead
~Big5~decoder:#big5-decoder
~Big5~encoder:#big5-encoder

~EUC-JP~lead:#euc-jp-lead
~EUC-JP~jis0212~flag:#euc-jp-jis0212-flag
~EUC-JP~decoder:#euc-jp-decoder
~EUC-JP~encoder:#euc-jp-encoder

~ISO-2022-JP~decoder:#iso-2022-jp-decoder
~ISO-2022-JP~encoder:#iso-2022-jp-encoder

~ISO-2022-JP~decoder状態:#iso-2022-jp-decoder-state
~ISO-2022-JP~decoder出力~状態:#iso-2022-jp-decoder-output-state
~ISO-2022-JP~lead:#iso-2022-jp-lead
~ISO-2022-JP出力~flag:#iso-2022-jp-output-flag

i.ASCII:#iso-2022-jp-decoder-ascii
i.Roman:#iso-2022-jp-decoder-roman
i.katakana:#iso-2022-jp-decoder-katakana
i.~lead~byte:#iso-2022-jp-decoder-lead-byte
i.~trail~byte:#iso-2022-jp-decoder-trail-byte
i.~escape開始:#iso-2022-jp-decoder-escape-start
i.~escape:#iso-2022-jp-decoder-escape

~ISO-2022-JP~encoder状態:#iso-2022-jp-encoder-state
i1.ASCII:#iso-2022-jp-encoder-ascii
i1.Roman:#iso-2022-jp-encoder-roman
i1.jis0208:#iso-2022-jp-encoder-jis0208

~Shift_JIS~lead:#shift_jis-lead
~Shift_JIS~decoder:#shift_jis-decoder
~Shift_JIS~encoder:#shift_jis-encoder

~EUC-KR~lead:#euc-kr-lead
~EUC-KR~decoder:#euc-kr-decoder
~EUC-KR~encoder:#euc-kr-encoder

~UTF-16~lead~byte:#utf-16-lead-byte
~UTF-16~lead~surrogate:#utf-16-lead-surrogate
~UTF-16~decoder:#utf-16-decoder
~UTF-16LE~decoder:#utf-16le-decoder
~UTF-16BE~decoder:#utf-16be-decoder
~UTF-16BE~decoder~flag:#utf-16be-decoder-flag

~x-user-defined~decoder:#x-user-defined-decoder
~x-user-defined~encoder:#x-user-defined-encoder

	~byte列に変換-:#convert-a-code-unit-to-bytes

indexes.json:~ENCSPEC/indexes.json


</script>


<!--% 置換データ -->

<script type="text/plain" id="words_table1">
ENCSPEC:https://encoding.spec.whatwg.org
BR:；<br>
bAND: <span class="op">&amp;</span> 
bOR: <span class="op">|</span> 
Lshift: <span class="op">&lt;&lt;</span>
Rshift: <span class="op">&gt;&gt;</span>

encoding0:encoding
UTF-8:<b class="ename">UTF-8</b> 
GBK:<b class="ename">GBK</b> 
gb18030:<b class="ename">gb18030</b> 
Big5:<b class="ename">Big5</b> 
EUC-JP:<b class="ename">EUC-JP</b> 
ISO-2022-JP:<b class="ename">ISO-2022-JP</b> 
Shift_JIS:<b class="ename">Shift_JIS</b> 
EUC-KR:<b class="ename">EUC-KR</b> 
jis0208:<b class="ename">jis0208</b> 
jis0212:<b class="ename">jis0212</b> 
replacement:<b class="ename">replacement</b> 
UTF-16BE:<b class="ename">UTF-16BE</b> 
UTF-16LE:<b class="ename">UTF-16LE</b> 
x-user-defined:<b class="ename">x-user-defined</b> 
</script>


<!--% 語彙置換データ -->
<script type="text/plain" id="words_table">
	●仕様
API:
algo:algorithm:::アルゴリズム
手続き:steps:~
段:step:~
UA:user agent:UA:::ユーザエージェント
技術的には:technical には:形の上では
歴史的:historical:~
規範的:normative:~
	規範的でない:non-normative:~
統一的:universal:~
適切:appropriate:~
互換性:compatibility:~
互換:compatible:~
非互換:incompatible:~
理由:reason:~
特色機能:feature:~
課題:issue:~
問題:problem:~
違法:illegal:~
自明:trivial:~
基本的:basic:~
網羅的:exhaustive:~
共通の:common:~
基盤:infrastructure:~
有意:significant:~
保守的:conservative:~
合法:legitimate:~
移行-:move:~
重要:important:~
特別な:special:~
完全さ:completeness:~
仕組み:mechanism:~
事例:case:~
各種用語:terminology:~
意味論:semantics:~
旧来の:legacy:~
標準:standard:~
関係ない:irrelevant:~
仕様:spec:~
	省略時は:optional
文脈:context:~
browser::::ブラウザ
proprietary::::プロプライエタリ
platform::::プラットフォーム
リバースエンジニア:reverse engineer:~
保安:security::~:セキュリティ
効率的:efficient:~

背景:background:~
有用:useful:~
強く:strong に:~
仕方:way:~
簡明:clear:~
隔たり:gap:~
詳細:details:~
進行中:ongoing:~
過去:past:~
共通的に:common に:よく
資質:nature:~
凡例:legend:~
考慮点:considerations:~
能:ability:~
	目標:goal
	助力:help
	~~標準の:The
	~~考慮
	一式で:in combination with
	より~~一般的には:larger
	備考
	入手できる:available
	則って
	~~十分:fine
	様に
	広く:widespread
	序:Preface
	要-
	不要:no need
	必要:necessary／need／
	決して
	見かけ上:superficially
	説明:Notes
	限らない
	にもかかわらず:nonetheless
	あいにく:unfortunately
	後の:future
	~~不正な:bogus
	例
	例えば
	注記
	特に:In particular
	関する:-

	●仕様（動詞
support::::サポート
追加の:additional:~
避ける:avoid する:~
影響-:affect:~
利用者:user:~
利用-:use:~
利用:use:~
利用中の:in use の:~
波及-:influence:~
意図的:intentional:~
意図-:intend:~
除外-:exclude:~
除外:exclusion:~
排他的:exclusive:~
既存の:existing:~
作者:author:~
提供-:provide:~
提供0-:offer:提供
収束:converge:~
相互運用可能:interoperable:~
究明:investigation:~
末端利用者:end user:~
可能化-:enable:~
不能化-:disable:~
報告-:report:~
解釈:interpretation:~
制御:control:~
未知の:unknown:~
拘束:constraints:~
拘束-:constrain:~
制約的:restrictive:~
奨励-:encourage:~
	促す
拡散-:spread:~
逸脱-:deviate:~
判別-:distinguish:~
開発者:developer:~
義務付けら:mandate さ:~
要求-:require:~
取組む:address する:取り組む
制限-:limit:~
働く:work する:~
拡張-:extend:~
拡張:extension:~
既定:default:~
fallback:::フォールバック
実装-:implement:~
実装:implementation:~
定義-:define:~
定義:definition:~
未定義:undefined:~
最適化-:optimize:~
依存-:depend:~
公開-:expose:~
共用:shared::~
共有-:share:~
流布-:deploy:~
配備済みの:deployed:~
許可-:permit:~
生産側:producer:生産側
生産-:produce:生産
消費側:consumer:~
消費者:consumer:~
誘発-:trigger:~
違反:violation:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
要旨した:outline した:要旨を述べた
霧消-:go away:~
挙動:behavior:ふるまい
	周知の:known:
	対処-:deal with
	扱い:dealing with
	準じる:match
	知られ:known／
		追い易く:easy to follow
	挙げ-:list
	示され:-
	呼ぶ:-
	埋める:-
	壊す:break
	変わって:change
	見えない:not see
	見よ:see
	記され
	記す

	●動詞（未分類
継続:continue::~
完遂:finished::~
実行:execution:~
走らす:run する:走らせる
走らせ:run し:~
返す:return する:~
返さ:return し:~
返され:return され:~
返した:return した:~
繰返:繰り返
読取れる:read できる::読み取れる
読取る:read する::読み取る
読取られ:read され::読み取られ
読取った:read した::読み取った
	読取結果:読み取った結果
	unread:〜を元に戻す
push:::::プッシュ
前付加-:prepend::~
付加-:append::~
挿入-:insert::~
合致-:match:~
断片化:fragment 化:~
対応関係:mapping:~
対応付ける:map する:~
対応付けて:map して:~
対応付けら:map さ:~
変換-:convert:~
表現-:represent:~
識別-:identify:~
除去-:remove:~
前置-:prefix::~
重複-:duplicate:~
分割:split:~
設定-:set:~
構文解析:parsing::~::パース処理
直列化-:serialize::~::シリアル化
処理-:process::~
処理器:processor::~::プロセッサ
入力:input::~
出力:output::~
	~~出力:emit
開始:start:~
包含-:contain:~
生成-:generate:~
結付けら:associate さ:結び付けら
見出す:find する:~
見出され:find され:~
終了-:terminate:~
保全-:preserve:~
往来-:roundtrip:~
参照-:reference:~
存在-:exist:~
包装-:wrap:~
在する:present する:在る
呼出して:invoke して:呼び出して
呼出す:invoke する:呼び出す
呼出時:invoke 時:呼び出し時
変化:changes:~
変更:changes:~
変更-:change:~
検査-:check:~
移動-:move:~
call:
	持つ
	一新-:set anew
	所与の:given
	与え:give
	転換-:turn
	失わせ:loss
	戻す:back
	出くわし:hit
	~~空いた:newly-vacated
	含まれ／含められ／含んで:include
	表す:signify
	対:combination
	被せた:Layering 〜  on top
	供する:-
	加え
	指-:-
	得られ:-
	得る:-
	終える:-
	行う

	●network／保安
URL:
protocol::::プロトコル
header::::ヘッダ
server::::サーバ
client::::クライアント
資源:resource::~:リソース
form::::フォーム
提出:submission::~
手入力:enter:~
攻撃:attack:~
攻撃者:attacker:~
防ぐ:prevent する:~
注入-:inject:~
注意深く:careful に:~
細工:craft:~
情報喪失:information loss:~
安全:safe:~
上書き:override:~
合意:agree:~
不一致:mismatch:~
交換:interchange:~
隠す:mask する:~
隠せな:mask できな:~
	突く:abuse
	至らせ:resulting in
	~~検知されることなく:silent

	●符号化方式
Unicode:
CJK:
block::::ブロック
私用領域:Private Use Area:~
	香港増補字符集
	基本多言語面
	互換漢字

gb1:
gb2:
gb3:
jis0212:
jis0208:
	Roman
utf-16be:
UTF-16:
Hangul:::ハングル

byte::::バイト
単byte:single-byte::単 byte:単バイト:シングルバイト
複byte:multi-byte::複 byte:複バイト:マルチバイト
surrogate::::サロゲート
scalar::::スカラー
flag::::フラグ
cp:code point::符号位置::コードポイント
cu:code unit::符号単位::コードユニット
索引:index::~::インデックス
pointer::::ポインタ
符号化文字集合:coded character set::~

BOM:
BOMseen:BOM seen:BOM 確認済み
BOMignore:ignore BOM:BOM 無視
簡体字:simplified::~
繁体字:traditional::~
ASCII:
空:empty:~
文字列:string:~
文字:character:~
小文字:lowercase:~
内容:content:~
範囲:range::~
範囲集:ranges::~
空白:whitespace:~
大小無視:case-insensitive:~
数字:digit:~

code::::コード
encode:::符号化::エンコード
encoding:::符号化方式::エンコーディング
encoder:::符号化器::エンコーダ
decode:::復号::デコード
decoder:::復号器::デコーダ
label::::ラベル
正準的:canonical::~
形式:format::データ形式::フォーマット

半角:halfwidth::~
全角:fullwidth::~
katakana::::カタカナ

	●
list::::リスト
table::::テーブル
entry::::エントリ

error::::エラー
名前:name::~
名:name::~
下限:lower boundary::~
上限:upper boundary::~
offset:
token::::トークン
stream::::ストリーム
streaming::::ストリーム処理
no_flush:do not flush:状態維持
EoS:end-of-stream::stream 終端:ストリーム終端
状態:state::~::ステート
escape:escape 
lead:::頭部
trail:::尾部
	頭部と尾部:leading and trailing
handler::::ハンドラ
instance::::インスタンス
mode::::モード
coder:
	出現~byte数:byte seen
	fatal:
失敗-:fail::~
失敗:failure::~


視覚化:visualization:~
被覆域:coverage:~
覆う:cover する:~
layout::::レイアウト
literal::::リテラル
data::::データ
bit::::ビット
shift::::シフト
hook::::フック
buffer::::バッファ
option::::オプション
script::::スクリプト
field::::フィールド

論理:logical:~
範囲検査:limit check:~
区画:area::~
複製:copy:~
一意:unique:~
一覧:table:~
値:value:~
	〜が返す値:〜の return value
配列:array::~
	算術式:equation:~
順序:order:~
有順序:ordered:~
加算:addition:~
減算:subtraction:~
乗算:multiplication:~
除算:division:~
剰余:remainder:~
区切子:delimiter:~

整数:integer:~
基数:base:~
	長さ:length

	●
HTML:
obj:object:::オブジェクト
method:::メソッド
interface:::インタフェース
構築子:constructor::~::コンストラクタ
取得子:getter:~
取得-:get:~
被呼出時:被 invoke 時:~
	invocation
投出-:throw:~
member::::メンバ

別名:alias:~
正確a:accurate:正確
等価:equivalent:~
精度:precision:~
引数:argument:~
方向:direction:~
	伴われない no 〜 present
	一致-:identical
	優先される:has priority over／more authoritative

	●指示語
新たな:new:~
初期:initial:~
単独の:single:~
自前の:own:~
現在の:current:~
最初の:first:~
最後の:last:~
全体的な:overall:~
	結果:result:~
	左上隅:top left corner
	ある程度:some extent
	より小さい:less than
	冒頭
	複数
	一つ
	一
	一連の
	一部
	上
	下
	以上
	以下
	下位:least significant
	下記
	中
	主に
	今や
	他
	他の
	その他の:miscellaneous
	以外
	何か
	何も
	何らか
	元の
	先の
	入らない
	入る
	内
	列目
	別
	先頭
	前
	前述の:aforementioned
	右辺
	左辺
	各
	各種
	各行
	同じ
	多くの
	対象
	対応-:corresponding
	少なくとも:at least
	属する
	後続の:subsequent／later
	後者
	尾部の:trailing
	最初
	最大
	最短:shortest
	頭部の:leading
	かつての:former
	全くの:fully
	次
	次の
	次回
	番目
	節
	逆方向:vice versa
	面
	項
	除いて／除き／除く
	該当-
	超え
	部分
	間
	際し
	非
	種の
	若干の:slight
	若干:slighty
	回
	常に
	後は
	時
	最も
	末尾
	等々と続く:and so on
	個
	個数

</script>


<!--% style -->

<style>
#encoding-labels td + td {
	white-space: pre;
	white-space: pre-line;
}


.algo {
	color:#404;
	font-style: italic;
}

i {
	color: #808;
}

.coder {
	font-family: sans-serif0, sans-serif;
}

.label {
	color: #666;
}

b.ename {
	font-weight: normal;
	font-family: sans-serif0, sans-serif;
	color: black;
}

code > dfn {
	color: inherit;
}

.code-point,
.hex-value {
	font-family: sans-serif0, sans-serif;
}

#_big5-lead > tr > td:nth-child(2) {
	white-space: nowrap;
}

</style>


<style>
/* based on the style at
https://encoding.spec.whatwg.org/visualization-colors.css
(2017-01-22)
*/

._vis-visualizationlegend > tr > :first-child > div {
	box-sizing: border-box;
	width: 2em;
	height: 2em;
}

._vis-unmapped {
  background-color: #920000;
  color: white;
}

._vis-astral {
  background-color: #6db6fe;
  color: black;
}

._vis-mid {
  background-color: #ffff6d;
  color: black;
}

._vis-upper, ._vis-byte {
  background-color: #d4d5db;
  color: black;
}

._vis-pua {
  background-color: #db6d00;
  color: black;
}

._vis-mid._vis-contiguous {
  background-color: #009292;
  color: black;
}

._vis-upper._vis-contiguous {
  background-color: #24fe23;
  color: black;
}

._vis-pua._vis-contiguous {
  background-color: #924900;
  color: white;
}

._vis-astral._vis-contiguous {
  background-color: #480091;
  color: white;
}

._vis-duplicate {
  border-style: solid ;
  border-color: #920000;
  color: black;
}

._vis-compatibility {
  border-style: dashed;
  border-color: black;
}

._vis-duplicate._vis-compatibility {
  border-style: dashed;
  border-color: #920000;
}

._vis-ext {
  border-style: dotted;
  border-color: black;
}

._vis-ext._vis-compatibility {
  border-style: dotted;
  border-color: #920000;
}

._vis-surrogate {
  background-color: #b4b4b6;
}

</style>

</head>

<body>

<!--%UI -->
<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">

<h1>Encoding Standard 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/" >WHATWG</a>
による，副題の日付の
<a href="https://encoding.spec.whatwg.org/" >Encoding Standard</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-08-17</time>
（公開： <time>2012-10-22</time>）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4NCjxwYXRoIGQ9Im01MCwwbDUwLDUwLTUwLDUwLTUwLTUwIiBmaWxsPSIjM2M3OTBhIi8+DQo8cGF0aCBkPSJtMzgsNDBjMC0xMiwyNC0xNSwyMy0yYzAsOS0xNiwxMy0xNiwyM3Y3aDEwdi00YzAtOSwxNy0xMiwxNy0yN2MtMi0yMi00NS0yMi00NSwzem03LDMyaDEwdjEwaC0xMCIgZmlsbD0iI2ZmZiIvPg0KPC9zdmc+DQo="
></a>

	<hgroup>
<h1>Encoding — 符号化方式</h1>
<h2>Living Standard — 最終更新 2017 年 8 月 17 日</h2>
	</hgroup>
<dl>
	<dt>Participate:</dt>
	<dd>
<a href="https://github.com/whatwg/encoding">GitHub whatwg/encoding</a>
(<a href="https://github.com/whatwg/encoding/issues/new">file an issue</a>,
<a href="https://github.com/whatwg/encoding/issues">open issues</a>)</dd>
	<dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/encoding/commits">GitHub whatwg/encoding/commits</a></dd>
	<dd><a href="https://encoding.spec.whatwg.org/commit-snapshots/debe869a71b0ec32fdcbf99b00f50f260c1d4403/">Snapshot as of this commit</a></dd>
	<dd><a href="https://twitter.com/encodings">@encodings</a></dd>

	<dt>Tests:</dt>
	<dd><a href="https://github.com/w3c/web-platform-tests/tree/master/encoding">web-platform-tests encoding/</a> (<a href="https://github.com/w3c/web-platform-tests/labels/encoding">ongoing work</a>)</dd>

	<dt>各国語翻訳（非規範的）</dt>
	<dd>日本語（このページ）</dd>

</dl>


</header>


<main id="MAIN" style="display:none;">


	<section id="preface">

<h2 title="Preface">1. 序</h2>

<p>
~UTF-8~encodingは、統一的な符号化文字集合である~Unicodeの交換に最も適切な~encodingである。
よって，この仕様は、新たな［
~protocolと形式
］, および［
新たな文脈~下で流布される既存の形式
］に対し、~UTF-8~encodingを要求する（また，定義する）。
◎
The UTF-8 encoding is the most appropriate encoding for interchange of Unicode, the universal coded character set. Therefore for new protocols and formats, as well as existing formats deployed in new contexts, this specification requires (and defines) the UTF-8 encoding.
</p>

<p>
~encodingには，他のもの（旧来の~encoding）もあり，過去にある程度までは定義されているが、~UA間で常に同じように実装されているとは限らない。
また、常に同じ~labelを利用してるわけでもなく、~encodingの中の未定義の区画, あるいは かつての~proprietaryな区画についての扱いも，しばしば異なっている。
この仕様は、新たな実装が~encoding実装をリバースエンジニアせずに済むように，また, 既存の~UAが一つに収束し得るようにするため、これらの隔たりを埋めることに取組む。
◎
The other (legacy) encodings have been defined to some extent in the past. However, user agents have not always implemented them in the same way, have not always used the same labels, and often differ in dealing with undefined and former proprietary areas of encodings. This specification addresses those gaps so that new user agents do not have to reverse engineer encoding implementations and existing user agents can converge.
</p>

<p>
特に，この仕様は、それらの~encodingと，そのそれぞれにおける［
~byte列と`~scalar値$ 列を相互に変換する~algo
］, および［
一連の`~label$を識別する正準的な名前
］を定義する。
また、~encodingの各種~algoのうち一部を JavaScript に公開する~APIも定義する。
◎
In particular, this specification defines all those encodings, their algorithms to go from bytes to scalar values and back, and their canonical names and identifying labels. This specification also defines an API to expose part of the encoding algorithms to JavaScript.
</p>

<p>
~UAは，すでに
<a href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">IANA Character Sets registry</a>
に挙げられている~labelからも 有意に逸脱している。
旧来の~encodingを これ以上~拡散させないため、この仕様は，前述の詳細について網羅的であり， registry はもう不要である。
特に，この仕様は、~encodingを拡張するための仕組みは提供しない。
◎
User agents have also significantly deviated from the labels listed in the IANA Character Sets registry. To stop spreading legacy encodings further, this specification is exhaustive about the aforementioned details and therefore has no need for the registry. In particular, this specification does not provide a mechanism for extending any aspect of encodings.
</p>

	</section>
	<section id="security-background">

<h2 title="Security background">2. 保安に関する背景</h2>

<p>
~encodingには、いくつかの保安~上の課題がある
— 生産側と消費側の間で，［
利用中の~encoding, あるいは所与の~encodingの実装-法
］について合意されてないときに。
例えば 2011 年には、次のような攻撃が報告されている：
そこでは、［
攻撃者が何らかの~fieldを制御し得るような， JSON 資源
］内の `22^X ~trail~byteを “隠す” ために，`Shift_JIS$n の~lead~byte `82^X が利用された。
生産側からは，これが違法な~byte対であっても問題が見えない一方で、消費側では，この~byte対を単独の `FFFD^U として~decodeする~~結果、全体的な解釈が変わってしまう — `0022^U は重要な区切子なので。
［
`~scalar値$に対し複数~byteを利用する~encoding
］の~decoderには、今や，違法な~byte対の事例では，［
範囲 `0000^U 〜 `007F^U に入る~scalar値
］を “隠せない” ようにすることが要求される
— 前述の~byte対に対しては、出力が［
`FFFD^U `0022^U
］になるように。
◎
There is a set of encoding security issues when the producer and consumer do not agree on the encoding in use, or on the way a given encoding is to be implemented. For instance, an attack was reported in 2011 where a Shift_JIS lead byte 0x82 was used to “mask” a 0x22 trail byte in a JSON resource of which an attacker could control some field. The producer did not see the problem even though this is an illegal byte combination. The consumer decoded it as a single U+FFFD and therefore changed the overall interpretation as U+0022 is an important delimiter. Decoders of encodings that use multiple bytes for scalar values now require that in case of an illegal byte combination, a scalar value in the range U+0000 to U+007F, inclusive, cannot be “masked”. For the aforementioned sequence the output would be U+FFFD U+0022.
</p>

<p>
これは、より~~一般的には，［
~lead~byteが伴われないときに，`~ASCII~byte$を`~ASCII~cp$でない何かに対応付ける
］ような~encodingにおける課題である。
これらは， “~ASCII非互換” の~encodingであり、あいにく，すでに流布された内容のために要求されるが、［
`ISO-2022-JP$n, `UTF-16BE$n, `UTF-16LE$n
］以外のものは，~supportされない。
（その種の 他の~encoding`~label$についても、未知の~encodingへ~fallbackせずに，`replacement$n ~encodingに対応付けてよいかどうかの究明が
<a href="https://github.com/whatwg/encoding/issues/8" title="Add more labels to the replacement encoding">進行中にある</a>
。）
攻撃の一~例として、注意深く細工された内容を資源の中へ注入して，利用者に~encodingを上書きするよう促す~~結果、例えば~scriptの実行に至らせるものがある。
◎
This is a larger issue for encodings that map anything that is an ASCII byte to something that is not an ASCII code point, when there is no lead byte present. These are “ASCII-incompatible” encodings and other than ISO-2022-JP, UTF-16BE, and UTF-16LE, which are unfortunately required due to deployed content, they are not supported. (Investigation is ongoing whether more labels of other such encodings can be mapped to the replacement encoding, rather than the unknown encoding fallback.) An example attack is injecting carefully crafted content into a resource and then encouraging the user to override the encoding, resulting in e.g. script execution. 
</p>

<p>
~HTMLや~HTMLの~form特色機能に見出される~URLに利用される~encoderも、その~encodingにより表現できない~scalar値がある場合には，若干の情報喪失につながり得る。
例えば，資源が `windows-1252$n ~encodingを利用しているとき、~serverは，末端利用者が~formに手入力した “💩” と “&amp;#128169;” とを判別できなくなる。
◎
Encoders used by URLs found in HTML and HTML’s form feature can also result in slight information loss when an encoding is used that cannot represent all scalar values. E.g. when a resource uses the windows-1252 encoding a server will not be able to distinguish between an end user entering “💩” and “&amp;#128169;” into a form.
</p>

<p>
ここに要旨した問題は、~UTF-8を排他的に利用しているときは，霧消する。
それが、今やすべてに対し~UTF-8~encodingが義務付けられている理由の一つである。
◎
The problems outlined here go away when exclusively using UTF-8, which is one of the many reasons that is now the mandatory encoding for all things.
</p>

<p class="note">注記：
<a href="#browser-ui">~browser UI</a> 節も見よ。
◎
See also the Browser UI chapter.
</p>

	</section>
	<section id="terminology">

<h2 title="Terminology">3. 各種用語</h2>

<p>
この仕様は Infra Standard `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
16 進数には "0x" が前置される。
◎
Hexadecimal numbers are prefixed with "0x".
</p>

<div class="p">
<p>
算術式の中のすべての数値は整数であり、各種~演算は次の記号で表現される：
</p>

<table>
<thead><tr><th>記号
<th>意味
</thead><tbody>

<tr><th>~PLUS
<td>加算

<tr><th>~MINUS
<td>減算

<tr><th>~INCBY
<td>左辺~値に対する右辺~値による加算

<tr><th>~DECBY
<td>左辺~値に対する右辺~値による減算

<tr><th>~MUL
<td>乗算

<tr><th>~DIV
<td>整数の除算（小数切り捨て）

<tr><th>~MOD
<td>整数の除算の剰余（ modulo ）

<tr><th>~Lshift
<td>論理~左~shift

<tr><th>~Rshift
<td>論理~右~shift

<tr><th>~bAND
<td>~bit AND

<tr><th>~bOR
<td>~bit OR

</tbody></table>

<p class="trans-note">【
記号 ~INCBY, ~DECBY は訳者による追加。
】</p>

◎
In equations, all numbers are integers, addition is represented by "+", subtraction by "−", multiplication by "×", integer division by "/" (returns the quotient), modulo by "%" (returns the remainder of an integer division), logical left shifts by "&lt;&lt;", logical right shifts by "&gt;&gt;", bitwise AND by "&amp;", and bitwise OR by "|". 
</div>

<p>
論理~右~shiftの演算~対象の精度は、少なくとも 21 ~bit以上で~MUST。
◎
For logical right shifts operands must have at least twenty-one bits precision.
</p>

<p>
`~token@
は、`~byte$や`~cp$などの， 1 個の~data片である。
◎
A token is a piece of data, such as a byte or code point.
</p>

<p>
`~stream@
は、有順序`~token$列を表現する。
`~EoS@
は、`~stream$にそれ以上 読取れる`~token$は無いことを表す，特別な`~token$である。
◎
A stream represents an ordered sequence of tokens. End-of-stream is a special token that signifies no more tokens are in the stream.
</p>

<p class="trans-note">【
~streamと~token列は（ “静的な” ）~data構造としては同じでも，
 “~stream” には，そのアクセスが
先頭（入力として与えられた場合）／末尾（出力~先の場合）
に（ “時系列的に” ）制約されることが含意される。
】</p>

<div class="algo-head">
<p>
`~stream$から`~token$を
<dfn id="concept-stream-read">読取る</dfn>
ときは、次を走らせ~MUST：
</p>
<ol>
	<li>
~IF［
~streamは空である
］
⇒
~RET `~EoS$
</li>
	<li>
~streamの先頭から 1 個の~tokenを除去する
</li>
	<li>
~RET 前~段で除去した~token
</li>
</ol>

<!-- this means read is blocking on e.g. networking activity;
     SimonSapin thinks this is fine, curse him if not -->
◎
When a token is read from a stream, the first token in the stream must be returned and subsequently removed, and end-of-stream must be returned otherwise.
</div>

<p>
1 個~以上の`~token$を`~stream$に
`前付加する@
ときは、それらの~tokenを，~streamの先頭に, 所与の順序を保ったまま挿入し~MUST。
◎
When one or more tokens are prepended to a stream, those tokens must be inserted, in given order, before the first token in the stream.
</p>

<p class="example">
~token列 "<code>&amp;#128169;</code>" を~stream "<code> hello world</code>" の先頭に挿入した結果は，~stream "<code>&amp;#128169; hello world</code>" になり、次回に読取られる~tokenは <code>&amp;</code> になる。
<!-- 💩 --><!-- #x1F4A9 = 128169 decimal -->
◎
Inserting the sequence of tokens &amp;#128169; in a stream " hello world", results in a stream "&amp;#128169; hello world". The next token to be read would be &amp;.
</p>

<p>
1 個~以上の`~token$を`~stream$に
`~pushする@
ときは、それらの~tokenを，~streamの末尾に, 所与の順序を保ったまま付加し~MUST。
◎
When one or more tokens are pushed to a stream, those tokens must be inserted, in given order, after the last token in the stream.
</p>



	</section>

	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoの記述に利用されている各種記号（此れ, ~LET, ~ON, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
加えて、次の記法も用いられる：
</p>

<table><thead><tr><th style="min-width: 10em;">記法
<th>意味
</thead>

<tbody>
<tr><th style="white-space:nowrap;">~byte列 [ %value1, %value2, … ]
<td>
数値的に %value1, %value2 … と同じ値をとる一連の`~byte$からなる, 所与の順序による，新たな`~token$列の~instanceを意味する。
角括弧の中が空
— “~byte列 [] ” —
と記されたときは，空の`~token$列を意味する。

<tr><th style="white-space:nowrap;">~cp [ %value ]
<td>
数値的に %value と同じ値をとる 1 個の`~cp$からなる，新たな`~token$列の~instanceを意味する。

</tbody></table>

	</section>
	<section id="encodings">

<h2 title="Encodings">4. ~encoding</h2>

<p>
`~encoding@
は、`~scalar値$ 列から~byte列への対応関係
【~encode】
および逆方向への対応関係
【~decode】
を定義する。
それぞれの`~encoding$には、
`名前@
および， 1 個~以上の
`~label@
が<a href="#encoding-labels">あてがわれている</a>。
◎
An encoding defines a mapping from a scalar value sequence to a byte sequence (and vice versa). Each encoding has a name, and one or more labels.
</p>

		<section id="encoders-and-decoders">
<h3 title="Encoders and decoders">4.1. ~encoderと~decoder</h3>

<div class="p">
<p>
各種 `~encoding$には、
`~decoder@
と
`~encoder@
が結付けられる。
各 `~decoder$ ／ 各 `~encoder$には、
`~handler@
が結付けられる。
`~handler$は、
( `~stream$, 1 個の`~token$ )
を入力にとり，次のいずれかを返す~algoである：
</p>

<ul>
	<li>`完遂@</li>
	<li>
<p>
空でない`~token$列
</p>

<p class="trans-note">【
ほとんどの~decoderの~handlerは， 1 個の~cpからなる~token列を返すが、
`~Big5~decoder$の~handlerだけ， 2 個の~cpを返す場合がある。
】</p>
	</li>
	<li>
<p>
~optionで`~cp$も伴い得る，`~error@
</p>
<p class="trans-note">【
~encoderの~handlerのみが、常に，~cpも伴う~errorを返す。
】</p>
	</li>
	<li>`継続@</li>
</ul>

◎
Each encoding has an associated decoder and most of them have an associated encoder. Each decoder and encoder have a handler algorithm. A handler algorithm takes an input stream and a token, and returns finished, one or more tokens, error optionally with a code point, or continue.
</div>


<p class="note">注記：
［
`replacement$n, `UTF-16BE$n, `UTF-16LE$n
］`~encoding$には、`~encoder$はない。
◎
The replacement, UTF-16BE, and UTF-16LE encodings have no encoder.
</p>


<div class="p">

<p>
以下で用いられる
`~error~mode@
は：
</p>

<ul>
	<li>
`~decoder$に対しては，［
`replacement^l（既定）,
`fatal^l
］のいずれかをとる。
</li>
	<li>
`~encoder$に対しては，［
`fatal^l（既定） ,
`html^l
］のいずれかをとる。
</li>

</ul>

◎
An error mode as used below is "replacement" (default) or "fatal" for a decoder and "fatal" (default) or "html" for an encoder.
</div>

<p class="note">注記：
XML 処理器は、その`~decoder$の`~error~mode$を `fatal^l に設定することになる。
`XML$r
◎
An XML processor would set error mode to "fatal". [XML]
</p>

<p class="note">注記：
`~error~mode$に `html^l が存在する理由は、
~URLや~HTML~formにおいては，`~error$に際し旧来の`~encoder$を終了させないようにする取扱いを要するためである。
`html^l `~error~mode$は、合法な入力と判別できない列を~~出力させ，~~検知されることなく~dataを失わせる。
これを防ぐため、開発者には `UTF-8$n `~encoding$の利用が強く奨励される。
`URL$r
`HTML$r
◎
html exists as error mode due to URLs and HTML forms requiring a non-terminating legacy encoder. The "html" error mode causes a sequence to be emitted that cannot be distinguished from legitimate input and can therefore lead to silent data loss. Developers are strongly encouraged to use the UTF-8 encoding to prevent this from happening. [URL] [HTML]
</p>

<div class="algo-head">
<p>
`~encoding$の［
`~decoder$ ／ `~encoder$
］ %~coder を
`走らす@
ときは、所与の：
</p>

<ul><li>入力`~stream$ : %入力
</li><li>出力`~stream$ : %出力
</li><li>`~error~mode$ : %~mode （省略時は ε ）
</li></ul>

<p>
に対し，次を走らす：
</p>
◎
To run an encoding’s decoder or encoder encoderDecoder with input stream input, output stream output, and optional error mode mode, run these steps:
</div>

<ol>
	<li>
~IF［
%~mode ~EQ ε
］
⇒
%~mode ~SET %~coder に応じて
⇒
`~decoder$であるならば `replacement^l ~BR
`~encoder$であるならば `fatal^l
◎
If mode is not given, set it to "replacement", if encoderDecoder is a decoder, and "fatal" otherwise.
</li>
	<li>
%~coder~instance ~LET 新たな %~coder の~instance
◎
Let encoderDecoderInstance be a new encoderDecoder.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>

		<ol>
			<li>
%結果 ~LET  次を与える下で，`~tokenを処理-$した結果
⇒
( %入力 から`読取った結果$, %~coder~instance, %入力, %出力, %~mode )
◎
Let result be the result of processing the result of reading from input for encoderDecoderInstance, input, output, and mode.
</li>
			<li>
~IF［
%結果 ~NEQ `継続$
］
⇒
~RET %結果
◎
If result is not continue, return result.
◎
Otherwise, do nothing. 
</li>
		</ol>
	</li>
</ol>

<div class="algo-head">
<p>
`~tokenを処理-@
するときは、所与の：
</p>

<ul><li>`~token$ : %~token 
</li><li>`~encoding$の［
`~encoder$／`~decoder$
］の~instance : %~coder~instance
</li><li>
入力`~stream$ : %入力
</li><li>
出力`~stream$ : %出力
</li><li>
`~error~mode$ : %~mode（省略時は ε ）
</li></ul>

<p>
に対し，次を走らす：
</p>
◎
To process a token token for an encoding’s encoder or decoder instance encoderDecoderInstance, stream input, output stream output, and optional error mode mode, run these steps:
</div>

<ol>
	<li>
~IF［
%~mode ~EQ ε
］
⇒
%~mode ~SET %~coder~instance に応じて
⇒
`~decoder$の~instanceであるならば `replacement^l ／
`~encoder$の~instanceであるならば `fatal^l
◎
If mode is not given, set it to "replacement", if encoderDecoderInstance is a decoder instance, and "fatal" otherwise.
</li>
	<li>
%結果 ~LET
( %入力, %~token )
に対し， %~coder~instance による`~handler$を走らせた結果
◎
Let result be the result of running encoderDecoderInstance’s handler on input and token.
</li>
	<li>
~IF［
%結果 ~IN { `継続$, `完遂$ }
］
⇒
~RET %結果
◎
If result is continue or finished, return result.
</li>
	<li>
~IF［
%結果 に 1 個~以上の`~token$がある
］
⇒
%結果 を %出力 に`~pushする$
◎
Otherwise, if result is one or more tokens, push result to output.
</li>
	<li>
<p>
~ELIF［
%結果 ~EQ `~error$
］
⇒
%~mode に応じて：
◎
Otherwise, if result is error, switch on mode and run the associated steps:
</p>

		<dl class="switch">
			<dt>`replacement^l</dt>
			<dd>
`FFFD^U を %出力 に`~pushする$
◎
Push U+FFFD to output.
</dd>

			<dt>`html^l</dt>
			<dd>
~cp列［
`0026^U, `0023^U, ［
%結果 の`~cp$を基数 10 により最短で表現する`~ASCII数字$列
］, `003B^U
］
【 "<code>&amp;#<var>数字列</var>;</code>" 】
を
%入力 に`前付加する$
◎
Prepend U+0026, U+0023, followed by the shortest sequence of ASCII digits representing result’s code point in base ten, followed by U+003B to input.
</dd>

			<dt>`fatal^l</dt>
			<dd>
~RET `~error$
◎
Return error.
</dd>
		</dl>
	</li>
	<li>
~RET `継続$
◎
Return continue.
</li>
</ol>



		</section>
		<section id="names-and-labels">

<h3 title="Names and labels">4.2. 名前と~label</h3>

<p>
下の一覧に、~UAが~supportし~MUST，すべての`~encoding$とそれらの`~label$を挙げる。
~UA は、他の`~encoding$や`~label$を~supportしては~MUST_NOT。
◎
The table below lists all encodings and their labels user agents must support. User agents must not support any other encodings or labels.
</p>

<p class="note">注記：
どの~encodingについても、その`~label$の集合は，`名前$を`~ASCII小文字~化$したものを含んでいる。
◎
For each encoding, ASCII-lowercasing its name yields one of its labels.
</p>

<p>
作者は、 `UTF-8$n `~encoding$を利用した上で，その利用が識別されるように［
`~ASCII大小無視$で `utf-8^lb に合致する`~label$
］を利用し~MUST。
◎
Authors must use the UTF-8 encoding and must use the ASCII case-insensitive "utf-8" label to identify it.
</p>

<p>
新たな［
~protocolと形式
］, あるいは［
新たな文脈~下で流布される既存の形式
］には、 `UTF-8$n `~encoding$が排他的に利用され~MUST。
これらの［
~protocolや形式
］の`~encoding$の［
`名前$や`~label$
］は、 `utf-8^lb として公開され~MUST。
◎
New protocols and formats, as well as existing formats deployed in new contexts, must use the UTF-8 encoding exclusively. If these protocols and formats need to expose the encoding’s name or label, they must expose it as "utf-8".
</p>

<p class="algo-head">
文字列 %~label から
`~encodingを取得-@
するときは、次を走らす：
◎
To get an encoding from a string label, run these steps:
</p>

<ol>
	<li>
%~label から頭部と尾部の`~ASCII空白$を除去する
◎
Remove any leading and trailing ASCII whitespace from label.
</li>
	<li>
~IF［
%~label が下の一覧のいずれかの`~label$に`~ASCII大小無視$で合致する
］
⇒
~RET 合致した`~label$に対応する`~encoding$
◎
If label is an ASCII case-insensitive match for any of the labels listed in the table below, return the corresponding encoding, and failure otherwise.
</li>
	<li>
~RET `失敗^i
◎
↑</li>
</ol>

<p class="note">注記：
配備済みの内容と互換にする必要から、この［
`~label$を`~encoding$に対応付ける~algo
］は，
<a href="https://www.unicode.org/reports/tr22/tr22-7.html#Charset_Alias_Matching">Unicode Technical Standard #22, 1.4 節</a>
によるものより基本的かつ制約的である。
◎
This is a more basic and restrictive algorithm of mapping labels to encodings than section 1.4 of Unicode Technical Standard #22 prescribes, as that is necessary to be compatible with deployed content.
</p>

<table id="encoding-labels">
<thead><tr><th>`名前$◎Name
<th>`~label$◎Labels
</thead>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#the-encoding">~~標準の~encoding</a>
◎
The Encoding
<tr><td>`UTF-8$n
<td>`unicode-1-1-utf-8^lb
`utf-8^lb
`utf8^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-single-byte-encodings">旧来の単byte~encoding</a>
◎
Legacy single-byte encodings
<tr><td>`IBM866$n
<td>`866^lb
`cp866^lb
`csibm866^lb
`ibm866^lb
<tr><td>`ISO-8859-2$n
<td>`csisolatin2^lb
`iso-8859-2^lb
`iso-ir-101^lb
`iso8859-2^lb
`iso88592^lb
`iso_8859-2^lb
`iso_8859-2:1987^lb
`l2^lb
`latin2^lb
<tr><td>`ISO-8859-3$n
<td>`csisolatin3^lb
`iso-8859-3^lb
`iso-ir-109^lb
`iso8859-3^lb
`iso88593^lb
`iso_8859-3^lb
`iso_8859-3:1988^lb
`l3^lb
`latin3^lb
<tr><td>`ISO-8859-4$n
<td>`csisolatin4^lb
`iso-8859-4^lb
`iso-ir-110^lb
`iso8859-4^lb
`iso88594^lb
`iso_8859-4^lb
`iso_8859-4:1988^lb
`l4^lb
`latin4^lb
<tr><td>`ISO-8859-5$n
<td>`csisolatincyrillic^lb
`cyrillic^lb
`iso-8859-5^lb
`iso-ir-144^lb
`iso8859-5^lb
`iso88595^lb
`iso_8859-5^lb
`iso_8859-5:1988^lb
<tr><td>`ISO-8859-6$n
<td>`arabic^lb
`asmo-708^lb
`csiso88596e^lb
`csiso88596i^lb
`csisolatinarabic^lb
`ecma-114^lb
`iso-8859-6^lb
`iso-8859-6-e^lb
`iso-8859-6-i^lb
`iso-ir-127^lb
`iso8859-6^lb
`iso88596^lb
`iso_8859-6^lb
`iso_8859-6:1987^lb
<tr><td>`ISO-8859-7$n
<td>`csisolatingreek^lb
`ecma-118^lb
`elot_928^lb
`greek^lb
`greek8^lb
`iso-8859-7^lb
`iso-ir-126^lb
`iso8859-7^lb
`iso88597^lb
`iso_8859-7^lb
`iso_8859-7:1987^lb
`sun_eu_greek^lb
<tr><td>`ISO-8859-8$n
<td>`csiso88598e^lb
`csisolatinhebrew^lb
`hebrew^lb
`iso-8859-8^lb
`iso-8859-8-e^lb
`iso-ir-138^lb
`iso8859-8^lb
`iso88598^lb
`iso_8859-8^lb
`iso_8859-8:1988^lb
`visual^lb
<tr><td>`ISO-8859-8-I$n
<td>`csiso88598i^lb
`iso-8859-8-i^lb
`logical^lb
<tr><td>`ISO-8859-10$n
<td>`csisolatin6^lb
`iso-8859-10^lb
`iso-ir-157^lb
`iso8859-10^lb
`iso885910^lb
`l6^lb
`latin6^lb
<tr><td>`ISO-8859-13$n
<td>`iso-8859-13^lb
`iso8859-13^lb
`iso885913^lb
<tr><td>`ISO-8859-14$n
<td>`iso-8859-14^lb
`iso8859-14^lb
`iso885914^lb
<tr><td>`ISO-8859-15$n
<td>`csisolatin9^lb
`iso-8859-15^lb
`iso8859-15^lb
`iso885915^lb
`iso_8859-15^lb
`l9^lb
<tr><td>`ISO-8859-16$n
<td>`iso-8859-16^lb
<tr><td>`KOI8-R$n
<td>`cskoi8r^lb
`koi^lb
`koi8^lb
`koi8-r^lb
`koi8_r^lb
<tr><td>`KOI8-U$n
<td>`koi8-ru^lb
`koi8-u^lb
<tr><td>`macintosh$n
<td>`csmacintosh^lb
`mac^lb
`macintosh^lb
`x-mac-roman^lb
<tr><td>`windows-874$n
<td>`dos-874^lb
`iso-8859-11^lb
`iso8859-11^lb
`iso885911^lb
`tis-620^lb
`windows-874^lb
<tr><td>`windows-1250$n
<td>`cp1250^lb
`windows-1250^lb
`x-cp1250^lb
<tr><td>`windows-1251$n
<td>`cp1251^lb
`windows-1251^lb
`x-cp1251^lb
<tr><td>`windows-1252$n
<td>`ansi_x3.4-1968^lb
`ascii^lb
`cp1252^lb
`cp819^lb
`csisolatin1^lb
`ibm819^lb
`iso-8859-1^lb
`iso-ir-100^lb
`iso8859-1^lb
`iso88591^lb
`iso_8859-1^lb
`iso_8859-1:1987^lb
`l1^lb
`latin1^lb
`us-ascii^lb
`windows-1252^lb
`x-cp1252^lb
<tr><td>`windows-1253$n
<td>`cp1253^lb
`windows-1253^lb
`x-cp1253^lb
<tr><td>`windows-1254$n
<td>`cp1254^lb
`csisolatin5^lb
`iso-8859-9^lb
`iso-ir-148^lb
`iso8859-9^lb
`iso88599^lb
`iso_8859-9^lb
`iso_8859-9:1989^lb
`l5^lb
`latin5^lb
`windows-1254^lb
`x-cp1254^lb
<tr><td>`windows-1255$n
<td>`cp1255^lb
`windows-1255^lb
`x-cp1255^lb
<tr><td>`windows-1256$n
<td>`cp1256^lb
`windows-1256^lb
`x-cp1256^lb
<tr><td>`windows-1257$n
<td>`cp1257^lb
`windows-1257^lb
`x-cp1257^lb
<tr><td>`windows-1258$n
<td>`cp1258^lb
`windows-1258^lb
`x-cp1258^lb
<tr><td>`x-mac-cyrillic$n
<td>`x-mac-cyrillic^lb
`x-mac-ukrainian^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-chinese-(simplified)-encodings">旧来の複byte Chinese （簡体字） ~encoding</a>
◎
Legacy multi-byte Chinese (simplified) encodings
<tr><td>`GBK$n
<td>`chinese^lb
`csgb2312^lb
`csiso58gb231280^lb
`gb2312^lb
`gb_2312^lb
`gb_2312-80^lb
`gbk^lb
`iso-ir-58^lb
`x-gbk^lb
<tr><td>`gb18030$n
<td>`gb18030^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-chinese-(traditional)-encodings">旧来の複byte Chinese （繁体字）~encoding</a>
◎
Legacy multi-byte Chinese (traditional) encodings
<tr><td>`Big5$n
<td>`big5^lb
`big5-hkscs^lb
`cn-big5^lb
`csbig5^lb
`x-x-big5^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-japanese-encodings">旧来の複byte Japanese ~encoding</a>
◎
Legacy multi-byte Japanese encodings
<tr><td>`EUC-JP$n
<td>`cseucpkdfmtjapanese^lb
`euc-jp^lb
`x-euc-jp^lb
<tr><td>`ISO-2022-JP$n
<td>`csiso2022jp^lb
`iso-2022-jp^lb
<tr><td>`Shift_JIS$n
<td>`csshiftjis^lb
`ms932^lb
`ms_kanji^lb
`shift-jis^lb
`shift_jis^lb
`sjis^lb
`windows-31j^lb
`x-sjis^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-multi-byte-korean-encodings">旧来の複byte Korean ~encoding</a>
◎
Legacy multi-byte Korean encodings
<tr><td>`EUC-KR$n
<td>`cseuckr^lb
`csksc56011987^lb
`euc-kr^lb
`iso-ir-149^lb
`korean^lb
`ks_c_5601-1987^lb
`ks_c_5601-1989^lb
`ksc5601^lb
`ksc_5601^lb
`windows-949^lb
</tbody>

<tbody><tr><th colspan="2" scope="rowgroup">
<a href="#legacy-miscellaneous-encodings">旧来のその他の~encoding</a>
◎
Legacy miscellaneous encodings
<tr><td>`replacement$n
<td>`csiso2022kr^lb
`hz-gb-2312^lb
`iso-2022-cn^lb
`iso-2022-cn-ext^lb
`iso-2022-kr^lb
`replacement^lb
<tr><td>`UTF-16BE$n
<td>`utf-16be^lb
<tr><td>`UTF-16LE$n
<td>`utf-16^lb
`utf-16le^lb
<tr><td>`x-user-defined$n
<td>`x-user-defined^lb
	</tbody>
</table>

<p class="note">注記：
すべての`~encoding$とそれらの`~label$は、規範的でない資源
`indexes.json$
からも入手できる。
◎
All encodings and their labels are also available as non-normative encodings.json resource.
</p>

		</section>
		<section id="output-encodings">

<h3 title="Output encodings">4.3 出力~encoding</h3>

<p>
`~encoding$ %~encoding から
`出力~encodingを取得-@
するときは、次を走らす：
◎
To get an output encoding from an encoding encoding, run these steps:
</p>

<ol>
	<li>
~IF［
%~encoding ~IN
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$n }
］
⇒
~RET `UTF-8$n
◎
If encoding is replacement, UTF-16BE, or UTF-16LE, return UTF-8.
</li>
	<li>
~RET %~encoding
◎
Return encoding.
</li>
</ol>

<p class="note">注記：
`出力~encodingを取得-$する~algoは、それを必要とする［
~URLの構文解析 ／ ~HTML~form提出
］にて有用になる。
◎
The get an output encoding algorithm is useful for URL parsing and HTML form submission, which both need exactly this.
</p>

		</section>
	</section>
	<section id="indexes">

<h2 title="Indexes">5. 索引</h2>

<p>
ほとんどの旧来の`~encoding$では、
【~encodingごとに固有の】
`索引@
が利用される。
`索引$とは、一連の~entryからなる有順序~listであり、各~entryは［
~pointerと, それに対応する~cp
］からなる組である。
`索引$の中では、~pointerは一意であり，~cpは重複し得る。
◎
Most legacy encodings make use of an index. An index is an ordered list of entries, each entry consisting of a pointer and a corresponding code point. Within an index pointers are unique and code points can be duplicated.
</p>

<p class="note">注記：
効率的な実装は、`~encoding$ごとに，その`~decoder$と`~encoder$のそれぞれに最適化された， 2 つの`索引$を備えることになるであろう。
◎
An efficient implementation likely has two indexes per encoding. One optimized for its decoder and one for its encoder.
</p>

<div class="p">

<p class="algo-head">
`索引$
【の~dataを供する下記の資源】
から，~pointerとそれに対応する~cpを見出すためには：
</p>

<ol>
	<li>
まず、 %行~list をその資源の内容を `000A^U で一連の “行” に分割した結果とする。
</li>
	<li>
%行~list から［
空行 ／ `0023^U で開始される行
］をすべて除去する。
</li>
	<li>
<p>
%行~list の各~行に対し，行を `0009^U で分割したときの：
</p>

<ul><li>最初の項が~pointer（ 10 進表記）を与える。
</li><li>次の項が対応する~cp（ 16 進表記）を与える。
</li><li>他の項は関係ない。
</li></ul>
	</li>
</ol>

◎
To find the pointers and their corresponding code points in an index, let lines be the result of splitting the resource’s contents on U+000A. Then remove each item in lines that is the empty string or starts with U+0023. Then the pointers and their corresponding code points are found by splitting each item in lines on U+0009. The first subitem is the pointer (as a decimal number) and the second is the corresponding code point (as a hexadecimal number). Other subitems are not relevant.
</div>

<p class="note">注記：
各`索引$の冒頭には、変更の有無を記すため，
<i>Identifier</i> と <i>Date</i>
【識別子と日付】
が記されている。
<i>Identifier</i> の変化は、`索引$に変更が加えられたことを表す。
◎
To signify changes an index includes an Identifier and a Date. If an Identifier has changed, so has the index.
</p>

<p>
%索引 の中で %~pointer が指す
`索引~cp@
とは、
%索引 内に %~pointer が［
在るならば，それに対応する~cp ／
無ければ ~NULL
］である。
◎
The index code point for pointer in index is the code point corresponding to pointer in index, or null if pointer is not in index.
</p>

<p>
%索引 の中で %~cp を指す
`索引~pointer@
とは、
%索引 内に %~cp に対応する~pointerが［
在るならば，それらのうちの <em>最初の</em> ~pointer ／
無ければ ~NULL
］である。
◎
The index pointer for code point in index is the first pointer corresponding to code point in index, or null if code point is not in index.
</p>

<div class="note" id="visualization">
<p>注記：
各 索引には，規範的でない視覚化があり、`索引~jis0208$には， `Shift_JIS$n 視覚化も別にある。
加えて，基本多言語面（
BMP ／ Basic Multilingual Plane ／ `0000^U 〜 `FFFF^U
）における被覆域の視覚化もある。
ただし、［
`索引~gb18030範囲集$ ／ `索引~ISO-2022-JP~katakana$
］には，これらの視覚化はない。
◎
There is a non-normative visualization for each index other than index gb18030 ranges and index ISO-2022-JP katakana. index jis0208 also has an alternative Shift_JIS visualization. Additionally, there is visualization of the Basic Multilingual Plane coverage of each index other than index gb18030 ranges and index ISO-2022-JP katakana.
</p>

<table>
<caption>
視覚化における凡例
◎
The legend for the visualizations is:
</caption>

<thead><tr><th>表示
<th>説明
</thead>

<tbody class="_vis-visualizationlegend">
<tr><td><div class="_vis-unmapped"></div><td>
対応する~cpなし。
◎
Unmapped

<tr><td><div class="_vis-mid"></div><td>
~UTF-8で 2 ~byte。
◎
Two bytes in UTF-8

<tr><td><div class="_vis-mid _vis-contiguous"></div><td>
~UTF-8で 2 ~byte, かつ
~cpは、前の~pointerの~cpの直後に続く。
◎
Two bytes in UTF-8, code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-upper"></div><td>
~UTF-8で 3 ~byte（私用領域でない）
◎
Three bytes in UTF-8 (non-PUA)

<tr><td><div class="_vis-upper _vis-contiguous"></div><td>
~UTF-8で 3 ~byte（私用領域でない）, かつ
~cpは、前の~pointerの~cpの直後に続く。
◎
Three bytes in UTF-8 (non-PUA), code point follows immediately the code point of previous pointer

<tr><td><div class="_vis-pua"></div><td>
私用領域
◎
Private Use

<tr><td><div class="_vis-pua _vis-contiguous"></div><td>
私用領域, かつ
~cpは、前の~pointerの~cpの直後に続く。
◎
Private Use, code point follows immediately the code point of previous
pointer

<tr><td><div class="_vis-astral"></div><td>
~UTF-8で 4 ~byte
◎
Four bytes in UTF-8

<tr><td><div class="_vis-astral _vis-contiguous"></div><td>
~UTF-8で 4 ~byte, かつ
~cpは、前の~pointerの~cpの直後に続く。
◎
Four bytes in UTF-8, code point follows immediately the code point
of previous pointer

<tr><td><div class="_vis-duplicate"></div><td>
先に現れているものと重複する~cpに対応する。
◎
Duplicate code point already mapped at an earlier index

<tr><td><div class="_vis-compatibility"></div><td>
~CJK互換漢字（ CJK Compatibility Ideograph ）
◎
CJK Compatibility Ideograph

<tr><td><div class="_vis-ext"></div><td>
~CJK統合漢字拡張 A
◎
CJK Unified Ideographs Extension A

</tbody>
</table>

</div>


<p>
以下は、この仕様で定義される`索引$のうち，`単byte索引$でないものであり、それぞれに自前の~tableがある：
【視覚化／被覆域の~tableは巨大なことに注意】
◎
These are the indexes defined by this specification, excluding index single-byte, which have their own table:
</p>

<table id="_index_list">
<thead><tr><th rowspan="2">`名前$
<th>`索引$
<th>視覚化
<th>基本多言語面（ BMP ）の被覆域
<tr><th colspan="3">備考
</thead>

<tbody><tr><td rowspan="2">`索引~Big5@
<td>`Big5$idx
<tr><td colspan="3">
これは、香港増補字符集（ Hong Kong Supplementary Character Set ）, および他の共通の拡張と一式で、~Big5標準に合致する。
◎
This matches the Big5 standard in combination with the Hong Kong Supplementary Character Set and other common extensions.

<tbody><tr><td rowspan="2">`索引~EUC-KR@
<td>`EUC-KR$idx
<tr><td colspan="3">
これは、 KS X 1001 標準と 統合~Hangul~code（ Unified Hangul Code ）に合致する。
Windows Codepage 949 としても共通的に知られている。
これ全体で、~Unicodeの~Hangul音節文字（ Hangul Syllables ）~blockを覆う。
~Hangul~blockのうち，視覚化における左上隅が~pointer 9026 にあるもの
【？】
は、~Unicode順に並ぶ。
Taken separately 【？】,
この索引における残りの~Hangul音節文字も、~Unicode順に並ぶ。
◎
This matches the KS X 1001 standard and the Unified Hangul Code, more commonly known together as Windows Codepage 949. It covers the Hangul Syllables block of Unicode in its entirety. The Hangul block whose top left corner in the visualization is at pointer 9026 is in the Unicode order. Taken separately, the rest of the Hangul syllables in this index are in the Unicode order, too. 

<tbody><tr><td rowspan="2">`索引~gb18030@
<td>`gb18030$idx
<tr><td colspan="3">
これは、各~cpが 2 ~byteに~encodeされる GB18030-2005 標準に合致する
— ただし，配備済みの内容と互換にする必要から、 `A3^X `A0^X は `3000^U に対応付けられる。
この索引~全体で、~Unicodeの~CJK統合漢字（ CJK Unified Ideographs ）~blockを覆う。
その~block内の~entryのうち，視覚化における（最初の） `3000^U より上または左にあるものは、~Unicode順に並ぶ。
◎
This matches the GB18030-2005 standard for code points encoded as two bytes, except for 0xA3 0xA0 which maps to U+3000 to be compatible with deployed content. This index covers the CJK Unified Ideographs block of Unicode in its entirety. Entries from that block that are above or to the left of (the first) U+3000 in the visualization are in the Unicode order.

<tbody><tr><td rowspan="2">`索引~gb18030範囲集@
<td><a href="~ENCSPEC/index-gb18030-ranges.txt">index-gb18030-ranges.txt</a>
<td><td>
<tr><td colspan="3">
この`索引$は、すべての~cpを挙げていくと項目数が 100 万を超えてしまう点で，他のすべてと異なる（ 207 面の範囲と自明な範囲検査により，きれいに表現し得るが）。
したがって、 4 ~byte に~encodeされる~cpについてのみ，見かけ上 GB18030-2005 標準に合致する。
下の［
`索引~gb18030範囲集~cp$ ／
`索引~gb18030範囲集~pointer$
］も見よ。
◎
This index works different from all others. Listing all code points would result in over a million items whereas they can be represented neatly in 207 ranges combined with trivial limit checks. It therefore only superficially matches the GB18030-2005 standard for code points encoded as four bytes. See also index gb18030 ranges code point and index gb18030 ranges pointer below.

<tbody><tr><td rowspan="3">`索引~jis0208@
<td>`jis0208$idx
<tr><td><td><a href="~ENCSPEC/shift_jis.html">索引~Shift_JIS視覚化</a><td>
<tr><td colspan="3">
IBM と NEC によるかつての~proprietary拡張も含まれている， JIS X 0208 標準。
◎
This is the JIS X 0208 standard including formerly proprietary extensions from IBM and NEC.

<tbody><tr><td rowspan="2">`索引~jis0212@
<td>`jis0212$idx
<tr><td colspan="3">
JIS X 0212 標準。
これを利用するのは、`~EUC-JP~decoder$に限られる（~encoderからは利用されない）
— 広く~supportされていないので。
◎
This is the JIS X 0212 standard. It is only used by the EUC-JP decoder due to lack of widespread support elsewhere.

<tbody><tr><td rowspan="2">`索引~ISO-2022-JP~katakana@
<td><a href="~ENCSPEC/index-iso-2022-jp-katakana.txt">index-gb18030-ranges.txt</a>
<td><td>
<tr><td colspan="3">
これは、
Unicode Normalization Form KC
に従って，半角~katakanaを全角~katakanaに対応付ける。
ただし、［
`FF9E^U ／ `FF9F^U
］は［
`309B^U ／ `309C^U
］に対応付ける
— ［
`3099^U ／ `309A^U
］ではなく
【これらはいずれも、濁点／半濁点】
。
これを利用するのは、`~ISO-2022-JP~encoder$に限られる。
`UNICODE$r
◎
This maps halfwidth to fullwidth katakana as per Unicode Normalization Form KC, except that U+FF9E and U+FF9F map to U+309B and U+309C rather than U+3099 and U+309A. It is only used by the ISO-2022-JP encoder. [UNICODE]

</tbody></table>


<p class="algo-head">
%~pointer が指す
`索引~gb18030範囲集~cp@
は、次の手続きが返す~cpである：
◎
The index gb18030 ranges code point for pointer is the return value of these steps:
</p>

<ol>
	<li>
~IF［
39419 ~LT %~pointer ~LT 189000
］~OR［
1237575 ~LT %~pointer
］
⇒
~RET ~NULL
◎
If pointer is greater than 39419 and less than 189000, or pointer is greater than 1237575, return null.
</li>
	<li>
~IF［
%~pointer ~EQ 7457
］
⇒
~RET ~cp `E7C7^U
◎
If pointer is 7457, return code point U+E7C7. 
</li>
	<li>
%~offset ~LET `索引~gb18030範囲集$ の中で %~pointer を超えない最後の~pointer ◎
Let offset be the last pointer in index gb18030 ranges that is equal to or less than pointer and let code point offset be its corresponding code point.
</li>
	<li>
%~cp~offset ~LET %~offset が指している~cp
◎
↑</li>
	<li>
~RET 値が［
%~cp~offset ~PLUS %~pointer ~MINUS %~offset
］なる~cp
◎
Return a code point whose value is code point offset + pointer − offset.
</li>
</ol>

<p class="algo-head">
%~cp を指す
`索引~gb18030範囲集~pointer@
は、次の手続きが返す~pointerである：
◎
The index gb18030 ranges pointer for code point is the return value of these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `E7C7^U
］
⇒
~RET ~pointer 7457
◎
If code point is U+E7C7, return pointer 7457.
</li>

	<li>
%~offset ~LET `索引~gb18030範囲集$ の中で %~cp を超えない最後の~cp
◎
Let offset be the last code point in index gb18030 ranges that is equal to or less than code point and let pointer offset be its corresponding pointer.
</li>
	<li>
%~pointer~offset ~LET %~offset に対応する~pointer
◎
↑</li>
	<li>
~RET 値が［
%~pointer~offset ~PLUS %~cp ~MINUS %~offset
］なる~pointer
◎
Return a pointer whose value is pointer offset + code point − offset.
</li>
</ol>

<p class="algo-head">
%~cp を指す
`索引~Shift_JIS~pointer@
は、次の手続きが返す~pointerである：
◎
The index Shift_JIS pointer for code point is the return value of these steps:
</p>

<ol>
	<li>
<p>
%索引 ~LET `索引~jis0208$ から，［
~pointerが範囲 { 8272 〜 8835 } に入る~entry
］すべてを除外した索引
◎
Let index be index jis0208 excluding all entries whose pointer is in the range 8272 to 8835, inclusive.
</p>

<p class="note">
`索引~jis0208$は、重複する~cpを包含するので、これらの~entryの除外により，後続の~cpが利用されるようになる。
◎
The index jis0208 contains duplicate code points so the exclusion of these entries causes later code points to be used.
</p>
	</li>
	<li>
~RET %索引 の中で %~cp を指す`索引~pointer$
◎
Return the index pointer for code point in index.
</li>
</ol>

<p class="algo-head">
%~cp を指す
`索引~Big5~pointer@
は、次の手続きが返す~pointerである：
◎
The index Big5 pointer for code point is the return value of these steps:
</p>


<ol>
	<li>
<p>
%索引 ~LET `索引~Big5$から［
~pointerが ( (`A1^X ~MINUS `81^X) ~MUL 157 ) より小さい~entry
］すべてを除外した索引
◎
Let index be index Big5 excluding all entries whose pointer is less than (0xA1 - 0x81) × 157. 
</p>

<p class="note">注記：
香港増補字符集（ Hong Kong Supplementary Character Set ）拡張を~literalとして返さないようにする。
◎
Avoid returning Hong Kong Supplementary Character Set extensions literally.
</p>
	</li>
	<li>
<p>
~IF［
%~cp ~IN 
{ `2550^U, `255E^U, `2561^U, `256A^U, `5341^U, `5345^U }
］
⇒
~RET
%索引 の中で %~cp に対応する <em>最後の</em> ~pointer
◎
If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345, return the last pointer corresponding to code point in index.
</p>

<p class="note">注記：
他にも重複している~cpはあるが、それらに対しては，<em>最初の</em> ~pointerが利用されることになる。
◎
There are other duplicate code points, but for those the first pointer is to be used.
</p>
	</li>
	<li>
~RET
%索引 の中で %~cp を指す`索引~pointer$
◎
Return the index pointer for code point in index.
</li>
</ol>



<hr>


<p class="note">注記：
すべての`索引$は規範的でない資源
`indexes.json$
からも入手できる（ `索引~gb18030範囲集$ の形式は、範囲を表現できるようにするため，若干~異なるものにされている）。
◎
All indexes are also available as a non-normative indexes.json resource. (Index gb18030 ranges has a slightly different format here, to be able to represent ranges.)
</p>

	</section>
	<section id="specification-hooks">

<h2 title="Specification hooks">6. 他の仕様のための~hook</h2>

<div class="note">
<p>注記：
次に挙げる各種~algoは、他の仕様からの~~利用が意図されている：
</p>

<ul><li>`~decode$
</li><li>`~UTF-8~decode$
</li><li>`~BOMはそのままに~UTF-8~decode$
</li><li>`~BOMも失敗-もそのままに~UTF-8~decode$
</li><li>`~encode$
</li><li>`~UTF-8~encode$
</li></ul>

<p>
新たな形式には、`~UTF-8~decode$が利用されることになる。
最初に`~label$を`~encoding$に転換するときは、`~encodingを取得-$する~algoを利用できる。
</p>
◎
The algorithms decode, UTF-8 decode, UTF-8 decode without BOM, UTF-8 decode without BOM or fail, encode, and UTF-8 encode are intended for usage by other specifications. UTF-8 decode is to be used by new formats. The get an encoding algorithm can be used first to turn a label into an encoding.
</div>

<p class="algo-head">
~fallback~encoding %~encoding を利用して，~byte~stream %~stream を
`~decode@
するときは、次を走らす：
◎
To decode a byte stream stream using fallback encoding encoding, run these steps:
</p>

<ol>
	<li>
%buffer ~LET ~byte列 []
◎
Let buffer be an empty byte sequence.
</li>
	<li>
%~BOMseen~flag ~LET ~OFF
◎
Let BOM seen flag be unset.
</li>
	<li>
次を 3 回 繰返す
⇒
%~stream から`読取った結果$を %buffer に付加する
— ただし，`~EoS$ が返されたときは、付加せずに繰返しを終える
◎
Read bytes from stream into buffer until either buffer contains three bytes or read returns end-of-stream.
</li>
	<li>
<p>
~IF［
次の表の中で， 1 列目に示された~byte列が %buffer の先頭の~byte列に合致する行がある
］
⇒
%~encoding ~SET その行の 2 列目に与えられる `~encoding$ ~BR
%~BOMseen~flag ~LET ~ON
◎
For each of the rows in the table below, starting with the first one and going down, if the first bytes of buffer match all the bytes given in the first column, then set encoding to the encoding given in the cell in the second column of that row and set BOM seen flag.
</p>


<table>

<thead><tr><th>~BOM◎Byte order mark
<th>~encoding◎Encoding
</thead>

<tbody><tr><td>`EF^X `BB^X `BF^X
<td>`UTF-8$n

<tr><td>`FE^X `FF^X
<td>`UTF-16BE$n

<tr><td>`FF^X `FE^X
<td>`UTF-16LE$n

</tbody></table>

<p class="note">注記：
配備済みの内容と互換性をとるため、~BOM（ byte order mark ）は他より~~優先される。
HTTP が利用される文脈~下では、これは，
`<code class="header">Content-Type</code>`
~headerの意味論に対する違反である。
◎
For compatibility with deployed content, the byte order mark (also known as BOM) is more authoritative than anything else. In a context where HTTP is used this is in violation of the semantics of the `Content-Type` header.
</p>
	</li>
	<li>
~IF［
%~BOMseen~flag ~EQ ~OFF
］
⇒
%buffer を %~stream に`前付加する$
◎
If BOM seen flag is unset, prepend buffer to stream.
</li>
	<li>
~ELIF ［
%~encoding ~NEQ `UTF-8$n
］~AND［
%buffer の長さ ~EQ 3
］
⇒
%buffer の最後の~byteを %~stream に`前付加する$
◎
Otherwise, if BOM seen flag is set, encoding is not UTF-8, and buffer contains three bytes, prepend the last byte of buffer to stream.
</li>
	<li>
%出力 ~LET ~cp`~stream$
◎
Let output be a code point stream.
</li>
	<li>
( %~stream, %出力 )
を与える下で，
%~encoding の`~decoder$を`走らす$
◎
Run encoding’s decoder with stream and output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="algo-head">
~byte~stream %~stream を
`~UTF-8~decode@
するときは、次を走らす：
◎
To UTF-8 decode a byte stream stream, run these steps:
</p>

<ol>
	<li>
%buffer ~LET ~byte列 []
◎
Let buffer be an empty byte sequence.
</li>
	<li>
次を 3 回 繰返す
⇒
%~stream から`読取った結果$を %buffer に付加する
【 — ただし，`~EoS$ が返されたときは、付加せずに繰返しを終える 】
◎
Read three bytes from stream into buffer.
</li>
	<li>
~IF［
%buffer ~NEQ ~byte列 [ `EF^X, `BB^X, `BF^X ]
］
⇒
%buffer を %~stream に`前付加する$
◎
If buffer does not match 0xEF 0xBB 0xBF, prepend buffer to stream.
</li>
	<li>
%出力 ~LET ~cp`~stream$
◎
Let output be a code point stream.
</li>
	<li>
( %~stream, %出力 )
を与える下で，
`UTF-8$n の`~decoder$を`走らす$
◎
Run UTF-8’s decoder with stream and output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="algo-head">
~byte~stream %~stream を
`~BOMはそのままに~UTF-8~decode@
するときは、次を走らす：
◎
To UTF-8 decode without BOM a byte stream stream, run these steps:
</p>

<ol>
	<li>
%出力 ~LET ~cp`~stream$
◎
Let output be a code point stream.
</li>
	<li>
( %~stream, %出力 )
を与える下で，
`UTF-8$n の`~decoder$を`走らす$
◎
Run UTF-8’s decoder with stream and output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>


<p class="algo-head">
~byte~stream %~stream を
`~BOMも失敗-もそのままに~UTF-8~decode@
するときは、次を走らす：
◎
To UTF-8 decode without BOM or fail a byte stream stream, run these steps:
</p>

<ol>
	<li>
%出力 ~LET ~cp`~stream$
◎
Let output be a code point stream.
</li>
	<li>
( %~stream, %出力, `fatal^l )
を与える下で，
`UTF-8$n の`~decoder$を`走らす$
◎
Let potentialError be the result of running UTF-8’s decoder with stream, output, and "fatal".
</li>
	<li>
~IF［
前~段の結果 ~EQ `~error$
］
⇒
~RET `失敗^i
◎
If potentialError is error, return failure.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>


<p class="algo-head">
~encoding %~encoding を利用して ~cp~stream %~stream を
`~encode@
するときは、次を走らす：
◎
To encode a code point stream stream using encoding encoding, run these steps:
</p>

<ol>
	<li>
~Assert：
%~encoding ~NIN 
{ `replacement$n, `UTF-16BE$n, `UTF-16LE$n }
◎
Assert: encoding is not replacement, UTF-16BE or UTF-16LE.
</li>
	<li>
%出力 ~LET ~byte`~stream$
◎
Let output be a byte stream.
</li>
	<li>
( %~stream, %出力, `html^l )
を与える下で，
 %~encoding の`~encoder$を`走らす$
◎
Run encoding’s encoder with stream, output, and "html".
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>


<p class="note">注記：
これは主に、~URLと~HTML~form用の旧来の~hookである。
`~UTF-8~encode$を被せた方が、決して`~error$を誘発させないので安全である。
`URL$r
`HTML$r
◎
This is mostly a legacy hook for URLs and HTML forms. Layering UTF-8 encode on top is safe as it never triggers errors. [URL] [HTML]
</p>

<div class="p">
<p class="algo-head">
~cp~stream %~stream を
`~UTF-8~encode@
するときは、次を走らす：
</p>

<ol>
	<li>
~RET `UTF-8$n を~encodingに利用して %~stream を`~encode$した結果
</li>
</ol>

◎
To UTF-8 encode a code point stream stream, return the result of encoding stream using encoding UTF-8.
</div>

	</section>
	<section id="api">

<h2 title="API">7. ~API</h2>

<p>
この節では Web IDL の各種用語が用いられる。
非~browser~UAに対しては、この~APIの~supportは要求されない。
`WEBIDL$r
◎
This section uses terminology from Web IDL. Non-browser user agents are not required to support this API.
◎
[WEBIDL]
</p>

<div class="example">
<p>
次の例は、 `TextEncoder$I ~objを利用して，文字列の配列を `ArrayBuffer$I に~encodeする。
結果は次を内容とする `Uint8Array$I になる：
<span class="block">
先頭が（ `Uint32Array$I としての）文字列の個数，その後は：
<span class="block">
最初の文字列の（ `Uint32Array$I としての）長さ,
`UTF-8$n に~encodeされたその文字列~data，<br>
2 番目の文字列の（ `Uint32Array$I としての）長さ,
その文字列~data，<br>
…
</span>
等々と続く。
</span>
◎
The following example uses the TextEncoder object to encode an array of strings into an ArrayBuffer. The result is a Uint8Array containing the number of strings (as a Uint32Array), followed by the length of the first string (as a Uint32Array), the UTF-8 encoded string data, the length of the second string (as a Uint32Array), the string data, and so on.
</p>

<pre>
function encodeArrayOfStrings(%strings) {
  var %encoder, %encoded, %len, %bytes, %view, %offset;

  %encoder = new TextEncoder();
  %encoded = [];

  %len = Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %strings.length; %i++) {
    %len += Uint32Array.BYTES_PER_ELEMENT;
    %encoded[%i] = %encoder.encode(%strings[%i]);
    %len += %encoded[%i].byteLength;
  }

  %bytes = new Uint8Array(%len);
  %view = new DataView(%bytes.buffer);
  %offset = 0;

  %view.setUint32(%offset, %strings.length);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %encoded.length; %i += 1) {
    %len = %encoded[%i].byteLength;
    %view.setUint32(%offset, %len);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %bytes.set(%encoded[%i], %offset);
    %offset += %len;
  }
  return %bytes.buffer;
}
</pre>

<p>
次の例は、［［
前の例, または `UTF-8$n 以外の~encodingに等価な~algo
］により生産される形式に~encodeされた~data
］を含んでいる `ArrayBuffer$I を~decodeして、元の，一連の文字列からなる配列に戻す。
◎
The following example decodes an ArrayBuffer containing data encoded in the format produced by the previous example, or an equivalent algorithm for encodings other than UTF-8, back into an array of strings.
</p>

<pre>
function decodeArrayOfStrings(%buffer, %encoding) {
  var %decoder, %view, %offset, %num_strings, %strings, %len;

  %decoder = new TextDecoder(%encoding);
  %view = new DataView(%buffer);
  %offset = 0;
  %strings = [];

  %num_strings = %view.getUint32(%offset);
  %offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var %i = 0; %i &lt; %num_strings; %i++) {
    %len = %view.getUint32(%offset);
    %offset += Uint32Array.BYTES_PER_ELEMENT;
    %strings[%i] = %decoder.decode(
      new DataView(%view.buffer, %offset, %len));
    %offset += %len;
  }
  return %strings;
}
</pre>
</div>

		<section id="interface-textdecoder">

<h3 title="Interface TextDecoder">7.1. ~interface `TextDecoder^I</h3>

<pre class="idl">
dictionary `TextDecoderOptions@I {
  `boolean$ fatal = false;
  `boolean$ ignoreBOM = false;
};

dictionary `TextDecodeOptions@I {
  `boolean$ stream = false;
};

[<a href="#dom-textdecoder">Constructor</a>(
    optional `DOMString$ %label = "utf-8",
    optional `TextDecoderOptions$I %options
),
 Exposed=(Window,Worker)]
interface `TextDecoder@I {
  readonly attribute `DOMString$ `encoding$m;
  readonly attribute `boolean$ `fatal$m;
  readonly attribute `boolean$ `ignoreBOM$m;
  `USVString$ `decode$m(
      optional BufferSource %input,
      optional `TextDecodeOptions$I %options
  );
};
</pre>

<p class="trans-note">【
<a href="Encoding-test.html">利用中の~browserでこの特色機能を試す</a>
】</p>

<div class="p">
<p>
各 `TextDecoder$I ~objには、次のものが結付けられる（括弧内は初期~値）：
</p>

<ul><li>`~encoding@dec
</li><li>`~decoder@dec
<p class="trans-note">【
`~encoding^ecに対応する`~decoder$の，~instance。
`~decoder$には，内部状態を保持する変数たちを伴うものもあるので、~objごとに~instanceを要する。
】</p>

</li><li>`~stream@dec
</li><li>`~BOMignore~flag@dec（ ~OFF ）
</li><li>`~BOMseen~flag@dec（ ~OFF ）
</li><li>`~error~mode@dec（ `replacement^l ）
</li><li>`~no_flush~flag@dec（ ~OFF ）
</li></ul>

◎
A TextDecoder object has an associated encoding, decoder, stream, ignore BOM flag (initially unset), BOM seen flag (initially unset), error mode (initially "replacement"), and do not flush flag (initially unset).
</div>


<p class="algo-head">
各 `TextDecoder$I ~objには、~streamを
`直列化-@dec
する~algoも結付けられる。
それは、所与の`~stream$ %~stream に対し，次を走らす：
◎
A TextDecoder object also has an associated serialize stream algorithm, that given a stream stream, runs these steps:
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>


		<ol>
			<li>
%~token ~LET %~stream から`読取った結果$
◎
Let token be the result of reading from stream.
</li>
			<li>
<p>
~IF［
`~encoding$dec ~IN { `UTF-8$n, `UTF-16BE$n, `UTF-16LE$n }
］~AND［
`~BOMignore~flag$dec ~EQ ~OFF
］~AND［
`~BOMseen~flag$dec ~EQ ~OFF
］：
◎
If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore BOM flag and BOM seen flag are unset, then:
</p>

				<ol>
					<li>
~IF［
%~token ~EQ `FEFF^U
］
⇒
`~BOMseen~flag$dec ~SET ~ON
◎
If token is U+FEFF, then set BOM seen flag.
</li>
					<li>
~ELIF［
%~token ~NEQ `~EoS$
］
⇒
`~BOMseen~flag$dec ~SET ~ON ~BR
%~token を %出力 に付加する
◎
Otherwise, if token is not end-of-stream, then set BOM seen flag and append token to output.
</li>
					<li>
~ELSE
⇒
~RET %出力
◎
Otherwise, return output.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%~token ~NEQ `~EoS$
］
⇒
%~token を %出力 に付加する
◎
Otherwise, if token is not end-of-stream, then append token to output.
</li>
			<li>
~ELSE
⇒
~RET %出力
◎
Otherwise, return output.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
この~algoは、~APIの利用者に より多くの制御を供するため，~platformの他の場所で利用される`~decode$ ~algoとは、~BOMの取扱いの点で意図的に異なるものにされている。
◎
This algorithm is intentionally different with respect to BOM handling from the decode algorithm used by the rest of the platform to give API users more control.
</p>

<hr>

<dl class="domintro">
	<dt>%decoder = new `TextDecoder$m([%label = "utf-8" [, %options]])</dt>
	<dd>
新たな `TextDecoder$I ~obj を返す。
◎
Returns a new TextDecoder object.
</dd>
	<dd>
%label が`~label$でない, または
%label が`replacement$nである場合、
`RangeError$E が`投出-$される。
◎
If label is either not a label or is a label for replacement, throws a RangeError.
</dd>

	<dt>%decoder . `encoding$m</dt>
	<dd>
`~encoding$decの`名前$を小文字~化して返す。
◎
Returns encoding’s name, lowercased.
</dd>

	<dt>%decoder . `fatal$m</dt>
	<dd>
`~error~mode$decが `fatal^l ならば ~T を, 他の場合は ~F を返す。
◎
Returns true if error mode is "fatal", and false otherwise.
</dd>

	<dt>%decoder . `ignoreBOM$m</dt>
	<dd>
`~BOMignore~flag$dec に応じて［
~ON ならば ~T ／
~OFF ならば ~F
］を返す。
◎
Returns true if ignore BOM flag is set, and false otherwise.
</dd>

	<dt>%decoder . `decode([input [, options]])$m</dt>
	<dd>
<p>
%input を `~encoding$decの`~decoder$にかけた結果を返す。
~streamを断片化して処理するときは、
%options の `stream^m ~memberを ~T にした下で，この~method 0 回~以上~呼出してから， %options を省略して（または その `stream^m ~memberを ~F にして）
1 回だけ呼出すことで行える。
後者の呼出時に %input もないならば、両~引数とも省略するのが最も簡明になる。
◎
Returns the result of running encoding’s decoder. The method can be invoked zero or more times with options’s stream set to true, and then once without options’s stream (or set to false), to process a fragmented stream. If the invocation without options’s stream (or set to false) has no input, it’s clearest to omit both arguments.
</p>

<pre class="example">
var %string = "", %decoder = new TextDecoder(%encoding), %buffer;
while(%buffer = next_chunk()) {
  %string += %decoder.decode(%buffer, {stream:true});
}
%string += %decoder.decode(); // ~EoS
</pre>

	</dd>
	<dd>
`~error~mode$dec ~EQ `fatal^l の下で，
`~encoding$decの`~decoder$が`~error$を返した場合、
`TypeError$E が`投出-$される。
◎
If the error mode is "fatal" and encoding’s decoder returns error, throws a TypeError.
</dd>
</dl>

<dl class="idl-def">
	<dt>`TextDecoder(label, options)@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
The TextDecoder(label, options) constructor, when invoked, must run these steps:
</p>

<ol>
	<li>
%~encoding ~LET %label から`~encodingを取得-$した結果
◎
Let encoding be the result of getting an encoding from label.
</li>
	<li>
~IF［
%~encoding ~IN { `失敗^i, `replacement$n }
］
⇒
~THROW `RangeError$E
◎
If encoding is failure or replacement, then throw a RangeError.
</li>
	<li>
%dec ~LET 新たな `TextDecoder$I ~obj
◎
Let dec be a new TextDecoder object.
</li>
	<li>
%dec の `~encoding$dec ~SET %~encoding
◎
Set dec’s encoding to encoding.
</li>
	<li>
~IF［
%options の `fatal^m ~member ~EQ ~T
］
⇒
%dec の `~error~mode$dec ~SET `fatal^l
◎
If options’s fatal member is true, then set dec’s error mode to "fatal".
</li>
	<li>
~IF［
%options の `ignoreBOM^m ~member ~EQ ~T
］
⇒
%dec の `~BOMignore~flag$dec ~SET `fatal^l
◎
If options’s ignoreBOM member is true, then set dec’s ignore BOM flag.
</li>
	<li>
~RET %dec
◎
Return dec.
</li>
</ol>

	</dd>

	<dt>`encoding@m</dt>
	<dd>
取得子は、此れの`~encoding$decの`名前$を`~ASCII小文字~化$した結果を返さ~MUST。
◎
The encoding attribute’s getter must return encoding’s name in ASCII lowercase.
</dd>

	<dt>`fatal@m</dt>
	<dd>
取得子は、［
此れの`~error~mode$dec ~EQ `fatal^l ならば ~T ／ ~ELSE_ ~F
］を返さ~MUST。
◎
The fatal attribute’s getter must return true if error mode is "fatal", and false otherwise.
</dd>

	<dt>`ignoreBOM@m</dt>
	<dd>
取得子は、［
此れの`~BOMignore~flag$dec ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The ignoreBOM attribute’s getter must return true if ignore BOM flag is set, and false otherwise.
</dd>

	<dt>`decode(input, options)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The decode(input, options) method, when invoked, must run these steps:
</p>

<ol>
	<li>
~IF［
此れの`~no_flush~flag$dec ~EQ ~OFF
］
⇒
此れの`~decoder$dec ~SET 新たな［
此れの`~encoding$decの`~decoder$
］ ~BR
此れの`~stream$dec ~SET 新たな`~stream$ ~BR
此れの`~BOMseen~flag$dec ~SET ~OFF
◎
If the do not flush flag is unset, set decoder to a new encoding’s decoder, set stream to a new stream, and unset the BOM seen flag.
</li>
	<li>
此れの`~no_flush~flag$dec ~SET［
%options の `stream^m ~EQ ~T ならば ~ON ／
~ELSE_ ~OFF
］
◎
If options’s stream is true, set the do not flush flag, and unset the do not flush flag otherwise.
</li>
	<li>
<p>
~IF［
%input は与えられている
］
⇒
%input の<a href="~WEBIDL#dfn-get-buffer-source-copy">複製</a>を 此れの`~stream$decに`~pushする$
◎
If input is given, then push a copy of input to stream.
</p>
<p class="note">注記：
実装には、この複製を避けるよう実装することが強く奨励される。
そうするときは、 %input が変更されても，後の `decode()$m の~callに影響しないようにする必要がある。
◎
Implementations are strongly encouraged to use an implementation strategy that avoids this copy. When doing so they will have to make sure that changes to input do not affect future calls to decode().
</p>
	</li>
	<li>
%出力 ~LET 新たな`~stream$
◎
Let output be a new stream.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>


		<ol>
			<li>
%~token ~LET 此れの`~stream$decから`読取った結果$
◎
Let token be the result of reading from stream.
</li>
			<li>
<p>
~IF［
%~token ~EQ `~EoS$
］~AND［
此れの`~no_flush~flag$dec ~EQ ~ON
］
⇒
~RET %出力 を`直列化-$decした結果
◎
If token is end-of-stream and the do not flush flag is set, then return output, serialized.
</p>

<p class="note">
~streamingでは、［
`~no_flush~flag$dec ~EQ ~ON
］のときに，ここで`~EoS$を取扱うことなく，その~flagを ~OFF にしない仕方で働く。
この仕方により、後続の呼出時には，`~decoder$decは この~algoの最初の段で一新されず、その状態は保全される。
◎
The way streaming works is to not handle end-of-stream here when the do not flush flag is set and to not unset that flag. That way in a subsequent invocation decoder is not set anew in the first step of the algorithm and its state is preserved.
</p>
			</li>
			<li>
%結果 ~LET 次を与える下で，`~tokenを処理-$した結果
⇒
( %~token, 此れの`~decoder$dec, 此れの`~stream$dec, %出力, 此れの`~error~mode$dec )
◎
Otherwise:
◎
Let result be the result of processing token for decoder, stream, output, and error mode.
</li>
			<li>
~IF［
%結果 ~EQ `完遂$
］
⇒
~RET %出力 を`直列化-$decした結果
◎
If result is finished, then return output, serialized.
</li>
			<li>
~IF［
%結果 ~EQ `~error$
］
⇒
~THROW `TypeError$E
◎
Otherwise, if result is error, then throw a TypeError.
</li>
		</ol>
	</li>
</ol>

	</dd>
</dl>

		</section>
		<section id="interface-textencoder">

<h3 title="Interface TextEncoder">7.2. ~interface `TextEncoder^I</h3>

<pre class="idl">
[<a href="#dom-textencoder" title="dom-TextEncoder">Constructor</a><!--
We cannot add an argument here that is not the label argument it had previously. That would break content.
-->, Exposed=(Window,Worker)]
interface `TextEncoder@I {
  readonly attribute `DOMString$ `~encoding0$m;
  [NewObject] `Uint8Array$ `encode$m(optional `USVString$ %input = "");
};
</pre>


<p>
各 `TextEncoder$I ~objには、
`~encoder@enc
が結付けられる：
◎
A TextEncoder object has an associated encoder.
</p>

<p class="note">注記：
`TextEncoder$I ~objの構築子には、 %label 引数はなく，~supportするのは `UTF-8$n のみである。
また、~scalar値~bufferを要する`~encoder$は無いので， `stream^m の~optionもない。
◎
A TextEncoder object offers no label argument as it only supports UTF-8. It also offers no stream option as no encoder requires buffering of scalar values.
</p>

<hr>

<dl class="domintro">
	<dt>%encoder = new `TextEncoder()$m</dt>
	<dd>
新たな `TextEncoder$I ~obj を返す。
◎
Returns a new TextEncoder object.
</dd>

	<dt>%encoder . `~encoding0$m</dt>
	<dd>
`utf-8^l を返す。
◎
Returns "utf-8".
</dd>

	<dt>%encoder . `encode([input = ""])$m</dt>
	<dd>
%input を `UTF-8$n の`~encoder$にかけた結果を返す。
◎
Returns the result of running UTF-8’s encoder.
</dd>

</dl>


<dl class="idl-def">
	<dt>`TextEncoder()@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
The TextEncoder() constructor, when invoked, must run these steps:
</p>

<ol>
	<li>
%enc ~LET 新たな `TextEncoder$I ~obj
◎
Let enc be a new TextEncoder object.
</li>
	<li>
%enc の 此れの`~encoder$enc ~SET `UTF-8$n の`~encoder$
◎
Set enc’s encoder to UTF-8’s encoder.
</li>
	<li>
~RET %enc
◎
Return enc.
</li>
</ol>

	</dd>

	<dt>`~encoding0@m</dt>
	<dd>
取得子は、 `utf-8^l を返さ~MUST。
◎
The encoding attribute’s getter must return "utf-8".
</dd>

	<dt>`encode(input)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The encode(input) method, when invoked, must run these steps:
</p>


<ol>
	<li>
%入力 ~LET %input を`~stream$に変換した結果
◎
Convert input to a stream.
</li>
	<li>
%出力 ~LET 新たな`~stream$
◎
Let output be a new stream.
</li>
	<li>
<p>
~WHILE 無条件 ：
◎
While true:
</p>

		<ol>
			<li>
%~token ~LET %入力 から`読取った結果$
◎
Let token be the result of reading from input.
</li>
			<li>
%結果 ~LET 次を与える下で，`~tokenを処理-$した結果
⇒
( %~token, 此れの`~encoder$enc, %入力, %出力 )
◎
Let result be the result of processing token for encoder, input, output.
</li>
			<li>
~IF［
%結果 ~EQ `完遂$
］
⇒
~RET ［［
%出力 を~byte列に変換した結果
］を包含する `ArrayBuffer$I
］を包装するような，新たな `Uint8Array$I ~obj
◎
If result is finished, convert output into a byte sequence, and then return a Uint8Array object wrapping an ArrayBuffer containing output.
</li>
		</ol>

<p class="note">注記：
`UTF-8$n が`~error$を返すことはない。
◎
UTF-8 cannot return error.
</p>
	</li>
</ol>
	</dd>
</dl>

		</section>
	</section>
	<section id="the-encoding">

<h2 title="The encoding">8. ~~標準の~encoding</h2>

<p class="trans-note">【
この “~~標準の” は “The” の対訳であり、およそ，
“規範とされるべき唯一無二の”
を意味する。
】</p>

		<section id="utf-8">

<h3>8.1. ~UTF-8</h3>

			<section id="utf-8-decoder">
<h4 title="UTF-8 decoder">8.1.1. ~UTF-8~decoder</h4>


<p>
`UTF-8$n の`~decoder$の各~instanceには、次のものが結付けられる
⇒
`~UTF-8~cp@（初期~時 0 ）~BR
`~UTF-8出現~byte数@（初期~時 0 ）~BR
`~UTF-8要~byte数@（初期~時 0 ）~BR
`~UTF-8下限@（初期~時 `80^X ）~BR
`~UTF-8上限@（初期~時 `BF^X ）
◎
UTF-8’s decoder’s has an associated UTF-8 code point, UTF-8 bytes seen, and UTF-8 bytes needed (all initially 0), a UTF-8 lower boundary (initially 0x80), and a UTF-8 upper boundary (initially 0xBF).
</p>

<p>
`UTF-8$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
UTF-8’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
~IF［
%~byte ~EQ `~EoS$
］~AND［
`~UTF-8要~byte数$ ~NEQ 0
］
⇒
`~UTF-8要~byte数$ ~SET 0 ~BR
~RET `~error$
◎
If byte is end-of-stream and UTF-8 bytes needed is not 0, set UTF-8 bytes needed to 0 and return error.
</li>
	<li>
~IF［
%~byte ~EQ `~EoS$
］
⇒
~RET `完遂$
◎
If byte is end-of-stream, return finished.
</li>
	<li>
<p>
~IF［
`~UTF-8要~byte数$ ~EQ 0
］：
◎
If UTF-8 bytes needed is 0, based on byte:
</p>

		<ol>
			<li>
<p>
%~byte に応じて：
◎
↑</p>

				<dl class="switch">
					<dt>`00^X 〜 `7F^X</dt>
					<dd>
~RET ~cp [ %~byte ]
◎
Return a code point whose value is byte.
</dd>

					<dt>`C2^X 〜 `DF^X</dt>
					<dd>
						<ol>
							<li>
`~UTF-8要~byte数$ ~SET 1
◎
Set UTF-8 bytes needed to 1.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `1F^X
<span class="note">（ %~byte の下位 5 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0x1F.
◎
The five least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`E0^X 〜 `EF^X</dt>
					<dd>
						<ol>
							<li>
~IF［
%~byte ~EQ `E0^X
］
⇒
`~UTF-8下限$ ~SET `A0^X
◎
If byte is 0xE0, set UTF-8 lower boundary to 0xA0.
</li>
							<li>
~IF［
%~byte ~EQ `ED^X
］
⇒
`~UTF-8上限$ ~SET `9F^X
◎
If byte is 0xED, set UTF-8 upper boundary to 0x9F.
</li>
							<li>
`~UTF-8要~byte数$ ~SET 2
◎
Set UTF-8 bytes needed to 2.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `F^X
<span class="note">（ %~byte の下位 4 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0xF.
◎
The four least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>`F0^X 〜 `F4^X</dt>
					<dd>
						<ol>
							<li>
~IF［
%~byte ~EQ `F0^X
］
⇒
`~UTF-8下限$ ~SET `90^X
◎
If byte is 0xF0, set UTF-8 lower boundary to 0x90.
</li>
							<li>
~IF［
%~byte ~EQ `F4^X
］
⇒
`~UTF-8上限$ ~SET `8F^X
◎
If byte is 0xF4, set UTF-8 upper boundary to 0x8F.
</li>
							<li>
`~UTF-8要~byte数$ ~SET 3
◎
Set UTF-8 bytes needed to 3.
</li>
							<li>
`~UTF-8~cp$ ~SET %~byte ~bAND `7^X
<span class="note">（ %~byte の下位 3 ~bit ）</span>
◎
Set UTF-8 code point to byte &amp; 0x7.
◎
The three least significant bits of byte.
</li>
						</ol>
					</dd>

					<dt>~OTHER◎Otherwise</dt>
					<dd>
~RET `~error$
◎
Return error.
</dd>
				</dl>
			</li>
			<li>
~RET `継続$
◎
Return continue.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~byte ~NIN { `~UTF-8下限$ 〜 `~UTF-8上限$ }
］：
◎
If byte is not in the range UTF-8 lower boundary to UTF-8 upper boundary, inclusive, then:
</p>

		<ol>
			<li>
( `~UTF-8~cp$, `~UTF-8要~byte数$, `~UTF-8出現~byte数$ ) ~SET ( 0, 0, 0 ) ~BR
( `~UTF-8下限$, `~UTF-8上限$ ) ~SET ( `80^X, `BF^X )
◎
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0, set UTF-8 lower boundary to 0x80, and set UTF-8 upper boundary to 0xBF.
</li>
	<li>
%~byte を %~stream に`前付加する$
◎
Prepend byte to stream.
</li>
	<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
( `~UTF-8下限$, `~UTF-8上限$ ) ~SET ( `80^X, `BF^X )
◎
Set UTF-8 lower boundary to 0x80 and UTF-8 upper boundary to 0xBF.
</li>
	<li>
<p>
`~UTF-8~cp$ ~SET (`~UTF-8~cp$ ~Lshift 6) ~bOR (%~byte ~bAND `3F^X)
◎
Set UTF-8 code point to (UTF-8 code point &lt;&lt; 6) | (byte &amp; 0x3F)
</p>

<p class="note">
`~UTF-8~cp$内の既存の~bitを左へ 6 ~bit ~shiftして，~~空いた下位 6 ~bitに %~byte の下位 6 ~bitをあてがう。
◎
Shift the existing bits of UTF-8 code point left by six places and set the newly-vacated six least significant bits to the six least significant bits of byte.
</p>
	</li>
	<li>
`~UTF-8出現~byte数$ ~INCBY 1
◎
Increase UTF-8 bytes seen by one.
</li>
	<li>
~IF［
`~UTF-8出現~byte数$ ~NEQ `~UTF-8要~byte数$
］
⇒
~RET `継続$
◎
If UTF-8 bytes seen is not equal to UTF-8 bytes needed, return continue.
</li>
	<li>
%~cp ~LET `~UTF-8~cp$
◎
Let code point be UTF-8 code point.
</li>
	<li>
( `~UTF-8~cp$, `~UTF-8要~byte数$, `~UTF-8出現~byte数$ ) ~SET ( 0, 0, 0 ) 
◎
Set UTF-8 code point, UTF-8 bytes needed, and UTF-8 bytes seen to 0.
</li>
	<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
</ol>

<p class="note">注記：
上の`~UTF-8~decoder$における拘束は、~Unicode標準の
“Best Practices for Using U+FFFD”
に準じる。
他のふるまいは Encoding 標準の下では許可されない（同じ結果が得られるなら、他の~algoでも~~十分であり，むしろ奨励される）。
`UNICODE$r
◎
The constraints in the UTF-8 decoder above match “Best Practices for Using U+FFFD” from the Unicode standard. No other behavior is permitted per the Encoding Standard (other algorithms that achieve the same result are fine, even encouraged). [UNICODE]
</p>

			</section>
			<section id="utf-8-encoder">
<h4 title="UTF-8 encoder">8.1.2. ~UTF-8~encoder</h4>

<p>
`UTF-8$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
UTF-8’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `~EoS$
］
⇒
~RET `完遂$
◎
If code point is end-of-stream, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
( %count, %~offset ) ~SET %~cp が属する範囲に応じて，次で与えられる値：
◎
Set count and offset based on the range code point is in:
</p>

<div>

		<dl class="switch">
			<dt>`0080^U 〜 `07FF^U</dt>
			<dd>
( 1, `C0^X )
</dd>
			<dt>`0800^U 〜 `FFFF^U</dt>
			<dd>
( 2, `E0^X )
</dd>
			<dt>`10000^U 〜 `10FFFF^U</dt>
			<dd>
( 3, `F0^X )
</dd>
		</dl>

◎
U+0080 to U+07FF, inclusive
• 1 and 0xC0
U+0800 to U+FFFF, inclusive
• 2 and 0xE0
U+10000 to U+10FFFF, inclusive
• 3 and 0xF0
</div>

	</li>
	<li>
%~byte列 ~LET ~byte列 [ ( %~cp ~Rshift ( 6 ~MUL %count ) ) ~PLUS %~offset ]
◎
Let bytes be a byte sequence whose first byte is (code point &gt;&gt; (6 × count)) + offset.
</li>
	<li>
<p>
~WHILE %count ~GT 0
：
◎
While count is greater than 0:
</p>

		<ol>
			<li>
%temp ~SET %~cp ~Rshift ( 6 ~MUL ( %count ~MINUS 1 ) )
◎
Set temp to code point &gt;&gt; (6 × (count − 1)).
</li>
	<li>
( `80^X ~bOR ( %temp ~bAND `3F^X ) ) を %~byte列 に付加する
◎
Append to bytes 0x80 | (temp &amp; 0x3F).
</li>
	<li>
%count ~DECBY 1
◎
Decrease count by one.
</li>
		</ol>
	</li>
	<li>
~RET %~byte列
◎
Return bytes bytes, in order.
</li>
</ol>

<p class="note">
この~algoは、~Unicode標準に述べられるものと一致する結果を得るが、完全さのためここに含められている。
`UNICODE$r
◎
This algorithm has identical results to the one described in the Unicode standard. It is included here for completeness. [UNICODE]
</p>


			</section>
		</section>
	</section>
	<section id="legacy-single-byte-encodings">

<h2 title="Legacy single-byte encodings">9. 旧来の単byte~encoding</h2>

<p>
各~byteが［
１個の~cpに対応するか, または対応する~cpは無い
］ような`~encoding$を
`単byte~encoding@
と呼ぶ。
すべての`単byte~encoding$が、同じ［
`~decoder$, `~encoder$
］を共有する。
`単byte~decoder$／`単byte~encoder$から参照される
`単byte索引@
は、利用される`単byte~encoding$に依存し，次の一覧で定義される。
［
`ISO-8859-8^n, `ISO-8859-8-I^n
］を除くすべての`単byte~encoding$は、それぞれに一意な`索引$を持つ。
◎
An encoding where each byte is either a single code point or nothing, is a single-byte encoding. Single-byte encodings share the decoder and encoder. Index single-byte, as referenced by the single-byte decoder and single-byte encoder, is defined by the following table, and depends on the single-byte encoding in use. All but two single-byte encodings have a unique index.
</p>

<p class="trans-note">【
被覆域の~tableは巨大なことに注意。
】</p>

<table>
<thead><tr><th>`名前$
<th>`索引$
<th>視覚化
<th>基本多言語面（ BMP ）の被覆域
</thead>

<tbody>
<tr><td>`IBM866@n<td>`IBM866$idx
<tr><td>`ISO-8859-2@n<td>`ISO-8859-2$idx
<tr><td>`ISO-8859-3@n<td>`ISO-8859-3$idx
<tr><td>`ISO-8859-4@n<td>`ISO-8859-4$idx
<tr><td>`ISO-8859-5@n<td>`ISO-8859-5$idx
<tr><td>`ISO-8859-6@n<td>`ISO-8859-6$idx
<tr><td>`ISO-8859-7@n<td>`ISO-8859-7$idx
<tr><td>`ISO-8859-8@n<td>`ISO-8859-8$idx
<tr><td>`ISO-8859-8-I@n<td colspan="3">`ISO-8859-8$n と同じ
<tr><td>`ISO-8859-10@n<td>`ISO-8859-10$idx
<tr><td>`ISO-8859-13@n<td>`ISO-8859-13$idx
<tr><td>`ISO-8859-14@n<td>`ISO-8859-14$idx
<tr><td>`ISO-8859-15@n<td>`ISO-8859-15$idx
<tr><td>`ISO-8859-16@n<td>`ISO-8859-16$idx
<tr><td>`KOI8-R@n<td>`KOI8-R$idx
<tr><td>`KOI8-U@n<td>`KOI8-U$idx
<tr><td>`macintosh@n<td>`macintosh$idx
<tr><td>`windows-874@n<td>`windows-874$idx
<tr><td>`windows-1250@n<td>`windows-1250$idx
<tr><td>`windows-1251@n<td>`windows-1251$idx
<tr><td>`windows-1252@n<td>`windows-1252$idx
<tr><td>`windows-1253@n<td>`windows-1253$idx
<tr><td>`windows-1254@n<td>`windows-1254$idx
<tr><td>`windows-1255@n<td>`windows-1255$idx
<tr><td>`windows-1256@n<td>`windows-1256$idx
<tr><td>`windows-1257@n<td>`windows-1257$idx
<tr><td>`windows-1258@n<td>`windows-1258$idx
<tr><td>`x-mac-cyrillic@n<td>`x-mac-cyrillic$idx
</tbody>
</table>

<p class="note">注記：
~layout方向に波及することから、 `ISO-8859-8$n と `ISO-8859-8-I$n の`~encoding$の`名前$は異なるものにされている。
歴史的に、このことは `ISO-8859-6$n と "ISO-8859-6-I" についても該当していたが、それは今や成立しない。
<!-- https://www.w3.org/Bugs/Public/show_bug.cgi?id=19505 -->
◎
ISO-8859-8 and ISO-8859-8-I are distinct encoding names, because ISO-8859-8 has influence on the layout direction. And although historically this might have been the case for ISO-8859-6 and "ISO-8859-6-I" as well, that is no longer true.
</p>



		<section id="single-byte-decoder">
<h3 title="single-byte decoder">9.1. 単byte~decoder</h3>

<p>
`単byte~encoding$の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
Single-byte encodings’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
~IF［
%~byte ~EQ `~EoS$
］
⇒
~RET `完遂$
◎
If byte is end-of-stream, return finished.
</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
%~cp ~LET
`単byte索引$ の中で
( %~byte ~MINUS `80^X )
が指す`索引~cp$
◎
Let code point be the index code point for byte − 0x80 in index single-byte.
</li>
	<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$
◎
If code point is null, return error.
</li>
	<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
</ol>

		</section>
		<section id="single-byte-encoder">
<h3 title="single-byte encoder">9.2. 単byte~encoder</h3>

<p>
`単byte~encoding$ の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
Single-byte encodings’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `~EoS$
］
⇒
~RET `完遂$
◎
If code point is end-of-stream, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET
`単byte索引$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index single-byte.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
~RET ~byte列 [ %~pointer ~PLUS `80^X ]
◎
Return a byte whose value is pointer + 0x80.
</li>
</ol>

		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(simplified)-encodings">

<h2 title="Legacy multi-byte Chinese (simplified) encodings">10. 旧来の複byte Chinese （簡体字） ~encoding</h2>

		<section id="gbk">
<h3 title="GBK">10.1 ~GBK</h3>

			<section id="gbk-decoder">
<h4 title="GBK decoder">10.1.1 ~GBK~decoder</h4>

<p>
`GBK$nの`~decoder$は，`gb18030$nの`~decoder$である。
◎
GBK’s decoder is gb18030’s decoder.
</p>

			</section>
			<section id="gbk-encoder">
<h4 title="GBK encoder">10.1.2 ~GBK~encoder</h4>

<p>
GBK の~encoderは，［
`~GBK~flag$ ~SET ~ON
］にされた`gb18030$nの`~encoder$である。
◎
GBK’s encoder is gb18030’s encoder with its GBK flag set.
</p>


<p class="note">注記：
`GBK$nを`gb18030$nに対する全くの別名にしないのは、
`GBK$nの`~encoder$により生成された内容を，旧来の~serverや他の消費者をなるべく壊すことなく，保守的に移行するためである。
◎
Not fully aliasing GBK with gb18030 is a conservative move to decrease the chances of breaking legacy servers and other consumers of content generated with GBK’s encoder.
</p>
			</section>
		</section>


		<section id="gb18030">

<h3 title="gb18030">10.2. ~gb18030</h3>


			<section id="gb18030-decoder">
<h4 title="gb18030 decoder">10.2.1. ~gb18030~decoder</h4>

<p>
`gb18030$n の`~decoder$の各~instanceには、次のものが結付けられる
⇒
`~gb1@（初期~時 0 ）~BR
`~gb2@（初期~時 0 ）~BR
`~gb3@（初期~時 0 ）
◎
gb18030’s decoder has an associated gb18030 first, gb18030 second, and gb18030 third (all initially 0x00).
</p>

<p>
`gb18030$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
gb18030’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
( `~gb1$, `~gb2$, `~gb3$ ) ~EQ ( `00^X, `00^X, `00^X )
］
⇒
~RET `完遂$
◎
If byte is end-of-stream and gb18030 first, gb18030 second, and gb18030 third are 0x00, return finished.
</li>
			<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X ) ~BR
~RET `~error$
◎
If byte is end-of-stream, and gb18030 first, gb18030 second, or gb18030 third is not 0x00, set gb18030 first, gb18030 second, and gb18030 third to 0x00, and return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb3$ ~NEQ `00^X
］：
◎
If gb18030 third is not 0x00, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~byte ~NIN { `30^X 〜 `39^X }
］：
◎
If byte is not in the range 0x30 to 0x39, inclusive, then:
</p>
				<ol>
					<li>
~byte列 [ `~gb2$, `~gb3$, %~byte ] を %~stream に`前付加する$
◎
Prepend gb18030 second, gb18030 third, and byte to stream.
</li>
					<li>
( `~gb1$, `~gb2$, `~gb3$ ) ~SET ( `00^X, `00^X, `00^X )
◎
Set gb18030 first, gb18030 second, and gb18030 third to 0x00.
</li>
					<li>
~RET `~error$
◎
Return error.
</li>
				</ol>
			</li>
			<li>
%~cp ~LET 次に与える~pointerが指す`索引~gb18030範囲集~cp$
⇒
(( `~gb1$ ~MINUS `81^X ) ~MUL ( 10 ~MUL 126 ~MUL 10 )) ~PLUS
(( `~gb2$ ~MINUS `30^X ) ~MUL ( 10 ~MUL 126 )) ~PLUS
(( `~gb3$ ~MINUS `81^X ) ~MUL 10 ) ~PLUS
( %~byte ~MINUS `30^X )
◎
Let code point be the index gb18030 ranges code point for ((gb18030 first − 0x81) × (10 × 126 × 10)) + ((gb18030 second − 0x30) × (10 × 126)) + ((gb18030 third − 0x81) × 10) + byte − 0x30.
</li>
			<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$
◎
If code point is null, return error.
</li>
			<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb2$ ~NEQ `00^X
］：
◎
If gb18030 second is not 0x00, then:
</p>

		<ol>
			<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒
`~gb3$ ~SET %~byte ~BR
~RET `継続$
◎
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 third to byte and return continue.
</li>
			<li>
~byte列 [ `~gb2$, %~byte ] を %~stream に`前付加する$ ~BR
( `~gb1$, `~gb2$ ) ~SET ( `00^X, `00^X ) ~BR
~RET `~error$
◎
Prepend gb18030 second followed by byte to stream, set gb18030 first and gb18030 second to 0x00, and return error.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~gb1$ ~NEQ `00^X
］：
◎
If gb18030 first is not 0x00, then:
</p>

		<ol>
			<li>
~IF［
%~byte ~IN { `30^X 〜 `39^X }
］
⇒
`~gb2$ ~SET %~byte ~BR
~RET `継続$
◎
If byte is in the range 0x30 to 0x39, inclusive, set gb18030 second to byte and return continue.
</li>
			<li>
%~lead ~LET `~gb1$ ~BR
%~pointer ~LET ~NULL ~BR
`~gb1$ ~SET `00^X
◎
Let lead be gb18030 first, let pointer be null, and set gb18030 first to 0x00.
</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if byte is less than 0x7F and 0x41 otherwise.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `80^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS %~offset )
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 + (byte − offset).
</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_
`索引~gb18030$ の中で %~pointer が指す`索引~cp$
］
◎
Let code point be null if pointer is null and the index code point for pointer in index gb18030 otherwise.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
%~byte を %~stream に`前付加する$
◎
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
<p>
%~byte に応じて：
◎
↓</p>

		<dl class="switch">
			<dt>`~ASCII~byte$</dt>
			<dd>
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</dd>

			<dt>`80^X</dt>
			<dd>
~RET ~cp [ `20AC^U ]
◎
If byte is 0x80, return code point U+20AC.
</dd>

			<dt>`81^X 〜 `FE^X</dt>
			<dd>
`~gb1$ ~SET %~byte ~BR
~RET `継続$
◎
If byte is in the range 0x81 to 0xFE, inclusive, set gb18030 first to byte and return continue.
</dd>

			<dt>その他（ `FF^X ）</dt>
			<dd>
~RET `~error$
◎
Return error.
</dd>

		</dl>
	</li>
</ol>


			</section>
			<section id="gb18030-encoder">
<h4 title="gb18030 encoder">10.2.2. ~gb18030~encoder</h4>

<p>
`gb18030$nの `~encoder$の各~instanceには、次のものが結付けられる
⇒
`~GBK~flag@（初期~時 ~OFF ）
◎
gb18030’s encoder has an associated GBK flag (initially unset).
</p>

<p>
`gb18030$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
gb18030’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `~EoS$
］
⇒
~RET `完遂$
◎
If code point is end-of-stream, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
~IF［
%~cp ~EQ `E5E5^U
］
⇒
~RET %~cp を伴う`~error$
◎
If code point is U+E5E5, return error with code point.
</p>

<p class="note">注記：
配備済みの内容との互換性をとるため、 `索引~gb18030$ は［
`A3^X `A0^X
］を `E5E5^U ではなく `3000^U に対応付けている。
したがって往来できない。
◎
Index gb18030 maps 0xA3 0xA0 to U+3000 rather than U+E5E5 for compatibility with deployed content. Therefore it cannot roundtrip.
</p>

</li>
	<li>
~IF［
`~GBK~flag$ ~EQ ~ON
］~AND［
%~cp ~EQ `20AC^U
］
⇒
~RET ~byte列 [ `80^X ]
◎
If the GBK flag is set and code point is U+20AC, return byte 0x80.
</li>
	<li>
%~pointer ~LET
`索引~gb18030$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index gb18030.
</li>
	<li>
<p>
~IF［
%~pointer ~NEQ ~NULL
］：
◎
If pointer is non-null, then:
</p>

		<ol>
			<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
◎
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET %~pointer ~MOD 190
◎
Let trail be pointer % 190.
</li>
			<li>
%~offset ~LET ［
%~trail  ~IN { `00^X 〜 `3E^X } ならば `40^X<!--0x7F-0x40--> ／
~ELSE_ `41^X
］
◎
Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.
</li>
			<li>
~RET ~byte列 [ %~lead, ( %~trail ~PLUS %~offset ) ]
◎
Return two bytes whose values are lead and trail + offset.
</li>
		</ol>
	</li>
	<li>
~IF［
`~GBK~flag$ ~EQ ~ON
］
⇒
~RET %~cp を伴う`~error$
◎
If GBK flag is set, return error with code point.
</li>
	<li>
%~pointer ~SET
%~cp
を指す`索引~gb18030範囲集~pointer$
◎
Set pointer to the index gb18030 ranges pointer for code point.
</li>
	<li>
%byte1 ~LET %~pointer ~DIV ( 10 ~MUL 126 ~MUL 10 )
◎
Let byte1 be pointer / (10 × 126 × 10).
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 ~MUL 10 )
◎
Set pointer to pointer % (10 × 126 × 10).
</li>
	<li>
%byte2 ~LET %~pointer ~DIV ( 10 ~MUL 126 )
◎
Let byte2 be pointer / (10 × 126). 
</li>
	<li>
%~pointer ~SET %~pointer ~MOD ( 10 ~MUL 126 )
◎
Set pointer to pointer % (10 × 126). 
</li>
	<li>
%byte3 ~LET %~pointer ~DIV 10
◎
Let byte3 be pointer / 10.
</li>
	<li>
%byte4 ~LET %~pointer ~MOD 10
◎
Let byte4 be pointer % 10. 
</li>
	<li>
~RET ~byte列 [
( %byte1 ~PLUS `81^X ),
( %byte2 ~PLUS `30^X ),
( %byte3 ~PLUS `81^X ),
( %byte4 ~PLUS `30^X )
]
◎
Return four bytes whose values are byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-chinese-(traditional)-encodings">

<h2 title="Legacy multi-byte Chinese (traditional) encodings">11. 旧来の複byte Chinese （繁体字）~encoding</h2>

<!--
 Lead:  0x81 to 0xFE
 Trail: 0x40 to 0x7E or 0xA1 to 0xFE
-->


		<section id="big5">

<h3 title="Big5">11.1. ~Big5</h3>

			<section id="big5-decoder">
<h4 title="Big5 decoder">11.1.1. ~Big5~decoder</h4>

<p>
`Big5$n の`~decoder$の各~instanceには、次のものが結付けられる
⇒
`~Big5~lead@（初期~時 `00^X ）
◎
Big5’s decoder has an associated Big5 lead (initially 0x00).
</p>

<p>
`Big5$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
Big5’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
</p>

		<ol>
			<li>
~IF［
`~Big5~lead$ ~NEQ `00^X
］
⇒
`~Big5~lead$ ~SET `00^X ~BR
~RET `~error$
</li>
			<li>
~RET `完遂$
</li>
		</ol>
◎
If byte is end-of-stream and Big5 lead is not 0x00, set Big5 lead to 0x00 and return error.
◎
If byte is end-of-stream and Big5 lead is 0x00, return finished.
</li>
	<li>
<p>
~IF［
`~Big5~lead$ ~NEQ `00^X
］：
◎
If Big5 lead is not 0x00, let lead be Big5 lead, let pointer be null, set Big5 lead to 0x00, and then:
</p>

		<ol>
			<li>
%~lead ~LET `~Big5~lead$ ~BR
%~pointer ~LET ~NULL ~BR
`~Big5~lead$ ~SET `00^X
◎
↑</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `62^X <!-- 0x62 = 0xA1-0x7E+1+0x40 -->
］
◎
Let offset be 0x40 if byte is less than 0x7F and 0x62 otherwise.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `A1^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 157 ~PLUS ( %~byte ~MINUS %~offset )
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1 to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 ~PLUS (byte − offset).
</li>
			<li>
<p>
~IF［
下の表の中で， 1 列目が %~pointer に等しい行がある
］
⇒
~RET 同じ行の 2 列目の <em>2 個の</em> ~cpからなる`~token$列
◎
If there is a row in the table below whose first column is pointer, return the two code points listed in its second column (the third column is irrelevant):
</p>

<!-- https://www.unicode.org/Public/UNIDATA/NamedSequences.txt -->
<table><thead><tr><th>~pointer◎Pointer
<th>~cp◎Code points
<th>説明（この段には関係ない）◎Notes
</thead>

<tbody id="_big5-lead"><tr><td>1133<!-- 0x88 0x62 -->
<td>`00CA^U `0304^U
<td>Ê̄ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON)

<tr><td>1135<!-- 0x88 0x64 -->
<td>`00CA^U `030C^U
<td>Ê̌ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON)

<tr><td>1164<!-- 0x88 0xA3 -->
<td>`00EA^U `0304^U
<td>ê̄ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON)

<tr><td>1166<!-- 0x88 0xA5 -->
<td>`00EA^U `030C^U
<td>ê̌ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON)

</tbody></table>
<!-- we do this to avoid PUA -->


<p class="note">注記：
`索引$ は単独の~cpに制限されるので、これらの~pointerにはこの表が利用される。
◎
Since indexes are limited to single code points this table is used for these pointers.
</p>
			</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~Big5$ の中で %~pointer が指す`索引~cp$
］
◎
Let code point be null if pointer is null and the index code point for pointer in index Big5 otherwise.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
%~byte を %~stream に`前付加する$
◎
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒
`~Big5~lead$ ~SET %~byte ~BR
~RET `継続$
◎
If byte is in the range 0x81 to 0xFE, inclusive, set Big5 lead to byte and return continue.
</li>
	<li>
~RET `~error$
◎
Return error.
</li>
</ol>

			</section>
			<section id="big5-encoder">
<h4 title="Big5 encoder">11.1.2. ~Big5~encoder</h4>

<p>
`Big5$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
Big5’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `~EoS$
］
⇒
~RET `完遂$
◎
If code point is end-of-stream, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET %~cp を指す`索引~Big5~pointer$
◎
Let pointer be the index Big5 pointer for code point.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 157 ) ~PLUS `81^X
◎
Let lead be pointer / 157 + 0x81.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 157
◎
Let trail be pointer % 157.
</li>
	<li>
%~offset ~LET ［
%~trail ~IN { `00^X 〜 `3E^X } ならば `40^X<!--0x7F-0x40--> ／
~ELSE_ `62^X<!--0xA1-0x3F-->
］
◎
Let offset be 0x40 if trail is less than 0x3F and 0x62 otherwise.
</li>
	<li>
~RET ~byte列 [ %~lead, ( %~trail ~PLUS %~offset) ]
◎
Return two bytes whose values are lead and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-japanese-encodings">

<h2 title="Legacy multi-byte Japanese encodings">12. 旧来の複byte Japanese ~encoding</h2>


		<section id="euc-jp">

<h3 title="EUC-JP">12.1. ~EUC-JP</h3>

<!-- https://www.iana.org/assignments/charset-reg/CP51932 -->

			<section id="euc-jp-decoder">
<h4 title="EUC-JP decoder">12.1.1. ~EUC-JP~decoder</h4>

<p>
`EUC-JP$n の`~decoder$の各~instanceには、次のものが結付けられる
⇒
`~EUC-JP~jis0212~flag@（初期~時 ~OFF ）~BR
`~EUC-JP~lead@（初期~時 `00^X）
◎
EUC-JP’s decoder has an associated EUC-JP jis0212 flag (initially unset) and EUC-JP lead (initially 0x00).
</p>

<p>
`EUC-JP$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
EUC-JP’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
`~EUC-JP~lead$ ~NEQ `00^X
］
⇒
`~EUC-JP~lead$ ~SET `00^X ~BR
~RET `~error$
◎
If byte is end-of-stream and EUC-JP lead is not 0x00, set EUC-JP lead to 0x00, and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂$
◎
If byte is end-of-stream and EUC-JP lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
~IF［
`~EUC-JP~lead$ ~EQ `8E^X
］~AND［
%~byte ~IN { `A1^X 〜 `DF^X }
］
⇒
`~EUC-JP~lead$ ~SET `00^X ~BR
~RET ~cp [ `FF61^X ~MINUS `A1^X ~PLUS %~byte ]
<!-- katakana; subtraction is done first to avoid upsetting compilers -->
◎
If EUC-JP lead is 0x8E and byte is in the range 0xA1 to 0xDF, inclusive, set EUC-JP lead to 0x00 and return a code point whose value is 0xFF61 − 0xA1 + byte.
</li>
	<li>
~IF［
`~EUC-JP~lead$ ~EQ `8F^X
］~AND［
%~byte ~IN { `A1^X 〜 `FE^X }
］
⇒
`~EUC-JP~jis0212~flag$ ~SET ~ON ~BR
`~EUC-JP~lead$ ~SET %~byte ~BR
~RET `継続$
◎
If EUC-JP lead is 0x8F and byte is in the range 0xA1 to 0xFE, inclusive, set the EUC-JP jis0212 flag, set EUC-JP lead to byte, and return continue.
</li>
	<li>
<p>
~IF［
`~EUC-JP~lead$ ~NEQ `00^X
］：
◎
If EUC-JP lead is not 0x00, let lead be EUC-JP lead, set EUC-JP lead to 0x00, and then:
</p>

		<ol>
			<li>
%~lead ~LET `~EUC-JP~lead$ ~BR
`~EUC-JP~lead$ ~SET `00^X
◎
↑</li>
			<li>
%~cp ~LET ~NULL
◎
Let code point be null.
</li>
			<li>
~IF［
%~lead, %~byte がいずれも ~IN { `A1^X 〜 `FE^X }
］
⇒
%索引 ~LET ［
`~EUC-JP~jis0212~flag$ ~EQ ~OFF ならば`索引~jis0208$ ／
~ON ならば［
`索引~jis0212$
］~BR
%~cp ~SET %索引 の中で
( ( %~lead ~MINUS `A1^X ) ~MUL 94 ~PLUS %~byte ~MINUS `A1^X )
が指す`索引~cp$
◎
If lead and byte are both in the range 0xA1 to 0xFE, inclusive, set code point to the index code point for (lead − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the EUC-JP jis0212 flag is unset and in index jis0212 otherwise.
</li>
			<li>
`~EUC-JP~jis0212~flag$ ~SET ~OFF
◎
Unset the EUC-JP jis0212 flag.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
%~byte を %~stream に`前付加する$
◎
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `8E^X, `8F^X, `A1^X 〜 `FE^X }
］
⇒
`~EUC-JP~lead$ ~SET %~byte ~BR
~RET `継続$
◎
If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, inclusive, set EUC-JP lead to byte and return continue.
</li>
	<li>
~RET `~error$
◎
Return error.
</li>
</ol>


			</section>
			<section id="euc-jp-encoder">
<h4 title="EUC-JP encoder">12.1.2. ~EUC-JP~encoder</h4>

<p>
`EUC-JP$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
EUC-JP’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
<p>
%~cp に応じて：
◎
↓</p>
		<dl class="switch">
			<dt>`~EoS$</dt>
			<dd>
~RET `完遂$
◎
If code point is end-of-stream, return finished.
</dd>

			<dt>`~ASCII~cp$</dt>
			<dd>
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

			<dt>`00A5^U</dt>
			<dd>
~RET ~byte列 [ `5C^X ]
◎
If code point is U+00A5, return byte 0x5C.
</dd>

			<dt>`203E^U</dt>
			<dd>
~RET ~byte列 [ `7E^X ]
◎
If code point is U+203E, return byte 0x7E.
</dd>

			<dt>`FF61^U 〜 `FF9F^U</dt>
			<dd>
~RET ~byte列 [ `8E^X, ( %~cp ~MINUS `FF61^X ~PLUS `A1^X ) ]
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, return two bytes whose values are 0x8E and code point − 0xFF61 + 0xA1.
</dd>

			<dt>~OTHER</dt>
			<dd>何もしない</dd>
		</dl>
	</li>
	<li>
~IF［
%~cp ~EQ `2212^U
］
⇒
%~cp ~SET `FF0D^U
◎
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
<p>
%~pointer ~LET `索引~jis0208$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index jis0208.
</p>

<p class="note">注記：
%~pointer は、 ~NULL でなければ，`索引~jis0208$と~pointer演算の資質に因り 8836 未満になる。
◎
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `A1^X
◎
Let lead be pointer / 94 + 0xA1.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `A1^X
◎
Let trail be pointer % 94 + 0xA1.
</li>
	<li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="iso-2022-jp">

<h3 title="ISO-2022-JP">12.2. ~ISO-2022-JP</h3>

<!--
 https://tools.ietf.org/html/rfc1468
 https://tools.ietf.org/html/rfc2237 (iso-2022-jp-1; not used)
 "ESC ) I" is from iso-2022-jp-3 reportedly
-->

			<section id="iso-2022-jp-decoder">
<h4 title="ISO-2022-JP decoder">12.2.1. ~ISO-2022-JP~decoder</h4>

<p>
`ISO-2022-JP$n の`~decoder$の各~instanceには、次のものが結付けられる
⇒
`~ISO-2022-JP~decoder状態@（初期~時 `ASCII$i）~BR
`~ISO-2022-JP~decoder出力~状態@（初期~時 `ASCII$i ）~BR
`~ISO-2022-JP~lead@（初期~時 `00^X ）~BR
`~ISO-2022-JP出力~flag@（初期~時 ~OFF ）
◎
ISO-2022-JP’s decoder has an associated ISO-2022-JP decoder state (initially ASCII), ISO-2022-JP decoder output state (initially ASCII), ISO-2022-JP lead (initially 0x00), and ISO-2022-JP output flag (initially unset).
</p>

<p>
`ISO-2022-JP$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，`~ISO-2022-JP~decoder状態$に応じて 次を走らす：
◎
ISO-2022-JP’s decoder’s handler, given a stream and byte, runs these steps, switching on ISO-2022-JP decoder state:
</p>

<dl class="switch">
	<dt>`ASCII@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

		<dl class="switch">
			<dt>`1B^X</dt>
			<dd>
`~ISO-2022-JP~decoder状態$ ~SET `~escape開始$i ~BR
~RET `継続$
◎
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

			<dt>`~ASCII~byte$ — ただし， `0E^X, `0F^X, `1B^X は除く</dt>
			<dd>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
~RET ~cp [ %~byte ]
◎
Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</dd>

			<dt>`~EoS$</dt>
			<dd>
~RET `完遂$
◎
Return finished.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
~RET `~error$
◎
Unset the ISO-2022-JP output flag and return error.
</dd>
		</dl>
	</dd>

	<dt>`Roman@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

		<dl class="switch">
			<dt>`1B^X</dt>
			<dd>
`~ISO-2022-JP~decoder状態$ ~SET `~escape開始$i ~BR
~RET `継続$
◎
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

			<dt>`5C^X</dt>
			<dd>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
~RET ~cp [ `00A5^U ]
◎
Unset the ISO-2022-JP output flag and return code point U+00A5.
</dd>

			<dt>`7E^X</dt>
			<dd>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
~RET ~cp [ `203E^U ]
◎
Unset the ISO-2022-JP output flag and return code point U+203E.
</dd>

			<dt>`~ASCII~byte$ — ただし， `0E^X, `0F^X, `1B^X, `5C^X, `7E^X は除く</dt>
			<dd>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
~RET a ~cp [ %~byte ]
◎
Unset the ISO-2022-JP output flag and return a code point whose value is byte.
</dd>

			<dt>`~EoS$</dt>
			<dd>
~RET `完遂$
◎
Return finished.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
~RET `~error$
◎
Unset the ISO-2022-JP output flag and return error.
</dd>
		</dl>
	</dd>

	<dt>`katakana@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

		<dl class="switch">
			<dt>`1B^X</dt>
			<dd>
`~ISO-2022-JP~decoder状態$ ~SET `~escape開始$i ~BR
~RET `継続$
◎
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

			<dt>`21^X 〜 `5F^X</dt>
			<dd>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
~RET ~cp [ `FF61^X ~MINUS `21^X ~PLUS %~byte ]
<!-- katakana; subtraction is done first to avoid upsetting compilers -->
◎
Unset the ISO-2022-JP output flag and return a code point whose value is 0xFF61 − 0x21 + byte.
</dd>

			<dt>`~EoS$</dt>
			<dd>
~RET `完遂$
◎
Return finished.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
~RET `~error$
◎
Unset the ISO-2022-JP output flag and return error.
</dd>
		</dl>
	</dd>

	<dt>`~lead~byte@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

		<dl class="switch">
			<dt>`1B^X</dt>
			<dd>
`~ISO-2022-JP~decoder状態$ ~SET `~escape開始$i ~BR
~RET `継続$
◎
Set ISO-2022-JP decoder state to escape start and return continue.
</dd>

			<dt>`21^X 〜 `7E^X</dt>
			<dd>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
`~ISO-2022-JP~lead$ ~SET %~byte ~BR
`~ISO-2022-JP~decoder状態$ ~SET `~trail~byte$i ~BR
~RET `継続$
◎
Unset the ISO-2022-JP output flag, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to trail byte, and return continue.
</dd>

			<dt>`~EoS$</dt>
			<dd>
~RET `完遂$
◎
Return finished.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
~RET `~error$
◎
Unset the ISO-2022-JP output flag and return error.
</dd>
		</dl>
	</dd>

	<dt>`~trail~byte@i</dt>
	<dd>
<p>
%~byte に応じて：
◎
Based on byte:
</p>

		<dl class="switch">
			<dt>`1B^X</dt>
			<dd>
<p>
`~ISO-2022-JP~decoder状態$ ~SET `~escape開始$i ~BR
~RET `~error$
<!-- iso-2022-jp decoder output state is still lead byte -->
◎
Set ISO-2022-JP decoder state to escape start and return error.
</p>

			</dd><dt>`21^X 〜 `7E^X</dt>
			<dd>
				<ol>
					<li>
`~ISO-2022-JP~decoder状態$ ~SET `~lead~byte$i
◎
Set the ISO-2022-JP decoder state to lead byte.
</li>
					<li>
%pointer ~LET ( `~ISO-2022-JP~lead$ ~MINUS `21^X ) ~MUL 94 ~PLUS %~byte ~MINUS `21^X
◎
Let pointer be (ISO-2022-JP lead − 0x21) × 94 + byte − 0x21.
</li>
					<li>
%~cp ~LET
`索引~jis0208$ の中で %~pointer が指す`索引~cp$
◎
Let code point be the index code point for pointer in index jis0208.
</li>
					<li>
~IF［
%~cp ~EQ ~NULL
］
⇒
~RET `~error$
◎
If code point is null, return error.
</li>
					<li>
~RET ~cp [ %~cp ]
◎
Return a code point whose value is code point.
</li>
				</ol>
			</dd>

			<dt>`~EoS$</dt>
			<dd>
`~ISO-2022-JP~decoder状態$ ~SET `~lead~byte$i ~BR
%~byte を %~stream に`前付加する$ ~BR
~RET `~error$
◎
Set the ISO-2022-JP decoder state to lead byte, prepend byte to stream, and return error.
</dd>

			<dt>~OTHER</dt>
			<dd>
`~ISO-2022-JP~decoder状態$ ~SET `~lead~byte$i ~BR
~RET `~error$
<!-- iso-2022-jp decoder output state is still lead byte -->
◎
Set ISO-2022-JP decoder state to lead byte and return error.
</dd>
		</dl>
	</dd>

	<dt>`~escape開始@i</dt>
	<dd>
		<ol>
			<li>
~IF［
%~byte ~IN { `24^X<!--＄-->, `28^X<!--(--> }
］
⇒
`~ISO-2022-JP~lead$ ~SET %~byte ~BR
`~ISO-2022-JP~decoder状態$ ~SET `~escape$i ~BR
~RET `継続$
◎
If byte is either 0x24 or 0x28, set ISO-2022-JP lead to byte, ISO-2022-JP decoder state to escape, and return continue.
</li>
			<li>
%~byte を %~stream に`前付加する$
◎
Prepend byte to stream.
</li>
			<li>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
`~ISO-2022-JP~decoder状態$ ~SET `~ISO-2022-JP~decoder出力~状態$ ~BR
~RET `~error$
◎
Unset the ISO-2022-JP output flag, set ISO-2022-JP decoder state to ISO-2022-JP decoder output state, and return error.
</li>
		</ol>
	</dd>

	<dt>`~escape@i</dt>
	<dd>
		<ol>
			<li>
%~lead ~LET `~ISO-2022-JP~lead$ ~BR
`~ISO-2022-JP~lead$ ~SET `00^X
◎
Let lead be ISO-2022-JP lead and set ISO-2022-JP lead to 0x00.
</li>
			<li>
%状態 ~LET ~NULL
◎
Let state be null.
</li>
			<li>
~IF［
%~lead ~EQ `28^X
］~AND［
%~byte ~EQ `42^X<!--B-->
］
⇒
%状態 ~SET `ASCII$i
◎
If lead is 0x28 and byte is 0x42, set state to ASCII.
</li>
			<li>
~IF［
%~lead ~EQ `28^X
］~AND［
%~byte ~EQ `4A^X<!--J-->
］
⇒
%状態 ~SET `Roman$i1
◎
If lead is 0x28 and byte is 0x4A, set state to Roman.
</li>
			<li>
~IF［
%~lead ~EQ `28^X
］~AND［
%~byte ~EQ `49^X<!--I-->
］
⇒
%状態 ~SET `katakana$i
◎
If lead is 0x28 and byte is 0x49, set state to katakana.
</li>
			<li>
~IF［
%~lead ~EQ `24^X
］~AND［
%~byte ~IN { `40^X<!--＠-->, `42^X<!--B--> }
］
⇒
%状態 ~SET `~lead~byte$i
◎
If lead is 0x24 and byte is either 0x40 or 0x42, set state to lead byte.
</li>
			<li>
<p>
~IF［
%状態 ~NEQ ~NULL
］：
◎
If state is non-null, then:
</p>

				<ol>
					<li>
`~ISO-2022-JP~decoder状態$ ~SET %状態 ~BR
`~ISO-2022-JP~decoder出力~状態$ ~SET %状態
◎
Set ISO-2022-JP decoder state and ISO-2022-JP decoder output state to state.
</li>
					<li>
%出力~flag ~LET `~ISO-2022-JP出力~flag$
◎
Let output flag be the ISO-2022-JP output flag.
</li>
					<li>
`~ISO-2022-JP出力~flag$ ~SET ~ON
◎
Set the ISO-2022-JP output flag.
</li>
					<li>
~RET ［
%出力~flag ~EQ ~OFF ならば `継続$ ／
~ELSE_ `~error$
］
◎
Return continue, if output flag is unset, and error otherwise.
</li>
				</ol>
			</li>
			<li>
~byte列 [ %~lead, %~byte ] を %~stream に`前付加する$
◎
Prepend lead and byte to stream.
</li>
			<li>
`~ISO-2022-JP出力~flag$ ~SET ~OFF ~BR
`~ISO-2022-JP~decoder状態$ ~SET `~ISO-2022-JP~decoder出力~状態$ ~BR
~RET `~error$
◎
Unset the ISO-2022-JP output flag, set ISO-2022-JP decoder state to ISO-2022-JP decoder output state and return error.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="iso-2022-jp-encoder">
<h4 title="ISO-2022-JP encoder">12.2.2. ~ISO-2022-JP~encoder</h4>

<p>
`ISO-2022-JP$n の`~encoder$の各~instanceには、次のものが結付けられる
⇒
`~ISO-2022-JP~encoder状態@
— これは，［
`ASCII@i1 ／
`Roman@i1 ／
`jis0208@i1
］のいずれかをとり得る（初期~時 `ASCII$i1 ）。
◎
ISO-2022-JP’s encoder has an associated ISO-2022-JP encoder state which is ASCII, Roman, or jis0208 (initially ASCII).
</p>

<p>
`ISO-2022-JP$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
ISO-2022-JP’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~cp ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
`~ISO-2022-JP~encoder状態$ ~NEQ `ASCII$i1
］
⇒
%~cp を %~stream に`前付加する$ ~BR
`~ISO-2022-JP~encoder状態$ ~SET `ASCII$i1 ~BR
~RET ~byte列 [ `1B^X, `28^X, `42^X ]
◎
If code point is end-of-stream and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
			<li>
~RET `完遂$
◎
If code point is end-of-stream and ISO-2022-JP encoder state is ASCII, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~ISO-2022-JP~encoder状態$ ~IN
{ `ASCII$i1, `Roman$i1 }
］~AND［
%~cp ~IN { `000E^U, `000F^U, `001B^U }
］
⇒
~RET `FFFD^U を伴う`~error$
◎
If ISO-2022-JP encoder state is ASCII or Roman, and code point is U+000E, U+000F, or U+001B, return error with U+FFFD.
</p>

<p class="note">
攻撃を防ぐため、これは %~cp ではなく， `FFFD^U を返す。
◎
This returns U+FFFD rather than code point to prevent attacks.
</p>
<!-- https://github.com/whatwg/encoding/issues/15 -->
	</li>
	<li>
~IF［
`~ISO-2022-JP~encoder状態$ ~EQ `ASCII$i1
］~AND［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If ISO-2022-JP encoder state is ASCII and code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
<p>
~IF［
`~ISO-2022-JP~encoder状態$ ~EQ `Roman$i1
］
⇒
%~cp に応じて：
◎
If ISO-2022-JP encoder state is Roman and code point is an ASCII code point, excluding U+005C and U+007E, or is U+00A5 or U+203E, then:
</p>

		<dl class="switch">
			<dt>`~ASCII~cp$ — ただし， `005C^U, `007E^U は除外する</dt>
			<dd>
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

			<dt>`00A5^U</dt>
			<dd>
~RET ~byte列 [ `5C^X ]
◎
If code point is U+00A5, return byte 0x5C.
</dd>

			<dt>`203E^U</dt>
			<dd>
~RET ~byte列 [ `7E^X ]
◎
If code point is U+203E, return byte 0x7E.
</dd>

			<dt>~OTHER</dt>
			<dd>何もしない</dd>
		</dl>
	</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］~AND［
`~ISO-2022-JP~encoder状態$ ~NEQ `ASCII$i1
］
⇒
%~cp を %~stream に`前付加する$ ~BR
`~ISO-2022-JP~encoder状態$ ~SET `ASCII$i1 ~BR
~RET ~byte列 [ `1B^X, `28^X, `42^X ]
◎
If code point is an ASCII code point, and ISO-2022-JP encoder state is not ASCII, prepend code point to stream, set ISO-2022-JP encoder state to ASCII, and return three bytes 0x1B 0x28 0x42.
</li>
	<li>
~IF［
%~cp ~NIN { `00A5^U, `203E^U }
］~AND［
`~ISO-2022-JP~encoder状態$ ~NEQ `Roman$i1
］
⇒
%~cp を %~stream に`前付加する$ ~BR
`~ISO-2022-JP~encoder状態$ ~SET `Roman$i1 ~BR
~RET ~byte列 [ `1B^X, `28^X, `4A^X ]
◎
If code point is either U+00A5 or U+203E, and ISO-2022-JP encoder state is not Roman, prepend code point to stream, set ISO-2022-JP encoder state to Roman, and return three bytes 0x1B 0x28 0x4A.
</li>
	<li>
~IF［
%~cp ~EQ `2212^U
］
⇒
%~cp ~SET `FF0D^U
◎
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
~IF［
%~cp ~IN { `FF61^U 〜 `FF9F^U }
］
⇒
%~cp ~SET `索引~ISO-2022-JP~katakana$の中で
( %~cp ~MINUS `FF61^X )
が指す`索引~cp$ 
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, set it to the index code point for code point − 0xFF61 in index ISO-2022-JP katakana.
</li>
	<li>
<p>
%~pointer ~LET `索引~jis0208$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index jis0208.
</p>

<p class="note">注記：
%~pointer は、 ~NULL でなければ，`索引~jis0208$と~pointer演算の資質に因り 8836 未満になる。
◎
If pointer is non-null, it is less than 8836 due to the nature of index jis0208 and the index pointer operation.
</p>
	</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
~IF［
`~ISO-2022-JP~encoder状態$ ~NEQ `jis0208$i1
］
⇒
%~cp を %~stream に`前付加する$ ~BR
`~ISO-2022-JP~encoder状態$ ~SET `jis0208$i1 ~BR
~RET ~byte列 [ `1B^X, `24^X, `42^X ]
◎
If ISO-2022-JP encoder state is not jis0208, prepend code point to stream, set ISO-2022-JP encoder state to jis0208, and return three bytes 0x1B 0x24 0x42.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 94 ) ~PLUS `21^X
◎
Let lead be pointer / 94 + 0x21.
</li>
	<li>
%~trail ~LET ( %~pointer ~MOD 94 ) ~PLUS `21^X
◎
Let trail be pointer % 94 + 0x21.
</li>
	<li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>
		<section id="shift_jis">

<h3 title="Shift_JIS">12.3. ~Shift_JIS</h3>


			<section id="shift_jis-decoder">
<h4 title="Shift_JIS decoder">12.3.1. ~Shift_JIS~decoder</h4>


<p>
`Shift_JIS$n の`~decoder$の各~instanceには、次のものが結付けられる
⇒
`~Shift_JIS~lead@（初期~時 `00^X ）
◎
Shift_JIS’s decoder has an associated Shift_JIS lead (initially 0x00).
</p>

<p>
`Shift_JIS$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
Shift_JIS’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
`~Shift_JIS~lead$ ~NEQ `00^X
］
⇒
`~Shift_JIS~lead$ ~SET `00^X ~BR
~RET `~error$
◎
If byte is end-of-stream and Shift_JIS lead is not 0x00, set Shift_JIS lead to 0x00 and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂$
◎
If byte is end-of-stream and Shift_JIS lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~Shift_JIS~lead$ ~NEQ `00^X
］：
◎
If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead, let pointer be null, set Shift_JIS lead to 0x00, and then:
</p>

		<ol>
			<li>
%~lead ~LET `~Shift_JIS~lead$ ~BR
%~pointer ~LET ~NULL ~BR
`~Shift_JIS~lead$ ~SET `00^X
◎
↑</li>
			<li>
%~offset ~LET ［
%~byte ~IN { `00^X 〜 `7E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40, if byte is less than 0x7F, and 0x41 otherwise.
</li>
			<li>
%~lead~offset ~LET ［
%~lead ~IN { `00^X 〜 `BF^X } ならば `81^X ／
~ELSE_ `C1^X
］
◎
Let lead offset be 0x81, if lead is less than 0xA0, and 0xC1 otherwise.
</li>
			<li>
~IF［
%~byte ~IN { `40^X 〜 `7E^X, `80^X 〜 `FC^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS %~lead~offset ) ~MUL 188 ~PLUS %~byte ~MINUS %~offset
◎
If byte is in the range 0x40 to 0x7E, inclusive, or 0x80 to 0xFC, inclusive, set pointer to (lead − lead offset) × 188 + byte − offset.
</li>
			<li>
<p>
~IF［
%~pointer ~IN { 8836 〜 10715 }
］
⇒
~RET ~cp [ `E000^X ~MINUS 8836 ~PLUS %~pointer ]
<!-- subtraction is done first to avoid upsetting compilers -->
◎
If pointer is in the range 8836 to 10715, inclusive, return a code point whose value is 0xE000 − 8836 + pointer.
</p>

<p class="note">注記：
これは EUDC として周知の，旧来の Windows によるものと相互運用可能にする。
<!-- PUA -->
◎
This is interoperable legacy from Windows known as EUDC.
</p>

<p class="trans-note">【
EUDC — いわゆる外字のための機能。
】【
8836 = 94 ~MUL 94 は~Shift_JIS（ JIS X 0208 ）の
`<a href="https://ja.wikipedia.org/wiki/%E5%8C%BA%E7%82%B9%E7%95%AA%E5%8F%B7">区点番号</a>^_
の総数。
結果の~cpは~Unicode私用領域に入る。
】</p>

			</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~jis0208$ の中で %~pointer が指す`索引~cp$
］
◎
Let code point be null, if pointer is null, and the index code point for pointer in index jis0208 otherwise.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
%~byte を %~stream に`前付加する$
◎
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN { `~ASCII~byte$, `80^X}
］
⇒
~RET ~cp [ %~byte ]
<!-- Opera has 0x7E -->
◎
If byte is an ASCII byte or 0x80, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `A1^X 〜 `DF^X }
］
⇒
~RET ~cp [ `FF61^X ~PLUS ( %~byte ~MINUS `A1^X ) ]
<!-- katakana; subtraction is done first to avoid upsetting compilers -->
◎
If byte is in the range 0xA1 to 0xDF, inclusive, return a code point whose value is 0xFF61 − 0xA1 + byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `9F^X, `E0^X 〜 `FC^X }
］
⇒
`~Shift_JIS~lead$ ~SET %~byte ~BR
~RET `継続$
◎
If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0 to 0xFC, inclusive, set Shift_JIS lead to byte and return continue.
</li>
	<li>
~RET `~error$
◎
Return error.
</li>
</ol>

			</section>
			<section id="shift_jis-encoder">
<h4 title="Shift_JIS encoder">12.3.2. ~Shift_JIS~encoder</h4>

<p>
`Shift_JIS$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
Shift_JIS’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
<p>
%~cp に応じて：
◎
↓</p>
		<dl class="switch">
			<dt>`~EoS$</dt>
			<dd>
~RET `完遂$
◎
If code point is end-of-stream, return finished.
</dd>

			<dt>`~ASCII~cp$</dt>
			<dt>`0080^U</dt>
			<dd>
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point or U+0080, return a byte whose value is code point.
</dd>

			<dt>`00A5^U</dt>
			<dd>
~RET ~byte列 [ `5C^X ]
◎
If code point is U+00A5, return byte 0x5C.
</dd>

			<dt>`203E^U</dt>
			<dd>
~RET ~byte列 [ `7E^X ]
◎
If code point is U+203E, return byte 0x7E.
</dd>

			<dt>`FF61^U 〜 `FF9F^U</dt>
			<dd>
~RET ~byte列 [ ( %~cp ~MINUS `FF61^X ) ~PLUS `A1^X ]
◎
If code point is in the range U+FF61 to U+FF9F, inclusive, return a byte whose value is code point − 0xFF61 + 0xA1.
</dd>

			<dt>~OTHER</dt>
			<dd>何もしない</dd>
		</dl>
	</li>
	<li>
~IF［
%~cp ~EQ `2212^U
］
⇒
%~cp ~SET `FF0D^U
◎
If code point is U+2212, set it to U+FF0D.
</li>
	<li>
%~pointer ~LET
%~cp を指す`索引~Shift_JIS~pointer$
◎
Let pointer be the index Shift_JIS pointer for code point.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 188 )
◎
Let lead be pointer / 188.
</li>
	<li>
%~lead~offset ~LET ［
%~lead ~IN { `00^X 〜 `1E^X } ならば `81^X ／
~ELSE_ `C1^X<!-- 0xA0-0x81 -->
］
◎
Let lead offset be 0x81, if lead is less than 0x1F, and 0xC1 otherwise.
</li>
	<li>
%~trail ~LET %~pointer ~MOD 188
◎
Let trail be pointer % 188.
</li>
	<li>
%~offset ~LET ［
%~trail ~IN { `00^X 〜 `3E^X } ならば `40^X ／
~ELSE_ `41^X
］
◎
Let offset be 0x40, if trail is less than 0x3F, and 0x41 otherwise.
</li>
	<li>
~RET ~byte列 [ ( %~lead ~PLUS %~lead~offset ), ( %~trail ~PLUS %~offset ) ]
◎
Return two bytes whose values are lead + lead offset and trail + offset.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="legacy-multi-byte-korean-encodings">

<h2 title="Legacy multi-byte Korean encodings">13. 旧来の複byte Korean ~encoding</h2>


		<section id="euc-kr">

<h3 title="EUC-KR">13.1. ~EUC-KR</h3>

			<section id="euc-kr-decoder">
<h4 title="EUC-KR decoder">13.1.1. ~EUC-KR~decoder</h4>

<p>
`EUC-KR$n の`~decoder$の各~instanceには、次のものが結付けられる
⇒
`~EUC-KR~lead@（初期~時 `00^X ）
◎
EUC-KR’s decoder has an associated EUC-KR lead (initially 0x00).
</p>

<p>
`EUC-KR$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
EUC-KR’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
`~EUC-KR~lead$ ~NEQ `00^X
］
⇒
`~EUC-KR~lead$ ~SET `00^X ~BR
~RET `~error$
◎
If byte is end-of-stream and EUC-KR lead is not 0x00, set EUC-KR lead to 0x00 and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂$
◎
If byte is end-of-stream and EUC-KR lead is 0x00, return finished.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~EUC-KR~lead$ ~NEQ `00^X
］：
◎
If EUC-KR lead is not 0x00, let lead be EUC-KR lead, let pointer be null, set EUC-KR lead to 0x00, and then:
</p>

		<ol>
			<li>
%~lead ~LET `~EUC-KR~lead$ ~BR
%~pointer ~LET ~NULL ~BR
`~EUC-KR~lead$ ~SET `00^X
◎
↑</li>
			<li>
~IF［
%~byte ~IN { `41^X 〜 `FE^X }
］
⇒
%~pointer ~SET ( %~lead ~MINUS `81^X ) ~MUL 190 ~PLUS ( %~byte ~MINUS `41^X )
◎
If byte is in the range 0x41 to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 + (byte − 0x41).
</li>
			<li>
%~cp ~LET ［
%~pointer ~EQ ~NULL ならば ~NULL ／
~ELSE_ `索引~EUC-KR$ の中で %~pointer が指す`索引~cp$
］
◎
Let code point be null, if pointer is null, and the index code point for pointer in index EUC-KR otherwise.
</li>
			<li>
~IF［
%~cp ~NEQ ~NULL
］
⇒
~RET ~cp [ %~cp ]
◎
If code point is non-null, return a code point whose value is code point.
</li>
			<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
%~byte を %~stream に`前付加する$
◎
If byte is an ASCII byte, prepend byte to stream.
</li>
			<li>
~RET `~error$
◎
Return error.
</li>
		</ol>
	</li>
	<li>
~IF［
%~byte ~IN `~ASCII~byte$
］
⇒
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</li>
	<li>
~IF［
%~byte ~IN { `81^X 〜 `FE^X }
］
⇒
`~EUC-KR~lead$ ~SET %~byte ~BR
~RET `継続$
◎
If byte is in the range 0x81 to 0xFE, inclusive, set EUC-KR lead to byte and return continue.
</li>
	<li>
~RET `~error$
◎
Return error.
</li>
</ol>

			</section>
			<section id="euc-kr-encoder">
<h4 title="EUC-KR encoder">13.1.2. ~EUC-KR~encoder</h4>

<p>
`EUC-KR$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
EUC-KR’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~EQ `~EoS$
］
⇒
~RET `完遂$
◎
If code point is end-of-stream, return finished.
</li>
	<li>
~IF［
%~cp ~IN `~ASCII~cp$
］
⇒
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</li>
	<li>
%~pointer ~LET
`索引~EUC-KR$ の中で
%~cp を指す`索引~pointer$
◎
Let pointer be the index pointer for code point in index EUC-KR.
</li>
	<li>
~IF［
%~pointer ~EQ ~NULL
］
⇒
~RET %~cp を伴う`~error$
◎
If pointer is null, return error with code point.
</li>
	<li>
%~lead ~LET ( %~pointer ~DIV 190 ) ~PLUS `81^X
◎
Let lead be pointer / 190 + 0x81.
</li>
			<li>
%~trail ~LET ( %~pointer ~MOD 190 ) ~PLUS `41^X
◎
Let trail be pointer % 190 + 0x41.
</li>
	<li>
~RET ~byte列 [ %~lead, %~trail ]
◎
Return two bytes whose values are lead and trail.
</li>
</ol>

			</section>
		</section>

<!-- removed from the spec 20130823
13.2 iso-2022-kr id="iso-2022-kr"
-->

	</section>
	<section id="legacy-miscellaneous-encodings">

<h2 title="Legacy miscellaneous encodings">14. その他の旧来の~encoding</h2>

		<section id="replacement">
<h3 title="replacement">14.1. ~replacement</h3>

<p class="note">注記：
`replacement$n `~encoding$は、~serverと~clientにおける `~encoding$の~supportの不一致を突く，ある種の攻撃を防ぐためのものである。
◎
The replacement encoding exists to prevent certain attacks that abuse a mismatch between encodings supported on the server and the client.
</p>

			<section id="replacement-decoder">
<h4 title="replacement decoder">14.1.1. ~replacement~decoder</h4>

<p>
`replacement$n の`~decoder$の各~instanceには、次のものが結付けられる
⇒
`~replacementによる~errorはすでに返した~flag@（初期~時 ~OFF ）
◎
replacement’s decoder has an associated replacement error returned flag (initially unset).
</p>

<p>
`replacement$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
replacement’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
~IF［
%~byte ~EQ `~EoS$
］
⇒
~RET `完遂$
◎
If byte is end-of-stream, return finished.
</li>
	<li>
~IF［
`~replacementによる~errorはすでに返した~flag$ ~EQ ~OFF
］
⇒
`~replacementによる~errorはすでに返した~flag$ ~SET ~ON ~BR
~RET `~error$
◎
If replacement error returned flag is unset, set the replacement error returned flag and return error.
</li>
	<li>
~RET `完遂$
◎
Return finished.
</li>
</ol>

<p class="trans-note">【
`replacement$n には、`~encoder$はない。
】</p>


			</section>
		</section>
		<section id="common-infrastructure-for-utf-16be-and-utf-16le">

<h3 title="Common infrastructure for UTF-16BE and UTF-16LE">14.2. ~UTF-16BEと~UTF-16LEに共通の基盤</h3>

			<section id="shared-utf-16-decoder">
<h4 title="shared UTF-16 decoder">14.2.1. 共用~UTF-16~decoder</h4>

<p class="note">注記：
~BOM（ byte order mark, “バイト順マーク” ）は`~label$より優先される。
それは，配備済みの内容において、どの`~label$よりも正確aであることが見出されているので。
したがって それは、`共用~UTF-16~decoder$の一部ではなく，`~decode$ ~algoの一部になる。
◎
A byte order mark has priority over a label as it has been found to be more accurate in deployed content. Therefore it is not part of the shared UTF-16 decoder algorithm but rather the decode algorithm.
</p>

<p>
`共用~UTF-16~decoder$の各~instanceには、次のものが結付けられる
⇒
`~UTF-16~lead~byte@（初期~時 ~NULL ）~BR
`~UTF-16~lead~surrogate@（初期~時 ~NULL ）~BR
`~UTF-16BE~decoder~flag@（初期~時 ~OFF ）
◎
shared UTF-16 decoder has an associated UTF-16 lead byte and UTF-16 lead surrogate (both initially null), and UTF-16BE decoder flag (initially unset).
</p>

<p>
`共用~UTF-16~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
shared UTF-16 decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~byte ~EQ `~EoS$
］：
◎
↓</p>

		<ol>
			<li>
~IF［
`~UTF-16~lead~byte$ ~NEQ ~NULL
］~OR［
`~UTF-16~lead~surrogate$ ~NEQ ~NULL
］
⇒
( `~UTF-16~lead~byte$, `~UTF-16~lead~surrogate$ ) ~SET ( ~NULL, ~NULL ) ~BR
~RET `~error$
◎
If byte is end-of-stream and either UTF-16 lead byte or UTF-16 lead surrogate is non-null, set UTF-16 lead byte and UTF-16 lead surrogate to null, and return error.
</li>
			<li>
~ELSE
⇒
~RET `完遂$
◎
If byte is end-of-stream and UTF-16 lead byte and UTF-16 lead surrogate are null, return finished.
</li>
		</ol>
	</li>
	<li>
~IF［
`~UTF-16~lead~byte$ ~EQ ~NULL
］
⇒
`~UTF-16~lead~byte$ ~SET %~byte ~BR
~RET `継続$
◎
If UTF-16 lead byte is null, set UTF-16 lead byte to byte and return continue.
</li>
	<li>
<p>
%~cu ~LET `~UTF-16BE~decoder~flag$に応じて，次で与えられる値：
◎
Let code unit be the result of:
</p>
		<dl class="switch">
			<dt>~ON◎UTF-16BE decoder flag is set</dt>
			<dd>
( `~UTF-16~lead~byte$ ~Lshift 8 ) ~PLUS %~byte
◎
(UTF-16 lead byte &lt;&lt; 8) + byte.
</dd>
			<dt>~OFF◎UTF-16BE decoder flag is unset</dt>
			<dd>
( %~byte ~Lshift 8 ) ~PLUS `~UTF-16~lead~byte$
◎
(byte &lt;&lt; 8) + UTF-16 lead byte.
</dd>
		</dl>
	</li>
	<li>
`~UTF-16~lead~byte$ ~SET ~NULL
◎
Then set UTF-16 lead byte to null.
</li>
	<li>
<p>
~IF［
`~UTF-16~lead~surrogate$ ~NEQ ~NULL
］：
◎
If UTF-16 lead surrogate is non-null, let lead surrogate be UTF-16 lead surrogate, set UTF-16 lead surrogate to null, and then:
</p>

		<ol>
			<li>
%~lead~surrogate ~LET `~UTF-16~lead~surrogate$ ~BR
`~UTF-16~lead~surrogate$ ~SET ~NULL
◎
↑</li>
			<li>
~IF［
%~cu ~IN { `DC00^U 〜 `DFFF^U }
］
⇒
~RET ~cp [
`10000^X ~PLUS ( ( %~lead~surrogate ~MINUS `D800^X ) ~Lshift 10 ) ~PLUS ( %~cu ~MINUS `DC00^X )
]
◎
If code unit is in the range U+DC00 to U+DFFF, inclusive, return a code point whose value is 0x10000 + ((lead surrogate − 0xD800) &lt;&lt; 10) + (code unit − 0xDC00).
</li>
			<li>
%byte1 ~LET %~cu ~Rshift 8
◎
Let byte1 be code unit &gt;&gt; 8.
</li>
			<li>
%byte2 ~LET %~cu ~bAND `00FF^X
◎
Let byte2 be code unit &amp; 0x00FF.
</li>
			<li>
%~byte列 ~LET %~utf-16be~flag に応じて［
~ON ならば ~byte列 [ %byte1, %byte2 ] ／
~OFF ならば ~byte列 [ %byte2, %byte1 ]
］
◎
Let bytes be two bytes whose values are byte1 and byte2, if the UTF-16BE decoder flag is set, and byte2 and byte1 otherwise.
</li>
			<li>
%~byte列 を %~stream に`前付加する$
◎
Prepend the bytes to stream and return error.
</li>
			<li>
~RET `~error$
◎
↑</li>
		</ol>
	</li>
	<li>
~IF［
%~cu ~IN { `D800^U 〜 `DBFF^U }
］
⇒
`~UTF-16~lead~surrogate$ ~SET %~cu ~BR
~RET `継続$
◎
If code unit is in the range U+D800 to U+DBFF, inclusive, set UTF-16 lead surrogate to code unit and return continue.
</li>
	<li>
~IF［
%~cu ~IN { `DC00^U 〜 `DFFF^U }
］
⇒
~RET `~error$
<!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->
◎
If code unit is in the range U+DC00 to U+DFFF, inclusive, return error.
</li>
	<li>
~RET ~cp [ %~cu ]
◎
Return code point code unit.
</li>
</ol>


			</section>
		</section>
		<section id="utf-16be">

<h3 title="UTF-16BE">14.3. ~UTF-16BE</h3>


			<section id="utf-16be-decoder">
<h4 title="UTF-16BE decoder">14.3.1. ~UTF-16BE~decoder</h4>


<p>
`UTF-16BE$n の`~decoder$は、［
`~UTF-16BE~decoder~flag$ ~SET ~ON
］にされた`共用~UTF-16~decoder$である。
◎
UTF-16BE’s decoder is shared UTF-16 decoder with its UTF-16BE decoder flag set.
</p>


			</section>
		</section>

		<section id="utf-16le">

<h3 title="UTF-16LE">14.4. ~UTF-16LE</h3>

<p class="note">注記：
配備済みの内容に対処するため、 `utf-16^lb, `utf-16le^lb のいずれも `UTF-16LE$n 用の`~label$にされている。
◎
Both "utf-16" and "utf-16le" are labels for UTF-16LE to deal with deployed content.
</p>

			<section id="utf-16le-decoder">
<h4 title="UTF-16LE decoder">14.4.1. ~UTF-16LE~decoder</h4>


<p>
`UTF-16BE$n の`~decoder$は、`共用~UTF-16~decoder$である。
◎
UTF-16LE’s decoder is shared UTF-16 decoder.
</p>

			</section>
		</section>

		<section id="x-user-defined">

<h3 title="x-user-defined">14.5. ~x-user-defined</h3>

<p class="note">注記：
これは技術的には`単byte~encoding$であるが、~algo的に実装し得るので，別々に定義される。
◎
While technically this is a single-byte encoding, it is defined separately as it can be implemented algorithmically.
</p>

			<section id="x-user-defined-decoder">
<h4 title="x-user-defined decoder">14.5.1. ~x-user-defined~decoder</h4>

<p>
`x-user-defined$n の`~decoder$の`~handler$は、所与の
( %~stream, %~byte )
に対し，次を走らす：
◎
x-user-defined’s decoder’s handler, given a stream and byte, runs these steps:
</p>

<ol>
	<li>
<p>
%~byte に応じて：
◎
↓</p>
		<dl class="switch">
			<dt>`~EoS$</dt>
			<dd>
~RET `完遂$
◎
If byte is end-of-stream, return finished.
</dd>

			<dt>`~ASCII~byte$</dt>
			<dd>
~RET ~cp [ %~byte ]
◎
If byte is an ASCII byte, return a code point whose value is byte.
</dd>

			<dt>~OTHER</dt>
			<dd>
~RET ~cp [ `F780^X ~PLUS %~byte ~MINUS `80^X ]
◎
Return a code point whose value is 0xF780 + byte − 0x80.
</dd>
		</dl>
	</li>
</ol>

			</section>
			<section id="x-user-defined-encoder">
<h4 title="x-user-defined encoder">14.5.2. ~x-user-defined~encoder</h4>

<p>
`x-user-defined$n の`~encoder$の`~handler$は、所与の
( %~stream, %~cp )
に対し，次を走らす：
◎
x-user-defined’s encoder’s handler, given a stream and code point, runs these steps:
</p>

<ol>
	<li>
<p>
%~cp に応じて：
◎
↓</p>
		<dl class="switch">
			<dt>`~EoS$</dt>
			<dd>
~RET `完遂$
◎
If code point is end-of-stream, return finished.
</dd>

			<dt>`~ASCII~cp$</dt>
			<dd>
~RET ~byte列 [ %~cp ]
◎
If code point is an ASCII code point, return a byte whose value is code point.
</dd>

			<dt>`F780^U 〜 `F7FF^U</dt>
			<dd>
~RET ~byte列 [ %~cp ~MINUS `F780^X ~PLUS `80^X ]
◎
If code point is in the range U+F780 to U+F7FF, inclusive, return a byte whose value is code point − 0xF780 + 0x80.
</dd>

			<dt>~OTHER</dt>
			<dd>
~RET %~cp を伴う`~error$
◎
Return error with code point.
</dd>
		</dl>
	</li>
</ol>

			</section>
		</section>
	</section>
	<section id="browser-ui">

<h2 title="Browser UI">15. ~browser UI</h2>

<p>
~browserには、資源の~encodingに対する上書きを可能化させないことが奨励される。
にもかかわらず，その種の特色機能が在する場合、前述の
<a href="#security-background">保安~上の課題</a>
から，~browserは， `UTF-16BE$n／`UTF-16LE$n を~optionとして提供0する~SHOULDでない。
~browserは、資源が `UTF-16BE$n／`UTF-16LE$n を利用して~decodeされた場合でも，この特色機能を不能化する~SHOULDである。
◎
Browsers are encouraged to not enable overriding the encoding of a resource. If such a feature is nonetheless present, browsers should not offer either UTF-16BE or UTF-16LE as option due to aforementioned security issues. Browsers also should disable this feature if the resource was decoded using either UTF-16BE or UTF-16LE.
</p>

	</section>
	<section id="implementation-considerations">
<h2 title="Implementation considerations">実装~上の考慮点</h2>

<p>
この標準における`~encoding$用の`~decoder$は、任意の`前付加-$を備える`~stream$を~supportする代わりに，次により実装することもできる：
◎
Instead of supporting streams with arbitrary prepend, the decoders for encodings in this standard could be implemented with:
</p>

<ol>
	<li>
読取った現在の~byteを元に戻す能。
◎
The ability to unread the current byte.
</li>
	<li>
`ISO-2022-JP$n 用の単byte（ `24^X ／ `28^X ）~buffer。
◎
↓</li>
	<li>
<p>
`gb18030$n 用の単byte（ `~ASCII~byte$ ）~buffer。
◎
A single-byte buffer for gb18030 (an ASCII byte) and ISO-2022-JP (0x24 or 0x28).
</p>

<p class="example" id="example-gb18030-implementation-strategy">
`gb18030$n に対しては、［
`~gb3$ ~NEQ `00^X
］の間に~~不正な~byteに出くわしたときは、`~gb2$は，次に返されることになる単byte~bufferの中に移動でき、`~gb3$が
— 単byte~bufferが返されて空にされた後， `00^X でないことが検査されたなら —
新たな`~gb1$になる。
これは、 `gb18030$n における 1 個目と 3 個目の~byte範囲が一致するので可能になる。
◎
For gb18030 when hitting a bogus byte while gb18030 third is not 0x00, gb18030 second could be moved into the single-byte buffer to be returned next, and gb18030 third would be the new gb18030 first, checked for not being 0x00 after the single-byte buffer was returned and emptied. This is possible as the range for the first and third byte in gb18030 is identical.
</p>
	</li>
</ol>

<p>
`~ISO-2022-JP~encoder$には，追加の状態として`~ISO-2022-JP~encoder状態$が必要になるが、それ以外では，この標準における`~encoding$用のどの`~encoder$にも 追加の状態や~bufferは要求されない。
◎
The ISO-2022-JP encoder needs ISO-2022-JP encoder state as additional state, but other than that, none of the encoders for encodings in this standard require additional state or buffers.
</p>

	</section>
	<section id="acknowledgments">

<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り、~encodingを相互運用可能なものにするために，たくさんの方々が助力され、この標準の目標へ近付けてきた。
同様に多くの方々の助力が，この標準を~~現在の姿に仕立て上げてきた。
特に，次の方々に感謝する：
◎
There have been a lot of people that have helped make encodings more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</p>

<div lang="en-x-a0">

<p>
With that, many thanks to

Adam Rice,
Alan Chaney,
Alexander Shtuchkin,
Allen Wirfs-Brock,
Aneesh Agrawal,
Arkadiusz Michalski,
Asmus Freytag,
Ben Noordhuis,
Boris Zbarsky,
Bruno Haible,
Cameron McCormack,
Charles McCathieNeville,
David Carlisle,
Domenic Denicola,
Dominique Hazaël-Massieux,
Doug Ewell,
Erik van der Poel,
<span lang="zh">譚永鋒</span> (Frank Yung-Fong Tang),
Geoffrey Sneddon,
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
James Graham,
Jeffrey Yasskin,
John Tamplin,
Joshua Bell,
<span lang="ja">村井純</span> (Jun Murai),
<span lang="ko">신정식</span> (Jungshik Shin),
Jxck,
<span lang="ko">강 성훈</span> (Kang Seonghoon),
<span lang="ja">川幡太一</span> (Kawabata Taichi),
Ken Lunde,
Ken Whistler,
Kenneth Russell,
<span lang="ja">田村健人</span> (Kent Tamura),
Leif Halvard Silli,
Makoto Kato,
Mark Callow,
Mark Crispin,
Mark Davis,
Martin Dürst,
Masatoshi Kimura,
Ms2ger,
Nigel Megitt,
Nigel Tao,
Norbert Lindenberg,
Øistein E. Andersen,
Peter Krefting,
Philip Jägenstedt,
Philip Taylor,
Richard Ishida,
Robbert Broersma,
Robert Mustacchi,
Ryan Dahl,
Shawn Steele,
Simon Montagu,
Simon Pieters,
Simon Sapin,
<span lang="ja">寺田健</span> (Takeshi Terada),
Vyacheslav Matva, and
<span lang="ja">成瀬ゆい</span> (Yui Naruse)

for being awesome.
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>
).
The <a href="#api">API</a> chapter was initially written by Joshua Bell
(<a href="https://www.google.com/">Google</a>).
</p>

<p>
Per <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>, to the extent possible under law, the editors have waived all copyright and related or neighboring rights to this work.
</p>
</div>

	</section>

</main><!-- id="MAIN" -->

	<section id="section-index">
<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>
	</section>
	<section id="references">

<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>

<script type="text/plain" class="ref_data">

[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[UNICODE]
    The Unicode Standard. URL: http://www.unicode.org/versions/latest/ 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/ 
</script>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<script type="text/plain" class="ref_data">

[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml 
</script>


		</section>
	</section>
</body>


<!--%他の語

	●訳注
参照
参照先
代入
代用対
含意-
固有の
保持-
内部状態
初期化
制約されることが
区点番号
実行制御
所属
数値的
数字列
日付
時系列的
有効
構造
機能
正規化され
特有
外字
符号点
~~符号位置
見なせる
角括弧
記号
記法
記述
記述され
訳
訳者
訳語
試す
課-:impose
識別子
集合
静的
変数
追加
意味
意味-
表記規約
	●
等しい
一方で
伴-
備える
化
化-
場合
場所
対し／対する
列:sequence
項目数
右／左
万
並び
年
数
数値:number
応じて
成立-
括弧内
方
桁:digit:~
法
演算
有-
有無
済む
点で
無い
無けれ
片
的
用い
異な
相互に
省略-:without
空行:empty string
組
統合:Unified
コード
総数
行:row／line
表
語
〜進数
〜進表記

-->
