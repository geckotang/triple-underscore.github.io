<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Typed Array Specification （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
COMMON_DATA.init = function(expanded){
	return {
		original_url: 'https://www.khronos.org/registry/typedarray/specs/latest/',
		main: 'MAIN',
		toc: 'toc',
		alt_refs: 'references',
		ref_id_prefix: 'refs',
		word_switch: 'replace_table'
	};
}


</script>



<!-- default.css removed selectors

@media print, @page
// elements
dlink, navbar, h1, h2, h3, h4, h5, h6, caption, img, s, del, u, ins, blockquote, sup, p, body, dl, ol, ul, li, dd

pre.note

// pseud
:link, :visited, a:active

// classes
.figure, .sidefigure, .propdef, .descdef, .testlink, .indexlist, .example, .illegal-example, .illegal-html, .illegal-xml, .deprecated-html, .html, .xml, .illegal-xml, .toc, .logo, .css, .descriptor, .caption, .equiv-table, .proptable, .data, .stepslist, .methods, .gl-spec, .diff-new, .diff-old, .diff-chg, .nestedlist, .nonnormative, .head, .copyright, .features, .rfc2119, .eqno, .issue, .type, .normref, .informref, .mtb, .id, .hide, .left, .right, .index

// styles
-webkit-text-size-adjust:
page-break-after:
counter-reset:

pre
.api tbody tr > td
dt, dd
pre, code { font-size: 1.2em; font-family: monospace; }
pre.idl :link, pre.idl :visited
 -->
<!--%style -->
<style type="text/css" >


div.note::before {
    content: "参考"; /* "Non-normative" */
    font: bold small sans-serif;
    /*float: left;*/
    position: absolute;
    top: -0.9em;
    text-align: center;
    line-height: 1em;
    border: thin solid #999;

	left: -2.5em;
    width: 5em; /*7.5em;*/
    color: #F8FFDD;
    background: #060;
    padding: 0.1em;
    /*margin: -1.3em 0 0.3em -2.5em;*/
}

div.note pre {
	padding: 0.5em;
	background: #E8FFDD;
}

div.note {
    background: #F8FFDD;
    padding: 0.5em;
    margin: 1em 0;
    border: thin solid #999;
    position: relative;
	color: #030; /* #060; */
}


pre.idl {
	border: solid thin;
	background: #EEEEEE;
	color: black;
	padding: 0.5em 1em;
/*min-width: 61em;*/
}

dl.api > dt {
	background-color:#CCCCEE;
}

dl.idl-def > dt {
	font-family: monospace0, monospace;
}

dd + dt {
	margin-top: 0.6em;
}

dd > p {
	margin-top: 0.6em;
	margin-bottom: 0.6em;
}

thead {
	border-bottom: 3px solid;
}

th {
	background-color: #CCCCEE;
	color: #111155;
}

.view-example-table {
	margin-left: 2em;
}
.view-example-table td {
	text-align: center;
	padding: 4px 8px;
}
.view-example-table tr > td:first-child {
	text-align: right;
	border: none;
}

var {
	font-family: monospace0, monospace;
}

code,
pre.idl > a,
dl.idl-def > dt > dfn {
	color:#CC3311;
}

samp {
	color:#832;
}

.union {
	color: purple;
	font-style: italic;
}

</style>

</head>

<!-- 
<body onload="generateTOC(document.getElementById('toc'))">
 -->
<body>

<div id="sideways-logo"><div>Khronos Working Draft</div></div>

<aside class="trans-meta">
<h1>Typed Array Specification 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
2013 年 7 月 18 日付 <strong >草案</strong>として公開された
<a href="https://www.khronos.org/registry/typedarray/specs/latest/">Typed Array </a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2014-10-22</time>
（公開：<time>2012-10-28</time>）
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<h1 title="Typed Array Specification">型付き配列 — Typed Array 仕様</h1>
<h2>2013 年 7 月 18 日付 草案</h2>

<dl>
	<dt title="This version:">このバージョン</dt>
    <dt title="Latest version:">最新バージョン</dt>
	<dd>
<a href="https://www.khronos.org/registry/typedarray/specs/latest/">https://www.khronos.org/registry/typedarray/specs/latest/</a>
	</dd>
	<dd>
<b>Web IDL:</b>
<a href="https://www.khronos.org/registry/typedarray/specs/latest/typedarray.idl">https://www.khronos.org/registry/typedarray/specs/latest/typedarray.idl</a>
	</dd>

	<dt title="Previous version:">前のバージョン</dt>
	<dd>
<a href="https://www.khronos.org/registry/typedarray/specs/1.0/">https://www.khronos.org/registry/typedarray/specs/1.0/</a>
	</dd>
	<dd>
<b>Web IDL:</b>
<a href="https://www.khronos.org/registry/typedarray/specs/1.0/typedarray.idl">https://www.khronos.org/registry/typedarray/specs/1.0/typedarray.idl</a>
	</dd>

	<dt title="Editors:">編集</dt>
	<dd>
<a href="mailto:dherman@mozilla.com">David Herman</a>
<a href="http://www.mozilla.com/">(Mozilla Corporation)</a>
	</dd>
	<dd>
<a href="mailto:kbr@google.com">Kenneth Russell</a>
<a href="http://www.google.com/intl/en/about.html">(Google, Inc.)</a>
	</dd>
</dl>
</header>

  <hr>

	<section id="abstract">
<h2 title="Abstract">要約</h2>
<p>
この仕様は、ネイティブ バイナリデータのやりとりを可能にする API を提供する。
これは、汎用の固定長バッファ型, および バッファ内に格納されたデータへのアクセスを許容する種々のアクセサ型を定義する。
<span lang="en">
This specification provides an API for interoperability with native binary data. It defines a generic fixed-length buffer type, as well as accessor types that allow access to the data stored within the buffer.
</span></p>

<p>
ここに述べられる機能は、元々は WebGL 仕様に端を発するものである。
<a href="#refsWEBGL">[WEBGL]</a>
<span lang="en">
The functionality described here originated in the WebGL specification [WEBGL].
</span></p>

	</section>
	<section id="status-of-this-document">
<h2 title="Status of this document">この文書の位置付け</h2>

    <!--begin-status-->
<p>
この文書は草案です。
この文書を進行中の作業以上のものとして引用しないように。
WebGL メーリングリスト
<a href="mailto:public_webgl@khronos.org">public_webgl@khronos.org</a>
（
<a href="https://www.khronos.org/webgl/public-mailing-list/archives/">アーカイブ</a>
）にて、この仕様に関する公開の論が交わされています（
<a href="http://www.khronos.org/webgl/public-mailing-list/">利用の手引き</a>
）。
<span lang="en">
This document is an editor's draft. Do not cite this document as other than work in progress. Public discussion of this specification is welcome on the (archived) WebGL mailing list public_webgl@khronos.org (see instructions).
</span></p>

    <p>
この文書の，改訂履歴も含む最新バージョンは下記から入手できる：
<span lang="en">
The latest version of this document, including all revision history, may be obtained via Subversion:
</span></p>

<pre>svn co https://cvs.khronos.org/svn/repos/registry/trunk/public/typedarray</pre>
    <!--end-status-->
	</section>


<nav class="toc" id="toc">
<h2 title="Table of contents">目次</h2>
<!--  --></nav>

<main id="MAIN">

	<section id="introduction">
<h2 title="Introduction" id="1">1. 序</h2>

<div class="note">
<p>
ECMAScript 
<a href="#refsECMA262">[ECMA-262]</a>
は、伝統的に，バイナリデータへのアクセスがない文脈の下で利用されてきた。
バイナリデータの操作を要する所では、しばしば， String として格納されたデータに charCodeAt() を利用してアクセスしたり, あるいは Array として格納されたデータとの間で base64 変換を介した受け渡しが行われている。
これらの手法は、いずれも低速であり，プログラムの誤りも導かれ易い。
例えば，バイナリデータを 32-bit 整数として読み取る際には、 4 個のソースバイトと目的の型との間の 手作業による変換コードを要する。
浮動小数点データの読み取りは更に高くつく。
<span lang="en">
ECMAScript [ECMA-262] has traditionally been used in contexts where there is no access to binary data. Where binary data has needed to be manipulated, it is often stored as a String and accessed using charCodeAt(), or stored as an Array with conversion to and from base64 for transmission. Both of these methods are slow and error-prone. For example, reading binary data as 32-bit integers requires manual conversion of 4 source bytes to and from the target type. Reading floating-point data is even more expensive.
</span></p>

<p>
ウェブアプリケーションが新たな機能性を獲得するに連れ、バイナリデータの取り扱いは，益々求められている機能になっている。
File API
<a href="#refsFILE">[FILEAPI]</a>
や WebSockets
<a href="#refsWEBSOCKETS">[WEBSOCKETS]</a>
などの現今の仕様は、ネイティブ形式によるバイナリデータの直接的な読み取りと書き込みが可能になれば、より便益を得られるようになる。
WebGL
<a href="#refsWEBGL">[WEBGL]</a>
などの仕様にとっては、この機能性が容認し得る性能に必須の要件になる。
<span lang="en">
As web applications gain access to new functionality, working with binary data has become a much-demanded feature. Current specifications such as the File API [FILEAPI] and Web Sockets [WEBSOCKETS] would benefit from being able to read and write binary data directly in its native form. Specifications such as WebGL [WEBGL] require this functionality to meet acceptable performance characteristics.
</span></p>

<p>
この仕様は、 ECMAScript からバイナリデータへアクセスするための，最小限の機能を定める。
<span lang="en">
This specification defines a minimal set of functionality for accessing binary data from ECMAScript.
</span></p>
    </div>

<p class="trans-note">【
この仕様に定義される各種インタフェースには、
ECMAScript 6 （ ECMAScript の次期バージョン）においては，対応する
<a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-typedarray-objects" >組み込みの型</a>が用意されている。
それに伴い， Web IDL でも
<a href="http://heycam.github.io/webidl/#idl-buffer-source-types">組み込みの型として扱われる</a>ことになる。
】</p>

	</section>
	<section id="overview">
<h2 title="Overview" id="2">2. 概観</h2>

<div class="note">
<p>
この仕様は、汎用の固定長バイナリ<!---->バッファを表現する <code >ArrayBuffer</code> 型を定義する。
<code >ArrayBuffer</code> の内容は、直接的には操作できない。
代わりに、 <code >ArrayBuffer</code> の各種 <em>ビュー</em> を作成する，一連の型が利用される。
例えば、バッファに対し， 32-bit 符号付き<!--1-->整数の配列としてアクセスするときは、 <code >ArrayBuffer</code> を参照する <code >Int32Array</code> を作成することになる。
<span lang="en">
This specification defines an ArrayBuffer type, representing a generic fixed-length binary buffer. It is not possible to manipulate the contents of an ArrayBuffer directly. Instead, a group of types are used to create views of the ArrayBuffer. For example, to access the buffer as an array of 32-bit signed integers, an Int32Array would be created that refers to the ArrayBuffer.
</span></p>

<p>
複数の型付き<!--1-->配列ビューを通して、同じ <code >ArrayBuffer</code> に対し，種々の型, 任意の 長さ／オフセットによる参照が可能になる。
また、複雑なデータ構造を持つ <code >ArrayBuffer</code> も構築可能になる。
例えば，次のコードでは：
<span lang="en">
Multiple typed array views can refer to the same ArrayBuffer, of different types, lengths, and offsets. This allows for complex data structures to be built up in the ArrayBuffer. As an example, given the following code:
</span></p>
<pre>
<span
title="create an 8-byte ArrayBuffer"
>      // 8 バイトの ArrayBuffer を作成</span>
      var <var >b</var> = new ArrayBuffer(8);

<span
title="create a view v1 referring to b, of type Int32, starting at // the default byte index (0) and extending until the end of the buffer"
>      // <var >b</var> の始端（既定の, バイトindex 0 ）の所から
      // バッファ終端までを参照する Int32 型のビュー, <var >v1</var> を作成</span>
      var <var >v1</var> = new Int32Array(b);

<span
title="create a view v2 referring to b, of type Uint8, starting at // byte index 2 and extending until the end of the buffer"
>      // <var >b</var> のバイトindex 2 の所から
      // バッファ終端までを参照する Uint8 型のビュー, <var >v2</var> を作成</span>
      var <var >v2</var> = new Uint8Array(<var >b</var>, 2);

<span
title="// create a view v3 referring to b, of type Int16, starting at // byte index 2 and having a length of 2"
>      // <var >b</var> のバイトindex 2 の所から
      // 長さ 2 の範囲を参照する Int16 型のビュー, <var >v3</var> を作成</span>
      var <var >v3</var> = new Int16Array(<var >b</var>, 2, 2);</pre>

<p>
次のようなバッファ, およびビューの割り付けが作成される：
<span lang="en">
The following buffer and view layout is created:
</span></p>


<table class="view-example-table" border>
<thead><tr><th>変数</th><th colspan="8">index</th></tr></thead>
	<tbody>
<tr style="font-size: smaller;"><td></td><td
	colspan="8"
	title="bytes (not indexable)"
	><em>バイト列（ index アクセス不可）</em></td></tr>
<tr><td><var >b</var> = </td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
<tr style="font-size: smaller;"><td></td><td
	colspan="8"
	title="indices"
	><em>アクセス index</em></td></tr>
<tr><td><var >v1</var> = </td><td
	colspan="4">0</td><td
	colspan="4">1</td></tr>
<tr><td><var >v2</var> = </td><td
	colspan="2" style="background: #aaa"></td><td
	>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr>
<tr><td><var >v3</var> = </td><td
	colspan="2" style="background: #aaa"></td><td
	colspan="2">0</td><td
	colspan="2">1</td><td
	colspan="2" style="background: #aaa"></td></tr>
	</tbody>
</table>


<p>
これは、 8 バイトのバッファ <var>b</var> と,
３個のバッファ<!---->ビュー
<var>v1</var>, <var>v2</var>, <var>v3</var>
を定義する。
これらのビューは、同じバッファを参照する。
すなわち：
<span class="block">
<samp>v1[0]</samp> は，バイト 0 〜 3 を符号付き<!--1--> 32-bit 整数として参照し,<br>
<samp>v2[0]</samp> は，バイト 2 を符号なし<!--1--> 8-bit 整数として参照し,<br>
<samp>v3[0]</samp> は，バイト 2 〜 3 を符号付き<!--1--> 16-bit 整数として参照する。
</span>
１つのビューに加えられた変更は、即時に他から見えるようになる：
例えば，
<span class="block">
<samp>v2[0] = 0xff; v2[1] = 0xff;</samp> が実行されたなら、<br>
<samp>v3[0] == -1</samp> となる（そこでは， −1 は <samp>0xffff</samp> で表現される）。
</span>
<span lang="en">
This defines an 8-byte buffer b, and three views of that buffer, v1, v2, and v3. Each of the views refers to the same buffer -- so v1[0] refers to bytes 0..3 as a signed 32-bit integer, v2[0] refers to byte 2 as a unsigned 8-bit integer, and v3[0] refers to bytes 2..3 as a signed 16-bit integer. Any modification to one view is immediately visible in the other: for example, after v2[0] = 0xff; v2[1] = 0xff; then v3[0] == -1 (where -1 is represented as 0xffff).
</span></p>

</div>

		<section id="endianness"><!-- ENDIANNESS -->
<h3 title="Endianness">2.1. endianness</h3>

<div class="note">
<p>
コンピュータのメモリは，基本的に 数値の連続的な並びで編成されている。
現今のすべてのコンピュータでは、これらのそれぞれの値が 8-bit バイナリ数（ “バイト” ）である。
より大きな数は、複数個のバイト（ “複バイト” ）をまとめて１個の値に解釈することで表現される。
例えば この仕様は、
16-bit, 32-bit の符号付き／符号なしの整数, および
32-bit, 64-bit 浮動小数点数について論じる。
<span lang="en">
Computer memory is fundamentally organized as a linear series of numbers. On all contemporary computers, each of these values is an 8-bit binary number (a "byte"). Larger numbers are represented by interpreting multiple bytes at a time as a single value. For example, this specification discusses 16-bit and 32-bit signed and unsigned integers, and 32-bit and 64-bit floating-point numbers.
</span></p>

<p>
そのような複バイト値の解釈には，バイトの並び順の解釈に多義性を孕む。
<em>little-endian</em> アーキテクチャの下では，最低アドレスのバイトが最下位バイトとして扱われ、
<em>big-endian</em> アーキテクチャの下では，最低アドレスのバイトが最上位バイトとして扱われる。
他の可能性もあるが、普通は利用されない。
現代の大多数の消費者コンピュータ機器では， little-endian アーキテクチャが利用されているが、 big-endian アーキテクチャも依然として重要なユースケースの下で利用されている。
<span lang="en">
There exists an ambiguity in the interpretation of such multi-byte values: specifically, which order the bytes are assembled. Little-endian architectures treat the byte with the lowest address as the least significant byte; big-endian architectures treat the byte with the lowest address as the most significant byte. More possibilities exist, but are not commonly used. Little-endian architectures are currently used in most consumer computing devices, but big-endian architectures are still used in important use cases.
</span></p>

<p>
次の図式に，little-endian と big-endian の下での値の格納の相違を示す。
値 <samp>305419896</samp> （ 16進 <samp>0x12345678</samp> ）が
<code>Uint32Array</code> を用いて <code >ArrayBuffer</code> の中に格納されているとするとき、ホストコンピュータの endianness に依存して、
<code >ArrayBuffer</code> の各バイト成分は（アドレスの低い方から順に）次の様に並ぶことになる：
<span lang="en">
The following diagram illustrates the difference in storage of values between little-endian and big-endian architectures. If the value 305419896 (0x12345678 in hexadecimal) were stored into an ArrayBuffer using a Uint32Array, then depending on the host computer's endianness, the component bytes of the ArrayBuffer would contain the following (organized from low address to high address):
</span></p>

<table class="view-example-table" border><tbody>
<tr><th>little-endian:</th><td>78</td><td>56</td><td>34</td><td>12</td></tr>
<tr><th>big-endian:</th><td>12</td><td>34</td><td>56</td><td>78</td></tr>
</tbody></table>

<p>
この仕様では、 endianness による相違は，一定の状況に限り露になる：
例えば， <code >ArrayBuffer</code> の同じ区域に複数種のビューの型が重なるときなど。
次の規範規則が，型付き<!--1-->配列ビューの実装に適用される：
<span lang="en">
In this specification, differences in endianness only become apparent in certain situations: for example, when overlaying multiple types of views on the same region of an ArrayBuffer. The following normative rules apply to implementations of the typed array views.
</span></p>

</div>

<p>
<a href="#typed-array-view-types">型付き<!--1-->配列ビュー型</a>
は、ホストコンピュータの endianness の下で，演算を行う。
<span lang="en">
The typed array view types operate with the endianness of the host computer.
</span></p>

<p>
<a href="#dataview-view-type"><code>DataView</code> ビュー型</a>
は、指定された endianness （ big-endian または little-endian ）の下で，演算を行う。
<span lang="en">
The DataView type operates upon data with a specified endianness (big-endian or little-endian).
</span></p>

<div class="note">

<p>
型付き<!--1-->配列ビュー型（ <code >Uint8Array</code>, <code >Float32Array</code>, 等々）は、グラフィクスカード, オーディオシステム, 等へ向けて送信されるような，巨大なデータブロックのメモリ内構成のために設計されている。
この種の用途では、データをメインメモリに書き込む際にホストマシンのネイティブ endianness の利用が要求される。
この仕様が型付き<!--1-->配列ビュー型に対し，一貫する指定された endianness （例えば little-endian ）の利用を義務付けない理由は、一部の CPU アーキテクチャ（この場合， big-endian アーキテクチャ）で稼働するグラフィクスカードからデータが誤って解釈されたり，その種のアーキテクチャに容認できない高い処理オーバヘッドを課さないようにするためである。
<span lang="en">
The typed array view types (Uint8Array, Float32Array, etc.) are designed for in-memory assembly of large blocks of data to be sent to the graphics card, audio system, etc. For these use cases, it is required to use the native endianness of the host machine when writing the data to main memory. If this specification had mandated for consistency that the typed array view types used a specified endianness (for example, little-endian), the data would either be misinterpreted by the graphics card on some processor architectures (in this example, big-endian architectures), or impose an unacceptably high performance overhead on such architectures.
</span></p>

<p>
データが，他のコンピュータから受信されたり, ディスク上のファイルから読み取られる際に，ホストコンピュータの endianness に関わらず 正しく解釈されるためには、データのバイト順の指定が決定的に重要になる。
基本的に，既存のどのファイル形式／ネットワークプロトコルでも、そのデータ形式は，ファイルやネットワークのペイロードに含まれるすべての複バイト<!---->データのバイト順を含め，明確に指定されている。
<code >DataView</code> ビュー型は，入出力タスクのために設計されており、したがって，指定されたバイト順のデータに対し演算を行う。
ホストコンピュータの endianness は <code >DataView</code> の処理には影響しない。
そのデータの読み書きは常に、データが特定の endianness で格納されていることを前提に，行われる。
<span lang="en">
When receiving data from other computers, or reading files from disk, it is critical to specify the byte order of the data so that it can be properly interpreted regardless of the endianness of the host computer. Essentially every file format or network protocol in existence has a clearly specified data format, including the byte order of all multi-byte data contained in the file or network payload. The DataView view type is designed for input/output tasks and therefore operates upon data with a specified byte order. The host computer's endianness is irrelevant when working with DataView; it always reads or writes data assuming that data is stored with a particular endianness.
</span></p>

<p>
より深い背景と考察が
<a href="http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/">型付き<!--1-->配列ビューの設計と利用についての論説</a>
<span class="trans-note">【
<a href="http://www.html5rocks.com/ja/tutorials/webgl/typed_arrays/" >和訳</a>
】</span>
に見られる。
<span lang="en">
This article on the design and usage of the typed array views may provide more background and in-depth discussion.
</span></p>

</div>

		</section>

	</section>
	<section id="conversions"><!-- CONVERSIONS -->
<h2 title="Type Conversion Rules" id="3">3. 型変換の規則</h2>

<p>
仕様の以下の部分では、例えば，浮動小数点値から種々のサイズの整数値への変換などにおいて、一定の型変換の規則が暗黙的に参照<!--0-->される。
これらの規則は Web IDL 仕様
<a href="#refsWEBIDL">[WEBIDL]</a>
が定義し，
<code>ToInt32</code> などの変換のアルゴリズムについては
ECMA-262仕様
<a href="#refsECMA262">[ECMA-262]</a>
が参照<!--0-->される。
<span lang="en">
The specification below implicitly references certain type conversion rules; for example, conversion of floating-point values to integer values of various sizes. The Web IDL specification [WEBIDL] defines these rules, and references the ECMA-262 specification [ECMA-262] for conversion algorithms such as ToInt32.
</span></p>

<p>
この仕様が参照<!--0-->している Web IDL 仕様は、現時点ではすべての数値型を定義していない。
例えば， <code>byte</code> は符号付き<!--1--> 8-bit 整数型である。
<span class="trans-note">【 現在の Web IDL 仕様では実質的にすべて定義されている。】</span>
これらの型については、最も近い［
サイズ, 正負符号の有無
］の型に適用される規則から，推定されるものとする。
<span lang="en">
The Web IDL specification does not currently define all of the numerical types referenced in this specification; for example, byte, which is a signed 8-bit integer type. For these types, the rules for the type of the closest size and signedness shall be extrapolated.
</span></p>

    <div class="note">
<p>
ECMA-262 仕様のアルゴリズムの実装者へのヒント：
浮動小数点数から整数値への変換では、 truncate あるいは round-to-zero が丸めモードに利用される
<span lang="en">
As a hint to implementors of the algorithms in the ECMA-262 specification, conversion of floating-point numbers to integer values uses the truncate, or round-to-zero, rounding mode.
</span></p>
    </div>

	</section>
	<section id="NAN">
<h2 title="Handling of Not-a-Number (NaN) Values" id="4">4. NaN （ Not-a-Number ）値の扱い</h2>

<p>
非数値（ NaN ）値が
<code>Float32Array</code> や <code>Float64Array</code>
に格納されるとき, あるいは
<code>setFloat32</code> や <code>setFloat64</code>
メソッドを利用して <code>DataView</code> に格納されるときの，下層の <code >ArrayBuffer</code> に書き込まれる bit パタンは指定されないが、 IEEE 754 による NaN を表現するいずれかの bit パタンになるものとする。
<a href="#refsIEEE754">[IEEE-754]</a>
<span lang="en">
When the not-a-number (NaN) value is stored into a Float32Array or Float64Array, or into a DataView using the setFloat32 or setFloat64 methods, the bit pattern written into the underlying ArrayBuffer is not specified, but shall be one of the IEEE 754 bit patterns that represent NaN [IEEE-754].
</span></p>

<p>
IEEE 754 による NaN を表現する bit パタンが
<code>Float32Array</code> や <code>Float64Array</code>
から読み込まれる, あるいは
<code>getFloat32</code> や <code>getFloat64</code>
メソッドを利用して <code>DataView</code> から読み込まれるときには、言語束縛（例えば, ECMAScript ）は，その NaN 値を表現する代替の bit パタンを利用してもよい。
<span lang="en">
When a bit pattern representing an IEEE 754 NaN is loaded from a Float32Array or Float64Array, or from a DataView using the getFloat32 or getFloat64 methods, the language binding (for example, ECMAScript) may use an alternative bit pattern to represent the NaN value.
</span></p>

<p>
Web IDL
<a href="#refsWEBIDL">[WEBIDL]</a>
および ECMA-262
<a href="#refsECMA262">[ECMA-262]</a>
仕様が NaN 値についての他のすべての取り扱いを定める。
特に， NaN が整数値に変換される際は、常に 0 に変換される。
<span lang="en">
The Web IDL [WEBIDL] and ECMA-262 [ECMA-262] specifications govern all other handling of NaN values, in particular the conversion to 0 when converting NaN to an integer value.
</span></p>

	</section>
	<section id="arraybuffer-type"><!-- ARRAYBUFFER -->
<h2 title="The ArrayBuffer Type" id="5">5. <code>ArrayBuffer</code> 型</h2>

<p>
<code>ArrayBuffer</code> 型は、配列バッファ<!---->ビューを通してデータを格納する際に利用されるバッファを表現する。
<code >ArrayBuffer</code> は次のメソッドとプロパティを持つ：
<span lang="en">
The ArrayBuffer type describes a buffer used to store data for the array buffer views. An ArrayBuffer has the following methods and properties:
</span></p>

<pre class="idl">
[ <a>Constructor</a>(unsigned long <var >length</var>) ]
interface <dfn id="ArrayBuffer">ArrayBuffer</dfn> {
    readonly attribute unsigned long <a>byteLength</a>;
    ArrayBuffer    <a>slice</a>(long <var >begin</var>, optional long <var >end</var>);
    static boolean <a>isView</a>(any <var >value</var>);
};
ArrayBuffer implements <a href="#cloning-and-transferring">Transferable</a>;</pre>

<dl class="api">
	<dt title="Constructors">構築子</dt>
	<dd>
		<dl class="idl-def">
			<dt><dfn>ArrayBuffer</dfn>(unsigned long <var >length</var>)</dt>
			<dd><p>
与えられたバイト長の新たな <code >ArrayBuffer</code> 作成する。
<code >ArrayBuffer</code> の内容は 0 に初期化される。
要求されたバイト数を割り当てられなかった場合、例外が投出される。
<span lang="en">
Creates a new ArrayBuffer of the given length in bytes. The contents of the ArrayBuffer are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.
</span></p></dd>
		</dl>
	</dd>

	<dt title="Properties">プロパティ</dt>
	<dd>
		<dl class="idl-def">
			<dt>unsigned long <dfn >byteLength</dfn></dt>
			<dd>
<p>
読み取り専用。
<span lang="en">
Read-only property.
</span></p>

<p>
<code >ArrayBuffer</code> のバイト数による長さ。
構築時に一定値に固定される。
<span lang="en">
The length of the ArrayBuffer in bytes, as fixed at construction time.
</span></p>

	<p>
この <code>ArrayBuffer</code> が無力化されている場合†、このプロパティは，読み取り時に 0 を返す。
<span class="trans-note">【†
<a href="http://html.spec.whatwg.org/multipage/infrastructure.html#transferable-objects">transferable objects</a>
】</span>
<span lang="en">
Reading this property returns 0 if this ArrayBuffer has been neutered.
</span></p>
			</dd>
		</dl>
	</dd>

	<dt title="Methods">メソッド</dt>
	<dd>
		<dl class="idl-def">
			<dt>ArrayBuffer <dfn>slice</dfn>(long <var >begin</var>, optional long <var >end</var>)</dt>
			<dd>
<p>
この <code >ArrayBuffer</code> の <var >begin</var>  から <var >end</var> の直前までのバイトの複製を内容とする，新たな <code >ArrayBuffer</code> を返す。
負の <var >begin</var>  や <var >end</var> は、始端からとは逆に，配列の終端からの index を指す。
<span lang="en">
Returns a new ArrayBuffer whose contents are a copy of this ArrayBuffer's bytes from begin, inclusive, up to end, exclusive. If either begin or end is negative, it refers to an index from the end of the array, as opposed to from the beginning.
</span></p>

<p>
<var >end</var> が指定されなかった場合、新たな <code >ArrayBuffer</code> は， <var >begin</var> からこの <code >ArrayBuffer</code> の終端までのすべてのバイトを含むことになる。
<span lang="en">
If end is unspecified, the new ArrayBuffer contains all bytes from begin to the end of this ArrayBuffer.
</span></p>

<p>
<var >begin</var> 値と <var >end</var> 値で指定される範囲は、現在の配列の有効な index 範囲に切り詰められる。
新たな <code >ArrayBuffer</code> に対し算出される長さが負になる場合、ゼロに切り上げられる。
<span lang="en">
The range specified by the begin and end values is clamped to the valid index range for the current array. If the computed length of the new ArrayBuffer would be negative, it is clamped to zero.
</span></p>
			</dd>

			<dt>static boolean <dfn>isView</dfn>(any <var >value</var>)</dt>
			<dd><p>
<var>value</var> が <code >ArrayBufferView</code> インタフェースを実装するオブジェクトであれば <code>true</code> を, 他の場合は <code>false</code> を返す。
<span lang="en">
Returns true if value is an object implementing the ArrayBufferView interface, and false otherwise.
</span></p></dd>
		</dl>
	</dd>
</dl>


	</section>
	<section id="arraybufferview-type"><!-- ARRAYBUFFERVIEW -->
<h2 title="The ArrayBufferView Type" id="6">6. <code>ArrayBufferView</code> 型</h2>

<p>
<code>ArrayBufferView</code> 型は、 <code >ArrayBuffer</code> のビュー型すべてに共通の情報を保持する。
<code>ArrayBufferView</code> は、次のプロパティを持つ：
<span lang="en">
The ArrayBufferView type holds information shared among all of the types of views of ArrayBuffers. An ArrayBufferView has the following properties:
</span></p>

<pre class="idl">
[NoInterfaceObject]
interface <dfn id="ArrayBufferView">ArrayBufferView</dfn> {
    readonly attribute ArrayBuffer   <a>buffer</a>;
    readonly attribute unsigned long <a>byteOffset</a>;
    readonly attribute unsigned long <a>byteLength</a>;
};</pre>

<dl class="api">

	<dt title="Constructors">構築子</dt>
	<dd><em>なし</em></dd>


	<dt title="Properties">プロパティ</dt>
	<dd>
		<dl class="idl-def">
			<dt>ArrayBuffer <dfn>buffer</dfn></dt>
			<dd ><p>
読み取り専用。
<span lang="en">
Read-only property.
</span></p>

<p>
この <code>ArrayBufferView</code> が参照<!--1-->している <code>ArrayBuffer</code> 。
<span lang="en">
The ArrayBuffer that this ArrayBufferView references.
</span></p></dd>

			<dt>unsigned long <dfn>byteOffset</dfn></dt>
			<dd>
<p>
読み取り専用。
<span lang="en">
Read-only property.
</span></p>

<p>
この <code>ArrayBufferView</code> が参照<!--1-->している <code>ArrayBuffer</code> の始端からの，バイト数によるオフセット。
構築時に一定値に固定される。
<span lang="en">
The offset of this ArrayBufferView from the start of its ArrayBuffer, in bytes, as fixed at construction time.
</span></p>

<p>
参照<!--1-->されている <code>ArrayBuffer</code> が無力化されている場合、このプロパティは，読み取り時に 0 を返す。
<span lang="en">
Reading this property returns 0 if the referenced ArrayBuffer has been neutered.
</span></p>
			</dd>

			<dt>unsigned long <dfn>byteLength</dfn></dt>
			<dd>
<p>
読み取り専用。
<span lang="en">
Read-only property.
</span></p>

<p>
<code>ArrayBufferView</code> のバイト数による長さ。
構築時に一定値に固定される。
<span lang="en">
The length of the ArrayBufferView in bytes, as fixed at construction time.
</span></p>

<p>
参照<!--1-->されている <code>ArrayBuffer</code> が無力化されている場合、このプロパティは，読み取り時に 0 を返す。
<span lang="en">
Reading this property returns 0 if the referenced ArrayBuffer has been neutered.
</span></p>
			</dd>
		</dl>
	</dd>

	<dt title="Methods">メソッド</dt>
	<dd><em>なし</em></dd>

</dl>


	</section>
	<section id="typed-array-view-types"><!-- TYPEDARRAYS -->
<h2 title="The Typed Array View Types" id="7">7. 型付き<!--1-->配列ビュー型</h2>

<p>
型付き<!--1-->配列ビュー（ typed array view ）型は、 <code>ArrayBuffer</code> のデータへの index アクセスと操作を可能にするビューを表現する。
これらそれぞれの長さは、構築時に一定値に固定される。
それぞれの型付き<!--1-->配列ビュー型は、同じひな型に従う。
<span lang="en">
The typed array view types represent a view of an ArrayBuffer that allows for indexing and manipulation. The length of each of these is fixed. Each of the typed array view types follows the same template.
</span></p>

<p>
次の型付き<!--1-->配列ビュー型がこの仕様にて定義される。
下の一覧におけるサイズは，バイト数で与えられ、与えられた型の <code>BYTES_PER_ELEMENT</code> 定数に対応する。
<span lang="en">
The following typed array view types are defined by this specification. The size below is given in bytes, and corresponds to the BYTES_PER_ELEMENT constant for the given type.
</span></p>

<table border>
	<thead><tr>
<th title="Type">型</th>
<th title="Size">サイズ</th>
<th title="Description">説明</th>
<th title="Web IDL type">Web IDL 型</th>
<th title="Equivalent C Type">等価な C の型</th>
	</tr></thead>

	<tbody>
<tr><td><code>Int8Array</code></td><td>1</td>
<td>
2 の補数による，<br>
8-bit 符号付き<!--1-->整数
<span lang="en">
8-bit 2's complement signed integer
</span></td>
<td><code>byte</code></td>
<td><code>signed char</code></td></tr>

<tr><td><code>Uint8Array</code></td><td>1</td>
<td>
8-bit 符号なし<!--1-->整数<br>
<span lang="en">
8-bit unsigned integer
</span></td>
<td><code>octet</code></td>
<td><code>unsigned char</code></td></tr>

<tr><td><code>Uint8ClampedArray</code></td><td>1</td>
<td>
8-bit 符号なし<!--1-->整数<br>
（切り詰めあり）
<span lang="en">
8-bit unsigned integer (clamped)
</span></td>
<td><code>octet</code></td>
<td><code>unsigned char</code></td></tr>

<tr><td><code>Int16Array</code></td><td>2</td>
<td>
2 の補数による，<br>
16-bit 符号付き<!--1-->整数
<span lang="en">
16-bit 2's complement signed integer
</span></td>
<td><code>short</code></td>
<td><code>short</code></td></tr>

<tr><td><code>Uint16Array</code></td><td>2</td>
<td>
16-bit 符号なし<!--1-->整数<br>
<span lang="en">
16-bit unsigned integer
</span></td>
<td><code>unsigned short</code></td>
<td><code>unsigned short</code></td></tr>

<tr><td><code>Int32Array</code></td><td>4</td>
<td>
2 の補数による，<br>
32-bit 符号付き<!--1-->整数
<span lang="en">
32-bit 2's complement signed integer
</span></td>
<td><code>long</code></td>
<td><code>int</code></td></tr>

<tr><td><code>Uint32Array</code></td><td>4</td>
<td>
32-bit 符号なし<!--1-->整数<br>
<span lang="en">
32-bit unsigned integer
</span></td>
<td><code>unsigned long</code></td>
<td><code>unsigned int</code></td></tr>

<tr><td><code>Float32Array</code></td><td>4</td>
<td>
32-bit<br>
IEEE 浮動小数点数
<span lang="en">
32-bit IEEE floating point
</span></td>
<td><code>unrestricted float</code></td>
<td><code>float</code></td></tr>

<tr><td><code>Float64Array</code></td><td>8</td>
<td>
64-bit<br>
IEEE 浮動小数点数
<span lang="en">
64-bit IEEE floating point
</span></td>
<td><code>unrestricted double</code></td>
<td><code>double</code></td></tr>
	</tbody>
</table>

<!-- 
<p class="trans-note">【
浮動小数点型の “unrestricted” の値には， NaN の他に +Infinity, −Infinity も許容されているが、それらの値の扱いについてはこの仕様では言及されていない。
】</p>
 -->

<p>
それぞれの型付き<!--1-->配列型は、次の構築子, プロパティ, 定数, メソッドを持つ。
以下の記述では、許容される種々の 型付き<!--1-->配列ビュー型 を指す総称として，語 <code class="union">TypedArray</code> が利用される。
<span class="trans-note">【また、 <code class="union">type</code> はその <code class="union">TypedArray</code> の要素の Web IDL 型を表すものとする。】</span>
ただし， <code>Uint8ClampedArray</code> については、次節にて定義される。
<span lang="en">
Each of the typed array types has the following constructors, properties, constants and methods. In the descriptions below, the generic term TypedArray is used to indicate that any valid typed array view type is allowed. Uint8ClampedArray is defined in the next section.
</span></p>

<p>
いずれかの <code class="union">TypedArray</code> インタフェースを実装する
<code>array</code> オブジェクトは、
範囲 0 ≤ index &lt; <code>array.length</code> の
<a href="http://heycam.github.io/webidl/#dfn-supported-property-indices">index 付きプロパティをサポートする</a>
。
<a href="#refsWEBIDL">[WEBIDL]</a>
<span lang="en">
An object array implementing one of the TypedArray interfaces supports indexed properties [WEBIDL] with indices in the range 0 ≤ index &lt; array.length.
</span></p>

<p>
複バイト値に対する演算を行う型付き<!--1-->配列ビューは、メインメモリからの値の読み書きをホストコンピュータの
<a href="#endianness">endianness</a>
の下で行う。
<span lang="en">
Typed array views operating upon multi-byte values use the host computer's endianness when reading or writing values from or to main memory.
</span></p>


<pre class="idl">
[
    <a>Constructor</a>(unsigned long <var >length</var>),
    <a>Constructor</a>(<code class="union">TypedArray</code> <var >array</var>),
    <a>Constructor</a>(<code class="union">type</code>[] <var >array</var>),
    <a>Constructor</a>(ArrayBuffer <var >buffer</var>,
                optional unsigned long <var >byteOffset</var>,
                optional unsigned long <var >length</var>)
]
interface <dfn id="TypedArray"><code class="union">TypedArray</code></dfn> {
    const unsigned long BYTES_PER_ELEMENT = <i title="element size in bytes">&lt;バイト数による要素サイズ&gt;</i>;

    readonly attribute unsigned long <a>length</a>;

    getter <code class="union">type</code> <a>get</a>(unsigned long <var >index</var>);
    setter void <a>set</a>(unsigned long index, <code class="union">type</code> <var >value</var>);
    void        <a>set</a>(<code class="union">TypedArray</code> <var >array</var>, optional unsigned long <var >offset</var>);
    void        <a>set</a>(<code class="union">type</code>[] <var >array</var>, optional unsigned long <var >offset</var>);
    <code class="union">TypedArray</code>  <a>subarray</a>(long <var >begin</var>, optional long <var >end</var>);
};
<code class="union">TypedArray</code> implements ArrayBufferView;</pre>


<dl class="api">

	<dt title="Constructors">構築子</dt>
	<dd>
		<dl class="idl-def">
			<dt><dfn class="union">TypedArray</dfn>(unsigned long <var >length</var>)</dt>
			<dd><p>
この型付き<!--1-->配列の <var >length</var> 個の要素を保持するに十分なバイト数の，新たな <code >ArrayBuffer</code> を作成した上で、そのバッファ全体を参照する型付き<!--1-->配列ビューを作成する。
直接的に構築される <code >ArrayBuffer</code> と同様、内容は 0 に初期化される。
要求されたバイト数を割り当てられなかった場合、例外が投出される。
<span lang="en">
Create a new ArrayBuffer with enough bytes to hold length elements of this typed array, then creates a typed array view referring to the full buffer. As with a directly constructed ArrayBuffer, the contents are initialized to 0. If the requested number of bytes could not be allocated an exception is raised.
</span></p></dd>

			<dt><dfn class="union">TypedArray</dfn>(<code class="union">TypedArray</code> <var >array</var>)</dt>
			<dt><dfn class="union">TypedArray</dfn>(<code class="union">type</code>[] <var >array</var>)</dt>
			<dd><p>
この型付き<!--1-->配列の <var >array</var>.<code>length</code> 個の要素を保持するに十分なバイト数の，新たな <code >ArrayBuffer</code> を作成した上で、そのバッファ全体を参照する型付き<!--1-->配列ビューを作成する。
新たなビューの内容のそれぞれの要素は、与えられた配列または型付き<!--1-->配列の内容から，型付き<!--1-->配列の型に適切に変換された上で、初期化される。
<span lang="en">
Create a new ArrayBuffer with enough bytes to hold array.length elements of this typed array, then creates a typed array view referring to the full buffer. The contents of the new view are initialized to the contents of the given array or typed array, with each element converted to the appropriate typed array type.
</span></p></dd>

			<dt><dfn class="union">TypedArray</dfn>(ArrayBuffer <var >buffer</var>, optional unsigned long <var >byteOffset</var>, optional unsigned long <var >length</var>)</dt>
			<dd>
<p>
<var >buffer</var> 引数に渡された <code >ArrayBuffer</code> をデータ格納域に利用する，新たな <code class="union">TypedArray</code> オブジェクトを作成する。
<var >byteOffset</var> （省略可）と <var >length</var> が、参照<!--1-->されるバッファの区間の制限に利用される。
<var >byteOffset</var> は、 <var >buffer</var> の始端からの，バイト数によるオフセットを指示する。
<var >length</var> は、オフセットからの，この <code class="union">TypedArray</code> が参照<!--1-->する要素の個数になる。
<var >byteOffset</var> と <var >byteLength</var> が両方とも省略された場合、 <code class="union">TypedArray</code> が参照<!--1-->する区間は， <code >ArrayBuffer</code> 全域に渡る。
<var >byteLength</var> が省略された場合、参照<!--1-->する区間は，与えられた <var >byteOffset</var> から <code >ArrayBuffer</code> の終端までに渡る。
<span lang="en">
Create a new TypedArray object using the passed ArrayBuffer for its storage. Optional byteOffset and length can be used to limit the section of the buffer referenced. The byteOffset indicates the offset in bytes from the start of the ArrayBuffer, and the length is the count of elements from the offset that this TypedArray will reference. If both byteOffset and length are omitted, the TypedArray spans the entire ArrayBuffer range. If the length is omitted, the TypedArray extends from the given byteOffset until the end of the ArrayBuffer.
</span></p>

<p>
<var >byteOffset</var> は、型に固有の要素サイズの倍数でなければならない。
そうでない場合、例外が投出される。
<span lang="en">
The given byteOffset must be a multiple of the element size of the specific type, otherwise an exception is raised.
</span></p>

<p>
<var >byteOffset</var> と <var >length</var> により参照<!--1-->される範囲が <code >ArrayBuffer</code> の終端を超えている場合、例外が投出される。
<span lang="en">
If a given byteOffset and length references an area beyond the end of the ArrayBuffer an exception is raised.
</span></p>

<p>
<var >length</var> が省略された場合、 ( <code >ArrayBuffer</code> の長さ − <var >byteOffset</var> ) は，型に固有の要素サイズの整数倍でなければならない。
そうでない場合、例外が投出される。
<span lang="en">
If length is not explicitly specified, the length of the ArrayBuffer minus the byteOffset must be a multiple of the element size of the specific type, or an exception is raised.
</span></p>
			</dd>
		</dl>
	</dd>

	<dt title="Constants">定数</dt>
	<dd>
		<dl class="idl-def">
			<dt>unsigned long <dfn >BYTES_PER_ELEMENT</dfn></dt>
			<dd><p >
バイト数による，配列の各<!---->要素のサイズ。
<span lang="en">
The size in bytes of each element in the array.
</span></p></dd>
		</dl>
	</dd>

	<dt title="Properties">プロパティ</dt>
	<dd>
		<dl class="idl-def">
			<dt>unsigned long <dfn >length</dfn></dt>
			<dd>
<p>
読み取り専用。
<span lang="en">
Read-only property.
</span></p>

<p>
要素<!---->数による， <code class="union">TypedArray</code> の長さ。
構築時に一定値に固定される。
<span lang="en">
The length of the TypedArray in elements, as fixed at construction time.
</span></p>

<p>
参照<!--1-->されている <code>ArrayBuffer</code> が無力化されている場合、このプロパティは，読み取り時に 0 を返す。
<span lang="en">
Reading this property returns 0 if the referenced ArrayBuffer has been neutered.
</span></p>
			</dd>
		</dl>
	</dd>


	<dt title="Methods">メソッド</dt>
	<dd>
		<dl class="idl-def">
			<dt>getter <code class="union">type</code> <dfn>get</dfn>(unsigned long <var >index</var>)</dt>
			<dd>
<p>
これは
<a href="http://heycam.github.io/webidl/#dfn-indexed-property-getter" >index 付き取得子</a>
（ indexed getter ）である。
<span lang="en">
This is an index getter.
</span></p>

<p>
与えられた数値 <var >index</var> に位置する要素を返す。
<span lang="en">
Returns the element at the given numeric index.
</span></p>

<p>
<code>Float32Array</code> と <code>Float64Array</code> に適用される追加の規則については、
<a href="#NAN">NaN 値の扱い</a>
を見よ。
<span lang="en">
See handling of NaN values for additional rules covering Float32Array and Float64Array.
</span></p>

			<dt>setter void <dfn >set</dfn>(unsigned long <var >index</var>, <code class="union">type</code> <var >value</var>)</dt>
			<dd>
<p>
これは
<a href="http://heycam.github.io/webidl/#dfn-indexed-property-setter" >index 付き設定子</a>
（ indexed setter ）である。
<span lang="en">
This is an index setter.
</span></p>

<p>
与えられた数値 <var >index</var> に位置する要素を与えられた <var >value</var> にする。
<span lang="en">
Sets the element at the given numeric index to the given value.
</span></p>

<p>
値から <code class="union">type</code> への変換は、
<a href="#conversions">型変換<!---->規則</a>
と
<a href="#NAN">NaN 値の扱い</a>
により定義される。
<span lang="en">
Conversions of values to type are defined by the type conversion rules and handling of NaN values.
</span></p>

			<dt>void <dfn>set</dfn>(<code class="union">TypedArray</code> <var >array</var>, optional unsigned long <var >offset</var>)</dt>
			<dt>void <dfn>set</dfn>(<code class="union">type</code>[] <var >array</var>, optional unsigned long <var >offset</var>)</dt>
			<dd>
<p>
<var >array</var> から読み取られる入力値により、複数個の要素の値を設定する。
<span lang="en">
Set multiple values, reading input values from the array.
</span></p>

<p>
<var >offset</var> （省略可）は、現在の配列に値を書き込む最初の index を指示する。
省略された場合、 0 と見なされる。
<span lang="en">
The optional offset value indicates the index in the current array where values are written. If omitted, it is assumed to be 0.
</span></p>

<p>
入力配列が <code class="union">TypedArray</code> である場合、二つの配列が，同じ下層の <code>ArrayBuffer</code> を利用していることもあり得る。
この状況における値の設定は、すべてのデータが，いずれの配列にも重ならない一時バッファにいったん複製されてから，その一時バッファのデータが現在の配列に複製されるかのように、ふるまうものとする。
<span lang="en">
If the input array is a TypedArray, the two arrays may use the same underlying ArrayBuffer. In this situation, setting the values takes place as if all the data is first copied into a temporary buffer that does not overlap either of the arrays, and then the data from the temporary buffer is copied into the current array.
</span></p>

<p>
［ <var >offset</var> + 与えられた配列の長さ ］が現在の <code class="union">TypedArray</code> の範囲を超えている場合、例外が投出される。
<span lang="en">
If the offset plus the length of the given array is out of range for the current TypedArray, an exception is raised.
</span></p>

			<dt><code class="union">TypedArray</code> <dfn>subarray</dfn>(long <var >begin</var>, optional long <var >end</var>)</dt>
			<dd>
<p>
この <code class="union">TypedArray</code> が参照<!--1-->する <code>ArrayBuffer</code> と同じ <code>ArrayBuffer</code> を参照<!--1-->し，この <code class="union">TypedArray</code> の <var >begin</var>  から <var >end</var> の直前までの要素を参照する、新たな <code class="union">TypedArray</code> ビューを返す。
負の <var >begin</var>  や <var >end</var> は、始端からとは逆に，配列の終端からの index を表す。
<span lang="en">
Returns a new TypedArray view of the ArrayBuffer store for this TypedArray, referencing the elements at begin, inclusive, up to end, exclusive. If either begin or end is negative, it refers to an index from the end of the array, as opposed to from the beginning.
</span></p>

<p>
<var >end</var> が指定されなかった場合、 <var >subarray</var> には， <var >begin</var> から <code class="union">TypedArray</code> の終端までのすべての要素が含まれる。
<span lang="en">
If end is unspecified, the subarray contains all elements from begin to the end of the TypedArray.
</span></p>
<p><!-- copy* -->
<var >begin</var> 値と <var >end</var> 値で指定される範囲は、現在の配列の有効な index 範囲に切り詰められる。
新たな <code >ArrayBuffer</code> に対し算出される長さが 負になる場合、ゼロに切り上げられる。
<span lang="en">
The range specified by the begin and end values is clamped to the valid index range for the current array. If the computed length of the new TypedArray would be negative, it is clamped to zero.
</span></p>

<p>
返される <code class="union">TypedArray</code> の型は，このメソッドが呼び出された配列と同じになる。
<span lang="en">
The returned TypedArray will be of the same type as the array on which this method is invoked.
</span></p>
			</dd>
		</dl>
	</dd>
</dl>


		<section id="uint8clampedarray-type"><!-- UINT8CLAMPEDARRAY -->
<h3 id="7.1">7.1. <code>Uint8ClampedArray</code></h3>

<p>
<code>Uint8ClampedArray</code> は、 <code>CanvasPixelArray</code> を置き換えるためのものである。
そのふるまいは、設定子と構築子において 入力数値を変換する際に、 modulo 算術ではなく，
<a href="http://heycam.github.io/webidl/#Clamp">切り詰め</a>
<a href="#refsWEBIDL">[WEBIDL]</a>
が利用されることを除き、他の型付き<!--1-->配列ビューと同じである。
<code>Uint8ClampedArray</code> の IDL は次で与えられる：
<span lang="en">
Uint8ClampedArray is defined in order to replace CanvasPixelArray. It behaves identically to the other typed array views, except that the setters and constructor use clamping [WEBIDL] rather than modulo arithmetic when converting incoming number values. The IDL for Uint8ClampedArray follows.
</span></p>

<pre class="idl">
<span title="The 'unsigned byte' type does not currently exist in Web IDL, though // 'octet' is equivalent."
>// 現時点では、 'unsigned byte' 型は Web IDL に存在しないが、
// 'octet' がそれに等価なものにあたる。</span>
[
    <a>Constructor</a>(unsigned long <var >length</var>),
    <a>Constructor</a>(Uint8ClampedArray <var >array</var>),
    <a>Constructor</a>(octet[] <var >array</var>),
    <a>Constructor</a>(ArrayBuffer <var >buffer</var>,
                optional unsigned long <var >byteOffset</var>,
                optional unsigned long <var >length</var>)
]
interface <dfn id="Uint8ClampedArray">Uint8ClampedArray</dfn> {
    const unsigned long <a>BYTES_PER_ELEMENT</a> = 1;

    readonly attribute unsigned long <a>length</a>;

    getter octet <a>get</a>(unsigned long <var >index</var>);
    setter void  <a>set</a>(unsigned long <var >index</var>, [Clamp] octet <var >value</var>);
    void         <a>set</a>(Uint8ClampedArray <var >array</var>, optional unsigned long <var >offset</var>);
    void         <a>set</a>(octet[] <var >array</var>, optional unsigned long <var >offset</var>);
    Uint8ClampedArray <a>subarray</a>(long <var >begin</var>, optional long <var >end</var>);
};
Uint8ClampedArray implements ArrayBufferView;</pre>



		</section>
	</section>
	<section id="dataview-view-type"><!-- DATAVIEW -->
<h2 title="The DataView View Type" id="8">8. <code>DataView</code> ビュー型</h2>

<p>
<code>ArrayBuffer</code> は、任意のデータ域の表現に有用になるオブジェクトである。
多くの場合、その種のデータは，ディスクやネットワークから読み取られ、これまでに述べた，型付き<!--1-->配列ビューに課されているアラインメントの制約には従わない。
加えて、データはしばしば，その特質から雑多な要素から構成され, 定義済みのバイト順を持つ。
<code>DataView</code> ビューは、その種のデータの <code >ArrayBuffer</code> からの読み取り／への書き込みを可能にする，低レベルのインタフェースを提供する。
<span lang="en">
An ArrayBuffer is a useful object for representing an arbitrary chunk of data. In many cases, such data will be read from disk or from the network, and will not follow the alignment restrictions that are imposed on the typed array views described earlier. In addition, the data will often be heterogeneous in nature and have a defined byte order. The DataView view provides a low-level interface for reading such data from and writing it to an ArrayBuffer.
</span></p>

<p>
コンピュータの <a href="#endianness">endianness</a> に関わらず、
<code >DataView</code> は メインメモリに対する値の読み書きを，指定された endianness （ big または little ）の下で行う。
<span lang="en">
Regardless of the host computer's endianness, DataView reads or writes values to or from main memory with a specified endianness: big or little.
</span></p>

<pre class="idl">
[
  <a>Constructor</a>(ArrayBuffer buffer,
              optional unsigned long byteOffset,
              optional unsigned long byteLength)
]
interface <dfn id="DataView">DataView</dfn> {
<span
title="// Gets the value of the given type at the specified byte offset // from the start of the view. There is no alignment constraint; // multi-byte values may be fetched from any offset."
>    // ビューの始端から 指定されたバイトオフセットの所から，
    // 与えられた型による値を取得する。アラインメントの拘束はなく、
    // 任意のオフセットの所から複バイト値を取得できる。</span>
    //
<span
title="// For multi-byte values, the optional littleEndian argument // indicates whether a big-endian or little-endian value should be // read. If false or undefined, a big-endian value is read."
>    // 複バイト値に対しては、 <var >littleEndian</var> 引数（省略可）が，
    // 格納されているデータを big-endian 値か little-endian 値の
    // いずれとして読み取るべきかを指示する。false または undefined
    // の場合、big-endian 値として読み取られる。</span>
    //
<span
title="These methods raise an exception if they would read // beyond the end of the view."
>    // これらのメソッドで、ビューの終端を超える読み取りが
    // 試みられた場合，例外が投出される。</span>

    byte           <a>getInt8</a>(unsigned long <var >byteOffset</var>);
    octet          <a>getUint8</a>(unsigned long <var >byteOffset</var>);
    short          <a>getInt16</a>(unsigned long <var >byteOffset</var>,
                            optional boolean <var >littleEndian</var>);
    unsigned short <a>getUint16</a>(unsigned long <var >byteOffset</var>,
                             optional boolean <var >littleEndian</var>);
    long           <a>getInt32</a>(unsigned long <var >byteOffset</var>,
                            optional boolean <var >littleEndian</var>);
    unsigned long  <a>getUint32</a>(unsigned long <var >byteOffset</var>,
                             optional boolean <var >littleEndian</var>);
    float          <a>getFloat32</a>(unsigned long <var >byteOffset</var>,
                              optional boolean <var >littleEndian</var>);
    double         <a>getFloat64</a>(unsigned long <var >byteOffset</var>,
                              optional boolean <var >littleEndian</var>);

<span
title="Stores a value of the given type at the specified byte offset // from the start of the view. There is no alignment constraint; // multi-byte values may be stored at any offset."
>    // ビューの始端から 指定されたバイトオフセットの所から，
    // 与えられた型による値を格納する。アラインメントの拘束はなく、
    // 任意のオフセットの所から複バイト値を格納できる。</span>
    //
<span
title="For multi-byte values, the optional littleEndian argument // indicates whether the value should be stored in big-endian or // little-endian byte order. If false or undefined, the value is // stored in big-endian byte order."
>    // 複バイト値に対しては、 <var >littleEndian</var> 引数（省略可）が，
    // データを big-endian か little-endian のいずれのバイト順で格納すべき
    // であるかを指示する。 false または undefined の場合、 
    // big-endian によるバイト順で格納される。</span>
    //
<span
title="These methods raise an exception if they would write // beyond the end of the view."
>    // これらのメソッドで、ビューの終端を超える書き込みが
    // 試みられた際には，例外が投出される。</span>

    void <a>setInt8</a>(unsigned long <var >byteOffset</var>,
                 byte <var >value</var>);
    void <a>setUint8</a>(unsigned long <var >byteOffset</var>,
                  octet <var >value</var>);
    void <a>setInt16</a>(unsigned long <var >byteOffset</var>,
                  short <var >value</var>,
                  optional boolean <var >littleEndian</var>);
    void <a>setUint16</a>(unsigned long <var >byteOffset</var>,
                   unsigned short <var >value</var>,
                   optional boolean <var >littleEndian</var>);
    void <a>setInt32</a>(unsigned long <var >byteOffset</var>,
                  long <var >value</var>,
                  optional boolean <var >littleEndian</var>);
    void <a>setUint32</a>(unsigned long <var >byteOffset</var>,
                   unsigned long <var >value</var>,
                   optional boolean <var >littleEndian</var>);
    void <a>setFloat32</a>(unsigned long <var >byteOffset</var>,
                    float <var >value</var>,
                    optional boolean <var >littleEndian</var>);
    void <a>setFloat64</a>(unsigned long <var >byteOffset</var>,
                    double <var >value</var>,
                    optional boolean <var >littleEndian</var>);
};
DataView implements ArrayBufferView;</pre>

<p>
<code>DataView</code> では、次の構築子, プロパティ, メソッドが利用できる：
<span lang="en">
The following constructors, properties, and methods are available on a DataView:
</span></p>

<dl class="api">

	<dt title="Constructors">構築子</dt>
	<dd>
		<dl class="idl-def">
			<dt><dfn>DataView</dfn>(ArrayBuffer buffer, optional unsigned long <var >byteOffset</var>, optional unsigned long <var >byteLength</var>)</dt>
			<dd>
<p>
引数に渡された <code >ArrayBuffer</code> をデータ格納域に利用する，新たな <code>DataView</code> オブジェクトを作成する。
<var >byteOffset</var> （省略可）と <var >byteLength</var> が、参照<!--1-->するバッファの区間の制限に利用される。
<var >byteOffset</var>は、 <code >ArrayBuffer</code> の始端からの，バイト数によるオフセットを指示する。
<var >byteLength</var> は、オフセットからの，この <code>DataView</code> が参照<!--1-->するバイト数を与える。
<var >byteOffset</var> と <var >byteLength</var> が両方とも省略された場合、 <code>DataView</code> が参照<!--1-->する区間は， <code >ArrayBuffer</code> 全域に渡る。
<var >byteLength</var> が省略された場合、参照<!--1-->する区間は，与えられた <var >byteOffset</var> から <code >ArrayBuffer</code> の終端までに渡る。
<span lang="en">
Create a new DataView object using the passed ArrayBuffer for its storage. Optional byteOffset and byteLength can be used to limit the section of the buffer referenced. The byteOffset indicates the offset in bytes from the start of the ArrayBuffer, and the byteLength is the number of bytes from the offset that this DataView will reference. If both byteOffset and byteLength are omitted, the DataView spans the entire ArrayBuffer range. If the byteLength is omitted, the DataView extends from the given byteOffset until the end of the ArrayBuffer.
</span></p>

<p>
<var >byteOffset</var> と <var >byteLength</var> により参照<!--1-->される範囲が <code >ArrayBuffer</code> の終端を超えている場合、例外が投出される。
<span lang="en">
If the given byteOffset and byteLength references an area beyond the end of the ArrayBuffer an exception is raised.
</span></p>
			</dd>
		</dl>
	</dd>

	<dt title="Properties">プロパティ</dt>
	<dd><em>なし</em></dd>

	<dt title="Methods">メソッド</dt>
	<dd>
		<dl class="idl-def">
			<dt>byte <dfn>getInt8</dfn>(unsigned long <var >byteOffset</var>);</dt>
			<dt>octet <dfn>getUint8</dfn>(unsigned long <var >byteOffset</var>);</dt>
			<dt>short <dfn>getInt16</dfn>(unsigned long <var >byteOffset</var>, optional boolean <var >littleEndian</var>);</dt>
			<dt>unsigned short <dfn>getUint16</dfn>(unsigned long <var >byteOffset</var>, optional boolean <var >littleEndian</var>);</dt>
			<dt>long <dfn>getInt32</dfn>(unsigned long <var >byteOffset</var>, optional boolean <var >littleEndian</var>);</dt>
			<dt>unsigned long <dfn>getUint32</dfn>(unsigned long <var >byteOffset</var>, optional boolean <var >littleEndian</var>);</dt>
			<dt>float <dfn>getFloat32</dfn>(unsigned long <var >byteOffset</var>, optional boolean <var >littleEndian</var>);</dt>
			<dt>double <dfn>getFloat64</dfn>(unsigned long <var >byteOffset</var>, optional boolean <var >littleEndian</var>);</dt>
			<dd>
<p>
ビューの始端からのバイトオフセット <var >byteOffset</var> の所から，与えられた型による値を取得する。
アラインメントの拘束はなく、任意のオフセットの所から複バイト値を取得できる。
<span lang="en">
Gets the value of the given type at the specified byte offset from the start of the view. There is no alignment constraint; multi-byte values may be fetched from any offset.
</span></p>

<p>
複バイト値に対しては、 <var >littleEndian</var> 引数（省略可）が，格納されているデータを big-endian 値か little-endian 値のいずれとして読み取るべきかを指示する。
false または undefined の場合、 big-endian 値として読み取られる。
<span lang="en">
For multi-byte values, the optional littleEndian argument indicates whether a big-endian or little-endian value should be read. If false or undefined, a big-endian value is read.
</span></p>

<p>
これらのメソッドで、ビューの終端を超える読み取りが試みられた場合，例外が投出される。
<span lang="en">
These methods raise an exception if they would read beyond the end of the view.
</span></p>

<p>
<code>getFloat32</code> と <code>getFloat64</code> に適用される追加の規則については、
<a href="#NAN">NaN 値の扱い</a>
を見よ。
<span lang="en">
See handling of NaN values for additional rules covering getFloat32 and getFloat64.
</span></p>
			</dd>

			<dt>void <dfn>setInt8</dfn>(unsigned long <var >byteOffset</var>, byte value);</dt>
			<dt>void <dfn>setUint8</dfn>(unsigned long <var >byteOffset</var>, octet value);</dt>
			<dt>void <dfn>setInt16</dfn>(unsigned long <var >byteOffset</var>, short value, optional boolean <var >littleEndian</var>);</dt>
			<dt>void <dfn>setUint16</dfn>(unsigned long <var >byteOffset</var>, unsigned short value, optional boolean <var >littleEndian</var>);</dt>
			<dt>void <dfn>setInt32</dfn>(unsigned long <var >byteOffset</var>, long value, optional boolean <var >littleEndian</var>);</dt>
			<dt>void <dfn>setUint32</dfn>(unsigned long <var >byteOffset</var>, unsigned long value, optional boolean <var >littleEndian</var>);</dt>
			<dt>void <dfn>setFloat32</dfn>(unsigned long <var >byteOffset</var>, float value, optional boolean <var >littleEndian</var>);</dt>
			<dt>void <dfn>setFloat64</dfn>(unsigned long <var >byteOffset</var>, double value, optional boolean <var >littleEndian</var>);</dt>

			<dd>
<p>
ビューの始端からのバイトオフセット <var >byteOffset</var> の所から，与えられた型による値を格納する。
アラインメントの拘束はなく、任意のオフセットの所から複バイト値を格納できる。
<span lang="en">
Stores a value of the given type at the specified byte offset from the start of the view. There is no alignment constraint; multi-byte values may be stored at any offset.
</span></p>

<p>
複バイト値に対しては、 <var >littleEndian</var> 引数（省略可）が，データを big-endian か little-endian のいずれのバイト順で格納すべきであるかを指示する。 false または undefined の場合、 big-endian によるバイト順で格納される。
<span lang="en">
For multi-byte values, the optional littleEndian argument indicates whether the value should be stored in big-endian or little-endian byte order. If false or undefined, the value is stored in big-endian byte order.
</span></p>

<p>
これらのメソッドでは、ビューの終端を超える書き込みが試みられた際には，例外が投出される。
<span lang="en">
These methods raise an exception if they would write beyond the end of the view.
</span></p>

<p>
与えられた型への値の変換は、
<a href="#conversions">型変換の規則</a>
および
<a href="#NAN">NaN 値の扱い</a>
にて定義される。
<span lang="en">
Conversions of values to the given type are defined by the type conversion rules and handling of NaN values.
</span></p>
			</dd>
		</dl>
	</dd>
</dl>


	</section>
	<section id="cloning-and-transferring">
<h2 title="Cloning and Transferring ArrayBuffers and Views" id="9">9. <code >ArrayBuffer</code> およびビューの，クローンと転送</h2>

<div class="note">
<p>
Web Workers
<a href="#refsWEBWORKERS">[WEBWORKERS]</a>,
との間で、大きなデータを繰り返し転送できるようにするため、 <code>ArrayBuffer</code> は
<!-- ＊ Transferable 削除 160302 -->
<code ><a href="http://html.spec.whatwg.org/multipage/infrastructure.html#transfer-a-transferable-object">Transferable</a></code>
インタフェース
<a href="#refsHTML">[HTML]</a>
を実装する。
この節では、
<a href="http://html.spec.whatwg.org/multipage/infrastructure.html#safe-passing-of-structured-data">有構造クローン</a>
<a href="#refsHTML">[HTML]</a>
（ structured cloning ）, および転送アルゴリズムの下での、 <code >ArrayBuffer</code> および ビューのふるまいを定義する。
<span lang="en">
In order to enable repeated transfer of large amounts of data between Web Workers [WEBWORKERS], ArrayBuffer implements the Transferable interface [HTML]. This section defines the behavior of ArrayBuffers and views under the structured cloning [HTML] and transfer algorithms.
</span></p>

</div>

		<section id="cloning-arraybuffer">
<h3 title="Cloning an ArrayBuffer" id="9.1">9.1. <code>ArrayBuffer</code> のクローン</h3>


<p>
利用者エージェントが <code>ArrayBuffer</code> オブジェクト <var>old</var> を <b>クローン</b> するときは、次の手続きを実行して，新たな <code>ArrayBuffer</code> オブジェクトを返さなければならない。
この手続きは不可分的に実行されなければならない。
<span lang="en">
When a user agent is asked to clone an ArrayBuffer object old, it must run the following steps, which return a new ArrayBuffer object. These steps must be run atomically.
</span></p>

	<ol>
		<li><p>
<var>old</var> の下層データの複製を参照し, <code>byteLength</code> プロパティの値が <var>old</var> と同じにされた，新たな <code>ArrayBuffer</code> オブジェクト <var>new buffer</var> を作成する。
<span lang="en">
Create a new ArrayBuffer object new buffer pointing at a copy of the underlying data from old, and with the same byteLength property.
</span></p>
		</li>
		<li><p>
<var>new buffer</var> を返す（これがクローンである）。
<span lang="en">
Return new buffer. It is the clone.
</span></p>
		</li>

	</ol>

		</section>
		<section id="transferring">
<h3 title="Transferring an ArrayBuffer" id="9.2">9.2. <code >ArrayBuffer</code> の転送</h3>

<p>
次のものを
<code ><a href="http://html.spec.whatwg.org/multipage/infrastructure.html#transfer-a-transferable-object">Transferable</a></code>
型のリストに追加する。
<span lang="en">
Add the following to the list of Transferable types:
</span></p>

	<ul>
		<li>
<code>ArrayBuffer</code>
<span lang="en">
ArrayBuffer
</span>
		</li>
	</ul>

<p>
<code>ArrayBuffer</code> オブジェクト <var>old</var> を
<a href="http://html.spec.whatwg.org/multipage/infrastructure.html#transfer-a-transferable-object">転送</a>
<a href="#refsHTML">[HTML]</a>
する際には、利用者エージェントは，次の手続きを実行しなければならない
<span lang="en">
To transfer [HTML] an ArrayBuffer object old, a user agent must run the following steps.
</span></p>

	<ol>
		<li>
<var>old</var> の下層データの複製を参照し, <code>byteLength</code> プロパティの値が <var>old</var> と同じにされた，新たな <code>ArrayBuffer</code> オブジェクト <var>new buffer</var> を作成する。
<span lang="en">
Create a new ArrayBuffer object new buffer pointing at the same underlying data as old, and with the same byteLength property.
</span></li>

		<li>
オブジェクト <var>old</var> を
<a href="http://html.spec.whatwg.org/multipage/infrastructure.html#transferable-objects">無力化</a>
<a href="#refsHTML">[HTML]</a>
する。
<span lang="en">
Neuter [HTML] object old.
</span></li>

		<li>
<var>new buffer</var> を返す。
<span lang="en">
Return new buffer.
</span></li>

	</ol>

		</section>
		<section id="cloning-arraybufferview">
<h3 title="Cloning an ArrayBufferView" id="9.3">9.3. <code >ArrayBufferView</code> のクローン</h3>


<p>
利用者エージェントが <code>ArrayBufferView</code> オブジェクト <var>old</var> を <b>クローン</b> する必要があるときは、新たなオブジェクトを返す，次の手続きを実行しなければならない。
この手続きは不可分的に実行されなければならない。
<span lang="en">
When a user agent is asked to clone an ArrayBufferView object old, it must run the following steps, which return a new object. These steps must be run atomically.
</span></p>

	<ol>
		<li><p>
<var>buffer</var> :← <var>old</var> の <code>buffer</code> プロパティに対し
内部的 有構造クローン アルゴリズム
<span class="trans-note">【
<a href="http://html.spec.whatwg.org/multipage/infrastructure.html#internal-structured-cloning-algorithm">internal structured cloning algorithm</a>
】</span>
<!-- 
http://dev.w3.org/html5/spec-LC/infrastructure.html#internal-structured-cloning-algorithm
 -->
を再帰的に呼び出した結果とする。
<span lang="en">
Let buffer be the result of invoking the internal structured cloning algorithm recursively on the buffer property of old.
</span></p>

		</li>
		<li><p>
<var>new view</var> :←
新たに構築された <var>old</var> と同じ型の <code>ArrayBufferView</code> サブクラス。
ここで <var>new view</var> は、 <var>buffer</var> を参照し， <var>old</var> と同じ［
<code>byteOffset</code>, <code>byteLength</code>, サブクラス固有のプロパティすべて
］を伴うものとする。
<span lang="en">
Let new view be a newly constructed ArrayBufferView subclass of the same type as old, referring to buffer, and with the same byteOffset, byteLength, and any subclass-specific properties as old.
</span></p>

		</li>
		<li><p>
<var>new view</var> を返す（これがクローンである）。
<span lang="en">
Return new view. It is the clone.
</span></p>
		</li>
	</ol>

<div class="note">

<p>
上の節により、次のふるまいが導き出される：
<span lang="en">
The above sections define the following behavior:
</span></p>

	<ul>
		<li><p>
<code>ArrayBuffer</code> が <code>postMessage</code> 呼び出しの下で転送されている場合、その <code>ArrayBuffer</code> を参照し, その呼び出しの間にクローンされた <code>ArrayBufferView</code> インスタンスは、新たに割り当てられた <code>ArrayBuffer</code> オブジェクトを参照する。
<code>postMessage</code> 呼び出しの後、古い <code>ArrayBuffer</code> を参照している <code>ArrayBufferView</code> のインスタンスは，それ以上バッファのデータを参照<!--1-->できなくなる。
それらのインスタンスや古い方の <code>ArrayBuffer</code> に対し，更なるクローンが試行された場合、 <code>DATA_CLONE_ERR</code> 例外が投出されることになる。
<span lang="en">
If an ArrayBuffer is transferred during a postMessage call, then any ArrayBufferView instances which refer to that ArrayBuffer and which are cloned during that call refer to the newly allocated ArrayBuffer object. After the postMessage call, the ArrayBufferView instances referring to the old ArrayBuffer can no longer be used to reference the buffer's data. Further attempts to clone them or the old ArrayBuffer will cause a DATA_CLONE_ERR exception to be thrown.
</span></p>

		</li>
		<li><p>
転送<!---->以外のクローンのふるまいは、 <code>ArrayBuffer</code> および，それを参照するどの <code>ArrayBufferView</code> のインスタンスについても，他の任意のオブジェクト型と同じである。
<span lang="en">
The behavior of cloning, rather than transferring, an ArrayBuffer and any ArrayBufferView instances which refer to it is the same as for any other object type.
</span></p>

		</li>
		<li><p>
転送<!---->可能なのは <code>ArrayBuffer</code> 型のみである。
<code>ArrayBufferView</code> のインスタンスを転送したり、
<span class="trans-note">【転送されているものと】</span>
同じ下層の <code>ArrayBuffer</code> を参照する， <code>ArrayBufferView</code> のインスタンスをクローンすることはできない。
<span lang="en">
Only the ArrayBuffer type is transferable. It is not possible to transfer certain ArrayBufferView instances, and clone others, if they refer to the same underlying ArrayBuffer.
</span></p>

		</li>
	</ul>
</div>


		</section>
	</section>
	<section id="examples">
<h2 title="Examples" id="10">10. 用例</h2>

<div class="note">
	<dl >
		<dt>
単純な 128 個の 32-bit float からなる配列を作成：
<span lang="en">
Creating a simple array of 128 32-bit floats:
</span></dt>

		<dd>
<pre>var f32s = new Float32Array(128);</pre>
		</dd>

		<dt>
新たな配列において、 8 個の連続する float ごとに，値をあてがう：
<span lang="en">
Filling each 8 consecutive floats of the new array:
</span></dt>

		<dd>
<pre>
for (var i = 0; i &lt; 128/8; ++i) {
  var sub_f32s = f32s.subarray(i, i+8);
  for (var j = 0; j &lt; 8; ++j) {
    sub_f32s[j] = j;
  }
}
</pre>

<p>
このコードは、 <samp>subarray()</samp> を利用して，元と同じデータを参照<!--1-->する新たな <code >Float32Array</code> を作成し、どの部分配列も常に 0 〜 7 で index アクセスできるようにする。
<span lang="en">
Note that this code uses subarray() to create a new Float32Array that references the same data as the original, so that it can always index the sub-array using 0..7.
</span></p>
		</dd>

		<dt>交替的な配列型</dt>
		<dd>
<p>
一部の API，特に WebGL
<a href="#refsWEBGL">[WEBGL]</a>
は、異なるデータ型が交替的に繰り返される，単独の連続的バッファが利用可能になることから恩恵を得る。
例えば，１個の point は、１個の座標データ（ 3 個の Float32 値）に続いて１個の色データ（ 4 個の Uint8 値）を持つ。
<span lang="en">
Some APIs, in particular WebGL [WEBGL], can benefit from being able to use a single contiguous buffer, with interleaved data types. For example, a point might have coordinate data (3 Float32 values) followed by color data (4 Uint8 values).
</span></p>

<p>
4 個の point とそれらに結び付けられた色は、次の様にして設定できる：
<span lang="en">
For 4 points and their associated colors, this can be set up in the following way:
</span></p>

<pre>var elementSize = 3 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT;
var buffer = new ArrayBuffer(4 * elementSize);
var coords = new Float32Array(buffer, 0);
var colors = new Uint8Array(buffer, 3 * Float32Array.BYTES_PER_ELEMENT);
</pre>

<p>
しかしながら，型付き<!--1-->配列は、望まれる point 単位の構造へ符号化するための，明示的な方法は備えていない。
したがって、正しく index アクセスするためには，何らかの手作業による算術が必要になる。
<code >Uint8Array</code> ビュー <var>colors</var> は、要素 [0] が下層バッファの 13 番目のバイトを指せるように，（バイト数で与えられる）明示的なオフセットを伴って作成されることに注意。
<span lang="en">
However, typed arrays don't have a way to explicitly encode the desired per-point structure, so some manual arithmetic must be done to correctly index into the right values. Note that the colors Uint8Array view is created with an explicit offset (which is given in bytes), so that the [0] element points at the 13th byte in the underlying buffer.
</span></p>

<p>
この例では、それぞれの ひとまとまりのデータのサイズは， 16 バイトになる（ 3 個の 4 バイト float に続く 4 バイト）。
16 ÷ <code >Float32Array.BYTES_PER_ELEMENT</code> = 4 になるので、与えられた Float32 要素から，次の point の同じ Float32 要素へ移動するためには、 index に 4 を加える必要がある。
同様に、与えられた Uint8 要素から，次の point の同じ位置に移動するには、 16 を加える必要がある：
<span lang="en">
In this example, each set of packed data is 16 bytes in size (3 4-byte floats followed by 4 bytes). 16 / Float32Array.BYTES_PER_ELEMENT is 4, so from any given Float32 element, to skip to the same Float32 element in the next point, 4 must be added to the index. Similarly, to skip from any given Uint8 element to the same in the next point, 16 must be added:
</span></p>


<pre>
var coordOffset = elementSize / Float32Array.BYTES_PER_ELEMENT;
var colorOffset = elementSize / Uint8Array.BYTES_PER_ELEMENT;

coords[0] = coords[1] = coords[2] = 1.0; <span
title="The first point's three coordinate values"
>// 最初の point の 3 個の座標成分値</span>
colors[0] = colors[1] = colors[2] = colors[3] = 255; <span
title="The first point's four colors"
>// 最初の point の 4 個の色成分値</span>

coords[0 + <var >N</var> * coordOffset] = 5.0; <span
title="The Nth point's first coordinate value"
>// <var >N</var> 番目の point の最初の座標成分値</span>
colors[0 + <var >N</var> * colorOffset] = 128; <span
title="The Nth point's first color value"
>// <var >N</var> 番目の point の最初の色成分値</span>

coords[<var >i</var> + <var >N</var> * coordOffset] = 6.0; <span
title="The Nth point's i coordinate value;"
>// <var >N</var> 番目の point の <var >i</var> 番目の座標成分値</span>
colors[<var >j</var> + <var >N</var> * colorOffset] = 200; <span
title="The Nth point's j color value"
>// <var >N</var> 番目の point の <var >j</var> 番目の色成分値</span>
</pre>

<p>
上の例でデータの一貫性が保たれるためには、 <var >i</var> は 0, 1, 2 のいずれか, <var >j</var> は 0, 1, 2, 3 のいずれか，でなければならないことに注意。
値がそれを超えると、 32-bit float や 8-bit integer に用意されたデータ区分が不正なデータで上書きされることになる。
<span lang="en">
In the above example, note that for keeping the data consistent, i must be one of 0, 1, or 2; and j must be one of 0, 1, 2, or 3. Any higher values will result in data segments that are reserved for 32-bit floats or for 8-bit integers being overwritten with incorrect data.
</span></p>
		</dd>


		<dt>
大きな配列から複数の部分域を切り出す
<span lang="en">
Slicing a large array into multiple regions
</span></dt>
		<dd>
<p>
上のものに似た他の利用として、１個の大きなバッファを割り当てた上で，様々な目的で異なる区域を利用する：
<span lang="en">
Another usage similar to the above is allocating one large buffer, and then using different regions of it for different purposes:
</span></p>

<pre>
var <var >buffer</var> = new ArrayBuffer(1024);</pre>

<p>
サイズ 128 × 4 = 512 バイトの 128 個の float を切り出す：
<span lang="en">
Carve out 128 floats, 128*4 = 512 bytes in size:
</span></p>

<pre>
var <var >floats</var> = new Float32Array(<var >buffer</var>, 0, 128);</pre>

<p>
しかる後、 <var >floats</var> の直後から，サイズ 128 × 2 = 256 バイトの 128 個の short を切り出す。
バイトオフセット引数 512 は、
<code><var >floats</var>.byteOffset + <var >floats</var>.byteLength</code>
に等しいことに注意。
<span lang="en">
Then 128 shorts, 128*2 = 256 bytes in size, immediately following the floats. Note that the 512 byte offset argument is equal to floats.byteOffset + floats.byteLength.
</span></p>

<pre>
var <var >shorts</var> = new Uint16Array(<var >buffer</var>, 512, 128);</pre>

<p>
最後に、 256 個の符号なし<!--1-->バイトを切り出す。
バイトオフセットを先に示したやり方で書けば、連鎖も単純になる。
長さを省略すれば、配列は ArrayBuffer の終端まで延長される。
<span lang="en">
Finally, 256 unsigned bytes. We can write the byte offset in the form suggested above to simplify the chaining. We also let this array extend until the end of the ArrayBuffer by not explicitly specifying a length.
</span></p>

<pre>var <var >bytes</var> = new Uint8Array(<var >buffer</var>, <var >shorts</var>.byteOffset + <var >shorts</var>.byteLength);</pre>

<p>
データがそれ以上必要とされなくなった際には、単に古いビューを破棄して, 新たなビューを作成することにより，追加の割り当て（この例では全体で 1024 バイト）を要せずに配列を再利用できる。
<span lang="en">
If the data is no longer needed, the entire 1024-byte array can be repurposed without causing additional allocations simply by creating new views and discarding the old.
</span></p>
		</dd>
	</dl>
</div>

    <!-- TODO(kbr): add example of ping-ponging ArrayBuffers between the main thread and a worker -->

	</section>
	<section id="resolved-issues">
<h2 title="Resolved Issues" id="11">11. 解決済みの論点</h2>

<dl >
	<dt>
<code>DataView</code> は、データの配列を読み取るためのメソッドを持つべきか？
<span lang="en">
Should DataView have methods for reading arrays of data?
</span></dt>
	<dd>
<p>
その種のメソッドは有用ではあるが、 API を小さく保つため，このバージョンの仕様には取り入れられない。
その種のメソッドは将来に委ねられる。
<span lang="en">
While such methods would be useful, they are not present in this version of the specification to reduce the API footprint. Such methods may be added in the future.
</span></p>
	</dd>
</dl>

	</section>
	<section id="references">
<h2 title="References" id="12">12. 参照文献</h2>

<dl>
	<dt id="refsECMA262">[ECMA-262]</dt>
	<dd>
<a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript Language Specification, 5th Edition</a>,
P. Lakshman and A. Wirfs-Brock, Editors. Ecma International, December 2009. Available at
http://www.ecma-international.org/publications/standards/Ecma-262.htm.</dd>

	<dt id="refsFILE">[FILEAPI]</dt>
	<dd>
<a href="http://www.w3.org/TR/FileAPI/">File API</a>,
A. Ranganathan, J. Sicking. W3C.
	</dd>

	<dt>[HTML]</dt>
	<dd>
<a href="http://html.spec.whatwg.org/multipage/">HTML</a>, I. Hickson. WHATWG.</dd>

	<dt id="refsIEEE754">[IEEE-754]</dt>
	<dd>
IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985). Institute of Electrical and Electronics Engineers, 1985.</dd>

	<dt>[WEBGL]</dt>
	<dd>
<a href="http://www.webgl.org/">WebGL Specification</a>, C. Marrin. Khronos.</dd>

	<dt>[WEBIDL]</dt>
	<dd>
<a href="http://heycam.github.io/webidl/">Web IDL</a>,
C. McCormack. W3C.
	</dd>

	<dt>[WEBMESSAGING]</dt>
	<dd>
<a href="http://html.spec.whatwg.org/complete/web-messaging.html">Web Messaging</a>, I. Hickson. WHATWG.</dd>

	<dt>[WEBSOCKETS]</dt>
	<dd>
<a href="http://w3c.github.io/websockets/">The WebSocket API</a>,
I. Hickson. W3C.
	</dd>

	<dt>[WEBWORKERS]</dt>
	<dd>
<a href="http://www.whatwg.org/specs/web-workers/current-work/">Web Workers</a>,
I. Hickson. WHATWG.
	</dd>

	<dt>[XMLHTTPREQUEST]</dt>
	<dd>
<a href="http://dev.w3.org/2006/webapi/XMLHttpRequest/">XMLHttpRequest</a>,
A. Kesteren. WHATWG.
	</dd>
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments" id="13">13. 謝辞</h2>

<p>
編集者は、この仕様に寄与された次の方々と WebGL working group のメンバの方々に感謝する：
</p>
<p >
The editors would like to thank Erik Arvidsson (Google), Joshua Bell (Linden Lab), Mark Callow (HI), Brendan Eich (Mozilla), Andreas Gal (Mozilla), Daniel Gessel (Apple), Dave Herman (Mozilla), Oliver Hunt (Apple), Tim Johansson (Opera), Vangelis Kokkevis (Google), Chris Marrin (Apple), Glenn Maynard, Cameron McCormack, Shiki Okasaka (Google), Arun Ranganathan (Mozilla), Alex Russell (Google), Gregg Tavares (Google), Ben Vanik (Google), Cedric Vivier (Mozilla), and the members of the WebGL working group for their contributions to this specification.
</p>
<p>
編集者は、この仕様の以前のバージョンで協同して編集を行った Vladimir Vukicevic に特に感謝する。
<span lang="en">
The editors would especially like to thank Vladimir Vukicevic for co-editing earlier versions of this specification.
</span></p>
	</section>

</main><!--  id="MAIN" -->

<!--% DATA SECTION -->
<div style="display:none;">

<input type="hidden" id="_page_config" value="" />

<script type="text/plain" id="replace_table">
バイト:byte
複バイト:multi-byte
バイトオフセット:byte offset
ソースバイト:source byte
	値:value
	参照:refer
	参照1:reference
	型:type
ビュー:view
配列:array
配列型:array type
データ:data
	作成:create
	利用-:use
	要素:element
	仕様:specification
バッファ:buffer
メソッド:method
プロパティ:property
型指定配列:typed array
型付き:typed
格納:store
格納域:storage
	終端:end
オブジェクト:object
クローン:clone
整数:integer
例外:exception
投出:raise
変換:conversion
変換-:convert
型変換:type conversion
オフセット:offset
サイズ:size
	定義:definition
	定義-:define
	始端:start
アクセス:access
	範囲:range
	表現-:represent
	表現:representation
転送:transfer
	transferring
符号付き:signed
符号なし:unsigned
	切り詰め:clamp
	読み取り:read
	読み取り専用:read-only
	規則:rule
構築子:constructor
	引数:arugument
任意選択:optional
省略可:optional
	省略:omit
バイナリデータ:binary data
バイナリ:binary
内容:content
	実行:run
	下層:underlying
	区間:section
インスタンス:instance
	構築時:construction time
	構築:construction
無力化:neuter
複製:copy
アラインメント:alignment
	拘束:constraint
コード:code
アルゴリズム:algorithm
	浮動小数点数:floats
	浮動小数点数:floating point
浮動小数点数:floating-point number
	浮動小数点数:floating-point number
浮動小数点データ:floating-point data
浮動小数点値:floating-point value
	負の:negative
パタン:pattern
整数値:integer 値
初期化:initialize
	保持:hold
定数:constant
補数:complement
インタフェース:interface
	固有の:specific
利用者エージェント:user agent
	座標成分値:coordinate value
	色成分値:color value
	手作業:manual
	構造:structure
	ゼロ:zero
	実装:implementation
	実装-:implement
	全域:entire
	設定子:setter
	一時バッファ: temporary buffer
	繰:2:
	節:section
有構造クローン:structured cloning
不可分的:atomic
サブクラス:subclass
	交替的:interleaved
バージョン:version
固定長:fixed-length
数値型:number type
整数型:integer type
データ域:chunk of data
	メモリ内構成:in-memory assembly
アーキテクチャ:architecture
ネイティブ:native
アドレス:address
</script>

</div>

</body>

</html>

<!--
big-endian
following次の
given 与えられ
index
little-endian
next 次の
point 単位の構造:per-point structure
points指す
same 同じ
transferring＊
〜の所から:starting at
それ以上必要とされなくなった:no longer needed
ふるまい:behavior
アクセサ:accessor 1
ウェブアプリケーション:web application 1
オーディオシステム:audio system 1
オーバヘッド:overhead 1
グラフィクスカード:graphics card 2
コンピュータ:computer 5
消費者コンピュータ機器:consumer computing devices 1
サポート:support 1
ディスク:disk 2
巨大なデータブロック:large blocks of data
ネットワーク:network 3
プロトコル:protocol 1
ファイル:file 3
プログラム:program 1
ペイロード:payload 1
ホストコンピュータ:host computer 5
ホストマシン:host machine 1
メインメモリ:main memory 3
メモリ:memory 2
モード:mode 1
ユースケース:use case 1
リスト:list 1
レベル:level 1
一定値に固定:fixed 5
一覧: 1
一貫:consistency 1
一貫性:consistent 1
一連の:group of
一部:some 2
上書き:overwritten
不可:-able 1
不正:incorrect 1
両方:both 2
丸めモード:rounding mode
代替:alternative 1
以上: 1
以下: 2
以外: 1
任意の: 7
伝統的:traditionally 1
位置: 3
低レベル:low-level
低速:slow 1
例:example 
依存して:depending on 1
依然として:still 1
便益:benefit 1
個数: 1
倍数:multiple 1
元:original
入出力タスク:input/output task
入力値:input value 1
入力数値:incoming number value 1
入力配列: 1
全体: 3
共通の情報:information shared among all of
内部的:internal 1
再利用:repurposed 1
再帰的:recursive 1
処理: 2
切り出す:carve out
利用可能:able to use 1
制限:limit 2
割り当て:allocate
区分:segment 1
区域:region 2
十分:enough 2
単独:single 1
単純:simple 2
即時に:immediately
参照文献:
取り扱い:handling
取得:fetch/get 4
取得子:getter 1
受信:receiving 1
古い:old
可能性: 1
同様: 2
呼び出し:call
図式:diagram 1
基本的に:Essentially/fundamentally 2
場合: 33
変数: 1
変更:modification 1
多義性:ambiguity 1
大きな:large
大多数:most 1
存在:exist 1
定義済みの:defined 1
実装者:implementors 1
実質的: 1
容認:acceptable 2
対応: 1
将来: 1
座標:coordinate 1
延長:extend 1
形式:format
影響しない:irrelevant 1
必要: 4
必須の要件:require 1
性能:performance characteristics 1
恩恵:benefit 1
成分:component 1
手法:method 1
手続き:steps
扱い:handling
指定:specify 13
指示-:indicate 7
推定:extrapolate 1
提供:provide 2
操作:manipulate 3
数値: 3
整数倍:multiple of 1
文脈:context 1
新たな:new
方法:way 1
既存:in existence 1
既定:default 1
明確に:clearly 1
明示的:explicit 2
普通:commonly 1
暗黙的:implicit 1
書き込む:write
最も近い:closest
最上位:most significant 1
最下位:least significant 1
最低:lowest 2
最初の:first 5
最小限:minimal set 1
最後に:finally
有効:valid 2
有無: 1
有用:useful 2
概観:overview 1
構成: 1
構築可能:built up 1
機能:feature/functionality 3
機能性:functionality 2
次節:next section 1
正負符号の有無:signedness 1
汎用の:generic 2
決定的に重要:critical 1
注意: 3
演算を行う:operates 4
特定: 1
特質:in nature 1
状況:situation 2
獲得:gain 1
現今:current 2
現代: 1
現在の:current 6
現時点:currently 2
理由: 1
用例:example 1
用意:reserve 1
用途:use cases 1
番目: 7
異なる:different
目的:target/purposes 2
直前:exclusive 2
直後:immediately following 1
直接的:directly 3
相違:difference 2
破棄:discarding 1
移動:skip 2
稼働: 1
符号化:encode 1
等価:equivalent 2
算出:compute 2
算術:arithmetic 2
節:section
結果:result 1
総称:generic term 1
編成:organize 1
置き換える:replace
義務付け:mandate 1
深い背景と考察:background and in-depth discussion
複数の:multiple
複数個:multiple 2
複数種: 1
複雑な:complex 1
要求:requested 3
規範規則:normative rule 1
解決済:resolved 1
解釈:interpret- 5
言語束縛:language binding 1
記述:description 1
設定: 3
設計:design 3
許容:allow 2
試行:attempt 1
語:term
説明:description 1
論点:issues 1
論説:article 1
追加:Add 1
追加の:additional 3
送信:sent 1
連続:consecutive 1
連続的:contiguous 2
連鎖:chaining 1
適切:appropriate 1
適用: 4
部分: 1
部分域:region 1
部分配列:sub-array 1
重ならない:not overlap
重ねられる:overlaying
重要:important 1
長さ:length
除き:except
雑多:heterogeneous 1
露になる:become apparent
非数値:not-a-number 1
高くつく:expensive
-->
