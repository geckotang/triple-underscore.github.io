<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Scoping Module Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style type="text/css">
.js-slot {
	color: green;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	var source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked 170825 spec
}

function expand(){
	var link_map = this.link_map;
	var class_map = {
		p: 'property', // prop
		ps: 'pseudo',
		pe: 'pseudo',
		css: 'css',
		e: 'element',
		a: 'attr',
		v: 'value',
		at: 'at-rule',
		f: 'func',
		t: 'type',
		sl: 'js-slot',
	};
	var tag_map = {
		I: 'code',
		m: 'code',
		p: 'code',
		ps: 'code',
		pe: 'code',
		at: 'code',
		t: 'var',
		css: 'code',
		e: 'code',
		a: 'code',
		v: 'code',
		f: 'code',
		c: 'code',
		sl: 'span',
	}

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'p': // property
	break;
case 'ps': // typedef
	text = ':' + key;
	break;
case 'pe': // typedef
	text = '::' + key;
	break;
case 't': // typedef
	text = '&lt;' + key + '&gt;';
	href= '#typedef-' + key;
	break;
case 'f': // func
	text = key + '()';
	break;
case 'v': // css values
	break;
case 'at': // css values
	text = '@' + key;
	break;
case 'e': // HTML element
	break;
case 'css': // css codes
	break;
case 'sl': // JS internal slot
	text = '[[' + key + ']]';
	break;
default:
//		console.log(match);
//	return match;
}


if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2017-08-25
trans_update:2017-09-01
page_state_key:CSS
original_url:https://drafts.csswg.org/css-scoping/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:selector,css
navs:issue
conformance:css
copyright:2017,permissive
trans_1st_pub:2017-09-01


●●original_id_map


●●words_table



	●slot／scope／node tree／shadow
host:::ホスト
shadow:
	shadowを貫く:shadow-piercing
light:::
	light木:light-tree
custom:::カスタム
slot:
slotable:
	slot-assigned
	slot-assignment
	at all slot-assignment levels
視野:scope::~:スコープ
視野付け:scoping::~:スコープ付け
視野付き:scoped::~:スコープ付き
文書:document::~
要素:element::~
文書片:document fragment::~
親:parent::~
子:child::~
子たち:children::~
先祖:ancestor::~
子孫:descendants::~
木:tree::~:ツリー
	木に留まる:tree-abiding
根:root::~:ルート
入子:nest:入れ子
貫く:pierce する::~
割当され:assign され::あてがわれ
割当する:assign する::あてがう
割当でき:assign でき::あてがえ
平坦:flat::~
平坦化-:flatten::~
	平坦化-法:flattening
境界:boundary:~
対象に:target:~
	対象にできない:untargettable
勝つ:win する:優先される
部品:component:~
型:type:~
局所:local:~
深い:deep な:~
	より深い:deeper
	-:pre-order

	●選択子／視野
規則:rule::~
	at-規則:at-rule
詳細度:specificity::~
選択-:select::~
	選択できない:unselectable
	選択-法:selecting
選択子:selector::~:セレクタ
複体:complex::~
合体:compound::~
結合子:combinator::~
無特色:featureless::~
	無特色:weird
疑似要素:pseudo-element::~
疑似類:pseudo-class::疑似クラス
照合-:match::~
	照合-法:matching
出自:origin::~
出自の:originating::~
合致-:match::~

	●CSS
CSS:
box:::ボックス
class:
cascade:::カスケード
	cascade法:cascading
flexbox:::
lay-out:lay out::レイアウト
node:::ノード
style:::スタイル
	styling
stylesheet:::スタイルシート
	stylesheet:sheet
block:::ブロック
文脈:context::~
宣言:declaration::~
継承-:inherit::~
継承:inheritance::~

静的:static::~
動的:dynamic::~

	●仕様
UA:user agent:UA
algo:algorithm::アルゴリズム
data-model:::データモデル
一般:general:~
一般的:general:~
事例:case:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
判定基準:criteria:~
効果:effect:~
	できるよう:possible
	不可能:impossible
概念:concept:~
標準:standard:~
	Standard:::
機能性:functionality:~
特別:special:~
特定0の:particular:ある特定の
特定の:specific:~
状況:situation:~
目的:purpose:~
能:ability:~
能力:capabilities:~
規範的:normative:~
	規範的でない:non-normative
説明:explanation:~
課題:issue:~
実施:practice:~
	方法:how:~
明白:obvious:~
明示的:explicit:~
暗黙的:implicit:~
有意:significant:~
適切:appropriate:~
通常の:normal な:~
作業草案:Working Draft:~
草案:draft:~
	we
	例:example:~
	先ず挙げられる:primary
	別の言い方をすれば:alternately
	特に:in particular
	理に適う:reasonable
	関わらず:regardless
	因り:due
	良くないことが起こる:very good
	~~素の:vanilla
	あいにく:unfortunately
	しかしながら:however
	べき:should
	困難:hard
	不都合:complaint
	capable
	complex
	idea
	informative
	概ね:loosely
	幸いなことに:luckily
	note
	関連する:relevant:~

	●仕様（動詞
debug:::デバッグ
予測-:predict:~
	予測できない:unpredictable:~
作者:author:~
	作者~level:author-level:~
依拠-:rely:~
利用:use:~
利用事例:use case:~
制約-:restrict:~
制限-:limit:~
取組む:address する:取り組む
理解-:understand:~

続行-:proceed:~
	要求ing:requiring:~
解釈-:interpret:~
許容-:allow:~
適用-:apply:~
関係-:relate:~
	関係する:related
関係性:relationship:~
偶発的:accidental:~
働く:work する:~
含意-:imply:~
変更点:changes:~
定義-:define:~
導入-:introduce:~
影響-:affect:~
意味-:mean:~
	意図:meant:~
意図的:intentional:~
所与の:given:~
拡張-:extend:~
指定-:specify:~
提供-:provide:~
有用:useful:~
期待-:expect:~
挙動:behavior:ふるまい
組込みの:built-in:組み込みの
援助-:aid:~
結付けら:associate さ:結び付けら
介入-:intervene:~
欲され:desire され:~
求めら:want さ:~
考慮点:considerations:~
実装-:implement:~
	単一化:single unified
	聞く:hear
	基づいて:based
	基づく:rebase
	扱-:treat
	必要がある:want
	知る:know:~
	把握-:grok:~
	~~編成し直す:reorg
	~~問題にはならない:matter
	任意選択で選ぶ:opt into
	力点を置いて:focusing
	-:remember
	利用できる:usable
	呼ばれる:call
	〜ないように:prevent
	試す:test する
	しようと:-try
	戸惑う／confusing
	見なさ:consider さ

	●未分類（動詞
表現-:represent:~
保護-:protect:~
保護:protection:~
上書き:override:~
付加-:append:~
作成-:create:~
到達-:reach:~
	到達できない:unreachable
	到達できる:reachable
制御:control:~
動作-:act:~
包含-:contain:~
	containing
埋める:fill する:~
埋込まれ:embed され:埋め込まれ
存在-:exist:~
応答-:respond:~
挿入-:insert:~
提示-:present:~
操作-:manipulate:~
改称-:rename:~
構築-:construct:~
構築:construction:~
比較-:compare:~
演算-:operate:~
生成-:generate:~
置換-:replace:~
見出され:find され:~
観測-:observe:~
	観測され得ない:observable:~
計算-:calculate:~
設定-:set:~
評価-:evaluate:~
走査-:traverse:~
走査:traversal:~
追加-:add:~
追加:addition:~
追加の:additional:~
遂行-:perform:~
遭遇-:encounter:~
除去-:remove:~
順序:order:~
	どうしの順序:relative ordering
順序付け:ordering:~
	内部~slot:private slot

	●未分類（動詞
優先-:prioritize:~
処理待ち:pending:~
包装-:wrap:~
	wrapper
	渡され:pass
	あてがう:assign
	与-:give:~
	含む:include
	含め:including
	現れる:appear
	-:attach
	called
	coming
	遮断-:disrupt:~
	後続-／:follow
	-:gain
	-:get
	名前:keyed with
	originating
	-:pop
	-:put
	made
	引き込む:pulled into
	居る:live
	できない:capable
	対応付ける:map する

	●未分類
DOM:
HTML:
	Scope
	Selector
	Shadow
call:
encapsulation:::カプセル化
index:::
level:::レベル
link:::リンク
list:::リスト
map:::
profile:::プロファイル
text:::テキスト
top-level:::トップレベル
window:::
markup:::マークアップ
group:::グループ
method:::メソッド
item:::アイテム
privacy:::プライバシー
security:::セキュリティ
再帰的:recursive:~
内容:content:~
初期:initial:~
名:name:~
名前:name:~
別名:alias:~
単純:simple:~
変種:variant:~
完全:complete:~
属性:attribute:~
既定:default:~
既定の:default:~
文法:grammar:~
構文:syntax:~
無効:invalid:~
関数形の:functional:~
	function
関数形:functional form:~
引数:argument:~
構造:structure:~
	直の:direct:~
種類:kind:~
空:empty:~
等価:equivalent:~

自動的:automatic:~
言語:language:~
page:::ページ
theme:::テーマ
色:color:~

	結果:result:~
	低い:low
	~~特性:qualities


	●指示語
新たな:new:~
普通は:ordinary には:~
普通の:ordinary:~
単独の:single:~
全部的:full:~
外側:outside:~
外縁:outer:~
内側:inside:~
内縁:inner:~
内部的:internal:~
現在の:current:~
	現在:currently:~
自前の:own:~

	最初の:first:~
	元の:original:~
	そこから:original:~
	全体:entire:~
	他の部分:the rest
	うち一部:some of
	そのような:such
	どこか:somewhere
	どこまでも:any number of
	一部:part of
	先に来る:earlier
	後に来る:coming later
	~slotに:downwards
	-:sort of
	ちょうど同じく:just as
	いくつかの:several#4
	すべて:all
	この:this
	これらの:these
	:that
	:they
	:their
	:those
	:them
	:themselves
	他の:other
	他の場合:otherwise
	代わり:instead
	依然として:still
	別々の:separate
	同じ:same
	同類:akin
	当の:in question
	最も外縁:outermost
	種々の:various
	異なる:different
	自身:itself
	複数の:multiple
	逆:opposite
	通:through
	遡る:on the way up
	個の:two ／three
	across
	against
	top
	nor
	一握りhandful
	higher
	later
	sole
	somewhat
	somewhere
	whichever
	より上位にある:lies〜 above
	より上位:higher up
	部分:part
	もっぱら:sole
	他:nobody else
	どうやっても:any way


●●words_table1


3GT:&gt;&gt;&gt;


●●link_map


I.Window:~WINDOW#window
at-規則:~CSSSYN#at-rule
at.font-face:~CSSFONT#at-ruledef-font-face
	#at-font-face-rule
m.querySelector():~DOM4#dom-parentnode-queryselector
sl.defaultElementStylesMap:#dom-window-defaultelementstylesmap-slot

e.slot:~HEscripting#the-slot-element
e.style:~HEmetadata#the-style-element

p.display:~CSSDISP#propdef-display

v.contents:~CSSDISP#valdef-display-contents

css.~3GT:#selectordef-shadow-piercing-descendant-combinator

pe.first-line:~CSSPSEUDO#selectordef-first-line
pe.slotted():#selectordef-slotted
ps.host():#selectordef-host-function
ps.host-context():#selectordef-host-context
ps.host:#selectordef-host

t.compound-selector-list:~SELECTORS#typedef-compound-selector-list
t.stylesheet:~CSSSYN#typedef-stylesheet

	●
~cascade:~CASCADE#cascade
子:~DOM4#concept-tree-child
	子たち:~DOM4#concept-tree-child
~custom要素:~DOM4#concept-element-custom
＊割当され$




複体~選択子:~SELECTORS#complex
合体~選択子:~SELECTORS#compound
の~list:~SELECTORS#list-of-simple-selectors
子孫:~DOM4#concept-tree-descendant
子孫~結合子:~SELECTORS#descendant-combinator
動的~profile:~SELECTORS#dynamic-profile
無特色:~SELECTORS#featureless
平坦化され:~DOM4#find-flattened-slotables
~slot用に平坦化された~slotableたちを見出す:~DOM4#find-flattened-slotables
~slot用に~slotableたちを見出す:~DOM4#find-slotables
平坦化された要素~木:#flat-tree
平坦~木:#flat-tree
断片~疑似要素:#fragment-pseudo-element
~host:~DOM4#concept-documentfragment-host
~shadow木の文脈~下:#in-the-context-of-a-shadow-tree
~light木:~DOM4#concept-light-tree
局所~名:~DOM4#concept-element-local-name
要素に対し選択子を照合-:~SELECTORS#match-a-selector-against-an-element
木に対し選択子を照合-:~SELECTORS#match-a-selector-against-a-tree

根:~DOM4#concept-tree-root
文書片:~DOM4#interface-documentfragment
	＊
選択子~合致-~list:#_selector-match-list
	＊選択子~合致-~list:~SELECTORS#selector-match-list
~shadowも含む先祖:~DOM4#concept-shadow-including-ancestor
~shadowも含む木~順序:~DOM4#concept-shadow-including-tree-order
~shadowを貫く子孫~結合子:#shadow-piercing-descendant-combinator
~shadow~host:~DOM4#element-shadow-host
~shadow根:~DOM4#concept-shadow-root
~shadow木:~DOM4#concept-shadow-tree
~slot:~DOM4#concept-slot
~slotable:~DOM4#concept-slotable
静的~profile:~SELECTORS#static-profile
木~文脈:#tree-context
型~選択子:~SELECTORS#type-selector

~UA出自:~CASCADE#cascade-origin-ua
詳細度:~SELECTORS#specificity
出自の要素:~SELECTORS#originating-element

cC.出自:~CASCADE#cascade-origin
cC.視野:~CASCADE#cascade-scope
cC.~shadow木:#_cascade-shadow-tree

	選択対象:~SELECTORS#selector-subject


●●spec_metadata



最新発行バージョン
	https://www.w3.org/TR/css-scoping-1/

編集者草案
	https://drafts.csswg.org/css-scoping/

以前のバージョン
	https://www.w3.org/TR/2014/WD-css-scoping-1-20140403/

テスト一式
	http://test.csswg.org/suites/css-scoping-1_dev/nightly-unstable/

最新の課題
	<a href="#issues-index">仕様内</a>
	<a href="https://github.com/w3c/csswg-drafts/labels/css-scoping-1">GitHub Issues</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)


●●ref_normative
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-DISPLAY-3]
    Elika Etemad. CSS Display Module Level 3. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-FONTS-4]
    John Daggett; Myles Maxfield. CSS Fonts Module Level 4. URL: https://www.w3.org/TR/css-fonts-4/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS3CASCADE]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 3. URL: https://www.w3.org/TR/css-cascade-3/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECTORS4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 2 May 2013. WD. URL: https://www.w3.org/TR/selectors4/


●●ref_informative
[CSS3-SELECTORS]
    Tantek Çelik; et al. Selectors Level 3. 29 September 2011. REC. URL: https://www.w3.org/TR/css3-selectors/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Scoping Module Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>

<body>

<header>
	<hgroup>
<h1 id="title">CSS Scoping Module Level 1</h1>
	</hgroup>

</header>


<div id="MAIN" style="display:none;">
	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、~CSSによる［
視野付け／~encapsulation
］の仕組みを，特に ~shadow~DOMの視野付け（ scoping ）に力点を置いて定義する。
◎
This specification defines scoping/encapsulation mechanisms for CSS, focusing on the Shadow DOM scoping mechanism.
</p>

~CSSisaLANG


	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
この節では、発行時点における…
これは編集者草案の公開の複製です…
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~UNSPECIFIED

	</section>
	<section id="default-element-styles">
<h2 title="Default Styles for Custom Elements">2. ~custom要素に対する既定の~style</h2>

<p>
`~custom要素$の定義-時には、それに対する
— 組込みの要素に適用される~UA~styleと同類の —
“既定の” ~styleを設定しておくよう求められることが多い。
あいにく，これを~~素の~CSSで行うのは、次の 2 点で困難である：
◎
When defining custom elements, one often wants to set up "default" styles for them, akin to the user-agent styles that apply to built-in elements. This is, unfortunately, hard to do in vanilla CSS, due to issues of scoping and specificity—＼
</p>

<ul>
	<li>
視野付けの課題：
当の要素は，`~shadow木$内で利用されるかもしれず、その場合，最も外縁の文書~内にある どの選択子からも、要素を対象にするべく到達できない。
◎
the element in question might be used in shadow trees, and thus is unreachable by any selector targeting it in the outermost document;＼
</li>
	<li>
詳細度の課題：
`型~選択子$の様な詳細度が低い選択子でも、当の要素を対象にするよう~~意図された作者~levelの~styleを，偶発的に上書きし得る。
◎
and selectors, even low-specificity ones like simple type selectors, can accidentally override author-level styles meant to target the element.
</li>
</ul>

<p>
これを援助するため、この節では，所与の要素に対し
“既定の要素~style”
を与える~stylesheetの作成-法を定義する。
この種の~stylesheetは、［
文書~全体, および すべての`~shadow木$内
］にわたって適用され、その中の各~規則は，作者~levelの規則が自動的に勝つように，`~UA出自$の下で適用される。
◎
To aid in this, this section defines a way to create a stylesheet of "default element styles" for a given element. This stylesheet applies across the entire document, in all shadow trees, and the rules in it apply at the user agent origin, so author-level rules automatically win.
</p>

<p>
各 `Window$I は、
`defaultElementStylesMap@sl
内部~slotを持つ
— それは、要素の`局所~名$を~stylesheetに対応付ける。
それらの~stylesheetは：
◎
Windows gain a private slot [[defaultElementStylesMap]] which is a map of local names to stylesheets.
</p>

<ul>
	<li>
<p>
~window内のどの文書にも適用され~MUST。
加えて，~UA~stylesheetとして解釈され~MUST。
◎
These stylesheets must apply to every document in the window. They must be interpreted as user agent stylesheets.
</p>

<p class="note">注記：
これは特に、各~文書ごとに，その中のすべての`~shadow木$に適用され、それらの中の宣言は`~UA出自$になることを含意する。
◎
Note: This implies, in particular, that they apply to all shadow trees in every document, and that the declarations in them are from the user agent origin.
</p>
	</li>
	<li>
`~cascade$の目的においては、~UAの自前の~stylesheetより後の順になる。
この種の~stylesheetどうしの順序は、観測され得ないので，~~問題にはならない。
◎
For the purpose of the cascade, these stylesheets are ordered after the user agent’s own stylesheets; their relative ordering doesn’t matter as it is not observable.
</li>
	<li>
その中の`複体~選択子$は、無効にされ~MUST。
◎
Within these stylesheets, complex selectors must be treated as invalid.＼
</li>
	<li>
その中の`合体~選択子$は、［［
要素のうち，その`局所~名$は `defaultElementStylesMap$sl 内で当の~stylesheetに対応付けられるもの
］を選択する，`型~選択子$
］が追加されているものと扱われ~MUST。
◎
Every compound selector must be treated as containing an additional type selector that selects elements with the local name that the stylesheet is keyed with.
</li>
</ul>

<p class="issue">
この種の~stylesheetに利用できる `at-規則$ を制約する必要はあるか？
例えば、 `font-face$at は許容されるか？
編集者は、とりあえず，何か不都合を
聞くまで／聞かない限り
は、許容したままにしておくことにする。
◎
Do we need to restrict the at-rules that can be used in these sheets? For example, do we allow an @font-face? I’m going to leave it as allowed unless/until I hear complaints.
</p>

<p>
この仕様は、
`defaultElementStylesMap$sl を［
追加する／除去する／一般に操作する
］方法は，定義しない。
そうするための仕方は、 `DOM$r などの他の仕様が定義するものと期待される。
◎
This specification does not define how to add to, remove from, or generally manipulate the [[defaultElementStylesMap]]. It is expected that other specifications, such as [DOM], will define ways to do so.
</p>

	</section>
	<section id="shadow-dom">
<h2 title="Shadow Encapsulation">3. ~shadowの~encapsulation</h2>

		<section id="shadow-gloss">
<h3 title="Informative Explanation of Shadow DOM">3.1. ~shadow~DOMの説明</h3>

~INFORMATIVE

<p>
この節では、この仕様が何を定義しているかを，~DOM標準 `DOM$r を全部的に把握せずに理解するのを援助するため、~DOMが規範的に定義しているいくつかの概念を説明する。
◎
The following is a non-normative explanation of several concepts normatively defined in the DOM Standard [DOM], to aid in understanding what this spec defines without having to fully grok the DOM Standard.
</p>

<p>
`SELECTORS4$r の <a href="~SELECTORS#data-model">~data-model節</a>
に定義される要素~木の各種~~特性に加え、~DOM標準は，`~shadow木$に関係するいくつかの新たな概念を追加している。
うちいくつかは~CSSにも関連する。
◎
In addition to the qualities of an element tree defined in Selectors Level 4 §data-model, the DOM Standard adds several new concepts related to shadow trees, several of which are relevant to CSS.
</p>

<p>
要素 %~host は、ある`~shadow木$ %~shadow木 を~hostすることもある
— その根である`~shadow根$ %~shadow根 は、特別な種類の`文書片$である（要素~nodeではない）。
%~shadow根 の子孫は、普通の要素その他の~nodeからなる。
%~host は、 %~shadow根 の`~host$であり，
【~shadow木を~hostする】`~shadow~host$になる。
◎
An element can host a shadow tree, which is a special kind of document fragment with a shadow root (a non-element node) at its root. Children of the shadow root are ordinary elements and other nodes. The element hosting the shadow tree is its host, or shadow host.
</p>

<p>
%~shadow木 内の要素は、一般に %~host の`子孫$とはされない（`子孫~結合子$の様な選択子の目的も含め）。
しかしながら， %~shadow木 は、 %~host が属する木
—  `~light木$ %~light木 —
における`平坦~木$の構築に利用される。
~CSSにおいては、この平坦~木が，選択子<em>より後の</em> すべて目的に（継承や~boxの構築なども含め）利用される。
◎
The elements in a shadow tree are not descendants of the shadow host in general (including for the purposes of Selectors like the descendant combinator). However, the shadow tree, when it exists, is used in the construction of the flattened element tree, which CSS uses for all purposes after Selectors (including inheritance and box construction).
</p>

<p>
%~shadow木 は、概ね，［
%~light木 における， %~host の通常の内容
］に代わって %~host の内容として扱われる。
しかしながら，［
%~light木 における %~host の子
］も、ある`~slot$ %~slot に割当されることにより， %~shadow木 の “中に引き込まれる” ことはある
— そのような子は、~CSSの目的においては %~slot の子として扱われる。
さらには、 %~slot も，より深い`~shadow木$内の`~slot$に割当されることもある。
幸いなことに どの`~slot$も，それ自身は
<a href="#slots-in-shadow-tree">既定では~boxを生成しない</a>
ので、
%~shadow木 を包装して~CSSを遮断している `slot$e 要素†の~cascadeを，作者が予測できなくなることはない。
【†~slotを作成できるのは、この型の要素に限られる。】
◎
Loosely, the shadow tree is treated as the shadow host’s contents instead of its normal light tree contents. However, some of its light tree children can be "pulled into" the shadow tree by assigning them to slots. This causes them to be treated as children of the slot for CSS purposes. The slots can then be assigned to slots in deeper shadow trees; luckily, slots themselves don’t generate boxes by default, so you don’t get an unpredictable cascade of slot wrapper elements disrupting your CSS.
</p>

<p>
`~slot$に何も明示的に割当されていない場合、代わりに `~slot$の自前の子たちが， “既定の” 内容として割当される。
◎
If nothing is explicitly assigned to a slot, the slot’s own children are instead assigned to it, as a sort of "default" contents.
</p>


		</section>
		<section id="selectors">
<h3 title="Shadow DOM and Selectors">3.2. ~shadow~DOMと選択子</h3>

			<section id="selectors-data-model">
<h4 title="Matching Selectors Against Shadow Trees">3.2.1. ~shadow木に対する選択子の照合-法</h4>

<p>
選択子が`~shadow木$に対し照合されるときの
`選択子~合致-~list@†
は、初期~時には，［
先頭の`~shadow~host$, および［
`~shadow木$の`~shadow根$
］の子孫すべて
］からなり、木~順序にされるとする。
<!-- ordered by a pre-order traversal -->
◎
When a selector is matched against a shadow tree, the selector match list is initially the shadow host, followed by all children of the shadow tree’s shadow root and their descendants, ordered by a pre-order traversal.
</p>

<p class="trans-note">【†
この用語は、 `SELECTORS4$r 仕様に定義されていたが，現在は廃され、照合する方法も含め，別の形で表現されている。
ここの, およびこの用語を参照している記述は、更新される必要がある。
】</p>

<p class="note">注記：
`~shadow木$は、要素の子孫には含まれない
— 要素の子孫は、`~light木$内の，要素の`子$に基づく。
◎
Note: Remember that the descendants of an element are based on the light tree children of the element, which does not include the shadow trees of the element.
</p>

<p>
`木に対し選択子を照合-$するときの
`木~文脈@
は、［
その~algoに渡される %根~要素
］の`根$で与えられる。
`木~文脈$が`~shadow根$であるとき、選択子は
`~shadow木の文脈~下@
で照合されてるという。
◎
When a selector is matched against a tree, its tree context is the root of the root elements passed to the algorithm. If the tree context is a shadow root, that selector is being matched in the context of a shadow tree.
</p>

<div class="example">
<p>
例えば、ある~stylesheetが，`~shadow木$内の［
要素~内に埋込まれて／
要素から~linkされて
］いるとき，その~stylesheet内のどの選択子も，`~shadow木の文脈~下$にある。
`~shadow根$上で~callされる `querySelector()$m に渡す選択子~引数も同様になる。
◎
For example, any selector in a stylesheet embedded in or linked from an an element in a shadow tree is in the context of a shadow tree. So is the argument to querySelector() when called from a shadow root.
</p>

</div>

<p>
宣言~block内の各~宣言は、それを適用するために照合した選択子の`木~文脈$を継承する。
◎
Declarations inherit the tree context of the selector that was matched to apply them.
</p>



			</section>
			<section id="host-element-in-tree">
<h4 title="Selecting Shadow Hosts from within a Shadow Tree">3.2.2. ~shadow木の中から~shadow~hostを選択するとき</h4>

<p>
`~shadow~host$ %~host は、それが~hostする`~shadow木$ %~shadow木 の外側にあるので、普通は，`~shadow木の文脈~下$で評価される選択子からは対象にできないが（選択子を照合する対象は，単独の木に制限される）、 %~shadow木 の文脈の内側からも， %~host を~styleできれば有用になることもときどきある。
◎
A shadow host is outside of the shadow tree it hosts, and so would ordinarily be untargettable by any selectors evaluated in the context of the shadow tree (as selectors are limited to a single tree), but it is sometimes useful to be able to style it from inside the shadow tree context.
</p>

<ul>
	<li>
選択子の目的においては、 %~host も
— その子たちが %~shadow木 の内容であるものと扱うように —
%~shadow木 に現れる（言い換えれば、 %~host は，`~shadow根$
—  %~shadow木 の根 — 
を置換するものとして扱われる）
◎
For the purpose of Selectors, a shadow host also appears in its shadow tree, with the contents of the shadow tree treated as its children. (In other words, the shadow host is treated as replacing the shadow root node.)
</li>
	<li>
%~host は、 %~shadow木 の中では，`無特色$であると見なされ、合致し得る選択子は［
`host$ps ／ `host()$ps ／ `host-context()$ps
］疑似類に限られる。
◎
When considered within its own shadow trees, the shadow host is featureless. Only the :host, :host(), and :host-context() pseudo-classes are allowed to match it.
</li>
</ul>

<details class="note">
<summary>注記：
なぜ~shadow~hostは`無特色$にされているのか ？
◎
Why is the shadow host so weird?
</summary>

<p>
%~shadow木 の外側に居る %~host の~markupは、
【~shadow木を内容とする】部品の作者ではなく，~page作者の制御~下にある。
◎
The shadow host lives outside the shadow tree, and its markup is in control of the page author, not the component author.
</p>

<p>
この部品が、 %~shadow木 内の~stylesheet内で，特定0の~class名を内部的に利用しているとする。
そのような部品を利用している~page作者が，同じ~class名を偶発的に %~host に利用した場合、良くないことが起こる。
そのような状況の結果，
【その~class名を選択する選択子を通して，~hostに】
偶発的にあてがわれる~styleは、部品~作者には予測-不可能であり，~page作者も~debugに戸惑うことになる。
◎
It would not be very good if a component used a particular class name internally in a shadow tree stylesheet, and the page author using the component accidentally also used the the same class name and put it on the shadow host. Such a situation would result in accidental styling that is impossible for the component author to predict, and confusing for the page author to debug.
</p>

<p>
しかしながら、 %~shadow木 内の~stylesheetが， %~host に~styleをあてがうことが理に適う利用事例も依然としてある（例えば，その部品は~flexboxとして~lay-outするよう求められている場合、 %~host の `display$p を設定することが要求される）。
なので、この状況を許容しつつ，~styleが偶発的にあてがわれないようにするため、 %~host は %~shadow木 には現れるが、完全に`無特色$で，選択するためには部品~作者が明示的に［
`host$ps, あるいは `host()^ps, `host-context()^ps
］を通して~markupに合致させる他ないようにされている。
◎
However, there are still some reasonable use-cases for letting a stylesheet in a shadow tree style its shadow host. (For example, the component might want to be laid out as a flexbox, requiring the shadow host to be set to display: flex.) So, to allow this situation but prevent accidental styling, the shadow host appears but is completely featureless and unselectable except through :host and its related functional forms, which make it very explicit when you’re trying to match against markup provided by the page author.
</p>

</details>

			</section>
			<section id="host-selector">
<h4 title="Selecting Into the Light: the :host, :host(), and :host-context() pseudo-classes">3.2.3.  ~light木の中への選択-法： `host^ps, `host()^ps, `host-context()^ps 疑似類</h4>

<p>
`host@ps
疑似類は、`~shadow木の文脈~下$では，当の`~shadow木$を~hostしている`~shadow~host$に合致するように評価され、他の文脈~下では，何にも合致しない。
◎
The :host pseudo-class, when evaluated in the context of a shadow tree, matches the shadow tree’s shadow host. In any other context, it matches nothing.
</p>

<p>
関数形の疑似類
`host()@ps
の構文は、次で与えられる：
◎
The :host() function pseudo-class has the syntax:
</p>

<pre class="prod">
:host( `compound-selector-list$t )
</pre>

<p>
それは、`~shadow木の文脈~下$では，当の`~shadow木$を~hostしている`~shadow~host$であって, かつ［
通常の文脈~下で引数の選択子（`合体~選択子$`の~list$）にも合致する
］ものに合致するように評価される。
他の文脈~下では，何にも合致しない。
◎
When evaluated in the context of a shadow tree, it matches the shadow tree’s shadow host if the shadow host, in its normal context, matches the selector argument. In any other context, it matches nothing.
</p>

<div class="example">
<p>
例えば、次の様な`~shadow木$を伴う部品があるとするとき：
◎
For example, say you had a component with a shadow tree like the following:
</p>

<pre class="lang-ml">
&lt;x-foo class="foo"&gt;
  &lt;“~shadow木”&gt;
    &lt;div class="foo"&gt;...&lt;/div&gt;
  &lt;/&gt;
&lt;/x-foo&gt;
</pre>

<p>
`~shadow木$の中の~stylesheetにおいては：
◎
For a stylesheet within the shadow tree:
</p>

<ul>
	<li>
`host$ps は、 `x-foo^e 要素に合致する。
◎
:host matches the &lt;x-foo&gt; element.
</li>
	<li>
`x-foo^css は、何にも合致しない。
◎
x-foo matches nothing.
</li>
	<li>
`.foo^css は `div^e 要素のみに合致する。
◎
.foo matches only the &lt;div&gt; element.
</li>
	<li>
`.foo:host^css は、何にも合致しない
— `.foo^css は `x-foo^e 要素に合致しないので。
◎
.foo:host matches nothing
</li>
	<li>
`:host(.foo)^css は、 `x-foo^e 要素に合致する
— 引数の `.foo^css も合致するので。
◎
:host(.foo) matches the &lt;x-foo&gt; element.
</li>
</ul>

</div>

<p>
`~shadow木$の中の選択子からは、普通は，`~shadow木$の外側にある要素は全く見えない。
しかしながら、~shadow木の外側のどこか, 同じ文書~内の, より上位にある先祖を選択できると有用になることもときどきある。
◎
Ordinary, selectors within a shadow tree can’t see elements outside the shadow tree at all. Sometimes, however, it’s useful to select an ancestor that lies somewhere outside the shadow tree, above it in the document.
</p>

<div class="example">

<p>
例えば、一群の部品からなる~groupは、それぞれがどう応答するか知る，一握りの色~themeを定義することもある
— ~page作者が、［
それらの部品または, 文書~内のより上位
］に特定の~classを追加して，特定0の~themeを任意選択で選べるような。
◎
For example, a group of components can define a handful of color themes they they know how to respond to. Page authors could opt into a particular theme by adding a specific class to the components, or higher up in the document.
</p>

<p class="trans-note">【
すなわち、部品を内容に含ませている先祖にあてがわれた~classに応じて、利用する色~theme（部品どうしや, その内部の構成子たちの色合いが調和するように設計された，色の集合）を切り替える。
】</p>

</div>

<p>
関数形の疑似類
`host-context()@ps
は、`~shadow木$の外側に［
特定0の選択子に合致するような先祖
］があるかどうか試す。
その構文は、次で与えられる：
◎
The :host-context() functional pseudo-class tests whether there is an ancestor, outside the shadow tree, which matches a particular selector. Its syntax is:
</p>

<pre class="prod">
:host-context( `compound-selector-list$t )
</pre>

<p>
`host-context()$ps
疑似類は、`~shadow木の文脈~下$では，［
当の~shadow木を~hostしている`~shadow~host$, または その`~shadowも含む先祖$
］のうち［
通常の文脈~下で引数の選択子（`合体~選択子$`の~list$）に合致する
］ものに合致するように評価される。
他の文脈~下では，何にも合致しない。
◎
When evaluated in the context of a shadow tree, the :host-context() pseudo-class matches the shadow host, if the shadow host or one of its shadow-including ancestors matches the provided &lt;compound-selector-list&gt;. In any other context, it matches nothing.
</p>

<p class="note">注記：
これは、当の選択子は、［
文書の根に到達するか, 引数に合致する要素が見つかる
］まで，~shadow境界を貫くように遡ることを意味する。
◎
Note: This means that the selector pierces through shadow boundaries on the way up, looking for elements that match its argument, until it reaches the document root.
</p>

			</section>
			<section id="slotted-pseudo">
<h4 title="Selecting Slot-Assigned Content: the ::slotted() pseudo-element">3.2.4. ~slotに割当された内容の選択-法： `slotted()^pe 疑似要素</h4>

<p>
`slotted()@pe
疑似要素は、`平坦化され$た上で`~slot$に割当された要素たちを表現する。
この疑似要素は：
◎
The ::slotted() pseudo-element represents the elements assigned, after flattening, to a slot.＼
</p>

<ul>
	<li>
`~slot$上にのみ存在する。
【すなわち、当の~slotが，この疑似要素の`出自の要素$になる。】
◎
This pseudo-element only exists on slots.
</li>
	<li>
当の木~内の他の要素を指す<em>別名</em>であり、それ自体は~boxを生成しない。
◎
The ::slotted() pseudo-element is an alias for other elements in the tree, and does not generate any boxes itself.
</li>
	<li>
<p>
その文法は、次で与えられる：
◎
The grammar of the ::slotted() pseudo-element is:
</p>

<pre class="prod">
::slotted( `compound-selector-list$t )
</pre>

	</li>
	<li>
<p>
次をいずれも満たす要素を表現する：
◎
The ::slotted() pseudo-element represents the elements that are:
</p>

		<ul>
			<li>
`平坦化され$て［
`slotted^pe の`出自の要素$である`~slot$
］に割当されている。
◎
assigned, after flattening, to the slot that is ::slotted’s originating element
</li>
			<li>
`要素に対し選択子を照合-$した結果、引数の `compound-selector-list$t （`合体~選択子$`の~list$）に合致する。
◎
matched by its &lt;compound-selector-list&gt; argument
</li>
		</ul>
	</li>
	<li>
<span class="css">`slotted()^pe`before^pe</span>
の様に，
<a href="~CSSPSEUDO#tree-abiding">木に留まる疑似要素</a>
を後続させれる
— それは、 `slotted()$pe 疑似要素により表現される要素を`出自の要素$とする適切な疑似要素を表現する。
◎
The ::slotted() pseudo-element can be followed by a tree-abiding pseudo-element, like ::slotted()::before, representing the appropriate pseudo-element of the elements represented by the ::slotted() pseudo-element.
</li>
</ul>

<div class="example">
<p>
例えば、次の様な［
子たち, および~shadow木
］を伴う部品があるとする：
◎
For example, say you had a component with both children and a shadow tree, like the following:
</p>

<pre class="lang-ml">
&lt;x-foo&gt;
  &lt;div id="one" slot="foo" class="foo"&gt;...&lt;/div&gt;
  &lt;div id="two" slot="foo"&gt;...&lt;/div&gt;
  &lt;div id="three" class="foo"&gt;
    &lt;div id="four" slot="foo"&gt;...&lt;/div&gt;
  &lt;/div&gt;
  &lt;“~shadow木”&gt;
    &lt;div id="five"&gt;...&lt;/div&gt;
    &lt;div id="six"&gt;...&lt;/div&gt;
    &lt;slot name="foo"&gt;&lt;/slot&gt;
  &lt;/&gt;
&lt;/x-foo&gt;
</pre>

<p>
`~shadow木$の中の~stylesheetにおいては、選択子 `::slotted(*)^css は，［
`#one^css, `#two^css
］のみを選択する
— それらはもっぱら `slot$e 要素に
<a href="~DOM4#find-flattened-slotables">割当される要素</a>なので。
それは、 `slot^a 属性を有さない `#three^css は選択しない。
また、 `#four^css も選択しない（ `~slot$に割当される~nodeは、`~shadow~host$の（直の）`子$に限られるので）。
◎
For a stylesheet within the shadow tree, a selector like ::slotted(*) selects #one and #two only, as they’re the elements assigned to the sole slot element. It will not select #three (no slot attribute) nor #four (only direct children of a shadow host can be assigned to a slot).
</p>

<p>
一方で， `::slotted(.foo)^css の様な選択子は、［
`#one^css, `#two^css
］のうち `.foo^css に合致する前者のみを選択する。
◎
A selector like ::slotted(.foo), on the other hand, will only select #one, as it matches .foo, but #two doesn’t.
</p>

<p class="note">注記：
`::slotted(*)^css
の様な選択子は、
`*::slotted(*)^css と等価になる
— 先頭の `*^css は、 `slot$e 要素の他にも多数の要素を選択するが、`~slot$になるのは `slot$e 要素に限られるので，合致するのは `slotted()$pe 疑似要素に合致する要素に限られる。
◎
Note: Note that a selector like ::slotted(*) is equivalent to *::slotted(*), where the * selects many more elements than just the slot element. However, since only the slot elements are slots, they’re the only elements with a ::slotted() pseudo-element as well.
</p>

</div>

<p class="note">注記：
`~slot$には~text~nodeも割当できるが、それらは `slotted()$pe では表現されないので，選択できない。
そのような~text~nodeに~styleをあてがう仕方は、 `~slot$に~styleをあてがった上で，継承に依拠する他にない。
◎
Note: ::slotted() can only represent the elements assigned to the slot. Slots can also be assigned text nodes, which can’t be selected by ::slotted(). The only way to style assigned text nodes is by styling the slot and relying on inheritance.
</p>

			</section>
			<section id="deep-combinator">
<h4 title="Selecting Through Shadows: the &gt;&gt;&gt; combinator">3.2.5. ~shadowを貫く選択-法： `~3GT^css 結合子</h4>

<p>
選択子~内にて，結合子
`~3GT@css
（
`~shadowを貫く子孫~結合子@
とも呼ばれる）に遭遇したときは、`選択子~合致-~list$内の各 要素を，そこから子~listや~shadow木をどこまでも走査して到達できるような要素たちに置換する。
◎
When a &gt;&gt;&gt; combinator (or shadow-piercing descendant combinator) is encountered in a selector, replace every element in the selector match list with every element reachable from the original element by traversing any number of child lists or shadow trees.
</p>

<div class="example">
<p>
例えば、次の様な`~shadow木$からなる部品があるとする：
◎
For example, say you had a component with a shadow tree like the following:
</p>

<pre class="lang-ml">
&lt;x-foo&gt;
  &lt;“~shadow木”&gt;
    &lt;div&gt;
      &lt;span id="not-top"&gt;...&lt;/span&gt;
    &lt;/div&gt;
    &lt;span id="top"&gt;...&lt;/span&gt;
    &lt;x-bar&gt;
      &lt;“~shadow木”&gt;
        &lt;span id="nested"&gt;...&lt;/span&gt;
      &lt;/&gt;
    &lt;/x-bar&gt;
  &lt;/&gt;
&lt;/x-foo&gt;
</pre>

<p>
外縁~文書~内の~stylesheetに対しては、選択子 `x-foo ~3GT span^css は、 3 個すべての `span^e 要素
— `#top^css, `#not-top^css, `#nested^css —
を選択する。
◎
For a stylesheet in the outer document, the selector x-foo &gt;&gt;&gt; span selects all three of &lt;span&gt; elements: #top, #not-top, and #nested.
</p></div>

<p>
`~shadowを貫く子孫~結合子$は、選択子の`静的~profile$の一部であり，`動的~profile$には含まれない。
このことは、例えば `querySelector()$m ~methodでは利用できるが，~stylesheet内では無効になることを意味する。
◎
The shadow-piercing descendant combinator is part of the static profile of Selectors, not the dynamic profile. This means that it is usable in, for example, the querySelector() method, but is invalid when used in stylesheets.
</p>



			</section>
		</section>
		<section id="shadow-cascading">
<h3 title="Shadow Trees and the Cascade">3.3. ~shadow木と~cascade</h3>

<p>
~shadow根~内の要素たちを対象にしている規則の~cascade法に欲される挙動に取組むため、この仕様は，
`CSS3CASCADE$r に定義される
<a href="~CASCADE#cascading">~cascade順序</a>
を拡張する。
◎
To address the desired cascading behavior of rules targetting elements in shadow roots, this specification extends the cascade order defined in the Cascade specification. [CSS3CASCADE]
</p>

<p>
`出自$cCと`視野$cCとの合間に，次の~cascade判定基準が追加され~MUST：
◎
An additional cascade criteria must be added, between Origin and Scope, called Shadow Tree.
</p>

<dl>
	<dt>`~shadow木@cC</dt>
	<dd>
`木~文脈$が互いに異なる 2 つの宣言を比較するときは、通常の規則に対しては，`~shadowも含む木~順序$において，先に来る
【実質的には、より先祖の木に属する】
宣言が勝つ。
`!important^css 規則に対しては、逆に，後に来る宣言が勝つ。
◎
When comparing two declarations that have different tree contexts, then for normal rules the declaration earlier in the shadow-including tree order wins, and for important rules the declaration coming later in the shadow-including tree order wins.
</dd>
	<dd class="note">注記：
これは、視野付き~styleに対する場合と【先祖, 子孫の順位が】<em>逆になる</em>。
◎
Note: This is the opposite of how scoped styles work.
</dd>
</dl>


		</section>
		<section id="flattening">
<h3 title="Flattening the DOM into an Element Tree" data-algorithm="Flattening the DOM into an Element Tree">3.4. ~DOMから要素~木への平坦化-法</h3>

<p>
選択子は，~host言語が提示する~DOM木に対し演算するが、~CSSの他の部分が［
標準の 親／`子$ 関係性を介しては到達できない，別々の木
］に働くためには、単一化された木~構造が必要になる。
これは、
`平坦化された要素~木@
（略して，`平坦~木$）と呼ばれ，次に従って構築される
【この “平坦化-” は、要素の入子ではなく，木の入子を平坦化することを表す。】
：
◎
While Selectors operates on the DOM tree as the host language presents it, with separate trees that are unreachable via the standard parent/child relationship, the rest of CSS needs a single unified tree structure to work with. This is called the flattened element tree (or flat tree), and is constructed as follows:
</p>

<ol>
	<li>
%根 ~LET 文書の`根$要素
◎
↓</li>
	<li>
%処理待ち~node~list ~LET 空~list
— この~listは、 ( `~node^i, `親^i ) の組として与えられる~itemたちで拡充されることになる
◎
Let pending nodes be a list of DOM nodes with associated parents,＼
</li>
	<li>
%処理待ち~node~list に ( %根, ε ) を付加する
◎
initially containing just the document’s root element with no associated parent.
</li>
	<li>
%平坦~木 ~LET ε
◎
↓</li>
	<li>
<p>
~WHILE %処理待ち~node~list は空でない：
◎
Repeatedly execute the following substeps until pending nodes is empty:
</p>

		<ol>
			<li>
%~item ~LET %処理待ち~node~list の最初の~item
◎
↓</li>
			<li>
%処理待ち~node~list から %~item を除去する
◎
Pop the first element from pending nodes, and assign it to pending node.
</li>
			<li>
%~node ~LET %~item の `~node^i
◎
↓</li>
			<li>
~IF［
%平坦~木 ~NEQ ε
］
⇒
%~node を，%~item の `親^i の`子$として %平坦~木 の中に挿入する
◎
Insert pending node into the flat tree as a child of its associated parent.＼
</li>
			<li>
~ELSE
⇒
%平坦~木 ~SET %根 を根とする， %根 のみからなる新たな`平坦~木$
◎
(If it has no associated parent, it’s the document root—just insert it into the flat tree as its root.)
</li>
			<li>
<p>
~IF［
%~node は`~shadow~host$である
］：
◎
Perform one of the following, whichever is the first that matches:
◎
pending node is a shadow host
</p>
				<ol>
					<li>
%~node が~hostしている`~shadow木$の`~shadow根$の
~EACH ( %子~node ) に対し
⇒
( %子~node, %~node )
を %処理待ち~node~list に付加する
◎
Append the child nodes of the shadow root of the shadow tree it hosts to pending nodes, with pending node as their associated parent.
</li>
					<li>
~CONTINUE
</li>
				</ol>
			</li>
			<li>

<p>
~IF［
%~node は`~slot$である
］：
</p>
				<ol>
					<li>
%~slotable~list ~LET `~slot用に~slotableたちを見出す$( %~node )
</li>
					<li>
<p>
~IF［
%~slotable~list は空でない
］：
</p>

<ol><li>%~slotable~list 内の ~EACH( %~slotable ) に対し
⇒
( %~slotable, %~node )
を %処理待ち~node~list に付加する
</li><li>~CONTINUE
</li></ol>
					</li>
				</ol>
◎
pending node is a slot
◎
Find slotables for pending node, and append them to pending nodes, with pending node as their associated parent.
◎
↓If no slotables were found for pending node, instead append its children to pending nodes, with pending node as their associated parent.
</li>
			<li>
%~node の~EACH( （`~light木$における）`子$ %子 ) に対し
⇒
( `子$, %~node ) を %処理待ち~node~list に付加する
◎
Otherwise,
◎
Append the child nodes of pending node’s light tree to pending nodes, with pending node as their associated parent.
</li>
		</ol>
	</li>
</ol>

<div class="note">
<p>注記：
言い換えれば、`平坦~木$は~top-level~DOM木であるが：
</p>
<ul>
	<li>
各`~shadow~host$は、その`~light木$内の子たちに代わって，`~shadow木$内の子たちで埋められる（更に，その`~shadow木$も`~shadow~host$を包含するならば，これを再帰的に続行する）
</li>
	<li>
各`~slot$は、それに割当された~nodeたちで埋められる（更に，`~slot$自身が より深い`~shadow木$内の`~slot$が割当されたなら，これを再帰的に続行する）。
</li>
</ul>
◎
Note: In other words, the flat tree is the top-level DOM tree, but shadow hosts are filled with their shadow tree children instead of their light tree children (and this proceeds recursively if the shadow tree contains any shadow hosts), and slots get filled with the nodes that are assigned to them (and this proceeds recursively if the slots are themselves assigned to a slot in a deeper shadow tree).
</div>

<p class="issue">
これによる明白でない結果は、~slotに割当された要素は、その~slotから【~styleを】継承することである
— 要素の~light木における親や, その~slotが割当されている より深い~slotでなく。
このことは、【~slotに割当された】~text~nodeは、その親の~shadow木により~styleされ，他からはどうやっても介入できないことを意味する。
そのような~text~nodeを対象にする追加の疑似要素は，求められるか？
— それらにも，要素のときと同様に at all slot-assignment levels【？】で~styleできるように。
このことは、~light木~内の~text~nodeに対しても，~slotに<!-- downwards -->割当される前に，そのような疑似要素が働く必要があることを含意する。
なので、これは，ただの `slotted()$pe の変種にはなり得ない。
Luckily, this is a long-standing request!【何が Luckily？】
◎
A non-obvious result of this is that elements assigned to a slot inherit from that slot, not their light-tree parent or any deeper slots their slot gets assigned to. This means that text nodes are styled by the shadow tree of their parent, with nobody else capable of intervening in any way. Do we want an additional pseudo-element for targeting those text nodes so they can be styled at all slot-assignment levels, like normal elements can be? This implies it needs to work for text nodes in the light tree before they’re assigned downwards, so this can’t just be a ::slotted() variant. Luckily, this is a long-standing request!
</p>



			<section id="slots-in-shadow-tree">
<h4 title="Slots and Slotted Elements in a Shadow Tree">3.4.1. ~shadow木~内の~slotとそれに割当される要素</h4>

<p>
`~slot$は、［
`~UA出自$内の規則を介して，その `display$p に `contents$v があてがわれている
］かのように動作し~MUST。
これは、 `display$p を介して上書きできるようにされ~MUST
— 欲されるときには、`~slot$が<em>~boxを生成できる</em>よう。
◎
Slots must act as if they were assigned display: contents via a rule in the UA origin. This must be possible to override via display, so they do generate boxes if desired.
</p>

<p class="trans-note">【
これは， `HTML$r では、~UA~stylesheetの
`slot{ display: contents }^css
規則として
<a href="~HTMLrendering#flow-content-3">実装されている</a>。
】</p>


<p class="note">注記：
`~slot$に要素を割当することによる明白でない結果は、要素は，その`~slot$から【~styleを】継承することである。
［
要素の親（`~light木$における要素の元の親）
］／［
その`~slot$もまた 他の`~slot$に割当されたとするときの，他の`~slot$
］は、継承には影響しない。
◎
Note: A non-obvious result of assigning elements to slots is that they inherit from the slot they’re assigned to. Their original light tree parent, and any deeper slots that their slot gets assigned to, don’t affect inheritance.
</p>



			</section>
		</section>
	</section>
	<section id="changes">
<h2 title="Changes">4. 変更点</h2>

<p>
<a href="https://www.w3.org/TR/2014/WD-css-scoping-1-20140403/">2014 年 4 月 3 日付 作業草案</a>
からの有意な変更点は：
◎
The following significant changes were made since the 3 April 2014 Working Draft.
</p>

<ul>
	<li>
`content^pe を `slotted^pe に改称した。
◎
Renamed ::content to ::slotted.
</li>
	<li>
`平坦化された要素~木$を定義した。
◎
Define the flattened tree
</li>
	<li>
Shadow DOM 節を，現在の `DOM$r に基づくように~~編成し直した。
◎
Generally reorg and rebase the Shadow DOM section on top of current DOM.
</li>
	<li>
`scope^at, `region^pe
に関係するものを次の~levelの草案まで先送りにした。
◎
Punt @scope and related things, and ::region and related things, to the next level of the draft.
</li>
</ul>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">5. ~privacyと~security上の考慮点</h2>

<p>
この仕様は Shadow DOM および，ある~shadowを貫く能力を導入するが、それが何らかの［
~privacy／~security
］に課題を導入することはない
—  現在の~shadow ~DOMは、そのような境界にならないよう，意図的に指定されているので（また、
~UAの［
~shadow~DOMを利用する ／
そのような境界が<em>ある</em>
］部分は、暗黙的に未だ指定されていない保護に依拠している
— それはそれらをこの仕様にて定義されるものから保護する【？】
）。
◎
This specification introduces Shadow DOM and some shadow-piercing capabilities, but this does not introduce any privacy or security issues—shadow DOM, as currently specified, is intentionally not a privacy/security boundary (and the parts of the UA that use shadow DOM and do have a privacy/security boundary implicitly rely on protections not yet specified, which protect them from the things defined in this specification).
</p>

	</section>


<!-- 
<h2 title="Acknowledgments">謝辞</h2>
-->

</main></div>
