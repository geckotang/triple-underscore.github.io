<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Streams Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script >
var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://streams.spec.whatwg.org/',
		main: 'MAIN',
		ref_data: '.ref_data',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};

	if(expanded){
		var e = E('_optional_controls');
		if(e) {
			e.parentNode.removeChild(e);
		}
		return options;
	}

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:英語+漢字:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);


/*
	Util.del_j(); // checked: 170310 spec
	repeat('h4', function(e){
		e.appendChild(document.createTextNode(' ' + e.className));
	})
*/


	return options;
}


function expand(mapping1){
	var link_map = this.link_map;
	var nesting = ''
	var class_map = {
		l: 'literal',
		b: 'es', // ES 値
		A: 'abstract', // 抽象演算
		Ax: 'abstract', // TC39
		I: 'interface', // interface
		C: 'interface', // interface class
	}
	var tag_map = {
		l: 'code',
		b: 'b',
		i: 'i',
		c: 'code',
		rs: 'code',
		dr: 'code',
		dw: 'code',
		ws: 'code',
		byob: 'code',
		rbsc: 'code',
		rsdc: 'code',
		wsdc: 'code',
		C: 'code',
		I: 'code',
		A: 'span',
		Ax: 'span',
		v: 'var',
	}

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|【.*?】|◎[^<◎`]*|%[\u4E00-\u9FFF~\w\-]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	return;

	function create_html(match, key, indicator, klass){
if(!indicator) {
	switch(match[0]){
	case '%' :
		return '<var>' + match.slice(1) + '</var>';
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
		break;
	case '【':
		return '<span class="trans-note">' + match + '</span>';
	default: //◎
		var result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
		nesting = '';
		return result;
	}
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'l': //
	text = '"' + key + '"';
	break;
case 'Ax':
	href = '~TC39#sec-' + key.toLowerCase();
	break;
case 'A':
	href = '#' + key.replace(/BYOB/g, "-byob-").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
//	href = '#_AO-' + key;
case 'c': //
case 'rs':
case 'ws':
case 'dr':
case 'dw':
case 'rsdc':
case 'wsdc':
case 'byob':
case 'rbsc':
	var i = key.indexOf('(');
	if(i > 0) {
		key = key.slice(0, i);
		text = key + text.slice(i).replace(/[A-Za-z]\w*/g, '<var>$&</var>');
	}
	break;
default:
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;
	}
}

</script>

<!--% 置換データ -->
<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
call:
construct:
create-array-from-list:
create-data-property:
create-iter-result-object:
get:
get-v:
invoke:
is-callable:
is-integer:
is-property-key:
object-create:
return-if-abrupt:
to-boolean:
to-number:
to-string:
type:
copy-data-block-bytes:
clone-array-buffer:
acquire-readable-stream-reader:acquire-readable-stream-default-reader
</script>


<!--%語彙  -->
<script type="text/plain" id="words_table1">
INFORMATIVE-DEEP:<p><em>この節とその各下位節すべては、参考である。</em><span lang="en">This section, and all its subsections, are non-normative.</span></p>
	http://www.w3.org/2001/tag/doc/promises-guide
STREAMS:https://github.com/whatwg/streams

	Record:Record
	List:List
this:<b class="es">this</b>
undefined:<b class="es">undefined</b>
true:<b class="es">true</b>
false:<b class="es">false</b>

ArrayBuffer:%ArrayBuffer%
Uint8Array:%Uint8Array%
ObjectPrototype:%ObjectPrototype%
DataView:%DataView%

WritableStream:<code>WritableStream</code> 
ReadableStreamTee:<span class="abstract">ReadableStreamTee</span> 

</script>

<!-- 
	TypedArray:%TypedArray%
	TBA:<p>策定中<span lang="en">TBA</span></p>
-->

<script type="text/plain" id="words_table">
	●stream
stream::::ストリーム
streaming::::ストリーミング
BYOB:
書込させ:write させ::書込ませ
書込され:write され::書込まれ
書込し:write し::書込み
書込した:write した::書込んだ
書込して:write して::書込んで
書込しな:write しな::書込まな
書込しよ:write しよ::書込も
書込する:write する::書込む
書込でき:write でき::書込め
書込み:writing::書込み
書込:write::書込み
書込器:writer::書込み器::ライタ
可書:writable::書込める

読取させ:read させ::読取らせ
読取され:read され::読取られ
読取しま:read しま::読取りま
読取した:read した::読取った
読取して:read して::読取って
読取しな:read しな::読取らな
読取しよ:read しよ::読取ろ
読取する:read する::読取る
読取でき:read でき::読取れ
読取り:reading::読取り
読取:read::読取り
読取器:reader::読取り器::リーダ
可読:readable::読取れる
	write:::::
	read:::::
	readable:::::
	reader:::::
	reading:::::
形式変換:transform::~::トランスフォーム
pipe::::パイプ
	配管する／管
piping::::パイプ
	~piping process
in-flight:
	
二叉化-:tee::~
二叉化:teeing::~
分岐:branch::~::ブランチ
有構造:structured::~
clone::::クローン
Realm:
brand-check:brand check

鎖:chain::~::チェイン
連鎖可能:chainable::~::チェイン可能
push::::プッシュ
pull::::プル
源:source::~::ソース
槽:sink::~::シンク
元の:original::~::オリジナル
最終:ultimate::~
行先:destination:~
下層:underlying::~
lock::::ロック
	lock法:locking
	錠
解放-:release::~
獲得-:acquire::~
	施錠
	開錠／解錠
作動中:active::~::アクティブ
側:side:~
包装-:wrap::~::ラップ
入出力:I/O:~
休止-:pause:~
再開-:resume:~
停止-:stop:~
	汲上げる:pump する
open:
	開いて:open して
close:::::クローズ
	closed:
error:::::エラー
	errored:
	~cancel:::::キャンセル
	cancellation:::::キャンセル
中止-:abort::~
取消す:cancel する::~::キャンセルする
取消-:cancel::取消::キャンセル
取消し:canceling::~::キャンセリング
取消:cancellation::取消し::キャンセレーション

	キャンセル／取消す
関心:interest:~

排他的:exclusive::~

制御器:controller::~::コントローラ
消費-:consume::~::コンシューム
消費:consumption::~
消費器:consumer::~::コンシューマ
生産-:produce::~::プロデュース
生産器:producer::~::プロデューサ
生産:production::~::プロダクション
変換器:converter::~::コンバータ
状態:state::~
状態machine:state machine::状態 machine:状態マシン
	:ステートマシン
生成:generation:~
生成-:generate:~

内部:internal::~
内部的:internal:~
作成-:create:~
作成:creation:~
翻訳-:translate::~
翻訳:translation::~
圧縮-:compress::~
圧縮済みの:compressed::~
圧縮器:compressor::~
未圧縮の:uncompressed::~
解凍-:decompress::~
解凍:decompression::~
復号器:decoder::~::デコーダ
復号:decode::~::デコード
符号化:encode::~::エンコード
仲介-:mediate::~

	listen:::::
自動割当て:auto-allocation::~
割当て:allocation::~
割当てた:allocate した::~
割当てて:allocate して::~
割当てる:allocate する::~

移動-:move:~
調整-:adjust:~
下流:downstream:~
最新の:up-to-date:~
受信:receive:~
	設定しておく:setup する:~
	予め決定済みの:predetermined:~
中間的:intermediate:~
転送-:transfer::~
排出-:drain:~
供給0-:vend:供給
	配給
給せる:supply できる:供せる
給-:supply:供
複製:copy::~
flow::::フロー
shutdown:
closing:
closure:



	●queuing strategy
策:strategy::~::ストラテジー
	strategy
合図:signal::通知::シグナル
伝播-:propagate::~
伝播:propagation::~
背圧:backpressure::~
圧力:pressure::~
掛ける:exert する:かける
掛けて:exert して:かけて
掛けら:exert さ:かけら
正常化:normalize:~
	収まる:subside する:~
満杯:full::~
	溢れる:over-full
	溢れ:overflowing
	落ち込んだ:dips
限界水位:high-water mark::~
chunk::::チャンク
enqueue:
queue-up:queue up
queue:
queuing:
	queue-with-sizes:
	個別~size付き~queue
size:::サイズ

	非負:non-negative:~
到達-:reach:~
合計:total::~
rate::::レート
流入:incoming:流入してくる
buffer::::バッファ
流す:flow する:~:::フローする
流れ:flow:~:::フロー
回送-:forward::~
増分的:incremental::~
送達-:deliver:~
高速:fast:~
	低速:slow:~
	slower
減速-:slow down:~
pace::::ペース
flag::::フラグ
listener::::リスナ
level::::レベル
slot:::::スロット
byte::::バイト
	~byte数による:byte-length
止める:stop する:~
	数え:count
	~chunk数による:count
	~~適正な:right
	使用量:usage
	埋めよ:fill しよ
	取出-:pull out:取り出
	手を止めて:back off
	捨てら:throw away さ
	減らせる:cut down
	十分素早く:quickly enough

	●promise
promise-calling:
promise:
非同期的:asynchronous::~
同期的:synchronous::~
同期-:synchronize::~
事由:reason::~
却下-:reject::~
却下:rejection::~
充足-:fulfill::~
充足:fulfillment::~
変形-:transform::~
決着:settle:~
処理待ち:pending::~
	順番待ちの
解決-:resolve::~
失敗-:fail::~
失敗:failure::~
完了:completion::~
完了-:complete::~
成功-:succeed::~
成功:success::~
成功裡:successful:~

schedule::::スケジュール:~

	●idl/js
Record:
List:
取得-:get::~::ゲット
取得子:getter::~::ゲッタ
作成子:creator::~::クリエータ
call:
call-back:call back
中途完了:abrupt completion::~
中途:abrupt::~
中途で:abrupt に::~
callback:
	calling
	呼ぶ:~callする:~
	呼出:~call:呼び出
	呼べ:~callすれ:~
	呼び:~callし:~
		呼んだ:~callした:~
	~callした
	呼ばれ:~callされ:~
	呼べる:~callできる:~
truthy:
構築子:constructor::~::コンストラクタ
構築-:construct:~
event::::イベント
class::::クラス
subclass:::派生 class:派生クラス:サブクラス
	subclass化:subclassing:~
method::::メソッド
obj:object:::オブジェクト
key::::キー
	対応付ける:map する
例外:exception:~
handler::::ハンドラ
設定-:set:~
	設定しておけば:this setup
	設定しておく:set up:~
値:value:~
返値:return value:返り値
返-:return:~
	返させ／返され
返る:return する:~
返す:return する:~
公開-:expose:~
関数:function::~
無名:anonymous:~
member::::メンバ
pattern::::パタン

演算:operation::~
演算-:operate::~
prototype::::プロトタイプ
投出-:throw:~
記述子:descriptor:~

map:
list:
名前:name:~
名:name:~
命名-:name:~

	●仕様（動詞
refactoring::::リファクタリング
働き:work:~
働く:work する:~
作者:author:~
利用:use:~
再利用:reuse:~
	reusable
利用者:user:~
定義:definition:~
定義-:define:~
確保-:ensure:~
統合-:integrate:~
統一化-:unify:~
統一的な:single, unified:~
要約-:summarize:~
設計:design:~
	きちんと設計されたwell-designed:
許容-:allow:~
	可能になる
試み:attempt:~
試みる:attempt する:~
試みて:attempt して:~
述べら:describe さ:~
述べる:describe する:~
指定-:specify:~
指示-:indicate:~
挙動:behavior:ふるまい
挙動する:behave する:ふるまう
挙動でき:behave でき:ふるまえ
提供-:provide:~
指図-:instruct:~
具体化:embody:~
可能化-:enable:~
適用-:apply:~
欲-:desire:~
希望-:hope:~
計画-:plan:~
求めて:want して:~
望む:wish する:~
望んで:wish して:~
	指す:refer する:~
意味-:mean:~
尊重-:respect:~
予期-:expect:~
順守-:obey:~
意図的:intentional:~
	意図-:intend:~
	意図され:meant:~
確信-:believe:~
最適化-:optimize:~
単純化:simplification:~
拡張:extended:~
成長-:grow:~
制御:control:~
制御先の:controlled:~
要求-:require:~
	要する
決定-:determine:~
feedback:::フィードバック
実装:implementation:~
実装-:implement:~
実装者:implementer:~
結付けら:associate さ:結び付けら
適応-:adapt:~
適応:adaptation:~
適応可能:adaptable:~
試行-:try:~
説明-:explain:~
	explanation:~
説明0:description:説明
干渉-:interfere:~
干渉:interference:~
保証-:guarantee:~
開発-:develop:~
開発者:developer:~
発展-:evolve:~
見做され:assume され:~
支持的な:supporting:~
集中-:centralize:~
向上-:improve:~
出荷-:ship:~
懸念-:concern:~
予測不能:unpredictable:~
影響-:affect:~
仕事:work:~
判定-:judge:~
拘束:constraints:~
施行-:enforce:~
検査-:check:~
	請われ:ask され
	もたらす:introduce
	外から見える:noticable
	興味を引く:interesting
	想起:evocative
	安定化:stabilizing:~
	至らせ:lead
	言語化:re-encoded
	先駆的:pioneering
	気にする:regardする
	〜し易くする:help
	心配する:worry
	についての:regarding
	別版を用いて:deviate
	異なる:different:~
	代入:assignment:~
	従う:follow する
	手入れ:take care
	決める:decide する
	扱う:dealing with／deal with
	調べる:consultする
	面する:-facing
	呼ばれ:refer／call／known
	待って:wait して
	言-:say
	力点を置いて:focus して
	尊重:ensure 〜 respect
	~~想定:imagine／-
	involvement
	made
	cause
	causing
	regard
	-:consider
	べき:should

	●仕様
API:
UA:user agent:UA
module::::モジュール
browser::::ブラウザ
platform::::プラットフォーム
option::::オプション
model::::モデル
framework::::フレームワーク
algo:algorithm:::アルゴリズム
approach::::アプローチ
ecosystem::::エコシステム
polyfill:::::
self-hosted:::自己完結的な
tool::::ツール
仕様:spec:~
	specification
仕組み:mechanism:~
共通的な:common な:よくある
共通的:common:~
可用:available:~
基準:reference:~
句:phrase:~
可能0:possible:可能
	場合もある
実際:actual:~
創出-:create:~
標準:standard:~
責務:concern::~
特有の:-specific な:~
特定の:specific:~
略記:shorthand:~
簡便:convenient:~
要件:requirement:~
規範的:normative:~
参考:non-normative:~
	informative:~
影響0:impact:影響
手段:means:~
方式:manner:~
有用:useful:~
通例的:usual:~
通例的な:usual:~
通常の:normal な:~
適切:appropriate:~
関連する:relevant な:~
	類似する:similar な:~
流儀:fashion:やり方
custom::::カスタム
customize::::カスタム化
独自の:custom:~
独自:custom:~
多目的に:utility purposes で:~
基本的な:base:~
便益:benefit:~
土台:foundation:~
選択的:selective:~
漠然と:vague に:~
部品:part:~
首に:primary に:主に
	主に:mainly
事例:case:~
仕方:way:~
殆どの:most:ほとんどの
大部分:most of:~
常に:always:~
方法:how:~
特殊化版:specialized version:~
version::::バージョン
暗黙的:implicit:~
意味論:semantics:~
明示的:explicit:~
概念:concept:~
基礎:basis:~
情報:information:~
入念:careful:~
慎重:careful:~
care::::ケア
扱難い:trickier:扱い難い
問題:issue:~
複雑さ:complexity:~
	複雑:complex:~
能力:capability:~
能:ability:~
仮説上の:hypothetical:仮想の
典型:typical な:~
概して:typical に:~
代表的:typical:~
機能性:functionality:~
無差別的:indiscriminate:~
独立:independent:~
試験可能:testable:~
汎化-:generic に:~
汎用的:generic:~
汎用:generic:~
汎用性:genericness:~
一般的:general:~
一般:general:~
一般の:general:~
手動的:manual:~
規約:convention:~
表記規約:conventions:~
記法:notation:~
新手法:innovation:~
全部的な:full:~
特色機能:feature:~
正確0:accurate:正確
演習:exercise:~
将来:future:~
後方互換性:backward-compatibility:~
柔軟性:flexibility:~
柔軟:flexible:~
恣意的:arbitrary:~
帰結:consequence:~

抽象化:abstraction:~
抽象化-:abstract 化:~
	抽象化して見えなくする abstract away
抽象:abstract:~
重要:important:~
安全:safe:~
局面:scenario:~
非対称性:asymmetry:~
正確:exact:~
経験的:heuristic:~
活動:activity:~
裁量:discretion:~
条件:condition:~
手動:manual:~
不変則:invariants:~
最適化-:optimize:~


	目的:purpose:~
	対照的:in contrast:~
	謝辞:acknowledgment:~
	読者:reader:~
	扱いにくい:awkward
	役に立たな:useless
	区別:distinction:
	分担:division:~
	突如:suddenly:~
	想定に近い:more aligned with our vision
	十分:suffice:~
	必要とされる:necessary
	沿う:along
	基づいて:based
	に則って:according to
	違って:unlike
	しかしながら:However
	更なる:further
	-:fairly
	thank
	とりわけ:especially
	ほとんどは:mostly
	おそらく:perhaps
	しかしながら:however
	したがって:thus
	次のようになる:it would look like
	手間をかけず:without much ceremony
	もちろん:of course
	簡潔にするため:for brevity
	~~基盤に:top of
	当の:in question
	に因り:due
	以降を通して:throughout the rest:
	ほぼ同様に:much like
	注目すべきはNotably
	上手く:well
	打開策:breakthrough idea
	最早〜ない:no longer
	ほぼ同様:much like
	何であれ，regardless of
	今や:now:~
	同様に:similarly
	少なくとも:least
	決して:never
	少しばかり:slight
	ごく近い:very similar
	に文書化されている:stated in the documentation for
	相当部分:large swathes
	何故なら:because
	責を負う:responsible
	本質的には，:In essence,
	当面の間は，:in the meantime,
	例:example
	例えば:example として
	詳細:detail
	〜を利用すれば、:We can then use 〜
	用法:using
	これを使えば、With this in hand,
	但し書き:caveats
	~~構成:factoring
	最近になって:recently
	そのようなわけで:As such,
	出荷するまでには程遠い:not quite yet ready to ship
	以降の:future
	多様になり得る:potentially-varying
	裏では:Under the covers,
	裏では:backing
	〜風の:in something close to
	満ちている:full of
	基準:reference
	それに伴われる:come along for the ride
	実体化:concrete
	~~特別に:specifically
	-:between
	言うまでもなく、〜に注意:It’s also worth noting that
	整理:clean up:~


	●未分類（動詞
配送-:dispatch:~
集中-:centralize:~
観測-:observe::~
	observing
処理:process:~
集成-:aggregate::~
access::::アクセス
accessor::::アクセサ
encapsulate::::カプセル化
install::::インストール
scroll::::スクロール
seek::::シーク
support::::サポート
照会-:query:~
動作:action:~
包含-:contain:~
反映-:reflect:~
受容-:accept:~
実行-:execute:~
実行:execution:~
遂行-:perform:~
待機-:wait:~
操作-:manipulate:~
格納-:store:~
取得0-:retrieve:取得
検証-:validate:~
	渡-:pass:~
	渡され／渡して
	渡す:pass する:~
移行-:move:~
組立てる:compose する:~
組立可能:composable:~
構成:composition:~
組込みの:built-in:組み込みの
表現-:represent:~
表現:representation:~
誘発-:trigger:~
追加-:add:~
追加の:additional:~
送信-:send:~
送信:sending:~
通信-:communicate:~
通信:communication:~
遅延-:delay:~
遷移:transition:~
開始処理:starting:~
開始-:start:~
再開始-:restart:~
取扱われ:handle され:取り扱われ
取扱う:handleする:取り扱う
取扱い:handling:取り扱い
築ける:build できる:~
築く:build する:~
築かれ:build され:~
承認-:acknowledge:~
差挟まれ:interleave され:差し挟まれ
差挟む:interleave する:差し挟む
遮られ:interrupt され:~
	interruption
	探されlook for
終えて:finish して:~
終えた:finish した:~
終わる:finish する:~
片付ける:clean up する:~
転換-:turn into:~
費やす:spend する:~
共有-:share:~
	促進させる:encouraging:
変更-:change:~
変更:changes:~
変化:changes:~
変化-:change:~
保持-:hold:~
維持管理-:maintain:~
	保守管理
	保ち続ける:keep track
管理:management:~
管理-:manage:~
統治-:govern:~
累積-:accumulate:~
累積の:accumulate される:~
累積:accumulation:~
防止-:prevent:~
完結-:finalize:~
破棄-:discard:~
除去-:remove:~
付加-:append:~
寄与-:contribute:~
	contribution
	ensuring:
継続-:continue:~
書出-:flush:書き出
遭遇-:encounter:~
初期化-:initialize:~
反応-:react:~
	reaction
組合せる:combine する:組み合せる
fallback::::フォールバック
fall-back:fall back:::フォールバック
追跡-:track:~
追跡:tracking:~
所有-:own:~
改変-:modify:~
	modification
	改変し得る:modifiable
所与の:given:与えられた
再入:reentrant:~
計算-:calculate:~
保存-:save:~
応答-:respond:~
呼出す:invoke す:呼び出す
呼出され:invoke され:呼び出され
起動-:initiate:~
開始-:start:~
露に:reveal:~
進行中の:ongoing:~
比較-:compare:~
更新-:update:~



	●未分類
JS:JavaScript
TCP:
OS:
	URL:
	ECMAScript:
	PNG:
	HTTP:
	GZIP:
	CSV:
	Object:
archive::::アーカイブ
binary::::バイナリ
bitmap::::ビットマップ
cache:::::キャッシュ
code::::コード
console::::コンソール
data::::データ
disk::::ディスク
effect::効果::エフェクト
field::::フィールド
file::::ファイル
filename:::file 名:ファイル名
filesystem::::ファイルシステム
frame::::フレーム
handle::::ハンドル
header::::ヘッダ
hook::::フック
index:
instance::::インスタンス
interface::::インタフェース
	~interface化する:interfacing
interprocess:::process 間:プロセス間
kernel::::カーネル
library::::ライブラリ
lifecycle:
literal::::リテラル
logic::::ロジック
message::::メッセージ
metadata::::メタデータ
mod:
multimedia::::マルチメディア
network::::ネットワーク
offset::::オフセット
pair::::ペア
parameter::::パラメタ
polling::::ポーリング
primitive::::プリミティブ
private::::プライベート
prop:property:::プロパティ
protocol::::プロトコル
public:::公開::パブリック
random::::ランダム
remote::::リモート
server::::サーバ
shut-down:shut down
socket:::::ソケット
stateful:
storage::::ストレージ
system::::システム
text::::テキスト
upload::::アップロード
video::::ビデオ
web:::::ウェブ
window::::ウィンドウ
zero::ゼロ

一覧:table:表
命令:command::~::コマンド
後方:backward:~
前方:forward:~
記憶域:memory::~::メモリ
	記憶域~内:in-memory:~
最小限に:minimize:~
複形態的:polymorphic:~
可視:visible:~
並列的:parallel:~
複合的な:composite::~
形式:format::~
真偽:boolean:~
集合:set:~
内容:content:~
要請本体:request body::~::リクエストボディ
応答本体:response body::~::レスポンスボディ
応答:response:~:::レスポンス
要請:request:~
生の:raw:~

事前条件:preconditions:~
速度:speed:~
変異不可:immutable::~
帯域外:out-of-band:~
実時間:real time:::リアルタイム
変数:variable:~
内側:inside:~
単独の:single:~
単純な:simple:~
単純:simple:~
	単に:simple に:~
即時:immediate:~
型:type:~
有型:typed:~
	簡単:easy:~
引数:argument:~
文字列:string:~
新たな:new:~
最終的:eventual:~
	~~最終的:final
段:step:~
手続き:steps:~
下位手続き:substeps:~
手順:procedure:手続き
画像:image:~
直接的:direct:~
相似的:analogous:~
空:empty:~
自動的:automatic:~
要素:element:~

言語:language:~
資源:resource:~


量:amount:~
低level:lower-level:低 level::低レベル
高level:higher-level:高 level::高レベル
効率的:efficient:~
自前の:own:~
絶えず:constant に:~
out-of-the-box:out of the box
展示:gallery:~
service-worker:service worker
透過的:transparent:~
不可分な:atomic:~
単位:unit:~
所在:location:~
背後:behind:~
構文:syntax:~
現在の:current:~
現在:currently:~

既定の:default:~
既定:default:~
順序:order:~
同時的:concurrent:~
構造:structure:~
有限:finite:~

宣言:declaration:~
大域:global::~::グローバル
高性能:high-performance:~

再度:again:再び
以前:previous:~
以前の:previous:~
	別々:separate
別の:another:~
同じ:same:~
次0の:next:次の
妥当:valid:~
機会:chance:~
	種類:kind:~
精確:precise:~

配列:array:~
遠隔の:remote:~
条態:condition:~
形:form:~
初期:initial:~
	初期の:initial:~
log::::ログ
匿名:anonymous:~
無限:infinite:~
準備済み:ready:~

精度:precision:~
倍精度:double-precision:~
浮動小数点:floating-point:~
算術:arithmetic:~
加算-:add:~
変動幅:variance:~
	数 100 京 個の:trillions
	莫大:huge
	丸め誤差:rounding error 
	限りがある:limit
相違:difference:~
等価:equivalent:~

</script>

<!--% 他の語

	●動詞
	~~湧き出:comes out
	~~流れ込む:goes in
見る:looking at
引き続き~call:call through
含む:include する
不具合:gone wrong
不具合が生じた:goes wrong
失った:loss した
現われ:appear
done
生じ:occur
見よ:see
見えなくさせられる hide
与-:give
与えられ:given
示-:show
~~終えた:done
現れる:appear する
やりとり:interaction
やりとりする:interface する
やりとり:interacting
やりとりする:interact
相互作用:interact with
doing
あり続ける:stay
going
あてがう:assign:
伝える:tell する
伝わり:inform され
得-:obtain
開始時:startup-time
表す:express
become
起-:happen
置-:put
放置:leave
come
go
~~代入:alias
~~要請~listen
対応付けて:map する
戻った:back した
保-:keep
destructuring


	●指示語
両者:both
最後の:last
最初の:first
個目の:first／second
2 個／ 2 種／ 2 つ:two
前:before
後:after
後続の
稀:rare
ある~~特定の:particular
特に:In particular
自身:itself:~
除いて:except
次の:following
周囲:around:~
それら自身:themselves:~
such::そのような
個々の:individual
節:section
複数の:multiple／
部位:part
他の:other
代わりに:instead
各:each
多い:often
多くの:many
間:duration
長い:long
最も単純:simplest
総計〜程の: 〜 worth of
上:above
後で／後に:later に
extent
まだ:still
nobody
point
special
higher
ever
until
まだ:yet
ここ:here
この:this
これらの:these
すべての:all
その:that
それら:they
それらの:their
それらの:those
それと同時に，At the same time,
なり次第:whenever
per
once
like
3 つの:three
いくつかの:couple
この時点で:At this point
の場合には:time
一度に一個ずつ:one at a time
同時に:at a time
先頭の:first
末尾の:final
任意の／どのような:arbitrary
任意の:any
ちょうど~~同じく:just asに
どこかで:ever
全体:entire
それ全体として:in its entirety
順に:in sequence
不在:not present
一度に:one go
その他の:Miscellaneous
外側:outside
余分な:extra
不定期の間:indefinitely
結果:result
種々の:various

	●
OS:operating system
低い:low
組み:trio
片:piece:~
行:line
連なり:successive
各部:portions
形:form
数:number
false
editor
we
his
when
通:through
互いに／一緒に:together
介して:via
呼応して:in response to
先頭へ一つずらす:shifting all other elements downward
中身:what type of ~ under the cover
WHILE:repeat
ロゴ:logo

-->

<!--%links -->
<script type="text/plain" id="_link_map">


	●dfn
~chunk:#chunk
可読~stream:#readable-stream
下層~源:#underlying-source
~pull源:#pull-source
~push源:#push-source
消費器:#consumer
取消す:#cancel-a-readable-stream
取消-:#cancel-a-readable-stream
取消し:#cancel-a-readable-stream
取消:#cancel-a-readable-stream
二叉化-:#tee-a-readable-stream
分岐:#branches-of-a-readable-stream-tee
下層~byte源:#underlying-byte-source
可読~byte~stream:#readable-byte-stream
可書~stream:#writable-stream
下層~槽:#underlying-sink
生産器:#producer
中止-:#abort-a-writable-stream
形式変換~stream:#transform-stream
~pipeする:#piping
~pipe:#piping
~pipe鎖:#pipe-chain
元の源:#original-source
最終~槽:#ultimate-sink
背圧:#backpressure
内部~queue:#internal-queues
~queuing策:#queuing-strategy
限界水位:#high-water-mark
~streamの内部~queueの残り~size:#desired-size-to-fill-a-streams-internal-queue

可読~stream読取器:#readable-stream-reader
読取器:#readable-stream-reader

可書~stream書込器:#writable-stream-writer
書込器:#writable-stream-writer

読取器に~lock:#locked-to-a-reader
書込器に~lock:#locked-to-a-reader
~lockされ:#locked-to-a-reader
~lockする:#locked-to-a-reader
~lock:#locked-to-a-reader

作動中:#active
~lockを解放-:#release-a-lock
解放-:#release-a-lock

既定の読取器:#default-readers
~BYOB読取器:#byob-readers

~ReadableStreamTee~pull関数:#readablestreamtee-pull-function
~ReadableStreamTee第一~分岐 取消-関数:#readablestreamtee-branch-1-cancel-function
~ReadableStreamTee第二~分岐 取消-関数:#readablestreamtee-branch-2-cancel-function
~WritableStream~error関数:#writablestream-error-function

完結する:#rs-pipeTo-finalize
~shutdown:#rs-pipeTo-shutdown-with-action
	#rs-pipeTo-shutdown

個別~size付き~queue演算 節:#queue-with-sizes

有構造~clone:~HTMLcloning#structuredclone
転送-:~HTMLcloning#transfer-abstract-op
並列的:~HTMLINFRA#in-parallel

	●ES6
有型~配列:~TC39#sec-typedarray-objects

~ArrayBuffer:~TC39#sec-arraybuffer-constructor
~Uint8Array:~TC39#sec-typedarray-objects
~ObjectPrototype:~TC39#sec-properties-of-the-object-prototype-object
min:~TC39#sec-algorithm-conventions

現在の~Realm~Record:~TC39#current-realm
大域~obj:~TC39#global-object

~List:#_es-List
~Record:#_es-record
	~TC39#sec-list-and-record-specification-type
中途完了:#_abrupt-completion
	~TC39#sec-completion-record-specification-type

	●promise
新たな~promise:#_p-a-new-promise
解決された~promise:#_p-a-promise-resolved-with
却下された~promise:#_p-a-promise-rejected-with
解決する:#_p-resolve-promise
却下する:#_p-reject-promise
充足~時:#_p-upon-fulfillment
却下~時:#_p-upon-rejection
変形-:#_p-transforming-by
~promise-calling:~PROMISES#promise-calling
	~promiseとして解決-:#_p-resolved-as-a-promise
	すべてを待機する:#_p-waiting-for-all

c.bufferedAmount:~WEBSOCKET#dom-websocket-bufferedamount

	●class/types
I.ArrayBuffer:~TC39#sec-arraybuffer-objects
I.Uint8Array:~TC39#sec-typedarray-objects
I.WebSocket:~WEBSOCKET#the-websocket-interface
I.DataView:~TC39#sec-dataview-objects
b.Number:~TC39#sec-ecmascript-language-types-number-type


C.ByteLengthQueuingStrategy:#blqs-class
C.CountQueuingStrategy:#cqs-class

C.ReadableStream:#rs-class
C.ReadableStreamDefaultReader:#default-reader-class
C.ReadableStreamDefaultController:#rs-default-controller-class
C.ReadableByteStreamController:#rbs-controller-class
C.ReadableStreamBYOBReader:#byob-reader-class
C.ReadableStreamBYOBRequest:#rs-byob-request-class

C.WritableStream:#ws-class
C.WritableStreamDefaultWriter:#default-writer-class
C.WritableStreamDefaultController:#ws-default-controller-class


	●#ws- #rs- #byob- #default-reader- #default-writer-
rs.ReadableStream:#rs-constructor
rs.locked:#rs-locked
rs.cancel:#rs-cancel
rs.getReader:#rs-get-reader
rs.pipeThrough:#rs-pipe-through
rs.pipeTo:#rs-pipe-to
rs.tee:#rs-tee
rs.desiredSize:#rs-default-controller-desired-size

rsdc.ReadableStreamDefaultController:#rs-default-controller-constructor
rsdc.desiredSize:#rs-default-controller-desired-size
rsdc.close:#rs-default-controller-close
rsdc.enqueue:#rs-default-controller-enqueue
rsdc.error:#rs-default-controller-error
rsdc.[[Cancel]]:#rs-default-controller-private-cancel
rsdc.[[Pull]]:#rs-default-controller-private-pull

dr.ReadableStreamDefaultReader:#default-reader-constructor
dr.closed:#default-reader-closed
dr.cancel:#default-reader-cancel
dr.read:#default-reader-read
dr.releaseLock:#default-reader-release-lock

rbsc.ReadableByteStreamController:#rbs-controller-constructor
rbsc.byobRequest:#rbs-controller-byob-request
rbsc.desiredSize:#rbs-controller-desired-size
rbsc.close:#rbs-controller-close
rbsc.enqueue:#rbs-controller-enqueue
rbsc.error:#rbs-controller-error
rbsc.[[Cancel]]:#rbs-controller-private-cancel
rbsc.[[Pull]]:#rbs-controller-private-pull


byob.ReadableStreamBYOBReader:#byob-reader-constructor
byob.closed:#byob-reader-closed
byob.cancel:#byob-reader-cancel
byob.read:#byob-reader-read
byob.releaseLock:#byob-reader-release-lock

ws.WritableStream:#ws-constructor
ws.locked:#ws-locked
ws.abort:#ws-abort
ws.getWriter:#ws-get-writer

dw.WritableStreamDefaultWriter:#default-writer-constructor
dw.closed:#default-writer-closed
dw.desiredSize:#default-writer-desiredSize
dw.ready:#default-writer-ready
dw.abort:#default-writer-abort
dw.close:#default-writer-close
dw.releaseLock:#default-writer-release-lock
dw.write:#default-writer-write

wsdc.WritableStreamDefaultController:#ws-default-controller-constructor
wsdc.error:#ws-default-controller-error


	●抽象演算

	■ TC39
		A.XXX:#_AO-XXX
		Ax.XXX:#~TC39#sec--xxx ( lowercase )
	A.Call
	A.Construct
	A.CreateArrayFromList
	A.CreateDataProperty
	A.CreateIterResultObject
	A.Get
	A.GetV
	A.Invoke
	A.IsCallable
	A.IsInteger
	A.IsPropertyKey
	A.ObjectCreate
	A.ReturnIfAbrupt
	A.ToNumber
	A.ToBoolean
	A.ToString
	A.Type
	A.CopyDataBlockBytes
	A.CloneArrayBuffer

Ax.Get:~TC39#sec-get-o-p
Ax.Type:~TC39#sec-ecmascript-data-types-and-values
b.Number:~TC39#sec-ecmascript-language-types-number-type

A.Transfer:~HTMLcloning#transfer-abstract-op
A.StructuredClone:~HTMLcloning#structuredclone
A.StructuredCloneWithTransfer:~HTMLcloning#structuredclonewithtransfer

</script>

<!--%style 

-->
<style>

.es {
	color: #041;
}

.slot {
	color: #061;
}



/* js code */
pre.lang-javascript {
	background: #FCFADC;
	padding: 0.5em;
}

.record-entries {
	white-space:pre-wrap;
	display: block;
	padding-left: 2em;
}

.throws:after, .nothrow:after {
	border: solid gray 1px;
	color: gray;
	font-size: 0.8em;
	background: #FCFFEF;
	margin-left: 0.5em;
	padding: 0 0.2em;
	display: inline-block;
}

.throws:after {
	content: "例外投出あり";
}

.nothrow:after {
	content: "投出なし";
}



</style>
<!-- 
code {
	background: #F0F0F0;
}
-->

</head>

<body class="whatwg">

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">
<h1>Streams Standard 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a> により，副題の日付にて公開された
<a href="https://streams.spec.whatwg.org/">Streams Standard</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新：<time>2017-03-18</time>
（公開：<time>2015-01-19</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

	<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KCjxjaXJjbGUKCWN4PSI1MCIgY3k9IjUwIiByPSI0NSIKCWZpbGw9IiNmZmYiCglzdHJva2U9IiMzYzc5MGEiCglzdHJva2Utd2lkdGg9IjEwIgovPgoKCTxnIHN0cm9rZT0iIzNjNzkwYSIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiPgo8IS0tIG91dGxpbmUgLS0+CjxwYXRoIHN0cm9rZS13aWR0aD0iMyIgZD0iCk04LDMwLjUgaDQyCk04LDY5LjUgaDQyCk00OS41LDI2LjUgaDEzIHY0NyBoLTEzIHoKIiAvPgoKPCEtLSBpbm5lciBsaW5lcyAtLT4KPHBhdGggc3Ryb2tlLXdpZHRoPSIxMiIgZD0iTTgsNTcgaDQyIiAvPgo8cGF0aCBzdHJva2Utd2lkdGg9IjE0IiBkPSJNNTAsNTcgaDEwIiAvPgoKPHBhdGggc3Ryb2tlLXdpZHRoPSIyIiBkPSJNOCwzNiBoNDIgbTAsLTIgaDEwIiAvPgo8cGF0aCBzdHJva2Utd2lkdGg9IjEiIGQ9IgpNOCw0OC41IGg0MgptMCwtMSBoOS41IHYyNQpNNTkuNSwyNyB2NwoiIC8+Cgo8IS0tIGhhbGYtdG9uZSBzaGFkaW5nIC0tPgo8cGF0aAoJc3Ryb2tlLWRhc2hhcnJheT0iMSwxIgoJZD0iCk04LDYzLjUgaDQwCm0wLDEgaC00MAptMCwxIGg0MAptMCwxIGgtNDAKbTAsMSBoNDAKCk01OSw2NC41IGgtOAptMCwxIGg4Cm0wLDEgaC04Cm0wLDEgaDgKbTAsMSBoLTgKbTAsMSBoOAoiIC8+Cgk8L2c+Cgo8L3N2Zz4K"
></a>
	<hgroup>
<h1 id="title">Streams</h1>
<h2>Living Standard — 最終更新 2017 年 3 月 17 日</h2>
	</hgroup>
<dl>
	<dt>Participate:</dt>
	<dd>
<a href="https://github.com/whatwg/streams">GitHub whatwg/streams</a>
(
<a href="https://github.com/whatwg/streams/issues/new">new issue</a>,
<a href="https://github.com/whatwg/streams/issues">open issues</a>
)</dd>

	<dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/streams/commits">GitHub whatwg/streams/commits</a></dd>
	<dd><a href="https://streams.spec.whatwg.org/commit-snapshots/253391df9a9588c696352e574494cd3d2646bc08" id="commit-snapshot-link">Snapshot as of this commit</a></dd>
	<dd><a href="https://twitter.com/streamsstandard">@streamsstandard</a></dd>

	<dt>各国語翻訳（非規範的）</dt>
	<dd>日本語（このページ）</dd>

</dl>

</header>

<div id="MAIN" style="display: none;">
	<section><!--  id="abstract" -->
<h2 title="Abstract">~~要約</h2>

<p>
この仕様は、~data~streamを［
作成する／組立てる／消費する
］ための~APIを，提供する。
これらの~streamは、低level入出力~primitiveに効率的に対応付けるように，および［
組込みの［
背圧と~queuing
］］を備える構成を簡単に~~作れるように設計されている。
~streamを~~基盤に：
~web~platformは、~filesystemや~socket~APIなどの 高levelの抽象化を築けるようになる。
と同時に，利用者たちは、給された~toolを利用して，［
自前の~streamを，~web~platformの~streamと上手く統合されるように築く
］ことが可能になる。
◎
This specification provides APIs for creating, composing, and consuming streams of data. These streams are designed to map efficiently to low-level I/O primitives, and allow easy composition with built-in backpressure and queuing. On top of streams, the web platform can build higher-level abstractions, such as filesystem or socket APIs, while at the same time users can use the supplied tools to build their own streams which integrate well with those of the web platform.
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~web~platformの相当部分は、~streaming~data上に築かれている：
すなわち，~dataは、全部を記憶域~内に読取することなく，増分的な流儀で、作成され, 処理され, 消費される。
Streams 標準は、そのような~streaming~dataを作成したり, それを~interface化するための，共通的~APIの集合を提供する
— それは
`可読~stream$,
`可書~stream$,
`形式変換~stream$
として具体化される。
◎
Large swathes of the web platform are built on streaming data: that is, data that is created, processed, and consumed in an incremental fashion, without ever reading all of it into memory. The Streams Standard provides a common set of APIs for creating and interfacing with such streaming data, embodied in readable streams, writable streams, and transform streams.
</p>

<p>
この標準は、~web~platformを成す各~部品が，自身の~streaming~dataを公開するために利用できるような、基本的な~stream~primitiveを提供する。
例えば `FETCH$r は、要請本体を可書~streamとして, あるいは
応答本体を可読~streamとして，公開できるようになる。
より一般的には、~platformは、~streamへの抽象化を待っている ~streamingに満ちている：
~multimedia~stream, ~file~stream, ~interprocess通信, 等々…
— すべてを記憶域~内に~bufferして，一度に処理する代わりに、~dataを増分的に処理できることから より便益が得られるような。
Streams Standard は、これらの~streamのための土台を提供して，開発者たちに公開することにより、次の様な利用~事例を可能化する：
◎
This standard provides the base stream primitives which other parts of the web platform can use to expose their streaming data. For example, [FETCH] could expose request bodies as a writable stream, or response bodies as a readable stream. More generally, the platform is full of streaming abstractions waiting to be expressed as streams: multimedia streams, file streams, interprocess communication, and more benefit from being able to process data incrementally instead of buffering it all into memory and processing it in one go. By providing the foundation for these streams to be exposed to developers, the Streams Standard enables use cases like:
</p>

<ul>
	<li>
~video~effect：
形式変換~streamを通して~pipeすることで，
可読~video~streamに対し実時間に~effectを適用する。
◎
Video effects: piping a readable video stream through a transform stream that applies effects in real time.
</li>
	<li>
解凍：
~file~streamを形式変換~streamを通すように~pipeすることで，
<kbd>.tgz</kbd> ~archiveの~fileを選択的に解凍する
— 利用者が画像の展示を~scrollするのに伴って，それらを `img^c 要素に転換する。
◎
Decompression: piping a file stream through a transform stream that selectively decompresses files from a .tgz archive, turning them into img elements as the user scrolls through an image gallery.
</li>
	<li>
画像の復号~処理：
HTTP 応答~streamを，［
~byte列を~bitmap~dataに復号する，形式変換~stream
］を通してから［
~bitmapを PNG に翻訳する別の形式変換
］を通すように~pipeする。
~service-worker `SERVICE-WORKERS$r
の `fetch^c ~hookの内側に~installされれば、これにより，
開発者たちは 新たな画像~形式を透過的に~polyfillできるようになる。
◎
Image decoding: piping an HTTP response stream through a transform stream that decodes bytes into bitmap data, and then through another transform that translates bitmaps into PNGs. If installed inside the fetch hook of a service worker [SERVICE-WORKERS], this would allow developers to transparently polyfill new image formats.
</li></ul>


<p>
ここに述べる~APIは、そのようなすべての~streamを統一化するための抽象化を提供し、この［
共有され, 組立可能な~interface
］の周囲にて成長する~ecosystemを促進させる。
と同時に，~APIは、［
効率的に低level入出力の責務に対応付けて，それに伴われる扱難い問題（ `背圧$ など）を~encapsulateする
］ように、入念に設計されている。
◎
The APIs described here provide unifying abstraction for all such streams, encouraging an ecosystem to grow around these shared and composable interfaces. At the same time, they have been carefully designed to map efficiently to low-level I/O concerns, and to encapsulate the trickier issues (such as backpressure) that come along for the ride.
</p>

	</section>
	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ε, ~LET, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
尚、この仕様~自身も~~末尾に自前の<a href="#conventions">表記規約</a>を備えていることに注意。
</p>


	</section>
	<section id="model">
<h2 title="Model">2. ~model</h2>


<p>
`~chunk@
とは、~stream［
へ書込される／から読取される
］ような，単独の~data片である。
それは，どのような型にもなり得る
— ~streamは、互いに異なる型からなる~chunkたちを包含し得る。
~chunkは、所与の~streamにおける不可分な~data単位にならないことも多い
— 例えば，~byte~streamは、単独の~byte列の代わりに，それぞれが［
16 KiB の `Uint8Array$I
］であるような~chunk列を包含することもある。
◎
A chunk is a single piece of data that is written to or read from a stream. It can be of any type; streams can even contain chunks of different types. A chunk will often not be the most atomic unit of data for a given stream; for example a byte stream might contain chunks consisting of 16 KiB Uint8Arrays, instead of single bytes.
</p>


		<section id="rs-model">
<h3 title="Readable Streams">2.1. 可読~stream</h3>

<p>
`可読~stream@
（ readable stream ）は、そこから読取できるような，~dataの源を表現する。
言い換えれば、~dataは，可読~streamから <em>~~湧き出る</em>。
◎
A readable stream represents a source of data, from which you can read. In other words, data comes out of a readable stream.
</p>

<p>
可読~streamは，任意の挙動を伴わせて作成し得るが、殆どの可読~streamは、［
`下層~源@
（ underlying source ）と~~呼ばれる，低levelの入出力~源
］を包装する。
下層~源には、 2 種の型，`~push源$と`~pull源$がある。
◎
Although a readable stream can be created with arbitrary behavior, most readable streams wrap a lower-level I/O source, called the underlying source. There are two types of underlying source: push sources and pull sources.
</p>

<p>
`~push源@
は、要請の有無にかかわらず，~dataを~pushしてくるような`下層~源$である。
それは、~dataの流れを
休止させる／再開させる
ための仕組みを提供することもある。
~push源の例には，~TCP~socketがある
— そこでは、~dataは~OS~levelから，
~TCP~window~sizeを変更することで制御し得るような~rateで，絶えず~pushされ続ける。
◎
Push sources push data at you, whether or not you are listening for it. They may also provide a mechanism for pausing and resuming the flow of data. An example push source is a TCP socket, where data is constantly being pushed from the OS level, at a rate that can be controlled by changing the TCP window size.
</p>

<p>
`~pull源@
は、~dataを得るためには要請を要するような`下層~源$である。
~dataは、同期的に可用になることもあれば（例： ~OSの記憶域~bufferに保持されている場合），非同期的に可用になることもある（例：~diskからの読取を要する場合）。
~pull源の例には，~file~handleがある
— そこでは、特定の所在へ~seekして，特定の量を読取する。
◎
Pull sources require you to request data from them. The data may be available synchronously, e.g. if it is held by the operating system’s in-memory buffers, or asynchronously, e.g. if it has to be read from disk. An example pull source is a file handle, where you seek to specific locations and read specific amounts.
</p>

<p>
可読~streamは、両~型の源を，統一的な~interfaceの背後に包装するように，設計されている。
◎
Readable streams are designed to wrap both types of sources behind a single, unified interface.
</p>

<p>
`~chunk$たちは、`下層~源$から，~streamの中へ~enqueueされる。
~chunkたちは、~streamの~public~interfaceを介して，一度に一個ずつ読取できる。
◎
Chunks are enqueued into the stream by the stream’s underlying source. They can then be read one at a time via the stream’s public interface.
</p>

<p>
可読~streamから その~public~interfaceを利用して読取する~codeは、
`消費器@
（ consumer ）と呼ばれている。
◎
Code that reads from a readable stream using its public interface is known as a consumer.
</p>

<p>
消費器は、可読~streamを
`取消す@
（ cancel する）能も持つ。
これは、［
消費器が~streamへの関心を失った
］こと，および［
即時に~streamを~closeして,
~queueされた`~chunk$たちは捨てて,
`下層~源$に取消の仕組みがあればそれを実行する
］ことを指示する。
◎
Consumers also have the ability to cancel a readable stream. This indicates that the consumer has lost interest in the stream, and will immediately close the stream, throw away any queued chunks, and execute any cancellation mechanism of the underlying source.
</p>

<p>
消費器は、可読~streamを
`二叉化-@
（ tee† ）することもできる。
これは、~streamを`~lock$して，それ以上 直接的に利用できなくする一方で、
`分岐@
（ branch ）と呼ばれる，独立に消費される 2 個の新たな~streamを作成する。
◎
Consumers can also tee a readable stream. This will lock the stream, making it no longer directly usable; however, it will create two new streams, called branches, which can be consumed independently.
</p>

<p class="trans-note">【†
“tee” という呼称は、 CUI における tee コマンドの “tee”
— T 字型 分岐の “T” —
に由来すると見られる。
】</p>

<p>
~byte列を表現するような~streamに対しては、`可読~stream$の拡張~versionが提供される
— それは特に、複製を最小限にして，~byte列を効率的に取扱うためにある。
そのような可読~streamに対する`下層~源$は、
`下層~byte源@
とも呼ばれる。
`下層~源$が`下層~byte源$でもあるような`可読~stream$は、
`可読~byte~stream@
とも呼ばれる。
◎
For streams representing bytes, an extended version of the readable stream is provided to handle bytes efficiently, in particular by minimizing copies. The underlying source for such a readable stream is called a underlying byte source. A readable stream whose underlying source is an underlying byte source is sometimes called a readable byte stream.
</p>


		</section>
		<section id="ws-model">
<h3 title="Writable Streams">2.2. 可書~stream</h3>

<p>
`可書~stream@
（ writable stream ）は、そこへ書込できるような，~dataの行先を表現する。
言い換えれば、~dataは 可書~streamへ<em>~~流れ込む</em>。
◎
A writable stream represents a destination for data, into which you can write. In other words, data goes in to a writable stream.
</p>

<p>
可読~streamと相似的に、殆どの可書~streamも，
`下層~槽@
（ underlying sink ）と呼ばれる低level 入出力~槽を包装する。
可書~streamは、一連の書込を~queueして，下層~槽に一個ずつ送達することにより、下層~槽の複雑さの一部を抽象化して見えなくするように働く。
◎
Analogously to readable streams, most writable streams wrap a lower-level I/O sink, called the underlying sink. Writable streams work to abstract away some of the complexity of the underlying sink, by queuing subsequent writes and only delivering them to the underlying sink one by one.
</p>

<p>
`~chunk$たちは、その~public~interfaceを介して，~streamへ書込され、一度に一個ずつ~streamの`下層~槽$に渡される。
◎
Chunks are written to the stream via its public interface, and are passed one at a time to the stream’s underlying sink.
</p>

<p>
可書~streamの中へ，その~public~interfaceを利用して書込する~codeは、
`生産器@
（ producer ）と呼ばれている。
◎
Code that writes into a writable stream using its public interface is known as a producer.
</p>

<p>
`生産器$は、可書~streamを
`中止-@
（ abort ）する能も持つ。
これは、［
生産器が，何か不具合があると確信したこと,
したがって 以降の書込は継続されるべきでないこと
］を指示する。
これは、`下層~槽$からの合図がなくとも，~streamを~error状態に置く。
◎
Producers also have the ability to abort a writable stream. This indicates that the producer believes something has gone wrong, and that future writes should be discontinued. It puts the stream in an errored state, even without a signal from the underlying sink.
</p>

		</section>
		<section id="ts-model">
<h3 title="Transform Streams">2.3. 形式変換~stream</h3>

<p>
`形式変換~stream@
（ transform stream ）は、~streamの~pair
— 可書~stream, 可読~stream —
からなる。
当の形式変換~stream特有の方式で，可書~側へ書込される結果、新たな~dataが可読~側から読取されて可用になる。
◎
A transform stream consists of a pair of streams: a writable stream, and a readable stream. In a manner specific to the transform stream in question, writes to the writable side result in new data being made available for reading from the readable side.
</p>

<p>
形式変換~streamの例：
◎
Some examples of transform streams include:
</p>

<ul>
	<li>
GZIP 圧縮器 —
未圧縮の~byte列が そこへ書込され，圧縮済みの~byte列が そこから読取される;
◎
A GZIP compressor, to which uncompressed bytes are written and from which compressed bytes are read;
</li>
	<li>
~video復号器 —
符号化された~byte列が そこへ書込され，
未圧縮の~video~frameたちが そこから読取される
◎
A video decoder, to which encoded bytes are written and from which uncompressed video frames are read;
</li>
	<li>
~text復号器
— ~byte列が そこへ書込され，
文字列たちが そこから読取される;
◎
A text decoder, to which bytes are written and from which strings are read;
</li>
	<li>
CSV-to-JSON 変換器
— CSV ~fileをなす各~行を表現する文字列たちが そこへ書込され、対応する~JS~objたちが そこから読取される。
◎
A CSV-to-JSON converter, to which strings representing lines of a CSV file are written and from which corresponding JavaScript objects are read.
</li>
</ul>




		</section>
		<section id="pipe-chains">
<h3 title="Pipe Chains and Backpressure">2.4. ~pipe鎖と背圧</h3>

<p>
~streamたちは首に，互いに
`~pipe@
して利用される。
可読~streamは、直接的に可書~streamに~pipeしたり，その~~前にいくつかの形式変換~streamを通してから~pipeすることもできる。
◎
Streams are primarily used by piping them to each other. A readable stream can be piped directly to a writable stream, or it can be piped through one or more transform streams first.
</p>

<p>
この仕方で互いに~pipeされた一連の~streamは、
`~pipe鎖@
（ pipe chain ）と呼ばれる。
~pipe鎖における
先頭の可読~streamの`下層~源$を
`元の源@
（ original source ）と呼び、末尾の可書~streamの`下層~槽$を
`最終~槽@
（ ultimate sink ）と呼ぶ。
◎
A set of streams piped together in this way is referred to as a pipe chain. In a pipe chain, the original source is the underlying source of the first readable stream in the chain; the ultimate sink is the underlying sink of the final writable stream in the chain.
</p>

<p>
`~pipe鎖$が構築されたなら、それを通して［
`~chunk$たちをどの~~程度 高速に流すべきかについての合図
］を伝播するために利用し得るようになる。
鎖のある段が~chunkをまだ受容できない場合、~pipe鎖を通して後方へ, 最終的に元の源まで，合図が伝播され、元の源に ~chunkの生産-を止めるよう伝えることになる。
この、［
鎖がどの~~程度 高速に~chunkを処理できるかに則って，元の源からの流れを正常化する処理
］は、
`背圧@
（ backpressure ）と呼ばれる。
◎
Once a pipe chain is constructed, it can be used to propagate signals regarding how fast chunks should flow through it. If any step in the chain cannot yet accept chunks, it propagates a signal backwards through the pipe chain, until eventually the original source is told to stop producing chunks so fast. This process of normalizing flow from the original source according to how fast the chain can process chunks is called backpressure.
</p>

<p>
可読~streamが`二叉化-$されたときは、その 2 個の`分岐$からの`背圧$合図は，いずれの分岐も読取できないときには，集成された上で、元の~streamの`下層~源$へ送信されることになる。
◎
When teeing a readable stream, the backpressure signals from its two branches will aggregate, such that if neither branch is read from, a backpressure signal will be sent to the underlying source of the original stream.
</p>


		</section>
		<section id="queuing-strategies">
<h3 title="Internal Queues and Queuing Strategies">2.5. 内部~queueと~queuing策</h3>

<p>
可読~stream, 可書~stream
のいずれも，
`内部~queue@
（ internal queue ）を維持管理し，類似する目的に利用する。
可読~streamの内部~queueは、［
`下層~源$により~enqueueされたが，`消費器$からはまだ読取されていない
］ような`~chunk$たちを包含する。
可書~streamの内部~queueは、［
`生産器$により~streamに書込され，承認されたが、まだ`下層~槽$により処理されていない
］ような`~chunk$たちを包含する。
◎
Both readable and writable streams maintain internal queues, which they use for similar purposes. In the case of a readable stream, the internal queue contains chunks that have been enqueued by the underlying source, but not yet read by the consumer. In the case of a writable stream, the internal queue contains chunks which have been written to the stream by the producer, but not yet processed and acknowledged by the underlying sink.
</p>

<p>
`~queuing策@
（ queuing strategy ）とは、~streamが［
自身の`内部~queue$の状態に基づいて，`背圧$を どのように合図すべきか
］を決定するような，~objである。
~queuing策は、各`~chunk$に~sizeをあてがい，［
~queue内のすべての~chunkの合計~size
］と［
`限界水位@
（ high-water mark ）と呼ばれる，指定された数
］とを比較する。
結果の差分 ~EQ ［
限界水位 − 合計~size
］は、
`~streamの内部~queueの残り~size@
（ desired size to fill the stream’s queue ）を決定するために利用される。
◎
A queuing strategy is an object that determines how a stream should signal backpressure based on the state of its internal queue. The queuing strategy assigns a size to each chunk, and compares the total size of all chunks in the queue to a specified number, known as the high water mark. The resulting difference, high water mark minus total size, is used to determine the desired size to fill the stream’s queue.
</p>

<p>
可読~streamにおいては、下層~源は，この残り~sizeを［
~chunk生成を減速させる背圧~合図
］に利用できる
— 残り~sizeを~zero以上に保とうとするために。
可書~streamにおいては、生産器は，類似するように挙動できる
— 残り~sizeが負になる前に書込を避けるために。
◎
For readable streams, an underlying source can use this desired size as a backpressure signal, slowing down chunk generation so as to try to keep the desired size above or at zero. For writable streams, a producer can behave similarly, avoiding writes that would cause the desired size to go negative.
</p>

<div class="example" id="example-simple-queuing-strategy">

<p>
~queuing策の単純な例には、各`~chunk$ごとに~size 1 をあてがい，`限界水位$は一定数にするものが挙げられる。
これは、~streamが背圧を適用する前に［
可読~stream内に~enqueueできる／
可書~streamに書込できる
］~chunk数は，その一定数までに限られることを意味する。
◎
A simple example of a queuing strategy would be one that assigns a size of one to each chunk, and has a high water mark of three. This would mean that up to three chunks could be enqueued in a readable stream, or three chunks written to a writable stream, before the streams are considered to be applying backpressure.
</p>
</div>

		</section>
		<section id="locking">
<h3 title="Locking">2.6. ~lock法</h3>


<p>
`可読~stream読取器@
または単に
<dfn>読取器</dfn>
（ reader ）とは、`可読~stream$から直接的に`~chunk$を読取できるようにする~objである。
読取器がない下では、`消費器$は，可読~stream上の高level演算
— ~streamを`取消す$か, または 可読~streamから可書~streamへ`~pipeする$ —
しか遂行できない。
◎
A readable stream reader, or simply reader, is an object that allows direct reading of chunks from a readable stream. Without a reader, a consumer can only perform high-level operations on the readable stream: canceling the stream, or piping the readable stream to a writable stream.
</p>

<p>
同様に、
`可書~stream書込器@
または単に
<dfn>書込器</dfn>
（ writer ）とは、`可書~stream$に直接的に`~chunk$を書込できるようにする~objである。
書込器がない下では、`生産器$は，可書~stream上の高level演算
— ~streamを中止するか, 可読~streamから可書~streamへ`~pipeする$ —
しか遂行できない。
◎
Similarly, a writable stream writer, or simply writer, is an object that allows direct writing of chunks to a writable stream. Without a writer, a producer can only perform the high-level operations of aborting the stream or piping a readable stream to the writable stream.
</p>


<p>
（これらの高level演算は、裏では，実際には 読取器／書込器を利用する。）
◎
(Under the covers, these high-level operations actually use a reader or writer themselves.)
</p>


<p>
所与の可読／可書~streamを利用している読取器／書込器がある間は、他のどの読取器／書込器も，その~streamを利用できない。
このことを，~streamは
`~lockされ@
ていると言い、読取器／書込器は
`作動中@
（ active ）と言う。
◎
A given readable or writable stream only has at most one reader or writer at a time. We say in this case the stream is locked, and that the reader or writer is active.
</p>

<p>
読取器／書込器は、その~lockを
`解放-@
する能力も持つ。
それにより，読取器／書込器は`作動中$でなくなり、他の読取器／書込器は，当の~streamの~lockを獲得できるようになる。
◎
A reader or writer also has the capability to release its lock, which makes it no longer active, and allows further readers or writers to be acquired.
</p>

<p>
`可読~byte~stream$には、 2 種の型の読取器［
`既定の読取器@
と
`~BYOB読取器@
］を供給0する能がある。
~BYOB（
“Bring Your Own Buffer” — “開発者が~bufferを給する”
）読取器は、開発者から給される~bufferの中へ読取できるようにして，~dataの複製を最小限にする。
◎
A readable byte stream has the ability to vend two types of readers: default readers and BYOB readers. BYOB ("bring your own buffer") readers allow reading into a developer-supplied buffer, thus minimizing copies.
</p>




		</section>
	</section>
	<section id="rs">
<h2 title="Readable Streams">3. 可読~stream</h2>

		<section id="rs-intro">
<h3 title="Using Readable Streams">3.1. 可読~streamの用法</h3>


<div class="example" id="example-basic-pipe-to">

<p>
可読~streamを消費する最も単純な仕方は、単純にそれを`可書~stream$へ`~pipeする$ことである。
これにより，その`背圧$が尊重されるようになり、（書込みでも読取りでも）~errorが生じれば`~pipe鎖$を通して伝播される：
◎
The simplest way to consume a readable stream is to simply pipe it to a writable stream. This ensures that backpressure is respected, and any errors (either writing or reading) are propagated through the chain:
</p>

<pre class="lang-javascript">
readableStream.pipeTo(%writableStream)
  .then(() =&gt; console.log(`すべての~dataは成功裡に書込されました^l))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));
</pre>
<!-- 
"All data successfully written!"
"Something went wrong!"
-->
</div>



<div class="example" id="example-pipe-as-chunks-receiver">

<p>
可読~streamからの各 新たな~chunkを，単純に改めたいと欲するならば、それを，独自にその目的に作成した 新たな`可書~stream$へ`~pipeする$こともできる：
◎
If you simply want to be alerted of each new chunk from a readable stream, you can pipe it to a new writable stream that you custom-create for that purpose:
</p>

<pre class="lang-javascript">
%readableStream.pipeTo(new WritableStream({
  write(%chunk) {
    console.log(`~chunkが受信されました^l, %chunk);
  },
  close() {
    console.log(`すべての~dataを成功裡に読取しました^l);
  },
  abort(%e) {
    console.error(`何かまずいことが起きたようです^l, %e);
  }
}));

<!-- 
"Chunk received"
"All data successfully read!"
"Something went wrong!"
-->
</pre>

<p>
~~自前の `write()^c 実装から~promiseを返すことにより、可読~streamに向けて`背圧$を合図できる。
◎
By returning promises from your write implementation, you can signal backpressure to the readable stream.
</p>

</div>

<div class="example" id="example-manual-read">

<p>
可読~streamは、通例的に，可書~streamへ~pipeするために利用されるが、直接的に読取することもできる
— `読取器$を獲得してから，その `read()^c ~methodを利用して ~chunkの連なりを取得することにより。
例えば，次の~codeは、~stream内の次0の`~chunk$が可用なら，その~logをとる：
◎
Although readable streams will usually be used by piping them to a writable stream, you can also read them directly by acquiring a reader and using its read() method to get successive chunks. For example, this code logs the next chunk in the stream, if available:
</p>

<pre class="lang-javascript">
const %reader = %readableStream.getReader();

%reader.read().then(
  ({ %value, %done }) =&gt; {
    if (%done) {
      console.log(`~streamはすでに~closeされています^l);
    } else {
      console.log(%value);
    }
  },
  %e =&gt; console.error(`~streamに~errorが生じたので読取できません^l, %e)
);
</pre>

<!-- 
"The stream was already closed"
"The stream became errored and cannot be read from"
-->
<p>
この~methodは、~streamを より手動的に読取するとき
— 主に~library作者にとって、［
`~pipe$する／`二叉化-$する
］ことから提供されるものを超えるような，~streamに対する新たな高level演算を築くとき —
に有用になる。
◎
This more manual method of reading a stream is mainly useful for library authors building new high-level operations on streams, beyond the provided ones of piping and teeing.
</p>

</div>


<div class="example" id="example-manual-read-bytes">

<p>
上の例では，可読~streamに対する`既定の読取器$の利用を示したが、~streamが`可読~byte~stream$である場合は，それに対する`~BYOB読取器$も獲得できる
— それにより、~buffer割当てについて，複製を避けるべく より精確に制御できるようになる。
例えば次の~codeは、~streamから最初の 1024 ~byteを，単独の記憶域~bufferの中に読取する：
◎
The above example showed using the readable stream’s default reader. If the stream is a readable byte stream, you can also acquire a BYOB reader for it, which allows more precise control over buffer allocation in order to avoid copies. For example, this code reads the first 1024 bytes from the stream into a single memory buffer:
</p>

<pre class="lang-javascript">
const %reader = readableStream.getReader({ mode: `byob^l });

let %startingAB = new ArrayBuffer(1024);
readInto(%startingAB)
  .then(%buffer =&gt; console.log(`最初の 1024 ~byte:^l, %buffer))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));

function readInto(%buffer, %offset = 0) {
  if (%offset === %buffer.byteLength) {
    return Promise.resolve(%buffer);
  }

  const %view = new Uint8Array(%buffer, %offset, %buffer.byteLength - %offset);
  return %reader.read(%view).then(%newView =&gt; {
    return readInto(%newView.buffer, %offset + %newView.byteLength);
  });
}
</pre>
<!-- 
"The first 1024 bytes:"
"Something went wrong!"
 -->

<p>
ここで重要なことは、~~最終的な %buffer 値は %startingAB と異なるが、それら（および すべての中間的~buffer）は，裏では同じ記憶域の割当てを共有することである。
~bufferは、毎回 新たな `ArrayBuffer$I ~objに`転送-$される。
%newView は、各種~propが次のように設定された，新たな `Uint8Array$I になる
⇒
`buffer^c ~SET 当の `ArrayBuffer$I ~obj；<br>
`byteOffset^c ~SET 書込された~byte列の~offset；<br />
`byteLength^c ~SET 書込された~byte数
◎
An important thing to note here is that the final buffer value is different from the startingAB, but it (and all intermediate buffers) shares the same backing memory allocation. At each step, the buffer is transferred to a new ArrayBuffer object. The newView is a new Uint8Array, with that ArrayBuffer object as its buffer property, the offset that bytes were written to as its byteOffset property, and the number of bytes that were written as its byteLength property.
</p>

</div>



		</section>
		<section id="rs-class">
<h3 title="Class ReadableStream">3.2. `ReadableStream^C ~class</h3>

<p>
`ReadableStream$C ~classは、`可読~stream$の一般~概念を実体化する~instanceである。
それは、どのような`~chunk$型にも適応可能であり，［
`下層~源$から給されたが, まだ消費器から読取されていない~data
］を保ち続けるための内部~queueを維持管理する。
◎
The ReadableStream class is a concrete instance of the general readable stream concept. It is adaptable to any chunk type, and maintains an internal queue to keep track of data supplied by the underlying source but not yet read by any consumer.
</p>


			<section id="rs-class-definition">
<h4 title="Class Definition">3.2.1. ~class定義</h4>

~INFORMATIVE

<p>
`ReadableStream$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば，次のようになる：
◎
If one were to write the ReadableStream class in something close to the syntax of [ECMASCRIPT], it would look like
</p>

<pre class="lang-javascript">
class ReadableStream {
  constructor(%underlyingSource = {}, { %size, %highWaterMark } = {})

  get locked()

  cancel(%reason)
  getReader()
  pipeThrough({ %writable, %readable }, %options)
  pipeTo(%dest, { %preventClose, %preventAbort, %preventCancel } = {})
  tee()
}
</pre>


			</section>
			<section id="rs-internal-slots">
<h4 title="Internal Slots">3.2.2. 内部~slot</h4>


<p>
`ReadableStream$C の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableStream are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th title="Internal Slot">内部~slot
<th title="Description(non-normative)">説明0（<em>参考</em>）
</thead>

<tbody><tr><td>[[disturbed]]
<td>
真偽~flag
— ~streamから何か読取されたか, ~streamが取消されたとき， ~true に設定される。
◎
A boolean flag set to true when the stream has been read from or canceled

<tr><td>[[readableStreamController]]
<td>
［
この~streamの状態と~queueを制御する能
］を伴って作成される［
`ReadableStreamDefaultController$C または `ReadableByteStreamController$C
］。
`IsReadableStream$A による~brand-checkにも利用される。
◎
A ReadableStreamDefaultController or ReadableByteStreamController created with the ability to control the state and queue of this stream; also used for the IsReadableStream brand check

<tr><td>[[reader]]
<td>
この~streamを`~lock$している`読取器$
— `ReadableStreamDefaultReader$C または `ReadableStreamBYOBReader$C —
の~instanceが［
あれば それ ／
なければ ~undefined
］。
◎
A ReadableStreamDefaultReader or ReadableStreamBYOBReader instance, if the stream is locked to a reader, or undefined if it is not


<tr><td>[[state]]
<td>
内部的に利用される，~streamの現在の状態を表す文字列
— 次のいずれか：
`readable^l, `closed^l, `errored^l
◎
A string containing the stream’s current state, used internally; one of "readable", "closed", or "errored"


<tr><td>[[storedError]]
<td>
~streamが どのように失敗したかを指示する値
— ~errorした~streamに対し演算しようと試行しているときに、失敗~事由か例外として与えられることになる。
◎
A value indicating how the stream failed, to be given as a failure reason or exception when trying to operate on an errored stream
</tbody></table>

			</section>
			<section id="rs-constructor">
<h4>3.2.3. `new ReadableStream(underlyingSource = {}, { size, highWaterMark } = {})^rs</h4>

<div class="note">

<p>
構築子に渡される %underlyingSource （下層~源）~objには、構築される~stream~instanceの挙動を統治する，以下の~methodを実装できる：
◎
The underlyingSource object passed to the constructor can implement any of the following methods to govern how the constructed stream instance behaves:
</p>

<ul>
	<li>
`start(controller)^c
は，即時に~callされ、概して，［
関連する~event~listenerを設定しておくことにより`~push源$に適応する
］, または［
`~pull源$への~accessを獲得する
］ために利用される。
この処理が非同期的になる場合、成功か失敗かを合図する~promiseを返すようにすることもできる。
◎
start(controller) is called immediately, and is typically used to adapt a push source by setting up relevant event listeners, or to acquire access to a pull source. If this process is asynchronous, it can return a promise to signal success or failure.
</li>
	<li>
`pull(controller)^c
は、~streamの内部~queueの`~chunk$が満杯でないとき，~queueが`限界水位$に到達するまで、繰り返し~callされる。
`pull()^c が~promiseを返す場合、その~promiseが充足されるまでは， `pull()^c が再度~callされることはない。
~promiseが却下された場合、~streamは~errorにされる。
◎
pull(controller) is called when the stream’s internal queue of chunks is not full, and will be called repeatedly until the queue reaches its high water mark. If pull returns a promise, then pull will not be called again until that promise fulfills; if the promise rejects, the stream will become errored.
</li>
<li>
`cancel(reason)^c は、［
`消費器$が，最早~streamへの関心を失ったことを合図する
］ときに，~callされる。
これは、`下層~源$への~accessを解放するために必要とされる動作を遂行するべきである。
この処理が非同期的になる場合、成功か失敗かを合図する~promiseを返すようにすることもできる。
◎
cancel(reason) is called when the consumer signals that they are no longer interested in the stream. It should perform any actions necessary to release access to the underlying source. If this process is asynchronous, it can return a promise to signal success or failure.
</li>
</ul>

<p>
`start()^c, `pull()^c
の両者ともに，［
渡された %controller ~objを介して，~streamの［
内部~queueと状態
］を操作する能
］が与えられる。
これは、
<a href="https://blog.domenic.me/the-revealing-constructor-pattern/">構築子を通して露にする~pattern</a>
（ revealing constructor pattern ）†の一例である。
◎
Both start and pull are given the ability to manipulate the stream’s internal queue and state via the passed controller object. This is an example of the revealing constructor pattern.
</p>

<p class="trans-note">【†
リンク先の要約：
~obj内部の能力を，その構築子の中（~objを構築する~code）に限って，露にさせるような，~pattern
— すなわち，外部からは、構築子に渡された引数（である関数に渡される引数 ／ である~objの~member）のみを介して，その能力に~accessできる。
】</p>


<p>
%underlyingSource ~objの `type^c ~propが `bytes^l に設定されている場合、この`可読~stream$は`可読~byte~stream$になり，
`~BYOB読取器$を成功裡に供給0できるようになる。
その場合、渡される %controller ~objは，
`ReadableByteStreamController$C の~instanceになる。
他の場合、それは `ReadableStreamDefaultController$C の~instanceになる。
◎
If the underlyingSource object contains a property type set to "bytes", this readable stream is a readable byte stream, and can successfully vend BYOB readers. In that case, the passed controller object will be an instance of ReadableByteStreamController. Otherwise, it will be an instance of ReadableStreamDefaultController.
</p>

<p>
`可読~byte~stream$に対しては、
%underlyingSource には `autoAllocateChunkSize^c ~propも含ませられ，この~streamに対する自動割当て特色機能を可能化する正~整数に設定できる。
その場合、`消費器$が`既定の読取器$を利用するとき、~stream実装は，所与の~sizeの `ArrayBuffer$I を自動的に割当てた上で［
`消費器$は`~BYOB読取器$を利用していた
］かのように`下層~源$の~codeを~callする。
これにより、`下層~源$の実装に必要な~code量も減らせる
— 自動割当てを伴わない
<a href="#example-rbs-push">§ 下層~push源を伴う可読~byte~stream（背圧~supportなし）</a>
と, 自動割当てを伴う
<a href="#example-rbs-pull">§ 下層~pull源を伴う可読~byte~stream</a>
とを比較されたし。
◎
For readable byte streams, underlyingSource can also contain a property autoAllocateChunkSize, which can be set to a positive integer to enable the auto-allocation feature for this stream. In that case, when a consumer uses a default reader, the stream implementation will automatically allocate an ArrayBuffer of the given size, and call the underlying source code as if the consumer was using a BYOB reader. This can cut down on the amount of code needed when writing the underlying source implementation, as can be seen by comparing §8.3 A readable byte stream with an underlying push source (no backpressure support) without auto-allocation to §8.5 A readable byte stream with an underlying pull source with auto-allocation.
</p>

<p>
構築子は、 2 個目の引数に［
2 個の~prop［
非負~数 `highWaterMark^c, および
`size(chunk)^c 関数
］を伴う`~queuing策$~obj
］を受容する。
この策~objは、組込みの［
`CountQueuingStrategy$C ／ `ByteLengthQueuingStrategy$C
］~classの~instanceにも, ~customのものにもなり得る。
策が給されなかった場合の既定の挙動は、`限界水位$ 1 の `CountQueuingStrategy$C と同じになる。
◎
The constructor also accepts a second argument containing the queuing strategy object with two properties: a non-negative number highWaterMark, and a function size(chunk). The supplied strategy could be an instance of the built-in CountQueuingStrategy or ByteLengthQueuingStrategy classes, or it could be custom. If no strategy is supplied, the default behavior will be the same as a CountQueuingStrategy with a high water mark of 1.
</p>

</div>


<ol class="algo">
	<li>
~this.[[state]] ~SET `readable^l
◎
Set this.[[state]] to "readable".
</li>
	<li>
~this.[[reader]] ~SET ~undefined,<br />
~this.[[storedError]] ~SET ~undefined
◎
Set this.[[reader]] and this.[[storedError]] to undefined.
</li>
	<li>
~this.[[disturbed]] ~SET ~false
◎
Set this.[[disturbed]] to false.
</li>
	<li>
~this.[[readableStreamController]] ~SET ~undefined
◎
Set this.[[readableStreamController]] to undefined.
</li>
	<li>
%type ~LET
? `GetV$A( %underlyingSource, `type^l )
◎
Let type be ? GetV(underlyingSource, "type").
</li>
	<li>
%typeString ~LET
? `ToString$A( %type )
◎
Let typeString be ? ToString(type).
</li>
	<li>
<p>
~IF
%typeString ~EQ `bytes^l
：
◎
If typeString is "bytes",
</p>
		<ol>
			<li>
~IF
%highWaterMark ~EQ ~undefined
⇒
%highWaterMark ~LET `0^b
◎
If highWaterMark is undefined, let highWaterMark be 0.
</li>
			<li>
~this.[[readableStreamController]] ~SET
? `Construct$A( `ReadableByteStreamController$C, « ~this, %underlyingSource, %highWaterMark » )
◎
Set this.[[readableStreamController]] to ? Construct(ReadableByteStreamController, « this, underlyingSource, highWaterMark »).
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF
%type ~EQ ~undefined
：
◎
Otherwise, if type is undefined,
</p>
		<ol>
			<li>
~IF
%highWaterMark ~EQ ~undefined
⇒
%highWaterMark ~LET `1^b
◎
If highWaterMark is undefined, let highWaterMark be 1.
</li>
			<li>
~this.[[readableStreamController]] ~SET
? `Construct$A( `ReadableStreamDefaultController$C, « ~this, %underlyingSource, %size, %highWaterMark » )
◎
Set this.[[readableStreamController]] to ? Construct(ReadableStreamDefaultController, « this, underlyingSource, size, highWaterMark »).
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
~THROW `RangeError^b
◎
Otherwise, throw a RangeError exception.
</li>
</ol>

			</section>
			<section id="rs-prototype">
<h4 title="Properties of the ReadableStream Prototype">3.2.4. `ReadableStream^C ~prototypeの各種~prop</h4>


				<section id="rs-locked">
<h5>3.2.4.1. `get locked^rs</h5>

<div class="note">

<p>
`locked^rs 取得子は、可読~streamが`読取器に~lock$されているかどうかを返す。
◎
The locked getter returns whether or not the readable stream is locked to a reader.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStream$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStream(this) is false, throw a TypeError exception.
</li>
	<li>
~RET
! `IsReadableStreamLocked$A( ~this )
◎
Return ! IsReadableStreamLocked(this).
</li>
</ol>

				</section>
				<section id="rs-cancel">
<h5>3.2.4.2. `cancel(reason)^rs</h5>

<div class="note">

<p>
`cancel()^rs ~methodは、~streamを`取消-$して，［
`消費器$が~streamへの関心を失った
］ことを合図する。
給された %reason 引数は、下層~源に~~渡される
— 利用されるとは限らないが。
◎
The cancel method cancels the stream, signaling a loss of interest in the stream by a consumer. The supplied reason argument will be given to the underlying source, which may or may not use it.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStream$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsReadableStream(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
! `IsReadableStreamLocked$A( ~this ) ~EQ ~true
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsReadableStreamLocked(this) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
! `ReadableStreamCancel$A( ~this, %reason )
◎
Return ! ReadableStreamCancel(this, reason).
</li>
</ol>

				</section>
				<section id="rs-get-reader">
<h5>3.2.4.3. `getReader({ mode } = {})^rs</h5>

<div class="note">

<p>
`getReader()^rs ~methodは、 %mode ~optionに指定される型の読取器を作成して返すと同時に，~streamを その新たな読取器に`~lockする$。
~streamが`~lockされ$ている間は、`解放-$されるまで，他の読取器は~lockを獲得できなくなる。
◎
The getReader method creates a reader of the type specified by the mode option and locks the stream to the new reader. While the stream is locked, no other reader can be acquired until this one is released.
</p>

<p>
この機能性は、［［
~streamを，それ全体として消費する能
］を欲するような，抽象化
］を創出するときに，とりわけ有用になる。
利用者は、~streamに対する読取器を取得することにより，［
他から［
読取が差挟まれたり，~streamが取消される
］ことにより，自身による抽象化が干渉される
］ことがないことを確保できる。
◎
This functionality is especially useful for creating abstractions that desire the ability to consume a stream in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours or cancel the stream, which would interfere with your abstraction.
</p>

<p>
%mode ~EQ ~undefined の場合、この~methodは `既定の読取器$（ `ReadableStreamDefaultReader$C の~instance）を作成する。
この読取器は、読取器の `read()$dr ~methodを介して，~streamから個々の`~chunk$を直接的に読取する能を提供する。
◎
When mode is undefined, the method creates a default reader (an instance of ReadableStreamDefaultReader). The reader provides the ability to directly read individual chunks from the stream via the reader’s read() method.
</p>

<p>
%mode ~EQ `byob^l の場合、この~methodは `~BYOB読取器$（ `ReadableStreamBYOBReader$C の~instance）を作成する。
この特色機能は、`可読~byte~stream$
— すなわち、 “開発者が~bufferを給する” 読取りを取扱う能を 特に備えるように構築された~stream —
上でのみ働く。
この読取器は、読取器の `read()$byob ~methodを介して，［
~streamから開発者から給された~bufferの中へ 個々の`~chunk$を直接的に読取する能
］を提供し、~bufferの割当てをより精確に制御できるようにする。
◎
When mode is "byob", the getReader method creates a BYOB reader (an instance of ReadableStreamBYOBReader). This feature only works on readable byte streams, i.e. streams which were constructed specifically with the ability to handle "bring your own buffer" reading. The reader provides the ability to directly read individual chunks from the stream via the reader’s read() method, into developer-supplied buffers, allowing more precise control over allocation.
</p>

</div>



<ol class="algo">
	<li>
~IF
! `IsReadableStream$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStream(this) is false, throw a TypeError exception.
</li>
	<li>
~IF
%mode ~EQ `byob^l
⇒
~RET
? `AcquireReadableStreamBYOBReader$A( ~this )
◎
If mode is "byob", return ? AcquireReadableStreamBYOBReader(this).
</li>
	<li>
~IF
%mode ~EQ ~undefined
⇒
~RET
? `AcquireReadableStreamDefaultReader$A( ~this )
◎
If mode is undefined, return ? AcquireReadableStreamDefaultReader(this).
</li>
	<li>
~THROW `RangeError^b
◎
Throw a RangeError exception.
</li>
</ol>

<div class="example" id="example-read-all-chunks">

<p>
読取器を利用すれば便益を得られるであろう抽象化の例として、可読~stream全体を`~chunk$の配列として記憶域の中に読取するように設計された，次のような関数がある：
◎
An example of an abstraction that might benefit from using a reader is a function like the following, which is designed to read an entire readable stream into memory as an array of chunks.
</p>

<pre class="lang-javascript">
function readAllChunks(%readableStream) {
  const %reader = %readableStream.getReader();
  const %chunks = [];

  return pump();

  function pump() {
    return %reader.read().then(({ %value, %done }) =&gt; {
      if (%done) {
        return %chunks;
      }

      %chunks.push(%value);
      return pump();
    });
  }
}
</pre>

<p>
最初に 読取器を得ることで、読取器を排他的に利用していることに注意。
これにより、他の消費器は，［
~chunkを読取したり, ~streamを`取消す$ことにより，~streamに干渉する
］ことはできなくなる。
◎
Note how the first thing it does is obtain a reader, and from then on it uses the reader exclusively. This ensures that no other consumer can interfere with the stream, either by reading chunks or by canceling the stream.
</p>

</div>


				</section>
				<section id="rs-pipe-through">
<h5>3.2.4.4. `pipeThrough({ writable, readable }, options)^rs</h5>

<div class="note">

<p>
`pipeThrough()^rs ~methodは、［
`形式変換~stream$（または，他の 
<code >{ %writable, %readable }</code>
~pair）を通して，この`可読~stream$を`~pipeする$
］ための，簡便かつ連鎖可能な仕方を提供する。
それは 単純に、給された~pairの可書~側へ~streamを~pipeして，更なる利用のために 可読~側を返す。
◎
The pipeThrough method provides a convenient, chainable way of piping this readable stream through a transform stream (or any other { writable, readable } pair). It simply pipes the stream into the writable side of the supplied pair, and returns the readable side for further use.
</p>

<p>
一般に，~streamが~pipeされている間は、他の消費器が読取器を獲得できないように，~streamは`~lockされ$る。
◎
Piping a stream will generally lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
</p>

<p>
この~methodは、その ~this 値が `ReadableStream$C ~objであることを要求しない点で，意図的に汎化してある。
また、その［
%writable ／ %readable
］引数が［
`WritableStream$C ／ `ReadableStream$C
］の~instanceであることも要求しない。
◎
This method is intentionally generic; it does not require that its this value be a ReadableStream object. It also does not require that its writable argument be a WritableStream instance, or that its readable argument be a ReadableStream instance.
</p>

</div>

<ol class="algo">
	<li>
%promise ~LET
? `Invoke$A( ~this, `pipeTo^l, « %writable, %options » )
◎
Let promise be ? Invoke(this, "pipeTo", « writable, options »).
</li>
	<li>
~IF［
`Type$A( %promise ) ~EQ `Object^b
］~AND［
%promise は [[PromiseIsHandled]] 内部~slotを持つ
］
⇒
%promise.[[PromiseIsHandled]] ~SET ~true
◎
If Type(promise) is Object and promise has a [[PromiseIsHandled]] internal slot, set promise.[[PromiseIsHandled]] to true.
</li>
	<li>
~RET %readable
◎
Return readable.
</li>
</ol>

<div class="example" id="example-pipe-chain">

<p>
`pipeThrough(transform, options)$rs
を利用して`~pipe鎖$を構築する典型~例：
◎
A typical example of constructing pipe chain using pipeThrough(transform, options) would look like
</p>

<pre class="lang-javascript">
%httpResponseBody
  .pipeThrough(%decompressorTransform)
  .pipeThrough(%ignoreNonImageFilesTransform)
  .pipeTo(%mediaGallery);
</pre>

</div>


				</section>
				<section id="rs-pipe-to">
<h5>3.2.4.5. `pipeTo(dest, { preventClose, preventAbort, preventCancel } = {})^rs</h5>

<div class="note">

<p>
`pipeTo()^rs ~methodは、この`可読~stream$を，所与の`可書~stream$に`~pipeする$。
~piping処理における 種々の~error条態の下での挙動は、渡される %options （ `{ ... }^c ）により~customizeできる。
この~methodは、~piping処理が［
成功裡に完了したときに充足される／
何らかの~errorに遭遇したときに却下される
］ような~promiseを返す。
◎
The pipeTo method pipes this readable stream to a given writable stream. The way in which the piping process behaves under various error conditions can be customized with a number of passed options. It returns a promise that fulfills when the piping process completes successfully, or rejects if any errors were encountered.
</p>

<p>
~streamが~pipeされている間は、他の消費器が読取器を獲得できないように，~streamを`~lockする$。
◎
Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
</p>

<p>
源の`可読~stream$ %source,
行先の`可書~stream$ %dest
における［
~error／~closure
］は、次に従って伝播する：
◎
Errors and closures of the source and destination streams propagate as follows:
</p>

<ul>
	<li>
%source における~errorは、［
`preventAbort^c が~truthy
］でない限り，
%dest を`中止-$することになる。
返される~promiseは，［
%source における~error, または
%dest を中止する間に~errorが生じたなら それ
］で却下されることになる。
◎
An error in the source readable stream will abort the destination writable stream, unless preventAbort is truthy. The returned promise will be rejected with the source’s error, or with any error that occurs during aborting the destination.
</li>
	<li>
%dest における~errorは、［
`preventAbort^c が~truthy
］でない限り，
%source を`取消す$ことになる。
返される~promiseは，［
%dest における~error, または %source を取消す間に~errorが生じた場合は それ
］で却下されることになる。
◎
An error in the destination writable stream will cancel the source readable stream, unless preventCancel is truthy. The returned promise will be rejected with the destination’s error, or with any error that occurs during canceling the source.
</li>
	<li>
%source が~closeしたときは、［
`preventClose^c ~EQ ~true
］でない限り，
%dest も~closeさせることになる。
返される~promiseは、この処理が完了した時点で充足されることになる
— ただし、行先を~closeしている間に~errorに遭遇した場合は、その~errorで却下されることになる。
◎
When the source readable stream closes, the destination writable stream will be closed, unless preventClose is true. The returned promise will be fulfilled once this process completes, unless an error is encountered while closing the destination, in which case it will be rejected with that error.
</li>
	<li>
%dest が［
~closeした／~closeされ始めた
］場合、［
`preventCancel^c ~EQ ~true
］でない限り，
%source を`取消す$ことになる。
返される~promiseは，［
~closeされた~streamへの~pipingが失敗したことを指示する~error, または
%source を取消す間に生じた~error
］で却下されることになる。
◎
If the destination writable stream starts out closed or closing, the source readable stream will be canceled, unless preventCancel is true. The returned promise will be rejected with an error indicating piping to a closed stream failed, or with any error that occurs during canceling the source.
</li>
</ul>

</div>


<ol class="algo">
	<li>
~IF
! `IsReadableStream$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsReadableStream(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
! `IsWritableStream$A( %dest ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsWritableStream(dest) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
%preventClose ~SET
! `ToBoolean$A( %preventClose )；<br>
%preventAbort ~SET
! `ToBoolean$A( %preventAbort )；<br>
%preventCancel ~SET
! `ToBoolean$A( %preventCancel )
◎
Set preventClose to ! ToBoolean(preventClose), set preventAbort to ! ToBoolean(preventAbort), and set preventCancel to ! ToBoolean(preventCancel).
</li>
	<li>
~IF
! `IsReadableStreamLocked$A( ~this ) ~EQ ~true
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsReadableStreamLocked(this) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
! `IsWritableStreamLocked$A( %dest ) ~EQ ~true
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsWritableStreamLocked(dest) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
! `IsReadableByteStreamController$A( ~this.[[readableStreamController]] ) ~EQ ~true
⇒
%reader ~LET ~UAの裁量で
⇒
! `AcquireReadableStreamBYOBReader$A( ~this )
または
! `AcquireReadableStreamDefaultReader$A( ~this )
◎
If ! IsReadableByteStreamController(this.[[readableStreamController]]) is true, let reader be either ! AcquireReadableStreamBYOBReader(this) or ! AcquireReadableStreamDefaultReader(this), at the user agent’s discretion.
</li>
	<li>
~ELSE
⇒
%reader ~LET
! `AcquireReadableStreamDefaultReader$A( ~this )
◎
Otherwise, let reader be ! AcquireReadableStreamDefaultReader(this).
</li>
	<li>
%writer ~LET
! `AcquireWritableStreamDefaultWriter$A( %dest )
◎
Let writer be ! AcquireWritableStreamDefaultWriter(dest).
</li>
	<li>
%shuttingDown ~LET ~false
◎
Let shuttingDown be false.
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
( %reader, %writer )
を用いて，`並列的$に、 ~this から すべての`~chunk$を読取して %dest に書込する。
これが起こる正確な方式は、
( 読取器, 書込器 )
が提供する~lock法に因り，作者~codeからは観測できない。
よって，~UAには これを柔軟に行う余地があるが、利用される正確な~algoが何であれ，次の拘束が適用される：
◎
In parallel, using reader and writer, read all chunks from this and write them to dest. Due to the locking provided by the reader and writer, the exact manner in which this happens is not observable to author code, and so there is flexibility in how this is done. The following constraints apply regardless of the exact algorithm used:
</p>

		<ul>
			<li>
<strong>~public~APIは利用されては~MUST_NOT</strong>：
— ［
読取り／書込み
］の間, および
以下に挙げる演算を遂行している間は、何かを改変し得るような~JSの［
読取器, 書込器, ~stream~API
］（すなわち，適切な~prototype上の各種~method）は、利用されては~MUST_NOT
— ~streamは，直接的に操作され~MUST。
◎
Public API must not be used: while reading or writing, or performing any of the operations below, the JavaScript-modifiable reader, writer, and stream APIs (i.e. methods on the appropriate prototypes) must not be used. Instead, the streams must be manipulated directly.
</li>
			<li>
<p>
<strong>背圧は施行され~MUST</strong>
— ~UAは：
◎
Backpressure must be enforced:
</p>
				<ul>
					<li>
`WritableStreamDefaultWriterGetDesiredSize$A( %writer ) が［
≤ `0^b ~OR ~EQ `null^b
］である間は、 %reader から読取しては~MUST_NOT。
◎
While WritableStreamDefaultWriterGetDesiredSize(writer) is ≤ 0 or is null, the user agent must not read from reader.
</li>
					<li>
%reader が`~BYOB読取器$である場合
⇒
%reader から読取する~chunkの~sizeを決定するときには，
`WritableStreamDefaultWriterGetDesiredSize$A( %writer )
を利用するべきである。
◎
If reader is a BYOB reader, WritableStreamDefaultWriterGetDesiredSize(writer) should be used to determine the size of the chunks read from reader.
</li>
					<li>
~ELSE_
⇒
`WritableStreamDefaultWriterGetDesiredSize$A( %writer ) 
を利用して、経験的に~flow~rateを決定してよい
— 例：
読取される~chunkの代表的な~sizeと比較して “低い” ものと判定される間は、読取を遅延することにより。
◎
Otherwise, WritableStreamDefaultWriterGetDesiredSize(writer) may be used to determine the flow rate heuristically, e.g. by delaying reads while it is judged to be "low" compared to the size of chunks that have been typically read.
</li>
				</ul>
			</li>
			<li>
<strong>~shutdownは、すべての活動を停止させ~MUST</strong>
— %shuttingDown が ~true になって以降は、~UAは，それ以上［
%reader からの読取 ／ %writer への書込
］を起動しては~MUST_NOT（進行中の 読取／書込 は、終えてよい）。
特に，~UAは、［
~this.[[state]], および %dest.[[state]]
］上で［
読取／書込
］を遂行する前に，以下の条件を検査し~MUST
— それらは、即時に~shutdownに至らせることもあるので。
◎
Shutdown must stop all activity: if shuttingDown becomes true, the user agent must not initiate further reads from reader or writes to writer. (Ongoing reads and writes may finish.) In particular, the user agent must check the below conditions on this.[[state]] and dest.[[state]] before performing any reads or writes, since they might lead to immediate shutdown.
</li>
			<li>
<p>
<strong>~errorは前方へ伝播され~MUST</strong>
— ~this.[[state]] ~EQ `errored^l のとき, または そうなったときは：
◎
Errors must be propagated forward: if this.[[state]] is or becomes "errored", then
</p>
				<ol>
					<li>
~IF
%preventAbort ~EQ ~false
⇒
( ~this.[[storedError]], 次の動作 )
を与える下で，`~shutdown$する
⇒
! `WritableStreamAbort$A( %dest, ~this.[[storedError]] )
◎
If preventAbort is false, shutdown with an action of ! WritableStreamAbort(dest, this.[[storedError]]) and with this.[[storedError]].
</li>
					<li>
~ELSE
⇒
( ~this.[[storedError]], ε )
を与える下で，`~shutdown$する
◎
Otherwise, shutdown with this.[[storedError]].
</li>
				</ol>
			</li>
			<li>
<p>
<strong>~errorは後方へ伝播され~MUST</strong>
— %dest.[[state]] ~EQ `errored^l のとき, または そうなったときは：
◎
Errors must be propagated backward: if dest.[[state]] is or becomes "errored", then
</p>
				<ol>
					<li>
~IF
%preventCancel ~EQ ~false
⇒
( %dest.[[storedError]], 次の動作 )
を与える下で，`~shutdown$する
⇒
! `ReadableStreamCancel$A( ~this, %dest.[[storedError]] )

◎
If preventCancel is false, shutdown with an action of ! ReadableStreamCancel(this, dest.[[storedError]]) and with dest.[[storedError]].
</li>
					<li>
~ELSE
⇒
( %dest.[[storedError]], ε )
を与える下で，`~shutdown$する
◎
Otherwise, shutdown with dest.[[storedError]].
</li>
				</ol>
			</li>
			<li>
<p>
<strong>~closingは前方へ伝播され~MUST</strong>
— ~this.[[state]] ~EQ `closed^l のとき, または そうなったときは：
◎
Closing must be propagated forward: if this.[[state]] is or becomes "closed", then
</p>
				<ol>
					<li>
~IF
%preventClose ~EQ ~false
⇒
( ε, 次の動作 )
を与える下で，`~shutdown$する
⇒
! `WritableStreamDefaultWriterCloseWithErrorPropagation$A( %writer )
◎
If preventClose is false, shutdown with an action of ! WritableStreamDefaultWriterCloseWithErrorPropagation(writer).
</li>
					<li>
~ELSE
⇒
( ε, ε )
を与える下で，`~shutdown$する
◎
Otherwise, shutdown.
</li>
				</ol>
			</li>
			<li>
<p>
<strong>~closingは後方へ伝播され~MUST</strong>
—
［
! `WritableStreamCloseQueuedOrInFlight$A( %dest ) ~EQ ~true
］~OR［
%dest.[[state]] ~EQ `closed^l
］のときは：
◎
Closing must be propagated backward: if ! WritableStreamCloseQueuedOrInFlight(dest) is true or dest.[[state]] is "closed", then
</p>
				<ol>
					<li>
%destClosed ~LET 新たな `TypeError^b
◎
Let destClosed be a new TypeError.
</li>
					<li>
~IF
%preventCancel ~EQ ~false
⇒
( %destClosed, 次の動作 )
を与える下で，`~shutdown$する
⇒
! `ReadableStreamCancel$A( ~this, %destClosed )
◎
If preventCancel is false, shutdown with an action of ! ReadableStreamCancel(this, destClosed) and with destClosed.
</li>
	<li>
~ELSE
⇒
( %destClosed, ε )
を与える下で，`~shutdown$する
◎
Otherwise, shutdown with destClosed.
</li>
		</ol>
	</li>
	<li>
<p id="rs-pipeTo-shutdown">
上のいずれかの要件／手続きにより，
`~shutdown@
するよう請われたときは、所与の
( %error, %action )
に対し，次の下位手続きを遂行する：
◎
Shutdown with an action: if any of the above requirements ask to shutdown with an action action, optionally with an error originalError, then:
</p>
				<ol>
					<li>
~IF
%shuttingDown ~EQ ~true
⇒
~RET
◎
If shuttingDown is true, abort these substeps.
</li>
					<li>
%shuttingDown ~SET ~true
◎
Set shuttingDown to true.
</li>
					<li>
進行中の書込があれば，それが終わるまで（すなわち，対応する~promiseが決着するまで）待機する。
◎
Wait until any ongoing write finishes (i.e. the corresponding promises settle).
</li>
					<li>
<p>
~IF
%action ~EQ ε
：
</p>
						<ol>
							<li>
%error で`完結する$
</li>
							<li>
~RET
</li>
						</ol>
◎
↓↓</li>
					<li>
%p ~LET %action を遂行した結果
◎
Let p be the result of performing action.
</li>
					<li>
%p の`充足~時$には
⇒
%error で`完結する$
◎
Upon fulfillment of p, finalize, passing along originalError if it was given.
</li>
					<li>
事由 %newError による %p の`却下~時$には
⇒
%newError で`完結する$
◎
Upon rejection of p with reason newError, finalize with newError.
</li>
				</ol>

<div class="p">
<p class="trans-note">【
この手続きは、原文では， 2 つに分けて記されているが（ %action ~EQ ε の場合と 非 ε の場合）、表記の都合により この訳では一つに集約している。
】
</p>
<span lang="en" style="white-space:pre-line">
Shutdown: if any of the above requirements or steps ask to shutdown, optionally with an error error, then:
• If shuttingDown is true, abort these substeps.
• Set shuttingDown to true.
• Wait until any ongoing write finishes (i.e. the corresponding promises settle).
• Finalize, passing along error if it was given.
</span>
</div>

			</li>
			<li>
<p>
所与の %error で
`完結する@
下位手続きは、次を遂行する：
◎
Finalize: both forms of shutdown will eventually ask to finalize, optionally with an error error, which means to perform the following steps:
</p>
				<ol>
					<li>
! `WritableStreamDefaultWriterRelease$A( %writer )
を遂行する
◎
Perform ! WritableStreamDefaultWriterRelease(writer).
</li>
					<li>
! `ReadableStreamReaderGenericRelease$A( %reader )
を遂行する
◎
Perform ! ReadableStreamReaderGenericRelease(reader).
</li>
					<li>
~IF
%error ~NEQ ε
⇒
%error で %promise を`却下する$
◎
If error was given, reject promise with error.
</li>
					<li>
~ELSE
⇒
`undefined^b で %promise を`解決する$
◎
Otherwise, resolve promise with undefined.
</li>
					</ol>
				</li>
			</ul>
		</li>
	<li>
~RET %promise 
◎
Return promise.
</li>
</ol>
				</section>
				<section id="rs-tee">
<h5>3.2.4.6. `tee()^rs</h5>

<div class="note">

<p>
`tee()^rs （二叉化-）~methodは、この可読~streamを`二叉化-$して、その結果の，［
それぞれが新たな `ReadableStream$C ~instanceである， 2 個の`分岐$
］からなる~~長さ 2 の配列を返す。
◎
The tee method tees this readable stream, returning a two-element array containing the two resulting branches as new ReadableStream instances.
</p>

<p>
~streamを二叉化すると，それを`~lock$し，他の消費器は読取器を獲得できなくなる。
~streamを`取消す$ためには、結果の分岐を両者とも取消す
— しかる後、この複合的な取消~事由が，~streamの`下層~源$まで伝播されることになる。
◎
Teeing a stream will lock it, preventing any other consumer from acquiring a reader. To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be propagated to the stream’s underlying source.
</p>

<p>
各~分岐~内で見える`~chunk$たちは 同じ~objになるので、~chunkが変異不可でない場合， 2 個の分岐~間で互いに干渉し合うことも許容されることに注意。
（ `tee()^rs に対し，［
その各~分岐における各~chunkに対し，`有構造~clone$を作成する
］ような~optionを追加するべきと考えるなら、
<a href="~STREAMS/issues/new">意見を寄せられたし</a>。）
◎
Note that the chunks seen in each branch will be the same object. If the chunks are not immutable, this could allow interference between the two branches. (Let us know if you think we should add an option to tee that creates structured clones of the chunks for each branch.)
</p>

</div>

<ol class="algo">

<li>
~IF
! `IsReadableStream$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStream(this) is false, throw a TypeError exception.
</li>
<li>
%branches ~LET
? `ReadableStreamTee$A( ~this, ~false )
◎
Let branches be ? ReadableStreamTee(this, false).
</li>
<li>
~RET
! `CreateArrayFromList$A( %branches )
◎
Return ! CreateArrayFromList(branches).
</li>
</ol>

<div class="example" id="example-tee-and-pipe">

<p>
~streamの二叉化は、~streamを 2 個の独立な消費器から並列的に
— おそらく異なる速度で —
読取させたいと望むときに最も有用になる。
例えば、［
~disk上の~fileを表現している可書~stream %cacheEntry
］と, ［
~remote~serverへの~uploadを表現している別の可書~stream %httpRequestBody
］が与えられたとき、同じ可読~streamを，同時に両~行先へ~pipeすることもできる：
◎
Teeing a stream is most useful when you wish to let two independent consumers read from the stream in parallel, perhaps even at different speeds. For example, given a writable stream cacheEntry representing an on-disk file, and another writable stream httpRequestBody representing an upload to a remote server, you could pipe the same readable stream to both destinations at once:
</p>

<pre class="lang-javascript">
const [%forLocal, %forRemote] = %readableStream.tee();
Promise.all([
  %forLocal.pipeTo(%cacheEntry),
  %forRemote.pipeTo(%httpRequestBody)
])
.then(() =&gt; console.log(
    `~streamは ~cacheに保存され, ~uploadされました^l))
.catch(%e =&gt; console.error(
    `~cache時または~upload時に失敗しました: ^l, %e));
</pre>
<!-- 
"Saved the stream to the cache and also uploaded it!"
"Either caching or uploading failed: "
 -->
</div>

				</section>
			</section>
		</section>
		<section id="rs-abstract-ops">
<h3 title="General Readable Stream Abstract Operations">3.3.一般の可読~stream抽象~演算</h3>

<p>
以下の抽象~演算は、この仕様の大部分と違って，他の仕様からも 一般に有用になるよう意図されている
— 単に，この仕様の各種~classの実装の一部としてではなく。
◎
The following abstract operations, unlike most in this specification, are meant to be generally useful by other specifications, instead of just being part of the implementation of this spec’s classes.
</p>



			<section id="acquire-readable-stream-byob-reader">
<h4 class="throws">3.3.1. `AcquireReadableStreamBYOBReader ( stream )^A</h4>

<p>
この抽象~演算は、所与の~streamから`~BYOB読取器$を獲得したいと望むような，他の仕様から~callされる用途に意図されている。
◎
This abstract operation is meant to be called from other specifications that may wish to acquire a BYOB reader for a given stream.
</p>

<ol class="algo">
	<li>
~RET
? `Construct$A( `ReadableStreamBYOBReader$C, « %stream » )
◎
Return ? Construct(ReadableStreamBYOBReader, « stream »).
</li>
</ol>

			</section>
			<section id="acquire-readable-stream-default-reader">
<h4 class="throws">3.3.2. `AcquireReadableStreamDefaultReader ( stream )^A</h4>

<p>
この抽象~演算は、所与の~streamから`既定の読取器$を獲得したいと望むような，他の仕様から~callされる用途に意図されている。
◎
This abstract operation is meant to be called from other specifications that may wish to acquire a default reader for a given stream.
</p>

<ol class="algo">
	<li>
~RET
? `Construct$A( `ReadableStreamDefaultReader$C, « %stream » )
◎
Return ? Construct(ReadableStreamDefaultReader, « stream »).
</li>
</ol>

			</section>
			<section id="is-readable-stream">
<h4 class="nothrow">3.3.3. `IsReadableStream ( x )^A</h4>

<ol class="algo">
	<li>
~IF
`Type$A(%x) ~NEQ `Object^b
⇒
~RET ~false
◎
If Type(x) is not Object, return false.
</li>
	<li>
~IF
%x は [[readableStreamController]] 内部~slotを持たない
⇒
~RET ~false
◎
If x does not have a [[readableStreamController]] internal slot, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="is-readable-stream-disturbed">
<h4 class="nothrow">3.3.4. `IsReadableStreamDisturbed ( stream )^A</h4>

<p>
この抽象~演算は、［
可読~streamは一度でも読取されたか取消されたかどうか
］を照会したいと望むような，他の仕様から~callされる用途に意図されている。
◎
This abstract operation is meant to be called from other specifications that may wish to query whether or not a readable stream has ever been read from or canceled.
</p>

<ol class="algo">
	<li>
~Assert：
! `IsReadableStream$A( %stream ) ~EQ ~true
◎
Assert: ! IsReadableStream(stream) is true.
</li>
	<li>
~RET %stream.[[disturbed]]
◎
Return stream.[[disturbed]].
</li>
</ol>

			</section>
			<section id="is-readable-stream-locked">
<h4 class="nothrow">3.3.5. `IsReadableStreamLocked ( stream )^A</h4>

<p>
この抽象~演算は、［
可読~streamが`読取器に~lock$されているかどうか
］を照会したいと望むような，他の仕様から~callされる用途に意図されている。
◎
This abstract operation is meant to be called from other specifications that may wish to query whether or not a readable stream is locked to a reader.
</p>

<ol class="algo">
	<li>
~Assert：
! `IsReadableStream$A( %stream ) ~EQ ~true
◎
Assert: ! IsReadableStream(stream) is true.
</li>
	<li>
~IF
%stream.[[reader]] ~EQ ~undefined
⇒
~RET ~false
◎
If stream.[[reader]] is undefined, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="readable-stream-tee">
<h4 class="throws">3.3.6. `ReadableStreamTee ( stream, cloneForBranch2 )^A</h4>

<p>
この抽象~演算は、所与の可読~streamを`二叉化-$したいと望むような，他の仕様から~callされる用途に意図されている。
◎
This abstract operation is meant to be called from other specifications that may wish to tee a given readable stream.
</p>

<p>
2 個目の引数 %cloneForBranch2 は、［
元の~streamからの~dataが，［
2 個目の分岐~内に現れる前に，`有構造~clone$される `HTML$r
］かどうか
］を統治する。
これは、両 分岐が消費されるとき
— ~chunkの転送-時など —
互いに干渉しあうおそれがある局面で有用になる。
しかしながら、両 分岐の間に 外から見える非対称性も もたらされることになる。
◎
The second argument, cloneForBranch2, governs whether or not the data from the original stream will be structured cloned before appearing in the second of the returned branches. This is useful for scenarios where both branches are to be consumed in such a way that they might otherwise interfere with each other, such as by transfering their chunks. However, it does introduce a noticable asymmetry between the two branches. [HTML]
</p>

<ol class="algo">
	<li>
~Assert：
! `IsReadableStream$A( %stream ) ~EQ ~true
◎
Assert: ! IsReadableStream(stream) is true.
</li>
	<li>
~Assert：
`Type$A( %cloneForBranch2 ) ~EQ `Boolean^b
◎
Assert: Type(cloneForBranch2) is Boolean.
</li>
	<li>
%reader ~LET
? `AcquireReadableStreamDefaultReader$A( %stream )
◎
Let reader be ? AcquireReadableStreamDefaultReader(stream).
</li>
	<li>
%teeState ~LET `~Record$ {
<span class="record-entries"
>[[closedOrErrored]]: ~false,
[[canceled1]]: ~false,
[[canceled2]]: ~false,
[[reason1]]: ~undefined,
[[reason2]]: ~undefined,
[[promise]]: `新たな~promise$
</span>
}
◎
Let teeState be Record {[[closedOrErrored]]: false, [[canceled1]]: false, [[canceled2]]: false, [[reason1]]: undefined, [[reason2]]: undefined, [[promise]]: a new promise}.
</li>
	<li>
%pull ~LET 新たな `~ReadableStreamTee~pull関数$
◎
Let pull be a new ReadableStreamTee pull function.
</li>
	<li>
%pull.[[reader]] ~SET %reader；<br>
%pull.[[teeState]] ~SET %teeState；<br>
%pull.[[cloneForBranch2]] ~SET %cloneForBranch2
◎
Set pull.[[reader]] to reader, pull.[[teeState]] to teeState, and pull.[[cloneForBranch2]] to cloneForBranch2.
</li>
	<li>
%cancel1 ~LET 新たな`~ReadableStreamTee第一~分岐 取消-関数$
◎
Let cancel1 be a new ReadableStreamTee branch 1 cancel function.
</li>
	<li>
%cancel1.[[stream]] ~SET %stream；<br>
%cancel1.[[teeState]] ~SET %teeState
◎
Set cancel1.[[stream]] to stream and cancel1.[[teeState]] to teeState.
</li>
	<li>
%cancel2 ~LET 新たな`~ReadableStreamTee第二~分岐 取消-関数$
◎
Let cancel2 be a new ReadableStreamTee branch 2 cancel function.
</li>
	<li>
%cancel2.[[stream]] ~SET %stream；<br>
%cancel2.[[teeState]] ~SET %teeState
◎
Set cancel2.[[stream]] to stream and cancel2.[[teeState]] to teeState.
</li>
	<li>
%underlyingSource1 ~LET
! `ObjectCreate$A( `~ObjectPrototype$ )
◎
Let underlyingSource1 be ! ObjectCreate(%ObjectPrototype%).
</li>
	<li>
! `CreateDataProperty$A( %underlyingSource1, `pull^l, %pull )
を遂行する
◎
Perform ! CreateDataProperty(underlyingSource1, "pull", pull).
</li>
	<li>
! `CreateDataProperty$A( %underlyingSource1, `cancel^l, %cancel1 )
を遂行する
◎
Perform ! CreateDataProperty(underlyingSource1, "cancel", cancel1).
</li>
	<li>
%branch1Stream ~LET
! `Construct$A( `ReadableStream$C, %underlyingSource1 )
◎
Let branch1Stream be ! Construct(ReadableStream, underlyingSource1).
</li>
	<li>
%underlyingSource2 ~LET
! `ObjectCreate$A( `~ObjectPrototype$ )
◎
Let underlyingSource2 be ! ObjectCreate(%ObjectPrototype%).
</li>
	<li>
! `CreateDataProperty$A( %underlyingSource2, `pull^l, %pull )
を遂行する
◎
Perform ! CreateDataProperty(underlyingSource2, "pull", pull).
</li>
	<li>
! `CreateDataProperty$A( %underlyingSource2, `cancel^l, %cancel2 )
を遂行する
◎
Perform ! CreateDataProperty(underlyingSource2, "cancel", cancel2).
</li>
	<li>
%branch2Stream ~LET
! `Construct$A( `ReadableStream$C, %underlyingSource2 )
◎
Let branch2Stream be ! Construct(ReadableStream, underlyingSource2).
</li>
	<li>
%pull.[[branch1]] ~SET %branch1Stream.[[readableStreamController]]
◎
Set pull.[[branch1]] to branch1Stream.[[readableStreamController]].
</li>
	<li>
%pull.[[branch2]] ~SET %branch2Stream.[[readableStreamController]]
◎
Set pull.[[branch2]] to branch2Stream.[[readableStreamController]].
</li>
	<li>
<p>
事由 %r による
%reader.[[closedPromise]] の`却下~時$には：
◎
Upon rejection of reader.[[closedPromise]] with reason r,
</p>
		<ol>
			<li>
<p>
~IF
%teeState.[[closedOrErrored]] ~EQ ~false
：
◎
If teeState.[[closedOrErrored]] is false, then:
</p>
				<ol>
					<li>
! `ReadableStreamDefaultControllerError$A( %pull.[[branch1]], %r )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerError(pull.[[branch1]], r).
</li>
					<li>
! `ReadableStreamDefaultControllerError$A( %pull.[[branch2]], %r )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerError(pull.[[branch2]], r).
</li>
					<li>
%teeState.[[closedOrErrored]] ~SET ~true
◎
Set teeState.[[closedOrErrored]] to true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET « %branch1Stream, %branch2Stream »
◎
Return « branch1Stream, branch2Stream ».
</li>
</ol>

<p>
`~ReadableStreamTee~pull関数@
は，組込みの匿名~関数であり、所与の`可読~stream読取器$から~dataを~pullして，
2 個の他の~stream（結付けられた二叉化-の各 “分岐”）の中へ~enqueueする。
この関数の各~instance %F は、内部~slotに［
[[reader]], [[branch1]], [[branch2]], [[teeState]],[[cloneForBranch2]]
］を持ち，~callされたときは 次の手続きを遂行する：
◎
A ReadableStreamTee pull function is an anonymous built-in function that pulls data from a given readable stream reader and enqueues it into two other streams ("branches" of the associated tee). Each ReadableStreamTee pull function has [[reader]], [[branch1]], [[branch2]], [[teeState]], and [[cloneForBranch2]] internal slots. When a ReadableStreamTee pull function F is called, it performs the following steps:
</p>

<ol class="algo">
	<li>
%reader ~LET %F.[[reader]]；<br>
%branch1 ~LET %F.[[branch1]]；<br>
%branch2 ~LET %F.[[branch2]]；<br>
%teeState ~LET %F.[[teeState]]；<br>
%cloneForBranch2 ~LET %F.[[cloneForBranch2]]
◎
Let reader be F.[[reader]], branch1 be F.[[branch1]], branch2 be F.[[branch2]], teeState be F.[[teeState]], and cloneForBranch2 be F.[[cloneForBranch2]].
</li>
	<li>
<p>
~RET 次に与える充足~handlerで
! `ReadableStreamDefaultReaderRead$A( %reader )
を`変形-$した結果
— 充足~handlerは、引数 %result をとり, 次の手続きを遂行する：
◎
Return the result of transforming ! ReadableStreamDefaultReaderRead(reader) with a fulfillment handler which takes the argument result and performs the following steps:
</p>

		<ol>
			<li>
~Assert：
`Type$A( %result ) ~EQ `Object^b
◎
Assert: Type(result) is Object.
</li>
			<li>
%value ~LET
? `Get$A( %result, `value^l )
◎
Let value be ? Get(result, "value").
</li>
			<li>
%done ~LET
? `Get$A( %result, `done^l )
◎
Let done be ? Get(result, "done").
</li>
			<li>
~Assert：
`Type$A( %done ) ~EQ `Boolean^b
◎
Assert: Type(done) is Boolean.
</li>
			<li>
<p>
~IF［
%done ~EQ ~true
］~AND［
%teeState.[[closedOrErrored]] ~EQ ~false
］：
◎
If done is true and teeState.[[closedOrErrored]] is false,
</p>
				<ol>
					<li>
<p>
~IF
%teeState.[[canceled1]] ~EQ ~false
：
◎
If teeState.[[canceled1]] is false,
</p>
						<ol>
							<li>
! `ReadableStreamDefaultControllerClose$A( %branch1 )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerClose(branch1).
</li>
						</ol>
					</li>
					<li>
<p>
~IF
%teeState.[[canceled2]] ~EQ ~false
：
◎
If teeState.[[canceled2]] is false,
</p>
						<ol>
							<li>
! `ReadableStreamDefaultControllerClose$A( %branch2 )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerClose(branch2).
</li>
						</ol>
					</li>
					<li>
%teeState.[[closedOrErrored]] ~SET ~true
◎
Set teeState.[[closedOrErrored]] to true.
</li>
				</ol>
			</li>
			<li>
~IF
%teeState.[[closedOrErrored]] ~EQ ~true
⇒
~RET
◎
If teeState.[[closedOrErrored]] is true, return.
</li>
			<li>
( %value1, %value2 ) ~LET ( %value, %value )
◎
Let value1 and value2 be value.
</li>
			<li>
~IF［
%teeState.[[canceled2]] ~EQ ~false
］~AND［
%cloneForBranch2 ~EQ ~true 
］
⇒
%value2 ~SET
? `StructuredClone$A( %value2 )
◎
If teeState.[[canceled2]] is false and cloneForBranch2 is true, set value2 to ? StructuredClone(value2).
</li>
			<li>
~IF
%teeState.[[canceled1]] ~EQ ~false 
⇒
? `ReadableStreamDefaultControllerEnqueue$A( %branch1, %value1 )
を遂行する
◎
If teeState.[[canceled1]] is false, perform ? ReadableStreamDefaultControllerEnqueue(branch1, value1).
</li>
			<li>
~IF
%teeState.[[canceled2]] ~EQ ~false
⇒
? `ReadableStreamDefaultControllerEnqueue$A( %branch2, %value2 )
を遂行する
◎
If teeState.[[canceled2]] is false, perform ? ReadableStreamDefaultControllerEnqueue(branch2, value2).
</li>
		</ol>
	</li>
</ol>

<p>
`~ReadableStreamTee第一~分岐 取消-関数@
は，組込みの匿名~関数であり、［
結付けられた二叉化-の 1 個目の分岐に対する取消
］に反応する。
この関数の各~instance %F は、内部~slotに［
[[stream]], [[teeState]]
］を持ち，引数 %reason を伴って~callされたときは 次の手続きを遂行する：
◎
A ReadableStreamTee branch 1 cancel function is an anonymous built-in function that reacts to the cancellation of the first of the two branches of the associated tee. Each ReadableStreamTee branch 1 cancel function has [[stream]] and [[teeState]] internal slots. When a ReadableStreamTee branch 1 cancel function F is called with argument reason, it performs the following steps:
</p>

<ol class="algo">
	<li>
%stream ~LET %F.[[stream]]；<br>
%teeState ~LET %F.[[teeState]]
◎
Let stream be F.[[stream]] and teeState be F.[[teeState]].
</li>
	<li>
%teeState.[[canceled1]] ~SET ~true
◎
Set teeState.[[canceled1]] to true.
</li>
	<li>
%teeState.[[reason1]] ~SET %reason 
◎
Set teeState.[[reason1]] to reason.
</li>
	<li>
<p>
~IF
%teeState.[[canceled2]] ~EQ ~true
：
◎
If teeState.[[canceled2]] is true,
</p>
		<ol>
			<li>
%compositeReason ~LET
! `CreateArrayFromList$A( « %teeState.[[reason1]], %teeState.[[reason2]] » )
◎
Let compositeReason be ! CreateArrayFromList(« teeState.[[reason1]], teeState.[[reason2]] »).
</li>
			<li>
%cancelResult ~LET
! `ReadableStreamCancel$A( %stream, %compositeReason )
◎
Let cancelResult be ! ReadableStreamCancel(stream, compositeReason).
</li>
			<li>
%cancelResult で
%teeState.[[promise]] を`解決する$
◎
Resolve teeState.[[promise]] with cancelResult.
</li>
		</ol>
	</li>
	<li>
~RET %teeState.[[promise]]
◎
Return teeState.[[promise]].
</li>
</ol>

<p>
`~ReadableStreamTee第二~分岐 取消-関数@
は，組込みの匿名~関数であり、［
結付けられた二叉化-の 2 個目の分岐に対する取消
］に反応する。
この関数の各~instance %F は、内部~slotに［
[[stream]], [[teeState]]
］を持ち，引数 %reason を伴って~callされたときは 次の手続きを遂行する：
◎
A ReadableStreamTee branch 2 cancel function is an anonymous built-in function that reacts to the cancellation of the second of the two branches of the associated tee. Each ReadableStreamTee branch 2 cancel function has [[stream]] and [[teeState]] internal slots. When a ReadableStreamTee branch 2 cancel function F is called with argument reason, it performs the following steps:
</p>

<ol class="algo">
	<li>
%stream ~LET %F.[[stream]]；<br>
%teeState ~LET %F.[[teeState]]
◎
Let stream be F.[[stream]] and teeState be F.[[teeState]].
</li>
	<li>
%teeState.[[canceled2]] ~SET ~true
◎
Set teeState.[[canceled2]] to true.
</li>
	<li>
%teeState.[[reason2]] ~SET %reason 
◎
Set teeState.[[reason2]] to reason.
</li>
	<li>
<p>
~IF
%teeState.[[canceled1]] ~EQ ~true
：
◎
If teeState.[[canceled1]] is true,
</p>
		<ol>
			<li>
%compositeReason ~LET
! `CreateArrayFromList$A( « %teeState.[[reason1]], %teeState.[[reason2]] » )
◎
Let compositeReason be ! CreateArrayFromList(« teeState.[[reason1]], teeState.[[reason2]] »).
</li>
			<li>
%cancelResult ~LET
! `ReadableStreamCancel$A( %stream, %compositeReason )
◎
Let cancelResult be ! ReadableStreamCancel(stream, compositeReason).
</li>
			<li>
%cancelResult で
%teeState.[[promise]] を`解決する$
◎
Resolve teeState.[[promise]] with cancelResult.
</li>
		</ol>
	</li>
	<li>
~RET %teeState.[[promise]]
◎
Return teeState.[[promise]].
</li>
</ol>

<div class="note">

<p>
ここに与えられた~algoは、［
~ReadableStreamTeeに対する各~callに対し，3 個の新たな関数~objが作成される
］ように書かれている。
これは、単なる単純化であり，実際には必要とされない
— 開発者~codeからは観測し得ないので。
例えば，~self-hosted実装は、［
これらの関数のための~methodを包含する~prototypeを持ち，状態が~instance変数として格納される
］ような~classを作成して，最適化することもできる。
◎
The algorithm given here is written such that three new function objects are created for each call to to ReadableStreamTee. This is just a simplification, and is not actually necessary, since it is unobservable to developer code. For example, a self-hosted implementation could optimize by creating a class whose prototype contains methods for these functions, with the state stored as instance variables.
</p>

</div>



			</section>
		</section>
		<section id="rs-abstract-ops-used-by-controllers">
<h3 title="Readable Stream Abstract Operations Used by Controllers">3.4. 制御器から利用される可読~stream抽象~演算</h3>

<p>
`ReadableStream$C ~classが，［［
単純な`可読~stream$
］, `可読~byte~stream$
］両者の挙動を単独の~classの中に~encapsulateする仕様は、多様になり得る~logicの大部分を， 2 種の制御器~class［
`ReadableStreamDefaultController$C, `ReadableByteStreamController$C
］の内側に集中させることにより、~~構成されている。
これらの~classは、［
~streamの`内部~queue$を管理する方法, および ~streamの［
`下層~源$／`下層~byte源$
］とやりとりするための［
~statefulな内部~slotの大部分, および抽象~演算
］を定義する。
◎
In terms of specification factoring, the way that the ReadableStream class encapsulates the behavior of both simple readable streams and readable byte streams into a single class is by centralizing most of the potentially-varying logic inside the two controller classes, ReadableStreamDefaultController and ReadableByteStreamController. Those classes define most of the stateful internal slots and abstract operations for how a stream’s internal queue is managed and how it interfaces with its underlying source or underlying byte source.
</p>

<p>
この節における抽象~演算は、制御器~実装から利用される~interfaceである
— それは、内部~状態の変化を［
`ReadableStream$C の~public~APIを通して可視になる，開発者が面する結果
］に翻訳して，結付けられている `ReadableStream$C ~objに影響させるためにある。
◎
The abstract operations in this section are interfaces that are used by the controller implementations to affect their associated ReadableStream object, translating those internal state changes into developer-facing results visible through the ReadableStream's public API.
</p>


			<section id="readable-stream-add-read-into-request">
<h4 class="nothrow">3.4.1. `ReadableStreamAddReadIntoRequest ( stream )^A</h4>

<ol class="algo">
	<li>
~Assert：
! `IsReadableStreamBYOBReader$A( %stream.[[reader]] ) ~EQ ~true
◎
Assert: ! IsReadableStreamBYOBReader(stream.[[reader]]) is true.
</li>
	<li>
~Assert：
%stream.[[state]] ~IN { `readable^l, `closed^l }
◎
Assert: stream.[[state]] is "readable" or "closed".
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%readIntoRequest ~LET `~Record$ { [[promise]]: %promise }
◎
Let readIntoRequest be Record {[[promise]]: promise}.
</li>
	<li>
%readIntoRequest を %stream.[[reader]].[[readIntoRequests]] の~~末尾に付加する
◎
Append readIntoRequest as the last element of stream.[[reader]].[[readIntoRequests]].
</li>
	<li>
~RET %promise 
◎
Return promise.
</li>
</ol>

			</section>
			<section id="readable-stream-add-read-request">
<h4 class="nothrow">3.4.2. `ReadableStreamAddReadRequest ( stream )^A</h4>

<ol class="algo">
	<li>
~Assert：
! `IsReadableStreamDefaultReader$A( %stream.[[reader]] ) ~EQ ~true
◎
Assert: ! IsReadableStreamDefaultReader(stream.[[reader]]) is true.
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%readRequest ~LET `~Record$ { [[promise]]: %promise }
◎
Let readRequest be Record {[[promise]]: promise}.
</li>
	<li>
%readRequest を %stream.[[reader]].[[readRequests]] の~~末尾に付加する
◎
Append readRequest as the last element of stream.[[reader]].[[readRequests]].
</li>
	<li>
~RET %promise 
◎
Return promise.
</li>
</ol>

			</section>
			<section id="readable-stream-cancel">
<h4 class="nothrow">3.4.3. `ReadableStreamCancel ( stream, reason )^A</h4>

<ol class="algo">
	<li>
%stream.[[disturbed]] ~SET ~true
◎
Set stream.[[disturbed]] to true.
</li>
	<li>
~IF
%stream.[[state]] ~EQ `closed^l
⇒
~RET ~undefined で`解決された~promise$
◎
If stream.[[state]] is "closed", return a promise resolved with undefined.
</li>
	<li>
~IF
%stream.[[state]] ~EQ `errored^l
⇒
~RET %stream.[[storedError]] で`却下された~promise$
◎
If stream.[[state]] is "errored", return a promise rejected with stream.[[storedError]].
</li>
	<li>
! `ReadableStreamClose$A( %stream )
を遂行する
◎
Perform ! ReadableStreamClose(stream).
</li>
	<li>
%sourceCancelPromise ~LET ! %stream.[[readableStreamController]].[[Cancel]](%reason)
◎
Let sourceCancelPromise be ! stream.[[readableStreamController]].[[Cancel]](reason).
</li>
	<li>
~RET ［
~undefined を返す充足~handler
］で %sourceCancelPromise を`変形-$した結果
◎
Return the result of transforming sourceCancelPromise with a fulfillment handler that returns undefined.
</li>
</ol>

			</section>
			<section id="readable-stream-close">
<h4 class="nothrow">3.4.4. `ReadableStreamClose ( stream )^A</h4>

<ol class="algo">
	<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
%stream.[[state]] ~SET `closed^l
◎
Set stream.[[state]] to "closed".
</li>
	<li>
%reader ~LET %stream.[[%reader]]
◎
Let reader be stream.[[reader]].
</li>
	<li>
~IF
%reader ~EQ ~undefined
⇒
~RET
◎
If reader is undefined, return.
</li>
	<li>
<p>
~IF
! `IsReadableStreamDefaultReader$A( %reader ) ~EQ ~true
：
◎
If ! IsReadableStreamDefaultReader(reader) is true,
</p>
		<ol>

			<li>
<p>
%reader.[[readRequests]] 内の~EACH( %readRequest ) に対し：
◎
Repeat for each readRequest that is an element of reader.[[readRequests]],
</p>
				<ol>
					<li>
! `CreateIterResultObject$A( ~undefined, ~true ) で
%readRequest.[[promise]] を`解決する$
◎
Resolve readRequest.[[promise]] with ! CreateIterResultObject(undefined, true).
</li>
				</ol>
			</li>
			<li>
%reader.[[readRequests]] ~SET 空`~List$
◎
Set reader.[[readRequests]] to an empty List.
</li>
		</ol>
	</li>
	<li>
~undefined で
%reader.[[closedPromise]] を`解決する$
◎
Resolve reader.[[closedPromise]] with undefined.
</li>
</ol>

<div class="note">

<p>
［
%stream.[[state]] ~EQ `closed^l
］でありつつ, ［
%stream.[[closeRequested]] ~EQ ~false
］である事例は、その制御器の `close()^c 関数が一度も~callされずに~streamが ~closeされたとき
— すなわち， ~streamが `cancel(reason)$rs の~callにより~closeされた場合 —
に起こる。
この事例では、制御器の `close()^c ~methodが~callされても，何もせず黙することも許容される
— 取消は下層~源の制御の外なので。
◎
The case where stream.[[state]] is "closed", but stream.[[closeRequested]] is false, will happen if the stream was closed without its controller’s close method ever being called: i.e., if the stream was closed by a call to cancel(reason). In this case we allow the controller’s close method to be called and silently do nothing, since the cancelation was outside the control of the underlying source.
</p>

</div>



			</section>
			<section id="readable-stream-error">
<h4 class="nothrow">3.4.5. `ReadableStreamError ( stream, e )^A</h4>

<ol class="algo">
	<li>
~Assert：
! `IsReadableStream$A( %stream ) ~EQ ~true
◎
Assert: ! IsReadableStream(stream) is true.
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
%stream.[[state]] ~SET `errored^l
◎
Set stream.[[state]] to "errored".
</li>
	<li>
%stream.[[storedError]] ~SET %e
◎
Set stream.[[storedError]] to e.
</li>
	<li>
%reader ~LET %stream.[[%reader]]
◎
Let reader be stream.[[reader]].
</li>
	<li>
~IF
%reader ~EQ ~undefined
⇒
~RET
◎
If reader is undefined, return.
</li>
	<li>
<p>
~IF
! `IsReadableStreamDefaultReader$A( %reader ) ~EQ ~true
：
◎
If ! IsReadableStreamDefaultReader(reader) is true,
</p>
		<ol>
			<li>
<p>
%reader.[[readRequests]] 内の~EACH( %readRequest ) に対し：
◎
Repeat for each readRequest that is an element of reader.[[readRequests]],
</p>
				<ol>
					<li>
%e で
%readRequest.[[promise]] を`却下する$
◎
Reject readRequest.[[promise]] with e.
</li>
				</ol>
			</li>
			<li>
%reader.[[readRequests]] ~SET 新たな空`~List$
◎
Set reader.[[readRequests]] to a new empty List.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
! `IsReadableStreamBYOBReader$A( %reader )
◎
Assert: ! IsReadableStreamBYOBReader(reader).
</li>
			<li>
<p>
%reader.[[readIntoRequests]] 内の~EACH( %readIntoRequest ) に対し：
◎
Repeat for each readIntoRequest that is an element of reader.[[readIntoRequests]],
</p>
				<ol>
					<li>
%e で
%readIntoRequest.[[promise]] を`却下する$
◎
Reject readIntoRequest.[[promise]] with e.
</li>
				</ol>
			</li>
			<li>
%reader.[[readIntoRequests]] ~SET 新たな空`~List$
◎
Set reader.[[readIntoRequests]] to a new empty List.
</li>
		</ol>
	</li>
	<li>
%e で
%reader.[[closedPromise]] を`却下する$
◎
Reject reader.[[closedPromise]] with e.
</li>
	<li>
%reader.[[closedPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set reader.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
</ol>

			</section>
			<section id="readable-stream-fulfill-read-into-request">
<h4 class="nothrow">3.4.6. `ReadableStreamFulfillReadIntoRequest ( stream, chunk, done )^A</h4>

<ol class="algo">
	<li>
%reader ~LET %stream.[[%reader]]
◎
Let reader be stream.[[reader]].
</li>
	<li>
%readIntoRequest ~LET
%reader.[[readIntoRequests]] の最初の要素
◎
Let readIntoRequest be the first element of reader.[[readIntoRequests]].
</li>
	<li>
%reader.[[readIntoRequests]] から
%readIntoRequest を除去する
— 後続の要素たちは~~先頭へ一つずらす
◎
Remove readIntoRequest from reader.[[readIntoRequests]], shifting all other elements downward (so that the second becomes the first, and so on).
</li>
	<li>
! `CreateIterResultObject$A( %chunk, %done ) で
%readIntoRequest.[[promise]] を`解決する$
◎
Resolve readIntoRequest.[[promise]] with ! CreateIterResultObject(chunk, done).
</li>
</ol>

			</section>
			<section id="readable-stream-fulfill-read-request">
<h4 class="nothrow">3.4.7. `ReadableStreamFulfillReadRequest ( stream, chunk, done )^A</h4>

<ol class="algo">
	<li>
%reader ~LET %stream.[[%reader]]
◎
Let reader be stream.[[reader]].
</li>
	<li>
%readRequest ~LET %reader.[[readRequests]] の最初の要素
◎
Let readRequest be the first element of reader.[[readRequests]].
</li>
	<li>
%reader.[[readRequests]] から %readRequest を除去する
— 後続の要素たちは~~先頭へ一つずらす
◎
Remove readRequest from reader.[[readRequests]], shifting all other elements downward (so that the second becomes the first, and so on).
</li>
	<li>
! `CreateIterResultObject$A( %chunk, %done ) で
%readRequest.[[promise]] を`解決する$
◎
Resolve readRequest.[[promise]] with ! CreateIterResultObject(chunk, done).
</li>
</ol>

			</section>
			<section id="readable-stream-get-num-read-into-requests">
<h4 class="nothrow">3.4.8. `ReadableStreamGetNumReadIntoRequests ( stream )^A</h4>

<ol class="algo">
	<li>
~RET %stream.[[reader]].[[readIntoRequests]] 内の要素~数
◎
Return the number of elements in stream.[[reader]].[[readIntoRequests]].
</li>
</ol>

			</section>
			<section id="readable-stream-get-num-read-requests">
<h4 class="nothrow">3.4.9. `ReadableStreamGetNumReadRequests ( stream )^A</h4>

<ol class="algo">
	<li>
~RET %stream.[[reader]].[[readRequests]] 内の要素~数
◎
Return the number of elements in stream.[[reader]].[[readRequests]].
</li>
</ol>

			</section>
			<section id="readable-stream-has-byob-reader">
<h4 class="nothrow">3.4.10. `ReadableStreamHasBYOBReader ( stream )^A</h4>

<ol class="algo">
	<li>
%reader ~LET %stream.[[%reader]]
◎
Let reader be stream.[[reader]].
</li>
	<li>
~IF
%reader ~EQ ~undefined
⇒
~RET ~false
◎
If reader is undefined, return false.
</li>
	<li>
~IF
! `IsReadableStreamBYOBReader$A( %reader )~EQ ~false
⇒
~RET ~false
◎
If ! IsReadableStreamBYOBReader(reader) is false, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="readable-stream-has-default-reader">
<h4 class="nothrow">3.4.11. `ReadableStreamHasDefaultReader ( stream )^A</h4>

<ol class="algo">
	<li>
%reader ~LET %stream.[[%reader]]
◎
Let reader be stream.[[reader]].
</li>
	<li>
~IF
%reader ~EQ ~undefined
⇒
~RET ~false
◎
If reader is undefined, return false.
</li>
	<li>
~IF
! `IsReadableStreamDefaultReader$A( %reader ) ~EQ ~false
⇒
~RET ~false
◎
If ! IsReadableStreamDefaultReader(reader) is false, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
		</section>
		<section id="default-reader-class">
<h3 title="Class ReadableStreamDefaultReader">3.5. `ReadableStreamDefaultReader^C ~class</h3>

<p>
`ReadableStreamDefaultReader$C ~classは、［
`ReadableStream$C ~instanceから供給0されるように設計された `既定の読取器$
］を表現する。
◎
The ReadableStreamDefaultReader class represents a default reader designed to be vended by a ReadableStream instance.
</p>



			<section id="default-reader-class-definition">
<h4 title="Class Definition">3.5.1. ~class定義</h4>

~INFORMATIVE

<p>
`ReadableStreamDefaultReader$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば，次のようになる：
◎
If one were to write the ReadableStreamDefaultReader class in something close to the syntax of [ECMASCRIPT], it would look like
</p>

<pre class="lang-javascript">
class ReadableStreamDefaultReader {
  constructor(%stream)

  get closed()

  cancel(%reason)
  read()
  releaseLock()
}
</pre>



			</section>
			<section id="default-reader-internal-slots">
<h4 title="Internal Slots">3.5.2. 内部~slot</h4>

<p>
`ReadableStreamDefaultReader$C の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableStreamDefaultReader are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th title="Internal Slot">内部~slot
<th title="Description(non-normative)">説明0（<em>参考</em>）
</thead>

<tbody><tr><td>[[closedPromise]]
<td>
この読取器の `closed$dr 取得子から返される~promise。
◎
A promise returned by the reader’s closed getter


<tr><td>[[ownerReadableStream]]
<td>
この読取器を所有する `ReadableStream$C ~instance
◎
A ReadableStream instance that owns this reader


<tr><td>[[readRequests]]
<td>
［［［
`消費器$が`~chunk$たちを可用になるより早く要請する
］ことに因り，まだ解決されていない
］ような，~promiseたち
］からなる`~List$
— 読取器の `read()$dr ~methodの~callから返される。
`IsReadableStreamDefaultReader$A による~brand-checkにも利用される。
◎
A List of promises returned by calls to the reader’s read() method that have not yet been resolved, due to the consumer requesting chunks sooner than they are available; also used for the IsReadableStreamDefaultReader brand check
</tbody></table>



			</section>
			<section id="default-reader-constructor">
<h4>3.5.3. `new ReadableStreamDefaultReader(stream)^dr</h4>

<div class="note">

<p>
`ReadableStreamDefaultReader()^dr
構築子は、一般に，直接的な利用を意図するものではない
— 代わりに，~streamの `getReader()$rs ~methodが利用されるべきである。
◎
The ReadableStreamDefaultReader constructor is generally not meant to be used directly; instead, a stream’s getReader() method should be used.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStream$A( %stream ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStream(stream) is false, throw a TypeError exception.
</li>
	<li>
~IF
! `IsReadableStreamLocked$A( %stream ) ~EQ ~true
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamLocked(stream) is true, throw a TypeError exception.
</li>
	<li>
! `ReadableStreamReaderGenericInitialize$A( ~this, %stream )
を遂行する
◎
Perform ! ReadableStreamReaderGenericInitialize(this, stream).
</li>
	<li>
~this.[[readRequests]] ~SET 新たな空`~List$
◎
Set this.[[readRequests]] to a new empty List.
</li>
</ol>

			</section>
			<section id="default-reader-prototype">
<h4 title="Properties of the ReadableStreamDefaultReader Prototype">3.5.4. `ReadableStreamDefaultReader^C ~prototypeの各種~prop</h4>



				<section id="default-reader-closed">
<h5>3.5.4.1. `get closed^dr</h5>

<div class="note">

<p>
`closed^dr 取得子は、~promiseを返す
— それは、［
~streamが~closeされたとき ／
読取器の~lockが`解放-$されたとき
］は 充足され，~streamがどこかで~errorしたときは 却下されることになる。
◎
The closed getter returns a promise that will be fulfilled when the stream becomes closed or the reader’s lock is released, or rejected if the stream ever errors.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamDefaultReader$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsReadableStreamDefaultReader(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET ~this.[[closedPromise]]
◎
Return this.[[closedPromise]].
</li>
</ol>

				</section>
				<section id="default-reader-cancel">
<h5>3.5.4.2. `cancel(reason)^dr</h5>

<div class="note">

<p>
読取器の `cancel()^dr ~methodは、`作動中$のときは，結付けられている~streamに対するそれと同じに挙動する。
◎
If the reader is active, the cancel method behaves the same as that for the associated stream.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamDefaultReader$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsReadableStreamDefaultReader(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
~this.[[ownerReadableStream]] ~EQ ~undefined
⇒
~RET `TypeError^b で`却下された~promise$
◎
If this.[[ownerReadableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
! `ReadableStreamReaderGenericCancel$A( ~this, %reason )
◎
Return ! ReadableStreamReaderGenericCancel(this, reason).
</li>
</ol>

				</section>
				<section id="default-reader-read">
<h5>3.5.4.3. `read()^dr</h5>

<div class="note">

<p>
`read()^dr ~methodは、［
~streamの内部~queueから，次0の可用な`~chunk$に~accessできる
］ようにする，~promiseを返す。
この~promiseは：
◎
The read method will return a promise that allows access to the next chunk from the stream’s internal queue, if available.
</p>

<ul>

<li>
可用な~chunkが無くなったときは、
`{ value: theChunk, done: false }^c
の形による~objで充足されることになる。
◎
If the chunk does become available, the promise will be fulfilled with an object of the form { value: theChunk, done: false }.
</li>
	<li>
~streamが~closeされたときは、
`{ value: undefined, done: true }^c
の形による~objで充足されることになる。
◎
If the stream becomes closed, the promise will be fulfilled with an object of the form { value: undefined, done: true }.
</li>
	<li>
~streamが~errorしたときは、関連する~errorで却下されることになる。
◎
If the stream becomes errored, the promise will be rejected with the relevant error.
</li></ul>

<p>
~chunkの読取りにより~queueが空になったときは、`下層~源$から更なる~dataが~pullされることになる。
◎
If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamDefaultReader$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsReadableStreamDefaultReader(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
~this.[[ownerReadableStream]] ~EQ ~undefined
⇒
~RET `TypeError^b で`却下された~promise$
◎
If this.[[ownerReadableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
! `ReadableStreamDefaultReaderRead$A( ~this )
◎
Return ! ReadableStreamDefaultReaderRead(this).
</li>
</ol>

				</section>
				<section id="default-reader-release-lock">
<h5>3.5.4.4. `releaseLock()^dr</h5>

<div class="note">

<p>
`releaseLock()^dr ~methodは、対応する~streamに対する読取器の`~lockを解放-$する。
解放されたなら、読取器は`作動中$でなくなる。
~lockが解放された時点から、読取器は，［
結付けられている~streamが~errorした場合は~errorしたように／
他の場合は~closeされたように
］現れるようになる。
◎
The releaseLock method releases the reader’s lock on the corresponding stream. After the lock is released, the reader is no longer active. If the associated stream is errored when the lock is released, the reader will appear errored in the same way from now on; otherwise, the reader will appear closed.
</p>

<p>
読取器の~lockは、処理待ちにある読取~要請が まだある間
— すなわち，読取器の `read()$dr ~methodから返された~promiseがまだ決着していない間 —
は、解放できない。
そのような試みは、 `TypeError^b を投出させ，~streamは読取器に~lockされたままになる。
◎
A reader’s lock cannot be released while it still has a pending read request, i.e., if a promise returned by the reader’s read() method has not yet been settled. Attempting to do so will throw a TypeError and leave the reader locked to the stream.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamDefaultReader$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamDefaultReader(this) is false, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[ownerReadableStream]] ~EQ ~undefined
⇒
~RET
◎
If this.[[ownerReadableStream]] is undefined, return.
</li>
	<li>
~IF
~this.[[readRequests]] は空でない
⇒
~THROW `TypeError^b
◎
If this.[[readRequests]] is not empty, throw a TypeError exception.
</li>
	<li>
! `ReadableStreamReaderGenericRelease$A( ~this )
を遂行する
◎
Perform ! ReadableStreamReaderGenericRelease(this).
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="byob-reader-class">
<h3 title="Class ReadableStreamBYOBReader">3.6. `ReadableStreamBYOBReader^C ~class</h3>

<p>
`ReadableStreamBYOBReader$C ~classは、［
`ReadableStream$C ~instanceにより供給0されるように設計された `~BYOB読取器$
］を表現する。
◎
The ReadableStreamBYOBReader class represents a BYOB reader designed to be vended by a ReadableStream instance.
</p>



			<section id="byob-reader-class-definition">
<h4 title="Class Definition">3.6.1. ~class定義</h4>

~INFORMATIVE

<p>
`ReadableStreamBYOBReader$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば，次のようになる：
◎
If one were to write the ReadableStreamBYOBReader class in something close to the syntax of [ECMASCRIPT], it would look like
</p>

<pre class="lang-javascript">
class ReadableStreamBYOBReader {
  constructor(%stream)

  get closed()

  cancel(%reason)
  read(%view)
  releaseLock()
}
</pre>



			</section>
			<section id="byob-reader-internal-slots">
<h4 title="Internal Slots">3.6.2. 内部~slot</h4>

<p>
`ReadableStreamBYOBReader$C
の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableStreamBYOBReader are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th title="Internal Slot">内部~slot
<th title="Description(non-normative)">説明0（<em>参考</em>）
</thead>

<tbody><tr><td>[[closedPromise]]
<td>
この読取器の `closed$byob 取得子から返される~promise。
◎
A promise returned by the reader’s closed getter


<tr><td>[[ownerReadableStream]]
<td>
この読取器を所有する `ReadableStream$C ~instance
◎
A ReadableStream instance that owns this reader


<tr><td>[[readIntoRequests]]
<td>
［［［
`消費器$が`~chunk$たちを可用になるより早く要請する
］ことに因り，まだ解決されていない
］ような，~promiseたち
］からなる`~List$
— 読取器の `read(view)$byob ~methodの~callから返される。
`IsReadableStreamBYOBReader$A による~brand-checkにも利用される。
◎
A List of promises returned by calls to the reader’s read(view) method that have not yet been resolved, due to the consumer requesting chunks sooner than they are available; also used for the IsReadableStreamBYOBReader brand check
</tbody></table>



			</section>
			<section id="byob-reader-constructor">
<h4>3.6.3. `new ReadableStreamBYOBReader(stream)^byob</h4>

<div class="note">

<p>
`ReadableStreamBYOBReader()^byob
構築子は、一般に，直接的な利用は意図されていない
— 代わりに，~streamの `getReader()$rs ~methodが利用されるべきである。
◎
The ReadableStreamBYOBReader constructor is generally not meant to be used directly; instead, a stream’s getReader() method should be used.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStream$A( %stream ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStream(stream) is false, throw a TypeError exception.
</li>
	<li>
~IF
! `IsReadableByteStreamController$A( %stream.[[readableStreamController]] ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableByteStreamController(stream.[[readableStreamController]]) is false, throw a TypeError exception.
</li>
	<li>
~IF
! `IsReadableStreamLocked$A( %stream ) ~EQ ~true
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamLocked(stream) is true, throw a TypeError exception.
</li>
	<li>
! `ReadableStreamReaderGenericInitialize$A( ~this, %stream )
を遂行する
◎
Perform ! ReadableStreamReaderGenericInitialize(this, stream).
</li>
	<li>
~this.[[readIntoRequests]] ~SET 新たな空`~List$
◎
Set this.[[readIntoRequests]] to a new empty List.
</li>
</ol>

			</section>
			<section id="byob-reader-prototype">
<h4 title="Properties of the ReadableStreamBYOBReader Prototype">3.6.4. `ReadableStreamBYOBReader^C ~prototypeの各種~prop</h4>



				<section id="byob-reader-closed">
<h5>3.6.4.1. `get closed^byob</h5>

<div class="note">

<p>
`closed^byob 取得子は、~promiseを返す
— それは、［
~streamが~closeされたとき ／
読取器の~lockが`解放-$されたとき
］は充足され，~streamがどこかで~errorしたときは却下されることになる。
◎
The closed getter returns a promise that will be fulfilled when the stream becomes closed or the reader’s lock is released, or rejected if the stream ever errors.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamBYOBReader$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsReadableStreamBYOBReader(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET ~this.[[closedPromise]]
◎
Return this.[[closedPromise]].
</li>
</ol>

				</section>
				<section id="byob-reader-cancel">
<h5>3.6.4.2. `cancel(reason)^byob</h5>

<div class="note">

<p>
`cancel()^dr ~methodは、読取器が`作動中$の間は，結付けられている~streamに対する同名の~methodと同じに挙動する。
◎
If the reader is active, the cancel method behaves the same as that for the associated stream.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamBYOBReader$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsReadableStreamBYOBReader(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
~this.[[ownerReadableStream]] ~EQ ~undefined
⇒
~RET `TypeError^b で`却下された~promise$
◎
If this.[[ownerReadableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
! `ReadableStreamReaderGenericCancel$A( ~this, %reason )
◎
Return ! ReadableStreamReaderGenericCancel(this, reason).
</li>
</ol>

				</section>
				<section id="byob-reader-read">
<h5>3.6.4.3. `read(view)^byob</h5>

<div class="note">

<p>
`read()^byob ~methodは、~byte列を`view^c の中へ読取して，下に述べるような~bufferで解決されることになる~promiseを返す
— この~bufferは、転送される場合もある。
◎
The read method will write read bytes into view and return a promise resolved with a possibly transferred buffer as described below.
</p><ul>

<li>
可用な~chunkが無くなったときは、
`{ value: theChunk, done: false }^c
の形による~objで充足されることになる。
◎
If the chunk does become available, the promise will be fulfilled with an object of the form { value: theChunk, done: false }.
</li>
	<li>
~streamが~closeされたときは、
`{ value: undefined, done: true }^c
の形による~objで充足されることになる。
◎
If the stream becomes closed, the promise will be fulfilled with an object of the form { value: undefined, done: true }.
</li>
	<li>
~streamが~errorしたときは、関連する~errorで却下されることになる。
◎
If the stream becomes errored, the promise will be rejected with the relevant error.
</li>
</ul>

<p>
~chunkの読取~時に~queueが空になった場合、`下層~byte源$から更なる~dataが~pullされる。
◎
If reading a chunk causes the queue to become empty, more data will be pulled from the underlying byte source.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamBYOBReader$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsReadableStreamBYOBReader(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
~this.[[ownerReadableStream]] ~EQ ~undefined
⇒
~RET `TypeError^b で`却下された~promise$
◎
If this.[[ownerReadableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
`Type$A( %view ) ~NEQ `Object^b
⇒
~RET `TypeError^b で`却下された~promise$
◎
If Type(view) is not Object, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
%view は [[ViewedArrayBuffer]] 内部~slotを持たない
⇒
~RET `TypeError^b で`却下された~promise$
◎
If view does not have a [[ViewedArrayBuffer]] internal slot, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
%view.[[ByteLength]] ~EQ `0^b
⇒
~RET `TypeError^b で`却下された~promise$
◎
If view.[[ByteLength]] is 0, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
! `ReadableStreamBYOBReaderRead$A( ~this, %view )
◎
Return ! ReadableStreamBYOBReaderRead(this, view).
</li>
</ol>

				</section>
				<section id="byob-reader-release-lock">
<h5>3.6.4.4. `releaseLock()^byob</h5>

<div class="note">

<p>
`releaseLock()^byob ~methodは、対応する~streamに対する読取器の`~lockを解放-$する。
解放されたなら、読取器は`作動中$でなくなる。
~lockが解放された時点から、読取器は，［
結付けられている~streamが~errorした場合は~errorしたように／
他の場合は~closeされたように
］現れるようになる。
◎
The releaseLock method releases the reader’s lock on the corresponding stream. After the lock is released, the reader is no longer active. If the associated stream is errored when the lock is released, the reader will appear errored in the same way from now on; otherwise, the reader will appear closed.
</p>

<p>
読取器の~lockは、処理待ちにある読取~要請が まだある間
— すなわち，読取器の `read()$byob ~methodから返された~promiseがまだ決着していない間 —
は、解放できない。
そのような試みは、 `TypeError^b を投出させ，~streamは読取器に~lockされたままになる。
◎
A reader’s lock cannot be released while it still has a pending read request, i.e., if a promise returned by the reader’s read() method has not yet been settled. Attempting to do so will throw a TypeError and leave the reader locked to the stream.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamBYOBReader$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamBYOBReader(this) is false, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[ownerReadableStream]] ~EQ ~undefined
⇒
~RET
◎
If this.[[ownerReadableStream]] is undefined, return.
</li>
	<li>
~IF
~this.[[readIntoRequests]] は空でない
⇒
~THROW `TypeError^b
◎
If this.[[readIntoRequests]] is not empty, throw a TypeError exception.
</li>
	<li>
! `ReadableStreamReaderGenericRelease$A( ~this )
を遂行する
◎
Perform ! ReadableStreamReaderGenericRelease(this).
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="rs-reader-abstract-ops">
<h3 title="Readable Stream Reader Abstract Operations">3.7. 可読~stream読取器の抽象~演算</h3>



			<section id="is-readable-stream-default-reader">
<h4 class="nothrow">3.7.1. `IsReadableStreamDefaultReader ( x )^A</h4>

<ol class="algo">
	<li>
~IF
`Type$A(%x) ~NEQ `Object^b
⇒
~RET ~false
◎
If Type(x) is not Object, return false.
</li>
	<li>
~IF
%x は [[readRequests]] 内部~slotを持たない
⇒
~RET ~false
◎
If x does not have a [[readRequests]] internal slot, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="is-readable-stream-byob-reader">
<h4 class="nothrow">3.7.2. `IsReadableStreamBYOBReader ( x )^A</h4>

<ol class="algo">
	<li>
~IF
`Type$A(%x) ~NEQ `Object^b
⇒
~RET ~false
◎
If Type(x) is not Object, return false.
</li>
	<li>
~IF
%x は [[readIntoRequests]] 内部~slotを持たない
⇒
~RET ~false
◎
If x does not have a [[readIntoRequests]] internal slot, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="readable-stream-reader-generic-cancel">
<h4 class="nothrow">3.7.3. `ReadableStreamReaderGenericCancel ( reader, reason )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %reader.[[ownerReadableStream]]
◎
Let stream be reader.[[ownerReadableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ ~undefined
◎
Assert: stream is not undefined.
</li>
	<li>
~RET
! `ReadableStreamCancel$A( %stream, %reason )
◎
Return ! ReadableStreamCancel(stream, reason).
</li>
</ol>

			</section>
			<section id="readable-stream-reader-generic-initialize">
<h4 class="nothrow">3.7.4. `ReadableStreamReaderGenericInitialize ( reader, stream )^A</h4>

<ol class="algo">
	<li>
%reader.[[ownerReadableStream]] ~SET %stream 
◎
Set reader.[[ownerReadableStream]] to stream.
</li>
	<li>
%stream.[[reader]] ~SET %reader 
◎
Set stream.[[reader]] to reader.
</li>
	<li>
<p>
~IF
%stream.[[state]] ~EQ `readable^l
：
◎
If stream.[[state]] is "readable",
</p>
		<ol>
			<li>
%reader.[[closedPromise]] ~SET `新たな~promise$
◎
Set reader.[[closedPromise]] to a new promise.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF
%stream.[[state]] ~EQ `closed^l
：
◎
Otherwise, if stream.[[state]] is "closed",
</p>
		<ol>
			<li>
%reader.[[closedPromise]] ~SET ~undefined で`解決された~promise$
◎
Set reader.[[closedPromise]] to a promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%stream.[[state]] ~EQ `errored^l
◎
Assert: stream.[[state]] is "errored".
</li>
			<li>
%reader.[[closedPromise]] ~SET
%stream.[[storedError]] で`却下された~promise$
◎
Set reader.[[closedPromise]] to a promise rejected with stream.[[storedError]].
</li>
			<li>
%reader.[[closedPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set reader.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="readable-stream-reader-generic-release">
<h4 class="nothrow">3.7.5. `ReadableStreamReaderGenericRelease ( reader )^A</h4>

<ol class="algo">
	<li>
~Assert：
%reader.[[ownerReadableStream]] ~NEQ ~undefined
◎
Assert: reader.[[ownerReadableStream]] is not undefined.
</li>
	<li>
~Assert：
%reader.[[ownerReadableStream]].[[reader]] ~EQ %reader
◎
Assert: reader.[[ownerReadableStream]].[[reader]] is reader.
</li>
	<li>
~IF
%reader.[[ownerReadableStream]].[[state]] ~EQ `readable^l
⇒
`TypeError^b で %reader.[[closedPromise]] を`却下する$
◎
If reader.[[ownerReadableStream]].[[state]] is "readable", reject reader.[[closedPromise]] with a TypeError exception.
</li>
	<li>
~ELSE
⇒
%reader.[[closedPromise]] ~SET
`TypeError^b で`却下された~promise$
◎
Otherwise, set reader.[[closedPromise]] to a promise rejected with a TypeError exception.
</li>
	<li>
%reader.[[closedPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set reader.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
	<li>
%reader.[[ownerReadableStream]].[[reader]] ~SET ~undefined
◎
Set reader.[[ownerReadableStream]].[[reader]] to undefined.
</li>
	<li>
%reader.[[ownerReadableStream]] ~SET ~undefined
◎
Set reader.[[ownerReadableStream]] to undefined.
</li>
</ol>

			</section>
			<section id="readable-stream-byob-reader-read">
<h4 class="nothrow">3.7.6. `ReadableStreamBYOBReaderRead ( reader, view )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %reader.[[ownerReadableStream]]
◎
Let stream be reader.[[ownerReadableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ ~undefined
◎
Assert: stream is not undefined.
</li>
	<li>
%stream.[[disturbed]] ~SET ~true
◎
Set stream.[[disturbed]] to true.
</li>
	<li>
~IF
%stream.[[state]] ~EQ `errored^l
⇒
~RET %stream.[[storedError]] で`却下された~promise$
◎
If stream.[[state]] is "errored", return a promise rejected with stream.[[storedError]].
</li>
	<li>
~RET
! `ReadableByteStreamControllerPullInto$A( %stream.[[readableStreamController]], %view )
◎
Return ! ReadableByteStreamControllerPullInto(stream.[[readableStreamController]], view).
</li>
</ol>

			</section>
			<section id="readable-stream-default-reader-read">
<h4 class="nothrow">3.7.7. `ReadableStreamDefaultReaderRead ( reader )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %reader.[[ownerReadableStream]]
◎
Let stream be reader.[[ownerReadableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ ~undefined
◎
Assert: stream is not undefined.
</li>
	<li>
%stream.[[disturbed]] ~SET ~true
◎
Set stream.[[disturbed]] to true.
</li>
	<li>
~IF
%stream.[[state]] ~EQ `closed^l
⇒
~RET
! `CreateIterResultObject$A( ~undefined, ~true )
で`解決された~promise$
◎
If stream.[[state]] is "closed", return a promise resolved with ! CreateIterResultObject(undefined, true).
</li>
	<li>
~IF
%stream.[[state]] ~EQ `errored^l
⇒
~RET %stream.[[storedError]] で`却下された~promise$
◎
If stream.[[state]] is "errored", return a promise rejected with stream.[[storedError]].
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
~RET ! %stream.[[readableStreamController]].[[Pull]]()
◎
Return ! stream.[[readableStreamController]].[[Pull]]().
</li>
</ol>

			</section>
		</section>
		<section id="rs-default-controller-class">
<h3 title="Class ReadableStreamDefaultController">3.8. `ReadableStreamDefaultController^C ~class</h3>

<p>
`ReadableStreamDefaultController$C ~classは、
`ReadableStream$C の状態と`内部~queue$を制御できるようにする~methodを持つ。
`可読~byte~stream$でない `ReadableStream$C を構築するときは、`下層~源$には，操作するための 対応する `ReadableStreamDefaultController$C ~instanceが与えられる。
◎
The ReadableStreamDefaultController class has methods that allow control of a ReadableStream's state and internal queue. When constructing a ReadableStream that is not a readable byte stream, the underlying source is given a corresponding ReadableStreamDefaultController instance to manipulate.
</p>



			<section id="rs-default-controller-class-definition">
<h4 title="Class Definition">3.8.1. ~class定義</h4>

~INFORMATIVE

<p>
`ReadableStreamDefaultController$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば，次のようになる：
◎
If one were to write the ReadableStreamDefaultController class in something close to the syntax of [ECMASCRIPT], it would look like
</p>

<pre class="lang-javascript">
class ReadableStreamDefaultController {
  constructor(%stream, %underlyingSource, %size, %highWaterMark)

  get desiredSize()

  close()
  enqueue(%chunk)
  error(%e)
}
</pre>



			</section>
			<section id="rs-default-controller-internal-slots">
<h4 title="Internal Slots">3.8.2. 内部~slot</h4>

<p>
`ReadableStreamDefaultController$C の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableStreamDefaultController are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th title="Internal Slot">内部~slot
<th title="Description(non-normative)">説明0（<em>参考</em>）
</thead>

<tbody><tr><td>[[closeRequested]]
<td>
真偽~flag
— ［
~streamは`下層~源$により~closeされたが，その内部~queueには 読取されていない`~chunk$がまだある
］かどうかを指示する。
◎
A boolean flag indicating whether the stream has been closed by its underlying source, but still has chunks in its internal queue that have not yet been read


<tr><td>[[controlledReadableStream]]
<td>
制御先の `ReadableStream$C の~instance。
◎
The ReadableStream instance controlled


<tr><td>[[pullAgain]]
<td>
真偽~flag
— 更に~dataを~pullするために，~streamの仕組みにて`下層~源$の `pull()^c ~method~callが要請されたが、以前の~callが依然として実行-中にあるため，まだ~pullを行えない場合に ~true に設定される。
◎
A boolean flag set to true if the stream’s mechanisms requested a call to the underlying source’s pull method to pull more data, but the pull could not yet be done since a previous call is still executing


<tr><td>[[pulling]]
<td>
真偽~flag
— `下層~源$の `pull()^c ~methodは実行-中にあるが，まだ充足されていない間は ~true に設定される。
これは、再入~callを防止するために利用される。
◎
A boolean flag set to true while the underlying source’s pull method is executing and has not yet fulfilled, used to prevent reentrant calls


<tr><td>[[queue]]
<td>
~streamの［
`~chunk$たちからなる内部~queue
］を表現する`~List$ 。
◎
A List representing the stream’s internal queue of chunks


<tr><td>[[queueTotalSize]]
<td>
[[queue]] 内に格納されている すべての~chunkの合計~size（`個別~size付き~queue演算 節$を見よ）
◎
The total size of all the chunks stored in [[queue]] (see §6.3 Queue-with-Sizes Operations)


<tr><td>[[started]]
<td>
真偽~flag
— ［
`下層~源$が開始処理を終えた
］かどうかを指示する。
◎
A boolean flag indicating whether the underlying source has finished starting


<tr><td>[[strategyHWM]]
<td>
~streamの`~queuing策$の一部として，構築子に給された数
— それを境に，~streamが`下層~源$に`背圧$を適用することになるような。
【 HWM ＝ High-Water Mark （限界水位） 】
◎
A number supplied to the constructor as part of the stream’s queuing strategy, indicating the point at which the stream will apply backpressure to its underlying source


<tr><td>[[strategySize]]
<td>
~streamの`~queuing策$の一部として，構築子に給された関数
— ~enqueueされる`~chunk$たちの~sizeを計算するための。
既定の挙動の場合， ~undefined になり得る。
◎
A function supplied to the constructor as part of the stream’s queuing strategy, designed to calculate the size of enqueued chunks; can be undefined for the default behavior


<tr><td>[[underlyingSource]]
<td>
~streamの`下層~源$の~obj表現。
`IsReadableStreamDefaultController$A による~brand-checkにも利用される。
◎
An object representation of the stream’s underlying source; also used for the IsReadableStreamDefaultController brand check
</tbody></table>


			</section>
			<section id="rs-default-controller-constructor">
<h4>3.8.3. `new ReadableStreamDefaultController(stream, underlyingSource, size, highWaterMark)^rsdc</h4>

<div class="note">

<p>
`ReadableStreamDefaultController()^rsdc 構築子は，直接的には利用できない
— それは、構築-中の `ReadableStream$C 上でのみ働く。
◎
The ReadableStreamDefaultController constructor cannot be used directly; it only works on a ReadableStream that is in the middle of being constructed.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStream$A( %stream ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStream(stream) is false, throw a TypeError exception.
</li>
	<li>
~IF
%stream.[[readableStreamController]] ~NEQ ~undefined
⇒
~THROW `TypeError^b
◎
If stream.[[readableStreamController]] is not undefined, throw a TypeError exception.
</li>
	<li>
~this.[[controlledReadableStream]] ~SET %stream
◎
Set this.[[controlledReadableStream]] to stream.
</li>
	<li>
~this.[[underlyingSource]] ~SET %underlyingSource
◎
Set this.[[underlyingSource]] to underlyingSource.
</li>
	<li>
! `ResetQueue$A( ~this )
を遂行する
◎
Perform ! ResetQueue(this).
</li>
	<li>
~this.[[started]] ~SET ~false,<br />
~this.[[closeRequested]] ~SET ~false,<br />
~this.[[pullAgain]] ~SET ~false,<br />
~this.[[pulling]] ~SET ~false
◎
Set this.[[started]], this.[[closeRequested]], this.[[pullAgain]], and this.[[pulling]] to false.
</li>
	<li>
%normalizedStrategy ~LET
? `ValidateAndNormalizeQueuingStrategy$A( %size, %highWaterMark )
◎
Let normalizedStrategy be ? ValidateAndNormalizeQueuingStrategy(size, highWaterMark).
</li>
	<li>
~this.[[strategySize]] ~SET %normalizedStrategy.[[size]]；<br>
~this.[[strategyHWM]] ~SET %normalizedStrategy.[[highWaterMark]]
◎
Set this.[[strategySize]] to normalizedStrategy.[[size]] and this.[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
</li>
	<li>
%controller ~LET ~this
◎
Let controller be this.
</li>
	<li>
%startResult ~LET
? `InvokeOrNoop$A( %underlyingSource, `start^l, « ~this » )
◎
Let startResult be ? InvokeOrNoop(underlyingSource, "start", « this »).
</li>
	<li>
<p>
%startPromise ~LET %startResult で`解決された~promise$
◎
Let startPromise be a promise resolved with startResult:
</p>
		<ul>
			<li>
<p>
%startPromise の`充足~時$には：
◎
Upon fulfillment of startPromise,
</p>
				<ol>
					<li>
%controller.[[started]] ~SET ~true
◎
Set controller.[[started]] to true.
</li>
					<li>
~Assert：
%controller.[[pulling]] ~EQ ~false
◎
Assert: controller.[[pulling]] is false.
</li>
					<li>
~Assert：
%controller.[[pullAgain]] ~EQ ~false
◎
Assert: controller.[[pullAgain]] is false.
</li>
					<li>
! `ReadableStreamDefaultControllerCallPullIfNeeded$A( %controller )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
</li>
				</ol>
			</li>
			<li>
<p>
事由 %r による %startPromise の`却下~時$には：
◎
Upon rejection of startPromise with reason r,
</p>
				<ol>
					<li>
! `ReadableStreamDefaultControllerErrorIfNeeded$A( %controller, %r )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerErrorIfNeeded(controller, r).
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>

			</section>
			<section id="rs-default-controller-prototype">
<h4 title="Properties of the ReadableStreamDefaultController Prototype">3.8.4. `ReadableStreamDefaultController^C ~prototypeの各種~prop</h4>



				<section id="rs-default-controller-desired-size">
<h5>3.8.4.1. `get desiredSize^rsdc</h5>

<div class="note">

<p>
`desiredSize^rsdc 取得子は、制御先の`~streamの内部~queueの残り~size$を返す。
それは、負にもなり得る
— ~queueを溢れたときに。
`下層~源$は、`背圧$をいつどのように適用するかを決定するときに，この情報を利用するべきである。
◎
The desiredSize getter returns the desired size to fill the controlled stream’s internal queue. It can be negative, if the queue is over-full. An underlying source should use this information to determine when and how to apply backpressure.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamDefaultController$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamDefaultController(this) is false, throw a TypeError exception.
</li>
	<li>
~RET
! `ReadableStreamDefaultControllerGetDesiredSize$A( ~this )
◎
Return ! ReadableStreamDefaultControllerGetDesiredSize(this).
</li>
</ol>

				</section>
				<section id="rs-default-controller-close">
<h5>3.8.4.2. `close()^rsdc</h5>

<div class="note">

<p>
`close()^rsdc ~methodは、制御先の可読~streamを~closeする。
`消費器$は依然として，それまでに~enqueueされた`~chunk$たちを~streamから読取できるが、それらが読取されたなら，~streamは~closeされる。
◎
The close method will close the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from the stream, but once those are read, the stream will become closed.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamDefaultController$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamDefaultController(this) is false, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[closeRequested]] ~EQ ~true
⇒
~THROW `TypeError^b
◎
If this.[[closeRequested]] is true, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[controlledReadableStream]].[[state]] ~NEQ `readable^l
⇒
~THROW `TypeError^b
◎
If this.[[controlledReadableStream]].[[state]] is not "readable", throw a TypeError exception.
</li>
	<li>
! `ReadableStreamDefaultControllerClose$A( ~this )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerClose(this).
</li>
</ol>

				</section>
				<section id="rs-default-controller-enqueue">
<h5>3.8.4.3. `enqueue(chunk)^rsdc</h5>

<div class="note">

<p>
`enqueue()^rsdc ~methodは、所与の`~chunk$を制御先の可読~stream内に~enqueueする。
◎
The enqueue method will enqueue a given chunk in the controlled readable stream.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamDefaultController$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamDefaultController(this) is false, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[closeRequested]] ~EQ ~true
⇒
~THROW `TypeError^b
◎
If this.[[closeRequested]] is true, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[controlledReadableStream]].[[state]] ~NEQ `readable^l
⇒
~THROW `TypeError^b
◎
If this.[[controlledReadableStream]].[[state]] is not "readable", throw a TypeError exception.
</li>
	<li>
~RET
? `ReadableStreamDefaultControllerEnqueue$A( ~this, %chunk )
◎
Return ? ReadableStreamDefaultControllerEnqueue(this, chunk).
</li>
</ol>

				</section>
				<section id="rs-default-controller-error">
<h5>3.8.4.4. `error(e)^rsdc</h5>

<div class="note">

<p>
`error()^rsdc ~methodは、可読~streamを~errorにする
— 以降のやりとりは、すべて所与の~error %e で失敗させる。
◎
The error method will error the readable stream, making all future interactions with it fail with the given error e.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamDefaultController$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamDefaultController(this) is false, throw a TypeError exception.
</li>
	<li>
%stream ~LET ~this.[[controlledReadableStream]]
◎
Let stream be this.[[controlledReadableStream]].
</li>
	<li>
~IF
%stream.[[state]] ~NEQ `readable^l
⇒
~THROW `TypeError^b
◎
If stream.[[state]] is not "readable", throw a TypeError exception.
</li>
	<li>
! `ReadableStreamDefaultControllerError$A( ~this, %e )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerError(this, e).
</li>
</ol>

				</section>
			</section>
			<section id="rs-default-controller-internal-methods">
<h4 title="Readable Stream Default Controller Internal Methods">3.8.5. 可読 ~streamの既定の制御器の各種 内部~method</h4>

<p>
以下のものは、各 `ReadableStreamDefaultController$C ~instanceにより実装される，追加の内部~methodである。
それらは，以下の節に述べる支持的な抽象~演算に似るが、可読~stream実装から，複形態的に［
それら, または
~BYOB制御器に対する それらに相当するもの
］いずれかへ配送できるように，~methodの形をとる。
◎
The following are additional internal methods implemented by each ReadableStreamDefaultController instance. They are similar to the supporting abstract operations in the following section, but are in method form to allow polymorphic dispatch from the readable stream implementation to either these or their counterparts for BYOB controllers.
</p>



				<section id="rs-default-controller-private-cancel">
<h5>3.8.5.1. `[[Cancel]](reason)^rsdc</h5>

<ol class="algo">
	<li>
! `ResetQueue$A( ~this )
を遂行する
◎
Perform ! ResetQueue(this).
</li>
	<li>
~RET
! `PromiseInvokeOrNoop$A( ~this.[[underlyingSource]], `cancel^l, « %reason » )
◎
Return ! PromiseInvokeOrNoop(this.[[underlyingSource]], "cancel", « reason »)
</li>
</ol>

				</section>
				<section id="rs-default-controller-private-pull">
<h5>3.8.5.2. `[[Pull]]()^rsdc</h5>

<ol class="algo">
	<li>
%stream ~LET ~this.[[controlledReadableStream]]
◎
Let stream be this.[[controlledReadableStream]].
</li>
	<li>
<p>
~IF
~this.[[queue]] は空でない
：
◎
If this.[[queue]] is not empty,
</p>
		<ol>
			<li>
%chunk ~LET
! `DequeueValue$A( ~this )
◎
Let chunk be ! DequeueValue(this).
</li>
			<li>
~IF［
~this.[[closeRequested]] ~EQ ~true
］~AND［
~this.[[queue]] は空である
］
⇒
! `ReadableStreamClose$A( %stream )
を遂行する
◎
If this.[[closeRequested]] is true and this.[[queue]] is empty, perform ! ReadableStreamClose(stream).
</li>
			<li>
~ELSE
⇒
! `ReadableStreamDefaultControllerCallPullIfNeeded$A( ~this )
を遂行する
◎
Otherwise, perform ! ReadableStreamDefaultControllerCallPullIfNeeded(this).
</li>
			<li>
~RET
! `CreateIterResultObject$A( %chunk, ~false )
で`解決された~promise$
◎
Return a promise resolved with ! CreateIterResultObject(chunk, false).
</li>
		</ol>
	</li>
	<li>
%pendingPromise ~LET
! `ReadableStreamAddReadRequest$A( %stream )
◎
Let pendingPromise be ! ReadableStreamAddReadRequest(stream).
</li>
	<li>
! `ReadableStreamDefaultControllerCallPullIfNeeded$A( ~this )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(this).
</li>
	<li>
~RET %pendingPromise 
◎
Return pendingPromise.
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="rs-default-controller-abstract-ops">
<h3 title="Readable Stream Default Controller Abstract Operations">3.9. 可読 ~stream既定の制御器の抽象~演算</h3>



			<section id="is-readable-stream-default-controller">
<h4 class="nothrow">3.9.1. `IsReadableStreamDefaultController ( x )^A</h4>

<ol class="algo">
	<li>
~IF
`Type$A(%x) ~NEQ `Object^b
⇒
~RET ~false
◎
If Type(x) is not Object, return false.
</li>
	<li>
~IF
%x は [[underlyingSource]] 内部~slotを持たない
⇒
~RET ~false
◎
If x does not have an [[underlyingSource]] internal slot, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="readable-stream-default-controller-call-pull-if-needed">
<h4 class="nothrow">3.9.2. `ReadableStreamDefaultControllerCallPullIfNeeded ( controller )^A</h4>

<ol class="algo">
	<li>
%shouldPull ~LET
! `ReadableStreamDefaultControllerShouldCallPull$A( %controller )
◎
Let shouldPull be ! ReadableStreamDefaultControllerShouldCallPull(controller).
</li>
	<li>
~IF
%shouldPull ~EQ ~false
⇒
~RET
◎
If shouldPull is false, return.
</li>
	<li>
<p>
~IF
%controller.[[pulling]] ~EQ ~true
：
◎
If controller.[[pulling]] is true,
</p>
		<ol>
			<li>
%controller.[[pullAgain]] ~SET ~true
◎
Set controller.[[pullAgain]] to true.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~Assert：
%controller .[[pullAgain]] ~EQ ~false
◎
Assert: controller.[[pullAgain]] is false.
</li>
	<li>
%controller.[[pulling]] ~SET ~true
◎
Set controller.[[pulling]] to true.
</li>
	<li>
%pullPromise ~LET
! `PromiseInvokeOrNoop$A( %controller.[[underlyingSource]], `pull^l, « %controller » )
◎
Let pullPromise be ! PromiseInvokeOrNoop(controller.[[underlyingSource]], "pull", « controller »).
</li>
	<li>
<p>
%pullPromise の`充足~時$には：
◎
Upon fulfillment of pullPromise,
</p>
		<ol>
			<li>
%controller.[[pulling]] ~SET ~false
◎
Set controller.[[pulling]] to false.
</li>
			<li>
<p>
~IF
%controller.[[pullAgain]] ~EQ ~true
：
◎
If controller.[[pullAgain]] is true,
</p>
				<ol>
					<li>
%controller.[[pullAgain]] ~SET ~false
◎
Set controller.[[pullAgain]] to false.
</li>
					<li>
! `ReadableStreamDefaultControllerCallPullIfNeeded$A( %controller )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
事由 %e による %pullPromise の`却下~時$には：
◎
Upon rejection of pullPromise with reason e,
</p>
		<ol>
			<li>
! `ReadableStreamDefaultControllerErrorIfNeeded$A( %controller, %e )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerErrorIfNeeded(controller, e).
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="readable-stream-default-controller-should-call-pull">
<h4 class="nothrow">3.9.3. `ReadableStreamDefaultControllerShouldCallPull ( controller )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~IF［
%stream.[[state]] ~IN { `closed^l, `errored^l }
］
⇒
~RET ~false
◎
If stream.[[state]] is "closed" or stream.[[state]] is "errored", return false.
</li>
	<li>
~IF
%controller.[[closeRequested]] ~EQ ~true
⇒
~RET ~false
◎
If controller.[[closeRequested]] is true, return false.
</li>
	<li>
~IF
%controller.[[started]] ~EQ ~false
⇒
~RET ~false
◎
If controller.[[started]] is false, return false.
</li>
	<li>
~IF［
! `IsReadableStreamLocked$A( %stream ) ~EQ ~true
］~AND［
! `ReadableStreamGetNumReadRequests$A( %stream ) ~GT `0^b
］
⇒
~RET ~true
◎
If ! IsReadableStreamLocked(stream) is true and ! ReadableStreamGetNumReadRequests(stream) &gt; 0, return true.
</li>
	<li>
%desiredSize ~LET `ReadableStreamDefaultControllerGetDesiredSize$A( %controller )
◎
Let desiredSize be ReadableStreamDefaultControllerGetDesiredSize(controller).
</li>
	<li>
~IF
%desiredSize ~GT `0^b
⇒
~RET ~true
◎
If desiredSize &gt; 0, return true.
</li>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>

			</section>
			<section id="readable-stream-default-controller-close">
<h4 class="nothrow">3.9.4. `ReadableStreamDefaultControllerClose ( controller )^A</h4>

<p>
他の仕様は、可読~streamを~closeしたいと望むとき，この抽象~演算を~callできる
— 開発者が［
自身が作成した~streamを，それに結付けられた制御器~objにより~closeする
］ときと同じ仕方で。
仕様は、自身が作成しなかった~streamに対し，これをすべき<em>でない</em>
— 事前条件（以下に~Assertとして挙げられる）が順守されることを確保し~MUST。
◎
This abstract operation can be called by other specifications that wish to close a readable stream, in the same way a developer-created stream would be closed by its associated controller object. Specifications should not do this to streams they did not create, and must ensure they have obeyed the preconditions (listed here as asserts).
</p>



<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~Assert：
%controller.[[closeRequested]] ~EQ ~false
◎
Assert: controller.[[closeRequested]] is false.
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
%controller.[[closeRequested]] ~SET ~true
◎
Set controller.[[closeRequested]] to true.
</li>
	<li>
~IF
%controller.[[queue]] は空である
⇒
! `ReadableStreamClose$A( %stream )
を遂行する
◎
If controller.[[queue]] is empty, perform ! ReadableStreamClose(stream).
</li>
</ol>

			</section>
			<section id="readable-stream-default-controller-enqueue">
<h4 class="throws">3.9.5. `ReadableStreamDefaultControllerEnqueue ( controller, chunk )^A</h4>

<p>
他の仕様は、可読~stream内に`~chunk$たちを~enqueueしたいと望むとき，この抽象~演算を~callできる
— 開発者が［
~streamに結付けられた制御器~objを利用して，~chunkたちを~enqueueする
］ときと同じ仕方で。
仕様は、自身が作成しなかった~streamに対し，これをすべき<em>でない</em>
— 事前条件（以下に~Assertとして挙げられる）が順守されることを確保し~MUST。
◎
This abstract operation can be called by other specifications that wish to enqueue chunks in a readable stream, in the same way a developer would enqueue chunks using the stream’s associated controller object. Specifications should not do this to streams they did not create, and must ensure they have obeyed the preconditions (listed here as asserts).
</p>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~Assert：
%controller.[[closeRequested]] ~EQ ~false
◎
Assert: controller.[[closeRequested]] is false.
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
~IF［
! `IsReadableStreamLocked$A( %stream ) ~EQ ~true
］~AND［
! `ReadableStreamGetNumReadRequests$A( %stream ) ~GT `0^b
］
⇒
! `ReadableStreamFulfillReadRequest$A( %stream, %chunk, ~false )
を遂行する
◎
If ! IsReadableStreamLocked(stream) is true and ! ReadableStreamGetNumReadRequests(stream) &gt; 0, perform ! ReadableStreamFulfillReadRequest(stream, chunk, false).
</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
%chunkSize ~LET `1^b
◎
Let chunkSize be 1.
</li>
			<li>
<p>
~IF
%controller.[[strategySize]] ~NEQ ~undefined
：
◎
If controller.[[strategySize]] is not undefined,
</p>
				<ol>
					<li>
%chunkSize ~SET
`Call$A( %controller.[[strategySize]], ~undefined, « %chunk » )
◎
Set chunkSize to Call(controller.[[strategySize]], undefined, « chunk »).
</li>
					<li>
<p>
~IF
%chunkSize は`中途完了$である：
◎
If chunkSize is an abrupt completion,
</p>
						<ol>
							<li>
! `ReadableStreamDefaultControllerErrorIfNeeded$A( %controller, %chunkSize.[[Value]] )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerErrorIfNeeded(controller, chunkSize.[[Value]]).
</li>
							<li>
~RET %chunkSize
◎
Return chunkSize.
</li>
						</ol>
					</li>
					<li>
%chunkSize ~LET %chunkSize.[[Value]]
◎
Let chunkSize be chunkSize.[[Value]].
</li>
				</ol>
			</li>
			<li>
%enqueueResult ~LET
! `EnqueueValueWithSize$A( %controller, %chunk, %chunkSize )
◎
Let enqueueResult be ! EnqueueValueWithSize(controller, chunk, chunkSize).
</li>
			<li>
<p>
~IF
%enqueueResult は`中途完了$である：
◎
If enqueueResult is an abrupt completion,
</p>
				<ol>
					<li>
! `ReadableStreamDefaultControllerErrorIfNeeded$A( %controller, %enqueueResult.[[Value]] )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerErrorIfNeeded(controller, enqueueResult.[[Value]]).
</li>
					<li>
~RET %enqueueResult 
◎
Return enqueueResult.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
! `ReadableStreamDefaultControllerCallPullIfNeeded$A( %controller )
を遂行する
◎
Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
</li>
</ol>

<div class="note">

<p>
［
%stream.[[state]] ~EQ `closed^l
］でありつつ, ［
%stream.[[closeRequested]] ~EQ ~false
］である事例は、その制御器の `close()^rsdc 関数が一度も~callされずに~streamが ~closeされたとき
— すなわち， ~streamが `cancel(reason)$rs の~callにより~closeされた場合 —
に起こる。
この事例では、制御器の `enqueue()^rsdc ~methodが~callされても，何もせず黙することも許容される
— 取消は下層~源の制御の外なので。
◎
The case where stream.[[state]] is "closed", but stream.[[closeRequested]] is false, will happen if the stream was closed without its controller’s close method ever being called: i.e., if the stream was closed by a call to cancel(reason). In this case we allow the controller’s enqueue method to be called and silently do nothing, since the cancelation was outside the control of the underlying source.
</p>

</div>



			</section>
			<section id="readable-stream-default-controller-error">
<h4 class="nothrow">3.9.6. `ReadableStreamDefaultControllerError ( controller, e )^A</h4>

<p>
他の仕様は、可読~streamを~error状態へ移行させたいと望むとき，この抽象~演算を~callできる
— 開発者が［
~streamに結付けられた制御器~objを利用して，~streamを~errorにする
］ときと同じ仕方で。
仕様は、自身が作成しなかった~streamに対し，これをすべき<em>でない</em>
— 事前条件（以下に~Assertとして挙げられる）が順守されることを確保し~MUST。
◎
This abstract operation can be called by other specifications that wish to move a readable stream to an errored state, in the same way a developer would error a stream using its associated controller object. Specifications should not do this to streams they did not create, and must ensure they have obeyed the precondition (listed here as an assert).
</p>


<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
! `ResetQueue$A( %controller )
を遂行する
◎
Perform ! ResetQueue(controller).
</li>
	<li>
! `ReadableStreamError$A( %stream, %e )
を遂行する
◎
Perform ! ReadableStreamError(stream, e).
</li>
</ol>

			</section>
			<section id="readable-stream-default-controller-error-if-needed">
<h4 class="nothrow">3.9.7. `ReadableStreamDefaultControllerErrorIfNeeded ( controller, e )^A</h4>

<ol class="algo">
	<li>
~IF
%controller.[[controlledReadableStream]].[[state]] ~EQ `readable^l
⇒
! `ReadableStreamDefaultControllerError$A( %controller, %e )
を遂行する
◎
If controller.[[controlledReadableStream]].[[state]] is "readable", perform ! ReadableStreamDefaultControllerError(controller, e).
</li>
</ol>

			</section>
			<section id="readable-stream-default-controller-get-desired-size">
<h4 class="nothrow">3.9.8. `ReadableStreamDefaultControllerGetDesiredSize ( controller )^A</h4>

<p>
他の仕様は、この`~streamの内部~queueの残り~size$を決定したいと望むとき，この抽象~演算を~callできる
— 開発者が，~streamに結付けられている制御器~objの `desiredSize^rsdc ~propを調べるときと同様に。
仕様は、自身が作成していない~streamに対しては，これを利用する<em>べきでない</em>。
◎
This abstract operation can be called by other specifications that wish to determine the desired size to fill this stream’s internal queue, similar to how a developer would consult the desiredSize property of the stream’s associated controller object. Specifications should not use this on streams they did not create.
</p>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
~IF
%state ~EQ `errored^l
⇒
~RET `null^b
◎
If state is "errored", return null.
</li>
	<li>
~IF %state ~EQ `closed^l
⇒
~RET `0^b
◎
If state is "closed", return 0.
</li>
	<li>
~RET %controller.[[strategyHWM]] − %controller.[[queueTotalSize]]
◎
Return controller.[[strategyHWM]] − controller.[[queueTotalSize]].
</li>
</ol>

			</section>
		</section>
		<section id="rbs-controller-class">
<h3 title="Class ReadableByteStreamController">3.10. `ReadableByteStreamController^C ~class</h3>

<p>
`ReadableByteStreamController$C ~classは、
`ReadableStream$C の状態と`内部~queue$を制御できるようにする各種~methodを備える。
`ReadableStream$C を構築するとき、`下層~byte源$に対応して，操作するための 
`ReadableByteStreamController$C ~instanceが与えられる。
◎
The ReadableByteStreamController class has methods that allow control of a ReadableStream's state and internal queue. When constructing a ReadableStream, the underlying byte source is given a corresponding ReadableByteStreamController instance to manipulate.
</p>



			<section id="rbs-controller-class-definition">
<h4 title="Class Definition">3.10.1. ~class定義</h4>

~INFORMATIVE

<p>
`ReadableByteStreamController$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば，次のようになる：
◎
If one were to write the ReadableByteStreamController class in something close to the syntax of [ECMASCRIPT], it would look like
</p>

<pre class="lang-javascript">
class ReadableByteStreamController {
  constructor(%stream, %underlyingByteSource, %highWaterMark)

  get byobRequest()
  get desiredSize()

  close()
  enqueue(%chunk)
  error(%e)
}
</pre>

			</section>
			<section id="rbs-controller-internal-slots">
<h4 title="Internal Slots">3.10.2. 内部~slot</h4>

<p>
`ReadableByteStreamController$C
の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableByteStreamController are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th title="Internal Slot">内部~slot
<th title="Description(non-normative)">説明0（<em>参考</em>）
</thead>

<tbody><tr><td>[[autoAllocateChunkSize]]
<td>
自動的~buffer割当て特色機能が可能化されているときは、正~整数を値にとり，割当てる~bufferの~sizeを指定する。
他の場合は ~undefined になる。
◎
A positive integer, when the automatic buffer allocation feature is enabled. In that case, this value specifies the size of buffer to allocate. It is undefined otherwise.


<tr><td>[[closeRequested]]
<td>
真偽~flag
— ［
~streamは その`下層~byte源$により~closeされたが，その内部~queueには 読取されていない`~chunk$がまだある
］かどうかを指示する。
◎
A boolean flag indicating whether the stream has been closed by its underlying byte source, but still has chunks in its internal queue that have not yet been read


<tr><td>[[controlledReadableStream]]
<td>
制御先の `ReadableStream$C の~instance。
◎
The ReadableStream instance controlled


<tr><td>[[pullAgain]]
<td>
真偽~flag
— 更に~dataを~pullするために，~streamの仕組みにて`下層~byte源$の `pull()^c ~method~callが要請されたが、以前の~callが依然として実行-中にあるため，まだ~pullを行えない場合に ~true に設定される。
◎
A boolean flag set to true if the stream’s mechanisms requested a call to the underlying byte source’s pull method to pull more data, but the pull could not yet be done since a previous call is still executing


<tr><td>[[pulling]]
<td>
真偽~flag
— `下層~byte源$の `pull()^c ~methodは実行-中にあるが，まだ充足されていない間は ~true に設定される。
これは、再入~callを防止するために利用される。
◎
A boolean flag set to true while the underlying byte source’s pull method is executing and has not yet fulfilled, used to prevent reentrant calls


<tr><td>[[byobRequest]]
<td>
現在の~BYOB~pull要請を表現している
`ReadableStreamBYOBRequest$C ~instance。
◎
A ReadableStreamBYOBRequest instance representing the current BYOB pull request


<tr><td>[[pendingPullIntos]]
<td>
処理待ちの~BYOB~pull要請を表現している記述子たちからなる`~List$ 。
◎
A List of descriptors representing pending BYOB pull requests


<tr><td>[[queue]]
<td>
~streamの［
`~chunk$たちからなる内部~queue
］を表現する`~List$ 。
◎
A List representing the stream’s internal queue of chunks


<tr><td>[[queueTotalSize]]
<td>
[[queue]] 内に格納されている すべての~chunkの，~byte数による合計~size
◎
The total size (in bytes) of all the chunks stored in [[queue]]


<tr><td>[[started]]
<td>
真偽~flag
— ［
`下層~源$が開始処理を終えた
］かどうかを指示する。
◎
A boolean flag indicating whether the underlying source has finished starting


<tr><td>[[strategyHWM]]
<td>
~streamの`~queuing策$の一部として，構築子に給された数
— それを境に，~streamが`下層~byte源$に`背圧$を適用することになるような。
【 HWM ＝ High-Water Mark （限界水位） 】
◎
A number supplied to the constructor as part of the stream’s queuing strategy, indicating the point at which the stream will apply backpressure to its underlying byte source


<tr><td>[[underlyingByteSource]]
<td>
~streamの`下層~byte源$の~obj表現。
`IsReadableByteStreamController$A による~brand-checkにも利用される。
◎
An object representation of the stream’s underlying byte source; also used for the IsReadableByteStreamController brand check
</tbody></table>


<div class="note">

<p>注記：
`ReadableByteStreamController$C の各~instanceは、
[[queue]], [[queueTotalSize]]
両~slotを有するが、これらに対しては `個別~size付き~queue演算 節$の ほとんどの抽象~演算は利用しない
— この~queueを操作する仕方は、仕様~内の他のものと~~異質なので。
代わりに， 2 つの~slotは、手動で一緒に更新する。
◎
Although ReadableByteStreamController instances have [[queue]] and [[queueTotalSize]] slots, we do not use most of the abstract operations in §6.3 Queue-with-Sizes Operations on them, as the way in which we manipulate this queue is rather different than the others in the spec. Instead, we update the two slots together manually.
</p>

<p>
これは、将来，仕様の~refactoring時に整理されるであろう。
◎
This might be cleaned up in a future spec refactoring.
</p>

</div>


			</section>
			<section id="rbs-controller-constructor">
<h4>3.10.3. `new ReadableByteStreamController(stream, underlyingByteSource, highWaterMark)^rbsc</h4>

<div class="note">

<p>
`ReadableByteStreamController()^rbsc 構築子は，直接的には利用できない
— それは、構築-中の `ReadableStream$C 上でのみ働く。
◎
The ReadableByteStreamController constructor cannot be used directly; it only works on a ReadableStream that is in the middle of being constructed.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableStream$A( %stream ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStream(stream) is false, throw a TypeError exception.
</li>
	<li>
~IF
%stream.[[readableStreamController]] ~NEQ ~undefined
⇒
~THROW `TypeError^b
◎
If stream.[[readableStreamController]] is not undefined, throw a TypeError exception.
</li>
	<li>
~this.[[controlledReadableStream]] ~SET %stream
◎
Set this.[[controlledReadableStream]] to stream.
</li>
	<li>
~this.[[underlyingByteSource]] ~SET %underlyingByteSource 
◎
Set this.[[underlyingByteSource]] to underlyingByteSource.
</li>
	<li>
~this.[[pullAgain]] ~SET ~false；<br>
~this.[[pulling]] ~SET ~false
◎
Set this.[[pullAgain]], and this.[[pulling]] to false.
</li>
	<li>
! `ReadableByteStreamControllerClearPendingPullIntos$A( ~this )
を遂行する
◎
Perform ! ReadableByteStreamControllerClearPendingPullIntos(this).
</li>
	<li>
! `ResetQueue$A( ~this )
を遂行する
◎
Perform ! ResetQueue(this).
</li>
	<li>
~this.[[started]] ~SET ~false；<br>
~this.[[closeRequested]] ~SET ~false
◎
Set this.[[started]] and this.[[closeRequested]] to false.
</li>
	<li>
~this.[[strategyHWM]] ~SET
? `ValidateAndNormalizeHighWaterMark$A( %highWaterMark )
◎
Set this.[[strategyHWM]] to ? ValidateAndNormalizeHighWaterMark(highWaterMark).
</li>
	<li>
%autoAllocateChunkSize ~LET
? `GetV$A( %underlyingByteSource, `autoAllocateChunkSize^l )
◎
Let autoAllocateChunkSize be ? GetV(underlyingByteSource, "autoAllocateChunkSize").
</li>
	<li>
<p>
~IF
%autoAllocateChunkSize ~NEQ ~undefined
：
◎
If autoAllocateChunkSize is not undefined,
</p>
		<ol>
			<li>
~IF［
! `IsInteger$A( %autoAllocateChunkSize ) ~EQ ~false
］~OR［
%autoAllocateChunkSize ~LTE `0^b
］
⇒
~THROW `RangeError^b
◎
If ! IsInteger(autoAllocateChunkSize) is false, or if autoAllocateChunkSize ≤ 0, throw a RangeError exception.
</li>
		</ol>
	</li>
	<li>
~this.[[autoAllocateChunkSize]] ~SET %autoAllocateChunkSize 
◎
Set this.[[autoAllocateChunkSize]] to autoAllocateChunkSize.
</li>
	<li>
~this.[[pendingPullIntos]] ~SET 新たな空`~List$
◎
Set this.[[pendingPullIntos]] to a new empty List.
</li>
	<li>
%controller ~LET ~this
◎
Let controller be this.
</li>
	<li>
%startResult ~LET
? `InvokeOrNoop$A( %underlyingByteSource, `start^l, « ~this » )
◎
Let startResult be ? InvokeOrNoop(underlyingByteSource, "start", « this »).
</li>
	<li>
<p>
%startPromise ~LET %startResult で`解決された~promise$
◎
Let startPromise be a promise resolved with startResult:
</p>
		<ul>
			<li>
<p>
%startPromise の`充足~時$には：
◎
Upon fulfillment of startPromise,
</p>
				<ol>
					<li>
%controller.[[started]] ~SET ~true
◎
Set controller.[[started]] to true.
</li>
					<li>
~Assert：
%controller.[[pulling]] ~EQ ~false
◎
Assert: controller.[[pulling]] is false.
</li>
					<li>
~Assert：
%controller.[[pullAgain]] ~EQ ~false
◎
Assert: controller.[[pullAgain]] is false.
</li>
					<li>
! `ReadableByteStreamControllerCallPullIfNeeded$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
</li>
				</ol>
			</li>
			<li>
<p>
事由 %r による %startPromise の`却下~時$には：
◎
Upon rejection of startPromise with reason r,
</p>
				<ol>
					<li>
~IF
%stream.[[state]] ~EQ `readable^l
⇒
! `ReadableByteStreamControllerError$A( %controller, %r )
を遂行する
◎
If stream.[[state]] is "readable", perform ! ReadableByteStreamControllerError(controller, r).
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>

			</section>
			<section id="rbs-controller-prototype">
<h4 title="Properties of the ReadableByteStreamController Prototype">3.10.4. `ReadableByteStreamController^C ~prototypeの各種~prop</h4>



				<section id="rbs-controller-byob-request">
<h5>3.10.4.1. `get byobRequest^rbsc</h5>

<div class="note">

<p>
`byobRequest^rbsc 取得子は、現在の~BYOB~pull要請を返す。
◎
The byobRequest getter returns the current BYOB pull request.
</p>

</div>

<ol class="algo">
	<li>
~IF
`IsReadableByteStreamController$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If IsReadableByteStreamController(this) is false, throw a TypeError exception.
</li>
	<li>
<p>
~IF［
~this.[[byobRequest]] ~EQ ~undefined
］~AND［
~this.[[pendingPullIntos]] は空でない
］：
◎
If this.[[byobRequest]] is undefined and this.[[pendingPullIntos]] is not empty,
</p>
		<ol>
			<li>
%firstDescriptor ~LET ~this.[[pendingPullIntos]] の最初の要素
◎
Let firstDescriptor be the first element of this.[[pendingPullIntos]].
</li>
			<li>
%view ~LET
! `Construct$A(`~Uint8Array$,
« %firstDescriptor.[[buffer]],
( %firstDescriptor.[[byteOffset]] + %firstDescriptor.[[bytesFilled]] ),
( %firstDescriptor.[[byteLength]] − %firstDescriptor.[[bytesFilled]] ) »)
◎
Let view be ! Construct(%Uint8Array%, « firstDescriptor.[[buffer]], firstDescriptor.[[byteOffset]] + firstDescriptor.[[bytesFilled]], firstDescriptor.[[byteLength]] − firstDescriptor.[[bytesFilled]] »).
</li>
			<li>
~this.[[byobRequest]] ~SET
! `Construct$A( `ReadableStreamBYOBRequest$C, « ~this, %view » )
◎
Set this.[[byobRequest]] to ! Construct(ReadableStreamBYOBRequest, « this, view »).
</li>
		</ol>
	</li>
	<li>
~RET ~this.[[byobRequest]]
◎
Return this.[[byobRequest]].
</li>
</ol>

				</section>
				<section id="rbs-controller-desired-size">
<h5>3.10.4.2. `get desiredSize^rbsc</h5>

<div class="note">

<p>
`desiredSize^rbsc 取得子は、制御先の`~streamの内部~queueの残り~size$を返す。
それは、負にもなり得る
— ~queueを溢れるときは。
`下層~源$は、`背圧$をいつどのように適用するかを決定するときに，この情報を利用するべきである。
◎
The desiredSize getter returns the desired size to fill the controlled stream’s internal queue. It can be negative, if the queue is over-full. An underlying source should use this information to determine when and how to apply backpressure.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableByteStreamController$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableByteStreamController(this) is false, throw a TypeError exception.
</li>
	<li>
~RET
! `ReadableByteStreamControllerGetDesiredSize$A( ~this )
◎
Return ! ReadableByteStreamControllerGetDesiredSize(this).
</li>
</ol>

				</section>
				<section id="rbs-controller-close">
<h5>3.10.4.3. `close()^rbsc</h5>

<div class="note">

<p>
`close()^rbsc ~methodは、制御先の可読~streamを~closeする。
`消費器$は依然として，それまでに~enqueueされた`~chunk$たちを~streamから読取できるが、それらが読取されたなら，~streamは~closeされる。
◎
The close method will close the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from the stream, but once those are read, the stream will become closed.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableByteStreamController$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableByteStreamController(this) is false, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[closeRequested]] ~EQ ~true
⇒
~THROW `TypeError^b
◎
If this.[[closeRequested]] is true, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[controlledReadableStream]].[[state]] ~NEQ `readable^l
⇒
~THROW `TypeError^b
◎
If this.[[controlledReadableStream]].[[state]] is not "readable", throw a TypeError exception.
</li>
	<li>
? `ReadableByteStreamControllerClose$A( ~this )
を遂行する
◎
Perform ? ReadableByteStreamControllerClose(this).
</li>
</ol>

				</section>
				<section id="rbs-controller-enqueue">
<h5>3.10.4.4. `enqueue(chunk)^rbsc</h5>

<div class="note">

<p>
`enqueue()^rbsc ~methodは、所与の`~chunk$を制御先の可読~stream内に~enqueueする。
◎
The enqueue method will enqueue a given chunk in the controlled readable stream.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableByteStreamController$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableByteStreamController(this) is false, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[closeRequested]] ~EQ ~true
⇒
~THROW `TypeError^b
◎
If this.[[closeRequested]] is true, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[controlledReadableStream]].[[state]] ~NEQ `readable^l
⇒
~THROW `TypeError^b
◎
If this.[[controlledReadableStream]].[[state]] is not "readable", throw a TypeError exception.
</li>
	<li>
~IF
`Type$A( %chunk ) ~NEQ `Object^b
⇒
~THROW `TypeError^b
◎
If Type(chunk) is not Object, throw a TypeError exception.
</li>
	<li>
~IF
%chunk は [[ViewedArrayBuffer]] 内部~slotを持たない
⇒
~THROW `TypeError^b
◎
If chunk does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError exception.
</li>
	<li>
~RET
! `ReadableByteStreamControllerEnqueue$A( ~this, %chunk )
◎
Return ! ReadableByteStreamControllerEnqueue(this, chunk).
</li>
</ol>

				</section>
				<section id="rbs-controller-error">
<h5>3.10.4.5. `error(e)^rbsc</h5>

<div class="note">

<p>
`error()^rbsc ~methodは、可読~streamを~errorにする
— 以降のやりとりは、すべて所与の~error %e で失敗させる。
◎
The error method will error the readable stream, making all future interactions with it fail with the given error e.
</p>

</div>

<ol class="algo">
	<li>
~IF
! `IsReadableByteStreamController$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableByteStreamController(this) is false, throw a TypeError exception.
</li>
	<li>
%stream ~LET ~this.[[controlledReadableStream]]
◎
Let stream be this.[[controlledReadableStream]].
</li>
	<li>
~IF
%stream.[[state]] ~NEQ `readable^l
⇒
~THROW `TypeError^b
◎
If stream.[[state]] is not "readable", throw a TypeError exception.
</li>
	<li>
! `ReadableByteStreamControllerError$A( ~this, %e )
を遂行する
◎
Perform ! ReadableByteStreamControllerError(this, e).
</li>
</ol>

				</section>
			</section>
			<section id="rbs-controller-internal-methods">
<h4 title="Readable Stream BYOB Controller Internal Methods">3.10.5. 可読 ~streamの~BYOB制御器の各種 内部~method</h4>

<p>
以下のものは、各 `ReadableByteStreamController$C ~instanceにより実装される，追加の内部~methodである。
それらは，以下の節に述べる支持的な抽象~演算に似るが、可読~stream実装から，複形態的に［
それら, または
既定の制御器に対する それらに相当するもの
］いずれかへ配送できるように，~methodの形をとる。
◎
The following are additional internal methods implemented by each ReadableByteStreamController instance. They are similar to the supporting abstract operations in the following section, but are in method form to allow polymorphic dispatch from the readable stream implementation to either these or their counterparts for default controllers.
</p>



				<section id="rbs-controller-private-cancel">
<h5>3.10.5.1. `[[Cancel]](reason)^rbsc</h5>

<ol class="algo">
	<li>
<p>
~IF
~this.[[pendingPullIntos]] は空でない：
◎
If this.[[pendingPullIntos]] is not empty,
</p>
		<ol>
			<li>
%firstDescriptor ~LET ~this.[[pendingPullIntos]] の最初の要素
◎
Let firstDescriptor be the first element of this.[[pendingPullIntos]].
</li>
			<li>
%firstDescriptor.[[bytesFilled]] ~SET `0^b
◎
Set firstDescriptor.[[bytesFilled]] to 0.
</li>
		</ol>
	</li>
	<li>
! `ResetQueue$A( ~this )
を遂行する
◎
Perform ! ResetQueue(this).
</li>
	<li>
~RET
! `PromiseInvokeOrNoop$A( ~this.[[underlyingByteSource]], `cancel^l, « %reason » )
◎
Return ! PromiseInvokeOrNoop(this.[[underlyingByteSource]], "cancel", « reason »)
</li>
</ol>

				</section>
				<section id="rbs-controller-private-pull">
<h5>3.10.5.2. `[[Pull]]()^rbsc</h5>

<ol class="algo">
	<li>
%stream ~LET ~this.[[controlledReadableStream]]
◎
Let stream be this.[[controlledReadableStream]].
</li>
	<li>
~Assert：
! `ReadableStreamHasDefaultReader$A( %stream ) ~EQ ~true
◎
Assert: ! ReadableStreamHasDefaultReader(stream) is true.
</li>
	<li>
<p>
~IF
~this.[[queueTotalSize]] ~GT `0^b：
◎
If this.[[queueTotalSize]] &gt; 0,
</p>
		<ol>
			<li>
~Assert：
! `ReadableStreamGetNumReadRequests$A( %stream ) ~EQ `0^b：
◎
Assert: ! ReadableStreamGetNumReadRequests(stream) is 0.
</li>
			<li>
%entry ~LET ~this.[[queue]] の最初の要素
◎
Let entry be the first element of this.[[queue]].
</li>
			<li>
~this.[[queue]] から %entry を除去する
— 後続の要素たちは~~先頭へ一つずらす
◎
Remove entry from this.[[queue]], shifting all other elements downward (so that the second becomes the first, and so on).
</li>
			<li>
~this.[[queueTotalSize]] ~DECBY %entry.[[byteLength]]
◎
Set this.[[queueTotalSize]] to this.[[queueTotalSize]] − entry.[[byteLength]].
</li>
			<li>
! `ReadableByteStreamControllerHandleQueueDrain$A( ~this )
を遂行する
◎
Perform ! ReadableByteStreamControllerHandleQueueDrain(this).
</li>
			<li>
%view ~LET
! `Construct$A( `~Uint8Array$, « %entry.[[buffer]], %entry.[[byteOffset]], %entry.[[byteLength]] » )
◎
Let view be ! Construct(%Uint8Array%, « entry.[[buffer]], entry.[[byteOffset]], entry.[[byteLength]] »).
</li>
			<li>
~RET
! `CreateIterResultObject$A( %view, ~false )
で`解決された~promise$
◎
Return a promise resolved with ! CreateIterResultObject(view, false).
</li>
		</ol>
	</li>
	<li>
%autoAllocateChunkSize ~LET ~this.[[autoAllocateChunkSize]]
◎
Let autoAllocateChunkSize be this.[[autoAllocateChunkSize]].
</li>
	<li>
<p>
~IF
%autoAllocateChunkSize ~NEQ ~undefined
：
◎
If autoAllocateChunkSize is not undefined,
</p>
		<ol>
			<li>
%buffer ~LET `Construct$A( `~ArrayBuffer$, « %autoAllocateChunkSize » )
◎
Let buffer be Construct(%ArrayBuffer%, « autoAllocateChunkSize »).
</li>
			<li>
~IF
%buffer は`中途完了$である
⇒
~RET %buffer.[[Value]] で`却下された~promise$
◎
If buffer is an abrupt completion, return a promise rejected with buffer.[[Value]].
</li>
			<li>
%pullIntoDescriptor ~LET `~Record$ {
<span class="record-entries"
>[[buffer]]: %buffer.[[Value]],
[[byteOffset]]: `0^b,
[[byteLength]]: %autoAllocateChunkSize,
[[bytesFilled]]: `0^b,
[[elementSize]]: `1^b,
[[ctor]]: `~Uint8Array$,
[[readerType]]: `default^l
</span>
}
◎
Let pullIntoDescriptor be Record {[[buffer]]: buffer.[[Value]], [[byteOffset]]: 0, [[byteLength]]: autoAllocateChunkSize, [[bytesFilled]]: 0, [[elementSize]]: 1, [[ctor]]: %Uint8Array%, [[readerType]]: "default"}.
</li>
			<li>
%pullIntoDescriptor を ~this.[[pendingPullIntos]] の~~末尾に付加する
◎
Append pullIntoDescriptor as the last element of this.[[pendingPullIntos]].
</li>
		</ol>
	</li>
	<li>
%promise ~LET
! `ReadableStreamAddReadRequest$A( %stream )
◎
Let promise be ! ReadableStreamAddReadRequest(stream).
</li>
	<li>
! `ReadableByteStreamControllerCallPullIfNeeded$A( ~this )
を遂行する
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(this).
</li>
	<li>
~RET %promise 
◎
Return promise.
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="rs-byob-request-class">
<h3 title="Class ReadableStreamBYOBRequest">3.11. `ReadableStreamBYOBRequest^C ~class</h3>

<p>
`ReadableStreamBYOBRequest$C ~classは、
`ReadableByteStreamController$C 内の［
中へ~pullする要請
］を表現する。
◎
The ReadableStreamBYOBRequest class represents a pull into request in a ReadableByteStreamController.
</p>



			<section id="rs-byob-request-class-definition">
<h4 title="Class Definition">3.11.1. ~class定義</h4>

~INFORMATIVE

<p>
`ReadableStreamBYOBRequest$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば，次のようになる：
◎
If one were to write the ReadableStreamBYOBRequest class in something close to the syntax of [ECMASCRIPT], it would look like
</p>

<pre class="lang-javascript">
class ReadableStreamBYOBRequest {
  constructor(%controller, %view)

  get view()

  respond(%bytesWritten)
  respondWithNewView(%view)
}
</pre>


			</section>
			<section id="rs-byob-request-internal-slots">
<h4 title="Internal Slots">3.11.2. 内部~slot</h4>

<p>
`ReadableStreamBYOBRequest$C の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of ReadableStreamBYOBRequest are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th title="Internal Slot">内部~slot
<th title="Description(non-normative)">説明0（<em>参考</em>）
</thead>

<tbody><tr><td>[[associatedReadableByteStreamController]]
<td>
親の `ReadableByteStreamController$C ~instance
◎
The parent ReadableByteStreamController instance


<tr><td>[[view]]
<td>
行先~領域を表現する `Uint8Array$I
— 制御器は、生成される~dataをその領域に書込できる。
◎
A typed array representing the destination region to which the controller may write generated data
</tbody></table>



			</section>
			<section id="rs-byob-request-constructor">
<h4>3.11.3. `new ReadableStreamBYOBRequest(controller, view)^c</h4>

<ol class="algo">
	<li>
~this.[[associatedReadableByteStreamController]] ~SET %controller
◎
Set this.[[associatedReadableByteStreamController]] to controller.
</li>
	<li>
~this.[[view]] ~SET %view
◎
Set this.[[view]] to view.
</li>
</ol>

			</section>
			<section id="rs-byob-request-prototype">
<h4 title="Properties of the ReadableStreamBYOBRequest Prototype">3.11.4. `ReadableStreamBYOBRequest^C ~prototypeの各種~prop</h4>



				<section id="rs-byob-request-view">
<h5>3.11.4.1. `get view^c</h5>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamBYOBRequest$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamBYOBRequest(this) is false, throw a TypeError exception.
</li>
	<li>
~RET ~this.[[view]]
◎
Return this.[[view]].
</li>
</ol>

				</section>
				<section id="rs-byob-request-respond">
<h5>3.11.4.2. `respond(bytesWritten)^c</h5>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamBYOBRequest$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamBYOBRequest(this) is false, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[associatedReadableByteStreamController]] ~EQ ~undefined
⇒
~THROW `TypeError^b
◎
If this.[[associatedReadableByteStreamController]] is undefined, throw a TypeError exception.
</li>
	<li>
~RET
? `ReadableByteStreamControllerRespond$A( ~this.[[associatedReadableByteStreamController]], %bytesWritten )
◎
Return ? ReadableByteStreamControllerRespond(this.[[associatedReadableByteStreamController]], bytesWritten).
</li>
</ol>

				</section>
				<section id="rs-byob-request-respond-with-new-view">
<h5>3.11.4.3. `respondWithNewView(view)^c</h5>

<ol class="algo">
	<li>
~IF
! `IsReadableStreamBYOBRequest$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsReadableStreamBYOBRequest(this) is false, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[associatedReadableByteStreamController]] ~EQ ~undefined
⇒
~THROW `TypeError^b
◎
If this.[[associatedReadableByteStreamController]] is undefined, throw a TypeError exception.
</li>
	<li>
~IF
`Type$A( %view ) ~NEQ `Object^b
⇒
~THROW `TypeError^b
◎
If Type(view) is not Object, throw a TypeError exception.
</li>
	<li>
~IF
%view は [[ViewedArrayBuffer]] 内部~slotを持たない
⇒
~THROW `TypeError^b
◎
If view does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError exception.
</li>
	<li>
~RET
? `ReadableByteStreamControllerRespondWithNewView$A( ~this.[[associatedReadableByteStreamController]], %view)
◎
Return ? ReadableByteStreamControllerRespondWithNewView(this.[[associatedReadableByteStreamController]], view).
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="rbs-controller-abstract-ops">
<h3 title="Readable Stream BYOB Controller Abstract Operations">3.12. 可読~streamの~BYOB制御器の抽象~演算</h3>



			<section id="is-readable-stream-byob-request">
<h4 class="nothrow">3.12.1. `IsReadableStreamBYOBRequest ( x )^A</h4>

<ol class="algo">
	<li>
~IF
`Type$A(%x) ~NEQ `Object^b
⇒
~RET ~false
◎
If Type(x) is not Object, return false.
</li>
	<li>
~IF
%x は [[associatedReadableByteStreamController]] 内部~slotを持たない
⇒
~RET ~false
◎
If x does not have an [[associatedReadableByteStreamController]] internal slot, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="is-readable-byte-stream-controller">
<h4 class="nothrow">3.12.2. `IsReadableByteStreamController ( x )^A</h4>

<ol class="algo">
	<li>
~IF
`Type$A(%x) ~NEQ `Object^b
⇒
~RET ~false
◎
If Type(x) is not Object, return false.
</li>
	<li>
~IF
%x は [[underlyingByteSource]] 内部~slotを持たない
⇒
~RET ~false
◎
If x does not have an [[underlyingByteSource]] internal slot, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-call-pull-if-needed">
<h4 class="nothrow">3.12.3. `ReadableByteStreamControllerCallPullIfNeeded ( controller )^A</h4>

<ol class="algo">
	<li>
%shouldPull ~LET
! `ReadableByteStreamControllerShouldCallPull$A( %controller )
◎
Let shouldPull be ! ReadableByteStreamControllerShouldCallPull(controller).
</li>
	<li>
~IF
%shouldPull ~EQ ~false
⇒
~RET
◎
If shouldPull is false, return.
</li>
	<li>
<p>
~IF
%controller.[[pulling]] ~EQ ~true
：
◎
If controller.[[pulling]] is true,
</p>
		<ol>
			<li>
%controller.[[pullAgain]] ~SET ~true
◎
Set controller.[[pullAgain]] to true.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~Assert：
%controller.[[pullAgain]] ~EQ ~false
◎
Assert: controller.[[pullAgain]] is false.
</li>
	<li>
%controller.[[pulling]] ~SET ~true
◎
Set controller.[[pulling]] to true.
</li>
	<li>
%pullPromise ~LET
! `PromiseInvokeOrNoop$A( %controller.[[underlyingByteSource]], `pull^l, « %controller » )
◎
Let pullPromise be ! PromiseInvokeOrNoop(controller.[[underlyingByteSource]], "pull", « controller »).
</li>
	<li>
<p>
%pullPromise の`充足~時$には：
◎
Upon fulfillment of pullPromise,
</p>
		<ol>
			<li>
%controller.[[pulling]] ~SET ~false
◎
Set controller.[[pulling]] to false.
</li>
			<li>
<p>
~IF
%controller.[[pullAgain]] ~EQ ~true
：
◎
If controller.[[pullAgain]] is true,
</p>
				<ol>
					<li>
%controller.[[pullAgain]] ~SET ~false
◎
Set controller.[[pullAgain]] to false.
</li>
					<li>
! `ReadableByteStreamControllerCallPullIfNeeded$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
事由 %e による
%pullPromise の`却下~時$には：
◎
Upon rejection of pullPromise with reason e,
</p>
		<ol>
			<li>
~IF
%controller.[[controlledReadableStream]].[[state]] ~EQ `readable^l
⇒
! `ReadableByteStreamControllerError$A( %controller, %e )
を遂行する
◎
If controller.[[controlledReadableStream]].[[state]] is "readable", perform ! ReadableByteStreamControllerError(controller, e).
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-clear-pending-pull-intos">
<h4 class="nothrow">3.12.4. `ReadableByteStreamControllerClearPendingPullIntos ( controller )^A</h4>


<ol class="algo">
	<li>
! `ReadableByteStreamControllerInvalidateBYOBRequest$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerInvalidateBYOBRequest(controller).
</li>
	<li>
%controller.[[pendingPullIntos]] ~SET 新たな空`~List$
◎
Set controller.[[pendingPullIntos]] to a new empty List.
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-close">
<h4 class="throws">3.12.5. `ReadableByteStreamControllerClose ( controller )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~Assert：
%controller.[[closeRequested]] ~EQ ~false
◎
Assert: controller.[[closeRequested]] is false.
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
<p>
~IF
%controller.[[queueTotalSize]] ~GT `0^b：
◎
If controller.[[queueTotalSize]] &gt; 0,
</p>
		<ol>
			<li>
%controller.[[closeRequested]] ~SET ~true
◎
Set controller.[[closeRequested]] to true.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~IF
%controller.[[pendingPullIntos]] は空でない
◎
If controller.[[pendingPullIntos]] is not empty,
</p>
		<ol>
			<li>
%firstPendingPullInto ~LET %controller.[[pendingPullIntos]] の最初の要素
◎
Let firstPendingPullInto be the first element of controller.[[pendingPullIntos]].
</li>
			<li>
<p>
~IF
%firstPendingPullInto.[[bytesFilled]] ~GT `0^b
◎
If firstPendingPullInto.[[bytesFilled]] &gt; 0,
</p>
				<ol>
					<li>
%e ~LET 新たな `TypeError^b 例外
◎
Let e be a new TypeError exception.
</li>
					<li>
! `ReadableByteStreamControllerError$A( %controller, %e )
を遂行する
◎
Perform ! ReadableByteStreamControllerError(controller, e).
</li>
					<li>
~THROW %e
◎
Throw e.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
! `ReadableStreamClose$A( %stream )
を遂行する
◎
Perform ! ReadableStreamClose(stream).
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-commit-pull-into-descriptor">
<h4 class="nothrow">3.12.6. `ReadableByteStreamControllerCommitPullIntoDescriptor ( stream, pullIntoDescriptor )^A</h4>

<ol class="algo">
	<li>
~Assert：
%stream.[[state]] ~NEQ `errored^l
◎
Assert: stream.[[state]] is not "errored".
</li>
	<li>
%done ~LET ~false
◎
Let done be false.
</li>
	<li>
<p>
~IF
%stream.[[state]] ~EQ `closed^l
：
◎
If stream.[[state]] is "closed",
</p>
		<ol>
			<li>
~Assert：
%pullIntoDescriptor.[[bytesFilled]] ~EQ `0^b
◎
Assert: pullIntoDescriptor.[[bytesFilled]] is 0.
</li>
			<li>
%done ~SET ~true
◎
Set done to true.
</li>
		</ol>
	</li>
	<li>
%filledView ~LET
! `ReadableByteStreamControllerConvertPullIntoDescriptor$A( %pullIntoDescriptor )
◎
Let filledView be ! ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor).
</li>
	<li>
<p>
~IF
%pullIntoDescriptor.[[readerType]] ~EQ `default^l
：
◎
If pullIntoDescriptor.[[readerType]] is "default",
</p>
		<ol>
			<li>
! `ReadableStreamFulfillReadRequest$A( %stream, %filledView, %done )
を遂行する
◎
Perform ! ReadableStreamFulfillReadRequest(stream, filledView, done).
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%pullIntoDescriptor.[[readerType]] ~EQ `byob^l
：
◎
Assert: pullIntoDescriptor.[[readerType]] is "byob".
</li>
			<li>
! `ReadableStreamFulfillReadIntoRequest$A( %stream, %filledView, %done )
を遂行する
◎
Perform ! ReadableStreamFulfillReadIntoRequest(stream, filledView, done).
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-convert-pull-into-descriptor">
<h4 class="nothrow">3.12.7. `ReadableByteStreamControllerConvertPullIntoDescriptor ( pullIntoDescriptor )^A</h4>

<ol class="algo">
	<li>
%bytesFilled ~LET %pullIntoDescriptor.[[bytesFilled]]
◎
Let bytesFilled be pullIntoDescriptor.[[bytesFilled]].
</li>
	<li>
%elementSize ~LET %pullIntoDescriptor.[[elementSize]]
◎
Let elementSize be pullIntoDescriptor.[[elementSize]].
</li>
	<li>
~Assert：
%bytesFilled ~LTE %pullIntoDescriptor.[[byteLength]]
◎
Assert: bytesFilled ≤ pullIntoDescriptor.[[byteLength]].
</li>
	<li>
~Assert：
( %bytesFilled ~mod %elementSize ) ~EQ `0^b
◎
Assert: bytesFilled mod elementSize is 0.
</li>
	<li>
~RET
! `Construct$A( %pullIntoDescriptor.[[ctor]], « %pullIntoDescriptor.[[buffer]], %pullIntoDescriptor.[[byteOffset]], %bytesFilled ÷ %elementSize » )
◎
Return ! Construct(pullIntoDescriptor.[[ctor]], « pullIntoDescriptor.[[buffer]], pullIntoDescriptor.[[byteOffset]], bytesFilled ÷ elementSize »).
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-enqueue">
<h4 class="nothrow">3.12.8. `ReadableByteStreamControllerEnqueue ( controller, chunk )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~Assert：
%controller.[[closeRequested]] ~EQ ~false
◎
Assert: controller.[[closeRequested]] is false.
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
%buffer ~LET %chunk.[[ViewedArrayBuffer]]
◎
Let buffer be chunk.[[ViewedArrayBuffer]].
</li>
	<li>
%byteOffset ~LET %chunk.[[ByteOffset]]
◎
Let byteOffset be chunk.[[ByteOffset]].
</li>
	<li>
%byteLength ~LET %chunk.[[ByteLength]]
◎
Let byteLength be chunk.[[ByteLength]].
</li>
	<li>
%transferredBuffer ~LET
! `Transfer$A( %buffer, `現在の~Realm~Record$ )
◎
Let transferredBuffer be ! Transfer(buffer, the current Realm Record).
</li>
	<li>
<p>
~IF
! `ReadableStreamHasDefaultReader$A( %stream ) ~EQ ~true
◎
If ! ReadableStreamHasDefaultReader(stream) is true
</p>
		<ol>
			<li>
<p>
~IF
! `ReadableStreamGetNumReadRequests$A( %stream ) ~EQ `0^b：
◎
If ! ReadableStreamGetNumReadRequests(stream) is 0,
</p>
				<ol>
					<li>
! `ReadableByteStreamControllerEnqueueChunkToQueue$A( %controller, %transferredBuffer, %byteOffset, %byteLength )
を遂行する
◎
Perform ! ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength).
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise,
</p>
				<ol>
					<li>
~Assert：
%controller.[[queue]] は空である
◎
Assert: controller.[[queue]] is empty.
</li>
					<li>
%transferredView ~LET
! `Construct$A( `~Uint8Array$, « %transferredBuffer, %byteOffset, %byteLength » )
◎
Let transferredView be ! Construct(%Uint8Array%, « transferredBuffer, byteOffset, byteLength »).
</li>
					<li>
! `ReadableStreamFulfillReadRequest$A( %stream, %transferredView, ~false )
を遂行する
◎
Perform ! ReadableStreamFulfillReadRequest(stream, transferredView, false).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF
! `ReadableStreamHasBYOBReader$A( %stream ) ~EQ ~true
：
◎
Otherwise, if ! ReadableStreamHasBYOBReader(stream) is true,
</p>
		<ol>
			<li>
! `ReadableByteStreamControllerEnqueueChunkToQueue$A( %controller, %transferredBuffer, %byteOffset, %byteLength )
を遂行する
◎
Perform ! ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength).
</li>
			<li>
! `ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller).
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
! `IsReadableStreamLocked$A( %stream ) ~EQ ~false
◎
Assert: ! IsReadableStreamLocked(stream) is false.
</li>
			<li>
! `ReadableByteStreamControllerEnqueueChunkToQueue$A( %controller, %transferredBuffer, %byteOffset, %byteLength )
を遂行する
◎
Perform ! ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength).
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-enqueue-chunk-to-queue">
<h4 class="nothrow">3.12.9. `ReadableByteStreamControllerEnqueueChunkToQueue ( controller, buffer, byteOffset, byteLength )^A</h4>

<ol class="algo">
	<li>
%controller.[[queue]] の~~末尾に `~Record$ {
<span class="record-entries"
>{[[buffer]]: %buffer,
[[byteOffset]]: %byteOffset,
[[byteLength]]: %byteLength 
</span>
} を付加する
◎
Append Record {[[buffer]]: buffer, [[byteOffset]]: byteOffset, [[byteLength]]: byteLength} as the last element of controller.[[queue]].
</li>
	<li>
%controller.[[queueTotalSize]] ~INCBY %byteLength
◎
Add byteLength to controller.[[queueTotalSize]].
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-error">
<h4 class="nothrow">3.12.10. `ReadableByteStreamControllerError ( controller, e )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
	<li>
! `ReadableByteStreamControllerClearPendingPullIntos$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerClearPendingPullIntos(controller).
</li>
	<li>
! `ResetQueue$A( %controller )
を遂行する
◎
Perform ! ResetQueue(controller).
</li>
	<li>
! `ReadableStreamError$A( %stream, %e )
を遂行する
◎
Perform ! ReadableStreamError(stream, e).
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-fill-head-pull-into-descriptor">
<h4 class="nothrow">3.12.11. `ReadableByteStreamControllerFillHeadPullIntoDescriptor ( controller, size, pullIntoDescriptor )^A</h4>

<ol class="algo">
	<li>
~Assert：［
%controller.[[pendingPullIntos]] は空である
］~OR［
%controller.[[pendingPullIntos]] の最初の要素 ~EQ %pullIntoDescriptor
］
◎
Assert: either controller.[[pendingPullIntos]] is empty, or the first element of controller.[[pendingPullIntos]] is pullIntoDescriptor.
</li>
	<li>
! `ReadableByteStreamControllerInvalidateBYOBRequest$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerInvalidateBYOBRequest(controller).
</li>
	<li>
%pullIntoDescriptor.[[bytesFilled]] ~INCBY %size
◎
Set pullIntoDescriptor.[[bytesFilled]] to pullIntoDescriptor.[[bytesFilled]] + size.
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-fill-pull-into-descriptor-from-queue">
<h4 class="nothrow">3.12.12. `ReadableByteStreamControllerFillPullIntoDescriptorFromQueue ( controller, pullIntoDescriptor )^A</h4>

<ol class="algo">
	<li>
%elementSize ~LET %pullIntoDescriptor.[[elementSize]]
◎
Let elementSize be pullIntoDescriptor.[[elementSize]].
</li>
	<li>
%currentAlignedBytes ~LET
( %pullIntoDescriptor.[[bytesFilled]] − ( %pullIntoDescriptor.[[bytesFilled]] ~mod %elementSize ) )
◎
Let currentAlignedBytes be pullIntoDescriptor.[[bytesFilled]] − (pullIntoDescriptor.[[bytesFilled]] mod elementSize).
</li>
	<li>
%maxBytesToCopy ~LET
`min$( %controller.[[queueTotalSize]],
( %pullIntoDescriptor.[[byteLength]] − %pullIntoDescriptor.[[bytesFilled]] )
)
◎
Let maxBytesToCopy be min(controller.[[queueTotalSize]], pullIntoDescriptor.[[byteLength]] − pullIntoDescriptor.[[bytesFilled]]).
</li>
	<li>
%maxBytesFilled ~LET
( %pullIntoDescriptor.[[bytesFilled]] + %maxBytesToCopy )
◎
Let maxBytesFilled be pullIntoDescriptor.[[bytesFilled]] + maxBytesToCopy.
</li>
	<li>
%maxAlignedBytes ~LET
( %maxBytesFilled − ( %maxBytesFilled ~mod %elementSize ) )
◎
Let maxAlignedBytes be maxBytesFilled − (maxBytesFilled mod elementSize).
</li>
	<li>
%totalBytesToCopyRemaining ~LET %maxBytesToCopy 
◎
Let totalBytesToCopyRemaining be maxBytesToCopy.
</li>
	<li>
%ready ~LET ~false
◎
Let ready be false.
</li>
	<li>
<p>
~IF
%maxAlignedBytes ~GT %currentAlignedBytes 
：
◎
If maxAlignedBytes &gt; currentAlignedBytes,
</p>
		<ol>
			<li>
%totalBytesToCopyRemaining ~SET %maxAlignedBytes − %pullIntoDescriptor.[[bytesFilled]]
◎
Set totalBytesToCopyRemaining to maxAlignedBytes − pullIntoDescriptor.[[bytesFilled]].
</li>
			<li>
%ready ~SET ~true
◎
Set ready to true.
</li>
		</ol>
	</li>
	<li>
%queue ~LET %controller.[[queue]]
◎
Let queue be controller.[[queue]].
</li>
	<li>
<p>
~WHILE %totalBytesToCopyRemaining ~GT `0^b：
◎
Repeat the following steps while totalBytesToCopyRemaining &gt; 0,
</p>
		<ol>
			<li>
%headOfQueue ~LET %queue の最初の要素
◎
Let headOfQueue be the first element of queue.
</li>
			<li>
%bytesToCopy ~LET
`min$( %totalBytesToCopyRemaining, %headOfQueue.[[byteLength]] )
◎
Let bytesToCopy be min(totalBytesToCopyRemaining, headOfQueue.[[byteLength]]).
</li>
			<li>
%destStart ~LET
( %pullIntoDescriptor.[[byteOffset]] + %pullIntoDescriptor.[[bytesFilled]] )
◎
Let destStart be pullIntoDescriptor.[[byteOffset]] + pullIntoDescriptor.[[bytesFilled]].
</li>
			<li>
! `CopyDataBlockBytes$A( %headOfQueue.[[buffer]].[[ArrayBufferData]], %headOfQueue.[[byteOffset]], %pullIntoDescriptor.[[buffer]].[[ArrayBufferData]], %destStart, %bytesToCopy )
を遂行する
◎
Perform ! CopyDataBlockBytes(headOfQueue.[[buffer]].[[ArrayBufferData]], headOfQueue.[[byteOffset]], pullIntoDescriptor.[[buffer]].[[ArrayBufferData]], destStart, bytesToCopy).
</li>
			<li>
<p>
~IF
%headOfQueue.[[byteLength]] ~EQ %bytesToCopy 
：
◎
If headOfQueue.[[byteLength]] is bytesToCopy,
</p>
				<ol>
					<li>
%queue の最初の要素を除去する
— 後続の要素たちは~~先頭へ一つずらす
◎
Remove the first element of queue, shifting all other elements downward (so that the second becomes the first, and so on).
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise,
</p>
				<ol>
					<li>
%headOfQueue.[[byteOffset]] ~INCBY %bytesToCopy
◎
Set headOfQueue.[[byteOffset]] to headOfQueue.[[byteOffset]] + bytesToCopy.
</li>
					<li>
%headOfQueue.[[byteLength]] ~DECBY %bytesToCopy
◎
Set headOfQueue.[[byteLength]] to headOfQueue.[[byteLength]] − bytesToCopy.
</li>
				</ol>
			</li>
			<li>
%controller.[[queueTotalSize]] ~DECBY %bytesToCopy
◎
Set controller.[[queueTotalSize]] to controller.[[queueTotalSize]] − bytesToCopy.
</li>
			<li>
! `ReadableByteStreamControllerFillHeadPullIntoDescriptor$A( %controller, %bytesToCopy, %pullIntoDescriptor )
を遂行する
◎
Perform ! ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor).
</li>
			<li>
%totalBytesToCopyRemaining ~DECBY %bytesToCopy
◎
Set totalBytesToCopyRemaining to totalBytesToCopyRemaining − bytesToCopy.
</li>
		</ol>
	</li>
	<li>
<p>
~IF
%ready ~EQ ~false
：
◎
If ready is false,
</p>
		<ol>
			<li>
~Assert：
%controller.[[queueTotalSize]] ~EQ `0^b
◎
Assert: controller.[[queueTotalSize]] is 0.
</li>
			<li>
~Assert：
%pullIntoDescriptor.[[bytesFilled]] ~GT `0^b
◎
Assert: pullIntoDescriptor.[[bytesFilled]] &gt; 0.
</li>
			<li>
~Assert：
%pullIntoDescriptor.[[bytesFilled]] ~LT %pullIntoDescriptor.[[elementSize]]
◎
Assert: pullIntoDescriptor.[[bytesFilled]] &lt; pullIntoDescriptor.[[elementSize]].
</li>
		</ol>
	</li>
	<li>
~RET %ready 
◎
Return ready.
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-get-desired-size">
<h4 class="nothrow">3.12.13. `ReadableByteStreamControllerGetDesiredSize ( controller )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
~IF
%state ~EQ `errored^l
⇒
~RET `null^b
◎
If state is "errored", return null.
</li>
	<li>
~IF %state ~EQ `closed^l
⇒
~RET `0^b
◎
If state is "closed", return 0.
</li>

	<li>
~RET %controller.[[strategyHWM]] − %controller.[[queueTotalSize]]
◎
Return controller.[[strategyHWM]] − controller.[[queueTotalSize]].
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-handle-queue-drain">
<h4 class="nothrow">3.12.14. `ReadableByteStreamControllerHandleQueueDrain ( controller )^A</h4>

<ol class="algo">
	<li>
~Assert：
%controller.[[controlledReadableStream]].[[state]] ~EQ `readable^l
◎
Assert: controller.[[controlledReadableStream]].[[state]] is "readable".
</li>
	<li>
<p>
~IF
%controller.[[queueTotalSize]] ~EQ `0^b；<br>
%controller.[[closeRequested]] ~EQ ~true
：
◎
If controller.[[queueTotalSize]] is 0 and controller.[[closeRequested]] is true,
</p>
		<ol>
			<li>
! `ReadableStreamClose$A( %controller.[[controlledReadableStream]] )
を遂行する
◎
Perform ! ReadableStreamClose(controller.[[controlledReadableStream]]).
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
! `ReadableByteStreamControllerCallPullIfNeeded$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-invalidate-byob-request">
<h4 class="nothrow">3.12.15. `ReadableByteStreamControllerInvalidateBYOBRequest ( controller )^A</h4>

<ol class="algo">
	<li>
~IF［
%controller.[[byobRequest]] ~EQ ~undefined
］
⇒
~RET
◎
If controller.[[byobRequest]] is undefined, return.
</li>
	<li>
%controller.[[byobRequest]].[[associatedReadableByteStreamController]] ~SET ~undefined
◎
Set controller.[[byobRequest]].[[associatedReadableByteStreamController]] to undefined.
</li>
	<li>
%controller.[[byobRequest]].[[view]] ~SET ~undefined
◎
Set controller.[[byobRequest]].[[view]] to undefined.
</li>
	<li>
%controller.[[byobRequest]] ~SET ~undefined
◎
Set controller.[[byobRequest]] to undefined.
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-process-pull-into-descriptors-using-queue">
<h4 class="nothrow">3.12.16. `ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue ( controller )^A</h4>

<ol class="algo">
	<li>
~Assert：
%controller.[[closeRequested]] ~EQ ~false
◎
Assert: controller.[[closeRequested]] is false.
</li>
	<li>
<p>
~WHILE %controller.[[pendingPullIntos]] は空でない：
◎
Repeat the following steps while controller.[[pendingPullIntos]] is not empty,
</p>
		<ol>
			<li>
~IF
%controller.[[queueTotalSize]] ~EQ `0^b
⇒
~RET
◎
If controller.[[queueTotalSize]] is 0, return.
</li>
			<li>
%pullIntoDescriptor ~LET %controller.[[pendingPullIntos]] の最初の要素
◎
Let pullIntoDescriptor be the first element of controller.[[pendingPullIntos]].
</li>
			<li>
<p>
~IF
! `ReadableByteStreamControllerFillPullIntoDescriptorFromQueue$A( %controller, %pullIntoDescriptor ) ~EQ ~true
：
◎
If ! ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) is true,
</p>
				<ol>
					<li>
! `ReadableByteStreamControllerShiftPendingPullInto$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerShiftPendingPullInto(controller).
</li>
					<li>
! `ReadableByteStreamControllerCommitPullIntoDescriptor$A( %controller.[[controlledReadableStream]], %pullIntoDescriptor)
を遂行する
◎
Perform ! ReadableByteStreamControllerCommitPullIntoDescriptor(controller.[[controlledReadableStream]], pullIntoDescriptor).
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-pull-into">
<h4 class="nothrow">3.12.17. `ReadableByteStreamControllerPullInto ( controller, view )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
%elementSizem ~LET `1^b
◎
Let elementSize be 1.
</li>
	<li>
%ctor ~LET ~DataView
◎
Let ctor be %DataView%.
</li>
	<li>
~IF
%view は [[TypedArrayName]] 内部~slotを持つ（すなわち， `DataView$I ではない）
⇒
( %elementSizem, %ctor ) ~SET
%view.[[TypedArrayName]] に対し
<a href="~TC39#sec-dataview-objects">有型~配列 構築子 table</a>
に指定される
( 要素~size, 構築子 )
◎
If view has a [[TypedArrayName]] internal slot (i.e., it is not a DataView),
◎
Set elementSize to the element size specified in the typed array constructors table for view.[[TypedArrayName]].
◎
Set ctor to the constructor specified in the typed array constructors table for view.[[TypedArrayName]].
</li>
	<li>
%pullIntoDescriptor ~LET `~Record$ {
<span class="record-entries"
>[[buffer]]: %view.[[ViewedArrayBuffer]],
[[byteOffset]]: %view.[[ByteOffset]],
[[byteLength]]: %view.[[ByteLength]],
[[bytesFilled]]: `0^b,
[[elementSize]]: %elementSize,
[[ctor]]: %ctor,
[[readerType]]: `byob^l
</span>
}
◎
Let pullIntoDescriptor be Record {[[buffer]]: view.[[ViewedArrayBuffer]], [[byteOffset]]: view.[[ByteOffset]], [[byteLength]]: view.[[ByteLength]], [[bytesFilled]]: 0, [[elementSize]]: elementSize, [[ctor]]: ctor, [[readerType]]: "byob"}.
</li>
	<li>
<p>
~IF
%controller.[[pendingPullIntos]] は空でない：
◎
If controller.[[pendingPullIntos]] is not empty,
</p>
		<ol>
			<li>
%pullIntoDescriptor.[[buffer]] ~SET
! `Transfer$A( %pullIntoDescriptor.[[buffer]], `現在の~Realm~Record$ )
◎
Set pullIntoDescriptor.[[buffer]] to ! Transfer(pullIntoDescriptor.[[buffer]], the current Realm Record).
</li>
			<li>
%pullIntoDescriptor を %controller.[[pendingPullIntos]] の~~末尾に付加する
◎
Append pullIntoDescriptor as the last element of controller.[[pendingPullIntos]].
</li>
			<li>
~RET
! `ReadableStreamAddReadIntoRequest$A( %stream )
◎
Return ! ReadableStreamAddReadIntoRequest(stream).
</li>
		</ol>
	</li>
	<li>
<p>
~IF
%stream.[[state]] ~EQ `closed^l
：
◎
If stream.[[state]] is "closed",
</p>
		<ol>
			<li>
%emptyView ~LET
! `Construct$A( %ctor, « %pullIntoDescriptor.[[buffer]], %pullIntoDescriptor.[[byteOffset]], `0^b » )
◎
Let emptyView be ! Construct(ctor, « pullIntoDescriptor.[[buffer]], pullIntoDescriptor.[[byteOffset]], 0 »).
</li>
			<li>
~RET
! `CreateIterResultObject$A( %emptyView, ~true )
で`解決された~promise$
◎
Return a promise resolved with ! CreateIterResultObject(emptyView, true).
</li>
		</ol>
	</li>
	<li>
<p>
~IF
%controller.[[queueTotalSize]] ~GT `0^b：
◎
If controller.[[queueTotalSize]] &gt; 0,
</p>
		<ol>
			<li>
<p>
~IF
! `ReadableByteStreamControllerFillPullIntoDescriptorFromQueue$A( %controller, %pullIntoDescriptor ) ~EQ ~true
：
◎
If ! ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) is true,
</p>
				<ol>
					<li>
%filledView ~LET
! `ReadableByteStreamControllerConvertPullIntoDescriptor$A( %pullIntoDescriptor )
◎
Let filledView be ! ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor).
</li>
					<li>
! `ReadableByteStreamControllerHandleQueueDrain$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerHandleQueueDrain(controller).
</li>
					<li>
~RET
! `CreateIterResultObject$A( %filledView, ~false )
で`解決された~promise$
◎
Return a promise resolved with ! CreateIterResultObject(filledView, false).
</li>
				</ol>
			</li>
			<li>
<p>
~IF
%controller.[[closeRequested]] ~EQ ~true
：
◎
If controller.[[closeRequested]] is true,
</p>
				<ol>
					<li>
%e ~LET `TypeError^b 例外
◎
Let e be a TypeError exception.
</li>
					<li>
! `ReadableByteStreamControllerError$A( %controller, %e )
を遂行する
◎
Perform ! ReadableByteStreamControllerError(controller, e).
</li>
					<li>
~RET %e で`却下された~promise$
◎
Return a promise rejected with e.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%pullIntoDescriptor.[[buffer]] ~SET
! `Transfer$A( %pullIntoDescriptor.[[buffer]], `現在の~Realm~Record$ )
◎
Set pullIntoDescriptor.[[buffer]] to ! Transfer(pullIntoDescriptor.[[buffer]], the current Realm Record).
</li>
	<li>
%pullIntoDescriptor を %controller.[[pendingPullIntos]] の~~末尾に付加する
◎
Append pullIntoDescriptor as the last element of controller.[[pendingPullIntos]].
</li>
	<li>
%promise ~LET
! `ReadableStreamAddReadIntoRequest$A( %stream )
◎
Let promise be ! ReadableStreamAddReadIntoRequest(stream).
</li>
	<li>
! `ReadableByteStreamControllerCallPullIfNeeded$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
</li>
	<li>
~RET %promise 
◎
Return promise.
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-respond">
<h4 class="throws">3.12.18. `ReadableByteStreamControllerRespond ( controller, bytesWritten )^A</h4>

<ol class="algo">
	<li>
%bytesWritten ~LET
? `ToNumber$A( %bytesWritten )
◎
Let bytesWritten be ? ToNumber(bytesWritten).
</li>
	<li>
<p>
~IF
! `IsFiniteNonNegativeNumber$A( %bytesWritten ) ~EQ ~false
⇒
~THROW `RangeError^b
◎
If ! IsFiniteNonNegativeNumber(bytesWritten) is false,
◎
　Throw a RangeError exception.
</li>
	<li>
~Assert：
%controller.[[pendingPullIntos]] は空でない
◎
Assert: controller.[[pendingPullIntos]] is not empty.
</li>
	<li>
? `ReadableByteStreamControllerRespondInternal$A( %controller, %bytesWritten )
を遂行する
◎
Perform ? ReadableByteStreamControllerRespondInternal(controller, bytesWritten).
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-respond-in-closed-state">
<h4 class="nothrow">3.12.19. `ReadableByteStreamControllerRespondInClosedState ( controller, firstDescriptor )^A</h4>

<ol class="algo">
	<li>
%firstDescriptor.[[buffer]] ~SET
! `Transfer$A( %firstDescriptor.[[buffer]], `現在の~Realm~Record$ )
◎
Set firstDescriptor.[[buffer]] to ! Transfer(firstDescriptor.[[buffer]], the current Realm Record).
</li>
	<li>
~Assert：
%firstDescriptor.[[bytesFilled]] ~EQ `0^b
◎
Assert: firstDescriptor.[[bytesFilled]] is 0.
</li>
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
<p>
~WHILE
! `ReadableStreamGetNumReadIntoRequests$A( %stream ) ~GT `0^b：
◎
Repeat the following steps while ! ReadableStreamGetNumReadIntoRequests(stream) &gt; 0,
</p>
		<ol>
			<li>
%pullIntoDescriptor ~LET
! `ReadableByteStreamControllerShiftPendingPullInto$A( %controller )
◎
Let pullIntoDescriptor be ! ReadableByteStreamControllerShiftPendingPullInto(controller).
</li>
			<li>
! `ReadableByteStreamControllerCommitPullIntoDescriptor$A( %stream, %pullIntoDescriptor)
を遂行する
◎
Perform ! ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor).
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-respond-in-readable-state">
<h4 class="throws">3.12.20. `ReadableByteStreamControllerRespondInReadableState ( controller, bytesWritten, pullIntoDescriptor )^A</h4>

<ol class="algo">
	<li>
~IF
( %pullIntoDescriptor.[[bytesFilled]] + %bytesWritten ) ~GT
%pullIntoDescriptor.[[byteLength]]
⇒
~THROW `RangeError^b
◎
If pullIntoDescriptor.[[bytesFilled]] + bytesWritten &gt; pullIntoDescriptor.[[byteLength]], throw a RangeError exception.
</li>
	<li>
! `ReadableByteStreamControllerFillHeadPullIntoDescriptor$A( %controller, %bytesWritten, %pullIntoDescriptor )
を遂行する
◎
Perform ! ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor).
</li>
	<li>
~IF
%pullIntoDescriptor.[[bytesFilled]] ~LT %pullIntoDescriptor.[[elementSize]]
⇒
~RET
◎
If pullIntoDescriptor.[[bytesFilled]] &lt; pullIntoDescriptor.[[elementSize]], return.
</li>
	<li>
! `ReadableByteStreamControllerShiftPendingPullInto$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerShiftPendingPullInto(controller).
</li>
	<li>
%remainderSize ~LET
( %pullIntoDescriptor.[[bytesFilled]] ~mod %pullIntoDescriptor.[[elementSize]] )
◎
Let remainderSize be pullIntoDescriptor.[[bytesFilled]] mod pullIntoDescriptor.[[elementSize]].
</li>
	<li>
<p>
~IF
%remainderSize ~GT `0^b：
◎
If remainderSize &gt; 0,
</p>
		<ol>
			<li>
%end ~LET
( %pullIntoDescriptor.[[byteOffset]] + %pullIntoDescriptor.[[bytesFilled]] )
◎
Let end be pullIntoDescriptor.[[byteOffset]] + pullIntoDescriptor.[[bytesFilled]].
</li>
			<li>
%remainder ~LET
? `CloneArrayBuffer$A( %pullIntoDescriptor.[[buffer]], ( %end − %remainderSize ), %remainderSize, `~ArrayBuffer$ )
◎
Let remainder be ? CloneArrayBuffer(pullIntoDescriptor.[[buffer]], end − remainderSize, remainderSize, %ArrayBuffer%).
</li>
			<li>
! `ReadableByteStreamControllerEnqueueChunkToQueue$A( %controller, %remainder, `0^b, %remainder.[[ByteLength]] )
を遂行する
◎
Perform ! ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.[[ByteLength]]).
</li>
		</ol>
	</li>
	<li>
%pullIntoDescriptor.[[buffer]] ~SET
! `Transfer$A( %pullIntoDescriptor.[[buffer]], `現在の~Realm~Record$ )
◎
Set pullIntoDescriptor.[[buffer]] to ! Transfer(pullIntoDescriptor.[[buffer]], the current Realm Record).
</li>
	<li>
%pullIntoDescriptor.[[bytesFilled]] ~SET
%pullIntoDescriptor.[[bytesFilled]] − %remainderSize 
◎
Set pullIntoDescriptor.[[bytesFilled]] to pullIntoDescriptor.[[bytesFilled]] − remainderSize.
</li>
	<li>
! `ReadableByteStreamControllerCommitPullIntoDescriptor$A( %controller.[[controlledReadableStream]], %pullIntoDescriptor )
を遂行する
◎
Perform ! ReadableByteStreamControllerCommitPullIntoDescriptor(controller.[[controlledReadableStream]], pullIntoDescriptor).
</li>
	<li>
! `ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller).
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-respond-internal">
<h4 class="throws">3.12.21. `ReadableByteStreamControllerRespondInternal ( controller, bytesWritten )^A</h4>

<ol class="algo">
	<li>
%firstDescriptor ~LET %controller.[[pendingPullIntos]] の最初の要素
◎
Let firstDescriptor be the first element of controller.[[pendingPullIntos]].
</li>
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
<p>
~IF
%stream.[[state]] ~EQ `closed^l
：
◎
If stream.[[state]] is "closed",
</p>
		<ol>
			<li>
~IF
%bytesWritten ~NEQ `0^b
⇒
~THROW `TypeError^b
◎
If bytesWritten is not 0, throw a TypeError exception.
</li>
			<li>
! `ReadableByteStreamControllerRespondInClosedState$A( %controller, %firstDescriptor )
を遂行する
◎
Perform ! ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor).
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%stream.[[state]] ~EQ `readable^l
◎
Assert: stream.[[state]] is "readable".
</li>
			<li>
? `ReadableByteStreamControllerRespondInReadableState$A( %controller, %bytesWritten, %firstDescriptor )
を遂行する
◎
Perform ? ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor).
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-respond-with-new-view">
<h4 class="throws">3.12.22. `ReadableByteStreamControllerRespondWithNewView ( controller, view )^A</h4>

<ol class="algo">
	<li>
~Assert：
%controller.[[pendingPullIntos]] は空でない
◎
Assert: controller.[[pendingPullIntos]] is not empty.
</li>
	<li>
%firstDescriptor ~LET %controller.[[pendingPullIntos]] の最初の要素
◎
Let firstDescriptor be the first element of controller.[[pendingPullIntos]].
</li>
	<li>
~IF
( %firstDescriptor.[[byteOffset]] + %firstDescriptor.[[bytesFilled]] ) ~NEQ %view.[[ByteOffset]]
⇒
~THROW `RangeError^b
◎
If firstDescriptor.[[byteOffset]] + firstDescriptor.[[bytesFilled]] is not view.[[ByteOffset]], throw a RangeError exception.
</li>
	<li>
~IF
%firstDescriptor.[[byteLength]] ~NEQ %view.[[ByteLength]]
⇒
~THROW `RangeError^b
◎
If firstDescriptor.[[byteLength]] is not view.[[ByteLength]], throw a RangeError exception.
</li>
	<li>
%firstDescriptor.[[buffer]] ~SET %view.[[ViewedArrayBuffer]]
◎
Set firstDescriptor.[[buffer]] to view.[[ViewedArrayBuffer]].
</li>
	<li>
? `ReadableByteStreamControllerRespondInternal$A( %controller, %view.[[ByteLength]] )
を遂行する
◎
Perform ? ReadableByteStreamControllerRespondInternal(controller, view.[[ByteLength]]).
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-shift-pending-pull-into">
<h4 class="nothrow">3.12.23. `ReadableByteStreamControllerShiftPendingPullInto ( controller )^A</h4>

<ol class="algo">
	<li>
%descriptor ~LET %controller.[[pendingPullIntos]] の最初の要素
◎
Let descriptor be the first element of controller.[[pendingPullIntos]].
</li>
	<li>
%controller.[[pendingPullIntos]] から %descriptor を除去する
— 後続の要素たちは~~先頭へ一つずらす
◎
Remove descriptor from controller.[[pendingPullIntos]], shifting all other elements downward (so that the second becomes the first, and so on).
</li>
	<li>
! `ReadableByteStreamControllerInvalidateBYOBRequest$A( %controller )
を遂行する
◎
Perform ! ReadableByteStreamControllerInvalidateBYOBRequest(controller).
</li>
	<li>
~RET %descriptor 
◎
Return descriptor.
</li>
</ol>

			</section>
			<section id="readable-byte-stream-controller-should-call-pull">
<h4 class="nothrow">3.12.24. `ReadableByteStreamControllerShouldCallPull ( controller )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledReadableStream]]
◎
Let stream be controller.[[controlledReadableStream]].
</li>
	<li>
~IF
%stream.[[state]] ~NEQ `readable^l
⇒
~RET ~false
◎
If stream.[[state]] is not "readable", return false.
</li>
	<li>
~IF
%controller.[[closeRequested]] ~EQ ~true
⇒
~RET ~false
◎
If controller.[[closeRequested]] is true, return false.
</li>
	<li>
~IF
%controller.[[started]] ~EQ ~false
⇒
~RET ~false
◎
If controller.[[started]] is false, return false.
</li>
	<li>
~IF［
! `ReadableStreamHasDefaultReader$A( %stream ) ~EQ ~true
］~AND［
! `ReadableStreamGetNumReadRequests$A( %stream ) ~GT `0^b
］
⇒
~RET ~true
◎
If ! ReadableStreamHasDefaultReader(stream) is true and ! ReadableStreamGetNumReadRequests(stream) &gt; 0, return true.
</li>
	<li>
~IF［
! `ReadableStreamHasBYOBReader$A( %stream ) ~EQ ~true
］~AND［
! `ReadableStreamGetNumReadIntoRequests$A( %stream ) ~GT `0^b
］
⇒
~RET ~true
◎
If ! ReadableStreamHasBYOBReader(stream) is true and ! ReadableStreamGetNumReadIntoRequests(stream) &gt; 0, return true.
</li>
	<li>
~IF
`ReadableByteStreamControllerGetDesiredSize$A( %controller ) ~GT `0^b
⇒
~RET ~true
◎
If ! ReadableByteStreamControllerGetDesiredSize(controller) &gt; 0, return true.
</li>
	<li>
~RET ~false
◎
Return false.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="ws">
<h2 title="Writable Streams">4. 可書~stream</h2>


<div class="warning" id="ws-not-ready-yet">

<p>
可書~stream仕様は、依然として安定化の途上にある。
最近になって大きく向上し，より~~想定に近いものになったが、依然として，出荷するまでには程遠い。
◎
The writable stream spec is still stabilizing, although it has recently improved a lot and is more aligned with our vision. Still, it is not quite yet ready to ship.
</p>

</div>


		<section id="ws-intro">
<h3 title="Using Writable Streams">4.1. 可書~streamの用法</h3>

<div class="example" id="example-basic-pipe-to-2">

<p>
`可読~stream$へ書込する通例的な仕方は、単純に，可読~streamをそれに`~pipeする$ことである。
これにより、その`背圧$が尊重されるようになる
— 可書~streamの`下層~槽$が，可読~streamが生産できるほど高速に~dataを受容できない場合に、可読~streamにその旨が伝わり，その~data生産を減速させる機会を得られるようになる。
◎
The usual way to write to a writable stream is to simply pipe a readable stream to it. This ensures that backpressure is respected, so that if the writable stream’s underlying sink is not able to accept data as fast as the readable stream can produce it, the readable stream is informed of this and has a chance to slow down its data production.
</p>

<pre class="lang-javascript">
readableStream.pipeTo(%writableStream)
  .then(() =&gt; console.log(`すべての~dataは成功裡に書込されました^l))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));
</pre>
<!-- 
"All data successfully written!"
"Something went wrong!"
 -->
</div>

<div class="example" id="example-manual-write-batch">

<p>
`書込器$を獲得して，その
`write()$dw ／ `close()$dw
~methodを利用すれば、可書~streamに直接的に書込することもできる。
それらは、［
流入~書込を，~queueした上で`下層~槽$へ順に回送する
］ことを，内部的に手入れするので、手間をかけず無差別的に，可書~streamへ書込できる：
◎
You can also write directly to writable streams by acquiring a writer and using its write() and close() methods. Since writable streams queue any incoming writes, and take care internally to forward them to the underlying sink in sequence, you can indiscriminately write to a writable stream without much ceremony:
</p>

<pre class="lang-javascript">
function writeArrayToStream(%array, %writableStream) {
  const %writer = %writableStream.getWriter();
  %array.forEach(%chunk =&gt; %writer.write(%chunk));

  return %writer.close();
}

writeArrayToStream([1, 2, 3, 4, 5], %writableStream)
  .then(() =&gt; console.log(`すべて終えました^l))
  .catch(%e =&gt; console.error(`~streamに~errorが生じました: ^l + %e));
</pre>

</div>

<div class="example" id="example-manual-write-with-error-handling">

<p>
これまでの例では、その `close()$dw ~methodから返された~promiseを見ることで，~stream全体の成功か失敗かについてのみに注目していた。
その~promise（ `closed$dw 取得子を利用して~accessすることもできる）は、~streamにて
— その初期化-時, それへの書込み時, その~close時にて —
何らかの不具合が生じたときに却下されることになり、また，~streamが成功裡に~closeされたなら 充足されることになる。
多くの場合、これについて~careしておけば済む。
◎
In the previous example we only paid attention to the success or failure of the entire stream, by looking at the promise returned by its close() method. That promise (which can also be accessed using the closed getter) will reject if anything goes wrong with the stream—initializing it, writing to it, or closing it. And it will fulfill once the stream is successfully closed. Often this is all you care about.
</p>

<p>
が、特定の`~chunk$に対し，書込みの成功について~careする場合は、~streamの `write()$dw ~methodから返される~promiseを利用できる：
◎
However, if you care about the success of writing a specific chunk, you can use the promise returned by the stream’s write() method:
</p>


<pre class="lang-javascript">
%writer.write(`~data内のある~chunk^l)
  .then(() =&gt; console.log(`~chunkは成功裡に書込されました^l))
  .catch(%e =&gt; console.error(%e));
</pre>
<!-- 
"i am a chunk of data"
"chunk successfully written!"
-->

<p>
“成功” が何を意味するかは、所与の~stream~instance（より精確には, その`下層~槽$）が決める。
例えば，~file~streamに対してなら、単純に OS が書込を受容したことを意味し，`~chunk$が~diskへ書出されることは必要とされないであろう。
◎
What "success" means is up to a given stream instance (or more precisely, its underlying sink) to decide. For example, for a file stream it could simply mean that the OS has accepted the write, and not necessarily that the chunk has been flushed to disk.
</p>
</div>

<div class="example" id="example-manual-write-with-backpressure">

<p>
`書込器$の［
`desiredSize$dw, `ready$dw
］~propにより、`生産器$は，~streamからの流れ制御の合図に より精確に応答して，記憶域の使用量を ~streamに指定された`限界水位$より下に保ち続けれるようになる。
次の例は、無限に続く~randomな~byte列を~streamに書込する
— その際に、 `desiredSize$dw を利用して，所与の時点に何~byte生成するかを決定し、 `ready$dw を利用して，`背圧$が収まるまで待機する。
◎
The desiredSize and ready properties of writable stream writers allow producers to more precisely respond to flow control signals from the stream, to keep memory usage below the stream’s specified high water mark. The following example writes an infinite sequence of random bytes to a stream, using desiredSize to determine how many bytes to generate at a given time, and using ready to wait for the backpressure to subside.
</p>

<pre class="lang-javascript">
async function writeRandomBytesForever(%writableStream) {
  const %writer = %writableStream.getWriter();

  while (true) {
    await %writer.ready;

    const %bytes = new Uint8Array(%writer.desiredSize);
    window.crypto.getRandomValues(%bytes);

    await %writer.write(%bytes);
  }
}

writeRandomBytesForever(myWritableStream).catch(
    e =&gt; console.error(`何か不具合が生じたようです^l, e)
);
</pre>
<!--
"Something broke"
 -->

</div>



		</section>
		<section id="ws-class">
<h3 title="Class WritableStream">4.2. `WritableStream^C ~class</h3>


			<section id="ws-class-definition">
<h4 title="Class Definition">4.2.1. ~class定義</h4>

~INFORMATIVE

<p>
`WritableStream$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば，次のようになる：
◎
If one were to write the WritableStream class in something close to the syntax of [ECMASCRIPT], it would look like
</p>


<pre class="lang-javascript">
class WritableStream {
  constructor(%underlyingSink = {}, { %size, %highWaterMark = 1 } = {})

  get locked()

  abort(%reason)
  getWriter()
}
</pre>



			</section>
			<section id="ws-internal-slots">
<h4 title="Internal Slots">4.2.2. 各種 内部~slot</h4>


<p>
`WritableStream$C の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of WritableStream are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th title="Internal Slot">内部~slot
<th title="Description(non-normative)">説明0（<em>参考</em>）
</thead>

<tbody>
<tr><td>[[backpressure]]
<td>
制御器により設定される~背圧~合図
◎
The backpressure signal set by the controller

<tr><td>[[closeRequest]]
<td>
書込器の `close()$dw ~methodから~返される~promise
◎
The promise returned from the writer close() method

<tr><td>[[inFlightWriteRequest]]
<td>
この~slotは、`下層~槽$の `write()^c ~methodが まだ実行-中で充足されていない間に，現在の~in-flight 【“~~処理中にある”】書込~演算のための~promiseに設定される。
これは、再入~callを防止するために利用される。
◎
A slot set to the promise for the current in-flight write operation while the underlying sink’s write method is executing and has not yet fulfilled, used to prevent reentrant calls

<tr><td>[[inFlightCloseRequest]]
<td>
この~slotは、`下層~槽$の `close()^c ~methodが まだ~実行-中で~充足されていない間に，現在の~in-flight~close演算のための~promiseに設定される。
これは、 `abort()$dw ~methodにより~closeが遮られるのを防止するために利用される。
◎
A slot set to the promise for the current in-flight close operation while the underlying sink’s close method is executing and has not yet fulfilled, used to prevent the abort() method from interrupting close

<tr><td>[[pendingAbortRequest]]
<td>
処理待ちの中止-演算に対する~promise
◎
The promise for a pending abort operation

<tr><td>[[state]]
<td>

内部に利用される ~streamの現在の状態を包含している文字列
— 次のいずれか：
`writable^l, `closed^l, `errored^l
◎
A string containing the stream’s current state, used internally; one of "writable", "closed", or "errored"


<tr><td>[[storedError]]
<td>
~streamが どのように失敗したかを指示する値
— ［
`errored^l 状態にある~stream上に演算しようと試行している
］ときに、失敗~事由か例外として与えられることになる。
◎
A value indicating how the stream failed, to be given as a failure reason or exception when trying to operate on the stream while in the "errored" state


<tr><td>[[writableStreamController]]
<td>
［
この~streamの状態と~queueを制御する能
］を伴って作成される `WritableStreamDefaultController$C 。
`IsWritableStream$A による~brand-checkにも利用される。
◎
A WritableStreamDefaultController created with the ability to control the state and queue of this stream; also used for the IsWritableStream brand check


<tr><td>[[writer]]
<td>
~streamが`書込器に~lock$されて［
いるならば `WritableStreamDefaultWriter$C の~instance ／
いなければ ~undefined
］。
◎
A WritableStreamDefaultWriter instance, if the stream is locked to a writer, or undefined if it is not


<tr><td>[[writeRequests]]
<td>
一連の［
`下層~槽$がまだ処理していない書込~要請に対する~promise
］からなる，~streamの内部~queueを表現する`~List$。
◎
A List of promises representing the stream’s internal queue of write requests not yet processed by the underlying sink.

</tbody></table>

<p class="note">注記：
[[inFlightCloseRequest]] ~slot,
[[closeRequest]] ~slotは、互いに排他的である。
また、［
[[inFlightWriteRequest]] ~NEQ ~undefined
］の間に [[writeRequests]] から要素が除去されることはない。
実装は、これらの不変則に基づいて これらの~slot用の~storageを最適化できる。
◎
The [[inFlightCloseRequest]] slot and [[closeRequest]] slot are mutually exclusive. Similarly, no element will be removed from [[writeRequests]] while [[inFlightWriteRequest]] is not undefined. Implementations can optimize storage for these slots based on these invariants.
</p>

			</section>
			<section id="ws-constructor">
<h4 >4.2.3. `new WritableStream( underlyingSink = {}, { size, highWaterMark = 1 } = {})^c</h4>

<div class="note">

<p>
構築子に渡される %underlyingSink （下層~槽）~objには、構築される~stream~instanceの挙動を統治する，以下の~methodを実装できる：
◎
The underlyingSink object passed to the constructor can implement any of the following methods to govern how the constructed stream instance behaves:
</p>

<ul>
	<li>
`start(controller)^c は、即時に~callされる。
それは、`下層~槽$への~accessを獲得するために必要とされる動作を遂行するべきである。
この処理が非同期的になる場合、成功か失敗かを合図する~promiseを返すようにすることもできる。
◎
start(controller) is called immediately, and should perform any actions necessary to acquire access to the underlying sink. If this process is asynchronous, it can return a promise to signal success or failure.
</li>
	<li>
`write(chunk, controller)^c は、`下層~槽$へ書込される新たな~dataの`~chunk$が準備済みになったときに~callされる。
書込~演算の成功か失敗かを合図する~promiseを返すようにすることもできる。
~stream実装は、この~methodが，［
以前の書込が成功した後にのみ~callされる
］こと, および［
`close^c ／ `abort^c が~callされた後には決して~callされない
］ことを保証する。
◎
write(chunk, controller) is called when a new chunk of data is ready to be written to the underlying sink. It can return a promise to signal success or failure of the write operation. The stream implementation guarantees that this method will be called only after previous writes have succeeded, and never after close or abort is called.
</li>
	<li>
`close(controller)^c は、`生産器$が［
自身による，一連の`~chunk$の~streamへの書込みを終え，
~queue-upされたすべての書込が成功裡に完了した
］ことを合図した後に~callされる。
それは、［
`下層~槽$への書込を完結させ，それへの~accessを解放する
］ために必要とされる動作を遂行するべきである。
この処理が非同期的になる場合、成功か失敗かを合図する~promiseを返すようにすることもできる。
~stream実装は、この~methodが［
~queue-upされたすべての書込が成功した後に
］のみ，~callされることを保証する。
◎
close(controller) is called after the producer signals that they are done writing chunks to the stream, and all queued-up writes successfully complete. It should perform any actions necessary to finalize writes to the underlying sink, and release access to it. If this process is asynchronous, it can return a promise to signal success or failure. The stream implementation guarantees that this method will be called only after all queued-up writes have succeeded.
</li>
	<li>
`abort(reason)^c は、`生産器$が［
~streamを中途で~closeして
それを ~error状態に置きたいと望む
］ことを合図するときに~callされる。
それは、保持されている資源があれば，`close^c とほぼ同様に片付けるべきであるが、おそらく 何らかの独自の取扱いも伴われる。
`close^c と違って、 `abort^c は，書込が~queue-upされていても~callされ、それらの`~chunk$たちは捨てられることになる。
この処理が非同期的になる場合、成功か失敗かを合図する~promiseを返すようにすることもできる。
◎
abort(reason) is called when the producer signals they wish to abruptly close the stream and put it in an errored state. It should clean up any held resources, much like close, but perhaps with some custom handling. Unlike close, abort will be called even if writes are queued up; those chunks will be thrown away. If this process is asynchronous, it can return a promise to signal success or failure.
</li>
</ul>

<p>
`start()^c ／ `write()^c ／ `close()^c
に渡される制御器~obj（ %controller ）は、 `WritableStreamDefaultController$C の~instanceであり，~streamを~errorさせる能を備える。
◎
The controller object passed to start, write and close is an instance of WritableStreamDefaultController, and has the ability to error the stream.
</p>

<p>
構築子は、 2 個目の引数に［
2 個の~prop［
非負~数 `highWaterMark^c, および `size(chunk)^c 関数
］を伴う`~queuing策$~obj
］を受容する。
給される `strategy^c は、組込みの［
`CountQueuingStrategy$C ／ `ByteLengthQueuingStrategy$C
］~classの~instance, あるいは~customのものにもなり得る。
策が給されなかった場合の既定の挙動は、`限界水位$ 1 の `CountQueuingStrategy$C と同じになる。
◎
The constructor also accepts a second argument containing the queuing strategy object with two properties: a non-negative number highWaterMark, and a function size(chunk). The supplied strategy could be an instance of the built-in CountQueuingStrategy or ByteLengthQueuingStrategy classes, or it could be custom. If no strategy is supplied, the default behavior will be the same as a CountQueuingStrategy with a high water mark of 1.
</p>

</div>


<ol class="algo">
	<li>
~this.[[state]] ~SET `writable^l
◎
Set this.[[state]] to "writable".
</li>
	<li>
~this.[[storedError]] ~SET ~undefined；<br>
~this.[[writer]] ~SET ~undefined；<br>
~this.[[writableStreamController]] ~SET ~undefined；<br>
~this.[[inFlightWriteRequest]] ~SET ~undefined；<br>
~this.[[closeRequest]] ~SET ~undefined；<br>
~this.[[inFlightCloseRequest]] ~SET ~undefined；<br>
~this.[[pendingAbortRequest]] ~SET ~undefined
◎
Set this.[[storedError]], this.[[writer]], this.[[writableStreamController]], this.[[inFlightWriteRequest]], this.[[closeRequest]], this.[[inFlightCloseRequest]] and this.[[pendingAbortRequest]] to undefined.
</li>
	<li>
~this.[[writeRequests]] ~SET 新たな空`~List$
◎
Set this.[[writeRequests]] to a new empty List.
</li>
	<li>
~this.[[backpressure]] ~SET ~false
◎
Set this.[[backpressure]] to false.
</li>
	<li>
%type ~LET
? `GetV$A( %underlyingSink, `type^l )
◎
Let type be ? GetV(underlyingSink, "type").
</li>
	<li>
<p>
~IF
%type ~NEQ ~undefined
⇒
~THROW `RangeError^b
◎
If type is not undefined, throw a RangeError exception.
</p>

<p class="note">
これは、後方互換性を懸念することなく，将来に新たな型を追加できるようにする。
◎
This is to allow us to add new potential types in the future, without backward-compatibility concerns.
</p>
	</li>
	<li>
~this.[[writableStreamController]] ~SET
? `Construct$A( `WritableStreamDefaultController$C, « ~this, %underlyingSink, %size, %highWaterMark » )
◎
Set this.[[writableStreamController]] to ? Construct(WritableStreamDefaultController, « this, underlyingSink, size, highWaterMark »).
</li>
	<li>
? `WritableStreamDefaultControllerStart$A(~this.[[writableStreamController]])
を遂行する
◎
Perform ? WritableStreamDefaultControllerStart(this.[[writableStreamController]]).
</li>
</ol>

			</section>
			<section id="ws-prototype">
<h4 title="Properties of the WritableStream Prototype">4.2.4. `WritableStream^C ~prototypeの各種~prop</h4>



				<section id="ws-locked">
<h5>4.2.4.1. `get locked^ws</h5>

<div class="note">

<p>
`locked^ws 取得子は、
可書~streamが`書込器に~lock$されているかどうかを返す。
◎
The locked getter returns whether or not the writable stream is locked to a writer.
</p>

</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStream$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsWritableStream(this) is false, throw a TypeError exception.
</li>
	<li>
~RET
! `IsWritableStreamLocked$A( ~this )
◎
Return ! IsWritableStreamLocked(this).
</li>
</ol>

				</section>
				<section id="ws-abort">
<h5>4.2.4.2. `abort( reason )^ws</h5>

<div class="note">

<p>
`abort()^c ~methodは、~streamを`中止-$する。
それは、生産器は最早~成功裡に~streamに書込できず，~queue-upされた書込は破棄した上で，即時に~error状態に移行されるべきであることを合図する。
これはまた、`下層~槽$の中止する仕組みも実行することになる。
◎
The abort method aborts the stream, signaling that the producer can no longer successfully write to the stream and it should be immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort mechanism of the underlying sink.
</p>
</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStream$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsWritableStream(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF 
! `IsWritableStreamLocked$A( ~this ) ~EQ ~true
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsWritableStreamLocked(this) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
! `WritableStreamAbort$A( ~this, %reason )
◎
Return ! WritableStreamAbort(this, reason).
</li>
</ol>

				</section>
				<section id="ws-get-writer">
<h5>4.2.4.3. `getWriter()^ws</h5>

<div class="note">

<p>
`getWriter()^ws ~methodは、`書込器$（ `WritableStreamDefaultWriter$C の~instance）を作成して，~streamをこの新たな`書込器に~lock$する。
~streamが~lockされている間は、他の書込器は，この~lockが`解放-$されるまで獲得できない。
◎
The getWriter method creates a writer (an instance of WritableStreamDefaultWriter) and locks the stream to the new writer. While the stream is locked, no other writer can be acquired until this one is released.
</p>

<p>
この機能性は、［
他から遮られたり書込が差挟まれることなく~streamに書込する能を欲するような，抽象化
］を創出するときに，とりわけ有用になる。
~streamに対する書込器を取得することにより，［
他から同時に書込されて，書込した~dataが予測不能になって役に立たなくなる
］ことはないことを確保できる。
◎
This functionality is especially useful for creating abstractions that desire the ability to write to a stream without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at the same time, which would cause the resulting written data to be unpredictable and probably useless.
</p>

</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStream$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsWritableStream(this) is false, throw a TypeError exception.
</li>
	<li>
~RET
? `AcquireWritableStreamDefaultWriter$A( ~this )
◎
Return ? AcquireWritableStreamDefaultWriter(this).
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="ws-abstract-ops">
<h3 title="General Writable Stream Abstract Operations">4.3. 一般の可書~stream抽象~演算</h3>


<p>
以下の抽象~演算は、この仕様の大部分と違って，他の仕様からも 一般に有用になるよう意図されている
— 単に，この仕様の各種~classの実装の一部としてではなく。
◎
The following abstract operations, unlike most in this specification, are meant to be generally useful by other specifications, instead of just being part of the implementation of this spec’s classes.
</p>



			<section id="acquire-writable-stream-default-writer">
<h4 class="throws">4.3.1. `AcquireWritableStreamDefaultWriter ( stream )^A</h4>

<ol class="algo">
	<li>
~RET
? `Construct$A( `WritableStreamDefaultWriter$C, %stream )
◎
Return ? Construct(WritableStreamDefaultWriter, « stream »).
</li>
</ol>

			</section>
			<section id="is-writable-stream">
<h4 class="nothrow">4.3.2. `IsWritableStream ( x )^A</h4>

<ol class="algo">
	<li>
~IF
`Type$A( %x ) ~NEQ `Object^b
⇒
~RET ~false
◎
If Type(x) is not Object, return false.
</li>
	<li>
~IF
%x は [[writableStreamController]] 内部~slotを持たない
⇒
~RET ~false
◎
If x does not have a [[writableStreamController]] internal slot, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="is-writable-stream-locked">
<h4 class="nothrow">4.3.3. `IsWritableStreamLocked ( stream )^A</h4>


<p>
この抽象~演算は、［
可書~streamが`書込器に~lock$されているかどうか
］を照会したいと望むような，他の仕様から~callされる用途に意図されている。
◎
This abstract operation is meant to be called from other specifications that may wish to query whether or not a writable stream is locked to a writer.
</p>

<ol class="algo">
	<li>
~Assert： 
! `IsWritableStream$A( %stream ) ~EQ ~true
◎
Assert: ! IsWritableStream(stream) is true.
</li>
	<li>
~IF
%stream.[[writer]] ~EQ ~undefined
⇒
~RET ~false
◎
If stream.[[writer]] is undefined, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="writable-stream-abort">
<h4 class="nothrow">4.3.4. `WritableStreamAbort ( stream, reason )^A</h4>

<ol class="algo">
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
~IF
%state ~EQ `closed^l
⇒
~RET ~undefined で`解決された~promise$
◎
If state is "closed", return a promise resolved with undefined.
</li>
	<li>
~IF
%state ~EQ `errored^l
⇒
~RET %stream.[[storedError]] で`却下された~promise$
◎
If state is "errored", return a promise rejected with stream.[[storedError]].
</li>
	<li>
~Assert：
%state ~EQ `writable^l
◎
Assert: state is "writable".
</li>
	<li>
%error ~LET 新たな `TypeError^b
— これは、~streamを中止するよう要請されたことを指示する
◎
Let error be a new TypeError indicating that the stream has been requested to abort.
</li>
	<li>
~IF
%stream.[[pendingAbortRequest]] ~NEQ ~undefined
⇒
~RET %error で`却下された~promise$
◎
If stream.[[pendingAbortRequest]] is not undefined, return a promise rejected with error.
</li>
	<li>
%controller ~LET %stream.[[writableStreamController]]
◎
Let controller be stream.[[writableStreamController]].
</li>
	<li>
~Assert：
%controller ~NEQ ~undefined
◎
Assert: controller is not undefined.
</li>
			<li>
%writer ~LET %stream.[[writer]]
◎
Let writer be stream.[[writer]].
</li>
	<li>
<p>
~IF
%writer ~NEQ ~undefined
：
◎
If writer is not undefined,
</p>
		<ol>
			<li>
~IF［
! `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~false
］~AND［
%stream.[[backpressure]] ~EQ ~true
］
⇒
%error で %writer.[[readyPromise]] を`却下する$
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is false and stream.[[backpressure]] is true, reject writer.[[readyPromise]] with error.
</li>
			<li>
~ELSE
⇒
%writer.[[readyPromise]] ~SET %error で`却下された~promise$
◎
Otherwise, set writer.[[readyPromise]] to a promise rejected with error.
</li>
			<li>
%writer.[[readyPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set writer.[[readyPromise]].[[PromiseIsHandled]] to true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
! `WritableStreamHasOperationMarkedInFlight$A( %stream ) ~EQ ~false
］~AND［
%controller.[[started]] ~EQ ~true
］：
◎
If ! WritableStreamHasOperationMarkedInFlight(stream) is false and controller.[[started]] is true,
</p>
		<ol>
			<li>
! `WritableStreamFinishAbort$A( %stream )
を遂行する
◎
Perform ! WritableStreamFinishAbort(stream).
</li>
			<li>
~RET
! `WritableStreamDefaultControllerAbort$A( %controller, %reason )
◎
Return ! WritableStreamDefaultControllerAbort(controller, reason).
</li>
		</ol>
	</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%stream.[[pendingAbortRequest]] ~SET
`~Record$ { [[promise]]: %promise, [[reason]]: %reason }
◎
Set stream.[[pendingAbortRequest]] to Record {[[promise]]: promise, [[reason]]: reason}.
</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>

			</section>
			<section id="writable-stream-finish-abort">
<h4 class="nothrow">4.3.5. `WritableStreamFinishAbort ( stream )^A</h4>

<ol class="algo">
	<li>
%error ~LET 新たな `TypeError^b
— ~streamは中止されたことを指示する
◎
Let error be a new TypeError indicating that the stream has been aborted.
</li>
	<li>
%stream.[[state]] ~SET `errored^l
◎
Set stream.[[state]] to "errored".
</li>
	<li>
%stream.[[storedError]] ~SET %error
◎
Set stream.[[storedError]] to error.
</li>
	<li>
! `WritableStreamRejectPromisesInReactionToError$A( %stream )
を遂行する
◎
Perform ! WritableStreamRejectPromisesInReactionToError(stream).
</li>
</ol>

			</section>
		</section>
		<section id="ws-abstract-ops-used-by-controllers">
<h3 title="Writable Stream Abstract Operations Used by Controllers">4.4. 制御器により利用される可書~stream抽象~演算</h3>


<p>
将来に，挙動が異なる可書~stream（単純な可読~streamと`可読~byte~stream$との間の区別に類似するような）も追加できるような柔軟性を得るため、`可書~stream$の内部~状態の多くの部分は，
`WritableStreamDefaultController$C ~classにより~encapsulateされる。
現時点における ~streamと その制御器との間の仕事の分担は、多少~恣意的に見えるかもしれないが、~logicの多くの部分を制御器~内に集中させることは，将来的に有用な構造になる。
◎
To allow future flexibility to add different writable stream behaviors (similar to the distinction between simple readable streams and readable byte streams), much of the internal state of a writable stream is encapsulated by the WritableStreamDefaultController class. At this point in time the division of work between the stream and its controller may seems somewhat arbitrary, but centralizing much of the logic in the controller is a useful structure for the future.
</p>


<p>
この節における抽象~演算は、結付けられている `WritableStream$C ~objに影響するような，制御器~実装により利用される~interfaceである。
制御器の内部~状態における変化は、 `WritableStream$C の~public~APIを通して可視になるように，開発者が面する結果に翻訳される。
◎
The abstract operations in this section are interfaces that are used by the controller implementation to affect its associated WritableStream object, translating the controller’s internal state changes into developer-facing results visible through the WritableStream's public API.
</p>



			<section id="writable-stream-add-write-request">
<h4 class="nothrow">4.4.1. `WritableStreamAddWriteRequest ( stream )^A</h4>

<ol class="algo">
	<li>
~Assert：
! `IsWritableStreamLocked$A( %stream ) ~EQ ~true
◎
Assert: ! IsWritableStreamLocked(stream) is true.
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `writable^l
◎
Assert: stream.[[state]] is "writable".
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%promise を %stream.[[writeRequests]] の~~末尾に付加する
◎
Append promise as the last element of stream.[[writeRequests]].
</li>
	<li>
~RET %promise 
◎
Return promise.
</li>
</ol>

			</section>
			<section id="writable-stream-finish-in-flight-write">
<h4 class="nothrow">4.4.2. `WritableStreamFinishInFlightWrite ( stream )^A</h4>

<ol class="algo">
	<li>
~Assert：
%stream.[[inFlightWriteRequest]] ~NEQ ~undefined
◎
Assert: stream.[[inFlightWriteRequest]] is not undefined.
</li>
	<li>
~undefined で
%stream.[[inFlightWriteRequest]] を`解決する$
◎
Resolve stream.[[inFlightWriteRequest]] with undefined.
</li>
	<li>
%stream.[[inFlightWriteRequest]] ~SET ~undefined
◎
Set stream.[[inFlightWriteRequest]] to undefined.
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
<p>
~IF
%state ~EQ `errored^l
：
◎
If state is "errored",
</p>
		<ol>
			<li>
! `WritableStreamFinishInFlightWriteInErroredState$A( %stream )
を遂行する
◎
Perform ! WritableStreamFinishInFlightWriteInErroredState(stream).
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~Assert：
%state ~EQ `writable^l
◎
Assert: state is "writable".
</li>
	<li>
! `WritableStreamHandleAbortRequestIfPending$A( %stream )
を遂行する
◎
Perform ! WritableStreamHandleAbortRequestIfPending(stream).
</li>
</ol>

			</section>
			<section id="writable-stream-finish-in-flight-write-in-errored-state">
<h4 class="nothrow">4.4.3. `WritableStreamFinishInFlightWriteInErroredState ( stream )^A</h4>

<ol>
	<li>
! `WritableStreamRejectAbortRequestIfPending$A( %stream )
を遂行する
◎
Perform ! WritableStreamRejectAbortRequestIfPending(stream).
</li>
	<li>
! `WritableStreamRejectPromisesInReactionToError$A( %stream )
を遂行する
◎
Perform ! WritableStreamRejectPromisesInReactionToError(stream).
</li>
</ol>

			</section>
			<section id="writable-stream-finish-in-flight-write-with-error">
<h4 class="nothrow">4.4.4. `WritableStreamFinishInFlightWriteWithError ( stream, reason )^A</h4>

<ol class="algo">
	<li>
~Assert：
%stream.[[inFlightWriteRequest]] ~NEQ ~undefined
◎
Assert: stream.[[inFlightWriteRequest]] is not undefined.
</li>
	<li>
%reason で
%stream.[[inFlightWriteRequest]] を`却下する$
◎
Reject stream.[[inFlightWriteRequest]] with reason.
</li>
	<li>
%stream.[[inFlightWriteRequest]] ~SET ~undefined
◎
Set stream.[[inFlightWriteRequest]] to undefined.
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
<p>
~IF
%state ~EQ `errored^l
：
◎
If state is "errored",
</p>
		<ol>
			<li>
! `WritableStreamFinishInFlightWriteInErroredState$A( %stream )
を遂行する
◎
Perform ! WritableStreamFinishInFlightWriteInErroredState(stream).
</li>
			<li>
~RET 
◎
Return.
</li>
		</ol>
	</li>
	<li>
~Assert：
%state ~EQ `writable^l
◎
Assert: state is "writable".
</li>
	<li>
%stream.[[state]] ~SET `errored^l
◎
Set stream.[[state]] to "errored".
</li>
	<li>
%stream.[[storedError]] ~SET %reason 
◎
Set stream.[[storedError]] to reason.
</li>
	<li>
<p>
~IF
%stream.[[pendingAbortRequest]] ~EQ ~undefined
：
◎
If stream.[[pendingAbortRequest]] is undefined,
</p>
		<ol>
			<li>
%writer ~LET %stream.[[writer]]
◎
Let writer be stream.[[writer]].
</li>
			<li>
<p>
~IF
%writer ~NEQ ~undefined
：
◎
If writer is not undefined,
</p>
				<ol>
					<li>
~IF［
! `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~false
］~AND［
%stream.[[backpressure]] ~EQ ~true
］
⇒
%reason で %writer.[[readyPromise]] を`却下する$
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is false and stream.[[backpressure]] is true, reject writer.[[readyPromise]] with reason.
</li>
					<li>
~ELSE
⇒
%writer.[[readyPromise]] ~SET %reason で`却下された~promise$
◎
Otherwise, set writer.[[readyPromise]] to a promise rejected with reason.
</li>
					<li>
%writer.[[readyPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set writer.[[readyPromise]].[[PromiseIsHandled]] to true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
%reason で
%stream.[[pendingAbortRequest]] を`却下する$
◎
Reject stream.[[pendingAbortRequest]] with reason.
</li>
			<li>
%stream.[[pendingAbortRequest]] ~SET ~undefined
◎
Set stream.[[pendingAbortRequest]] to undefined.
</li>
		</ol>
	</li>
	<li>
! `WritableStreamRejectPromisesInReactionToError$A( %stream )
を遂行する
◎
Perform ! WritableStreamRejectPromisesInReactionToError(stream).
</li>
</ol>

			</section>
			<section id="writable-stream-finish-in-flight-close">
<h4 class="nothrow">4.4.5. `WritableStreamFinishInFlightClose ( stream )^A</h4>

<ol class="algo">
	<li>
~Assert：
%stream.[[inFlightCloseRequest]] ~NEQ ~undefined
◎
Assert: stream.[[inFlightCloseRequest]] is not undefined.
</li>
	<li>
~undefined で
%stream.[[inFlightCloseRequest]] を`解決する$
◎
Resolve stream.[[inFlightCloseRequest]] with undefined.
</li>
	<li>
%stream.[[inFlightCloseRequest]] ~SET ~undefined
◎
Set stream.[[inFlightCloseRequest]] to undefined.
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
<p>
~IF
%state ~EQ `errored^l
：
◎
If state is "errored",
</p>
		<ol>
			<li>
! `WritableStreamFinishInFlightCloseInErroredState$A( %stream )
を遂行する
◎
Perform ! WritableStreamFinishInFlightCloseInErroredState(stream).
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~Assert：
%state ~EQ `writable^l
◎
Assert: state is "writable".
</li>
	<li>
<p>
~IF
%stream.[[pendingAbortRequest]] ~EQ ~undefined
：
◎
If stream.[[pendingAbortRequest]] is undefined,
</p>
		<ol>
			<li>
%stream.[[state]] ~SET `closed^l
◎
Set stream.[[state]] to "closed".
</li>
			<li>
%writer ~LET %stream.[[writer]]
◎
Let writer be stream.[[writer]].
</li>
			<li>
~IF
%writer ~NEQ ~undefined
⇒
~undefined で
%writer.[[closedPromise]] を`解決する$
◎
If writer is not undefined, resolve writer.[[closedPromise]] with undefined.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~undefined で
%stream.[[pendingAbortRequest]] を`解決する$
◎
Resolve stream.[[pendingAbortRequest]] with undefined.
</li>
	<li>
%stream.[[pendingAbortRequest]] ~SET ~undefined
◎
Set stream.[[pendingAbortRequest]] to undefined.
</li>
	<li>
%error ~LET
新たな `TypeError^b
— これは、~streamを中止するよう要請されたが，それはすでに~closeされたことを指示する。
◎
Let error to a new TypeError indicating that the stream was requested to abort but has been closed.
</li>
	<li>
%stream.[[state]] ~SET `errored^l
◎
Set stream.[[state]] to "errored".
</li>
	<li>
%stream.[[storedError]] ~SET %error
◎
Set stream.[[storedError]] to error.
</li>
	<li>
! `WritableStreamRejectClosedPromiseInReactionToError$A( %stream )
を遂行する
◎
Perform ! WritableStreamRejectClosedPromiseInReactionToError(stream).
</li>
</ol>

			</section>
			<section id="writable-stream-finish-in-flight-close-in-errored-state">
<h4 class="nothrow">4.4.6. `WritableStreamFinishInFlightCloseInErroredState ( stream )^A</h4>

<ol class="algo">
	<li>
! `WritableStreamRejectAbortRequestIfPending$A( %stream )
を遂行する
◎
Perform ! WritableStreamRejectAbortRequestIfPending(stream).
</li>
	<li>
! `WritableStreamRejectClosedPromiseInReactionToError$A( %stream )
を遂行する
◎
Perform ! WritableStreamRejectClosedPromiseInReactionToError(stream).
</li>
</ol>
			</section>
			<section id="writable-stream-finish-in-flight-close-with-error">
<h4 class="nothrow">4.4.7. `WritableStreamFinishInFlightCloseWithError ( stream, reason )^A</h4>

<ol class="algo">
	<li>
~Assert：
%stream.[[inFlightCloseRequest]] ~NEQ ~undefined
◎
Assert: stream.[[inFlightCloseRequest]] is not undefined.
</li>
	<li>
%reason で
%stream.[[inFlightCloseRequest]] を`却下する$
◎
Reject stream.[[inFlightCloseRequest]] with reason.
</li>
	<li>
%stream.[[inFlightCloseRequest]] ~SET ~undefined
◎
Set stream.[[inFlightCloseRequest]] to undefined.
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>

	<li>
<p>
~IF
%state ~EQ `errored^l
：
◎
If state is "errored",
</p>
		<ol>
			<li>
! `WritableStreamFinishInFlightCloseInErroredState$A( %stream )
を遂行する
◎
Perform ! WritableStreamFinishInFlightCloseInErroredState(stream).
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~Assert：
%state ~EQ `writable^l
◎
Assert: state is "writable".
</li>
	<li>
%stream.[[state]] ~SET `errored^l
◎
Set stream.[[state]] to "errored".
</li>
	<li>
%stream.[[storedError]] ~SET %reason 
◎
Set stream.[[storedError]] to reason.
</li>
	<li>
<p>
~IF
%stream.[[pendingAbortRequest]] ~EQ ~undefined
：
◎
If stream.[[pendingAbortRequest]] is undefined,
</p>
		<ol>
			<li>
%writer ~LET %stream.[[writer]]
◎
Let writer be stream.[[writer]].
</li>
	<li>
<p>
~IF
%writer ~NEQ ~undefined
：
◎
If writer is not undefined,
</p>
		<ol>
					<li>
%writer.[[readyPromise]] ~SET
%reason で`却下された~promise$
◎
Set writer.[[readyPromise]] to a promise rejected with reason.
</li>
					<li>
%writer.[[readyPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set writer.[[readyPromise]].[[PromiseIsHandled]] to true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
%reason で
%stream.[[pendingAbortRequest]] を`却下する$
◎
Reject stream.[[pendingAbortRequest]] with reason.
</li>
			<li>
%stream.[[pendingAbortRequest]] ~SET ~undefined
◎
Set stream.[[pendingAbortRequest]] to undefined.
</li>
		</ol>
	</li>
	<li>
! `WritableStreamRejectClosedPromiseInReactionToError$A( %stream )
を遂行する
◎
Perform ! WritableStreamRejectClosedPromiseInReactionToError(stream).
</li>
</ol>

			</section>
			<section id="writable-stream-close-queued-or-in-flight">
<h4 class="nothrow">4.4.8.  `WritableStreamCloseQueuedOrInFlight ( stream )^A</h4>

<ol class="algo">
	<li>
~IF［
%stream.[[closeRequest]] ~EQ ~undefined
］~AND［
%stream.[[inFlightCloseRequest]] ~EQ ~undefined
］
⇒
~RET ~false
◎
If stream.[[closeRequest]] is undefined and stream.[[inFlightCloseRequest]] is undefined, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="writable-stream-handle-abort-request-if-pending">
<h4 class="nothrow">4.4.9. `WritableStreamHandleAbortRequestIfPending ( stream )^A</h4>

<ol>
	<li>
~IF
%stream.[[pendingAbortRequest]] ~EQ ~undefined
⇒
~RET
◎
If stream.[[pendingAbortRequest]] is undefined, return.
</li>
			<li>
! `WritableStreamFinishAbort$A( %stream )
を遂行する
◎
Perform ! WritableStreamFinishAbort(stream).
</li>
	<li>
%abortRequest ~LET %stream.[[pendingAbortRequest]]
◎
Let abortRequest be stream.[[pendingAbortRequest]].
</li>
			<li>
%stream.[[pendingAbortRequest]] ~SET ~undefined
◎
Set stream.[[pendingAbortRequest]] to undefined.
</li>
	<li>
%promise ~LET
! `WritableStreamDefaultControllerAbort$A( %stream.[[writableStreamController]], %abortRequest.[[reason]])
◎
Let promise be ! WritableStreamDefaultControllerAbort(stream.[[writableStreamController]], abortRequest.[[reason]]).
</li>
	<li>
値 %result による %promise の`充足~時$には
⇒
%result で
%abortRequest.[[promise]] を`解決する$
◎
Upon fulfillment of promise with value result, resolve abortRequest.[[promise]] with result.
</li>
	<li>
事由 %reason による %promise の`却下~時$には
⇒
%reason で
%abortRequest.[[promise]] を`却下する$
◎
Upon rejection of promise with reason reason, reject abortRequest.[[promise]] with reason.
</li>
</ol>

			</section>
			<section id="writable-stream-has-operation-marked-in-flight">
<h4 class="nothrow">4.4.10. `WritableStreamHasOperationMarkedInFlight ( stream )^A</h4>

<ol class="algo">
	<li>
~IF［
%stream.[[inFlightWriteRequest]] ~EQ ~undefined
］~AND［
%controller.[[inFlightCloseRequest]] ~EQ ~undefined
］
⇒
~RET ~false
◎
If stream.[[inFlightWriteRequest]] is undefined and controller.[[inFlightCloseRequest]] is undefined, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="writable-stream-mark-close-request-in-flight">
<h4 class="nothrow">4.4.11. `WritableStreamMarkCloseRequestInFlight ( stream )^A</h4>

<ol class="algo">
	<li>
~Assert：
%stream.[[inFlightCloseRequest]] ~EQ ~undefined
◎
Assert: stream.[[inFlightCloseRequest]] is undefined.
</li>
	<li>
~Assert：
%stream.[[closeRequest]] ~NEQ ~undefined
◎
Assert: stream.[[closeRequest]] is not undefined.
</li>
	<li>
%stream.[[inFlightCloseRequest]] ~SET %stream.[[closeRequest]]
◎
Set stream.[[inFlightCloseRequest]] to stream.[[closeRequest]].
</li>
	<li>
%stream.[[closeRequest]] ~SET ~undefined
◎
Set stream.[[closeRequest]] to undefined.
</li>
</ol>

			</section>
			<section id="writable-stream-mark-first-write-request-in-flight">
<h4 class="nothrow">4.4.12. `WritableStreamMarkFirstWriteRequestInFlight ( stream )^A</h4>

<ol class="algo">
	<li>
~Assert：
%stream.[[inFlightWriteRequest]] ~EQ ~undefined
◎
Assert: stream.[[inFlightWriteRequest]] is undefined.
</li>
	<li>
~Assert：
%stream.[[writeRequests]] は空でない
◎
Assert: stream.[[writeRequests]] is not empty.
</li>
	<li>
%writeRequest ~LET %stream.[[writeRequests]] の最初の要素
◎
Let writeRequest be the first element of stream.[[writeRequests]].
</li>
	<li>
%stream.[[writeRequests]] から %writeRequest を除去する
— 後続の要素たちは~~先頭へ一つずらす
◎
Remove writeRequest from stream.[[writeRequests]], shifting all other elements downward (so that the second becomes the first, and so on).
</li>
	<li>
%stream.[[inFlightWriteRequest]] ~SET %writeRequest 
◎
Set stream.[[inFlightWriteRequest]] to writeRequest.
</li>
</ol>


			</section>
			<section id="writable-stream-reject-closed-promise-in-reaction-to-error">
<h4 class="nothrow">4.4.13. `WritableStreamRejectClosedPromiseInReactionToError ( stream )^A</h4>

<ol class="algo">
	<li>
%writer ~LET %stream.[[writer]]
◎
Let writer be stream.[[writer]].
</li>
	<li>
<p>
~IF
%writer ~NEQ ~undefined
：
◎
If writer is not undefined,
</p>
		<ol>
			<li>
%stream.[[storedError]] で
%writer.[[closedPromise]] を`却下する$
◎
Reject writer.[[closedPromise]] with stream.[[storedError]].
</li>
			<li>
%writer.[[closedPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set writer.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
		</ol>
	</li>
</ol>


			</section>
			<section id="writable-stream-reject-abort-request-if-pending">
<h4 class="nothrow">4.4.14. `WritableStreamRejectAbortRequestIfPending ( stream )^A</h4>


<ol class="algo">
	<li>
<p>
~IF
%stream.[[pendingAbortRequest]] ~NEQ ~undefined
：
◎
If stream.[[pendingAbortRequest]] is not undefined,
</p>
		<ol>
			<li>
%stream.[[storedError]] で
%stream.[[pendingAbortRequest]] を`却下する$
◎
Reject stream.[[pendingAbortRequest]] with stream.[[storedError]].
</li>
			<li>
%stream.[[pendingAbortRequest]] ~SET ~undefined
◎
Set stream.[[pendingAbortRequest]] to undefined.
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="writable-stream-reject-promises-in-reaction-to-error">
<h4 class="nothrow">4.4.15. `WritableStreamRejectPromisesInReactionToError ( stream )^A</h4>

<ol class="algo">
	<li>
%storedError ~LET %stream.[[storedError]]
◎
Let storedError be stream.[[storedError]].
</li>
	<li>
<p>
%stream.[[writeRequests]] 内の~EACH ( %writeRequest ) に対し：
◎
Repeat for each writeRequest that is an element of stream.[[writeRequests]],
</p>
		<ol>
			<li>
%storedError で %writeRequest を`却下する$
◎
Reject writeRequest with storedError.
</li>
		</ol>
	</li>
	<li>
%stream.[[writeRequests]] ~SET 空`~List$
◎
Set stream.[[writeRequests]] to an empty List.
</li>
	<li>
<p>
~IF
%stream.[[pendingCloseRequest]] ~NEQ ~undefined
◎
If stream.[[closeRequest]] is not undefined,
</p>
		<ol>
			<li>
~Assert：
%stream.[[inFlightCloseRequest]] ~EQ ~undefined
◎
Assert: stream.[[inFlightCloseRequest]] is undefined.
</li>
			<li>
%storedError で %stream.[[closeRequest]] を`却下する$
◎
Reject stream.[[closeRequest]] with storedError.
</li>
			<li>
%stream.[[closeRequest]] ~SET ~undefined
◎
Set stream.[[closeRequest]] to undefined.
</li>
		</ol>
	</li>
	<li>
! `WritableStreamRejectClosedPromiseInReactionToError$A( %stream )
を遂行する
◎
Perform ! WritableStreamRejectClosedPromiseInReactionToError(stream).
</li>
</ol>

			</section>
			<section id="writable-stream-update-backpressure">
<h4 class="nothrow">4.4.16. `WritableStreamUpdateBackpressure ( stream, backpressure )^A</h4>

<ol class="algo">
	<li>
~Assert：
%stream.[[state]] ~EQ `writable^l
◎
Assert: stream.[[state]] is "writable".
</li>
	<li>
~Assert：
`WritableStreamCloseQueuedOrInFlight$A( %backpressure ) ~EQ ~false
◎
Assert: WritableStreamCloseQueuedOrInFlight(stream) is false.
</li>
	<li>
%writer ~LET %stream.[[writer]]
◎
Let writer be stream.[[writer]].
</li>
	<li>
<p>
~IF［
%writer ~NEQ ~undefined
］~AND［
%backpressure ~NEQ %stream.[[backpressure]]
］：
◎
If writer is not undefined and backpressure is not stream.[[backpressure]],
</p>
		<ol>
			<li>
~IF
%backpressure ~EQ ~true
⇒
%writer.[[readyPromise]] ~SET `新たな~promise$
◎
If backpressure is true, set writer.[[readyPromise]] to a new promise.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise,
</p>
				<ol>
					<li>
~Assert：
%backpressure ~EQ ~false
◎
Assert: backpressure is false.
</li>
					<li>
~undefined で
%writer.[[readyPromise]] を`解決する$
◎
Resolve writer.[[readyPromise]] with undefined.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%stream.[[backpressure]] ~SET %backpressure
◎
Set stream.[[backpressure]] to backpressure.
</li>
</ol>

			</section>
		</section>
		<section id="default-writer-class">
<h3 title="Class WritableStreamDefaultWriter">4.5. `WritableStreamDefaultWriter^C ~class</h3>


<p>
`WritableStreamDefaultWriter$C ~classは、［
`WritableStream$C ~instanceから供給0されるように設計された`可書~stream書込器$
］を表現する。
◎
The WritableStreamDefaultWriter class represents a writable stream writer designed to be vended by a WritableStream instance.
</p>


			<section id="default-writer-class-definition">
<h4 title="Class Definition">4.5.1. ~class定義</h4>


~INFORMATIVE


<p>
`WritableStreamDefaultWriter$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば，次のようになる：
◎
If one were to write the WritableStreamDefaultWriter class in something close to the syntax of [ECMASCRIPT], it would look like
</p>


<pre class="lang-javascript">
class WritableStreamDefaultWriter {
  constructor(%stream)

  get closed()
  get desiredSize()
  get ready()

  abort(%reason)
  close()
  releaseLock()
  write(%chunk)
}
</pre>



			</section>
			<section id="default-writer-internal-slots">
<h4 title="Internal Slots">4.5.2. 各種 内部~slot</h4>


<p>
`WritableStreamDefaultWriter$C の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of WritableStreamDefaultWriter are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th title="Internal Slot">内部~slot
<th title="Description(non-normative)">説明0（<em>参考</em>）
</thead>

<tbody>

<tr><td>[[closedPromise]]
<td>
書込器の `closed()$dw 取得子から返される~promise
◎
A promise returned by the writer’s closed getter


<tr><td>[[ownerWritableStream]]
<td>
この書込器を所有する `WritableStream$C の~instance
◎
A WritableStream instance that owns this writer


<tr><td>[[readyPromise]]
<td>
書込器の `ready$dw 取得子から返される~promise
◎
A promise returned by the writer’s ready getter
</tbody></table>



			</section>
			<section id="default-writer-constructor">
<h4 title="new WritableStreamDefaultWriter(stream)">4.5.3. `new WritableStreamDefaultWriter( stream )^dw</h4>

<div class="note">

<p>
`WritableStreamDefaultWriter()^dw 構築子は、一般に，直接的な利用は意図されていない
— 代わりに，~streamの `getWriter()$ws ~methodが利用されるべきである。
◎
The WritableStreamDefaultWriter constructor is generally not meant to be used directly; instead, a stream’s getWriter() method should be used.
</p>
</div>


<ol class="algo">
	<li>
~IF 
! `IsWritableStream$A( %stream ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsWritableStream(stream) is false, throw a TypeError exception.
</li>
	<li>
~IF 
! `IsWritableStreamLocked$A( %stream ) ~EQ ~true
⇒
~THROW `TypeError^b
◎
If ! IsWritableStreamLocked(stream) is true, throw a TypeError exception.
</li>
	<li>
~this.[[ownerWritableStream]] ~SET %stream 
◎
Set this.[[ownerWritableStream]] to stream.
</li>
	<li>
%stream.[[writer]] ~SET ~this
◎
Set stream.[[writer]] to this.
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
<p>
~IF
%state ~EQ `writable^l
：
◎
If state is "writable",
</p>
		<ol>
			<li>
<p>
~IF
%stream.[[pendingAbortRequest]] ~NEQ ~undefined
：
◎
If stream.[[pendingAbortRequest]] is not undefined,
</p>
				<ol>
					<li>
%error ~LET 新たな `TypeError^b
— これは、~streamを中止するよう要請されたことを指示する
◎
Let error be a new TypeError indicating that the stream has been requested to abort.
</li>
					<li>
~this.[[readyPromise]] ~SET
%error で`却下された~promise$
◎
Set this.[[readyPromise]] to a promise rejected with error.
</li>
					<li>
~this.[[readyPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set this.[[readyPromise]].[[PromiseIsHandled]] to true.
</li>
				</ol>
			</li>
			<li>
~ELIF［
! `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~false
］~AND［
%stream.[[backpressure]] ~EQ ~true
］
⇒
~this.[[readyPromise]] ~SET `新たな~promise$
◎
Otherwise, if ! WritableStreamCloseQueuedOrInFlight(stream) is false and stream.[[backpressure]] is true, set this.[[readyPromise]] to a new promise.
</li>
			<li>
~ELSE
⇒
~this.[[readyPromise]] ~SET
~undefined で`解決された~promise$
◎
Otherwise, set this.[[readyPromise]] to a promise resolved with undefined.
</li>
			<li>
~this.[[closedPromise]] ~SET `新たな~promise$
◎
Set this.[[closedPromise]] to a new promise.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF
%state ~EQ `closed^l
：
◎
Otherwise, if state is "closed",
</p>
		<ol>
			<li>
~this.[[readyPromise]] ~SET
~undefined で`解決された~promise$
◎
Set this.[[readyPromise]] to a promise resolved with undefined.
</li>
			<li>
~this.[[closedPromise]] ~SET
~undefined で`解決された~promise$
◎
Set this.[[closedPromise]] to a promise resolved with undefined.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise,
</p>
		<ol>
			<li>
~Assert：
%state ~EQ `errored^l
◎
Assert: state is "errored".
</li>
			<li>
%storedError ~LET %stream.[[storedError]]
◎
Let storedError be stream.[[storedError]].
</li>
			<li>
~this.[[readyPromise]] ~SET
%storedError で`却下された~promise$
◎
Set this.[[readyPromise]] to a promise rejected with storedError.
</li>
			<li>
~this.[[readyPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set this.[[readyPromise]].[[PromiseIsHandled]] to true.
</li>
			<li>
~this.[[closedPromise]] ~SET
%storedError で`却下された~promise$
◎
Set this.[[closedPromise]] to a promise rejected with storedError.
</li>
			<li>
~this.[[closedPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set this.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="default-writer-prototype">
<h4 title="Properties of the WritableStreamDefaultWriter Prototype">4.5.4. `WritableStreamDefaultWriter^C ~prototypeの各種~prop</h4>



				<section id="default-writer-closed">
<h5 title="get closed">4.5.4.1. `get closed^dw</h5>

<div class="note">

<p>
`closed^c 取得子は、~promiseを返す。
それは、~streamが~closeされたときは充足され，［
どこかで~errorした ／
~streamが~closeし終える前に書込器の~lockが`解放-$された
］ときは却下される。
◎
The closed getter returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or the writer’s lock is released before the stream finishes closing.
</p>

</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStreamDefaultWriter$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsWritableStreamDefaultWriter(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET ~this.[[closedPromise]]
◎
Return this.[[closedPromise]].
</li>
</ol>

				</section>
				<section id="default-writer-desiredSize">
<h5 title="get desiredSize">4.5.4.2. `get desiredSize^dw</h5>

<div class="note">

<p>
`desiredSize^c 取得子は、`~streamの内部~queueの残り~size$を返す。
~queueを溢れている場合の結果は、負になる。
`生産器$は、この情報を利用して，書込する~~適正な~data量を決定するべきである。
◎
The desiredSize getter returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full. A producer should use this information to determine the right amount of data to write.
</p>

<p>
~streamが~error状態にある場合、 `null^b になる。
~streamが~close状態にある場合、~zeroになる。
この取得子が，書込器の~lockが`解放-$されている間に呼出された場合、例外を投出する。
◎
It will be null if the stream is errored, or zero if the stream is closed. The getter will throw an exception if invoked when the writer’s lock is released.
</p>
</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStreamDefaultWriter$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsWritableStreamDefaultWriter(this) is false, throw a TypeError exception.
</li>
	<li>
~IF
~this.[[ownerWritableStream]] ~EQ ~undefined
⇒
~THROW `TypeError^b
◎
If this.[[ownerWritableStream]] is undefined, throw a TypeError exception.
</li>
	<li>
~RET
! `WritableStreamDefaultWriterGetDesiredSize$A( ~this )
◎
Return ! WritableStreamDefaultWriterGetDesiredSize(this).
</li>
</ol>

				</section>
				<section id="default-writer-ready">
<h5 title="get ready">4.5.4.3. `get ready^dw</h5>

<div class="note">

<p>
`ready^dw 取得子は、`~streamの内部~queueの残り~size$が~zero以下から正へ遷移したとき
— それは，`背圧$は適用されないことを合図する —
に充足されることになる，~promiseを返す。
`~streamの内部~queueの残り~size$が また~zero以下に落ち込んだときには、取得子は，［
次0の遷移まで処理待ちであり続ける，`新たな~promise$
］を返すことになる。
◎
The ready getter returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions from nonpositive to positive, signaling that it is no longer applying backpressure. Once the desired size to fill the stream’s internal queue dips back to zero or below, the getter will return a new promise that stays pending until the next transition.
</p>


<p>
~streamが~errorになった, または
書込器の~lockが`解放-$された場合、返された~promiseは，却下されることになる。
◎
If the stream becomes errored, or the writer’s lock is released, is the returned promise will become rejected.
</p>
</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStreamDefaultWriter$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsWritableStreamDefaultWriter(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET ~this.[[readyPromise]]
◎
Return this.[[readyPromise]].
</li>
</ol>

				</section>
				<section id="default-writer-abort">
<h5 title="abort(reason)">4.5.4.4. `abort( reason )^dw</h5>

<div class="note">

<p>
書込器が`作動中$にある場合、 `abort()^c ~methodは、結付けられている~streamに対するそれと同じに挙動する（他の場合，それは却下された~promiseを返す。）
◎
If the writer is active, the abort method behaves the same as that for the associated stream. (Otherwise, it returns a rejected promise.)
</p>
</div>

<ol class="algo">
	<li>
~IF
! `IsWritableStreamDefaultWriter$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsWritableStreamDefaultWriter(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
~this.[[ownerWritableStream]] ~EQ ~undefined
⇒
~RET `TypeError^b で`却下された~promise$
◎
If this.[[ownerWritableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
! `WritableStreamDefaultWriterAbort$A( ~this, %reason )
◎
Return ! WritableStreamDefaultWriterAbort(this, reason).
</li>
</ol>

				</section>
				<section id="default-writer-close">
<h5 title="close()">4.5.4.5. `close()^dw</h5>

<div class="note">

<p>
`close()^dw ~methodは、結付けられている可書~streamを~closeする。
`下層~槽$は、自身の~close挙動を呼出す前に，以前に書込された`~chunk$を処理し終えることになる。
その間，更に書込しようとする試みは、失敗することになる（~streamを~errorにすることなく）。
◎
The close method will close the associated writable stream. The underlying sink will finish processing any previously-written chunks, before invoking its close behavior. During this time any further attempts to write will fail (without erroring the stream).
</p>

<p>
この~methodは、~promiseを返す
— それは、残りの`~chunk$すべてが成功裡に書込され，~stream成功裡に~closeしたなら，~undefined で充足される。
この処理の間に~errorに遭遇した場合は却下される。
（これは `closed$dw から返されるものと同じ~promiseになる。）
◎
The method returns a promise that is fulfilled with undefined if all remaining chunks are successfully written and the stream successfully closes, or rejects if an error is encountered during this process. (This is the same promise as is returned by closed.)
</p>

</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStreamDefaultWriter$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsWritableStreamDefaultWriter(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
%stream ~LET ~this.[[ownerWritableStream]]
◎
Let stream be this.[[ownerWritableStream]].
</li>
	<li>
~IF
%stream ~EQ ~undefined
⇒
~RET `TypeError^b で`却下された~promise$
◎
If stream is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
! `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~true
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
! `WritableStreamDefaultWriterClose$A( ~this )
◎
Return ! WritableStreamDefaultWriterClose(this).
</li>
</ol>

				</section>
				<section id="default-writer-release-lock">
<h5 title="releaseLock()">4.5.4.6. `releaseLock()^dw</h5>

<div class="note">

<p>
`releaseLock()^dw ~methodは、書込器による対応する~stream上の~lockを`解放-$する。
~lockが解放されて以降は、当の書込器は，最早 `作動中$でなくなる。
~lockが解放される時点で，結付けられている~streamが~error状態にある場合、それ以降も，書込器はそれを引き継ぐように~errorしたように現れる。
他の場合、書込器は~closeされたように現れる。
◎
The releaseLock method releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active. If the associated stream is errored when the lock is released, the writer will appear errored in the same way from now on; otherwise, the writer will appear closed.
</p>

<p>
まだ終えてない進行中の書込があるときでも（すなわち、前回の `write()$dw ~callから返された~promiseが決着していなくとも）、~lockは解放できることに注意。
書込~中に書込器に対する~lockを保持することは要求されない
— ~lockは、単純に，他の生産器が差挟むような方式で書込するのを防止するためにある。
◎
Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the promises returned from previous calls to write() have not yet settled). It’s not required to hold the lock on the writer for the duration of the write; the lock instead simply prevents other producers from writing in an interleaved manner.
</p>
</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStreamDefaultWriter$A( ~this ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsWritableStreamDefaultWriter(this) is false, throw a TypeError exception.
</li>
	<li>
%stream ~LET ~this.[[ownerWritableStream]]
◎
Let stream be this.[[ownerWritableStream]].
</li>
	<li>
~IF
%stream ~EQ ~undefined
⇒
~RET
◎
If stream is undefined, return.
</li>
	<li>
~Assert：
%stream.[[writer]] ~NEQ ~undefined
◎
Assert: stream.[[writer]] is not undefined.
</li>
	<li>
! `WritableStreamDefaultWriterRelease$A( ~this )
を遂行する
◎
Perform ! WritableStreamDefaultWriterRelease(this).
</li>
</ol>

				</section>
				<section id="default-writer-write">
<h5 title="write(chunk)">4.5.4.7. `write( chunk )^dw</h5>

<div class="note">

<p>
`write()^dw ~methodは、所与の`~chunk$を可書~streamに書込する
— 以前の書込があれば それが成功裡に終わるまで待機した上で，`下層~槽$に`~chunk$を送信することにより。
この~methodは、~promiseを返す。
~promiseは、書込が成功したときは ~undefined で充足され、書込に失敗したとき, または書込み処理が起動される前に~streamが~errorした場合は，却下される。
◎
The write method writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully, and then sending the chunk to the underlying sink. It will return a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes errored before the writing process is initiated.
</p>

<p>
注記：
“成功” が 何を意味するかは，`下層~槽$に委ねられる。
それは、単純に`~chunk$が受容されたことを指示するだけかもしれない
— それが最終~行先に安全に保存されることは，必要とされない。
◎
Note that what "success" means is up to the underlying sink; it may indicate simply that the chunk has been accepted, and not necessarily that it is safely saved to its ultimate destination.
</p>
</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStreamDefaultWriter$A( ~this ) ~EQ ~false
⇒
~RET `TypeError^b で`却下された~promise$
◎
If ! IsWritableStreamDefaultWriter(this) is false, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
~this.[[ownerWritableStream]] ~EQ ~undefined
⇒
~RET `TypeError^b で`却下された~promise$
◎
If this.[[ownerWritableStream]] is undefined, return a promise rejected with a TypeError exception.
</li>
	<li>
~RET
! `WritableStreamDefaultWriterWrite$A( ~this, %chunk )
◎
Return ! WritableStreamDefaultWriterWrite(this, chunk).
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="rs-writer-abstract-ops">
<h3 title="Writable Stream Writer Abstract Operations">4.6. 可書~stream書込器の抽象~演算</h3>



			<section id="is-writable-stream-default-writer">
<h4 class="nothrow">4.6.1. `IsWritableStreamDefaultWriter ( x )^A</h4>

<ol class="algo">
	<li>
~IF
`Type$A( %x ) ~NEQ `Object^b
⇒
~RET ~false
◎
If Type(x) is not Object, return false.
</li>
	<li>
~IF
%x は [[ownerWritableStream]] 内部~slotを持たない
⇒
~RET ~false
◎
If x does not have an [[ownerWritableStream]] internal slot, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="writable-stream-default-writer-abort">
<h4 class="nothrow">4.6.2. `WritableStreamDefaultWriterAbort ( writer, reason )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %writer.[[ownerWritableStream]]
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ ~undefined
◎
Assert: stream is not undefined.
</li>
	<li>
~RET
! `WritableStreamAbort$A( %stream, %reason )
◎
Return ! WritableStreamAbort(stream, reason).
</li>
</ol>

			</section>
			<section id="writable-stream-default-writer-close">
<h4 class="nothrow">4.6.3. `WritableStreamDefaultWriterClose ( writer )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %writer.[[ownerWritableStream]]
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ ~undefined
◎
Assert: stream is not undefined.
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
~IF
%state ~IN { `closed^l, `errored^l }
⇒
~RET `TypeError^b で`却下された~promise$
◎
If state is "closed" or "errored", return a promise rejected with a TypeError exception.
</li>
	<li>
~IF［
%stream.[[pendingAbortRequest]] ~NEQ ~undefined
］
⇒
~RET `TypeError^b で`却下された~promise$
— これは、~streamを中止するよう要請されたことを指示する。
◎
If stream.[[pendingAbortRequest]] is not undefined, return a promise rejected with a TypeError indicating that the stream has been requested to abort.
</li>
	<li>
~Assert：
%state ~EQ `writable^l
◎
Assert: state is "writable".
</li>
	<li>
~Assert：
! `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~false
◎
Assert: ! WritableStreamCloseQueuedOrInFlight(stream) is false.
</li>
	<li>
%promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%stream.[[closeRequest]] ~SET %promise
◎
Set stream.[[closeRequest]] to promise.
</li>
	<li>
~IF 
%stream.[[backpressure]] ~EQ ~true
⇒
~undefined で
%writer.[[readyPromise]] を`解決する$
◎
If stream.[[backpressure]] is true, resolve writer.[[readyPromise]] with undefined.
</li>
	<li>
! `WritableStreamDefaultControllerClose$A( %stream.[[writableStreamController]] )
を遂行する
◎
Perform ! WritableStreamDefaultControllerClose(stream.[[writableStreamController]]).
</li>
	<li>
~RET %promise 
◎
Return promise.
</li>
</ol>

			</section>
			<section id="writable-stream-default-writer-close-with-error-propagation">
<h4 class="nothrow">4.6.4. `WritableStreamDefaultWriterCloseWithErrorPropagation ( writer )^A</h4>

<p class="note">注記：
この抽象~演算は、 `pipeTo()$rs における~error伝播の意味論を実装し易くするためにある。
◎
This abstract operation helps implement the error propagation semantics of pipeTo().
</p>

<ol class="algo">
	<li>
%stream ~LET %writer.[[ownerWritableStream]]
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ ~undefined
◎
Assert: stream is not undefined.
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
! `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~true
］~OR［
%state ~EQ `closed^l
］
⇒
~RET ~undefined で`解決された~promise$
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is true or state is "closed", return a promise resolved with undefined.
</li>
	<li>
~IF［
%state ~EQ `errored^l
］
⇒
~RET %stream.[[storedError]] で`却下された~promise$
◎
If state is "errored", return a promise rejected with stream.[[storedError]].
</li>
	<li>
~Assert：
%state ~EQ `writable^l
◎
Assert: state is "writable".
</li>
	<li>
~RET
! `WritableStreamDefaultWriterClose$A( %writer )
◎
Return ! WritableStreamDefaultWriterClose(writer).
</li>
</ol>

			</section>
			<section id="writable-stream-default-writer-get-desired-size">
<h4 class="nothrow">4.6.5. `WritableStreamDefaultWriterGetDesiredSize ( writer )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %writer.[[ownerWritableStream]]
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
%state ~EQ `errored^l
］~OR［
%stream.[[pendingAbortRequest]] ~NEQ ~undefined
］
⇒
~RET `null^b
◎
If state is "errored" or stream.[[pendingAbortRequest]] is not undefined, return null.
</li>
	<li>
~IF %state ~EQ `closed^l
⇒
~RET `0^b
◎
If state is "closed", return 0.
</li>
	<li>
~RET
! `WritableStreamDefaultControllerGetDesiredSize$A( %stream.[[writableStreamController]] )
◎
Return ! WritableStreamDefaultControllerGetDesiredSize(stream.[[writableStreamController]]).
</li>
</ol>

			</section>
			<section id="writable-stream-default-writer-release">
<h4 class="nothrow">4.6.6. `WritableStreamDefaultWriterRelease ( writer )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %writer.[[ownerWritableStream]]
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ ~undefined
◎
Assert: stream is not undefined.
</li>
	<li>
~Assert:
%stream.[[writer]] ~EQ %writer
◎
Assert: stream.[[writer]] is writer.
</li>
	<li>
%releasedError ~LET 新たな `TypeError^b
◎
Let releasedError be a new TypeError.
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
%state ~EQ `writable^l
］~AND［
! `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~false
］~AND［
%stream.[[pendingAbortRequest]] ~EQ ~undefined
］~AND［
%stream.[[backpressure]] ~EQ ~true
］
⇒
%releasedError で
%writer.[[readyPromise]] を`却下する$
◎
If state is "writable" and ! WritableStreamCloseQueuedOrInFlight(stream) is false and stream.[[pendingAbortRequest]] is undefined and stream.[[backpressure]] is true, reject writer.[[readyPromise]] with releasedError.
</li>
	<li>
~ELSE
⇒
%writer.[[readyPromise]] ~SET %releasedError で`却下された~promise$
◎
Otherwise, set writer.[[readyPromise]] to a promise rejected with releasedError.
</li>
	<li>
%writer.[[readyPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set writer.[[readyPromise]].[[PromiseIsHandled]] to true.
</li>
	<li>
~IF［
%state ~EQ `writable^l
］~OR［
! `WritableStreamHasOperationMarkedInFlight$A( %stream ) ~EQ ~true
］
⇒
%releasedError で
%writer.[[closedPromise]] を`却下する$
◎
If state is "writable" or ! WritableStreamHasOperationMarkedInFlight(stream) is true, reject writer.[[closedPromise]] with releasedError.
</li>
	<li>
~ELSE
⇒
%writer.[[closedPromise]] ~SET %releasedError で`却下された~promise$
◎
Otherwise, set writer.[[closedPromise]] to a promise rejected with releasedError.
</li>
	<li>
%writer.[[closedPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set writer.[[closedPromise]].[[PromiseIsHandled]] to true.
</li>
	<li>
%stream.[[writer]] ~SET ~undefined
◎
Set stream.[[writer]] to undefined.
</li>
	<li>
%writer.[[ownerWritableStream]] ~SET ~undefined
◎
Set writer.[[ownerWritableStream]] to undefined.
</li>
</ol>

			</section>
			<section id="writable-stream-default-writer-write">
<h4 class="nothrow">4.6.7. `WritableStreamDefaultWriterWrite ( writer, chunk )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %writer.[[ownerWritableStream]]
◎
Let stream be writer.[[ownerWritableStream]].
</li>
	<li>
~Assert：
%stream ~NEQ ~undefined
◎
Assert: stream is not undefined.
</li>
	<li>
%controller ~LET %stream.[[writableStreamController]]
◎
Let controller be stream.[[writableStreamController]].
</li>
	<li>
%chunkSize ~LET
! `WritableStreamDefaultControllerGetChunkSize$A(%controller, %chunk)
◎
Let chunkSize be ! WritableStreamDefaultControllerGetChunkSize(controller, chunk).
</li>
	<li>
~IF %stream ~NEQ %writer.[[ownerWritableStream]]
⇒
~RET `TypeError^b で`却下された~promise$
◎
If stream is not equal to writer.[[ownerWritableStream]], return a promise rejected with a TypeError exception.
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
~IF［
%state ~NEQ `writable^l
］~OR［
! `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~true
］
⇒
~RET `TypeError^b で`却下された~promise$
◎
If state is not "writable" or ! WritableStreamCloseQueuedOrInFlight(stream) is true, return a promise rejected with a TypeError exception.
</li>
	<li>
~IF
%stream.[[pendingAbortRequest]] ~NEQ ~undefined
⇒
~RET `TypeError^b で`却下された~promise$
— これは、~streamを中止するよう要請されたことを指示する。
◎
If stream.[[pendingAbortRequest]] is not undefined, return a promise rejected with a TypeError indicating that the stream has been requested to abort.
</li>
	<li>
%promise ~LET
! `WritableStreamAddWriteRequest$A( %stream )
◎
Let promise be ! WritableStreamAddWriteRequest(stream).
</li>
	<li>
! `WritableStreamDefaultControllerWrite$A( %controller, %chunk, %chunkSize )
を遂行する
◎
Perform ! WritableStreamDefaultControllerWrite(controller, chunk, chunkSize).
</li>
	<li>
~RET %promise 
◎
Return promise.
</li>
</ol>

			</section>
		</section>
		<section id="ws-default-controller-class">
<h3 title="Class WritableStreamDefaultController">4.7. `WritableStreamDefaultController^C ~class</h3>


<p>
`WritableStreamDefaultController$C ~classは、
`WritableStream$C の状態を制御~可能にする，各種~methodを持つ。
`WritableStream$C の構築-時には、`下層~槽$には，操作するための対応する `WritableStreamDefaultController$C の~instanceが与えられる。
◎
The WritableStreamDefaultController class has methods that allow control of a WritableStream's state. When constructing a WritableStream, the underlying sink is given a corresponding WritableStreamDefaultController instance to manipulate.
</p>



			<section id="ws-default-controller-class-definition">
<h4 title="Class Definition">4.7.1. ~class定義</h4>


~INFORMATIVE


<p>
`WritableStreamDefaultController$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば，次のようになる：
◎
If one were to write the WritableStreamDefaultController class in something close to the syntax of [ECMASCRIPT], it would look like
</p>


<pre class="lang-javascript">
class WritableStreamDefaultController {
  constructor( %stream, %underlyingSink, %size, %highWaterMark )

  error(e)
}
</pre>



			</section>
			<section id="ws-default-controller-internal-slots">
<h4 title="Internal Slots">4.7.2. 各種 内部~slot</h4>


<p>
`WritableStreamDefaultController$C の各~instanceは、次の一覧に述べる各種 内部~slotを伴って作成される：
◎
Instances of WritableStreamDefaultController are created with the internal slots described in the following table:
</p>

<table class="slot-def">
<thead><tr><th title="Internal Slot">内部~slot
<th title="Description(non-normative)">説明0（<em>参考</em>）
</thead>

<tbody>

<tr><td>[[controlledWritableStream]]
<td>
制御される `WritableStream$C の~instance
◎
The WritableStream instance controlled

<tr><td>[[queue]]
<td>
~streamの［
`~chunk$たちからなる内部~queue
］を表現する`~List$ 。
◎
A List representing the stream’s internal queue of chunks


<tr><td>[[queueTotalSize]]
<td>
[[queue]] 内に格納されている すべての~chunkの合計~size（`個別~size付き~queue演算 節$を見よ）
◎
The total size of all the chunks stored in [[queue]] (see §6.3 Queue-with-Sizes Operations)


<tr><td>[[started]]
<td>
真偽~flag
— `下層~槽$が開始し終えた【 start() を終えた】かどうかを指示する。
◎
A boolean flag indicating whether the underlying sink has finished starting


<tr><td>[[strategyHWM]]
<td>
~streamの`~queuing策$の一部として，構築子に給された数
— ~streamがその`下層~槽$に`背圧$を適用することになる~~基準を指示する。
◎
A number supplied to the constructor as part of the stream’s queuing strategy, indicating the point at which the stream will apply backpressure to its underlying sink


<tr><td>[[strategySize]]
<td>
~streamの`~queuing策$の一部として，構築子に給された
~enqueueされた`~chunk$の~sizeを計算するために設計された関数
;
既定の挙動に対しては ~undefined もとり得る。
◎
A function supplied to the constructor as part of the stream’s queuing strategy, designed to calculate the size of enqueued chunks; can be undefined for the default behavior


<tr><td>[[underlyingSink]]
<td>
~streamの`下層~槽$の，~obj表現。
`IsWritableStreamDefaultController$A による~brand-checkにも利用される。
◎
An object representation of the stream’s underlying sink; also used for the IsWritableStreamDefaultController brand check

</tbody></table>



			</section>
			<section id="ws-default-controller-constructor">
<h4>4.7.3. new `WritableStreamDefaultController( stream, underlyingSink, size, highWaterMark )^dw</h4>

<div class="note">

<p>
`WritableStreamDefaultController^c
構築子は，直接的には利用できない
— それは、構築されつつある `WritableStream$C 上でのみ働く。
◎
The WritableStreamDefaultController constructor cannot be used directly; it only works on a WritableStream that is in the middle of being constructed.
</p>
</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStream$A( %stream ) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsWritableStream(stream) is false, throw a TypeError exception.
</li>
	<li>
~IF
%stream.[[writableStreamController]] ~NEQ ~undefined
⇒
~THROW `TypeError^b
◎
If stream.[[writableStreamController]] is not undefined, throw a TypeError exception.
</li>
	<li>
~this.[[controlledWritableStream]] ~SET %stream 
◎
Set this.[[controlledWritableStream]] to stream.
</li>
	<li>
~this.[[underlyingSink]] ~SET %underlyingSink 
◎
Set this.[[underlyingSink]] to underlyingSink.
</li>
	<li>
! `ResetQueue$A( ~this )
を遂行する
◎
Perform ! ResetQueue(this).
</li>
	<li>
~this.[[started]] ~SET ~false
◎
Set this.[[started]] to false.
</li>
	<li>
%normalizedStrategy ~LET
? `ValidateAndNormalizeQueuingStrategy$A( %size, %highWaterMark )
◎
Let normalizedStrategy be ? ValidateAndNormalizeQueuingStrategy(size, highWaterMark).
</li>
	<li>
~this.[[strategySize]] ~SET %normalizedStrategy.[[size]]；<br>
~this.[[strategyHWM]] ~SET %normalizedStrategy.[[highWaterMark]]
◎
Set this.[[strategySize]] to normalizedStrategy.[[size]] and this.[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
</li>
	<li>
%backpressure ~LET
! `WritableStreamDefaultControllerGetBackpressure$A( ~this )
◎
Let backpressure be ! WritableStreamDefaultControllerGetBackpressure(this).
</li>
	<li>
! `WritableStreamUpdateBackpressure$A( %stream, %backpressure )
を遂行する
◎
Perform ! WritableStreamUpdateBackpressure(stream, backpressure).
</li>
</ol>

			</section>
			<section id="ws-default-controller-prototype">
<h4 title="Properties of the WritableStreamDefaultController Prototype">4.7.4. `WritableStreamDefaultController^C ~prototypeの各種~prop</h4>


				<section id="ws-default-controller-error">
<h5>4.7.4.1. `error( e )^dw</h5>

<div class="note">

<p>
`error()^dw ~methodは、可書~streamを~errorにする
— それに対する以降のやりとりすべては，与えられた~error %e で失敗するようになる。
◎
The error method will error the writable stream, making all future interactions with it fail with the given error e.
</p>
<p>
この~methodは、稀にしか利用されない
— 通例的には、`下層~槽$のいずれかの~methodから，却下された~promiseを返すだけで十分になるので。
しかしながら、`下層~槽$とのやりとりによる通常の~lifecycleの外側にある~eventに呼応して~streamが突如~shut-downされる場合には，有用になり得る。
◎
This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying sink’s methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the normal lifecycle of interactions with the underlying sink.
</p>
</div>

<ol class="algo">
	<li>
~IF 
! `IsWritableStreamDefaultController$A( ~this) ~EQ ~false
⇒
~THROW `TypeError^b
◎
If ! IsWritableStreamDefaultController(this) is false, throw a TypeError exception.
</li>
	<li>
%state ~LET ~this.[[controlledWritableStream]].[[state]]
◎
Let state be this.[[controlledWritableStream]].[[state]].
</li>
	<li>
~IF
%state ~IN { `closed^l, `errored^l }
⇒
~THROW `TypeError^b
◎
If state is "closed" or "errored", throw a TypeError exception.
</li>
	<li>
! `WritableStreamDefaultControllerError$A( ~this, %e )
を遂行する
◎
Perform ! WritableStreamDefaultControllerError(this, e).
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="ws-default-controller-abstract-ops">
<h3 title="Writable Stream Default Controller Abstract Operations">4.8. 可書~streamの既定の制御器の抽象~演算</h3>



			<section id="is-writable-stream-default-controller">
<h4 class="nothrow">4.8.1. `IsWritableStreamDefaultController ( x )^A</h4>

<ol class="algo">
	<li>
~IF
`Type$A( %x ) ~NEQ `Object^b
⇒
~RET ~false
◎
If Type(x) is not Object, return false.
</li>
	<li>
~IF
%x は [[underlyingSink]] 内部~slotを持たない
⇒
~RET ~false
◎
If x does not have an [[underlyingSink]] internal slot, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="writable-stream-default-controller-abort">
<h4 class="nothrow">4.8.2. `WritableStreamDefaultControllerAbort ( controller, reason )^A</h4>

<ol class="algo">
	<li>
! `ResetQueue$A( %controller )
を遂行する
◎
Perform ! ResetQueue(controller).
</li>
	<li>
%sinkAbortPromise ~LET
! `PromiseInvokeOrNoop$A( %controller.[[underlyingSink]], `abort^l, « %reason » )
◎
Let sinkAbortPromise be ! PromiseInvokeOrNoop(controller.[[underlyingSink]], "abort", « reason »).
</li>
	<li>
~RET 
%sinkAbortPromise を［
~undefined を返す充足~handler
］で`変形-$した結果
◎
Return the result of transforming sinkAbortPromise with a fulfillment handler that returns undefined.
</li>
</ol>

			</section>
			<section id="writable-stream-default-controller-close">
<h4 class="nothrow">4.8.3. `WritableStreamDefaultControllerClose ( controller )^A</h4>

<ol class="algo">
	<li>
! `EnqueueValueWithSize$A( %controller, `close^l, `0^b )
を遂行する
◎
Perform ! EnqueueValueWithSize(controller, "close", 0).
</li>
	<li>
! `WritableStreamDefaultControllerAdvanceQueueIfNeeded$A( %controller )
を遂行する
◎
Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller).
</li>
</ol>

			</section>
			<section id="writable-stream-default-controller-get-chunk-size">
<h4 class="nothrow">4.8.4. `WritableStreamDefaultControllerGetChunkSize ( controller , chunk )^A</h4>

<ol class="algo">
	<li>
%strategySize ~LET %controller.[[strategySize]]
◎
Let strategySize be controller.[[strategySize]].
</li>
	<li>
~IF
%strategySize ~EQ ~undefined
⇒
~RET `1^b
◎
If strategySize is undefined, return 1.
</li>
	<li>
%returnValue ~LET `Call$A( %strategySize, ~undefined, « %chunk » )
◎
Let returnValue be Call(strategySize, undefined, « chunk »).
</li>
	<li>
<p>
~IF
%returnValue は`中途完了$である
：
◎
If returnValue is an abrupt completion,
</p>
		<ol>
			<li>
! `WritableStreamDefaultControllerErrorIfNeeded$A( %controller, %returnValue.[[Value]] )
を遂行する
◎
Perform ! WritableStreamDefaultControllerErrorIfNeeded(controller, returnValue.[[Value]]).
</li>
			<li>
~RET `1^b
◎
Return 1.
</li>
		</ol>
	</li>
	<li>
~RET %returnValue.[[Value]]
◎
Return returnValue.[[Value]].
</li>
</ol>
			</section>
			<section id="writable-stream-default-controller-get-desired-size">
<h4 class="nothrow">4.8.5. `WritableStreamDefaultControllerGetDesiredSize ( controller )^A</h4>

<ol class="algo">
	<li>
~RET %controller.[[strategyHWM]] − %controller.[[queueTotalSize]]
◎
Return controller.[[strategyHWM]] − controller.[[queueTotalSize]].
</li>
</ol>

			</section>
			<section id="writable-stream-default-controller-write">
<h4 class="nothrow">4.8.6. `WritableStreamDefaultControllerWrite ( controller, chunk, chunkSize )^A</h4>

<ol class="algo">
	<li>
%writeRecord ~LET `~Record$ { [[chunk]]: %chunk }
◎
Let writeRecord be Record {[[chunk]]: chunk}.
</li>
	<li>
%enqueueResult ~LET
! `EnqueueValueWithSize$A( %controller, %writeRecord, %chunkSize )
◎
Let enqueueResult be ! EnqueueValueWithSize(controller, writeRecord, chunkSize).
</li>
	<li>
<p>
~IF
%enqueueResult は`中途完了$である
：
◎
If enqueueResult is an abrupt completion,
</p>
		<ol>
			<li>
! `WritableStreamDefaultControllerErrorIfNeeded$A( %controller, %enqueueResult.[[Value]])
を遂行する
◎
Perform ! WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueResult.[[Value]]).
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%stream ~LET %controller.[[controlledWritableStream]]
◎
Let stream be controller.[[controlledWritableStream]].
</li>
	<li>
<p>
~IF ! `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~false
：
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is false,
</p>
		<ol>
			<li>
%backpressure ~LET ! `WritableStreamDefaultControllerGetBackpressure$A( %controller )
◎
Let backpressure be ! WritableStreamDefaultControllerGetBackpressure(controller).
</li>
			<li>
! `WritableStreamUpdateBackpressure$A( %stream, %backpressure )
を遂行する
◎
Perform ! WritableStreamUpdateBackpressure(stream, backpressure).
</li>
		</ol>
	</li>
	<li>
! `WritableStreamDefaultControllerAdvanceQueueIfNeeded$A( %controller )
を遂行する
◎
Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller).
</li>
</ol>


			</section>
			<section id="writable-stream-default-controller-start">
<h4 class="throws">4.8.7. `WritableStreamDefaultControllerStart ( controller )^A</h4>

<ol class="algo">
	<li>
%startResult ~LET ? `InvokeOrNoop$A( %controller.[[underlyingSink]], `start^l, « %controller » )
◎
Let startResult be ? InvokeOrNoop(controller.[[underlyingSink]], "start", « controller »).
</li>
	<li>
%stream ~LET %controller.[[controlledWritableStream]]
◎
Let stream be controller.[[controlledWritableStream]].
</li>
	<li>
<p>
%startPromise ~LET
%startResult で`解決された~promise$：
◎
Let startPromise be a promise resolved with startResult:
</p>
		<ol>
			<li>
<p>
%startPromise の`充足~時$には：
◎
Upon fulfillment of startPromise,
</p>
				<ol>
					<li>
%controller.[[started]] ~SET ~true
◎
Set controller.[[started]] to true.
</li>
					<li>
~IF
%stream.[[state]] ~EQ `errored^l
⇒
! `WritableStreamRejectAbortRequestIfPending$A( %stream )
を遂行する
◎
If stream.[[state]] is "errored", perform ! WritableStreamRejectAbortRequestIfPending(stream).
</li>
					<li>
~ELSE
⇒
! `WritableStreamHandleAbortRequestIfPending$A( %stream )
を遂行する
◎
Otherwise, perform ! WritableStreamHandleAbortRequestIfPending(stream).
</li>
					<li>
! `WritableStreamDefaultControllerAdvanceQueueIfNeeded$A( %controller )
を遂行する
◎
Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller).
</li>
				</ol>
			</li>
			<li>
<p>
事由 %r による %startPromise の`却下~時$には：
◎
Upon rejection of startPromise with reason r,
</p>
				<ol>
					<li>
~Assert：
%stream.[[state]] ~IN { `writable^l, `errored^l }
◎
Assert: stream.[[state]] is "writable" or "errored".
</li>
					<li>
! `WritableStreamDefaultControllerErrorIfNeeded$A( %controller, %r )
を遂行する
◎
Perform ! WritableStreamDefaultControllerErrorIfNeeded(controller, r).
</li>
					<li>
! `WritableStreamRejectAbortRequestIfPending$A( %stream )
を遂行する
◎
Perform ! WritableStreamRejectAbortRequestIfPending(stream).
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="writable-stream-default-controller-advance-queue-if-needed">
<h4 class="nothrow">4.8.8. `WritableStreamDefaultControllerAdvanceQueueIfNeeded ( controller )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledWritableStream]]
◎
Let stream be controller.[[controlledWritableStream]].
</li>
	<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
	<li>
~IF
%state ~IN { `closed^l, `errored^l }
⇒
~RET
◎
If state is "closed" or "errored", return.
</li>
	<li>
~IF
%controller.[[started]] ~EQ ~false
⇒
~RET
◎
If controller.[[started]] is false, return.
</li>
	<li>
~IF
%stream.[[inFlightWriteRequest]] ~NEQ ~undefined
⇒
~RET
◎
If stream.[[inFlightWriteRequest]] is not undefined, return.
</li>
	<li>
~IF
%controller.[[queue]] は空である
⇒
~RET
◎
If controller.[[queue]] is empty, return.
</li>
	<li>
%writeRecord ~LET ! `PeekQueueValue$A( %controller )
◎
Let writeRecord be ! PeekQueueValue(controller).
</li>
	<li>
~IF
%writeRecord ~EQ `close^l
⇒
! `WritableStreamDefaultControllerProcessClose$A( %controller )
を遂行する
◎
If writeRecord is "close", perform ! WritableStreamDefaultControllerProcessClose(controller).
</li>
	<li>
~ELSE
⇒
! `WritableStreamDefaultControllerProcessWrite$A( %controller, %writeRecord.[[chunk]])
を遂行する
◎
Otherwise, perform WritableStreamDefaultControllerProcessWrite(controller, writeRecord.[[chunk]]).
</li>
</ol>
			</section>
			<section id="writable-stream-default-controller-error-if-needed">
<h4 class="nothrow">4.8.9. `WritableStreamDefaultControllerErrorIfNeeded ( controller, e )^A</h4>

<ol class="algo">
	<li>
~IF
%controller.[[controlledWritableStream]].[[state]] ~EQ `writable^l
⇒
! `WritableStreamDefaultControllerError$A( %controller, %e )
を遂行する
◎
If controller.[[controlledWritableStream]].[[state]] is "writable", perform ! WritableStreamDefaultControllerError(controller, e).
</li>
</ol>

			</section>
			<section id="writable-stream-default-controller-process-close">
<h4 class="nothrow">4.8.10. `WritableStreamDefaultControllerProcessClose ( controller )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledWritableStream]]
◎
Let stream be controller.[[controlledWritableStream]].
</li>
	<li>
! `WritableStreamMarkCloseRequestInFlight$A( %stream )
を遂行する
◎
Perform ! WritableStreamMarkCloseRequestInFlight(stream).
</li>
	<li>
! `DequeueValue$A( %controller )
を遂行する
◎
Perform ! DequeueValue(controller).
</li>
	<li>
~Assert：
%controller.[[queue]] は空である
◎
Assert: controller.[[queue]] is empty.
</li>
	<li>
%sinkClosePromise ~LET
! `PromiseInvokeOrNoop$A( %controller.[[underlyingSink]], `close^l, « %controller » )
◎
Let sinkClosePromise be ! PromiseInvokeOrNoop(controller.[[underlyingSink]], "close", « controller »).
</li>
	<li>
<p>
%sinkClosePromise の`充足~時$には：
◎
Upon fulfillment of sinkClosePromise,
</p>
		<ol>
			<li>
! `WritableStreamFinishInFlightClose$A( %stream )
を遂行する
◎
Perform ! WritableStreamFinishInFlightClose(stream).
</li>
		</ol>
	</li>
	<li>
<p>
事由 %reason による
%sinkClosePromise の`却下~時$には：
◎
Upon rejection of sinkClosePromise with reason reason,
</p>

		<ol>
			<li>
! `WritableStreamFinishInFlightCloseWithError$A( %stream, %reason )
を遂行する
◎
Perform ! WritableStreamFinishInFlightCloseWithError(stream, reason).
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="writable-stream-default-controller-process-write">
<h4 class="nothrow">4.8.11. `WritableStreamDefaultControllerProcessWrite ( controller, chunk )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controllerWritableStream]]
◎
Let stream be controller.[[controllerWritableStream]].
</li>
	<li>
! `WritableStreamMarkFirstWriteRequestInFlight$A( %stream )
を遂行する
◎
Perform ! WritableStreamMarkFirstWriteRequestInFlight(stream).
</li>
	<li>
%sinkWritePromise ~LET
! `PromiseInvokeOrNoop$A( %controller.[[underlyingSink]], `write^l, « %chunk, %controller » )
◎
Let sinkWritePromise be ! PromiseInvokeOrNoop(controller.[[underlyingSink]], "write", « chunk, controller »).
</li>
	<li>
<p>
%sinkWritePromise の`充足~時$には：
◎
Upon fulfillment of sinkWritePromise,
</p>
		<ol>
			<li>
! `WritableStreamFinishInFlightWrite$A( %stream )
を遂行する
◎
Perform ! WritableStreamFinishInFlightWrite(stream).
</li>
			<li>
%state ~LET %stream.[[state]]
◎
Let state be stream.[[state]].
</li>
			<li>
~IF
%state ~EQ `errored^l
⇒
~RET
◎
If state is "errored", return.
</li>
			<li>
~Assert：
%state ~EQ `writable^l
◎
Assert: state is "writable".
</li>
			<li>
! `DequeueValue$A( %controller )
を遂行する
◎
Perform ! DequeueValue(controller).
</li>
			<li>
<p>
~IF
! `WritableStreamCloseQueuedOrInFlight$A(stream) ~EQ ~false
：
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is false,
</p>
				<ol>
					<li>
%backpressure ~LET
! `WritableStreamDefaultControllerGetBackpressure$A( %controller )
◎
Let backpressure be ! WritableStreamDefaultControllerGetBackpressure(controller).
</li>
					<li>
! `WritableStreamUpdateBackpressure$A( %stream, %backpressure )
を遂行する
◎
Perform ! WritableStreamUpdateBackpressure(stream, backpressure).
</li>
				</ol>
			</li>
			<li>
! `WritableStreamDefaultControllerAdvanceQueueIfNeeded$A( %controller )
を遂行する
◎
Perform ! WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller).
</li>
		</ol>
	</li>
	<li>
<p>
事由 %reason による
%sinkWritePromise の`却下~時$には：
◎
Upon rejection of sinkWritePromise with reason,
</p>
		<ol>
			<li>
%wasErrored ~LET ~F
◎
Let wasErrored be false.
</li>
			<li>
~IF
%stream.[[state]] ~EQ `errored^l
⇒
%wasErrored ~SET ~true
◎
If stream.[[state]] is "errored", set wasErrored to true.
</li>
			<li>
! `WritableStreamFinishInFlightWriteWithError$A( %stream, %reason )
を遂行する
◎
Perform ! WritableStreamFinishInFlightWriteWithError(stream, reason).
</li>
			<li>
~Assert：
%stream.[[state]] ~EQ `errored^l
◎
Assert: stream.[[state]] is "errored".
</li>
			<li>
~IF［
%wasErrored ~EQ ~false
］
⇒
%controller.[[queue]] ~SET 空の`~List$
◎
If wasErrored is false, set controller.[[queue]] to an empty List.
</li>
		</ol>
	</li>
</ol>

			</section>
			<section id="writable-stream-default-controller-get-backpressure">
<h4 class="nothrow">4.8.12. `WritableStreamDefaultControllerGetBackpressure ( controller )^A</h4>

<ol class="algo">
	<li>
%desiredSize ~LET
! `WritableStreamDefaultControllerGetDesiredSize$A( %controller )
◎
Let desiredSize be ! WritableStreamDefaultControllerGetDesiredSize(controller).
</li>
	<li>
~RET %desiredSize ≤ `0^b
◎
Return desiredSize ≤ 0.
</li>
</ol>

			</section>
			<section id="writable-stream-default-controller-error">
<h4 class="nothrow">4.8.13. `WritableStreamDefaultControllerError ( controller, e )^A</h4>

<ol class="algo">
	<li>
%stream ~LET %controller.[[controlledWritableStream]]
◎
Let stream be controller.[[controlledWritableStream]].
</li>
	<li>
~Assert：
%stream.[[state]] ~EQ `writable^l
◎
Assert: stream.[[state]] is "writable".
</li>
	<li>
%stream.[[state]] ~SET `errored^l
◎
Set stream.[[state]] to "errored".
</li>
	<li>
%stream.[[storedError]] ~SET %e 
◎
Set stream.[[storedError]] to e.
</li>
	<li>
%writer ~LET %stream.[[writer]]
◎
Let writer be stream.[[writer]].
</li>
	<li>
<p>
~IF［
%stream.[[pendingAbortRequest]] ~EQ ~undefined
］~AND［
%writer ~NEQ ~undefined
］：
◎
If stream.[[pendingAbortRequest]] is undefined and writer is not undefined,
</p>
		<ol>
			<li>
~IF［
If ! `WritableStreamCloseQueuedOrInFlight$A( %stream ) ~EQ ~F
］~AND［
%stream.[[backpressure]] ~EQ ~true
］
⇒
%e で %writer.[[readyPromise]] を`却下する$
◎
If ! WritableStreamCloseQueuedOrInFlight(stream) is false and stream.[[backpressure]] is true, reject writer.[[readyPromise]] with e.
</li>
			<li>
~ELSE
⇒
%writer.[[readyPromise]] ~SET %e で`却下された~promise$
◎
Otherwise, set writer.[[readypromise]] to a promise rejected with e.
</li>
			<li>
%writer.[[readyPromise]].[[PromiseIsHandled]] ~SET ~true
◎
Set writer.[[readyPromise]].[[PromiseIsHandled]] to true.
</li>
		</ol>
	</li>
	<li>
! `ResetQueue$A( %controller )
を遂行する
◎
Perform ! ResetQueue(controller).
</li>
	<li>
~IF
! `WritableStreamHasOperationMarkedInFlight$A( %stream ) ~EQ ~false
⇒
! `WritableStreamRejectPromisesInReactionToError$A( %stream )
を遂行する
◎
If ! WritableStreamHasOperationMarkedInFlight(stream) is false, perform ! WritableStreamRejectPromisesInReactionToError(stream).
</li>
</ol>
			</section>
		</section>
	</section>
	<section id="ts">
<h2 title="Transform Streams">5. 形式変換~stream</h2>

<p>
形式変換~streamは，試験可能な実装にて開発されてきたが、まだ仕様の~~記述として言語化されていない。
その前に，その設計が検証されるのを待機している~~所である。
当面の間は，
<a href="~STREAMS/blob/master/reference-implementation/lib/transform-stream.js">reference-implementation/lib/transform-stream.js</a>
を見よ。
◎
Transform streams have been developed in the testable implementation, but not yet re-encoded in spec language. We are waiting to validate their design before doing so. In the meantime, see reference-implementation/lib/transform-stream.js.
</p>


	</section>
	<section id="other-stuff">
<h2 title="Other Stream APIs and Operations">6. 他の~stream~API と演算</h2>

		<section id="blqs-class">
<h3 title="Class ByteLengthQueuingStrategy">6.1. `ByteLengthQueuingStrategy^C ~class</h3>


<p>
~byte列を扱うときに共通的な`~queuing策$は、流入`~chunk$たちの `byteLength^c ~propの累積が，指定された`限界水位$に到達するまで、待機することである。
そのようなわけで，これは、~streamを構築するときに利用できるような，組込みの`~queuing策$として提供される。
◎
A common queuing strategy when dealing with bytes is to wait until the accumulated byteLength properties of the incoming chunks reaches a specified high-water mark. As such, this is provided as a built-in queuing strategy that can be used when constructing streams.
</p>


<div class="example" id="example-blqs">

<p>
`可読~stream$／`可書~stream$を作成する際には、~byte数による~queuing策を直接的に給せる：
◎
When creating a readable stream or writable stream, you can supply a byte-length queuing strategy directly:
</p>

<pre class="lang-javascript">
const %stream = new ReadableStream(
  { ... },
  new ByteLengthQueuingStrategy({ %highWaterMark: 16 * 1024 })
);
</pre>

<p>
この事例では、可読~stream実装が 下層~源へ`背圧$合図の送信を開始するまでに、可読~streamの`下層~源$に~~総計 16 KiB 程の`~chunk$たちを~enqueueできる。
◎
In this case, 16 KiB worth of chunks can be enqueued by the readable stream’s underlying source before the readable stream implementation starts sending backpressure signals to the underlying source.
</p>

<pre class="lang-javascript">
const %stream = new WritableStream(
  { ... },
  new ByteLengthQueuingStrategy({ %highWaterMark: 32 * 1024 })
);
</pre>

<p>
この事例では、`下層~槽$への以前の書込が終わるまで待機する間，可書~streamが `生産器$へ向けて`背圧$合図の送信を開始するまでに、~~総計 32 KiB 程の`~chunk$たちを可書~streamの内部~queue内に累積し得る。
◎
In this case, 32 KiB worth of chunks can be accumulated in the writable stream’s internal queue, waiting for previous writes to the underlying sink to finish, before the writable stream starts sending backpressure signals to any producers.
</p>
</div>

			<section id="blqs-class-definition">
<h4 title="Class Definition">6.1.1. ~class定義</h4>

~INFORMATIVE

<p>
`ByteLengthQueuingStrategy$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば、次のようになる：
◎
If one were to write the ByteLengthQueuingStrategy class in something close to the syntax of [ECMASCRIPT], it would look like
</p>


<pre class="lang-javascript">
class ByteLengthQueuingStrategy {
  constructor({ %highWaterMark })
  size(%chunk)
}
</pre>

<p>
`ByteLengthQueuingStrategy^C の各~instanceは、追加で，自前の~data~prop `highWaterMark^c がその構築子により設定される。
◎
Each ByteLengthQueuingStrategy instance will additionally have an own data property highWaterMark set by its constructor.
</p>


			</section>
			<section id="blqs-constructor">
<h4>6.1.2. `new ByteLengthQueuingStrategy({ highWaterMark })^c</h4>

<div class="note">
<p>
この構築子は、`限界水位$を与える非負~数をとり，それを~objの~propとして格納する。
◎
The constructor takes a non-negative number for the high-water mark, and stores it on the object as a property.
</p>

</div>

<ol class="algo">
	<li>
! `CreateDataProperty$A( ~this, `highWaterMark^l, %highWaterMark )
を遂行する
◎
Perform ! CreateDataProperty(this, "highWaterMark", highWaterMark).
</li>
</ol>

			</section>
			<section id="blqs-prototype">
<h4 title="Properties of the ByteLengthQueuingStrategy Prototype">6.1.3. `ByteLengthQueuingStrategy^C ~prototypeの各種~prop</h4>
				<section id="blqs-size">
<h5>6.1.3.1. `size(chunk)^c</h5>


<div class="note">

<p>
`size()^c ~methodは、所与の`~chunk$の `byteLength^c ~propを返す（~chunkがそれを持たない場合、 ~undefined を返し，この策を利用している~streamを~errorにさせることになる）
◎
The size method returns the given chunk’s byteLength property. (If the chunk doesn’t have one, it will return undefined, causing the stream using this strategy to error.)
</p>

<p>
この~methodは、その ~this 値が `ByteLengthQueuingStrategy^C ~objであることを要求しない点で，意図的に汎化してある。
◎
This method is intentionally generic; it does not require that its this value be a ByteLengthQueuingStrategy object.
</p>

</div>


<ol class="algo">
	<li>
~RET
? `GetV$A( %chunk, `byteLength^l )
◎
Return ? GetV(chunk, "byteLength").
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="cqs-class">
<h3 title="Class CountQueuingStrategy">6.2. `CountQueuingStrategy^C ~class</h3>


<p>
汎用~objの~streamを扱うときに共通的な`~queuing策$は、単純に，［
指定された`限界水位$に到達するまで，累積の`~chunk$数を数え続ける
］ものである。
そのようなわけで、この策も ~out-of-the-boxで提供される。
◎
A common queuing strategy when dealing with streams of generic objects is to simply count the number of chunks that have been accumulated so far, waiting until this number reaches a specified high-water mark. As such, this strategy is also provided out of the box.
</p>


<div class="example" id="example-cqs">

<p>
`可読~stream$／`可書~stream$を作成するときは、~chunk数による~queuing策を直接的に給せる：
◎
When creating a readable stream or writable stream, you can supply a count queuing strategy directly:
</p>

<pre class="lang-javascript">
const %stream = new ReadableStream(
  { ... },
  new CountQueuingStrategy({ %highWaterMark: 10 })
);
</pre>

<p>
この事例では、可読~stream実装が `下層~源$へ向けて`背圧$合図の送信を開始するまでに、（種類は問わず） 10 個の`~chunk$を，可読~streamの`下層~源$に~enqueueし得る。
◎
In this case, 10 chunks (of any kind) can be enqueued by the readable stream’s underlying source before the readable stream implementation starts sending backpressure signals to the underlying source.
</p>

<pre class="lang-javascript">
const %stream = new WritableStream(
  { ... },
  new CountQueuingStrategy({ %highWaterMark: 5 })
);
</pre>

<p>
この事例では、`下層~槽$への以前の書込が終わるまで待機している間，可書~streamが `生産器$へ向けて`背圧$合図の送信を開始するまでに、可書~streamの内部~queue内に（種類は問わず） 5 個の`~chunk$を累積し得る。
◎
In this case, five chunks (of any kind) can be accumulated in the writable stream’s internal queue, waiting for previous writes to the underlying sink to finish, before the writable stream starts sending backpressure signals to any producers.
</p>
</div>


			<section id="cqs-class-definition">
<h4 title="Class Definition">6.2.1. ~class定義</h4>

~INFORMATIVE

<p>
`CountQueuingStrategy$C ~classは、
`ECMASCRIPT$r 風の構文で書くならば，次のようになる：
◎
If one were to write the CountQueuingStrategy class in something close to the syntax of [ECMASCRIPT], it would look like
</p>


<pre class="lang-javascript">
class CountQueuingStrategy {
  constructor({ %highWaterMark })
  size()
}
</pre>

<p>
`CountQueuingStrategy^C の各~instanceは、追加で，自前の~data~prop `highWaterMark^c が，その構築子により設定される。
◎
Each CountQueuingStrategy instance will additionally have an own data property highWaterMark set by its constructor.
</p>


			</section>
			<section id="cqs-constructor">
<h4>6.2.2. `new CountQueuingStrategy({ highWaterMark })^c</h4>

<div class="note">
<p>
この構築子は、`限界水位$を与える非負~数をとり，それを~objの~propとして格納する。
◎
The constructor takes a non-negative number for the high-water mark, and stores it on the object as a property.
</p>

</div>

<ol class="algo">
	<li>
! `CreateDataProperty$A( ~this, `highWaterMark^l, %highWaterMark )
を遂行する
◎
Perform ! CreateDataProperty(this, "highWaterMark", highWaterMark).
</li>
</ol>

			</section>
			<section id="cqs-prototype">
<h4 title="Properties of the CountQueuingStrategy Prototype">6.2.3. `CountQueuingStrategy^C ~prototypeの各種~prop</h4>

				<section id="cqs-size">
<h5>6.2.3.1. `size()^c</h5>


<div class="note">
<p>
`size()^c ~methodは、常に 1 を返す
— 合計~queue~sizeが，~queue内にある`~chunk$の個数になるように。
◎
The size method returns one always, so that the total queue size is a count of the number of chunks in the queue.
</p>

<p>
この~methodは、その ~this 値が `CountQueuingStrategy^C ~objであることを要求しない点で，意図的に汎化してある。
◎
This method is intentionally generic; it does not require that its this value be a CountQueuingStrategy object.
</p>

</div>

<ol class="algo">
	<li>
~RET `1^b
◎
Return 1.
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="queue-with-sizes">
<h3 title="Queue-with-Sizes Operations">6.3. 個別~size付き~queue演算</h3>

<p>
この仕様における各種~streamは、
“個別~size付き~queue”
（ queue-with-sizes ）と称される~data構造を利用して，~queue-upされた値を, それに決定された~sizeと伴に格納する。
個別~size付き~queueは、種々の仕様~levelの~objに包含され，［
常に，
[[queue]], [[queueTotalSize]]
と命名され，~pairにされる 2 つの内部~slot
］を持つ~objにより表現される。
[[queue]] は，それぞれが［
[[value]], [[size]]
］~fieldを伴う一連の~Recordからなる`~List$であり、
[[queueTotalSize]] は，~JS `Number$b
— すなわち，倍精度~浮動小数点 数 —
をとる。
◎
The streams in this specification use a "queue-with-sizes" data structure to store queued up values, along with their determined sizes. Various specification objects contain a queue-with-sizes, represented by the object having two paired internal slots, always named [[queue]] and [[queueTotalSize]]. [[queue]] is a List of Records with [[value]] and [[size]] fields, and [[queueTotalSize]] is a JavaScript Number, i.e. a double-precision floating point number.
</p>

<p>
個別~size付き~queueを包含する~obj上で演算するときには、
この 2 つの内部~slotが同期し続けることを確保するため，以下の抽象~演算が利用される。
◎
The following abstract operations are used when operating on objects that contain queues-with-sizes, in order to ensure that the two internal slots stay synchronized.
</p>

<p class="warning">
ここに指定される~frameworkは，合計が [[queueTotalSize]] ~slotに~~収まり続けるようにするが、浮動小数点 算術の精度には限りがあるため，
[[queue]] 内の すべての`~chunk$の~sizeを加算していくことに<em>等価ではない</em>。
（しかしながら，この相違が生じるのは、~chunkたちの~sizeの変動幅が莫大になるとき（ 〜 10<sup>15</sup> ）か, 数 100 京 個の~chunkが~enqueueされたときに限られる。）
◎
Due to the limited precision of floating-point arithmetic, the framework specified here, of keeping a running total in the [[queueTotalSize]] slot, is not equivalent to adding up the size of all chunks in [[queue]]. (However, this only makes a difference when there is a huge (~ 1015) variance in size between chunks, or when trillions of chunks are enqueued.)
</p>


			<section id="dequeue-value">
<h4 class="nothrow">6.3.1. `DequeueValue ( container )^A</h4>

<ol class="algo">
	<li>
~Assert：
%container は
[[queue]], [[queueTotalSize]]
両~内部~slotを持つ
◎
Assert: container has [[queue]] and [[queueTotalSize]] internal slots.
</li>
	<li>
~Assert：
%container.[[queue]] は空でない
◎
Assert: container.[[queue]] is not empty.
</li>
	<li>
%pair ~LET %container.[[queue]] の最初の要素
◎
Let pair be the first element of container.[[queue]].
</li>
	<li>
%container.[[queue]] から %pair を除去する
— 後続の要素たちは~~先頭へ一つずらす
◎
Remove pair from container.[[queue]], shifting all other elements downward (so that the second becomes the first, and so on).
</li>
	<li>
%container.[[queueTotalSize]] ~SET %container.[[queueTotalSize]] − %pair.[[size]]
◎
Set container.[[queueTotalSize]] to container.[[queueTotalSize]] − pair.[[size]].
</li>
	<li>
~IF［
%container.[[queueTotalSize]] ~LT `0^b
］
⇒
%container.[[queueTotalSize]] ~SET `0^b
（これは丸め誤差に因り生じ得る。）
◎
If container.[[queueTotalSize]] &lt; 0, set container.[[queueTotalSize]] to 0. (This can occur due to rounding errors.)
</li>
	<li>
~RET %pair.[[value]]
◎
Return pair.[[value]].
</li>
</ol>

			</section>
			<section id="enqueue-value-with-size">
<h4 class="throws">6.3.2. `EnqueueValueWithSize ( container, value, size )^A</h4>

<ol class="algo">
	<li>
~Assert：
%container は
[[queue]], [[queueTotalSize]]
両~内部~slotを持つ
◎
Assert: container has [[queue]] and [[queueTotalSize]] internal slots.
</li>
	<li>
%size ~LET ? `ToNumber$A( %size )
◎
Let size be ? ToNumber(size).
</li>
	<li>
~IF［
! `IsFiniteNonNegativeNumber$A( %size ) ~EQ `false^b
］
⇒
~THROW `RangeError^b
◎
If ! IsFiniteNonNegativeNumber(size) is false, throw a RangeError exception.
</li>
	<li>
`~Record${ [[value]]: %value, [[size]]: %size }
を
%container.[[queue]] の~~末尾に付加する
◎
Append Record {[[value]]: value, [[size]]: size} as the last element of container.[[queue]].
</li>
	<li>
%container.[[queueTotalSize]] ~SET %container.[[queueTotalSize]] + %size
◎
Set container.[[queueTotalSize]] to container.[[queueTotalSize]] + size.
</li>
</ol>


			</section>
			<section id="peek-queue-value">
<h4 class="nothrow">6.3.3. `PeekQueueValue ( container )^A</h4>

<ol class="algo">
	<li>
~Assert：
%container は
[[queue]], [[queueTotalSize]]
両~内部~slotを持つ
◎
Assert: container has [[queue]] and [[queueTotalSize]] internal slots.
</li>
	<li>
~Assert：
%container.[[queue]] は空でない
◎
Assert: container.[[queue]] is not empty.
</li>
	<li>
%pair ~LET %container.[[queue]] の最初の要素
◎
Let pair be the first element of container.[[queue]].
</li>
	<li>
~RET %pair.[[value]]
◎
Return pair.[[value]].
</li>
</ol>
			</section>
			<section id="reset-queue">
<h4 class="nothrow">6.3.4. `ResetQueue ( container )^A</h4>

<ol class="algo">
	<li>
~Assert：
%container は
[[queue]], [[queueTotalSize]]
両~内部~slotを持つ
◎
Assert: container has [[queue]] and [[queueTotalSize]] internal slots.
</li>
	<li>
%container.[[queue]] ~SET 新たな空`~List$
◎
Set container.[[queue]] to a new empty List.
</li>
	<li>
%container.[[queueTotalSize]] ~SET `0^b
◎
Set container.[[queueTotalSize]] to 0.
</li>
</ol>
			</section>
		</section>
		<section id="misc-abstract-ops">
<h3 title="Miscellaneous Operations">6.4. その他の演算</h3>

<p>
この仕様にて多目的に利用される抽象~演算を，以下に定義する：
◎
A few abstract operations are used in this specification for utility purposes. We define them here.
</p>


			<section id="invoke-or-noop">
<h4 class="throws">6.4.1. `InvokeOrNoop ( O, P, args )^A</h4>

<div class="note">

<p>
`InvokeOrNoop$A は、~methodが不在のときは ~undefined を返すように，
`ECMASCRIPT$r の抽象~演算 `Invoke$A を少しばかり改変したものである。
◎
InvokeOrNoop is a slight modification of the [ECMASCRIPT] Invoke abstract operation to return undefined when the method is not present.
</p>
</div>

<ol class="algo">
	<li>
~Assert：
%O ~NEQ ~undefined
◎
Assert: O is not undefined.
</li>
	<li>
~Assert：
`IsPropertyKey$A(%P) ~EQ ~true
◎
Assert: ! IsPropertyKey(P) is true.
</li>
	<li>
~Assert：
%args は`~List$である
◎
Assert: args is a List.
</li>
	<li>
%method ~LET
? `GetV$A( %O, %P )
◎
Let method be ? GetV(O, P).
</li>
	<li>
~IF
%method ~EQ ~undefined
⇒
~RET ~undefined
◎
If method is undefined, return undefined.
</li>
	<li>
~RET
? `Call$A( %method, %O, %args )
◎
Return ? Call(method, O, args).
</li>
</ol>

			</section>
			<section id="is-finite-non-negative-number">
<h4 class="nothrow">6.4.2. `IsFiniteNonNegativeNumber ( v )^A</h4>

<ol class="algo">
	<li>
~IF
%v ~EQ `NaN^b
⇒
~RET ~false
◎
If v is NaN, return false.
</li>
	<li>
~IF
%v ~EQ `+∞^b
⇒
~RET ~false
◎
If v is +∞, return false.
</li>
	<li>
~IF
%v ~LT `0^b
⇒
~RET ~false
◎
If v &lt; 0, return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

			</section>
			<section id="promise-invoke-or-noop">
<h4 class="nothrow">6.4.3. `PromiseInvokeOrNoop ( O, P, args )^A</h4>


<div class="note">
<p>
`PromiseInvokeOrNoop^A は、`~promise-calling$の特殊化版である。
それは，~methodに対し働くが、~methodが不在のときは ~undefined に対する~promiseを返す。
◎
PromiseInvokeOrNoop is a specialized version of promise-calling that both works on methods and returns a promise for undefined when the method is not present.
</p>

</div>


<ol class="algo">
	<li>
~Assert：
%O ~NEQ ~undefined
◎
Assert: O is not undefined.
</li>
	<li>
~Assert：
`IsPropertyKey$A(%P) ~EQ ~true
◎
Assert: ! IsPropertyKey(P) is true.
</li>
	<li>
~Assert：
%args は`~List$である
◎
Assert: args is a List.
</li>
	<li>
%returnValue ~LET `InvokeOrNoop$A( %O, %P, %args )
◎
Let returnValue be InvokeOrNoop(O, P, args).
</li>
	<li>
~IF
%returnValue は`中途完了$である
⇒
~RET %returnValue.[[Value]] で`却下された~promise$
◎
If returnValue is an abrupt completion, return a promise rejected with returnValue.[[Value]].
</li>
	<li>
~ELSE
⇒
~RET %returnValue.[[Value]] で`解決された~promise$
◎
Otherwise, return a promise resolved with returnValue.[[Value]].
</li>
</ol>

			</section>
			<section id="validate-and-normalize-high-water-mark">
<h4 class="throws">6.4.4. `ValidateAndNormalizeHighWaterMark ( highWaterMark )^A</h4>


<ol class="algo">
	<li>
%highWaterMark ~SET
? `ToNumber$A( %highWaterMark )
◎
Set highWaterMark to ? ToNumber(highWaterMark).
</li>
	<li>
<p>
~IF［
%highWaterMark ~EQ `NaN^b
］~OR［
%highWaterMark ~LT `0^b
］
⇒
~THROW `TypeError^b
◎
If highWaterMark is NaN or highWaterMark &lt; 0, throw a RangeError exception. 
</p>

<p class="note">
+∞ は妥当な`限界水位$として明示的に許容される。
それは、`背圧$が決して適用されないようにする。
◎
+∞ is explicitly allowed as a valid high water mark. It causes backpressure to never be applied.
</p>
	</li>
	<li>
~RET %highWaterMark
◎
Return highWaterMark.
</li>
</ol>

			</section>
			<section id="validate-and-normalize-queuing-strategy">
<h4 class="throws">6.4.5. `ValidateAndNormalizeQueuingStrategy ( size, highWaterMark )^A</h4>

<ol class="algo">
	<li>
~IF［
%size ~NEQ ~undefined
］~AND［
! `IsCallable$A( %size ) ~EQ ~false
］
⇒
~THROW `TypeError^b
◎
If size is not undefined and ! IsCallable(size) is false, throw a TypeError exception.
</li>
	<li>
%highWaterMark ~LET
? `ValidateAndNormalizeHighWaterMark$A( %highWaterMark )
◎
Let highWaterMark be ? ValidateAndNormalizeHighWaterMark(highWaterMark).
</li>
	<li>
~RET
`~Record$ {[[size]]: %size, [[highWaterMark]]: %highWaterMark}
◎
Return Record {[[size]]: size, [[highWaterMark]]: highWaterMark}.
</li>
</ol>
			</section>
		</section>
	</section>
	<section id="globals">
<h2 title="Global Properties">7. 各種~大域~prop</h2>

<p>
次の構築子が同じ名前の~data~propとして`大域~obj$上に公開され~MUST：
◎
The following constructors must be exposed on the global object as data properties of the same name:
</p>

<ul><li>`ReadableStream$C
</li><li>`WritableStream$C
</li><li>`ByteLengthQueuingStrategy$C
</li><li>`CountQueuingStrategy$C
</li></ul>


<p>
これらの~propの属性は、
{ [[Writable]]: ~true, [[Enumerable]]: ~false, [[Configurable]]: ~true }
にされ~MUST。
◎
The attributes of these properties must be { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</p>

<div class="note">

<p>
次の各種~classは、独立に有用になることはないので，特に <em>公開されない</em>
⇒
`ReadableStreamDefaultReader$C,
`ReadableStreamBYOBReader$C,
`ReadableStreamDefaultController$C,
`ReadableByteStreamController$C,
`WritableStreamDefaultWriter$C,
`WritableStreamDefaultController$C
◎
The ReadableStreamDefaultReader, ReadableStreamBYOBReader, ReadableStreamDefaultController, ReadableByteStreamController, WritableStreamDefaultWriter, and WritableStreamDefaultController classes are specifically not exposed, as they are not independently useful.
</p>

</div>


	</section>
	<section id="creating-examples">
<h2 title="Examples of Creating Streams">8. ~streamを作成する例</h2>

~INFORMATIVE-DEEP

<p>
これまでの例では、~streamを利用する方法に力点を置いていた。
ここでは、
`ReadableStream$C ／ `WritableStream$C
構築子を利用して，~streamを作成する方法を示す。
◎
The previous examples throughout the standard have focused on how to use streams. Here we show how to create a stream, using the ReadableStream or WritableStream constructors.
</p>

		<section id="example-rs-push-no-backpressure">
<h3 title="A readable stream with an underlying push source (no backpressure support)">8.1. 下層~push源を伴う 可読~stream（背圧~supportなし）</h3>

<p>
次の関数は、 `WebSocket$I ~instance `HTML$r を包装する可読~streamを作成する。
それは、背圧~合図を~supportしない`~push源$である。
<!-- It illustrates how, -->
`~push源$に適応させるとき、通例的に，働きの大部分は `start()^c 関数にて起きるようにされる。
◎
The following function creates readable streams that wrap WebSocket instances [HTML], which are push sources that do not support backpressure signals. It illustrates how, when adapting a push source, usually most of the work happens in the start function.
</p>

<pre class="lang-javascript">
function makeReadableWebSocketStream(%url, %protocols) {
  const %ws = new WebSocket(%url, %protocols);
  %ws.binaryType = `arraybuffer^l;

  return new ReadableStream({
    start(%controller) {
      %ws.onmessage =
          %event =&gt; controller.enqueue(%event.data);
      %ws.onclose =
          () =&gt; %controller.close();
      %ws.onerror =
          () =&gt; %controller.error(new Error(`WebSocket に~errorが生じました^l));
    },

    cancel() {
      %ws.close();
    }
  });
}
</pre>

<!-- 
The WebSocket errored!
-->
<p>
この関数を利用すれば、~web~socketのための可読~streamを作成して，それを任意の可書~streamへ~pipeできるようになる：
◎
We can then use this function to create readable streams for a web socket, and pipe that stream to an arbitrary writable stream:
</p>

<pre class="lang-javascript">
const %webSocketStream =
    makeReadableWebSocketStream(`wss://example.com:443/^l, `protocol^l);

webSocketStream.pipeTo(%writableStream)
  .then(() =&gt; console.log(`すべての~dataは成功裡に書込されました^l))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));
</pre>




		</section>
		<section id="example-rs-push-backpressure">
<h3 title="A readable stream with an underlying push source and backpressure support">8.2. 下層~push源を伴う 可読~stream（背圧~supportあり）</h3>

<p>
次の関数は、 “背圧~socket” を包装する`可読~stream$を返す
— 背圧~socketは、~web~socketと同じ~APIを持つ仮説上の~objであるが，［
`readStop^c ／ `readStart^c
］~methodにより，~dataの流れを［
休止する／再開する
］能も提供する。
この例は、そうすることで，背圧を~supportする`下層~源$にそれを適用する方法を示すものになる。
◎
The following function returns readable streams that wrap "backpressure sockets," which are hypothetical objects that have the same API as web sockets, but also provide the ability to pause and resume the flow of data with their readStop and readStart methods. In doing so, this example shows how to apply backpressure to underlying sources that support it.
</p>

<pre class="lang-javascript">
function makeReadableBackpressureSocketStream(%host, %port) {
  const %socket = createBackpressureSocket(%host, %port);

  return new ReadableStream({
    start(%controller) {
      %socket.ondata = %event =&gt; {
        %controller.enqueue(%event.data);

        if (%controller.desiredSize &lt;= 0) {
/* <span class="comment">
内部~queueは満杯なので，下層~源へ背圧~合図を伝播させる。
◎
The internal queue is full, so propagate the backpressure signal to the underlying source.
</span> */
          socket.readStop();
        }
      };

      %socket.onend =
          () =&gt; %controller.close();
      %socket.onerror =
          () =&gt; %controller.error(new Error(`~socketに~errorが生じました^l));
    },

    pull() {
/* <span class="comment">
内部~queueが空になったが，~streamの消費器は まだ更なる~dataを求めている場合に~callされる。
その場合、以前に休止していたなら~dataの流れを再開始する。
◎
This is called if the internal queue has been emptied, but the stream’s consumer still wants more data. In that case, restart the flow of data if we have previously paused it.
</span> */
      %socket.readStart();
    },

    cancel() {
      %socket.close();
    }
  });
}
</pre>

<!-- 
"The socket errored!"
-->

<p>
この関数を利用すれば、~web~socketのときと同じ仕方で，そのような “背圧~socket” のための可読~streamを作成できるようになる。
しかしながら，この場合には、［
~socketが生産するほど高速には~dataを受容できないような行先へ~pipeされたとき
］, あるいは［
しばらくの間~streamから読取することなく放置したとき
］は，［
背圧~合図がその~socketに向けて送信される
］ことになる。
◎
We can then use this function to create readable streams for such "backpressure sockets" in the same way we do for web sockets. This time, however, when we pipe to a destination that cannot accept data as fast as the socket is producing it, or if we leave the stream alone without reading from it for some time, a backpressure signal will be sent to the socket.
</p>

		</section>
		<section id="example-rbs-push">
<h3 title="A readable byte stream with an underlying push source (no backpressure support)">8.3. 下層~push源を伴う 可読~byte~stream（背圧~supportなし）</h3>

<p>
次の関数は、仮説上の UDP ~socket~APIを包装する`可読~byte~stream$を返す
— それは、 POSIX `select(2)^c ~system~callを想起するよう意図された，~promiseを返す `select2()^c ~methodを含む。
◎
The following function returns readable byte streams that wraps a hypothetical UDP socket API, including a promise-returning select2() method that is meant to be evocative of the POSIX select(2) system call.
</p>

<p>
UDP ~protocolには組込みの背圧~supportはないので、 `desiredSize$rbsc が与える背圧~合図は無視される。
~streamは、~socketからの~dataが可用になったが，開発者からはまだ要請されていないときには、~streamの`内部~queue$に~enqueueして，~kernel空間の~queueから溢れないようにすることも確保する。
◎
Since the UDP protocol does not have any built-in backpressure support, the backpressure signal given by desiredSize is ignored, and the stream ensures that when data is available from the socket but not yet requested by the developer, it is enqueued in the stream’s internal queue, to avoid overflow of the kernel-space queue and a consequent loss of data.
</p>

<p>
これには、`消費器$と~streamの間の相互作用について興味を引く帰結がある。
消費器が~socketが生産するほど高速に~dataを読取しない場合、`~chunk$たちは，不定期の間~streamの`内部~queue$に残り続ける。
その場合，`~BYOB読取器$を利用すると，~dataを~streamの内部~queueから開発者が給する~bufferへ移動するときに，余分な複製が生じることになる。
一方で，消費器が~dataを十分素早く消費した場合、`~BYOB読取器$においては，
開発者から給される~bufferへ複製なしに直接的に読取できるようになる。
◎
This has some interesting consequences for how consumers interact with the stream. If the consumer does not read data as fast as the socket produces it, the chunks will remain in the stream’s internal queue indefinitely. In this case, using a BYOB reader will cause an extra copy, to move the data from the stream’s internal queue to the developer-supplied buffer. However, if the consumer consumes the data quickly enough, a BYOB reader will allow zero-copy reading directly into developer-supplied buffers.
</p>

<p>
（この例より複雑な~version
— `desiredSize$rbsc を利用して［
帯域外の，背圧を合図する仕組み
］（例えば，~socketに向けて ~dataの送信~rateを調整するような~messageを送信するなど）を伝えるなど —
も~~想定できるが、それについては，読者への演習に残しておく。）
◎
(You can imagine a more complex version of this example which uses desiredSize to inform an out-of-band backpressure signaling mechanism, for example by sending a message down the socket to adjust the rate of data being sent. That is left as an exercise for the reader.)
</p>



<pre class="lang-javascript">
const %DEFAULT_CHUNK_SIZE = 65536;

function makeUDPSocketStream(%host, %port) {
  const %socket = createUDPSocket(%host, %port);

  return new ReadableStream({
    type: `bytes^l,

    start(%controller) {
      readRepeatedly().catch(%e =&gt; %controller.error(%e));

      function readRepeatedly() {
        return %socket.select2().then(() =&gt; {
          /* <span class="comment">
%socket は可読になり得るので、処理待ちの~BYOB要請がないときでも、両~事例とも取扱う必要がある。
◎
Since the socket can become readable even when there’s no pending BYOB requests, we need to handle both cases.
</span> */
          let %bytesRead;
          if (%controller.byobRequest) {
            const %v = %controller.byobRequest.view;
            %bytesRead = %socket.readInto(%v.buffer, %v.byteOffset, v.byteLength);
            %controller.byobRequest.respond(%bytesRead);
          } else {
            const %buffer = new ArrayBuffer(%DEFAULT_CHUNK_SIZE);
            %bytesRead = %socket.readInto(buffer, 0, %DEFAULT_CHUNK_SIZE);
            %controller.enqueue(new Uint8Array(%buffer, 0, %bytesRead));
          }

          if (%bytesRead === 0) {
            %controller.close();
            return;
          }

          return readRepeatedly();
        });
      }
    },

    cancel() {
      %socket.close();
    }
  });
}
</pre>

<p>
この関数から返される `ReadableStream$C ~instanceは、今や，前に示したすべての便益と但し書きを伴うような `~BYOB読取器$を供給0できる。
◎
ReadableStream instances returned from this function can now vend BYOB readers, with all of the aforementioned benefits and caveats.
</p>

		</section>
		<section id="example-rs-pull">
<h3 title="A readable stream with an underlying pull source">8.4. 下層~pull源を伴う 可読~stream</h3>

<p>
次の関数は、（それ自身 直接的に C 言語の［
`fopen()^c, `fread()^c, `fclose()^c
］組みへ対応付けている）
<a href="https://nodejs.org/api/fs.html">Node.js file system API</a>
の各部を包装する，`可読~stream$を返す。
~fileは `~pull源$の典型~例である。
`~push源$を伴う例とは対照的に、ここでの働きの大部分は、
`start()^c 関数の開始時ではなく，
`pull()^c 関数~内でその時々に起きることに注意。
◎
The following function returns readable streams that wrap portions of the Node.js file system API (which themselves map fairly directly to C’s fopen, fread, and fclose trio). Files are a typical example of pull sources. Note how in contrast to the examples with push sources, most of the work here happens on-demand in the pull function, and not at startup time in the start function.
</p>

<pre class="lang-javascript">
const %fs = require(`pr/fs^l); // https://github.com/jden/pr
const %CHUNK_SIZE = 1024;

function makeReadableFileStream(filename) {
  let %fd;
  let %position = 0;

  return new ReadableStream({
    start() {
      return %fs
      .open(%filename, `r^l)
      .then(%result =&gt; {
        %fd = %result;
      });
    },

    pull(%controller) {
      const %buffer = new ArrayBuffer(%CHUNK_SIZE);

      return %fs
        .read(%fd, %buffer, 0, %CHUNK_SIZE, %position)
        .then(%bytesRead =&gt; {
        if (%bytesRead === 0) {
          return %fs.close(%fd).then(() =&gt; %controller.close());
        } else {
          %position += %bytesRead;
          %controller.enqueue(new Uint8Array(%buffer, 0, %bytesRead));
        }
      });
    },

    cancel() {
      return %fs.close(%fd);
    }
  });
}
</pre>

<p>
これを利用すれば、前に~socketに対しできたときとちょうど~~同じく，~fileに対する可読~streamを作成して利用できるようになる。
◎
We can then create and use readable streams for files just as we could before for sockets.
</p>

		</section>
		<section id="example-rbs-pull">
<h3 title="A readable byte stream with an underlying pull source">8.5. 下層~pull源を伴う 可読~byte~stream</h3>

<p>
次の関数は、
<a href="https://nodejs.org/api/fs.html">Node.js file system API</a>
を再び利用して，~fileを複製することなく効率的に読取できるようにする，`可読~byte~stream$を返す。
それは、予め決定済みの~chunk~size 1024 を利用する代わりに，開発者から給された~bufferを埋めようと試みることで、全部的な制御を可能にする。
◎
The following function returns readable byte streams that allow efficient zero-copy reading of files, again using the Node.js file system API. Instead of using a predetermined chunk size of 1024, it attempts to fill the developer-supplied buffer, allowing full control.
</p>

<pre class="lang-javascript">
const %fs = require(`pr/fs^l); // https://github.com/jden/pr
const DEFAULT_CHUNK_SIZE = 1024;

function makeReadableByteFileStream(%filename) {
  let %fd;
  let %position = 0;

  return new ReadableStream({
    type: `bytes^l,

    start() {
      return %fs.open(%filename, `r^l).then(%result =&gt; {
        %fd = %result;
      });
    },

    pull(%controller) {
      /* <span class="leaf comment">
消費器が既定の読取器を利用していても，自動割当て特色機能は、~bufferを割当てて，それを `byobRequest^c を介して渡してくれる。
◎
Even when the consumer is using the default reader, the auto-allocation feature allocates a buffer and passes it to us via byobRequest.
</span> */
      const %v = %controller.byobRequest.view;

      return %fs
      .read(%fd, %v.buffer, %v.byteOffset, %v.byteLength, %position)
      .then(%bytesRead =&gt; {
        if (%bytesRead === 0) {
          return %fs.close(%fd).then(() =&gt; %controller.close());
        } else {
          %position += %bytesRead;
          %controller.byobRequest.respond(%bytesRead);
        }
      });
    },

    cancel() {
      return %fs.close(%fd);
    },

    autoAllocateChunkSize: DEFAULT_CHUNK_SIZE
  });
}

</pre>

<p>
これを使えば、返された `ReadableStream$C に対する`~BYOB読取器$を作成して利用できるようになる。
一方で、それを［
通例的~なものと同じ，単純かつ汎用的な方式
］で利用して，`既定の読取器$を作成することもできる。
［
低levelの，ここに示す`下層~byte源$に対する~byteの追跡
］と［
高levelの，~chunkに基づく`既定の読取器$による消費
］との間の適応は、すべて，~stream実装により自動的に~careされる。
`autoAllocateChunkSize^c ~optionを介する自動割当て特色機能は、［
<a href="#example-rbs-push">§ 下層~push源と背圧~supportを伴う可読~byte~stream（背圧~supportなし）</a>
のように手動的に分岐する
］のに比して，必要な~code量も少なく済ませられる。
◎
With this in hand, we can create and use BYOB readers for the returned ReadableStream. But we can also create default readers, using them in the same simple and generic manner as usual. The adaptation between the low-level byte tracking of the underlying byte source shown here, and the higher-level chunk-based consumption of a default reader, is all taken care of automatically by the streams implementation. The auto-allocation feature, via the autoAllocateChunkSize option, even allows us to write less code, compared to the manual branching in §8.3 A readable byte stream with an underlying push source (no backpressure support).
</p>



		</section>
		<section id="example-ws-no-backpressure">
<h3 title="A writable stream with no backpressure or success signals">8.6. 背圧や成功 合図を伴わない 可書~stream</h3>


<p>
次の関数は、 `WebSocket$I `HTML$r を包装する`可書~stream$を返す。
~web~socketは［
所与の~dataの`~chunk$が いつ成功裡に送信されたか
］を伝える仕方を提供しない（扱いにくい `bufferedAmount$c の~pollingを行わない限り
— それについては，読者への演習に残しておく）。
そのようなわけで、この可書~streamは，その`生産器$に［
正確0な背圧~合図や 書込の成功／失敗
］を通信する能を持たない。
すなわち、その`書込器$の
`write()$dw ~method ／ `ready$dw 取得子
から返される~promiseは、常に即時に充足されることになる。
◎
The following function returns a writable stream that wraps a WebSocket [HTML]. Web sockets do not provide any way to tell when a given chunk of data has been successfully sent (without awkward polling of bufferedAmount, which we leave as an exercise to the reader). As such, this writable stream has no ability to communicate accurate backpressure signals or write success/failure to its producers. That is, the promises returned by its writer’s write() method and ready getter will always fulfill immediately.
</p>

<pre class="lang-javascript">
function makeWritableWebSocketStream(%url, %protocols) {
  const %ws = new WebSocket(%url, %protocols);

  return new WritableStream({
    start(%controller) {
      %ws.onerror = () =&gt; {
          %controller.error(new Error("WebSocket に~errorが生じました"));
      }
      return new Promise(%resolve => %ws.onopen = %resolve);
    },

    write(%chunk) {
      %ws.send(%chunk);
/* <span class="comment">
即時に返る
— ~web~socketでは，書込がいつ完了するかを伝える容易な仕方はないので。
◎
Return immediately, since the web socket gives us no easy way to tell when the write completes.
</span> */
    },

    close() {
      return new Promise((%resolve, %reject) =&gt; {
        %ws.onclose = %resolve;
        %ws.close(1000);
      });
    },

    abort(%reason) {
      return new Promise((%resolve, %reject) => {
        %ws.onclose = %resolve;
        %ws.close(4000, %reason && %reason.message);
      });
    }
  });
}
</pre>


<p>
この関数を利用すれば、~web~socketに対する可書~streamを作成して，任意の可読~streamをそれに~pipeできるようになる：
◎
We can then use this function to create writable streams for a web socket, and pipe an arbitrary readable stream to it:
</p>

<pre class="lang-javascript">
const %webSocketStream = makeWritableWebSocketStream(
    `wss://example.com:443/^l, `protocol^l);

readableStream.pipeTo(%webSocketStream)
  .then(() =&gt; console.log(`すべての~dataは成功裡に書込されました^l))
  .catch(%e =&gt; console.error(`何かまずいことが起きたようです^l, %e));
</pre>


		</section>
		<section id="example-ws-backpressure">
<h3 title="A writable stream with backpressure and success signals">8.7. 背圧や成功 合図を伴う 可書~stream</h3>

<p>
次の関数は、（それ自身 直接的に C 言語の［
`fopen^c, `fwrite^c, `fclose^c
］組みへ対応付けている）
<a href="https://nodejs.org/api/fs.html">Node.js file system API</a>
の各部を包装する，`可書~stream$を返す。
その~APIは、所与の書込が成功したときにそれを伝える仕方を提供するので、この~streamは，個々の書込が成功したか失敗したかも込みで，`背圧$合図を通信できる。
◎
The following function returns writable streams that wrap portions of the Node.js file system API (which themselves map fairly directly to C’s fopen, fwrite, and fclose trio). Since the API we are wrapping provides a way to tell when a given write succeeds, this stream will be able to communicate backpressure signals as well as whether an individual write succeeded or failed.
</p>

<pre class="lang-javascript">
const %fs = require(`pr/fs^l); // https://github.com/jden/pr

function makeWritableFileStream(%filename) {
  let %fd;

  return new WritableStream({
    start() {
      return %fs.open(%filename, `w^l).then(%result =&gt; {
        %fd = %result;
      });
    },

    write(%chunk) {
      return %fs.write(%fd, %chunk, 0, %chunk.length);
    },

    close() {
      return %fs.close(%fd);
    },

    abort() {
      return %fs.close(%fd);
    }
  });
}
</pre>

<p>
この関数を利用すれば、~fileに対する可書~streamを作成して，個々の~data`~chunk$を書込できるようになる：
◎
We can then use this function to create a writable stream for a file, and write individual chunks of data to it:
</p>

<pre class="lang-javascript">
const %fileStream = makeWritableFileStream(`/example/path/on/fs.txt^l);
const %writer = %fileStream.getWriter();

%writer.write(`~streamするか, しないか、\n^l);
%writer.write(`それが~~問題だ。\n^l);

%writer.close()
  .then( () =&gt; console.log(
      `~chunkたちは書込され, ~streamは成功裡に~closeされました^l
  ))
  .catch(%e =&gt; console.error(%e));
</pre>

<!-- 
"To stream, or not to stream\n"
"That is the question\n"
"chunks written and stream closed successfully!"
-->

<p>
ある~~特定の `fs.write^c ~callにて時間がかかる場合、返される~promiseは，~~後に充足されることになることに注意。
当面の間は，追加の書込を~queue-upできる
— それらは~streamの内部~queueに格納される。
この~queueにおける`~chunk$たちの累積により、~streamは， `ready$dw 取得子が処理待ち~promiseを返すように変化し得る
— それは、~streamの`生産器$に［
可能0なら手を止めて書込みを停止すべきである
］ことを合図する。
◎
Note that if a particular call to fs.write takes a longer time, the returned promise will fulfill later. In the meantime, additional writes can be queued up, which are stored in the stream’s internal queue. The accumulation of chunks in this queue can change the stream to return a pending promise from the ready getter, which is a signal to producers that they should back off and stop writing if possible.
</p>

<p>
この事例においては、可書~streamが書込を~queue-upする仕方が，とりわけ重要になる
—
<a href="https://nodejs.org/api/fs.html#fs_fs_write_fd_data_position_encoding_callback">`fs.write^c にて文書化されている</a>
ように：
<q>
[promise] を待機することなく，同じ~file上で
`fs.write^c を複数回 利用することは安全でない</q>
ので。
しかしながら、 `makeWritableFileStream^c 関数を書くときは，それについて心配する必要はない
— ~stream実装が，［
`下層~槽$の `write()^c ~methodは，［
以前の~callにより返された~promiseがあれば，それが充足される
］まで~callされない
］ことを保証してくれる。
◎
The way in which the writable stream queues up writes is especially important in this case, since as stated in the documentation for fs.write, "it is unsafe to use fs.write multiple times on the same file without waiting for the [promise]." But we don’t have to worry about that when writing the makeWritableFileStream function, since the stream implementation guarantees that the underlying sink’s write method will not be called until any promises returned by previous calls have fulfilled!
</p>

		</section>
		<section id="example-both">
<h3 title="A { readable, writable } stream pair wrapping the same underlying resource">8.8.  同じ下層~資源を包装する { 可読, 可書 } ~stream~pair</h3>

<p>
次の関数は
`{ readable, writable }^c
の形による~objを返す
—
`readable^c ~propは可読~streamを,
`writable^c ~propは可書~streamを包含していて、両~streamとも同じ下層~web~socket資源を包装するような。
これは、本質的には，［
<a href="#example-rs-push-no-backpressure"
>下層の~push源を伴う可読~stream（背圧~supportなし）</a>
］と［
<a href="#example-ws-no-backpressure"
>背圧や成功~合図を伴わない可書~stream</a>
］を組合せる。
◎
The following function returns an object of the form { readable, writable }, with the readable property containing a readable stream and the writable property containing a writable stream, where both streams wrap the same underlying web socket resource. In essence, this combines §8.1 A readable stream with an underlying push source (no backpressure support) and §8.6 A writable stream with no backpressure or success signals.
</p>

<p>
~JS~classを利用して、再利用~可能な
`下層~槽$／`下層~源$
の抽象化を作成する方法を~~示す：
◎
While doing so, it illustrates how you can use JavaScript classes to create reusable underlying sink and underlying source abstractions.
</p>

<pre class="lang-javascript">
function streamifyWebSocket(%url, %protocol) {
  const %ws = new WebSocket(%url, %protocols);
  %ws.binaryType = `arraybuffer^l;

  return {
    readable: new ReadableStream(new WebSocketSource(%ws)),
    writable: new WritableStream(new WebSocketSink(%ws))
  };
}

class WebSocketSource {
  constructor(%ws) {
    this._ws = %ws;
  }

  start(controller) {
    this._ws.onmessage =
        %event =&gt; controller.enqueue(%event.data);
    this._ws.onclose =
        () =&gt; %controller.close();

    this._ws.addEventListener(`error^l, () =&gt; {
      %controller.error(new Error(`WebSocket に~errorが生じました^l));
    });
  }

  cancel() {
    this._ws.close();
  }
}

class WebSocketSink {
  constructor(%ws) {
    this._ws = %ws;
  }

  start(%controller) {
    this._ws.addEventListener(`error^l, () =&gt; {
      %controller.error(new Error(`WebSocket に~errorが生じました^l));
    });

    return new Promise(%resolve =&gt; this._ws.onopen = %resolve);
  }

  write(%chunk) {
    this._ws.send(%chunk);
  }

  close() {
    return new Promise((%resolve, %reject) =&gt; {
      this._ws.onclose = %resolve;
      this._ws.close();
    });
  }

  abort(%reason) {
    return new Promise((%resolve, %reject) => {
      %ws.onclose = %resolve;
      %ws.close(4000, %reason && %reason.message);
    });
  }
}
</pre>

<p>
この関数で作成された~objを利用すれば、標準~stream~APIを利用して，遠隔の~web~socketと通信できるようになる：
◎
We can then use the objects created by this function to communicate with a remote web socket, using the standard stream APIs:
</p>

<pre class="lang-javascript">
const %streamyWS =
    streamifyWebSocket(`wss://example.com:443/^l, `protocol^l);
const %writer = %streamyWS.writable.getWriter();
const %reader = %streamyWS.readable.getReader();

%writer.write(`どうも、^l);
%writer.write(`web socket さん。^l);

%reader.read().then(({ %value, %done }) =&gt; {
  console.log(`こちらこそ、どうもです：^l, %value);
});
</pre>

<!-- 
"Hello"
"web socket"
"The web socket says: "
-->

<p>
このように設定しておけば、［
`readable^c 側を取消すと，暗黙的に `writable^c 側が~closeされ
］，同様に［
`writable^c 側を~closeする／中止すると，暗黙的に `readable^c 側が~closeされる
］ようになることに注意。
◎
Note how in this setup canceling the readable side will implicitly close the writable side, and similarly, closing or aborting the writable side will implicitly close the readable side.
</p>



		</section>
	</section>
	<section id="conventions">
<h2 title="Conventions">表記規約</h2>

<p>
この仕様は `ECMASCRIPT$r によるものにごく近い~algo規約を利用するが、簡潔にするため，その多くに対し，以下の仕方による別版を用いている。
最終的には、 ECMAScript 自身の規約が，これらの仕方で発展するものと希望されている（また，漠然と計画されている）。
◎
This specification uses algorithm conventions very similar to those of [ECMASCRIPT]. However, it deviates in the following ways, mostly for brevity. It is hoped (and vaguely planned) that eventually the conventions of ECMAScript itself will evolve in these ways.
</p>


<ul>
	<li>
関数／~method
の宣言には、分割代入【？】（  destructuring ）記法が利用される
— そこでは、~algoの開始~~前に
分割代入の手順（ destructuring assignment procedure ）が遂行されるものと見做される。
◎
We use destructuring notation in function and method declarations, and assume that the destructuring assignment procedure was performed before the algorithm starts.
</li>
	<li>
同様に、いくつかの事例においては，既定の引数の記法として
`= {}^c
が利用される。
◎
We similarly use the default argument notation = {} in a couple of cases.
</li>
	<li>
"~this" は "~this 値" の略記である。
◎
We use "this" instead of "this value".
</li>
	<li>
<p>
ECMAScript 仕様より高levelで~promise上に演算するときに
`PROMISES-GUIDE$r
による各種 略記~句を利用する：
</p>
		<dl class="def-list">
<dt id="_p-a-new-promise"
	><a href="~PROMISES#a-new-promise">新たな~promise</a></dt>
<dt id="_p-a-promise-resolved-with"
	>〜で<a href="~PROMISES#a-promise-resolved-with">解決された~promise</a></dt>
<dt id="_p-a-promise-rejected-with"
	>〜で<a href="~PROMISES#a-promise-rejected-with">却下された~promise</a></dt>
<dt id="_p-resolve-promise"
	>〜で~promiseを<a href="~PROMISES#resolve-promise">解決する</a></dt>
<dt id="_p-reject-promise"
	>〜で~promiseを<a href="~PROMISES#reject-promise">却下する</a></dt>
<dt id="_p-transforming-by"
	>〜で~promiseを<a href="~PROMISES#transforming-by">変形-</a>する</dt>
<dt id="_p-upon-fulfillment"
	>~promiseの<a href="~PROMISES#upon-fulfillment">充足~時</a>には…</dt>
<dt id="_p-upon-rejection"
	>~promiseの<a href="~PROMISES#upon-rejection">却下~時</a>には…</dt>
<!-- 
<dt id="_p-resolved-as-a-promise"
	>〜を<a href="~PROMISES#resolved-as-a-promise">~promiseとして解決-</a>する</dt>
<dt id="_p-waiting-for-all"
	><a href="~PROMISES#waiting-for-all">すべてを待機する</a></dt>
<dt id="_p-promise-calling"
	><a href="~PROMISES#promise-calling">~promise-calling</a></dt>
<dt id="_p-a-promise-resolved-with"><a href="~PROMISES#a-promise-resolved-with">解決済みの</a></dt>
<dt id="_p-promise-calling"><a href="~PROMISES#promise-calling">~promise-call</a></dt>
<dt id="_p-fulfillment-value"><a href="~PROMISES#fulfillment-value">充足~値</a></dt>
<dt id="_p-reason-value"><a href="~PROMISES#reason-value">事由~値</a></dt>

-->

<dd></dd>

		</dl>


◎
We use the shorthand phrases from the [PROMISES-GUIDE] to operate on promises at a higher level than the ECMAScript spec does.
</li>
	<li>
`ECMASCRIPT$r と同様，言うまでもなく、すべての数は 倍精度~浮動小数点による値で表現され，それらに対し遂行される すべての算術~演算は 標準の仕方で行われ~MUSTことに注意。
◎
It’s also worth noting that, as in [ECMASCRIPT], all numbers are represented as double-precision floating point values, and all arithmetic operations performed on them must be done in the standard way for such values.
</li>
	<li>
以下の各種 抽象~演算は、`ECMASCRIPT$r 仕様にて定義される：

<dl class="def-list"
	><dt id="call"
	>`Call$Ax
</dt><dt id="construct"
	>`Construct$Ax
</dt><dt id="create-array-from-list"
	>`CreateArrayFromList$Ax
</dt><dt id="create-data-property"
	>`CreateDataProperty$Ax
</dt><dt id="create-iter-result-object"
	>`CreateIterResultObject$Ax
</dt><dt id="get"
	>`Get$Ax
</dt><dt id="get-v"
	>`GetV$Ax
</dt><dt id="invoke"
	>`Invoke$Ax
</dt><dt id="is-callable"
	>`IsCallable$Ax
</dt><dt id="is-integer"
	>`IsInteger$Ax
</dt><dt id="is-property-key"
	>`IsPropertyKey$Ax
</dt><dt id="object-create"
	>`ObjectCreate$Ax
</dt><dt id="return-if-abrupt"
	>`ReturnIfAbrupt$Ax
</dt><dt id="to-boolean"
	>`ToBoolean$Ax
</dt><dt id="to-number"
	>`ToNumber$Ax
</dt><dt id="to-string"
	>`ToString$Ax
</dt><dt id="type"
	>`Type$Ax
</dt><dt id="copy-data-block-bytes"
	>`CopyDataBlockBytes$Ax
</dt><dt id="clone-array-buffer"
	>`CloneArrayBuffer$Ax
</dt>
			<dd></dd>
		</dl>
	</li>
</ul>

<p class="trans-note">【
以下の表記／用語も、 ECMAScript 仕様に定義される（訳者による補完）。
】</p>

<ul>
	<li>
“~Assert： …”
は、いわゆる表明を表す。
（要約：）
暗黙的な不変則を明示的に示して ~algoの明確化を図るものであり、~algoの意味論に要件を追加するものではない。
</li>
	<li>
`中途完了@ （
<a href="~TC39#sec-completion-record-specification-type">abrupt completion</a>
）
— （引用）
中途完了とは、演算の完了に伴われる [[type]] 値が normal 以外であることを意味する。
</li>
	<li>
<p>
抽象~演算の前に置かれる記号 "!", "?" の意味は、
<a href="~TC39#sec-algorithm-conventions">~algo表記規約</a>
に定義されている。
大雑把に述べれば：
</p>
		<ul>
			<li>
"! `AbstractOp^A(…)"
という表記は、そこでの `AbstractOp^A の~callは決して`中途完了$にならないことを表す。
</li>
			<li>
"? `AbstractOp^A(…)"
という表記は、`中途完了$になり得るため，例外が投出され得ることを表す。
</li>
		</ul>
	</li>
	<li>
<p>
`~List@,
`~Record@
型は、
<a href="~TC39#sec-list-and-record-specification-type">The List and Record Specification Types</a>
（ “仕様が規定する~modelにのみ~~存在する型” ）に定義されている：
</p>
		<ul>
			<li>
`~List$ は、順序~付けられた値たちからなる~listを表す。
</li>
			<li>
"« %A, %B, … »"
のような表記は、~literalによる`~List$の初期化を表す。
</li>
			<li>
`~Record$ は、名前を持ついくつかの~fieldからなる順序のない集合（すなわち， ~map ）を表す。
</li>
			<li>
"`~Record$ { … }"
のような表記は、~literalによる `~Record$ の初期化を表す。
</li>
		</ul>
	</li>
	<li>
"<code>%args =&gt; %code</code>"
のような表記は、
%args を引数に %code を実行する無名~関数を表す（
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/arrow_functions">arrow function</a>
）。
</li>
	<li>
`class^c
— <a href="~TC39#sec-class-definitions">Class Definitions</a>
</li>
</ul>


	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様に寄与された次の方々に感謝する：
</p>

<div>
The editor would like to thank

Adam Rice,
Anne van Kesteren,
Ben Kelly,
Brian di Palma,
Calvin Metcalf,
Dominic Tarr,
Ed Hager,
Forbes Lindesay,
贺师俊 (hax),
isonmad,
Jake Archibald,
Jens Nockert,
Mangala Sadhu Sangeet Singh Khalsa,
Marcos Caceres,
Marvin Hagemeister,
Michael Mior,
Mihai Potra,
Simon Menke,
Stephen Sugden,
Tab Atkins,
Tanguy Krotoff,
Thorsten Lorenz,
Till Schneidereit,
Tim Caswell,
Trevor Norris,
tzik,
Youenn Fablet,
and Xabier Rodríguez

for their contributions to this specification.
</div>

<p>
次の方々に特別な謝意を：
API に重大な変更をもたらすような
<a href="~STREAMS/issues/253">実装における懸念事項</a>
を挙げられた， Bert Belder 氏，
初期の基準~実装の~~仕事をされた Forrest Norvell 氏，
~pipeの~~仕方を二つの~methodに分け,
<a href="~STREAMS/issues/44">a major sticking point</a>
の解決に繋がる打開策を示された Gorgi Kosev 氏，
Node.js において先駆的な~JS~streamの~~仕事をされた Isaac Schlueter 氏，
早期から~~関与し, サポートされた Jake Verbaten 氏，
ロゴマークを提供された Janessa Det 氏，
API に高性能な~network~streamingも可能にすることに助力された Will Chan 氏，
可読~読取器の設計に助力された平野裕（ Yutaka Hirano ）氏。
◎
Special thanks to:

Bert Belder for bringing up implementation concerns that led to crucial API changes;
Forrest Norvell for his work on the initial reference implementation;
Gorgi Kosev for his breakthrough idea of separating piping into two methods, thus resolving a major sticking point;
Isaac Schlueter for his pioneering work on JavaScript streams in Node.js;
Jake Verbaten for his early involvement and support;
Janessa Det for the logo;
Will Chan for his help ensuring that the API allows high-performance network streaming;
and 平野裕 (Yutaka Hirano) for his help with the readable stream reader design.
</p>

<p>
This standard is written by <a href="https://domenic.me/">Domenic Denicola</a> (<a href="https://google.com">Google</a>,
<a href="mailto:d@domenic.me">d@domenic.me</a>)
and
吉野剛史 (Takeshi Yoshino, <a href="https://google.com">Google</a>,
<a href="mailto:tyoshino@chromium.org">tyoshino@chromium.org</a>).
</p>

<p>
Per
<a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>,
to the extent possible under law, the editor has waived all copyright and related or neighboring rights to this work.
</p>

	</section>

</main></div><!-- MAIN -->


	<section id="index">
<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>

	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範的）</h3>

<script type="text/plain" class="ref_data">

[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[PROMISES-GUIDE]
    Domenic Denicola. Writing Promise-Using Specifications. 16 February 2016. Finding of the W3C TAG. URL: https://www.w3.org/2001/tag/doc/promises-guide 

</script>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<script type="text/plain" class="ref_data">
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[SERVICE-WORKERS]
    Alex Russell; et al. Service Workers 1. URL: https://w3c.github.io/ServiceWorker/ 
</script>

		</section>
	</section>
