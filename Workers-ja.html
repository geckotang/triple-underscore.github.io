<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Web Workers （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';

COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/workers.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'workers',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170223 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		E: 'error',
		et: 'event-type',
		sc: 'scheme',
		h: 'header',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		hd: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		h: 'code',
		sc: 'code',
		et: 'code',
		E: 'code',
		V: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|%[\w~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
//	switch(match){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		if(match[1]){
			in_idl = true;
			nesting += '</pre>';
			return '<pre class="idl">';
		} else {
			nesting += '</span>';
			return '：<span class="block">';
		}
	case '⇒！':
	}//◎
	if(in_idl) {
		result = nesting;
		in_idl = false;
	} else {
		result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	}
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	href = '#' + key.toLowerCase();
	if(in_idl) tag = '';
	break;
case 'hd': // event handler
	if(in_idl) tag = '';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	if(in_idl) tag = '';
	break;
case 'sc': // url scheme
	text += ':';
	break;
case 'et': // event type
	href = '~HTMLindex#event-' + key;
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_original_id_map">
</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">

	●IDL
I.AbstractWorker:#abstractworker
I.DedicatedWorkerGlobalScope:#dedicatedworkerglobalscope
I.SharedWorker:#sharedworker
I.SharedWorkerGlobalScope:#sharedworkerglobalscope
I.Worker:#worker
I.WorkerOptions:#workeroptions
I.WorkerType:#workertype
I.RequestCredentials:~FETCH#requestcredentials
I.WorkerGlobalScope:#workerglobalscope
I.WorkerLocation:#workerlocation
I.WorkerNavigator:#workernavigator
I.Window:~BROWSERS#window
I.Event:~DOM4#event
I.EventTarget:~DOM4#interface-eventtarget
I.EventHandler:~WAPI#eventhandler
I.ErrorEvent:~WAPI#errorevent
I.OnErrorEventHandler:~WAPI#onerroreventhandler
I.object:~WEBIDL#idl-object
I.ServiceWorkerContainer:~SW#serviceworkercontainer

I.NavigatorID:~HTMLnavigator#navigatorid
I.NavigatorLanguage:~HTMLnavigator#navigatorlanguage
I.NavigatorOnLine:~HTML5/browsers.html#navigatoronline
I.NavigatorConcurrentHardware:#navigatorconcurrenthardware
I.URLUtilsReadOnly:~URLSpec#urlutilsreadonly
I.MessagePort:~HTMLcomms#messageport
I.MessageEvent:~HTMLcomms#messageevent
I.Document:~HTMLdom#document


I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
	E.NetworkError:~WEBIDL#networkerror
	E.SecurityError:~WEBIDL#securityerror
	E.SyntaxError:~WEBIDL#js-syntaxerror
	E.SyntaxError:~WEBIDL#syntaxerror
	E.URLMismatchError:~WEBIDL#urlmismatcherror

	●IDL members
		■WorkerGlobalScope
m.self:#dom-workerglobalscope-self
m.location:#dom-workerglobalscope-location
m.navigator:#dom-worker-navigator
m.importScripts:#dom-workerglobalscope-importScripts
hd.onerror:#handler-workerglobalscope-onerror
hd.onlanguagechange:#handler-workerglobalscope-onlanguagechange
hd.onoffline:#handler-workerglobalscope-onoffline
hd.ononline:#handler-workerglobalscope-ononline
hd.onrejectionhandled:#handler-workerglobalscope-onrejectionhandled
hd.onunhandledrejection:#handler-workerglobalscope-onunhandledrejection

		■DedicatedWorkerGlobalScope
m.~postMessage0:#dom-dedicatedworkerglobalscope-postmessage
m.~close0:#dom-dedicatedworkerglobalscope-close
hd.~onmessage0:#handler-dedicatedworkerglobalscope-onmessage

		■SharedWorkerGlobalScope
m.name:#dom-sharedworkerglobalscope-name
m.close:#dom-sharedworkerglobalscope-close
hd.onconnect:#handler-sharedworkerglobalscope-onconnect

		■AbstractWorker
hd.~onerror0:#handler-abstractworker-onerror
		■Worker
m.Worker:#dom-worker
m.terminate:#dom-worker-terminate
m.postMessage:#dom-worker-postmessage
hd.onmessage:#dom-worker-onmessage

		■SharedWorker
m.SharedWorker:#dom-sharedworker
m.port:#dom-sharedworker-port

		■WorkerLocation
m.href:#dom-workerlocation-href
m.origin:#dom-workerlocation-origin
m.protocol:#dom-workerlocation-protocol
m.host:#dom-workerlocation-host
m.hostname:#dom-workerlocation-hostname
m.~port0:#dom-workerlocation-port
m.pathname:#dom-workerlocation-pathname
m.search:#dom-workerlocation-search
m.hash:#dom-workerlocation-hash

		■NavigatorConcurrentHardware
m.hardwareConcurrency:#dom-navigator-hardwareconcurrency

		■外部
m.addEventListener:~DOM4#dom-eventtarget-addeventlistener
m.cancelable:~DOM4#dom-event-cancelable

m.start:~HTMLcomms#dom-messageport-start
m.source:~HTMLcomms#dom-messageevent-source
m.ports:~HTMLcomms#dom-messageevent-ports
m.data:~HTMLcomms#dom-messageevent-data

m.message:~WAPI#dom-errorevent-message
m.filename:~WAPI#dom-errorevent-filename
m.lineno:~WAPI#dom-errorevent-lineno
m.colno:~WAPI#dom-errorevent-colno
m.error:~WAPI#dom-errorevent-error


	et.XXX:~HTMLindex#event-XXX
	languagechange
	message
	offline
	online
	error
	rejectionhandled
	unhandledrejection
et.connect:~HTMLindex#event-workerglobalscope-connect

sc.blob:https://w3c.github.io/FileAPI/#DefinitionOfScheme
sc.data:~IETF/rfc2397#section-2
sc.http:~RFC7230#section-2.7.1
sc.https:~RFC7230#section-2.7.2

e.iframe:~HEembed#the-iframe-element
e.script:~HEscripting#the-script-element

文書:#_document
~eventloop:#_event-loop
暗黙的な~port:#_scope-implicit-port
1.暗黙的な~port:#_worker-implicit-port
V.url:#_location-url

文書~list:#the-worker's-documents
	'
文書~listに追加-:#add-a-document-to-the-worker's-documents
	'
~port~list:#the-worker's-ports
	'
~worker~list:#the-worker's-workers
	'

~workerを強制終了する:#kill-a-worker
~workerを終了させる:#terminate-a-worker
~workerを走らす:#run-a-worker
~workerを~close:#close-a-worker
休止可能:#suspendable-worker
許可対象:#permissible-worker
専用~worker:#dedicatedworkerglobalscope
追加する関連の文書:#list-of-relevant-document-objects-to-add
保護下:#protected-worker
作動中必要:#active-needed-worker
~workerの環境~設定群~objを設定して:#set-up-a-worker-environment-settings-object
公式的な作成~時点:#official-moment-of-creation
i.~closing~flag:#dom-workerglobalscope-closing

~scriptを~worker大域~scopeの中に取込む:#import-scripts-into-worker-global-scope

wG.構築子~生成元:#concept-sharedworkerglobalscope-constructor-origin
wG.構築子~url:#concept-sharedworkerglobalscope-constructor-url
wG.名前:#concept-sharedworkerglobalscope-name
wG.~url:#concept-workerglobalscope-url
wG.種別:#concept-workerglobalscope-type
wG.~HTTPS状態:#concept-workerglobalscope-https-state
wG.~referrer施策:#concept-workerglobalscope-referrer-policy
wG.~CSP~list:#concept-workerglobalscope-csp-list
wG.~module~map:#concept-workerglobalscope-module-map

~worker大域~scope:#concept-workerlocation-workerglobalscope

	●DOM, HTML
文脈~obj:~DOM4#context-object
~eventを発火-:~DOM4#concept-event-fire


同じ名前の~method:~HTMLcomms#dom-messageport-postmessage

	● webappapis.html
非同期に完了-:~WAPI#_asynchronously-complete
~event~handler:~WAPI#event-handlers
~event~handler IDL 属性:~WAPI#event-handler-idl-attributes
~event~handler ~event型:~WAPI#event-handler-event-type
x.~eventloop:~WAPI#event-loop
~module~map:~WAPI#module-map
~errorを報告-:~WAPI#report-the-error
~script:~WAPI#concept-script
~classic~script:~WAPI#classic-script
~module~script:~WAPI#module-script
~worker用~classic~scriptを~fetchする:~WAPI#fetch-a-classic-worker-script
~worker用~module~script~graphを~fetchする:~WAPI#fetch-a-module-worker-script-tree
~workerが~importする~classic~scriptを~fetch:~WAPI#fetch-a-classic-worker-imported-script

~classic~scriptを作成-:~WAPI#creating-a-classic-script
~classic~scriptを走らす:~WAPI#run-a-classic-script
~module~scriptを走らす:~WAPI#run-a-module-script
~scriptを作成-:~WAPI#create-a-script
~realm実行~環境:~WAPI#realm-execution-environment
~task源:~WAPI#task-source
~task:~WAPI#concept-task
待入し:~WAPI#queue-a-task
~taskを待入する:~WAPI#queue-a-task
~task待行列:~WAPI#task-queue
~DOM操作~task源:~WAPI#dom-manipulation-task-source
大域~obj:~WAPI#global-object
の大域~obj:~WAPI#concept-settings-object-global
1.大域~obj:~WAPI#concept-realm-global

enV.~id:~WAPI#concept-environment-id
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
enV.作動中の~sw:~WAPI#concept-environment-active-service-worker
enV.~HTTPS状態:~WAPI#https-state
enV.担当の文書:~WAPI#responsible-document
enV.担当の~eventloop:~WAPI#responsible-event-loop
enV.担当の閲覧文脈:~WAPI#responsible-browsing-context
enV.生成元:~WAPI#concept-settings-object-origin
enV.~module~map:~WAPI#concept-settings-object-module-map
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.~API~URL文字~符号化方式:~WAPI#api-url-character-encoding
enV.~API基底~URL:~WAPI#api-base-url


未取扱い:~WAPI#concept-error-nothandled
現在の設定群~obj:~WAPI#current-settings-object
設定群~obj:~WAPI#settings-object
関連する設定群~obj:~WAPI#relevant-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
尚早に中止され:~WAPI#abort-a-running-script
走っている~scriptを中止-:~WAPI#abort-a-running-script
~fetchを遂行する:~WAPI#fetching-scripts-perform-fetch
V.~top-level内~flag:~WAPI#fetching-scripts-is-top-level
実行~準備済み~flag:~WAPI#concept-environment-execution-ready-flag


作動中の~timerの~list:~HTMLGAPI#list-of-active-timers

	● browsers.html
全部的に作動中:~BROWSERS#fully-active
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
閲覧文脈:~BROWSERS#browsing-context
互いに関係するかつ生成元も類似する閲覧文脈~群:~BROWSERS#unit-of-related-similar-origin-browsing-contexts
生成元:~BROWSERS#concept-origin
不透明な生成元:~BROWSERS#concept-origin-opaque
破棄-:~BROWSERS#discard-a-document
同一生成元:~BROWSERS#same-origin
Unicode 直列化:~BROWSERS#unicode-serialisation-of-an-origin

~app-cache関連:~NAVI#offline
	~NAVI#_for-app-cache

	● comms.html
連絡:~HTMLcomms#entangle
~port~message待行列:~HTMLcomms#port-message-queue
~message~channel:~HTMLcomms#channel-messaging
新たな~MessagePort~obj:~HTMLcomms#create-a-new-messageport-object
所有者:~HTMLcomms#concept-port-owner

	● infrastructure.html
並列的:~HTMLINFRA#in-parallel
相対的に構文解析-:~HTMLINFRA#parse-a-url
結果の~URL~record:~HTMLINFRA#resulting-url-record
結果の~URL文字列:~HTMLINFRA#resulting-url-string


完全に読込まれて:~HTMLsyntax#completely-loaded

	●URL
~URL:~URLSpec#concept-url
等しい:~URLSpec#concept-url-equals
url.~scheme:~URLSpec#concept-url-scheme
url.~host:~URLSpec#concept-url-host
url.~port:~URLSpec#concept-url-port
url.~path:~URLSpec#concept-url-path
url.~query:~URLSpec#concept-url-query
url.素片:~URLSpec#concept-url-fragment
url.生成元:~URLSpec#concept-url-origin
url.~cannot-be-a-base-URL~flag:~URLSpec#url-cannot-be-a-base-url-flag

input:~URLSpec#concept-urlutils-input

入力の設定:~URLSpec#concept-urlutils-set-the-input
基底~URLの取得:~URLSpec#concept-urlutils-get-the-base
整数として直列化-:~URLSpec#serialize-an-integer
~host直列化器:~URLSpec#concept-host-serializer
~URL直列化器:~URLSpec#concept-url-serializer


	●WebIDL
凍結~配列:~WEBIDL#dfn-frozen-array-type

	●Fetch
~fetch:~FETCH#concept-fetch
~CORS~protocol:~FETCH#http-cors-protocol
~HTTPS状態~値:~FETCH#concept-https-state-value
rq.予約済み~client:~FETCH#concept-request-reserved-client
応答を処理する:~FETCH#process-response
応答:~FETCH#concept-response
rs.~url:~FETCH#concept-response-url
rs.~HTTPS状態:~FETCH#concept-response-https-state

UTF-8:~ENCODING#utf-8

InitializeHostDefinedRealm():~TC39#sec-initializehostdefinedrealm
~JS実行~文脈:~TC39#sec-execution-contexts
~client~message待行列:~SW#dfn-client-message-queue
~sw~client:~SW#serviceworkercontainer-service-worker-client

設定群は保安的~文脈であるか？:~SECURE-CONTEXT#settings-object
~referrer施策:~REFERRER-POLICY#referrer-policy

</script>

<!--% 置換データ -->

<script type="text/plain" id="words_table1">
DEMO:https://html.spec.whatwg.org/demos/workers
	Document: <code>Document</code> 
MessagePort: <code>MessagePort</code> 

postMessage0:postMessage
onmessage0:onmessage
onerror0:onerror
port0:port
close0:close

</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">
此れ:<b>これ°</b>
	●fetch, url, encoding, network
url:
URL:
CORS:
HTTPS:
CSP:
protocol::::プロトコル
record::::レコード
JS:JavaScript
realm:
import:
scheme::::スキーム
port::::ポート
host::::ホスト
path::::パス
query::::クエリ
素片:fragment::~::フラグメント
close:
header::::ヘッダ
fetch:
	fetching
referrer::::リファラ
address::::アドレス
client::::クライアント
server::::サーバ
ok:
app-cache:application cache:::アプリキャッシュ
真偽値:boolean:~
module::::モジュール
text::::テキスト
行先:destination:~
非安全:unsafe:~
保安的:secure::~:セキュア
直列化:serialisation::~::シリアル化
直列化-:serialize::~::シリアライズ
直列化器:serializer::~::シリアライザ
資格証:credentials::資格証明情報::クレデンシャル
暗号用:cryptographic::~
nonce::::ナンス
応答-:respond::~::レスポンド
応答:response::~::レスポンス
要請:request::~::リクエスト
	解決-:resolve:~:::リゾルブ
解析済:parsed::解析済み::パース済み
構文解析-:parse::~::パース
成分:component:~
生成元:origin::~::オリジン
同一生成元:same origin::~::同一オリジン
非同一生成元:cross-origin::~::クロスオリジン
	similar-origin:
不透明:opaque::~
一意:unique:~
絶対:absolute::~
相対的:relative::~
予約済み:reserved:~
cannot-be-a-base-URL:::基底 URL 不可用
符号化方式:encoding::~::エンコーディング
復号-:decode::~::デコード
復号:decoding::~::デコード
	符号化:encode:~
非同期:asynchronous::~
page::::ページ
networking::::ネットワーク処理
network::::ネットワーク
binary::::バイナリ
資源:resource::~:リソース
redirect::::リダイレクト
link::::リンク

	●
closing:
timeout:
buffer::::バッファ
online::::オンライン
access::::アクセス
	user~interface::::ユーザインタフェース
click::::クリック
button::::ボタン
施策:policy::~:ポリシー
map::::マップ
core::::コア
multi::::マルチ
main::::メイン
mega-pixel:mega pixel:::メガピクセル
method::::メソッド
message::::メッセージ

mode::::モード
model::::モデル
library::::ライブラリ
list::::リスト
routine::::ルーチン
loop::::ループ
log::::ログ
data::::データ
database::::データベース
transaction::::トランザクション
tutorial::::チュートリアル
cost::::コスト
viewer::::ビューア
file::::ファイル
platform::::プラットフォーム
chat::::チャット
private::非公開
	非公開チャット:~private~chat
	公開チャット:~public~chat
public::公開

muted-errors:muted errors:error 情報黙秘:エラー情報黙秘
黙秘-:mute::~
黙秘error:muted error::error 黙秘:エラー黙秘
再投出error:rethrow error::error 再投出:エラー再投出

garbage::::ガーベジ
収集-:collect:~
収集:collection:~

	●
id:
target:
sw:service worker
field:
catch:
error::::エラー
instance::::インスタンス
	~instance化-:instantiate
member::::メンバ
interface::::インタフェース
obj:object:::オブジェクト
window::::ウィンドウ
strict:

event::::イベント
eventloop::::イベントループ
型:type::~
handler::::ハンドラ
listener::::リスナ
	待ち受ける:listen
loop::::ループ
発火:fire::~
例外:exception:~
配列:array:~
辞書:dictionary:::ディクショナリ
名前:name:~
同名:same name:~
取得子:getter:~
	取得-:get／obtain:~
空:empty:~
文字列:string:~
空文字列:empty string:~
型:type:~
値:value:~
関数:function:~
引数:argument:~
被呼出時:被 invoke 時:~
呼出-:invoke:呼び出
	呼出して／呼出され
呼出す:invoke する:呼び出す
返し:return し:~
返る:return する:~
返らな:return しな:~
返った:return した:~
返す:return する:~
返さ:return し:~
返され:return され:~
code::::コード
call:
callback:
構築子:constructor::~::コンストラクタ
検索:search:::~
読専:read only:読み取り専用
凍結:frozen::~

compile::::コンパイル
site::::サイト

support::::サポート
script::::スクリプト
classic::::クラシック
scope::::スコープ
thread::::スレッド


zero::::ゼロ
source::::ソース
源:source::~::ソース
timer::::タイマー
未終了の:outstanding:~
task::::タスク
channel::::チャンネル
top-level::::トップレベル
background::::バックグラウンド
閲覧:browsing::~
木:tree::~::ツリー
graph::::グラフ
flag::::フラグ
特有の:specific な:~
	ブロック:
内側:inside::~
外側:outside::~
外縁:outer:~
内縁:inner:~
	~policy決定:policy decision

worker:
subworker:::下位 worker
大域:global::~::グローバル
環境:environment::~
種別:type::~

接続ing:connecting::接続::コネクティング
接続:connection::~::コネクション
接続-:connect::~::コネクト
	非公開チャット:private chat:~
	公開チャット:public chat:~

設定群:settings::~
設定法:setting::~
設定-:set::~::セット
	設定しておく:set up した
設置:set up::~::セットアップ

担当の:responsible::~::レスポンシブル
連絡:entangle::~::エンタングル
不可分的:atomic::~::アトミック
待行列:queue::待ち行列::キュー
待入する:queue する::待ち行列に入れる::キューする
待入し:queue し::待ち行列に入れ::キューし

親:parent::~
並列的:parallel::~
走らす:run する:走らせる
走らせ:run し:~
走らさ:run さ:~
走って:run して:~
稼働時:runtime:~
実行-:execute:~
実行:execution:~
	実行文脈
準備済み:ready:~
強制終了:kill::~
終了-:terminate:~
連鎖:chain::~::チェイン
即時:immediate:~

入子の:nested:入れ子の:::ネストされた
新たな:new::~
環境設定:configuration:~:::コンフィグレーション
環境設定-:configure:~:::コンフィギュア
委譲:delegation:~

違反-:violate:~
閲覧文脈:browsing context::~
文脈:context::~

即応可能:responsive::~::レスポンシブ
	下位:sub:~

可視:visibe:~
可視性:visibility:~
画像:image:~:::イメージ

開始-:start:~
環境:environment:~
監視:monitoring:~
基底:base:~

活動:activities::~
動作:action::~::アクション
動作-:act::~::アクト
実際:actual:~
全部的:full:~:::フル
作動中:active::~::アクティブ
作動中の:active::~::アクティブ
作動中必要:active needed::作動中のため必要::アクティブのため必要
休止-:suspend::~::サスペンド
休止:suspending::~::サスペンディング
休止可能:suspendable::~::サスペンド可能
許可対象:permissible::~

共用:shared::~
共用is:is shared::共用？
共有-:share::~
専用:dedicated::~
言語:language::~
孤立:orphan:~
公開-:expose::~
有構造:structured::~
作成-:create:~
作成:creation:~
作成時の:creation:~
作成法:creation:~
作成元:creator:~
仕事:task::~::タスク
失敗-:fail:~

直通:direct:~
通知:notifications::~
受信-:receive::~
送信:send::~
返信:send back::~
返送:transfer back::~
通信-:communicate::~
通信:communication::~
通信ing:communicating::通信
転送-:transfer::~
転送:transferring::~
伝送-:transmit:~
初期:initial:~
初期化-:initialize:~
	initialize ／ unoptimized
所有-:own::~
所有者:owner::~

推移的:transitive:~

操作:manipulation:~
投出:throw::~
属性:attribute::~

	代入:assign:~
代理-:proxy:~
継承-:inherit::~
継承:inherited::~

中断-:interrupt:~
起動:launch:~
直接的:direct:~
直接:direct:~
成功裡:successful:~
存続期間:lifetime:~
待機-:wait:~
中止-:abort:~

破壊-:destroy::~
破棄-:discard::~
文書:document::~
文書s:documents::文書たち
保護下:protected::~
報告-:report:~
報告:reporting:~
関係する:related:~
追加-:add:~
隔離-:isolate:~

検証-:validate::~
後処理-:postprocess::~
取込む:import する::取り込む
取込み:import::取り込み


	●仕様
API:
custom::::カスタム
	~custom化:customization
hook::::フック
UA:user agent:UA
optional::::オプション
option::::オプション
app:application:::アプリ
algo:algorithm:::アルゴリズム
取扱い:handling:取り扱い
未取扱い:not handled:~
取扱う:handle する:取り扱う

仕様:spec:~
試行:attempt:~
手続き:steps:~
段:step:~
下位手続き:substeps:~
結付ける:associate する:結び付ける
結付けて:associate して:結び付けて
結付けら:associate さ:結び付けら
省略-:omit:~
作者:author:~
基盤:infrastructure:~:::インフラ
意味論:semantics:~:::セマンティクス
拡張:extension:~
拡張-:extend:~
共通:common:~
廃用:obsolete:~
確立-:establish:~
既定:default:~
既定の:default:~
適合性:conformance:~
特色機能:feature:~
要件:requirements:~
利用者:user:~:::ユーザ
暗黙的:implicit:~
明示的:explicit:~
意図-:intend:~
不能化-:disable:~
可能化-:enable:~
制限:limit:~
制約-:restrict:~
制約:restriction:~
原理:principle:~
相違:difference:~
依存-:depend:~
公式的な:official な:~
上書き:override:~
特定0の:particular:ある特定の
定義-:define:~
定義:definition:~
比較的:relative に:~
予期-:expect:~
一般:general:~
視野:scope:~
適用外:not applicable:~
基礎概念:fundamental concept:~
指定-:specify:~
管理:management:~
開発:development:~
開発者:developer:~
console::::コンソール
実装-:implement:~
実装者:implementor:~
実装固有:implementation-specific:~
可用:available:~
効率的:efficient:~
処理能:performance::~::パフォーマンス
記憶域:memory::~::メモリ
無視:ignore:~
許容:allow:~
不十分:insufficient:~
不適切:inappropriate:~
適切:appropriate:~
依存性:dependencies:~
尚早:premature:~
遂行-:perform:~
互換性:compatibility:~
独立:independent:~
独立の:independent:~
最適化-:optimize:~
決定0:decision:決定
実質的:effective:~
見做され:assume され:~
観測-:observe:~
序論:introduction:~
能:ability:~
自動的:automatic:~
影響-:affect:~
解釈-:interpret:~
単純:simple:~

	●未分類
DOM:
UI:user interface:UI
hardware::::ハードウェア
filter::::フィルタ
clone:::::クローン
process:::プロセス
demo:::デモ
文:statement:~
宣言:declaration:~
拡充-:populate:~
	整数
計時:timing:~
所与の:与えられた
検査:check:~
文字:character:~
要素:element:~
入力:input:~
正確:exact:~
表現-:represent:~
識別-:identify:~
識別:identity:~
除去-:remove:~
参照:reference:~
処理待ち:pending:~
処理-:process:~
処理:processing:~
演算:operation:~
抽象演算:abstract operation:~
指紋収集:fingerprinting::~
能力:capabilities:~
論理CPU:logical processor:~
協調:coordination:~
協同-:collaborate:~
同時的:concurrent:~
素数:prime number:~
入出力:I/O:~
	ページ作者:author:~
衝突-:collide:~
状態:state:~
status:
阻止-:block:~
伝播-:propagate:~
探索:search:~
単位:unit:~
続行:continue:~
現在:currently:~
現在の:current:~
表示:display:~
関連の:relevant:~
関連する:relevant な:~
単独の:single:~
切替えら:switch さ:切り替えら
	重い:heavy-weight な:~
開始時:start-up 時:~
素朴:naïve:~
更新:update:~
外部:external:~
漸進的:progressive:~
情報:information:~
証券code:symbol:証券コード
生存-:survive:~
読込まれ:load され::読込まれ::ロードされ
遷移-:navigate::~::ナビゲート
再始動:restarting:~
繰返-:repeat:~
繋がろ:contact しよ:~
番号:number:~
登録-:register:~
登録:registration:~
完全:complete:~
完了-:complete:~
迂回-:bypass:~
比較-:compare:~
第一:first:~
第二:second:~
保持-:hold:~
告知-:announce:~
対話:interaction:~
便益:benefit:~
grayscale::::グレイスケール
輝度:luminance:~
</script>

<!--%他の語

通例的な:usual
良い~~選択~better~choice
汚-:polluting
~main~threadの外でoff-main-thread

長期:long 1
ここでの名称:called herein 1
多数の同時利用:used in large numbers
画素:pixel:~
長時間居残:long-lived 1
後続:following 1
数値計算:number-crunching 1
生成:
最新:recent 1
発見:found 1

定期的に:regular interval で
株式:stock:~
相場表示機:stock ticker:~
表示機:TICKER 1
監視対象:watch 1
検索器:SEARCHER 1
選択:SELECTION 1
初期設定:CONFIGURATION 1
消去:clear:~
一律:turn all 1
株式更新:stock updater 1

注記:note 1
通用:apply:~

興味を引く:interesting 1
起点: 1

実例:example 1
もう不要:no longer need
升目:tiles 1
注目すべき重要な点:key things worth noting 1
~~簡単:quick 1
付け加え:attach 1
幾人: 1
状況: 1
個別的: 1
他方:another 1
指名:naming 1
成立: 1
普及:becoming prevalent 1
分業:split 1
付番: 1
付番
範囲: 1
等分:farmed out 1
完成:finished 1
複雑:complex 1

唯一:only 1
何個: 1
分別: 1
対象: 1
大別:kinds of 1
以降: 1
~~既存:already on 1
等価なもの:equivalent construct 1
時点: 1
該当: 1
方法: 1
時間:time 1
位置:position 1
行~番号:line number:~
列~番号:column number:~
一段上層:one level up 1
上述: 1
現時点: 1
一時的に:shortly 1
通常:normal 1
順番: 1
取得先: 1
早期:prematurely 1
取得: 2
概説:introduce 2
注意: 2
変更:change 2
可能: 2
番号: 2
一方: 2
一部: 2
別々の:separate 2／diffrent
同様: 2
次第: 2

不可: 2
計算量の大きな:computationally expensive
計算:compute, calculation
項目:item, 3
必要: 3

最後: 3
~~解く:dis-entangle
外せる:unregister
目的:purpose 3
一致: 3
自身: 4
番目: 4
関係が深い:involved
関わらず:regardless of
一連: 5
以下: 5
最初: 6
存在: 6
次を与える下で: 6
全体: 6
複数: 8
対応: 8
規定: 10
	UA defined
結果:result 13
追加: 16
利用: 26
場合: 41

-->

<!--%style -->
<style type="text/css">
</style>

</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Standard — Web Workers 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Web Workers</a>
を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-02-24</time>
（公開：<time>2012-03-11</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

	<hgroup>
<h1>Web Workers</h1>
<h2>HTML Living Standard — 最終更新 2017 年 2 月 23 日</h2>
	</hgroup>

<main id="MAIN" style="display:none;">

<section id="workers">
<h1>10. Web Workers</h1>

	<section id="introduction-14">

<h2 title="Introduction">10.1. 序論</h2>

		<section id="scope-2">
<h3 title="Scope">10.1.1. 視野</h3>

~INFORMATIVE

<p>
この仕様は、他の~UI~scriptから独立に，~backgroundで~scriptを走らすための~APIを定義する。
◎
This specification defines an API for running scripts in the background independently of any user interface scripts.
</p>

<p>
これにより，~click他 利用者との対話に応答する~scriptから中断されることなく，長期に渡り~scriptを走らせて、~pageは即応可能に保ちながら，長い~taskを実行させられるようになる。
◎
This allows for long-running scripts that are not interrupted by scripts that respond to clicks or other user interactions, and allows long tasks to be executed without yielding to keep the page responsive.
</p>

<p>
~worker（これらの~background~scriptのここでの名称）は、比較的 重いので，多数の同時利用は意図されていない。
例えば、~mega-pixel画像の個々の画素に対し，別々の~workerを起動させることは不適切である。
下の例に~workerの適切な利用を示す：
◎
Workers (as these background scripts are called herein) are relatively heavy-weight, and are not intended to be used in large numbers. For example, it would be inappropriate to launch one worker for each pixel of a four megapixel image. The examples below show some appropriate uses of workers.
</p>

<p>
一般に，~workerは長時間居残り続け、開始時の処理能~cost, および ~instanceごとの記憶域~costは，高くつくものと予期されている。
◎
Generally, workers are expected to be long-lived, have a high start-up performance cost, and a high per-instance memory cost.
</p>

		</section>
		<section id="examples-6">

<h3 title="Examples">10.1.2. 例</h3>


~INFORMATIVE

<p>
~workerには様々な利用がある。
後続の下位節にて、この利用を示す。
◎
There are a variety of uses that workers can be put to. The following subsections show various examples of this use.
</p>

			<section id="a-background-number-crunching-worker">

<h4 title="A background number-crunching worker">10.1.2.1. ~backgroundで数値計算し続ける~worker</h4>


~INFORMATIVE

<p>
~workerの最も単純な利用は、~UIを中断せずに計算量の大きな仕事を遂行するものである。
◎
The simplest use of workers is for performing a computationally expensive task without interrupting the user interface.
</p>

<p>
この例では、~main文書が~workerを生成（ spawn ）して, （素朴な）素数の~~計算を行い, 見つかった最新の素数を 漸進的に表示し続ける。
◎
In this example, the main document spawns a worker to (naïvely) compute prime numbers, and progressively displays the most recently found prime number.
</p>

<p>
~main~pageは次で与えられる：
◎
The main page is as follows:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;~worker例： 単~coreによる~~計算&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;これまでに見つかった最大の素数は：&lt;output id="result"&gt;&lt;/output&gt;&lt;/p&gt;

&lt;script&gt;
   var %worker = new Worker('worker.js');
   %worker.onmessage = function (%event) {
     document.getElementById('result').textContent = %event.data;
   };
&lt;/script&gt;

 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
`Worker()$m
構築子の~callにより，~workerが作成され、［
その~workerを表現し, その~workerと通信する， `Worker$I ~obj
］が返される。
~objの `onmessage$hd ~event~handlerには、~workerから~messageを受信する~codeを入れられる。
◎
The Worker() constructor call creates a worker and returns a Worker object representing that worker, which is used to communicate with the worker. That object's onmessage event handler allows the code to receive messages from the worker.
</p>

<p>
~worker自身は次で与えられる：
◎
The worker itself is as follows:
</p>

<pre>
var %n = 1;
search: while (true) {
  %n += 1;
  for (var %i = 2; %i &lt;= Math.sqrt(%n); %i += 1)
    if (%n % %i == 0)
     continue search;
  // <span class="comment"
	title="found a prime!"
	>素数~発見！</span>
  postMessage(%n);
}
</pre>

<p class="trans-note">【
いきなり `postMessage()^m が大域~関数として登場している所からも推察されるように、ちょうど通常の~scriptの window ~objにあたる，~worker~scriptの実行文脈のための大域~obj（<a href="#infrastructure">大域~scope節</a>）が、（~workerを生成した側の実行文脈とは別に）存在している、と考えれば，仕様の残りの部分も理解し易い。
】</p>

<p>
この~codeは、単純な 最適化されていない，素数の探索~routineである。
`~postMessage0()$m
が、見つかった素数を~messageにして~pageに返信する~methodである。
◎
The bulk of this code is simply an unoptimized search for a prime number. The postMessage() method is used to send a message back to the page when a prime is found.
</p>

<p>
<a href="~DEMO/primes/page.html">この例を~onlineで見る</a>
◎
View this example online.
</p>

			</section>
			<section id="worker-used-for-background-i/o">

<h4 title="Worker used for background I/O">10.1.2.2. ~background入出力に~workerを利用する</h4>


~INFORMATIVE

<p>
この例では、~main文書において２“人”の~workerが用いられる。
１人は定期的に株式の更新を取得してくれ,
もう１人は利用者が~~要請した検索~queryを遂行してくれる。
◎
In this example, the main document uses two workers, one for fetching stock updates at regular intervals, and one for performing search queries that the user requests.
</p>

<p>
~main~pageは次で与えられる：
◎
The main page is as follows:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;~worker例：相場表示機&lt;/title&gt;

&lt;script&gt;
   // <span class="comment"
	title="TICKER"
	>表示機</span>
   var %symbol = 'GOOG'; // <span class="comment"
	title="default symbol to watch"
	>既定の監視対象の証券code（ %symbol ）</span>
   var %ticker = new Worker('ticker.js');

   // <span class="comment"
	title="SEARCHER"
	>検索器</span>
   var %searcher = new Worker('searcher.js');
   function search(%query) {
     %searcher.postMessage(%query);
   }

   // <span class="comment"
	title="SYMBOL SELECTION UI"
	>証券code選択 UI</span>
   function select(%newSymbol) {
     %symbol = %newSymbol;
     %ticker.postMessage(%symbol);
   }
&lt;/script&gt;

  &lt;meta http-equiv="Refresh" content="120; URL=../"&gt;
 &lt;/head&gt;
 &lt;body onload="search('')"&gt;
  &lt;p&gt;
    &lt;output id="symbol"&gt;&lt;/output&gt;
    &lt;output id="value"&gt;&lt;/output&gt;
  &lt;/p&gt;

&lt;script&gt;
   %ticker.onmessage = function (%event) {
     var %data = %event.data.split(' ');
     document.getElementById('symbol').textContent = %data[0];
     document.getElementById('value').textContent = %data[1];
   };
   %ticker.postMessage(%symbol);
&lt;/script&gt;

  &lt;p&gt;&lt;label&gt;Search:
    &lt;input type="text" autofocus oninput="search(this.value)"&gt;
  &lt;/label&gt;&lt;/p&gt;
  &lt;ul id="results"&gt;&lt;/ul&gt;

&lt;script&gt;
   %searcher.onmessage = function (%event) {
     var %data = %event.data.split(' ');
     var %results = document.getElementById('results');
     while (%results.hasChildNodes()) // <span class="comment"
	title="clear previous results"
	>前の結果を消去</span>
       %results.removeChild(%results.firstChild);
     for (var %i = 0; %i &lt; data.length; %i += 1) {
       // <span class="comment"
	title="add a list item with a button for each result"
	>各結果に対し、~buttonを伴う~list項目を追加する</span>
       var %li = document.createElement('li');
       var %button = document.createElement('button');
       %button.value = %data[i];
       %button.type = 'button';
       %button.onclick = function () { select(this.value); };
       %button.textContent = %data[i];
       %li.appendChild(%button);
       %results.appendChild(%li);
     }
   };
&lt;/script&gt;

  &lt;p&gt;（この例の~dataは本物ではありません。
   "Google" または "Apple" で検索してみてください。）&lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
2 人の~workerは、実際の~network~callを遂行するための，共通~libraryを利用する。
この~libraryは次のようになっている：
◎
The two workers use a common library for performing the actual network calls. This library is as follows:
</p>

<pre>
function get(%url) {
  try {
    var %xhr = new XMLHttpRequest();
    %xhr.open('GET', %url, false);
    %xhr.send();
    return %xhr.responseText;
  } catch (%e) {
    return ''; // <span class="comment"
	title="turn all errors into empty results"
	>~errorが生じたときは一律に空文字列を返す</span>
  }
}
</pre>

<p>
株式~更新~workerは次のようになっている：
◎
The stock updater worker is as follows:
</p>

<pre>
importScripts('io.js');
var %timer;
var %symbol;
function update() {
  postMessage(%symbol + ' ' + get('stock.cgi?' + %symbol));
  %timer = setTimeout(%update, 10000);
}
onmessage = function (%event) {
  if (%timer)
    clearTimeout(%timer);
  %symbol = %event.data;
  update();
};
</pre>

<p class="trans-note">【
大域~変数のように定義された `onmessage^m が、ちょうど
`window.onload^m ~event~handlerを定義するときと同様の形で，~worker~scriptの大域~scopeにおける~event~handlerを定義する。
】</p>

<p>
検索~query~workerは次のようになっている：
◎
The search query worker is as follows:
</p>

<pre>
importScripts('io.js');
onmessage = function (%event) {
  postMessage(get('search.cgi?' + %event.data));
};
</pre>

<p>
<a href="~DEMO/stocks/page.html">この例を~onlineで見る</a>
◎
View this example online.
</p>

			</section>
			<section id="module-worker-example">
<h4 title="Using a JavaScript module as a worker">10.1.2.3. ~JS~moduleを~workerとして利用する</h4>

~INFORMATIVE

<div >
<p>
これまでのどの例も`~classic~script$を走らす~workerを示してきたが、~workerは，`~module~script$を利用して~instance化することもできる
— これには通例的な次の便益がある：
</p>

<ul><li>~JS `import^c 文を利用して他の~moduleを取込む能
</li><li>既定で~strict~modeになる
</li><li>~workerの大域~scopeを汚さないような，~top-levelの宣言
</li></ul>
◎
All of our examples so far show workers that run classic scripts. Workers can instead be instantiated using module scripts, which have the usual benefits: the ability to use the JavaScript import statement to import other modules; strict mode by default; and top-level declarations not polluting the worker's global scope.
</div>

<p>
そのような~moduleに基づく~workerは、非同一生成元~内容に関して，~classic~workerと異なる制約に従うことに注意。
~classic~workerと違って，~module~workerは、その~scriptが`~CORS~protocol$を利用して公開されている限り，非同一生成元~scriptを利用して~instance化できる。
加えて、 `importScripts()$m ~methodは，~module~workerの内側では自動的に失敗することになるので、一般に，~JS `import^c 文の方が良い~~選択になる。
◎
Note that such module-based workers follow different restrictions regarding cross-origin content, compared to classic workers. Unlike classic workers, module workers can be instantiated using a cross-origin script, as long as that script is exposed using the CORS protocol. Additionally, the importScripts() method will automatically fail inside module workers; the JavaScript import statement is generally a better choice.
</p>

<p>
この例では、~main文書が，~main~threadの外で画像~操作を行う~workerを利用する。
それは、別の~moduleから利用される~filterを取込む。
◎
In this example, the main document uses a worker to do off-main-thread image manipulation. It imports the filters used from another module.
</p>

<p>
~main~pageは次で与えられる：
◎
The main page is as follows:
</p>


<pre>
&lt;!DOCTYPE html&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;~worker例： 画像の復号&lt;/title&gt;

&lt;label&gt;
  復号する画像の URL を入れてください
  &lt;input type="url" id="image-url" list="image-list"&gt;
  &lt;datalist id="image-list"&gt;
    &lt;option value="https://html.spec.whatwg.org/images/drawImage.png"&gt;
    &lt;option value="https://html.spec.whatwg.org/images/robots.jpeg"&gt;
    &lt;option value="https://html.spec.whatwg.org/images/arcTo2.png"&gt;
  &lt;/datalist&gt;
&lt;/label&gt;

&lt;label&gt;
  適用する~filterを選んでください
  &lt;select id="filter"&gt;
    &lt;option value="none"&gt;なし&lt;/option&gt;
    &lt;option value="grayscale"&gt;~grayscale&lt;/option&gt;
    &lt;option value="brighten"&gt;20% 明るくする&lt;/option&gt;
  &lt;/select&gt;
&lt;/label&gt;

&lt;script type="module"&gt;
  const %worker = new Worker("worker.js", { type: "module" });
  %worker.onmessage = receiveFromWorker;

  const %url = document.querySelector("#image-url");
  const %filter = document.querySelector("#filter");
  const %output = document.querySelector("#output");

  %url.oninput = updateImage;
  %filter.oninput = sendToWorker;

  let %imageData, %context;

  function updateImage() {
    const %img = new Image();
    %img.src = %url.value;

    %img.onload = () =&gt; {
      %output.innerHTML = "";

      const %canvas = document.createElement("canvas");
      %canvas.width = %img.width;
      %canvas.height = %img.height;

      %context = %canvas.getContext("2d");
      %context.drawImage(%img, 0, 0);
      %imageData = %context.getImageData(0, 0, %canvas.width, %canvas.height);

      sendToWorker();
      %output.appendChild(%canvas);
    };
  }

  function sendToWorker() {
    %worker.postMessage({ %imageData, filter: %filter.value });
  }

  function receiveFromWorker(%e) {
    %context.putImageData(%e.data, 0, 0);
  }
&lt;/script&gt;
</pre>


<p>
~worker~fileは次で与えられる：
◎
The worker file is then:
</p>


<pre>
import * as filters from "./filters.js";

self.onmessage = %e =&gt; {
  const { %imageData, %filter } = %e.data;
  filters[%filter](%imageData);
  self.postMessage(%imageData, [%imageData.data.buffer]);
};
</pre>

<p>
これは、次の~file `filters.js^c を取込む：
◎
Which imports the file filters.js:
</p>

<pre>
export function none() {}

export function grayscale({ data: %d }) {
  for (let %i = 0; %i &lt; %d.length; %i += 4) {
    const [%r, %g, %b] = [%d[%i], %d[%i + 1], %d[%i + 2]];

    // RGB に対する CIE 輝度
    // 人の目は 赤, 青 に鈍感なので，それらを減衰する
    %d[%i] = %d[%i + 1] = %d[%i + 2] = 0.2126 * %r + 0.7152 * %g + 0.0722 * %b;
  }
};

export function brighten({ data: %d }) {
  for (let %i = 0; %i &lt; %d.length; ++%i) {
    %d[%i] *= 1.2;
  }
};</pre>

<!-- 
    // CIE luminance for the RGB
    // The human eye is bad at seeing red and blue, so we de-emphasize them.
-->

<p>
<a href="~DEMO/modules/page.html">この例を~onlineで見る</a>
◎
View this example online.
</p>

			</section>
			<section id="shared-workers-introduction">

<h4 title="Shared workers introduction">10.1.2.4. 共用~worker概説</h4>


~INFORMATIVE

<p>
この節では、 Hello World の例を基に，共用~workerについて概説する。
共用~workerでは、それぞれの~workerが複数の接続を持ち得るので，少し異なる~APIが利用される。
◎
This section introduces shared workers using a Hello World example. Shared workers use slightly different APIs, since each worker can have multiple connections.
</p>

<p>
この最初の例では、利用者がどのようにして~workerに接続し，~workerがその接続-時にどのように~pageに~messageを返信するかを示す。
受信された~messageは~logに表示される。
◎
This first example shows how you connect to a worker and how a worker can send a message back to the page when it connects to it. Received messages are displayed in a log.
</p>

<p>
HTML ~pageをここに示す：
◎
Here is the HTML page:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;共用~worker： ~demo 1&lt;/title&gt;
&lt;pre id="log"&gt;Log:&lt;/pre&gt;

&lt;script&gt;
  var %worker = new SharedWorker('test.js');
  var %log = document.getElementById('log');
  %worker.port.onmessage = function(%e) { // <span class="comment"
	title="note: not worker.onmessage!"
	><code >%worker.onmessage</code> ではないことに注意</span>
    %log.textContent += '\n' + %e.data;
  }
&lt;/script&gt;
</pre>

<p>
~JS~workerは次になる：
◎
Here is the JavaScript worker:
</p>

<pre>
onconnect = function(%e) {
  var %port = %e.ports[0];
  %port.postMessage('Hello World!');
}
</pre>

<p class="trans-note">【
`onconnect^m の名が示唆するように、接続が確立され次第，~workerの大域~scopeに属する `onconnect()^m が呼出される。
】</p>

<p>
<a href="~DEMO/shared/001/test.html">この例を~onlineで見る</a>
◎
View this example online.
</p>

<hr>
<p>
次の例は、２つの変更により，最初のものを拡張する：
まず，~messageは`~event~handler IDL 属性$の代わりに
`addEventListener()$m
を用いて受信される。
次に，~messageは
~workerに<em>向けて</em> 送信され，それに対し~workerが別の~messageを返信するようにしている。
受信された~messageは再び~logに表示される。
◎
This second example extends the first one by changing two things: first, messages are received using addEventListener() instead of an event handler IDL attribute, and second, a message is sent to the worker, causing the worker to send another message in return. Received messages are again displayed in a log.
</p>

<p>
次は HTML ~page：
◎
Here is the HTML page:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;共用~worker： ~demo 2&lt;/title&gt;
&lt;pre id="log"&gt;Log:&lt;/pre&gt;

&lt;script&gt;
  var %worker = new SharedWorker('test.js');
  var %log = document.getElementById('log');
  %worker.port.addEventListener('message', function(%e) {
    %log.textContent += '\n' + %e.data;
  }, false);
  worker.port.start(); // <span class="comment"
	title="note: need this when using addEventListener"
	>注記： `addEventListener()^m を用いた場合はこれが必要になる</span>
  %worker.port.postMessage('ping');
&lt;/script&gt;
</pre>

<p>
~JS~workerは次になる：
◎
Here is the JavaScript worker:
</p>

<pre>
onconnect = function(%e) {
  var %port = %e.ports[0];
  %port.postMessage('Hello World!');
  %port.onmessage = function(%e) {
    %port.postMessage('pong'); // <span class="comment"
	title="not e.ports[0].postMessage!"
	><code>%e.ports[0].postMessage</code> ではないことに注意</span>
    // <span class="comment"
	title="e.target.postMessage('pong'); would work also"
	><code>%e.target.postMessage('pong');</code> でもいける</span>
  }
}
</pre>

<p>
<a href="~DEMO/shared/002/test.html">この例を~onlineで見る</a>
◎
View this example online.
</p>

<hr>
<p>
最後の例は、２つの~pageから同じ~workerに接続させる方法を示す。
この例では，２番目の~pageは 単に最初の~pageの `iframe$e に入れられているが、同じ原理は，別々の`~top-level閲覧文脈$（ top-level browsing context ）上の全く別々の~pageであっても，通用する。
◎
Finally, the example is extended to show how two pages can connect to the same worker; in this case, the second page is merely in an iframe on the first page, but the same principle would apply to an entirely separate page in a separate top-level browsing context.
</p>

<p>
外縁 HTML ~page：
◎
Here is the outer HTML page:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;共用~worker： ~demo 3&lt;/title&gt;
&lt;pre id="log"&gt;Log:&lt;/pre&gt;

&lt;script&gt;
  var %worker = new SharedWorker('test.js');
  var %log = document.getElementById('log');
  %worker.port.addEventListener('message', function(%e) {
    %log.textContent += '\n' + %e.data;
  }, false);
  %worker.port.start();
  %worker.port.postMessage('ping');
&lt;/script&gt;

&lt;iframe src="inner.html"&gt;&lt;/iframe&gt;
</pre>

<p>
内縁 HTML ~page：
◎
Here is the inner HTML page:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;共用~worker： ~demo 3 inner frame&lt;/title&gt;
&lt;pre id=log&gt;Inner log:&lt;/pre&gt;

&lt;script&gt;
  var %worker = new SharedWorker('test.js');
  var %log = document.getElementById('log');
  %worker.port.onmessage = function(%e) {
   %log.textContent += '\n' + %e.data;
  }
&lt;/script&gt;
</pre>

<p>
~JS~workerは次になる：
◎
Here is the JavaScript worker:
</p>

<pre>
var %count = 0;
onconnect = function(%e) {
  %count += 1;
  var %port = %e.ports[0];
  %port.postMessage('Hello World! You are connection #' + %count);
  %port.onmessage = function(%e) {
    %port.postMessage('pong');
  }
}
</pre>

<p>
<a href="~DEMO/shared/003/test.html">この例を~onlineで見る</a>
◎
View this example online.
</p>

			</section>
			<section id="shared-state-using-a-shared-worker">

<h4 title="Shared state using a shared worker">10.1.2.5. 共用~workerの利用による状態の共有-</h4>


~INFORMATIVE

<p>
次の例では、同じ~mapを~~表示する複数の~window（~viewer）を開けるようになっている。
単独の~workerが すべての~viewerを束ねる形で、すべての~windowが同じ~map情報を共有する。
それぞれの~viewerでは 独立に~map内を動き回れつつ、それらのいずれかにおいて 何らかの~dataが~map内に置かれたときは，すべての~viewerが更新される。
◎
In this example, multiple windows (viewers) can be opened that are all viewing the same map. All the windows share the same map information, with a single worker coordinating all the viewers. Each viewer can move around independently, but if they set any data on the map, all the viewers are updated.
</p>

<p>
~main~pageはさほど興味を引くものではない。
~viewerを開くための単なる起点である：
◎
The main page isn't interesting, it merely provides a way to open the viewers:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;~worker例： Multiviewer&lt;/title&gt;

&lt;script&gt;
   function openViewer() {
     window.open('viewer.html');
   }
&lt;/script&gt;

 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;&lt;button type=button onclick="openViewer()"&gt;Open a new
  viewer&lt;/button&gt;&lt;/p&gt;
  &lt;p&gt;<span title="Each viewer opens in a new window. You can have as many viewers
  as you like, they all view the same data.">各~viewerは新たな~windowを開く。望む限り，いくつでも
  ~viewerを開ける。それらはすべて同じ~dataを~~表示する。</span>&lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
~viewerはより~~関係が深いものになる：
◎
The viewer is more involved:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;~worker例： Multiviewer ~viewer&lt;/title&gt;

&lt;script&gt;
   var worker = new SharedWorker('worker.js', 'core');

   // <span class="comment"
	title="CONFIGURATION"
	>環境設定</span>
   function configure(%event) {
     if (%event.data.substr(0, 4) != 'cfg ') return;
     var %name = %event.data.substr(4).split(' ', 1)[0];
     // <span class="comment"
	title="update display to mention our name is name"
	>名前が %name であることを示すために表示を更新する</span>
     document.getElementsByTagName('h1')[0].textContent += ' ' + %name;
     // <span class="comment"
	title="no longer need this listener"
	>この~listenerはもう不要</span>
     %worker.port.removeEventListener('message', configure, false);
   }
   %worker.port.addEventListener('message', configure, false);

   // <span class="comment"
	title="MAP"
	>~map</span>
   function paintMap(%event) {
     if (%event.data.substr(0, 4) != 'map ') return;
     var %data = %event.data.substr(4).split(',');
     // <span class="comment"
	title="display tiles data[0] .. data[8]"
	><code >%data[0] .. %data[8]</code> の各升を表示する</span>
     var %canvas = document.getElementById('map');
     var %context = %canvas.getContext('2d');
     for (var %y = 0; %y &lt; 3; %y += 1) {
       for (var %x = 0; %x &lt; 3; %x += 1) {
         var %tile = data[%y * 3 + %x];
         if (%tile == '0')
           %context.fillStyle = 'green';
         else 
           %context.fillStyle = 'maroon';
         %context.fillRect(x * 50, y * 50, 50, 50);
       }
     }
   }
   %worker.port.addEventListener('message', paintMap, false);

   // <span class="comment"
	title="PUBLIC CHAT"
	>~public~chat</span>
   function updatePublicChat(%event) {
     if (%event.data.substr(0, 4) != 'txt ') return;
     var %name = %event.data.substr(4).split(' ', 1)[0];
     var %message = %event.data.substr(4 + %name.length + 1);
     // <span class="comment"
	title="display &quot;&lt;name&gt; message&quot; in public chat"
	>~public~chatに "<code>&lt;%name&gt; %message</code>" を表示する</span>
     var %public = document.getElementById('public');
     var %p = document.createElement('p');
     var %n = document.createElement('button');
     %n.textContent = '&lt;' + %name + '&gt; ';
     %n.onclick = function () { %worker.port.postMessage('msg ' + %name); };
     %p.appendChild(%n);
     var %m = document.createElement('span');
     %m.textContent = %message;
     %p.appendChild(%m);
     %public.appendChild(%p);
   }
   %worker.port.addEventListener('message', updatePublicChat, false);

   // <span class="comment"
	title="PRIVATE CHAT"
	>~private~chat</span>
   function startPrivateChat(%event) {
     if (%event.data.substr(0, 4) != 'msg ') return;
     var %name = %event.data.substr(4).split(' ', 1)[0];
     var %port = %event.ports[0];
     // <span class="comment"
	title="display a private chat UI"
	>~private~chat UI を表示する</span>
     var %ul = document.getElementById('private');
     var %li = document.createElement('li');
     var %h3 = document.createElement('h3');
     %h3.textContent = 'Private chat with ' + %name;
     %li.appendChild(%h3);
     var %div = document.createElement('div');
     var %addMessage = function(%name, %message) {
       var %p = document.createElement('p');
       var %n = document.createElement('strong');
       %n.textContent = '&lt;' + %name + '&gt; ';
       %p.appendChild(%n);
       var %t = document.createElement('span');
       %t.textContent = %message;
       %p.appendChild(%t);
       %div.appendChild(%p);
     };
     %port.onmessage = function (%event) {
       addMessage(%name, %event.data);
     };
     %li.appendChild(%div);
     var %form = document.createElement('form');
     var %p = document.createElement('p');
     var %input = document.createElement('input');
     %input.size = 50;
     %p.appendChild(%input);
     %p.appendChild(document.createTextNode(' '));
     var %button = document.createElement('button');
     %button.textContent = 'Post';
     %p.appendChild(%button);
     %form.onsubmit = function () {
       %port.postMessage(%input.value);
       addMessage('me', %input.value);
       %input.value = '';
       return false;
     };
     %form.appendChild(%p);
     %li.appendChild(%form);
     %ul.appendChild(%li);
   }
   %worker.port.addEventListener('message', startPrivateChat, false);

   %worker.port.start();
&lt;/script&gt;

 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;Viewer&lt;/h1&gt;
  &lt;h2&gt;Map&lt;/h2&gt;
  &lt;p&gt;&lt;canvas id="map" height=150 width=150&gt;&lt;/canvas&gt;&lt;/p&gt;
  &lt;p&gt;
   &lt;button type=button onclick="%worker.port.postMessage('mov left')"
   &gt;Left&lt;/button&gt;
   &lt;button type=button onclick="%worker.port.postMessage('mov up')"
   &gt;Up&lt;/button&gt;
   &lt;button type=button onclick="%worker.port.postMessage('mov down')"
   &gt;Down&lt;/button&gt;
   &lt;button type=button onclick="%worker.port.postMessage('mov right')"
   &gt;Right&lt;/button&gt;
   &lt;button type=button onclick="%worker.port.postMessage('set 0')"
   &gt;Set 0&lt;/button&gt;
   &lt;button type=button onclick="%worker.port.postMessage('set 1')"
   &gt;Set 1&lt;/button&gt;
  &lt;/p&gt;
  &lt;h2&gt;Public Chat&lt;/h2&gt;
  &lt;div id="public"&gt;&lt;/div&gt;
  &lt;form onsubmit="%worker.port.postMessage('txt ' + %message.value);
    %message.value = ''; return false;"
  &gt;
   &lt;p&gt;
    &lt;input type="text" name="message" size="50"&gt;
    &lt;button&gt;Post&lt;/button&gt;
   &lt;/p&gt;
  &lt;/form&gt;
  &lt;h2&gt;Private Chat&lt;/h2&gt;
  &lt;ul id="private"&gt;&lt;/ul&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
~viewerの書かれ方には注目すべき重要な点がいくつかある。
◎
There are several key things worth noting about the way the viewer is written.
</p>

<p>
<strong>複数の~listener</strong>：
単独の~message処理~関数の代わりに、この~codeでは，それぞれが~messageに関連するのかどうかの~~簡単な検査を遂行するような，複数の~event~listenerを付け加えている。
この例では，さほど大きな相違は生じないが、幾人かの作者~達が協同する中で，~workerとの通信に単独の~portの利用が望まれている状況においても、すべての変更を単独の~event取扱い関数に加えることなく，独立の~codeでそれが可能になる。
◎
Multiple listeners. Instead of a single message processing function, the code here attaches multiple event listeners, each one performing a quick check to see if it is relevant for the message. In this example it doesn't make much difference, but if multiple authors wanted to collaborate using a single port to communicate with a worker, it would allow for independent code instead of changes having to all be made to a single event handling function.
</p>

<p>
このようなやり方で~event~listenerを登録するようにした場合、この例の <code>configure()</code> ~methodのように、事を終えた後には，~~個別的に~listenerを登録から外せるようになる。
◎
Registering event listeners in this way also allows you to unregister specific listeners when you are done with them, as is done with the configure() method in this example.
</p>

<p>
最後に，~worker：
◎
Finally, the worker:
</p>

<pre>
var %nextName = 0;
function getNextName() {
  // <span class="comment"
	title="this could use more friendly names"
	>より~~親しみ易い名前にすることもできるが</span>
  // <span class="comment"
	title="but for now just return a number"
	>今の所は単なる番号</span>
  return %nextName++;
}

var %map = [
 [0, 0, 0, 0, 0, 0, 0],
 [1, 1, 0, 1, 0, 1, 1],
 [0, 1, 0, 1, 0, 0, 0],
 [0, 1, 0, 1, 0, 1, 1],
 [0, 0, 0, 1, 0, 0, 0],
 [1, 0, 0, 1, 1, 1, 1],
 [1, 1, 0, 1, 1, 0, 1],
];

function wrapX(%x) {
  if (%x &lt; 0) return wrapX(%x + %map[0].length);
  if (%x &gt;= %map[0].length) return wrapX(%x - %map[0].length);
  return %x;
}

function wrapY(%y) {
  if (%y &lt; 0) return wrapY(%y + %map.length);
  if (%y &gt;= %map[0].length) return wrapY(%y - %map.length);
  return %y;
}

function wrap(%val, %min, %max) {
  if (%val &lt; %min)
    return %val + (%max-%min)+1;
  if (%val &gt; %max)
    return %val - (%max-%min)-1;
  return %val;
}

function sendMapData(%viewer) {
  var %data = '';
  for (var %y = %viewer.y-1; y &lt;= %viewer.y+1; %y += 1) {
    for (var %x = %viewer.x-1; %x &lt;= %viewer.x+1; %x += 1) {
      if (%data != '')
        %data += ',';
      %data += %map[wrap(%y, 0, %map[0].length-1)][wrap(%x, 0, %map.length-1)];
    }
  }
  %viewer.port.postMessage('map ' + %data);
}

var %viewers = {};
onconnect = function (%event) {
  var %name = getNextName();
  %event.ports[0]._data = { port: event.ports[0], name: %name, x: 0, y: 0, };
  %viewers[%name] = %event.ports[0]._data;
  %event.ports[0].postMessage('cfg ' + %name);
  %event.ports[0].onmessage = getMessage;
  sendMapData(event.ports[0]._data);
};

function getMessage(%event) {
  switch (%event.data.substr(0, 4)) {
    case 'mov ':
      var %direction = %event.data.substr(4);
      var %dx = 0;
      var %dy = 0;
      switch (%direction) {
        case 'up': %dy = -1; break;
        case 'down': %dy = 1; break;
        case 'left': %dx = -1; break;
        case 'right': %dx = 1; break;
      }
      %event.target._data.x = wrapX(%event.target._data.x + %dx);
      %event.target._data.y = wrapY(%event.target._data.y + %dy);
      sendMapData(%event.target._data);
      break;
    case 'set ':
      var %value = %event.data.substr(4);
      map[%event.target._data.y][%event.target._data.x] = %value;
      for (var %viewer in %viewers)
        sendMapData(%viewers[%viewer]);
      break;
    case 'txt ':
      var %name = %event.target._data.name;
      var %message = %event.data.substr(4);
      for (var %viewer in %viewers)
        %viewers[%viewer].port.postMessage('txt ' + %name + ' ' + %message);
      break;
    case 'msg ':
      var %party1 = %event.target._data;
      var %party2 = %viewers[%event.data.substr(4).split(' ', 1)[0]];
      if (%party2) {
        var %channel = new MessageChannel();
        %party1.port.postMessage('msg ' + %party2.name, [%channel.port1]);
        %party2.port.postMessage('msg ' + %party1.name, [%channel.port2]);
      }
      break;
  }
}</pre>

<p>
<strong>複数の~pageへの接続ing</strong>：
この~scriptは、複数の接続を待ち受けるために，
`onconnect$hd ~event~listenerを利用している。
◎
Connecting to multiple pages. The script uses the onconnect event listener to listen for multiple connections.
</p>

<p>
<strong>直通~channel</strong>：
~workerが，一方の~viewerから他方の~viewerを~~指名する `msg^l ~messageを受信したとき、２つの間に直接~接続が設置され、~workerがすべての~messageを代理しなくとも，２つの~viewerが直接的に通信できる。
◎
Direct channels. When the worker receives a "msg" message from one viewer naming another viewer, it sets up a direct connection between the two, so that the two viewers can communicate directly without the worker having to proxy all the messages.
</p>

<p>
<a href="~DEMO/multiviewer/page.html">この例を~onlineで見る</a>
◎
View this example online.
</p>

			</section>
			<section id="delegation">

<h4 title="Delegation">10.1.2.6. 委譲</h4>

~INFORMATIVE

<p>
~multi~core CPU の普及に伴い、計算量の大きな仕事を複数の~workerに分業させて，処理能を高められるようになっている。
この例では、 1 〜 10,000,000 に付番された計算量の大きな仕事を 10 等分して， 10 個の~subworkerに遂行させる。
◎
With multicore CPUs becoming prevalent, one way to obtain better performance is to split computationally expensive tasks amongst multiple workers. In this example, a computationally expensive task that is to be performed for every number from 1 to 10,000,000 is farmed out to ten subworkers.
</p>

<p>
~main~pageは次で与えられる。
これは単に結果を報告する：
◎
The main page is as follows, it just reports the result:
</p>

<pre>
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;~worker例： ~multi~coreによる~~計算&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;Result: &lt;output id="result"&gt;&lt;/output&gt;&lt;/p&gt;

&lt;script&gt;
   var %worker = new Worker('worker.js');
   %worker.onmessage = function (%event) {
     document.getElementById('result').textContent = %event.data;
   };
&lt;/script&gt;

 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
~worker自身は次のようになっている：
◎
The worker itself is as follows:
</p>

<pre>// <span class="comment"
	title="settings"
	>設定</span>
var %num_workers = 10;
var %items_per_worker = 1000000;

// <span class="comment"
	title="start the workers"
	>~workerを開始-</span>
var %result = 0;
var %pending_workers = %num_workers;
for (var %i = 0; %i &lt; %num_workers; %i += 1) {
  var %worker = new Worker('core.js');
  %worker.postMessage(%i * %items_per_worker);
  %worker.postMessage((%i+1) * %items_per_worker);
  %worker.onmessage = storeResult;
}

// <span class="comment"
	title="handle the results"
	>結果を取扱う</span>
function storeResult(%event) {
  %result += 1*%event.data;
  %pending_workers -= 1;
  if (%pending_workers &lt;= 0)
    postMessage(%result); // <span class="comment"
	title="finished!"
	>完成！</span>
}
</pre>

<p>
一連の~subworkerを開始させる~loopと, すべての~subworkerから応答が返されるのを待つ~handlerからなる。
◎
It consists of a loop to start the subworkers, and then a handler that waits for all the subworkers to respond.
</p>

<p>
~subworkerは次のように実装されている：
◎
The subworkers are implemented as follows:
</p>

<pre>
var %start;
onmessage = getStart;
function getStart(%event) {
  %start = 1*%event.data;
  onmessage = getEnd;
}

var %end;
function getEnd(%event) {
  %end = 1*%event.data;
  onmessage = null;
  work();
}

function work() {
  var %result = 0;
  for (var %i = %start; i &lt; %end; %i += 1) {
    // <span class="comment"
	title="perform some complex calculation here"
	>何か複雑な計算がここで遂行される</span>
    %result += 1;
  }
  postMessage(%result);
  close();
}
</pre>

<p>
これらはそれぞれ、２度の~eventで２個の番号を受信し,
それにより指定される付番~範囲の~~計算を遂行し,
結果を親に報告する。
◎
They receive two numbers in two events, perform the computation for the range of numbers thus specified, and then report the result back to the parent.
</p>

<p>
<a href="~DEMO/multicore/page.html">この例を~onlineで見る</a>
◎
View this example online.
</p>

			</section>
		</section>
		<section id="tutorials">

<h3 title="Tutorials">10.1.3. ~tutorial</h3>

			<section id="creating-a-dedicated-worker">

<h4 title="Creating a dedicated worker">10.1.3.1. 専用~workerの作成法</h4>


~INFORMATIVE

<p>
~workerを作成するためには~JS~fileの~URLを要する。
その~fileの~URLを唯一の引数とする
`Worker()$m
の構築子が呼出されると、~workerが作成されて返される：
◎
Creating a worker requires a URL to a JavaScript file. The Worker() constructor is invoked with the URL to that file as its only argument; a worker is then created and returned:
</p>

<pre>
var %worker = new Worker('helper.js');
</pre>


<p>
`~classic~script$でなく`~module~script$として解釈させたいときは、記し方を少し変える必要がある：
◎
If you want your worker script to be interpreted as a module script instead of the default classic script, you need to use a slightly different signature:
</p>

<pre>
var worker = new Worker('helper.js', { type: "module" });
</pre>

			</section>
			<section id="communicating-with-a-dedicated-worker">

<h4 title="Communicating with a dedicated worker">10.1.3.2. 専用~workerとの通信ing</h4>


~INFORMATIVE

<p>
専用~workerは暗黙的に
`MessagePort$I
~objを利用する。
したがって、有構造~dataの送信, ~binary~dataの転送, 他の~portへの転送など、
`MessagePort$I と同じ特色機能を~supportする。
◎
Dedicated workers use MessagePort objects behind the scenes, and thus support all the same features, such as sending structured data, transferring binary data, and transferring other ports.
</p>

<p>
専用~workerから~messageを受信するためには、
`Worker$I ~objの `onmessage$hd `~event~handler IDL 属性$を利用する：
◎
To receive messages from a dedicated worker, use the onmessage event handler IDL attribute on the Worker object:
</p>

<pre>
%worker.onmessage = function (%event) { ... };
</pre>

<p>
`addEventListener()$m
~methodも利用できる。
◎
You can also use the addEventListener() method.
</p>

<p class="note">注記：
専用~workerに利用される暗黙的な
`MessagePort$I
には、その作成-時に`~port~message待行列$が暗黙的に備わり，可能化される。
したがって、
`Worker$I ~interfaceには
`MessagePort$I ~interfaceの `start()$m ~methodにあたるものは存在しない。
◎
The implicit MessagePort used by dedicated workers has its port message queue implicitly enabled when it is created, so there is no equivalent to the MessagePort interface's start() method on the Worker interface.
</p>

<p>
~workerへの~dataの <em>送信</em> には
`postMessage()$m ~methodを用いる。
有構造~dataもこの通信~channelを通して送信できる。
（何個かの） `ArrayBuffer$I ~objを効率的に送信する（~cloneせずに転送する）ためには、それらを配列にして 2 個目の引数に渡す。
◎
To send data to a worker, use the postMessage() method. Structured data can be sent over this communication channel. To send ArrayBuffer objects efficiently (by transferring them rather than cloning them), list them in an array in the second argument.
</p>

<pre>
%worker.postMessage({
  operation: 'find-edges',
  input: %buffer, // <span class="comment"
	title="an ArrayBuffer object"
	>ArrayBuffer ~obj</span>
  threshold: 0.6,
}, [%buffer]);
</pre>

<p>
~workerの内側で~messageを受信するときは、
`~onmessage0$hd `~event~handler IDL 属性$を利用する。
◎
To receive a message inside the worker, the onmessage event handler IDL attribute is used.
</p>

<pre>
onmessage = function (%event) { ... };
</pre>

<p>
ここでもまた `addEventListener()$m ~methodを利用できる。
◎
You can again also use the addEventListener() method.
</p>

<p>
いずれの場合も，~dataは~event~objの `data$m 属性に供される。
◎
In either case, the data is provided in the event object's data attribute.
</p>

<p>
~messageの返信にも，また
`~postMessage0()$m
を利用する。
有構造~dataも同じように~supportされる。
◎
To send messages back, you again use postMessage(). It supports the structured data in the same manner.
</p>

<pre>
postMessage(%event.data.input, [%event.data.input]); // <span class="comment"
	title="transfer the buffer back"
	>~bufferを返送</span>
</pre>


			</section>
			<section id="shared-workers">

<h4 title="Shared workers">10.1.3.3. 共用~worker</h4>


~INFORMATIVE

<p>
共用~workerは、その作成-時に利用される~scriptの~URLにより識別され，~optionalで明示的な名前も伴われる。
名前により，特定0の共用~workerに対し複数の~instanceを開始させられるようになる。
◎
Shared workers are identified by the URL of the script used to create it, optionally with an explicit name. The name allows multiple instances of a particular shared worker to be started.
</p>

<p>
共用~workerは，生成元の~scopeに属する（生成元ごとに分別される）。
別々の~siteが同名のものを利用したとしても，衝突することはない。
しかしながら，１つの~pageと同じ~siteの他の~pageで、同じ共用~worker名が，異なる~script~URLを伴って用いられた場合、失敗することになる。
◎
Shared workers are scoped by origin. Two different sites using the same names will not collide. However, if a page tries to use the same shared worker name as another page on the same site, but with a different script URL, it will fail.
</p>

<p>
共用~workerの作成には、
`SharedWorker()$m
構築子を利用する。
この構築子は、利用する~scriptの~URLを第一~引数にとり，~workerの名前を（もしあれば）第二~引数にとる。
◎
Creating shared workers is done using the SharedWorker() constructor. This constructor takes the URL to the script to use for its first argument, and the name of the worker, if any, as the second argument.
</p>

<pre>
var %worker = new SharedWorker('service.js');
</pre>


<p>
共用~workerとの通信ingは、明示的な
`MessagePort$I ~objを通して行われる。
`SharedWorker()$m 構築子から返される~objは，その~portへの参照を
`port$m 属性に保持する。
◎
Communicating with shared workers is done with explicit MessagePort objects. The object returned by the SharedWorker() constructor holds a reference to the port on its port attribute.
</p>

<pre>
%worker.port.onmessage = function (%event) { ... };
%worker.port.postMessage('some message');
%worker.port.postMessage({
   foo: 'structured',
   bar: ['data', 'also', 'possible']
});
</pre>

<p>
共用~workerの内側では、
`connect$et ~eventにより，~workerの新たな~clientの存在が告知される。
新たな~clientのための~portは、~event~objの
`source$m 属性により与えられる。
◎
Inside the shared worker, new clients of the worker are announced using the connect event. The port for the new client is given by the event object's source attribute.
</p>

<pre>
onconnect = function (%event) {
  var %newPort = %event.source;
  // <span class="comment"
	title="set up a listener"
	>~listenerの設置</span>
  %newPort.onmessage = function (%event) { ... };
  // <span class="comment"
	title="send a message back to the port"
	>~portに~messageを返信</span>
  %newPort.postMessage('ready!'); // <span class="comment"
	title="can also send structured data, of course"
	>もちろん、有構造~dataも返信できる</span>
};
</pre>

			</section>
		</section>
	</section>

	<section id="_conventions">
<h3 class="trans-note">【日本語訳に固有の表記規約】</h3>

<ul>
	<li>
この訳の~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</li>
	<li>
此れとは、`文脈~obj$の略記である。
</li>
	<li>
`文書@
は、 `Document$I ~objの略記である。
</li>
</ul>


	</section>

	<section id="infrastructure-2">

<h2 title="Infrastructure">10.2. 基盤</h2>

<p>
~workerは、専用~workerと共用~workerの２つに大別される。
専用~workerは、作成-時にその作成元に~linkされるが、~message~portを利用すれば，他の閲覧文脈や~workerに向けても通信できる。
一方で，共用~workerは、名前を持ち，その作成-後に それへの参照を得ておけば、同じ`生成元$上で走っているどの~scriptとも通信できる。
◎
There are two kinds of workers; dedicated workers, and shared workers. Dedicated workers, once created, are linked to their creator; but message ports can be used to communicate from a dedicated worker to multiple other browsing contexts or workers. Shared workers, on the other hand, are named, and once created any script running in the same origin can obtain a reference to that worker and communicate with it.
</p>

		<section id="the-global-scope">

<h3 title="The global scope">10.2.1. 大域~scope</h3>

<p>
大域~scopeが~workerの “内側” である。
◎
The global scope is the "inside" of a worker.
</p>

<p class="trans-note">【
すなわち，同じ~workerが、その中で走っている~scriptに公開する `WorkerGlobalScope$I ~obj（大域~scope）と,
その~workerを外側から利用する~scriptに公開する `Worker$I ~objの， “二つの顔” を持つ（共用~workerの場合、後者は，~workerを共有している大域~環境ごとに別々に，複数個あり得る）。
】</p>

			<section id="the-workerglobalscope-common-interface">
<h4 title="The WorkerGlobalScope common interface">10.2.1.1. `WorkerGlobalScope^I 共通~interface</h4>


⇒！
[Exposed=Worker]
interface `WorkerGlobalScope@I : `EventTarget$I {
  readonly attribute `WorkerGlobalScope$I `self$m;
  readonly attribute `WorkerLocation$I `location$m;
  readonly attribute `WorkerNavigator$I `navigator$m;
  void `importScripts$m(USVString... %urls);

  attribute `OnErrorEventHandler$I `onerror$hd;
  attribute `EventHandler$I `onlanguagechange$hd;
  attribute `EventHandler$I `onoffline$hd;
  attribute `EventHandler$I `ononline$hd;
  attribute `EventHandler$I `onrejectionhandled$hd;
  attribute `EventHandler$I `onunhandledrejection$hd;
};
◎

<p>
各 `WorkerGlobalScope$I ~objには、次のものが結付けられる（括弧内は初期~値）：
</p>

<dl class="def-list">
	<dt>`種別@wG</dt>
	<dd>
次のいずれか
⇒
`classic^l ／ `module^l
◎
A WorkerGlobalScope object has an associated type ("classic" or "module"). It is set during creation.
</dd>

	<dt>`~url@wG（ ~NULL ）</dt>
	<dd>
~NULL または `~URL$
◎
A WorkerGlobalScope object has an associated url (null or a URL). It is initially null.
</dd>

	<dt>`~HTTPS状態@wG（ `none^l ）</dt>
	<dd>
`~HTTPS状態~値$
◎
A WorkerGlobalScope object has an associated HTTPS state (an HTTPS state value). It is initially "none".
</dd>

	<dt>`~referrer施策@wG（空~文字列）</dt>
	<dd>
`~referrer施策$
◎
A WorkerGlobalScope object has an associated referrer policy (a referrer policy). It is initially the empty string.
</dd>

	<dt>`~CSP~list@wG（空~list）</dt>
	<dd>
<a href="~CSP3#policy">Content Security Policy ~obj</a>
の~list
◎
A WorkerGlobalScope object has an associated CSP list. It is initially an empty list.
</dd>

	<dt>`~module~map@wG（空）</dt>
	<dd>
`~module~map$
◎
A WorkerGlobalScope object has an associated module map. It is a module map, initially empty.
</dd>

</dl>


<dl class="domintro">
	<dt>%workerGlobal . `self$m</dt>
	<dd>
%workerGlobal 自身を返す。
◎
Returns workerGlobal.
</dd>

	<dt>%workerGlobal . `location$m</dt>
	<dd>
%workerGlobal の `WorkerLocation$I ~objを返す。
◎
Returns workerGlobal's WorkerLocation object.
</dd>

	<dt>%workerGlobal . `navigator$m</dt>
	<dd>
%workerGlobal の `WorkerNavigator$I ~objを返す。
◎
Returns workerGlobal's WorkerNavigator object.
</dd>

	<dt>%workerGlobal . `importScripts(urls...)$m</dt>
	<dd>
%urls 内の各`~URL$を、渡された順に一つずつ，~fetchして, 実行して, 結果を返すか例外を投出する。
◎
Fetches each URL in urls, executes them one-by-one in the order they are passed, and then returns (or throws if something went amiss).
</dd>
</dl>

<dl class="idl-def">
	<dt>`self@m</dt>
	<dd>
取得子は、此れを返さ~MUST。
◎
The self attribute must return the WorkerGlobalScope object itself.
</dd>

	<dt>`location@m</dt>
	<dd>
取得子は、 `WorkerLocation$I ~objであって, ［
その`~worker大域~scope$ ~EQ 此れ
］なるものを返さ~MUST。
◎
The location attribute must return the WorkerLocation object whose associated WorkerGlobalScope object is the WorkerGlobalScope object.
</dd>
	<dd class="note">
`WorkerLocation$I ~objが作成されるのは，
`WorkerGlobalScope$I ~objより後になるが、それは~scriptからは観測し得ないので，問題にはならない。
◎
While the WorkerLocation object is created after the WorkerGlobalScope object, this is not problematic as it cannot be observed from script.
</dd>

</dl>

<hr>

<p>
`WorkerGlobalScope$I
~interfaceを実装する~objにおいては、次の`~event~handler$（および，それらに対応する`~event~handler ~event型$）が`~event~handler IDL 属性$として~supportされ~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the WorkerGlobalScope interface:
</p>

<table>
<thead><tr><th>~event~handler
<th>~event~handler ~event型
</thead>

<tbody><tr><td>`onerror@hd
<td>`error$et

<tr><td>`onlanguagechange@hd
<td>`languagechange$et

<tr><td>`onoffline@hd
<td>`offline$et

<tr><td>`ononline@hd
<td>`online$et

<tr><td>`onrejectionhandled@hd
<td>`rejectionhandled$et

<tr><td>`onunhandledrejection@hd
<td>`unhandledrejection$et

</tbody></table>

			</section>
			<section id="dedicated-workers-and-the-dedicatedworkerglobalscope-interface">

<h4 title="Dedicated workers and the DedicatedWorkerGlobalScope interface">10.2.1.2. 専用~workerと `DedicatedWorkerGlobalScope^I ~interface</h4>

⇒！
[Global=(Worker,DedicatedWorker),Exposed=DedicatedWorker]
interface `DedicatedWorkerGlobalScope@I : `WorkerGlobalScope$I {
  void `~postMessage0$m(any %message, optional sequence&lt;`object$I&gt; transfer = []);

  void `~close0$m();

  attribute `EventHandler$I `~onmessage0$hd;
};
◎

<p>
各 `DedicatedWorkerGlobalScope$I ~objには、
`MessagePort$I ~objである
`暗黙的な~port@
が結付けられているかのように，動作し~MUST。
この~port~objは、~worker作成-時に設置される~channelの一部をなすが，公開されることはない。
この~port~objは、決して `DedicatedWorkerGlobalScope$I ~objより先に~garbage収集されてはならない。
◎
DedicatedWorkerGlobalScope objects act as if they had an implicit MessagePort associated with them. This port is part of a channel that is set up when the worker is created, but it is not exposed. This object must never be garbage collected before the DedicatedWorkerGlobalScope object.
</p>

<p>
`暗黙的な~port$から受信されるすべての~messageは、即時に
`DedicatedWorkerGlobalScope$I
~objに渡され~MUST。
◎
All messages received by that port must immediately be retargeted at the DedicatedWorkerGlobalScope object.
</p>


<dl class="domintro">
	<dt>%dedicatedWorkerGlobal . `postMessage(message [, transfer ])$m</dt>
	<dd>
~messageを~cloneして，それを
%dedicatedWorkerGlobal に結付けられている `Worker$I ~objへ伝送する。
%transfer に、~cloneせずに転送させる~objの~listを渡せる。
◎
Clones message and transmits it to the Worker object associated with dedicatedWorkerGlobal. transfer can be passed as a list of objects that are to be transferred rather than cloned.
</dd>

	<dt>%dedicatedWorkerGlobal . `~close0()$m</dt>
	<dd>
%dedicatedWorkerGlobal を中止する。
◎
Aborts dedicatedWorkerGlobal.
</dd>
</dl>

<dl class="idl-def">
	<dt>`~postMessage0()@m</dt>
	<dd>
被呼出時には、それが即時に，此れの`暗黙的な~port$上の`同じ名前の~method$を同じ引数で呼出して, 同じ値を返したかのように，動作し~MUST。
◎
The postMessage() method on DedicatedWorkerGlobalScope objects must act as if, when invoked, it immediately invoked the method of the same name on the port, with the same arguments, and returned the same return value.
</dd>

</dl>

<p class="algo-head">
所与の %workerGlobal に対し，
`~workerを~close@
するときは、次の手続きを走らす：
◎
To close a worker, given a workerGlobal, run these steps:
</p>

<ol>
	<li>
%workerGlobal の`~eventloop$の`~task待行列$に追加された`~task$は、すべて破棄する
◎
Discard any tasks that have been added to workerGlobal's event loop's task queues.
</li>
	<li>
%workerGlobal の`~closing~flag$i ~SET ~ON
（これにより、~taskがそれ以上~待行列に入れられることはなくなる。）
◎
Set workerGlobal's closing flag to true. (This prevents any further tasks from being queued.)
</li>
</ol>


<dl class="idl-def">
	<dt>`~close0()@m</dt>
	<dd>
被呼出時には、此れを与える下で，`~workerを~close$し~MUST。
◎
The close() method, when invoked, must close a worker with this DedicatedWorkerGlobalScope object.
</dd>

</dl>

<hr>


<p>
`DedicatedWorkerGlobalScope$I
~interfaceを実装する~objにおいては、次の`~event~handler$（および，それらに対応する`~event~handler ~event型$）が`~event~handler IDL 属性$として~supportされ~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the DedicatedWorkerGlobalScope interface:
</p>

<table>
<thead><tr>
<th>~event~handler
<th>~event~handler ~event型
</thead>

<tbody><tr><td>`~onmessage0@hd
<td>`message$et

</tbody></table>

<p>
<span class="trans-note">【
`~app-cache関連$の記述（この訳では省略する）。
】</span>
◎
For the purposes of the application cache networking model, a dedicated worker is an extension of the cache host from which it was created.
</p>

			</section>
			<section id="shared-workers-and-the-sharedworkerglobalscope-interface">

<h4 title="Shared workers and the SharedWorkerGlobalScope interface">10.2.1.3. 共用~workerと `SharedWorkerGlobalScope^I ~interface</h4>

⇒！
[Global=(Worker,SharedWorker),Exposed=SharedWorker]
interface `SharedWorkerGlobalScope@I : `WorkerGlobalScope$I {
  readonly attribute DOMString `name$m;

  void `close$m();

           attribute `EventHandler$I `onconnect$hd;
};
◎

<p>
各 `SharedWorkerGlobalScope$I ~objには、［
`構築子~生成元@wG
,
`構築子~url@wG
,
`名前@wG
］が結付けられる。
これらは、~objの作成-時に`~workerを走らす$~algoにて初期化される。
◎
A SharedWorkerGlobalScope object has an associated constructor origin, constructor url, and name. They are initialized when the SharedWorkerGlobalScope object is created, in the run a worker algorithm.
</p>

<p>
共用~workerは、その `SharedWorkerGlobalScope$I ~obj上の
`connect$et ~eventを通して，各~接続の~message~portを受信する。
◎
Shared workers receive message ports through connect events on their SharedWorkerGlobalScope object for each connection.
</p>



<dl class="domintro">
	<dt>%sharedWorkerGlobal . `name$m</dt>
	<dd>
%sharedWorkerGlobal の`名前$wGを返す。
◎
Returns sharedWorkerGlobal's name.
</dd>

	<dt>%sharedWorkerGlobal . `close()$m</dt>
	<dd>
%sharedWorkerGlobal を中止する。
◎
Aborts sharedWorkerGlobal.
</dd>
</dl>


<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
取得子は、此れの`名前$wGを返さ~MUST。
この値は、 `SharedWorker$I 構築子を用いて~workerへの参照を取得するときに利用できる名前を表現する。
◎
The name attribute must return the SharedWorkerGlobalScope object's name. Its value represents the name that can be used to obtain a reference to the worker using the SharedWorker constructor.
</dd>

	<dt>`close()@m</dt>
	<dd>
被呼出時には、此れを与える下で，`~workerを~close$し~MUST。
◎
The close() method, when invoked, must close a worker with this SharedWorkerGlobalScope object.
</dd>

</dl>

<hr>

<p>
`SharedWorkerGlobalScope$I
~interfaceを実装する~objにおいては、次の`~event~handler$（および，それらに対応する`~event~handler ~event型$）が`~event~handler IDL 属性$として~supportされ~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the SharedWorkerGlobalScope interface:
</p>

<table>
<thead><tr><th>~event~handler
<th>~event~handler ~event型
</thead>

<tbody><tr><td>`onconnect@hd
<td>`connect$et

</tbody></table>

			</section>
		</section>

		<section id="worker-event-loop">

<h3 title="The event loop">10.2.2. ~eventloop</h3>

<p>
各 `WorkerGlobalScope$I ~objは、次のものを持つ：
◎
↓</p>

<dl class="def-list">
	<dt>`~eventloop@</dt>
	<dd>
<p>
この`~eventloop$xは：
</p>

<ul><li>`互いに関係するかつ生成元も類似する閲覧文脈~群$に対し定義されるそれとは別々の，異なる`~eventloop$xであり、`閲覧文脈$には結付けられない。
</li><li>その`~task待行列$に入れられ得る`~task$は、［
~event, ~callback, ~networking活動
］に限られる。
</li><li>`~workerを走らす$~algoにより作成される。
</li></ul>

◎
Each WorkerGlobalScope object has a distinct event loop, separate from those used by units of related similar-origin browsing contexts. This event loop has no associated browsing context, and its task queues only have events, callbacks, and networking activity as tasks. These event loops are created by the run a worker algorithm.
</dd>

	<dt>`~closing~flag@i</dt>
	<dd>
<p>
この~flagは：
</p>

<ul ><li>初期~時には ~OFF にされ~MUST。
</li><li>下の処理~model節の~algoにより， ~ON にされ得る。
</li><li>~ON にされたときは
⇒
`~eventloop$の`~task待行列$は，それ以降に追加される`~task$を破棄し~MUST（待行列の中の~~既存の~taskは、特に指定されない限り，影響されない）。
実質的には、`~closing~flag$iが ~ON になったなら，［
~timerは発火を止め,
処理待ちにあるすべての~background演算の通知は取り除かれる,
等々
］が行われる。
</li></ul>

◎
Each WorkerGlobalScope object also has a closing flag, which must initially be false, but which can get set to true by the algorithms in the processing model section below.
◎
Once the WorkerGlobalScope's closing flag is set to true, the event loop's task queues must discard any further tasks that would be added to them (tasks already on the queue are unaffected except where otherwise specified). Effectively, once the closing flag is true, timers stop firing, notifications for all pending background operations are dropped, etc.
</dd>
</dl>






		</section>
		<section id="the-worker's-lifetime">

<h3 title="The worker's lifetime">10.2.3. ~workerの存続期間</h3>

<p>
~workerは、`~message~channel$とそれらの
`MessagePort$I ~objを通して，他の~workerや`閲覧文脈$と通信する。
◎
Workers communicate with other workers and with browsing contexts through message channels and their MessagePort objects.
</p>

<p>
各 `WorkerGlobalScope$I ~objは、次のものを持つ：
◎
↓</p>

<dl class="def-list">
	<dt>`~port~list@</dt>
	<dd>
<p>
次を満たすような `MessagePort$I ~objすべてからなる，~list：
</p>

<ul ><li>別の~portと`連絡$（ entangle ）されていて, かつ
</li><li>この~objに所有されている~portをきっかり１つ持つ。
</li></ul>

<p>
この~listには`専用~worker$の`暗黙的な~port$も含まれる。
</p>

◎
Each WorkerGlobalScope worker global scope has a list of the worker's ports, which consists of all the MessagePort objects that are entangled with another port and that have one (but only one) port owned by worker global scope. This list includes the implicit MessagePort in the case of dedicated workers.
</dd>

	<dt>`~worker~list@</dt>
	<dd>
初期~時には空~list。
この~workerが更なる~workerを作成-／取得したときに拡充される。
◎
Each WorkerGlobalScope also has a list of the worker's workers. Initially this list is empty; it is populated when the worker creates or obtains further workers.
</dd>

	<dt>`文書~list@</dt>
	<dd>
初期~時には空~list。
この~workerの作成-時に拡充される。
◎
Finally, each WorkerGlobalScope also has a list of the worker's Documents. Initially this list is empty; it is populated when the worker is created.
</dd>
</dl>

<p class="algo-head">
~UAは、`文書$ %D を~worker %~worker の
`文書~listに追加-@
するときは、次を行わ~MUST
⇒
~FOR
%~worker の`~worker~list$内の~EACH ( ~worker %Q )
に対し
⇒
~IF［
%D ~NIN %Q の`文書~list$
］
⇒
%D を %Q の `WorkerGlobalScope$I 所有者の`文書~listに追加-$する
<!-- WorkerGlobalScope owner's list ? -->
◎
Whenever a Document d is added to the worker's Documents, the user agent must, for each worker q in the list of the worker's workers whose list of the worker's Documents does not contain d, add d to q's WorkerGlobalScope owner's list of the worker's Documents.
</p>

<p>
`文書$が`破棄-$されたときは，常に、各~workerの`文書~list$から，その`文書$が（もしあれば）除去され~MUST。
◎
Whenever a Document object is discarded, it must be removed from the list of the worker's Documents of each worker whose list contains that Document.
</p>


<div class="p">
<p>
所与の`環境~設定群~obj$ %O の下で，［
~workerを作成する／取得する際に，
`追加する関連の文書@
%文書s
］は、 %O `の大域~obj$ %G に依存する：
</p>

<ul>
	<li>
%G が
`WorkerGlobalScope$I
~objである場合（すなわち，入子の~workerを作成している場合）、
%文書s は， %G の `文書~list$で与えられる。
</li>
	<li>
他の場合， %G は `Window$I ~objであり、
%文書s は，単に %O により指定される`担当の文書$enVで与えられる。
</li>
</ul>

◎
Given an environment settings object o when creating or obtaining a worker, the list of relevant Document objects to add depends on the type of global object specified by o. If o specifies a global object that is a WorkerGlobalScope object (i.e. if we are creating a nested worker), then the relevant Documents are the the worker's Documents of the global object specified by o. Otherwise, o specifies a global object that is a Window object, and the relevant Document is just the responsible document specified by o.
</div>


<hr>

<div class="p">
<p>
次のいずれかを満たす~workerは、
`許可対象@
（ permissible ）にあるとされる：
</p>

<ul>
	<li>
その`文書~list$は、空でない。
</li>
	<li>
<p>
次のいずれも満たす
</p>
		<ul >
			<li>
その`文書~list$は、~UAにより定義される短い~timeout値を超えて空であり続けることはない。
</li>
			<li>
その `WorkerGlobalScope$I ~objは、実際に
`SharedWorkerGlobalScope$I ~objである（すなわち，~workerは共用~workerである）
</li>
			<li>
~UAには、`文書$が `完全に読込まれて$はいないような`閲覧文脈$がある。
</li>
		</ul>
	</li>
</ul>
◎
A worker is said to be a permissible worker if its list of the worker's Documents is not empty, or if its list has been empty for no more than a short user-agent-defined timeout value, its WorkerGlobalScope is actually a SharedWorkerGlobalScope object (i.e. the worker is a shared worker), and the user agent has a browsing context whose Document is not completely loaded.
</div>

<p>
上の定義の二番目の方は、~pageが読込まれている短い時間，~pageが共用~workerに再び繋がろうとしている下でも、共用~workerが生存できるようにする。
これを利用すれば、~UAは，［
利用者が その~siteの中で~pageから~pageへ遷移するとき
］に［
~siteに利用されている共用~workerの再始動~cost
］を避けれるようになる。
◎
The second part of this definition allows a shared worker to survive for a short time while a page is loading, in case that page is going to contact the shared worker again. This can be used by user agents as a way to avoid the cost of restarting a shared worker used by a site when the user is navigating from page to page within that site.
</p>

<p>
~workerは、その`文書~list$に属するいずれかの`文書$が`全部的に作動中$であるとき，
`作動中必要@
（ active needed ）とされる。
◎
A worker is said to be an active needed worker if any of the Document objects in the worker's Documents are fully active.
</p>


<div class="p">
<p>
`作動中必要$であって，次のいずれかを満たす~workerは、
`保護下@
（ protected ）にあるとされる：
</p>

<ul><li>未終了の~timerを持つ。
</li><li>~database~transactionを持つ。
</li><li>~network接続を持つ。
</li><li>`~port~list$は空でない。
</li><li>その `WorkerGlobalScope$I は実際に `SharedWorkerGlobalScope$I ~objである（すなわち，~workerは共用~workerである）
</li></ul>

◎
A worker is said to be a protected worker if it is an active needed worker and either it has outstanding timers, database transactions, or network connections, or its list of the worker's ports is not empty, or its WorkerGlobalScope is actually a SharedWorkerGlobalScope object (i.e. the worker is a shared worker).
</div>


<p>
`作動中必要$でない`許可対象$の~workerは、
`休止可能@
（ suspendable ）にあるとされる。
◎
A worker is said to be a suspendable worker if it is not an active needed worker but it is a permissible worker.
</p>

		</section>
		<section id="worker-processing-model">

<h3 title="Processing model">10.2.4. 処理~model</h3>


<div>

<p class="algo-head">
~UAは、~scriptに対する
`~workerを走らす@
ときは、所与の：
</p>

<ul ><li>%~worker （ `Worker$I ／ `SharedWorker$I ~obj ）
</li><li>%url （ `~URL$ ）
</li><li>%外側~設定群 （ `環境~設定群~obj$ ）
</li><li>%外側~port （ `MessagePort$I ~obj ）
</li><li>%options （ `WorkerOptions$I 辞書 ）
</li><li>%名前 （文字列, 省略可
— %~worker が `SharedWorker$I の場合は常に供される）
</li></ul>

<p>
に対し，次の手続きを走らせ~MUST：
</p>

◎
When a user agent is to run a worker for a script with Worker or SharedWorker object worker, URL url, environment settings object outside settings, MessagePort outside port, a WorkerOptions dictionary options, and an optional string name, it must run the following steps. (name is always provided when worker is a SharedWorker.)
</div>


<ol>
	<li id="worker-processing-model-top">

<p>
別々の並列的~実行~環境（すなわち，別の~threadや~processまたはそれに等価なもの）を作成した上で、この手続きの以下の部分をその文脈の下で走らす。
◎
Create a separate parallel execution environment (i.e. a separate thread or process or equivalent construct), and run the rest of these steps in that context.
</p>

<p>
計時~APIの目的においては，これが~workerの
`公式的な作成~時点@
になる。
◎
For the purposes of timing APIs, this is the official moment of creation of the worker.
</p>

	</li>
	<li>
%共用is ~LET ［
%~worker は `SharedWorker$I ~objであるならば ~T ／
~ELSE_ ~F
］
◎
Let is shared be true if worker is a SharedWorker object, and false otherwise.
</li>
	<li>
%文書s ~LET
%外側~設定群 から与えられる，`追加する関連の文書$
◎
Let docs be the list of relevant Document objects to add given outside settings.
</li>
	<li>
%親~worker大域~scope ~LET ~NULL
◎
Let parent worker global scope be null.
</li>
	<li>
~IF［
%外側~設定群 `の大域~obj$は `WorkerGlobalScope$I ~objである（すなわち、この手続きは入子の~workerを作成している）
］
⇒
%親~worker大域~scope ~SET %外側~設定群 `の大域~obj$
◎
If outside settings's global object is a WorkerGlobalScope object (i.e. we are creating a nested worker), set parent worker global scope to outside settings's global object.
</li>
	<li>
<p>
次のように~custom化する下で，~JSの
`InitializeHostDefinedRealm()$ 抽象演算を~callする：
◎
Call the JavaScript InitializeHostDefinedRealm() abstract operation with the following customizations:
</p>

		<ul>
			<li>
<p>
%~worker大域~scope ~LET %共用is に応じて，次で与えられる~obj：
</p>

<dl class="switch"
	><dt>~T
</dt><dd>大域~objに対する 新たな `SharedWorkerGlobalScope$I ~obj
</dd><dt>~F
</dt><dd>大域~objに対する 新たな `DedicatedWorkerGlobalScope$I ~obj
</dd></dl>

◎
For the global object, if is shared is true, create a new SharedWorkerGlobalScope object. Otherwise, create a new DedicatedWorkerGlobalScope object. Let worker global scope be the created object.
</li>
			<li>
%~realm実行~環境 ~LET 作成された`~JS実行~文脈$
◎
Let realm execution context be the created JavaScript execution context.
</li>
		</ul>
	</li>
	<li>
%内側~設定群 ~LET 次を与える下で，`~workerの環境~設定群~objを設定して$おいた結果
⇒
( %~realm実行~環境, %外側~設定群 )
◎
Set up a worker environment settings object with realm execution context and outside settings, and let inside settings be the result.
</li>
	<li>
~IF［
%共用is ~EQ ~T
］
⇒
%~worker大域~scope の ( `構築子~生成元$wG, `構築子~url$wG, `名前$wG ) ~SET ( %外側~設定群 の`生成元$enV, %url, %名前 )
◎
If is shared is true, then:
◎
• Set worker global scope's constructor origin to outside settings's origin.
◎
• Set worker global scope's constructor url to url.
◎
• Set worker global scope's name to name.
</li>
	<li>
%行先 ~LET ［
%共用is ~EQ ~T ならば `sharedworker^l ／
~ELSE_ `worker^l
］
◎
Let destination be "sharedworker" if is shared is true, and "worker" otherwise.
</li>
	<li>
<p>
%options の `type^m ~memberの値に応じて，次に従って~scriptを得る：
◎
Obtain script by switching on the value of options's type member:
</p>

		<dl class="switch">
			<dt>`classic^l</dt>
			<dd>
次を与える下で，`~worker用~classic~scriptを~fetchする$
⇒
( %~url, %外側~設定群, %行先, %内側~設定群 )
◎
Fetch a classic worker script given url, outside settings, destination, and inside settings.
</dd>
			<dt>`module^l</dt>
			<dd>
次を与える下で，`~worker用~module~script~graphを~fetchする$
⇒
(
%~url,
%外側~設定群,
%行先,
%options の `credentials^m ~memberの値,
%内側~設定群
)
◎
Fetch a module worker script graph given url, outside settings, destination, the value of the credentials member of options, and inside settings.
</dd>
		</dl>


<p>
いずれの場合も，`~fetchを遂行する$ときは、所与の
( %要請, `~top-level内~flag$V )
に対し，［
`~top-level内~flag$V ~EQ ~ON
］ならば，次の手続きを遂行する：
◎
In both cases, to perform the fetch given request, perform the following steps if the is top-level flag is set:
</p>

		<ol>
			<li>
%要請 の`予約済み~client$rq ~SET %内側~設定群
◎
Set request's reserved client to inside settings.
</li>
			<li>
%要請 を`~fetch$する
— ~fetchし終えるまで非同期に待機した上で，以降の手続きを［
結果の`応答$ %応答 に対し ~fetchの`応答を処理する$
］一部として走らす
◎
Fetch request, and asynchronously wait to run the remaining steps as part of fetch's process response for the response response.
</li>
			<li>
%~worker大域~scope の`~url$wG ~SET %応答 の `~url$rs
◎
Set worker global scope's url to response's url.
</li>
			<li>
%~worker大域~scope の`~HTTPS状態$wG ~SET %応答 の`~HTTPS状態$rs
◎
Set worker global scope's HTTPS state to response's HTTPS state.
</li>
			<li>
%~worker大域~scope の`~referrer施策$wG ~SET
%応答 の
<a href="~REFERRER-POLICY#parse-referrer-policy-from-header">`Referrer-Policy^h ~headerを構文解析-</a>
した結果
◎
Set worker global scope's referrer policy to the result of parsing the `Referrer-Policy` header of response.
</li>
			<li>
次を与える下で，
<a href="~CSP3#initialize-global-object-csp">大域~objの~CSP~listを初期化する</a>
`CSP$r
⇒
( %~worker大域~scope, %応答 )
◎
Execute the Initialize a global object's CSP list algorithm on worker global scope and response. [CSP]
</li>
			<li>
%応答 を結果として`非同期に完了-$する
◎
Asynchronously complete the perform the fetch steps with response.
</li>
		</ol>
	</li>
	<li>
<p>
前~段が %~script を結果として`非同期に完了-$するまで待機した上で：
</p>
		<ol>
			<li>
<p>
~IF［
%~script ~EQ ~NULL
］：
</p>
				<ol>
					<li>
次を行う`~taskを待入する$
⇒
%~worker に向けて，名前 `error$et の`~eventを発火-$する
</li>
					<li>
~RET
</li>
			</ol>
		</li>
	</ol>
◎
If the algorithm asynchronously completes with null, queue a task to fire an event named error at worker, and abort these steps. Otherwise, continue the rest of these steps after the algorithm's asynchronous completion, with script being the asynchronous completion value.
</li>
	<li>
%~worker を %~worker大域~scope に結付ける
◎
Associate worker with worker global scope.
</li>
	<li>
%内側~port ~LET ［
`所有者$： %内側~設定群
］の下で作成される，`新たな~MessagePort~obj$
◎
Create a new MessagePort object whose owner is inside settings. Let inside port be this new object.
</li>
	<li>
%内側~port を %~worker大域~scope に結付ける
◎
Associate inside port with worker global scope.
</li>
	<li>
%外側~port と %内側~port を`連絡$する
◎
Entangle outside port and inside port.
</li>
	<li>
%文書s 内の一連の`文書$を，
%~worker大域~scope の`文書~listに追加-$する
◎
Add to worker global scope's list of the worker's Documents the Document objects in docs.
</li>
	<li>
~IF［
%親~worker大域~scope ~NEQ ~NULL
］
⇒
%~worker大域~scope を
%親~worker大域~scope の`~worker~list$に追加する
◎
If parent worker global scope is not null, add worker global scope to the list of the worker's workers of parent worker global scope.
</li>
	<li>
%~worker大域~scope の`種別$wG ~SET %options の `type^m ~memberの値
◎
Set worker global scope's type to the value of the type member of options.
</li>
	<li>
新たな `WorkerLocation$I ~objを作成して，それに %~worker大域~scope を結付ける
◎
Create a new WorkerLocation object and associate it with worker global scope.
</li>
	<li>
<strong>孤立~workerの closing</strong>：
<p>
~workerの監視を開始する：
~workerが`保護下$でなくなり次第、`許可対象$であり続ける間まで，
%~worker大域~scope の`~closing~flag$iは ~ON にする。
◎
Closing orphan workers: Start monitoring the worker such that no sooner than it stops being a protected worker, and no later than it stops being a permissible worker, worker global scope's closing flag is set to true.
</li>
	<li>
<strong>~workerの休止</strong>：
<p>
~workerの監視を開始する：
~UAは、［
%~worker大域~scope の`~closing~flag$iが ~OFF にされ, かつ
~workerが`休止可能$にされ
］次第、~worker内の~scriptの実行を，［
`~closing~flag$iが ~ON に切替えられるか
］, または［
~workerが`休止可能$でなくなる
］まで、休止させる
◎
Suspending workers: Start monitoring the worker, such that whenever worker global scope's closing flag is false and the worker is a suspendable worker, the user agent suspends execution of script in that worker until such time as either the closing flag switches to true or the worker stops being a suspendable worker.
</li>
	<li>
%内側~設定群 の`実行~準備済み~flag$ ~SET ~ON
◎
Set inside settings's execution ready flag.
</li>
	<li>

<div>
<p>
%~script に応じて：
</p>

		<dl class="switch">
			<dt>`~classic~script$である</dt>
			<dd>
( %~script )
を与える下で，`~classic~scriptを走らす$
</dd>
			<dt>`~module~script$である</dt>
			<dd>
( %~script )
を与える下で，`~module~scriptを走らす$
</dd>
		</dl>
◎
If script is a classic script, then run the classic script script. Otherwise, it is a module script; run the module script script.
</div>

<p class="note">注記：
通例の［
値を返す, 例外による失敗-
］に加えて、これは、下に定義される［
`~workerを強制終了する$ ／ `~workerを終了させる$
］~algoにより`尚早に中止され$ることもある。
◎
In addition to the usual possibilities of returning a value or failing due to an exception, this could be prematurely aborted by the "kill a worker" or "terminate a worker" algorithms defined below.
</p>
	</li>
	<li>
%外側~port の`~port~message待行列$を可能化する
◎
Enable outside port's port message queue.
</li>
	<li>
~IF［
%共用is ~EQ ~F
］
⇒
~workerの暗黙的な~portの`~port~message待行列$を可能化する
◎
If is shared is false, enable the port message queue of the worker's implicit port.
</li>
	<li>
<p>
~IF［
%共用is ~EQ ~T
］
⇒
%~task ~LET `~DOM操作~task源$を利用して，［
%~worker大域~scope に向けて，次のようにされた`~eventを発火-$する
］`~taskを待入する$：
</p>

<ul ><li>`MessageEvent$I ~interfaceを利用する
</li><li>名前 `connect$et
</li><li>各種~属性は次のように初期化する：
	<ul><li>`data$m 属性 ~SET 空文字列
	</li><li>`ports$m 属性 ~SET %内側~port のみを含む新たな`凍結~配列$
	</li><li>`source$m 属性 ~SET %内側~port
	</li></ul>
</li></ul>

◎
If is shared is true, then queue a task, using the DOM manipulation task source, to fire an event named connect at worker global scope, using MessageEvent, with the data attribute initialized to the empty string, the ports attribute initialized to a new frozen array containing inside port, and the source attribute initialized to inside port.
</li>
	<li>
［
%~worker大域~scope に`関連する設定群~obj$を，`~sw~client$として結付けている
`ServiceWorkerContainer$I ~obj
］の`~client~message待行列$を可能化する
◎
Enable the client message queue of the ServiceWorkerContainer object whose associated service worker client is worker global scope's relevant settings object.
</li>
	<li>
<p>
%内側~設定群 により指定される`担当の~eventloop$enVを，それが破壊されるまで走らす。
◎
Event loop: Run the responsible event loop specified by inside settings until it is destroyed.
</p>

<p class="note">注記：
`~eventloop$が走らす`~task$による，~eventの取扱いや~callbackの実行は、下で定義される［
“`~workerを強制終了する$”
または
“`~workerを終了させる$”
］~algoにより，`尚早に中止され$得る。
◎
The handling of events or the execution of callbacks by tasks run by the event loop might get prematurely aborted by the "kill a worker" or "terminate a worker" algorithms defined below.
</p>

<p class="note">注記：
この段における~workerの処理~modelは、`~eventloop$処理~modelに述べられるように，［
`~closing~flag$iが ~ON にされた後の，~eventloopが破壊される
］まで、残り続ける。
◎
The worker processing model remains on this step until the event loop is destroyed, which happens after the closing flag is set to true, as described in the event loop processing model.
</p>

	</li>
	<li>
%~worker大域~scope の`作動中の~timerの~list$を空にする
◎
Empty the worker global scope's list of active timers.
</li>
	<li>
%~worker大域~scope の`~port~list$内のすべての~portに対し、それぞれの`連絡$を~~解く
◎
Disentangle all the ports in the list of the worker's ports.
</li>
	<li>
%~worker大域~scope の`文書~list$を空にする
◎
Empty the worker's list of the worker's Documents.
</li>
</ol>


<hr>

<p class="algo-head">
~UAが
`~workerを強制終了する@
ときは、~workerの~main~loop（すなわち，上で定義した
“`~workerを走らす$”
処理~model）とは`並列的$に，次の手続きを走らせ~MUST：
◎
When a user agent is to kill a worker it must run the following steps in parallel with the worker's main loop (the "run a worker" processing model defined above):
</p>

<ol>
	<li>
%~worker大域~scope ~LET ~workerの `WorkerGlobalScope$I ~obj
◎
↓</li>
	<li>
%~worker大域~scope の`~closing~flag$i ~SET ~ON
◎
Set the worker's WorkerGlobalScope object's closing flag to true.
</li>
	<li>
%~worker大域~scope の`~eventloop$の`~task待行列$に入れられた`~task$があれば、それらは処理せずに，破棄する
◎
If there are any tasks queued in the WorkerGlobalScope object's event loop's task queues, discard them without processing them.
</li>
	<li>
~UAにより定義される時間だけ，待機する
◎
Wait a user-agent-defined amount of time.
</li>
	<li>
~worker内で現在`走っている~scriptを中止-$する
◎
Abort the script currently running in the worker.
</li>
</ol>

<p>
~UAは、いつでも，~worker上の
“`~workerを強制終了する$”
処理~modelを呼出してよい。
例えば、`~closing~flag$iが ~ON にされた後でも，~workerが実行し続けるようであれば、利用者からの要請, CPU の quota 管理, ~workerが`作動中必要$でなくなったときに対応するために。

◎
User agents may invoke the "kill a worker" processing model on a worker at any time, e.g. in response to user requests, in response to CPU quota management, or when a worker stops being an active needed worker if the worker continues executing even after its closing flag was set to true.
</p>

<hr>

<p class="algo-head">
~UAが
`~workerを終了させる@
ときは、~workerの~main~loop
— すなわち，上で定義した “`~workerを走らす$” 処理~model —
とは`並列的$に，次の手続きを走らせ~MUST：
◎
When a user agent is to terminate a worker it must run the following steps in parallel with the worker's main loop (the "run a worker" processing model defined above):
</p>

<ol>
	<li>
%~worker大域~scope ~LET ~workerの `WorkerGlobalScope$I ~obj
◎
↓</li>
	<li>
%~worker大域~scope の`~closing~flag$i ~SET ~ON
◎
Set the worker's WorkerGlobalScope object's closing flag to true.
</li>
	<li>
%~worker大域~scope の`~eventloop$の`~task待行列$に入れられた`~task$があれば、それらを処理せずに，破棄する
◎
If there are any tasks queued in the WorkerGlobalScope object's event loop's task queues, discard them without processing them.
</li>
	<li>
~worker内で現在`走っている~scriptを中止-$する
◎
Abort the script currently running in the worker.
</li>
	<li>
%~worker大域~scope が実際には `DedicatedWorkerGlobalScope$I ~objである場合（すなわち~workerは専用~worker）、
~workerの暗黙的な~portの`~port~message待行列$を空にする
◎
If the worker's WorkerGlobalScope object is actually a DedicatedWorkerGlobalScope object (i.e. the worker is a dedicated worker), then empty the port message queue of the port that the worker's implicit port is entangled with.
</li>
</ol>

<hr>

<p>
上に示された~taskの`~task源$は、`~DOM操作~task源$とする。
◎
The task source for the tasks mentioned above is the DOM manipulation task source.
</p>


		</section>
		<section id="runtime-script-errors-2">

<h3 title="Runtime script errors">10.2.5. 稼働時の~script~error</h3>


<p>
~workerの~scriptのいずれかにおいて，~catchされない稼働時~script~errorが生じた場合、その~errorが以前の~script~errorの取扱い時に生じたものでないならば，~UAは：
◎
↓</p>

<ul>
	<li>
`WorkerGlobalScope$I ~objを target に、~errorが生じた位置（行~番号と列~番号）を伴う，当の`~script$の`~errorを報告-$し~MUST。
◎
Whenever an uncaught runtime script error occurs in one of the worker's scripts, if the error did not occur while handling a previous script error, the user agent must report the error for that script, with the position (line number and column number) where the error occurred, using the WorkerGlobalScope object as the target.
</li>
	<li>
共用~workerに対しては、~errorが依然として`未取扱い$ならば，開発者~consoleに~errorを報告してもよい。
◎
For shared workers, if the error is still not handled afterwards, the error may be reported to a developer console.
</li>
	<li>
<p>
専用~workerに対しては、~errorが依然として`未取扱い$ならば，次を行う~taskを`待入し$~MUST：
◎
For dedicated workers, if the error is still not handled afterwards, the user agent must queue a task to run these steps:

</p>
		<ol>
			<li>
<p>
%notHandled ~LET ~workerに結付けられている `Worker$I ~objに向けて，次のようにされた`~eventを発火-$した結果：
</p>

<ul ><li>`ErrorEvent$I ~interfaceを利用する
</li><li>名前 `error$et
</li><li>`cancelable$m 属性 ~SET ~T に初期化する
</li><li>
~eventの［
`message$m,
`filename$m,
`lineno$m,
`colno$m
］属性は、適切に初期化する
</li><li>~eventの `error$m 属性 ~SET ~NULL に初期化する
</li></ul>
◎
Let notHandled be the result of firing an event named error at Worker object associated with the worker, using ErrorEvent, with the cancelable attribute initialized to true, the message, filename, lineno, and colno attributes initialized appropriately, and the error attribute initialized to null.
</li>
			<li>
~IF［
%notHandled ~EQ ~T
］
⇒
`Worker$I ~objが属する大域~scopeの中で，~catchされなかった稼働時~script~errorが生じたかのように、動作する
— したがって、一段上層においても，稼働時~script~errorの報告~処理-が繰返されることになる。
◎
If notHandled is true, then the user agent must act as if the uncaught runtime script error had occurred in the global scope that the Worker object is in, thus repeating the entire runtime script error reporting process one level up.
</li>
		</ol>
	</li>
</ul>


<p>
［
~workerの `Worker$I ~objに接続している暗黙的な~port
］の`連絡$が~~解かれていた場合（すなわち，親の~workerが終了されていた場合）、~UAは［［
`Worker$I ~objは `error$et ~event~handlerを持っていなかった
］, かつ［
~workerの `onerror$hd 属性は ~NULL であった
］］かのように，動作し~MUST。
他の場合、上述のように動作し~MUST。
◎
If the implicit port connecting the worker to its Worker object has been disentangled (i.e. if the parent worker has been terminated), then the user agent must act as if the Worker object had no error event handler and as if that worker's onerror attribute was null, but must otherwise act as described above.
</p>

<p class="note">注記：
したがって，~error報告-は、専用~workerの連鎖を伝播して
— この連鎖に属する，いずれかの~workerが終了され, ~garbage収集されていたとしても — 
元の`文書$まで伝播される。
◎
Thus, error reports propagate up to the chain of dedicated workers up to the original Document, even if some of the workers along this chain have been terminated and garbage collected.
</p>

<p>
上に示された~taskの`~task源$は、`~DOM操作~task源$とする。
◎
The task source for the task mentioned above is the DOM manipulation task source.
</p>

		</section>
		<section id="creating-workers">

<h3 title="Creating workers">10.2.6. ~workerの作成法</h3>


			<section id="the-abstractworker-abstract-interface">

<h4 title="The AbstractWorker abstract interface">10.2.6.1. `AbstractWorker^I abstract ~interface</h4>

⇒！
[NoInterfaceObject, Exposed=(Window,Worker)]
interface `AbstractWorker@I {
  attribute `EventHandler$I `~onerror0$hd;
};
◎

<p>
`AbstractWorker$I ~interfaceを実装する~objにおいては、次の`~event~handler$（および，それらに対応する`~event~handler ~event型$）が`~event~handler IDL 属性$として~supportされ~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the AbstractWorker interface:
</p>

<table>
<thead><tr><th>`~event~handler$
<th>~event~handler ~event型
</thead>

<tbody><tr><td>`~onerror0@hd
<td>`error$et

</tbody></table>

			</section>
			<section id="script-settings-for-workers">
<h4 title="Script settings for workers">10.2.6.2. ~workerのための~script設定法</h4>

<p class="algo-head">
~UAは、
`~workerの環境~設定群~objを設定して@
おくときは、所与の
( `~JS実行~文脈$ %実行~文脈, `環境~設定群~obj$ %外側~設定群 )
に対し，次の手続きを走らせ~MUST：
◎
When the user agent is required to set up a worker environment settings object, given a JavaScript execution context execution context and environment settings object outside settings, it must run the following steps:
</p>

<ol>
	<li>
`継承 担当の閲覧文脈^V ~LET %外側~設定群 の`担当の閲覧文脈$enV
◎
Let inherited responsible browsing context be outside settings's responsible browsing context.
</li>
	<li>
`継承 生成元^V ~LET %外側~設定群 の`生成元$enV
◎
Let inherited origin be outside settings's origin.
</li>
	<li>
%~worker~eventloop ~LET
新たに作成された`~eventloop$
◎
Let worker event loop be a newly created event loop.
</li>
	<li>
%realm ~LET %実行~文脈 の Realm 成分の値
◎
Let realm be the value of execution context's Realm component.
</li>
	<li>
%~worker大域~scope ~LET %realm の`大域~obj$1
◎
Let worker global scope be realm's global object.
</li>
	<li>
<p>
%設定群~obj ~LET
以下に定義される一連の~algoを備える，新たな`環境~設定群~obj$
：
◎
Let settings object be a new environment settings object whose algorithms are defined as follows:
</p>

<dl>
	<dt>`~realm実行~環境$◎The realm execution context</dt>
	<dd>
~RET %実行~文脈
◎
Return execution context. 
</dd>

	<dt>`~module~map$enV◎The module map</dt>
	<dd>
~RET %~worker大域~scope の`~module~map$wG
◎
Return worker global scope's module map.
</dd>

	<dt>`担当の閲覧文脈$enV◎The responsible browsing context</dt>
	<dd>
~RET `継承 担当の閲覧文脈^V
◎
Return inherited responsible browsing context.
</dd>

	<dt>`担当の~eventloop$enV◎The responsible event loop</dt>
	<dd>
~RET %~worker~eventloop
◎
Return worker event loop.
</dd>

	<dt>`担当の文書$enV◎The responsible document</dt>
	<dd>
適用外（`担当の~eventloop$enVは `閲覧文脈$の`~eventloop$xではないので）
◎
Not applicable (the responsible event loop is not a browsing context event loop).
</dd>

	<dt>`~API~URL文字~符号化方式$enV◎The API URL character encoding</dt>
	<dd>
~RET `UTF-8$
◎
Return UTF-8.
</dd>

	<dt>`~API基底~URL$enV◎The API base URL</dt>
	<dd>
~RET %~worker大域~scope の`~url$wG
◎
Return worker global scope's url.
</dd>

	<dt>`生成元$enV◎The origin</dt>
	<dd>
~RET ［
%~worker大域~scope の`~url$wGの`~scheme$url ~EQ `data^l ならば `不透明な生成元$ ／
~ELSE_ `継承 生成元^V
］
◎
Return a unique opaque origin if worker global scope's url's scheme is "data", and inherited origin otherwise.
</dd>

	<dt>`~HTTPS状態$enV◎The HTTPS state</dt>
	<dd>
~RET %~worker大域~scope の`~HTTPS状態$wG
◎
Return worker global scope's HTTPS state.
</dd>

	<dt>`~referrer施策$enV◎The referrer policy</dt>
	<dd>
~RET %~worker大域~scope の`~referrer施策$wG
◎
Return worker global scope's referrer policy.
</dd>

</dl>
	</li>
	<li>
%設定群~obj の
( `~id$enV, `作成時の~URL$enV, `~target閲覧文脈$enV, `作動中の~sw$enV )
~SET
( 新たな一意かつ不透明な文字列, %~worker大域~scope の`~URL$, ~NULL, ~NULL )
◎
Set settings object's id to a new unique opaque string, settings object's creation URL to worker global scope's url, settings object's target browsing context to null, and settings object's active service worker to null.
</li>
	<li>
%realm の [[HostDefined]] ~field ~SET %設定群~obj
◎
Set realm's [[HostDefined]] field to settings object.
</li>
	<li>
~RET %設定群~obj
◎
Return settings object.
</li>
</ol>

			</section>
			<section id="dedicated-workers-and-the-worker-interface">

<h4 title="Dedicated workers and the Worker interface">10.2.6.3. 専用~workerと `Worker^I ~interface</h4>


⇒！
[<a href="#dom-worker">Constructor</a>(USVString %scriptURL, optional `WorkerOptions$I %options), Exposed=(Window,Worker)]
interface `Worker@I : `EventTarget$I {
  void `terminate$m();

  void `postMessage$m(any %message, optional sequence&lt;`object$I&gt; transfer = []);
  attribute `EventHandler$I `onmessage$hd;
};

dictionary `WorkerOptions@I {
  `WorkerType$I type = "classic";
  `RequestCredentials$I credentials = "omit"; // †
};

enum `WorkerType@I { "classic", "module" };

`Worker$I implements `AbstractWorker$I;
◎

<p class="note">†
`credentials^m （資格証）は、 `type^m （`種別$wG） ~EQ `module^l の場合に限り，利用される。
◎
credentials is only used if type is "module"
</p>

<dl class="domintro">

	<dt>%worker  = new `Worker(scriptURL  [, options ])$m</dt>
	<dd>
新たな `Worker$I ~objを返す。
%scriptURL は~backgroundで~fetchされ, 実行され、作成される新たな大域~環境への通信~channelを表現する %worker が返される。
%options を利用すれば，この新たな大域~環境が~JS~moduleを~supportすることを確保でき（その `type^m ~memberに `module^l を指定する）、その場合に限り `credentials^m ~memberを通して， %scriptURL が~fetchされる方法も指定できる。
◎
Returns a new Worker object. scriptURL will be fetched and executed in the background, creating a new global environment for which worker represents the communication channel. options can be used to ensure this new global environment supports JavaScript modules (specify type: "module") and if that is specified, can also be used to specify how scriptURL is fetched through the credentials option.
</dd>

	<dt>%worker . `terminate()$m</dt>
	<dd>
%worker に結付けられている大域~環境を中止する。
◎
Aborts worker's associated global environment.
</dd>

	<dt>%worker . `postMessage(message [, transfer ])$m</dt>
	<dd>
%message を~cloneして %worker の大域~環境へ伝送する。
%transfer には，一連の~objからなる~listを渡すことができ、それらは~cloneされずに転送される。
◎
Clones message and transmits it to worker's global environment. transfer can be passed as a list of objects that are to be transferred rather than cloned.
</dd>

</dl>


<dl class="idl-def">
	<dt>`terminate()@m</dt>
	<dd>
被呼出時には、此れが結付けられている~worker上で`~workerを終了させる$~algoを走らせ~MUST。
◎
The terminate() method, when invoked, must cause the "terminate a worker" algorithm to be run on the worker with which the object is associated.
</dd>

</dl>

<div class="p">
<p>
各 `Worker$I ~obj %worker は、
`MessagePort$I ~objである
`暗黙的な~port@1
が結付けられているかのように，動作する。
この~portは：
</p>

<ul ><li>%worker の作成-時に設置される~channelの一部をなすが，公開されることはない。
</li><li>決して %worker より先に~garbage収集されてはならない。
</li><li>この~portから受信されるすべての~messageは、即時に %worker に渡され~MUST。
</li></ul>

◎
Worker objects act as if they had an implicit MessagePort associated with them. This port is part of a channel that is set up when the worker is created, but it is not exposed. This object must never be garbage collected before the Worker object.
◎
All messages received by that port must immediately be retargeted at the Worker object.
</div>


<dl class="idl-def">
	<dt>`postMessage()@m</dt>
	<dd>
<!-- semi-copy -->
被呼出時には、それが即時に，此れの`暗黙的な~port$1上の`同じ名前の~method$を同じ引数で呼出して, 同じ値を返したかのように，動作し~MUST。
◎
The postMessage() method on Worker objects must act as if, when invoked, it immediately invoked the method of the same name on the port, with the same arguments, and returned the same return value.
</dd>
	<dd class="example">

<p>
`postMessage()$m
~methodの第一~引数は有構造~dataでもよい：
◎
The postMessage() method's first argument can be structured data:
</p>

<pre>
worker.postMessage({
   opcode: 'activate',
   device: 1938,
   parameters: [23, 102]
});
</pre>

	</dd>
</dl>

<p>
`Worker$I
~interfaceを実装する~objにおいては、次の`~event~handler$（および，それらに対応する`~event~handler ~event型$）が`~event~handler IDL 属性$として~supportされ~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by objects implementing the Worker interface:
</p>

<table>
<thead><tr><th>~event~handler
<th>~event~handler ~event型
</thead>

<tbody><tr><td>`onmessage@hd
<td> `message$et

</tbody></table>

<hr>

<p class="idl-def">
`Worker(scriptURL, options)@m
構築子の被呼出時には、次の手続きを走らせ~MUST：
◎
When the Worker(scriptURL, options) constructor is invoked, the user agent must run the following steps:
</p>

<ol>
	<li>
~UAの任意選択で
⇒
~IF［
この~~要請は施策~決定0に違反している（例えば~pageに対し，専用~workerの開始-を許容しないように~UAが環境設定されているときなど）
］
⇒
~THROW `SecurityError^E
◎
The user agent may throw a "SecurityError" DOMException and abort these steps if the request violates a policy decision (e.g. if the user agent is configured to not allow the page to start dedicated workers).
</li>
	<li>
%外側~設定群 ~LET `現在の設定群~obj$
◎
Let outside settings be the current settings object.
</li>
	<li>
%~worker~URL ~LET %scriptURL 引数を， %外側~設定群 に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse the scriptURL argument relative to outside settings.
</li>
	<li>
<p>
~IF［
%~worker~URL ~EQ ~error
］
⇒
~THROW `SyntaxError^E
◎
If this fails, throw a "SyntaxError" DOMException and abort these steps.
◎
Let worker URL be the resulting URL record.
</p>

<p class="note">注記：
`blob$sc ~URLも含め，`同一生成元$であれば どの~URLも利用できる。
`data$sc ~URLも利用できるが、作成される~workerには`不透明な生成元$が伴われることになる。
◎
Any same-origin URL (including blob: URLs) can be used. data: URLs can also be used, but they create a worker with an opaque origin.
</p>
	</li>
	<li>
%~worker ~LET 新たな `Worker$I ~obj
◎
Let worker be a new Worker object.
</li>
	<li>
%外側~port ~LET ［
`所有者$： %外側~設定群
］の下で作成される，`新たな~MessagePort~obj$
◎
Create a new MessagePort object whose owner is outside settings. Let this be the outside port.
</li>
	<li>
%~worker の`暗黙的な~port$1 ~SET %外側~port
◎
Associate the outside port with worker.
</li>
	<li>
%文書s ~LET
%外側~設定群 から与えられる，`追加する関連の文書$
◎
Let docs be the list of relevant Document objects to add given outside settings object.
</li>
	<li>
~RET %~worker
— ただし、以下の手続きは`並列的$に走らす。
◎
Return worker, and run the following step in parallel.
</li>
	<li>
<p>
次を与える下で，`~workerを走らす$：
</p>

<ul ><li>%~worker ~SET %~worker
</li><li>%url ~SET %~worker~URL
</li><li>%外側~設定群 ~SET %外側~設定群
</li><li>%外側~port ~SET %外側~port
</li><li>%options ~SET %options
</li></ul>

◎
Run a worker given worker, worker URL, outside settings, outside port, and options.
</li>
</ol>

			</section>
			<section id="shared-workers-and-the-sharedworker-interface">

<h4 title="Shared workers and the SharedWorker interface">10.2.6.4. 共用~workerと `SharedWorker^I ~interface</h4>


⇒！
[<a href="#dom-sharedworker">Constructor</a>(USVString %scriptURL, optional DOMString %name = "", optional `WorkerOptions$I %options),
Exposed=(Window,Worker)]
interface `SharedWorker@I : `EventTarget$I {
  readonly attribute `MessagePort$I `port$m;
};
`SharedWorker$I implements `AbstractWorker$I;
◎

<dl class="domintro">

	<dt>%sharedWorker  = new `SharedWorker(scriptURL [, name [, options ]])$m</dt>
	<dd>
新たな `SharedWorker$I ~objを返す。
%scriptURL は~backgroundで~fetchされ, 実行され、作成される新たな大域~環境への通信~channelを表現する %sharedWorker が返される。
%name を利用すれば，その大域~環境の`名前$wGを定義できる。
%options を利用すれば，この新たな大域~環境が~JS~moduleを~supportすることを確保でき（その `type^m ~memberに `module^l を指定する）、その場合に限り `credentials^m ~memberを通して， %scriptURL が~fetchされる方法も指定できる。
◎
Returns a new SharedWorker object. scriptURL will be fetched and executed in the background, creating a new global environment for which sharedWorker represents the communication channel. name can be used to define the name of that global environment. options can be used to ensure this new global environment supports JavaScript modules (specify type: "module") and if that is specified, can also be used to specify how scriptURL is fetched through the credentials option.
</dd>

	<dt>%sharedWorker  . `port$m</dt>
	<dd>
%sharedWorker の `MessagePort$I ~objを返す。
それを利用して大域~環境と通信できる。
◎
Returns sharedWorker's MessagePort object which can be used to communicate with the global environment.
</dd>

</dl>


<dl class="idl-def">
	<dt>`port@m</dt>
	<dd>
取得子は、此れの構築子により あてがわれた値（ %外側~port ）を返さ~MUST。
この値は、共用~workerと通信するための `MessagePort$I を表現する。
◎
The port attribute must return the value it was assigned by the object's constructor. It represents the MessagePort for communicating with the shared worker.
</dd>

</dl>


<p>
`SharedWorker(scriptURL, name, options)@m
構築子の被呼出時には、次の手続きを走らせ~MUST：
◎
When the SharedWorker(scriptURL, name, options) constructor is invoked, the user agent must run the following steps:
</p>

<ol>
	<li>
~UAの任意選択で
⇒
~IF［
この~~要請は施策~決定0に違反している（例えばその~pageに対し，共用~workerの開始-を許容しないように~UAが環境設定されているときなど）
］
⇒
~THROW `SecurityError^E
◎
The user agent may throw a "SecurityError" DOMException and abort these steps if the request violates a policy decision (e.g. if the user agent is configured to not allow the page to start shared workers).
</li>
	<li>
%外側~設定群 ~LET `現在の設定群~obj$
◎
Let outside settings be the current settings object.
</li>
	<li>
%~URL~record ~LET %scriptURL を， %外側~設定群 に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse scriptURL relative to outside settings.
</li>
	<li>
~IF［
%~URL~record ~EQ ~error
］
⇒
~THROW `SyntaxError^E
◎
If this fails, throw a "SyntaxError" DOMException and abort these steps.
</li>
	<li>
<p>
%~URL~record ~LET `結果の~URL~record$
◎
Otherwise, let urlRecord be the resulting URL record.
</p>

<p class="note">注記：
`blob$sc ~URLも含め，`同一生成元$であれば どの~URLも利用できる。
`data$sc ~URLも利用できるが、作成される~workerには`不透明な生成元$が伴われることになる。
◎
Any same-origin URL (including blob: URLs) can be used. data: URLs can also be used, but they create a worker with an opaque origin.
</p>
	</li>
	<li>
%~worker ~LET 新たな `SharedWorker$I ~obj
◎
Let worker be a new SharedWorker object.
</li>
	<li>
%外側~port ~LET ［
`所有者$： %外側~設定群
］の下で作成される，`新たな~MessagePort~obj$
◎
Create a new MessagePort object whose owner is outside settings. Let this be the outside port.
</li>
	<li>
%~worker の `port$m 属性 ~SET %外側~port
◎
Assign outside port to the port attribute of worker.
</li>
	<li>
`保安的~文脈？^V ~LET
`設定群は保安的~文脈であるか？$( %外側~設定群 )
◎
Let isSecureContext be the result of executing Is environment settings object a secure context? on outside settings.
</li>
	<li>
<p>
次の下位手続きを`並列的$に走らす：
◎
Run these substeps in parallel:
</p>

		<ol>
			<li>
%~worker大域~scope ~LET ~NULL
◎
Let worker global scope be null.
</li>
			<li>
<p>
~IF［
次の両者とも満たす `SharedWorkerGlobalScope$I ~obj %O が存在する
］…
◎
↓</p>

				<ul>
					<li>
<div class="p">
<p>
%O は次をすべてを満たす：
</p>

<ul ><li>%O の `~closing~flag$i ~EQ ~OFF
</li><li>［
%O の`構築子~生成元$wG, %外側~設定群 の`生成元$enV
］は，互いに`同一生成元$である
</li><li>［
%O の`構築子~url$wG, %~URL~record
］は，互いに`等しい$
</li><li>%O の`名前$wG ~EQ %name
</li></ul>

◎
If there exists a SharedWorkerGlobalScope object whose closing flag is false, constructor origin is same origin with outside settings's origin, constructor url equals urlRecord, and name is name, then set worker global scope to that SharedWorkerGlobalScope object.
</div>

<p class="note">注記：
`data$sc ~URLは、`不透明な生成元$が伴われる~workerを作成することになる。
`構築子~生成元$wG, `構築子~url$wG の両者とも比較されるので，同じ `data$sc ~URLを利用して ある`生成元$の中で同じ `SharedWorkerGlobalScope$I ~objを取得できるが、`同一生成元$の制約を迂回することはできない。
◎
data: URLs create a worker with an opaque origin. Both the constructor origin and constructor url are compared so the same data: URL can be used within an origin to get to the same SharedWorkerGlobalScope object, but cannot be used to bypass the same origin restriction.
</p>

					</li>
					<li>
<p>
~UAは、次を許容しないように環境設定されてはいない
⇒
%O が表現する~workerと［［
`設定群~obj$ ~EQ %外側~設定群
］なる`~script$たち
］との間の通信
◎
If worker global scope is not null, but the user agent has been configured to disallow communication between the worker represented by the worker global scope and the scripts whose settings object is outside settings, then set worker global scope to null.
</p>

<p class="note">注記：
例えば~UAが開発~mode下にあり、そこでは 特定0の`~top-level閲覧文脈$が 他のすべての~pageから隔離されていて、その開発~mode下の~scriptからは，通常の閲覧~modeで走っている~workerへの接続ingが阻止されているときなど。
◎
For example, a user agent could have a development mode that isolates a particular top-level browsing context from all other pages, and scripts in that development mode could be blocked from connecting to shared workers running in the normal browser mode.
</p>
					</li>
				</ul>
<p>
…ならば：
◎
If worker global scope is not null, then run these subsubsteps:
</p>

				<ol>
					<li>
%~worker大域~scope ~SET %O
◎
↑</li>
					<li>
%設定群~obj ~LET %~worker大域~scope に`関連する設定群~obj$
◎
Let settings object be the relevant settings object for worker global scope.
</li>
					<li>
<p>
~IF［
`設定群は保安的~文脈であるか？$( %設定群~obj ) ~NEQ `保安的~文脈？^V
`SECURE-CONTEXTS$r
］
</p>
						<ol>
							<li>
次を行う`~taskを待入する$
⇒
%~worker に向けて，名前 `error$et の`~eventを発火-$する
</li>
							<li>
~RET
</li>
					</ol>
◎
If the result of executing Is environment settings object a secure context? on settings object is not isSecureContext, then queue a task to fire an event named error at worker and abort these subsubsteps. [SECURE-CONTEXTS]
</li>
					<li>
%~worker を %~worker大域~scope に結付ける
◎
Associate worker with worker global scope.
</li>
					<li>
%内側~port ~LET ［
`所有者$: %設定群~obj
］の下で作成される，`新たな~MessagePort~obj$
◎
Create a new MessagePort object whose owner is settings object. Let this be the inside port.
</li>
					<li>
%外側~port と %内側~port を`連絡$する
◎
Entangle outside port and inside port.
</li>
					<li>
<p>
%~task ~LET `~DOM操作~task源$を利用して，［
%~worker大域~scope に向けて，次のようにされた`~eventを発火-$する
］`~taskを待入する$：
</p>

<ul ><li>`MessageEvent$I ~interfaceを利用する
</li><li>名前 `connect$et
</li><li>各種~属性は次のように初期化する：
	<ul><li>`data$m 属性 ~SET 空文字列
	</li><li>`ports$m 属性 ~SET %内側~port のみを含む新たな`凍結~配列$
	</li><li>`source$m 属性 ~SET %内側~port
	</li></ul>
</li></ul>

◎
Queue a task, using the DOM manipulation task source, to fire an event named connect at worker global scope, using MessageEvent, with the data attribute initialized to the empty string, the ports attribute initialized to a new frozen array containing only inside port, and the source attribute initialized to inside port.
</li>
					<li>
%外側~設定群 から与えられる，`追加する関連の文書$を，
%~worker大域~scope の`文書~listに追加-$する
◎
Add to worker global scope's list of the worker's Documents the list of relevant Document objects to add given outside settings.
</li>
					<li>
~IF［［
%外側~設定群 `の大域~obj$ %G
］は `WorkerGlobalScope$I ~objである
］
⇒
%G の`~worker~list$に，%~worker大域~scope を追加する
◎
If outside settings's global object is a WorkerGlobalScope object, add worker global scope to the list of the worker's workers of outside settings's global object.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
⇒
次を与える下で，`~workerを走らす$：
</p>

<ul ><li>%~worker ~SET %~worker
</li><li>%url ~SET %~URL~record
</li><li>%外側~設定群 ~SET %外側~設定群
</li><li>%外側~port ~SET %外側~port
</li><li>%options ~SET %options
</li><li>%名前 ~SET %name
</li></ul>

◎
Otherwise, run a worker given worker, urlRecord, outside settings, outside port, options, and name.
</li>
		</ol>
	</li>
	<li>
~RET %~worker
◎
Return worker.
</li>
</ol>

			</section>
		</section>
		<section id="navigator.hardwareconcurrency">
<h4 title="Concurrent hardware capabilities">10.2.7 同時的~hardware能力</h4>

<pre class="idl">
[NoInterfaceObject, Exposed=(Window,Worker)]
interface `NavigatorConcurrentHardware@I {
  readonly attribute unsigned long long `hardwareConcurrency$m;
};
</pre>

<dl class="domintro">
	<dt>%window . `navigator$m . `hardwareConcurrency$m</dt>
	<dd>
~UAに可用になり得る論理CPU数を返す。
◎
Returns the number of logical processors potentially available to the user agent.
</dd>
</dl>

<dl class="idl-def">
	<dt>`hardwareConcurrency@m</dt>
	<dd>
取得子は、範囲［
1 〜 ~UAに可用になり得る論理CPU数
］内の整数を返さ~MUST
— ~UAがこれを決定できない場合は、 1 を返す。
~FINGERPRINTING
◎
The navigator.hardwareConcurrency attribute's getter must return a number between 1 and the number of logical processors potentially available to the user agent. If this cannot be determined, the getter must return 1.
(This is a fingerprinting vector.)
</dd>
	<dd>
~UAは、［
特有の制限がある場合（作成できる `Worker$I 数の上限など）や，指紋収集の可能性を制限したいと欲するとき
］に限って，可用な論理CPU数としてより低い値を公開するべきである。
<!-- err toward -->
◎
User agents should err toward exposing the number of logical processors available, using lower values only in cases where there are user-agent specific limits in place (such as a limitation on the number of workers that can be created) or when the user agent desires to limit fingerprinting possibilities.
</dd>
</dl>



		</section>
	</section>
	<section id="apis-available-to-workers">

<h2 title="APIs available to workers">10.3. ~workerから可用な~API</h2>


		<section id="importing-scripts-and-libraries">

<h3 title="Importing scripts and libraries">10.3.1. ~script／~libraryの取込み</h3>


<p class="idl-def">
`WorkerGlobalScope$I ~obj %O 上の
`importScripts(urls)@m
~methodの被呼出時には、~UAは，
( %O, %urls )
を与える下で，`~scriptを~worker大域~scopeの中に取込む$ことが要求される。
◎
When a script invokes the importScripts(urls) method on a WorkerGlobalScope object, the user agent must import scripts into worker global scope given this WorkerGlobalScope object and urls.
</p>

<div >
<p>
`~scriptを~worker大域~scopeの中に取込む@
ときは、所与の：
</p>

<ul ><li>%~worker大域~scope （ `WorkerGlobalScope$I ~obj ）
</li><li>%urls （ `sequence&lt;DOMString&gt;^I ）
</li><li>`~fetchを遂行する$ ~custom~hook
— 省略可。
提供された場合、`~workerが~importする~classic~scriptを~fetch$するときに利用される
</li></ul>

<p>
に対し，次の手続きを走らせ~MUST：
</p>

◎
To import scripts into worker global scope, given a WorkerGlobalScope object worker global scope and a sequence&lt;DOMString&gt; urls, run these steps. The algorithm may optionally be customized by supplying custom perform the fetch hooks, which if provided will be used when invoking fetch a classic worker-imported script.
</div>



<ol>
	<li>
~IF［
%~worker大域~scope の`種別$wG ~EQ `module^l
］
⇒
~THROW `TypeError^E
◎
If worker global scope's type is "module", throw a TypeError exception and abort these steps.
</li>
	<li>
%設定群~obj ~LET `現在の設定群~obj$
◎
Let settings object be the current settings object.
</li>
	<li>
~IF［
%urls は空である
］
⇒
~RET
◎
If urls is empty, abort these steps.
</li>
	<li>
%~url~list ~LET 空~list
◎
↓</li>
	<li>
<p>
~FOR
%urls 内の ~EACH ( %~url ) に対し：
</p>
		<ol>
			<li>
%~url ~SET %~url を %設定群~obj に`相対的に構文解析-$した`結果の~URL~record$
</li>
			<li>
~IF［
%~url ~EQ ~error
］
⇒
~THROW `SyntaxError^E
</li>
			<li>
%~url~list に %~url を追加する
</li>
		</ol>
◎
Parse each value in urls relative to settings object. If any fail, throw a "SyntaxError" DOMException and abort these steps.
</li>
	<li>
<p>
~FOR
%~url~list 内の ~EACH ( %url ) に対し：
◎
For each url in the resulting URL records, run these substeps:
</p>
		<ol>
			<li>
%~script ~LET 次を与える下で，
`~workerが~importする~classic~scriptを~fetch$した結果（例外~投出あり）
⇒
( %url, %設定群~obj ), および
`~fetchを遂行する$ ~custom手続きが提供されていれば それも
◎
Fetch a classic worker-imported script given url and settings object, passing along any custom perform the fetch steps provided. If this succeeds, let script be the result. Otherwise, rethrow the exception.
</li>
			<li>
<p>
次を与える下で，`~classic~scriptを走らす$
⇒
%~script, ［
%再投出error~flag ~SET ~ON
］
◎
Run the classic script script, passing the rethrow errors flag.
</p>

<div class="note">
<p>注記：
~scriptは、次のいずれかが生じるまで走らすことになる：
</p>

<ul ><li>普通に返った
</li><li>構文解析-に失敗した
</li><li>投出された例外を~catchしなかった
</li><li>“`~workerを強制終了する$” ／ “`~workerを終了させる$”
~algoにより`尚早に中止され$た
</li></ul>
◎
script will run until it either returns, fails to parse, fails to catch an exception, or gets prematurely aborted by the "kill a worker" or "terminate a worker" algorithms defined above.
</div>

<p>
［
~scriptから例外が投出された ／
~scriptは`尚早に中止され$た
］場合
`普通に返らなかった場合^tnote
⇒
この手続きすべてを中止した上で、~call元の~scriptにて，その［
例外／中止-
］の処理を続行させる
◎
If an exception was thrown or if the script was prematurely aborted, then abort all these steps, letting the exception or aborting continue to be processed by the calling script.
</p>
			</li>
		</ol>
	</li>
</ol>


<p class="note">注記：
<cite>Service Workers</cite> 
仕様 `SW$r は、`~fetchを遂行する$ ~hookに自前の~optionを与えて この~algoを走らす仕様の例である。
◎
Service Workers is an example of a specification that runs this algorithm with its own options for the perform the fetch hook. [SW]
</p>

		</section>
		<section id="the-workernavigator-object">

<h3 title="The WorkerNavigator object">10.3.2. `WorkerNavigator^I ~obj</h3>


<p class="idl-def">
`WorkerGlobalScope$I ~interfaceの
`navigator@m
属性は、~UA（~client）の識別と状態を表現する，
`WorkerNavigator$I ~interfaceの~instanceを返さ~MUST。
◎
The navigator attribute of the WorkerGlobalScope interface must return an instance of the WorkerNavigator interface, which represents the identity and state of the user agent (the client):
</p>

⇒！
[Exposed=Worker]
interface `WorkerNavigator@I {};
`WorkerNavigator$I implements `NavigatorID$I;
`WorkerNavigator$I implements `NavigatorLanguage$I;
`WorkerNavigator$I implements `NavigatorOnLine$I;
`WorkerNavigator$I implements `NavigatorConcurrentHardware$I;
◎

		</section>
		<section id="worker-locations">

<h3 title="Worker locations">10.3.3. `WorkerLocation^I ~obj</h3>

⇒！
[Exposed=Worker]
interface `WorkerLocation@I {
  stringifier readonly attribute USVString `href$m;
  readonly attribute USVString `origin$m;
  readonly attribute USVString `protocol$m;
  readonly attribute USVString `host$m;
  readonly attribute USVString `hostname$m;
  readonly attribute USVString `~port0$m;
  readonly attribute USVString `pathname$m;
  readonly attribute USVString `search$m;
  readonly attribute USVString `hash$m;
};
◎

<p>
各 `WorkerLocation$I ~objには、［
`WorkerGlobalScope$I ~objである
`~worker大域~scope@
］が結付けられる。
◎
A WorkerLocation object has an associated WorkerGlobalScope object (a WorkerGlobalScope object).
</p>

<div >
<p>
この節を通して：
</p>

<ul>
	<li>
記号 "＋" は、文字列の連結を表すとする。
</li>
	<li>
`url@V は、当の `WorkerLocation$I ~objの`~worker大域~scope$の`~url$wGを表すとする。
</li>
</ul>
◎
↓</div>


<dl class="idl-def">
	<dt>`href@m</dt>
	<dd>
取得子は、次を返さ~MUST
⇒
`url$V を `~URL直列化器$にかけた結果
◎
The href attribute's getter must return the associated WorkerGlobalScope object's url, serialized.
</dd>

	<dt>`origin@m</dt>
	<dd>
取得子は、次を返さ~MUST
⇒
［
`url$V の`生成元$url
］の `Unicode 直列化$
◎
The origin attribute's getter must return the Unicode serialization of the associated WorkerGlobalScope object's url's origin.
</dd>
	<dd class="note">
`MessageEvent$I との互換性をとるため、これは，
ASCII 直列化ではなく Unicode を返す。
◎
It returns the Unicode rather than the ASCII serialization for compatibility with MessageEvent.
</dd>

	<dt>`protocol@m</dt>
	<dd>
取得子は、次を返さ~MUST
⇒
［
`url$V の`~scheme$url
］ ＋ `:^l
◎
The protocol attribute's getter must run return the associated WorkerGlobalScope object's url's scheme, followed by ":".
</dd>

	<dt>`host@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The host attribute's getter must run these steps:
</p>

<ol>
	<li>
%host ~LET `url$V の`~host$url
◎
↓</li>
	<li>
~IF［
%host ~EQ ~NULL
］
⇒
~RET 空文字列
◎
Let url be the associated WorkerGlobalScope object's url.
◎
If url's host is null, return the empty string.
</li>
	<li>
%host ~LET %host を`~host直列化器$にかけた結果
◎
↓</li>
	<li>
%port ~LET `url$V の`~port$url
◎
↓</li>
	<li>
~IF［
%port ~EQ ~NULL
］
⇒
~RET %host
◎
If url's port is null, return url's host, serialized.
</li>
	<li>
~RET %host ＋ `:^l ＋ ［
%port を`整数として直列化-$した結果
］
◎
Return url's host, serialized, followed by ":" and url's port, serialized.
</li>
</ol>

	</dd>

	<dt>`hostname@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The hostname attribute's getter must run these steps:
</p>

<ol>
	<li>
%host ~LET `url$V の`~host$url
◎
Let host be the associated WorkerGlobalScope object's url's host.
</li>
	<li>
~IF［
%host ~EQ ~NULL
］
⇒
~RET 空文字列
◎
If host is null, return the empty string.
</li>
	<li>
~RET 
%host を`~host直列化器$にかけた結果
◎
Return host, serialized.
</li>
</ol>

	</dd>

	<dt>`~port0@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The port attribute's getter must run these steps:
</p>

<ol>
	<li>
%port ~LET `url$V の`~port$url
◎
Let port be the associated WorkerGlobalScope object's url's port.
</li>
	<li>
~IF ［
%port ~EQ ~NULL 
］
⇒
~RET 空文字列
◎
If port is null, return the empty string.
</li>
	<li>
~RET %port を`整数として直列化-$した結果
◎
Return port, serialized.
</li>
</ol>

	</dd>

	<dt>`pathname@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The pathname attribute's getter must run these steps:
</p>

<ol>
	<li>
~IF［
`url$V の`~cannot-be-a-base-URL~flag$url ~EQ ~ON
］
⇒
~RET `url$V の`~path$url内の最初の文字列
◎
Let url be the associated WorkerGlobalScope object's url.
◎
If url's cannot-be-a-base-URL flag is set, return the first string in url's path.
</li>
	<li>
~RET `/^l ＋［
`url$V の`~path$url内の各~文字列（空文字列も含め）を，
`/^l で区切って順に連結した結果
］
◎
Return "/", followed by the strings in url's path (including empty strings), separated from each other by "/".
</li>
</ol>

	</dd>

	<dt>`search@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The search attribute's getter must run these steps:
</p>

<ol>
	<li>
%query ~LET `url$V の`~query$url
◎
Let query be the associated WorkerGlobalScope object's url's query.
</li>
	<li>
~IF［
%query ~IN { ~NULL, 空文字列 }
］
⇒
~RET 空文字列
◎
If query is either null or the empty string, return the empty string.
</li>
	<li>
~RET `?^l ＋ %query
◎
Return "?", followed by query.
</li>
</ol>

	</dd>

	<dt>`hash@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The hash attribute's getter must run these steps:
</p>

<ol>
	<li>
%fragment ~LET `url$V の`素片$url
◎
Let fragment be the associated WorkerGlobalScope object's url's fragment.
</li>
	<li>
~IF［
%fragment ~IN { ~NULL, 空文字列 }
］
⇒
~RET 空文字列
◎
If fragment is either null or the empty string, return the empty string.
</li>
	<li>
~RET `#^l ＋ %fragment
◎
Return "#", followed by fragment.
</li>
</ol>

</dl>

		</section>
	</section>
</section>

</main><!-- id="MAIN" -->


</body></html>
