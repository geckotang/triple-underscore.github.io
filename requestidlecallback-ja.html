<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Cooperative Scheduling of Background Tasks（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
var source_data;

COMMON_DATA.page_state_key = '___TIMING';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'http://www.w3.org/TR/requestidlecallback/',
//		original_url: 'https://w3c.github.io/requestidlecallback/',
		spec_status: 'WD',
		main: 'MAIN',
		fill_text_link: '#_versions > dd, #references dd',
		hash_case_modified: 'dfn',
		alt_refs: 'references',
		ref_id_prefix: 'bib-',
//		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 2015-10-28 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		l: 'literal',
		E: 'dom-error',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		d: 'code',
		c: 'code',
		E: 'code',
		l: 'code',
		V: 'var',
		b: 'b',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
	var context_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|【.*?】|%[\w\u4E00-\u9FFF~]+|`(.+?)([$@!\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN0', '_toc_list0');

	function create_html(match, key, indicator, klass){


if(!key) {
	switch(match[0]){
	case '⇒':
		if(match.charAt(1) === '！'){
			in_idl = true;
			nesting += '</pre>';
			return '<pre class="idl">';
		} else {
			nesting += '</span>';
			return '：<span class="block">';
		}
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '%':
		return '<var>' + match.slice(1) + '</var>';
	}//◎
	if(in_idl) {
		result = nesting;
		in_idl = false;
	} else {
		result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	}
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"'
	break;
case 'I': // IDL interface
	href = '#' + key;
	if(in_idl) tag = '';
	break;
case 'm': // IDL member / IDL dictionary member
	//href = context_ifc + key.replace(/\(.+/, '');
	if(in_idl) tag = '';
	key = key.replace(/\(.+/, '');
	text = key + text.replace(/^[^\(]+/, '').replace(/\w+/g, '<var>$&</var>' );
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>



<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
IdleRequestOptions:
IdleDeadline:
IdleRequestCallback:
dom-Window-requestIdleCallback:
dom-Window-cancelIdleCallback:
dom-IdleRequestOptions-timeout:
dom-IdleDeadline-timeRemaining:
dom-IdleDeadline-didTimeout:
</script>

<!--%links -->
<script type="text/plain" id="_link_map">

	50ms:#why50
	:#figure1
	:#figure2
	:#window_extensions

m.requestIdleCallback:#dom-Window-requestIdleCallback
m.cancelIdleCallback:#dom-Window-cancelIdleCallback

m.timeout:#dom-IdleRequestOptions-timeout
m.timeRemaining:#dom-IdleDeadline-timeRemaining
m.didTimeout:#dom-IdleDeadline-didTimeout

文書:~DOM4#concept-document
I.Document:~TR/dom/#document
I.Window:~HTML50/browsers.html#the-window-object
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
m.performance.now:~HRTIME#dom-performance-now

m.setInterval:~HTML50/webappapis.html#dom-windowtimers-setinterval
m.setTimeout:~HTML50/webappapis.html#dom-windowtimers-settimeout
m.hidden:~TR/page-visibility/#dom-document-hidden
m.requestAnimationFrame:~TR/animation-timing/#dom-windowanimationtiming-requestanimationframe
	m.requestAnimationFrame:https://html.spec.whatwg.org/multipage/webappapis.html#animation-frames


遊休~callback:#_idle-callback
~callback:#_callback
	~timeout:#_timeout
~handle:#_handle

遊休~callback~list内:#_list-of-idle-callbacks
~event~loop刻限:#_event-loop-deadline

~callback刻限:#_callback-deadline
~timeout~flag:#_timeout-flag
文脈~obj:~DOM4#context-object

要請された遊休~callbackの~list:#dfn-list-of-idle-request-callbacks
稼働可能な遊休~callbackの~list:#dfn-list-of-runnable-idle-callbacks
遊休~callback識別子:#dfn-idle-callback-identifier
遊休task~task源:#dfn-idle-task-task-source
遊休~期間:#dfn-idle-period
遊休~callbackを呼出す~algo:#dfn-invoke-idle-callbacks-algorithm
~timeoutに達した遊休~callbackを呼出す~algo:#dfn-invoke-idle-callback-timeout-algorithm

	conforming implementation:~TR/WebIDL/#dfn-conforming-implementation
	~privacyと~security:~HRTIME#privacy-security

~task源:~WAPI#task-source
~event~loop:~WAPI#event-loop
~taskを待入する:~WAPI#queue-a-task
待行列に入れる:~WAPI#queue-a-task
待入する:~WAPI#queue-a-task
~task:~WAPI#concept-task
~errorを報告する:~WAPI#report-the-error

全部的に作動中の文書:~HTML50/browsers.html#fully-active
作動中の~timerの~list:~HTML50/webappapis.html#list-of-active-timers
作動中の文書:~HTML50/browsers.html#active-document

</script>

<!--%置換語 -->

<script type="text/plain" id="words_table1">
</script>

<!--%語彙 -->
<script type="text/plain" id="words_table">

	-:portion:~
	API:API:~
	CPU:CPU:~
	勘定に入れる:account:~
	causing:::
	changing:::
	client側:client-side:~
	decide:::
	decision:::
	entirely:::
	余計なextra:::
	final:::
	-forward:::
	further:::
	get:::
	i:::
	increment:::
	lag:::
	last刻限:last_deadline:~
	遅延に厳しい:latency-critical
	時間に厳しい:time-critical
	long:::
	longer:::
	near:::
	note:::
	part:::
	possible:::
	property:::
	remain:::
	scriptに基づく:script-based:~
	small:::
	step:::
	subtlety:::
	uncaught:::
	差し迫ったupcoming:::
	very:::
	自由free:::
	見合うfit:::
	負荷load:::

jank:::カクツキ
templating:::テンプレート処理
code:::コード
pattern:::パタン
animation:::アニメーション
	~UA:browser
client:::クライアント
data:::データ
entry:::エントリ
error:::エラー
event:::イベント
interface:::インタフェース
layout:::レイアウト
list:::リスト
member:::メンバ
method:::メソッド
mode:::モード
model:::モデル
obj:object::オブジェクト
overhead:::オーバーヘッド
privacy:::プライバシー
processor:::プロセッサ
promise:::
screen:::スクリーン
script:::スクリプト
security:::セキュリティ
source:::ソース
源:source::~:ソース
	式style
zero:::ゼロ
頁:page::ページ
文脈:context:~
関数:function:~

	●処理model
logic:::ロジック
call:::
task:::タスク
callback::::コールバック
commit:::コミット
frame:::フレーム
loop:::ループ
micro-:::マイクロ
	micro-秒:microsecond:~
milli-:::ミリ
	milli-秒:millisecond:~
timeout::::タイムアウト
handle::::ハンドル
timer:::タイマー
post:::ポスト
	repost:::
	reposting:::
round-robin:::ラウンドロビン
	running:::
	save:::
schedule:::スケジュール
	scheduled:::
	scheduling:::

vsync::video 同期:ビデオ同期
main-thread:main thread::メインスレッド
定期的:regular:~
仕事:work::タスク
取扱う:handle する:取り扱う
処理待ち:pending:~
処理待ちの:pending:~
遂行-:perform:~
	時間に厳しいtime-critical
予測不能:unpredictable:~
	再~post:re-post:~
	再度:again:~
	再度~schedule:reschedule:~
処理-:process:~
処理:processing:~
刻限:deadline::~
協同的な:cooperative:~
協同して:cooperative に:~
即時:immediate:~
反応-:react:~
	前:before:~
取消す:cancel する:取り消す
受取る:receive する:受け取る
	合間:between:~
	同じ:same:~
	含-:include:~
呼出す:invoke する:呼び出す
呼出され:invoke され:呼び出され
呼出:invocation:呼び出し
被呼出時:被 invoke 時:~
差挟む:interleave する:~
	先送りpostpone／yield／get called back／to be performed／ to be repeatedly executed
完了-:complete:~
実行-:execute:~
実行:execution:~
実行時:runtime:~
待入する:queue する::待ち行列に入れる:キューする
待入され:queue され::待ち行列に入れられ:キューされ
待入しな:queue しな::待ち行列に入れな:キューしな
待行列:queue::待ち行列
負荷:load:~
	負荷が高い~heavy page load
待機-:wait:~
応答-:respond:~
応答:response:~
応答性:responsiveness:~
早期:early:~
今:now:~
時間:time:~
時刻:time:~
時区間:time:~
時間軸:timeline:~
更新:update:~
期間:period::~
未来の:future:~
未来:future:~
機会:chance:~
正確0:accurate:正確
	残りの／:remaining:~
現在:currently:~
現在の:current:~
現在時刻:the current time:~
	生じ:occur:~
	生じing:occurring:~
生成:generation:~
瞬間的:instantaneous:~
	秒:second:~
稼働-:run:~
	稼働資格:run する資格:~
	稼働可能とされ:eligible to run:~
稼働可能:runnable:~
稼働可能な:runnable:~
粒度:granularity:~
	終わった:finish:~
終端:end:~
	末尾:end:~
継続的:continuous:~
継続-:continue:~
背景:background:~
要請:request::~:リクエスト
	要請済:requested:要請済み
見積もり:estimation:~
見積もる:estimate する:~
	見込まれる／:likely:~
識別子:identifier:~
識別-:identify:~
遅延:delay::~:ディレイ
遊休:idle::~:アイドル
遊休task:idle-task::遊休タスク :アイドルタスク 
	達-:reach:~
開始:start:~
起動-:initiate:開始
	method:function:~
閾値:threshold:~
高頻度:frequent:~
非同期的:asynchronous:~
非同期:asynchronous:~
投出-:throw:~
	策:strategy:~

	pop:::
	taking:::
	繰り返しrepeatedly
	間引くthrottle〜rather than continuously
	~~静止quiescence:::
	不定期 unbounded amount of time:::
	exit:::
	expectation:::
	要請された順に:FIFO order
	-:assess:~
	begun:::
	ある時間までに time bound within which
	bound:::
	過ぎるexpire:::
	previous:::
	previously:::
	produce:::
	水増し:pad する:::
	上限:cap
	細分化された仕事:chunk:::
	continuation:::
	continue:::
	周期cycle:::
	最小minimum:::
	最小限に:minimum possible


	●仕様
UA:user agent:UA
algo:algorithm::アルゴリズム
app:application::アプリ
approach:::アプローチ
platform:::プラットフォーム
vendor:::ベンダ
web:::ウェブ
version:::バージョン
support:::サポート
仕方:way:~
仕様:spec:~
	他の:other:~
	代わりに:instead:~
任意選択:optional:~
	伝える:inform する:~
制御:control:~
制限-:limit:~
前提:assumption:~
	加えて:in addition:~
参照:reference:~
受容可能:acceptable:~
可用:available:~
	可能化-:enable:~
困難:difficult:~
在する:present する:在る
	基づく:based:~
報告-:report:~
	始-:begin:~
存在-:exist:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
実装者:implementer:~
	対応-:correspond:~
	もたらす-:introduce:~
	導入:introduction:~
導出-:derive:~
波及-:impact:~
意味-:mean:~
意図-:intend:~
	成す:constitute:~
所与の:given:与えられた
手段:means:~
手続き:steps:~
段:step:~
拡張:extension:~
	指す:refer する:~
指定-:specify:~
提供-:provide:~
作者:author:~
	例:example:~
	例えば:for example:~
全部的:full:~
依拠-:rely:~
	依然として:still:~
知識:knowledge:~
最適:optimal:~
最適化-:optimize:~
有意な:significant:~
	望む:wish する:~
期待-:expect:~
予期-:expect:~
概して:typical に:~
欠点:disadvantage:~
状況:situation:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
段階:stage:~
研究:studies:~
確保-:ensure:~
許容-:allow:~
	謝辞:acknowledgment:~
要求-:require:~
議論:discussion:~
適切:appropriate:~
適合性:conformance:~
	重要:important:~
	勧告案:Candidate Recommendation:~
注意深く:careful に:~
開発者:developer:~
将来:future:~
事例:case:~

	させたい-:prefer:~
	存続する限り:lifetime

	●保安
算出-:compute:~
軽減-:mitigate:~
cache:::キャッシュ
攻撃:attack:~
統計的指紋収集:statistical fingerprinting:~
分解能:resolution:~
privacy:::プライバシー
security:::セキュリティ

	●未分類
一意:unique:~
片:fragment:~
付加-:append:追加
作動中の:active な:~::アクティブ
作動中:active:~::アクティブ
値:value:~
入力:input:~
公開-:expose:~
共有-:share:~
具現化-:render:~::レンダー
具現化:rendering:~::レンダリング
描画:rendering:~::レンダリング
描画-:render:~::レンダー
内容:content:~
内部的:internal:~
初期時:initial 時:~
保証-:guarantee:~
優先度:priority:~
人:human:~
利用者:user:~::ユーザ
利用者対話:user-interaction:~::ユーザインタラクション
知覚-:perceive:~
	~perception:::
	利用者が知覚し得る:user-perceptible:~
	知覚し得る:perceptible:~

単独の:single:~
単純:simple:~
可視:visible:~
合成:compositing:~
情報:information:~
抑える:reduce する:~
文書:document:~
属性:attribute:~
引数:argument:~
構築-:construct:~
機器:device:~
決定-:determine:~
演算:operation:~
電力消費:power-usage:~
節電:low-power:~
見出す:find する:~
解析:analytic:~
解決-:resolve:~
計算-:calculate:~
計算:computation:~
記録-:record:~
設定-:set:~
誘発-:trigger:~
部分的:partial:~
長さ:length:~
除去-:remove:~
非互換:incompatible:~
音声:audio:~
順序:order:~
	高い:high:~
新たな:new:~
flag:::フラグ
空:empty:~
一般:general:~


	別の:another:~
	利用-:use:~
	利用ing:using:~
	各:each:~
	後:after:~
	後続の:subsequent:~
	必要-:need:~
	必ずしも〜ない:necessarily:~
	数:number:~
	新たに:newly:~
	書く:write する:~
	最も容易な:easiest:~
	最も近い:closest:~
	最大:maximum:~
	最後の:last:~
	最終的:eventual:~
	次の:next:~
	次の:the-following:~
	正の:positive:~
	~~精度:accurate:~
	求める:want する:~
	渡す-:pass する:~
	短い:short:~
	示-:show:~
	示され:shown:~
	空にする:clear:~
	立場:position:~
	結果:result:~
	結果の:resulting:~
	ある程度の:non-trivial:~
	non-trivial
	返-:return:~
	述べ-:describe:~
	追加の:additional:~

	選ぶ:choose する:~
	避ける:avoid する:~
	重い:heavy:~
	量:amount:~
	~entry~s:entries:~
	この:this:~
	これらの:these:~
	したがって:therefore:~
	すべて:all:~
	そのような:such:~
	なり得る:potential:~
	みなす:deem:~
	より:more:~
	より早期の:earlier:~
	より良い:better:~
	より高い:higher:~
	下:below:~
	与-:give:~
	両者:both:~
	事前に具現化:pre-rendering:~
	介:via:~
	during:~
	interested:~
	加わるjoin:~
	mailing:~
	current:~
	50m:~
	iDL:~
	占める／taken:~
	lET:~
	rET:~
	iF:~
	option:~
	AND:~
	lTE:~
	slow-down:~
	now:~
	LET:~
	t:~
	ELSE_:~
	F:~
	EQ:~
	IF:~
	GT:~
	gTE:~
	sET:~
	doc:~
	EACH:~
	doclist:~
	runlist:~
	LT:~
	SET:~
	T:~
	長時間~稼働する~long~running
	微小な~very~small
	小さな~small
	どの程度の時間を要するhow long each of these callbacks are likely to take

</script>



<!--%style  -->

<style type="text/css">

p {
	font-stretch: condensed;
}

._frames1 {
	white-space: nowrap;
}
._frames1 ._period {
	display: inline-block;
	border: solid #F0C441 1px;
	background:#FEF3CE;
	padding: 0.1em;
}

._frames1 ._task {
	display: inline-block;
	border-style: solid;
	border-width: 2px;
	padding: 3px;
	line-height: 1.1em;
	min-height: 2.2em;
	min-width: 4em;
	text-align: center;
	border-radius: 5px;
	vertical-align: middle;
}
._idle_callback {
	border-color: orange;
	background: #F0C441;
}

._UA_task {
	border-color:#4385C5;
	background:#D0E2F2;
}

._deadline {
	background: white;
	text-align: center;
	font-size: smaller;
}

._vsync {
	display: inline-block;
	border-left: dashed currentcolor 2px;
	color: black;
	height: 7em;
	width: 0;
	vertical-align: middle;
	position: relative;
}
._vsync > div {
	position:absolute;
	text-align:center;
}

</style>

</head>
<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">
<h1>Cooperative Scheduling of Background Tasks 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題に日付にて<strong >作業草案</strong>として公開された
<a id="_SPEC_URL">Cooperative Scheduling of Background Tasks</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新： <time>2016-06-07</time>
（公開：<time>2015-11-27</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>



<header>

<div><a href="http://www.w3.org/" id="_W3C">W3C</a></div>


<h1>背景タスクの協同的なスケジュール法 — Cooperative Scheduling of Background Tasks</h1>
<h2>2016 年 5 月 17 日 W3C 作業草案</h2>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dd>http://www.w3.org/TR/2016/WD-requestidlecallback-20160517/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>http://www.w3.org/TR/requestidlecallback/</dd>

	<dt title="Latest Editor’s Draft:">最新の編集者草案</dt>
	<dd>https://w3c.github.io/requestidlecallback/</dd>

	<dt title="Previous version:">以前のバージョン</dt>
	<dd>http://www.w3.org/TR/2016/WD-requestidlecallback-20160428/</dd>

	<dt title="Editors:">編集</dt>
	<dd>Ross McIlroy, Google Inc., rmcilroy@chromium.org</dd>
	<dd>Ilya Grigorik, Google Inc., igrigorik@gmail.com</dd>

	<dt>Repository:</dt>
	<dd><a href="https://github.com/w3c/requestidlecallback/">We are on Github.</a></dd>
	<dd><a href="https://github.com/w3c/requestidlecallback/issues">File a bug.</a></dd>
	<dd><a href="https://github.com/w3c/requestidlecallback/commits/gh-pages/index.html">Commit history.</a></dd>
	<dd><a href="https://github.com/w3c/web-platform-tests/tree/master/requestidlecallback">Tests.</a></dd>
</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
© 2016
<a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
<a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
<a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>).
W3C
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and
<a rel="license" href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a>
rules apply.
</small>


</header>


<div id="MAIN" style="display:none;">



	<section id="abstract">
<p>
この文書は、~web頁~作者が背景~taskと協同して~scheduleするために
— すなわち，［
入力~処理／~animation／~frame合成
］などの，同じ~event~loopを共有する高~優先度~taskに遅延をもたらさないように — 
利用できる API を定義する。
~UAは、［
現在~scheduleされている~task, ~vsync刻限, 利用者対話, 等々
］の知識を有するので、背景~taskを［
~animationや入力~応答にて
利用者が知覚し得る遅延や~jank
］をもたらすことなく，いつ稼働できるかを決定するにあたって、~~有利な立場にある。
したがって，この API を利用すれば、背景~taskは，~UAが遊休~中のときに稼働されるように，より適切に~scheduleされるはずである。
◎
This document defines an API that web page authors can use to cooperatively schedule background tasks such that they do not introduce delays to other high priority tasks that share the same event loop, such as input processing, animations and frame compositing. The user agent is in a better position to determine when background tasks can be run without introducing user-perceptible delays or jank in animations and input response, based on its knowledge of currently scheduled tasks, vsync deadlines, user-interaction and so on. Using this API should therefore result in more appropriate scheduling of background tasks during times when the browser would otherwise be idle.
</p>

	</section>
	<section id="sotd">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<em>この節では、発行時点における…</em>
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>
に委譲
】</span></p>

<!-- 

This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at http://www.w3.org/TR/.

This is a work in progress and may change without any notices.

Implementers SHOULD be aware that this document is not stable. Implementers who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways. Vendors interested in implementing this document before it eventually reaches the Candidate Recommendation stage SHOULD join the mailing lists below and take part in the discussions.

This document was published by the Web Performance Working Group as an Editor's Draft. If you wish to make comments regarding this document, please send them to public-web-perf@w3.org (subscribe, archives) with [RequestIdleCallback] at the start of your email's subject. All comments are welcome.

Publication as an Editor's Draft does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.

This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.

This document is governed by the 1 September 2015 W3C Process Document. 

-->

<p id="unstable">
<strong>
実装者は、この仕様が安定的ではないことに留意すべきです。
</strong>
議論に加わっていない実装者は、仕様が互換でない形に変更されていく~~状況に直面するかもしれません。
この仕様の実装に関心のある~vendorは、この仕様が最終的に勧告案に達する前に，前述のメーリングリストに加入して 議論に加わるべきです。
◎
Implementers SHOULD be aware that this document is not stable. Implementers who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways. Vendors interested in implementing this document before it eventually reaches the Candidate Recommendation stage SHOULD join the mailing lists below and take part in the discussions.
</p>

	</section>

<nav class="toc" id="table-of-contents">
<h2 title="Table of Contents">目次</h2>
<ol id="_toc_list0"></ol>
</nav>

<main id="MAIN0">


	<section id="introduction" class="informative">
<h2 title="Introduction">1. 序論</h2>
<p>
~web頁では、~UAの~event~loop上で，背景~taskを実行することが求められることが多い。
背景~taskとは、
“時間に厳しい”
~task
【 time-critical — 所定の刻限までに終えることが求められる~task 】
ではないが，有意な時間はかかるような、計算~taskである。
そのような~taskの例には、［
解析~dataを記録する ／
長時間~稼働し続けるような~data処理~演算 ／
~client側~templating ／
近い未来に可視になると見込まれる内容を 事前に具現化しておく
］などが挙げられる。
これらの~taskは、~event~loopを，時間に厳しい他の演算（例えば［
利用者~入力に反応する ／
`requestAnimationFrame()$m `ANIMATION-TIMING$r を利用する ~scriptに基づく~animation
］など）と共有しなければならない。
これらの背景~taskは、概して，［
`setTimeout()$m を利用して~callbackを~scheduleして，その~callbackにて背景~taskを稼働する
］ことにより遂行されている。
◎
Web pages often want to execute computation tasks on the browser's event loop which are not time-critical, but might take a significant portion of time to perform. Examples of such background tasks include recording analytics data, long running data processing operations, client-side templating and pre-rendering of content likely to become visible in the near future. These tasks must share the event loop with other time-critical operations, such as reacting to input and performing script-based animations using requestAnimationFrame ([ANIMATION-TIMING]). These background tasks are typically performed by scheduling a callback using [setTimeout] and running the background task during that callback.
</p>

<div class="p">
<p>
この~approachの欠点は：
</p>

<ul>
	<li>
~scriptの作者には、
`setTimeout()$m に与えた~callbackが［
時間に厳しいのか，~UAが遊休~中になるまで遅延できるのか
］について，~UAに伝えるすべがない。
</li>
	<li>
~UAは、［［
時間に厳しい演算の遅延や，~jankその他の利用者が知覚し得るような遅延
］をもたらすことなく，いつまで~callbackを実行し続けられるか
］についての情報を，~callbackに提供できない。
</li>
</ul>

<p>
その結果，作者にとっては、単純に［
微小な値を引数に `setTimeout()$m を~callして，その~callbackの中で最小限に細分化された仕事をこなし，追加の仕事を `setTimeout()$m への別の~callで再度~scheduleする
］のが，最も容易になるが、これは：
</p>

<ul>
	<li>
多数の小さな~taskを~UAの~event~loopに~postして，それらの実行を~scheduleすることによる，余計な~overheadがあるので、最適とは言えない。
</li>
	<li>
~UAが，［
これらの~callbackのそれぞれを，時間に厳しい他の仕事の合間に適切に差挟む
］ことに依拠しているが、そうするのは困難である
— ~UAは、それぞれの~callbackが要する時間について正確0な前提を置けないので。
</li>
</ul>

◎
A disadvantage of this approach is that the author of the script has no way to inform the user-agent as to whether a given setTimeout callback is time-critical or could be delayed until the browser is otherwise idle. In addition, the user agent isn't able to provide the callback with any information about how long it can continue to execute without delaying time-critical operations and causing jank or other user-perceptible delays. As a result, the easiest way forward is for the author is to simply call setTimeout with a very small value, and then execute the minimum possible chunk of work in the resulting callback and reschedule additional work with another call to setTimeout. This is less than optimal because there is extra overhead from having to post many small tasks on the user agent's event loop and schedule their execution. It also relies on the user-agent interleaving other time-critical work between each of these callbacks appropriately, which is difficult since the user-agent can't make accurate assumptions on how long each of these callbacks are likely to take.
</div>

<p>
この文書にて述べられる API により、~script作者は，［
~callbackを，~UAが遊休~中になったなら~callされるように~scheduleする
］よう，~UAに要請することが可能になる。
~UAは、その~callbackに［
自身の見積もりによる，自身が遊休~中であり続ける時間
］を，刻限（ deadline ）として渡す。
頁~作者は、その刻限を利用して，［
~callbackが実行する背景~taskが，~animationや, 利用者~入力に対する応答などの~~遅延に厳しい~eventに波及しない
］ことを確保できる。
◎
The API described in this document allows script authors to request the user-agent to schedule a callback when it would otherwise be idle. The user agent provides an estimation of how long it expects to remain idle as a deadline passed to the callback. The page author can use the deadline to ensure that these background tasks don't impact latency-critical events such as animation and input response.
</p>

<p>
この API を利用して、背景~taskを書く例を示す：
◎
Here is an example of using the API to write a background task.
</p>

<div class="example">
<pre>
&lt;!DOCTYPE html&gt;
&lt;title&gt;<span class="comment">
`requestIdleCallback()$m を利用して、背景~taskを~scheduleする
◎
Scheduling background tasks using requestIdleCallback
</span>&lt;/title&gt;
&lt;script&gt;
var %requestId = 0;
var %pointsTotal = 0;
var %pointsInside = 0;

function piStep() {
  var %r = 10;
  var %x = Math.random() * %r * 2 - %r;
  var %y = Math.random() * %r * 2 - %r;
  return (Math.pow(%x, 2) + Math.pow(%y, 2) &lt; Math.pow(%r, 2))
}
function refinePi(%deadline) {
  while (%deadline.timeRemaining() &gt; 0) {
    if (piStep())
      %pointsInside++;
    %pointsTotal++;
  }
  var %currentEstimate = (4 * %pointsInside / %pointsTotal);
  var %textElement = document.getElementById("piEstimate");
  %textElement.innerHTML="Pi Estimate: " + %currentEstimate;
  %requestId = window.requestIdleCallback(refinePi);
}
function start() {
  %requestId = window.requestIdleCallback(refinePi);
}
function stop() {
  if (%requestId)
    window.cancelIdleCallback(%requestId);
  %requestId = 0;
}
&lt;/script&gt;
&lt;button onclick="start()"&gt;クリックで開始&lt;/button&gt;
&lt;button onclick="stop()"&gt;クリックで停止&lt;/button&gt;
&lt;div id="piEstimate"&gt;まだ開始されていない&lt;/div&gt;
</pre>

<!-- 
Click me to start!
Click me to stop!
Not started
 -->
</div>


	</section>
	<section id="idle_period" class="informative">
<h2 title="Idle Periods">2. 遊休~期間</h2>

~INFORMATIVE

<p>
~UAの~main-threadは、［
入力~処理, および
所与の~frameに対する 具現化＆合成
］が完了してから，［
次の~frameが始まる ／
別の処理待ち~taskが稼働可能になる ／
利用者からの入力を受取る
］のいずれかが生じるまでは、遊休~中になることが多い。
この仕様は、この遊休~中の間に ~callbackの実行を~scheduleする手段を， `requestIdleCallback()$m を介して提供する。
◎
After input processing, rendering and compositing for a given frame has been completed, the user agent's main thread often becomes idle until either: the next frame begins; another pending task becomes eligible to run; or user input is received. This specification provides a means to schedule execution of callbacks during this otherwise idle time via a requestIdleCallback API.
</p>

<p>
`requestIdleCallback()$m を介して~postされた~callbackには、~UAにより定義される遊休~期間にて稼働可能になる。
遊休~callback
【 “~UAの遊休~期間に~callされるものとして，作者が与える~callback関数” 】
の稼働-時には、現在の遊休~期間の終端に対応する刻限が渡される。
何をもって遊休~期間とするかは，~UAにより定義されるが、［
~UA自身が遊休~中にあると予期するような， “~~静止” 期間
］に生じるものと期待される。
◎
Callbacks posted via the requestIdleCallback API become eligible to run during user agent defined idle periods. When an idle callback is run it will be given a deadline which corresponds to the end of the current idle period. The decision as to what constitutes an idle period is user agent defined, however the expectation is that they occur in periods of quiescence where the browser expects to be idle.
</p>

<p>
遊休~期間の一例として、次の図に示されるような，［
所与の~frameを~screenへ~commitしてから，作動中の~animationの間に次の~frameの処理を開始するまで
］の時区間が挙げられる。
そのような遊休~期間は，~animationが作動中にあり, ~screenが更新され続ける間に，高頻度に生じるが、概して とても短くなる（すなわち、~vsync周期が 60Hz の機器においては約 16ms 以下）。
◎
One example of an idle period is the time between committing a given frame to the screen and starting processing on the next frame during active animations, as shown in Fig. 1 Example of an inter-frame idle period . Such idle periods will occur frequently during active animations and screen updates, but will typically be very short (i.e., less than 16ms for devices with a 60Hz vsync cycle).
</p>


<figure id="figure1">
<!-- requestidlecallback/image01.png -->
<div style="padding: 1em 0;">
	<div class="_frames1">
…
		<div class="_vsync">
<div style="top:-1.3em;left:-4em;width:8em; font-size:small;">~vsync</div>
		</div>

<span class="_task _UA_task">入力を<br>取扱う</span>
<span class="_task _UA_task">~animation<br>~frame要請</span>
<span class="_task _UA_task">~frame<br>~commit</span>
		<div class="_period">
遊休~期間<br />
<span class="_task _idle_callback">遊休<br>~callback</span>
<span class="_task _idle_callback">遊休<br>~callback</span>
		</div>
		<div class="_vsync">
<div style="top:-1.3em;left:-4em;width:8em; font-size:small;">~vsync</div>
		</div>
<span class="_task _UA_task">入力を<br>取扱う</span>
…
	</div>
	<div style="border-top: solid black 1px;" title="時間軸">
時間 →
<span style="float:right;">→</span>
	</div>
</div>
<figcaption>
~frame間の遊休~期間の例
◎
Example of an inter-frame idle period
</figcaption></figure>

<p class="note">
~web開発者は、遊休~callbackの間に その演算が遂行するすべての仕事を【非同期的なものも含めて】勘定に入れるよう，注意深くなるべきである。
一部の演算
— 例えば、~promiseを解決する, あるいは頁~layoutを誘発するものなど —
は、遊休~callbackが終わった後にも，後続の~taskを~scheduleさせ得る。
そのような事例では、刻限を過ぎる前に，これらの演算を次の~frame刻限の前に遂行できるように先送りするべきである。
◎
The web-developer should be careful to account for all work performed by operations during an idle callback. Some operations, such as resolving a promise or triggering a page layout, may cause subsequent tasks to be scheduled to run after the idle callback has finished. In such cases, the application should account for this additional work by yielding before the deadline expires to allow these operations to be performed before the next frame deadline.
</p>

<p>
遊休~期間の別の例として、~screenの更新がないときの遊休~~状態が挙げられる。
そのような状況では、~UAが遊休~期間を早々に終端させ得るような差し迫った~taskがないときでも、いつ起きるか予測不能な~task
— 利用者~入力の処理など —
により，利用者が知覚し得る遅延が起きないようにするため、遊休~期間の長さは，
<a href="#why50">50ms を上限にする</a>べきである。
遊休~期間が終わり，まだ遊休~中にあるならば、~UAは，次の図に示されるように，別の遊休~期間を~scheduleできる
— 背景~仕事は、複数の遊休~期間にわたり，何回でも存続し続けられる。
◎
Another example of an idle period is when the user agent is idle with no screen updates occurring. In such a situation the user agent may have no upcoming tasks with which it can bound the end of the idle period. In order to avoid causing user-perceptible delays in unpredictable tasks, such as processing of user input, the length of these idle periods should be capped to a maximum value of 50ms. Once an idle period is finished the user agent can schedule another idle period if it remains idle, as shown in , to enable background work to continue to occur over longer idle time periods.
</p>


<figure id="figure2">
<!-- requestidlecallback/image00.png -->
<div style="padding-bottom: 1em;">
	<div class="_frames1">
…
<span class="_task _UA_task">~frame<br>~commit</span>
		<div class="_vsync">
<div style="top:-1.3em;left:-4em;width:8em; font-size:small;">~vsync</div>
		</div>

		<div class="_period">
<div class="_deadline">← 50ms 刻限 →</div>
遊休~期間<br />
<span class="_task _idle_callback">遊休<br>~callback</span>
<span class="_task _idle_callback">遊休<br>~callback</span>
		</div>

		<div class="_period" style="position:relative;">
<div class="_deadline">← 50ms 刻限 →</div>
遊休~期間<br />
<span class="_task _idle_callback">遊休<br>~callback</span>
<span class="_task _idle_callback">遊休<br>~callback</span>
<div style="position:absolute; right:1em;">　　　↑<br><span style="background: white;">利用者~入力</span></div>
		</div>

<span class="_task _UA_task">入力を<br>取扱う</span>
…
	</div>
	<div style="border-top: solid black 1px;" title="時間軸">
時間 →
<span style="float:right;">→</span>
	</div>
</div>
<figcaption>
処理待ちの~frame更新はないときの遊休~期間の例
◎
Example of an idle period when there are no pending frame updates
</figcaption></figure>


<p>
遊休~期間の間，~UAは、各 遊休~callbackを［
遊休~期間が終端するか, または
稼働可能とされている遊休~callbackをすべて稼働し終える
］まで、要請された順に稼働することになる。
すなわち、~UAは必ずしも，~postされた遊休~callbackすべてを単独の遊休~期間~内に稼働させることはない。
残りの遊休~taskは、次の遊休~期間にも稼働可能であり続ける。
◎
During an idle period the user agent will run idle callbacks in FIFO order until either the idle period ends or there are no more idle callbacks eligible to be run. As such, the user agent will not necessarily run all currently posted idle callbacks within a single idle period. Any remaining idle tasks are eligible to run during the next idle period.
</p>


<p>
現在の遊休~期間にて稼働可能であるとされる遊休~taskは、その遊休~期間が開始される前に~postされたものに限られる。
したがって、ある遊休~callbackが `requestIdleCallback()$m を利用して別の~callbackを~postしたならば、その~callbackは，現在の遊休~期間においては稼働しないことになる。
これにより、遊休~callbackは，自身の仕事を所与の刻限までに完了できない場合には，未来の遊休~期間にまた稼働させるように自身を再度~postできるようになる。
すなわち、次の例の様に，遊休~期間が短か過ぎるときは先送りする~code~patternも可能になる：
◎
Only idle tasks which posted before the start of the current idle period are eligible to be run during the current idle period. As a result, if an idle callback posts another callback using requestIdleCallback, this subsequent callback won't be run during the current idle period. This enables idle callbacks to re-post themselves to be run in a future idle period if they cannot complete their work by a given deadline - i.e., allowing code patterns like the following example, without causing the callback to be repeatedly executed during a too-short idle period:
</p>


<div class="example"><pre>
function doWork(%deadline) {
  if (%deadline.timeRemaining() &lt;= 5) {
    /* <span class="comment">
この仕事は 5ms 以上かかるので、刻限の余裕が十分になるまで，先送りする。
◎
This will take more than 5ms so wait until we get called back with a long enough deadline.
</span> */
    requestIdleCallback(doWork);
    return;
  }
  /* <span class="comment">
何らかの仕事を行う…
◎
do work...
</span> */
}
</pre></div>


<p>
新たに~postされた遊休~callbackは、次の遊休~期間の開始~時に，`稼働可能な遊休~callbackの~list$の末尾に付加される。
したがって，再~postされる~callbackたちは、~round-robin式に
— 各~callbackが［
同じ遊休~期間における，より早期の~taskにより再~postされた~callback
］より前に稼働する機会が得られるように —
稼働することが確保される。
◎
At the start of the next idle period newly posted idle callbacks are appended to the end of the runnable idle callback list, thus ensuring that reposting callbacks will be run round-robin style, with each callback getting a chance to be run before that of an earlier task's reposted callback.
</p>

<p class="note">注記：
この仕様の将来~versionでは、他の~schedule方策も許容され得る。
例えば、遊休~callbackを同じ遊休~期間の中で~scheduleしたり、少なくとも X ~milli-秒 以上の遊休~期間, 等々。
現在の仕様は、~callbackが［
自身の~logicを実行したり，次の遊休~期間に自身を再~postできる
］ような，次の遊休~期間に~scheduleする事例のみを~supportする
◎
Future versions of this specification could allow other scheduling strategies. For example, schedule idle callback within the same idle period, a period that has at least X milliseconds of idle time, and so on. Current specification only supports the case for scheduling into the next idle period, at which time the callback can execute its logic, or repost itself into the next idle period.
</p>

<p>
~UAは、~web頁が利用者から可視でない下では、機器の電力消費を抑えるためなど，遊休~期間の生成を間引くこともできる
— 例えば，毎 10 秒ごとに一回にするなど。
◎
When the user agent determines that the web page is not user visible it can throttle idle periods to reduce the power usage of the device, for example, only triggering an idle period every 10 seconds rather than continuously.
</p>

<p>
最後に，目立たないが重要な点として、頁の負荷が高い間は，~UAが遊休~期間として可用な CPU 時間をあてがう保証-はないことに注意。
~UAが遊休~期間を何ら~scheduleしないことも，まったく受容可能であり、その場合，
`requestIdleCallback()$m を介して~postされた遊休~callbackは、不定期に先送りされることにもなり得る。
作者は、~callbackを遊休~期間~内に実行させたいが，ある時間までに実行することを要する場合には、
`requestIdleCallback()$m の %options 引数に `timeout$m ~memberを提供できる
— 遊休~期間~内に~callbackが実行される前に，指定された~timeoutに達した場合、それを実行する~taskが待入される。
◎
A final subtlety to note is that there is no guarantee that a user agent will have any idle CPU time available during heavy page load. As such, it is entirely acceptable that the user agent does not schedule any idle period, which would result in the idle callbacks posted via the requestIdleCallback API being postponed for a potentially unbounded amount of time. For cases where the author prefers to execute the callback within an idle period, but requires a time bound within which it can be executed, the author can provide the timeout property in the options argument to requestIdleCallback: if the specified timeout is reached before the callback is executed within an idle period, a task is queued to execute it.
</p>

<p class="note" id="why50">
刻限の上限 50ms は、 `RESPONSETIME$r の研究から導出されたものである
— そこでは、利用者~入力に対する 100ms 内の応答は，一般に人にとっては瞬間的であると知覚されることが示されている。
したがって，遊休~taskが始まった直後に利用者~入力が生じたとしても、~UAには，［
利用者から知覚されることなく 入力に応答するための猶予
］として， 50ms が残されることになる。
◎
The maximum deadline of 50ms is derived from studies [RESPONSETIME] which show that that a response to user input within 100ms is generally perceived as instantaneous to humans. Capping idle deadlines to 50ms means that even if the user input occurs immediately after the idle task has begun, the user agent still has a remaining 50ms in which to respond to the user input without producing user perceptible lag.
</p>
	</section>
	<section id="conformance">

<h2 title="Conformance">3. 適合性</h2>
<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>
<!-- 
As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.

The key words MUST, REQUIRED, SHALL, and SHOULD are to be interpreted as described in [RFC2119].

The IDL fragments in this specification MUST be interpreted as required for conforming IDL fragments, as described in the Web IDL specification. [WEBIDL]

This specification defines a single conformance class:

conforming user agent
    A user agent is considered to be a conforming user agent if it satisfies all of the MUST-, REQUIRED- and SHALL-level criteria in this specification. A conforming user agent must also be a conforming implementation of the IDL fragment in section 4. Window interface extensions, as described in the Web IDL specification [WEBIDL].
 -->

	</section>
	<section id="window_extensions">

<h2 title="Window interface extensions">4. `Window^I ~interfaceに対する拡張</h2>

<p>
`requestIdleCallback()$m 演算は、下の IDL 片による部分的~interfaceにより，
`Window$I ~obj上で公開される。
`HTML5$r
◎
The partial interface in the IDL fragment below is used to expose the requestIdleCallback operation on the [Window] object. [HTML5]
</p>

⇒！
partial interface `Window!I {
  unsigned long `requestIdleCallback$m(
      `IdleRequestCallback$I %callback,
      `IdleRequestOptions$I %options
  );
  void `cancelIdleCallback$m(unsigned long %handle);
};

dictionary `IdleRequestOptions@I {
  optional unsigned long `timeout@m;
};

interface `IdleDeadline@I {
  `DOMHighResTimeStamp$I `timeRemaining$m();
  readonly attribute boolean `didTimeout$m;
};

callback `IdleRequestCallback@I = void (`IdleDeadline$I %deadline);
◎


<p>
各 `Window$I は、次のものを持つ：
◎
Each Window has:
</p>


<dl class="def-list">
	<dt>`要請された遊休~callbackの~list@</dt>
	<dd>
初期時は空で~MUST。
~list内の各~entryは数で識別され、その数は，当の `Window^I ~objが存続する限り，~list内で一意にされ~MUST。
◎
A list of idle request callbacks. The list MUST be initially empty and each entry in this list is identified by a number, which MUST be unique within the list for the lifetime of the Window object.
</dd>
	<dd class="trans-note">【
数~自体には特に意味はなく、~list内に同一の~callbackが複数あっても，~list内の位置ごとに別々に扱うことを意味すると見られる。
次項も同様。
】</dd>

	<dt>`稼働可能な遊休~callbackの~list@</dt>
	<dd>
初期時は空で~MUST。
~list内の各~entryは数で識別され、その数は，当の `Window^I ~objの存続期間にわたり，~list内で一意にされ~MUST。
◎
A list of runnable idle callbacks. The list MUST be initially empty and each entry in this list is identified by a number, which MUST be unique within the list of the lifetime of the Window object.
</dd>

	<dt>`遊休~callback識別子@</dt>
	<dd>
整数。
初期時は~zeroで~MUST。
◎
An idle callback identifier, which is a number which MUST initially be zero.
</dd>

</dl>

<p>
%window の
`遊休~callback~list内@
とは、 %window の［
`要請された遊休~callbackの~list$内, `稼働可能な遊休~callbackの~list$内
］の総称である。
</p>

		<section id="the-requestidlecallback-method">
<h3 title="The requestIdleCallback method">4.1 `requestIdleCallback()^m ~method</h3>

<p>
`requestIdleCallback(callback, options)@m
~methodの被呼出時には、次を~~実行し~MUST：
◎
When requestIdleCallback(callback, options) is invoked, the user agent MUST run the following steps:
</p>


<ol>
	<li>
%window ~LET この `Window$I ~obj
◎
Let window be this Window object.
</li>
	<li>
%window の`遊休~callback識別子$ ~INCBY 1
◎
Increment the window's idle callback identifier by one.
</li>
	<li>
%~handle ~LET %window の現在の`遊休~callback識別子$
◎
Let handle be window's idle callback identifier current value.
</li>
	<li>
%遊休~callback ~SET 次のように設定された新たな`遊休~callback$
⇒
( `~callback$, `~handle$ ) ~SET ( %callback, %~handle )
◎
Append callback to window's list of idle request callbacks, associated with handle.
</li>

	<li>
%遊休~callback を %window の`要請された遊休~callbackの~list$に付加する
◎
↑</li>

	<li>
~RET %~handle
— ただし、以下の手続きは非同期に継続する。
◎
Return handle and then continue running this algorithm asynchronously.
</li>
	<li>
<p>
~IF［
%options に `timeout$m ~memberは在する ~AND
その値 ~GT 0
］：
◎
If the timeout property is present in options and has a positive value:
</p>
		<ol >
			<li>
%~timeout ~LET
現在時刻 ~PLUS ( `timeout^m ~member値を~milli-秒~単位による時間の長さとして解釈した結果 )
◎
↓</li>
			<li>
［
現在時刻 ~GTE %~timeout
］になるまで待機する
◎
Wait for timeout milliseconds.
</li>
			<li>
~IF［
この~algoの他の呼出にて，この~algoの中で待機しているもののうち，［
そこでの %~timeout ~LT この %~timeout
］なるものがある
⇒
それらすべてが この~algoを終えるまで待機する
◎
Wait until all invocations of this algorithm, whose timeout added to their posted time occurred before this one's, have completed.
</li>
			<li>
<p>
任意選択で、~UAが定義する時間だけ更に待機する
◎
Optionally, wait a further user-agent defined length of time.
</p>

<p class="note">
この段が意図する所は、~UAが機器の電力消費を最適化する必要に応じて，~timeoutを pad できるようにするためである。
例えば、~timerの粒度を抑えるような節電~modeを有する~processorも中にはあり、そのような~platform上では，~UAは，より正確0な非~節電~modeを利用することを要求する代わりに，この~scheduleに見合うように~timerを slow down できる。
◎
This is intended to allow user agents to pad timeouts as needed to optimise the power usage of the device. For example, some processors have a low-power mode where the granularity of timers is reduced; on such platforms, user agents can slow timers down to fit this schedule instead of requiring the processor to use the more accurate mode with its associated higher power usage.
</p>

<p class="trans-note">【
“pad”, “slow down” が，時間の進行を遅らすのか, 実装が保有する すべての［ 刻限／~timeout ］を延期する（遅延を加算する）のかは、明確に述べられていない
— いずれにせよ、その違いは， API には現れないためと見られる。
】</p>

			</li>
			<li>
次を行う~taskを，`遊休task~task源$の`待行列に入れる$
⇒
( %window, %~handle )
を与える下で，`~timeoutに達した遊休~callbackを呼出す~algo$を遂行する
◎
Queue a task on the queue associated with the idle-task task source, which performs the invoke idle callback timeout algorithm, passing handle and window as arguments.
</li>
		</ol>
	</li>
</ol>



<p class="note">
`requestIdleCallback()$m は、［
単独の`遊休~期間$~内に実行されることになる，~callbackの一回の~call
］のみを~scheduleする。
その~callbackは、 %刻限 までに自身の仕事を完了できないならば、その~taskを継続するための未来の~callを~scheduleするために，再度 `requestIdleCallback()$m を~callした上で（それは，~callback自身の中で行い得る）、制御を即時に`~event~loop$に返すべきである。
◎
requestIdleCallback only schedules a single callback, which will be executed during a single idle period. If the callback cannot complete its work before the given deadline then it should call requestIdleCallback again (which may be done from within the callback) to schedule a future callback for the continuation of its task, and exit immediately to return control back to the event loop.
</p>
		</section>
		<section id="the-cancelidlecallback-method">
<h3 title="The cancelIdleCallback method">4.2 `cancelIdleCallback()^m ~method</h3>

<p>
`cancelIdleCallback(handle)@m
~methodは、以前に行った`遊休~callback$を~scheduleする要請を取消す。
被呼出時には、次を走らせ~MUST：
◎
The cancelIdleCallback method is used to cancel a previously made request to schedule an idle callback. When cancelIdleCallback(handle) is called, the user agent MUST run the following steps:
</p>

<ol>
	<li>
%window ~LET この `Window$I ~obj
◎
Let window be this Window object.
</li>
	<li>
~IF［
%window の`遊休~callback~list内$に［
`~handle$ ~EQ %~handle
］なる`遊休~callback$がある
］
⇒
%window の`遊休~callback~list内$から その`遊休~callback$を除去する
◎
Find the entry in either the window's list of idle request callbacks or list of runnable idle callbacks that is associated with the value handle.
◎
If there is such an entry, remove it from both window's list of idle request callbacks and the list of runnable idle callbacks.
</li>
</ol>

<p class="note">
`cancelIdleCallback()$m
は、稼働可能かどうかにかかわらず， %window の`遊休~callback~list内$から`遊休~callback$を除去する。
◎
cancelIdleCallback might be invoked for an entry in window's list of idle request callbacks or the list of runnable idle callbacks. In either case the entry should be removed from the list so that the callback does not run.
</p>

		</section>
		<section id="the-timeremaining-method">
<h3 title="The timeRemaining method">4.3 `timeRemaining()^m ~method</h3>

<p>
各 `IdleDeadline$I ~objには、次のものが内部的に結付けられる：
</p>

<ul>
	<li>
`~callback刻限@
— 時間軸~上のある時点。
</li>
	<li>
`~timeout~flag@
— 指定されない限り， ~OFF。
</li>
</ul>


<p>
`timeRemaining()@m
~methodの被呼出時には、`~callback刻限$までの残り時間を，次の手続きで計算される `DOMHighResTimeStamp$I として返さ~MUST
— 結果の値は， 5 ~micro-秒までの~~精度に~~抑える~SHOULDである（
<a href="~HRTIME#privacy-security">~privacyと~security</a>
`HR-TIME-2$r
を見よ）：
◎
When the timeRemaining() method is invoked on an IdleDeadline object it MUST return the amount of time remaining before the callback's deadline as a DOMHighResTimeStamp. The value SHOULD be accurate to 5 microseconds - see "Privacy and Security" section of [HR-TIME]. This value is calculated by performing the following steps:
</p>

<ol>
	<li>
%刻限 ~LET `文脈~obj$の`~callback刻限$を `DOMHighResTimeStamp$I 値に換算した結果
◎
Let deadline be the deadline of the associated callback as a [DOMHighResTimeStamp]. [HR-TIME-2]
</li>
	<li>
%今 ~LET `performance.now()$m から返される時刻
◎
Let now be the value returned by [performance.now()].
</li>
	<li>
~RET Max( %刻限 − %今, 0 )
◎
Let timeRemaining be deadline - now.
◎
If timeRemaining is negative, set it to 0.
◎
Return timeRemaining.
</li>
</ol>

<p>
`didTimeout@m 属性は、［
`文脈~obj$の`~timeout~flag$ ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The didTimeout attribute on an IdleDeadline object MUST return true if the callback was invoked by the invoke idle callback timeout algorithm, and false otherwise.
</p>


		</section>
	</section>
	<section id="processing-model">
<h2 title="Processing Model">5. 処理~model</h2>

		<section id="start-an-event-loop-s-idle-period">
<h3 title="Start an event loop's idle period">5.1 ~event~loop の遊休~期間を開始させる</h3>

<p>
~UAは、所与の`~event~loop$ %loop に対し，その遊休~期間でない いつの時点であれ、［
%loop はある程度の時間 遊休~中であり続けると見込まれる
］, かつ［
%loop 上の背景~仕事は，［
他の`~event~loop$上に生じている より優先度の高い仕事
］に波及することなく実行できる
］ときは、 %loop に対し，新たな遊休~期間を起動する~SHOULDである。
◎
Whenever the user agent assesses that a given event loop is likely to remain idle for a non-trivial amount of time, and that background work could be executed on this event loop without impacting any high priority work occurring on other event-loops, it SHOULD initiate a new idle period for the event loop.
</p>

<p class="note">
~UAには、~event~loopが遊休~中になり次第，遊休~期間を定期的に起動することが期待される
— 例えば、定期的に生じる，~frameの描画-時と非~描画-時の合間など。
［
`文書$の `hidden$m 属性 ~EQ ~T
］の下では、`文書$に対する遊休~期間の生成を間引くこともできる
— 例えば、電力消費を最適化するため，
における一回の遊休~期間を毎 10 秒ごとに制限するなど。
◎
The expectation is that the user agent will initiate idle periods regularly when the event loop becomes idle, for example, in between frame rendering and regularly during times when no frames are being rendered. If the Document's hidden attribute ([PAGE-VISIBILITY]) is true then the user agent can throttle idle period generation, for example limiting the Document to one idle period every 10 seconds to optimize for power usage.
</p>

<p>
各
`遊休~callback@
は、次のものからなる：
</p>

<ul>
	<li>
`~callback@
— ~scheduleするよう要請された~callback関数。
</li>
	<li>
`~handle@
— この遊休~callbackを一意に識別する整数。
</li>
<!-- 
	<li>
状態（初期時は 待機中 ）
— 次のいずれか
待機中／稼働可能／処理済み
</li>
	<li>
~timeout
— ~NULL, または
時間軸~上のある時点
（他から指定されない限り ~NULL ）
</li>
 -->
</ul>

<p>
各 `~event~loop$には、
`~event~loop刻限@
— 時間軸~上のある時点（初期時は “過去” ）が結付けられる。
</p>

<!-- 
現在時刻とは、手続きの中で，その語が現れる段が実行された時点での時刻である。
-->

<p>
~UAは、`~event~loop$ %~event~loop の遊休~期間を開始させるときは、次を行わ~MUST：
◎
When the user agent wishes to start an event loop's idle period, the following steps MUST be performed:
</p>

<ol>
	<li>
［
現在時刻 ~GTE %~event~loop の`~event~loop刻限$
］になるまで待機する
◎
Let last_deadline be the last idle period deadline associated with the current event loop, or 0 if no previous deadline exists.
◎
If last_deadline is greater than the current time:
◎
Wait until the current time is greater than or equal to last_deadline.
</li>
	<li>
%今 ~LET 現在時刻
◎
Let now be the current time.
</li>
	<li>
%刻限 ~LET ~UAがその時点までは遊休~中であり続けるものと予期する，時間軸~上のある時点
◎
Let deadline be a time in the future until which the browser expects to remain idle.
</li>
	<li>
%刻限 ~SET Min( %今 + 50ms, %刻限 )
◎
If deadline - now is greater than 50ms, then cap deadline by setting it to be now + 50ms.
</li>
	<li>
`文書たち^V ~LET
%~event~loop に結付けられている`全部的に作動中の文書$からなる~list
◎
Let docs be the list of fully active Document objects associated with the event loop in question.
</li>
	<li>
<p>
`文書たち^V 内の~EACH( %文書 ) に対し：
◎
For every document in docs perform the following steps:
</p>
		<ol>
			<li>
%要請~list ~LET %文書 の `Window^I ~objの`要請された遊休~callbackの~list$
◎
Let doclist be document's Window object's list of idle request callbacks.
</li>
			<li>
%稼働可能~list ~LET %文書 の `Window^I ~objの`稼働可能な遊休~callbackの~list$
◎
Let runlist be document's Window object's list of runnable idle callbacks.
</li>
			<li>
%稼働可能~list に %要請~list 内のすべての`遊休~callback$を~list順に付加する
◎
Append all entries from doclist into runlist preserving order.
</li>
			<li>
%要請~list を空にする
◎
Clear doclist.
</li>
		</ol>
	</li>
	<li>
次を行う~taskを`待入する$
⇒
%刻限 を与える下で，`遊休~callbackを呼出す~algo$を遂行する
◎
Queue a task which performs the steps defined in the invoke idle callbacks algorithm with deadline as parameter.
</li>
	<li>
%~event~loop の`~event~loop刻限$ ~SET %刻限
◎
Save deadline as the last idle period deadline associated with the current event loop.
</li>
</ol>

<p>
これらの`~task$に対する`~task源$は、
`遊休task~task源@
である。
◎
The task source for these tasks is the idle-task task source.
</p>

<div class="note">
<p>
%今 から %刻限 までの時区間を指して，
`遊休~期間@
という。
ある時点で作動中の遊休~期間は、一つに限られる。
遊休~期間は、~UAが最早~遊休~中でないと決定した場合には，早期に終端し得る。
そうなった場合でも、次の遊休~期間は， %刻限 に達するまで開始できない。
◎
The time between now and deadline is referred to as the idle period. There can only be one idle period active at a given time. The idle period can end early if the user agent determines that it is no longer idle. If so, the next idle period cannot start until after deadline.
</p>

<div class="p">
<p>
~UAには、［
~callbackが %今 から %刻限 までの期間~全体にわたって稼働するとしても，時間に厳しい~taskは遅延されない
］ように、 %刻限 を選ぶことが期待される。
そのようなわけで、次のうちの最小に設定するべきである：
</p>

<ul>
	<li>
［［
`setTimeout()$m ／ `setInterval()$m
］を介して設定された`作動中の~timerの~list$
］内の，最も近未来の~timeout
</li>
	<li>
［
`requestAnimationFrame()$m を介して~postされた，処理待ちの~animation~callback
］に対し~scheduleされている実行時
</li>
	<li>
内部的な処理待ち~timeout
— 次の~frame描画の開始~刻限, 音声~処理, 他の~UAが重要とみなす内部的~taskなど。
</li>
	<li>
50ms 後の未来
— 予測不能な利用者~入力に対し，人から知覚される閾値~内に~~収まる応答性を確保するための、上限として。
</li>
</ul>

◎
Also note, the expectation is that the user agent will choose deadline to ensure that no time-critical tasks will be delayed even if a callback runs for the whole time period from now to deadline. As such, it should be set to the minimum of: the closest timeout in the list of active timers as set via [setTimeout] and [setInterval]; the scheduled runtime for pending animation callbacks posted via [requestAnimationFrame]; pending internal timeouts such as deadlines to start rendering the next frame, process audio or any other internal task the user agent deems important; and a maximum cap of 50ms in the future to ensure responsiveness to unpredictable user input within the threshold of human perception.
</div>

</div>


		</section>
		<section id="invoke-idle-callbacks-algorithm">
<h3 title="Invoke idle callbacks algorithm">5.2 遊休~callbackを呼出す~algo</h3>

<p>
`遊休~callbackを呼出す~algo@
は、 %刻限 が与えられた下で，次を走らす：
◎
The invoke idle callbacks algorithm:
</p>


<ol>
	<li>
`文書たち^V ~LET ［
`~UAにおいて^tnote
`全部的に作動中の文書$であって，その
`Window^I ~objの`稼働可能な遊休~callbackの~list$は空でないもの
］からなる~list
◎
Let docs be the list of fully active Document objects whose Window object's list of runnable idle callbacks is not empty.
</li>

	<li>
~IF［
現在時刻 ~GTE %刻限
］
⇒
~RET
◎
Let now be the current time.
◎
If now is less than deadline:
</li>
	<li>
%文書 ~LET `文書たち^V 内の任意の文書
◎
Select any document from docs.
</li>
	<li>
%稼働可能~list ~LET
%文書 の `Window^I ~objの`稼働可能な遊休~callbackの~list$
◎
↓</li>
	<li>
%遊休~callback ~SET %稼働可能~list 内の最初の~callback
◎
↓</li>
	<li>
%稼働可能~list から %遊休~callback を除去する
◎
Pop callback from document's Window object's list of runnable idle callbacks.
</li>
	<li>
~IF［
%稼働可能~list は空である
］
⇒
`文書たち^V から %文書 を除去する
◎
If document's Window object's list of runnable idle callbacks is now empty, remove document from docs.
</li>
	<li>
%刻限~引数 ~LET
次のように設定された，新たな `IdleDeadline$I ~obj
⇒
`~callback刻限$ ~SET %刻限
◎
Let deadlineArg be an IdleDeadline constructed with the given deadline and the didTimeout attribute set to false.
</li>
	<li>
%刻限~引数 を引数に %遊休~callback の`~callback$を~callする
— このとき
⇒
~scriptから~errorが投出された場合は、その`~errorを報告する$
◎
Call callback with deadlineArg as its argument. If an uncaught runtime script error occurs, then report the error.
</li>

	<li>
~IF［
`文書たち^V は空でない
］
⇒
~UAは、次を行う~taskを`待入する$~SHOULDである
⇒
%刻限 を与える下で，`遊休~callbackを呼出す~algo$を遂行する
◎
If docs is not empty, the user agent SHOULD queue a task which performs the steps in the invoke idle callbacks algorithm with deadline as parameter.
</li>
</ol>

<p class="note">
~UAは、 %刻限 がまだ来ていなくても，上の~algoの最後の段を実行せずに，遊休~期間を早期に終端させるのも自由である。
例えば~UAは、より優先度の高い稼働可能な仕事があれば，そうしてよい。
◎
The user agent is free to end an idle period early, even if deadline has not yet occurred, by not executing the last step of the above algorithm. For example, the user agent may decide to do this if it determines that higher priority work has become runnable.
</p>

		</section>
		<section id="invoke-idle-callback-timeout-algorithm">
<h3 title="Invoke idle callback timeout algorithm">5.3 ~timeoutに達した遊休~callbackを呼出す~algo</h3>

<p>
`~timeoutに達した遊休~callbackを呼出す~algo@
は、
( %window, %~handle )
が与えられた下で，次を行う：
◎
The invoke idle callback timeout algorithm:
</p>

<ol>
	<li>
%遊休~callback ~LET［
%window の`遊休~callback~list内$の［
`~handle$ ~EQ %~handle
］なる`遊休~callback$
］
◎
Let callback be the result of finding the entry in window's list of idle request callbacks or the list of runnable idle callbacks that is associated with the value given by the handle argument passed to the algorithm.
</li>
	<li>
~IF［
そのような %遊休~callback はない
］
⇒
~RET
◎
If callback is not undefined:
</li>
	<li>
%window の`遊休~callback~list内$から %遊休~callback を除去する
◎
Remove callback from both window's list of idle request callbacks and the list of runnable idle callbacks.
</li>
	<li>
%刻限~引数 ~LET
次のように設定された，新たな `IdleDeadline$I ~obj
⇒
`~callback刻限$ ~SET 現在時刻,<br>
`~timeout~flag$ ~SET ~ON
◎
Let now be the current time.
◎
Let deadlineArg be an IdleDeadline constructed with a deadline of now and the didTimeout attribute set to true.
</li>
	<li>
%刻限~引数 を引数に %遊休~callback の`~callback$を~callする
— このとき
⇒
~scriptから~errorが投出された場合は、その`~errorを報告する$
◎
Call callback with deadlineArg as its argument. If an uncaught runtime script error occurs, then report the error.
</li>
</ol>

		</section>
	</section>
	<section id="privacy-and-security">
<h2 title="Privacy and Security">6. ~privacyと~security</h2>


<p>
~UAは、遊休~callbackの~schedule時に，自身が予期する，遊休であり続ける時間の見積もりを提供する。
この情報は、その~frameの中で 他の~app~taskや関係する~browserの仕事にかかった時間を見積もるために利用できる。
しかしながら，開発者はすでに、他の手段を介してこの情報に~accessできる
— 例えば、 `requestAnimationFrame()^m を介して~frameの始まりを~markして，次の~frameの時刻を見積もって，その情報を~callbackの中での “残り時間” を算出するために利用するなど。
◎
When an idle callback is scheduled the user agent provides an estimate of how long it expects to remain idle. This information can be used to estimate the time taken by other application tasks and related browser work within that frame. However, developers can already access this information via other means - e.g. mark beginning of the frame via requestAnimationFrame, estimate the time of the next frame, and use that information to compute "remaining time" within any callback.
</p>

<p>
~cache攻撃と統計的指紋収集を軽減するため、 `IdleDeadline$I ~interfaceから返される時間の分解能は、［
`HR-TIME-2$r に定義される `Performance^I ~interface
］と同じ 5 ~micro秒までの細かさに設定されるべきである。
◎
To mitigate cache and statistical fingerprinting attacks, the resolution of the time estimates returned by the IdleDeadline interface should be set to the same 5 microsecond minimum as the Performance interface defined in [HR-TIME].
</p>
	</section>

</main></div><!-- id="MAIN"／MAIN0 -->

	<section id="acknowledgements" class="appendix">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様に協力された次の方々に：
<span lang="en">
The editors would like to thank the following people for contributing to this specification:
</span></p>

<p>
Sami Kyostila, Alex Clarke, Boris Zbarsky, Marcos Caceres, Jonas Sicking, Robert O'Callahan, David Baron, Todd Reifsteck, Tobin Titus, Ilya Grigorik, Elliott Sprehn, Tetsuharu OHZEKI, Lon Ingram, Domenic Denicola and Philippe Le Hegaret.
</p>
	</section>

	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative-references">
<h3 title="Normative References">文献（規範）</h3>

<dl>
	<dt>[HR-TIME]</dt>
	<dd>Jatinder Mann. W3C. High Resolution Time. 17 December 2012. W3C Recommendation.</dd>
	<dd>http://www.w3.org/TR/hr-time/</dd>

	<dt>[HR-TIME-2]</dt>
	<dd>Ilya Grigorik; James Simonsen; Jatinder Mann. W3C. High Resolution Time Level 2. 25 February 2016. W3C Working Draft.</dd>
	<dd>http://www.w3.org/TR/hr-time-2/</dd>

	<dt>[HTML5]</dt>
	<dd>Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Edward O'Connor; Silvia Pfeiffer. W3C. HTML5. 28 October 2014. W3C Recommendation.</dd>
	<dd>http://www.w3.org/TR/html5/</dd>

	<dt>[RFC2119]</dt>
	<dd>S. Bradner. IETF. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc2119</dd>

	<dt>[WEBIDL]</dt>
	<dd>Cameron McCormack; Boris Zbarsky. W3C. WebIDL Level 1. 8 March 2016. W3C Candidate Recommendation.</dd>
	<dd>http://www.w3.org/TR/WebIDL-1/</dd>
</dl>

		</section>
		<section id="informative-references">
<h3 title="Informative References">文献（参考）</h3>

<dl class="bibliography" resource="">

	<dt>[ANIMATION-TIMING]</dt>
	<dd>James Robinson; Cameron McCormack. W3C. Timing control for script-based animations. 22 September 2015. W3C Note.</dd>
	<dd>http://www.w3.org/TR/animation-timing/</dd>

	<dt>[PAGE-VISIBILITY]</dt>
	<dd>Jatinder Mann; Arvind Jain. W3C. Page Visibility (Second Edition). 29 October 2013. W3C Recommendation.</dd>
	<dd>http://www.w3.org/TR/page-visibility/</dd>

	<dt>[RESPONSETIME]</dt>
	<dd>Robert B. Miller. Response time in man-computer conversational transactions. December 1968. Fall Joint Computer Conference.</dd>
	<dd>http://yusufarslan.net/sites/yusufarslan.net/files/upload/content/Miller1968.pdf</dd>
</dl>


		</section>
	</section>
