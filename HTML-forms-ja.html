<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Form control（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/forms.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160924 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		E: 'error',
		h: 'header',
		st: 'attr-state',
		Im: 'attr-state',
		v: 'value',
		iM: 'value',
		M: 'method',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code', // IDL
		m: 'code', // IDL
		E: 'code', // err
		c: 'code', 
		e: 'code', // elem
		a: 'code', // attr
		M: 'code',
		h: 'code',
		et: 'code',
		st: 'span', // for IM
		stT: 'code', // input type=
		Im: 'span', // for modality
		v: 'code', // attr value
		iM: 'code', // for modality
		mt: 'code', // mime type
		V: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var context = '';
	

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[\w\-~一-鿆]+|[`!](.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'stT' :
	text = '&lt;input type=' + key + '&gt;';
	break;
case 'xCode':
	return '<pre class="html-code" id="_ex-' + key + '">＊</pre>'
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(match[0] === '!') {
	if(indicator === '^'){
		context = key;
	} else {
		klass = klass + '!' + context;
	}
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>



<script type="text/plain" id="_original_id_map">
</script>


<!--%リンク置換データ -->
<script type="text/plain" id="_link_map">
	●IDL
E.IndexSizeError:~WEBIDL#indexsizeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
	DOMException:~WEBIDL#dfn-DOMException
I.Document:~HTMLdom#document
文書:#_document
I.SelectionMode:#selectionmode
I.ValidityState:#validitystate
I.HTMLTextAreaElement:~HEforms#htmltextareaelement

m.action:#dom-fs-action
m.autofocus:#dom-fe-autofocus
m.badInput:#dom-validitystate-badinput
m.checkValidity:#dom-cva-checkvalidity
m.customError:#dom-validitystate-customerror
m.disabled:#dom-fe-disabled
m.elements:~HEforms#dom-form-elements
m.encoding:#dom-fs-encoding
m.enctype:#dom-fs-enctype
m.form:#dom-fae-form
m.formAction:#dom-fs-formaction
m.formEnctype:#dom-fs-formenctype
m.formMethod:#dom-fs-formmethod
m.formNoValidate:#dom-fs-formnovalidate
m.formTarget:#dom-fs-formtarget
m.method:#dom-fs-method
m.name:#dom-fe-name
m.noValidate:#dom-fs-novalidate
m.patternMismatch:#dom-validitystate-patternmismatch
m.rangeOverflow:#dom-validitystate-rangeoverflow
m.rangeUnderflow:#dom-validitystate-rangeunderflow
m.reportValidity:#dom-cva-reportvalidity
m.select:#dom-textarea/input-select
m.selectionDirection:#dom-textarea/input-selectiondirection
m.selectionEnd:#dom-textarea/input-selectionend
m.selectionStart:#dom-textarea/input-selectionstart
m.setCustomValidity:#dom-cva-setcustomvalidity
m.setRangeText:#dom-textarea/input-setrangetext
m.setSelectionRange:#dom-textarea/input-setselectionrange
m.show:~HEinteractive#dom-dialog-show
m.showModal:~HEinteractive#dom-dialog-showmodal
m.stepMismatch:#dom-validitystate-stepmismatch
m.submit:~HEforms#dom-form-submit
m.target:#dom-fs-target
m.tooLong:#dom-validitystate-toolong
m.tooShort:#dom-validitystate-tooshort
m.typeMismatch:#dom-validitystate-typemismatch
m.valid:#dom-validitystate-valid
m.validationMessage:#dom-cva-validationmessage
m.validity:#dom-cva-validity
m.valueMissing:#dom-validitystate-valuemissing
m.willValidate:#dom-cva-willvalidate

m.cancelable:~DOM4#dom-event-cancelable
m.bubbles:~DOM4#dom-event-bubbles

m.innerHTML:https://w3c.github.io/DOM-Parsing/#widl-Element-innerHTML


l.end:#dom-selectionmode-end
l.preserve:#dom-selectionmode-preserve
l.select:#dom-selectionmode-select
l.start:#dom-selectionmode-start


	●要素／属性／値／状態
e.base:~HEmetadata#the-base-element
e.button:~HEforms#the-button-element
e.datalist:~HEforms#the-datalist-element
e.dialog:~HEinteractive#the-dialog-element
e.fieldset:~HEforms#the-fieldset-element
e.form:~HEforms#the-form-element
e.input:~HEinput#the-input-element
e.legend:~HEforms#the-legend-element
e.object:~HTMLemb#the-object-element
e.option:~HEforms#the-option-element
e.select:~HEforms#the-select-element
e.textarea:~HEforms#the-textarea-element

et.click:~UIEVENTS#event-type-click
et.input:~HTMLindex#event-input
et.invalid:~HTMLindex#event-invalid
et.reset:~HTMLindex#event-reset
et.select:~HTMLindex#event-select
et.submit:~HTMLindex#event-submit

a.accept-charset:~HEforms#attr-form-accept-charset
a.action:#attr-fs-action
a.autofocus:#attr-fe-autofocus
a.dirname:#attr-fe-dirname
a.disabled:#attr-fe-disabled
a.~disabled0:~HEforms#attr-fieldset-disabled
a.enctype:#attr-fs-enctype
a.form:#attr-fae-form
a.formaction:#attr-fs-formaction
a.formenctype:#attr-fs-formenctype
a.formmethod:#attr-fs-formmethod
a.formnovalidate:#attr-fs-formnovalidate
a.formtarget:#attr-fs-formtarget
a.inputmode:#attr-fe-inputmode
a.hidden:~HTMLinteraction#the-hidden-attribute
a.max:~HEinput#attr-input-max
a.maxlength:#attr-fe-maxlength
a.~maxlengthI:~HEinput#attr-input-maxlength
a.~maxlengthT:~HEforms#attr-textarea-maxlength
a.method:#attr-fs-method
a.min:~HEinput#attr-input-min
a.minlength:#attr-fe-minlength
a.~nameF:~HEforms#attr-form-name
a.~minlengthI:~HEinput#attr-input-minlength
a.~minlengthT:~HEforms#attr-textarea-minlength
a.~multipleI:~HEinput#attr-input-multiple
a.multiple:~HEforms#attr-select-multiple
a.name:#attr-fe-name
a.novalidate:#attr-fs-novalidate
a.open:#attr-dialog-open
a.pattern:~HEinput#attr-input-pattern
a.~requiredI:~HEinput#attr-input-required
a.~requiredT:~HEforms#attr-textarea-required
a.step:~HEinput#attr-input-step
a.target:#attr-fs-target
a.~target0:~HEmetadata#attr-base-target
a.type:~HEinput#attr-input-type
a.value:~HEinput#attr-input-value


iM.email:#attr-fe-inputmode-keyword-email
iM.full-width-latin:#attr-fe-inputmode-keyword-full-width-latin
iM.kana-name:#attr-fe-inputmode-keyword-kana-name
iM.kana:#attr-fe-inputmode-keyword-kana
iM.katakana:#attr-fe-inputmode-keyword-katakana
iM.latin-name:#attr-fe-inputmode-keyword-latin-name
iM.latin-prose:#attr-fe-inputmode-keyword-latin-prose
iM.latin:#attr-fe-inputmode-keyword-latin
iM.numeric:#attr-fe-inputmode-keyword-numeric
iM.tel:#attr-fe-inputmode-keyword-tel
iM.url:#attr-fe-inputmode-keyword-url
iM.verbatim:#attr-fe-inputmode-keyword-verbatim

v.dialog:#attr-fs-method-dialog-keyword
v.get:#attr-fs-method-get-keyword
v.post:#attr-fs-method-post-keyword
v._charset_:#attr-fe-name-charset

sT.~textPlain:#attr-fs-enctype-text
sT.~fuEncoded:#attr-fs-enctype-urlencoded
sT.~mpFormData:#attr-fs-enctype-formdata

mt.~fuEncoded:~URLSpec#concept-urlencoded
mt.~mpFormData:~HTMLindex#multipart/form-data
mt.~textPlain:~IETF/rfc2046#section-4.1.3
mt.application/octet-stream:~IETF/rfc2046#section-4.5.1


Im.Email:#attr-fe-inputmode-state-email
Im.Full-width-latin:#attr-fe-inputmode-state-full-width-latin
Im.Kana-name:#attr-fe-inputmode-state-kana-name
Im.Kana:#attr-fe-inputmode-state-kana
Im.Katakana:#attr-fe-inputmode-state-katakana
Im.Latin-name:#attr-fe-inputmode-state-latin-name
Im.Latin-prose:#attr-fe-inputmode-state-latin-prose
Im.Latin:#attr-fe-inputmode-state-latin
Im.Verbatim:#attr-fe-inputmode-state-verbatim
Im.Numeric:#attr-fe-inputmode-state-numeric
Im.Tel:#attr-fe-inputmode-state-telephone
Im.Url:#attr-fe-inputmode-state-url

st.Default:#attr-fe-inputmode-state-default

stT.number:~HEinput#number-state-(type=number)
stT.email:~HEinput#e-mail-state-(type=email)
stT.tel:~HEinput#telephone-state-(type=tel)
stT.url:~HEinput#url-state-(type=url)
stT.color:~HEinput#color-state-(type=color)

st.Checkbox:~HEinput#checkbox-state-(type=checkbox)
st.Date:~HEinput#date-state-(type=date)
st.Email:~HEinput#e-mail-state-(type=email)
st.File:~HEinput#file-upload-state-(type=file)
st.Hidden:~HEinput#hidden-state-(type=hidden)
st.Image:~HEinput#image-button-state-(type=image)
st.Datetime-local:~HEinput#local-date-and-time-state-(type=datetime-local)
st.Month:~HEinput#month-state-(type=month)
st.Number:~HEinput#number-state-(type=number)
st.Password:~HEinput#password-state-(type=password)
st.Radio:~HEinput#radio-button-state-(type=radio)
st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Submit:~HEinput#submit-button-state-(type=submit)
st.Tel:~HEinput#telephone-state-(type=tel)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Time:~HEinput#time-state-(type=time)
st.Url:~HEinput#url-state-(type=url)
st.Week:~HEinput#week-state-(type=week)


st.GET:#attr-fs-method-get
st.POST:#attr-fs-method-post
st.dialog:#attr-fs-method-dialog

	●
~offset:#_insertion-offset
~legend:~HEforms#_fieldset-legend
~dirty値~flag:#_concept-text-dirty
	~HEforms#concept-textarea-dirty
	~HEinput#concept-input-value-dirty-flag
適用される:~HEinput#concept-input-apply
適用されない:~HEinput#do-not-apply
選択された座標:~HEinput#concept-input-type-image-coordinate
選択された~file~list:~HEinput#concept-input-type-file-selected
~radio~button群:~HEinput#radio-button-group

~formに所有され得る要素:~HEforms#form-associated-element
~listされ:~HEforms#category-listed
再設定-可能:~HEforms#category-reset
提出-可能:~HEforms#category-submit

opt.選択有無:~HEforms#concept-option-selectedness
提出-~button:~HEforms#concept-submit-button
選択肢~list:~HEforms#concept-select-option-list
改行を正規化-:~HEforms#textarea-line-break-normalisation-transformation
行折返し:~HEforms#textarea-wrapping-transformation
opt.値:~HEforms#concept-option-value
opt.不能化され:~HEforms#concept-option-disabled
tA.生の値:~HEforms#concept-textarea-raw-value

~dialogを閉じる:~HEinteractive#close-the-dialog


	●form
所有させる:#concept-form-association
~form所有者:#form-owner
所有され:#form-owner
所有-:#form-owner

値:#concept-fe-value
値たち:#concept-fe-values
~API値:#concept-fe-api-value
~checkedness:#concept-fe-checked
変異可能:#concept-fe-mutable
不能化され:#concept-fe-disabled
~form~control~maxlength属性:#attr-fe-maxlength
~form~control~minlength属性:#attr-fe-minlength

既定の~button:#default-button
~button:#concept-button

再設定~algo:#concept-form-reset-control
~formを再設定-:#concept-form-reset
~form所有者を再設定-:#reset-the-form-owner
選択~範囲を設定-:#set-the-selection-range

必要とされるのは稀:#avoid-inputmode
稀に必要とされ:#avoid-inputmode
自動focus根:#nearest-ancestor-autofocus-scoping-root-element
最も近い先祖の自動focus視野根~要素:#nearest-ancestor-autofocus-scoping-root-element

	●提出 fs
提出-:#concept-form-submit
~form提出:#form-submission-2
動作:#concept-fs-action
~enctype:#concept-fs-enctype
~method:#concept-fs-method
~target:#concept-fs-target
検証なし状態:#concept-fs-novalidate

~Get動作~URL:#submit-get-action
本体として~Mailする:#submit-mailto-body
~header列を伴う~Mail:#submit-mailto-headers
変異-動作~URL:#submit-mutate-action
~entity本体として提出する:#submit-body
~dialogを提出する:#submit-dialog

~navigateを計画する:#plan-to-navigate
計画された~navi:#planned-navigation
~form~data集合を構築-:#constructing-the-form-data-set

~form提出用の属性:#attributes-for-form-submission
form.符号化方式:#picking-an-encoding-for-the-form

~mpFormData境界~文字列:#multipart/form-data-boundary-string
~mpFormDataとして符号化-:#multipart/form-data-encoding-algorithm
~textPlainとして符号化-:#text/plain-encoding-algorithm


	●妥当性
拘束を対話的に検証-:#interactively-validate-the-constraints
拘束を静的に検証-:#statically-validate-the-constraints
拘束検証の対象外:#barred-from-constraint-validation
拘束検証の候補:#candidate-for-constraint-validation

~custom妥当性~error~message:#custom-validity-error-message
自身の拘束を満たす:#concept-fv-valid
妥当性~状態:#validity-states

~pattern不一致の難あり:#suffering-from-a-pattern-mismatch
~step不一致の難あり:#suffering-from-a-step-mismatch
型~不一致の難あり:#suffering-from-a-type-mismatch
~overflowの難あり:#suffering-from-an-overflow
~underflowの難あり:#suffering-from-an-underflow
不良~入力の難あり:#suffering-from-bad-input
欠落の難あり:#suffering-from-being-missing
長過ぎる難あり:#suffering-from-being-too-long
短か過ぎる難あり:#suffering-from-being-too-short
~custom~errorの難あり:#suffering-from-a-custom-error

値に許容される最大~長さ:#maximum-allowed-value-length
値に許容される最小~長さ:#minimum-allowed-value-length


	●INFRA
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化:~INFRA#ascii-lowercase

妥当な日付t文字列:~HTMLINFRA#valid-date-string
妥当な年月t文字列:~HTMLINFRA#valid-month-string
接続され:~HTMLINFRA#becomes-connected
	文書~内に挿入された:#insert-an-element-into-a-document
	文書から除去された:#remove-an-element-from-a-document
中へ挿入され:~HTMLINFRA#insert-an-element-into-a-document
から除去され:~HTMLINFRA#remove-an-element-from-a-document
~ASCII数字:~HTMLINFRA#ascii-digits
h.Content-Type:~HTMLINFRA#content-type
~live:~HTMLINFRA#live
~plugin:~HTMLINFRA#plugin
値なしに対する既定の状態:~HTMLINFRA#missing-value-default
列挙ed属性:~HTMLINFRA#enumerated-attribute
前後~空白~可の妥当かつ空でない~URL:~HTMLINFRA#valid-non-empty-url-potentially-surrounded-by-spaces
反映-:~HTMLINFRA#reflect
妥当でない値に対する既定の状態:~HTMLINFRA#invalid-value-default
妥当な~URL:~HTMLINFRA#valid-url
妥当な整数:~HTMLINFRA#valid-integer
妥当な浮動小数点数:~HTMLINFRA#valid-floating-point-number
妥当な非~負~整数:~HTMLINFRA#valid-non-negative-integer
文字大小区別:~HTMLINFRA#case-sensitive
既知の値のみに制限され:~HTMLINFRA#limited-to-only-known-values
相対的に構文解析-:~HTMLINFRA#parse-a-url
真偽~属性:~HTMLINFRA#boolean-attribute
空白並びで分割-:~HTMLINFRA#split-a-string-on-spaces
空白区切りの~token集合:~HTMLINFRA#set-of-space-separated-tokens
符号単位~長さ:~HTMLINFRA#code-unit-length
結果の~URL~record:~HTMLINFRA#resulting-url-record
非~負~整数として構文解析-:~HTMLINFRA#rules-for-parsing-non-negative-integers


	●WAPI
~DOM操作~task源:~WAPI#dom-manipulation-task-source
~taskを待入する:~WAPI#queue-a-task
待入され:~WAPI#queue-a-task

~errorを報告する:~WAPI#report-the-error
走っている~script:~WAPI#running-script
~task待行列:~WAPI#task-queue
~task源:~WAPI#task-source
~task:~WAPI#concept-task
利用者~対話~task源:~WAPI#user-interaction-task-source
~click~eventを発火-:~WAPI#fire-a-click-event

	●DOM4
~ID:~DOM4#concept-id
doc.~URL:~DOM4#concept-document-url
接続されて:~DOM4#connected
文書の符号化方式:~DOM4#concept-document-encoding
広義~先祖:~DOM4#concept-tree-inclusive-ancestor
~node文書:~DOM4#concept-node-document
木~順序:~DOM4#concept-tree-order
木:~DOM4#concept-tree
発火-:~DOM4#concept-event-fire
作動化の挙動:~DOM4#eventtarget-activation-behavior

	●URL
~URL:~URLSpec#concept-url
~UTF-8~percent符号化-:~URLSpec#utf-8-percent-encode
~fuEncoded直列化器:~URLSpec#concept-urlencoded-serializer
既定の符号化-集合:~URLSpec#default-encode-set
url.~query:~URLSpec#concept-url-query
url.~scheme:~URLSpec#concept-url-scheme

	●ENC
~UTF-8:~ENCODING#utf-8
符号化-:~ENCODING#encode
符号化方式:~ENCODING#encoding
~UTF-8符号化-:~ENCODING#utf-8-encode
符号化方式を取得-:~ENCODING#concept-encoding-get
出力~符号化方式を取得-:~ENCODING#get-an-output-encoding
enc.名前:~ENCODING#name

	●borowser

作動中の文書:~BROWSERS#active-document
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
入子の閲覧文脈:~BROWSERS#nested-browsing-context
生成元:~BROWSERS#concept-origin
親~閲覧文脈:~BROWSERS#parent-browsing-context
同一生成元:~BROWSERS#same-origin

妥当な閲覧文脈~名または~keyword:~BROWSERS#valid-browsing-context-name-or-keyword
名前から閲覧文脈を選ぶ規則:~BROWSERS#the-rules-for-choosing-a-browsing-context-given-a-browsing-context-name
作動中の~sandbox用~flag集合:~BROWSERS#active-sandboxing-flag-set
閲覧文脈~sandbox化( 自動~特色機能 )~flag:~BROWSERS#sandboxed-automatic-features-browsing-context-flag
閲覧文脈~sandbox化( ~form )~flag:~BROWSERS#sandboxed-forms-browsing-context-flag

~navigate:~NAVI#navigate
置換え可能化~flag:~NAVI#replacement-enabled
履歴を走査する:~NAVI#traverse-the-history
値たちは再設定され:~NAVI#history-autocomplete


	●fetch
要請:~FETCH#concept-request
rq.本体:~FETCH#concept-request-body
rq.~header~list:~FETCH#concept-request-header-list
rq.~method:~FETCH#concept-request-method
rq.~url:~FETCH#concept-request-url

	●syntax
~HTML構文解析器:~HTML5/syntax.html#html-parser
完全に読込まれ:~HTML5/syntax.html#completely-loaded
構文解析-~error:~HTML5/syntax.html#parse-error
構文解析を停止-:~HTML5/syntax.html#stop-parsing

	●dom
左横書き:~HTMLdom#concept-ltr
右横書き:~HTMLdom#concept-rtl
方向性:~HTMLdom#the-directionality


	●interaction
~focusされて:~HTMLinteraction#focused
~focusする手続き:~HTMLinteraction#focusing-steps

	●
具現化されて:~HTMLrendering#being-rendered

~Unicode~scalar値~列に変換-:~WEBIDL#dfn-obtain-unicode

</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
NAVI:https://html.spec.whatwg.org/multipage/browsers.html

此れ:<b>これ°</b>

disabled0:disabled
maxlengthI:maxlength
maxlengthT:maxlength
minlengthI:minlength
minlengthT:minlength
multipleI:multiple
requiredI:required
requiredT:required
target0:target
nameF:name
fuEncoded:<code>application/x-www-form-urlencoded</code> 
mpFormData:<code>multipart/form-data</code> 
textPlain:<code>text/plain</code> 

awesomeAt:awesome@example.com
rtlWord1:%D9%85%D8%B1%D8%AD%D8%A8%D8%A7
</script>

<!--%語彙 -->
<script type="text/plain" id="words_table">
	●network／url／保安
domain::::ドメイン
header::::ヘッダ
method::::メソッド
payload::::ペイロード
scheme::::スキーム
password::::パスワード
username::::ユーザ名
query::::クエリ
HTTP:
URL:
client::::クライアント
navigate::::ナビゲート
navi:navigation:::ナビ
server::::サーバ
percent::::パーセント
sandbox::::サンドボックス
security::::セキュリティ
url:
record::::レコード
POST:
GET:
entity:
Get:
Mail:
multipart:
計画-:plan::~

要請:request::~::リクエスト
本体:body::~::ボディ
提出元:submitter::~
	multipart:
提出用の:submission::~
提出:submission::~
提出-:submit::~
	-:submitted from

読込まれ:load され::読み込まれ::ロードされ
読込む:load する::読み込む::ロードする
読込んで:load して::読み込んで::ロードして
読込-:load::読み込み::ロード
送信-:send:~
資源:resource::~:リソース
行先:destination::~
敵対的:hostile:~
生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン

	●仕様
Web:
UA:user agent:UA
algo:algorithm:::アルゴリズム
app:application:::アプリ
API:
browser::::ブラウザ
model::::モデル
platform::::プラットフォーム
support::::サポート
	それらの:those
下位手続き:substeps:~
事例:case:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
任意選択で:optional に:~
任意選択:optional:~
作者:author:~
依存-:depend:~
共通の:common な:~
共通的:common に:よく
利用者:user:~
効果:effect:~
単純:simple:~
含意-:imply:~
	わけではない:imply
奨励-:encourage:~
定義-:define:~
定義:definition:~
実装-:implement:~
実際:actual:~
意図-:intend:~
	意図せず:unintentional
所与の:given:与えられた
手続き:steps:~
段:step:~
指定-:specify:~
指示-:indicate:~
挙動:behavior:ふるまい
提供-:provide:~
援助:aids:~
援助-:aid:~
旧来の:legacy:~
	旧式:older
	旧:old
明示的:explicit:~
期待-:expect:~
条件:condition:~
正確:exact:~
歴史的:historical:~
決定-:determine:~
特定0の:particular:ある特定の
特色機能:feature:~
理由:reason:~
目的0:purpose:目的
矢印:arrow:~
	directional arrow
結付け:association:結び付け
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける

要件:requirement:~
要求-:require:~
述べた:describe した:~
述べる:describe する:~
述べら:describe さ:~
記述-:describe:~
記述:description:~
許容-:allow:~
通例的:usual:~
適切:appropriate:~
適用-:apply:~
関係性:relationship:~
関係-:relate:~
制御-:control:~
基盤:infrastructure:~
多義的:ambiguous:~
	実質的:effective:~
影響-:affect:~
意味-:mean:~
意味:meaning:~
意図的:intentional:~
改善-:improve:~
暗黙的:implicit:~
有用:useful:~
概して:typical に:~
概念:concept:~
標準:standard:~
特有の:specific な:~
特定の:specific な:~
	を通して:in terms of
相似的:analogous:~
相応しく:suitable に:~
規範的:normative:~
解釈-:interpret:~
	再~解釈される問題 problematic reinterpretation
認識-:recognize:~
適合:conforming:~
不適合:non-conforming:~
取扱う:handle する:取り扱う
要件:requirements:~
見做され:assume され:~
精確:precise:~
受容-:accept:~
方式:manner:~
	具体例として:for instance,
規約:conventions:~
上書き:override:~
試みる:attempt する:~
設計-:design:~
強く:strong に:~

推移的:transitive:~
特別:special:~
詳細:details:~
通常の:normal な:~
避ける:avoid する:~
便利:helpful:~
事実:fact:~
状況:situation:~
稀:rare:~
専用の:dedicated:~
可能0:possible:可能
	対処:work around
	取りやめた:drop
	欠いて:lack of
	ではなく:as opposed to
	足りる:suffice
	~~判断:think
	依然として:still:~
	基づく:based
	代わりに:instead
	おそらく:probably#1
	しかしながら，:however
	したがって:thus
	べき:should
	ほとんどの:most
	他の:other:~
	他の場合:otherwise:~
	伝える:inform:~
	利用-:use:~
	可視でない:invisible:~
	呼ばれ／称され:called::~
	場合によっては:possibly:~
	序論:introduction:~
	必要:need:~
	必要とされ:necessary:~
	望む:wish する:~
	様々な:various:~
	決して:never:~
	満たす:satisfy:~
	節:section:~
	望み:wishes
	帰結として:consequently
	読まれる用途:readable
	次の様:might be something like
	され次第:as soon as
	反し:go against
	他所:other parts
	ものと:ought
	申し分ない:fine
	考える:consider
	似た様な:something like
	ない限り，in the absence of
	全く:quite
	かかわらず:regardless
	まるごと:altogether
	複雑になって／複雑な:complicated
	担当する:has claimed responsibility
	以前は:previously
	最早:no longer
	他方:On the other hand
	呼応して:in response to
	魔法の:magic
	usable
	conclude
	overall
	stood
	follow
	-:causing
	-:loop
	nothing
	overall
	~~有効になる:kick in
	in the face of
	後者:latter:~
	扱う:treat:~
	見よ:see
	類似する:similar:~
	当の:main
	を以って:by means of
	任意の:arbitrary
	例:example
	別々に:separately
	別の:another
	別個の:distinct

	●構文／直列化
ASCII:
CR:
CRLF:CR+LF
LF:
UTF-8:
Unicode:
scalar::::スカラー
charset:
error::::エラー
keyword::::キーワード
open:
tag::::タグ
token::::トークン
field::::フィールド
byte-stream:byte stream:::バイトストリーム
数字:digit:~
境界:boundary:~
引用符:quote:~
改行文字:line break:~
整数:integer:~
文字:character:~
文字列:string:~
	-:substring:~
構文:syntax:~
構文解析-:parse::~::パース
構文解析器:parser::~::パーサ
正しい:correct な:~
正規化-:normalize:~
正規化:normalization:~
省略-:omit:~
区切文字:separator character:~
空:empty:~
空白:whitespace:~
空白並び:spaces:~
空白区切りの:space-separated:~
測定-:measure:~
符号単位:code unit:~
符号位置:code point:~
符号化-:encode:~
符号化方式:encoding:~
解析済:parsed::解析済み::パース済み
	16 進:hexadecimal
	3 桁ごと:thousand
	部位:part:~
	開始:start:~
	16 進:hexadecimal
	基数 10:base-ten
直列化器:serializer::~::シリアライザ
近似-:approximate:~
分割-:split:~

出力:output:~
取得-:get:~

	●状態／妥当性
checkedness::::チェック有無
overflow::::オーバーフロー
underflow::::アンダーフロー
pattern::::パタン
step:
enctype:
custom::::カスタム
	難あり:suffer from／suffering from
	対象外:barred from
不一致:mismatch::~
不良:bad:~
真偽:boolean::~
妥当性:validity:~
妥当:valid:~
	妥当でない:invalid:~
未取扱:unhandled:未取り扱いの
	~unhandled-invalid:#5
非妥当:invalid:~
不能化-:disable::~
値:value:~
選択有無:selectedness:~
候補:candidate:~
再設定-:reset::~::リセット
再設定:reset::~::リセット
制限-:limit:~
	上限／下限:limit:~
可能化-:enable:~
可能化:enabled:~
型:type:~
変換-:convert:~
変化-:change:~
	そのまま変化しない:remain unchanged
変更-:change:~
変更:changes:~
必須の:required::~
必須:required::~
拘束検証:constraint validation:~
拘束:constraints:~
拘束-:constrain:~
静的:static::~
既定の:default::~::デフォルト
既定:default::~::デフォルト
更新-:update:~
最大:maximum:~
最小:minimum:~
検証-:validate::~
検証:validation::~
検証なし:no-validate::~
状態:state::~
検査-:check::~::チェック
dirty::::
flag::::フラグ
違反:violation:~
問題:problem:~
行折返し:line wrapping:行の折返し
	~~結合:coalesce
肯定的:positive:~
否定的:negative:~
変異-:mutate::~
変異可能:mutable::~
	変異可能~性:mutability
	合う／合わない:fit


	●UI
window::::ウィンドウ
legend:
alert:
box::::ボックス
form::::フォーム
UI:
caret::::キャレット
button::::ボタン
click:
control::::コントロール
dialog::::ダイアログ
event::::イベント
欄:field::~::フィールド
field::::フィールド
file::::ファイル
focus::::フォーカス
picker:
color-well:
key::::キー
label::::ラベル
modality::::モダリティ
radio::::ラジオ
scrolling::::スクロール
選択肢:option::~::オプション
対話的:interactive:~
対話-:interact:やりとり
対話:interaction:~
作動化の:activation::~::アクティブ化の
合成:synthetic::~
報告-:report:~
報告:report:~
指名-:designate::~
改行:line-break:~
方向:direction:~
	方向:dir
方向性:directionality:~
書字:writing:~
編集:edit:~
自動充填:autofill::~
自動focus:autofocus::自動 focus:自動フォーカス
自動化:automated:~
自動:automatic:~
自動的:automatic:~
自由形の:free-form:~
進捗:progress:~
選好-:prefer:~
地域化-:localize:~
探索:search::検索

側:side:~
全角:full-width:~

動作-:act:~
動作:action:~
座標:coordinate:~
体験:experience:~
	に注目させる:brings 〜 attention

	●UI 入力
右横書き:right-to-left:~
左横書き:left-to-right:~
	ltr／rtl
入力:input:~
locale::::ロケール
	散文でない:non-prose
CJK:
	米国:US
積極的:aggressive:~
人:human:~
computer::::コンピュータ
	人から~computerへの:human-to-computer
	人から人への:human-to-human
communication::::コミュニケーション
Latin::::
用字系:script::~
	Latin用字系:Latin-script ／ latin-script
alphabetic::::アルファベットの
頭字化:capitalization:~
	capitalisation／capitalization
kana::かな
romaji::ローマ字
katakana:カタカナ
hiragana::ひらがな
kanji::漢字
mnemonic::符号
顧客:customer:~
	文頭:start of sentences
	副:secondary

instant-messaging::::インスタントメッセージング
Japanese::日本語
英数字:alphanumeric:~
数的:numeric:~
製品:product:~

keyboard-layout:keyboard layout:::キー配列
	切り替えてswitch::~
	叩く:hit する:~
	-:letter
予測:prediction:~
	Shift ＋:Shift modifier
e-mail::::メール
	~e-mail:email

address::::アドレス
credit-card::::クレジットカード
連絡先:contact:~
電話:telephone:~
番号:number:~


選択-:select:~
選択:selection:~
	選択し得る:selectable:~
始端:start:~
終端:end:~
	始端~offset 〜 終端~offset: sequence of characters starting with the character at the 始端th position (in logical order) and ending with the character at the (終端-1)th position

offset::::オフセット
cursor::::カーソル
前方:forward::~
後方:backward::~
none:::未定
範囲:range:~
	範囲:size
	途中:in the middle
	留める:snap

埋めら:fill さ:~
埋める:fill する:~
	予め〜埋められ:prefill
打込んで:type して::~::タイプして
打込み:typing::~::タイピング
手入力-:enter:~
手入力:entry:~
手動:manual:~
手早く:quick に:~
	直後:just before
	直前:just after

	3 桁ごと:thousand:~
	Shift ＋:Shift modifier
	低い:low
	高い:high
	16 進:hexadecimal

	●呈示
graphical-cue:graphical cue:::グラフィック的な指示記号

呈示:presentation:~
呈示-:present:~
具現化-:render:~
可視:visible:~

	●内容
MIME:
HTML:
plugin::::プラグイン
	入子に:nest:入れ子に
入子の:nested:入れ子の
内容:content:~
内縁:inner:~
単語:word:~
外縁:outer:~
子:child:~
先祖:ancestor:~
子孫:descendants:~
属性:attribute:~
形式:format:~
木:tree::~::ツリー
所有者:owner:~
所有-:own:~
文書:document:~
文脈:context:~
根:root::~::ルート
視野根:scoping root::~::視野ルート
要素:element:~
親:parent:~
連鎖:chain:~
data::::データ
group::::グループ
群:group::~::グループ
text::::テキスト
	~textによる:textual
列挙ed:enumerated:列挙


	●DOM／IDL／event／task
被呼出時:被 invoke 時:~
取得子:getter:~
設定子:setter:~
引数:argument:~
投出:throw:~
反映-:reflect:~
発火-:fire::~
DOM:
ID:
IDL:
JS:JavaScript
call:
interface::::インタフェース
member::::メンバ
live:
trusted:
method::::メソッド
node::::ノード
obj:object:::オブジェクト
task::::タスク
源:source::~::ソース
target::::ターゲット
待行列:queue::待ち行列::キュー
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ
待入させ:queue させ::待ち行列に入れさせ::キューさせ
取得子:getter:~
取消され:cancel され:取り消され
取消して:cancel して:取り消して
取消す:cancel する:取り消す
作動中の:active な::~::アクティブな
接続-:connect::~




	●未分類（動詞
付加-:append:~
作成-:create:~
公開-:expose:~
包含-:contain:~
合致-:match:~
挿入-:insert:~
構築-:construct:~
相違-:differ:~
置換-:replace:~
置換え:replacement:~
表現-:represent:~
設定-:set:~
迂回-:bypass:~
追加-:add:~
遂行-:perform:~
防止-:prevent:~
	させない
除去-:remove:~
依拠-:rely:~
依拠可能:reliable:~
保全-:preserve:~
保存-:save:~
処理-:process:~
列挙:enumeration:~
初期化-:initialize:~
判別-:distinguish:~
到達-:reach:~
削除-:delete:~
呼出され:invoke され:呼び出され
呼出す:invoke する:呼び出す
命名:naming:~
埋込む:embed する:~
失敗-:fail:~
失敗:failure:~
存在-:exist:~
実行-:execute:~
宣言-:declare:~
挿入:insertion:~
操作-:manipulate:~
操作:manipulation:~
改変-:modify:~
演算-:operate:~
生成-:generate:~
破棄-:discard:~
移動-:move:~
翻訳-:translate:~
調整-:adjust:~
通知-:notify:~
配置-:place:~
走って:run して:~
走らす:run する:~
走らせ:run し:~
阻む:block する:~
閉じる:close する:~
対応付けら:map さ:~
	失った:lost
維持-:maintain:~
	有さない:missing
	表せ:expressible

	●未分類
	-:paragraph:~
code::::コード
fallback::::フォールバック
list::::リスト
literal::::リテラル
maxlength:
message::::メッセージ
minlength:
mode::::モード
script:スクリプト
	対象:subject
tool::::ツール
top-level::::トップレベル
位置:position:~
全部的:full:~
内側:inside:~
内部:internal:~
初期:initial:~
動的:dynamic:~
名:name:~
名前:name:~
在する:present:在る
変数:variable:~
不完全:incomplete:~
完全:complete:~
網羅性:completeness:~
差分:delta:~
成分:component:~
新たな:new:~
既知の:known:~
構造:structure:~
無視-:ignore:~
現在の:current:~
相対的:relative:~
自前の:own:~
色:color:~
規則:rule:~
言語:language:~
論理:logical:~
長さ:length:~
閲覧文脈:browsing context:~
集合:set:~
頁:page:::ページ
順序:order:~
素の:plain:~
	頭部に:leading
	一時的:temporary
	-:long
	~~結合:coalesce
	組:tuple:~
	( 名前, 値, 型 ):name-value-type
	非 file:non-file
	下限:lower bound
	後に:subsequently
	cover
	final
	occurrence
	now:
	+:pair
	-:long
	-:mark
	1 個の:one
	code片:snippet#2
	cue:#1
	directional
	first-in-form
	focusing
	made
	occurrence
	pointing
	previous
	using

	~~最後の:final
	すべて:everything
	一部:part of
	対応する:respective
	数え:count
	空に戻す:clear
	見出され:find され:~
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	それら:they
	上:above
	下:below
	与-:give
	両者:both:~
	低い:low::~
	前:before:~
	各:each:~
	同じ:same:~
	対応-:correspond:~
	対応する:corresponding:~
	後:after:~
	following
	得-:obtain:~
	数:number:~

	含-:include:~
	含めて:including:~
	新たに:newly

	時点:instant:~
	最も近い:nearest:~
	最初の:first:~
	最後の:last:~
	減る:decrease:~
	現在:currently:~
	異なる:different:~
	省略時は／optionally::~
	示す:show:~
	種類:kind:~
	結果:result:~
	自身:itself:~
	表:table:~
	表す:express:~
	複数の:multiple:~
	負の:negative:~
	起こる:happen:~
	返す:return:~
	除-:except:~
	高い:high::~


</script>




<!--%style -->
<style type="text/css">

</style>


</head>

<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML — Forms （ Form control infrastructure 他 ）日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Forms</a>
章の Form control infrastructure その他の関連する節を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-12-17</time>
（公開：<time>2016-09-29</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">
	<hgroup>
<h1>フォーム（共通） — Forms （ Form control infrastructure 他 ）</h1>
<h2>HTML Living Standard — 最終更新 2016 年 12 月 16 日</h2>
	</hgroup>
</header>


<main id="MAIN" style="display:none;">

			<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（ ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>
<p>
この訳では、 `Document$I ~objを単に
`文書@
と略記する。
</p>

			</section>
			<section id="form-control-infrastructure">
<h3 title="Form control infrastructure">4.10.18. ~form~control基盤</h3>

				<section id="a-form-control's-value">
<h4 title="A form control's value">4.10.18.1. ~form ~controlの値</h4>

<p>
ほとんどの~form~controlは、
`値@
と
`~checkedness@
を持つ（後者は `input$e 要素のみから利用される）。
これらは、利用者が~controlと対話する方法を記述するために利用される。
◎
Most form controls have a value and a checkedness. (The latter is only used by input elements.) These are used to describe how the user interacts with the control.
</p>

<p>
~controlの`値$は、その内部~状態である。
そのようなわけで、利用者の現在の入力に合致しないこともある。
◎
A control's value is its internal state. As such, it might not match the user's current input.
</p>

<p class="example">
具体例として、利用者が 数字を期待する `Number$st 欄の中に単語
"<kbd>three</kbd>"
を手入力した場合、利用者の入力は
文字列 "three" になるが、~controlの`値$は，そのまま変化しない。
ありは、利用者が `Email$st 欄の中へ~e-mail~address
"<kbd>&nbsp;~awesomeAt</kbd>"
（頭部に空白あり）を手入力した場合、利用者の入力は文字列 `&nbsp;~awesomeAt^l になるが，~browserの~UIは それを`値$ `~awesomeAt^l （頭部に空白なし）に翻訳するであろう。
◎
For instance, if a user enters the word "three" into a numeric field that expects digits, the user's input would be the string "three" but the control's value would remain unchanged. Or, if a user enters the email address " awesome@example.com" (with leading whitespace) into an email field, the user's input would be the string " awesome@example.com" but the browser's UI for email fields might translate that into a value of "awesome@example.com" (without the leading whitespace).
</p>

<p>
各 `input$e 要素は，別々に定義される
`値たち@
も持つ。
それは、要素の `~multipleI$a 属性に対する 拘束検証の挙動を定義するためにある。
◎
To define the behavior of constraint validation in the face of the input element's multiple attribute, input elements can also have separately defined values.
</p>

<p>
`値$を伴うすべての~form~controlは、
`~API値@
を得るための~algoも備える。
それは、［
`maxlength$a ／ `minlength$a
］属性の挙動, および `textarea$e 要素に特有の他の~APIを定義するためにある。
既定では、この~algoは，単純に~controlの`値$を返す。
◎
To define the behavior of the maxlength and minlength attributes, as well as other APIs specific to the textarea element, all form control with a value also have an algorithm for obtaining an API value. By default this algorithm is to simply return the control's value.
</p>

<p>
`select$e 要素は、`値$を持たない
— 代わりに，その `option$e 要素の`選択有無$optが利用される。
◎
The select element does not have a value; the selectedness of its option elements is what is used instead.
</p>


				</section>
				<section id="mutability">
<h4 title="Mutability">4.10.18.2. 変異可能~性</h4>

<p>
~form~controlは
`変異可能@
として指名され得る。
◎
A form control can be designated as mutable.
</p>


<p class="note">注記：
これは，（要素がそう指名されているかどうかに依拠する，この仕様における定義と要件を以って）、利用者が~form~controlの`値$や`~checkedness$を改変できるかどうか，および ~controlは予め自動的に埋められるかどうかを決定する。
◎
This determines (by means of definitions and requirements in this specification that rely on whether an element is so designated) whether or not the user can modify the value or checkedness of a form control, or whether or not a control can be automatically prefilled.
</p>

				</section>
				<section id="association-of-controls-and-forms">
<h4 title="Association of controls and forms">4.10.18.3. ~controlと~formとの結付け</h4>


`28800^bug

<p>
`~formに所有され得る要素$には、 `form$e 要素との関係性が与えられ得る
— それは、要素の
`~form所有者@
と呼ばれる。
どの `form$e 要素にも所有されない要素の`~form所有者$は ~NULL とする。
◎
A form-associated element can have a relationship with a form element, which is called the element's form owner. If a form-associated element is not associated with a form element, its form owner is said to be null.
</p>

<p class="trans-note">【
“所有される”
— 原文では、単に “結付けられる（ associated ）” であるが、この訳では
“所有-”
という語を用いて，その関係性を表すことにする。
例えば， “~form %F が所有する要素” とは、`~formに所有され得る要素$であって［
その`~form所有者$ ~EQ %F
］であるものからなる集合を意味する。
】</p>


<p>
`~formに所有され得る要素$は、既定では，それに最も近い先祖 `form$e 要素に所有される（下に述べる）が、それらのうち`~listされ$る要素には，これを上書きする
`form@a
属性が指定されても~MAY。
◎
A form-associated element is, by default, associated with its nearest ancestor form element (as described below), but, if it is listed, may have a form attribute specified to override this.
</p>

<p class="note">注記：
この特色機能により、入子の `form$e 要素に対する~supportを欠いている下でも，作者は対処できるようになる。
◎
This feature allows authors to work around the lack of support for nested form elements.
</p>

<p>
`~listされ$る要素に指定する `form$a 属性の値は、要素の`木$内にある `form$e 要素の`~ID$で~MUST。
◎
If a listed form-associated element has a form attribute specified, then that attribute's value must be the ID of a form element in the element's tree.
</p>

<p class="note">注記：
この節における規則は、複雑になっている
— ［
文書／`木$
］が適合ならば，入子の `form$e 要素を包含することは決してないが、そのような入子の要素を有する`木$を生成することは，事実として全く可能0なので（例： ~DOM操作を遂行する~scriptを用いて）。
それまた、~HTML構文解析器における規則によっても複雑になっている
— 歴史的~理由から、`~formに所有され得る要素$が，その先祖でない `form$e 要素に所有されることもあるので。
◎
The rules in this section are complicated by the fact that although conforming documents or trees will never contain nested form elements, it is quite possible (e.g., using a script that performs DOM manipulation) to generate trees that have such nested elements. They are also complicated by rules in the HTML parser that, for historical reasons, can result in a form-associated element being associated with a form element that is not its ancestor.
</p>

<p>
`~formに所有され得る要素$の作成-時には、その`~form所有者$は，~NULLに（所有者なし）に初期化され~MUST。
◎
When a form-associated element is created, its form owner must be initialized to null (no owner).
</p>

<p class="algo-head">
所与の~form %~form に，`~formに所有され得る要素$ %要素 を
`所有させる@
ときは、［
%要素 の`~form所有者$ ~SET %~form
］に設定し~MUST。
◎
When a form-associated element is to be associated with a form, its form owner must be set to that form.
</p>


<p>
`~formに所有され得る要素$ %要素 に対し，次が生じたときは、~UAは %要素 の`~form所有者を再設定-$し~MUST：
◎
↓</p>

<ul>
	<li>
%要素 または そのいずれかの先祖が`接続され$たとき。
<span class="note">注記：
`~HTML構文解析器$は、~form~controlを挿入するときにこの要件を上書きする。
</span>
◎
When a form-associated element or one of its ancestors becomes connected, then the user agent must reset the form owner of that form-associated element. The HTML parser overrides this requirement when inserting form controls.
</li>
	<li>
ある要素の親~nodeが変更された結果，
%要素 とその`~form所有者$（ ~NEQ ~NULL とする）が同じ`木$内でなくなったとき。
◎
When an element changes its parent node resulting in a form-associated element and its form owner (if any) no longer being in the same tree, then the user agent must reset the form owner of that form-associated element.
</li>
	<li>
%要素 が`~listされ$る要素であって，その `form$a 属性が［
設定- ／ 変更- ／除去-
］されたとき。
◎
When a listed form-associated element's form attribute is set, changed, or removed, then the user agent must reset the form owner of that element.
</li>
	<li>
%要素 が`~listされ$る要素であって， `form$a 属性を有している下で，
`木$内のある要素の`~ID$が変更されたとき。
◎
When a listed form-associated element has a form attribute and the ID of any of the elements in the tree changes, then the user agent must reset the form owner of that form-associated element.
</li>
	<li>
%要素 が`~listされ$る要素であって， `form$a 属性を有している下で，
`~ID$を伴うある要素が，`文書$［
の`中へ挿入され$た ／ `から除去され$た
］とき。
◎
When a listed form-associated element has a form attribute and an element with an ID is inserted into or removed from the Document, then the user agent must reset the form owner of that form-associated element.
</li>
</ul>

<p class="algo-head">
~UAは、`~formに所有され得る要素$ %要素 の
`~form所有者を再設定-@
するときは、次の手続きを走らせ~MUST：
◎
When the user agent is to reset the form owner of a form-associated element element, it must run the following steps:
</p>

<ol>
	<li>
<p>
~IF［
次のすべてが満たされる
］
⇒
◎
If all of the following conditions are true
</p>

		<ul class="brief">
			<li>
%要素 の`~form所有者$ ~NEQ ~NULL
◎
element's form owner is not null
</li>
			<li>
［
%要素 は`~listされ$る要素でない
］~OR［
%要素 は `form$a 内容~属性を有さない
］
◎
element is not listed or its form content attribute is not present
</li>
			<li>
%要素 の`~form所有者$ ~EQ ［
%要素 の先祖の連鎖が変化した後における，
%要素 に最も近い［
%要素 の先祖である `form$e 要素
］］
◎
element's form owner is its nearest form element ancestor after the change to the ancestor chain
</li>
		</ul>
<p>
ならば
⇒
~RET
◎
then do nothing, and abort these steps.
</p>
	</li>
	<li>
%要素 の`~form所有者$ ~SET ~NULL
◎
Set element's form owner to null.
</li>
	<li>
<p>
~IF［
%要素 は`~listされ$る要素である
］~AND［
%要素 は `form$a 内容~属性を有する
］~AND［
%要素 は`接続されて$いる
］：
◎
If element is listed, has a form content attribute, and is connected, then run this substep:
</p>

		<ol>
			<li>
%id ~LET %要素 の `form$a 内容~属性の値
</li>
			<li>
~IF［
%要素 の`木$内に［
`~ID$ ~EQ %id
］なる要素はある
］
⇒
~IF［
該当する要素うち，`木~順序$で最初の要素は、 `form$e 要素である
］
⇒
その `form$e 要素に， %要素 を`所有させる$
◎
If the first element in element's tree, in tree order, to have an ID that is case-sensitively equal to element's form content attribute's value, is a form element, then associate the element with that form element.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%要素 の先祖に `form$e 要素がある
］
⇒
該当する `form$e 要素のうち %要素 に最も近いものに， %要素 を`所有させる$
◎
Otherwise, if element has an ancestor form element, then associate element with the nearest such ancestor form element.
</li>
</ol>

<div class="example">

<p>
次の不適合~code片：
◎
In the following non-conforming snippet:
</p>


<pre class="html-code bad">
...
 &lt;form id="a"&gt;
  &lt;div id="b"&gt;&lt;/div&gt;
 &lt;/form&gt;
 &lt;script&gt;
  document.getElementById('b').innerHTML =
     '&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/form&gt;&lt;form id="c"&gt;&lt;input id="d"&gt;&lt;/table&gt;' +
     '&lt;input id="e"&gt;';
 &lt;/script&gt;
...
</pre>

<p>
"d" の`~form所有者$は，内縁の入子の~form "c" になる一方で、
"e" の`~form所有者$は，外縁の~form "a" になる。
◎
The form owner of "d" would be the inner nested form "c", while the form owner of "e" would be the outer form "a".
</p>

<p>
これは次のようにして起こる：
先ず，~node "e" は、`~HTML構文解析器$において "c" に結付けられる。
次に，`innerHTML$m ~algoは、~nodeたちを一時的な文書から要素 "b" へ移動する。
各~nodeは、この時点で，各自の先祖の連鎖が変更されたことを見る。
したがって、構文解析器による “魔法の” 結付けすべては、通常の，先祖への結付けに再設定される。
◎
This happens as follows: First, the "e" node gets associated with "c" in the HTML parser. Then, the innerHTML algorithm moves the nodes from the temporary document to the "b" element. At this point, the nodes see their ancestor chain change, and thus all the "magic" associations done by the parser are reset to normal ancestor associations.
</p>

<p>
もっとも、この例は不適合な文書である
— そこには、入子の `form$e 要素による内容~modelの違反があり，また
`&lt;/form&gt;^c ~tagにも`構文解析-~error$がある。
◎
This example is a non-conforming document, though, as it is a violation of the content models to nest form elements, and there is a parse error for the &lt;/form&gt; tag.
</p>

</div>


<dl class="domintro">
	<dt>%element . `form$m</dt>
	<dd>
要素の`~form所有者$が［
あればそれ ／ なければ ~NULL
］を返す。
◎
Returns the element's form owner.
◎
Returns null if there isn't one.
</dd>
</dl>


<dl class="idl-def">
	<dt>`form@m</dt>
	<dd>
`~formに所有され得る要素$のうち，`~listされ$るものは、この~IDL属性を有する。
◎
↓</dd>
	<dd>
取得子は、［
此れの`~form所有者$ ~NEQ ~NULL ならば それ ／
~ELSE_ ~NULL 
］を返さ~MUST。
◎
Listed form-associated elements have a form IDL attribute, which, on getting, must return the element's form owner, or null if there isn't one.
</dd>

</dl>



				</section>
			</section>
			<section id="attributes-common-to-form-controls">
<h3 title="Attributes common to form controls">4.10.19. 各種~form~controlに共通の属性</h3>

				<section id="naming-form-controls:-the-name-attribute">
<h4 title="Naming form controls: the name attribute">4.10.19.1. ~form~controlの命名： `name^a 属性</h4>

<p>
`name@a
内容~属性は、~form~controlの名前を与える。
それは、`~form提出$, および
`form$e 要素の `elements$m ~objにて利用される。
この属性の値に［
空~文字列 ／ `isindex^v
］を指定しては~MUST_NOT。
◎
The name content attribute gives the name of the form control, as used in form submission and in the form element's elements object. If the attribute is specified, its value must not be the empty string or isindex.
</p>

<p class="note">注記：
いくつかの~UAは、歴史的に，［
名前 `isindex^v を伴う “first-in-form” ~text~control
］に対する特別な~supportを実装していた。
また，この仕様は、以前は，そのための関係する~UA要件を定義していた。
しかしながら，一部の~UAは、後にその特別な~supportを取りやめたため、関係する要件は この仕様から除去された。
なので、旧来の~UAから再~解釈される問題を避けるため、名前 `isindex^v は最早~許容されない。
◎
A number of user agents historically implemented special support for first-in-form text controls with the name isindex, and this specification previously defined related user agent requirements for it. However, some user agents subsequently dropped that special support, and the related requirements were removed from this specification. So, to avoid problematic reinterpretations in legacy user agents, the name isindex is no longer allowed.
</p>

<p>
`~nameF$a に対しては［
`isindex^v, 空~文字列
］以外の どの値も許容される。
◎
Other than isindex, any non-empty value for name is allowed.
</p>
<!-- ＊段落分断 -->
<p>
［
`value$a 属性を有さない `Hidden$st ~control
］の `name$a 属性に対する~keyword
`_charset_@v
は特別であり、指定された場合， `value$a 属性に代わって 自動的に，［
~controlを`所有-$している~formの`符号化方式$form
］が提出-時における~controlの値を与えるようになる。
◎
The name _charset_ is special: If used as the name of a Hidden control with no value attribute, then during submission the value attribute is automatically given a value consisting of the submission character encoding.
</p>

<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
`name$a 内容~属性を`反映-$し~MUST。
◎
The name IDL attribute must reflect the name content attribute.
</dd>

</dl>


				</section>
				<section id="submitting-element-directionality:-the-dirname-attribute">
<h4 title="Submitting element directionality: the dirname attribute">4.10.19.2. 要素~方向性の提出~法： `dirname^a 属性</h4>

<p>
~form~control要素の
`dirname@a
属性は、要素の`方向性$の提出を可能化し，`~form提出$の際に この値を包含させる名前を与える。
<!-- name of the control＊ -->
この属性の値には，空~文字列を指定しては~MUST_NOT。
◎
The dirname attribute on a form control element enables the submission of the directionality of the element, and gives the name of the control that contains this value during form submission. If such an attribute is specified, its value must not be the empty string.
</p>

<div class="example">
<p>
~text~controlと提出~buttonを包含する~formの例：
◎
In this example, a form contains a text control and a submission button:
</p>

<pre class="html-code">
&lt;form action="addcomment.cgi" method=post&gt;
 &lt;p&gt;&lt;label&gt;コメント： &lt;input type=text name="comment"<mark> dirname="comment.dir"</mark> required&gt;&lt;/label&gt;&lt;/p&gt;
 &lt;p&gt;&lt;button name="mode" type=submit value="add"&gt;コメントを投稿する&lt;/button&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>

<!-- 
<form action="addcomment.cgi" method=post>
 <p><label>Comment: <input type=text name="comment" dirname="comment.dir" required></label></p>
 <p><button name="mode" type=submit value="add">Post Comment</button></p>
</form>
-->

<p>
利用者がこの~formを提出したとき、~UAは，順に［
"comment", "comment.dir", "mode"
］と称される 3 個の欄を含める。
利用者が "Hello" と手入力していたなら、その提出~本体は，次の様になるであろう：
◎
When the user submits the form, the user agent includes three fields, one called "comment", one called "comment.dir", and one called "mode"; so if the user types "Hello", the submission body might be something like:
</p>

<pre>
comment=Hello&amp;<mark>comment.dir=ltr</mark>&amp;mode=add
</pre>


<p>
利用者が手動で書字~方向を右横書きに切り替えて，
"<span dir="rtl" lang="ar">مرحبا</span>"
と手入力していたなら、その提出~本体は，次の様になるであろう：
◎
If the user manually switches to a right-to-left writing direction and enters "مرحبا", the submission body might be something like:
</p>


<pre>
comment=~rtlWord1&amp;<mark>comment.dir=rtl</mark>&amp;mode=add
</pre>

</div>


				</section>
				<section id="limiting-user-input-length:-the-maxlength-attribute">
<h4 title="Limiting user input length: the maxlength attribute">4.10.19.3. 利用者~入力の長さ上限の設定-法： `maxlength^a 属性</h4>

<p>
`~form~control~maxlength属性@
は、`~dirty値~flag$により制御され、利用者が入力できる文字~数の上限を宣言する。
この “文字~数” は，`符号単位~長さ$で測定され、
`textarea$e 要素の事例においては，すべての改行は 1 個の文字に正規化される
（ ~CRLF ではなく）。
◎
A form control maxlength attribute, controlled by a dirty value flag, declares a limit on the number of characters a user can input. The "number of characters" is measured using code-unit length and, in the case of textarea elements, with all line breaks normalized to a single character (as opposed to CRLF pairs).
</p>

<p class="trans-note">【
`~dirty値~flag@
は、当の要素に応じて［
<a href="~HEforms#concept-textarea-dirty">`textarea^e 要素のそれ</a>,
または
<a href="~HEinput#concept-input-value-dirty-flag">`input^e 要素のそれ</a>
］を指す。
】</p>

<p>
要素の `~form~control~maxlength属性$に指定する値は
`妥当な非~負~整数$で~MUST。
要素の
`値に許容される最大~長さ@
は、［［
要素がこの属性を有する
］~AND［
その値を`非~負~整数として構文解析-$した結果 ~NEQ ~error
］ならば 結果の数 ／
~ELSE_ ε
］とする。
◎
If an element has its form control maxlength attribute specified, the attribute's value must be a valid non-negative integer. If the attribute is specified and applying the rules for parsing non-negative integers to its value results in a number, then that number is the element's maximum allowed value length. If the attribute is omitted or parsing its value results in an error, then there is no maximum allowed value length.
</p>

<div>
<p><strong>拘束検証</strong>
⇒
要素が次をすべて満たしている間は、`長過ぎる難あり$になる：
</p>

<ul ><li>その`~dirty値~flag$ ~EQ ~T
</li><li>その`値$が最後に変更されたのは，利用者の編集による（~scriptによるものではなく）
</li><li>その`~API値$の`符号単位~長さ$ ~GT その`値に許容される最大~長さ$ ~NEQ ε
</li></ul>

◎
Constraint validation: If an element has a maximum allowed value length, its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), and the code-unit length of the element's API value is greater than the element's maximum allowed value length, then the element is suffering from being too long.
</div>

<p>
~UAは、利用者が，要素の`~API値$を［
その`符号単位~長さ$ ~GT 要素の`値に許容される最大~長さ$
］なる値に設定させないようにして~MAY。
◎
User agents may prevent the user from causing the element's API value to be set to a value whose code-unit length is greater than the element's maximum allowed value length.
</p>

<p class="note">注記：
`textarea$e 要素の事例では、`~API値$と`値$は相違する。
特に、`値に許容される最大~長さ$が検査される前に，それ用に`改行を正規化-$する（一方で `行折返し$は適用されない)。
◎
In the case of textarea elements, the API value and value differ. In particular, the textarea line break normalization transformation is applied before the maximum allowed value length is checked (whereas the textarea wrapping transformation is not applied).
</p>


				</section>
				<section id="setting-minimum-input-length-requirements:-the-minlength-attribute">
<h4 title="Setting minimum input length requirements: the minlength attribute">4.10.19.4. 利用者~入力の長さ下限の設定-法： `minlength^a 属性</h4>

<p>
`~form~control~minlength属性@
は、`~dirty値~flag$により制御され、利用者が入力できる文字~数の下限を宣言する。
この “文字~数” は，`符号単位~長さ$で測定され、
`textarea$e 要素の事例においては、すべての改行は 1 個の文字に正規化される（~CRLFでなく）。
◎
A form control minlength attribute, controlled by a dirty value flag, declares a lower bound on the number of characters a user can input. The "number of characters" is measured using code-unit length and, in the case of textarea elements, with all line breaks normalized to a single character (as opposed to CRLF pairs).
</p>

<p class="note">注記：
`minlength$a 
属性は `required^a 属性を含意しない。
当の~form~controlが `required^a 属性を有さない場合、値は依然として省略し得る
— `minlength$a 属性が~~有効になるのは、利用者が何らかの値を手入力したときに限られる。
作者は、空~文字列を許容しない場合には， `required^a 属性も設定する必要がある。
◎
The minlength attribute does not imply the required attribute. If the form control has no required attribute, then the value can still be omitted; the minlength attribute only kicks in once the user has entered a value at all. If the empty string is not allowed, then the required attribute also needs to be set.
</p>

<p>
要素の`~form~control~minlength属性$に指定する値は、`妥当な非~負~整数$で~MUST。
要素の
`値に許容される最小~長さ@
は、［［
要素が この属性を有する
］~AND［
その値を`非~負~整数として構文解析-$した結果 ~NEQ ~error
］ならば 結果の数 ／
~ELSE_ ε
］とする。
◎
If an element has its form control minlength attribute specified, the attribute's value must be a valid non-negative integer. If the attribute is specified and applying the rules for parsing non-negative integers to its value results in a number, then that number is the element's minimum allowed value length. If the attribute is omitted or parsing its value results in an error, then there is no minimum allowed value length.
</p>

<p>
要素の［
`値に許容される最大~長さ$,
`値に許容される最小~長さ$
］の両者とも ε でない場合、［
`値に許容される最小~長さ$ ~LTE `値に許容される最大~長さ$
］で~MUST。
◎
If an element has both a maximum allowed value length and a minimum allowed value length, the minimum allowed value length must be smaller than or equal to the maximum allowed value length.
</p>

<div>
<p><strong>拘束検証</strong>
⇒
要素が次をすべて満たしている間は、`短か過ぎる難あり$になる
</p>

<ul ><li>その`~dirty値~flag$ ~EQ ~T
</li><li>その`値$が最後に変更されたのは，利用者の編集による（~scriptによるものではなく）
</li><li>その`値$ ~NEQ 空~文字列
</li><li>その`~API値$の`符号単位~長さ$ ~LT その`値に許容される最小~長さ$ ~NEQ ε
</li></ul>

◎
Constraint validation: If an element has a minimum allowed value length, its dirty value flag is true, its value was last changed by a user edit (as opposed to a change made by a script), its value is not the empty string, and the code-unit length of the element's API value is less than the element's minimum allowed value length, then the element is suffering from being too short.
</div>


<div class="example">

<p>
次の例には 4 個の~text~controlがある。
最初のそれは必須であり、 5 文字 以上にする必要がある。
他の 3 個は任意選択であるが、利用者が埋める場合には， 10 文字~以上を手入力する必要がある。
◎
In this example, there are four text controls. The first is required, and has to be at least 5 characters long. The other three are optional, but if the user fills one in, the user has to enter at least 10 characters.
</p>

<pre class="html-code">
&lt;form action="/events/menu.cgi" method="post"&gt;
 &lt;p&gt;&lt;label&gt;Name of Event: &lt;input required minlength=5 maxlength=50 name=event&gt;&lt;/label&gt;&lt;/p&gt;
 &lt;p&gt;&lt;label&gt;Describe what you would like for breakfast, if anything:
    &lt;textarea name="breakfast" minlength="10"&gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt;
 &lt;p&gt;&lt;label&gt;Describe what you would like for lunch, if anything:
    &lt;textarea name="lunch" minlength="10"&gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt;
 &lt;p&gt;&lt;label&gt;Describe what you would like for dinner, if anything:
    &lt;textarea name="dinner" minlength="10"&gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt;
 &lt;p&gt;&lt;input type=submit value="Submit Request"&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>


</div>

				</section>
				<section id="enabling-and-disabling-form-controls:-the-disabled-attribute">
<h4 title="Enabling and disabling form controls: the disabled attribute">4.10.19.5. ~form~controlの可能化-法と不能化-法： `disabled^a 属性</h4>

<p>
`disabled@a
内容~属性は`真偽~属性$である。
◎
The disabled content attribute is a boolean attribute.
</p>

<p>
~form~control %C は、次のいずれかを満たすならば
`不能化され@
ているとされる：
◎
A form control is disabled if any of the following conditions are met:
</p>

<ol>
	<li>
<p>
%C は次をすべて満たす
</p>
<ul ><li>［
`button$e ／ `input$e ／ `select$e ／ `textarea$e
］要素である
</li><li>`disabled$a 属性を有する（その値にかかわらず）
</li></ul>

◎
The element is a button, input, select, or textarea element, and the disabled attribute is specified on this element (regardless of its value).
</li>
	<li>
<p>
次をすべて満たす要素 %F がある
</p>

<ul ><li>%F は `fieldset$e 要素である
</li><li>%F は `~disabled0$a 属性を有する
</li><li>%C ~IN { %F の子孫 }
</li><li>［
%F の`~legend$ ~EQ ε
］~OR［
%C ~NIN { %F の`~legend$の子孫 }
］
</li></ul>


◎
The element is a descendant of a fieldset element whose disabled attribute is specified, and is not a descendant of that fieldset element's first legend element child, if any.
</li>
</ol>

<p>
~form~controlが`不能化され$ている間は、`利用者~対話~task源$から`待入され$る どの `click$et ~eventも，その要素に配送されないようにし~MUST。
◎
A form control that is disabled must prevent any click events that are queued on the user interaction task source from being dispatched on the element.
</p>

<p><strong>拘束検証</strong>
⇒
要素は、`不能化され$ている間は，`拘束検証の対象外$になる
◎
Constraint validation: If an element is disabled, it is barred from constraint validation.
</p>

<dl class="idl-def">
	<dt>`disabled@m</dt>
	<dd>
`disabled$a 内容~属性を`反映-$し~MUST。
◎
The disabled IDL attribute must reflect the disabled content attribute.
</dd>

</dl>


				</section>
				<section id="form-submission">
<h4 title="Form submission">4.10.19.6. ~form提出</h4>

<p>
`~form提出用の属性@
は、 `form$e 要素にも，`提出-~button$†にも指定できる。
（† ~formを提出する~buttonを表現する要素
— 例えば `input$e 要素であって `type$a 属性が `Submit$st 状態にあるもの。）
◎
Attributes for form submission can be specified both on form elements and on submit buttons (elements that represent buttons that submit forms, e.g. an input element whose type attribute is in the Submit Button state).
</p>

<p>
`form$e 要素には、次に挙げる`~form提出用の属性$が指定されて~MAY
⇒
`action$a, `enctype$a, `method$a, `novalidate$a, `target$a
◎
The attributes for form submission that may be specified on form elements are action, enctype, method, novalidate, and target.
</p>

<p>
`提出-~button$には、次に挙げる，対応する`~form提出用の属性$が指定されて~MAY
⇒
`formaction$a, `formenctype$a, `formmethod$a, `formnovalidate$a, `formtarget$a
— これらの属性の省略-時の既定は、 `form$e 要素に与えられた対応する属性の値になる。
◎
The corresponding attributes for form submission that may be specified on submit buttons are formaction, formenctype, formmethod, formnovalidate, and formtarget. When omitted, they default to the values given on the corresponding attributes on the form element.
</p>

<hr>

<p>
`action@a
／
`formaction@a
内容~属性に指定する値は、`前後~空白~可の妥当かつ空でない~URL$で~MUST。
◎
The action and formaction content attributes, if specified, must have a value that is a valid non-empty URL potentially surrounded by spaces.
</p>

<div >
<p class="algo-head">
要素の
`動作@
は、次に従って決定される値である：
</p>

<ol>
	<li>
［
要素は`提出-~button$である
］~AND［
要素は `formaction$a 属性を有する
］ならば その値
</li>
	<li>
~ELSE_ ［
要素の`~form所有者$ %O ~NEQ ~NULL
］~AND［
%O は `action$a 属性を有する
］ならば その値
</li>
	<li>
~ELSE_ 空~文字列
</li>
</ol>

◎
The action of an element is the value of the element's formaction attribute, if the element is a submit button and has such an attribute, or the value of its form owner's action attribute, if it has one, or else the empty string.
</div>

<hr>

<p>
`method@a
／
`formmethod@a
内容~属性は、`列挙ed属性$であり，次の~keywordと状態をとり得る：
◎
The method and formmethod content attributes are enumerated attributes with the following keywords and states:
</p>

<ul>
	<li>
~keyword
`get@v
は、
`GET@st
状態に対応付けられる
— それは、~HTTP~GET~methodを指示する。
◎
The keyword get, mapping to the state GET, indicating the HTTP GET method.
</li>
	<li>
~keyword
`post@v
は、
`POST@st
状態に対応付けられる
— それは、~HTTP~POST~methodを指示する。
◎
The keyword post, mapping to the state POST, indicating the HTTP POST method.
</li>
	<li>
~keyword
`dialog@v
は、
`dialog@st
状態に対応付けられる
— それは、 `form$e の提出-時に，その~formが見出される `dialog$e ~boxが［
あれば それを閉じる ／
なければ 提出しない
］ことが意図されることを指示する。
◎
The keyword dialog, mapping to the state dialog, indicating that submitting the form is intended to close the dialog box in which the form finds itself, if any, and otherwise not submit.
</li>
</ul>

<p>
これらの属性に対する`妥当でない値に対する既定の状態$は、
`GET$st 状態とする。
`method$a 属性に対する`値なしに対する既定の状態$も
`GET$st 状態とする。
（ `formmethod$a 属性には，`値なしに対する既定の状態$はない。）
◎
The invalid value default for these attributes is the GET state. The missing value default for the method attribute is also the GET state. (There is no missing value default for the formmethod attribute.)
</p>


<p>
要素の
`~method@
は、上に与えた いずれかの状態をとる
— それは、［
要素は`提出-~button$である
］~AND［
要素は `formmethod$a 属性を有する
］ならば その属性の状態 ／
~ELSE_ 要素の`~form所有者$の `method$a 属性の状態
］とする。
◎
The method of an element is one of those states. If the element is a submit button and has a formmethod attribute, then the element's method is that attribute's state; otherwise, it is the form owner's method attribute's state.
</p>

<div class="example">

<p>
`method$a 属性を利用して 既定の値 `get$v を明示的に指定する例
— 探索~queryは、~URL内に提出されるようになる：
◎
Here the method attribute is used to explicitly specify the default value, "get", so that the search query is submitted in the URL:
</p>

<pre class="html-code">
&lt;form method="get" action="/search.cgi"&gt;
 &lt;p&gt;&lt;label&gt;Search terms: &lt;input type=search name=q&gt;&lt;/label&gt;&lt;/p&gt;
 &lt;p&gt;&lt;input type=submit&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>

</div>

<div class="example">

<p>
他方， `method$a 属性に値 `post$v に指定した場合、利用者の~messageは，~HTTP要請の本体~内に提出される：
◎
On the other hand, here the method attribute is used to specify the value "post", so that the user's message is submitted in the HTTP request's body:
</p>

<pre class="html-code">
&lt;form method="post" action="/post-message.cgi"&gt;
 &lt;p&gt;&lt;label&gt;Message: &lt;input type=text name=m&gt;&lt;/label&gt;&lt;/p&gt;
 &lt;p&gt;&lt;input type=submit value="Submit message"&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>

</div>

<div class="example">

<p>
次の例では、 `form$e は `dialog$e に利用される。
~formが提出されたとき~dialogを自動的に閉じるため、
`method$a 属性には `dialog$v ~keywordが利用されている。
◎
In this example, a form is used with a dialog. The method attribute's "dialog" keyword is used to have the dialog automatically close when the form is submitted.
</p>

<pre class="html-code" lang="en-GB">
&lt;dialog id="ship"&gt;
 &lt;form method=dialog&gt;
  &lt;p&gt;A ship has arrived in the harbour.&lt;/p&gt;
  &lt;button type=submit value="board"&gt;Board the ship&lt;/button&gt;
  &lt;button type=submit value="call"&gt;Call to the captain&lt;/button&gt;
 &lt;/form&gt;
&lt;/dialog&gt;
&lt;script&gt;
 var ship = document.getElementById('ship');
 ship.showModal();
 ship.onclose = function (event) {
   if (ship.returnValue == 'board') {
     // ...
   } else {
     // ...
   }
 };
&lt;/script&gt;
</pre>

</div>

<hr>

<p>
`enctype@a
／
`formenctype@a
内容~属性は、`列挙ed属性$であり，次の~keywordと状態をとり得る：
◎
The enctype and formenctype content attributes are enumerated attributes with the following keywords and states:
</p>

<ul>
	<li>
"`~fuEncoded@sT"
~keywordと, 対応する状態。
◎
The "application/x-www-form-urlencoded" keyword and corresponding state.
</li>
	<li>
"`~mpFormData@sT"
~keywordと, 対応する状態。
◎
The "multipart/form-data" keyword and corresponding state.
</li>
	<li>
"`~textPlain@sT"
~keywordと, 対応する状態。
◎
The "text/plain" keyword and corresponding state.
</li>
</ul>

<p>
これらの属性に対する `妥当でない値に対する既定の状態$は、
`~fuEncoded$sT 状態とする。
`enctype$a 属性に対する`値なしに対する既定の状態$も
`~fuEncoded$sT 状態とする。
（ `formenctype$a 属性には，`値なしに対する既定の状態$はない。）
◎
The invalid value default for these attributes is the application/x-www-form-urlencoded state. The missing value default for the enctype attribute is also the application/x-www-form-urlencoded state. (There is no missing value default for the formenctype attribute.)
</p>

<p>
要素の
`~enctype@
は、これら 3 状態のいずれかをとる。
要素の`~enctype$は、［［
要素は`提出-~button$である
］~AND［
`formenctype$a 属性を有する
］ならばその属性の状態 ／
~ELSE_ 要素の`~form所有者$の`enctype$a 属性の状態
］とする。
◎
The enctype of an element is one of those three states. If the element is a submit button and has a formenctype attribute, then the element's enctype is that attribute's state; otherwise, it is the form owner's enctype attribute's state.
</p>

<hr>

<p>
`target@a
／
`formtarget@a
内容~属性に指定する値は、`妥当な閲覧文脈~名または~keyword$で~MUST。
◎
The target and formtarget content attributes, if specified, must have values that are valid browsing context names or keywords.
</p>

<div>
<p>
%要素 の
`~target@
は、次の結果で与えられる：
</p> 

<ol>
	<li>
~IF［
%要素 は`提出-~button$である
］~AND［
%要素 は `formtarget$a 属性を有する
］
⇒
~RET その属性~値
</li>
	<li>
~ELIF［
%要素 の`~form所有者$ %O ~NEQ ε
］~AND［
%O は `target$a 属性を有する
］
⇒
~RET その属性~値
</li>
	<li>
~ELIF［
%要素 の`文書$~内の `base$e 要素のうち，
`~target0$a 属性を有するものからなる`木~順序による^tnote
集合は空でない
］
⇒
~RET その集合~内の最初の要素の `~target0$a 属性の値
</li>
	<li>
~RET 空~文字列
</li>
</ol>


◎
The target of an element is the value of the element's formtarget attribute, if the element is a submit button and has such an attribute; or the value of its form owner's target attribute, if it has such an attribute; or, if the Document contains a base element with a target attribute, then the value of the target attribute of the first such base element; or, if there is no such element, the empty string.
</div>

<hr>

<p>
`novalidate@a
／
`formnovalidate@a
内容~属性は`真偽~属性$である。
在する場合、
~form／要素
は，提出の間に検証されないことを指示する。
◎
The novalidate and formnovalidate content attributes are boolean attributes. If present, they indicate that the form is not to be validated during submission.
</p>

<div>
<p>
要素の
`検証なし状態@
は、［
要素が次を満たすならば ~T ／
~ELSE_ ~F
］とする：
</p>

<ul><li>`提出-~button$である ~AND
</li><li>次のいずれかを満たす
<ul><li>`formnovalidate$a 属性を有する
</li><li>要素の`~form所有者$は `novalidate$a 属性を有する
</li></ul>
	</li>
</ul>



◎
The no-validate state of an element is true if the element is a submit button and the element's formnovalidate attribute is present, or if the element's form owner's novalidate attribute is present, and false otherwise.
</div>

<div class="example">
<p>
この属性は、検証~拘束を備える~formに “保存-” ~buttonを含ませて，［
利用者が，~form内の~dataを全部的に手入力していない場合でも、それらの進捗を保存できる
］ようにするときに有用になる。
次の単純な~form例には、 2 個の必須の欄に加えて， 3 個の~button
— ~form提出-用の~button（両~欄とも埋めることが要求される）,
保存-用の~button（利用者が後で戻って来て埋められるようにする）,
~formを まるごと取消す~button —
がある：
◎
This attribute is useful to include "save" buttons on forms that have validation constraints, to allow users to save their progress even though they haven't fully entered the data in the form. The following example shows a simple form that has two required fields. There are three buttons: one to submit the form, which requires both fields to be filled in; one to save the form so that the user can come back and fill it in later; and one to cancel the form altogether.
</p>

<pre class="html-code">
&lt;form action="editor.cgi" method="post"&gt;
 &lt;p&gt;&lt;label&gt;Name: &lt;input required name=fn&gt;&lt;/label&gt;&lt;/p&gt;
 &lt;p&gt;&lt;label&gt;Essay: &lt;textarea required name=essay&gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt;
 &lt;p&gt;&lt;input type=submit name=submit value="Submit essay"&gt;&lt;/p&gt;
 &lt;p&gt;&lt;input type=submit formnovalidate name=save value="Save essay"&gt;&lt;/p&gt;
 &lt;p&gt;&lt;input type=submit formnovalidate name=cancel value="Cancel"&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>

</div>

<hr>

<div class="p">
<dl class="idl-def">
	<dt>`action@m</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
ただし、取得子は，［
此れは その内容~属性を有さない
］~OR［
此れは その内容~属性を有していて，その値 ~EQ 空~文字列
］ならば、此れの`~node文書$の`~URL$docを返さ~MUST。
</dd>

	<dt>`target@m</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
</dd>

	<dt>`method@m</dt>
	<dt>`enctype@m</dt>
	<dd>
`既知の値のみに制限され$る下で，同じ名前の対応する内容~属性を`反映-$し~MUST。
</dd>

	<dt>`encoding@m</dt>
	<dd>
`既知の値のみに制限され$る下で，
`enctype$a 内容~属性を`反映-$し~MUST。
</dd>

	<dt>`noValidate@m</dt>
	<dd>
`novalidate$a 内容~属性を`反映-$し~MUST。
</dd>

	<dt>`formAction@m</dt>
	<dd>
`formaction$a 内容~属性を`反映-$し~MUST。
ただし、取得子は，［
此れは その内容~属性を有さない
］~OR［
此れは その内容~属性を有していて，その値 ~EQ 空~文字列
］ならば、此れの`~node文書$の`~URL$docを返さ~MUST。
</dd>

	<dt>`formEnctype@m</dt>
	<dd>
`既知の値のみに制限され$る下で，
`formenctype$a 内容~属性を`反映-$し~MUST。
</dd>

	<dt>`formMethod@m</dt>
	<dd>
`既知の値のみに制限され$る下で，
`formmethod$a 内容~属性を`反映-$し~MUST。
</dd>

	<dt>`formNoValidate@m</dt>
	<dd>
`formnovalidate$a 内容~属性
を`反映-$し~MUST。
</dd>

	<dt>`formTarget@m</dt>
	<dd>
`formtarget$a 内容~属性を`反映-$し~MUST。
</dd>

</dl>

◎
The action IDL attribute must reflect the content attribute of the same name, except that on getting, when the content attribute is missing or its value is the empty string, the element's node document's URL must be returned instead. The target IDL attribute must reflect the content attribute of the same name. The method and enctype IDL attributes must reflect the respective content attributes of the same name, limited to only known values. The encoding IDL attribute must reflect the enctype content attribute, limited to only known values. The noValidate IDL attribute must reflect the novalidate content attribute. The formAction IDL attribute must reflect the formaction content attribute, except that on getting, when the content attribute is missing or its value is the empty string, the element's node document's URL must be returned instead. The formEnctype IDL attribute must reflect the formenctype content attribute, limited to only known values. The formMethod IDL attribute must reflect the formmethod content attribute, limited to only known values. The formNoValidate IDL attribute must reflect the formnovalidate content attribute. The formTarget IDL attribute must reflect the formtarget content attribute.
</div>



					<section id="autofocusing-a-form-control:-the-autofocus-attribute">
<h5 title="Autofocusing a form control: the autofocus attribute">4.10.19.6.1. ~form~controlの自動focus法： `autofocus^a 属性</h5>

<p>
`autofocus@a
内容~属性により、作者は，［
頁が読込まれ次第 ／
当の~formが見出される `dialog$e が示され次第
］，~controlを~focusさせるよう指示できるようになる
— 利用者は、当の~controlに 手動で~focusせずに，打込みを開始できるようになる。
◎
The autofocus content attribute allows the author to indicate that a control is to be focused as soon as the page is loaded or as soon as the dialog within which it finds itself is shown, allowing the user to just start typing without having to manually focus the main control.
</p>

<p>
`autofocus$a
属性は`真偽~属性$である。
◎
The autofocus attribute is a boolean attribute.
</p>

<p>
要素 %要素 が属する
`自動focus根@†
は、［
%要素 自身または %要素 に最も近い先祖
］に `dialog$e 要素が［
あるならば それ ／
なければ %要素 の last `広義~先祖$である要素††とする。
◎
An element's nearest ancestor autofocus scoping root element is the element itself if the element is a dialog element, or else is the element's nearest ancestor dialog element, if any, or else is the element's last inclusive ancestor element.
</p>

<p class="trans-note">【†
原文では，
“nearest ancestor autofocus scoping root element”
といういかにも長い呼称なので、この訳では略記する。
】【††
“last” が意図不明。
“`木~順序$で最後”
を意味するならば、定義により，最後の`広義~先祖$は %要素 自身になる。
】</p>

<p>
同じ`自動focus根$に属する複数の要素が， `autofocus$a 属性を有していては~MUST_NOT。
◎
There must not be two elements with the same nearest ancestor autofocus scoping root element that both have the autofocus attribute specified.
</p>

<p>
`autofocus$a 属性を有する要素が，文書の`中へ挿入され$たときは、~UAは次の手続きを走らすべきである：
◎
When an element with the autofocus attribute specified is inserted into a document, user agents should run the following steps:
</p>

<ol>
	<li>
%文書 ~LET 要素の`~node文書$
◎
Let target be the element's node document.
</li>
	<li>
%B ~LET %文書 が`属する閲覧文脈$
</li>
	<li>
~IF［
%B ~EQ ε
］
⇒
~RET
◎
If target has no browsing context, abort these steps.
</li>
	<li>
%T ~LET %B の`~top-level閲覧文脈$
</li>
	<li>
~IF［
%T ~EQ ε （例： %B が`親~閲覧文脈$のない`入子の閲覧文脈$のとき）
］
⇒
~RET
◎
If target's browsing context has no top-level browsing context (e.g. it is a nested browsing context with no parent browsing context), abort these steps.
</li>
	<li>
~IF［
`閲覧文脈~sandbox化( 自動~特色機能 )~flag$ ~IN %文書 の`作動中の~sandbox用~flag集合$
］
⇒
~RET
◎
If target's active sandboxing flag set has the sandboxed automatic features browsing context flag, abort these steps.
</li>
	<li>
~IF［
( %文書 の`生成元$, %T 内の現在~focusされている要素の`~node文書$の`生成元$ )
は`同一生成元$でない
］
⇒
~RET
◎
If target's origin is not the same as the origin of the node document of the currently focused element in target's top-level browsing context, abort these steps.
</li>
	<li>
~IF［
( %文書 の`生成元$, %T の`作動中の文書$の`生成元$ )
は`同一生成元$でない
］
⇒
~RET
◎
If target's origin is not the same as the origin of the active document of target's top-level browsing context, abort these steps.
</li>
	<li>
~IF［
ある`文書$ %D があって，［
%D の`~top-level閲覧文脈$の`作動中の文書$
］~EQ［
%T の`作動中の文書$
］］~AND［
~UAは、 %D の`中へ挿入され$た要素に呼応して，この手続きの最後の段にすでに到達した`？^tnote
］
⇒
~RET
◎
If the user agent has already reached the last step of this list of steps in response to an element being inserted into a Document whose top-level browsing context's active document is the same as target's top-level browsing context's active document, abort these steps.
</li>
	<li>
~IF［
利用者は~focusを変更しないよう望むことを指示した（例えば，~form~control内で打込みを開始することにより）
］
⇒
~UAの任意選択で
⇒
~RET
◎
If the user has indicated (for example, by starting to type in a form control) that they do not wish focus to be changed, then optionally abort these steps.
</li>
	<li>
<p>
`~task源$に`利用者~対話~task源$を用いる下で，要素を`~focusする手続き$を走らす`~taskを待入する$
— ~UAは、次をしても~MAY：
</p>

<ul ><li>文書の~scrolling位置も変更するか，あるいは
</li><li>要素を利用者に注目させるような何らかの他の動作を遂行する。
</li></ul>
◎
Queue a task that runs the focusing steps for the element. User agents may also change the scrolling position of the document, or perform some other action that brings the element to the user's attention. The task source for this task is the user interaction task source.
</li>
</ol>

<p class="note">注記：
これは、文書を読込んでいる間の自動的~focusを取扱う。
`dialog$e 要素の［
`show()$m ／ `showModal()$m
］~methodも， `autofocus$a 属性を処理する。
◎
This handles the automatic focusing during document load. The show() and showModal() methods of dialog elements also processes the autofocus attribute.
</p>

<p class="note">注記：
~controlを~focusするときに、~UAが~focusを失った~browser~windowを~focusし~MUSTわけではない。
◎
Focusing the control does not imply that the user agent must focus the browser window if it has lost focus.
</p>

<dl class="idl-def">
	<dt>`autofocus@m</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
◎
The autofocus IDL attribute must reflect the content attribute of the same name.
</dd>
</dl>



<div class="example">
<p>
次の~code片の~text~controlは、文書が読込まれたときに~focusされることになる。
◎
In the following snippet, the text control would be focused when the document was loaded.
</p>

<pre class="html-code">
&lt;input maxlength="256" name="q" value="" autofocus&gt;
&lt;input type="submit" value="Search"&gt;
</pre>
</div>


					</section>
				</section>
				<section id="input-modalities:-the-inputmode-attribute">
<h4 title="Input modalities: the inputmode attribute">4.10.19.7. 入力~modality： `inputmode^a 属性</h4>

<p>
`inputmode@a
内容~属性は、［
~form~controlの中に内容を手入力している利用者にとって，どの種類の入力~仕組みが最も便利になるか
］を指定する，`列挙ed属性$である。
◎
The inputmode content attribute is an enumerated attribute that specifies what kind of input mechanism would be most helpful for users entering content into the form control.
</p>

<p>
~UAは、下に与える すべての~keyword, および 対応する状態を認識し~MUSTが、対応する状態すべてを~supportする必要はない。
ある~keywordに対応する状態を~supportしない~UAは、代わりにその~keywordが，下に定義されるように その~fallback状態に対応付けられているかのように動作し~MUST。
この~fallbackの挙動は推移的とする。
◎
User agents must recognize all the keywords and corresponding states given below, but need not support all of the corresponding states. If a keyword's state is not supported, the user agent must act as if the keyword instead mapped to the given state's fallback state, as defined below. This fallback behavior is transitive.
</p>

<p class="note">注記：
例えば、 QWERTY ~keyboard-layoutを備える~UAが，~text予測も自動~頭字化も~supportしない場合、~keyword `latin-prose$iM を，連鎖［
`Latin-prose$Im → `Latin$Im → `Verbatim$Im
］に従って `verbatim$iM ~keywordと同じ仕方で扱うこともできる。
◎
For example, if a user agent with a QWERTY keyboard layout does not support text prediction and automatic capitalization, then it could treat the latin-prose keyword in the same way as the verbatim keyword, following the chain Latin Prose → Latin Text → Latin Verbatim.
</p>

<p>
次の表に、この属性に可能0な~keywordと状態を挙げる。
1 列目に~keyword，同じ行の 2 列目に対応付けられる状態, 3 列目に~fallback状態を与える。
◎
The possible keywords and states for the attributes are listed in the following table. The keywords are listed in the first column. Each maps to the state given in the cell in the second column of that keyword's row, and that state has the fallback state given in the cell in the third column of that row.
</p>

<p class="trans-note">【
この和訳では、状態~名を，単に~keywordの最初の文字を大文字にしただけの文字列で表す。
原文の状態~名には もう少し説明的なものもあり，ハイフンもないが、ここでは対応関係を簡明にすることを優先する。
】</p>


<table class="three-column-nowrap">
<thead><tr><th>~keyword
</th><th>状態
</th><th>~fallback状態
</th><th>記述

</th></tr><tr lang="en"><th>Keyword
</th><th>State
</th><th>Fallback state
</th><th>Description
</th></tr></thead>

<tbody><tr><td>`verbatim@iM
</td><td>`Verbatim@Im
</td><td>`Default$st
</td><td>
内容が散文（ prose ）でない，英数字~Latin用字系~入力
— 例： ~username, ~password, 製品~code。
◎
Alphanumeric Latin-script input of non-prose content, e.g. usernames, passwords, product codes.

</td></tr><tr><td>`latin@iM
</td><td>`Latin@Im
</td><td>`Verbatim$Im
</td><td>
利用者の選好する言語（たち）による~Latin用字系~入力
— 人から~computerへの~communication用に意図され，何らかの打込み援助（例：~text予測）が可能化されるような。
— 例：自由形の~text探索~欄。
◎
Latin-script input in the user's preferred language(s), with some typing aids enabled (e.g. text prediction). Intended for human-to-computer communications, e.g. free-form text search fields.

</td></tr><tr><td>`latin-name@iM
</td><td>`Latin-name@Im
</td><td>`Latin$Im
</td><td>
利用者の選好する言語（たち）による~Latin用字系~入力
— 人~名を手入力するために意図される打込み援助が可能化されるような（例：
利用者の連絡先~listからの~text予測や，単語ごとの自動~頭字化）。
顧客~名~欄などの状況に意図される。
◎
Latin-script input in the user's preferred language(s), with typing aids intended for entering human names enabled (e.g. text prediction from the user's contact list and automatic capitalisation at every word). Intended for situations such as customer name fields.

</td></tr><tr><td>`latin-prose@iM
</td><td>`Latin-prose@Im
</td><td>`Latin$Im
</td><td>
利用者の選好する言語（たち）による~Latin用字系~入力
— 人から人への~communication用に意図され，より積極的な打込み援助が可能化されるような（例： ~text予測や文頭の自動~頭字化）。
~e-mailや~instant-messagingなどの状況に意図される。
◎
Latin-script input in the user's preferred language(s), with aggressive typing aids intended for human-to-human communications enabled (e.g. text prediction and automatic capitalisation at the start of sentences). Intended for situations such as e-mails and instant messaging.

</td></tr><tr><td>`full-width-latin@iM
</td><td>`Full-width-latin@Im
</td><td><a href="#attr-fe-inputmode-state-latin">Latin Prose</a>
`？^tnote<!-- ＊ -->
</td><td>
利用者の副~言語（たち）による，全角~文字を用いる~Latin用字系~入力
— 人から人への~communication用に意図され，より積極的な打込み援助が可能化されるような（例： ~text予測や文頭の自動~頭字化）。
~CJK~textの内側に~Latin~textを埋込むために意図される。
◎
Latin-script input in the user's secondary language(s), using full-width characters, with aggressive typing aids intended for human-to-human communications enabled (e.g. text prediction and automatic capitalisation at the start of sentences). Intended for latin text embedded inside CJK text.

</td></tr><tr><td>`kana@iM
</td><td>`Kana@Im
</td><td>`Default$st
</td><td>
概して ~hiragana入力による，~kana入力や~romaji入力
— 全角~文字を利用し，~kanjiへ変換するための~supportを伴うような。
~Japanese~text入力~用に意図される。
◎
Kana or romaji input, typically hiragana input, using full-width characters, with support for converting to kanji. Intended for Japanese text input.

</td></tr><tr><td>`kana-name@iM
</td><td>`Kana-name@Im
</td><td>`Kana$Im
</td><td>
概して ~hiragana入力による，~kana入力や~romaji入力
— 全角~文字を利用し，~kanjiへ変換するための~supportを伴い，人~名を手入力するために意図される打込み援助も可能化されるような（例： 利用者の連絡先~listに基づく~text予測）。
顧客~名~欄などの状況に意図される。
◎
Kana or romaji input, typically hiragana input, using full-width characters, with support for converting to kanji, and with typing aids intended for entering human names enabled (e.g. text prediction from the user's contact list). Intended for situations such as customer name fields.

</td></tr><tr><td>`katakana@iM
</td><td>`Katakana@Im
</td><td>`Kana$Im
</td><td>
~katakana入力
— 全角~文字を利用し，~kanjiへ変換するための~supportを伴うような。
~Japanese~text入力~用に意図される。
◎
Katakana input, using full-width characters, with support for converting to kanji. Intended for Japanese text input.

</td></tr><tr><td>`numeric@iM
</td><td>`Numeric@Im
</td><td>`Default$st
</td><td>
数的~入力
— 数字 0 〜 9 の~key,
利用者が選好する 3 桁ごとの区切文字,
負~数を指示する文字を含むような。
数的~codeに意図される。
例： ~credit-card番号。
（実数に対しては、 `number$stT を選好せよ。）
◎
Numeric input, including keys for the digits 0 to 9, the user's preferred thousands separator character, and the character for indicating negative numbers. Intended for numeric codes, e.g. credit card numbers. (For numbers, prefer "&lt;input type=number&gt;".)

</td></tr><tr class="rare"><td>`tel@iM
</td><td>`Tel@Im
</td><td>`Numeric$Im
</td><td>
電話~番号~入力
— 数字 0 〜 9, 文字 "#", "*" の~keyを含めて。
~localeによっては、これには~alphabetic~mnemonicも含まれる（例えば米国では、歴史的に，~label "2" の~keyには ~label "A", "B", "C" も付与されている）。
これが`必要とされるのは稀$である
— 代わりに `tel$stT を利用-せよ。
◎
Telephone number input, including keys for the digits 0 to 9, the "#" character, and the "*" character. In some locales, this can also include alphabetic mnemonic labels (e.g. in the US, the key labeled "2" is historically also labeled with the letters A, B, and C). Rarely necessary; use "&lt;input type=tel&gt;" instead.

</td></tr><tr class="rare"><td>`email@iM
</td><td>`Email@Im
</td><td>`Default$st
</td><td>
利用者の~localeにおける~text入力
— 文字 "@" や "." などの，~e-mail~addressの入力を援助する~keyも伴われた。
これが`必要とされるのは稀$である
— 代わりに `email$stT を利用せよ。
◎
Text input in the user's locale, with keys for aiding in the input of e-mail addresses, such as that for the "@" character and the "." character. Rarely necessary; use "&lt;input type=email&gt;" instead.

</td></tr><tr class="rare"><td>`url@iM
</td><td>`Url@Im
</td><td>`Default$st
</td><td>
利用者の~localeにおける~text入力
— `~URL$の入力を援助する~keyが伴われた
— 文字 "/" や "." ，
"www." や ".co.uk" など
~domain名に共通的に見出される文字列を手早く入力するための。
これが`必要とされるのは稀$である
— 代わりに `url$stT を利用せよ。
◎
Text input in the user's locale, with keys for aiding in the input of URLs, such as that for the "/" and "." characters and for quick input of strings commonly found in domain names such as "www." or ".co.uk". Rarely necessary; use "&lt;input type=url&gt;" instead.

</td></tr></tbody></table>


<p id="avoid-inputmode">
上に挙げた最後の 3 個の~keywordは、網羅性のためのみに提供されており，必要とされるのは稀である
— それらの通例的な利用-事例には、（上の表に述べたように）専用の入力~controlが存在するので。
◎
The last three keywords listed above are only provided for completeness, and are rarely necessary, as dedicated input controls exist for their usual use cases (as described in the table above).
</p>


<p>
すべての~UAは、
`Default@st
入力~mode状態を~supportし~MUST
— それは、~UAの既定の入力~modalityに対応する。
この仕様は、~UAの既定の~modalityがどう演算するかは定義しない。
`値なしに対する既定の状態$は `Default$st 入力~modeとする。
◎
User agents must all support the Default input mode state, which corresponds to the user agent's default input modality. This specification does not define how the user agent's default modality is to operate. The missing value default is the default input mode state.
</p>


<p>
~UAは，［
`inputmode$a 属性が`適用される$ ~form~control
］の値を編集する~UIを公開するときには、その属性の状態に対応する入力~modalityを利用するべきである。
ある状態に対応する入力~modalityは、上の表~内の状態の記述に合うように設計されたものとする。
この値は 動的に変化し得るので、~UAは，属性の状態~変化に応じて
— 利用者の望みに反しない限り —
その~UIを更新するべきである。
◎
User agents should use the input modality corresponding to the state of the inputmode attribute when exposing a user interface for editing the value of a form control to which the attribute applies. An input modality corresponding to a state is one designed to fit the description of the state in the table above. This value can change dynamically; user agents should update their interface as the attribute changes state, unless that would go against the user's wishes.
</p>

				</section>
				<section id="autofill">
<h4 title="Autofill">4.10.19.8. 自動充填（ autofill ）</h4>

<p class="trans-note">【
この節の内容は、未訳。
】</p>


				</section>
			</section>
			<section id="textFieldSelection">
<h3 title="APIs for the text control selections">4.10.20. ~text~control選択~用の~API</h3>


<p>
［
`input$e ／ `textarea$e
］要素は、それらの選択を取扱うためとして，その~DOM~interfaceにて次の~memberを定義している：
◎
The input and textarea elements define the following members in their DOM interfaces for handling their selection:
</p>


<pre class="idl extract">
  void `select$m();
  attribute unsigned long? `selectionStart$m;
  attribute unsigned long? `selectionEnd$m;
  attribute DOMString? `selectionDirection$m;
  void `setRangeText$m(DOMString %replacement);
  void `setRangeText$m(DOMString %replacement, unsigned long %start, unsigned long %end, optional `SelectionMode$I %selectionMode = "preserve");
  void `setSelectionRange$m(unsigned long %start, unsigned long %end, optional DOMString %direction = "preserve");
</pre>

<p class="trans-note">【
`textarea$e （ `HTMLTextAreaElement$I ）の
`selectionStart^m ／ `selectionEnd^m ／ `selectionDirection^m
は ~NULL を返さない（ nullable でない：
<a href="https://github.com/whatwg/html/issues/2175">~~参照</a>
）。
】</p>

<p>
`setRangeText()$m
~methodは、次の列挙を利用する：
◎
The setRangeText method uses the following enumeration:
</p>

<pre class="idl">
enum `SelectionMode@I {
  `select$l,
  `start$l,
  `end$l,
  `preserve$l // default
};
</pre>


<p>
これらの~IDL~memberは、［
`input$e ／ `textarea$e
］~text~controlの選択を公開し，制御する。
◎
These methods and attributes expose and control the selection of input and textarea text controls.
</p>

<p>
この節における
`~offset@
とは、~text内の，論理~順序による［
始端, 終端, 隣接する ある 2 文字の間
］のいずれかを指す，負でない整数であり、`~offset$ 0 は始端を指し，`~offset$［
~text内の文字~数
］は終端を指すとする。
</p>

<p class="trans-note">【
この`~offset$の定義は、簡潔に記すために，この訳に導入している（原文の “offset” は、文字列~内の “文字の~offset” を表していて，記述がまわりくどいので）。
】</p>


<dl class="domintro">

	<dt>%element . `select()$m</dt>
	<dd>
~text~control内のすべてを選択する。
◎
Selects everything in the text control.
</dd>

	<dt>%element . `selectionStart$m [ = %value ]</dt>
	<dd>
選択の始端を指す`~offset$を返す。
◎
Returns the offset to the start of the selection.
</dd>
	<dd>
設定して，選択の始端を変更できる。
◎
Can be set, to change the start of the selection.
</dd>

	<dt>%element . `selectionEnd$m [ = %value ]</dt>
	<dd>
選択の終端を指す`~offset$を返す。
◎
Returns the offset to the end of the selection.
</dd>
	<dd>
設定して，選択の終端を変更できる。
◎
Can be set, to change the end of the selection.
</dd>

	<dt>%element . `selectionDirection$m [ = %value ]</dt>
	<dd>
現在の選択~方向を返す。
◎
Returns the current direction of the selection.
</dd>
	<dd>
設定して，現在の選択~方向を変更できる。
◎
Can be set, to change the direction of the selection.
</dd>
	<dd>
可能0な値は［
`forward^l, `backward^l, `none^l
］のいずれかである。
◎
The possible values are "forward", "backward", and "none".
</dd>

	<dt>%element . `setSelectionRange(start, end [, direction] )$m</dt>
	<dd>
選択の［
始端, 終端, 方向
］を［
%start, %end, %direction
］に変更する。
%direction が省略された場合、方向は~platformの既定のそれ（ `forward^l または `none^l ）に再設定される。
◎
Changes the selection to cover the given substring in the given direction. If the direction is omitted, it will be reset to be the platform default (none or forward).
</dd>

	<dt>%element . `setRangeText(replacement [, start, end [, selectionMode ] ] )$m</dt>
	<dd>
~textのある範囲を，新たな~textに置換する。
%start, %end 引数が提供されない場合の範囲は、選択~全体と見做される。
◎
Replaces a range of text with the new text. If the start and end arguments are not provided, the range is assumed to be the selection.
</dd>
	<dd>
<p>
~~最後の引数は、~textが置換された後に，選択が どう設定されるべきかを決定する。
可能0な値は：
◎
The final argument determines how the selection should be set after the text has been replaced. The possible values are:
</p>

		<dl>
			<dt>`select$l</dt>
			<dd>
新たに挿入された~textを選択する。
◎
Selects the newly inserted text.
</dd>

			<dt>`start$l</dt>
			<dd>
選択の始端, 終端ともに 挿入された~textの直前に移動する。
◎
Moves the selection to just before the inserted text.
</dd>

			<dt>`end$l</dt>
			<dd>
選択の始端, 終端ともに 挿入された~textの直後に移動する。
◎
Moves the selection to just after the selected text.
</dd>

			<dt>`preserve$l</dt>
			<dd>
選択をなるべく保全しようと試みる。
これが既定。
◎
Attempts to preserve the selection. This is the default.
</dd>
		</dl>
	</dd>
</dl>


<div>
<p>
`input$e 要素に対しては、これらの~IDL~memberが`適用されない$間は：
</p>

<ul ><li>その［
被呼出時 ／ 設定子
］には `InvalidStateError$E 例外を投出し~MUST
</li><li>その取得子は~NULLを返さ~MUST。
</li></ul>

<p>
他の場合、それらは，下に述べるように動作し~MUST。
</p>

◎
For input elements, calling these methods while they don't apply, and setting these attributes while they don't apply, must throw an "InvalidStateError" DOMException; and getting these attributes while they don't apply must return null. Otherwise, they must act as described below.
</div>

<p>
これらの~IDL~memberは、［
`input$e 要素に対しては その`値$ ／
`textarea$e 要素に対しては その`生の値$tA
］に対し演算し~MUST。
◎
For input elements, these methods and attributes must operate on the element's value. For textarea elements, these methods and attributes must operate on the element's raw value.
</p>

<p>
［
`input$e ／ `textarea$e
］要素において~text選択を変更するような~UI特色機能は、可能0な所では，この節に述べる~DOM~APIを通して実装され~MUST
— 例えば すべて同じ~eventが発火されるように。
◎
Where possible, user interface features for changing the text selection in input and textarea elements must be implemented in terms of the DOM API described in this section, so that, e.g., all the same events fire.
</p>


<p>
［
`input$e ／ `textarea$e
］要素は、［
`前方^i, `後方^i, `~none^i
］のいずれかを値にとる `選択~方向^i を持つ。
この方向は、利用者が選択を操作するときに設定される。
選択~方向の正確な意味は~platformに依存する。
◎
The selections of input and textarea elements have a direction, which is either forward, backward, or none. This direction is set when the user manipulates the selection. The exact meaning of the selection direction depends on the platform.
</p>

<p class="note">注記：
Windows 上では、この選択~方向は、選択に相対的な~caret位置を指示する：
~caretは、方向に応じて［
`前方^i ならば選択の終端 ／
`後方^i ならば選択の始端
］にある。
Windows に `~none^i 方向はない。
Mac では、方向は，利用者が
Shift ＋ 矢印~keyを用いて，選択~範囲を調整するときに 選択のどちらの端が影響されるかを指示する：
改変される端は、方向に応じて［
`前方^i ならば選択の終端 ／
`後方^i ならば選択の始端
］になる。
Mac では、 `~none^i 方向が既定であり，特定0の方向はまだ選択されてないことを指示する。
方向は、利用者が選択を最初に調整するときに，どっちの矢印~keyが利用されたかに基づいて暗黙的に設定される。
◎
On Windows, the direction indicates the position of the caret relative to the selection: a forward selection has the caret at the end of the selection and a backward selection has the caret at the start of the selection. Windows has no none direction. On Mac, the direction indicates which end of the selection is affected when the user adjusts the size of the selection using the arrow keys with the Shift modifier: the forward direction means the end of the selection is modified, and the backwards direction means the start of the selection is modified. The none direction is the default on Mac, it indicates that no particular direction has yet been selected. The user sets the direction implicitly when first adjusting the selection, based on which directional arrow key was used.
</p>


<dl class="idl-def">
	<dt>`select()@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
</p>
		<ol>
			<li>
此れの~text~controlの内容を全部的に選択する
</li>
			<li>
選択~方向 ~SET ［
~platformは選択~方向 `~none^i を~supportするならば `~none^i ／
~ELSE_ `前方^i
］
</li>
			<li>
`利用者~対話~task源$を用いる下で，次を走らす`~taskを待入する$
⇒
此れに向けて、名前 `select$et の~eventを，［
`bubbles$m 属性 ~SET ~T
］に初期化した上で `発火-$する
</li>
		</ol>
◎
The select() method must cause the contents of the text control to be fully selected, with the selection direction being none, if the platform support selections with the direction none, or otherwise forward. The user agent must then queue a task, using the user interaction task source, to fire an event named select at the element, with the bubbles attribute initialized to true.
</dd>
	<dd>
`input$e 要素の事例においては、~control内に選択し得る~textがない場合，この~methodは何もしては~MUST_NOT。
◎
In the case of input elements, if the control has no selectable text, then the method must do nothing.
</dd>
	<dd class="example">
具体例として、 `color$stT を，［
16 進~色~codeを受容する~text~control
］ではなく［
色~pickerを擁する~color-well
］として具現化する~UAにおいては、~textは選択し得ないので，この~methodの~callは無視される。
◎
For instance, in a user agent where &lt;input type=color&gt; is rendered as a color well with a picker, as opposed to a text control accepting a hexadecimal color code, there would be no selectable text, and thus calls to the method are ignored.
</dd>

	<dt>`selectionStart@m</dt>
	<dd>
取得子は、選択の始端を指す`~offset$を返さ~MUST。
選択がない場合、~text手入力~cursorを指す`~offset$を返さ~MUST。
◎
The selectionStart attribute must, on getting, return the offset (in logical order) to the character that immediately follows the start of the selection. If there is no selection, then it must return the offset (in logical order) to the character that immediately follows the text entry cursor.
</dd>
	<dd>
設定子は、次を引数に`選択~範囲を設定-$し~MUST
⇒
(
所与の値,
MAX( `selectionEnd$m 属性の現在の値, 所与の値 ),
(`selectionDirection$m の現在の値 )
)
◎
On setting, it must set the selection range with the new value as the first argument; the current value of the selectionEnd attribute as the second argument, unless the current value of the selectionEnd is less than the new value, in which case the second argument must also be the new value; and the current value of the selectionDirection as the third argument.
</dd>

	<dt>`selectionEnd@m</dt>
	<dd>
取得子は、選択が［
ないならば ~text手入力~cursor ／
あるならば その終端
］を指す`~offset$を返さ~MUST。
◎
The selectionEnd attribute must, on getting, return the offset (in logical order) to the character that immediately follows the end of the selection. If there is no selection, then it must return the offset (in logical order) to the character that immediately follows the text entry cursor.
</dd>
	<dd>
設定子は、次を引数に`選択~範囲を設定-$し~MUST
⇒
`selectionStart$m 属性の現在の値, 所与の値, `selectionDirection$m の現在の値
◎
On setting, it must set the selection range with the current value of the selectionStart attribute as the first argument, the new value as the second argument, and the current value of the selectionDirection as the third argument.
</dd>

	<dt>`selectionDirection@m</dt>
	<dd>
取得子は、現在の選択~方向に応じて［
`前方^i ならば `forward^l ／
`後方^i ならば `backward^l ／
~ELSE_ `none^l
］を返さ~MUST。
◎
The selectionDirection attribute must, on getting, return the string corresponding to the current selection direction: if the direction is forward, "forward"; if the direction is backward, "backward"; and otherwise, "none".
</dd>
	<dd>
設定子は、次を引数に`選択~範囲を設定-$し~MUST
⇒
( `selectionStart$m 属性の現在の値, `selectionEnd$m 属性の現在の値, 所与の値 )
◎
On setting, it must set the selection range with the current value of the selectionStart attribute as the first argument, the current value of the selectionEnd attribute as the second argument, and the new value as the third argument.
</dd>

	<dt>`setSelectionRange(start, end, direction)@m</dt>
	<dd>
被呼出時には、同じ引数で`選択~範囲を設定-$し~MUST。
◎
The setSelectionRange(start, end, direction) method must set the selection range with the same arguments.
</dd>

</dl>


<p class="algo-head">
`選択~範囲を設定-@
するときは、所与の (
%始端 （非負~整数または~NULL）,
%終端 （非負~整数または~NULL）,
%方向 （文字列, 省略時は ε）
)
に対し，次の手続き走らせ~MUST：
◎
To set the selection range with an integer or null start, an integer or null end, and optionally a string direction, means to run these steps:
</p>

<ol>
	<li>
~IF［
%始端 ~EQ ~NULL
］
⇒
%始端 ~SET 0
◎
If start is null, let start be zero.
</li>
	<li>
~IF［
%終端 ~EQ ~NULL
］
⇒
%終端 ~LET 0
◎
If end is null, let end be zero.
</li>
	<li>
%L ~LET ~text~controlの値の長さ
</li>
	<li>
%終端 ~LET MIN ( %終端, %L )
</li>
	<li>
%始端 ~LET MIN ( %始端, %L, %終端 )
</li>
	<li>
~text~controlの選択~範囲を［
%始端 `~offset$ 〜 %終端 `~offset$
］に設定する
— 範囲が空になる場合、空~選択の概念がない~UAにおいては，~cursorを %終端 `~offset$に設定する
</li>
	<li>
現在の選択~方向 ~SET ［
%方向 ~EQ `backward^l ならば `後方^i ／
~ELSE_ ~platformは選択~方向 `~none^i を~supportしないならば `前方^i ／
~ELSE_ %方向 ~EQ `forward^l ならば `前方^i ／
~ELSE_ `~none^i
］
◎
Set the selection of the text control to the sequence of characters starting with the character at the startth position (in logical order) and ending with the character at the (end-1)th position. Arguments greater than the length of the value of the text control must be treated as pointing at the end of the text control. If end is less than or equal to start then the start of the selection and the end of the selection must both be placed immediately before the character with offset end. In UAs where there is no concept of an empty selection, this must set the cursor to be just before the character with offset end. The direction of the selection must be set to backward if direction is a case-sensitive match for the string "backward", forward if direction is a case-sensitive match for the string "forward" or if the platform does not support selections with the direction none, and none otherwise (including if the argument is omitted).
</li>
	<li>
~task源に`利用者~対話~task源$を用いる下で，次を走らす`~taskを待入する$
⇒
要素に向けて、名前 `select$et の~eventを，［
`bubbles$m 属性 ~SET ~T
］に初期化した上で `発火-$する
◎
Queue a task, using the user interaction task source, to fire an event named select at the element, with the bubbles attribute initialized to true.
</li>
</ol>


<p>
`setRangeText(replacement start, end selectionMode)@m
の被呼出時には、次の手続きを走らせ~MUST：
◎
The setRangeText(replacement, start, end, selectMode) method must run the following steps:
</p>

<ol>
	<li>
( %選択~始端, %選択~終端 ) ~LET
此れの
( `selectionStart$m, `selectionEnd$m )
属性の現在の値
</li>
	<li>
~IF［
%start 以降の引数は与えられていない
］
⇒
( %start, %end ) ~SET ( %選択~始端, %選択~終端 )
◎
If the method has only one argument, then let start and end have the values of the selectionStart attribute and the selectionEnd attribute respectively.
◎
Otherwise, let start, end have the values of the second and third arguments respectively.
</li>
	<li>
~IF［
%start ~GT %end
］
⇒
~THROW `IndexSizeError$E
◎
If start is greater than end, then throw an "IndexSizeError" DOMException and abort these steps.
</li>
	<li>
%L ~LET 此れの値の長さ
</li>
	<li>
%始端 ~SET MIN( %start, %L )
◎
If start is greater than the length of the value of the text control, then set it to the length of the value of the text control.
</li>
	<li>
%終端 ~SET MIN( %end, %L )
◎
If end is greater than the length of the value of the text control, then set it to the length of the value of the text control.
◎
Let selection start be the current value of the selectionStart attribute.
◎
Let selection end be the current value of the selectionEnd attribute.
</li>
	<li>
~IF［
%始端 ~LT %終端
］
⇒
此れの値 内の［
%始端 `~offset$ 〜 %終端 `~offset$
］にある文字を削除する
◎
If start is less than end, delete the sequence of characters starting with the character at the startth position (in logical order) and ending with the character at the (end-1)th position.
</li>
	<li>
此れの値 内の %始端 `~offset$に %replacement の値を挿入する
◎
Insert the value of the first argument into the text of the value of the text control, immediately before the startth character.
</li>
	<li>
%新~終端 ~LET %始端 + ( %replacement の長さ )
◎
Let new length be the length of the value of the first argument.
◎
Let new end be the sum of start and new length.
</li>
	<li>
<p>
%selectionMode に応じて：
◎
Run the appropriate set of substeps from the following list:
</p>

		<dl class="switch">
			<dt>`select@l
◎
If the fourth argument's value is "select"
</dt>
			<dd>
( %選択~始端, %選択~終端 ) ~SET ( %始端, %新~終端 )
◎
Let selection start be start.
◎
Let selection end be new end.
</dd>

			<dt>`start@l
◎
If the fourth argument's value is "start"
</dt>
			<dd>
( %選択~始端, %選択~終端 ) ~SET ( %始端, %始端 )
◎
Let selection start and selection end be start.
</dd>

			<dt>`end@l
◎
If the fourth argument's value is "end"
</dt>
			<dd>
( %選択~始端, %選択~終端 ) ~SET ( %新~終端, %新~終端 )
◎
Let selection start and selection end be new end.
</dd>

			<dt>`preserve@l （既定）
◎
If the fourth argument's value is "preserve" (the default)
</dt>
			<dd>
				<ol>
					<li>
%差分 ~LET ( %replacement の長さ ) − ( %終端 − %始端 )
◎
Let old length be end minus start.
◎
Let delta be new length minus old length.
</li>
					<li>
~IF［
%選択~始端 ~GT %終端
］
⇒
%選択~始端 ~INCBY %差分
（ %差分 が負の場合，すなわち 新たな~textが置換された~textより短い場合、 %選択~始端 の値は<em>減る</em>ことになる）
◎
If selection start is greater than end, then increment it by delta. (If delta is negative, i.e. the new text is shorter than the old text, then this will decrease the value of selection start.)
</li>
					<li>
~ELIF［
%選択~始端 ~GT %始端
］
⇒
%選択~始端 ~SET %始端
（ %選択~始端 が置換された~textの途中にあった場合，選択の始端は新たな~textの始端に留められる）
◎
Otherwise: if selection start is greater than start, then set it to start. (This snaps the start of the selection to the start of the new text if it was in the middle of the text that it replaced.)
</li>
					<li>
~IF［
%選択~終端 ~GT %終端
］
⇒
%選択~終端 ~INCBY %差分
◎
If selection end is greater than end, then increment it by delta in the same way.
</li>
					<li>
~ELIF［
%選択~終端 ~GT %始端
］
⇒
%選択~終端 ~SET %新~終端
（ %選択~終端 が置換された~textの途中にあった場合，選択の始端は新たな~textの終端に留められる）
◎
Otherwise: if selection end is greater than start, then set it to new end. (This snaps the end of the selection to the end of the new text if it was in the middle of the text that it replaced.)
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~text~controlの選択~範囲を［
%選択~始端 `~offset$ 〜 %選択~終端 `~offset$
］に設定する
— 範囲が空になる場合、空~選択の概念がない~UAにおいては，~cursorを %選択~終端 `~offset$に設定する
◎
Set the selection of the text control to the sequence of characters starting with the character at the selection startth position (in logical order) and ending with the character at the (selection end-1)th position. In UAs where there is no concept of an empty selection, this must set the cursor to be just before the character with offset end. The direction of the selection must be set to forward if the platform does not support selections with the direction none, and none otherwise.
</li>
	<li>
現在の選択~方向 ~SET ［
~platformは `~none^i を~supportしないならば `前方^i ／
~ELSE_ `~none^i
］
◎
↑</li>
	<li>
~task源に`利用者~対話~task源$を用いる下で，次を走らす`~taskを待入する$
⇒
此れに向けて、名前 `select$et の~eventを，［
`bubbles$m 属性 ~SET ~T
］に初期化した上で `発火-$する
◎
Queue a task, using the user interaction task source, to fire an event named select at the element, with the bubbles attribute initialized to true.
</li>
</ol>

<p>
この~APIが`適用される$すべての要素は、どの時点でも（要素が`具現化されて$いなくとも），選択~範囲 または~text手入力~cursor位置を有するとする。
~UAは、それらの初期~状態を決定する際には，~platform規約に従うべきである。
◎
All elements to which this API applies have either a selection or a text entry cursor position at all times (even for elements that are not being rendered). User agents should follow platform conventions to determine their initial state.
</p>

<p>
U+200D 文字（ ZERO WIDTH JOINER ）などの可視でない文字であっても，文字として数えられる。
したがって，具体例として、選択は 可視でない文字のみを含むこともあり，~text挿入~cursorは そのような文字の前後いずれかの側に配置され得る。
◎
Characters with no visible rendering, such as U+200D ZERO WIDTH JOINER, still count as characters. Thus, for instance, the selection can include just an invisible character, and the text insertion cursor can be placed to one side or another of such a character.
</p>

<div class="example">

<p>
現在~選択されている~textを得るには、次の~JSで足りる：
◎
To obtain the currently selected text, the following JavaScript suffices:
</p>

<pre class="html-code">
var %selectionText = %control.value.substring(%control.selectionStart, %control.selectionEnd);
</pre>

<p>
（ %control は［
`input$e ／ `textarea$e
］要素とする。）
◎
...where control is the input or textarea element.
</p>

</div>

<div class="example">

<p>
3 つの属性を保全して，~text選択は維持しながら、~text~controlの始端に~textを追加する例：
◎
To add some text at the start of a text control, while maintaining the text selection, the three attributes must be preserved:
</p>

<pre class="html-code">
var %oldStart = %control.selectionStart;
var %oldEnd = %control.selectionEnd;
var %oldDirection = %control.selectionDirection;
var %prefix = "http://";
%control.value = %prefix + %control.value;
%control.setSelectionRange(%oldStart + %prefix.length, %oldEnd + %prefix.length, %oldDirection);
</pre>

<p>
（ %control は［
`input$e ／ `textarea$e
］要素とする。）
◎
...where control is the input or textarea element.
</p>

</div>



			</section>
			<section id="constraints">
<h3 title="Constraints">4.10.21. 拘束</h3>

				<section id="definitions">
<h4 title="Definitions">4.10.21.1. 各種 定義</h4>

<p>
`提出-可能$な要素は、
`拘束検証の対象外@
にある間を除いて，
`拘束検証の候補@
になる（例えば、 `object$e 要素は`拘束検証の対象外$になる。）
◎
A submittable element is a candidate for constraint validation except when a condition has barred the element from constraint validation. (For example, an element is barred from constraint validation if it is an object element.)
</p>

<p>
要素には、
`~custom妥当性~error~message@
も定義され得る
— 初期~時には，空~文字列とする。
その値が空~文字列でないときは、要素は，`~custom~errorの難あり$になる。
`setCustomValidity()$m ~methodを用いて，それを設定できる。
~UAは、当の~controlにおける問題を利用者に~alertするときには、`~custom妥当性~error~message$を利用するべきである。
◎
An element can have a custom validity error message defined. Initially, an element must have its custom validity error message set to the empty string. When its value is not the empty string, the element is suffering from a custom error. It can be set using the setCustomValidity() method. The user agent should use the custom validity error message when alerting the user to the problem with the control.
</p>

<p>
要素は、様々な仕方で拘束できる／され得る。
以下に，拘束検証の目的0において~controlを妥当でなくするような，~form~controlがとり得る
`妥当性~状態@
を挙げる。
（下の定義は規範的でない
— 各~状態が適用されるかどうかは、この仕様の他所にて より精確に定義される。）
◎
An element can be constrained in various ways. The following is the list of validity states that a form control can be in, making the control invalid for the purposes of constraint validation. (The definitions below are non-normative; other parts of this specification define more precisely when each state applies or does not.)
</p>


<dl>
	<dt>
`欠落の難あり@
◎
Suffering from being missing
</dt>
	<dd>
~controlは、 `required^a 属性（
`input$e の `~requiredI$a ／ `textarea$e の `~requiredT$a
）を有するが、その`値$がないとき。
ただし、［
`select$e 要素 ／ `~radio~button群$に属する~control
］においては、それらの各 節に指定されるように，より複雑な規則になる。
◎
When a control has no value but has a required attribute (input required, textarea required); or, more complicated rules for select elements and controls in radio button groups, as specified in their sections.
</dd>

	<dt>
`型~不一致の難あり@
◎
Suffering from a type mismatch
</dt>
	<dd> 
任意の利用者~入力を許容する~controlの`値$が正しい構文でないとき（
`Email$st, `Url$st
）。
◎
When a control that allows arbitrary user input has a value that is not in the correct syntax (E-mail, URL).
</dd>

	<dt>
`~pattern不一致の難あり@
◎
Suffering from a pattern mismatch
</dt>
	<dd>
~controlの`値$が `pattern$a 属性を満たさないとき。
◎
When a control has a value that doesn't satisfy the pattern attribute.
</dd>

	<dt>
`長過ぎる難あり@
◎
Suffering from being too long
</dt>
	<dd> 
~controlの`値$が`~form~control~maxlength属性$（
`input$e の `~maxlengthI$a ／ `textarea$e の `~maxlengthT$a
）に比して長過ぎるとき。
◎
When a control has a value that is too long for the form control maxlength attribute (input maxlength, textarea maxlength).
</dd>

	<dt>
`短か過ぎる難あり@
◎
Suffering from being too short
</dt>
	<dd>
~controlの`値$が`~form~control~minlength属性$（
`input$e の `~minlengthI$a ／ `textarea$e の `~minlengthT$a
）に比して短か過ぎるとき。
◎
When a control has a value that is too short for the form control minlength attribute (input minlength, textarea minlength).
</dd>

	<dt>
`~underflowの難あり@
◎
Suffering from an underflow
</dt>
	<dd>
~controlの`値$は 空~文字列でない, かつ
`min$a 属性に比して低~過ぎるとき。
◎
When a control has a value that is not the empty string and is too low for the min attribute.
</dd>

	<dt>
`~overflowの難あり@
◎
Suffering from an overflow
</dt>
	<dd>
~controlの`値$は 空~文字列でない, かつ
`max$a 属性に比して高~過ぎるとき。
◎
When a control has a value that is not the empty string and is too high for the max attribute.
</dd>

	<dt>
`~step不一致の難あり@
◎
Suffering from a step mismatch
</dt>
	<dd>
~controlの`値$が `step$a 属性が与える規則に合わないとき。
◎
When a control has a value that doesn't fit the rules given by the step attribute.
</dd>

	<dt>
`不良~入力の難あり@
◎
Suffering from bad input
</dt>
	<dd>
~controlの入力は不完全であり、~UAは，［
その現在の状態において，利用者が~formを提出できる
］と~~判断していないとき。
◎
When a control has incomplete input and the user agent does not think the user ought to be able to submit the form in its current state.
</dd>
	<dd class="trans-note">【
すなわち、上に挙げられた他のどの “難あり” にも該当しないが， “難あり” にされるべきとき。
】</dd>

	<dt>
`~custom~errorの難あり@
◎
Suffering from a custom error
</dt>
	<dd>
~controlの`~custom妥当性~error~message$が空~文字列でないとき。
（これは、要素の `setCustomValidity()$m ~methodにより設定される。）
◎
When a control's custom validity error message (as set by the element's setCustomValidity() method) is not the empty string.
</dd>
</dl>

<p class="note">注記：
要素は，`不能化され$ていても，依然として これらいずれかの状態に難ありになり得る。
したがって，これらの状態は、提出の間に~formを検証するときに，利用者に問題を指示しない場合でも，~DOMにおいて表現され得る。
`<a href="#the-constraint-validation-api">拘束検証~DOM~API</a>を通して？^tnote
◎
An element can still suffer from these states even when the element is disabled; thus these states can be represented in the DOM even if validating the form during submission wouldn't indicate a problem to the user.
</p>

<p>
要素は、上述した どの`妥当性~状態$の難ありでもないとき，
`自身の拘束を満たす@
とされる。
◎
An element satisfies its constraints if it is not suffering from any of the above validity states.
</p>


				</section>
				<section id="constraint-validation">
<h4 title="Constraint validation">4.10.21.2. 拘束検証</h4>

<div >
<p class="algo-head">
~UAは、 `form$e 要素 %~form の
`拘束を静的に検証-@
することが要求されたときは，次の手続きを走らせ~MUST
— それは、［
`肯定的^i, `否定的^i
］のいずれかを返す：
</p>

<ul ><li>`肯定的^i は %~form 内のすべての~controlは妥当であることを表し、
`否定的^i はその否定を表す。
</li><li>`否定的^i を返す場合の結果には，［
妥当でないかつ, それを担当する~scriptもない要素
］の~listも伴われる（場合によっては空になる）
</li></ul>

◎
When the user agent is required to statically validate the constraints of form element form, it must run the following steps, which return either a positive result (all the controls in the form are valid) or a negative result (there are invalid controls) along with a (possibly empty) list of elements that are invalid and for which no script has claimed responsibility:
</div>

<ol>
	<li>
%~control~list ~LET
%~form が`所有-$している要素のうち，`提出-可能$であるものからなる，`木~順序$による~list
◎
Let controls be a list of all the submittable elements whose form owner is form, in tree order.
</li>
	<li>
%非~妥当~control~list ~LET 空~list
◎
Let invalid controls be an initially empty list of elements.
</li>
	<li>
<p>
~FOR
%~control~list 内の ~EACH ( %欄 ) に対し：
◎
For each element field in controls, in tree order, run the following substeps:
</p>

		<ol>
			<li>
~IF［
%欄 は`拘束検証の候補$でない
］
⇒
~CONTINUE
◎
If field is not a candidate for constraint validation, then move on to the next element.
</li>
			<li>
~IF［
%欄 は`自身の拘束を満たす$
］
⇒
~CONTINUE
◎
Otherwise, if field satisfies its constraints, then move on to the next element.
</li>
			<li>
%非~妥当~control~list に %欄 を追加する
◎
Otherwise, add field to invalid controls.
</li>
		</ol>
	</li>
	<li>
~IF［
%非~妥当~control~list は空である
］
⇒
~RET `肯定的^i
◎
If invalid controls is empty, then return a positive result and abort these steps.
</li>
	<li>
%未取扱~非妥当~control~list ~LET 空~list
◎
Let unhandled invalid controls be an initially empty list of elements.
</li>
	<li>
<p>
~FOR
%非~妥当~control~list 内の ~EACH ( %欄 ) に対し：
◎
For each element field in invalid controls, if any, in tree order, run the following substeps:
</p>

		<ol>
			<li>
%notCanceled ~LET %欄 に向けて、名前 `invalid$et の~eventを，［
`cancelable$m 属性 ~SET ~T
］に初期化した上で `発火-$する
◎
Let notCanceled be the result of firing an event named invalid at field, with the cancelable attribute initialized to true.
</li>
			<li>
~IF［
%notCanceled ~EQ ~T
］
⇒
%未取扱~非妥当~control~list に %欄 を追加する
◎
If notCanceled is true, then add field to unhandled invalid controls.
</li>
</ol>

	</li>
	<li>
~RET `否定的^i ＋ %未取扱~非妥当~control~list
◎
Return a negative result with the list of elements in the unhandled invalid controls list.
</li>
</ol>

<p class="algo-head">
~UAは、
`form$e 要素 %~form を
`拘束を対話的に検証-@
するときは、次の手続きを走らせ~MUST
◎
If a user agent is to interactively validate the constraints of form element form, then the user agent must run the following steps:
</p>

<ol>
	<li>
~IF［
%~form の`拘束を静的に検証-$した結果 ~EQ `肯定的^i
］
⇒
~RET `肯定的^i
◎
Statically validate the constraints of form, and let unhandled invalid controls be the list of elements returned if the result was negative.
◎
If the result was positive, then return that result and abort these steps.
</li>
	<li>
<p>
前段の検証-結果に伴われる %未取扱~非妥当~control~list 内の 1 個~以上の要素の拘束についての問題を，利用者に報告する
— ~UAは次をしても~MAY：
</p>

<ul>
	<li>
~list内のいずれかの要素を`~focusする手続き$を走らせて，~focusする
</li>
	<li>
文書の~scrolling位置も変更する ／
要素を利用者に注目させるような何らかの他の動作を遂行する。
</li>
	<li>
複数の拘束~違反を報告する。
</li>
	<li>
適切になるなら，関係する拘束~違反~報告を~~結合する
（例：
`~radio~button群$内の複数の~radio~buttonが必須とされている場合、報告する必要がある~errorは一つだけになる）。
</li>
	<li>
いずれかの~controlが`具現化されて$いない場合（例： `hidden$a 属性を有するなど）、~script~errorを報告する。
</li>
</ul>

◎
Report the problems with the constraints of at least one of the elements given in unhandled invalid controls to the user. User agents may focus one of those elements in the process, by running the focusing steps for that element, and may change the scrolling position of the document, or perform some other action that brings the element to the user's attention. User agents may report more than one constraint violation. User agents may coalesce related constraint violation reports if appropriate (e.g. if multiple radio buttons in a group are marked as required, only one error need be reported). If one of the controls is not being rendered (e.g. it has the hidden attribute set) then user agents may report a script error.
</li>
	<li>
~RET `否定的^i
◎
Return a negative result.
</li>
</ol>

				</section>
				<section id="the-constraint-validation-api">
<h4 title="The constraint validation API">4.10.21.3. 拘束検証~API</h4>

<dl class="domintro">

	<dt>%element . `willValidate$m</dt>
	<dd>
［
%element は~formの提出-時に検証されるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element will be validated when the form is submitted; false otherwise.
</dd>

	<dt>%element . `setCustomValidity(message)$m</dt>
	<dd>
~custom~errorを設定して %element が検証-時に失敗するようにする。
%message は 利用者に問題を報告するときに示される~messageを与える。
◎
Sets a custom error, so that the element would fail to validate. The given message is the message to be shown to the user when reporting the problem to the user.
</dd>
	<dd>
%message が空~文字列の場合、~custom~errorを~~空に戻す。
◎
If the argument is the empty string, clears the custom error.
</dd>

	<dt>%element . `validity$m . `valueMissing$m</dt>
	<dd>
［
%element は必須の欄であって 値がない ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element has no value but is a required field; false otherwise.
</dd>

	<dt>%element . `validity$m . `typeMismatch$m</dt>
	<dd>
［
%element の値は正しい構文でないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is not in the correct syntax; false otherwise.
</dd>

	<dt>%element . `validity$m . `patternMismatch$m</dt>
	<dd>
［
%element の値は提供された~patternに合致しないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value doesn't match the provided pattern; false otherwise.
</dd>

	<dt>%element . `validity$m . `tooLong$m</dt>
	<dd>
［
%element の値は 提供された最大~長さより長いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is longer than the provided maximum length; false otherwise.
</dd>

	<dt>%element . `validity$m . `tooShort$m</dt>
	<dd>
［
%element の値は 空~文字列でない, かつ 提供された最小~長さより短いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value, if it is not the empty string, is shorter than the provided minimum length; false otherwise.
</dd>

	<dt>%element . `validity$m . `rangeUnderflow$m</dt>
	<dd>
［
%element の値は 提供された最小より低いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is lower than the provided minimum; false otherwise.
</dd>

	<dt>%element . `validity$m . `rangeOverflow$m</dt>
	<dd>
［
%element の値は 提供された最大より高いならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value is higher than the provided maximum; false otherwise.
</dd>

	<dt>%element . `validity$m . `stepMismatch$m</dt>
	<dd>
［
%element の値は `step$a 属性が与える規則に合わないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value doesn't fit the rules given by the step attribute; false otherwise.
</dd>

	<dt>%element . `validity$m . `badInput$m</dt>
	<dd>
［
利用者が~UI内に提供した入力を ~UAが値に変換できないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the user has provided input in the user interface that the user agent is unable to convert to a value; false otherwise.
</dd>

	<dt>%element . `validity$m . `customError$m</dt>
	<dd>
［
%element に~custom~errorがあるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element has a custom error; false otherwise.
</dd>

	<dt>%element . `validity$m . `valid$m</dt>
	<dd>
［
%element の値に妥当性の問題がないならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the element's value has no validity problems; false otherwise.
</dd>

	<dt>%valid = %element . `checkValidity()$m</dt>
	<dd>
［
%element の値に妥当性の問題がないならば ~T ／
~ELSE_ ~F
］を返す。
加えて， ~F を返すときは、
%element に向けて `invalid$et ~eventを発火する。
◎
Returns true if the element's value has no validity problems; false otherwise. Fires an invalid event at the element in the latter case.
</dd>

	<dt>%valid = %element . `reportValidity()$m</dt>
	<dd>
［
%element の値に妥当性の問題がないならば ~T ／
~ELSE_ ~F
］を返す。
加えて， ~F を返すときは、
 %element に向けて `invalid$et ~eventを発火した上で，（~eventが取消されなかったなら）問題を利用者に報告する。
◎
Returns true if the element's value has no validity problems; otherwise, returns false, fires an invalid event at the element, and (if the event isn't canceled) reports the problem to the user.
</dd>

	<dt>%element . `validationMessage$m</dt>
	<dd>
%element の妥当性が検査され，問題があった場合に 利用者に示されることになる~error~messageを返す。
◎
Returns the error message that would be shown to the user if the element was to be checked for validity.
</dd>
</dl>



<dl class="idl-def">
	<dt>`willValidate@m</dt>
	<dd>
取得子は、［
此れは`拘束検証の候補$であるならば ~T ／
~ELSE_（すなわち`拘束検証の対象外$ならば） ~F 
］を返さ~MUST。
◎
The willValidate attribute's getter must return true, if this element is a candidate for constraint validation, and false otherwise (i.e., false if any conditions are barring it from constraint validation).
</dd>

	<dt>`setCustomValidity(message)@m</dt>
	<dd>
被呼出時には、［
此れの`~custom妥当性~error~message$ ~SET %message
］に設定し~MUST。
◎
The setCustomValidity(message) method, when invoked, must set the custom validity error message to message.
</dd>
	<dd class="example">

<p>
次の例では、~scriptは，~form~controlの値を編集される度に検査し、妥当な値でないならば，
`setCustomValidity()$m ~methodを利用して適切な~messageを設定する。
◎
In the following example, a script checks the value of a form control each time it is edited, and whenever it is not a valid value, uses the setCustomValidity() method to set an appropriate message.
</p>

<pre class="html-code">
&lt;label&gt;Feeling: &lt;input name=f type="text" oninput="check(this)"&gt;&lt;/label&gt;
&lt;script&gt;
 function check(%input) {
   if (%input.value == "good" ||
       %input.value == "fine" ||
       %input.value == "tired") {
     %input.setCustomValidity('"' + %input.value + '" is not a feeling.');
   } else {
     /* <span class="comment">
%input は申し分ない — ~error~messageを再設定する
◎
input is fine -- reset the error message
</span> */
     %input.setCustomValidity('');
   }
 }
&lt;/script&gt;
</pre>

	</dd>

	<dt>`validity@m</dt>
	<dd>
取得子は、［
此れの`妥当性~状態$を表現する `ValidityState$I ~obj
］を返さ~MUST。
この~objは`~live$とする。
◎
The validity attribute's getter must return a ValidityState object that represents the validity states of this element. This object is live.
</dd>

</dl>


<pre class="idl">interface `ValidityState@I {
  readonly attribute boolean `valueMissing$m;
  readonly attribute boolean `typeMismatch$m;
  readonly attribute boolean `patternMismatch$m;
  readonly attribute boolean `tooLong$m;
  readonly attribute boolean `tooShort$m;
  readonly attribute boolean `rangeUnderflow$m;
  readonly attribute boolean `rangeOverflow$m;
  readonly attribute boolean `stepMismatch$m;
  readonly attribute boolean `badInput$m;
  readonly attribute boolean `customError$m;
  readonly attribute boolean `valid$m;
};
</pre>

<p>
`ValidityState$I ~objは、次に挙げる属性を持つ。
それらの取得子は、［
対応する条件が満たされるならば ~T ／
~ELSE_ ~F
］を返さ~MUST：
◎
A ValidityState object has the following attributes. On getting, they must return true if the corresponding condition given in the following list is true, and false otherwise.
</p>

<dl class="idl-def">
	<dt>`valueMissing@m</dt>
	<dd>
~controlには`欠落の難あり$
◎
The control is suffering from being missing.
</dd>

	<dt>`typeMismatch@m</dt>
	<dd>
~controlには`型~不一致の難あり$
◎
The control is suffering from a type mismatch.
</dd>

	<dt>`patternMismatch@m</dt>
	<dd>
~controlには`~pattern不一致の難あり$
◎
The control is suffering from a pattern mismatch.
</dd>

	<dt>`tooLong@m</dt>
	<dd>
~controlには`長過ぎる難あり$
◎
The control is suffering from being too long.
</dd>

	<dt>`tooShort@m</dt>
	<dd>
~controlには`短か過ぎる難あり$
◎
The control is suffering from being too short.
</dd>

	<dt>`rangeUnderflow@m</dt>
	<dd>
~controlには`~underflowの難あり$
◎
The control is suffering from an underflow.
</dd>

	<dt>`rangeOverflow@m</dt>
	<dd>
~controlには`~overflowの難あり$
◎
The control is suffering from an overflow.
</dd>

	<dt>`stepMismatch@m</dt>
	<dd>
~controlには`~step不一致の難あり$
◎
The control is suffering from a step mismatch.
</dd>

	<dt>`badInput@m</dt>
	<dd>
~controlには`不良~入力の難あり$
◎
The control is suffering from bad input.
</dd>

	<dt>`customError@m</dt>
	<dd>
~controlには`~custom~errorの難あり$
◎
The control is suffering from a custom error.
</dd>

	<dt>`valid@m</dt>
	<dd>
上に挙げた どの条件も満たされない
◎
None of the other conditions are true.
</dd>
</dl>

<hr>

<dl class="idl-def">
	<dt>`checkValidity()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The checkValidity() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
<p >
~IF［
此れは`拘束検証の候補$である
］~AND［
此れは`自身の拘束を満たす$
］：
◎
If this element is a candidate for constraint validation and does not satisfy its constraints, then:
</p>

				<ol>
					<li>
此れに向けて、名前 `invalid$et の~eventを，［
`cancelable$m 属性 ~SET ~T
］に初期化した上で `発火-$する（取消しても効果はないが。）
◎
Fire an event named invalid at this element, with the cancelable attribute initialized to true (though canceling has no effect).
</li>
					<li>
~RET ~F
◎
Return false.
</li>
				</ol>
			</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</dd>

	<dt>`reportValidity()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The reportValidity() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
<p>
~IF［
此れは`拘束検証の候補$である
］~AND［
此れは`自身の拘束を満たす$
］：
◎
If this element is a candidate for constraint validation and does not satisfy its constraints, then:
</p>

				<ol>
					<li>
%report ~LET 此れに向けて、名前 `invalid$et の~eventを，［
`cancelable$m 属性 ~SET ~T
］に初期化した上で `発火-$した結果
◎
Let report be the result of firing an event named invalid at this element, with the cancelable attribute initialized to true.
</li>
					<li>
<p>
~IF［
%report ~EQ ~T
］
⇒
此れの拘束についての問題を 利用者に報告する
— その際には、~UAは 次をしても~MAY：
</p>

<ul><li>此れを`~focusする手続き$を走らす
</li><li>文書の~scrolling位置を変更する, あるいは
要素を利用者に注目させるような何らかの他の動作を遂行する
</li><li>此れが複数の問題に難ありならば，それら複数の拘束~違反を報告する
</li><li>此れが`具現化されて$いない場合、利用者に通知する代わりに，`走っている~script$に対し`~errorを報告する$
</li></ul>
◎
If that event is not canceled, report the problems with the constraints of this element to the user. When reporting the problem with the constraints to the user, the user agent may run the focusing steps for this element, and may change the scrolling position of the document, or perform some other action that brings this element to the user's attention. User agents may report more than one constraint violation, if this element suffers from multiple problems at once. If this element is not being rendered, then the user agent may, instead of notifying the user, report the error for the running script.
</li>
					<li>
~RET ~F
◎
Return false.
</li>
				</ol>
			</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</dd>

	<dt>`validationMessage@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The validationMessage attribute's getter must run these steps:
</p>

		<ol>
			<li>
~IF［
此れは`拘束検証の候補$でない
］~OR［
此れは`自身の拘束を満たす$
］
⇒
~RET 空~文字列
◎
If this element is not a candidate for constraint validation or if this element satisfies its constraints, then return the empty string.
</li>
			<li>
<p>
~RET 次の要件を満たすような~message：
</p>
<ul>
	<li>
此れは、妥当性の拘束に問題がある，唯一の~form~controlである場合、利用者に示すに相応しく地域化された~message
</li>
	<li>
~UAが~textによる~messageを実際に示さない場合（例えば，代わりに~graphical-cueを示す場合）、~controlが満たさない（ 1 個~以上の）妥当性~拘束を表し, 相応しく地域化された~message。
</li>
	<li>
［
此れは`拘束検証の候補$である
］~AND［
`~custom~errorの難あり$
］の場合、結果の~message内には`~custom妥当性~error~message$が在するべきである。
<span class="trans-note">【
この場合の結果に，他の情報も含まれ得るのかどうかは、原文の記述からは，はっきりしない。
】</span>
</li>
</ul>

◎
Return a suitably localized message that the user agent would show the user if this were the only form control with a validity constraint problem. If the user agent would not actually show a textual message in such a situation (e.g., it would show a graphical cue instead), then return a suitably localized message that expresses (one or more of) the validity constraint(s) that the control does not satisfy. If the element is a candidate for constraint validation and is suffering from a custom error, then the custom validity error message should be present in the return value.
</li>
		</ol>
	</dd>
</dl>


				</section>
				<section id="security-forms">
<h4 title="Security">4.10.21.4. ~security</h4>


<p id="security-0">
~serverは、~client側の検証に依拠するべきでない。
敵対的な利用者は，~client側の検証を意図的に迂回でき、また
意図せずとも，これらの特色機能を実装しない［
旧式の~UA ／ 自動化~tool
］の利用者により迂回され得るので。
拘束検証の特色機能が意図するのは，利用者~体験を改善することに限られており、~securityについては，いかなる種類の仕組みも提供しない。
◎
Servers should not rely on client-side validation. Client-side validation can be intentionally bypassed by hostile users, and unintentionally bypassed by users of older user agents or automated tools that do not implement these features. The constraint validation features are only intended to improve the user experience, not to provide any kind of security mechanism.
</p>


				</section>
			</section>
			<section id="form-submission-2">
<h3 title="Form submission">4.10.22. ~form提出</h3>

				<section id="introduction-5">
<h4 title="Introduction">4.10.22.1. 序論</h4>


~INFORMATIVE

<p>
~formが提出されるとき、~form内の~dataは，`~enctype$が指定する構造に変換された上で、所与の`~method$を用いて，`動作$に指定される行先へ送信される。
◎
When a form is submitted, the data in the form is converted into the structure specified by the enctype, and then sent to the destination specified by the action using the given method.
</p>

<p>
例えば、次の~formでは：
◎
For example, take the following form:
</p>

<pre class="html-code">
&lt;form action="/find.cgi" method=get&gt;
 &lt;input type=text name=t&gt;
 &lt;input type=search name=q&gt;
 &lt;input type=submit&gt;
&lt;/form&gt;
</pre>

<p>
利用者が
1 番目の欄に "cats",
2 番目の欄に "fur"
と打込んで，提出~buttonを叩いた場合、~UAは
`/find.cgi?t=cats&amp;q=fur^c
を読込むことになる。
◎
If the user types in "cats" in the first field and "fur" in the second, and then hits the submit button, then the user agent will load /find.cgi?t=cats&amp;q=fur.
</p>

<p>
他方、次の~formを考える：
◎
On the other hand, consider this form:
</p>

<pre class="html-code">
&lt;form action="/find.cgi" method=post enctype="multipart/form-data"&gt;
 &lt;input type=text name=t&gt;
 &lt;input type=search name=q&gt;
 &lt;input type=submit&gt;
&lt;/form&gt;
</pre>


<p>
利用者により同じ入力が与えられた下での提出の結果は，全く異なり、代わりに~UAは，所与の~URLへ向けて 次の~textに似た様な~entity本体を伴わせた~HTTP~POSTを行う：
◎
Given the same user input, the result on submission is quite different: the user agent instead does an HTTP POST to the given URL, with as the entity body something like the following text:
</p>

<pre class="http-code">
------kYFrd4jNJEgCervE
Content-Disposition: form-data; name="t"

cats
------kYFrd4jNJEgCervE
Content-Disposition: form-data; name="q"

fur
------kYFrd4jNJEgCervE--
</pre>


				</section>
				<section id="implicit-submission">
<h4 title="Implicit submission">4.10.22.2. 暗黙的な提出</h4>

<p>
`form$e 要素の
`既定の~button@
は、それが`所有-$している`提出-~button$のうち，`木~順序$で最初のものとする。
◎
A form element's default button is the first submit button in tree order whose form owner is that form element.
</p>

<p>
~UAが，利用者による ~formの暗黙的な提出を~supportする場合（例えば，一部の~platformでは、~text~controlが`~focusされて$いる間に <kbd>enter</kbd> ~keyを叩くと，~formは暗黙的に提出される）、~formの`既定の~button$に`作動化の挙動$があって, `不能化され$ていない場合に そうするときは、~UAは，その`既定の~button$に向けて`~click~eventを発火-$し~MUST。
◎
If the user agent supports letting the user submit a form implicitly (for example, on some platforms hitting the "enter" key while a text control is focused implicitly submits the form), then doing so for a form, whose default button has activation behavior and is not disabled, must cause the user agent to fire a click event at that default button.
</p>


<p class="note">注記：
その帰結として、そのような暗黙的な提出の仕組みが利用されているときでも，`既定の~button$が`不能化され$ている場合、~formは提出されない（不能化された~buttonには`作動化の挙動$はないので）。
◎
Consequently, if the default button is disabled, the form is not submitted when such an implicit submission mechanism is used. (A button has no activation behavior when disabled.)
</p>

<p class="note">注記：
~Webには，~formを暗黙的に提出する仕方がある場合に限り利用できる頁もある。
したがって、~UAには，これの~supportが強く奨励される。
◎
There are pages on the Web that are only usable if there is a way to implicitly submit forms, so user agents are strongly encouraged to support this.
</p>

<div>
<p>
~formに`提出-~button$がない場合、暗黙的な提出の仕組みは：
</p>

<ul>
	<li>
<p>
~form内に，` 暗黙的な提出を阻む欄^i がある場合には、何もしては~MUST_NOT
⇒
` 暗黙的な提出を阻む欄^i とは、`form$e 要素が`所有-$している `input$e 要素のうち，`type$a 属性の状態が次のいずれかにあるものとする
⇒
`Text$st, `Text$st, `Url$st, `Tel$st, `Email$st, `Password$st, `Date$st, `Month$st, `Week$st, `Time$st, `Datetime-local$st, `Number$st
</p>

</li>
	<li>
他の場合、 `form$e 要素は，それ自身から`提出-$し~MUST。
</li>
</ul>

◎
If the form has no submit button, then the implicit submission mechanism must do nothing if the form has more than one field that blocks implicit submission, and must submit the form element from the form element itself otherwise.
◎
For the purpose of the previous paragraph, an element is a field that blocks implicit submission of a form element if it is an input element whose form owner is that form element and whose type attribute is in one of the following states: Text, Search, URL, Telephone, E-mail, Password, Date, Month, Week, Time, Local Date and Time, Number
</div>

				</section>
				<section id="form-submission-algorithm">
<h4 title="Form submission algorithm">4.10.22.3. ~form提出~algo</h4>

<p class="algo-head">
`form$e 要素 %~form を要素 %提出元 （概して~button）から
`提出-@
するときは、~UAは，次の手続きを走らせ~MUST：
<!-- ＊
optionally with a submitted from submit() method flag set（省略時は ~OFF ）
 -->
◎
When a form element form is submitted from an element submitter (typically a button), optionally with a submitted from submit() method flag set, the user agent must run the following steps:
</p>

<ol>
	<li>
`submit() から呼出された^V ~LET ［
この手続きは `submit()$m ~methodから呼出されたならば ~T ／
~ELSE_ ~F
］
</li>
	<li>
%~form文書 ~LET %~form の`~node文書$
◎
Let form document be the form's node document.
</li>
	<li>
%~form閲覧文脈 ~LET %~form文書 が`属する閲覧文脈$
◎
↓</li>
	<li id="sandboxSubmitBlocked">
<p >
~IF［
次のいずれかが満たされる
]
⇒
~RET：
</p>
<ul ><li>%~form文書 は`接続されて$いない<!-- %~form＊？ -->
</li><li>%~form閲覧文脈 ~EQ ε
</li><li>`閲覧文脈~sandbox化( ~form )~flag$ ~IN
%~form文書 の`作動中の~sandbox用~flag集合$
</li></ul>

◎
If form document is not connected, has no associated browsing context, or its active sandboxing flag set has its sandboxed forms browsing context flag set, then abort these steps without doing anything.
◎
Let form browsing context be the browsing context of form document.
</li>
	<li>
<p>
~IF［
`submit() から呼出された^V ~EQ ~F
］：
</p>
		<ol>
			<li>
<p>
~IF［
%提出元 の`検証なし状態$ ~EQ ~F
］：
</p>
				<ol>
					<li>
%結果 ~LET %~form の`拘束を対話的に検証-$した結果
</li>
					<li>
<p>
~IF［
%結果 ~EQ `否定的^i
］：
</p>

<ol><li>%~form に向けて，名前 `invalid$et の~eventを`発火-$する
</li><li>~RET
</li></ol>
					</li>
				</ol>
◎
If the submitted from submit() method flag is not set, and the submitter element's no-validate state is false, then interactively validate the constraints of form and examine the result: if the result is negative (the constraint validation concluded that there were invalid fields and probably informed the user of this) then fire an event named invalid at the form element and then abort these steps.
◎
If the submitted from submit() method flag is not set, then:
</li>
			<li>
%continue ~LET %~form に向けて、名前 `submit$et の~eventを，［
( `bubbles$m, `cancelable$m ) 属性 ~SET ( ~T, ~T )
］に初期化した上で `発火-$した結果
◎
Let continue be the result of firing an event named submit at form, with the bubbles attribute initialized to true and the cancelable attribute initialized to true.
</li>
			<li>
~IF［
%continue ~EQ ~F
］
⇒
~RET
◎
If continue is false, then abort these steps. 
</li>
		</ol>
	<li>
%~form~data集合 ~LET
%提出元 の文脈~下で %~form から`~form~data集合を構築-$した結果
◎
Let form data set be the result of constructing the form data set for form in the context of submitter.
</li>
	<li>
%符号化方式 ~LET %~form の現在の`符号化方式$form
◎
Let encoding be the result of picking an encoding for the form.
</li>
	<li>
%動作~URL ~LET %提出元 の`動作$
◎
Let action be the submitter element's action.
</li>
	<li>
~IF［
%動作~URL ~EQ 空~文字列
］
⇒
%動作~URL ~LET %~form文書 の`~URL$doc
◎
If action is the empty string, let action be the URL of the form document.
</li>
	<li>
%解析済~動作 ~LET %動作~URL を %提出元 の`~node文書$に`相対的に構文解析-$した`結果の~URL~record$
◎
↓</li>
	<li>
~IF［
%解析済~動作 ~EQ ~error
］
⇒
~RET
◎
Parse the URL action, relative to the submitter element's node document. If this fails, abort these steps.
◎
Let parsed action be the resulting URL record.
</li>
	<li>
%~scheme ~LET %解析済~動作 の`~scheme$url
◎
Let scheme be the scheme of parsed action.
</li>
	<li>
%~enctype ~LET %提出元 の`~enctype$
◎
Let enctype be the submitter element's enctype.
</li>
	<li>
%~method ~LET %提出元 の`~method$
◎
Let method be the submitter element's method.
</li>
	<li>
%~target ~LET %提出元 の`~target$
◎
Let target be the submitter element's target.
</li>
	<li>
%~target閲覧文脈 ~LET ［
利用者から ~form提出に利用する特定の`閲覧文脈$が指示されたならば その `閲覧文脈$ ／
~ELSE_ 次を与える下で，`名前から閲覧文脈を選ぶ規則$を適用した結果
］
⇒
( 名前 %~target, 文脈 %~form閲覧文脈 )
◎
If the user indicated a specific browsing context to use when submitting the form, then let target browsing context be that browsing context. Otherwise, apply the rules for choosing a browsing context given a browsing context name using target as the name and form browsing context as the context in which the algorithm is executed, and let target browsing context be the resulting browsing context.
</li>
	<li>
<p>
`置換え~flag^V ~LET ［
次のいずれかが満たされるならば ~ON ／
~ELSE_ ~OFF
］：
</p>
		<ul>
			<li>
%~target閲覧文脈 は、新たに作成されたものである
</li>
			<li>
［
%~form文書 はまだ`完全に読込まれ$ていない
］~AND［
`submit() から呼出された^V ~EQ ~T
］
</li>
		</ul>
◎
If target browsing context was created in the previous step, or, alternatively, if the form document has not yet completely loaded and the submitted from submit() method flag is set, then let replace be true. Otherwise, let it be false.
</li>
	<li>
~IF［
%~method ~EQ `dialog$st
］
⇒
`~dialogを提出する$
◎
If the value of method is dialog then jump to the submit dialog steps.
</li>
	<li>
<p>
( %~scheme, %~method ) に応じて，下の表の一列目の %~scheme に該当する行の %~method に該当する列に示される下位手続きを遂行する
◎
Otherwise, select the appropriate row in the table below based on the value of scheme as given by the first cell of each row. Then, select the appropriate cell on that row based on the value of method as given in the first cell of each column. Then, jump to the steps named in that cell and defined below the table.
</p>

<table><thead><tr><td>%~scheme
</td><th>%~method ~EQ `GET$st
</th><th>%~method ~EQ `POST$st
</th></tr></thead><tbody><tr><th> `http^c
</th><td>`変異-動作~URL$
◎
Mutate action URL
</td><td>`~entity本体として提出する$
◎
Submit as entity body

</td></tr><tr><th> `https^c
</th><td>`変異-動作~URL$
◎
Mutate action URL
</td><td>`~entity本体として提出する$
◎
Submit as entity body

</td></tr><tr><th> `ftp^c
</th><td>`~Get動作~URL$
◎
Get action URL
</td><td>`~Get動作~URL$
◎
Get action URL

</td></tr><tr><th> `javascript^c
</th><td>`~Get動作~URL$
◎
Get action URL
</td><td>`~Get動作~URL$
◎
Get action URL

</td></tr><tr><th> `data^c
</th><td>`変異-動作~URL$
◎
Mutate action URL
</td><td>`~Get動作~URL$
◎
Get action URL

</td></tr><tr><th> `mailto^c
</th><td>`~header列を伴う~Mail$
◎
Mail with headers
</td><td>`本体として~Mailする$
◎
Mail as body

</td></tr><tr><th> その他
</th><td colspan="2">
この仕様では定義されない
—
~UAは、これを定義する別の仕様がない限り，この仕様にて 類似する~schemeに対し定義される方式と相似的に動作するべきである。
◎
If scheme is not one of those listed in this table, then the behavior is not defined by this specification. User agents should, in the absence of another specification defining this, act in a manner analogous to that defined in this specification for similar schemes.

</td></tr></tbody></table>

</ol>

<p>
各 `form$e 要素 %~form は、
`計画された~navi@
を持つ。
それは，~NULL または ある`~task$として定義され、要素の作成-時には~NULLに設定され~MUST。
以下に述べる挙動において，特定0の資源 %行先 への
`~navigateを計画する@
よう要求されたときは、次の手続きを走らせ~MUST
◎
Each form element has a planned navigation, which is either null or a task; when the form is first created, its planned navigation must be set to null. In the behaviors described below, when the user agent is required to plan to navigate to a particular resource destination, it must run the following steps:
</p>

<ol>
	<li>
~IF［
%~form の`計画された~navi$ ~NEQ ~NULL
］
⇒
それを`~task待行列$から除去する
◎
If the form has a non-null planned navigation, remove it from its task queue.
</li>
	<li>
( %~target閲覧文脈, `置換え~flag^V ) ~LET 
この手続きを呼び出させた ~formを`提出-$する~algoにより設定されたそれら
◎
↓</li>
	<li>
<p>
%~form の`計画された~navi$ ~LET 次の手続きを走らす新たな`~task$：
◎
Let the form's planned navigation be a new task that consists of running the following steps:
</p>

		<ol>
			<li>
%~form の`計画された~navi$ ~SET ~NULL
◎
Let the form's planned navigation be null.
</li>
			<li>
［
`置換え可能化~flag$ ~SET `置換え~flag^V
］の下で，
%~target閲覧文脈 を %行先 へ`~navigate$する
◎
Navigate target browsing context to destination. If replace is true, then target browsing context must be navigated with replacement enabled.
◎
For the purposes of this task, target browsing context and replace are the variables that were set up when the overall form submission algorithm was run, with their values as they stood when this planned navigation was queued.
</li>
		</ol>
	</li>
	<li>
~task源に`~DOM操作~task源$を用いる下で，次を走らす`~taskを待入する$
⇒
%~form の`計画された~navi$
◎
Queue the task that is the form's new planned navigation.
◎
The task source for this task is the DOM manipulation task source.
</li>
</ol>

<p>
各種~挙動は、 %~form を`提出-$する~algoの文脈~下で，次に従うとする：
◎
The behaviors are as follows:
</p>

<dl>
	<dt>`変異-動作~URL@
◎
Mutate action URL
</dt>
	<dd>
		<ol>
			<li>
%解析済~動作 の`~query$url ~SET
%符号化方式 を与える下で，
%~form~data集合 を`~fuEncoded直列化器$にかけた結果
◎
Let query be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.
◎
Set parsed action's query component to query.
</li>
			<li>
%解析済~動作 への`~navigateを計画する$
◎
Plan to navigate to parsed action.
</li>
		</ol>
	</dd>

	<dt>`~entity本体として提出する@
◎
Submit as entity body
</dt>
	<dd>
		<ol>
			<li>
<p>
%~enctype に応じて：
◎
Switch on enctype:
</p>

				<dl class="switch">
					<dt>`~fuEncoded$sT</dt>
					<dd>
<p>
%本体 ~LET
%符号化方式 を与える下で，
%~form~data集合 を`~fuEncoded直列化器$にかけた結果
◎
Let body be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.
</p>


<p>
%本体 ~SET %本体 を`~UTF-8符号化-$した結果
◎
Set body to the result of encoding body.
</p>

<p>
%~MIME型 ~LET `~fuEncoded$mt
◎
Let MIME type be "application/x-www-form-urlencoded".
</p>
					</dd>


					<dt>`~mpFormData$sT</dt>
					<dd>
%本体 ~LET 
%符号化方式 を与える下で，
%~form~data集合 を`~mpFormDataとして符号化-$した結果
◎
Let body be the result of running the multipart/form-data encoding algorithm with form data set and encoding.
</dd>
					<dd>
%~MIME型 ~LET 次の文字列を順に連結した結果：

<ol><li>`multipart/form-data;^l
</li><li>1 個の U+0020 文字（ SPACE ）
</li><li>`boundary=^l
</li><li>`~mpFormDataとして符号化-$するときに生成された`~mpFormData境界~文字列$
</li></ol>

◎
Let MIME type be the concatenation of the string "multipart/form-data;", a U+0020 SPACE character, the string "boundary=", and the multipart/form-data boundary string generated by the multipart/form-data encoding algorithm.
</dd>

					<dt>`~textPlain$sT</dt>
					<dd>
<p>
%本体 ~LET
%符号化方式 を与える下で，
%~form~data集合 を`~textPlainとして符号化-$した結果
◎
Let body be the result of running the text/plain encoding algorithm with form data set and encoding.
</p>

<p>
%本体 ~SET %符号化方式 を用いて %本体 を`符号化-$した結果
◎
Set body to the result of encoding body using encoding.
</p>

<p>
%~MIME型 ~LET `~textPlain^mt
◎
Let MIME type be "text/plain".
</p>
</dd>
</dl>

			<li>
<p>
次のようにされた新たな`要請$への`~navigateを計画する$
</p>

<ul><li>`~url$rq ~SET %解析済~動作
</li><li>`~method$rq ~SET %~method
</li><li>`~header~list$rq ~SET 
( `Content-Type^h / %~MIME型 )
のみからなる
</li><li>`本体$rq ~SET %本体
</li></ul>

◎
Plan to navigate to a new request whose url is parsed action, method is method, header list consists of `Content-Type`/MIME type, and body is body.
</li>
		</ol>
	</dd>

	<dt>`~Get動作~URL@
◎
Get action URL
</dt>
	<dd>
<p>
%解析済~動作 への`~navigateを計画する$
◎
Plan to navigate to parsed action.
</p>

<p class="note">注記：
%~form~data集合 は破棄される。
◎
The form data set is discarded.
</p>
	</dd>

	<dt>`~header列を伴う~Mail@
◎
Mail with headers
</dt>
	<dd>
		<ol>
			<li>
%~header列 ~LET
%符号化方式 を与える下で，
%~form~data集合 を`~fuEncoded直列化器$にかけた結果
◎
Let headers be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.
</li>
			<li>
%~header列 内の各 U+002B 文字（ `+^l ）を 文字列 `%20^l に置換する
◎
Replace occurrences of U+002B PLUS SIGN characters (+) in headers with the string "%20".
</li>
			<li>
%解析済~動作 の`~query$url ~SET %~header列
◎
Set parsed action's query to headers.
</li>
			<li>
%解析済~動作 への`~navigateを計画する$
◎
Plan to navigate to parsed action.
</li>
		</ol>
	</dd>

	<dt>
`本体として~Mailする@
◎
Mail as body
</dt>
	<dd>
		<ol>
			<li>
<p>
%~enctype に応じて：
◎
Switch on enctype:
</p>

<dl class="switch">
<dt>`~textPlain$sT</dt>
<dd>
<ol>
	<li>
%本体 ~LET
%符号化方式 を与える下で，
%~form~data集合 を`~textPlainとして符号化-$した結果
◎
Let body be the result of running the text/plain encoding algorithm with form data set and encoding.
</li>
	<li>
%本体 内の ~EACH ( 符号位置 ) を［
`既定の符号化-集合$を用いて，`~UTF-8~percent符号化-$した結果
］に置換する
`URL$r
◎
Set body to the result of concatenating the result of UTF-8 percent encoding each code point in body, using the default encode set. [URL]
</li>
</ol>

</dd>
<dt>
その他
◎
Otherwise
</dt>
<dd>
%本体 ~LET
%符号化方式 を与える下で，
%~form~data集合 を`~fuEncoded直列化器$にかけた結果
◎
Let body be the result of running the application/x-www-form-urlencoded serializer with form data set and encoding.
</dd>
</dl>
			</li>
			<li>
%~query ~LET %解析済~動作 の`~query$url
</li>
			<li>
~IF［
%~query ~EQ ~NULL
］
⇒
%~query ~SET 空~文字列
◎
If parsed action's query is null, then set it to the empty string.
</li>
			<li>
~IF［
%~query ~NEQ 空~文字列
］
⇒
%~query に 1 個の U+0026 文字（ `&amp;^l ）を付加する
◎
If parsed action's query is not the empty string, then append a single U+0026 AMPERSAND character (&amp;) to it.
</li>
			<li>
%~query に `body=^l を付加する
◎
Append "body=" to parsed action's query.
</li>
			<li>
%~query に %本体 を付加する
◎
Append body to parsed action's query.
</li>
			<li>
%解析済~動作 の`~query$url ~SET %~query
</li>
			<li>
%解析済~動作 への`~navigateを計画する$
◎
Plan to navigate to parsed action.
</li>
		</ol>
	</dd>
	<dt>`~dialogを提出する@
◎
Submit dialog
</dt>
	<dd>
		<ol>
			<li>
%対象 ~LET %~form に最も近い先祖 `dialog$e 要素
◎
Let subject be the nearest ancestor dialog element of form, if any.
</li>
			<li>
~IF［
%対象 ~EQ ε（無い）
］~OR［
%対象 は `open$a 属性を有さない
］
⇒
~RET
— 何もしない。
◎
If there isn't one, or if it does not have an open attribute, do nothing. Otherwise, proceed as follows:
</li>
			<li>
%結果 ~LET %提出元 の`値$（ ε もとり得る）
◎
↓</li>
			<li>
<p>
~IF［
%提出元 は `input$e 要素である
］~AND［
その `type$a 属性は `Image$st 状態にある
］：
</p>
				<ol>
					<li>
( %x, %y ) ~LET `選択された座標$の ( x, y ) 成分を基数 10 の数として `~ASCII数字$列で表した結果
</li>
					<li>
%結果 ~SET［
%x, 1 個の U+002C 文字（ `,^l ）, %y
］を順に連結した結果
</li>
				</ol>

◎
If submitter is an input element whose type attribute is in the Image Button state, then let result be the string formed by concatenating the selected coordinate's x-component, expressed as a base-ten number using ASCII digits, a U+002C COMMA character (,), and the selected coordinate's y-component, expressed in the same way as the x-component.
◎
Otherwise, if submitter has a value, then let result be that value.
◎
Otherwise, there is no result.
</li>
			<li>
%対象 の`~dialogを閉じる$
</li>
			<li>
~RET %結果
◎
Then, close the dialog subject. If there is a result, let that be the return value.
</li>
		</ol>
	</dd>
</dl>

				</section>
				<section id="constructing-form-data-set">
<h4 title="Constructing the form data set">4.10.22.4. ~form~data集合の構築-法</h4>

<p class="algo-head">
%提出元 （省略時は ~NULL ）の文脈~下で，~form %~form から
`~form~data集合を構築-@
する~algoは、次に従う：
◎
The algorithm to construct the form data set for a form form optionally in the context of a submitter submitter is as follows. If not specified otherwise, submitter is null.
</p>

<ol>
	<li>
%~control~list ~LET ［
%~form が`所有-$している`提出-可能$な要素
］すべてからなる，`木~順序$による~list
◎
Let controls be a list of all the submittable elements whose form owner is form, in tree order.
</li>
	<li>
%~form~data集合 ~LET 空~list
—
( 名前, 値, 型 ) 組からなる~list
◎
Let the form data set be a list of name-value-type tuples, initially empty.
</li>
	<li>
<p>
%~control~list 内の ~EACH ( %欄 ) に対し：
◎
Loop: For each element field in controls, in tree order, run the following substeps:
</p>

		<ol>
			<li>
%~~種別 ~LET ［
%欄 は `input$e 要素であるならば その `type$a 属性の状態 ／
~ELSE_ ε
］
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~CONTINUE
◎
If any of the following conditions are met, then skip these substeps for this element:
</p>

				<ul>
					<li>
%欄 の先祖に `datalist$e 要素がある
◎
The field element has a datalist element ancestor.
</li>
					<li>
%欄 は`不能化され$ている
◎
The field element is disabled.
</li>
					<li>
［
%欄 は`~button$である
］~AND［
%欄 ~NEQ %提出元
］
◎
The field element is a button but it is not submitter.
</li>
					<li>
［
%~~種別 ~IN { `Checkbox$st, `Radio$st }
］~AND［
%欄 の`~checkedness$ ~EQ ~F
］
◎
The field element is an input element whose type attribute is in the Checkbox state and whose checkedness is false.
◎
The field element is an input element whose type attribute is in the Radio Button state and whose checkedness is false.
</li>
					<li>
［
%~~種別 ~NEQ `Image$st
］~AND［［
%欄 は `name$a 属性を有さない
］~OR［
%欄 は `name$a 属性を有していて，その値 ~EQ 空~文字列
］］
◎
The field element is not an input element whose type attribute is in the Image Button state, and either the field element does not have a name attribute specified, or its name attribute's value is the empty string.
</li>
					<li>
%欄 は［
`~plugin$を利用していない `object$e 要素
］である
◎
The field element is an object element that is not using a plugin.
</li>
				</ul>
			</li>
			<li>
%型 ~LET %欄 の `type^m ~IDL属性の値
◎
Otherwise, process field as follows:
◎
Let type be the value of the type IDL attribute of field.
</li>
			<li>
%名前 ~LET ［
%欄 は `name$a 属性を有する ならば その値 ／
~ELSE_ 空~文字列
］
◎
↓</li>
			<li>
<p>
%~~種別 に応じて, または［
%~~種別 ~EQ ε
］の場合は %欄 に応じて：
</p>

<dl class="switch">
	<dt>`Image$st</dt>
	<dd>
				<ol>
					<li>
~IF［
%名前 ~NEQ 空~文字列
］
⇒
%名前 の末尾に 1 個の U+002E 文字（ `.^l ）を付加する
◎
If the field element is an input element whose type attribute is in the Image Button state, then run these further nested substeps:
◎
If the field element has a name attribute specified and its value is not the empty string, let name be that value followed by a single U+002E FULL STOP character (.). Otherwise, let name be the empty string.
</li>
					<li>
%x名 ~LET %名前 の末尾に 1 個の U+0078 文字（ `x^l ）を付加した結果
◎
Let namex be the string consisting of the concatenation of name and a single U+0078 LATIN SMALL LETTER X character (x).
</li>
					<li>
%y名 ~LET %名前 の末尾に 1 個の U+0079 文字（ `y^l ）を付加した結果
◎
Let namey be the string consisting of the concatenation of name and a single U+0079 LATIN SMALL LETTER Y character (y).
</li>
					<li>
~Assert：
%欄 ~EQ %提出元
◎
↓</li>
					<li>
( %x, %y ) ~LET 
この~algoが呼出される前に利用者により`選択された座標$の
( %x, %y ) 成分
◎
The field element is submitter, and before this algorithm was invoked the user indicated a coordinate. Let x be the x-component of the coordinate selected by the user, and let y be the y-component of the coordinate selected by the user.
</li>
					<li>
組( %x名, %x, %型 )
を %~form~data集合 に付加する
◎
Append an entry to the form data set with the name namex, the value x, and the type type.
</li>
					<li>
組( %y名, %y, %型 )
を %~form~data集合 に付加する
◎
Append an entry to the form data set with the name namey and the value y, and the type type.
</li>
					<li>
~CONTINUE
◎
Skip the remaining substeps for this element: if there are any more elements in controls, return to the top of the loop step, otherwise, jump to the end step below.
◎
Let name be the value of the field element's name attribute.
</li>
				</ol>
	</dd>

	<dt>`select$e 要素である</dt>
	<dd>
~FOR
%欄 の`選択肢~list$内の ~EACH( `option$e 要素 %O ) に対し
⇒
~IF［
%O の`選択有無$opt ~EQ ~T
］~AND［
%O は`不能化され$optていない
］
⇒
組( %名前, %O の`値$opt, %型 )
を %~form~data集合 に付加する
◎
If the field element is a select element, then for each option element in the select element's list of options whose selectedness is true and that is not disabled, append an entry to the form data set with the name as the name, the value of the option element as the value, and type as the type.
</dd>

	<dt>`Checkbox$st</dt>
	<dt>`Radio$st</dt>
	<dd>
				<ol>
					<li>
%値 ~LET ［
%欄 は `value$a 属性を有するならば その値 ／
~ELSE_ 文字列 `on^l
］
◎
Otherwise, if the field element is an input element whose type attribute is in the Checkbox state or the Radio Button state, then run these further nested substeps:
◎
If the field element has a value attribute specified, then let value be the value of that attribute; otherwise, let value be the string "on".
</li>
					<li>
組( %名前, %値, %型 )
を %~form~data集合 に付加する
◎
Append an entry to the form data set with name as the name, value as the value, and type as the type.
</li>
				</ol>
</dd>

	<dt>`File$st</dt>
	<dd>
		<ol>
			<li>
%~file~list ~LET %欄 の`選択された~file~list$
</li>
			<li>
~IF［
%~file~list は空である
］
⇒
組( %名前, 空~文字列, `application/octet-stream$mt )
を %~form~data集合 に付加する
</li>
			<li>
~ELSE
⇒
~FOR
%~file~list 内の ~EACH( %~file ) に対し
⇒
組( %名前, ~data, %型 ) を %~form~data集合 に付加する
— ここで~dataは
⇒
%~file の ( 名前, 型, 本体 ) からなる
</li>
		</ol>
◎
Otherwise, if the field element is an input element whose type attribute is in the File Upload state, then for each file selected in the input element, append an entry to the form data set with the name as the name, the file (consisting of the name, the type, and the body) as the value, and type as the type. If there are no selected files, then append an entry to the form data set with the name as the name, the empty string as the value, and application/octet-stream as the type.
</dd>

	<dt>`object$e 要素である</dt>
	<dd>
~IF［
`~plugin$から~form提出~値を得られる
］
⇒
組( %名前, ~form提出~値, `object^l )
を %~form~data集合 に付加する
◎
Otherwise, if the field element is an object element: try to obtain a form submission value from the plugin, and if that is successful, append an entry to the form data set with name as the name, the returned form submission value as the value, and the string "object" as the type.
</dd>

	<dt>その他</dt>
	<dd>
組( %名前, %欄 の`値$, %型 )
を %~form~data集合 に付加する
◎
Otherwise, append an entry to the form data set with name as the name, the value of the field element as the value, and type as the type.
</dd>
</dl>

			</li>
			<li>
<p>
~IF［
%欄 は `dirname$a 属性を有する
］~AND［
その値 ~NEQ 空~文字列
］：
◎
If the element has a dirname attribute, and that attribute's value is not the empty string, then run these substeps:
</p>

				<ol>
					<li>
%方向~名 ~LET %欄 の `dirname$a 属性の値
◎
Let dirname be the value of the element's dirname attribute.
</li>
					<li>
%方向 ~LET %欄 の`方向性$に応じて［
`左横書き$ならば `ltr^l ／
`右横書き$ならば `rtl^l
］
◎
Let dir be the string "ltr" if the directionality of the element is 'ltr', and "rtl" otherwise (i.e. when the directionality of the element is 'rtl').
</li>
					<li>
組( %方向~名, %方向, `direction^l )
を %~form~data集合 に付加する
◎
Append an entry to the form data set with dirname as the name, dir as the value, and the string "direction" as the type.
</li>
			</ol>

<p class="note">注記：
要素が `dirname$a 属性を有するのは、
`textarea$e 要素であるか, または［
`input$e 要素であって その `type$a 属性の状態 ~IN { `Text$st, `Search$st }
］の場合に限られる
◎
An element can only have a dirname attribute if it is a textarea element or an input element whose type attribute is in either the Text state or the Search state.
</p>

			</li>
		</ol>
	</li>
	<li>
<div class="p">

<p>
%~form~data集合 内の~EACH ( %組 ) に対し：
</p>
		<ol>
			<li>
%組 の名前の改行文字を正規化する
</li>
			<li>
~IF［
%組 の型 ~NIN { `file^l, `textarea^l }
］
⇒
%組 の値の改行文字を正規化する
</li>
		</ol>

<p>
この段において、所与の %文字列 の改行文字を正規化するときは
⇒
%文字列 内の各［
~LF, ~CR
］を、それが~CRLFの一部を成さないならば，~CRLFに置換する
⇒
ここで、
~LF は文字 U+000A LINE FEED（~LF）,
~CR は文字 U+000D CARRIAGE RETURN,
~CRLFは 2 文字からなる並び［
~CR, ~LF
］を表すとする。
</p>
◎
End: For the name of each entry in the form data set, and for the value of each entry in the form data set whose type is not "file" or "textarea", replace every occurrence of a U+000D CARRIAGE RETURN (CR) character not followed by a U+000A LINE FEED (LF) character, and every occurrence of a U+000A LINE FEED (LF) character not preceded by a U+000D CARRIAGE RETURN (CR) character, by a two-character string consisting of a U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair.
</div>

<p class="note">注記：
`textarea$e 要素の`値$に対しては、この改行文字~正規化は，すでに
~controlの`生の値$tAを~controlの`値$に変換するときに遂行されている（
それはまた、必要とされる行折返しも遂行する）。
`type$a 属性が `File$st 状態にある `input$e 要素に対しては、その値は正規化されない。
◎
In the case of the value of textarea elements, this newline normalization is already performed during the conversion of the control's raw value into the control's value (which also performs any necessary line wrapping). In the case of input elements type attributes in the File Upload state, the value is not normalized.
</p>
	</li>
	<li>
<p>＊
%~form~data集合 内の~EACH ( %組 ) に対し：
</p>
		<ol>
			<li>
%組 の名前を`~Unicode~scalar値~列に変換-$する
</li>
			<li>
~IF［
%組 の型 ~NEQ `file^l
］
⇒
%組 の値を`~Unicode~scalar値~列に変換-$する
</li>
		</ol>
◎
Replace the name of each entry in the form data set, and the value of each entry in the form data set whose type is not "file", with the results of converting to a sequence of Unicode scalar values.
</li>
	<li>
~RET %~form~data集合
◎
Return the form data set.
</li>
</ol>


				</section>
				<section id="selecting-a-form-submission-encoding">
<h4 title="Selecting a form submission encoding">4.10.22.5. ~form提出 符号化方式</h4>


<p class="algo-head">
所与の時点における， `form$e 要素 %~form の
`符号化方式@form
は、次の手続きを走らせた結果から`出力~符号化方式を取得-$した結果とする：
◎
If the user agent is to pick an encoding for a form, it must run the following steps:
</p>

<div>

<ol>
	<li>
~IF［
%~form は `accept-charset$a 属性を有さない
］
⇒
~RET `文書の符号化方式$
</li>
	<li>
~FOR
%~form の `accept-charset$a 属性の値を`空白並びで分割-$した結果~内の~EACH ( ~token ) に対し，順に
⇒
~IF［
~tokenから`符号化方式を取得-$した結果 ~NEQ 失敗
］
⇒
~RET その結果
</li>
	<li>
~RET `~UTF-8$
</li>
</ol>

◎
Let encoding be the document's character encoding.
◎
If the form element has an accept-charset attribute, set encoding to the return value of running these substeps:
◎
• Let input be the value of the form element's accept-charset attribute.
◎
• Let candidate encoding labels be the result of splitting input on spaces.
◎
• Let candidate encodings be an empty list of character encodings.
◎
• For each token in candidate encoding labels in turn (in the order in which they were found in input), get an encoding for the token and, if this does not result in failure, append the encoding to candidate encodings.
◎
• If candidate encodings is empty, return UTF-8.
◎
• Return the first encoding in candidate encodings.
◎
Return the result of getting an output encoding from encoding.
</div>



				</section>
				<section id="url-encoded-form-data">
<h4 title="URL-encoded form data">4.10.22.6. ~URLに符号化された~form~data</h4>


<p id="application-x-www-form-urlencoded-encoding-algorithm">
<span id="application/x-www-form-urlencoded-encoding-algorithm"></span>

`~fuEncoded$mt の詳細は
WHATWG URL 標準 `URL$r を見よ。
◎
See the WHATWG URL standard for details on application/x-www-form-urlencoded. [URL]
</p>

				</section>
				<section id="multipart-form-data">
<h4 title="Multipart form data">4.10.22.7. ~multipart~form~data</h4>

`16909^bug

<p class="algo-head">
所与の %符号化方式 の下で， %~form~data集合 を
`~mpFormDataとして符号化-@
する~algoは、次を走らす：
◎
The multipart/form-data encoding algorithm, given a form data set and encoding, is as follows:
</p>

<ol>
	<li>
%~charset ~LET %符号化方式 の`名前$enc
◎
Let result be the empty string.
◎
Let charset be the name of encoding.
</li>
	<li>
<p>
~FOR
%~form~data集合 内の~EACH( %組 ) に対し：
◎
For each entry in the form data set, perform these substeps:
</p>

		<ol>
			<li>
~IF［
%組 の名前 ~EQ `_charset_$v
］~AND［
%組 の型 ~EQ `hidden^l
］
⇒
%組 の値 ~SET %~charset
◎
If the entry's name is "_charset_" and its type is "hidden", replace its value with charset.
</li>
			<li>
<p>
%組 の［
名前, 値
］のそれぞれに対し，その中の［
%符号化方式 を用いて表せない ~EACH ( %文字 )
］を，次を連結して得られる文字列に置換する：
</p>

<ol><li>U+0026 文字（ `&amp;^l ）
</li><li>U+0023 文字（ `#^l ）
</li><li>%文字 の~Unicode符号位置を基数 10 で表現する， 1 個以上の`~ASCII数字$からなる並び
</li><li>U+003B 文字（ `;^l ）
</li></ol>

◎
For each character in the entry's name and value that cannot be expressed using the selected character encoding, replace the character by a string consisting of a U+0026 AMPERSAND character (&amp;), a U+0023 NUMBER SIGN character (#), one or more ASCII digits representing the Unicode code point of the character in base ten, and finally a U+003B SEMICOLON character (;).
</li>
</ol>

			</li>
			<li>
<p>
~RET 以下に与える要件の下に，［
`RFC7578$r
<cite>Returning Values from Forms: `~mpFormData^mt</cite>
に述べられる規則
］を用いて，<!-- (now mutated) -->
%~form~data集合 を符号化した結果の~byte-stream
◎
Encode the (now mutated) form data set using the rules described by RFC 7578, Returning Values from Forms: multipart/form-data, and return the resulting byte stream. [RFC7578]
</p>

		<ul>
			<li>
%~form~data集合 内の各 %組 が `field^i を与え，
%組 の
( 名前, 値 )
が
( `field name^i, `field value^i )
を与える。
◎
Each entry in the form data set is a field, the name of the entry is the field name and the value of the entry is the field value.
</li>
			<li>
各~部位の順序は、 %~form~data集合 内の %組 の順序と同じで~MUST。
名前が同じ 複数の %組 は，別個の~fieldとして扱われ~MUST。
◎
The order of parts must be the same as the order of fields in the form data set. Multiple entries with the same name must be treated as distinct fields.
</li>
			<li>
<p>
生成された `~mpFormData$mt 資源の各~部位のうち：
</p>

				<ul>
					<li>
非~file~fieldに対応するものには、
`Content-Type$h ~headerは指定されては~MUST_NOT。
それらの名前と値は、上で選択された符号化方式を用いて符号化され~MUST。
◎
The parts of the generated multipart/form-data resource that correspond to non-file fields must not have a `Content-Type` header specified. Their names and values must be encoded using the character encoding selected above.
</li>
					<li>
~file~fieldに対応するものに含まれる~file名には、上で選択された符号化方式を利用し~MUST
— その精確な名前は，必要とされるなら近似され得る（例えば，名前~内の［
改行文字を除去する ／
引用符を "`%22^c" に変更する ／
選択された符号化方式では表せない文字は他の文字に置換する
］など）。
◎
File names included in the generated multipart/form-data resource (as part of file fields) must use the character encoding selected above, though the precise name may be approximated if necessary (e.g. newlines could be removed from file names, quotes could be changed to "%22", and characters not expressible in the selected character encoding could be replaced by other characters).
</li>
				</ul>
			</li>
		</ul>
<p>
`~mpFormData境界~文字列@
とは、~UAが，この~algoが返す値を生成するときに利用する境界~文字列である。
（この値は、この~algoが生成する ~form提出~payloadの~MIME型を生成するときに利用される。）
◎
The boundary used by the user agent in generating the return value of this algorithm is the multipart/form-data boundary string. (This value is used to generate the MIME type of the form submission payload generated by this algorithm.)
</p>

	</li>
</ol>

<p>
`~mpFormData$mt ~payloadを解釈する方法の詳細は、
`RFC7578$r を見よ。
◎
For details on how to interpret multipart/form-data payloads, see RFC 7578. [RFC7578]
</p>


				</section>
				<section id="plain-text-form-data">
<h4 title="Plain text form data">4.10.22.8. 素の~text~form~data</h4>


<p class="algo-head">
所与の %符号化方式 の下で， %~form~data集合 を
`~textPlainとして符号化-@
する~algoは、次を走らす：
◎
The text/plain encoding algorithm, given a form data set and encoding, is as follows:
</p>

<ol>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
%~charset ~LET %符号化方式 の`名前$enc
◎
Let charset be the name of encoding.
</li>
	<li>
<p>
~FOR
%~form~data集合 内の~EACH( %組 ) に対し：
◎
For each entry in the form data set, perform these substeps:
</p>

		<ol>
			<li>
~IF［
%組 の名前 ~EQ `_charset_$v
］~AND［
%組 の型 ~EQ `hidden^l
］
⇒
%組 の値 ~SET %~charset
◎
If the entry's name is "_charset_" and its type is "hidden", replace its value with charset.
</li>
			<li>
~IF［
%組 の型 ~EQ `file^l
］
⇒
%組 の値 ~SET 値の~file名~~成分
◎
If the entry's type is "file", replace its value with the file's name only.
</li>
			<li>
<p>
次を順に連結した結果を %結果 に付加する：
</p>

<ol><li>%組 の名前
</li><li>1 個の U+003D 文字（ `=^l ）
</li><li>%組 の値
</li><li>~CRLF
</li></ol>

◎
Append the entry's name to result.
◎
Append a single U+003D EQUALS SIGN character (=) to result.
◎
Append the entry's value to result.
◎
Append a U+000D CARRIAGE RETURN (CR) U+000A LINE FEED (LF) character pair to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p>
`~textPlain$mt 形式を利用する~payloadは、人から読まれる用途に意図される。
その形式は多義的なので、~computerからは 依拠可能に解釈できない（例えば、値~内の~literal改行文字と 値の終端にある改行文字を判別する仕方はない）。
◎
Payloads using the text/plain format are intended to be human readable. They are not reliably interpretable by computer, as the format is ambiguous (for example, there is no way to distinguish a literal newline in a value from the newline at the end of the value).
</p>


				</section>
			</section>
			<section id="resetting-a-form">
<h3 title="Resetting a form">4.10.23. ~formの再設定-法</h3>

<p class="algo-head">
`~formを再設定-@
するときは、所与の `form$e 要素 %~form に対し，次を走らせ~MUST：
◎
When a form element form is reset, run these steps:
</p>

<ol>
	<li>
%reset ~LET %~form に向けて、名前 `reset$et の~eventを，［
( `bubbles$m, `cancelable$m ) 属性 ~SET ( ~T, ~T )
］に初期化した上で `発火-$した結果
◎
Let reset be the result of firing an event named reset at form, with the bubbles and cancelable attributes initialized to true.
</li>
	<li>
~IF［
%reset ~EQ ~T
］
⇒
%~form が`所有-$している ~EACH ( `再設定-可能$な %要素 ) に対し
⇒
%要素 の`再設定~algo$を呼出す
◎
If reset is true, then invoke the reset algorithm of each resettable element whose form owner is form.
</li>
</ol>

<p>
各 `再設定-可能$な要素は、自前の
`再設定~algo@
を定義する。
それらの~algoの一部として，~form~controlに加えられた変更は、利用者による変更には数えられない（したがって、例えば `input$et ~eventを発火させることはない）。
◎
Each resettable element defines its own reset algorithm. Changes made to form controls as part of these algorithms do not count as changes caused by the user (and thus, e.g., do not cause input events to fire).
</p>


			</section>

</main>


