<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Browsing the Web（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style type="text/css">
.js, .js-slot, .js-type {
	color: green;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'browsing-the-web',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170608 spec
}

function expand(){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		sc: 'scheme',
		E: 'error',
		dir: 'directive',
		ps: 'pseudo',
		sl: 'js-slot',
		jA: 'abstract',
		jT: 'js-type',
		v: 'value',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		sc: 'code',
		et: 'code',
		E: 'code',
		dir: 'code',
		ps: 'code',
		sl: 'span',
		jA: 'span',
		jT: 'code',
		v: 'code',
		V: 'var',
		i: 'i',
		sub: 'sub',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'bl': // byte literal
	text = '`<code class="literal">' + key + '</code>`';
	break;
case 'h': // HTTP header
	text = '`<code class="header">' + key + '</code>`';
	break;
case 'hm': // HTTP method
	text = '`<code class="method">' + key + '</code>`';
	break;
case 'sc': // url scheme
	text = key.replace(/_/g, ':');
	break;
case 'ps':
	text = ':' + key;
	break;
case 'sl': // JS internal slot
	text = '[[' + key + ']]';
	break;
case 'appCache':
	href = '#_for-app-cache';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2018-01-15
trans_update:2018-01-15
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/browsing-the-web.html
site_nav:browsers,network,html
nav_prev:HISTORY
nav_next:WAPI
trans_1st_pub:2017-01-01

●●original_urls
offline:https://html.spec.whatwg.org/multipage/offline.html

●●words_table



DOM:
HTML:
Web:
browser::::ブラウザ
data::::データ
error::::エラー
flag::::フラグ
mode::::モード
inline::::インライン
link::::リンク
list::::リスト
	-:mark
open:
選択肢:option:~:::オプション
source::::ソース
iframe-srcdoc:iframe srcdoc
	表:~table
timer::::タイマー
token::::トークン
web:
	0:zero
上書き:override:~

CSP:
CSS:
Content-Type:
DNS:
EOF:
ID:
JSON:
	LF
	LINE FEED
MIME:
	PI
PLAINTEXT:
	POST:
Record:
TLS:
UTF-8:
XML:




	●仕様（動詞
依存-:depend:~
依拠-:rely:~
奨励-:encourage:~
	強く:highly
定義-:define:~
定義:definition:~
実装-:implement:~
指定-:specify:~
	unspecified
指示-:indicate:~
挙動:behavior:ふるまい
供-:provide:~
提供-:offer:~
最適化-:optimize:~
望む:wish する:~
決定-:determine:~
無視-:ignore:~
	省略-:omit:~
確保-:ensure:~
確認-:confirm:~
確認:confirmation:~
	（確認を）とる:ask
要求-:require:~
見做せな:assume できな:~
述べる:describe する:~
試みる:attempt する:~
試み:attempt:~
説明-:explain:~
利用-:use:~
再利用-:reuse:~
利用者:user:~
	食い違いが生じる:disagree
影響-:affect:~
意味-:mean:~
意図-:intend:~
拒否-:refuse:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
結付けた:associate した:結び付けた
取扱う:handle する:取り扱う
取扱われ:handle され:取り扱われ
取扱わせ:handle させ:取り扱わせ
	取扱い:handling:取り扱い
	取り扱わせ:hand:~
care::::ケア
検分-:examine:~
究明:investigation:~
言及-:mention:~
注目:attention:~
制御:control:~
含意-:imply:~
判定-:judge:~
予見-:believe:~
	-:defer
相互作用-:interact:~
拡張:extension:~
飛ばさ:skip さ:~
督促-:urge:~
	扱う:treat
	必要-:need
	求め:want
	決め-:decide
	処理を委託:perform 〜 dispatch
	加えて:in addition
	関心を失った:no longer interested in:
	見よ:see
	面した:in the face of
	かいくぐる:evade
	ことにされた:supposed
	ことになった場合:face
	所与の:given

	●仕様
UA:user agent:UA
support::::サポート
tool::::ツール
platform::::プラットフォーム
algo:algorithm:::アルゴリズム
app:application:::アプリ
model::::モデル
custom::::カスタム
	custom化:customize
architecture::::アーキテクチャ
一意:unique:~
不透明:opaque:~
事例:case:~
事由:reason:~
理由:reason:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
作者:author:~
実際:actual:~
実際の:actual:~
	actually
	-:default
歴史的:historical:~
標準:standard:~
特定0の:particular:ある特定の
特色機能:feature:~
状況:situation:~
目的0:purpose:目的
直接的:direct:~
	やりとり:interact:~
通常の:normal な:~
適用-:apply:~
	適用-可能な:applicable:
明示的:explicit:~
暗黙の:implied:~
体験:experience:~
要件:requirements:~
適切:appropriate:~
可用:available:~
問題:problem:~
下位手続き:substeps:~
手続き:steps:~
段:step:~
手動:manual:~
旧来の:legacy:~
旧来:legacy:~
単純:simple:~
汎用:generic:~
特有の:specific な:~
手段:means:~
外部:external:~
外部的:external:~
専用の:dedicated:~
組込みの:built-in:~
未知の:unknown:~
処理能:performance:~
側面:aspect:~
経験則:heuristic:~
自立的:stand-alone:~
在来の:preexisting:~
暗黙的:implicit:~
意味論:semantics:~
独立:independent:~
代替の:alternative:~
正しく:correct に:~
整合的に:consistent manner で:~
用語:term:~
正確:exact:~
課題:issue:~

	決して:never
	必要とされ:necessary
	節:section
	でき:possible
	とは限らない:necessarily
	なければその前に:potentially before
	べき:should
	ほぼ間違いなく:certainly
	他にない:nothing conspires
	任せる:take place:
	例えば:for example
	依然として:still
	具体例として:for instance
	同じものを与える下で:setup
	対になる:for that matter
	特に:specifically
	類似的に:similarly
	いらつく／紛らわしい／的外れである: annoying, deceptive, or pointless
	しかしながら，:however
	したがって:thus
	すでに:already
	そうな:likely

	●network／保安／navi
HTTP:
HTTP_S:HTTP(S) 
HTTPS:
client::::クライアント
download::::ダウンロード
header::::ヘッダ
mail::::メール
message::::メッセージ
payload::::ペイロード
redirect::::リダイレクト
address::::アドレス
cache::::キャッシュ
caching-strategy:caching strategy:::キャッシュ方策
entry::::エントリ
disposition:
status::::ステータス
fetch:
fetching:::fetch 処理
options:::option 集
stream::::ストリーム
service-worker:service worker
URL:
基底:base::~
url:
record::::レコード
host::::ホスト
scheme::::スキーム
navigate::::ナビゲート
	navigating:
navi:navigation:::ナビ
network::::ネットワーク
	~network用:networking
protocol::::プロトコル
referrer::::リファラ
load:
unload:
	~unload法:unloading:
method::::メソッド
本体:body::~::ボディ
部位:part:~
受信-:send:~
	受け取る-:send:~
要請:request::~::リクエスト
応答:response::~::レスポンス
境界:boundary:~
行先:destination::~
資格証:credentials::資格証明情報::クレデンシャル
共用:shared:~
宣言的:declarative:~
refresh:

保安化-:secure に::~:セキュア化
保安:security::~:セキュリティ
session::::セッション
sandbox::::サンドボックス
sandboxing:::sandbox 処理:サンドボックス処理
施策:policy::~:ポリシー
素片:fragment::~::フラグメント
素片除外:exclude fragments::~::フラグメント除外
資源:resource::~:リソース
非冪等:non-idempotent:~
敵対的:hostile:~
指令:directive::~::ディレクティブ
媒体:media::~:メディア
阻止-:block::~::ブロック
阻止ed:Blocked::阻止される::ブロックされる
許容ed:Allowed::許容される
許容-:allow:~
強制的:forcible:~
悪用-:exploit:~
軽減-:mitigate:~
騙す:trick する:~
脆弱性:vulnerability:~
危険:dangerous:~
懸念:concern:~
算出-:compute:~

	●環境 ／ 閲覧
id:
allowX:allow〜
環境:environment:~
大域:global::~::グローバル
設定群:settings:~
現在:currently:~
現在の:current:~
状態:state:~
視野:scope::~::スコープ
関連する:relevant な:~
予約済み:reserved:~
標的:target::~::ターゲット
target:
top-level::::トップレベル
	-:delta
	-:jump
閲覧文脈:browsing context::~
補助:auxiliary::~
閲覧:browsing::~
生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン
破棄-:discard:~

再読込み:reload::再読み込み::リロード
読込まれ:load され::読み込まれ::ロードされ
読込む:load する::読み込む::ロードする
	読込み:loading::読み込み::ローディング
読込:load::読み込み::ロード
	-:component
成熟-:mature:~
所在:location:~
頁:page:::ページ
	走査-:traverse:~
走査する:traverse する::辿る
走査した:traverse した::辿った
走査:traversal::辿り
入子に:nest:入れ子に
入子の:nested:入れ子の
入子に:nest:入れ子に
族:family:~
回復可能:salvageable:~
	回復可能でなくする:unsalvageable:~

閉じる:close する::~
開く:open する::~

要素:element:~
子:child:~
子孫:descendant:~
容器:container:::コンテナ
木:tree::~::ツリー
根:root::~::ルート
文書:document:~

作動中の:active な::~::アクティブな
作動化:activation::~::アクティブ化

履歴:history::~
片付け:cleanup:~
中止-:abort:~
	中止-法:aborting

	●IDL / js / event
handler::::ハンドラ
realm:
Realm:
event-loop:event loop:::イベントループ
event::::イベント
欄:field::~::フィールド
IDL:
JS:JavaScript
call:
catch:
instance::::インスタンス
interface::::インタフェース
listener::::リスナ
	に対する~listenerがある:listen
node::::ノード
obj:object:::オブジェクト
script::::スクリプト
	scripting::::スクリプト処理
task::::タスク
源:source::~::ソース
window::

例外:exception:~
投出-:throw:~
取得-:get:~
取得子:getter:~
設定子:setter:~
	On getting／On setting
呼出す:invoke する:呼び出す
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
呼出して:invoke して:呼び出して
呼出さな:invoke しな:呼び出さな
初期:initial:~
初期化-:initialize:~
初期化:initialization:~

並列的:parallel:~
発火-:fire:~
発火済み:fired:~
配送-:dispatch::~
配送:dispatch::~
queue::::キュー
待機-:wait:~
引数:argument:~
属性:attribute:~
上書target:target override::上書き target


	●UI
UI:user interface:UI
click::::クリック
	右~click:right-click
focus::::フォーカス
form::::フォーム
control::::コントロール
	media::::メディア
modal::::モーダル
plugin::::プラグイン
prompt:
scroll::::スクロール
scrolling::::スクロール処理
	~scroll可能域:scrollable region
title::::タイトル
text::::テキスト
画像:image::~
動画:video::~::ビデオ
音声:audio::~::オーディオ
書字方向性:directionality:~
表示-:display:~
可視性:visibility:~
	制御
逐次的:sequential:~
表示域:viewport::~
疑似類:pseudo-class::疑似 class:疑似クラス
上端:top:~
開始位置:beginning:~
始点:starting point:~
自動充填:autofill:~
layout::::レイアウト

	●未分類（動詞
non-blocking:
合成-:synthesize:~
登録:registration:~
登録-:register:~
登録済みの:registered:~
作成-:create:~
作成時の:creation:~
伝播-:propagate:~
保持-:hold:~
再設定:reset:~:::リセット
未設定:unset:~
処理-:process:~
処理:processing:~
達-:reach:~
変異-:mutate:~
動作-:act:~
動作:action:~
	-:reference
反映-:reflect:~
取消す:cancel する::取り消す::キャンセルする
取消され:cancel され::取り消され::キャンセルされ
	cancelation
	可能化-:enable:~
可能化:enabled:~
不能化-:disable:~
合致-:match:~
変化あり:changed:~
変更-:change:~
失敗-:fail:~
失敗:failure:~
孕まれ:involve され:~
実行-:execute:~
実行:execution:~
復旧-:restore:~
復旧:restoration:~
持続化-:persist:~
持続的な:persisted:~
操作:manipulation:~
更新-:update:~
指名-:designate:~
	-:store
環境設定-:configure:~
	環境設定:configuration:~
生成-:generate:~
表現-:represent:~
設定-:set:~
置換-:replace:~
置換え:replacement:置き換え
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
解析器:parser::~::パーサ
直列化-:serialize::~::シリアル化
直列形の:serialized::~::シリアル形の
符号化方式:encoding::~::エンコーディング
復号-:decode::~::デコード
符号化-:encode::~::エンコード
複製:copy:~
提出:submission::~
提出-:submit::~
表示中:showing:~
評価-:evaluate:~
評価:evaluation:~
確立-:establish:~
終了入子:termination nesting:終了入れ子
成功-:succeed:~
	unsuccessful
停止-:stop:~
継続-:continue:~
記録-:record:~
具現化:rendering::~
具現化-:render::~
変換-:convert:~
変換:conversion:~
報告:report:~
見出せた:find できた:~
見出され:find され:~
見出す:find する:~
誘発-:trigger:~
走らす:run する:~
走らせ:run し:~
起動-:initiate:~
追加-:add:~
付加-:append:~
遂行-:perform:~
遅延:delay:~
	遅延~中:delaying:~
選定-:select:~
関係-:relate:~
開始-:start:~
除去-:remove:~
消滅-:disappear:~
一時停止:pause:~
続行-:proceed:~
埋めた:fill した:~
切替えた:switch した:切り替えた
折返す:wrap する:折り返す
完了-:complete:~

	●未分類
API:
hash:
classic::::クラシック
community::::コミュニティ
computer::::コンピュータ
counter::::カウンタ
fallback::::フォールバック
hyperlink::::ハイパーリンク
id:
level::::レベル
metadata::::メタデータ
percent-::: %-
risk::::リスク
software::::ソフトウェア
stylesheet:style sheet:::スタイルシート
style::::スタイル
view::::ビュー
feed-viewer::::配信ビューア
file::::ファイル
native::::ネイティブ
byte::::バイト
offline::::オフライン
package::::パッケージ
	multipart
tokenizer::::トークン化器
token::::トークン
開始tag:start tag:開始 tag::開始タグ

種別:type:~
抽象演算:abstract operation:~
位置:position:~
値:value:~
入力:input:~
内容:content:~
準備度:readiness:~
即時:immediate:~
既定の:default:~
名:name:~
名前:name:~
型:type:~
下位型:subtype:~
完全:complete:~
情報:information:~
文脈:context:~
新たな:new:~
文字:character:~
文字列:string:~
大小無視:case-insensitive:~
空:empty:~
符号位置:code point:~
名前空間:namespace:~
増分的:incremental:~
整形式性:well-formedness:~
tag::::タグ
規則:rule:~
連続的:contiguous:~
集合:set:~
最近の:latest:~
順序:order:~
識別-:identify:~
素の:plain:~
	syndication feed
同等:equal:~
再帰:recursive:~


●●original_id_map


	number-of-document-tree-child-browsing-contexts:number-of-child-browsing-contexts


●●words_table1


Location:<code>Location</code> 

src-embed:src
src-iframe:src
src-img:src
src-media:src

javascript:<code class="scheme">javascript:</code>


●●link_map



	●idl
E.SecurityError:~WEBIDL#securityerror

I.DOMException:~WEBIDL#idl-DOMException
I.WebSocket:~WEBSOCKET#websocket
I.Document:~HTMLdom#document
I.Element:~DOM4#interface-element
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventSource:~HTMLsse#eventsource
I.History:~HISTORY#history-3
I.WebSocket:~WEBSOCKET#websocket
I.Window:~WINDOW#window
I.WindowProxy:~WINDOW#windowproxy

~window:~WINDOW#the-window-object
文書:~HTMLdom#the-document-object

I.BeforeUnloadEvent:#beforeunloadevent
I.HashChangeEvent:#hashchangeevent
I.HashChangeEventInit:#hashchangeeventinit
I.PageTransitionEvent:#pagetransitionevent
I.PageTransitionEventInit:#pagetransitioneventinit
I.PopStateEvent:#popstateevent
I.PopStateEventInit:#popstateeventinit

m.WebSocket:~WEBSOCKET#dom-websocket
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.document.open:~HTML5/dynamic-markup-insertion.html#dom-document-open
m.document.title:~HTMLdom#dom-document-title
m.history.state:~HISTORY#dom-history-state
m.location.assign:~HISTORY#dom-location-assign
m.newURL:#dom-hashchangeevent-newurl
m.oldURL:#dom-hashchangeevent-oldurl
m.persisted:#dom-pagetransitionevent-persisted
m.preventDefault:~DOM4#dom-event-preventdefault
m.pushState:~HISTORY#dom-history-pushstate
m.replaceState:~HISTORY#dom-history-replacestate
m.returnValue:#dom-beforeunloadevent-returnvalue
m.state:#dom-popstateevent-state
m.type:~DOM4#dom-event-type
m.window.open:~WINDOW#dom-window-open
m.opener:~BROWSERS#dom-window-opener

l.auto:~HISTORY#dom-scrollrestoration-auto
l.manual:~HISTORY#dom-scrollrestoration-manual


m.WebSocket:~WEBSOCKET#dom-websocket
m.document.open:~HTML5/dynamic-markup-insertion.html#dom-document-open
m.state:#dom-popstateevent-state
m.oldURL:#dom-hashchangeevent-oldurl
m.newURL:#dom-hashchangeevent-newurl
m.persisted:#dom-pagetransitionevent-persisted
m.returnValue:#dom-beforeunloadevent-returnvalue

m.type:~DOM4#dom-event-type
m.cancelable:~DOM4#dom-event-cancelable

et.abort:~HTMLindex#event-abort
et.beforeunload:~HTMLindex#event-beforeunload
et.hashchange:~HTMLindex#event-hashchange
et.load:~HTMLindex#event-load
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow
et.popstate:~HTMLindex#event-popstate
et.unload:~HTMLindex#event-unload

e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.title:~HEmetadata#the-title-element
e.body:~HEsections#the-body-element
e.a:~HEtextlevel#the-a-element
e.input:~HEinput#the-input-element
e.textarea:~HEforms#the-textarea-element

e.img:~HEimages#the-imge-element
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.audio:~HEmedia#the-audio-element
e.video:~HEmedia#the-video-element

a.autoplay:~HEmedia#attr-media-autoplay
a.dir:~HTMLdom#the-dir-attribute
a.href:~HTMLlinks#attr-hyperlink-href
a.name:~HTMLobs#attr-a-name
a.type:~HEinput#attr-input-type
a.~src-embed:~HEembed#attr-embed-src
a.~src-iframe:~HEembed#attr-iframe-src
a.~src-img:~HEimages#attr-img-src
a.~src-media:~HEmedia#attr-media-src

sc.about_blank:~HTMLdep#about:blank
sc.mailto_:~IETF/rfc6068#section-2
	sc.javascript_:#javascript-protocol
~javascript~URL:#javascript-protocol
	l.javascript:#javascript-protocol


c.application/atom+xml:~HTMLindex#application/atom+xml
c.application/json:~HTMLindex#application/json
c.multipart/x-mixed-replace:~HTML5/iana.html#multipart/x-mixed-replace
c.text/cache-manifest:~HTML5/iana.html#text/cache-manifest
c.text/css:~HTMLindex#text/css
bl.text/html:~HTML5/iana.html#text/html
c.text/json:~HTMLindex#text/json
c.text/plain:~IETF/rfc2046#section-4.1.3
c.text/vtt:~HTMLindex#text/vtt

h.Content-Disposition:~IETF/rfc6266
h.Referrer-Policy:~REFERRER-POLICY#referrer-policy-header-dfn
	https://w3c.github.io/webappsec-referrer-policy/#referrer-policy-header-dfn
h.Refresh:~HTML5/iana.html#refresh

v.off:~HTMLautofill#attr-fe-autocomplete-off
ps.target:~HTMLselectors#selector-target

非~文書~内容として取扱う:#navigate-non-Document

	●用語
なければその前に:#_potentially-before

~source閲覧文脈:#source-browsing-context
V.S:#source-browsing-context
V.B:#_target-browsing-context
~navigate:#navigate
~navi:#navigate
~navigate応答を処理する:#process-a-navigate-response
~navigate~fetchを処理する:#process-a-navigate-fetch
~navigate~URL~schemeを処理する:#process-a-navigate-url-scheme
自己~naviを明示的に上書き:#explicit-self-navigation-override
素片へ~navigateする:#scroll-to-fragid
素片へ~scroll:#scroll-to-the-fragment-identifier

~JSON~MIME型:#json-mime-type
履歴を走査する:#traverse-the-history
~entryを更新する:#entry-update
明示的に~supportされる~JSON型:#explicitly-supported-json-type
明示的に~supportされる~XML型:#explicitly-supported-xml-type

成熟-:#concept-navigate-mature
~plugin文書:#plugin-document
上書き~URL:#override-url
標的~要素:#target-element
終了入子~level:#termination-nesting-level

doc.指示された部位:#the-indicated-part-of-the-document
指示された要素を見出す:#find-a-potential-indicated-element
doc.~unload発火済み~flag:#fired-unload
doc.頁~表示中~flag:#page-showing
doc.回復可能~状態:#concept-document-salvageable

doc.中止-:#abort-a-document
doc.初期化-:#initialise-the-document-object
doc.~addressを設定-:#set-the-document's-address
	'
doc.~unload:#unload-a-document
doc.~unloadを~prompt:#prompt-to-unload-a-document
doc.~unloadを拒否-:#refused-to-allow-the-document-to-be-unloaded
doc.~unload時の片付け手続き:#unloading-document-cleanup-steps
doc.~unload中の文書の可視性を変更する手続き:#unloading-document-visibility-change-steps

新たな頁で~session履歴を更新-:#update-the-session-history-with-the-new-page
~session履歴~文書の可視性を変更する手続き:#session-history-document-visibility-change-steps
置換え可能化~flag:#replacement-enabled
例外~可能化~flag:#exceptions-enabled
再読込みから誘発された:#reload-triggered-navigation
持続的な利用者~状態を復旧-:#restore-persisted-user-state
~inline内容を表示する:#read-ua-inline

	#read-html
	#read-xml
	#read-plugin
	#read-media
	#read-text
	#hand-off-to-external-software
	#hand-off-to-external-software
	~HISTORY#history-notes
	#navigate-fragid-step
	#navigate-redirect-step
	#read-multipart-x-mixed-replace


	●BROWSERS
閲覧文脈:~BROWSERS#browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
子~閲覧文脈:~BROWSERS#child-browsing-context
子孫~閲覧文脈~list:~BROWSERS#list-of-the-descendant-browsing-contexts
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-context
入子にして:~BROWSERS#browsing-context-nested-through
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
閲覧文脈~容器:~BROWSERS#browsing-context-container
閲覧文脈~名:~BROWSERS#browsing-context-name
閲覧文脈~視野~生成元:~BROWSERS#browsing-context-scope-origin
~load~event遅延~中~mode:~BROWSERS#delaying-load-events-mode
作動中の文書:~BROWSERS#active-document
作動中の文書を設定する:~BROWSERS#set-the-active-document
~navigateは許容されて:~BROWSERS#allowed-to-navigate
作成-:~BROWSERS#creating-a-new-browsing-context
文書~族:~BROWSERS#document-family

~window用に環境~設定群~objを設定して:~WINDOW#set-up-a-window-environment-settings-object
結付けられている文書:~WINDOW#concept-document-window
doc.破棄-:~WINDOW#discard-a-document

持続的な利用者~状態:~HISTORY#an-entry-with-persisted-user-state
~session履歴:~HISTORY#session-history
~session履歴~entry:~HISTORY#session-history-entry
履歴を前／後に走査する:~HISTORY#traverse-the-history-by-a-delta
現在の~entry:~HISTORY#current-entry
最近の~entry:~HISTORY#latest-entry
直列形の状態:~HISTORY#serialized-state
~scroll復旧~mode:~HISTORY#scroll-restoration-mode

生成元:~ORIGIN#concept-origin
同一生成元:~ORIGIN#same-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
~sandboxingを実装する:~ORIGIN#implement-the-sandboxing
作動中の~sandbox用~flag集合:~ORIGIN#active-sandboxing-flag-set
~sandbox化( ~modal )~flag:~ORIGIN#sandboxed-modals-flag
閲覧文脈~sandbox化( ~plugin )~flag:~ORIGIN#sandboxed-plugins-browsing-context-flag

sl.Window:~WINDOW#concept-windowproxy-window


	●HTMLINFRA
~Content-Type~metadata:~HTMLurl#content-type
型~情報:~HTMLurl#content-type
	相対的に構文解析-:~HTMLurl#resolve-a-url
	結果の~URL~record:~HTMLurl#resulting-url-record
	~scheme~data:~HTMLurl#concept-url-scheme-data

	~HTML文書:~HTMLINFRA#html-documents
即時に:~HTMLINFRA#immediately
並列的に:~HTMLINFRA#in-parallel
文書~内に挿入され:~HTMLINFRA#insert-an-element-into-a-document
~plugin:~HTMLINFRA#plugin
保安化-:~HTMLINFRA#concept-plugin-secure
~target上書き:~HTMLINFRA#concept-event-target-override
適用-可能な仕様:~HTMLINFRA#other-applicable-specifications



	●WAPI
関連する設定群~obj:~WAPI#relevant-settings-object
関連する大域~obj:~WAPI#concept-relevant-global
~DOM操作~task源:~WAPI#dom-manipulation-task-source
~event-loop:~WAPI#event-loop
~event-loopを回す:~WAPI#spin-the-event-loop
~task:~WAPI#concept-task
~task~queue:~WAPI#task-queue
~task源:~WAPI#task-source
~taskを~queueする:~WAPI#queue-a-task
~queueする:~WAPI#queue-a-task
~taskを~queueし:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
環境~設定群~obj:~WAPI#environment-settings-object
大域~obj:~WAPI#global-object
履歴~走査~task源:~WAPI#history-traversal-task-source
~network用~task源:~WAPI#networking-task-source
~script:~WAPI#concept-script
~scriptingが不能化されている:~WAPI#concept-bc-noscript
~scriptは不能化され:~WAPI#concept-bc-noscript
一時停止-:~WAPI#pause
~classic~scriptを作成する:~WAPI#creating-a-classic-script
~classic~scriptを走らす:~WAPI#run-a-classic-script
既定の~classic~script~fetch~options:~WAPI#default-classic-script-fetch-options

環境:~WAPI#environment
enV.~HTTPS状態:~WAPI#https-state
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.~id:~WAPI#concept-environment-id
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
enV.作動中の~service-worker:~WAPI#concept-environment-active-service-worker
enV.~API用~基底~URL:~WAPI#api-base-url

~unload中の~openは無視する~counter:~HTMLGAPI#ignore-opens-during-unload-counter
登録済みの~handler:~HTMLnavigator#dom-navigator-registerprotocolhandler


	●FETCH
~fetch~scheme:~FETCH#fetch-scheme
~HTTP_S~scheme:~FETCH#http-scheme
~fetch:~FETCH#concept-fetch
~HTTP~redirect~fetch:~FETCH#concept-http-redirect-fetch
~ok~status:~FETCH#ok-status
~header~list:~FETCH#concept-header-list
応答を処理-:~FETCH#process-response
要請:~FETCH#concept-request
~network~error:~FETCH#concept-network-error
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.~client:~FETCH#concept-request-client
rq.~referrer:~FETCH#concept-request-referrer
rq.~method:~FETCH#concept-request-method
rq.~mode:~FETCH#concept-request-mode
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.~target~client~id:#concept-request-target-client-id
rq.~target閲覧文脈:~FETCH#concept-request-target-browsing-context
rq.~url:~FETCH#concept-request-url
rq.予約済み~client:~FETCH#concept-request-reserved-client
rq.生成元:~FETCH#concept-request-origin
rq.行先:~FETCH#concept-request-destination
rq.資格証~mode:~FETCH#concept-request-credentials-mode

応答:~FETCH#concept-response
rs.~HTTPS状態:~FETCH#concept-response-https-state
rs.所在~URL:~FETCH#concept-response-location-url
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.~status:~FETCH#concept-response-status

	●他HTML

doc.~referrer施策:~HTMLdom#concept-document-referrer-policy
doc.~HTTPS状態:~HTMLdom#concept-document-https-state
doc.~referrer:~HTMLdom#the-document's-referrer
	'
作動中の構文解析器:~HTMLdom#active-parser
上書きされる再読込み:~HTMLdom#an-overridden-reload
現在の文書の準備度:~HTMLdom#current-document-readiness

共用~宣言的~refresh手続き:~HEmetadata#shared-declarative-refresh-steps

~JS~MIME型:~HTMLscript#javascript-mime-type
消滅させる:~WEBSOCKET#make-disappear
強制的に閉じる:~HTMLsse#concept-eventsource-forcibly-close

~HTML構文解析器:~HTMLparsing#html-parser
~PLAINTEXT状態:~HTMLparsing#plaintext-state
構文解析器を中止する:~HTMLparsing#abort-a-parser
~HTML構文解析器~内で:~HTMLparsing#parser-appcache
入力~byte~stream:~HTMLparsing#the-input-byte-stream
構文解析を停止した:~HTMLparsing#stop-parsing
停止-:~HTMLparsing#stop-parsing
~tokenizer:~HTMLparsing#tokenization

st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)

~objを~focusする:~HTMLinteraction#focusing-steps
逐次的~focus~naviの始点:~HTMLinteraction#sequential-focus-navigation-starting-point
利用者による作動化により誘発され:~HTMLinteraction#triggered-by-user-activation

~XML構文解析器:~HTMLxml#xml-parser
~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document
	内容を具現化するのに失敗する:~HEembed#sandboxPluginEmbed
~allowX~flagを設定する:~HEembed#set-the-allow*-flags

~form提出:~HTMLforms#concept-form-submit
再設定~algo:~HTMLforms#concept-form-reset-control
自動充填~欄~名:~HTMLautofill#autofill-field-name

~downloadとして:~HTMLlinks#as-a-download
~hyperlinkを追う:~HTMLlinks#following-hyperlinks-2
具現化されて:~HTMLrendering#being-rendered
作動中の~timer~list:~HTMLGAPI#list-of-active-timers


	●他
sub.大小無視:~INFRA#ascii-case-insensitive

木~順序:~DOM4#concept-tree-order
~ID:~DOM4#concept-id
doc.内容~型:~DOM4#concept-document-content-type
doc.種別:~DOM4#concept-document-type
doc.~URL:~DOM4#concept-document-url
doc.文字~符号化方式:~DOM4#concept-document-encoding
	~HTMLdep#document's-character-encoding
 '
木~内:~DOM4#in-a-document-tree
~eventを作成-:~DOM4#concept-event-create
配送-:~DOM4#concept-event-dispatch
~eventを発火-:~DOM4#concept-event-fire
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element

~URLを直列化する:~URL1#concept-url-serializer
~URL:~URL1#concept-url
~byte列を~byte列に~percent-復号する:~URL1#percent-decode
文字列を~byte列に~percent-復号する:~URL1#string-percent-decode
url.素片:~URL1#concept-url-fragment
url.~scheme:~URL1#concept-url-scheme
url.同等:~URL1#concept-url-equals
~URL~record:~URL1#concept-url

~UTF-8復号する:~ENCODING#utf-8-decode
BOMも失敗-もそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom-or-fail


疑似類:~SELECTORS4#pseudo-class
表示域:~CSS2VISUREN#viewport
~viewの中へ~scrollする:~CSSOMVIEW#scroll-an-element-into-view
開始位置へ~scroll:~CSSOMVIEW#scroll-to-the-beginning-of-the-document

~HTML~MIME型:~MIMESNIFF#html-mime-type
~MIME型:~MIMESNIFF#mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
算出される~MIME型:~MIMESNIFF#computed-mime-type
V.資源から算出された~MIME型:#_computed-mime-type

文書の~CSP~listを初期化する:~CSP3#initialize-document-csp
~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？:~CSP3#should-block-navigation-request
~sourceから~targetを~navigateするある種別の要請に対する応答は~CSPにより阻止されるべきか？:~CSP3#should-block-navigation-response

jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
jA.InitializeHostDefinedRealm():~TC39#sec-initializehostdefinedrealm
jA.Type:~TC39#sec-ecmascript-data-types-and-values
現在の~Realm~Record:~TC39#current-realm
~JS実行~文脈:~TC39#sec-execution-contexts
~JS実行~文脈を走らす:~TC39#running-execution-context


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
Loading Web pages 章の
<a href="~SPEC_URL">Browsing the Web</a>
節を日本語に翻訳したものです。
~PUB
</p>

</script>

<!--% 他の語
利用-:use
含-:include
含めて:including
対応:corresponding
対応付ける:map する
常に:always
得-:obtain
引く:brought
待たれる:pending
引用用の:quoting
	成す:comprise
時間長:amount of time
消え去る:going away
渡-:pass
生-:occur
発した:emit
知-:know
示す:show
終え:finish:
起こる:happen
返す:return
選ぶ:choose
間に挟む:intervening
除-:except
~GOTO:step labeled
-:parameter
Atom
seamless:
time:
word processor
~unload中の~openは無視する:ignore-opens-during-unload
戻-:back
結果:result
結果を得る:dereference
通:through

	●指示語
aforementioned
~~真の:real
新たに:newly
続けて:in a row
間:between
代わりに:instead
いくつかの:several
これらの:these
すべての:all
その:that
そのような:such
それら:they
それらの:their
それらの:those
まるごと:altogether
一部:part of
上:above
下:below
両者／両:both
他の:other
他の場合:otherwise
以前の:previous
元々:originally
元の:original
先頭の:leading
前:before
後:after
前もって:prior
前／後:back or forwards
後に:later
後続-:follow:~
各:each
同じ:same
早期の:earlier
最初の:first
最後の:last
最終的に:eventual
更なる:further
最初にin the first place
異なる:different
種々の:various
箇所 place
自身:itself
複数の:multiple
:two
ある種の:certain
何らかの:some sort of
1 個の:single:~

 -->


<body>

<header>
	<hgroup>
<h1 title="Browsing the Web">7.8. Web の閲覧</h1>
	</hgroup>

</header>

<hr>

<main id="MAIN" style="display:none;">

		<section id="browsing-the-web">
<h2 title="Browsing the Web">7.8. ~webの閲覧</h2>

			<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, 此れ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

			</section>
			<section id="navigating-across-documents">
<h3 title="Navigating across documents">7.8.1. 文書から文書へ~navigateするとき</h3>

<p>
ある種の動作は、`閲覧文脈$を新たな資源へ`~navigate$させる。
~UAは、この仕様に定義されるそれに加えて，利用者に閲覧文脈を明示的に~navigateさせる種々の仕方を供して~MAY。
◎
Certain actions cause the browsing context to navigate to a new resource. A user agent may provide various ways for the user to explicitly cause a browsing context to navigate, in addition to those defined in this specification.
</p>

<p class="example">
例えば 次のものは、閲覧文脈を~navigateさせ得る
⇒
`~hyperlinkを追う$,
`~form提出$,
`window.open()$m ~method,
`location.assign()$m ~method。
◎
For example, following a hyperlink, form submission, and the window.open() and location.assign() methods can all cause a browsing context to navigate.
</p>

<p class="note">注記：
`資源^i は，~URLを持つが、それのみが資源を識別するために必要とされる情報とは限らない。
例えば、~HTTP `POST^hm を利用する~form提出は、［
~HTTP~method, ~payload
］も情報として有することになる。
類似的に，`~iframe-srcdoc文書$は、自身が利用する~dataを知る必要がある。
◎
A resource has a URL, but that might not be the only information necessary to identify it. For example, a form submission that uses HTTP POST would also have the HTTP method and payload. Similarly, an iframe srcdoc document needs to know the data it is to use.
</p>

<p>
`~navi$には常に、
`~source閲覧文脈@
と呼ばれる，それを開始させる責を負っていた`閲覧文脈$が孕まれる。
◎
Navigation always involves source browsing context, which is the browsing context which was responsible for starting the navigation.
</p>

<p class="trans-note">【
すなわち，`~navi$は、~source閲覧文脈を明示的に与えずに呼出されることもあるが、その場合でも，~source閲覧文脈は その箇所の文脈から暗黙的に決定される。
】</p>

<p class="XXX">
<a href="https://github.com/whatwg/html/issues/1130">issue #1130</a> にて説明されるように，~sourceとしての閲覧文脈の利用は、正しい~architectureとは言えないかもしれない。
◎
As explained in issue #1130 the use of a browsing context as source might not be the correct architecture.
</p>


<div>

<p class="algo-head">
閲覧文脈を資源へ
`~navigate@
する~algoは、次を入力にとり，以下を走らせ~MUST：
</p>

<ul><li>`S$V （`~source閲覧文脈$）
</li><li>%B （~navigateされる`閲覧文脈$）
</li><li>%資源 （~navigate先とされる資源または その~URL）
</li><li>`例外~可能化~flag@ （省略時は ~OFF）
</li><li>`置換え可能化~flag$ （省略時は ~OFF）
</li></ul>


<p class="trans-note">【
以下，この節を通して、記号 `S$V, %B は，順に［
`~source閲覧文脈$, ~navigateされる`閲覧文脈$
］を意図して与えられている入力を表す。
これらは同じ閲覧文脈を指す場合もある。
】【
`置換え可能化~flag$は，原文には明示的に記されていないが、この~algoを呼出している一部の箇所から，入力として与えられている。
】</p>

◎
To navigate a browsing context browsingContext to a resource resource, optionally with an exceptions enabled flag, the user agent must run these steps:
</div>


<ol>
	<li>
%~navi ~LET この`~navi$~algoの~instance
◎
↓</li>
	<li>
~IF［
%資源 は`~URL$である
］
⇒
%資源 ~SET 次のようにされた 新たな`要請$
⇒
`~url$rq ~SET %資源
◎
If resource is a URL, then set resource to a new request whose url is resource.
</li>
	<li id="sandboxLinks">
<p>
~IF［
`S$V には， %B に対する`~navigateは許容されて$いない
］：
◎
If the source browsing context is not allowed to navigate browsingContext, then:
</p>

		<ol>
			<li>
~IF［
`例外~可能化~flag$ ~EQ ~ON
］
⇒
~THROW `SecurityError$E
◎
If the exceptions enabled flag is set, then throw a "SecurityError" DOMException.
</li>
			<li>
<p>
~ELSE
⇒
~UAは［
新たな, または `S$V の `~top-level閲覧文脈$
］内に %資源 を開くような選択肢を利用者に提供して~MAY
— その事例では、~UAは、利用者から指名された`~top-level閲覧文脈$を，利用者がそれを独立に要請したかのように %資源 へ`~navigate$し~MUST。
◎
Otherwise, the user agent may instead offer to open resource in a new top-level browsing context or in the top-level browsing context of the source browsing context, at the user's option, in which case the user agent must navigate that designated top-level browsing context to resource as if the user had requested it independently.
</p>

<p class="note">注記：
しかしながら，そうすることは、危険にもなり得る
— それは、利用者が［
作者による，内容を~sandbox化する明示的な要請
］を上書きすることを意味するので。
◎
Doing so, however, can be dangerous, as it means that the user is overriding the author's explicit request to sandbox the content.
</p>

<p class="trans-note">【
選択肢を提供しない場合、（原文の “instead” を “`SecurityError^E の代わりに” と解釈するならば）最初の段と同じく `SecurityError$E になると思われるが，はっきりしない。
】</p>

			</li>
		</ol>
	</li>
	<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
	<li>
<p>
~IF［
次のいずれも満たすような，［
%B を~navigateしようとする在来の %試み
］がある
］…：
</p>

<ul><li>%試み における`~source閲覧文脈$ ~EQ %B
</li><li>%試み は 文書を`~unload$docする~algoを現在~走らせている
</li></ul>

<p>
…ならば
⇒
~RET
— %試み やそれが走らせている~algoは、影響されない。
</p>

◎
If there is a preexisting attempt to navigate browsingContext, and the source browsing context is the same as browsingContext, and that attempt is currently running the unload a document algorithm, then return without affecting the preexisting attempt to navigate browsingContext.
</li>
	<li>
~IF［
%文書 に対し，その`~unloadを~prompt$docする~algoが走っている
］
⇒
~RET
— その~algoは、影響されない。
◎
If the prompt to unload algorithm is being run for the active document of browsingContext, then return without affecting the prompt to unload algorithm.
</li>
	<li id="navigate-fragid-step">
<p>
~IF［
%~navi は
`再読込みから誘発された@
ものではない
］~AND［
%資源 は`要請$である
］：
</p>
		<ol>
			<li>
%~URL ~LET %資源 の`~url$rq
</li>
			<li>
~IF［
( %~URL, %文書 の`~URL$doc ) は［
%素片除外~flag ~SET ~ON
］の下で`同等$url
］
⇒
~IF［
%~URL の`素片$url ~NEQ ~NULL
］
⇒＃
`素片へ~navigateする$( %B, %~URL, `置換え可能化~flag$ )；
~RET
</li>
		</ol>
◎
If this is not a reload-triggered navigation, resource is a request, resource's url equals browsingContext's active document's URL with exclude fragments flag set, and resource's url's fragment is non-null, then navigate to that fragment, with replacement enabled if this was invoked with replacement enabled, and return.
</li>
	<li>
<p>
%B を~navigateしようとする在来の ~EACH ( %試み ) に対し：
</p>
		<ol>
			<li>
~IF［
%試み はすでに`成熟-$している
］
⇒
~CONTINUE
</li>
			<li>
%試み を取消す
— %試み により開始された`~fetch$ ~algoの~instanceも含めて
</li>
			<li>
~IF［
%試み は，すでに新たな`文書$を作成して`初期化-$docした
］
⇒
その文書を`中止-$docする
</li>
		</ol>

<p>
（`成熟-$した %試み に対しては、`~session履歴~entry$がすでにあるので，後で`新たな頁で~session履歴を更新-$する~algoの中で取扱われる。）
</p>

◎
Cancel any preexisting but not yet mature attempt to navigate browsingContext, including canceling any instances of the fetch algorithm started by those attempts. If one of those attempts has already created and initialized a new Document object, abort that Document also. (Navigation attempts that have matured already have session history entries, and are therefore handled during the update the session history with the new page algorithm, later.)
</li>
	<li>
<p>
%文書 の`~unloadを~prompt$docする
⇒
~IF［
利用者は文書の`~unloadを拒否-$docした
］
⇒
~RET
◎
Prompt to unload the active document of browsingContext. If the user refused to allow the document to be unloaded, then return.
</p>

<p>
この段を走らせている間に %~navi が取消されたとしても、`~unloadを~prompt$docする~algoは，完了され~MUST。
◎
If this instance of the navigation algorithm gets canceled while this step is running, the prompt to unload algorithm must nonetheless be run to completion.
</p>
	</li>
	<li>
%文書 を`中止-$docする
◎
Abort the active document of browsingContext.
</li>
	<li>
<p>
~IF［
%B は`入子の閲覧文脈$である
］
⇒
%B を`~load~event遅延~中~mode$にする
◎
If browsingContext is a nested browsing context, then put it in the delaying load events mode.
</p>

<p>
~UAは、後に， %~navi が［
`成熟-$した ／ 
すべて走らせ終えた ／
取消された ／
中止された
］時点
— いずれかが最初に生じた時点 —
で， %B を`~load~event遅延~中~mode$から外さ~MUST。
◎
The user agent must take this nested browsing context out of the delaying load events mode when this navigation algorithm later matures, or when it terminates (whether due to having run all the steps, or being canceled, or being aborted), whichever happens first.
</p>

	</li>
	<li>
%~navi種別 ~LET ［
%~navi は`~form提出$~algoの結果として呼出されたならば `form-submission^l ／
~ELSE_ `other^l
］
◎
Let navigationType be "form-submission" if the navigation algorithm was invoked as a result of the form submission algorithm, and "other" otherwise.
</li>
	<li>
~RET
— ただし、以降の手続きは`並列的に$継続する。
それは、必要とされるなら %資源 を得ようと試みる。
◎
Return to whatever algorithm invoked the navigation steps and continue running these steps in parallel.
◎
This is the step that attempts to obtain resource, if necessary. Jump to the first appropriate substep:
</li>
	<li>
<p>
~IF［
%資源 は`応答$である
］：
</p>

<ol><li>`~navigate応答を処理する$( ~NULL, %資源, %~navi種別, `S$V, %B )
</li><li>~RET
</li></ol>
◎
If resource is a response
◎
Run process a navigate response with null, resource, navigationType, the source browsing context, and browsingContext, and then return.
</li>
	<li>
~Assert：
%資源 は`要請$である
【この段と次の段は訳者による追加。】
◎
↓</li>
	<li>
%要請 ~LET %資源
【これは以下を読み易くするための単なる名称変更。】
◎
↓</li>
	<li>
%~url ~LET %要請 の`~url$rq
◎
↓</li>
	<li>
%~scheme ~LET %~url の`~scheme$url
◎
↓</li>
	<li>
<div class="p">
<p>
~IF［
%~scheme ~EQ `javascript^l
］
⇒
<!-- ＊%文書 に結付けらている -->
`~javascript~URL$手続きを走らす`~taskを~queueする$
</p>

<p>
`~javascript~URL@
手続きは、次を走らす：
</p>

◎
If resource is a request whose url's scheme is "javascript"
◎
Queue a task to run these "javascript: URL" steps, associated with the active document of browsingContext:
</div>


				<ol id="concept-js-deref">
					<li>
%結果 ~LET `undefined^c
◎
↓</li>
					<li>
<p>
~IF［
次の両者とも満たされる
］…：
◎
Let result be undefined, and jump to the step labeled process result below if either of the following are true:
</p>
						<ul>
							<li>
<p>
( `S$V にて`作動中の文書$の`生成元$, %文書 の`生成元$ )
は`同一生成元$である
◎
The source browsing context's active document's origin is not the same origin as browsingContext's active document's origin.
</p>

<p class="XXX">
<a href="https://github.com/whatwg/html/issues/2591">issue #2591</a>
にて説明されるように、この段は働かないため，保安~上の課題がある。
◎
As explained in issue #2591 this step does not work and presents a security issue.
</p>
							</li>
							<li>
`~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？$
( %要請, `other^l, `S$V, %B )
の結果 ~EQ `許容ed^i
`CSP$r
◎
The Should navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon resource, "other", the source browsing context, and browsingContext. [CSP]
</li>
						</ul>
<p>
…ならば：
</p>
						<ol>
							<li>
%~url文字列 ~LET `~URLを直列化する$( %~url )
の結果から先頭の `javascript:^l を除去した結果
◎
Let urlString be the result of running the URL serializer on resource's url.
◎
Remove the leading "javascript:" string from urlString.
</li>
							<li>
%~script~source ~LET `~byte列を~byte列に~percent-復号する$( %~url文字列 )
【`文字列を~byte列に~percent-復号する$？】
◎
Let script source be the result of applying the percent decode algorithm to urlString.
</li>
							<li>
%~script~source ~LET `~UTF-8復号する$( %~script~source )
◎
Replace script source with the result of applying the UTF-8 decode algorithm to script source.
</li>
							<li>
%設定群 ~LET %文書 に`関連する設定群~obj$
◎
Let address be the URL of the active document of browsingContext.
◎
Let settings be the relevant settings object for the active document of browsingContext.
</li>
							<li>
%基底~URL ~LET %設定群 の`~API用~基底~URL$enV
◎
Let base URL be settings object's API base URL.
</li>
							<li>
%~script ~LET
`~classic~scriptを作成する$(
%~script~source,
%設定群,
%基底~URL,
`既定の~classic~script~fetch~options$
)
◎
Let script be the result of creating a classic script given script source, settings, base URL, and the default classic script fetch options.

 and settings.
</li>
							<li>
`~classic~scriptを走らす$( %~script )
⇒
%結果 ~LET ［
その評価が成功したならば その評価-結果 ／
~ELSE_（ `~scriptは不能化され$ている場合も含む） `undefined^c
］
◎
Let result be the result of running the classic script script. If evaluation was unsuccessful, let result be undefined instead. (The result will also be undefined if scripting is disabled.)
</li>
						</ol>
					</li>
					<li>
%応答 ~LET 新たな`応答$
◎
Let response be null.
</li>
					<li>
~IF［
`Type$jA( %結果 ) ~NEQ `String^jT
］
⇒
%応答 の`~status$rs ~SET `204^c
◎
Process result: If Type(result) is not String, then set response to a response whose status is 204.
</li>
					<li>
<div class="p">
<p>
~ELSE：
</p>

<ol ><li>
<p>
%応答 の`~header~list$rs ~SET 次の~headerからなる`~header~list$：
</p>
	<ul ><li>( `Content-Type^h / `text/html$bl )
	</li><li>( `Referrer-Policy$h / %設定群 の`~referrer施策$enV )
	</li></ul>
</li><li>%応答 の`本体$rs ~SET %結果†
</li><li>%応答 の`~HTTPS状態$rs ~SET %設定群 の`~HTTPS状態$enV
</li></ol>

◎
Otherwise, set response a response whose header list consists of `Content-Type`/`text/html` and `Referrer-Policy`/settings's referrer policy, whose body is result, and whose HTTPS state is settings's HTTPS state.
</div>

<p class="warning">†
~JS文字列 %結果 と応答の`本体$rsを成す~byte列との間の正確な変換は、まだ指定されていない。
~UAの挙動が更に究明されるのが待たれる。
<a href="https://github.com/whatwg/html/issues/1129">issue #1129</a>
を見よ。
◎
The exact conversion between the JavaScript string result and the bytes that comprise a response body is not yet specified, pending further investigation into user agent behavior. See issue #1129.
</p>

<p>
文書の`~addressを設定-$docするときが来たときは、`上書き~URL$に %文書 の`~URL$を利用する
◎
When it comes time to set the document's address, use address as the override URL.
</p>

					</li>
					<li>
`~navigate応答を処理する$( %要請, %応答, %~navi種別, `S$V, %B )
◎
Run process a navigate response with resource, response, navigationType, the source browsing context, and browsingContext,＼
</li>
					<li>
~RET
◎
and then return.
</li>
				</ol>
<p>
この`~task$の`~task源$は、`~DOM操作~task源$とする。
◎
The task source for this task is the DOM manipulation task source.
</p>

<div class="example">
よって，例えば `a$e 要素の `href$a 属性に対する`~javascript~URL$が評価されるのは、その`~hyperlinkを追う$ときに限られることになる。
一方で、 `iframe$e 要素 %E の `~src-iframe$a 属性における その種の~URLは、
%E が設定しておかれるときに， %E が`入子にしている閲覧文脈$ %C の文脈~下で評価され、結果の返り値が文字列であったなら， %C の`文書$を置換する（したがって %C の`~window$も変更する）ことになる。
◎
So for example a javascript: URL in an href attribute of an a element would only be evaluated when the link was followed, while such a URL in the src attribute of an iframe element would be evaluated in the context of the iframe's own nested browsing context when the iframe is being set up; once evaluated, its return value (if it was a string) would replace that browsing context's Document, thus also changing the Window object of that browsing context.
</div>
	</li>
	<li>
~ELIF …
【`~app~cache関連の条件と処理$appCache】
◎
If resource is to be fetched using `GET`, and there are relevant application caches that are identified by a URL with the same origin as the URL in question, and that have this URL as one of their entries, excluding entries marked as foreign, and whose mode is fast, and the user agent is not in a mode where it will avoid using application caches
◎
• Fetch resource from the most appropriate application cache of those that match.
◎
For example, imagine an HTML page with an associated application cache displaying an image and a form, where the image is also used by several other application caches. If the user right-clicks on the image and chooses "View Image", then the user agent could decide to show the image from any of those caches, but it is likely that the most useful cache for the user would be the one that was used for the aforementioned HTML page. On the other hand, if the user submits the form, and the form does a POST submission, then the user agent will not use an application cache at all; the submission will be made to the network.
◎
This still needs to be integrated with the Fetch standard. [FETCH]
</li>
	<li>
~ELIF［
%~scheme ~IN { `~fetch~scheme$ }
］
⇒
`~navigate~fetchを処理する$( %要請, `S$V, %B, %~navi種別 )
◎
If resource is a request whose url's scheme is a fetch scheme
◎
• Run process a navigate fetch given resource, the source browsing context, and browsing context, and navigationType.
</li>
	<li>
~ELSE
⇒
`~navigate~URL~schemeを処理する$( %~url, %B )
◎
Otherwise, resource is a request whose url's scheme is neither "javascript" nor a fetch scheme
◎
• Run process a navigate URL scheme given resource's url and browsingContext.
</li>
</ol>


<p class="algo-head">
`~navigate~fetchを処理する@
ときは、所与の
( `要請$ %要請, `~source閲覧文脈$ `S$V, `閲覧文脈$ %B, 文字列 %~navi種別 )
に対し，次を走らす：
◎
To process a navigate fetch, given a request request, browsing context sourceBrowsingContext, browsing context browsingContext, and string navigationType, run these steps:
</p>


<ol>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
<p>
%要請 を次のように設定する：
</p>

<ul><li>`~client$rq ~SET `S$V にて`作動中の文書$に`関連する設定群~obj$
</li><li>`行先$rq ~SET `document^l
</li><li>`~mode$rq ~SET `navigate^l
</li><li>`資格証~mode$rq ~SET `include^l
</li><li>`~URL資格証~利用~flag$rq
</li><li>`~redirect~mode$rq ~SET `manual^l
</li><li>`~target~client~id$rq ~SET %B にて`作動中の文書$に`関連する設定群~obj$の`~id$enV
</li></ul>
◎
Set request's client to sourceBrowsingContext's active document's relevant settings object, destination to "document", mode to "navigate", credentials mode to "include", use-URL-credentials flag, redirect mode to "manual", and target client id to browsingContext's active document's relevant settings object's id.
</li>
	<li>
~IF［
%B は`子~閲覧文脈$である
］
⇒
~IF［
%B を`入子にして$いる`閲覧文脈~容器$の`閲覧文脈~視野~生成元$ %O ~NEQ ε
］
⇒
%要請 の`生成元$rq ~SET %O
◎
If browsingContext is a child browsing context and the browsing context container of browsingContext has a browsing context scope origin, then set request's origin to that browsing context scope origin.
</li>
	<li>
<div class="p">
<p>
%予約済み環境 ~LET 次のようにされた新たな`環境$：
</p>

<ul><li>`~id$enV ~SET 新たな一意かつ不透明な文字列
</li><li>`作成時の~URL$enV ~SET %要請 の`~url$rq
</li><li>`~target閲覧文脈$enV ~SET %B
</li></ul>

◎
Create a new environment reservedEnvironment, and set its id to a new unique opaque string, its creation URL to request's url, and its target browsing context to browsingContext.
</div>

<p class="note">注記：
作成される環境の`作動中の~service-worker$enVは、
その`作成時の~URL$enVが~service-worker登録に合致するならば，
~fetchの間に，
<a href="~SW#on-fetch-request-algorithm">~fetchを取扱う</a> ~algoの中で設定される。
`SW$r
◎
The created environment's active service worker is set in the handle fetch algorithm during the fetch if its creation URL matches a service worker registration. [SW]
</p>
	</li>
	<li>
%要請 の`予約済み~client$rq ~SET %予約済み環境
◎
Set request's reserved client to reservedEnvironment.
</li>
	<li>
%応答 ~SET `~network~error$
◎
↓</li>
	<li>
<p>
~IF［
`~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？$
( %要請, %~navi種別, `S$V,  %B )
`CSP$r
の結果 ~EQ `許容ed^i 
◎
If the Should navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon request, navigationType, sourceBrowsingContext, and browsingContext, then set response to a network error. [CSP]
◎
Otherwise:
</p>
		<ol>
			<li>
%要請 を用いて`~fetch$する
◎
Fetch request.
</li>
			<li>
%応答 ~SET `~network用~task源$上の`応答を処理-$する`~task$を待機した結果
◎
Wait for the task on the networking task source to process response and set response to the result.
</li>
		</ol>
	</li>
	<li>
%所在 ~LET %応答 の`所在~URL$rs
◎
↓</li>
	<li id="navigate-redirect-step">
<div class="p">
<p>
~WHILE［
%所在 ~EQ `失敗^i
］~OR［［
%所在 は`~URL$である
］~AND［
%所在 の`~scheme$urlは`~HTTP_S~scheme$である
］］：
</p>

<ol ><li>%応答 ~SET ( %要請, %応答 ) を用いて`~HTTP~redirect~fetch$を遂行した結果
</li><li>%所在 ~SET %応答 の`所在~URL$rs
</li></ol>

◎
If response has a location URL and it is either failure or a URL whose scheme is an HTTP(S) scheme, then set response to the result of performing HTTP-redirect fetch using request and response and then run this step again.
</div>


<p class="note">注記：
~naviは、~redirectを手動で取扱う。
~naviが、~web~platformにおいて `mailto_$sc の類の~URLへの~redirectを~careする唯一の箇所なので。
◎
Navigation handles redirects manually as navigation is the only place in the web platform that cares for redirects to mailto: URLs and such.
</p>
	</li>
	<li>
<p>
~IF［
%所在 は`~URL$である
］
⇒
%所在 の`~scheme$url に応じて：
</p>
		<dl class="switch">
			<dt>`blob^l</dt>
			<dt>`file^l</dt>
			<dt>`filesystem^l</dt>
			<dt>`javascript^l</dt>
			<dd>
%応答 ~SET `~network~error$
</dd>

			<dt>`~fetch~scheme$である</dt>
			<dd>
<ol ><li>%新~要請 ~LET 新たな`要請$
</li><li>%新~要請 の`~url$rq ~SET %所在
</li><li>`~navigate~fetchを処理する$( %新~要請, `S$V, %B, %~navi種別 )
</li></ol>
			</dd>

			<dt>その他</dt>
			<dd>
`~navigate~URL~schemeを処理する$( %所在, %B )
</dd>

		</dl>

◎
Otherwise, if response has a location URL that is a URL whose scheme is "blob", "file", "filesystem", or "javascript", then set response to a network error.
◎
Otherwise, if response has a location URL that is a URL whose scheme is a fetch scheme, then run process a navigate fetch with a new request whose url is response's location URL, sourceBrowsingContext, browsingContext, and navigationType.
◎
Otherwise, if response has a location URL that is a URL, run the process a navigate URL scheme given response's location URL and browsingContext.
</li>
	<li>
【`~app~cache関連の処理$appCache】
◎
Fallback in prefer-online mode: If response was not fetched from an application cache, and was to be fetched using `GET`, and there are relevant application caches that are identified by a URL with the same origin as the URL in question, and that have this URL as one of their entries, excluding entries marked as foreign, and whose mode is prefer-online, and the user didn't cancel the navigation attempt during the earlier step, and response is either a network error or its status is not an ok status, then:
• Let candidate be the response identified by the URL in question from the most appropriate application cache of those that match.
• If candidate is not marked as foreign, then the user agent must discard the failed load and instead continue along these steps using candidate as response. The user agent may indicate to the user that the original page load failed, and that the page used was a previously cached response.
◎
Fallback for fallback entries: If response was not fetched from an application cache, and was to be fetched using `GET`, and its URL matches the fallback namespace of one or more relevant application caches, and the most appropriate application cache of those that match does not have an entry in its online safelist that has the same origin as response's URL and that is a prefix match for response's URL, and the user didn't cancel the navigation attempt during the earlier step, and response is either a network error or its status is not an ok status, then:
• Let candidate be the fallback response specified for the fallback namespace in question. If multiple application caches match, the user agent must use the fallback of the most appropriate application cache of those that match.
• If candidate is not marked as foreign, then the user agent must discard the failed load and instead continue along these steps using candidate as response. The document's URL, if appropriate, will still be the originally requested URL, not the fallback URL, but the user agent may indicate to the user that the original page load failed, that the page used was a fallback response, and what the URL of the fallback response actually is.
• Run process a navigate response given request, response, navigationType, the source browsing context, browsingContext, and reservedEnvironment.
</li>
</ol>


<p class="algo-head">
`~navigate応答を処理する@
ときは、所与の
( `要請$または ~NULL %要請, `応答$ %応答, 文字列 %~navi種別, `閲覧文脈$ `S$V, `閲覧文脈$ %B, `環境$ %予約済み環境 （省略時は ε ）)
に対し，次を走らす：
◎
To process a navigate response, given null or a request request, a response response, a string navigationType, two browsing contexts source and browsingContext, and an optional environment reservedEnvironment, run these steps:
</p>

<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If any of the following are true, then display the inline content with an appropriate error shown to the user, with the newly created Document object's origin set to a new opaque origin, and return.
</p>

		<ul>
			<li>
%応答 は`~network~error$である
◎
response is a network error.
</li>
			<li class="XXX">
TODO：
ここで `X-Frame-Options^h の処理を定義する。
<a href="https://github.com/whatwg/html/issues/1230">whatwg/html#1230</a>
◎
TODO: Define X-Frame-Options processing here [whatwg/html#1230].
</li>
			<li>
`~sourceから~targetを~navigateするある種別の要請に対する応答は~CSPにより阻止されるべきか？$
( %要請, %~navi種別, %応答, `S$V, %B ) `CSP$r
の結果 ~EQ `阻止ed^i
◎
The Should navigation response to navigation request of type from source in target be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon request, response, navigationType, source, and browsingContext. [CSP]
</li>
			</ul>
<div>
<p>
…ならば：
</p>

<ol ><li>適切な~errorを利用者に示すような，`~inline内容を表示する$
</li><li>前段により作成された`文書$の`生成元$ ~SET 新たな`不透明な生成元$
</li><li>~RET
</li></ol>
◎
↑</div>

<p class="note">注記：
WHATWG Fetch 標準により定義される~network~error
— ~DNSや~TLS ~errorなど —
が伝播される所は，ここであり、利用者に表示されることになる。
`FETCH$r
◎
This is where the network errors defined and propagated by the WHATWG Fetch standard, such as DNS or TLS errors, end up being displayed to users. [FETCH]
</p>
	</li>
	<li>
~IF［
%応答 の`~status$rs ~IN { `204^st, `205^st }
］
⇒
~RET
◎
If response's status is 204 or 205, then return.
</li>
	<li>
<p>
~IF［
%応答 内に `Content-Disposition$h ~headerがあって，それは
`attachment^c ~disposition型を指定している
］：
</p>
<ol ><li>%応答 を`~downloadとして$取扱う
</li><li>~RET
</li></ol>
◎
If response has an `Content-Disposition` header specifying the attachment disposition type, then handle it as a download and return.
</li>
	<li id="_computed-mime-type">
%~MIME型 ~LET %応答 から`算出される~MIME型$
◎
Let type be the computed type of response.
</li>
	<li>
<p>
~IF［
~UAは［
%~MIME型 の資源に対しては［
`閲覧文脈$内に内容を具現化する以外の何らかの仕組み
］を利用して処理する
］ように環境設定されている
］：
</p>

<ol><li>%応答 が表現している %~MIME型 の資源を`非~文書~内容として取扱う$
</li><li>~RET
</li></ol>
◎
If the user agent has been configured to process resources of the given type using some mechanism other than rendering the content in a browsing context, then skip this step. Otherwise, if the type is one of the following types, jump to the appropriate entry in the following list, and process response as described there:
</li>
	<li>
<p>
%~MIME型 に応じて：
◎
↑</p>

		<dl class="switch">
			<dt>
`~HTML~MIME型$
◎
an HTML MIME type
</dt>
			<dd>
<a href="#read-html">~HTML文書~節</a>
に与える手続きに従う
◎
Follow the steps given in the HTML document section, and then, once they have completed, return.
</dd>
			<dt>
`~XML~MIME型$であって, `明示的に~supportされる~XML型$でない
◎
an XML MIME type that is not an explicitly supported XML type
</dt>
			<dd>
<p>
<a href="#read-xml">~XML文書~節</a>
に与える手続きに従う：
</p>
				<ol>
					<li>
~IF［
その結果、内容は汎用~XML文書として表示されるものと決定された
］
⇒
その手続きを完了させる
</li>
					<li>
~ELSE
⇒
%応答 が表現している %~MIME型 の資源を`非~文書~内容として取扱う$
<!-- ＊proceed to the next step -->
</li>
				</ol>

◎
Follow the steps given in the XML document section. If that section determines that the content is not to be displayed as a generic XML document, then proceed to the next step in this overall set of steps. Otherwise, once the steps given in the XML document section have completed, return.
</dd>
			<dt>
`~JS~MIME型$
◎
a JavaScript MIME type
</dt>
			<dt>
`~JSON~MIME型$であって, `明示的に~supportされる~JSON型$でない
◎
a JSON MIME type that is not an explicitly supported JSON type
</dt>
			<dt>`text/cache-manifest$c</dt>
			<dt>`text/css$c</dt>
			<dt>`text/plain$c</dt>
			<dt>`text/vtt$c</dt>
			<dd>
<a href="#read-text">素の~text~file節</a>
に与える手続きに従う
◎
Follow the steps given in the plain text file section, and then, once they have completed, return..
</dd>
			<dt>`multipart/x-mixed-replace$c</dt>
			<dd>
<a href="#read-multipart-x-mixed-replace">`multipart/x-mixed-replace^c 節</a>
に与える手続きに従う
◎
Follow the steps given in the multipart/x-mixed-replace section, and then, once they have completed, return.
</dd>
			<dt>
~supportされる［
画像 ／ 動画 ／ 音声
］型
◎
A supported image, video, or audio type
</dt>
			<dd>
<a href="#read-media">媒体~節</a>
に与える手続きに従う
◎
Follow the steps given in the media section, and then, once they have completed, return.
</dd>
			<dt>
内容を %B 内に具現化するときに外部~appを利用するような型
◎
A type that will use an external application to render the content in browsingContext
</dt>
			<dd>
<a href="#read-plugin">~plugin節</a>
に与える手続きに従う
◎
Follow the steps given in the plugin section, and then, once they have completed, return.
</dd>
			<dt>その他</dt>
			<dd>
%応答 が表現している %~MIME型 の資源を`非~文書~内容として取扱う$
◎
↓</dd>
		</dl>
<p>
上の目的においては：
◎
↓</p>

		<ul>
			<li>
<p>
次に該当する`~MIME型$は、
`明示的に~supportされる~XML型@
とされる：
◎
An explicitly supported XML type is＼
</p>

				<ul>
					<li>
~UAが内容を具現化するときに，外部~appを利用するように 環境設定されているもの（ %B 内に直接的に具現化するような `~plugin$か，または別々の~app）
◎
one for which the user agent is configured to use an external application to render the content (either a plugin rendering directly in browsingContext, or a separate application),＼
</li>
					<li>
~UAが専用の処理~規則を有しているもの（例： 組込みの Atom ~feed-viewerを備える~Web~browserは `application/atom+xml$c ~MIME型を明示的に~supportするとされる）
◎
or one for which the user agent has dedicated processing rules (e.g. a Web browser with a built-in Atom feed viewer would be said to explicitly support the application/atom+xml MIME type),＼
</li>
					<li>
~UAが専用の~handler有しているもの
◎
or one for which the user agent has a dedicated handler.
</li>
				</ul>
			</li>
			<li>
<p>
次に該当する`~MIME型$は、
`~JSON~MIME型@
とされる：
</p>

<ul><li>`application/json$c
</li><li>`text/json$c
</li><li>下位型の尾部 5 文字 ~EQ `+json^l なるもの
</li></ul>

◎
The term JSON MIME type is used to refer to the MIME types application/json, text/json, and any MIME type whose subtype ends with the five characters "+json".
</li>
			<li>
<p>
次に該当する`~MIME型$は、
`明示的に~supportされる~JSON型@
とされる：
◎
An explicitly supported JSON type is＼
</p>
				<ul>
					<li>
~UAが内容を具現化するときに外部~appを利用するように環境設定されているもの（ %B 内に直接的に具現化するような `~plugin$か，または別々の~app）
◎
one for which the user agent is configured to use an external application to render the content (either a plugin rendering directly in browsingContext, or a separate application),＼
</li>
					<li>
~UAが専用の処理~規則を有しているもの
◎
or one for which the user agent has dedicated processing rules,＼
</li>
					<li>
~UAが専用の~handler有しているもの
◎
or one for which the user agent has a dedicated handler.
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<div >
<p>
~IF［
前~段にて新たな`文書$ %新~文書 が作成された
］
⇒
次にしたがって
`~addressを設定-@doc
する
— すなわち、 %新~文書 の`~URL$docを次に与えるものに設定する：
</p>

<ul><li>
`上書き~URL@
がある場合は、それ。
</li><li>他の場合、 %新~文書 が元々~fetchされた`~URL$
— 当の資源を得るために利用された他の~dataは無視する。
</li></ul>

◎
Setting the document's address: If there is no override URL, then any Document created by these steps must have its URL set to the URL that was originally to be fetched, ignoring any other data that was used to obtain the resource. However, if there is an override URL, then any Document created by these steps must have its URL set to that URL instead.
</div>

<p class="note">注記：
`上書き~URL$は、`上書きされる再読込み$を遂行するとき, および
`~javascript~URL$から結果を得る（ dereference する）ときに設定される。
◎
An override URL is set when dereferencing a javascript: URL and when performing an overridden reload.
</p>
	</li>
</ol>



<p class="algo-head">
`~navigate応答を処理する$~algo
【から呼出される各種 下位手続き】
の中で，新たな`文書$ %新~文書 が作成された場合、それを
`初期化-@doc
するときは，次を走らすことが要求される：
◎
Initializing a new Document object: when a Document is created as part of the above steps, the user agent will be required to additionally run the following algorithm after creating the new object:
</p>

<p class="trans-note">【
一部の変数（ %応答 など）は、`~navigate応答を処理する$に渡されたものを指すことに注意。
】</p>

<ol>
	<li>
<p>
~IF［
次のすべてが満たされる
］…：
</p>

<ul ><li>%B の`~session履歴$は、 %B の`作成-$時に追加された `about_blank$sc `文書$ %文書 のみからなる
</li><li>`置換え可能化~flag$ ~EQ ~ON
</li><li>
( %文書 の生成元, %新~文書 の生成元 )
は`同一生成元$である
</li></ul>

<p>
ならば
⇒
何もしない
</p>

◎
If browsingContext's only entry in its session history is the about:blank Document that was added when browsingContext was created, and navigation is occurring with replacement enabled, and that Document has the same origin as the new Document, then do nothing.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
<p>
次のように~custom化する下で，
~JS `InitializeHostDefinedRealm()$jA
抽象演算を~callする
◎
Call the JavaScript InitializeHostDefinedRealm() abstract operation with the following customizations:
</p>

				<ul>
					<li>
大域~obj用に，新たな `Window$I ~objを作成する
◎
For the global object, create a new Window object.
</li>
					<li>
大域 <b>this</b> 値には， %B の `WindowProxy$I ~objを利用する
◎
For the global this value, use browsingContext's WindowProxy object.
</li>
				</ul>
			<li>
<p>
%~realm実行~文脈 ~LET `~JS実行~文脈を走らす$
◎
Let realm execution context be the running JavaScript execution context.
</p>

<p class="note">注記：
これは、前~段で作成した`~JS実行~文脈$になる。
◎
This is the JavaScript execution context created in the previous step.
</p>
			</li>
			<li>
( %~realm実行~文脈, %予約済み環境 )
で`~window用に環境~設定群~objを設定して$おく
◎

Let realm execution context be the created JavaScript execution context.
◎
Set up a window environment settings object with realm execution context and reservedEnvironment, if present.
</li>
		</ol>
	</li>
	<li>
%新~文書 の`~HTTPS状態$doc ~SET %応答 の`~HTTPS状態$rs
◎
Set the Document's HTTPS state to the HTTPS state of response.
</li>
	<li>
%新~文書 の`~referrer施策$doc ~SET %応答 の
<a href="~REFERRER-POLICY#parse-referrer-policy-from-header">`Referrer-Policy^h ~headerを構文解析-</a>した結果
`REFERRERPOLICY$r
◎
Set the Document's referrer policy to the result of parsing the `Referrer-Policy` header of response. [REFERRERPOLICY]
</li>
	<li>
`文書の~CSP~listを初期化する$( %新~文書, %応答 )
`CSP$r
◎
Execute the Initialize a Document's CSP list algorithm on the Document object and the response used to generate the document. [CSP]
</li>
	<li>
<p>
~IF［
%要請 ~NEQ ~NULL
］
⇒
%新~文書 の`~referrer$doc ~SET
%要請 の`~referrer$rq %~referrer は`~URL~record$であるならば
`~URLを直列化する$( %~referrer ) ／
~ELSE_ 空~文字列
◎
If request is non-null, then set the document's referrer to the serialization of request's referrer, if request's referrer is a URL record, and the empty string otherwise.
</p>

<p class="note">注記：
WHATWG Fetch 標準により、`要請$の`~referrer$rq はこの時点で，
`~URL~record$ または `no-referrer^l になる。
◎
Per the WHATWG Fetch standard a request's referrer will be either a URL record or "no-referrer" at this point.
</p>
	</li>
	<li>
%新~文書 に対し`~sandboxingを実装する$
◎
Implement the sandboxing for the Document.
</li>
	<li>
%新~文書 に対し`~allowX~flagを設定する$
◎
Set the allow* flags for the Document.
</li>
	<li>
<p>
~IF［
%応答 には `Refresh$h ~headerはある
］：
◎
If response has a `Refresh` header, then:
</p>

		<ol>
			<li class="XXX">
<a href="https://github.com/whatwg/html/issues/2900">`Refresh^h ~headerが複数ある場合</a>
はどうする？
◎
Multiple `Refresh` headers.
</li>
			<li>
%値 ~LET `Refresh^h の値から得られる文字列
— 各~byteを等しい値の符号位置に対応付ける
◎
Let value be the value of the header with each byte mapped to a code point of equal value.
</li>
			<li>
`共用~宣言的~refresh手続き$( %新~文書, %値 )
を走らす
◎
Run the shared declarative refresh steps with the Document and value.
</li>
		</ol>
	</li>
</ol>

<p class="algo-head">
~naviにおいて所与の %~MIME型 の %資源 を
`非~文書~内容として取扱う@
ときは：
◎
Non-document content:＼
</p>
<ol>
	<li>
<p>
~IF［
~UAは、 %~MIME型 の資源を何らかの~inline内容として表示する
］
⇒
%資源 による`~inline内容を表示する$
◎
If, given type, the new resource is to be handled by displaying some sort of inline content,＼
</p>

<div class="example">
<p>
例えば、次に該当するとき：
</p>

<ul ><li>~UAは、 %資源 の内容を~nativeに具現化する
</li><li>%~MIME型 は~supportされないことを示す~error~message
</li></ul>
◎
e.g., a native rendering of the content or an error message because the specified type is not supported, then display the inline content, and then return.
</div>
	</li>
	<li>
<p>
~ELSE（ %~MIME型 の資源は 当の`閲覧文脈$に影響しない ）
⇒
%資源 を
<a href="#hand-off-to-external-software">適切に処理する</a>
</p>

<div class="example">
<p>
例えば、次に該当するとき：
</p>

<ul ><li>%資源 を外部~appに取り扱わせる
</li><li>%資源 は未知の型であり，`~downloadとして$処理する
</li></ul>
</div>

◎
Otherwise, the document's type is such that the resource will not affect browsingContext, e.g., because the resource is to be handed to an external application or because it is an unknown type that will be processed as a download. Process the resource appropriately.
</li>
</ol>


<p class="algo-head">
`~navigate~URL~schemeを処理する@
ときは、所与の
( `~URL$ %~url, `閲覧文脈$ %B )
に対し，次を走らす：
◎
To process a navigate URL scheme, given a URL url and browsing context browsingContext, run these steps:
</p>

<ol>
	<li>
~IF［
%~url は、 %B に影響しない仕組みを用いて取扱われるものである（ %~url の`~scheme$urlは外部的に取扱われるものである）
］
⇒
~RET
— 代わりに，<a href="#hand-off-to-external-software">その仕組みを続行する</a>
◎
If url is to be handled using a mechanism that does not affect browsingContext, e.g., because url's scheme is handled externally, then proceed with that mechanism instead.
</li>
	<li>
<p>
~ELIF［
%~url は、何らかの~inline内容を表示して取扱われるものである
］
⇒
その`~inline内容を表示する$
— 例えば：
</p>

<ul ><li>指定された~schemeは~supportされる~protocolでないことを示す~error~message, あるいは
</li><li>利用者が 所与の~schemeに対する`登録済みの~handler$を選定できるようにするための~inline~prompt
</li></ul>

<p class="note">注記：
登録済みの~handlerが利用されている事例では、`~navigate$は，新たな~URLで再び呼出されることになる。
</p>

◎
Otherwise, url is to be handled by displaying some sort of inline content, e.g., an error message because the specified scheme is not one of the supported protocols, or an inline prompt to allow the user to select a registered handler for the given scheme. Display the inline content.
◎
In the case of a registered handler being used, navigate will be invoked with a new URL.
</li>
</ol>

<p>
~UAは、資源の［
~URL／~data
］を
<dfn id="hand-off-to-external-software">外部~software~packageに取扱わせる</dfn>
ときは（例： `mailto_$sc ~URLを~mail~clientに取り扱わせたり， Word 文書を word processor に取り扱わせるなど）：
◎
When a resource is handled by passing its URL or data to an external software package separate from the user agent (e.g. handing a mailto: URL to a mail client, or a Word document to a word processor),＼
</p>

<ul>
	<li>
対象の~softwareを悪用しようと試みる~riskを軽減するよう試みるべきである。
例えば［
`~source閲覧文脈$にて`作動中の文書$の`生成元$は，指定された~softwareを呼出すことが許容される
］ことについて確認するよう，利用者に~promptするなどにより。
◎
user agents should attempt to mitigate the risk that this is an attempt to exploit the target software, e.g. by prompting the user to confirm that the source browsing context's active document's origin is to be allowed to invoke the specified software.＼
</li>
	<li>
特に、`~navigate$~algoが `利用者による作動化により誘発され$たものでない場合、~UAは，前もって利用者に確認をとることなく，外部~software~packageを呼出すべきでない。
◎
In particular, if the navigate algorithm, when it was invoked, was not triggered by user activation, the user agent should not invoke the external software package without prior user confirmation.
</li>
</ul>

<p class="example">
例えば、［
ある敵対的~頁が，~linkを~clickするよう利用者を騙すように悪用できる
］ような脆弱性が，~target~softwareの~URL~handler内にあるかもしれない。
◎
For example, there could be a vulnerability in the target software's URL handler which a hostile page would attempt to exploit by tricking a user into clicking a link.
</p>

<hr>

<div >
<p class="algo-head">
下の各~節の一部にて，~UAが
`新たな頁で~session履歴を更新-@
するよう要求されたときは、次を走らす`~taskを~queueし$~MUST
— その~taskを（新たな~entryではなく）`現在の~entry$の`文書$に結付けた上で：
</p>

<p>
【この手続きには、次に挙げる暗黙の入力がある：】
</p>

<ul ><li>%~navi （この~algoを呼出した`~navi$~algoの~instance）
</li><li>%B （ %~navi により~navigateされている`閲覧文脈$）
</li><li>%履歴 （ %B の`~session履歴$）
</li><li>%更新~entry （%~navi は %履歴 内のある
`~entryを更新する@
ために起動されたならば，その~entry ／
~ELSE_ ε
）
</li><li>%資源~URL （ %~navi に渡された %資源 は`~URL$であるならば それ ／ ~ELSE_ ε）
</li><li>%資源 （ %~navi による~navigate先の資源）
</li><li>%文書 （ %資源 を表現している新たな`文書$）
</li></ul>

◎
Some of the sections below, to which the above algorithm defers in certain cases, require the user agent to update the session history with the new page. When a user agent is required to do this, it must queue a task (associated with the Document object of the current entry, not the new one) to run the following steps:
</div>

<ol>
	<li>
次を与える下で，［
%履歴 の`現在の~entry$の`文書$
］を`~unload$docする
⇒
%recycle ~SET ~F
◎
Unload the Document object of the current entry, with the recycle parameter set to false.
</li>
	<li>
~IF［
前~段の`~unload$docを走らせている間に %~navi は取消された
］
⇒
~RET
⇒
`~unload$docは走らせ終え~MUSTが、
 %~navi は，この段を超えて走らせては~MUST_NOT。
（特に，ここで %~navi が取消されても、具体例として，文書や その子孫を~unloadする一部として生じている ~event配送や~script実行は，中止されない。）
◎
If this instance of the navigation algorithm is canceled while this step is running the unload a document algorithm, then the unload a document algorithm must be allowed to run to completion, but this instance of the navigation algorithm must not run beyond this step. (In particular, for instance, the cancelation of this algorithm does not abort any event dispatch or script execution occurring as part of unloading the document or its descendants.)
</li>
	<li>
<p>
~IF［
%更新~entry ~NEQ ε
］：
◎
If the navigation was initiated for entry update of an entry
</p>
		<ol>
			<li>
%旧~文書 ~LET %更新~entry の`文書$
◎
↓</li>
			<li>
%履歴 内の~entryのうち［
その`文書$ ~EQ %旧~文書
］なる ~EACH ( ~entry %e ) に対し
⇒
%e の`文書$ ~SET %文書
◎
Replace the Document of the entry being updated, and any other entries that referenced the same document as that entry, with the new Document.
</li>
			<li>
`履歴を走査する$( %更新~entry )
◎
Traverse the history to the new entry.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
<p>
%新~entry ~LET %資源 とその文書を表現する，次のものからなる新たな`~session履歴~entry$：
</p>

<ul ><li>`文書$ ~SET %文書
</li><li>関係する状態【おそらく、`直列形の状態$を指す】
</li><li>`~scroll復旧~mode$ ~SET `auto$l
</li><li>`~URL$ ~SET %文書 の`~URL$doc 【この項目は、この訳による推定（~URLは必須なので）。】
</li></ul>

◎
↓</li>
			<li>
<p>
~IF［
%資源~URL ~NEQ ε
］~AND［
%資源~URL ~EQ %B にて`作動中の文書$の`~URL$doc
］：
◎
If the navigation was initiated with a URL that equals the browsing context's active document's URL
</p>
				<ol>
					<li>
%履歴 の`現在の~entry$を %新~entry に置換する
◎
Replace the current entry with a new entry representing the new resource and its Document object, related state, and the default scroll restoration mode of "auto".
</li>
					<li>
`履歴を走査する$( %新~entry )
◎
Traverse the history to the new entry.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
◎
Otherwise
</p>
				<ol>
					<li>
<p>
%履歴 内の`現在の~entry$より後の~entryは すべて除去する
◎
Remove all the entries in the browsing context's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.
</p>

<p class="note">注記：
これは、<a href="~HISTORY#history-notes">~UAの~UIに影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
					</li>
					<li>
%文書 の `History$I ~objの末尾に %新~entry を付加する
◎
Append a new entry at the end of the History object representing the new resource and its Document object, related state, and the default scroll restoration mode of "auto".
</li>
					<li>
`履歴を走査する$( %新~entry, %~navi に渡された`置換え可能化~flag$ )
◎
Traverse the history to the new entry. If the navigation was initiated with replacement enabled, then the traversal must itself be initiated with replacement enabled.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
この時点で、 %~navi は
`成熟-@
したとされる。
◎
The navigation algorithm has now matured.
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
~UAにより定義される時間長だけ`~event-loopを回す$
（この段は、~UAが処理能の懸念に面したとき，利用者~体験を最適化できるようにするためにある。）
◎
Fragment loop: Spin the event loop for a user-agent-defined amount of time, as desired by the user agent implementer. (This is intended to allow the user agent to optimize the user experience in the face of performance concerns.)
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~BREAK：
</p>
<ul><li>%文書 に対する構文解析器は無い
</li><li>%文書 に対する構文解析器は`構文解析を停止した$
</li><li>~UAには、［
利用者が`素片へ~scroll$することに関心を失った
］と予見する事由がある
</li></ul>

◎
If the Document object has no parser, or its parser has stopped parsing, or the user agent has reason to believe the user is no longer interested in scrolling to the fragment, then return.
</li>
			<li>
%文書 の`~URL$docを与える下で，`素片へ~scroll$する
◎
↓</li>
			<li>
~IF［
前~段の結果 %文書 内の`指示された部位$docを見出せた
］
⇒
~BREAK
◎
Scroll to the fragment given in the document's URL. If this fails to find an indicated part of the document, then return to the fragment loop step.
</li>
		</ol>
	</li>
</ol>

<p>
この`~task$の`~task源$は、`~network用~task源$とする。
◎
The task source for this task is the networking task source.
</p>



			</section>
			<section id="read-html">
<h3 title="Page load processing model for HTML files">7.8.2. ~HTML~fileに対する頁~読込~処理~model</h3>

<div>
<p>
~HTML文書を `閲覧文脈$内に読込むことになるときは、~UAは 次を走らす`~taskを~queueし$~MUST：
</p>

<ol><li>%文書 ~SET 新たな`文書$
</li><li>%文書 の`種別$doc ~SET `html^l
</li><li>%文書 の`内容~型$doc ~SET `text/html^l
</li><li>%文書 を`初期化-$docする
</li><li>%解析器 ~LET 新たな`~HTML構文解析器$
</li><li>%解析器 を %文書 に結付ける
</li></ol>

<p>
~fetchingを走らせている間に`~network用~task源$から
`~task~queue$に入れられる各`~task$は、~fetchされた~byte列で
%解析器 への`入力~byte~stream$を埋めた上で，
%解析器 に入力~streamの適切な処理を遂行させ~MUST。
</p>
◎
When an HTML document is to be loaded in a browsing context, the user agent must queue a task to create a Document object, mark it as being an HTML document, set its content type to "text/html", initialize the Document object, and finally create an HTML parser and associate it with the Document. Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</div>


<p class="note">注記：
`入力~byte~stream$に渡された~byte列は、文字~並びに変換されて`~tokenizer$に渡される。
この処理-の一部は、資源の~~真の `~Content-Type~metadata$ から見出される文字~符号化方式~情報に依拠する
— `資源から算出された~MIME型$V は、その目的0には利用されない。
◎
The input byte stream converts bytes into characters for use in the tokenizer. This process relies, in part, on character encoding information found in the real Content-Type metadata of the resource; the computed type is not used for this purpose.
</p>

<p>
可用な~byte列が尽きたときは、~UAは， %解析器 が暗黙の~EOF文字を処理する`~taskを~queueし$~MUST
— それは、最終的に `load$et ~eventを発火させることになる。
◎
When no more bytes are available, the user agent must queue a task for the parser to process the implied EOF character, which eventually causes a load event to be fired.
</p>

<p>
~UAは、`文書$が作成された後, かつ ~scriptが実行される前の, ほぼ間違いなく %解析器 が`停止-$する前に，`新たな頁で~session履歴を更新-$し~MUST。
◎
After creating the Document object, but before any script execution, certainly before the parser stops, the user agent must update the session history with the new page.
</p>

<p class="note">注記：
【`~app~cache関連の注記$appCache】
◎
Application cache selection happens in the HTML parser.
</p>

<p>
この節にて言及した各~taskの`~task源$は、`~network用~task源$で~MUST。
◎
The task source for the two tasks mentioned in this section must be the networking task source.
</p>



			</section>
			<section id="read-xml">
<h3 title="Page load processing model for XML files">7.8.3. ~XML~fileに対する頁~読込~処理~model</h3>

<p>
~XML~fileを~inlineに表示することになった場合、~UAは，次に挙げる各種 仕様に定義される要件に従わ~MUST
⇒
`XML$r, `XMLNS$r, `RFC7303$r, `DOM$r, および 関連する他の［
`文書$を作成するときの仕様 ／
文書に対応する`~XML構文解析器$の仕様
］
◎
When faced with displaying an XML file inline, user agents must follow the requirements defined in the XML and Namespaces in XML recommendations, RFC 7303, DOM, and other relevant specifications to create a Document object and a corresponding XML parser. [XML] [XMLNS] [RFC7303] [DOM]
</p>

<p class="note">注記：
これを書いている時点では，~XML仕様~communityは、実際には，~XMLと~DOMとがどう相互作用するか まだ指定していない。
◎
At the time of writing, the XML specification community had not actually yet specified how XML and the DOM interact.
</p> 

<p>
~UAは、`文書$ %文書 を作成したなら：
◎
↓</p>

<ul>
	<li>
%文書 を`初期化-$docし~MUST。
◎
After the Document is created, the user agent must initialize the Document object.
</li>
	<li>
上に挙げた各 仕様の規則に則って，文字~符号化方式を決定するときには、実際の~HTTP~headerや他の~metadataのうち［
この仕様が与える~algoにより［
変異される／含意される
］~header
］でないものが，利用され~MUST。
%文書 の`文字~符号化方式$docは、そのように確立された符号化方式に設定され~MUST。
◎
The actual HTTP headers and other metadata, not the headers as mutated or implied by the algorithms given in this specification, are the ones that must be used when determining the character encoding according to the rules given in the above specifications. Once the character encoding is established, the document's character encoding must be set to that character encoding.
</li>
	<li>
【`~app~cache関連の処理~要件$appCache】
◎
If the document element, as parsed according to the XML specifications cited above, is found to be an html element with an attribute manifest whose value is not the empty string, then, as soon as the element is inserted into the document, the user agent must parse the value of that attribute relative to that element's node document, and if that is successful, must apply the URL serializer algorithm to the resulting URL record with the exclude fragment flag set to obtain manifest URL, and then run the application cache selection algorithm with manifest URL as the manifest URL, passing in the newly-created Document. Otherwise, if the attribute is absent, its value is the empty string, or parsing its value fails, then as soon as the document element is inserted into the document, the user agent must run the application cache selection algorithm with no manifest, and passing in the Document.
◎
Because the processing of the manifest attribute happens only once the document element is parsed, any URLs referenced by processing instructions before the document element (such as &lt;?xml-stylesheet?&gt; PIs) will be fetched from the network and cannot be cached.
</li>
	<li>
<p>
%文書 の根 `Element$I ~nodeの名前空間を検分して，その名前空間に基づいて，代替の処理~toolに~~処理を委託して~MAY
— 例：
その内容が，実際には syndication feed であると決定されたなら、それを feed ~handlerに渡すなど。
そのような処理に任せることになる場合、この節の手続きは中止した上で，`~navigate$手続きにおける`非~文書~内容として取扱う$とする。
</p>
<p class="trans-note">【
syndication feed
— 連携サイト（ syndication ）から随時更新されるような情報（ feed ）。
】</p>
◎
User agents may examine the namespace of the root Element node of this Document object to perform namespace-based dispatch to alternative processing tools, e.g. determining that the content is actually a syndication feed and passing it to a feed handler. If such processing is to take place, abort the steps in this section, and jump to the next step (labeled non-document content) in the navigate steps above.
</li>
	<li>
<p>
前項に該当しない場合，
%文書 を伴う`新たな頁で~session履歴を更新-$し~MUST
— その時機は：
</p>

<ul ><li>文書が完全に構文解析される前でもよい（したがって `増分的に具現化する^i ことになる）。
</li><li>どの~script実行よりも前で~MUST。
</li></ul>

◎
Otherwise, then, with the newly created Document, the user agent must update the session history with the new page. User agents may do this before the complete document has been parsed (thus achieving incremental rendering), and must do this before any scripts are to be executed.
</li>
	<li>
構文解析-時の~error（例えば ~XML名前空間 整形式性~error）に際しては、
%文書 を変異して~inlineに報告して~MAY。
◎
Error messages from the parse process (e.g. XML namespace well-formedness errors) may be reported inline by mutating the Document.
</li>
</ul>


			</section>
			<section id="read-text">
<h3 title="Page load processing model for text files">7.8.4. ~text~fileに対する頁~読込~処理~model</h3>

<div class="p">
<p>
素の~text文書を `閲覧文脈$内に読込むことになるときは、~UAは，次を走らす`~taskを~queueし$~MUST：
</p>

<ol><li>%文書 ~SET 新たな`文書$
</li><li>%文書 の`種別$doc ~SET `html^l
</li><li>%文書 の`内容~型$doc ~SET `資源から算出された~MIME型$V
</li><li>%文書 を`初期化-$docする
</li><li>%構文解析器 ~SET 新たな`~HTML構文解析器$
</li><li>%構文解析器 は，その~tokenizerが次をすでに行ったかのようにしておく
	<ol><li>~tag名 `pre^l の開始tag~tokenを発した
	</li><li>1 個の文字 U+000A （LF）を発した
	</li><li>`~PLAINTEXT状態$に切替えた
	</li></ol>
</li><li>%構文解析器 を %文書 に結付ける
</li></ol>

<p>
~fetchingを走らせている間に`~network用~task源$から`~task~queue$に入れられる各`~task$は、
%構文解析器 の`入力~byte~stream$を~fetchされた~byte列で埋めて，
%構文解析器 に入力~streamの適切な処理を遂行させ~MUST。
</p>
◎
When a plain text document is to be loaded in a browsing context, the user agent must queue a task to create a Document object, mark it as being an HTML document, set its content type to the computed MIME type of the resource (type in the navigate algorithm), initialize the Document object, create an HTML parser, associate it with the Document, act as if the tokenizer had emitted a start tag token with the tag name "pre" followed by a single U+000A LINE FEED (LF) character, and switch the HTML parser's tokenizer to the PLAINTEXT state. Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</div>


<p>
素の~text文書である %資源 に対しては、次に挙げる要件が~UAに課される：
◎
↓</p>

<ul>
	<li>
%資源 の~byte列を
実際の文字に変換する規則，および
その~textを利用者~向けに実際に具現化する規則は、 `資源から算出された~MIME型$V の仕様により定義される。
◎
The rules for how to convert the bytes of the plain text document into actual characters, and the rules for actually rendering the text to the user, are defined by the specifications for the computed MIME type of the resource (type in the navigate algorithm).
</li>
	<li>
%資源 の`文字~符号化方式$docは、 %資源 の復号-時に利用された文字~符号化方式に設定され~MUST。
◎
The document's character encoding must be set to the character encoding used to decode the document.
</li>
	<li>
【`~app~cache関連の処理~要件$appCache】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.
</li>
	<li>
可用な~byte列が尽きたときは、
構文解析器が暗黙の~EOF文字を処理する`~taskを~queueし$~MUST
— それは、最終的に
`load$et ~eventを発火させることになる。
◎
When no more bytes are available, the user agent must queue a task for the parser to process the implied EOF character, which eventually causes a load event to be fired.
</li>
	<li>
<p>
%資源 から`文書$ %文書 を作成した後, かつ
頁を構文解析し終えて`なければその前に$，`新たな頁で~session履歴を更新-$し~MUST。
◎
After creating the Document object, but potentially before the page has finished parsing, the user agent must update the session history with the new page.
</p>

<p class="trans-note">【
“`なければその前に@”
— 原文の “, but potentially before” の意図が［
要件の一部 ／
可能性があることを示す単なる説明 ／
終える前にそうしてよいことの明示的な許可
］のどれなのか はっきりしないが、同じ要件~文の一部として  but 節の中に記されているので，要件と解釈する下で和訳している。
】</p>
	</li>
	<li>
<p>
%文書 の `head$e 要素に内容を追加して~MAY
— 例：
~stylesheetへ~linkする,
~scriptを供する,
%文書 に `title$e を与える,
等々。
◎
User agents may add content to the head element of the Document, e.g., linking to a style sheet, providing script, or giving the document a title.
</p>

<p class="note">注記：
特に、 RFC 3676 の `Format=Flowed^c 特色機能を~supportする~UAは、［
~textを正しく折返す／
【行頭の "&gt;" による】 引用用の特色機能を取扱う
］ために，何らかの~styleを適用する必要が生じることになる。
これは、例えば~CSS拡張を利用して遂行することもできる。
◎
In particular, if the user agent supports the Format=Flowed feature of RFC 3676 then the user agent would need to apply extra styling to cause the text to wrap correctly and to handle the quoting feature. This could be performed using, e.g., a CSS extension.
</p>
	</li>
</ul>

<p>
この節に言及した 2 つの~taskの`~task源$は、`~network用~task源$で~MUST。
◎
The task source for the two tasks mentioned in this section must be the networking task source.
</p>

			</section>
			<section id="read-multipart-x-mixed-replace">
<h3 title="Page load processing model for multipart/x-mixed-replace resources">7.8.5. `multipart/x-mixed-replace^c 資源に対する頁~読込~処理~model</h3>

<p>
型 `multipart/x-mixed-replace$c を伴う資源を `閲覧文脈$内に読込むことになるときは、~UAは，次に従わ~MUST：
◎
When a resource with the type multipart/x-mixed-replace is to be loaded in a browsing context, the user agent must＼
</p>

<ul>
	<li>
`RFC2046$r による `multipart^c 型に対する規則を利用して資源を構文解析する。
◎
parse the resource using the rules for multipart types. [RFC2046]
</li>
	<li>
資源から得られる ~EACH( %本体~部位 ) に対し，出現順に 次を走らす
⇒
次を除いて、この節を呼出した`~navi$と同じものを与える下で，`~navigate応答を処理する$
⇒
%応答 の本体には %本体~部位 を利用する。
また、これまでの反復にて，`文書$が作成され`初期化-$docされている場合は、［
`置換え可能化~flag$ ~SET ~ON
］にする。
◎
For each body part obtained from the resource, the user agent must run process a navigate response using the new body part and the same browsing context, with replacement enabled if a previous body part from the same resource resulted in a Document object being created and initialized, and otherwise using the same setup as the navigate attempt that caused this section to be invoked in the first place.
</li>
	<li>
前項による，［
各 本体~部位を，完全に自立的な資源であったかのように処理する目的0
］においては、各 本体~部位に対し［
それに後続する境界に達した所で，当の資源に対する~byte列は尽きた
］かのように動作する。
◎
For the purposes of algorithms processing these body parts as if they were complete stand-alone resources, the user agent must act as if there were no more bytes for those resources whenever the boundary following the body part is reached.
</li>
</ul>

<p class="note">注記：
したがって， `load$et ~event（および，対になる `unload$et ~event）は、各~本体~部位が読込まれる度に発火されることになる。
◎
Thus, load events (and for that matter unload events) do fire for each body part loaded.
</p>


			</section>
			<section id="read-media">
<h3 title="Page load processing model for media">7.8.6. 媒体に対する頁~読込~処理~model</h3>


<p>
［
画像 ／ 動画 ／ 音声
］資源を `閲覧文脈$内に読込むことになるときは、~UAは 次をするべきである：
◎
When an image, video, or audio resource is to be loaded in a browsing context, the user agent should＼
</p>

<ol>
	<li>
%文書 ~SET 新たな`文書$
◎
create a Document object,＼
</li>
	<li>
%文書 の`種別$doc ~SET `html^l
◎
mark it as being an HTML document,＼
</li>
	<li>
%文書 の`内容~型$doc ~SET `資源から算出された~MIME型$V
◎
set its content type to the computed MIME type of the resource (type in the navigate algorithm),＼
</li>
	<li>
%文書 を`初期化-$docする
◎
initialize the Document object,＼
</li>
	<li>
%文書 に `html$e 要素を付加する
◎
append an html element to the Document,＼
</li>
	<li>
`html$e 要素に `head$e 要素, `body$e 要素を順に付加する
◎
append a head element and a body element to the html element,＼
</li>
	<li>
<p>
`body$e 要素に［
資源の媒体に応じて，次の表の 2 列目に与えられる要素
］を付加する：
</p>

<table><thead><tr><th>媒体~型
<th>要素
<th>属性
</thead>

<tbody><tr><td>画像
<td>`img$e
<td>`~src-img$a

<tr><td>動画
<td>`video$e
<td>`~src-media$a

<tr><td>音声
<td>`audio$e
<td>`~src-media$a

</tbody></table>

◎
append an element host element for the media, as described below, to the body element,＼
</li>
	<li>
前~段で付加した要素の［
対応する，前~段の表の 3 列目の属性
］の値 ~SET 資源の~address
◎
and set the appropriate attribute of the element host element, as described below, to the address of the image, video, or audio resource.
◎
The element host element to create for the media is the element given in the table below in the second cell of the row whose first cell describes the media. The appropriate attribute to set is the one given by the third cell in that same row.
◎
Type of media | Element for the media | Appropriate attribute
Image | img | src
Video | video | src
Audio | audio | src
</li>
</ol>

<p>
次に，~UAは、`構文解析を停止した$かのように動作し~MUST。
◎
Then, the user agent must act as if it had stopped parsing.
</p>

<p>
【`~app~cache関連の処理~要件$appCache】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.
</p>

<p>
~UAは、`文書$が作成された後, かつ
頁を構文解析し終えて`なければその前に$，`新たな頁で~session履歴を更新-$し~MUST。
◎
After creating the Document object, but potentially before the page has finished fully loading, the user agent must update the session history with the new page.
</p>

<p>
~UAは、`文書$の `head$e 要素に内容を追加して~MAY ／
%~host要素 に内容~属性を追加して~MAY
— 例：
~stylesheetへの~link ／
~scriptを供する ／
文書に `title$e を与える ／
媒体を `autoplay$a にする
等々。
◎
User agents may add content to the head element of the Document, or attributes to the element host element, e.g., to link to a style sheet, to provide a script, to give the document a title, or to make the media autoplay.
</p>

			</section>
			<section id="read-plugin">
<h3 title="Page load processing model for content that uses plugins">7.8.7. ~pluginを利用する内容に対する頁~読込~処理~model</h3>

<p>
外部~資源を具現化することを要する資源を，`閲覧文脈$内に読込むことになるときは、~UAは 次をするべきである：
◎
When a resource that requires an external resource to be rendered is to be loaded in a browsing context, the user agent should＼
</p>

<ol>
	<li>
%文書 ~SET 新たな`文書$
◎
create a Document object,＼
</li>
	<li>
%文書 の`種別$doc ~SET `html^l
◎
mark it as being an HTML document and＼
</li>
	<li>
%文書 を
`~plugin文書@
とする
◎
mark it as being a plugin document,＼
</li>
	<li>
%文書 の`内容~型$doc ~SET `資源から算出された~MIME型$V
◎
set its content type to the computed MIME type of the resource (type in the navigate algorithm),＼
</li>
	<li>
%文書 を`初期化-$docする
◎
initialize the Document object,＼
</li>
	<li>
`文書$に `html$e 要素を付加する
◎
append an html element to the Document,＼
</li>
	<li>
`html$e 要素に `head$e 要素, `body$e 要素を順に付加する
◎
append a head element and a body element to the html element,＼
</li>
	<li>
`body$e 要素に `embed$e 要素を付加する
◎
append an embed to the body element,＼
</li>
	<li>
`embed$e 要素の `~src-embed$a 属性を資源の~addressに設定する
◎
and set the src attribute of the embed element to the address of the resource.
</li>
</ol>

<p class="note">注記：
用語 `~plugin文書$は、［
`plugin-types^dir 指令をかいくぐるために `iframe$e が利用されることは生じ得ない
］ことを確保するための仕組みの一部として， `CSP$r により利用される。
◎
The term plugin document is used by Content Security Policy as part of the mechanism that ensures iframes can't be used to evade plugin-types directives. [CSP]
</p>

<p>
次に，~UAは、`構文解析を停止した$かのように動作し~MUST。
◎
Then, the user agent must act as if it had stopped parsing.
</p>

<p>
【`~app~cache関連の処理~要件$appCache】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, and passing in the newly-created Document.
</p>

<p>
~UAは、`文書$が作成された後, かつ
頁を構文解析し終えて`なければその前に$，`新たな頁で~session履歴を更新-$し~MUST。
◎
After creating the Document object, but potentially before the page has finished fully loading, the user agent must update the session history with the new page.
</p>

<p>
~UAは［
`文書$の `head$e 要素 ／
`embed$e 要素の属性
］に内容を追加して~MAY
— 例：
~stylesheetへ~linkする,
文書に `title$e を与える,
等々。
◎
User agents may add content to the head element of the Document, or attributes to the embed element, e.g. to link to a style sheet or to give the document a title.
</p>

<p id="sandboxPluginNavigate" class="note">注記：
［
`閲覧文脈~sandbox化( ~plugin )~flag$ ~IN `文書$の`作動中の~sandbox用~flag集合$
］の下で［
関連する`~plugin$を`保安化-$できなかった
］場合には、合成された `embed$e 要素は，
<a href="~HEembed#sandboxPluginEmbed">内容を具現化するのに失敗する</a>ことになる。
◎
If the Document's active sandboxing flag set has its sandboxed plugins browsing context flag set, the synthesized embed element will fail to render the content if the relevant plugin cannot be secured.
</p>



			</section>
			<section id="read-ua-inline">
<h3 title="Page load processing model for inline content that doesn't have a DOM">7.8.8. ~DOMを有さない~inline内容に対する頁~読込~処理~model</h3>


<p>
~UAは、頁を`閲覧文脈$内に~inlineに表示するときは、次をするべきである：
◎
When the user agent is to display a user agent page inline in a browsing context, the user agent should＼
</p>

<ol>
	<li>
%文書 ~SET 新たな`文書$
◎
create a Document object,＼
</li>
	<li>
%文書 の`種別$doc ~SET `html^l
◎
mark it as being an HTML document,＼
</li>
	<li>
%文書 の`内容~型$doc ~SET `text/html^l
◎
set its content type to "text/html",＼
</li>
	<li>
%文書 を`初期化-$docする
◎
initialize the Document object,＼
</li>
	<li>
<p>
次のいずれかを行う：
◎
and then either＼
</p>
		<ul>
			<li>
%文書 を［
`文書$の通常の具現化~規則を利用して具現化されない
］ような~customな具現化に結付ける
◎
associate that Document with a custom rendering that is not rendered using the normal Document rendering rules, or＼
</li>
			<li>
%文書 を［
それが~UAが具現化しようと求める内容を表現する
］ように変異させる。
◎
mutate that Document until it represents the content the user agent wants to render.
</li>
		</ul>
	</li>
</ol>


<p>
~UAは、頁が設定しておかれたなら，`構文解析を停止した$かのように動作し~MUST。
◎
Once the page has been set up, the user agent must act as if it had stopped parsing.
</p>

<p>
【`~app~cache関連の処理~要件$appCache】
◎
Upon creation of the Document object, the user agent must run the application cache selection algorithm with no manifest, passing in the newly-created Document.
</p>

<p>
~UAは、`文書$が作成された後, かつ
頁を完全に設定して`なければその前に$，`新たな頁で~session履歴を更新-$し~MUST。
◎
After creating the Document object, but potentially before the page has been completely set up, the user agent must update the session history with the new page.
</p>


			</section>
			<section id="scroll-to-fragid">
<h3 title="Navigating to a fragment">7.8.9. 素片へ~navigateするとき</h3>

<p>
~UAは，素片へ~navigateすることになったときは、所与の
( `閲覧文脈$ %B, `~URL$ %~URL, %置換え可能化~flag )
に対し，次を走らせ~MUST：
◎
When a user agent is supposed to navigate to a fragment, optionally with replacement enabled, then the user agent must run the following steps:
</p>

<ol>
	<li>
~Assert：
%~URL の`素片$url ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
	<li>
%履歴 ~LET %B の`~session履歴$
◎
↓</li>
	<li>
<p>
~IF［
%置換え可能化~flag ~EQ ~OFF
］
⇒
%履歴 内から， %履歴 の`現在の~entry$より後の~entryはすべて除去する
◎
If not with replacement enabled, then remove all the entries in the browsing context's session history after the current entry. If the current entry is the last entry in the session history, then no entries are removed.
</p>

<p class="note">注記：
これは、<a href="~HISTORY#history-notes">~UAの~UIに影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
	</li>
	<li>
%B の`~top-level閲覧文脈$の`文書~族$内の ~EACH ( `文書$ %D ) に対し
⇒
%D に結付けられている`履歴~走査~task源$により~queueされた`~task$があれば，それらを除去する
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
	<li>
<p>
%~entry ~LET 当の資源とその文書を表現する，次のものからなる新たな`~session履歴~entry$：
</p>

<ul ><li>`文書$ ~SET %B にて`作動中の文書$
</li><li>関係する状態【おそらく、`直列形の状態$を指す】
</li><li>`~scroll復旧~mode$ ~SET `現在の~entry$のそれ
</li><li>`~URL$ ~SET %~URL
</li></ul>

<p>
%~entry の~titleは未設定のままにする
</p>

◎
Append a new entry at the end of the History object representing the new resource and its Document object, related state, and current entry's scroll restoration mode. Its URL must be set to the address to which the user agent was navigating. The title must be left unset.
</li>
	<li>
`History$I ~objの末尾に %~entry を付加する
◎
↑</li>
	<li>
`履歴を走査する$( %~entry,  %置換え可能化~flag, ~ON )
— これは、今や文書の`~URL$docになった`素片へ~scroll$することになる。
◎
Traverse the history to the new entry, with replacement enabled if this was invoked with replacement enabled, and with the non-blocking events flag set. This will scroll to the fragment given in what is now the document's URL.
</li>
</ol>

<p class="note">注記：
素片が指す`~ID$を有する要素が まだ構文解析されていないため，~scrollできなかった場合、代わりに，元の`~navi$~algoから呼ばれる［
`新たな頁で~session履歴を更新-$する~algo
］の最後の方で，~scrollingが~careされることになる。
◎
If the scrolling fails because the relevant ID has not yet been parsed, then the original navigation algorithm will take care of the scrolling instead, as the last few steps of its update the session history with the new page algorithm.
</p>


<hr>

<div >
<p class="algo-head">
%文書 の
`素片へ~scroll@
するよう要求されたときは、~UAは，次を行わ~MUST：
◎
When the user agent is required to scroll to the fragment and＼
</p>

<ol>
	<li>
%部位 ~LET %文書 内の`指示された部位$doc
◎
the indicated part of the document,＼
</li>
	<li>
~IF［
%部位 ~EQ ε
］~OR［
%部位 は`具現化されて$いない
］
⇒
~RET
◎
if any, is being rendered,＼
</li>
	<li>
<p>
次のいずれかを行う：
◎
the user agent must either＼
</p>

		<ul>
			<li>
下に述べるように，文書の~scroll位置を %部位 に変更する。
◎
change the scrolling position of the document using the following algorithm,＼
</li>
			<li>
%部位 に利用者の注目を引くような他の何らかの動作を遂行する。
◎
or perform some other action such that the indicated part of the document is brought to the user's attention. If there is no indicated part, or if the indicated part is not being rendered, then the user agent must do nothing.
</li>
		</ul>
	</li>
</ol>

<!-- 初期時は null なので不要な記述 -->
</div>

<p>
`文書$ %文書 の~scroll位置を %部位 に変更するときは：
◎
The aforementioned algorithm is as follows:
</p>

<ol>
	<li>
%文書 の`標的~要素$ ~SET ~NULL
◎
If there is no indicated part of the document, set the Document's target element to null.
</li>
	<li>
<p>
%部位 に応じて：
</p>

		<dl class="switch">
			<dt>`文書の上端^i
◎
If the indicated part of the document is the top of the document, then:
</dt>
			<dd>
%文書 の`開始位置へ~scroll$する `CSSOMVIEW$r
◎
Set the Document's target element to null.
◎
Scroll to the beginning of the document for the Document. [CSSOMVIEW]
</dd>

			<dt>要素である
◎
Otherwise:
</dt>
			<dd>
				<ol>
					<li>
%文書 の`標的~要素$ ~SET %部位
◎
Let target be element that is the indicated part of the document.
◎
Set the Document's target element to target.
</li>
					<li>
<p>
次を与える下で， %部位 を`~viewの中へ~scrollする$
`CSSOMVIEW$r
⇒
align to top flag ~SET ~ON
◎
Use the scroll an element into view algorithm to scroll target into view, with the align to top flag set. [CSSOMVIEW]
</p>
<p class="trans-note">【
align to top flag は、現在の `CSSOMVIEW^r 仕様による手続きの入力と合致していない（が、相応するものはある）。
意味としては、 %部位 の上端が %文書 の表示域の上端に揃うように~scrollすることを表す（~layoutが横組みであれば）。
】</p>
					</li>
					<li>
`~objを~focusする$( %部位, %文書 の`表示域$ )
◎
Run the focusing steps for target, with the Document's viewport as the fallback target.
</li>
					<li>
%文書 における`逐次的~focus~naviの始点$ ~SET %部位
◎
Move the sequential focus navigation starting point to target.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

<p>
`文書$ %文書 内の
`指示された部位@doc
は、`素片$urlがあれば，それが指示するものになる。
`素片$urlから~nodeにどう対応付けるかの意味論は、
%文書 が利用している`~MIME型$を定義する仕様により定義される（例えば、`~XML~MIME型$に対する`素片$urlの処理は `RFC7303$r が責を負う）。
◎
The indicated part of the document is the one that the fragment, if any, identifies. The semantics of the fragment in terms of mapping it to a node is defined by the specification that defines the MIME type used by the Document (for example, the processing of fragments for XML MIME types is the responsibility of RFC7303). [RFC7303]
</p>


<p>
各 `文書$には、 `target$ps 疑似類を定義するために利用される
`標的~要素@
がある。
それは、初期~時は~NULLであり，上の~algoで更新される。
◎
There is also a target element for each Document, which is used in defining the :target pseudo-class and is updated by the above algorithm. It is initially null.
</p>


<p class="algo-head">
~HTML文書（および， `~HTML~MIME型$ ） %文書 に対しては、
%文書 内の`指示された部位$docを決定するときは，次の処理~modelに従わ~MUST。
◎
For HTML documents (and HTML MIME types), the following processing model must be followed to determine what the indicated part of the document is.
</p>

<ol>
	<li>
%素片 ~LET %文書 の`~URL$docの`素片$url
◎
Let fragment be the document's URL's fragment.
</li>
	<li>
~Assert：
%素片 ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
	<li>
~IF［
%素片 ~EQ 空~文字列
］
⇒
~RET `文書の上端^i
◎
If fragment is the empty string, then the indicated part of the document is the top of the document; return.
</li>
	<li>
~IF［
`指示された要素を見出す$( %文書, %素片 ) ~NEQ ~NULL
］
⇒
~RET その結果
◎
If find a potential indicated element with fragment returns non-null, than the return value is the indicated part of the document; return.
</li>
	<li>
%素片~byte列 ~SET `~byte列を~byte列に~percent-復号する$( %素片 )
【`文字列を~byte列に~percent-復号する$？】
◎
Let fragmentBytes be the result of percent-decoding fragment.
</li>
	<li>
%復号-済み素片 ~LET `BOMも失敗-もそのままに~UTF-8復号する$( %素片~byte列 )
◎
Let decodedFragment be the result of running UTF-8 decode without BOM or fail on fragmentBytes.
</li>
	<li>
~IF［
`指示された要素を見出す$( %文書, %復号-済み素片 ) ~NEQ ~NULL
］
⇒
~RET その結果
◎
If find a potential indicated element with decodedFragment returns non-null, than the return value is the indicated part of the document; return.
</li>
	<li>
~IF［
%復号-済み素片 ~EQ`大小無視$sub `top^l
］
⇒
~RET `文書の上端^i
◎
If decodedFragment is an ASCII case-insensitive match for the string top, then the indicated part of the document is the top of the document; return.
</li>
	<li>
~RET ε
◎
There is no indicated part of the document.
</li>
</ol>

<p class="algo-head">
`指示された要素を見出す@
ときは、所与の
( `文書$ %文書, 文字列 %素片 )
に対し，次を走らす：
◎
To find a potential indicated element given a string fragment, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 の`木~内$に［
`~ID$ ~EQ %素片
］なる要素はある
］
⇒
~RET 該当する要素のうち，`木~順序$で最初のもの
◎
If there is an element in the document tree that has an ID equal to fragment, then return the first such element in tree order.
</li>
	<li>
~IF［
%文書 の`木~内$に［
`name$a 属性を有していて，その値 ~EQ %素片
］なる `a$e 要素はある
］
⇒
~RET 該当する要素のうち，`木~順序$で最初のもの
◎
If there is an a element in the document tree that has a name attribute whose value is equal to fragment, then return the first such element in tree 
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>


<p>
この節に言及した~taskの`~task源$は
`~DOM操作~task源$で~MUST。
◎
The task source for the task mentioned in this section must be the DOM manipulation task source.
</p>



			</section>
			<section id="history-traversal">
<h3 title="History traversal">7.8.10. 履歴の走査</h3> 

<div >
<p class="algo-head">
~UAは，
`履歴を走査する@
よう要求されたときは、所与の：
</p>

<ul ><li>`~session履歴~entry$ %~entry
</li><li>`置換え可能化~flag$ （省略時は ~OFF ）
</li><li>`~non-blocking~event~flag^i （省略時は ~OFF ）
</li></ul>

<p>
に対し，次に従って動作し~MUST：
</p>
◎
When a user agent is required to traverse the history to a session history entry entry, optionally with replacement enabled, and optionally with the non-blocking events flag set, the user agent must act as follows.
</div>

<p class="note">注記：
この~algoは、明示的に`履歴を前／後に走査する$ときのみならず，他の状況においても呼出される
— 例えば、閲覧文脈を`~navigate$するときに，`新たな頁で~session履歴を更新-$する一部として。
◎
This algorithm is not just invoked when explicitly going back or forwards in the session history — it is also invoked in other situations, for example when navigating a browsing context, as part of updating the session history with the new page.
</p>

<ol>
	<li>
%履歴 ~LET %~entry が属する`~session履歴$
◎
↓</li>
	<li>
%B ~LET %履歴 を有する`閲覧文脈$
◎
↓</li>
	<li>
<p>
~IF［
%~entry はもはや`文書$を保持していない
］：
◎
If entry no longer holds a Document object, then＼
</p>

		<ol>
			<li>
`~entryを更新する$ためとして，
%~entry の`~URL$へ %B を`~navigate$する
◎
navigate the browsing context to entry's URL to perform an entry update of entry, and＼
</li>
			<li>
~RET
◎
return.＼
</li>
		</ol>

<p>
`~navigate$ ~algoは、走査を完了するために，この~algoを再度~呼出すことになる
— その時点では <em>`文書$はある</em>ので，この段は飛ばされることになる。
この~naviは、 %~entry の初回の作成-時に利用されていたものと同じ`~source閲覧文脈$を利用して行われ~MUST（これは、［
`置換え可能化~flag$ ~SET ~ON
］にされた下では決して起こり得ない）。
◎
The "navigate" algorithm reinvokes this "traverse" algorithm to complete the traversal, at which point there is a Document object and so this step gets skipped. The navigation must be done using the same source browsing context as was used the first time entry was created. (This can never happen with replacement enabled.)
</p>

<p class="note">注記：
資源が非冪等~動作を利用して得られたものであった場合（ 例えば `POST^hm による~form提出）や, 資源はもはや可用でない場合（例えば~computerは今や~offlineになっていて，頁も~cacheされていないため）など、再度そこへ~navigateできないこともある。
この事例では、~naviの結果は，以前と異なる頁になる
— 例えば，問題を説明する~error~messageや, ~formを再度~提出する~UIを提供するなど。
◎
If the resource was obtained using a non-idempotent action, for example a POST form submission, or if the resource is no longer available, for example because the computer is now offline and the page wasn't cached, navigating to it again might not be possible. In this case, the navigation will result in a different page than previously; for example, it might be an error message explaining the problem or offering to resubmit the form.
</p>

	</li>
	<li>
%現~entry ~LET %履歴 の`現在の~entry$
◎
↓</li>
	<li>
~IF［
%現~entry の~titleは［
`pushState()$m ／ `replaceState()$m
］~methodにより設定されていない
］
⇒
%現~entry の~title ~SET `document.title$m ~IDL属性の値を取得した結果
◎
If the current entry's title was not set by the pushState() or replaceState() methods, then set its title to the value returned by the document.title IDL attribute.
</li>
	<li>
適切になる, かつ ~UAが持続化するよう望む状態があれば、それらを反映するように，%現~entry を更新する
—
この~entryは、`持続的な利用者~状態$を伴うものとされる。
◎
If appropriate, update the current entry in the browsing context's Document object's History object to reflect any state that the user agent wishes to persist. The entry is then said to be an entry with persisted user state.
</li>
	<li>
%文書 ~LET %~entry の`文書$
◎
↓</li>
	<li>
%現~文書 ~LET %現~entry の`文書$（ ~EQ %B にて`作動中の文書$）
◎
↓</li>
	<li>
<p>
~IF［
%文書 ~NEQ %現~文書
］：
◎
If entry has a different Document object than the current entry, then run the following substeps:
</p>

		<ol>
			<li>
%B の`~top-level閲覧文脈$の`文書~族$内の ~EACH ( `文書$ ) に対し
⇒
`文書$に結付けられている`履歴~走査~task源$により~queueされた`~task$があれば，それらを除去する
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
			<li>
<p>
~IF［
( %文書 の`生成元$, %現~文書 の`生成元$ )
は`同一生成元$でない
］：
◎
If the origin of entry's Document object is not the same as the origin of the current entry's Document object, then run the following subsubsteps:
</p>

				<ol>
					<li>
%履歴 内の ~EACH ( ~entry %e ) に対し
⇒
~IF［
( %e の`文書$の`生成元$, %現~文書 の`生成元$ )
は`同一生成元$である
］~AND［
%e は %現~entry と連続的である
【<a href="~HISTORY#_contiguous">~~参照</a>】
］
⇒
%e の`閲覧文脈~名$ ~SET %B の`閲覧文脈~名$
◎
The current browsing context name must be stored with all the entries in the history that are associated with Document objects with the same origin as the active document and that are contiguous with the current entry.
</li>
					<li id="resetBCName">
~IF［
%B は`~top-level閲覧文脈$である
］~AND［
%B は`補助~閲覧文脈$でない
］
⇒
%B の`閲覧文脈~名$ ~SET 空~文字列
◎
If the browsing context is a top-level browsing context, but not an auxiliary browsing context, then set the browsing context's name to the empty string.
</li>
				</ol>
			</li>
			<li id="appcache-history-2">
%B にて`作動中の文書を設定する$( %文書 )
◎
Set the active document of the browsing context to entry's Document object.
</li>
			<li>
<p>
~IF［
%~entry の`閲覧文脈~名$ ~NEQ ε
］：
◎
If entry has a browsing context name, then run the following subsubsteps:
</p>

				<ol>
					<li>
%B の`閲覧文脈~名$ ~SET %~entry の`閲覧文脈~名$
◎
Set the browsing context's browsing context name to entry's browsing context name.
</li>
					<li>
%履歴 内の ~EACH ( ~entry %e ) に対し
⇒
~IF［
( %e の`文書$の`生成元$, %文書 の`生成元$ )
は`同一生成元$である
］~AND［
%e は %~entry と連続的である
］
⇒
%e の`閲覧文脈~名$ ~SET ε
◎
Clear any browsing context names of all entries in the history that are associated with Document objects with the same origin as the new active document and that are contiguous with entry.
</li>
				</ol>
			</li>
			<li id="history-autocomplete">
%文書 内の ~EACH ( ~form~control %E ) に対し
⇒
~IF［
%E の`自動充填~欄~名$ ~EQ `off$v
］
⇒
%E の`再設定~algo$を呼出す
◎
If entry's Document object has any form controls whose autofill field name is "off", invoke the reset algorithm of each of those elements.
</li>
			<li>
<p>
~IF［
%文書 の`現在の文書の準備度$ ~EQ `complete^l
］
⇒
次を走らす`~taskを~queueする$：
◎
If the current document readiness of entry's Document object is "complete", then queue a task to run the following subsubsteps:
</p>

				<ol>
					<li>
~IF［
%文書 の`頁~表示中~flag$doc ~EQ ~T
］
⇒
~RET
◎
If the Document's page showing flag is true, then abort these steps.
</li>
					<li>
%文書 の`頁~表示中~flag$doc ~SET ~T
◎
Set the Document's page showing flag to true.
</li>
					<li>
<p>
`適用-可能な仕様$により， %文書 に対し定義されている
`~session履歴~文書の可視性を変更する手続き@
があれば、それらを走らす
◎
Run any session history document visibility change steps for Document that are defined by other applicable specifications.
</p>

<p class="note">注記：
これは、 Page Visibility 仕様からの利用-に特に意図されている。
`PAGEVIS$r
◎
This is specifically intended for use by the Page Visibility specification. [PAGEVIS]
</p>

					</li>
					<li>
<p>
%文書 の`~window$に向けて，［
%旧来~上書target~flag ~SET ~ON
］を与える下で，次のようにされた`~eventを発火-$する
</p>

<ul ><li>名前 `pageshow$et
</li><li>`PageTransitionEvent$I ~interfaceを利用する
</li><li>`persisted$m 属性 ~SET ~T に初期化する
</li></ul>

◎
Fire an event named pageshow at the Document object's Window object, using PageTransitionEvent, with the persisted attribute initialized to true, and legacy target override flag set.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%文書 の`~URL$doc ~SET %~entry の`~URL$
◎
Set the document's URL to entry's URL.
</li>
	<li>
%~hash変化あり ~LET ~F
◎
↓</li>
	<li>
~IF［
%~entry の~URLの`素片$url ~NEQ %現~entry の`素片$url
］~AND［
%文書 ~EQ %現~文書
］
⇒＃
%~hash変化あり ~LET ~T；
%旧~URL ~LET %現~entry の~URL；
%新~URL ~LET %~entry の~URL
◎
If entry has a URL whose fragment differs from that of the current entry's when compared in a case-sensitive manner, and the two share the same Document object, then let hash changed be true, and let old URL be the current entry's URL and new URL be entry's URL. Otherwise, let hash changed be false.
</li>
	<li>
~IF［
`置換え可能化~flag@
~EQ ~ON
］
⇒
%履歴 内で %~entry の直前にある~entryを除去する
◎
If the traversal was initiated with replacement enabled, remove the entry immediately before the specified entry in the session history.
</li>
	<li>
~IF［
%~entry は`持続的な利用者~状態$を伴わない
］~AND［
%~entry の`~URL$の`素片$url ~NEQ ~NULL
］
⇒
`素片へ~scroll$する
◎
If entry is not an entry with persisted user state, but its URL's fragment is non-null, then scroll to the fragment.
</li>
	<li>
%履歴 の`現在の~entry$ ~SET %~entry
◎
Set the current entry to entry.
</li>
	<li>
%状態 ~LET %~entry の`直列形の状態$
◎
↓</li>
	<li>
~IF［
%状態 ~NEQ ~NULL
］
⇒
%状態 ~SET `StructuredDeserialize$jA( %状態, `現在の~Realm~Record$ )
⇒
例外が投出されたときは、~catchして
⇒
%状態 ~SET ~NULL （例外は無視する）
◎
Let targetRealm be the current Realm Record.
◎
If entry has serialized state, then let state be StructuredDeserialize(entry's serialized state, targetRealm). If this throws an exception, catch it, ignore the exception, and let statebe null.
◎
Otherwise, let state be null.
</li>
	<li>
`history.state$m ~SET %状態
◎
Set history.state to state.
</li>
	<li>
%状態~変化あり ~LET ［
%文書 の`最近の~entry$ ~NIN { ε, %~entry } ならば ~T ／
~ELSE_ ~F
］
◎
Let state changed be true if entry's Document object has a latest entry, and that entry is not entry; otherwise let it be false.
</li>
	<li>
%文書 の`最近の~entry$ ~SET %~entry
◎
Set entry's Document object's latest entry to entry.
</li>
	<li>
<p>
次に与える~taskを， `~non-blocking~event~flag^i に応じて
⇒
~OFF ならば`即時に$走らす ／
~ON ならば`~queueする$
◎
If the non-blocking events flag is not set, then run the following substeps immediately. Otherwise, the non-blocking events flag is set; queue a task to run the following substeps instead.
</p>

<p>
~taskは、次の下位手続きを走らす：
◎
↑</p>

		<ol>
			<li>
<p>
~IF［
%状態~変化あり ~EQ ~T
］
⇒
%文書 の`~window$に向けて，次のようにされた`~eventを発火-$する
</p>
<ul ><li>名前 `popstate$et
</li><li>`PopStateEvent$I ~interfaceを利用する
</li><li>`bubbles$m 属性 ~SET ~T に初期化する
</li><li>`state$m 属性 ~SET %状態 に初期化する
</li></ul>

◎
If state changed is true, then fire an event named popstate at the Document object's Window object, using PopStateEvent, with the bubbles attribute initialized to true and the state attribute initialized state.
</li>
			<li>
~IF［
%~entry は`持続的な利用者~状態$を伴う
］
⇒
~UAは、`持続的な利用者~状態を復旧-$して，
%文書 と その具現化の側面を更新して~MAY
◎
If entry is an entry with persisted user state, then the user agent may restore persisted user state and update aspects of the document and its rendering.
</li>
			<li>
<p>
~IF［
%~hash変化あり ~EQ ~T
］
⇒
%B の`~window$に向けて，次のようにされた`~eventを発火-$する：
</p>

<ul ><li>名前 `hashchange$et
</li><li>`HashChangeEvent$I ~interfaceを利用する
</li><li>`bubbles$m 属性 ~SET ~T に初期化する
</li><li>`oldURL$m 属性 ~SET %旧~URL に初期化する
</li><li>`newURL$m 属性 ~SET %新~URL に初期化する
</li></ul>

◎
If hash changed is true, then fire an event named hashchange at the browsing context's Window object, using HashChangeEvent, with the bubbles attribute initialized to true, the oldURL attribute initialized to old URL, and the newURL attribute initialized to new URL.
</li>
		</ol>
	</li>
</ol>

<p>
上に言及された~taskの`~task源$は
`~DOM操作~task源$で~MUST。
◎
The task source for the tasks mentioned above is the DOM manipulation task source.
</p>


				<section id="persisted-user-state-restoration">
<h4 title="Persisted user state restoration">7.8.10.1. 持続的な利用者~状態の復旧</h4>

<p class="algo-head">
~UAは、`~session履歴~entry$ %~entry から
`持続的な利用者~状態を復旧-@
するときは，次の手続きを即時に走らせ~MUST：
◎
When the user agent is to restore persisted user state from a history entry, it must run the following steps immediately:
</p>

<ol>
	<li>
%文書 ~LET %~entry の`文書$
◎
↓</li>
	<li>
<p>
~IF［
%~entry の`~scroll復旧~mode$ ~EQ `manual$l
］
⇒
~UAは、［
%文書 ／ %文書 の~scroll可能域
］に対する~scroll位置を復旧するべきでない
— ただし、~scroll可能域のうち，その~scroll復旧が［
%文書 が`入子にして$いる`閲覧文脈$の`~session履歴~entry$の`~scroll復旧~mode$
］により制御されているものは除く
</p>

<p>
~ELSE
⇒
~UAは、~scroll位置を復旧して~MAY
</p>

◎
If the entry has a scroll restoration mode, let scrollRestoration be that. Otherwise let scrollRestoration be "auto"
◎
If scrollRestoration is "manual" the user agent should not restore the scroll position for the Document or any of its scrollable regions, with the exception of any nested browsing contexts whose scroll restoration is controlled by their own history entry's scroll restoration mode, otherwise, it may do so.
</li>
	<li>
~UAの任意選択で
⇒
%文書 とその具現化の他の側面を更新する
— 具体例として，~UAが以前に記録した~form欄の値など。
◎
Optionally, update other aspects of the document and its rendering, for instance values of form fields, that the user agent had previously recorded.
</li>
</ol>

<p class="note">注記：
持続的~状態が，そのような~controlにおける利用者~入力の書字方向性を含む場合、これには，次に該当する要素の `dir$a 属性を更新することも含まれる
⇒
`textarea$e 要素 ／
`input$e 要素のうち ［
その `type$a 属性の状態 ~IN { `Text$st, `Search$st }
］なるもの
◎
This can even include updating the dir attribute of textarea elements or input elements whose type attribute is in either the Text state or the Search state, if the persisted state includes the directionality of user input in such controls.
</p>

<p class="note">注記：
~UAが~scroll位置を復旧しないことは、~scroll位置が特定0の値（例： (0,0) ）に~~維持されることを含意するものではない。
実際の~scroll位置は［
~naviの種別や, ~UAによる~caching-strategy
］に依存する。
なので、~web~appは，特定0の~scroll位置に決まるとは見做せない
— ~appには、自身が求めるものに設定することが督促される。
◎
Not restoring the scroll position by user agent does not imply that the scroll position will be left at any particular value (e.g., (0,0)). The actual scroll position depends on the navigation type and the user agent's particular caching strategy. So web applications cannot assume any particular scroll position but rather are urged to set it to what they want it to be.
</p>

				</section>
				<section id="the-popstateevent-interface">
<h4 title="The PopStateEvent interface">7.8.10.2. `PopStateEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window,
Constructor(DOMString type, optional `PopStateEventInit$I eventInitDict)]
interface `PopStateEvent@I : `Event$I {
  readonly attribute any `state$m;
};

dictionary `PopStateEventInit@I : `EventInit$I {
  any state = null;
};
</pre>

<dl class="domintro">
	<dt>%event . `state$m</dt>
	<dd>
`pushState()$m ／ `replaceState()$m
に供された情報の複製を返す。
◎
Returns a copy of the information that was provided to pushState() or replaceState().
</dd>
</dl>

<dl class="idl-def">
	<dt>`state@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The state attribute must return the value it was initialized to.＼
</dd>
	<dd>
この~eventに対する文脈~情報を表現する。
表現される状態が`文書$の初期~状態の場合は ~NULL になる。
◎
It represents the context information for the event, or null, if the state represented is the initial state of the Document.
</dd>
</dl>


				</section>
				<section id="the-hashchangeevent-interface">
<h4 title="The HashChangeEvent interface">7.8.10.3. `HashChangeEvent^I ~interface</h4>


<pre class="idl">
[Exposed=Window,
Constructor(DOMString type, optional `HashChangeEventInit$I eventInitDict)]
interface `HashChangeEvent@I : `Event$I {
  readonly attribute USVString `oldURL$m;
  readonly attribute USVString `newURL$m;
};

dictionary `HashChangeEventInit@I : `EventInit$I {
  USVString oldURL = "";
  USVString newURL = "";
};
</pre>

<dl class="domintro">
	<dt>%event . `oldURL$m</dt>
	<dd>
履歴を走査する直前の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that was previously current.
</dd>
	<dt>%event . `newURL$m</dt>
	<dd>
履歴を走査した直後の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that is now current.
</dd>
</dl>

<dl class="idl-def">
	<dt>`oldURL@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The oldURL attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、履歴を走査する直前の`~session履歴~entry$の~URLを，この~eventの文脈~情報として表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed from.
</dd>

	<dt>`newURL@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The newURL attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、履歴を走査した直後の`~session履歴~entry$の~URLを，この~eventの文脈~情報として表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed to.
</dd>
</dl>


				</section>
				<section id="the-pagetransitionevent-interface">
<h4 title="The PageTransitionEvent interface">7.8.10.4. `PageTransitionEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window,
Constructor(DOMString type, optional `PageTransitionEventInit$I eventInitDict)]
interface `PageTransitionEvent@I : `Event$I {
  readonly attribute boolean `persisted$m;
};

dictionary `PageTransitionEventInit@I : `EventInit$I {
  boolean persisted = false;
};
</pre>

<dl class="domintro">
	<dt>%event . `persisted$m</dt>
	<dd>
`pageshow$et ~eventに対しては、［
頁が新たに読込まれつつある（したがって `load$et ~eventが発火されることになる）ならば ~F ／
~ELSE_ ~T
］を返す。
◎
For the pageshow event, returns false if the page is newly being loaded (and the load event will fire). Otherwise, returns true.
</dd>
	<dd>
`pagehide$et ~eventに対しては、［
当の頁が最後に消え去るときには ~F ／
~ELSE_ ~T
］を返す。
~T は、この頁は，利用者がこの頁に~navigateして戻った場合に（その頁を回復可能でなくするものが他になければ）再利用され得ることを意味する。
◎
For the pagehide event, returns false if the page is going away for the last time. Otherwise, returns true, meaning that (if nothing conspires to make the page unsalvageable) the page might be reused if the user navigates back to this page.
</dd>
	<dd>
<p>
頁を回復不能にするものには次が含まれる：
</p>

<ul ><li>`document.open()$m
</li><li>`beforeunload$et ~eventに対する~listenerがあるとき
</li><li>`unload$et ~eventに対する~listenerがあるとき
</li><li>回復可能でない `iframe$e があるとき
</li><li>作動中の `WebSocket$I ~objがあるとき
</li><li>文書を`中止-$docしたとき
</li></ul>

◎
Things that can cause the page to be unsalvageable include:

• document.open()
• Listening for beforeunload events
• Listening for unload events
• Having iframes that are not salvageable
• Active WebSocket objects
• Aborting a Document 
</dd>

</dl>

<dl class="idl-def">
	<dt>`persisted@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The persisted attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは~eventの文脈~情報を表現する。
◎
It represents the context information for the event.
</dd>
</dl>

				</section>
			</section>
			<section id="unloading-documents">
<h3 title="Unloading documents">7.8.11. 文書の~unload法</h3>


<div>
<p>
`文書$は、次のものを持つ：
</p>

<dl>
	<dt>`回復可能~状態@doc</dt>
	<dd>
初期~時には ~T にされ~MUST。
</dd>

	<dt>`~unload発火済み~flag@doc</dt>
	<dd>
初期~時には ~F にされ~MUST。
</dd>

	<dt>`頁~表示中~flag@doc</dt>
	<dd>
初期~時には ~F にされ~MUST。
この~flagは、~scriptが［
`pageshow$et, `pagehide$et
］~eventを整合的に受信する（例： `pageshow$et を間に挟むことなく 2 つの `pagehide$et ~eventを続けて受信したり，その逆が生じることは決してない）ことを確保するために利用される。
</dd>
</dl>

◎
A Document has a salvageable state, which must initially be true, a fired unload flag, which must initially be false, and a page showing flag, which must initially be false. The page showing flag is used to ensure that scripts receive pageshow and pagehide events in a consistent manner (e.g. that they never receive two pagehide events in a row without an intervening pageshow, or vice versa).
</div>


<p>
各`~event-loop$は、
`終了入子~level@
と呼ばれる~counterを有する
— 初期~時には 0 にされ~MUST。
◎
Event loops have a termination nesting level counter, which must initially be 0.
</p>

<p class="algo-head">
%再帰~flag （省略時は ~OFF ）が与えられた下で，`文書$ %文書 の
`~unloadを~prompt@doc
するときは、次を走らす：
◎
To prompt to unload, given a Document object document and optionally a recursiveFlag, run these steps:
</p>

<ol>
	<li>
`~event-loop$の`終了入子~level$ ~INCBY 1
◎
Increase the event loop's termination nesting level by 1.
</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~INCBY 1
◎
Increase the document's ignore-opens-during-unload counter by 1.
</li>
	<li>
%event ~LET `BeforeUnloadEvent$I ~interfaceを利用する`~eventを作成-$した結果
◎
Let event be the result of creating an event using BeforeUnloadEvent.
</li>
	<li>
%event の
( `type$m, `cancelable$m )
属性 ~SET
( `beforeunload$et, ~T )
に初期化する
◎
Initialize event's type attribute to beforeunload and its cancelable attribute true.
</li>
	<li>
%文書 の`~window$に向けて %event を`配送-$する<!-- ＊ -->
◎
Dispatch: Dispatch event at document's Window object.
</li>
	<li>
`~event-loop$の`終了入子~level$ ~DECBY 1
◎
Decrease the event loop's termination nesting level by 1.
</li>
	<li>
~IF［
%event 配送-時に何らかの~event~listenerが誘発された
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If any event listeners were triggered by the earlier dispatch step, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
次のいずれも満たされる
］…：
◎
↓</p>

		<ul>
			<li>
`~sandbox化( ~modal )~flag$ ~NIN %文書 の`作動中の~sandbox用~flag集合$
◎
If document's active sandboxing flag set does not have its sandboxed modals flag set, and＼
</li>
			<li>
［
%event の `returnValue$m 属性 ~NEQ 空~文字列
］~OR［
%event は取消された
］
◎
the returnValue attribute of the event object is not the empty string, or if the event was canceled, then＼
</li>
		</ul>

<p>
…ならば
⇒
~UAは、利用者に %文書 の~unloadを望むかどうかを確認をとって~MAY：
◎
the user agent may ask the user to confirm that they wish to unload the document.
</p>

<p class="note">注記：
利用者に示される~messageは、~custom化することはできず，~UAにより決定される。
特に、 `returnValue$m 属性の実際の値は無視される。
◎
The message shown to the user is not customizable, but instead determined by the user agent. In particular, the actual value of the returnValue attribute is ignored.
</p>

		<ul>
			<li>
~UAは，そうすることが利用者にとって［
いらつく／紛らわしい／的外れである
］と判定したときは、利用者に確認をとらないことが奨励される。
単純な経験則として、利用者が %文書 とやりとりしていなければ，とらないことが挙げられる。
◎
The user agent is encouraged to avoid asking the user for confirmation if it judges that doing so would be annoying, deceptive, or pointless. A simple heuristic might be that if the user has not interacted with the document, the user agent would not ask for confirmation before unloading it.
</li>
			<li>
~UAは，利用者に確認をとる場合には、利用者の応答を待機している間，`一時停止-$し~MUST。
◎
If the user agent asks the user for confirmation, it must pause while waiting for the user's response.
</li>
			<li>
利用者から頁~naviの確認をとれなかった場合、
%文書 の
`~unloadを拒否-@doc
したとされる。
◎
If the user did not confirm the page navigation, then the user agent refused to allow the document to be unloaded.
</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%再帰~flag ~EQ ~OFF
］：
◎
If the recursiveFlag is not set, then:
</p>
		<ol>
			<li>
<p>
%文書 の`子孫~閲覧文脈~list$ 内の
~EACH ( `閲覧文脈$ %B ) に対し：
◎
Let descendants be the list of the descendant browsing contexts of document.
◎
For each browsingContext in descendants:
</p>
				<ol>
					<li>
%D ~LET %B にて`作動中の文書$
◎
↓</li>
					<li>
［
%再帰~flag ~SET ~ON
］を与える下で， %D の`~unloadを~prompt$docする
⇒
~IF［
利用者は文書の`~unloadを拒否-$docした
］
⇒
~BREAK
（利用者は、 %文書 についても暗黙的に`~unloadを拒否-$docしたことになる）
◎
Prompt to unload browsingContext's active document with the recursiveFlag set. If the user refused to allow the document to be unloaded, then the user implicitly also refused to allow document to be unloaded; break.
</li>
					<li>
~IF［
%D の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の `回復可能~状態$doc ~SET ~F
◎
If the salvageable state of browsingContext's active document is false, then set the salvageable state of document to false.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~DECBY 1
◎
Decrease the document's ignore-opens-during-unload counter by 1.
</li>
</ol>

<p class="algo-head">
~UAは，`文書$ %文書 を
`~unload@doc
するときは、次を走らせ~MUST
— 手続きには、次の引数も渡される
⇒
%recycle（~T または ~F ）
— ~T ならば %文書 を再利用することを指示する（ `document.open()$m ~methodは、これに ~T を渡して この手続きを呼出す）。
◎
When a user agent is to unload a document, it must run the following steps. These steps are passed an argument, recycle, which is either true or false, indicating whether the Document object is going to be re-used. (This is set by the document.open() method.)
</p>

<ol>
	<li>
`~event-loop$の`終了入子~level$ ~INCBY 1
◎
Increase the event loop's termination nesting level by one.
</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~INCBY 1
◎
Increase the Document's ignore-opens-during-unload counter by one.
</li>
	<li>
<p>
~IF［
%文書 の`頁~表示中~flag$doc ~EQ ~T
］：
◎
If the Document's page showing flag is false, then jump to the step labeled unload event below (i.e. skip firing the pagehide event and don't rerun the unloading document visibility change steps).
</p>
		<ol>
			<li>
%文書 の`頁~表示中~flag$doc ~SET ~F
◎
Set the Document's page showing flag to false.
</li>
			<li>
<p>
%文書 の`~window$に向けて，次のようにする下で 名前 `pagehide$et の`~eventを発火-$する
</p>

<ul ><li>`PageTransitionEvent$I ~interfaceを利用する
</li><li>`persisted$m 属性 ~SET ［
%文書 の `回復可能~状態$doc ~EQ ~T ならば ~T ／
~ELSE_ ~F
］に初期化する
</li><li>%旧来~上書target~flag ~SET ~ON
</li></ul>

◎
Fire an event named pagehide at the Document object's Window object, using PageTransitionEvent, with the persisted attribute initialized to true if the Document object's salvageable state is true, and false otherwise, and legacy target override flag set.
</li>
			<li>
<p>
%文書 に対し
`適用-可能な仕様$により定義される
`~unload中の文書の可視性を変更する手続き@doc
があれば，それらを走らす
◎
Run any unloading document visibility change steps for Document that are defined by other applicable specifications.
</p>

<p class="note">注記：
これは、 Page Visibility 仕様からの利用-に特に意図されている。
`PAGEVIS$r
◎
This is specifically intended for use by the Page Visibility specification. [PAGEVIS]
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%文書 の`~unload発火済み~flag$doc ~EQ ~F
］
⇒
%文書 の`~window$に向けて，［
%旧来~上書target~flag ~SET ~ON
］の下で，名前 `unload$et の`~eventを発火-$する
◎
Unload event: If the Document's fired unload flag is false, then fire an event named unload at the Document's object Window object, with legacy target override flag set.
</li>
	<li>
`~event-loop$の`終了入子~level$ ~DECBY 1
◎
Decrease the event loop's termination nesting level by one.
</li>
			<li>
~IF［
前~前~段にて，何らかの~event~listenerが誘発された
］
⇒＃
%文書 の`回復可能~状態$doc ~SET ~F；
%文書 の`~unload発火済み~flag$doc ~SET ~T
◎
If any event listeners were triggered by the earlier unload event step, then set the Document object's salvageable state to false and set the Document's fired unload flag to true.
</li>
	<li>
%文書 に対し［
この仕様も含む `適用-可能な仕様$
］にて定義される
`~unload時の片付け手続き$docがあれば，それらを走らす
◎
Run any unloading document cleanup steps for Document that are defined by this specification and other applicable specifications.
</li>
	<li>
<p>
~IF［
この手続きの~instanceは、下の段 `(A)^i から呼出されたものではない
］：
◎
If this algorithm was invoked by another instance of the "unload a document" algorithm (i.e. by the steps below that invoke this algorithm for all descendant browsing contexts), then jump to the step labeled end.
</p>
		<ol>
			<li>
%子孫~list ~LET %文書 の`子孫~閲覧文脈~list$
◎
Let descendants be the list of the descendant browsing contexts of the Document.
</li>
			<li>
<p>
%子孫~list 内の ~EACH ( `閲覧文脈$ %B ) に対し：
◎
If descendants is not an empty list, then for each browsing context b in descendants run the following substeps:
</p>

				<ol>
					<li>
%作動中の文書 ~LET %B にて`作動中の文書$
◎
↓</li>
					<li>
`(A)^i：［
%recycle ~SET ~F
］を与える下で
%作動中の文書 を`~unload$docする
◎
Unload the active document of the browsing context b with the recycle parameter set to false.
</li>
					<li>
~IF［
%作動中の文書 の `回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If the salvageable state of the active document of the browsing context b is false, then set the salvageable state of this document to false also.
</li>
				</ol>
			</li>
			<li>
~IF［
%文書 の`回復可能~状態$doc ~EQ ~F
］~AND［
%recycle ~EQ ~F
］
⇒
%文書 を`破棄-$docする
◎
If both the Document's salvageable state and recycle are false, then the Document's browsing context must discard the Document.
</li>
		</ol>
	</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~DECBY 1
◎
End: Decrease the Document's ignore-opens-during-unload counter by one.
</li>
</ol>

<p class="algo-head">
この仕様は、`文書$ %文書 に対する
`~unload時の片付け手続き@doc
を定義する。
他の仕様も、~unload時の片付け手続きとして，他の手続きを定義できる。
◎
This specification defines the following unloading document cleanup steps. Other specifications can define more.
</p>

<ol>
	<li>
%~window ~LET %文書 の`~window$
◎
Let window be the Document's Window object.
</li>
	<li>
~EACH ( `WebSocket$I ~obj %O ) に対し
⇒
~IF［
%O に`関連する大域~obj$ ~EQ %~window
］
⇒
%O を`消滅させる$
◎
For each WebSocket object webSocket whose relevant global object is equal to window, make disappear webSocket.
</li>
	<li>
~IF［
前~段により影響された `WebSocket$I ~objはある
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If this affected any WebSocket objects, then set the Document's salvageable state to false.
</li>
	<li>
<p>
~IF［
%文書 の`回復可能~状態$doc ~EQ ~F
］：
◎
If the Document's salvageable state is false, run the following substeps:
</p>
		<ol>
			<li>
~EACH ( `EventSource$I ~obj %O ) に対し
⇒
~IF［
%O に`関連する大域~obj$ ~EQ %~window
］
⇒
%O を`強制的に閉じる$
◎
For each EventSource object eventSource whose relevant global object is equal to window, forcibly close eventSource.
</li>
			<li>
%文書 の`~window$の`作動中の~timer~list$を空にする
◎
Empty window's list of active timers.
</li>
		</ol>
	</li>
</ol>


				<section id="the-beforeunloadevent-interface">
<h4 title="The BeforeUnloadEvent interface">7.8.11.1. `BeforeUnloadEvent^I ~interface</h4>

<pre class="idl">
[Exposed=Window]
interface `BeforeUnloadEvent@I : `Event$I {
  attribute DOMString `returnValue$m;
};
</pre>


<p class="note">注記：
`BeforeUnloadEvent$I に特有の初期化~methodはない。
◎
There are no BeforeUnloadEvent-specific initialization methods.
</p>

<p>
`BeforeUnloadEvent$I
~interfaceは、旧来の~interfaceである
— それは、~eventを取消すのみならず，
`returnValue$m 属性を空~文字列でない値に設定することで
`~unloadを~prompt$docする処理を制御できるようにする。
作者は `returnValue$m を利用する代わりに `preventDefault()$m ~method, または~eventを取消す他の手段を利用するべきである。
◎
The BeforeUnloadEvent interface is a legacy interface which allows prompting to unload to be controlled not only by canceling the event, but by setting the returnValue attribute to a value besides the empty string. Authors should use the preventDefault() method, or other means of canceling events, instead of using returnValue.
</p>

<dl class="idl-def">
	<dt>`returnValue@m</dt>
	<dd>
この属性は、文書の`~unloadを~prompt$docする処理-を制御する。
◎
The returnValue attribute controls the process of prompting to unload.＼
</dd>
	<dd>
~eventの作成-時には、この属性は空~文字列に設定され~MUST。
◎
When the event is created, the attribute must be set to the empty string.＼
</dd>
	<dd>
取得子は、この属性に最後に設定された値を返さ~MUST。
◎
On getting, it must return the last value it was set to.＼
</dd>
	<dd>
設定子は、この属性を所与の値に設定し~MUST。
◎
On setting, the attribute must be set to the new value.
</dd>
	<dd class="note">注記：
この属性が `DOMString^I にされているのは、もっぱら歴史的~理由による。
空~文字列~以外のどの値も，利用者に確認をとるよう要請するものと扱われる。
◎
This attribute is a DOMString only for historical reasons. Any value besides the empty string will be treated as a request to ask the user for confirmation.
</dd>
</dl>

				</section>
			</section>
			<section id="aborting-a-document-load">
<h3 title="Aborting a document load">7.8.12. 文書~読込の中止-法</h3>

<p class="algo-head">
~UAは，`文書$ %文書 が
`中止-@doc
されたときは、次を走らせ~MUST：
◎
If a Document is aborted, the user agent must run the following steps:
</p>

<ol>
	<li>
<p>
%文書 が`属する閲覧文脈$の ~EACH ( `子~閲覧文脈$ %子 ) に対し：
</p>
		<ol>
			<li>
%子~文書 ~LET %子 にて`作動中の文書$
</li>
			<li>
%子~文書 を`中止-$docする
</li>
			<li>
~IF［
%子~文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
</li>
		</ol>

◎
Abort the active documents of every child browsing context. If this results in any of those Document objects having their salvageable state set to false, then set this Document's salvageable state to false also.
</li>
	<li>
<p>
~IF［
%文書 の文脈~下にある`~fetch$~algoの~instanceたちがある
］：
</p>
		<ol>
			<li>
<p>
それらを取消す
— 以降：
</p>
<ul ><li>それらに対し`~queueされ$る`~task$は破棄する
</li><li>それらに対し~networkから受信される更なる~dataは破棄する
</li></ul>
			</li>
			<li>
%文書 の`回復可能~状態$doc ~SET ~F
</li>
		</ol>

◎
Cancel any instances of the fetch algorithm in the context of this Document, discarding any tasks queued for them, and discarding any further data received from the network for them. If this resulted in any instances of the fetch algorithm being canceled or any queued tasks or any network data getting discarded, then set the Document's salvageable state to false.
</li>
	<li>
<p>
~IF［
%文書 には`作動中の構文解析器$がある
］：
</p>
		<ol>
			<li>
その`構文解析器を中止する$
</li>
			<li>
%文書 の`回復可能~状態$doc ~SET ~F
</li>
		</ol>
◎
If the Document has an active parser, then abort that parser and set the Document's salvageable state to false.
</li>
</ol>

<p>
~UAは、利用者が`文書$に対し明示的に`中止-$docする~algoを呼出すことを許容して~MAY。
利用者がそれをした場合、その`文書$が`作動中の文書$であるならば、~UAは，`中止-$docする~algoを呼出す前に，その`文書$の`~window$に向けて，名前 `abort$et の`~eventを発火-$する`~taskを~queueする$べきである。
◎
User agents may allow users to explicitly invoke the abort a document algorithm for a Document. If the user does so, then, if that Document is an active document, the user agent should queue a task to fire an event named abort at that Document's Window object before invoking the abort algorithm.
</p>


		</section>

		<section id="offline">
<h2 title="Offline Web applications">7.9. ~offline~Web~app</h2>

<p class="critical">
この特色機能は、~Web~platformから除去されつつある過程にある（何年もかかるであろう）。
今では、~offline~Web~app特色機能は，利用しないことが強く奨励される。
代わりに、~service-worker `SW$r を利用すること。
◎
This feature is in the process of being removed from the Web platform. (This is a long process that takes many years.) Using any of the offline Web application features at this time is highly discouraged. Use service workers instead. [SW]
</p>

<p class="trans-note">【
以下、この節の内容は未訳。
このサイトのこの仕様の和訳における
`~app~cache関連の…@appCache
と記された箇所も未訳であり、実際の原文では，この節にて定義される各種~用語を利用する内容が記述されている。
言い換えれば、和訳は，~UAがこの節に述べられる機能を~supportしていないかのように単純化して記述している。
】</p>


		</section>


</section></main>
