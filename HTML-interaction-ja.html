<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — User interaction（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/interaction.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 151224 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		ps: 'pseudo',
		P: 'production',
		p: 'property',
		st: 'attr-state',
		css: 'css',
		v: 'value',
		E: 'error',
		uc: 'unicode-category', // Unicode character class
		h: 'header',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		hd: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		ps: 'code',
		st: 'span',
		h: 'code',
		P: 'code',
		p: 'code',
		css: 'code',
		uc: 'span',
		samp: 'samp',
		v: 'code',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
//	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN', '_toc_list0');


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
//var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a': // event type
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'et': // event type
	break;
case 'i': // model constants
	break;
case 'h': // http header
	text = '<code class="header">' + text + '</code>';
	break;
case 'v': // attr value
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
</script>


<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">

I.Document:~HTMLDOM#document
I.ElementContentEditable:#elementcontenteditable
I.Element:~DOM4#interface-element
I.File:~FILEAPI#file
I.FileList:~FILEAPI#filelist-section
I.FocusEvent:~UIEVENTS#interface-FocusEvent
I.Node:~DOM4#interface-node
I.Text:~DOM4#interface-text
I.Window:~BROWSERS#window
I.Selection:https://w3c.github.io/selection-api/#idl-def-Selection
E.SyntaxError:~WEBIDL#syntaxerror


■e
e.a:~HTML5/semantics.html#the-a-element
e.area:~HTML-EMB#the-area-element
e.body:~HTML5/semantics.html#the-body-element
e.button:~HTML-FORMS#the-button-element
e.canvas:~HTML5/scripting.html#the-canvas-element
e.details:~HTML-FORMS#the-details-element
e.dialog:~HTML-FORMS#the-dialog-element
e.div:~HTML5/semantics.html#the-div-element
e.form:~HTML-FORMS#the-form-element
e.iframe:~HTML-EMB#the-iframe-element
e.img:~HTML-EMB#the-img-element
e.input:~HTML-FORMS#the-input-element
e.label:~HTML-FORMS#the-label-element
e.link:~HTML5/semantics.html#the-link-element
e.menuitem:~HTML-FORMS#the-menuitem-element
e.object:~HTML-EMB#the-object-element
e.output:~HTML-FORMS#the-output-element
e.select:~HTML-FORMS#the-select-element
e.textarea:~HTML-FORMS#the-textarea-element
	＊e.the body element:~HTMLDOM#the-body-element-2
e.video:~HTML-EMB#the-video-element


■DOM
m.istrusted:~DOM4#dom-event-istrusted
m.accessKey:#dom-accesskey
m.accessKeyLabel:#dom-accesskeylabel
m.activeElement:#dom-document-activeelement
m.＊blur:#dom-blur
m.blur:#dom-window-blur
m.click:#dom-click
m.contentEditable:#dom-contenteditable
m.execCommand:#execCommand
m.＊focus:#dom-focus
m.focus:#dom-window-focus
m.forceSpellCheck:#dom-forcespellcheck
m.hasFocus:#dom-document-hasfocus
m.hidden:#dom-hidden
m.isContentEditable:#dom-iscontenteditable

m.queryCommandEnabled:#dom-document-querycommandenabled
m.queryCommandIndeterm:#dom-document-querycommandindeterm
m.queryCommandState:#dom-document-querycommandstate
m.queryCommandSupported:#dom-document-querycommandsupported
m.queryCommandValue:#dom-document-querycommandvalue

m.spellcheck:#dom-spellcheck
m.tabIndex:#dom-tabindex
	＊
m.relatedTarget:~UIEVENTS#dom-focusevent-relatedtarget
m.detail:~UIEVENTS#dom-uievent-detail
m.view:~UIEVENTS#dom-uievent-view
m.showModal:~HTML-FORMS#dom-dialog-showmodal

■css
p.outline:~CSSUI#outline
p.overflow:~CSSWG/css-overflow/#propdef-overflow
p.white-space:~CSSTEXT#white-space-property

■#attr-
a.contenteditable:#attr-contenteditable
a.form:~HTML-FORMS#attr-fae-form
a.href:~HTML5/semantics.html#attr-hyperlink-href
a.＊href:~HTML5/semantics.html#attr-link-href
a.open:~HTML-FORMS#attr-dialog-open
a.pattern:~HTML-FORMS#attr-input-pattern
a.readonly:~HTML-FORMS#attr-input-readonly
a.＊readonly:~HTML-FORMS#attr-textarea-readonly
a.spellcheck:#attr-spellcheck
a.src:~HTML-EMB#attr-img-src
a.tabindex:#attr-tabindex
a.title:~HTMLDOM#attr-title
a.type:~HTML-FORMS#attr-input-type

a.accesskey:#the-accesskey-attribute
	a.dropzone:#the-dropzone-attribute
a.hidden:#the-hidden-attribute
a.aria-describedby:https://w3c.github.io/aria/aria/aria.html#aria-describedby

a.draggable:~HTMLDND#the-draggable-attribute


■event
et.blur:~HTML5/indices.html#event-blur
et.change:~HTML5/indices.html#event-change
et.click:~UIEVENTS#event-type-click
et.focus:~HTML5/indices.html#event-focus
et.mousedown:~UIEVENTS#event-type-mousedown
et.mousemove:~UIEVENTS#event-type-mousemove
et.mouseover:~UIEVENTS#event-type-mouseover

■
	<a href="">:~HTML5/semantics.html#the-a-element-
	c.<input type=number>:~HTML-FORMS#number-state-(type=number)-
	c.<input type=range multiple>:~HTML-FORMS#range-state-(type=range)
	c.<input type=text>:~HTML-FORMS#text-(type=text)-state-and-search-state-(type=search)-
m.designMode:#designMode


■
c.application/microdata+json:~HTML5/iana.html#application/microdata+json
l.application/octet-stream:~IETF/rfc2046#section-4.5.1
	~applyする:~HTML-FORMS#concept-input-apply

文書:#_document
要素:#_element
~tabindex値:#_focusable-area-tabindex-value

~ASCII大小無視:~HTMLINFRA#ascii-case-insensitive

現在の標的~要素:#current-target-element

選択を削除-:#delete-the-selection
配送-:~HTMLINFRA#concept-event-dispatch
~HTML要素:~HTMLINFRA#html-elements

~MIME型:~HTMLINFRA#mime-type
st.Action:~HTML-FORMS#command-facet-action
st.Disabled State:~HTML-FORMS#command-facet-disabledstate
st.Hidden State:~HTML-FORMS#command-facet-hiddenstate
st.E-mail:~HTML-FORMS#e-mail-state-(type=email)
st.Hidden:~HTML-FORMS#hidden-state-(type=hidden)
st.Number:~HTML-FORMS#number-state-(type=number)
st.Password:~HTML-FORMS#password-state-(type=password)
st.Search:~HTML-FORMS#text-(type=text)-state-and-search-state-(type=search)
st.Tel:~HTML-FORMS#telephone-state-(type=tel)
st.Text:~HTML-FORMS#text-(type=text)-state-and-search-state-(type=search)
st.URL:~HTML-FORMS#url-state-(type=url)


l.text/plain:~IETF/rfc2046#section-4.1.3
l.text/uri-list:~HTML5/indices.html#text/uri-list

x.~CSS~pixel:~CSSVAL#valdef-length-px
x.絶対~URL:~URLSpec#syntax-url-absolute
x.相対~URL:~URLSpec#syntax-url-relative
	＊
x.内在的~size:https://drafts.csswg.org/css2/conform.html#intrinsic
x.~node文書:~DOM4#concept-node-document
x.被support~prop~index:~WEBIDL#dfn-supported-property-indices
x.被support~token~s:~DOM4#concept-supported-tokens
x.木~順序:~DOM4#concept-tree-order
x.表示域:~CSS2VISUREN#viewport

作動化の挙動:#activation-behaviour
作動中の文書:~BROWSERS#active-document
作動範囲:#active-range
実際には不能化され:~HTML5/scripting.html#concept-element-disabled
あてがわれている~access~key:#assigned-access-key
具現化され:~HTMLRENDERING#being-rendered
~modal~dialogにより阻止-:#blocked-by-a-modal-dialog
~modal~dialogが示され:~HTML-FORMS#dom-dialog-showmodal

~body要素:~HTMLDOM#the-body-element-2
真偽~属性:~HTMLINFRA#boolean-attribute

閲覧文脈~容器:~BROWSERS#browsing-context-container
閲覧文脈:~BROWSERS#browsing-context
doc.閲覧文脈:~BROWSERS#concept-document-bc
子~閲覧文脈:~BROWSERS#child-browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-context
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
親~閲覧文脈:~BROWSERS#parent-browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context

	関連する~canvas~fallback内容として利用中にある:~HTML5/scripting.html#being-used-as-relevant-canvas-fallback-content
	~canvas~MouseEvent~rerouting手続き:~HTML5/scripting.html#canvas-mouseevent-rerouting-steps
大小区別:~HTMLINFRA#case-sensitive
~commands:~HTML-FORMS#concept-command
~control群:#control-group
~home~control群:#home-control-group
首~control群:#primary-control-group
所有者~obj:#control-group-owner-object
	~control群~所有者~obj:#control-group-owner-object

~UIにより利用者に公開されている~control:~HTML-EMB#expose-a-user-interface-to-the-user
~ASCII小文字~化:~HTMLINFRA#converted-to-ascii-lowercase
~commandを定義する:~HTML-FORMS#concept-command

~dialog群:#dialog-group
~dialog群~manager:#dialog-group-manager
~manager:#dialog-group-manager
指名focus~dialog:#focused-dialog-of-the-dialog-group
不能化され:~HTML-FORMS#concept-fe-disabled
不能化-:~HTML5/scripting.html#concept-element-disabled
配送-:~HTMLINFRA#concept-event-dispatch

編集可能:#editable
編集中の~host:#editing-host
列挙~属性:~HTMLINFRA#enumerated-attribute
明に不活:#expressly-inert-control
dlg.明に不活:#expressly-inert-dialog

~click~eventを発火-:~WAPI#fire-a-click-event
~focus~eventを発火-:#fire-a-focus-event
単純~eventを発火-:~WAPI#fire-a-simple-event


~focus鎖:#focus-chain
~focusを~gain:#gains-focus
~focus更新~手続き:#focus-update-steps
可focus域:#focusable-area
	＊可focus:#focusable-area
~top-level閲覧文脈の現focused域:#currently-focused-area-of-a-top-level-browsing-context
現focused域:#currently-focused-area-of-a-top-level-browsing-context

指名focus域:#focused-area-of-the-control-group
	~control群の被focus域:#focused-area-of-the-control-group
	~that~focus群の被focus域:#focused-area-of-the-control-group
相応しい逐次的~可focus域:#suitable-sequentially-focusable-area

	被focus:#bc-focus-ergo-bcc-focus
	`被focus:#focused
~focusされ:#focused
~unfocusする手続き:#unfocusing-steps

~focusする手続き:#focusing-steps
~has~focus手続き:#has-focus-steps

~home逐次的~focus~navigation順序:#home-sequential-focus-navigation-order
~focus~lock~flag:#locked-for-focus
逐次的~focus~navigation順序:#sequential-focus-navigation-order
逐次的~focus~navigationの始点:#sequential-focus-navigation-starting-point
始点:#sequential-focus-navigation-starting-point
逐次的~focus~navigation:#sequential-focus-navigation
~tabindex~focus~flag:#specially-focusable
~focus修復~規則 1:#focus-fixup-rule-one
~focus修復~規則 3:#focus-fixup-rule-three
~focus修復~規則 2:#focus-fixup-rule-two

~hyperlink:~HTML5/semantics.html#hyperlink
	適切になるなら:#concept-platform-dropeffect-override
	concept-platform-dropeffect-override-
画像~map:~HTML-EMB#image-map
~immediate利用者~selection:#immediate-user-selection
即時に:~HTMLINFRA#immediately
文書~内にある:~DOM4#in-a-document
文書~要素:~DOM4#document-element
不活:#inert
不活ness:#inert-
既定の挙動:#concept-spellcheck-default
既定で継承-:#concept-spellcheck-default-inherit
既定で ~T:#concept-spellcheck-default-true
既定で ~F:#concept-spellcheck-default-false

対話的~内容:~HTMLDOM#interactive-content-2
妥当でない値に対する既定の状態:~HTMLINFRA#invalid-value-default
~live:~HTMLINFRA#live
	＊~might~expose:~HTML-FORMS#expose-commands-in-ui
値なしに対する既定の状態:~HTMLINFRA#missing-value-default
変異可能:~HTML-FORMS#concept-fe-mutable
最近傍の作動化可能な要素:#nearest-activatable-element

相対的に構文解析-:~HTMLINFRA#parse-a-url
~taskを待入する:~WAPI#queue-a-task
読専~配列:~HTMLINFRA#dfn-read-only-array

i.被保護~mode:#concept-dnd-p
i.読専~mode:#concept-dnd-ro
i.可書~mode:#concept-dnd-rw

反映-:~HTMLINFRA#reflect
表現-:~HTMLDOM#represents
	＊根~要素:~HTMLINFRA#root-element
整数として構文解析-:~HTMLINFRA#rules-for-parsing-integers
~authentic~click作動化~手続きを走らす:#run-authentic-click-activation-steps
取消時の作動化~手続きを走らす:#run-canceled-activation-steps
取消時の作動化~手続き:#canceled-activation-steps
~click後の作動化~手続きを走らす:#run-post-click-activation-steps
~click前の作動化~手続きを走らす:#run-pre-click-activation-steps
~click前の作動化~手続き:#pre-click-activation-steps
合成~click作動化~手続きを走らす:#run-synthetic-click-activation-steps
	:~HTML-FORMS#concept-input-type-file-selected
逐次的~navigation探索~algo:#sequential-navigation-search-algorithm
~source~node:#source-node
空白類:~HTMLINFRA#space-character

空白並びで分割-:~HTMLINFRA#split-a-string-on-spaces
~trusted:~HTMLINFRA#concept-events-trusted
空白区切りの一意な~tokenからなる有順序~集合:~HTMLINFRA#ordered-set-of-unique-space-separated-tokens
	具現化~節にて推薦されている規則:~HTMLRENDERING#hiddenCSS
妥当な整数:~HTMLINFRA#valid-integer
fe.値:~HTML-FORMS#concept-fe-value

~DOM~anchor:#dom-anchor


</script>

<!-- 
■重複
browsing context:~BROWSERS#browsing-context
＊browsing context:~BROWSERS#concept-document-bc
＊blur:#dom-blur
blur:#dom-window-blur
＊focus:#dom-focus
focus:#dom-window-blur
＊focus:#dom-focus
href:~HTML5/semantics.html#attr-hyperlink-href
＊href:~HTML5/semantics.html#attr-link-href
readonly:~HTML-FORMS#attr-input-readonly
＊readonly:~HTML-FORMS#attr-textarea-readonly

 -->

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
BROWSERS:https://html.spec.whatwg.org/multipage/browsers.html
HTML-FORMS:https://html.spec.whatwg.org/multipage/forms.html
HTML-EMB:https://html.spec.whatwg.org/multipage/embedded-content.html
HTMLRENDERING:HTML-rendering-ja.html
	RFC7232:RFC7232-ja.html

	head0:<code class="attr">head</code> 
	html0:<code class="attr">html</code> 
	body0:<code class="attr">body</code> 
	title0:<code class="attr">title</code> 
	lang: <code class="attr">lang</code> 
此れ:<b>これ°</b>
</script>


<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">

	逐次的~focus~navigation順序
	~focus~navigation序列

blur:
focus:
可focus:focusable::可 focus
	unfocused::::
	~unfocus時の:unfocusing::::
	focusing::::フォーカスing
	focus時の:focusing
被focus:focused::被 focus
現focused:current focused:現在の被 focus
`~top-level閲覧文脈$
指名focus:designated focused::指名 focused
tabindex:
shape:
control::::コントロール
dialog::::ダイアログ
修復:fixup::~
	~focus修復:focus-fixup
entry::::エントリ
event::::イベント
fallback::::フォールバック
scroll::::スクロール
scrollable::::スクロール可能
scrollbar::::スクロールバー
tab::::タブ
top-level::::トップレベル
widget::::
window::::ウィンドウ
容器:container:::コンテナ
到達-:reach:~
作動中の:active:~
作動中:active:~
作動化-:activate:~
作動化:activation:~
作動化の:activation:~

対象0:subject:対象


pop:

API::::
ASCII::::
DOM::::
HTML::::
IDL::::
UA::::
UI::::
Unicode::::
Web::::
access::::アクセス
accessibility::access 容易性::アクセス容易性
address::::アドレス
algo:algorithm:::アルゴリズム
anchor::::アンカー
app:application:::アプリ
前方:forward::~
後方:backward::~
canvas:
overflow:
panel::::パネル
screen::::スクリーン
	block::::ブロック
browser::::ブラウザ
buffer::::バッファ
button::::ボタン
box::::ボックス
bullet::::ビュレット
call::::
click-in-progress::::
click::::クリック
command::::コマンド
data::::データ
drag::::ドラッグ
drop::::ドロップ
engine::::エンジン
error::::エラー
誤り:error::~::エラー

field::::フィールド
file::::ファイル
flag::::フラグ

	designated focused
form::::フォーム
形成-:form:~
game::::ゲーム
graphic::::グラフィック
graphical::::グラフィック的
header::::ヘッダ
hint::::ヒント
host::::ホスト
hyperlink::::ハイパーリンク
interface::::インタフェース

群:group::~::グループ
manager::::マネージャ
不活:inert::~
不活ness:
inertness::::
lock::::ロック
modal::::モダール
navigate::::ナビゲート
navigation::::ナビゲーション


item::::アイテム
key::::キー
keyboard::::キーボード
keyword::::キーワード
label::::ラベル
link::::リンク
list::::リスト
literal::::リテラル
log-in:log in:::ログイン
logic::::ロジック
	loop::::ループ
main::::メイン
	map::::マップ
	mark::::
markup::::マークアップ
menu::::メニュー
method::::メソッド
model::::モデル
mouse::::マウス
node::::ノード
obj:object:::オブジェクト
platform::::プラットフォーム
pointing::::ポインタ指示
program::::プログラム
prop:property:::プロパティ
script::::スクリプト
所在bar:location bar:所在 bar
style::::スタイル
stylesheet:style sheet:::スタイルシート
shortcut::::ショートカット
site::::サイト
space::::
support::::サポート
system::::システム
level::::レベル
text::::テキスト
time::::
token::::トークン
trusted::::
version::::バージョン


zero::::ゼロ

十key:numeric keypad:::テンキーの類

一般:general:~
上書き:override:~
不在:absent:~
不正:incorrect:~
不能化-:disable:~
不能化:disabled:~
	不能化され:disabled:~
可能化-:enable:~
可能化:enabled:~
	可能化され:enabled:~
事例:case:~
可能0:possible:可能
理由:reason:~
仕方:way:~
仕様:specification:~
仕組み:mechanism:~
機構:mechanism:~
付加-:append:~
代替:alternative:~
	位置:position:~
作成-:create:~
作者:author:~
例外:exception:~
供与-:contribute:~
依存-:depend:~
依存:dependent:~
保つ:keep する:~
保護-:protect:~
値:value:~
	停止-:stop:~
	なくなった:stop
先祖:ancestor:~
先行-:precede:~
頭部の:leading:~
入力:input:~
入子に:nest:入れ子に
入子の:nested:入れ子の
full::::フル
公開-:expose:~
共通的に:common に:よく
具現化-:render:~
具現化:rendering:~
内側:inside:~
内容:content:~
再利用:reuse:~
再度:again:~
再設定-:reset:~
処理:processing:~
出力:output:~
分割-:split:~
初期化-:initialise:~
初期時には:initially:~
利用-:use:~
利用者:user:~
	到達できない:unreachable:~
	到達できる:reachable:~
制約:restriction:~
効果:effect:~
動作-:act:~
動作:action:~
包含-:contain:~
行0:line:行
折返す:wrap する:~
折返され:wrap され:~
折返し:wrapping:~
単独の:single:~
単語:word:~
即時:immediate:~
直に:immediate に:~
直の:immediate:~
即時に:immediately:~
参照-:reference:~
反映-:reflect:~
	取得-／ようになる:get:~
取扱わせ:handle させ:~
取扱い:handling:~
取消す:cancel する:取り消す
取消され:cancel され:取り消され
取消時:cancel 時:取り消し時
取消可能:cancelable:~
可用:available:~
合成:synthetic:~
合致-:match:~
合間:between:~
名:name:~
名前:name:~
呈示:presentation:~
呼出され:invoke され:呼び出され
呼出せる:invoke できる:呼び出せる
問題:problem:~
因子:factor:~
域:area:~
報告-:report:~
境界点:boundary point:~
声:voice:~
変更-:change:~
変化-:change:~
変更点:changes:~
外側:outside:~
失った:lose した:~
奨励-:encourage:~
妥当な:valid:~
子たち:children:~
子孫:descendant:~
字下げ:indentation:~
存在-:exist:~
定義-:define:~
定義:definition:~
実施:practice:~
実行-:execute:~
実装-:implement:~
実際:actual:~
宣言-:declare:~
対応-:correspond:~
対応ing:corresponding:~
対話-:interact:やりとり
対話:interaction:~
対話的:interactive:~
未来:future:~
導出-:derive:~
局面:scenario:~
属性:attribute:~
層:layer:~
序論:introduction:~
引数:argument:~
強制-:force:~
影響-:affect:~
必須の:required:~
情報:information:~
意味-:mean:~
意味論:semantics:~
所与の:given:与えられた
所属-:belong:~
手入力-:enter:~
手動:manual:~
手引き:guide:~
手段:means:~
手続き:steps:~
投出:throw:~
押下げら:depress さ:~
押下げた:press した:~
抽象的:abstract:~
持続-:persist:~
指名-:designate:~
指定-:specify:~
指示-:indicate:~
挙動:behaviour:~
提供-:provide:~
提供0-:offer:提供
整数:integer:~
敵対的:hostile:~
文:sentence:~
文字:character:~
文字列:string:~
文書:document:~
文法:grammar:~
文脈:context:~
新たな:new:~
方向:direction:~
方式:manner:~
既定の:default:~
明に:expressly:~
明示的:explicit:~
暗黙の:implied:~
更新-:update:~
最善:best:~
有意:significant:~
有用:useful:~

有順序:ordered:~
順序:order:~
順序付けら:order さ:~

期待-:expect:~
木:tree::~::ツリー
本質的:essential:~
根:root::~::ルート
検査-:check:~
検査:checking:~
	検査し得る:checkable:~
検査器:checker:~
検索:search:~
概して:typically:~
概念:concept:~
構文解析-:parse:~
構築-:construct:~
標的:target:~
正確:exact:~
正確に:exactly:~
歴史的:historical:~
段:step:~
段落:paragraph:~
決定-:determine:~
浮上-:bubble:~
	惑わす:confusion:~
演算:operation:操作
濫用-:abuse:~
無視-:ignore:~
特定0の:particular:ある特定の
特有の:specific な:~
特定の:specific:~
特色機能:feature:~
状態:state:~
現在:currently:~
現在の:current:~
環:ring:~
環境:environment:~
用語:term:~
画像:image:~
発火-:fire:~
目的0:purpose:目的
直接的:direct:~
相対的:relative:~
相応しい:suitable:~
省略-:omit:~
省略可:optional:~
破壊-:destroy:~
確保-:ensure:~
確立-:establish:~
推薦-:suggest:~
移動-:move:~
空:empty:~
空白:whitespace:~
管理-:manage:~
管理:management:~
節0:section:節
範囲:range:~
素の:plain:~
素早く:quick:~
組合せ:combination:組み合わせ
結付けら:associated:~
継承-:inherit:~
	〜続ける:continue:~
綴り:spelling:~
編集:editing:~
編集-:edit:~
編集中の:editing:~
編集用の:editing:~
編集可能:editable:~
編集者:editor:~
考慮-:consider:~
	考える
背景:background:~
自前の:own:~
表現-:represent:~
表示-:display:~
	被指名-:designated:~
装置:device:~
要件:requirements:~
要求-:require:~
要素:element:~
要請-:request:~
見出-:find:~
規則:rule:~
規範的:normative:~
規約:convention:~
親:parent:~
解釈-:interpret:~
言語:language:~
自然言語:language:~
記述-:describe:~
	述べる:describe する:~
記述:description:~
設定-:set:~
設定ing:setting:~
設定群:settings:~
許容-:allow:~
試行-:try:~
誘発-:trigger:~
読取器:reader::~::リーダ
走査:traversal:~
転送:transfer:~
追加-:add:~
追加:addition:~
逐次的:sequential:~
通例的に:usually:~
通知:notification:~
連列:sequence:~
継続的:continuous:~
遂行-:perform:~
適切:appropriate:~
適用-:apply:~
適用可能:applicable:~
遵守-:honour:~
選好-:prefer:~
選好:preference:~
選択-:select:~
	選択:selecting:~
選択:selection:~
選定法:selection mechanism:~
部分木:subtree:~
配送-:dispatch:~
鎖:chain:~
開始-:start:~
終端:end:~
始端:start:~
間接的:indirect:~
関係-:relate:~
関係する:related:~
関心:interest:~
関連の:relevant:~
関連する:relevant な:~
関連しな:relevant でな:~
	できなく:prevent:~
除去-:remove:~
階層:hierarchy:~
隠す:hide する:~
隠され:hide され:~
隠せる:hide できる:~
隠して:hide して:~
頁:page:::ページ
領域:region:~
	同様に:similarly:~
首に:primarily:主に
首:primary:主
	＊首位／第一
含意-:imply:~

修飾:modifier:~
外形線:outline:~
送信0-:submit:送信
縮退-:collapse:~
逆順:reverse order:~
代用-:substitute:~
	やり直して-:restart:~
正当:legitimate:~
略式的:skeletal:~
選択的:selective:~
数字:digit:~
普通字:letter:~
off-screen::::オフスクリーン


	〜に基づく:based:~
	〜の代わりに:instead:~
	あてがう:assign:~
	かかわらず:regardless:~
	この:this:~
	これらの:these:~
	しかしながら，:however:~
	したがって:therefore:~
	したがって:thus:~
	すでに:already:~
	すべての:all:~
	その:that:~
	そのような:such:~
	その他:others:~
	それら:they:~
	それらの:their:~
	それらの:those:~
	それらを:them:~
	とりわけ:especially:~
	べき:should:~
	三つ:three:~
	三番目の:third:~
	上:above:~
	下:below:~
	与-:give:~
	両者:both:~
	二つ／ 2 個の:two:~
	二番目の:second:~
	介:via:~
	他の:other:~
	他の場合:otherwise:~
	以前の:previous:~
	任意の／恣意的な:arbitrary:~
	例:example:~
	依然として:still:~
	-:originally:~
	別の:another:~
	前:before:~
	前者:former:~
	可視の:visible:~
	露わになる:visible:~
	各:each:~
	同じ:same:~
	含-:include:~
	在-:present:~
	始-:begin:~
	小さい:small:~
	常に:always:~
	後:after:~
	後者:latter:~
	必要とされ:necessary:~
	数:number:~
最近傍の:nearest:最も近い
	最初の:first:~
	最後の:last:~
	次0:next:~
正しく:correct に:~

	正の:positive:~
	求め:want:~
	決して:never:~
	生じる:occur する:~
	異なる:different:~
	示す:show:~
	種々の:various:~
	等々:etc:~
	などなど:and so forth
	結果:result:~
	結果の:resulting:~
	自身:itself:~
	複数の:multiple:~
試みた:attempt した:~
試みる:attempt する:~
試みて:attempt して:~
	読込-:load:~
論じら:discuss さ:~
	負の:negative:~
	走-:run:~
	走っている:running:~
	起こる:happen:~
	返す:return:~
	通:through:~
	通常は:normally:~
	先ずfirst place
	一定の:certain:~

</script>


<!--%style -->
<style type="text/css">
*[lang="en"] {
	white-space: pre-line;
}

pre {
	white-space: pre-wrap;
}

.attr-state {
	font-family: sans-serif0, sans-serif;
}

</style>
<!-- 

.unicode-category {
	color: green;
}

.category-list > li {
	display: inline;
}
.category-list > li::before {
	content: "• ";
}
-->
</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Living Standard — XXXXX 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Semantics, structure, and APIs of HTML documents</a>
章を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-XXXXX</time>
（公開：<time>2016-XXXXX</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header id="head">
	<hgroup>
<h1>HTML — 利用者~対話 — User interaction</h1>
<h2>Living Standard — 最終更新 2016 年 4 月 16 日</h2>
	</hgroup>
</header>

<nav class="toc" id="toc">
<h2>目次</h2>
<ol id="_toc_list0"></ol></nav>

<hr>

<main id="MAIN" style="display:none;">

	<section id="editing">
<h2 title="User interaction">6. 利用者~対話</h2>

		<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
この文書の用語［
`文書@
／
`要素@
］は、［
`Document$I ／ `Element$I
］~objの略記として用いられる。
</p>

		</section>
		<section id="the-hidden-attribute">
<h3 title="The hidden attribute">6.1. `hidden^a 属性</h3>

`19159^bug


<p>
`hidden$a 内容~属性は、すべての`~HTML要素$に設定できる。
`hidden$a 属性は`真偽~属性$である。
指定された場合、その要素は，利用者からは直接的に~accessできないことを指示する
— すなわち，［
まだ, あるいはそれ以降、頁の現在の状態に直接的には関連しない
］ことを, あるいは［
頁の他の部分に再利用される内容を宣言するために利用されている
］ことを指示する。
~UAは、 `hidden$a 属性が指定されている要素を具現化するべきでない。
この要件は、~style層を通して間接的に実装されてよい。
例えば ~HTML＋CSS ~UAは、これらの要件を
<a href="~HTMLRENDERING#hiddenCSS">具現化~節にて推薦されている規則</a>
を利用して実装することもできる。
◎
All HTML elements may have the hidden content attribute set. The hidden attribute is a boolean attribute. When specified on an element, it indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user. User agents should not render elements that have the hidden attribute specified. This requirement may be implemented indirectly through the style layer. For example, an HTML+CSS user agent could implement these requirements using the rules suggested in the Rendering section.
</p>


<p class="note">注記：
この属性は、概して CSS を利用して実装されるので、
CSS を利用して上書きすることもまた可能0である。
具体的には、すべての要素に
`display: block^css
を適用する規則は、 `hidden$a 属性の効果を取消すことになる。
したがって，~stylesheetを書く作者には、この属性を有する要素に依然として期待される~styleがあてがわれるよう，注意する必要がある。
◎
Because this attribute is typically implemented using CSS, it's also possible to override it using CSS. For instance, a rule that applies 'display: block' to all elements will cancel the effects of the hidden attribute. Authors therefore have to take care when writing their style sheets to make sure that the attribute is still styled as expected.
</p>



<div class="example">

<p>
次の略式的な例では、利用者が~log-inするまで~Web~gameの~main~screenを隠すために，この属性が利用されている：
◎
In the following skeletal example, the attribute is used to hide the Web game's main screen until the user logs in:
</p>


<pre>
&lt;h1&gt;The Example Game&lt;/h1&gt;
&lt;section id="login"&gt;
 &lt;h2&gt;Login&lt;/h2&gt;
 &lt;form&gt;
  ...
  &lt;!-- 利用者~資格を検査したなら， login() を~callする --&gt;
 &lt;/form&gt;
 &lt;script&gt;
  function login() {
    // ~screenを切り替える
    document.getElementById('login').hidden = true;
    document.getElementById('game').hidden = false;
  }
 &lt;/script&gt;
&lt;/section&gt;
&lt;section id="game" hidden&gt;
 ...
&lt;/section&gt;
</pre>

</div>

<!-- 
The Example Game
Login

calls login() once the user's credentials have been checked

// switch screens
-->
<p>
`hidden$a 属性は、他の呈示では正当に示され得るような内容に対し，それを隠す用途には，利用されては~MUST_NOT。
例えば、~tab化された~dialog内の~panelを隠す用途に `hidden$a を利用することは，不正である
— ~tab化された~interfaceは，~overflow呈示の一種に過ぎず、単に~scrollbarを伴う大きな頁にすべての~form~controlを示すことに同等なので。
同様に、この属性を ある呈示に限って内容を隠す用途に利用することは，不正である
— `hidden$a にされた†ものは、~screen読取器も含め，すべての呈示から隠される。
◎
The hidden attribute must not be used to hide content that could legitimately be shown in another presentation. For example, it is incorrect to use hidden to hide panels in a tabbed dialog, because the tabbed interface is merely a kind of overflow presentation — one could equally well just show all the form controls in one big page with a scrollbar. It is similarly incorrect to use this attribute to hide content just from one presentation — if something is marked hidden, it is hidden from all presentations, including, for instance, screen readers.
</p>

<p class="trans-note">【†
以下、 “`hidden$a にされた” とは， “`hidden$a 属性を有する” を意味する。
】</p>


<p>
`hidden$a にされている要素から， `hidden$a にされていない要素へ`~hyperlink$しては~MUST_NOT。
同様に、 `hidden$a にされていない［
`label$e ／ `output$e
］要素の `for^a 属性が、 `hidden$a にされている要素を指しては~MUST_NOT。
いずれの参照-も，利用者を惑わすことになるので。
◎
Elements that are not themselves hidden must not hyperlink to elements that are hidden. The for attributes of label and output elements that are not themselves hidden must similarly not refer to elements that are hidden. In both cases, such references would cause user confusion.
</p>


<p>
しかしながら，他の文脈においては、要素や~scriptが `hidden$a にされている要素を指すこともある。
◎
Elements and scripts may, however, refer to elements that are hidden in other contexts.
</p>

<div class="example">

<p>
例えば、 `href$a 属性の~link先として `hidden$a にされた節0をあてがうのは，不正になる。
当の内容が［
適用可能でない／関連しない
］ならば、そこへ~linkする理由はない。
◎
For example, it would be incorrect to use the href attribute to link to a section marked with the hidden attribute. If the content is not applicable or relevant, then there is no reason to link to it.
</p>


<p>
しかしながら， ARIA `aria-describedby$a 属性を利用して `hidden$a にされている記述を指すことは，申し分ない。
記述を隠すことは，それ~~単独では有用でないことを含意するが、ある画像についての記述を その画像から参照させるなど，特定の文脈~下で有用になるように書くことはできる。
◎
It would be fine, however, to use the ARIA aria-describedby attribute to refer to descriptions that are themselves hidden. While hiding the descriptions implies that they are not useful alone, they could be written in such a way that they are useful in the specific context of being referenced from the images that they describe.
</p>

<p>
同様に、 `hidden$a にされた `canvas$e 要素は，~scriptによる~graphic~engineから~off-screen~bufferとして利用されることもあり、~form~controlの `form$a 属性は， `hidden$a にされた `form$e 要素を指すこともある。
◎
Similarly, a canvas element with the hidden attribute could be used by a scripted graphics engine as an off-screen buffer, and a form control could refer to a hidden form element using its form attribute.
</p>

</div>

<p>
`hidden$a にされた節0内の要素であっても、依然として作動中であり続ける
— 例えば，そのような節0内の［
~script／~form~control
］は、依然として［
実行される／送信0される
］。
変化するのは、利用者~向けの呈示に限られる。
◎
Elements in a section hidden by the hidden attribute are still active, e.g. scripts and form controls in such sections still execute and submit respectively. Only their presentation to the user changes.
</p>

<p>
`hidden@m
~IDL属性は、同じ名前の内容~属性を`反映-$し~MUST。
◎
The hidden IDL attribute must reflect the content attribute of the same name.
</p>


		</section>
		<section id="inert-subtrees">
<h3 title="Inert subtrees">6.2. 不活~部分木</h3>


<p>
~node（特に，要素／~text~node）は、
`不活@
にされ得る。
~nodeが`不活$にされている下では、~UAは，利用者~対話~eventの標的にする目的0においては，~nodeは不在であったかのように動作し~MUST。
また、~text検索~UI（ “頁~内を~~検索” として周知の）の目的0においては，~nodeを無視してよい。
また、その~node内の~textについては，利用者が選択できなくしてよい。
しかしながら，~UAは、［
利用者が，検索や~text選択におけるこの制約を上書きできる
］ようにするべきである。
◎
This section does not define or create any content attribute named "inert". This section merely defines an abstract concept of inertness.
◎
A node (in particular elements and text nodes) can be marked as inert. When a node is inert, then the user agent must act as if the node was absent for the purposes of targeting user interaction events, may ignore the node for the purposes of text search user interfaces (commonly known as "find in page"), and may prevent the user from selecting text in that node. User agents should allow the user to override the restrictions on search and text selection, however.
</p>


<p class="example">
例えば、ある頁の `body$e の中には`不活$にされた段落のみがあるとする。
利用者が，~pointing装置をその段落の外から内に移動させ，そこで~clickした場合、
`mouseover$et ~eventは発火されず，
`mousemove$et ／ `click$et
~eventは，段落ではなく `body$e 要素に向けて発火されることになる。
◎
For example, consider a page that consists of just a single inert paragraph positioned in the middle of a body. If a user moves their pointing device from the body over to the inert paragraph and clicks on the paragraph, no mouseover event would be fired, and the mousemove and click events would be fired on the body element rather than the paragraph.
</p>


<p class="note">注記：
一般に、不活である~nodeには，~focusできない。
また、~nodeが`~commandを定義する$ものであれば，不能化されることになる。
◎
When a node is inert, it generally cannot be focused. Inert nodes that are commands will also get disabled.
</p>


<p>
`閲覧文脈~容器$が`不活$にされている間は、［
それが`入子にしている閲覧文脈$において`作動中の文書$, および
その`文書$内のすべての~node
］は、`不活$にされ~MUST。
◎
While a browsing context container is marked as inert, its nested browsing context's active document, and all nodes in that Document, must be marked as inert.
</p>


<p>
`文書$全体が
%~subject `~modal~dialogにより阻止-@
されるとして＊~markされ得る。
`文書$がそのように~markされている間は、
%~subject 要素とその子孫を除く，`文書~内にある$どの~nodeも，`不活$にされ~MUST。
（この段落にて除かれる要素であっても、他の手段を通して，`不活$にされ得る
— 当の~modal~dialogの一部分であることは，~nodeが`不活$にされることを “＊保護する” ことはない）
◎
An entire Document can be marked as blocked by a modal dialog subject. While a Document is so marked, every node that is in the Document, with the exception of the subject element and its descendants, must be marked inert. (The elements excepted by this paragraph can additionally be marked inert through other means; being part of a modal dialog does not "protect" a node from being marked inert.)
</p>


<p>
ある時点で，`文書$を`~modal~dialogにより阻止-$されるものと~markできる要素＊は
唯一つに限られる。
新たな `dialog$e が，`文書$を`~modal~dialogにより阻止-$したときは、以前にそうしていた要素による，`文書$の阻止-~ingは停止される。
◎
Only one element at a time can mark a Document as being blocked by a modal dialog. When a new dialog is made to block a Document, the previous element, if any, stops blocking the Document.
</p>


<p class="note">注記：
`dialog$e 要素の `showModal()$m ~methodを、この仕組みに用立てられる。
◎
The dialog element's showModal() method makes use of this mechanism.
</p>


		</section>
		<section id="activation">
<h3 title="Activation">6.3. 作動化</h3>


<p>
ある種の~HTML要素は、`作動化の挙動$を有する
— 利用者はそれを作動化できることを意味する。
これは、作動化の仕組みに依存して，下に述べるような~event連列を誘発する。
連列は、通常は `click$et ~eventで締め括られる。
◎
Certain elements in HTML have an activation behaviour, which means that the user can activate them. This triggers a sequence of events dependent on the activation mechanism, and normally culminating in a click event, as described below.
</p>

<p>
~UAは、［
利用者が，手動で`作動化の挙動$を持つ要素を誘発できる
］ようにするべきである
— 具体的には、~keyboardや声~入力を利用したり，~mouse~clickを通して。
利用者が，`作動化の挙動$が定義されている要素を，~click以外の方式で誘発したときは、＊対話~eventの既定の動作では、要素~上で`合成~click作動化~手続きを走らす$ことが要求される。
◎
The user agent should allow the user to manually trigger elements that have an activation behaviour, for instance using keyboard or voice input, or through mouse clicks. When the user triggers an element with a defined activation behaviour in a manner other than clicking it, the default action of the interaction event must be to run synthetic click activation steps on the element.
</p>

<p>
各~要素には、 %~click進捗中~flag
— 初期時は ~OFF —
が結付けられる。
◎
Each element has a click in progress flag, initially set to false.
</p>


<p>
~UAは、要素 %要素 上で
`合成~click作動化~手続きを走らす@
ときは、次の手続きを走らせ~MUST：
◎
When a user agent is to run synthetic click activation steps on an element, the user agent must run the following steps:
</p>

<ol>
	<li>
~IF［
%要素 の %~click進捗中~flag ~EQ ~ON
］
⇒
~RET
◎
If the element's click in progress flag is set to true, then abort these steps.
</li>
	<li>
%要素 上の %~click進捗中~flag ~SET ~ON
◎
Set the click in progress flag on the element to true.
</li>
	<li>
%要素 上で`~click前の作動化~手続きを走らす$
◎
Run pre-click activation steps on the element.
</li>
	<li>
%要素 に向けて，`~click~eventを発火-$する
— ここで、この手続きが `click()$m ~methodから呼出された場合には，
~eventの `istrusted$m 属性も ~F に初期化する。
◎
Fire a click event at the element. If the run synthetic click activation steps algorithm was invoked because the click() method was invoked, then the isTrusted attribute must be initialised to false.
</li>
	<li>
~IF［
前段の~eventは取消されなかった
］
⇒
%要素 上で`~click後の作動化~手続きを走らす$
◎
If this click event is not canceled, run post-click activation steps on the element.
</li>
	<li>
~ELSE
⇒
%要素 上で`取消時の作動化~手続きを走らす$
◎
If the event is canceled, the user agent must run canceled activation steps on the element instead.
</li>
	<li>
%要素 上の %~click進捗中~flag ~SET ~OFF
◎
Set the click in progress flag on the element to false.
</li>
</ol>


<p>
~UAは、~pointing装置が~clickされたときは，次で与えられる
`click$et ~eventを発火する代わりに＊
`~authentic~click作動化~手続きを走らす@
ことが要求される：
◎
When a pointing device is clicked, the user agent must run authentic click activation steps instead of firing the click event. When a user agent is to run authentic click activation steps for a given event event, it must follow these steps:
</p>

<ol>
	<li>
%標的 ~LET %~event の標的（利用者により指名された要素）
◎
Let target be the element designated by the user (the target of event).
</li>
	<li>
~IF［
%標的 は `canvas$e 要素である
］
⇒
<a href="~HTML5/scripting.html#canvas-mouseevent-rerouting-steps">~canvas `MouseEvent^I ~rerouting手続き</a>
を走らす
◎
If target is a canvas element, run the canvas MouseEvent rerouting steps. If this changes event's target, then let target be the new target.
</li>
	<li>
%標的 上の %~click進捗中~flag ~SET ~ON
◎
Set the click in progress flag on target to true.
</li>
	<li>
%要素 ~LET %標的 に`最近傍の作動化可能な要素$
◎
Let e be the nearest activatable element of target (defined below), if any.
</li>
	<li>
~IF［
%要素 ~NEQ ε
］
⇒
%要素 上で`~click前の作動化~手続きを走らす$
◎
If there is an element e, run pre-click activation steps on it.
</li>
	<li>
%標的 に向けて %~event を`配送-$する
◎
Dispatch event (the required click event) at target.
</li>
	<li>
<p>
~IF［
%要素 ~NEQ ε
］：
</p>
		<ol>
			<li>
~IF［
%~event は取消されなかった
］
⇒
%要素 上で`~click後の作動化~手続きを走らす$
◎
If there is an element e and the click event is not canceled, run post-click activation steps on element e.
</li>
			<li>
~ELSE
⇒
%要素 上で`取消時の作動化~手続きを走らす$
◎
If there is an element e and the event is canceled, run canceled activation steps on element e.
</li>
		</ol>
	</li>
	<li>
%標的 上の %~click進捗中~flag ~SET ~OFF
◎
Set the click in progress flag on target to false.
</li>

</ol>


<p class="note">注記：
作者~scriptにより配送される合成~eventは、上の~algoを走らすことはない。
`合成~click作動化~手続きを走らす$~algoを~program的に走らせたいときは、
`click()$m ~methodを利用できる。
◎
The algorithms above don't run for arbitrary synthetic events dispatched by author script. The click() method can be used to make the run synthetic click activation steps algorithm happen programmatically.
</p>

<p class="note">注記：
~clickによる~focus時の挙動（例：利用者が~text~fieldを~clickして~focusしたとき）は、概して~clickの前，~mouse~buttonが最初に押下げられたときに起こるので、ここでは論じられない。
◎
Click-focusing behaviour (e.g. the focusing of a text field when user clicks in one) typically happens before the click, when the mouse button is first depressed, and is therefore not discussed here.
</p> 


<p>
所与の要素 %標的 に
`最近傍の作動化可能な要素@
とは、次の~algoが返す要素, または ε （なし）である：
◎
Given an element target, the nearest activatable element is the element returned by the following algorithm:
</p>

<div >
<ol>
	<li>
<p>
~WHILE［
%標的 には`作動化の挙動$は定義されていない
］：
</p>
		<ol>
			<li>
~IF［
%標的 には親~要素はない
］
⇒
~RET ε
</li>
			<li>
%標的 ~SET %標的 の親~要素
</li>
		</ol>
	</li>
	<li>
~RET %標的
</li>
</ol>

◎
If target has a defined activation behaviour, then return target and abort these steps.
◎
If target has a parent element, then set target to that parent element and return to the first step.
◎
Otherwise, there is no nearest activatable element.
</div>


<p>
~UAは、要素~上で
`~click前の作動化~手続きを走らす@
ときは、その要素に
`~click前の作動化~手続き@
が定義されているならば，それを走らせ~MUST。
◎
When a user agent is to run pre-click activation steps on an element, it must run the pre-click activation steps defined for that element, if any.
</p>


<p>
~UAは、要素~上で
`取消時の作動化~手続きを走らす@
ときは、その要素に
`取消時の作動化~手続き@
が定義されているならば，それを走らせ~MUST。
◎
When a user agent is to run canceled activation steps on an element, it must run the canceled activation steps defined for that element, if any.
</p>


<p>
~UAは、要素~上で
`~click後の作動化~手続きを走らす@
ときは、その要素に
`作動化の挙動@
が定義されているならば，それを走らせ~MUST。
作動化の挙動は、
上の手続きにより発火された `click$et ~eventを~referし得る

＊leading up to この地点。
◎
When a user agent is to run post-click activation steps on an element, it must run the activation behaviour defined for that element, if any. Activation behaviours can refer to the click event that was fired by the steps above leading up to this point.
</p>

<dl class="domintro">
	<dt>%element . `click()$m</dt>
	<dd>
要素が~clickされたかのように動作させる。
◎
Acts as if the element was clicked.
</dd>
</dl>

<p>
`click()@m
~methodの被呼出時には、次の手続きを走らせ~MUST：
◎
The click() method must run the following steps:
</p>

<ol>
	<li>
此れは`不能化され$ている~form~controlである
⇒
~RET
◎
If the element is a form control that is disabled, abort these steps.
</li>
	<li>
要素~上で`合成~click作動化~手続きを走らす$
◎
Run synthetic click activation steps on the element.
</li>
</ol>

		</section>
		<section id="focus">
<h3 title="Focus">6.4. ~focus</h3>


			<section id="introduction-8">
<h4 title="Introduction">6.4.1. 序論</h4>

~INFORMATIVE

<p>
~HTML~UIは、概して複数の対話的~widgetからなる
—
~form~control,
~scrollable領域,
~link,
~dialog~box,
~browser~tab,
などなど。
これらの~widgetは、あるもの（例： ~browser~tab, ~dialog~box）が他のもの（例： ~link, ~form~control）を包含しているような，階層を形成する。
◎
An HTML user interface typically consists of multiple interactive widgets, such as form controls, scrollable regions, links, dialog boxes, browser tabs, and so forth. These widgets form a hierarchy, with some (e.g. browser tabs, dialog boxes) containing others (e.g. links, form controls).
</p>


<p>
~keyboardを利用して~interfaceと対話するとき、~key入力は，
~systemから対話的~widgetの階層を通して，作動中の~widgetまで，~channeled
~which~is
＊`~focusされ$ていると~said~to~be。
◎
When interacting with an interface using a keyboard, key input is channeled from the system, through the hierarchy of interactive widgets, to an active widget, which is said to be focused.
</p>

<div class="example">


<p>
~graphical環境~内で走っている~browser~tab内で走っている~HTML~appを考える。
この~appの頁には，いくつかの~text~fieldや~linkがあり、現在~modal~dialogを示していて，その中にも~text~fieldや~buttonがあるとする。
◎
Consider an HTML application running in a browser tab running in a graphical environment. Suppose this application had a page with some text fields and links, and was currently showing a modal dialog, which itself had a text field and a button.
</p>


<p>
この局面における可focus~widgetの階層は、先ず~browser~windowを含み、
⇒
~windowは，~HTML~appを包含している~browser~tabを子として持ち、
⇒
~tabは，前述の~dialogの他に種々の~linkや~text~fieldを子として持ち、
⇒
~dialogは，~text~fieldや~buttonを子として持つことになる。
◎
The hierarchy of focusable widgets, in this scenario, would include the browser window, which would have, amongst its children, the browser tab containing the HTML application. The tab itself would have as its children the various links and text fields, as well as the dialog. The dialog itself would have as its children the text field and the button.
</p>

<figure>
<img src="/images/focus-tree.png" alt="" width="800" height="450">
<figcaption>

</figcaption></figure>

<p>
この例において ~focusされている~widgetが，~dialog~box内の~text~fieldであった場合、~key入力は、［
~graphical~system →
① ~Web~browser →
② ~tab →
③ ~dialog →
④ ~text~field
］の順に＊~channeledされることになる
◎
If the widget with focus in this example was the text field in the dialog box, then key input would be channeled from the graphical system to ① the Web browser, then to ② the tab, then to ③ the dialog, and finally to ④ the text field.
</p>

</div>


<p>
~keyboard~eventは、常に，この`~focusされ$た要素を標的にする。
◎
Keyboard events are always targeted at this focused element.
</p>


			</section>
			<section id="data-model">
<h4 title="Data model">6.4.2. ~data~model</h4>


<p>
用語
`可focus域@
は、~keyboard入力の標的になれるような，~UIの領域を指す。
可focus域は，［
要素, 要素の一部分, ~UAにより管理される他の領域
］になり得る。
◎
The term focusable area is used to refer to regions of the interface that can become the target of keyboard input. Focusable areas can be elements, parts of elements, or other regions managed by the user agent.
</p>

<p>
各`可focus域$は、
`~DOM~anchor@
を持つ
— それは、`可focus域$の~DOMにおける位置を表現する `Node$I ~objである（`可focus域$自身が `Node$I であれば，それがそのまま`~DOM~anchor$になる）。
`~DOM~anchor$は、`可focus域$を表現する~DOM~objが他にないときに，一部の~APIにより`可focus域$の代用として利用される。
◎
Each focusable area has a DOM anchor, which is a Node object that represents the position of the focusable area in the DOM. (When the focusable area is itself a Node, it is its own DOM anchor.) The DOM anchor is used in some APIs as a substitute for the focusable area when there is no other DOM object to represent the focusable area.
</p>


<p>
次の表は、どの~objが`可focus域$になり得るかを述べるものである。
表の左列は，`可focus域$になり得る~objについてを述べ、右列は，それらの~objの`~DOM~anchor$を述べる（横幅全体にまたがる列には，例を示す。）
◎
The following table describes what objects can be focusable areas. The cells in the left column describe objects that can be focusable areas; the cells in the right column describe the DOM anchors for those elements. (The cells that span both columns are non-normative examples.)
</p>

<table id="table-fa"><thead><tr><th id="th-fa-area">`可focus域$
</th><th id="th-fa-dom-rep">`~DOM~anchor$
</th></tr><tr><th colspan="2" id="th-fa-examples">
<div class="example">例</div>
</th></tr></thead>

<tbody><tr><th headers="th-fa-area" id="td-fa-1" class="data-header">
<p >
次をいずれも満たす要素：
</p>

<ul ><li>`~tabindex~focus~flag$ ~EQ ~ON
</li><li>`不能化-$されていない
</li><li>`明に不活$でない
</li><li>［
`具現化され$ている
~OR
<a href="~HTML5/scripting.html#being-used-as-relevant-canvas-fallback-content">関連する~canvas~fallback内容として利用中にある</a>
］
</li></ul>

◎
Elements that have their tabindex focus flag set, that are not actually disabled, that are not expressly inert, and that are either being rendered or being used as relevant canvas fallback content.
</th><td headers="td-fa-1 th-fa-dom-rep">
要素~自身。
◎
The element itself.
</td></tr><tr><td colspan="2" headers="td-fa-1 th-fa-examples">

<div class="example">
<ul>
	<li>
`iframe$e
</li>
	<li>
<a href="~HTML-FORMS#text-(type=text)-state-and-search-state-(type=search)-">`&lt;input type=text&gt;^e</a>,
</li>
	<li>
場合によっては
<a href="~HTML5/semantics.html#the-a-element-">`&lt;a href=""&gt;^e</a>
（~platform規約に依存する）。
</li>
</ul>
</div>


◎
iframe, &lt;input type=text&gt;, sometimes &lt;a href=""&gt; (depending on platform conventions).
</p></td></tr></tbody>

<tbody><tr><th headers="th-fa-area" id="td-fa-2" class="data-header">
`画像~map$内の `area$e 要素の~shapeのうち，次を満たすもの
⇒
次を満たすような `img$e 要素に結付けらている
⇒
`具現化され$ている, かつ `明に不活$でない。
◎
The shapes of area elements in an image map associated with an img element that is being rendered and is not expressly inert.
</th><td headers="td-fa-2 th-fa-dom-rep">
`img$e 要素。
◎
The img element.
</td></tr><tr><td colspan="2" headers="td-fa-2 th-fa-examples">

<div class="example">
<p>
次の例では、
`area$e 要素は，各~画像ごとに一つ， 2 個の~shapeを作成する。
［
最初の／二番目の
］~shapeの`~DOM~anchor$は，［
最初の／二番目の
］ `img$e 要素になる。
◎
In the following example, the area element creates two shapes, one on each image. The DOM anchor of the first shape is the first img element, and the DOM anchor of the second shape is the second img element.
</p>

<pre>
&lt;map id=wallmap&gt;&lt;area alt="入り口ドア" coords="10,10,100,200" href="door.html"&gt;&lt;/map&gt;
...
&lt;img src="images/innerwall.jpeg" alt="ドア付きの白い壁がここにある。" usemap="#wallmap"&gt;
...
&lt;img src="images/outerwall.jpeg" alt="ドア付きの赤い壁がここにある。" usemap="#wallmap"&gt;
</pre>
</div>
<!-- 
alt="Enter Door"
...
alt="There is a white wall here, with a door."
...
alt="There is a red wall here, with a door."
-->

</td></tr></tbody>

<tbody><tr><th headers="th-fa-area" id="td-fa-3" class="data-header">
<p >
~UAにより提供される下位~widget＊の＊要素であって，次をいずれも満たすもの：
</p>

<ul ><li>`具現化され$ている
</li><li>`不能化-$されてない
</li><li>`明に不活$でない
</li></ul>

◎
The user-agent provided subwidgets of elements that are being rendered and are not actually disabled or expressly inert.
</th><td headers="td-fa-3 th-fa-dom-rep">
`可focus域$である下位~widgetに対する要素。
◎
The element for which the focusable area is a subwidget.
</td></tr><tr><td colspan="2" headers="td-fa-3 th-fa-examples">

<div class="example">
<ul>
	<li>
`video$e 要素に対し，`~UIにより利用者に公開されている~control$
</li>
	<li>
<a href="~HTML-FORMS#number-state-(type=number)-">`&lt;input type=number&gt;^e</a>
用の増減~button ／
</li>
	<li>
<a href="~HTML-FORMS#range-state-(type=range)-">`&lt;input type=range multiple&gt;^e</a>
用の範囲~control~widget
</li>
	<li>
`details$e 要素の具現化の一部分であって，当の要素の開閉を~keyboard入力を利用して可能化させているもの。
</li>
</ul>
</div>

◎
The controls in the user interface that is exposed to the user for a video element, the up and down buttons in a spin-control version of &lt;input type=number&gt; , the two range control widgets in a &lt;input type=range multiple&gt;, the part of a details element's rendering that enabled the element to be opened or closed using keyboard input.
</td></tr></tbody>

<tbody><tr><th headers="th-fa-area" id="td-fa-4" class="data-header">
`具現化され$ている~AND `明に不活$でない要素の，~scrollable領域。
◎
The scrollable regions of elements that are being rendered and are not expressly inert.
</th><td headers="td-fa-4 th-fa-dom-rep">
その~scrollable領域~boxを~~生成した要素。
◎
The element for which the box that the scrollable region scrolls was created.
</td></tr><tr><td colspan="2" headers="td-fa-4 th-fa-examples">

<div class="example">
<p>
CSS `overflow$p ~propに対する `scroll^v 値は、概して，~scrollable領域を作成させる。
◎
The CSS 'overflow' property's 'scroll' value typically creates a scrollable region.
</p>
</div>

</td></tr></tbody>



<tbody><tr><th headers="th-fa-area" id="td-fa-5" class="data-header">
`閲覧文脈$docを持つ, かつ`不活$でない
`文書$の`表示域$x。
◎
The viewport of a Document that has a ＊browsing context and is not inert.
</th><td headers="td-fa-5 th-fa-dom-rep">
`表示域$xを作成させている`文書$。
◎
The Document for which the viewport was created.
</td></tr><tr><td colspan="2" headers="td-fa-5 th-fa-examples">
<div class="example">
</div>

<p class="example">
`iframe$e の内容。
◎
The contents of an iframe.
</p>
</td></tr></tbody>

<tbody><tr><th headers="th-fa-area" id="td-fa-6" class="data-header">
~any
他の要素またはその一部分
— とりわけ，~accessibilityを支援する, あるいは~platform規約により良く合致するもの。
◎
Any other element or part of an element, especially to aid with accessibility or to better match platform conventions.
</th><td headers="td-fa-6 th-fa-dom-rep">
要素。
◎
The element.
</td></tr><tr><td colspan="2" headers="td-fa-6 th-fa-examples">

<div class="example">
</div>

<p class="example">
~UAは、利用者が~listを~navigateし易くなるよう，すべての~list~item~bulletを可focusにすることもできる。
◎
A user agent could make all list item bullets focusable, so that a user can more easily navigate lists.
</p>

<p class="example">
同様に，~UAは、
`title$a 属性を有するすべての要素に対し，その参考情報に~accessできるよう，可focusにすることもできる。
◎
Similarly, a user agent could make all elements with title attributes focusable, so that their advisory information can be accessed.
</p>

</td></tr></tbody></table>


<p id="bc-focus-ergo-bcc-focus" class="note">注記：
`閲覧文脈~容器$ %容器 （例： `iframe$e ）は，`可focus域$であるが、
%容器 へ~routeされる~key~eventは，［
%容器 が`入子にしている閲覧文脈$において`作動中の文書$ %文書
］へ，直に~routeされるようになる。
同様に，逐次的~focus~navigationにおいては、
%容器 は，本質的には %文書 の＊~placeholderとして動作するに過ぎない。
◎
A browsing context container (e.g. an iframe) is a focusable area, but key events routed to a browsing context container get immediately routed to the nested browsing context's active document. Similarly, in sequential focus navigation a browsing context container essentially acts merely as a placeholder for its nested browsing context's active document.
</p>


<hr>

<p>
次のものは、
`~control群@
を作成させる：
◎
The following create control groups:
</p>

<ul>
	<li>
`閲覧文脈$docに属する`文書$。
◎
Document object that have ＊browsing contexts.
</li>
	<li>
`open$a 属性を有する `dialog$e 要素であって，`具現化され$ているもの。
◎
dialog elements that have an open attribute specified and that are being rendered.
</li>
</ul>


<p>
対応している
`文書$ ／ `dialog$e 要素
は、作成される`~control群$の
`所有者~obj@
という（`~control群$と`所有者~obj$とは常に一対一に対応する）。
◎
The corresponding Document object or dialog element is the created control group's owner object. (There is always a 1:1 mapping of control groups to control group owner objects.)
</p>

<p>
どの`可focus域$ %F も、ある一つの`~control群$に所属する。
それは、［
%F の`~DOM~anchor$ %A, または %A の先祖
］のうち， %A に最も近い`所有者~obj$の`~control群$である。
◎
Each focusable area belongs to a single control group as follows. If the DOM anchor of a focusable area is a control group owner object, then that focusable area belongs to that control group owner object's control group. Otherwise, the focusable area belongs to its DOM anchor's nearest ancestor control group owner object's control group.
</p>

<div class="example">

<p>
したがって：
</p>

<ul>
	<li>
`表示域$xは常に，`表示域$xを作成した`文書$の`~control群$に所属する。
</li>
	<li>
`input$e ~controlは、［
その最近傍の先祖である`所有者~obj$
］の`~control群$に所属する。
</li>
	<li>
画像~mapの~shapeは、対応する `img$e 要素の［
最近傍の先祖である`所有者~obj$
］に所属する（ `area$e 要素のそれではなく
— これは、同じ `area$e 要素が，異なる`~control群$に所属する複数の~shapeを作成し得ることを意味する＊？）。
</li>
</ul>

◎
Thus, a viewport always belongs to the control group of the Document for which the viewport was created, an input control belongs to the control group of its nearest ancestor dialog or Document, and an image map's shapes belong to the nearest ancestor dialog or Document of the img elements (not the area elements — this means one area element might create multiple shapes in different control groups).
</div>


<p class="note">注記：
`~control群$は空になる場合
— すなわち、`可focus域$を持たない —
もあり得る。
◎
It is possible for a control group to be empty, i.e. for it to have no focusable areas.
</p>

<div >
<p>
次のいずれも満たす要素は、
`明に不活@
とされる：
</p>

<ul ><li>`不活$である。
</li><li>`所有者~obj$ではない。
</li><li>要素の＊最近傍の先祖である`所有者~obj$は、`不活$でない。
</li></ul>

◎
An element is expressly inert if it is inert but it is not a control group owner object and its nearest ancestor control group owner object is not inert.
</div>


<p>
各 空でない`~control群$内では、ある一つの`可focus域$が
`指名focus域@
にされる。
どの~control（可focus域）がそう指名されるかは、この仕様の各種~algoに基づいて，時経過に伴って変化する。
空の`~control群$の`指名focus域$は、 ε とする（存在しない）。

＊`所有者~obj$ %O の`指名focus域$と記されたときは、
 %O の`~control群$の`指名focus域$を指す。
◎
One focusable area in each non-empty control group is designated the focused area of the control group. Which control is so designated changes over time, based on algorithms in this specification. If a control group is empty, it has no focused area.
</p>

<p>
各
`所有者~obj$は、
`~dialog群@
の
`~manager@
としても動作し得る。
＊＊＊
要するに所有者~objは~dialog群を持ち得る

◎
Each control group owner object can also act as the manager of a dialog group.
</p>

<p>
<!-- 
`open$a 属性を有する, かつ`具現化され$ている
 -->
`所有者~obj$である `dialog$e 要素のうち，`明に不活$dlgでないもの %D は，ある一つの`~dialog群$ %G に所属する。
%G の`~manager$は、
%D の最近傍の先祖である`所有者~obj$である。
◎
Each dialog element that has an open attribute specified and that is being rendered (i.e. that is a control group owner object) and is not expressly inert belongs to the dialog group whose manager is the dialog element's nearest ancestor control group owner object.
</p>


<p>
次のいずれも満たす `dialog$e は、
`明に不活@dlg
であるとされる
⇒
`不活$である ~AND
最近傍の先祖である`所有者~obj$は`不活$でない
◎
A dialog is expressly inert if it is inert but its nearest ancestor control group owner object is not.
</p>


<p>
`所有者~obj$ %O に対し，［
どの `dialog$e 要素も，その最近傍の先祖である`所有者~obj$は %O でない
］場合、 %O の`~dialog群$は ε である（持たない）。
＊＊＊
形式的には %O の~dialog群は空，と定義する方が明快
◎
If no dialog element has a particular control group owner object as its nearest ancestor control group owner object, then that control group owner object has no dialog group.
</p>


<p>
各`~dialog群$においては、ある `dialog$e が
`指名focus~dialog@
にされ得る。
＊
何も指名されていなければ`指名focus~dialog$は ε である。
＊
どの `dialog$e がそう指名されるかは、この仕様の各種~algoに基づいて，時経過に伴って変化する。

＊`所有者~obj$ %O の`指名focus~dialog$と記されたときは、
 %O の`~dialog群$の`指名focus~dialog$を指す。
◎
Each dialog group can have a dialog designated as the focused dialog of the dialog group. Which dialog is so designated changes over time, based on algorithms in this specification.
</p>

<hr>


<p>
`~control群$に属する`可focus域$たちの順序は、それらの`~DOM~anchor$の`木~順序$xに基づく。
同じ`~control群$に属する`可focus域$のうち，`~DOM~anchor$が同じになるものどうしの順序は、それらが生成する CSS ~boxの＊~box木における木~順序
— ＊~DOM木における`木~順序$xと同様の順序 —
に基づく。
<!-- 
~DOM木における`木~順序$x ~pre-order, ~depth-first走査における
互いに＊相対的な位置＊により順序される。
 -->
`CSS$r
◎
Focusable areas in control groups are ordered relative to the tree order of their DOM anchors. Focusable areas with the same DOM anchor in a control group are ordered relative to their CSS box's relative positions in a pre-order, depth-first traversal of the box tree. [CSS]
</p>


<p>
`~dialog群$に属する要素たちの順序は、`木~順序$xに基づく。
◎
Elements in dialog groups are ordered in tree order.
</p>


<hr>

<p>
特定0の時点における`~top-level閲覧文脈$ %T の
`現focused域@†
は、次の~algoから返される［
`可focus域$ ／ `dialog$e 要素 ＊／ 文書＊
］である：
◎
The currently focused area of a top-level browsing context at any particular time is the focusable area or dialog returned by this algorithm:
</p>

<p class="trans-note">【†＊
原文では、 “~top-level閲覧文脈の現focused域” で一つの用語として定義されているが、長いので単に “現focused域” と略記する。
現focused域は、各~top-level閲覧文脈ごとに定義されるのか，ある一つの “現在~focusされている” ~top-level閲覧文脈に対してのみ定義されるのかは、原文の記述からは区別できない。
】</p>

<ol>
	<li>
%候補 ~LET %T にて`作動中の文書$
◎
Let candidate be the Document of the top-level browsing context.
</li>
	<li>
<p>
~WHILE：
</p>

		<ol>
			<li>
~IF［
%候補 の`指名focus~dialog$ ~NEQ ε
］
⇒
%候補 ~LET その指名focus~dialog＊？；<br />
~CONTINUE
</li>

			<li>
<p >
~IF［
%候補 の`指名focus域$ ~NEQ ε
］
</p>
				<ol>
					<li>
%候補 ~SET その指名focus域
</li>
					<li>
~IF［
%候補 は`閲覧文脈~容器$である
］
⇒
%候補 ~LET %C が`入子にしている閲覧文脈$において`作動中の文書$；<br />
~CONTINUE
</li>
					<li>
~BREAK
</li>
				</ol>
			</li>
		</ol>
◎
If candidate has a dialog group with a designated focused dialog of the dialog group, then let candidate be the designated focused dialog of the dialog group, and redo this step.
◎
Otherwise, if candidate has a non-empty control group, and the designated focused area of the control group is a browsing context container, then let candidate be the active document of that browsing context container's nested browsing context, and redo this step.
◎
Otherwise, if candidate has a non-empty control group, let candidate be the designated focused area of the control group.
</li>
	<li>
~RET %候補
◎
Return candidate.
</li>

</ol>


<p>
要素が
`~focusされ@
ているとは、要素は，ある`可focus域$ %F の`~DOM~anchor$であって，
%F は`現focused域$であることをいう。
要素が`~focusされ$るようになることを、
`~focusを~gain@
するともいう。
<!-- ＊
原文と定義の仕方を逆に
 -->
◎
An element that is the DOM anchor of a focusable area is said to gain focus when that focusable area becomes the currently focused area of a top-level browsing context. When an element is the DOM anchor of a focusable area of the currently focused area of a top-level browsing context, it is focused.
</p>


<p>
`可focus域$ ／ `所有者~obj$
%~subject の
`~focus鎖@
は
次に従って構築される有順序~listである：
◎
The focus chain of a focusable area or control group owner object subject is the ordered list constructed as follows:
</p>

<ol>
	<li>
%現~obj ~LET %~subject
◎
Let current object be subject.
</li>
	<li>
%出力 ~LET 空~list
◎
Let output be an empty list.
</li>
	<li>
<p>
<!-- Loop -->
~WHILE：
</p>
		<ol>
			<li>
%出力 に %現~obj を付加する
◎
Loop: Append current object to output.
</li>
			<li>
<p>
~IF［
%現~obj は `area$e 要素の~shapeである
］
⇒
%出力 に その `area$e 要素を付加する
◎
If current object is an area element's shape, append that area element to output.
</p>

<p>
~ELIF［
%現~obj は`可focus域$であって
その`~DOM~anchor$は要素であって
その %現~obj 自身ではない,
］
⇒
%出力 に
その `~DOM~anchor$ 要素を付加する
◎
Otherwise, if current object is a focusable area whose DOM anchor is an element that is not current object itself, append that DOM anchor element to output.
</p>

			</li>
			<li>
<p>
~IF［
%現~obj は，ある`~dialog群$内の `dialog$e ~objである
］
⇒
%現~obj ~SET その`~dialog群$の`~manager$；<br>
~CONTINUE
◎
If current object is a dialog object in a dialog group, let current object be that dialog group's manager, and return to the step labeled loop.
</p>


<p>
~IF［
%現~obj は`可focus域$である
］
⇒
%現~obj ~SET その`可focus域$が所属する`~control群$の`所有者~obj$；<br>
~CONTINUE
◎
Otherwise, if current object is a focusable area, let current object be that focusable area's control group's owner object, and return to the step labeled loop.
</p>


<p>
~IF［
%現~obj は `入子の閲覧文脈$内の`文書$である
］
⇒
%現~obj ~SET %現~objの`閲覧文脈~容器$；<br>
~CONTINUE
◎
Otherwise, if current object is a Document in a nested browsing context, let current object be its browsing context container, and return to the step labeled loop.
</p>
</li>
			<li>
~BREAK
</li>

		</ol>
	</li>
	<li>
<p>
~RET %出力
◎
Return output.
</p>
	</li>
</ol>

<p class="note">注記：
~focus鎖は、 %~subject から開始して，（ %~subject が`現focused域$である／なり得るならば）
`~top-level閲覧文脈$の＊作動中の＊`文書$まで，~focus階層を辿り続ける。
◎
The chain starts with subject and (if subject is or can be the currently focused area of a top-level browsing context) continues up the focus hierarchy up to the Document of the top-level browsing context.
</p>

			</section>
			<section id="the-tabindex-attribute">
<h4 title="The tabindex attribute">6.4.3. `tabindex^a 属性</h4>


<div >
<p>
`tabindex@a
内容~属性により、作者は，次について＊~supposeすることを指示できるようになる：
</p>

<ul>
	<li>
要素は`可focus域$になること。
</li>
	<li>
`逐次的~focus~navigation$を利用して到達できるかどうか。
</li>
	<li>
到達できる場合、要素は，逐次的~focus~navigation順序の中でどこに位置するか。
＊相対的~順序。
</li>
</ul>

<p>
“tab index” という名称は、一連の可focus要素を~navigateするときに， “tab” ~keyが共通的に利用されることに~~由来する。
語 “＊~tabbing” とは、逐次的~focus~navigationを利用して到達し得る可focus要素を，前方へ辿ることを指す。
</p>

◎
The tabindex content attribute allows authors to indicate that an element is supposed to be focusable, and whether it is supposed to be reachable using sequential focus navigation and, if so, what is to be the relative order of the element for the purposes of sequential focus navigation. The name "tab index" comes from the common use of the "tab" key to navigate through the focusable elements. The term "tabbing" refers to moving forward through the focusable elements that can be reached using sequential focus navigation.
</div>


<p>
この属性が省略されている場合、~UAは，既定の~s＊？を適用する。
（`具現化され$ている要素を可focusでなくする仕方は、それを`不能化-$するか`不活$にする他にない。）
◎
When the attribute is omitted, the user agent applies defaults. (There is no way to make an element that is being rendered be not focusable at all without disabling it or making it inert.)
</p>


<p>
`tabindex$a 属性に指定される値は、`妥当な整数$で~MUST。
正の数は、`逐次的~focus~navigation順序$における，要素の`可focus域$の相対的~位置＊を指定する。
負の数は、当の~controlが，`逐次的~focus~navigation$においては到達できなくなることを指示する。
◎
The tabindex attribute, if specified, must have a value that is a valid integer. Positive numbers specify the relative position of the element's focusable areas in the sequential focus navigation order, and negative numbers indicate that the control is to be unreachable by sequential focus navigation.
</p>


<p>＊
開発者は `tabindex$a 属性に対する 0, −1 以外の値は注意して利用するべきである。
 as this is complicated to do 正しく＊correctly
◎
Developers should use caution when using values other than 0 or −1 for their tabindex attributes as this is complicated to do correctly.
</p>

<p>
各~要素には
`~tabindex~focus~flag@
が結付けられ、下に定義されるように ~ON にされ得る。
以前の節0で述べたように、この~flagは，要素が`可focus域$になるかどうか決定する要因になる。
◎
Each element can have a tabindex focus flag set, as defined below. This flag is a factor that contributes towards determining whether an element is a focusable area, as described in the previous section.
</p>


<p>
要素~上に指定される `tabindex$a 属性の値は
`整数として構文解析-$され~MUST。
属性の有無 ／ その値は、次のように解釈され~MUST：
◎
If the tabindex attribute is specified on an element, it must be parsed using the rules for parsing integers. The attribute's values, or lack thereof, must be interpreted as follows:
</p>

<dl>
	<dt>
属性は省略されているか，値を構文解析した結果は~errorになる場合：
◎
If the attribute is omitted or parsing the value returns an error
</dt>
	<dd>
<p>
~UAは、~platform規約に従って，次を決定するべきである
⇒
要素の`~tabindex~focus~flag$は ~ON にされるか？
— そうであれば
⇒
［
要素, または要素を`~DOM~anchor$とする`可focus域$
］へは、`逐次的~focus~navigation$を利用して到達できるか？
— そうであれば
⇒
`逐次的~focus~navigation順序$において 要素／可focus域はどこに＊相対的~位置するか？
◎
The user agent should follow platform conventions to determine if the element's tabindex focus flag is set and, if so, whether the element and any focusable areas that have the element as their DOM anchor can be reached using sequential focus navigation, and if so, what their relative position in the sequential focus navigation order is to be.
</dd>
	<dd>
<p>
最大公約数的な~platform規約として、次の要素に対しては，`~tabindex~focus~flag$を ~ON に設定することが推薦される：
◎
Modulo platform conventions, it is suggested that for the following elements, the tabindex focus flag be set:
</p>

<ul>
	<li>
`href$a 属性を有する `a$e 要素
◎
a elements that have an href attribute
</li>
	<li>
`＊href$a 属性を有する `link$e
◎
link elements that have an href attribute
</li>
	<li>
`button$e 要素
◎
button elements
</li>
	<li>
`input$e 要素のうち，その `type$a 属性の状態 ~NEQ `Hidden$st なるもの
◎
input elements whose type attribute are not in the Hidden state
</li>
	<li>
`select$e 要素
◎
select elements
</li>
	<li>
`textarea$e 要素
◎
textarea elements
</li>
	<li>
`menuitem$e 要素
◎
menuitem elements
</li>
	<li>
`draggable$a 属性を有する要素であって、それにより，~UAが［
利用者が~pointing装置を利用することなく，要素に対する~drag演算を始める
］ことを可能化するもの。
◎
Elements with a draggable attribute set, if that would enable the user agent to allow the user to begin a drag operations for those elements without the use of a pointing device
</li>
	<li>
`編集中の~host$
◎
Editing hosts
</li>
	<li>
`閲覧文脈~容器$
◎
Browsing context containers
</li>
</ul>
	</dd>
	<dd class="note">注記：
~platform規約を無視して常に要素を（その`~tabindex~focus~flag$を設定して）~focusできるようにするような，妥当な理由としては、要素を作動化するために利用者がとり得る仕組みが，~keyboard動作を通して要素を~focusさせる他にない場合が挙げられる。
◎
One valid reason to ignore the platform conventions and always allow an element to be focused (by setting its tabindex focus flag) would be if the user's only mechanism for activating an element is through a keyboard action that triggers the focused element.
</dd>

	<dt id="negative-tabindex">
値 ~LT 0 の場合：
◎
If the value is a negative integer
</dt>
	<dd>
<p >
~UAは：
</p>
<ul>
	<li>
要素の`~tabindex~focus~flag$は ~ON にし~MUST。
</li>
	<li>
`逐次的~focus~navigation順序$からは、要素を外すべきである。
</li>
</ul>

◎
The user agent must set the element's tabindex focus flag, but should omit the element from the sequential focus navigation order.
</dd>
	<dd class="note">注記：
作者から~~要請される，要素を逐次的~focus~navigationから外す要件を無視する妥当な理由としては、利用者が~focusを移動させる仕組みが，逐次的~focus~navigationの他にない場合が挙げられる。
具体的には、~keyboardのみの利用者は，負の `tabindex$a を伴う~text~fieldを~clickできないので、利用者の~UAは，＊かかわらずに利用者に~tabで~controlへ移れるようにすることは正当化される。
◎
One valid reason to ignore the requirement that sequential focus navigation not allow the author to lead to the element would be if the user's only mechanism for moving the focus is sequential focus navigation. For instance, a keyboard-only user would be unable to click on a text field with a negative tabindex, so that user's user agent would be well justified in allowing the user to tab to the control regardless.
</dd>

	<dt>
値 ~EQ ~zero の場合：
◎
If the value is a zero
</dt>
	<dd>
<p>
~UAは：
</p>

<ul>
	<li>
要素の`~tabindex~focus~flag$は ~ON にし~MUST。
</li>
	<li>
［
要素, および要素を`~DOM~anchor$とする`可focus域$
］へ， `逐次的~focus~navigation$を利用して到達できるようにするべきである。
</li>
	<li>
`逐次的~focus~navigation順序$における要素の相対的~位置を決定する際には、~platform規約に従うべきである。
</li>
</ul>

◎
The user agent must set the element's tabindex focus flag, should allow the element and any focusable areas that have the element as their DOM anchor to be reached using sequential focus navigation, following platform conventions to determine the element's relative position in the sequential focus navigation order.
</dd>

	<dt>
値 ~GT ~zero の場合：
◎
If the value is greater than zero
</dt>
	<dd>
<p>
~UAは：
</p>

<ul>
	<li>
要素の`~tabindex~focus~flag$は ~ON にし~MUST。
</li>
	<li>
［
要素, および要素を`~DOM~anchor$とする`可focus域$
］へは，`逐次的~focus~navigation$を利用して到達できるようにする
べきである。
</li>
	<li>
<p>
以下に従って、要素 ／ `可focus域$を逐次的~focus~navigation順序に組み入れるべきである：
</p>

<ul>
	<li>
［
`~tabindex値$ ~GT 0
］なるものが［
`~tabindex値$ ~LTE 0
］なるものより先になる。
</li>
	<li>
<p >
`~tabindex値$ ~GT 0 なるものたちの順序は：
</p>
		<ul>
			<li>
`~tabindex値$の昇順に整列される（値が小さいものが先）
</li>
			<li>
`~tabindex値$が同じものどうしの順序は、`~DOM~anchor$の`木~順序$xに従う
</li>
		</ul>
	</li>
</ul>

<p>
~focus~navigation順序の目的における［
要素／`可focus域$
］の
`~tabindex値@
は、次で定義される：
</p>
		<ul>
			<li>
その`~DOM~anchor$は［
要素である
］~AND［
`tabindex$a 属性を有する
］~AND［
その属性~値は`妥当な整数$である
］ならば、その整数
</li>
			<li>
他の場合は − 1 （負数であれば何でもよい）
</li>
		</ul>
	</li>
</ul>

◎
The user agent must set the element's tabindex focus flag, should allow the element and any focusable areas that have the element as their DOM anchor to be reached using sequential focus navigation, and should place the element — referenced as candidate below — and the aforementioned focusable areas in the sequential focus navigation order so that, relative to other focusable areas in the sequential focus navigation order, they are:
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has been omitted or whose value, when parsed, returns an error,
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to or less than zero,
◎
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than zero but less than the value of the tabindex attribute on candidate,
◎
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is earlier in the document in tree order than candidate,
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is later in the document in tree order than candidate, and
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than the value of the tabindex attribute on candidate.
</dd>
</dl>


<p>
要素の`~tabindex~focus~flag$が ~ON にされても，他から`作動化の挙動$が定義されていなければ、その`作動化の挙動$は何もしない。
◎
An element that has its tabindex focus flag set but does not otherwise have an activation behaviour defined has an activation behaviour that does nothing.
</p>


<p class="note">注記：
このことは、 `tabindex$a 属性によってのみ可focusになっている要素に対しては、非~mouseによる作動化（例： 要素が`~focusされ$ている間に “enter” ~keyを叩いて）に呼応して `click$et ~eventが発火されることを意味する。
◎
This means that an element that is only focusable because of its tabindex attribute will fire a click event in response to a non-mouse activation (e.g. hitting the "enter" key while the element is focused).
</p>


<p>
`tabindex$a 属性が指定されている要素は、`対話的~内容$になる。
◎
An element with the tabindex attribute specified is interactive content.
</p>


<p>
`tabIndex@m
~IDL属性は、 `tabindex$a 内容~属性の値を`反映-$し~MUST。
その既定~値は、［
可focus要素に対しては 0 ／
可focusでない要素に対しては −1 
］とする。
◎
The tabIndex IDL attribute must reflect the value of the tabindex content attribute. Its default value is 0 for elements that are focusable and −1 for elements that are not focusable.
</p>


			</section>
			<section id="processing-model-5">
<h4 title="Processing model">6.4.4. 処理~model</h4>


<div>
<p>
所与の %新~focus標的 を
`~focusする手続き@
は、次で与えられる
— その~~入力は：
</p>

<ul>
	<li>
%新~focus標的
— ［
`可focus域$ ／ `可focus域$でない要素 ／ `閲覧文脈$
］のいずれかである~obj
</li>
	<li>
`~fallback標的^i （省略時は ε ）
</li>

</ul>

◎
The focusing steps for an object new focus target that is either a focusable area, or an element that is not a focusable area, or a browsing context, are as follows. They can optionally be run with a fallback target.
</div>

<ol>
	<li>
<div >
<p>
~IF［
%新~focus標的 は，次の両者を満たす
］…：
</p>

<ul ><li>`dialog$e 要素でも`所有者~obj$でもない
</li><li>`可focus域$でない
</li></ul>

<p>
…ならば
⇒
%新~focus標的 ~SET 次のうち， %新~focus標的 が最初に満たす条件に対応する~obj：
</p>
◎
If new focus target is neither a dialog element that has an open attribute specified and that is being rendered (i.e. that is a control group owner object), nor a focusable area, then run the first matching set of steps from the following list:
</div>

<dl class="switch">
	<dt>
`area$e 要素である
~AND
`可focus域$であるような~shapeを，1 個以上~伴う
◎
If new focus target is an area element with one or more shapes that are focusable areas
</dt>
	<dd>
それらの~shapeのうち，［
対応している `img$e 要素は［
%新~focus標的 が所属する画像~mapを利用している
］］もののうち，要素の`木~順序$xで最初のもの。
◎
Let new focus target be the shape corresponding to the first img element in tree order that uses the image map to which the area element belongs.
</dd>
	<dt>
要素であって，`可focus域$である 1 個以上の~scrollable領域を伴う
◎
If new focus target is an element with one or more scrollable regions that are focusable areas
</dt>
	<dd>
要素の最初の~scrollable領域
—＊
~box木の
~pre-order, ~depth-first走査
に則って最初の
`CSS$r
◎
Let new focus target be the element's first scrollable region, according to a pre-order, depth-first traversal of the box tree. [CSS]
</dd>
	<dt>
`文書~要素$である
◎
If new focus target is the document element of its Document
</dt>
	<dd>
`文書$の`表示域$x
◎
Let new focus target be the Document's viewport.
</dd>
	<dt>
`閲覧文脈$である
◎
If new focus target is a browsing context
</dt>
	<dd>
%新~focus標的 において`作動中の文書$
◎
Let new focus target be the browsing context's active document.
</dd>
	<dt>
`閲覧文脈~容器$である
◎
If new focus target is a browsing context container
</dt>
	<dd>
%新~focus標的 が`入子にしている閲覧文脈$において`作動中の文書$
◎
Let new focus target be the browsing context container's nested browsing context's active document.
</dd>
	<dt>
他の場合：
◎
Otherwise
</dt>
	<dd>
`~fallback標的^i
◎
If no fallback target was specified, abort the focusing steps.
◎
Otherwise, let new focus target be the fallback target.
↓</dd>
		</dl>
	</li>
	<li>
~IF［
%新~focus標的 ~EQ ε
］
⇒
~RET
◎
↑</li>
	<li>
<p>
~WHILE：
</p>
		<ol>
			<li>
<p >
~IF［
%新~focus標的 は［
`所有者~obj$である
~AND
`可focus域$でない
］］
</p>

				<ol>
					<li>
~IF［
%新~focus標的 の`指名focus~dialog$ ~NEQ ε
］
⇒
%新~focus標的 ~SET それ
</li>
					<li>
~ELIF［
%新~focus標的 の`指名focus域$ ~NEQ ε
］
⇒
%新~focus標的 ~SET それ
<!-- ＊designate  -->
</li>
					<li>
~CONTINUE
</li>
				</ol>

◎
If new focus target is a control group owner object that is not a focusable area, but does have a dialog group, and that dialog group has a designated focused dialog, then let new focus target be the focused dialog of the dialog group, and redo this step.
◎
Otherwise, if new focus target is a control group owner object that is not a focusable area, and its control group is not empty, then designate new focus target as the focused area of the control group, and redo this step.
</li>
			<li>
~ELIF［
%新~focus標的 は`閲覧文脈~容器$である
］
⇒
%新~focus標的 ~SET %新~focus標的 が`入子にしている閲覧文脈$において`作動中の文書$
◎
Otherwise, if new focus target is a browsing context container, then let new focus target be the nested browsing context's active document, and redo this step.
</li>

			<li>
~ELSE
⇒
~BREAK
</li>
		</ol>

<p class="note">注記：
`具現化され$ている `dialog$e 要素は、［
`open$a, `tabindex$a
］両~属性が指定されている場合，`所有者~obj$であると同時に`可focus域$になり得る。
◎
A dialog element can be both a control group owner object and a focusable area, if it has both an open attribute specified and a tabindex attribute specified and is being rendered.
</p>
	</li>
	<li>
~IF［
%新~focus標的 は`可focus域$である
］~AND［
%新~focus標的 の`~DOM~anchor$は`不活$である
］
⇒
~RET
◎
If new focus target is a focusable area and its DOM anchor is inert, then abort these steps.
</li>
	<li>
~IF［
%新~focus標的 ~EQ `現focused域$
］
⇒
~RET
◎
If new focus target is the currently focused area of a top-level browsing context, then abort these steps.
</li>
	<li>
%旧~鎖 ~LET %新~focus標的 が見出される`~top-level閲覧文脈$の`現focused域$の`~focus鎖$
◎
Let old chain be the focus chain of the currently focused area of the top-level browsing context in which new focus target finds itself.
</li>
	<li>
%新~鎖 ~LET %新~focus標的 の`~focus鎖$
◎
Let new chain be the focus chain of new focus target.
</li>
	<li>
( %旧~鎖, %新~鎖, %新~focus標的 )
を与える下で，`~focus更新~手続き$を走らす
◎
Run the focus update steps with old chain, new chain, and new focus target respectively.
</li>

</ol>

<p>
~UAは、［
`可focus域$ ／ `dialog$e ／ `閲覧文脈$
］ %候補
に対し，利用者が~focusを %候補 に移動しようと試みたときには、
%候補 を`~focusする手続き$を`即時に$走らせ~MUST。
◎
User agents must immediately run the focusing steps for a focusable area, dialog, or browsing context candidate whenever the user attempts to move the focus to candidate.
</p>


<p>
［
`可focus域$ ／ `可focus域$でない要素
］~obj %旧~focus標的
を
`~unfocusする手続き@
は、次で与えられる：
◎
The unfocusing steps for an object old focus target that is either a focusable area or an element that is not a focusable area are as follows:
</p>

<ol>
	<li>
~IF［
%旧~focus標的 は`不活$である
］
⇒
~RET
◎
If old focus target is inert, then abort these steps.
</li>
	<li>
%現focused域 ~LET `現focused域$
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

		<ul>
			<li>
［
%旧~focus標的 は `area$e 要素である
］~AND［
その~shapeのいずれかが %現focused域 である
］
</li>
			<li>
［
%旧~focus標的 は要素である
］~AND［
その要素は 1 つ以上の~scrollable領域を持つ
］~AND［
それらの領域のうち，いずれかは %現focused域 である
］
</li>
		</ul>

<p>
…ならば
⇒
%旧~focus標的 ~LET %現focused域
◎
If old focus target is an area element and one of its shapes is the currently focused area of a top-level browsing context, or, if old focus target is an element with one or more scrollable regions, and one of them is the currently focused area of a top-level browsing context, then let old focus target be that currently focused area of a top-level browsing context.
</p>

	</li>
	<li>
%旧~鎖 ~LET %現focused域 の`~focus鎖$
◎
Let old chain be the focus chain of the currently focused area of a top-level browsing context.
</li>
	<li>
~IF［
%旧~focus標的 ~NIN %旧~鎖
］
⇒
~RET
◎
If old focus target is not one of the entries in old chain, then abort these steps.
</li>
	<li>
<p>
~IF［
%旧~focus標的 は、ある`~dialog群$ %G 内の `dialog$e である
］~AND［
%G の`~manager$の`指名focus域$ ~NEQ ε
］
⇒
%新~focus標的 ~LET その指名focus域
◎
If old focus target is a dialog in a dialog group, and the dialog group manager has a non-empty control group, then let new focus target be the designated focused area of that focus group.
</p>

<p>
~ELIF［
%旧~focus標的 は`可focus域$である
］
⇒
%新~focus標的 ~LET %旧~focus標的 の`~control群$の最初の`可focus域$
（`所有者~obj$は`文書$ならば、これは常に`表示域$xになる。）
◎
Otherwise, if old focus target is a focusable area, then let new focus target be the first focusable area of its control group (if the control group owner object is a Document, this will always be a viewport).
</p>


<p>
~ELSE
⇒
~RET
◎
Otherwise, let new focus target be null.
</p>
	</li>
	<li>
~IF［
%新~focus標的 ~NEQ ~NULL
］
⇒
%新~focus標的 を`~focusする手続き$を走らす
◎
If new focus target is not null, then run the focusing steps for new focus target.
</li>

</ol>


<p>
`現focused域$が，それに代わる別の要素が明示的に~focusされずに，何らかの方法で~unfocuseされた場合、~UAは，その~objを`~unfocusする手続き$を`即時に$走らせ~MUST。
◎
When the currently focused area of a top-level browsing context is somehow unfocused without another element being explicitly focused in its stead, the user agent must immediately run the unfocusing steps for that object.
</p>


<p class="note">注記：
`~unfocusする手続き$により，常に~focusが変更されるとは限らない
— `現focused域$に適用されるときであっても。
例えば，`現focused域$は`表示域$xである場合、通例的には，別の`可focus域$を`~focusする手続き$により明示的に~focusされるまで，その~focusを保つことになる。
◎
The unfocusing steps do not always result in the focus changing, even when applied to the currently focused area of a top-level browsing context. For example, if the currently focused area of a top-level browsing context is a viewport, then it will usually keep its focus regardless until another focusable area is explicitly focused with the focusing steps.
</p>


<hr>

<ul>
	<li>
`可focus域$ %A が 空`~control群$ %G に追加されたときは
⇒
%A が， %G の`指名focus域$にされ~MUST。
◎
When a focusable area is added to an empty control group, it must be designated the focused area of the control group.
</li>

	<li>
<p>
`~dialog群$ %G が形成されるとき、
%G の`~manager$の`~control群$が空の場合、
次の手続きから返される結果が
%G の`指名focus~dialog$にされ~MUST：
</p>

		<ol>
			<li>
~IF［
%G 内に`不活$でない `dialog$e がある
］
⇒
~RET それらのうち，最初のもの
</li>
			<li>
~RET %G 内の最初の`dialog$e
</li>
		</ol>

＊空でない場合はどうなる？

◎
When a dialog group is formed, if the dialog group manager has an empty control group, the first non-inert dialog in the dialog group, if any, or else the first dialog in the dialog group regardless of inertness, must be designated the focused dialog of the dialog group.
</li>


	<li>
<div>
<p>
`~focus修復~規則 1@
：
`~control群$ %G から何らかの仕方で
`指名focus域$が除去されたとき（例：
`指名focus域$が［
`可focus域$でなくなった ／
~DOMから除去された ／
`明に不活$になった
］とき, 等々）には、次の手続きから返される結果を
%G の新たな`指名focus域$にする：
</p>

<ol>
	<li>
%G ~LET 当の`~control群$から当の`指名focus域$を除去した結果
</li>
	<li>
~IF［
%G 内に`不活$でない`指名focus域$がある
］
⇒
~RET それらのうち最初のもの
</li>
	<li>
~IF［
%G は空でない
］
⇒
~RET %G 内の最初のもの
</li>
	<li>
~RET ε（なし）
</li>
</ol>

◎
Focus fixup rule one: When the designated focused area of a control group is removed from that control group in some way (e.g. it stops being a focusable area, it is removed from the DOM, it becomes expressly inert, etc), and the control group is still not empty: designate the first non-inert focused area in that control group to be the new focused area of the control group, if any; if they are all inert, then designate the first focused area in that control group to be the new focused area of the control group regardless of inertness. If such a removal instead results in the control group being empty, then there is simply no longer a focused area of the control group.
</div>


<div class="example">
<p>
これは、例えば次のときに起こり得る：
</p>

<ul><li>要素が`文書$から除去されたとき
</li><li>`hidden$a 属性が追加されたとき
</li><li>`input$e 要素が`不能化され$たとき
</li></ul>
◎
For example, this might happen because an element is removed from its Document, or has a hidden attribute added. It might also happen to an input element when the element gets disabled.
</div>

	</li>
	<li>
<p>
`~focus修復~規則 2@：
［
`~dialog群$ %G の`指名focus~dialog$ ~EQ ε
］~AND［
%G の`~manager$の`~control群$は，空でないから空に変化した場合、次の手続きから返される結果を＊＊
%G を新たに`指名focus~dialog$にする：
</p>

<ol>
	<li>
%G 内に `不活$でない `dialog$e があれば
それらのうち最初の
</li>
	<li>
~RET %G 内の最初の `dialog$e
</li>
</ol>

◎
Focus fixup rule two: When a dialog group has no designated focused dialog of the dialog group, and its dialog group manager's control group changes from being non-empty to being empty, the first non-inert dialog in the dialog group, if any, or else the first dialog in the dialog group regardless of inertness, must be designated the focused dialog of the dialog group.
</li>

<li>
<p>
`~focus修復~規則 3@：
`~dialog群$ %G から %G の`指名focus~dialog$が何らかの仕方で除去されたと（例：
それは［
`具現化され$なくなった ／
`open$a 属性を失った ／
`明に不活$dlgになった,
］等々），
%G は依然として存続している（その %G 内に他の `dialog$e があるなど）
］場合、
%G の`指名focus~dialog$を，次の手続きから返される結果にする：
</p>

<ol>
	<li>
~IF［
%G の`~manager$の`~control群$は空でない
］
⇒
~RET ε
</li>
	<li>
~IF［
%G 内に`不活$でない `dialog$e がある
］
⇒
~RET それ
</li>
	<li>
~RET %G 内の最初の `dialog$e
</li>
</ol>

◎
Focus fixup rule three: When the designated focused dialog of a dialog group is removed from that dialog group in some way (e.g. it stops being rendered, it loses its open attribute, it becomes expressly inert, etc), and there is still a dialog group (because the dialog in question was not the last dialog in that dialog group): if the dialog group's manager's control group is non-empty, let there be no designated focused dialog of the dialog group any more; otherwise (in the case that the control group is empty), designate the first non-inert dialog in the dialog group to be the focused dialog of the dialog group, or, if they are all inert, designate the first dialog in the dialog group to be the focused dialog of the dialog group regardless of inertness.
</li>

</ul>

<div >
<p>
~UAは、`現focused域$ %F が、次のいずれかのように変化したときは…：
</p>

<ul><li>`可focus域$でなくなった
</li><li>`~dialog群$に属する `dialog$e であったが，属さなくなった
</li><li>`不活$でなくなった
</li></ul>

<p>
次の手続きを走らせ~MUST：
</p>

◎
When the currently focused area of a top-level browsing context was a focusable area but stops being a focusable area, or when it was a dialog in a dialog group and stops being part of that dialog group, or when it starts being inert, the user agent must run the following steps:
</div>

<ol>
	<li>
%旧~時点 ~LET この~algoが適用可能になる直前
</li>
	<li>
%旧~focus標的 ~LET
%旧~時点 における`現focused域$（例：
不能化された要素 ／ 閉じられる前の~dialog ／
この~algoを走らせたもの）。
◎
Let old focus target be whatever the currently focused area of the top-level browsing context was immediately before this algorithm became applicable (e.g. before the element was disabled, or the dialog was closed, or whatever caused this algorithm to run).
</li>
	<li>
%旧~鎖 ~LET %旧~時点 における %旧~focus標的 の`~focus鎖$
◎
Let old chain be the focus chain of the currently focused area of the top-level browsing context at the same time.
</li>
	<li>

その
~the変更
暗黙の~by
~the
上の［
`~focus修復~規則 1$,
`~focus修復~規則 2$,
`~focus修復~規則 3$
］は適用されることを~make~sure。
◎
Make sure that the changes implied by the focus fixup rules one, two, and three above are applied.
</li>
	<li>
%新~focus標的 ~LET `現focused域$
◎
Let new focus target be the currently focused area of a top-level browsing context.
</li>
	<li>
~IF［
%旧~focus標的 ~EQ %新~focus標的
］
⇒
~RET
◎
If old focus target and new focus target are the same, abort these steps.
</li>
	<li>
%新~鎖 ~LET %新~focus標的 の`~focus鎖$
◎
Let new chain be the focus chain of new focus target.
</li>
	<li>
( %旧~鎖, %新~鎖, %新~focus標的 )
を与える下で，`~focus更新~手続き$を走らす
◎
Run the focus update steps with old chain, new chain, and new focus target respectively.
</li>

</ol>
<hr>


<p>
所与の
( %旧~鎖, %新~鎖, %新~focus標的 )
に対する
`~focus更新~手続き@
は、次で与えられる：
◎
The focus update steps, given an old chain, a new chain, and a new focus target respectively, are as follows:
</p>

<ol>
	<li>
~WHILE［
%旧~鎖 内の最後の~entry ~EQ %新~鎖 内の最後の~entry
］
⇒
%旧~鎖 内から最後の~entryを~popする；<br>
%新~鎖 内から最後の~entryを~popする
◎
If the last entry in old chain and the last entry in new chain are the same, pop the last entry from old chain and the last entry from new chain and redo this step.
</li>
	<li>
<p>
~FOR
%旧~鎖 内の
~EACH( ~entry %~entry ) に対し：
◎
For each entry entry in old chain, in order, run these substeps:
</p>

		<ol>
			<li id="unfocus-causes-change-event">
<p>
~IF［
次のいずれも満たされるならば
］…
</p>

<ul ><li>%~entry は `input$e 要素 %要素 である
</li><li>%要素 には `change$et ~eventが
<a href="~HTML-FORMS#concept-input-apply">適用される</a>
</li><li>%要素 には`作動化の挙動$は定義されていない
</li><li>%要素 が~focusされている間に，利用者は %要素 の［
`値$fe ／ 
<a href="~HTML-FORMS#concept-input-type-file-selected">選択-中の~fileの~list</a>
］を変更していて、その（~controlが最初に~focusされたときと異なるような）変更はまだ~commitされていない
</li></ul>

<p>
…ならば
⇒
%要素 に向けて，名前 `change$et, かつ浮上する`単純~eventを発火-$する
</p>
◎
If entry is an input element, and the change event applies to the element, and the element does not have a defined activation behaviour, and the user has changed the element's value or its list of selected files while the control was focused without committing that change (such that it is different to what it was when the control was first focused), then fire a simple event that bubbles named change at the element.
</li>
			<li>
%~blur~event標的 ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry は要素である
］
⇒
%~blur~event標的 ~LET %~entry
◎
If entry is an element, let blur event target be entry.
</li>
			<li>
~ELIF［
%~entry は`文書$である
］
⇒
%~blur~event標的 ~LET その`文書$の `Window$I ~obj
◎
If entry is a Document object, let blur event target be that Document object's Window object.
◎
Otherwise, let blur event target be null.
</li>
			<li>
＊%relatedTargt ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry ~EQ %旧~鎖 内の最後の~entry
］~AND［
%~entry は`要素$である
］~AND［
%新~鎖 内の最後の~entryは`要素$である
］
⇒
%relatedTargt ~LET %新~鎖 内の最後の~entry
◎
If entry is the last entry in old chain, and entry is an Element, and the last entry in new chain is also an Element, then let related blur target be the last entry in new chain. Otherwise, let related blur target be null.
</li>
			<li>
<p>
~IF［
%~blur~event標的 ~NEQ ~NULL
］
⇒
( `blur$et, %relatedTargt )
を与える下で， %~blur~event標的 に向けて`~focus~eventを発火-$する
◎
If blur event target is not null, fire a focus event named blur at blur event target, with related blur target as the related target.
</p>


<p class="note">注記：
~eventは発火されない事例もある
— 例えば、 %~entry は［
`area$e 要素の~shape ／ ~scrollable領域 ／ `表示域$x
］であるとき。
◎
In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.
</p>

			</li>
		</ol>
	</li>
	<li>
~IF［
%新~focus標的 の~focus時に，~platform特有の関連する規約がある
］
⇒
その規約を適用する（例えば，一部の~platformは、~text~fieldに~focusされたときに，その内容を選択する）
◎
Apply any relevant platform-specific conventions for focusing new focus target. (For example, some platforms select the contents of a text field when that field is focused.)
</li>
	<li>
<p>
~FOR
%新~鎖 内の ~EACH( ~entry %~entry ) に対し，逆順に：
◎
For each entry entry in new chain, in reverse order, run these substeps:
</p>

		<ol>
			<li>
~IF［
%~entry は `dialog$e 要素である
］
⇒
%~entry ~LET %~entry が属する~dialog群の`指名focus~dialog$
◎
If entry is a dialog element: Let entry be the designated focused dialog of its dialog group.
</li>
			<li>

<div >
<p>
~IF［
%~entry は`可focus域$である
］：
</p>
				<ol>
					<li>
%~entry の＊所有者の`指名focus域$ ~SET %~entry
</li>
					<li>
不要＊
%~control群 ~LET %~entry が属する~control群
</li>
					<li>
不要＊
%~control群 の`指名focus域$ ~SET %~entry
</li>
					<li>
＊%~entry の所有者の`指名focus~dialog$ ~SET ε
</li>
					<li>
不要＊
~IF［
%~control群 の`所有者~obj$は`~dialog群~manager$＊ ~NEQ ε
］
⇒
その`~dialog群$の`指名focus~dialog$ ~SET ε
</li>
				</ol>
◎
If entry is a focusable area: Designate entry as the focused area of the control group. If its control group's owner object is also a dialog group manager, then let there be no designated focused dialog in that dialog group.
</div>


<p class="note">注記：
%~entry は `dialog$e 要素であると同時に，`可focus域$でもあることもあり得る
— その場合、それ自身が`所有者~obj$になる。
◎
It is possible for entry to be both a dialog element and a focusable area, in which case it is its own control group owner object.
</p>

			</li>
			<li>
%~focus~event標的 ~LET ~NULL
◎
↓</li>
			<li>

~IF［
%~entry は要素である
］
⇒
%~focus~event標的 ~SET %~entry
◎
If entry is an element, let focus event target be entry.
</li>
			<li>
~IF［
%~entry は`文書$である
］
⇒
%~focus~event標的 ~SET その`文書$の `Window$I ~obj。
◎
If entry is a Document object, let focus event target be that Document object's Window object.
◎
Otherwise, let focus event target be null.
</li>
			<li>
%relatedTargt ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry ~EQ %新~鎖 内の最後の~entry
］~AND［
%~entry は`要素$である
］~AND［
%旧~鎖 内の最後の~entryは`要素$である
］
⇒
%relatedTargt ~SET %旧~鎖 内の最後の~entry
◎
If entry is the last entry in new chain, and entry is an Element, and the last entry in old chain is also an Element, then let related focus target be the last entry in old chain. Otherwise, let related focus target be null.
</li>
			<li>
<p>
~IF［
%~focus~event標的 ~NEQ ~NULL
］
⇒
( `focus$et, %relatedTargt )
を与える下で， %~focus~event標的 に向けて`~focus~eventを発火-$する
◎
If focus event target is not null, fire a focus event named focus at focus event target, with related focus target as the related target.
</p>


<p class="note">注記：
~eventは発火されない事例もある
— 例えば、 %~entry は［
`area$e 要素の~shape ／
~scrollable領域 ／
`表示域$x
］であるとき。
◎
In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.
</p>

			</li>
		</ol>
	</li>
</ol>


<div>
<p>
~UAは、
( 名前 %e, 関係する標的 %r )
が与えられた下で，要素 %t に向けて
`~focus~eventを発火-@
するよう要求されたときは、次のようにされた~eventを作成した上で，
%t に向けて`配送-$し~MUST：
</p>

<ul ><li>`~trusted$である
</li><li>`FocusEvent$I ~objである
</li><li>所与の名前 %e に初期化する
</li><li>浮上しない
</li><li>取消可能でない
</li><li>各種~属性は、次のように初期化する
	<ul><li>`relatedTarget$m ~SET %r
	</li><li>`view$m ~SET %t の`文書$の `Window$I ~obj
	</li><li>`detail$m ~SET 0
	</li></ul>
</li></ul>

◎
When a user agent is required to fire a focus event named e at an element t and with a given related target r, the user agent must create a trusted FocusEvent object, initialise it to have the given name e, to not bubble, to not be cancelable, and to have the relatedTarget attribute initialised to r, the view attribute initialised to the Window object of the Document object of t, and the detail attribute initialised to 0, and must then dispatch the newly created FocusEvent object at the specified target element t.
</div>


<hr>

<p>
~UAは、`~top-level閲覧文脈$内で~key~event %~event を~routeするときは、次の手続きを走らせ~MUST：
◎
When a key event is to be routed in a top-level browsing context, the user agent must run the following steps:
</p>

<ol>
	<li>
%標的~域 ~LET `現focused域$
◎
Let target area be the currently focused area of the top-level browsing context.
</li>
	<li>
%標的~node ~LET ［
%標的~域 は`可focus域$ならば %標的~域 の`~DOM~anchor$ ／
~ELSE_（ %標的~域は `dialog$e である ） %標的~域
］
◎
If target area is a focusable area, let target node be target area's DOM anchor. Otherwise, target area is a dialog; let target node be target area.
</li>
	<li>
<p>
~IF［
%標的~node は`文書$であって`~body要素$を持つ
］
⇒
%標的~node ~SET その`~body要素$
◎
If target node is a Document that has a body element, then let target node be the body element of that Document.
</p>

<p>
~ELIF［
%標的~node は`文書$である
］~AND［
＊%標的~node の`文書~要素$ ~NEQ ~NULL
］
⇒
%標的~node ~SET %標的~node の`文書~要素$
◎
Otherwise, if target node is a Document object that has a non-null document element, then let target node be that document element.
</p>
	</li>
	<li>
<p>
~IF［
%標的~node は`不活$でない
］
⇒
%標的~node に向けて %~event を発火する
◎
If target node is not inert, fire the event at target node.
</p>


<p class="note">注記：
`現focused域$が`不活$である場合もあり得る
— 例えば`~modal~dialogが示され$ていて
~and~then
その `dialog$e 要素が`不活$にされているとき。
それは，~the~appにおける~logicに誤りがある結果による可能性が高いが。
◎
It is possible for the currently focused area of a top-level browsing context to be inert, for example if a modal dialog is shown, and then that dialog element is made inert. It is likely to be the result of a logic error in the application, though.
</p>

	</li>
	<li>
~IF［
 %~event は取消されなかった
］
⇒
%標的~域 に %~event を取扱わせる
— これは、 %標的~node に対する`合成~click作動化~手続きを走らす$ことも含み得る~might。
◎
If the event was not canceled, then let target area handle the key event. This might include running synthetic click activation steps for target node.
</li>

</ol>

<hr>

<p>
所与の`文書$ %標的 に対する
`~has~focus手続き@
は、次で与えられる：
◎
The has focus steps, given a Document object target, are as follows:
</p>

<ol>
	<li>
%候補 ~LET `~top-level閲覧文脈$の`文書$
◎
Let candidate be the Document of the top-level browsing context.
</li>
	<li>
~IF［
%候補 ~EQ %標的
］
⇒
~RET ~T
◎
If candidate is target, return true and abort these steps.
</li>
	<li>
<p>
~WHILE：
</p>

		<ol>
			<li>
~IF［
%候補 の`指名focus~dialog$ ~NEQ ε
］
⇒
%候補 ~LET その指名focus~dialog
◎
If candidate has a dialog group with a designated focused dialog of the dialog group, then let candidate be the designated focused dialog of the dialog group, and redo this step.
</li>
			<li>
<p>
~ELIF［
%候補 の`指名focus域$ ~NEQ ε
］~AND［
その`指名focus域$は`閲覧文脈~容器$である
］：
</p>

				<ol>
					<li>
%文書 ~LET その`閲覧文脈~容器$が`入子にしている閲覧文脈$において`作動中の文書$
</li>
					<li>
~IF［
%文書 ~EQ %標的
］
⇒
~RET ~T
</li>
					<li>
%候補 ~LET %文書
</li>
				</ol>
◎
Otherwise, if candidate has a non-empty control group, and the designated focused area of the control group is a browsing context container, and the active document of that browsing context container's nested browsing context is target, then return true and abort these steps.
◎
Otherwise, if candidate has a non-empty control group, and the designated focused area of the control group is a browsing context container, then let candidate be the active document of that browsing context container's nested browsing context, and redo this step.
</li>
			<li>
~ELSE
⇒
~RET ~F
◎
Otherwise, return false and abort these steps.
</li>
		</ol>
	</li>
</ol>


			</section>
			<section id="sequential-focus-navigation">
<h4 title="Sequential focus navigation">6.4.5. 逐次的~focus~navigation</h4>


<p>
各`~control群$では、それが含む一部または全部の`可focus域$が
`逐次的~focus~navigation順序@
により順序付けられる。
この順序は、`~control群$ 自身における~the順序＊何の？＊に関係する必要はない。
`~control群$の`逐次的~focus~navigation順序$から＊省略された`可focus域$は、`逐次的~focus~navigation$を介しては到達できない。
◎
Each control group has a sequential focus navigation order, which orders some or all of the focusable areas in the control group relative to each other. The order in the sequential focus navigation order does not have to be related to the order in the control group itself. If a focusable area is omitted from the sequential focus navigation order of its control group, then it is unreachable via sequential focus navigation.
</p>


<p>
逐次的~focus~navigationには
＊`逐次的~focus~navigationの始点@
もある
— 初期時には ε （未設定）とする。
~UAは、利用者が＊それを移動すべく指示したときに，この始点を設定してよい。
◎
There can also be a sequential focus navigation starting point. It is initially unset. The user agent may set it when the user indicates that it should be moved.
</p>


<p class="example">
例えば~UAは、利用者が文書の内容を~clickしたときに，その~click位置に設定することもできる。
◎
For example, the user agent could set it to the position of the user's click if the user clicks on the document contents.
</p>

<div >
<p>
~UAは、利用者から次のいずれかが要請されたときは：
</p>
<ul>
	<li>(A)
~top-level閲覧文脈の %T の`現focused域$から
＊次0の／前の
`可focus域$へ~focusを移動する（例えば，~tab~keyを押すことによる既定の動作として）
</li>
	<li>(B)
%T の外側から~focusを先ず %T へ移動する（例えば，~browserの＊所在barから）
</li>
</ul>

<p>
次の~algoを利用し~MUST：
</p>
◎
When the user requests that focus move from the currently focused area of a top-level browsing context to the next or previous focusable area (e.g. as the default action of pressing the tab key), or when the user requests that focus sequentially move to a top-level browsing context in the first place (e.g. from the browser's location bar), the user agent must use the following algorithm:
</div>

<ol>
	<li>
%始点 ~LET 上述の［
(A) ならば %T の`現focused域$ ／
(B) ならば %T
］
◎
Let starting point be the currently focused area of a top-level browsing context, if the user requested to move focus sequentially from there, or else the top-level browsing context itself, if the user instead requested to move focus from outside the top-level browsing context.
</li>
	<li>
%~focus始点 ~LET `逐次的~focus~navigationの始点$
</li>
	<li>
~IF［
%~focus始点 ~NEQ ε
］~AND［
%~focus始点 は %始点 の内側にある
］
⇒
%始点 ~LET %~focus始点
◎
If there is a sequential focus navigation starting point defined and it is inside starting point, then let starting point be the sequential focus navigation starting point instead.
</li>
	<li>
<p>
%方向 ~LET 
利用者が要請した~navigation方向
— `前方^i または `後方^i
◎
Let direction be forward if the user requested the next control, and backward if the user requested the previous control.
</p>

<p class="note">注記：
概して、［
<kbd>tab</kbd> ／
<kbd><kbd>shift</kbd>+<kbd>tab</kbd></kbd>
］を押すことは［
前方／後方
］にある~controlへ移動することを要請する。
◎
Typically, pressing tab requests the next control, and pressing shift+tab requests the previous control.
</p>
	</li>
	<li>
<p >
~WHILE：
</p>
		<ol>
			<li>
%選定法 ~LET ［
%始点 は`閲覧文脈$である
~OR
%始点 は`~control群$の＊`逐次的~focus~navigation順序$に含まれる
］ならば `逐次的^i ／
~ELSE_ `~DOM^i
◎
Loop: Let selection mechanism be sequential if the starting point is a browsing context or if starting point is in its control group's sequential focus navigation order.
◎
Otherwise, starting point is not in its control group's sequential focus navigation order; let selection mechanism be DOM.
</li>
			<li>
%候補 ~LET
( %始点, %方向, %選定法 )
を与える下で，`逐次的~navigation探索~algo$を走らせた結果
◎
Let candidate be the result of running the sequential navigation search algorithm with starting point, direction, and selection mechanism as the arguments.
</li>
			<li>
~IF［
%候補 ~NEQ ~NULL
］
⇒
%候補 を`~focusする手続き$を走らす；<br>
~RET
◎
If candidate is not null, then run the focusing steps for candidate and abort these steps.
</li>
			<li>
`逐次的~focus~navigationの始点$ ~SET ε
◎
Otherwise, unset the sequential focus navigation starting point.
</li>
			<li>
<p>
~IF［
%始点 ~EQ %T
~OR
%始点 は %T 内の`可focus域$である
］
⇒
~UAは、%方向 を遵守しつつ，~focusを
~its自前の~control~s適切に（もしあれば）転送するべきである；<br>
~RET
◎
If starting point is the top-level browsing context, or a focusable area in the top-level browsing context, the user agent should transfer focus to its own controls appropriately (if any), honouring direction, and then abort these steps.
</p>


<p class="example">
例えば、 %方向 ~EQ `後方^i の場合、［
~browserの具現化~域の前にある＊？最後の可focus~control
］が，~focusする~controlになる。
◎
For example, if direction is backward, then the last focusable control before the browser's rendering area would be the control to focus.
</p>


<p>
~IF［
可focus~controlはない（具体的には、~kiosk-mode~browser）
］
⇒
~UAは、 %始点 を %T にした下で，この手続きをやり直してよい
◎
If the user agent has no focusable controls — a kiosk-mode browser, for instance — then the user agent may instead restart these steps with the starting point being the top-level browsing context itself.
</p>
	</li>
			<li>
~ELSE（ %始点 は`入子の閲覧文脈$ %B 内の`可focus域$である）
⇒
%始点 ~LET %B の`閲覧文脈~容器$
◎
Otherwise, starting point is a focusable area in a nested browsing context. Let starting point be that nested browsing context's browsing context container, and return to the step labeled loop.
</li>

		</ol>
	</li>
</ol>



<p>

`逐次的~navigation探索~algo@
は、所与の
( %始点, %方向, %選定法 )
に対し，次を走らす：
◎
The sequential navigation search algorithm consists of the following steps. This algorithm takes three arguments: starting point, direction, and selection mechanism.
</p>

<ol>
	<li>
<div>
		<ol>
			<li>
%候補 ~LET ~NULL
</li>
			<li>
%候補~集合 ~LET 空~集合
</li>
			<li>
<p>
~IF［
%始点 は`閲覧文脈$である
］
⇒
%候補~集合 ~SET %始点 において`作動中の文書$の`首~control群$
</p>

<p>
ここで、`所有者~obj$ %O の
`首~control群@
は、 %O の`指名focus~dialog$を %D とするとき，次で定義される
⇒
%D ~NEQ ε ならば %D の`首~control群$ ／
~ELSE_ %O の`~control群$
</p>
			</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
<p >
%候補~集合 ~SET %選定法 に応じて：
</p>

<ul ><li>`~DOM^i ならば %始点 が所属する`~control群$†1
</li><li>`逐次的^i ならば %始点 が所属する`~control群$の`逐次的~focus~navigation順序$＊†2
</li></ul>
					</li>
					<li>
<p>
%候補~集合 ~SET %候補~集合 内の可focus域のうち， %方向 に応じて：
</p>

<ul ><li>`前方^i ならば %始点 に後続しているもの
</li><li>`後方^i ならば %始点 に先行しているもの
</li></ul>
					</li>
				</ol>
			</li>
			<li>
<p>
%候補~集合 ~SET %候補~集合 内の`可focus域$ %F のうち，次のいずれも満たすもの†3：
</p>

<ul ><li>その`~DOM~anchor$は`不活$でない
</li><li>%F は、 %F が属する`~control群$の`逐次的~focus~navigation順序$にも属する
</li></ul>
			</li>
			<li>
~IF［
%候補~集合 は空でない
］
⇒
%候補 ~SET %候補~集合 内の可focus域のうち， %方向 に応じて
⇒
`前方^i ならば 最初のもの ／
`後方^i ならば 最後のもの
</li>
		</ol>


<p class="trans-note">【†1〜3：
†1 は
`~home~control群@
／
†2 は
`~home逐次的~focus~navigation順序@
／
†3 を満たす可focus域は
`相応しい逐次的~可focus域@
と定義されているるが、この訳では無為に用語を増やさないため，これらの用語は利用しない。
】</p>


<div lang="en" style="white-space: normal;">

<p>
The appropriate cell is the one that is from the column whose header describes direction and from the first row whose header describes starting point and selection mechanism.
</p>
<p>
Pick the appropriate cell from the following table, and follow the instructions in that cell.
</p>

<table><thead><tr><th>
</th><th>direction is forward
</th><th>direction is backward
</th></tr></thead>
<tbody><tr><th>
starting point is a browsing context
</th><td>
Let candidate be the first suitable sequentially focusable area in starting point's active document's primary control group, if any; or else null
</td><td>
Let candidate be the last suitable sequentially focusable area in starting point's active document's primary control group, if any; or else null
</td></tr><tr><th>
selection mechanism is DOM
</th><td>
Let candidate be the first suitable sequentially focusable area in the home control group following starting point, if any; or else null
</td><td>
Let candidate be the last suitable sequentially focusable area in the home control group preceding starting point, if any; or else null
</td></tr><tr><th>
selection mechanism is sequential
</th><td>
Let candidate be the first suitable sequentially focusable area in the home sequential focus navigation order following starting point, if any; or else null
</td><td>
Let candidate be the last suitable sequentially focusable area in the home sequential focus navigation order preceding starting point, if any; or else null
</td></tr></tbody></table>

<p>
A suitable sequentially focusable area is a focusable area whose DOM anchor is not inert and that is in its control group's sequential focus navigation order.
<p>
The primary control group of a control group owner object X is the control group of X if X has no dialog group or if its dialog group has no designated focused dialog of the dialog group, otherwise, it is the primary control group of X's dialog group's designated focused dialog of the dialog group.
<p>
The home control group is the control group to which starting point belongs.
<p>
The home sequential focus navigation order is the sequential focus navigation order to which starting point belongs.
</div></div>


<p class="note">注記：＊
%始点 が常に，それが属する`~control群$の`逐次的~focus~navigation順序$に属するとは限らないが、属さない場合の %選定法 は `~DOM^i になる。

＊＊＊＊
`~home逐次的~focus~navigation順序$
は`~home~control群$の`逐次的~focus~navigation順序$であるが、
%始点 がその`逐次的~focus~navigation順序$内にあるときにのみ利用される（そうでないときの %選定法 は `~DOM^i になる）。
◎
The home sequential focus navigation order is the home control group's sequential focus navigation order, but is only used when the starting point is in that sequential focus navigation order (when it's not, selection mechanism will be DOM).
</p>

	</li>
	<li>
<p>
~IF［
%候補 は`閲覧文脈~容器$である
］：
</p>

		<ol>
			<li>
%新~候補 ~LET
( %候補 が`入子にしている閲覧文脈$, %方向, `逐次的^i )
を与える下で，`逐次的~navigation探索~algo$を走らせた結果
</li>
			<li>
~IF［
%新~候補 ~EQ ~NULL
］
⇒
%始点 ~SET %候補；<br>
~GOTO ~the~top~ofこの~algo。
</li>
			<li>
%候補 ~SET %新~候補
</li>
		</ol>

◎
If candidate is a browsing context container, then let new candidate be the result of running the sequential navigation search algorithm with candidate's nested browsing context as the first argument, direction as the second, and sequential as the third.
◎
If new candidate is null, then let starting point be candidate, and return to the top of this algorithm. Otherwise, let candidate be new candidate.
</li>
	<li>
~RET %候補
◎
Return candidate.
</li>

</ol>


			</section>
			<section id="focus-management-apis">
<h4 title="Focus management APIs">6.4.6. ~focus管理~API</h4>

<dl class="domintro">
	<dt>%document . `activeElement$m</dt>
	<dd>
~key~eventが それを通して／それに向けて~routeされているような，文書~内の最も深い要素を返す。
これは概ね、文書~内の被focus要素になる。
◎
Returns the deepest element in the document through which or to which key events are being routed. This is, roughly speaking, the focused element in the document.
</dd>
	<dd>
この~APIの目的0においては、`子~閲覧文脈$が~focusされるときには,
その`閲覧文脈~容器$が`親~閲覧文脈$内で
<a href="#bc-focus-ergo-bcc-focus">~focusされる</a>。
例えば、利用者が，~focusを `iframe$e 内のある~text~fieldに移動させたとき、その `iframe$e が，その`~node文書$x上の `activeElement$m から返される要素になる。
◎
For the purposes of this API, when a child browsing context is focused, its browsing context container is focused in the parent browsing context. For example, if the user moves the focus to a text field in an iframe, the iframe is the element returned by the activeElement API in the iframe's node document.
</dd>

	<dt>%document . `hasFocus()$m</dt>
	<dd>
~key~eventは，［
%document へ, または %document を通して~routeされている
］ならば ~T を返す。
~ELSE_ ~F を返す。
これは概ね、~focusされている［
当の文書, または
その内側に入子にされている文書
］に対応する。
◎
Returns true if key events are being routed through or to the document; otherwise, returns false. Roughly speaking, this corresponds to the document, or a document nested inside this one, being focused.
</dd>

	<dt>%window . `focus()$m</dt>
	<dd>
~focusを %window の`閲覧文脈$（もしあれば）に移動させる。
◎
Moves the focus to the window's browsing context, if any.
</dd>

	<dt>%element . `＊focus()$m</dt>
	<dd>
~focusを %element に移動させる。
◎
Moves the focus to the element.
</dd>
	<dd>
要素は`閲覧文脈~容器$である場合、~focusは，代わりに`入子の閲覧文脈$へ移動される。
◎
If the element is a browsing context container, moves the focus to the nested browsing context instead.
</dd>

	<dt>%element . `＊blur()$m</dt>
	<dd>
~focusを`表示域$xに移動させる。
この~methodは、利用しないことが奨励される。
`表示域$xを~focusしたければ、`文書$の`文書~要素$上で，
`＊focus()$m ~methodを~callすること。
◎
Moves the focus to the viewport. Use of this method is discouraged; if you want to focus the viewport, call the focus() method on the Document's document element.
</dd>
	<dd>
~focus環が目障りであっても、~focus環を隠すためにこの~methodを利用しないこと。
代わりに、 CSS 規則で `outline$p ~prop（外形線）を上書きした上で，~focusされる要素を示すような他の仕方を提供すること。
そのような代替の~focusing~styleが可用にできなかった場合、首に~keyboardを利用して頁を~navigateしている人や，~navigateし易くするため~focus外形線を利用している弱視者にとっては、頁の使い勝手が悪くなることに留意すること。
◎
Do not use this method to hide the focus ring if you find the focus ring unsightly. Instead, use a CSS rule to override the 'outline' property, and provide a different way to show what element is focused. Be aware that if an alternative focusing style isn't made available, the page will be significantly less usable for people who primarily navigate pages using a keyboard, or those with reduced vision who use focus outlines to help them navigate the page.
</dd>
	<dd class="example">
<p>
例えば、~linkから外形線を隠す代わりに，黄色の背景を利用して~focusを指示したければ、次も利用できる：
◎
For example, to hide the outline from links and instead use a yellow background to indicate focus, you could use:
</p>

<pre>
:link:focus, :visited:focus { outline: none; background: yellow; color: black; }
</pre>

	</dd>
</dl>


<p>
`文書$~上の
`activeElement@m
属性は、次を走らせた結果を返さ~MUST：
◎
The activeElement attribute on Document objects must return the value returned by the following steps:
</p>

<ol>
	<li>
%候補 ~LET 此れ
◎
Let candidate be the Document on which the method was invoked.
</li>
	<li>
~WHILE［
%候補 の`~dialog群$ %G  ~NEQ ε
］~AND［
%G の`指名focus~dialog$ %D ~NEQ ε
］
⇒
%候補 ~LET %D
◎
If candidate has a dialog group with a designated focused dialog of the dialog group, then let candidate be the designated focused dialog of the dialog group, and redo this step.
</li>
	<li>
~IF［
%候補 の`~control群$ %G は空でない
］
⇒
%候補 ~LET %G の`指名focus域$
◎
If candidate has a non-empty control group, let candidate be the designated focused area of the control group.
</li>
	<li>
~IF［
%候補 は`可focus域$である
］
⇒
%候補 ~LET %候補 の`~DOM~anchor$
◎
If candidate is a focusable area, let candidate be candidate's DOM anchor.
</li>
	<li>
~IF［
%候補 は`文書$である
］
⇒
~RET［
%候補 は`~body要素$を持つならば それ ／
~ELSE_ %候補 の`文書~要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ ~NULL
］
◎
If candidate is a Document that has a body element, then let candidate be the body element of that Document.
◎
Otherwise, if candidate is a Document with a non-null document element, then let candidate be that document element.
◎
Otherwise, if candidate is a Document, then let candidate be null.
</li>
	<li>
~RET %候補
◎
Return candidate.
</li>

</ol>


<p>
`文書$上の
`hasFocus()@m
~methodの被呼出時には、此れを与える下で，`~has~focus手続き$を走らせた結果を返さ~MUST。
◎
The hasFocus() method on the Document object, when invoked, must return the result of running the has focus steps with the Document object as the argument.
</p>


<p>
`Window$I ~obj上の
`focus()@m
~methodの被呼出時には、此れの`閲覧文脈$を`~focusする手続き$を走らせ~MUST。
加えて，此れの`閲覧文脈$が`~top-level閲覧文脈$である場合、~UAには，［
頁が~focusを~gainしようと試みていることを，利用者に向けて指示する
］ような，何らかの類の通知を誘発することが奨励される。
◎
The focus() method on the Window object, when invoked, must run the focusing steps with the Window object's browsing context. Additionally, if this browsing context is a top-level browsing context, user agents are encouraged to trigger some sort of notification to indicate to the user that the page is attempting to gain focus.
</p>


<p>
`Window$I ~obj上の
`blur()@m ~methodは、~UAに次についての~hintを提供する：
~scriptは，［
利用者は，おそらく 当の `Window$I ~objの`閲覧文脈$の内容に対する関心を失った
］ものと見込んでいるが、再び関心が向けられるかもしれないことについての。
◎
The blur() method on the Window object, when invoked, provides a hint to the user agent that the script believes the user probably is not currently interested in the contents of the browsing context of the Window object on which the method was invoked, but that the contents might become interesting again in the future.
</p>

<p>
~UAには、この `blur()$m ~methodの~callを全面的に無視することが奨励される。
◎
User agents are encouraged to ignore calls to this blur() method entirely.
</p>


<p class="note">注記：
歴史的に、
`focus()$m ／ `blur()$m
~methodは、実際には，`閲覧文脈$を包含している~system~widget（例：~tabや~window）の~system~levelの~focusにも影響していたが、この挙動は，敵対的~siteにより利用者の~detrimentに広範に濫用されている。
◎
Historically, the focus() and blur() methods actually affected the system-level focus of the system widget (e.g. tab or window) that contained the browsing context, but hostile sites widely abuse this behaviour to the user's detriment.
</p>


<p>
要素~上の
`＊focus()@m
~methodの被呼出時には、次の~algoを走らせ~MUST：
◎
The focus() method on elements, when invoked, must run the following algorithm:
</p>

<ol>
	<li>
~IF［
此れの`~focus~lock~flag$ ~EQ ~ON
］
⇒
~RET
◎
If the element is marked as locked for focus, then abort these steps.
</li>
	<li>
此れの
`~focus~lock~flag@
~SET ~ON
◎
Mark the element as locked for focus.
</li>
	<li>
此れを`~focusする手続き$を走らす
◎
Run the focusing steps for the element.
</li>
	<li>
此れの`~focus~lock~flag$ ~SET ~OFF
◎
Unmark the element as locked for focus.
</li>

</ol>


<p>
要素~上の
`＊blur()@m
~methodの被呼出時には、此れを`~unfocusする手続き$を走らすべきである。
~UAは、使い勝手＊の理由から，選択的に または一様に，この~methodの~callを無視してよい。
◎
The blur() method, when invoked, should run the unfocusing steps for the element on which the method was called. User agents may selectively or uniformly ignore calls to this method for usability reasons.
</p>


<p class="example">
例えば、ただ美観の理由で， `＊blur()$m ~methodを利用して無思慮に~focus環が除去された場合、~keyboard利用者からは，頁の使い勝手は悪くなるであろう。
この~methodの~callを無視すれば、~keyboard利用者でも頁と対話できるようになる。
◎
For example, if the ＊blur() method is unwisely being used to remove the focus ring for aesthetics reasons, the page would become unusable by keyboard users. Ignoring calls to this method would thus allow keyboard users to interact with the page.
</p>

			</section>
		</section>
		<section id="assigning-keyboard-shortcuts">
<h3 title="Assigning keyboard shortcuts">6.5. ~keyboard~shortcutの＊~assigning</h3>

			<section id="introduction-9">
<h4 title="Introduction">6.5.1. 序論</h4>

~INFORMATIVE

<p>
作動化-／~focusされ得るような各~要素には、
`accesskey$a 属性を利用して，それを作動化させる単独の~key組合せをあてがえる。
◎
Each element that can be activated or focused can be assigned a single key combination to activate it, using the accesskey attribute.
</p>


<p>
正確な~shortcutは、
`accesskey$a 属性から提供される情報を＊手引きに利用しつつ，利用者の~keyboardについての情報
— ~platform上にすでに存在する／頁~上で他に指定されている，~shortcutなど —
に基づいて，~UAにより決定される
◎
The exact shortcut is determined by the user agent, based on information about the user's keyboard, what keyboard shortcuts already exist on the platform, and what other shortcuts have been specified on the page, using the information provided in the accesskey attribute as a guide.
</p>


<p>
`accesskey$a 属性~内にいくつもの代替を提供すれば、作者は，多様な入力~装置にわたり関連の~keyboard~shortcutが可用になることを確保できる。
◎
In order to ensure that a relevant keyboard shortcut is available on a wide variety of input devices, the author can provide a number of alternatives in the accesskey attribute.
</p>


<p>
各~代替は、普通字や数字などの単独の文字からなる。
◎
Each alternative consists of a single character, such as a letter or digit.
</p>


<p>
~UAは、利用者に~keyboard~shortcutの~listを提供できるが、作者にもそうすることが奨励される。
`accessKeyLabel$m ~IDL属性は、~UAによりあてがわれた実際の~key組合せを表現している文字列を返す。
◎
User agents can provide users with a list of the keyboard shortcuts, but authors are encouraged to do so also. The accessKeyLabel IDL attribute returns a string representing the actual key combination assigned by the user agent.
</p>

<div class="example">

<p>
次の例には、~shortcut~keyを利用して呼出せる~buttonが提供されている。
ここでは、~full~keyboard用として，＊可能0な~key "C" ，および
十keyしかない場合のために，別の可能0な~keyとして "1" も提供されている。
◎
In this example, an author has provided a button that can be invoked using a shortcut key. To support full keyboards, the author has provided "C" as a possible key. To support devices equipped only with numeric keypads, the author has provided "1" as another possibly key.
</p>


<pre>
&lt;input type=button value=Collect onclick="collect()"
       <strong>accesskey="C 1"</strong> id=c&gt;
</pre>

</div>

<div class="example">

<p>
どの~shortcut~keyがあるか，利用者に伝えるため、次の~scriptでは
ここで~opted~to＊
~buttonの~labelに，~key組合せを明示的に追加する：
◎
To tell the user what the shortcut key is, the author has this script here opted to explicitly add the key combination to the button's label:
</p>


<pre>
function addShortcutKeyLabel(button) {
<strong>  if (button.accessKeyLabel != '')
    button.value += ' (' + button.accessKeyLabel + ')';</strong>
}
addShortcutKeyLabel(document.getElementById('c'));
</pre>


<p>
同じ~key組合せであっても，~platformが異なれば、~browserは，各~platformに普及している規約に基づいて異なる~labelを示すことになる。
例えば、~key組合せが［
Control ＋ Shift ＋ C
］ならば、［
Windows ~browserでは `Ctrl+Shift+C^samp ／
Mac ~browserでは `^⇧C^samp ／
Emacs ~browserでは `C-C^samp
］のように表示されるであろう。
同様に、~keyの組合せが［
Alt ~key ＋ Escape ~key
］であれば、［
Windows では `Alt+Esc^samp ／
Mac では `⌥⎋^samp ／
Emacs ~browserでは `M-ESC^samp または `ESC ESC^samp
］が利用されるであろう。
◎
Browsers on different platforms will show different labels, even for the same key combination, based on the convention prevalent on that platform. For example, if the key combination is the Control key, the Shift key, and the letter C, a Windows browser might display "Ctrl+Shift+C", whereas a Mac browser might display "^⇧C", while an Emacs browser might just display "C-C". Similarly, if the key combination is the Alt key and the Escape key, Windows might use "Alt+Esc", Mac might use "⌥⎋", and an Emacs browser might use "M-ESC" or "ESC ESC".
</p>


<p>
したがって，一般に、
`accessKeyLabel$m ~IDL属性から返される値を構文解析しようと試みることは＊~unwiseになる。
◎
In general, therefore, it is unwise to attempt to parse the value returned from the accessKeyLabel IDL attribute.
</p>

</div>


			</section>
			<section id="the-accesskey-attribute">
<h4 title="The accesskey attribute">6.5.2. `accesskey^a 属性</h4>


<p>
`accesskey$a 内容~属性は、すべての`~HTML要素$に設定できる。
この属性の値は、要素を
作動化する／~focusする
~keyboard~shortcutを作成する手引きとして，~UAにより利用される。
◎
All HTML elements may have the accesskey content attribute set. The accesskey attribute's value is used by the user agent as a guide for creating a keyboard shortcut that activates or focuses the element.
</p>


<p>
指定される値は、`空白区切りの一意な~tokenからなる有順序~集合$で~MUST。
＊`大小区別$される
各~tokenは、正確に 1 個の~Unicode符号位置で~MUST。
◎
If specified, the value must be an ordered set of unique space-separated tokens that are case-sensitive, each of which must be exactly one Unicode code point in length.
</p>

<div class="example">

<p>
次の例では、様々な~linkに~access~keyがあてがわれている
— ~siteに馴染んでいる~keyboard利用者は，関連の頁に素早く~navigateできるようになる：
◎
In the following example, a variety of links are given with access keys so that keyboard users familiar with the site can more quickly navigate to the relevant pages:
</p>


<pre>
&lt;nav&gt;
 &lt;p&gt;
  &lt;a title="Consortium Activities" accesskey="A" href="/Consortium/activities"&gt;Activities&lt;/a&gt; |
  &lt;a title="Technical Reports and Recommendations" accesskey="T" href="/TR/"&gt;Technical Reports&lt;/a&gt; |
  &lt;a title="Alphabetical Site Index" accesskey="S" href="/Consortium/siteindex"&gt;Site Index&lt;/a&gt; |
  &lt;a title="About This Site" accesskey="B" href="/Consortium/"&gt;About Consortium&lt;/a&gt; |
  &lt;a title="Contact Consortium" accesskey="C" href="/Consortium/contact"&gt;Contact&lt;/a&gt;
 &lt;/p&gt;
&lt;/nav&gt;
</pre>

</div>

<div class="example">


<p>
次の例では、検索~fieldに，二つの可能0~access~key
"s", "0" がこの順序で与えられている。
~full~keyboard装置を備えている~UAは、~shortcut~keyとして
<kbd><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>S</kbd></kbd>
選ぶであろう。
一方で，十keyしか備えていない装置~上の~UAは、~key
<kbd><kbd>0</kbd></kbd>
を選ぶであろう：
◎
In the following example, the search field is given two possible access keys, "s" and "0" (in that order). A user agent on a device with a full keyboard might pick Ctrl+Alt+S as the shortcut key, while a user agent on a small device with just a numeric keypad might pick just the plain unadorned key 0:
</p>


<pre>
&lt;form action="/search"&gt;
 &lt;label&gt;Search: &lt;input type="search" name="q" accesskey="s 0"&gt;&lt;/label&gt;
 &lt;input type="submit"&gt;
&lt;/form&gt;
</pre>

</div>

<div class="example">
<p>
次の例では、可能0~access~keyが~buttonに記述されている。
加えて，~UAが選択した~keyの組合せを告知するため、~scriptは，~buttonの~labelを更新しようと試行する。
◎
In the following example, a button has possible access keys described. A script then tries to update the button's label to advertise the key combination the user agent selected.
</p>


<pre>
&lt;input type=submit accesskey="N @ 1" value="Compose"&gt;
...
&lt;script&gt;
 function labelButton(button) {
   if (button.accessKeyLabel)
     button.value += ' (' + button.accessKeyLabel + ')';
 }
 var inputs = document.getElementsByTagName('input');
 for (var i = 0; i &lt; inputs.length; i += 1) {
   if (inputs[i].type == "submit")
     labelButton(inputs[i]);
 }
&lt;/script&gt;
</pre>

<p>
ある~UA上では、~buttonの~labelは，
`Compose (⌘N)^samp になるかもしれない。
別の~UA上では
`Compose (Alt+⇧+1)^samp
になるかもしれない。
~UAが~keyをあてがわない場合、それは
~just `Compose^samp になる~will。
正確な文字列は、`あてがわれている~access~key$, および
~UAがその~key組合せをどう表現するかに依存する。
◎
On one user agent, the button's label might become "Compose (⌘N)". On another, it might become "Compose (Alt+⇧+1)". If the user agent doesn't assign a key, it will be just "Compose". The exact string depends on what the assigned access key is, and on how the user agent represents that key combination.
</p>

</div>

			</section>
			<section id="processing-model-6">
<h4 title="Processing model">6.5.3. 処理~model</h4>


<p>
要素に
`あてがわれている~access~key@
とは、要素の `accesskey$a 内容~属性から導出される~key組合せである
— 初期時には、どのような~access~keyもあてがっては~MUST_NOT。
◎
An element's assigned access key is a key combination derived from the element's accesskey content attribute. Initially, an element must not have an assigned access key.
</p>


<p>
~UAは、要素の `accesskey$a 属性が［
設定- ／ 変更- ／除去-
］される度に、次の手続きを走らせて得られる~access~keyで，要素に`あてがわれている~access~key$を更新し~MUST：
◎
Whenever an element's accesskey attribute is set, changed, or removed, the user agent must update the element's assigned access key by running the following steps:
</p>

<ol>
	<li>
<p>
~IF［
要素は `accesskey$a 属性を有する
］
⇒
~FOR
属性の値を`空白並びで分割-$した結果~内の~EACH ( %値 ) に対し：
◎
If the element has no accesskey attribute, then skip to the fallback step below.
◎
Otherwise, split the attribute's value on spaces, and let keys be the resulting tokens.
◎
For each value in keys in turn, in the order the tokens appeared in the attribute's value, run the following substeps:
</p>

		<ol>
			<li>
~IF［
%値 を成す~Unicode符号位置の個数 ~NEQ 1
］
⇒
~CONTINUE
◎
If the value is not a string exactly one Unicode code point in length, then skip the remainder of these steps for this value.
</li>
			<li>
~IF［
%値 は~systemの~keyboard上のどの~keyにも対応しない
］
⇒
~CONTINUE
◎
If the value does not correspond to a key on the system's keyboard, then skip the remainder of these steps for this value.
</li>
			<li>
~IF［
%値 に対応する~keyと, ~zero個以上の修飾~keyとの組み合わせに，~access~keyとして利用できるものがある
］
⇒
~UAの任意選択で
⇒
~RET その~key組合せ
~FINGERPRINTING
◎
If the user agent can find a mix of zero or more modifier keys that, combined with the key that corresponds to the value given in the attribute, can be used as the access key, then the user agent may assign that combination of keys as the element's assigned access key and abort these steps. ~FINGERPRINTING
</li>
		</ol>
	</li>
	<li>
~UAの任意選択で
⇒
~RET ~UAの任意選択で選んだ~key組合せ
◎
Fallback: Optionally, the user agent may assign a key combination of its choosing as the element's assigned access key and then abort these steps.
</li>
	<li>
~RET ~access~keyなし
◎
If this step is reached, the element has no assigned access key.
</li>

</ol>


<p>
要素に対し~access~keyを選択してあてがった~UAは、
`accesskey$a 内容~属性が変更されるか，要素は別の`文書$へ移動されるまでは、それに`あてがわれている~access~key$を変更するべきでない。
◎
Once a user agent has selected and assigned an access key for an element, the user agent should not change the element's assigned access key unless the accesskey content attribute is changed or the element is moved to another Document.
</p>


<div>
<p>
`~commandを定義する$ような要素に対し，［
利用者が，それに`あてがわれている~access~key$に対応する~key組合せを押下げた
］ときは、~UAは，次のいずれも満たされるならば，その~commandの `Action$st を誘発し~MUST：
</p>

<ul><li>~commandの `Hidden State$st ~facet ~EQ ~F （可視である）
</li><li>~commandの `Disabled State$st ~facet ~EQ  ~F （可能化されている）
</li><li>要素は`閲覧文脈$docに属する`文書~内にある$
</li><li>要素, および 要素のどの先祖にも， `hidden$a 属性は指定されていない
</li></ul>
◎
When the user presses the key combination corresponding to the assigned access key for an element, if the element defines a command, the command's Hidden State facet is false (visible), the command's Disabled State facet is also false (enabled), the element is in a Document that has a ＊browsing context, and neither the element nor any of its ancestors has a hidden attribute specified, then the user agent must trigger the Action of the command.
</div>


<p class="note">注記：
~UAは、 `accesskey$a 属性を有する要素を，他の仕方で
— 例えば，特定の~key組合せに呼応して表示される~menu内に —
<a href="~HTML-FORMS#expose-commands-in-ui">公開することもある</a>。
◎
User agents might expose elements that have an accesskey attribute in other ways as well, e.g. in a menu displayed in response to a specific key combination.
</p> 

<hr>

<p>
`accessKey@m
~IDL属性は、 `accesskey$a 内容~属性を`反映-$し~MUST。
◎
The accessKey IDL attribute must reflect the accesskey content attribute.
</p>


<p>
`accessKeyLabel@m
~IDL属性は、要素に`あてがわれている~access~key$が［
あれば それを表現する文字列 ／
なければ空~文字列
］を返さ~MUST。
◎
The accessKeyLabel IDL attribute must return a string that represents the element's assigned access key, if any. If the element does not have one, then the IDL attribute must return the empty string.
</p>

			</section>
		</section>
		<section id="editing-2">
<h3 title="Editing">6.6. 編集</h3>



			<section id="contenteditable">
<h4 title="Making document regions editable: The contenteditable content attribute">6.6.1. 文書の領域を編集可能にする： `contenteditable^a 内容~属性</h4>


<pre class="idl">
[NoInterfaceObject]
interface `ElementContentEditable@I {
  attribute DOMString `contentEditable$m;
  readonly attribute boolean `isContentEditable$m;
};
</pre>


<p>
`contenteditable@a
内容~属性は`列挙~属性$であり、その~keywordの集合は
{ 空~文字列, `true^v, `false^v }
である。
~keyword［
空~文字列 ／ `true^l
］は、 `~T^st 状態に対応付けられる。
~keyword `false^l は `~F^st 状態に対応付けられる。
加えて，`値なしに対する既定の状態$（および `妥当でない値に対する既定の状態$）
は、三番目の状態 `継承-^st 状態に対応付けられる。
◎
The contenteditable content attribute is an enumerated attribute whose keywords are the empty string, true, and false. The empty string and the true keyword map to the true state. The false keyword maps to the false state. In addition, there is a third state, the inherit state, which is the missing value default (and the invalid value default).
</p>


<p>
`~T^st ／ `~F^st ／ `継承-^st
状態は，当の要素が［
編集可能である ／ 編集可能でない ／ 親が編集可能ならそうなる
］ことを指示する。
◎
The true state indicates that the element is editable. The inherit state indicates that the element is editable if its parent is. The false state indicates that the element is not editable.
</p>

	●



<div class="example">
<p>
例えば、~pageには
~consider~a
~new~articleを~publishするための
`form$e と `textarea$e があって、利用者には~HTMLで~articleを書くことが期待されているとする：
◎
For example, consider a page that has a form and a textarea to publish a new article, where the user is expected to write the article using HTML:
</p>

<pre>
&lt;form method=POST&gt;
 &lt;fieldset&gt;
  &lt;legend&gt;New article&lt;/legend&gt;
  &lt;textarea name=article&gt;&amp;lt;p&gt;Hello world.&amp;lt;/p&gt;&lt;/textarea&gt;
 &lt;/fieldset&gt;
 &lt;p&gt;&lt;button&gt;Publish&lt;/button&gt;&lt;/p&gt;
&lt;/form&gt;</pre>

<p>
~scriptが可能化されているとき、
`textarea$e 要素に代わって
~could~be
~rich~text~fieldに置換され~with~a
~instead,
~using~the
`contenteditable$a 属性を利用して：
◎
When scripting is enabled, the textarea element could be replaced with a rich text field instead, using the contenteditable attribute:
</p>

<pre>
&lt;form method=POST&gt;
 &lt;fieldset&gt;
  &lt;legend&gt;New article&lt;/legend&gt;
  &lt;textarea id=textarea name=article&gt;&amp;lt;p&gt;Hello world.&amp;lt;/p&gt;&lt;/textarea&gt;
  &lt;div id=div style="white-space: pre-wrap" hidden&gt;&lt;p&gt;Hello world.&lt;/p&gt;&lt;/div&gt;
  &lt;script&gt;
   let textarea = document.getElementById("textarea");
   let div = document.getElementById("div");
   textarea.hidden = true;
   div.hidden = false;
   div.contentEditable = "true";
   div.oninput = (e) =&gt; {
     textarea.value = div.innerHTML;
   };
  &lt;/script&gt;
 &lt;/fieldset&gt;
 &lt;p&gt;&lt;button&gt;Publish&lt;/button&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>

   <p>
例えば~linkの挿入などの特色機能を可能化するのは
~features~to
,
~can~be
`execCommand()$m ~APIを利用して, あるいは
`Selection$I ~APIと他の~DOM~APIを利用して実装し得る

`EDITING$r `SELECTION$r `DOM$r
◎
Features to enable, e.g., inserting links, can be implemented using the document.execCommand() API, or using Selection APIs and other DOM APIs. [EDITING] [SELECTION] [DOM]
</p>

</div>

<div class="example">
<p>
`contenteditable$a
属性は、効果を~greatにする＊？ためにも利用できる：
◎
The contenteditable attribute can also be used to great effect:
</p>

<pre>
&lt;!doctype html&gt;
&lt;title&gt;Live CSS editing!&lt;/title&gt;
&lt;style style=white-space:pre contenteditable&gt;
html { margin:.2em; font-size:2em; color:lime; background:purple }
head, title, style { display:block }
body { display:none }
&lt;/style&gt;
</pre>

</div>



<dl class="domintro">
	<dt>%element . `contentEditable$m [ = %値 ]</dt>
	<dd>
`contenteditable$a 属性の状態に基づいて［
`true^l, `false^l,  `inherit^l
］いずれかを返す。
◎
Returns "true", "false", or "inherit", based on the state of the contenteditable attribute.
</dd>
	<dd>
設定してその状態を変更できる
— 新たな値がこれらの文字列のいずれでもない場合、
`SyntaxError$E 例外が投出される。
◎
Can be set, to change that state.
◎
Throws a SyntaxError exception if the new value isn't one of those strings.
</dd>

	<dt>%element . `isContentEditable$m</dt>
	<dd>
要素が編集可能ならば ~T ／
~ELSE_ ~F
を返す。
◎
Returns true if the element is editable; otherwise, returns false.
</dd>
</dl>



<div>
<p>
`contentEditable@m
~IDL属性の被取得時には、要素~上の
`contenteditable$a 内容~属性の状態に応じて［
`~T^st ならば `true^l ／
`~T^st ならば `false^l ／
~ELSE_ `inherit^l
］を返さ~MUST。
被設定時には、新たな値を`~ASCII小文字~化$した結果に応じて，対応する段を走らせ~MUST：
</p>

<dl class="switch">
	<dt>`inherit^l</dt>
	<dd>
内容~属性を除去する
</dd>

	<dt>`true^l</dt>
	<dd>
内容~属性 ~SET `true^l
</dd>

	<dt>`false^l</dt>
	<dd>
内容~属性 ~SET `false^l,
</dd>

	<dt>その他</dt>
	<dd>
~THROW `SyntaxError$E
</dd>

</dl>


◎
The contentEditable IDL attribute, on getting, must return the string "true" if the content attribute is set to the true state, "false" if the content attribute is set to the false state, and "inherit" otherwise. On setting, if the new value is an ASCII case-insensitive match for the string "inherit" then the content attribute must be removed, if the new value is an ASCII case-insensitive match for the string "true" then the content attribute must be set to the string "true", if the new value is an ASCII case-insensitive match for the string "false" then the content attribute must be set to the string "false", and otherwise the attribute setter must throw a SyntaxError exception.
</div>


<p>
`isContentEditable@m
~IDL属性の被取得時には、［
要素は`編集中の~host$または `編集可能$であるならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The isContentEditable IDL attribute, on getting, must return true if the element is either an editing host or editable, and false otherwise.
</p>


			</section>
			<section id="making-entire-documents-editable:-the-designmode-idl-attribute">
<h4 title="Making entire documents editable: The designMode IDL attribute">6.6.2. 文書~全体を編集可能にする： `designMode^m IDL 属性</h4>

<p>
文書は
`designMode@m
を持つ。
~which
~can~be
~either
可能化する／不能化できる。
◎
Documents have a designMode, which can be either enabled or disabled.
</p>


<dl class="domintro">
	<dt>%document . `designMode$m [ = %value＊ ]</dt>
	<dd>
文書は［
編集可能ならば `on^l ／
~ELSE_ `off^l
］返す。
◎
Returns "on" if the document is editable, and "off" if it isn't.
</dd>
	<dd>
設定して文書の現在の状態を変更できる。
これは、文書を~focusした上で，文書~内の選択を再設定する。
◎
Can be set, to change the document's current state. This focuses the document and resets the selection in that document.
</dd>
</dl>


<div>
<p>
`文書$上の 
`designMode$m ~IDL属性がとり得る値は［
`on^l, `off^l
］のいずれかである。
被設定時には、所与の値を `~ASCII小文字~化$した結果に応じて，次を走らせ~MUST：
</p>

<dl class="switch">
	<dt>`on^l</dt>
	<dd>
`designMode$m を可能化する
</dd>

	<dt>`off^l</dt>
	<dd>
`designMode$m を不能化する
</dd>

	<dt>その他</dt>
	<dd>
無視する。
</dd>

◎
The designMode IDL attribute on the Document object takes two values, "on" and "off". On setting, the new value must be compared in an ASCII case-insensitive manner to these two values; if it matches the "on" value, then designMode must be enabled, and if it matches the "off" value, then designMode must be disabled. Other values must be ignored.
</dl></div>


<p>
`designMode$m
の被取得時には、可能化されているならば `on^l ／
~ELSE_ `off^l 
］を返さ~MUST。
◎
On getting, if designMode is enabled, the IDL attribute must return the value "on"; otherwise it is disabled, and the attribute must return the value "off".
</p>


<p>
文書が破壊されるか, 状態が変化するまで、最後に設定された状態を持続し~MUST。
初期時には、文書の `designMode$m は不能化され~MUST。
◎
The last state set must persist until the document is destroyed or the state is changed. Initially, documents must have their designMode disabled.
</p>


<p>
`designMode$m
不能化されが可能化されへ変化したときは、~UAは
`即時に$
文書の`作動範囲$の［
始端／終端
］境界点を`文書$の始端に再設定した上で、［
`文書$の＊`文書~要素$ ~NEQ ~NULL
］ならば それを`~focusする手続き$を走らせ~MUST。
◎
When the designMode changes from being disabled to being enabled, the user agent must immediately reset the document's active range's start and end boundary points to be at the start of the Document and then run the focusing steps for the document element of the Document, if non-null.
</p>


			</section>
			<section id="best-practices-for-in-page-editors">
<h4 title="Best practices for in-page editors">6.6.3. 頁~編集者による最善の実施</h4>


<p>
作者には、［
`編集中の~host$, および
編集-用の仕組みを通して作成された~markup
］上の `white-space$p ~propを値 `pre-wrap^v に設定することが奨励される。
~HTMLにおける空白に対する既定の取扱いは， WYSIWYG 編集には不向きであり、
`white-space$p が既定~値のままだと，一部のきわどい事例では，行0の折返しが正しく働かなくなる。
◎
Authors are encouraged to set the 'white-space' property on editing hosts and on markup that was originally created through these editing mechanisms to the value 'pre-wrap'. Default HTML whitespace handling is not well suited to WYSIWYG editing, and line wrapping will not work correctly in some corner cases if 'white-space' is left at its default value.
</p>


<div class="example">

<p>
既定の `normal^v 値が利用された場合に生じる問題の一例として、利用者が［
"<kbd>yellow</kbd>", 2 個の空白類, <kbd>ball</kbd>"
］を続けて手入力したときを考える。
`white-space$p の既定の値（ `normal^v ）の下では，~~連続する `space^i は一つに縮退する呈示が要求されるため、結果の~markupを［
`yellow^l, `nbsp^i, `space^i, `ball^l
］の並び, または［
`yellow^l, `space^i, `nbsp^i, `ball^l
］の並びとするような編集~規則が必要とされる
— ここで， `nbsp^i は分断不可 space（ non-breaking space ）,
`space^i は普通の space（ U+0020 ）を表すとする。
<!--  "␣"  -->
◎
As an example of problems that occur if the default 'normal' value is used instead, consider the case of the user typing "yellow␣␣ball", with two spaces (here represented by "␣") between the words. With the editing rules in place for the default value of 'white-space' ('normal'), the resulting markup will either consist of "yellow&amp;nbsp; ball" or "yellow &amp;nbsp;ball"; i.e., there will be a non-breaking space between the two words in addition to the regular space. This is necessary because the 'normal' value for 'white-space' requires adjacent regular spaces to be collapsed together.
</p>

<p>
2 つの単語の合間で行0を折返す必要がある場合、前者の［
`nbsp^i, `space^i
］並びの事例では，行0の終端までに単語 `yellow^l のみが収まる場合でも，
`nbsp^i の直後で次の行0へ折返され、後者の［
`space^i, `nbsp^i
］並びの事例では， `nbsp^i の直前で次の行0へ折返される
— その結果、単語 `ball^l の前の字下げが露わになる。
◎
In the former case, "yellow⍽" might wrap to the next line ("⍽" being used here to represent a non-breaking space) even though "yellow" alone might fit at the end of the line; in the latter case, "⍽ball", if wrapped to the start of the line, would have visible indentation from the non-breaking space.
</p>



<p>
一方で、 `white-space$p が `pre-wrap^v に設定されている下での編集~規則は、単語の合間に 2 個の `space^i を挟むだけ済む。
その結果、 2 個の単語は行0の終端の所で分割され，~spaceは具現化からきれいに除去されることになる。
◎
When 'white-space' is set to 'pre-wrap', however, the editing rules will instead simply put two regular spaces between the words, and should the two words be split at the end of a line, the spaces would be neatly removed from the rendering.
</p>

</div>


			</section>
			<section id="editing-apis">
<h4 title="Editing APIs">6.6.4. 編集~API</h4>


<div>
<p>
次に挙げるものは、
HTML Editing API 仕様 `EDITING$r
にて定義される：
</p>

<ul><li>用語
`作動範囲@,
`編集中の~host@,
`編集可能@
の定義
</li><li>［
`編集中の~host$ ／ `編集可能$
］である要素に課される~UI要件
</li><li>

<p>
次の各種~method：
</p>
	<ul><li>`execCommand()@m
	</li><li>`queryCommandEnabled()@m
	</li><li>`queryCommandIndeterm()@m
	</li><li>`queryCommandState()@m
	</li><li>`queryCommandSupported()@m
	</li><li>`queryCommandValue()@m
	</li></ul>
</li><li>~text選択
</li><li>`選択を削除-@
する~algo
</li></ul>



◎
The definition of the terms active range, editing host, and editable, the user interface requirements of elements that are editing hosts or editable, the execCommand(), queryCommandEnabled(), queryCommandIndeterm(), queryCommandState(), queryCommandSupported(), and queryCommandValue() methods, text selections, and the delete the selection algorithm are defined in the HTML Editing APIs specification. [EDITING]
</div>



			</section>
			<section id="spelling-and-grammar-checking">
<h4 title="Spelling and grammar checking">6.6.5. 綴りや文法の検査</h4>



<p>
~UAは、［
~form~control（ `textarea$e 要素の値など）や,
`編集中の~host$内の要素（例： `contenteditable$a を利用して）
］内の編集可能~textに対する綴りや文法の検査を~supportできる。
◎
User agents can support the checking of spelling and grammar of editable text, either in form controls (such as the value of textarea elements), or in elements in an editing host (e.g. using contenteditable).
</p>


<p>
~UAは、各~要素に対し，［
既定のもの, または利用者の選好
］を通して、
`既定の挙動@
を確立し~MUST。
各~要素に対して可能0な既定の挙動には、次の 3 種がある：
◎
For each element, user agents must establish a default behaviour, either through defaults or through preferences expressed by the user. There are three possible default behaviours for each element:
</p>

<dl>
	<dt>`既定で ~T@</dt>
	<dd>
要素の綴りや文法は、要素の内容が編集可能であって，その検査は
`spellcheck$a 属性を通して明示的に不能化されていないならば、検査される。
◎
The element will be checked for spelling and grammar if its contents are editable and spellchecking is not explicitly disabled through the spellcheck attribute.
</dd>
	<dt>`既定で ~F@</dt>
	<dd>
要素の綴りや文法は、 `spellcheck$a 属性を通して明示的に可能化されていない限り，決して検査されない。
◎
The element will never be checked for spelling and grammar unless spellchecking is explicitly enabled through the spellcheck attribute.
</dd>
	<dt>`既定で継承-@</dt>
	<dd>
要素の既定の挙動は、その親~要素のそれと同じになる。
親~要素がない場合には，既定の挙動を持たない＊。
◎
The element's default behaviour is the same as its parent element's. Elements that have no parent element cannot have this as their default behaviour.
</dd></dl>

<hr>


<p>
`spellcheck@a
属性は、`列挙~属性$であり、~keywordとして［
空~文字列,
`true^v,
`false^v
］のいずれかをとり得る。
~keyword［
空~文字列 ／ `true^v
］は `~T^st 状態に対応付けられる。
~keyword `false^v は `~F^st 状態に対応付けられる。
加えて，`値なしに対する既定の状態$（および `妥当でない値に対する既定の状態$）
は、 3 番目の状態， `既定の挙動^st に対応付けられる。
◎
The spellcheck attribute is an enumerated attribute whose keywords are the empty string, true and false. The empty string and the true keyword map to the true state. The false keyword maps to the false state. In addition, there is a third state, the default state, which is the missing value default (and the invalid value default).
</p>


<p class="note">注記：
［
`~T^st ／ `~F^st ／ `既定の挙動^st
］状態は、当の要素の綴りや文法が［
検査される ／ 検査されない ／ 既定の挙動に則って
— 場合によっては親~要素の自前の `spellcheck$a 状態に基づいて — 動作する
］ことを指示する。
◎
The true state indicates that the element is to have its spelling and grammar checked. The default state indicates that the element is to act according to a default behaviour, possibly based on the parent element's own spellcheck state, as defined below. The false state indicates that the element is not to be checked.
</p>


<hr>

<dl class="domintro">
	<dt>%element . `spellcheck$m [ = %値 ]</dt>
	<dd>
要素の綴りや文法が検査されるならば ~T ／
~ELSE_ ~F
を返す。
◎
Returns true if the element is to have its spelling and grammar checked; otherwise, returns false.
</dd>
	<dd>
設定して、既定の挙動を上書きしつつ，
`spellcheck$a 内容~属性を設定できる。
◎
Can be set, to override the default and set the spellcheck content attribute.
</dd>

	<dt>%element . `forceSpellCheck()$m</dt>
	<dd>
（検査が可能化されているならば）
要素~上の綴りや文法の誤りを報告するよう，~UAに強制する
—
利用者が要素を決して~focusしたことがなくとも（この~methodが呼出されなければ、~UAは，利用者が~just手入力した~text以外の~textにおける誤りについては隠せる。）
◎
Forces the user agent to report spelling and grammar errors on the element (if checking is enabled), even if the user has never focused the element. (If the method is not invoked, user agents can hide errors in text that wasn't just entered by the user.)
</dd>
</dl>

<div>
<p>
`spellcheck@m
~IDL属性の被取得時には、次を走らせ~MUST：
</p>

<ol>
	<li>
<p>
要素の `spellcheck$a 内容~属性の状態に応じて：
</p>

<dl class="switch">
	<dt>`~T^st
</dt><dd>~RET ~T

</dd><dt>`~F^st
</dt><dd>~RET ~F

</dd><dt>`既定の挙動^st
</dt><dd>
<p>
要素の`既定の挙動$に応じて：
</p>
	<dl class="switch">
	<dt>`既定で ~T$
	</dt><dd>~RET ~T

	</dd><dt>`既定で ~F$
	</dt><dd>~RET ~F

	</dd><dt>`既定で継承-$
	</dt><dd>
~RET 要素の親~要素の `spellcheck$m ~IDL属性を取得した結果
	</dd></dl>
</dd></dl>

	</li>
</ol>

◎
The spellcheck IDL attribute, on getting, must return true if the element's spellcheck content attribute is in the true state, or if the element's spellcheck content attribute is in the default state and the element's default behaviour is true-by-default, or if the element's spellcheck content attribute is in the default state and the element's default behaviour is inherit-by-default and the element's parent element's spellcheck IDL attribute would return true; otherwise, if none of those conditions applies, then the attribute must instead return false.
</div>


<p class="note">注記：
`spellcheck$m ~IDL属性は、［
`spellcheck$a 内容~属性を上書きする利用者~選好~s
］により影響されることはないため、実際の＊~spellchecking状態を反映しないこともある。
◎
The spellcheck IDL attribute is not affected by user preferences that override the spellcheck content attribute, and therefore might not reflect the actual spellchecking state.
</p>


<p>
被設定時には、要素の `spellcheck$a 内容~属性を［
新たな値 ~EQ ~T ならば ~literal文字列 `true^l ／
~ELSE_ `false^l
］に設定し~MUST。
◎
On setting, if the new value is true, then the element's spellcheck content attribute must be set to the literal string "true", otherwise it must be set to the literal string "false".
</p>
<hr>


<p>
この特色機能の目的0において検査し得る~textは、次に挙げる~text片に限られ~MUST：
◎
User agents must only consider the following pieces of text as checkable for the purposes of this feature:
</p>

<ul>
	<li>
<p>
［
次のいずれも満たすような `input$e 要素
］の，`値$fe：
</p>
		<ul>
			<li>
`type$a 属性の状態 ~IN
{ `Text$st, `Text$st, `URL$st, `E-mail$st }
</li>
			<li>
`変異可能$ （すなわち、［
`readonly$a 属性は有さない
］~AND `不能化され$ていない）
</li>
		</ul>
◎
The value of input elements whose type attributes are in the Text, Search, URL, or E-mail states and that are mutable (i.e. that do not have the readonly attribute specified and that are not disabled).
</li>
	<li>
<p>
［
次のいずれも満たすような `textarea$e 要素
］の，`値$fe：
</p>
		<ul>
			<li>
`＊readonly$a 属性は有さない
</li>
			<li>
`不能化され$ていない
</li>
		</ul>
◎
The value of textarea elements that do not have a ＊readonly attribute and that are not disabled.
</li>
	<li>
［
`編集中の~host$ ／ `編集可能$な要素
］の子であるような `Text$I ~node内の~text。
◎
Text in Text nodes that are children of editing hosts or editable elements.
</li>
	<li>
`編集可能$な要素の属性~内の~text。
◎
Text in attributes of editable elements.
</li>
</ul>


<div>
<p>
~textに結付けらる当の要素は：
</p>

	<ul>
		<li>
`Text$I ~nodeの一部分である~textに対しては、［
単語, 文, その他の~text片
］の最初の文字の直の親である要素になる。
</li>
		<li>
属性~内の~textに対しては、当の属性を有している要素になる。
</li>
		<li>
`input$e ／ `textarea$e
要素の値に対しては、要素~自身になる。
</li>
	</ul>

◎
For text that is part of a Text node, the element with which the text is associated is the element that is the immediate parent of the first character of the word, sentence, or other piece of text. For text in attributes, it is the attribute's element. For the values of input and textarea elements, it is the element itself.
</div>


<p>
<!-- 
（上に定義されるように）適用可能な要素~内の［
単語, 文, その他の~text片
］
-->
検査し得る~text %~text に対する綴りや文法の検査は、次の~algoの結果が［
`可能化される^i ならば可能化され ／ `不能化される^i ならば不能化され
］~MUST：
◎
To determine if a word, sentence, or other piece of text in an applicable element (as defined above) is to have spelling- and grammar-checking enabled, the UA must use the following algorithm:
</p>

<ol>
	<li>
~IF［
利用者は、 %~text に対する検査を不能化している
］
⇒
~RET `不能化される^i
◎
If the user has disabled the checking for this text, then the checking is disabled.
</li>
	<li>
~IF［
利用者は、 %~text の検査を常に可能化するように強制している
］
⇒
~RET `可能化される^i
◎
Otherwise, if the user has forced the checking for this text to always be enabled, then the checking is enabled.
</li>
	<li>
%要素 ~LET 
</li>
	<li>
%要素~列 ~SET［
%~text に結付けらている当の要素, および その先祖~要素
］からなる，要素 に近い順の~list
</li>
	<li>
<p>
~FOR
%要素~列 内の~EACH( %要素 ) に対し，順に
⇒
%要素 の `spellcheck$a 内容~属性の状態に応じて：
</p>

<dl class="switch"><dt>`~T^st
</dt><dd>~RET `可能化される^i

</dd><dt>`~F^st
</dt><dd>~RET `不能化される^i

</dd><dt>`既定の挙動^st
</dt><dd>~CONTINUE
</dd></dl>
◎
Otherwise, if the element with which the text is associated has a spellcheck content attribute, then: if that attribute is in the true state, then checking is enabled; otherwise, if that attribute is in the false state, then checking is disabled.
◎
Otherwise, if there is an ancestor element with a spellcheck content attribute that is not in the default state, then: if the nearest such ancestor's spellcheck content attribute is in the true state, then checking is enabled; otherwise, checking is disabled.
</li>
	<li>
<p>
~FOR
%要素~列 内の~EACH( %要素 ) に対し，順に
⇒
%要素 の`既定の挙動$に応じて：
</p>

<dl class="switch">
<dt>`既定で ~T$
</dt><dd>~RET `可能化される^i

</dd><dt>`既定で ~F$
</dt><dd>~RET `不能化される^i

</dd><dt>`既定で継承-$
</dt><dd>~CONTINUE
</dd></dl>

<p class="trans-note">【
原文では，この段の中でこの~algoを再帰的に呼出しているが、前~段にて，どの先祖の
 `spellcheck$a 内容~属性の状態も `既定の挙動^st であることはすでに判っているので、この和訳ではより簡潔な形に定義し直している。
】</p>

◎
Otherwise, if the element's default behaviour is true-by-default, then checking is enabled.
◎
Otherwise, if the element's default behaviour is false-by-default, then checking is disabled.
◎
Otherwise, if the element's parent element has its checking enabled, then checking is enabled.
◎
Otherwise, checking is disabled.
</li>

	<li>
~RET ？
`この場合の挙動は、原文には定義されていない^tnote
</li>

</ol>

<div >
<p>
単語/＊sentence/~text
に対する検査が可能化されている場合、~UAは，その~text内に綴りや文法に誤りがあれば それを指示するべきである。
~UAは、綴りや文法の訂正を推薦するときには，文書~内に所与の他の意味論も織り込むべきである — これには、次が含まれる：
</p>
<ul>
	<li>
要素に指定されている自然言語や,
利用者が選好している自然言語~設定群
を利用して、綴りや文法に利用する規則を決定してよい。
</li>
	<li>
可能0な所では、
`pattern$a などの `input$e 要素~属性を利用して，結果の値が妥当になることを確保するべきである。
</li>
</ul>

◎
If the checking is enabled for a word/sentence/text, the user agent should indicate spelling and grammar errors in that text. User agents should take into account the other semantics given in the document when suggesting spelling and grammar corrections. User agents may use the language of the element to determine what spelling and grammar rules to use, or may use the user's preferred language settings. UAs should use input element attributes such as pattern to ensure that the resulting value is valid, where possible.
</div>

<p >
検査が：
</p>

<ul>
	<li>
不能化されている場合、~UAは，その~textに対する綴りや文法の誤りを指示するべきでない。
◎
If checking is disabled, the user agent should not indicate spelling or grammar errors for that text.
</li>
	<li>
<p>
可能化されていても、~UAは，［
利用者が検査することに関心がないものと判断できるような~text
］内の綴りや文法の誤りについては報告しないことにしてもよい
— 例えば：
</p>

<ul ><li>頁が読込まれた時点ですでに在った~text
</li><li>利用者が手入力しなかった~text
</li><li>利用者が~focusしていない~control内の~text
</li><li>~UAにとって綴りが誤っているのかどうか判らない e-mail ~addressの一部。
</li></ul>

<p >
要素~上の
`forceSpellCheck()@m
~methodの被呼出時には、この挙動を上書きし~MUST
— 利用者は［
その要素~内の，検査が可能化されている~text内のすべての綴りや文法の誤り
］に関心があるものと，~UAが見なすように強制して。
</p>

◎
Even when checking is enabled, user agents may opt to not report spelling or grammar errors in text that the user agent deems the user has no interest in having checked (e.g. text that was already present when the page was loaded, or that the user did not type, or text in controls that the user has not focused, or in parts of e-mail addresses that the user agent is not confident were misspelt). The forceSpellCheck() method, when invoked on an element, must override this behaviour, forcing the user agent to consider all spelling and grammar errors in text in that element for which checking is enabled to be of interest to the user.
</li>
</ul>


<div class="example">

<p>
次の例における ID `a^l にされた要素は、［
単語 `Hello^l に対する綴りを検査するかどうか
］を決定するために利用される。
この例では、検査されない。
◎
The element with ID "a" in the following example would be the one used to determine if the word "Hello" is checked for spelling errors. In this example, it would not be.
</p>


<pre>
&lt;div contenteditable="true"&gt;
 &lt;span spellcheck="false" id="a"&gt;Hell&lt;/span&gt;&lt;em&gt;o!&lt;/em&gt;
&lt;/div&gt;
</pre>


<p>
次の例における ID `b^l にされた要素に対しては、検査は可能化される（
`input$e 要素~上の属性~値~内の頭部の空白類は，属性を無視させるので、
~the既定の＊にかかわらず先祖の値が代わりに利用される）。
◎
The element with ID "b" in the following example would have checking enabled (the leading space character in the attribute's value on the input element causes the attribute to be ignored, so the ancestor's value is used instead, regardless of the default).
</p>


<pre class="bad">&lt;p spellcheck="true"&gt;
 &lt;label&gt;Name: &lt;input spellcheck=" false" id="b"&gt;&lt;/label&gt;
&lt;/p&gt;
</pre>

</div>


<p class="note">注記：
この仕様は、綴りや文法~検査器のための~UIは定義しない。
例えば~UAは、［
その場で検査を提供0する ／
検査が可能化されている間，継続的に検査を遂行する ／
その他の~UI
］も利用できる。
◎
This specification does not define the user interface for spelling and grammar checkers. A user agent could offer on-demand checking, could perform continuous checking while the checking is enabled, or could use other interfaces.
</p>

			</section>
		</section>
		<section id="dnd">
<h3 title="Drag and drop">6.7. ~drag＆~drop</h3>

<p class="trans-note">【
この節の内容は、
<a href="~HTMLDND">別~頁にて</a>。
】</p>


		</section>
	</section>
</main>


<pre>

================


:#4
	Alt:#1
	C:
	Control:#1
	Emacs:#2
	Escape:#1
	Mac:#1
	Shift:#1
	WYSIWYG
	Windows:#1
	ARIA
	CSS
~according:#1
織り込む~take~into~account
加えて~additionally:#2
告知-~advertise:#1
参考情報:advisory information:#1
美観など~aesthetics:#1
~aforementioned:#1
支援:aid:~
~algo:#1
~alone:#2
~amongst:#1
~assigning:#1
~authentic:#2
~aware:#1
~became:#1
~become:#2
見込んで~believe:#1
~big:#1
~body:#3
候補~candidate:#51
~care:#1
~caused:#1
~cell:#6
~channeled:#2
~column:#4
~committing:#1
判らない~not confident:#1
~consist:#2
~control群:#47
訂正~correction:#1
~culminating:#1
判断-~deem:#1
最も深い~deepest:#1
~depth-first:#2
~detriment:#1
〜しないことが奨励~discourage:#1
~e-mail:#1
~earlier:#1
終端~end:#3
~equipped:#1
-:~express:#1
~facet:#2
馴染んでいる~familiar:#1
~finally:#1
申し分ない~fine:#1
収まる~fit:#1
~fixup:#1
修復~focus-fixup:#6
~follow:#4
	等々:and so forth:#1
~gain:#2
~home:#8
~iD:#2
~in-:#1
~instruction:#1
〜しか／~just
正当化される~well~justified:#1
~kiosk-mode:#1
~lack:#1
~later:#1
~lead:#1
~left:#1
可能性が高い~likely:#1
~mac:#1
~made:#2
~marked:#1
~matching:#1
に過ぎない~merely:#1
~middle:#1
綴りが誤っている~misspelt:#1
組み合わせ~mix:#1
最大公約数的な:modulo:~


~moving:#1
きれいに~neatly:#1
~non-breaking:#3

も~opt~to:#1
~opted:#1

選ぶ~pick:#3
~text片:~piece~of~text:#3
~placeholder:#1
~point:#2
~pre-order:#2
押すこと:pressing:#3
普及している~prevalent:#1
~put:#1
~redo:#5
~reduce:#1
指す~refer:#7
~referenced:#1
 `space^i ~regular~spaces ／普通の space（ U+0020 ）
~rerouting:#1
~right:#1
~route:#4
~routed:#1
~row:#1
~said:#1
何らかの方法~somehow:#1
~sometime:#1
またがる~span:#1
その検査／~spellchecking:#2
~spin-control:#1

不向きで not well suited
とする／~suppose:#3
~sure:#2
~tab化された:~tabbed:#2
~tabbing:#1
伝える~tell:#1
~thereof:#1
~top:#1
~toward:#1
手入力~type0:#2
~unable:#1
~unadorned:#1
~unmark:#1
~unset:#1
目障り~unsightly:#1
使い勝手は悪くなる~unusable:#1
無思慮／~unwise:#2
様々な~variety:#2
弱視者:reduced vision:
~vision:#1
広範に~widely:#1
~~連続する~adjacent:#1
おそらく~probably:#1
その場で~on-demand:#1
一つに~together:#1
一様~uniform:#1
人々~people:#1
働かな~work しな:~
使い勝手~usability reason:#1
単純に~simply:#1
叩いて~hit:#1
多様な~wide variety of
易くする~help:#1
概ね、~roughly~speaking:#2
選んだ~choosing:#1
閉じられ~closed:#2
開閉~opened~or~closed
黄色の~yellow:#1


</pre>

	~~由来する:comes from
	下位~widget~s:subwidgets
	容易く:easily
	始点:starting point:~
	何らかの類の:some sort of
	全面的に:entirely
	符号位置:code point
	きわどい:corner
	〜されない:opposed:#1
一部分:part of
部分:part
具体的には~for~instance,
一枚の大きな~one~big
同等に~equally
指-refer
~~単独~alone
周知のcommonly known
用立て~make use of
締め括られる~culminating
進捗中:in progress:~
	表:table
真中に＊~in~the~middle
走らな
~steps above leading up to this point:~
左列:The cells in the left column
右列:cells in the right column
横幅全体にまたがる列:cells that span both columns
~DOM木における`木~順序$xと同様の順序 ~pre-order, ~depth-first
要因a factor that contributes towards
有無~lack thereof
それに代わるin its stead
使い勝手が悪くsignificantly less usable
対応付けられる:map され
-:in place for
off-screen
増減~button:up and down buttons in a spin-control version
挿入~inserting
