<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Performance Timeline Level 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style>
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"'
	break;
case 'm': // IDL member
case 'mO':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Performance Timeline Level 2
spec_date:2018-10-09
trans_update:2018-01-12
source_checked:170524
page_state_key:TIMING
original_url:https://w3c.github.io/performance-timeline/
spec_status:ED
ref_id_prefix:bib-
copyright:2018,permissive
trans_1st_pub:2015-07-27


●●class_map
E:error

●●tag_map
I:code
m:code
mO:code
d:code
c:code
E:code
v:var
V:var
b:b
i:i

●●original_id_map



	dom-performanceentrylist:idl-def-performanceentrylist
	dom-performanceobservercallback:idl-def-performanceobservercallback
	dom-performanceobserverentrylist:idl-def-performanceobserverentrylist
	dom-performanceobserverinit:idl-def-performanceobserverinit


●●link_map


Exposed:~WEBIDL#Exposed
Default:~WEBIDL#Default

I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.Performance:~HRTIME#dfn-performance
I.PerformanceEntry:#dom-performanceentry
I.PerformanceEntryList:#dom-performanceentrylist
I.PerformanceObserver:#dom-performanceobserver
I.PerformanceObserverCallback:#dom-performanceobservercallback
I.PerformanceObserverEntryList:#dom-performanceobserverentrylist
I.PerformanceObserverInit:#dom-performanceobserverinit

DOMString:~WEBIDL#idl-DOMString
boolean:~WEBIDL#idl-boolean
object:~WEBIDL#idl-object
sequence:~WEBIDL#idl-sequence
Constructor:~WEBIDL#Constructor

m.name:#dom-performanceentry-name
m.startTime:#dom-performanceentry-starttime
m.entryType:#dom-performanceentry-entrytype
m.duration:#dom-performanceentry-duration
m.toJSON:#dom-performanceentry-tojson

m.getEntries:#dom-performance-getentries
m.getEntriesByName:#dom-performance-getentriesbyname
m.getEntriesByType:#dom-performance-getentriesbytype

mO.getEntries:#dom-performanceobserverentrylist-getentries
mO.getEntriesByName:#dom-performanceobserverentrylist-getentriesbyname
mO.getEntriesByType:#dom-performanceobserverentrylist-getentriesbytype

m.observe:#dom-performanceobserver-observe
m.disconnect:#dom-performanceobserver-disconnect
m.takeRecords:#dom-performanceobserver-takerecords


m.PerformanceObserver:#_dom-performanceobserver-performanceobserver

d.entryTypes:#dom-performanceobserverinit-entrytypes
d.buffered:#dom-performanceobserverinit-buffered

	m.PerformanceObserverInit.entryTypes:#dom-performanceobserverinit-entrytypes

V.~entry~obj:#dfn-entryobject
V.~entry~obj~list:#dfn-list-of-entry-objects

絞込んだ:#filter-buffer-by-name-and-type
処理能時列線:#dfn-performance-timeline
	Performance Timeline
観測器~buffer:#dfn-observer-buffer
~callback:#_observer-callback
処理能~entry~buffer:#dfn-performance-entry-buffer
関連する処理能~entry~buffer:#dfn-relevant-performance-entry-buffer
処理能~観測器~task~queue済み~flag:#dfn-performance-observer-task-queued-flag
処理能~entryを~queueする:#dfn-queue-a-performanceentry
	登録する:#dfn-register-the-observer
登録-済み:#dfn-registered-performance-observer

処理能~観測器:#_performanceobserver-interface
処理能~観測器~list:#dfn-registered-performance-observer
	登録-済み処理能~観測器:#dfn-registered-performance-observer
処理能~時列線~task源:#_performance-timeline-task-source

~options:#_options

~ES大域~環境:~WEBIDL#es-environment
~interface~obj:~WEBIDL#dfn-interface-object
辞書~member:~WEBIDL#dfn-dictionary-member
~callback this 値:~WEBIDL#dfn-callback-this-value
既定の~toJSON演算:~WEBIDL#default-tojson-operation
投出-:~WEBIDL#dfn-throw

例外を報告する:~WAPI#report-the-exception
~taskを~queueする:~WAPI#queue-a-task
~task~queue:~WAPI#task-queue
~task源:~WAPI#task-source
関連する大域~obj:~WAPI#concept-relevant-global
大域~obj:~WAPI#global-object

r.PAINT-TIMING:paint-timing-ja.html

●●words_table1


●●words_table



	●peroformance
時列線:timeline::~:タイムライン
処理能:performance::~:パフォーマンス
処理能時列線:Performance Timeline::~:パフォーマンスタイムライン
	処理能観測器:Performance Observer::~:パフォーマンスオブザーバ
観測器:observer::~:オブザーバ
観測-:observe::~:オブザーブ

時間:time::~
時刻印:timestamp::~
時系列順:chronological order::~
時刻:time::~
所要時間:duration::~

disconnect:
entry:::エントリ
host:::ホスト
event:::イベント
bottleneck:::ボトルネック
overhead:::オーバーヘッド
buffer:::バッファ
task:::タスク
flag:::フラグ
source:::ソース
源:source::~:ソース
options::option 集


登録-:register::~
	登録-済み:registered
直列化-:serialize::~:シリアル化
直列化子:serializer::~:シリアライザ
計時:timing::~
計測:measure::~
計量:metric::~
記録:record::~

正確0:accurate:正確
通知-:notify:~
延期-:delay:~
適時に:timely manner で::~
分解能:resolution::~
同期的:synchronous::~
報告-:report::~
報告:reporting::~
定期的:periodic::~
格納-:store:~
測定-:instrument::~
取得-:retrieve::~
全存続期間:full lifecycle::~
遊休中:idle 中:~
	during idle periods
低優先度の:low priority:~
監視:monitoring:~
	最小限に抑える-:minimize#1

絞込んだ:filter した:絞り込んだ
絞込む:filter する:絞り込む
絞込み:filtering:絞り込み
	~filter:取り除いた

	interested:
queue::::キュー
	~queue済み:queued

高分解能の:high-resoluting:~

	●IDL
callback:
call:
toJSON:
辞書:dictionary::~:デイクショナリ
連列:sequence::~:シーケンス
型:type:~
instance:::インスタンス
interface::::インタフェース
list:::リスト
map:
member:::メンバ
method:::メソッド
obj:object::オブジェクト
空:empty:~
在する:present する:在る
大域:global:~::グローバル
環境:environment:~
属性:attribute:~
整列-:sort:~
文書:document:~
新たな:new:~
文字列:string:~
名前:name:~
値:value:~
種別:type:~
	型:type:~
識別子:identifier:~
例外:exception:~
投出-:throw:~
構築子:constructor::~:コンストラクタ
被呼出時:被 invoke 時:~
呼出した:invoke した:呼び出した
取得子:getter:~
演算:operation:~
配列:array:~

	●
初期:initial:~
	initially
付加-:append:~
複製:copy:~
引数:argument:~
関数:function:~
設定-:set:~

	●仕様
	-:discouraged
UA:user agent:UA
algo:algorithm::アルゴリズム
access:::アクセス
	足並みを揃える:align with:
app:application::アプリ
support:::サポート
	~supportされない:unsupported:~
version:::バージョン
web::::ウェブ
approach:::アプローチ
仕様:spec:~
保つ:keep する:~
妥当:valid:~
定義-:define:~
	予め定義された:predefined:::~
導入:introduce:~
手続き:steps:~
下位手続き:substeps:~
拡張-:extend:~
拡張:extension:~
供-:provide:~
暗黙的:implicit:~
最小限:minimum:~
概して:typical に:~
概念:concept:~
無視-:ignore:~
相違:difference:~
要求-:require:~
規則:rule:~
認識-:recognize:~
適用-:apply:~
避ける:avoid する:~
避けれ:avoid でき:~
重要:important:~
開発者:developer:~
関係-:relate:~
側面:aspect:~
別法:alternative:~
可用:available:~
可能0:possible:可能
可能化-:enable:~
	基づいて:based:~
情報:information:~
固守-:adhere:~
結付ける:associate する:結び付ける
結付けら:associate さ:結び付けら
影響0:impact:影響
	なくす:eliminate
制限:limitations:~
取組む:address する:取り組む
設計:design:~
奨励-:encourage:~
考慮点:considerations:~
依存関係:dependencies:~
便利:convenience:~
警告:warning:~
適切:appropriate:~

	●未分類（動詞
作成-:create:~
処理-:process:~
処理:processing:~
包含-:contain:~
合致-:match:~
生成-:generate:~
省略-:omit:~
置換-:replace:~
表現-:represent:~
表面化-:surface:~
追加-:add:~
関与-:participate:~
除去-:remove:~
申込む:subscribe する:申し込む
申込んで:subscribe して:申し込んで
検出-:detect:~
操作-:manipulate:~
識別-:identify:~
公開-:expose:~
走らせ:run し:~
走らす:run する:~
開始-:start:~
中止-:abort:~

	polling
	-:emit
	調べる:poll する
	所与の:given
	与:give
	利用:use
	得-:obtain
	示-:show
	返-:return
	述-:describe
	関心のある:interested in
	instruct
	respect
	run
	subscription

	●未分類
ES:ECMAScript
JS:JavaScript
console:::コンソール
privacy:::プライバシー
保安:security::~:セキュリティ
interface:::インタフェース
data:::データ
navi:navigation::ナビ
option:::オプション
page:::ページ
pair:::ペア
primitive:
code:::コード
cost:::コスト
logic:::ロジック
property:::プロパティ
script:::スクリプト

関連する:relevant な:~
一意:unique:~
内容:content:~
合間:between:~
特性:characteristics:~
資源:resource::~:リソース
順序:order:~
消費者:consumer:~

	競合:race condition:~
	deduplication
	no longer
	together
	この:this
	すべての:all
	より速く:faster
	代わり:instead
	例:example
	全体:entire
	各:each
	同じ:same
	大量に:significant volume の
	必要とされ:necessary
	最初の:first
	最後の:last
	種々の:various
	高:high


●●ref_normative

[HR-TIME-2]
    High Resolution Time Level 2. Ilya Grigorik; James Simonsen; Jatinder Mann. W3C. 1 March 2018. W3C Candidate Recommendation. URL: https://www.w3.org/TR/hr-time-2/
[resource-timing]
    Resource Timing Level 1. Arvind Jain; Todd Reifsteck; Jatinder Mann; Zhiheng Wang; Anderson Quach. W3C. 30 March 2017. W3C Candidate Recommendation. URL: https://www.w3.org/TR/resource-timing-1/
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119
[WebIDL]
    Web IDL. Cameron McCormack; Boris Zbarsky; Tobie Langel. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/
[WHATWG-DOM]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[WHATWG-HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[WHATWG-INFRA]
    Infra Standard. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/

●●ref_informative

[NAVIGATION-TIMING-2]
    Navigation Timing Level 2. Ilya Grigorik; Tobin Titus; Jatinder Mann; Arvind Jain. W3C. 5 December 2017. W3C Working Draft. URL: https://www.w3.org/TR/navigation-timing-2/
[PERFORMANCE-TIMELINE]
    Performance Timeline. Jatinder Mann; Zhiheng Wang. W3C. 12 December 2013. W3C Recommendation. URL: https://www.w3.org/TR/performance-timeline/
[RESOURCE-TIMING-2]
    Resource Timing Level 2. Todd Reifsteck; Ilya Grigorik; Arvind Jain; Jatinder Mann; Zhiheng Wang; Anderson Quach. W3C. 18 May 2018. W3C Working Draft. URL: https://www.w3.org/TR/resource-timing-2/
[USER-TIMING-2]
    User Timing Level 2. Ilya Grigorik; Jatinder Mann; Zhiheng Wang; Anderson Quach. W3C. 2 April 2018. W3C Working Draft. URL: https://www.w3.org/TR/user-timing-2/
[WORKERS]
    Web Workers. Ian Hickson. W3C. 24 September 2015. W3C Working Draft. URL: https://www.w3.org/TR/workers/

●●trans_metadata

<p>
~THIS_PAGEは、~W3Cにより，副題に日付にて編集者草案として公開された
<a href="~SPEC_URL">Performance Timeline Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/performance-timeline-2/

編集者草案
	https://w3c.github.io/performance-timeline/

編集
	<a href="https://www.igvita.com/">Ilya Grigorik</a>, Google, <a href="mailto:igrigorik@gmail.com">igrigorik@gmail.com</a>
	Jatinder Mann, Microsoft Corp., <a href="mailto:jmann@microsoft.com">jmann@microsoft.com</a> (Until November 2014)
	Zhiheng Wang, Google (Until July 2013)

リポジトリ
	<a href="https://github.com/w3c/performance-timeline/">We are on GitHub</a>
	<a href="https://github.com/w3c/performance-timeline/commits/gh-pages/index.html">Commit history</a>
	<a href="https://github.com/w3c/performance-timeline/issues">File a bug</a>

Mailing list
	<a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a>

実装
	<a href="http://w3c-test.org/performance-timeline/">Test Suite</a>
	<a href="https://github.com/web-platform-tests/wpt/tree/master/performance-timeline">Test Suite repository</a>

</script>


</head>

<body>

<header>

	<hgroup>
<h1 id="title">処理能 時列線 — Performance Timeline Level 2</h1>
	</hgroup>
</header>


<div id="MAIN" hidden>

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、
High Resolution Time 仕様 `HR-TIME-2$r
を拡張して、より高~分解能の処理能~計量~dataを［
取得する／格納する
］~methodを供する。
◎
This specification extends the High Resolution Time specification [HR-TIME-2] by providing methods to store and retrieve high resolution performance metric data.
</p>

	</section>
	<section id="sotd">
<h2 title="Status of This Document">この文書の位置付け</h2>

<p>
この節では、発行時点における…
<!-- 
これは編集者草案の公開の複製です…
-->
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>


<p>
Performance Timeline Level 2 は、その最初の~versionである
`PERFORMANCE-TIMELINE$r を置換し，次を含む：
◎
Performance Timeline Level 2 replaces the first version of [PERFORMANCE-TIMELINE] and includes:
</p>

<ul>
	<li>
`HR-TIME-2$r に定義される `Performance$I ~interfaceを拡張する。
◎
Extends the base definition of the Performance interface defined by [HR-TIME-2];
</li>
	<li>
Web Workers `WORKERS$r に
`PerformanceEntry$I を公開する。
◎
Exposes PerformanceEntry in Web Workers [WORKERS];
</li>
	<li>
`PerformanceObserver$I 用の~supportを追加する。
◎
Adds support for performance observers.
</li>
</ul>

<p>
この文書は
<a href="https://www.w3.org/webperf/">Web Performance Working Group</a>
により発行されました。
◎
This document was published by the Web Performance Working Group as an Editor's Draft. Comments regarding this document are welcome. Please send them to public-web-perf@w3.org (subscribe, archives) with [Performance Timeline] at the start of your email's subject.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">

<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~web~appの処理能~特性を正確0に計測することは、~web~appを より速くするための重要な側面である。
この仕様は、~web開発者が，
~web~appの全存続期間にわたる種々の処理能~計量［
に~accessする ／
を測定する ／
を取得する
］ことを可能化するために必要とされる
`処理能時列線$の~primitiveを定義する。
◎
Accurately measuring performance characteristics of web applications is an important aspect of making web applications faster. This specification defines the necessary Performance Timeline primitives that enable web developers to access, instrument, and retrieve various performance metrics from the full lifecycle of a web application.
</p>

<p>
［
`NAVIGATION-TIMING-2$r ／ `RESOURCE-TIMING-2$r ／ `USER-TIMING-2$r
］は、順に［
文書の~navi ／
~page上の資源 ／
開発者~script
］に関係する計時~情報を定義する仕様の例である。
これらは、他の処理能~interfaceと伴に，~web~appの`処理能時列線$を述べる処理能の計量を定義する。
例えば，次の~scriptは、開発者が［
文書の~navi ／
~page上の資源 ／
開発者~script
］に関係する処理能~計量を得るために
`処理能時列線$に~accessする方法を示すものである：
◎
[NAVIGATION-TIMING-2], [RESOURCE-TIMING-2], and [USER-TIMING-2] are examples of specifications that define timing information related to the navigation of the document, resources on the page, and developer scripts, respectively. Together these and other performance interfaces define performance metrics that describe the Performance Timeline of a web application. For example, the following script shows how a developer can access the Performance Timeline to obtain performance metrics related to the navigation of the document, resources on the page, and developer scripts:
</p>


<div class="example">

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body onload="init()"&gt;
&lt;img id="image0" src="https://www.w3.org/Icons/w3c_main.png" /&gt;
&lt;script&gt;

function init()
{
  /* <span class="comment">
`USER-TIMING-2$r を見よ
◎
see [[USER-TIMING-2]]
</span> */
  performance.mark("startWork");
  doWork(); /* <span class="comment">
何らかの開発者~code
◎
Some developer code
</span> */
  performance.mark("endWork");
  measurePerf();
}

function measurePerf() {
  performance
    .getEntries()
    .map(%entry =&gt; JSON.stringify(%entry, null, 2))
    .forEach(%json =&gt; console.log(%json));
}

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

</div>

<p>
別法として，開発者は、`処理能時列線$を観測して，新たな処理能~計量が観測される度に `PerformanceObserver$I ~interfaceを介して通知させれる。
また，任意選択で、指定した種別の, すでに~buffer済みの処理能~計量も通知させれる。
◎
Alternatively, the developer can observe the Performance Timeline and be notified of new performance metrics and, optionally, previously buffered performance metrics of specified type, via the PerformanceObserver interface:
</p>


<div class="example">

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
  &lt;img id="image0" src="https://www.w3.org/Icons/w3c_main.png" /&gt;
  &lt;script&gt;

const %observer = new PerformanceObserver(%list => {
  %list
    .getEntries()
    /* <span class="comment">
挿入された値を取得する
◎
Get the values we are interested in
</span> */
    .map(({ %name, %entryType, %startTime, %duration }) => {
      const %obj = {
        "Duration": %duration,
        "Entry Type": %entryType,
        "Name": %name,
        "Start Time": %startTime,
      };
      return JSON.stringify(%obj, null, 2);
    })
    /* <span class="comment">
それらを~consoleに表示する
◎
Display them to the console
</span> */
    .forEach(console.log);
    /* <span class="comment">
~eventを処理したなら~disconnectされてよい
◎
maybe disconnect after processing the events.
</span> */

  %observer.disconnect();
});
/* <span class="comment">
Resource-Timing と User-Timing ~eventに対し，
~buffer済みの~eventを取得する／新たな~eventを申込む
◎
retrieve buffered events and subscribe to new events for Resource-Timing and User-Timing
</span> */
observer.observe({
  entryTypes: [`resource^l, `mark^l, `measure^l],
  buffered: true
});

  &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>


<p>
Performance Timeline Level 2 には、
`PerformanceObserver$I ~interfaceが追加された。
これは、最初の例に示された~bufferに基づく~approachにおける制限に取組むように設計されている。
`PerformanceObserver$I を利用すれば、~appは次が可能になる：
◎
The PerformanceObserver interface was added in Performance Timeline Level 2 and is designed to address limitations of the buffer-based approach shown in the first example. By using the PerformanceObserver interface, the application can:
</p>

<ul>
	<li>
時列線を調べ続ける（ polling ）ことなく，新たな計量を検出できる。
◎
Avoid polling the timeline to detect new metrics
</li>
	<li>
~costのかかる~~重複排除~logic（ deduplication ）なしに，新たな計量を識別できる。
◎
Eliminate costly deduplication logic to identify new metrics
</li>
	<li>
他の消費者と~~競合する（ race condition ）ことなく，~bufferを操作できる。
◎
Eliminate race conditions with other consumers that may want to manipulate the buffer
</li>
</ul>

<p>
開発者には、可能0な所では， `PerformanceObserver$I を利用することが奨励される。
加えて，新たな処理能 API や計量は、 `PerformanceObserver$I ~interfaceを通してのみ可用にされることになる。
◎
The developer is encouraged to use PerformanceObserver where possible. Further, new performance API's and metrics may only be available through the PerformanceObserver interface.
</p>


	</section>

	<section id="_terms">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（ 此れ, ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>
	</section>

	<section id="performance-timeline">
<h2 title="Performance Timeline" id="dfn-performance-timeline">3. 処理能時列線</h2>


<div class="p">
<p>
各 `~ES大域~環境$【`大域~obj$】には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`処理能~観測器~task~queue済み~flag@</dt>
	<dd>
~flag値。
【初期~時は ~OFF 】
</dd>

	<dt>`処理能~観測器~list@</dt>
	<dd>
`処理能~観測器$からなる~list。
初期~時は空とする。
</dd>
	<dd>
`処理能~観測器$は、この~list内にある間は `登録-済み^i であるともいう。
</dd>

	<dt>`処理能~entry~buffer@</dt>
	<dd>
`PerformanceEntry$I ~objたちを格納する（初期~時は空）。
</dd>
</dl>

◎
Each ECMAScript global environment has:
◎
a performance observer task queued flag
◎
a list of registered performance observer objects that is initially empty
◎
a performance entry buffer to store PerformanceEntry objects that is initially empty
</div>

<p>
~objに
`関連する処理能~entry~buffer@
は、［
~objに`関連する大域~obj$
］に結付けられている`処理能~entry~buffer$を指す。
◎
The relevant performance entry buffer is the performance entry buffer associated with the relevant global object.
</p>

		<section id="extensions-to-the-performance-interface">
<h3 title="Extensions to the Performance interface">3.1. `Performance^I ~interfaceに対する拡張</h3>

<p>
この節では、［
処理能に関係する各種~属性, および［
`処理能時列線$からの処理能~計量~dataを取得する
］ために利用される 各種~method
］を~hostするように，
`HR-TIME-2$r の `Performance$I ~interfaceを拡張する。
◎
This extends the Performance interface [HR-TIME-2] and hosts performance related attributes and methods used to retrieve the performance metric data from the Performance Timeline.
</p>

<pre class="idl">
partial interface `Performance$I {
    `PerformanceEntryList$I `getEntries$m();
    `PerformanceEntryList$I `getEntriesByType$m(`DOMString$ %type);
    `PerformanceEntryList$I `getEntriesByName$m(`DOMString$ %name, optional `DOMString$ %type);
};

typedef `sequence$&lt;`PerformanceEntry$I&gt; `PerformanceEntryList$I;
</pre>

<p>
`PerformanceEntryList@I
は、 `PerformanceEntry$I の連列を表現する
— それは、開発者に~JS配列の便利~methodすべてを供する。
◎
The PerformanceEntryList represents a sequence of PerformanceEntry, providing developers with all the convenience methods found on JavaScript arrays.
</p>

<dl class="idl-def" id="methods">
	<dt id="getentries-method">`getEntries()@m</dt>
	<dd>
被呼出時には、此れに`関連する処理能~entry~buffer$を
( ~NULL, ~NULL )
で`絞込んだ$結果を返すモノトスル。
◎
3.1.1 getEntries() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to relevant performance entry buffer, and name and type set to null.
</dd>

	<dt id="getentriesbytype-method">`getEntriesByType(type)@m</dt>
	<dd>
被呼出時には、此れに`関連する処理能~entry~buffer$を
( ~NULL, %type )
で`絞込んだ$結果を返すモノトスル。
◎
3.1.2 getEntriesByType() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to relevant performance entry buffer, name set to null, and type set to type.
</dd>

	<dt id="getentriesbyname-method">`getEntriesByName(name, type)@m</dt>
	<dd>
被呼出時には、此れに`関連する処理能~entry~buffer$を
( %name, %type （省略時は ~NULL） )
で`絞込んだ$結果を返すモノトスル。
◎
3.1.3 getEntriesByName() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to relevant performance entry buffer, name set to name, and type set to null if optional entryType is omitted, and type set to type otherwise.
</dd>
</dl>

		</section>
		<section id="the-performanceentry-interface">

<h3 title="The PerformanceEntry interface">3.2. `PerformanceEntry^I ~interface</h3>

<p>
`PerformanceEntry$I
~interfaceは、種々の計量による処理能~dataを~hostする。
◎
The PerformanceEntry interface hosts the performance data of various metrics.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceEntry@I {
    readonly attribute `DOMString$           `name$m;
    readonly attribute `DOMString$           `entryType$m;
    readonly attribute `DOMHighResTimeStamp$I `startTime$m;
    readonly attribute `DOMHighResTimeStamp$I `duration$m;
    [`Default$] `object$ `toJSON$m();
};
</pre>

<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
取得子は、此れの識別子を返すモノトスル。
この識別子は、一意になる必要はない。
◎
This attribute MUST return an identifier for this PerformanceEntry object. This identifier does not have to be unique.
</dd>

	<dt>`entryType@m</dt>
	<dd>
取得子は、此れで表現される
<a href="http://www.w3.org/wiki/Web_Performance/EntryType">~interface型</a>
を述べる `DOMString^I を返すモノトスル。
◎
This attribute MUST return the type of the interface represented by this PerformanceEntry object.
</dd>
	<dd class="note">
<p>
他の仕様で定義される `entryType^m 値の例には、次が挙げられる：
</p>

<ul ><li>`mark^l, `measure^l `USER-TIMING-2$r
</li><li>`navigation^l `NAVIGATION-TIMING-2$r
</li><li>`resource^l `RESOURCE-TIMING-2$r
</li><li>`longtask^l 【仕様は不明 — `paint^l `PAINT-TIMING$r ？】 
</li></ul>

◎
Note
◎
Example entryType values defined by other specifications include: "mark" and "measure" [USER-TIMING-2], "navigation" [NAVIGATION-TIMING-2], "resource" [RESOURCE-TIMING-2], and "longtask".
</dd>

	<dt>`startTime@m</dt>
	<dd>
取得子は、［
此れの処理能~計量にて最初に記録された時刻印
］を~~表現する `DOMHighResTimeStamp$I 値を返すモノトスル。
処理能~計量に開始-時刻の概念は適用されない場合、
0 を返すことにしてもヨイ。
◎
This attribute MUST return the time value of the first recorded timestamp of this performance metric. If the startTime concept doesn't apply, a performance metric may choose to return a startTime of 0.
</dd>

	<dt id="attributes">`duration@m</dt>
	<dd>
取得子は、［
此れに記録される~event全体の所要時間
］を~~表現する `DOMHighResTimeStamp$I 値を返すモノトスル。
これは概して，此れに［
最初に記録された時刻印
］から［
最後に記録された時刻印
］までの時間~差になる。
処理能~計量に所要時間の概念が適用されない場合、
0 を返すことにしてもヨイ。
◎
This attribute MUST return the time value of the duration of the entire event being recorded by this PerformanceEntry. Typically, this would be the time difference between the last recorded timestamp and the first recorded timestamp of this PerformanceEntry. If the duration concept doesn't apply, a performance metric may choose to return a duration of 0.
</dd>

	<dt>`toJSON()@m</dt>
	<dd>
~call時には、 `WebIDL$r による`既定の~toJSON演算$を走らす。
◎
When toJSON is called, run [WebIDL]'s default toJSON operation.
</dd>
</dl>

		</section>
		<section id="the-performanceobserver-interface">

<h3 title="The PerformanceObserver interface">3.3. `PerformanceObserver^I ~interface</h3>


<p>
`PerformanceObserver$I ~interfaceを利用すれば、`処理能時列線$を観測して，新たな処理能~計量（ `PerformanceEntry$I ~obj）が記録される度に通知させれる。
また，任意選択で、すでに~buffer済みの処理能~計量も通知させれる。
◎
The PerformanceObserver interface can be used to observe the Performance Timeline to be notified of new performance metrics as they are recorded, and optionally buffered performance metrics. 
</p>

<p>
`PerformanceObserver$I ~objは、単に
`処理能~観測器@
とも称される。
各 `処理能~観測器$には、次のものが結付けられる：
◎
Each PerformanceObserver has these associated concepts:
</p>

<dl>
	<dt>`~callback@</dt>
	<dd>
作成-時に設定される，
`PerformanceObserverCallback$I ~callback。
◎
A PerformanceObserverCallback set on creation.
</dd>
	<dt>`観測器~buffer@</dt>
	<dd>
`PerformanceEntryList$I ~obj。
初期~時は空とする。
◎
A PerformanceEntryList object called the observer buffer that is initially empty. 
</dd>

	<dt>`~options@</dt>
	<dd>
`PerformanceObserverInit$I 辞書, または ε （なし）。
初期~時は ε とする。
`登録-済み$である間は非 ε になる。
◎
↓↓</dd>
</dl>

<div class="p">
<p class="idl-def">
`PerformanceObserver(callback)@m
構築子の被呼出時には、次を走らすモノトスル：
</p>

<ol ><li>%観測器 ~LET 新たな `PerformanceObserver$I ~obj
</li><li>%観測器 の`~callback$ ~SET %callback
</li><li>~RET %観測器
</li></ol>

◎
The PerformanceObserver(callback) constructor must create a new PerformanceObserver object with PerformanceObserverCallback set to callback and then return it.
◎
A registered performance observer is a struct consisting of an observer (a PerformanceObserver object) and options (a PerformanceObserverInit dictionary).
</div>



<pre class="idl">
callback `PerformanceObserverCallback@I = void (
    `PerformanceObserverEntryList$I %entries,
    `PerformanceObserver$I %observer
);

[`Constructor$(`PerformanceObserverCallback$I %callback),
`Exposed$=(Window,Worker)]
interface `PerformanceObserver@I {
    void `observe$m(`PerformanceObserverInit$I %options);
    void `disconnect$m();
    `PerformanceEntryList$I `takeRecords$m();
};
</pre>

<p class="note">注記：
処理能~overheadを最小限に保つためには、~appは，関心のある~event種別のみを申込んで、処理能~dataを観測する必要がなくなったなら，観測器を
`disconnect()$m するべきである。
名前（ `name$m ）による絞込みは~supportされない
— それは，暗黙的にすべての~event種別を申込むことになり、可能0ではあるが，大量の~eventを生成することになるので。
<!-- discouraged -->
◎
Note
◎
To keep the performance overhead to minimum the application should only subscribe to event types that it is interested in, and disconnect the observer once it no longer needs to observe the performance data. Filtering by name is not supported, as it would implicitly require a subscription for all event types — this is possible, but discouraged, as it will generate a significant volume of events.
</p>

			<section id="observe-method">
<h4 title="observe() method">3.3.1. `observe(options)@m ~method</h4>

<p id="dfn-register-the-observer">
この~methodは、此れが`登録-済み$であれば 此れを更新し，そうでなければ此れを
`登録-済み$にする。
◎
The observe() method instructs the user agent to register the observer and＼
</p>

<p class="idl-def">
被呼出時には、次を走らすモノトスル：
◎
must run these steps:
</p>
<ol>
	<li>
%~entry種別~list ~LET %options の `entryTypes$d 連列
◎
Let entry types be options entryTypes sequence.
</li>
	<li>
%~entry種別~list から~supportされない `entryType$m 名はすべて除去する
⇒
~UAは、何かが除去された場合は，開発者に通知するべきである
— 例えば、除去された種別を~console警告に挙げるのが適切になるであろう。
◎
Remove all unsupported types from entry types. The user agent SHOULD notify developers if entry types is modified. For example, a console warning listing removed types might be appropriate.
</li>
	<li>
~IF［
%~entry種別~list は空である
］
⇒
~RET
⇒
~UAは、この手続きが中止されたことを開発者に通知するべきである
— 例えば、~console警告が適切になるであろう。
◎
If the resulting entry types sequence is an empty sequence, abort these steps. The user agent SHOULD notify developers when the steps are aborted to notify that registration has been aborted. For example, a console warning might be appropriate.
</li>
	<li>
%観測器~list ~LET 此れに`関連する大域~obj$の`処理能~観測器~list$
◎
↓</li>
	<li>
~IF［
此れ ~NIN %観測器~list
］
⇒
%観測器~list に此れを付加する
◎
If the list of registered performance observer objects of relevant global object contains a registered performance observer whose observer is the context object, replace its options, with options. 
◎
Otherwise, append a new registered performance observer object to the list of registered performance observer objects of relevant global object, with the context object as observer and options as the options. 
</li>
	<li>
此れの`~options$ ~SET %options
◎
↑</li>
	<li>
~IF［
%options の `buffered$d ~member ~NEQ ~T
］
⇒
~RET
◎
↓</li>
	<li>
%~entry種別~list 内の~EACH( %種別 ) に対し
⇒
此れに`関連する処理能~entry~buffer$を
( ~NULL, %種別 )
で`絞込んだ$結果 内の ~EACH( %~entry ) に対し
⇒
此れの`観測器~buffer$に %~entry を付加する
◎
If options' buffered flag is set, for each entry type in entry types sequence: 
◎
• Let entries be the PerformanceEntryList object returned by the 4.2 Filter buffer by name and type algorithm with buffer set to relevant performance entry buffer, name set to null and type set to entry type.
◎
• Append entries to the context object's observer buffer.
</li>
</ol>


				<section id="performanceobserverinit-dictionary">
<h5 title="PerformanceObserverInit dictionary">3.3.1.1. `PerformanceObserverInit^I 辞書</h5>

<pre class="idl">
dictionary `PerformanceObserverInit@I {
    required `sequence$&lt;`DOMString$&gt; `entryTypes$d;
    `boolean$ `buffered$d = false;
};
</pre>

<dl class="idl-def">
	<dt>`entryTypes@d</dt>
	<dd>
観測されることになる一連の~entry種別からなる~list。
この~listは、空であってはナラナイ。
 ~UAは、この~list内の種別のうち，自身が認識しないものは無視するモノトスル。
◎
A list of entry types to be observed. The list MUST NOT be empty and types not recognized by the user agent MUST be ignored. 
</dd>

	<dt>`buffered@d</dt>
	<dd>
~buffer済み~entryたちも`観測器~buffer$に~queueするべきかどうかを指示する。
◎
A flag to indicate whether buffered entries should be queued into observer's buffer.
</dd>
</dl>

				</section>
				<section id="performanceobserverentrylist-interface">
<h5 title="PerformanceObserverEntryList interface">3.3.1.2. `PerformanceObserverEntryList^I ~interface</h5>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `PerformanceObserverEntryList@I {
    `PerformanceEntryList$I `getEntries$mO();
    `PerformanceEntryList$I `getEntriesByType$mO(`DOMString$ %type);
    `PerformanceEntryList$I `getEntriesByName$mO(`DOMString$ %name, optional `DOMString$ %type);
};
</pre>

<dl class="idl-def">
	<dt id="getentries-method-0">`getEntries()@mO</dt>
	<dd>
被呼出時には、此れが表現する`観測器~buffer$を
( ~NULL, ~NULL )
で`絞込んだ$結果を返すモノトスル。
◎
3.3.3.1 getEntries() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to observer buffer, and name and type set to null.
</dd>

	<dt id="getentriesbytype-method-0">`getEntriesByType(type)@mO</dt>
	<dd>
被呼出時には、此れが表現する`観測器~buffer$を
( ~NULL, %type )
で`絞込んだ$結果を返すモノトスル。
◎
3.3.3.2 getEntriesByType() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to observer buffer, name set to null, and type set to type.
</dd>

	<dt id="getentriesbyname-method-0">`getEntriesByName(name, type)@mO</dt>
	<dd>
被呼出時には、此れが表現する`観測器~buffer$を
( %name, %type （省略時は ~NULL） )
で`絞込んだ$結果を返すモノトスル。
◎
3.3.3.3 getEntriesByName() method
◎
Returns a PerformanceEntryList object returned by 4.2 Filter buffer by name and type algorithm with buffer set to observer buffer, name set to name, and type set to null if optional entryType is omitted, and type set to type otherwise.
</dd>
</dl>

				</section>
			</section>
			<section id="takerecords-method">
<h4 title="takeRecords() method">3.3.2. `takeRecords()@m ~method</h4>

<div class="p">
<p class="idl-def">
被呼出時には、次を走らすモノトスル：
</p>

<ol>
	<li>
%複製 ~LET 此れの`観測器~buffer$の複製
</li>
	<li>
此れの`観測器~buffer$を空にする
</li>
	<li>
~RET %複製
</li>
</ol>

◎
The takeRecords() method must return a copy of the context object's observer buffer, and also empty context object's observer buffer.
</div>


			</section>
			<section id="disconnect-method">
<h4 title="disconnect() method">3.3.3. `disconnect()@m ~method</h4>

<div class="p">
<p class="idl-def">
被呼出時には、次を走らすモノトスル：
</p>

<ol>
	<li>
此れに`関連する大域~obj$の`処理能~観測器~list$から，此れを除去する
</li>
	<li>
此れの`~options$ ~LET ε
</li>
	<li>
此れの`観測器~buffer$を空にする
</li>
</ol>

◎
The disconnect() method must remove the context object from the list of registered performance observer objects of relevant global object, and also empty context object's observer buffer.
</div>


			</section>
		</section>
	</section>
	<section id="processing">
<h2 title="Processing">4. 処理</h2>

		<section id="queue-a-performanceentry">
<h3 title="Queue a PerformanceEntry">4.1. `PerformanceEntry^I を~queueする</h3>

<div class="p">
<p>
`処理能~entryを~queueする@
ときは、所与の
⇒＃
%新たな~entry （ `PerformanceEntry$I ~obj）,
%処理能~entry~bufferに追加する~flag（省略時は ~OFF ）
◎終
に対し，次を走らす：
</p>

◎
To queue a PerformanceEntry (new entry) with an optional add to performance entry buffer flag, which is unset by default, run these steps:
</div>

<ol>
	<li>
%大域~obj ~LET `関連する大域~obj$
【どの~objに`関連する大域~obj$かは、この~algoを呼出した文脈に依存する。】
◎
↓</li>
	<li>
%大域~obj の`処理能~観測器~list$内の ~EACH ( `処理能~観測器$ %観測器 ) に対し
⇒
~IF［
%新たな~entry の `entryType$m 値 ~IN
%観測器 の`~options$の `entryTypes^m
］
⇒
%観測器 の`観測器~buffer$に %新たな~entry を付加する
◎
Let interested observers be an initially empty set of PerformanceObserver objects.
◎
For each registered performance observer (observer):
◎
• If observer's PerformanceObserverInit entryTypes includes new entry’s entryType value, append observer to interested observers.
◎
For each observer in interested observers:
◎
• Append new entry to observer buffer.
<!-- 
原文の記述は無為に冗長なので、この段では等価な結果を得るものに変換して記述している。
-->
</li>
	<li>
~IF［
%処理能~entry~bufferに追加する~flag ~EQ ~ON
］
⇒
%新たな~entry を %大域~obj の`処理能~entry~buffer$に追加する
◎
If the add to performance entry buffer flag is set, add new entry to the performance entry buffer.
</li>
	<li>
~IF［
%大域~obj の`処理能~観測器~task~queue済み~flag$ ~EQ ~ON
］
⇒
~RET
◎
If the performance observer task queued flag is set, terminate these steps.
</li>
	<li>
%大域~obj の`処理能~観測器~task~queue済み~flag$ ~SET ~ON
◎
Set performance observer task queued flag.
</li>
	<li>
<p>
次の下位手続きを走らす`~taskを~queueする$
— この~task用の`~task源$は、
`処理能~時列線~task源@
とする：
◎
Queue a task that consists of running the following substeps. The task source for the queued task is the performance timeline task source.
</p>
		<ol>
			<li>
%大域~obj の`処理能~観測器~task~queue済み~flag$ ~SET ~OFF
◎
Unset performance observer task queued flag.
</li>
			<li>
%通知-~list ~LET ［
%大域~obj の`処理能~観測器~list$
］の複製
<!-- ＊
複製をとるのは、後段で~callされる~callbackによる影響を避けるため
-->
◎
Let notify list be a copy of relevant global object's list of registered performance observer objects.
</li>
			<li>
<p>
%通知-~list 内の~EACH ( `処理能~観測器$ %観測器 ) に対し：
◎
For each PerformanceObserver object po in notify list, run these steps:
</p>
				<ol>
					<li>
~IF［
%観測器 の`観測器~buffer$は空である
］
⇒
~CONTINUE
◎
↓</li>
					<li>
%~entryたち ~LET %観測器 の`観測器~buffer$の複製
◎
Let entries be a copy of po’s observer buffer.
</li>
					<li>
%観測器 の`観測器~buffer$を空にする
◎
Empty po’s observer buffer.
</li>
					<li>
<p>
次を渡して %観測器 の`~callback$を~callする
⇒＃
引数~list « %~entryたち, %観測器 »,
`~callback this 値$ %観測器
</p>

<p>
この段にて例外が`投出-$された場合は、その`例外を報告する$。
</p>

◎
If entries is non-empty, call po’s callback with entries as first argument and po as the second argument and callback this value. If this throws an exception, report the exception.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<p>
`処理能~時列線~task源$用の`~task~queue$は、低優先度の~queueである
— ~UAは、処理能~監視~codeの影響0を最小限に抑えるため，可能0なら遊休中に処理するべきである。
◎
The performance timeline task queue is a low priority queue that, if possible, should be processed by the user agent during idle periods to minimize impact of performance monitoring code.
</p>

		</section>
		<section id="filter-buffer-by-name-and-type">
<h3 title="Filter buffer by name and type">4.2. ~bufferを ( %名前, %種別 ) で絞込む</h3>

<div class="p">
<p>
この~algoは、所与の：
</p>

<ul><li>%~buffer （ `PerformanceEntry$I ~objの~list）
</li><li>%名前 （文字列, 省略時は ~NULL）
</li><li>%種別 （文字列, 省略時は ~NULL）
</li></ul>
<p>
に対し，次を走らせた結果の `PerformanceEntryList$I ~objを返す：
</p>

<ol>
	<li>
%~list ~LET 下に与える下位手続きを走らせた結果
</li>
	<li>
`~entry~obj~list@V
~LET %~list を その各~objの `startTime$m の時系列順に整列した結果の~list
— `startTime$m が同じ~objどうしの順序は指定されない
</li>
	<li>
~RET %~list を包含する新たな `PerformanceEntryList$I ~obj
</li>
</ol>

<p>
上で利用される下位手続きは、次を走らす：
</p>

◎
Given a buffer and optional name and type string values this algorithm returns a PerformanceEntryList object that contains a list of PerformanceEntry objects sorted in chronological order with respect to startTime; objects with the same startTime have unspecified ordering.
</div>

<ol>
	<li>
%~list ~LET 空~list
◎
Let the list of entry objects be the empty PerformanceEntryList.
</li>
	<li>
<p>
%~buffer 内の ~EACH ( `PerformanceEntry$I ~obj
`~entry~obj@V
) に対し：
◎
For each PerformanceEntry object (entryObject) in the buffer, in chronological order with respect to startTime:
</p>

		<ol>
			<li>
~IF［
%名前 ~NIN { ~NULL,  `~entry~obj$V の `name$m 属性~値 )
］
⇒
~CONTINUE
◎
If name is not null and entryObject's name attribute does not match name in a case-sensitive manner, go to next entryObject.
</li>
			<li>
~IF［
%種別 ~NEQ { ~NULL,  `~entry~obj$V の `entryType$m 属性~値 }
］
⇒
~CONTINUE
◎
If type is not null and entryObject's type attribute does not match type in a case-sensitive manner, go to next entryObject.
</li>
			<li>
%~list に `~entry~obj$V を追加する
◎
Add entryObject to the list of entry objects.
</li>
  </ol>
  </li>
  <li>
~RET %~list
◎
Return the list of entry objects.
</li>
</ol>

		</section>
	</section>
	<section id="privacy-security">

<h3 title="Privacy and Security">5. ~privacyと保安</h3>

<p>
この仕様は、
`HR-TIME-2$r に定義された `Performance$I ~interfaceを拡張し，`処理能時列線$［
に~entryを~queueする／から~entryを取得する
］ための~methodを供する。
高分解能の計時~情報を公開することによる［
~privacy／保安
］上の考慮点については、
`HR-TIME-2$r を参照されたし。
◎
This specification extends the Performance interface defined by [HR-TIME-2] and provides methods to queue and retrieve entries from the performance timeline. Please refer to [HR-TIME-2] for privacy and security considerations of exposing high-resoluting timing information.
</p>
	</section>

</main></div><!-- id="MAIN"／MAIN0 -->

	<section class="appendix">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様に協力された次の方々に：
</p>

<div lang="en-x-a0">
Thanks to Arvind Jain, Boris Zbarsky, Jatinder Mann, Nat Duca, Philippe Le Hegaret, Ryosuke Niwa, Shubhie Panicker, Todd Reifsteck, Yoav Weiss, and Zhiheng Wang, for their contributions to this work.
</div>
	</section>

