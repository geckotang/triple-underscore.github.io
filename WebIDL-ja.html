<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Web IDL （第２版 — 日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<!--%script -->

<script>
var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://heycam.github.io/webidl/',
		spec_status: 'ED',
		main: 'MAIN',
		fill_text_link: '#_versions > dd, #references dd',
		ref_id_prefix: 'ref-',
		alt_refs: 'references'
	};

	if(expanded) return options;

// 文法ブロック生成
	var grammar_tables = buildGrammerTables();

	source_data = {
		html: E('MAIN').innerHTML,
		refsSec: E('references'),
		link_map: Util.getMapping('_link_map'),
		ext_map: Util.getMapping('_ext_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:英語寄り:漢字主体:カナ主体',
		grammar_tables: grammar_tables,
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);


/* checked for 2016-11-07 spec.

	Util.del_j();
	repeat('pre span[title]', function(e){
		e.textContent = e.title;//.replace(/^/gm, '// ');
	});
	repeat('h2, h3, h4, h5', function(e){
		var t = e.title;
		if(!t) return;
		e.textContent = e.textContent.replace(/\. .+/, '. ' + t);
	});
	repeat('dl.grammar > dt', function(e){
		e.insertBefore(C('br'), e.firstChild);
		e.appendChild(document.createTextNode(' ::'));
	});
	repeat('.algorithm li', function(e){
		e.insertBefore(C('br'), e.firstChild);
	});

*/

	return options;

}

function expand(mapping1){
	E('MAIN').innerHTML = Util.replaceWords1(
		createHTML(),
		mapping1
	);

	populate();
}


/*内容変換生成*/

function createHTML(){
	var source = source_data.html;
	var link_map = source_data.link_map;
	var ext_map = source_data.ext_map;

	return source.replace(
		/◎[^<◎]*|%([\w\-]+)|`(.*?)([$@\^]\w*)/g,
		create_html
	);

function create_html(s, key1, key, indicator){
	if(key1){
		return '<var>' + key1 + '</var>';
	}
	if(!key){
		return '<span lang="en">' + s.slice(1).trim() + '</span>';
	}
	switch(indicator){
	case '^':
		return ext_map[key] || '＊';
	case '@':
		return '<dfn id="' + link_map[key].slice(1) + '">' + key + '</dfn>';
	case '$':
		return '<a href="' + link_map[key] + '">' + key + '</a>';
	case '$g': // 非終端記号／生成規則
		return '<a class="g" href="#prod-' + key + '">' + key + '</a>';
	case '^g': // 非終端記号／生成規則
		return '<span class="g" href="#prod-' + key + '">' + key + '</span>';
	case '^sym': // 終端記号
		return '<span class="sym">' + key + '</span>';
	case '^char': // char
		return '<span class="char">' + key + '</span>';
	case '^sup': // sup
		return '<sup>' + key + '</sup>';
	case '^c': // code
		return '<code>' + key + '</code>';
	case '^i': // i syntax変数
		return '<i>' + key + '</i>';
	case '^C': // 仮想定数
		return '<i class="const">' + key + '</i>';
	case '^mk': // syntax強調
		return '<mark>' + key + '</mark>';
	case '^l': // literal
		return '"<code>' + key + '</code>"';
	case '@E': // error 名
		return '"<code id="' + key.toLowerCase() + '">' + key + '</code>"';
	case '@eE': // ES error 名
		return '"<code id="exceptiondef-' + key.toLowerCase() + '">' + key + '</code>"';
	case '$T': // IDL 型
		return '<a class="idltype" href="#idl-' + key.replace(/ /g, '-') + '">' + key + '</a>';
	case '^T': // IDL 型
		return '<span class="idltype">' + key + '</span>';
	case '@T': // IDL 型（定義）
		return '<dfn class="idltype" id="idl-' + key.replace(/ /g, '-') + '">' + key + '</dfn>';
	case '^t': // ES 型
		return '<span class="estype">' + key + '</span>';
	case '^V': // IDL 値
		return '<span class="idlvalue">' + key + '</span>';
	case '^v': // ES 値
		return '<span class="esvalue">' + key + '</span>';
	case '$A': // ES 抽象演算
		return '<a class="abstract" href="~TC39#sec-' + key.toLowerCase() + '">' + key + '</a>';
	case '^M': // IDL メンバ
		return '<span class="idlmember">' + key + '</span>';
	case '$x': // 拡張属性
		return '<a class="xattr" href="#' + key + '">[' + key + ']</a>';
	case '^x': // 拡張属性
		return '<span class="xattr">[' + key + ']</span>';
	case '$r': // 文献
		return '<a href="#ref-' + key + '">[' + key + ']</a>';
	case '$sec': // 節
		return '<a class="sec" href="#'+ key +'" >' + ( link_map[ '#' + key] || '＊') + '</a>';
	case '^es': // ES 内部 property/method/slot
		return '<span class="prop">[[' + key + ']]</span>';
	case '$esI': // ES intrinsic/prototype object
		return '<a href="' + link_map['esI.' + key] + '"><span class="es-intrinsic">%' + key + '%</span></a>';
	case '$esS': // ES well-known symbols
		return '<a href="~TC39#sec-well-known-symbols"><span class="prop">@@' + key + '</span></a>';


	case '^var': // 変数
		return '<var>' + key + '</var>';
/*
	case '^m': // ES member,
		return '<span class="esmember">' + key + '</span>';
	case '^note': // 訳注
		return '<span class="trans-note">【' + key + '】</span>';
	case '^esa': // ES 抽象演算
		return '<span class="esabs">' + key + '</span>';
	case '^cp': // 複製の place holder 
		return '<a title="cp-' + key + '"></a>';
*/

	case '^desc': // ES property descriptor
		return desc(key);

	default:
		return s;
	}
}

function desc(id){// ES プロパティ記述子
	return (
		'<span class="descriptor">{\u00A0' +
		'[[Writable]]: ' + TFmap(id[0]) +
		', [[Enumerable]]: ' + TFmap(id[1]) +
		', [[Configurable]]: ' + TFmap(id[2]) +
		( (id.length > 3) ?
			', [[Value]]:' + TFmap(id.slice(4)) : ''
		) + 
		'\u00A0}</span>' // 00A0 &nbsp;
	);
	function TFmap(c){
		switch(c) {
		case 'T':
			return '<span class="esvalue">true</span>';
		case 'F':
			return '<span class="esvalue">false</span>';
		default:
			return '<var>' + c + '</var>';
		}
	}
}

}


function populate(){

// 内容複製
	duplicate();
	
	function duplicate(){
		var visited = Object.create(null);
		var iter = document.createNodeIterator(
			E('MAIN0'), NodeFilter.SHOW_COMMENT, null, null
		);
		var node;
		while(node = iter.nextNode()){
			var id = node.data;
			if(id.slice(0, 3) !== 'cp-'){
				continue;
			}
			var e = visited[id] || E(id);
			if(!e) continue;
//			if(!e) console.log(id);
			if(!visited[id]){
				e.removeAttribute('id');
//				e.style.outline = 'solid green 1px'
				visited[id] = e;
			}
			e = e.cloneNode(true);
//			e.style.outline = 'dashed green 1px'
			node.parentNode.replaceChild(e, node);
		}
	}


// 文法ブロック
	var G = source_data.grammar_tables;
	var lhs = G.dt;
	var rhs = G.dd;

	repeat('div.grammar', function(div){
		var dl = C('dl');
		dl.className = 'grammar';
		div.textContent.match(/\w+/g).forEach(function(name){
			if(!(name in lhs)) return;// throw name;
			dl.appendChild(lhs[name].cloneNode(true));
			dl.appendChild(rhs[name].cloneNode(true));
		});
		div.parentNode.replaceChild(dl, div);
	});

	var grammar_table = E('_p-grammar-table');
	grammar_table.parentNode.replaceChild(G.dom, grammar_table);
}



// 文法ブロック生成
// 逆参照機能があるので、文法一覧 → 本文リンクは省略
function buildGrammerTables(){
//
	var g_data = Util.textData('_d-grammar-table');
	var g_table = C('dl');

	var lhs = Object.create(null);
	var rhs = Object.create(null);
	var index = 0;//＊

	g_table.className = 'grammar';
	g_table.innerHTML = '<dd>' + g_data
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/\s(?=[A-Za-z])/g, '$&＠')
		.replace(/"([ -~]+?)"/g, '<span class="sym">$1</span>')
		.replace(/\s*●(\w+)\s*/g, function(t, name){
			lhs[name] = index++;
			return ( '</dd><dt>＠' + name + '</dt><dd>' );
		})
		.replace(/＠(\w+)/g, ' <a class="g" href="#prod-$1">$1</a>')
		+ '</dd>\n'
	;

	g_table.removeChild(g_table.firstChild);

	var dts = g_table.getElementsByTagName('dt');
	var span = C('span');
	span.className = 'g';

	for(var name in lhs){
		var dt = dts.item(lhs[name]);
		rhs[name] = dt.nextElementSibling;
		lhs[name] = dt.cloneNode(true);

		dt.id = 'prod-' + name;
		var s = span.cloneNode(false);
		s.textContent = name;
		dt.replaceChild(s, dt.lastChild);
	}

	return {dom: g_table, dt: lhs, dd: rhs};///
}

</script>


<script type="text/plain" id="_original_id_map">
ol-callable:
ol-optionality-list:
ol-type-list:
dfn-variadic-argument:
dfn-normal-location:
dfn-consequential0:
dfn-const-tokens:
	dfn-element-type:
dfn-exception-thrown:
_conventions:
	prop-accessors:
	_es-conversion-for-idl-integer_:
idl-integers:
idl-floats:
	dfn-get-buffer-source-reference-or-copy:dfn-get-buffer-source-reference

dfn-invoke-indexed-setter:invoke-indexed-setter
dfn-invoke-named-setter:invoke-named-setter
dfn-function-like:

	idl-long:dom-long
	idl-unsigned-long:dom-unsignedlong
	idl-long-long:dom-longlong
	idl-unsigned-long-long:dom-unsignedlonglong
	idl-float:dom-float
	idl-unrestricted-float:dom-unrestrictedfloat
	idl-double:dom-double
	idl-unrestricted-double:dom-unrestricteddouble
	idl-DOMString:dom-DOMString
	idl-ByteString:dom-ByteString
	idl-USVString:dom-USVString
	idl-object:dom-object
	idl-sequence:dom-sequence
	idl-promise:dom-promise
	idl-Error:dom-Error
	idl-frozen-array:dom-FrozenArray

</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
THEN:⇒<br>&nbsp;&nbsp;&nbsp;
THROW:<a href="#ecmascript-throw"><b>THROW</b></a>
SLASH:<code class="sym">/</code>
HTMLwindowproxy:HTML-windowproxy-ja.html

REPLACEMENT:<span class="char">U+FFFD REPLACEMENT CHARACTER</span>
record_KV:<span class="idltype">record&lt;<var>K</var>, <var>V</var>&gt;</span>

DOMException:<span class="idltype">DOMException</span> 
promise_T:<span class="idltype">Promise&lt;<var>T</var>&gt;</span>
sequence_T:<span class="idltype">sequence&lt;<var>T</var>&gt;</span>
FrozenArray_T:<span class="idltype">FrozenArray&lt;<var>T</var>&gt;</span>

varT:<var>T</var>
iterator0:<span class="prop">@@iterator</span>
Promise_resolve:<span class="es-intrinsic">%Promise_resolve%</span>
PlatformObjectGetOwnProperty:<span class="abstract">PlatformObjectGetOwnProperty</span>
</script>

<!--%語 -->
<script type="text/plain" id="words_table">
IDL:
JS:ECMAScript
DOMException:
名前:name:~
名:name:~
値:value:~
型:type:~
	種別:type:~
true:
false:
ifc:interface::::インタフェース
obj:object::::オブジェクト
prop:property::::プロパティ
data-prop:data property::::データプロパティ
meth:method::::メソッド
内部:internal:~
algo:algorithm::アルゴリズム
mapping:
辞書:dictionary::~::ディクショナリ
record:::::レコード
名前空間:namespace::~
列挙:enumeration::~
列挙不可:unenumerable::~
列挙可能:enumerable::~
列挙-:enumerate::~
連列:sequence::~::シーケンス
	sequence:::並び
原型:prototype::::プロトタイプ
原型鎖:prototype chain::::プロトタイプチェイン
tok:token:::トークン

optional:::オプション
随意:optional::::オプショナル
	随意の:optional::::オプショナル
	随意~引数
省略可否:optionality::~
省略可:optional::~
必須:required::~
	必須:non-optional
引数:argument:~
引数個数:argument count:~
可変個:variadic::~
	可変個の引数をとる:variadic
	可変個
	可変個~引数:variadic argument:
固定長:fixed length:~

判別-:distinguish:~
判別可能:distinguishable:~
判別引数:distinguishing argument:~

mb:member:::メンバ
文字列:string::~
scalar:::::スカラー
演算:operation::~::オペレーション
演算-:operate:~
関数:function::~
例外:exception::~
単純例外:simple exception::~
変換-:convert::~
変換:conversion::~
属性:attribute::~::アトリビュート
拡張属性:extended attribute::~::拡張アトリビュート

定義-:define:~
定義:definition:~
未定義:undefined:~
	〜により定義される:-defined
再定義-:redefine:~
定義済みの:predefined:~

返値:return value:return 値:返り値
返値型:return type:return 型:返り値型
返す:return する:~
返る:return する:~
返され:return され:~
返さな:return しな:~
返し:return し:~
返せる:return できる:~
	int_t:integer 型::整数型
固有型:specific type:specific 型:~
内縁:inner::~::インナー
共用体:union:::~:ユニオン
promise:
凍結-:freeze::~
凍結:frozen::~
実数:numeric::~
整数:integer::~
無符号:unsigned:::符号なし
有符号:signed:::符号あり

配列:array:::~
有型:typed:~
既定:default:::~:デフォルト
既定の:default:::~:デフォルト
呼戻:callback::::コールバック
呼戻子:callback::::コールバック
index:::::インデックス
indexing:::index アクセス::インデクシング
有index:indexed::有 index::有インデックス
有名:named::~
keyword::::キーワード
pdesc:Property Descriptor::property 記述子::プロパティデスクリプタ
	descriptor::::記述子:デスクリプタ
field::::フィールド
instance::::インスタンス
host::::ホスト
nullable:
null:
view:::::ビュー
class:::::クラス
	可 null
多重定義:overload::~::オーバーロード
有効:effective:~
	有効~多重定義~集合:effective overload set
継承-:inherit::~
継承:inheritance::~
継承ing:inheriting::継承
非継承:non-inherited::~
	辞書継承:inherit::~
被継承:inherited::継承
継承階層:inheritance hierarchy:~
UA:user agent::UA::ユーザエージェント
利用者:user:::~:ユーザ
platform:::::プラットフォーム
予約済み:reserved:~
予約済みの:reserved:~
識別子:identifier::~
構築子:constructor:::~:コンストラクタ
取得子:getter:::~:ゲッタ
設定子:setter:::~:セッタ
作成子:creator:::~:クリエータ
削除子:deleter:::~:デリータ
文字列化子:stringifier:::~
文字列化-:stringify:::~
文字列化:stringification:::~
旧来呼出子:legacy caller:::~
旧来:legacy:::~
旧来の:legacy:::~
直列化-:serialize:::~:シリアライズ
直列化子:serializer:::~:シリアライザ
直列化:serialization:::~:シリアル化
	シリアライゼーション
直列化形の:serialized:::~:シリアル化された
直列化形:serialized form:::~:シリアル化形
	直列化済み
直列化可能:serializable:::~:シリアライズ可能
map:::::マップ
set:::::セット
slot:::::スロット
buffer:::::バッファ
source:::::ソース
maplike:::map 似::マップ似
setlike:::set 似::セット似
反復子:iterator:::~:イテレータ
反復-:iterate:::~:イテレート
反復:iteration:::~:イテレーション
反復値:iterated value:iterated 値::~:イテレート値
可反復:iterable:::~:イテラブル

状態:state:~
target:

投出:throw::~
定数:constant::~::コンスタント
正則:regular:::~:レギュラー
静的:static:::~:スタティック
特殊:special:::~:スペシャル
有限:finite::~
単精度:single-precision::~
倍精度:double-precision::~
浮動小数点:floating point::~
浮動小数点数:floating point number::~
片:fragment:~:::フラグメント
部分的:partial::~::パーシャル
主:primary::~:::プライマリ
中途完了:abrupt completion::~
正常完了:normal completion::~

符号単位:code unit::~::コードユニット
被support:supported::被 support:被サポート

support::::サポート
message::::メッセージ
読専:readonly:::~
	読み取り専用
	//EN dash
可書:read–write:::読み書き可能
catch:::::キャッチ
primitive:::::プリミティブ
bit::::ビット
callable:::::コーラブル
call:::::コール
真偽:boolean::~::ブーリアン
自前の:own::~
native:::::ネイティブ
flag:::::フラグ
大域:global:::~:グローバル
環境:environment:~
大域環境:global environment:global 環境:~::グローバル環境
形:form::~::フォーム
key:::::キー
value:::::値
	//EN dash
key-value:key–value pair::key–value ペア::{キー：値} ペア

言語束縛:language binding:言語 binding:~::言語バインディング
pair::::ペア
data::::データ
literal::::リテラル
escape::::エスケープ
追補:supplemental::~::サプルメンタル
帰結:consequential::~::コンシーケンシャル
平坦化-:flat 化::~
平坦化:flattened::~
公開-:expose::~
公開:exposure::~
変更:change::~
改変-:modify::~
改変:modifications:~
偽装不可:unforgeable::~::アンフォージャブル
参照:reference:~
accessor:::アクセサ
access:::アクセス
list:::リスト
block:::ブロック
code:::コード

error:::エラー
script:::スクリプト
stack:::スタック
trace:::トレース
snapshot:::スナップショット
scope:::スコープ
octet:::オクテット

incumbent:
exotic:
proxy:
bind:
Realm:
realm:
configurable:
typedef:
valuetype:
completion:

保安:security::~::セキュリティ
保安的:secure::~::セキュア
	保安的でない:insecure
符号位置:code point::~::コードポイント
注釈文:prose:~:::プローズ
隠蔽:shadow:~
言語:language:~
合致:match:~:::マッチ
日付時刻:time:~
時刻:time:~
変数:variable:~
文字:character:~
複製:copy:~
組込み:built-in:組み込み:::ビルトイン
無限:infinity:~
pattern::::パタン
entry::::エントリ
	項目／一員
識別-:identify:~
宣言:declaration:~
宣言-:declare:~
長さ:length:~
writable::書き込み可能
妥当:valid:~
	invalid
解決:resolution:~:::レゾリューション
解決-:resolve:~:::リゾルブ
実装:implementation:~
実装-:implement:~
実装者:implementor:~
伝播-:propagate:~
適合:conforming:~
適合性:conformance:~
test-suite:test suite:::テスト一式:テストスイート
初期:initial:~
要素:element:~
範囲:range:~
表現-:represent:~
	表現:representation:~
文脈:context::~
評価-:evaluate:~
等価:equivalent:~
構文:syntax:~:::シンタックス
特徴:characteristics:~

文法:grammar:~:::グラマー
記号:symbol:~:::シンボル
symbol:
終端:terminal:~:::ターミナル
構文解析:parse:~:::パース
構文解析器:parser:~:::パーサ
引用符:quotes:~:::クォート
	引用符で括られ:quote され:~
正規表現:regular expression:~
生成規則:production:~:::プロダクション
ゼロ:zero::~
strict-mode:strict mode
byte:::バイト
loop:::ループ
tuple::::タプル
surrogate::::サロゲート
一意:unique:~
式:expression:~
	:::エクスプレッション
size::::サイズ
検索:lookup::~::ルックアップ
注釈付きの:annotated::~
注釈付き:annotated::~
implements:
worker::::ワーカ

内在的:intrinsic::~
新たな:new:~
既存の:existing:~
既存のも:existing のも:~
空:empty:~
指定-:specify:~
所与の:given:与えられた

設定群:settings:~

	●動詞
充足-:fulfill::~
却下-:reject::~
却下:rejection::~
事由:reason::~
決着-:settle::~
未初期化の:uninitialized:~
初期化-:initialize:~
代入-:assign:~
代入:assignment:~
代入ing:assigning:代入
決定-:determine:~
設定-:set:~
設定:setting:~
取得-:get:~
取得:getting:~
取得0-:retrieve:取得
取得0:retrieving:取得
取得1:retrieval:取得

削除-:delete:~
削除:deletion:~
作成-:create:~
作成:creation:~
除去-:remove:~
付加-:append:~
追加-:add:~
追加の:additional:~
	追加で
試み:attempt:~
試みて:attempt して:~
試みる:attempt する:~
試みた:attempt した:~
試みさ:attempt さ:~
試みら:attempt さ:~
走らせ:run し:~
走らさ:run さ:~
走らす:run する:~

呼出す:invoke する:呼び出す
呼出せる:invoke できる:呼び出せる
呼出され:invoke され:呼び出され
呼出して:invoke して:呼び出して
呼出した:invoke した:呼び出した
呼出し:invoking:呼び出し
呼出:invocation:呼び出し
被呼出時:被 invoke 時:~
	when invoked
渡され:pass され:~
渡す:pass する:~
渡し:pass し:~
渡して:pass して:~
渡した:pass した:~
渡さず:pass せず:~
渡せる:pass できる:~
値渡し:passed by value:~

	受け~~渡-:send and receive
	~~渡しで:で pass by され
	渡り
結付けら:associate さ:結び付けら
	結付け:association:結び付け
	結付けて:associate して:結び付けて
結付ける:associate する:結び付ける
現れる:appear する:~
現れ:appear し:~
出現:appearing:~
扱う:treat する:~
扱わな:treat しな:~
扱われ:treat され:~
	扱い:treatment:~
	扱え:treat でき:~
	扱っ:treat し:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
取扱われ:handle され:取り扱われ
取扱える:handle できる:取り扱える
利用:use:~
	用いる:use する:~
	用いら:use さ:~
	用いて:use して:~
存在-:exist:~
	存在t-:present:存在
在する:present する:在る
存在t:presence:存在
不在:not present:~

置換-:replace:~
言明-:state:~
制御:control:~
構築-:construct:~
構築:construction:~
構成子:constructs:~
連結:concatenation:~
連結-:concatenate:~
無視-:ignore:~
予期-:expect:~
期待-:expect:~
指示-:indicate:~
提供-:provide:~
束縛-:bind:~
解釈-:interpret:~
解釈:interpretation:~
付随-:accompany:~
符号化-:encode:~:::エンコード
符号化:encoded:~:::エンコード化
符号化方式:encoding:~
影響-:affect:~
反映-:reflect:~
制約-:restrict:~
制約:restriction:~
拘束:constraint:~
更新:update:~
適用-:apply:~
	適用し得る:applicable
検査:check:~:::チェック
要求-:require:~
推奨-:recommend:~
許容-:allow:~
上書き:override:~
依存-:depend:~
依拠-:rely:~
受容:accept:~
破棄-:discard:~
失敗-:fail:~
分割-:split:~
分離-:separate:~
区切る:separate する:~
区切らな:separate しな:~
区切られ:separate され:~
区切りの:-separated:~
延期-:defer:~
波及-:influence:~
省略-:omit:~
	~~省略:missing:~
正準化-:canonicalize:~
強制:coerce:~
選定-:select:~
選定:selection:~
格納-:store:~
格納済み:stored:~
修正-:fix:~
記述:description:~
記述-:describe:~
述べる:describe する:~
述べら:describe さ:~
述べ:describe し:~
保持-:hold:~
保有-:keep:~
競合-:conflict:~
改称-:rename:~
命名:naming:~
命名-:name:~
挙動:behavior:ふるまい
挙動する:behave する:ふるまう
挙動し:behave し:ふるまわ
挙動させ:behave させ:ふるまわせ
照会-:query:::~:クエリ
成功-:succeed:~
登録-:register:~
完了-:complete:~
完了:completion:~
完全:complete:~
拡張-:extend:~
	拡張-可能:extensible
拡張:extension:~
拡張性:extensibility:~
変化-:change:~
変更点:changes:~
切離す:detach する::切り離す
切離され:detach され::切り離され
観測-:observe:~
意図-:intend:~
意図:intention:~
見出され:find され:~
明確化-:clarify:~
明確性:clarity:~
転送-:forward:~
機能-:work:~
働く:work する:~
準備-:prepare:~


代理:proxy:~
抽象:abstract:~
抽象的:abstract:~
抽象演算:abstract operation:~
仮数:significand:~
偶数:even:~

	●仕様
Web:
API:
特色機能:feature::~::フィーチャ
仕様:spec:~
策定者:author:~
作者:author:~
省略符号:ellipsis:~
特有:-specific:ごとに固有
特有の:specific な:固有の
固有の:specific:~
要件:requirements:~
文書:document:~
不許可に:disallow:~
暗黙的:implicit:~
明示的:explicit:~
認識-:recognize:~
付録:Appendix:~
標準:standard:~
非標準:non-standard:~
相互運用性:interoperability:~
level:::レベル
互換性:compatibility:~
技術報告:technical reports:~
独立:independent:~
通用する:agnostic な:~
将来:future:~
mailing-list:mailing list::メーリングリスト
bug:::バグ
	リンク:link:~
規定:normative:~
参考:informative:~
詳細:details:~
意味論:semantics:~:::セマンティクス
判定基準:criteria:~
記法:notation:~
手続き:steps:~
下位手続き:substeps:~
	手続き:action
系列:variety:~
便宜性:facility:~
普通の:ordinary:~
実質的:effective:~
共通の:common:~
共通する:common な:~
共通的に:common に:よく
規約:convention:~
保証:guarantee:~
多義性:ambiguity:~
歴史的:historical:~
状況:situation:~
要請:request:~
一般的な:general:~
一般:general:~
一般化-:generalize:~
心配:concern:~
制限:limitation:~
整合性:consistency:~
機能性:functionality:~
解禁-:lift:~
設計:design:~
最適化:optimization:~
実際の:actual:~
	論じら:discuss さ:~
	説明-:explain
	説明:explanation／description:~
査読者:reviewer:~
特定0の:particular:ある特定の
概して:typical に:~
	誤った:wrong
勧める:suggest する:~
一貫する:consistent になる:~
遂行-:perform:~
能:ability:機能
通常通り:as normal に:通常どおり
仕方:way:~
用語:term:~
保全-:preserve:~
決断:decision:~
不用意:accidental:~
version:::バージョン
style::::スタイル
設計pattern:design pattern:::デザインパターン
方式:manner:~
	~~方式:style
直接的:direct:~
間接的:indirect:~
暗黙の:implied:~
形式的:formal:~
略記形:bare form:~
仕組み:mechanism:~
	策定中:underspecified:~
見なさ:consider さ:~
考える:consider する:~
	考慮に入れ:consider
見做す:assume する:~
見做さ:assume さ:~
計画-:plan
有用:useful:~
変種:variant:~
発行-:publish:~
相互運用可能:interoperable:~
実施:practice:~
確保-:ensure:~
	指針:guide
	よく見れば:The astute reader may
	気付く:notice
	よく似ている:very similar
	少しばかり／もう少し:slightly

	●未分類
Unicode:
変異不可の:immutable な::~
singleton:
梱包-:package:~
	最小:shortest
	series
基数:base:~
先祖:ancestor:~
循環:cycle:~
単一:single:~
規則:rule:~
入力:input:~
出力:output:~
片付ける:clean up する:~

和集合:union:~
連鎖:chain:~
可視性判定:visibility:~
特別:special:~
内包:include:~
接尾辞:suffix:~
推移的:transitive:~
最長合致:longest possible match:~
等号:equals sign:~
派生:derived:~
順序:order:~
順序付けら:order さ:~
有順序:ordered:~
全順序:total order:~

演算子:operator:~

semicolon:::セミコロン
colon:::コロン
comma:::カンマ
dash:::ダッシュ
波括弧:braces:~
丸括弧:parenthesis:~
角括弧:square brackets:~
山括弧:angle brackets:~

offset:::オフセット
signature:::シグネチャ
library:::ライブラリ
system:::システム
browser:::ブラウザ
clone:::クローン
主thread:main thread::メインスレッド
テスト:testing::~
project::::プロジェクト
node:::ノード
graph:::グラフ
parameter:::パラメタ
hook:::フック
クラス:class::~
page:::ページ
text:::テキスト
event-handler:event handler::イベントハンドラ
place-holder:place holder:::プレースホルダ
programming:::プログラミング
program:::プログラム
pointer:::ポインタ
chunk:::チャンク
文:statement:~
集合:set:~:::セット
部分集合:subset:~:::サブセット
固定的:fixed:~
構造:structure:~
連想配列:associative array:~
有向:directed:~
辞書式:lexicographic:~
相対的:relative:~
絶対的:absolute:~
現在の:current:~
現在:currently:~
最初の:first:~
最後の:last:~
二番目の:second:２番目の
第一:first:~
第二:second:~
第三:third:~
結果:result:~
不可視に:invisible:~
可視:visible:~
	注記:note:~
	警告:warning:~
	課題:issue:~



	●低頻度
polyfill:
mixin:
mix-in:mix in
実行:execution:~
実行-:execute:~
	実行-可能:executable
非同期:asynchronous:~
所在:location:~
所在-:locate:~
	同一性:identity:~
実体:entity:~
正確:exact:~
略記法:shorthand:~
可用:available:~
可用な:available:~
副作用:side effect:~
情報:information:~
適切:appropriate:~
計数:counter:~
検分:inspection:~
検分-:inspect:~
対応関係:mapping:~
種類:kind:~

単独の:single:~
単純:simple:~
単純化-:simplify:~
効果:effect:~
	効果なし:no effect:~
不正:incorrect:~
不正な:incorrect:~
正しく:correct に:~
	正しい right

衝突:clash:~
protocol::プロトコル
binary::バイナリ
network::ネットワーク
encapsulate:::カプセル化
encapsulation:::カプセル化

transaction:::トランザクション
database:::データベース
mode:::モード
作動中:active:~:::アクティブ
作動中の:active な:~:::アクティブな
記憶域:memory:~:::メモリ
モデル:model::~
木:tree::~::ツリー
下層の:undelying:~
	節:section:~
交換可能:interchangable:~
一覧:table:~
一貫性:consistency:~
内容:contents:~
匿名:anonymous:~
処理:processing:~
私的:private:~
数学的演算:mathematical operation:~

hyphen:::ハイフン
連続的な:contiguous:~
記録-:record:~
算出-:compute:~
算出:computing:~
計算:computation:~
平方根:square root:~
内側:inside:~
生産-:produce:生成
精確:precise:~
単語:word:~
命名法:naming scheme:~
本体:body:~
入子に:nest:入れ子に
開いた:open した:~

読込んだ:load した:読み込んだ
切詰める:clamp する:切り詰める
切詰めら:clamp さ:切り詰めら
	切り詰める:truncate
生成-:generate:~
関連する:relevant な:~
font::::フォント
install::::インストール
	保たれ:keep され:~

</script>

<!--%links dfn -->
<script type="text/plain" id="_link_map">
~Unicode~scalar値~列に変換-:#dfn-obtain-unicode
	~JS値へ変換される:#dfn-convert-idl-to-ecmascript-value
	~IDL値へ変換される:#dfn-convert-ecmascript-to-idl-value
~IDL片:#dfn-idl-fragment

引数をとらない:#dfn-xattr-no-arguments
引数~listを引数にとる:#dfn-xattr-argument-list
有名~引数~list:#dfn-xattr-named-argument-list
有名~引数~listを引数にとる:#dfn-xattr-named-argument-list
識別子~listを引数にとる:#dfn-xattr-identifier-list
識別子を引数にとる:#dfn-xattr-identifier
型の~pairを引数にとる:#dfn-xattr-type-pair

属性:#dfn-attribute
呼戻~文脈:#dfn-callback-context
呼戻~関数:#dfn-callback-function
呼戻~ifc:#dfn-callback-interface
符号単位:#dfn-code-unit
適合~JS実装:#dfn-conforming-ecmascript-implementation
適合~IDL片の集合:#dfn-conforming-set-of-idl-fragments
適合~実装:#dfn-conforming-implementation
帰結~ifc:#dfn-consequential-interfaces
広義~帰結~ifc:#dfn-consequential0
定数:#dfn-constant
定義:#dfn-definition
既定~値:#dfn-optional-argument-default-value
削除子:#dfn-deleter
辞書:#dfn-dictionary
辞書~mb:#dfn-dictionary-member
必須~辞書~mb:#dfn-required-dictionary-member
判別可能:#dfn-distinguishable
判別引数~index:#dfn-distinguishing-argument-index
有効~多重定義~集合:#dfn-effective-overload-set
関数類:#dfn-function-like
列挙:#dfn-enumeration
列挙~値:#dfn-enumeration-value

例外:#dfn-exception
作成-:#dfn-create-exception
作成する:#dfn-create-exception
単純例外:#dfn-simple-exception
~message:#dfn-exception-message
~error名:#dfn-exception-error-name
~error名~一覧:#dfn-error-names-table
投出:#dfn-throw
投出する:#dfn-throw
~DOMException:#dfn-DOMException

平坦化~mb型:#dfn-flattened-union-member-types
取得子:#dfn-getter
取得子を継承-:#dfn-inherit-getter
識別子:#dfn-identifier
~ifc:#dfn-interface
~ifc~mb:#dfn-interface-member
~implements文:#dfn-implements-statement

名前空間:#dfn-namespace
部分的~名前空間~定義:#dfn-partial-namespace
名前空間~mb:#dfn-namespace-member

継承-:#dfn-inherit
被継承~ifc:#dfn-inherited-interfaces
被継承~辞書:#dfn-inherited-dictionaries
可反復:#dfn-iterable
可反復~宣言:#dfn-iterable-declaration
反復される値:#dfn-values-to-iterate-over
反復される値~pair:#dfn-value-pairs-to-iterate-over

値~反復子:#dfn-value-iterator
~pair反復子:#dfn-pair-iterator
旧来呼出子:#dfn-legacy-caller
~map~entry:#dfn-map-entries
~map~key型:#dfn-map-key-type
~map~value型:#dfn-map-value-type
~set~entry:#dfn-set-entries
~maplike:#dfn-maplike
~maplike 宣言:#dfn-maplike-declaration
~setlike:#dfn-setlike
~setlike 宣言:#dfn-setlike-declaration

有index~prop取得子:#dfn-indexed-property-getter
有index~prop設定子:#dfn-indexed-property-setter
有index~propを~supportする:#dfn-support-indexed-properties
有index~propを~support:#dfn-support-indexed-properties
有index~propの値を決定する:#dfn-determine-the-value-of-an-indexed-property
	既存の有index~propを削除する:#dfn-delete-an-existing-indexed-property
既存の有index~propを設定する:#dfn-set-the-value-of-an-existing-indexed-property
新たな有index~propを設定する:#dfn-set-the-value-of-a-new-indexed-property

有名~prop削除子:#dfn-named-property-deleter
有名~prop取得子:#dfn-named-property-getter
有名~prop設定子:#dfn-named-property-setter
有名~propを~supportする:#dfn-support-named-properties

有名~propの値を決定する:#dfn-determine-the-value-of-a-named-property
既存の有名~propを削除する:#dfn-delete-an-existing-named-property
既存の有名~propを設定する:#dfn-set-the-value-of-an-existing-named-property
新たな有名~propを設定する:#dfn-set-the-value-of-a-new-named-property

有名~定義:#dfn-named-definition

演算:#dfn-operation
省略可否 値:#dfn-optionality-value
随意~引数:#dfn-optional-argument
多重定義:#dfn-overloaded
部分的~辞書~定義:#dfn-partial-dictionary
部分的~ifc定義:#dfn-partial-interface
部分的~ifc:#dfn-partial-interface
~platform~obj:#dfn-platform-object

読専:#dfn-read-only
読み取り専用:#dfn-read-only
	読専~a:#dfn-read-only-array
正則~属性:#dfn-regular-attribute
正則~演算:#dfn-regular-operation
直列化可能な型:#dfn-serializable-type
直列化~pattern:#dfn-serialization-pattern
直列化-時の挙動:#dfn-serialization-behavior
直列化形の値:#dfn-serialized-value
直列化形の値に変換-:#dfn-convert-to-serialized-value
直列化子:#dfn-serializer
設定子:#dfn-setter
特殊~keyword:#dfn-special-keyword
特殊~演算:#dfn-special-operation
値の~listを反復する:#dfn-iterate-a-list-of-values
静的~属性:#dfn-static-attribute
静的~演算:#dfn-static-operation
文字列化子:#dfn-stringifier
文字列化の挙動:#dfn-stringification-behavior
追補~ifc:#dfn-supplemental-interface
被support~prop~index:#dfn-supported-property-indices
被support~prop名:#dfn-supported-property-names
~target~obj:#dfn-iterator-target-object

~typedef:#dfn-typedef
型~名:#dfn-type-name
利用者~obj:#dfn-user-object
可変個の引数をとる:#dfn-variadic
可変個~引数:#dfn-variadic-argument
末尾~引数:#dfn-variadic-argument
拡張属性:#dfn-extended-attribute
予約済み識別子:#dfn-reserved-identifier
在する:#dfn-present
不在:#dfn-present

	未初期化:#dfn-uninitialized-iterator-state
用語例:#dfn-example-term

参照／複製を取得-:#dfn-get-buffer-source-reference
	dfn-get-buffer-source-copy
切離す:#dfn-detach
切離された:#dfn-detach

定数~tok:#dfn-const-tokens
	配列の要素~型:#dfn-element-type
	連列の要素~型:#dfn-element-type

保安的~文脈:~SECURE-CONTEXT#secure-context

例外~型:#dfn-exception-type
~nullable~mb型の個数:#dfn-number-of-nullable-member-types
~nullable型:#dfn-nullable-type
~nullable:#dfn-nullable-type
~nullable型を内包する:#dfn-includes-a-nullable-type
内縁~型:#dfn-inner-type
整数~型:#dfn-integer-type
~buffer~source型:#dfn-buffer-source-type
有型~配列~型:#dfn-typed-array-type
~mb型:#dfn-union-member-type
実数~型:#dfn-numeric-type
文字列~型:#dfn-string-type
~primitive型:#dfn-primitive-type
返値型:#dfn-return-type
型:#idl-types
固有型:#dfn-specific-type
共用体~型:#dfn-union-type
呼戻~関数~型:#idl-callback-function
~ifc型:#idl-interface
連列~型:#sequence-type
~sequence_T:#idl-sequence
辞書~型:#idl-dictionary
~record型:#record-type
~record_KV:#idl-record
~mapping:#record-mappings
列挙~型:#idl-enumeration
凍結~配列~型:#dfn-frozen-array-type
~FrozenArray_T:#idl-frozen-array
~obj型:#dfn-object-type
~promise型:#dfn-promise-type
~promise_T:#idl-promise

有index~prop:#idl-indexed-properties
有名~prop:#idl-named-properties
連列~値を作成-:#create-sequence-from-iterable
凍結~配列~値を作成-:#create-frozen-array-from-iterable

ArrayBufferView:#ArrayBufferView
BufferSource:#BufferSource
DOMTimeStamp:#DOMTimeStamp
Function:#Function
VoidFunction:#VoidFunction
ArrayBufferView:#ArrayBufferView

IntegerPart:#abstract-opdef-integerpart
ConvertToInt:#abstract-opdef-converttoint

	●JS 束縛
GetCompletion:#_GetCompletion
PrepareSettings:#_PrepareSettings
通例の場所に存在する:#dfn-normal-location

List:~TC39#sec-list-and-record-specification-type
NewTarget:~TC39#sec-built-in-function-objects

~class文字列:#dfn-class-string
主~ifc:#dfn-primary-interface
主~大域~ifc:#dfn-primary-global-interface
単一~演算~呼戻~ifc:#dfn-single-operation-callback-interface

~ifc~obj:#dfn-interface-object
~ifc原型~obj:#dfn-interface-prototype-object
~DOMException原型~obj:#dfn-DOMException-prototype-object
~DOMException構築子~obj:#dfn-DOMException-constructor-object
初期~obj:#dfn-initial-object
反復子~原型~obj:#dfn-iterator-prototype-object
名前空間~obj:#dfn-namespace-object
既定の反復子~obj:#dfn-default-iterator-object
有名~prop~obj:#dfn-named-properties-object
関数~obj:#dfn-function-object

~promiseが決着したときの手続きを遂行する:#dfn-perform-steps-once-promise-is-settled

~map~size取得子:#dfn-map-size-getter
~set~size取得子:#dfn-set-size-getter
内部~map~objへ転送する:#dfn-forwards-to-the-internal-map-object
内部~set~objへ転送する:#dfn-forwards-to-the-internal-set-object

保安~検査を遂行する:#dfn-perform-a-security-check
保安的~文脈~下に限り可用になる:#dfn-available-only-in-secure-contexts
偽装不可:#dfn-unforgeable-on-an-interface
偽装不可~prop名:#dfn-unforgeable-property-name

公開~集合:#dfn-exposure-set
公開され:#dfn-exposed
公開する:#dfn-expose

凍結~配列を作成-:#dfn-create-frozen-array
呼戻 this 値:#dfn-callback-this-value
呼戻~関数を呼出す:#invoke-a-callback-function
変化-:#dfn-change-global-environment
多重定義~解決~algo:#dfn-overload-resolution-algorithm
現在の大域環境:#dfn-current-global-environment
大域~名:#dfn-global-name
属する~Realm:#dfn-associated-realm

属性~取得子:#dfn-attribute-getter
属性~設定子:#dfn-attribute-setter
有index~prop設定子を呼出す:#dfn-invoke-indexed-setter
有名~propの可視性判定~algo:#dfn-named-property-visibility
有名~prop設定子を呼出す:#dfn-invoke-named-setter
有名~構築子:#dfn-named-constructor
演算~関数を作成-:#dfn-create-operation-function
直列化形の値から~JS値に変換-:#dfn-convert-serialized-value-to-ecmascript-value
配列~index~prop名:#dfn-array-index-property-name

利用者~objの属性~値を取得する:#get-a-user-objects-attribute-value
利用者~objの属性~値を設定する:#set-a-user-objects-attribute-value
利用者~objの演算を~callする:#call-a-user-objects-operation

型互換:#_type-compatible

	●外部
大域~obj:~WAPI#concept-realm-global
関連する~Realm:~WAPI#concept-relevant-realm
関連する設定群~obj:~WAPI#relevant-settings-object
設定群~obj:~WAPI#concept-realm-settings-object
~incumbent設定群~obj:~WAPI#incumbent-settings-object
走らせた~scriptを片付ける:~WAPI#clean-up-after-running-script
走らせた呼戻子を片付ける:~WAPI#clean-up-after-running-a-callback
~scriptを走らすために準備する:~WAPI#prepare-to-run-script
呼戻子を走らすために準備する:~WAPI#prepare-to-run-a-callback
~event-handler~IDL属性:~WAPI#event-handler-idl-attributes

	中途完了:#abrupt-completion
	正常完了:#normal-completion
	~TC39#sec-completion-record-specification-type
~Realm:~TC39#sec-code-realms
~callable:~TC39#sec-iscallable
配列~反復子~obj:~TC39#sec-array-iterator-objects
~pdesc:~TC39#sec-property-descriptor-specification-type
Assert:~TC39#sec-algorithm-conventions
Completion:~TC39#sec-completion-record-specification-type
変異不可の原型~exotic~obj:~TC39#sec-immutable-prototype-exotic-objects
内部~slot:~TC39#sec-object-internal-methods-and-internal-slots

~Unicode~scalar値:http://www.unicode.org/glossary/#unicode_scalar_value

~PlatformObjectGetOwnProperty:#getownproperty-guts


esI.FunctionPrototype:~TC39#sec-properties-of-the-function-prototype-object
esI.ObjectPrototype:~TC39#sec-properties-of-the-object-prototype-object
esI.ArrayPrototype:~TC39#sec-well-known-intrinsic-objects
esI.ErrorPrototype:~TC39#sec-well-known-intrinsic-objects
esI.Error:~TC39#sec-well-known-intrinsic-objects
esI.Promise:~TC39#sec-promise-constructor
esI.ArrayProto_values:~TC39#sec-well-known-intrinsic-objects
esI.IteratorPrototype:~TC39#sec-well-known-intrinsic-objects

	~TC39#sec-well-known-symbols
	esS.iterator:
	esS.unscopables:
	esS.toStringTag:

	●§
#idl:~ifc定義~言語
#idl-objects:~ifcを実装している~obj
#idl-types:型
#idl-extended-attributes:拡張属性
#idl-special-operations:特殊~演算
#idl-stringifiers:文字列化子
#idl-indexed-properties:有index~prop
#idl-named-properties:有名~prop
#es-creating-throwing-exceptions:例外の作成と投出
#es-type-mapping:~JS型との対応関係
#es-unrestricted-double:unrestricted double
#es-DOMString:DOMString
#es-interface:~ifc型
#es-callback-function:呼戻~関数~型
#es-nullable-type:~nullable型
#es-buffer-source-types:~buffer~source型
#es-extended-attributes:~JS固有の拡張属性
#es-interfaces:~ifc
#interface-object:~ifc~obj
#es-constructible-interfaces:構築-可能な~ifc
#named-constructors:有名~構築子
#interface-prototype-object:~ifc原型~obj
#named-properties-object:有名~prop~obj
#es-constants:定数
#es-attributes:属性
#es-operations:演算
#es-serializer:直列化子
#es-iterators:反復子に共通する挙動
#es-platform-objects:~ifcを実装している~platform~obj
#indexed-and-named-properties:有index~propと有名~prop
#getownproperty:~platform~obj [[GetOwnProperty]] ~meth
#platformobjectset:~platform~obj [[Set]] ~meth
#defineownproperty:~platform~obj [[DefineOwnProperty]] ~meth
#property-enumeration:~prop列挙
#es-user-objects:利用者~obj
#namespace-object:名前空間~obj
#idl-grammar:~IDL文法

#es-DOMException-prototype-object:~DOMException原型~obj

</script>

<!--%links他 -->
<!-- 

	ToBoolean
	ToNumber
	ToUint16
	ToInt32
	ToUint32
	ToString
	ToObject
	IsCallable:iscallable
	IsAccessorDescriptor:isaccessordescriptor
	IsDataDescriptor:isdatadescriptor
	DetachArrayBuffer:detacharraybuffer
	IsDetachedBuffer:isdetachedbuffer
	GetIterator
	IteratorStep
	IteratorValue
	NormalCompletion
	ReturnIfAbrupt
	GetMethod
	CreateMapIterator
	CreateSetIterator
	CreateIterResultObject
	IsConstructor
	Construct
	DefinePropertyOrThrow
	ArrayCreate
	CreateDataProperty
	Get:get-o-p
	SetIntegrityLevel
-->

<script type="text/plain" id="_ext_map">
	●補完
	active 関数~obj:~TC39#sec-execution-contexts
	<a href="~TC39#sec-function-environment-records">`NewTarget^es</a>
	●
Type:<a class="abstract" href="~TC39#sec-ecmascript-data-types-and-values">Type</a>
Get:<a class="abstract" href="~TC39#sec-get-o-p">Get</a>
Set:<a class="abstract" href="~TC39#sec-set-o-p-v-throw">Set</a>

NumericLiteral:<a href="~TC39#sec-literals-numeric-literals"><em>NumericLiteral</em></a>

MISSING:特殊~値 <i class="const">missing</i> 

辞書継承:<a href="#dfn-inherit-dictionary">継承-</a>
辞書既定値:<a href="#dfn-dictionary-member-default-value">既定~値</a>

ol-callable:<a href="#ol-callable"><var>callable</var></a>
ol-optionality-list:<a href="#ol-optionality-list"><var>省略可否~list</var></a>
ol-type-list:<a href="#ol-type-list"><var>型~list</var></a>


toIDL:<a href="#dfn-convert-ecmascript-to-idl-value">変換-</a>
toES:<a href="#dfn-convert-idl-to-ecmascript-value">変換-</a>
直列化値toES: <a href="#dfn-convert-serialized-value-to-ecmascript-value">~JS値に変換-</a>


論ML:先に進む前に， <a href="mailto:public-script-coord@w3.org">public-script-coord@w3.org</a> ~mailing-listにて論を交わすことを強く勧める
最近数値:最も近い実数~値（２数が等距離にある場合は，<em>仮数が偶数になる</em>方を選ぶ — <a href="#ref-ECMA-262">[ECMA-262]</a>, <a href="~TC39#sec-ecmascript-language-types-number-type">Number 型</a> ）
投出:<a href="#ecmascript-throw" class="dfnref external">投出</a>
	❖HTML = specs/web-apps/current-work/multipage

</script>

<!--%grammar data -->

<script type="text/plain" id="_d-grammar-table">
●Definitions
ExtendedAttributeList Definition Definitions
ε
●Definition
CallbackOrInterface
Namespace
Partial
Dictionary
Enum
Typedef
ImplementsStatement
●CallbackOrInterface
"callback" CallbackRestOrInterface
Interface
●ArgumentNameKeyword
"attribute"
"callback"
"const"
"deleter"
"dictionary"
"enum"
"getter"
"implements"
"inherit"
"interface"
"iterable"
"legacycaller"
"maplike"
"namespace"
"partial"
"required"
"serializer"
"setlike"
"setter"
"static"
"stringifier"
"typedef"
"unrestricted"
●CallbackRestOrInterface
CallbackRest
Interface
●Interface
"interface" identifier Inheritance "{" InterfaceMembers "}" ";"
●Partial
"partial" PartialDefinition
●PartialDefinition
PartialInterface
PartialDictionary
Namespace
●PartialInterface
"interface" identifier "{" InterfaceMembers "}" ";"
●InterfaceMembers
ExtendedAttributeList InterfaceMember InterfaceMembers
ε
●InterfaceMember
Const
Operation
Serializer
Stringifier
StaticMember
Iterable
ReadOnlyMember
ReadWriteAttribute
ReadWriteMaplike
ReadWriteSetlike
●Inheritance
":" identifier
ε
●Const
"const" ConstType identifier "=" ConstValue ";"
●ConstValue
BooleanLiteral
FloatLiteral
integer
"null"
●BooleanLiteral
"true"
"false"
●FloatLiteral
float
"-Infinity"
"Infinity"
"NaN"
●ConstType
PrimitiveType Null
identifier Null
●ReadOnlyMember
"readonly" ReadOnlyMemberRest
●ReadOnlyMemberRest
AttributeRest
ReadWriteMaplike
ReadWriteSetlike
●ReadWriteAttribute
"inherit" ReadOnly AttributeRest
AttributeRest
●AttributeRest
"attribute" Type AttributeName ";"
●AttributeName
AttributeNameKeyword
identifier
●AttributeNameKeyword
"required"
●Inherit
"inherit"
ε
●ReadOnly
"readonly"
ε
●DefaultValue
ConstValue
string
"[" "]"
●Operation
ReturnType OperationRest
SpecialOperation
●SpecialOperation
Special Specials ReturnType OperationRest
●Specials
Special Specials
ε
●Special
"getter"
"setter"
"deleter"
"legacycaller"
●OperationRest
OptionalIdentifier "(" ArgumentList ")" ";"
●OptionalIdentifier
identifier
ε
●ArgumentList
Argument Arguments
ε
●Arguments
"," Argument Arguments
ε
●Argument
ExtendedAttributeList OptionalOrRequiredArgument
●OptionalOrRequiredArgument
"optional" Type ArgumentName Default
Type Ellipsis ArgumentName
●ArgumentName
ArgumentNameKeyword
identifier
●Ellipsis
"..."
ε
●ReturnType
Type
"void"
●Stringifier
"stringifier" StringifierRest
●StringifierRest
ReadOnly AttributeRest
ReturnType OperationRest
";"
●Serializer
"serializer" SerializerRest
●SerializerRest
OperationRest
"=" SerializationPattern ";"
";"
●SerializationPattern
"{" SerializationPatternMap "}"
"[" SerializationPatternList "]"
identifier
●SerializationPatternMap
"getter"
"inherit" Identifiers
identifier Identifiers
ε
●SerializationPatternList
"getter"
identifier Identifiers
ε
●Identifiers
"," identifier Identifiers
ε
●StaticMember
"static" StaticMemberRest
●StaticMemberRest
ReadOnly AttributeRest
ReturnType OperationRest
●Iterable
"iterable" "<" Type OptionalType ">" ";"
●OptionalType
"," Type
ε
●ReadWriteMaplike
MaplikeRest
●MaplikeRest
"maplike" "<" Type "," Type ">" ";"
●ReadWriteSetlike
SetlikeRest
●SetlikeRest
"setlike" "<" Type ">" ";"
●Namespace
"namespace" identifier "{" NamespaceMembers "}" ";"
●NamespaceMembers
ExtendedAttributeList NamespaceMember NamespaceMembers
ε
●NamespaceMember
ReturnType OperationRest
●Dictionary
"dictionary" identifier Inheritance "{" DictionaryMembers "}" ";"
●DictionaryMembers
ExtendedAttributeList DictionaryMember DictionaryMembers
ε
●DictionaryMember
Required Type identifier Default ";"
●Required
"required"
ε
●PartialDictionary
"dictionary" identifier "{" DictionaryMembers "}" ";"
●Default
"=" DefaultValue
ε
●Enum
"enum" identifier "{" EnumValueList "}" ";"
●EnumValueList
string EnumValueListComma
●EnumValueListComma
"," EnumValueListString
ε
●EnumValueListString
string EnumValueListComma
ε
●CallbackRest
identifier "=" ReturnType "(" ArgumentList ")" ";"
●Typedef
"typedef" Type identifier ";"
●ImplementsStatement
identifier "implements" identifier ";"
●Type
SingleType
UnionType Null
●SingleType
NonAnyType
"any"
●UnionType
"(" UnionMemberType "or" UnionMemberType UnionMemberTypes ")"
●UnionMemberType
NonAnyType
UnionType Null
●UnionMemberTypes
"or" UnionMemberType UnionMemberTypes
ε
●NonAnyType
PrimitiveType Null
PromiseType Null
StringType Null
identifier Null
"sequence" "<" Type ">" Null
"object" Null
"Error" Null
"DOMException" Null
BufferRelatedType Null
"FrozenArray" "<" Type ">" Null
RecordType Null
●PrimitiveType
UnsignedIntegerType
UnrestrictedFloatType
"boolean"
"byte"
"octet"
●UnrestrictedFloatType
"unrestricted" FloatType
FloatType
●FloatType
"float"
"double"
●UnsignedIntegerType
"unsigned" IntegerType
IntegerType
●IntegerType
"short"
"long" OptionalLong
●OptionalLong
"long"
ε
●StringType
"ByteString"
"DOMString"
"USVString"
●PromiseType
"Promise" "<" ReturnType ">"
●RecordType
"record" "<" StringType "," Type ">"
●Null
"?"
ε
●BufferRelatedType
"ArrayBuffer"
"DataView"
"Int8Array"
"Int16Array"
"Int32Array"
"Uint8Array"
"Uint16Array"
"Uint32Array"
"Uint8ClampedArray"
"Float32Array"
"Float64Array"
●ExtendedAttributeList
"[" ExtendedAttribute ExtendedAttributes "]"
ε
●ExtendedAttributes
"," ExtendedAttribute ExtendedAttributes
ε
●ExtendedAttribute
"(" ExtendedAttributeInner ")" ExtendedAttributeRest
"[" ExtendedAttributeInner "]" ExtendedAttributeRest
"{" ExtendedAttributeInner "}" ExtendedAttributeRest
Other ExtendedAttributeRest
●ExtendedAttributeRest
ExtendedAttribute
ε
●ExtendedAttributeInner
"(" ExtendedAttributeInner ")" ExtendedAttributeInner
"[" ExtendedAttributeInner "]" ExtendedAttributeInner
"{" ExtendedAttributeInner "}" ExtendedAttributeInner
OtherOrComma ExtendedAttributeInner
ε
●Other
integer
float
identifier
string
other
"-"
"-Infinity"
"."
"..."
":"
";"
"<"
"="
">"
"?"
"ByteString"
"DOMString"
"FrozenArray"
"Infinity"
"NaN"
"USVString"
"any"
"boolean"
"byte"
"double"
"false"
"float"
"long"
"null"
"object"
"octet"
"or"
"optional"
"sequence"
"short"
"true"
"unsigned"
"void"
ArgumentNameKeyword
BufferRelatedType
●OtherOrComma
Other
","
●IdentifierList
identifier Identifiers
●ExtendedAttributeNoArgs
identifier
●ExtendedAttributeArgList
identifier "(" ArgumentList ")"
●ExtendedAttributeIdent
identifier "=" identifier
●ExtendedAttributeIdentList
identifier "=" "(" IdentifierList ")"
●ExtendedAttributeNamedArgList
identifier "=" identifier "(" ArgumentList ")"
</script>


<!--%style -->
<style>

/* common-*.css を上書き */
*[lang="en"] {
	white-space: pre-line;
}

.advisement { /* 警告 */
	text-align: left;
}

pre {
	white-space: pre-wrap;
}

code {
	color: #aa2300; /* #ff4500; 変更 */
}

/* 追加 */

.sym {
	font-weight: bold;
}
.g {
	font-style: italic;
}

.char {
	font-size: 85%
}


/* 節リンク */
.sec::before {
	content: '「';
	color: gray;
}
.sec::after {
	content: '」節';
	color: gray;
}

.input,
.xattr,
.sym {
  font-family: monospace0, monospace;
}


/* 拡張属性 */
.xattr {
	color: purple;
}

/* 生成文法記号 */
.sym {
}

/* IDL, ECMAScript 型／値 */

.idltype, .idlmember, .estype {
	font-family: monospace0, monospace;
}
.idlvalue, .esvalue {
	font-family: monospace0, monospace;
}


.idltype, .idlvalue, .idlmember {
	color: #017;
}

.esvalue, .estype {
	color: #061;
}

/* ECMAScript
	プロパティ記述子,
	内部プロパティ ／ well-known symbol,
	intrinsic/prototype object
*/
.descriptor,
.prop,
.es-intrinsic {
	color: #061;
}

/* 仮想の定数 */
i.const {
	text-decoration: underline;
}

/* 定義語彙参照 */
.dfnref {
}

	/* コードブロック */
pre {
	margin: 0.5em 0 0.5em 0.5em;
	padding: 0.5em 1em;
}

pre.syntax,
pre.idl-code,
pre.es-code,
pre.html-code {
}

pre.idl-code,
pre.syntax{
	background:hsl(24, 20%, 95%);
}

pre.es-code {
	background: #FCFADC;
}

/* 引用例 */
blockquote {
	padding: 1px 1em;
	margin-left: 2em;
	margin-right: 2em;
}

.example blockquote {
	background: #f0f6ff;
}

/* 抽象演算 */
a.abstract {
	color: green;
}


/* 文法 */
dl.grammar {
	background: #eee;
}
dl.grammar > dt {
	font-weight: normal;
}
dl.grammar > dd {
	margin-left: 6em;
	white-space: pre-line;
}

dl.grammar > dt::after {
	content: " ::";
}

	/* 終端記号 */
#terminals > dd {
	margin-left: 4em;
}

#terminals > dt::after {
	content: " =";
}
#terminals > dd.regex::before,
#terminals > dd.regex::after {
	position:static;
	content: "/";
	color: orangered;
}

/* アルゴリズム */

ol.algorithm,
ol.algorithm ol {
	border-left: 1px solid #90b8de;
}

dd > :first-child {
  margin-top: 0;
}


a.placeholder {
  color: #00e;
}

/* 集合 */
div.set {
  margin-left: 3em;
  margin-bottom: 1em;
  text-indent: -1em;
}

/* Level 2 */
section.L2, /* override :target */
.L2 {
	background: #FEE;
}


/* table */

table {
	border-style:hidden hidden none hidden;
}
table thead {
	border-bottom: solid medium gray;
}

table td, table th {
	border: solid thin gray;
	border-top: none;
	padding:0.2em;
}

	/* 表 整形 */
#matrix-idl-floats th,
#matrix-idl-integers th {
	white-space: nowrap;
}
#matrix-idl-integers td:nth-child(2),
#matrix-idl-integers td:nth-child(3),
#matrix-integers td,
#matrix-integers th {
	text-align: right;
	white-space: nowrap;
}
#matrix-integers th {
	min-width: 4em;
}
#matrix-buffer-sources td:first-child {
	white-space: pre-line;
}

/* 判別表 */

#_disting {
	font-size: 80%;
}

#_disting > thead {
	border-bottom: 1px solid #90b8de;
}

#_disting > thead > tr > th {
	vertical-align: top;
	text-align: center;
}

#_disting th {
	background: #d9e8ff;
}

#_disting td, #_disting th {
	border: 1px solid #90b8de;
	padding: 4px;
}

#_disting td {
	text-align: center;
	background: #f0f6ff;
}

#_disting td[colspan] {
	background: #ddd;
}

#_disting > tbody > tr > th:first-child {
	text-align: right;
}

#_disting > tbody > tr > th:last-child {
	text-align: left;
}

@supports (transform: rotate(-40deg)) or (-webkit-transform: rotate(-40deg)) {
	#_disting {
		font-size: 100%;
		white-space: nowrap;
	}

	#_disting > thead > tr > th {
		padding-top: 10em;
		border: none;
		background: none;
		min-width: 2em;
		max-width: 2em;
		overflow: visible;
	}

	#_disting > thead > tr > th > span {
		margin-left: 0.5em;
		line-height: 1em;
		white-space: nowrap;
		text-decoration: underline;
		display: block;
		-webkit-transform: rotate(-40deg);
		-webkit-transform-origin: 0% 0%;
		transform: rotate(-40deg);
		transform-origin: 20% 0%;
	}
}

</style>
<!-- 
/*
	-webkit-writing-mode:vertical-rl;
	writing-mode:vertical-rl;
*/

/* IDL 構文の参考例 */
pre.syntax {
	background: #ddffdd;
	padding: 1em;
	margin: 1em 2em;
}

/* IDL 構文 
pre.syntax {
	font-weight: bold;
}
pre.syntax em, pre.syntax i { font-weight: normal; }
pre.syntax em { color: red }
*/

 -->


</head>

<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>


<aside class="trans-meta">

<h1>Web IDL (Second Edition) — 日本語訳</h1>

<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a>
により，副題の日付にて<strong >編集者草案</strong>（ Editor’s Draft ）として公開された 
<a href="https://heycam.github.io/webidl/">Web IDL</a>
（第２版）を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-11-12</time>
（公開： <time>2013-08-22</time>）
<!-- <time>2012-05-15</time>（第１版） -->
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>

<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1 title="Web IDL">Web IDL</h1>
<h2>2016 年 11 月 11 日付 W3C 編集者草案</h2>
	</hgroup>
<dl id="_versions">
	<dt title="This Version:">このバージョン</dt>
	<dd>https://heycam.github.io/webidl/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>https://www.w3.org/TR/WebIDL-1/</dd>

	<dt title="Version History:">バージョン履歴</dt>
	<dd>https://github.com/heycam/webidl/commits/gh-pages</dd>

	<dt title="Feedback:">フィードバック</dt>
	<dd><a href="mailto:public-script-coord@w3.org?subject=%5Bwebidl%5D%20YOUR%20TOPIC%20HERE">public-script-coord@w3.org</a> with subject line “<kbd>[webidl] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-script-coord/" rel="discussion">archives</a>)</dd>
	<dd><a href="https://github.com/heycam/webidl">GitHub</a> (
<a href="https://github.com/heycam/webidl/issues/new">new issue</a>,
<a href="https://github.com/heycam/webidl/issues">open issues</a>,
<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WebAppsWG&amp;component=WebIDL&amp;resolution=---">legacy bug tracker</a>)</dd>

	<dt title="Editor:">編集</dt>
	<dd><a href="http://mcc.id.au/">Cameron McCormack</a>, Mozilla Corporation <a href="mailto:cam@mcc.id.au">cam@mcc.id.au</a></dd>
     <dd><a href="mailto:bzbarsky@mit.edu">Boris Zbarsky</a> (Mozilla Corporation)</dd>
     <dd><a href="http://tobie.me">Tobie Langel</a> <a href="mailto:tobie@codespeaks.com">tobie@codespeaks.com</a></dd>

</dl>

<p class="trans-note">【
最新発行バージョン, バージョン履歴は、訳者による追加。
】</p>


<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016
<a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
<a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
<a href="http://www.keio.ac.jp/">Keio</a>,
<a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
<a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a>
rules apply.
</small>

</header>


<div id="MAIN" style="display:none;">

	<section>
<h2 title="Abstract">要約</h2>

<p>
この文書は、~Web~browserへの実装を目的とする~ifcを記述するための~ifc定義~言語， ~Web~IDLを定義する。
~Web~IDLは、~Web~platformにおける, 共通の~script~objの挙動を，より容易く指定できるようするために、いくつもの特色機能を備えた~IDLの変種である。
この文書では、~Web~IDLで記述される~ifcを ~JS実行~環境の構成子に対応付ける方法についても，詳細に渡り述べられる。
この文書は、［
既に発行-済みの仕様，および 新たに発行され, この文書を参照する仕様
］の適合~ifc実装が，相互運用可能になるための、実装者にとっての指針になるものと期待されている。
◎
This document defines an interface definition language, Web IDL, that can be used to describe interfaces that are intended to be implemented in web browsers. Web IDL is an IDL variant with a number of features that allow the behavior of common script objects in the web platform to be specified more readily. How interfaces described with Web IDL correspond to constructs within ECMAScript execution environments is also detailed in this document. It is expected that this document acts as a guide to implementors of already-published specifications, and that newly published specifications reference this document to ensure conforming implementations of interfaces are interoperable.
</p>

	</section>
	<section id="sotd">

<h2 title="Status of this Document">この文書の位置付け</h2>

<p>
<em>この節では…</em>
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status">W3C 日本語訳 共通ページ</a>
に委譲
】</span></p>


<p><strong>
この文書に対する変更は、
<a href="https://github.com/heycam/webidl">https://github.com/heycam/webidl</a>
から追跡できます。
</strong>
◎
Changes to this document may be tracked at https://github.com/heycam/webidl.
</p>

<p>
この文書に関するコメントを歓迎します。
コメントは、冒頭の “フィードバック” に挙げた
GitHub repository ／ public mailing list
宛に願います。
◎
If you wish to make comments regarding this document, please send them to this specification’s GitHub repository or (archived) public mailing list public-script-coord@w3.org (see instructions). When sending e-mail, please put the text “webidl” in the subject, preferably like this: “[webidl] …summary of comment…. All comments are welcome.
</p>




	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序</h2>

~INFORMATIVE

<p>
W3C により発行される技術報告に含められる~programming言語~ifcは、概して
Object Management Group による~IDL（ Interface Definition Language ）
`OMGIDL$r を利用して記述されていた。
この~IDLは、これらの~ifcを，言語から独立な方式で記述する手段を提供する。
通例，その種の文書には、~IDLで記述された~ifcを［
所与の言語
］の構成子に対応付ける方法について，詳細を述べる、言語束縛についての追加の付録が含められる。
◎
Technical reports published by the W3C that include programming language interfaces have typically been described using the Object Management Group’s Interface Definition Language (IDL) [OMGIDL]. The IDL provides a means to describe these interfaces in a language independent manner. Usually, additional language binding appendices are included in such documents which detail how the interfaces described with the IDL correspond to constructs in the given language.
</p>

<p>
しかしながら、~Web上で最も共通的に利用されている言語, ~JSに対しては、これらの仕様における言語束縛は，終始~低い~~精度で指定されていたため、相互運用性の課題も生じていた。
加えて、それぞれの仕様が同じ基本的な情報を述べなければならない
— 例えば、
~IDLで記述される DOM ~ifcが~JS大域~objの~propに対応していることや,
`unsigned long$T ~IDL型が~JSの `Number^t 型に対応付けられることなど。
◎
However, the bindings in these specifications for the language most commonly used on the web, ECMAScript, are consistently specified with low enough precision as to result in interoperability issues. In addition, each specification must describe the same basic information, such as DOM interfaces described in IDL corresponding to properties on the ECMAScript global object, or the unsigned long IDL type mapping to the Number type in ECMAScript.
</p>

<p>
この仕様は、~Web~APIのための~ifcを定義する仕様で利用できる， OMG ~IDLに似た~IDL言語を定義する。
この~IDLには、以前は注釈文による記述を要していた共通の機能性を~supportするために，いくつもの拡張が加えられた。
加えて、 ECMAScript Edition 6 のための，精確な言語束縛も与えられた。
◎
This specification defines an IDL language similar to OMG IDL for use by specifications that define interfaces for Web APIs. A number of extensions are given to the IDL to support common functionality that previously must have been written in prose. In addition, precise language bindings for ECMAScript Edition 6 are given.
</p>

	</section>
	<section id="_conventions">
<h2 class="trans-note">【日本語訳に特有の表記規約】</h2>

<p>
この訳では，アルゴリズムの記述に次の記号を用いる
：
<span class="block">
:= （~~定義）, :← （~~初期化）, ← （~~代入）, ~EQ, ~NEQ （~~比較）,<br>
~IF, ~ELSE, ~ELIF, ~WHILE, ~FOR ~EACH (…), ~BREAK, ~CONTINUE, ~RET, ~THROW （~~実行制御）
</span>
</p>

<p>
これらのうち，次のもの以外の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照。
</p>

<ul>
	<li>
~THROW は、もっぱら~JS言語束縛において利用される（定義はリンク先を~~参照）。
</li>
	<li>
<p>
:= は :← と同じ意味に解釈されても不都合は無いが、意味合いは異なる：
</p>

		<dl>
			<dt>%var := %value</dt>
			<dd>
新たな記号 %var の~~導入とその値の %value による定義を表す（原文 “let var to …” ）。
</dd>

			<dt>%var :← %value</dt>
			<dd>
新たな変数 %var の~~導入とその値の %value による初期化-を表す（原文 “initialize” ）。
</dd>
			<dd>
<b>:=</b> との相違は， %var の値が後で変更され得る所<small>（ … のように見受けられるが、原文をそのまま反映しているだけなので，~~例外はあるかもしれない）</small>。
</dd>
		</dl>
	</li>
</ul>

<p>
この仕様~自身にも，<a href="#conventions">表記規約がある</a>。
</p>

<p class="L2">
最新発行~versionにはない，編集者草案にて追加された おおよその部分には、この段落と同じ~styleがあてがわれている（細かい箇所までは網羅していない）。
</p>

<p>
この仕様の中の用語の一部は、定訳が無いため，訳者が適当に対訳をあてがっている。
ウィンドウ下端に対訳の切り替え機能がある。
</p>


	</section>
	<section id="idl">
<h2 title="Interface definition language">2. ~ifc定義~言語</h2>


<p>
この節では、~Web~platform~APIのための~ifcを定義するために利用できる言語，
<em>~Web~IDL</em> について述べる。
~Web~APIを定義する仕様は、［
その仕様が定義する~APIのための~ifc（~objが表出し得る状態と挙動）
］を記述する，１つ以上の
`~IDL片@
を含み得る。
`~IDL片$は、文法~記号 `Definitions$g に合致する，定義の並びである。
実装が~supportする `~IDL片$の集合は、順序付けられない。
完全な文法と利用される記法の説明については，`idl-grammar$secを見よ。
◎
This section describes a language, Web IDL, which can be used to define interfaces for APIs in the Web platform. A specification that defines Web APIs can include one or more IDL fragments that describe the interfaces (the state and behavior that objects can exhibit) for the APIs defined by that specification. An IDL fragment is a sequence of definitions that matches the Definitions grammar symbol. The set of IDL fragments that an implementation supports is not ordered. See IDL grammar for the complete grammar and an explanation of the notation used.
</p>


<p>
 `~IDL片$に現れ得る
`定義@
には、次の種類がある：
`~ifc$,
`部分的~ifc定義$,
`名前空間$,
`部分的~名前空間~定義$,
`辞書$,
`部分的~辞書~定義$,
`~typedef$,
`~implements文$
。
これらはすべて後続の節にて定義される。
◎
The different kinds of definitions that can appear in an IDL fragment are: interfaces, partial interface definitions, namespaces, partial namespace definitions, dictionaries, partial dictionary definitions, typedefs and implements statements. These are all defined in the following sections.
</p>


<p>
各`定義$（ `Definition$g に合致）の前には、［
`拡張属性$の~list（ `ExtendedAttributeList$g に合致）
］を置くことができる
— それらは、その定義が，言語束縛において どう取扱われるかを制御する。
この仕様が定義する拡張属性の，どの言語束縛にも通用する部分については
`idl-extended-attributes$sec
にて論じられ、~JS言語束縛~特有の部分については
`es-extended-attributes$sec
にて論じられる。
◎
Each definition (matching Definition) can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how the definition will be handled in language bindings. The extended attributes defined by this specification that are language binding agnostic are discussed in §2.12 Extended attributes, while those specific to the ECMAScript language binding are discussed in §3.3 ECMAScript-specific extended attributes.
</p>


<pre class="syntax">
[`extended_attributes^mk]
interface `identifier^i {
  /* interface_members... */
};
</pre>


<div class="grammar">
-Definitions
-Definition
-CallbackOrInterface
</div>

<div class="example">
<p>
 `~IDL片$の例を示す：
◎
The following is an example of an IDL fragment.
</p>

<pre class="idl-code">
interface Paint { };

interface SolidColor : Paint {
  attribute double red;
  attribute double green;
  attribute double blue;
};

interface Pattern : Paint {
  attribute DOMString imageURL;
};

[Constructor]
interface GraphicalWindow {
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;

  attribute Paint currentPaint;

  void drawRectangle(double x, double y, double width, double height);

  void drawText(double x, double y, DOMString text);
};
</pre>

<p>
ここでは、４個の`~ifc$が定義されている。
`GraphicalWindow^T ~ifcには、
２個の`読専$ `属性$,
１個の~writableな属性,
２個の`演算$
が定義されている。
`GraphicalWindow^T ~ifcを実装する~objは、
利用されている個別の言語に適切な方式で，これらの属性と演算を公開することになる。
◎
Here, four interfaces are being defined. The GraphicalWindow interface has two read only attributes, one writable attribute, and two operations defined on it. Objects that implement the GraphicalWindow interface will expose these attributes and operations in a manner appropriate to the particular language being used.
</p>

<p>
~JSにおいては、~IDL~ifc上の属性／演算は、すべての `GraphicalWindow^T ~objにおいて，その原型~obj上の
~accessor~prop ／ `Function^t 値~data-prop
として，公開されることになる。
`GraphicalWindow^T を実装する各~JS~objは、その原型鎖の中にその原型~objを持つことになる。
◎
In ECMAScript, the attributes on the IDL interfaces will be exposed as accessor properties and the operations as Function-valued data properties on a prototype object for all GraphicalWindow objects; each ECMAScript object that implements GraphicalWindow will have that prototype object in its prototype chain.
</p>

<p>
`GraphicalWindow^T 上に現れる `Constructor$x は`拡張属性$である。
この拡張属性により、 `new GraphicalWindow()^c の~callに対し，この~ifcを実装する新たな~objを返すような構築子が、~JS実装に存在することになる。
◎
The [Constructor] that appears on GraphicalWindow is an extended attribute. This extended attribute causes a constructor to exist in ECMAScript implementations, so that calling new GraphicalWindow() would return a new object that implemented the interface.
</p>

</div>

		<section id="idl-names">
<h3 title="Names">2.1. 名前（識別子）</h3>


<p>
どの［
`~ifc$ ／
`部分的~ifc定義$ ／
`名前空間$ ／
`部分的~名前空間~定義$ ／
`辞書$ ／
`部分的~辞書~定義$ ／
`列挙$ ／
`呼戻~関数$ ／
`~typedef$
］も（これらは総称して
`有名~定義@
と呼ばれる）, および
どの［
`定数$ ／
`属性$ ／
`辞書~mb$
］も、何らかの`演算$を行うための
`識別子@
を持つ。
識別子はその宣言~内のどこかに位置する `identifier$g ~tokから決定される：
◎
Every interface, partial interface definition, namespace, partial namespace definition, dictionary, partial dictionary definition, enumeration, callback function and typedef (together called named definitions) and every constant, attribute, and dictionary member has an identifier, as do some operations. The identifier is determined by an identifier token somewhere in the declaration:
</p>

<ul>
	<li>
<p>
`有名~定義$に対しては、~keyword［
`interface^c ／
`namespace^c ／
`dictionary^c ／
`enum^c ／
`callback^c
］の直後に現れる `identifier$g ~tokがその定義の識別子を決定する。
◎
For named definitions, the identifier token that appears directly after the interface, namespace, dictionary, enum or callback keyword determines the identifier of that definition.
</p>

<pre class="syntax">
interface `interface_identifier^mk { /* interface_members... */ };
partial interface `interface_identifier^mk { /* interface_members... */ };
namespace `namespace_identifier^mk { /* namespace_members... */ };
partial namespace `namespace_identifier^mk { /* namespace_members... */ };
dictionary `dictionary_identifier^mk { /* dictionary_members... */ };
partial dictionary `dictionary_identifier^mk { /* dictionary_members... */ };
enum `enumeration_identifier^mk { "enum", "values" /* , ... */ };
callback `callback_identifier^mk = return_type (/* arguments... */);
</pre>
	</li>
	<li>
<p>
`属性$,
`~typedef$,
`辞書~mb$
に対しては、宣言の末尾の~semicolonの前に位置する最後の `identifier$g ~tokが識別子を決定する。
◎
For attributes, typedefs and dictionary members, the final identifier token before the semicolon at the end of the declaration determines the identifier.
</p>

<pre class="syntax">
interface `identifier^i {
  attribute `type^i `attribute_identifier^mk;
};

typedef `type^i `typedef_identifier^mk;

dictionary `identifier^i {
  `type^i `dictionary_member_identifier^mk;
};
</pre>

</li>
	<li>
<p>
`定数$に対しては、等号の前に位置する
`identifier$g ~tokが識別子を決定する。
◎
For constants, the identifier token before the equals sign determines the identifier.
</p>

<pre class="syntax">
const `type^i `constant_identifier^mk = 42;
</pre>

</li>
	<li>
<p>
`演算$に対しては、返値型の後，かつ左~丸括弧の前に現れる `identifier$g ~tok（ `OperationRest$g の中の文法~記号 `OptionalIdentifier$g の部分として合致）
が、その演算の識別子を決定する。
そのような `identifier$g ~tokが無い場合、その演算は識別子を持たない。
◎
For operations, the identifier token that appears after the return type but before the opening parenthesis (that is, one that is matched as part of the OptionalIdentifier grammar symbol in an OperationRest) determines the identifier of the operation. If there is no such identifier token, then the operation does not have an identifier.
</p>

<pre class="syntax">
interface interface_identifier {
  `return_type^i `operation_identifier^mk(/* arguments... */);
};
</pre>

</li>
</ul>

<p class="note">注記：
［
取得子や設定子などの，
<a href="#idl-special-operations">特殊な種類の演算</a>
］を宣言する演算は、識別子を持たないことがある。
◎
Note: Operations can have no identifier when they are being used to declare a special kind of operation, such as a getter or setter.
</p>

<p>
これらの構成子のすべてにおいて、
`identifier$g ~tokから先頭の
`U+005F LOW LINE ("_")^char
文字を（もし在れば）除去した値が`識別子$になる。
◎
For all of these constructs, the identifier is the value of the identifier token with any leading U+005F LOW LINE ("_") character (underscore) removed.
</p>

<p class="note">注記：
先頭の
`"_"^char
は、識別子を~escapeして，予約済みの語と見誤られなくするために利用される。
例えば、 `interface^l という名前を持つ~ifcも定義できる。
先頭の
`"_"^char
は識別子の~escapeを外す際に落とされる。
◎
Note: A leading "_" is used to escape an identifier from looking like a reserved word so that, for example, an interface named “interface” can be defined. The leading "_" is dropped to unescape the identifier.
</p>

<p>
演算~引数がとり得る識別子は、もう少し広い集合になる。
演算の宣言においては、引数の識別子はその型の直後に指定され、
`identifier$g ~tokか, または `ArgumentNameKeyword$g 記号に合致する~keywordで与えられる。
これらの~keywordのいずれかが利用される場合、先頭の underscore による~escapeは不要である。
◎
Operation arguments can take a slightly wider set of identifiers. In an operation declaration, the identifier of an argument is specified immediately after its type and is given by either an identifier token or by one of the keywords that match the ArgumentNameKeyword symbol. If one of these keywords is used, it need not be escaped with a leading underscore.
</p>

<pre class="syntax">
interface interface_identifier {
  `return_type^i `operation_identifier^i(argument_type `argument_identifier^mk /* , ... */);
}
</pre>

<div class="grammar">
-ArgumentNameKeyword
</div>

<p>
演算~引数に `identifier$g ~tokが利用された場合、その`識別子$はその~tokから先頭の
`U+005F LOW LINE ("_")^char
文字（ underscore ）を取り除いた値になる。
代わりにいずれかの `ArgumentNameKeyword$g ~keyword~tokが利用された場合、演算~引数の`識別子$は単にその~tokになる。
◎
If an identifier token is used, then the identifier of the operation argument is the value of that token with any leading U+005F LOW LINE ("_") character (underscore) removed. If instead one of the ArgumentNameKeyword keyword token is used, then the identifier of the operation argument is simply that token.
</p>

<p>
上に示されたどの~IDL構成子のどの`識別子$も
`constructor^l, `toString^l, `toJSON^l
になっては~MUST_NOT。
また、文字
`U+005F LOW LINE ("_")^char
から始まっては~MUST_NOT。
これらは
`予約済み識別子@
と呼ばれる。
◎
The identifier of any of the abovementioned IDL constructs must not be “constructor”, “toString”, “toJSON”, or begin with a U+005F LOW LINE ("_") character. These are known as reserved identifiers.
</p>

<p class="note">注記：
後の節にて、一部の特定0の構成子に対しては，識別子の名前に更なる制約が課され得る。
◎
Note: Further restrictions on identifier names for particular constructs may be made in later sections.
</p>

<p>
所与の実装が~supportする `~IDL片$の集合に属する、どの［
`~ifc$ ／
`名前空間$ ／
`辞書$ ／
`列挙$ ／
`呼戻~関数$ ／
`~typedef$
］の`識別子$も，他のそれと互いに同じになっては~MUST_NOT。
◎
Within the set of IDL fragments that a given implementation supports, the identifier of every interface, namespace, dictionary, enumeration, callback function and typedef must not be the same as the identifier of any other interface, namespace, dictionary, enumeration, callback function or typedef.
</p>

<p>
`~IDL片$の中における`定義$への参照が、参照~先の定義の宣言より後に現れる必要はない。
参照は複数の`~IDL片$をまたがることもできる。
◎
Within an IDL fragment, a reference to a definition need not appear after the declaration of the referenced definition. References can also be made across IDL fragments.
</p>

<div class="example">
<p>
したがって，次の`~IDL片$は妥当である：
◎
Therefore, the following IDL fragment is valid:
</p>

<pre class="idl-code">
interface B : A {
  void f(SequenceOfLongs x);
};

interface A {
};

typedef sequence&lt;long&gt; SequenceOfLongs;
</pre>
</div>


<div class="example">
<p>
`定義$／`~ifc~mb$に，`識別子$を与える例を、次の`~IDL片$に示す：
◎
The following IDL fragment demonstrates how identifiers are given to definitions and interface members.
</p>

<pre class="idl-code">
// <span class="comment"
	title="Typedef identifier: &quot;number&quot;"
>~typedef識別子： `number^l</span>
typedef double number;

// <span class="comment"
	title="Interface identifier: &quot;System&quot;"
>~ifc識別子： `System^l</span>
interface System {

  // <span class="comment"
	title="Operation identifier:          &quot;createObject&quot;"
>演算~識別子： `createObject^l</span>
  // <span class="comment"
	title="Operation argument identifier: &quot;interface&quot;"
>演算~引数~識別子： `interface^l</span>
  object createObject(DOMString _interface);

  // <span class="comment"
	title="Operation argument identifier: &quot;interface&quot;"
>演算~引数~識別子： `interface^l</span>
  sequence&lt;object&gt; getObjects(DOMString interface);

  // <span class="comment"
	title="Operation has no identifier; it declares a getter."
>演算は識別子を持たない。取得子を宣言する。</span>
  getter DOMString (DOMString keyName);
};

// <span class="comment"
	title="Interface identifier: &quot;TextField&quot;"
>~ifc識別子： `TextField^l</span>
interface TextField {

  // <span class="comment"
	title="Attribute identifier: &quot;const&quot;"
>属性~識別子： `const^l</span>
  attribute boolean _const;

  // <span class="comment"
	title="Attribute identifier: &quot;value&quot;"
>属性~識別子： `value^l</span>
  attribute DOMString? _value;
};
</pre>

<p>
`TextField^T `~ifc$
の二番目の`属性$は（ `value^l は~IDL文法の~keywordではないので） underscore で~escapeする必要はないが、属性の`識別子$を得る際には，依然として~escapeは外される。
◎
Note that while the second attribute on the TextField interface need not have been escaped with an underscore (because “value” is not a keyword in the IDL grammar), it is still unescaped to obtain the attribute’s identifier.
</p>
</div>
		</section>
		<section id="idl-interfaces">
<h3 title="Interfaces">2.2. ~ifc</h3>


<p>
`~IDL片$は~obj指向~systemの記述に利用される。
その種の~systemにおいては、~objは同一性（ identity ）を持つ実体であり，状態と挙動の~encapsulationである。
`~ifc@
とは、その~ifcを実装する~objが公開することになる，何らかの状態や挙動を宣言するための，`定義$（
`Interface$g ／
`callback^sym `Interface$g
いずれかに合致）である。
◎
IDL fragments are used to describe object oriented systems. In such systems, objects are entities that have identity and which are encapsulations of state and behavior. An interface is a definition (matching Interface or callback Interface) that declares some state and behavior that an object implementing that interface will expose.
</p>

<pre class="syntax">
interface `identifier^i {
  /* interface_members... */
};
</pre>

<p>
~ifcは、~ifc宣言の波括弧の合間に現れる，一連の
`~ifc~mb@
— `定数$, `属性$, `演算$, その他の宣言 —
が成す集合（ `InterfaceMembers$g に合致）の仕様である。
属性は，その~ifcを実装する~objが公開することになる状態を記述し、演算は，~obj上で呼出せる挙動を記述する。
定数は，~system内の~objの利用者の便宜のために公開される，有名~定数~値を宣言する。
◎
An interface is a specification of a set of interface members (matching InterfaceMembers), which are the constants, attributes, operations and other declarations that appear between the braces in the interface declaration. Attributes describe the state that an object implementing the interface will expose, and operations describe the behaviors that can be invoked on the object. Constants declare named constant values that are exposed as a convenience to users of objects in the system.
</p>

<p>
~Web~IDLの~ifcは，その~ifcを実装する~objがどのように挙動するかを記述する。
~obj指向~言語のための言語束縛においては、個々の~IDL~ifcを実装する~objは，［
~objの状態を検分したり改変する仕方，~ifcに記述された挙動を呼出す仕方
］を提供することが期待されている。
◎
Interfaces in Web IDL describe how objects that implement the interface behave. In bindings for object oriented languages, it is expected that an object that implements a particular IDL interface provides ways to inspect and modify the object’s state and to invoke the behavior described by the interface.
</p>

<p>
~ifcは，別の~ifc（の~mb）を
`継承-@
するようにも定義し得る。
~ifcの識別子に文字
`U+003A COLON (":")^char
と`識別子$が後続している場合、後者の識別子が，継承される~ifcを識別する。
ある~ifc %I を継承する~ifcを実装する~objは， %I も実装する。
~objはしたがって， %I からの~ifc~mbに対応する~mbも持つことになる。
◎
An interface can be defined to inherit from another interface. If the identifier of the interface is followed by a U+003A COLON (":") character and an identifier, then that identifier identifies the inherited interface. An object that implements an interface that inherits from another also implements that inherited interface. The object therefore will also have members that correspond to the interface members from the inherited interface.
</p>

<pre class="syntax">
interface `identifier^i : `identifier_of_inherited_interface^mk {
  /* interface_members... */
};
</pre>

<p>
~mbが現れる順序は、
<a href="#es-interfaces">~JS言語束縛</a>
における~prop列挙においては，有意になる。
◎
The order that members appear in has significance for property enumeration in the ECMAScript binding.
</p>

<p>
~ifcは、継承される~ifcの~mbと同じ名前を持つ，~ifc~mbを指定してもよい。
派生~ifcを実装する~objは、派生~ifc上でそれらの~mbを公開することになる。
その~obj上で上書きされた~mbに~accessし得るかどうかは、言語束縛~特有になる。
◎
Interfaces may specify an interface member that has the same name as one from an inherited interface. Objects that implement the derived interface will expose the member on the derived interface. It is language binding specific whether the overridden member can be accessed on the object.
</p>

<div class="example">
<p>
次の２つの~ifcを考える
◎
Consider the following two interfaces.
</p>

<pre class="idl-code">
interface A {
  void f();
  void g();
};

interface B : A {
  void f();
  void g(DOMString x);
};
</pre>

<p>
~JS言語束縛においては、
`B^T の~instanceは，次の様な原型鎖を持つことになる：
◎
In the ECMAScript language binding, an instance of B will have a prototype chain that looks like the following:
</p>

<div style="white-space:pre;margin-left:2em;">
[ `Object.prototype^v ： `Object^t 原型~obj]
              ↑
[ `A.prototype^v ： `A^T の~ifc原型~obj]
              ↑
[ `B.prototype^v ： `B^T の~ifc原型~obj]
              ↑
[ `B^T の~instance]</div>

<!-- 
[Object.prototype: the Object prototype object]
[B.prototype: interface prototype object for B]
[instanceOfB]
 -->
<p>
~JSにおける
`instanceOfB.f()^c
の~callは、
`B^T 上で定義された f を呼出すことになる。<!-- ＊ f -->
しかしながら， `A^T 上の f も、依然として
`A.prototype.f.call(instanceOfB)^c
の~callにより， `B^T を実装する~obj上で呼出せる。
◎
Calling instanceOfB.f() in ECMAScript will invoke the f defined on B. However, the f from A can still be invoked on an object that implements B by calling A.prototype.f.call(instanceOfB).
</p>

</div>

<p>
所与の~ifc %A の
`被継承~ifc@
とは、［
%A が直接的にまたは間接的に継承する，すべての~ifc
］からなる集合である。
%A が 他の~ifcを`継承-$しない場合、集合は空である。
他の場合、その集合には， %A が継承する~ifc %B と %B の`被継承~ifc$すべてが含まれる。
◎
The inherited interfaces of a given interface A is the set of all interfaces that A inherits from, directly or indirectly. If A does not inherit from another interface, then the set is empty. Otherwise, the set includes the interface B that A inherits from and all of B’s inherited interfaces.
</p>

<p>
~ifcは、その継承階層が循環するように宣言されては~MUST_NOT。
すなわち、~ifc %A は自身を継承することも,
%A を継承する別の~ifc %B を継承することもできない，等々。
◎
An interface must not be declared such that its inheritance hierarchy has a cycle. That is, an interface A cannot inherit from itself, nor can it inherit from another interface B that inherits from A, and so on.
</p>

<p>
~ifcの一般的な多重~継承は~supportされず，~objは~ifcの任意の集合を実装することはできないことに注意。
~objは、所与の［
単独の~ifc %A
］を実装するように，すなわち %A の`被継承~ifc$すべてを実装するように，定義できる。
加えて、`~implements文$を利用すれば，［
ある~ifcを実装している~objが，常にある別の~ifcも実装する
］ように定義することもできる。
◎
Note that general multiple inheritance of interfaces is not supported, and objects also cannot implement arbitrary sets of interfaces. Objects can be defined to implement a single given interface A, which means that it also implements all of A’s inherited interfaces. In addition, an implements statement can be used to define that objects implementing an interface will always also implement another interface.
</p>

<p>
各~ifc~mbの前には、`拡張属性$の~list（ `ExtendedAttributeList$g に合致）を置くことができる
— それらは、その~ifc~mbが，言語束縛において どう取扱われるかを制御する。
◎
Each interface member can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how the interface member will be handled in language bindings.
</p>

<pre class="syntax">
interface `identifier^i {

  [`extended_attributes^mk]
  const `type^i `constant_identifier^i = 42;

  [`extended_attributes^mk]
  attribute `type^i `identifier^i;

  [`extended_attributes^mk]
  `return_type^i `identifier^i(/* arguments... */);
};
</pre>


<p>
`呼戻~ifc@
は，その定義の先頭に `callback^c ~keywordを利用する`~ifc$である。
呼戻~ifcは、
`idl-objects$sec
で述べるように，`~platform~obj$ではなく，`利用者~obj$により実装され得るものである。
◎
A callback interface is an interface that uses the callback keyword at the start of its definition. Callback interfaces are ones that can be implemented by user objects and not by platform objects, as described in §2.10 Objects implementing interfaces.
</p>

<pre class="syntax">
callback interface `identifier^i {
  /* interface_members... */
};
</pre>

<p class="note">注記：
似た命名の`呼戻~関数$定義も見よ。
◎
Note: See also the similarly named callback function definition.
</p>

<p>
`呼戻~ifc$は非~呼戻~ifcを`継承-$しては~MUST_NOT。
非~呼戻~ifcは呼戻~ifcを`継承-$しては~MUST_NOT。
呼戻~ifcには`帰結~ifc$が存在しては~MUST_NOT。
◎
Callback interfaces must not inherit from any non-callback interfaces, and non-callback interfaces must not inherit from any callback interfaces. Callback interfaces must not have any consequential interfaces.
</p>

<p>
`呼戻~ifc$上に［
`静的~属性$ ／ `静的~演算$
］が定義されては~MUST_NOT。
◎
Static attributes and static operations must not be defined on a callback interface.
</p>


<div class="advisement">

<p>
仕様~策定者は、既存の~APIの要件の記述に不可欠な場合を除き，単独の`演算$のみを持つ`呼戻~ifc$を定義するべきでない。
代わりに，`呼戻~関数$が利用されるべきである。
◎
Specification authors should not define callback interfaces that have only a single operation, unless required to describe the requirements of existing APIs. Instead, a callback function should be used.
</p>

<p>
`呼戻~ifc$である `EventListener^T の定義は、所与の~prop（この場合は `handleEvent^l ）を伴う`利用者~obj$により その~ifcを実装することが，許容される必要があるものと見なされている、既存の~APIの例である。
新たな~API, あるいは互換性の心配がない~APIのための`呼戻~関数$には、（~JS言語束縛においては） `Function^t ~objのみが許容されることになる。
◎
The definition of EventListener as a callback interface is an example of an existing API that needs to allow user objects with a given property (in this case “handleEvent”) to be considered to implement the interface. For new APIs, and those for which there are no compatibility concerns, using a callback function will allow only a Function object (in the ECMAScript language binding).
</p>
</div>

<p class="issue">
上の警告は，将来に呼戻~ifcを拡張する際には、おそらく適用されるべきではないであろう。
それが単一~演算~呼戻~ifcから取り掛かる良い理由になると見られる。
◎
Perhaps this warning shouldn’t apply if you are planning to extend the callback interface in the future. That’s probably a good reason to start off with a single operation callback interface.
</p>

<p class="issue">
編集者は，［
所与の呼戻~ifcを実装している利用者~obj上で，演算が実装されていない場合
］を~supportする必要があると考えている。
既存の呼戻~ifcを拡張する仕様は、おそらく，実装されていない演算の~callを避けることが求まれるであろう（代わりに何らかの既定の挙動を持たせて）。
従って，演算が実装されているかどうか意味する用語が定義されるべきであろう
—
~JS言語束縛における，~propの有無の検査に対応することになるような。
◎
I think we need to support operations not being implemented on a given user object implementing a callback interface. If specs extending an existing callback interface, we probably want to be able to avoid calling the operations that aren’t implemented (and having some default behavior instead). So we should perhaps define a term that means whether the operation is implemented, which in the ECMAScript binding would correspond to checking for the property’s existence.
</p>

<div class="note">
<p>
関数~引数として
“~propの集まり（ property bag ）”
のような~JS~objをとる~APIを定義する仕様の策定者には、`呼戻~ifc$よりも`辞書$の利用を勧める。
◎
Specification authors wanting to define APIs that take ECMAScript objects as “property bag” like function arguments are suggested to use dictionaries rather than callback interfaces.
</p>

<p>
例えば，次のものは：
◎
For example, instead of this:
</p>

<pre class="idl-code">
callback interface Options {
  attribute DOMString? option1;
  attribute DOMString? option2;
  attribute long? option3;
};

interface A {
  void doTask(DOMString type, Options options);
};
</pre>

<p>
次の様な利用を可能にするために：
◎
to be used like this:
</p>

<pre class="es-code">
var a = getA();  // <span class="comment"
	title="Get an instance of A."
>`A^T の~instanceを取得する。</span>

a.doTask("something", { option1: "banana", option3: 100 });
</pre>

<p>
代わりに，次のように記す：
◎
instead write the following:
</p>

<pre class="idl-code">
dictionary Options {
  DOMString? option1;
  DOMString? option2;
  long? option3;
};

interface A {
  void doTask(DOMString type, optional Options options);
};
</pre>
</div>

<p>
~ifcに対する~IDLは、
`部分的~ifc定義@
（ `partial^sym `PartialInterface$g に合致）を利用して，複数の部分に分割できる。
部分的~ifc定義の`識別子$は、その~ifc定義の識別子と同じで~MUST。
それぞれの部分的~ifcに現れる，すべての~mbは、その~ifc自身の~mbであるものと見なされる。
◎
The IDL for interfaces can be split into multiple parts by using partial interface definitions (matching partial PartialInterface). The identifier of a partial interface definition must be the same as the identifier of an interface definition. All of the members that appear on each of the partial interfaces are considered to be members of the interface itself.
</p>

<pre class="syntax">
interface `SomeInterface^mk {
  /* interface_members... */
};

partial interface `SomeInterface^mk {
  /* interface_members... */
};
</pre>

<p class="note">注記：
部分的~ifc定義の目的は、~ifcの定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補助する所にある。
◎
Note: Partial interface definitions are intended for use as a specification editorial aide, allowing the definition of an interface to be separated over more than one section of the document, and sometimes multiple documents.
</p>

<p>
`~ifc$定義, およびその`部分的~ifc定義$が現れる順序は問題にされない。
◎
The order of appearance of an interface definition and any of its partial interface definitions does not matter.
</p>

<p class="note">注記：
部分的~ifc定義においては、別の~ifcからの`継承-$は指定できない。
継承は元の`~ifc$定義に指定され~MUST。
◎
Note: A partial interface definition cannot specify that the interface inherits from another interface. Inheritance must be specified on the original interface definition.
</p>

<p>
多少の制限もあるが、`部分的~ifc定義$にも，`拡張属性$を指定できる。
次の拡張属性は，部分的~ifc定義に指定されては~MUST_NOT：
`Constructor$x,
`LegacyArrayClass$x
`NamedConstructor$x,
`NoInterfaceObject$x
。
◎
Extended attributes can be specified on partial interface definitions, with some limitations. The following extended attributes must not be specified on partial interface definitions: [Constructor], [LegacyArrayClass], [NamedConstructor], [NoInterfaceObject].
</p>


<p class="note">注記：
`Exposed$x,
`Global$x,
`OverrideBuiltins$x,
`PrimaryGlobal$x,
`SecureContext$x
を除き，上に挙げたものが
この文書に定義される中で`~ifc$に適用し得る`拡張属性$のすべてである。
◎
Note: The above list of extended attributes is all of those defined in this document that are applicable to interfaces except for [Exposed], [Global], [OverrideBuiltins], [PrimaryGlobal], and [SecureContext].
</p>

<p>
`部分的~ifc定義$に指定される
`拡張属性$は
`~ifc$自身に現れるものと見なされる。
◎
Any extended attribute specified on a partial interface definition is considered to appear on the interface itself.
</p>

<p>
関連の言語束縛が，~ifcと［
言語の構成子
］との間の対応付けを決定する。
◎
The relevant language binding determines how interfaces correspond to constructs in the language.
</p>

<p>
~ifcには、次の拡張属性を適用し得る：
`Constructor$x,
`Exposed$x,
`Global$x,
`LegacyArrayClass$x,
`NamedConstructor$x,
`NoInterfaceObject$x,
`OverrideBuiltins$x,
`PrimaryGlobal$x,
`SecureContext$x
。
◎
The following extended attributes are applicable to interfaces: [Constructor], [Exposed], [Global], [LegacyArrayClass], [NamedConstructor], [NoInterfaceObject], [OverrideBuiltins], [PrimaryGlobal], and [SecureContext].
</p>

<div class="grammar">
--CallbackOrInterface
-CallbackRestOrInterface
-Interface
-Partial
-PartialDefinition
-PartialInterface
-InterfaceMembers
-InterfaceMember
-Inheritance
</div>

<div class="example">

<p>
次の`~IDL片$に、２つの相互に参照しあう`~ifc$
— `Human^T と `Dog^T —
の定義~例を示す。
いずれも `Animal^T を継承するので、２つの~ifcいずれかを実装する~objは， `name^M 属性も持つことになる。
◎
The following IDL fragment demonstrates the definition of two mutually referential interfaces. Both Human and Dog inherit from Animal. Objects that implement either of those two interfaces will thus have a name attribute.
</p>

<pre class="idl-code">
interface Animal {
  attribute DOMString name;
};

interface Human : Animal {
  attribute Dog? pet;
};

interface Dog : Animal {
  attribute Human? owner;
};
</pre>
</div>


<div class="example">
<p>
次の`~IDL片$は
DOM `~ifc$の一部を単純化した~versionを定義する。
うち１個は`呼戻~ifc$である。
◎
The following IDL fragment defines simplified versions of a few DOM interfaces, one of which is a callback interface.
</p>

<pre class="idl-code">
interface Node {
  readonly attribute DOMString nodeName;
  readonly attribute Node? parentNode;
  Node appendChild(Node newChild);
  void addEventListener(DOMString type, EventListener listener);
};

callback interface EventListener {
  void handleEvent(Event event);
};
</pre>

<p>
`EventListener^T ~ifcは呼戻~注釈付きの~ifcなので，`利用者~obj$により実装し得る：
◎
Since the EventListener interface is annotated callback interface, user objects can implement it:
</p>

<pre class="es-code">
var node = getNode();  // <span class="comment" id="cp-get-Node"
	title="Obtain an instance of Node."
>`Node^T の~instanceを得る。</span>

var listener = {
  handleEvent: function(event) {
    // ...
  }
};
node.addEventListener("click", listener);            // <span class="comment"
	title="This works."
>これは機能する。</span>

node.addEventListener("click", function() { ... });  // <span class="comment"
	title="As does this."
>これと同様に。</span>
</pre>

<p>
しかしながら，利用者~objは
`Node^T を実装することはできない：
◎
It is not possible for a user object to implement Node, however:
</p>

<pre class="es-code">
var node = getNode();  // <!--cp-get-Node-->

var newNode = {
  nodeName: "span",
  parentNode: null,
  appendChild: function(newchild) {
    // ...
  },
  addEventListener: function(type, listener) {
    // ...
  }
};
node.appendChild(newNode);  // <span class="comment"
	title="This will throw a TypeError exception."
>`TypeError^T 例外が投出されることになる。</span>
</pre>
</div>

			<section id="idl-constants">
<h4 title="Constants">2.2.1. 定数</h4>


<p>
`定数@
は、定数~値を名前に束縛するために利用される，宣言（ `Const$g に合致）である。
定数は`~ifc$に現れ得る。
◎
A constant is a declaration (matching Const) used to bind a constant value to a name. Constants can appear on interfaces.
</p>


<p class="advisement">
過去においては，定数は、主に，有名~整数~codeを列挙する~styleで定義されていた。
~Web~platformは、文字列の利用を支持し，この設計patternから離れつつある。
定数の定義を要する仕様~策定者は、`論ML^。
◎
Constants have in the past primarily been used to define named integer codes in the style of an enumeration. The Web platform is moving away from this design pattern in favor of the use of strings. Specification authors who wish to define constants are strongly advised to discuss this on the public-script-coord@w3.org mailing list before proceeding.
</p>

<pre class="syntax">
const `type^i `constant_identifier^i = 42;
</pre>

<p>
`定数$の`識別子$は［
同じ~ifc上で定義される別の`~ifc~mb$
］の識別子と同じになっては~MUST_NOT。
また、識別子が［
`length^l ／ `name^l ／ `prototype^l
］になっては~MUST_NOT。
◎
The identifier of a constant must not be the same as the identifier of another interface member defined on the same interface.  The identifier also must not be “length”, “name” or “prototype”.
</p>

<p class="note">
これらの名前は、すべての `Function^t ~objに存在する~propの名前である。
◎
Note: These three names are the names of properties that exist on all Function objects.
</p>

<p>
定数の型（ `ConstType$g に合致）は、［
`~primitive型$または`~nullable$~primitive型
］で~MUST。
`識別子$が利用される場合、その識別子は［
~primitive型または~nullable~primitive型<!-- numeric？ -->
］の`~typedef$を参照し~MUST。
◎
The type of a constant (matching ConstType) must not be any type other than a primitive type or a nullable primitive type. If an identifier is used, it must reference a typedef whose type is a primitive type or a nullable primitive type.
</p>

<div class="p">
<p>
定数~宣言の `ConstValue$g 部は定数の値を与え、次のいずれかの~tokをとり得る：
</p>

<ul ><li>２つの真偽~literal（ `true^c と `false^c ）
</li><li>`null^c
</li><li>`integer$g
</li><li>`float$g
</li><li>３つの特別な浮動小数点~定数~値（ `-Infinity^c, `Infinity^c, `NaN^c ）
</li></ul>

<p class="trans-note">【
この訳では、これらの~tokを総称して，
`定数~tok@
と呼ぶことにする。
】</p>
◎
The ConstValue part of a constant declaration gives the value of the constant, which can be one of the two boolean literal tokens (true and false), the null token, an integer token, a float token, or one of the three special floating point constant values (-Infinity, Infinity and NaN).
</div>

<p class="note">注記：
文字列や空~連列に加え，これらの値も［
辞書~mbの`辞書既定値^や, 随意~引数の`既定~値$
］を指定するために利用できる。
文字列や空~連列 `[]^c は、`定数$の値には利用できないことに注意。
◎
Note: These values – in addition to strings and the empty sequence – can also be used to specify the default value of a dictionary member or of an optional argument. Note that strings and the empty sequence [] cannot be used as the value of a constant.
</p>

<p>
真偽~literal~tokの値は、それぞれ，
~IDL `boolean$T 値［
`true^V, `false^V
］になる。
◎
The value of the boolean literal tokens true and false are the IDL boolean values true and false.
</p>

<p>
`integer$g ~tokの値は、次に従って決定される整数~値になる：
◎
The value of an integer token is an integer whose value is determined as follows:
</p>

<ol class="algorithm">
	<li>
%S := `integer$g ~tokに合致する文字~並び
◎
Let S be the sequence of characters matched by the integer token.
</li>
	<li>
%sign := ［
%S の先頭が
`U+002D HYPHEN-MINUS ("-")^char
ならば −1 ／
~ELSE_ 1
］
◎
Let sign be −1 if S begins with U+002D HYPHEN-MINUS ("-"), and 1 otherwise.
</li>
	<li>
<p>
%base := %S から先頭の
`U+002D HYPHEN-MINUS ("-")^char
は（もしあれば）除いた残りの部分の，頭部の文字~並びに基づく基数：
◎
Let base be the base of the number based on the characters that follow the optional leading U+002D HYPHEN-MINUS ("-") character:
</p>
		<dl class="switch">
<dt>`0X^l （
`U+0030 DIGIT ZERO ("0")^char,
`U+0058 LATIN CAPITAL LETTER X ("X")^char
）</dt>
<dt>`0x^l （
`U+0030 DIGIT ZERO ("0")^char,
`U+0078 LATIN SMALL LETTER X ("x")^char
）</dt>
<dd>
基数は 16
◎
The base is 16.
</dd>
<dt>`U+0030 DIGIT ZERO ("0")^char</dt>
<dd>
基数は 8
◎
The base is 8.
</dd>
<dt title="Otherwise">その他</dt>
<dd>
基数は 10
◎
The base is 10.
</dd>
		</dl>
	</li>
	<li>
%number := %S から頭部の ［
`U+002D HYPHEN-MINUS ("-")^char ／
基数を指示する文字~並び
］を（もしあれば）除いた残りの文字すべてを，指定された基数 %base に基づいて整数に解釈した結果
◎
Let number be the result of interpreting all remaining characters following the optional leading U+002D HYPHEN-MINUS ("-") character and any characters indicating the base as an integer specified in base base.
</li>
	<li>
~RET %sign × %number
◎
Return sign × number.
</li>
</ol>

<p>
`integer$g ~tokの型は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型と同じである。
`integer$g ~tokの値は、
`idl-types$sec
で与えられる，その型の値として妥当な範囲に入ら~MUST。
◎
The type of an integer token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of. The value of the integer token must not lie outside the valid range of values for its type, as given in §2.11 Types.
</p>

<p id="float-token-value">
`float$g ~tokの値は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型に依存して，単精度, 倍精度 いずれかの IEEE 754 浮動小数点数になり、次に従って決定される：
◎
The value of a float token is either an IEEE 754 single-precision floating point number or an IEEE 754 double-precision floating point number, depending on the type of the constant, dictionary member or optional argument it is being used as the value for, determined as follows:
</p>

<ol class="algorithm">
	<li>
%S := `float$g ~tokに合致する文字~並び
◎
Let S be the sequence of characters matched by the float token.
</li>
	<li>
%result := %S を~JS `NumericLiteral^ として構文解析して得られる Mathematical Value
◎
Let result be the Mathematical Value that would be obtained if S were parsed as an ECMAScript NumericLiteral.
</li>
	<li>
~IF
`float$g ~tokが `float$T または `unrestricted float$T の値として利用されている
~THEN
~RET %result に最も近い IEEE 754 単精度 浮動小数点数
`IEEE-754$r
◎
If the float token is being used as the value for a float or unrestricted float, then the value of the float token is the IEEE 754 single-precision floating point number closest to result.
</li>
	<li>
~ELSE （すなわち `float$g ~tokが `double$T または `unrestricted double$T の値として利用されている）
~THEN
~RET %result に最も近い IEEE 754 倍精度 浮動小数点数
◎
Otherwise, the float token is being used as the value for a double or unrestricted double, and the value of the float token is the IEEE 754 double-precision floating point number closest to result. [IEEE-754]
</li>
</ol>

<p>
`Infinity^c, `-Infinity^c, `NaN^c
のいずれかとして指定された定数~値は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型に依存して，単精度, 倍精度 いずれかの IEEE 754 浮動小数点数になり、次に従って決定される：
◎
The value of a constant value specified as Infinity, -Infinity or NaN is either an IEEE 754 single-precision floating point number or an IEEE 754 double-precision floating point number, depending on the type of the constant, dictionary member or optional argument is is being used as the value for:
</p>


<dl class="switch">
	<dt>
`unrestricted float$T 型の定数~値 `Infinity^c
◎
Type unrestricted float, constant value Infinity
</dt>
	<dd>
値は IEEE 754 単精度，正の無限~値
◎
The value is the IEEE 754 single-precision positive infinity value.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `Infinity^c
◎
Type unrestricted double, constant value Infinity
</dt>
	<dd>
値は IEEE 754 倍精度，正の無限~値
◎
The value is the IEEE 754 double-precision positive infinity value.
</dd>
	<dt>
`unrestricted float$T 型の定数~値 `-Infinity^c
◎
Type unrestricted float, constant value -Infinity
</dt>
	<dd>
値は IEEE 754 単精度，負の無限~値
◎
The value is the IEEE 754 single-precision negative infinity value.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `-Infinity^c
◎
Type unrestricted double, constant value -Infinity
</dt>
	<dd>
値は IEEE 754 倍精度，負の無限~値
◎
The value is the IEEE 754 double-precision negative infinity value.
</dd>
	<dt>
`unrestricted float$T 型の定数~値 `NaN^c
◎
Type unrestricted float, constant value NaN
</dt>
	<dd>
値は~bit~pattern 0x7fc00000 の， IEEE 754 単精度 NaN
◎
The value is the IEEE 754 single-precision NaN value with the bit pattern 0x7fc00000.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `NaN^c
◎
Type unrestricted double, constant value NaN
</dt>
	<dd>
値は~bit~pattern 0x7ff8000000000000 の， IEEE 754 倍精度 NaN
◎
The value is the IEEE 754 double-precision NaN value with the bit pattern 0x7ff8000000000000.
</dd>
</dl>

<p>
`float$g ~tokの型は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型と同じになる。
`float$g ~tokの値は、
`idl-types$sec
で与えられるように，その型の値として妥当な範囲の外にあっては~MUST_NOT。
また、［
`Infinity^c, `-Infinity^c, `NaN^c
］が［
`float$T や `double$T
］の値として利用されては~MUST_NOT。
◎
The type of a float token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of. The value of the float token must not lie outside the valid range of values for its type, as given in §2.11 Types. Also, Infinity, -Infinity and NaN must not be used as the value of a float or double.
</p>

<p>
`null^c ~tokの値は、`~nullable型$に属する特別な `null^V 値である。
`null^c ~tokの型は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型と同じになる。
◎
The value of the null token is the special null value that is a member of the nullable types. The type of the null token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of.
</p>

<p>
%VT を定数にあてがわれる値の型,
%DT を［ 定数／辞書~mb／随意~引数 ］自身の型とするとき、これらの型は互換，すなわち %DT と %VT が一致するか, または
%DT はその`内縁~型$が %VT であるような`~nullable型$でなければ~MUST。
◎
If VT is the type of the value assigned to a constant, and DT is the type of the constant, dictionary member or optional argument itself, then these types must be compatible, which is the case if DT and VT are identical, or DT is a nullable type whose inner type is VT.
</p>

<p>
`定数$は
それが現れる`~ifc$の個々の~instanceには結付けられない。
`定数$が~instanceにも公開されるかどうかは
言語束縛~特有になる。
◎
Constants are not associated with particular instances of the interface on which they appear. It is language binding specific whether constants are exposed on instances.
</p>

<div class="note">

<p>
~JS言語束縛では，しかしながら、`定数$が宣言されている~IDL`~ifc$を実装する~objを通して，`定数$への~accessが許容される。
例えば次の~IDLでは：
◎
The ECMAScript language binding does however allow constants to be accessed through objects implementing the IDL interfaces on which the constants are declared. For example, with the following IDL:
</p>

<pre class="idl-code">
interface A {
  const short rambaldi = 47;
};
</pre>

<p>
~JSにおいては、この定数~値は，［
`A.rambaldi^c および (`A^T の~instance)`.rambaldi^c
］として~accessできる。
◎
the constant value can be accessed in ECMAScript either as A.rambaldi or instanceOfA.rambaldi.
</p>
</div>

<p>
定数には、次の拡張属性を適用し得る：
`Exposed$x,
`SecureContext$x
◎
The following extended attributes are applicable to constants: [Exposed], [SecureContext].
</p>

<div class="grammar">
-Const
-ConstValue
-BooleanLiteral
-FloatLiteral
-ConstType
</div>


<div class="example">
<p>
次の`~IDL片$に、上の型の`定数$を定義する例を示す。
◎
The following IDL fragment demonstrates how constants of the above types can be defined.
</p>

<pre class="idl-code">
interface Util {
  const boolean DEBUG = false;
  const octet LF = 10;
  const unsigned long BIT_MASK = 0x0000fc00;
  const double AVOGADRO = 6.022e23;
};
</pre>

</div>
			</section>
			<section id="idl-attributes">
<h4 title="Attributes">2.2.2. 属性</h4>


<p>
`属性@
（
`inherit^sym `ReadOnly$g `AttributeRest$g ／
`static^sym `ReadOnly$g `AttributeRest$g ／
`stringifier^sym `ReadOnly$g `AttributeRest$g ／
`ReadOnly$g `AttributeRest$g
いずれかに合致）は、［
`~ifc$を実装している~objが，［
所与の［
型, `識別子$
］により，値の取得0や（一部の場合は）変更を行える
］~data~fieldを持つことになる
］ことを宣言するために利用される，
`~ifc~mb$である。
属性は次の２種類に分けられる：
◎
An attribute is an interface member (matching inherit ReadOnly AttributeRest, static ReadOnly AttributeRest, stringifier ReadOnly AttributeRest, or ReadOnly AttributeRest) that is used to declare data fields with a given type and identifier whose value can be retrieved and (in some cases) changed. There are two kinds of attributes:
</p>

<ol>
	<li>
<p>
`正則~属性$は、`~ifc$を実装している~objが，所与の`識別子$を伴う~data~field~mbを持つことになることを宣言するために利用される。
◎
regular attributes, which are those used to declare that objects implementing the interface will have a data field member with the given identifier
</p>

<pre class="syntax">
interface `interface_identifier^i {
  attribute `type^i `identifier^i;
};
</pre>

	</li>
	<li>
<p>
`静的~属性$は、その~ifcを実装している個々の~objには結付けられない属性を宣言するために利用される。
◎
static attributes, which are used to declare attributes that are not associated with a particular object implementing the interface
</p>

<pre class="syntax">
interface `interface_identifier^i {
  static attribute `type^i `identifier^i;
};
</pre>

	</li>
</ol>

<p>
`static^c ~keywordを伴わない属性は
`正則~属性@
を宣言する。
そうでなければ，`静的~属性$を宣言する。
◎
If an attribute has no static keyword, then it declares a regular attribute. Otherwise, it declares a static attribute.
</p>


<p>
`属性$の`識別子$は［
同じ`~ifc$上に定義される別の`~ifc~mb$の識別子
］と同じになっては~MUST_NOT。
静的~属性の識別子が `prototype^l になっては~MUST_NOT。
◎
The identifier of an attribute must not be the same as the identifier of another interface member defined on the same interface. The identifier of a static attribute must not be “prototype”.
</p>

<p>
属性の型は、 `attribute^c ~keywordの後に現れる
型（ `Type$g に合致）で与えられる。
`Type$g が［
`識別子$, または `?^c が後続する識別子
］である場合、その識別子は［
~ifc, `列挙$, `呼戻~関数$, `~typedef$
］のいずれかとして識別され~MUST。
◎
The type of the attribute is given by the type (matching Type) that appears after the attribute keyword. If the Type is an identifier or an identifier followed by ?, then the identifier must identify an interface, enumeration, callback function or typedef.
</p>

<p>
属性の型は、~typedefの解決-後に，次に挙げる型, あるいはその`~nullable型$になっては~MUST_NOT。
◎
The type of the attribute, after resolving typedefs, must not be a nullable or non-nullable version of any of the following types:
</p>


<ul id="cp-nullable-type-list">
	<li>
`連列~型$
◎
a sequence type
</li>
	<li>
`辞書~型$
◎
a dictionary type
</li>
	<li>
`~record型$
◎
a record type
</li>
	<li>
その`平坦化~mb型$に［
［ ~nullable／非~nullable ］の連列~型 ／ 辞書 ／ ~record<!-- 区切り？ -->
］を含んでいるような，`共用体~型$
<span class="trans-note">【
平坦化~mb型は~nullableを含み得ないので，この “~nullable” の記述は不要では？
】</span>
◎
a union type that has a nullable or non-nullable sequence type, dictionary, or record as one of its flattened member types
</li>
</ul>


<p>
`attribute^c ~keywordの前に `readonly^c ~keywordが利用されている場合、属性は
`読専@（ readonly, 読み取り専用）
になる。
［
読専の属性が定義されている~ifc
］を実装する~objにおいては、その属性に対する代入は許容されないことになる。
代入が、単に言語において許容されないのか,
無視されるのか,
あるいは例外が投出されるのか，については、言語束縛~特有になる。
◎
The attribute is read only if the readonly keyword is used before the attribute keyword. An object that implements the interface on which a read only attribute is defined will not allow assignment to that attribute. It is language binding specific whether assignment is simply disallowed by the language, ignored or an exception is thrown.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  readonly attribute `type^i `identifier^i;
};
</pre>

<p>
`読専$でない`正則~属性$は、先祖の~ifcからその
`取得子を継承-@
するように宣言できる。
これにより、先祖~ifcの読専の属性を，派生~ifc上で~writableにできる。
属性は、その宣言が `inherit^c を伴うとき，`取得子を継承-$するものとされる。
その属性が取得子を継承する読専の属性は、［
同じ識別子の属性が定義されている，先祖の~ifc
］のうち，最も末端の~ifcに属する属性である。
<!-- readonlyとは限らない？ -->
取得子を［
継承する側, される側
］の属性の型は同じで~MUST。
また、 `inherit^c が［
`読専$の属性／`静的~属性$
］に現れては~MUST_NOT。
◎
A regular attribute that is not read only can be declared to inherit its getter from an ancestor interface. This can be used to make a read only attribute in an ancestor interface be writable on a derived interface. An attribute inherits its getter if its declaration includes inherit in the declaration. The read only attribute from which the attribute inherits its getter is the attribute with the same identifier on the closest ancestor interface of the one on which the inheriting attribute is defined. The attribute whose getter is being inherited must be of the same type as the inheriting attribute, and inherit must not appear on a read only attribute or a static attribute.
</p>

<pre class="syntax">
interface `Ancestor^i {
  readonly attribute `TheType^i `theIdentifier^i;
};

interface `Derived^i : `Ancestor^i {
  inherit attribute `TheType^i `theIdentifier^i;
};
</pre>

<p>
`正則~属性$の宣言に `stringifier^c ~keywordが利用されている場合、その~ifcを実装している~objが文字列化されるときに，その属性の値になることを指示する。
詳細は
`idl-stringifiers$sec
に。
◎
When the stringifier keyword is used in a regular attribute declaration, it indicates that objects implementing the interface will be stringified to the value of the attribute. See §2.2.4.2 Stringifiers for details.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier attribute DOMString `identifier^i;
};
</pre>

<p id="callback-attribute-exceptions">
実装が
`利用者~obj$上の`属性$の値の取得-または設定-を試みたときに（例えば 呼戻~objが実装に供されているとき），その試みによる~~結果，例外が投出される場合、他から指定されない限り，その例外は［
実装からその属性への~accessを生じさせた，利用者~code
］まで伝播することになる。
同様に、属性の取得-により返される値を~IDL型の値に変換できない場合、それにより生じた例外も［
実装からその属性の値の取得を試みさせた，利用者~code
］まで伝播することになる。
◎
If an implementation attempts to get or set the value of an attribute on a user object (for example, when a callback object has been supplied to the implementation), and that attempt results in an exception being thrown, then, unless otherwise specified, that exception will be propagated to the user code that caused the implementation to access the attribute. Similarly, if a value returned from getting the attribute cannot be converted to an IDL type, then any exception resulting from this will also be propagated to the user code that resulted in the implementation attempting to get the value of the attribute.
</p>


<p>
［
正則／静的
］属性には、次の`拡張属性$を適用し得る：
`Clamp$x,
`EnforceRange$x,
`Exposed$x,
`SameObject$x,
`SecureContext$x,
`TreatNullAs$x
◎
The following extended attributes are applicable to regular and static attributes: [Clamp], [EnforceRange], [Exposed], [SameObject], [SecureContext], [TreatNullAs].
</p>

<p>
次の`拡張属性$は、正則~属性のみに適用し得る：
`LenientSetter$x,
`LenientThis$x,
`PutForwards$x,
`Replaceable$x,
`Unforgeable$x
◎
The following extended attributes are applicable only to regular attributes: [LenientSetter], [LenientThis], [PutForwards], [Replaceable], [Unforgeable].
</p>


<div class="grammar">
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteAttribute
AttributeRest
AttributeName
AttributeNameKeyword
Inherit
ReadOnly
</div>

<div class="example">
<p>
次の`~IDL片$に，`~ifc$上にて`属性$を宣言する例を示す：
◎
The following IDL fragment demonstrates how attributes can be declared on an interface:
</p>

<pre class="idl-code">
interface Animal {

  // <span class="comment"
	title="A simple attribute that can be set to any string value."
>単純な，任意の文字列に設定され得る属性。</span>
  readonly attribute DOMString name;

  // <span class="comment"
	title="An attribute whose value can be assigned to."
>値を代入できる属性。</span>
  attribute unsigned short age;
};

interface Person : Animal {

  /* <span class="comment"
	title="An attribute whose getter behavior is inherited from Animal, and need not be
specified in the description of Person."
>取得子の挙動を `Animal^T から継承する属性。
`Person^T の記述にて指定する必要はない。</span> */
  inherit attribute DOMString name;
};
</pre>
</div>
			</section>
			<section id="idl-operations">
<h4 title="Operations">2.2.3. 演算</h4>


<p>
`演算@
（
`static^sym `OperationRest$g ／
`stringifier^sym `OperationRest$g ／
`serializer^sym `OperationRest$g ／
`ReturnType$g `OperationRest$g ／
`SpecialOperation$g
いずれかに合致）は、その~ifcを実装している~obj上で呼出せる挙動を定義する，
`~ifc~mb$である。
演算には次の３つの種類がある：
◎
An operation is an interface member (matching static OperationRest, stringifier OperationRest, serializer OperationRest, ReturnType OperationRest or SpecialOperation) that defines a behavior that can be invoked on objects implementing the interface. There are three kinds of operation:
</p>

<dl>
	<dt>`正則~演算$</dt>
	<dd>
その`~ifc$を実装している~objが、所与の`識別子$を伴う~methを持つことになることを宣言するために利用される。
◎
regular operations, which are those used to declare that objects implementing the interface will have a method with the given identifier
</dd>
	<dd>
<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(/* arguments... */);
};
</pre>
	</dd>

	<dt>`特殊~演算$</dt>
	<dd>
~objの~indexingや文字列化など、その~ifcを実装している~obj上の特殊な挙動を宣言するために利用される。
◎
special operations, which are used to declare special behavior on objects implementing the interface, such as object indexing and stringification
</dd>
	<dd>

<pre class="syntax">
interface `interface_identifier^i {
  /* special_keywords... */ `return_type^i `identifier^i(/* arguments... */);
  /* special_keywords... */ `return_type^i (/* arguments... */);
};
</pre>
	</dd>

	<dt>`静的~演算$</dt>
	<dd>
その~ifcを実装している個々の~objには結付けられない演算を宣言するために利用される。
◎
static operations, which are used to declare operations that are not associated with a particular object implementing the interface
</dd>
	<dd>
<pre class="syntax">
interface `interface_identifier^i {
  static `return_type^i `identifier^i(/* arguments... */);
};
</pre>
	</dd>
</dl>

<p>
識別子を持ち, かつ
`static^sym ~keywordがない演算は、
`正則~演算@
を宣言する。
１個~以上の`特殊~keyword$（すなわち，［
`Special$g に合致する~keyword, または
`stringifier^c ~keyword
］）が宣言に利用されている演算は，`特殊~演算$を宣言する。
演算を，正則~演算と特殊~演算を兼ねるように宣言することもできる。
特殊~演算についての詳細は
`idl-special-operations$sec
に。
`正則~演算$は、`~ifc~mb$になり得ることに加え，`名前空間~mb$にもなり得ることに注意。
◎
If an operation has an identifier but no static keyword, then it declares a regular operation. If the operation has one or more special keywords used in its declaration (that is, any keyword matching Special, or the stringifier keyword), then it declares a special operation. A single operation can declare both a regular operation and a special operation; see §2.2.4 Special operations for details on special operations. Note that in addition to being interface members, regular operations can also be namespace members.
</p>

<p>
識別子を持たない演算は、いずれかの特殊~keywordを利用して，`特殊~演算$として宣言され~MUST。
◎
If an operation has no identifier, then it must be declared to be a special operation using one of the special keywords.
</p>

<p>
`正則~演算$／`静的~演算$の識別子は、同じ`~ifc$上に定義される`定数$や`属性$の識別子と同じになっては~MUST_NOT。
静的~演算の識別子が `prototype^l になっては~MUST_NOT。
◎
The identifier of a regular operation or static operation must not be the same as the identifier of a constant or attribute defined on the same interface. The identifier of a static operation must not be “prototype”.
</p>

<p class="note">注記：
しかしながら、識別子をその~ifc上の別の演算と同じにすることはできる。
演算の多重定義は、これにより指定される。
◎
Note: The identifier can be the same as that of another operation on the interface, however. This is how operation overloading is specified.
</p>

<p>
`静的~演算$の`識別子$は、同じ`~ifc$上に定義される`正則~演算$の識別子と同じになっては~MUST_NOT。
◎
The identifier of a static operation also must not be the same as the identifier of a regular operation defined on the same interface.
</p>

<p>
演算の
`返値型@
（ `ReturnType$g に合致）は、［
随意の［
演算の`識別子$
］］の前に現れる型により 与えられる。
返値型
`void@T
は，演算が値を返さないことを指示する。
返値型が `?^c 付きの`識別子$である場合、その識別子は［
~ifc , 辞書 , `列挙$ , `呼戻~関数$ , `~typedef$
］のいずれかに識別され~MUST。
◎
The return type of the operation is given by the type (matching ReturnType) that appears before the operation’s optional identifier. A return type of void indicates that the operation returns no value. If the return type is an identifier followed by ?, then the identifier must identify an interface, dictionary, enumeration, callback function or typedef.
</p>

<p>
演算の引数（ `ArgumentList$g に合致）は、宣言の中の丸括弧の合間にて与えられる。
それぞれの引数は、型（ `Type$g に合致）の後に
`識別子$（ `ArgumentName$g に合致）を続けて指定される。
◎
An operation’s arguments (matching ArgumentList) are given between the parentheses in the declaration. Each individual argument is specified as a type (matching Type) followed by an identifier (matching ArgumentName).
</p>

<p class="note">注記：
表現力のため、演算~引数の識別子には， `ArgumentNameKeyword$g 記号に合致する~keywordも，~escapeを要することなく 指定できる。
<!--  -->
◎
Note: For expressiveness, the identifier of an operation argument can also be specified as one of the keywords matching the ArgumentNameKeyword symbol without needing to escape it.
</p>

<p>
演算~引数の `Type$g が `?^c 付きの`識別子$である場合、その識別子は［
~ifc , `列挙$ , `呼戻~関数$ , `~typedef$
］のいずれかに識別され~MUST。
演算~引数の型が `?^c 付きでない`識別子$である場合、その識別子は，それらのいずれかの定義か, または `辞書$に識別され~MUST。
◎
If the Type of an operation argument is an identifier followed by ?, then the identifier must identify an interface, enumeration, callback function or typedef. If the operation argument type is an identifier not followed by ?, then the identifier must identify any one of those definitions or a dictionary.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i `identifier^i, `type^i `identifier^i /* , ... */);
};
</pre>

<p>
各~引数の識別子は、同じ演算~宣言~内の他の引数の識別子と同じになっては~MUST_NOT。
◎
The identifier of each argument must not be the same as the identifier of another argument in the same operation declaration.
</p>

<p>
各~引数の前には、`拡張属性$の~list（ `ExtendedAttributeList$g に合致）を置くことができる
— それらは、その引数として渡された値が，言語束縛において どう取扱われるかを制御する。
◎
Each argument can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how a value passed as the argument will be handled in language bindings.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i([`extended_attributes^mk] `type^i `identifier^i, [`extended_attributes^mk] `type^i `identifier^i /* , ... */);
};
</pre>


<div class="example">
<p>
次の`~IDL片$は
`~ifc$上に`正則~演算$を宣言する：
◎
The following IDL fragment demonstrates how regular operations can be declared on an interface:
</p>

<pre class="idl-code">
interface Dimensions {
  attribute unsigned long width;
  attribute unsigned long height;
};

interface Button {

  // <span class="comment"
	title="An operation that takes no arguments and returns a boolean."
>引数をとらず, `boolean^T を返す演算</span>
  boolean isMouseOver();

  // <span class="comment"
	title="Overloaded operations."
>多重定義された演算。</span>
  void setDimensions(Dimensions size);
  void setDimensions(unsigned long width, unsigned long height);
};
</pre>
</div>

<div >
<p>
演算の 最後の引数 の引数~型の直後に `...^c ~tokが利用されている場合、その演算は
`可変個の引数をとる@
もの（ variadic ）と見なされる。
<span class="trans-note">【
その最後の引数を
`可変個~引数@
もしくは
<dfn>末尾~引数</dfn>
と記すことにする。
】</span>
そのように宣言された演算は：
</p>

<ul>
	<li>
その末尾~引数の後に任意~個数の引数を伴って呼出せることを指示し、それらの余分な暗黙の形式的~引数の型は，末尾~引数と同じ型と見なされる。
</li>
	<li>
呼出すときには、末尾~引数を省略することもできる。
</li>
	<li>
末尾~引数~以外の引数が `...^c ~tokを伴って宣言されては~MUST_NOT。
</li>
</ul>
◎
An operation is considered to be variadic if the final argument uses the ... token just after the argument type. Declaring an operation to be variadic indicates that the operation can be invoked with any number of arguments after that final argument. Those extra implied formal arguments are of the same type as the final explicit argument in the operation declaration. The final argument can also be omitted when invoking the operation. An argument must not be declared with the ... token unless it is the final argument in the operation’s argument list.
</div>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i<em>...</em> `identifier^i);
  `return_type^i `identifier^i(`type^i `identifier^i, `type^i<em>...</em> `identifier^i);
};
</pre>

<p>
`引数~listを引数にとる$`拡張属性$（この仕様で定義される `Constructor$x と `NamedConstructor$x ）, および
`呼戻~関数$についても、その引数~listに `...^c ~tokが利用されているならば，`可変個の引数をとる$ものと見なされる。
<span class="trans-note">【
以下の記述における “演算†” には，これらの（構築子を与える）拡張属性や呼戻も含まれていると思われる。
】</span>
◎
Extended attributes that take an argument list ([Constructor] and [NamedConstructor], of those defined in this specification) and callback functions are also considered to be variadic when the ... token is used in their argument lists.
</p>


<div class="example">
<p>
次の`~IDL片$は，可変個の引数をとる演算を２つ持つ~ifcを定義する：
◎
The following IDL fragment defines an interface that has two variadic operations:
</p>

<pre class="idl-code">
interface IntegerSet {
  readonly attribute unsigned long cardinality;

  void union(long... ints);
  void intersection(long... ints);
};
</pre>

<p>
~JS言語束縛においては、可変個の引数をとる演算は，後続の引数を受容し得る関数により実装される：
◎
In the ECMAScript binding, variadic operations are implemented by functions that can accept the subsequent arguments:
</p>

<pre class="es-code">
var s = getIntegerSet();  // <span class="comment"
	title="Obtain an instance of IntegerSet."
>`IntegerSet^T の~instanceを得る。</span>

s.union();                // <span class="comment"
	title="Passing no arguments corresponding to 'ints'."
>`ints^l に対応する引数を~~省略。</span>
s.union(1, 4, 7);         // <span class="comment"
	title="Passing three arguments corresponding to 'ints'."
>`ints^l に対応する３個の引数を渡す。</span>
</pre>

<p>
可変個の引数をとる関数を~supportしない言語のための言語束縛においては、その種の演算には，整数の 配列または~list を明示的に渡すように指定することになるであろう。
◎
A binding for a language that does not support variadic functions might specify that an explicit array or list of integers be passed to such an operation.
</p>
</div>


<p>
`optional^c ~keywordを伴って宣言された引数は
`随意~引数@
であるものと見なされる。
`可変個の引数をとる$演算†の`末尾~引数$も随意~引数と見なされる。
随意として宣言された引数は，演算†を呼出す時にその値を省略し得ることを指示する。
`末尾~引数$が，明示的に随意として宣言されては~MUST_NOT。
◎
An argument is considered to be an optional argument if it is declared with the optional keyword. The final argument of a variadic operation is also considered to be an optional argument. Declaring an argument to be optional indicates that the argument value can be omitted when the operation is invoked. The final argument in an operation must not explicitly be declared to be optional if the operation is variadic.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i `identifier^i, optional `type^i `identifier^i);
};
</pre>


<p>
随意~引数には
`既定~値@
を指定できる。
引数の識別子に
`U+003D EQUALS SIGN ("=")^char
と
値（ `DefaultValue$g に合致）が後続している場合、その値がその随意~引数の
`既定~値$
を与える。
ただし、`可変個の引数をとる$演算†の`末尾~引数$には、既定~値が指定されては~MUST_NOT。
既定~値は、対応する引数が省略されて演算†が~callされたときに，その引数がとる値と見做される。
◎
Optional arguments can also have a default value specified. If the argument’s identifier is followed by a U+003D EQUALS SIGN ("=") and a value (matching DefaultValue), then that gives the optional argument its default value. The implicitly optional final argument of a variadic operation must not have a default value specified. The default value is the value to be assumed when the operation is called with the corresponding argument omitted.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i `identifier^i, optional `type^i `identifier^i = `value^i);
};
</pre>

<p class="advisement">
`boolean$T 型の引数には、既定~値として `true^V を利用しないことを強く勧める。
さもなければ、 `undefined^v に既定の変換（すなわち， `false^V ）が利用されると期待する作者たちを惑わすことになるので。
◎
It is strongly suggested not to use default value of true for boolean-typed arguments, as this can be confusing for authors who might otherwise expect the default conversion of undefined to be used (i.e., false).
</p>

<div>

<p>
次を満たす引数は、随意として指定され~MUST。
</p>

<ul>
	<li>
引数の型は［
`辞書~型$ ／ `~record型$
］である, または［
`共用体~型$であって，ある［
`辞書~型$ ／ `~record型$
］を`平坦化~mb型$に含んでいる
］, かつ
</li>
	<li>
その辞書~型 %D と %D の先祖には，必須の~mbはない, かつ
</li>
	<li>
引数は最後の引数である, または
引数に後続するどの引数も`随意~引数$である。
</li>
</ul>

<p>
そのような引数は、他から指定されない限り，常に［
各~mbが既定~値にされた，空の［
辞書／~record
］］を値にとるものと見なされる。
</p>
◎
If the type of an argument is a dictionary type or record type or a union type that has a dictionary or record type as one of its flattened member types, and that dictionary type and its ancestors have no required members, and the argument is either the final argument or is followed only by optional arguments, then the argument must be specified as optional. Such arguments are always considered to have a default value of an empty dictionary or record, as appropriate, unless otherwise specified.
</div>

<div class="note">
<p>
これは、作者が辞書の既定~値のみの利用を望むときでも，空の辞書~値を渡さずに済むような~APIの設計を促すためである。
◎
This is to encourage API designs that do not require authors to pass an empty dictionary value when they wish only to use the dictionary’s default values.
</p>

<p>
辞書~型は明示的な既定~値を指定し得ないので、上の “他から指定されない限り” の条件は，`平坦化~mb型$に辞書~型が含まれているような`共用体~型$に対してのみ可能になる。<!--  -->
◎
Dictionary types cannot have a default value specified explicitly, so the “unless otherwise specified” clause above can only be invoked for a union type that has a dictionary type as one of its flattened member types.
</p>
</div>

<p>
`既定~値$に`定数~tok$が利用された場合、`定数$に対するときと同じ仕方で解釈される。
◎
When a boolean literal token (true or false), the null token, an integer token, a float token or one of the three special floating point literal values (Infinity, -Infinity or NaN) is used as the default value, it is interpreted in the same way as for a constant.
</p>

<p id="string-literal">
随意~引数の既定~値には、 `string$g ~tokも指定できる。
それは、次に従って決定される`文字列~型$の値をとる：
◎
Optional argument default values can also be specified using a string token, whose value is a string type determined as follows:
</p>

<ol class="algorithm">
	<li>
%S := `string$g ~tokに合致する［
`~Unicode~scalar値$の並び
］から，先頭と末尾の
`U+0022 QUOTATION MARK^char ( `"^c )
文字を除去したもの
◎
Let S be the sequence of Unicode scalar values matched by the string token with its leading and trailing U+0022 QUOTATION MARK ('"') characters removed.
</li>
	<li>
<p>
`string$g ~tokの値は、引数の型に応じて，次で与えられる：
◎
Depending on the type of the argument:
</p>

<dl class="switch">
	<dt>`DOMString$T</dt>
	<dt>`列挙$ 型</dt>
	<dd>
%S を UTF-16 符号化したものに対応する， 16 ~bit無符号~整数~符号単位（以下、単に
`符号単位@
と記される）の並び。
◎
The value of the string token is the sequence of 16 bit unsigned integer code units (hereafter referred to just as code units) corresponding to the UTF-16 encoding of S.
</dd>
	<dt>`ByteString$T</dt>
	<dd>
%S を UTF-8 符号化したものに対応する， 8 ~bit無符号~整数~符号単位の並び。
◎
The value of the string token is the sequence of 8 bit unsigned integer code units corresponding to the UTF-8 encoding of S.
</dd>
	<dt>`USVString$T</dt>
	<dd>
%S 。
◎
The value of the string token is S.
</dd>
</dl>
	</li>
</ol>

<p>
`随意~引数$の型が`列挙$である場合、その`既定~値$に指定される値は，その列挙のいずれかの`列挙~値$で~MUST。
◎
If the type of the optional argument is an enumeration, then its default value if specified must be one of the enumeration’s values.
</p>

<p>
`連列~型$（`~nullable$も含む）の随意~引数の既定~値には、
2 個の~tokによる `[]^c を利用して，その型と同じ型の空~連列~値を表現する値も指定できる。
`連列~型$（`~nullable$も含む）でない随意~引数に，この既定~値を指定しては~MUST_NOT。
◎
Optional argument default values can also be specified using the two token value [], which represents an empty sequence value. The type of this value is the same the type of the optional argument it is being used as the default value of. That type must be a sequence type or a nullable type.
</p>

<div class="example">
<p>
次の`~IDL片$は、２つの長さが異なる引数~listで呼出せる単独の`演算$を伴う`~ifc$を定義する：
◎
The following IDL fragment defines an interface with a single operation that can be invoked with two different argument list lengths:
</p>

<pre class="idl-code">
interface ColorCreator {
  object createColor(double v1, double v2, double v3, optional double alpha);
};
</pre>

<p>
それは、`多重定義$された２つの`演算$を持つ次の`~ifc$と等価になる：
◎
It is equivalent to an interface that has two overloaded operations:
</p>

<pre class="idl-code">
interface ColorCreator {
  object createColor(double v1, double v2, double v3);
  object createColor(double v1, double v2, double v3, double alpha);
};
</pre>
</div>

<p id="callback-operation-exceptions">
実装が`利用者~obj$上の`演算$の呼出しを試みた結果
（例えば，呼戻~objが実装に供されていて），例外が投出される場合、他から指定されない限り，その例外は［
実装からその演算の呼出しを生じさせた，利用者~code
］まで伝播することになる。
同様に，演算の呼出しにより返される値を~IDL型に変換できない場合、それにより生じた例外も［
実装からその演算の呼出しを試みさせた，利用者~code
］まで伝播することになる。
◎
If an implementation attempts to invoke an operation on a user object (for example, when a callback object has been supplied to the implementation), and that attempt results in an exception being thrown, then, unless otherwise specified, that exception will be propagated to the user code that caused the implementation to invoke the operation. Similarly, if a value returned from invoking the operation cannot be converted to an IDL type, then any exception resulting from this will also be propagated to the user code that resulted in the implementation attempting to invoke the operation.
</p>


<p>
演算には、次の拡張属性を適用し得る：
`Exposed$x,
`NewObject$x,
`SecureContext$x,
`TreatNullAs$x,
`Unforgeable$x
。
◎
The following extended attributes are applicable to operations: [Exposed], [NewObject], [SecureContext], [TreatNullAs], [Unforgeable].
</p>

<p>
演算~引数には、次の拡張属性を適用し得る：
`Clamp$x,
`EnforceRange$x,
`TreatNullAs$x
。
◎
The following extended attributes are applicable to operation arguments: [Clamp], [EnforceRange], [TreatNullAs].
</p>

<div class="grammar">
DefaultValue
Operation
SpecialOperation
Specials
Special
OperationRest
OptionalIdentifier
ArgumentList
Arguments
Argument
OptionalOrRequiredArgument
ArgumentName
Ellipsis
ArgumentNameKeyword
ReturnType
</div>

			</section>
			<section id="idl-special-operations">
<h4 title="Special operations">2.2.4. 特殊~演算</h4>


<p>
`特殊~演算@
は、［
その特殊~演算~宣言が現れる~ifc
］を実装する~obj上における［
一定の種類の特殊な挙動
］の宣言である。
`特殊~演算$は，演算~宣言において１個~以上の
`特殊~keyword@
を利用して宣言される。
◎
A special operation is a declaration of a certain kind of special behavior on objects implementing the interface on which the special operation declarations appear. Special operations are declared by using one or more special keywords in an operation declaration.
</p>

<p>
`特殊~演算$には、次の一覧に示す６種類がある。
一覧には、それぞれの種類の特殊~演算に対し，その宣言-時に利用される特殊~keyword, およびその特殊~演算の用途も示す：
◎
There are six kinds of special operations. The table below indicates for a given kind of special operation what special keyword is used to declare it and what the purpose of the special operation is:
</p>

<table>

<thead><tr><th>`特殊~演算$◎Special operation
</th><th>~keyword◎Keyword
</th><th>用途◎Purpose
</th></tr></thead>

<tbody><tr><td>`取得子@
</td><td>`getter^c
</td><td>
~prop取得1
のために~objが~indexingされる際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property retrieval.
</td></tr>

<tr><td>`設定子@
</td><td>`setter^c
</td><td>
~prop代入／作成
のために~objが~indexingされる際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property assignment or creation.
</td></tr>

<tr><td>`削除子@
</td><td>`deleter^c
</td><td>
~prop削除
のために~objが~indexingされる際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property deletion.
</td></tr>

<tr><td>`旧来呼出子@
</td><td>`legacycaller^c
</td><td>
~objが関数であったかのように~callされる際の挙動を定義する。
◎
Defines behavior for when an object is called as if it were a function.
</td></tr>

<tr><td>`文字列化子@
</td><td>`stringifier^c
</td><td>
~objを `DOMString$T に変換する方法を定義する。
◎
Defines how an object is converted into a DOMString.
</td></tr>

<tr><td>`直列化子@
</td><td>`serializer^c
</td><td>
~objを直列化形に変換する方法を定義する。
◎
Defines how an object is converted into a serialized form.
</td></tr>

</tbody></table>

<p>
すべての言語束縛が、［
これら６種類の，~objの特殊な挙動
］すべてを~supportするわけではない。
`特殊~演算$が，識別子を伴わない演算を利用して宣言された場合、その個々の種類の特殊~演算を~supportしない言語束縛においては，単にその機能性が存在しないことになる。
◎
Not all language bindings support all of the six kinds of special object behavior. When special operations are declared using operations with no identifier, then in language bindings that do not support the particular kind of special operations there simply will not be such functionality.
</p>

<div class="example">
<p>
次の~IDL片は、取得子と設定子を伴う~ifcを定義する：
◎
The following IDL fragment defines an interface with a getter and a setter:
</p>

<pre class="idl-code">
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  getter double (DOMString propertyName);
  setter void (DOMString propertyName, double propertyValue);
};
</pre>

<p>
~propの取得子や設定子を~supportしない言語束縛では、
`Dictionary^T を実装している~objはこの特殊な挙動を持たないことになる。
◎
In language bindings that do not support property getters and setters, objects implementing Dictionary will not have that special behavior.
</p>

</div>

<p>
`特殊~演算$を`識別子$を伴わせて定義することは、その宣言から識別子のない特殊~演算を分離することと，等価である。
この書き方は、~ifcの演算についての注釈文の記述を単純化するために許容されている。
◎
Defining a special operation with an identifier is equivalent to separating the special operation out into its own declaration without an identifier. This approach is allowed to simplify prose descriptions of an interface’s operations.
</p>

<div class="example">
<p>
次の２つの~ifcは等価である：
◎
The following two interfaces are equivalent:
</p>

<pre class="idl-code">
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  getter double getProperty(DOMString propertyName);
  setter void setProperty(DOMString propertyName, double propertyValue);
};
</pre>

<pre class="idl-code">
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  double getProperty(DOMString propertyName);
  void setProperty(DOMString propertyName, double propertyValue);

  getter double (DOMString propertyName);
  setter void (DOMString propertyName, double propertyValue);
};
</pre>
</div>

<p>
１つの演算に同じ`特殊~keyword$が複数~回 現れては~MUST_NOT。
◎
A given special keyword must not appear twice on an operation.
</p>

<div id="_property-accessors">
<!-- 
有index~prop~accessor:indexed-property-accessor
有名~prop~accessor:named-property-accessor
-->
<p>
取得子, 設定子, 削除子は２つ系列に分類される：
</p>

<ul>
	<li>
`有名~prop取得子@,
`有名~prop設定子@,
`有名~prop削除子@
と呼ばれる，~prop名として `DOMString$T をとるもの。
</li>
	<li>
`有index~prop取得子@,
`有index~prop設定子@
と呼ばれる，~prop~indexとして `unsigned long$T をとるもの
— 有index~propには，<em>削除子は無い</em>。
</li>
</ul>

<p>
詳細は
`idl-indexed-properties$sec, `idl-named-properties$sec
に。
</p>
◎
Getters and setters come in two varieties: ones that take a DOMString as a property name, known as named property getters and named property setters, and ones that take an unsigned long as a property index, known as indexed property getters and indexed property setters. There is only one variety of deleter: named property deleters. See §2.2.4.4 Indexed properties and §2.2.4.5 Named properties for details.
</div>

<p>
所与の`~ifc$上に存在する，［
`文字列化子$, `直列化子$, `削除子$ および, 各~系列の［
`取得子$, `設定子$
］］は、それぞれ，高々１個までで~MUST。
旧来呼出子 については、多重定義された~callの挙動を指定する，複数のものが、同じ~ifc上に存在し得る。
◎
On a given interface, there must exist at most one stringifier, at most one serializer, at most one named property deleter, and at most one of each variety of getter and setter. Multiple legacy callers can exist on an interface to specify overloaded calling behavior.
</p>

<p>
~ifcが［
いずれかの系列の`設定子$,
あるいは`有名~prop削除子$
］を持つ場合、同じ系列の`取得子$も持た~MUST。
◎
If an interface has a setter of a given variety, then it must also have a getter of that variety. If it has a named property deleter, then it must also have a named property getter.
</p>


<p>
演算を利用して宣言される`特殊~演算$は，`可変個の引数をとる$ようにされたり, `随意~引数$を持っては~MUST_NOT。
◎
Special operations declared using operations must not be variadic nor have any optional arguments.
</p>

<p>
`特殊~演算$は，`呼戻~ifc$上で宣言されては~MUST_NOT。
◎
Special operations must not be declared on callback interfaces.
</p>

<p>
~objが，所与の`特殊~演算$を定義する複数の`~ifc$を実装する場合、その演算に対し，どの特殊~演算が呼出されるかは 未定義である。
◎
If an object implements more than one interface that defines a given special operation, then it is undefined which (if any) special operation is invoked for that operation.
</p>

				<section id="idl-legacy-callers">
<h5 title="Legacy callers">2.2.4.1. 旧来呼出子</h5>


<p>
`~ifc$が１個~以上の`旧来呼出子$を持つとき、その~ifcを実装する~objは，それらが関数であったかのように~callし得ることを指示する。
上に示された様に，旧来呼出子は
`legacycaller^c ~keywordを伴って宣言される`演算$を利用して指定できる。
◎
When an interface has one or more legacy callers, it indicates that objects that implement the interface can be called as if they were functions. As mentioned above, legacy callers can be specified using an operation declared with the legacycaller keyword.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  legacycaller `return_type^i `identifier^i(/* arguments... */);
  legacycaller `return_type^i (/* arguments... */);
};
</pre>

<p>
~ifcに複数の`旧来呼出子$が指定されている場合、その~objが関数であったかのように~callされる際に，どの旧来呼出子が呼出されるか決定するときには、`多重定義~解決~algo$が利用される。
◎
If multiple legacy callers are specified on an interface, overload resolution is used to determine which legacy caller is invoked when the object is called as if it were a function.
</p>

<p>
`旧来呼出子$は、`~promise型$を返し得るように定義されては~MUST_NOT。
◎
Legacy callers must not be defined to return a promise type.
</p>


<p class="advisement">
`旧来呼出子$は望ましくない特色機能としてあまねく認識されている。
それらはもっぱら，旧来の~Web~platform特色機能を指定できるようにするために存在する。
旧来呼出子は、旧来の~APIの挙動の指定が要求されていない限り，仕様に利用されるべきでない。
その場合においても，先に進む前に
<a href="mailto:public-script-coord@w3.org">public-script-coord@w3.org</a> ~mailing-listにて論を交わすべきである。
◎
Legacy callers are universally recognised as an undesirable feature. They exist only so that legacy Web platform features can be specified. Legacy callers should not be used in specifications unless required to specify the behavior of legacy APIs, and even then this should be discussed on the public-script-coord@w3.org mailing list before proceeding.
</p>


<div class="example">
<p>
次の`~IDL片$は、`旧来呼出子$を伴う`~ifc$を定義する。
◎
The following IDL fragment defines an interface with a legacy caller.
</p>

<pre class="idl-code">
interface NumberQuadrupler {
  // <span class="comment"
	title="This operation simply returns four times the given number x."
>この演算は単純に %x を 4 倍にして返す。</span>
  legacycaller double compute(double x);
};
</pre>

<p>
この~ifcを~supportする~JS実装では，関数として~callされる `NumberQuadrupler^T を実装する`~platform~obj$が許容されることになるであろう：
◎
An ECMAScript implementation supporting this interface would allow a platform object that implements NumberQuadrupler to be called as a function:
</p>

<pre class="es-code">
var f = getNumberQuadrupler();  // <span class="comment"
	title="Obtain an instance of NumberQuadrupler."
>`NumberQuadrupler^T の~instanceを得る。</span>

f.compute(3);                   // <span class="comment"
	title="This evaluates to 12."
>これは `12^v に評価される。</span>
f(3);                           // <span class="comment"
	title="This also evaluates to 12."
>これも `12^v に評価される。</span>
</pre>
</div>
				</section>
				<section id="idl-stringifiers">
<h5 title="Stringifiers">2.2.4.2. 文字列化子</h5>


<p>
`~ifc$が`文字列化子$を持つとき、
<!--  -->
その~ifcを実装する~objは，文字列への既定でない変換を持つことになる。
上に示した様に、文字列化子は
`stringifier^c ~keywordを伴って宣言される`演算$を利用して，指定できる。
◎
When an interface has a stringifier, it indicates that objects that implement the interface have a non-default conversion to a string. As mentioned above, stringifiers can be specified using an operation declared with the stringifier keyword.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier DOMString `identifier^i();
  stringifier DOMString ();
};
</pre>

<p>
`文字列化子$の宣言-時に利用された演算が`識別子$を持たない場合、~ifcに付随する注釈文において，~ifcの
`文字列化の挙動@
が定義され~MUST。
演算が識別子を持つ場合、その演算の呼出しにより，~objは文字列に変換される。
◎
If an operation used to declare a stringifier does not have an identifier, then prose accompanying the interface must define the stringification behavior of the interface. If the operation does have an identifier, then the object is converted to a string by invoking the operation to obtain the string.
</p>

<p>
演算により宣言される`文字列化子$は、引数をとらず,
`DOMString$T を返すように，宣言され~MUST。
◎
Stringifiers declared with operations must be declared to take zero arguments and return a DOMString.
</p>

<p>
略記法として、
`stringifier^c ~keywordが，識別子を伴わない演算により宣言される場合、その演算の`返値型$, および引数~listを省略できる。
◎
As a shorthand, if the stringifier keyword is declared using an operation with no identifier, then the operation’s return type and argument list can be omitted.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier;
};
</pre>

<div class="example">
<p>
次の２つの~ifcは等価である：
◎
The following two interfaces are equivalent:
</p>

<pre class="idl-code">
interface A {
  stringifier DOMString ();
};
</pre>

<pre class="idl-code">
interface A {
  stringifier;
};
</pre>
</div>

<p>
`stringifier^c ~keywordは
`属性$上に置くこともできる。
この場合、その属性の値が，~objから文字列への変換-を与える。
`stringifier^c ~keywordが［［
`DOMString$T／`USVString$T
として宣言されていない属性
］や
`静的~属性$
］上に置かれては~MUST_NOT。
◎
The stringifier keyword can also be placed on an attribute. In this case, the string to convert the object to is the value of the attribute. The stringifier keyword must not be placed on an attribute unless it is declared to be of type DOMString or USVString. It also must not be placed on a static attribute.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier attribute DOMString `identifier^i;
};
</pre>

<div class="grammar">
Stringifier
StringifierRest
</div>

<div class="example">
<p>
次の`~IDL片$は、
`name^M
属性の値に文字列化する~ifcを定義する：
◎
The following IDL fragment defines an interface that will stringify to the value of its name attribute:
</p>

<pre class="idl-code">
[Constructor]
interface Student {
  attribute unsigned long id;
  stringifier attribute DOMString name;
};
</pre>

<p>
~JS言語束縛においては、文字列が期待されている文脈において
`Student^T
~objが利用されたときの結果は、その~objの `name^l ~propの値になる：
◎
In the ECMAScript binding, using a Student object in a context where a string is expected will result in the value of the object’s “name” property being used:
</p>

<pre class="es-code">
var s = new Student();
s.id = 12345678;
s.name = '周杰倫';

var greeting = 'こんにちは、 ' + s + ' さん。';
    // <span class="comment"
	title="Now greeting == 'Hello, 周杰倫!'."
>%greeting は `こんにちは、 周杰倫 さん。^l になる。</span>
</pre>

<p>
次の`~IDL片$は、~IDL自身には指定されない独自の文字列化の挙動を持つ~ifcを定義する。
◎
The following IDL fragment defines an interface that has custom stringification behavior that is not specified in the IDL itself.
</p>

<pre class="idl-code">
[Constructor]
interface Student {
  attribute unsigned long id;
  attribute DOMString? familyName;
  attribute DOMString givenName;

  stringifier DOMString ();
};
</pre>

<p>
したがって、例えば次の段落の様な，文字列化の挙動を説明する注釈文が要求される：
◎
Thus, prose is required to explain the stringification behavior, such as the following paragraph:
</p>

<blockquote>
`Student^T ~ifc を実装する~objを文字列化した結果は、
`familyName^M 属性の値が `null^V の場合は
`givenName^M 属性の値，他の場合は［
`givenName^M 属性の値,
１個の space 文字,
`familyName^M 属性の値
］の連結にならなければ~MUST_NOT。
◎
Objects that implement the Student interface must stringify as follows. If the value of the familyName attribute is null, the stringification of the object is the value of the givenName attribute. Otherwise, if the value of the familyName attribute is not null, the stringification of the object is the concatenation of the value of the givenName attribute, a single space character, and the value of the familyName attribute.
</blockquote>

<p>
この~IDLの~JS実装は、次に従って挙動することになる：
◎
An ECMAScript implementation of the IDL would behave as follows:
</p>

<pre class="es-code">
var s = new Student();
s.id = 12345679;
s.familyName = 'Smithee';
s.givenName = 'Alan';

var greeting = 'こんにちは、 ' + s + ' さん。';
    // <span class="comment"
	title="Now greeting == 'Hi Alan Smithee'."
>%greeting は `こんにちは、 Alan Smithee さん^l になる。</span>
</pre>
</div>
				</section>
				<section id="idl-serializers">
<h5 title="Serializers">2.2.4.3. 直列化子</h5>


<p>
`~ifc$が`直列化子$を持つとき、その~ifcを実装する~objが，自身を直列化形に変換する仕方を提供することを指示する。
直列化子は `serializer^c ~keywordを利用して宣言できる。
◎
When an interface has a serializer, it indicates that objects provide a way for them to be converted into a serialized form. Serializers can be declared using the serializer keyword:
</p>

<pre class="syntax">
interface `interface_identifier^i {
  serializer;
};
</pre>

<p>
この仕方で`直列化子$を宣言する~ifcにおいては、付随する注釈文にて，
その~ifcの
`直列化-時の挙動@
が定義され~MUST。
直列化-時の挙動は、次のいずれかの型による
`直列化形の値@
を返すものとして定義される：
◎
Prose accompanying an interface that declares a serializer in this way must define the serialization behavior of the interface. Serialization behavior is defined as returning a serialized value of one of the following types:
</p>

<ul>
	<li>
<p >
次のいずれも満たすような，一連の~key-valueからなる<em>~map</em>
</p>
		<ul>
			<li>
どの~keyも ~map内で一意な `DOMString$T 値である
</li>
			<li>
どの~valueも `直列化形の値$である
</li>
		</ul>

◎
a map of key–value pairs, where the keys are DOMString values (unique in the map) and the values are serialized values
</li>
	<li>
一連の`直列化形の値$からなる，<em>~list</em>
◎
a list of serialized values
</li>
	<li>
`DOMString$T 値
◎
a DOMString value
</li>
	<li>
`unrestricted double$T 値
◎
an unrestricted double value
</li>
	<li>
`boolean$T 値
◎
a boolean value
</li>
	<li>
`null^V 値
◎
the null value
</li>
</ul>

<p>
［
言語束縛において，`直列化-時の挙動$が~obj上にてどのように可用にされるか
］, および［
抽象的な`直列化形の値$がどのようにして適切な具体的な値に変換されるか
］については、言語束縛~特有になる。
◎
How the serialization behavior is made available on an object in a language binding, and how exactly the abstract serialized value is converted into an appropriate concrete value, is language binding specific.
</p>

<p class="note">注記：
~JS言語束縛においては、`直列化-時の挙動$は，［
`直列化形の値$を［［
`JSON.stringify^c 関数により JSON に直列化し得る
］ような~JS値
］に変換したもの
］を返すような `toJSON^c ~methとして，公開される。
詳細は
`es-serializer$sec
に。
◎
Note: In the ECMAScript language binding, serialization behavior is exposed as a toJSON method which returns the serialized value converted into an ECMAScript value that can be serialized to JSON by the JSON.stringify function. See §3.6.7.2 Serializers for details.
</p>

<p>
`直列化-時の挙動$は、別途の注釈文を与えずに，~IDLの中で直接的に指定することもできる。
そのためには、
~keyword `serializer^c と
文字
`U+003D EQUALS SIGN ("=")^char
に続けて，以下に述べる６種の形をとり得る
`直列化~pattern@
を記す：
◎
Serialization behavior can also be specified directly in IDL, rather than separately as prose. This is done by following the serializer keyword with a U+003D EQUALS SIGN ("=") character and a serialization pattern, which can take one of the following six forms:
</p>

<dl>
	<dt>
~ifcからの，ゼロ個~以上の属性に対応する~entryを伴う~map ①：
◎
↓</dt>
	<dt>
または、① に加え，被継承~ifc からの属性に対応する~entryも伴う~map：
◎
A map with entries corresponding to zero or more attributes from the interface, and optionally attributes from an inherited interface:
</dt>
	<dd>

<pre class="syntax">
interface `interface_identifier^i {
  serializer = { `attribute_identifier^i, `attribute_identifier^i /* , ... */ }; // ①
  serializer = { inherit, `attribute_identifier^i, `attribute_identifier^i /* , ... */ };
};
</pre>

<p id="cp-attr-must-serializable">
どの識別子も，~ifc上で宣言された属性の識別子で~MUST。
識別されるどの属性も，`直列化可能な型$を持た~MUST。
◎
Each identifier must be the identifier of an attribute declared on the interface. The identified attributes all must have a serializable type.
</p>

<p>
`inherit^c ~keywordは、［
~ifcが`直列化子$を定義する別の~ifcを継承し, かつ
そのような~ifcのうち最も末端のものが［
この形, または次項の形（すなわち， `{ attribute }^c ）
］による`直列化~pattern$を利用して直列化子を定義している
］場合を除き，利用されては~MUST_NOT。
◎
The inherit keyword must not be used unless the interface inherits from another that defines a serializer, and the closest such interface defines its serializer using this serialization pattern form or the following form (i.e. { attribute }).
</p>

<p id="cp-ser-behavior-as-follows">
この形の直列化~patternに対する`直列化-時の挙動$は、次で与えられる：
◎
The serialization behavior for this form of serialization pattern is as follows:
</p>

		<ol class="algorithm">
			<li id="cp-let-empty-map">
%map := 空の~map
◎
Let map be an empty map.
</li>
			<li id="cp-set-map-if-inherit">
~IF `inherit^c ~keywordが利用されている
~THEN
%map ← `直列化子$を宣言する最も末端の被継承~ifc の`直列化-時の挙動$の結果
◎
If the inherit keyword was used, then set map to be the result of the serialization behavior of the closest inherited interface that declares a serializer.
</li>
			<li>
<p>
~FOR
直列化~pattern内の~EACH ( 属性~識別子 %i ) に対し，順に：
◎
For each attribute identifier i in the serialization pattern, in order:
</p>

				<ol>
					<li id="cp-remove-with-key-eq-i">
%map 内から［
~key ~EQ %i
］なる~entryをすべて除去する
◎
Remove any entry in map with key name i.
</li>
					<li id="cp-let-V-attr-of-id-i">
%V := 識別子 %i の属性の値
◎
Let V be the value of the attribute with identifier i.
</li>
					<li id="cp-add-entry-key-of-i">
［
~key ~EQ %i,
~value ~EQ ［
%V を`直列化形の値に変換-$した結果
］］なる~entryを %map に追加する
◎
Add an entry to map whose key name is i and whose value is result of converting V to a serialized value.
</li>
				</ol>
			</li>
			<li id="cp-ret-map">
~RET %map
◎
Return map.
</li>
		</ol>
	</dd>
	<dt>
~ifcからの，すべての［
`直列化可能な型$を持つ属性
］に対応する~entryを伴う~map ②：
◎
↓</dt>
	<dt>
または、② に加え，被継承~ifc からの属性に対応する~entryも伴う~map：
◎
A map with entries corresponding to all attributes from the interface that have a serializable type, and optionally attributes from an inherited interface:
</dt>
	<dd>

<pre class="syntax">
interface `interface_identifier^i {
  serializer = { attribute }; // ②
  serializer = { inherit, attribute };
};
</pre>

<p><!-- copy* -->
`inherit^c ~keywordは、［
~ifcが`直列化子$を定義する別の~ifcを継承し, かつ
そのような~ifcのうち最も末端のものが［
この形, または前項の形
］による`直列化~pattern$を利用して直列化子を定義している
］場合を除き，利用されては~MUST_NOT。
◎
The inherit keyword must not be used unless the interface inherits from another that defines a serializer, and the closest such interface defines its serializer using this serialization pattern form or the previous form.
</p>

<!--cp-ser-behavior-as-follows-->

		<ol class="algorithm">
			<!--cp-let-empty-map-->
			<!--cp-set-map-if-inherit-->
			<li>
<p>
~FOR
~ifc上の ~EACH (
`直列化可能な型$を持つ属性の識別子 %i
) に対し，それが~ifc上に現れる順に：
◎
For each identifier i of an attribute on the interface whose type is a serializable type, in the order they appear on the interface:
</p>

				<ol>
					<!--cp-remove-with-key-eq-i-->
					<!--cp-let-V-attr-of-id-i-->
					<!--cp-add-entry-key-of-i-->
				</ol>
			</li>
			<!--cp-ret-map-->
		</ol>
	</dd>
	<dt>
`有名~prop$に対応している~entryを伴う~map：
◎
A map with entries corresponding to the named properties:
</dt>
	<dd>

<pre class="syntax">
interface `interface_identifier^i {
  serializer = { getter };
};
</pre>

<p>
この形は、［
~ifcまたはそれが継承する~ifcが有名~propを~supportする
］, かつ［
`有名~prop取得子$の返値型が直列化可能である
］場合を除き，利用されては~MUST_NOT。
◎
This form must not be used unless the interface or one it inherits from supports named properties and the return type of the named property getter is a serializable type.
</p>

<!--cp-ser-behavior-as-follows-->

		<ol class="algorithm">
			<!--cp-let-empty-map-->

			<li>
<p>
~FOR
~obj上の~EACH ( `被support~prop名$ %n ) に対し，順に：
◎
For each supported property name n on the object, in order:
</p>

				<ol>
					<li>
%V := 名前 %n の有名~propの値
◎
Let V be the value of the named property with name n.
</li>
					<li>
［
~key ~EQ %n,
~value ~EQ ［
%V を`直列化形の値に変換-$した結果
］］なる~entryを %map に追加する
◎
Add an entry to map whose key name is n and whose value is result of converting V to a serialized value.
</li>
				</ol>
			</li>
			<!--cp-ret-map-->
		</ol>
	</dd>
	<dt>
~ifc上のゼロ個~以上の属性の値の~list：
◎
A list of value of zero or more attributes on the interface:
</dt>
	<dd>

<pre class="syntax">
interface `interface_identifier^i {
  serializer = [ `attribute_identifier^i, `attribute_identifier^i /* , ... */ ];
};
</pre>

<!--cp-attr-must-serializable-->

<!--cp-ser-behavior-as-follows-->

		<ol class="algorithm">
			<li id="cp-let-list-empty">
%list := 空~list
◎
Let list be an empty list.
</li>
			<li>
<p>
~FOR
直列化~pattern内の ~EACH ( 属性~識別子 %i ) に対し，順に：
◎
For each attribute identifier i in the serialization pattern:
</p>

				<ol>
					<!--cp-let-V-attr-of-id-i-->
					<li id="cp-append-serialized">
%V を`直列化形の値に変換-$した結果の値を %list に付加する
◎
Append to list the value that is the result of converting V to a serialized value.
</li>
				</ol>
			</li>
			<li id="cp-ret-list">
~RET %list
◎
Return list.
</li>
		</ol>
	</dd>
	<dt>
`有index~prop$に対応している~entryの~list
◎
A list with entries corresponding to the indexed properties:
</dt>
	<dd>

<pre class="syntax">
interface `interface_identifier^i {
  serializer = [ getter ];
};
</pre>

<p>
この形は、［
~ifcまたはそれが継承する~ifcが`有index~propを~supportする$
］, かつ［
`有index~prop取得子$の返値型が直列化可能な型である
］場合を除き，利用されては~MUST_NOT。
◎
This form must not be used unless the interface or one it inherits from supports indexed properties and the return type of the indexed property getter is a serializable type.
</p>

<!--cp-ser-behavior-as-follows-->

		<ol class="algorithm">
			<!--cp-let-list-empty-->
			<li>
%i :← 0
◎
Let i be 0.
</li>
			<li>
<p>
~WHILE %i ~LTE ~obj上の`被support~prop~index$の最大：
◎
While i is less than or equal to the greatest supported property index on the object:
</p>

				<ol>
					<li>
%V := ［
%i は`被support~prop~index$であるならば ~index %i に位置する有index~propの値 ／
~ELSE_ `null^V
］
◎
Let V be the value of the indexed property with index i if i is a supported property index, or null otherwise.
</li>
					<!--cp-append-serialized-->
					<li>
%i ← %i + 1
◎
Set i to i + 1.
</li>
				</ol>
			</li>
			<!--cp-ret-list-->
		</ol>
	</dd>
	<dt>
単独の属性：
◎
A single attribute:
</dt>
	<dd>

<pre class="syntax">
interface `interface_identifier^i {
  serializer = `attribute_identifier^i;
};
</pre>

<p><!-- copy* -->
識別子は，~ifc上で宣言された属性の識別子で~MUST。
その属性は，`直列化可能な型$を持た~MUST。
◎
The identifier must be the identifier of an attribute declared on the interface, and this attribute must have a serializable type.
</p>

<!--cp-ser-behavior-as-follows-->

		<ol class="algorithm">
			<li>
~RET 
指定された識別子を伴う属性の値を`直列化形の値に変換-$した結果
◎
Let V be the value of the attribute with the specified identifier.
◎
Return the result of converting V to a serialized value.
</li>
		</ol>
	</dd>
</dl>



<p class="note">注記：
一連の~entryは，特定0の順序により~mapに追加される。
~JS言語束縛においては，~propが~objに追加される順序に従うものと定義される。
この順序は
`JSON.stringify^c
から生成される直列化に波及するので。
◎
Note: Entries are added to maps in a particular order so that in the ECMAScript language binding it is defined what order properties are added to objects. This is because this order can influence the serialization that JSON.stringify can produce.
</p>




<p>
各種
`直列化可能な型@, および
それらを
`直列化形の値に変換-@
する方法は、次で与えられる：
◎
The list of serializable types and how they are converted to serialized values is as follows:
</p>

<dl class="switch">
	<dt>`long long$T</dt>
	<dt>`unsigned long long$T</dt>
	<dd>
最も近い等価な `double$T 値に変換される（
<a href="#_int-toES_">この~IDL整数~型を~JS `Number^t 値に変換する</a>
ときと同様に）
◎
converted by choosing the closest equivalent double value (as when converting a long long to an ECMAScript Number value)
◎
converted by choosing the closest equivalent double value (as when converting a unsigned long long to an ECMAScript Number value)
</dd>
	<dt>他のすべての`整数~型$</dt>
	<dt>`float$T</dt>
	<dd>
等価な `double$T 値に変換される
◎
converted by choosing the equivalent double value
</dd>
	<dt>`double$T</dt>
	<dt>`boolean$T</dt>
	<dt>`DOMString$T</dt>
	<dd>
それぞれの型の，同じ値
◎
the same value of the respective type
</dd>
	<dt>`列挙~型$◎an enumeration type</dt>
	<dd>
等価な `DOMString$T 値
◎
the equivalent DOMString value
</dd>

	<dt>`USVString$T◎a USVString</dt>
	<dd>
所与の`~Unicode~scalar値$の並びを UTF-16 に符号化して生産される `DOMString$T
◎
the DOMString produced by encoding the given sequence of Unicode scalar values in UTF-16
</dd>

	<dt>`ByteString$T◎a ByteString</dt>
	<dd>
各~符号単位と対応する~byteが数として同じであるような，等価な `DOMString$T 値
◎
the equivalent DOMString value where each code unit has the same value as the corresponding byte value
</dd>


	<dt>`~nullable型$であって，その`内縁~型$は直列化可能であるもの
◎a nullable serializable type</dt>
	<dd>
値が `null^T ならば `null^T に変換され、他の場合は，その`内縁~型$に従って変換される
◎
converted to null if that is its value, otherwise converted as per its inner type
</dd>
	<dt>
`共用体~型$であって，そのどの`~mb型$も直列化可能であるもの
◎
a union type where all of its member types are serializable types
</dt>
	<dd>
その`固有型$に従って変換される
◎
converted as per its specific type
</dd>
	<dt>
`連列~型$であって，その要素~型は直列化可能であるもの
◎
a sequence type that has a serializable type as its element type
</dt>
	<dd>
~listに変換される。
その各~要素は，連列の中の対応する要素を`直列化形の値に変換-$した結果で与えられる。
◎
converted to a list where each element is the result of converting its corresponding sequence element to a serialized value
</dd>
	<dt>
<!-- `辞書$ -->
`辞書~型$であって，そのどの`辞書~mb$も直列化可能な型であるもの
◎
a dictionary where all of its members have serializable types
</dt>
	<dd>
~mapに変換される。
その一連の~entryは、辞書に`在する$各~mb %m に対する~entry［
~key ~EQ %m の識別子,
~value ~EQ ［
%m の値を`直列化形の値に変換-$した結果
］］で与えられる。
◎
converted to a map consisting of an entry for each dictionary member that is present, where the entry’s key is the identifier of the dictionary member and its value is the result of converting the dictionary member’s value to a serializable type
</dd>
	<dt>
`~ifc型$であって，`直列化子$を持つもの
◎
an interface type that has a serializer
</dt>
	<dd>
~objの直列化子を呼出して変換される
◎
converted by invoking the object’s serializer
</dd>
</dl>

<p>
`直列化子$は `serializer^c ~keywordを伴う`演算$を利用して指定することもできる：
◎
Serializers can also be specified using an operation with the serializer keyword:
</p>

<pre class="syntax">
interface `interface_identifier^i {
  serializer `identifier^i();
};
</pre>

<p>
演算を伴って宣言される`直列化子$は、ゼロ個の引数をとり, かつ
`直列化可能な型$を返すものとして，宣言され~MUST。
◎
Serializers declared with operations must be declared to take zero arguments and return a serializable type.
</p>

<p>
`直列化子$が演算を伴って宣言されている~ifcにおける，`直列化-時の挙動$
は、その演算を呼出して返される値を`直列化形の値に変換-$した結果で与えられる。
◎
The serialization behavior of the interface with a serializer declared with an operation is the result of converting the value returned from invoking the operation to a serialized value.
</p>

<div class="grammar">
Serializer
SerializerRest
SerializationPattern
SerializationPatternMap
SerializationPatternList
Identifiers
</div>

<div class="example">
<p>
次の
`~IDL片$は、注釈文にて定義される`直列化子$を持つ， `Transaction^T ~ifcを定義する：
◎
The following IDL fragment defines an interface Transaction that has a serializer defines in prose:
</p>

<pre class="idl-code">
interface Transaction {
  readonly attribute Account from;
  readonly attribute Account to;
  readonly attribute double amount;
  readonly attribute DOMString description;
  readonly attribute unsigned long number;

  serializer;
};

interface Account {
  attribute DOMString name;
  attribute unsigned long number;
};
</pre>

<p>
直列化子は、次に従うように定義できる：
◎
The serializer could be defined as follows:
</p>

	<blockquote>
<p>
`Transaction^T ~ifcの`直列化-時の挙動$は、次の~algoで与えられる。
ここで %O は `Transaction^T を実装する~objであるとする：
◎
The serialization behavior of the Transaction interface is to run the following algorithm, where O is the object that implements Transaction:
</p>

		<ol class="algorithm">
			<!--cp-let-empty-map-->
			<li>
［
~key ~EQ `from^l,
~value ~EQ ［
%O 上の `from^M 属性から参照されている `Account^T ~obj上の `number^M 属性~値に対する`直列化形の値$
］］なる~entryを %map に追加する。
◎
Add an entry to map whose key is “from” and whose value is the serialized value of the number attribute on the Account object referenced by the from attribute on O.
</li>
			<li>
［
~key ~EQ `to^l,
~value ~EQ ［
%O 上の `to^M 属性から参照されている `Account^T ~obj上の `number^M 属性~値に対する`直列化形の値$
］］なる~entryを %map に追加する。
◎
Add an entry to map whose key is “to” and whose value is the serialized value of the number attribute on the Account object referenced by the from attribute on O.
</li><!-- *from attribute → to 〜 -->
			<li>
属性 `amount^c, `description^c のそれぞれに対し，［
~key ~EQ その属性の`識別子$,
~value ~EQ ［
%O 上のその属性~値に対する`直列化形の値$
］］なる~entryを %map に追加する。
◎
For both of the attributes amount and description, add an entry to map whose key is the identifier of the attribute and whose value is the serialized value of the value of the attribute on O.
</li>
			<!--cp-ret-map-->

		</ol>
	</blockquote>
<p>
`Account^T ~obj自身を直列化可能にしてもよいのであれば、`直列化~pattern$の利用により，注釈文による`直列化-時の挙動$を定義せずに済ませられるようになる：
◎
If it was acceptable for Account objects to be serializable on their own, then serialization patterns could be used to avoid having to define the serialization behavior in prose:
</p>

<pre class="idl-code">
interface Transaction {
  readonly attribute Account from;
  readonly attribute Account to;
  readonly attribute double amount;
  readonly attribute DOMString description;
  readonly attribute unsigned long number;

  serializer = { from, to, amount, description };
};

interface Account {
  attribute DOMString name;
  attribute unsigned long number;

  serializer = number;
};
</pre>

<p>
~JS言語束縛においては、
`Transaction^T ~obj上に `toJSON^c ~methが存在することになる：
◎
In the ECMAScript language binding, there would exist a toJSON method on Transaction objects:
</p>

<pre class="es-code">
// <span class="comment"
	title="Get an instance of Transaction."
>`Transaction^T の~instanceを取得-</span>
var txn = getTransaction();


/* <span class="comment"
	title="Evaluates to an object like this:"
> 次の様な~objに評価される：</span>
 {
   from: 1234
   to: 5678
   amount: 110.75
   description: "dinner"
 }
*/

txn.toJSON();

// <span class="comment"
	title="Evaluates to a string like this:"
>次の様な文字列に評価される：</span>
// '{"from":1234,"to":5678,"amount":110.75,"description":"dinner"}'
JSON.stringify(txn);
</pre>
</div>

				</section>
				<section id="idl-indexed-properties">
<h5 title="Indexed properties">2.2.4.4. 有index~prop</h5>

<p>
`有index~prop取得子$を定義する`~ifc$は、
`有index~propを~supportする@
という。
◎
An interface that defines an indexed property getter is said to support indexed properties.
</p>

<p>
~ifcが`有index~propを~supportする$場合、その~ifc定義には，所与の任意の時点で~objに~indexingし得る~indexについての記述も付随してい~MUST。
これらの~indexは
`被support~prop~index@
と呼ばれる。
◎
If an interface supports indexed properties, then the interface definition must be accompanied by a description of what indices the object can be indexed with at any given time. These indices are called the supported property indices.
</p>

<p>
`有index~prop取得子$は、１個の `unsigned long$T 引数をとるように宣言され~MUST。
有index~propの設定子は、２個の引数をとり,
第一~引数が `unsigned long$T をとるように宣言され~MUST。
◎
Indexed property getters must be declared to take a single unsigned long argument. Indexed property setters must be declared to take two arguments, where the first is an unsigned long.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  getter `type^i `identifier^i(unsigned long `identifier^i);
  setter `type^i `identifier^i(unsigned long `identifier^i, `type^i `identifier^i);

  getter `type^i (unsigned long `identifier^i);
  setter `type^i (unsigned long `identifier^i, `type^i `identifier^i);
};
</pre>

<p>
次の要件が，有index~propの［
取得子, 設定子
］の定義に適用される：
◎
The following requirements apply to the definitions of indexed property getters and setters:
</p>
<ul>
	<li>
<p>
`有index~prop取得子$の宣言に利用された`演算$が`識別子$を：
</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の`被support~prop~index$による~indexingの際に返される値は、その演算を，その~indexを唯一の引数に渡して呼出したときと同じになる。
</li>
			<li>
持たない場合、その~ifc定義には，所与の~indexに対し
`有index~propの値を決定する@
方法についての記述も付随してい~MUST。
</li>
		</ul>
◎
If an indexed property getter was specified using an operation with an identifier, then the value returned when indexing the object with a given supported property index is the value that would be returned by invoking the operation, passing the index as its only argument. If the operation used to declare the indexed property getter did not have an identifier, then the interface definition must be accompanied by a description of how to determine the value of an indexed property for a given index.
</li>
	<li>
<p>
`有index~prop設定子$の宣言に利用された`演算$が`識別子$を：
</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の
( `被support~prop~index$, 値 )
による，~prop代入のための~indexingの際に生じる挙動は、その演算の第一~引数に~indexを, 第二~引数に値を渡して呼出したときと同じになる。
</li>
			<li>
持たない場合、その~ifc定義には，所与の
( ~prop~index, 値 )
に対し［
`既存の有index~propを設定する@
方法, および
`新たな有index~propを設定する@
方法
］についての記述も付随してい~MUST。
</li>
		</ul>

◎
If an indexed property setter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property assignment with a given supported property index and value is the same as if the operation is invoked, passing the index as the first argument and the value as the second argument. If the operation used to declare the indexed property setter did not have an identifier, then the interface definition must be accompanied by a description of how to set the value of an existing indexed property and how to set the value of a new indexed property for a given property index and value.
</li>
</ul>


<div class="note">
<p>
`有index~prop$の［
取得子／設定子
］が`識別子$を伴う`演算$を利用して指定されている場合、~objに対する［
`被support~prop~index$でない整数
］による~indexingは，その~indexによる演算の呼出しと同じ挙動をなぞるとは限らないことに注意。
この場合における実際の挙動は、言語束縛~特有になる。
◎
Note that if an indexed property getter or setter is specified using an operation with an identifier, then indexing an object with an integer that is not a supported property index does not necessarily elicit the same behavior as invoking the operation with that index. The actual behavior in this case is language binding specific.
</p>

<p>
~JS言語束縛においては，~~通常の~prop検索が行われる。
例えば次の~IDLでは：
◎
In the ECMAScript language binding, a regular property lookup is done. For example, take the following IDL:
</p>
<!-- language -->

<pre class="idl-code">
interface A {
  getter DOMString toWord(unsigned long index);
};
</pre>

<p>
`A^T を実装している~objの`被support~prop~index$は，範囲［
0 ~LTE %index ~LT 2
］とする。
また、 `toWord^M は，引数の数字を英単語に変換した文字列を返すように定義されているとする。
範囲~外の~indexにより`演算$を呼出したときの挙動は，~objの直接的な~indexingとは異なる：
◎
Assume that an object implementing A has supported property indices in the range 0 ≤ index &lt; 2. Also assume that toWord is defined to return its argument converted into an English word. The behavior when invoking the operation with an out of range index is different from indexing the object directly:
</p>

<pre class="es-code">
var a = getA();

a.toWord(0);  // <span class="comment"
	title="Evaluates to &quot;zero&quot;."
>`zero^l  に評価される。</span>
a[0];         // <span class="comment"
	title="Also evaluates to &quot;zero&quot;."
>これも `zero^l に評価される。</span>

a.toWord(5);  // <span class="comment"
	title="Evaluates to &quot;five&quot;."
>`five^l に評価される。</span>
a[5];         // <span class="comment"
	title="Evaluates to undefined, since there is no property &quot;5&quot;."
>~prop `5^l は存在しないので `undefined^v に評価される。</span>
</pre>
</div>

<div class="example">
<p>
次の`~IDL片$は
名前または~indexによる値の取得0と設定を許容する
`OrderedMap^T
~ifcを定義する：
◎
The following IDL fragment defines an interface OrderedMap which allows retrieving and setting values by name or by index number:
</p>

<pre class="idl-code">
interface OrderedMap {
  readonly attribute unsigned long size;

  getter any getByIndex(unsigned long index);
  setter void setByIndex(unsigned long index, any value);

  getter any get(DOMString name);
  setter void set(DOMString name, any value);
};
</pre>

<p>
すべての特殊~演算が識別子を伴う演算を利用して宣言されているので、追加を要する唯一の注釈文は，これらの集合が持つ~keyを与える記述になる。
`OrderedMap^T 内に存在しない項目に対する検索が試みられた場合に対し，
`get()^c 演算が `null^V を返すように定義されているとするとき、次の２~~文で足りるであろう：
◎
Since all of the special operations are declared using operations with identifiers, the only additional prose that is necessary is that which describes what keys those sets have. Assuming that the get() operation is defined to return null if an attempt is made to look up a non-existing entry in the OrderedMap, then the following two sentences would suffice:
</p>

	<blockquote>
<p>
`OrderedMap^T を実装する~obj %map は、範囲［
0 ~LTE %index&nbsp;&lt;&nbsp;`map.size^c
］の`有index~propを~supportする$。
◎
An object map implementing OrderedMap supports indexed properties with indices in the range 0 ≤ index &lt; map.size.
</p>

<p>
そのような~objは、
`get()^c に渡されたときに非 `null^V 値が返されるような，どの名前に対しても、有名~propを~supportする。
◎
Such objects also support a named property for every name that, if passed to get(), would return a non-null value.
</p>
	</blockquote>

<p>
`es-platform-objects$sec
にて述べられるように、~JS実装は［
有名, 有index
］いずれの~propの集合に対しても、その集合に属する各項に対応する~propを［
`OrderedMap^T を実装している`~platform~obj$
］上に，作成することになるであろう。
下に示すように、これらの~propを，~objの~methの呼出しと同じ仕方で，~objとのやり取りに利用できる：
◎
As described in §3.8 Platform objects implementing interfaces, an ECMAScript implementation would create properties on a platform object implementing OrderedMap that correspond to entries in both the named and indexed property sets. These properties can then be used to interact with the object in the same way as invoking the object’s methods, as demonstrated below:
</p>

<pre class="es-code">
// <span class="comment"
	title="Assume map is a platform object implementing the OrderedMap interface."
>%map は `OrderedMap^T ~ifcを実装する~platform~objであるとする。</span>
var map = getOrderedMap();
var x, y;

x = map[0];       /* <span class="comment"
	title="If map.length &gt; 0, then this is equivalent to:

  x = map.getByIndex(0)

since a property named &quot;0&quot; will have been placed on map.
Otherwise, x will be set to undefined, since there will be
no property named &quot;0&quot; on map.">
`map.length^c ~GT 0 ならば、
`x = map.getByIndex(0)^c
と等価になる（名前 `0^l の~propが %map 上に置かれるので）。
他の場合、名前 `0^l の~propは %map 上にないので，
%x は `undefined^v に設定されることになる。</span> */

map[1] = false;   /* <span class="comment"
	title="This will do the equivalent of:

  map.setByIndex(1, false)">
これは、
`map.setByIndex(1, false)^c
と等価な動作になる。
</span> */

y = map.apple;    /* <span class="comment"
	title="If there exists a named property named &quot;apple&quot;, then this
will be equivalent to:

  y = map.get('apple')

since a property named &quot;apple&quot; will have been placed on
map.  Otherwise, y will be set to undefined, since there
will be no property named &quot;apple&quot; on map.">
名前 `apple^l の有名~propが存在する場合、
%map 上には名前 `apple^l の~propがあり，
`y = map.get('apple')^c
と等価な動作になる。
他の場合、 %map 上に名前 `apple^l の~propはないので，
%y は `undefined^v に設定されることになる。</span> */

map.berry = 123;  /* <span class="comment"
	title="This will do the equivalent of:

  map.set('berry', 123)">
これは、
`map.set('berry', 123)^c
と等価な動作になる。
</span> */

delete map.cake;  /* <span class="comment"
	title="If a named property named &quot;cake&quot; exists, then the &quot;cake&quot;
property will be deleted, and then the equivalent to the
following will be performed:

	  map.remove(&quot;cake&quot;)">
有名~prop `cake^l が存在するならば、 `cake^l ~propは削除され，
`map.remove("cake")^c
と等価な動作になる。
</span> */

</pre></div>
				</section>
				<section id="idl-named-properties">
<h5 title="Named properties">2.2.4.5. 有名~prop</h5>


<p>
`有名~prop取得子$を定義する`~ifc$は、
`有名~propを~supportする@
という。
◎
An interface that defines a named property getter is said to support named properties.
</p>

<p>
`有名~propを~supportする$~ifcの~ifc定義には、［
所与の任意の時点で~objに~indexingし得るような名前からなる，有順序~集合
］についての記述も付随してい~MUST。
これらの名前は、
`被support~prop名@
と呼ばれる。
◎
If an interface supports named properties, then the interface definition must be accompanied by a description of the ordered set of names that can be used to index the object at any given time. These names are called the supported property names.
</p>

<p>
有名~propの取得子と削除子は、１個の `DOMString$T 引数をとるように宣言され~MUST。
有名~propの設定子は、２個の引数をとり，第一~引数に `DOMString$T をとるように宣言され~MUST。
◎
Named property getters and deleters must be declared to take a single DOMString argument. Named property setters must be declared to take two arguments, where the first is a DOMString.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  getter `type^i `identifier^i(DOMString `identifier^i);
  setter `type^i `identifier^i(DOMString `identifier^i, `type^i `identifier^i);
  deleter `type^i `identifier^i(DOMString `identifier^i);

  getter `type^i (DOMString `identifier^i);
  setter `type^i (DOMString `identifier^i, `type^i `identifier^i);
  deleter `type^i (DOMString `identifier^i);
};
</pre>

<p>
次の要件が，有名~propの［
取得子, 設定子, 削除子
］の定義に適用される：
◎
The following requirements apply to the definitions of named property getters, setters and deleters:
</p>
<ul>
	<li>
<p>
`有名~prop取得子$の宣言に利用された`演算$が`識別子$を：
</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の`被support~prop名$による~indexingの際に返される値は、その演算を，その~prop名を唯一の引数に渡して呼出したときと同じになる。
</li>
			<li>
持たない場合、その~ifc定義には，所与の~prop名に対し
`有名~propの値を決定する@
方法についての記述も付随してい~MUST。
</li>
		</ul>

◎
If a named property getter was specified using an operation with an identifier, then the value returned when indexing the object with a given supported property name is the value that would be returned by invoking the operation, passing the name as its only argument. If the operation used to declare the named property getter did not have an identifier, then the interface definition must be accompanied by a description of how to determine the value of a named property for a given property name.
</li>
	<li>
<p>
`有名~prop設定子$の宣言に利用された`演算$が`識別子$を：
</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の
( `被support~prop名$, 値 )
による，~prop代入のための~indexingの際に生じる挙動は、
その演算の第一~引数に~prop名を, 第二~引数に値を渡して呼出したときと同じになる。
</li>
			<li>
持たない場合、その~ifc定義には，所与の
( ~prop名, 値 )
に対し［
`既存の有名~propを設定する@
方法, および
`新たな有名~propを設定する@
方法
］についての記述も付随してい~MUST。
</li>
		</ul>
◎
If a named property setter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property assignment with a given supported property name and value is the same as if the operation is invoked, passing the name as the first argument and the value as the second argument. If the operation used to declare the named property setter did not have an identifier, then the interface definition must be accompanied by a description of how to set the value of an existing named property and how to set the value of a new named property for a given property name and value.
</li>
	<li>
<p>
`有名~prop削除子$の宣言に利用された`演算$が`識別子$を：
</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の`被support~prop名$による，~prop削除のための~indexingの際に生じる挙動は、その演算を，その~prop名を唯一の引数に渡して呼出したときと同じになる。
</li>
			<li>
持たない場合、その~ifc定義には，所与の~prop名に対し
`既存の有名~propを削除する@
方法についての記述も付随してい~MUST。
</li>
		</ul>
◎
If a named property deleter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property deletion with a given supported property name is the same as if the operation is invoked, passing the name as the only argument. If the operation used to declare the named property deleter did not have an identifier, then the interface definition must be accompanied by a description of how to delete an existing named property for a given property name.
</li>
</ul>


<p class="note">注記：
`有index~prop$のときと同様に，`有名~prop$の［
取得子／設定子／削除子
］が`識別子$を伴う`演算$を利用して指定された場合、~objに対する［
`被support~prop名$でない名前
］による~indexingは，その名前による演算の呼出しと同じ挙動をなぞるとは限らないことに注意。
挙動は、言語束縛~特有になる。
◎
Note: As with indexed properties, if an named property getter, setter or deleter is specified using an operation with an identifier, then indexing an object with a name that is not a supported property name does not necessarily elicit the same behavior as invoking the operation with that name; the behavior is language binding specific.
</p>

				</section>
			</section>
			<section id="idl-static-attributes-and-operations">
<h4 title="Static attributes and operations">2.2.5. 静的~属性と静的~演算</h4>


<p>
<span>`静的~属性@</span>,
`静的~演算@
は、それが宣言される`~ifc$の個々の~instance上には結付けられないものであり、代わりに，その ~ifc自身に結付けられる。
静的~属性と静的~演算は，それらの宣言の中で `static^c ~keywordを利用して宣言される。
◎
Static attributes and static operations are ones that are not associated with a particular instance of the interface on which it is declared, and is instead associated with the interface itself. Static attributes and operations are declared by using the static keyword in their declarations.
</p>

<p>
静的~演算の呼出しや静的~属性の取得-／設定-が，~ifcの~instanceへの参照を通して可能かどうかは、言語束縛~特有になる。
◎
It is language binding specific whether it is possible to invoke a static operation or get or set a static attribute through a reference to an instance of the interface.
</p>

<p>
静的~演算／静的~属性は，`呼戻~ifc$上で宣言されては~MUST_NOT。
◎
Static attributes and operations must not be declared on callback interfaces.
</p>

<div class="grammar">
StaticMember
StaticMemberRest
</div>

<div class="example">
<p>
次の`~IDL片$は、静的~演算が宣言されている
`Circle^T ~ifcを定義する：
◎
The following IDL fragment defines an interface Circle that has a static operation declared on it:
</p>

<pre class="idl-code">
interface Point { /* ... */ };

interface Circle {
  attribute double cx;
  attribute double cy;
  attribute double radius;

  static readonly attribute long triangulationCount;
  static Point triangulate(Circle c1, Circle c2, Circle c3);
};
</pre>

<p>
~JS言語束縛においては、
`Circle^T に対応する`~ifc~obj$上に，
`triangulate^M に対応する `Function^t ~obj, および
`triangulationCount^M に対応する~accessor~prop
が存在することになる：
◎
In the ECMAScript language binding, the Function object for triangulate and the accessor property for triangulationCount will exist on the interface object for Circle:
</p>

<pre class="es-code">
var circles = getCircles();        // <span class="comment"
	title="an Array of Circle objects"
>`Circle^T ~objの `Array^t</span>

typeof Circle.triangulate;         // <span class="comment" id="cp-eval-function"
	title="Evaluates to &quot;function&quot;"
>`function^l に評価される。</span>
typeof Circle.triangulationCount;  // <span class="comment"
	title="Evaluates to &quot;number&quot;"
>`number^l に評価される。</span>
Circle.prototype.triangulate;      // <span class="comment" id="cp-eval-undefined"
	title="Evaluates to undefined"
>`undefined^v に評価される。</span>
Circle.prototype.triangulationCount;  // <span class="comment"
	title="Also evaluates to undefined"
>これも `undefined^v に評価される。</span>
circles[0].triangulate;            // <span class="comment"
	title="As does this"
>これも。</span>
circles[0].triangulationCount;     // <span class="comment"
	title="And this"
>これも。</span>

// <span class="comment"
	title="Call the static operation"
>静的~演算の~call</span>
var triangulationPoint = Circle.triangulate(circles[0], circles[1], circles[2]);
// <span class="comment"
	title="Find out how many triangulations we have done"
>`triangulate^M を呼んだ回数を調べる</span>
window.alert(Circle.triangulationCount);

</pre>

</div>
			</section>
			<section id="idl-overloading">
<h4 title="Overloading">2.2.6. 多重定義</h4>


<p>
`~ifc$上に定義される
`正則~演算$／`静的~演算$
が，その~ifc上の同じ種類の別の（正則／静的）演算と
同じ`識別子$を持つ場合、その演算は
`多重定義@
されているという。
その~ifcを実装する~obj上で，それらの演算のどれかを呼出すために多重定義された演算の識別子が利用された際に，どの演算が実際に呼出されるかは、演算に渡された引数の個数と型により決定される。
~ifc上に複数の`旧来呼出子$が定義されている場合も、それらの旧来呼出子は多重定義されているという。
~JS言語束縛においては
`Constructor$x も多重定義され得る。
多重定義された［
演算／旧来呼出子／構築子
］がとり得る引数の指定には一定の制約があり、これらの制約を記述するため，`有効~多重定義~集合$の~~概念が利用される。
◎
If a regular operation or static operation defined on an interface has an identifier that is the same as the identifier of another operation on that interface of the same kind (regular or static), then the operation is said to be overloaded. When the identifier of an overloaded operation is used to invoke one of the operations on an object that implements the interface, the number and types of the arguments passed to the operation determine which of the overloaded operations is actually invoked. If an interface has multiple legacy callers defined on it, then those legacy callers are also said to be overloaded. In the ECMAScript language binding, constructors can be overloaded too. There are some restrictions on the arguments that overloaded operations, legacy callers and constructors can be specified to take, and in order to describe these restrictions, the notion of an effective overload set is used.
</p>

<p>
`演算$／`旧来呼出子$は、複数の［
`~ifc$定義, および その`部分的~ifc定義$
］にまたがって多重定義されては~MUST_NOT。
◎
Operations and legacy callers must not be overloaded across interface and partial interface definitions.
</p>

<div class="note">
<p>
例えば，次の様な `f^T, `g^T の多重定義は許容されない：
◎
For example, the overloads for both f and g are disallowed:
</p>

<pre class="idl-code">
interface A {
  void f();
};

partial interface A {
  void f(double x);
  void g();
};

partial interface A {
  void g(DOMString x);
};
</pre>

<p>
構築子の多重定義については、元々`部分的~ifc定義$上には［
`Constructor$x, `NamedConstructor$x
］`拡張属性$の出現が許容されていないので，同様の制約は~~自動的に満たされることに注意。
◎
Note that the [Constructor] and [NamedConstructor] extended attributes are disallowed from appearing on partial interface definitions, so there is no need to also disallow overloading for constructors.
</p>
</div>


<div class="p">
<p>
`有効~多重定義~集合@
とは、個々の
`関数類@
— ［
`演算$ ／
構築子（ `Constructor$x または `NamedConstructor$x により指定される） ／
`旧来呼出子$ ／
`呼戻~関数$
］ —
に許容され得る呼出を表現するものである。
</p>

<p class="trans-note">【
“関数類（引数を伴って~callし得る~IDL構成子）”
という語は、簡潔に総称するためにこの訳に導入した，非公式な用語である。
】</p>

<p>
`有効~多重定義~集合$を算出する~algoは、次に挙げる６種の~IDL構成子に対し演算する。
算出するために必要な入力は、渡される引数の個数, および
`関数類$の種別に応じて，以下に示されるものになる：
</p>
◎
An effective overload set represents the allowable invocations for a particular operation, constructor (specified with [Constructor] or [NamedConstructor]), legacy caller or callback function. The algorithm to compute an effective overload set operates on one of the following six types of IDL constructs, and listed with them below are the inputs to the algorithm needed to compute the set.
</div>


<dl class="switch">
	<dt>正則~演算◎For regular operations</dt>
	<dt>静的~演算◎For static operations</dt>
	<dd>
`演算$が見出された`~ifc$, および
演算の`識別子$
◎
the interface on which the operations are to be found
◎
the identifier of the operations
◎
the number of arguments to be passed
</dd>

	<dt>旧来呼出子◎For legacy callers</dt>
	<dd>
`旧来呼出子$が見出された`~ifc$
◎
the interface on which the legacy callers are to be found
◎
the number of arguments to be passed
</dd>
	<dt>構築子◎For constructors</dt>
	<dd>
`Constructor$x `拡張属性$が見出された`~ifc$
◎
the interface on which the [Constructor] extended attributes are to be found
◎
the number of arguments to be passed
</dd>

	<dt>有名~構築子◎For named constructors</dt>
	<dd>
`NamedConstructor$x `拡張属性$が見出された`~ifc$, および
有名~構築子の`識別子$
◎
the interface on which the [NamedConstructor] extended attributes are to be found
◎
the identifier of the named constructors
◎
the number of arguments to be passed
</dd>

	<dt>呼戻~関数◎For callback functions</dt>
	<dd>
`呼戻~関数$
◎
the callback function
◎
the number of arguments to be passed
</dd>

</dl>

<p>
有効~多重定義~集合は、他のものと伴に，~ifc上に多重定義された`関数類$が多義性を孕んでいるかどうか決定するために利用される。
◎
An effective overload set is used, among other things, to determine whether there are ambiguities in the overloaded operations, constructors and callers specified on an interface.
</p>

<div >
<p>
有効~多重定義~集合の各~要素は，~tuple
&lt;`ol-callable^, `ol-type-list^, `ol-optionality-list^&gt;
である：
</p>

<ul>
	<li>
<dfn id="ol-callable">%callable</dfn>
は、`関数類$の種別に応じて，次になる：
		<ul>
			<li>
［
正則~演算／静的~演算／旧来呼出子
］に対しては，その いずれかの演算。
</li>
			<li>
［
構築子／有名~構築子
］に対しては，その いずれかの拡張属性。
</li>
			<li>
［
呼戻~関数
］に対しては，呼戻~関数~自身。
</li>
		</ul>
	</li>
	<li>
<dfn id="ol-type-list">`型~list^var</dfn>
は、 `ol-callable^ の一連の引数にあてがわれている~IDL型の~listである。
</li>
	<li>
<dfn id="ol-optionality-list">`省略可否~list^var</dfn>
は，［
`省略可否 値@
と称される値
］の~listであり、それぞれの値は［
所与の~indexに位置する引数が［
“`必須^C”,
“`省略可^C”,
“`可変個^C”
］のいずれであるか
］を指示する。
</li>
</ul>

<p>
各~tupleは、［
所与の一連の型
］による引数~値~listに許容され得る`関数類$の呼出を表現する。
`随意~引数$や［
`可変個の引数をとる$`関数類$ （すなわち，演算か構築子）
］の利用に因り、有効~多重定義~集合~内には，同じ種類の`関数類$を識別する複数の~entryが存在し得る。
</p>

◎
The elements of an effective overload set are tuples of the form &lt;callable, type list, optionality list&gt;. If the effective overload set is for regular operations, static operations or legacy callers, then callable is an operation; if it is for constructors or named constructors, then callable is an extended attribute; and if it is for callback functions, then callable is the callback function itself. In all cases, type list is a list of IDL types, and optionality list is a list of three possible optionality values – “required”, “optional” or “variadic” – indicating whether the argument at a given index was declared as being optional or corresponds to a variadic argument. Each tuple represents an allowable invocation of the operation, constructor, legacy caller or callback function with an argument value list of the given types. Due to the use of optional arguments and variadic operations and constructors, there may be multiple entries in an effective overload set identifying the same operation or constructor.
</div>


<p>
下の~algoが，有効~多重定義~集合を算出する方法を記述する。
必要に応じて，上述の入力~変数が利用される：
◎
The algorithm below describes how to compute an effective overload set. The following input variables are used, if they are required:
</p>
<ul>
	<li>
%A は［
演算／有名~構築子
］の識別子
◎
the identifier of the operation or named constructor is A
</li>
	<li>
%N は引数個数
◎
the argument count is N
</li>
	<li>
%I は~ifc
◎
the interface is I
</li>
	<li>
%C は呼戻~関数
◎
the callback function is C
</li>
</ul>

<p>
拡張属性に対する引数が示されるときはいつでも，その拡張属性の`有名~引数~list$の引数を指しているものとする。
◎
Whenever an argument of an extended attribute is mentioned, it is referring to an argument of the extended attribute’s named argument list.
</p>

<ol class="algorithm">
	<li>
%S :← ∅
◎
Initialize S to ∅.
</li>
	<li>
<p>
%F := 有効~多重定義~集合の種類に応じて，次で与えられる要素の集合：
◎
Let F be a set with elements as follows, according to the kind of effective overload set:
</p>
		<dl class="switch">
			<dt>正則~演算◎For regular operations</dt>
			<dd><p>
%I 上で定義された`正則~演算$のうち，識別子が %A であるもの
◎
The elements of F are the regular operations with identifier A defined on interface I.
</p></dd>
			<dt>静的~演算◎For static operations</dt>
			<dd><p>
%I 上で定義された`静的~演算$のうち，識別子が %A であるもの
◎
The elements of F are the static operations with identifier A defined on interface I.
</p></dd>
			<dt>構築子◎For constructors</dt>
			<dd><p>
%I 上の `Constructor$x `拡張属性$
◎
The elements of F are the [Constructor] extended attributes on interface I.
</p></dd>
			<dt>有名~構築子◎For named constructors</dt>
			<dd><p>
%I 上の `NamedConstructor$x `拡張属性$のうち，その`有名~引数~list$の識別子が %A であるもの
◎
The elements of F are the [NamedConstructor] extended attributes on interface I whose named argument lists’ identifiers are A.
</p></dd>
			<dt>旧来呼出子◎For legacy callers</dt>
			<dd><p>
%I 上で定義された `旧来呼出子$
◎
The elements of F are the legacy callers defined on interface I.
</p></dd>
			<dt>呼戻~関数◎For callback functions</dt>
			<dd><p>
呼戻~関数~自身である %C （唯一つ）
◎
The single element of F is the callback function itself, C.
</p></dd>

		</dl>
	</li>
	<li>
<p>
%maxarg := %F の中の各~要素（`関数類$
）が宣言している引数~個数の最大
— ただし，［
`可変個の引数をとる$ `関数類$
］の中の`末尾~引数$は、 1 個の引数に数える
◎
Let maxarg be the maximum number of arguments the operations, constructor extended attributes or callback functions in F are declared to take. For variadic operations and constructor extended attributes, the argument on which the ellipsis appears counts as a single argument.
</p>

<p class="note">注記：
したがって
`void f(long x, long... y);^c
が宣言している引数~個数は 2 個と見なされる。
◎
Note: So void f(long x, long... y); is considered to be declared to take two arguments.
</p>


</li>
	<li>
%m := %maxarg と %N の最大
◎
Let m be the maximum of maxarg and N.
</li>
	<li>
<p>
~FOR
%F 内の~EACH ( %X ) に対し：
◎
For each operation, extended attribute or callback function X in F:
</p>

<p class="trans-note">【
見通しを良くするため、この下位手続きの記述は，原文のものから手を加えている。
】</p>


		<ol class="algorithm">
			<li>
%n := %X が宣言している引数~個数（従って %n ~LTE %m ）
◎
Let n be the number of arguments X is declared to take.
</li>
			<li>
~FOR
0 ~LTE %i ~LT %n なる ~EACH( 整数 %i ) に対し：
<span class="block">
%t<sub>%i</sub> := ~index %i に位置する %X の引数の型,<br>
%o<sub>%i</sub> := ［
~index %i に位置する %X の引数が［
随意ならば “`省略可^C” ／
~ELSE_ “`必須^C”
］］
</span>
◎
Let t0..n−1 be a list of types, where ti is the type of X’s argument at index i.
◎
Let o0..n−1 be a list of optionality values, where oi is “variadic” if X’s argument at index i is a final, variadic argument, “optional” if the argument is optional, and “required” otherwise.
◎
↓↓Add to S the tuple &lt;X, t0..n−1, o0..n−1&gt;.
</li>
			<li>
<p>
~IF
%X は `可変個の引数をとる$ように宣言されている
⇒
◎
If X is declared to be variadic, then:
</p>
				<ol>
					<li>
%o<sub>%n−1</sub> := “`可変個^C” （上の設定を上書き）
◎
↑</li>
					<li>
<p>
~FOR
%n ~LTE %i ~LT %m なる ~EACH( 整数 %i ) に対し，~~昇順に：
◎
For every integer i, such that n ≤ i ≤ m−1:
</p>

						<ol>
							<li>
%t<sub>%i</sub> := %t<sub>%n−1</sub>,<br>
%o<sub>%i</sub> := “`可変個^C”
◎
Let u0..i be a list of types, where uj = tj (for j &lt; n) and uj = tn−1 (for j ≥ n).
◎
Let p0..i be a list of optionality values, where pj = oj (for j &lt; n) and pj = “variadic” (for j ≥ n).
</li>
							<li>
~tuple
&lt;%X, (%t<sub>0</sub> … %t<sub>%i</sub>), (%o<sub>0</sub> … %o<sub>%i</sub>)&gt;
を %S に追加する
◎
Add to S the tuple &lt;X, u0..i, p0..i&gt;.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~FOR
%n ~GT %i ~GTE −1 なる ~EACH( 整数 %i ) に対し，~~降順に：
</p>
				<ol>
					<li>
<p>
~IF %i ~EQ −1：
</p>
						<ol>
							<li>
~tuple &lt;%X, (), ()&gt; を %S に追加する
</li>
							<li>
~BREAK
</li>
						</ol>
					</li>
					<li>
~tuple
&lt;%X, (%t<sub>0</sub> … %t<sub>%i</sub>), (%o<sub>0</sub> … %o<sub>%i</sub>)&gt;
を %S に追加する
</li>
					<li>
~IF
%o<sub>%i</sub> ~EQ “`必須^C”
~THEN
~BREAK
</li>
				</ol>
◎
Initialize i to n−1.
◎
While i ≥ 0:
• If argument i of X is not optional (i.e., it is not marked as optional and is not a final, variadic argument), then break this loop.
• Otherwise, add to S the tuple &lt;X, t0..i−1, o0..i−1&gt;.
• Set i to i−1.
</li>
		</ol>
	</li>
	<li>
有効~多重定義~集合は %S である
◎
The effective overload set is S.
</li>
</ol>

<div class="example" id="_dist-example-1_">
<p>
次の~ifcに対し：
◎
For the following interface:
</p>

<pre class="idl-code">
interface A {
  /* f1 */ void f(DOMString a);
  /* f2 */ void f(Node a, DOMString b, double... c);
  /* f3 */ void f();
  /* f4 */ void f(Event a, DOMString b, optional DOMString c, double... d);
};
</pre>

<p>
`Node^T と `Event^T を，どの~objからも両方同時に実装できないような，別々の~ifcとするとき、［
識別子 `f^c,
引数個数 4
］の`正則~演算$からなる`有効~多重定義~集合$は：
◎
assuming Node and Event are two other interfaces of which no object can implement both, the effective overload set for regular operations with identifier f and argument count 4 is:
</p>
	<div class="set">
{ &lt;f1, (DOMString), (`必須^C)&gt;,<br>
  &lt;f2, (Node, DOMString), (`必須^C, `必須^C)&gt;,<br>
  &lt;f2, (Node, DOMString, double), (`必須^C, `必須^C, `可変個^C)&gt;,<br>
  &lt;f2, (Node, DOMString, double, double), (`必須^C, `必須^C, `可変個^C, `可変個^C)&gt;,<br>
  &lt;f3, (), ()&gt;,<br>
  &lt;f4, (Event, DOMString), (`必須^C, `必須^C)&gt;,<br>
  &lt;f4, (Event, DOMString, DOMString), (`必須^C, `必須^C, `省略可^C)&gt;,<br>
  &lt;f4, (Event, DOMString, DOMString, double), (`必須^C, `必須^C, `省略可^C, `可変個^C)&gt; }
	</div>
</div>


<p>
２つの型は、次の~algoが ~T を返すならば，
`判別可能@
であるとされる：
◎
Two types are distinguishable if the following algorithm returns true.
</p>

<ol class="algorithm">
	<li>
<div class="p">
<p>
~IF［
一方の型は`~nullable型を内包する$
］~AND［
他方の型は 次のいずれかを満たす
］
~THEN
~RET ~F：
</p>

<ul><li>`~nullable型を内包する$
</li><li>`共用体~型$である ~AND
その`平坦化~mb型$に［
`辞書~型$ ／ `~record型$
］が含まれている
</li><li>`辞書~型$である
</li><li>`~record型$である
</li></ul>

◎
If one type includes a nullable type and the other type either includes a nullable type, is a union type with flattened member types including a dictionary type or record type, or is a dictionary type or record type, return false.
</div>


<div class="example">

<p>
次の各~pairは、いずれも判別可能でない：
</p>

<ul><li>`double?^T と `record&lt;DOMString, DOMString&gt;^T
</li><li>`(Interface1 or long)?^T と `(Interface2 or DOMString)?^T
</li><li>`(Interface1 or long?)^T と `(Interface2 or DOMString)?^T
</li><li>`(Interface1 or long?)^T と `(Interface2 or DOMString?)^T
</li><li>`(Dictionary1 or long)^T と `(Interface2 or DOMString)?^T
</li><li>`(Dictionary1 or long)^T と `(Interface2 or DOMString?)^T
</li></ul>

<p>
（ `Interface1^T, `Interface2^T は ~ifc型，
`Dictionary1^T は 辞書~型とする）
</p>

◎
None of the following pairs are distinguishable:
• double? and record&lt;DOMString, DOMString&gt;
• (Interface1 or long)? and (Interface2 or DOMString)?
• (Interface1 or long?) and (Interface2 or DOMString)?
• (Interface1 or long?) and (Interface2 or DOMString?)
• (Dictionary1 or long) and (Interface2 or DOMString)?
• (Dictionary1 or long) and (Interface2 or DOMString?) 
</div>

	</li>
	<li>
~IF
両方の型とも［
`共用体~型$ ／~nullable共用体~型
］である
~THEN
~RET
両者のどの`~mb型$どうしも互いに判別可能であるならば ~T ／
~ELSE_ ~F
◎
If both types are either a union type or nullable union type, return true if each member type of the one is distinguishable with each member type of the other, or false otherwise.
</li>
	<li>
~IF
一方の型は［
`共用体~型$ ／~nullable共用体~型
］である
~THEN
~RET 
その共用体のどの`~mb型$も 他方の型と判別可能であるならば ~T ／
~ELSE_ ~F
◎
If one type is a union type or nullable union type, return true if each member type of the union type is distinguishable with the non-union type, or false otherwise.
</li>
	<li>
<p>
~IF
２つの型が（`~nullable型$の場合はその`内縁~型$が）下の表に現れ、かつ［
対応する欄に “●” 印がある, または［
対応する欄に英字があって，表の下に指定される追加の要件を満たす
］］
~THEN
~RET ~T
◎
If the two types (taking their inner types if they are nullable types) appear in the following table and there is a “●” mark in the corresponding entry or there is a letter in the corresponding entry and the designated additional requirement below the table is satisfied, then return true. Otherwise return false.
</p>

<div style="overflow:auto; margin-left:-2em;">
<table id="_disting">
<thead><tr><th>
<th><span>`boolean$T
</span><th><span>`実数~型$
</span><th><span>`文字列~型$
</span><th><span>`~ifc型$
</span><th><span>`~obj型$
</span><th><span>`呼戻~関数$
</span><th><span>`辞書~型$／`~record型$
</span><th><span>`連列~型$（ ~sequence_T ）
</span><th><span>`凍結~配列~型$（ ~FrozenArray_T ）
</span><th><span>`例外~型$
</span><th><span>`~buffer~source型$
</span><th></thead>

<tbody><tr><th>`boolean^T
<td><td>●<td>●<td>●<td>●<td>●
<td>●<td>●<td>●<td>●<td>●
<th>`boolean^T

<tr><th>実数~型
<td colspan="1"><td><td>●<td>●<td>●<td>●
<td>●<td>●<td>●<td>●<td>●
<th>実数~型

<tr><th>文字列~型
<td colspan="2"><td><td>●<td>●<td>●
<td>●<td>●<td>●<td>●<td>●
<th>文字列~型

<tr><th>~ifc
<td colspan="3"><td>(a)<td><td>(b)
<td>(b)<td>●<td>●<td>●<td>●
<th>~ifc

<tr><th>`object^T
<td colspan="4"><td>
<td><td><td><td><td><td>
<th>`object^T

<tr><th>呼戻~関数
<td colspan="5"><td>
<td><td>●<td>●<td>●<td>●
<th>呼戻~関数

<tr><th>辞書／~record
<td colspan="6">
<td><td>●<td>●<td>●<td>●
<th>辞書／~record

<tr><th>連列~型
<td colspan="7"><td><td><td>●<td>●
<th>~sequence_T

<tr><th>凍結~配列~型
<td colspan="8"><td><td>●<td>●
<th>~FrozenArray_T

<tr><th>例外~型
<td colspan="9"><td><td>●
<th>例外~型

<tr><th>~buffer~source型
<td colspan="10"><td>
<th>~buffer~source型

</tbody></table></div>

		<ul>
			<li>
<p>
(a) —
識別される２つの`~ifc$が，同じ`~platform~obj$に実装されることは起こり得ない（特に，２つは同じ~ifcでない）, かつ
少なくとも一方は`呼戻~ifc$でない。
◎
The two identified interfaces are not the same, it is not possible for a single platform object to implement both interfaces, and it is not the case that both are callback interfaces.
</p>

			</li>
			<li>
(b) —
２つのうち~ifc型の方は`呼戻~ifc$でない。
◎
The interface type is not a callback interface.
</li>
		</ul>
	</li>
	<li>
~RET ~F
◎
↑</li>

</ol>

<div class="example">

<ul>
	<li>
`double$T と `DOMString$T とは判別可能になる
— `実数~型$と`文字列~型$の交差する欄に ● 印があるので。
◎
double and DOMString are distinguishable because there is a ● at the intersection of numeric types with string types.
</li>
	<li>
`double$T と `long$T は判別可能でない
— 両者とも`実数~型$であり，`実数~型$と`実数~型$の交差する欄に ● 印はないので
◎
double and long are not distinguishable because they are both numeric types, and there is no ● or letter at the intersection of numeric types with numeric types.
</li>
	<li>
<p>
次の~IDL片が与えられたとするとき：
◎
Given:
</p>

<pre class="idl-code">
callback interface CBIface {
    attribute DOMString attr1;
};

interface Iface {
    attribute DOMString attr2;
};

dictionary Dict {
    DOMString field1;
};
</pre>

<p>
`CBIface^T は、
`Iface^T とは 判別可能になる（上の (a) を満たすので）が，
`Dict^T とは判別可能にならない（上の (b) を満たさないので）
◎
CBIface is distinguishable from Iface because the pair satisfies note (a), but it is not distinguishable from Dict because that pair does not satisfy note (b).
</li>
	<li>
`~promise型$は、上の表には現れていないので，他のどの型とも判別可能でない。
◎
Promise types do not appear in the above table, and as a consequence are not distinguishable with any other type.
</li>
</ul>
</div>

<p>
`有効~多重定義~集合$の中に，所与の`ol-type-list^長さを持つ~entryが複数ある場合、［
それらのどの２つの~entryに対しても~index %i に位置する２つの型が`判別可能$になる
］ような，~index %i が存在し~MUST。
そのような~indexのうち，最小のものを、
<span class="trans-note">【
その型~listの長さ, もしくはそれらの~entryの集合に対する
】</span>
`判別引数~index@
と呼ぶ。
◎
If there is more than one entry in an effective overload set that has a given type list length, then for those entries there must be an index i such that for each pair of entries the types at index i are distinguishable. The lowest such index is termed the distinguishing argument index for the entries of the effective overload set with the given type list length.
</p>

<div class="example">
<p>
前の例に示された有効~多重定義~集合を考える。
`ol-type-list^長さ 2, 3, 4 の集合はそれぞれ複数の~entryを含む。
これらの`ol-type-list^長さのそれぞれに対し，
`Node^T と `Event^T は`判別可能$になるので、`判別引数~index$は 0 である。
◎
Consider the effective overload set shown in the previous example. There are multiple entries in the set with type lists 2, 3 and 4. For each of these type list lengths, the distinguishing argument index is 0, since Node and Event are distinguishable.
</p>

<p>
しかしながら，次の多重定義の利用は妥当でない：
◎
The following use of overloading however is invalid:
</p>

<pre class="idl-code">
interface B {
  void f(long x);
  void f(double x);
};
</pre>

<p>
`long$T と `double$T は判別可能でないので。
<span class="trans-note">【
原文には `long$T ではなく， `DOMString$T と記されているが、それは今や
`double$T と判別可能になったので，修正している。
】</span>
◎
since DOMString and double are not distinguishable.
</p>
</div>

<p>
加えて，所与の`ol-type-list^長さに対する
`判別引数~index$
より小さい，どの~indexに対しても、［
`有効~多重定義~集合$のすべての~entryの，その~indexに位置する［
`ol-type-list^の型／`ol-optionality-list^の真偽~値
］は，同じで~MUST
］。
◎
In addition, for each index j, where j is less than the distinguishing argument index for a given type list length, the types at index j in all of the entries’ type lists must be the same and the booleans in the corresponding list indicating argument optionality must be the same.
</p>

<div class="example">
<p>
次は妥当でない：
◎
The following is invalid:
</p>

<pre class="idl-code">
interface B {
  /* f1 */ void f(DOMString w);
  /* f2 */ void f(long w, double x, Node y, Node z);
  /* f3 */ void f(double w, double x, DOMString y, Node z);
};
</pre>

<p>
引数個数 4 に対する
有効~多重定義~集合は：
◎
For argument count 4, the effective overload set is:
</p>

	<div class="set">
{ &lt;f1, (DOMString), (`必須^C)&gt;,<br>
  &lt;f2, (long, double, Node, Node), (`必須^C, `必須^C, `必須^C, `必須^C)&gt;,<br>
  &lt;f3, (double, double, DOMString, Node), (`必須^C, `必須^C, `必須^C, `必須^C)&gt; }
	</div>

<p>
であり、`ol-type-list^長さ 4 の~entryを調べると，
`Node^T と `DOMString$T は`判別可能$なので、
`判別引数~index$は 2 になる。
しかしながら，これらの２つの多重定義の~index 0 に位置する引数~型は異なるので、この多重定義は妥当でない。
◎
Looking at entries with type list length 4, the distinguishing argument index is 2, since Node and DOMString are distinguishable. However, since the arguments in these two overloads at index 0 are different, the overloading is invalid.
</p>
</div>


<div class="trans-note">

<p>【
複雑な条件だが，概念的には、共用体~型を利用して，多重定義された宣言を等価な単独の宣言に統合するために必要な条件が意図されている様に見られる。
例えば，<a href="#_dist-example-1_">先に挙げられた例</a>は次のように書き換え得る：
】</p>

<pre class="idl-code">
interface A {
             /*---f4----*/ /*-f2-*/     /*---f1----*/    /*-f3-*/
  void f(
    optional ( Event     or Node     or   DOMString ) a, /*----*/
    optional   DOMString             b, /*---------------------*/
    optional ( DOMString or double ) c, /*---------------------*/
               double...             d  /*---------------------*/
  );
};
</pre>

<p>【
しかしながら、例えば個別の宣言ごとに異なる拡張属性や特殊~演算が指定されることは，あるかもしれない
— そのような場合、統合できなくなる。
この仕様の中では，そのような指定~法を明示的に禁止している箇所は見当たらない
— 例えば次のように，拡張属性が多重定義の一部のみに指定されることも、無いとは言い切れない：
】</p>

<pre class="idl-code">
interface A {
  `NewObject$x T f(B a);
              T f(C a);
};
</pre>

</div>


			</section>
			<section id="idl-iterable">
<h4 title="Iterable declarations">2.2.7. 可反復~宣言</h4>

<p>
~ifcは
`可反復@
になるように宣言できる。
そのためには、`~ifc$の本体にて
`可反復~宣言@
（`Iterable$g に合致）を利用する。
◎
An interface can be declared to be iterable by using an iterable declaration (matching Iterable) in the body of the interface.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  iterable&lt;`value_type^i&gt;;
  iterable&lt;`key_type^i, `value_type^i&gt;;
};
</pre>

<p>
可反復として宣言された~ifcを実装している~objは、値の連列を得るために反復し得るようになる。
◎
Objects implementing an interface that is declared to be iterable support being iterated over to obtain a sequence of values.
</p>

<p class="note">注記：
~JS言語束縛においては、可反復な~ifcは、その`~ifc原型~obj$上に，［
`entries^l, `forEach^l, `keys^l, `values^l, `iterator$esS
］~propを持つことになる。
◎
Note: In the ECMAScript language binding, an interface that is iterable will have “entries”, “forEach”, “keys”, “values” and @@iterator properties on its interface prototype object.
</p>

<div>
<p>
~parameterとして所与の型の個数が：
</p>

<ul>
	<li>
1 個の場合、~ifcは，その型の値たちを提供する
`値~反復子@
を持つことになる。
</li>
	<li>
2 個の場合、~ifcは，［
~key, 値
］からなる~pairたちを提供する
`~pair反復子@
を持つことになる。
ここで、~pairの~keyは，最初の型の値をとり、~pairの値は，二番目の型の値をとる。
</li>
</ul>
◎
If a single type parameter is given, then the interface has a value iterator and provides values of the specified type. If two type parameters are given, then the interface has a pair iterator and provides value pairs, where the first value is a key and the second is the value associated with the key.
</div>

<p>
`値~反復子$を宣言できる~ifcは、`有index~propを~supportする$, かつ
名前 `length^l の`整数~型$の`属性$を持つもののみで~MUST。
`値~反復子$の値~型は、`有index~prop取得子$が返す型と同じで~MUST。
`値~反復子$は暗黙的に，当の~objの有index~prop上を反復するように定義される。
◎
A value iterator must only be declared on an interface that supports indexed properties and has an integer-typed attribute named “length”. The value-type of the value iterator must be the same as the type returned by the indexed property getter. A value iterator is implicitly defined to iterate over the object’s indexed properties.
</p>

<p>
`~pair反復子$は、`有index~propを~supportする$~ifc上に宣言されては~MUST_NOT。
`~pair反復子$を伴う`~ifc$においては、付随する注釈文にて［
何が
`反復される値~pair@
の~listを成すのか
］が定義され~MUST。
◎
A pair iterator must not be declared on an interface that supports indexed properties. Prose accompanying an interface with a pair iterator must define what the list of value pairs to iterate over is.
</p>


<div class="note">

<p>
`値~反復子$に対し生成される~JS `forEach^c ~methは、
`Array.prototype.forEach^c が行うように，その呼戻子を呼出す。
`~pair反復子$に対する `forEach^c ~methは、
`Map.prototype.forEach^c が行うように，その呼戻子を呼出す。
◎
The ECMAScript forEach method that is generated for a value iterator invokes its callback like Array.prototype.forEach does, and the forEach method for a pair iterator invokes its callback like Map.prototype.forEach does.
</p>

<p>
現在，`値~反復子$は`有index~propを~supportする$~ifcのみに許容されているので、
`forEach^c ~methを配列のように利用することにも~~意味がある。
`値~反復子$は、次のものにも必要かもしれない：
(a) `有index~propを~support$しない~ifc上, あるいは
(b) 呼戻子を，代わりに `Set.protoype.forEach^c のように呼出す（ここで~keyは，値と同じ）ような `forEach^c ~methに対して。
そのような `forEach^c ~methを必要とする~APIを再~作成している策定者は、
<a href="mailto:public-script-coord@w3.org">public-script-coord@w3.org</a>
宛まで要請されたし。
◎
Since value iterators are currently allowed only on interfaces that support indexed properties, it makes sense to use an Array-like forEach method. There may be a need for value iterators (a) on interfaces that do not support indexed properties, or (b) with a forEach method that instead invokes its callback like Set.protoype.forEach (where the key is the same as the value). If you’re creating an API that needs such a forEach method, please send a request to public-script-coord@w3.org.
</p>

</div>

<p class="note">注記：
`配列~反復子~obj$は，このように働く。
`有index~propを~supportする$ ~ifcに対しては、［
`entries^l ／ `keys^l ／ `values^l ／ `iterator$esS
］から返される反復子~objは，実際の`配列~反復子~obj$である。
◎
Note: This is how array iterator objects work. For interfaces that support indexed properties, the iterator objects returned by “entries”, “keys”, “values” and @@iterator are actual array iterator objects.
</p>

<p>
可反復~宣言を伴う~ifcの［
`広義~帰結~ifc$, `被継承~ifc$
］は、名前［
`entries^l ／ `forEach^l ／ `keys^l ／ `values^l
］の`~ifc~mb$を持っては~MUST_NOT。
◎
Interfaces with iterable declarations must not have any interface members named “entries”, “forEach”, “keys” or “values”, or have any inherited or consequential interfaces that have interface members with these names.
</p>


<div class="example">
<p>
次の~ifcを考える。
`SessionManager^T は、一連の `Session^T ~objに~accessできるようにする：
◎
Consider the following interface SessionManager, which allows access to a number of Session objects:
</p>

<pre class="idl-code">
interface SessionManager {
  Session getSessionForUser(DOMString username);
  readonly attribute unsigned long sessionCount;

  iterable&lt;Session&gt;;
};

interface Session {
  readonly attribute DOMString username;
  // <span class="comment">...</span>
};
</pre>

<p>
反復子の挙動は、次に従うように定義できる：
◎
The behavior of the iterator could be defined like so:
</p>

<blockquote>
<p>
<i>反復される値</i>
は、［
`username^M の昇順で整列された，
`SessionManager^T 上の一連の `Session^T ~obj
］である。
◎
The values to iterate over are the open Session objects on the SessionManager sorted by username.
</p>

<p class="issue">
除去された定義 “反復される値” への参照を修正する。
◎
Fix reference to removed definition for "values to iterate over".
</p>

</blockquote>

<p>
~JS言語束縛においては、
`SessionManager^T `~ifc$に対する`~ifc原型~obj$は、［
被呼出時に［［
次の反復値を返す `next^c ~meth
］を持つ反復子~obj
］を返すような，関数
］である `values^c ~meth
を持つことになる。
それは、［
一連の `Session^T ~objからなる~list
］の［
各~index ／
各 ( ~index, `Session^T ~obj ) ~pair
］を反復する［
`values^c ／ `entries^c
］~methを持つ。
それは、 `SessionManager^T を `for..of^c ~loopの中でも利用できるようする，
`iterator$esS ~methも持つ：
◎
In the ECMAScript language binding, the interface prototype object for the SessionManager interface has a values method that is a function, which, when invoked, returns an iterator object that itself has a next method that returns the next value to be iterated over. It has values and entries methods that iterate over the indexes of the list of session objects and [index, session object] pairs, respectively. It also has a @@iterator method that allows a SessionManager to be used in a for..of loop:
</p>

<pre class="es-code">
// <span class="comment"
	title="Get an instance of SessionManager.
Assume that it has sessions for two users, &quot;anna&quot; and &quot;brian&quot;."
>`SessionManager^T の~instanceを取得する。
２人の利用者 `anna^l と `brian^l に対する session があるとする。</span>
var sm = getSessionManager();

typeof SessionManager.prototype.values;
                         // <!--cp-eval-function-->
var it = sm.values();    // <span class="comment"
	title="values() returns an iterator object"
>`values()^c は反復子~objを返す</span>
String(it);              // <span class="comment"
	title="Evaluates to &quot;[object SessionManager Iterator]&quot;"
>`[object SessionManager Iterator]^l に評価される</span>
typeof it.next;          // <!--cp-eval-function-->

// <span class="comment"
	title="This loop will alert &quot;anna&quot; and then &quot;brian&quot;."
>この~loopは `anna^l を alert した後 `brian^l を alert することになる。</span>
for (;;) {
  let result = it.next();
  if (result.done) {
    break;
  }
  let session = result.value;
  window.alert(session.username);
}

// <span class="comment"
	title="This loop will also alert &quot;anna&quot; and then &quot;brian&quot;."
>この~loopも `anna^l を alert した後 `brian^l を alert することになる。</span>
for (let session of sm) {
  window.alert(session.username);
}
</pre>

</div>


<p>
`可反復~宣言$を伴う~ifcの［
`広義~帰結~ifc$ ／ `被継承~ifc$
］に，［
別の`可反復~宣言$, `~maplike 宣言$, `~setlike 宣言$
］が宣言されては~MUST_NOT。
◎
An interface must not have more than one iterable declaration. The inherited and consequential interfaces of an interface with an iterable declaration must not also have an iterable declaration. An interface with an iterable declaration and its inherited and consequential interfaces must not have a maplike declaration or setlike declaration.
</p>

<p>
`可反復~宣言$には、次の拡張属性を適用し得る：
`Exposed$x,
`SecureContext$x
。
◎
The following extended attributes are applicable to iterable declarations: [Exposed], [SecureContext].

</p>

<div class="grammar">
Iterable
OptionalType
</div>


			</section>
			<section id="idl-maplike" class="L2">
<h4 title="Maplike declarations">2.2.8. ~maplike 宣言</h4>

<p>
~ifcは
`~maplike@
になるように宣言できる。
そのためには、`~ifc$の本体にて
`~maplike 宣言@
（
`ReadWriteMaplike$g ／
`readonly^sym `MaplikeRest$g
いずれかに合致）を利用する。
◎
An interface can be declared to be maplike by using a maplike declaration (matching ReadWriteMaplike or readonly MaplikeRest) in the body of the interface.
</p>


<pre class="syntax">
interface `interface_identifier^i {
  readonly maplike&lt;`key_type^i, `value_type^i&gt;;
  maplike&lt;`key_type^i, `value_type^i&gt;;
};
</pre>


<p>
~maplikeになるように宣言された~ifcを実装する~objは、その一連の［
`~map~entry@
と呼ばれる~key-value
］からなる，有順序~listを表現する。
~keyおよび~valueに利用される型は、~maplike 宣言の山括弧の中で与えられる。
それらの~keyは一意になることが要求される。
◎
Objects implementing an interface that is declared to be maplike represent an ordered list of key–value pairs known as its map entries. The types used for the keys and values are given in the angle brackets of the maplike declaration. Keys are required to be unique.
</p>

<p>
`~maplike$ ~ifcを実装している~objの`~map~entry$の~listは、~objの作成~時には空である。
~ifcに付随している注釈文は、~objの一連の`~map~entry$がどのように変化するかを述べ得る。
◎
The map entries of an object implementing a maplike interface is empty at the of the object’s creation. Prose accompanying the interface can describe how the map entries of an object change.
</p>

<p>
~maplike~ifcは、一連の~map~entryを照会するための，言語束縛に適切な~APIを~supportする。
`readonly^c ~keywordが利用されなかった場合†、~map~entryを改変するための~APIも~supportする。
<span class="trans-note">【† 以下， “可書~maplike” とも記される】</span>
◎
Maplike interfaces support an API for querying the map entries appropriate for the language binding. If the readonly keyword is not used, then it also supports an API for modifying the map entries.
</p>

<p class="note">注記：
~JS言語束縛においては、一連の~map~entryとやりとりするための~APIは，
~JSにて可用な `Map^t ~objに類似する。
`readonly^c ~keywordが利用された場合、それは［
`entries^l, `forEach^l, `get^l, `has^l, `keys^l, `values^l, `iterator$esS
］~meth, および `size^l 取得子を含む。
可書~maplikeに対しては、更に［
`clear^l, `delete^l, `set^l
］~methも含む。
◎
Note: In the ECMAScript language binding, the API for interacting with the map entries is similar to that available on ECMAScript Map objects. If the readonly keyword is used, this includes “entries”, “forEach”, “get”, “has”, “keys”, “values”, @@iterator methods and a “size” getter. For read–write maplikes, it also includes “clear”, “delete” and “set” methods.
</p>

<p>
~maplike~ifcの［
`広義~帰結~ifc$, `被継承~ifc$
］は、名前が［
`entries^l／`forEach^l／`get^l／`has^l／`keys^l／`size^l／`values^l
］であるような `~ifc~mb$を持っては~MUST_NOT。
可書~maplike~ifcの［
`広義~帰結~ifc$, `被継承~ifc$
］は、名前が［
`clear^l／`delete^l／`set^l
］であるような `属性$や`定数$も持っては~MUST_NOT。
◎
Maplike interfaces must not have any interface members named “entries”, “forEach”, “get”, “has”, “keys”, “size”, or “values”, or have any inherited or consequential interfaces that have interface members with these names. Read–write maplike interfaces must not have any attributes or constants named “clear”, “delete”, or “set”, or have any inherited or consequential interfaces that have attributes or constants with these names.
</p>

<p class="note">注記：
名前［
`clear^l／`delete^l／`set^l
］の演算は，可書~maplike~ifc上にも許容され、その場合，~JS言語束縛においては，その~methの既定の実装は `~ifc原型~obj$に追加されなくなる。
これにより、これらの演算の既定の挙動を上書きできるようになる。
◎
Note: Operations named “clear”, “delete”, or “set” are allowed on read–write maplike interfaces and will prevent the default implementation of these methods being added to the interface prototype object in the ECMAScript language binding. This allows the default behavior of these operations to be overridden.
</p>

<p>
~maplike~ifcの［
`広義~帰結~ifc$ ／ `被継承~ifc$
］に，［
`可反復~宣言$, 別の`~maplike 宣言$, `~setlike 宣言$
］が宣言されては~MUST_NOT。
◎
An interface must not have more than one maplike declaration. The inherited and consequential interfaces of a maplike interface must not also have a maplike declaration. A maplike interface and its inherited and consequential interfaces must not have an iterable declaration or setlike declaration.
</p>

<div class="grammar">
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteMaplike
MaplikeRest
</div>

<p>
`~maplike 宣言$に適用し得る`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to maplike declarations.
</p>

<p class="issue">
例を追加する。
◎
Add example.
</p>


			</section>
			<section id="idl-setlike" class="L2">
<h4 title="Setlike declarations">2.2.9. ~setlike 宣言</h4>

<p>
~ifcは
`~setlike@
になるように宣言できる。
そのためには、`~ifc$の本体にて
`~setlike 宣言@
（
`ReadWriteSetlike$g ／
`readonly^sym `SetlikeRest$g
いずれかに合致）を利用する。
◎
An interface can be declared to be setlike by using a setlike declaration (matching ReadWriteSetlike or readonly SetlikeRest) in the body of the interface.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  readonly setlike&lt;`type^i&gt;;
  setlike&lt;`type^i&gt;;
};
</pre>

<p>
~setlikeになるように宣言された~ifcを実装する~objは、その一連の［
`~set~entry@
と呼ばれる~value
］からなる，有順序~listを表現する。
~valueに利用される型は、~setlike 宣言の山括弧の中で与えられる。
それらの~valueは一意になることが要求される。
◎
Objects implementing an interface that is declared to be setlike represent an ordered list of values known as its set entries. The type of the values is given in the angle brackets of the setlike declaration. Values are required to be unique.
</p>

<p>
`~setlike$ ~ifcを実装している~objの`~set~entry$の~listは、~objの作成~時には空である。
~ifcに付随している注釈文は、~objの一連の`~set~entry$がどのように変化するかを述べ得る。
◎
The set entries of an object implementing a setlike interface is empty at the of the object’s creation. Prose accompanying the interface can describe how the set entries of an object change.
</p>

<p>
~setlike~ifcは、一連の~set~entryを照会するための，言語束縛に適切な~APIを~supportする。
`readonly^c ~keywordが利用されなかった場合†、~set~entryを改変するための API も~supportする。
<span class="trans-note">【† 以下， “可書~setlike” とも記される】</span>
◎
Setlike interfaces support an API for querying the set entries appropriate for the language binding. If the readonly keyword is not used, then it also supports an API for modifying the set entries.
</p>

<p class="note">注記：
~JS言語束縛においては、一連の~set~entryとやりとりするための~APIは，
~JSにて可用な `Set^t ~objに類似する。
`readonly^c ~keywordが利用された場合、それは［
`entries^l, `forEach^l, `has^l, `keys^l, `values^l, `iterator$esS
］~meth, および `size^l 取得子を含む。
可書~setlikeに対しては、更に［
`add^l, `clear^l, `delete^l
］~methも含む。
◎
Note: In the ECMAScript language binding, the API for interacting with the set entries is similar to that available on ECMAScript Set objects. If the readonly keyword is used, this includes “entries”, “forEach”, “has”, “keys”, “values”, @@iterator methods and a “size” getter. For read–write setlikes, it also includes “add”, “clear”, and “delete” methods.
</p>

<p>
~setlike~ifcの［
`広義~帰結~ifc$, `被継承~ifc$
］は、名前が［
`entries^l／`forEach^l／`has^l／`keys^l／`size^l／`values^l
］であるような `~ifc~mb$を持っては~MUST_NOT。
可書~setlike~ifcの［
`広義~帰結~ifc$, `被継承~ifc$
］は、名前が［
`add^l／`clear^l／`delete^l
］であるような `属性$や`定数$も持っては~MUST_NOT。
◎
Setlike interfaces must not have any interface members named “entries”, “forEach”, “has”, “keys”, “size”, or “values”, or have any inherited or consequential interfaces that have interface members with these names.. Read–write setlike interfaces must not have any attributes or constants named “add”, “clear”, or “delete”, or have any inherited or consequential interfaces that have attributes or constants with these names.
</p>

<p class="note">注記：
名前［
`add^l／`clear^l／`delete^l
］の演算は，可書~setlike~ifc上にも許容され、その場合，~JS言語束縛においては，その~methの既定の実装は `~ifc原型~obj$に追加されなくなる。
これにより、これらの演算の既定の挙動を上書きできるようになる。
◎
Note: Operations named “add”, “clear”, or “delete” are allowed on read–write setlike interfaces and will prevent the default implementation of these methods being added to the interface prototype object in the ECMAScript language binding. This allows the default behavior of these operations to be overridden.
</p>

<p>
~setlike~ifcの［
`広義~帰結~ifc$ ／ `被継承~ifc$
］に，［
`可反復~宣言$, `~maplike 宣言$, 別の`~setlike 宣言$
］が宣言されては~MUST_NOT。
◎
An interface must not have more than one setlike declaration. The inherited and consequential interfaces of a setlike interface must not also have a setlike declaration. A setlike interface and its inherited and consequential interfaces must not have an iterable declaration or maplike declaration.
</p>

<div class="grammar">
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteSetlike
SetlikeRest
</div>

<p>
`~setlike 宣言$に適用し得る`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to setlike declarations.
</p>

<p class="issue">
例を追加する。
◎
Add example.
</p>


			</section>
		</section>
		<section id="idl-namespaces" class="L2">
<h3 title="Namespaces">2.3. 名前空間</h3>

<p>
`名前空間@
（ namespace ）は、いくつかの挙動が結付けられた 大域~singletonを宣言する定義（ `Namespace$g に合致）である。
◎
A namespace is a definition (matching Namespace) that declares a global singleton with associated behaviors.
</p>

<p class="trans-note">【
すなわち、~instanceは 1 個しか存在し得ない（かつ，その 1 個は常に存在する）ような~ifcのようなものと捉えればよいであろう。
】</p>


<pre class="syntax">
namespace `identifier^i {
  /* namespace_members... */
};
</pre>

<p>
名前空間は、
`名前空間~mb@
— 名前空間~宣言~内の波括弧の合間に現れる`正則~演算$ —
の集合（ `NamespaceMembers$g に合致）の仕様である。
これらの演算は、名前空間の中に梱包された挙動を述べる。
◎
A namespace is a specification of a set of namespace members (matching NamespaceMembers), which are the regular operations that appear between the braces in the namespace declaration. These operations describe the behaviors packaged into the namespace.
</p>



<p>
~ifcと同様、名前空間に対する~IDLは、
`部分的~名前空間~定義@
（ `partial^sym `Namespace$g に合致）を利用して，複数の部分に分割できる。
部分的~名前空間~定義の`識別子$は、その名前空間~定義の識別子と同じで~MUST。
それぞれの部分的~名前空間に現れる，すべての~mbは、その名前空間~自身の~mbであるものと見なされる。
◎
As with interfaces, the IDL for namespaces can be split into multiple parts by using partial namespace definitions (matching partial Namespace). The identifier of a partial namespace definition must be the same as the identifier of a namespace definition. All of the members that appear on each of the partial namespace definitions are considered to be members of the namespace itself.
</p>



<pre class="syntax">
namespace `SomeNamespace^mk {
  /* namespace_members... */
};

partial namespace `SomeNamespace^mk {
  /* namespace_members... */
};
</pre>

<p class="note">注記：
部分的~ifc定義と同様に、部分的~名前空間~定義の目的は、名前空間の定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補助する所にある。
◎
Note: As with partial interface definitions, partial namespace definitions are intended for use as a specification editorial aide, allowing the definition of a namespace to be separated over more than one section of the document, and sometimes multiple documents.
</p>


<p><!-- copy* -->
~mbが現れる順序は、
<a href="#es-namespaces">~JS言語束縛</a>
における~prop列挙においては，有意になる。
◎
The order that members appear in has significance for property enumeration in the ECMAScript binding.
</p>

<p>
~ifcや辞書と違って、名前空間は型を作成しないことに注意。
◎
Note that unlike interfaces or dictionaries, namespaces do not create types.
</p>

<p>
この仕様に定義される拡張属性のうち，名前空間に適用し得るのは
`Exposed$x, `SecureContext$x
に限られる。
◎
Of the extended attributes defined in this specification, only the [Exposed] and [SecureContext] extended attributes are applicable to namespaces.
</p>

<div class="grammar">
Partial
PartialDefinition
Namespace
NamespaceMembers
NamespaceMember
</div>

<div class="example">

<p>
次の`~IDL片$は、`名前空間$を定義する：
◎
The following IDL fragment defines an namespace.
</p>

<pre class="idl-code">namespace VectorUtils {
  double dotProduct(Vector x, Vector y);
  Vector crossProduct(Vector x, Vector y);
};
</pre>

<p>
~JS実装は、（原型 `ObjectPrototype$esI を伴う）単純~objであった名前 `VectorUtils^c の大域~propを，宣言された各~演算に対する列挙可能な~data~propたちで公開することになる：
◎
An ECMAScript implementation would then expose a global property named VectorUtils which was a simple object (with prototype %ObjectPrototype%) with enumerable data properties for each declared operation:
</p>



<pre class="es-code">
Object.getPrototypeOf(VectorUtils);  // <span class="comment"
	title="Evaluates to Object.prototype."
>`Object.prototype^c に評価される。</span>
Object.keys(VectorUtils);            // <span class="comment"
	title="Evaluates to [&quot;dotProduct&quot;, &quot;crossProduct&quot;]."
><samp>[`dotProduct^l, `crossProduct^l]</samp> に評価される。</span>
Object.getOwnPropertyDescriptor(VectorUtils, "dotProduct");
/* <span class="comment"
	title="Evaluates to { value: &lt;a function&gt;, enumerable: true, configurable: true, writable: true }."
><samp>{ value: &lt;ある関数&gt;, enumerable: true,
    configurable: true, writable: true }</samp>
   に評価される。</span> */
</pre>
</div>

		</section>
		<section id="idl-dictionaries">
<h3 title="Dictionaries">2.4. 辞書</h3>


<p>
`辞書@
（ dictionary ）は、［
有順序かつ固定的な 一連の~keyを有する，~key-valueの連想配列~data型
］を定義するために利用される，`定義$（ `Dictionary$g に合致）である。
各~pairを
`辞書~mb@
と呼ぶ。
その~keyは文字列であり，その値は定義の中で指定される個々の型に属する。
◎
A dictionary is a definition (matching Dictionary) used to define an associative array data type with a fixed, ordered set of key–value pairs, termed dictionary members, where keys are strings and values are of a particular type specified in the definition.
</p>

<pre class="syntax">
dictionary `identifier^i {
  /* dictionary_members... */
};
</pre>

<p>
辞書は常に値渡しである。
辞書が何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に辞書が渡された際に，その辞書への参照が~objに保有されることはない。
同様に，~platform~objから返されるどの辞書も複製であり、それに対する改変は~platform~objからは可視でないことになる。
◎
Dictionaries are always passed by value. In language bindings where a dictionary is represented by an object of some kind, passing a dictionary to a platform object will not result in a reference to the dictionary being kept by that object. Similarly, any dictionary returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>
<p>
辞書は 別の辞書を
<dfn id="dfn-inherit-dictionary">継承-</dfn>
するように定義し得る。
辞書の識別子に~colonと`識別子$が後続するとき、後者の識別子が，継承される辞書を識別する。
この識別子は辞書を識別するもので~MUST。
◎
A dictionary can be defined to inherit from another dictionary. If the identifier of the dictionary is followed by a colon and a identifier, then that identifier identifies the inherited dictionary. The identifier must identify a dictionary.
</p>

<p>
辞書は、その継承階層が循環するように宣言されては~MUST_NOT。
すなわち、辞書 %A は自身を継承することも,
%A を継承する別の辞書 %B を継承することもできない，等々。
◎
A dictionary must not be declared such that its inheritance hierarchy has a cycle. That is, a dictionary A cannot inherit from itself, nor can it inherit from another dictionary B that inherits from A, and so on.
</p>

<pre class="syntax">
dictionary `Base^mk {
  /* dictionary_members... */
};

dictionary `Derived^i : `Base^mk {
  /* dictionary_members... */
};
</pre>

<p>
所与の辞書~型 %D の
`被継承~辞書@
とは、
%D が直接的にまたは間接的に継承するすべての辞書の集合である。
%D が他の辞書を`辞書継承^しない場合、その集合は空である。
そうでない場合、その集合は %D が`辞書継承^する~ifc %E と %E の`被継承~辞書$すべてを含む。
◎
The inherited dictionaries of a given dictionary D is the set of all dictionaries that D inherits from, directly or indirectly. If D does not inherit from another dictionary, then the set is empty. Otherwise, the set includes the dictionary E that D inherits from and all of E’s inherited dictionaries.
</p>

<p>
型 %D の辞書~値 %d は、
%D 上および %D の`被継承~辞書$上で定義される辞書~mbに対応する~key-valueを持ち得る。
%d 上における，各~辞書~mbの存在tは、それが %D において`必須~辞書~mb$であると指定されていない限り，随意である。
%d 上に指定されているならば，その辞書~mbは
`在する@
（ present ）といい、そうでない場合は
<dfn>`不在$</dfn>
という。
辞書~mbは，随意で
<dfn id="dfn-dictionary-member-default-value">既定~値</dfn>
も持ち得る。
それは、 %d 上にその~mb値が指定されずに %d が`~platform~obj$に渡された際に，辞書~mbに利用される値になる。
既定~値を伴う辞書~mbは常に在するものと見なされる。
◎
A dictionary value of type D can have key–value pairs corresponding to the dictionary members defined on D and on any of D’s inherited dictionaries. On a given dictionary value, the presence of each dictionary member is optional, unless that member is specified as required. When specified in the dictionary value, a dictionary member is said to be present, otherwise it is not present. Dictionary members can also optionally have a default value, which is the value to use for the dictionary member when passing a value to a platform object that does not have a specified value. Dictionary members with default values are always considered to be present.
</p>

<p class="advisement">
演算~引数の`既定~値$と同様に、
`boolean$T 型の辞書~mbに対しては、既定~値として `true^V を利用しないことを強く勧める。
さもなければ、 `undefined^v に既定の変換（すなわち， `false^V ）が利用されると期待する作者たちを惑わすことになるので。
◎
As with operation argument default values, is strongly suggested not to use of true as the default value for boolean-typed dictionary members, as this can be confusing for authors who might otherwise expect the default conversion of undefined to be used (i.e., false).
</p>


<p>
各`辞書~mb$（ `DictionaryMember$g に合致）は、型（ `Type$g に合致）および, 後続の（ `identifier$g ~tokで与えられる）`識別子$により指定され、その識別子が~key-valueの~key名になる。
`Type$g が `?^c 付きの`識別子$である場合、その識別子は［
~ifc, `列挙$, `呼戻~関数$, `~typedef$
］のいずれかに識別され~MUST。
辞書~mb型が `?^c 付きでない識別子である場合、その識別子は，それらの定義, または`辞書$に識別され~MUST。
◎
Each dictionary member (matching DictionaryMember) is specified as a type (matching Type) followed by an identifier (given by an identifier token following the type). The identifier is the key name of the key–value pair. If the Type is an identifier followed by ?, then the identifier must identify an interface, enumeration, callback function or typedef. If the dictionary member type is an identifier not followed by ?, then the identifier must identify any one of those definitions or a dictionary.
</p>

<pre class="syntax">
dictionary `identifier^i {
  `type^i `identifier^i;
};
</pre>

<p>
識別子に
`U+003D EQUALS SIGN ("=")^char
と値（ `DefaultValue$g に合致）が後続している場合、それが辞書~mbの
`辞書既定値^
を与える。
◎
If the identifier is followed by a U+003D EQUALS SIGN ("=") and a value (matching DefaultValue), then that gives the dictionary member its default value.
</p>

<pre class="syntax">
dictionary `identifier^i {
  `type^i `identifier^i = "value";
};
</pre>

<p>
`辞書既定値^に［
`定数~tok$ ／ `string$g ~tok ／ 2 個の~tok並び `[]^c
］が利用された場合、
`演算$の引数の`既定~値$
のときと同じ仕方で解釈される。
◎
When a boolean literal token (true or false), the null token, an integer token, a float token, one of the three special floating point literal values (Infinity, -Infinity or NaN), a string token or the two token sequence [] used as the default value, it is interpreted in the same way as for an operation’s optional argument default value.
</p>

<p>
`辞書~mb$の型が`列挙$である場合、その`辞書既定値^に指定される値は，その`列挙~値$のいずれかで~MUST。
◎
If the type of the dictionary member is an enumeration, then its default value if specified must be one of the enumeration’s values.
</p>


<p>
辞書~mbの型の前に ~keyword `required^c が置かれた場合、その~mbは
`必須~辞書~mb@
と見なされ，辞書~上に`在する$ことが要求される。
`必須~辞書~mb$は、`既定~値$を持っては~MUST_NOT。
◎
If the type of the dictionary member is preceded by the required keyword, the member is considered a required dictionary member and must be present on the dictionary. A required dictionary member must not have a default value.
</p>

<pre class="syntax">
dictionary `identifier^i {
  required `type^i `identifier^i;
};
</pre>

<p>
辞書~mbの型は，その辞書を <em>内包</em> しては~MUST_NOT。
次のいずれかを満たす型 %T は、辞書~型 %D を内包するものとされる：
◎
The type of a dictionary member must not include the dictionary it appears on. A type includes a dictionary D if at least one of the following is true:
</p>

<ul>
	<li>
%T は %D である
◎
the type is D
</li>
	<li>
%T は %D を`辞書継承^している辞書である
◎
the type is a dictionary that inherits from D
</li>
	<li>
%T は`~nullable型$であり，その`内縁~型$は %D を内包している
◎
the type is a nullable type whose inner type includes D
</li>
	<li>
%T は［
`連列~型$, または`凍結~配列~型$
］であり，その要素~型は %D を内包している
◎
the type is a sequence type or frozen array whose element type includes D
</li>
	<li>
%T は`共用体~型$であり，そのいずれかの`~mb型$は %D を内包している
◎
the type is a union type, one of whose member types includes D
</li>
	<li>
%T は辞書であり，そのいずれかの［
自前の, または 継承している
］~mbの型は %D を内包している
◎
the type is a dictionary, one of whose members or inherited members has a type that includes D
</li>
</ul>


<p>
~ifcと同様に、辞書のための~IDLは
`部分的~辞書~定義@
（ `partial^sym `Dictionary$g に合致）を利用して複数の部分に分割できる。
部分的~辞書~定義の`識別子$は、当の辞書~定義の識別子と同じで~MUST。
それぞれの部分的~辞書~定義に現れるすべての~mbは、辞書~自身の~mbと見なされる。
◎
As with interfaces, the IDL for dictionaries can be split into multiple parts by using partial dictionary definitions (matching partial Dictionary). The identifier of a partial dictionary definition must be the same as the identifier of a dictionary definition. All of the members that appear on each of the partial dictionary definitions are considered to be members of the dictionary itself.
</p>

<pre class="syntax">
dictionary `SomeDictionary^mk {
  /* dictionary_members... */
};

partial dictionary `SomeDictionary^mk {
  /* dictionary_members... */
};
</pre>

<p class="note">注記：
部分的~ifc定義と同様に、部分的~辞書~定義の目的は、辞書の定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補助する所にある。
◎
Note: As with partial interface definitions, partial dictionary definitions are intended for use as a specification editorial aide, allowing the definition of an interface to be separated over more than one section of the document, and sometimes multiple documents.
</p>

<p id="_order-of-dict-members_">
所与の辞書~上の`辞書~mb$は、継承された辞書~mbが 非継承~mbより前に位置するように順序付けられる。
１つの辞書~定義~上の（部分的~辞書~定義もすべて含めた）すべての辞書~mbは、それらの識別子を構成する Unicode 符号位置により，辞書式に順序付けられる。
◎
The order of the dictionary members on a given dictionary is such that inherited dictionary members are ordered before non-inherited members, and the dictionary members on the one dictionary definition (including any partial dictionary definitions) are ordered lexicographically by the Unicode codepoints that comprise their identifiers.
</p>

<div class="note">
<p>
例えば，次の定義では：
◎
For example, with the following definitions:
</p>

<pre class="idl-code">
dictionary B : A {
  long b;
  long a;
};

dictionary A {
  long c;
  long g;
};

dictionary C : B {
  long e;
  long f;
};

partial dictionary A {
  long h;
  long d;
};
</pre>

<p>
型 `C^T の辞書~値の `辞書~mb$の順序は［
`c^M, `d^M, `g^M, `h^M, `a^M, `b^M, `e^M, `f^M
］になる。
◎
the order of the dictionary members of a dictionary value of type C is c, d, g, h, a, b, e, f.
</p>

<p>
辞書の~mbは順序付けられることが要求される。
一部の言語束縛においては、~platform~objに辞書~値を渡した際に観測される挙動が，辞書~mbを取りに行く順序に依存するので。
例えば，次の追加の~ifc：
◎
Dictionaries are required to have their members ordered because in some language bindings the behavior observed when passing a dictionary value to a platform object depends on the order the dictionary members are fetched. For example, consider the following additional interface:
</p>

<pre class="idl-code">
interface Something {
  void f(A a);
};
</pre>

<p>
および，次の~JS~codeを考えるとき：
◎
and this ECMAScript code:
</p>

<pre class="es-code">
var something = getSomething();  // <span class="comment"
	title="Get an instance of Something."
>`Something^T の~instanceを取得する。</span>
var x = 0;

var dict = { };
Object.defineProperty(dict, "d", { get: function() { return ++x; } });
Object.defineProperty(dict, "c", { get: function() { return ++x; } });

something.f(dict);
</pre>

<p>
辞書~mbを取りに行く順序が、それらがとることになる値を決定する。
`A^T における順序は， `c^M の次が `d^M と定義されるので、
`c^M に対する値は 1 になり, `d^M に対する値は 2 になる。
◎
The order that the dictionary members are fetched in determines what values they will be taken to have. Since the order for A is defined to be c then d, the value for c will be 1 and the value for d will be 2.
</p>
</div>

<p>
辞書~mbの識別子は、その辞書~上, またはその辞書の`被継承~辞書$上で定義される，別の辞書~mbの識別子と同じになっては~MUST_NOT。
◎
The identifier of a dictionary member must not be the same as that of another dictionary member defined on the dictionary or on that dictionary’s inherited dictionaries.
</p>

<p>
辞書は［
`属性$／`定数$
］の型に利用されては~MUST_NOT。
◎
Dictionaries must not be used as the type of an attribute or constant.
</p>

<p>
`辞書$には、次の拡張属性を適用し得る：
`Constructor$x, `Exposed$x, `SecureContext$x
。
◎
The following extended attributes are applicable to dictionaries: [Constructor], [Exposed], [SecureContext],
</p>

<p>
辞書~mbには、次の拡張属性を適用し得る：
`Clamp$x, `EnforceRange$x
。
◎
The following extended attributes are applicable to dictionary members: [Clamp], [EnforceRange].
</p>

<div class="grammar">
--Partial
--PartialDefinition
-Dictionary
-DictionaryMembers
-DictionaryMember
-Required
-PartialDictionary
-Default
--DefaultValue
--Inheritance
</div>

<div class="example">
<p>
辞書~型の利用の１つは、`演算$に対し、
呼出し~codeの所で指定される順序に制約を課すことなく，随意~引数をいくつでも与えられるようにすることである。
例えば，次の`~IDL片$を考える：
◎
One use of dictionary types is to allow a number of optional arguments to an operation without being constrained as to the order they are specified at the call site. For example, consider the following IDL fragment:
</p>

<pre class="idl-code">
[Constructor]
interface Point {
  attribute double x;
  attribute double y;
};

dictionary PaintOptions {
  DOMString? fillPattern = "black";
  DOMString? strokePattern = null;
  Point position;
};

interface GraphicsContext {
  void drawRectangle(
    double width, double height,
    optional PaintOptions options
  );
};
</pre>

<p>
この~IDLの~JS実装においては、随意の
`PaintOptions^T 辞書
により， `Object^t を渡すことができる：
◎
In an ECMAScript implementation of the IDL, an Object can be passed in for the optional PaintOptions dictionary:
</p>

<pre class="es-code">
// <span class="comment"
	title="Get an instance of GraphicsContext."
>`GraphicsContext^T の~instanceを取得する。</span>
var ctx = getGraphicsContext();

// <span class="comment"
	title="Draw a rectangle."
>矩形を描く。</span>
ctx.drawRectangle(
    300, 200,
    { fillPattern: "red", position: new Point(10, 10) }
);
</pre>

<p>
`fillPattern^M と `strokePattern^M のいずれにも`辞書既定値^が与えられているので、 `drawRectangle^M の定義においては，それらが省略された場合でも所与の既定~値を持つと見做すことができ、それらが`不在$の場合に取扱う方法についての明示的な言及が不要になる。
◎
Both fillPattern and strokePattern are given default values, so if they are omitted, the definition of drawRectangle can assume that they have the given default values and not include explicit wording to handle their non-presence.
</p>
</div>
		</section>
		<section id="idl-exceptions">
<h3 title="Exceptions">2.5. 例外</h3>

<div >
<p>
`例外@
とは、~errorを表現する~objの型であり，実装により［
投出される, または first ~class値として扱われる
］ものである。
~Web~IDLでは，例外を定義することは許容されないが、代わりに
仕様が参照し，その演算, 属性, 等々の定義にて投出できるような，いくつもの定義済みの例外がある。
例外は、次のものを持つ：
</p>

<dl>
	<dt>`~error名@</dt>
	<dd>
`DOMString$T による，例外が表現する~errorの型
</dd>

	<dt>`~message@（随意）</dt>
	<dd>
~errorの詳細を人が読める~~形で提供する，~UAにより定義される値
</dd>

</dl>
◎
An exception is a type of object that represents an error and which can be thrown or treated as a first class value by implementations. Web IDL does not allow exceptions to be defined, but instead has a number of pre-defined exceptions that specifications can reference and throw in their definition of operations, attributes, and so on. Exceptions have an error name, a DOMString, which is the type of error the exception represents, and a message, which is an optional, user agent-defined value that provides human readable details of the error.
</div>


<p>
仕様にて投出するために可用な例外には２つの種類がある。
まず、次のいずれかの名前として識別される
`単純例外@
：
◎
There are two kinds of exceptions available to be thrown from specifications. The first is a simple exception, which is identified by one of the following names:
</p>


<ul>
	<li>`Error@eE</li>
	<li>`EvalError@eE</li>
	<li>`RangeError@eE</li>
	<li>`ReferenceError@eE</li>
	<li>`TypeError@eE</li>
	<li>`URIError@eE</li>
</ul>

<p>
これらは、
<a href="~TC39#sec-error-objects">~JS~error~obj</a>に対応する（ `SyntaxError^t は除く — それは~JS構文解析器でのみ利用されるので，~~意図的に除かれている）。
各 `単純例外$の意味は、~JS仕様における対応する `Error^t ~objに合致する。
◎
These correspond to all of the ECMAScript error objects (apart from SyntaxError, which is deliberately omitted as it is for use only by the ECMAScript parser). The meaning of each simple exception matches its corresponding Error object in the ECMAScript specification.
</p>


<p>
もう一種の例外は
`~DOMException@
である
— それは，歴史的に DOM にて定義された例外との互換性をとるための例外であり、名前と整数~code（後者は随意）を，~encapsulateする。
◎
The second kind of exception is a DOMException, which is an exception that encapsulates a name and an optional integer code, for compatibility with historically defined exceptions in the DOM.
</p>

<p>
`単純例外$に対しては、その例外の名前が，そのまま`~error名$になる。
`~DOMException$に対しては、`~error名$は，後に示す`~error名~一覧$に挙げられている いずれかの名前で~MUST。
その一覧には、その~error名に対する`~DOMException$の整数~codeも（もし在れば）指示される。
◎
For simple exceptions, the error name is the name of the exception. For a DOMException, the error name must be one of the names listed in the error names table below. The table also indicates the DOMException's integer code for that error name, if it has one.
</p>

<p>
例外~objを指すために利用し得る，２種の型がある：
すべての例外が含まれる `Error$T, および
~DOMException~objのみを含む `DOMException$T 。
これにより、`演算$の`返値型$を`~DOMException$に宣言したり，`属性$の型を `Error$T 型にすることも可能になる。
◎
There are two types that can be used to refer to exception objects: Error, which encompasses all exceptions, and DOMException which includes just DOMException objects. This allows for example an operation to be declared to have a DOMException return type or an attribute to be of type Error.
</p>

<p>
例外は、その`~error名$を提供して
`作成する@
こともできる。
例外は、それを`作成する$ために要求される詳細を提供して
`投出する@
こともできる。
◎
Exceptions can be created by providing its error name. Exceptions can also be thrown, by providing the same details required to create one.
</p>

<p>
例外を作成したり, 作成した例外を投出した結果の挙動は、言語束縛~特有になる。
◎
The resulting behavior from creating and throwing an exception is language binding-specific.
</p>

<p class="note">注記：
~JS言語束縛の場合にどうなるかについては、
`es-creating-throwing-exceptions$secに。
◎
Note: See §3.14 Creating and throwing exceptions for details on what creating and throwing an exception entails in the ECMAScript language binding.
</p>

<div class="example">
<p>
例外を作成して投出する言い回しの用例をここに示す。
名前 `TypeError^T の新たな `単純例外$を投出するときは†：
◎
Here is are some examples of wording to use to create and throw exceptions. To throw a new simple exception named TypeError:
</p>

<blockquote>
`TypeError^t を`投出$。
◎
Throw a TypeError.
</blockquote>

<p>
`~error名$ `IndexSizeError^T の新たな`~DOMException$を投出するときは†：
◎
To throw a new DOMException with error name IndexSizeError:
</p>

<blockquote>
`IndexSizeError^t を`投出$。
◎
Throw an IndexSizeError.
</blockquote>

<p class="trans-note">【†
この訳では、~algoの中では，記号 ~THROW を利用して記される。
】</p>

<p>
`~error名$ `SyntaxError^T の新たな `~DOMException$を作成するときは：
◎
To create a new DOMException with error name SyntaxError:
</p>

<blockquote>
%object := 新たに`作成-$された `SyntaxError^t
◎
Let object be a newly created SyntaxError.
</blockquote>

</div>


			<section id="idl-DOMException-error-names">
<h4 title="Error names">2.5.1. ~error名</h4>

<p>
下の
`~error名~一覧@
は、`~DOMException$に許容されるすべての~error名, 説明, および 旧来の code 名とその値の一覧である。
◎
The error names table below lists all the allowed error names for DOMExceptions, a description, and legacy code values.
</p>

<p class="note">注記：
ここに挙げられていない~error名があれば、この仕様の冒頭に指示したように, ~bugを申請されるよう願う。
間もなく解消に向けて取り組まれることになる。
Thanks! 
◎
Note: If an error name is not listed here, please file a bug as indicated at the top of this specification and it will be addressed shortly. Thanks!
</p>

<div style="overflow:auto;"><table id="error-names">
<thead><tr><th>名前◎Name
</th><th style="min-width:12em;">説明◎Description
</th><th>
旧来の code 名（数値）
◎
Legacy code name and value
</th></tr></thead>

<tbody><tr><td>`IndexSizeError@E
</td><td><p>
index は許容されている範囲に入っていない。
◎
The index is not in the allowed range.
</p></td><td>`INDEX_SIZE_ERR^c (1)

</td></tr><tr><td>`HierarchyRequestError@E
</td><td><p>
演算から不正な~node木が得られることになる。
◎
The operation would yield an incorrect node tree.
</p></td><td>`HIERARCHY_REQUEST_ERR^c (3)

</td></tr><tr><td>`WrongDocumentError@E
</td><td><p>
~objが属している文書は誤っている。
◎
The object is in the wrong document.
</p></td><td>`WRONG_DOCUMENT_ERR^c (4)

</td></tr><tr><td>`InvalidCharacterError@E
</td><td><p>
文字列に妥当でない文字が含まれている。
◎
The string contains invalid characters.
</p></td><td>`INVALID_CHARACTER_ERR^c (5)

</td></tr><tr><td>`NoModificationAllowedError@E
</td><td><p>
~objは改変できない。
◎
The object can not be modified.
</p></td><td>`NO_MODIFICATION_ALLOWED_ERR^c (7)

</td></tr><tr><td>`NotFoundError@E
</td><td><p>
~objは見つからなかった。
◎
The object can not be found here.
</p></td><td>`NOT_FOUND_ERR^c (8)

</td></tr><tr><td>`NotSupportedError@E
</td><td><p>
演算は~supportされていない。
◎
The operation is not supported.
</p></td><td>`NOT_SUPPORTED_ERR^c (9)

</td></tr><tr><td>`InUseAttributeError@E
</td><td><p>
属性は使用中にある。
◎
The attribute is in use.
</p></td><td>`INUSE_ATTRIBUTE_ERR^c (10)

</td></tr><tr><td>`InvalidStateError@E
</td><td><p>
~objは不正な状態にある。
◎
The object is in an invalid state.
</p></td><td>`INVALID_STATE_ERR^c (11)

</td></tr><tr><td>`SyntaxError@E
</td><td><p>
文字列は期待される~patternに合致していない。
◎
The string did not match the expected pattern.
</p></td><td>`SYNTAX_ERR^c (12)

</td></tr><tr><td>`InvalidModificationError@E
</td><td><p>
~objはこの仕方では改変できない。
◎
The object can not be modified in this way.
</p></td><td>`INVALID_MODIFICATION_ERR^c (13)

</td></tr><tr><td>`NamespaceError@E
</td><td><p>
演算は <cite>Namespaces in XML</cite> において許容されない。
`XML-NAMES$r
◎
The operation is not allowed by Namespaces in XML. [XML-NAMES]
</p></td><td>`NAMESPACE_ERR^c (14)

</td></tr><tr><td>`InvalidAccessError@E
</td><td><p>
~objは演算または引数を~supportしない。
◎
The object does not support the operation or argument.
</p></td><td>`INVALID_ACCESS_ERR^c (15)

</td></tr><tr><td>`SecurityError@E
</td><td><p>
演算は保安的でない。
◎
The operation is insecure.
</p></td><td>`SECURITY_ERR^c (18)

</td></tr><tr><td>`NetworkError@E
</td><td><p>
~network~errorが生じた。
◎
A network error occurred.
</p></td><td>`NETWORK_ERR^c (19)

</td></tr><tr><td>`AbortError@E
</td><td><p>
演算は中止された。
◎
The operation was aborted.
</p></td><td>`ABORT_ERR^c (20)

</td></tr><tr><td>`URLMismatchError@E
</td><td><p>
所与の URL は他方の URLに合致していない。
◎
The given URL does not match another URL.
</p></td><td>`URL_MISMATCH_ERR^c (21)
 

</td></tr><tr><td>`QuotaExceededError@E
</td><td><p>
quota の上限を超えた。
◎
The quota has been exceeded.
</p></td><td>`QUOTA_EXCEEDED_ERR^c (22)

</td></tr><tr><td>`TimeoutError@E
</td><td><p>
演算は時間切れになった。
◎
The operation timed out.
</p></td><td>`TIMEOUT_ERR^c (23)

</td></tr><tr><td>`InvalidNodeTypeError@E
</td><td><p>
あてがわれた~nodeは不正か, またはこの演算において不正な先祖を持つ。
◎
The supplied node is incorrect or has an incorrect ancestor for this operation.
</p></td><td>`INVALID_NODE_TYPE_ERR^c (24)

</td></tr><tr><td>`DataCloneError@E
</td><td><p>
~objは~cloneできない。
◎
The object can not be cloned.
</p></td><td>`DATA_CLONE_ERR^c (25)

</td></tr><tr><td>`EncodingError@E
</td><td><p>
符号化~演算（符号化, 復号の両者を含む）に失敗した。
◎
The encoding operation (either encoded or decoding) failed.
</p></td><td>—

</td></tr><tr><td>`NotReadableError@E
</td><td><p>
I/O 読み取り演算に失敗した。
◎
The I/O read operation failed.
</p></td><td>—


</td></tr><tr><td>`UnknownError@E
</td><td><p>
未知の一時的な事由により，演算に失敗した（例：記憶域を使い切った）。
◎
The operation failed for an unknown transient reason (e.g. out of memory).
</p></td><td>—

</td></tr><tr><td>`ConstraintError@E
</td><td><p>
~transactionにおける変異~演算は、拘束を満たせないため，失敗した。
◎
A mutation operation in a transaction failed because a constraint was not satisfied.
</p></td><td>—

</td></tr><tr><td>`DataError@E
</td><td><p>
提供された~dataは、必要十分でない。
◎
Provided data is inadequate.
</p></td><td>—

</td></tr><tr><td>`TransactionInactiveError@E
</td><td><p>
現在~作動中でない／すでに終わった ~transactionに対し，要請が行われた。
◎
A request was placed against a transaction which is currently not active, or which is finished.
</p></td><td>—

</td></tr><tr><td>`ReadOnlyError@E
</td><td><p>
“読み取り専用” （ `readonly^l ~mode）の~transactionにおいて，変異させようとする演算が試みられた。
◎
The mutating operation was attempted in a "readonly" transaction.
</p></td><td>—

</td></tr><tr><td>`VersionError@E
</td><td><p>
既存の~versionより低い~versionを利用して~databaseを open しようとした。
◎
An attempt was made to open a database using a lower version than the existing version.
</p></td><td>—

</td></tr><tr><td>`OperationError@E
</td><td><p>
演算~特有の事由により，演算に失敗した。
◎
The operation failed for an operation-specific reason.
</p></td><td>—

</td></tr><tr><td>`NotAllowedError@E
</td><td><p>
要請された演算は、現在の文脈においては
~UA／~platform
からは
— 場合によっては，利用者が否認したことにより —
許容されない。
◎
The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.
</p></td><td>—

</td></tr></tbody></table></div>

			</section>
		</section>
		<section id="idl-enums">
<h3 title="Enumerations">2.6. 列挙</h3>


<p>
`列挙@
（ enumeration ）は、［
妥当な値の集合が，定義済みの文字列の集合になる
］ような型を宣言するために利用される，`定義$（ `Enum$g に合致）である。
`属性$に代入し得る／`演算$に渡し得る `DOMString$T 値を制約する用途に，列挙を利用できる。
◎
An enumeration is a definition (matching Enum) used to declare a type whose valid values are a set of predefined strings. Enumerations can be used to restrict the possible DOMString values that can be assigned to an attribute or passed to an operation.
</p>

<pre class="syntax">
enum `identifier^i { "enum", "values" /* , ... */ };
</pre>

<p>
一連の
`列挙~値@
は、
`string$g ~literalの~comma区切りの~listとして指定される。
`列挙~値$の~list内に重複があっては~MUST_NOT。
◎
The enumeration values are specified as a comma-separated list of string literals. The list of enumeration values must not include duplicates.
</p>

<p class="advisement">
別の命名法を利用する理由が特にない限り、列挙~値は，すべて小文字にすることを強く勧める
— 複数の単語は，~dashで区切るか全く区切らないことにして。
例えば、~objが作成されるべきであることを指示する列挙~値は，
`createobject^l や `create-object^l
などと命名できる。
列挙~値の単語を~dashで区切るか区切らないか決めるときは、類似の他の~APIと一貫するように，関係する列挙~値の利用を考慮に入れること。
◎
It is strongly suggested that enumeration values be all lowercase, and that multiple words be separated using dashes or not be separated at all, unless there is a specific reason to use another value naming scheme. For example, an enumeration value that indicates an object should be created could be named "createobject" or "create-object". Consider related uses of enumeration values when deciding whether to dash-separate or not separate enumeration value words so that similar APIs are consistent.
</p>

<p>
妥当な列挙~値のいずれでもない文字列~値が、列挙~型の`属性$への代入ingや, 列挙~型の`演算$に渡される引数に利用されたときの挙動は、言語束縛~特有になる。
◎
The behavior when a string value that is not one a valid enumeration value is used when assigning to an attribute, or passed as an operation argument, whose type is the enumeration, is language binding specific.
</p>

<p class="note">注記：
~JS言語束縛においては、`属性$への妥当でない文字列~値の代入は無視される一方，そのような値を`演算$の引数に渡したときには例外が投出される。
◎
Note: In the ECMAScript binding, assignment of an invalid string value to an attribute is ignored, while passing such a value as an operation argument results in an exception being thrown.
</p>

<p>
`列挙$に適用し得る`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to enumerations.
</p>

<div class="grammar">
-Enum
-EnumValueList
-EnumValueListComma
-EnumValueListString
</div>


<div class="example">
<p>
次の`~IDL片$は
１個の`属性$と１個の`演算$引数の型として利用される
`列挙$を定義する
◎
The following IDL fragment defines an enumeration that is used as the type of an attribute and an operation argument:
</p>

<pre class="idl-code">
enum MealType { "米", "麺", "その他" };

interface Meal {
  attribute MealType type;
  attribute double size;     // <span class="comment"
	title="in grams"
>グラム~~単位</span>

  void initialize(MealType type, double size);
};
</pre>

<p>
~JS実装は、 type ~propに代入され得る, あるいは
`initialize^M 関数に渡され得る文字列を，
`列挙$内にて識別されるものに制約することになる。
◎
An ECMAScript implementation would restrict the strings that can be assigned to the type property or passed to the initializeMeal function to those identified in the enumeration.
</p>

<pre class="es-code">
var meal = getMeal();          // <span class="comment"
	title="Get an instance of Meal."
>`Meal^T の~instanceを取得する。</span>

meal.initialize("米", 200);    // <span class="comment"
	title="Operation invoked as normal."
>演算は通常通り呼出される。</span>

try {
  meal.initialize("肉", 100);  // <span class="comment"
	title="Throws a TypeError."
>`TypeError^t が投出される。</span>
} catch (e) {
}

meal.type = "麺";              // <span class="comment"
	title="Attribute assigned as normal."
>属性は通常通り代入される。</span>
meal.type = "魚";              // <span class="comment"
	title="Attribute assignment ignored."
>属性~代入は無視される。</span>
meal.type == "麺";             // <span class="comment"
	title="Evaluates to true." id="cp-eval-true"
>`true^v に評価される。</span>
</pre>
</div>
		</section>
		<section id="idl-callback-functions">
<h3 title="Callback functions">2.7. 呼戻~関数</h3>

<p class="issue">
“Custom DOM Elements” 仕様からは、`呼戻~関数~型$を，~platform~objから提供される関数に利用することが求められている。
“呼戻~関数” を，両方の目的に利用し得ることを明らかにするため、単に “関数” と改称するべきだろうか？
◎
The “Custom DOM Elements” spec wants to use callback function types for platform object provided functions. Should we rename “callback functions” to just “functions” to make it clear that they can be used for both purposes?
</p>

<p>
`呼戻~関数@
は、関数~型を宣言するときに利用される，`定義$（ `callback^sym `CallbackRest$g に合致）である。
◎
A callback function is a definition (matching callback CallbackRest) used to declare a function type.
</p>

<pre class="syntax">
callback `identifier^i = `return_type^i (/* arguments... */);
</pre>

<p class="note">注記：
似た命名の`呼戻~ifc$も見よ。
◎
Note: See also the similarly named callback interfaces.
</p>

<p>
等号の左側の`識別子$が
`呼戻~関数$の名前を与える。
等号の右側の［
返値型（ `ReturnType$g に合致）
と［
引数~list（ `ArgumentList$g に合致）
<span class="trans-note">【による一連の型】</span>
］］が，`呼戻~関数~型$の~signatureを与える。
◎
The identifier on the left of the equals sign gives the name of the callback function and the return type and argument list (matching ReturnType and ArgumentList) on the right side of the equals sign gives the signature of the callback function type.
</p>

<p>
`呼戻~関数$は
`定数$の型に利用されては~MUST_NOT。
◎
Callback functions must not be used as the type of a constant.
</p>

<p>
呼戻~関数には、次の拡張属性を適用し得る：
`TreatNonObjectAsNull$x
。
◎
The following extended attribute is applicable to callback functions: [TreatNonObjectAsNull].
</p>

<div class="grammar">
--CallbackOrInterface
--CallbackRestOrInterface
-CallbackRest
</div>


<div class="example">
<p>
次の`~IDL片$は、演算の完了-時に利用者により定義される関数を呼出す~APIのために利用される，`呼戻~関数$を定義する。
◎
The following IDL fragment defines a callback function used for an API that invokes a user-defined function when an operation is complete.
</p>

<pre class="idl-code">
callback AsyncOperationCallback = void (DOMString status);

interface AsyncOperations {
  void performOperation(AsyncOperationCallback whenFinished);
};
</pre>

<p>
~JS言語束縛においては、
`Function^t ~objは演算~引数として渡される。
◎
In the ECMAScript language binding, a Function object is passed as the operation argument.
</p>

<pre class="es-code">
var ops = getAsyncOperations();  // <span class="comment"
	title="Get an instance of AsyncOperations."
>`AsyncOperations^T の~instanceを取得する。</span>

ops.performOperation(function(status) {
  window.alert("Operation finished, status is " + status + ".");
});
</pre>
</div>
		</section>
		<section id="idl-typedefs">
<h3 title="Typedefs">2.8. ~typedef</h3>


<p>
`~typedef@
は、ある型に対し 新たな名前を宣言するために利用される，`定義$（ `Typedef$g に合致）である。
この新たな名前は、言語束縛からは公開されない。
これはもっぱら，~IDLにおいて型を参照するための略記法として利用される。
◎
A typedef is a definition (matching Typedef) used to declare a new name for a type. This new name is not exposed by language bindings; it is purely used as a shorthand for referencing the type in the IDL.
</p>

<pre class="syntax">
typedef `type^i `identifier^i;
</pre>

<p>
新たな名前が与えられる型（ `Type$g に合致）は， `typedef^c ~keywordの後に指定され、型に後続する `identifier$g ~tokが，その新たな名前を与える。
◎
The type being given a new name is specified after the typedef keyword (matching Type), and the identifier token following the type gives the name.
</p>

<p>
`Type$g が、同じまたは別の`~typedef$に識別されては~MUST_NOT。
◎
The Type must not identify the same or another typedef.
</p>

<p>
`~typedef$に適用し得る`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to typedefs.
</p>

<div class="grammar">
-Typedef
</div>


<div class="example">
<p>
次の`~IDL片$は、`~typedef$を利用して，長い`連列~型$の代わりに短い`識別子$を使えるようしている。
◎
The following IDL fragment demonstrates the use of typedefs to allow the use of a short identifier instead of a long sequence type.
</p>


<pre class="idl-code">
interface Point {
  attribute double x;
  attribute double y;
};

typedef sequence&lt;Point&gt; Points;

interface Widget {
  boolean pointWithinBounds(Point p);
  boolean allPointsWithinBounds(Points ps);
};
</pre>

</div>
		</section>
		<section id="idl-implements-statements">
<h3 title="Implements statements">2.9. ~implements文</h3>


<p>
`~implements文@
は、［［
文の左側の`識別子$により識別される~ifc %L
］を実装するすべての~objが，［
文の右側の識別子により識別される追加の~ifc %R
］を，
%R が継承する他のすべての~ifcも含めて，実装し~MUST
］ことを宣言するために利用される、`定義$（ `ImplementsStatement$g に合致）である。
◎
An implements statement is a definition (matching ImplementsStatement) used to declare that all objects implementing an interface A (identified by the first identifier) must additionally implement interface B (identified by the second identifier), including all other interfaces that B inherits from.
</p>

<pre class="syntax">
`identifier_L^i implements `identifier_R^i;
</pre>

<p>
%R も<!-- を実装している~objが -->，追加の~ifc %R1 を実装するための`~implements文$を伴って宣言されている場合、推移的に， %L を実装するすべての~objは %R1 も追加で実装することになる。
◎
Transitively, if objects implementing B are declared with an implements statement to additionally implement interface C, then all objects implementing A do additionally implement interface C.
</p>

<ul>
	<li>
%L と %R は異なる~ifcで~MUST。
◎
The two identifiers must identify two different interfaces.
</li>
	<li>
%L は %R を`継承-$していては~MUST_NOT。
◎
The interface identified on the left-hand side of an implements statement must not inherit from the interface identifier on the right-hand side, and vice versa. Both identified interfaces also must not be callback interfaces.
</li>
	<li>
%R は %L を`継承-$していては~MUST_NOT。
◎
↑</li>
	<li>
%L, %R のいずれも，`呼戻~ifc$であっては~MUST_NOT。
◎
↑</li>
	<li>
各`~implements文$を，［
%L を表現する~nodeから %R を表現する~nodeへ向かう，有向~graphの辺
］と見なすとき、この~graphは循環しては~MUST_NOT。
◎
If each implements statement is considered to be an edge in a directed graph, from a node representing the interface on the left-hand side of the statement to a node representing the interface on the right-hand side, then this graph must not have any cycles.
</li>
</ul>

<p>
</p>

<p>
</p>

<p class="trans-note">【
記号 %L, %R はここまで。
】</p>


<p>
所与の~objが実装する~ifcは、
`追補~ifc@
と見なされるものと, そうでないものに分類される。
~obj %O の`追補~ifc$は、次のものからなる：
◎
Interfaces that a given object implements are partitioned into those that are considered supplemental interfaces and those that are not. An interface A is considered to be a supplemental interface of an object O if:
</p>

<ul>
	<li>
%O が~ifc %B を実装するならば、
~IDLにより <code>%B implements %A</code> と言明されている~ifc %A は，
%O の追補~ifcである。
◎
O implements a different interface B, and the IDL states that B implements A; or
</li>
	<li>
%O の追補~ifcが`継承-$する~ifcは，
%O の追補~ifcである。
◎
O implements a different supplemental interface C, and C inherits from A.
</li>
</ul>

<p class="trans-note">【
訳では，原文をより構成的な言い回しに変形している
— この方が解り易いので。
~implements文, および継承の定義により， %O はそのすべての追補~ifcを実装することになる。
概念的には， %O が実装するすべての~ifcは［
%O の`主~ifc$, およびその`被継承~ifc$
］の集合と,
%O の追補~ifcの集合に二分されると考えられる。
】</p>

<div class="note">
<p>
左側の`~ifc$が（ある~objの）`追補~ifc$になるように
`~implements文$を記すのは望ましくない。
例えば，仕様~策定者 1 が次を記していたとして：
◎
Specification authors are discouraged from writing implements statements where the interface on the left-hand side is a supplemental interface. For example, if author 1 writes:
</p>

<pre class="idl-code">
interface Window { /* ... */ };
interface SomeFunctionality { /* ... */ };
Window implements SomeFunctionality;
</pre>

<p>
後に，仕様~策定者 2 が次を記したとする：
◎
and author 2 later writes:
</p>

<pre class="idl-code">
interface Gizmo { /* ... */ };
interface MoreFunctionality { /* ... */ };
SomeFunctionality implements MoreFunctionality;
Gizmo implements SomeFunctionality;
</pre>

<p>
策定者 2 は、正確にどの~ifcが
`implements SomeFunctionality^c
文の左側にすでに利用されたか把握していないこともあり得る。
そのため、予期される以上の~objに対し，
`MoreFunctionality^T
の実装-が要求され得る。
◎
then it might be the case that author 2 is unaware of exactly which interfaces already are used on the left-hand side of an implements SomeFunctionality statement, and so has required more objects implement MoreFunctionality than he or she expected.
</p>

<p class="trans-note">【
前者の仕様から `SomeFunctionality^T を実装するものと想定されている~obj（ `Window^T ）が，（ `Window^T には~~関係ないかもしれない）後者の仕様により
`MoreFunctionality^T も実装しなければならなくなる。
】</p>

<p>
このような場合、策定者 2 は次のように記す方が良いであろう：
◎
Better in this case would be for author 2 to write:
</p>

<pre class="idl-code">
interface Gizmo { /* ... */ };
interface MoreFunctionality { /* ... */ };
Gizmo implements SomeFunctionality;
Gizmo implements MoreFunctionality;
</pre>
</div>

<p>
~ifc %A の
`帰結~ifc@
は、次のものからなる：
◎
The consequential interfaces of an interface A are:
</p>
<ul>
	<li>
~IDLにより <code>%A implements %B</code> と言明されている，各~ifc %B, および
◎
each interface B where the IDL states A implements B;
</li>
	<li>
%A の帰結~ifcが継承する各~ifc, および
◎
each interface that a consequential interface of A inherits from; and
</li>
	<li>
%A の帰結~ifc %C に対し，
~IDLにより <code>%C implements %D</code> と言明されている、各~ifc %D 。
◎
each interface D where the IDL states that C implements D, where C is a consequential interface of A.
</li>
</ul>

<p class="trans-note">【
概念的には、 %A を実装するにあたって実装-が要求される~ifcすべての集合から， %A 自身および %A の`被継承~ifc$を除いたものと捉えられる。
】</p>

<p>
~ifc %B が~ifc %A の
`広義~帰結~ifc@
であるとは、 %B は［
%A 自身であるか, または %A の`帰結~ifc$である
］ことを意味する。
</p>

<p class="trans-note">【
“広義~帰結~ifc” は、この訳で導入した非公式な用語である
— この定義の方が，`帰結~ifc$を~~参照する ほぼすべての記述を簡潔に記せるので。
】</p>


<p>
所与の~ifcに対し、その，どの`広義~帰結~ifc$で定義される，どの~mbの識別子も、他の`広義~帰結~ifc$で定義される~mbの識別子と同じになっては~MUST_NOT。
<span class="trans-note">【
同じ~ifc上においては，`多重定義$があり得る。
】</span>
◎
For a given interface, there must not be any member defined on any of its consequential interfaces whose identifier is the same as any other member defined on any of those consequential interfaces or on the original interface itself.
</p>

<div class="note">
<p>
例えば、次は許容されない：
◎
For example, that precludes the following:
</p>

<pre class="idl-code">
interface A { attribute long x; };
interface B { attribute long x; };
A implements B;  // <span class="comment"
	title="B::x would clash with A::x"
>`B::x^M と `A::x^M が衝突</span>

interface C { attribute long y; };
interface D { attribute long y; };
interface E : D { };
C implements E;  // <span class="comment"
	title="D::y would clash with C::y"
>`D::y^M と `C::y^M が衝突</span>

interface F { };
interface H { attribute long z; };
interface I { attribute long z; };
F implements H;
F implements I;  // <span class="comment"
	title="H::z and I::z would clash when mixed in to F"
>`H::z^M と `I::z^M が `F^T 内に併合される際に衝突</span>
</pre>
</div>

<p>
`~implements文$に適用し得る`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to implements statements.
</p>

<div class="grammar">
-ImplementsStatement
</div>


<div class="example">
<p>
次の`~IDL片$は、２つの`~ifc$を定義する。
一方の~ifcが，他方を実装する~objに常に実装されることを言明する。
◎
The following IDL fragment defines two interfaces, stating that one interface is always implemented on objects implementing the other.
</p>

<pre class="idl-code">
interface Entry {
  readonly attribute unsigned short entryType;
  // <span class="comment">...</span>
};

interface Observable {
  void addEventListener(DOMString type,
                        EventListener listener,
                        boolean useCapture);
  // <span class="comment">...</span>
};

Entry implements Observable;
</pre>

<p>
~JS実装では、したがって，どの `Entry^T も
その原型鎖の中に `addEventListener^l ~propを持つことになる：
◎
An ECMAScript implementation would thus have an “addEventListener” property in the prototype chain of every Entry:
</p>

<pre class="es-code">
var e = getEntry();         // <span class="comment"
	title="Obtain an instance of Entry."
>`Entry^T の~instanceを得る。</span>
typeof e.addEventListener;  // <!--cp-eval-function-->
</pre>

<p>
すべての `Observable^T ~objが `Entry^T を実装するのではないことに注意。
◎
Note that it is not the case that all Observable objects implement Entry.
</p>
</div>
		</section>
		<section id="idl-objects">
<h3 title="Objects implementing interfaces">2.10. ~ifcを実装している~obj</h3>


<p>
`~IDL片$の集合の実装においては、
~objは
`~platform~obj@,
`利用者~obj@,
またはそのいずれでもないものとして記述され得る。
~platform~objと見なされる~objは次の２種類に分けられる：
◎
In a given implementation of a set of IDL fragments, an object can be described as being a platform object, a user object, or neither. There are two kinds of object that are considered to be platform objects:
</p>
<ul>
	<li>
`呼戻~ifc$でない`~ifc$を実装する~obj
◎
objects that implement a non-callback interface;
</li>
	<li>
~IDL `~DOMException$を表現する~obj
◎
objects representing IDL DOMExceptions.
</li>
</ul>

<p>
~browserにおいては、例えば，［
~page内で走らせている~JSに対し，~page内容への~accessを提供する
］ために，~browserに実装されている（ `Node^T や `Document^T などの~ifcを実装している） DOM ~objが、~platform~objになる。
これらの~objは、
C++ などの言語で実装される~exotic~objになるか,
または~native~JS~objになるであろう。
いずれにせよ，所与の~IDL片の集合に対する実装は、［
実装により作成されたすべての~platform~obj
］を認識できる必要がある。
これは、所与の~objに［
その~objが実装における~platform~objであるかどうかを記録するための，何らかの内部~状態
］を~~実際に持たせるか、あるいは, おそらく，［
~objが一定の内部 C++ クラスにより実装されているかどうか
］を見ることにより、実現し得るであろう。
~platform~objが，正確にどのように実装から認識されるかについては、実装~特有になる。
◎
In a browser, for example, the browser-implemented DOM objects (implementing interfaces such as Node and Document) that provide access to a web page’s contents to ECMAScript running in the page would be platform objects. These objects might be exotic objects, implemented in a language like C++, or they might be native ECMAScript objects. Regardless, an implementation of a given set of IDL fragments needs to be able to recognize all platform objects that are created by the implementation. This might be done by having some internal state that records whether a given object is indeed a platform object for that implementation, or perhaps by observing that the object is implemented by a given internal C++ class. How exactly platform objects are recognised by a given implementation of a set of IDL fragments is implementation specific.
</p>

<p>
~system内の他のすべての~objは、~platform~objとしては扱われないことになる。
例えば、~browserが開いた~Web~pageが， DOM Core を実装する~JS~libraryを読込んだとする。
この~libraryは、~browserが提供する実装とは異なる実装と見なされることになる。
~JS~libraryにより作成された［
`Node^T ~ifcを実装する~obj
］は、~browser実装による［
`Node^T を実装する~platform~obj
］としては扱われないことになる。
◎
All other objects in the system would not be treated as platform objects. For example, assume that a web page opened in a browser loads an ECMAScript library that implements DOM Core. This library would be considered to be a different implementation from the browser provided implementation. The objects created by the ECMAScript library that implement the Node interface will not be treated as platform objects that implement Node by the browser implementation.
</p>

<p>
利用者~objとは、［［
作者により定義される演算を~Web~APIから呼出せるようにする，あるいは~Web~APIからの~objの属性~操作を通して, 作者の~programと値を受け~~渡せるようにする
］ための`呼戻~ifc$
］を実装するものとして、作者が作成することになる~objである。
~Web~pageにおいては、 DOM Events 実装から呼出される呼戻を登録する際に利用される，［
`EventListener^T ~ifcを実装する~JS~obj
］が、利用者~objと見なされることになる。
◎
User objects are those that authors would create, implementing callback interfaces that the Web APIs use to be able to invoke author-defined operations or to send and receive values to the author’s program through manipulating the object’s attributes. In a web page, an ECMAScript object that implements the EventListener interface, which is used to register a callback that the DOM Events implementation invokes, would be considered to be a user object.
</p>

<p>
利用者~objが実装できるのは`呼戻~ifc$のみであり,
~platform~objが実装できるのは非~呼戻~ifcのみであることに注意。
◎
Note that user objects can only implement callback interfaces and platform objects can only implement non-callback interfaces.
</p>
		</section>
		<section id="idl-types">
<h3 title="Types">2.11. 型</h3>


<p>
この節では、~Web~IDLで~supportされる型,
それぞれの型に対応する値の集合,
その型の`定数$がどのように表現されるか,
について挙げていく。
◎
This section lists the types supported by Web IDL, the set of values corresponding to each type, and how constants of that type are represented.
</p>

<p>
互いに類似する型の集合には、次のような総称が付与されている：
</p>

<dl >
	<dt>`整数~型@</dt>
	<dd>
`byte$T ,
`octet$T ,
`short$T ,
`unsigned short$T ,
`long$T ,
`unsigned long$T ,
`long long$T ,
`unsigned long long$T
◎
The following types are known as integer types: byte, octet, short, unsigned short, long, unsigned long, long long and unsigned long long.
</dd>

	<dt>`実数~型@</dt>
	<dd>
すべての`整数~型$ ,
`float$T ,
`unrestricted float$T ,
`double$T ,
`unrestricted double$T
◎
The following types are known as numeric types: the integer types, float, unrestricted float, double and unrestricted double.
</dd>

	<dt>`~primitive型@</dt>
	<dd>
`boolean$T ,
すべての`実数~型$
◎
The primitive types are boolean and the numeric types.
</dd>

	<dt>`文字列~型@</dt>
	<dd>
`DOMString$T, すべての`列挙~型$ , `ByteString$T, `USVString$T
◎
The string types are DOMString, all enumeration types, ByteString and USVString.
</dd>

	<dt>`例外~型@</dt>
	<dd>
`Error$T, `DOMException$T
◎
The exception types are Error and DOMException.
</dd>

	<dt>`有型~配列~型@</dt>
	<dd>
`Int8Array$T,
`Int16Array$T,
`Int32Array$T,
`Uint8Array$T,
`Uint16Array$T,
`Uint32Array$T,
`Uint8ClampedArray$T,
`Float32Array$T,
`Float64Array$T
◎
The typed array types are Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array and Float64Array.
</dd>

	<dt>`~buffer~source型@</dt>
	<dd>
`ArrayBuffer$T,
`DataView$T,
すべての`有型~配列~型$
◎
The buffer source types are ArrayBuffer, DataView, and the typed array types.
</dd>

	<dt>`~obj型@</dt>
	<dd>
`object$T 型, すべての `~ifc型$, すべての`例外~型$
◎
The object type, all interface types and the exception types are known as object types.
</dd>

</dl>


<p>
どの型も，型を識別するための文字列である
`型~名@
を持つ — それは一意になるとは限らない。
以下の各~節では、各~型にあてがわれる型~名も定義する。
◎
Every type has a type name, which is a string, not necessarily unique, that identifies the type. Each sub-section below defines what the type name is for each type.
</p>

<p id="type-conversion-exceptions">
`演算$の呼出しや`属性$に値を代入する際に必要になる，言語束縛~特有の型から~IDL型への変換はすべて、［
演算に指定された機能性や 属性~代入
］が~~実行に移される前に遂行される。
変換が遂行できない場合、演算は走らされず, 属性は更新されないことになる。
一部の言語束縛では、この型~変換により，例外が投出され得る。
そのような場合、これらの例外は，演算の呼出しや属性への代入-を試みた~codeまで，伝播することになる。
◎
When conversions are made from language binding specific types to IDL types in order to invoke an operation or assign a value to an attribute, all conversions necessary will be performed before the specified functionality of the operation or attribute assignment is carried out. If the conversion cannot be performed, then the operation will not run or the attribute will not be updated. In some language bindings, type conversions could result in an exception being thrown. In such cases, these exceptions will be propagated to the code that made the attempt to invoke the operation or assign to the attribute.
</p>

<div class="grammar">
-Type
-SingleType
-UnionType
-UnionMemberType
-UnionMemberTypes
-NonAnyType
-ConstType
-PrimitiveType
-UnrestrictedFloatType
-FloatType
-UnsignedIntegerType
-IntegerType
-OptionalLong
-StringType
-PromiseType
-RecordType
-Null
</div>

			<section id="idl-any">
<h4 title="any">2.11.1. `any^T</h4>


<p>
`any$T 型は、 `共用体~型$ 以外のすべての型の和集合である。
その`型~名$は、 `Any^l である。
◎
The any type is the union of all other possible non-union types. Its type name is “Any”.
</p>

<p>
`any$T 型は、そのそれぞれの値ごとに固有の非 `any$T 型が結付けられる意味で，~~特別な共用体~型のようなものである。
例えば，
`any$T 型のある値は `unsigned long$T 150 をとり得る一方、別の値は `long$T 150 をとり得る。
これらは別々の型の値になる。
◎
The any type is like a discriminated union type, in that each of its values has a specific non-any type associated with it. For example, one value of the any type is the unsigned long 150, while another is the long 150. These are distinct values.
</p>

<p>
`any$T 型の個々の値の型は、その
`固有型@
と呼ばれる。
（ `共用体~型$の値も`固有型$を持つ。）
◎
The particular type of an any value is known as its specific type. (Values of union types also have specific types.)
</p>

<p class="trans-note">【
`any^T 型は，
<a href="#es-any">`any^T</a>
節にも見られるように `null^V 値もとり得るようだが（従って暗黙的な意味で`~nullable$型になると考えられる）、明示的な言及が見当たらない（“すべての型” には~nullable型も含まれる？）。
<!-- 
おそらく、非~nullableの `any^T 型も在った方が，いくつかの定義はより簡潔に記せるように思われる。
 -->
】</p>


			</section>
			<section id="idl-boolean">
<h4 title="boolean">2.11.2. `boolean^T</h4>


<p>
`boolean$T 型は２つの値：
`true^V と `false^V をとり得る。
◎
The boolean type has two values: true and false.
</p>

<p>
~IDLにおいては、 `boolean$T 定数~値は［
`true^c ／ `false^c
］~tokで表現される。
◎
boolean constant values in IDL are represented with the true and false tokens.
</p>

<p>
`boolean$T 型の`型~名$は、 `Boolean^l である。
◎
The type name of the boolean type is “Boolean”.
</p>
			</section>
			<section id="idl-integers">
<h4>2.11.2.3〜10. 整数~型</h4>

<p class="trans-note">【
この訳では、原文の 2.11.2.3〜10 節の内容
— 各種~IDL整数~型の定義を集約して，一括して与える。
】</p>

<p>
各種 有符号／無符号 `整数~型$の，とり得る値の範囲, および `型~名$は、次の表で与えられる：
◎
The xxx := (byte|short|long|long long／octet|unsigned short|unsigned long|unsigned long long) type is a (signed／unsigned) integer type that has values in the range ([−P÷2, P÷2 − 1]／[0, P − 1]); P := 2^(8|16|32|64).
◎
xxx constant values in IDL are represented with integer tokens.
◎
The type name of the xxx type is “Xxx”.
</p>


<table id="matrix-idl-integers">

<thead><tr><th>~IDL型
</th><th>最小~値
</th><th>最大~値
</th><th>型~名
</th></tr></thead>

<tbody><tr><th>`byte@T
</th><td title="−128">−2`7^sup
</td><td title="127">2`7^sup − 1
</td><td>`Byte^l

</td></tr><tr><th>`octet@T
</th><td>0
</td><td title="255">2`8^sup − 1
</td><td>`Octet^l

</td></tr><tr><th>`short@T
</th><td title="−32768">−2`15^sup
</td><td title="32767">2`15^sup − 1
</td><td>`Short^l

</td></tr><tr><th>`unsigned short@T
</th><td>0
</td><td title="65535">2`16^sup − 1
</td><td>`UnsignedShort^l

</td></tr><tr><th>`long@T
</th><td title="−2147483648">−2`31^sup
</td><td title="2147483647">2`31^sup − 1
</td><td>`Long^l

</td></tr><tr><th>`unsigned long@T
</th><td>0
</td><td title="4294967295">2`32^sup − 1
</td><td>`UnsignedLong^l

</td></tr><tr><th>`long long@T
</th><td title="−9223372036854775808">−2`63^sup
</td><td title="9223372036854775807">2`63^sup − 1
</td><td>`LongLong^l

</td></tr><tr><th>`unsigned long long@T
</th><td>0
</td><td title="18446744073709551615">2`64^sup − 1
</td><td>`UnsignedLongLong^l

</td></tr></tbody></table>


<p>
~IDLにおいては、どの`整数~型$の定数~値も， `integer$g ~tokで表現される。
</p>

			</section>
			<section id="idl-floats">
<h4>2.11.11〜14. 浮動小数点数~型</h4>

<p class="trans-note">【
この訳では、原文の 3.11.11 〜 3.11.14 節の内容
— 各種~IDL浮動小数点数~型の定義を集約して，一括して与える。
】</p>

<p>
各種
“浮動小数点数 型”
— `整数~型$でない`実数~型$ —
の，とり得る値の範囲, および `型~名$は、次の表で与えられる：
</p>


<table id="matrix-idl-floats">

<thead><tr><th>~IDL型
</th><th>値の範囲 `IEEE-754$r
</th><th>型~名
</th></tr></thead>

<tbody><tr><th>`float@T
</th><td>
すべての有限［
単精度 32 ~bit IEEE 754 浮動小数点数
］の集合
◎
The float type is a floating point numeric type that corresponds to the set of finite single-precision 32 bit IEEE 754 floating point numbers. [IEEE-754]
</td><td>`Float^l

</td></tr><tr><th>`unrestricted float@T
</th><td>
すべての有限, 非~有限［
単精度 32 ~bit IEEE 754 浮動小数点数
］の集合
◎
The unrestricted float type is a floating point numeric type that corresponds to the set of all possible single-precision 32 bit IEEE 754 floating point numbers, finite and non-finite. [IEEE-754]
</td><td>`UnrestrictedFloat^l

</td></tr><tr><th>`double@T
</th><td>
すべての有限［
倍精度 64 ~bit IEEE 754 浮動小数点数
］の集合
◎
The double type is a floating point numeric type that corresponds to the set of finite double-precision 64 bit IEEE 754 floating point numbers. [IEEE-754]
</td><td>`Double^l

</td></tr><tr><th>`unrestricted double@T
</th><td>
すべての有限, 非~有限［
倍精度 64 ~bit IEEE 754 浮動小数点数
］の集合
◎
The unrestricted double type is a floating point numeric type that corresponds to the set of all possible double-precision 64 bit IEEE 754 floating point numbers, finite and non-finite. [IEEE-754]
</td><td>`UnrestrictedDouble^l

</td></tr></tbody></table>


<p>
~IDLにおいては、どの浮動小数点数 型の定数~値も，
`float$g ~tokで表現される。
◎
The type name of the( xxx)? yyy type is “(Xxx)Yyy”.
</p>

<p class="advisement">
特に 32 ~bit浮動小数点~型を利用する理由が無い限り，仕様は
`float$T でなく，`double$T を利用するべきである。
`double$T が表現し得る値~集合は，より近く~JS `Number^t に合致するので。
◎
Unless there are specific reasons to use a 32 bit floating point type, specifications should use double rather than float, since the set of values that a double can represent more closely matches an ECMAScript Number.
</p>

			</section>
			<section id="idl-DOMString">
<h4 title="DOMString">2.11.15. `DOMString^T</h4>


<p>
`DOMString$T 型は、可能なすべての［
`符号単位$の並び
］の集合に対応する。
そのような並びは、共通的に，
UTF-16 符号化~文字列 `RFC2781$r
として解釈されるが、要求されてはいない。
`DOMString$T は
<cite><a href="https://www.w3.org/TR/DOM-Level-3-Core//core#ID-C74D1578">DOM Level 3 Core §The DOMString Type</a></cite>
において［
OMG IDL boxed `sequence&lt;unsigned short&gt;^T valuetype
］として定義されているが、この文書は，文字列が要求される様々な状況における，その連列~型に対する特別な場合分けを避けるため、 `DOMString$T を内在的な型として定義する。
◎
The DOMString type corresponds to the set of all possible sequences of code units. Such sequences are commonly interpreted as UTF-16 encoded strings [RFC2781] although this is not required. While DOMString is defined to be an OMG IDL boxed sequence&lt;unsigned short&gt; valuetype in DOM Level 3 Core §The DOMString Type, this document defines DOMString to be an intrinsic type so as to avoidspecial casing that sequence type in various situations where a string is required.
</p>

<p class="note">注記：
`null^V は `DOMString$T の値ではないことにも注意。
~IDLにおいて `null^V を許容するためには，
<code >DOMString?</code> と記される
`~nullable$
`DOMString$T
を利用する必要がある。
◎
Note: Note also that null is not a value of type DOMString. To allow null, a nullable DOMString, written as DOMString? in IDL, needs to be used.
</p>

<p>
この仕様においては、
`DOMString$T 値が妥当な UTF-16 文字列であることは要求されない。
例えば，
`DOMString$T 値は、対になっていない代用対（ surrogate pair ）文字も含み得る。
しかしながら，~Web~IDLを利用する仕様の策定者は、所与の個々の［
`符号単位$の並び
］から `~Unicode~scalar値$列を得たいと求めることもあろう。
◎
Nothing in this specification requires a DOMString value to be a valid UTF-16 string. For example, a DOMString value might include unmatched surrogate pair characters. However, authors of specifications using Web IDL might want to obtain a sequence of Unicode scalar values given a particular sequence of code units.
</p>

<p>
次の~algoは、 `DOMString$T 値 %S を
`~Unicode~scalar値~列に変換-@
する仕方を定義する：
◎
The following algorithm defines a way to convert a DOMString to a sequence of Unicode scalar values:
</p>

<ol class="algorithm">
	<li>
%n := %S の長さ
◎
Let S be the DOMString value.
◎
Let n be the length of S.
</li>
	<li>
%i :← 0
◎
Initialize i to 0.
</li>
	<li>
%U :← Unicode 文字の空~連列
◎
Initialize U to be an empty sequence of Unicode characters.
</li>
	<li>
<p id="cp-while-i-n">
~WHILE %i ~LT %n ：
◎
While i &lt; n:
</p>


		<ol>
			<li>
%c := %S 内で~index %i に位置する`符号単位$
◎
Let c be the code unit in S at index i.
</li>
			<li>
<p>
%c の値に応じて：
◎
Depending on the value of c:
</p>
				<dl class="switch">
					<dt>%c ~LT 0xD800</dt>
					<dt>%c ~GT 0xDFFF</dt>
					<dd>

<p>
符号位置 %c の Unicode 文字を %U に付加する
◎
Append to U the Unicode character with code point c.
</p>
					</dd>
					<dt>0xDC00 ~LTE %c ~LTE 0xDFFF</dt>
					<dd>
<p>
~REPLACEMENT を %U に付加する
◎
Append to U a U+FFFD REPLACEMENT CHARACTER.
</p>
					</dd>
					<dt>0xD800 ~LTE %c ~LTE 0xDBFF</dt>
					<dd>
						<ol class="only">
							<li>
~IF
%i + 1 ~GTE %n
~THEN
~REPLACEMENT を %U に付加する
◎
If i = n−1, then append to U a U+FFFD REPLACEMENT CHARACTER.
</li>
							<li>
<p>
~ELSE
⇒
◎
Otherwise, i ~LT n−1:
</p>
								<ol>
									<li>
%d := %S 内の~index %i + 1 に位置する`符号単位$
◎
Let d be the code unit in S at index i+1.
</li>
									<li>
<p>
~IF
0xDC00 ~LTE %d ~LTE 0xDFFF
⇒
◎
If 0xDC00 ≤ d ≤ 0xDFFF, then:
</p>
										<ol>
											<li>
符号位置 ［
2`16^sup + 2`10^sup × ( %c &amp; 0x3FF ) + ( %d &amp; 0x3FF )
］の Unicode 文字を %U に付加する
◎
Let a be c &amp; 0x3FF.
◎
Let b be d &amp; 0x3FF.
◎
Append to U the Unicode character with code point 2^16 + 2^10 a+b.
</li>
											<li>
%i ← %i&nbsp;+&nbsp;1
◎
Set i to i+1.
</li>
										</ol>
									</li>
									<li>
~ELSE
~THEN
~REPLACEMENT を %U に付加する
◎
Otherwise, d &lt; 0xDC00 or d &gt; 0xDFFF. Append to U a U+FFFD REPLACEMENT CHARACTER.
</li>
								</ol>
							</li>
						</ol>
					</dd>
				</dl>
			</li>
			<li>
%i ← %i&nbsp;+&nbsp;1
◎
Set i to i+1.
</li>
		</ol>
	</li>
	<li>
~RET %U
◎
Return U.
</li>
</ol>

<p>
~IDLにおいて，定数 `DOMString$T 値を表現する仕方は、ない。
`string$g ~literalを利用して， `DOMString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］に既定~値を指定することはできる。
◎
There is no way to represent a constant DOMString value in IDL, although DOMString dictionary member and operation optional argument default values can be specified using a string literal.
</p>

<p>
`DOMString$T 型の`型~名$は、 `String^l である。
◎
The type name of the DOMString type is “String”.
</p>

			</section>
			<section id="idl-ByteString">
<h4 title="ByteString">2.11.16. `ByteString^T</h4>

<p>
`ByteString$T 型は、可能なすべての［
byte の並び
］の集合に対応する。
その種の並びは、要求されてはいないが，［
UTF-8 に符号化された文字列 `RFC3629$r, あるいは［
他の何らかの［ 1 符号単位あたり 8 ~bit ］になる符号化方式
］により符号化された文字列
］に解釈し得る。
◎
The ByteString type corresponds to the set of all possible sequences of bytes. Such sequences might be interpreted as UTF-8 encoded strings [RFC3629] or strings in some other 8-bit-per-code-unit encoding, although this is not required.
</p>

<p>
~IDLにおいて，定数 `ByteString$T 値を表現する仕方は、ない。
`string$g ~literalを利用して， `ByteString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］に既定~値を指定することはできる。
◎
There is no way to represent a constant ByteString value in IDL, although ByteString dictionary member and operation optional argument default values can be specified using a string literal.
</p>

<p>
`ByteString$T 型の`型~名$は、 `ByteString^l である。
◎
The type name of the ByteString type is “ByteString”.
</p>

<p class="advisement">
仕様は、［
HTTP などの， byte や文字列を交換可能な~~形で利用する~protocol
］とのやりとりのみに，
`ByteString$T を利用するべきである。
一般に、文字列は，その値が［
常に ASCII または 何らかの 8 ~bit文字~符号化方式
］になることが期待されているとしても，
`DOMString$T 値により表現されるべきである。
8 ~bit~dataを保持するためには、`ByteString$T ではなく，［
`octet$T または `byte$T
］を要素とする［
`連列~型$ ／ `凍結~配列~型$ ／
<a href="~TC39#sec-typedarray-objects">Typed Arrays</a>
］が利用されるべきである。
◎
Specifications should only use ByteString for interfacing with protocols that use bytes and strings interchangably, such as HTTP. In general, strings should be represented with DOMString values, even if it is expected that values of the string will always be in ASCII or some 8 bit character encoding. Sequences, frozen arrays or Typed Arrays with octet or byte elements should be used for holding 8 bit data rather than ByteString.
</p>

			</section>
			<section id="idl-USVString">
<h4 title="USVString">2.11.17. `USVString^T</h4>

<p>
`USVString$T 型は、可能なすべての［［
`~Unicode~scalar値$
— ~surrogate符号位置でない Unicode 符号位置
］の並び
］の集合に対応する。
◎
The USVString type corresponds to the set of all possible sequences of Unicode scalar values, which are all of the Unicode code points apart from the surrogate code points.
</p>

<p>
~IDLにおいて，定数 `USVString$T 値を表現する仕方は、ない。
`string$g ~literalを利用して， `USVString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］に既定~値を指定することはできる。
◎
There is no way to represent a constant USVString value in IDL, although USVString dictionary member and operation optional argument default values can be specified using a string literal.
</p>

<p>
`USVString$T 型の`型~名$は、 `USVString^l である。
◎
The type name of the USVString type is “USVString”.
</p>

<p class="advisement">
仕様は、［
~text処理を遂行する際に `~Unicode~scalar値$による文字列~演算が必要になる
］ときにのみ，~APIに `USVString$T を利用するべきである。
文字列を利用する ほとんどの~APIは、文字列~内の`符号単位$に いかなる解釈も行わない `DOMString$T を利用するべきである。
疑わしい場合は `DOMString$T を利用すること。
◎
Specifications should only use USVString for APIs that perform text processing and need a string of Unicode scalar values to operate on. Most APIs that use strings should instead be using DOMString, which does not make any interpretations of the code units in the string. When in doubt, use DOMString.
</p>

			</section>
			<section id="idl-object">
<h4 title="object">2.11.18. `object^T</h4>

<p>
`object$T 型は、可能なすべての［
非 `null^V ~obj参照
］の集合に対応する。
◎
The object type corresponds to the set of all possible non-null object references.
</p>

<p>
~IDLにおいて，定数 `object$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant object value in IDL.
</p>

<p>
可能なすべての~obj参照に加えて，
`null^V 値も内包する型を表すためには、
`~nullable型$ `object?^T を利用する。
◎
To denote a type that includes all possible object references plus the null value, use the nullable type object?.
</p>

<p>
`object$T 型の`型~名$は、 `Object^l である。
◎
The type name of the object type is “Object”.
</p>
			</section>
			<section id="idl-interface">
<h4 title="Interface types">2.11.19. ~ifc型</h4>


<p>
`~ifc$を識別する`識別子$は、その~ifcを実装する，可能なすべての［
非 `null^V ~obj参照の集合
］に対応する型を指すために利用される。
◎
An identifier that identifies an interface is used to refer to a type that corresponds to the set of all possible non-null references to objects that implement that interface.
</p>

<p>
非~呼戻~ifcに対する~ifc型の~IDL値は，単に~obj参照により表現される。
`呼戻~ifc$ に対しては、~ifc型の~IDL値は［
~obj参照,
`呼戻~文脈$
］の組により表現される。
`呼戻~文脈@
とは、言語束縛~特有の値であり、［
言語束縛~特有の~obj参照が~IDL値に変換される時点における，実行~文脈についての情報
］を格納するために利用されるものである。
◎
For non-callback interfaces, an IDL value of the interface type is represented just by an object reference. For callback interfaces, an IDL value of the interface type is represented by a tuple of an object reference and a callback context. The callback context is a language binding specific value, and is used to store information about the execution context at the time the language binding specific object reference is converted to an IDL value.
</p>

<p class="note">注記：
~JS~objに対しては、`呼戻~文脈$は，
`Object^t 値が~IDL呼戻~ifc型の値に変換される時点の
`~incumbent設定群~obj$への参照を保持するために利用される。
`es-interface$sec
を見よ。
◎
Note: For ECMAScript objects, the callback context is used to hold a reference to the incumbent settings object at the time the Object value is converted to an IDL callback interface type value. See §3.2.13 Interface types.
</p>

<p>
~IDLにおいて，個々の~ifc型の定数~obj参照~値を表現する仕方は、ない。
◎
There is no way to represent a constant object reference value for a particular interface type in IDL.
</p>

<p>
所与の~ifcを実装する，可能なすべての~obj参照に加えて、
`null^V 値も内包する型を表すためには，`~nullable型$を利用する。
◎
To denote a type that includes all possible references to objects implementing the given interface plus the null value, use a nullable type.
</p>

<p>
~ifc型の`型~名$は、その~ifcの`識別子$である。
◎
The type name of an interface type is the identifier of the interface.
</p>
			</section>
			<section id="idl-dictionary">
<h4 title="Dictionary types">2.11.20. 辞書~型</h4>


<p>
`辞書$を識別する`識別子$は、［
辞書~定義に~~寄与する，すべての辞書の集合
］に対応する型を指すために利用される。
◎
An identifier that identifies a dictionary is used to refer to a type that corresponds to the set of all dictionaries that adhere to the dictionary definition.
</p>

<p>
~IDLにおいて，定数~辞書~値を表現する仕方は、ない。
◎
There is no way to represent a constant dictionary value in IDL.
</p>

<p>
辞書~型の`型~名$は、その辞書の`識別子$である。
◎
The type name of a dictionary type is the identifier of the dictionary.
</p>
			</section>
			<section id="idl-enumeration">
<h4 title="Enumeration types">2.11.21. 列挙~型</h4>


<p>
`列挙$を識別する`識別子$は、［
その`列挙~値$に属する文字列（ `DOMString$T と同様の，`符号単位$の並び）の集合
］を値にとる型を指すために利用される。
<!--  -->
◎
An identifier that identifies an enumeration is used to refer to a type whose values are the set of strings (sequences of code units, as with DOMString) that are the enumeration’s values.
</p>

<p>
`DOMString$T と同様に、
~IDLにおいて，定数`列挙$値を表現する仕方は、ない。
`string$g ~literalを利用して、列挙~型にされた`辞書~mb$に
`辞書既定値^を指定することはできる。
◎
Like DOMString, there is no way to represent a constant enumeration value in IDL, although enumeration-typed dictionary member default values can be specified using a string literal.
</p>

<p>
列挙~型の`型~名$は、その列挙の`識別子$である。
◎
The type name of an enumeration type is the identifier of the enumeration.
</p>
			</section>
			<section id="idl-callback-function">
<h4 title="Callback function types">2.11.22. 呼戻~関数~型</h4>


<p>
`呼戻~関数$を識別する`識別子$は、［
所与の~signatureを伴う関数~objへの参照
］を値にとる型を指すために利用される。
◎
An identifier that identifies a callback function is used to refer to a type whose values are references to objects that are functions with the given signature.
</p>

<p>
呼戻~関数~型の~IDL値は，［
~obj参照, `呼戻~文脈$
］の組により表現される。
◎
An IDL value of the callback function type is represented by a tuple of an object reference and a callback context.
</p>

<p class="note">注記：
`~ifc型$と同様に、`呼戻~文脈$は，
~JS `Object^t 値が~IDL呼戻~ifc型の値に変換される時点の
`~incumbent設定群~obj$への参照を保持するために利用される。
`es-callback-function$sec
を見よ。
◎
Note: As with callback interface types, the callback context is used to hold a reference to the incumbent settings object at the time an ECMAScript Object value is converted to an IDL callback function type value. See §3.2.16 Callback function types.
</p>


<p>
~IDLにおいて，定数  `呼戻~関数$値を表現する仕方は、ない。
◎
There is no way to represent a constant callback function value in IDL.
</p>

<p>
呼戻~関数~型の`型~名$は、その呼戻~関数の`識別子$である。
◎
The type name of a callback function type is the identifier of the callback function.
</p>
			</section>
			<section id="idl-nullable-type">
<h4 title="Nullable types — T?">2.11.23. ~nullable型 — `~varT?^T</h4>


<div class="p">
<p>
`~nullable型@
は、（その
`内縁~型@
と呼ばれる）既存の型から構築される~IDL型であり、とり得る値の集合は，内縁~型がとり得る値に値 `null^V のみを~~追加したものになる。
~IDLにおいては、`~nullable型$は，既存の型の後に
文字 `U+003F QUESTION MARK ("?")^char
を置いて表現される。
`内縁~型$は次のいずれであっても~MUST_NOT：
</p>

<ul ><li>`any$T 型
</li><li>別の~nullable型
</li><li>`共用体~型$であって［
それ自身が`~nullable型を内包する$, または
その`平坦化~mb型$に［
`辞書~型$ ／ `~record型$
］が含まれている
］もの。
</li></ul>

◎
A nullable type is an IDL type constructed from an existing type (called the inner type), which just allows the additional value null to be a member of its set of values. Nullable types are represented in IDL by placing a U+003F QUESTION MARK ("?") character after an existing type. The inner type must not be any, another nullable type, or a union type that itself has includes a nullable type or has a dictionary or record type as one of its flattened member types.
</div>

<p class="note">注記：
［
辞書~型／~record型
］は，一般には~nullableになれるが、その場合，演算~引数や辞書~mbの型には利用できない。
◎
Note: Although dictionary and record types can in general be nullable, they cannot when used as the type of an operation argument or a dictionary member.
</p>

<p>
~IDLにおいては、~nullable型の定数~値は，その`内縁~型$の定数~値と同じ仕方で表現されるか, または `null^c ~tokで表現される。
◎
Nullable type constant values in IDL are represented in the same way that constant values of their inner type would be represented, or with the null token.
</p>

<p>
~nullable型の`型~名$は、［
その内縁~型 %T の型~名,
文字列 `OrNull^l
］の連結である。
◎
The type name of a nullable type is the concatenation of the type name of the inner type T and the string “OrNull”.
</p>

<div class="example">
<p>
例えば、値
`true^V, `false^V, `null^V
をとり得る型は， `boolean?^T と記される：
◎
For example, a type that allows the values true, false and null is written as boolean?:
</p>

<pre class="idl-code">
interface MyConstants {
  const boolean? ARE_WE_THERE_YET = false;
};
</pre>

<p>
次の`~ifc$は２個の`属性$を持つ。
一方は `DOMString$T または `null^V 値を値にとり得る。
他方は `Node^T ~objへの参照または `null^V 値を値にとり得る：
◎
The following interface has two attributes: one whose value can be a DOMString or the null value, and another whose value can be a reference to a Node object or the null value:
</p>

<pre class="idl-code">
interface Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute Node? parentNode;
  // <span class="comment">...</span>
};
</pre>
</div>
			</section>
			<section id="idl-sequence">
<h4 title="Sequence types — sequence&lt;T&gt;">2.11.24. 連列~型 — ~sequence_T</h4>

<p>
`連列~型@
— ~sequence_T —
は、［［
型 %T の値
］の連列（長さゼロも許容される）
］を値にとり得るような，~parameter化された型である。
◎
The sequence&lt;T&gt; type is a parameterized type whose values are (possibly zero-length) sequences of values of type T.
</p>

<p>
連列は常に値渡しである。
連列が何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に連列が渡された際に，その連列への参照が~objに保有されることはない。
同様に，~platform~objから返されるどの連列も複製であり、それに対する改変は~platform~objからは可視でないことになる。
◎
Sequences are always passed by value. In language bindings where a sequence is represented by an object of some kind, passing a sequence to a platform object will not result in a reference to the sequence being kept by that object. Similarly, any sequence returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>
<p>
~IDLにおいて，定数~連列~値を表現する仕方は、ない。
◎
There is no way to represent a constant sequence value in IDL.
</p>

<p>
連列は［
`属性$／`定数$
］の型に利用されては~MUST_NOT。
◎
Sequences must not be used as the type of an attribute or constant.
</p>

<p class="note">注記：
この制約は、［
`連列~型$は、その参照が渡し回されるものではなく，複製されるものである
］ことを，仕様~策定者や利用者から見て明らかにするためにある。
連列~型の~writableな`属性$には、代わりに，連列を取得-／設定する`演算$~pairの利用を勧める。
◎
Note: This restriction exists so that it is clear to specification writers and API users that sequences are copied rather than having references to them passed around. Instead of a writable attribute of a sequence type, it is suggested that a pair of operations to get and set the sequence is used.
</p>

<p>
連列~型の`型~名$は、［
%T の型~名,
文字列 `Sequence^l
］の連結である。
◎
The type name of a sequence type is the concatenation of the type name for T and the string “Sequence”.
</p>

			</section>
			<section id="idl-record">
<h4 title="Record types — record&lt;K, V&gt;">2.11.25. ~record型 — ~record_KV</h4>

<p>
`~record型@
— ~record_KV —
は、［
いくつかの`~mapping$からなる，有順序~連想配列
］を値にとり得るような，~parameter化された型である。
各
`~mapping@
は、［
型 %K の ある~instance（ “~key” ）を型 %V の ある~instance（ “値” ）に対応付けるもの
］である。
~recordの~mappingたちの順序は、~record値の作成-時に決定される。
仕様においては、~recordの値は，次のようにも記せる／され得る：
◎
A record type is a parameterized type whose values are ordered associative arrays mapping instances of K to instances of V. The (key, value) pairs are called mappings. The order of a record’s mappings is determined when the record value is created. In a specification, a record’s value can be written:
</p>

<blockquote>`« (key1, value1), (key2, value2), … »^V</blockquote>

<p>
しかしながら、~IDLにおいて，定数~record値を表現する仕方は、ない。
◎
However, there is no way to represent a constant record value in IDL.
</p>

<p>
%K は［
`DOMString$T ／ `USVString$T ／ `ByteString$T
］でなければ~MUST。
◎
K must be one of DOMString, USVString, or ByteString.
</p>

<p>
~recordは常に値渡しである。
~recordが何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に~recordが渡された際に，その~recordへの参照が~objに保有されることはない。
同様に，~platform~objから返されるどの~recordも複製であり、それに対する改変は~platform~objからは可視でないことになる。
◎
Records are always passed by value. In language bindings where a record is represented by an object of some kind, passing a record to a platform object will not result in a reference to the record being kept by that object. Similarly, any record returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>

<p>
~recordは［
`属性$／`定数$
］の型に利用されては~MUST_NOT。
◎
Records must not be used as the type of an attribute or constant.
</p>

<p>
~record型の`型~名$は、［
%K の型~名,
%V の型~名,
文字列 `Record^l
］の連結である。
◎
The type name of a record type is the concatenation of the type name for K, the type name for V and the string “Record”.
</p>

			</section>
			<section id="idl-promise">

<h4 title="Promise types — Promise&lt;T&gt;">2.11.26. ~promise型 — ~promise_T</h4>

<p>
`~promise型@
— ~promise_T —
は、［［
<span class="block">
“［［
非同期 演算において，延期され得る（非同期にもなり得る）計算
］の最終的な結果†
］への~place-holder”
`ECMA-262$r
</span>
］として利用される~obj
］への参照を値にとるような，~parameter化された型である。
~promise~objの意味論についての詳細は~JS仕様
<a href="~TC39#sec-promise-objects">25.4 節</a>
に。
◎
A promise type is a parameterized type whose values are references to objects that “is used as a place holder for the eventual results of a deferred (and possibly asynchronous) computation result of an asynchronous operation”. See section 25.4 of the ECMAScript specification for details on the semantics of promise objects.
</p>

<p class="trans-note">【†
%T が，充足-時における結果の値の型を与える。
】</p>

<p>
~IDLにおいて，~promise値を表現する仕方は、ない。
◎
There is no way to represent a promise value in IDL.
</p>

<p>
~promise型の`型~名$は、［
%T の型~名,
文字列 `Promise^l
］の連結である。
◎
The type name of a promise type is the concatenation of the type name for T and the string “Promise”.
</p>


			</section>
			<section id="idl-union">
<h4 title="Union types">2.11.27. 共用体~型</h4>


<p>
`共用体~型@
（ union ）は、とり得る値の集合が 複数の型の値の和集合であるような，型である。
共用体~型（ `UnionType$g に合致）は、
`or^c ~keywordで区切られた型の並びを左右~丸括弧で括って記される。
共用体~型を構成する型は、共用体の
`~mb型@
と呼ばれる。
◎
A union type is a type whose set of values is the union of those in two or more other types. Union types (matching UnionType) are written as a series of types separated by the or keyword with a set of surrounding parentheses. The types which comprise the union type are known as the union’s member types.
</p>

<div class="note">
<p>
例えば，
`(Node or DOMString)^c や `(double or sequence&lt;double&gt;)^c
などのように記す。
`共用体~型$に全体として `?^c 接尾辞を適用するときは，
`(Node or DOMString)?^c
のように，右~丸括弧の後に置く。
◎
For example, you might write (Node or DOMString) or (double or sequence&lt;double&gt;). When applying a ? suffix to a union type as a whole, it is placed after the closing parenthesis, as in (Node or DOMString)?.
</p>

<p>
共用体~型の`~mb型$は、入子にされた共用体~型にまでは掘り下げられないことに注意。
したがって，
`(double or (sequence&lt;long&gt; or Event) or (Node or DOMString)?)^T
の~mb型は、
`double^T ,
`(sequence&lt;long&gt; or Event)^T ,
`(Node or DOMString)?^T
になる。
◎
Note that the member types of a union type do not descend into nested union types. So for (double or (sequence&lt;long&gt; or Event) or (Node or DOMString)?) the member types are double, (sequence&lt;long&gt; or Event) and (Node or DOMString)?.
</p>
</div>

<p>
`any$T 型と同様、共用体~型の値は，その値に合致するいずれか一つの`~mb型$を`固有型$として持つ。
◎
Like the any type, values of union types have a specific type, which is the particular member type that matches the value.
</p>

<p>
`共用体~型$ %T の
`平坦化~mb型@
とは、次の手続きで決定される型の集合である：
◎
The flattened member types of a union type is a set of types determined as follows:
</p>

<ol class="algorithm">
	<li>
%S :← ∅
◎
Let T be the union type.
◎
Initialize S to ∅.
</li>
	<li>
<p id="cp-foreach-union-mb">
~FOR
%T 内の~EACH ( `~mb型$ %U ) に対し：
◎
For each member type U of T:
</p>
		<ol>
			<li>
~IF
%U は `~nullable型$である
~THEN
%U ← %U の`内縁~型$
◎
If U is a nullable type, then set U to be the inner type of U.
</li>
			<li>
~IF
%U は `共用体~型$である
~THEN
%U の`平坦化~mb型$に属するすべての型を %S に追加する
◎
If U is a union type, then add to S the flattened member types of U.
</li>
			<li>
~ELSE
~THEN
%U を %S に追加する
◎
Otherwise, U is not a union type. Add U to S.
</li>
		</ol>
	</li>
	<li>
~RET %S
◎
Return S.
</li>
</ol>

<p class="note">注記：
例えば，`共用体~型$
`(Node or (sequence&lt;long&gt; or Event) or (XMLHttpRequest or DOMString)? or sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;)^T
の`平坦化~mb型$は、６つの型［
`Node^T ,
`sequence&lt;long&gt;^T ,
`Event^T ,
`XMLHttpRequest^T ,
`DOMString^T ,
`sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;^T
］からなる。
◎
Note: For example, the flattened member types of the union type (Node or (sequence&lt;long&gt; or Event) or (XMLHttpRequest or DOMString)? or sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;) are the six types Node, sequence&lt;long&gt;, Event, XMLHttpRequest, DOMString and sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;.
</p>

<p>
`共用体~型$ %T の
`~nullable~mb型の個数@
とは、次の手続きで決定される整数である：
◎
The number of nullable member types of a union type is an integer determined as follows:
</p>

<ol class="algorithm">
	<li>
%n :← 0
◎
Let T be the union type.
◎
Initialize n to 0.
</li>
	<li>
<!--cp-foreach-union-mb-->
		<ol>
			<li>
<p>
~IF
%U は `~nullable型$である
⇒
◎
If U is a nullable type, then:
</p>
				<ol>
					<li>
%n ← %n + 1
◎
Set n to n + 1.
</li>
					<li>
%U ← %U の`内縁~型$
◎
Set U to be the inner type of U.
</li>
				</ol>
			</li>
			<li>
<p>
~IF
%U は `共用体~型$である
⇒
◎
If U is a union type, then:
</p>
				<ol>
					<li>
%m := %U の`~nullable~mb型の個数$
◎
Let m be the number of nullable member types of U.
</li>
					<li>
%n ← %n + %m
◎
Set n to n + m.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %n
◎
Return n.
</li>
</ol>

<p>
`~mb型$に `any$T 型が利用されては~MUST_NOT。
◎
The any type must not be used as a union member type.
</p>

<p>
`共用体~型$の
`~nullable~mb型の個数$
は 0 か 1 で~MUST。
1 の場合、その共用体~型は`平坦化~mb型$に［
`辞書~型$／`~record型$
］を持っては~MUST_NOT。
◎
The number of nullable member types of a union type must be 0 or 1, and if it is 1 then the union type must also not have a dictionary type or record type in its flattened member types.
</p>

<p>
次を満たす型は
`~nullable型を内包する@
とされる。
◎
A type includes a nullable type if:
</p>

<ul>
	<li>
`~nullable型$である, または
◎
the type is a nullable type, or
	</li>
	<li>
`共用体~型$であり, かつ
その `~nullable~mb型の個数$が 0 でない（ 1 である）。
◎
the type is a union type and its number of nullable member types is 1.
	</li>
</ul>

<p class="trans-note">【
概念的には， `null^V を値にとり得る型と考えられる。
ただし、この定義では `any$T 型は含まれないことになる。
】</p>

<p>
`共用体~型$の`平坦化~mb型$に属する
どの２つの型も`判別可能$で~MUST。
◎
Each pair of flattened member types in a union type, T and U, must be distinguishable.
</p>

<p>
~IDLにおいては、`共用体~型$の定数~値は，それらの`~mb型$の定数~値と同じ仕方で表現される。
◎
Union type constant values in IDL are represented in the same way that constant values of their member types would be represented.
</p>

<p>
共用体~型の`型~名$は、その各~mb型の型~名を順に，文字列 `Or^l で連結したものである。
◎
The type name of a union type is formed by taking the type names of each member type, in order, and joining them with the string “Or”.
</p>
<div class="grammar">
--UnionType
--UnionMemberType
--UnionMemberTypes
--NonAnyType
</div>
			</section>
			<section id="idl-Error">
<h4 title="Error">2.11.28. `Error^T</h4>

<p>
`Error$T 型は、［
`単純例外$, `~DOMException$
］を含む，可能なすべての［
非 null 例外~objへの参照
］の集合に対応する。
◎
The Error type corresponds to the set of all possible non-null references to exception objects, including simple exceptions and DOMExceptions.
</p>

<p>
~IDLにおいて，定数 `Error$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant Error value in IDL.
</p>

<p>
`Error$T の`型~名$は、 `Error^l である。
◎
The type name of the Error type is “Error”.
</p>

			</section>
			<section id="idl-DOMException">
<h4 title="DOMException">2.11.29. `DOMException^T</h4>

<p>
`DOMException$T 型は、可能なすべての［
非 `null^V `~DOMException$
を表現する~obj参照
］の集合に対応する。
◎
The DOMException type corresponds to the set of all possible non-null references to objects representing DOMExceptions.
</p>

<p>
~IDLにおいて，定数 `DOMException$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant DOMException value in IDL.
</p>

<p>
`DOMException$T の`型~名$は、 `DOMException^l である。
◎
The type name of the DOMException type is “DOMException”.
</p>

			</section>
			<section id="idl-buffer-source-types">
<h4 title="Buffer source types">2.11.30. ~buffer~source型</h4>

<p>
可能なすべての［［［
~dataの~buffer, または［
~dataの~buffer上の~view
］］を表現する~obj
］への 非 `null^V 参照
］の集合に対応する，いくつかの型がある。
下の一覧に、それらの型, および それらが表現する［
~bufferまたは その~view
］の種類を挙げる。
◎
There are a number of types that correspond to sets of all possible non-null references to objects that represent a buffer of data or a view on to a buffer of data. The table below lists these types and the kind of buffer or view they represent.
</p>


<table id="matrix-buffer-sources">

<thead><tr><th>型◎Type
</th><th>~bufferの種類◎Kind of buffer
</th></tr></thead>

<tbody><tr><td>`ArrayBuffer@T
</td><td>
固定的な個数の~byteからなる~bufferへの~pointer（ `null^V もとり得る）を保持する~obj。
◎
An object that holds a pointer (which may be null) to a buffer of a fixed number of bytes

</td></tr><tr><td>`DataView@T
</td><td>
`ArrayBuffer$T への~viewであって、~bufferの中の，任意の~offsetに格納されている 整数／浮動小数点 値への~accessを可能にするもの。
◎
A view on to an ArrayBuffer that allows typed access to integers and floating point values stored at arbitrary offsets into the buffer

</td></tr><tr><td>`Int8Array@T,
`Int16Array@T,
`Int32Array@T
</td><td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの ２の補数による有符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of two’s complement signed integers of the given size in bits

</td></tr><tr><td>`Uint8Array@T,
`Uint16Array@T,
`Uint32Array@T
</td><td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの 無符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of unsigned integers of the given size in bits

</td></tr><tr><td>`Uint8ClampedArray@T
</td><td>
`ArrayBuffer$T への~viewであって、値を切詰める変換も伴われるような，［
8~bit無符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of unsigned 8 bit integers with clamped conversions

</td></tr><tr><td>`Float32Array@T,
`Float64Array@T
</td><td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの IEEE 754 浮動小数点数
］からなる配列を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of IEEE 754 floating point numbers of the given size in bits

</td></tr></tbody></table>

<p class="note">注記：
これらの型はすべて、~JSにて定義される~classに対応する。
◎
Note: These types all correspond to classes defined in ECMAScript.
</p>

<p>
これらのどの型についても：
◎
↓</p>

<ul>
	<li>
~IDLにおいて，その型の定数~値を表現する仕方は、ない。
◎
There is no way to represent a constant value of any of these types in IDL.
</li>
	<li>
その`型~名$は、その型~自身の名前である。
◎
The type name of all of these types is the name of the type itself.
</li>
</ul>

<p>
仕様の中の注釈文~levelにおいては、~IDL`~buffer~source型$は，単純に~objへの参照である。
仕様の注釈文にて，~buffer内の~byte列を 検分したり操作するときは、最初に，~buffer~sourceに保持されている~byte列の
<a id="dfn-get-buffer-source-copy">`参照／複製を取得-@</a>
する手続きを介さ~MUST。
仕様の注釈文では、その結果の~byte列への参照／複製を利用して，個々の~byte値を取得したり設定できる。
◎
At the specification prose level, IDL buffer source types are simply references to objects. To inspect or manipulate the bytes inside the buffer, specification prose must first either get a reference to the bytes held by the buffer source or get a copy of the bytes held by the buffer source. With a reference to the buffer source’s bytes, specification prose can get or set individual byte values using that reference.
</p>

<div class="advisement">
<p>
仕様において、［
~buffer~sourceに保持されている~byteへの参照を取得する
］ような ~textを書くときには、細心の注意を払う必要がある
— 下層の~dataは、予測し得ない時に作者や他の~APIにより，容易に変更され得るので。
改変されないような ~binary~dataの~chunkを得るために，演算~引数として~buffer~source型を利用する場合は、その演算を定義する注釈文の始めの方で，~buffer~sourceの~byte列の複製を取得することが、強く推奨される。
◎
Extreme care must be taken when writing specification text that gets a reference to the bytes held by a buffer source, as the underyling data can easily be changed by the script author or other APIs at unpredictable times. If you are using a buffer source type as an operation argument to obtain a chunk of binary data that will not be modified, it is strongly recommended to get a copy of the buffer source’s bytes at the beginning of the prose defining the operation.
</p><!-- underyling -->

<p>
~byte列の 参照／複製 を取得する明示的な注釈文を要することの意図は、仕様の査読者が，これらの~buffer~source型の利用に孕まれる問題を見つけ易くするためである。
◎
Requiring prose to explicitly get a reference to or copy of the bytes is intended to help specification reviewers look for problematic uses of these buffer source types.
</p></div>

<div class="note">
<p>注記：
~bufferを~~入力にとる~APIを設計するときは、 `ArrayBuffer$T や他の~view~型よりも `BufferSource^T ~typedefの利用が推奨される。
◎
When designing APIs that take a buffer, it is recommended to use the BufferSource typedef rather than ArrayBuffer or any of the view types.
</p>

<p>
~bufferを作成したり返す~APIを設計するときは、
`Uint8Array$T よりも `ArrayBuffer$T 型の利用が推奨される。
◎
When designing APIs that create and return a buffer, it is recommended to use the ArrayBuffer type rather than Uint8Array.
</p>
</div>

<p>
`切離された$ `ArrayBuffer$T ~objに対し，~buffer~sourceに保持されている~byte列の`参照／複製を取得-$しようと試みたときは、言語束縛~特有の方式で失敗することになる。
◎
Attempting to get a reference to or get a copy of the bytes held by a buffer source when the ArrayBuffer has been detached will fail in a language binding-specific manner.
</p>

<p class="note">注記：
~JS言語束縛において ~buffer~source型とのやりとりがどのように働くかについては、`es-buffer-source-types$secに。
◎
Note: See §3.2.24 Buffer source types below for how interacting with buffer source types works in the ECMAScript language binding.
</p>

<p class="issue">
これらの型や用語を利用する仕様~textの例を含ませる必要がある。
◎
We should include an example of specification text that uses these types and terms.
</p>


<div class="grammar">
-BufferRelatedType
</div>

			</section>
			<section id="idl-frozen-array">
<h4 title="Frozen array types — FrozenArray&lt;T&gt;">2.11.31. 凍結~配列~型 — ~FrozenArray_T</h4>

<p>
`凍結~配列~型@
— ~FrozenArray_T —
は、［［［
一連の［
改変できない，型 ~varT の値
］からなる，固定長の配列
］を保持する~obj
］への参照
］を値にとり得るような，~parameter化された型である。
◎
A frozen array type is a parameterized type whose values are references to objects that hold a fixed length array of unmodifiable values. The values in the array are of type T.
</p>

<p>
`~FrozenArray_T$ 値は参照である
— 値の~listであり，値渡しである`連列~型$と違って。
◎
Since FrozenArray&lt;T&gt; values are references, they are unlike sequence types, which are lists of values that are passed by value.
</p>

<p>
~IDLにおいて，定数~凍結~配列~値を表現する仕方は、ない。
◎
There is no way to represent a constant frozen array value in IDL.
</p>

<p>
凍結~配列~型の`型~名$は、［
%T の型~名,
文字列 `Array^l
］の連結である。
◎
The type name of a frozen array type is the concatenation of the type name for T and the string “Array”.
</p>

			</section>
		</section>
		<section id="idl-extended-attributes">
<h3 title="Extended attributes">2.12. 拡張属性</h3>


<p>
`拡張属性@
は、［
`定義$ ／ `~ifc~mb$ ／ `名前空間~mb$ ／ `辞書~mb$ ／ `演算$引数
］上に現れ得る <em>注釈</em> （ annotation ）であり，［
言語束縛がこれらの構成子をどう取扱うことになるか
］を制御するために利用される。
拡張属性は `ExtendedAttributeList$g により指定される。
それは、全体が角括弧で括られた，いくつかの `ExtendedAttribute$g からなる~comma区切りの~listである。
◎
An extended attribute is an annotation that can appear on definitions, interface members, namespace members, dictionary members, and operation arguments, and is used to control how language bindings will handle those constructs. Extended attributes are specified with an ExtendedAttributeList, which is a square bracket enclosed, comma separated list of ExtendedAttributes.
</p>

<p>
文法~記号 `ExtendedAttribute$g は，ほぼ任意の~tok並びに合致するが、この文書で定義される`拡張属性$は，より制約された構文のみを受容する。
`~IDL片$に~~現れるどの拡張属性も、次の表に示す文法~記号のいずれかへの合致により、それが属する（１つ以上の）形が決定される：
◎
The ExtendedAttribute grammar symbol matches nearly any sequence of tokens, however the extended attributes defined in this document only accept a more restricted syntax. Any extended attribute encountered in an IDL fragment is matched against the following six grammar symbols to determine which form (or forms) it is in:
</p>


<table><thead>
<tr><th>文法~記号◎Grammar symbol
</th><th>形◎Form
</th><th>例◎Example
</th></tr></thead><tbody>

<tr><td>`ExtendedAttributeNoArgs$g
</td><td>`引数をとらない@
◎
takes no arguments
</td><td>`[Replaceable]^c</td></tr>

<tr><td>`ExtendedAttributeArgList$g
</td><td>`引数~listを引数にとる@
◎
takes an argument list
</td><td>`[Constructor(double x, double y)]^c</td></tr>

<tr><td>`ExtendedAttributeNamedArgList$g
</td><td>`有名~引数~listを引数にとる@
◎
takes a named argument list
</td><td>`[NamedConstructor=Image(DOMString src)]^c</td></tr>

<tr><td>`ExtendedAttributeIdent$g
</td><td>`識別子を引数にとる@
◎
takes an identifier
</td><td>`[PutForwards=name]^c</td></tr>

<tr><td>`ExtendedAttributeIdentList$g
</td><td>`識別子~listを引数にとる@
◎
takes an identifier list
</td><td>`[Exposed=(Window,Worker)]^c</td></tr>

</tbody></table>

<p>
この仕様は、~JS言語束縛に適用し得る，種々の拡張属性を定義する。
それらについては
`es-extended-attributes$sec
にて述べる。
各~拡張属性~定義において、上に挙げたどの形が許容されるかについて言明される。
◎
This specification defines a number of extended attributes that are applicable to the ECMAScript language binding, which are described in §3.3 ECMAScript-specific extended attributes. Each extended attribute definition will state which of the above six forms are allowed.
</p>

<div class="grammar">
-ExtendedAttributeList
-ExtendedAttributes
-ExtendedAttribute
-ExtendedAttributeRest
-ExtendedAttributeInner
-Other
-OtherOrComma
-IdentifierList
-Identifiers
-ExtendedAttributeNoArgs
-ExtendedAttributeArgList
-ExtendedAttributeIdent
-ExtendedAttributeIdentList
-ExtendedAttributeNamedArgList
</div>

		</section>
	</section>
	<section id="ecmascript-binding">
<h2 title="ECMAScript binding">3. ~JS言語束縛</h2>


<p>
この節では、
`idl$sec
にて定義された~IDLで記される`定義$と
<cite>~JS言語~仕様 第 6 版</cite>
`ECMA-262$r
により定義される~JSの中の個々の構成子との対応を述べる。
◎
This section describes how definitions written with the IDL defined in §2 Interface definition language correspond to particular constructs in ECMAScript, as defined by the ECMAScript Language Specification 6th Edition [ECMA-262].
</p>

<p>
他から指定されない限り，この節で定義される各~objは：
</p>

<ul>
	<li>
<p >
ECMA-262 の
<a href="~TC39#sec-ordinary-object-internal-methods-and-internal-slots">9.1 節</a>,
<a href="~TC39#sec-built-in-function-objects-call-thisargument-argumentslist">9.3.1 節</a>
に記述される内部~prop を持つ。
指定がある場合は、次のうち１つ以上のものが，~exotic~objに対する規則に則って再定義される：
`Call^es,
`Set^es,
`DefineOwnProperty^es,
`GetOwnProperty^es,
`Delete^es,
`HasInstance^es
。
◎
Objects defined in this section have internal properties as described in ECMA-262 sections 9.1 and 9.3.1 unless otherwise specified, in which case one or more of the following are redefined in accordance with the rules for exotic objects: [[Call]], [[Set]], [[DefineOwnProperty]], [[GetOwnProperty]], [[Delete]] and [[HasInstance]].
</p>

<p>
他の仕様は、`~ifc$の~instanceである`~platform~obj$の内部~methの定義を上書きして~MAY。
◎
Other specifications may override the definitions of any internal method of a platform object that is an instance of an interface.
Warning
</p>

<p class="advisement">
内部~JS~obj~methを上書きすることは、低~levelの演算であり，~objの挙動を普通の~objから違えさせ得るので、この便宜性は，保安／互換性のために必要とされない限り，利用されるべきでない。
これは、
<a href="https://github.com/annevk/html-cross-origin-objects/">`Location^T ~obj と, 場合によっては `WindowProxy^T ~obj</a>
に利用されることが予期されている。
◎
As overriding internal ECMAScript object methods is a low level operation and can result in objects that behave differently from ordinary objects, this facility should not be used unless necessary for security or compatibility. The expectation is that this will be used for Location objects and possibly WindowProxy objects.
</p>

	</li>
	<li>
その `Extensible^es 内部~propの値は `true^v である。
◎
Unless otherwise specified, the [[Extensible]] internal property of objects defined in this section has the value true.
</li>
	<li>
その `Prototype^es 内部~propは
`Object^v 原型~objである。
◎
Unless otherwise specified, the [[Prototype]] internal property of objects defined in this section is the Object prototype object.
</li>
</ul>

<p>
この節にて述べる一部の~objは、
`~class文字列@
を持つものと定義される。
それは、 `Object.prototype.toString^c が返す文字列に内包される。
~class文字列を持つ~objは、その作成-時に，その指定された文字列を値にとる，名前 `toStringTag$esS ~symbolの~propを持た~MUST。
◎
Some objects described in this section are defined to have a class string, which is the string to include in the string returned from Object.prototype.toString. If an object has a class string, then the object must, at the time it is created, have a property whose name is the @@toStringTag symbol and whose value is the specified string.
</p>

<p class="issue">
`toStringTag$esS が
{ writable, enumerable, configurable }
かどうかを定義するべきである。
ES6 仕様における すべての `toStringTag$esS ~propは、非 writable かつ非 enumerable であり，非 configurable である。
◎
Should define whether @@toStringTag is writable, enumerable and configurable. All @@toStringTag properties in the ES6 spec are non-writable and non-enumerable, and configurable.
</p>

<p>
`関数~obj@
であるものと定義される~objは、次の特徴を有する：
◎
If an object is defined to be a function object, then it has characteristics as follows:
</p>

<ul>
	<li>
他から指定されない限り，その `Prototype^es 内部~propは
`FunctionPrototype$esI
である。
◎
Its [[Prototype]] internal property is %FunctionPrototype% unless otherwise specified.
</li>
	<li>
その `Get^es 内部~prop は
<a href="~TC39#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver">ECMA-262 9.1.8 節</a>
の記述に従って設定される。
◎
Its [[Get]] internal property is set as described in ECMA-262 section 9.1.8.
</li>
	<li>
その `Construct^es 内部~prop は
<a href="~TC39#sec-function-@@create">ECMA-262 19.2.2.3 節</a>
の記述に従って設定される。
◎
Its [[Construct]] internal property is set as described in ECMA-262 section 19.2.2.3.
</li>
	<li>
他から指定されない限り，その
<span class="prop">@@hasInstance</span>
内部~prop は
<a href="~TC39#sec-function.prototype-@@hasinstance">ECMA-262 19.2.3.8 節</a>
の記述に従って設定される。
◎
Its @@hasInstance property is set as described in ECMA-262 section 19.2.3.8, unless otherwise specified.
</li>
</ul>

<p class="issue">
上の~listは、最新の ES6 草案に沿うように更新する必要がある。
◎
The list above needs updating for the latest ES6 draft.
</p>

<p id="ecmascript-abstractop">
この節の中の~algoは、手続きとその下位手続き, 数学的演算, 等々の利用に関し，
<a href="~TC39#sec-algorithm-conventions">ECMA-262 Algorithm Conventions 節</a>
に記述されている表記規約を利用する。
この節で参照される抽象演算：
`ToBoolean$A,
`ToNumber$A,
`ToUint16$A,
`ToInt32$A,
`ToUint32$A,
`ToString$A,
`ToObject$A,
`IsAccessorDescriptor$A,
`IsDataDescriptor$A,
並びに
`Type^( %x ) 記法は、 ECMA-262 6, 7 節にて定義される。
◎
Algorithms in this section use the conventions described in ECMA-262 section 5.2, such as the use of steps and substeps, the use of mathematical operations, and so on. The ToBoolean, ToNumber, ToUint16, ToInt32, ToUint32, ToString, ToObject, IsAccessorDescriptor and IsDataDescriptor abstract operations and the Type(x) notation referenced in this section are defined in ECMA-262 sections 6 and 7.
</p>

<p>
~algoにおいて
“<dfn id="ecmascript-throw"><b>THROW</b></dfn> `SomethingError^t”
と記される所では、 ECMA-262 の~algoとちょうど同じ様に，新たな~JS `SomethingError^t ~objを構築して投出することを意味する。<!--  -->
◎
When an algorithm says to throw a SomethingError then this means to construct a new ECMAScript SomethingError object and to throw it, just as the algorithms in ECMA-262 do.
</p>

<p>
~algoの手続きは，他の~algoや抽象演算の中へ~callし得るが、それらから投出される例外は
<a href="#_try-catch_">明示的に取扱われ</a>ていないことに注意。
~algoまたは抽象演算により例外が投出され，それが~call元により明示的に取扱われない所では、~algoは終了され，その~call元の更に外へ伝播する，等々となる。
◎
Note that algorithm steps can call in to other algorithms and abstract operations and not explicitly handle exceptions that are thrown from them. When an exception is thrown by an algorithm or abstract operation and it is not explicitly handled by the caller, then it is taken to end the algorithm and propagate out to its caller, and so on.
</p>

<div class="example">
<p>
次の~algoを考える：
◎
Consider the following algorithm:
</p>

<ol class="algorithm">
	<li>
%x := この~algoに渡された~JS値
◎
Let x be the ECMAScript value passed in to this algorithm.
</li>
	<li>
%y := `ToString$A( %x )
◎
Let y be the result of calling ToString(x).
</li>
	<li>
~RET %y
◎
Return y.
</li>
</ol>

<p>
`ToString$A は例外を投出し得るが（例えば~obj
`({ toString: function() { throw 1 } })^c
が渡されたとき），例外は上の~algoでは取扱われないので、もし投出された場合、この~algoは終了され，その例外は ~call元が在るならばその~call元に伝播する。
◎
Since ToString can throw an exception (for example if passed the object ({ toString: function() { throw 1 } })), and the exception is not handled in the above algorithm, if one is thrown then it causes this algorithm to end and for the exception to propagate out to its caller, if there is one.
</p>
</div>


		<section id="es-environment">
<h3 title="ECMAScript environment">3.1. ~JS環境</h3>

<p>
所与の［
`~IDL片$の集合
］に対する~JS実装においては、それらの`~IDL片$の中の それぞれの定義に対応する，~JS~objが存在することになる。
これらの~objは
`初期~obj@
と呼ばれ、次のものからなる：
◎
In an ECMAScript implementation of a given set of IDL fragments, there will exist a number of ECMAScript objects that correspond to definitions in those IDL fragments. These objects are termed the initial objects, and comprise the following:
</p>
<ul>
	<li>
`~ifc~obj$
◎
interface objects
</li>
	<li>
`有名~構築子$
◎
named constructors
</li>
	<li>
`~ifc原型~obj$
◎
interface prototype objects
</li>
	<li>
`有名~prop~obj$
◎
named properties objects
</li>
	<li>
`反復子~原型~obj$
◎
iterator prototype objects
</li>
	<li>
`属性~取得子$
◎
attribute getters
</li>
	<li>
`属性~設定子$
◎
attribute setters
</li>
	<li>
<a href="#es-operations">演算</a>
に対応する `Function^t ~obj
◎
the Function objects that correspond to operations
</li>
	<li>
<a href="#es-stringifier">文字列化子</a>
に対応する `Function^t ~obj
<!-- es-stringifier -->
◎
the Function objects that correspond to stringifiers
</li>
	<li>
<a href="#es-serializer">直列化子</a>
に対応する `Function^t ~obj
◎
the Function objects that correspond to serializers
</li>
	<li>
<a href="#es-iterator">反復子</a>
に対応する `Function^t ~obj
◎
the Function objects that correspond to iterators
</li>
	<li class="L2">
`~map~size取得子$
◎
map size getters
</li>
	<li>
`~DOMException構築子~obj$
◎
DOMException constructor objects
</li>
	<li>
`~DOMException原型~obj$
◎
DOMException prototype objects
</li>
</ul>

<p>
各
<a href="~TC39#sec-code-realms">~JS大域環境</a>
は、それぞれに一意な［
各種`初期~obj$からなる集合
］を持た~MUST。
この集合は、［
その環境のための大域~objが作成された後, かつ
その環境に結付けられている~JS実行~文脈に制御が移る前
］に作成され~MUST。
所与の大域環境に属する すべての初期~objに対し、その `Prototype^es は，同じ大域環境に属してい~MUST。
◎
Each ECMAScript global environment must have its own unique set of each of the initial objects, created before control enters any ECMAScript execution context associated with the environment, but after the global object for that environment is created. The [[Prototype]]s of all initial objects in a given global environment must come from that same global environment.
</p>

<p class="trans-note">【
<!-- 
objet’s global environment ／ global environment associated with an objet
-->
上の “大域環境に属する” という句は、所与の~objが同時に複数の大域環境に <em >属する</em> ことは，決してないことを含意する。
】</p>

<div class="example">
<p>
HTML ~UAにおいては、複数の frame や window が作成されたときに，複数の大域環境が存在し得る。
frame や window のそれぞれは、自身の`初期~obj$の集合を持つことになる。
次の HTML 文書の例のように：
◎
In an HTML user agent, multiple global environments can exist when multiple frames or windows are created. Each frame or window will have its own set of initial objects, which the following HTML document demonstrates:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;title&gt;Different global environments&lt;/title&gt;
&lt;iframe id=a&gt;&lt;/iframe&gt;
&lt;script&gt;
var iframe = document.getElementById("a");
var w = iframe.contentWindow;     // <span class="comment"
	title="The global object in the frame"
>frame 内の大域~obj</span>

Object == w.Object;       // <span class="comment"
	title="Evaluates to false, per ECMA-262"
>ECMA-262 に則り， `false^v に評価される</span>
Node == w.Node;                            // <span class="comment"
	title="Evaluates to false." id="cp-eval-false"
>`false^v に評価される。</span>
iframe instanceof w.Node;                  // <!--cp-eval-false-->
iframe instanceof w.Object;                // <!--cp-eval-false-->
iframe.appendChild instanceof Function;    // <!--cp-eval-true-->
iframe.appendChild instanceof w.Function;  // <!--cp-eval-false-->
&lt;/script&gt;
</pre>
</div>

<p>
他から指定されない限り、各~JS大域環境は，実装が~supportする すべての`~ifc$を
`公開する@
。
所与の~JS大域環境が公開しない~ifcは，
`es-interfaces$secにて与える要件に従うとは限らない。
◎
Unless otherwise specified, each ECMAScript global environment exposes all interfaces that the implementation supports. If a given ECMAScript global environment does not expose an interface, then the requirements given in §3.6 Interfaces are not followed for that interface.
</p>

<p class="note">注記：
これにより，例えば、［
~Web Workers のための~JS大域環境
］が`公開する$［
被support~ifcの集合
］を，［
~Web~pageのための環境
］が公開するものと異なるようにすることも許容される。
◎
Note: This allows, for example, ECMAScript global environments for Web Workers to expose different sets of supported interfaces from those exposed in environments for Web pages.
</p>


<div class="p">
<p>
これを書いている時点では，~JS仕様は それを反映していないが、どの~JS~objにも`~Realm$が結付けられ~MUST
— この~Realmを指して， ~objが
`属する~Realm@†
という。
</p>

<p class="trans-note">【†
日本語表現の都合により，この訳では “属する” という句を用いることにする。
】</p>

<p>
各~objと~Realmを結付ける仕組みは、今の所，策定中にあるが：
</p>
<ul>
	<li>
`~platform~obj$については、それが`属する~Realm$は，その~objに`関連する~Realm$に等しい。
</li>
	<li>
非~exotic関数~obj（すなわち，~callable~proxyでも~bindされた関数でもない）についても、それが`属する~Realm$は，その関数~objの `Realm^es 内部~slotの値に等しい。
</li>
</ul>

◎
Although at the time of this writing the ECMAScript specification does not reflect this, every ECMAScript object must have an associated Realm. The mechanisms for associating objects with Realms are, for now, underspecified. However, we note that in the case of platform objects, the associated Realm is equal to the object’s relevant Realm, and for non-exotic function objects (i.e. not callable proxies, and not bound functions) the associated Realm is equal to the value of the function object’s [[Realm]] internal slot.
</div>


		</section>
		<section id="es-type-mapping">
<h3 title="ECMAScript type mapping">3.2. ~JS型との対応関係</h3>


<p>
この節では、~IDLにおける各~型が，~JSにおける型と どのように~~対応付けられるかについて述べる。
◎
This section describes how types in the IDL map to types in ECMAScript.
</p>

<p>
以下の各~下位~節では、所与の［
~IDL型の値
］が，~JSの中ではどのように表現されるかを述べる。
各種~IDL型に対し、その型を期待する`~platform~obj$に~JS値が渡された際に
<dfn id="dfn-convert-ecmascript-to-idl-value">~IDL値へ変換される</dfn>
方法, および
その型の~IDL値が~platform~objから返される際に
<dfn id="dfn-convert-idl-to-ecmascript-value">~JS値へ変換される</dfn>
方法が述べられる。
◎
Each sub-section below describes how values of a given IDL type are represented in ECMAScript. For each IDL type, it is described how ECMAScript values are converted to an IDL value when passed to a platform object expecting that type, and how IDL values of that type are converted to ECMAScript values when returned from a platform object.
</p>

			<section id="es-any">
<h4 title="any">3.2.1. `any^T</h4>


<p>
~IDL `any$T 型は、他のすべての~IDL型の和集合なので，どの~JS値~型にも対応し得る。
◎
Since the IDL any type is the union of all other IDL types, it can correspond to any ECMAScript value type.
</p>

<p id="es-to-any">
~JS値から~IDL `any$T 値への`toIDL^は、
~JS値の型に応じて次のようになる：
◎
How to convert an ECMAScript value to an IDL any value depends on the type of the ECMAScript value:
</p>

<dl class="switch">
	<dt>`undefined^v◎The undefined value</dt>
	<dd>
~JS `undefined^v 値を表現する特別な~objへの `object$T 参照
◎
The IDL value is an object reference to a special object that represents the ECMAScript undefined value.
</dd>

	<dt>`null^v◎The null value</dt>
	<dd>
`null^V `object$T​? 参照<!--  -->
◎
The IDL value is the null object? reference.
</dd>

	<dt>`Boolean^t◎A Boolean value</dt>
	<dd>
同じ真偽~値を表現する `boolean$T 値
◎
The IDL value is the boolean value that represents the same truth value.
</dd>

	<dt>`Number^t◎A Number value</dt>
	<dd>
`es-unrestricted-double$sec
による，［
`Number^t から~IDL `unrestricted double$T 値への変換-規則
］に従って得られる値
◎
The IDL value is that which is obtained by following the rules for converting the Number to an IDL unrestricted double value, as described in §3.2.8 unrestricted double.
</dd>

	<dt>`String^t◎A String value</dt>
	<dd>
`es-DOMString$sec
による，［
`String^v から `DOMString$T 値への変換-規則
］に従って得られる値
◎
The IDL value is that which is obtained by following the rules for converting the String to an IDL DOMString value, as described in §3.2.9 DOMString.
</dd>

	<dt>`object^t◎An object value</dt>
	<dd>
同じ~objを参照する `object$T 値
◎
The IDL value is an object value that references the same object.
</dd>

</dl>

<div class="p">
<p id="any-to-es">
~IDL `any$T 値 %V は，次のように~JS値へ`toES^される：
</p>

<ul><li>%V が［
~JS `undefined^v 値を表現する特別な~objへの `object$T 参照
］ならば、~JS `undefined^v 値に変換される。
</li><li>他の場合、この節の残りで述べられる， %V の`固有型$を変換するための規則に従う。
</li></ul>

◎
An IDL any value is converted to an ECMAScript value as follows. If the value is an object reference to a special object that represents an ECMAScript undefined value, then it is converted to the ECMAScript undefined value. Otherwise, the rules for converting the specific type of the IDL any value as described in the remainder of this section are performed.
</div>

			</section>
			<section id="es-void">
<h4 title="void">3.2.2. `void^T</h4>


<p>
`void$T が~IDLに現れ得る唯一の場所は、`演算$の`返値型$である。
［
~IDLにおいて `void$T 返値型が指定されている演算
］を実装する［
`~platform~obj$上の関数
］は、 `undefined^v 値を返さ~MUST。
<!-- % ` Function -->
◎
The only place that the void type may appear in IDL is as the return type of an operation. Functions on platform objects that implement an operation whose IDL specifies a void return type must return the undefined value.
</p>

<p>
［
~IDLにおいて `void$T 返値型が指定されている演算
］を実装する~JS関数は、どのような値を返しても~MAY（破棄されることになる）。
◎
ECMAScript functions that implement an operation whose IDL specifies a void return type may return any value, which will be discarded.
</p>
			</section>
			<section id="es-boolean">
<h4 title="boolean">3.2.3. `boolean^T</h4>


<p id="es-to-boolean">
次の~algoにより，
~JS値 %V は~IDL `boolean$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL boolean value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%x := `ToBoolean$A( %V ) の算出-結果
◎
Let x be the result of computing ToBoolean(V).
</li>
	<li>
~RET ［
~JS `Boolean^t 値 %x
］と同じ真偽~値を表現する~IDL `boolean$T 値
◎
Return the IDL boolean value that is the one that represents the same truth value as the ECMAScript Boolean value x.
</li>
</ol>

<p id="boolean-to-es">
~IDL `boolean$T 値［
`true^V／`false^V
］は，~JS［
`true^v／`false^v
］値に`toES^される。
◎
The IDL boolean value true is converted to the ECMAScript true value and the IDL boolean value false is converted to the ECMAScript false value.
</p>


			</section>
			<section id="es-integer-types">
<h4>3.2.4. 整数~型</h4>

<p class="trans-note">【
この訳では、原文の次に挙げる各~節の内容
— ~JS値 から各種~IDL整数~型 値への変換, およびその逆の変換の定義 —
を集約して，一括して与える。
】</p>

<dl>
	<dt id="es-byte">3.2.4.1. `byte^T</dt>
	<dt id="es-octet">3.2.4.2. `octet^T</dt>
	<dt id="es-short">3.2.4.3. `short^T</dt>
	<dt id="es-unsigned-short">3.2.4.4. `unsigned short^T</dt>
	<dt id="es-long">3.2.4.5. `long^T</dt>
	<dt id="es-unsigned-long">3.2.4.6. `unsigned long^T</dt>
	<dt id="es-long-long">3.2.4.7. `long long^T</dt>
	<dt id="es-unsigned-long-long">3.2.4.8. `unsigned long long^T</dt>
	<dd></dd>
</dl>

<p>
<a id="es-to-byte"></a
><a id="es-to-octet"></a
><a id="es-to-short"></a
><a id="es-to-unsigned-short"></a
><a id="es-to-long"></a
><a id="es-to-unsigned-long"></a
><a id="es-to-long-long"></a
><a id="es-to-unsigned-long-long"></a>
次の~algoにより，~JS値 %V は~IDL`整数~型$ %T の値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL _T_ value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%x := ? `ConvertToInt$( %V, %T )
◎
Let x be ? ConvertToInt(V, _N_, "signed|unsigned").
</li>
	<li>
~RET %x と同じ実数~値を表現する，型 %T の~IDL値
◎
Return the IDL _T_ value that represents the same numeric value as x.
</li>
</ol>

<p>
<a id="byte-to-es"></a
><a id="octet-to-es"></a
><a id="short-to-es"></a
><a id="unsigned-short-to-es"></a
><a id="long-to-es"></a
><a id="unsigned-long-to-es"></a
><a id="long-long-to-es"></a
><a id="unsigned-long-long-to-es"></a>
~IDL`整数~型$ %T の値 %V を~JS値に`toES^した結果は， %T に応じて次で与えられる：
◎
The result of converting an IDL _T_ value to an ECMAScript value is a ...
</p>

<dl class="switch">
	<dt>`long long$T</dt>
	<dt>`unsigned long long$T</dt>
	<dd id="_int-toES_">
%V に`最近数値^を表現する `Number^t 値。
%V が範囲 [%MIN, %MAX] に入るならば、その値 は %V と正確に同じ値を表現できることになる。
◎
The result of converting an IDL _T_ value to an ECMAScript value is a Number value that represents the closest numeric value to the _T_, choosing the numeric value with an even significand if there are two equally close values. If the _T_ is in the range [_MIN_, _MAX_], then the Number will be able to represent exactly the same value as the _T_.
</dd>

	<dt>他の整数~型</dt>
	<dd>
%V と同じ実数~値を表現する `Number^t 値。
その値は 範囲 [%MIN, %MAX] の整数になる。
◎
Number that represents the same numeric value as the IDL _T_ value. The Number value will be an integer in the range [_MIN_, _MAX_].
</dd>

</dl>


				<section id="es-integer-types-abstract-ops">
<h5 title="Abstract operations">3.2.4.9. 抽象演算</h5>

<p>
`IntegerPart@( %n )：
◎
IntegerPart(n)：
</p>

<ol class="algorithm">
	<li>
%r :=
<a href="~TC39#sec-algorithm-conventions">floor</a>(
<a href="~TC39#sec-algorithm-conventions">abs</a>( %n ) )
◎
Let r be floor(abs(n))
</li>
	<li>
~IF
%n ~LT 0
~THEN
~RET −1 × %r
◎
If n &lt; 0, then return -1 × r.
</li>
	<li>
~RET %r
◎
Otherwise, return r.
</li>
</ol>

<p>
`ConvertToInt@( %V, %T )
◎
ConvertToInt(V, bitLength, signedness):
</p>

<ol class="algorithm">
	<li>
<p>
( %MIN, %MAX, %N, %signed ) :=
%T に応じて，次の表で与えられる値：
</p>

<table id="matrix-integers">

<thead><tr><th>%T
</th><th>%N
</th><th>%MIN
</th><th>%MAX
</th><th>%signed
</th></tr></thead>

<tbody><tr><th>`byte$T
</th><td>8
</td><td>−2`7^sup
</td><td>2`7^sup − 1
</td><td>~T

</td></tr><tr><th>`octet$T
</th><td>8
</td><td>0
</td><td>2`8^sup − 1
</td><td>~F

</td></tr><tr><th>`short$T
</th><td>16
</td><td>−2`15^sup
</td><td>2`15^sup − 1
</td><td>~T

</td></tr><tr><th>`unsigned short$T
</th><td>16
</td><td>0
</td><td>2`16^sup − 1
</td><td>~F

</td></tr><tr><th>`long$T
</th><td>32
</td><td>−2`31^sup
</td><td>2`31^sup − 1
</td><td>~T

</td></tr><tr><th>`unsigned long$T
</th><td>32
</td><td>0
</td><td>2`32^sup − 1
</td><td>~F

</td></tr><tr><th>`long long$T
</th><td>64
</td><td>−2`53^sup + 1
</td><td>2`53^sup − 1
</td><td>~T

</td></tr><tr><th>`unsigned long long$T
</th><td>64
</td><td>0
</td><td>2`53^sup − 1
</td><td>~F

</td></tr></tbody></table>

<p class="note">注記：
`long long^T, `unsigned long long^T の
%MIN, %MAX
を 2 の 53 乗で~~制限しているのは、［
`EnforceRange$x ／ `Clamp$x
］注釈付きの `long long$T 型を，一義的に~JSの
<a href="~TC39#sec-ecmascript-language-types-number-type">Number 型</a>
整数として表現できることを確保するためである。
</p>
◎
If bitLength is 64, then:
• Let upperBound be 253 − 1.
• If signedness is "unsigned", then let lowerBound be 0.
• Otherwise let lowerBound be −253 + 1.
◎
Note: this ensures long long types annotated with [EnforceRange] or [Clamp] extended attributes are representable in ECMAScript’s Number type as unambiguous integers.
◎
Otherwise, if signedness is "unsigned", then:
• Let lowerBound be 0.
• Let upperBound be 2bitLength − 1.
◎
Otherwise:
• Let lowerBound be -2bitLength − 1.
• Let upperBound be 2bitLength − 1 − 1.
</li>
	<li>
%x :← ? `ToNumber$A( %V )
◎
Set x to ? ToNumber(V).
</li>
	<li>
<p>
~IF
~IDL値への変換は，
`EnforceRange$x 注釈付きの［
`属性$に代入される／
`演算$の引数に渡される／
`辞書~mb$の値に利用される
］ことにより遂行されている
⇒
◎
If the conversion to an IDL value is being performed due to any of the following:
• V is being assigned to an attribute annotated with the [EnforceRange] extended attribute,
• V is being passed as an operation argument annotated with the [EnforceRange] extended attribute, or
• V is being used as the value of a dictionary member annotated with the [EnforceRange] extended attribute,
then:
</p>
		<ol>
			<li id="cp-x-isNonFinite">
~IF
%x ~IN { `NaN^v, +∞, −∞ }
~THEN
~THROW `TypeError^t
◎
If x is NaN, +∞, or −∞, then throw a TypeError.
</li>
			<li id="cp-floor_x">
%x ← ! `IntegerPart$( %x )
◎
Set x to ! IntegerPart(x).
</li>
			<li>
~IF［
%x ~LT %MIN
］~OR［
%x ~GT %MAX
］
~THEN
~THROW `TypeError^t
◎
If x &lt; lowerBound or x &gt; upperBound, then throw a TypeError.
</li>
			<li>
~RET %x
◎
Return x.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%x ~NEQ `NaN^v
］~AND［
~IDL値への変換は，
`Clamp$x 注釈付きの［
`属性$に代入される／
`演算$の引数に渡される／
`辞書~mb$の値に利用される
］ことにより遂行されている
］
⇒
◎
If x is not NaN and the conversion to an IDL value is being performed due to any of the following:
• V is being assigned to an attribute annotated with the [Clamp] extended attribute,
• V is being passed as an operation argument annotated with the [Clamp] extended attribute, or
• V is being used as the value of a dictionary member annotated with the [Clamp] extended attribute,
then:
</p>

		<ol>
			<li>
%x ← <a href="~TC39#sec-algorithm-conventions" >min</a>(
<a href="~TC39#sec-algorithm-conventions" >max</a>(
%x, %MIN ), %MAX)
◎
Set x to min(max(x, lowerBound), upperBound).
</li>
			<li>
~RET %x を最も近い整数に丸めた結果（２つの整数と等距離にある場合は偶数を選び，−0 より +0 の方を選ぶ）
◎
Round x to the nearest integer, choosing the even integer if it lies halfway between two, and choosing +0 rather than −0.
</li>
			<li>
~RET %x
◎
Return x.
</li>
		</ol>
	</li>
	<li>
~IF
%x ~IN { `NaN^v, +0, −0, +∞, −∞ }
~THEN
~RET 0
◎
If x is NaN, +0, −0, +∞, or −∞, then return 0.
</li>
	<!--cp-floor_x-->
	<li>
%x ← %x
<a href="~TC39#sec-algorithm-conventions">modulo</a>
2<sup>%N</sup>
◎
Set x to x modulo 2bitLength.
</li>
	<li>
~IF［
%signed ~EQ ~T
］~AND［
%x  ~GTE 2<sup>%N − 1</sup>
］
~THEN
~RET %x − 2<sup>%N</sup>
◎
If signedness is "signed" and x ≥ 2bitLength − 1, then return x − 2bitLength.
</li>
	<li>
~RET %x
◎
Otherwise, return x.
</li>
</ol>

				</section>
			</section>
			<section id="es-float">
<h4 title="float">3.2.5. `float^T</h4>


<p id="es-to-float">
次の~algoにより，
~JS値 %V は~IDL `float$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL float value by running the following algorithm:
</p>

<ol class="algorithm">
	<li id="cp-ToNumber">
%x := ? `ToNumber$A( %V )
◎
Let x be ? ToNumber(V).
</li>
	<!--cp-x-isNonFinite-->
	<li id="cp-let-S-to754">
%S := ［
−0 を除く有限 IEEE 754 単精度 浮動小数点~値の集合に，２つの特別な値{ 2`128^sup, −2`128^sup }
を追加した集合
］
◎
Let S be the set of finite IEEE 754 single-precision floating point values except −0, but with two special values added: 2^128 and −2^128.
</li>
	<li id="cp-round-x-to-y">
%y := ［ %S の中で %x に`最近数値^ ］
（この目的においては，２つの特別な値 2`128^sup, −2`128^sup の仮数は偶数と見なされる。）
◎
Let y be the number in S that is closest to x, selecting the number with an even significand if there are two equally close values. (The two special values 2^128 and −2^128 are considered to have even significands for this purpose.)
</li>
	<li>
~IF
%y ~IN { 2`128^sup, −2`128^sup }
~THEN
~THROW `TypeError^t
◎
If y is 2^128 or −2^128, then throw a TypeError.
</li>
	<li id="cp-if-y-0-x-lt0">
~IF［
%y ~EQ +0
］~AND［
%x ~LT 0
］
~THEN
~RET −0
◎
If y is +0 and x is negative, return −0.
</li>
	<li id="cp-ret-y">
~RET %y
◎
Return y.
</li>
</ol>

<p id="float-to-es">
~IDL `float$T 値を~JS値に`toES^した結果は、その
~IDL値と同じ実数~値を表現する `Number^t 値になる。
◎
The result of converting an IDL float value to an ECMAScript value is the Number value that represents the same numeric value as the IDL float value.
</p>
			</section>
			<section id="es-unrestricted-float">
<h4 title="unrestricted float">3.2.6. `unrestricted float^T</h4>


<p id="es-to-unrestricted-float">
次の~algoにより，
~JS値 %V は~IDL `unrestricted float$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL unrestricted float value by running the following algorithm:
</p>

<ol class="algorithm">
	<!--cp-ToNumber-->
	<li>
~IF
%x ~EQ `NaN^v
~THEN
~RET ~bit~pattern 0x7fc00000 の IEEE 754 NaN 値 `IEEE-754$r を表現する~IDL `unrestricted float$T 値
◎
If x is NaN, then return the IDL unrestricted float value that represents the IEEE 754 NaN value with the bit pattern 0x7fc00000 [IEEE-754].
</li>
	<!--cp-let-S-to754-->
	<!--cp-round-x-to-y-->
	<li>
~IF
%y ~EQ 2`128^sup
~THEN
~RET +∞
◎
If y is 2^128, return +∞.
</li>
	<li>
~IF
%y ~EQ −2`128^sup 
~THEN
~RET −∞
◎
If y is −2^128, return −∞.
</li>
	<!--cp-if-y-0-x-lt0-->
	<!--cp-ret-y-->
</ol>

<p class="note">注記：
~JS `NaN^v 値は唯１個しかないので，特定0の単精度 IEEE 754 NaN 値に正準化されなければならない。
上に示された NaN 値は、単純に，その~bit~patternが無符号 32 ~bit整数に解釈されたときに最低~値の quiet NaN になることから，選ばれている。
◎
Note: Since there is only a single ECMAScript NaN value, it must be canonicalized to a particular single precision IEEE 754 NaN value. The NaN value mentioned above is chosen simply because it is the quiet NaN with the lowest value when its bit pattern is interpreted as an unsigned 32 bit integer.
</p>

<p id="unrestricted-float-to-es">
~IDL `unrestricted float$T 値を~JS値に`toES^した結果は、次の `Number^t になる：
◎
The result of converting an IDL unrestricted float value to an ECMAScript value is a Number:
</p>

<ol>
	<li>
その~IDL値 ~EQ NaN ならば `NaN^v
◎
If the IDL unrestricted float value is a NaN, then the Number value is NaN.
</li>
	<li>
他の場合，その~IDL値と同じ実数~値を表現する（~~唯一の） `Number^t 値。
◎
Otherwise, the Number value is the one that represents the same numeric value as the IDL unrestricted float value.
</li>
</ol>
			</section>
			<section id="es-double">
<h4 title="double">3.2.7. `double^T</h4>


<p id="es-to-double">
次の~algoにより，
~JS値 %V は~IDL `double$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL double value by running the following algorithm:
</p>

<ol class="algorithm">
	<!--cp-ToNumber-->
	<!--cp-x-isNonFinite-->
	<li>
~RET %x と同じ実数~値を持つ~IDL `double$T 値
◎
Return the IDL double value that has the same numeric value as x.
</li>
</ol>

<p id="double-to-es">
~IDL `double$T 値を~JS値に`toES^した結果は、その
~IDL値と同じ実数~値を表現する `Number^t 値になる。
◎
The result of converting an IDL double value to an ECMAScript value is the Number value that represents the same numeric value as the IDL double value.
</p>
			</section>
			<section id="es-unrestricted-double">
<h4 title="unrestricted double">3.2.8. `unrestricted double^T</h4>


<p id="es-to-unrestricted-double">
次の~algoにより，
~JS値 %V は~IDL `unrestricted double$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL unrestricted double value by running the following algorithm:
</p>

<ol class="algorithm">
	<!--cp-ToNumber-->
	<li>
~IF
%x ~EQ `NaN^v
~THEN
~RET ~bit~pattern 0x7ff8000000000000 の IEEE 754 NaN 値 `IEEE-754$r を表現する~IDL `unrestricted double$T 値
◎
If x is NaN, then return the IDL unrestricted double value that represents the IEEE 754 NaN value with the bit pattern 0x7ff8000000000000 [IEEE-754].
</li>
	<li>
~RET %x と同じ実数~値を持つ~IDL `unrestricted double$T 値
◎
Return the IDL unrestricted double value that has the same numeric value as x.
</li>
</ol>

<p class="note">注記：
~JS `NaN^v 値は唯１個しかないので，特定0の倍精度 IEEE 754 NaN 値に正準化されなければならない。
上に示された NaN 値は、単純に，その~bit~patternが無符号 64 ~bit整数に解釈されたときに最低~値の quiet NaN になることから，選ばれている。
◎
Note: Since there is only a single ECMAScript NaN value, it must be canonicalized to a particular double precision IEEE 754 NaN value. The NaN value mentioned above is chosen simply because it is the quiet NaN with the lowest value when its bit pattern is interpreted as an unsigned 64 bit integer.
</p>

<p id="unrestricted-double-to-es">
~IDL `unrestricted double$T 値を~JS値に`toES^した結果は、次の `Number^t になる：
◎
The result of converting an IDL unrestricted double value to an ECMAScript value is a Number:
</p>

<ol>
	<li>
その~IDL値 ~EQ NaN ならば `NaN^v 。
◎
If the IDL unrestricted double value is a NaN, then the Number value is NaN.
</li>
	<li>
他の場合，その~IDL値と同じ実数~値を表現する（~~唯一の） `Number^t 値。
◎
Otherwise, the Number value is the one that represents the same numeric value as the IDL unrestricted double value.
</li>
</ol>
			</section>
			<section id="es-DOMString">
<h4 title="DOMString">3.2.9. `DOMString^T</h4>


<p id="es-to-DOMString">
次の~algoにより，
~JS値 %V は~IDL `DOMString$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL DOMString value by running the following algorithm:
</p>


<ol class="algorithm">
	<li><!-- copy* -->
~IF［
%V ~EQ `null^v
］~AND［
~IDL値への変換は， `TreatNullAs$x 注釈付きの［
`演算$の引数に渡される ／
`属性$に代入される ／
演算の`利用者~obj$実装から返される ／
属性の`利用者~obj$実装から返される
］ことにより遂行されている
］
~THEN
~RET 空~文字列を表現する `DOMString$T 値
◎
If V is null and the conversion to an IDL value is being performed due to any of the following:
• V is being passed as an operation argument that is annotated with [TreatNullAs],
• V is being assigned to an attribute annotated with [TreatNullAs],
• V is being returned from a user object implementation of an operation annotated with [TreatNullAs], or
• V is being returned from a user object implementation of an attribute annotated with [TreatNullAs],
◎
then return the DOMString value that represents the empty string.
</li>
	<li>
%x := `ToString$A( %V )
◎
Let x be ToString(V).
</li>
	<li>
~RET ［
その~JS `String^t 値 %x が表現するものと同じ，符号単位の並び
］を表現する~IDL `DOMString$T 値
◎
Return the IDL DOMString value that represents the same sequence of code units as the one the ECMAScript String value x represents.
</li>
</ol>

<p id="DOMString-to-es">
~IDL `DOMString$T 値を~JS値に`toES^した結果は、
その~IDL `DOMString$T が表現するものと同じ,
`符号単位$の並びを表現する `String^t 値になる。
◎
The result of converting an IDL DOMString value to an ECMAScript value is the String value that represents the same sequence of code units that the IDL DOMString represents.
</p>
			</section>
			<section id="es-ByteString">
<h4 title="ByteString">3.2.10. `ByteString^T</h4>

<p id="es-to-ByteString">
次の~algoにより，
~JS値 %V は~IDL `ByteString$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL ByteString value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%x := `ToString$A( %V )
◎
Let x be ToString(V).
</li>
	<li>
~IF
%x の中に 値 ~GT 255 なる
<a href="~TC39#sec-ecmascript-language-types-string-type">要素</a>
がある
~THEN
~THROW `TypeError^t
◎
If the value of any element of x is greater than 255, then throw a TypeError.
</li>
	<li>
~RET ［［
各~要素の値 ← %x の対応する要素の値
］にされた，
長さ ~EQ %x の長さ
］の~IDL `ByteString$T 値
◎
Return an IDL ByteString value whose length is the length of x, and where the value of each element is the value of the corresponding element of x.
</li>
</ol>

<p id="ByteString-to-es">
~IDL `ByteString$T 値 %V を~JS値に`toES^した結果は、［［
各~要素の値 ← %V の対応する要素の値
］にされた,
長さ ~EQ %V の長さ
］の `String^t 値になる。
◎
The result of converting an IDL ByteString value to an ECMAScript value is a String value whose length is the length of the ByteString, and the value of each element of which is the value of the corresponding element of the ByteString.
</p>

			</section>
			<section id="es-USVString">
<h4 title="USVString">3.2.11. `USVString^T</h4>

<p id="es-to-USVString">
次の~algoにより，
~JS値 %V は~IDL `USVString$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL USVString value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%string :=  %V を `DOMString$T に`toIDL^した結果
◎
Let string be the result of converting V to a DOMString.
</li>
	<li>
~RET
%string を `~Unicode~scalar値~列に変換-$した結果の~IDL `USVString$T 値
◎
Return an IDL USVString value that is the result of converting string to a sequence of Unicode scalar values.
</li>
</ol>

<p id="USVString-to-es">
次の~algoにより，
~IDL `USVString$T 値 %V は~JS値に`toES^される：
◎
An IDL USVString value is converted to an ECMAScript value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%scalarValues := `USVString$T が表現する`~Unicode~scalar値$の並び
◎
Let scalarValues be the sequence of Unicode scalar values the USVString represents.
</li>
	<li>
%string := %scalarValues を UTF-16 に符号化した結果の`符号単位$の並び
◎
Let string be the sequence of code units that results from encoding scalarValues in UTF-16.
</li>
	<li>
~RET
%string と同じ`符号単位$の並びを表現する `String^t 値
◎
Return the String value that represents the same sequence of code units as string.
</li>
</ol>


			</section>
			<section id="es-object">
<h4 title="object">3.2.12. `object^T</h4>


<p>
~IDL `object$T 値は
~JS `Object^t 値により表現される。
◎
IDL object values are represented by ECMAScript Object values.
</p>

<p id="es-to-object">
次の~algoにより，
~JS値 %V は~IDL `object$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL object value by running the following algorithm:
</p>

<ol class="algorithm">
	<li id="cp-type-not-object">
~IF
`Type^( %V ) ~NEQ `Object^t
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Object, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objを参照する~IDL `object$T 値
◎
Return the IDL object value that is a reference to the same object as V.
</li>
</ol>

<p id="object-to-es">
~IDL `object$T 値 %V を~JS値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^t 値になる。
◎
The result of converting an IDL object value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL object represents.
</p>
			</section>
			<section id="es-interface">
<h4 title="Interface types">3.2.13. ~ifc型</h4>


<p>
~IDL`~ifc型$の値は
~JS［
`Object^t, または `Function^t
］値により表現される。
◎
IDL interface type values are represented by ECMAScript Object or Function values.
</p>

<p id="es-to-interface">
次の~algoにより，
~JS値 %V は~IDL`~ifc型$の値に`toIDL^される（以下では %I をその`~ifc$とする）：
◎
An ECMAScript value V is converted to an IDL interface type value by running the following algorithm (where I is the interface):
</p>

<ol class="algorithm">
	<!--cp-type-not-object-->
	<li>
~IF
%V は %I を実装する`~platform~obj$である
~THEN
~RET その~platform~objへの参照を表現する，~IDL`~ifc型$の値
◎
If V is a platform object that implements I, then return the IDL interface type value that represents a reference to that platform object.
</li>
	<li>
~IF
%V は［
`es-user-objects$sec の規則に従って %I を実装する
］ものと見なされる`利用者~obj$である
~THEN
~RET その利用者~objへの参照を表現し,
`呼戻~文脈$として`~incumbent設定群~obj$を伴う，
~IDL`~ifc型$の値
◎
If V is a user object that is considered to implement I according to the rules in §3.9 User objects implementing callback interfaces, then return the IDL interface type value that represents a reference to that user object, with the incumbent settings object as the callback context.
</li>
	<li id="cp-throw-typeerror">
~THROW `TypeError^t
◎
Throw a TypeError.
</li><!-- % * -->
</ol>

<p id="interface-to-es">
~IDL`~ifc型$の値 %V を~JS値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^t 値になる。
◎
The result of converting an IDL interface type value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL interface type value represents.
</p>
			</section>
			<section id="es-dictionary">
<h4 title="Dictionary types">3.2.14. 辞書~型</h4>


<p>
~IDL`辞書~型$の値は
~JS `Object^t 値により表現される。
その~obj（またはその原型鎖）上の~propが`辞書~mb$に対応する。
◎
IDL dictionary type values are represented by ECMAScript Object values. Properties on the object (or its prototype chain) correspond to dictionary members.
</p>

<p id="es-to-dictionary">
次の~algoにより，
~JS値 %V は~IDL`辞書~型$ %D の値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL dictionary type value by running the following algorithm (where D is the dictionary type):
</p>

<ol class="algorithm">
	<li><!--  title="cp-type-not-object" -->
~IF
`Type^( %V ) ~NIN { `Undefined^t, `Null^t, `Object^t }
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Undefined, Null or Object, then throw a TypeError.
</li>
	<li>
%dict := 型 %D の空の辞書~値（初期~時にはどの`辞書~mb$も`不在$と見なされる）
◎
Let dict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
</li>
	<li id="cp-let-inherited-dictionaries">
%dictionaries := %D および %D のすべての`被継承~辞書$を，先祖から先に，継承-順に並べた~list
◎
Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
</li>
	<li>
<p id="cp-for-each-dictionary">
~FOR
%dictionaries 内の~EACH ( 辞書 %dictionary ) に対し，順に： 
◎
For each dictionary dictionary in dictionaries, in order:
</p>
		<ol>
			<li>
<p id="cp-foreach-mb">
~FOR
%dictionary 上に宣言されている~EACH ( 辞書~mb %member ) に対し，辞書式~順序で：
◎
For each dictionary member member declared on dictionary, in lexicographical order:
</p>

				<ol>
					<li id="cp-let-key">
%key := %member の`識別子$
◎
Let key be the identifier of member.
</li>
					<li>
<p>
%value :=
`Type^( %V ) に応じて，次で与えられる~JS値：
◎
Let value be an ECMAScript value, depending on Type(V):
</p>

						<dl class="switch">
							<dt>`Undefined^t</dt>
							<dt>`Null^t</dt>
							<dd>
`undefined^v
◎
undefined
</dd>

							<dt>その他◎anything else</dt>
							<dd>
? `Get^( %key, %V )
◎
? Get(V, key)
</dd>
						</dl>
					</li>
					<li>
~IF
%value ~NEQ `undefined^v
~THEN
%idlValue := %value を %member に宣言されている型の~IDL値に`toIDL^した結果
◎
If value is not undefined, then:
• Let idlValue be the result of converting value to an IDL value whose type is the type member is declared to be of.
• Set the dictionary member on dict with key name key to the value idlValue. This dictionary member is considered to be present.
</li>
					<li>
~ELIF
%member は `辞書既定値^ %d を持つ
~THEN
%idlValue := %d
◎
Otherwise, if value is undefined but member has a default value, then:
• Let idlValue be the dictionary member’s default value.
• Set the dictionary member on dict with key name key to the value idlValue. This dictionary member is considered to be present.
</li>
					<li>
~ELIF
%member は `必須~辞書~mb$である
~THEN
~THROW `TypeError^t
◎
Otherwise, if value is undefined and member is a required dictionary member, then throw a TypeError.
</li>
					<li>
~ELSE
~THEN
~CONTINUE
◎
↑</li>
					<li>
%dict 上の ~key名 %key の辞書~mbの値 ← %idlValue
（この辞書~mbは`在する$ものと見なされるようになる）
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %dict
◎
Return dict.
</li>
</ol>

<p class="note">注記：
`辞書~mb$が~JS~obj上で検索される順序は、~objの~prop列挙~順序と同じになるとは限らない。
◎
Note: The order that dictionary members are looked up on the ECMAScript object are not necessarily the same as the object’s property enumeration order.
</p>

<p id="dictionary-to-es">
次の~algoにより，
~IDL辞書 %D 型の値 %V は~JS `Object^t 値に`toES^される：
◎
An IDL dictionary value V is converted to an ECMAScript Object value by running the following algorithm (where D is the dictionary):
</p>

<ol class="algorithm">
	<li>
%O := ! `ObjectCreate$A( `ObjectPrototype$esI )
◎
Let O be ! ObjectCreate(%ObjectPrototype%).
</li>
	<!--cp-let-inherited-dictionaries-->
	<li>
<!--cp-for-each-dictionary-->
		<ol>
			<li>
<!--cp-foreach-mb-->
				<ol>
					<!--cp-let-key-->
					<li>
<p>
~IF
名前 %key の辞書~mbが %V 内に`在する$
⇒
◎
If the dictionary member named key is present in V, then:
</p>
						<ol>
							<li>
%idlValue := %V 上の %member の値
◎
Let idlValue be the value of member on V.
</li>
							<li>
%value := %idlValue を~JS値に`toES^した結果
◎
Let value be the result of converting idlValue to an ECMAScript value.
</li>
							<li>
! `CreateDataProperty$A( %O, %key, %value )
を遂行する
◎
Perform ! CreateDataProperty(O, key, value).
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %O
◎
Return O.
</li>
</ol>
			</section>
			<section id="es-enumeration">
<h4 title="Enumeration types">3.2.15. 列挙~型</h4>


<p>
~IDL`列挙~型$の値は
~JS `String^t 値により表現される。
◎
IDL enumeration types are represented by ECMAScript String values.
</p>

<p id="es-to-enumeration">
次の~algoにより，
~JS値 %V は
~IDL`列挙$型 %E の値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL enumeration type value as follows (where E is the enumeration):
</p>

<ol class="algorithm">
	<li>
%S := `ToString$A( %V )
◎
Let S be the result of calling ToString(V).
</li>
	<li>
~IF
%S は %E の`列挙~値$のいずれでもない
~THEN
~THROW `TypeError^t
◎
If S is not one of E’s enumeration values, then throw a TypeError.
</li>
	<li>
~RET 型 %E の， %S に等しい列挙~値
◎
Return the enumeration value of type E that is equal to S.
</li>
</ol>

<p id="enumeration-to-es">
~IDL`列挙$型の値を~JS値に`toES^した結果は、［
その`列挙~値$と同じ`符号単位$の並び
］を表現する `String^t 値になる。
◎
The result of converting an IDL enumeration type value to an ECMAScript value is the String value that represents the same sequence of code units as the enumeration value.
</p>
			</section>
			<section id="es-callback-function">
<h4 title="Callback function types">3.2.16. 呼戻~関数~型</h4>


<p>
~IDL`呼戻~関数~型$の値は~JS `Function^t ~objにより表現される。
ただし， `TreatNonObjectAsNull$x の場合は、任意の~objをとり得る。
◎
IDL callback function types are represented by ECMAScript Function objects, except in the [TreatNonObjectAsNull] case, when they can be any object.
</p>

<p id="es-to-callback-function">
次の~algoにより，
~JS値 %V は~IDL`呼戻~関数~型$の値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL callback function type value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`IsCallable$A( %V ) ~EQ ~false
］~AND ［
~IDL値への変換は［
`~nullable$ `呼戻~関数$型 ~AND
`TreatNonObjectAsNull$x 注釈付き
］である`属性$への代入-により，遂行されては<em>いない</em>
］
~THEN
~THROW `TypeError^t <!-- % * -->
◎
If the result of calling IsCallable(V) is false and the conversion to an IDL value is not being performed due to V being assigned to an attribute whose type is a nullable callback function that is annotated with [TreatNonObjectAsNull], then throw a TypeError.
</li>
	<li>
~RET
%V が表現するものと同じ~objを表現し,
`呼戻~文脈$として`~incumbent設定群~obj$を伴う，
~IDL`呼戻~関数~型$の値
◎
Return the IDL callback function type value that represents a reference to the same object that V represents, with the incumbent settings object as the callback context.
</li>
</ol>

<p id="callback-function-to-es">
~IDL`呼戻~関数~型$の値を~JS値に`toES^した結果は、その`呼戻~関数~型$の値が表現するものと同じ~objへの参照になる。
◎
The result of converting an IDL callback function type value to an ECMAScript value is a reference to the same object that the IDL callback function type value represents.
</p>
			</section>
			<section id="es-nullable-type">
<h4 title="Nullable types — T?">3.2.17. ~nullable型 — `~varT?^T</h4>

<p>
~IDL`~nullable型$の値は、その`内縁~型$に対応する~JS型の値か, または
~JS `null^v 値により表現される。
◎
IDL nullable type values are represented by values of either the ECMAScript type corresponding to the inner IDL type, or the ECMAScript null value.
</p>

<p>
この節を通して、
`~varT?^T は，`内縁~型$が %T である~IDL`~nullable型$を表す。
</p>

<p id="es-to-nullable">
次の~algoにより，
~JS値 %V は `~varT?^T 型の値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL nullable type T? value (where T is the inner type) as follows:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ~NEQ `Object^t
］~AND ［
%V から~IDL値への変換は［
`~nullable$<!-- missing id="dfn-nullable" -->`呼戻~関数$型 ~AND
`TreatNonObjectAsNull$x 注釈付き
］である`属性$への代入-により遂行されている
］
~THEN
~RET 型 `~varT?^T の値 `null^V
◎
If Type(V) is not Object, and the conversion to an IDL value is being performed due to V being assigned to an attribute whose type is a nullable callback function that is annotated with [TreatNonObjectAsNull], then return the IDL nullable type T? value null.
</li>
	<li>
~IF
%V ~IN { `null^v, `undefined^v }
~THEN
~RET 型 `~varT?^T の値 `null^V
◎
Otherwise, if V is null or undefined, then return the IDL nullable type T? value null.
</li>
	<li>
~RET %V を`内縁~型$ %T に対する規則に従って`toIDL^した結果
◎
Otherwise, return the result of converting V using the rules for the inner IDL type T.
</li>
</ol>

<p id="nullable-to-es">
型 `~varT?^T の~IDL値 %V を~JS値に`toES^した結果は、［
%V ~EQ `null^V ならば `null^v ／
~ELSE_ %V を型 %T の値として~JS値に`toES^した結果
］になる。
◎
The result of converting an IDL nullable type value to an ECMAScript value is:
• If the IDL nullable type T? value is null, then the ECMAScript value is null.
• Otherwise, the ECMAScript value is the result of converting the IDL nullable type value to the inner IDL type T.
</p>

			</section>
			<section id="es-sequence">
<h4 title="Sequences — sequence&lt;T&gt;">3.2.18. 連列 — ~sequence_T</h4>

<p>
~IDL `~sequence_T$ 値は
~JS `Array^t 値により表現される。
◎
IDL sequence&lt;T&gt; values are represented by ECMAScript Array values.
</p>

<p id="es-to-sequence">
次の~algoにより，
~JS値 %V は~IDL `~sequence_T$ 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL sequence&lt;T&gt; value as follows:
</p>

<ol class="algorithm">
	<li>
~IF
%V は ~objでない
~THEN
~THROW `TypeError^t
◎
If V is not an object, throw a TypeError.
</li>
	<li id="cp-checkiter-V">
%method := `GetMethod$A( %V, `iterator$esS ) の結果
◎
Let method be the result of GetMethod(V, @@iterator).
</li>
	<li id="cp-ifAbr-method">
`ReturnIfAbrupt$A( %method )
◎
ReturnIfAbrupt(method).
</li>
	<li>
~IF
%method ~EQ `undefined^v
~THEN
~THROW `TypeError^t
◎
If method is undefined, throw a TypeError.
</li>
	<li>
%V, %method から`連列~値を作成-$した結果
◎
Return the result of creating a sequence from V and method.
</li>
</ol>

<p id="sequence-to-es">
次の~algoにより，型 `~sequence_T$ の~IDL連列~値 %S は
~JS `Array^t ~objに`toES^される：
◎
An IDL sequence value S of type sequence&lt;T&gt; is converted to an ECMAScript Array object as follows:
</p>

<ol class="algorithm">
	<li>
%n := %S の長さ
◎
Let n be the length of S.
</li>
	<li>
%A := 式 `[]^c で作成されるものと同じ，新たな `Array^t ~obj
◎
Let A be a new Array object created as if by the expression [].
</li>
	<li>
%i :← 0
◎
Initialize i to be 0.
</li>
	<li>
<!--cp-while-i-n-->
		<ol>
			<li>
%V := %S 内の~index %i に位置する値
◎
Let V be the value in S at index i.
</li>
			<li>
%E := %V を~JS値に`toES^した結果
◎
Let E be the result of converting V to an ECMAScript value.
</li>
			<li>
%P := `ToString$A( %i )
◎
Let P be the result of calling ToString(i).
</li>
			<li>
`CreateDataProperty$A( %A, %P, %E ) を~callする
◎
Call CreateDataProperty(A, P, E).
</li>
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
~RET %A
◎
Return A.
</li>
</ol>




				<section id="create-sequence-from-iterable">
<h5 title="Creating a sequence from an iterable">3.2.18.1. 可反復から連列を作成する</h5>

<p>
所与の［
可反復 %iterable,
反復子~取得子 %method
］から
型 `~sequence_T$ の~IDL値を作成するときは，次の手続きを遂行する：
◎
To create an IDL value of type sequence&lt;T&gt; given an iterable iterable and an iterator getter method, perform the following steps:
</p>

<ol class="algorithm">
	<li>
%iter := `GetIterator$A(%iterable, %method)
◎
Let iter be GetIterator(iterable, method).
</li>
	<li>
`ReturnIfAbrupt$A( %iter )
◎
ReturnIfAbrupt(iter).
</li>
	<li>
%i :← 0
◎
Initialize i to be 0.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Repeat
</p>
		<ol>
			<li>
%next := `IteratorStep$A( %iter )
◎
Let next be IteratorStep(iter).
</li>
			<li>
`ReturnIfAbrupt$A( %next )
◎
ReturnIfAbrupt(next).
</li>
			<li>
~IF
%next ~EQ `false^v
~THEN
~RET
~index %j に位置する要素の値が %S<sub>%j</sub> で, 長さ %i の，型
`~sequence_T$ の~IDL連列~値
◎
If next is false, then return an IDL sequence value of type sequence&lt;T&gt; of length i, where the value of the element at index j is Sj.
</li>
			<li>
%nextItem := `IteratorValue$A( %next )
◎
Let nextItem be IteratorValue(next).
</li>
			<li>
`ReturnIfAbrupt$A( %nextItem )
◎
ReturnIfAbrupt(nextItem).
</li>
			<li>
%S<sub>%i</sub> :← %nextItem を型 %T の~IDL値に`toIDL^した結果
◎
Initialize Si to the result of converting nextItem to an IDL value of type T.
</li>
			<li id="cp-inc-i">
%i ← %i + 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
</ol>
				</section>




<div class="example">
<p>
次の`~ifc$は
連列~型の引数を伴う`演算$と伴に
連列~型の`属性$を定義する。
◎
The following interface defines an attribute of a sequence type as well as an operation with an argument of a sequence type.
</p>

<pre class="idl-code">
interface Canvas {

  sequence&lt;DOMString&gt; getSupportedImageCodecs();

  void drawPolygon(sequence&lt;double&gt; coordinates);
  sequence&lt;double&gt; getLastDrawnPolygon();

  // <span class="comment">...</span>
};
</pre>

<p>
この~ifcの~JS実装においては、型［
`String^t ／ `Number^t 
］の要素からなる `Array^t ~objが，それぞれ［
`sequence&lt;DOMString&gt;^T ／
`sequence&lt;double&gt;^T
］の表現-に利用される。
この `Array^t ~objは実質的には値渡しであり、
`getSupportedImageCodecs()^c
関数が~callされる度に，新たな `Array^t が返され、
`Array^t が `drawPolygon^c に渡されたときは常に，その参照は~call完了-後には保有されないことになる。
◎
In an ECMAScript implementation of this interface, an Array object with elements of type String is used to represent a sequence&lt;DOMString&gt;, while an Array with elements of type Number represents a sequence&lt;double&gt;. The Array objects are effectively passed by value; every time the getSupportedImageCodecs() function is called a new Array is returned, and whenever an Array is passed to drawPolygon no reference will be kept after the call completes.
</p>

<pre class="es-code">
/* <span class="comment"
	title="Obtain an instance of Canvas.  Assume that getSupportedImageCodecs()
returns a sequence with two DOMString values: &quot;image/png&quot; and &quot;image/svg+xml&quot;."
>`Canvas^T の~instanceを得る。
`getSupportedImageCodecs()^c は、２個の `DOMString^T 値
`image/png^l, `image/svg+xml^l
からなる連列を返すものとする。</span> */
var canvas = getCanvas();

// <span class="comment"
	title="An Array object of length 2."
>長さ 2 の `Array^t ~obj。</span>
var supportedImageCodecs = canvas.getSupportedImageCodecs();

// <span class="comment"
	title="Evaluates to &quot;image/png&quot;." id="cp-eval-img"
>`image/png^l に評価される。</span>
supportedImageCodecs[0];

/* <span class="comment"
	title="Each time canvas.getSupportedImageCodecs() is called, it returns a
new Array object.  Thus modifying the returned Array will not
affect the value returned from a subsequent call to the function."
>`canvas.getSupportedImageCodecs()^c が~callされる度に，新たな `Array^t object が返される。
したがって，返された `Array^t を改変しても，後続の関数~callで返される値には影響しないことになる。</span> */
supportedImageCodecs[0] = `image/jpeg^l;

// <!--cp-eval-img-->
canvas.getSupportedImageCodecs()[0];

// <span class="comment"
	title="This evaluates to false, since a new Array object is returned each call."
>各~callで新たな `Array^t ~objが返されるので、これは `false^v に評価される。</span>
canvas.getSupportedImageCodecs() == canvas.getSupportedImageCodecs();


// <span class="comment"
	title="An Array of Numbers..."
>実数~値の `Array^t は...</span>
var a = [0, 0, 100, 0, 50, 62.5];

// <span class="comment"
	title="...can be passed to a platform object expecting a sequence&lt;double&gt;."
>...は `sequence&lt;double&gt;^T を期待する~platform~objに渡すことができる</span>
canvas.drawPolygon(a);

/* <span class="comment"
	title="Each element will be converted to a double by first calling ToNumber().
So the following call is equivalent to the previous one, except that
&quot;hi&quot; will be alerted before drawPolygon() returns."
>各~要素は最初に `ToNumber$A() の~callにより， `double^T に変換される。
したがって，次の~callは `drawPolygon()^c が返る前に `hi^l が alert されることを除き，前のものと等価になる。</span> */
a = [
    false,
    '',
    { valueOf: function() { alert('hi'); return 100; } },
    0,
    '50',
    new Number(62.5)
];
canvas.drawPolygon(a);

/* <span class="comment"
	title="Modifying an Array that was passed to drawPolygon() is guaranteed not to
have an effect on the Canvas, since the Array is effectively passed by value."
>`Array^t は実質的に値渡しなので，`drawPolygon()^c に渡された `Array^t を改変しても， `Canvas^T には効果を及ぼさないことが保証される。</span> */
a[4] = 20;
var b = canvas.getLastDrawnPolygon();
alert(b[4]);    // <span class="comment"
	title="This would alert &quot;50&quot;."
>これは `50^l を alert することになる。</span>
</pre>
</div>

			</section>
			<section id="es-record">
<h4 title="Records — record&lt;K, V&gt;">3.2.19. ~record — ~record_KV</h4>

<p>
~IDL `record$T 値は、~JS `Object^t 値により表現される。
◎
IDL record&lt;K, V&gt; values are represented by ECMAScript Object values.
</p>

<p id="es-to-record">
次の~algoにより，~JS値 %O は~IDL `~record_KV$ 値に`toIDL^される：
◎
An ECMAScript value O is converted to an IDL record&lt;K, V&gt; value as follows:
</p>

<ol class="algorithm">
	<li>
%result := 新たな空の`~record_KV$ 値
◎
Let result be a new empty instance of record&lt;K, V&gt;.
</li>
	<li>
~IF
`Type^( %O ) ~IN  { `Undefined^t, `Null^t }
~THEN
~RET %result
◎
If Type(O) is Undefined or Null, return result.
</li>
	<li>
~IF
`Type^( %O ) ~NEQ `Object^t
~THEN
~THROW `TypeError^t
◎
If Type(O) is not Object, throw a TypeError.
</li>
	<li>
%keys := ? %O.`OwnPropertyKeys^es()
◎
Let keys be ? O.[[OwnPropertyKeys]]().
</li>
	<li>
<p>
%keys 内の~EACH ( %key ) に対し， `List$ 順に：
◎
Repeat, for each element key of keys in List order:
</p>

		<ol>
			<li>
%desc := ? %O.`GetOwnProperty^es( %key )
◎
Let desc be ? O.[[GetOwnProperty]](key).
</li>
			<li>
<p>
~IF［
%desc ~NEQ `undefined^v
］~AND［
%desc.`Enumerable^es ~EQ `true^v
］：
◎
If desc is not undefined and desc.[[Enumerable]] is true:
</p>

				<ol>
					<li>
%typedKey := %key を %K 型~値に`toIDL^した結果
◎
Let typedKey be key converted to an IDL value of type K.
</li>
					<li>
%value := ? `Get^( %O, %key)
◎
Let value be ? Get(O, key).
</li>
					<li>
%typedValue := %value を %V 型~値に`toIDL^した結果
◎
Let typedValue be value converted to an IDL value of type V.
</li>
					<li>
<p>
~IF
%result 内に %typedKey を~keyとする`~mapping$はある
~THEN
その~mappingの値 ← %typedValue
◎
If typedKey is already a key in result, set its value to typedValue.
</p>

<p class="note">注記：
これは、 %O が~proxy~objであるときに起こり得る。
◎
Note: This can happen when O is a proxy object.
</p>
					</li>
					<li>
~ELSE
~THEN
%result に`~mapping$ ( %typedKey, %typedValue )
を付加する
◎
Otherwise, append to result a mapping (typedKey, typedValue).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %result
◎
Return result.
</li>
</ol>


<p id="record-to-es">
次の~algoにより，~IDL `record$T 値 %D は~JS値に`toES^される：
◎
An IDL record&lt;…&gt; value D is converted to an ECMAScript value as follows:
</p>

<ol class="algorithm">
	<li>
%result := ! `ObjectCreate$A( `ObjectPrototype$esI )
◎
Let result be ! ObjectCreate(%ObjectPrototype%).
</li>
	<li>
<p>
%D 内の~EACH ( `~mapping$( %key, %value ) ) に対し：
◎
Repeat, for each mapping (key, value) in D:
</p>

		<ol>
			<li>
%esKey := %key を~JS値に`toES^した結果
◎
Let esKey be key converted to an ECMAScript value.
</li>
			<li>
%esValue := %value を~JS値に`toES^した結果
◎
Let esValue be value converted to an ECMAScript value.
</li>
			<li>
%created := ! `CreateDataProperty$A( %result, %esKey, %esValue )
◎
Let created be ! CreateDataProperty(result, esKey, esValue).
</li>
			<li>
~Assert：
%created ~EQ `true^v
◎
Assert: created is true.
</li>
		</ol>
	</li>
	<li>
~RET %result
◎
Return result.
</li>
</ol>

<div class="example">

<p>
`record&lt;DOMString, double&gt;^T 型の引数として~JS値 `{b: 3, a: 4}^v を渡した結果は、~IDL値 `« ("b", 3), ("a", 4) »^V になる。
◎
Passing the ECMAScript value {b: 3, a: 4} as a record&lt;DOMString, double&gt; argument would result in the IDL value « ("b", 3), ("a", 4) ».
</p>

<p>
~recordが考慮に入れるのは，
<a href="~TC39#sec-own-property">own</a>
<a href="~TC39#sec-property-attributes">enumerable</a>
~propに限られるので、引数を返すだけの~IDL演算
<span class="block">
<samp>`record&lt;DOMString, double&gt;^T identity(`record&lt;DOMString, double&gt;^T %arg)</samp>
</span>
が与えられたとき、次の~codeは 各~表明（ "assert" ）に合格する：
◎
Records only consider own enumerable properties, so given an IDL operation record&lt;DOMString, double&gt; identity(record&lt;DOMString, double&gt; arg) which returns its argument, the following code passes its assertions:
</p>

<pre class="es-code">
let %proto = {a: 3, b: 4};
let %obj = {__proto__: proto, d: 5, c: 6}
Object.defineProperty(%obj, "e", {value: 7, enumerable: false});
let %result = identity(%obj);
console.assert(%result.a === undefined);
console.assert(%result.b === undefined);
console.assert(%result.e === undefined);
let %entries = Object.entries(%result);
console.assert(%entries[0][0] === "d");
console.assert(%entries[0][1] === 5);
console.assert(%entries[1][0] === "c");
console.assert(%entries[1][1] === 6);
</pre>

<p>
~recordの［
~key, 値
］は、他から拘束され得る
— ~keyは、 3 種の文字列~型に拘束されるに過ぎないが。
例えば：
◎
Record keys and values can be constrained, although keys can only be constrained among the three string types. The following conversions have the described results:
</p>

<table><thead><tr><th>渡された値◎Value
</th><th>値が渡された型◎Passed to type
</th><th>結果◎Result
</th></tr></thead>

<tbody><tr><td>`{"😞": 1}^v
</td><td>`record&lt;ByteString, double&gt;^T
</td><td>`TypeError^t

</td></tr><tr><td>`{"\uD83D": 1}^v
</td><td>`record&lt;USVString, double&gt;^T
</td><td>`« ("\uFFFD", 1) »^V

</td></tr><tr><td>`{"\uD83D": {hello: "world"}}^v
</td><td>`record&lt;DOMString, double&gt;^T
</td><td>`« ("\uD83D", 0) »^V
</td></tr></tbody></table>

</div>

			</section>
			<section id="es-promise">

<h4 title="Promise types —&nbsp;Promise&lt;T&gt;">3.2.20. ~promise型 — ~promise_T</h4>

<p>
~IDL`~promise型$値は
~JS `Promise^t ~objにより表現される。
◎
IDL promise type values are represented by ECMAScript Promise objects.
</p>

<p id="es-to-promise">
次の~algoにより，
~JS値 %V は~IDL `~promise_T$ 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL Promise&lt;T&gt; value as follows:
</p>

<ol class="algorithm">
	<li>
<p>
%resolve := `Promise$esI.resolve の元の値
◎
Let resolve be the original value of %Promise%.resolve.
</p>

<p class="issue">
~JSは、［
well-known 内在的~obj ~Promise_resolve
］を，ここから参照し得るように増補することになる筈である。
◎
ECMAScript should grow a %Promise_resolve% well-known intrinsic object that can be referenced here.
</p>
	</li>
	<li>
%promise := ［
`this^v 値に `Promise$esI,
単独の引数に %V
］を渡して，%resolve を~callした結果
◎
Let promise be the result of calling resolve with %Promise% as the this value and V as the single argument value.
</li>
	<li>
~RET %promise と同じ~objへの参照である~IDL`~promise型$値
◎
Return the IDL promise type value that is a reference to the same object as promise.
</li>
</ol>

<p id="promise-to-es">
~IDL`~promise型$値 %V を~JS値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Promise^t 値になる。
◎
The result of converting an IDL promise type value to an ECMAScript value is the Promise value that represents a reference to the same object that the IDL promise type represents.
</p>

<p>
~promiseが決着したとき、すなわち，それが［
充足された, または却下された
］とき、それぞれに応じて，何らかの手続きが遂行され得る
— そのいずれかは省略され得る
<span class="trans-note">【
これらの手続きは、~promiseを利用する仕様が指定する
】</span>
。
仕様にて
`~promiseが決着したときの手続きを遂行する@
と記された所では、次の手続きに従わ~MUST：
◎
One can perform some steps once a promise is settled. There can be one or two sets of steps to perform, covering when the promise is fulfilled, rejected, or both. When a specification says to perform some steps once a promise is settled, the following steps must be followed:
</p>

<ol class="algorithm">

	<li>
%promise := 型 `~promise_T$ の~promise~obj
◎
Let promise be the promise object of type Promise&lt;T&gt;.
</li>
	<li>
<p>
%onFulfilled := 被呼出時の挙動が次で与えられる，新たな`関数~obj$
◎
Let onFulfilled be a new function object whose behavior when invoked is as follows:
</p>

		<ol>
			<li>
<p>
~IF %T は `void$T 型
⇒
◎
If T is void, then:
</p>
				<ol>
					<li>
~RET
~promiseが充足-時に走らすことが要求されている手続きを遂行した結果
◎
Return the result of performing any steps that were required to be run if the promise was fulfilled.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
⇒
◎
Otherwise, T is a type other than void:
</p>

				<ol>
					<li>
%V := %onFulfilled に渡された第一~引数
◎
Let V be the first argument to onFulfilled.
</li>
					<li>
%value := %V を型 %T の~IDL値に`toIDL^した結果
◎
Let value be the result of converting V to an IDL value of type T.
</li>
					<li>
~IF ［
~promiseの充足-時に走らすことが要求されている手続き
］がある
~THEN
~RET ~promiseの値として %value を渡して，その手続きを遂行した結果
◎
If there are no steps that are required to be run if the promise was fulfilled, then return undefined.
◎
Otherwise, return the result of performing any steps that were required to be run if the promise was fulfilled, with value as the promise’s value.
</li>
					<li>
~RET `undefined^v
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
%onRejected := 被呼出時の挙動が次で与えられる，新たな`関数~obj$：
◎
Let onRejected be a new function object whose behavior when invoked is as follows:
</p>
		<ol>

			<li>
%R := %onRejected に渡された第一~引数
◎
Let R be the first argument to onRejected.
</li>
			<li>
%reason := %R を~IDL `any$T 型~値に`toIDL^した結果
◎
Let reason be the result of converting R to an IDL value of type any.
</li>
			<li>
~IF ［
~promiseの却下-時に走らすことが要求されている手続き
］がある
~THEN
~RET 却下~事由として %reason を渡して，その手続きを遂行した結果
◎
If there are no steps that are required to be run if the promise was rejected, then return undefined.
◎
Otherwise, return the result of performing any steps that were required to be run if the promise was rejected, with reason as the rejection reason.
</li>
			<li>
~RET `undefined^v
◎
↑</li>
		</ol>
	</li>
	<li>
%then := ~prop名 `then^l により， %promise の `Get^es 内部~methを~callした結果
◎
Let then be the result of calling the internal [[Get]] method of promise with property name “then”.
</li>
	<li>
~IF
%then は`~callable$でない
~THEN
~THROW `TypeError^t
◎
If then is not callable, then throw a TypeError.
</li>
	<li>
~RET ［
`this^v 値に %promise,
その２個の引数に ( %onFulfilled, %onRejected )
］を渡して，%then を~callした結果
◎
Return the result of calling then with promise as the this value and onFulfilled and onRejected as its two arguments.
</li>
</ol>

<p class="issue">
この用語を利用する仕様の記述例を含める必要がある。
◎
Include an example of how to write spec text using this term.
</p>


			</section>
			<section id="es-union">
<h4 title="Union types">3.2.21. 共用体~型</h4>


<p>
~IDL`共用体~型$の値は
共用体の`~mb型$に対応する~JS値により表現される。
◎
IDL union type values are represented by ECMAScript values that correspond to the union’s member types.
</p>

<p id="es-to-union">
次の~algoにより，
~JS値 %V は
~IDL`共用体~型$の値に`toIDL^される：
◎
To convert an ECMAScript value V to an IDL union type value is done as follows:
</p>

<ol class="algorithm">
	<li>
~IF［
%V ~IN { `null^v, `undefined^v }
］~AND［
当の`共用体~型$は`~nullable型を内包する$
］
~THEN
~RET ~IDL値 `null^V
◎
If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
</li>
	<li>
%types := 当の`共用体~型$の`平坦化~mb型$
◎
Let types be the flattened member types of the union type.
</li>
	<li>
<p>
~IF［
%V ~IN { `null^v, `undefined^v }
］：
◎
If V is null or undefined, then:
</p>
		<ol>
			<li>
~IF
%types に`辞書~型$が含まれている
~THEN
~RET %V をその辞書~型に`toIDL^した結果
◎
If types includes a dictionary type, then return the result of converting V to that dictionary type.
</li>
			<li>
~IF
%types に`~record型$が含まれている
~THEN
~RET %V をその~record型に`toIDL^した結果
◎
If types includes a record type, then return the result of converting V to that record type.
</li>
		</ol>
	</li>
	<li>
<p>
~IF
%V は `~platform~obj$である
⇒
◎
If V is a platform object, then:
</p>

		<ol>
			<li>
~IF
%types に %V が実装する`~ifc型$が含まれている
~THEN
~RET ~obj %V への参照である~IDL値
◎
If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
</li>
			<li id="cp-object-in-types">
~IF
%types に `object$T が含まれている
~THEN
~RET ~obj %V への参照である~IDL値
◎
If types includes object, then return the IDL value that is a reference to the object V.
</li>
		</ol>
	</li>
	<li>
<p>
~IF
%V は `DOMException^t ~platform~objである
⇒
◎
If V is a DOMException platform object, then:
</p>
		<ol>
			<li>
~IF
%types に `DOMException$T または `Error$T が含まれている
~THEN
~RET %V を その型に`toIDL^した結果
◎
If types includes DOMException or Error, then return the result of converting V to that type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF
%V は ~native `Error^t ~objである（すなわち， `ErrorData^es `内部~slot$を持つ）
⇒
◎
If V is a native Error object (that is, it has an [[ErrorData]] internal slot), then:
</p>
		<ol>
			<li>
~IF
%types に `Error$T が含まれている
~THEN
~RET %V を `Error$T に`toIDL^した結果
◎
If types includes Error, then return the result of converting V to Error.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF
%V は `ArrayBufferData^es `内部~slot$を伴う~objである
⇒
◎
If V is an object with an [[ArrayBufferData]] internal slot, then:
</p>
		<ol>
			<li>
~IF
%types に `ArrayBuffer$T が含まれている
~THEN
~RET %V を `ArrayBuffer$T に`toIDL^した結果
◎
If types includes ArrayBuffer, then return the result of converting V to ArrayBuffer.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF
%V は `DataView^es `内部~slot$を伴う~objである
⇒
◎
If V is an object with a [[DataView]] internal slot, then:
</p>
		<ol>
			<li>
~IF
%types に `DataView$T が含まれている
~THEN
~RET %V を `DataView$T に`toIDL^した結果
◎
If types includes DataView, then return the result of converting V to DataView.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF
%V は `TypedArrayName^es `内部~slot$を伴う~objである
⇒
◎
If V is an object with a [[TypedArrayName]] internal slot, then:
</p>
		<ol>
			<li>
~IF
%types に［
`有型~配列~型$であって，［
その型~名<!-- ＊名前 --> ~EQ %V の `TypedArrayName^es `内部~slot$の値
］なるもの
］が含まれている
~THEN
~RET %V をその型に`toIDL^した結果
◎
If types includes a typed array type whose name is the value of V’s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF
`IsCallable$A( %V )  ~EQ ~true
⇒
◎
If IsCallable(V) is true, then:
</p>
		<ol>
			<li>
~IF
%types に`呼戻~関数$型が含まれている
~THEN
~RET %V をその呼戻~関数~型に`toIDL^した結果
◎
If types includes a callback function type, then return the result of converting V to that callback function type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF
%V は任意の種類の~objである
⇒
◎
If V is any kind of object, then:
</p>
		<ol>
			<li>
<p>
~IF
%types に`連列~型$が含まれている
⇒
◎
If types includes a sequence type, then
</p>
				<ol>
					<!--cp-checkiter-V-->
					<!--cp-ifAbr-method-->
					<li>
~IF
%method ~NEQ `undefined^v
~THEN
~RET %V, %method から その型の`連列~値を作成-$した結果
◎
If method is not undefined, return the result of creating a sequence of that type from V and method.
</li>
				</ol>
			</li>
			<li>
<p>
~IF
%types に`凍結~配列~型$が含まれている
⇒
◎
If types includes a frozen array type, then
</p>
				<ol>
					<!--cp-checkiter-V-->
					<!--cp-ifAbr-method-->
					<li>
~IF
%method ~NEQ `undefined^v
~THEN
~RET %V, %method から その型の`凍結~配列~値を作成-$した結果
◎
If method is not undefined, return the result of creating a frozen array of that type from V and method.
</li>
				</ol>
			</li>
			<li>
~IF
%types に`辞書~型$が含まれている
~THEN
~RET %V をその型に`toIDL^した結果
◎
If types includes a dictionary type, then return the result of converting V to that dictionary type.
</li>
			<li>
~IF
%types に`~record型$が含まれている
~THEN
~RET %V をその型に`toIDL^した結果
◎
If types includes a record type, then return the result of converting V to that record type.
</li>
			<li>
~IF
%types に`呼戻~ifc$型が含まれている
~THEN
~RET %V をその型に`toIDL^した結果
◎
If types includes a callback interface type, then return the result of converting V to that interface type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF
%V は `Boolean^t 値である
⇒
◎
If V is a Boolean value, then:
</p>
		<ol>
			<li id="cp-boolean-in-types">
~IF
%types に `boolean$T が含まれている
~THEN
~RET %V を `boolean$T に`toIDL^した結果
◎
If types includes a boolean, then return the result of converting V to boolean.
</li>
		</ol>
	</li>
	<li>
<p>
~IF
%V は `Number^t 値である
⇒
◎
If V is a Number value, then:
</p>
		<ol>
			<li id="cp-numeric-in-types">
~IF
%types に`実数~型$が含まれている
~THEN
~RET %V をその`実数~型$に`toIDL^した結果
◎
If types includes a numeric type, then return the result of converting V to that numeric type.
</li>
		</ol>
	</li>
	<li>
~IF
%types に`文字列~型$が含まれている
~THEN
~RET %V をその型に`toIDL^した結果
◎
If types includes a string type, then return the result of converting V to that type.
</li>
	<!--cp-numeric-in-types-->
	<!--cp-boolean-in-types-->
	<!--cp-throw-typeerror-->
</ol>

<div class="p">

<p id="union-to-es">
~IDL共用体~型の値 %U は，次のように~JS値へ`toES^される：
</p>

<ul><li>%U が［
~JS `undefined^v 値を表現する特別な~objへの `object$T 参照
］ならば、~JS `undefined^v 値に変換される。
</li><li>他の場合、この `es-type-mapping$sec にて述べている， %U の`固有型$を変換するための規則に従う。
</li></ul>

◎
An IDL union type value is converted to an ECMAScript value as follows. If the value is an object reference to a special object that represents an ECMAScript undefined value, then it is converted to the ECMAScript undefined value. Otherwise, the rules for converting the specific type of the IDL union type value as described in this section (§3.2 ECMAScript type mapping).
</div>

			</section>
			<section id="es-Error">
<h4 title="Error">3.2.22. `Error^T</h4>

<p>
~IDL `Error$T 値は、［
~native~JS `Error^t ~obj ／
`~DOMException$に対する~platform~obj
］により表現される。
◎
IDL Error values are represented by native ECMAScript Error objects and platform objects for DOMExceptions.
</p>


<p id="es-to-Error">
次の~algoにより，
~JS値 %V は~IDL `Error$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL Error value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ~NEQ `Object^t
］~OR［
%V は `ErrorData^es `内部~slot$を持たない
］
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Object, or V does not have an [[ErrorData]] internal slot, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `Error$T 値
◎
Return the IDL Error value that is a reference to the same object as V.
</li>
</ol>


<p id="Error-to-es">
~IDL `Error$T 値 %V を~JS値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Error^t 値である。
◎
The result of converting an IDL Error value to an ECMAScript value is the Error value that represents a reference to the same object that the IDL Error represents.
</p>

			</section>
			<section id="es-DOMException">
<h4 title="DOMException">3.2.23. `DOMException^T</h4>

<p>
~IDL `DOMException$T 値は、`~DOMException$に対する~platform~objにより表現される。
◎
IDL DOMException values are represented by platform objects for DOMExceptions.
</p>

<p id="es-to-DOMException">
次の~algoにより，
~JS値 %V は~IDL`~DOMException$値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL DOMException value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ~NEQ `Object^t
］~OR［
%V は`~DOMException$を表現する~platform~objでない
］
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Object, or V is not a platform object that represents a DOMException, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `DOMException$T 値
◎
Return the IDL DOMException value that is a reference to the same object as V.
</li>
</ol>

<p id="DOMException-to-es">
~IDL `DOMException$T 値 %V を~JS値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^t 値である。
◎
The result of converting an IDL DOMException value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL DOMException represents.
</p>


			</section>
			<section id="es-buffer-source-types">
<h4 title="Buffer source types">3.2.24. ~buffer~source型</h4>

<p>
~IDL`~buffer~source型$の値は、対応する~JS~classの~objにより表現される。
◎
Values of the IDL buffer source types are represented by objects of the corresponding ECMAScript class.
</p>

<p id="es-to-buffer-source">
次の~algoにより，
~JS値 %V は~IDL `ArrayBuffer$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL ArrayBuffer value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ~NEQ `Object^t
］~OR［
%V は `ArrayBufferData^es `内部~slot$を持たない
］~OR［
`IsDetachedBuffer$A( %V ) ~EQ `true^v
］
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Object, or V does not have an [[ArrayBufferData]] internal slot, or IsDetachedBuffer(V) is true, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `ArrayBuffer$T 値
◎
Return the IDL ArrayBuffer value that is a reference to the same object as V.
</li>
</ol>

<p id="buffer-source-to-es">
次の~algoにより，
~JS値 %V は~IDL `DataView$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL DataView value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ~NEQ `Object^t
］~OR［
%V は `DataView^es `内部~slot$を持たない
］
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Object, or V does not have a [[DataView]] internal slot, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `DataView$T 値
◎
Return the IDL DataView value that is a reference to the same object as V.
</li>
</ol>

<p>
%T をいずれかの`有型~配列~型$とするとき、次の~algoにより，~JS値 %V は~IDL %T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array or Float64Array value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ~NEQ `Object^t
］~OR［
%V は ［
値が %T の型~名に等しい `TypedArrayName^es `内部~slot$
<!-- ＊名前 -->
］を持たない
］
~THEN
~THROW `TypeError^t
◎
Let T be the IDL type V is being converted to.
◎
If Type(V) is not Object, or V does not have a [[TypedArrayName]] internal slot with a value equal to the name of T, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL %T 値
◎
Return the IDL value of type T that is a reference to the same object as V.
</li>
</ol>

<p>
いずれの`~buffer~source型$に対しても、その型の~IDL値 %V を~JS値に`toES^した結果は，
%V が表現するものと同じ~objへの参照を表現する `Object^t 値である。
◎
The result of converting an IDL value of any buffer source type to an ECMAScript value is the Object value that represents a reference to the same object that the IDL value represents.
</p>

<p>
［
~JS［
`ArrayBuffer^t,
`DataView^t,
`有型~配列~型$
］のいずれかの ~objである，~buffer~source %O
］に保持されている~byte列の`参照／複製を取得-$するときは、次の手続きに従わ~MUST：
◎
When getting a reference to or getting a copy of the bytes held by a buffer source that is an ECMAScript ArrayBuffer, DataView or typed array object, these steps must be followed:
</p>

<ol class="algorithm">
	<li>
%arrayBuffer :← %O
◎
Let O be the ECMAScript object that is the buffer source.
◎
Initialize arrayBuffer to O.
</li>
	<li>
%offset :← 0
◎
Initialize offset to 0.
</li>
	<li>
%length :← 0
◎
Initialize length to 0.
</li>
	<li>

<p>
~IF
%O は `ViewedArrayBuffer^es `内部~slot$を持つ
⇒
◎
If O has a [[ViewedArrayBuffer]] internal slot, then:
</p>

		<ol>
			<li>
%arrayBuffer ←
%O の `ViewedArrayBuffer^es `内部~slot$の値
◎
Set arrayBuffer to the value of O’s [[ViewedArrayBuffer]] internal slot.
</li>
			<li>
~IF
%arrayBuffer ~EQ `undefined^v
~THEN
~THROW `TypeError^t
◎
If arrayBuffer is undefined, then throw a TypeError.
</li>
			<li>
%offset ←
%O の `ByteOffset^es `内部~slot$の値
◎
Set offset to the value of O’s [[ByteOffset]] internal slot.
</li>
			<li>
%length ←
%O の `ByteLength^es `内部~slot$の値
◎
Set length to the value of O’s [[ByteLength]] internal slot.
</li>
		</ol>
	</li>
	<li>
~ELSE
%length ←
%O の `ArrayBufferByteLength^es `内部~slot$の値
◎
Otherwise, set length to the value of O’s [[ArrayBufferByteLength]] internal slot.
</li>
	<li>
~IF
`IsDetachedBuffer$A( %O )
~THEN
~THROW `TypeError^t
◎
If IsDetachedBuffer(O), then throw a TypeError.
</li>
	<li>
%data :=
%O の `ArrayBufferData^es `内部~slot$の値
◎
Let data be the value of O’s [[ArrayBufferData]] internal slot.
</li>
	<li>
~RET ［
%data 内の~byte~offset %offset の所から， %length 個の~byte
］［
への参照, または の複製
］（いずれか要求された方）。
◎
Return a reference to or copy of (as required) the length bytes in data starting at byte offset offset.
</li>
</ol>

<p>
`ArrayBuffer$T ~objを
`切離す@
ときは、次の手続きに従わ~MUST：
◎
To detach an ArrayBuffer, these steps must be followed:
</p>

<ol class="algorithm">
	<li>
%O := その `ArrayBuffer$T である~JS~obj
◎
Let O be the ECMAScript object that is the ArrayBuffer.
</li>
	<li>
! `DetachArrayBuffer$A( %O )
を遂行する
◎
Perform ! DetachArrayBuffer(O).
</li>
</ol>

			</section>
			<section id="es-frozen-array" class="L2">
<h4 title="Frozen arrays — FrozenArray&lt;T&gt;">3.2.25. 凍結~配列 — ~FrozenArray_T</h4>


<p>
`凍結~配列~型$の値は、~~凍結された（ frozen ）~JS `Array^t ~obj参照により表現される。
◎
Values of frozen array types are represented by frozen ECMAScript Array object references.
</p>

<p>
次の~algoにより，
~JS値 %V は~IDL `~FrozenArray_T$ 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL FrozenArray&lt;T&gt; value by running the following algorithm:
</p>


<ol class="algorithm">
	<li>
%values := %V を~IDL ~sequence_T 型に`toIDL^した結果
◎
Let values be the result of converting V to IDL type sequence&lt;T&gt;.
</li>
	<li>
~RET %values から`凍結~配列を作成-$した結果
◎
Return the result of creating a frozen array from values.
</li>
</ol>

<p>
型 ~varT の値の連列から
`凍結~配列を作成-@
するときは、次の手続きに従う：
◎
To create a frozen array from a sequence of values of type T, follow these steps:
</p>

<ol class="algorithm">
	<li>
%array := 値の連列を~JS値に`toES^した結果
◎
Let array be the result of converting the sequence of values to an ECMAScript value.
</li>
	<li>
`SetIntegrityLevel$A(%array, <code>"frozen"</code>)
を遂行する
◎
Perform SetIntegrityLevel(array, "frozen").
</li>
	<li>
~RET %array
◎
Return array.
</li>
</ol>

<p>
~IDL `~FrozenArray_T$ 値 %V を~JS値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^t 値である。
◎
The result of converting an IDL FrozenArray&lt;T&gt; value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL FrozenArray&lt;T&gt; represents.
</p>

				<section id="create-frozen-array-from-iterable">
<h5 title="Creating a frozen array from an iterable">3.2.25.1. 可反復から凍結~配列を作成する</h5>

<p>
所与の［
可反復 %iterable,
反復子~取得子 %method
］から
型 `~FrozenArray_T$ の~IDL値を作成するときは，次の手続きを遂行する：
◎
To create an IDL value of type FrozenArray&lt;T&gt; given an iterable iterable and an iterator getter method, perform the following steps:
</p>

<ol class="algorithm">
	<li>
%values := %iterable, %method から型 ~varT の`連列~値を作成-$した結果
◎
Let values be the result of creating a sequence of type sequence&lt;T&gt; from iterable and method.
</li>
	<li>
~RET %values から`凍結~配列を作成-$した結果
◎
Return the result of creating a frozen array from values.
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="es-extended-attributes">
<h3 title="ECMAScript-specific extended attributes">3.3. ~JS固有の拡張属性</h3>


<p>
この節では、その存在tが~JS言語束縛にのみ影響する いくつかの`拡張属性$を定義する。
◎
This section defines a number of extended attributes whose presence affects only the ECMAScript binding.
</p>

			<section id="Clamp">
<h4>3.3.1. `Clamp^x</h4>


<p>
`Clamp$x `拡張属性$が［
`整数~型$の［
`演算$の引数 ／
~writableな`属性$ ／
`辞書~mb$
］］上に現れた場合、
~JS `Number^t から~IDL型への変換-において，範囲~外の値は、
modulo 演算（ `ToInt32$A, `ToUint32$A, 等々）を利用する演算子を利用せずに，範囲~内の妥当な値に切詰められる（切り上げ／切り下げされる）ことになる。
◎
If the [Clamp] extended attribute appears on an operation argument, writable attribute or dictionary member whose type is one of the integer types, it indicates that when an ECMAScript Number is converted to the IDL type, out of range values will be clamped to the range of valid values, rather than using the operators that use a modulo operation (ToInt32, ToUint32, etc.).
</p>

<div>
<p>
`Clamp$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`読専$の属性に現れては~MUST_NOT。
</li><li>`整数~型$でない［
属性／演算~引数／辞書~mb
］に現れては~MUST_NOT。
</li><li>`EnforceRange$x 拡張属性と併用されては~MUST_NOT。
</li></ul>

◎
The [Clamp] extended attribute must take no arguments.
◎
The [Clamp] extended attribute must not appear on a read only attribute, or an attribute, operation argument or dictionary member that is not of an integer type. It also must not be used in conjunction with the [EnforceRange] extended attribute.
</div>


<p>
`Clamp$x の利用に課される固有の要件については、
~JS値から種々の~IDL整数~型への変換-規則について述べた
`es-type-mapping$sec
に。
◎
See the rules for converting ECMAScript values to the various IDL integer types in §3.2 ECMAScript type mapping for the specific requirements that the use of [Clamp] entails.
</p>


<div class="example">
<p>
次の`~IDL片$では，それぞれが３個の `octet$T 引数をとる，２個の`演算$が宣言される。
一方には３個すべての引数に `Clamp$x `拡張属性$が利用され，他方はそうでない：
◎
In the following IDL fragment, two operations are declared that take three octet arguments; one uses the [Clamp] extended attribute on all three arguments, while the other does not:
</p>

<pre class="idl-code">
interface GraphicsContext {
  void setColor(octet red, octet green, octet blue);
  void setColorClamped([Clamp] octet red, [Clamp] octet green, [Clamp] octet blue);
};
</pre>

<p>
この~IDLの~JS実装においては、
`setColorClamped^M の~callに渡された，
`octet$T の範囲~外の `Number^t 値は、範囲 [0,&nbsp;255] に切詰められる。
◎
In an ECMAScript implementation of the IDL, a call to setColorClamped with Number values that are out of range for an octet are clamped to the range [0, 255].
</p>

<pre class="es-code">
// <span class="comment"
	title="Get an instance of GraphicsContext."
>`GraphicsContext^T の~instanceを取得する。</span>
var context = getGraphicsContext();

// <span class="comment"
	title="Calling the non-[Clamp] version uses ToUint8 to coerce the Numbers to octets."
>非 `Clamp^x 版の~callは実数~値を~octetに強制する ToUint8 を利用する。</span>
// <span class="comment"
	title="This is equivalent to calling setColor(255, 255, 1)."
>次は `setColor(255, 255, 1)^c の~callと等価。</span>
context.setColor(-1, 255, 257);

// <span class="comment"
	title="Call setColorClamped with some out of range values."
>範囲~外の値を渡して `setColorClamped^M を~call。</span>
// <span class="comment"
	title="This is equivalent to calling setColorClamped(0, 255, 255)."
>次は `setColorClamped(0, 255, 255)^c の~callと等価。</span>
context.setColorClamped(-1, 255, 257);
</pre>
</div>
			</section>
			<section id="Constructor">
<h4>3.3.2. `Constructor^x</h4>


<p>
`Constructor$x `拡張属性$が `~ifc$上に現れた場合、その~ifcに対応する`~ifc~obj$は，［
その~ifcを実装する~objを構築し得るようにする， `Construct^es 内部~meth
］を持つことになる。
◎
If the [Constructor] extended attribute appears on an interface, it indicates that the interface object for this interface will have an [[Construct]] internal method, allowing objects implementing the interface to be constructed.
</p>

<p>
同じ~ifc上に複数の `Constructor$x 拡張属性が現れてもよい。
◎
Multiple [Constructor] extended attributes may appear on a given interface.
</p>

<p>
`Constructor$x 拡張属性には、［
`引数をとらない$
か, または
`有名~引数~listを引数にとる$
］ことが要求される。<!-- must -->
略記形の前者
`[Constructor]^c
は、引数~listが空にされた
`[Constructor()]^c
と同じ意味になる。
~ifc上のそれぞれの `Constructor$x 拡張属性が、［
指定された引数を渡して，その~ifcを実装する~objを構築する仕方
］を、供することになる。
◎
The [Constructor] extended attribute must either take no arguments or take an argument list. The bare form, [Constructor], has the same meaning as using an empty argument list, [Constructor()]. For each [Constructor] extended attribute on the interface, there will be a way to construct an object that implements the interface by passing the specified arguments.
</p>

<p>
構築子の注釈文においては，［
`Constructor$x 拡張属性が現れる~ifcに対応する型の~IDL値を返すか, または
例外を投出する
］ように定義され~MUST。
◎
The prose definition of a constructor must either return an IDL value of a type corresponding to the interface the [Constructor] extended attribute appears on, or throw an exception.
</p>

<p>
`Constructor$x 拡張属性は：
</p>

<ul>
	<li>
同じ~ifc上で， `NoInterfaceObject$x 拡張属性と併用されては~MUST_NOT。
◎
The [Constructor] and [NoInterfaceObject] extended attributes must not be specified on the same interface.
</li>
	<li>
`呼戻~ifc$上に利用されては~MUST_NOT。
◎
The [Constructor] extended attribute must not be used on a callback interface.
</li>
</ul>

<p>
~ifcに対する構築子がどう実装されるかの詳細は
`es-constructible-interfaces$sec
に。
◎
See §3.6.1.1 Constructible Interfaces for details on how a constructor for an interface is to be implemented.
</p>


<div class="example">
<p>
次の~IDLは２つの~ifcを定義する。
二番目のものは `Constructor$x 拡張属性を持つ一方，最初のものは持たない。
◎
The following IDL defines two interfaces. The second has the [Constructor] extended attribute, while the first does not.
</p>

<pre class="idl-code">
interface NodeList {
  Node item(unsigned long index);
  readonly attribute unsigned long length;
};

[Constructor,
 Constructor(double radius)]
interface Circle {
  attribute double r;
  attribute double cx;
  attribute double cy;
  readonly attribute double circumference;
};
</pre>

<p>
これらの~ifcを~supportする~JS実装は、
`Circle^T ~ifc~obj上に，［
その~ifcを実装する新たな~obj
］を返す `Construct^es ~propを持つことになる。
それは 0 個または 1 個の引数をとる。
`NodeList^T ~ifc~objは
`Construct^es ~propを持たないことになる。
◎
An ECMAScript implementation supporting these interfaces would have a [[Construct]] property on the Circle interface object which would return a new object that implements the interface. It would take either zero or one argument. The NodeList interface object would not have a [[Construct]] property.
</p>

<pre class="es-code">
var x = new Circle();      
       /* <span class="comment"
	title="The uses the zero-argument constructor to create a
reference to a platform object that implements the
Circle interface."
>これは，引数なしの構築子を利用して、 `Circle^T ~ifcを実装する~platform~objへの参照を作成する。</span> */

var y = new Circle(1.25);  
       /* <span class="comment"
	title="This also creates a Circle object, this time using
the one-argument constructor."
>今度は１引数の構築子を利用して `Circle^T ~objを作成する。</span> */

var z = new NodeList();    
       /* <span class="comment"
	title="This would throw a TypeError, since no
[Constructor] is declared."
>`Constructor^x が宣言されていないので `TypeError^t が投出されることになる。</span> */
</pre>
</div>


			</section>
			<section id="EnforceRange">
<h4>3.3.3. `EnforceRange^x</h4>


<p>
`EnforceRange$x `拡張属性$が［
`演算$の引数 ／
~writableな`正則~属性$／
`整数~型$の`辞書~mb$
］に現れた場合、
~JS `Number^t がその~IDL型に変換される際に，範囲~外の値に対しては、 modulo 演算を利用する演算子（ `ToInt32$A, `ToUint32$A, 等々）を利用して妥当な値に変換される代わりに，例外が投出されるようになる。
`Number^t は、その範囲が検査される前に，ゼロ側に丸められる。
◎
If the [EnforceRange] extended attribute appears on an operation argument, writable regular attribute or dictionary member whose type is one of the integer types, it indicates that when an ECMAScript Number is converted to the IDL type, out of range values will cause an exception to be thrown, rather than converted to being a valid value using the operators that use a modulo operation (ToInt32, ToUint32, etc.). The Number will be rounded towards zero before being checked against its range.
</p>

<div>
<p>
`EnforceRange$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>［
`読専$属性 ／ `静的~属性$
］に現れては~MUST_NOT。
</li><li>`整数~型$でない［
属性 ／ 演算~引数 ／ 辞書~mb
］に現れては~MUST_NOT。
</li><li>`Clamp$x 拡張属性と併用されては~MUST_NOT。
</li></ul>

◎
The [EnforceRange] extended attribute must take no arguments.
◎
The [EnforceRange] extended attribute must not appear on a read only attribute, a static attribute, or an attribute, operation argument or dictionary member that is not of an integer type. It also must not be used in conjunction with the [Clamp] extended attribute.
</div>


<p>
`EnforceRange$x の利用に課される固有の要件については、［
~JS値から種々の~IDL整数~型への変換-規則
］について述べている
`es-type-mapping$sec
にて。
◎
See the rules for converting ECMAScript values to the various IDL integer types in §3.2 ECMAScript type mapping for the specific requirements that the use of [EnforceRange] entails.
</p>


<div class="example">
<p><!-- copy* -->
次の`~IDL片$では，それぞれが３個の `octet$T 引数をとる，２個の`演算$が宣言される。
一方には３個すべての引数に `EnforceRange$x `拡張属性$が利用され，他方はそうでない：
◎
In the following IDL fragment, two operations are declared that take three octet arguments; one uses the [EnforceRange] extended attribute on all three arguments, while the other does not:
</p>

<pre class="idl-code">
interface GraphicsContext {
  void setColor(octet red, octet green, octet blue);
  void setColorEnforcedRange([EnforceRange] octet red, [EnforceRange] octet green, [EnforceRange] octet blue);
};
</pre>

<p>
この~IDLの~JS実装においては、
`octet$T の範囲~外の `Number^t 値を渡して
`setColorEnforcedRange^M を~callしたときの結果は、例外の投出になる。
◎
In an ECMAScript implementation of the IDL, a call to setColorEnforcedRange with Number values that are out of range for an octet will result in an exception being thrown.
</p>

<pre class="es-code">
// <span class="comment"
	title="Get an instance of GraphicsContext."
>`GraphicsContext^T の~instanceを取得する。</span>
var context = getGraphicsContext();

/* <span class="comment"
	title="Calling the non-[EnforceRange] version uses ToUint8 to coerce the Numbers to octets.
This is equivalent to calling setColor(255, 255, 1)."
>非 `EnforceRange^x 版の~callは実数~値を~octetに強制する ToUint8 を利用する。これは `setColor(255, 255, 1)^c の~callと等価になる。</span> */
context.setColor(-1, 255, 257);

/* <span class="comment"
	title="When setColorEnforcedRange is called, Numbers are rounded towards zero.
This is equivalent to calling setColor(0, 255, 255)."
>実数~値は `setColorEnforcedRange^M が~callされる際にゼロ側に丸められる。
これは `setColor(0, 255, 255)^c の~callと等価になる。</span> */
context.setColorEnforcedRange(-0.9, 255, 255.2);

/* <span class="comment"
	title="The following will cause a TypeError to be thrown, since even after
rounding the first and third argument values are out of range."
>次は `TypeError^t を投出させる。丸められた後でも，第一, 第三~引数は範囲~外になるので。</span> */
context.setColorEnforcedRange(-1, 255, 256);
</pre>
</div>


			</section>
			<section id="Exposed">

<h4>3.3.4. `Exposed^x</h4>

<p>
`Exposed$x `拡張属性$が［
`~ifc$ ／
`部分的~ifc定義$ ／
`名前空間$ ／
`部分的~名前空間~定義$ ／
個々の`~ifc~mb$ ／
個々の`名前空間~mb$
］上に現れた場合、その構成子が特定0の［
大域~ifcの集合
］上に公開されることを指示する
—
既定による，`主~大域~ifc$上でのみ公開されるのではなく。
◎
If the [Exposed] extended attribute appears on an interface, partial interface, namespace, partial namespace, or an individual interface member or namespace member, it indicates that the construct is exposed on a particular set of global interfaces, rather than the default of being exposed only on the primary global interface.
</p>

<p>
`Exposed$x `拡張属性$には、
`識別子を引数にとる$か, または
`識別子~listを引数にとる$ことが要求される。
引数に挙げられた各~識別子は`大域~名$で~MUST。
◎
The [Exposed] extended attribute must either take an identifier or take an identifier list. Each of the identifiers mentioned must be a global name.
</p>

<p>
`Exposed$x `拡張属性$を指定し得る どの構成子も，
`公開~集合@
を持つ
— それは、`~ifc$の集合であり，その構成子が どの大域環境で利用し得るかを定義する。
所与の構成子に対する`公開~集合$は、次で定義される：
◎
Every construct that the [Exposed] extended attribute can be specified on has an exposure set, which is a set of interfaces defining which global environments the construct can be used in. The exposure set for a given construct is defined as follows:
</p>

<ul>
	<li>
［
`Exposed$x `拡張属性$が指定されている構成子
］の`公開~集合$は，［
その拡張属性の引数に挙げられている いずれかの`大域~名$
］を持つ~ifcからなる。
◎
If the [Exposed] extended attribute is specified on the construct, then the exposure set is the set of all interfaces that have a global name that is listed in the extended attribute’s argument.
</li>
	<li>
<p>
下に挙げる構成子のうち， `Exposed$x 拡張属性が現れないものに対しては、その構成子の型に依存して，その`公開~集合$が暗黙的に定義される：
◎
If the [Exposed] extended attribute does not appear on a construct, then its exposure set is defined implicitly, depending on the type of construct:
</p>

<dl class="switch">
	<dt>~ifc◎interface</dt>
	<dt>名前空間◎namespace</dt>
	<dd>
`主~大域~ifc$のみからなる。
◎
The exposure set of the interface or namespace only contains the primary global interface.
</dd>

	<dt>部分的~ifc◎partial interface</dt>
	<dt>部分的~名前空間◎partial namespace</dt>
	<dd>
元の［
~ifc／名前空間
］定義の`公開~集合$と同じ。
◎
The exposure set of the partial interface or namespace is the exposure set of the original interface or namespace definition.
</dd>

	<dt>~ifc~mb◎interface member</dt>
	<dd>
その~mbが宣言されている［
~ifc／部分的~ifc
］の`公開~集合$と同じ。
◎
The exposure set of the interface member is the exposure set of the interface or partial interface the member is declared on.
</dd>

	<dt>名前空間~mb◎namespace member</dt>
	<dd>
その~mbが宣言されている［
名前空間／部分的~名前空間
］の`公開~集合$と同じ。
◎
The exposure set of the namespace member is the exposure set of the namespace or partial namespace the member is declared on.
</dd>
</dl>
	</li>
</ul>


<p>
`Exposed$x 拡張属性は：
</p>

<ul>
	<li>
［
`多重定義$されている`演算$
］上に現れるときは、その演算のすべての多重定義~上に，引数も含めて全く同じに現れ~MUST。
◎
If [Exposed] appears on an overloaded operation, then it must appear identically on all overloads.
</li>
	<li>
［
~ifc~mbと, それを宣言している部分的~ifc定義
］の両者に指定されては~MUST_NOT。
◎
The [Exposed] extended attribute must not be specified on both an interface member and a partial interface definition the interface member is declared on. Similarly, the [Exposed] extended attribute must not be specified on both a namespace member and a partial namespace definition the namespace member is declared on.
</li>
	<li>
［
名前空間~mbと, それを宣言している部分的~名前空間~定義
］の両者に指定されては~MUST_NOT。
◎
↑</li>
	<li>
~ifc~mb %m 上に現れた場合、
%m の`公開~集合$は， %m が宣言されている［
~ifc／部分的~ifc
］の`公開~集合$の部分集合で~MUST。
◎
If [Exposed] appears an interface member, then the interface member’s exposure set must be a subset of the exposure set of the interface or partial interface it’s a member of. Similarly, if [Exposed] appears on a namespace member, then the namespace member’s exposure set must be a subset of the exposure set of the namespace or partial namespace it’s a member of.
</li>
	<li>
名前空間~mb %m 上に現れた場合、
%m の`公開~集合$は， %m が宣言されている［
名前空間／部分的~名前空間
］の`公開~集合$の部分集合で~MUST。
◎
↑</li>
</ul>

<p>
~ifcの`公開~集合$は：
◎
↓</p>

<ul>
	<li>
その`帰結~ifc$すべての`公開~集合$の和集合の部分集合で~MUST。
◎
An interface’s exposure set must be a subset of the exposure set of all of the interface’s consequential interfaces.
</li>
	<li>
別の~ifcを`継承-$しているならば、その~ifcの`公開~集合$の部分集合で~MUST。
◎
If an interface X inherits from another interface Y then the exposure set of X must be a subset of the exposure set of Y.
</li>
</ul>

<p>
［
`~ifc$ ／ `名前空間$ ／ `~ifc~mb$ ／ `名前空間~mb$
］ %X が，所与の~JS大域環境 %G において
`公開され@
るとは、 %G が［
%X の`公開~集合$に属する ある~ifc
］を実装していて，次のいずれかを満たすことを意味する：
◎
An interface, namespace, interface member, or namespace member is exposed in a given ECMAScript global environment if the ECMAScript global object implements an interface that is in the construct’s exposure set, and either:
</p>

<ul>
	<li>
~JS大域~objに`関連する設定群~obj$は
`保安的~文脈$であるか, または
◎
the relevant settings object for the ECMAScript global object is a secure context; or
</li>
	<li>
%X は`保安的~文脈~下に限り可用になる$，ではない。
◎
the construct is not available only in secure contexts.
</li>
</ul>

<p class="note">注記：
~JS大域~objに`関連する設定群~obj$が`保安的~文脈$であるかどうかは，変化し得ないので、
%X に対する~propを作成するかどうかの実装による決断は、`初期~obj$を作成する時点の一度限りになる。
◎
Note: Since it is not possible for the relevant settings object for an ECMAScript global object to change whether it is a secure context or not over time, an implementation’s decision to create properties for an interface or interface member can be made once, at the time the initial objects are created.
</p>


<p>
`Exposed$x の利用に課される固有の要件については
`es-interfaces$sec,
`es-constants$sec,
`es-attributes$sec,
`es-operations$sec,
`es-iterators$sec
に。
◎
See §3.6 Interfaces, §3.6.5 Constants, §3.6.6 Attributes, §3.6.7 Operations and §3.6.8 Common iterator behavior for the specific requirements that the use of [Exposed] entails.
</p>

<div class="example">
<p>
`Exposed$x には、［
~ifc ／
名前空間 ／
個々の~ifc~mb ／
個々の名前空間~mb
］を［
`Worker^T <span class="trans-note">【
<a href="http://dev.w3.org/html5/workers/">~Web Workers</a>
】</span>
や `Window^T, あるいはその両者
］の中でのみ可用にするかどうかを制御する用途が意図されている。
◎
[Exposed] is intended to be used to control whether interfaces, namespaces, or individual interface or namespace members are available for use only in workers, only in the Window, or in both.
</p>

<p>
それがどのように得られるかを，次の~IDL片に示す：
◎
The following IDL fragment shows how that might be achieved:
</p>

<pre class="idl-code">
[PrimaryGlobal]
interface Window {
  // ...
};

/* <span class="comment"
	title="By using the same identifier Worker for both SharedWorkerGlobalScope
	and DedicatedWorkerGlobalScope, both can be addressed in an [Exposed]
	extended attribute at once."
>`SharedWorkerGlobalScope^T と `DedicatedWorkerGlobalScope^T
の両者に同じ識別子 `Worker^l を利用する
— 両者は `Exposed^x 拡張属性からまとめて指せるようになる。</span> */
[Global=Worker]
interface SharedWorkerGlobalScope : WorkerGlobalScope {
  // ...
};

[Global=Worker]
interface DedicatedWorkerGlobalScope : WorkerGlobalScope {
  // ...
};

/* <span class="comment"
	title="Dimensions is available for use in workers and on the main thread."
>`Dimensions^T は、［ 主thread上と~workerの中 ］でのみ可用。</span> */
[Exposed=(Window,Worker), Constructor(double width, double height)]
interface Dimensions {
  readonly attribute double width;
  readonly attribute double height;
};

/* <span class="comment"
	title="WorkerNavigator is only available in workers.  Evaluating WorkerNavigator
	in the global scope of a worker would give you its interface object, while
	doing so on the main thread will give you a ReferenceError."
>`WorkerNavigator^T は~workerの中でのみ可用。
~workerの大域~scopeの中で `WorkerNavigator^T を評価したときは~ifc~objを得られる一方で、主thread上でそうしたときは `ReferenceError^t になる。</span> */
[Exposed=Worker]
interface WorkerNavigator {
  // ...
};

/* <span class="comment"
	title="Node is only available on the main thread.  Evaluating Node
	in the global scope of a worker would give you a ReferenceError."
>`Node^T は主thread上でのみ可用。
~workerの大域~scopeの中で `Node^T を評価したときは `ReferenceError^t になる。</span> */
interface Node {
  // ...
};

/* <span class="comment"
	title="MathUtils is available for use in workers and on the main thread."
>`MathUtils^T は、［ 主thread上と~workerの中 ］でのみ可用。</span> */
[Exposed=(Window,Worker)]
namespace MathUtils {
  static double someComplicatedFunction(double x, double y);
};

/* <span class="comment"
	title="WorkerUtils is only available in workers.  Evaluating WorkerUtils
	in the global scope of a worker would give you its namespace object, while
	doing so on the main thread will give you a ReferenceError."
>`WorkerUtils^T は，~workerの中でのみ可用。
~workerの大域~scopeの中で `WorkerUtils^T を評価したときは その名前空間~objを得られる一方で、主thread上でそうしたときは `ReferenceError^t になる。</span> */
[Exposed=Worker]
namespace WorkerUtils {
  void setPriority(double x);
};

/* <span class="comment"
	title="NodeUtils is only available in the main thread.  Evaluating NodeUtils
	in the global scope of a worker would give you a ReferenceError."
>`NodeUtils^T は主thread上でのみ可用。
~workerの大域~scopeの中で `Node^T を評価したときは `ReferenceError^t になる。</span> */
namespace NodeUtils {
  DOMString getAllText(Node node);
};



</pre>

</div>


			</section>
			<section id="Global">
<h4 title="[Global] and [PrimaryGlobal]">3.3.5. `Global^x と `PrimaryGlobal^x</h4>

<p>
［
`Global$x ／
<dfn id="PrimaryGlobal">`PrimaryGlobal^x</dfn>
］`拡張属性$が `~ifc$上に現れた場合、その~ifcを実装している~objは
~JS環境にて大域~objとして利用できることを指示する。
また、原型鎖の構造, および［
`~ifc~mb$に対応する~propが原型~obj上にどのように反映されるか
］についても、他の~ifcと異なるものにされることを指示する。
より明確には：
◎
If the [Global] or [PrimaryGlobal] extended attribute appears on an interface, it indicates that objects implementing this interface can be used as the global object in an ECMAScript environment, and that the structure of the prototype chain and how properties corresponding to interface members will be reflected on the prototype objects will be different from other interfaces. Specifically:
</p>

<ol>
	<li>
どの`有名~prop$も，~obj自身ではなく,
原型鎖の中の~obj
— `有名~prop~obj$ —
上にて公開されることになる。
◎
Any named properties will be exposed on an object in the prototype chain – the named properties object – rather than on the object itself.
</li>
	<li>
`~ifc$のどの`広義~帰結~ifc$のどの`~ifc~mb$も、`~ifc原型~obj$上ではなく, ~obj自身の~propに対応することになる。
◎
Interface members from the interface (or consequential interfaces) will correspond to properties on the object itself rather than on interface prototype objects.
</li>
</ol>

<div class="note">
<p>
原型鎖の中の~obj上に置かれる有名~propは、変数~宣言とそのままの名前の代入を通して，大域~obj自身の~propにより隠蔽される。
◎
Placing named properties on an object in the prototype chain is done so that variable declarations and bareword assignments will shadow the named property with a property on the global object itself.
</p>

<p>
~ifc~mbに対応する~propを~obj自身の上に置くことは、次の様な，特色機能を検出するためによく利用される手法が機能することになることを意味する：
<!-- 機能しない？ -->
◎
Placing properties corresponding to interface members on the object itself will mean that common feature detection methods like the following will work:
</p>

<pre class="es-code">
var indexedDB = window.indexedDB || window.webkitIndexedDB ||
                window.mozIndexedDB || window.msIndexedDB;

var requestAnimationFrame = window.requestAnimationFrame ||
                            window.mozRequestAnimationFrame || ...;
</pre>

<p>
~JSにおける変数~宣言が取扱われる仕方から，代入が評価される前に隠蔽する変数~propが作成されることになるので、上の~codeでは，
`window.indexedDB^c
と
`window.requestAnimationFrame^c
が `undefined^v に評価されることになる。
◎
Because of the way variable declarations are handled in ECMAScript, the code above would result in the window.indexedDB and window.requestAnimationFrame evaluating to undefined, as the shadowing variable property would already have been created before the assignment is evaluated.
</p>
</div>

<p>
`Global$x ／ `PrimaryGlobal$x
`拡張属性$が利用された`~ifc$に対しては：
◎
If the [Global] or [PrimaryGlobal] extended attributes is used on an interface, then:
</p>


<ul>
	<li>
`有名~prop設定子$が定義されては~MUST_NOT。
◎
The interface must not define a named property setter.
</li>
	<li>
自身およびその`被継承~ifc$は，
`OverrideBuiltins$x 拡張属性が伴われて宣言されては~MUST_NOT。
◎
The interface must not also be declared with the [OverrideBuiltins] extended attribute.
◎
The interface must not inherit from another interface with the [OverrideBuiltins] extended attribute.
</li>
	<li>
他の~ifcが`継承-$しては~MUST_NOT。
◎
Any other interface must not inherit from it.
</li>
</ul>


<p><!-- copy* -->
`Global$x ／ `PrimaryGlobal$x が`部分的~ifc定義$上に指定される場合、その部分的~ifc定義は，~ifc定義の中で`有名~prop取得子$を定義する部分をなすもので~MUST。
◎
If [Global] or [PrimaryGlobal] is specified on a partial interface definition, then that partial interface definition must be the part of the interface definition that defines the named property getter.
</p>

<p>
`Global$x ／ `PrimaryGlobal$x
`拡張属性$は、同じ~JS大域環境において，複数の~objから実装され得るような`~ifc$上に利用されては~MUST_NOT。
◎
The [Global] and [PrimaryGlobal] extended attribute must not be used on an interface that can have more than one object implementing it in the same ECMAScript global environment.
</p>

<p class="note">注記：
これは、有名~propを公開する`有名~prop~obj$が 原型鎖の中にあるものであり、複数の［~objの有名~prop］を，それらの~objを継承する１個の~obj上で公開することに意味が無いからである。
◎
Note: This is because the named properties object, which exposes the named properties, is in the prototype chain, and it would not make sense for more than one object’s named properties to be exposed on an object that all of those objects inherit from.
</p>

<p>
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴って宣言された~ifcにおいては、そのどの２つの`広義~帰結~ifc$の間でも，`識別子$が同じになる`~ifc~mb$が存在しては~MUST_NOT。
また、それらの~ifcに渡って，［
複数の`文字列化子$ ／
複数の`直列化子$ ／
複数の［
`可反復~宣言$, `~maplike 宣言$, `~setlike 宣言$
<span class="trans-note">【混在も含む】</span>
］］が存在しては~MUST_NOT。
◎
If an interface is declared with the [Global] or [PrimaryGlobal] extended attribute, then there must not be more than one interface member across the interface and its consequential interfaces with the same identifier. There also must not be more than one stringifier, more than one serializer, or more than one iterable declaration, maplike declaration or setlike declaration across those interfaces.
</p>

<p class="note">注記：
その理由は、~ifcとその帰結~ifcの~mbすべてが、~ifcを実装する~objに平坦化されるからである。
◎
Note: This is because all of the members of the interface and its consequential interfaces get flattened down on to the object that implements the interface.
</p>


<p>
`Global$x ／ `PrimaryGlobal$x 拡張属性は， 1 個~以上の大域~ifcに同じ名前を付けて、その名前を通して `Exposed$x 拡張属性から参照する目的にも利用できる。
◎
The [Global] and [PrimaryGlobal] extended attributes can also be used to give a name to one or more global interfaces, which can then be referenced by the [Exposed] extended attribute.
</p>

<p>
`Global$x ／ `PrimaryGlobal$x 拡張属性には、［
`引数をとらない$
か, または
`識別子~listを引数にとる$
］ことが要求される。
◎
The [Global] and [PrimaryGlobal] extended attributes must either take no arguments or take an identifier list.
</p>

<p>
`Global$x ／ `PrimaryGlobal$x
`拡張属性$が宣言されている~ifcは， 1 個~以上の
`大域~名@
を持つ：
拡張属性が 識別子~listを引数に伴うならば，それらの識別子が~ifcの大域~名になり、他の場合，~ifc自身の識別子が~ifcの~~唯一の大域~名になる。
◎
If the [Global] or [PrimaryGlobal] extended attribute is declared with an identifier list argument, then those identifiers are the interface’s global names; otherwise, the interface has a single global name, which is the interface’s identifier.
</p>

<p class="note">注記：
識別子~list引数は、 `Exposed$x `拡張属性$の中の単独の名前で，複数の大域~ifcを指せるようにするためにある。
◎
Note: The identifier argument list exists so that more than one global interface can be addressed with a single name in an [Exposed] extended attribute.
</p>

<p>
`Global$x, `PrimaryGlobal$x の両`拡張属性$が，同じ~ifc上に宣言されては~MUST_NOT。
`PrimaryGlobal$x 拡張属性が宣言される~ifcは<!-- ある大域環境において実装が~supportする~ifcの集合の中で -->，高々 1 個で~MUST。
`PrimaryGlobal$x が宣言された~ifcは、
`主~大域~ifc@
と呼ばれる。
◎
The [Global] and [PrimaryGlobal] extended attributes must not be declared on the same interface. The [PrimaryGlobal] extended attribute must be declared on at most one interface. The interface [PrimaryGlobal] is declared on, if any, is known as the primary global interface.
</p>


<p>
有名~propにおける
`Global$x ／ `PrimaryGlobal$x
の利用に課される固有の要件については
`named-properties-object$sec,
`getownproperty$sec,
`defineownproperty$sec
に。
`~ifc~mb$に対応する~propの所在に関する要件については
`es-constants$sec,
`es-attributes$sec,
`es-operations$sec
に。
◎
See §3.6.4 Named properties object, §3.8.3 Platform object [[GetOwnProperty]] method and §3.8.8 Platform object [[DefineOwnProperty]] method for the specific requirements that the use of [Global] and [PrimaryGlobal] entails for named properties, and §3.6.5 Constants, §3.6.6 Attributes and §3.6.7 Operations for the requirements relating to the location of properties corresponding to interface members.
</p>

<div class="example">
<p>
`PrimaryGlobal$x は、
<a href="~BROWSERS#window">`Window^T</a><!-- ＊ -->
~ifcからの利用が意図されている。
（ `Global$x は，~worker大域~ifcからの利用が意図されている。）
`Window^T ~ifcは frame を `Window^T ~obj上の~propとして公開する。
`Window^T ~objは~JS大域~objとしても機能するので、有名~propに対する代入や変数~宣言は、新たな値への置換-になる。
属性に対する変数~宣言は、既存のものを置換する~propを作成しない。
◎
The [PrimaryGlobal] extended attribute is intended to be used by the Window interface. ([Global] is intended to be used by worker global interfaces.) The Window interface exposes frames as properties on the Window object. Since the Window object also serves as the ECMAScript global object, variable declarations or assignments to the named properties will result in them being replaced by the new value. Variable declarations for attributes will not create a property that replaces the existing one.
</p>

<pre class="idl-code">
[PrimaryGlobal]
interface Window {
  getter any (DOMString name);
  attribute DOMString name; 
   // ...
};
</pre>

<p>
次の HTML 文書では、
`Window^T ~obj上の有名~propが隠蔽され,
属性に対する~propは同じ名前の変数が宣言されても置換されない：
◎
The following HTML document illustrates how the named properties on the Window object can be shadowed, and how the property for an attribute will not be replaced when declaring a variable of the same name:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;title&gt;<span class="comment"
	title="Variable declarations and assignments on Window"
	>Window 上の変数~宣言と代入</span>&lt;/title&gt;
&lt;iframe name=abc&gt;&lt;/iframe&gt;
&lt;!-- <span class="comment"
	title="Shadowing named properties">有名~propを隠蔽する</span> --&gt;
&lt;script&gt;
  window.abc;    // <span class="comment"
	title="Evaluates to the iframe’s Window object."
>`iframe^c の `Window^T ~objに評価される。</span>
  abc = 1;       // <span class="comment"
	title="Shadows the named property."
>有名~propを隠蔽する。</span>
  window.abc;    // <span class="comment"
	title="Evaluates to 1." id="cp-eval-1"
>`1^v に評価される。</span>
&lt;/script&gt;

&lt;!-- <span class="comment"
	title="Preserving properties for IDL attributes"
>~IDL属性に対する~propは保全される</span> --&gt;
&lt;script&gt;
  Window.prototype.def = 2;         // <span class="comment"
	title="Places a property on the prototype."
>原型~上に~propを置く。</span>
  window.hasOwnProperty("length");  // <!--cp-eval-true-->

  length;        // <!--cp-eval-1-->
  def;           // <span class="comment"
	title="Evaluates to 2."
>`2^v に評価される。</span>
&lt;/script&gt;

&lt;script&gt;
  var length;    // <span class="comment"
	title="Variable declaration leaves existing property."
>この変数~宣言は既存の~propに触らない。</span>
  length;        // <!--cp-eval-1-->
  var def;       // <span class="comment"
	title="Variable declaration creates shadowing property."
>この変数~宣言は隠蔽する~propを作成する。</span>
  def;           // <!--cp-eval-undefined-->
&lt;/script&gt;
</pre>

</div>

			</section>
			<section id="LegacyArrayClass" class="L2">
<h4>3.3.6. `LegacyArrayClass^x</h4>

<p>
`LegacyArrayClass$x `拡張属性$が［
他を`継承-$しないように定義された`~ifc$
］上に現れた場合、その`~ifc原型~obj$の `Prototype^es 内部~propは，
`Object^t 原型~objではなく,
`Array^t 原型~objになる。
これにより、その~ifcを実装している~objにおいて，
`Array^t ~methを容易く利用できるようになる。
◎
If the [LegacyArrayClass] extended attribute appears on an interface that is not defined to inherit from another, it indicates that the internal [[Prototype]] property of its interface prototype object will be the Array prototype object rather than the Object prototype object. This allows Array methods to be used more easily with objects implementing the interface.
</p>

<div class="p">
<p>
`LegacyArrayClass$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`被継承~ifc$を持つ~ifcに利用されては~MUST_NOT：
</li></ul>

◎
The [LegacyArrayClass] extended attribute must take no arguments. It must not be used on an interface that has any inherited interfaces.
</div>


<p class="note">注記：
`LegacyArrayClass$x を利用する~ifcには、継承される `Array^t ~methが正しく演算するように、配列に類似するような，~objの長さを公開する［
型 `unsigned long^t の `length^l `属性$
］を定義する必要がある。
そのような~ifcは、概して，配列~要素への~accessを提供する`有index~propを~supportする$ことになるであろう。
◎
Note: Interfaces using [LegacyArrayClass] will need to define a “length” attribute of type unsigned long that exposes the length of the array-like object, in order for the inherited Array methods to operate correctly. Such interfaces would typically also support indexed properties, which would provide access to the array elements.
</p>

<p>
`LegacyArrayClass$x の利用に課される固有の要件については
`interface-prototype-object$sec
に。
◎
See §3.6.3 Interface prototype object for the specific requirements that the use of [LegacyArrayClass] entails.
</p>

<div class="example">

<p>
次の`~IDL片$は、 `LegacyArrayClass$x を利用する２つの`~ifc$を定義する。
◎
The following IDL fragment defines two interfaces that use [LegacyArrayClass].
</p>

<pre class="idl-code">
[LegacyArrayClass]
interface ItemList {
  attribute unsigned long length;
  getter object getItem(unsigned long index);
  setter object setItem(unsigned long index, object item);
};

[LegacyArrayClass]
interface ImmutableItemList {
  readonly attribute unsigned long length;
  getter object getItem(unsigned long index);
};
</pre>

<p>
上の２つの~ifcの
`getItem^c, `setItem^c, `removeItem^c
の適切な定義を伴う
~JS実装においては、配列に類似する~objを検分したり改変するための `Array^t ~methを利用できる：
◎
In an ECMAScript implementation of the above two interfaces, with appropriate definitions for getItem, setItem and removeItem, Array methods to inspect and modify the array-like object can be used.
</p>

<pre class="es-code">
var list = getItemList();  // <span class="comment"
	title="Obtain an instance of ItemList."
>`ItemList^T の~instanceを得る。</span>

list.concat();             // <span class="comment"
	title="Clone the ItemList into an Array."
>%list を `Array^t の中に~cloneする。</span>
list.pop();                // <span class="comment"
	title="Remove an item from the ItemList."
>%list から項目を除去する。</span>
list.unshift({ });         // <span class="comment"
	title="Insert an item at index 0."
>項目を~index 0 の位置に挿入する。</span>
</pre>

<p>
`ImmutableItemList^T は、読専の `length^c `属性$を持ち，
`有index~prop設定子$を持たない。
`ImmutableItemList^T を実装する~obj上では、一般に `Array^t を改変する~methは失敗することになる。
正確な挙動は
<a href="~TC39#sec-properties-of-the-array-prototype-object">`Array^t ~meth自身</a>
の定義に依存する。
◎
ImmutableItemList has a read only length attribute and no indexed property setter. The mutating Array methods will generally not succeed on objects implementing ImmutableItemList. The exact behavior depends on the definition of the Array methods themselves.
</p>

</div>

			</section>
			<section id="LegacyUnenumerableNamedProperties" class="L2">
<h4>3.3.7. `LegacyUnenumerableNamedProperties^x</h4>

<p id="dfn-unenumerable"><!--＊-->
`LegacyUnenumerableNamedProperties$x `拡張属性$が［
`有名~propを~supportする$`~ifc$
］に現れた場合、その~ifc上の すべての有名~propは，列挙不可であることを指示する。
◎
If the [LegacyUnenumerableNamedProperties] extended attribute appears on a interface that supports named properties, it indicates that all the interface’s named properties are unenumerable.
</p>

<div class="p">
<p>
`LegacyUnenumerableNamedProperties$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`有名~prop取得子$を定義しない~ifc上に現れては~MUST_NOT。
</li><li>当の~ifcのすべての派生~ifcにも適用され、それらには，この拡張属性は指定されては~MUST_NOT。
</li></ul>

◎
The [LegacyUnenumerableNamedProperties] extended attribute must take no arguments and must not appear on an interface that does not define a named property getter.
◎
If the [LegacyUnenumerableNamedProperties] extended attribute is specified on an interface, then it applies to all its derived interfaces and must not be specified on any of them.
</div>

<p>
`LegacyUnenumerableNamedProperties$x の利用に課される固有の要件については、`property-enumeration$secに。
◎
See §3.8.12 Property enumeration for the specific requirements that the use of [LegacyUnenumerableNamedProperties] entails.
</p>


			</section>
			<section id="LenientSetter" class="L2">
<h4>3.3.8. `LenientSetter^x</h4>

<p>
`LenientSetter$x `拡張属性$が［
`読専$の`正則~属性$
］に現れた場合、［
属性の~accessor~propとして，何もしない設定子が生成される
］ことを指示する。
その結果，~strict-mode下では、~propに対する誤った代入に対しては，例外は投出されずに無視されるようになる。
◎
If the [LenientSetter] extended attribute appears on a read only regular attribute, it indicates that a no-op setter will be generated for the attribute’s accessor property. This results in erroneous assignments to the property in strict mode to be ignored rather than causing an exception to be thrown.
</p>

<div class="advisement">
<p>
仕様は、互換性の理由から要求されない限り，
`LenientSetter$x を利用するべきでない。
<!-- observed -->
~pageにて、作者が当の~propへの代入ingにより~IDL属性を~polyfillしようと試みていて、~propが存在するときでも不用意にそうしたとする。
~strict-mode下では、これは例外を投出させ，~pageを壊すことになりかねない。
`LenientSetter$x が無いと、このことから~browserは，将来に出荷できなくなる。
◎
Specifications should not use [LenientSetter] unless required for compatibility reasons. Pages have been observed where authors have attempted to polyfill an IDL attribute by assigning to the property, but have accidentally done so even if the property exists. In strict mode, this would cause an exception to be thrown, potentially breaking page. Without [LenientSetter], this could prevent a browser from shipping the feature.
</p>

<p>
これを将来に利用したいと望む仕様~策定者は、`論ML^。
◎
Specification authors who wish to use this feature are strongly advised to discuss this on the public-script-coord@w3.org mailing list before proceeding.
</p>

</div>

<div class="p">
<p>
`LenientSetter$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`読専$の`正則~属性$以外に利用されては~MUST_NOT。
</li><li>同じ属性~上で，
`PutForwards$x ／ `Replaceable$x
拡張属性と併用されては~MUST_NOT。
</li></ul>

◎
The [LenientThis] extended attribute must take no arguments. It must not be used on anything other than a read only regular attribute.
◎
An attribute with the [LenientSetter] extended attribute must not also be declared with the [PutForwards] or [Replaceable] extended attributes.
</div>

<p>
`LenientSetter$x がどう実装されるかの詳細は、
`es-attributes$sec に。
◎
See the Attributes section for how [LenientSetter] is to be implemented.
</p>

<div class="example">

<p>
次の~IDL片は `LenientSetter$x 拡張属性を利用する~ifcを定義する。
◎
The following IDL fragment defines an interface that uses the [LenientSetter] extended attribute.
</p>

<pre class="idl-code">
interface Example {
  [LenientSetter] readonly attribute DOMString x;
  readonly attribute DOMString y;
};
</pre>

<p>
この~ifcを~supportする~JS実装は， `x^M に対応する~accessor~prop上に設定子を持つことになり、~strict-mode下では，どのような代入も無視されるようになる。
◎
An ECMAScript implementation that supports this interface will have a setter on the accessor property that correspond to x, which allows any assignment to be ignored in strict mode.
</p>

<pre class="es-code">
"use strict";

var example = getExample();  // <span class="comment"
	title="Get an instance of Example."
>`Example^T の~instanceを取得する。</span>

// <span class="comment"
	title="Fine; while we are in strict mode, there is a setter that is a no-op."
>~~問題ない。~strict-mode下では，何もしない設定子がある。</span>
example.x = 1;

// <span class="comment"
	title="Throws a TypeError, since we are in strict mode and there is no setter."
>`TypeError^t が投出される。~strict-mode下にあり，設定子がないので。</span>
example.y = 1;
</pre>

</div>

			</section>
			<section id="LenientThis">
<h4>3.3.9. `LenientThis^x</h4>

<p>
`LenientThis$x `拡張属性$が `正則~属性$上に現れた場合、その属性が現れる`~ifc$を実装する~objとは異なる `this^v 値を伴うような，その属性の取得子や設定子の呼出は、無視されることになる。
◎
If the [LenientThis] extended attribute appears on a regular attribute, it indicates that invocations of the attribute’s getter or setter with a this value that is not an object that implements the interface on which the attribute appears will be ignored.
</p>

<div class="p">
<p>
`LenientThis$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`静的~属性$上に利用されては~MUST_NOT。
</li></ul>
◎
The [LenientThis] extended attribute must take no arguments. It must not be used on a static attribute.
</div>


<p class="advisement"><!-- copy* -->
互換性の理由から要求されない限り、仕様は `LenientThis$x を利用するべきでない。
この特色機能を要する仕様~策定者は、`論ML^。
◎
Specifications should not use [LenientThis] unless required for compatibility reasons. Specification authors who wish to use this feature are strongly advised to discuss this on the public-script-coord@w3.org mailing list before proceeding.
</p>

<p>
`LenientThis$x がどう実装されるかについては、
`es-attributes$sec
に。
◎
See the Attributes section for how [LenientThis] is to be implemented.
</p>

<div class="example">
<p>
次の~IDL片は
`LenientThis$x 拡張属性を利用する
~ifcを定義する。
◎
The following IDL fragment defines an interface that uses the [LenientThis] extended attribute.
</p>

<pre class="idl-code">
interface Example {
  [LenientThis] attribute DOMString x;
  attribute DOMString y;
};
</pre>

<p>
この~ifcを~supportする~JS実装では、 `x^M に対応する~accessor~propの取得子／設定子では，
`Example^T ~obj以外の何かを伴う呼出しも許容されることになる。
◎
An ECMAScript implementation that supports this interface will allow the getter and setter of the accessor property that corresponds to x to be invoked with something other than an Example object.
</p>

<pre class="es-code">
var example = getExample();  // <span class="comment"
	title="Get an instance of Example."
>`Example^T の~instanceを取得する。</span>
var obj = { };

/* <span class="comment"
	title="Fine."
>~~通常。</span> */
example.x;

/* <span class="comment"
	title="Ignored, since the this value is not an Example object and [LenientThis] is used."
>この値は `Example^T ~objでなく, かつ
`LenientThis^x が利用されているので、無視される。</span> */
Object.getOwnPropertyDescriptor(Example.prototype, "x").get.call(obj);

/* <span class="comment"
	title="Also ignored, since Example.prototype is not an Example object and [LenientThis] is used."
>`Example.prototype^v は `Example^T ~objでなく, かつ
`LenientThis^x が利用されているので、これも無視される。</span> */
Example.prototype.x;

/* <span class="comment"
	title="Throws a TypeError, since Example.prototype is not an Example object."
>`Example.prototype^v は `Example^T ~objでないので `TypeError^t が投出される。</span> */
Example.prototype.y;
</pre>
</div>
			</section>
			<section id="NamedConstructor">
<h4>3.3.10. `NamedConstructor^x</h4>


<div class="p">

<p>
`NamedConstructor$x `拡張属性$が `~ifc$上に現れた場合、~JS大域~objは，次を伴う~propを持つことになる：
</p>

<ul><li>その名前は、拡張属性の引数に指定された名前。
</li><li>値は、その~ifcを実装する~objを作成できる構築子~関数。
</li></ul>

<p>
所与の~ifc上に，複数の `NamedConstructor$x 拡張属性が現れてもよい。
</p>
◎
If the [NamedConstructor] extended attribute appears on an interface, it indicates that the ECMAScript global object will have a property with the specified name whose value is a constructor function that can create objects that implement the interface. Multiple [NamedConstructor] extended attributes may appear on a given interface.
</div>


<p>
`NamedConstructor$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`識別子を引数にとる$か, または`有名~引数~listを引数にとる$ことが要求される。
前者の形
<code>[NamedConstructor=`identifier$g]</code>
は、空の引数~list
<code>[NamedConstructor=`identifier$g()]</code>
を利用するのと同じ意味になる。
~ifc上の各 `NamedConstructor$x 拡張属性が、［［
前述の~propの値である構築子~関数
］に，指定された引数を渡して、その~ifcを実装する~objを構築する仕方
］を供することになる。
◎
The [NamedConstructor] extended attribute must either take an identifier or take a named argument list. The first form, [NamedConstructor=identifier], has the same meaning as using an empty argument list, [NamedConstructor=identifier()]. For each [NamedConstructor] extended attribute on the interface, there will be a way to construct an object that implements the interface by passing the specified arguments to the constructor function that is the value of the aforementioned property.
</li>
	<li>
<p>
次に挙げる識別子は、有名~構築子の識別子として利用されては~MUST_NOT：
</p>

<ul ><li>別の~ifc上の `NamedConstructor$x 拡張属性の識別子
</li><li>`~ifc~obj$を持つ~ifcの識別子
</li><li>`予約済み識別子$
</li></ul>

◎
The identifier used for the named constructor must not be the same as that used by an [NamedConstructor] extended attribute on another interface, must not be the same as an identifier of an interface that has an interface object, and must not be one of the reserved identifiers.
</li>
	<li>
`呼戻~ifc$上に利用されては~MUST_NOT。
◎
The [NamedConstructor] extended attribute must not be used on a callback interface.
</li>
</ul>

<p>
有名~構築子がどう実装されるかの詳細は
`named-constructors$sec
に。
◎
See §3.6.2 Named constructors for details on how named constructors are to be implemented.
</p>


<div class="example">
<p>
次の~IDLは
`NamedConstructor$x 拡張属性を利用する~ifcを定義する。
◎
The following IDL defines an interface that uses the [NamedConstructor] extended attribute.
</p>

<pre class="idl-code">
[NamedConstructor=Audio,
 NamedConstructor=Audio(DOMString src)]
interface HTMLAudioElement : HTMLMediaElement {
  // <span class="comment">...</span>
};
</pre>

<p>
この~ifcを~supportする~JS実装は、
`Audio^T 構築子を利用する `HTMLAudioElement^T ~objの構築を許容することになる。
◎
An ECMAScript implementation that supports this interface will allow the construction of HTMLAudioElement objects using the Audio constructor.
</p>

<pre class="es-code">
typeof Audio;                   // <!--cp-eval-function-->

var a1 = new Audio();
   /* <span class="comment"
	title="Creates a new object that implements
HTMLAudioElement, using the zero-argument
constructor."
>引数なしの構築子を利用して， `HTMLAudioElement^T を実装する ~objを作成する。</span> */

var a2 = new Audio('a.flac');
   /* <span class="comment"
	title="Creates an HTMLAudioElement using the
one-argument constructor."
>１引数の構築子を利用して， `HTMLAudioElement^T を作成する。</span> */
</pre>
</div>


			</section>
			<section id="NewObject">
<h4>3.3.11. `NewObject^x</h4>

<p>
`NewObject$x `拡張属性$が［
`正則~演算$／`静的~演算$
］上に現れた場合、その演算が~callされる際に，常に
新たに作成された~objへの参照が返され~MUSTことを指示する。
◎
If the [NewObject] extended attribute appears on a regular or static operation, then it indicates that when calling the operation, a reference to a newly created object must always be returned.
</p>

<p>
`NewObject$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [NewObject] extended attribute must take no arguments.
</li>
	<li>
`返値型$が［
`~ifc型$, または `~promise型$
］である［
`正則~演算$／`静的~演算$
］以外の所に利用されては~MUST_NOT。
◎
The [NewObject] extended attribute must not be used on anything other than a regular or static operation whose return type is an interface type or a promise type.
</li>
</ul>

<div class="example">
<p>
この拡張属性の利用が適する一例には，
<a href="https://dom.spec.whatwg.org/#document">`Document^T</a>
~ifc（ `DOM$r, 6.5 節）上の
<a href="https://dom.spec.whatwg.org/#dom-document-createelement">createElement</a>
演算がある。
これは，~callされる度に新たな~objが返されるべきなので。
◎
As an example, this extended attribute is suitable for use on the createElement operation on the Document interface ([DOM], section 6.5), since a new object should always be returned when it is called.
</p>

<pre class="idl-code">
interface Document : Node {
  [NewObject] Element createElement(DOMString localName);
  // ...
};
</pre>

</div>

			</section>
			<section id="NoInterfaceObject">
<h4>3.3.12. `NoInterfaceObject^x</h4>


<p>
`NoInterfaceObject$x `拡張属性$が `~ifc$上に現れた場合、その~ifcに対応する`~ifc~obj$は，~JS言語束縛には存在しないことになる。
◎
If the [NoInterfaceObject] extended attribute appears on an interface, it indicates that an interface object will not exist for the interface in the ECMAScript binding.
</p>


<p class="advisement">
`NoInterfaceObject$x 拡張属性は、明白な~Web互換性の理由がない限り，もっぱら`追補~ifc$として利用されるもの以外の~ifcには、利用されるべきでない。
この特色機能を要する仕様~策定者は、`論ML^。
◎
The [NoInterfaceObject] extended attribute should not be used on interfaces that are not solely used as supplemental interfaces, unless there are clear Web compatibility reasons for doing so. Specification authors who wish to use this feature are strongly advised to discuss this on the public-script-coord@w3.org mailing list before proceeding.
</p>

<p>
`NoInterfaceObject$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [NoInterfaceObject] extended attribute must take no arguments.
</li>
	<li>
同じ~ifc上で， `Constructor$x 拡張属性と併用されては~MUST_NOT。
一方， `NamedConstructor$x 拡張属性との併用は差し支えない。
◎
If the [NoInterfaceObject] extended attribute is specified on an interface, then the [Constructor] extended attribute must not also be specified on that interface. A [NamedConstructor] extended attribute is fine, however.
</li>
	<li>
`静的~演算$が定義されている~ifc上に指定されては~MUST_NOT。
◎
The [NoInterfaceObject] extended attribute must not be specified on an interface that has any static operations defined on it.
</li>
	<li>
`定数$が宣言されてる場合を除き，`呼戻~ifc$上に指定されては~MUST_NOT。
`定数$を伴わない呼戻~ifcは，`~ifc~obj$を決して持たないので。
◎
The [NoInterfaceObject] extended attribute must not be specified on a callback interface unless it has a constant declared on it. This is because callback interfaces without constants never have interface objects.
</li>
	<li>
この拡張属性が指定されていない~ifcが，この拡張属性が指定されている~ifcを継承しては~MUST_NOT
◎
An interface that does not have the [NoInterfaceObject] extended attribute specified must not inherit from an interface that has the [NoInterfaceObject] extended attribute specified.
</li>
</ul>


<p>
`NoInterfaceObject$x の利用に課される固有の要件については、`es-interfaces$secに。
◎
See §3.6 Interfaces for the specific requirements that the use of [NoInterfaceObject] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は２つの~ifcを定義する。
１つはその~ifc~objが~JS大域~obj上に公開され，もう１つはそうでない：
◎
The following IDL fragment defines two interfaces, one whose interface object is exposed on the ECMAScript global object, and one whose isn’t:
</p>

<pre class="idl-code">
interface Storage {
  void addEntry(unsigned long key, any value);
};

[NoInterfaceObject]
interface Query {
  any lookupEntry(unsigned long key);
};
</pre>

<p>
上の~IDLの~JS実装においては、
`Storage^T に対する原型の操作は許容される一方，
`Query^T に対してはそうならない。
◎
An ECMAScript implementation of the above IDL would allow manipulation of Storage’s prototype, but not Query’s.
</p>

<pre class="es-code">
typeof Storage;                        // <span class="comment"
	title="evaluates to &quot;object&quot;"
>`object^l に評価される。</span>

// <span class="comment"
	title="Add some tracing alert() call to Storage.addEntry."
>`Storage.addEntry^c に~trace用の `alert()^c ~callを追加する</span>
var fn = Storage.prototype.addEntry;
Storage.prototype.addEntry = function(key, value) {
  alert('Calling addEntry()');
  return fn.call(this, key, value);
};

typeof Query;                          // <span class="comment"
	title="evaluates to &quot;undefined&quot;"
>`undefined^l に評価される。</span>
var fn = Query.prototype.lookupEntry;  // <span class="comment"
	title="exception, Query isn’t defined"
>例外を投出。 `Query^T は定義されていない。</span>
</pre>
</div>
			</section>
			<section id="OverrideBuiltins">
<h4>3.3.13. `OverrideBuiltins^x</h4>


<p>
`OverrideBuiltins$x `拡張属性$が `~ifc$上に現れた場合，その~ifcを実装する`~platform~obj$においては、［
その~objやその原型鎖
］上に存在する他の~propに関わらず，~objの`被support~prop名$すべてに対し，それぞれに対応する~propがその~obj上に現れることになる。
このことは、（通例の挙動では、有名~propは［
~obj自身やその原型鎖
］上のどこにも同じ名前の~propが存在しないときに限り，公開されるのに対し、）有名~propが、［
さもなければ~obj上に現れることになる，同じ名前のどの~prop
］も，常に隠蔽することになることを意味する。
◎
If the [OverrideBuiltins] extended attribute appears on an interface, it indicates that for a platform object implementing the interface, properties corresponding to all of the object’s supported property names will appear to be on the object, regardless of what other properties exist on the object or its prototype chain. This means that named properties will always shadow any properties that would otherwise appear on the object. This is in contrast to the usual behavior, which is for named properties to be exposed only if there is no property with the same name on the object itself or somewhere on its prototype chain.
</p>

<div class="p">
<p>
`OverrideBuiltins$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`有名~prop取得子$を定義しない~ifc上に現れては~MUST_NOT。
</li><li>`Global$x ／ `PrimaryGlobal$x
拡張属性と併用されては~MUST_NOT。
</li><li>`部分的~ifc定義$上に指定される場合、その部分的~ifc定義は，~ifc定義の中で`有名~prop取得子$を定義する部分をなすもので~MUST。
</li></ul>

◎
The [OverrideBuiltins] extended attribute must take no arguments and must not appear on an interface that does not define a named property getter or that also is declared with the [Global] or [PrimaryGlobal] extended attribute. If the extended attribute is specified on a partial interface definition, then that partial interface definition must be the part of the interface definition that defines the named property getter.
</div>

<p>
`OverrideBuiltins$x の利用に課される固有の要件については
`indexed-and-named-properties$sec, `defineownproperty$sec
に。
◎
See §3.8.1 Indexed and named properties and §3.8.8 Platform object [[DefineOwnProperty]] method for the specific requirements that the use of [OverrideBuiltins] entails. 
</p>

<div class="example">
<p>
次の`~IDL片$は２つの`~ifc$を定義する。
一方は`有名~prop取得子$を持ち, 他方はそうでない：
◎
The following IDL fragment defines two interfaces, one that has a named property getter and one that does not.
</p>

<pre class="idl-code">
interface StringMap {
  readonly attribute unsigned long length;
  getter DOMString lookup(DOMString key);
};

[OverrideBuiltins]
interface StringMap2 {
  readonly attribute unsigned long length;
  getter DOMString lookup(DOMString key);
};
</pre>

<p>
これら２つの~ifcの~JS実装においては、それぞれの~ifcを実装する~obj上の一部の~propについて，その取得による結果が異なってくることになる：
◎
In an ECMAScript implementation of these two interfaces, getting certain properties on objects implementing the interfaces will result in different values:
</p>

<pre class="es-code">
/* <span class="comment"
	title="Obtain an instance of StringMap.  Assume that it has &quot;abc&quot;, &quot;length&quot; and
&quot;toString&quot; as supported property names."
>`StringMap^T の~instanceを得る。
被support~prop名として， `abc^l, `length^l, `toString^l を持つとする。</span> */
var map1 = getStringMap();

/* <span class="comment"
	title="This invokes the named property getter."
>有名~prop取得子を呼出す。</span> */
map1.abc;

/* <span class="comment"
	title="This fetches the &quot;length&quot; property on the object that corresponds to the
length attribute."
>`length^M 属性に対応する~obj上の `length^l ~propを取りに行く。</span> */
map1.length;

/* <span class="comment"
	title="This fetches the &quot;toString&quot; property from the object’s prototype chain."
>~objの原型鎖~上の `toString^l ~propを取りに行く。</span> */
map1.toString;


/* <span class="comment"
	title="Obtain an instance of StringMap2.  Assume that it also has &quot;abc&quot;, &quot;length&quot;
and &quot;toString&quot; as supported property names."
>`StringMap2^T の~instanceを得る。
これも被support~prop名として， `abc^l, `length^l, `toString^l を持つとする。</span> */
var map2 = getStringMap2();  

/* <span class="comment"
	title="This invokes the named property getter."
>これは 有名~prop取得子を呼出す。</span> */
map2.abc;

/* <span class="comment"
	title="This also invokes the named property getter, despite the fact that the &quot;length&quot;
property on the object corresponds to the length attribute."
>これも 有名~prop取得子を呼出す。
~obj上の `length^l ~propが length 属性に対応しているにも関わらず。</span> */
map2.length;

/* <span class="comment"
	title="This too invokes the named property getter, despite the fact that &quot;toString&quot; is
a property in map2’s prototype chain."
>これもまた 有名~prop取得子を呼出す。
`toString^l が %map2 の prototype chain 内にある~propであるにも関わらず。</span> */
map2.toString;
</pre>
</div>
			</section>
			<section id="PutForwards">
<h4>3.3.14. `PutForwards^x</h4>


<p>
`PutForwards$x `拡張属性$が［
`~ifc型$の`読専$の`正則~属性$宣言
］上に現れた場合、その属性への代入ingは 固有の挙動を持つことになる。
すなわち，その代入は、代入-が試みられた属性から，現在~参照されている~objの属性（その拡張属性の引数で指定される）に “転送-” される。
◎
If the [PutForwards] extended attribute appears on a read only regular attribute declaration whose type is an interface type, it indicates that assigning to the attribute will have specific behavior. Namely, the assignment is “forwarded” to the attribute (specified by the extended attribute argument) on the object that is currently referenced by the attribute being assigned to.
</p>

<p>
`PutForwards$x 拡張属性には、`識別子を引数にとる$ことが要求される。
次が与えられるとき：
◎
The [PutForwards] extended attribute must take an identifier. Assuming that:
</p>

<ul>
	<li>
%A は
`PutForwards$x 拡張属性が現れる`属性$,
◎
A is the attribute on which the [PutForwards] extended attribute appears,
</li>
	<li>
%I は
%A が宣言されている`~ifc$,
◎
I is the interface on which A is declared,
</li>
	<li>
%J は
%A の型として宣言されている `~ifc型$, <!--  -->
◎
J is the interface type that A is declared to be of, and
</li>
	<li>
%N は
その拡張属性の`識別子$引数,
◎
N is the identifier argument of the extended attribute,
</li>
</ul>

<p>
このとき，`識別子$ %N を持つ別の`属性$ %B が
%J 上に宣言されてい~MUST。
%I を実装している~obj上の属性 %A への値の代入では、代わりに，
%A が参照する~objの属性 %B にその値が代入されることになる。
◎
then there must be another attribute B declared on J whose identifier is N. Assignment of a value to the attribute A on an object implementing I will result in that value being assigned to attribute B of the object that A references, instead.
</p>

<p>
`PutForwards$x 注釈付きの`属性$は連鎖し得ることに注意。
すなわち、
`PutForwards$x `拡張属性$を伴う属性は，この拡張属性を持つ他の属性を指すことができる。
ただし、この代入の連鎖が循環しては~MUST_NOT。
代入の連鎖が辿られる際に，１つの`~ifc$上の特定0の属性に複数~回 遭遇するならば、循環が存在する。
◎
Note that [PutForwards]-annotated attributes can be chained. That is, an attribute with the [PutForwards] extended attribute can refer to an attribute that itself has that extended attribute. There must not exist a cycle in a chain of forwarded assignments. A cycle exists if, when following the chain of forwarded assignments, a particular attribute on an interface is encountered more than once.
</p>

<p>
`PutForwards$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
同じ属性~上で，
`LenientSetter$x ／ `Replaceable$x
拡張属性と併用されては~MUST_NOT。
◎
An attribute with the [PutForwards] extended attribute must not also be declared with the [LenientSetter] or [Replaceable] extended attributes.
</li>
	<li>
`読専$でない`属性$~上に利用されては~MUST_NOT。
◎
The [PutForwards] extended attribute must not be used on an attribute that is not read only.
</li>
	<li>
`静的~属性$上に利用されては~MUST_NOT。
◎
The [PutForwards] extended attribute must not be used on a static attribute.
</li>
	<li>
`呼戻~ifc$上で宣言される属性~上に利用されては~MUST_NOT。
◎
The [PutForwards] extended attribute must not be used on an attribute declared on a callback interface.
</li>
</ul>

<p>
`PutForwards$x がどう実装されるかについては、
`es-attributes$sec
に。
◎
See the Attributes section for how [PutForwards] is to be implemented.
</p>

<div class="example">
<p>
次の`~IDL片$は、姓名と人を表す~ifcを定義する。
`Person^T ~ifcの `name^M 属性~上に利用される `PutForwards$x 拡張属性は、その属性への代入による結果が `Person^T ~objの
<span class="trans-note">【
`name^M 属性が指す `Name^T ~objの
】</span>
`full^M 属性への代入になることを指示する：
◎
The following IDL fragment defines interfaces for names and people. The [PutForwards] extended attribute is used on the name attribute of the Person interface to indicate that assignments to that attribute result in assignments to the full attribute of the Person object:
</p>

<pre class="idl-code">
interface Name {
  attribute DOMString full;
  attribute DOMString family;
  attribute DOMString given;
};

interface Person {
  [PutForwards=full] readonly attribute Name name;
  attribute unsigned short age;
};
</pre>

<p>
~JS言語束縛においては、
`name^l ~propへの代入が許容されることになる：
◎
In the ECMAScript binding, this would allow assignments to the “name” property:
</p>

<pre class="es-code">
var p = getPerson();           // <span class="comment"
	title="Obtain an instance of Person."
>`Person^T の~instanceを得る。</span>

p.name = 'John Citizen';       // <span class="comment"
	title="This statement..."
>この文は...</span>
p.name.full = 'John Citizen';  // <span class="comment"
	title="...has the same behavior as this one."
>...これと同じ挙動になる。</span>
</pre>
</div>
			</section>
			<section id="Replaceable">
<h4>3.3.15. `Replaceable^x</h4>


<p>
`Replaceable$x `拡張属性$が `読専$の`正則~属性$上に現れた場合、`~platform~obj$上の対応する~propが設定される際に、その~obj上に，代入される値をとる同じ名前の自前の~propが作成されることになる。
この~propは、
`~ifc原型~obj$上に存在する，その属性に対応する~accessor~propを隠蔽する。
◎
If the [Replaceable] extended attribute appears on a read only regular attribute, it indicates that setting the corresponding property on the platform object will result in an own property with the same name being created on the object which has the value being assigned. This property will shadow the accessor property corresponding to the attribute, which exists on the interface prototype object.
</p>

<p>
`Replaceable$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Replaceable] extended attribute must take no arguments.
</li>
	<li>
同じ属性~上で，
`LenientSetter$x ／ `Replaceable$x
拡張属性と併用されては~MUST_NOT。
◎
An attribute with the [Replaceable] extended attribute must not also be declared with the [LenientSetter] or [PutForwards] extended attributes.
</li>
	<li>
`読専$でない`属性$~上に利用されては~MUST_NOT。
◎
The [Replaceable] extended attribute must not be used on an attribute that is not read only.
</li>
	<li>
`静的~属性$上に利用されては~MUST_NOT。
◎
The [Replaceable] extended attribute must not be used on a static attribute.
</li>
	<li>
`呼戻~ifc$上で宣言される属性に利用されては~MUST_NOT。
◎
The [Replaceable] extended attribute must not be used on an attribute declared on a callback interface.
</li>
</ul>

<p>
`Replaceable$x の利用に課される固有の要件については
`es-attributes$sec
に。
◎
See §3.6.6 Attributes for the specific requirements that the use of [Replaceable] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は、計数を増やす`演算$と，計数~値を公開する初期~値 0 の`属性$を持つ`~ifc$を定義する：
◎
The following IDL fragment defines an interface with an operation that increments a counter, and an attribute that exposes the counter’s value, which is initially 0:
</p>

<pre class="idl-code">
interface Counter {
  [Replaceable] readonly attribute unsigned long value;
  void increment();
};
</pre>

<p>
`Counter^T を実装する `~platform~obj$上の
`value^l ~propへの代入ingにより，その`属性$に対応する~propは隠蔽されることになる：
◎
Assigning to the “value” property on a platform object implementing Counter will shadow the property that corresponds to the attribute:
</p>

<pre class="es-code">
var counter = getCounter();         // <span class="comment"
	title="Obtain an instance of Counter."
>`Counter^T の~instanceを得る。</span>
counter.value;                      // <span class="comment"
	title="Evaluates to 0."
>`0^v に評価される。</span>

counter.hasOwnProperty("value");    // <!--cp-eval-false-->
Object.getPrototypeOf(counter).hasOwnProperty("value");
                                    // <!--cp-eval-true-->

counter.increment();
counter.increment();
counter.value;                      // <span class="comment"
	title="Evaluates to 2."
>`2^v に評価される。</span>

counter.value = 'a';                
       // <span class="comment"
	title="Shadows the property with one that is unrelated
to Counter::value."
>`Counter::value^V に関係無いもので~propを隠蔽する。</span>

counter.hasOwnProperty("value");    // <!--cp-eval-true-->

counter.increment();
counter.value;                      // <span class="comment"
	title="Evaluates to 'a'."
>`a^l に評価される。</span>

delete counter.value;               // <span class="comment"
	title="Reveals the original property."
>元の~propを露にする。</span>
counter.value;                      // <span class="comment"
	title="Evaluates to 3."
>`3^v に評価される。</span>
</pre>
</div>

			</section>
			<section id="SameObject">
<h4>3.3.16. `SameObject^x</h4>


<p>
`SameObject$x `拡張属性$が `読専$`属性$に現れた場合、所与の~obj上でその属性の値が取得される度に，常に同じ値が返され~MUSTことを指示する。
◎
If the [SameObject] extended attribute appears on a read only attribute, then it indicates that when getting the value of the attribute on a given object, the same value must always be returned.
</p>

<p>
`SameObject$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [SameObject] extended attribute must take no arguments.
</li>
	<li>
［［
`~ifc型$／`~obj型$
］である`読専$`属性$
］以外の所に利用されては~MUST_NOT。
◎
The [SameObject] extended attribute must not be used on anything other than a read only attribute whose type is an interface type or object.
</li>
</ul>


<div class="example">
<p>
この拡張属性の利用が適する一例には，
<a href="https://dom.spec.whatwg.org/#document">`Document^T</a>
~ifc（ `DOM$r, 6.5 節）上の
<a href="https://dom.spec.whatwg.org/#dom-document-implementation">`implementation^c</a>
属性がある。
所与の `Document^T ~objに対しては，常に同じ~objが返されるので。
◎
As an example, this extended attribute is suitable for use on the implementation attribute on the Document interface ([DOM], section 6.5), since the same object is always returned for a given Document object.
</p>

<pre class="idl-code">
interface Document : Node {
  [SameObject] readonly attribute DOMImplementation implementation;
  // ...
};
</pre>
</div>

			</section>
			<section id="SecureContext">
<h4>3.3.17. `SecureContext^x</h4>

<p>
`SecureContext$x `拡張属性$が［
`~ifc$ ／
`部分的~ifc定義$ ／
`名前空間$ ／
`部分的~名前空間~定義$ ／
`~ifc~mb$ ／
`名前空間~mb$
］ %X 上に現れた場合、 %X は `保安的~文脈$の中でのみ公開されることを指示する。
◎
If the [SecureContext] extended attribute appears on an interface, partial interface, namespace, partial namespace, interface member, or namespace member, it indicates that the construct is exposed only within a secure context.
</p>

<p>
`SecureContext$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [SecureContext] extended attribute must take no arguments.
</li>
	<li>
［
`~ifc$ ／
`部分的~ifc定義$ ／
`名前空間$ ／
`部分的~名前空間~定義$ ／
`~ifc~mb$ ／
`名前空間~mb$
］以外のものに利用されては~MUST_NOT。
◎
The [SecureContext] extended attribute must not be used on anything other than an interface, partial interface, namespace, partial namespace, interface member, or namespace member.
</li>
</ul>

<p>
［
`SecureContext$x `拡張属性$を指定できるような
］構成子 %X が
`保安的~文脈~下に限り可用になる@
かどうかは、次に従って定義される：
◎
Whether a construct that the [SecureContext] extended attribute can be specified on is available only in secure contexts is defined as follows:
</p>

<ul>
	<li>
%X に `SecureContext$x `拡張属性$が指定されているならば、
%X は，`保安的~文脈~下に限り可用になる$。
◎
If the [SecureContext] extended attribute is specified on the construct, then it is available only in secure contexts.
</li>
	<li>
<p>
指定されていない場合に %X が`保安的~文脈~下に限り可用になる$かどうかは、
%X の型に依存する：
◎
Otherwise, if the [SecureContext] extended attribute does not appear on a construct, then whether it is available only in secure contexts depends on the type of construct:
</p>

		<dl class="switch">
			<dt>~ifc</dt>
			<dt>名前空間</dt>
			<dd>
%X は`保安的~文脈~下に限り可用になる$，ではない。
◎
The interface or namespace is not available only in secure contexts.
</dd>
			<dt>部分的~ifc</dt>
			<dt>部分的~名前空間</dt>
			<dd>
%X が`保安的~文脈~下に限り可用になる$のは、元の
~ifc／名前空間
定義がそうであるとき，そのときに限る。
◎
The partial interface or partial namespace is available only in secure contexts if and only if the original interface or namespace definition is.
</dd>
			<dt>~ifc~mb</dt>
			<dd>
%X が`保安的~文脈~下に限り可用になる$のは、 %X を宣言している［
~ifc／部分的~ifc定義
］がそうであるとき，そのときに限る。
◎
The interface member is available only in secure contexts if and only if the interface or partial interface the member is declared on is.
</dd>
			<dt>名前空間~mb</dt>
			<dd>
%X が`保安的~文脈~下に限り可用になる$のは、 %X を宣言している［
名前空間／部分的~名前空間~定義
］がそうであるとき，そのときに限る。
◎
The namespace member is available only in secure contexts if and only if the namspace or partial namespace the member is declared on is.
</dd>
		</dl>
	</li>
</ul>

<p class="note">注記：
構成子が`保安的~文脈~下に限り可用になる$かどうかは、所与の~JS大域環境にて`公開され$るかどうかに波及する。
◎
Note: Whether a construct is available only in secure contexts influences whether it is exposed in a given ECMAScript global environment.
</p>


<p>
`SecureContext$x 拡張属性は：
</p>

<ul>
	<li>
`多重定義$されている`演算$上に現れるならば，他のすべての多重定義~上にも現れ~MUST。
◎
If [SecureContext] appears on an overloaded operation, then it must appear on all overloads.
</li>
	<li>
［
~ifc~mbと, それを宣言している［
~ifc／部分的~ifc定義
］］の両者に指定されては~MUST_NOT。
◎
The [SecureContext] extended attribute must not be specified on both an interface member and the interface or partial interface definition the interface member is declared on, or on both a namespace member and the namespace or partial namespace definition the namespace member is declared on.
</li>
	<li>
［
名前空間~mbと, それを宣言している［
名前空間／部分的~名前空間~定義
］］の両者に指定されては~MUST_NOT。
◎
↑</li>
	<li>
~ifc上に現れるならば、それを`継承-$するどの~ifc上にも現れ~MUST。
◎
An interface without the [SecureContext] extended attribute must not inherit from another interface that does specify [SecureContext].
</li>
</ul>

<div class="example">
<p>
次の`~IDL片$は、すべての文脈で実行-可能な 1 個の`演算$, および
保安的~文脈からのみ実行-可能な  1 個の演算と 1 個の属性を伴う~ifcを定義する：
◎
The following IDL fragment defines an interface with one operation that is executable from all contexts, and two which are executable only from secure contexts.
</p>

<pre class="idl-code">
interface PowerfulFeature {
/* <span class="comment"
	title="This call will succeed in all contexts."
>次の演算の~callはどの文脈~下でも成功する。</span> */
  Promise &lt;Result&gt; calculateNotSoSecretResult();

/* <span class="comment"
	title="This operation will not be exposed to a non-secure context. In such a context, there will be no &quot;calculateSecretResult&quot; property on PowerfulFeature.prototype."
>保安的でない文脈~下では、次の演算は公開されなくなる。
`PowerfulFeature.prototype^c 上に
`calculateSecretResult^l ~propはない。</span> */
  [SecureContext] Promise&lt;Result&gt; calculateSecretResult();

/* <span class="comment"
	title="The same applies here: the attribute will not be exposed to a non-secure context, and in a non-secure context there will be no &quot;secretBoolean&quot; property on PowerfulFeature.prototype."
>次の属性にも同じことが言え、保安的でない文脈には公開されなくなる
— `PowerfulFeature.prototype^c 上に
`secretBoolean^l ~propはない。</span> */
  [SecureContext] readonly attribute boolean secretBoolean;
};
</pre>

</div>

			</section>
			<section id="TreatNonObjectAsNull">
<h4>3.3.18. `TreatNonObjectAsNull^x</h4>


<p>
`TreatNonObjectAsNull$x `拡張属性$が `呼戻~関数$上に現れた場合、
`属性$に代入される［
`~nullable$`呼戻~関数$型であって, ~objではない
］どの値も， `null^V 値に変換するようにすることを指示する。
◎
If the [TreatNonObjectAsNull] extended attribute appears on a callback function, then it indicates that any value assigned to an attribute whose type is a nullable callback function that is not an object will be converted to the null value.
</p>

<p class="advisement">
仕様は、旧来の~APIの挙動の指定, もしくは
それらの~APIとの整合性が要求されていない限り，
`TreatNonObjectAsNull$x
を利用するべきでない。
この特色機能を要する仕様~策定者は、`論ML^。
この文書が書かれた時点での，
`TreatNonObjectAsNull$x の妥当な既知の用途は、
`onclick^c, `onerror^c などの`~event-handler~IDL属性$の型として利用される`呼戻~関数$のみである。
◎
Specifications should not use [TreatNonObjectAsNull] unless required to specify the behavior of legacy APIs or for consistency with these APIs. Specification authors who wish to use this feature are strongly advised to discuss this on the public-script-coord@w3.org mailing list before proceeding. At the time of writing, the only known valid use of [TreatNonObjectAsNull] is for the callback functions used as the type of event handler IDL attributes such as onclick and onerror.
</p>

<p>
`TreatNonObjectAsNull$x の利用に課される固有の要件については
`es-nullable-type$sec
に。
◎
See §3.2.17 Nullable types — T? for the specific requirements that the use of [TreatNonObjectAsNull] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は、
`TreatNonObjectAsNull$x 注釈付きの`呼戻~関数$型の属性と,
この`拡張属性$を伴わない`呼戻~関数$を持つ~ifcを定義する。
◎
The following IDL fragment defines an interface that has one attribute whose type is a [TreatNonObjectAsNull]-annotated callback function and another whose type is a callback function without the extended attribute:
</p>

<pre class="idl-code">
callback OccurrenceHandler = void (DOMString details);

[TreatNonObjectAsNull]
callback ErrorHandler = void (DOMString details);

interface Manager {
  attribute OccurrenceHandler? handler1;
  attribute ErrorHandler? handler2;
};
</pre>

<p>
~JS実装においては、
`handler1^c に対する~objでない値（ `Number^t 値など）の代入ingは，
`handler2^c に対する代入ingの挙動と異なる：
◎
In an ECMAScript implementation, assigning a value that is not an object (such as a Number value) to handler1 will have different behavior from that when assigning to handler2:
</p>

<pre class="es-code">
var manager = getManager();  // <span class="comment"
	title="Get an instance of Manager."
>`Manager^T の~instanceを取得する。</span>

manager.handler1 = function() { };
manager.handler1;            // <span class="comment" id="cp-eval-the-function"
	title="Evaluates to the function."
>当の function に評価される。</span>

try {
  manager.handler1 = 123;    // <span class="comment"
	title="Throws a TypeError."
>`TypeError^t を投出。</span>
} catch (e) {
}

manager.handler2 = function() { };
manager.handler2;            // <!--cp-eval-the-function-->

manager.handler2 = 123;
manager.handler2;            // <span class="comment"
	title="Evaluates to null."
>`null^v に評価される。</span>
</pre>

</div>

			</section>
			<section id="TreatNullAs">
<h4>3.3.19. `TreatNullAs^x</h4>


<p>
`TreatNullAs$x `拡張属性$が［
`DOMString$T 型の［
`属性$ ／ `演算$の引数
］］上に現れた場合、［
その属性に代入される ／ その演算の引数に渡される
］ `null^v 値は、既定による `null^l に文字列化される代わりに，空~文字列 "" に変換されることになる。
◎
If the [TreatNullAs] extended attribute appears on an attribute or operation argument whose type is DOMString, it indicates that a null value assigned to the attribute or passed as the operation argument will be handled differently from its default handling. Instead of being stringified to “null”, which is the default, it will be converted to the empty string “”.
</p>

<p>
`TreatNullAs$x が演算~自身に指定されていて，その演算が`呼戻~ifc$上にある場合、その
<a href="#es-user-objects">~ifcを実装する利用者~obj</a>
においてその演算を実装する関数の返値は、上述の演算~引数や属性に対するときと同じ仕方で取扱われることになる。
◎
If [TreatNullAs] is specified on an operation itself, and that operation is on a callback interface, then it indicates that a user object implementing the interface will have the return value of the function that implements the operation handled in the same way as for operation arguments and attributes, as above.
</p>

<p>
`TreatNullAs$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
次の`識別子を引数にとる$ことが要求される：
`EmptyString^c
◎
The [TreatNullAs] extended attribute must take the identifier EmptyString.
</li>
	<li>
<p>
`DOMString$T でない演算~引数, 属性, 演算の返値に指定されては~MUST_NOT。
◎
The [TreatNullAs] extended attribute must not be specified on an operation argument, attribute or operation return value whose type is not DOMString.
</p>

<p class="note">注記：
すなわち、
`DOMString?^T 型の属性であっても，
`null^V はその型の妥当な値なので
`TreatNullAs$x が利用されてはならない。
◎
Note: This means that even an attribute of type DOMString? must not use [TreatNullAs], since null is a valid value of that type.
</p>
	</li>
	<li>
非~呼戻~ifc上の演算に指定されては~MUST_NOT
◎
The [TreatNullAs] extended attribute also must not be specified on an operation on a non-callback interface.
</li>
</ul>


<p>
`TreatNullAs$x の利用に課される固有の要件については
`es-DOMString$sec
に。
◎
See §3.2.9 DOMString for the specific requirements that the use of [TreatNullAs] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は、
`TreatNullAs$x 拡張属性を伴う属性と同じ拡張属性を伴う引数をとる演算を持つ，~ifcを定義する。
◎
The following IDL fragment defines an interface that has one attribute with the [TreatNullAs] extended attribute, and one operation with an argument that has the extended attribute:
</p>

<pre class="idl-code">
interface Dog {
  attribute DOMString name;
  [TreatNullAs=EmptyString] attribute DOMString owner;

  boolean isMemberOfBreed([TreatNullAs=EmptyString] DOMString breedName);
};
</pre>

<p>
`Dog^T ~ifcを実装する~JS実装においては、
`owner^l ~propに代入される, あるいは
`isMemberOfBreed^c 関数の引数に渡される `null^v 値は、
`null^l ではなく，空~文字列に変換されることになる：
◎
An ECMAScript implementation implementing the Dog interface would convert a null value assigned to the “owner” property or passed as the argument to the isMemberOfBreed function to the empty string rather than "null":
</p>

<pre class="es-code">
var d = getDog();         
       // <span class="comment"
	title="Assume d is a platform object implementing the Dog
interface."
>%d は `Dog^T ~ifcを実装する~platform~objとする。</span>

d.name = null;            // <span class="comment"
	title="This assigns the string &quot;null&quot; to the .name property."
>文字列 `null^l を `.name^c ~propに代入する。</span>

d.owner = null;           // <span class="comment"
	title="This assigns the string &quot;&quot; to the .owner property."
>文字列 "" を `.owner^c ~propに代入する。</span>

d.isMemberOfBreed(null);  // <span class="comment"
	title="This passes the string &quot;&quot; to the isMemberOfBreed
function."
>文字列 "" を `isMemberOfBreed^c 関数に渡す。</span>
</pre>
</div>
			</section>
			<section id="Unforgeable">
<h4>3.3.20. `Unforgeable^x</h4>


<p>
`Unforgeable$x `拡張属性$が［
静的でない［
`属性$／`演算$
］］上に現れた場合、その属性／演算は，［
その挙動を改変できない, かつ［
~obj上で~prop検索が遂行された際には，常にその属性の~prop値が返される
］］ような~JS~propとして反映されることになる。
特に，その~propは、非~configurableになり，かつ［
~objの原型~上ではなく, ~obj上の自前の~prop
］として存在することになる。
◎
If the [Unforgeable] extended attribute appears on a non-static attribute or non-static operations, it indicates that the attribute or operation will be reflected as an ECMAScript property in a way that means its behavior cannot be modified and that performing a property lookup on the object will always result in the attribute’s property value being returned. In particular, the property will be non-configurable and will exist as an own property on the object itself rather than on its prototype.
</p>

<p>
所与の~ifc %A のいずれかの`広義~帰結~ifc$上にて，
`Unforgeable$x `拡張属性$ 注釈付きで宣言されている属性／演算 は、
%A 上において
`偽装不可@
であるとされる。
<!-- “偽装不可” という対訳は概念的な意味で汎用性には欠くが，元々は保安~上の要求に端を発するものと見られる -->
◎
An attribute or operation is said to be unforgeable on a given interface A if the attribute or operation is declared on A or one of A’s consequential interfaces, and is annotated with the [Unforgeable] extended attribute.
</p>

<div>
<p>
`Unforgeable$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>静的でない［
`属性$, `演算$
］以外の所に現れては~MUST_NOT。
</li><li>ある演算~上に現れるならば、その~ifc上で同じ識別子を持つ他のすべての演算~上にも現れ~MUST。
</li></ul>

◎
The [Unforgeable] extended attribute must take no arguments.
◎
The [Unforgeable] extended attribute must not appear on anything other than an attribute or a non-static operation. If it does appear on an operation, then it must appear on all operations with the same identifier on that interface.
</div>

<p>
属性／演算 %m が，~ifc %A 上で`偽装不可$であって, かつ
%A が別の~ifc %B の`被継承~ifc$である場合、
%B の`広義~帰結~ifc$は，`識別子$が %m と同じであるような［静的でない属性］や`正則~演算$を持っては~MUST_NOT。
◎
If an attribute or operation X is unforgeable on an interface A, and A is one of the inherited interfaces of another interface B, then B and all of its consequential interfaces must not have a non-static attribute or regular operation with the same identifier as X.
</p>

<div class="note">

<p>
例えば，次は許容されない：
◎
For example, the following is disallowed:
</p>

<pre class="idl-code">
interface A1 {
[Unforgeable] readonly attribute DOMString x;
};
interface B1 : A1 {
  void x();  
       // <span class="comment"
	title="Invalid; would be shadowed by A1’s x."
>妥当でない： `A1^T の `x^M で隠蔽されるので。</span>
};

interface B2 : A1 { };
B2 implements Mixin;
interface Mixin {
  void x();  
       // <span class="comment"
	title="Invalid; B2’s copy of x would be shadowed by A1’s x."
>妥当でない： `B2^T における `x^M の複製は `A1^T の `x^M で隠蔽されるので。</span>
};
</pre>

</div>


<p>
`Unforgeable$x の利用に課される固有の要件については
`es-attributes$sec,
`es-operations$sec,
`es-platform-objects$sec,
`indexed-and-named-properties$sec,
`defineownproperty$sec
に。
◎
See §3.6.6 Attributes, §3.6.7 Operations, §3.8 Platform objects implementing interfaces, §3.8.1 Indexed and named properties and §3.8.8 Platform object [[DefineOwnProperty]] method for the specific requirements that the use of [Unforgeable] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は
片方に `Unforgeable$x が指定された２個の`属性$を持つ~ifcを定義する：
◎
The following IDL fragment defines an interface that has two attributes, one of which is designated as [Unforgeable]:
</p>

<pre class="idl-code">
interface System {
  [Unforgeable] readonly attribute DOMString username;
  readonly attribute long long loginTime; 
};
</pre>

<p>
この~ifcの~JS実装においては、
`username^M 属性は，~obj自身において非~configurable~propとして公開されることになる：
◎
In an ECMAScript implementation of the interface, the username attribute will be exposed as a non-configurable property on the object itself:
</p>

<pre class="es-code">
var system = getSystem();         // <span class="comment"
	title="Get an instance of System."
>`System^T の~instanceを取得する。</span>

system.hasOwnProperty("username");             // <!--cp-eval-true-->
system.hasOwnProperty("loginTime");            // <!--cp-eval-false-->
System.prototype.hasOwnProperty("username");   // <!--cp-eval-false-->
System.prototype.hasOwnProperty("loginTime");  // <!--cp-eval-true-->

try {
  // <span class="comment"
	title="This call would fail, since the property is non-configurable."
>この~callは失敗することになる — ~propは非~configurableなので。</span>
  Object.defineProperty(system, "username", { value: "administrator" });
} catch (e) { }

// <span class="comment"
	title="This defineProperty call would succeed, because System.prototype.loginTime
is configurable."
>次の `defineProperty^c ~callは成功する
— `System.prototype.loginTime^c が~configurableなので。</span>
var forgedLoginTime = 5;
Object.defineProperty(System.prototype, "loginTime", { value: forgedLoginTime });

system.loginTime;  // <span class="comment"
	title="So this now evaluates to forgedLoginTime."
>よって，これは今や %forgedLoginTime に評価される。</span>
</pre>
</div>
			</section>
			<section id="Unscopable" class="L2">

<h4>3.3.21. `Unscopable^x</h4>

<p>
`Unscopable$x `拡張属性$が［
`正則~属性$／`正則~演算$
］上に現れた場合、［
その~ifc~mbを伴う~ifcを実装する~obj
］が，［
その~prop名 %N を，それに伴うどの［
~obj環境 record
］内にも，その基底~objとして内包しない
］ことを指示する。
その~~結果、 `with^c 文の中では，［
%N に合致する “素の” 識別子
］は，その~propには解決されないことになる。
このふるまいは、 %N を［
`~ifc原型~obj$上の
`unscopables$esS ~propの値
］に含ませることで，得られる。
◎
If the [Unscopable] extended attribute appears on a regular attribute or regular operation, it indicates that an object that implements an interface with the given interface member will not include its property name in any object environment record with it as its base object. The result of this is that bare identifiers matching the property name will not resolve to the property in a with statement. This is achieved by including the property name on the interface prototype object’s @@unscopables property’s value.
</p>

<p>
`Unscopable$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Unscopable] extended attribute must take no arguments.
</li>
	<li>
［
`正則~属性$, `正則~演算$
］以外の所に現れては~MUST_NOT。
◎
The [Unscopable] extended attribute must not appear on anything other than a regular attribute or regular operation.
</li>
</ul>


<p>
`Unscopable$x の利用に課される固有の要件については
`interface-prototype-object$sec
に。
◎
See §3.6.3 Interface prototype object for the specific requirements that the use of [Unscopable] entails.
</p>

<div class="note">

<p>
例えば、次の~IDLが与えられたとき：
◎
For example, with the following IDL:
</p>

<pre class="idl-code">
interface Thing {
  void f();
  [Unscopable] g();
};
</pre>

<p>
`f^l ~propは、 `with^c 文の中で “素の” 識別子により参照できるが，
`g^l ~propはできない：
◎
the “f” property an be referenced with a bare identifier in a with statement but the “g” property cannot:
</p>

<pre class="es-code">
var thing = getThing();  // <span class="comment"
	title="An instance of Thing"
	>`Thing^T の~instance</span>
with (thing) {
  f;                     // <span class="comment"
	title="Evaluates to a Function object."
	>`Function^t ~objに評価される。</span>
  g;                     // <span class="comment"
	title="Throws a ReferenceError."
	>`ReferenceError^t を投出。</span>
}
</pre>

</div>

			</section>
		</section>
		<section id="es-security">
<h3 title="Security">3.4. 保安~検査</h3>

<p>
以下の節の一部の~algoでは、所与の~objに対し
`保安~検査を遂行する@
ものがある。
この検査は、所与の［
`演算$／`属性$
］ %M に対する［
呼出／~access
］が許容されるべきかどうかを決定するために利用される。
保安~検査に対する入力は次の 3 つである：
◎
Certain algorithms in the sections below are defined to perform a security check on a given object. This check is used to determine whether a given operation invocation or attribute access should be allowed. The security check takes the following three inputs: 
</p>

<ol>
	<li>
［
%M の呼出 ／ %M への~access
］が行われている当の`~platform~obj$
◎
the platform object on which the operation invocation or attribute access is being done,
</li>
	<li>
%M の`識別子$
◎
the identifier of the operation or attribute, and
</li>
	<li>
<p>
%M を実装する `Function^t ~objの種別
— 次のいずれかとして与えられる：
</p>
		<ul>
			<li>
`~meth^C
（ %M が演算に対応するとき）
</li>
			<li>
`取得子^C
（ %M が “取得子” 関数に対応するとき）
</li>
			<li>
`設定子^C
（ %M が “設定子” 関数に対応するとき）
</li>
		</ul>
◎
the type of the Function object – “method” (when it corresponds to an IDL operation), or “getter” or “setter” (when it corresponds to the getter or setter function of an IDL attribute).
</li>
</ol>


<p class="note">注記：
保安~検査がどう遂行されるかは、 HTML 仕様が定義する。
`HTML$r
◎
Note: The HTML Standard defines how a security check is performed. [HTML]
</p>



		</section>
		<section id="es-overloads">
<h3 title="Overload resolution algorithm">3.5. 多重定義~解決~algo</h3>

<div>
<p>
多重定義された`関数類$の呼出を解決するために，
`多重定義~解決~algo@
が定義される。
その入力は：
</p>

<ul><li>`有効~多重定義~集合$ %S
</li><li>~JS値の~list %arg<sub>0..%n−1</sub>
<!-- 
— 以下、~listの~index %i に位置する値を arg[%i], 
~listの長さを %n と記す
-->
</li></ul>

<p>
である。
その出力は，次の組である：
</p>

<ul><li>%S 内のいずれかの~entryの［
`演算$／`拡張属性$（構築子）
］
</li><li>各項が［
~IDL値, または`MISSING^
］のいずれかであるような，~list
</li></ul>

<p>
~algoは次に従って挙動する：
</p>

◎
In order to define how overloaded function invocations are resolved, the overload resolution algorithm is defined. Its input is an effective overload set, S, and a list of ECMAScript values, arg0..n−1. Its output is a pair consisting of the operation or extended attribute of one of S’s entries and a list of IDL values or the special value “missing”. The algorithm behaves as follows:
</div>

<ol class="algorithm">
	<li>
%maxarg := max( %S 内の各~entryの `ol-type-list^ の長さ )
◎
Let maxarg be the length of the longest type list of the entries in S.
</li>
	<li>
%argcount :← min(%maxarg,&nbsp;%n)
◎
Initialize argcount to be min(maxarg, n).
</li>
	<li>
%S から［
`ol-type-list^の長さ ~NEQ %argcount
］なる~entryすべてを除去する
◎
Remove from S all entries whose type list is not of length argcount.
</li>
	<li>
~IF
%S ~EQ ∅
~THEN
~THROW `TypeError^t
◎
If S is empty, then throw a TypeError.
</li>
	<li>
%d :← −1
◎
Initialize d to −1.
</li>
	<li>
%method :← `undefined^v
◎
Initialize method to undefined.
</li>
	<li>
~IF
%S に複数の~entryがある
~THEN
%d ← それらの %S の~entryに対する`判別引数~index$
◎
If there is more than one entry in S, then set d to be the distinguishing argument index for the entries of S.
</li>
	<li>
%values :← 空~list（各項が［
~IDL値, または`MISSING^
］のいずれかになる）
◎
Initialize values to be an empty list, where each entry will be either an IDL value or the special value “missing”.
</li>
	<li>
%i :← 0
◎
Initialize i to 0.
</li>
	<li>
<p>
~WHILE %i ~LT %d ：
◎
While i &lt; d:
</p>
		<ol>
			<li>
%V := %arg<sub>%i</sub>
◎
Let V be argi.
</li>
			<li>
<p>
%type := %S から任意に選んだ~entryの `ol-type-list^ の中の~index %i に位置する型
◎
Let type be the type at index i in the type list of any entry in S.
</p>

<p class="note">注記：
この時点では %S のすべての~entryにおいて，その~index %i に位置する［
`ol-type-list^ の型, および
`ol-optionality-list^の`省略可否 値$
］は 同じである。
<span class="trans-note">【
（下で利用されている）既定~値も
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22883">同じになる必要がある</a>
ように思われるが？
】</span>
◎
Note: All entries in S at this point have the same type and optionality value at index i.
</p>
</li>
			<li>
%optionality := %S から任意に選んだ~entryの `ol-optionality-list^ の中の~index %i に位置する`省略可否 値$
◎
Let optionality be the value at index i in the list of optionality values of any entry in S.
</li>
			<li id="cp-if-optional">
<p>
~IF［
%optionality ~EQ “`省略可^C”
］~AND［
%V ~EQ `undefined^v
］
⇒
◎
If optionality is “optional” and V is undefined, then:
</p>
				<ol>
					<li>
~IF
~index %i に位置する引数は `既定~値$を伴って宣言されている
~THEN
その既定~値を %values に付加する
◎
If the argument at index i is declared with a default value, then append to values that default value.
</li>
					<li>
~ELSE
~THEN
`MISSING^ を %values に付加する
◎
Otherwise, append to values the special value “missing”.
</li>
				</ol>
			</li>
			<li id="cp-append-convert1">
~ELSE
~THEN
%V を~IDL型 %type に`toIDL^した結果を %values に付加する
◎
Otherwise, append to values the result of converting V to IDL type type.
</li>
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
<p>
~IF
%i ~EQ %d
<span class="trans-note">【すなわち， %S に複数の~entryがある】</span>
⇒
◎
If i = d, then:
</p>

		<ol>
			<li>
<p>
%V := %arg<sub>%i</sub>
◎
Let V be argi.
</p>
<p class="note">注記：
これが多重定義の解決-に利用されることになる引数になる。
◎
Note: This is the argument that will be used to resolve which overload is selected.
</p>

			</li>
			<li>
~IF［
%V ~EQ `undefined^v
］~AND［
%S の~entryに［
その `ol-optionality-list^ の中の~index %i に位置する`省略可否 値$
］ ~EQ “`省略可^C” なるものが在る
］
~THEN
他のすべての~entryを %S から除去する
◎
If V is undefined, and there is an entry in S whose list of optionality values has “optional” at index i, then remove from S all other entries.
</li>
			<li>
~ELIF
［
%V ~IN { `null^v, `undefined^v }
］~AND［
%S の~entryに［
その `ol-type-list^ の中の~index %i に位置する型が `~nullable型を内包する$
］ようなものが在る
］
~THEN
他のすべての~entryを %S から除去する
◎
↓</li>
			<li>
<p>
~ELIF
下の表の中に，次のいずれも満たすような行が在る：
</p>
				<ul>
					<li>
%V は行の一列目の条件を満たす。
</li>
					<li>
%S の~entryに，次を満たすものが在る：［
その `ol-type-list^ の中の~index %i に位置する型 %T
］は［
行の二列目に挙げられる型の集合 %Types
］に`型互換$である。
</li>
				</ul>

<p>
~THEN
表の中のそのような行のうち，最初の行について、［
上の二番目の条件に該当する %S の~entry†
］以外の~entryすべてを，
%S から除去する
</p>

<p>
ここで、型 %T が，（`~nullable$でも `共用体~型$ でもない）型の集合
%Types に
`型互換@
であるとは、
%T が次のいずれかを満たすことを意味する：
</p>

				<ul>
					<li>
%T は %Types に属する
</li>
					<li>
%T は`~nullable$型であり, かつ
その`内縁~型$は %Types に属する
</li>
					<li>
%T は`共用体~型$, または`~nullable$共用体~型である, かつ
その`平坦化~mb型$の中に %Types に属するものが在る
</li>
				</ul>

<p class="trans-note">【†
下の表のどの行についても、二列目に挙げられた型たちは，どの 2 つも互いに`判別可能$でない。
したがって、
%S （`有効~多重定義~集合$）, %i （`判別引数~index$）の定義により、どの行についても，`型互換$な %S の~entryは，高々１個になる。
】【
簡潔にするため、この段は，原文の記述を再構成している。
】</p>


<table>
<col span="1" style="width:50%;" /><col/>
<thead><tr><th>%V が満たす条件
</th><th>%Types
</th></tr></thead>

<tbody><tr><td>
%V ~IN { `null^v, `undefined^v }
◎
Otherwise: if V is null or undefined, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`辞書~型$, `~record型$
◎
• a nullable type
• a dictionary type
• a record type
• a union type that includes a nullable type or that has a dictionary type or a record type in its flattened members
◎
then remove from S all other entries.

</td></tr><tr><td>
`~platform~obj$である
◎
Otherwise: if V is a platform object, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
%V が実装する`~ifc型$, `object$T
◎
• an interface type that V implements
• object
• a nullable version of any of the above types
• a union type or a nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
`DOMException^t ~objである
◎
Otherwise: if V is a DOMException platform object and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`DOMException$T, `Error$T, `object$T
◎
• DOMException
• Error
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
`Error^t ~objである（すなわち， `ErrorData^es `内部~slot$を持つ）
◎
Otherwise: if V is an Error object (that is, it has an [[ErrorData]] internal slot) and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`Error$T, `object$T
◎
• Error
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.


</td></tr><tr><td>
`ArrayBufferData^es `内部~slot$を持つ
◎
Otherwise: if V is an object with an [[ArrayBufferData]] internal slot and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`ArrayBuffer$T, `object$T
◎
• ArrayBuffer
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
`DataView^es `内部~slot$を持つ
◎
Otherwise: if V is an object with a [[DataView]] internal slot and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`DataView$T, `object$T
◎
• DataView
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
`TypedArrayName^es `内部~slot$を持つ
◎
Otherwise: if V is an object with a [[TypedArrayName]] internal slot and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
［
型~名が %V の `TypedArrayName^es `内部~slot$に等しい `有型~配列~型$
］, `object$T
◎
• a typed array type whose name is equal to the value of V’s [[TypedArrayName]] internal slot
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
`IsCallable$A( %V ) ~EQ ~true
◎
Otherwise: if IsCallable(V) is true, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`呼戻~関数$ 型, `object$T
◎
• a callback function type
• object
• a nullable version of any of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
<p>
［
任意の種類の~objである
］~AND［
次を遂行した結果の %method ~NEQ `undefined^v
］：
</p>

<ol class="algorithm">
	<li>
%method := `GetMethod$A( %V, `iterator$esS ) の結果
</li>
	<li>
`ReturnIfAbrupt$A( %method )
</li>
</ol>

◎
Otherwise: if V is any kind of object, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`連列~型$, `凍結~配列~型$
◎
• a sequence type
• a frozen array type
• a nullable version of any of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
and after performing the following steps,
◎
Let method be the result of GetMethod(V, @@iterator).
◎
ReturnIfAbrupt(method).
◎
method is not undefined, then remove from S all other entries.

</td></tr><tr><td>
任意の種類の~objである
◎
Otherwise: if V is any kind of object, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`呼戻~ifc$型, `辞書~型$, `~record型$, `object$T
◎
• a callback interface type
• a dictionary type
• a record type
• object
• a nullable version of any of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
`Boolean^t 値である
◎
Otherwise: if V is a Boolean value, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`boolean$T
◎
• boolean
• a nullable boolean
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
`Number^t 値である
◎
Otherwise: if V is a Number value, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`実数~型$
◎
• a numeric type
• a nullable numeric type
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`文字列~型$
◎
• a string type
• a nullable version of any of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`実数~型$
◎
• a numeric type
• a nullable numeric type
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`boolean$T
◎
• boolean
• a nullable boolean
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
無条件
◎
Otherwise: if there is an entry in S that has any at position i of its type list, then remove from S all other entries.
</td><td>
`any$T

</td></tr></tbody></table>

			</li>
			<li>
~ELSE
~THEN
~THROW `TypeError^t
◎
Otherwise: throw a TypeError.
</li>
		</ol>
	</li>
	<li>
%entry := %S の（~~唯一の）~entry
◎
↓</li>
	<li>
%callable := %entry の `ol-callable^ （ `演算$／`拡張属性$ ）
◎
Let callable be the operation or extended attribute of the single entry in S.
</li>
	<li>
<p>
~IF［
%i ~EQ %d
］~AND［
%method ~NEQ `undefined^v
］⇒
◎
If i = d and method is not undefined, then
</p>
		<ol>
			<li>
%V := %arg<sub>%i</sub>
◎
Let V be argi.
</li>
			<li>
%T := %entry の `ol-type-list^ の中の~index %i に位置する型
◎
Let T be the type at index i in the type list of the remaining entry in S.
</li>
			<li>
~IF
%T は`連列~型$である
~THEN
［
%V, %method
］から，型 %T の`連列~値を作成-$した結果を， %values に付加する
◎
If T is a sequence type, then append to values the result of creating a sequence of type T from V and method.
</li>
			<li>
~ELSE（ %T は`凍結~配列~型$である）
~THEN
［
%V, %method
］から，型 %T の`凍結~配列~値を作成-$した結果を， %values に付加する
◎
Otherwise, T is a frozen array type. Append to values the result of creating a frozen array of type T from V and method.
</li>
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
<p>
~WHILE %i ~LT %argcount ：
◎
While i &lt; argcount:
</p>

		<ol>
			<li>
%V := %arg<sub>%i</sub>
◎
Let V be argi.
</li>
			<li>
%type := %entry の `ol-type-list^ の中の~index %i に位置する型
◎
Let type be the type at index i in the type list of the remaining entry in S.
</li>
			<li>
%optionality := %entry の `ol-optionality-list^ の中の~index %i に位置する`省略可否 値$
◎
Let optionality be the value at index i in the list of optionality values of the remaining entry in S.
</li>
			<!--cp-if-optional-->
			<!--cp-append-convert1-->
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
<p>
~WHILE %i ~LT %callable が宣言している引数~個数：
◎
While i is less than the number of arguments callable is declared to take:
</p>

		<ol>
			<li>
~IF
%callable の~index %i に位置する引数に
`既定~値$
が宣言されている
~THEN
その既定~値を %values に付加する
◎
If callable’s argument at index i is declared with a default value, then append to values that default value.
</li>
			<li>
~ELIF
%callable の~index %i に位置する引数は`可変個~引数$でない
~THEN
`MISSING^を %values に付加する
◎
Otherwise, if callable’s argument at index i is not variadic, then append to values the special value “missing”.
</li>
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
~RET ~pair &lt;%callable, %values&gt;
◎
Return the pair &lt;callable, values&gt;.
</li>
</ol>

<div class="note">

<p>
多重定義~解決~algoは、~callされている［
多重定義された`関数類$
］の識別に加えて、
~JS引数~値から，それぞれに対応する~IDL値への変換を遂行する。
概略的には次のように演算する。
◎
The overload resolution algorithm performs both the identification of which overloaded operation, constructor, etc. is being called, and the conversion of the ECMAScript argument values to their corresponding IDL values. Informally, it operates as follows.
</p>

<p>
まず、関数に渡された~JS引数の個数を考慮に入れつつ，妥当な多重定義の選定が行われる：
◎
First, the selection of valid overloads is done by considering the number of ECMAScript arguments that were passed in to the function:
</p>
	<ul>
		<li>
最長の多重定義~引数~listより多い引数が渡された場合、余分な引数は無視する。
◎
If there are more arguments passed in than the longest overload argument list, then they are ignored.
</li>
		<li>
余分な引数を無視した後の引数の個数と，同じ個数の引数をとれる多重定義のみが考慮の対象になる。
もし無ければ， `TypeError^t が投出される。
◎
After ignoring these trailing arguments, only overloads that can take this exact number of arguments are considered. If there are none, then a TypeError is thrown.
</li>
	</ul>

<p>
~~正しい個数の引数をとる，多重定義の集合が得られたなら、
~JS値は左から右の順に変換される。
多重定義に対する制約の定義から、この時点で複数の多重定義の候補がある場合、引数~listの中で，最終的に選定される多重定義を判別する際の~~基準となる位置がある。
これが`判別引数~index$である。
◎
Once we have a set of possible overloads with the right number of arguments, the ECMAScript values are converted from left to right. The nature of the restrictions on overloading means that if we have multiple possible overloads at this point, then there will be one position in the argument list that will be used to distinguish which overload we will finally select; this is the distinguishing argument index.
</p>

<p>
まず最初に，判別引数より左に位置する引数を変換する（これらの引数については、同じ~indexに位置する他の多重定義の引数と同じ型であることが要件にされている）。
<!-- 判別引数~indexまで到達したなら、 -->
次に、対応し得る~IDL型を決定するために，判別引数~indexの位置に渡された~JS値の型を検分する。
これにより、呼出されることになる多重定義の最終的な選定が可能になる。
渡された値が `undefined^v であって, かつ
この位置に随意~引数を伴う多重定義がある場合、その多重定義が選定される。
このとき，渡された値の型に対する妥当な多重定義が無ければ、 `TypeError^t が投出される。
判別引数~indexに位置する値の検分は副作用を持たない。
多重定義~解決~algoを走らすことに因る唯一の副作用は、
~JS値から~IDL値への変換-に因るものに限られる。
◎
We first convert the arguments to the left of the distinguishing argument. (There is a requirement that an argument to the left of the distinguishing argument index has the same type as in the other overloads, at the same index.) Then we inspect the type of the ECMAScript value that is passed in at the distinguishing argument index to determine which IDL type it may correspond to. This allows us to select the final overload that will be invoked. If the value passed in is undefined and there is an overload with an optional argument at this position, then we will choose that overload. If there is no valid overload for the type of value passed in here, then we throw a TypeError. The inspection of the value at the distinguishing argument index does not have any side effects; the only side effects that come from running the overload resolution algorithm are those that come from converting the ECMAScript values to IDL values.
</p>

<p>
この段階で，利用する多重定義が決定されたことになる。
しかる後、判別引数に後続する残りの引数~値も左から右の順に変換する。
ここでも，前述の余分な引数は、無視される。
◎
At this point, we have determined which overload to use. We now convert the remaining arguments, from the distinguishing argument onwards, again ignoring any additional arguments that were ignored due to being passed after the last possible argument.
</p>

<p>
随意~引数の~JS値からそれに等価な~IDL値へ変換する際には、
`undefined^v は，［
随意~引数に`既定~値$が在ればそれに／
無ければ`MISSING^に
］変換されることになる。
◎
When converting an optional argument’s ECMAScript value to its equivalent IDL value, undefined will be converted into the optional argument’s default value, if it has one, or a special value “missing” otherwise.
</p>

<p>
しかしながら、`可変個~引数$に対応する随意~引数に対する `undefined^v は，`MISSING^とは見なされない。
この場合の `undefined^v 値は、必須の引数と同様に，`可変個~引数$の型に変換されることになる。
◎
Optional arguments corresponding to a final, variadic argument do not treat undefined as a special “missing” value, however. The undefined value is converted to the type of variadic argument as would be done for a non-optional argument.
</p>
</div>

		</section>
		<section id="es-interfaces">
<h3 title="Interfaces">3.6. ~ifc</h3>


<p>
所与の~JS大域環境 %G にて`公開され$ている，どの`~ifc$ %I に対しても、 %I が次のいずれかの条件：
◎
For every interface that is exposed in a given ECMAScript global environment and:
</p>

<ul>
	<li>
`呼戻~ifc$である, かつ
`定数$を伴って宣言されている
◎
is a callback interface that has constants declared on it, or
</li>
	<li>
非~呼戻`~ifc$である, かつ
`NoInterfaceObject$x `拡張属性$を伴わずに宣言されている
◎
is a non-callback interface that is not declared with the [NoInterfaceObject] extended attribute,
</li>
</ul>


<div>
<p>
を満たすならば、
%I に対応して，次の特徴を有する~propが %G の大域~obj上に存在し~MUST：
</p>

<ul>
	<li>
名前は %I の`識別子$。
</li>
	<li>
値は
`~ifc~obj@
と呼ばれる~obj
— この~objの特徴については、下の
`interface-object$sec
にて述べる。
</li>
	<li id="cp-has-attr-TFT">
属性 `TFT^desc を持つ。
</li>
</ul>

◎
a corresponding property must exist on the ECMAScript environment’s global object. The name of the property is the identifier of the interface, and its value is an object called the interface object.
◎
The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. The characteristics of an interface object are described in §3.6.1 Interface object.
</div>


<div class="p">
<p>
加えて、 %G において
`NamedConstructor$x 拡張属性を伴って`公開され$る，どの~ifcに対しても、次の特徴を有する~propが %G の大域~obj上に存在し~MUST：
</p>

<ul>
	<li>
名前は `=^sym の直後に現れる `identifier$g
</li>
	<li>
値は、その~ifcを実装する~objの構築を可能にする,
`有名~構築子@
と呼ばれる~obj
— この構築子の特徴については、下の
`named-constructors$sec
にて述べる。
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
In addition, for every [NamedConstructor] extended attribute on an exposed interface, a corresponding property must exist on the ECMAScript global object. The name of the property is the identifier that occurs directly after the “=”, and its value is an object called a named constructor, which allows construction of objects that implement the interface. The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. The characteristics of a named constructor are described in §3.6.2 Named constructors.
</div>


			<section>
<h4 class="trans-note">3.6.X. 【この訳に特有の定義】</h4>

<p>
共通の記述を集約するため、この訳では次の非公式な定義を導入する（加えて、原文の定義を，より見通しのよい~~形に変形してもいる）：
</p>

<div>
<p>
所与の~prop %p が ~ifc %A に対する
`通例の場所に存在する@
とは，次を意味する：
</p>

<ul>
	<li>
%A が
`Global$x ／ `PrimaryGlobal$x
注釈付きの~ifcでないならば、 %p は %A の`~ifc原型~obj$上に存在する。
</li>
	<li>
また、ある
`Global$x ／ `PrimaryGlobal$x
注釈付きの~ifc %G が存在して， %A が %G の`広義~帰結~ifc$であるならば、 %p は（前項に加えて，） %G を実装する単独の~obj上に存在する。
</li>
</ul>
◎
If the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on the single object that implements the interface.
◎
Otherwise, if the interface is a consequential interface of a [Global]- or [PrimaryGlobal]-annotated interface, then the property exists on the single object that implements the [Global]- or [PrimaryGlobal]-annotated interface as well as on the consequential interface’s interface prototype object.
◎
Otherwise, the property exists solely on the interface’s interface prototype object.
</div>

<!-- ＊

~ifcが 'Global$x 拡張属性を伴って宣言されている

	その~ifcを実装する単独の~obj上に存在

他の場合，~ifcが 'Global$x 注釈付きの~ifc %G の'帰結~ifc$である

	その帰結~ifcの'~ifc原型~obj$, および
	%G を実装する単独の~obj
	上に存在

他の場合、~propは，その~ifcの'~ifc原型~obj$上においてのみ存在

-->


			</section>
			<section id="interface-object">
<h4 title="Interface object">3.6.1. ~ifc~obj</h4>


<p>
所与の非~呼戻`~ifc$に対応する~ifc~objは、`関数~obj$である。
それは、下の
`es-constants$sec, `es-operations$sec
にて述べるように，その~ifc上に定義される
`定数$, `静的~演算$
のそれぞれに対応する~propを持つ。
◎
The interface object for a given non-callback interface is a function object. It has properties that correspond to the constants and static operations defined on that interface, as described in sections §3.6.5 Constants and §3.6.7 Operations.
</p>

<p>
非~呼戻~ifc %A に対応する~ifc~objの `Prototype^es 内部~propの値は、次のように決定される：
◎
The [[Prototype]] internal property of an interface object for a non-callback interface is determined as follows:
</p>

<ol>
	<li>
%A が他の何らかの~ifc %B を継承する場合、
%B に対応する~ifc~obj。
◎
If the interface inherits from some other interface, the value of [[Prototype]] is the interface object for that other interface.
</li>
	<li>
他の場合、
`FunctionPrototype$esI
◎
If the interface doesn’t inherit from any other interface, the value of [[Prototype]] is %FunctionPrototype%.
</li>
</ol>

<div class="p">
<p>
非~呼戻~ifcに対応する~ifc~objは、次の特徴を有する~propを持た~MUST：
</p>

<ul>
	<li id="cp-name-is-prototype">
名前は `prototype^l
</li>
	<li>
値は
`~ifc原型~obj@
と呼ばれる~obj
— この~objは、その~ifc上に定義される［
`正則~属性$, `正則~演算$
］のそれぞれに対応する~propを持つ。
詳細は
`interface-prototype-object$sec
にて述べる。
</li>
	<li id="cp-has-attr-FFF">
属性 `FFF^desc を持つ
</li>
</ul>

◎
An interface object for a non-callback interface must have a property named “prototype” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } whose value is an object called the interface prototype object. This object has properties that correspond to the regular attributes and regular operations defined on the interface, and is described in more detail in §3.6.3 Interface prototype object.
</div>

<p class="note">注記：
非~呼戻~ifcに対応する~ifc~objは `関数~obj$なので、
`typeof^c 演算子が その種の~ifc~objに適用されるときには，
"`function^v" を返すようになることも意味する。
◎
Note: Since an interface object for a non-callback interface is a function object the typeof operator will return "function" when applied to such an interface object.
</p>

<p>
呼戻~ifcに対応する~ifc~objの `Prototype^es 内部~propは、
Function.prototype ~objで~MUST。
◎
The internal [[Prototype]] property of an interface object for a callback interface must be the Function.prototype object.
</p>

<p class="note">注記：
呼戻~ifcに対応する~ifc~objが存在するのは，その`~ifc$上に`定数$が宣言されている場合に限られることに留意。
存在する場合、それらは関数~objではない。
◎
Note: Remember that interface objects for callback interfaces only exist if they have constants declared on them; when they do exist, they are not function objects.
</p>


				<section id="es-constructible-interfaces">
<h5 title="Constructible Interfaces">3.6.1.1. 構築-可能な~ifc</h5>

<p>
`~ifc$が `Constructor$x `拡張属性$（構築子）を伴って宣言されている場合、
その`~ifc~obj$は，その~ifcを実装する~objを作成する構築子として~callし得るものになる。
そのような~ifcが関数として~callされた場合，例外が投出されることになる。
◎
If the interface is declared with a [Constructor] extended attribute, then the interface object can be called as a constructor to create an object that implements that interface. Calling that interface as a function will throw an exception.
</p>

<p>
`Constructor$x `拡張属性$を伴わずに宣言されている~ifcは、［
構築子, 関数
］のいずれとして~callされた場合も，例外が投出されることになる。
◎
Interfaces that are not declared with a [Constructor] extended attribute will throw when called, both as a function and as a constructor.
</p>

<p>
［
所与の非~呼戻`~ifc$ %I
］に対する~ifc~objである `関数~obj$ %F を評価するときは、
%arg<sub>0..%n−1</sub> を %F に渡された引数~値の~listとするとき，次の手続きに従わ~MUST：
◎
When evaluating the function object F, which is the interface object for a given non-callback interface I, assuming arg0..n−1 as the list of argument values passed F, the following steps must be taken:
</p>

<ol class="algorithm">
	<li>
~IF
%I は `Constructor$x `拡張属性$を伴って宣言されていない
~THEN
~THROW `TypeError^t
◎
If I was not declared with a [Constructor] extended attribute, then throw a TypeError.
</li>
	<li>
~IF
`NewTarget$ ~EQ `undefined^v
~THEN
~THROW `TypeError^t
◎
If NewTarget is undefined, then throw a TypeError.
</li>
	<li>
%id := %I の識別子
◎
Let id be the identifier of interface I.
</li>
	<li id="cp-call-method1">
%S :← %I 上の構築子のうち［
`識別子$ %id, 引数個数 %n
］から得られる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for constructors with identifier id on interface I and with argument count n.
</li>
	<li id="cp-call-method2">
&lt;%constructor, %values&gt; := 
%S と %arg<sub>0..%n−1</sub> を`多重定義~解決~algo$に渡した結果
◎
Let &lt;constructor, values&gt; be the result of passing S and arg0..n−1 to the overload resolution algorithm.
</li>
	<li>
%R := %values を一連の引数~値として， %constructor の記述に挙げられている手続きを遂行した結果
— 例外は再~投出する
◎
Let R be the result of performing the actions listed in the description of constructor with values as the argument values. Rethrow any exceptions.
</li>
	<li>
%O := %R を型 %I の~JS`~ifc型$ 値に`toES^した結果
◎
Let O be the result of converting R to an ECMAScript interface type value I.
</li>
	<li>
~Assert：
%O は %I を実装する~objである
◎
Assert: O is an object that implements I.
</li>
	<li>
~Assert：
%O.`Realm^es ~EQ %F.`Realm^es
◎
Assert: O.[[Realm]] is equal to F.[[Realm]].
</li>
	<li>
~RET %O
◎
Return O.
</li>
</ol>

<div class="p">
<p>
呼戻でない~ifc %I に対応する~ifc~objは、次の特徴を有する~propを持た~MUST：
</p>

<ul>
	<li>
名前は `length^l
</li>
	<li id="cp-has-attr-FFT">
属性 `FFT^desc を持つ
</li>
	<li>
値は 下に与える手続きから決定される `Number^t 値
</li>
</ul>

◎
Interface objects for non-callback interfaces must have a property named “length” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } whose value is a Number. If the [Constructor] extended attribute does not appear on the interface definition, then the value is 0. Otherwise, the value is determined as follows:
</div>

<ol class="algorithm">
	<li>
~IF
%I の定義には `Constructor$x 拡張属性は現れない
~THEN
~RET 0
◎
↑</li>
	<li>
%id := ~ifc %I の識別子
◎
Let id be the identifier of interface I.
</li>
	<li id="cp-constructor-overload1">
%S :← `~ifc$ %I 上の構築子のうち［
`識別子$ %id, 引数個数 0
］から得られる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for constructors with identifier id on interface I and with argument count 0.
</li>
	<li id="cp-constructor-overload2">
~RET %S 内の各~entryの引数~listの長さのうち，最小
◎
Return the length of the shortest argument list of the entries in S.
</li>
</ol>

<div class="p">
<p>
どの~ifc~objも、次の特徴を有する~propを持た~MUST：
<ul>
	<li>
名前は `name^l
</li>
	<li>
値は 対応する~ifcの識別子
</li>
	<!--cp-has-attr-FFT-->
</ul>

◎
All interface objects must have a property named “name” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } whose value is the identifier of the corresponding interface.
</div>


				</section>
				<section id="es-interface-hasinstance">
<h5 title="Interface object [[HasInstance]] method">3.6.1.2. ~ifc object `HasInstance^es ~meth</h5>

<p>
どの~ifc~obj %A に対しても，その `HasInstance^es 内部~methは、
%V をその引数とするとき，次に従って挙動し~MUST：
◎
The internal [[HasInstance]] method of every interface object A must behave as follows, assuming V is the object argument passed to [[HasInstance]]:
</p>

<ol class="algorithm">
	<li>
~IF
%V は ~objでない
~THEN
~RET `false^v
◎
If V is not an object, return false.
</li>
	<li>
%O := ~prop名 `prototype^l により， %A の `Get^es ~methを~callした結果
◎
Let O be the result of calling the [[Get]] method of A with property name “prototype”.
</li>
	<li>
~IF
%O は ~objでない
~THEN
~THROW `TypeError^t
◎
If O is not an object, throw a TypeError exception.
</li>
	<li>
~IF
%V は［
%O を`~ifc原型~obj$に持つ`~ifc$
］を実装する`~platform~obj$である
~THEN
~RET `true^v
◎
If V is a platform object that implements the interface for which O is the interface prototype object, return true.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Repeat:
</p>
		<ol>
			<li>
%V ← %V の `Prototype^es 内部~propの値
◎
Set V to the value of the [[Prototype]] internal property of V.
</li>
			<li>
~IF
%V ~EQ `null^v
~THEN
~RET `false^v
◎
If V is null, return false.
</li>
			<li>
~IF
%O と %V が同じ~objを指している
~THEN
~RET `true^v
◎
If O and V refer to the same object, return true.
</li>
		</ol>
	</li>
</ol>



				</section>
			</section>
			<section id="named-constructors">
<h4 title="Named constructors">3.6.2. 有名~構築子</h4>

<p>
`有名~構築子$は、`識別子$（以下 %id とする）を伴う１個~以上の
`NamedConstructor$x `拡張属性$により 存在することになる，`関数~obj$である。
それは、その拡張属性が現れる`~ifc$（以下 %I とする）を実装する~objの構築を可能にする， `Call^es 内部~prop を持た~MUST。
◎
A named constructor that exists due to one or more [NamedConstructor] extended attributes with a given identifier is a function object. It must have a [[Call]] internal property, which allows construction of objects that implement the interface on which the [NamedConstructor] extended attributes appear.
</p>

<p>
それは、
%arg<sub>0..%n−1</sub> を構築子に渡された引数~値の~listとするとき，次に従って挙動する：
◎
It behaves as follows, assuming arg0..n−1 is the list of argument values passed to the constructor, id is the identifier of the constructor specified in the extended attribute named argument list, and I is the interface on which the [NamedConstructor] extended attribute appears:
</p>

<ol class="algorithm">
	<!--cp-call-method1-->
	<!--cp-call-method2-->
	<li>
%R := %values を一連の引数~値として， %constructor の記述に挙げられている手続きを遂行した結果
◎
Let R be the result of performing the actions listed in the description of constructor with values as the argument values.
</li>
	<li>
~RET %R を型 %I の~JS`~ifc型$ 値に`toES^した結果
◎
Return the result of converting R to an ECMAScript interface type value I.
</li>
</ol>

<p><!-- copy* -->
`有名~構築子$の `Call^es 内部~methが返す値は、~ifc %I を実装する~objで~MUST。
この~objは、その`有名~構築子$が属する~JS大域環境に属してい~MUST。
◎
If the internal [[Call]] method of the named constructor returns normally, then it must return an object that implements interface I. This object also must be associated with the ECMAScript global environment associated with the named constructor.
</p>

<div class="p">
<p>
有名~構築子は、次の特徴を有する~propを持た~MUST：
</p>

<ul>
	<li>
名前は `length^l
</li>
	<!--cp-has-attr-FFT-->
	<li>
値は、次に与える手続きから決定される `Number^t
</li>
</ul>
◎
A named constructor must have a property named “length” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } whose value is a Number determined as follows:
</div>

<ol class="algorithm">
	<!--cp-constructor-overload1-->
	<!--cp-constructor-overload2-->
</ol>


<div class="p">

<p>
有名~構築子は、次の特徴を有する~propを持た~MUST：
</p>

<ul>
	<li>
名前は `name^l
</li>
	<li>
値は 構築子に利用されている識別子。
</li>
	<!--cp-has-attr-FFT-->
</ul>

◎
A named constructor must have a property named “name” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } whose value is the identifier used for the named constructor.
</div>

<div class="p">

<p>
有名~構築子は、次の特徴を有する~propも持た~MUST：
</p>
<ul>
	<!--cp-name-is-prototype-->
	<li>
値は `NamedConstructor$x `拡張属性$が現れた`~ifc$に対応する`~ifc原型~obj$。
</li>
	<!--cp-has-attr-FFF-->
</ul>

◎
A named constructor must also have a property named “prototype” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } whose value is the interface prototype object for the interface on which the [NamedConstructor] extended attribute appears.
</div>

			</section>
			<section id="interface-prototype-object">
<h4 title="Interface prototype object">3.6.3. ~ifc原型~obj</h4>


<p>
定義されたどの非~呼戻`~ifc$に対しても、その~ifcが `NoInterfaceObject$x `拡張属性$を伴って宣言されたかどうかに関わらず，対応する`~ifc原型~obj$が存在し~MUST。
個々の~ifcに対し，その~ifc原型~objは、その~ifc上に定義される［
`正則~属性$, `正則~演算$
］のそれぞれに対応する~propを持つ。
これらの~propについての詳細は
`es-attributes$sec, `es-operations$sec
にて述べる。
◎
There must exist an interface prototype object for every non-callback interface defined, regardless of whether the interface was declared with the [NoInterfaceObject] extended attribute. The interface prototype object for a particular interface has properties that correspond to the regular attributes and regular operations defined on that interface. These properties are described in more detail in sections §3.6.6 Attributes and §3.6.7 Operations.
</p>

<p>
`~ifc~obj$と同様に，~ifc原型~objも その~ifc上に定義される`定数$に対応する~propを持つ（ `es-operations$sec にて述べる）。
◎
As with the interface object, the interface prototype object also has properties that correspond to the constants defined on that interface, described in §3.6.7 Operations.
</p>

<div class="p">
<p>
その~ifc上に `NoInterfaceObject$x 拡張属性が指定されていない場合、その~ifc原型~objは，次の特徴を有する~propを持た~MUST：
</p>

<ul>
	<li>
名前は `constructor^l
</li>
	<li>
値は その~ifcに対応する~ifc~objへの参照
</li>
	<!--cp-has-attr-TFT-->
</ul>

◎
If the [NoInterfaceObject] extended attribute was not specified on the interface, then the interface prototype object must also have a property named “constructor” with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } whose value is a reference to the interface object for the interface.

</div>


<p>
所与の~ifc %A に対応する`~ifc原型~obj$は、次に与える値をとる， `Prototype^es 内部~propを持た~MUST：
◎
The interface prototype object for a given interface A must have an internal [[Prototype]] property whose value is returned from the following steps:
</p>

<ol class="algorithm">
	<li>
%A が
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴って宣言されていて, かつ
`有名~propを~supportする$ならば、下の
`named-properties-object$sec
にて定義される， %A に対応する`有名~prop~obj$
◎
If A is declared with the [Global] or [PrimaryGlobal] extended attribute, and A supports named properties, then return the named properties object for A, as defined in §3.6.4 Named properties object.
</li>
	<li>
<p>
他の場合：
◎
Otherwise,
</p>
		<ol class="algorithm" id="cp-get-proto">
			<li>
%A が別の~ifc %B を継承するように宣言されているならば、
%B に対応する`~ifc原型~obj$
◎
If A is declared to inherit from another interface, then return the interface prototype object for the inherited interface.
</li>
			<li>
他の場合，
%A が `LegacyArrayClass$x 拡張属性を伴って宣言されているならば、
`ArrayPrototype$esI
◎
Otherwise, if A is declared with the [LegacyArrayClass] extended attribute, then return %ArrayPrototype%.
</li>
			<li>
他の場合、
`ObjectPrototype$esI
◎
Otherwise, return %ObjectPrototype%.
</li>
		</ol>
	</li>
</ol>

<div class="note">
<p>
`NoInterfaceObject$x `拡張属性$を伴って定義された`~ifc$に対応する`~ifc原型~obj$は、その~ifcが非`追補~ifc$
として利用されているならば~access可能になる。
例えば、次の~IDLでは：
◎
The interface prototype object of an interface that is defined with the [NoInterfaceObject] extended attribute will be accessible if the interface is used as a non-supplemental interface. For example, with the following IDL:
</p>

<pre class="idl-code">
[NoInterfaceObject]
interface Foo {
};

partial interface Window {
  attribute Foo foo;
};
</pre>

<p>
`~ifc~obj$を通して
~ifc原型~objに~accessすることはできない（ `window.Foo^c として存在しないので）。
しかしながら、
`Foo^T の~instanceは，その `Prototype^es 内部~prop値の取得 —
この例では， `Object.getPrototypeOf(window.foo)^c
— により，~ifc原型~objを公開し得る。
◎
it is not possible to access the interface prototype object through the interface object (since it does not exist as window.Foo). However, an instance of Foo can expose the interface prototype object by gettings its internal [[Prototype]] property value – Object.getPrototypeOf(window.foo) in this example.
</p>

<p>
~ifcがもっぱら`追補~ifc$として利用されている場合、その~ifc原型~objを `Prototype^es 内部~propの値にとる~objは存在しないので、~ifc原型~objに~accessする仕方はないことになる。
そのような場合、この~objが存在しないことは，受容し得る最適化になる。
◎
If the interface is used solely as a supplemental interface, then there will be no way to access its interface prototype object, since no object will have the interface prototype object as its internal [[Prototype]] property value. In such cases, it is an acceptable optimization for this object not to exist.
</p>
</div>

<div class="L2">

<div class="p">
<p>
~ifcのいずれかの`広義~帰結~ifc$が，［
`Unscopable$x 拡張属性を伴って宣言された`~ifc~mb$
］を持つ場合（そのような~mbからなる集合を %M とする）、その~ifc原型~obj上には，次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `unscopables$esS ~symbol
</li>
	<li>
値は 次の手続きで作成される~obj
</li>
</ul>
◎
If the interface or any of its consequential interfaces has any interface member declared with the [Unscopable] extended attribute, then there must be a property on the interface prototype object whose name is the @@unscopables symbol and whose value is an object created as follows:
</div>

<ol class="algorithm">
	<li>
%object := 式 `({})^c により作成されるものと同じ，新たな~obj
<!-- ObjectCreate -->
◎
Let object be a new object created as if by the expression ({}).
</li>
	<li>
<p>
%M 内の ~EACH ( %m ) に対し：
</p>
		<ol>
			<li>
`CreateDataProperty$A( %object, %m の`識別子$, `true^v ) を~callする
</li>
		</ol>
◎
For each of the aforementioned interface members declared with the [Unscopable] extended attribute, call CreateDataProperty(object, the identifier of the interface member, true).
</li>
	<li>
~RET %object
◎
Return object.
</li>
</ol>

</div>

<p>
~ifc %A が［
`Global$x ／ `PrimaryGlobal$x
］`拡張属性$を伴って宣言されている場合、どの~ifc
%B ~IN { %A , %A の`被継承~ifc$ }
に対しても、
%B の`~ifc原型~obj$は，`変異不可の原型~exotic~obj$で~MUST。
◎
If the interface is declared with the [Global] or [PrimaryGlobal] extended attribute, or the interface is in the set of inherited interfaces for any other interface that is declared with one of these attributes, then the interface prototype object must be an immutable prototype exotic object.
</p>

<p>
`~ifc原型~obj$の `~class文字列$は［
`~ifc$の`識別子$,
文字列 `Prototype^l 
］の連結である。
◎
The class string of an interface prototype object is the concatenation of the interface’s identifier and the string “Prototype”.
</p>
			</section>
			<section id="named-properties-object">
<h4 title="Named properties object">3.6.4. 有名~prop~obj</h4>


<p>
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴って宣言されていて, かつ
`有名~propを~supportする$
どの`~ifc$に対しても、その~ifcに対応する
`有名~prop~obj@
と呼ばれる~objが存在し~MUST。
◎
For every interface declared with the [Global] or [PrimaryGlobal] extended attribute that supports named properties, there must exist an object known as the named properties object for that interface.
</p>

<p>
所与の~ifc %A に対応する`有名~prop~obj$は、次に従って決定される値をとる， `Prototype^es 内部~propを持た~MUST：
◎
The named properties object for a given interface A must have an internal [[Prototype]] property whose value is returned from the following steps:
</p>

<!--cp-get-proto-->

<p>
`有名~prop~obj$の `~class文字列$は［
`~ifc$の`識別子$,
文字列 `Properties^l
］の連結である。
◎
The class string of a named properties object is the concatenation of the interface’s identifier and the string “Properties”.
</p>

				<section id="named-properties-object-getownproperty">
<h5 title="Named properties object [[GetOwnProperty]] method">3.6.4.1. 有名~prop~obj `GetOwnProperty^es ~meth</h5>


<p>
`有名~prop~obj$ %O の `GetOwnProperty^es 内部~methが ~prop名 %P を伴って~callされたときは、次の手続きを行う：
◎
When the [[GetOwnProperty]] internal method of a named properties object O is called with property key P, the following steps are taken: 
</p>

<ol class="algorithm">
	<li>
%A := %O に対する`~ifc$
◎
Let A be the interface for the named properties object O.
</li>
	<li>
<p>
%object := %O が属する~JS大域環境に属する， %A を実装する~~唯一の~obj
<!--  -->
◎
Let object be the sole object from O’s ECMAScript global environment that implements A.
</p>

<p class="note">注記：
例えば，`~ifc$が HTML5 で定義される `Window^T ~ifcならば、この大域環境の window ~objが~~唯一の~objになる。
◎
Note: For example, if the interface is the Window interface, then the sole object will be this global environment’s window object.
</p>

</li>
	<li>
<p>
~IF［
( ~prop名 %P, ~obj %object )
を~~入力に，`有名~propの可視性判定~algo$を走らせた結果 ~EQ true
⇒
◎
If the result of running the named property visibility algorithm with property name P and object object is true, then:
</p>
		<ol>
			<li>
%operation := `有名~prop取得子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property getter.
</li>
			<li id="cp-let-uninitialized">
%value :← 未初期化の変数
◎
Let value be an uninitialized variable.
</li>
			<li id="cp-determine-ifndef">
~IF
%operation は `識別子$なしに定義されている
~THEN
%value ← ［
名前 %P に対し，~ifcの記述に挙げられている
`有名~propの値を決定する$
手続きを遂行した結果
］
◎
If operation was defined without an identifier, then set value to the result of performing the steps listed in the interface description to determine the value of a named property with P as the name.
</li>
			<li id="cp-set-as-desc1">
~ELSE
~THEN
%value ← ［
( %P )
を引数に， %operation の記述に挙げられている手続きを遂行した結果
］
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the steps listed in the description of operation with P as the only argument value.
</li>
			<li>
<p id="cp-ret-new-desc">
~RET 次の様な新たな`~pdesc$：
◎
Let desc be a newly created Property Descriptor with no fields.
</p>

<div>
&nbsp;&nbsp; `TET-V^desc — ここで：

				<ul>
					<li id="cp-let-convert2">
%V := %value を~JS値に`toES^した結果
</li>
					<li>
%E := ［
%A が実装するある~ifcに `LegacyUnenumerableNamedProperties$x `拡張属性$が伴われているならば `false^v ／
~ELSE_ `true^v
］
</li>
				</ul>

◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If A implements an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then set desc.[[Enumerable]] to false, otherwise set it to true.
◎
Set desc.[[Writable]] to true and desc.[[Configurable]] to true.
◎
Return desc.
</div>
			</li>
		</ol>
	</li>
	<li id="cp-return-OrdinaryGetOwnProperty">
~RET
`OrdinaryGetOwnProperty$A( %O, %P )
◎
Return OrdinaryGetOwnProperty(O, P).
</li>
</ol>

				</section>
				<section id="named-properties-object-defineownproperty">

<h5 title="Named properties object [[DefineOwnProperty]] method">3.6.4.2. 有名~prop~obj `DefineOwnProperty^es ~meth</h5>

<p>
`有名~prop~obj$の `DefineOwnProperty^es 内部~methが~callされたときは、次の手続きを行う：
◎
When the [[DefineOwnProperty]] internal method of a named properties object is called, the following steps are taken: 
</p>

<ol class="algorithm">
	<li>
~RET `false^v
◎
Return false.
</li>
</ol>

				</section>
				<section id="named-properties-object-delete">

<h5 title="Named properties object [[Delete]] method">3.6.4.3. 有名~prop~obj `Delete^es ~meth</h5>

<p>
`有名~prop~obj$の `Delete^es 内部~methが~callされたときには，次の手続きを行う：
◎
When the [[Delete]] internal method of a named properties object is called, the following steps are taken:
</p>

<ol class="algorithm">
	<li>
~RET `false^v
◎
Return false.
</li>
</ol>


				</section>
				<section id="named-properties-object-setprototypeof">
<h5 title="Named properties object [[SetPrototypeOf]] method">3.6.4.4. 有名~prop~obj `SetPrototypeOf^es ~meth</h5>

<p>
`有名~prop~obj$の `SetPrototypeOf^es 内部~methが~callされたときは、`変異不可の原型~exotic~obj$の `SetPrototypeOf^es 内部~methに対し定義されるものと同じ~algoを実行し~MUST。
◎
When the [[SetPrototypeOf]] internal method of a named properties object is called, the same algorithm must be executed as is defined for the [[SetPrototypeOf]] internal method of an immutable prototype exotic object.
</p>

				</section>
				<section id="named-properties-object-preventextensions">
<h5 title="Named properties object [[PreventExtensions]] method">3.6.4.5. 有名~prop~obj `PreventExtensions^es ~meth</h5>

<p>
`有名~prop~obj$の `PreventExtensions^es 内部~methが~callされたときは、次の手続きを行う：
◎
When the [[PreventExtensions]] internal method of a named properties object is called, the following steps are taken:
</p>

<ol class="algorithm">
	<li>
~RET `false^v
◎
Return false.
</li>
</ol>


<p class="note">注記:
これにより、`有名~prop~obj$は 拡張-可能に保たれる
— それらに対する `PreventExtensions^es を失敗させることにより。
◎
Note: this keeps named properties object extensible by making [[PreventExtensions]] fail.
</p>
				</section>
			</section>
			<section id="es-constants">
<h4 title="Constants">3.6.5. 定数</h4>


<p>
`~ifc$上で定義され, かつ`公開され$ている どの`定数$に対しても、次の特徴を有する，対応する~propが存在し~MUST：
◎
For each exposed constant defined on an interface A, there must be a corresponding property. The property has the following characteristics:
</p>
<ul>
	<li>
名前は 定数の`識別子$。
◎
The name of the property is the identifier of the constant.
</li>
	<li><p id="cp-proploc0">
~propは ~ifcに対する`通例の場所に存在する$。
◎
The location of the property is determined as follows:
• If the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on the single object that implements the interface.
• Otherwise, if the interface is a consequential interface of a [Global]- or [PrimaryGlobal]-annotated interface, then the property exists on the single object that implements the [Global]- or [PrimaryGlobal]-annotated interface as well as on the consequential interface’s interface prototype object.
• Otherwise, the property exists solely on the interface’s interface prototype object.
</p></li>
	<li>
値は 定数の~IDL値を~JS値に`toES^した結果。
◎
The value of the property is that which is obtained by converting the constant’s IDL value to an ECMAScript value.
</li>
	<li>
属性 `FTF^desc を持つ。
◎
The property has attributes { [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }.
</li>
</ul>

<p>
加えて、<!-- ~ifcに＊ -->`~ifc原型~obj$が在る場合は、同じ特徴を有する~propが，その~obj上にも存在し~MUST。
◎
In addition, a property with the same characteristics must exist on the interface object, if that object exists.
</p>
			</section>
			<section id="es-attributes">
<h4 title="Attributes">3.6.6. 属性</h4>


<p>
`~ifc$において，その いずれかの`広義~帰結~ifc$により `公開され$ている各 `属性$（以下， `属性^var と記す）に対しては、次の特徴を有する，対応する~propが存在し~MUST：
◎
For each exposed attribute of the interface, whether it was declared on the interface itself or one of its consequential interfaces, there must exist a corresponding property. The characteristics of this property are as follows:
</p>

<ul>
	<li>
名前は `属性^var の`識別子$
◎
The name of the property is the identifier of the attribute.
</li>
	<li>
<p id="cp-proploc">
~propの所在は、次のように決定される：
◎
The location of the property is determined as follows:
</p>

		<ul>

			<li>
`属性^var が`静的~属性$である場合、対応する単独の~propが， ~ifcに対する`~ifc~obj$上に存在する。
◎
If the attribute is a static attribute, then there is a single corresponding property and it exists on the interface’s interface object.
</li>
			<li>
他の場合， `属性^var が~ifc上で`偽装不可$であるならば、~propは，
~ifcを実装するどの~obj上にも存在する。
◎
Otherwise, if the attribute is unforgeable on the interface or if the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on every object that implements the interface.
◎
↓</li>
			<li id="cp-exist-normal-loc">
他の場合、~propは ~ifcに対する`通例の場所に存在する$。
◎
↑
◎
Otherwise, if the interface is a consequential interface of a [Global]- or [PrimaryGlobal]-annotated interface, then the property exists on the single object that implements the [Global]- or [PrimaryGlobal]-annotated interface as well as on the consequential interface’s interface prototype object.
◎
Otherwise, the property exists solely on the interface’s interface prototype object.
</li>
		</ul>
	</li>
	<li>
<p>
属性
<span class="descriptor">{&nbsp;[[Get]]: %G, [[Set]]: %S, [[Enumerable]]: `true^v, [[Configurable]]: %configurable&nbsp;}</span>
を持つ。ここで：
◎
The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]: true, [[Configurable]]: configurable }, where:
</p>
		<ul>
			<li>
%configurable は［
`属性^var が `Unforgeable$x 拡張属性を伴って宣言されているならば `false^v ／
~ELSE_ `true^v
］
◎
configurable is false if the attribute was declared with the [Unforgeable] extended attribute and true otherwise;
</li>
			<li>
%G は下で定義される`属性~取得子$
◎
G is the attribute getter, defined below; and
</li>
			<li>
%S は下で定義される`属性~設定子$
◎
S is the attribute setter, also defined below.
</li>
		</ul>
	</li>
</ul>

<p>
`属性~取得子@
は、被呼出時の挙動が次で与えられる， `Function^t ~obj %F である：
◎
The attribute getter is a Function object whose behavior when invoked is as follows:
</p>
<!-- not defined V, O -->
<ol class="algorithm">
	<li>
%idlValue :← ~IDL値をとる未初期化の変数
◎
Let idlValue be an IDL value determined as follows.
</li>
	<li>
<p id="cp-if-regular-attr">
~IF
`属性^var は `正則~属性$である
⇒
◎
If the attribute is a regular attribute, then:
</p>
		<ol>
			<li>
<p id="cp-let-I-for-attr">
%I := この（ `属性^var に対応している）~propが`~ifc原型~obj$上に現れるような，`~ifc$
◎
Let I be the interface whose interface prototype object this property corresponding to the attribute appears on.
</p>

<p class="note">注記：
このことは、 `属性^var が`~implements文$により~ifc上にて可用になったとしても、
%I は `属性^var が元々宣言された方ではなく，~implements文の左側の~ifcであることを意味する。
◎
Note: This means that even if an implements statement was used to make an attribute available on the interface, I is the interface on the left hand side of the implements statement, and not the one that the attribute was originally declared on.
</p>
			</li>
			<li id="cp-let-O-this-value">
%O := `this^v 値
◎
Let O be the this value.
</li>
			<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, `属性^var の`識別子$, `取得子^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier of the attribute, and
• the type “getter”.
</li>
			<li>
<p>
~IF
%O は %I を実装する`~platform~obj$でない
⇒
◎
If O is not a platform object that implements I, then:
</p>
				<ol>
					<li>
~IF
`属性^var が `LenientThis$x `拡張属性$を伴って指定されている
~THEN
~RET `undefined^v
◎
If the attribute was specified with the [LenientThis] extended attribute, then return undefined.
</li>
					<li>
~ELSE
~THEN
~THROW `TypeError^t
◎
Otherwise, throw a TypeError.
</li>
				</ol>
			</li>
			<li>
%idlValue ← %O を~objとして、［
`属性^var，あるいは［
`属性^var がその`取得子を継承-$するように宣言されている場合は，継承された属性
］］の記述に挙げられている，取得~時に生じる手続きを遂行した結果
◎
Set idlValue to be the result of performing the actions listed in the description of the attribute that occur when getting (or those listed in the description of the inherited attribute, if this attribute is declared to inherit its getter), with O as the object.
</li>
		</ol>
	</li>
	<li>
~ELSE （すなわち `属性^var は`静的~属性$）
~THEN
%idlValue ← `属性^var の記述に挙げられている，取得~時に生じる手続きを遂行した結果
◎
Otherwise, the attribute is a static attribute. Set idlValue to be the result of performing the actions listed in the description of the attribute that occur when getting.
</li>
	<li>
~RET %idlValue を~JS値に`toES^した結果
◎
Let V be the result of converting idlValue to an ECMAScript value.
◎
Return V.
</li>
</ol>

<p id="cp-length-is-0">
この `Function^t ~objの `length^l ~propの値は、 `Number^t 値 `0^v である。
◎
The value of the Function object’s “length” property is the Number value 0.
</p>

<p>
この `Function^t ~objの `name^l ~propの値は、［
`get^l , 属性の識別子
］を連結して得られる `String^t 値である。
◎
The value of the Function object’s “name” property is a String whose value is the concatenation of “get ” and the identifier of the attribute.
</p>

<p>
`属性~設定子@
は、 `属性^var の宣言に `readonly^c が伴われていて, かつ［
`LenientThis$x, `PutForwards$x, `Replaceable$x
］のいずれの`拡張属性$も伴われていない場合、 `undefined^v である。
他の場合、被呼出時の挙動が次で与えられる， `Function^t ~obj %F である：
◎
The attribute setter is undefined if the attribute is declared readonly and does not have a [LenientThis], [PutForwards] or [Replaceable] extended attribute declared on it. Otherwise, it is a Function object whose behavior when invoked is as follows:
</p>

<ol class="algorithm">

	<li>
~IF
%F に引数が渡されていない
~THEN
~THROW `TypeError^t
◎
If no arguments were passed to the Function, then throw a TypeError.
</li>
	<li>
%V := %F に渡された第一~引数の値
◎
Let V be the value of the first argument passed to the Function.
</li>
	<li>
<!--cp-if-regular-attr-->

		<ol>
			<li><!--cp-let-I-for-attr--></li>
			<!--cp-let-O-this-value-->

			<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, 属性の`識別子$, `設定子^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier of the attribute, and
• the type “setter”.
</li>
			<li>
%validThis := ［
%O が %I を実装する`~platform~obj$ならば
`true^v ／
~ELSE_ `false^v
］
◎
Let validThis be true if O is a platform object that implements I, or false otherwise.
</li>
			<li>
~IF［
%validThis ~EQ `false^v
］~AND［
`属性^var は `LenientThis$x `拡張属性$を伴って指定されていない
］
~THEN
~THROW `TypeError^t
◎
If validThis is false and the attribute was not specified with the [LenientThis] extended attribute, then throw a TypeError.
</li>
			<li>
<p>
~IF
`属性^var は `Replaceable$x 拡張属性を伴って宣言されている
⇒
◎
If the attribute is declared with a [Replaceable] extended attribute, then:
</p>
				<ol>
					<li>
%P := `属性^var の識別子
◎
Let P be the identifier of the attribute.
</li>
					<li id="cp-CreateDataProperty-OPV">
`CreateDataProperty$A( %O, %P, %V ) を~callする
◎
Call CreateDataProperty(O, P, V).
</li>
					<li>
~RET `undefined^v
◎
Return undefined.
</li>
				</ol>
			</li>
			<li>
~IF
%validThis ~EQ `false^v
~THEN
~RET `undefined^v
◎
If validThis is false, then return undefined.
</li>
			<li>
~IF
`属性^var は `LenientSetter$x 拡張属性を伴って宣言されている：
~THEN
~RET `undefined^v
◎
If the attribute is declared with a [LenientSetter] extended attribute, then return undefined.
</li>
			<li>
<p>
~IF
`属性^var は `PutForwards$x 拡張属性を伴って宣言されている：
◎
If the attribute is declared with a [PutForwards] extended attribute, then:
</p>
				<ol>
					<li>
%Q := `属性^var の識別子を~prop名に利用して， %O 上の `Get^es ~methを~callした結果
◎
Let Q be the result of calling the [[Get]] method on O using the identifier of the attribute as the property name.
</li>
					<li>
~IF
%Q は ~objでない
~THEN
~THROW `TypeError^t
◎
If Q is not an object, then throw a TypeError.
</li>
					<li>
%A := `PutForwards$x 拡張属性により識別される属性
◎
Let A be the attribute identified by the [PutForwards] extended attribute.
</li>
					<li>
%A の識別子を~prop名に, %V を値に利用して，
%Q 上の `Put^es ~methを~callする
◎
Call the [[Put]] method on Q using the identifier of A as the property name and V as the value.
</li>
					<li>
~RET `undefined^v
◎
Return undefined.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
%idlValue := 次で決定される~IDL値：
◎
Let idlValue be an IDL value determined as follows:
</p>
		<ul>
			<li>
<p>
~IF
`属性^var の型は `列挙$である
⇒
◎
If the type of the attribute is an enumeration, then:
</p>
				<ol>
					<li>
%S := `ToString$A( %V )
◎
Let S be the result of calling ToString(V).
</li>
					<li>
~IF
%S は `列挙~値$のいずれでもない
~THEN
~RET `undefined^v
◎
If S is not one of the enumeration’s values, then return undefined.
</li>
					<li>
%idlValue は %S に等しい列挙~値
◎
The value of idlValue is the enumeration value equal to S.
</li>
				</ol>
			</li>
			<li>
~ELSE
~THEN
%idlValue は %V を~IDL値に`toIDL^した結果
◎
Otherwise, the type of the attribute is not an enumeration. The value of idlValue is the result of converting V to an IDL value.
</li>
		</ul>
	</li>
	<li>
%idlValue を値として, 加えて［
`属性^var が`正則~属性$であるならば %O を~objとして
］， `属性^var の設定が生じる際の記述に挙げられている手続きを遂行する
◎
If the attribute is a regular attribute, then perform the actions listed in the description of the attribute that occur when setting, with O as the object and idlValue as the value.
◎
Otherwise, the attribute is a static attribute. Perform the actions listed in the description of the attribute that occur when setting with idlValue as the value.
</li>
	<li>
~RET `undefined^v
◎
Return undefined.
</li>
</ol>

<p id="cp-length-is-1">
この `Function^t ~objの `length^l ~propの値は、 `Number^t 値 `1^v である。
◎
The value of the Function object’s “length” property is the Number value 1.
</p>

<p>
この `Function^t ~objの `name^l ~propの値は、［
`set^l , 属性の識別子
］を連結して得られる `String^t 値である。
◎
The value of the Function object’s “name” property is a String whose value is the concatenation of “set ” and the identifier of the attribute.
</p>



<p class="note">注記：
１個の~IDL属性に対応する~propは【~~通常は】１個に限られるが、~accessor~prop［
取得子／設定子
］には，［［
その~IDL属性に対応する~prop
］が~accessされた
］~objを指す `this^v 値が渡されるので、それらの~propは，~instance特有の~dataを公開できる。
◎
Note: Although there is only a single property for an IDL attribute, since accessor property getters and setters are passed a this value for the object on which property corresponding to the IDL attribute is accessed, they are able to expose instance-specific data.
</p>

<p class="note">注記：
`読専$`属性$に対応する~propへの代入を試みた結果は、それを行う~scriptが~strict-modeであるかどうかに依存して異なる挙動になることに注意。
~strict-modeの場合、その種の代入により `TypeError^t が投出されることになる。
~strict-modeでない場合、代入の試みは無視されることになる。
◎
Note: Note that attempting to assign to a property corresponding to a read only attribute results in different behavior depending on whether the script doing so is in strict mode. When in strict mode, such an assignment will result in a TypeError being thrown. When not in strict mode, the assignment attempt will be ignored.
</p>

			</section>
			<section id="es-operations">
<h4 title="Operations">3.6.7. 演算</h4>

<p>
`~ifc$上に定義され, かつ`公開され$ている`演算$ `演算^var の各~一意な`識別子$ごとに、次の特徴を有する，対応する~propが存在し~MUST
—
ただし、［
その`識別子$, 引数個数 0
］の`演算$からなる`有効~多重定義~集合$が空~集合である場合
<span class="trans-note">【
要するに `演算^var が識別子を伴わない場合？
】</span>
は除く：
◎
For each unique identifier of an exposed operation defined on the interface, there must exist a corresponding property, unless the effective overload set for that identifier and operation and with an argument count of 0 has no entries.
◎
The characteristics of this property are as follows:
</p>

<ul>
	<li>
名前は `演算^var の`識別子$
◎
The name of the property is the identifier.
</li>
	<li>
<!--cp-proploc-->
		<ul>
			<li>
`演算^var が`静的~演算$である場合、~propは ~ifcに対する`~ifc~obj$上に存在する。
◎
If the operation is static, then the property exists on the interface object.
</li>
			<li><!-- copy* -->
他の場合， `演算^var が~ifc上で`偽装不可$であるならば、~propは，~ifcを実装するどの~obj上にも存在する。
◎
Otherwise, if the operation is unforgeable on the interface or if the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on every object that implements the interface.
◎
↓</li>
			<!--cp-exist-normal-loc-->
		</ul>
	</li>
	<li>
属性 `BTB^desc を持つ。
ここで %B は［
`演算^var が~ifc上で`偽装不可$である場合は `false^v ／
~ELSE_ `true^v
］である。
◎
The property has attributes { [[Writable]]: B, [[Enumerable]]: true, [[Configurable]]: B }, where B is false if the operation is unforgeable on the interface, and true otherwise.
</li>
	<li>
<p>
~propの~値は、
( `演算^var, ~ifc, ~Realm )
から，`演算~関数を作成-$した結果
— ここで：
</p>

<ul><li>~Realmは、~propが所在する~objに`関連する~Realm$。
</li><li>~ifcが~mixinである場合、それを~mix-inしている~ifcを渡す。
すなわち、当の演算が`~implements文$を通して可用にされている（ ~implements文の右側の~ifcで宣言されている）場合、その~implements文の左側の~ifcを渡す。
</li></ul>

◎
The value of the property is the result of creating an operation function given the operation, the interface (or the interface it’s being mixed in to, if the interface is actually a mixin), and the relevant Realm of the object that is the location of the property.
◎
Note: that is, even if an implements statement was used to make an operation available on the interface, we pass in the interface on the left-hand side of the implements statement, and not the really-a-mixin interface on the right-hand side, where the operation was originally declared.
</li>
</ul>


<p class="advisement">
上の記述には、とりわけ部分的~ifc周りで，~bugがある。
<a href="https://github.com/heycam/webidl/issues/164">issue #164</a>
を見よ。
◎
The above description has some bugs, especially around partial interfaces. See issue #164.
</p>


<p>
`名前空間$にて宣言された演算に対応する~propについては、
`namespace-object$secに述べる（~ifcについても、最終的には名前空間と同様に，~propを明示的に~installする~~方式に移行することが望まれている。）
◎
For namespaces, the properties corresponding to each declared operation are described in §3.11.1 Namespace object. (We hope to eventually move interfaces to the same explicit property-installation style as namespaces.)
</p>


<p>
`演算~関数を作成-@
するときは、所与の
( `演算$ %op, `名前空間$または`~ifc$ %target, `~Realm$ %realm )
に対し：
◎
To create an operation function, given an operation op, a namespace or interface target, and a Realm realm:
</p>


<ol class="algorithm">
	<li>
%id := %op の`識別子$
◎
Let id be op’s identifier.
</li>
	<li>
<p>
%steps :=
所与の関数~引数~値 %arg<sub>0..%n−1</sub> に対し，次を行う手続き
— ただし，手続きの中で例外が投出された場合は、その下に与える手続きを行うとする：
◎
Let steps be the following series of steps, given function argument values arg0..n−1:
◎
Try running the following steps:
</p>

		<ol>
			<li>
%O := `null^v
◎
Let O be null.
</li>
			<li>
<p>
~IF
%target は`~ifc$である
］~AND［
%op は`静的~演算$でない
］：
◎
If target is an interface, and op is not a static operation:
</p>

				<ol>
					<li>
<p >
~IF
`this^v 値 ~IN { `null^v, `undefined^v }
~THEN
%O ← %realm の`大域~obj$
</p>

<p>
（この大域~objが %target を実装しない場合、数~段~先で `TypeError^t が生じることになる。）</p>
◎
If the this value is null or undefined, set O to realm’s global object. (This will subsequently cause a TypeError in a few steps, if the global object does not implement target.)
</li>
					<li>
~ELSE
~THEN
%O ← `this^v 値
◎
Otherwise, set O to the this value.
</li>
					<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, %id, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing O, id, and "method".
</li>
					<li>
~IF
%O は ~ifc %target を実装する`~platform~obj$でない
~THEN
~THROW `TypeError^t
◎
If O is not a platform object that implements the interface target, throw a TypeError.
</li>
				</ol>
			</li>
			<li>
<p>
%S := %target 上の［
%op が［
正則~演算ならば`正則~演算$ ／ 静的~演算ならば`静的~演算$
］］のうち，［
`識別子$ %id, 引数個数 %n
］から得られる`有効~多重定義~集合$
◎
Let S be the effective overload set for regular operations (if op is a regular operation) or for static operations (if op is a static operation) with identifier id on target and with argument count n.
</li>
			<li id="cp-let-resolution">
&lt;%operation, %values&gt; :=
%S と %arg<sub>0..%n−1</sub> を`多重定義~解決~algo$に渡した結果
◎
Let &lt;operation, values&gt; be the result of passing S and arg0..n−1 to the overload resolution algorithm.
</li>
			<li>
<p>
%R :=
( %operation, %values ) を引数に，演算の記述に挙げられている手続きを
— %O ~NEQ `null^v ならば %O 上で —
遂行した結果
◎
Let R be the result of performing the actions listed in the description of operation, on O if O is not null, with values as the argument values.
</li>
			<li>
~RET %R を［
%op の返値に宣言された型
］の~JS値に`toES^した結果
◎
Return the result of converting R to an ECMAScript value of the type op is declared to return.
</li>
		</ol>
<p>
上で例外 %e が投出された場合の手続き：
◎
And then, if an exception was thrown:
</p>

		<ol>
			<li>
<p>
~IF
%op の`返値型$は `~promise型$である
~THEN
~RET 次を渡して［
`Promise$esI.reject の初期~値
］を~callした結果：
</p>

<ul ><li>`this^v ~obj： `Promise$esI
</li><li>引数~list： ( %e )
</li></ul>
◎
If op has a return type that is a promise type, then:
• Let reject be the initial value of %Promise%.reject.
• Return the result of calling reject with %Promise% as the this object and the exception as the single argument value.
</li>
			<li>
~ELSE
~THEN
~THROW %e
◎
Otherwise, end these steps and allow the exception to propagate.
</li>
		</ol>
	</li>
	<li>
%F := 
! `CreateBuiltinFunction$A( %realm, %steps, %realm の `FunctionPrototype$esI )
◎
Let F be ! CreateBuiltinFunction(realm, steps, the %FunctionPrototype% of realm).
</li>
	<li>
! `SetFunctionName$A( %F, %id )
を遂行する
◎
Perform ! SetFunctionName(F, id).
</li>
	<li>
%S := %target 上の［
%op が正則~演算である場合は`正則~演算$ ／
静的~演算である場合は`静的~演算$
］のうち［
`識別子$ %id, 引数個数 0
］から得られる`有効~多重定義~集合$
◎
Let S be the effective overload set for regular operations (if op is a regular operation) or for static operations (if op is a static operation) with identifier id on target and with argument count 0.
</li>
	<li>
%length := %S 内の各~entryの引数~listの長さのうち，最小
◎
Let length be the length of the shortest argument list in the entries in S.
</li>
	<li>
! `DefinePropertyOrThrow$A( %F, `length^l, `FFT-length^desc )
を遂行する
◎
Perform ! DefinePropertyOrThrow(F, "length", PropertyDescriptor{[[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).
</li>
	<li>
~RET %F
◎
Return F.
</li>
</ol>


				<section id="es-stringifier">
<h5 title="Stringifiers">3.6.7.1. 文字列化子</h5>

<p>
`~ifc$が`公開され$ている`文字列化子$（以下 `文字列化子^var と記す）を持つ場合、次の特徴を有する~propが存在し~MUST：
◎
If the interface has an exposed stringifier, then there must exist a property with the following characteristics:
</p>

<ul>
	<li>
名前は `toString^l
◎
The name of the property is “toString”.
</li>
	<li><!-- copy* -->
~propの所在は：
`文字列化子^var が~ifc上で`偽装不可$であるか, または
~ifcが
`Global$x ／ `PrimaryGlobal$x
拡張属性を伴って宣言されているならば、~ifcを実装するどの~obj上にも存在する。
他の場合、~ifcの`~ifc原型~obj$上に存在する。
◎
If the stringifier is unforgeable on the interface or if the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on every object that implements the interface. Otherwise, the property exists on the interface prototype object.
</li>
	<li>
属性 `BTB^desc を持つ。
ここで %B は［
`文字列化子^var が~ifc上で`偽装不可$である場合は `false^v ／
~ELSE_ `true^v
］である。
◎
The property has attributes { [[Writable]]: B, [[Enumerable]]: true, [[Configurable]]: B }, where B is false if the stringifier is unforgeable on the interface, and true otherwise.
</li>
	<li>
値は 下に与える `Function^t ~obj %F 。
◎
↓</li>
</ul>

<p>
~prop値 %F は、被呼出時には次に従って挙動し~MUST：
◎
The value of the property is a Function object, which behaves as follows:
</p>

<ol class="algorithm">
	<li id="cp-call-ToObject">
%O := `this^v 値~上で `ToObject$A を~callした結果
◎
Let O be the result of calling ToObject on the this value.
</li>
	<li><!-- copy* -->
~IF
%O は `~platform~obj$である
~THEN
( %O, `文字列化子^var の`識別子$, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier of the stringifier, and
• the type “method”.
</li>
	<li>
~IF
%O は［
`文字列化子^var を宣言する~ifcを実装する~obj
］でない
~THEN
~THROW `TypeError^t
◎
If O is not an object that implements the interface on which the stringifier was declared, then throw a TypeError.
</li>
	<li>
%V :← 未初期化の変数
◎
Let V be an uninitialized variable.
</li>
	<li>
<p>
`stringifier^c が指定されている場所に応じて：
◎
Depending on where stringifier was specified:
</p>
		<dl class="switch">
			<dt>
`属性$上
◎
on an attribute
</dt>
			<dd><!-- copy* -->
%V ← %O を~objとして、［
その属性, あるいは［
その属性がその`取得子を継承-$するように宣言されている場合は，継承された属性
］］の記述に挙げられている，取得~時に生じる手続きを遂行した結果
◎
Set V to the result of performing the actions listed in the description of the attribute that occur when getting (or those listed in the description of the inherited attribute, if this attribute is declared to inherit its getter), with O as the object.
</dd>

			<dt>
識別子を伴う`演算$上
◎
on an operation with an identifier
</dt>
			<dd>
%V ← %O を `this^v 値として, 引数は渡さずに、その演算の記述に挙げられている手続きを遂行した結果
◎
Set V to the result of performing the actions listed in the description of the operation, using O as the this value and passing no arguments.
</dd>
			<dt>
識別子を伴わない`演算$上
◎
on an operation with no identifier
</dt>
			<dd>
%V ← ~ifcの`文字列化の挙動$を遂行した結果
◎
Set V to the result of performing the stringification behavior of the interface.
</dd>
		</dl>
	</li>
	<li>
~RET
%V を `String^t 値に`toES^した結果
◎
Return the result of converting V to a String value.
</li>
</ol>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `toString^l である。
◎
The value of the Function object’s “name” property is the String value “toString”.
</p>

				</section>
				<section id="es-serializer">
<h5 title="Serializers">3.6.7.2. 直列化子</h5>

<div class="p">
<p>
`公開され$ている`直列化子$（以下 `直列化子^var と記す）を持つ`~ifc$に対しては、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `toJSON^l
</li>
	<li id="cp-value-is-a-func-F">
値は 下に与える `Function^t ~obj %F 。
◎
↓</li>
	<li id="cp-has-attr-TTT">
属性 `TTT^desc を持つ
</li>
</ul>

◎
If the interface has an exposed serializer, then a property must exist whose name is “toJSON”, with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a Function object.
</div>


<!--cp-proploc0-->

<p>
~prop値 %F は、被呼出時には次に従って挙動し~MUST：
◎
The property’s Function object, when invoked, must behave as follows:
</p>

<ol class="algorithm">
	<!--cp-call-ToObject-->
	<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, `直列化子^var の`識別子$, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier of the serializer, and
• the type “method”.
</li>
	<li>
~IF
%O は［
`直列化子^var を宣言する~ifc
］を実装する~objでない
~THEN
~THROW `TypeError^t
◎
If O is not an object that implements the interface on which the serializer was declared, then throw a TypeError.
</li>
	<li>
<p>
`直列化子^var の `serializer^c の指定のされ方に応じて：
◎
Depending on how serializer was specified:
</p>

		<dl class="switch">
			<dt>
識別子を伴う`演算$上に指定されたものである場合
◎
on an operation with an identifier
</dt>
			<dd>
				<ol class="algorithm">
					<li>
~RET %O を `this^v 値に利用して, 引数を渡さずに，演算の記述に挙げられている手続きを遂行した結果
◎
Return the result of performing the actions listed in the description of the operation, using O as the this value and passing no arguments.
</li>
				</ol>
			</dd>
			<dt>
~keywordとして指定されたものである場合
— `直列化~pattern$の有無に関わらず
◎
as a keyword, either with or without a serialization pattern
</dt>
			<dd>
				<ol class="algorithm">
					<li>
%S := ~obj %O に対する~ifcの`直列化-時の挙動$を呼出した結果の`直列化形の値$
◎
Let S be the serialized value that is the result of invoking the serialization behavior of the interface for object O.
</li>
					<li>
~RET
%S を`直列化値toES^した結果
◎
Return the result of converting S to an ECMAScript value.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>


<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `toJSON^l である。
◎
The value of the Function object’s “name” property is the String value “toJSON”.
</p>

<p>
`直列化形の値から~JS値に変換-@
する手続きは，次で定義される：
◎
The following steps define how to convert a serialized value to an ECMAScript value:
</p>

<ol class="algorithm">
	<li>
%S := `直列化形の値$
◎
Let S be the serialized value.
</li>
	<li>
<p>
%S の型に応じて：
◎
Depending on the type of S:
</p>

		<dl class="switch">
			<dt>~map◎a map</dt>
			<dd>
				<ol class="algorithm">
					<li>
%O := 式 `({})^c により作成されるものと同じ，新たな~obj
<!-- ObjectCreate -->
◎
Let O be a new object created as if by the expression ({}).
</li>
					<li>
<p>
~FOR
%S 内の~EACH ( ~entry ) に対し，それらが~mapに追加された順に：
◎
For each entry in S, in the order they were added to the map:
</p>

						<ol>
							<li>
%V := ~entryの~valueを`直列化値toES^した結果
◎
Let V be the result of converting the value of the entry to an ECMAScript value.
</li>
							<li>
%P := ~entryの~key
◎
Let P be the entry’s key.
</li>
							<!--cp-CreateDataProperty-OPV-->
						</ol>
					</li>
					<li>
~RET %O
◎
Return O.
</li>
				</ol>
			</dd>
			<dt>~list◎a list</dt>
			<dd>
				<ol class="algorithm">
					<li>
%A :=
式 `[]^c で作成されるものと同じ，新たな `Array^t ~obj
◎
Let A be a new Array object created as if by the expression [].
</li>
					<li>
%index :← 0
◎
Let index be 0.
</li>
					<li>
<p>
~WHILE %index ~LT %S 内の要素~数：
◎
While index is less than the number of elements in S:
</p>

						<ol>
							<li>
%V := %S 内の~index %index に位置する要素の値を`直列化値toES^した結果
◎
Let V be the result of converting the value of the element in S at index index to an ECMAScript value.
</li>
							<li>
%P := `ToString$A( %index )
◎
Let P be ToString(index).
</li>
							<li>
`CreateDataProperty$A( %A, %P, %V ) を~callする
<span class="trans-note">【原文の %O を %A に修正】</span>
◎
Call CreateDataProperty(O, P, V).
</li>
						</ol>
					</li>
					<li>
~RET %A
◎
Return A.
</li>
				</ol>
			</dd>
			<dt>他の直列化形の値◎any other serialized value</dt>
			<dd>
				<ol class="algorithm">
					<li>
~RET %S を~JS値に`toES^した結果
◎
Let V be the result of converting S to an ECMAScript value.
◎
Return V.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

				</section>
			</section>
			<section id="es-iterators">
<h4 title="Common iterator behavior">3.6.8. 反復子に共通する挙動</h4>

				<section id="es-iterator">
<h5 title="@@iterator">3.6.8.1. ~iterator0</h5>

<p >
所与の`~ifc$が，次のいずれかを持つならば…：
◎
If the interface has any of the following:
</p>

<ul>
	<li>
`可反復~宣言$
◎
an iterable declaration
</li>
	<li>
`有index~prop取得子$, および［
名前 `length^c の，`整数~型$の`属性$
］
◎
an indexed property getter and an integer-typed attribute named “length”
</li>
	<li class="L2">
`~maplike 宣言$
◎
a maplike declaration
</li>
	<li class="L2">
`~setlike 宣言$
◎
a setlike declaration
</li>
</ul>

<div class="p">
<p>
…ならば、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は ~iterator0 ~symbol
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TFT-->
</ul>

◎
then a property must exist whose name is the @@iterator symbol, with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<p id="cp-F-is-given-as-follows">
~prop値 %F は、次で与えられる：
◎
↓</p>

<dl class="switch">
	<dt>
~ifcは `有index~prop取得子$を定義している場合：
◎
↓</dt>
	<dd>
`ArrayProto_values$esI 。
◎
If the interface defines an indexed property getter, then the Function object is %ArrayProto_values%.
</dd>

	<dt>
~ifcは`~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then the Function, when invoked, must behave as follows:
</dt>
	<dd>
<p id="cp-F-must-behave-as-follows">
被呼出時には次に従って挙動し~MUST：
◎
↑</p>

<ol class="algorithm">
	<li id="cp-let-ToObject-this">
%object := `this^v 値~上の `ToObject$A を~callした結果
◎
Let object be the result of calling ToObject on the this value.
</li>
	<li id="cp-iterator-security-check">
~IF
%object は `~platform~obj$である
~THEN
( %object, `~iterator0^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier “@@iterator”, and
• the type “method”.
</li>
	<li>
%interface := `可反復~宣言$が宣言されている`~ifc$
◎
Let interface be the interface the iterable declaration is on.
</li>
	<li id="cp-throw-if-not-impl">
~IF
%object は［
%interface を実装する`~platform~obj$
］でない
~THEN
~THROW `TypeError^t
◎
If object is not a platform object that implements interface, then throw a TypeError.
</li>
	<li>
~RET ［
%interface,
~target %object,
反復子の種類 `key+value^C
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind “key+value”.
◎
Return iterator.
</li>
</ol>
	</dd>

	<dt class="L2">
~ifcは `~maplike 宣言$／`~setlike 宣言$を持つ場合：
◎
If the interface has a maplike declaration or setlike declaration, then the Function object that is the value of the @@iterator property, when invoked, must behave as follows:
</dt>
	<dd class="L2">
<!--cp-F-must-behave-as-follows-->

<ol class="algorithm">
	<!--cp-let-ToObject-this-->
	<!--cp-iterator-security-check-->
	<li>
~IF
%object は［
`~maplike 宣言$ ／ `~setlike 宣言$
を定義する`~ifc$を実装する`~platform~obj$
］でない
~THEN
~THROW `TypeError^t
◎
If object is not a platform object that implements the interface on which the maplike declaration or setlike declaration is defined, then throw a TypeError.
</li>
	<li>
<p>
~IF
~ifcは`~maplike 宣言$を持つ ⇒
◎
If the interface has a maplike declaration, then:
</p>
		<ol>
			<li>
%backing := %object の `BackingMap^es `内部~slot$の値
◎
Let backing be the value of the [[BackingMap]] internal slot of object.
</li>
			<li>
~RET `CreateMapIterator$A(%backing, `key+value^l)
◎
Return CreateMapIterator(backing, "key+value").
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE ⇒
◎
Otherwise:
</p>
		<ol>
			<li>
%backing := %object の `BackingSet^es `内部~slot$の値
◎
Let backing be the value of the [[BackingSet]] internal slot of object.
</li>
			<li>
~RET `CreateSetIterator$A(%backing, `value^l)
◎
Return CreateSetIterator(backing, "value").
</li>
		</ol>
	</li>
</ol>
	</dd>

</dl>

<p>
%F の `length^l ~propの値は、 `Number^t 値 `0^v である。
◎
The value of the @@iterator Function object’s “length” property is the Number value 0.
</p>

<p>
%F の `name^l ~propの値は、当の~ifcが［［
`~pair反復子$ ／ `~maplike 宣言$
］を持つならば `String^t 値 `entries^l ／
`~setlike 宣言$を持つならば `String^t 値 `values^l
］である。
◎
The value of the @@iterator Function object’s “name” property is the String value “entries” if the interface has a pair iterator or a maplike declaration and the String “values” if the interface has a setlike declaration.
</p>


				</section>
				<section id="es-forEach">
<h5 title="forEach">3.6.8.2. forEach</h5>

<p>
`~ifc$が次のいずれかを持つならば：
◎
If the interface has any of the following:
</p>

<ul>
	<li>
`可反復~宣言$
◎
an iterable declaration
</li>
	<li class="L2">
`~maplike 宣言$
◎
a maplike declaration
</li>
	<li class="L2">
`~setlike 宣言$
◎
a setlike declaration
</li>
</ul>


<div class="p">
<p>
…ならば、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `forEach^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
then a property named “forEach” must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>~ifcは `有index~prop取得子$を定義している場合：</dt>
	<dd>
`ArrayPrototype$esI の
`forEach^l ~data-propの初期~値。
◎
If the interface defines an indexed property getter, then the Function object is the initial value of the “forEach” data property of %ArrayPrototype%.
</dd>

	<dt>~ifcは `~pair反復子$を持つ場合：</dt>
	<dd>
<p>
［［
その~ifcが，その`~pair反復子$を代わりに 次に示す［
`演算$, および注釈文による定義
］を持つ
］と見なしたときに，存在することになるもの
］と同じに挙動する：
◎
If the interface has a pair iterator, then the Function must have the same behavior, when invoked with argument callback and optional argument thisArg, as one that would exist assuming the interface had this operation instead of the iterable declaration:
</p>

<pre class="idl-code">
interface Iterable {
  void forEach(Function %callback, optional any %thisArg);
};
</pre>

<p>
注釈文による定義は、
( 引数 %callback, 随意~引数 %thisArg )
で呼出されたとき：
◎
with the following prose definition:
</p>

<ol class="algorithm">
	<li>
%O := `this^v 値
◎
Let O be the this value.
</li>
	<li>
%pairs := `反復される値~pair$の~list
◎
Let pairs be the list of value pairs to iterate over.
</li>
	<li>
<p>
~FOR
%pairs 内の~EACH ( %pairs ) に対し，順に：
◎
Let i be 0.
◎
While i is less than the length of pairs:
</p>
		<ol>
			<li>
%pair := %pairs 内で~index %i に位置する~entry
◎
Let pair be the entry in pairs at index i.
</li>
			<li>
%key := %pair の~key
◎
Let key be pair’s key.
</li>
			<li>
%value := %pair の値
◎
Let value be pair’s value.
</li>
			<li>
`呼戻 this 値$に %thisArg （引数が渡されなかった場合は `undefined^v ）を,
引数に ( %value, %key, %O ) を渡して，
%callback を<a href="#invoke-a-callback-function">呼出す</a>
◎
Invoke callback with thisArg (or undefined, if the argument was not supplied) as the callback this value and value, key and O as its arguments.
</li>
			<li>
現在の`反復される値~pair$の~listに %pairs で更新する
◎
Update pairs to the current list of value pairs to iterate over.
◎
Set i to i + 1.
</li>
		</ol>
	</li>
</ol>

	</dd>

	<dt class="L2">
~ifcは `~maplike 宣言$／`~setlike 宣言$を持つ場合：
◎
If the interface has a maplike declaration or setlike declaration then the Function, when invoked, must behave as follows:
</dt>
	<dd class="L2">
<!--cp-F-must-behave-as-follows-->

<ol class="algorithm">
	<!--cp-let-ToObject-this-->
	<li>
~IF
%object は `~platform~obj$である
~THEN
( %object, `forEach^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier “forEach”, and
• the type “method”.
</li>
	<li>
%interface := `~maplike 宣言$／`~setlike 宣言$が宣言されている`~ifc$
◎
Let interface be the interface on which the maplike declaration or setlike declaration is declared.
</li>
	<!--cp-throw-if-not-impl-->
	<li>
%callbackFn := ［
この関数に引数が渡されているならば その第一~引数の値 ／
~ELSE_ `undefined^v
］
◎
Let callbackFn be the value of the first argument passed to the function, or undefined if the argument was not supplied.
</li>
	<li>
~IF
`IsCallable$A( %callbackFn ) ~EQ `false^v
~THEN
~THROW `TypeError^t
◎
If IsCallable(callbackFn) is false, throw a TypeError.
</li>
	<li>
%thisArg := ［
関数に第二~引数が渡されているならば その引数の値 ／
~ELSE_ `undefined^v
］
◎
Let thisArg be the value of the second argument passed to the function, or undefined if the argument was not supplied.
</li>
	<li>
%backing := %interface が［
`~maplike 宣言$ ／ `~setlike 宣言$
］のいずれを持つかに応じて， %object の［
`BackingMap^es ／ `BackingSet^es
］`内部~slot$の値
◎
Let backing be the value of the [[BackingMap]] internal slot of object, if the interface has a maplike declaration, or the [[BackingSet]] internal slot of object otherwise.
</li>
	<li>
<p>
%callbackWrapper := 被呼出時に次に従って挙動する `Function^t ：
◎
Let callbackWrapper be a Function that, when invoked, behaves as follows:
</p>

		<ol>
			<li>
( %v, %k ) := 関数に渡された ( 第一~引数, 第二~引数 )
◎
Let v and k be the first two arguments passed to the function.
</li>
			<li>
%thisArg := `this^v 値
◎
Let thisArg be the this value.
</li>
			<li>
`Call$A( %callbackFn, %thisArg, « %v, %k, %object » )
◎
Call(callbackFn, thisArg, «v, k, object»).
</li>
		</ol>

<p class="note">注記：
%callbackWrapper 関数は、単純に，第三~引数に %object を渡して ~~入力の %callbackFn を~callする
— その内部［
`BackingMap^es ／ `BackingSet^es
］~objではなく。
◎
Note: The callbackWrapper function simply calls the incoming callbackFn with object as the third argument rather than its internal [[BackingMap]] or [[BackingSet]] object.
</p>

<p class="issue">
~script作者は、［
forEach が~callされる度に， %callbackWrapper が新たな関数になる
］かどうか，観測し得るだろうか？
［
環境を capture <!-- ＊ -->した唯一の関数が在ること
］を指定する仕方として，何が最良になるだろうか？
◎
Can the script author observe that callbackWrapper might be a new function every time forEach is called? What’s the best way of specifying that there’s only one function that has captured an environment?
</p>

	</li>
	<li>
%forEach := 
( `forEach^l, %backing )
を引数に，
%backing の `Get^es~内部~methを~callした結果
◎
Let forEach be the result of calling the [[Get]] internal method of backing with “forEach” and backing as arguments.
</li>
	<li>
~IF
`IsCallable$A( %forEach ) ~EQ `false^v
~THEN
~THROW `TypeError^t
◎
If IsCallable(forEach) is false, throw a TypeError.
</li>
	<li>
`Call$A( %forEach, %backing, « %callbackWrapper, %thisArg » )
◎
Call(forEach, backing, «callbackWrapper, thisArg»).
</li>
	<li>
~RET `undefined^v
◎
Return undefined.
</li>
</ol>

	</dd>
</dl>

<!--cp-length-is-1-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `forEach^l である。
◎
The value of the Function object’s “name” property is the String value “forEach”.
</p>

				</section>
			</section>
			<section id="es-iterable">
<h4 title="Iterable declarations">3.6.9. 可反復~宣言</h4>

				<section id="es-iterable-entries">
<h5 title="entries">3.6.9.1. entries</h5>

<div class="p">
<p>
`可反復~宣言$を持つ`~ifc$には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `entries^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration, then a property named “entries” must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>~ifcは`値~反復子$を持つ場合：</dt>
	<dd>
`ArrayPrototype$esI の
`entries^l ~data-propの初期~値。
◎
If the interface has a value iterator, then the Function object is the initial value of the “entries” data property of %ArrayPrototype%.
</dd>

	<dt>~ifcは`~pair反復子$を持つ場合：
</dt>
	<dd>
`iterator$esS ~propの値で与えられる `Function^t ~obj。
◎
If the interface has a pair iterator, then the Function object is the value of the @@iterator property.
</dd>
</dl>

				</section>
				<section id="es-iterable-keys">
<h5 title="keys">3.6.9.2. keys</h5>


<div class="p">
<p>
`可反復~宣言$を持つ`~ifc$には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `keys^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration, then a property named “keys” must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>~ifcは`値~反復子$を持つ場合：</dt>
	<dd>
`ArrayPrototype$esI の `keys^l ~data-propの初期~値。
◎
If the interface has a value iterator, then the Function object is the initial value of the “keys” data property of %ArrayPrototype%.
</dd>

	<dt>~ifcは`~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then the Function, when invoked, must behave as follows:
</dt>
	<dd>
<!--cp-F-must-behave-as-follows-->

<ol class="algorithm">
	<!--cp-let-ToObject-this-->
	<li>
~IF
%object は `~platform~obj$である
~THEN
( %object, `keys^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier “keys”, and
• the type “method”.
</li>
	<li id="cp-let-ifc-iterable-declared">
%interface := `可反復~宣言$が宣言されている`~ifc$
◎ 
Let interface be the interface on which the iterable declaration is declared on.
</li>
	<!--cp-throw-if-not-impl-->

	<li>
~RET ［
%interface,
~target %object,
反復子の種類 `key^C
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind “key”.
◎
Return iterator.
</li>
</ol>
	</dd>
</dl>


<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `keys^l である。
◎
The value of the Function object’s “name” property is the String value “keys”.
</p>

				</section>
				<section id="es-iterable-values">
<h5 title="values">3.6.9.3. values</h5>

<div class="p">
<p>
`可反復~宣言$を持つ`~ifc$には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `values^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration, then a property named “values” must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>~ifcは`値~反復子$を持つ場合：</dt>
	<dd>
`iterator$esS ~propの値で与えられる `Function^t ~obj。
◎
If the interface has a value iterator, then the Function object is the value of the @@iterator property.
</dd>

	<dt>~ifcは`~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then the Function, when invoked, must behave as follows:
</dt>
	<dd>
<!--cp-F-must-behave-as-follows-->

<ol class="algorithm">
	<!--cp-let-ToObject-this-->
	<li>
~IF
%object は `~platform~obj$である
~THEN
( %object, `entries^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier “entries”, and
• the type “method”.
</li>
	<!--cp-let-ifc-iterable-declared-->
	<!--cp-throw-if-not-impl-->
	<li>
~RET ［
%interface,
~target %object,
反復子の種類 `value^C
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind “value”.
◎
Return iterator.
</li>
</ol>

	</dd>
</dl>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `values^l である。
◎
The value of the Function object’s “name” property is the String value “values”.
</p>


				</section>
				<section id="es-default-iterator-object">
<h5 title="Default iterator objects">3.6.9.4. 既定の反復子~obj</h5>


<p>
所与の［
`~ifc$, ~target, 反復の種類
］に対する
`既定の反復子~obj@
とは、~objであって，その
`Prototype^es 内部~prop が，その~ifcの`反復子~原型~obj$であるものである。
◎
A default iterator object for a given interface, target and iteration kind is an object whose internal [[Prototype]] property is the iterator prototype object for the interface.
</p>

<p>
`既定の反復子~obj$は、次の３つの値を内部に持つ：
◎
A default iterator object has three internal values:
</p>

<dl>
	<dt>~target</dt>
	<dd>
反復される値を供給する~obj
◎
its target, which is an object whose values are to be iterated,
</dd>

	<dt>種類</dt>
	<dd>
反復の種類
<span class="trans-note">【
`key^C, `value^C, `key+value^C のいずれか
】</span>

◎
its kind, which is the iteration kind,
</dd>

	<dt>~index</dt>
	<dd>
一連の値のうち，反復されることになる値を指す、現在の~index。
◎
its index, which is the current index into the values value to be iterated.
</dd>

</dl>


<p class="note">注記：
既定の反復子~objは、`~pair反復子$のみに利用される
—
`値~反復子$は、現在は，~objの`被support~prop~index$上を反復するように制約されており、標準の~JS `Array^t 反復子~objを利用する。
<!-- #dfn-supported-indexed-properties＊誤記？ -->
◎
Note: Default iterator objects are only used for pair iterators; value iterators, as they are currently restricted to iterating over an object’s supported indexed properties, use standard ECMAScript Array iterator objects.
</p>

<p>
`既定の反復子~obj$が最初に作成されたときの~indexは、 0 にされる。
◎
When a default iterator object is first created, its index is set to 0.
</p>

<p>
所与の`~ifc$に対する`既定の反復子~obj$の `~class文字列$は、［
その~ifcの`識別子$,
文字列 `Iterator^l 
］の連結である。
◎
The class string of a default iterator object for a given interface is the result of concatenting the identifier of the interface and the string “Iterator”.
</p>

				</section>
				<section id="es-iterator-prototype-object">
<h5 title="Iterator prototype object">3.6.9.5. 反復子~原型~obj</h5>

<p>
`~pair反復子$を持つどの`~ifc$に対しても、
`反復子~原型~obj@
と呼ばれる~objが存在する。
それは、その~ifcに対する`既定の反復子~obj$の原型としての~~役割を担う。
◎
The iterator prototype object for a given interface is an object that exists for every interface that has a pair iterator. It serves as the prototype for default iterator objects for the interface.
</p>

<p>
`反復子~原型~obj$の `Prototype^es 内部~propは、
`IteratorPrototype$esI で~MUST。
◎
The internal [[Prototype]] property of an iterator prototype object must be %IteratorPrototype%.
</p>

<div class="p">
<p>
`反復子~原型~obj$は、次の特徴を有する~propを持た~MUST：
</p>

<ul>
	<li>
名前は `next^l
</li>
	<li>
値は 下に与えるように挙動する`関数~obj$
</li>
	<!--cp-has-attr-TTT-->
</ul>

◎
An iterator prototype object must have a property named “next” with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object that behaves as follows:
</div>

<ol class="algorithm">
	<li>
%interface := その`反復子~原型~obj$が存在する`~ifc$
◎
Let interface be the interface for which the iterator prototype object exists.
</li>
	<!--cp-let-ToObject-this-->
	<li>
~IF
%object は `~platform~obj$である
~THEN
( %object, `next^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier “next”, and
• the type “method”.
</li>
	<li>
~IF
%object は %interface に対する`既定の反復子~obj$でない
~THEN
~THROW `TypeError^t
◎
If object is not a default iterator object for interface, then throw a TypeError.
</li>
	<li>
%target := %object の~target
◎
Let target be object’s target.
</li>
	<li>
%index := %object の~index
◎
Let index be object’s index.
</li>
	<li>
%kind := %object の種類
◎
Let kind be object’s kind.
</li>
	<li>
<p>
%values := `反復される値~pair$の~list
◎
Let values be the list of value pairs to iterate over.
</p>

<p class="trans-note">【
変数 %target が~algoのどこにも利用されていない —
この段で %values を供給する~objを指すと見られるが。
】</p>

	</li>
	<li>
%len := %values の長さ
◎
Let len be the length of values.
</li>
	<li>
~IF
%index ~GTE %len
~THEN
~RET
`CreateIterResultObject$A(`undefined^v, `true^v)
◎
If index is greater than or equal to len, then return CreateIterResultObject(undefined, true).
</li>
	<li>
%pair := %values 内の %index に位置する~entry
◎
Let pair be the entry in values at index index.
</li>
	<li>
%object の~index ← %index + 1
◎
Set object’s index to index + 1.
</li>
	<li>
<p>
%result :=
%kind の値に応じて，次で決定される値：
◎
Let result be a value determined by the value of kind:
</p>

		<dl class="switch">
			<dt>`key^C</dt>
			<dd>
<ol class="algorithm">
	<li id="cp-let-idlkey-of-pair">
%idlKey := %pair の~key
◎
Let idlKey be pair’s key.
</li>
	<li id="cp-idlKey-toES">
%key := %idlKey を~JS値に`toES^した結果
◎
Let key be the result of converting idlKey to an ECMAScript value.
</li>
	<li>
%result ← %key
◎
result is key.
</li>
</ol>
			</dd>

			<dt>`value^C</dt>
			<dd>
<ol class="algorithm">
	<li id="cp-let-idlValue-of-pair">
%idlValue := %pair の~key
◎
Let idlValue be pair’s value.
</li>
	<li id="cp-idlValue-toES">
%value := %idlValue を~JS値に`toES^した結果
◎
Let value be the result of converting idlValue to an ECMAScript value.
</li>
	<li>
%result ← %value
◎
result is value.
</li>
</ol>
			</dd>

			<dt>`key+value^C</dt>
			<dd>
<ol class="algorithm">
	<!--cp-let-idlkey-of-pair-->
	<!--cp-let-idlValue-of-pair-->
	<!--cp-idlKey-toES-->
	<!--cp-idlValue-toES-->
	<li>
%array := `ArrayCreate$A( 2 ) を遂行した結果
◎
Let array be the result of performing ArrayCreate(2).
</li>
	<li>
`CreateDataProperty$A( %array, `0^l, %key ) を~callする
◎
Call CreateDataProperty(array, "0", key).
</li>
	<li>
`CreateDataProperty$A( %array, `1^l, %value ) を~callする
◎
Call CreateDataProperty(array, "1", value).
</li>
	<li>
%result ← %array
◎
result is array.
</li>
</ol>
			</dd>
		</dl>
	</li>
	<li>
~RET
`CreateIterResultObject$A( %result, `false^v )
◎
Return CreateIterResultObject(result, false).
</li>
</ol>

<p>
所与の`~ifc$に対する`反復子~原型~obj$の `~class文字列$は［
その~ifcの`識別子$,
文字列 `Iterator^l
］の連結である。
◎
The class string of an iterator prototype object for a given interface is the result of concatenting the identifier of the interface and the string “Iterator”.
</p>

				</section>
			</section>
			<section id="es-maplike" class="L2">
<h4 title="Maplike declarations">3.6.10. ~maplike 宣言</h4>

<p>
`~maplike 宣言$を持つ`~ifc$
— この節を通して， %A と記される —
を実装する どの~objも，
`BackingMap^es `内部~slot$を持た~MUST。
— それは、初期~時には，新たに作成された `Map^t ~objに設定される。
この `Map^t ~objの `MapData^es 内部~slotが，~objの一連の`~map~entry$になる。
◎
Any object that implements an interface that has a maplike declaration must have a [[BackingMap]] internal slot, which is initially set to a newly created Map object. This Map object’s [[MapData]] internal slot is the object’s map entries.
</p>

<p>
%A の`~ifc原型~obj$上には、いくつかの追加の~propが存在する。
これらの追加の~propは、以下の各 下位~節にて述べられる。
◎
If an interface A is declared with a maplike declaration, then there exists a number of additional properties on A’s interface prototype object. These additional properties are described in the sub-sections below.
</p>

<p>
それらの~propのうち一部のものは、以下において［
所与の関数~名に対し，
`内部~map~objへ転送する@
ような`関数~obj$ 値を持つ
］ように定義される。
その種の関数は、被呼出時に次に従って挙動する：
◎
Some of the properties below are defined to have a function object value that forwards to the internal map object for a given function name. Such functions behave as follows when invoked:
</p>

<ol class="algorithm">
	<!--cp-let-O-this-value-->
	<li id="cp-let-arguments-passed">
%arguments := 関数に渡された引数の~list
◎
Let arguments be the list of arguments passed to this function.
</li>
	<li id="cp-let-name-function-name">
%name := 関数~名
◎
Let name be the function name.
</li>
	<li id="cp-security-check-name">
~IF
%O は `~platform~obj$である
~THEN
( %O, %name, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• an identifier equal to name, and
• the type “method”.
</li>
	<li id="cp-throw-if-O-not-obj">
~IF
%O は %A を実装する~objでない
~THEN
~THROW `TypeError^t
◎
If O is not an object that implements A, then throw a TypeError.
</li>
	<li id="cp-let-map-BackingMap">
%map :=
%O の `BackingMap^es `内部~slot$の値である `Map^t ~obj
◎
Let map be the Map object that is the value of O’s [[BackingMap]] internal slot.
</li>
	<li id="cp-Get-name-map">
%function :=
( %name, %map )
を引数に，
%map の `Get^es 内部~methを~callした結果
◎
Let function be the result of calling the [[Get]] internal method of map passing name and map as arguments.
</li>
	<li id="cp-throw-if-IsCallable-funciton-false">
~IF
`IsCallable$A( %function ) ~EQ `false^v
~THEN
~THROW `TypeError^t
◎
If IsCallable(function) is false, then throw a TypeError.
</li>
	<li>
~RET
`Call$A( %function, %map, %arguments )
◎
Return Call(function, map, arguments).
</li>
</ol>

				<section id="es-map-size">
<h5 title="size">3.6.10.1. size</h5>
<p>
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
There must exist a property named “size” on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
名前は `size^l
◎
↑</li>
	<li>
属性
<span class="descriptor">{&nbsp;[[Get]]: %G, [[Enumerable]]: `false^v, [[Configurable]]: `true^v&nbsp;}</span>
を持つ。
ここで %G は、次項にて定義される
`~map~size取得子@
である。
◎
The property has attributes { [[Get]]: G, [[Enumerable]]: false, [[Configurable]]: true }, where G is the interface’s map size getter, defined below.
</li>
	<li>
<p>
`~map~size取得子$は、被呼出時の挙動が次で与えられる， `Function^t ~obj：
◎
The map size getter is a Function object whose behavior when invoked is as follows:
</p>

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li id="cp-security-check-size">
~IF
%O は `~platform~obj$である
~THEN
( %O, `size^l, `取得子^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier “size”, and
• the type “getter”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li>
~RET
( `size^l, %map )
を引数に，
%map の `Get^es 内部~methを~callした結果
◎
Return the result of calling the [[Get]] internal method of map passing “size” and map as arguments.
</li>
		</ol>
<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `size^l である。
◎
The value of the Function object’s “name” property is the String value “size”.
</p>

	</li>
</ul>


				</section>
				<section id="es-map-entries">
<h5 title="entries">3.6.10.2. entries</h5>

<div class="p">
<p>
%A の`~ifc原型~obj$上には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `entries^l
</li>
	<li>
値は `iterator$esS ~propの値で与えられる`関数~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
A property named “entries” must exist on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the function object that is the value of the @@iterator property.
</div>


				</section>
				<section id="es-map-keys-values">
<h5 title="keys and values">3.6.10.3. keys, values</h5>

<p>
名前［
`keys^l ／ `values^l
］に対しては、
%A の`~ifc原型~obj$上には，次の特徴を有する 同じ名前の~propが存在し~MUST。
◎
For both of “keys” and “values”, there must exist a property with that name on A’s interface prototype object with the following characteristics:
</p>


<ul>
	<li id="cp-has-TFT">
属性 `TFT^desc を持つ。
◎
The property has attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</li>
	<li>
値は `内部~map~objへ転送する$ `Function^t ~obj。
◎
The value of the property is a Function object that forwards that name to the internal map object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、 `String^t 値［
`keys^l ／ `values^l
］である。
◎
The value of the Function object’s “name” property is the String value “keys” or “values”, correspondingly.
</p>

				</section>
				<section id="es-map-get-has">
<h5 title="get and has">3.6.10.4. get, has</h5>

<p>
名前［
`get^l ／ `has^l
］に対しては、
%A の`~ifc原型~obj$上には，次の特徴を有する 同じ名前の~propが存在し~MUST。
◎
For both of “get” and “has”, there must exist a property with that name on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<p id="cp-value-is-Function-as">
値は 被呼出時に次に従って挙動する `Function^t ~obj：
◎
The value of the property is a Function object that behaves as follows when invoked:
</p>

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
%name := ~propの名前（ `get^l または `has^l ）。
◎
Let name be the name of the property – “get” or “has”.
</li>
			<!--cp-security-check-name-->
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li id="cp-let-keyType">
%keyType := `~maplike 宣言$にて指定された~key型
◎
Let keyType be the key type specified in the maplike declaration.
</li>
			<!--cp-Get-name-map-->
			<li id="cp-let-keyArg-1st-arg">
%keyArg := ［
この関数に引数が渡されているならば その第一~引数の値 ／
~ELSE_ `undefined^v
］
◎
Let keyArg be the first argument passed to this function, or undefined if not supplied.
</li>
			<li id="cp-keyArg-toIDL-keyIDL">
%keyIDL := %keyArg を型 %keyType の~IDL値に`toIDL^した結果
◎
Let keyIDL be the result of converting keyArg to an IDL value of type keyType.
</li>
			<li id="cp-keyIDL-toES-key">
%key := %keyIDL を~JS値に`toES^した結果
◎
Let key be the result of converting keyIDL to an ECMAScript value.
</li>
			<li id="cp-Call-fmk">
~RET
`Call$A( %function, %map, « %key » )
◎
Return Call(function, map, «key»).
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この `Function^t ~objの `name^l ~propの値は、 `String^t 値［
`get^l ／ `has^l
］である。
◎
The value of the Function object’s “name” property is the String value “get” or “has”, correspondingly.
</p>

				</section>
				<section id="es-map-clear">
<h5 title="clear">3.6.10.5. clear</h5>

<p>
%A のどの`広義~帰結~ifc$も識別子 `clear^l の`~ifc~mb$を宣言しない, かつ
%A は可書~maplike 宣言を伴って宣言されている場合、
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
If A and A’s consequential interfaces do not declare an interface member with identifier “clear”, and A was declared with a read–write maplike declaration, then a property named “clear” and the following characteristics must exist on A’s interface prototype object:
</p>


<ul>
	<li>
名前は `clear^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
値は `内部~map~objへ転送する$`Function^t ~obj。
◎
The value of the property is a Function object that forwards “clear” to the internal map object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `clear^l である。
◎
The value of the Function object’s “name” property is the String value “clear”.
</p>

				</section>
				<section id="es-map-delete">
<h5 title="delete">3.6.10.6. delete</h5>


<p>
%A のどの`広義~帰結~ifc$も，識別子 `delete^l の`~ifc~mb$を宣言しない, かつ
%A は可書~maplike 宣言を伴って宣言されている場合、
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
If A and A’s consequential interfaces do not declare an interface member with identifier “delete”, and A was declared with a read–write maplike declaration, then a property named “delete” and the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<li>
名前は `delete^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-Function-as-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, `delete^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier “delete”, and
• the type “method”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<!--cp-let-keyType-->
			<li>
%function :=
( `delete^l, %map )
を引数に，
%map の `Get^es 内部~methを~callした結果
◎
Let function be the result of calling the [[Get]] internal method of map passing “delete” and map as arguments.
</li>
			<!--cp-let-keyArg-1st-arg-->
			<!--cp-keyArg-toIDL-keyIDL-->
			<!--cp-keyIDL-toES-key-->
			<!--cp-Call-fmk-->
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `delete^l である。
◎
The value of the Function object’s “name” property is the String value “delete”.
</p>

				</section>
				<section id="es-map-set">
<h5 title="set">3.6.10.7. set</h5>

<p>
%A のどの`広義~帰結~ifc$も，［
識別子 `set^l の`~ifc~mb$を宣言しない, かつ
%A は可書~maplike 宣言を伴って宣言されている
］ならば、
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
If A and A’s consequential interfaces do not declare an interface member with identifier “set”, and A was declared with a read–write maplike declaration, then a property named “set” and the following characteristics must exist on A’s interface prototype object:
</p>


<ul>
	<li>
名前は `set^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-Function-as-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, `set^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier “set”, and
• the type “method”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li>
%keyType, %valueType := 順に，`~maplike 宣言$にて指定された~key型, ~value型
◎
Let keyType and valueType be the key and value types specified in the maplike declaration.
</li>
			<li>
%function :=
( `set^l, %map )
を引数に，
%map の `Get^es 内部~methを~callした結果
◎
Let function be the result of calling the [[Get]] internal method of map passing “set” and map as arguments.
</li>
	<!--cp-let-keyArg-1st-arg-->

			<li>
%valueArg :=［
この関数に第二~引数が渡されているならば その値 ／
~ELSE_ `undefined^v
］
◎
Let valueArg be the second argument passed to this function, or undefined if not supplied.
</li>
			<!--cp-keyArg-toIDL-keyIDL-->
			<li>
%valueIDL := %valueArg を型 %valueType の~IDL値に`toIDL^した結果
◎
Let valueIDL be the result of converting valueArg to an IDL value of type valueType.
</li>
			<!--cp-keyIDL-toES-key-->
			<li>
%value := %valueIDL を~JS値に`toES^した結果
◎
Let value be the result of converting valueIDL to an ECMAScript value.
</li>
			<li>
%result :=
! `Call$A( %function, %map, « %key, value » )
◎
! Call(function, map, «key, value»).
</li>
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
	</li>
</ul>

<p>
この `Function^t ~objの `length^l ~propの値は、 `Number^t 値 `2^v である。
◎
The value of the Function object’s “length” property is the Number value 2.
</p>

<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `set^l である。
◎
The value of the Function object’s “name” property is the String value “set”.
</p>

				</section>
			</section>
			<section id="es-setlike" class="L2">
<h4 title="Setlike declarations">3.6.11. ~setlike 宣言</h4>

<p>
`~setlike 宣言$を持つ`~ifc$
— この節を通して， %A と記される —
を実装するどの~objも，
`BackingSet^es `内部~slot$を持た~MUST
— それは、初期~時には，新たに作成された `Set^t ~objに設定される。
この `Map^t ~objの `SetData^es 内部~slotが，~objの一連の`~set~entry$になる。
◎
Any object that implements an interface that has a setlike declaration must have a [[BackingSet]] internal slot, which is initially set to a newly created Set object. This Set object’s [[SetData]] internal slot is the object’s set entries.
</p>

<p>
%A の`~ifc原型~obj$上には、いくつかの追加の~propが存在する。
これらの追加の~propは、以下の各 下位~節にて述べられる。
◎
If an interface A is declared with a setlike declaration, then there exists a number of additional properties on A’s interface prototype object. These additional properties are described in the sub-sections below.
</p>

<p>
それらの~propのうち一部のものは、以下にて
所与の関数~名に対し，
`内部~set~objへ転送する@
ような`関数~obj$ 値を持つように定義される。
その種の関数は、被呼出時に次に従って挙動する：
◎
Some of the properties below are defined to have a function object value that forwards to the internal set object for a given function name. Such functions behave as follows when invoked:
</p>
  
<ol class="algorithm">
	<!--cp-let-O-this-value-->
	<!--cp-let-arguments-passed-->
	<!--cp-let-name-function-name-->
	<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, %name, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• an identifier equal to name, and
• the type “method”.
</li>
	<!--cp-throw-if-O-not-obj-->
	<li id="cp-let-set-BackingSet">
%set :=
%O の `BackingSet^es `内部~slot$の値である `Set^t ~obj
◎
Let set be the Set object that is the value of O’s [[BackingSet]] internal slot.
</li>
	<li id="cp-Get-name-set">
%function :=
( %name, %set )
を引数に，
%set の `Get^es 内部~methを~callした結果
◎
Let function be the result of calling the [[Get]] internal method of set passing name and set as arguments.
</li>
	<!--cp-throw-if-IsCallable-funciton-false-->
	<li>
~RET
`Call$A( %function, %set, %arguments )
◎
Return Call(function, set, arguments).
</li>
</ol>

				<section id="es-set-size">
<h5 title="size">3.6.11.1. size</h5>


<p>
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
There must exist a property named “size” on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
名前は `size^l
◎
↑</li>
	<li>
属性
<span class="descriptor">{&nbsp;[[Get]]: %G, [[Enumerable]]: `false^v, [[Configurable]]: `true^v&nbsp;}</span>
を持つ。
ここで %G は、下に定義される
`~set~size取得子@
である。
◎
The property has attributes { [[Get]]: G, [[Enumerable]]: false, [[Configurable]]: true }, where G is the interface’s set size getter, defined below.
	</li>
</ul>

<p>
`~set~size取得子$は、被呼出時の挙動が次で与えられる， `Function^t ~objである：
◎
The set size getter is a Function object whose behavior when invoked is as follows:
</p>

		<ol class="algorithm">
	<!--cp-let-O-this-value-->
	<!--cp-security-check-size-->
	<!--cp-throw-if-O-not-obj-->
	<!--cp-let-set-BackingSet-->
			<li>
~RET
( `size^l, %set )
を引数に，
%set の `Get^es 内部~methを~callした結果
◎
Return the result of calling the [[Get]] internal method of set passing “size” and set as arguments.
</li>
		</ol>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `size^l である。
◎
The value of the Function object’s “name” property is the String value “size”.
</p>

				</section>
				<section id="es-set-values">
<h5 title="values">3.6.11.2. values</h5>

<div class="p">
<p>
%A の`~ifc原型~obj$上には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `values^l
</li>
	<li>
値は `iterator$esS ~propの値で与えられる`関数~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
A property named “values” must exist on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the function object that is the value of the @@iterator property.
</div>


				</section>
				<section id="es-set-entries-keys">
<h5 title="entries and keys">3.6.11.3. entries, keys</h5>


<p>
名前［
`entries^l ／ `keys^l,
］に対しては、
%A の`~ifc原型~obj$上には，次の特徴を有する 同じ名前の~propが存在し~MUST。
◎
For both of “entries” and “keys”, there must exist a property with that name on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
値は `内部~set~objへ転送する$ `Function^t ~obj。
◎
The value of the property is a Function object that forwards that name to the internal set object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、 `String^t 値［
`entries^l ／ `keys^l
］である。
◎
The value of the Function object’s “name” property is the String value “entries” or “keys”, correspondingly.
</p>


				</section>
				<section id="es-set-has">
<h5 title="has">3.6.11.4. has</h5>

<p>
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST。
◎
There must exist a property with named “has” on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
名前は `has^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-Function-as-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, `has^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier “has”, and
• the type “method”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-set-BackingSet-->
			<li>
%type := `~setlike 宣言$にて指定された~value型
◎
Let type be the value type specified in the setlike declaration.
</li>
			<li>
%function :=
( `has^l, %set )
を引数に，
%set の `Get^es 内部~methを~callした結果
◎
Let function be the result of calling the [[Get]] internal method of set passing “has” and set as arguments.
</li>
			<li id="cp-let-arg-1st-arg">
%arg := ［
この関数に引数が渡されているならば その第一~引数の値 ／
~ELSE_ `undefined^v
］
◎
Let arg be the first argument passed to this function, or undefined if not supplied.
</li>
			<li id="cp-arg-toIDL-type">
%idlValue := %arg を型 %type の~IDL値に `toIDL^した結果
◎
Let idlValue be the result of converting arg to an IDL value of type type.
</li>
			<!--cp-idlValue-toES-->
			<li>
~RET
`Call$A( %function, %set, « %value » )
◎
Call(function, set, «value»).
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `has^l である。
◎
The value of the Function object’s “name” property is the String value “has”.
</p>

				</section>
<!-- es-set-add-delete？ -->
				<section id="es-add-delete">
<h5 title="add and delete">3.6.11.5. add, delete</h5>


<p>
名前［
`add^l ／ `delete^l
］に対しては、次の２条件：
◎
For both of “add” and “delete”, if:
</p>

<ul>
	<li>
%A のどの`広義~帰結~ifc$も，その名前に合致する識別子を伴う`~ifc~mb$を宣言していない
◎
A and A’s consequential interfaces do not declare an interface member with a matching identifier, and
</li>
	<li>
%A は可書`~maplike 宣言$を伴って宣言されている
◎
A was declared with a read–write setlike declaration,
</li>
</ul>

<p>
がいずれも満たされるならば、
%A の`~ifc原型~obj$上には，次の特徴を有する 同じ名前の~propが存在し~MUST：
◎
then a property with that name and the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-Function-as-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
%name := ~propの名前（ `add^l または `delete^l ）。
◎
Let name be the name of the property – “add” or “delete”.
</li>
			<!--cp-security-check-name-->
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-set-BackingSet-->
			<li>
%type := `~setlike 宣言$に指定された値~型
◎
Let type be the value type specified in the setlike declaration.
</li>
			<!--cp-Get-name-set-->
			<!--cp-let-arg-1st-arg-->
			<!--cp-arg-toIDL-type-->
			<!--cp-idlValue-toES-->
			<li>
%result :=
! `Call$A( %function, %set, « %value » )
◎
Let result be ! Call(function, set, «value»).
</li>
			<li>
~RET ［
%name ~EQ `delete^l ならば %result ／
~ELSE_ %O
］
◎
If name is "delete", then retun result.
◎
Otherwise, return O.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この `Function^t ~objの `name^l ~propの値は、 `String^t 値［
`add^l ／ `delete^l
］である。
◎
The value of the Function object’s “name” property is the String value “add” or “delete”, correspondingly.
</p>

				</section>
				<section id="es-set-clear">
<h5 title="clear">3.6.11.6. clear</h5>

<p>
%A のどの`広義~帰結~ifc$も，合致する識別子を伴う`~ifc~mb$を宣言しない,
かつ %A は可書~setlike 宣言を伴って宣言されている場合、
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
If A and A’s consequential interfaces do not declare an interface member with a matching identifier, and A was declared with a read–write setlike declaration, then a property named “clear” and the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<li>
名前は `clear^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
値は `内部~set~objへ転送する$ `Function^t ~obj。
◎
The value of the property is a Function object that forwards “clear” to the internal set object.
</li>
	</ul>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `clear^l である。
◎
The value of the Function object’s “name” property is the String value “clear”.
</p>

				</section>
			</section>
		</section>
		<section id="es-implements-statements">
<h3 title="Implements statements">3.7. ~implements文</h3>


<p>
~ifc %A の`~ifc原型~obj$は、 %A のすべての`帰結~ifc$に対し、その~ifc原型~obj上に存在する［
`定数$,
`属性$,
`演算$
［
`可反復~宣言$ ／
`~maplike 宣言$ ／
`~setlike 宣言$
］］のそれぞれについて，対応する~propの複製を持た~MUST。
演算に対しては、~propが `Function^t ~obj値を伴う~data-propである所では，~propの各~複製ごとに元のものと異なる `Function^t ~objを持た~MUST。
同様に，属性に対しても、~accessor~propの各~複製ごとに，その取得子に対し, また
その設定子に対しても同様に、元のものと異なる `Function^t ~objを持た~MUST。
◎
The interface prototype object of an interface A must have a copy of each property that corresponds to one of the constants, attributes, operations, iterable declarations, maplike declarations and setlike declarations that exist on all of the interface prototype objects of A’s consequential interfaces. For operations, where the property is a data property with a Function object value, each copy of the property must have distinct Function objects. For attributes, each copy of the accessor property must have distinct Function objects for their getters, and similarly with their setters.
</p>



<div class="note">

<p>
［
~implements文により 存在が与えられる複製
］の値である `Function^t ~objの~callを通して，`演算$が呼出されたときは、その~objが，~~実際に［
その~propを持つ`~ifc原型~obj$に対応する`~ifc$を実装するもの
］であることを~~確認するために、 `this^v 値が検査される。
◎
When invoking an operation by calling a Function object that is the value of one of the copies that exists due to an implements statement, the this value is checked to ensure that it is an object that implements the interface corresponding to the interface prototype object that the property is on.
</p>

<p>
例えば次の~IDL片を考える：
◎
For example, consider the following IDL:
</p>

<pre class="idl-code">
interface A {
  void f();
};

interface B { };
B implements A;

interface C { };
C implements A;
</pre>

<p>
（ `B^T ではなく，）`A^T や `C^T を実装する~obj上で
`B.prototype.f^c
を~callした結果は、 `TypeError^T の投出になる。
しかしながら、 `B^T や `C^T を実装する~obj上では
`A.prototype.f^c
の~callは成功することになる。
これは、~JSにおいて~IDL演算の呼出がどのように働くかを定義する，
`es-operations$sec
の~algoにより取扱われる。
◎
Attempting to call B.prototype.f on an object that implements A (but not B) or one that implements C will result in a TypeError being thrown. However, calling A.prototype.f on an object that implements B or one that implements C would succeed. This is handled by the algorithm in §3.6.7 Operations that defines how IDL operation invocation works in ECMAScript.
</p>

<p>
同様の挙動が~IDL`属性$に対応する取得子や設定子の `Function^t ~objにも要求され、`es-attributes$sec
にて取扱われる。
◎
Similar behavior is required for the getter and setter Function objects that correspond to an IDL attributes, and this is handled in §3.6.6 Attributes.
</p>
</div>

		</section>
		<section id="es-platform-objects">
<h3 title="Platform objects implementing interfaces">3.8. ~ifcを実装している~platform~obj</h3>


<p>
どの`~platform~obj$も、`初期~obj$とちょうど同じ様に，大域環境に属する。
各~platform~objがどの大域環境に（または、代理を通して，どの大域~objに）属するか，についての言明-は~Web~IDLを利用する仕様が責を負う。
◎
Every platform object is associated with a global environment, just as the initial objects are. It is the responsibility of specifications using Web IDL to state which global environment (or, by proxy, which global object) each platform object is associated with.
</p>

<p>
１つ以上の~ifcを実装する~platform~objの
`主~ifc@
とは、それが実装する［
`追補~ifc$でない~ifc
］のうち，継承階層において最も末端の~ifcである。
~platform~objの `Prototype^es 内部~propの値は、`~platform~obj$が属する大域環境に属する，`主~ifc$の`~ifc原型~obj$である。
◎
The primary interface of a platform object that implements one or more interfaces is the most-derived non-supplemental interface that it implements. The value of the internal [[Prototype]] property of the platform object is the interface prototype object of the primary interface from the platform object’s associated global environment.
</p>

<p>
所与の`~platform~obj$が属する大域環境は、その作成-後に
`変化-@
し得る。
~platform~objが属する大域環境が変化した場合、その `Prototype^es 内部~prop は，その新たな大域環境に属する `主~ifc$の`~ifc原型~obj$に，即時に更新され~MUST。
◎
The global environment that a given platform object is associated with can change after it has been created. When the global environment associated with a platform object is changed, its internal [[Prototype]] property must be immediately updated to be the interface prototype object of the primary interface from the platform object’s newly associated global environment.
</p>

<p>
１個~以上の~ifcを実装する~platform~objの `~class文字列$は、~platform~objの`主~ifc$の`識別子$で~MUST。
◎
The class string of a platform object that implements one or more interfaces must be the identifier of the primary interface of the platform object.
</p>


			<section id="indexed-and-named-properties">
<h4 title="Indexed and named properties">3.8.1. 有index~propと有名~prop</h4>

<p>
`~platform~obj$が実装する`~ifc$が［
<!-- supports indexed or named properties -->
`有index~propを~supportする$, または`有名~propを~supportする$
］場合、その~objは，~objの［有index／有名］~propに対応する，追加の~propを持って現れることになる。
これらの~propは，~obj上の “真の” 自前の~propではないが、
`GetOwnProperty^es 内部~methにより公開されて見えるようにされる。
◎
If a platform object implements an interface that supports indexed or named properties, the object will appear to have additional properties that correspond to the object’s indexed and named properties. These properties are not “real” own properties on the object, but are made to look like they are by being exposed by the [[GetOwnProperty]] internal method.
</p>

<p>
しかしながら，
`Global$x ／ `PrimaryGlobal$x
`拡張属性$が利用されている場合、有名~propは
その~obj上ではなく，［
原型鎖~内の~objである, `有名~prop~obj$
］上に公開される。
◎
However, when the [Global] or [PrimaryGlobal] extended attribute has been used, named properties are not exposed on the object but on another object in the prototype chain, the named properties object.
</p>

<p>
~objが`有index~propを~supportする$ような複数の~ifcを実装することは許容され得る。
しかしながら，そのような場合、［
~objにおける`被support~prop~index$の定義が競合していたり，それらの~ifcのいずれかが その~platform~objに対する`追補~ifc$である
］場合に、［
~objが持つように現れることになる追加の~prop
］がどれになるか, あるいは［
その有index~propに関する正確な挙動
］がどうなるか，については、未定義である。
同じことは、有名~propについても該当する。
◎
It is permissible for an object to implement multiple interfaces that support indexed properties. However, if so, and there are conflicting definitions as to the object’s supported property indices, or if one of the interfaces is a supplemental interface for the platform object, then it is undefined what additional properties the object will appear to have, or what its exact behavior will be with regard to its indexed properties. The same applies for named properties.
</p>

<p>
［
~platform~objが実装する，継承階層において最も末端の~ifc
］上で定義される`有index~prop取得子$が、［
配列~indexによる~objに対する~indexingの際の挙動
］を定義する。
`有index~prop設定子$に対しても同様になる。
先祖の~ifcによる，これらの特殊~演算の定義は、この仕方で上書きできる。
◎
The indexed property getter that is defined on the derived-most interface that the platform object implements is the one that defines the behavior when indexing the object with an array index. Similarly for indexed property setters. This way, the definitions of these special operations from ancestor interfaces can be overridden.
</p>

<p>
~objが有index~propを~supportしていることにより，存在しているかのように現れる各~propの名前を
`配列~index~prop名@
という。
それは、次の~algoが ~true を返すような~prop名 %P である：
◎
The name of each property that appears to exist due to an object supporting indexed properties is an array index property name, which is a property name P such that Type(P) is String and for which the following algorithm returns true:
</p>

<ol class="algorithm">
	<li>
~IF
`Type^(%P) ~NEQ `String^t
~THEN
~RET ~false
◎
↑</li>
	<li>
%i := `ToUint32$A( %P )
◎
Let i be ToUint32(P).
</li>
	<li>
%s := `ToString$A( %i )
◎
Let s be ToString(i).
</li>
	<li>
~IF［
%s ~NEQ %P
］~OR［
%i ~EQ 2`32^sup&nbsp;−&nbsp;1
］
~THEN
~RET ~false
◎
If s ~NEQ P or i = 2^32 − 1, then return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

<div class="p">
<p>
所与の~platform~obj %O 上の~prop名は、
%O が次を満たす`~ifc$ %I を実装するならば，
`偽装不可~prop名@
とされる：
</p>

<ul><li>%I はその~prop名を識別子とする`~ifc~mb$を持つ, かつ
</li><li>その~mbは［
%O が実装するいずれかの~ifc
］上で`偽装不可$である。
</li></ul>

◎
A property name is an unforgeable property name on a given platform object if the object implements an interface that has an interface member with that identifier and that interface member is unforgeable on any of the interfaces that O implements.
</div>


<p>
所与の有名~propを~obj上に公開するかどうかは、
`有名~propの可視性判定~algo@
を利用して決定される。
一部の有名~propは、［
`OverrideBuiltins$x `拡張属性$が利用されたかどうか
］に依存して，~obj上に公開されなくなる。
この~algoは、
( ~prop名 %P, ~obj %O )
を~~入力にとり，次に従って演算する：
◎
The named property visibility algorithm is used to determine if a given named property is exposed on an object. Some named properties are not exposed on an object depending on whether the [OverrideBuiltins] extended attribute was used. The algorithm operates as follows, with property name P and object O:
</p>

<ol class="algorithm">
	<li>
~IF
%P は %O 上の`被support~prop名$でない
~THEN
~RET ~false
◎
If P is not a supported property name of O, then return false.
</li>
	<li>
<p>
~IF
%O は名前 %P の自前の~propを持つ
~THEN
~RET ~false
◎
If O has an own property named P, then return false.
</p>

<p class="note">注記：
これには %O が偽装不可の~propを持つ事例も含まれる
— 実施においては、それらは常に ~objが被support~prop名を持つより先に設定しておかれ，対応する有名~propを不可視にするので。
◎
Note: This will include cases in which O has unforgeable properties, because in practice those are always set up before objects have any supported property names, and once set up will make the corresponding named properties invisible.
</p>

	</li>
	<li>
~IF
%O が実装する ある~ifcが， `OverrideBuiltins$x `拡張属性$を持つ
~THEN
~RET ~true
◎
If O implements an interface that has the [OverrideBuiltins] extended attribute, then return true.
</li>
	<li>
%prototype :← %O の `Prototype^es 内部~prop の値
◎
Initialize prototype to be the value of the internal [[Prototype]] property of O.
</li>
	<li>
<p>
~WHILE %prototype ~NEQ `null^v ：
◎
While prototype is not null:
</p>
		<ol>
			<li>
~IF［
%prototype は `有名~prop~obj$でない
］~AND［
%prototype は 名前 %P の自前の~propを持つ
］
~THEN
~RET ~false
◎
If prototype is not a named properties object, and prototype has an own property named P, then return false.
</li>
			<li>
%prototype ← %prototype の `Prototype^es 内部~prop の値
◎
Set prototype to be the value of the internal [[Prototype]] property of prototype.
</li>
		</ol>
	</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

<div class="note">

<p>
これにより、有名~propを伴う~objに対する~prop解決が次の順序で行えるようになる：
◎
This should ensure that for objects with named properties, property resolution is done in the following order:
</p>
	<ol>
		<li>
有index~prop
◎
Indexed properties.
</li>
		<li>
自前の~prop
— 偽装不可である属性／演算も含め。
◎
Own properties, including unforgeable attributes and operations.
</li>
		<li>
<p>
`OverrideBuiltins$x である場合：
◎
Then, if [OverrideBuiltins]:
</p>
			<ol>
				<li>
有名~prop
◎
Named properties.
</li>
				<li>
原型鎖からの~prop
◎
Properties from the prototype chain.
</li>
			</ol>
		</li>
		<li>
<p>
他の場合：
◎
Otherwise, if not [OverrideBuiltins]:
</p>
			<ol>
				<li>
原型鎖からの~prop
◎
Properties from the prototype chain.
</li>
				<li>
有名~prop
◎
Named properties.
</li>
			</ol>
		</li>
	</ol>
</div>

<p>
`取得子$の~supportは
~platform~obj `GetOwnProperty^es ~meth（`getownproperty$sec）
により取扱われ、`設定子$については
~platform~obj `DefineOwnProperty^es ~meth（`defineownproperty$sec）, および
~platform~obj `Set^es ~meth（`platformobjectset$sec）
により取扱われる。
◎
Support for getters is handled by the platform object [[GetOwnProperty]] method defined in section §3.8.3 Platform object [[GetOwnProperty]] method, and for setters by the platform object [[DefineOwnProperty]] method defined in section §3.8.8 Platform object [[DefineOwnProperty]] method and the platform object [[Set]] method defined in section §3.8.6 Platform object [[Set]] method.
</p>
			</section>
			<section id="getownproperty-guts">
<h4 title="The PlatformObjectGetOwnProperty abstract operation">3.8.2. ~PlatformObjectGetOwnProperty 抽象演算</h4>

<p>
抽象演算 ~PlatformObjectGetOwnProperty は、
( ~obj %O, ~prop名 %P, 真偽~値 %ignoreNamedProps )
を~~渡して~callされたとき，次の手続きを遂行する:
◎
The PlatformObjectGetOwnProperty abstract operation performs the following steps when called with an object O, a property name P, and a boolean ignoreNamedProps value:
</p>

<ol class="algorithm">
	<li>
<p id="cp-if-support-and-index">
~IF［
%O は `有index~propを~supportする$
］~AND［
%P は `配列~index~prop名$である
］
⇒
◎
If O supports indexed properties and P is an array index property name, then:
</p>
		<ol>
			<li id="cp-ToUint32-2">
%index := `ToUint32$A( %P )
◎
Let index be the result of calling ToUint32(P).
</li>
			<li>
<p>
~IF
%index は `被support~prop~index$である
⇒
◎
If index is a supported property index, then:
</p>
				<ol>
					<li>
%operation := `有index~prop取得子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the indexed property getter.
</li>
					<!--cp-let-uninitialized-->
					<li><!-- copy* -->
~IF
%operation は `識別子$を伴わずに定義されている
~THEN
%value ← ［
~index %index に対し，~ifcの記述に挙げられている
`有index~propの値を決定する$
手続きを遂行した結果
］
◎
If operation was defined without an identifier, then set value to the result of performing the steps listed in the interface description to determine the value of an indexed property with index as the index.
</li>
					<li><!-- copy* -->
~ELSE
~THEN
%value ← ［
( %index )
を引数に， %operation の記述に挙げられている手続きを遂行した結果
］
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the steps listed in the description of operation with index as the only argument value.
</li>
					<li>
<!--cp-ret-new-desc-->
<div>
&nbsp;&nbsp; `BTT-V^desc — ここで：

						<ul>
							<!--cp-let-convert2-->
							<li>
%B := ［
%O が実装するある~ifcに，`有index~prop設定子$が伴われている ならば `true^v ／
~ELSE_ `false^v
］
</li>
						</ul>
◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If O implements an interface with an indexed property setter, then set desc.[[Writable]] to true, otherwise set it to false.
◎
Set desc.[[Enumerable]] and desc.[[Configurable]] to true.
◎
Return desc.
</div>
					</li>
				</ol>
			</li>
			<li>
%ignoreNamedProps ← ~true
◎
Set ignoreNamedProps to true.
			</li>
		</ol>
	</li>
	<li>
<p>
~IF ［
%O は `有名~propを~supportする$
］~AND［
%O は
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴う`~ifc$を実装しない
］~AND［
( ~prop名 %P, ~obj %O )
を~~入力に，`有名~propの可視性判定~algo$を走らせた結果 ~EQ ~true
］~AND［
%ignoreNamedProps ~EQ ~false
］
⇒
◎
If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute, the result of running the named property visibility algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
</p>
		<ol>
			<li>
%operation := `有名~prop取得子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property getter.
</li>
			<!--cp-let-uninitialized-->
			<!--cp-determine-ifndef-->
			<!--cp-set-as-desc1-->

			<li>
<!--cp-ret-new-desc-->
<div>
&nbsp;&nbsp; `BET-V^desc — ここで：

				<ul>
					<!--cp-let-convert2-->
					<li>
%B := ［
%O が実装するある~ifcに，`有名~prop設定子$が伴われている ならば `true^v
<!-- and
O does not implement an interface with the [Global] extended attribute
...
--> ／
~ELSE_ `false^v
］
</li>
					<li>
%E := ［
%O が実装するある~ifcに， `LegacyUnenumerableNamedProperties$x `拡張属性$が伴われているならば `false^v ／
~ELSE_ `true^v
］
</li>
				</ul>
◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If O implements an interface with a named property setter, then set desc.[[Writable]] to true, otherwise set it to false.
◎
If O implements an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then set desc.[[Enumerable]] to false, otherwise set it to true.
◎
Set desc.[[Configurable]] to true.
◎
Return desc.
</div>
			</li>
		</ol>
	</li>
	<!--cp-return-OrdinaryGetOwnProperty-->
</ol>
			</section>
			<section id="getownproperty">
<h4 title="Platform object [[GetOwnProperty]] method">3.8.3. ~platform~obj `GetOwnProperty^es ~meth</h4>

<p>
［
`有index~propを~supportする$, または`有名~propを~supportする$
］`~ifc$を実装する どの`~platform~obj$ %O に対しても，その `GetOwnProperty^es 内部~methは、
( ~prop名 %P )
を引数に~callされたときには，次に従って挙動し~MUST：
◎
The internal [[GetOwnProperty]] method of every platform object O that implements an interface which supports indexed or named properties must behave as follows when called with property name P:
</p>

<ol class="algorithm">
	<li>
~RET
( %O, %P, `false^v )
を引数に，抽象演算 `~PlatformObjectGetOwnProperty$ を呼出した結果
◎
Return the result of invoking the PlatformObjectGetOwnProperty abstract operation with O, P, and false as arguments.
</li>
</ol>

			</section>
			<section id="invoking-indexed-setter">
<h4 title="Invoking a platform object indexed property setter">3.8.4. ~platform~obj~有index~prop~設定子の呼出し</h4>

<p>
( ~prop~名 %P, ~JS値 %V )
を~~渡して
`有index~prop設定子を呼出す@
ときは、次の手続きを遂行し~MUST：
◎
To invoke an indexed property setter with property name P and ECMAScript value V, the following steps must be performed:
</p>

<ol class="algorithm">
	<!--cp-ToUint32-2-->
	<li>
%creating := ［
%index が`被support~prop~index$でないならば ~true ／
~ELSE_ ~false
］
◎
Let creating be true if index is not a supported property index, and false otherwise.
</li>
	<li>
%operation := `有index~prop設定子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the indexed property setter.
</li>
	<li id="cp-2nd-arg">
%T := %operation の第二~引数の型
◎
Let T be the type of the second argument of operation.
</li>
	<li id="cp-V-toIDL-T">
%value := %V を型 %T の~IDL値に`toIDL^した結果
◎
Let value be the result of converting V to an IDL value of type T.
</li>
	<li>
<p id="cp-ifdef-no-id">
~IF
%operation は `識別子$を伴わずに定義されている
⇒
◎
If operation was defined without an identifier, then:
</p>
		<ol>
			<li>
~IF
%creating ~EQ ~true
~THEN
( ~index %index, 値 %value )
に対し，~ifcの記述に挙げられている
`新たな有index~propを設定する$
手続きを遂行する
◎
If creating is true, then perform the steps listed in the interface description to set the value of a new indexed property with index as the index and value as the value.
</li>
			<li>
~ELSE
~THEN
( ~index %index, 値 %value )
に対し，~ifcの記述に挙げられている
`既存の有index~propを設定する$
手続きを遂行する
◎
Otherwise, creating is false. Perform the steps listed in the interface description to set the value of an existing indexed property with index as the index and value as the value.
</li>
		</ol>
	</li>
	<li>
~ELSE
~THEN
( %index, %value )
を引数に，
%operation の記述に挙げられている手続きを遂行する
◎
Otherwise, operation was defined with an identifier. Perform the steps listed in the description of operation with index and value as the two argument values.
</li>
</ol>


			</section>
			<section id="invoking-named-setter">
<h4 title="Invoking a platform object named property setter">3.8.5. ~platform~obj~有名~prop設定子の呼出し</h4>

<p>
( ~prop~名 %P, ~JS値 %V )
を~~渡して
`有名~prop設定子を呼出す@
ときは、次の手続きを遂行し~MUST：
◎
To invoke a named property setter with property name P and ECMAScript value V, the following steps must be performed:
</p>

<ol class="algorithm">
	<li id="cp-let-creating">
%creating := ［
%P は`被support~prop名$であるならば~true ／
~ELSE_ ~false
］
◎
Let creating be true if P is not a supported property name, and false otherwise.
</li>
	<li>
%operation := `有名~prop設定子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property setter.
</li>
	<!--cp-2nd-arg-->
	<!--cp-V-toIDL-T-->
	<li>
<!--cp-ifdef-no-id-->
		<ol>
			<li>
~IF
%creating ~EQ ~true
~THEN
( 名前 %P, 値 %value )
に対し，~ifcの記述に挙げられている
`新たな有名~propを設定する$
手続きを遂行する
◎
If creating is true, then perform the steps listed in the interface description to set the value of a new named property with P as the name and value as the value.
</li>
			<li>
~ELSE
~THEN
( 名前 %P, 値 %value )
に対し，~ifcの記述に挙げられている
`既存の有名~propを設定する$
手続きを遂行する
◎
Otherwise, creating is false. Perform the steps listed in the interface description to set the value of an existing named property with P as the name and value as the value.
</li>
		</ol>
	</li>
	<li>
~ELSE
~THEN
( %P, %value )
を引数に，
%operation の記述に挙げられている手続きを遂行する
◎
Otherwise, operation was defined with an identifier. Perform the steps listed in the description of operation with P and value as the two argument values.
</li>
</ol>

			</section>
			<section id="platformobjectset">
<h4 title="Platform object [[Set]] method">3.8.6. ~platform~obj `Set^es ~meth</h4>

<p>
［
`有index~propを~supportする$, または`有名~propを~supportする$
］`~ifc$を実装する どの`~platform~obj$ %O に対しても，その `Set^es 内部~methは、
( ~prop名 %P, 値 %V, ~JS言語~値 %Receiver )
を引数に~callされたときには，次に従って挙動し~MUST：
◎
The internal [[Set]] method of every platform object O that implements an interface which supports indexed or named properties must behave as follows when called with property name P, value V, and ECMAScript language value Receiver:
</p>

<ol class="algorithm">
	<li>
<p>
~IF
%O ~EQ %Receiver
⇒
◎
If O and Receiver are the same object, then:
</p>

		<ol>
			<li>
<p>
~IF［
%O は `有index~propを~supportする$
］~AND［
%P は`配列~index~prop名$である
］~AND［
%O が実装するある~ifcに，`有index~prop設定子$が伴われている
］
⇒
◎
If O supports indexed properties, P is an array index property name, and O implements an interface with an indexed property setter, then:
</p>

				<ol>
					<li>
( %P, %V )
を~~渡して
`有index~prop設定子を呼出す$
◎
Invoke the indexed property setter with P and V.
</li>
					<li>
~RET `true^v
◎
Return true.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%O は `有名~propを~supportする$
］~AND［
`Type^( %P ) ~EQ `String^t
］~AND［
%P は`配列~index~prop名$である
］~AND［
%O が実装するある~ifcに，`有名~prop設定子$が伴われている
］
⇒
◎
If O supports named properties, Type(P) is String, P is not an array index property name, and O implements an interface with a named property setter, then:
</p>

				<ol>
					<li>
( %P, %V )
を~~渡して
`有名~prop設定子を呼出す$
◎
Invoke the named property setter with P and V.
</li>
					<li>
~RET `true^v
◎
Return true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%ownDesc :=
( %O, %P, `true^v )
を引数に，抽象演算 `~PlatformObjectGetOwnProperty$ を呼出した結果
◎
Let ownDesc be the result of invoking the PlatformObjectGetOwnProperty abstract operation with O, P, and true as arguments.
</li>
	<li>
<a href="~TC39#sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver">既定の `Set^es 内部~meth</a>
の手続きにおける［
段 3〜11
］を遂行する
◎
Perform steps 3-11 of the default [[Set]] internal method.
</li>
</ol>

			</section>


			<section id="platformobjectsetprototypeof">
<h4 title="Platform object [[SetPrototypeOf]] method">3.8.7. ~platform~obj `SetPrototypeOf^es ~meth</h4>

<p>
［
`Global$x ／ `PrimaryGlobal$x
］`拡張属性$を伴う`~ifc$を実装する どの`~platform~obj$に対しても，その内部 `SetPrototypeOf^es ~methは、［
`変異不可の原型~exotic~obj$の `SetPrototypeOf^es 内部~meth
］に定義されるものと同じ~algoを実行し~MUST。
◎
The internal [[SetPrototypeOf]] method of every platform object that implements an interface with the [Global] or [PrimaryGlobal] extended attribute must execute the same algorithm as is defined for the [[SetPrototypeOf]] internal method of an immutable prototype exotic object.
</p>

<p class="note">注記：
<a href="~BROWSERS#window">`Window^T</a>
~objに対しては、これが実装されているかどうかは観測し得ない
—
<a href="~HTMLwindowproxy#windowproxy">`WindowProxy^T</a>
~objの存在tにより、 `Window^T ~obj上では， `SetPrototypeOf^es は決して直接的に~callされないことが確保されるので。
しかしながら，他の~大域~objに対しては、このことは必要とされない。
◎
Note: For Window objects, it is unobservable whether this is implemented, since the presence of the WindowProxy object ensures that [[SetPrototypeOf]] is never called on a Window object directly. For other global objects, however, this is necessary.
</p>
			</section>
			<section id="defineownproperty">
<h4 title="Platform object [[DefineOwnProperty]] method">3.8.8. ~platform~obj `DefineOwnProperty^es ~meth</h4>

<p>
［［
`有index~propを~supportする$, または`有名~propを~supportする$
］`~ifc$を実装する`~platform~obj$ %O
］の `DefineOwnProperty^es 内部~methは，［
~prop~key %P, `~pdesc$ %Desc
］を伴って~callされたときは、次の手続きに従わ~MUST：
◎
When the internal [[DefineOwnProperty]] method of a platform object O that implements an interface which supports indexed or named properties is called with property key P and Property Descriptor Desc, the following steps must be taken:
</p>


<ol class="algorithm">
	<li>
<p>
~IF［
%O は `有index~propを~supportする$
］~AND［
%P は`配列~index~prop名$である
］
⇒
◎
If O supports indexed properties and P is an array index property name, then:
</p>
		<ol>
			<li id="cp-ret-false-ifnot-IsDataDescriptor">
~IF
`IsDataDescriptor$A( %Desc ) を~callした結果 ~EQ `false^v
~THEN
~RET `false^v
◎
If the result of calling IsDataDescriptor(Desc) is false, then return false.
</li>
			<li>
~IF
%O が実装する どの~ifcにも，`有index~prop設定子$は伴われていない
~THEN
~RET `false^v
◎
If O does not implement an interface with an indexed property setter, then return false.
</li>
			<li>
( %P, %Desc.`Value^es )
を~~渡して
`有index~prop設定子を呼出す$
◎
Invoke the indexed property setter with P and Desc.[[Value]].
</li>
			<li>
~RET `true^v
◎
Return true.
</li>
		</ol>
	</li>
	<li>
<p><!-- copy* -->
~IF［
%O は `有名~propを~supportする$
］~AND［
%O は
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴う`~ifc$を実装しない
］~AND［
%P は %O の `Unforgeable$x ~prop名でない
］
⇒
◎
If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute and P is not an unforgeable property name of O, then:
</p>
		<ol>
			<!--cp-let-creating-->
			<li>
<p>
<!--Otherwise, if-->
~IF［
%O が実装するある~ifcに， `OverrideBuiltins$x `拡張属性$が伴われている
］~OR［
%O は 名前 %P の自前の~propを持たない
］
⇒
◎
If O implements an interface with the [OverrideBuiltins] extended attribute or O does not have an own property named P, then:
</p>
				<ol>
					<li>
~IF［
%creating ~EQ ~false
］~AND［
%O が実装する どの~ifcにも，`有名~prop設定子$は伴われていない
］
~THEN
~RET `false^v
◎
If creating is false and O does not implement an interface with a named property setter, then return false.
</li>
					<li>
<p>
~IF
%O が実装する ある~ifcに，`有名~prop設定子$が伴われている
⇒
◎
If O implements an interface with a named property setter, then:
</p>
						<ol>
							<!--cp-ret-false-ifnot-IsDataDescriptor-->
							<li>
( %P, %Desc.`Value^es )
を~~渡して
`有名~prop設定子を呼出す$
◎
Invoke the named property setter with P and Desc.[[Value]].
</li>
							<li>
~RET `true^v
◎
Return true.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF
%O は
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴う`~ifc$を実装していない
~THEN
%Desc.`Configurable^es ← `true^v
◎
If O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute, then set Desc.[[Configurable]] to true.
</li>
	<li>
~RET `OrdinaryDefineOwnProperty$A( %O, %P, %Desc )
◎
Return OrdinaryDefineOwnProperty(O, P, Desc).
</li>
</ol>


			</section>
			<section id="delete">
<h4 title="Platform object [[Delete]] method">3.8.9. ~platform~obj `Delete^es ~meth</h4>


<p>
［
`有index~propを~supportする$, または`有名~propを~supportする$
］`~ifc$を実装する
どの`~platform~obj$ %O においても，その `Delete^es 内部~methは、~prop名 %P を伴って~callされたときには，次に従って挙動し~MUST。
◎
The internal [[Delete]] method of every platform object O that implements an interface which supports indexed or named properties must behave as follows when called with property name P.
</p>



<ol class="algorithm">
	<li>
<!--cp-if-support-and-index-->
		<ol>
			<!--cp-ToUint32-2-->
			<li>
~IF
%index は `被support~prop~index$でない
~THEN
~RET `true^v
◎
If index is not a supported property index, then return true.
</li>
			<li>
~RET `false^v
◎
Return false.
</li>
		</ol>
	</li>
	<li>
<p><!-- copy* -->
~IF［
%O は `有名~propを~supportする$
］~AND［
%O は
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴う`~ifc$を実装しない
］~AND［
( ~prop名 %P, ~obj %O )
を~~入力に，`有名~propの可視性判定~algo$を~callした結果 ~EQ ~true
］
⇒
◎
If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute and the result of calling the named property visibility algorithm with property name P and object O is true, then:
</p>
		<ol>
			<li>
~IF
%O が実装する どの~ifcにも，`有名~prop削除子$は伴われていない
~THEN
~RET `false^v
◎
If O does not implement an interface with a named property deleter, then return false.
</li>
			<li>
%operation := `有名~prop削除子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property deleter.
</li>
			<li>
<!--cp-ifdef-no-id-->
				<ol>
					<li>
名前 %P に対し，既存の有名~propを削除するために、~ifcの記述に挙げられている
`既存の有名~propを削除する$
手続きを遂行する
◎
Perform the steps listed in the interface description to delete an existing named property with P as the name.
</li>
					<li>
~IF
手続きから削除の失敗-が指示された
~THEN
~RET `false^v
◎
If the steps indicated that the deletion failed, then return false.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
⇒
◎
Otherwise, operation was defined with an identifier:
</p>
				<ol>
					<li>
( %P )
を引数に，
%operation の記述に挙げられている手続きを遂行する
◎
Perform the steps listed in the description of operation with P as the only argument value.
</li>
					<li>
~IF［
%operation は `返値型$ `boolean$T を伴って宣言されている
］~AND［
その手続きから `false^V が返された
］
~THEN
~RET `false^v
◎
If operation was declared with a return type of boolean and the steps returned false, then return false.
</li>
				</ol>
			</li>
			<li id="cp-return-true">
~RET `true^v
◎
Return true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF
%O は 名前 %P の自前の~propを持つ
⇒
◎
If O has an own property with name P, then:
</p>
		<ol>
			<li>
~IF
その~propは~configurableでない
~THEN
~RET `false^v
◎
If the property is not configurable, then return false.
</li>
			<li>
~ELSE
~THEN
その~propを %O から除去する
◎
Otherwise, remove the property from O.
</li>
		</ol>
	</li>
	<!--cp-return-true-->
</ol>
			</section>
			<section id="call">
<h4 title="Platform object [[Call]] method">3.8.10. ~platform~obj `Call^es ~meth</h4>


<p>
少なくとも１つの`旧来呼出子$を伴う`~ifc$ %I を実装する，どの`~platform~obj$においても，その `Call^es 内部~methは、
%arg<sub>0..%n−1</sub> を `Call^es に渡される引数~値の~listとするとき，次に従って挙動し~MUST。
◎
The internal [[Call]] method of every platform object that implements an interface I with at least one legacy caller must behave as follows, assuming arg0..n−1 is the list of argument values passed to [[Call]]:
</p>

<ol class="algorithm">
	<li>
%S :← %I 上の旧来呼出子のうち［
引数個数 %n
］から得られる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for legacy callers on I and with argument count n.
</li>
	<!--cp-let-resolution-->
	<li>
( %values )
を引数に，旧来呼出子 %operation の記述に挙げられている手続きを遂行する
◎
Perform the actions listed in the description of the legacy caller operation with values as the argument values.
</li>
	<li>
~RET ［
その %operation の返値として宣言されている型が
`void$T ならば `undefined^v ／
~ELSE_ 前段の返値を~JS値に`toES^した結果
］
◎
Return the result of converting the return value from those actions to an ECMAScript value of the type operation is declared to return (or undefined if operation is declared to return void).
</li>
</ol>
			</section>
			<section id="preventextensions">
<h4 title="Platform object [[PreventExtensions]] method">3.8.11. ~platform ~obj `PreventExtensions^es ~meth</h4>

<p>
`~platform~obj$ %O の `PreventExtensions^es 内部~methが~callされたときは、次の手続きを行う：
◎
When the [[PreventExtensions]] internal method of a platform object O is called, the following steps are taken:
</p>

<ol class="algorithm">
	<li>
~IF［
%O は`有index~propを~supportする$
］~OR［
%O は`有名~propを~supportする$
］
~THEN
~RET `false^v
◎
If O supports indexed properties or O supports named properties, return false.
</li>
	<li>
~RET
`OrdinaryPreventExtensions$A( %O )
◎
Return OrdinaryPreventExtensions(O).
</li>
</ol>

<p class="note">注記:
これにより、［
`有index~propを~supportする$ ／ `有名~propを~supportする$
］`~platform~obj$は 拡張-可能に保たれる
— それらに対する `PreventExtensions^es を失敗させることにより。
◎
Note: this keeps platform objects which support indexed or named properties extensible by making [[PreventExtensions]] fail for them.
</p>
			</section>
			<section id="property-enumeration">
<h4 title="Property enumeration">3.8.12. ~prop列挙</h4>


<p>
この文書は、
`~ifc$を実装しているすべての`~platform~obj$に対する（または
<a href="#es-exception-objects">例外を表現する~platform~obj</a>
に対する）
完全な~prop列挙~順序は定義しない。
しかしながら，~platform~objが［
`有index~propを~supportする$, または`有名~propを~supportする$
］~ifcを実装する場合、その~obj上の~propは次の順序により列挙され~MUST：
◎
This document does not define a complete property enumeration order for all platform objects implementing interfaces (or for platform objects representing exceptions). However, if a platform object implements an interface that supports indexed or named properties, then properties on the object must be enumerated in the following order:
</p>

<ol>
	<li>
最初に，~objが`有index~propを~supportする$場合、その~objの`被support~prop~index$が数的~順序で列挙される。
◎
If the object supports indexed properties, then the object’s supported property indices are enumerated first, in numerical order.
</li>
	<li>
次に，~objが［
`有名~propを~supportする$, かつ
`LegacyUnenumerableNamedProperties$x `拡張属性$を伴う~ifcは実装しない
］場合、その~objの被support~prop名のうち，［
`有名~propの可視性判定~algo$に従って可視であるもの
］が、`被support~prop名$の集合に（仕様により）定義された順序で列挙される。
◎
If the object supports named properties and doesn’t implement an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then the object’s supported property names that are visible according to the named property visibility algorithm are enumerated next, in the order given in the definition of the set of supported property names.
</li>
	<li>
最後に、自前の~prop, および~objの原型鎖からの~propのうち，列挙可能なものが未定義の順序で列挙される。
◎
Finally, any enumerable own properties or properties from the object’s prototype chain are then enumerated, in no defined order.
</li>
</ol>

<p class="note">注記：
~JS仕様の将来~versionでは~prop列挙のための全順序が定義され得る。
◎
Note: Future versions of the ECMAScript specification may define a total order for property enumeration.
</p>

			</section>
		</section>
		<section id="es-user-objects">
<h3 title="User objects implementing callback interfaces">3.9. 呼戻~ifcを実装する利用者~obj</h3>


<p>
上の
`idl-objects$sec
に述べたように、
`呼戻~ifc$は，~scriptの中で~JS~objにより実装され得る。
次の場合分けにより、所与の~objが［
呼戻~ifcを実装している利用者~obj
］と見なされるかどうかが決定される。
◎
As described in §2.10 Objects implementing interfaces, callback interfaces can be implemented in script by an ECMAScript object. The following cases determine whether and how a given object is considered to be a user object implementing a callback interface:
</p>

<ul>
	<li>
<p>
~ifcが（下で定義される）`単一~演算~呼戻~ifc$である場合、どの~objも，その~ifcを実装するものと見なされる。
その演算（または多重定義されている演算の集合）の実装は、次で与えられる：
◎
If the interface is a single operation callback interface (defined below) then any object is considered to implement the interface. The implementation of the operation (or set of overloaded operations) is as follows:
</p>
		<ul>
			<li>
~objが`~callable$である場合、その演算（または多重定義されている演算の集合）の実装はその~callable~obj自身になる。
◎
If the object is callable, then the implementation of the operation (or set of overloaded operations) is the callable object itself.
</li>
			<li>
他の場合（すなわち~objは`~callable$でない）、その演算（または多重定義されている演算の集合）の実装は、その演算の`識別子$を~prop名
<span class="trans-note">【†1】</span>
として，その~obj上の `Get^es 内部~methを呼出した結果になる。<!--  -->
◎
Otherwise, the object is not callable. The implementation of the operation (or set of overloaded operations) is the result of invoking the internal [[Get]] method on the object with a property name that is the identifier of the operation.
</li>
		</ul>
	</li>
	<li>
<!-- `~platform~obj$でなく, かつ -->
他の場合（~ifcは`単一~演算~呼戻~ifc$でない）、どの~objも，その~ifcを実装するものと見なされる。
所与の`識別子$を伴って~ifc上に宣言される各~演算に対し、その実装は，その識別子を~prop名として，その~obj上の `Get^es を呼出した結果になる。
◎
Otherwise, the interface is not a single operation callback interface. Any object is considered to implement the interface. For each operation declared on the interface with a given identifier, the implementation is the result of invoking [[Get]] on the object with a property name that is that identifier.
</li>
</ul>

<p>
`~ifc$上に`定数$が宣言されているとしても、~JS~objが，その~ifcを実装している`利用者~obj$と見なされるために，それらの定数に対応する~propを持つ必要はないことに注意。
◎
Note that ECMAScript objects need not have properties corresponding to constants on them to be considered as user objects implementing interfaces that happen to have constants declared on them.
</p>

<p>
`単一~演算~呼戻~ifc@
とは、次のすべてを満たす`呼戻~ifc$である：
◎
A single operation callback interface is a callback interface that:
</p>
<ul>
	<li>
別の~ifcを`継承-$するように宣言されていない,
◎
is not declared to inherit from another interface,
</li>
	<li>
`属性$を持たない,
◎
has no attributes, and
</li>
	<li>
すべてが同じ`識別子$を持つ１個~以上の`正則~演算$があり，他のものはない。
◎
has one or more regular operations that all have the same identifier, and no others.
</li>
</ul>

<p class="trans-note">【
例えば DOM の 
<a href="https://dom.spec.whatwg.org/#eventlistener">`EventListener^T</a>
~ifc。
その唯一の~mbの識別子 `handleEvent^c が上述の~prop名（ †1 ）にあたる。
】</p>

<p class="trans-note">【
共通の記述を集約するため、この訳では，以下に定義される各種 手続きの中から一部分を抽出して，次の二つの手続き
“PrepareSettings”,
“GetCompletion”
に~~分離する（ 手続きの名前は、当たり障りないように選んだだけで特に意味はない）：
】</p>

<p>
`PrepareSettings@( %realm, %value )
は、次を遂行する：
</p>

<ol class="algorithm">
	<li>
`関連する設定群^var := %realm の`設定群~obj$
◎
Let relevant settings be realm’s settings object.
</li>
	<li>
`格納済み設定群^var := %value の`呼戻~文脈$
◎
Let stored settings be value’s callback context.
</li>
	<li>
`関連する設定群^var で`~scriptを走らすために準備する$
◎
Prepare to run script with relevant settings.
</li>
	<li>
`格納済み設定群^var で`呼戻子を走らすために準備する$
◎
Prepare to run a callback with stored settings.
</li>
	<li>
~RET ( `関連する設定群^var, `格納済み設定群^var )
</li>
</ol>


<p>
`GetCompletion@( `関連する設定群^var, `格納済み設定群^var, %completion, %T )
は、次を遂行する：
</p>

<ol class="algorithm">
	<li>
`格納済み設定群^var で，`走らせた呼戻子を片付ける$
◎
Clean up after running a callback with stored settings.
</li>
	<li>
`関連する設定群^var で，`走らせた~scriptを片付ける$
◎
Clean up after running script with relevant settings.
</li>
	<li>
~IF
%completion は正常完了である
~THEN
~RET %completion
◎
If completion is a normal completion, return completion.
</li>
	<li>
~IF［
%completion は中途完了である
］~AND［
%T は`~promise型$でない
］
~THEN
~RET %completion
◎
If completion is an abrupt completion and T is not a promise type, return completion.
</li>
	<li>
<p>
%rejectedPromise := 次を与える下で［
`Promise$esI.reject の初期~値
］を~callした結果：
</p>
<ul ><li>`this^v 値： `Promise$esI
</li><li>引数~list： ( %completion.`Value^es )
</li></ul>
◎
Let rejectedPromise be the result of calling reject with %Promise% as the this value and completion.[[Value]] as the single argument value.
</li>
	<li>
~RET %rejectedPromise を %T 型~値に`toIDL^した結果
◎
Return the result of converting rejectedPromise to T.
</li>
</ol>



<div class="p">
<p>
`利用者~objの演算を~callする@
ときは、所与の：
</p>

<ul ><li>`~ifc型$の値： %value
</li><li>演算~名： %opName（ sometimes-随意）
<span class="trans-note">【
“optional” に “sometimes-” が加わると何が変わるのか？
】</span>
</li><li>引数~値の~list： %arg<sub>0..%n−1</sub>（各~引数は［
~IDL値, または`MISSING^ （供されなかった随意~引数を表現する）
］をとる）
</li><li>`呼戻 this 値@： %thisArg （随意）
</li></ul>

<p>
に対し、次の~手続きを遂行する。
この手続きは、~IDL値を返すか，例外を投出する。
</p>

◎
To call a user object’s operation, given a callback interface type value value, sometimes-optional operation name opName, list of argument values arg0..n−1 each of which is either an IDL value or the special value “missing” (representing a missing optional argument), and optional callback this value thisArg, perform the following steps. These steps will either return an IDL value or throw an exception.
</div>


<ol class="algorithm">
	<li id="cp-let-completion">
%completion :← 未初期化の変数
◎
Let completion be an uninitialized variable.
</li>
	<li id="cp-let-default-thisArg">
~IF
%thisArg は与えられていない
~THEN
%thisArg := `undefined^v
◎
If thisArg was not given, let thisArg be undefined.
</li>
	<li>
%O := %value に対応している~JS~obj
◎
Let O be the ECMAScript object corresponding to value.
</li>
	<li id="cp-let-realm-Realm">
%realm := %O が`属する~Realm$
◎
Let realm be O’s associated Realm.
</li>
	<li>
( `関連する設定群^var, `格納済み設定群^var ) := `PrepareSettings$( %realm, %value )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be value’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<li>
%T := 当の演算の返値型
◎
↓</li>
	<li>
<p>
当の演算の実装 %X を決定する：
◎
Determine the implementation of the operation, X:
</p>
		<ol>
			<li>
~IF［
%value の~ifcは、`単一~演算~呼戻~ifc$である
］~AND［
! `IsCallable$A( %O ) ~EQ ~true
］
~THEN
%X ← %O
◎
If value’s interface is a single operation callback interface and ! IsCallable(O) is true, then set X to O.
</li>
			<li>
<p>
~ELSE — %opName が供されてい~MUST：
◎
Otherwise, opName must be supplied:
</p>
				<ol>
					<li>
%getResult := `Get$A( %O, %opName )
◎
Let getResult be Get(O, opName).
</li>
					<li id="cp-set-getResult">
~IF
%getResult は中途完了である：
~THEN
~RET `GetCompletion$( `関連する設定群^var, `格納済み設定群^var, %getResult, %T )
◎
If getResult is an abrupt completion, set completion to getResult and jump to the step labeled return.
</li>
					<li>
%X ← %getResult.`Value^es
◎
Set X to getResult.[[Value]].
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF
! `IsCallable$A( %X ) ~EQ `false^v ：
</p>

<ol ><li>%completion ← 新たな `Completion${
`Type^es: throw,
`Value^es: 新たな `TypeError^t ~obj,
`Target^es: 空
}
</li><li>~RET `GetCompletion$( `関連する設定群^var, `格納済み設定群^var, %completion, %T )
</li></ol>

◎
If ! IsCallable(X) is false, then set completion to a new Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}, and jump to the step labeled return.
</li>
	<li>
~IF［
%value の~ifcは`単一~演算~呼戻~ifc$でない
］~OR［
! `IsCallable$A( %O ) ~EQ `false^v
］
~THEN
%thisArg ← %O
（提供された値を上書きする）
◎
If value’s interface is not a single operation callback interface, or if ! IsCallable(O) is false, set thisArg to O (overriding the provided value).
</li>
	<li id="cp-let-esArgs-empty">
%esArgs := 空の~JS List 値
◎
Let esArgs be an empty List of ECMAScript values.
</li>
	<li>
%i :← 0
◎
Let i be 0.
</li>
	<li>
%count :← 0
◎
Let count be 0.
</li>
	<li>
<!--cp-while-i-n-->
		<ol>
			<li id="cp-append-undef-to-esArgs">
~IF
%arg<sub>%i</sub> ~EQ `MISSING^
~THEN
`undefined^v を %esArgs に付加する
◎
If argi is the special value “missing”, then append undefined to esArgs.
</li>
			<li>
<p id="cp-else-argi-is-IDL-val">
~ELSE（ %arg<sub>%i</sub> は~IDL値である）：
◎
Otherwise, argi is an IDL value:
</p>
				<ol>
					<li id="cp-let-convertResult">
%convertResult :=
%arg<sub>%i</sub> を~JS値に`toES^した結果
◎
Let convertResult be the result of converting argi to an ECMAScript value.
</li>
					<li id="cp-convertResult-is-abrupt">
~IF
%convertResult は中途完了である
~THEN
~RET `GetCompletion$( `関連する設定群^var, `格納済み設定群^var, %convertResult, %T )
◎
If convertResult is an abrupt completion, set completion to convertResult and jump to the step labeled return.
</li>
					<li id="cp-add-convertResult-esArgs">
%convertResult.`Value^es を %esArgs に付加する
◎
Append convertResult.[[Value]] to esArgs.
</li>
					<li id="cp-count-incby1">
%count ← %i + 1
◎
Set count to i + 1.
</li>
				</ol>
			</li>
			<li>
%i ← %i + 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
	<li id="cp-truncate-esArgs">
%esArgs を長さ %count 個に切り詰める
◎
Truncate esArgs to have length count.
</li>
	<li>
%callResult := `Call$A( %X, %thisArg, %esArgs )
◎
Let callResult be Call(X, thisArg, esArgs).
</li>
	<li id="cp-callResult-is-abrupt">
~IF
%callResult は中途完了である
~THEN
~RET `GetCompletion$( `関連する設定群^var, `格納済み設定群^var, %callResult, %T )
◎
If callResult is an abrupt completion, set completion to callResult and jump to the step labeled return.
</li>
	<li id="cp-set-completion-callResult">
%completion ←
%callResult.`Value^es を %T 型~値に`toIDL^した結果
◎
Set completion to the result of converting callResult.[[Value]] to an IDL value of the same type as the operation’s return type.
</li>
	<li id="call-user-object-operation-return">
<p>
~RET `GetCompletion$( `関連する設定群^var, `格納済み設定群^var, %completion, %T )
</p>
◎
Return: at this point completion will be set to an ECMAScript completion value.
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• If completion is a normal completion, return completion.
• If completion is an abrupt completion and the operation has a return type that is not a promise type, return completion.
• Let reject be the initial value of %Promise%.reject.
• Let rejectedPromise be the result of calling reject with %Promise% as the this value and completion.[[Value]] as the single argument value.
• Return the result of converting rejectedPromise to the operation’s return type.
</li>
</ol>

<div class="p">
<p>
`利用者~objの属性~値を取得する@
ときは、所与の：
</p>

<ul ><li>`~ifc型$の値： %object
</li><li>属性~名： %attributeName
</li></ul>

<p>
に対し，次の手続きを遂行する。
この手続きは、~IDL値を返すか，例外を投出する。
</p>

◎
To get a user object’s attribute value, given a callback interface type value object and attribute name attributeName, perform the following steps. These steps will either return an IDL value or throw an exception.
</div>


<ol class="algorithm">
	<!--cp-let-completion-->
	<li id="cp-let-O-corresponding">
%O := %object に対応している~JS~obj
◎
Let O be the ECMAScript object corresponding to object.
</li>
	<!--cp-let-realm-Realm-->
	<li>
( `関連する設定群^var, `格納済み設定群^var ) := `PrepareSettings$( %realm, %object )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be object’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<li>
%getResult := `Get$A( %O, %attributeName )
◎
Let getResult be Get(O, attributeName).
</li>
	<!--cp-set-getResult-->
	<li>
%completion ←
%getResult.`Value^es を当の属性の型と同じ型の~IDL値に`toIDL^した結果
◎
Set completion to the result of converting getResult.[[Value]] to an IDL value of the same type as the attribute’s type.
</li>
	<li id="get-user-object-attribute-return">
~RET `GetCompletion$( `関連する設定群^var, `格納済み設定群^var, %completion, %T )
◎
Return: at this point completion will be set to an ECMAScript completion value.
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• If completion is a normal completion, return completion.
• If completion is an abrupt completion and the attribute’s type is not a promise type, return completion.
• Let reject be the initial value of %Promise%.reject.
• Let rejectedPromise be the result of calling reject with %Promise% as the this value and completion.[[Value]] as the single argument value.
• Return the result of converting rejectedPromise to the attribute’s type.
</li>
</ol>


<div class="p">
<p>
`利用者~objの属性~値を設定する@
ときは、所与の：
</p>

<ul ><li>`~ifc型$の値： %object
</li><li>属性~名： %attributeName
</li><li>~IDL値： %value
</li></ul>

<p>
に対し，次の手続きを遂行する。
この手続きは、何も返さないが，例外を投出し得る。
</p>

◎
To set a user object’s attribute value, given a callback interface type value object, attribute name attributeName, and IDL value value, perform the following steps. These steps will not return anything, but could throw an exception.
</div>

<ol class="algorithm">
	<!--cp-let-completion-->
	<!--cp-let-O-corresponding-->
	<!--cp-let-realm-Realm-->
	<li>
( `関連する設定群^var, `格納済み設定群^var ) := `PrepareSettings$( %realm, %object )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be object’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<li>
%convertResult := %value を~JS値に`toES^した結果
◎
Let convertResult be the result of converting value to an ECMAScript value.
</li>
	<!--cp-convertResult-is-abrupt-->
	<li>
%completion ←
`Set^( %O, %attributeName, %convertResult.`Value^es, `true^v )
◎
Set completion to Set(O, attributeName, convertResult.[[Value]], true).
</li>
	<li id="set-user-object-attribute-return">
<p>
`最終~段^i
（ この時点で %completion は~JS~completion値に設定される。
値 `true^v に対し `Set^ から返される結果は，中途完了か正常完了である。）
◎
Return: at this point completion will be set to an ECMAScript completion value, which is either an abrupt completion or a normal completion for the value true (as returned by Set).
</p>
		<ol>
			<li>
`格納済み設定群^var で，`走らせた~scriptを片付ける$
◎
Clean up after running a callback with stored settings.
</li>
			<li>
`関連する設定群^var で，`走らせた~scriptを片付ける$
◎
Clean up after running script with relevant settings.
</li>
			<li>
~IF
%completion は中途完了である
~THEN
~RET %completion
◎
If completion is an abrupt completion, return completion.
</li>
			<li>
~RET `NormalCompletion$A( `void$T )
◎
Return NormalCompletion(void).
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="es-invoking-callback-functions">
<h3 title="Invoking callback functions">3.10. 呼戻~関数の呼出し</h3>

<p>
`呼戻~関数$値として利用されている~JS`~callable$~objの~callのされ方は、前~節で述べた，`利用者~obj$上の`演算$の~callと同様である。
◎
An ECMAScript callable object that is being used as a callback function value is called in a manner similar to how operations on user objects are called (as described in the previous section).
</p>


<div class="p">
<p>
`呼戻~関数を呼出す@
ときは、所与の：
</p>

<ul ><li>`呼戻~関数~型$の値： %callable
</li><li>引数~list： %arg<sub>0..%n−1</sub> （各~引数は［
~IDL値, または `MISSING^ （供されなかった随意~引数を表現する）
］をとる）
</li><li>`呼戻 this 値$： %thisArg
</li></ul>

<p>
に対し，次の手続きを遂行する。
この手続きは、~IDL値を返すか，例外を投出する。
</p>

◎
To invoke a callback function type value callable with a list of arguments arg0..n−1, each of which is either an IDL value or the special value “missing” (representing a missing optional argument), and with optional callback this value thisArg, perform the following steps. These steps will either return an IDL value or throw an exception.
</div>


<ol class="algorithm">
	<!--cp-let-completion-->
	<!--cp-let-default-thisArg-->
	<li>
%F := %callable に対応している~JS~obj
◎
Let F be the ECMAScript object corresponding to callable.
	<li>
%T := 当の呼戻~関数の返値型
◎
↓</li>
	<li>
<p>
~IF
! `IsCallable$A( %F ) ~EQ `false^v
：
◎
If ! IsCallable(F) is false:
</p>
		<ol>
			<li>
<p>
~IF
%T ~EQ `void$T
~THEN
~RET
◎
If the callback function’s return type is void, return.
</p>

<p class="note">注記：
これが生じるのは、
`TreatNonObjectAsNull$x が付与された属性による呼戻~関数に限られる。
◎
Note: This is only possible when the callback function came from an attribute marked with [TreatNonObjectAsNull].
</p>
			</li>
			<li>
~RET `undefined^v を %T 型~値に`toIDL^した結果
◎
Return the result of converting undefined to the callback function’s return type.
</li>
		</ol>
	</li>
	<li>
%realm := %F が`属する~Realm$
◎
Let realm be F’s associated Realm.
</li>
	<li>
( `関連する設定群^var, `格納済み設定群^var ) := `PrepareSettings$( %realm, %callable )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be callable’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<!--cp-let-esArgs-empty-->
	<li>
%i :← 0
◎
Let i be 0.
</li>
	<li>
%count :← 0
◎
Let count be 0.
</li>
	<li>
<!--cp-while-i-n-->
		<ol>
			<!--cp-append-undef-to-esArgs-->
			<li>
<!--cp-else-argi-is-IDL-val-->
				<ol>
					<!--cp-let-convertResult-->
					<!--cp-convertResult-is-abrupt-->
					<!--cp-add-convertResult-esArgs-->
					<!--cp-count-incby1-->
				</ol>
			</li>
			<li>
%i ← %i + 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
	<!--cp-truncate-esArgs-->
	<li>
%callResult := `Call$A( %F, %thisArg, %esArgs )
◎
Let callResult be Call(F, thisArg, esArgs).
</li>
	<!--cp-callResult-is-abrupt-->
	<!--cp-set-completion-callResult-->
	<li id="invoke-return">
~RET `GetCompletion$( `関連する設定群^var, `格納済み設定群^var, %completion, %T )
◎
Return: at this point completion will be set to an ECMAScript completion value.
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• If completion is a normal completion, return completion.
• If completion is an abrupt completion and the callback function has a return type that is not a promise type, return completion.
• Let reject be the initial value of %Promise%.reject.
• Let rejectedPromise be the result of calling reject with %Promise% as the this value and completion.[[Value]] as the single argument value.
• Return the result of converting rejectedPromise to the callback function’s return type.
</li>
</ol>



		</section>
		<section id="es-namespaces" class="L2">
<h3 title="Namespaces">3.11. 名前空間</h3>

<div class="p">
<p>
所与の~JS大域~環境 %G にて`公開され$ている どの`名前空間$ %namespace に対しても、
%G の大域~obj上に，次の特徴を有するような 対応する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は %namespace の`識別子$
</li>
	<li>
値は
`名前空間~obj@
と呼ばれる~obj
— その特徴は、`namespace-object$secに述べる。
</li>
	<!--cp-has-attr-TFT-->
</ul>

◎
For every namespace that is exposed in a given ECMAScript global environment, a corresponding property must exist on the ECMAScript environment’s global object. The name of the property is the identifier of the namespace, and its value is an object called the namespace object.
◎
The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. The characteristics of a namespace object are described in §3.11.1 Namespace object.
</div>

			<section id="namespace-object">
<h4 title="Namespace object">3.11.1. 名前空間~obj</h4>

<p>
所与の
( `名前空間$ %namespace, `~Realm$ %realm )
に対する名前空間~objは、次に従って作成される：
◎
The namespace object for a given namespace namespace and Realm realm is created as follows:
</p>

<ol class="algorithm">
 	<li>
%namespaceObject :=
! `ObjectCreate$A( %realm の `ObjectPrototype$esI )
◎
Let namespaceObject be ! ObjectCreate(the %ObjectPrototype% of realm).
</li>
 	<li>
<p>
~FOR
%namespace の`名前空間~mb$であって`公開され$ている
~EACH ( `正則~演算$ %op ) に対し：
◎
For each exposed regular operation op that is a namespace member of this namespace,
</p>
		<ol>
			<li>
%F :=
( %op, %namespace, %realm ) から
`演算~関数を作成-$した結果
◎
Let F be the result of creating an operation function given op, namespace, and realm.
</li>
			<li>
! `CreateDataProperty$A( %namespaceObject, %op の`識別子$, %F )
を遂行する
◎
Perform ! CreateDataProperty(namespaceObject, op’s identifier, F).
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="es-exceptions">
<h3 title="Exceptions">3.12. 例外</h3>

<div class="p">
<p>
~JS大域~obj上には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `DOMException^l
</li>
	<li>
値は
`~DOMException構築子~obj@
と呼ばれる~obj（次節にて述べる）
</li>
	<!--cp-has-attr-TFT-->
</ul>

<p>
それは、旧来の~DOMException~code定数への~accessを提供し，
`DOMException$T の~instanceを構築できるようにする。
</p>

◎
There must exist a property on the ECMAScript global object whose name is “DOMException” and value is an object called the DOMException constructor object, which provides access to legacy DOMException code constants and allows construction of DOMException instances. The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</div>


			<section id="es-DOMException-constructor-object">
<h4 title="DOMException constructor object">3.12.1. ~DOMException構築子~obj</h4>

<p>
`~DOMException構築子~obj$は、
`Prototype^es 値 `Error$esI は伴わない，関数~objで~MUST。
◎
The DOMException constructor object must be a function object but with a [[Prototype]] value of %Error%.
</p>

<p>
</p>


<div class="p">
<p>
`~error名~一覧$に挙げられた どの旧来~codeに対しても，
`~DOMException構築子~obj$上に，次の特徴を有する~propが存在し~MUST：
</p>

<ul><li>名前は 一覧に指示されている名前
</li><li>値は 一覧に指示されている値
</li><li>属性 `FTF^desc を持つ
</li></ul>
◎
For every legacy code listed in the error names table, there must be a property on the DOMException constructor object whose name and value are as indicated in the table. The property has attributes { [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }.
</div>

<div class="p">
<p>
`~DOMException構築子~obj$は、次の特徴を有する~propを持た~MUST：
</p>

<ul>
	<!--cp-name-is-prototype-->
	<li>
値は
`~DOMException原型~obj@
と呼ばれる~obj（ `es-DOMException-prototype-object$secにて述べる）
</li>
	<!--cp-has-attr-FFF-->
</ul>

<p>
この~objは、その例外~上に宣言されている旧来~code値への~accessも提供する。
</p>

◎
The DOMException constructor object must also have a property named “prototype” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } whose value is an object called the DOMException prototype object. This object also provides access to the legacy code values.
</div>


				<section id="es-DOMException-call">
<h5 title="DOMException(message, name)">3.12.1.1. ~DOMException(%message, %name)</h5>

<p>
~DOMException関数が，引数 ( %message, %name ) を伴って，~callされたときは、次の手続きを行う：
◎
When the DOMException function is called with arguments message and name, the following steps are taken:
</p>

<ol class="algorithm">
	<li>
%F := 作動中の関数~obj
<span class="trans-note">【
<a href="~TC39#sec-execution-contexts">the active function object</a>
】</span>
◎
Let F be the active function object.
</li>
	<li>
%newTarget := ［
`NewTarget$ ~EQ `undefined^v ならば %F ／
~ELSE_ NewTarget
］
◎
If NewTarget is undefined, let newTarget be F, else let newTarget be NewTarget.
</li>
	<li>
%super := %F.`GetPrototypeOf^es()
◎
Let super be F.[[GetPrototypeOf]]().
</li>
	<li>
`ReturnIfAbrupt$A(%super)
◎
ReturnIfAbrupt(super).
</li>
	<li>
~IF
`IsConstructor$A(%super) ~EQ `false^v
~THEN
~THROW `TypeError^t
◎
If IsConstructor(super) is false, throw a TypeError exception.
</li>
	<li>
%O := `Construct$A(%super, «%message», %newTarget)
◎
Let O be Construct(super, «‍message», newTarget).
</li>
	<li>
<p>
~IF
%name ~NEQ `undefined^v
：
◎
If name is not undefined, then
</p>
		<ol>
			<li>
%name := `ToString$A(%name)
◎
Let name be ToString(name).
</li>
			<li>
%status := `DefinePropertyOrThrow$A(%O, `name^l, `TFT-name^desc )
◎
Let status be DefinePropertyOrThrow(O, "name", PropertyDescriptor{[[Value]]: name, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).
</li>
			<li>
`ReturnIfAbrupt$A(%status)
◎
ReturnIfAbrupt(status).
</li>
			<li>
%code := ［
~error名に対し`~error名~一覧$に旧来~codeが指示されていれば それ ／
~ELSE_ `0^v
］
◎
Let code be the legacy code indicated in the error names table for error name name, or 0 if there is none.
</li>
			<li>
%status := `DefinePropertyOrThrow$A(%O, `code^l, `TFT-code^desc)
◎
Let status be DefinePropertyOrThrow(O, "code", PropertyDescriptor{[[Value]]: code, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).
</li>
			<li>
`ReturnIfAbrupt$A(%status)
◎
ReturnIfAbrupt(status).
</li>
		</ol>
	</li>
	<li>
~RET %O
◎
Return O.
</li>
</ol>

				</section>
			</section>
			<section id="es-DOMException-prototype-object">
<h4 title="DOMException prototype object">3.12.2. ~DOMException原型~obj</h4>

<p>
`~DOMException原型~obj$は、
`ErrorPrototype$esI を値にとる `Prototype^es 内部~propを持た~MUST。
◎
The DOMException prototype object must have an internal [[Prototype]] property whose value is %ErrorPrototype%.
</p>

<p>
`~DOMException原型~obj$の`~class文字列$は、 `DOMExceptionPrototype^l で~MUST。
◎
The class string of the DOMException prototype object is “DOMExceptionPrototype”.
</p>

<div class="p">
<p>
`~DOMException原型~obj$上には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `constructor^l
</li>
	<li>
値は `~DOMException構築子~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>

◎
There must be a property named “constructor” on the DOMException prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the DOMException constructor object.
</div>

<div class="p">
<p>
`~error名~一覧$に挙げられた どの旧来~codeに対しても，
`~DOMException原型~obj$上に，次の特徴を有する~propが存在し~MUST：
</p>

<ul><li>名前は 一覧に指示されている名前
</li><li>値は 一覧に指示されている値
</li><li>属性 `FTF^desc を持つ
</li></ul>
◎
For every legacy code listed in the error names table, there must be a property on the DOMException prototype object whose name and value are as indicated in the table. The property has attributes { [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }.
</div>

			</section>
		</section>
		<section id="es-exception-objects">
<h3 title="Exception objects">3.13. 例外~obj</h3>

<p>
`単純例外$は、対応する型の~native ~JS~objにより表現される。
◎
Simple exceptions are represented by native ECMAScript objects of the corresponding type.
</p>

<p>
`~DOMException$は、`~DOMException原型~obj$を継承する`~platform~obj$により表現される。
◎
DOMExceptions are represented by platform objects that inherit from the DOMException prototype object.
</p>

<p>
<p>
~JS内で~DOMExceptionを表現している，どの~platform~objも、`初期~obj$と丁度~同じ様に大域環境に属する。
通常のように, あるいは `new^c 式の一部として，`~DOMException構築子~obj$の~callにより作成された例外~objが属する大域環境は、
`~DOMException構築子~obj$自身が属する大域環境と同じで~MUST。
◎
Every platform object representing a DOMException in ECMAScript is associated with a global environment, just as the initial objects are. When an exception object is created by calling the DOMException constructor object, either normally or as part of a new expression, then the global environment of the newly created object is associated with must be the same as for the DOMException constructor object itself.
</p>

<p>
その`~DOMException$~obj %O の `Prototype^es 内部~propの値は、 %O が属する大域環境に属する `~DOMException原型~obj$で~MUST。
◎
The value of the internal [[Prototype]] property of a DOMException object must be the DOMException prototype object from the global environment the exception object is associated with.
</p>

<p>
`~DOMException$~objの `~class文字列$は， `DOMException^l で~MUST。
◎
The class string of a DOMException object must be “DOMException”.
</p>

<p class="note">注記：
~DOMException~objの意図は、［
`Object.prototype.toString^c に渡されたときに応答が異なることと, 
`code^l ~propを持つこと
］を除いて，~JS仕様が定義する他の種々の~native `Error^t ~objと同様になることである。
~native `Error^t ~obj上に
— 例えば~stack~traceや~error行番号などを公開するような —
非標準の~propを与える実装は、それらを例外~obj上にも公開しなければならないことになる。
◎
Note: The intention is for DOMException objects to be just like the other various native Error objects that the ECMAScript specification defines, apart from responding differently to being passed to Object.prototype.toString and it having a “code” property. If an implementation places non-standard properties on native Error objects, exposing for example stack traces or error line numbers, then these ought to be exposed on exception objects too.
</p>

		</section>
		<section id="es-creating-throwing-exceptions">
<h3 title="Creating and throwing exceptions">3.14. 例外の作成と投出</h3>

<p>
最初に、
`現在の大域環境@
を，次の~algoを走らせた結果として定義する：
◎
First, we define the current global environment as the result of running the following algorithm:
</p>

<ol class="algorithm">
	<li>

<p>
%F := ~JS~call~stack上の最上層の~callの中で `this^v 値に利用されている `Function^t ~obj
— ここで， %F は次のいずれかの~IDL構成子に対応する：
</p>

<ul ><li>`属性$
</li><li>`演算$
</li><li>`有index~prop$
</li><li>`有名~prop$
</li><li>`Constructor$x
</li><li>`有名~構築子$
</li><li>`文字列化子$
</li></ul>

◎
Let F be the Function object used as the this value in the top-most call on the ECMAScript call stack where F corresponds to an IDL attribute, operation, indexed property, named property, constructor, named constructor or stringifier.
</li>
	<li>
<p>
~RET %F に対応する~IDL構成子に応じて，次で与えられる`~ifc$
<span class="trans-note">【を表現する`~platform~obj$】</span>
が属する大域環境
◎
↓</p>

		<dl class="switch">
			<dt>属性</dt>
			<dt>演算</dt>
			<dt>文字列化子</dt>
			<dd>
その定義が現れる~ifc
◎
If F corresponds to an attribute, operation or stringifier, then return the global environment associated with the interface that definition appears on.
</dd>

			<dt>有index~prop</dt>
			<dt>有名~prop</dt>
			<dd>
その~propの［
取得子／設定子／削除子
］が定義されている~ifc
◎
Otherwise, if F corresponds to an indexed or named property, then return the global environment associated with the interface that the indexed or named property getter, setter or deleter was defined on.
</dd>

			<dt>有名~構築子</dt>
			<dt>`~ifc~obj$である構築子</dt>
			<dd>
その構築子に対応する~ifc
◎
Otherwise, if F is a named constructor for an interface, or is an interface object for an interface that is a constructor, then return the global environment associated with that interface.
</dd>

			<dt>例外~field取得子†</dt>
			<dd>
その例外~fieldが定義されている例外
◎
Otherwise, F is an exception field getter. Return the global environment associated with the exception on which the exception field was defined.
</dd>
			<dd class="trans-note">【†
この項は不要であろう（仕様の更新に伴う削除漏れ — 例外~field取得子は，過去版に定義されていたが、その記述は現在~削除されている）。
】</dd>
		</dl>
	</li>
</ol>



<p>
［
名前 %N, ~UAにより定義される~message %M
］（ %M は随意）を伴う，`単純例外$／ `~DOMException$ %E
を`作成する$ときは、次の手続きに従わ~MUST：
◎
When a simple exception or DOMException E is to be created, with error name N and optional user agent-defined message M, the following steps must be followed:
</p>

<ol class="algorithm">

	<li>
%M := ［
%M が指定されていないならば `undefined^v ／
~ELSE_ %M を `String^t 値に`toES^した結果
］
◎
If M was not specified, let M be undefined. Otherwise, let it be the result of converting M to a String value.
</li>
	<li>
%N := %N を `String^t 値に`toES^した結果
◎
Let N be the result of converting N to a String value.
</li>
	<li>
<p>
%args := %E の型に応じて，次で与えられる~JS値の~list：
◎
Let args be a list of ECMAScript values.
</p>
		<dl class="switch">
			<dt>`~DOMException$◎E is DOMException</dt>
			<dd>
(`undefined^v, %N)
◎
args is (undefined, N).
</dd>

			<dt>`単純例外$◎E is a simple exception</dt>
			<dd>
(%M)
◎
args is (M)
</dd>

		</dl>

	<li>
%G := `現在の大域環境$
◎
Let G be the current global environment.
</li>
	<li>
<p>
%X := %E の型に応じて，次で与えられる~obj：
◎
Let X be an object determined based on the type of E:
</p>
		<dl class="switch">
			<dt>`~DOMException$◎E is DOMException</dt>
			<dd>
%G に属する， `~DOMException構築子~obj$
◎
X is the DOMException constructor object from the global environment G.
</dd>

			<dt>`単純例外$◎E is a simple exception</dt>
			<dd>
%G に属する，対応する~JS~errorのための構築子
◎

X is the constructor for the corresponding ECMAScript error from the global environment G.
</dd>

		</dl>
	</li>
	<li>
~RET %args を引数~listとして， %X を関数として~callした結果
◎
Let O be the result of calling X as a function with args as the argument list.
◎
Return O.
</li>
</ol>


<p>
［
`~error名$ %N, ~UAにより定義される~message %M
］（ %M は随意）を伴う，
~IDL `単純例外$／ `~DOMException$ %E を`投出する$ときは、次の手続きに従わ~MUST：
◎
When a simple exception or DOMException E is to be thrown, with error name N and optional user agent-defined message M, the following steps must be followed:
</p>

<ol class="algorithm">
	<li>
%O := ［
`~error名$ %N,
~message %M
］を伴う，指定された例外 %E を`作成-$した結果
◎
Let O be the result of creating the specified exception E with error name N and optional user agent-defined message M.
</li>
	<li>
%O を投出する
◎
Throw O.
</li>
</ol>

<div class="note">

<p>
上の~algoは、
<a href="#es-exception-objects">例外を表現する~platform~obj</a>
が， `Function^t %F から［
%F が出自にする大域環境
］の外へ伝播することを制約しない。
例えば、次の~IDLを考える：
◎
The above algorithms do not restrict platform objects representing exceptions propagating out of a Function to be ones that are associated with the global environment where that Function object originated. For example, consider the IDL:
</p>

<pre class="idl-code">
interface A {

  // <span class="comment"
	title="Calls computeSquareRoot on m, passing x as its argument."
>( %x ) を引数に %m 上の `computeSquareRoot^M を~call</span>
  double doComputation(MathUtils m, double x);
};

interface MathUtils {
  // <span class="comment"
	title="If x is negative, throws a NotSupportedError.  Otherwise, returns the square root of x."
>%x が負ならば `NotSupportedError^t を投出。
そうでなければ %x の平方根を返す。</span>
  double computeSquareRoot(double x);
};
</pre>

<p>
異なる大域環境に属する `MathUtils^T ~objを doComputation に渡した場合、投出される例外は，その大域環境に属する：
◎
If we pass a MathUtils object from a different global environment to doComputation, then the exception thrown will be from that global environment:
</p>

<pre class="es-code">
var a = getA();                      // <span class="comment"
	title="An A object from this global environment."
>この大域環境に属する~obj</span>
var m = otherWindow.getMathUtils();  // <span class="comment"
	title="A MathUtils object from a different global environment."
>異なる大域環境に属する `MathUtils^T ~obj</span>

a instanceof Object;                 // <!--cp-eval-true-->
m instanceof Object;                 // <!--cp-eval-false-->
m instanceof otherWindow.Object;     // <!--cp-eval-true-->

try {
  a.doComputation(m, -1);
} catch (e) {
  e instanceof DOMException;          // <!--cp-eval-false-->
  e instanceof otherWindow.DOMException;  // <!--cp-eval-true-->
}
</pre>
</div>

<p>
この文書が~JS組込みの `Error^t ~instanceの投出に課す，どの要件も、
`現在の大域環境$に属する組込みのものを利用し~MUST。
◎
Any requirements in this document to throw an instance of an ECMAScript built-in Error must use the built-in from the current global environment.
</p>
		</section>
		<section id="es-handling-exceptions">
<h3 title="Handling exceptions">3.15. 例外の取扱い</h3>


<p>
~JS言語束縛のどの~algoも, 処理~要件も、
~JS例外を~catchしない。
~JS `Function^t がこの節の要件により呼出され，その `Function^t が例外の投出により終了したときはいつでも、その例外は~call元まで（そこで~catchされない場合は更にその~call元まで，等々）伝播し~MUST。
◎
None of the algorithms or processing requirements in the ECMAScript language binding catch ECMAScript exceptions. Whenever an ECMAScript Function is invoked due to requirements in this section and that Function ends due to an exception being thrown, that exception must propagate to the caller, and if not caught there, to its caller, and so on.
</p>

<div class="example">
<p>
次の`~IDL片$は２つの`~ifc$と１つの`例外$を定義する。
`ExceptionThrower^T 上の `valueOf^M 属性は、その値の取得-が試みられたときに常に例外を投出するように定義されている。
◎
The following IDL fragment defines two interfaces and an exception. The valueOf attribute on ExceptionThrower is defined to throw an exception whenever an attempt is made to get its value.
</p>

<pre class="idl-code">
interface Dahut {
  attribute DOMString type;
};

interface ExceptionThrower {
  // <span class="comment"
	title="This attribute always throws a NotSupportedError and never returns a value."
>この属性は常に `NotSupportedError^t を投出し，決して値を返さない。</span>
  attribute long valueOf;
};
</pre>

<p>
~JS実装がこの~ifcを~supportしているとするとき、例外は次の~codeに従って取扱われる：
◎
Assuming an ECMAScript implementation supporting this interface, the following code demonstrates how exceptions are handled:
</p>

<pre class="es-code">
var d = getDahut();              // <span class="comment"
	title="Obtain an instance of Dahut."
>`Dahut^T の~instanceを得る。</span>
var et = getExceptionThrower();  // <span class="comment"
	title="Obtain an instance of ExceptionThrower."
>`ExceptionThrower^T の~instanceを得る。</span>

try {
  d.type = { toString: function() { throw "abc"; } };
} catch (e) {
  /* <span class="comment"
	title="The string &quot;abc&quot; is caught here, since as part of the conversion
from the native object to a string, the anonymous function
was invoked, and none of the [[DefaultValue]], ToPrimitive or
ToString algorithms are defined to catch the exception."
>文字列 `abc^l はここで~catchされる。
何故なら、~native~objから文字列への変換の一環として匿名~関数が呼出され，
`DefaultValue^es, ToPrimitive, ToString のいずれの~algoも，例外を~catchするように定義されていないので。</span> */
}

try {
  d.type = { toString: { } };
} catch (e) {
  /* <span class="comment"
	title="An exception is caught here, since an attempt is made to invoke
[[Call]] on the native object that is the value of toString property."
>例外はここで~catchされる。
toString ~propの値である~native~obj上で `Call^es の呼出しが試みられるので。</span> */
}

d.type = et;
  /* <span class="comment"
	title="An uncaught NotSupportedError DOMException is thrown here, since the
[[DefaultValue]] algorithm attempts to get the value of the
&quot;valueOf&quot; property on the ExceptionThrower object.
The exception propagates out of this block of code."
>~catchされなかった `NotSupportedError^t `~DOMException$は ここで投出される。
`DefaultValue^es ~algoは， `ExceptionThrower^T ~obj上の `valueOf^l ~propの値の取得-を試みるので。
例外はこの~code~blockの外へ伝播する。</span> */
</pre>
</div>
		</section>
	</section>
	<section id="common">
<h2 title="Common definitions">4. 共通の定義</h2>


<p>
この節では、すべての`適合~実装$が~supportし~MUST，いくつかの共通の定義を指定する。
◎
This section specifies some common definitions that all conforming implementations must support.
</p>

		<section id="common-ArrayBufferView">
<h3 title="ArrayBufferView">4.1. `ArrayBufferView^T</h3>

<pre class="idl">
typedef (Int8Array or Int16Array or Int32Array or
         Uint8Array or Uint16Array or Uint32Array or Uint8ClampedArray or
         Float32Array or Float64Array or DataView) `ArrayBufferView@;
</pre>

<p>
`ArrayBufferView^T ~typedefは、
`ArrayBuffer$T 上の~viewを提供する~objを表現するために利用される。
◎
The ArrayBufferView typedef is used to represent objects that provide a view on to an ArrayBuffer.
</p>


		</section>

		<section id="common-BufferSource">
<h3 title="BufferSource">4.2. `BufferSource^T</h3>

<pre class="idl">
typedef (ArrayBufferView or ArrayBuffer) `BufferSource@;
</pre>


<p>
`BufferSource^T ~typedefは、
`ArrayBuffer$T ~obj自身, または
`ArrayBuffer$T 上の~viewを提供する~objを表現するために利用される。
◎
The BufferSource typedef is used to represent objects that are either themselves an ArrayBuffer or which provide a view on to an ArrayBuffer. 
</p>


		</section>
		<section id="common-DOMTimeStamp">
<h3 title="DOMTimeStamp">4.3. `DOMTimeStamp^T</h3>


<pre class="idl">
typedef unsigned long long `DOMTimeStamp@;
</pre>

<p>
`DOMTimeStamp^T 型は、ミリ秒数を表現するために利用される。
（何らかの起点に相対的な）絶対的な時間として，または相対的な時間差として。
この型を利用する仕様は、ミリ秒数の解釈され方も定義する必要がある。
◎
The DOMTimeStamp type is used for representing a number of milliseconds, either as an absolute time (relative to some epoch) or as a relative amount of time. Specifications that use this type will need to define how the number of milliseconds is to be interpreted.
</p>
		</section>
		<section id="common-Function">
<h3 title="Function">4.4. `Function^T</h3>


<pre class="idl">
callback `Function@ = any (any... arguments);
</pre>

<p>
`Function^T `呼戻~関数$型は、渡される引数や返値の種類に制約のない関数~値を表現するために利用される。
◎
The Function callback function type is used for representing function values with no restriction on what arguments are passed to it or what kind of value is returned from it.
</p>
		</section>
		<section id="common-VoidFunction">
<h3 title="VoidFunction">4.5. `VoidFunction^T</h3>


<pre class="idl">
callback `VoidFunction@ = void ();
</pre>

<p>
`VoidFunction^T `呼戻~関数$型は
引数をとらず, 値を返さない関数~値を表現するために利用される。
◎
The VoidFunction callback function type is used for representing function values that take no arguments and do not return any value.
</p>
		</section>
	</section>
	<section id="extensibility">
<h2 title="Extensibility">5. 拡張性</h2>

~INFORMATIVE

<p>
言語束縛の要件に対する拡張は、この文書~内で定義される拡張属性と競合しない`拡張属性$を利用して指定できる。
［
私的な~project特有の利用
］のための拡張は、他の仕様に現れる`~IDL片$に含められるべきではない。
他の仕様の用途に要求される拡張は、この文書の将来~versionに取り込まれるためには，
<cite>Web IDL</cite> の担当グループ（この文書が書かれた時点では
<a href="http://www.w3.org/WebPlatform/WG/">W3C Web Platform Working Group</a>
）による~~調整を通すことが推奨される。
◎
Extensions to language binding requirements can be specified using extended attributes that do not conflict with those defined in this document. Extensions for private, project-specific use should not be included in IDL fragments appearing in other specifications. It is recommended that extensions that are required for use in other specifications be coordinated with the group responsible for work on Web IDL, which at the time of writing is the W3C Web Platform Working Group, for possible inclusion in a future version of this document.
</p>

<p>
~IDL言語の他の側面の拡張は極力~避けられるべきである。
◎
Extensions to any other aspect of the IDL language are strongly discouraged.
</p>
	</section>
	<section id="referencing">
<h2 title="Referencing this specification">6. この仕様を参照するとき</h2>

~INFORMATIVE

<p>
一つ以上の`~IDL片$を利用して~Web~platform~ifcを定義する他の仕様は、この仕様を参照することになるものと期待されている。
それらの仕様には、~IDLが この仕様の記述に従って解釈されることを指示する，次の様な~~文を含ませることを勧める：
◎
It is expected that other specifications that define Web platform interfaces using one or more IDL fragments will reference this specification. It is suggested that those specifications include a sentence such as the following, to indicate that the IDL is to be interpreted as described in this specification:
</p>

<blockquote>
この仕様における各~IDL片は、この仕様が規範とする参照文献にて定義される~IDL片とともに，［
“~Web~IDL” 仕様に述べられる， <em>`適合~IDL片の集合$</em> に課される要件
］に従って、解釈され~MUST。<!--  -->
<a class="placeholder">[WEBIDL]</a>
◎
The IDL fragment in Appendix A of this specification must, in conjunction with the IDL fragments defined in this specification’s normative references, be interpreted as required for conforming sets of IDL fragments, as described in the “Web IDL” specification. [WEBIDL]
</blockquote>

<p>
加えて、この仕様を参照する仕様における，~UAのための適合性クラスは、この仕様の
`適合~実装$クラスを参照することを勧める：
◎
In addition, it is suggested that the conformance class for user agents in referencing specifications be linked to the conforming implementation class from this specification:
</p>

<blockquote>
適合 FooML ~UAは、 “~Web~IDL” 仕様の記述に則り，この仕様に示されている各~IDL片に対しても <em>`適合~実装$</em> で~MUST。
<a class="placeholder">[WEBIDL]</a>
◎
A conforming FooML user agent must also be a conforming implementation of the IDL fragment in Appendix A of this specification, as described in the “Web IDL” specification. [WEBIDL]
</blockquote>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">7. 謝辞</h2>

~INFORMATIVE

<p>
編集者は、この仕様に~~寄与された，次の方々に感謝する：
</p>
<p>
The editor would like to thank the following people for contributing
to this specification:

Glenn Adams,
David Andersson,
L.&nbsp;David Baron,
Art Barstow,
Nils Barth,
Robin Berjon,
David Bruant,
Jan-Ivar Bruaroey,
Marcos Cáceres,
Giovanni Campagna,
Domenic Denicola,
Chris Dumez,
Michael Dyck,
Brendan Eich,
João Eiras,
Gorm Haug Eriksen,
Sigbjorn Finne,
David Flanagan,
Aryeh Gregor,
Dimitry Golubovsky,
James Graham,
Aryeh Gregor,
Kartikaya Gupta,
Marcin Hanclik,
Jed Hartman,
Stefan Haustein,
Dominique Hazaël-Massieux,
Ian Hickson,
Björn Höhrmann,
Kyle Huey,
Lachlan Hunt,
Oliver Hunt,
Jim Jewett,
Wolfgang Keller,
Anne van Kesteren,
Olav Junker Kjær,
Magnus Kristiansen,
Takeshi Kurosawa,
Yves Lafon,
Travis Leithead,
Jim Ley,
Kevin Lindsey,
Jens Lindström,
Peter Linss,
呂康豪 (Kang-Hao Lu),
Kyle Machulis,
Mark Miller,
Ms2ger,
Andrew Oakley,
岡坂&nbsp;史紀 (Shiki Okasaka),
Jason Orendorff,
Olli Pettay,
Simon Pieters,
Andrei Popescu,
François Remy,
Tim Renouf,
Alex Russell,
Takashi Sakamoto,
Doug Schepers,
Jonas Sicking,
Garrett Smith,
Geoffrey Sneddon,
Jungkee Song,
Josh Soref,
Maciej Stachowiak,
Anton Tayanovskyy,
Peter Van der Beken,
Jeff Walden,
Allen Wirfs-Brock,
Jeffrey Yasskin and
Collin Xu.
</p>

<p>
編集者が休みの間、この文書を維持されていた Sam Weinig に特別な謝意を。
◎
Special thanks also go to Sam Weinig for maintaining this document while the editor was unavailable to do so.
</p>
	</section>

	<section id="idl-grammar">
<h2 title="IDL grammar">~IDL文法</h2>

<p>
この節では、開始~記号 `Definitions$g が`~IDL片$全体に合致する，
LL(1) 文法を定義する。
◎
This section defines an LL(1) grammar whose start symbol, Definitions, matches an entire IDL fragment.
</p>

<div class="p">
<p>
文法~内の各~生成規則には、その右側に１個~以上の記号の並びが示される：
</p>

<ul ><li>ε は、何もなしを指示する。
</li><li>等幅~fontで示される記号は、~literalによる終端~記号である。
</li><li>大文字から始まり, 斜体で示される記号は、非~終端~記号である。
</li><li>小文字から始まり, 斜体で示される記号は、次に示す正規表現に合致する終端~記号である（Perl 5 `PERLRE$r の正規表現~構文を利用）。
</li></ul>

◎
Each production in the grammar has on its right hand side either a non-zero sequence of terminal and non-terminal symbols, or an epsilon (ε) which indicates no symbols. Symbols that begin with an uppercase letter are non-terminal symbols. Symbols in monospaced fonts are terminal symbols. Symbols in sans-serif font that begin with a lowercase letter are terminal symbols that are matched by the regular expressions (using Perl 5 regular expression syntax [PERLRE]) as follows:
</div>

<dl class="grammar" id="terminals">
<dt id="prod-integer">`integer^g</dt>
<dd>~SLASH<code>-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)</code>~SLASH</dd>

<dt id="prod-float">`float^g</dt>
<dd>~SLASH<code>-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)</code>~SLASH</dd>

<dt id="prod-identifier">`identifier^g</dt>
<dd>~SLASH<code>_?[A-Za-z][0-9A-Z_a-z-]*</code>~SLASH</dd>

<dt id="prod-string">`string^g</dt>
<dd>~SLASH<code>"[^"]*"</code>~SLASH</dd>

<dt id="prod-whitespace">`whitespace^g</dt>
<dd>~SLASH<code>[\t\n\r ]+</code>~SLASH</dd>

<dt id="prod-comment">`comment^g</dt>
<dd>~SLASH<code>\/\/.*|\/\*(.|\n)*?\*\/</code>~SLASH</dd>

<dt id="prod-other">`other^g</dt>
<dd>~SLASH<code>[^\t\n\r 0-9A-Za-z]</code>~SLASH</dd>

</dl>

<p>
~tok化は Unicode 文字~並び `UNICODE$r に対し演算する。
~tok化の際には、最長合致が利用され~MUST。
例えば，入力~textが
“<span class="input">a1</span>”
であるなら、それは１個の `identifier$g に~tok化され，
`identifier$g と `integer$g には分離されない。
最長合致が［
上に挙げた，名前を持つ終端~記号の いずれか
］と［
文法~内の終端~記号
］のいずれにも合致し得る場合、後者の終端~記号に~tok化され~MUST。
したがって、入力~text
“<span class="input">long</span>”
は，
`identifier$g `long^l ではなく，引用符で括られた終端~記号 `long^sym
として~tok化され、
“<span class="input">.</span>”
は，
`other$g
ではなく，引用符で括られた終端~記号
`.^sym
として~tok化される。
◎
The tokenizer operates on a sequence of Unicode characters [UNICODE]. When tokenizing, the longest possible match must be used. For example, if the input text is “a1”, it is tokenized as a single identifier, and not as a separate identifier and integer. If the longest possible match could match one of the above named terminal symbols or one of the other terminal symbols from the grammar, it must be tokenized as the latter. Thus, the input text “long” is tokenized as the quoted terminal symbol long rather than an identifier called “long”, and “.” is tokenized as the quoted terminal symbol . rather than an other.
</p>

<p>
~IDL構文においては、文字の大小は，文法~内で利用される引用符で括られた終端~記号と
`identifier$g 終端~記号に利用される値の，いずれにおいても区別される。
したがって、例えば入力~text
“<span class="input">Const</span>”
は，終端~記号 `const^sym ではなく `identifier$g として~tok化され、
`識別子$ `A^l を伴う`~ifc$は， `a^l を伴うそれとは異なるものになり、
また，`拡張属性$ `constructor^x が `Constructor$x 拡張属性に認識されることはない。
◎
The IDL syntax is case sensitive, both for the quoted terminal symbols used in the grammar and the values used for identifier terminals. Thus, for example, the input text “Const” is tokenized as an identifier rather than the terminal symbol const, an interface with identifier “A” is distinct from one named “a”, and an extended attribute [constructor] will not be recognized as the [Constructor] extended attribute.
</p>

<p>
`whitespace$g や `comment$g からなる任意~個数の終端~記号が、構文解析される入力~textにおける，他のどの終端~記号の合間にも、暗黙的に許容される。
それらの `whitespace$g や `comment$g は、構文解析~時には無視される。
◎
Implicitly, any number of whitespace and comment terminals are allowed between every other terminal in the input text being parsed. Such whitespace and comment terminals are ignored while parsing.
</p>


<p>
次の LL(1) 文法の開始~記号 `Definitions$g が`~IDL片$に合致する：
◎
The following LL(1) grammar, starting with Definitions, matches an IDL fragment:
</p>

<p class="trans-note">【
見出しをクリックするとその文法~記号の~~参照元が示される（上の終端~記号の表も同様）。
】</p>

<!-- place holder for the over all grammar table -->
<div id="_p-grammar-table"></div>

<p class="note">注記：
非~終端~記号 `Other$g は、
`(^sym, `)^sym,
`[^sym, `]^sym,
`{^sym, `}^sym,
`,^sym
を除く，任意の１個の終端~記号に合致する。
◎
Note: The Other non-terminal matches any single terminal symbol except for "(", ")", "[", "]", "{", "}" and ",".
</p>

<p>
非~終端~記号 `ExtendedAttribute$g は，任意の空でない終端~記号の並びに合致するが（丸括弧, 角括弧, 波括弧が対になっていて, かつ `,^sym ~tokがそれらの括弧対の間にのみ現れる限り）、それらの可能な並びのうち一部のみが
この仕様で定義される`拡張属性$に利用される —
これらの拡張属性に利用される構文については
`idl-extended-attributes$sec
に。
◎
While the ExtendedAttribute non-terminal matches any non-empty sequence of terminal symbols (as long as any parentheses, square brackets or braces are balanced, and the "," token appears only within those balanced brackets), only a subset of those possible sequences are used by the extended attributes defined in this specification — see §2.12 Extended attributes for the syntaxes that are used by these extended attributes.
</p>
	</section>
	<section id="conventions">
<h2 title="Document conventions">表記規約</h2>


<p>
この文書では、次の表記規約／~styleが利用される：
◎
The following typographic conventions are used in this document:
</p>

<p class="trans-note">【
“†” が付与されているものは、この訳による追加の~style。
】</p>

<ul>
	<li>
用語の定義：
`用語例@
◎
Defining instances of terms: example term
</li>
	<li>
この文書で定義される用語へのリンク：
`用語例$
◎
Links to terms defined in this document or elsewhere: example term
</li>
	<li>
他の文書で定義される用語へのリンク：
<a class="dfnref" href="https://triple-underscore.github.io/WebIDL-ja.html#dfn-example-term">example term</a>
◎
↑</li>
	<li>
文法の終端~記号（~literal）：
`sometoken^sym
◎
Grammar terminals: sometoken
</li>
	<li>
文法の非~終端~記号（先頭は大文字）：
`ExampleGrammarSymbol^g
◎
Grammar non-terminals: ExampleGrammarNonTerminal
</li>
	<li>
文法の終端~記号（生成規則, 先頭は小文字）： `identifier^g
◎
Grammar symbols: identifier
</li>
	<li>
~IDL型：`ExampleIDLType^T,<br>
~IDL~ifc~mb：`ExampleIDLMember^M,<br>
~IDL値：`ExampleIDLValue^V
</li>
	<li>
~JS型：`ExampleESType^t,<br>
~JS値：`ExampleESValue^v
◎
IDL and ECMAScript types: ExampleType
</li>
	<li>
~JS内部［~prop／~meth／~slot］： `ExamplePropertyOrMethodOrSlot^es
†
</li>
	<li>
~JS抽象演算：
<a class="abstract">ExampleAbstractOperation</a>
†
</li>
<!-- 
~JS~obj~mb：ExampleESMember^m
-->


	<li>
~code片：
`a = b + obj.f()^c
◎
Code snippets: a = b + obj.f()
</li>
	<li>
Unicode 文字：
`U+0030 DIGIT ZERO ("0")^char
◎
Unicode characters: U+0030 DIGIT ZERO ("0")
</li>
	<li>
拡張属性：
`ExampleExtendedAttribute^x
◎
Extended attributes: [ExampleExtendedAttribute]
</li>
	<li>
注釈文や~algoにおける変数~名：
%exampleVariableName
◎
Variable names in prose and algorithms: exampleVariableName.
</li>
	<li>
文字列~literal：
`example string literal^l
†
</li>
	<li>
モデルを定義するために利用される仮想の定数~値：
`定数~例^C
†
</li>
	<li>
各~algoでは、~JS~completion~recordを unwrap する<!-- ＊ -->ための［
! 記法および ? 記法
］も含め，
<a href="~TC39#sec-algorithm-conventions">~JS仕様の規約</a>
が利用される。
◎
Algorithms use the conventions of the ECMAScript specification, including the ! and ? notation for unwrapping completion records.
</li>
	<li>
<p>
~IDL構文の参考例：
◎
IDL informal syntax examples:
</p>

<pre class="syntax">
interface `identifier^mk {
  /* interface_members... */
};
</pre>

<p>
（周囲の注釈文の中で論の対象にされている構文は， mark 要素で`強調される^mk（~styleは~browserに依存する）。）
◎
(Specific parts of the syntax discussed in surrounding prose are highlighted.)
</p>
	</li>
	<li>
<p>
~IDL文法~片：
◎
IDL grammar snippets:
</p>

<dl class="grammar">
	<dt>`ExampleGrammarNonTerminal^g</dt>
	<dd>`OtherNonTerminal^g `sometoken^sym
`other$g `AnotherNonTerminal^g
ε  // <span title="nothing">nothing</span></dd>
</dl>

	</li>
	<li>
<p>
規定でない注記：
◎
Non-normative notes:
</p>

<p class="note">注記：
これは注記。
◎
Note: This is a note.
</p>
	</li>
	<li>
<p>
規定でない例：
◎
Non-normative examples:
</p>

<div class="example">
<p>
これは例。
◎
This is an example.
</p>
</div>
	</li>
	<li>
<p>
規定の警告：
◎
Normative warnings:
</p>

<p class="advisement">
これは警告。
◎
This is a warning.
</p>

	</li>
	<li>
<p>
~code~block：
◎
Code blocks:
</p>

<pre class="idl-code">
// <span class="comment"
	title="This is an IDL code block.">これは~IDL~code~block。</span>
interface Example {
  attribute long something;
};
</pre>

<pre class="es-code">
// <span class="comment"
	title="This is an ECMAScript code block.">これは~JS~code~block。</span>
window.onload = function() { window.alert("loaded"); };
</pre>

</li>
</ul>


	</section>
	<section id="conformance">
<h2 title="Conformance">適合性</h2>


<p class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#conformance">W3C 日本語訳 共通ページ</a>
に委譲
】</p>

<p>
この仕様では、次に挙げる主体が適合性の対象になるものと定義される：
◎
The following conformance classes are defined by this specification:
</p>

<dl>
	<dt>`適合~IDL片の集合@◎conforming set of IDL fragments</dt>
	<dd>
`~IDL片$の集合は、全体として，この仕様にて~IDL片に適用される［
“〜~MUST_NOT” , “要求される” <!-- , “〜SHALL”  -->
~levelの判定基準
］をすべて満たすとき，`適合~IDL片の集合$になる。
◎
A set of IDL fragments is considered to be a conforming set of IDL fragments if, taken together, they satisfy all of the must-, required- and shall-level criteria in this specification that apply to IDL fragments.
</dd>

	<dt>`適合~実装@◎conforming implementation</dt>
	<dd>
~UAは、自身が~supportするすべての言語束縛において，この仕様により その実装に適用される，すべての
“〜~MUST_NOT” , “要求される” <!-- , “〜SHALL”  -->
~levelの判定基準を満たすとき，
`適合~IDL片の集合$に対する`適合~実装$であるとされる。
◎
A user agent is considered to be a conforming implementation relative to a conforming set of IDL fragments if it satisfies all of the must-, required- and shall-level criteria in this specification that apply to implementations for all language bindings that the user agent supports.
</dd>
	<dt>`適合~JS実装@◎conforming ECMAScript implementation</dt>
	<dd>
~UAは、この仕様にて~JS言語束縛の実装に適用されるすべての
“〜~MUST_NOT” , “要求される” <!-- , “〜SHALL”  -->
~levelの判定基準を満たすとき，
`適合~IDL片の集合$に対する`適合~JS実装$であるとされる。
◎
A user agent is considered to be a conforming ECMAScript implementation relative to a conforming set of IDL fragments if it satisfies all of the must-, required- and shall-level criteria in this specification that apply to implementations for the ECMAScript language binding.
</dd>

</dl>


	</section>

</main></div><!-- MAIN -->

	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative-references">
<h3 title="Normative references">文献（規範的）</h3>


<dl>

	<dt>[ECMA-262]</dt>
	<dd>ECMAScript Language Specification.</dd>
	<dd>https://tc39.github.io/ecma262/</dd>

	<dt>[HTML]</dt>
	<dd>Ian Hickson. HTML Standard. Living Standard.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

	<dt>[IEEE-754]</dt>
	<dd>IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985). 29 August 2008.</dd>
	<dd>http://ieeexplore.ieee.org/servlet/opac?punumber=4610933</dd>

	<dt>[PERLRE]</dt>
	<dd>Perl regular expressions (Perl 5.8.8). February 2006.</dd>
	<dd>http://search.cpan.org/dist/perl/pod/perlre.pod</dd>
	<dd class="trans-ja-refs"><a href="http://perldoc.jp/pod/perlreref">日本語訳</a></dd>

	<dt>[RFC2119]</dt>
	<dd>S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc2119</dd>

	<dt>[RFC2781]</dt>
	<dd>P. Hoffman; F. Yergeau. UTF-16, an encoding of ISO 10646. February 2000. Informational.</dd>
	<dd>https://tools.ietf.org/html/rfc2781</dd>

	<dt>[RFC3629]</dt>
	<dd>F. Yergeau. UTF-8, a transformation format of ISO 10646. November 2003. Internet Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc3629</dd>

	<dt>[SECURE-CONTEXTS]</dt>
	<dd>Mike West. Secure Contexts.</dd>
	<dd>https://w3c.github.io/webappsec-secure-contexts/</dd>

	<dt>[UNICODE]</dt>
	<dd>The Unicode Standard.</dd>
	<dd>http://www.unicode.org/versions/latest/</dd></dl>


		</section>
		<section id="informative-references">
<h3 title="Informative references">文献（参考）</h3>


<dl>

	<dt>[DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>

	<dt>[OMGIDL]</dt>
	<dd>CORBA 3.1 – OMG IDL Syntax and Semantics chapter. January 2008.</dd>
	<dd>http://www.omg.org/cgi-bin/doc?formal/08-01-04.pdf</dd>

	<dt>[XML-NAMES]</dt>
	<dd>Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC.</dd>
	<dd>https://www.w3.org/TR/xml-names</dd>
</dl>


		</section>
	</section>

</body></html>



<!--%他の語


	等しい:equal
	供され:supplied
最終的~eventual

何もしない:no-op
~~問題ない:Fine;

出荷:shipping
誤った:erroneous
~~特別なdiscriminated
置くplace
惑わすことになる:confusing
決める:decide する:~

前に〜を置く:precede
対応-:correspond:~
	対応付ける:map する:~／correspond
可能: 23
唯一の:only:~ 18
意味:mean／meaning 22
~~意味があるit makes sense

常に:always
合格-:pass:~
表明:assertion:~

同じ:the same
後続: 13
広義: 18
必要: 24
自身: 33
複数: 30
追加: 17
以上: 4
以下: 19
以外: 11
任意: 16
位置: 46
同様: 28
型互換: 19
場合: 259
部分: 9
対応: 117
対応付: 3
方法: how
時点: 10
末尾: 12
末端: 7＠most-derived／
注意: 16
番目: 15
手段:means
一方: 14
一連: 25
一部: 20
併用: 8＠declared with／
先頭: 9
右側: 4＠right-hand side／right
左側: 8＠left-hand side／left
場所: 12
最大: 4
最小: 7
有無: 6
理由: 7＠reason／because 10
用語例: 2
用途: 6
目的: 6
課題: 11
通常: 6＠regular/Fine/
通常の: normal な:~
通常のようにnormally
類似: 6
他方: 8
両者: 7
両方: 2
両方同時: 1
以上: 13
個数: 17

リンク:link:~
グラム: 1
一例: 2
一定: 3
一時的: 1
一環: 1＠as part of
一種: 1
一般: 3

丁度:just 1
上述: 2
上限: 1
下位手続: 1
下位~節: 2＠sub-section
下端: 1
不可欠: 1
不定: 1＠indeterminate
不要: 2
不都合: 1
中心: 1
中止: 1
主体: 1
主要: 1

互換: 1
今度: 1
付与: 2
代入: 1
代用対: 1
以前: 2
仮想: 1

何故: 1
余分: 5
併合:mixed 1
使用中:in use 1
~~例外: 1
供給: 1
依然: 3
便宜:convenience

個
個別: 1
候補: 1＠possible
側面: 1
入力: 3
全体: 3
通例usually／usual
通例の:
具体的な:concrete:~
内部: 1
冒頭: 1
出自に: 1＠originate
分類: 2＠
別途: 1
前回: 1
前段: 1
前述: 2
前項: 1
動作: 4
区切: 3
区別: 1
十分: 2
午前零時:1＠midnight
~~唯一の:sole:~
即時: 1＠immediately
原文: 4
参照: 2
参照文献: 1
参考例: 1
各下位~節: 1
各発行: 1
各種: 3
各節: 1
各項: 4
合間: 3
同一: 1
同一性: 1
同時: 2
向上: 1
周囲: 1
問題: 3
回数: 1
図式:diagram 1
基底: 1
基準: 1
基礎的: 1
場合分: 2
増補: 1＠grow
大小:case:~
大文字:uppercase letter:~
小文字:lowercase letter／lowercase:~
変形: 1

変異:mutation/mutating 2
多少: 1
多重~継承:multiple 〜1
姓名: 1＠names
委譲-: 1＠delegated
定義: 3
定訳: 1
実現: 1
実行制御: 1
実行結果: 1
容易: 2
~~寄与: 2＠adhere／contributing
対訳: 2
対象: 3
導入: 3
左右: 1
平文: 1
広範囲:wide 1
強調: 1
後者: 4
前者: 2
復号: 1＠decoding
復活: 1＠Added back
必須化:Require 1
応答: 1＠responding
意図的: 1＠deliberate
感謝: 1
成立-:be true 3
手法: 1
把握: 1＠unaware
括弧対: 1
挿入-:insert 1
操作-:manipulate
操作:manipulating／manipulation
支持: 1
数値: 1
数字: 1
数的: 1＠numerical
整列: 1
文献: 2
既存: 1
既知: 1
日間: 1
昇順: 2
降順: 1
明白: 1
明確には:Specifically 1
時間: 1＠time:~
時間切: 1＠timed out
時間差: 1＠amount of time:~
最上層: 1＠top-most 1
最低: 2＠lowest
最新の:latest
最終的: 3
最良: 1
最長: 2＠longest
有用: 1
未知: 1
条件: 4
検出: 1
極力避: 1
~~概念: 1＠notion:~ 1
概略的: 1＠Informally
構成-:2＠comprise:~ 2
次項: 3
段落: 1
段階: 1
比較: 1
混同:＠looking like 1
熟慮: 1＠deliberate
片方: 1
独自: 2
用例: 2
申請: 1
留意: 1＠Remember
知識:knowledge:~
番号: 1
発行: 1
直後: 4
相互: 1
相違: 1
矩形: 1＠rectangle
~~確認:checked to ensure
程度: 1
種別: 2
等距離:equally close
算出方法: 1
算出結果: 1
~~精度:precision:~
~~精度:accuracy
近く:closely
終了:end 3
終始:consistently:~
維持: 1
総称: 2
編集: 2
編集者: 3＠editor
編集者草案: 1＠editor’s draft
~~自動的: 1
英単語: 1
英字: 1
行番号: 1
表出: 1
表記: 1
表記規約:typographic convention:~
規範的:normative
草案:draft:~
表現力:expressiveness:~
補助: 2
補数: 1
見受: 1
見通: 1
解消: 1
取り組-:address
言及: 4
記述例:example 1
訳者: 1
該当: 2
誘発: 1＠cause
調整: 3＠tweaked
調整を通すcoordinate
謝意: 1
謝辞: 1
因る: due to
起点: 1＠epoch
過去: 1
適当: 1
遭遇-:encounter 1
選択-:choose 1
重複:duplicates 1
開始:start
開発時:during the development 1
関係: 1
関係無: 1
防止: 2
集約: 1
非公式: 1
項目: 3
頭部: 2
有意:has significance
~~終端end
~null
２の補数two’s complement
予測し得ない unpredictable
細心の注意を払う必要があるExtreme care must be taken
孕まれる問題~problematic
見つけ易くするhelp 〜 look for

~~入力にとる~take
~~入力のincoming
順繰りに挙げloop through
object 指向: 2
グラム／単位
米／肉／麺／魚／その他:rice／sandwich／noodles／dumplings／other
~~役割を担う:serve 1
担当グループ:group responsible for work 1
ミリ秒数:number of milliseconds
個
素のbare
単に:simply
節:section:~
listed in 〜／
表す:denote 2
休みunavailable to do so
含む:include
~call元:caller
指す:refer
指す:address
一義的:unambiguous
-->

