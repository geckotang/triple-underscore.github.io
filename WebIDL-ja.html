<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Web IDL （第２版 — 日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<!--%script -->

<script>
var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'http://heycam.github.io/webidl/',
		spec_status: 'ED',
		main: 'MAIN',
		fill_text_link: '#_versions > dd, #references dd',
		ref_id_prefix: 'ref-',
		alt_refs: 'references'
	};

	if(expanded) return options;

// 文法ブロック生成
	var grammar_tables = buildGrammerTables();

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		ext_map: Util.getMapping('_ext_map'),
		sec_map: Util.getMapping('_secno_map'),
		levels: 'ほぼ英語:英語主体:英語寄り:漢字主体:カナ主体',
		grammar_tables: grammar_tables,
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);


	return options;


/* checked for 2016-02-15 spec.

	Util.del_j();
	repeat('pre span[title]', function(e){
		e.textContent = e.title;//.replace(/^/gm, '// ');
	});
	repeat('h2, h3, h4, h5', function(e){
		var t = e.title;
		if(!t) return;
		e.textContent = e.textContent.replace(/\. .+/, '. ' + t);
	});
	repeat('dl.grammar > dd', function(e){
		e.insertBefore(document.createTextNode(' → '), e.firstChild);
	});
*/

}

/*
// section id → 番号 対応表生成
	repeat('h2, h3, h4, h5', function(h){
		var num = h.textContent.split('. ', 1)[0];
		var id = h.parentNode.id;
		if(id && num) source_data.sec_map[id] = num;
	});
	Util.dump(source_data.sec_map);



repeat('aside, header #sotd, #words_table1, #words_table0, #_ext_map, .trans-note, .example, .note, .warning', function(e){
	e.parentNode.removeChild(e);
})
*/

function expand(mapping1){
	E('MAIN').innerHTML = Util.replaceWords1(
		createHTML(),
		mapping1
	);

	populate();

// 目次構築 
	Util.rebuildToc('sections', '_toc_list0');
	Util.rebuildToc('appendices', '_toc_list1');
}


/*内容変換生成*/

function createHTML(){
	var source = source_data.html;
	var link_map = source_data.link_map;
	var ext_map = source_data.ext_map;
	var sec_map = source_data.sec_map;//リンク → 節番号

	return source.replace(
		/◎[^<◎]*|%([\w\-]+)|`(.*?)([$@\^]\w*)/g,
		create_html
	);

function create_html(s, key1, key, indicator){
	if(key1){
		return '<var>' + key1 + '</var>';
	}
	if(!key){
		return '<span lang="en">' + s.slice(1).trim() + '</span>';
	}
	switch(indicator){
	case '^':
		return ext_map[key];
	case '@':
		return '<dfn id="' + link_map[key].slice(1) + '">' + key + '</dfn>';
	case '$':
		return '<a href="' + link_map[key] + '">' + key + '</a>';
	case '$g': // 生成規則
		return '<a class="sym" href="#prod-' + key + '">' + key + '</a>';
	case '^g': // 生成規則
		return '<span class="sym" href="#prod-' + key + '">' + key + '</span>';
	case '^sym': // 定数 終端記号
		return '<span class="sym">"' + key + '"</span>';
	case '^char': // char
		return '<span class="char">' + key + '</span>';
	case '^sup': // sup
		return '<sup>' + key + '</sup>';
	case '^c': // code
		return '<code>' + key + '</code>';
	case '^i': // i syntax変数
		return '<i>' + key + '</i>';
	case '^C': // 仮想定数
		return '<i class="const">' + key + '</i>';
	case '^mk': // syntax強調
		return '<mark>' + key + '</mark>';
	case '^l': // literal
		return '"<code>' + key + '</code>"';
	case '@err': // Error 名
		return '"<code id="' + key.toLowerCase() + '">' + key + '</code>"';
	case '$T': // IDL 型
		return '<a class="idltype" href="#idl-' + key.replace(/ /g, '-') + '">' + key + '</a>';
	case '^T': // IDL 型
		return '<span class="idltype">' + key + '</span>';
	case '@T': // IDL 型（定義）
		return '<dfn class="idltype" id="idl-' + key.replace(/ /g, '-') + '">' + key + '</dfn>';
	case '^t': // ES 型
		return '<span class="estype">' + key + '</span>';
	case '^V': // IDL 値
		return '<span class="idlvalue">' + key + '</span>';
	case '^v': // ES 値
		return '<span class="esvalue">' + key + '</span>';
	case '$A': // ES 抽象演算
		return '<a class="abstract" href="~ES6#sec-' + key.toLowerCase() + '">' + key + '</a>';
	case '^M': // IDL メンバ
		return '<span class="idlmember">' + key + '</span>';
	case '$x': // 拡張属性
		return '<a class="xattr" href="#' + key + '">[' + key + ']</a>';
	case '^x': // 拡張属性
		return '<span class="xattr">[' + key + ']</span>';
	case '$r': // 文献
		return '<a href="#ref-' + key + '">[' + key + ']</a>';
	case '$sec': // 節
//		if(! (key in sec_map)) console.log(key);
		return '<a href="#'+ key +'" >' + sec_map[key] +' 節</a>';
	case '^es': // ES 内部 property/method/slot
		return '<span class="prop">[[' + key + ']]</span>';
/*
	case '^m': // ES member,
		return '<span class="esmember">' + key + '</span>';
	case '^note': // 訳注
		return '<span class="trans-note">【' + key + '】</span>';
	case '^esa': // ES 抽象演算
		return '<span class="esabs">' + key + '</span>';
	case '^cp': // 複製の place holder 
		return '<a title="cp-' + key + '"></a>';
*/

	case '^desc': // ES property descriptor
		return desc(key);

	default:
		return s;
	}
}

function desc(id){// ES プロパティ記述子
	return (
		'<span class="descriptor">{\u00A0' +
		'[[Writable]]: ' + TFmap(id[0]) +
		', [[Enumerable]]: ' + TFmap(id[1]) +
		', [[Configurable]]: ' + TFmap(id[2]) +
		( (id.length > 3) ?
			', [[Value]]:' + TFmap(id.slice(4)) : ''
		) + 
		'\u00A0}</span>' // 00A0 &nbsp;
	);
	function TFmap(c){
		switch(c) {
		case 'T':
			return '<span class="esvalue">true</span>';
		case 'F':
			return '<span class="esvalue">false</span>';
		default:
			return '<var>' + c + '</var>';
		}
	}
}

}


function populate(){
// ラベル生成
	var span = C('span');
	span.className = 'blockTitle';
	var map = {
		'idl-code': 'IDL',
		'es-code': 'ECMAScript',
		'html-code': 'HTML'
	}
	repeat('pre.idl-code, pre.es-code, pre.html-code', function(pre){
		var title = map[pre.className];
		if(!title) return;
		var s = span.cloneNode(false);
		s.textContent = title;
		var div = C('div');
		div.className = 'block';
		div.appendChild(s);
		pre.parentNode.insertBefore(div, pre);
		div.appendChild(pre);
	});

	span.className = 'header';
	var map = { note: '注記', example: '例', warning: '警告', ednote: '課題'}
	for(var n in map){
		span.textContent = map[n];
		repeat('div.' + n, function(div){
			div.insertBefore(span.cloneNode(true), div.firstChild);
		});
	}

// 内容複製
	duplicate();
	
	function duplicate(){
		var visited = Object.create(null);
		var iter = document.createNodeIterator(
			E('MAIN'), NodeFilter.SHOW_COMMENT, null, null
		);
		var node;
		while(node = iter.nextNode()){
			var id = node.data;
			if(id.slice(0, 3) !== 'cp-'){
				continue;
			}
			var e = visited[id] || E(id);
			if(!e) continue;
//			if(!e) console.log(id);
			if(!visited[id]){
				e.removeAttribute('id');
//				e.style.outline = 'solid green 1px'
				visited[id] = e;
			}
			e = e.cloneNode(true);
//			e.style.outline = 'dashed green 1px'
			node.parentNode.replaceChild(e, node);
		}
	}


// 文法ブロック
	var G = source_data.grammar_tables;
	var lhs = G.dt;
	var rhs = G.dd;

	repeat('div.grammar', function(div){
		var dl = C('dl');
		dl.className = 'grammar';
		div.textContent.match(/\w+/g).forEach(function(name){
			if(!(name in lhs)) return;// throw name;
			dl.appendChild(lhs[name].cloneNode(true));
			dl.appendChild(rhs[name].cloneNode(true));
		});
		div.parentNode.replaceChild(dl, div);
	});

	var grammar_table = E('_p-grammar-table');
	grammar_table.parentNode.replaceChild(G.dom, grammar_table);
}



// 文法ブロック生成
// 逆参照機能があるので、文法一覧 → 本文リンクは省略
function buildGrammerTables(){
	var g_data = E('_d-grammar-table');
	g_data.parentNode.removeChild(g_data);
	var g_table = C('dl');

	var lhs = Object.create(null);
	var rhs = Object.create(null);
	var index = 0;

	g_table.className = 'grammar';
	g_table.innerHTML = '<dd>' + g_data.textContent
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/\s(?=[A-Za-z])/g, '＠')
		.replace(/\s*●(●?)(\w+)\s*/g, function(t, v2, name){
			lhs[name] = index++;
			return (
'</dd><dt'
+ (v2 ? ' class="v2"' : '')
+ '><span class="prod-number">['
+ index
+ ']</span>＠'
+ name
+ '</dt><dd>'
			);
		})
		.replace(/＠(\w+)/g, ' <a class="sym" href="#prod-$1">$1</a>')
		+ '</dd>\n'
	;

	g_table.removeChild(g_table.firstChild);

	var dts = g_table.getElementsByTagName('dt');
	var span = C('span');
	span.className = 'sym';

	for(var name in lhs){
		var dt = dts.item(lhs[name]);
		rhs[name] = dt.nextElementSibling;
		lhs[name] = dt.cloneNode(true);

		dt.id = 'prod-' + name;
		var s = span.cloneNode(false);
		s.textContent = name;
		dt.replaceChild(s, dt.lastChild);
	}

	return {dom: g_table, dt: lhs, dd: rhs};///
}

</script>


<script type="text/plain" id="_original_id_map">
ol-callable:
ol-optionality-list:
ol-type-list:
type-compatible:
dfn-variadic-argument:
dfn-normal-location:
dfn-consequential0:
dfn-const-tokens:
	dfn-element-type:
dfn-exception-thrown:
_conventions:
	prop-accessors:
	_es-conversion-for-idl-integer_:
es-integers:
idl-integers:
idl-floats:
	dfn-get-buffer-source-reference-or-copy:dfn-get-buffer-source-reference

dfn-invoke-indexed-setter:invoke-indexed-setter
dfn-invoke-named-setter:invoke-named-setter
dfn-function-like:

	idl-long:dom-long
	idl-unsigned-long:dom-unsignedlong
	idl-long-long:dom-longlong
	idl-unsigned-long-long:dom-unsignedlonglong
	idl-float:dom-float
	idl-unrestricted-float:dom-unrestrictedfloat
	idl-double:dom-double
	idl-unrestricted-double:dom-unrestricteddouble
	idl-DOMString:dom-DOMString
	idl-ByteString:dom-ByteString
	idl-USVString:dom-USVString
	idl-object:dom-object
	idl-sequence:dom-sequence
	idl-promise:dom-promise
	idl-RegExp:dom-RegExp
	idl-Error:dom-Error
	idl-frozen-array:dom-FrozenArray

</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
THEN:⇒<br>&nbsp;&nbsp;&nbsp;
THROW:<a href="#ecmascript-throw"><b>THROW</b></a>
TRY:<a href="#_try-catch_" ><b>TRY</b></a>
REJECT:<b>REJECT</b>
CATCH:<b>CATCH</b>

MUST:なければ<em class="rfc2119">ならない</em>
MUST_NOT:<em class="rfc2119">ならない</em>
MAY:<em class="rfc2119">よい</em>
SHOULD:<em class="rfc2119">べき</em>である
SHOULD_NOT:<em class="rfc2119">べき</em>でない
REQUIRED:<em class="rfc2119">要求される</em>

ES6:https://tc39.github.io/ecma262/
	http://www.ecma-international.org/ecma-262/6.0/
	https://people.mozilla.org/~jorendorff/es6-draft.html


REPLACEMENT:<span class="char">U+FFFD REPLACEMENT CHARACTER</span>
varT:<var>T</var>
thisArg:<i>thisArgument</i>
	thisArg:<i>thisArg</i>
argList:<i>argumentsList</i>
iterator0:@@iterator
</script>
<!-- 
xF: <span class="esvalue">false</span>
xT: <span class="esvalue">true</span>
xB: <var>B</var>
xC: <var>C</var>
xE: <var>E</var>
xS: <var>S</var>
-->

<!--%語 -->
<script type="text/plain" id="words_table">
名前:name:~
名:name:~
値:value:~
型:type:~
	種別:type:~
true:
false:

ifc:interface::::インタフェース
obj:object::::オブジェクト
prop:property::::プロパティ
data-prop:data property::::データプロパティ
meth:method::::メソッド
内的:internal:内部
algo:algorithm::アルゴリズム
辞書:dictionary::::ディクショナリ
列挙:enumeration:::~
列挙不可:unenumerable::~
列挙可能:enumerable::~
列挙-:enumerate::~

連列:sequence::::シーケンス
	sequence:::並び
原型:prototype::::プロトタイプ
原型鎖:prototype chain::::プロトタイプチェイン
tok:token:::トークン

optional:::オプション
随意:optional::::オプショナル
	随意の:optional::::オプショナル
	随意~引数
省略可否:optionality::~
省略可:optional::~
必須:required::~
	必須:non-optional
引数:argument:~
引数個数:argument count:~
可変個:variadic::~
	可変個の引数をとる:variadic
	可変個
	可変個~引数:variadic argument:
固定長:fixed length:~

判別-:distinguish:~
判別可能:distinguishable:~
判別引数:distinguishing argument:~

mb:member:::メンバ
文字列:string::~
scalar:::::スカラー
演算:operation::~::オペレーション
演算-:operate:~
関数:function::~
例外:exception::~
単純例外:simple exception::~
変換-:convert::~
変換:conversion::~
属性:attribute::~::アトリビュート
拡張属性:extended attribute::~::拡張アトリビュート

定義-:define:~
定義:definition:~
未定義:undefined:~
	〜により定義される:-defined
再定義-:redefine:~
定義済みの:predefined:~

返値:return value:return 値:返り値
返値型:return type:return 型:返り値型
返す:return する:~
返る:return する:~
返され:return され:~
返さな:return しな:~
返し:return し:~
返せる:return できる:~
	int_t:integer 型::整数型
固有型:specific type:specific 型:~
内部型:inner type:inner 型:~::インナー型
共用体:union:::~:ユニオン
promise:
凍結-:freeze::~
凍結:frozen::~
実数:numeric::~
整数:integer::~
無符号:unsigned:::符号なし
有符号:signed:::符号あり

配列:array:::~
有型:typed:~
既定:default:::~:デフォルト
既定の:default:::~:デフォルト
呼戻:callback::::コールバック
呼戻子:callback::::コールバック
index:::::インデックス
indexing:::index アクセス::インデクシング
有index:indexed::有 index::有インデックス
有名:named::~
keyword::::キーワード
pdesc:Property Descriptor::property 記述子::プロパティデスクリプタ
	descriptor::::記述子:デスクリプタ
field::::フィールド
instance::::インスタンス
host::::ホスト
nullable:
null:
view:::::ビュー
class:::::クラス
	可 null
多重定義:overload::~::オーバーロード
有効:effective:~
	有効~多重定義~集合:effective overload set
継承-:inherit::~
継承:inheritance::~
継承ing:inheriting::継承
非継承:non-inherited::~
	辞書継承:inherit::~
被継承:inherited::継承
継承階層:inheritance hierarchy:~
UA:user agent::UA::ユーザエージェント
利用者:user:::~:ユーザ
platform:::::プラットフォーム
予約済み:reserved:~
予約済みの:reserved:~
識別子:identifier::~
構築子:constructor:::~:コンストラクタ
取得子:getter:::~:ゲッタ
設定子:setter:::~:セッタ
作成子:creator:::~:クリエータ
削除子:deleter:::~:デリータ
文字列化子:stringifier:::~
文字列化:stringify:::~
文字列化の:stringification:::~
旧来呼出子:legacy caller:::~
旧来:legacy:::~
旧来の:legacy:::~
直列化-:serialize:::~:シリアライズ
直列化子:serializer:::~:シリアライザ
直列化:serialization:::~:シリアル化
直列化の:serialization:::~:シリアル化の
	シリアライゼーション
直列化ed:serialized:::直列化:シリアル化
	直列化済み
直列化可能:serializable:::~:シリアライズ可能
直列化可能な:serializable:::~:シリアライズ可能な
	ser_t:serialized type:serialized 型:
map:::::マップ
set:::::セット
slot:::::スロット
buffer:::::バッファ
source:::::ソース
maplike:::mapもどき::マップもどき
setlike:::setもどき::セットもどき
反復子:iterator:::~:イテレータ
反復-:iterate:::~:イテレート
反復:iteration:::~:イテレーション
反復型:iterated type:iterated 型::~:イテレート型
反復値:iterated value:iterated 値::~:イテレート値
可反復:iterable:::~:イテラブル
追加子:adder:~

状態:state:~
target:

投出:throw::~::スロー
定数:constant::~::コンスタント
正則:regular:::~:レギュラー
静的:static:::~:スタティック
特殊:special:::~:スペシャル
有限:finite::~
単精度:single-precision::~
倍精度:double-precision::~
浮動小数点:floating point::~
浮動小数点数:floating point number::~
片:fragment:~:::フラグメント
部分的:partial::~::パーシャル
主:primary::~:::プライマリ

符号単位:code unit::~::コードユニット
被support:supported:::被サポート

support::::サポート
message::::メッセージ
読専:readonly:::~
	読み取り専用
	//EN dash
可書:read–write:::読み書き可能
catch:::::キャッチ
configurable:
primitive:::::プリミティブ
bit::::ビット
呼出可能:callable::::コーラブル
call:::::コール
真偽:boolean::~::ブーリアン
自前の:own::~
native:::::ネイティブ
typedef:
valuetype:
flag:::::フラグ
大域:global:::~:グローバル
環境:environment:~
大域環境:global environment:global 環境:~::グローバル環境
形:form::~::フォーム
key:::::キー
value:::::値
	//EN dash
key-value:key–value pair::key–value ペア::{キー：値} ペア

言語束縛:language binding:言語 binding:~::言語バインディング
pair::::ペア
data::::データ
literal::::リテラル
escape::::エスケープ
追補:supplemental::~::サプルメンタル
帰結:consequential::~::コンシーケンシャル
平坦化-:flat 化::~
平坦化:flattened::~
特色機能:feature::~::フィーチャ
公開-:expose::~
公開:exposure::~
変更:change::~
改変-:modify::~
改変:modifications:~
偽装不可:unforgeable::~::アンフォージャブル
参照:reference:~
accessor:::アクセサ
access:::アクセス
list:::リスト
block:::ブロック
code:::コード

error:::エラー
incumbent:
script:::スクリプト
stack:::スタック
trace:::トレース
snapshot:::スナップショット
scope:::スコープ
octet:::オクテット
保安検査:security check:security 検査:~:セキュリティ検査:セキュリティチェック
符号位置:code point::~::コードポイント
注釈文:prose:~:::プローズ
隠蔽:shadow:~
言語:language:~
合致:match:~:::マッチ
日付時刻:time:~
時刻:time:~

変数:variable:~
文字:character:~
複製:copy:~
組込み:built-in:組み込み:::ビルトイン
無限:infinity:~
pattern:::パタン
entry::::エントリ
	項目／一員
識別-:identify:~
宣言:declaration:~
宣言-:declare:~
	internal::内部
長さ:length:~
writable::書き込み可能
妥当:valid:~
	invalid
解決:resolution:~:::レゾリューション
解決-:resolve:~:::リゾルブ
実装:implementation:~
実装-:implement:~
伝播-:propagate:~
適合:conforming:~
適合性:conformance:~
test-suite:test suite::テスト一式:テストスイート
初期:initial:~
要素:element:~
範囲:range:~
表現-:represent:~
	表現:representation:~
文脈:context:~:::コンテキスト
評価-:evaluate:~
等価:equivalent:~
構文:syntax:~:::シンタックス
	特徴:characteristics:~

文法:grammar:~:::グラマー
記号:symbol:~:::シンボル
symbol:
終端:terminal:~:::ターミナル
構文解析:parse:~:::パース
引用符:quotes:~:::クォート
	引用符で括られ:quote され:~
正規表現:regular expression:~
生成規則:production:~:::プロダクション
ゼロ:zero::~
byte:::バイト
loop:::ループ
tuple::::タプル
surrogate::::サロゲート
一意:unique:~
式:expression:~
	:::エクスプレッション
size::::サイズ
lookup:::表引き::ルックアップ
注釈付きの:annotated::~
注釈付き:annotated::~
implements_st:implements statement:implements 文
worker::::ワーカ
exotic:
secure::::セキュア

内在的:intrinsic::~
新たな:new:~
既存の:existing:~
既存のも:existing のも:~
空:empty:~
指定-:specify:~
所与の:given:与えられた

	●動詞
充足-:fulfill::~
却下-:reject::~
却下:rejection::~
事由:reason::~
決着-:settle::~
未初期化の:uninitialized:~
初期化-:initialize:~
代入-:assign:~
代入:assignment:~
代入ing:assigning:代入
決定-:determine:~
設定-:set:~
設定:setting:~
取得-:get:~
取得:getting:~
取得0-:retrieve:取得
取得0:retrieving:取得
取得1:retrieval:取得

削除-:delete:~
削除:deletion:~
作成-:create:~
作成:creation:~
除去-:remove:~
付加-:append:~
追加-:add:~
追加の:additional:~
	追加で
試み:attempt:~
試みて:attempt して:~
試みる:attempt する:~
試みた:attempt した:~
試みさ:attempt さ:~
試みら:attempt さ:~
走らせ:run し:~
走らさ:run さ:~

呼出す:invoke する:呼び出す
呼出せる:invoke できる:呼び出せる
呼出され:invoke され:呼び出され
呼出して:invoke して:呼び出して
呼出した:invoke した:呼び出した
呼出し:invoking:呼び出し
呼出:invocation:呼び出し
被呼出時:被 invoke 時:~
	when invoked
渡され:pass され:~
渡す:pass する:~
渡し:pass し:~
渡して:pass して:~
渡した:pass した:~
渡さず:pass せず:~
渡せる:pass できる:~
値渡し:passed by value:~

	受け~~渡-:send and receive
	~~渡しで:で pass by され
	渡り
結付けら:associate さ:結び付けら
	結付け:association:結び付け
	結付けて:associate して:結び付けて
	結付ける:associate する:結び付ける
現れる:appear する:~
現れ:appear し:~
出現:appearing:~
扱う:treat する:~
扱わな:treat しな:~
扱われ:treat され:~
	扱い:treatment:~
	扱え:treat でき:~
	扱っ:treat し:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
取扱われ:handle され:取り扱われ
取扱える:handle できる:取り扱える
利用:use:~
	用いる:use する:~
	用いら:use さ:~
	用いて:use して:~
存在-:exist:~
	存在t-:present:存在
在する:present する:在る
存在t:presence:存在
不在:not present:~

置換-:replace:~
言明-:state:~
制御:control:~
構築-:construct:~
構築:construction:~
構成子:constructs:~
連結:concatenation:~
連結-:concatenate:~
無視-:ignore:~
予期-:expect:~
期待-:expect:~
指示-:indicate:~
提供-:provide:~
束縛-:bind:~
解釈-:interpret:~
解釈:interpretation:~
付随-:accompany:~
符号化-:encode:~
符号化:encoded:~
符号化方式:encoding:~
影響-:affect:~
反映-:reflect:~
制約-:restrict:~
制約:restriction:~
拘束:constraint:~
更新:update:~
適用-:apply:~
検査:check:~
要求-:require:~
推奨-:recommend:~
許容-:allow:~
上書き:override:~
依存-:depend:~
依拠-:rely:~
受容:accept:~
破棄-:discard:~
失敗-:fail:~
分割-:split:~
分離-:separate:~
区切る:separate する:~
区切らな:separate しな:~
区切られ:separate され:~
区切りの:-separated:~
延期-:defer:~
波及-:influence:~
省略-:omit:~
	~~省略:missing:~
正準化-:canonicalize:~
模倣:mimic:~
強制:coerce:~
選定-:select:~
選定:selection:~
格納-:store:~
修正-:fix:~
記述:description:~
記述-:describe:~
述べる:describe する:~
述べら:describe さ:~
述べ:describe し:~
保持-:hold:~
保有-:keep:~
競合-:conflict:~
改称-:rename:~
命名:naming:~
命名-:name:~
挙動:behavior:ふるまい
挙動する:behave する:ふるまう
挙動し:behave し:ふるまわ
挙動させ:behave させ:ふるまわせ
照会-:query:::~:クエリ
成功-:succeed:~
登録-:register:~
完了-:complete:~
完全:complete:~
拡張-:extend:~
拡張:extension:~
拡張性:extensibility:~
変化-:change:~
変更点:changes:~
切離す:detach する::切り離す
切離され:detach され::切り離され
観測-:observe:~
意図-:intend:~
意図:intention:~
見出され:find され:~
明確化-:clarify:~
明確性:clarity:~
転送-:forward:~
機能-:work:~
働く:work する:~


代理:proxy:~
抽象:abstract:~
抽象的:abstract:~
抽象演算:abstract operation:~
仮数:significand:~
偶数:even:~
仕様:spec:~
策定者:author:~
作者:author:~
省略符号:ellipsis:~
特有:-specific:ごとに固有
特有の:specific な:固有の
固有の:specific:~
要件:requirements:~
文書:document:~
基数:base:~
先祖:ancestor:~
不許可に:disallow:~
循環:cycle:~
単一:single:~
規則:rule:~
入力:input:~
出力:output:~

暗黙的:implicit:~
明示的:explicit:~
認識-:recognize:~
和集合:union:~
連鎖:chain:~
可視性判定:visibility:~
特別:special:~
内包:include:~
接尾辞:suffix:~
推移的:transitive:~
付録:Appendix:~
最長合致:longest possible match:~
等号:equals sign:~
派生:derived:~
順序:order:~
順序付けら:order さ:~
全順序:total order:~

演算子:operator:~

semicolon:::セミコロン
colon:::コロン
comma:::カンマ
dash:::ダッシュ
波括弧:braces:~
丸括弧:parenthesis:~
角括弧:square brackets:~
山括弧:angle brackets:~

offset:::オフセット
signature:::シグネチャ
library:::ライブラリ
system:::システム
browser:::ブラウザ
clone:::クローン
メインスレッド:main thread::~
テスト:testing::~
プロジェクト:project::~
version:::バージョン
node:::ノード
graph:::グラフ
parameter:::パラメタ
hook:::フック
クラス:class::~
page:::ページ
テキスト:text:~
event-handler:event handler::イベントハンドラ
プレースホルダ:place holder::~
プログラミング:programming::~
プログラム:program::~
pointer:::ポインタ
chunk:::チャンク
スタイル:style::~
デザインパターン:design pattern::~
文:statement:~
集合:set:~:::セット
部分集合:subset:~:::サブセット
固定的:fixed:~
略記形:bare form:~
構造:structure:~
連想配列:associative array:~
有向:directed:~
辞書式:lexicographic:~
方式:manner:~
相対的:relative:~
絶対的:absolute:~
直接的:direct:~
間接的:indirect:~
暗黙の:implied:~
形式的:formal:~
現在の:current:~
現在:currently:~
最初の:first:~
最後の:last:~
二番目の:second:２番目の
第一:first:~
第二:second:~
第三:third:~

結果:result:~

	注記:note:~
	警告:warning:~
	課題:issue:~

標準:standard:~
非標準:non-standard:~
相互運用性:interoperability:~
レベル:level:~
互換性:compatibility:~
技術報告:technical reports:~
非依存:independent:~
将来:future:~
メーリングリスト:mailing list:~
バグ:bug::~
	リンク:link:~
規定:normative:~
参考:informative:~
詳細:details:~
意味論:semantics:~:::セマンティクス
判定基準:criteria:~
記法:notation:~
手続き:steps:~
下位手続き:substeps:~
系列:variety:~
便宜性:facility:~
普通の:ordinary:~


	●低頻度

非同期:asynchronous:~
所在:location:~
	同一性:identity:~
実体:entity:~
正確:exact:~
略記法:shorthand:~
可用:available:~
可用な:available:~
副作用:side effect:~
情報:information:~
適切:appropriate:~
計数:counter:~
検分:inspection:~
検分-:inspect:~
対応関係:mapping:~
種類:kind:~

単独の:single:~
単純:simple:~
単純化-:simplify:~
効果:effect:~
	効果なし:no effect:~
不正:incorrect:~
不正な:incorrect:~
正しく:correct に:~
	正しい right

構文解析器:parser:~:::パーサ
衝突:clash:~
protocol::プロトコル
binary::バイナリ
network::ネットワーク
encapsulate:::カプセル化
encapsulation:::カプセル化

transaction:::トランザクション
database:::データベース
mode:::モード
作動中:active:~:::アクティブ
記憶域:memory:~:::メモリ
パタン:pattern:~
モデル:model:~
セキュリティ:security:~
木:tree::~::ツリー
下層の:underlaying:~
	underyling
	節:section:~
実質的:effective:~
共通の:common:~
共通する:common な:~
共通的に:common に:よく
規約:convention:~
交換可能:interchangable:~
一覧:table:~
一貫性:consistency:~
内容:contents:~
保証:guarantee:~
匿名:anonymous:~
多義性:ambiguity:~
歴史的:historical:~
状況:situation:~
要請:request:~
一般的な:general:~
一般:general:~
心配:concern:~
制限:limitation:~
処理:processing:~
私的:private:~
数学的演算:mathematical operation:~
整合性:consistency:~
機能性:functionality:~
ハイフン:hyphen:~
連続的な:contiguous:~
解禁-:lift:~
記録-:record:~
設計:design:~
最適化:optimization:~
実際の:actual:~
	論じら:discuss さ:~
	説明-:explain
	説明:explanation／description:~
算出-:compute:~
算出:computing:~
計算:computation:~
平方根:square root:~
査読者:reviewer:~
内側:inside:~
特定0の:particular:ある特定の
概して:typical に:~
	誤った:wrong
生産-:produce:生成
精確:precise:~
勧める:suggest する:~
単語:word:~
命名法:naming scheme:~
一貫する:consistent になる:~
遂行-:perform:~
能:ability:機能
通常通り:as normal に:通常どおり
仕方:way:~
用語:term:~
本体:body:~
入子に:nest:入れ子に
開いた:open した:~

読込んだ:load した:読み込んだ
切詰める:clamp する:切り詰める
切詰めら:clamp さ:切り詰めら
	切り詰める:truncate
保全-:preserve:~
決断:decision:~
</script>

<!--%他の語
~~特別なdiscriminated
置くplace
惑わすことになる:confusing
決める:decide する:~

前に〜を置く:precede
対応-:correspond:~
	対応付ける:map する:~／correspond
特定: 10＠particular／
可能: 23
唯一の:only:~ 18
意味:mean／meaning 22
~~意味があるit makes sense

同じ:the same
後続: 13
広義: 18
必要: 24
自身: 33
複数: 30
追加: 17
以上: 4
以下: 19
以外: 11
任意: 16
位置: 46
同様: 28
型互換: 19
場合: 259
部分: 9
対応: 117
対応付: 3
方法: how
時点: 10
末尾: 12
末端: 7＠most-derived／
注意: 16
番目: 15
手段:means
一方: 14
一連: 25
一部: 20
併用: 8＠declared with／
先頭: 9
右側: 4＠right-hand side／right
左側: 8＠left-hand side／left
場所: 12
実行: execution／
最大: 4
最小: 7
有無: 6
理由: 7＠reason／because 10
用語例: 2
用途: 6
目的: 6
課題: 11
通常: 6＠regular/Fine/
通常の: normal な:~
通常のようにnormally
類似: 6
他方: 8
両者: 7
両方: 2
両方同時: 1
以上: 13
個数: 17

リンク:link:~
グラム: 1
一例: 2
一定: 3
一時的: 1
一環: 1＠as part of
一種: 1
一般: 3

丁度:just 1
上述: 2
上限: 1
下位手続: 1
下位~節: 2＠sub-section
下端: 1
不可欠: 1
不定: 1＠indeterminate
不要: 2
不都合: 1
中心: 1
中止: 1
主体: 1
主要: 1

互換: 1
今度: 1
付与: 2
代入: 1
代用対: 1
以前: 2
仮想: 1

何故: 1
余分: 5
併合:mixed 1
使用中:in use 1
~~例外: 1
供給: 1
依然: 3
便宜: 1＠convenience

個
個別: 1
候補: 1＠possible
側面: 1
入力: 3
全体: 3
通例usually／usual
通例の:
具体的な:concrete:~
内部: 1
冒頭: 1
出自に: 1＠originate
分類: 2＠
別途: 1
前回: 1
前段: 1
前述: 2
前項: 1
動作: 4
区切: 3
区別: 1
十分: 2
午前零時:1＠midnight
~~唯一の:sole:~
即時: 1＠immediately
原文: 4
参照: 2
参照文献: 1
参考例: 1
可視: 1＠visible
各下位~節: 1
各発行: 1
各種: 3
各節: 1
各項: 4
合間: 3
同一: 1
同一性: 1
同時: 2
向上: 1
周囲: 1
問題: 3
回数: 1
図式:diagram 1
基底: 1
基準: 1
基礎的: 1
場合分: 2
増補: 1＠grow
大小:case:~
大文字:uppercase letter:~
小文字:lowercase letter／lowercase:~
変形: 1

変異:mutation/mutating 2
多少: 1
多重~継承:multiple 〜1
姓名: 1＠names
委譲-: 1＠delegated
定義: 3
定訳: 1
実現: 1
走らせ:run し:~
走らせている:running 1
実行制御: 1
実行結果: 1
容易: 2
~~寄与: 2＠adhere／contributing
対訳: 2
対象: 3
導入: 3
左右: 1
平文: 1
広範囲:wide 1
強調: 1
後者: 4
前者: 2
復号: 1＠decoding
復活: 1＠Added back
必須化:Require 1
応答: 1＠responding
意味合: 1
意図的: 1＠deliberate
感謝: 1
成立-:be true 3
手法: 1
把握: 1＠unaware
セキュリティに抵触:insecure 1
括弧対: 1
挿入-:insert 1
操作-:manipulate
操作:manipulating／manipulation
支持: 1
数値: 1
数字: 1
数的: 1＠numerical
整列: 1
文法片: 1
文献: 2
既存: 1
既知: 1
日間: 1
昇順: 2
降順: 1
明白: 1
明確には:Specifically 1
時間: 1＠time:~
時間切: 1＠timed out
時間差: 1＠amount of time:~
最上層: 1＠top-most 1
最低: 2＠lowest
最新の:latest
最終的: 3
最良: 1
最長: 2＠longest
有用: 1
未知: 1
条件: 4
検出: 1
極力避: 1
~~概念: 1＠notion:~ 1
概略的: 1＠Informally
構成-:2＠comprise:~ 2
次項: 3
段落: 1
段階: 1
比較: 1
混同:＠looking like 1
熟慮: 1＠deliberate
片方: 1
独自: 2
生成: 1
用例: 2
申請: 1
留意: 1＠Remember
知識:knowledge:~
番号: 1
発行: 1
直後: 4
相互: 1
相違: 1
矩形: 1＠rectangle
確認: 1＠checked to ensure
程度: 1
種別: 2
等距離: 4＠equally close
算出方法: 1
算出結果: 1
~~精度:precision:~
~~精度:accuracy
近く:closely
終了:end 3
終始:consistently:~
維持: 1
総称: 2
編集: 2
編集者: 3＠editor
編集者草案: 1＠editor’s draft
考慮:considering／considered 2
~~自動的: 1
英単語: 1
英字: 1
行番号: 1
表出: 1
表記: 1
表記規約:typographic convention:~
規範的: 1
草案:draft:~
表現力:expressiveness:~
補助: 2
補数: 1
見受: 1
見通: 1
解消: 1
取り組-:address
言及: 4
記述例:example 1
訳者: 1
該当: 2
誘発: 1＠cause
調整: 3＠tweaked
調整を通すcoordinate
謝意: 1
謝辞: 1
因る: due to
起点: 1＠epoch
過去: 1
適当: 1
遭遇-:encounter 1
選択-:choose 1
重複:duplicates 1
開始:start
開発時:during the development 1
関係: 1
関係無: 1
関連の:relevant
防止: 2
集約: 1
非公式: 1
項目: 3
頭部: 2
有意でない:no significance
~~終端end
~null
２の補数two’s complement
予測し得ない unpredictable
細心の注意を払う必要があるExtreme care must be taken
孕まれる問題~problematic
見つけ易くするhelp 〜 look for

~~入力にとる~take
~~入力のincoming
順繰りに挙げloop through


object 指向: 2
グラム／単位
米／肉／麺／魚／その他:rice／sandwich／noodles／dumplings／other
~~役割を担う:serve 1
担当グループ:group responsible for work 1
ミリ秒数:number of milliseconds
個
素のbare
ふるまう:behave する
見出され:found
単に:simply
節:section:~
listed in 〜／
表す:denote 2
休みunavailable to do so
関わらない部分:agnostic
含む:include
~call元:caller
指す:refer
指す:address
strict mode
-->



<!--%links dfn -->
<script type="text/plain" id="_link_map">
Unicode ~scalar値~列に変換-:#dfn-obtain-unicode
	ECMAScript 値へ変換される:#dfn-convert-idl-to-ecmascript-value
	IDL 値へ変換される:#dfn-convert-ecmascript-to-idl-value
IDL 片:#dfn-idl-fragment
~class文字列:#dfn-class-string

引数をとらない:#dfn-xattr-no-arguments
引数~listを引数にとる:#dfn-xattr-argument-list
有名~引数~list:#dfn-xattr-named-argument-list
有名~引数~listを引数にとる:#dfn-xattr-named-argument-list
識別子~listを引数にとる:#dfn-xattr-identifier-list
識別子を引数にとる:#dfn-xattr-identifier
型の~pairを引数にとる:#dfn-xattr-type-pair

配列~index~prop名:#dfn-array-index-property-name
属性:#dfn-attribute
属性~取得子:#dfn-attribute-getter
属性~設定子:#dfn-attribute-setter
呼戻 this 値:#dfn-callback-this-value
呼戻~文脈:#dfn-callback-context
呼戻~関数:#dfn-callback-function
呼戻~ifc:#dfn-callback-interface
変化-:#dfn-change-global-environment
符号単位:#dfn-code-unit
適合 ECMAScript 実装:#dfn-conforming-ecmascript-implementation
適合 IDL 片の集合:#dfn-conforming-set-of-idl-fragments
適合~実装:#dfn-conforming-implementation
帰結~ifc:#dfn-consequential-interfaces
広義~帰結~ifc:#dfn-consequential0
定数:#dfn-constant
定義:#dfn-definition
既定~値:#dfn-optional-argument-default-value
既定の偽装不可 valueOf 関数:#dfn-default-unforgeable-valueOf-function
削除子:#dfn-deleter
辞書:#dfn-dictionary
辞書~構築子:#dfn-dictionary-constructor
辞書~mb:#dfn-dictionary-member
必須~辞書~mb:#dfn-required-dictionary-member
判別可能:#dfn-distinguishable
判別引数~index:#dfn-distinguishing-argument-index
有効~多重定義~集合:#dfn-effective-overload-set
関数類:#dfn-function-like
列挙:#dfn-enumeration
列挙~値:#dfn-enumeration-value
公開する:#dfn-expose
公開され:#dfn-exposed

例外:#dfn-exception
作成-:#dfn-create-exception
作成する:#dfn-create-exception
単純例外:#dfn-simple-exception
~message:#dfn-exception-message
~error名:#dfn-exception-error-name
~error名~一覧:#dfn-error-names-table
投出:#dfn-throw
投出する:#dfn-throw
投出された例外:#dfn-exception-thrown
DOMException:#dfn-DOMException
DOMException 構築子~obj:#dfn-DOMException-constructor-object
DOMException 原型~obj:#dfn-DOMException-prototype-object

平坦化~mb型:#dfn-flattened-union-member-types
関数~obj:#dfn-function-object
取得子:#dfn-getter
取得子を継承-:#dfn-inherit-getter
大域~名:#dfn-global-name
識別子:#dfn-identifier
~ifc:#dfn-interface
~ifc~mb:#dfn-interface-member
~ifc~obj:#dfn-interface-object
~ifc原型~obj:#dfn-interface-prototype-object
~implements_st:#dfn-implements-statement

継承-:#dfn-inherit
被継承~ifc:#dfn-inherited-interfaces
被継承~辞書:#dfn-inherited-dictionaries
初期~obj:#dfn-initial-object
凍結~配列を作成-:#dfn-create-frozen-array
可反復:#dfn-iterable
可反復~宣言:#dfn-iterable-declaration
反復子~原型~obj:#dfn-iterator-prototype-object
反復される値:#dfn-values-to-iterate-over
反復される値~pair:#dfn-value-pairs-to-iterate-over

値~反復子:#dfn-value-iterator
~pair反復子:#dfn-pair-iterator
既定の反復子~obj:#dfn-default-iterator-object
旧来呼出子:#dfn-legacy-caller
~map~entry:#dfn-map-entries
~map~key型:#dfn-map-key-type
~map~size取得子:#dfn-map-size-getter
~map~value型:#dfn-map-value-type
~set~entry:#dfn-set-entries
~set~size取得子:#dfn-set-size-getter
~maplike:#dfn-maplike
~maplike 宣言:#dfn-maplike-declaration
~setlike:#dfn-setlike
~setlike 宣言:#dfn-setlike-declaration

有index~prop取得子:#dfn-indexed-property-getter
有index~prop設定子:#dfn-indexed-property-setter
有index~propを~supportする:#dfn-support-indexed-properties
有index~propを~support:#dfn-support-indexed-properties
有index~prop設定子を呼出す:#dfn-invoke-indexed-setter
有index~propの値を決定する:#dfn-determine-the-value-of-an-indexed-property
	既存の有index~propを削除する:#dfn-delete-an-existing-indexed-property
既存の有index~propを設定する:#dfn-set-the-value-of-an-existing-indexed-property
新たな有index~propを設定する:#dfn-set-the-value-of-a-new-indexed-property

有名~prop~obj:#dfn-named-properties-object
有名~prop削除子:#dfn-named-property-deleter
有名~prop取得子:#dfn-named-property-getter
有名~prop設定子:#dfn-named-property-setter
有名~propの可視性判定~algo:#dfn-named-property-visibility
有名~propを~supportする:#dfn-support-named-properties

有名~prop設定子を呼出す:#dfn-invoke-named-setter
有名~propの値を決定する:#dfn-determine-the-value-of-a-named-property
既存の有名~propを削除する:#dfn-delete-an-existing-named-property
既存の有名~propを設定する:#dfn-set-the-value-of-an-existing-named-property
新たな有名~propを設定する:#dfn-set-the-value-of-a-new-named-property

有名~構築子:#dfn-named-constructor
有名~定義:#dfn-named-definition

演算:#dfn-operation
省略可否 値:#dfn-optionality-value
随意~引数:#dfn-optional-argument
多重定義:#dfn-overloaded
多重定義~解決~algo:#dfn-overload-resolution-algorithm
部分的~辞書~定義:#dfn-partial-dictionary
部分的~ifc定義:#dfn-partial-interface
部分的~ifc:#dfn-partial-interface
~platform~obj:#dfn-platform-object

主~大域~ifc:#dfn-primary-global-interface
主~ifc:#dfn-primary-interface
~promiseが決着したときの手続きを遂行する:#dfn-perform-steps-once-promise-is-settled
読専:#dfn-read-only
読み取り専用:#dfn-read-only
	読専~a:#dfn-read-only-array
正則~属性:#dfn-regular-attribute
正則~演算:#dfn-regular-operation
保安検査を遂行する:#dfn-perform-a-security-check
直列化可能な型:#dfn-serializable-type
直列化~pattern:#dfn-serialization-pattern
直列化の挙動:#dfn-serialization-behavior
直列化ed値:#dfn-serialized-value
直列化ed値から ECMAScript 値に変換-:#dfn-convert-serialized-value-to-ecmascript-value
直列化ed値に変換-:#dfn-convert-to-serialized-value
直列化子:#dfn-serializer
設定子:#dfn-setter
特殊~keyword:#dfn-special-keyword
特殊~演算:#dfn-special-operation
値の~listを反復する:#dfn-iterate-a-list-of-values
静的~属性:#dfn-static-attribute
静的~演算:#dfn-static-operation
文字列化子:#dfn-stringifier
文字列化の挙動:#dfn-stringification-behavior
追補~ifc:#dfn-supplemental-interface
被support~prop~index:#dfn-supported-property-indices
被support~prop名:#dfn-supported-property-names
~target~obj:#dfn-iterator-target-object

~typedef:#dfn-typedef
型~名:#dfn-type-name
偽装不可:#dfn-unforgeable-on-an-interface
偽装不可~prop名:#dfn-unforgeable-property-name
利用者~obj:#dfn-user-object
可変個の引数をとる:#dfn-variadic
可変個~引数:#dfn-variadic-argument
末尾~引数:#dfn-variadic-argument
拡張属性:#dfn-extended-attribute
予約済み識別子:#dfn-reserved-identifier
単一~演算~呼戻~ifc:#dfn-single-operation-callback-interface
在する:#dfn-present
不在:#dfn-present

	未初期化:#dfn-uninitialized-iterator-state
現在の大域環境:#dfn-current-global-environment
用語例:#dfn-example-term

~map要素を追加する:#dfn-add-map-elements-from-iterable
公開~集合:#dfn-exposure-set

参照／複製を取得-:#dfn-get-buffer-source-reference
	dfn-get-buffer-source-copy
切離す:#dfn-detach
切離された:#dfn-detach
内的~map~objへ転送する:#dfn-forwards-to-the-internal-map-object
内的~set~objへ転送する:#dfn-forwards-to-the-internal-set-object

通例の場所に存在する:#dfn-normal-location
定数~tok:#dfn-const-tokens
	配列の要素~型:#dfn-element-type
	連列の要素~型:#dfn-element-type

~secure文脈~下に限り可用:#dfn-available-only-in-secure-contexts
~secure文脈:https://w3c.github.io/webappsec-secure-contexts/#secure-context
呼出可能:~ES6#sec-iscallable
配列~反復子~obj:~ES6#sec-array-iterator-objects

例外~型:#dfn-exception-type
~nullable~mb型の個数:#dfn-number-of-nullable-member-types
~nullable型:#dfn-nullable-type
~nullable:#dfn-nullable-type
~nullable型を内包する:#dfn-includes-a-nullable-type
内部型:#dfn-inner-type
整数~型:#dfn-integer-type
~buffer~source型:#dfn-buffer-source-type
有型~配列~型:#dfn-typed-array-type
~mb型:#dfn-union-member-type
実数~型:#dfn-numeric-type
文字列~型:#dfn-string-type
~primitive型:#dfn-primitive-type
返値型:#dfn-return-type
型:#idl-types
固有型:#dfn-specific-type
共用体~型:#idl-union
~共用体~型:#dfn-union-type
呼戻~関数~型:#idl-callback-function
~ifc型:#idl-interface
連列~型:#idl-sequence
辞書~型:#idl-dictionary
列挙~型:#idl-enumeration
凍結~配列~型:#idl-frozen-array
~凍結~配列~型:#dfn-frozen-array-type
~obj型:#idl-object
~obj~型:#dfn-object-type
~promise型:#idl-promise
~promise~型:#dfn-promise-type

有index~prop:#idl-indexed-properties
有名~prop:#idl-named-properties

連列~値を作成-:#create-sequence-from-iterable
凍結~配列~値を作成-#create-frozen-array-from-iterable
関連する設定群~obj:~WAPI#relevant-settings-object
abrupt completion:~ES6#sec-completion-record-specification-type
	＊中途完了
Assert:~ES6#sec-algorithm-conventions
~REJECT:#Reject
Unicode ~scalar値:http://www.unicode.org/glossary/#unicode_scalar_value


</script>

<!--%links他 -->
<!-- 

	ToBoolean
	ToNumber
	ToUint16
	ToInt32
	ToUint32
	ToString
	ToObject
	IsCallable:iscallable
	IsAccessorDescriptor:isaccessordescriptor
	IsDataDescriptor:isdatadescriptor
	DetachArrayBuffer:detacharraybuffer
	IsDetachedBuffer:isdetachedbuffer
	GetIterator
	IteratorStep
	IteratorValue
	NormalCompletion
	ReturnIfAbrupt
	＊CheckIterable
	GetMethod
	CreateMapIterator
	CreateSetIterator
	CreateIterResultObject
	IsConstructor
	Construct
	DefinePropertyOrThrow
	ArrayCreate
	CreateDataProperty
	Get:get-o-p
	SetIntegrityLevel
-->

<script type="text/plain" id="_ext_map">
	●補完
	active 関数~obj:~ES6#sec-execution-contexts
	<a href="~ES6#sec-function-environment-records">`NewTarget^es</a>
	●
Type:<a class="abstract" href="~ES6#sec-ecmascript-data-types-and-values">Type</a>
Get:<a class="abstract" href="~ES6#sec-get-o-p">Get</a>

FunctionPrototype:<a href="~ES6#sec-well-known-intrinsic-objects">%FunctionPrototype%</a>
ObjProto_toString:<a href="~ES6#sec-well-known-intrinsic-objects">%ObjProto_toString%</a>
ObjectPrototype:<a href="~ES6#sec-well-known-intrinsic-objects">%ObjectPrototype%</a>
ArrayPrototype:<a href="~ES6#sec-well-known-intrinsic-objects">%ArrayPrototype%</a>
ErrorPrototype:<a href="~ES6#sec-well-known-intrinsic-objects">%ErrorPrototype%</a>
Error:<a href="~ES6#sec-well-known-intrinsic-objects">%Error%</a>
Promise:<a href="~ES6#sec-well-known-intrinsic-objects">%Promise%</a>
ArrayProto_values:<a href="~ES6#sec-well-known-intrinsic-objects">%ArrayProto_values%</a>
IteratorPrototype:<a href="~ES6#sec-well-known-intrinsic-objects">%IteratorPrototype%</a>

Promise_resolve:%Promise_resolve%

NumericLiteral:<a href="~ES6#sec-literals-numeric-literals"><em>NumericLiteral</em></a>

iterator_symbol:<a href="~ES6#sec-well-known-symbols"><span class="prop">@@iterator</span></a>
unscopables_symbol:<a href="~ES6#sec-well-known-symbols"><span class="prop">@@unscopables</span></a>
toStringTag_symbol:<a href="~ES6#sec-well-known-symbols"><span class="prop">@@toStringTag</span></a>
internal_slot:<a href="~ES6#sec-object-internal-methods-and-internal-slots">内的~slot</a>
PlatformObjectGetOwnProperty:<a href="#getownproperty-guts"><span class="prop">PlatformObjectGetOwnProperty</span></a>


MISSING:特殊~値 <i class="const">missing</i> 

promise_T:<a class="idltype" href="#idl-promise">Promise&lt;~varT&gt;</a>
sequence_T:<a class="idltype" href="#idl-sequence">sequence&lt;~varT&gt;</a>
FrozenArray_T:<a class="idltype" href="#idl-frozen-array">FrozenArray&lt;~varT&gt;</a>

toIDL:<a href="#dfn-convert-ecmascript-to-idl-value">変換-</a>
toES:<a href="#dfn-convert-idl-to-ecmascript-value">変換-</a>
辞書継承:<a href="#dfn-inherit-dictionary">継承-</a>
辞書既定値:<a href="#dfn-dictionary-member-default-value">既定~値</a>
直列化値toES: <a href="#dfn-convert-serialized-value-to-ecmascript-value">ECMAScript 値に変換-</a>

ol-callable:<a href="#ol-callable"><var>callable</var></a>
ol-optionality-list:<a href="#ol-optionality-list"><var>省略可否~list</var></a>
ol-type-list:<a href="#ol-type-list"><var>型~list</var></a>

	型互換に絞る:に<a href="#type-compatible">型互換</a>な <var>S</var> の~entryが在る ~THEN 他のすべての~entryを <var>S</var> から除去する
論ML:を要する仕様~策定者は、先に進む前に， <a href="mailto:public-script-coord@w3.org">public-script-coord@w3.org</a> メーリングリストにて論を交わすことを強く勧める
最近数値:最も近い実数~値（２数が等距離にある場合は，<em>仮数が偶数になる</em>方を選ぶ — <a href="#ref-ECMA-262">[ECMA-262]</a> 6.1.6 節, <a href="~ES6#sec-ecmascript-language-types-number-type">The Number Type</a> ）
投出:<a href="#ecmascript-throw" class="dfnref external">投出</a>
	❖HTML = specs/web-apps/current-work/multipage

	＊TODO 更新（参照先の定義は廃止）
incumbent-script:<a href="http://www.whatwg.org/HTML/webappapis.html#incumbent-script">~incumbent~script</a>
stack-of-incumbent-script:<a href="http://www.whatwg.org/HTML/webappapis.html">~incumbent~scriptの~stack</a>

	incumbent-settings-object:<a href="http://www.whatwg.org/HTML/webappapis.html#incumbent-settings-object">~incumbent設定群~obj</a>
	stack-of-script-settings-objects:<a href="http://www.whatwg.org/HTML/webappapis.html#stack-of-script-settings-objects">~script設定群~objの~stack</a>


演算:<var>演算</var>
属性:<var>属性</var>
文字列化子:<var>文字列化子</var>
直列化子:<var>直列化子</var>
</script>


<!--%grammar data 

●● は第２版 v2
-->

<script type="text/plain" id="_d-grammar-table">
●Definitions
ExtendedAttributeList Definition Definitions
| ε
●Definition
CallbackOrInterface
| Partial
| Dictionary
| Enum
| Typedef
| ImplementsStatement
●CallbackOrInterface
"callback" CallbackRestOrInterface
| Interface
●CallbackRestOrInterface
CallbackRest
| Interface
●Interface
"interface" identifier Inheritance "{" InterfaceMembers "}" ";"
●Partial
"partial" PartialDefinition
●PartialDefinition
PartialInterface
| PartialDictionary
●PartialInterface
"interface" identifier "{" InterfaceMembers "}" ";"
●InterfaceMembers
ExtendedAttributeList InterfaceMember InterfaceMembers
| ε
●InterfaceMember
Const
| Operation
| Serializer
| Stringifier
| StaticMember
| Iterable
| ReadOnlyMember
| ReadWriteAttribute
| ReadWriteMaplike
| ReadWriteSetlike
●Dictionary
"dictionary" identifier Inheritance "{" DictionaryMembers "}" ";"
●DictionaryMembers
ExtendedAttributeList DictionaryMember DictionaryMembers
| ε
●DictionaryMember
Required Type identifier Default ";"
●Required
"required"
| ε
●PartialDictionary
"dictionary" identifier "{" DictionaryMembers "}" ";"
●Default
"=" DefaultValue
| ε
●DefaultValue
ConstValue
| string
| "[" "]"
●Inheritance
":" identifier
| ε
●Enum
"enum" identifier "{" EnumValueList "}" ";"
●EnumValueList
string EnumValueListComma
●EnumValueListComma
"," EnumValueListString
| ε
●EnumValueListString
string EnumValueListComma
| ε
●CallbackRest
identifier "=" ReturnType "(" ArgumentList ")" ";"
●Typedef
"typedef" Type identifier ";"
●ImplementsStatement
identifier "implements" identifier ";"
●Const
"const" ConstType identifier "=" ConstValue ";"
●ConstValue
BooleanLiteral
| FloatLiteral
| integer
| "null"
●BooleanLiteral
"true"
| "false"
●FloatLiteral
float
| "-Infinity"
| "Infinity"
| "NaN"
●●Serializer
"serializer" SerializerRest
●●SerializerRest
OperationRest
| "=" SerializationPattern ";"
| ";"
●●SerializationPattern
"{" SerializationPatternMap "}"
| "[" SerializationPatternList "]"
| identifier
●●SerializationPatternMap
"getter"
| "inherit" Identifiers
| identifier Identifiers
| ε
●●SerializationPatternList
"getter"
| identifier Identifiers
| ε
●●Stringifier
"stringifier" StringifierRest
●●StringifierRest
ReadOnly AttributeRest
| ReturnType OperationRest
| ";"
●●StaticMember
"static" StaticMemberRest
●●StaticMemberRest
ReadOnly AttributeRest
| ReturnType OperationRest
●●ReadOnlyMember
"readonly" ReadOnlyMemberRest
●●ReadOnlyMemberRest
AttributeRest
| ReadWriteMaplike
| ReadWriteSetlike
●●ReadWriteAttribute
"inherit" ReadOnly AttributeRest
| AttributeRest
●●AttributeRest
"attribute" Type AttributeName ";"
●AttributeName
AttributeNameKeyword
| identifier
●AttributeNameKeyword
"required"
●Inherit
"inherit"
| ε
●ReadOnly
"readonly"
| ε
●Operation
ReturnType OperationRest
| SpecialOperation
●●SpecialOperation
Special Specials ReturnType OperationRest
●Specials
Special Specials
| ε
●Special
"getter"
| "setter"
| "deleter"
| "legacycaller"
●OperationRest
OptionalIdentifier "(" ArgumentList ")" ";"
●OptionalIdentifier
identifier
| ε
●ArgumentList
Argument Arguments
| ε
●Arguments
"," Argument Arguments
| ε
●Argument
ExtendedAttributeList OptionalOrRequiredArgument
●OptionalOrRequiredArgument
"optional" Type ArgumentName Default
| Type Ellipsis ArgumentName
●ArgumentName
ArgumentNameKeyword
| identifier
●Ellipsis
"..."
| ε
●●Iterable
"iterable" "<" Type OptionalType ">" ";"
●●OptionalType
"," Type
| ε
●●ReadWriteMaplike
MaplikeRest
●●ReadWriteSetlike
SetlikeRest
●●MaplikeRest
"maplike" "<" Type "," Type ">" ";"
●●SetlikeRest
"setlike" "<" Type ">" ";"
●ExtendedAttributeList
"[" ExtendedAttribute ExtendedAttributes "]"
| ε
●ExtendedAttributes
"," ExtendedAttribute ExtendedAttributes
| ε
●ExtendedAttribute
"(" ExtendedAttributeInner ")" ExtendedAttributeRest
| "[" ExtendedAttributeInner "]" ExtendedAttributeRest
| "{" ExtendedAttributeInner "}" ExtendedAttributeRest
| Other ExtendedAttributeRest
●ExtendedAttributeRest
ExtendedAttribute
| ε
●ExtendedAttributeInner
"(" ExtendedAttributeInner ")" ExtendedAttributeInner
| "[" ExtendedAttributeInner "]" ExtendedAttributeInner
| "{" ExtendedAttributeInner "}" ExtendedAttributeInner
| OtherOrComma ExtendedAttributeInner
| ε
●Other
integer
| float
| identifier
| string
| other
| "-"
| "-Infinity"
| "."
| "..."
| ":"
| ";"
| "<"
| "="
| ">"
| "?"
| "ByteString"
| "DOMString"
| "FrozenArray"
| "Infinity"
| "NaN"
| "RegExp"
| "USVString"
| "any"
| "boolean"
| "byte"
| "double"
| "false"
| "float"
| "long"
| "null"
| "object"
| "octet"
| "or"
| "optional"
| "sequence"
| "short"
| "true"
| "unsigned"
| "void"
| ArgumentNameKeyword
| BufferRelatedType
●ArgumentNameKeyword
"attribute"
| "callback"
| "const"
| "deleter"
| "dictionary"
| "enum"
| "getter"
| "implements"
| "inherit"
| "interface"
| "iterable"
| "legacycaller"
| "maplike"
| "partial"
| "required"
| "serializer"
| "setlike"
| "setter"
| "static"
| "stringifier"
| "typedef"
| "unrestricted"
●OtherOrComma
Other
| ","
●Type
SingleType
| UnionType Null
●SingleType
NonAnyType
| "any"
●UnionType
"(" UnionMemberType "or" UnionMemberType UnionMemberTypes ")"
●UnionMemberType
NonAnyType
| UnionType Null
●UnionMemberTypes
"or" UnionMemberType UnionMemberTypes
| ε
●NonAnyType
PrimitiveType Null
| PromiseType Null
| "ByteString" Null
| "DOMString" Null
| "USVString" Null
| identifier Null
| "sequence" "<" Type ">" Null
| "object" Null
| "RegExp" Null
| "Error" Null
| "DOMException" Null
| BufferRelatedType Null
| "FrozenArray" "<" Type ">" Null
●●BufferRelatedType
"ArrayBuffer"
| "DataView"
| "Int8Array"
| "Int16Array"
| "Int32Array"
| "Uint8Array"
| "Uint16Array"
| "Uint32Array"
| "Uint8ClampedArray"
| "Float32Array"
| "Float64Array"
●ConstType
PrimitiveType Null
| identifier Null
●PrimitiveType
UnsignedIntegerType
| UnrestrictedFloatType
| "boolean"
| "byte"
| "octet"
●UnrestrictedFloatType
"unrestricted" FloatType
| FloatType
●FloatType
"float"
| "double"
●UnsignedIntegerType
"unsigned" IntegerType
| IntegerType
●IntegerType
"short"
| "long" OptionalLong
●OptionalLong
"long"
| ε
●●PromiseType
"Promise" "<" ReturnType ">"
●Null
"?"
| ε
●ReturnType
Type
| "void"
●IdentifierList
identifier Identifiers
●Identifiers
"," identifier Identifiers
| ε
●ExtendedAttributeNoArgs
identifier
●ExtendedAttributeArgList
identifier "(" ArgumentList ")"
●ExtendedAttributeIdent
identifier "=" identifier
●ExtendedAttributeIdentList
identifier "=" "(" IdentifierList ")"
●ExtendedAttributeNamedArgList
identifier "=" identifier "(" ArgumentList ")"

</script>

<script type="text/plain" id="_secno_map">
introduction:1
conventions:1.1
conformance:2
idl:3
idl-names:3.1
idl-interfaces:3.2
idl-constants:3.2.1
idl-attributes:3.2.2
idl-operations:3.2.3
idl-special-operations:3.2.4
idl-legacy-callers:3.2.4.1
idl-stringifiers:3.2.4.2
idl-serializers:3.2.4.3
idl-indexed-properties:3.2.4.4
idl-named-properties:3.2.4.5
idl-static-attributes-and-operations:3.2.5
idl-overloading:3.2.6
idl-iterable:3.2.7
idl-maplike:3.2.8
idl-setlike:3.2.9
idl-dictionaries:3.3
idl-exceptions:3.4
idl-DOMException-error-names:3.4.1
idl-enums:3.5
idl-callback-functions:3.6
idl-typedefs:3.7
idl-implements-statements:3.8
idl-objects:3.9
idl-types:3.10
idl-any:3.10.1
idl-boolean:3.10.2
idl-integers:3.2.3-10
idl-float:3.10.11
idl-unrestricted-float:3.10.12
idl-double:3.10.13
idl-unrestricted-double:3.10.14
idl-DOMString:3.10.15
idl-ByteString:3.10.16
idl-USVString:3.10.17
idl-object:3.10.18
idl-interface:3.10.19
idl-dictionary:3.10.20
idl-enumeration:3.10.21
idl-callback-function:3.10.22
idl-nullable-type:3.10.23
idl-sequence:3.10.24
idl-promise:3.10.25
idl-union:3.10.26
idl-RegExp:3.10.27
idl-Error:3.10.28
idl-DOMException:3.10.29
idl-buffer-source-types:3.10.30
idl-frozen-array:3.10.31
idl-extended-attributes:3.11
ecmascript-binding:4
es-environment:4.1
es-type-mapping:4.2
es-any:4.2.1
es-void:4.2.2
es-boolean:4.2.3
es-integers:4.2.4-11
es-float:4.2.12
es-unrestricted-float:4.2.13
es-double:4.2.14
es-unrestricted-double:4.2.15
es-DOMString:4.2.16
es-ByteString:4.2.17
es-USVString:4.2.18
es-object:4.2.19
es-interface:4.2.20
es-dictionary:4.2.21
es-enumeration:4.2.22
es-callback-function:4.2.23
es-nullable-type:4.2.24
es-sequence:4.2.25
create-sequence-from-iterable:4.2.25.1
es-promise:4.2.26
es-union:4.2.27
es-RegExp:4.2.28
es-Error:4.2.29
es-DOMException:4.2.30
es-buffer-source-types:4.2.31
es-frozen-array:4.2.32
create-frozen-array-from-iterable:4.2.32.1
es-extended-attributes:4.3
Clamp:4.3.1
Constructor:4.3.2
EnforceRange:4.3.3
Exposed:4.3.4
ImplicitThis:4.3.5
Global:4.3.6
LegacyArrayClass:4.3.7
LegacyUnenumerableNamedProperties:4.3.8
LenientThis:4.3.9
NamedConstructor:4.3.10
NewObject:4.3.11
NoInterfaceObject:4.3.12
OverrideBuiltins:4.3.13
PutForwards:4.3.14
Replaceable:4.3.15
SameObject:4.3.16
TreatNonObjectAsNull:4.3.18
TreatNullAs:4.3.19
Unforgeable:4.3.20
Unscopable:4.3.21
es-security:4.4
es-overloads:4.5
es-interfaces:4.6
interface-object:4.6.1
es-interface-call:4.6.1.1
es-interface-hasinstance:4.6.1.2
named-constructors:4.6.2
es-dictionary-constructors:4.6.3
interface-prototype-object:4.6.4
named-properties-object:4.6.5
named-properties-object-getownproperty:4.6.5.1
named-properties-object-defineownproperty:4.6.5.2
named-properties-object-delete:4.6.5.3
es-constants:4.6.6
es-attributes:4.6.7
es-operations:4.6.8
es-stringifier:4.6.8.1
es-serializer:4.6.8.2
es-iterators:4.6.9
es-iterator:4.6.9.1
es-forEach:4.6.9.2
es-iterable:4.6.10
es-iterable-entries:4.6.10.1
es-iterable-keys:4.6.10.2
es-iterable-values:4.6.10.3
es-default-iterator-object:4.6.10.4
es-iterator-prototype-object:4.6.10.5
es-maplike:4.6.11
es-map-size:4.6.11.1
es-map-entries:4.6.11.2
es-map-keys-values:4.6.11.3
es-map-get-has:4.6.11.4
es-map-clear:4.6.11.5
es-map-delete:4.6.11.6
es-map-set:4.6.11.7
es-setlike:4.6.12
es-set-size:4.6.12.1
es-set-values:4.6.12.2
es-set-entries-keys:4.6.12.3
es-set-has:4.6.12.4
es-add-delete:4.6.12.5
es-set-clear:4.6.12.6
initializing-objects-from-iterables:4.6.13
es-implements-statements:4.7
es-platform-objects:4.8
indexed-and-named-properties:4.8.1
getownproperty-guts:4.8.2
getownproperty:4.8.3
invoking-indexed-setter:4.8.4
invoking-named-setter:4.8.5
platformobjectset:4.8.6
defineownproperty:4.8.7
delete:4.8.8
call:4.8.9
property-enumeration:4.8.10
es-user-objects:4.9
es-invoking-callback-functions:4.10
es-exceptions:4.11
es-DOMException-constructor-object:4.11.1
es-DOMException-call:4.11.1.1
es-DOMException-prototype-object:4.11.2
es-exception-objects:4.12
es-creating-throwing-exceptions:4.13
es-handling-exceptions:4.14
common:5
common-ArrayBufferView:5.1
common-BufferSource:5.2
common-DOMTimeStamp:5.3
common-Function:5.4
common-VoidFunction:5.5
extensibility:6
referencing:7
acknowledgements:8
idl-grammar:A
references:B
normative-references:B.1
informative-references:B.2
changes:C
</script>

<!-- 

var map = {}
var data = [];

source_data.html.replace(/<[^>]*>|\s+|\w+|[\u4E00-\u9FFF]+|[\u30A1-\u30FC]+|[\u3041-\u3094]+|([^<\s\w\u4E00-\u9FFF\u30A1-\u30FC\u3041-\u3094]+)/g, function(key, t){
//	if(!t) return '';
	if(! (key in map)){
		map[key] = 1;
		data.push(key)
	}
	return '';
});
Util.dump(data);
throw data.length;
-->

<!--%style -->
<style>

code {
	color: #aa2300; /* #ff4500; 変更 */
}

.sym,
code,
.input,
.xattr,
.sym,
dl.grammar > dd,
table.grammar td {
  font-family: monospace0, monospace;
}

*[lang="en"] {
	white-space: pre-line;
}


/* 拡張属性 */
.xattr {
	color: purple; /* 追加 */
}

/* 生成文法記号 */
.sym {
}

/* IDL, ECMAScript 型／値 */

.idltype, .idlvalue, .esvalue, .estype, .esmember {
	font-weight: bold;
	font-family: sans-serif0, sans-serif;
}

.idlmember {
	font-weight: bold;
	font-family: monospace0, monospace;
}

.idltype, .idlvalue, .idlmember {
	color: #017;
}

.esvalue, .estype, .esmember {
	color: #061;
}

/* ECMAScript プロパティ記述子 */
.descriptor {
	color: #061;
}

/* ECMAScript 内部プロパティ */
.prop {
	color: #061;
}

.char { font-size: 85% }

/* 仮想の定数 */
i.const {
	text-decoration: underline;
}

/* 定義語彙参照 */
.dfnref {
}

/* IDL 構文の参考例 */
pre.syntax {
	background: #ddffdd;
	padding: 1em;
	margin: 1em 2em;
	font-weight: bold;
}

/* IDL 構文 */
pre.syntax em, pre.syntax i { font-weight: normal; }
pre.syntax em { color: red }

/* コードブロック */
div.block {
  border: 1px solid #90b8de;
  border-left: 3px double #90b8de;
  border-left: none;
  border-right: none;
  background: #f0f6ff;
/*  margin: 2em;
  margin-top: 1em;
  margin-bottom: 1em; */
  margin: 1em;
  padding: 0 0.5em;
  padding-bottom: 0.5em;
}
	/* コードブロック内タイトル */
.blockTitle {
  position: relative;
  top: -0.75em;
  left: -1.5em;
  /*border: 1px solid #90b8de;
  border-left: none;
  border-right: none;*/
  background: #90b8de;
  color: white;
  padding: 0.25em 1em 0.25em 1em;
  font-weight: bold;
  font-size: 80%;
}
	/* コードブロック本体 */
pre.idl-code,
pre.es-code,
pre.html-code {
/*	font-size: 14px !important; */

  padding: 0 1em;
  margin: 0;
  margin-bottom: 1em;
}
	/* コードブロック内コメント */
pre > span {
	color: #005a9c;
	font-family: serif0, serif;
}

/* 注記, 例, 警告, 課題 */

.example, .note, .warning, .ednote {
  background: #d9e8ff;
  border-top: 3px solid #005a9c;
  border-bottom: 3px solid #005a9c;
  margin: 1em 2em;
  padding: 0 1em 0.5em 1em;
}

.warning {
  border-color: rgb(255, 20, 147);
  background: rgb(255, 228, 225);
}

.ednote {
  border-color: red;
  background: rgb(255, 228, 225);
}
	/* "注記", "例", "警告" */
.header {
	font-weight: bold;
	display: block;
	padding-top: 0.5em;
}

.example blockquote {
  background: #f0f6ff;
}

/* 引用例 */
blockquote {
  padding: 1px 1em;
  margin-left: 2em;
  margin-right: 2em;
}

/* 文法 */
dl.grammar {
	background: #eee;
}
dl.grammar > dt {
	font-weight: normal;
}
dl.grammar > dd {
	position: relative;
	margin-left: 10em;
	white-space: pre-line;
}

dl.grammar > dd::before {
	content: "→";
	position:absolute;
	left: -2em;
	font-family: serif;
}

/* 抽象演算 */
a.abstract {
	color: green;
}


	/* 終端記号 */
#terminals > dd {
	margin-left: 4em;
}

#terminals > dt::after {
	content: " =";
}
#terminals > dd.regex::before,
#terminals > dd.regex::after {
	position:static;
	content: "/";
	color: orangered;
}

/* class="vert" */
table.vert {
  border: 1px solid white;
  border-top: 2px solid #005a9c;
  border-bottom: 2px solid #005a9c;
  margin: 1em auto;
  background: none;
  font-size: 90%;
}

table.vert th, table.vert td {
  padding: 0.25em 0.75em;
  min-width: 6em;
}

table.vert thead {
  background: #d9e8ff;
  border-bottom: 2px solid #005a9c;
}

table.vert tbody {
  background: #f0f6ff;
}

/* アルゴリズム */

ol.algorithm ol {
  border-left: 1px solid #90b8de;
  margin-left: 1em;
}

dd > :first-child {
  margin-top: 0;
}


/* 判別表, #matrix-integers */

.matrix {
	margin-left: auto;
	margin-right: auto;
}

.matrix > thead > tr > th {
	vertical-align: top;
	text-align: center;
}

.matrix th {
	background: #d9e8ff;
	white-space: nowrap;
}

.matrix td, .matrix th {
	border: 1px solid #90b8de;
	padding: 4px;
}

.matrix td {
	text-align: center;
	background: #f0f6ff;
}

.matrix td[colspan] {
	background: #ddd;
}


a.placeholder {
  color: #00e;
}

/* 集合 */
div.set {
  margin-left: 3em;
  margin-bottom: 1em;
  text-indent: -1em;
}

#_algo_symbols th {
	font-weight: normal;
}

/* 第２版 */
.v2 {
	outline: solid red 1px;
}

/* Level 2 */
.L2 {
	background: #FEE;
}


/* 整数型 */
#matrix-integers th {
	min-width: 4em;
}

#matrix-integers > tbody > tr > th:first-child {
	text-align: right;
}



/* 判別表 */

#distinguishable-table {
	font-size: 80%;
	margin-left: -4em;
}

#distinguishable-table tbody > tr > th:first-child {
	text-align: right;
}

#distinguishable-table tbody > tr > th:last-child {
	text-align: left;
}


@supports (transform: rotate(-45deg)) or (-webkit-transform: rotate(-45deg)) {
	#distinguishable-table {
		font-size: 100%;
	}
	#distinguishable-table thead > tr > th {
		padding-top: 4em;
		border: none;
		background: none;
		min-width: 2em;
		max-width: 2em;
		overflow: visible;
	}

	#distinguishable-table thead > tr > th > span {
		margin-left: 0.5em;
		line-height: 1em;
		white-space: nowrap;
		text-decoration: underline;
		display: block;
		-webkit-transform: rotate(-40deg);
		-webkit-transform-origin: 0% 0%;
		transform: rotate(-40deg);
		transform-origin: 20% 0%;
	}
}

</style>
<!-- 
/*
	-webkit-writing-mode:vertical-rl;
	writing-mode:vertical-rl;
*/

 -->


</head>

<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>


<aside class="trans-meta">

<h1>Web IDL (Second Edition) — 日本語訳</h1>

<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a>
により，副題の日付にて<strong >編集者草案</strong>（ Editor's Draft ）として公開された 
<a href="http://heycam.github.io/webidl/">Web IDL</a>
（第２版）を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-04-21</time>
（公開： <time>2012-05-15</time>（第１版）, <time>2013-08-22</time>（第２版））
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<div><a href="http://www.w3.org/" id="_W3C">W3C</a></div>

<h1 title="Web IDL (Second Edition)">Web IDL 第２版</h1>
<h2><em>2016 年 4 月 20 日付</em> W3C 編集者草案</h2>

<dl id="_versions">
	<dt title="This Version:">このバージョン</dt>
	<dd>http://heycam.github.io/webidl/</dd>

	<dt title="Latest Version:">最新発行バージョン</dt>
	<dd>http://www.w3.org/TR/WebIDL-1/</dd>

	<dt>第１版</dt>
	<dd>http://www.w3.org/TR/WebIDL/</dd>

	<dt title="Previous Versions:">以前のバージョン</dt>
	<dd>http://www.w3.org/TR/2012/CR-WebIDL-20120419/</dd>
	<dd>http://www.w3.org/TR/2012/WD-WebIDL-20120207/</dd>
	<dd>http://www.w3.org/TR/2011/WD-WebIDL-20110927/</dd>
	<dd>http://www.w3.org/TR/2011/WD-WebIDL-20110712/</dd>
	<dd>http://www.w3.org/TR/2010/WD-WebIDL-20101021/</dd>
	<dd>http://www.w3.org/TR/2008/WD-WebIDL-20081219/</dd>
	<dd>http://www.w3.org/TR/2008/WD-WebIDL-20080829/</dd>
	<dd>http://www.w3.org/TR/2008/WD-DOM-Bindings-20080410/</dd>
	<dd>http://www.w3.org/TR/2007/WD-DOM-Bindings-20071017/</dd>

	<dt title="Participate:">Participate:</dt>
	<dd>
Send feedback to
<a href="mailto:public-script-coord@w3.org">public-script-coord@w3.org</a>
(<a href="http://lists.w3.org/Archives/Public/public-script-coord/" >archive</a>)
or
<a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?product=WebAppsWG&amp;component=WebIDL">file a bug</a>
(<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WebAppsWG&amp;component=WebIDL&amp;resolution=---">open bugs</a>)
	<dd>

	</dd>
	<dt title="Editor:">編集</dt>
	<dd><a href="http://mcc.id.au/">Cameron McCormack</a>, Mozilla Corporation &lt;cam@mcc.id.au&gt;</dd>
	<dd>Boris Zbarsky, Mozilla Corporation &lt;bzbarsky@mit.edu&gt;</dd>
</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016
<a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
<a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
<a href="http://www.keio.ac.jp/">Keio</a>,
<a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
<a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a>
rules apply.
</small>
	</header>

	<hr>

	<section>
<h2 title="Abstract">要約</h2>

<p>
この文書は、 Web ブラウザへの実装を目的とするインタフェースを記述するためのインタフェース定義言語， Web IDL を定義する。
Web IDL は、 Web プラットフォームにおける, 共通のスクリプト オブジェクトの挙動を，より容易く指定できるようするために、いくつもの特色機能を備えた IDL の変種である。
この文書では、 Web IDL で記述されるインタフェースを, ECMAScript 実行環境の構成子に対応付ける方法についても，詳細に渡り述べられる。
この文書は、［
既に発行済みの仕様，および 新たに発行され, この文書を参照する仕様
］の適合インタフェース実装が，相互運用可能になるための、実装者にとっての指針になるものと期待されている。
<span lang="en">
This document defines an interface definition language, Web IDL, that can be used to describe interfaces that are intended to be implemented in web browsers. Web IDL is an IDL variant with a number of features that allow the behavior of common script objects in the web platform to be specified more readily. How interfaces described with Web IDL correspond to constructs within ECMAScript execution environments is also detailed in this document. It is expected that this document acts as a guide to implementors of already-published specifications, and that newly published specifications reference this document to ensure conforming implementations of interfaces are interoperable.
</span></p>

<!-- XXX
Things to consider that aren't in ednotes:
* Consistent linking to term definitions.
* Consistent capitalisation and naming of algorithm variables.

Potential V2 features:
* Parameterized interface types, for BlahLists
http://www.w3.org/mid/op.vr2r6waf64w2qv@anne-van-kesterens-macbook-pro.local
...
-->

	</section>
	<section id="sotd">

<h2 title="Status of This Document">この文書の位置付け</h2>

<p>
<em>この節では…</em>
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status">W3C 日本語訳 共通ページ</a>
に委譲
】</span></p>

<p>
この文書は <cite>Web IDL （第２版）</cite>仕様の
2016 年 4 月 20 日付 <b>編集者草案</b>（ Editor’s Draft ）です。
この文書についてコメントがあれば
<a href="mailto:public-script-coord@w3.org">public-script-coord@w3.org</a>（
<a href="http://lists.w3.org/Archives/Public/public-script-coord/">アーカイブ</a>
）宛に送られるよう願います。
<span lang="en">
This document is the 20 April 2016 Editor’s Draft of the Web IDL (Second Edition) specification. Please send comments about this document to public-script-coord@w3.org (archived).
</span></p>

<p class="v2">
これは Web IDL の，第１版 勧告候補から分岐された第２版です。
この第２版には、勧告策定の進行を遅滞させずには第１版に含めれないような，新たな特色機能が含められています。
<span lang="en">
This is the Second Edition of Web IDL, branched off from the Candidate Recommendation of the First Edition. This Second Edition includes new features that could not have been added to the First Edition without delaying its progress along the Recommendation track.
</span></p>

<div class="trans-note" id="_changes-v2">
<p>【
新たな部分のほとんどは、 ECMAScript 6 による新機能に対応するものであり，したがって第１版との下位互換性もほぼ保たれる~~形で策定されているものと見られる。
この訳では、第１版（の 2014 年 10 月 4 日付<!-- 130124 130825 --> 
<a href="http://heycam.github.io/webidl/v1.html">編集者草案</a>
<small>（このリンク先は今や削除されているが）</small>
）との比較で，<strong >第２版に追加された主要な部分</strong>に、上の段落と同じ様に，枠線で囲んだスタイル付けを施している（その部分の定義を参照する 他の細かい場所の語も，第２版にて追加されたものになるが、煩雑さを避けるため，スタイル付けは施されていない。<small >また，ごく一部には更新も混ざっている（その部分を削除すると意味が通らなくなるので，容易に見分けられるであろう）</small>）。

特に、例外オブジェクトに関する記述は，一新されている。
また、少数の用語は第１版から変更されている（
“attribute （属性）” → “regular attribute （正則属性）” ／
“[[Class]]” （ ECMAScript 内部プロパティ） → “@@toStringTag”
）。
その他，文字列に類する型の総称として語 “文字列 型” が導入されている。
また、配列型は 凍結配列型に置き換えられている。
一部の文法記号も第１版から削除, あるいは別の表現に置換されている。
】</p>

<p>【
<a href="http://www.w3.org/TR/WebIDL-1/">最新発行バージョン</a>
（ “Level 1” バージョン）との相違点は：
（その仕様からの引用）
<q>Level 1 バージョンは、メインである編集者草案の一部であって，実装され試験された安定的と見なされている部分を含む。
実装者は、最新の更新を含むこの編集者草案を参照されたし（…以下略）。</q>
<span class="L2">
Level 1 に含まれていない部分は、この訳の中では，この文と同じ色の背景によるスタイル付けを施してある（上述と同様に細部まで施されてはいない）。
</span>
】</p>

</div>

<p>
この文書は W3C
<a href="http://www.w3.org/Interaction/">Interaction Domain</a>
の
<a href="https://www.w3.org/WebPlatform/WG/">Web Platform Working Group</a>
により制作されました。
この文書に加えられた変更は
GitHub のコミットログ：
<a href="https://github.com/heycam/webidl/commits/gh-pages/index.xml">最近の変更点</a>,
<a href="https://github.com/heycam/webidl/commits/gh-pages/Overview.xml">より以前の変更点</a>
から閲覧できます。
<span lang="en">
This document is produced by the Web Platform Working Group in the W3C Interaction Domain. Changes made to this document can be found in the specification’s commit log on GitHub: recent changes, older changes.

This document is produced by the Web Applications Working Group, part of the Rich Web Clients Activity in the W3C Interaction Domain. 
</span></p>

<p>
<!--In addition to the issues marked by editorial notes in this document,-->
この仕様の
<a href="https://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;product=WebAppsWG&amp;component=WebIDL&amp;longdesc_type=allwordssubstr&amp;longdesc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bug_id_type=anyexact&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Reuse%20same%20sort%20as%20last%20time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">bug tracker</a>
もご覧ください。
<span lang="en">
There is a bug tracker for the specification.
</span></p>

	</section>


	<nav class="toc" id="toc">
<h2 title="Table of Contents">目次</h2>
<ol id="_toc_list0"></ol>
<hr />

<ol id="_toc_list1"></ol>
	</nav>

	<main id="MAIN" style="display:none;">
<div id="sections">
	<section id="introduction">
<h2 title="Introduction">1. 序</h2>

~INFORMATIVE

<p>
W3C により発行される技術報告に含められるプログラミング言語~ifcは、概して
Object Management Group による IDL （ Interface Definition Language ）
`OMGIDL$r を利用して記述されていた。
この IDL は、これらの~ifcを，言語~非依存の方式で記述する手段を提供する。
通例，その種の文書には、 IDL で記述された~ifcを［
所与の言語
］の構成子に対応付ける方法について，詳細を述べる、言語束縛についての追加の付録が含められる。
◎
Technical reports published by the W3C that include programming language interfaces have typically been described using the Object Management Group’s Interface Definition Language (IDL) [OMGIDL]. The IDL provides a means to describe these interfaces in a language independent manner. Usually, additional language binding appendices are included in such documents which detail how the interfaces described with the IDL correspond to constructs in the given language.
</p>

<p>
しかしながら、 Web 上で最も共通的に利用されている言語, ECMAScript に対しては、これらの仕様における言語束縛は，終始~低い~~精度で指定されていたため、相互運用性の課題も生じていた。
加えて、それぞれの仕様が同じ基本的な情報を述べなければならない
— 例えば、
IDL で記述される DOM ~ifcが ECMAScript 大域~objの~propに対応していることや,
`unsigned long$T IDL 型が ECMAScript の `Number^t 型に対応付けられることなど。
◎
However, the bindings in these specifications for the language most commonly used on the web, ECMAScript, are consistently specified with low enough precision as to result in interoperability issues. In addition, each specification must describe the same basic information, such as DOM interfaces described in IDL corresponding to properties on the ECMAScript global object, or the unsigned long IDL type mapping to the Number type in ECMAScript.
</p>

<p>
この仕様は、 Web API のための~ifcを定義する仕様で利用できる， OMG IDL に似た IDL 言語を定義する。
この IDL には、以前は注釈文による記述を要していた共通の機能性を~supportするために，いくつもの拡張が加えられた。
加えて、 ECMAScript Edition 6 のための，精確な言語束縛も与えられた。
◎
This specification defines an IDL language similar to OMG IDL for use by specifications that define interfaces for Web APIs. A number of extensions are given to the IDL to support common functionality that previously must have been written in prose. In addition, precise language bindings for ECMAScript Edition 6 are given.
</p>

		<section id="conventions">
<h3 title="Typographic conventions">1.1. 表記規約</h3>


<p>
この文書では、次の表記規約／スタイルが利用される：
◎
The following typographic conventions are used in this document:
</p>

<p class="trans-note">【
“†” が付与されているものは、この訳による追加のスタイル。
】</p>

<ul>
	<li>
用語の定義：
`用語例@
◎
Defining instances of terms: example term
</li>
	<li>
この文書で定義される用語へのリンク：
`用語例$
◎
Links to terms defined in this document: example term
</li>
	<li>
他の文書で定義される用語へのリンク：
<a class="dfnref" href="triple-underscore.github.io/WebIDL-ja.html#dfn-example-term">example term</a>
◎
Links to terms defined in other documents: example term
</li>
	<li>
文法~記号：
`ExampleGrammarSymbol^g
◎
Grammar symbols: ExampleGrammarSymbol
</li>

	<li>
文法の~literal ~keyword／~tok（終端~記号）：
平文の中では `exampleKeyword^c，
IDL 文法片の中では引用符で括って `exampleToken^sym
†
</li>


	<li>
IDL 型：`ExampleIDLType^T,<br>
IDL ~ifc~mb：`ExampleIDLMember^M,<br>
IDL 値：`ExampleIDLValue^V
</li>

	<li>
ECMAScript 型：`ExampleESType^t,<br>
ECMAScript 値：`ExampleESValue^v
◎
IDL and ECMAScript types: ExampleType
</li>

	<li>
ECMAScript 内的［~prop／~meth／~slot］： `ExamplePropertyOrMethodOrSlot^es
†
</li>

	<li>
ECMAScript 抽象演算：
<a class="abstract">ExampleAbstractOperation</a>
†
</li>

<!-- 
ECMAScript ~obj~mb：ExampleESMember^m
-->


	<li>
~code片：
`a = b + obj.f()^c
◎
Code snippets: a = b + obj.f()
</li>
	<li>
Unicode 文字：
`U+0030 DIGIT ZERO ("0")^char
◎
Unicode characters: U+0030 DIGIT ZERO ("0")
</li>
	<li>
拡張属性：
`ExampleExtendedAttribute^x
◎
Extended attributes: [ExampleExtendedAttribute]
</li>
	<li>
注釈文や~algoにおける変数~名：
%exampleVariableName
◎
Variable names in prose and algorithms: exampleVariableName.
</li>

	<li>
文字列~literal：
`example string literal^l
†
</li>
	<li>
モデルを定義するために利用される仮想の定数~値：
`定数~例^C
†
</li>

	<li>
<p>
IDL 構文の参考例：
◎
IDL informal syntax examples:
</p>

<pre class="syntax">
interface `identifier^mk {
  `interface-members…^mk
};
</pre>

<p>
（周囲の注釈文の中で論の対象にされている部分は， mark 要素で`強調される^mk（スタイルはブラウザに依存する）。）
<!-- 
（赤いテキストは、周囲の注釈文の中で論の対象にされている，構文の中の特定の部分の強調に利用される。）
 -->
◎
(Red text is used to highlight specific parts of the syntax discussed in surrounding prose.)
</p>
</li>
	<li>
<p>
IDL 文法~片：
◎
IDL grammar snippets:
</p>

<dl class="grammar">
	<dt><span class="prod-number">[5]</span> `ExampleGrammarSymbol^g</dt>
	<dd>OtherSymbol "sometoken"
| AnotherSymbol
| ε  // <span title="nothing">nothing</span></dd>
</dl>

<p>
（各~文法~規則の左側には参照~用の番号が振られる。）
◎
(Each grammar rule is assigned a number for reference, shown on the left.)
</p>
	</li>

	<li>
<p>
規定でない注記：
◎
Non-normative notes:
</p>

<div class="note"><p>
これは注記。
◎
This is a note.
</p></div>
</li>
	<li>
<p>
規定でない例：
◎
Non-normative examples:
</p>

<div class="example">
<p>
これは例。
◎
This is an example.
</p>
</div>
</li>
	<li>
<p>
規定の警告：
◎
Normative warnings:
</p>
<div class="warning">
<p>
これは警告。
◎
This is a warning.
</p>
</div>
</li>
	<li>
<p>
~code~block：
◎
Code blocks:
</p>

<pre class="idl-code">
// <span title="This is an IDL code block.">これは IDL ~code~block。</span>
interface Example {
  attribute long something;
};
</pre>

<pre class="es-code">
// <span title="This is an ECMAScript code block.">これは ECMAScript ~code~block。</span>
window.onload = function() { window.alert("loaded"); };
</pre>

</li>
</ul>

		</section>
		<section id="_conventions">
<h3 class="trans-note">【日本語訳に特有の表記規約】</h3>

<p>
この第２版にて追加された／変更された主要な部分には、
<span class="v2">このようなスタイル付けを施している</span>
（<a href="#_changes-v2">詳細</a>）。
</p>

<p>
この訳では，アルゴリズムの記述に次の記号を用いる
：
<span class="block">
:= （~~定義）, :← （~~初期化）, ← （~~代入）, ＝, ≠ （~~比較）,<br>
~IF, ~ELSE, ~ELIF, ~WHILE, ~FOR ~EACH (…), ~BREAK, ~CONTINUE, ~RET, ~THROW, ~TRY, ~CATCH, `~REJECT$ （~~実行制御）
</span>
</p>

<p>
これらのうち，次のもの以外の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照。
</p>

<ul>
	<li>
~THROW, ~TRY, ~CATCH, `~REJECT$ は、もっぱら ECMAScript 言語束縛において利用される（定義はリンク先を~~参照）。
</li>

	<li>
<p>
:= は :← と同じ意味に解釈されても不都合は無いが、意味合いは異なる：
</p>

<table id="_algo_symbols" border><tbody>

<tr><th style="min-width:10em;">%var&nbsp;:=&nbsp;%value</th><td>
新たな記号 %var の~~導入とその値の %value による定義を表す（原文 “let var to …” ）。
</td></tr>

<tr><th>%var&nbsp;:←&nbsp;%value</th><td>
新たな変数 %var の~~導入とその値の %value による初期化-を表す（原文 “initialize” ）。
<b>:=</b> との相違は， %var の値が後で変更され得る所<small>（ … のように見受けられるが、原文をそのまま反映しているだけなので，~~例外はあるかもしれない）</small>。
</td></tr>

</tbody></table>
	</li>
</ul>

<p>
この仕様の中の用語の一部は、定訳が無いため，訳者が適当に対訳をあてがっている。
ウィンドウ下端に対訳の切り替え機能がある。
</p>

		</section>
	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>


<p>
図式, 例, 注記, および “参考” と記された節を除く，この仕様のすべては規定である。
◎
Everything in this specification is normative except for diagrams, examples, notes and sections marked as being informative.
</p>

<p>
この文書における~keyword［
“〜~MUST” ＝ MUST ／
“〜しては~MUST_NOT” ＝ MUST_NOT ／
“~REQUIRED” ＝ REQUIRED ／
<!-- 
SHALL
SHALL NOT
 -->
“〜する~SHOULD” ＝ SHOULD ／
“〜する~SHOULD_NOT” ＝ SHOULD NOT ／
“〜しても~MAY” ＝ MAY
<!-- 
RECOMMENDED
OPTIONAL
-->
］は、
<cite><a href="http://tools.ietf.org/html/rfc2119">RFC 文書にて要件の程度を指示するために利用される~keyword</a></cite>
`RFC2119$r 
の記述に則って解釈されるものとする。
◎
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in Key words for use in RFCs to Indicate Requirement Levels [RFC2119].
</p>

<p>
この仕様では、次に挙げる主体が適合性の対象になるものと定義される：
◎
The following conformance classes are defined by this specification:
</p>

<dl>
	<dt>`適合 IDL 片の集合@◎conforming set of IDL fragments</dt>
	<dd>
`IDL 片$の集合は、全体として，この仕様にて IDL 片に適用される［
“〜~MUST_NOT” , “~REQUIRED” <!-- , “〜SHALL”  -->レベルの判定基準
］をすべて満たすとき，`適合 IDL 片の集合$になる。
◎
A set of IDL fragments is considered to be a conforming set of IDL fragments if, taken together, they satisfy all of the MUST-, REQUIRED- and SHALL-level criteria in this specification that apply to IDL fragments.
</dd>

	<dt>`適合~実装@◎conforming implementation</dt>
	<dd>
~UAは、自身が~supportするすべての言語束縛において，この仕様により その実装に適用される，すべての
“〜~MUST_NOT” , “~REQUIRED” <!-- , “〜SHALL”  -->レベルの判定基準を満たすとき，
`適合 IDL 片の集合$に対する`適合~実装$であるとされる。
◎
A user agent is considered to be a conforming implementation relative to a conforming set of IDL fragments if it satisfies all of the MUST-, REQUIRED- and SHALL-level criteria in this specification that apply to implementations for all language bindings that the user agent supports.
</dd>
	<dt>`適合 ECMAScript 実装@◎conforming ECMAScript implementation</dt>
	<dd>
~UAは、この仕様にて ECMAScript 言語束縛の実装に適用されるすべての
“〜~MUST_NOT” , “~REQUIRED” <!-- , “〜SHALL”  -->レベルの判定基準を満たすとき，
`適合 IDL 片の集合$に対する`適合 ECMAScript 実装$であるとされる。
◎
A user agent is considered to be a conforming ECMAScript implementation relative to a conforming set of IDL fragments if it satisfies all of the MUST-, REQUIRED- and SHALL-level criteria in this specification that apply to implementations for the ECMAScript language binding.
</dd>

</dl>
	</section>
	<section id="idl">
<h2 title="Interface definition language">3. ~ifc定義~言語</h2>


<p>
この節では、
Web ~platform API のための~ifcを定義するために利用できる言語，
<em>Web IDL</em> について述べる。
Web API を定義する仕様は、［
その仕様が定義する API のための~ifc（~objが表出し得る状態と挙動）
］を記述する，１つ以上の
`IDL 片@
を含み得る。
`IDL 片$は、文法~記号 `Definitions$g に合致する，定義の並びである。
実装が~supportする `IDL 片$の集合は、順序付けられない。
完全な文法と利用される記法の説明については，
<a href="#idl-grammar">付録 A</a>
を見よ。
◎
This section describes a language, Web IDL, which can be used to define interfaces for APIs in the Web platform. A specification that defines Web APIs can include one or more IDL fragments that describe the interfaces (the state and behavior that objects can exhibit) for the APIs defined by that specification. An IDL fragment is a sequence of definitions that matches the Definitions grammar symbol. The set of IDL fragments that an implementation supports is not ordered. See Appendix A for the complete grammar and an explanation of the notation used.
</p>


<p>
 `IDL 片$に現れ得る
`定義@
には、次の種類がある：
`~ifc$,
`部分的~ifc定義$,
`辞書$,
`部分的~辞書~定義$,
`~typedef$,
`~implements_st$
。
これらはすべて後続の節にて定義される。
◎
The different kinds of definitions that can appear in an IDL fragment are: interfaces, partial interface definitions, dictionaries, partial dictionary definitions, typedefs and implements statements. These are all defined in the following sections.
</p>


<p>
各`定義$（ `Definition$g に合致）の前には、［
`拡張属性$の~list（ `ExtendedAttributeList$g に合致）
］を置くことができる
— それらは、その定義が，言語束縛において どう取扱われるかを制御する。
この仕様が定義する拡張属性の，言語束縛に関わらない部分については
`idl-extended-attributes$sec
にて論じられ、 ECMAScript 言語束縛に特有の部分については
`es-extended-attributes$sec
にて論じられる。
◎
Each definition (matching Definition) can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how the definition will be handled in language bindings. The extended attributes defined by this specification that are language binding agnostic are discussed in section 3.11, while those specific to the ECMAScript language binding are discussed in section 4.3.
</p>


<pre class="syntax">
[`extended-attributes^mk]
interface `identifier^i {
  `interface-members…^i
};
</pre>


<div class="grammar">
-Definitions
-Definition
-CallbackOrInterface
</div>

<div class="example">
<p>
 `IDL 片$の例を示す：
◎
The following is an example of an IDL fragment.
</p>

<pre class="idl-code">
interface Paint { };

interface SolidColor : Paint {
  attribute double red;
  attribute double green;
  attribute double blue;
};

interface Pattern : Paint {
  attribute DOMString imageURL;
};

[Constructor]
interface GraphicalWindow {
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;

  attribute Paint currentPaint;

  void drawRectangle(double x, double y, double width, double height)<!-- 
    raises(GraphicsException)-->;

  void drawText(double x, double y, DOMString text)<!-- 
    raises(GraphicsException)-->;
};
</pre>

<p>
ここでは、４個の`~ifc$が定義されている。
`GraphicalWindow^T ~ifcには、
２個の`読専$ `属性$,
１個の~writableな属性,
２個の`演算$
が定義されている。
`GraphicalWindow^T ~ifcを実装する~objは、
利用されている個別の言語に適切な方式で，これらの属性と演算を公開することになる。
◎
Here, four interfaces are being defined. The GraphicalWindow interface has two read only attributes, one writable attribute, and two operations defined on it. Objects that implement the GraphicalWindow interface will expose these attributes and operations in a manner appropriate to the particular language being used.
</p>

<p>
ECMAScript においては、 IDL ~ifc上の属性／演算は、すべての `GraphicalWindow^T ~objにおいて，その原型~obj上の
~accessor~prop ／ `Function^t 値~data-prop
として，公開されることになる。
`GraphicalWindow^T を実装する各 ECMAScript ~objは、その原型鎖の中にその原型~objを持つことになる。
◎
In ECMAScript, the attributes on the IDL interfaces will be exposed as accessor properties and the operations as Function-valued data properties on a prototype object for all GraphicalWindow objects; each ECMAScript object that implements GraphicalWindow will have that prototype object in its prototype chain.
</p>

<!--JAVA
In Java, there will exist a Java interface that corresponds to the IDL ...
-->

<p>
`GraphicalWindow^T 上に現れる `Constructor$x は`拡張属性$である。
この拡張属性により、 `new GraphicalWindow()^c の~callに対し，この~ifcを実装する新たな~objを返すような構築子が、 ECMAScript 実装に存在することになる。
◎
The [Constructor] that appears on GraphicalWindow is an extended attribute. This extended attribute causes a constructor to exist in ECMAScript implementations, so that calling new GraphicalWindow() would return a new object that implemented the interface.
	<!--JAVA 
The [Constructor] extended attribute has no effect in the Java language binding, however.-->
</p>
</div>

		<section id="idl-names">
<h3 title="Names">3.1. 名前（識別子）</h3>


<p>
どの［
`~ifc$,
`部分的~ifc定義$,
`辞書$,
`部分的~辞書~定義$,
`列挙$,
`呼戻~関数$,
`~typedef$
］も（これらは総称して
`有名~定義@
と呼ばれる）, および
どの［
`定数$,
`属性$,
`辞書~mb$
］も、何らかの`演算$を行うための
`識別子@
を持つ。
識別子はその宣言~内のどこかに位置する `identifier$g ~tokから決定される：
◎
Every interface, partial interface definition, dictionary, partial dictionary definition, enumeration, callback function and typedef (together called named definitions) and every constant, attribute, and dictionary member has an identifier, as do some operations. The identifier is determined by an identifier token somewhere in the declaration:
</p>

<ul>
	<li>
<p>
`有名~定義$に対しては、~keyword：
`interface^c,
`dictionary^c,
`enum^c,
`callback^c
の直後に現れる `identifier$g ~tokがその定義の識別子を決定する。
◎
For named definitions, the identifier token that appears directly after the interface, dictionary, enum or callback keyword determines the identifier of that definition.
</p>

<pre class="syntax">
interface `interface-identifier^mk { `interface-members…^i };
partial interface `interface-identifier^mk { `interface-members…^i };
dictionary `dictionary-identifier^mk { `dictionary-members…^i };
partial dictionary `dictionary-identifier^mk { `dictionary-members…^i };
enum `enumeration-identifier^mk { `enumeration-values…^i };
callback `callback-identifier^mk = `callback-signature^i;
</pre>
	</li>

	<li>
<p>
`属性$,
`~typedef$,
`辞書~mb$
に対しては、宣言の末尾の~semicolonの前に位置する最後の `identifier$g ~tokが識別子を決定する。
◎
For attributes, typedefs and dictionary members, the final identifier token before the semicolon at the end of the declaration determines the identifier.
</p>

<pre class="syntax">
interface `identifier^i {
  attribute `type^i `attribute-identifier^mk;
};

typedef `type^i `typedef-identifier^mk;

dictionary `identifier^i {
  `type^i `dictionary-member-identifier^mk;
};
</pre>

</li>
	<li>
<p>
`定数$に対しては、等号の前に位置する
`identifier$g ~tokが識別子を決定する。
◎
For constants, the identifier token before the equals sign determines the identifier.
</p>

<pre class="syntax">
const `type^i `constant-identifier^mk = `value^i;
</pre>

</li>
	<li>
<p>
`演算$に対しては、返値型の後，かつ左~丸括弧の前に現れる `identifier$g ~tok（ `OperationRest$g の中の文法~記号 `OptionalIdentifier$g の部分として合致）
が、その演算の識別子を決定する。
そのような `identifier$g ~tokが無い場合、その演算は識別子を持たない。
◎
For operations, the identifier token that appears after the return type but before the opening parenthesis (that is, one that is matched as part of the OptionalIdentifier grammar symbol in an OperationRest) determines the identifier of the operation. If there is no such identifier token, then the operation does not have an identifier.
</p>

<pre class="syntax">
`return-type^i `operation-identifier^mk(`arguments…^i);
</pre>

</li>
</ul>

<div class="note"><p>
［
取得子や設定子などの，
<a href="#idl-special-operations">特殊な種類の演算</a>
］を宣言する演算は、識別子を持たないことがある。
◎
Operations can have no identifier when they are being used to declare a special kind of operation, such as a getter or setter.
</p></div>

<p>
これらの構成子のすべてにおいて、
`identifier$g ~tokから先頭の
`U+005F LOW LINE ("_")^char
文字を（もし在れば）除去した値が`識別子$になる。
◎
For all of these constructs, the identifier is the value of the identifier token with any leading U+005F LOW LINE ("_") character (underscore) removed.
</p>

<div class="note"><p>
先頭の
`"_"^char
は、識別子を~escapeして，予約済みの語と見誤られなくするために利用される。
例えば、 `interface^l という名前を持つ~ifcも定義できる。
先頭の
`"_"^char
は識別子の~escapeを外す際に落とされる。
◎
A leading "_" is used to escape an identifier from looking like a reserved word so that, for example, an interface named “interface” can be defined. The leading "_" is dropped to unescape the identifier.
</p></div>

<p>
演算~引数がとり得る識別子は、もう少し広い集合になる。
演算の宣言においては、引数の識別子はその型の直後に指定され、
`identifier$g ~tokか, または `ArgumentNameKeyword$g 記号に合致する~keywordで与えられる。
これらの~keywordのいずれかが利用される場合、先頭の underscore による~escapeは不要である。
◎
Operation arguments can take a slightly wider set of identifiers. In an operation declaration, the identifier of an argument is specified immediately after its type and is given by either an identifier token or by one of the keywords that match the ArgumentNameKeyword symbol. If one of these keywords is used, it need not be escaped with a leading underscore.
</p>

<pre class="syntax">
`return-type^i `operation-identifier^i(`argument-type^i `argument-identifier^mk, …);
</pre>

<div class="grammar">
-ArgumentNameKeyword
</div>

<p>
演算~引数に `identifier$g ~tokが利用された場合、その`識別子$はその~tokから先頭の
`U+005F LOW LINE ("_")^char
文字（ underscore ）を取り除いた値になる。
代わりにいずれかの `ArgumentNameKeyword$g ~keyword~tokが利用された場合、演算~引数の`識別子$は単にその~tokになる。
◎
If an identifier token is used, then the identifier of the operation argument is the value of that token with any leading U+005F LOW LINE ("_") character (underscore) removed. If instead one of the ArgumentNameKeyword keyword token is used, then the identifier of the operation argument is simply that token.
</p>

<p>
上に示されたどの IDL 構成子のどの`識別子$も
`constructor^l, `toString^l, `toJSON^l
になっては~MUST_NOT。
また、文字
`U+005F LOW LINE ("_")^char
から始まっては~MUST_NOT。
これらは
`予約済み識別子@
と呼ばれる。
◎
The identifier of any of the abovementioned IDL constructs MUST NOT be “constructor”, “toString”, “toJSON”, or begin with a U+005F LOW LINE ("_") character. These are known as reserved identifiers.
</p>

<div class="note">

<p>
後の節にて、一部の特定0の構成子に対しては，識別子の名前に更なる制約が課され得る。
◎
Further restrictions on identifier names for particular constructs may be made in later sections.
</p></div>

<p>
所与の実装が~supportする `IDL 片$の集合に属する、どの［
`~ifc$,
`辞書$,
`列挙$,
`呼戻~関数$,
`~typedef$
］の`識別子$も，他のそれと互いに同じになっては~MUST_NOT。
◎
Within the set of IDL fragments that a given implementation supports, the identifier of every interface, dictionary, enumeration, callback function and typedef MUST NOT be the same as the identifier of any other interface, dictionary, enumeration, callback function or typedef.
</p>

<p>
 `IDL 片$の中における`定義$への参照が、参照~先の定義の宣言より後に現れる必要はない。
参照は複数の `IDL 片$をまたがることもできる。
◎
Within an IDL fragment, a reference to a definition need not appear after the declaration of the referenced definition. References can also be made across IDL fragments.
</p>

<div class="example">
<p>
したがって，次の `IDL 片$は妥当である：
◎
Therefore, the following IDL fragment is valid:
</p>

<pre class="idl-code">
interface B : A {
  void f(SequenceOfLongs x);
};

interface A {
};

typedef sequence&lt;long&gt; SequenceOfLongs;
</pre>
</div>


<div class="example">
<p>
`定義$／`~ifc~mb$に，`識別子$を与える例を、次の `IDL 片$に示す：
◎
The following IDL fragment demonstrates how identifiers are given to definitions and interface members.
</p>

<pre class="idl-code">
// <span title="Typedef identifier: &quot;number&quot;"
>~typedef識別子： `number^l</span>
typedef double number;

// <span title="Interface identifier: &quot;System&quot;"
>~ifc識別子： `System^l</span>
interface System {

  // <span title="Operation identifier:          &quot;createObject&quot;"
>演算~識別子： `createObject^l</span>
  // <span title="Operation argument identifier: &quot;interface&quot;"
>演算~引数~識別子： `interface^l</span>
  object createObject(DOMString _interface);

  // <span title="Operation argument identifier: &quot;interface&quot;"
>演算~引数~識別子： `interface^l</span>
  sequence&lt;object&gt; getObjects(DOMString interface);

  // <span title="Operation has no identifier; it declares a getter."
>演算は識別子を持たない。取得子を宣言する。</span>
  getter DOMString (DOMString keyName);
};

// <span title="Interface identifier: &quot;TextField&quot;"
>~ifc識別子： `TextField^l</span>
interface TextField {

  // <span title="Attribute identifier: &quot;const&quot;"
>属性~識別子： `const^l</span>
  attribute boolean _const;

  // <span title="Attribute identifier: &quot;value&quot;"
>属性~識別子： `value^l</span>
  attribute DOMString? _value;
};
</pre>

<p>
`TextField^T `~ifc$
の二番目の`属性$は（ `value^l は IDL 文法の~keywordではないので） underscore で~escapeする必要はないが、属性の`識別子$を得る際には，依然として~escapeは外される。
◎
Note that while the second attribute on the TextField interface need not have been escaped with an underscore (because “value” is not a keyword in the IDL grammar), it is still unescaped to obtain the attribute’s identifier.
</p>
</div>
		</section>
		<section id="idl-interfaces">
<h3 title="Interfaces">3.2. ~ifc</h3>


<p>
 `IDL 片$は~obj指向~systemの記述に利用される。
その種の~systemにおいては、~objは同一性（ identity ）を持つ実体であり，状態と挙動の~encapsulationである。
`~ifc@
とは、その~ifcを実装する~objが公開することになる，何らかの状態や挙動を宣言するための，`定義$（
`Interface$g ／
`callback^sym `Interface$g
いずれかに合致）である。
◎
IDL fragments are used to describe object oriented systems. In such systems, objects are entities that have identity and which are encapsulations of state and behavior. An interface is a definition (matching Interface or "callback" Interface) that declares some state and behavior that an object implementing that interface will expose.
</p>

<pre class="syntax">
interface `identifier^i {
  `interface-members…^i
};
</pre>

<p>
~ifcは、~ifc宣言の波括弧の合間に現れる，一連の
`~ifc~mb@
— `定数$, `属性$, `演算$, その他の宣言 —
が成す集合（ `InterfaceMembers$g に合致）の仕様である。
属性は，その~ifcを実装する~objが公開することになる状態を記述し、演算は，~obj上で呼出せる挙動を記述する。
定数は，~system内の~objの利用者の便宜のために公開される，有名~定数~値を宣言する。
◎
An interface is a specification of a set of interface members (matching InterfaceMembers), which are the constants, attributes, operations and other declarations that appear between the braces in the interface declaration. Attributes describe the state that an object implementing the interface will expose, and operations describe the behaviors that can be invoked on the object. Constants declare named constant values that are exposed as a convenience to users of objects in the system.
</p>

<p>
Web IDL の~ifcは，その~ifcを実装する~objがどのように挙動するかを記述する。
~obj指向~言語のための言語束縛においては、個々の IDL ~ifcを実装する~objは，［
~objの状態を検分したり改変する仕方，~ifcに記述された挙動を呼出す仕方
］を提供することが期待されている。
◎
Interfaces in Web IDL describe how objects that implement the interface behave. In bindings for object oriented languages, it is expected that an object that implements a particular IDL interface provides ways to inspect and modify the object's state and to invoke the behavior described by the interface.
</p>
<!--JAVA
In the Java language binding, for example, this is achieved by ...
-->

<p>
~ifcは，別の~ifc（の~mb）を
`継承-@
するようにも定義し得る。
~ifcの識別子に文字
`U+003A COLON (":")^char
と`識別子$が後続している場合、後者の識別子が，継承される~ifcを識別する。
ある~ifc %I を継承する~ifcを実装する~objは， %I も実装する。
~objはしたがって， %I からの~ifc~mbに対応する~mbも持つことになる。
◎
An interface can be defined to inherit from another interface. If the identifier of the interface is followed by a U+003A COLON (":") character and an identifier, then that identifier identifies the inherited interface. An object that implements an interface that inherits from another also implements that inherited interface. The object therefore will also have members that correspond to the interface members from the inherited interface.
</p>

<pre class="syntax">
interface `identifier^i : `identifier-of-inherited-interface^mk {
  `interface-members…^i
};
</pre>

<p>
~mbが現れる順序は、<a href="#idl-overloading">多重定義</a>の場合を除いて有意でない。
◎
The order that members appear in has no significance except in the case of overloading.
</p>

<p>
~ifcは、継承される~ifcの~mbと同じ名前を持つ，~ifc~mbを指定してもよい。
派生~ifcを実装する~objは、派生~ifc上でそれらの~mbを公開することになる。
その~obj上で上書きされた~mbに~accessし得るかどうかは、言語束縛~特有になる。
◎
Interfaces may specify an interface member that has the same name as one from an inherited interface. Objects that implement the derived interface will expose the member on the derived interface. It is language binding specific whether the overridden member can be accessed on the object.
</p>

<div class="example">
<p>
次の２つの~ifcを考える
◎
Consider the following two interfaces.
</p>

<pre class="idl-code">
interface A {
  void f();
  void g();
};

interface B : A {
  void f();
  void g(DOMString x);
};
</pre>

<p>
ECMAScript 言語束縛においては、
`B^T の~instanceは，次の様な原型鎖を持つことになる：
◎
In the ECMAScript language binding, an instance of B will have a prototype chain that looks like the following:
</p>

<div style="white-space:pre;margin-left:2em;">
[ `Object.prototype^v ： `Object^t 原型~obj]
              ↑
[ `A.prototype^v ： `A^T の~ifc原型~obj]
              ↑
[ `B.prototype^v ： `B^T の~ifc原型~obj]
              ↑
[ `B^T の~instance]</div>

<!-- 
[Object.prototype: the Object prototype object]
[B.prototype: interface prototype object for B]
[instanceOfB]
 -->
<p>
ECMAScript における
`instanceOfB.f()^c
の~callは、
`B^T 上で定義された f を呼出すことになる。<!-- ＊ f -->
しかしながら， `A^T 上の f も、依然として
`A.prototype.f.call(instanceOfB)^c
の~callにより， `B^T を実装する~obj上で呼出せる。
◎
Calling instanceOfB.f() in ECMAScript will invoke the f defined on B. However, the f from A can still be invoked on an object that implements B by calling A.prototype.f.call(instanceOfB).
</p>
<!--JAVA
In the Java language binding, the two IDL interfaces will correspond to...
-->
</div>

<p>
所与の~ifc %A の
`被継承~ifc@
とは、［
%A が直接的にまたは間接的に継承する，すべての~ifc
］からなる集合である。
%A が 他の~ifcを`継承-$しない場合、集合は空である。
他の場合、その集合には， %A が継承する~ifc %B と %B の`被継承~ifc$すべてが含まれる。
◎
The inherited interfaces of a given interface A is the set of all interfaces that A inherits from, directly or indirectly. If A does not inherit from another interface, then the set is empty. Otherwise, the set includes the interface B that A inherits from and all of B’s inherited interfaces.
</p>

<p>
~ifcは、その継承階層が循環するように宣言されては~MUST_NOT。
すなわち、~ifc %A は自身を継承することも,
%A を継承する別の~ifc %B を継承することもできない，等々。
◎
An interface MUST NOT be declared such that its inheritance hierarchy has a cycle. That is, an interface A cannot inherit from itself, nor can it inherit from another interface B that inherits from A, and so on.
</p>

<p>
~ifcの一般的な多重~継承は~supportされず，~objは~ifcの任意の集合を実装することはできないことに注意。
~objは、所与の［
単独の~ifc %A
］を実装するように，すなわち %A の`被継承~ifc$すべてを実装するように，定義できる。
加えて、`~implements_st$を利用すれば，［
ある~ifcを実装している~objが，常にある別の~ifcも実装する
］ように定義することもできる。
◎
Note that general multiple inheritance of interfaces is not supported, and objects also cannot implement arbitrary sets of interfaces. Objects can be defined to implement a single given interface A, which means that it also implements all of A’s inherited interfaces. In addition, an implements statement can be used to define that objects implementing an interface will always also implement another interface.
</p>

<p>
各~ifc~mbの前には、`拡張属性$の~list（ `ExtendedAttributeList$g に合致）を置くことができる
— それらは、その~ifc~mbが，言語束縛において どう取扱われるかを制御する。
◎
Each interface member can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how the interface member will be handled in language bindings.
</p>

<pre class="syntax">
interface `identifier^i {

  [`extended-attributes^mk]
  const `type^i `identifier^i = `value^i;

  [`extended-attributes^mk]
  attribute `type^i `identifier^i;

  [`extended-attributes^mk]
  `return-type^i `identifier^i(`arguments…^i);
};
</pre>


<p>
`呼戻~ifc@
は，その定義の先頭に `callback^c ~keywordを利用する`~ifc$である。
呼戻~ifcは、
`idl-objects$sec
で述べるように，`~platform~obj$ではなく，`利用者~obj$により実装され得るものである。
◎
A callback interface is an interface that uses the callback keyword at the start of its definition. Callback interfaces are ones that can be implemented by user objects and not by platform objects, as described in section 3.9 below.
</p>

<pre class="syntax">
callback interface `identifier^i {
  `interface-members…^i
};
</pre>

<div class="note"><p>
似た命名の`呼戻~関数$定義も見よ。
◎
See also the similarly named callback function definition.
</p></div>

<p>
`呼戻~ifc$は非~呼戻~ifcを`継承-$しては~MUST_NOT。
非~呼戻~ifcは呼戻~ifcを`継承-$しては~MUST_NOT。
呼戻~ifcには`帰結~ifc$が存在しては~MUST_NOT。
◎
Callback interfaces MUST NOT inherit from any non-callback interfaces, and non-callback interfaces MUST NOT inherit from any callback interfaces. Callback interfaces MUST NOT have any consequential interfaces.
</p>

<p>
`呼戻~ifc$上に［
`静的~属性$ ／ `静的~演算$
］が定義されては~MUST_NOT。
◎
Static attributes and static operations MUST NOT be defined on a callback interface.
</p>


<div class="warning">

<p>
仕様~策定者は、既存の API の要件の記述に不可欠な場合を除き，単独の`演算$のみを持つ`呼戻~ifc$を定義する~SHOULD_NOT。
代わりに，`呼戻~関数$が利用される~SHOULD。
◎
Specification authors SHOULD NOT define callback interfaces that have only a single operation, unless required to describe the requirements of existing APIs. Instead, a callback function SHOULD be used.
</p>

<p>
`呼戻~ifc$である `EventListener^T の定義は、所与の~prop（この場合は `handleEvent^l ）を伴う`利用者~obj$により その~ifcを実装することが，許容される必要があるものと見なされている、既存の API の例である。
新たな API, あるいは互換性の心配がない API のための`呼戻~関数$には、（ ECMAScript 言語束縛においては） `Function^t ~objのみが許容されることになる。
◎
The definition of EventListener as a callback interface is an example of an existing API that needs to allow user objects with a given property (in this case “handleEvent”) to be considered to implement the interface. For new APIs, and those for which there are no compatibility concerns, using a callback function will allow only a Function object (in the ECMAScript language binding).
</p>
</div>

<div class="ednote v2"><p>
上の警告は，将来に呼戻~ifcを拡張する際には、おそらく適用されるべきではないであろう。
それが単一~演算~呼戻~ifcから取り掛かる良い理由になると見られる。
◎
Perhaps this warning shouldn't apply if you are planning to extend the callback interface in the future. That's probably a good reason to start off with a single operation callback interface.
</p></div>

<div class="ednote v2"><p>
編集者は，［
所与の呼戻~ifcを実装している利用者~obj上で，演算が実装されていない場合
］を~supportする必要があると考えている。
既存の呼戻~ifcを拡張する仕様は、おそらく，実装されていない演算の~callを避けることが求まれるであろう（代わりに何らかの既定の挙動を持たせて）。
従って，演算が実装されているかどうか意味する用語が定義されるべきであろう
—
ECMAScript 言語束縛における，~propの有無の検査に対応することになるような。
◎
I think we need to support operations not being implemented on a given user object implementing a callback interface. If specs extending an existing callback interface, we probably want to be able to avoid calling the operations that aren't implemented (and having some default behavior instead). So we should perhaps define a term that means whether the operation is implemented, which in the ECMAScript binding would correspond to checking for the property's existence.
</p></div>

<div class="note">
<p>
関数~引数として
“~propの集まり（ property bag ）”
のような ECMAScript ~objをとる API を定義する仕様の策定者には、`呼戻~ifc$よりも`辞書~型$の利用を勧める。
◎
Specification authors wanting to define APIs that take ECMAScript objects as “property bag” like function arguments are suggested to use dictionary types rather than callback interfaces.
</p>

<p>
例えば，次のものは：
◎
For example, instead of this:
</p>

<pre class="idl-code">
callback interface Options {
  attribute DOMString? option1;
  attribute DOMString? option2;
  attribute long? option3;
};

interface A {
  void doTask(DOMString type, Options options);
};
</pre>

<p>
次の様な利用を可能にするために：
◎
to be used like this:
</p>

<pre class="es-code">
var a = getA();  // <span title="Get an instance of A."
>`A^T の~instanceを取得する。</span>

a.doTask("something", { option1: "banana", option3: 100 });
</pre>

<p>
代わりに，次の様に記す：
◎
instead write the following:
</p>

<pre class="idl-code">
dictionary Options {
  DOMString? option1;
  DOMString? option2;
  long? option3;
};

interface A {
  void doTask(DOMString type, Options options);
};
</pre>
</div>

<p>
~ifcに対する IDL は、
`部分的~ifc定義@
（ `partial^sym `PartialInterface$g に合致）を利用して，複数の部分に分割できる。
部分的~ifc定義の`識別子$は、その~ifc定義の識別子と同じで~MUST。
それぞれの部分的~ifcに現れる，すべての~mbは、その~ifc自身の~mbであるものと見なされる。
◎
The IDL for interfaces can be split into multiple parts by using partial interface definitions (matching "partial" PartialInterface). The identifier of a partial interface definition MUST be the same as the identifier of an interface definition. All of the members that appear on each of the partial interfaces are considered to be members of the interface itself.
</p>

<pre class="syntax">
interface `SomeInterface^mk {
  `interface-members…^i
};

partial interface `SomeInterface^mk {
  `interface-members…^i
};
</pre>

<div class="note"><p>
部分的~ifc定義の目的は、~ifcの定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補助する所にある。
◎
Partial interface definitions are intended for use as a specification editorial aide, allowing the definition of an interface to be separated over more than one section of the document, and sometimes multiple documents.
</p></div>

<p>
`~ifc$定義, およびその`部分的~ifc定義$が現れる順序は問題にされない。
◎
The order of appearance of an interface definition and any of its partial interface definitions does not matter.
</p>

<div class="note"><p>
部分的~ifc定義においては、別の~ifcからの`継承-$は指定できない。
継承は元の`~ifc$定義に指定され~MUST。
◎
A partial interface definition cannot specify that the interface inherits from another interface. Inheritance must be specified on the original interface definition.
</p></div>

<p>
多少の制限もあるが、`部分的~ifc定義$にも，`拡張属性$を指定できる。
次の拡張属性は，部分的~ifc定義に指定されては~MUST_NOT：
`Constructor$x,
`ImplicitThis$x,
<!--JAVA [JavaPackage], -->
`LegacyArrayClass$x
`NamedConstructor$x,
`NoInterfaceObject$x
。
◎
Extended attributes can be specified on partial interface definitions, with some limitations. The following extended attributes MUST NOT be specified on partial interface definitions: [Constructor], [ImplicitThis], [LegacyArrayClass], [NamedConstructor], [NoInterfaceObject].
</p>


<div class="note"><p>
`Exposed$x,
`Global$x,
`OverrideBuiltins$x,
`PrimaryGlobal$x,
`SecureContext$x,
`Unforgeable$x
を除き，上に挙げたものが
この文書に定義される中で`~ifc$に適用し得る`拡張属性$のすべてである。
◎
The above list of extended attributes is all of those defined in this document that are applicable to interfaces except for [Exposed], [Global], [OverrideBuiltins], [PrimaryGlobal], [SecureContext] and [Unforgeable].
</p></div>

<p>
`部分的~ifc定義$に指定される
`拡張属性$は
`~ifc$自身に現れるものと見なされる。
◎
Any extended attribute specified on a partial interface definition is considered to appear on the interface itself.
</p>

<p>
関連の言語束縛が，~ifcと［
言語の構成子
］との間の対応付けを決定する。
◎
The relevant language binding determines how interfaces correspond to constructs in the language.
</p>
<!-- 
An interface forward declaration is a definition that matches ...
-->


<p>
~ifcには、次の拡張属性を適用し得る：
`Constructor$x,
`Exposed$x,
`Global$x,
`ImplicitThis$x,
<!--JAVA [JavaPackage], -->
`LegacyArrayClass$x,
`NamedConstructor$x,
`NoInterfaceObject$x,
`OverrideBuiltins$x,
`PrimaryGlobal$x,
`SecureContext$x,
`Unforgeable$x
。
◎
The following extended attributes are applicable to interfaces: [Constructor], [Exposed], [Global], [ImplicitThis], [LegacyArrayClass], [NamedConstructor], [NoInterfaceObject], [OverrideBuiltins], [PrimaryGlobal], [SecureContext], [Unforgeable].
</p>

<div class="grammar">
--CallbackOrInterface
-CallbackRestOrInterface
-Interface
-Partial
-PartialDefinition
-PartialInterface
-InterfaceMembers
-InterfaceMember
-Inheritance
</div>

	  <div class="example">
<!-- 
The following IDL fragment demonstrates the use of an
interface forward declaration ...
-->

<p>
次の `IDL 片$に、２つの相互に参照しあう`~ifc$
— `Human^T と `Dog^T —
の定義~例を示す。
いずれも `Animal^T を継承するので、２つの~ifcいずれかを実装する~objは， `name^M 属性も持つことになる。
◎
The following IDL fragment demonstrates the definition of two mutually referential interfaces. Both Human and Dog inherit from Animal. Objects that implement either of those two interfaces will thus have a name attribute.
</p>

<pre class="idl-code">
interface Animal {
  attribute DOMString name;
};

interface Human : Animal {
  attribute Dog? pet;
};

interface Dog : Animal {
  attribute Human? owner;
};
</pre>
</div>


<div class="example">
<p>
次の `IDL 片$は
DOM `~ifc$の一部を単純化した~versionを定義する。
うち１個は`呼戻~ifc$である。
◎
The following IDL fragment defines simplified versions of a few DOM interfaces, one of which is a callback interface.
</p>

<pre class="idl-code">
interface Node {
  readonly attribute DOMString nodeName;
  readonly attribute Node? parentNode;
  Node appendChild(Node newChild);
  void addEventListener(DOMString type, EventListener listener);
};

callback interface EventListener {
  void handleEvent(Event event);
};
</pre>

<p>
`EventListener^T ~ifcは呼戻~注釈付きの~ifcなので，`利用者~obj$により実装し得る：<!--  -->
◎
Since the EventListener interface is annotated callback interface, user objects can implement it:
</p>

<pre class="es-code">
var node = getNode();  // <span id="cp-get-Node" title="Obtain an instance of Node."
>`Node^T の~instanceを得る。</span>

var listener = {
  handleEvent: function(event) {
    ...
  }
};
node.addEventListener("click", listener);            // <span title="This works."
>これは機能する。</span>

node.addEventListener("click", function() { ... });  // <span title="As does this."
>これと同様に。</span>
</pre>

<p>
しかしながら，利用者~objは
`Node^T を実装することはできない：
◎
It is not possible for a user object to implement Node, however:
</p>

<pre class="es-code">
var node = getNode();  // <!--cp-get-Node-->

var newNode = {
  nodeName: "span",
  parentNode: null,
  appendChild: function(newchild) {
    ...
  },
  addEventListener: function(type, listener) {
    ...
  }
};
node.appendChild(newNode);  // <span title="This will throw a TypeError exception."
>`TypeError^T 例外が投出されることになる。</span>
</pre>
</div>

			<section id="idl-constants">
<h4 title="Constants">3.2.1. 定数</h4>


<p>
`定数@
は、定数~値を名前に束縛するために利用される，宣言（ `Const$g に合致）である。
定数は`~ifc$に現れ得る。
◎
A constant is a declaration (matching Const) used to bind a constant value to a name. Constants can appear on interfaces.
</p>
<div class="warning">

<p>
過去においては，定数は、主に，有名~整数~codeを列挙するスタイルで定義されていた。
Web ~platformは、文字列の利用を支持し，このデザインパターンから離れつつある。
定数の定義`論ML^。
◎
Constants have in the past primarily been used to define named integer codes in the style of an enumeration. The Web platform is moving away from this design pattern in favor of the use of strings. Specification authors who wish to define constants are strongly advised to discuss this on the public-script-coord@w3.org mailing list before proceeding.
</p>
</div>

<pre class="syntax">
const `type^i `identifier^i = `value^i;
</pre>

<p>
`定数$の`識別子$は［
同じ~ifc上で定義される別の`~ifc~mb$
］の識別子と同じになっては~MUST_NOT。
また、識別子が［
`length^l ／ `name^l ／ `prototype^l
］になっては~MUST_NOT。
◎
The identifier of a constant MUST NOT be the same as the identifier of another interface member defined on the same interface.  The identifier also MUST NOT be “length”, “name” or “prototype”.
</p>

<p class="note">
これらの名前は、すべての `Function^t ~objに存在する~propの名前である。
◎
These three names are the names of properties that exist on all Function objects.
</p>

<p>
定数の型（ `ConstType$g に合致）は、［
`~primitive型$または`~nullable$~primitive型
］で~MUST。
`識別子$が利用される場合、その識別子は［
~primitive型または~nullable~primitive型<!-- numeric？ -->
］の`~typedef$を参照し~MUST。
◎
The type of a constant (matching ConstType) MUST NOT be any type other than a primitive type or a nullable primitive type. If an identifier is used, it MUST reference a typedef whose type is a primitive type or a nullable primitive type.
</p>

<div class="p">
<p>
定数~宣言の `ConstValue$g 部は定数の値を与え、次のいずれかの~tokをとり得る：
</p>

<ul>
	<li>
２つの真偽~literal（ `true^c と `false^c ）
</li>
	<li>
`null^c
</li>
	<li>
`integer$g
</li>
	<li>
`float$g
</li>
	<li>
３つの特別な浮動小数点~定数~値（ `-Infinity^c, `Infinity^c, `NaN^c ）
</li>
</ul>

<p class="trans-note">【
この訳では、これらの~tokを総称して，
`定数~tok@
と呼ぶことにする。
】</p>
◎
The ConstValue part of a constant declaration gives the value of the constant, which can be one of the two boolean literal tokens (true and false), the null token, an integer token, a float token, or one of the three special floating point constant values (-Infinity, Infinity and NaN).
</div>

<div class="note"><p>
文字列や空~連列に加え，これらの値も［
辞書~mbの`辞書既定値^や, 随意~引数の`既定~値$
］を指定するために利用できる。
文字列や空~連列 `[]^c は、`定数$の値には利用できないことに注意。
◎
These values – in addition to strings and the empty sequence – can also be used to specify the default value of a dictionary member or of an optional argument. Note that strings and the empty sequence [] cannot be used as the value of a constant.

</p></div>

<p>
真偽~literal~tokの値は、それぞれ，
IDL `boolean$T 値［
`true^V, `false^V
］になる。
◎
The value of the boolean literal tokens true and false are the IDL boolean values true and false.
</p>

<p>
`integer$g ~tokの値は、次の様にして決定される整数~値になる：
◎
The value of an integer token is an integer whose value is determined as follows:
</p>

<ol class="algorithm">
	<li>
%S := `integer$g ~tokに合致する文字~並び
◎
Let S be the sequence of characters matched by the integer token.
</li>
	<li>
%sign := ［
%S の先頭が
`U+002D HYPHEN-MINUS ("-")^char
ならば −1 ／
~ELSE_ 1
］
◎
Let sign be −1 if S begins with U+002D HYPHEN-MINUS ("-"), and 1 otherwise.
</li>
	<li>
<p>
%base := %S から先頭の
`U+002D HYPHEN-MINUS ("-")^char
は（もしあれば）除いた残りの部分の，頭部の文字~並びに基づく基数：
◎
Let base be the base of the number based on the characters that follow the optional leading U+002D HYPHEN-MINUS ("-") character:
</p>
		<dl class="switch">
<dt>`0X^l （
`U+0030 DIGIT ZERO ("0")^char,
`U+0058 LATIN CAPITAL LETTER X ("X")^char
）</dt>
<dt>`0x^l （
`U+0030 DIGIT ZERO ("0")^char,
`U+0078 LATIN SMALL LETTER X ("x")^char
）</dt>
<dd>
基数は 16
◎
The base is 16.
</dd>
<dt>`U+0030 DIGIT ZERO ("0")^char</dt>
<dd>
基数は 8
◎
The base is 8.
</dd>
<dt title="Otherwise">その他</dt>
<dd>
基数は 10
◎
The base is 10.
</dd>
		</dl>
	</li>
	<li>
%number := %S から頭部の ［
`U+002D HYPHEN-MINUS ("-")^char ／
基数を指示する文字~並び
］を（もしあれば）除いた残りの文字すべてを，指定された基数 %base に基づいて整数に解釈した結果
<!--  -->
◎
Let number be the result of interpreting all remaining characters following the optional leading U+002D HYPHEN-MINUS ("-") character and any characters indicating the base as an integer specified in base base.
</li>
	<li>
~RET %sign × %number
◎
Return sign × number.
</li>
</ol>

<p>
`integer$g ~tokの型は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型と同じである。
`integer$g ~tokの値は、
`idl-types$sec
で与えられる，その型の値として妥当な範囲に入ら~MUST。
◎
The type of an integer token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of. The value of the integer token MUST NOT lie outside the valid range of values for its type, as given in section 3.10 below.
</p>

<p id="float-token-value">
`float$g ~tokの値は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型に依存して，単精度, 倍精度 いずれかの IEEE 754 浮動小数点数になり、次の様にして決定される：
◎
The value of a float token is either an IEEE 754 single-precision floating point number or an IEEE 754 double-precision floating point number, depending on the type of the constant, dictionary member or optional argument it is being used as the value for, determined as follows:
</p>

<ol class="algorithm">
	<li>
%S := `float$g ~tokに合致する文字~並び
◎
Let S be the sequence of characters matched by the float token.
</li>
	<li>
%value := %S を ECMAScript `NumericLiteral^ （ `ECMA-262$r 11.8.3 節）として構文解析して得られる Mathematical Value
◎
Let value be the Mathematical Value that would be obtained if S were parsed as an ECMAScript NumericLiteral ([ECMA-262], section 11.8.3).
</li>
	<li>
~IF
`float$g ~tokが `float$T または `unrestricted float$T の値として利用されている
~THEN
~RET %value <!-- result -->に最も近い IEEE 754 単精度 浮動小数点数
`IEEE-754$r
◎
If the float token is being used as the value for a float or unrestricted float, then the value of the float token is the IEEE 754 single-precision floating point number closest to result. Otherwise, the float token is being used as the value for a double or unrestricted double, and the value of the float token is the IEEE 754 double-precision floating point number closest to result. [IEEE-754]
</li>

	<li>
~ELSE （すなわち `float$g ~tokが `double$T または `unrestricted double$T の値として利用されている）
~THEN
~RET %value に最も近い IEEE 754 倍精度 浮動小数点数
◎
↑</li>

</ol>

<p>
`Infinity^c, `-Infinity^c, `NaN^c
のいずれかとして指定された定数~値は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型に依存して，単精度, 倍精度 いずれかの IEEE 754 浮動小数点数になり、次の様にして決定される：
◎
The value of a constant value specified as Infinity, -Infinity or NaN is either an IEEE 754 single-precision floating point number or an IEEE 754 double-precision floating point number, depending on the type of the constant, dictionary member or optional argument is is being used as the value for:
</p>

<!-- 
 -->

<dl class="switch">
	<dt>
`unrestricted float$T 型の定数~値 `Infinity^c
◎
Type unrestricted float, constant value Infinity
</dt>
	<dd>
値は IEEE 754 単精度，正の無限~値
◎
The value is the IEEE 754 single-precision positive infinity value.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `Infinity^c
◎
Type unrestricted double, constant value Infinity
</dt>
	<dd>
値は IEEE 754 倍精度，正の無限~値
◎
The value is the IEEE 754 double-precision positive infinity value.
</dd>
	<dt>
`unrestricted float$T 型の定数~値 `-Infinity^c
◎
Type unrestricted float, constant value -Infinity
</dt>
	<dd>
値は IEEE 754 単精度，負の無限~値
◎
The value is the IEEE 754 single-precision negative infinity value.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `-Infinity^c
◎
Type unrestricted double, constant value -Infinity
</dt>
	<dd>
値は IEEE 754 倍精度，負の無限~値
◎
The value is the IEEE 754 double-precision negative infinity value.
</dd>
	<dt>
`unrestricted float$T 型の定数~値 `NaN^c
◎
Type unrestricted float, constant value NaN
</dt>
	<dd>
値は~bit~pattern 0x7fc00000 の， IEEE 754 単精度 NaN
◎
The value is the IEEE 754 single-precision NaN value with the bit pattern 0x7fc00000.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `NaN^c
◎
Type unrestricted double, constant value NaN
</dt>
	<dd>
値は~bit~pattern 0x7ff8000000000000 の， IEEE 754 倍精度 NaN
◎
The value is the IEEE 754 double-precision NaN value with the bit pattern 0x7ff8000000000000.
</dd>
</dl>

<p>
`float$g ~tokの型は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型と同じになる。
`float$g ~tokの値は、
`idl-types$sec
で与えられるように，その型の値として妥当な範囲の外にあっては~MUST_NOT。
また、［
`Infinity^c, `-Infinity^c, `NaN^c
］が［
`float$T や `double$T
］の値として利用されては~MUST_NOT。
◎
The type of a float token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of. The value of the float token MUST NOT lie outside the valid range of values for its type, as given in section 3.10 below. Also, Infinity, -Infinity and NaN MUST NOT be used as the value of a float or double.
</p>

<p>
`null^c ~tokの値は、`~nullable型$に属する特別な `null^V 値である。
`null^c ~tokの型は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型と同じになる。
◎
The value of the null token is the special null value that is a member of the nullable types. The type of the null token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of.
</p>

<p>
%VT を定数にあてがわれる値の型,
%DT を［ 定数／辞書~mb／随意~引数 ］自身の型とするとき、これらの型は互換，すなわち %DT と %VT が一致するか, または
%DT はその`内部型$が %VT であるような`~nullable型$でなければ~MUST。
◎
If VT is the type of the value assigned to a constant, and DT is the type of the constant, dictionary member or optional argument itself, then these types MUST be compatible, which is the case if DT and VT are identical, or DT is a nullable type whose inner type is VT.
</p>

<p>
`定数$は
それが現れる`~ifc$の個々の~instanceには結付けられない。
`定数$が~instanceにも公開されるかどうかは
言語束縛~特有になる。
◎
Constants are not associated with particular instances of the interface on which they appear. It is language binding specific whether constants are exposed on instances.
</p>

<div class="note">

<p>
ECMAScript 言語束縛では，しかしながら、`定数$が宣言されている IDL `~ifc$を実装する~objを通して，`定数$への~accessが許容される。
例えば次の IDL では：
<!--JAVA
Both the ECMAScript and the Java language binding do however
-->
◎
The ECMAScript language binding does however allow constants to be accessed through objects implementing the IDL interfaces on which the constants are declared. For example, with the following IDL:
</p>

<pre class="idl-code">
interface A {
  const short rambaldi = 47;
};
</pre>

<p>
ECMAScript においては、この定数~値は，［
`A.rambaldi^c および (`A^T の~instance)`.rambaldi^c
］として~accessできる。
<!--JAVA and in Java-->
◎
the constant value can be accessed in ECMAScript either as A.rambaldi or instanceOfA.rambaldi.
</p>
</div>

<p>
定数には、次の拡張属性を適用し得る：
`Exposed$x,
`SecureContext$x
◎
The following extended attributes are applicable to constants: [Exposed], [SecureContext].
</p>

<div class="grammar">
-Const
-ConstValue
-BooleanLiteral
-FloatLiteral
-ConstType
</div>


<div class="example">
<p>
次の `IDL 片$に、上の型の`定数$を定義する例を示す。
◎
The following IDL fragment demonstrates how constants of the above types can be defined.
</p>

<pre class="idl-code">
interface Util {
  const boolean DEBUG = false;
  const octet LF = 10;
  const unsigned long BIT_MASK = 0x0000fc00;
  const double AVOGADRO = 6.022e23;
};
</pre>

</div>
			</section>
			<section id="idl-attributes">
<h4 title="Attributes">3.2.2. 属性</h4>


<p>
`属性@
（
`inherit^sym `ReadOnly$g `AttributeRest$g ／
`static^sym `ReadOnly$g `AttributeRest$g ／
`stringifier^sym `ReadOnly$g `AttributeRest$g ／
`ReadOnly$g `AttributeRest$g
いずれかに合致）は、［
`~ifc$を実装している~objが，［
所与の［
型, `識別子$
］により，値の取得0や（一部の場合は）変更を行える
］~data~fieldを持つことになる
］ことを宣言するために利用される，
`~ifc~mb$である。
属性は次の２種類に分けられる：
◎
An attribute is an interface member (matching "inherit" ReadOnly AttributeRest, "static" ReadOnly AttributeRest, "stringifier" ReadOnly AttributeRest, or ReadOnly AttributeRest) that is used to declare data fields with a given type and identifier whose value can be retrieved and (in some cases) changed. There are two kinds of attributes:
</p>

<ol>
	<li>
<p>
`正則~属性$は、`~ifc$を実装している~objが，所与の`識別子$を伴う~data~field~mbを持つことになることを宣言するために利用される。
◎
regular attributes, which are those used to declare that objects implementing the interface will have a data field member with the given identifier
</p>

<pre class="syntax">
attribute `type^i `identifier^i;
</pre>

	</li>
	<li class="v2">
<p>
`静的~属性$は、その~ifcを実装している個々の~objには結付けられない属性を宣言するために利用される。
◎
static attributes, which are used to declare attributes that are not associated with a particular object implementing the interface
</p>

<pre class="syntax">
static attribute `type^i `identifier^i;
</pre>

	</li>
</ol>

<p class="v2">
`static^c ~keywordを伴わない属性は
`正則~属性@
を宣言する。
そうでなければ，`静的~属性$を宣言する。
◎
If an attribute has no static keyword, then it declares a regular attribute. Otherwise, it declares a static attribute.
</p>


<p>
`属性$の`識別子$は［
同じ`~ifc$上に定義される別の`~ifc~mb$の識別子
］と同じになっては~MUST_NOT。
静的~属性の識別子が `prototype^l になっては~MUST_NOT。
◎
The identifier of an attribute MUST NOT be the same as the identifier of another interface member defined on the same interface. The identifier of a static attribute MUST NOT be “prototype”.
</p>

<p>
属性の型は、 `attribute^c ~keywordの後に現れる
型（ `Type$g に合致）で与えられる。
`Type$g が［
`識別子$, または `?^c が後続する識別子
］である場合、その識別子は［
~ifc, `列挙$, `呼戻~関数$, `~typedef$
］のいずれかとして識別され~MUST。
◎
The type of the attribute is given by the type (matching Type) that appears after the attribute keyword. If the Type is an identifier or an identifier followed by ?, then the identifier MUST identify an interface, enumeration, callback function or typedef.
</p>

<p>
属性の型は、~typedefの解決-後に，次に挙げる型, あるいはその`~nullable型$になっては~MUST_NOT。
◎
The type of the attribute, after resolving typedefs, MUST NOT be a nullable or non-nullable version of any of the following types:
</p>


<ul id="cp-nullable-type-list">
	<li>
`連列~型$
◎
a sequence type
	</li>
	<li>
`辞書$
◎
a dictionary
	</li>
	<li>
その`平坦化~mb型$に［
［ ~nullable／非~nullable ］の連列~型, または辞書<!-- 区切り？ -->
］を含んでいるような，`共用体~型$
<span class="trans-note">【
平坦化~mb型は~nullableを含み得ないので，この “~nullable” の記述は不要では？
】</span>
◎
a union type that has a nullable or non-nullable sequence type or dictionary as one of its flattened member types
	</li>
</ul>


<p>
`attribute^c ~keywordの前に `readonly^c ~keywordが利用されている場合、属性は
`読専@（ readonly, 読み取り専用）
になる。
［
読専の属性が定義されている~ifc
］を実装する~objにおいては、その属性に対する代入は許容されないことになる。
代入が、単に言語において許容されないのか,
無視されるのか,
あるいは例外が投出されるのか，については、言語束縛~特有になる。
◎
The attribute is read only if the readonly keyword is used before the attribute keyword. An object that implements the interface on which a read only attribute is defined will not allow assignment to that attribute. It is language binding specific whether assignment is simply disallowed by the language, ignored or an exception is thrown.
</p>

<pre class="syntax">
readonly attribute `type^i `identifier^i;
</pre>

<p>
`読専$でない`正則~属性$は、先祖の~ifcからその
`取得子を継承-@
するように宣言できる。
これにより、先祖~ifcの読専の属性を，派生~ifc上で~writableにすることができる。
属性は、その宣言が `inherit^c を伴うとき，`取得子を継承-$するものとされる。
その属性が取得子を継承する読専の属性は、［
同じ識別子の属性が定義されている，先祖の~ifc
］のうち，最も末端の~ifcに属する属性である。
<!-- readonlyとは限らない？ -->
取得子を［
継承する側, される側
］の属性の型は同じで~MUST。
また、 `inherit^c が［
`読専$の属性／`静的~属性$
］に現れては~MUST_NOT。
◎
A regular attribute that is not read only can be declared to inherit its getter from an ancestor interface. This can be used to make a read only attribute in an ancestor interface be writable on a derived interface. An attribute inherits its getter if its declaration includes inherit in the declaration. The read only attribute from which the attribute inherits its getter is the attribute with the same identifier on the closest ancestor interface of the one on which the inheriting attribute is defined. The attribute whose getter is being inherited MUST be of the same type as the inheriting attribute, and inherit MUST NOT appear on a read only attribute or a static attribute.
</p>

<pre class="syntax">
interface `Ancestor^i {
  readonly attribute `TheType^i `theIdentifier^i;
};

interface `Derived^i : `Ancestor^i {
  inherit attribute `TheType^i `theIdentifier^i;
};
</pre>

<!-- 
The GetRaises and SetRaises clauses are used to declare ...
-->

<p>
`正則~属性$の宣言に `stringifier^c ~keywordが利用されている場合、その~ifcを実装している~objが文字列化されるときに，その属性の値になることを指示する。
詳細は
`idl-stringifiers$sec
に。
◎
When the stringifier keyword is used in a regular attribute declaration, it indicates that objects implementing the interface will be stringified to the value of the attribute. See section 3.2.4.2 below for details.
</p>

<pre class="syntax">
stringifier attribute DOMString `identifier^i;
</pre>

<p id="callback-attribute-exceptions">
実装が
`利用者~obj$上の`属性$の値の取得-または設定-を試みたときに（例えば 呼戻~objが実装に供されているとき），その試みによる~~結果，例外が投出される場合、他から指定されない限り，その例外は［
実装からその属性への~accessを生じさせた，利用者~code
］まで伝播することになる。
同様に、属性の取得-により返される値を IDL 型の値に変換できない場合、それにより生じた例外も［
実装からその属性の値の取得を試みさせた，利用者~code
］まで伝播することになる。
◎
If an implementation attempts to get or set the value of an attribute on a user object (for example, when a callback object has been supplied to the implementation), and that attempt results in an exception being thrown, then, unless otherwise specified, that exception will be propagated to the user code that caused the implementation to access the attribute. Similarly, if a value returned from getting the attribute cannot be converted to an IDL type, then any exception resulting from this will also be propagated to the user code that resulted in the implementation attempting to get the value of the attribute.
</p>


<p>
［
正則／静的
］属性には、次の`拡張属性$を適用し得る：
`Clamp$x,
`EnforceRange$x,
`Exposed$x,
`SameObject$x,
`SecureContext$x,
`TreatNullAs$x,
。
◎
The following extended attributes are applicable to regular and static attributes: [Clamp], [EnforceRange], [Exposed], [SameObject], [SecureContext], [TreatNullAs].
</p>

<p>
次の`拡張属性$は、正則~属性のみに適用し得る：
`LenientThis$x,
`PutForwards$x,
`Replaceable$x,
`Unforgeable$x
◎
The following extended attributes are applicable only to regular attributes: [LenientThis], [PutForwards], [Replaceable], [Unforgeable].
</p>


<div class="grammar">
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteAttribute
AttributeRest
AttributeName
AttributeNameKeyword
Inherit
ReadOnly
</div>

<div class="example">
<p>
次の `IDL 片$に，`~ifc$上にて`属性$を宣言する例を示す：
◎
The following IDL fragment demonstrates how attributes can be declared on an interface:
</p>

<pre class="idl-code">
<!--exception InvalidName {
  DOMString reason;
};

exception NoSuchPet { };
-->interface Animal {

  // <span title="A simple attribute that can be set to any string value."
>単純な，任意の文字列に設定され得る属性。</span>
  readonly attribute DOMString name;

  // <span title="An attribute whose value can be assigned to."
>値を代入できる属性。</span>
  attribute unsigned short age;
};

interface Person : Animal {
  
  // <span title="An attribute whose getter behavior is inherited from Animal, and need not be
specified in the description of Person."
>取得子の挙動を `Animal^T から継承する属性。
  // `Person^T の記述の中で指定する必要はない。</span>
  inherit attribute DOMString name<!-- setraises (InvalidName)-->;
<!-- 
  // <span>An attribute whose value cannot be assigned to, and which can raise an</span>
  // <span>exception in some circumstances.</span>
  readonly attribute DOMString petName getraises (NoSuchPet);
-->};
</pre>
</div>
			</section>
			<section id="idl-operations">
<h4 title="Operations">3.2.3. 演算</h4>


<p>
`演算@
（
`static^sym `OperationRest$g ／
`stringifier^sym `OperationRest$g ／
`serializer^sym `OperationRest$g ／
`ReturnType$g `OperationRest$g ／
`SpecialOperation$g
いずれかに合致）は、その~ifcを実装している~obj上で呼出せる挙動を定義する，
`~ifc~mb$である。
演算には次の３つの種類がある：
◎
An operation is an interface member (matching "static" OperationRest, "stringifier" OperationRest, "serializer" OperationRest, ReturnType OperationRest or SpecialOperation) that defines a behavior that can be invoked on objects implementing the interface. There are three kinds of operation:
</p>

<ol>
	<li>
<p>
`正則~演算$：
その`~ifc$を実装している~objが、所与の`識別子$を伴う~methを持つことになることを宣言するために利用される。
◎
regular operations, which are those used to declare that objects implementing the interface will have a method with the given identifier
</p>

<pre class="syntax">
`return-type^i `identifier^i(`arguments…^i);
</pre>

</li>
	<li>
<p>
`特殊~演算$：
~objの~indexingや文字列化など、その~ifcを実装している~obj上の特殊な挙動を宣言するために利用される。
◎
special operations, which are used to declare special behavior on objects implementing the interface, such as object indexing and stringification
</p>

<pre class="syntax">
`special-keywords…^i `return-type^i `identifier^i(`arguments…^i);
`special-keywords…^i `return-type^i (`arguments…^i);
</pre>

</li>
	<li>
<p>
`静的~演算$：
その~ifcを実装している個々の~objには結付けられない演算を宣言するために利用される。
◎
static operations, which are used to declare operations that are not associated with a particular object implementing the interface
</p>

<pre class="syntax">
static `return-type^i `identifier^i(`arguments…^i);
</pre>

	</li>
</ol>

<p>
識別子を持ち, かつ
`static^sym ~keywordがない演算は、
`正則~演算@
を宣言する。
１個~以上の`特殊~keyword$（すなわち，［
`Special$g に合致する~keyword, または
`stringifier^c ~keyword
］）が宣言に利用されている演算は，`特殊~演算$を宣言する。
演算を，正則~演算と特殊~演算を兼ねるように宣言することもできる。
特殊~演算についての詳細は
`idl-special-operations$sec
に。
◎
If an operation has an identifier but no static keyword, then it declares a regular operation. If the operation has one or more special keywords used in its declaration (that is, any keyword matching Special, or the stringifier keyword), then it declares a special operation. A single operation can declare both a regular operation and a special operation; see section 3.2.4 below for details on special operations.
</p>

<p>
識別子を持たない演算は、いずれかの特殊~keywordを利用して，`特殊~演算$として宣言され~MUST。
◎
If an operation has no identifier, then it MUST be declared to be a special operation using one of the special keywords.
</p>

<p>
`正則~演算$／`静的~演算$の識別子は、同じ`~ifc$上に定義される`定数$や`属性$の識別子と同じになっては~MUST_NOT。
静的~演算の識別子が `prototype^l になっては~MUST_NOT。
◎
The identifier of a regular operation or static operation MUST NOT be the same as the identifier of a constant or attribute defined on the same interface. The identifier of a static operation MUST NOT be “prototype”.
</p>

<div class="note"><p>
しかしながら、識別子をその~ifc上の別の演算と同じにすることはできる。
演算の多重定義は、これにより指定される。
◎
The identifier can be the same as that of another operation on the interface, however. This is how operation overloading is specified.
</p></div>

<p>
`静的~演算$の`識別子$は、同じ`~ifc$上に定義される`正則~演算$の識別子と同じになっては~MUST_NOT。
◎
The identifier of a static operation also MUST NOT be the same as the identifier of a regular operation defined on the same interface.
</p>

<p>
演算の
`返値型@
（ `ReturnType$g に合致）は、［
~optionalの［
演算の`識別子$
］］の前に現れる型により 与えられる。
返値型
`void@T
は，演算が値を返さないことを指示する。
返値型が `?^c 付きの`識別子$である場合、その識別子は［
~ifc , 辞書 , `列挙$ , `呼戻~関数$ , `~typedef$
］のいずれかに識別され~MUST。
◎
The return type of the operation is given by the type (matching ReturnType) that appears before the operation’s optional identifier. A return type of void indicates that the operation returns no value. If the return type is an identifier followed by ?, then the identifier MUST identify an interface, dictionary, enumeration, callback function or typedef.
</p>

<p>
演算の引数（ `ArgumentList$g に合致）は、宣言の中の丸括弧の合間にて与えられる。
それぞれの引数は、型（ `Type$g に合致）の後に
`識別子$（ `ArgumentName$g に合致）を続けて指定される。
◎
An operation’s arguments (matching ArgumentList) are given between the parentheses in the declaration. Each individual argument is specified as a type (matching Type) followed by an identifier (matching ArgumentName).
</p>

<div class="note"><p>
表現力のため、演算~引数の識別子には， `ArgumentNameKeyword$g 記号に合致する~keywordも，~escapeを要することなく 指定できる。
<!--  -->
◎
For expressiveness, the identifier of an operation argument can also be specified as one of the keywords matching the ArgumentNameKeyword symbol without needing to escape it.
</p></div>

<p>
演算~引数の `Type$g が `?^c 付きの`識別子$である場合、その識別子は［
~ifc , `列挙$ , `呼戻~関数$ , `~typedef$
］のいずれかに識別され~MUST。
演算~引数の型が `?^c 付きでない`識別子$である場合、その識別子は，それらのいずれかの定義か, または `辞書$に識別され~MUST。
◎
If the Type of an operation argument is an identifier followed by ?, then the identifier MUST identify an interface, enumeration, callback function or typedef. If the operation argument type is an identifier not followed by ?, then the identifier MUST identify any one of those definitions or a dictionary.
</p>

<pre class="syntax">
`return-type^i `identifier^i(`type^i `identifier^i, `type^i `identifier^i, …);
</pre>

<p>
各~引数の識別子は、同じ演算~宣言~内の他の引数の識別子と同じになっては~MUST_NOT。
◎
The identifier of each argument MUST NOT be the same as the identifier of another argument in the same operation declaration.
</p>

<p>
各~引数の前には、`拡張属性$の~list（ `ExtendedAttributeList$g に合致）を置くことができる
— それらは、その引数として渡された値が，言語束縛において どう取扱われるかを制御する。
◎
Each argument can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how a value passed as the argument will be handled in language bindings.
</p>

<pre class="syntax">
`return-type^i `identifier^i([`extended-attributes^mk] `type^i `identifier^i, [`extended-attributes^mk] `type^i `identifier^i, …);
</pre>


<div class="example">
<p>
次の `IDL 片$は
`~ifc$上に`正則~演算$を宣言する：
◎
The following IDL fragment demonstrates how regular operations can be declared on an interface:
</p>

<pre class="idl-code">
interface Dimensions {
  attribute unsigned long width;
  attribute unsigned long height;
};

interface Button {

  // <span title="An operation that takes no arguments and returns a boolean."
>引数をとらず, `boolean^T を返す演算<!-- 
and could possibly raise an exception.--></span>
  boolean isMouseOver()<!-- raises (NoPointerDevice)-->;

  // <span title="Overloaded operations."
>多重定義された演算。</span>
  void setDimensions(Dimensions size);
  void setDimensions(unsigned long width, unsigned long height);
};
</pre>
</div>

<div >
<p>
演算の 最後の引数 の引数~型の直後に `...^c ~tokが利用されている場合、その演算は
`可変個の引数をとる@
もの（ variadic ）と見なされる。
<span class="trans-note">【
その最後の引数を
`可変個~引数@
もしくは
<dfn>末尾~引数</dfn>
と記すことにする。
】</span>
そのように宣言された演算は：
</p>

<ul>
	<li>
その末尾~引数の後に任意~個数の引数を伴って呼出せることを指示し、それらの余分な暗黙の形式的~引数の型は，末尾~引数と同じ型と見なされる。
</li>
	<li>
呼出すときには、末尾~引数を省略することもできる。
</li>
	<li>
末尾~引数~以外の引数が `...^c ~tokを伴って宣言されては~MUST_NOT。
</li>
</ul>
◎
An operation is considered to be variadic if the final argument uses the ... token just after the argument type. Declaring an operation to be variadic indicates that the operation can be invoked with any number of arguments after that final argument. Those extra implied formal arguments are of the same type as the final explicit argument in the operation declaration. The final argument can also be omitted when invoking the operation. An argument MUST NOT be declared with the ... token unless it is the final argument in the operation’s argument list.
</div>

<pre class="syntax">
`return-type^i `identifier^i(`type^i<em>...</em> `identifier^i);
`return-type^i `identifier^i(`type^i `identifier^i, `type^i<em>...</em> `identifier^i);
</pre>

<p>
`引数~listを引数にとる$`拡張属性$（この仕様で定義される `Constructor$x と `NamedConstructor$x ）, および
`呼戻~関数$についても、その引数~listに `...^c ~tokが利用されているならば，`可変個の引数をとる$ものと見なされる。
<span class="trans-note">【
以下の記述における “演算†” には，これらの（構築子を与える）拡張属性や呼戻も含まれていると思われる。
】</span>
◎
Extended attributes that take an argument list ([Constructor] and [NamedConstructor], of those defined in this specification) and callback functions are also considered to be variadic when the ... token is used in their argument lists.
</p>


<div class="example">
<p>
次の `IDL 片$は，可変個の引数をとる演算を２つ持つ~ifcを定義する：
◎
The following IDL fragment defines an interface that has two variadic operations:
</p>

<pre class="idl-code">
interface IntegerSet {
  readonly attribute unsigned long cardinality;

  void union(long... ints);
  void intersection(long... ints);
};
</pre>

<p>
ECMAScript 言語束縛においては、可変個の引数をとる演算は，後続の引数を受容し得る関数により実装される：
◎
In the ECMAScript binding, variadic operations are implemented by functions that can accept the subsequent arguments:
</p>

<pre class="es-code">
var s = getIntegerSet();  // <span title="Obtain an instance of IntegerSet."
>`IntegerSet^T の~instanceを得る。</span>

s.union();                // <span title="Passing no arguments corresponding to 'ints'."
>`ints^l に対応する引数を~~省略。</span>
s.union(1, 4, 7);         // <span title="Passing three arguments corresponding to 'ints'."
>`ints^l に対応する３個の引数を渡す。</span>
</pre>

<p>
可変個の引数をとる関数を~supportしない言語のための言語束縛においては、その種の演算には，整数の 配列または~list を明示的に渡すように指定することになるであろう。
◎
A binding for a language that does not support variadic functions might specify that an explicit array or list of integers be passed to such an operation.
</p>
</div>


<p>
`optional^c ~keywordを伴って宣言された引数は
`随意~引数@
であるものと見なされる。
`可変個の引数をとる$演算†の`末尾~引数$も随意~引数と見なされる。
随意として宣言された引数は，演算†を呼出す時にその値を省略し得ることを指示する。
`末尾~引数$が，明示的に随意として宣言されては~MUST_NOT。
◎
An argument is considered to be an optional argument if it is declared with the optional keyword. The final argument of a variadic operation is also considered to be an optional argument. Declaring an argument to be optional indicates that the argument value can be omitted when the operation is invoked. The final argument in an operation MUST NOT explicitly be declared to be optional if the operation is variadic.
</p>

<pre class="syntax">
`return-type^i `identifier^i(`type^i `identifier^i, optional `type^i `identifier^i);
</pre>


<p>
随意~引数には
`既定~値@
を指定できる。
引数の識別子に
`U+003D EQUALS SIGN ("=")^char
と
値（ `DefaultValue$g に合致）が後続している場合、その値がその随意~引数の
`既定~値$
を与える。
ただし、`可変個の引数をとる$演算†の`末尾~引数$には、既定~値が指定されては~MUST_NOT。
既定~値は、対応する引数が省略されて演算†が~callされたときに，その引数がとる値と見なされる。
◎
Optional arguments can also have a default value specified. If the argument’s identifier is followed by a U+003D EQUALS SIGN ("=") and a value (matching DefaultValue), then that gives the optional argument its default value. The implicitly optional final argument of a variadic operation MUST NOT have a default value specified. The default value is the value to be assumed when the operation is called with the corresponding argument omitted.
</p>

<pre class="syntax">
`return-type^i `identifier^i(`type^i `identifier^i, optional `type^i `identifier^i = `value^i);
</pre>

<div class="warning">
<p>
`boolean$T 型の引数には、既定~値として `true^V を利用しないことを強く勧める。
さもなければ、 `undefined^v に既定の変換（すなわち， `false^V ）が利用されると期待する作者たちを惑わすことになるので。
◎
It is strongly suggested not to use default value of true for boolean-typed arguments, as this can be confusing for authors who might otherwise expect the default conversion of undefined to be used (i.e., false).
</p>
</div>

<div>

<p>
次を満たす引数は、随意として指定され~MUST。
</p>

<ul>
	<li>
引数の型は［
`辞書~型$である, または［
`共用体~型$であって，ある`辞書~型$を`平坦化~mb型$に含んでいる
］, かつ
</li>
	<li>
その辞書~型 %D と %D の先祖には，必須の~mbはない, かつ
</li>
	<li>
引数は最後の引数である, または
引数に後続するどの引数も`随意~引数$である。
</li>
</ul>

<p>
そのような引数は、他から指定されない限り，常に［
各~mbが`辞書既定値^にされた，空の辞書
］を値にとるものと見なされる。
</p>
◎
If the type of an argument is a dictionary type or a union type that has a dictionary type as one of its flattened member types, and that dictionary type and its ancestors have no required members, and the argument is either the final argument or is followed only by optional arguments, then the argument MUST be specified as optional. Such arguments are always considered to have a default value of an empty dictionary, unless otherwise specified.
</div>

<div class="note">
<p>
これは、作者が辞書の既定~値のみの利用を望むときでも，空の辞書~値を渡さずに済むような API の設計を促すためである。
◎
This is to encourage API designs that do not require authors to pass an empty dictionary value when they wish only to use the dictionary’s default values.
</p>

<p>
辞書~型は明示的な既定~値を指定し得ないので、上の “他から指定されない限り” の条件は，`平坦化~mb型$に辞書~型が含まれているような`共用体~型$に対してのみ可能になる。<!--  -->
◎
Dictionary types cannot have a default value specified explicitly, so the “unless otherwise specified” clause above can only be invoked for a union type that has a dictionary type as one of its flattened member types.
</p>
</div>

<p>
`既定~値$に`定数~tok$が利用された場合、`定数$に対するときと同じ仕方で解釈される。
◎
When a boolean literal token (true or false), the null token, an integer token, a float token or one of the three special floating point literal values (Infinity, -Infinity or NaN) is used as the default value, it is interpreted in the same way as for a constant.
</p>

<p>
随意~引数の既定~値には、 `string$g ~tokも指定できる。
それは、次の様にして決定される`文字列~型$の値をとる：
◎
Optional argument default values can also be specified using a string token, whose value is a string type determined as follows:
</p>

<ol class="algorithm">
	<li>
%S := `string$g ~tokに合致する［
`Unicode ~scalar値$の並び
］から，先頭と末尾の
`U+0022 QUOTATION MARK^char ( `"^c )
文字を除去したもの
◎
Let S be the sequence of Unicode scalar values matched by the string token with its leading and trailing U+0022 QUOTATION MARK ('"') characters removed.
</li>
	<li>
<p>
`string$g ~tokの値は、引数の型に応じて，次で与えられる：
◎
Depending on the type of the argument:
</p>

<dl class="switch">
	<dt>`DOMString$T</dt>
	<dt>`列挙$ 型</dt>
	<dd>
%S を UTF-16 符号化したものに対応する， 16 ~bit無符号~整数~符号単位（以下、単に
`符号単位@
と記される）の並び。
◎
The value of the string token is the sequence of 16 bit unsigned integer code units (hereafter referred to just as code units) corresponding to the UTF-16 encoding of S.
</dd>
	<dt class="v2">`ByteString$T</dt>
	<dd>
%S を UTF-8 符号化したものに対応する， 8 ~bit無符号~整数~符号単位の並び。
◎
The value of the string token is the sequence of 8 bit unsigned integer code units corresponding to the UTF-8 encoding of S.
</dd>
	<dt class="v2">`USVString$T</dt>
	<dd>
%S 。
◎
The value of the string token is S.
</dd>
</dl>
	</li>
</ol>

<p>
`随意~引数$の型が`列挙$である場合、その`既定~値$に指定される値は，その列挙のいずれかの`列挙~値$で~MUST。
◎
If the type of the optional argument is an enumeration, then its default value if specified MUST be one of the enumeration’s values.
</p>

<p class="v2">
`連列~型$（`~nullable$も含む）の随意~引数の既定~値には、
2 個の~tokによる `[]^c を利用して，その型と同じ型の空~連列~値を表現する値も指定できる。
`連列~型$（`~nullable$も含む）でない随意~引数に，この既定~値を指定しては~MUST_NOT。
◎
Optional argument default values can also be specified using the two token value [], which represents an empty sequence value. The type of this value is the same the type of the optional argument it is being used as the default value of. That type MUST be a sequence type or a nullable type.
</p>
<!-- or a nullable sequence type -->

<div class="example">
<p>
次の `IDL 片$は、２つの長さが異なる引数~listで呼出せる単独の`演算$を伴う`~ifc$を定義する：
◎
The following IDL fragment defines an interface with a single operation that can be invoked with two different argument list lengths:
</p>

<pre class="idl-code">
interface ColorCreator {
  object createColor(double v1, double v2, double v3, optional double alpha);
};
</pre>

<p>
それは、`多重定義$された２つの`演算$を持つ次の`~ifc$と等価になる：
◎
It is equivalent to an interface that has two overloaded operations:
</p>

<pre class="idl-code">
interface ColorCreator {
  object createColor(double v1, double v2, double v3);
  object createColor(double v1, double v2, double v3, double alpha);
};
</pre>
</div>
<!-- 
A `raises^c clause (matching `Raises$g) is used to declare ...
-->


<p id="callback-operation-exceptions">
実装が`利用者~obj$上の`演算$の呼出しを試みた結果
（例えば，呼戻~objが実装に供されていて），例外が投出される場合、他から指定されない限り，その例外は［
実装からその演算の呼出しを生じさせた，利用者~code
］まで伝播することになる。
同様に，演算の呼出しにより返される値を IDL 型に変換できない場合、それにより生じた例外も［
実装からその演算の呼出しを試みさせた，利用者~code
］まで伝播することになる。
◎
If an implementation attempts to invoke an operation on a user object (for example, when a callback object has been supplied to the implementation), and that attempt results in an exception being thrown, then, unless otherwise specified, that exception will be propagated to the user code that caused the implementation to invoke the operation. Similarly, if a value returned from invoking the operation cannot be converted to an IDL type, then any exception resulting from this will also be propagated to the user code that resulted in the implementation attempting to invoke the operation.
</p>


<p>
演算には、次の拡張属性を適用し得る：
`Exposed$x,
`NewObject$x,
`SecureContext$x,
`TreatNullAs$x,
`Unforgeable$x
。
◎
The following extended attributes are applicable to operations: [Exposed], [NewObject], [SecureContext], [TreatNullAs], [Unforgeable].
</p>

<p>
演算~引数には、次の拡張属性を適用し得る：
`Clamp$x,
`EnforceRange$x,
`TreatNullAs$x
。
◎
The following extended attributes are applicable to operation arguments: [Clamp], [EnforceRange], [TreatNullAs].
</p>

<div class="grammar">
DefaultValue
Operation
SpecialOperation
Specials
Special
OperationRest
OptionalIdentifier
ArgumentList
Arguments
Argument
OptionalOrRequiredArgument
ArgumentName
Ellipsis
ArgumentNameKeyword
ReturnType
</div>

			</section>
			<section id="idl-special-operations">
<h4 title="Special operations">3.2.4. 特殊~演算</h4>


<p>
`特殊~演算@
は、［
その特殊~演算~宣言が現れる~ifc
］を実装する~obj上における［
一定の種類の特殊な挙動
］の宣言である。
`特殊~演算$は，演算~宣言において１個~以上の
`特殊~keyword@
を利用して宣言される。
◎
A special operation is a declaration of a certain kind of special behavior on objects implementing the interface on which the special operation declarations appear. Special operations are declared by using one or more special keywords in an operation declaration.
</p>

<p>
`特殊~演算$には、次の一覧に示す６種類がある。
一覧には、それぞれの種類の特殊~演算に対し，その宣言-時に利用される特殊~keyword, およびその特殊~演算の用途も示す：
◎
There are six kinds of special operations. The table below indicates for a given kind of special operation what special keyword is used to declare it and what the purpose of the special operation is:
</p>
<table class="vert">
	<thead><tr>
<th>`特殊~演算$◎Special operation</th>
<th>~keyword◎Keyword</th>
<th>用途◎Purpose</th>
	</tr></thead>
	<tbody>

<tr><td>`取得子@
</td><td>`getter^c
</td><td>
~prop取得1
のために~objが~indexingされる際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property retrieval.
</td></tr>

<tr><td>`設定子@
</td><td>`setter^c
</td><td>
~prop代入／作成
のために~objが~indexingされる際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property assignment or creation.
</td></tr>

<tr><td>`削除子@
</td><td>`deleter^c
</td><td>
~prop削除
のために~objが~indexingされる際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property deletion.
</td></tr>

<tr><td>`旧来呼出子@
</td><td>`legacycaller^c
</td><td>
~objが関数であったかのように~callされる際の挙動を定義する。
◎
Defines behavior for when an object is called as if it were a function.
</td></tr>

<tr><td>`文字列化子@
</td><td>`stringifier^c
</td><td>
~objを `DOMString$T に変換する方法を定義する。
◎
Defines how an object is converted into a DOMString.
</td></tr>

<tr class="v2"><td>`直列化子@
</td><td>`serializer^c
</td><td>
~objを直列化ed形に変換する方法を定義する。
◎
Defines how an object is converted into a serialized form.
</td></tr>

</tbody></table>

<p>
すべての言語束縛が、［
これら６種類の，~objの特殊な挙動
］すべてを~supportするわけではない。
`特殊~演算$が，識別子を伴わない演算を利用して宣言された場合、その個々の種類の特殊~演算を~supportしない言語束縛においては，単にその機能性が存在しないことになる。
◎
Not all language bindings support all of the six kinds of special object behavior. When special operations are declared using operations with no identifier, then in language bindings that do not support the particular kind of special operations there simply will not be such functionality.
</p>

<div class="example">
<p>
次の IDL 片は、取得子と設定子を伴う~ifcを定義する：
◎
The following IDL fragment defines an interface with a getter and a setter:
</p>

<pre class="idl-code">
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  getter double (DOMString propertyName);
  setter void (DOMString propertyName, double propertyValue);
};
</pre>

<p>
~propの取得子や設定子を~supportしない言語束縛では、
`Dictionary^T を実装している~objはこの特殊な挙動を持たないことになる。
◎
In language bindings that do not support property getters and setters, objects implementing Dictionary will not have that special behavior.
<!--JAVA For example, in the Java language binding, the corresponding Java interface will have only a single method, <code>long getPropertyCount()</code>.
-->
</p>
</div>

<p>
`特殊~演算$を`識別子$を伴わせて定義することは、その宣言から識別子のない特殊~演算を分離することと，等価である。
この書き方は、~ifcの演算についての注釈文の記述を単純化するために許容されている。
◎
Defining a special operation with an identifier is equivalent to separating the special operation out into its own declaration without an identifier. This approach is allowed to simplify prose descriptions of an interface’s operations.
</p>

<div class="example">
<p>
次の２つの~ifcは等価である：
◎
The following two interfaces are equivalent:
</p>

<pre class="idl-code">
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  getter double getProperty(DOMString propertyName);
  setter void setProperty(DOMString propertyName, double propertyValue);
};
</pre>

<pre class="idl-code">
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  double getProperty(DOMString propertyName);
  void setProperty(DOMString propertyName, double propertyValue);

  getter double (DOMString propertyName);
  setter void (DOMString propertyName, double propertyValue);
};
</pre>
</div>
<!-- 
The <code>omittable</code> keyword ...
-->

<p>
１つの演算に同じ`特殊~keyword$が複数~回 現れては~MUST_NOT。
◎
A given special keyword MUST NOT appear twice on an operation.
</p>

<div id="_property-accessors">
<!-- 
有index~prop~accessor:indexed-property-accessor
有名~prop~accessor:named-property-accessor
-->
<p>
取得子, 設定子, 削除子は２つ系列に分類される：
</p>

<ul>
	<li>
`有名~prop取得子@,
`有名~prop設定子@,
`有名~prop削除子@
と呼ばれる，~prop名として `DOMString$T をとるもの。
</li>
	<li>
`有index~prop取得子@,
`有index~prop設定子@
と呼ばれる，~prop~indexとして `unsigned long$T をとるもの
— 有index~propには，<em>削除子は無い</em>。
</li>
</ul>

<p>
詳細は
`idl-indexed-properties$sec, `idl-named-properties$sec
に。
</p>
◎
Getters and setters come in two varieties: ones that take a DOMString as a property name, known as named property getters and named property setters, and ones that take an unsigned long as a property index, known as indexed property getters and indexed property setters. There is only one variety of deleter: named property deleters. See section 3.2.4.4 and section 3.2.4.5 for details.
</div>

<p>
所与の`~ifc$上に存在する，［
`文字列化子$, `直列化子$, `削除子$ および, 各~系列の［
`取得子$, `設定子$
］］は、それぞれ，高々１個までで~MUST。
旧来呼出子 については、多重定義された~callの挙動を指定する，複数のものが、同じ~ifc上に存在し得る。
◎
On a given interface, there MUST exist at most one stringifier, at most one serializer, at most one named property deleter, and at most one of each variety of getter and setter. Multiple legacy callers can exist on an interface to specify overloaded calling behavior.
</p>

<p>
~ifcが［
いずれかの系列の`設定子$,
あるいは`有名~prop削除子$
］を持つ場合、同じ系列の`取得子$も持た~MUST。
◎
If an interface has a setter of a given variety, then it MUST also have a getter of that variety. If it has a named property deleter, then it MUST also have a named property getter.
</p>


<p>
演算を利用して宣言される`特殊~演算$は，`可変個の引数をとる$ようにされたり, `随意~引数$を持っては~MUST_NOT。
◎
Special operations declared using operations MUST NOT be variadic nor have any optional arguments.
</p>

<p>
`特殊~演算$は，`呼戻~ifc$上で宣言されては~MUST_NOT。
◎
Special operations MUST NOT be declared on callback interfaces.
</p>

<p>
~objが，所与の`特殊~演算$を定義する複数の`~ifc$を実装する場合、その演算に対し，どの特殊~演算が呼出されるかは 未定義である。
◎
If an object implements more than one interface that defines a given special operation, then it is undefined which (if any) special operation is invoked for that operation.
</p>

				<section id="idl-legacy-callers">
<h5 title="Legacy callers">3.2.4.1. 旧来呼出子</h5>


<p>
`~ifc$が１個~以上の`旧来呼出子$を持つとき、その~ifcを実装する~objは，それらが関数であったかのように~callし得ることを指示する。
上に示された様に，旧来呼出子は
`legacycaller^c ~keywordを伴って宣言される`演算$を利用して指定できる。
◎
When an interface has one or more legacy callers, it indicates that objects that implement the interface can be called as if they were functions. As mentioned above, legacy callers can be specified using an operation declared with the legacycaller keyword.
</p>

<pre class="syntax">
legacycaller `return-type^i `identifier^i(`arguments…^i);
legacycaller `return-type^i (`arguments…^i);<!-- 
omittable legacycaller `return-type^i `identifier^i(`arguments…^i);-->
</pre>

<p>
~ifcに複数の`旧来呼出子$が指定されている場合、その~objが関数であったかのように~callされる際に，どの旧来呼出子が呼出されるか決定するときには、`多重定義~解決~algo$が利用される。
◎
If multiple legacy callers are specified on an interface, overload resolution is used to determine which legacy caller is invoked when the object is called as if it were a function.
</p>

<p>
`旧来呼出子$は、`~promise型$を返し得るように定義されては~MUST_NOT。
◎
Legacy callers MUST NOT be defined to return a promise type.
</p>


<div class="warning">

<p>
`旧来呼出子$は望ましくない特色機能としてあまねく認識されている。
それらはもっぱら，旧来の Web ~platform特色機能を指定できるようにするために存在する。
旧来呼出子は、旧来の API の挙動の指定が要求されていない限り，仕様に利用される~SHOULD_NOT。
その場合においても，先に進む前に
<a href="mailto:public-script-coord@w3.org">public-script-coord@w3.org</a> メーリングリストにて論を交わすべきである。
◎
Legacy callers are universally recognised as an undesirable feature. They exist only so that legacy Web platform features can be specified. Legacy callers SHOULD NOT be used in specifications unless required to specify the behavior of legacy APIs, and even then this should be discussed on the public-script-coord@w3.org mailing list before proceeding.
</p>
</div>

<div class="example">
<p>
次の `IDL 片$は、`旧来呼出子$を伴う`~ifc$を定義する。
◎
The following IDL fragment defines an interface with a legacy caller.
</p>

<pre class="idl-code">
interface NumberQuadrupler {
  // <span title="This operation simply returns four times the given number x."
>この演算は単純に %x を 4 倍にして返す。</span>
  legacycaller double compute(double x);
};
</pre>

<p>
この~ifcを~supportする ECMAScript 実装では，関数として~callされる `NumberQuadrupler^T を実装する`~platform~obj$が許容されることになるであろう：
◎
An ECMAScript implementation supporting this interface would allow a platform object that implements NumberQuadrupler to be called as a function:
</p>

<pre class="es-code">
var f = getNumberQuadrupler();  // <span title="Obtain an instance of NumberQuadrupler."
>`NumberQuadrupler^T の~instanceを得る。</span>

f.compute(3);                   // <span title="This evaluates to 12."
>これは `12^v に評価される。</span>
f(3);                           // <span title="This also evaluates to 12."
>これも `12^v に評価される。</span>
</pre>
</div>
				</section>
				<section id="idl-stringifiers">
<h5 title="Stringifiers">3.2.4.2. 文字列化子</h5>


<p>
`~ifc$が`文字列化子$を持つとき、
<!--  -->
その~ifcを実装する~objは，文字列への既定でない変換を持つことになる。
上に示した様に、文字列化子は
`stringifier^c ~keywordを伴って宣言される`演算$を利用して，指定できる。
◎
When an interface has a stringifier, it indicates that objects that implement the interface have a non-default conversion to a string. As mentioned above, stringifiers can be specified using an operation declared with the stringifier keyword.
</p>

<pre class="syntax">
stringifier DOMString `identifier^i();
stringifier DOMString ();<!-- 
omittable stringifier DOMString `identifier^i();-->
</pre>

<p>
`文字列化子$の宣言-時に利用された演算が`識別子$を持たない場合、~ifcに付随する注釈文において，~ifcの
`文字列化の挙動@
が定義され~MUST。
演算が識別子を持つ場合、その演算の呼出しにより，~objは文字列に変換される。
◎
If an operation used to declare a stringifier does not have an identifier, then prose accompanying the interface MUST define the stringification behavior of the interface. If the operation does have an identifier, then the object is converted to a string by invoking the operation to obtain the string.
</p>

<p>
演算により宣言される`文字列化子$は、引数をとらず,
`DOMString$T を返すように，宣言され~MUST。
◎
Stringifiers declared with operations MUST be declared to take zero arguments and return a DOMString.
</p>

<p>
略記法として、
`stringifier^c ~keywordが，識別子を伴わない演算により宣言される場合、その演算の`返値型$, および引数~listを省略できる。
◎
As a shorthand, if the stringifier keyword is declared using an operation with no identifier, then the operation’s return type and argument list can be omitted.
</p>

<pre class="syntax">
stringifier;
</pre>

<div class="example">
<p>
次の２つの~ifcは等価である：
◎
The following two interfaces are equivalent:
</p>

<pre class="idl-code">
interface A {
  stringifier DOMString ();
};
</pre>

<pre class="idl-code">
interface A {
  stringifier;
};
</pre>
</div>

<p>
`stringifier^c ~keywordは
`属性$上に置くこともできる。
この場合、その属性の値が，~objから文字列への変換-を与える。
`stringifier^c ~keywordが［［
`DOMString$T／`USVString$T
として宣言されていない属性
］や
`静的~属性$
］上に置かれては~MUST_NOT。
◎
The stringifier keyword can also be placed on an attribute. In this case, the string to convert the object to is the value of the attribute. The stringifier keyword MUST NOT be placed on an attribute unless it is declared to be of type DOMString or USVString. It also MUST NOT be placed on a static attribute.
</p>

<pre class="syntax">
stringifier attribute DOMString `identifier^i;
</pre>

<div class="grammar">
Stringifier
StringifierRest
</div>

<div class="example">
<p>
次の `IDL 片$は、
`name^M
属性の値に文字列化する~ifcを定義する：
◎
The following IDL fragment defines an interface that will stringify to the value of its name attribute:
</p>

<pre class="idl-code">
[Constructor]
interface Student {
  attribute unsigned long id;
  stringifier attribute DOMString name;
};
</pre>

<p>
ECMAScript 言語束縛においては、文字列が期待されている文脈において
`Student^T
~objが利用されたときの結果は、その~objの `name^l ~propの値になる：
◎
In the ECMAScript binding, using a Student object in a context where a string is expected will result in the value of the object’s “name” property being used:
</p>

<pre class="es-code">
var s = new Student();
s.id = 12345678;
s.name = '周杰倫';

var greeting = 'こんにちは、 ' + s + ' さん。';
    // <span title="Now greeting == 'Hello, 周杰倫!'."
>%greeting は `こんにちは、 周杰倫 さん。^l になる。</span>
</pre>

<p>
次の `IDL 片$は、 IDL 自身には指定されない独自の文字列化の挙動を持つ~ifcを定義する。
◎
The following IDL fragment defines an interface that has custom stringification behavior that is not specified in the IDL itself.
</p>

<pre class="idl-code">
[Constructor]
interface Student {
  attribute unsigned long id;
  attribute DOMString? familyName;
  attribute DOMString givenName;

  stringifier DOMString ();
};
</pre>

<p>
したがって、例えば次の段落の様な，文字列化の挙動を説明する注釈文が要求される：
◎
Thus, prose is required to explain the stringification behavior, such as the following paragraph:
</p>

<blockquote><p>
`Student^T ~ifc を実装する~objを文字列化した結果は、
`familyName^M 属性の値が `null^V の場合は
`givenName^M 属性の値，他の場合は［
`givenName^M 属性の値,
１個の space 文字,
`familyName^M 属性の値
］の連結にならなければ~MUST_NOT。
◎
Objects that implement the Student interface must stringify as follows. If the value of the familyName attribute is null, the stringification of the object is the value of the givenName attribute. Otherwise, if the value of the familyName attribute is not null, the stringification of the object is the concatenation of the value of the givenName attribute, a single space character, and the value of the familyName attribute.
</p></blockquote>

<p>
この IDL の ECMAScript 実装は、次の様に挙動することになる：
◎
An ECMAScript implementation of the IDL would behave as follows:
</p>

<pre class="es-code">
var s = new Student();
s.id = 12345679;
s.familyName = 'Smithee';
s.givenName = 'Alan';

var greeting = 'こんにちは、 ' + s + ' さん。';
    // <span title="Now greeting == 'Hi Alan Smithee'."
>%greeting は `こんにちは、 Alan Smithee さん^l になる。</span>
</pre>
</div>
				</section>
				<section id="idl-serializers" class="v2">
<h5 title="Serializers">3.2.4.3. 直列化子</h5>


<p>
`~ifc$が`直列化子$を持つとき、その~ifcを実装する~objが，自身を直列化ed形に変換する仕方を提供することを指示する。
直列化子は `serializer^c ~keywordを利用して宣言できる。
◎
When an interface has a serializer, it indicates that objects provide a way for them to be converted into a serialized form. Serializers can be declared using the serializer keyword:
</p>

<pre class="syntax">
serializer;
</pre>

<p>
この仕方で`直列化子$を宣言する~ifcにおいては、付随する注釈文にて，
その~ifcの
`直列化の挙動@
が定義され~MUST。
直列化の挙動は、次のいずれかの型による
`直列化ed値@
を返すものとして定義される：
◎
Prose accompanying an interface that declares a serializer in this way MUST define the serialization behavior of the interface. Serialization behavior is defined as returning a serialized value of one of the following types:
</p>

<ul>
	<li>
<p >
次のいずれも満たすような，一連の~key-valueからなる<em>~map</em>
</p>
		<ul>
			<li>
どの~keyも ~map内で一意な `DOMString$T 値である
</li>
			<li>
どの~valueも `直列化ed値$である
</li>
		</ul>

◎
a map of key–value pairs, where the keys are DOMString values (unique in the map) and the values are serialized values
</li>
	<li>
一連の`直列化ed値$からなる，<em>~list</em>
◎
a list of serialized values
</li>
	<li>
`DOMString$T 値
◎
a DOMString value
</li>
	<li>
`unrestricted double$T 値
◎
an unrestricted double value
</li>
	<li>
`boolean$T 値
◎
a boolean value
</li>
	<li>
`null^V 値
◎
the null value
</li>
</ul>

<p>
［
言語束縛において，`直列化の挙動$が~obj上にてどのように可用にされるか
］, および［
抽象的な`直列化ed値$がどのようにして適切な具体的な値に変換されるか
］については、言語束縛~特有になる。
◎
How the serialization behavior is made available on an object in a language binding, and how exactly the abstract serialized value is converted into an appropriate concrete value, is language binding specific.
</p>

<div class="note"><p>
ECMAScript 言語束縛においては、`直列化の挙動$は，［
`直列化ed値$を［［
`JSON.stringify^c 関数により JSON に直列化し得る
］ような ECMAScript 値
］に変換したもの
］を返すような `toJSON^c ~methとして，公開される。
詳細は
`es-serializer$sec
に。
◎
In the ECMAScript language binding, serialization behavior is exposed as a toJSON method which returns the serialized value converted into an ECMAScript value that can be serialized to JSON by the JSON.stringify function. See section 4.6.8.2 below for details.
</p></div>

<p>
`直列化の挙動$は、別途の注釈文を与えずに， IDL の中で直接的に指定することもできる。
そのためには、
~keyword `serializer^c と
文字
`U+003D EQUALS SIGN ("=")^char
に続けて，以下に述べる６種の形をとり得る
`直列化~pattern@
を記す：
◎
Serialization behavior can also be specified directly in IDL, rather than separately as prose. This is done by following the serializer keyword with a U+003D EQUALS SIGN ("=") character and a serialization pattern, which can take one of the following six forms:
</p>

<dl>
	<dt>
~ifcからの，ゼロ個~以上の属性に対応する~entryを伴う~map ①：
◎
↓</dt>
	<dt>
または、① に加え，被継承~ifc からの属性に対応する~entryも伴う~map：
◎
A map with entries corresponding to zero or more attributes from the interface, and optionally attributes from an inherited interface:
</dt>
	<dd>

<pre class="syntax">
serializer = { `attribute-identifier^i, `attribute-identifier^i, … }; // ①
serializer = { inherit, `attribute-identifier^i, `attribute-identifier^i, … };
</pre>

<p id="cp-attr-must-serializable">
どの識別子も，~ifc上で宣言された属性の識別子で~MUST。
識別されるどの属性も，`直列化可能な型$を持た~MUST。
◎
Each identifier MUST be the identifier of an attribute declared on the interface. The identified attributes all MUST have a serializable type.
</p>

<p>
`inherit^c ~keywordは、［
~ifcが`直列化子$を定義する別の~ifcを継承し, かつ
そのような~ifcのうち最も末端のものが［
この形, または次項の形（すなわち， `{ attribute }^c ）
］による`直列化~pattern$を利用して直列化子を定義している
］場合を除き，利用されては~MUST_NOT。
◎
The inherit keyword MUST NOT be used unless the interface inherits from another that defines a serializer, and the closest such interface defines its serializer using this serialization pattern form or the following form (i.e. { attribute }).
</p>

<p id="cp-ser-behavior-as-follows">
この形の直列化~patternに対する`直列化の挙動$は、次で与えられる：
◎
The serialization behavior for this form of serialization pattern is as follows:
</p>

		<ol class="algorithm">
			<li id="cp-let-empty-map">
%map := 空の~map
◎
Let map be an empty map.
</li>
			<li id="cp-set-map-if-inherit">
~IF `inherit^c ~keywordが利用されている
~THEN
%map ← `直列化子$を宣言する最も末端の被継承~ifc の`直列化の挙動$の結果
◎
If the inherit keyword was used, then set map to be the result of the serialization behavior of the closest inherited interface that declares a serializer.
</li>
			<li>
<p>
~FOR
直列化~pattern内の~EACH ( 属性~識別子 %i ) に対し，順に：
◎
For each attribute identifier i in the serialization pattern, in order:
</p>

				<ol>
					<li id="cp-remove-with-key-eq-i">
%map 内から［
~key ＝ %i
］なる~entryをすべて除去する
◎
Remove any entry in map with key name i.
</li>
					<li id="cp-let-V-attr-of-id-i">
%V := 識別子 %i の属性の値
◎
Let V be the value of the attribute with identifier i.
</li>
					<li id="cp-add-entry-key-of-i">
［
~key ＝ %i,
~value ＝ ［
%V を`直列化ed値に変換-$した結果
］］なる~entryを %map に追加する
◎
Add an entry to map whose key name is i and whose value is result of converting V to a serialized value.
</li>
				</ol>
			</li>
			<li id="cp-ret-map">
~RET %map
◎
Return map.
</li>
		</ol>
	</dd>
	<dt>
~ifcからの，すべての［
`直列化可能な型$を持つ属性
］に対応する~entryを伴う~map ②：
◎
↓</dt>
	<dt>
または、② に加え，被継承~ifc からの属性に対応する~entryも伴う~map：
◎
A map with entries corresponding to all attributes from the interface that have a serializable type, and optionally attributes from an inherited interface:
</dt>
	<dd>

<pre class="syntax">
serializer = { attribute }; // ②
serializer = { inherit, attribute };
</pre>

<p><!-- copy* -->
`inherit^c ~keywordは、［
~ifcが`直列化子$を定義する別の~ifcを継承し, かつ
そのような~ifcのうち最も末端のものが［
この形, または前項の形
］による`直列化~pattern$を利用して直列化子を定義している
］場合を除き，利用されては~MUST_NOT。
◎
The inherit keyword MUST NOT be used unless the interface inherits from another that defines a serializer, and the closest such interface defines its serializer using this serialization pattern form or the previous form.
</p>

<!--cp-ser-behavior-as-follows-->

		<ol class="algorithm">
			<!--cp-let-empty-map-->
			<!--cp-set-map-if-inherit-->
			<li><p>
~FOR
~ifc上の ~EACH (
`直列化可能な型$を持つ属性の識別子 %i
) に対し，それが~ifc上に現れる順に：
◎
For each identifier i of an attribute on the interface whose type is a serializable type, in the order they appear on the interface:
</p>

				<ol>
					<!--cp-remove-with-key-eq-i-->
					<!--cp-let-V-attr-of-id-i-->
					<!--cp-add-entry-key-of-i-->
				</ol>
			</li>
			<!--cp-ret-map-->
		</ol>
	</dd>
	<dt>
`有名~prop$に対応している~entryを伴う~map：
◎
A map with entries corresponding to the named properties:
</dt>
	<dd>

<pre class="syntax">
serializer = { getter };
</pre>

<p>
この形は、［
~ifcまたはそれが継承する~ifcが有名~propを~supportする
］, かつ［
`有名~prop取得子$の返値型が直列化可能である
］場合を除き，利用されては~MUST_NOT。
◎
This form MUST NOT be used unless the interface or one it inherits from supports named properties and the return type of the named property getter is a serializable type.
</p>

<!--cp-ser-behavior-as-follows-->

		<ol class="algorithm">
			<!--cp-let-empty-map-->

			<li><p>
~FOR
~obj上の~EACH ( `被support~prop名$ %n ) に対し，順に：
◎
For each supported property name n on the object, in order:
</p>

				<ol>
					<li>
%V := 名前 %n の有名~propの値
◎
Let V be the value of the named property with name n.
</li>

					<!--cp-add-entry-key-of-i-->
				</ol>
			</li>

			<!--cp-ret-map-->
		</ol>
	</dd>
	<dt>
~ifc上のゼロ個~以上の属性の値の~list：
◎
A list of value of zero or more attributes on the interface:
</dt>
	<dd>

<pre class="syntax">
serializer = [ `attribute-identifier^i, `attribute-identifier^i, … ];
</pre>

<!--cp-attr-must-serializable-->

<!--cp-ser-behavior-as-follows-->

		<ol class="algorithm">
			<li id="cp-let-list-empty">
%list := 空~list
◎
Let list be an empty list.
</li>
			<li><p>
~FOR
直列化~pattern内の ~EACH ( 属性~識別子 %i ) に対し，順に：
◎
For each attribute identifier i in the serialization pattern:
</p>

				<ol>
					<!--cp-let-V-attr-of-id-i-->
					<li id="cp-append-serialized">
%V を`直列化ed値に変換-$した結果の値を %list に付加する
◎
Append to list the value that is the result of converting V to a serialized value.
</li>
				</ol>
			</li>
			<li>
~RET %list
◎
Return list.
</li>
		</ol>
	</dd>
	<dt>
`有index~prop$に対応している~entryの~list
◎
A list with entries corresponding to the indexed properties:
</dt>
	<dd>

<pre class="syntax">
serializer = [ getter ];
</pre>

<p>
この形は、［
~ifcまたはそれが継承する~ifcが`有index~propを~supportする$
］, かつ［
`有index~prop取得子$の返値型が直列化可能な型である
］場合を除き，利用されては~MUST_NOT。
◎
This form MUST NOT be used unless the interface or one it inherits from supports indexed properties and the return type of the indexed property getter is a serializable type.
</p>

<!--cp-ser-behavior-as-follows-->

		<ol class="algorithm">
			<!--cp-let-list-empty-->
			<li>
%i := 0
◎
Let i be 0.
</li>
			<li><p>
~WHILE %i ≤ ~obj上の`被support~prop~index$の最大：
◎
While i is less than or equal to the greatest supported property index on the object:
</p>

				<ol>
					<li>
%V := ［
%i は`被support~prop~index$であるならば ~index %i に位置する有index~propの値 ／
~ELSE_ `null^V
］
◎
Let V be the value of the indexed property with index i if i is a supported property index, or null otherwise.
</li>
					<!--cp-append-serialized-->
					<li>
%i ← %i + 1
◎
Set i to i + 1.
</li>
				</ol>
			</li>
			<!--cp-ret-map-->

		</ol>
	</dd>
	<dt>
単独の属性：
◎
A single attribute:
</dt>
	<dd>

<pre class="syntax">
serializer = `attribute-identifier^i;
</pre>

<p><!-- copy* -->
識別子は，~ifc上で宣言された属性の識別子で~MUST。
その属性は，`直列化可能な型$を持た~MUST。
◎
The identifier MUST be the identifier of an attribute declared on the interface, and this attribute MUST have a serializable type.
</p>

<!--cp-ser-behavior-as-follows-->

		<ol class="algorithm">
			<li>
~RET 
指定された識別子を伴う属性の値を`直列化ed値に変換-$した結果
◎
Let V be the value of the attribute with the specified identifier.
◎
Return the result of converting V to a serialized value.
</li>
		</ol>
	</dd>
</dl>



<div class="note"><p>
一連の~entryは，特定0の順序により~mapに追加される。
ECMAScript 言語束縛においては，~propが~objに追加される順序に従うものと定義される。
この順序は
`JSON.stringify^c
から生成される直列化に波及するので。
◎
Entries are added to maps in a particular order so that in the ECMAScript language binding it is defined what order properties are added to objects. This is because this order can influence the serialization that JSON.stringify can produce.
</p></div>




<p>
各種
`直列化可能な型@, および
それらを
`直列化ed値に変換-@
する方法は、次で与えられる：
◎
The list of serializable types and how they are converted to serialized values is as follows:
</p>

<dl class="switch">
	<dt>`long long$T</dt>
	<dt>`unsigned long long$T</dt>
	<dd>
最も近い等価な `double$T 値に変換される（
<a href="#_int-toES_">この IDL 整数~型を ECMAScript `Number^t 値に変換する</a>
ときと同様に）
◎
converted by choosing the closest equivalent double value (as when converting a long long to an ECMAScript Number value)
◎
converted by choosing the closest equivalent double value (as when converting a unsigned long long to an ECMAScript Number value)
</dd>
	<dt>他のすべての`整数~型$</dt>
	<dt>`float$T</dt>
	<dd>
等価な `double$T 値に変換される
◎
converted by choosing the equivalent double value
</dd>
	<dt>`double$T</dt>
	<dt>`boolean$T</dt>
	<dt>`DOMString$T</dt>
	<dd>
それぞれの型の，同じ値
◎
the same value of the respective type
</dd>
	<dt>`列挙~型$◎an enumeration type</dt>
	<dd>
等価な `DOMString$T 値
◎
the equivalent DOMString value
</dd>

	<dt>`USVString$T◎USVString</dt>
	<dd>
所与の`Unicode ~scalar値$の並びを UTF-16 に符号化して生産される `DOMString$T
◎
the DOMString produced by encoding the given sequence of Unicode scalar values in UTF-16
</dd>

	<dt>`ByteString$T◎ByteString</dt>
	<dd>
各~符号単位と対応する~byteが数として同じであるような，等価な `DOMString$T 値
◎
the equivalent DOMString value where each code unit has the same value as the corresponding byte value
</dd>


	<dt>`~nullable型$であって，その`内部型$は直列化可能であるもの
◎a nullable serializable type</dt>
	<dd>
値が `null^T ならば `null^T に変換され、他の場合は，その`内部型$に従って変換される
◎
converted to null if that is its value, otherwise converted as per its inner type
</dd>
	<dt>
`共用体~型$であって，そのどの`~mb型$も直列化可能であるもの
◎
a union type where all of its member types are serializable types
</dt>
	<dd>
その`固有型$に従って変換される
◎
converted as per its specific type
</dd>
	<dt>
`連列~型$であって，その要素~型は直列化可能であるもの
◎
a sequence type that has a serializable type as its element type
</dt>
	<dd>
~listに変換される。
その各~要素は，連列の中の対応する要素を`直列化ed値に変換-$した結果で与えられる。
◎
converted to a list where each element is the result of converting its corresponding sequence element to a serialized value
</dd>
	<dt>
<!-- `辞書$ -->
`辞書~型$であって，そのどの`辞書~mb$も直列化可能な型であるもの
◎
a dictionary where all of its members have serializable types
</dt>
	<dd>
~mapに変換される。
その一連の~entryは、辞書に`在する$各~mb %m に対する~entry［
~key ＝ %m の識別子,
~value ＝ ［
%m の値を`直列化ed値に変換-$した結果
］］で与えられる。
◎
converted to a map consisting of an entry for each dictionary member that is present, where the entry’s key is the identifier of the dictionary member and its value is the result of converting the dictionary member’s value to a serializable type
</dd>
	<dt>
`~ifc型$であって，`直列化子$を持つもの
◎
an interface type that has a serializer
</dt>
	<dd>
~objの直列化子を呼出して変換される
◎
converted by invoking the object’s serializer
</dd>
</dl>

<p>
`直列化子$は `serializer^c ~keywordを伴う`演算$を利用して指定することもできる：
◎
Serializers can also be specified using an operation with the serializer keyword:
</p>

<pre class="syntax">
serializer `type^i `identifier^i();
</pre>

<p>
演算を伴って宣言される`直列化子$は、ゼロ個の引数をとり, かつ
`直列化可能な型$を返すものとして，宣言され~MUST。
◎
Serializers declared with operations MUST be declared to take zero arguments and return a serializable type.
</p>

<p>
`直列化子$が演算を伴って宣言されている~ifcにおける，`直列化の挙動$
は、その演算を呼出して返される値を`直列化ed値に変換-$した結果で与えられる。
◎
The serialization behavior of the interface with a serializer declared with an operation is the result of converting the value returned from invoking the operation to a serialized value.
</p>

<div class="grammar">
Serializer
SerializerRest
SerializationPattern
SerializationPatternMap
SerializationPatternList
Identifiers
</div>

<div class="example">
<p>
次の
 `IDL 片$は、注釈文にて定義される`直列化子$を持つ， `Transaction^T ~ifcを定義する：
◎
The following IDL fragment defines an interface Transaction that has a serializer defines in prose:
</p>

<pre class="idl-code">
interface Transaction {
  readonly attribute Account from;
  readonly attribute Account to;
  readonly attribute double amount;
  readonly attribute DOMString description;
  readonly attribute unsigned long number;

  serializer;
};

interface Account {
  DOMString name;
  unsigned long number;
};
</pre>

<p>
直列化子は次の様に定義し得る：
◎
The serializer could be defined as follows:
</p>

	<blockquote>
<p>
`Transaction^T ~ifcの`直列化の挙動$は、次の~algoで与えられる。
ここで %O は `Transaction^T を実装する~objであるとする：
◎
The serialization behavior of the Transaction interface is to run the following algorithm, where O is the object that implements Transaction:
</p>

		<ol class="algorithm">
			<!--cp-let-empty-map-->
			<li>
［
~key ＝ `from^l,
~value ＝ ［
%O 上の `from^M 属性から参照されている `Account^T ~obj上の `number^M 属性~値に対する`直列化ed値$
］］なる~entryを %map に追加する。
◎
Add an entry to map whose key is “from” and whose value is the serialized value of the number attribute on the Account object referenced by the from attribute on O.
</li>
			<li>
［
~key ＝ `to^l,
~value ＝ ［
%O 上の `to^M 属性から参照されている `Account^T ~obj上の `number^M 属性~値に対する`直列化ed値$
］］なる~entryを %map に追加する。
◎
Add an entry to map whose key is “to” and whose value is the serialized value of the number attribute on the Account object referenced by the from attribute on O.
</li><!-- *from attribute → to 〜 -->
			<li>
属性 `amount^c, `description^c のそれぞれに対し，［
~key ＝ その属性の`識別子$,
~value ＝ ［
%O 上のその属性~値に対する`直列化ed値$
］］なる~entryを %map に追加する。
◎
For both of the attributes amount and description, add an entry to map whose key is the identifier of the attribute and whose value is the serialized value of the value of the attribute on O.
</li>
			<!--cp-ret-map-->

		</ol>
	</blockquote>
<p>
`Account^T ~obj自身を直列化可能にしてもよいのであれば、`直列化~pattern$の利用により，注釈文による`直列化の挙動$を定義せずに済ませられるようになる：
◎
If it was acceptable for Account objects to be serializable on their own, then serialization patterns could be used to avoid having to define the serialization behavior in prose:
</p>

<pre class="idl-code">
interface Transaction {
  readonly attribute Account from;
  readonly attribute Account to;
  readonly attribute double amount;
  readonly attribute DOMString description;
  readonly attribute unsigned long number;

  serializer = { from, to, amount, description };
};

interface Account {
  DOMString name;
  unsigned long number;

  serializer = number;
};
</pre>

<p>
ECMAScript 言語束縛においては、
`Transaction^T ~obj上に `toJSON^c ~methが存在することになる：
◎
In the ECMAScript language binding, there would exist a toJSON method on Transaction objects:
</p>

<pre class="es-code">
// <span title="Get an instance of Transaction."
>`Transaction^T の~instanceを取得-</span>
var txn = getTransaction();


/* <span title="Evaluates to an object like this:"
> 次の様な~objに評価される：</span>
 {
   from: 1234
   to: 5678
   amount: 110.75
   description: "dinner"
 }
*/

txn.toJSON();

// <span title="Evaluates to a string like this:"
>次の様な文字列に評価される：</span>
// '{"from":1234,"to":5678,"amount":110.75,"description":"dinner"}'
JSON.stringify(txn);
</pre>
</div>

				</section>
				<section id="idl-indexed-properties">
<h5 title="Indexed properties">3.2.4.4. 有index~prop</h5>

<p>
`有index~prop取得子$を定義する`~ifc$は、
`有index~propを~supportする@
という。
◎
An interface that defines an indexed property getter is said to support indexed properties.
</p>

<p>
~ifcが`有index~propを~supportする$場合、その~ifc定義には，所与の任意の時点で~objに~indexingし得る~indexについての記述も付随してい~MUST。
これらの~indexは
`被support~prop~index@
と呼ばれる。
◎
If an interface supports indexed properties, then the interface definition MUST be accompanied by a description of what indices the object can be indexed with at any given time. These indices are called the supported property indices.
</p>

<p>
`有index~prop取得子$は、１個の `unsigned long$T 引数をとるものとして宣言され~MUST。
有index~propの設定子は、２個の引数をとり,
第一~引数が `unsigned long$T をとるものとして宣言され~MUST。
◎
Indexed property getters MUST be declared to take a single unsigned long argument. Indexed property setters MUST be declared to take two arguments, where the first is an unsigned long.
</p>

<pre class="syntax">
getter `type^i `identifier^i(unsigned long `identifier^i);
setter `type^i `identifier^i(unsigned long `identifier^i, `type^i `identifier^i);

getter `type^i (unsigned long `identifier^i);
setter `type^i (unsigned long `identifier^i, `type^i `identifier^i);
</pre>

<p>
次の要件が，有index~propの［
取得子, 設定子
］の定義に適用される：
◎
The following requirements apply to the definitions of indexed property getters and setters:
</p>
<ul>
	<li>
<p>
`有index~prop取得子$の宣言に利用された`演算$が`識別子$を：
</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の`被support~prop~index$による~indexingの際に返される値は、その演算を，その~indexを唯一の引数に渡して呼出したときと同じになる。
</li>
			<li>
持たない場合、その~ifc定義には，所与の~indexに対し
`有index~propの値を決定する@
方法についての記述も付随してい~MUST。
</li>
		</ul>
◎
If an indexed property getter was specified using an operation with an identifier, then the value returned when indexing the object with a given supported property index is the value that would be returned by invoking the operation, passing the index as its only argument. If the operation used to declare the indexed property getter did not have an identifier, then the interface definition must be accompanied by a description of how to determine the value of an indexed property for a given index.
</li>
	<li>
<p>
`有index~prop設定子$の宣言に利用された`演算$が`識別子$を：
</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の
( `被support~prop~index$, 値 )
による，~prop代入のための~indexingの際に生じる挙動は、その演算の第一~引数に~indexを, 第二~引数に値を渡して呼出したときと同じになる。
</li>
			<li>
持たない場合、その~ifc定義には，所与の
( ~prop~index, 値 )
に対し［
`既存の有index~propを設定する@
方法, および
`新たな有index~propを設定する@
方法
］についての記述も付随してい~MUST。
</li>
		</ul>

◎
If an indexed property setter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property assignment with a given supported property index and value is the same as if the operation is invoked, passing the index as the first argument and the value as the second argument. If the operation used to declare the indexed property setter did not have an identifier, then the interface definition must be accompanied by a description of how to set the value of an existing indexed property and how to set the value of a new indexed property for a given property index and value.
</li>
</ul>


<div class="note">
<p>
`有index~prop$の［
取得子／設定子
］が`識別子$を伴う`演算$を利用して指定されている場合、~objに対する［
`被support~prop~index$でない整数
］による~indexingは，その~indexによる演算の呼出しと同じ挙動をなぞるとは限らないことに注意。
この場合における実際の挙動は、言語束縛~特有になる。
◎
Note that if an indexed property getter or setter is specified using an operation with an identifier, then indexing an object with an integer that is not a supported property index does not necessarily elicit the same behavior as invoking the operation with that index. The actual behavior in this case is language binding specific.
</p>

<p>
ECMAScript 言語束縛においては，~~通常の~prop~lookupが行われる。
例えば次の IDL では：
◎
In the ECMAScript language binding, a regular property lookup is done. For example, take the following IDL:
</p>
<!-- language -->

<pre class="idl-code">
interface A {
  getter DOMString toWord(unsigned long index);
};
</pre>

<p>
`A^T を実装している~objの`被support~prop~index$は，範囲［
0 ≤ %index &lt; 2
］とする。
また、 `toWord^M は，引数の数字を英単語に変換した文字列を返すように定義されているとする。
範囲~外の~indexにより`演算$を呼出したときの挙動は，~objの直接的な~indexingとは異なる：
◎
Assume that an object implementing A has supported property indices in the range 0 ≤ index &lt; 2. Also assume that toWord is defined to return its argument converted into an English word. The behavior when invoking the operation with an out of range index is different from indexing the object directly:
</p>

<pre class="es-code">
var a = getA();

a.toWord(0);  // <span title="Evaluates to &quot;zero&quot;."
>`zero^l  に評価される。</span>
a[0];         // <span title="Also evaluates to &quot;zero&quot;."
>これも `zero^l に評価される。</span>

a.toWord(5);  // <span title="Evaluates to &quot;five&quot;."
>`five^l に評価される。</span>
a[5];         // <span title="Evaluates to undefined, since there is no property &quot;5&quot;."
>~prop `5^l は存在しないので `undefined^v に評価される。</span>
</pre>
</div>

<div class="example">
<p>
次の `IDL 片$は
名前または~indexによる値の取得0と設定を許容する
`OrderedMap^T
~ifcを定義する：
◎
The following IDL fragment defines an interface OrderedMap which allows retrieving and setting values by name or by index number:
</p>

<pre class="idl-code">
interface OrderedMap {
  readonly attribute unsigned long size;

  getter any getByIndex(unsigned long index);
  setter void setByIndex(unsigned long index, any value);

  getter any get(DOMString name);
  setter void set(DOMString name, any value);
};
</pre>

<p>
すべての特殊~演算が識別子を伴う演算を利用して宣言されているので、追加を要する唯一の注釈文は，これらの集合が持つ~keyを与える記述になる。
`OrderedMap^T 内に存在しない項目に対する~lookupが試みられた場合に対し，
`get()^c 演算が `null^V を返すように定義されているとするとき、次の２~~文で足りるであろう：
◎
Since all of the special operations are declared using operations with identifiers, the only additional prose that is necessary is that which describes what keys those sets have. Assuming that the get() operation is defined to return null if an attempt is made to look up a non-existing entry in the OrderedMap, then the following two sentences would suffice:
</p>

	<blockquote>
<p>
`OrderedMap^T を実装する~obj %map は、範囲［
0 ≤&nbsp;%index&nbsp;&lt;&nbsp;`map.size^c
］の`有index~propを~supportする$。
◎
An object map implementing OrderedMap supports indexed properties with indices in the range 0 ≤ index &lt; map.size.
</p>

<p>
そのような~objは、
`get()^c に渡されたときに非 `null^V 値が返されるような，どの名前に対しても、有名~propを~supportする。
◎
Such objects also support a named property for every name that, if passed to get(), would return a non-null value.
</p>
	</blockquote>

<p>
`es-platform-objects$sec
にて述べられるように、 ECMAScript 実装は［
有名, 有index
］いずれの~propの集合に対しても、その集合に属する各項に対応する~propを［
`OrderedMap^T を実装している`~platform~obj$
］上に，作成することになるであろう。
下に示す様に、これらの~propを，~objの~methの呼出しと同じ仕方で，~objとのやり取りに利用できる：
◎
As described in section 4.8, an ECMAScript implementation would create properties on a platform object implementing OrderedMap that correspond to entries in both the named and indexed property sets. These properties can then be used to interact with the object in the same way as invoking the object’s methods, as demonstrated below:
</p>

<pre class="es-code">
// <span title="Assume map is a platform object implementing the OrderedMap interface."
>%map は `OrderedMap^T ~ifcを実装する~platform~objであるとする。</span>
var map = getOrderedMap();
var x, y;

x = map[0];       /*<span title="If map.length &gt; 0, then this is equivalent to:

  x = map.getByIndex(0)

since a property named &quot;0&quot; will have been placed on map.
Otherwise, x will be set to undefined, since there will be
no property named &quot;0&quot; on map.">
                   `map.length^c &gt; 0 ならば、次と等価になる：
                   
                     `x = map.getByIndex(0)^c
                   
                   （名前 `0^l の~propが %map 上に置かれるので）。
                   他の場合、名前 `0^l の~propは %map 上にないので，
                   %x は `undefined^v に設定されることになる。</span> */

map[1] = false;   /*<span title="This will do the equivalent of:

  map.setByIndex(1, false)">
                   これは、次と等価な動作になる：
                  
                     `map.setByIndex(1, false)^c
                  </span> */

y = map.apple;    /*<span title="If there exists a named property named &quot;apple&quot;, then this
will be equivalent to:

  y = map.get('apple')

since a property named &quot;apple&quot; will have been placed on
map.  Otherwise, y will be set to undefined, since there
will be no property named &quot;apple&quot; on map.">
                   名前 `apple^l の有名~propが存在する場合、
                   名前 `apple^l の~propが %map 上にあり，
                   次と等価な動作になる：
                  
                     `y = map.get('apple')^c
                  
                   他の場合、名前 `apple^l の~propは %map 上にないので，
                   %y は `undefined^v に設定されることになる。</span> */

map.berry = 123;  /*<span title="This will do the equivalent of:

  map.set('berry', 123)">
                   これは、次と等価な動作になる：
                  
                     `map.set('berry', 123)^c
                  </span> */

delete map.cake;  /*<span title="If a named property named &quot;cake&quot; exists, then the &quot;cake&quot;
property will be deleted, and then the equivalent to the
following will be performed:

	  map.remove(&quot;cake&quot;)">
                   有名~prop `cake^l が存在するなら、
                   `cake^l ~propが削除され，
                   次と等価な動作になる：
                  
                     `map.remove("cake")^c
                  </span> */

</pre></div>
				</section>
				<section id="idl-named-properties">
<h5 title="Named properties">3.2.4.5. 有名~prop</h5>


<p>
`有名~prop取得子$を定義する`~ifc$は、
`有名~propを~supportする@
という。
◎
An interface that defines a named property getter is said to support named properties.
</p>

<p>
`有名~propを~supportする$~ifcの~ifc定義には、［
所与の任意の時点で~objに~indexingし得るような，順序付けられた名前の集合
］についての記述も付随してい~MUST。
これらの名前は、
`被support~prop名@
と呼ばれる。
◎
If an interface supports named properties, then the interface definition MUST be accompanied by a description of the ordered set of names that can be used to index the object at any given time. These names are called the supported property names.
</p>

<p>
有名~propの取得子と削除子は、１個の `DOMString$T を引数にとるものとして宣言され~MUST。
有名~propの設定子は、２個の引数をとり，第一~引数に `DOMString$T をとるものとして宣言され~MUST。
◎
Named property getters and deleters MUST be declared to take a single DOMString argument. Named property setters MUST be declared to take two arguments, where the first is a DOMString.
</p>

<pre class="syntax">
getter `type^i `identifier^i(DOMString `identifier^i);
setter `type^i `identifier^i(DOMString `identifier^i, `type^i `identifier^i);
deleter `type^i `identifier^i(DOMString `identifier^i);

getter `type^i (DOMString `identifier^i);
setter `type^i (DOMString `identifier^i, `type^i `identifier^i);
deleter `type^i (DOMString `identifier^i);
</pre>

<p>
次の要件が，有名~propの［
取得子, 設定子, 削除子
］の定義に適用される：
◎
The following requirements apply to the definitions of named property getters, setters and deleters:
</p>
<ul>
	<li>
<p>
`有名~prop取得子$の宣言に利用された`演算$が`識別子$を：
</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の`被support~prop名$による~indexingの際に返される値は、その演算を，その~prop名を唯一の引数に渡して呼出したときと同じになる。
</li>
			<li>
持たない場合、その~ifc定義には，所与の~prop名に対し
`有名~propの値を決定する@
方法についての記述も付随してい~MUST。
</li>
		</ul>

◎
If a named property getter was specified using an operation with an identifier, then the value returned when indexing the object with a given supported property name is the value that would be returned by invoking the operation, passing the name as its only argument. If the operation used to declare the named property getter did not have an identifier, then the interface definition must be accompanied by a description of how to determine the value of a named property for a given property name.
</li>
	<li>
<p>
`有名~prop設定子$の宣言に利用された`演算$が`識別子$を：
</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の
( `被support~prop名$, 値 )
による，~prop代入のための~indexingの際に生じる挙動は、
その演算の第一~引数に~prop名を, 第二~引数に値を渡して呼出したときと同じになる。
</li>
			<li>
持たない場合、その~ifc定義には，所与の
( ~prop名, 値 )
に対し［
`既存の有名~propを設定する@
方法, および
`新たな有名~propを設定する@
方法
］についての記述も付随してい~MUST。
</li>
		</ul>
◎
If a named property setter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property assignment with a given supported property name and value is the same as if the operation is invoked, passing the name as the first argument and the value as the second argument. If the operation used to declare the named property setter did not have an identifier, then the interface definition must be accompanied by a description of how to set the value of an existing named property and how to set the value of a new named property for a given property name and value.
</li>
	<li>
<p>
`有名~prop削除子$の宣言に利用された`演算$が`識別子$を：
</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の`被support~prop名$による，~prop削除のための~indexingの際に生じる挙動は、その演算を，その~prop名を唯一の引数に渡して呼出したときと同じになる。
</li>
			<li>
持たない場合、その~ifc定義には，所与の~prop名に対し
`既存の有名~propを削除する@
方法についての記述も付随してい~MUST。
</li>
		</ul>
◎
If a named property deleter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property deletion with a given supported property name is the same as if the operation is invoked, passing the name as the only argument. If the operation used to declare the named property deleter did not have an identifier, then the interface definition must be accompanied by a description of how to delete an existing named property for a given property name.
</li>
</ul>


<div class="note"><p>
`有index~prop$のときと同様に，`有名~prop$の［
取得子／設定子／削除子
］が`識別子$を伴う`演算$を利用して指定された場合、~objに対する［
`被support~prop名$でない名前
］による~indexingは，その名前による演算の呼出しと同じ挙動をなぞるとは限らないことに注意。
挙動は、言語束縛~特有になる。
◎
As with indexed properties, if an named property getter, setter or deleter is specified using an operation with an identifier, then indexing an object with a name that is not a supported property name does not necessarily elicit the same behavior as invoking the operation with that name; the behavior is language binding specific.
</p></div>

				</section>
			</section>
			<section id="idl-static-attributes-and-operations">
<h4 title="Static attributes and operations">3.2.5. 静的~属性と静的~演算</h4>


<p>
<span class="v2">`静的~属性@</span>,
`静的~演算@
は、それが宣言される`~ifc$の個々の~instance上には結付けられないものであり、代わりに，その ~ifc自身に結付けられる。
静的~属性と静的~演算は，それらの宣言の中で `static^c ~keywordを利用して宣言される。
◎
Static attributes and static operations are ones that are not associated with a particular instance of the interface on which it is declared, and is instead associated with the interface itself. Static attributes and operations are declared by using the static keyword in their declarations.
</p>

<p>
静的~演算の呼出しや静的~属性の取得-／設定-が，~ifcの~instanceへの参照を通して可能かどうかは、言語束縛~特有になる。
◎
It is language binding specific whether it is possible to invoke a static operation or get or set a static attribute through a reference to an instance of the interface.
</p>

<p>
静的~演算／静的~属性は，`呼戻~ifc$上で宣言されては~MUST_NOT。
◎
Static attributes and operations MUST NOT be declared on callback interfaces.
</p>

<div class="grammar">
StaticMember
StaticMemberRest
</div>

<div class="example">
<p>
次の `IDL 片$は、静的~演算が宣言されている
`Circle^T ~ifcを定義する：
◎
The following IDL fragment defines an interface Circle that has a static operation declared on it:
</p>

<pre class="idl-code">
interface Point { /* ... */ };

interface Circle {
  attribute double cx;
  attribute double cy;
  attribute double radius;

  static readonly attribute long triangulationCount;
  static Point triangulate(Circle c1, Circle c2, Circle c3);
};
</pre>

<p>
ECMAScript 言語束縛においては、
`Circle^T に対応する`~ifc~obj$上に，
`triangulate^M に対応する `Function^t ~obj, および
`triangulationCount^M に対応する~accessor~prop
が存在することになる：
◎
In the ECMAScript language binding, the Function object for triangulate and the accessor property for triangulationCount will exist on the interface object for Circle:
</p>

<pre class="es-code">
var circles = getCircles();        // <span title="an Array of Circle objects"
>`Circle^T ~objの `Array^t</span>

typeof Circle.triangulate;         // <span id="cp-eval-function" title="Evaluates to &quot;function&quot;"
>`function^l に評価される。</span>
typeof Circle.triangulationCount;  // <span title="Evaluates to &quot;number&quot;"
>`number^l に評価される。</span>
Circle.prototype.triangulate;      // <span id="cp-eval-undefined" title="Evaluates to undefined."
>`undefined^v に評価される。</span>
Circle.prototype.triangulationCount;  // <span title="Also evaluates to undefined"
>これも `undefined^v に評価される。</span>
circles[0].triangulate;            // <span title="As does this"
>これも。</span>
circles[0].triangulationCount;     // <span title="And this"
>これも。</span>

// <span title="Call the static operation"
>静的~演算の~call</span>
var triangulationPoint = Circle.triangulate(circles[0], circles[1], circles[2]);
// <span title="Find out how many triangulations we have done"
>`triangulate^M を呼んだ回数を調べる</span>
window.alert(Circle.triangulationCount);

</pre>

	<!--JAVA
In the Java language binding, however, the triangulate method ...
-->
</div>
			</section>
			<section id="idl-overloading">
<h4 title="Overloading">3.2.6. 多重定義</h4>


<p>
`~ifc$上に定義される
`正則~演算$／`静的~演算$
が，その~ifc上の同じ種類の別の（正則／静的）演算と
同じ`識別子$を持つ場合、その演算は
`多重定義@
されているという。
その~ifcを実装する~obj上で，それらの演算のどれかを呼出すために多重定義された演算の識別子が利用された際に，どの演算が実際に呼出されるかは、演算に渡された引数の個数と型により決定される。
~ifc上に複数の`旧来呼出子$が定義されている場合も、それらの旧来呼出子は多重定義されているという。
ECMAScript 言語束縛においては
`Constructor$x も多重定義され得る。
多重定義された［
演算／旧来呼出子／構築子
］がとり得る引数の指定には一定の制約があり、これらの制約を記述するため，`有効~多重定義~集合$の~~概念が利用される。
◎
If a regular operation or static operation defined on an interface has an identifier that is the same as the identifier of another operation on that interface of the same kind (regular or static), then the operation is said to be overloaded. When the identifier of an overloaded operation is used to invoke one of the operations on an object that implements the interface, the number and types of the arguments passed to the operation determine which of the overloaded operations is actually invoked. If an interface has multiple legacy callers defined on it, then those legacy callers are also said to be overloaded. In the ECMAScript language binding, constructors can be overloaded too. There are some restrictions on the arguments that overloaded operations, legacy callers and constructors can be specified to take, and in order to describe these restrictions, the notion of an effective overload set is used.
</p>

<p>
`演算$／`旧来呼出子$は、複数の［
`~ifc$定義, および その`部分的~ifc定義$
］にまたがって多重定義されては~MUST_NOT。
◎
Operations and legacy callers MUST NOT be overloaded across interface and partial interface definitions.
</p>

<div class="note">
<p>
例えば，次の様な `f^T, `g^T の多重定義は許容されない：
◎
For example, the overloads for both f and g are disallowed:
</p>

<pre class="idl-code">
interface A {
  void f();
};

partial interface A {
  void f(double x);
  void g();
};

partial interface A {
  void g(DOMString x);
};
</pre>

<p>
構築子の多重定義については、元々`部分的~ifc定義$上には［
`Constructor$x, `NamedConstructor$x
］`拡張属性$の出現が許容されていないので，同様の制約は~~自動的に満たされることに注意。
◎
Note that the [Constructor] and [NamedConstructor] extended attributes are disallowed from appearing on partial interface definitions, so there is no need to also disallow overloading for constructors.
</p>
</div>


<div class="p">
<p>
`有効~多重定義~集合@
とは、個々の
`関数類@
— ［
`演算$ ／
構築子（ `Constructor$x または `NamedConstructor$x により指定される） ／
`旧来呼出子$ ／
`呼戻~関数$
］ —
に許容され得る呼出を表現するものである。
</p>

<p class="trans-note">【
“関数類（引数を伴って~callし得る IDL 構成子）”
という語は、簡潔に総称するためにこの訳に導入した，非公式な用語である。
】</p>

<p>
`有効~多重定義~集合$を算出する~algoは、次に挙げる６種の IDL 構成子に対し演算する。
算出するために必要な入力は、渡される引数の個数, および
`関数類$の種別に応じて，以下に示されるものになる：
</p>
◎
An effective overload set represents the allowable invocations for a particular operation, constructor (specified with [Constructor] or [NamedConstructor]), legacy caller or callback function. The algorithm to compute an effective overload set operates on one of the following six types of IDL constructs, and listed with them below are the inputs to the algorithm needed to compute the set.
</div>


<dl class="switch">
	<dt>正則~演算◎For regular operations</dt>
	<dt>静的~演算◎For static operations</dt>
	<dd>
`演算$が見出された`~ifc$, および
演算の`識別子$
◎
the interface on which the operations are to be found
◎
the identifier of the operations
◎
the number of arguments to be passed
</dd>

	<dt>旧来呼出子◎For legacy callers</dt>
	<dd>
`旧来呼出子$が見出された`~ifc$
◎
the interface on which the legacy callers are to be found
◎
the number of arguments to be passed
</dd>
	<dt>構築子◎For constructors</dt>
	<dd>
`Constructor$x `拡張属性$が見出された`~ifc$
◎
the interface on which the [Constructor] extended attributes are to be found
◎
the number of arguments to be passed
</dd>

	<dt>有名~構築子◎For named constructors</dt>
	<dd>
`NamedConstructor$x `拡張属性$が見出された`~ifc$, および
有名~構築子の`識別子$
◎
the interface on which the [NamedConstructor] extended attributes are to be found
◎
the identifier of the named constructors
◎
the number of arguments to be passed
</dd>

	<dt>呼戻~関数◎For callback functions</dt>
	<dd>
`呼戻~関数$
◎
the callback function
◎
the number of arguments to be passed
</dd>

</dl>

<p>
有効~多重定義~集合は、他のものと伴に，~ifc上に多重定義された`関数類$が多義性を孕んでいるかどうか決定するために利用される。
◎
An effective overload set is used, among other things, to determine whether there are ambiguities in the overloaded operations, constructors and callers specified on an interface.
</p>

<div >
<p>
有効~多重定義~集合の各~要素は，~tuple
&lt;`ol-callable^, `ol-type-list^, `ol-optionality-list^&gt;
である：
</p>

<ul>
	<li>
<dfn id="ol-callable">%callable</dfn>
は、`関数類$の種別に応じて，次になる：
		<ul>
			<li>
［
正則~演算／静的~演算／旧来呼出子
］に対しては，その いずれかの演算。
</li>

			<li>
［
構築子／有名~構築子
］に対しては，その いずれかの拡張属性。
</li>

			<li>
［
呼戻~関数
］に対しては，呼戻~関数~自身。
</li>
		</ul>
	</li>

	<li>
<dfn id="ol-type-list"><var>型~list</var></dfn>
は、 `ol-callable^ の一連の引数にあてがわれている IDL 型の~listである。
</li>

	<li>
<dfn id="ol-optionality-list"><var>省略可否~list</var></dfn>
は，［
`省略可否 値@
と称される値
］の~listであり、それぞれの値は［
所与の~indexに位置する引数が［
“`必須^C”,
“`省略可^C”,
“`可変個^C”
］のいずれであるか
］を指示する。
</li>
</ul>

<p>
各~tupleは、［
所与の一連の型
］による引数~値~listに許容され得る`関数類$の呼出を表現する。
`随意~引数$や［
`可変個の引数をとる$`関数類$ （すなわち，演算か構築子）
］の利用に因り、有効~多重定義~集合~内には，同じ種類の`関数類$を識別する複数の~entryが存在し得る。
</p>

◎
The elements of an effective overload set are tuples of the form &lt;callable, type list, optionality list&gt;. If the effective overload set is for regular operations, static operations or legacy callers, then callable is an operation; if it is for constructors or named constructors, then callable is an extended attribute; and if it is for callback functions, then callable is the callback function itself. In all cases, type list is a list of IDL types, and optionality list is a list of three possible optionality values – “required”, “optional” or “variadic” – indicating whether the argument at a given index was declared as being optional or corresponds to a variadic argument. Each tuple represents an allowable invocation of the operation, constructor, legacy caller or callback function with an argument value list of the given types. Due to the use of optional arguments and variadic operations and constructors, there may be multiple entries in an effective overload set identifying the same operation or constructor.
</div>


<p>
下の~algoが，有効~多重定義~集合を算出する方法を記述する。
必要に応じて，上述の入力~変数が利用される：
◎
The algorithm below describes how to compute an effective overload set. The following input variables are used, if they are required:
</p>
<ul>
	<li>
%A は［
演算／有名~構築子
］の識別子
◎
the identifier of the operation or named constructor is A
</li>
	<li>
%N は引数個数
◎
the argument count is N
</li>
	<li>
%I は~ifc
◎
the interface is I
</li>
	<li>
%C は呼戻~関数
◎
the callback function is C
</li>
</ul>

<p>
拡張属性に対する引数が示されるときはいつでも，その拡張属性の`有名~引数~list$の引数を指しているものとする。
◎
Whenever an argument of an extended attribute is mentioned, it is referring to an argument of the extended attribute’s named argument list.
</p>

<ol class="algorithm">
	<li>
%S :← ∅
◎
Initialize S to ∅.
</li>
	<li>
<p>
%F := 有効~多重定義~集合の種類に応じて，次で与えられる要素の集合：
◎
Let F be a set with elements as follows, according to the kind of effective overload set:
</p>
		<dl class="switch">
			<dt>正則~演算◎For regular operations</dt>
			<dd><p>
%I 上で定義された`正則~演算$のうち，識別子が %A であるもの
◎
The elements of F are the regular operations with identifier A defined on interface I.
</p></dd>
			<dt>静的~演算◎For static operations</dt>
			<dd><p>
%I 上で定義された`静的~演算$のうち，識別子が %A であるもの
◎
The elements of F are the static operations with identifier A defined on interface I.
</p></dd>
			<dt>構築子◎For constructors</dt>
			<dd><p>
%I 上の `Constructor$x `拡張属性$
◎
The elements of F are the [Constructor] extended attributes on interface I.
</p></dd>
			<dt>有名~構築子◎For named constructors</dt>
			<dd><p>
%I 上の `NamedConstructor$x `拡張属性$のうち，その`有名~引数~list$の識別子が %A であるもの
◎
The elements of F are the [NamedConstructor] extended attributes on interface I whose named argument lists’ identifiers are A.
</p></dd>
			<dt>旧来呼出子◎For legacy callers</dt>
			<dd><p>
%I 上で定義された `旧来呼出子$
◎
The elements of F are the legacy callers defined on interface I.
</p></dd>
			<dt>呼戻~関数◎For callback functions</dt>
			<dd><p>
呼戻~関数~自身である %C （唯一つ）
◎
The single element of F is the callback function itself, C.
</p></dd>

		</dl>
	</li>
<!-- v2？
If the effective overload set is for regular operations, then:
...
-->
	<li>
<p>
%maxarg := %F の中の各~要素（`関数類$
）が宣言している引数~個数の最大
— ただし，［
`可変個の引数をとる$ `関数類$
］の中の`末尾~引数$は、 1 個の引数に数える
◎
Let maxarg be the maximum number of arguments the operations, constructor extended attributes or callback functions in F are declared to take. For variadic operations and constructor extended attributes, the argument on which the ellipsis appears counts as a single argument.
</p>

<div class="note"><p>
したがって
`void f(long x, long... y);^c
が宣言している引数~個数は 2 個と見なされる。
◎
So void f(long x, long... y); is considered to be declared to take two arguments.
</p></div>


</li>
	<li>
%m := %maxarg と %N の最大
◎
Let m be the maximum of maxarg and N.
</li>
	<li>
<p>
~FOR
%F 内の~EACH ( %X ) に対し：
◎
For each operation, extended attribute or callback function X in F:
</p>

<p class="trans-note">【
見通しを良くするため、この下位手続きの記述は，原文のものから手を加えている。
】</p>


		<ol class="algorithm">
			<li>
%n := %X が宣言している引数~個数（従って %n ≤ %m ）
◎
Let n be the number of arguments X is declared to take.
</li>
			<li>
~FOR
0 ≤ %i &lt; %n なる ~EACH( 整数 %i ) に対し：
<span class="block">
%t<sub>%i</sub> := ~index %i に位置する %X の引数の型,<br>
%o<sub>%i</sub> := ［
~index %i に位置する %X の引数が［
随意ならば “`省略可^C” ／
~ELSE_ “`必須^C”
］］
</span>
◎
Let t0..n−1 be a list of types, where ti is the type of X’s argument at index i.
◎
Let o0..n−1 be a list of optionality values, where oi is “variadic” if X’s argument at index i is a final, variadic argument, “optional” if the argument is optional, and “required” otherwise.
◎
↓↓Add to S the tuple &lt;X, t0..n−1, o0..n−1&gt;.
</li>

			<li>
<p>
~IF
%X は `可変個の引数をとる$ように宣言されている
⇒
◎
If X is declared to be variadic, then:
◎
↓↓Add to S the tuple &lt;X, t0..n−2, o0..n−2&gt;.
</p>

<div class="note"><p>
ここではまだ，`末尾~引数$には触れない。
◎
This leaves off the final, variadic argument.
</p></div>

				<ol>
					<li>
%o<sub>%n−1</sub> := “`可変個^C” （上の設定を上書き）
◎
↑</li>
					<li>
<p>
~FOR
%n ≤ %i &lt; %m なる ~EACH( 整数 %i ) に対し，~~昇順に：
◎
For every integer i, such that n ≤ i ≤ m−1:
</p>

						<ol>
							<li>
%t<sub>%i</sub> := %t<sub>%n−1</sub>,<br>
%o<sub>%i</sub> := “`可変個^C”
◎
Let u0..i be a list of types, where uj = tj (for j &lt; n) and uj = tn−1 (for j ≥ n).
◎
Let p0..i be a list of optionality values, where pj = oj (for j &lt; n) and pj = “variadic” (for j ≥ n).
</li>
							<li>
~tuple
&lt;%X, (%t<sub>0</sub> … %t<sub>%i</sub>), (%o<sub>0</sub> … %o<sub>%i</sub>)&gt;
を %S に追加する
◎
Add to S the tuple &lt;X, u0..i, p0..i&gt;.
</li>

						</ol>
					</li>
				</ol>
			</li>

			<li>
<p>
~FOR
%n &gt; %i ≥ −1 なる ~EACH( 整数 %i ) に対し，~~降順に：
</p>
				<ol>
					<li>
~IF %i ＝ −1
~THEN
~tuple &lt;%X, (), ()&gt; を %S に追加する；<br>
~BREAK
</li>
					<li>
~tuple
&lt;%X, (%t<sub>0</sub> … %t<sub>%i</sub>), (%o<sub>0</sub> … %o<sub>%i</sub>)&gt;
を %S に追加する
</li>
					<li>
~IF
%o<sub>%i</sub> ＝ “`必須^C”
~THEN
~BREAK
</li>
				</ol>
◎
Initialize i to n−1.
◎
While i ≥ 0:
• If argument i of X is not optional, then break this loop.
• Otherwise, add to S the tuple &lt;X, t0..i−1, o0..i−1&gt;.
• Set i to i−1.
If n &gt; 0 and all arguments of X are optional, then add to S the tuple &lt;X, (), ()&gt; (where “()” represents the empty list).
</li>

		</ol>
	</li>

	<li>
有効~多重定義~集合は %S である
◎
The effective overload set is S.
</li>
</ol>

<div class="example" id="_dist-example-1_">
<p>
次の~ifcに対し：
◎
For the following interface:
</p>

<pre class="idl-code">
interface A {
  /* f1 */ void f(DOMString a);
  /* f2 */ void f(Node a, DOMString b, double... c);
  /* f3 */ void f();
  /* f4 */ void f(Event a, DOMString b, optional DOMString c, double... d);
};
</pre>

<p>
`Node^T と `Event^T を，どの~objからも両方同時に実装できないような，別々の~ifcとするとき、［
識別子 `f^c,
引数個数 4
］の`正則~演算$からなる`有効~多重定義~集合$は：
◎
assuming Node and Event are two other interfaces of which no object can implement both, the effective overload set for regular operations with identifier f and argument count 4 is:
</p>
	<div class="set">
{ &lt;f1, (DOMString), (`必須^C)&gt;,<br>
  &lt;f2, (Node, DOMString), (`必須^C, `必須^C)&gt;,<br>
  &lt;f2, (Node, DOMString, double), (`必須^C, `必須^C, `可変個^C)&gt;,<br>
  &lt;f2, (Node, DOMString, double, double), (`必須^C, `必須^C, `可変個^C, `可変個^C)&gt;,<br>
  &lt;f3, (), ()&gt;,<br>
  &lt;f4, (Event, DOMString), (`必須^C, `必須^C)&gt;,<br>
  &lt;f4, (Event, DOMString, DOMString), (`必須^C, `必須^C, `省略可^C)&gt;,<br>
  &lt;f4, (Event, DOMString, DOMString, double), (`必須^C, `必須^C, `省略可^C, `可変個^C)&gt; }
	</div>
</div>
<!-- 
The following types are considered to be the exactly matchable types:
...
-->

<p>
２つの型が
`判別可能@
であるとは、２つのうち［
`~nullable型を内包する$, または
`辞書~型$である
］ものは高々１つまでであり、かつ，次の３条件のうち 少なくとも１つが成立することを意味する：
◎
Two types are distinguishable if at most one of the two includes a nullable type or is a dictionary type, and at least one of the following three conditions is true:
</p>

<ol>
	<li>

<p>
２つの型が（`~nullable型$の場合はその`内部型$が）下の表に現れ、かつ［
対応する欄に “●” 印がある, または［
対応する欄に英字があって，表の下に指定される追加の要件を満たす
］］：
◎
The two types (taking their inner types if they are nullable types) appear in the following table and there is a “●” mark in the corresponding entry or there is a letter in the corresponding entry and the designated additional requirement below the table is satisfied:
</p>

		<div style="overflow:auto;" id="distinguishable-table">
<table class="matrix">

<thead><tr><th>
<th><span>`boolean$T
</span><th><span>`実数~型$
</span><th><span>`文字列~型$
</span><th><span>`~ifc型$
</span><th><span>`~obj型$
</span><th><span>`呼戻~関数$
</span><th><span>`辞書~型$
</span><th><span>`sequence_T^
</span><th><span>`FrozenArray_T^
</span><th><span>`RegExp$T
</span><th><span>`例外~型$
</span><th><span>`~buffer~source型$
</span><th>
</tr></thead>

<tbody><tr><th>`boolean^T
</th><td><td>●<td>●<td>●<td>●
<td>●<td>●<td>●<td>●<td>●
<td>●<td>●
<th>`boolean^T

</th></tr><tr><th>実数~型
</th><td colspan="1"><td><td>●<td>●<td>●
<td>●<td>●<td>●<td>●<td>●
<td>●<td>●
<th>実数~型

</th></tr><tr><th>文字列~型
</th><td colspan="2"><td><td>●<td>●
<td>●<td>●<td>●<td>●<td>●
<td>●<td>●
<th>文字列~型

</th></tr><tr><th>~ifc
</th><td colspan="3"><td>(a)<td>
<td>(b)<td>(b)<td>●<td>●<td>●
<td>●<td>●
<th>~ifc

</th></tr><tr><th>`object^T
</th><td colspan="4"><td>
<td><td><td><td><td><td><td>
<th>`object^T

</th></tr><tr><th>呼戻~関数
</th><td colspan="5">
<td><td><td>●<td>●<td>●
<td>●<td>●
<th>呼戻~関数

</th></tr><tr><th>辞書
</th><td colspan="6"><td><td>●<td>●<td>●
<td>●<td>●
<th>辞書

</th></tr><tr><th>`sequence&lt;~varT&gt;^T
</th><td colspan="7"><td><td><td>●
<td>●<td>●
<th>`sequence&lt;~varT&gt;^T

</th></tr><tr><th>`FrozenArray_T^
</th><td colspan="8"><td><td>●
<td>●<td>●
<th>`FrozenArray_T^

</th></tr><tr><th>`RegExp^T
</th><td colspan="9">
<td><td>●<td>●
<th>`RegExp^T

</th></tr><tr><th>例外~型
</th><td colspan="10"><td><td>●
<th>例外~型

</th></tr><tr><th>~buffer~source型
</th><td colspan="11"><td>
<th>~buffer~source型

</th></tr></tbody></table>
		</div>

		<ul>
			<li>
<p>
(a) —
識別される２つの`~ifc$が，同じ`~platform~obj$に実装されることは起こり得ない（特に，２つは同じ~ifcでない）, かつ
少なくとも一方は`呼戻~ifc$でない。
◎
The two identified interfaces are not the same, it is not possible for a single platform object to implement both interfaces, and it is not the case that both are callback interfaces.
</p>

			</li>
			<li><p>
(b) —
２つのうち~ifc型の方は`呼戻~ifc$でない。
◎
The interface type is not a callback interface.
</p></li>
		</ul>
	</li>
	<li><p>
一方のみが［
`共用体~型$または~nullable共用体~型
］であって, かつ
その共用体のどの`~mb型$も 他方の型と判別可能である。
◎
One type is a union type or nullable union type, the other is neither a union type nor a nullable union type, and each member type of the first is distinguishable with the second.
</p></li>

	<li><p>
両方の型が［
共用体~型または~nullable共用体~型
］であり, かつ
一方の各~mb型は 他方のどの~mb型とも判別可能である。
◎
Both types are either a union type or nullable union type, and each member type of the one is distinguishable with each member type of the other.
</p></li>
</ol>

<div class="note v2"><p>
`~promise型$は、上の表には現れていないので，他のどの型とも判別可能でないことになる。
◎
Promise types do not appear in the above table, and as a consequence are not distinguishable with any other type.
</p></div>

<p>
`有効~多重定義~集合$の中に，所与の`ol-type-list^長さを持つ~entryが複数ある場合、［
それらのどの２つの~entryに対しても~index %i に位置する２つの型が`判別可能$になる
］ような，~index %i が存在し~MUST。
そのような~indexのうち，最小のものを、
<span class="trans-note">【
その型~listの長さ, もしくはそれらの~entryの集合に対する
】</span>
`判別引数~index@
と呼ぶ。
◎
If there is more than one entry in an effective overload set that has a given type list length, then for those entries there MUST be an index i such that for each pair of entries the types at index i are distinguishable. The lowest such index is termed the distinguishing argument index for the entries of the effective overload set with the given type list length.
</p>
<!--, and either: ...-->

<div class="example">
<p>
前の例に示された有効~多重定義~集合を考える。
`ol-type-list^長さ 2, 3, 4 の集合はそれぞれ複数の~entryを含む。
これらの`ol-type-list^長さのそれぞれに対し，
`Node^T と `Event^T は`判別可能$になるので、`判別引数~index$は 0 である。
◎
Consider the effective overload set shown in the previous example. There are multiple entries in the set with type lists 2, 3 and 4. For each of these type list lengths, the distinguishing argument index is 0, since Node and Event are distinguishable.
</p>

<p>
しかしながら，次の多重定義の利用は妥当でない：
◎
The following use of overloading however is invalid:
</p>

<pre class="idl-code">
interface B {
  void f(long x);
  void f(double x);
};
</pre>

<p>
`long$T と `double$T は判別可能でないので。
<span class="trans-note">【
原文には `long$T ではなく， `DOMString$T と記されているが、それは今や
`double$T と判別可能になったので，修正している。
】</span>
◎
since DOMString and double are not distinguishable.
</p>
</div>

<p>
加えて，所与の`ol-type-list^長さに対する
`判別引数~index$
より小さい，どの~indexに対しても、［
`有効~多重定義~集合$のすべての~entryの，その~indexに位置する［
`ol-type-list^の型／`ol-optionality-list^の真偽~値
］は，同じで~MUST
］。
◎
In addition, for each index j, where j is less than the distinguishing argument index for a given type list length, the types at index j in all of the entries’ type lists MUST be the same and the booleans in the corresponding list indicating argument optionality MUST be the same.
</p>

<div class="example">
<p>
次は妥当でない：
◎
The following is invalid:
</p>

<pre class="idl-code">
interface B {
  /* f1 */ void f(DOMString w);
  /* f2 */ void f(long w, double x, Node y, Node z);
  /* f3 */ void f(double w, double x, DOMString y, Node z);
};
</pre>

<p>
引数個数 4 に対する
有効~多重定義~集合は：
◎
For argument count 4, the effective overload set is:
</p>

	<div class="set">
{ &lt;f1, (DOMString), (`必須^C)&gt;,<br>
  &lt;f2, (long, double, Node, Node), (`必須^C, `必須^C, `必須^C, `必須^C)&gt;,<br>
  &lt;f3, (double, double, DOMString, Node), (`必須^C, `必須^C, `必須^C, `必須^C)&gt; }
	</div>

<p>
であり、`ol-type-list^長さ 4 の~entryを調べると，
`Node^T と `DOMString$T は`判別可能$なので、
`判別引数~index$は 2 になる。
しかしながら，これらの２つの多重定義の~index 0 に位置する引数~型は異なるので、この多重定義は妥当でない。
◎
Looking at entries with type list length 4, the distinguishing argument index is 2, since Node and DOMString are distinguishable. However, since the arguments in these two overloads at index 0 are different, the overloading is invalid.
</p>
</div>

<!-- 
These restrictions on argument types reduce ...
-->


<div class="trans-note">

<p>【
複雑な条件だが，概念的には、共用体~型を利用して，多重定義された宣言を等価な単独の宣言に統合するために必要な条件が意図されている様に見られる。
例えば，<a href="#_dist-example-1_">先に挙げられた例</a>は次の様に書き換え得る：
】</p>

<pre class="idl-code">
interface A {
             /*---f4----*/ /*-f2-*/     /*---f1----*/    /*-f3-*/
  void f(
    optional ( Event     or Node     or   DOMString ) a, /*----*/
    optional   DOMString             b, /*---------------------*/
    optional ( DOMString or double ) c, /*---------------------*/
               double...             d  /*---------------------*/
  );
};
</pre>

<p>【
しかしながら、例えば個別の宣言ごとに異なる拡張属性や特殊~演算が指定されることは，あるかもしれない
— そのような場合、統合できなくなる。
この仕様の中では，そのような指定~法を明示的に禁止している箇所は見当たらない
— 例えば次の様に，拡張属性が多重定義の一部のみに指定されることも、無いとは言い切れない：
】</p>

<pre class="idl-code">
interface A {
  `NewObject$x T f(B a);
              T f(C a);
};
</pre>

</div>


			</section>
			<section id="idl-iterable" class="v2">
<h4 title="Iterable declarations">3.2.7. 可反復~宣言</h4>

<p>
~ifcは
`可反復@
になるように宣言できる。
そのためには、`~ifc$の本体にて
`可反復~宣言@
（`Iterable$g に合致）を利用する。
◎
An interface can be declared to be iterable by using an iterable declaration (matching Iterable) in the body of the interface.
</p>

<pre class="syntax">
iterable&lt;`value-type^i&gt;;
iterable&lt;`key-type^i, `value-type^i&gt;;
</pre>

<p>
可反復として宣言された~ifcを実装している~objは、値の連列を得るために反復し得るようになる。
◎
Objects implementing an interface that is declared to be iterable support being iterated over to obtain a sequence of values.
</p>

<div class="note"><p>
ECMAScript 言語束縛においては、可反復な~ifcは、その`~ifc原型~obj$上に，［
`entries^l, `forEach^l, `keys^l, `values^l, `iterator_symbol^
］~propを持つことになる。
◎
In the ECMAScript language binding, an interface that is iterable will have “entries”, “forEach”, “keys”, “values” and @@iterator properties on its interface prototype object.
</p></div>

<div>
<p>
~parameterとして所与の型の個数が：
</p>

<ul>
	<li>
1 個の場合、~ifcは，その型の値たちを提供する
`値~反復子@
を持つことになる。
</li>
	<li>
2 個の場合、~ifcは，［
~key, 値
］からなる~pairたちを提供する
`~pair反復子@
を持つことになる。
ここで、~pairの~keyは，最初の型の値をとり、~pairの値は，二番目の型の値をとる。
</li>
</ul>
◎
If a single type parameter is given, then the interface has a value iterator and provides values of the specified type. If two type parameters are given, then the interface has a pair iterator and provides value pairs, where the first value is a key and the second is the value associated with the key.
</div>

<p>
`値~反復子$を宣言できる~ifcは、`有index~propを~supportする$, かつ
名前 `length^l の`整数~型$の`属性$を持つもののみで~MUST。
`値~反復子$の値~型は、`有index~prop取得子$が返す型と同じで~MUST。
`値~反復子$は暗黙的に，当の~objの有index~prop上を反復するように定義される。
◎
A value iterator MUST only be declared on an interface that supports indexed properties and has an integer-typed attribute named “length”. The value-type of the value iterator MUST be the same as the type returned by the indexed property getter. A value iterator is implicitly defined to iterate over the object’s indexed properties.
</p>

<p>
`~pair反復子$は、`有index~propを~supportする$~ifc上に宣言されては~MUST_NOT。
`~pair反復子$を伴う`~ifc$においては、付随する注釈文にて［
何が
`反復される値~pair@
の~listを成すのか
］が定義され~MUST。
◎
A pair iterator MUST NOT be declared on an interface that supports indexed properties. Prose accompanying an interface with a pair iterator MUST define what the list of value pairs to iterate over is.
</p>


<div class="note">

<p>
`値~反復子$に対し生成される ECMAScript `forEach^c ~methは、
`Array.prototype.forEach^c が行うように，その呼戻子を呼出す。
`~pair反復子$に対する `forEach^c ~methは、
`Map.prototype.forEach^c が行うように，その呼戻子を呼出す。
◎
The ECMAScript forEach method that is generated for a value iterator invokes its callback like Array.prototype.forEach does, and the forEach method for a pair iterator invokes its callback like Map.prototype.forEach does.
</p>

<p>
現在，`値~反復子$は`有index~propを~supportする$~ifcのみに許容されているので、
`forEach^c ~methを配列の様に利用することにも~~意味がある。
`値~反復子$は、次のものにも必要かもしれない：
(a) `有index~propを~support$しない~ifc上, あるいは
(b) 呼戻子を，代わりに `Set.protoype.forEach^c の様に呼出す（ここで~keyは，値と同じ）ような `forEach^c ~methに対して。
そのような `forEach^c ~methを必要とする API を再~作成している策定者は、
<a href="mailto:public-script-coord@w3.org">public-script-coord@w3.org</a>
宛まで要請されたし。
◎
Since value iterators are currently allowed only on interfaces that support indexed properties, it makes sense to use an Array-like forEach method. There may be a need for value iterators (a) on interfaces that do not support indexed properties, or (b) with a forEach method that instead invokes its callback like Set.protoype.forEach (where the key is the same as the value). If you’re creating an API that needs such a forEach method, please send a request to public-script-coord@w3.org.
</p>

</div>

<div class="note"><p>
`配列~反復子~obj$は，このように働く。
`有index~propを~supportする$ ~ifcに対しては、［
`entries^l ／ `keys^l ／ `values^l ／ `iterator_symbol^
］から返される反復子~objは，実際の`配列~反復子~obj$である。
◎
This is how array iterator objects work. For interfaces that support indexed properties, the iterator objects returned by “entries”, “keys”, “values” and @@iterator are actual array iterator objects.
</p></div>

<p>
可反復~宣言を伴う~ifcの［
`広義~帰結~ifc$, `被継承~ifc$
］は、名前［
`entries^l ／ `keys^l ／ `values^l
］の`~ifc~mb$を持っては~MUST_NOT。
◎
Interfaces with iterable declarations MUST NOT have any interface members named “entries”, “keys” or “values”, or have any inherited or consequential interfaces that have interface members with these names.
</p>


<div class="example">
<p>
次の~ifcを考える。
`SessionManager^T は、一連の `Session^T ~objに~accessできるようにする：
◎
Consider the following interface SessionManager, which allows access to a number of Session objects:
</p>

<pre class="idl-code">
interface SessionManager {
  Session getSessionForUser(DOMString username);
  readonly attribute unsigned long sessionCount;

  iterable&lt;Session&gt;;
};

interface Session {
  readonly attribute DOMString username;
  // <span>...</span>
};
</pre>

<p>
反復子の挙動は次の様に定義し得る：
◎
The behavior of the iterator could be defined like so:
</p>

<blockquote>
<p>
`反復される値$は、［
`username^M の昇順で整列された，
`SessionManager^T 上の一連の `Session^T ~obj
］である。
◎
The values to iterate over are the open Session objects on the SessionManager sorted by username.
</p>

</blockquote>

<p>
ECMAScript 言語束縛においては、
`SessionManager^T `~ifc$に対する`~ifc原型~obj$は、［
被呼出時に［［
次の反復値を返す `next^c ~meth
］を持つ反復子~obj
］を返すような，関数
］である `values^c ~meth
を持つことになる。
それは、［
一連の `Session^T ~objからなる~list
］の［
各~index ／
各 ( ~index, `Session^T ~obj ) ~pair
］を反復する［
`values^c ／ `entries^c
］~methを持つ。
それは、 `SessionManager^T を `for..of^c ~loopの中でも利用できるようする，
`iterator_symbol^ ~methも持つ：
◎
In the ECMAScript language binding, the interface prototype object for the SessionManager interface has a values method that is a function, which, when invoked, returns an iterator object that itself has a next method that returns the next value to be iterated over. It has values and entries methods that iterate over the indexes of the list of session objects and [index, session object] pairs, respectively. It also has a @@iterator method that allows a SessionManager to be used in a for..of loop:
</p>

<pre class="es-code">
// <span title="Get an instance of SessionManager.
Assume that it has sessions for two users, &quot;anna&quot; and &quot;brian&quot;."
>`SessionManager^T の~instanceを取得する。
// ２人の利用者 `anna^l と `brian^l に対する session があるとする。</span>
var sm = getSessionManager();

typeof SessionManager.prototype.values;
                         // <!--cp-eval-function-->
var it = sm.values();    // <span title="values() returns an iterator object"
>`values()^c は反復子~objを返す</span>
String(it);              // <span title="Evaluates to &quot;[object SessionManager Iterator]&quot;"
>`[object SessionManager Iterator]^l に評価される</span>
typeof it.next;          // <!--cp-eval-function-->

// <span title="This loop will alert &quot;anna&quot; and then &quot;brian&quot;."
>この~loopは `anna^l を alert した後 `brian^l を alert することになる。</span>
for (;;) {
  let result = it.next();
  if (result.done) {
    break;
  }
  let session = result.value;
  window.alert(session.username);
}

// <span title="This loop will also alert &quot;anna&quot; and then &quot;brian&quot;."
>この~loopも `anna^l を alert した後 `brian^l を alert することになる。</span>
for (let session of sm) {
  window.alert(session.username);
}
</pre>

</div>


<p>
`可反復~宣言$を伴う~ifcの［
`広義~帰結~ifc$ ／ `被継承~ifc$
］に，［
別の`可反復~宣言$, `~maplike 宣言$, `~setlike 宣言$
］が宣言されては~MUST_NOT。
◎
An interface MUST NOT have more than one iterable declaration. The inherited and consequential interfaces of an interface with an iterable declaration MUST NOT also have an iterable declaration. An interface with an iterable declaration and its inherited and consequential interfaces MUST NOT have a maplike declaration or setlike declaration.
</p>

<p>
`可反復~宣言$には、次の拡張属性を適用し得る：
`Exposed$x,
`SecureContext$x
。
◎
The following extended attributes are applicable to iterable declarations: [Exposed], [SecureContext].

</p>

<!--
<p>
  No <a class='dfnref' href='#dfn-extended-attribute'>extended attributes</a>
  defined in this specification are applicable to <code>iterator object</code> declarations.
</p>
-->

<div class="grammar">
Iterable
OptionalType
</div>


			</section>
			<section id="idl-maplike" class="v2 L2">
<h4 title="Maplike declarations">3.2.8. ~maplike 宣言</h4>

<p>
~ifcは
`~maplike@
になるように宣言できる。
そのためには、`~ifc$の本体にて
`~maplike 宣言@
（
`ReadWriteMaplike$g ／
`readonly^sym `MaplikeRest$g
いずれかに合致）を利用する。
◎
An interface can be declared to be maplike by using a maplike declaration (matching ReadWriteMaplike or "readonly" MaplikeRest) in the body of the interface.
</p>


<pre class="syntax">
readonly maplike&lt;`key-type^i, `value-type^i&gt;;
maplike&lt;`key-type^i, `value-type^i&gt;;
</pre>


<p>
~maplikeになるように宣言された~ifcを実装する~objは、その一連の［
`~map~entry@
と呼ばれる~key-value
］からなる，順序付けられた~listを表現する。
~keyおよび~valueに利用される型は、~maplike 宣言の山括弧の中で与えられる。
それらの~keyは一意になることが要求される。
◎
Objects implementing an interface that is declared to be maplike represent an ordered list of key–value pairs known as its map entries. The types used for the keys and values are given in the angle brackets of the maplike declaration. Keys are required to be unique.
</p>

<p>
`~maplike$ ~ifcを実装している~objの`~map~entry$の~listは、~objの作成~時には空である。
~ifcに付随している注釈文は、~objの一連の`~map~entry$がどのように変化するかを述べ得る。
◎
The map entries of an object implementing a maplike interface is empty at the of the object’s creation. Prose accompanying the interface can describe how the map entries of an object change.
</p>

<p>
~maplike~ifcは、一連の~map~entryを照会するための，言語束縛に適切な API を~supportする。
`readonly^c ~keywordが利用されなかった場合†、~map~entryを改変するための API も~supportする。
<span class="trans-note">【† 以下， “可書~maplike” とも記される】</span>
◎
Maplike interfaces support an API for querying the map entries appropriate for the language binding. If the readonly keyword is not used, then it also supports an API for modifying the map entries.
</p>

<div class="note"><p>
ECMAScript 言語束縛においては、一連の~map~entryとやりとりするための API は，
ECMAScript にて可用な `Map^t ~objに類似する。
`readonly^c ~keywordが利用された場合、それは［
`entries^l, `forEach^l, `get^l, `has^l, `keys^l, `values^l, `iterator_symbol^
］~meth, および `size^l 取得子を含む。
可書~maplikeに対しては、更に［
`clear^l, `delete^l, `set^l
］~methも含む。
◎
In the ECMAScript language binding, the API for interacting with the map entries is similar to that available on ECMAScript Map objects. If the readonly keyword is used, this includes “entries”, “forEach”, “get”, “has”, “keys”, “values”, @@iterator methods and a “size” getter. For read–write maplikes, it also includes “clear”, “delete” and “set” methods.
</p></div>

<p>
~maplike~ifcの［
`広義~帰結~ifc$, `被継承~ifc$
］は、名前が［
`entries^l／`forEach^l／`get^l／`has^l／`keys^l／`size^l／`values^l
］であるような `~ifc~mb$を持っては~MUST_NOT。
可書~maplike~ifcの［
`広義~帰結~ifc$, `被継承~ifc$
］は、名前が［
`clear^l／`delete^l／`set^l
］であるような `属性$や`定数$も持っては~MUST_NOT。
◎
Maplike interfaces MUST NOT have any interface members named “entries”, “forEach”, “get”, “has”, “keys”, “size”, or “values”, or have any inherited or consequential interfaces that have interface members with these names. Read–write maplike interfaces MUST NOT have any attributes or constants named “clear”, “delete”, or “set”, or have any inherited or consequential interfaces that have attributes or constants with these names.
</p>

<div class="note"><p>
名前［
`clear^l／`delete^l／`set^l
］の演算は，可書~maplike~ifc上にも許容され、その場合， ECMAScript 言語束縛においては，その~methの既定の実装は `~ifc原型~obj$に追加されなくなる。
これにより、これらの演算の既定の挙動を上書きできるようになる。
◎
Operations named “clear”, “delete”, or “set” are allowed on read–write maplike interfaces and will prevent the default implementation of these methods being added to the interface prototype object in the ECMAScript language binding. This allows the default behavior of these operations to be overridden.
</p></div>

<p>
~maplike~ifcの［
`広義~帰結~ifc$ ／ `被継承~ifc$
］に，［
`可反復~宣言$, 別の`~maplike 宣言$, `~setlike 宣言$
］が宣言されては~MUST_NOT。
◎
An interface MUST NOT have more than one maplike declaration. The inherited and consequential interfaces of a maplike interface MUST NOT also have a maplike declaration. A maplike interface and its inherited and consequential interfaces MUST NOT have an iterable declaration or setlike declaration.
</p>

<div class="grammar">
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteMaplike
MaplikeRest
</div>

<p>
`~maplike 宣言$に適用し得る`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to maplike declarations.
</p>

<div class="ednote"><p>
例を追加する。
◎
Add example.
</p></div>


			</section>
			<section id="idl-setlike" class="v2 L2">
<h4 title="Setlike declarations">3.2.9. ~setlike 宣言</h4>

<p>
~ifcは
`~setlike@
になるように宣言できる。
そのためには、`~ifc$の本体にて
`~setlike 宣言@
（
`ReadWriteSetlike$g ／
`readonly^sym `SetlikeRest$g
いずれかに合致）を利用する。
◎
An interface can be declared to be setlike by using a setlike declaration (matching ReadWriteSetlike or "readonly" SetlikeRest) in the body of the interface.
</p>

<pre class="syntax">
readonly setlike&lt;`type^i&gt;;
setlike&lt;`type^i&gt;;
</pre>

<p>
~setlikeになるように宣言された~ifcを実装する~objは、その一連の［
`~set~entry@
と呼ばれる~value
］からなる，順序付けられた~listを表現する。
~valueに利用される型は、~setlike 宣言の山括弧の中で与えられる。
それらの~valueは一意になることが要求される。
◎
Objects implementing an interface that is declared to be setlike represent an ordered list of values known as its set entries. The type of the values is given in the angle brackets of the setlike declaration. Values are required to be unique.
</p>

<p>
`~setlike$ ~ifcを実装している~objの`~set~entry$の~listは、~objの作成~時には空である。
~ifcに付随している注釈文は、~objの一連の`~set~entry$がどのように変化するかを述べ得る。
◎
The set entries of an object implementing a setlike interface is empty at the of the object’s creation. Prose accompanying the interface can describe how the set entries of an object change.
</p>

<p>
~setlike~ifcは、一連の~set~entryを照会するための，言語束縛に適切な API を~supportする。
`readonly^c ~keywordが利用されなかった場合†、~set~entryを改変するための API も~supportする。
<span class="trans-note">【† 以下， “可書~setlike” とも記される】</span>
◎
Setlike interfaces support an API for querying the set entries appropriate for the language binding. If the readonly keyword is not used, then it also supports an API for modifying the set entries.
</p>

<div class="note"><p>
ECMAScript 言語束縛においては、一連の~set~entryとやりとりするための API は，
ECMAScript にて可用な `Set^t ~objに類似する。
`readonly^c ~keywordが利用された場合、それは［
`entries^l, `forEach^l, `has^l, `keys^l, `values^l, `iterator_symbol^
］~meth, および `size^l 取得子を含む。
可書~setlikeに対しては、更に［
`add^l, `clear^l, `delete^l
］~methも含む。
◎
In the ECMAScript language binding, the API for interacting with the set entries is similar to that available on ECMAScript Set objects. If the readonly keyword is used, this includes “entries”, “forEach”, “has”, “keys”, “values”, @@iterator methods and a “size” getter. For read–write setlikes, it also includes “add”, “clear”, and “delete” methods.
</p></div>

<p>
~setlike~ifcの［
`広義~帰結~ifc$, `被継承~ifc$
］は、名前が［
`entries^l／`forEach^l／`has^l／`keys^l／`size^l／`values^l
］であるような `~ifc~mb$を持っては~MUST_NOT。
可書~setlike~ifcの［
`広義~帰結~ifc$, `被継承~ifc$
］は、名前が［
`add^l／`clear^l／`delete^l
］であるような `属性$や`定数$も持っては~MUST_NOT。
◎
Setlike interfaces MUST NOT have any interface members named “entries”, “forEach”, “has”, “keys”, “size”, or “values”, or have any inherited or consequential interfaces that have interface members with these names.. Read–write setlike interfaces MUST NOT have any attributes or constants named “add”, “clear”, or “delete”, or have any inherited or consequential interfaces that have attributes or constants with these names.
</p>

<div class="note"><p>
名前［
`add^l／`clear^l／`delete^l
］の演算は，可書~setlike~ifc上にも許容され、その場合， ECMAScript 言語束縛においては，その~methの既定の実装は `~ifc原型~obj$に追加されなくなる。
これにより、これらの演算の既定の挙動を上書きできるようになる。
◎
Operations named “add”, “clear”, or “delete” are allowed on read–write setlike interfaces and will prevent the default implementation of these methods being added to the interface prototype object in the ECMAScript language binding. This allows the default behavior of these operations to be overridden.
</p></div>

<p>
~setlike~ifcの［
`広義~帰結~ifc$ ／ `被継承~ifc$
］に，［
`可反復~宣言$, `~maplike 宣言$, 別の`~setlike 宣言$
］が宣言されては~MUST_NOT。
◎
An interface MUST NOT have more than one setlike declaration. The inherited and consequential interfaces of a setlike interface MUST NOT also have a setlike declaration. A setlike interface and its inherited and consequential interfaces MUST NOT have an iterable declaration or maplike declaration.
</p>

<div class="grammar">
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteSetlike
SetlikeRest
</div>

<p>
`~setlike 宣言$に適用し得る`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to setlike declarations.
</p>

<div class="ednote"><p>
例を追加する。
◎
Add example.
</p></div>


			</section>
		</section>
		<section id="idl-dictionaries">
<h3 title="Dictionaries">3.3. 辞書</h3>


<p>
`辞書@
は、固定的かつ順序付けられた~keyの集合による，
~key-valueの連想配列~data型を定義するために利用される，`定義$（ `Dictionary$g に合致）である。
各~pairを
`辞書~mb@
と呼ぶ。
その~keyは文字列であり，その値は定義の中で指定される個々の型に属する。
◎
A dictionary is a definition (matching Dictionary) used to define an associative array data type with a fixed, ordered set of key–value pairs, termed dictionary members, where keys are strings and values are of a particular type specified in the definition.
</p>

<pre class="syntax">
dictionary `identifier^i {
  `dictionary-members…^i
};
</pre>

<p>
辞書は常に値渡しである。
辞書が何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に辞書が渡された際に，その辞書への参照がその~objに保有されることはない。
同様に，~platform~objから返されるどの辞書も複製であり、それに対する改変は~platform~objからは見えないことになる。
◎
Dictionaries are always passed by value. In language bindings where a dictionary is represented by an object of some kind, passing a dictionary to a platform object will not result in a reference to the dictionary being kept by that object. Similarly, any dictionary returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>
<p>
辞書は 別の辞書を
<dfn id="dfn-inherit-dictionary">継承-</dfn>
するように定義し得る。
辞書の識別子に~colonと`識別子$が後続するとき、後者の識別子が，継承される辞書を識別する。
この識別子は辞書を識別するもので~MUST。
◎
A dictionary can be defined to inherit from another dictionary. If the identifier of the dictionary is followed by a colon and a identifier, then that identifier identifies the inherited dictionary. The identifier MUST identify a dictionary.
</p>

<p>
辞書は、その継承階層が循環するように宣言されては~MUST_NOT。
すなわち、辞書 %A は自身を継承することも,
%A を継承する別の辞書 %B を継承することもできない，等々。
◎
A dictionary MUST NOT be declared such that its inheritance hierarchy has a cycle. That is, a dictionary A cannot inherit from itself, nor can it inherit from another dictionary B that inherits from A, and so on.
</p>

<pre class="syntax">
dictionary `Base^mk {
  `dictionary-members…^i
};

dictionary `Derived^i : `Base^mk {
  `dictionary-members…^i
};
</pre>

<p>
所与の辞書~型 %D の
`被継承~辞書@
とは、
%D が直接的にまたは間接的に継承するすべての辞書の集合である。
%D が他の辞書を`辞書継承^しない場合、その集合は空である。
そうでない場合、その集合は %D が`辞書継承^する~ifc %E と %E の`被継承~辞書$すべてを含む。
◎
The inherited dictionaries of a given dictionary D is the set of all dictionaries that D inherits from, directly or indirectly. If D does not inherit from another dictionary, then the set is empty. Otherwise, the set includes the dictionary E that D inherits from and all of E’s inherited dictionaries.
</p>

<p>
型 %D の辞書~値 %d は、
%D 上および %D の`被継承~辞書$上で定義される辞書~mbに対応する~key-valueを持ち得る。
%d 上における，各~辞書~mbの存在tは、それが %D において`必須~辞書~mb$であると指定されていない限り，~optionalである。
%d 上に指定されているならば，その辞書~mbは
`在する@
（ present ）といい、そうでない場合は
<dfn>`不在$</dfn>
という。
辞書~mbは，~optionalで
<dfn id="dfn-dictionary-member-default-value">既定~値</dfn>
も持ち得る。
それは、 %d 上にその~mb値が指定されずに %d が`~platform~obj$に渡された際に，辞書~mbに利用される値と見なされる。
既定~値を伴う辞書~mbは常に在するものと見なされる。
◎
A dictionary value of type D can have key–value pairs corresponding to the dictionary members defined on D and on any of D’s inherited dictionaries. On a given dictionary value, the presence of each dictionary member is optional, unless that member is specified as required. When specified in the dictionary value, a dictionary member is said to be present, otherwise it is not present. Dictionary members can also optionally have a default value, which is the value to use for the dictionary member when passing a value to a platform object that does not have a specified value. Dictionary members with default values are always considered to be present.
</p>

<div class="warning">
<p>
演算~引数の`既定~値$と同様に、
`boolean$T 型の辞書~mbに対しては、既定~値として `true^V を利用しないことを強く勧める。
さもなければ、 `undefined^v に既定の変換（すなわち， `false^V ）が利用されると期待する作者たちを惑わすことになるので。
◎
As with operation argument default values, is strongly suggested not to use of true as the default value for boolean-typed dictionary members, as this can be confusing for authors who might otherwise expect the default conversion of undefined to be used (i.e., false).
</p>
</div>

<p>
各`辞書~mb$（ `DictionaryMember$g に合致）は、型（ `Type$g に合致）および, 後続の（ `identifier$g ~tokで与えられる）`識別子$により指定され、その識別子が~key-valueの~key名になる。
`Type$g が `?^c 付きの`識別子$である場合、その識別子は［
~ifc, `列挙$, `呼戻~関数$, `~typedef$
］のいずれかに識別され~MUST。
辞書~mb型が `?^c 付きでない識別子である場合、その識別子は，それらの定義, または`辞書$に識別され~MUST。
◎
Each dictionary member (matching DictionaryMember) is specified as a type (matching Type) followed by an identifier (given by an identifier token following the type). The identifier is the key name of the key–value pair. If the Type is an identifier followed by ?, then the identifier MUST identify an interface, enumeration, callback function or typedef. If the dictionary member type is an identifier not followed by ?, then the identifier MUST identify any one of those definitions or a dictionary.
</p>

<pre class="syntax">
dictionary `identifier^i {
  `type^i `identifier^i;
};
</pre>

<p>
識別子に
`U+003D EQUALS SIGN ("=")^char
と値（ `DefaultValue$g に合致）が後続している場合、それが辞書~mbの
`辞書既定値^
を与える。
◎
If the identifier is followed by a U+003D EQUALS SIGN ("=") and a value (matching DefaultValue), then that gives the dictionary member its default value.
</p>

<pre class="syntax">
dictionary `identifier^i {
  `type^i `identifier^i = `value^i;
};
</pre>

<p>
`辞書既定値^に［
`定数~tok$ ／ `string$g ~tok ／ 2 個の~tok並び `[]^c
］が利用された場合、
`演算$の引数の`既定~値$
のときと同じ仕方で解釈される。
◎
When a boolean literal token (true or false), the null token, an integer token, a float token, one of the three special floating point literal values (Infinity, -Infinity or NaN), a string token or the two token sequence [] used as the default value, it is interpreted in the same way as for an operation’s optional argument default value.
</p>

<p>
`辞書~mb$の型が`列挙$である場合、その`辞書既定値^に指定される値は，その`列挙~値$のいずれかで~MUST。
◎
If the type of the dictionary member is an enumeration, then its default value if specified MUST be one of the enumeration’s values.
</p>


<p>
辞書~mbの型の前に ~keyword `required^c が置かれた場合、その~mbは
`必須~辞書~mb@
と見なされ，辞書~上に`在する$ことが要求される。
`必須~辞書~mb$は、`既定~値$を持っては~MUST_NOT。
◎
If the type of the dictionary member is preceded by the required keyword, the member is considered a required dictionary member and must be present on the dictionary. A required dictionary member MUST NOT have a default value.
</p>

<pre class="syntax">
dictionary `identifier^i {
  required `type^i `identifier^i;
};
</pre>

<p>
辞書~mbの型は，その辞書を <em>内包</em> しては~MUST_NOT。
次のいずれかが成立するとき、型 %T は辞書~型 %D を内包するものとされる：
◎
The type of a dictionary member MUST NOT include the dictionary it appears on. A type includes a dictionary D if at least one of the following is true:
</p>

<ul>
	<li>
%T は %D である
◎
the type is D
</li>
	<li>
%T は %D を`辞書継承^している辞書である
◎
the type is a dictionary that inherits from D
</li>
	<li>
%T は`~nullable型$であり，その`内部型$が %D を内包している
◎
the type is a nullable type whose inner type includes D
</li>
	<li>
%T は`連列~型$か, または`凍結~配列~型$であり，その要素~型が %D を内包している
◎
the type is a sequence type or frozen array whose element type includes D
</li>
	<li>
%T は`共用体~型$であり，そのいずれかの`~mb型$が %D を内包している
◎
the type is a union type, one of whose member types includes D
</li>
	<li>
%T は辞書であり，そのいずれかの［
~mb, または
継承している~mb
］の型が %D を内包している
◎
the type is a dictionary, one of whose members or inherited members has a type that includes D
</li>
</ul>


<p>
~ifcと同様に、辞書のための IDL は
`部分的~辞書~定義@
（ `partial^sym `Dictionary$g に合致）を利用して複数の部分に分割できる。
部分的~辞書~定義の`識別子$は
辞書~定義の識別子と同じで~MUST。
それぞれの部分的~辞書~定義に現れるすべての~mbは、辞書~自身の~mbと見なされる。
◎
As with interfaces, the IDL for dictionaries can be split into multiple parts by using partial dictionary definitions (matching "partial" Dictionary). The identifier of a partial dictionary definition MUST be the same as the identifier of a dictionary definition. All of the members that appear on each of the partial dictionary definitions are considered to be members of the dictionary itself.
</p>

<pre class="syntax">
dictionary `SomeDictionary^mk {
  `dictionary-members…^i
};

partial dictionary `SomeDictionary^mk {
  `dictionary-members…^i
};
</pre>

<div class="note"><p>
部分的~ifc定義と同様に、部分的~辞書~定義の目的は、辞書の定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補助する所にある。
◎
As with partial interface definitions, partial dictionary definitions are intended for use as a specification editorial aide, allowing the definition of an interface to be separated over more than one section of the document, and sometimes multiple documents.
</p></div>

<p id="_order-of-dict-members_">
所与の辞書~上の`辞書~mb$は、継承された辞書~mbが
非継承~mbより前に位置する様に順序付けられる。
１つの辞書~定義~上の（部分的~辞書~定義もすべて含めた）すべての辞書~mbは、それらの識別子を構成する Unicode 符号位置により，辞書式に順序付けられる。
◎
The order of the dictionary members on a given dictionary is such that inherited dictionary members are ordered before non-inherited members, and the dictionary members on the one dictionary definition (including any partial dictionary definitions) are ordered lexicographically by the Unicode codepoints that comprise their identifiers.
</p>

<div class="note">
<p>
例えば，次の定義では：
◎
For example, with the following definitions:
</p>

<pre class="idl-code">
dictionary B : A {
  long b;
  long a;
};

dictionary A {
  long c;
  long g;
};

dictionary C : B {
  long e;
  long f;
};

partial dictionary A {
  long h;
  long d;
};
</pre>

<p>
型 `C^T の辞書~値の `辞書~mb$の順序は［
`c^M, `d^M, `g^M, `h^M, `a^M, `b^M, `e^M, `f^M
］になる。
◎
the order of the dictionary members of a dictionary value of type C is c, d, g, h, a, b, e, f.
</p>

<p>
辞書の~mbは順序付けられることが要求される。
一部の言語束縛においては、~platform~objに辞書~値を渡した際に観測される挙動が，辞書~mbを取りに行く順序に依存するので。
例えば，次の追加の~ifc：
◎
Dictionaries are required to have their members ordered because in some language bindings the behavior observed when passing a dictionary value to a platform object depends on the order the dictionary members are fetched. For example, consider the following additional interface:
</p>

<pre class="idl-code">
interface Something {
  void f(A a);
};
</pre>

<p>
および，次の ECMAScript ~codeを考えるとき：
◎
and this ECMAScript code:
</p>

<pre class="es-code">
var something = getSomething();  // <span title="Get an instance of Something."
>`Something^T の~instanceを取得する。</span>
var x = 0;

var dict = { };
Object.defineProperty(dict, "d", { get: function() { return ++x; } });
Object.defineProperty(dict, "c", { get: function() { return ++x; } });

something.f(dict);
</pre>

<p>
辞書~mbを取りに行く順序が、それらがとることになる値を決定する。
`A^T における順序は， `c^M の次が `d^M と定義されるので、
`c^M に対する値は 1 になり, `d^M に対する値は 2 になる。
◎
The order that the dictionary members are fetched in determines what values they will be taken to have. Since the order for A is defined to be c then d, the value for c will be 1 and the value for d will be 2.
</p>
</div>

<p>
辞書~mbの識別子は、その辞書~上, またはその辞書の`被継承~辞書$上で定義される，別の辞書~mbの識別子と同じになっては~MUST_NOT。
◎
The identifier of a dictionary member MUST NOT be the same as that of another dictionary member defined on the dictionary or on that dictionary’s inherited dictionaries.
</p>

<p>
辞書は［
`属性$／`定数$
］の型に利用されては~MUST_NOT。
◎
Dictionaries MUST NOT be used as the type of an attribute or constant.
</p>

<p>
`辞書$には、次の拡張属性を適用し得る：
<span class="v2">`Constructor$x,</span>
`Exposed$x,
`SecureContext$x
<!--JAVA [JavaPackage], -->
。
◎
The following extended attributes are applicable to dictionaries: [Constructor], [Exposed], [SecureContext],
</p>

<p>
辞書~mbには、次の拡張属性を適用し得る：
`Clamp$x, `EnforceRange$x
。
◎
The following extended attributes are applicable to dictionary members: [Clamp], [EnforceRange].
</p>

<div class="grammar">
--Partial
--PartialDefinition
-Dictionary
-DictionaryMembers
-DictionaryMember
-PartialDictionary
-Default
--DefaultValue
--Inheritance
</div>

<div class="example">
<p>
辞書~型の利用の１つは、`演算$に対し、
呼出し~codeの所で指定される順序に制約を課すことなく，随意~引数をいくつでも与えられるようにすることである。
例えば，次の `IDL 片$を考える：
◎
One use of dictionary types is to allow a number of optional arguments to an operation without being constrained as to the order they are specified at the call site. For example, consider the following IDL fragment:
</p>

<pre class="idl-code">
[Constructor]
interface Point {
  attribute double x;
  attribute double y;
};

dictionary PaintOptions {
  DOMString? fillPattern = "black";
  DOMString? strokePattern = null;
  Point position;
};

interface GraphicsContext {
  void drawRectangle(double width, double height, optional PaintOptions options);
};
</pre>

<p>
この IDL の ECMAScript 実装においては、随意の
`PaintOptions^T 辞書
により， `Object^t を渡すことができる：
◎
In an ECMAScript implementation of the IDL, an Object can be passed in for the optional PaintOptions dictionary:
</p>

<pre class="es-code">
// <span title="Get an instance of GraphicsContext."
>`GraphicsContext^T の~instanceを取得する。</span>
var ctx = getGraphicsContext();

// <span title="Draw a rectangle."
>矩形を描く。</span>
ctx.drawRectangle(300, 200, { fillPattern: "red", position: new Point(10, 10) });
</pre>

<p>
`fillPattern^M と `strokePattern^M のいずれにも`辞書既定値^が与えられているので、 `drawRectangle^M の定義においては，それらが省略された場合でも所与の既定~値を持つと見なすことができ、それらが`不在$の場合に取扱う方法についての明示的な言及が不要になる。
◎
Both fillPattern and strokePattern are given default values, so if they are omitted, the definition of drawRectangle can assume that they have the given default values and not include explicit wording to handle their non-presence.
</p>
</div>
		</section>
		<section id="idl-exceptions" class="v2">
<h3 title="Exceptions">3.4. 例外</h3>

<p class="trans-note">【
この節の内容は、第１版から一新されている。
】</p>

<div >
<p>
`例外@
とは、~errorを表現する~objの型であり，実装により［
投出される, または first ~class値として扱われる
］ものである。
Web IDL では，例外を定義することは許容されないが、代わりに
仕様が参照し，その演算, 属性, 等々の定義にて投出できるような，いくつもの定義済みの例外がある。
例外は、次のものを持つ：
</p>

<dl>
	<dt>`~error名@</dt>
	<dd>
`DOMString$T による，例外が表現する~errorの型
</dd>

	<dt>`~message@（随意）</dt>
	<dd>
~errorの詳細を人が読める~~形で提供する，~UAにより定義される値
</dd>

</dl>
◎
An exception is a type of object that represents an error and which can be thrown or treated as a first class value by implementations. Web IDL does not allow exceptions to be defined, but instead has a number of pre-defined exceptions that specifications can reference and throw in their definition of operations, attributes, and so on. Exceptions have an error name, a DOMString, which is the type of error the exception represents, and a message, which is an optional, user agent-defined value that provides human readable details of the error.
</div>


<p>
仕様にて投出するために可用な例外には２つの種類がある。
まず、次のいずれかの名前として識別される
`単純例外@
：
◎
There are two kinds of exceptions available to be thrown from specifications. The first is a simple exception, which is identified by one of the following names:
</p>

<ul>
	<li>`Error$T</li>
	<li>`EvalError^T</li>
	<li>`RangeError^T</li>
	<li>`ReferenceError^T</li>
	<li>`TypeError^T</li>
	<li>`URIError^T</li>
</ul>

<p>
これらは、
<a href="~ES6#sec-error-objects">ECMAScript error objects</a>（ `ECMA-262$r, 19.5 節）に対応する（ `SyntaxError^t は除く — それは ECMAScript 構文解析器でのみ利用されるので，~~意図的に除かれている）。
各 `単純例外$の意味は、 ECMAScript 仕様における対応する `Error^t ~objに合致する。
◎
These correspond to all of the ECMAScript error objects ([ECMA-262], section 19.5) (apart from SyntaxError, which is deliberately omitted as it is for use only by the ECMAScript parser). The meaning of each simple exception matches its corresponding Error object in the ECMAScript specification.
</p>


<p>
もう一種の例外は
`DOMException@
である
— それは，歴史的に DOM にて定義された例外との互換性をとるための例外であり、名前と整数~code（後者は随意）を，~encapsulateする。
◎
The second kind of exception is a DOMException, which is an exception that encapsulates a name and an optional integer code, for compatibility with historically defined exceptions in the DOM.
</p>

<p>
`単純例外$に対しては、その例外の名前が，そのまま`~error名$になる。
`DOMException$に対しては、`~error名$は，後に示す`~error名~一覧$に挙げられている いずれかの名前で~MUST。
その一覧には、その~error名に対する`DOMException$の整数~codeも（もし在れば）指示される。
◎
For simple exceptions, the error name is the name of the exception. For a DOMException, the error name MUST be one of the names listed in the error names table below. The table also indicates the DOMException's integer code for that error name, if it has one.
</p>

<p>
例外~objを指すために利用し得る，２種の`型$がある：
すべての例外が含まれる `Error$T, および
DOMException ~objのみを含む `DOMException$T 。
これにより、`演算$の`返値型$を `DOMException$ に宣言したり，`属性$の型を `Error$T 型にすることも可能になる。
◎
There are two types that can be used to refer to exception objects: Error, which encompasses all exceptions, and DOMException which includes just DOMException objects. This allows for example an operation to be declared to have a DOMException return type or an attribute to be of type Error.
</p>

<p>
例外は、その`~error名$を提供して
`作成する@
こともできる。
例外は、それを`作成する$ために要求される詳細を提供して
`投出する@
こともできる。
◎
Exceptions can be created by providing its error name. Exceptions can also be thrown, by providing the same details required to create one.
</p>

<p>
例外を作成したり, 作成した例外を投出した結果の挙動は、言語束縛~特有になる。
◎
The resulting behavior from creating and throwing an exception is language binding-specific.
</p>

<div class="note">
<p>
ECMAScript 言語束縛の場合にどうなるかについては、
`es-creating-throwing-exceptions$secに。
◎
See section 4.13 below for details on what creating and throwing an exception entails in the ECMAScript language binding.
</p></div>

<div class="example">
<p>
例外を作成して投出する言い回しの用例をここに示す。
名前 `TypeError^T の新たな `単純例外$を投出するときは†：
◎
Here is are some examples of wording to use to create and throw exceptions. To throw a new simple exception named TypeError:
</p>

<blockquote><p>
`TypeError^t を`投出$。
◎
Throw a TypeError.
</p></blockquote>

<p>
`~error名$ `IndexSizeError^T の
新たな `DOMException$を投出するときは†：
◎
To throw a new DOMException with error name IndexSizeError:
</p>

<blockquote><p>
`IndexSizeError^t を`投出$。
◎
Throw an IndexSizeError.
</p></blockquote>

<p class="trans-note">【†
この訳では、~algoの中では，記号 ~THROW を利用して記される。
】</p>

<p>
`~error名$ `SyntaxError^T の新たな `DOMException$を作成するときは：
◎
To create a new DOMException with error name SyntaxError:
</p>

<blockquote><p>
%object := 新たに`作成-$された `SyntaxError^t
◎
Let object be a newly created SyntaxError.
</p></blockquote>

</div>


			<section id="idl-DOMException-error-names">
<h4 title="Error names">3.4.1. ~error名</h4>

<p>
下の
`~error名~一覧@
は、 `DOMException$ に許容されるすべての~error名, 説明, および 旧来の code 名とその値の一覧である。
◎
The error names table below lists all the allowed error names for DOMExceptions, a description, and legacy code values.
</p>

<div class="note"><p>
ここに挙げられていない~error名があれば、この仕様の冒頭に指示したように, バグを申請されるよう願う。
間もなく解消に向けて取り組まれることになる。
Thanks! 
◎
If an error name is not listed here, please file a bug as indicated at the top of this specification and it will be addressed shortly. Thanks!
</p></div>

<div style="overflow:auto;"><table id="error-names" class="vert">
<thead><tr><th>名前◎Name
</th><th style="min-width:12em;">説明◎Description
</th><th>
旧来の code 名（数値）
◎
Legacy code name and value
</th></tr></thead>

<tbody><tr><td>`IndexSizeError@err
</td><td><p>
index は許容されている範囲に入っていない。
◎
The index is not in the allowed range.
</p></td><td>`INDEX_SIZE_ERR^c (1)

</td></tr><tr><td>`HierarchyRequestError@err
</td><td><p>
演算から不正な~node木が得られることになる。
◎
The operation would yield an incorrect node tree.
</p></td><td>`HIERARCHY_REQUEST_ERR^c (3)

</td></tr><tr><td>`WrongDocumentError@err
</td><td><p>
~objが属している文書は誤っている。
◎
The object is in the wrong document.
</p></td><td>`WRONG_DOCUMENT_ERR^c (4)

</td></tr><tr><td>`InvalidCharacterError@err
</td><td><p>
文字列に妥当でない文字が含まれている。
◎
The string contains invalid characters.
</p></td><td>`INVALID_CHARACTER_ERR^c (5)

</td></tr><tr><td>`NoModificationAllowedError@err
</td><td><p>
~objは改変できない。
◎
The object can not be modified.
</p></td><td>`NO_MODIFICATION_ALLOWED_ERR^c (7)

</td></tr><tr><td>`NotFoundError@err
</td><td><p>
~objは見つからなかった。
◎
The object can not be found here.
</p></td><td>`NOT_FOUND_ERR^c (8)

</td></tr><tr><td>`NotSupportedError@err
</td><td><p>
演算は~supportされていない。
◎
The operation is not supported.
</p></td><td>`NOT_SUPPORTED_ERR^c (9)

</td></tr><tr><td>`InUseAttributeError@err
</td><td><p>
属性は使用中にある。
◎
The attribute is in use.
</p></td><td>`INUSE_ATTRIBUTE_ERR^c (10)

</td></tr><tr><td>`InvalidStateError@err
</td><td><p>
~objは不正な状態にある。
◎
The object is in an invalid state.
</p></td><td>`INVALID_STATE_ERR^c (11)

</td></tr><tr><td>`SyntaxError@err
</td><td><p>
文字列は期待されるパタンに合致していない。
◎
The string did not match the expected pattern.
</p></td><td>`SYNTAX_ERR^c (12)

</td></tr><tr><td>`InvalidModificationError@err
</td><td><p>
~objはこの仕方では改変できない。
◎
The object can not be modified in this way.
</p></td><td>`INVALID_MODIFICATION_ERR^c (13)

</td></tr><tr><td>`NamespaceError@err
</td><td><p>
演算は <cite>Namespaces in XML</cite> において許容されない。
`XMLNS$r
◎
The operation is not allowed by Namespaces in XML. [XMLNS]
</p></td><td>`NAMESPACE_ERR^c (14)

</td></tr><tr><td>`InvalidAccessError@err
</td><td><p>
~objは演算または引数を~supportしない。
◎
The object does not support the operation or argument.
</p></td><td>`INVALID_ACCESS_ERR^c (15)

</td></tr><tr><td>`SecurityError@err<!-- XHR -->
</td><td><p>
演算はセキュリティに抵触する。
◎
The operation is insecure.
</p></td><td>`SECURITY_ERR^c (18)

</td></tr><tr><td>`NetworkError@err<!-- XHR -->
</td><td><p>
~network~errorが生じた。
◎
A network error occurred.
</p></td><td>`NETWORK_ERR^c (19)

</td></tr><tr><td>`AbortError@err<!-- XHR -->
</td><td><p>
演算は中止された。
◎
The operation was aborted.
</p></td><td>`ABORT_ERR^c (20)

</td></tr><tr><td>`URLMismatchError@err<!-- Workers -->
</td><td><p>
所与の URL は他方の URLに合致していない。
◎
The given URL does not match another URL.
</p></td><td>`URL_MISMATCH_ERR^c (21)
 

</td></tr><tr><td>`QuotaExceededError@err<!-- HTML -->
</td><td><p>
quota の上限を超えた。
◎
The quota has been exceeded.
</p></td><td>`QUOTA_EXCEEDED_ERR^c (22)

</td></tr><tr><td>`TimeoutError@err<!-- XHR -->
</td><td><p>
演算は時間切れになった。
◎
The operation timed out.
</p></td><td>`TIMEOUT_ERR^c (23)

</td></tr><tr><td>`InvalidNodeTypeError@err
</td><td><p>
あてがわれた~nodeは不正か, またはこの演算において不正な先祖を持つ。
◎
The supplied node is incorrect or has an incorrect ancestor for this operation.
</p></td><td>`INVALID_NODE_TYPE_ERR^c (24)

</td></tr><tr><td>`DataCloneError@err<!-- HTML -->
</td><td><p>
~objは~cloneできない。
◎
The object can not be cloned.
</p></td><td>`DATA_CLONE_ERR^c (25)

</td></tr><tr><td>`EncodingError@err<!-- Encoding -->
</td><td><p>
符号化~演算（符号化, 復号の両者を含む）に失敗した。
◎
The encoding operation (either encoded or decoding) failed.
</p></td><td>—

</td></tr><tr><td>`NotReadableError@err<!-- File API -->
</td><td><p>
I/O 読み取り演算に失敗した。
◎
The I/O read operation failed.
</p></td><td>—


</td></tr><tr><td>`UnknownError@err<!-- Indexed DB / Web Crypto -->
</td><td><p>
未知の一時的な事由により，演算に失敗した（例：記憶域を使い切った）。
  <!-- The operation failed for reasons unrelated to the database itself and not covered by any other errors. -->
◎
The operation failed for an unknown transient reason (e.g. out of memory).
</p></td><td>—

</td></tr><tr><td>`ConstraintError@err<!-- Indexed DB -->
</td><td><p>
~transactionにおける変異~演算は、拘束を満たせないため，失敗した。
◎
A mutation operation in a transaction failed because a constraint was not satisfied.
</p></td><td>—

</td></tr><tr><td>`DataError@err<!-- Indexed DB / Web Crypto -->
</td><td><p>
提供された~dataは、必要十分でない。
◎
Provided data is inadequate.
</p></td><td>—

</td></tr><tr><td>`TransactionInactiveError@err<!-- Indexed DB -->
</td><td><p>
現在~作動中でない／すでに終わった ~transactionに対し，要請が行われた。
◎
A request was placed against a transaction which is currently not active, or which is finished.
</p></td><td>—

</td></tr><tr><td>`ReadOnlyError@err<!-- Indexed DB -->
</td><td><p>
“読み取り専用” （ `readonly^l ~mode）の~transactionにおいて，変異させようとする演算が試みられた。
◎
The mutating operation was attempted in a "readonly" transaction.
</p></td><td>—

</td></tr><tr><td>`VersionError@err<!-- Indexed DB -->
</td><td><p>
既存の~versionより低い~versionを利用して~databaseを open しようとした。
◎
An attempt was made to open a database using a lower version than the existing version.
</p></td><td>—

</td></tr><tr><td>`OperationError@err<!-- Web Crypto -->
</td><td><p>
演算~特有の事由により，演算に失敗した。
◎
The operation failed for an operation-specific reason.
</p></td><td>—

</td></tr><tr><td>`NotAllowedError@err<!-- HTML -->
</td><td><p>
要請された演算は、現在の文脈においては
~UA／~platform
から許容されない。
◎
The request is not allowed by the user agent or the platform in the current context.
</p></td><td>—

</td></tr></tbody></table></div>

			</section>
		</section>
		<section id="idl-enums">
<h3 title="Enumerations">3.5. 列挙</h3>


<p>
`列挙@
は、［
妥当な値の集合が，定義済みの文字列の集合になる
］ような型を宣言するために利用される，`定義$（ `Enum$g に合致）である。
`属性$に代入し得る／`演算$に渡し得る `DOMString$T 値を制約する用途に，列挙を利用できる。
◎
An enumeration is a definition (matching Enum) used to declare a type whose valid values are a set of predefined strings. Enumerations can be used to restrict the possible DOMString values that can be assigned to an attribute or passed to an operation.
</p>

<pre class="syntax">
enum `identifier^i { `enumeration-values…^i };
</pre>

<p>
一連の
`列挙~値@
は、
`string$g ~literalの~comma区切りの~listとして指定される。
`列挙~値$の~list内に重複があっては~MUST_NOT。
◎
The enumeration values are specified as a comma-separated list of string literals. The list of enumeration values MUST NOT include duplicates.
</p>

<div class="warning">
<p>
別の命名法を利用する理由が特にない限り、列挙~値は，すべて小文字にすることを強く勧める
— 複数の単語は，~dashで区切るか全く区切らないことにして。
例えば、~objが作成されるべきであることを指示する列挙~値は，
`createobject^l や `create-object^l
などと命名できる。
列挙~値の単語を~dashで区切るか区切らないか決めるときは、類似の他の API と一貫するように，関係する列挙~値の利用を考慮に入れること。
◎
It is strongly suggested that enumeration values be all lowercase, and that multiple words be separated using dashes or not be separated at all, unless there is a specific reason to use another value naming scheme. For example, an enumeration value that indicates an object should be created could be named "createobject" or 'create-object". Consider related uses of enumeration values when deciding whether to dash-separate or not separate enumeration value words so that similar APIs are consistent.
</p>
</div>

<p>
妥当な列挙~値のいずれでもない文字列~値が、列挙~型の`属性$への代入ingや, 列挙~型の`演算$に渡される引数に利用されたときの挙動は、言語束縛~特有になる。
◎
The behavior when a string value that is not one a valid enumeration value is used when assigning to an attribute, or passed as an operation argument, whose type is the enumeration, is language binding specific.
</p>

<div class="note"><p>
ECMAScript 言語束縛においては、`属性$への妥当でない文字列~値の代入は無視される一方，そのような値を`演算$の引数に渡したときには例外が投出される。
◎
In the ECMAScript binding, assignment of an invalid string value to an attribute is ignored, while passing such a value as an operation argument results in an exception being thrown.
</p></div>

<p>
`列挙$に適用し得る`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to enumerations.
</p>

<div class="grammar">
-Enum
-EnumValueList
-EnumValueListComma
-EnumValueListString
</div>


<div class="example">
<p>
次の `IDL 片$は
１個の`属性$と１個の`演算$引数の型として利用される
`列挙$を定義する
◎
The following IDL fragment defines an enumeration that is used as the type of an attribute and an operation argument:
</p>

<pre class="idl-code">
enum MealType { "米", "麺", "その他" };

interface Meal {
  attribute MealType type;
  attribute double size;     // <span title="in grams"
>グラム~~単位</span>

  void initialize(MealType type, double size);
};
</pre>

<p>
ECMAScript 実装は、 type ~propに代入され得る, あるいは
`initialize^M 関数に渡され得る文字列を，
`列挙$内にて識別されるものに制約することになる。
◎
An ECMAScript implementation would restrict the strings that can be assigned to the type property or passed to the initializeMeal function to those identified in the enumeration.
</p>

<pre class="es-code">
var meal = getMeal();            // <span title="Get an instance of Meal."
>`Meal^T の~instanceを取得する。</span>

meal.initialize("米", 200);      // <span title="Operation invoked as normal."
>演算は通常通り呼出される。</span>

try {
  meal.initialize("肉", 100);    // <span title="Throws a TypeError."
>`TypeError^t が投出される。</span>
} catch (e) {
}

meal.type = "麺";                // <span title="Attribute assigned as normal."
>属性は通常通り代入される。</span>
meal.type = "魚";                // <span title="Attribute assignment ignored."
>属性~代入は無視される。</span>
meal.type == "麺";               // <span title="Evaluates to true." id="cp-eval-true"
>`true^v に評価される。</span>
</pre>
</div>
		</section>
		<section id="idl-callback-functions">
<h3 title="Callback functions">3.6. 呼戻~関数</h3>

<div class="ednote v2"><p>
“Custom DOM Elements” 仕様からは、`呼戻~関数~型$を，~platform~objから提供される関数に利用することが求められている。
“呼戻~関数” を，両方の目的に利用し得ることを明らかにするため、単に “関数” と改称するべきだろうか？
◎
The “Custom DOM Elements” spec wants to use callback function types for platform object provided functions. Should we rename “callback functions” to just “functions” to make it clear that they can be used for both purposes?
</p></div>

<p>
`呼戻~関数@
は、関数~型を宣言するときに利用される，`定義$（ `callback^sym `CallbackRest$g に合致）である。
◎
A callback function is a definition (matching "callback" CallbackRest) used to declare a function type.
</p>

<pre class="syntax">
callback `identifier^i = `return-type^i (`arguments…^i);
</pre>

<div class="note"><p>
似た命名の`呼戻~ifc$も見よ。
<!--  -->
◎
See also the similarly named callback interfaces.
</p></div>

<p>
等号の左側の`識別子$が
`呼戻~関数$の名前を与える。
等号の右側の［
返値型（ `ReturnType$g に合致）
と［
引数~list（ `ArgumentList$g に合致）
<span class="trans-note">【による一連の型】</span>
］］が，`呼戻~関数~型$の~signatureを与える。
◎
The identifier on the left of the equals sign gives the name of the callback function and the return type and argument list (matching ReturnType and ArgumentList) on the right side of the equals sign gives the signature of the callback function type.
</p>

<p>
`呼戻~関数$は
`定数$の型に利用されては~MUST_NOT。
◎
Callback functions MUST NOT be used as the type of a constant.
</p>

<p>
呼戻~関数には、次の拡張属性を適用し得る：
`TreatNonObjectAsNull$x
。
◎
The following extended attribute is applicable to callback functions: [TreatNonObjectAsNull].
</p>

<div class="grammar">
--CallbackOrInterface
--CallbackRestOrInterface
-CallbackRest
</div>


<div class="example">
<p>
次の `IDL 片$は、演算の完了-時に利用者により定義される関数を呼出す APIのために利用される，`呼戻~関数$を定義する。
◎
The following IDL fragment defines a callback function used for an API that invokes a user-defined function when an operation is complete.
</p>

<pre class="idl-code">
callback AsyncOperationCallback = void (DOMString status);

interface AsyncOperations {
  void performOperation(AsyncOperationCallback whenFinished);
};
</pre>

<p>
ECMAScript 言語束縛においては、
`Function^t ~objは演算~引数として渡される。
◎
In the ECMAScript language binding, a Function object is passed as the operation argument.
</p>

<pre class="es-code">
var ops = getAsyncOperations();  // <span title="Get an instance of AsyncOperations."
>`AsyncOperations^T の~instanceを取得する。</span>

ops.performOperation(function(status) {
  window.alert("Operation finished, status is " + status + ".");
});
</pre>
</div>
		</section>
		<section id="idl-typedefs">
<h3 title="Typedefs">3.7. ~typedef</h3>


<p>
`~typedef@
は、ある型に対し 新たな名前を宣言するために利用される，`定義$（ `Typedef$g に合致）である。
この新たな名前は、言語束縛からは公開されない。
これはもっぱら， IDL において型を参照するための略記法として利用される。
◎
A typedef is a definition (matching Typedef) used to declare a new name for a type. This new name is not exposed by language bindings; it is purely used as a shorthand for referencing the type in the IDL.
</p>

<pre class="syntax">
typedef `type^i `identifier^i;
</pre>

<p>
新たな名前が与えられる型（ `Type$g に合致）は， `typedef^c ~keywordの後に指定され、型に後続する `identifier$g ~tokが，その新たな名前を与える。
◎
The type being given a new name is specified after the typedef keyword (matching Type), and the identifier token following the type gives the name.
</p>

<p>
`Type$g が、同じまたは別の`~typedef$に識別されては~MUST_NOT。
◎
The Type MUST NOT identify the same or another typedef.
</p>

<p>
`~typedef$に適用し得る`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to typedefs.
</p>

<div class="grammar">
-Typedef
</div>


<div class="example">
<p>
次の `IDL 片$は、`~typedef$を利用して，長い`連列~型$の代わりに短い`識別子$を使えるようしている。
◎
The following IDL fragment demonstrates the use of typedefs to allow the use of a short identifier instead of a long sequence type.
</p>


<pre class="idl-code">
interface Point {
  attribute double x;
  attribute double y;
};

typedef sequence&lt;Point&gt; Points;

interface Widget {
  boolean pointWithinBounds(Point p);
  boolean allPointsWithinBounds(Points ps);
};
</pre>

</div>
		</section>
		<section id="idl-implements-statements">
<h3 title="Implements statements">3.8. ~implements_st</h3>


<p>
`~implements_st@
は、［［
文の左側の`識別子$により識別される~ifc %L
］を実装するすべての~objが，［
文の右側の識別子により識別される追加の~ifc %R
］を，
%R が継承する他のすべての~ifcも含めて，実装し~MUST
］ことを宣言するために利用される、`定義$（ `ImplementsStatement$g に合致）である。
◎
An implements statement is a definition (matching ImplementsStatement) used to declare that all objects implementing an interface A (identified by the first identifier) MUST additionally implement interface B (identified by the second identifier), including all other interfaces that B inherits from.
</p>

<pre class="syntax">
`identifier-L^i implements `identifier-R^i;
</pre>

<p>
%R も<!-- を実装している~objが -->，追加の~ifc %R1 を実装するための`~implements_st$を伴って宣言されている場合、推移的に， %L を実装するすべての~objは %R1 も追加で実装することになる。
◎
Transitively, if objects implementing B are declared with an implements statement to additionally implement interface C, then all objects implementing A do additionally implement interface C.
</p>

<ul>
	<li>
%L と %R は異なる~ifcで~MUST。
◎
The two identifiers MUST identify two different interfaces.
</li>
	<li>
%L は %R を`継承-$していては~MUST_NOT。
◎
The interface identified on the left-hand side of an implements statement MUST NOT inherit from the interface identifier on the right-hand side, and vice versa. Both identified interfaces also MUST NOT be callback interfaces.
</li>
	<li>
%R は %L を`継承-$していては~MUST_NOT。
◎
↑</li>
	<li>
%L, %R のいずれも，`呼戻~ifc$であっては~MUST_NOT。
◎
↑</li>
	<li>
各`~implements_st$を，［
%L を表現する~nodeから %R を表現する~nodeへ向かう，有向~graphの辺
］と見なすとき、この~graphは循環しては~MUST_NOT。
◎
If each implements statement is considered to be an edge in a directed graph, from a node representing the interface on the left-hand side of the statement to a node representing the interface on the right-hand side, then this graph MUST NOT have any cycles.
</li>
</ul>

<p>
</p>

<p>
</p>

<p class="trans-note">【
記号 %L, %R はここまで。
】</p>


<p>
所与の~objが実装する~ifcは、
`追補~ifc@
と見なされるものと, そうでないものに分類される。
~obj %O の`追補~ifc$は、次のものからなる：
◎
Interfaces that a given object implements are partitioned into those that are considered supplemental interfaces and those that are not. An interface A is considered to be a supplemental interface of an object O if:
</p>

<ul>
	<li>
%O が~ifc %B を実装するならば、
IDL により <code>%B implements %A</code> と言明されている~ifc %A は，
%O の追補~ifcである。
◎
O implements a different interface B, and the IDL states that B implements A; or
</li>
	<li>
%O の追補~ifcが`継承-$する~ifcは，
%O の追補~ifcである。
◎
O implements a different supplemental interface C, and C inherits from A.
</li>
</ul>

<p class="trans-note">【
訳では，原文の定義をより構成的な定義に変形している
— この方が解り易いので。
~implements_st, および継承の定義により， %O はそのすべての追補~ifcを実装することになる。
概念的には， %O が実装するすべての~ifcは［
%O の`主~ifc$, およびその`被継承~ifc$
］の集合と,
%O の追補~ifcの集合に二分されると考えられる。
】</p>

<div class="note">
<p>
左側の`~ifc$が（ある~objの）`追補~ifc$になるように
`~implements_st$を記すのは望ましくない。
例えば，仕様~策定者 1 が次を記していたとして：
◎
Specification authors are discouraged from writing implements statements where the interface on the left-hand side is a supplemental interface. For example, if author 1 writes:
</p>

<pre class="idl-code">
interface Window { ... };
interface SomeFunctionality { ... };
Window implements SomeFunctionality;
</pre>

<p>
後に，仕様~策定者 2 が次を記したとする：
◎
and author 2 later writes:
</p>

<pre class="idl-code">
interface Gizmo { ... };
interface MoreFunctionality { ... };
SomeFunctionality implements MoreFunctionality;
Gizmo implements SomeFunctionality;
</pre>

<p>
策定者 2 は、どの~ifcが
`implements SomeFunctionality^c
文の左側にすでに利用されるか正確に把握していないこともあり得る。
そのため、予期される以上の~objに対し，
`MoreFunctionality^T
の実装-が要求され得る。
◎
then it might be the case that author 2 is unaware of exactly which interfaces already are used on the left-hand side of an implements SomeFunctionality statement, and so has required more objects implement MoreFunctionality than he or she expected.
</p>

<p class="trans-note">【
前者の仕様から `SomeFunctionality^T を実装するものと想定されている~obj（ `Window^T ）が，（ `Window^T には~~関係ないかもしれない）後者の仕様により
`MoreFunctionality^T も実装しなければならなくなる。
】</p>

<p>
このような場合、策定者 2 は次の様に記す方が良いであろう：
◎
Better in this case would be for author 2 to write:
</p>

<pre class="idl-code">
interface Gizmo { ... };
interface MoreFunctionality { ... };
Gizmo implements SomeFunctionality;
Gizmo implements MoreFunctionality;
</pre>
</div>

<p>
~ifc %A の
`帰結~ifc@
は、次のものからなる：
◎
The consequential interfaces of an interface A are:
</p>
<ul>
	<li>
IDL により <code>%A implements %B</code> と言明されている，各~ifc %B, および
◎
each interface B where the IDL states A implements B;
</li>
	<li>
%A の帰結~ifcが継承する各~ifc, および
◎
each interface that a consequential interface of A inherits from; and
</li>
	<li>
%A の帰結~ifc %C に対し，
IDL により <code>%C implements %D</code> と言明されている、各~ifc %D 。
◎
each interface D where the IDL states that C implements D, where C is a consequential interface of A.
</li>
</ul>

<p class="trans-note">【
概念的には、 %A を実装するにあたって実装-が要求される~ifcすべての集合から， %A 自身および %A の`被継承~ifc$を除いたものと捉えられる。
】</p>

<p>
~ifc %B が~ifc %A の
`広義~帰結~ifc@
であるとは、 %B は［
%A 自身であるか, または %A の`帰結~ifc$である
］ことを意味する。
</p>

<p class="trans-note">【
“広義~帰結~ifc” は、この訳で導入した非公式な用語である
— この定義の方が，`帰結~ifc$を~~参照する ほぼすべての記述を簡潔に記せるので。
】</p>


<p>
所与の~ifcに対し、その，どの`広義~帰結~ifc$で定義される，どの~mbの識別子も、他の`広義~帰結~ifc$で定義される~mbの識別子と同じになっては~MUST_NOT。
<span class="trans-note">【
同じ~ifc上においては，`多重定義$があり得る。
】</span>
◎
For a given interface, there MUST NOT be any member defined on any of its consequential interfaces whose identifier is the same as any other member defined on any of those consequential interfaces or on the original interface itself.
</p>

<div class="note">
<p>
例えば、次は許容されない：
◎
For example, that precludes the following:
</p>

<pre class="idl-code">
interface A { attribute long x; };
interface B { attribute long x; };
A implements B;  // <span title="B::x would clash with A::x"
>`B::x^M と `A::x^M が衝突</span>

interface C { attribute long y; };
interface D { attribute long y; };
interface E : D { };
C implements E;  // <span title="D::y would clash with C::y"
>`D::y^M と `C::y^M が衝突</span>

interface F { };
interface H { attribute long z; };
interface I { attribute long z; };
F implements H;
F implements I;  // <span title="H::z and I::z would clash when mixed in to F"
>`H::z^M と `I::z^M が `F^T 内に併合される際に衝突</span>
</pre>
</div>

<p>
`~implements_st$に適用し得る`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to implements statements.
</p>

<div class="grammar">
-ImplementsStatement
</div>


<div class="example">
<p>
次の `IDL 片$は、２つの`~ifc$を定義する。
一方の~ifcが，他方を実装する~objに常に実装されることを言明する。
◎
The following IDL fragment defines two interfaces, stating that one interface is always implemented on objects implementing the other.
</p>

<pre class="idl-code">
interface Entry {
  readonly attribute unsigned short entryType;
  // <span>...</span>
};

interface Observable {
  void addEventListener(DOMString type,
                        EventListener listener,
                        boolean useCapture);
  // <span>...</span>
};

Entry implements Observable;
</pre>

<p>
ECMAScript 実装では、したがって，どの `Entry^T も
その原型鎖の中に `addEventListener^l ~propを持つことになる：
◎
An ECMAScript implementation would thus have an “addEventListener” property in the prototype chain of every Entry:
</p>

<pre class="es-code">
var e = getEntry();         // <span title="Obtain an instance of Entry."
>`Entry^T の~instanceを得る。</span>
typeof e.addEventListener;  // <!--cp-eval-function-->
</pre>

<!--JAVA
Similarly, in Java, any <span class='javatype'>Node</span> ...
-->

<p>
すべての `Observable^T ~objが `Entry^T を実装するのではないことに注意。
◎
Note that it is not the case that all Observable objects implement Entry.
</p>
</div>
		</section>
		<section id="idl-objects">
<h3 title="Objects implementing interfaces">3.9. ~ifcを実装している~obj</h3>


<p>
 `IDL 片$の集合の実装においては、
~objは
`~platform~obj@,
`利用者~obj@,
またはそのいずれでもないものとして記述され得る。
~platform~objと見なされる~objは次の２種類に分けられる：
◎
In a given implementation of a set of IDL fragments, an object can be described as being a platform object, a user object, or neither. There are two kinds of object that are considered to be platform objects:
</p>
<ul>
	<li>
`呼戻~ifc$でない`~ifc$を実装する~obj
◎
objects that implement a non-callback interface;
</li>

	<li>
IDL `DOMException$ を表現する~obj
◎
objects representing IDL DOMExceptions.
</li>
</ul>

<p>
~browserにおいては、例えば，［
~page内で走らせている ECMAScript に対し，~page内容への~accessを提供する
］ために，~browserに実装されている（ `Node^T や `Document^T などの~ifcを実装している） DOM ~objが、~platform~objになる。
これらの~objは、
C++ などの言語で実装される~exotic~objになるか,
または~native ECMAScript ~objになるであろう。
いずれにせよ，所与の IDL 片の集合に対する実装は、［
実装により作成されたすべての~platform~obj
］を認識できる必要がある。
これは、所与の~objに［
その~objが実装における~platform~objであるかどうかを記録するための，何らかの内的~状態
］を~~実際に持たせるか、あるいは, おそらく，［
~objが内部の一定の C++ クラスにより実装されているかどうか
］を見ることにより、実現し得るであろう。
~platform~objが，正確にどのように実装から認識されるかについては、実装~特有になる。
◎
In a browser, for example, the browser-implemented DOM objects (implementing interfaces such as Node and Document) that provide access to a web page’s contents to ECMAScript running in the page would be platform objects. These objects might be exotic objects, implemented in a language like C++, or they might be native ECMAScript objects. Regardless, an implementation of a given set of IDL fragments needs to be able to recognize all platform objects that are created by the implementation. This might be done by having some internal state that records whether a given object is indeed a platform object for that implementation, or perhaps by observing that the object is implemented by a given internal C++ class. How exactly platform objects are recognised by a given implementation of a set of IDL fragments is implementation specific.
</p>

<p>
~system内の他のすべての~objは、~platform~objとしては扱われないことになる。
例えば、~browserが開いた Web ~pageが， DOM Core を実装する ECMAScript ~libraryを読込んだとする。
この~libraryは、~browserが提供する実装とは異なる実装として扱われることになる。
ECMAScript ~libraryにより作成された［
`Node^T ~ifcを実装する~obj
］は、~browser実装による［
`Node^T を実装する~platform~obj
］としては扱われないことになる。
◎
All other objects in the system would not be treated as platform objects. For example, assume that a web page opened in a browser loads an ECMAScript library that implements DOM Core. This library would be considered to be a different implementation from the browser provided implementation. The objects created by the ECMAScript library that implement the Node interface will not be treated as platform objects that implement Node by the browser implementation.
</p>

<p>
利用者~objとは、［［
作者により定義される演算を Web API から呼出せるようにする，あるいは Web API からの~objの属性~操作を通して, 作者のプログラムと値を受け~~渡せるようにする
］ための`呼戻~ifc$
］を実装するものとして、作者が作成することになる~objである。
Web ~pageにおいては、 DOM Events 実装から呼出される呼戻を登録する際に利用される，［
`EventListener^T ~ifcを実装する ECMAScript ~obj
］が、利用者~objと見なされることになる。
◎
User objects are those that authors would create, implementing callback interfaces that the Web APIs use to be able to invoke author-defined operations or to send and receive values to the author’s program through manipulating the object’s attributes. In a web page, an ECMAScript object that implements the EventListener interface, which is used to register a callback that the DOM Events implementation invokes, would be considered to be a user object.
</p>

<p>
利用者~objが実装できるのは`呼戻~ifc$のみであり,
~platform~objが実装できるのは非~呼戻~ifcのみであることに注意。
◎
Note that user objects can only implement callback interfaces and platform objects can only implement non-callback interfaces.
</p>
<!-- 
When a non-platform object is passed to a platform object ...
-->
		</section>
<!-- 
<h3>Valuetypes</h3>
...
-->

		<section id="idl-types">
<h3 title="Types">3.10. 型</h3>


<p>
この節では、
Web IDL で~supportされる型,
それぞれの型に対応する値の集合,
その型の`定数$がどのように表現されるか,
について挙げていく。
◎
This section lists the types supported by Web IDL, the set of values corresponding to each type, and how constants of that type are represented.
</p>

<p>
互いに類似する型の集合には、次の様に総称が付与されている：
</p>

<dl >
	<dt>`整数~型@</dt>
	<dd>
`byte$T ,
`octet$T ,
`short$T ,
`unsigned short$T ,
`long$T ,
`unsigned long$T ,
`long long$T ,
`unsigned long long$T
◎
The following types are known as integer types: byte, octet, short, unsigned short, long, unsigned long, long long and unsigned long long.
</dd>

	<dt>`実数~型@</dt>
	<dd>
すべての`整数~型$ ,
`float$T ,
`unrestricted float$T ,
`double$T ,
`unrestricted double$T
◎
The following types are known as numeric types: the integer types, float, unresticted float, double and unrestricted double.
</dd>

	<dt>`~primitive型@</dt>
	<dd>
`boolean$T ,
すべての`実数~型$
◎
The primitive types are boolean and the numeric types.
</dd>

	<dt>`文字列~型@</dt>
	<dd>
`DOMString$T, すべての`列挙~型$ , `ByteString$T, `USVString$T
◎
The string types are DOMString, all enumeration types, ByteString and USVString.
</dd>

	<dt class="v2">`例外~型@</dt>
	<dd>
`Error$T, `DOMException$T
◎
The exception types are Error and DOMException.
</dd>

	<dt class="v2">`有型~配列~型@</dt>
	<dd>
`Int8Array$T,
`Int16Array$T,
`Int32Array$T,
`Uint8Array$T,
`Uint16Array$T,
`Uint32Array$T,
`Uint8ClampedArray$T,
`Float32Array$T,
`Float64Array$T
◎
The typed array types are Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array and Float64Array.
</dd>

	<dt class="v2">`~buffer~source型@</dt>
	<dd>
`ArrayBuffer$T,
`DataView$T,
すべての`有型~配列~型$
◎
The buffer source types are ArrayBuffer, DataView, and the typed array types.
</dd>

	<dt>`~obj~型@</dt>
	<dd>
`object$T 型, すべての `~ifc型$, すべての`例外~型$
◎
The object type, all interface types and the exception types are known as object types.
</dd>

</dl>


<p>
どの型も，型を識別するための文字列である
`型~名@
を持つ — それは一意になるとは限らない。
以下の各~節では、各~型にあてがわれる型~名も定義する。
◎
Every type has a type name, which is a string, not necessarily unique, that identifies the type. Each sub-section below defines what the type name is for each type.
</p>

<p id="type-conversion-exceptions">
`演算$の呼出しや`属性$に値を代入する際に必要になる，言語束縛~特有の型から IDL 型への変換はすべて、［
演算に指定された機能性や 属性~代入
］が実行に移される前に遂行される。
変換が遂行できない場合、演算は走らされず, 属性は更新されないことになる。
一部の言語束縛では、この型~変換により，例外が投出され得る。
そのような場合、これらの例外は，演算の呼出しや属性への代入-を試みた~codeまで，伝播することになる。
◎
When conversions are made from language binding specific types to IDL types in order to invoke an operation or assign a value to an attribute, all conversions necessary will be performed before the specified functionality of the operation or attribute assignment is carried out. If the conversion cannot be performed, then the operation will not run or the attribute will not be updated. In some language bindings, type conversions could result in an exception being thrown. In such cases, these exceptions will be propagated to the code that made the attempt to invoke the operation or assign to the attribute.
</p>

<div class="grammar">
-Type
-SingleType
-UnionType
-UnionMemberType
-UnionMemberTypes
-NonAnyType
-ConstType
-PrimitiveType
-UnrestrictedFloatType
-FloatType
-UnsignedIntegerType
-IntegerType
-OptionalLong
-PromiseType
-Null
</div>

			<section id="idl-any">
<h4 title="any">3.10.1. `any^T</h4>


<p>
`any$T 型は、 `共用体~型$ 以外のすべての型の和集合である。
その`型~名$は、 `Any^l である。
◎
The any type is the union of all other possible non-union types. Its type name is “Any”.
</p>

<p>
`any$T 型は、そのそれぞれの値ごとに固有の非 `any$T 型が結付けられる意味で，~~特別な共用体~型のようなものである。
例えば，
`any$T 型のある値は `unsigned long$T 150 をとり得る一方、別の値は `long$T 150 をとり得る。
これらは別々の型の値になる。
◎
The any type is like a discriminated union type, in that each of its values has a specific non-any type associated with it. For example, one value of the any type is the unsigned long 150, while another is the long 150. These are distinct values.
</p>

<p>
`any$T 型の個々の値の型は、その
`固有型@
と呼ばれる。
（ `共用体~型$の値も`固有型$を持つ。）
◎
The particular type of an any value is known as its specific type. (Values of union types also have specific types.)
</p>

<p class="trans-note">【
`any^T 型は，
`es-any$sec
にも見られる様に `null^V 値もとり得るようだが（従って暗黙的な意味で`~nullable$型になると考えられる）、明示的な言及が見当たらない（“すべての型” には~nullable型も含まれる？）。
<!-- 
おそらく、非~nullableの `any^T 型も在った方が，いくつかの定義はより簡潔に記せるように思われる。
 -->
】</p>


			</section>
			<section id="idl-boolean">
<h4 title="boolean">3.10.2. `boolean^T</h4>


<p>
`boolean$T 型は２つの値：
`true^V と `false^V をとり得る。
◎
The boolean type has two values: true and false.
</p>

<p>
IDL においては、 `boolean$T 定数~値は［
`true^c ／ `false^c
］~tokで表現される。
◎
boolean constant values in IDL are represented with the true and false tokens.
</p>

<p>
`boolean$T 型の`型~名$は、 `Boolean^l である。
◎
The type name of the boolean type is “Boolean”.
</p>
			</section>
			<section id="idl-integers">
<h4>3.10.2.3〜10. 整数~型</h4>

<p class="trans-note">【
この訳では、原文の 3.2.3 〜 3.2.10 節の内容
— 各種 IDL 整数~型の定義を集約して，一括して与える。
】</p>

<p>
各種 有符号／無符号 `整数~型$の，とり得る値の範囲, および `型~名$は、次の表で与えられる：
◎
The xxx := (byte|short|long|long long／octet|unsigned short|unsigned long|unsigned long long) type is a (signed／unsigned) integer type that has values in the range ([−P÷2, P÷2 − 1]／[0, P − 1]); P := 2^(8|16|32|64).
◎
xxx constant values in IDL are represented with integer tokens.
◎
The type name of the xxx type is “Xxx”.
</p>


<table class="matrix" id="matrix-idl-integers">

<thead><tr><th>IDL 型
</th><th>最小~値
</th><th>最大~値
</th><th>型~名
</th></tr></thead>

<tbody><tr><th>`byte@T
</th><td title="−128">−2`7^sup
</td><td title="127">2`7^sup − 1
</td><td>`Byte^l

</td></tr><tr><th>`octet@T
</th><td>0
</td><td title="255">2`8^sup − 1
</td><td>`Octet^l

</td></tr><tr><th>`short@T
</th><td title="−32768">−2`15^sup
</td><td title="32767">2`15^sup − 1
</td><td>`Short^l

</td></tr><tr><th>`unsigned short@T
</th><td>0
</td><td title="65535">2`16^sup − 1
</td><td>`UnsignedShort^l

</td></tr><tr><th>`long@T
</th><td title="−2147483648">−2`31^sup
</td><td title="2147483647">2`31^sup − 1
</td><td>`Long^l

</td></tr><tr><th>`unsigned long@T
</th><td>0
</td><td title="4294967295">2`32^sup − 1
</td><td>`UnsignedLong^l

</td></tr><tr><th>`long long@T
</th><td title="−9223372036854775808">−2`63^sup
</td><td title="9223372036854775807">2`63^sup − 1
</td><td>`LongLong^l

</td></tr><tr><th>`unsigned long long@T
</th><td>0
</td><td title="18446744073709551615">2`64^sup − 1
</td><td>`UnsignedLongLong^l

</td></tr></tbody></table>


<p>
IDL においては、どの`整数~型$の定数~値も， `integer$g ~tokで表現される。
</p>

			</section>
			<section id="idl-floats">
<h4>3.10.11〜14. 浮動小数点数~型</h4>

<p class="trans-note">【
この訳では、原文の 3.10.11 〜 3.10.14 節の内容
— 各種 IDL 浮動小数点数~型の定義を集約して，一括して与える。
】</p>

<p>
各種
“浮動小数点数 型”
— `整数~型$でない`実数~型$ —
の，とり得る値の範囲, および `型~名$は、次の表で与えられる：
</p>


<table class="matrix" id="matrix-idl-floats">

<thead><tr><th>IDL 型
</th><th>値の範囲 `IEEE-754$r
</th><th>型~名
</th></tr></thead>

<tbody><tr><th>`float@T
</th><td title="−128">
すべての有限［
単精度 32 ~bit IEEE 754 浮動小数点数
］の集合
◎
The float type is a floating point numeric type that corresponds to the set of finite single-precision 32 bit IEEE 754 floating point numbers. [IEEE-754]
</td><td>`Float^l

</td></tr><tr><th>`unrestricted float@T
</th><td>
すべての有限, 非~有限［
単精度 32 ~bit IEEE 754 浮動小数点数
］の集合
◎
The unrestricted float type is a floating point numeric type that corresponds to the set of all possible single-precision 32 bit IEEE 754 floating point numbers, finite and non-finite. [IEEE-754]
</td><td>`UnrestrictedFloat^l

</td></tr><tr><th>`double@T
</th><td>
すべての有限［
倍精度 64 ~bit IEEE 754 浮動小数点数
］の集合
◎
The double type is a floating point numeric type that corresponds to the set of finite double-precision 64 bit IEEE 754 floating point numbers. [IEEE-754]
</td><td>`Double^l

</td></tr><tr><th>`unrestricted double@T
</th><td>
すべての有限, 非~有限［
倍精度 64 ~bit IEEE 754 浮動小数点数
］の集合
◎
The unrestricted double type is a floating point numeric type that corresponds to the set of all possible double-precision 64 bit IEEE 754 floating point numbers, finite and non-finite. [IEEE-754]
</td><td>`UnrestrictedDouble^l

</td></tr></tbody></table>


<p>
IDL においては、どの浮動小数点数 型の定数~値も，
`float$g ~tokで表現される。
◎
The type name of the( xxx)? yyy type is “(Xxx)Yyy”.
</p>

<div class="warning">
<p>
特に 32 ~bit浮動小数点~型を利用する理由が無い限り，仕様は
`float$T でなく，`double$T を利用する~SHOULD。
`double$T が表現し得る値~集合は，より近く ECMAScript `Number^t に合致するので。
◎
Unless there are specific reasons to use a 32 bit floating point type, specifications SHOULD use double rather than float, since the set of values that a double can represent more closely matches an ECMAScript Number.
</p>
</div>

			</section>
			<section id="idl-DOMString">
<h4 title="DOMString">3.10.15. `DOMString^T</h4>


<p>
`DOMString$T 型は、可能なすべての［
`符号単位$の並び
］の集合に対応する。
そのような並びは、共通的に，
UTF-16 符号化~文字列 `RFC2781$r
として解釈されるが、要求されてはいない。
`DOMString$T は
<cite><a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-C74D1578">DOM Level 3 Core</a></cite>
（ `DOM3CORE$r, 1.2.1 節）
において［
OMG IDL boxed
<a class="idltype" href="#idl-sequence">sequence&lt;unsigned short&gt;</a>
valuetype
］として定義されているが、この文書は，文字列が要求される様々な状況における，その連列~型に対する特別な場合分けを避けるため、 `DOMString$T を内在的な型として定義する。
◎
The DOMString type corresponds to the set of all possible sequences of code units. Such sequences are commonly interpreted as UTF-16 encoded strings [RFC2781] although this is not required. While DOMString is defined to be an OMG IDL boxed sequence&lt;unsigned short&gt; valuetype in DOM Level 3 Core ([DOM3CORE], section 1.2.1), this document defines DOMString to be an intrinsic type so as to avoid special casing that sequence type in various situations where a string is required.
</p>

<div class="note"><p>
`null^V は `DOMString$T の値ではないことにも注意。
IDL において `null^V を許容するためには，
<code >DOMString?</code> と記される
<a href="#idl-nullable-type">~nullable</a>
`DOMString$T
を利用する必要がある。
◎
Note also that null is not a value of type DOMString. To allow null, a nullable DOMString, written as DOMString? in IDL, needs to be used.
</p></div>

<p>
この仕様においては、
`DOMString$T 値が妥当な UTF-16 文字列であることは要求されない。
例えば，
`DOMString$T 値は、対になっていない代用対（ surrogate pair ）文字も含み得る。
しかしながら， Web IDL を利用する仕様の策定者は、所与の個々の［
`符号単位$の並び
］から Unicode ~scalar値~列を得たいと求めることもあろう。
次の~algoは、 `DOMString$T 値 %S を
`Unicode ~scalar値~列に変換-@
する仕方を定義する：
◎
Nothing in this specification requires a DOMString value to be a valid UTF-16 string. For example, a DOMString value might include unmatched surrogate pair characters. However, authors of specifications using Web IDL might want to obtain a sequence of Unicode scalar values given a particular sequence of code units. The following algorithm defines a way to convert a DOMString to a sequence of Unicode scalar values:
</p>

<ol class="algorithm">
	<li>
%n := %S の長さ
◎
Let S be the DOMString value.
◎
Let n be the length of S.
</li>
	<li>
%i :← 0
◎
Initialize i to 0.
</li>
	<li>
%U :← Unicode 文字の空~連列
◎
Initialize U to be an empty sequence of Unicode characters.
</li>
	<li>
<p id="cp-while-i-n">
~WHILE %i &lt; %n ：
◎
While i &lt; n:
</p>


		<ol>
			<li>
%c := %S 内で~index %i に位置する`符号単位$
◎
Let c be the code unit in S at index i.
</li>
			<li>
<p>
%c の値に応じて：
◎
Depending on the value of c:
</p>
				<dl class="switch">
					<dt>%c &lt; 0xD800</dt>
					<dt>%c &gt; 0xDFFF</dt>
					<dd>

<p>
符号位置 %c の Unicode 文字を %U に付加する
◎
Append to U the Unicode character with code point c.
</p>
					</dd>
					<dt>0xDC00 ≤ %c ≤ 0xDFFF</dt>
					<dd>
<p>
~REPLACEMENT を %U に付加する
◎
Append to U a U+FFFD REPLACEMENT CHARACTER.
</p>
					</dd>
					<dt>0xD800 ≤ %c ≤ 0xDBFF</dt>
					<dd>
						<ol class="only">
							<li>
~IF
%i + 1 ≥ %n
~THEN
~REPLACEMENT を %U に付加する
◎
If i = n−1, then append to U a U+FFFD REPLACEMENT CHARACTER.
</li>
							<li>
<p>
~ELSE
⇒
◎
Otherwise, i &lt; n−1:
</p>
								<ol>
									<li>
%d := %S 内の~index %i + 1 に位置する`符号単位$
◎
Let d be the code unit in S at index i+1.
</li>
									<li>
<p>
~IF
0xDC00 ≤ %d ≤ 0xDFFF
⇒
◎
If 0xDC00 ≤ d ≤ 0xDFFF, then:
</p>
										<ol>
											<li>
符号位置 ［
2`16^sup + 2`10^sup × ( %c &amp; 0x3FF ) + ( %d &amp; 0x3FF )
］の Unicode 文字を %U に付加する
◎
Let a be c &amp; 0x3FF.
◎
Let b be d &amp; 0x3FF.
◎
Append to U the Unicode character with code point 2^16 + 2^10 a+b.
</li>
											<li>
%i ← %i&nbsp;+&nbsp;1
◎
Set i to i+1.
</li>
										</ol>
									</li>
									<li>
~ELSE
~THEN
~REPLACEMENT を %U に付加する
◎
Otherwise, d &lt; 0xDC00 or d &gt; 0xDFFF. Append to U a U+FFFD REPLACEMENT CHARACTER.
</li>
								</ol>
							</li>
						</ol>
					</dd>
				</dl>
			</li>
			<li>
%i ← %i&nbsp;+&nbsp;1
◎
Set i to i+1.
</li>
		</ol>
	</li>
	<li>
~RET %U
◎
Return U.
</li>
</ol>

<p>
IDL において，定数 `DOMString$T 値を表現する仕方は、ない。
`string$g ~literalを利用して， `DOMString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］に既定~値を指定することはできる。
◎
There is no way to represent a constant DOMString value in IDL, although DOMString dictionary member and operation optional argument default values can be specified using a string literal.
</p>

<p>
`DOMString$T 型の`型~名$は、 `String^l である。
◎
The type name of the DOMString type is “String”.
</p>

			</section>
			<section id="idl-ByteString" class="v2">
<h4 title="ByteString">3.10.16. `ByteString^T</h4>

<p>
`ByteString$T 型は、可能なすべての［
byte の並び
］の集合に対応する。
その種の並びは、要求されてはいないが，［
UTF-8 に符号化された文字列 `RFC3629$r, あるいは［
他の何らかの［ 1 符号単位あたり 8 ~bit ］になる符号化方式
］により符号化された文字列
］に解釈し得る。
◎
The ByteString type corresponds to the set of all possible sequences of bytes. Such sequences might be interpreted as UTF-8 encoded strings [RFC3629] or strings in some other 8-bit-per-code-unit encoding, although this is not required.
</p>

<p>
IDL において，定数 `ByteString$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant ByteString value in IDL.
</p>

<p>
`ByteString$T 型の`型~名$は、 `ByteString^l である。
◎
The type name of the ByteString type is “ByteString”.
</p>

<div class="warning">
<p>
仕様は、［
HTTP などの， byte や文字列を交換可能な~~形で利用する~protocol
］とのやりとりのみに，
`ByteString$T を利用する~SHOULD。
一般に、文字列は，その値が［
常に ASCII または 何らかの 8 ~bit文字~符号化方式
］になることが期待されているとしても，
`DOMString$T 値により表現される~SHOULD。
8 ~bit~dataを保持するためには、`ByteString$T ではなく，［
`octet$T または `byte$T
］を要素とする［
`連列~型$ ／ `凍結~配列~型$ ／
<a href="http://www.khronos.org/registry/typedarray/specs/latest/">Typed Arrays</a>
`TYPEDARRAYS$r
］が利用される~SHOULD。
<span class="trans-note">【
Typed Arrays は~buffer~source型（ `idl-buffer-source-types$sec ）に置き換わっている
— 更新漏れ？
】</span>
◎
Specifications SHOULD only use ByteString for interfacing with protocols that use bytes and strings interchangably, such as HTTP. In general, strings SHOULD be represented with DOMString values, even if it is expected that values of the string will always be in ASCII or some 8 bit character encoding. Sequences, frozen arrays or Typed Arrays with octet or byte elements SHOULD be used for holding 8 bit data rather than ByteString. [TYPEDARRAYS]
</p></div>

			</section>
			<section id="idl-USVString" class="v2">
<h4 title="USVString">3.10.17. `USVString^T</h4>

<p>
`USVString$T 型は、可能なすべての［［
`Unicode ~scalar値$
— ~surrogate符号位置でない Unicode 符号位置
］の並び
］の集合に対応する。
◎
The USVString type corresponds to the set of all possible sequences of Unicode scalar values, which are all of the Unicode code points apart from the surrogate code points.
</p>

<p>
IDL において，定数 `USVString$T 値を表現する仕方は、ない。
`string$g ~literalを利用して， `USVString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］に既定~値を指定することはできる。
◎
There is no way to represent a constant USVString value in IDL, although USVString dictionary member and operation optional argument default values can be specified using a string literal.
</p>

<p>
`USVString$T 型の`型~名$は、 `USVString^l である。
◎
The type name of the USVString type is “USVString”.
</p>

<div class="warning"><p>
仕様は、［
テキスト処理を遂行する際に Unicode ~scalar値による文字列~演算が必要になる
］ときにのみ， API に `USVString$T を利用する~SHOULD。
文字列を利用する ほとんどの API は、文字列~内の`符号単位$に いかなる解釈も行わない `DOMString$T を利用するべきである。
疑わしい場合は `DOMString$T を利用すること。
◎
Specifications SHOULD only use USVString for APIs that perform text processing and need a string of Unicode scalar values to operate on. Most APIs that use strings should instead be using DOMString, which does not make any interpretations of the code units in the string. When in doubt, use DOMString.
</p></div>

			</section>
			<section id="idl-object">
<h4 title="object">3.10.18. `object^T</h4>

<p>
`object$T 型は、可能なすべての［
非 `null^V ~obj参照
］の集合に対応する。
◎
The object type corresponds to the set of all possible non-null object references.
</p>

<p>
IDL において，定数 `object$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant object value in IDL.
</p>

<p>
可能なすべての~obj参照に加えて，
`null^V 値も内包する型を表すためには、
`~nullable型$ `object?^T を利用する。
◎
To denote a type that includes all possible object references plus the null value, use the nullable type object?.
</p>

<p>
`object$T 型の`型~名$は、 `Object^l である。
◎
The type name of the object type is “Object”.
</p>
			</section>
			<section id="idl-interface">
<h4 title="Interface types">3.10.19. ~ifc型</h4>


<p>
`~ifc$を識別する`識別子$は、その~ifcを実装する，可能なすべての［
非 `null^V ~obj参照の集合
］に対応する型を指すために利用される。
◎
An identifier that identifies an interface is used to refer to a type that corresponds to the set of all possible non-null references to objects that implement that interface.
</p>

<p>
非~呼戻~ifcに対する~ifc型の IDL 値は，単に~obj参照により表現される。
`呼戻~ifc$ に対しては、~ifc型の IDL 値は［
~obj参照,
`呼戻~文脈$
］の組により表現される。
`呼戻~文脈@
とは、言語束縛~特有の値であり、［
言語束縛~特有の~obj参照が IDL 値に変換される時点における，実行~文脈についての情報
］を格納するために利用されるものである。
◎
For non-callback interfaces, an IDL value of the interface type is represented just by an object reference. For callback interfaces, an IDL value of the interface type is represented by a tuple of an object reference and a callback context. The callback context is a language binding specific value, and is used to store information about the execution context at the time the language binding specific object reference is converted to an IDL value.
</p>

<div class="note"><p>
ECMAScript ~objに対しては、`呼戻~文脈$は，
`Object^t 値が IDL 呼戻~ifc型の値に変換される時点の
`incumbent-script^ `HTML$r への参照を保持するために利用される。
`es-interface$sec
を見よ。
◎
For ECMAScript objects, the callback context is used to hold a reference to the incumbent script [HTML] at the time the Object value is converted to an IDL callback interface type value. See section 4.2.20 below.
</p></div>

<p>
IDL において，個々の~ifc型の定数~obj参照~値を表現する仕方は、ない。
◎
There is no way to represent a constant object reference value for a particular interface type in IDL.
</p>

<p>
所与の~ifcを実装する，可能なすべての~obj参照に加えて、
`null^V 値も内包する型を表すためには，`~nullable型$を利用する。
◎
To denote a type that includes all possible references to objects implementing the given interface plus the null value, use a nullable type.
</p>

<p>
~ifc型の`型~名$は、その~ifcの`識別子$である。
◎
The type name of an interface type is the identifier of the interface.
</p>
			</section>
			<section id="idl-dictionary">
<h4 title="Dictionary types">3.10.20. 辞書~型</h4>


<p>
`辞書$を識別する`識別子$は、［
辞書~定義に~~寄与する，すべての辞書の集合
］に対応する型を指すために利用される。
◎
An identifier that identifies a dictionary is used to refer to a type that corresponds to the set of all dictionaries that adhere to the dictionary definition.
</p>

<p>
IDL において，定数~辞書~値を表現する仕方は、ない。
◎
There is no way to represent a constant dictionary value in IDL.
</p>

<p>
辞書~型の`型~名$は、その辞書の`識別子$である。
◎
The type name of a dictionary type is the identifier of the dictionary.
</p>
			</section>
			<section id="idl-enumeration">
<h4 title="Enumeration types">3.10.21. 列挙~型</h4>


<p>
`列挙$を識別する`識別子$は、［
その`列挙~値$に属する文字列（ `DOMString$T と同様の，`符号単位$の並び）の集合
］を値にとる型を指すために利用される。
<!--  -->
◎
An identifier that identifies an enumeration is used to refer to a type whose values are the set of strings (sequences of code units, as with DOMString) that are the enumeration’s values.
</p>

<p>
`DOMString$T と同様に、
IDL において，定数`列挙$値を表現する仕方は、ない。
`string$g ~literalを利用して、列挙~型にされた`辞書~mb$に
`辞書既定値^を指定することはできる。
◎
Like DOMString, there is no way to represent a constant enumeration value in IDL, although enumeration-typed dictionary member default values can be specified using a string literal.
</p>

<p>
列挙~型の`型~名$は、その列挙の`識別子$である。
◎
The type name of an enumeration type is the identifier of the enumeration.
</p>
			</section>
			<section id="idl-callback-function">
<h4 title="Callback function types">3.10.22. 呼戻~関数~型</h4>


<p>
`呼戻~関数$を識別する`識別子$は、［
所与の~signatureを伴う関数~objへの参照
］を値にとる型を指すために利用される。
◎
An identifier that identifies a callback function is used to refer to a type whose values are references to objects that are functions with the given signature.
</p>

<p>
呼戻~関数~型の IDL 値は，［
~obj参照, `呼戻~文脈$
］の組により表現される。
◎
An IDL value of the callback function type is represented by a tuple of an object reference and a callback context.
</p>

<div class="note"><p>
`~ifc型$と同様に、`呼戻~文脈$は，
ECMAScript `Object^t 値が IDL 呼戻~ifc型の値に変換される時点の
`incumbent-script^ `HTML$r への参照を保持するために利用される。
`es-callback-function$sec
を見よ。
◎
As with callback interface types, the callback context is used to hold a reference to the incumbent script [HTML] at the time an ECMAScript Object value is converted to an IDL callback function type value. See section 4.2.23 below.
</p></div>


<p>
IDL において，定数  `呼戻~関数$値を表現する仕方は、ない。
◎
There is no way to represent a constant callback function value in IDL.
</p>

<p>
呼戻~関数~型の`型~名$は、その呼戻~関数の`識別子$である。
◎
The type name of a callback function type is the identifier of the callback function.
</p>
			</section>
			<section id="idl-nullable-type">
<h4 title="Nullable types — T?">3.10.23. ~nullable型 — `~varT?^T</h4>


<div class="p">
<p>
`~nullable型@
は、（その
`内部型@
と呼ばれる）既存の型から構築される IDL 型であり、許容される~mbは，内部型の値の集合に 値 `null^V のみを~~追加したものになる。
IDL においては、`~nullable型$は，既存の型の後に
`U+003F QUESTION MARK ("?")^char
文字を置いて表現される。
`内部型$は次のいずれであっても~MUST_NOT：
</p>

<ul ><li>`any$T 型
</li><li>別の~nullable型
</li><li>`共用体~型$であって［
それ自身が`~nullable型を内包する$, または
その`平坦化~mb型$に辞書~型が含まれている
］もの。
</li></ul>

◎
A nullable type is an IDL type constructed from an existing type (called the inner type), which just allows the additional value null to be a member of its set of values. Nullable types are represented in IDL by placing a U+003F QUESTION MARK ("?") character after an existing type. The inner type MUST NOT be any, another nullable type, or a union type that itself has includes a nullable type or has a dictionary type as one of its flattened member types.
</div>

<div class="note"><p>
辞書~型は一般に~nullableになれるが、その場合，演算~引数や辞書~mbの型として利用することはできない。
◎
Although dictionary types can in general be nullable, they cannot when used as the type of an operation argument or a dictionary member.
</p></div>

<p>
IDL においては、~nullable型の定数~値は，その`内部型$の定数~値と同じ仕方で表現されるか, または `null^c ~tokで表現される。
◎
Nullable type constant values in IDL are represented in the same way that constant values of their inner type would be represented, or with the null token.
</p>

<p>
~nullable型の`型~名$は、［
その内部型 %T の型~名,
文字列 `OrNull^l
］の連結である。
◎
The type name of a nullable type is the concatenation of the type name of the inner type T and the string “OrNull”.
</p>

<div class="example">
<p>
例えば、値
`true^V, `false^V, `null^V
をとり得る型は， `boolean?^T と記される：
◎
For example, a type that allows the values true, false and null is written as boolean?:
</p>

<pre class="idl-code">
interface MyConstants {
  const boolean? ARE_WE_THERE_YET = false;
};
</pre>

<p>
次の`~ifc$は２個の`属性$を持つ。
一方は `DOMString$T または `null^V 値を値にとり得る。
他方は `Node^T ~objへの参照または `null^V 値を値にとり得る：
◎
The following interface has two attributes: one whose value can be a DOMString or the null value, and another whose value can be a reference to a Node object or the null value:
</p>

<pre class="idl-code">
interface Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute Node? parentNode;
  // <span>...</span>
};
</pre>
</div>
			</section>
			<section id="idl-sequence" class="v2">
<h4 title="Sequences — sequence&lt;T&gt;">3.10.24. 連列 — `sequence&lt;~varT&gt;^T</h4>


<p>
`sequence_T^
型は、［［
型 %T の値
］の連列（長さゼロも許容される）
］を値にとり得るような，~parameter化された型である。
◎
The sequence&lt;T&gt; type is a parameterized type whose values are (possibly zero-length) sequences of values of type T.
</p>

<p>
連列は常に値渡しである。
連列が何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に連列が渡された際に，その連列への参照がその~objに保有されることはない。
同様に，~platform~objから返されるどの連列も複製であり、それに対する改変は~platform~objからは見えないことになる。
◎
Sequences are always passed by value. In language bindings where a sequence is represented by an object of some kind, passing a sequence to a platform object will not result in a reference to the sequence being kept by that object. Similarly, any sequence returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>
<p>
IDL において，定数~連列~値を表現する仕方は、ない。
◎
There is no way to represent a constant sequence value in IDL.
</p>

<p>
連列は［
`属性$／`定数$
］の型に利用されては~MUST_NOT。
◎
Sequences MUST NOT be used as the type of an attribute or constant.
</p>

<div class="note"><p>
この制約は、［
`連列~型$は、その参照が渡し回されるものではなく，複製されるものである
］ことを，仕様~策定者や利用者から見て明らかにするためにある。
連列~型の~writableな`属性$には、代わりに，連列を取得-／設定する`演算$~pairの利用を勧める。
◎
This restriction exists so that it is clear to specification writers and API users that sequences are copied rather than having references to them passed around. Instead of a writable attribute of a sequence type, it is suggested that a pair of operations to get and set the sequence is used.
</p></div>

<p>
連列~型の`型~名$は、［
%T の型~名,
文字列 `Sequence^l
］の連結である。
◎
The type name of a sequence type is the concatenation of the type name for T and the string “Sequence”.
</p>
			</section>
			<section id="idl-promise" class="v2">

<h4 title="Promise types — Promise&lt;T&gt;">3.10.25. ~promise型 — `Promise&lt;~varT&gt;^T</h4>

<p>
`~promise~型@
は、その値が ［［
“［
非同期 演算において，延期され得る（非同期にもなり得る）計算
］の最終的な結果へのプレースホルダ” `ECMA-262$r
］として利用される~obj
］への参照であるような，~parameter化された型である。
~promise~objの意味論についての詳細は ECMAScript 仕様
<a href="~ES6#sec-promise-objects">25.4 節</a>
に。
◎
A promise type is a parameterized type whose values are references to objects that “is used as a place holder for the eventual results of a deferred (and possibly asynchronous) computation result of an asynchronous operation” [ECMA-262]. See section 25.4 of the ECMAScript specification for details on the semantics of promise objects.
</p>

<p>
IDL において，~promise値を表現する仕方は、ない。
◎
There is no way to represent a promise value in IDL.
</p>

<p>
~promise型の`型~名$は、［
%T の型~名,
文字列 `Promise^l
］の連結である。
◎
The type name of a promise type is the concatenation of the type name for T and the string “Promise”.
</p>


			</section>
			<section id="idl-union">
<h4 title="Union types">3.10.26. 共用体~型</h4>


<p>
`~共用体~型@
は、とり得る値の集合が 複数の型の値の和集合であるような，型である。
共用体~型（ `UnionType$g に合致）は、
`or^c ~keywordで区切られた型の並びを左右~丸括弧で括って記される。
共用体~型を構成する型は、共用体の
`~mb型@
と呼ばれる。
◎
A union type is a type whose set of values is the union of those in two or more other types. Union types (matching UnionType) are written as a series of types separated by the or keyword with a set of surrounding parentheses. The types which comprise the union type are known as the union’s member types.
</p>

<div class="note">
<p>
例えば，
`(Node or DOMString)^c や `(double or sequence&lt;double&gt;)^c
などのように記す。
`共用体~型$に全体として `?^c 接尾辞を適用するときは，
`(Node or DOMString)?^c
のように，右~丸括弧の後に置く。
◎
For example, you might write (Node or DOMString) or (double or sequence&lt;double&gt;). When applying a ? suffix to a union type as a whole, it is placed after the closing parenthesis, as in (Node or DOMString)?.
</p>

<p>
共用体~型の`~mb型$は、入子にされた共用体~型にまでは掘り下げられないことに注意。
したがって，
`(double or (sequence&lt;long&gt; or Event) or (Node or DOMString)?)^c
に対する~mb型は
`double^T ,
`(sequence&lt;long&gt; or Event)^T ,
`(Node or DOMString)?^T
になる。
◎
Note that the member types of a union type do not descend into nested union types. So for (double or (sequence&lt;long&gt; or Event) or (Node or DOMString)?) the member types are double, (sequence&lt;long&gt; or Event) and (Node or DOMString)?.
</p>
</div>

<p>
`any$T 型と同様、共用体~型の値は，その値に合致するいずれか一つの`~mb型$を`固有型$として持つ。
◎
Like the any type, values of union types have a specific type, which is the particular member type that matches the value.
</p>

<p>
`共用体~型$ %T の
`平坦化~mb型@
とは、次の手続きで決定される型の集合である：
◎
The flattened member types of a union type is a set of types determined as follows:
</p>

<ol>
	<li>
%S :← ∅
◎
Let T be the union type.
◎
Initialize S to ∅.
</li>
	<li>
<p id="cp-foreach-union-mb">
~FOR
%T 内の~EACH ( `~mb型$ %U ) に対し：
◎
For each member type U of T:
</p>
		<ol>
			<li>
~IF
%U は `~nullable型$である
~THEN
%U ← %U の`内部型$
◎
If U is a nullable type, then set U to be the inner type of U.
</li>
			<li>
~IF
%U は `共用体~型$である
~THEN
%U の`平坦化~mb型$に属するすべての型を %S に追加する
◎
If U is a union type, then add to S the flattened member types of U.
</li>
			<li>
~ELSE
~THEN
%U を %S に追加する
◎
Otherwise, U is not a union type. Add U to S.
</li>
		</ol>
	</li>
	<li>
~RET %S
◎
Return S.
</li>
</ol>

<div class="note"><p>
例えば，`共用体~型$
`(Node or (sequence&lt;long&gt; or Event) or (XMLHttpRequest or DOMString)? or sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;)^c
の`平坦化~mb型$は、６つの型［
`Node^T ,
`sequence&lt;long&gt;^T ,
`Event^T ,
`XMLHttpRequest^T ,
`DOMString^T ,
`sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;^T
］からなる。
◎
For example, the flattened member types of the union type (Node or (sequence&lt;long&gt; or Event) or (XMLHttpRequest or DOMString)? or sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;) are the six types Node, sequence&lt;long&gt;, Event, XMLHttpRequest, DOMString and sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;.
</p></div>

<p>
`共用体~型$ %T の
`~nullable~mb型の個数@
とは、次の手続きで決定される整数である：
◎
The number of nullable member types of a union type is an integer determined as follows:
</p>

<ol>
	<li>
%n :← 0
◎
Let T be the union type.
◎
Initialize n to 0.
</li>
	<li>
<!--cp-foreach-union-mb-->
		<ol>
			<li>
<p>
~IF
%U は `~nullable型$である
⇒
◎
If U is a nullable type, then:
</p>
				<ol>
					<li>
%n ← %n + 1
◎
Set n to n + 1.
</li>
					<li>
%U ← %U の`内部型$
◎
Set U to be the inner type of U.
</li>
				</ol>
			</li>
			<li>
<p>
~IF
%U は `共用体~型$である
⇒
◎
If U is a union type, then:
</p>
				<ol>
					<li>
%m := %U の`~nullable~mb型の個数$
◎
Let m be the number of nullable member types of U.
</li>
					<li>
%n ← %n + %m
◎
Set n to n + m.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %n
◎
Return n.
</li>
</ol>

<p>
`~mb型$に `any$T 型が利用されては~MUST_NOT。
◎
The any type MUST NOT be used as a union member type.
</p>

<p>
`共用体~型$の
`~nullable~mb型の個数$
は 0 か 1 で~MUST。
1 の場合、その共用体~型は`平坦化~mb型$に辞書~型を持っては~MUST_NOT。
◎
The number of nullable member types of a union type MUST be 0 or 1, and if it is 1 then the union type MUST also not have a dictionary type in its flattened member types.
</p>

<p>
次を満たす型は
`~nullable型を内包する@
とされる。
◎
A type includes a nullable type if:
</p>

<ul>
	<li>
`~nullable型$である, または
◎
the type is a nullable type, or
	</li>
	<li>
`共用体~型$であり, かつ
その `~nullable~mb型の個数$が 0 でない（ 1 である）。
◎
the type is a union type and its number of nullable member types is 1.
	</li>
</ul>

<p class="trans-note">【
概念的には， `null^V を値にとり得る型と考えられる。
ただし、この定義では `any$T 型は含まれないことになる。
】</p>

<p>
`共用体~型$の`平坦化~mb型$に属する
どの２つの型も`判別可能$で~MUST。
◎
Each pair of flattened member types in a union type, T and U, MUST be distinguishable.
</p>

<p>
IDL においては、`共用体~型$の定数~値は，それらの`~mb型$の定数~値と同じ仕方で表現される。
◎
Union type constant values in IDL are represented in the same way that constant values of their member types would be represented.
</p>

<p>
共用体~型の`型~名$は、その各~mb型の型~名を順に，文字列 `Or^l で連結したものである。
◎
The type name of a union type is formed by taking the type names of each member type, in order, and joining them with the string “Or”.
</p>
<div class="grammar">
--UnionType
--UnionMemberType
--UnionMemberTypes
--NonAnyType
</div>
			</section>
			<section id="idl-RegExp" class="v2 L2">
<h4 title="RegExp">3.10.27. `RegExp^T</h4>

<p>
`RegExp$T 型は、［
正規表現を表現する~obj
］への参照を値にとる型である。
特定0の正規表現~言語や，それが~supportする特色機能は、言語束縛~特有になる。
◎
The RegExp type is a type whose values are references to objects that represent regular expressions. The particular regular expression language and the features it supports is language binding specific.
</p>

<p>
IDL において，定数 `RegExp$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant RegExp value in IDL.
</p>

<p>
`RegExp$T の`型~名$は、 `RegExp^l である。
◎
The type name of the RegExp type is “RegExp”.
</p>


			</section>
			<section id="idl-Error" class="v2">
<h4 title="Error">3.10.28. `Error^T</h4>

<p>
`Error$T 型は、［
`単純例外$, `DOMException$
］を含む，可能なすべての［
非 null 例外~objへの参照
］の集合に対応する。
◎
The Error type corresponds to the set of all possible non-null references to exception objects, including simple exceptions and DOMExceptions.
</p>

<p>
IDL において，定数 `Error$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant Error value in IDL.
</p>

<p>
`Error$T の`型~名$は、 `Error^l である。
◎
The type name of the Error type is “Error”.
</p>

			</section>
			<section id="idl-DOMException" class="v2">
<h4 title="DOMException">3.10.29. `DOMException^T</h4>

<p>
`DOMException$T 型は、可能なすべての［
非 `null^V `DOMException$
を表現する~obj参照
］の集合に対応する。
◎
The DOMException type corresponds to the set of all possible non-null references to objects representing DOMExceptions.
</p>

<p>
IDL において，定数 `DOMException$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant DOMException value in IDL.
</p>

<p>
`DOMException$T の`型~名$は、 `DOMException^l である。
◎
The type name of the DOMException type is “DOMException”.
</p>

			</section>
			<section id="idl-buffer-source-types" class="v2">
<h4 title="Buffer source types">3.10.30. ~buffer~source型</h4>

<p>
可能なすべての［［［
~dataの~buffer, または［
~dataの~buffer上の~view
］］を表現する~obj
］への 非 `null^V 参照
］の集合に対応する，いくつかの型がある。
下の一覧に、それらの型, および それらが表現する［
~bufferまたは その~view
］の種類を挙げる。
◎
There are a number of types that correspond to sets of all possible non-null references to objects that represent a buffer of data or a view on to a buffer of data. The table below lists these types and the kind of buffer or view they represent.
</p>


<table class="vert">

<thead><tr><th>型◎Type
</th><th>~bufferの種類◎Kind of buffer
</th></tr></thead>

<tbody><tr><td>`ArrayBuffer@T
</td><td>
固定的な個数の~byteからなる~bufferへの~pointer（ `null^V もとり得る）を保持する~obj。
◎
An object that holds a pointer (which may be null) to a buffer of a fixed number of bytes

</td></tr><tr><td>`DataView@T
</td><td>
`ArrayBuffer$T への~viewであって、~bufferの中の，任意の~offsetに格納されている 整数／浮動小数点 値への~accessを可能にするもの。
◎
A view on to an ArrayBuffer that allows typed access to integers and floating point values stored at arbitrary offsets into the buffer

</td></tr><tr><td>`Int8Array@T,<br>`Int16Array@T,<br>`Int32Array@T
</td><td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの ２の補数による有符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of two’s complement signed integers of the given size in bits

</td></tr><tr><td>`Uint8Array@T,<br>`Uint16Array@T,<br>`Uint32Array@T
</td><td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの 無符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of unsigned integers of the given size in bits

</td></tr><tr><td>`Uint8ClampedArray@T
</td><td>
`ArrayBuffer$T への~viewであって、値を切詰める変換も伴われるような，［
8~bit無符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of unsigned 8 bit integers with clamped conversions

</td></tr><tr><td>`Float32Array@T,<br>`Float64Array@T
</td><td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの IEEE 754 浮動小数点数
］からなる配列を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of IEEE 754 floating point numbers of the given size in bits

</td></tr></tbody></table>

<div class="note"><p>
これらの型はすべて、 ECMAScript にて定義される~classに対応する。
◎
These types all correspond to classes defined in ECMAScript.
</p></div>

<p>
`ArrayBuffer$T ~objを
`切離す@
とは、その~bufferへの~pointerを `null^v に設定することである。
◎
To detach an ArrayBuffer is to set its buffer pointer to null.
</p>

<p>
これらのどの型についても、
IDL において，その型の定数~値を表現する仕方は、ない。
◎
There is no way to represent a constant value of any of these types in IDL.
</p>

<p>
これらのどの型についても，その`型~名$は、その型~自身の名前である。
◎
The type name of all of these types is the name of the type itself.
</p>

<p>
仕様の中の注釈文レベルにおいては、 IDL `~buffer~source型$は，単純に~objへの参照である。
仕様の注釈文にて，~buffer内の~byte列を 検分したり操作するときは、最初に，~buffer~sourceに保持されている~byte列の
<a id="dfn-get-buffer-source-copy">`参照／複製を取得-@</a>
する手続きを介さ~MUST。
仕様の注釈文では、その結果の~byte列への参照／複製を利用して，個々の~byte値を取得したり設定できる。
◎
At the specification prose level, IDL buffer source types are simply references to objects. To inspect or manipulate the bytes inside the buffer, specification prose MUST first either get a reference to the bytes held by the buffer source or get a copy of the bytes held by the buffer source. With a reference to the buffer source’s bytes, specification prose can get or set individual byte values using that reference.
</p>

<div class="warning">
<p>
仕様において、［
~buffer~sourceに保持されている~byteへの参照を取得する
］ような テキストを書くときには、細心の注意を払う必要がある
— 下層の~dataは、予測し得ない時に作者や他の API により，容易に変更され得るので。
改変されないような ~binary~dataの~chunkを得るために，演算~引数として~buffer~source型を利用する場合は、その演算を定義する注釈文の始めの方で，~buffer~sourceの~byte列の複製を取得することが、強く推奨される。
◎
Extreme care must be taken when writing specification text that gets a reference to the bytes held by a buffer source, as the underyling data can easily be changed by the script author or other APIs at unpredictable times. If you are using a buffer source type as an operation argument to obtain a chunk of binary data that will not be modified, it is strongly recommended to get a copy of the buffer source’s bytes at the beginning of the prose defining the operation.
</p><!-- underyling underlaying -->

<p>
~byte列の 参照／複製 を取得する明示的な注釈文を要することの意図は、仕様の査読者が，これらの~buffer~source型の利用に孕まれる問題を見つけ易くするためである。
◎
Requiring prose to explicitly get a reference to or copy of the bytes is intended to help specification reviewers look for problematic uses of these buffer source types.
</p></div>

<div class="note"><p>
~bufferを~~入力にとる API を設計するときは、 `ArrayBuffer$T や他の~view~型よりも `BufferSource^T ~typedefの利用が推奨される。
◎
When designing APIs that take a buffer, it is recommended to use the BufferSource typedef rather than ArrayBuffer or any of the view types.
</p>

<p>
~bufferを作成したり返す API を設計するときは、
`Uint8Array$T よりも `ArrayBuffer$T 型の利用が推奨される。
◎
When designing APIs that create and return a buffer, it is recommended to use the ArrayBuffer type rather than Uint8Array.
</p></div>

<p>
`切離された$ `ArrayBuffer$T ~objに対し，~buffer~sourceに保持されている~byte列の`参照／複製を取得-$しようと試みたときは、言語束縛~特有の方式で失敗することになる。
◎
Attempting to get a reference to or get a copy of the bytes held by a buffer source when the ArrayBuffer has been detached will fail in a language binding-specific manner.
</p>

<div class="note"><p>
ECMAScript 言語束縛において ~buffer~source型とのやりとりがどのように働くかについては、`es-buffer-source-types$secに。
◎
See section 4.2.31 below for how interacting with buffer source types works in the ECMAScript language binding.
</p></div>

<div class="ednote">

<p>
これらの型や用語を利用する仕様テキストの例を含ませる必要がある。
◎
We should include an example of specification text that uses these types and terms.
</p></div>

			</section>
			<section id="idl-frozen-array" class="v2">
<h4 title="Frozen arrays — FrozenArray&lt;T&gt;">3.10.31. 凍結~配列~型 — `FrozenArray&lt;~varT&gt;^T</h4>

<p>
`~凍結~配列~型@
は、［［［
一連の［
改変できない，型 ~varT の値
］からなる，固定長の配列
］を保持する~obj
］への参照
］を値にとり得るような，~parameter化された型である。
◎
A frozen array type is a parameterized type whose values are references to objects that hold a fixed length array of unmodifiable values. The values in the array are of type T.
</p>

<p>
`FrozenArray_T^ 値は参照である
— 値の~listであり，値渡しである`連列~型$と違って。
◎
Since FrozenArray&lt;T&gt; values are references, they are unlike sequence types, which are lists of values that are passed by value.
</p>

<p>
IDL において，定数~凍結~配列~値を表現する仕方は、ない。
◎
There is no way to represent a constant frozen array value in IDL.
</p>

<p>
凍結~配列~型の`型~名$は、［
%T の型~名,
文字列 `Array^l
］の連結である。
◎
The type name of a frozen array type is the concatenation of the type name for T and the string “Array”.
</p>

			</section>
		</section>
		<section id="idl-extended-attributes">
<h3 title="Extended attributes">3.11. 拡張属性</h3>


<p>
`拡張属性@
は、［
`定義$ ／ `~ifc~mb$ ／ `辞書~mb$ ／ `演算$引数
］上に現れ得る <em>注釈</em> （ annotation ）であり，［
言語束縛がこれらの構成子をどう取扱うことになるか
］を制御するために利用される。
拡張属性は `ExtendedAttributeList$g により指定される。
それは、全体が角括弧で括られた，いくつかの `ExtendedAttribute$g からなる~comma区切りの~listである。
◎
An extended attribute is an annotation that can appear on definitions, interface members, dictionary members, and operation arguments, and is used to control how language bindings will handle those constructs. Extended attributes are specified with an ExtendedAttributeList, which is a square bracket enclosed, comma separated list of ExtendedAttributes.
</p>

<p>
文法~記号 `ExtendedAttribute$g は，ほぼ任意の~tok並びに合致するが、この文書で定義される`拡張属性$は，より制約された構文のみを受容する。
 `IDL 片$に~~現れるどの拡張属性も、次の表に示す文法~記号のいずれかへの合致により、それが属する（１つ以上の）形が決定される：
◎
The ExtendedAttribute grammar symbol matches nearly any sequence of tokens, however the extended attributes defined in this document only accept a more restricted syntax. Any extended attribute encountered in an IDL fragment is matched against the following six grammar symbols to determine which form (or forms) it is in:
<!--JAVA *five -->
</p>


<table class="vert"><thead>
<tr><th>文法~記号◎Grammar symbol
</th><th>形◎Form
</th><th>例◎Example
</th></tr></thead><tbody>

<tr><td>`ExtendedAttributeNoArgs$g
</td><td title="takes no arguments">`引数をとらない@
</td><td>`[Replaceable]^c</td></tr>

<tr><td>`ExtendedAttributeArgList$g
</td><td title="takes an argument list">`引数~listを引数にとる@
</td><td>`[Constructor(double x, double y)]^c</td></tr>

<tr><td>`ExtendedAttributeNamedArgList$g
</td><td title="takes a named argument list">`有名~引数~listを引数にとる@
</td><td>`[NamedConstructor=Image(DOMString src)]^c</td></tr>

<tr><td>`ExtendedAttributeIdent$g
</td><td title="takes an identifier">`識別子を引数にとる@
</td><td>`[PutForwards=name]^c</td></tr>

<tr><td>`ExtendedAttributeIdentList$g
</td><td title="takes an identifier list">`識別子~listを引数にとる@
</td><td>`[Exposed=(Window,Worker)]^c</td></tr>

<!--JAVA
<tr>...</tr>
-->
</tbody></table>

<p>
この仕様は、 ECMAScript 言語束縛に適用し得る，種々の拡張属性を定義する。
それらについては
`es-extended-attributes$sec
にて述べる。
各~拡張属性~定義において、上に挙げたどの形が許容されるかについて言明される。
<!--JAVA
Although ExtendedAttributeIdent ...
-->
◎
This specification defines a number of extended attributes that are applicable to the ECMAScript language binding, which are described in section 4.3. Each extended attribute definition will state which of the above six forms are allowed.
</p>

<div class="grammar">
-ExtendedAttributeList
-ExtendedAttributes
-ExtendedAttribute
-ExtendedAttributeRest
-ExtendedAttributeInner
-Other
-OtherOrComma
-IdentifierList
-Identifiers
-ExtendedAttributeNoArgs
-ExtendedAttributeArgList
-ExtendedAttributeIdent
-ExtendedAttributeIdentList
-ExtendedAttributeNamedArgList
</div>

		</section>
	</section>
	<section id="ecmascript-binding">
<h2 title="ECMAScript binding">4. ECMAScript 言語束縛</h2>


<p>
この節では、
`idl$sec
にて定義された IDL で記される`定義$<!-- ~ def -->と
<cite>ECMAScript 言語~仕様 第 6 版</cite>
`ECMA-262$r
により定義される ECMAScript の中の個々の構成子との対応を述べる。
◎
This section describes how definitions written with the IDL defined in section 3 correspond to particular constructs in ECMAScript, as defined by the ECMAScript Language Specification 6th Edition [ECMA-262].
</p>

<p>
他から指定されない限り，この節で定義される各~objは：
</p>

<ul>
	<li>
<p >
ECMA-262 の
<a href="~ES6#sec-ordinary-object-internal-methods-and-internal-slots">9.1 節</a>,
<a href="~ES6#sec-built-in-function-objects-call-thisargument-argumentslist">9.3.1 節</a>
に記述される内的~prop を持つ。
指定がある場合は、次のうち１つ以上のものが，~exotic~objに対する規則に則って再定義される：
`Call^es,
`Set^es,
`DefineOwnProperty^es,
`GetOwnProperty^es,
`Delete^es,
`HasInstance^es
。
◎
Objects defined in this section have internal properties as described in ECMA-262 sections 9.1 and 9.3.1 unless otherwise specified, in which case one or more of the following are redefined in accordance with the rules for exotic objects: [[Call]], [[Set]], [[DefineOwnProperty]], [[GetOwnProperty]], [[Delete]] and [[HasInstance]].
</p>

<p>
他の仕様は、`~ifc$の~instanceである`~platform~obj$の内的~methの定義を上書きして~MAY。
◎
Other specifications MAY override the definitions of any internal method of a platform object that is an instance of an interface.
Warning
</p>

<div class="warning">
<p>
内的 ECMAScript ~obj~methを上書きすることは、低レベルの演算であり，~objの挙動を普通の~objから違えさせ得るので、この便宜性は，セキュリティ／互換性のために必要とされない限り，利用される~SHOULD_NOT。
これは、
<a href="https://github.com/annevk/html-cross-origin-objects/">`Location^T ~obj と, 場合によっては `WindowProxy^T ~obj</a>
に利用されることが予期されている。
◎
As overriding internal ECMAScript object methods is a low level operation and can result in objects that behave differently from ordinary objects, this facility SHOULD NOT be used unless necessary for security or compatibility. The expectation is that this will be used for Location objects and possibly WindowProxy objects.
</p>
</div>

	</li>

	<li>
その `Extensible^es 内的~propの値は `true^v である。
◎
Unless otherwise specified, the [[Extensible]] internal property of objects defined in this section has the value true.
</li>

	<li>
その `Prototype^es 内的~propは
`Object^v 原型~objである。
◎
Unless otherwise specified, the [[Prototype]] internal property of objects defined in this section is the Object prototype object.
</li>

</ul>

<p class="v2">
この節にて述べる一部の~objは、
`~class文字列@
を持つものと定義される。
それは、 `Object.prototype.toString^c が返す文字列に内包される。
~class文字列を持つ~objは、その作成-時に，その指定された文字列を値にとる，名前 `toStringTag_symbol^ ~symbolの~propを持た~MUST。
◎
Some objects described in this section are defined to have a class string, which is the string to include in the string returned from Object.prototype.toString. If an object has a class string, then the object MUST, at the time it is created, have a property whose name is the @@toStringTag symbol and whose value is the specified string.
</p>

<div class="ednote v2"><p>
`toStringTag_symbol^ が
{ writable, enumerable, configurable }
かどうかを定義するべきである。
ES6 仕様における すべての `toStringTag_symbol^ ~propは、非 writable かつ非 enumerable であり，非 configurable である。
◎
Should define whether @@toStringTag is writable, enumerable and configurable. All @@toStringTag properties in the ES6 spec are non-writable and non-enumerable, and configurable.
</p>
</div>


<p>
`関数~obj@
であるものと定義される~objは、次のように特徴付けられる：
◎
If an object is defined to be a function object, then it has characteristics as follows:
</p>
<ul>
	<li>
他から指定されない限り，その `Prototype^es 内的~propは
`FunctionPrototype^
（ `ECMA-262$r 6.1.7.4 節）である。
◎
Its [[Prototype]] internal property is %FunctionPrototype% ([ECMA-262], section 6.1.7.4) unless otherwise specified.
</li>

	<li>
その `Get^es 内的~prop は
<a href="~ES6#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver">ECMA-262 9.1.8 節</a>
の記述に従って設定される。
◎
Its [[Get]] internal property is set as described in ECMA-262 section 9.1.8.
</li>
	<li>
その `Construct^es 内的~prop は
<a href="~ES6#sec-function-@@create">ECMA-262 19.2.2.3 節</a>
の記述に従って設定される。
◎
Its [[Construct]] internal property is set as described in ECMA-262 section 19.2.2.3.
</li>
	<li>
他から指定されない限り，その
<span class="prop">@@hasInstance</span>
内的~prop は
<a href="~ES6#sec-function.prototype-@@hasinstance">ECMA-262 19.2.3.8 節</a>
の記述に従って設定される。
◎
Its @@hasInstance property is set as described in ECMA-262 section 19.2.3.8, unless otherwise specified.
</li>

</ul>

<div class="ednote v2"><p>
上の~listは、最新の ES6 草案に沿うように更新する必要がある。
◎
The list above needs updating for the latest ES6 draft.
</p></div>

<p id="ecmascript-abstractop">
この節の中の~algoは、手続きとその下位~手続き, 数学的演算, 等々の利用に関し，
<a href="~ES6#sec-algorithm-conventions">ECMA-262 Algorithm Conventions 節</a>
に記述されている表記規約を利用する。
この節で参照される抽象演算：
`ToBoolean$A,
`ToNumber$A,
`ToUint16$A,
`ToInt32$A,
`ToUint32$A,
`ToString$A,
`ToObject$A,
`IsAccessorDescriptor$A,
`IsDataDescriptor$A,
並びに
`Type^( %x ) 記法は、 ECMA-262 6, 7 節にて定義される。
◎
Algorithms in this section use the conventions described in ECMA-262 section 5.2, such as the use of steps and substeps, the use of mathematical operations, and so on. The ToBoolean, ToNumber, ToUint16, ToInt32, ToUint32, ToString, ToObject, IsAccessorDescriptor and IsDataDescriptor abstract operations and the Type(x) notation referenced in this section are defined in ECMA-262 sections 6 and 7.
</p>

<p>
~algoにおいて
“<dfn id="ecmascript-throw"><b>THROW</b></dfn> <b><i>Something</i>Error</b>”
と記される所では、 ECMA-262 の~algoとちょうど同じ様に，新たな ECMAScript <b><i>Something</i>Error</b> ~objを構築して投出することを意味する。<!--  -->
◎
When an algorithm says to “throw a SomethingError” then this means to construct a new ECMAScript SomethingError object and to throw it, just as the algorithms in ECMA-262 do.
</p>

<p>
~algoの手続きは，他の~algoや抽象演算の中へ~callし得るが、それらから投出される例外は
<a href="#_try-catch_">明示的に取扱われ</a>ていないことに注意。
~algoまたは抽象演算により例外が投出され，それが~call元により明示的に取扱われない所では、~algoは終了され，その~call元の更に外へ伝播する，等々となる。
◎
Note that algorithm steps can call in to other algorithms and abstract operations and not explicitly handle exceptions that are thrown from them. When an exception is thrown by an algorithm or abstract operation and it is not explicitly handled by the caller, then it is taken to end the algorithm and propagate out to its caller, and so on.
</p>

<div class="example">
<p>
次の~algoを考える：
◎
Consider the following algorithm:
</p>

<ol class="algorithm">
	<li>
%x := この~algoに渡された ECMAScript 値
◎
Let x be the ECMAScript value passed in to this algorithm.
</li>
	<li>
%y := `ToString$A( %x )
◎
Let y be the result of calling ToString(x).
</li>
	<li>
~RET %y
◎
Return y.
</li>
</ol>

<p>
`ToString$A は例外を投出し得るが（例えば~obj
`({ toString: function() { throw 1 } })^c
が渡されたとき），例外は上の~algoでは取扱われないので、もし投出された場合、この~algoは終了され，その例外は ~call元が在るならばその~call元に伝播する。
◎
Since ToString can throw an exception (for example if passed the object ({ toString: function() { throw 1 } })), and the exception is not handled in the above algorithm, if one is thrown then it causes this algorithm to end and for the exception to propagate out to its caller, if there is one.
</p>
</div>


<div class="trans-note" id="_try-catch_">
<p>【
この訳では、原文における明示的な例外の取扱いの表記に，（いわゆる try 〜 catch 文に似た）次の記法を用いる：
</p>

<div style="white-space:pre; margin-left:2em;">~TRY：
    <var>~block１</var>
~CATCH：
    <var>~block２</var>
</div>

<p>
<var>~block２</var> は、 <var>~block１</var> の中で例外が投出されたとき, そのときに限り，（例外を~call元へ伝播させる代わりに）実行されるものとする。
この例外は、 <var>~block２</var> の中では，
`投出された例外@
と記される。
】</p>

</div>

		<section id="es-environment">
<h3 title="ECMAScript environment">4.1. ECMAScript 環境</h3>

<p>
所与の［
`IDL 片$の集合
］に対する ECMAScript 実装においては、それらの `IDL 片$の中の それぞれの定義に対応する， ECMAScript ~objが存在することになる。
これらの~objは
`初期~obj@
と呼ばれ、次のものからなる：
◎
In an ECMAScript implementation of a given set of IDL fragments, there will exist a number of ECMAScript objects that correspond to definitions in those IDL fragments. These objects are termed the initial objects, and comprise the following:
</p>
<ul>
	<li>
`~ifc~obj$
◎
interface objects
</li>
	<li>
`有名~構築子$
◎
named constructors
</li>
	<li class="v2">
`辞書~構築子$
◎
dictionary constructors
</li>
	<li>
`~ifc原型~obj$
◎
interface prototype objects
</li>
	<li>
`有名~prop~obj$
◎
named properties objects
</li>
	<li class="v2">
`反復子~原型~obj$
◎
iterator prototype objects
</li>
	<li>
`属性~取得子$
◎
attribute getters
</li>
	<li>
`属性~設定子$
◎
attribute setters
</li>
	<li>
<a href="#es-operations">演算</a>
に対応する `Function^t ~obj
◎
the Function objects that correspond to operations
</li>
	<li>
<a href="#es-stringifier">文字列化子</a>
に対応する `Function^t ~obj
<!-- es-stringifier -->
◎
the Function objects that correspond to stringifiers
</li>
	<li class="v2">
<a href="#es-serializer">直列化子</a>
に対応する `Function^t ~obj
◎
the Function objects that correspond to serializers
</li>
	<li class="v2">
<a href="#es-iterator">反復子</a>
に対応する `Function^t ~obj
◎
the Function objects that correspond to iterators
</li>
	<li>
`既定の偽装不可 valueOf 関数$
◎
default unforgeable valueOf functions
</li>
	<li class="v2 L2">
`~map~size取得子$
◎
map size getters
</li>

	<li class="v2">
`DOMException 構築子~obj$
◎
DOMException constructor objects
</li>

	<li class="v2">
`DOMException 原型~obj$
◎
DOMException prototype objects
</li>

	<li class="v2">
`有名~prop~obj$
◎
named properties objects
</li>

</ul>

<p>
各
<a href="~ES6#sec-code-realms">ECMAScript 大域環境</a>
（ `ECMA-262$r 8.2 節）
は、それぞれに一意な［
各種`初期~obj$からなる集合
］を持た~MUST。
この集合は、［
その環境のための大域~objが作成された後, かつ
その環境に結付けられている ECMAScript 実行~文脈に制御が移る前
］に作成され~MUST。
所与の大域環境に属する すべての初期~objに対し、その `Prototype^es は，同じ大域環境に属してい~MUST。
◎
Each ECMAScript global environment ([ECMA-262], section 8.2) MUST have its own unique set of each of the initial objects, created before control enters any ECMAScript execution context associated with the environment, but after the global object for that environment is created. The [[Prototype]]s of all initial objects in a given global environment MUST come from that same global environment.
</p>

<p class="trans-note">【
<!-- 
objet’s global environment ／ global environment associated with an objet
-->
上の “大域環境に属する” という句は、所与の~objが複数の大域環境に <em >属する</em> ことは，決してないことを含意する。
】</p>

<div class="example">
<p>
HTML ~UAにおいては、複数の frame や window が作成されたときに，複数の大域環境が存在し得る。
frame や window のそれぞれは、自身の`初期~obj$の集合を持つことになる。
次の HTML 文書の例の様に：
◎
In an HTML user agent, multiple global environments can exist when multiple frames or windows are created. Each frame or window will have its own set of initial objects, which the following HTML document demonstrates:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;title&gt;Different global environments&lt;/title&gt;
&lt;iframe id=a&gt;&lt;/iframe&gt;
&lt;script&gt;
var iframe = document.getElementById("a");
var w = iframe.contentWindow;     // <span title="The global object in the frame"
>frame 内の大域~obj</span>

Object == w.Object;       // <span title="Evaluates to false, per ECMA-262"
>ECMA-262 に則り， `false^v に評価される</span>
Node == w.Node;                            // <span title="Evaluates to false." id="cp-eval-false"
>`false^v に評価される。</span>
iframe instanceof w.Node;                  // <!--cp-eval-false-->
iframe instanceof w.Object;                // <!--cp-eval-false-->
iframe.appendChild instanceof Function;    // <!--cp-eval-true-->
iframe.appendChild instanceof w.Function;  // <!--cp-eval-false-->
&lt;/script&gt;
</pre>
</div>

<p>
他から指定されない限り、各 ECMAScript 大域環境は，実装が~supportする すべての`~ifc$を
`公開する@
。
所与の ECMAScript 大域環境が公開しない~ifcは，
`es-interfaces$secにて与える要件に従うとは限らない。
◎
Unless otherwise specified, each ECMAScript global environment exposes all interfaces that the implementation supports. If a given ECMAScript global environment does not expose an interface, then the requirements given in section 4.6 are not followed for that interface.
</p>

<div class="note"><p>
これにより，例えば、［
Web Workers のための ECMAScript 大域環境
］が`公開する$［
被support~ifcの集合
］を，［
Web ~pageのための環境
］が公開するものと異なるようにすることも許容される。
◎
This allows, for example, ECMAScript global environments for Web Workers to expose different sets of supported interfaces from those exposed in environments for Web pages.
</p></div>

		</section>
		<section id="es-type-mapping">
<h3 title="ECMAScript type mapping">4.2. ECMAScript 型への対応関係</h3>


<p>
この節では、 IDL における各~型が， ECMAScript における型へ どのように~~対応付けられるかについて述べる。
◎
This section describes how types in the IDL map to types in ECMAScript.
</p>

<p>
以下の各~下位~節では、所与の［
IDL 型の値
］が， ECMAScript の中ではどのように表現されるかを述べる。
各種 IDL 型に対し、その型を期待する`~platform~obj$に ECMAScript 値が渡された際に
<dfn id="dfn-convert-ecmascript-to-idl-value">IDL 値へ変換される</dfn>
方法, および
その型の IDL 値が~platform~objから返される際に
<dfn id="dfn-convert-idl-to-ecmascript-value">ECMAScript 値へ変換される</dfn>
方法が述べられる。
◎
Each sub-section below describes how values of a given IDL type are represented in ECMAScript. For each IDL type, it is described how ECMAScript values are converted to an IDL value when passed to a platform object expecting that type, and how IDL values of that type are converted to ECMAScript values when returned from a platform object.
</p>

			<section id="es-any">
<h4 title="any">4.2.1. `any^T</h4>


<p>
IDL `any$T 型は、他のすべての IDL 型の和集合なので，どの ECMAScript 値~型にも対応し得る。
◎
Since the IDL any type is the union of all other IDL types, it can correspond to any ECMAScript value type.
</p>

<p id="es-to-any">
ECMAScript 値から IDL `any$T 値への`toIDL^は、
ECMAScript 値の型に応じて次の様になる：
◎
How to convert an ECMAScript value to an IDL any value depends on the type of the ECMAScript value:
</p>

<dl class="switch">
	<dt>`undefined^v◎The undefined value</dt>
	<dd>
ECMAScript `undefined^v 値を表現する特別な~objへの `object$T 参照
◎
The IDL value is an object reference to a special object that represents the ECMAScript undefined value.
</dd>

	<dt>`null^v◎The null value</dt>
	<dd>
`null^V `object$T​? 参照<!--  -->
◎
The IDL value is the null object? reference.
</dd>

	<dt>`Boolean^t◎A Boolean value</dt>
	<dd>
同じ真偽~値を表現する `boolean$T 値
◎
The IDL value is the boolean value that represents the same truth value.
</dd>

	<dt>`Number^t◎A Number value</dt>
	<dd>
`es-unrestricted-double$sec
による，［
`Number^t から IDL `unrestricted double$T 値への変換-規則
］に従って得られる値
◎
The IDL value is that which is obtained by following the rules for converting the Number to an IDL unrestricted double value, as described in section 4.2.15, below.
</dd>

	<dt>`String^t◎A String value</dt>
	<dd>
`es-DOMString$sec
による，［
`String^v から `DOMString$T 値への変換-規則
］に従って得られる値
◎
The IDL value is that which is obtained by following the rules for converting the String to an IDL DOMString value, as described in section 4.2.16, below.
</dd>

	<dt>`object^t◎An object value</dt>
	<dd>
同じ~objを参照する `object$T 値
◎
The IDL value is an object value that references the same object.
</dd>

</dl>

<p id="any-to-es">
IDL `any$T 値 %V は，次の様にして ECMAScript 値へ`toES^される：
<span class="block">
%V が［
ECMAScript `undefined^v 値を表現する特別な~objへの `object$T 参照
］ならば、 ECMAScript `undefined^v 値に変換される。
他の場合、この節の残りで述べられる， %V の`固有型$を変換するための規則に従う。
</span>
◎
An IDL any value is converted to an ECMAScript value as follows. If the value is an object reference to a special object that represents an ECMAScript undefined value, then it is converted to the ECMAScript undefined value. Otherwise, the rules for converting the specific type of the IDL any value as described in the remainder of this section are performed.
</p>
			</section>
			<section id="es-void">
<h4 title="void">4.2.2. `void^T</h4>


<p>
`void$T が IDL に現れ得る唯一の場所は、`演算$の`返値型$である。
［
IDL において `void$T 返値型が指定されている演算
］を実装する［
`~platform~obj$上の関数
］は、 `undefined^v 値を返さ~MUST。
<!-- % ` Function -->
◎
The only place that the void type may appear in IDL is as the return type of an operation. Functions on platform objects that implement an operation whose IDL specifies a void return type MUST return the undefined value.
</p>

<p>
［
IDL において `void$T 返値型が指定されている演算
］を実装する ECMAScript 関数は、どのような値を返しても~MAY（破棄されることになる）。
◎
ECMAScript functions that implement an operation whose IDL specifies a void return type MAY return any value, which will be discarded.
</p>
			</section>
			<section id="es-boolean">
<h4 title="boolean">4.2.3. `boolean^T</h4>


<p id="es-to-boolean">
次の~algoにより，
ECMAScript 値 %V は IDL `boolean$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL boolean value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%x := `ToBoolean$A( %V ) の算出-結果
◎
Let x be the result of computing ToBoolean(V).
</li>
	<li>
~RET ［
ECMAScript `Boolean^t 値 %x
］と同じ真偽~値を表現する IDL `boolean$T 値
◎
Return the IDL boolean value that is the one that represents the same truth value as the ECMAScript Boolean value x.
</li>
</ol>

<p id="boolean-to-es">
IDL `boolean$T 値［
`true^V／`false^V
］は， ECMAScript［
`true^v／`false^v
］値に`toES^される。
◎
The IDL boolean value true is converted to the ECMAScript true value and the IDL boolean value false is converted to the ECMAScript false value.
</p>


			</section>
			<section id="es-integers">
<h4>4.2.4 〜 11. 整数~型</h4>

<div class="trans-note">

<p>【
この訳では、原文の次に挙げる各~節の内容
— ECMAScript 値 から各種 IDL 整数~型 値への変換, およびその逆の変換の定義 —
の重複する記述を集約して，一括して与える。
】</p>

<ul>
	<li id="es-byte">4.2.4. `byte^T</li>
	<li id="es-octet">4.2.5. `octet^T</li>
	<li id="es-short">4.2.6. `short^T</li>
	<li id="es-unsigned-short">4.2.7. `unsigned short^T</li>
	<li id="es-long">4.2.8. `long^T</li>
	<li id="es-unsigned-long">4.2.9. `unsigned long^T</li>
	<li id="es-long-long">4.2.10. `long long^T</li>
	<li id="es-unsigned-long-long">4.2.11. `unsigned long long^T</li>
</ul>

</div>


<p>
この節を通して，記号 %T は、任意に与えられた~~特定の IDL `整数~型$を表すものとする。
</p>

<p>
この節の記号
%MIN, %MAX, %N, %signed
は、 %T に応じて，次の表で与えられる値を表すものとする：
</p>

<table class="matrix" id="matrix-integers">

<thead><tr><th>%T
</th><th>%MIN
</th><th>%MAX
</th><th>%N
</th><th>%signed
</th></tr></thead>

<tbody><tr><th>`byte$T
</th><td>−2`7^sup
</td><td>2`7^sup − 1
</td><td>8
</td><td>~T

</td></tr><tr><th>`octet$T
</th><td>0
</td><td>2`8^sup − 1
</td><td>8
</td><td>~F

</td></tr><tr><th>`short$T
</th><td>−2`15^sup
</td><td>2`15^sup − 1
</td><td>16
</td><td>~T

</td></tr><tr><th>`unsigned short$T
</th><td>0
</td><td>2`16^sup − 1
</td><td>16
</td><td>~F

</td></tr><tr><th>`long$T
</th><td>−2`31^sup
</td><td>2`31^sup − 1
</td><td>32
</td><td>~T

</td></tr><tr><th>`unsigned long$T
</th><td>0
</td><td>2`32^sup − 1
</td><td>32
</td><td>~F

</td></tr><tr><th>`long long$T
</th><td>−2`53^sup + 1
</td><td>2`53^sup − 1
</td><td>64
</td><td>~T

</td></tr><tr><th>`unsigned long long$T
</th><td>0
</td><td>2`53^sup − 1
</td><td>64
</td><td>~F

</td></tr></tbody></table>

<p class="trans-note">【
`long long^T, `unsigned long long^T の
%MIN, %MAX が， 2 の 53 乗で~~制限されていることに注意。
】</p>


<p>
<a id="es-to-byte"></a
><a id="es-to-octet"></a
><a id="es-to-short"></a
><a id="es-to-unsigned-short"></a
><a id="es-to-long"></a
><a id="es-to-unsigned-long"></a
><a id="es-to-long-long"></a
><a id="es-to-unsigned-long-long"></a>
次の~algoにより， ECMAScript 値 %V は IDL `整数~型$ %T の値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL _T_ value by running the following algorithm:
</p>

<ol class="algorithm">

	<li>
%x :← `ToNumber$A( %V )
◎
Initialize x to ToNumber(V).
</li>
	<li>
<p>
~IF
IDL 値への変換は，
`EnforceRange$x 注釈付きの［
`属性$に代入される／
`演算$の引数に渡される／
`辞書~mb$の値に利用される
］ことにより遂行されている
⇒
◎
If the conversion to an IDL value is being performed due to any of the following:
• V is being assigned to an attribute annotated with the [EnforceRange] extended attribute,
• V is being passed as an operation argument annotated with the [EnforceRange] extended attribute, or
• V is being used as the value of a dictionary member annotated with the [EnforceRange] extended attribute,
then:
</p>
		<ol>
			<li>
~IF
%x ~IN { `NaN^v, +∞, −∞ }
~THEN
~THROW `TypeError^t
◎
If x is NaN, +∞, or −∞, then throw a TypeError.
</li>
			<li id="cp-floor_x">
%x ← <a href="~ES6#sec-algorithm-conventions">sign</a>(%x) × <a href="~ES6#sec-algorithm-conventions">floor</a>(<a href="~ES6#sec-algorithm-conventions">abs</a>(%x))
◎
Set x to sign(x) * floor(abs(x)).
</li>
			<li>
~IF［
%x &lt; %MIN
］~OR［
%x &gt; %MAX
］
~THEN
~THROW `TypeError^t
◎
If x &lt; −_MIN_ or x &gt; _MAX_, then throw a TypeError.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%x ≠ `NaN^v
］~AND［
IDL 値への変換は，
`Clamp$x 注釈付きの［
`属性$に代入される／
`演算$の引数に渡される／
`辞書~mb$の値に利用される
］ことにより遂行されている
］
⇒
◎
If x is not NaN and the conversion to an IDL value is being performed due to any of the following:
• V is being assigned to an attribute annotated with the [Clamp] extended attribute,
• V is being passed as an operation argument annotated with the [Clamp] extended attribute, or
• V is being used as the value of a dictionary member annotated with the [Clamp] extended attribute,
then:
</p>

		<ol>
			<li>
%x ← min(max(%x, %MIN), %MAX)
◎
Set x to min(max(x, _MIN_), _MAX_).
</li>
			<li>
%x ← %x を最も近い整数に丸めた結果（２つの整数と等距離にある場合は偶数を選び，−0 より +0 の方を選ぶ）
◎
Round x to the nearest integer, choosing the even integer if it lies halfway between two, and choosing +0 rather than −0.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE ⇒
</p>
		<ol>
			<li>
~IF
%x ~IN { `NaN^v, +0, −0, +∞, −∞ }
~THEN
~RET 0 を表現する 型 %T の IDL 値
◎
If x is NaN, +0, −0, +∞, or −∞, then return the IDL _T_ value that represents 0.
</li>
			<!--cp-floor_x-->
			<li>
%x ← %x
<a href="~ES6#sec-algorithm-conventions">modulo</a>
2<sup>%N</sup>
◎
Set x to x modulo 2_N_.
</li>
			<li>
~IF［
%signed ＝ ~T
］~AND［
%x  ≥ 2<sup>%N − 1</sup>
］
~THEN
%x ← %x − 2<sup>%N</sup>
◎
If x is greater than or equal to 2_N_-1, then set x to x − 2_N_.
</li>

		</ol>

<p class="trans-note">【
%T が
`unsigned short$T ／ `long$T ／ `unsigned long$T
ならば，この下位手続きの~~処理はそれぞれ
`ToUint16$A ／ `ToInt32$A ／ `ToUint32$A
に一致する。
】</p>

	</li>

	<li>
~RET %x と同じ実数~値を表現する，型 %T の IDL 値
◎
Return the IDL _T_ value that represents the same numeric value as x.
</li>

</ol>


<p>
<a id="byte-to-es"></a
><a id="octet-to-es"></a
><a id="short-to-es"></a
><a id="unsigned-short-to-es"></a
><a id="long-to-es"></a
><a id="unsigned-long-to-es"></a
><a id="long-long-to-es"></a
><a id="unsigned-long-long-to-es"></a>
IDL `整数~型$ %T の値 %V を ECMAScript 値に`toES^した結果は， %T に応じて次で与えられる：
◎
The result of converting an IDL _T_ value to an ECMAScript value is a ...
</p>

<dl class="switch">
	<dt>`long long$T</dt>
	<dt>`unsigned long long$T</dt>
	<dd id="_int-toES_">
%V に`最近数値^を表現する `Number^t 値。
%V が範囲 [%MIN, %MAX] に入るならば、その値 は %V と正確に同じ値を表現できることになる。
◎
Number value that represents the closest numeric value to _T_, choosing the numeric value with an even significand if there are two equally close values ([ECMA-262], section 6.1.6). If _T_ is in the range [_MIN_, _MAX_], then the Number will be able to represent exactly the same value as _T_.
</dd>

	<dt>他の整数~型</dt>
	<dd>
%V と同じ実数~値を表現する `Number^t 値。
その値は 範囲 [%MIN, %MAX] の整数になる。
◎
Number that represents the same numeric value as the IDL _T_ value. The Number value will be an integer in the range [_MIN_, _MAX_].
</dd>

</dl>

			</section>
			<section id="es-float">
<h4 title="float">4.2.12. `float^T</h4>


<p id="es-to-float">
次の~algoにより，
ECMAScript 値 %V は IDL `float$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL float value by running the following algorithm:
</p>

<ol class="algorithm">
	<li id="cp-ToNumber">
%x := `ToNumber$A( %V )
◎
Let x be ToNumber(V).
</li>
	<li>
~IF
%x ~IN { `NaN^v, `+Infinity^v, `−Infinity^v }
~THEN
~THROW `TypeError^t
◎
If x is NaN, +Infinity or −Infinity, then throw a TypeError.
</li>
	<li id="cp-let-S-to754">
%S := ［
−0 を除く有限 IEEE 754 単精度 浮動小数点~値の集合に，２つの特別な値{ 2`128^sup, −2`128^sup }
を追加した集合
］
◎
Let S be the set of finite IEEE 754 single-precision floating point values except −0, but with two special values added: 2^128 and −2^128.
</li>
	<li id="cp-round-x-to-y">
%y := ［ %S の中で %x に`最近数値^ ］
（この目的においては，２つの特別な値 2`128^sup, −2`128^sup の仮数は偶数と見なされる。）
◎
Let y be the number in S that is closest to x, selecting the number with an even significand if there are two equally close values ([ECMA-262], section 8.5). (The two special values 2^128 and −2^128 are considered to have even significands for this purpose.)
</li>
	<li>
~IF
%y ~IN { 2`128^sup, −2`128^sup }
~THEN
~THROW `TypeError^t
◎
If y is 2^128 or −2^128, then throw a TypeError.
</li>
	<li id="cp-if-y-0-x-lt0">
~IF［
%y ＝ +0
］~AND［
%x &lt; 0
］
~THEN
~RET −0
◎
If y is +0 and x is negative, return −0.
</li>
	<li id="cp-ret-y">
~RET %y
◎
Return y.
</li>
</ol>

<p id="float-to-es">
IDL `float$T 値を ECMAScript 値に`toES^した結果は、その
IDL 値と同じ実数~値を表現する `Number^t 値になる。
◎
The result of converting an IDL float value to an ECMAScript value is the Number value that represents the same numeric value as the IDL float value.
</p>
			</section>
			<section id="es-unrestricted-float">
<h4 title="unrestricted float">4.2.13. `unrestricted float^T</h4>


<p id="es-to-unrestricted-float">
次の~algoにより，
ECMAScript 値 %V は IDL `unrestricted float$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL unrestricted float value by running the following algorithm:
</p>

<ol class="algorithm">
	<!--cp-ToNumber-->
	<li>
~IF
%x ＝ `NaN^v
~THEN
~RET ~bit~pattern 0x7fc00000 の IEEE 754 NaN 値 `IEEE-754$r を表現する IDL `unrestricted float$T 値
◎
If x is NaN, then return the IDL unrestricted float value that represents the IEEE 754 NaN value with the bit pattern 0x7fc00000 [IEEE-754].
</li>
	<!--cp-let-S-to754-->
	<!--cp-round-x-to-y-->
	<li>
~IF
%y ＝ 2`128^sup
~THEN
~RET +∞
◎
If y is 2^128, return +∞.
</li>
	<li>
~IF
%y ＝ −2`128^sup 
~THEN
~RET −∞
◎
If y is −2^128, return −∞.
</li>
	<!--cp-if-y-0-x-lt0-->
	<!--cp-ret-y-->
</ol>

<div class="note"><p>
ECMAScript `NaN^v 値は唯１個しかないので，特定0の単精度 IEEE 754 NaN 値に正準化されなければならない。
上に示された NaN 値は、単純に，その~bit~patternが無符号 32 ~bit整数に解釈されたときに最低~値の quiet NaN になることから，選ばれている。
◎
Since there is only a single ECMAScript NaN value, it must be canonicalized to a particular single precision IEEE 754 NaN value. The NaN value mentioned above is chosen simply because it is the quiet NaN with the lowest value when its bit pattern is interpreted as an unsigned 32 bit integer.
</p></div>

<p id="unrestricted-float-to-es">
IDL `unrestricted float$T 値を ECMAScript 値に`toES^した結果は、次の `Number^t になる：
◎
The result of converting an IDL unrestricted float value to an ECMAScript value is a Number:
</p>

<ul><!-- ❖ ol -->
	<li>
その IDL 値 ＝ NaN ならば `NaN^v
◎
If the IDL unrestricted float value is a NaN, then the Number value is NaN.
</li>
	<li>
他の場合，その IDL 値と同じ実数~値を表現する（~~唯一の） `Number^t 値。
◎
Otherwise, the Number value is the one that represents the same numeric value as the IDL unrestricted float value.
</li>
</ul>
			</section>
			<section id="es-double">
<h4 title="double">4.2.14. `double^T</h4>


<p id="es-to-double">
次の~algoにより，
ECMAScript 値 %V は IDL `double$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL double value by running the following algorithm:
</p>

<ol class="algorithm">
	<!--cp-ToNumber-->
	<li>
~IF
%x ~IN { `NaN^v, `+Infinity^v, `−Infinity^v }
~THEN
~THROW `TypeError^t
◎
If x is NaN, +Infinity or −Infinity, then throw a TypeError.
</li>
	<li>
~RET %x と同じ実数~値を持つ IDL `double$T 値
◎
Return the IDL double value that has the same numeric value as x.
</li>
</ol>

<p id="double-to-es">
IDL `double$T 値を ECMAScript 値に`toES^した結果は、その
IDL 値と同じ実数~値を表現する `Number^t 値になる。
◎
The result of converting an IDL double value to an ECMAScript value is the Number value that represents the same numeric value as the IDL double value.
</p>
			</section>
			<section id="es-unrestricted-double">
<h4 title="unrestricted double">4.2.15. `unrestricted double^T</h4>


<p id="es-to-unrestricted-double">
次の~algoにより，
ECMAScript 値 %V は IDL `unrestricted double$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL unrestricted double value by running the following algorithm:
</p>

<ol class="algorithm">
	<!--cp-ToNumber-->
	<li>
~IF
%x ＝ `NaN^v
~THEN
~RET ~bit~pattern 0x7ff8000000000000 の IEEE 754 NaN 値 `IEEE-754$r を表現する IDL `unrestricted double$T 値
◎
If x is NaN, then return the IDL unrestricted double value that represents the IEEE 754 NaN value with the bit pattern 0x7ff8000000000000 [IEEE-754].
</li>
	<li>
~RET %x と同じ実数~値を持つ IDL `unrestricted double$T 値
◎
Return the IDL unrestricted double value that has the same numeric value as x.
</li>
</ol>

<div class="note"><p>
ECMAScript `NaN^v 値は唯１個しかないので，特定0の倍精度 IEEE 754 NaN 値に正準化されなければならない。
上に示された NaN 値は、単純に，その~bit~patternが無符号 64 ~bit整数に解釈されたときに最低~値の quiet NaN になることから，選ばれている。
◎
Since there is only a single ECMAScript NaN value, it must be canonicalized to a particular double precision IEEE 754 NaN value. The NaN value mentioned above is chosen simply because it is the quiet NaN with the lowest value when its bit pattern is interpreted as an unsigned 64 bit integer.
</p></div>

<p id="unrestricted-double-to-es">
IDL `unrestricted double$T 値を ECMAScript 値に`toES^した結果は、次の `Number^t になる：
◎
The result of converting an IDL unrestricted double value to an ECMAScript value is a Number:
</p>

<ul>
	<li>
その IDL 値 ＝ NaN ならば `NaN^v 。
◎
If the IDL unrestricted double value is a NaN, then the Number value is NaN.
</li>
	<li>
他の場合，その IDL 値と同じ実数~値を表現する（~~唯一の） `Number^t 値。
◎
Otherwise, the Number value is the one that represents the same numeric value as the IDL unrestricted double value.
</li>
</ul>
			</section>
			<section id="es-DOMString">
<h4 title="DOMString">4.2.16. `DOMString^T</h4>


<p id="es-to-DOMString">
次の~algoにより，
ECMAScript 値 %V は IDL `DOMString$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL DOMString value by running the following algorithm:
</p>


<ol class="algorithm">
	<li><!-- copy* -->
~IF［
%V ＝ `null^v
］~AND［
IDL 値への変換は，
<a class="xattr" href="#TreatNullAs">[TreatNullAs=EmptyString]</a>
注釈付きの［
`演算$の引数に渡される ／
`属性$に代入される ／
演算の`利用者~obj$実装から返される ／
属性の`利用者~obj$実装から返される
］ことにより遂行されている
］
~THEN
~RET 空~文字列を表現する `DOMString$T 値
◎
If V is null and the conversion to an IDL value is being performed due to any of the following:
• V is being passed as an operation argument that is annotated with [TreatNullAs=EmptyString],
• V is being assigned to an attribute annotated with [TreatNullAs=EmptyString],
• V is being returned from a user object implementation of an operation annotated with [TreatNullAs=EmptyString], or
• V is being returned from a user object implementation of an attribute annotated with [TreatNullAs=EmptyString],
◎
then return the DOMString value that represents the empty string.
</li>

	<li>
%x := `ToString$A( %V )
◎
Let x be ToString(V).
</li>
	<li>
~RET ［
その ECMAScript `String^t 値 %x が表現するものと同じ，符号単位の並び
］を表現する IDL `DOMString$T 値
◎
Return the IDL DOMString value that represents the same sequence of code units as the one the ECMAScript String value x represents.
</li>
</ol>

<p id="DOMString-to-es">
IDL `DOMString$T 値を ECMAScript 値に`toES^した結果は、
その IDL `DOMString$T が表現するものと同じ,
`符号単位$の並びを表現する `String^t 値になる。
◎
The result of converting an IDL DOMString value to an ECMAScript value is the String value that represents the same sequence of code units that the IDL DOMString represents.
</p>
			</section>
			<section id="es-ByteString" class="v2">
<h4 title="ByteString">4.2.17. `ByteString^T</h4>

<p id="es-to-ByteString">
次の~algoにより，
ECMAScript 値 %V は IDL `ByteString$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL ByteString value by running the following algorithm:
</p>

<ol>
	<li>
%x := `ToString$A( %V )
◎
Let x be ToString(V).
</li>

	<li>
~IF
%x の中に 値 &gt; 255 なる
<a href="~ES6#sec-ecmascript-language-types-string-type">要素</a>
がある
~THEN
~THROW `TypeError^t
◎
If the value of any element of x is greater than 255, then throw a TypeError.
</li>

	<li>
~RET ［［
各~要素の値 ← %x の対応する要素の値
］にされた，
長さ ＝ %x の長さ
］の IDL `ByteString$T 値
◎
Return an IDL ByteString value whose length is the length of x, and where the value of each element is the value of the corresponding element of x.
</li>

</ol>

<p id="ByteString-to-es">
IDL `ByteString$T 値 %V を ECMAScript 値に`toES^した結果は、［［
各~要素の値 ← %V の対応する要素の値
］にされた,
長さ ＝ %V の長さ
］の `String^t 値になる。
◎
The result of converting an IDL ByteString value to an ECMAScript value is a String value whose length is the length of the ByteString, and the value of each element of which is the value of the corresponding element of the ByteString.
</p>

			</section>
			<section id="es-USVString" class="v2">
<h4 title="USVString">4.2.18. `USVString^T</h4>

<p id="es-to-USVString">
次の~algoにより，
ECMAScript 値 %V は IDL `USVString$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL USVString value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%string :=  %V を `DOMString$T に`toIDL^した結果
◎
Let string be the result of converting V to a DOMString.
</li>
	<li>
~RET
%string を `Unicode ~scalar値~列に変換-$した結果の IDL `USVString$T 値
◎
Return an IDL USVString value that is the result of converting string to a sequence of Unicode scalar values.
</li>
</ol>

<p id="USVString-to-es">
次の~algoにより，
IDL `USVString$T 値 %V は ECMAScript 値に`toES^される：
◎
An IDL USVString value is converted to an ECMAScript value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%scalarValues := `USVString$T が表現する
`Unicode ~scalar値$の並び
◎
Let scalarValues be the sequence of Unicode scalar values the USVString represents.
</li>
	<li>
%string := %scalarValues を UTF-16 に符号化した結果の`符号単位$の並び
◎
Let string be the sequence of code units that results from encoding scalarValues in UTF-16.
</li>
	<li>
~RET
%string と同じ`符号単位$の並びを表現する `String^t 値
◎
Return the String value that represents the same sequence of code units as string.
</li>
</ol>


			</section>
			<section id="es-object">
<h4 title="object">4.2.19. `object^T</h4>


<p>
IDL `object$T 値は
ECMAScript `Object^t 値により表現される。
◎
IDL object values are represented by ECMAScript Object values.
</p>

<p id="es-to-object">
次の~algoにより，
ECMAScript 値 %V は IDL `object$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL object value by running the following algorithm:
</p>

<ol class="algorithm">
	<li id="cp-type-not-object">
~IF
`Type^( %V ) ≠ Object
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Object, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objを参照する IDL `object$T 値
◎
Return the IDL object value that is a reference to the same object as V.
</li>
</ol>

<p id="object-to-es">
IDL `object$T 値 %V を ECMAScript 値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^t 値になる。
◎
The result of converting an IDL object value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL object represents.
</p>
			</section>
			<section id="es-interface">
<h4 title="Interface types">4.2.20. ~ifc型</h4>


<p>
IDL `~ifc型$の値は
ECMAScript ［
`Object^t, または `Function^t
］値により表現される。
◎
IDL interface type values are represented by ECMAScript Object or Function values.
</p>

<p id="es-to-interface">
次の~algoにより，
ECMAScript 値 %V は IDL `~ifc型$の値に`toIDL^される（以下では %I をその`~ifc$とする）：
◎
An ECMAScript value V is converted to an IDL interface type value by running the following algorithm (where I is the interface):
</p>

<ol class="algorithm">
	<!--cp-type-not-object-->
	<li>
~IF
%V は %I を実装する`~platform~obj$である
~THEN
~RET その~platform~objへの参照を表現する， IDL `~ifc型$の値
◎
If V is a platform object that implements I, then return the IDL interface type value that represents a reference to that platform object.
</li>
	<li>
~IF
%V は［
`es-user-objects$sec の規則に従って %I を実装する
］ものと見なされる`利用者~obj$である
~THEN
~RET その利用者~objへの参照を表現し,
`呼戻~文脈$として`incumbent-script^ `HTML$r を伴う，
IDL `~ifc型$の値
◎
If V is a user object that is considered to implement I according to the rules in section 4.9, then return the IDL interface type value that represents a reference to that user object, with the incumbent script as the callback context. [HTML]
</li>
	<li id="cp-throw-typeerror">
~THROW `TypeError^t
◎
Throw a TypeError.
</li><!-- % * -->
</ol>

<p id="interface-to-es">
IDL `~ifc型$の値 %V を ECMAScript 値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^t 値になる。
◎
The result of converting an IDL interface type value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL interface type value represents.
</p>
			</section>
			<section id="es-dictionary">
<h4 title="Dictionary types">4.2.21. 辞書~型</h4>


<p>
IDL `辞書~型$の値は
ECMAScript `Object^t 値により表現される。
その~obj（またはその原型鎖）上の~propが`辞書~mb$に対応する。
◎
IDL dictionary type values are represented by ECMAScript Object values. Properties on the object (or its prototype chain) correspond to dictionary members.
</p>

<p id="es-to-dictionary">
次の~algoにより，
ECMAScript 値 %V は IDL `辞書$ %D の型の値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL dictionary type value by running the following algorithm (where D is the dictionary):
</p>

<ol class="algorithm">
	<li><!--  title="cp-type-not-object" -->
~IF
`Type^( %V ) は Undefined, Null, Object のいずれでもない
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Undefined, Null or Object, then throw a TypeError.
	</li>
	<li>
~IF
%V は ~native `RegExp^t ~objである
~THEN
~THROW `TypeError^t
◎
If V is a native RegExp object, then throw a TypeError.
	</li>
	<li>
%dict := 型 %D の空の辞書~値（初期~時にはどの`辞書~mb$も`不在$と見なされる）
◎
Let dict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
</li>
	<li id="cp-let-inherited-dictionaries">
%dictionaries := %D および %D のすべての`被継承~辞書$を，先祖から先に，継承-順に並べた~list
◎
Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
</li>
	<li>
<p id="cp-for-each-dictionary">
~FOR
%dictionaries 内の~EACH ( 辞書 %dictionary ) に対し，順に： 
◎
For each dictionary dictionary in dictionaries, in order:
</p>
		<ol>
			<li>
<p id="cp-foreach-mb">
~FOR
%dictionary 上に宣言されている~EACH ( 辞書~mb %member ) に対し，辞書式~順序で：
◎
For each dictionary member member declared on dictionary, in lexicographical order:
</p>

				<ol>
					<li id="cp-let-key">
%key := %member の`識別子$
◎
Let key be the identifier of member.
</li>

					<li>
<p>
%value :=
`Type^( %V ) に応じて，次で与えられる ECMAScript 値：
◎
Let value be an ECMAScript value, depending on Type(V):
</p>

						<dl class="switch">
							<dt>Undefined</dt>
							<dt>Null</dt>
							<dd>
`undefined^v
◎
value is undefined.
</dd>

							<dt>その他◎anything else</dt>
							<dd>
~prop名 %key により， %V 上の `Get^es 内的~methを~callした結果
◎
value is the result of calling the [[Get]] internal method on V with property name key.
</dd>
						</dl>
					</li>
					<li>
~IF
%value ≠ `undefined^v
~THEN
%idlValue := %value を %member に宣言されている型の IDL 値に`toIDL^した結果
◎
If value is not undefined, then:
• Let idlValue be the result of converting value to an IDL value whose type is the type member is declared to be of.
• Set the dictionary member on dict with key name key to the value idlValue. This dictionary member is considered to be present.
</li>
					<li>
~ELIF
%member は `辞書既定値^ %d を持つ
~THEN
%idlValue := %d
◎
Otherwise, if value is undefined but the dictionary member has a default value, then:
• Let idlValue be the dictionary member’s default value.
• Set the dictionary member on dict with key name key to the value idlValue. This dictionary member is considered to be present.
</li>
					<li>
~ELIF
%member は `必須~辞書~mb$である
~THEN
~THROW `TypeError^t
◎
Otherwise, if value is undefined and the dictionary member is a required dictionary member, then throw a TypeError.
</li>
					<li>
~ELSE
~THEN
~CONTINUE
◎
↑</li>
					<li>
%dict 上の ~key名 %key の辞書~mbの値 ← %idlValue
（この辞書~mbは`在する$ものと見なされるようになる）
◎
↑</li>

				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %dict
◎
Return dict.
</li>
</ol>

<div class="note"><p>
`辞書~mb$が ECMAScript ~obj上で~lookupされる順序は、~objの~prop列挙~順序と同じになるとは限らない。
◎
The order that dictionary members are looked up on the ECMAScript object are not necessarily the same as the object’s property enumeration order.
</p></div>

<p id="dictionary-to-es">
次の~algoにより，
IDL 辞書 %D 型の値 %V は ECMAScript `Object^t 値に`toES^される：
◎
An IDL dictionary value V is converted to an ECMAScript Object value by running the following algorithm (where D is the dictionary):
</p>

<ol class="algorithm">
	<li>
%O := 式 `({})^c で作成されるものと同じ，新たな `Object^t 値
◎
Let O be a new Object value created as if by the expression ({}).
</li>
	<!--cp-let-inherited-dictionaries-->
	<li>
<!--cp-for-each-dictionary-->
		<ol>
			<li>
<!--cp-foreach-mb-->
				<ol>
					<!--cp-let-key-->
					<li>
<p>
~IF
名前 %key の辞書~mbが %V 内に`在する$
⇒
◎
If the dictionary member named key is present in V, then:
</p>
						<ol>
							<li>
%idlValue := %V 上の %member の値
◎
Let idlValue be the value of member on V.
</li>
							<li>
%value := %idlValue を ECMAScript 値に`toES^した結果
◎
Let value be the result of converting idlValue to an ECMAScript value.
</li>
							<li>
( ~prop名 %key, ~pdesc `TTT-value^desc, 真偽~flag `false^v )
を引数に，
%O 上の `DefineOwnProperty^es 内的~methを~callする
◎
Call the [[DefineOwnProperty]] internal method on O with property name key, Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %O
◎
Return O.
</li>
</ol>
			</section>
			<section id="es-enumeration">
<h4 title="Enumeration types">4.2.22. 列挙~型</h4>


<p>
IDL `列挙~型$の値は
ECMAScript `String^t 値により表現される。
◎
IDL enumeration types are represented by ECMAScript String values.
</p>

<p id="es-to-enumeration">
次の~algoにより，
ECMAScript 値 %V は
IDL `列挙$ %E の型の値に`toIDL^される：
<!-- <a class="dfnref" href="#dfn-enumeration">enumeration type</a> -->
◎
An ECMAScript value V is converted to an IDL enumeration type value as follows (where E is the enumeration):
</p>

<ol class="algorithm">
	<li>
%S := `ToString$A( %V )
◎
Let S be the result of calling ToString(V).
</li>
	<li>
~IF
%S は %E の`列挙~値$のいずれでもない
~THEN
~THROW `TypeError^t
◎
If S is not one of E’s enumeration values, then throw a TypeError.
</li>
	<li>
~RET 型 %E の， %S に等しい列挙~値
◎
Return the enumeration value of type E that is equal to S.
</li>
</ol>

<p id="enumeration-to-es">
<!-- <a class="dfnref" href="#dfn-enumeration">enumeration type</a> -->
IDL `列挙$型の値を ECMAScript 値に`toES^した結果は、［
その`列挙~値$と同じ`符号単位$の並び
］を表現する `String^t 値になる。
◎
The result of converting an IDL enumeration type value to an ECMAScript value is the String value that represents the same sequence of code units as the enumeration value.
</p>
			</section>
			<section id="es-callback-function">
<h4 title="Callback function types">4.2.23. 呼戻~関数~型</h4>


<p>
IDL `呼戻~関数~型$の値は ECMAScript `Function^t ~objにより表現される。
ただし， `TreatNonObjectAsNull$x の場合は、任意の~objをとり得る。
◎
IDL callback function types are represented by ECMAScript Function objects, except in the [TreatNonObjectAsNull] case, when they can be any object.
</p>

<p id="es-to-callback-function">
次の~algoにより，
ECMAScript 値 %V は IDL `呼戻~関数~型$の値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL callback function type value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`IsCallable$A( %V ) ＝ ~false
］~AND ［
IDL 値への変換は［
`~nullable$ `呼戻~関数$型 ~AND
`TreatNonObjectAsNull$x 注釈付き
］である`属性$への代入-により，遂行されては<em>いない</em>
］
~THEN
~THROW `TypeError^t <!-- % * -->
◎
If the result of calling IsCallable(V) is false and the conversion to an IDL value is not being performed due to V being assigned to an attribute whose type is a nullable callback function that is annotated with [TreatNonObjectAsNull], then throw a TypeError.
</li>

	<li>
~RET
%V が表現するものと同じ~objを表現し,
`呼戻~文脈$として`incumbent-script^ `HTML$r を伴う，
IDL `呼戻~関数~型$の値
◎
Return the IDL callback function type value that represents a reference to the same object that V represents, with the incumbent script as the callback context. [HTML].
</li>

</ol>

<p id="callback-function-to-es">
IDL `呼戻~関数~型$の値を ECMAScript 値に`toES^した結果は、その`呼戻~関数~型$の値が表現するものと同じ~objへの参照になる。
◎
The result of converting an IDL callback function type value to an ECMAScript value is a reference to the same object that the IDL callback function type value represents.
</p>
			</section>
			<section id="es-nullable-type">
<h4 title="Nullable types — T?">4.2.24. ~nullable型 — `~varT?^T</h4>

<p>
IDL `~nullable型$の値は、その`内部型$に対応する ECMAScript 型の値か, または
ECMAScript `null^v 値により表現される。
◎
IDL nullable type values are represented by values of either the ECMAScript type corresponding to the inner IDL type, or the ECMAScript null value.
</p>

<p>
この節を通して、
`~varT?^T は，`内部型$が %T である IDL `~nullable型$を表す。
</p>

<p id="es-to-nullable">
次の~algoにより，
ECMAScript 値 %V は `~varT?^T 型の値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL nullable type T? value (where T is the inner type) as follows:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ≠ Object
］~AND ［
%V から IDL 値への変換は［
`~nullable$<!-- missing id="dfn-nullable" -->`呼戻~関数$型 ~AND
`TreatNonObjectAsNull$x 注釈付き
］である`属性$への代入-により遂行されている
］
~THEN
~RET 型 `~varT?^T の値 `null^V
◎
If Type(V) is not Object, and the conversion to an IDL value is being performed due to V being assigned to an attribute whose type is a nullable callback function that is annotated with [TreatNonObjectAsNull], then return the IDL nullable type T? value null.
</li>
	<li>
~IF
%V ~IN { `null^v, `undefined^v }
~THEN
~RET 型 `~varT?^T の値 `null^V
◎
Otherwise, if V is null or undefined, then return the IDL nullable type T? value null.
</li>
	<li>
~RET %V を`内部型$ %T に対する規則に従って`toIDL^した結果
◎
Otherwise, return the result of converting V using the rules for the inner IDL type T.
</li>
</ol>

<p id="nullable-to-es">
型 `~varT?^T の IDL 値 %V を ECMAScript 値に`toES^した結果は、［
%V ＝ `null^V ならば `null^v ／
~ELSE_ %V を型 %T の値として ECMAScript 値に`toES^した結果
］になる。
◎
The result of converting an IDL nullable type value to an ECMAScript value is:
• If the IDL nullable type T? value is null, then the ECMAScript value is null.
• Otherwise, the ECMAScript value is the result of converting the IDL nullable type value to the inner IDL type T.
</p>

			</section>
			<section id="es-sequence" class="v2">
<h4 title="Sequences — sequence&lt;T&gt;">4.2.25. 連列 — `sequence&lt;~varT&gt;^T</h4>

<p>
IDL `sequence_T^ 値は
ECMAScript `Array^t 値により表現される。
◎
IDL sequence&lt;T&gt; values are represented by ECMAScript Array values.
</p>

<p id="es-to-sequence">
次の~algoにより，
ECMAScript 値 %V は IDL `sequence_T^ 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL sequence&lt;T&gt; value as follows:
</p>

<ol class="algorithm">
	<li>
~IF
%V は ~objでない
~THEN
~THROW `TypeError^t
◎
If V is not an object, throw a TypeError.
</li>

	<li>
~IF
%V は ~native `RegExp^t ~objである
~THEN
~THROW `TypeError^t
◎
If V is a native RegExp object, throw a TypeError.
</li>

	<li id="cp-checkiter-V">
%method := `GetMethod$A( %V, `iterator_symbol^ ) の結果
◎
Let method be the result of GetMethod(V, @@iterator).
</li>

	<li id="cp-ifAbr-method">
`ReturnIfAbrupt$A( %method )
◎
ReturnIfAbrupt(method).
</li>

	<li>
~IF
%method ＝ `undefined^v
~THEN
~THROW `TypeError^t
◎
If method is undefined, throw a TypeError.
</li>

	<li>
%V, %method から型 `sequence_T^ の`連列~値を作成-$した結果
◎
Return the result of creating a sequence of type sequence&lt;T&gt; from V and method.
</li>

</ol>

<p id="sequence-to-es">
次の~algoにより，型 `sequence_T^ の IDL 連列~値 %S は
ECMAScript `Array^t ~objに`toES^される：
◎
An IDL sequence value S of type sequence&lt;T&gt; is converted to an ECMAScript Array object as follows:
</p>

<ol class="algorithm">
	<li>
%n := %S の長さ
◎
Let n be the length of S.
</li>

	<li>
%A := 式 `[]^c で作成されるものと同じ，新たな `Array^t ~obj
◎
Let A be a new Array object created as if by the expression [].
</li>
	<li>
%i :← 0
◎
Initialize i to be 0.
</li>
	<li>
<!--cp-while-i-n-->
		<ol>
			<li>
%V := %S 内の~index %i に位置する値
◎
Let V be the value in S at index i.
</li>
			<li>
%E := %V を ECMAScript 値に`toES^した結果
◎
Let E be the result of converting V to an ECMAScript value.
</li>

			<li>
%P := `ToString$A( %i )
◎
Let P be the result of calling ToString(i).
</li>
			<li>
( ~prop名 %P, ~pdesc `TTT-E^desc, 真偽~flag `false^v )
を引数に，
%A 上の `DefineOwnProperty^es 内的~methを~callする
◎
Call the [[DefineOwnProperty]] internal method on A with property name P, Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: E } and Boolean flag false.
</li>
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
~RET %A
◎
Return A.
</li>
</ol>




				<section id="create-sequence-from-iterable">
<h5 title="Creating a sequence from an iterable">4.2.25.1. 可反復から連列を作成する</h5>

<p>
所与の［
可反復 %iterable,
反復子~取得子 %method
］から
型 `sequence_T^ の IDL 値を作成するときは，次の手続きを遂行する：
◎
To create an IDL value of type sequence&lt;T&gt; given an iterable iterable and an iterator getter method, perform the following steps:
</p>

<ol class="algorithm">
	<li>
%iter := `GetIterator$A(%iterable, %method)
◎
Let iter be GetIterator(iterable, method).
</li>
	<li>
`ReturnIfAbrupt$A( %iter )
◎
ReturnIfAbrupt(iter).
</li>
	<li>
%i :← 0
◎
Initialize i to be 0.
</li>
	<li>
<p>
~WHILE ~T：
◎
Repeat
</p>
		<ol>
			<li>
%next := `IteratorStep$A( %iter )
◎
Let next be IteratorStep(iter).
</li>
			<li>
`ReturnIfAbrupt$A( %next )
◎
ReturnIfAbrupt(next).
</li>
			<li>
~IF
%next ＝ `false^v
~THEN
~RET
~index %j に位置する要素の値が %S<sub>%j</sub> で, 長さ %i の，型
`sequence_T^ の IDL 連列~値
◎
If next is false, then return an IDL sequence value of type sequence&lt;T&gt; of length i, where the value of the element at index j is Sj.
</li>
			<li>
%nextItem := `IteratorValue$A( %next )
◎
Let nextItem be IteratorValue(next).
</li>
			<li>
`ReturnIfAbrupt$A( %nextItem )
◎
ReturnIfAbrupt(nextItem).
</li>
			<li>
%S<sub>%i</sub> :← %nextItem を型 %T の IDL 値に`toIDL^した結果
◎
Initialize Si to the result of converting nextItem to an IDL value of type T.
</li>
			<li id="cp-inc-i">
%i ← %i + 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
</ol>
				</section>




<div class="example">
<p>
次の`~ifc$は
連列~型の引数を伴う`演算$と伴に
連列~型の`属性$を定義する。
◎
The following interface defines an attribute of a sequence type as well as an operation with an argument of a sequence type.
</p>

<pre class="idl-code">
interface Canvas {

  sequence&lt;DOMString&gt; getSupportedImageCodecs();

  void drawPolygon(sequence&lt;double&gt; coordinates);
  sequence&lt;double&gt; getLastDrawnPolygon();

  // <span>...</span>
};
</pre>

<p>
この~ifcの ECMAScript 実装においては、型［
`String^t ／ `Number^t 
］の要素からなる `Array^t ~objが，それぞれ［
`sequence&lt;DOMString&gt;^T ／
`sequence&lt;double&gt;^T
］の表現-に利用される。
この `Array^t ~objは実質的には値渡しであり、
`getSupportedImageCodecs()^c
関数が~callされる度に，新たな `Array^t が返され、
`Array^t が `drawPolygon^c に渡されたときは常に，その参照は~call完了-後には保有されないことになる。
◎
In an ECMAScript implementation of this interface, an Array object with elements of type String is used to represent a sequence&lt;DOMString&gt;, while an Array with elements of type Number represents a sequence&lt;double&gt;. The Array objects are effectively passed by value; every time the getSupportedImageCodecs() function is called a new Array is returned, and whenever an Array is passed to drawPolygon no reference will be kept after the call completes.
</p>

<pre class="es-code">
/* <span title="Obtain an instance of Canvas.  Assume that getSupportedImageCodecs()
returns a sequence with two DOMString values: &quot;image/png&quot; and &quot;image/svg+xml&quot;."
>`Canvas^T の~instanceを得る。
   `getSupportedImageCodecs()^c は、２個の `DOMString^T 値
     `image/png^l, `image/svg+xml^l
   からなる連列を返すものとする。</span> */
var canvas = getCanvas();

// <span title="An Array object of length 2."
>長さ 2 の `Array^t ~obj。</span>
var supportedImageCodecs = canvas.getSupportedImageCodecs();

// <span title="Evaluates to &quot;image/png&quot;." id="cp-eval-img"
>`image/png^l に評価される。</span>
supportedImageCodecs[0];

/* <span title="Each time canvas.getSupportedImageCodecs() is called, it returns a
new Array object.  Thus modifying the returned Array will not
affect the value returned from a subsequent call to the function."
>`canvas.getSupportedImageCodecs()^c が~callされる度に，新たな
   `Array^t object が返される。したがって，返された `Array^t を改変しても，
  後続の関数~callで返される値には影響しないことになる。</span> */
supportedImageCodecs[0] = `image/jpeg^l;

// <!--cp-eval-img-->
canvas.getSupportedImageCodecs()[0];

// <span title="This evaluates to false, since a new Array object is returned each call."
>各~callで新たな `Array^t ~objが返されるので、これは `false^v に評価される。</span>
canvas.getSupportedImageCodecs() == canvas.getSupportedImageCodecs();


// <span title="An Array of Numbers..."
>実数~値の `Array^t は...</span>
var a = [0, 0, 100, 0, 50, 62.5];

// <span title="...can be passed to a platform object expecting a sequence&lt;double&gt;."
>...は `sequence&lt;double&gt;^T を期待する~platform~objに渡すことができる</span>
canvas.drawPolygon(a);

/* <span title="Each element will be converted to a double by first calling ToNumber().
So the following call is equivalent to the previous one, except that
&quot;hi&quot; will be alerted before drawPolygon() returns."
>各~要素は最初に `ToNumber$A() の~callにより， `double^T に変換される。
   したがって，次の~callは `drawPolygon()^c が返る前に
   `hi^l が alert されることを除き，前のものと等価になる。</span> */
a = [
    false,
    '',
    { valueOf: function() { alert('hi'); return 100; } },
    0,
    '50',
    new Number(62.5)
];
canvas.drawPolygon(s);

/* <span title="Modifying an Array that was passed to drawPolygon() is guaranteed not to
have an effect on the Canvas, since the Array is effectively passed by value."
>`Array^t は実質的に値渡しなので，`drawPolygon()^c に渡された
   `Array^t を改変しても， `Canvas^T には効果を及ぼさないことが保証される。</span> */
a[4] = 20;
var b = canvas.getLastDrawnPolygon();
alert(b[4]);    // <span title="This would alert &quot;50&quot;."
>これは `50^l を alert することになる。</span>
</pre>
</div>
<!-- 
IDL sequence&lt;% T values are represented by
...
...
-->
			</section>
			<section id="es-promise" class="v2">

<h4 title="Promise types —&nbsp;Promise&lt;T&gt;">4.2.26. ~promise型 — `Promise&lt;~varT&gt;^T</h4>

<p>
IDL `~promise型$値は
ECMAScript `Promise^t ~objにより表現される。
◎
IDL promise type values are represented by ECMAScript Promise objects.
</p>

<p id="es-to-promise">
次の~algoにより，
ECMAScript 値 %V は IDL `promise_T^ 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL Promise&lt;T&gt; value as follows:
</p>

<ol class="algorithm">
	<li>
<p>
%resolve := `Promise^.resolve の元の値
◎
Let resolve be the original value of %Promise%.resolve.
</p>

<div class="ednote"><p>
ECMAScript は、［
well-known 内在的~obj `Promise_resolve^
］を，ここから参照し得るように増補することになる筈である。
◎
ECMAScript should grow a %Promise_resolve% well-known intrinsic object that can be referenced here.
</p></div>
	</li>

	<li>
%promise := ［
`this^v 値に `Promise^,
単独の引数に %V
］を渡して，%resolve を~callした結果
◎
Let promise be the result of calling resolve with %Promise% as the this value and V as the single argument value.
</li>


	<li>
~RET %promise と同じ~objへの参照である IDL `~promise型$値
◎
Return the IDL promise type value that is a reference to the same object as promise.
</li>
</ol>

<p id="promise-to-es">
IDL `~promise型$値 %V を ECMAScript 値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Promise^t 値になる。
◎
The result of converting an IDL promise type value to an ECMAScript value is the Promise value that represents a reference to the same object that the IDL promise type represents.
</p>

<p>
~promiseが決着したとき、すなわち，それが［
充足された, または却下された
］とき、それぞれに応じて，何らかの手続きが遂行され得る
— そのいずれかは省略され得る
<span class="trans-note">【
これらの手続きは、~promiseを利用する仕様が指定する
】</span>
。
仕様にて
`~promiseが決着したときの手続きを遂行する@
と記された所では、次の手続きに従わ~MUST：
◎
One can perform some steps once a promise is settled. There can be one or two sets of steps to perform, covering when the promise is fulfilled, rejected, or both. When a specification says to perform some steps once a promise is settled, the following steps MUST be followed:
</p>

<ol class="algorithm">

	<li>
%promise := 型 `promise_T^ の~promise~obj
◎
Let promise be the promise object of type Promise&lt;T&gt;.
</li>

	<li>
<p>
%onFulfilled := 被呼出時の挙動が次で与えられる，新たな`関数~obj$
◎
Let onFulfilled be a new function object whose behavior when invoked is as follows:
</p>

		<ol>
			<li>
<p>
~IF %T は `void$T 型
⇒
◎
If T is void, then:
</p>
				<ol>
					<li>
~RET
~promiseが充足-時に走らせることが要求されている手続きを遂行した結果
◎
Return the result of performing any steps that were required to be run if the promise was fulfilled.
</li>
				</ol>
			</li>

			<li>
<p>
~ELSE
⇒
◎
Otherwise, T is a type other than void:
</p>

				<ol>
					<li>
%V := %onFulfilled に渡された第一~引数
◎
Let V be the first argument to onFulfilled.
</li>

					<li>
%value := %V を型 %T の IDL 値に`toIDL^した結果
◎
Let value be the result of converting V to an IDL value of type T.
</li>

					<li>
~IF ［
~promiseの充足-時に走らせることが要求されている手続き
］がある
~THEN
~RET ~promiseの値として %value を渡して，その手続きを遂行した結果
◎
If there are no steps that are required to be run if the promise was fulfilled, then return undefined.
◎
Otherwise, return the result of performing any steps that were required to be run if the promise was fulfilled, with value as the promise’s value.
</li>

					<li>
~RET `undefined^v
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>

	<li>
<p>
%onRejected := 被呼出時の挙動が次で与えられる，新たな`関数~obj$：
◎
Let onRejected be a new function object whose behavior when invoked is as follows:
</p>
		<ol>

			<li>
%R := %onRejected に渡された第一~引数
◎
Let R be the first argument to onRejected.
</li>

			<li>
%reason := %R を IDL <a class="idltype" href="#idl-any">any</a> 型~値に`toIDL^した結果
◎
Let reason be the result of converting R to an IDL value of type any.
</li>

			<li>
~IF ［
~promiseの却下-時に走らせることが要求されている手続き
］がある
~THEN
~RET 却下~事由として %reason を渡して，その手続きを遂行した結果
◎
If there are no steps that are required to be run if the promise was rejected, then return undefined.
◎
Otherwise, return the result of performing any steps that were required to be run if the promise was rejected, with reason as the rejection reason.
</li>

			<li>
~RET `undefined^v
◎
↑</li>
		</ol>
	</li>

	<li>
%then := ~prop名 `then^l により， %promise の `Get^es 内的~methを~callした結果
◎
Let then be the result of calling the internal [[Get]] method of promise with property name “then”.
</li>

	<li>
~IF
%then は`呼出可能$でない
~THEN
~THROW `TypeError^t
◎
If then is not callable, then throw a TypeError.
</li>

	<li>
~RET ［
`this^v 値に %promise,
その２個の引数に ( %onFulfilled, %onRejected )
］を渡して，%then を~callした結果
◎
Return the result of calling then with promise as the this value and onFulfilled and onRejected as its two arguments.
</li>
</ol>

<div class="ednote"><p>
この用語を利用する仕様の記述例を含める必要がある。
◎
Include an example of how to write spec text using this term.
</p></div>


			</section>
			<section id="es-union">
<h4 title="Union types">4.2.27. 共用体~型</h4>


<p>
IDL `共用体~型$の値は
共用体の`~mb型$に対応する ECMAScript 値により表現される。
◎
IDL union type values are represented by ECMAScript values that correspond to the union’s member types.
</p>

<p id="es-to-union">
次の~algoにより，
ECMAScript 値 %V は
IDL `共用体~型$の値に`toIDL^される：
◎
To convert an ECMAScript value V to an IDL union type value is done as follows:
</p>

<ol class="algorithm">
	<li>
~IF［
その`共用体~型$が`~nullable型を内包する$
］~AND［
%V ~IN { `null^v, `undefined^v }
］
~THEN
~RET IDL 値 `null^V
◎
If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
</li>
	<li>
%types := その`共用体~型$の`平坦化~mb型$
◎
Let types be the flattened member types of the union type.
</li>
	<li>
<p>
~IF
%V は `~platform~obj$である
⇒
◎
If V is a platform object, then:
</p>
<!-- 
∈∋
 -->
		<ol>
			<li>
~IF
%types に %V が実装する `~ifc型$が含まれている
~THEN
~RET ~obj %V への参照である IDL 値
◎
If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
</li>
			<li id="cp-object-in-types">
~IF
%types に `object$T が含まれている
~THEN
~RET ~obj %V への参照である IDL 値
◎
If types includes object, then return the IDL value that is a reference to the object V.
</li>
		</ol>
	</li>

	<li class="v2 L2">
<p>
~IF
%V は ~native `RegExp^t ~objである
⇒
◎
If V is a native RegExp object, then:
</p>
		<ol>
			<li>
~IF
%types に `RegExp$T が含まれている
~THEN
~RET %V を `RegExp$T に`toIDL^した結果
◎
If types includes RegExp, then return the result of converting V to RegExp.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>

	<li class="v2">
<p>
~IF
%V は `DOMException^t ~platform~objである
⇒
◎
If V is a DOMException platform object, then:
</p>
		<ol>
			<li>
~IF
%types に `DOMException$T または `Error$T が含まれている
~THEN
~RET %V を その型に`toIDL^した結果
◎
If types includes DOMException or Error, then return the result of converting V to that type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>

	<li class="v2">
<p>
~IF
%V は ~native `Error^t ~objである（すなわち， `ErrorData^es `internal_slot^を持つ）
⇒
◎
If V is a native Error object (that is, it has an [[ErrorData]] internal slot), then:
</p>
		<ol>
			<li>
~IF
%types に `Error$T が含まれている
~THEN
~RET %V を `Error$T に`toIDL^した結果
◎
If types includes Error, then return the result of converting V to Error.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>

	<li class="v2">
<p>
~IF
%V は `ArrayBufferData^es `internal_slot^を伴う~objである
⇒
◎
If V is an object with an [[ArrayBufferData]] internal slot, then:
</p>
		<ol>
			<li>
~IF
%types に `ArrayBuffer$T が含まれている
~THEN
~RET %V を `ArrayBuffer$T に`toIDL^した結果
◎
If types includes ArrayBuffer, then return the result of converting V to ArrayBuffer.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>

	<li class="v2">
<p>
~IF
%V は `DataView^es `internal_slot^を伴う~objである
⇒
◎
If V is an object with a [[DataView]] internal slot, then:
</p>
		<ol>
			<li>
~IF
%types に `DataView$T が含まれている
~THEN
~RET %V を `DataView$T に`toIDL^した結果
◎
If types includes DataView, then return the result of converting V to DataView.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>

	<li class="v2">
<p>
~IF
%V は `TypedArrayName^es `internal_slot^を伴う~objである
⇒
◎
If V is an object with a [[TypedArrayName]] internal slot, then:
</p>
		<ol>
			<li>
~IF
%types に［＊
`有型~配列~型$であって，［
その型~名<!-- 名前 --> ~EQ %V の `TypedArrayName^es `internal_slot^ の値
］なるもの
］が含まれている
~THEN
~RET %V をその型に`toIDL^した結果
◎
If types includes a typed array type whose name is the value of V’s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>

	<li>
<p>
~IF
`IsCallable$A( %V )  ＝ ~true
⇒
◎
If IsCallable(V) is true, then:
</p>
		<ol>
			<li>
~IF
%types に`呼戻~関数$型が含まれている
~THEN
~RET %V をその呼戻~関数~型に`toIDL^した結果
◎
If types includes a callback function type, then return the result of converting V to that callback function type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>

	<li>
<p>
~IF［
%V ~IN { `null^v, `undefined^v }
］~OR［
%V は ~native `RegExp^t ~objを除く任意の種類の~objである
］
⇒
◎
If V is null or undefined or is any kind of object except for a native RegExp object, then:
</p>
		<ol>
			<li>
~IF
%types に`辞書~型$が含まれている
~THEN
~RET %V をその辞書~型に`toIDL^した結果
◎
If types includes a dictionary type, then return the result of converting V to that dictionary type.
</li>
		</ol>
	</li>

	<li>
<p>
~IF
%V は ~native `RegExp^t ~objを除く任意の種類の~objである
⇒
◎
If V is any kind of object except for a native RegExp object, then:
</p>
		<ol>
			<li class="v2">
<p>
~IF
%types に`連列~型$が含まれている
⇒
◎
If types includes a sequence type, then
</p>
				<ol>
					<!--cp-checkiter-V-->
					<!--cp-ifAbr-method-->
					<li>
~IF
%method ≠ `undefined^v
~THEN
~RET %V, %method から その型の`連列~値を作成-$した結果
◎
If method is not undefined, return the result of creating a sequence of that type from V and method.
</li>

				</ol>
			</li>
			<li class="v2">
<p>
~IF
%types に`凍結~配列~型$が含まれている
⇒
◎
If types includes a frozen array type, then
</p>
				<ol>
					<!--cp-checkiter-V-->
					<!--cp-ifAbr-method-->
					<li>
~IF
%method ≠ `undefined^v
~THEN
~RET %V, %method から その型の`凍結~配列~値を作成-$した結果
◎
If method is not undefined, return the result of creating a frozen array of that type from V and method.
</li>

				</ol>
			</li>
			<li>
~IF
%types に`呼戻~ifc$型が含まれている
~THEN
~RET %V をその型に`toIDL^した結果
◎
If types includes a callback interface type, then return the result of converting V to that interface type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>

	<li>
<p>
~IF
%V は `Boolean^t 値である
⇒
◎
If V is a Boolean value, then:
</p>
		<ol>
			<li id="cp-boolean-in-types">
~IF
%types に `boolean$T が含まれている
~THEN
~RET %V を `boolean$T に`toIDL^した結果
◎
If types includes a boolean, then return the result of converting V to boolean.
</li>
		</ol>
	</li>

	<li>
<p>
~IF
%V は `Number^t 値である
⇒
◎
If V is a Number value, then:
</p>
		<ol>
			<li id="cp-numeric-in-types">
~IF
%types に`実数~型$が含まれている
~THEN
~RET %V をその`実数~型$に`toIDL^した結果
◎
If types includes a numeric type, then return the result of converting V to that numeric type.
</li>
		</ol>
	</li>

	<li>
~IF
%types に`文字列~型$が含まれている
~THEN
~RET %V をその型に`toIDL^した結果
◎
If types includes a string type, then return the result of converting V to that type.
</li>

	<!--cp-numeric-in-types-->
	<!--cp-boolean-in-types-->
	<!--cp-throw-typeerror-->
</ol>


<p id="union-to-es">
IDL 共用体~型の値 %U は，次の様にして ECMAScript 値へ`toES^される：
<span class="block">
%U が［
ECMAScript `undefined^v 値を表現する特別な~objへの `object$T 参照
］ならば、 ECMAScript `undefined^v 値に変換される。
他の場合、この 4.2 節にて述べている， %U の`固有型$を変換するための規則に従う。
</span>
◎
An IDL union type value is converted to an ECMAScript value as follows. If the value is an object reference to a special object that represents an ECMAScript undefined value, then it is converted to the ECMAScript undefined value. Otherwise, the rules for converting the specific type of the IDL union type value as described in this section (4.2).
</p>

			</section>
			<section id="es-RegExp" class="v2 L2">
<h4 title="RegExp">4.2.28. `RegExp^T</h4>

<p>
IDL `RegExp$T 値は、 ECMAScript `RegExp^t ~objにより表現される。
◎
IDL RegExp values are represented by ECMAScript RegExp objects.
</p>

<p id="es-to-RegExp">
次の~algoにより，
ECMAScript 値 %V は IDL `RegExp$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL RegExp value by running the following algorithm:
</p>


<ol class="algorithm">
	<li>
<p>
~IF［
`Type^( %V ) ≠ Object
］~OR［
%V は ~native `RegExp^t でない
］
~THEN
%V ← ［
`現在の大域環境$に属するの［
標準の組込みの［
名前 `RegExp^c の構築子
］］により、式 <code>new RegExp(%V)</code> から作成されるもの
］と同じ，新たな `RegExp^t ~obj
◎
If Type(V) is not Object, or V is not a native RegExp object, then set V to be a newly created RegExp object created as if by the expression new RegExp(V), where RegExp is the standard built-in constructor with that name from the current global environment.
</p>

<div class="note"><p>
%V が文字列に変換された際に，正規表現として妥当でない構文である場合、例外が投出され得ることに注意。
◎
Note that this can result in an exception being thrown, if V, when converted to a string, does not have valid regular expression syntax.
</p></div>

</li>

	<li>
~RET %V と同じ~objへの参照である IDL `RegExp$T 値
◎
Return the IDL RegExp value that is a reference to the same object as V.
</li>

</ol>

<p id="RegExp-to-es">
IDL `RegExp$T 値 %V を ECMAScript 値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `RegExp^t 値である。
◎
The result of converting an IDL RegExp value to an ECMAScript value is the RegExp value that represents a reference to the same object that the IDL RegExp represents.
</p>

			</section>
			<section id="es-Error" class="v2">
<h4 title="Error">4.2.29. `Error^T</h4>

<p>
IDL `Error$T 値は、［
~native ECMAScript `Error^t ~obj ／
`DOMException$ に対する~platform~obj
］により表現される。
◎
IDL Error values are represented by native ECMAScript Error objects and platform objects for DOMExceptions.
</p>


<p id="es-to-Error">
次の~algoにより，
ECMAScript 値 %V は IDL `Error$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL Error value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ≠ Object
］~OR［
%V は `ErrorData^es
`internal_slot^ を持たない
］
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Object, or V does not have an [[ErrorData]] internal slot, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である IDL `Error$T 値
◎
Return the IDL Error value that is a reference to the same object as V.
</li>
</ol>


<p id="Error-to-es">
IDL `Error$T 値 %V を ECMAScript 値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Error^t 値である。
◎
The result of converting an IDL Error value to an ECMAScript value is the Error value that represents a reference to the same object that the IDL Error represents.
</p>

			</section>
			<section id="es-DOMException" class="v2">
<h4 title="DOMException">4.2.30. `DOMException^T</h4>

<p>
IDL `DOMException$T 値は、
`DOMException$ に対する~platform~objにより表現される。
◎
IDL DOMException values are represented by platform objects for DOMExceptions.
</p>

<p id="es-to-DOMException">
次の~algoにより，
ECMAScript 値 %V は IDL `DOMException$ 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL DOMException value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ≠ Object
］~OR［
%V は `DOMException$ を表現する~platform~objでない
］
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Object, or V is not a platform object that represents a DOMException, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である IDL `DOMException$T 値
◎
Return the IDL DOMException value that is a reference to the same object as V.
</li>

</ol>

<p id="DOMException-to-es">
IDL `DOMException$T 値 %V を ECMAScript 値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^t 値である。
◎
The result of converting an IDL DOMException value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL DOMException represents.
</p>


			</section>
			<section id="es-buffer-source-types" class="v2">
<h4 title="Buffer source types">4.2.31. ~buffer~source型</h4>

<p>
IDL `~buffer~source型$の値は、対応する ECMAScript ~classの~objにより表現される。
◎
Values of the IDL buffer source types are represented by objects of the corresponding ECMAScript class.
</p>

<p id="es-to-buffer-source">
次の~algoにより，
ECMAScript 値 %V は IDL `ArrayBuffer$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL ArrayBuffer value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ≠ Object
］~OR［
%V は `ArrayBufferData^es `internal_slot^ を持たない
］~OR［
`IsDetachedBuffer$A( %V ) ~EQ `true^v
］
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Object, or V does not have an [[ArrayBufferData]] internal slot, or IsDetachedBuffer(V) is true, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である IDL `ArrayBuffer$T 値
◎
Return the IDL ArrayBuffer value that is a reference to the same object as V.
</li>
</ol>

<p id="buffer-source-to-es">
次の~algoにより，
ECMAScript 値 %V は IDL `DataView$T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL DataView value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ≠ Object
］~OR［
%V は `DataView^es `internal_slot^ を持たない
］
~THEN
~THROW `TypeError^t
◎
If Type(V) is not Object, or V does not have a [[DataView]] internal slot, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である IDL `DataView$T 値
◎
Return the IDL DataView value that is a reference to the same object as V.
</li>
</ol>

<p>
%T をいずれかの`有型~配列~型$とするとき、次の~algoにより， ECMAScript 値 %V は IDL %T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array or Float64Array value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type^( %V ) ≠ Object
］~OR［
%V は ［
値が %T の型~名に等しい `TypedArrayName^es `internal_slot^
<!-- ＊名前 -->
］を持たない
］
~THEN
~THROW `TypeError^t
◎
Let T be the IDL type V is being converted to.
◎
If Type(V) is not Object, or V does not have a [[TypedArrayName]] internal slot with a value equal to the name of T, then throw a TypeError.
</li>

	<li>
~RET %V と同じ~objへの参照である IDL %T 値
◎
Return the IDL value of type T that is a reference to the same object as V.
</li>
</ol>

<p>
いずれの`~buffer~source型$に対しても、その型の IDL 値 %V を ECMAScript 値に`toES^した結果は，
%V が表現するものと同じ~objへの参照を表現する `Object^t 値である。
◎
The result of converting an IDL value of any buffer source type to an ECMAScript value is the Object value that represents a reference to the same object that the IDL value represents.
</p>

<p>
［
ECMAScript ［
`ArrayBuffer^t,
`DataView^t,
`有型~配列~型$
］のいずれかの ~objである，~buffer~source %O
］に保持されている~byte列の`参照／複製を取得-$するときは、次の手続きに従わ~MUST：
◎
When getting a reference to or getting a copy of the bytes held by a buffer source that is an ECMAScript ArrayBuffer, DataView or typed array object, these steps MUST be followed:
</p>

<ol class="algorithm">
	<li>
%arrayBuffer :← %O
◎
Let O be the ECMAScript object that is the buffer source.
◎
Initialize arrayBuffer to O.
</li>
	<li>
%offset :← 0
◎
Initialize offset to 0.
</li>
	<li>
%length :← 0
◎
Initialize length to 0.
</li>
	<li>

<p>
~IF
%O は `ViewedArrayBuffer^es `internal_slot^ を持つ
⇒
◎
If O has a [[ViewedArrayBuffer]] internal slot, then:
</p>

		<ol>
			<li>
%arrayBuffer ←
%O の `ViewedArrayBuffer^es `internal_slot^ の値
◎
Set arrayBuffer to the value of O’s [[ViewedArrayBuffer]] internal slot.
</li>
			<li>
~IF
%arrayBuffer ~EQ `undefined^v
~THEN
~THROW `TypeError^t
◎
If arrayBuffer is undefined, then throw a TypeError.
</li>
			<li>
%offset ←
%O の `ByteOffset^es `internal_slot^ の値
◎
Set offset to the value of O’s [[ByteOffset]] internal slot.
</li>
			<li>
%length ←
%O の `ByteLength^es `internal_slot^ の値
◎
Set length to the value of O’s [[ByteLength]] internal slot.
</li>
		</ol>
	</li>
	<li>
~ELSE
%length ←
%O の `ArrayBufferByteLength^es `internal_slot^ の値
◎
Otherwise, set length to the value of O’s [[ArrayBufferByteLength]] internal slot.
</li>
	<li>
~IF
`IsDetachedBuffer$A( %O )
~THEN
~THROW `TypeError^t
◎
If IsDetachedBuffer(O), then throw a TypeError.
</li>
	<li>
%data :=
%O の `ArrayBufferData^es `internal_slot^ の値
◎
Let data be the value of O’s [[ArrayBufferData]] internal slot.
</li>
	<li>
~RET ［
%data 内の~byte~offset %offset の所から， %length 個の~byte
］［
への参照, または の複製
］（いずれか要求された方）。
◎
Return a reference to or copy of (as required) the length bytes in data starting at byte offset offset.
</li>
</ol>

<p>
`ArrayBuffer$T ~objを`切離す$ときは、次の手続きに従わ~MUST：
◎
To detach an ArrayBuffer, these steps MUST be followed:
</p>

<ol class="algorithm">
	<li>
%O := その［
`ArrayBuffer$T である ECMAScript ~obj
］
◎
Let O be the ECMAScript object that is the ArrayBuffer.
</li>
	<li>
`DetachArrayBuffer$A( %O )
◎
DetachArrayBuffer(O).
</li>
</ol>

			</section>
			<section id="es-frozen-array" class="v2 L2">
<h4 title="Frozen arrays — FrozenArray&lt;T&gt;">4.2.32. 凍結~配列 — `FrozenArray&lt;~varT&gt;^T</h4>


<p>
`凍結~配列~型$の値は、~~凍結された（ frozen ） ECMAScript `Array^t ~obj参照により表現される。
◎
Values of frozen array types are represented by frozen ECMAScript Array object references.
</p>

<p>
次の~algoにより，
ECMAScript 値 %V は IDL `FrozenArray&lt;~varT&gt;^T 値に`toIDL^される：
◎
An ECMAScript value V is converted to an IDL FrozenArray&lt;T&gt; value by running the following algorithm:
</p>


<ol class="algorithm">
	<li>
%values := %V を IDL `sequence&lt;~varT&gt;^T 型に`toIDL^した結果
◎
Let values be the result of converting V to IDL type sequence&lt;T&gt;.
</li>
	<li>
~RET %values から`凍結~配列を作成-$した結果
◎
Return the result of creating a frozen array from values.
</li>
</ol>

<p>
型 ~varT の値の連列から
`凍結~配列を作成-@
するときは、次の手続きに従う：
◎
To create a frozen array from a sequence of values of type T, follow these steps:
</p>

<ol class="algorithm">
	<li>
%array := 値の連列を ECMAScript 値に`toES^した結果
◎
Let array be the result of converting the sequence of values to an ECMAScript value.
</li>
	<li>
Perform<!-- ＊ -->
`SetIntegrityLevel$A(%array, <code>"frozen"</code>)
◎
Perform SetIntegrityLevel(array, "frozen").
</li>
	<li>
~RET %array
◎
Return array.
</li>
</ol>

<p>
IDL `FrozenArray&lt;~varT&gt;^T 値 %V を ECMAScript 値に`toES^した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^t 値である。
◎
The result of converting an IDL FrozenArray&lt;T&gt; value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL FrozenArray&lt;T&gt; represents.
</p>

				<section id="create-frozen-array-from-iterable">
<h5 title="Creating a frozen array from an iterable">4.2.32.1. 可反復から凍結~配列を作成する</h5>

<p>
所与の［
可反復 %iterable,
反復子~取得子 %method
］から
型 `FrozenArray_T^ の IDL 値を作成するときは，次の手続きを遂行する：
◎
To create an IDL value of type FrozenArray&lt;T&gt; given an iterable iterable and an iterator getter method, perform the following steps:
</p>

<ol class="algorithm">
	<li>
%values := %iterable, %method から型 ~varT の`連列~値を作成-$した結果
◎
Let values be the result of creating a sequence of type sequence&lt;T&gt; from iterable and method.
</li>
	<li>
~RET %values から`凍結~配列を作成-$した結果
◎
Return the result of creating a frozen array from values.
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="es-extended-attributes">
<h3 title="ECMAScript-specific extended attributes">4.3. ECMAScript 固有の拡張属性</h3>


<p>
この節では、その存在tが ECMAScript 言語束縛にのみ影響する いくつかの`拡張属性$を定義する。
◎
This section defines a number of extended attributes whose presence affects only the ECMAScript binding.
</p>

			<section id="Clamp">
<h4>4.3.1. `Clamp^x</h4>


<p>
`Clamp$x `拡張属性$が［
`整数~型$の［
`演算$の引数 ／
~writableな`属性$ ／
`辞書~mb$
］］上に現れた場合、
ECMAScript `Number^t から IDL 型への変換-において，範囲~外の値は、
modulo 演算（ `ToInt32$A, `ToUint32$A, 等々）を利用する演算子を利用せずに，範囲~内の妥当な値に切詰められる（切り上げ／切り下げされる）ことになる。
◎
If the [Clamp] extended attribute appears on an operation argument, writable attribute or dictionary member whose type is one of the integer types, it indicates that when an ECMAScript Number is converted to the IDL type, out of range values will be clamped to the range of valid values, rather than using the operators that use a modulo operation (ToInt32, ToUint32, etc.).
</p>

<div>
<p>
`Clamp$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
</li>
	<li>
`読専$の属性に現れては~MUST_NOT。
</li>

	<li>
`整数~型$でない［
属性／演算~引数／辞書~mb
］に現れては~MUST_NOT。
</li>

	<li>
`EnforceRange$x 拡張属性と併用されては~MUST_NOT。
</li>
</ul>

◎
The [Clamp] extended attribute MUST take no arguments.
◎
The [Clamp] extended attribute MUST NOT appear on a read only attribute, or an attribute, operation argument or dictionary member that is not of an integer type. It also MUST NOT be used in conjunction with the [EnforceRange] extended attribute.
</div>


<p>
`Clamp$x の利用に課される固有の要件については、
ECMAScript 値から種々の IDL 整数~型への変換-規則について述べた
`es-type-mapping$sec
に。
◎
See the rules for converting ECMAScript values to the various IDL integer types in section 4.2 for the specific requirements that the use of [Clamp] entails.
</p>


<div class="example">
<p>
次の `IDL 片$では，それぞれが３個の `octet$T 引数をとる，２個の`演算$が宣言される。
一方には３個すべての引数に `Clamp$x `拡張属性$が利用され，他方はそうでない：
◎
In the following IDL fragment, two operations are declared that take three octet arguments; one uses the [Clamp] extended attribute on all three arguments, while the other does not:
</p>

<pre class="idl-code">
interface GraphicsContext {
  void setColor(octet red, octet green, octet blue);
  void setColorClamped([Clamp] octet red, [Clamp] octet green, [Clamp] octet blue);
};
</pre>

<p>
この IDL の ECMAScript 実装においては、
`setColorClamped^M の~callに渡された，
`octet$T の範囲~外の `Number^t 値は、範囲 [0,&nbsp;255] に切詰められる。
◎
In an ECMAScript implementation of the IDL, a call to setColorClamped with Number values that are out of range for an octet are clamped to the range [0, 255].
</p>

<pre class="es-code">
// <span title="Get an instance of GraphicsContext."
>`GraphicsContext^T の~instanceを取得する。</span>
var context = getGraphicsContext();

// <span title="Calling the non-[Clamp] version uses ToUint8 to coerce the Numbers to octets."
>非 `Clamp^x 版の~callは実数~値を~octetに強制する ToUint8 を利用する。</span>
// <span title="This is equivalent to calling setColor(255, 255, 1)."
>次は `setColor(255, 255, 1)^c の~callと等価。</span>
context.setColor(-1, 255, 257);

// <span title="Call setColorClamped with some out of range values."
>範囲~外の値を渡して `setColorClamped^M を~call。</span>
// <span title="This is equivalent to calling setColorClamped(0, 255, 255)."
>次は `setColorClamped(0, 255, 255)^c の~callと等価。</span>
context.setColorClamped(-1, 255, 257);
</pre>
</div>
			</section>
			<section id="Constructor">
<h4>4.3.2. `Constructor^x</h4>


<p>
`Constructor$x `拡張属性$が `~ifc$上に現れた場合、その~ifcに対応する`~ifc~obj$は，［
その~ifcを実装する~objを構築し得るようにする， `Construct^es 内的~meth
］を持つことになる。
◎
If the [Constructor] extended attribute appears on an interface, it indicates that the interface object for this interface will have an [[Construct]] internal method, allowing objects implementing the interface to be constructed.
</p>

<div class="p v2">
<p>
`Constructor$x `拡張属性$が `辞書$上に現れた場合、 ECMAScript 大域~objは，次を伴う~propを持つことになる：
</p>

<ul>
	<li>
その名前は、辞書の識別子。
</li>
	<li>
値は、所与の型による辞書~値を表現する ECMAScript ~objを返せる構築子~関数。
</li>
</ul>

◎
If it appears on a dictionary, then it indicates that the ECMAScript global object will have a property whose name is the identifier of the dictionary and whose value is a constructor function that can return an ECMAScript object that represents a dictionary value of the given type.
</div>


<p>
同じ［
~ifc／辞書
］上に複数の `Constructor$x 拡張属性が現れてもよい。
◎
Multiple [Constructor] extended attributes may appear on a given interface or dictionary.
</p>

<p>
`Constructor$x 拡張属性には、［
`引数をとらない$
か, または
`有名~引数~listを引数にとる$
］ことが~REQUIRED。<!-- MUST -->
略記形の前者
`[Constructor]^c
は、引数~listが空にされた
`[Constructor()]^c
と同じ意味になる。
~ifc上のそれぞれの `Constructor$x 拡張属性が、［
指定された引数を渡して，その~ifcを実装する~objを構築する仕方
］を、供することになる。
◎
The [Constructor] extended attribute MUST either take no arguments or take an argument list. The bare form, [Constructor], has the same meaning as using an empty argument list, [Constructor()]. For each [Constructor] extended attribute on the interface, there will be a way to construct an object that implements the interface by passing the specified arguments.
</p>

<p class="v2">
構築子の注釈文においては，［
`Constructor$x 拡張属性が現れる［
~ifc／辞書
］に対応する型の IDL 値を返すか, または
例外を投出する
］ように定義され~MUST。
◎
The prose definition of a constructor MUST either return an IDL value of a type corresponding to the interface or dictionary the [Constructor] extended attribute appears on, or throw an exception.
</p>

<p>
`Constructor$x 拡張属性は：
</p>

<ul>
	<li><p>
同じ~ifc上で， `NoInterfaceObject$x 拡張属性と併用されては~MUST_NOT。
◎
If the [Constructor] extended attribute is specified on an interface, then the [NoInterfaceObject] extended attribute MUST NOT also be specified on that interface.
</p></li>

	<li><p>
`呼戻~ifc$上に利用されては~MUST_NOT。
◎
The [Constructor] extended attribute MUST NOT be used on a callback interface.
</p></li>
</ul>


<p>
~ifc／辞書
に対する構築子がどう実装されるかの詳細は
`es-interface-call$sec ／ `es-dictionary-constructors$sec
に。
◎
See section 4.6.1.1 below for details on how a constructor for an interface is to be implemented, and section 4.6.3 for how a constructor for a dictionary is to be implemented.
</p>


<div class="example">
<p>
次の IDL は２つの~ifcを定義する。
二番目のものは `Constructor$x 拡張属性を持つ一方，最初のものは持たない。
◎
The following IDL defines two interfaces. The second has the [Constructor] extended attribute, while the first does not.
</p>

<pre class="idl-code">
interface NodeList {
  Node item(unsigned long index);
  readonly attribute unsigned long length;
};

[Constructor,
 Constructor(double radius)]
interface Circle {
  attribute double r;
  attribute double cx;
  attribute double cy;
  readonly attribute double circumference;
};
</pre>

<p>
これらの~ifcを~supportする ECMAScript 実装は、
`Circle^T ~ifc~obj上に，［
その~ifcを実装する新たな~obj
］を返す `Construct^es ~propを持つことになる。
それは 0 個または 1 個の引数をとる。
`NodeList^T ~ifc~objは
`Construct^es ~propを持たないことになる。
◎
An ECMAScript implementation supporting these interfaces would have a [[Construct]] property on the Circle interface object which would return a new object that implements the interface. It would take either zero or one argument. The NodeList interface object would not have a [[Construct]] property.
</p>

<pre class="es-code">
var x = new Circle();      
       // <span title="The uses the zero-argument constructor to create a
reference to a platform object that implements the
Circle interface."
>これは，引数なしの構築子を利用して、 `Circle^T ~ifcを
//        実装する~platform~objへの参照を作成する。</span>

var y = new Circle(1.25);  
       // <span title="This also creates a Circle object, this time using
the one-argument constructor."
>今度は１引数の構築子を利用して `Circle^T ~objを作成する。</span>

var z = new NodeList();    
       // <span title="This would throw a TypeError, since no
[Constructor] is declared."
>`Constructor^x が宣言されていないので
//        `TypeError^t が投出されることになる。</span>
</pre>
</div>


<div class="example v2">
<p>
次の IDL は構築子を伴う辞書~型を定義する：
◎
The following IDL defines a dictionary type with a constructor:
</p>

<pre class="idl-code">
[Constructor(unsigned long patties, unsigned long cheeseSlices)]
dictionary BurgerOrder {
  unsigned long pattyCount;
  unsigned long cheeseSliceCount;
};
</pre>

<p>
構築子は次の注釈文を伴って定義される：
◎
The constructor is defined with the following prose:
</p>

<p>
`BurgerOrder^T 構築子の被呼出時には、
`pattyCount^c ／ `cheeseSliceCount^c
~mbが，それぞれ
`patties^c ／ `cheeseSlices^c
引数の値に設定された，型 `BurgerOrder^T の辞書~値が返され~MUST。
◎
When the BurgerOrder constructor is invoked, it must return a dictionary value of type BurgerOrder whose pattyCount and cheeseSliceCount members are set to the values of the patties and cheeseSlices arguments, respectively.
</p>

<p>
この辞書~型を~supportする ECMAScript 実装は、大域~obj上にて，［［
辞書の~mbに対応する~prop
］を伴う plain ~obj
］を返す構築子~関数を持つことになる：
◎
An ECMAScript implementation supporting this dictionary type would have a constructor function on the global object that returns a plain object with properties corresponding to the dictionary’s members:
</p>

<pre class="es-code">
typeof BurgerOrder;                     // <!--cp-eval-function-->

var order = new BurgerOrder(1, 2);      // <span title="Creates a new object."
>新たな~objを作成する。</span>

order.hasOwnProperty("pattyCount");     // <!--cp-eval-true-->
order.pattyCount;                       // <span id="cp-eval-1" title="Evaluates to 1."
>`1^v に評価される。</span>

Object.getPrototypeOf(order) == Object.prototype;  // <!--cp-eval-true-->

</pre>

</div>


			</section>
			<section id="EnforceRange">
<h4>4.3.3. `EnforceRange^x</h4>


<p>
`EnforceRange$x `拡張属性$が［
`演算$の引数 ／
~writableな`正則~属性$／
`整数~型$の`辞書~mb$
］に現れた場合、
ECMAScript `Number^t がその IDL 型に変換される際に，範囲~外の値に対しては、 modulo 演算を利用する演算子（ `ToInt32$A, `ToUint32$A, 等々）を利用して妥当な値に変換される代わりに，例外が投出されるようになる。
`Number^t は、その範囲が検査される前に，ゼロ側に丸められる。
◎
If the [EnforceRange] extended attribute appears on an operation argument, writable regular attribute or dictionary member whose type is one of the integer types, it indicates that when an ECMAScript Number is converted to the IDL type, out of range values will cause an exception to be thrown, rather than converted to being a valid value using the operators that use a modulo operation (ToInt32, ToUint32, etc.). The Number will be rounded towards zero before being checked against its range.
</p>

<div>
<p>
`EnforceRange$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
</li>
	<li>
［
`読専$属性 ／ `静的~属性$
］に現れては~MUST_NOT。
</li>
	<li>
`整数~型$でない［
属性 ／ 演算~引数 ／ 辞書~mb
］に現れては~MUST_NOT。
</li>
	<li>
`Clamp$x 拡張属性と併用されては~MUST_NOT。
</li>
</ul>

◎
The [EnforceRange] extended attribute MUST take no arguments.
◎
The [EnforceRange] extended attribute MUST NOT appear on a read only attribute, a static attribute, or an attribute, operation argument or dictionary member that is not of an integer type. It also MUST NOT be used in conjunction with the [Clamp] extended attribute.
</div>


<p>
`EnforceRange$x の利用に課される固有の要件については、［
ECMAScript 値から種々の IDL 整数~型への変換-規則
］について述べている
`es-type-mapping$sec
にて。
◎
See the rules for converting ECMAScript values to the various IDL integer types in section 4.2 for the specific requirements that the use of [EnforceRange] entails.
</p>


<div class="example">
<p><!-- copy* -->
次の `IDL 片$では，それぞれが３個の `octet$T 引数をとる，２個の`演算$が宣言される。
一方には３個すべての引数に `EnforceRange$x `拡張属性$が利用され，他方はそうでない：
◎
In the following IDL fragment, two operations are declared that take three octet arguments; one uses the [EnforceRange] extended attribute on all three arguments, while the other does not:
</p>

<pre class="idl-code">
interface GraphicsContext {
  void setColor(octet red, octet green, octet blue);
  void setColorEnforcedRange([EnforceRange] octet red, [EnforceRange] octet green, [EnforceRange] octet blue);
};
</pre>

<p>
この IDL の ECMAScript 実装においては、
`octet$T の範囲~外の `Number^t 値を渡して
`setColorEnforcedRange^M を~callしたときの結果は、例外の投出になる。
◎
In an ECMAScript implementation of the IDL, a call to setColorEnforcedRange with Number values that are out of range for an octet will result in an exception being thrown.
</p>

<pre class="es-code">
// <span title="Get an instance of GraphicsContext."
>`GraphicsContext^T の~instanceを取得する。</span>
var context = getGraphicsContext();

/* <span title="Calling the non-[EnforceRange] version uses ToUint8 to coerce the Numbers to octets.
This is equivalent to calling setColor(255, 255, 1)."
>非 `EnforceRange^x 版の~callは実数~値を~octetに強制する ToUint8 を
  利用する。これは `setColor(255, 255, 1)^c の~callと等価になる。</span> */
context.setColor(-1, 255, 257);

/* <span title="When setColorEnforcedRange is called, Numbers are rounded towards zero.
This is equivalent to calling setColor(0, 255, 255)."
>実数~値は `setColorEnforcedRange^M が~callされる際にゼロ側に丸められる。
   これは `setColor(0, 255, 255)^c の~callと等価になる。</span> */
context.setColorEnforcedRange(-0.9, 255, 255.2);

/* <span title="The following will cause a TypeError to be thrown, since even after
rounding the first and third argument values are out of range."
>次は `TypeError^t を投出させる。丸められた後でも，
   第一, 第三~引数は範囲~外になるので。</span> */
context.setColorEnforcedRange(-1, 255, 256);
</pre>
</div>


			</section>
			<section id="Exposed">

<h4>4.3.4. `Exposed^x</h4>

<p>
`Exposed$x `拡張属性$が［［
`~ifc$ ／ `部分的~ifc定義$
］／
個々の`~ifc~mb$ ／
<a href="#es-dictionary-constructors">構築子</a>を伴う`辞書$
］上に現れた場合、その［
~ifc ／
~ifc~mb ／
<a href="#es-dictionary-constructors">辞書~構築子</a>
］が，特定0の［
大域~ifcの集合
］上に公開されることを指示する
—
既定による，`主~大域~ifc$上でのみ公開されるのではなく。
◎
If the [Exposed] extended attribute appears on an interface, partial interface, an individual interface member, or dictionary with a constructor, it indicates that the interface, interface member or dictionary constructor is exposed on a particular set of global interfaces, rather than the default of being exposed only on the primary global interface.
</p>

<p>
`Exposed$x `拡張属性$には、
`識別子を引数にとる$か, または
`識別子~listを引数にとる$ことが~REQUIRED。
引数に挙げられた各~識別子は`大域~名$で~MUST。
◎
The [Exposed] extended attribute MUST either take an identifier or take an identifier list. Each of the identifiers mentioned MUST be a global name.
</p>

<p>
`Exposed$x `拡張属性$を指定し得る どの構成子も，
`公開~集合@
を持つ
— それは、`~ifc$の集合であり，その構成子が どの大域環境で利用し得るかを定義する。
所与の構成子に対する`公開~集合$は、次で定義される：
◎
Every construct that the [Exposed] extended attribute can be specified on has an exposure set, which is a set of interfaces defining which global environments the construct can be used in. The exposure set for a given construct is defined as follows:
</p>

<ul>
	<li><p>
［
`Exposed$x `拡張属性$が指定されている構成子
］の`公開~集合$は，［
その拡張属性の引数に挙げられている いずれかの`大域~名$
］を持つ~ifcからなる。
◎
If the [Exposed] extended attribute is specified on the construct, then the exposure set is the set of all interfaces that have a global name that is listed in the extended attribute's argument.
</p></li>

	<li>
<p>
下に挙げる構成子のうち， `Exposed$x 拡張属性が現れないものに対しては、その構成子の型に依存して，その`公開~集合$が暗黙的に定義される：
◎
If the [Exposed] extended attribute does not appear on a construct, then its exposure set is defined implicitly, depending on the type of construct:
</p>

<dl class="switch">
	<dt>~ifc◎interface</dt>
	<dt>辞書◎dictionary</dt>
	<dd>
`主~大域~ifc$のみからなる。
◎
The exposure set of the interface or dictionary only contains the primary global interface.
</dd>

	<dt>部分的~ifc◎partial interface</dt>
	<dd>
元の~ifc定義の`公開~集合$と同じ。
◎
The exposure set of the partial interface is the exposure set of the original interface definition.
</dd>

	<dt>~ifc~mb◎interface member</dt>
	<dd>
その~mbが宣言されている［
~ifc／部分的~ifc
］の`公開~集合$と同じ。
◎
The exposure set of the interface member is the exposure set of the interface or partial interface the member is declared on.
</dd>
</dl>
	</li>
</ul>


<p>
`Exposed$x 拡張属性は：
</p>

<ul>
	<li>
［
`多重定義$されている`演算$
］上に現れるときは、その演算のすべての多重定義~上に，引数も含めて全く同じに現れ~MUST。
◎
If [Exposed] appears on an overloaded operation, then it MUST appear identically on all overloads.
</li>
	<li>
［
~ifc~mbと, その~ifc~mbを宣言している部分的~ifc定義
］の両者に指定されては~MUST_NOT。
◎
The [Exposed] extended attribute MUST NOT be specified on both an interface member and a partial interface definition the interface member is declared on.
</li>
	<li>
~ifc %I とその~ifc~mb %m の両者に現れた場合、 %m の`公開~集合$は， %I の`公開~集合$の部分集合で~MUST。
◎
If [Exposed] appears on both an interface and one of its interface members, then the interface member's exposure set MUST be a subset of the interface's exposure set.
</li>
	<li class="v2">
`Constructor$x 拡張属性を持たない`辞書$上に指定されては~MUST_NOT。
◎
↓</li>
</ul>

<p>
~ifcの`公開~集合$は：
</p>

<ul>
	<li>
その`帰結~ifc$すべての`公開~集合$の和集合の部分集合で~MUST。
◎
An interface's exposure set MUST be a subset of the exposure set of all of the interface's consequential interfaces.
</li>
	<li>
別の~ifcを`継承-$しているならば、その~ifcの`公開~集合$の部分集合で~MUST。
◎
If an interface X inherits from another interface Y then the exposure set of X MUST be a subset of the exposure set of Y.
◎
The [Exposed] extended attribute MUST NOT be specified on a dictionary that does not also have a [Constructor] extended attribute.
</li>
</ul>

<p>
［
`~ifc$／`~ifc~mb$／`辞書$
］ %X が，所与の ECMAScript 大域環境 %G において
`公開され@
るとは、 %G が［
%X の`公開~集合$に属する ある~ifc
］を実装していて，次のいずれかを満たすことを意味する：
◎
An interface, interface member or dictionary is exposed in a given ECMAScript global environment if the ECMAScript global object implements an interface that is in the interface, interface member or dictionary's exposure set, and either:
</p>

<ul>
	<li>
ECMAScript 大域~objに`関連する設定群~obj$は
`~secure文脈$であるか, または
◎
the relevant settings object for the ECMAScript global object is a secure context; or
</li>
	<li>
%X は`~secure文脈~下に限り可用$ではない。
◎
the interface, interface member or dictionary is not available only in secure contexts.
</li>
</ul>

<div class="note"><p>
ECMAScript 大域~objに`関連する設定群~obj$が`~secure文脈$であるかどうかは，変化し得ないので、
%X に対する~propを作成するかどうかの実装による決断は、`初期~obj$を作成する時点の一度限りになる。
◎
Since it is not possible for the relevant settings object for an ECMAScript global object to change whether it is a secure context or not over time, an implementation's decision to create properties for an interface, interface member or dictionary can be made once, at the time the initial objects are created.
</p></div>


<p>
`Exposed$x の利用に課される固有の要件については
`es-interfaces$sec,
`es-dictionary-constructors$sec,
`es-constants$sec,
`es-attributes$sec,
`es-operations$sec,
`es-iterators$sec
に。
◎
See section 4.6, section 4.6.3, section 4.6.6, section 4.6.7, section 4.6.8 and section 4.6.9 for the specific requirements that the use of [Exposed] entails.
</p>

<div class="example">
<p>
`Exposed$x には、~ifcや個々の~ifc~mbを［
`Worker^T <span class="trans-note">【
<a href="http://dev.w3.org/html5/workers/">Web Workers</a>
】</span>
や `Window^T, あるいはその両者
］の中でのみ可用にするかどうかを制御する用途が意図されている。
◎
[Exposed] is intended to be used to control whether interfaces or individual interface members are available for use only in workers, only in the Window, or in both.
</p>

<p>
それがどのように得られるかを，次の IDL 片に示す：
◎
The following IDL fragment shows how that might be achieved:
</p>

<pre class="idl-code">
[PrimaryGlobal]
interface Window {
  ...
};

/* <span title="By using the same identifier Worker for both SharedWorkerGlobalScope
	and DedicatedWorkerGlobalScope, both can be addressed in an [Exposed]
	extended attribute at once."
>`SharedWorkerGlobalScope^T と `DedicatedWorkerGlobalScope^T
   の両者に同じ識別子 `Worker^l を利用する — 両者は
   `Exposed^x 拡張属性からまとめて指せるようになる。</span> */
[Global=Worker]
interface SharedWorkerGlobalScope : WorkerGlobalScope {
  ...
};

[Global=Worker]
interface DedicatedWorkerGlobalScope : WorkerGlobalScope {
  ...
};

/* <span title="MathUtils is available for use in workers and on the main thread."
>`MathUtils^T は、［ メインスレッド上と~workerの中 ］でのみ可用。</span> */
[Exposed=(Window,Worker)]
interface MathUtils {
  static double someComplicatedFunction(double x, double y);
};

/* <span title="WorkerUtils is only available in workers.  Evaluating WorkerUtils
	in the global scope of a worker would give you its interface object, while
	doing so on the main thread will give you a ReferenceError."
>`WorkerUtils^T は，~workerの中でのみ可用。 `WorkerUtils^T を~workerの
   大域~scopeの中で評価したときは その~ifc~objを得られるが、
   メインスレッド上でそれを行ったときは `ReferenceError^t になる。</span> */
[Exposed=Worker]
interface WorkerUtils {
  static void setPriority(double x);
};

/* <span title="Node is only available on the main thread.  Evaluating Node
	in the global scope of a worker would give you a ReferenceError."
>`Node^T はメインスレッド上でのみ可用。~workerの大域~scopeの中で
   `Node^T を評価したときは `ReferenceError^t になる。</span> */
interface Node {
  ...
};
</pre>

</div>


			</section>
			<section id="ImplicitThis" class="L2">
<h4>4.3.5. `ImplicitThis^x</h4>

<p>
`ImplicitThis$x `拡張属性$が `~ifc$上に現れた場合、
その~ifcの`演算$に対応する `Function^t が，
`this^v 値として［
`null^v または `undefined^v
］値を伴って呼出された際に，代わりに ECMAScript 大域~objがその `this^v 値に利用されることになる。
これは，~callする~codeが strict mode 下にあるかどうかには依らない。
◎
If the [ImplicitThis] extended attribute appears on an interface, it indicates that when a Function corresponding to one of the interface’s operations is invoked with the null or undefined value as the this value, that the ECMAScript global object will be used as the this value instead. This is regardless of whether the calling code is in strict mode.
</p>

<p>
`ImplicitThis$x 拡張属性には、`引数をとらない$ことが~REQUIRED。
◎
The [ImplicitThis] extended attribute MUST take no arguments.
</p>

<p>
`ImplicitThis$x の利用に課される固有の要件については
`es-operations$sec
に。
◎
See section 4.6.8 for the specific requirements that the use of [ImplicitThis] entails.
</p>

<div class="note"><p>
`ImplicitThis$x `拡張属性$は
HTML5 （ `HTML5$r, 5.2 節）にて定義されるように，
`Window^T `~ifc$上での利用が意図されている。
◎
The [ImplicitThis] extended attribute is intended for use on the Window interface as defined in HTML5 ([HTML5], section 5.2).
</p></div>

<div class="example">
<p>
次の例では、 `Window^T `~ifc$が `ImplicitThis$x `拡張属性$を伴って定義される。
◎
In the following example, the Window interface is defined with the [ImplicitThis] extended attribute.
</p>

<pre class="idl-code">
[ImplicitThis]
interface Window {
  ...
  attribute DOMString name;
  void alert(DOMString message);
};
</pre>

<p>
`Window^T ~objは ECMAScript 大域~objとして利用されるので、明示的な~objがなくても, strict mode 下にあっても，その関数を~callできる：
◎
Since the Window object is used as the ECMAScript global object, calls to its functions can be made without an explicit object, even in strict mode:
</p>

<pre class="es-code">
"use strict";

window.alert("hello");      // <span title="Calling alert with an explicit window object works."
>`Window^T ~objを明示的に与えて alert を~call。</span>
alert("hello");             // <span title="This also works, even though we are in strict mode."
>これも機能する。 strict mode 下にあっても。</span>
alert.call(null, "hello");  // <span title="As does passing null explicitly as the this value."
>`this^v 値に明示的に `null^v を渡しても同様。</span>

// <span title="This does not apply to getters for attributes on the interface, though."
>しかしながら，~ifc上の属性に対する取得子には適用されない：</span>
// <span title="The following will throw a TypeError."
>次は `TypeError^t を投出する。</span>
Object.getOwnPropertyDescriptor(Window.prototype, "name").get.call(null);
</pre>
</div>

			</section>
			<section id="Global">
<h4 title="[Global] and [PrimaryGlobal]">4.3.6. `Global^x と `PrimaryGlobal^x</h4>

<p>
［
`Global$x ／
<dfn id="PrimaryGlobal">`PrimaryGlobal^x</dfn>
］`拡張属性$が `~ifc$上に現れた場合、その~ifcを実装している~objは
ECMAScript 環境にて大域~objとして利用できることを指示する。
また、原型鎖の構造, および［
`~ifc~mb$に対応する~propが原型~obj上にどのように反映されるか
］についても、他の~ifcと異なるものにされることを指示する。
より明確には：
◎
If the [Global] or [PrimaryGlobal] extended attribute appears on an interface, it indicates that objects implementing this interface can be used as the global object in an ECMAScript environment, and that the structure of the prototype chain and how properties corresponding to interface members will be reflected on the prototype objects will be different from other interfaces. Specifically:
</p>

<ol>
	<li>
どの`有名~prop$も，~obj自身ではなく,
原型鎖の中の~obj
— `有名~prop~obj$ —
上にて公開されることになる。
◎
Any named properties will be exposed on an object in the prototype chain – the named properties object – rather than on the object itself.
</li>

	<li>
`~ifc$のどの`広義~帰結~ifc$のどの`~ifc~mb$も、`~ifc原型~obj$上ではなく, ~obj自身の~propに対応することになる。
◎
Interface members from the interface (or consequential interfaces) will correspond to properties on the object itself rather than on interface prototype objects.
</li>

</ol>

<div class="note">
<p>
原型鎖の中の~obj上に置かれる有名~propは、変数~宣言とそのままの名前の代入を通して，大域~obj自身の~propにより隠蔽される。
◎
Placing named properties on an object in the prototype chain is done so that variable declarations and bareword assignments will shadow the named property with a property on the global object itself.
</p>

<p>
~ifc~mbに対応する~propを~obj自身の上に置くことは、次の様な，特色機能を検出するためによく利用される手法が機能することになることを意味する：
<!-- 機能しない？ -->
◎
Placing properties corresponding to interface members on the object itself will mean that common feature detection methods like the following will work:
</p>

<pre class="es-code">
var indexedDB = window.indexedDB || window.webkitIndexedDB ||
                window.mozIndexedDB || window.msIndexedDB;

var requestAnimationFrame = window.requestAnimationFrame ||
                            window.mozRequestAnimationFrame || ...;
</pre>

<p>
ECMAScript における変数~宣言が取扱われる仕方から，代入が評価される前に隠蔽する変数~propが作成されることになるので、上の~codeでは，
`window.indexedDB^c
と
`window.requestAnimationFrame^c
が `undefined^c に評価されることになる。
◎
Because of the way variable declarations are handled in ECMAScript, the code above would result in the window.indexedDB and window.requestAnimationFrame evaluating to undefined, as the shadowing variable property would already have been created before the assignment is evaluated.
</p>
</div>

<p>
`Global$x ／ `PrimaryGlobal$x
`拡張属性$が利用された`~ifc$に対しては：
◎
If the [Global] or [PrimaryGlobal] extended attributes is used on an interface, then:
</p>


<ul>
	<li>
`有名~prop設定子$が定義されては~MUST_NOT。
◎
The interface MUST NOT define a named property setter.
</li>

	<li>
自身およびその`被継承~ifc$は，
`OverrideBuiltins$x 拡張属性が伴われて宣言されては~MUST_NOT。
◎
The interface MUST NOT also be declared with the [OverrideBuiltins] extended attribute.
◎
The interface MUST NOT inherit from another interface with the [OverrideBuiltins] extended attribute.
</li>

	<li>
他の~ifcが`継承-$しては~MUST_NOT。
◎
Any other interface MUST NOT inherit from it.
</li>

</ul>


<p><!-- copy* -->
`Global$x ／ `PrimaryGlobal$x が`部分的~ifc定義$上に指定される場合、その部分的~ifc定義は，~ifc定義の中で`有名~prop取得子$を定義する部分をなすもので~MUST。
◎
If [Global] or [PrimaryGlobal] is specified on a partial interface definition, then that partial interface definition MUST be the part of the interface definition that defines the named property getter.
</p>

<p>
`Global$x ／ `PrimaryGlobal$x
`拡張属性$は、同じ ECMAScript 大域環境において，複数の~objから実装され得るような`~ifc$上に利用されては~MUST_NOT。
◎
The [Global] and [PrimaryGlobal] extended attribute MUST NOT be used on an interface that can have more than one object implementing it in the same ECMAScript global environment.
</p>

<div class="note"><p>
これは、有名~propを公開する`有名~prop~obj$が 原型鎖の中にあるものであり、複数の［~objの有名~prop］を，それらの~objを継承する１個の~obj上で公開することに意味が無いからである。
◎
This is because the named properties object, which exposes the named properties, is in the prototype chain, and it would not make sense for more than one object’s named properties to be exposed on an object that all of those objects inherit from.
</p></div>

<p>
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴って宣言された~ifcにおいては、そのどの２つの`広義~帰結~ifc$の間でも，`識別子$が同じになる`~ifc~mb$が存在しては~MUST_NOT。
また、それらの~ifcに渡って，［
複数の`文字列化子$ ／
複数の`直列化子$ ／
複数の［
`可反復~宣言$, `~maplike 宣言$, `~setlike 宣言$
<span class="trans-note">【混在も含む】</span>
］］が存在しては~MUST_NOT。
◎
If an interface is declared with the [Global] or [PrimaryGlobal] extended attribute, then there MUST NOT be more than one interface member across the interface and its consequential interfaces with the same identifier. There also MUST NOT be more than one stringifier, more than one serializer, or more than one iterable declaration, maplike declaration or setlike declaration across those interfaces.
</p>

<div class="note"><p>
その理由は、~ifcとその帰結~ifcの~mbすべてが、~ifcを実装する~objに平坦化されるからである。
◎
This is because all of the members of the interface and its consequential interfaces get flattened down on to the object that implements the interface.
</p></div>


<p>
`Global$x ／ `PrimaryGlobal$x 拡張属性は， 1 個~以上の大域~ifcに同じ名前を付けて、その名前を通して `Exposed$x 拡張属性から参照する目的にも利用できる。
◎
The [Global] and [PrimaryGlobal] extended attributes can also be used to give a name to one or more global interfaces, which can then be referenced by the [Exposed] extended attribute.
</p>

<p>
`Global$x ／ `PrimaryGlobal$x 拡張属性には、［
`引数をとらない$
か, または
`識別子~listを引数にとる$
］ことが~REQUIRED。
◎
The [Global] and [PrimaryGlobal] extended attributes MUST either take no arguments or take an identifier list.
</p>

<p>
`Global$x ／ `PrimaryGlobal$x
`拡張属性$が宣言されている~ifcは， 1 個~以上の
`大域~名@
を持つ：
拡張属性が 識別子~listを引数に伴うならば，それらの識別子が~ifcの大域~名になり、他の場合，~ifc自身の識別子が~ifcの~~唯一の大域~名になる。
◎
If the [Global] or [PrimaryGlobal] extended attribute is declared with an identifier list argument, then those identifiers are the interface’s global names; otherwise, the interface has a single global name, which is the interface's identifier.
</p>

<div class="note"><p>
識別子~list引数は、 `Exposed$x `拡張属性$の中の単独の名前で，複数の大域~ifcを指せるようにするためにある。
◎
The identifier argument list exists so that more than one global interface can be addressed with a single name in an [Exposed] extended attribute.
</p></div>

<p>
`Global$x, `PrimaryGlobal$x の両`拡張属性$が，同じ~ifc上に宣言されては~MUST_NOT。
`PrimaryGlobal$x 拡張属性が宣言される~ifcは<!-- ある大域環境において実装が~supportする~ifcの集合の中で -->，高々 1 個で~MUST。
`PrimaryGlobal$x が宣言された~ifcは、
`主~大域~ifc@
と呼ばれる。
◎
The [Global] and [PrimaryGlobal] extended attributes MUST NOT be declared on the same interface. The [PrimaryGlobal] extended attribute MUST be declared on at most one interface. The interface [PrimaryGlobal] is declared on, if any, is known as the primary global interface.
</p>


<p>
有名~propにおける
`Global$x ／ `PrimaryGlobal$x
の利用に課される固有の要件については
`named-properties-object$sec,
`getownproperty$sec,
`defineownproperty$sec
に。
`~ifc~mb$に対応する~propの所在に関する要件については
`es-constants$sec,
`es-attributes$sec,
`es-operations$sec
に。
◎
See section 4.6.5, section 4.8.3 and section 4.8.7 for the specific requirements that the use of [Global] and [PrimaryGlobal] entails for named properties, and section 4.6.6, section 4.6.7 and section 4.6.8 for the requirements relating to the location of properties corresponding to interface members.
</p>

<div class="example">
<p>
`PrimaryGlobal$x は、
HTML5 （ `HTML5$r, 5.2 節） で定義されるように，
`Window^T ~ifcからの利用が意図されている。
（ `Global$x は，~worker大域~ifcからの利用が意図されている。）
`Window^T ~ifcは frame を `Window^T ~obj上の~propとして公開する。
`Window^T ~objは ECMAScript 大域~objとしても機能するので、有名~propに対する代入や変数~宣言は、新たな値への置換-になる。
属性に対する変数~宣言は、既存のものを置換する~propを作成しない。
◎
The [PrimaryGlobal] extended attribute is intended to be used by the Window interface as defined in HTML5 ([HTML5], section 5.2). ([Global] is intended to be used by worker global interfaces.) The Window interface exposes frames as properties on the Window object. Since the Window object also serves as the ECMAScript global object, variable declarations or assignments to the named properties will result in them being replaced by the new value. Variable declarations for attributes will not create a property that replaces the existing one.
</p>

<pre class="idl-code">
[PrimaryGlobal]
interface Window {
  getter any (DOMString name);
  attribute DOMString name; 
   ...
};
</pre>

<p>
次の HTML 文書では、
`Window^T ~obj上の有名~propが隠蔽され,
属性に対する~propは同じ名前の変数が宣言されても置換されない：
◎
The following HTML document illustrates how the named properties on the Window object can be shadowed, and how the property for an attribute will not be replaced when declaring a variable of the same name:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;title&gt;<span
	title="Variable declarations and assignments on Window"
	>Window 上の変数~宣言と代入</span>&lt;/title&gt;
&lt;iframe name=abc&gt;&lt;/iframe&gt;
&lt;!-- <span title="Shadowing named properties">有名~propを隠蔽する</span> --&gt;
&lt;script&gt;
  window.abc;    // <span title="Evaluates to the iframe's Window object."
>`iframe^c の `Window^T ~objに評価される。</span>
  abc = 1;       // <span title="Shadows the named property."
>有名~propを隠蔽する。</span>
  window.abc;    // <!--cp-eval-1-->
&lt;/script&gt;

&lt;!-- <span title="Preserving properties for IDL attributes">IDL 属性に対する~propは保全される</span> --&gt;
&lt;script&gt;
  Window.prototype.def = 2;         // <span title="Places a property on the prototype."
>原型~上に~propを置く。</span>
  window.hasOwnProperty("length");  // <!--cp-eval-true-->

  length;        // <!--cp-eval-1-->
  def;           // <span title="Evaluates to 2."
>`2^v に評価される。</span>
&lt;/script&gt;

&lt;script&gt;
  var length;    // <span title="Variable declaration leaves existing property."
>この変数~宣言は既存の~propに触らない。</span>
  length;        // <!--cp-eval-1-->
  var def;       // <span title="Variable declaration creates shadowing property."
>この変数~宣言は隠蔽する~propを作成する。</span>
  def;           // <!--cp-eval-undefined-->
&lt;/script&gt;
</pre>

</div>

			</section>
			<section id="LegacyArrayClass" class="L2">
<h4>4.3.7. `LegacyArrayClass^x</h4>

<p>
`LegacyArrayClass$x `拡張属性$が［
他を`継承-$しないように定義された`~ifc$
］上に現れた場合、その`~ifc原型~obj$の `Prototype^es 内的~propは，
`Object^t 原型~objではなく,
`Array^t 原型~objになる。
これにより、その~ifcを実装している~objにおいて，
`Array^t ~methを容易く利用できるようになる。
◎
If the [LegacyArrayClass] extended attribute appears on an interface that is not defined to inherit from another, it indicates that the internal [[Prototype]] property of its interface prototype object will be the Array prototype object rather than the Object prototype object. This allows Array methods to be used more easily with objects implementing the interface.
</p>

<div class="p">
<p>
`LegacyArrayClass$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
</li>
	<li>
`被継承~ifc$を持つ~ifcに利用されては~MUST_NOT：
</li>
</ul>

◎
The [LegacyArrayClass] extended attribute MUST take no arguments. It MUST NOT be used on an interface that has any inherited interfaces.
</div>


<div class="note"><p>
`LegacyArrayClass$x を利用する~ifcには、継承される `Array^t ~methが正しく演算するように、配列に類似するような，~objの長さを公開する［
型 `unsigned long^t の `length^l `属性$
］を定義する必要がある。
そのような~ifcは、概して，配列~要素への~accessを提供する`有index~propを~supportする$ことになるであろう。
◎
Interfaces using [LegacyArrayClass] will need to define a “length” attribute of type unsigned long that exposes the length of the array-like object, in order for the inherited Array methods to operate correctly. Such interfaces would typically also support indexed properties, which would provide access to the array elements.
</p></div>

<p>
`LegacyArrayClass$x の利用に課される固有の要件については
`interface-prototype-object$sec
に。
◎
See section 4.6.4 for the specific requirements that the use of [LegacyArrayClass] entails.
</p>

<div class="example">

<p>
次の `IDL 片$は、 `LegacyArrayClass$x を利用する２つの`~ifc$を定義する。
◎
The following IDL fragment defines two interfaces that use [LegacyArrayClass].
</p>

<pre class="idl-code">
[LegacyArrayClass]
interface ItemList {
  attribute unsigned long length;
  getter object getItem(unsigned long index);
  setter object setItem(unsigned long index, object item);
};

[LegacyArrayClass]
interface ImmutableItemList {
  readonly attribute unsigned long length;
  getter object getItem(unsigned long index);
};
</pre>

<p>
上の２つの~ifcの
`getItem^c, `setItem^c, `removeItem^c
の適切な定義を伴う
ECMAScript 実装においては、配列に類似する~objを検分したり改変するための `Array^t ~methを利用できる：
◎
In an ECMAScript implementation of the above two interfaces, with appropriate definitions for getItem, setItem and removeItem, Array methods to inspect and modify the array-like object can be used.
</p>

<pre class="es-code">
var list = getItemList();  // <span title="Obtain an instance of ItemList."
>`ItemList^T の~instanceを得る。</span>

list.concat();             // <span title="Clone the ItemList into an Array."
>%list を `Array^t の中に~cloneする。</span>
list.pop();                // <span title="Remove an item from the ItemList."
>%list から項目を除去する。</span>
list.unshift({ });         // <span title="Insert an item at index 0."
>項目を~index 0 の位置に挿入する。</span>
</pre>

<p>
`ImmutableItemList^T は、読専の `length^c `属性$を持ち，
`有index~prop設定子$を持たない。
`ImmutableItemList^T を実装する~obj上では、一般に `Array^t を改変する~methは失敗することになる。
正確な挙動は
<a href="~ES6#sec-properties-of-the-array-prototype-object">`Array^t ~meth自身</a>
の定義に依存する
（ `ECMA-262$r 22.1.3 節） 。
◎
ImmutableItemList has a read only length attribute and no indexed property setter. The mutating Array methods will generally not succeed on objects implementing ImmutableItemList. The exact behavior depends on the definition of the Array methods themselves ([ECMA-262], section 22.1.3).
</p>

</div>

			</section>
			<section id="LegacyUnenumerableNamedProperties" class="L2">
<h4>4.3.8. `LegacyUnenumerableNamedProperties^x</h4>

<p id="dfn-unenumerable"><!--＊-->
`LegacyUnenumerableNamedProperties$x `拡張属性$が［
`有名~propを~supportする$`~ifc$
］に現れた場合、その~ifc上の すべての有名~propは，列挙不可であることを指示する。
◎
If the [LegacyUnenumerableNamedProperties] extended attribute appears on a interface that supports named properties, it indicates that all the interface's named properties are unenumerable.
</p>

<div class="p">
<p>
`LegacyUnenumerableNamedProperties$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
</li>
	<li>
`有名~prop取得子$を定義しない~ifc上に現れては~MUST_NOT。
</li>
	<li>
当の~ifcのすべての派生~ifcにも適用され、それらには，この拡張属性は指定されては~MUST_NOT。
</li>

</ul>
◎
The [LegacyUnenumerableNamedProperties] extended attribute MUST take no arguments and MUST NOT appear on an interface that does not define a named property getter.
◎
If the [LegacyUnenumerableNamedProperties] extended attribute is specified on an interface, then it applies to all its derived interfaces and MUST NOT be specified on any of them.
</div>

<p>
`LegacyUnenumerableNamedProperties$x の利用に課される固有の要件については、`property-enumeration$secに。
◎
See section 4.8.10 for the specific requirements that the use of [LegacyUnenumerableNamedProperties] entails.
</p>


			</section>
			<section id="LenientThis">
<h4>4.3.9. `LenientThis^x</h4>

<p>
`LenientThis$x `拡張属性$が `正則~属性$上に現れた場合、その属性が現れる`~ifc$を実装する~objとは異なる `this^v 値を伴うような，その属性の取得子や設定子の呼出は、無視されることになる。
◎
If the [LenientThis] extended attribute appears on a regular attribute, it indicates that invocations of the attribute’s getter or setter with a this value that is not an object that implements the interface on which the attribute appears will be ignored.
</p>

<div class="p">
<p>
`LenientThis$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
</li>
	<li>
`静的~属性$上に利用されては~MUST_NOT。
</li>
</ul>
◎
The [LenientThis] extended attribute MUST take no arguments. It MUST NOT be used on a static attribute.
</div>


<div class="warning">

<p><!-- copy* -->
互換性の理由から要求されない限り、仕様は `LenientThis$x を利用する~SHOULD_NOT。
この特色機能`論ML^。
◎
Specifications SHOULD NOT use [LenientThis] unless required for compatibility reasons. Specification authors who wish to use this feature are strongly advised to discuss this on the public-script-coord@w3.org mailing list before proceeding.
</p>
</div>

<p>
`LenientThis$x がどう実装されるかについては、下の
<a href="#es-attributes">属性</a>
の節に。
◎
See the Attributes section below for how [LenientThis] is to be implemented.
</p>

<div class="example">
<p>
次の IDL 片は
`LenientThis$x 拡張属性を利用する
~ifcを定義する。
◎
The following IDL fragment defines an interface that uses the [LenientThis] extended attribute.
</p>

<pre class="idl-code">
interface Example {
  [LenientThis] attribute DOMString x;
  attribute DOMString y;
};
</pre>

<p>
この~ifcを~supportする ECMAScript 実装では、
x に対応する~accessor~propの取得子／設定子では，
`Example^T ~obj以外の何かを伴う呼出しも許容されることになる。
◎
An ECMAScript implementation that supports this interface will allow the getter and setter of the accessor property that corresponds to x to be invoked with something other than an Example object.
</p>

<pre class="es-code">
var example = getExample();  // <span title="Get an instance of Example."
>`Example^T の~instanceを取得する。</span>
var obj = { };

/* <span title="Fine."
>~~通常。</span> */
example.x;

/* <span title="Ignored, since the this value is not an Example object and [LenientThis] is used."
>この値は `Example^T ~objでなく, かつ
   `LenientThis^x が利用されているので、無視される。</span> */
Object.getOwnPropertyDescriptor(Example.prototype, "x").get.call(obj);

/* <span title="Also ignored, since Example.prototype is not an Example object and [LenientThis] is used."
>`Example.prototype^v は `Example^T ~objでなく, かつ
   `LenientThis^x が利用されているので、これも無視される。</span> */
Example.prototype.x;

/* <span title="Throws a TypeError, since Example.prototype is not an Example object."
>`Example.prototype^v は `Example^T ~objでないので `TypeError^t が投出される。</span> */
Example.prototype.y;
</pre>
</div>
			</section>
			<section id="NamedConstructor">
<h4>4.3.10. `NamedConstructor^x</h4>


<div class="p">

<p>
`NamedConstructor$x `拡張属性$が `~ifc$上に現れた場合、 ECMAScript 大域~objは，次を伴う~propを持つことになる：
</p>

<ul>
	<li>
その名前は、拡張属性の引数に指定された名前。
</li>
	<li>
値は、その~ifcを実装する~objを作成できる構築子~関数。
</li>
</ul>

<p>
所与の~ifc上に，複数の `NamedConstructor$x 拡張属性が現れてもよい。
</p>
◎
If the [NamedConstructor] extended attribute appears on an interface, it indicates that the ECMAScript global object will have a property with the specified name whose value is a constructor function that can create objects that implement the interface. Multiple [NamedConstructor] extended attributes may appear on a given interface.
</div>


<p>
`NamedConstructor$x 拡張属性は：
</p>

<ul>
	<li>
`識別子を引数にとる$か, または`有名~引数~listを引数にとる$ことが~REQUIRED。
前者の形
<code>[NamedConstructor=`identifier$g]</code>
は、空の引数~list
<code>[NamedConstructor=`identifier$g()]</code>
を利用するのと同じ意味になる。
~ifc上の各 `NamedConstructor$x 拡張属性が、［［
前述の~propの値である構築子~関数
］に，指定された引数を渡して、その~ifcを実装する~objを構築する仕方
］を供することになる。
◎
The [NamedConstructor] extended attribute MUST either take an identifier or take a named argument list. The first form, [NamedConstructor=identifier], has the same meaning as using an empty argument list, [NamedConstructor=identifier()]. For each [NamedConstructor] extended attribute on the interface, there will be a way to construct an object that implements the interface by passing the specified arguments to the constructor function that is the value of the aforementioned property.
</li>
	<li>
<p>
次に挙げる識別子が、有名~構築子の識別子として利用されては~MUST_NOT：
</p>

		<ul>
			<li>
別の~ifc上の `NamedConstructor$x 拡張属性の識別子,
</li>
			<li>
`~ifc~obj$を持つ~ifcの識別子,
</li>
			<li>
`予約済み識別子$。
</li>
		</ul>

◎
The identifier used for the named constructor MUST NOT be the same as that used by an [NamedConstructor] extended attribute on another interface, MUST NOT be the same as an identifier of an interface that has an interface object, and MUST NOT be one of the reserved identifiers.
</li>
	<li>
`呼戻~ifc$上に利用されては~MUST_NOT。
◎
The [NamedConstructor] extended attribute MUST NOT be used on a callback interface.
</li>
</ul>

<p>
有名~構築子がどう実装されるかの詳細は
`named-constructors$sec
に。
◎
See section 4.6.2 below for details on how named constructors are to be implemented.
</p>


<div class="example">
<p>
次の IDL は
`NamedConstructor$x 拡張属性を利用する~ifcを定義する。
◎
The following IDL defines an interface that uses the [NamedConstructor] extended attribute.
</p>

<pre class="idl-code">
[NamedConstructor=Audio,
 NamedConstructor=Audio(DOMString src)]
interface HTMLAudioElement : HTMLMediaElement {
  // <span>...</span>
};
</pre>

<p>
この~ifcを~supportする ECMAScript 実装は、
`Audio^T 構築子を利用する `HTMLAudioElement^T ~objの構築を許容することになる。
◎
An ECMAScript implementation that supports this interface will allow the construction of HTMLAudioElement objects using the Audio constructor.
</p>

<pre class="es-code">
typeof Audio;                   // <!--cp-eval-function-->

var a1 = new Audio();
   /* <span title="Creates a new object that implements
HTMLAudioElement, using the zero-argument
constructor."
>引数なしの構築子を利用して，
   `HTMLAudioElement^T を実装する ~objを作成する。</span> */

var a2 = new Audio('a.flac');
   /* <span title="Creates an HTMLAudioElement using the
one-argument constructor."
>１引数の構築子を利用して， `HTMLAudioElement^T を作成する。</span> */
</pre>
</div>


			</section>
			<section id="NewObject" class="v2">
<h4>4.3.11. `NewObject^x</h4>

<p>
`NewObject$x `拡張属性$が［
`正則~演算$／`静的~演算$
］上に現れた場合、その演算が~callされる際に，常に
新たに作成された~objへの参照が返され~MUSTことを指示する。
◎
If the [NewObject] extended attribute appears on a regular or static operation, then it indicates that when calling the operation, a reference to a newly created object MUST always be returned.
</p>

<p>
`NewObject$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
◎
The [NewObject] extended attribute MUST take no arguments.
</li>
	<li>
`返値型$が［
`~ifc型$, または `~promise型$
］である［
`正則~演算$／`静的~演算$
］以外の所に利用されては~MUST_NOT。
◎
The [NewObject] extended attribute MUST NOT be used on anything other than a regular or static operation whose return type is an interface type or a promise type.
</li>
</ul>

<div class="example">
<p>
この拡張属性の利用が適する一例には，
<a href="https://dom.spec.whatwg.org/#document">`Document^T</a>
~ifc（ `DOM$r, 6.5 節）上の
<a href="https://dom.spec.whatwg.org/#dom-document-createelement">createElement</a>
演算がある。
これは，~callされる度に新たな~objが返されるべきなので。
◎
As an example, this extended attribute is suitable for use on the createElement operation on the Document interface ([DOM], section 6.5), since a new object should always be returned when it is called.
</p>

<pre class="idl-code">
interface Document : Node {
  [NewObject] Element createElement(DOMString localName);
  ...
};
</pre>

</div>

			</section>
			<section id="NoInterfaceObject">
<h4>4.3.12. `NoInterfaceObject^x</h4>


<p>
`NoInterfaceObject$x `拡張属性$が `~ifc$上に現れた場合、その~ifcに対応する`~ifc~obj$は， ECMAScript 言語束縛には存在しないことになる。
◎
If the [NoInterfaceObject] extended attribute appears on an interface, it indicates that an interface object will not exist for the interface in the ECMAScript binding.
</p>


<div class="warning">
<p>
`NoInterfaceObject$x 拡張属性は、明白な Web 互換性の理由がない限り，もっぱら`追補~ifc$として利用されるもの以外の~ifcには、利用される~SHOULD_NOT。
この特色機能`論ML^。
◎
The [NoInterfaceObject] extended attribute SHOULD NOT be used on interfaces that are not solely used as supplemental interfaces, unless there are clear Web compatibility reasons for doing so. Specification authors who wish to use this feature are strongly advised to discuss this on the public-script-coord@w3.org mailing list before proceeding.
</p>
</div>

<p>
`NoInterfaceObject$x 拡張属性は：
</p>

<ul>
	<li>
`NoInterfaceObject$x 拡張属性には、`引数をとらない$ことが~REQUIRED。
◎
The [NoInterfaceObject] extended attribute MUST take no arguments.
</li>
	<li>
同じ~ifc上で， `Constructor$x 拡張属性と併用されては~MUST_NOT。
一方， `NamedConstructor$x 拡張属性との併用は差し支えない。
◎
If the [NoInterfaceObject] extended attribute is specified on an interface, then the [Constructor] extended attribute MUST NOT also be specified on that interface. A [NamedConstructor] extended attribute is fine, however.
</li>

	<li>
`静的~演算$が定義されている~ifc上に指定されては~MUST_NOT。
◎
The [NoInterfaceObject] extended attribute MUST NOT be specified on an interface that has any static operations defined on it.
</li>

	<li>
`定数$が宣言されてる場合を除き，`呼戻~ifc$上に指定されては~MUST_NOT。
`定数$を伴わない呼戻~ifcは，`~ifc~obj$を決して持たないので。
◎
The [NoInterfaceObject] extended attribute MUST NOT be specified on a callback interface unless it has a constant declared on it. This is because callback interfaces without constants never have interface objects.
</li>

	<li>
この拡張属性が指定されていない~ifcが，この拡張属性が指定されている~ifcを継承しては~MUST_NOT
◎
An interface that does not have the [NoInterfaceObject] extended attribute specified MUST NOT inherit from an interface that has the [NoInterfaceObject] extended attribute specified.
</li>

</ul>


<p>
`NoInterfaceObject$x の利用に課される固有の要件については、`es-interface$secに。
◎
See section 4.2.20 for the specific requirements that the use of [NoInterfaceObject] entails.
</p>

<div class="example">
<p>
次の `IDL 片$は２つの~ifcを定義する。
１つはその~ifc~objが ECMAScript 大域~obj上に公開され，もう１つはそうでない：
◎
The following IDL fragment defines two interfaces, one whose interface object is exposed on the ECMAScript global object, and one whose isn’t:
</p>

<pre class="idl-code">
interface Storage {
  void addEntry(unsigned long key, any value);
};

[NoInterfaceObject]
interface Query {
  any lookupEntry(unsigned long key);
};
</pre>

<p>
上の IDL の ECMAScript 実装においては、
`Storage^T に対する原型の操作は許容される一方，
`Query^T に対してはそうならない。
◎
An ECMAScript implementation of the above IDL would allow manipulation of Storage’s prototype, but not Query’s.
</p>

<pre class="es-code">
typeof Storage;                        // <span title="evaluates to &quot;object&quot;"
>`object^l に評価される。</span>

// <span title="Add some tracing alert() call to Storage.addEntry."
>`Storage.addEntry^c に~trace用の `alert()^c ~callを追加する</span>
var fn = Storage.prototype.addEntry;
Storage.prototype.addEntry = function(key, value) {
  alert('Calling addEntry()');
  return fn.call(this, key, value);
};

typeof Query;                          // <span title="evaluates to &quot;undefined&quot;"
>`undefined^l に評価される。</span>
var fn = Query.prototype.lookupEntry;  // <span title="exception, Query isn’t defined"
>例外を投出。 `Query^T は定義されていない。</span>
</pre>
</div>
			</section>
			<section id="OverrideBuiltins">
<h4>4.3.13. `OverrideBuiltins^x</h4>


<p>
`OverrideBuiltins$x `拡張属性$が `~ifc$上に現れた場合，その~ifcを実装する`~platform~obj$においては、［
その~objやその原型鎖
］上に存在する他の~propに関わらず，~objの`被support~prop名$すべてに対し，それぞれに対応する~propがその~obj上に現れることになる。
このことは、（通例の挙動では、有名~propは［
~obj自身やその原型鎖
］上のどこにも同じ名前の~propが存在しないときに限り，公開されるのに対し、）有名~propが、［
さもなければ~obj上に現れることになる，同じ名前のどの~prop
］も，常に隠蔽することになることを意味する。
◎
If the [OverrideBuiltins] extended attribute appears on an interface, it indicates that for a platform object implementing the interface, properties corresponding to all of the object’s supported property names will appear to be on the object, regardless of what other properties exist on the object or its prototype chain. This means that named properties will always shadow any properties that would otherwise appear on the object. This is in contrast to the usual behavior, which is for named properties to be exposed only if there is no property with the same name on the object itself or somewhere on its prototype chain.
</p>

<div class="p">
<p>
`OverrideBuiltins$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
</li>
	<li>
`有名~prop取得子$を定義しない~ifc上に現れては~MUST_NOT。
</li>
	<li>
`Global$x ／ `PrimaryGlobal$x
拡張属性と併用されては~MUST_NOT。
</li>
	<li>
`部分的~ifc定義$上に指定される場合、その部分的~ifc定義は，~ifc定義の中で`有名~prop取得子$を定義する部分をなすもので~MUST。
</li>

</ul>

◎
The [OverrideBuiltins] extended attribute MUST take no arguments and MUST NOT appear on an interface that does not define a named property getter or that also is declared with the [Global] or [PrimaryGlobal] extended attribute. If the extended attribute is specified on a partial interface definition, then that partial interface definition MUST be the part of the interface definition that defines the named property getter.
</div>

<p>
`OverrideBuiltins$x の利用に課される固有の要件については
`indexed-and-named-properties$sec, `defineownproperty$sec
に。
◎
See section 4.8.1 and section 4.8.7 for the specific requirements that the use of [OverrideBuiltins] entails. 
</p>

<div class="example">
<p>
次の `IDL 片$は２つの`~ifc$を定義する。
一方は`有名~prop取得子$を持ち, 他方はそうでない：
◎
The following IDL fragment defines two interfaces, one that has a named property getter and one that does not.
</p>

<pre class="idl-code">
interface StringMap {
  readonly attribute unsigned long length;
  getter DOMString lookup(DOMString key);
};

[OverrideBuiltins]
interface StringMap2 {
  readonly attribute unsigned long length;
  getter DOMString lookup(DOMString key);
};
</pre>

<p>
これら２つの~ifcの ECMAScript 実装においては、それぞれの~ifcを実装する~obj上の一部の~propについて，その取得による結果が異なってくることになる：
◎
In an ECMAScript implementation of these two interfaces, getting certain properties on objects implementing the interfaces will result in different values:
</p>

<pre class="es-code">
/* <span title="Obtain an instance of StringMap.  Assume that it has &quot;abc&quot;, &quot;length&quot; and
&quot;toString&quot; as supported property names."
>`StringMap^T の~instanceを得る。被support~prop名
   として， `abc^l, `length^l, `toString^l を持つとする。</span> */
var map1 = getStringMap();

/* <span title="This invokes the named property getter."
>有名~prop取得子を呼出す。</span> */
map1.abc;

/* <span title="This fetches the &quot;length&quot; property on the object that corresponds to the
length attribute."
>`length^M 属性に対応する~obj上の `length^l ~propを取りに行く。</span> */
map1.length;

/* <span title="This fetches the &quot;toString&quot; property from the object's prototype chain."
>~objの原型鎖~上の `toString^l ~propを取りに行く。</span> */
map1.toString;


/* <span title="Obtain an instance of StringMap2.  Assume that it also has &quot;abc&quot;, &quot;length&quot;
and &quot;toString&quot; as supported property names."
>`StringMap2^T の~instanceを得る。これも被support~prop名
   として， `abc^l, `length^l, `toString^l を持つとする。</span> */
var map2 = getStringMap2();  

/* <span title="This invokes the named property getter."
>これは 有名~prop取得子を呼出す。</span> */
map2.abc;

/* <span title="This also invokes the named property getter, despite the fact that the &quot;length&quot;
property on the object corresponds to the length attribute."
>これも 有名~prop取得子を呼出す。~obj上の
   `length^l ~propが length 属性に対応しているにも関わらず。</span> */
map2.length;

/* <span title="This too invokes the named property getter, despite the fact that &quot;toString&quot; is
a property in map2's prototype chain."
>これもまた 有名~prop取得子を呼出す。 `toString^l が
   %map2 の prototype chain 内にある~propであるにも関わらず。</span> */
map2.toString;
</pre>
</div>
			</section>

<!-- 
section id='PrototypeRoot'
	<h4>PrototypeRoot</h4>
...
...
-->

			<section id="PutForwards">
<h4>4.3.14. `PutForwards^x</h4>


<p>
`PutForwards$x `拡張属性$が［
`~ifc型$の`読専$の`正則~属性$宣言
］上に現れた場合、その属性への代入ingは 固有の挙動を持つことになる。
すなわち，その代入は、代入-が試みられた属性から，現在~参照されている~objの属性（その拡張属性の引数で指定される）に “転送-” される。
◎
If the [PutForwards] extended attribute appears on a read only regular attribute declaration whose type is an interface type, it indicates that assigning to the attribute will have specific behavior. Namely, the assignment is “forwarded” to the attribute (specified by the extended attribute argument) on the object that is currently referenced by the attribute being assigned to.
</p>

<p>
`PutForwards$x 拡張属性には、`識別子を引数にとる$ことが~REQUIRED。
次が与えられるとき：
◎
The [PutForwards] extended attribute MUST take an identifier. Assuming that:
</p>

<ul>
	<li>
%A は
`PutForwards$x 拡張属性が現れる`属性$,
◎
A is the attribute on which the [PutForwards] extended attribute appears,
</li>
	<li>
%I は
%A が宣言されている`~ifc$,
◎
I is the interface on which A is declared,
</li>
	<li>
%J は
%A の型として宣言されている `~ifc型$, <!--  -->
◎
J is the interface type that A is declared to be of, and
</li>
	<li>
%N は
その拡張属性の`識別子$引数,
◎
N is the identifier argument of the extended attribute,
</li>
</ul>

<p>
このとき，`識別子$ %N を持つ別の`属性$ %B が
%J 上に宣言されてい~MUST。
%I を実装している~obj上の属性 %A への値の代入では、代わりに，
%A が参照する~objの属性 %B にその値が代入されることになる。
◎
then there MUST be another attribute B declared on J whose identifier is N. Assignment of a value to the attribute A on an object implementing I will result in that value being assigned to attribute B of the object that A references, instead.
</p>

<p>
`PutForwards$x 注釈付きの`属性$は連鎖し得ることに注意。
すなわち、
`PutForwards$x `拡張属性$を伴う属性は，この拡張属性を持つ他の属性を指すことができる。
ただし、この代入の連鎖が循環しては~MUST_NOT。
代入の連鎖が辿られる際に，１つの`~ifc$上の特定0の属性に複数~回 遭遇するならば、循環が存在する。
◎
Note that [PutForwards]-annotated attributes can be chained. That is, an attribute with the [PutForwards] extended attribute can refer to an attribute that itself has that extended attribute. There MUST NOT exist a cycle in a chain of forwarded assignments. A cycle exists if, when following the chain of forwarded assignments, a particular attribute on an interface is encountered more than once.
</p>

<p>
`PutForwards$x 拡張属性は：
</p>

<ul>
	<li>
同じ属性~上で， `Replaceable$x 拡張属性と併用されては~MUST_NOT。
◎
An attribute with the [PutForwards] extended attribute MUST NOT also be declared with the [Replaceable] extended attribute.
</li>

	<li class="v2">
`読専$でない`属性$~上に利用されては~MUST_NOT。
◎
The [PutForwards] extended attribute MUST NOT be used on an attribute that is not read only.
</li>

	<li class="v2">
`静的~属性$上に利用されては~MUST_NOT。
◎
The [PutForwards] extended attribute MUST NOT be used on a static attribute.
</li>

	<li>
`呼戻~ifc$上で宣言される属性~上に利用されては~MUST_NOT。
◎
The [PutForwards] extended attribute MUST NOT be used on an attribute declared on a callback interface.
</li>

</ul>

<p>
`PutForwards$x がどう実装されるかについては、下の
<a href="#es-attributes">属性</a>
の節に。
◎
See the Attributes section below for how [PutForwards] is to be implemented.
</p>

<div class="example">
<p>
次の `IDL 片$は、姓名と人を表す~ifcを定義する。
`Person^T ~ifcの `name^M 属性~上に利用される `PutForwards$x 拡張属性は、その属性への代入による結果が `Person^T ~objの
<span class="trans-note">【
`name^M 属性が指す `Name^T ~objの
】</span>
`full^M 属性への代入になることを指示する：
◎
The following IDL fragment defines interfaces for names and people. The [PutForwards] extended attribute is used on the name attribute of the Person interface to indicate that assignments to that attribute result in assignments to the full attribute of the Person object:
</p>

<pre class="idl-code">
interface Name {
  attribute DOMString full;
  attribute DOMString family;
  attribute DOMString given;
};

interface Person {
  [PutForwards=full] readonly attribute Name name;
  attribute unsigned short age;
};
</pre>

<p>
ECMAScript 言語束縛においては、
`name^l ~propへの代入が許容されることになる：
◎
In the ECMAScript binding, this would allow assignments to the “name” property:
</p>

<pre class="es-code">
var p = getPerson();           // <span title="Obtain an instance of Person."
>`Person^T の~instanceを得る。</span>

p.name = 'John Citizen';       // <span title="This statement..."
>この文は...</span>
p.name.full = 'John Citizen';  // <span title="...has the same behavior as this one."
>...これと同じ挙動になる。</span>
</pre>
</div>
			</section>
			<section id="Replaceable">
<h4>4.3.15. `Replaceable^x</h4>


<p>
`Replaceable$x `拡張属性$が `読専$の`正則~属性$上に現れた場合、`~platform~obj$上の対応する~propが設定される際に、その~obj上に，代入される値をとる同じ名前の自前の~propが作成されることになる。
この~propは、
`~ifc原型~obj$上に存在する，その属性に対応する~accessor~propを隠蔽する。
◎
If the [Replaceable] extended attribute appears on a read only regular attribute, it indicates that setting the corresponding property on the platform object will result in an own property with the same name being created on the object which has the value being assigned. This property will shadow the accessor property corresponding to the attribute, which exists on the interface prototype object.
</p>

<p>
`Replaceable$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
◎
The [Replaceable] extended attribute MUST take no arguments.
</li>
	<li>
同じ属性~上で， `Replaceable$x 拡張属性と併用されては~MUST_NOT。
◎
An attribute with the [Replaceable] extended attribute MUST NOT also be declared with the [PutForwards] extended attribute.
</li>
	<li class="v2">
`読専$でない`属性$~上に利用されては~MUST_NOT。
◎
The [Replaceable] extended attribute MUST NOT be used on an attribute that is not read only.
</li>

	<li class="v2">
`静的~属性$上に利用されては~MUST_NOT。
◎
The [Replaceable] extended attribute MUST NOT be used on a static attribute.
</li>

	<li>
`呼戻~ifc$上で宣言される属性に利用されては~MUST_NOT。
◎
The [Replaceable] extended attribute MUST NOT be used on an attribute declared on a callback interface.
</li>

</ul>

<p>
`Replaceable$x の利用に課される固有の要件については
`es-attributes$sec
に。
◎
See section 4.6.7 for the specific requirements that the use of [Replaceable] entails.
</p>

<div class="example">
<p>
次の `IDL 片$は、計数を増やす`演算$と，計数~値を公開する初期~値 0 の`属性$を持つ`~ifc$を定義する：
◎
The following IDL fragment defines an interface with an operation that increments a counter, and an attribute that exposes the counter’s value, which is initially 0:
</p>

<pre class="idl-code">
interface Counter {
  [Replaceable] readonly attribute unsigned long value;
  void increment();
};
</pre>

<p>
`Counter^T を実装する `~platform~obj$上の
`value^l ~propへの代入ingにより，その`属性$に対応する~propは隠蔽されることになる：
◎
Assigning to the “value” property on a platform object implementing Counter will shadow the property that corresponds to the attribute:
</p>

<pre class="es-code">
var counter = getCounter();         // <span title="Obtain an instance of Counter."
>`Counter^T の~instanceを得る。</span>
counter.value;                      // <span title="Evaluates to 0."
>`0^v に評価される。</span>

counter.hasOwnProperty("value");    // <!--cp-eval-false-->
Object.getPrototypeOf(counter).hasOwnProperty("value");
                                    // <!--cp-eval-true-->

counter.increment();
counter.increment();
counter.value;                      // <span title="Evaluates to 2."
>`2^v に評価される。</span>

counter.value = 'a';                
       // <span title="Shadows the property with one that is unrelated
to Counter::value."
>`Counter::value^V に関係無いもので~propを隠蔽する。</span>

counter.hasOwnProperty("value");    // <!--cp-eval-true-->

counter.increment();
counter.value;                      // <span title="Evaluates to 'a'."
>`a^l に評価される。</span>

delete counter.value;               // <span title="Reveals the original property."
>元の~propを露にする。</span>
counter.value;                      // <span title="Evaluates to 3."
>`3^v に評価される。</span>
</pre>
</div>

			</section>
			<section id="SameObject" class="v2">
<h4>4.3.16. `SameObject^x</h4>


<p>
`SameObject$x `拡張属性$が `読専$`属性$に現れた場合、所与の~obj上でその属性の値が取得される度に，常に同じ値が返され~MUSTことを指示する。
◎
If the [SameObject] extended attribute appears on a read only attribute, then it indicates that when getting the value of the attribute on a given object, the same value MUST always be returned.
</p>

<p>
`SameObject$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
◎
The [SameObject] extended attribute MUST take no arguments.
</li>
	<li>
［［
`~ifc型$／`~obj型$
］である`読専$`属性$
］以外の所に利用されては~MUST_NOT。
◎
The [SameObject] extended attribute MUST NOT be used on anything other than a read only attribute whose type is an interface type or object.
</li>
</ul>


<div class="example">
<p>
この拡張属性の利用が適する一例には，
<a href="https://dom.spec.whatwg.org/#document">`Document^T</a>
~ifc（ `DOM$r, 6.5 節）上の
<a href="https://dom.spec.whatwg.org/#dom-document-implementation">`implementation^c</a>
属性がある。
所与の `Document^T ~objに対しては，常に同じ~objが返されるので。
◎
As an example, this extended attribute is suitable for use on the implementation attribute on the Document interface ([DOM], section 6.5), since the same object is always returned for a given Document object.
</p>

<pre class="idl-code">
interface Document : Node {
  [SameObject] readonly attribute DOMImplementation implementation;
  ...
};
</pre>
</div>

			</section>
			<section id="SecureContext" class="v2">
<h4>4.3.17. `SecureContext^x</h4>

<p>
`SecureContext$x `拡張属性$が［［
`~ifc$ ／ `部分的~ifc定義$
］／
個々の`~ifc~mb$ ／
<a href="#es-dictionary-constructors">構築子</a>を伴う`辞書$
］ %X 上に現れた場合、 %X は `~secure文脈$（ `SECURE-CONTEXTS$r, 2 節）の中でのみ公開されることを指示する。
◎
If the [SecureContext] extended attribute appears on an interface, partial interface, an individual interface member, or dictionary with a constructor, it indicates that the interface, interface member or dictionary constructor is exposed only within a secure context ([SECURE-CONTEXTS], section 2).
</p>

<p>
`SecureContext$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
◎
The [SecureContext] extended attribute MUST take no arguments.
</li>
	<li>
［［
`~ifc$ ／ `部分的~ifc定義$
］／
個々の`~ifc~mb$ ／
<a href="#es-dictionary-constructors">構築子</a>を伴う`辞書$
］以外のものに利用されては~MUST_NOT。
◎
The [SecureContext] extended attribute MUST NOT be used on anything other than an interface, partial interface, an individual interface member, or dictionary.
</li>
</ul>

<p>
［
`SecureContext$x `拡張属性$を指定できるような
］構成子 %X が
`~secure文脈~下に限り可用@
になるかどうかは、次に従って定義される：
◎
Whether a construct that the [SecureContext] extended attribute can be specified on is available only in secure contexts is defined as follows:
</p>

<ul>
	<li>
%X に `SecureContext$x `拡張属性$が指定されているならば、
%X は，`~secure文脈~下に限り可用$になる。
◎
If the [SecureContext] extended attribute is specified on the construct, then it is available only in secure contexts.
</li>
	<li>
<p>
指定されていない場合に %X が`~secure文脈~下に限り可用$になるかどうかは、
%X の型に依存する：
◎
Otherwise, if the [SecureContext] extended attribute does not appear on a construct, then whether it is available only in secure contexts depends on the type of construct:
</p>

		<dl class="switch">
			<dt>~ifc</dt>
			<dt>辞書</dt>
			<dd>
%X は，`~secure文脈~下に限り可用$ではない。
◎
The interface or dictionary is not available only in secure contexts.
partial interface
</dd>
			<dt>部分的~ifc</dt>
			<dd>
%X が`~secure文脈~下に限り可用$になるのは、元の~ifc定義がそうであるとき，そのときに限る。
◎
The partial interface is available only in secure contexts if and only if the original interface definition is.
</dd>
			<dt>~ifc~mb</dt>
			<dd>
%X が`~secure文脈~下に限り可用$になるのは、 %X を宣言している［
~ifc／部分的~ifc定義
］がそうであるとき，そのときに限る。
◎
The interface member is available only in secure contexts if and only if the interface or partial interface the member is declared on is.
</dd>
		</dl>
	</li>
</ul>

<div class="note"><p>
構成子が`~secure文脈~下に限り可用$になるかどうかは、所与の ECMAScript 大域環境にて`公開され$るかどうかに波及する。
◎
Whether a construct is available only in secure contexts influences whether it is exposed in a given ECMAScript global environment.
</p></div>


<p>
`SecureContext$x 拡張属性は：
</p>

<ul>
	<li>
`多重定義$されている`演算$上に現れるならば，他のすべての多重定義~上にも現れ~MUST。
◎
If [SecureContext] appears on an overloaded operation, then it MUST appear on all overloads.
</li>
	<li>
［
~ifc~mbと, その~ifc~mbを宣言している［
~ifc／部分的~ifc定義
］］の両者に指定されては~MUST_NOT。
◎
The [SecureContext] extended attribute MUST NOT be specified on both an interface member and the interface or partial interface definition the interface member is declared on.
</li>
	<li>
~ifc上に現れるならば、それを`継承-$するどの~ifc上にも現れ~MUST。
◎
An interface without the [SecureContext] extended attribute MUST NOT inherit from another interface that does specify [SecureContext].
</li>
	<li>
`Constructor$x 拡張属性を持たない`辞書$上には、指定されては~MUST_NOT。
◎
The [SecureContext] extended attribute MUST NOT be specified on a dictionary that does not also have a [Constructor] extended attribute.
</li>
</ul>

<div class="example">
<p>
次の `IDL 片$は、すべての文脈で実行可能な 1 個の`演算$, および
~secure文脈からのみ実行可能な  1 個の演算と 1 個の属性を伴う~ifcを定義する：
◎
The following IDL fragment defines an interface with one operation that is executable from all contexts, and two which are executable only from secure contexts.
</p>

<pre class="idl-code">
interface PowerfulFeature {
/* <span title="This call will succeed in all contexts."
>次の演算の~callはどの文脈~下でも成功する。</span> */
  Promise &lt;Result&gt; calculateNotSoSecretResult();

/* <span title="This operation will not be exposed to a non-secure context. In such a context, there will be no &quot;calculateSecretResult&quot; property on PowerfulFeature.prototype."
>~secureでない文脈~下では、次の演算は公開されなくなる。
`PowerfulFeature.prototype^c 上に
`calculateSecretResult^l ~propはない。</span> */
  [SecureContext] Promise&lt;Result&gt; calculateSecretResult();

/* <span title="The same applies here: the attribute will not be exposed to a non-secure context, and in a non-secure context there will be no &quot;secretBoolean&quot; property on PowerfulFeature.prototype."
>次の属性にも同じことが言え、~secureでない文脈には公開されなくなる
— `PowerfulFeature.prototype^c 上に
`secretBoolean^l ~propはない。</span> */
  [SecureContext] readonly attribute boolean secretBoolean;
};
</pre>

</div>

			</section>
			<section id="TreatNonObjectAsNull">
<h4>4.3.18. `TreatNonObjectAsNull^x</h4>


<p>
`TreatNonObjectAsNull$x `拡張属性$が `呼戻~関数$上に現れた場合、
`属性$に代入される［
`~nullable$`呼戻~関数$型であって, ~objではない
］どの値も， `null^V 値に変換するようにすることを指示する。
◎
If the [TreatNonObjectAsNull] extended attribute appears on a callback function, then it indicates that any value assigned to an attribute whose type is a nullable callback function that is not an object will be converted to the null value.
</p>

<div class="warning">
<p>
仕様は、旧来の API の挙動の指定, もしくは
それらの API との整合性が要求されていない限り，
`TreatNonObjectAsNull$x
を利用する~SHOULD_NOT。
この特色機能`論ML^。
この文書が書かれた時点での，
`TreatNonObjectAsNull$x の妥当な既知の用途は、
`onclick^c, `onerror^c などの
<a href="~WAPI#event-handler-idl-attributes">~event-handler IDL 属性</a>
（ `HTML5$r ）の型として利用される`呼戻~関数$のみである。
◎
Specifications SHOULD NOT use [TreatNonObjectAsNull] unless required to specify the behavior of legacy APIs or for consistency with these APIs. Specification authors who wish to use this feature are strongly advised to discuss this on the public-script-coord@w3.org mailing list before proceeding. At the time of writing, the only known valid use of [TreatNonObjectAsNull] is for the callback functions used as the type of event handler IDL attributes ([HTML5], section 6.1.6.1) such as onclick and onerror.
</p>
</div>

<p>
`TreatNonObjectAsNull$x の利用に課される固有の要件については
`es-nullable-type$sec
に。
◎
See section 4.2.24 for the specific requirements that the use of [TreatNonObjectAsNull] entails.
</p>

<div class="example">
<p>
次の `IDL 片$は、
`TreatNonObjectAsNull$x 注釈付きの`呼戻~関数$型の属性と,
この`拡張属性$を伴わない`呼戻~関数$を持つ~ifcを定義する。
◎
The following IDL fragment defines an interface that has one attribute whose type is a [TreatNonObjectAsNull]-annotated callback function and another whose type is a callback function without the extended attribute:
</p>

<pre class="idl-code">
callback OccurrenceHandler = void (DOMString details);

[TreatNonObjectAsNull]
callback ErrorHandler = void (DOMString details);

interface Manager {
  attribute OccurrenceHandler? handler1;
  attribute ErrorHandler? handler2;
};
</pre>

<p>
ECMAScript 実装においては、
`handler1^c に対する~objでない値（ `Number^t 値など）の代入ingは，
`handler2^c に対する代入ingの挙動と異なる：
◎
In an ECMAScript implementation, assigning a value that is not an object (such as a Number value) to handler1 will have different behavior from that when assigning to handler2:
</p>

<pre class="es-code">
var manager = getManager();  // <span title="Get an instance of Manager."
>`Manager^T の~instanceを取得する。</span>

manager.handler1 = function() { };
manager.handler1;            // <!--cp-eval-function-->

try {
  manager.handler1 = 123;    // <span title="Throws a TypeError."
>`TypeError^t を投出。</span>
} catch (e) {
}

manager.handler2 = function() { };
manager.handler2;            // <!--cp-eval-function-->

manager.handler2 = 123;
manager.handler2;            // <span title="Evaluates to null."
>`null^v に評価される。</span>
</pre>

</div>

			</section>
			<section id="TreatNullAs">
<h4>4.3.19. `TreatNullAs^x</h4>


<p>
`TreatNullAs$x `拡張属性$が［
`DOMString$T 型の［
`属性$ ／ `演算$の引数
］］上に現れた場合、［
その属性に代入される ／ その演算の引数に渡される
］ `null^v 値は、既定による `null^l に文字列化される代わりに，空~文字列 "" に変換されることになる。
◎
If the [TreatNullAs] extended attribute appears on an attribute or operation argument whose type is DOMString, it indicates that a null value assigned to the attribute or passed as the operation argument will be handled differently from its default handling. Instead of being stringified to “null”, which is the default, it will be converted to the empty string “”.
</p>

<p>
`TreatNullAs$x が演算~自身に指定されていて，その演算が`呼戻~ifc$上にある場合、その
<a href="#es-user-objects">~ifcを実装する利用者~obj</a>
においてその演算を実装する関数は、上の演算~引数や属性に対するときと同じ仕方で取扱われる，返値を持つことになる。
◎
If [TreatNullAs] is specified on an operation itself, and that operation is on a callback interface, then it indicates that a user object implementing the interface will have the return value of the function that implements the operation handled in the same way as for operation arguments and attributes, as above.
</p>

<p>
`TreatNullAs$x 拡張属性には、次の`識別子を引数にとる$ことが~REQUIRED：
`EmptyString^c
。
◎
The [TreatNullAs] extended attribute MUST take the identifier EmptyString.
</p>

<p>
`TreatNullAs$x 拡張属性は：
</p>

<ul>
	<li>
<p>
`DOMString$T でない演算~引数, 属性, 演算の返値に指定されては~MUST_NOT。
◎
The [TreatNullAs] extended attribute MUST NOT be specified on an operation argument, attribute or operation return value whose type is not DOMString.
</p>

<div class="note"><p>
すなわち、
`DOMString?^T 型の属性であっても，
`null^V はその型の妥当な値なので
`TreatNullAs$x が利用されてはならない。
◎
This means that even an attribute of type DOMString? must not use [TreatNullAs], since null is a valid value of that type.
</p></div>
	</li>

	<li>
非~呼戻~ifc上の演算に指定されては~MUST_NOT
◎
The [TreatNullAs] extended attribute also MUST NOT be specified on an operation on a non-callback interface.
</li>

</ul>


<p>
`TreatNullAs$x の利用に課される固有の要件については
`es-DOMString$sec
に。
◎
See section 4.2.16 for the specific requirements that the use of [TreatNullAs] entails.
</p>

<div class="example">
<p>
次の `IDL 片$は、
`TreatNullAs$x 拡張属性を伴う属性と同じ拡張属性を伴う引数をとる演算を持つ，~ifcを定義する。
◎
The following IDL fragment defines an interface that has one attribute with the [TreatNullAs] extended attribute, and one operation with an argument that has the extended attribute:
</p>

<pre class="idl-code">
interface Dog {
  attribute DOMString name;
  [TreatNullAs=EmptyString] attribute DOMString owner;

  boolean isMemberOfBreed([TreatNullAs=EmptyString] DOMString breedName);
};
</pre>

<p>
`Dog^T ~ifcを実装する ECMAScript 実装においては、
`owner^l ~propに代入される, あるいは
`isMemberOfBreed^c 関数の引数に渡される `null^v 値は、
`null^l ではなく，空~文字列に変換されることになる：
◎
An ECMAScript implementation implementing the Dog interface would convert a null value assigned to the “owner” property or passed as the argument to the isMemberOfBreed function to the empty string rather than "null":
</p>

<pre class="es-code">
var d = getDog();         
       // <span title="Assume d is a platform object implementing the Dog
interface."
>%d は `Dog^T ~ifcを実装する~platform~objとする。</span>

d.name = null;            // <span title="This assigns the string &quot;null&quot; to the .name property."
>文字列 `null^l を `.name^c ~propに代入する。</span>

d.owner = null;           // <span title="This assigns the string &quot;&quot; to the .owner property."
>文字列 "" を `.owner^c ~propに代入する。</span>

d.isMemberOfBreed(null);  // <span title="This passes the string &quot;&quot; to the isMemberOfBreed
function."
>文字列 "" を `isMemberOfBreed^c 関数に渡す。</span>
</pre>
</div>
			</section>
			<section id="Unforgeable">
<h4>4.3.20. `Unforgeable^x</h4>


<p>
`Unforgeable$x `拡張属性$が［
静的でない［
`属性$／`演算$
］］上に現れた場合、その属性／演算は，［
その挙動を改変できない, かつ［
~obj上で~prop~lookupが遂行された際には，常にその属性の~prop値が返される
］］ような ECMAScript ~propとして反映されることになる。
特に，その~propは、非~configurableになり，かつ［
~objの原型~上ではなく, ~obj上の自前の~prop
］として存在することになる。
◎
If the [Unforgeable] extended attribute appears on a non-static attribute or non-static operations, it indicates that the attribute or operation will be reflected as an ECMAScript property in a way that means its behavior cannot be modified and that performing a property lookup on the object will always result in the attribute’s property value being returned. In particular, the property will be non-configurable and will exist as an own property on the object itself rather than on its prototype.
</p>

<p>
`Unforgeable$x `拡張属性$が `~ifc$上に現れた場合、その~ifcのどの`広義~帰結~ifc$上で宣言されている どの［
静的でない［ `属性$／`演算$ ］
］も、その原型~上ではなく, その~ifcを実装する~obj上の自前の ECMAScript ~propとして，上述と同様に反映されることになる。
◎
If the [Unforgeable] extended attribute appears on an interface, it indicates that all of the non-static attributes and non-static operations declared on that interface and its consequential interfaces will be similarly reflected as own ECMAScript properties on objects that implement the interface, rather than on the prototype.
</p>

<p>
属性／演算 %m は、次のいずれかが成立するとき，
所与の~ifc %A 上において
`偽装不可@
とされる：
<!-- “偽装不可” という対訳は概念的な意味で汎用性には欠くが，元々はセキュリティ上の要求に端を発するものと見られる -->
◎
An attribute or operation is said to be unforgeable on a given interface A if any of the following are true:
</p>

<ul>
	<li>
%m は %A のいずれかの`広義~帰結~ifc$上にて，
`Unforgeable$x `拡張属性$ 注釈付きで宣言されている
◎
The attribute or operation is declared on A or one of A’s consequential interfaces, and is annotated with the [Unforgeable] extended attribute.
</li>
	<li>
`Unforgeable$x `拡張属性$ 注釈付きであるような
%A の`広義~帰結~ifc$ %B が存在して，
%m が %B のいずれかの`広義~帰結~ifc$上で宣言されている
◎
The attribute or operation is declared on A or one of A’s consequential interfaces, and that interface is annotated with the [Unforgeable] extended attribute.
◎
There exists an interface B, which is either A or one of A’s consequential interfaces, B is annotated with the [Unforgeable] extended attribute, and the attribute or operation is declared on one of B’s consequential interfaces.
</li>
</ul>

<div>
<p>
`Unforgeable$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
</li>
	<li>
［［
静的でない［
`属性$, `演算$
］］, ~ifc
］以外の所に現れては~MUST_NOT。
</li>
	<li>
演算~上に現れた場合、その~ifc上で同じ識別子を持つ他のすべての演算~上にも現れ~MUST。
</li>

</ul>

◎
The [Unforgeable] extended attribute MUST take no arguments.
◎
The [Unforgeable] extended attribute MUST NOT appear on anything other than an attribute, non-static operation or an interface. If it does appear on an operation, then it MUST appear on all operations with the same identifier on that interface.
</div>

<p>
属性／演算 %m が，~ifc %A 上で`偽装不可$であって, かつ
%A が別の~ifc %B の`被継承~ifc$である場合、
%B の`広義~帰結~ifc$は，`識別子$が %m と同じであるような［静的でない属性］や`正則~演算$を持っては~MUST_NOT。
◎
If an attribute or operation X is unforgeable on an interface A, and A is one of the inherited interfaces of another interface B, then B and all of its consequential interfaces MUST NOT have a non-static attribute or regular operation with the same identifier as X.
</p>

<div class="note">

<p>
例えば，次は許容されない：
◎
For example, the following is disallowed:
</p>

<pre class="idl-code">
interface A1 {
[Unforgeable] readonly attribute DOMString x;
};
interface B1 : A1 {
  void x();  
       // <span title="Invalid; would be shadowed by A1's x."
>妥当でない： `A1^T の `x^M で隠蔽されるので。</span>
};

interface B2 : A1 { };
B2 implements Mixin;
interface Mixin {
  void x();  
       // <span title="Invalid; B2's copy of x would be shadowed by A1's x."
>妥当でない： `B2^T における `x^M の複製は `A1^T の `x^M で隠蔽されるので。</span>
};

[Unforgeable]
interface A2 {
  readonly attribute DOMString x;
};
interface B3 : A2 {
  void x();  
       // <span title="Invalid; would be shadowed by A2's x."
>妥当でない： `A2^T の `x^M で隠蔽されるので。</span>
};

interface B4 : A2 { };
B4 implements Mixin;
interface Mixin {
  void x();  
       // <span title="Invalid; B4's copy of x would be shadowed by A2's x."
>妥当でない： `B4^T における `x^M の複製は `A2^T の `x^M で隠蔽されるので。</span>
};

interface A3 { };
A3 implements A2;
interface B5 : A3 {
  void x();  
       // <span title="Invalid; would be shadowed by A3's mixed-in copy of A2's x."
>妥当でない： `A3^T における ［ `A2^T の `x^M ］の mixed-in 複製で隠蔽されるので。</span>
};
</pre>

</div>


<p>
`Unforgeable$x の利用に課される固有の要件については
`es-attributes$sec,
`es-operations$sec,
`es-platform-objects$sec,
`indexed-and-named-properties$sec,
`defineownproperty$sec
に。
◎
See section 4.6.7, section 4.6.8, section 4.8, section 4.8.1 and section 4.8.7 for the specific requirements that the use of [Unforgeable] entails.
</p>

<div class="example">
<p>
次の `IDL 片$は
片方に `Unforgeable$x が指定された２個の`属性$を持つ~ifcを定義する：
◎
The following IDL fragment defines an interface that has two attributes, one of which is designated as [Unforgeable]:
</p>

<pre class="idl-code">
interface System {
  [Unforgeable] readonly attribute DOMString username;
  readonly attribute long long loginTime; 
};
</pre>

<p>
この~ifcの ECMAScript 実装においては、
`username^M 属性は，~obj自身において非~configurable~propとして公開されることになる：
◎
In an ECMAScript implementation of the interface, the username attribute will be exposed as a non-configurable property on the object itself:
</p>

<pre class="es-code">
var system = getSystem();         // <span title="Get an instance of System."
>`System^T の~instanceを取得する。</span>

system.hasOwnProperty("username");             // <!--cp-eval-true-->
system.hasOwnProperty("loginTime");            // <!--cp-eval-false-->
System.prototype.hasOwnProperty("username");   // <!--cp-eval-false-->
System.prototype.hasOwnProperty("loginTime");  // <!--cp-eval-true-->

try {
  // <span title="This call would fail, since the property is non-configurable."
>この~callは失敗することになる — ~propは非~configurableなので。</span>
  Object.defineProperty(system, "username", { value: "administrator" });
} catch (e) { }

// <span title="This defineProperty call would succeed, because System.prototype.loginTime
is configurable."
>次の `defineProperty^c ~callは成功する — `System.prototype.loginTime^c が~configurableなので。</span>
var forgedLoginTime = 5;
Object.defineProperty(System.prototype, "loginTime", { value: forgedLoginTime });

system.loginTime;  // <span title="So this now evaluates to forgedLoginTime."
>よって，これは今や %forgedLoginTime に評価される。</span>
</pre>
</div>
			</section>
			<section id="Unscopable" class="v2 L2">

<h4>4.3.21. `Unscopable^x</h4>

<p>
`Unscopable$x `拡張属性$が［
`正則~属性$／`正則~演算$
］上に現れた場合、［
その~ifc~mbを伴う~ifcを実装する~obj
］が，［
その~prop名 %N を，それに伴うどの［
~obj環境 record
］内にも，その基底~objとして内包しない
］ことを指示する。
その~~結果、 `with^c 文の中では，［
%N に合致する “素の” 識別子
］は，その~propには解決されないことになる。
このふるまいは、 %N を［
`~ifc原型~obj$上の
`unscopables_symbol^ ~propの値
］に含ませることで，得られる。
◎
If the [Unscopable] extended attribute appears on a regular attribute or regular operation, it indicates that an object that implements an interface with the given interface member will not include its property name in any object environment record with it as its base object. The result of this is that bare identifiers matching the property name will not resolve to the property in a with statement. This is achieved by including the property name on the interface prototype object’s @@unscopables property’s value.
</p>

<p>
`Unscopable$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが~REQUIRED。
◎
The [Unscopable] extended attribute MUST take no arguments.
</li>
	<li>
［
`正則~属性$, `正則~演算$
］以外の所に現れては~MUST_NOT。
◎
The [Unscopable] extended attribute MUST NOT appear on anything other than a regular attribute or regular operation.
</li>
</ul>


<p>
`Unscopable$x の利用に課される固有の要件については
`interface-prototype-object$sec
に。
◎
See section 4.6.4 for the specific requirements that the use of [Unscopable] entails.
</p>

<div class="note">

<p>
例えば、次の IDL が与えられたとき：
◎
For example, with the following IDL:
</p>

<pre class="idl-code">
interface Thing {
  void f();
  [Unscopable] g();
};
</pre>

<p>
`f^l ~propは、 `with^c 文の中で “素の” 識別子により参照できるが，
`g^l ~propはできない：
◎
the “f” property an be referenced with a bare identifier in a with statement but the “g” property cannot:
</p>

<pre class="es-code">
var thing = getThing();  // <span title=
	"An instance of Thing"
	>`Thing^T の~instance</span>
with (thing) {
  f;                     // <span title=
	"Evaluates to a Function object."
	>`Function^t ~objに評価される。</span>
  g;                     // <span title=
	"Throws a ReferenceError."
	>`ReferenceError^t を投出。</span>
}
</pre>

</div>

			</section>
		</section>
		<section id="es-security">
<h3 title="Security">4.4. 保安検査</h3>

<p>
以下の節の一部の~algoでは、所与の~objに対し
`保安検査を遂行する@†
ものがある。
この検査は、所与の［
`演算$／`属性$
］ %f に対する［
呼出／~access
］が許容されるべきかどうかを決定するために利用される。
保安検査に対する入力は次の 4 つである：
◎
Certain algorithms in the sections below are defined to perform a security check on a given object. This check is used to determine whether a given operation invocation or attribute access should be allowed. The security check takes the following four inputs: 
</p>

<ol>
	<li>
［
%f の呼出 ／ %f への~access
］が行われている当の`~platform~obj$
◎
the platform object on which the operation invocation or attribute access is being done,
</li>
	<li>
<p>
%f を実装する `Function^t ~obj %F が属する ECMAScript 大域環境†
</p>

<p class="trans-note">【†
簡潔に記述するため、この訳では，この入力には %F をそのまま渡すようにも記される。
その場合は、その~objが属する ECMAScript 大域環境が渡されたと解釈するものとする。
】</p>
◎
the ECMAScript global environment associated with the Function object that implements the operation or attribute,
</li>
	<li>
%f の`識別子$
◎
the identifier of the operation or attribute, and
</li>
	<li>
<p>
次のいずれかで与えられる， %F の種別：
</p>
		<ul>
			<li>
`~meth^C
（ %f が演算に対応するとき）
</li>
			<li>
`取得子^C
（ %f が “取得子” 関数に対応するとき）
</li>
			<li>
`設定子^C
（ %f が “設定子” 関数に対応するとき）
</li>
		</ul>
◎
the type of the Function object – “method” (when it corresponds to an IDL operation), or “getter” or “setter” (when it corresponds to the getter or setter function of an IDL attribute).
</li>
</ol>


<div class="note"><p>
どのようにして［
保安検査が遂行された上で，適切な例外を投出するか, 通常のように返るか
］については， HTML 仕様が定義するものと期待されている。
`HTML$r
◎
The expectation is that the HTML specification defines how a security check is performed, and that it will either throw an appropriate exception or return normally. [HTML]
</p></div>



		</section>
		<section id="es-overloads">
<h3 title="Overload resolution algorithm">4.5. 多重定義~解決~algo</h3>

<div>
<p>
多重定義された`関数類$の呼出を解決するために，
`多重定義~解決~algo@
が定義される。
その入力は：
</p>

<ul>
	<li>
`有効~多重定義~集合$ %S
</li>
	<li>
ECMAScript 値の~list %arg<sub>0..%n−1</sub>
<!-- 
— 以下、~listの~index %i に位置する値を arg[%i], 
~listの長さを %n と記す
-->
</li>
</ul>

<p>
である。
その出力は，次の組である：
</p>

<ul>
	<li>
%S 内のいずれかの~entryの［
`演算$／`拡張属性$（構築子）
］
</li>
	<li>
各項が［
IDL 値, または`MISSING^
］のいずれかであるような，~list</li>
</ul>

<p>
~algoは次の様に挙動する：
</p>

◎
In order to define how overloaded function invocations are resolved, the overload resolution algorithm is defined. Its input is an effective overload set, S, and a list of ECMAScript values, arg0..n−1. Its output is a pair consisting of the operation or extended attribute of one of S’s entries and a list of IDL values or the special value “missing”. The algorithm behaves as follows:
</div>

<ol class="algorithm">
	<li>
%maxarg := max( %S 内の各~entryの `ol-type-list^ の長さ )
◎
Let maxarg be the length of the longest type list of the entries in S.
</li>
	<li>
%argcount :← min(%maxarg,&nbsp;%n)
◎
Initialize argcount to be min(maxarg, n).
</li>

	<li>
%S から［
`ol-type-list^の長さ ≠ %argcount
］なる~entryすべてを除去する
◎
Remove from S all entries whose type list is not of length argcount.
</li>

	<li>
~IF
%S ＝ ∅
~THEN
~THROW `TypeError^t
◎
If S is empty, then throw a TypeError.
</li>

	<li>
%d :← −1
◎
Initialize d to −1.
</li>

	<li class="v2">
%method :← `undefined^v
◎
Initialize method to undefined.
</li>

	<li>
~IF
%S に複数の~entryがある
~THEN
%d ← それらの %S の~entryに対する`判別引数~index$
◎
If there is more than one entry in S, then set d to be the distinguishing argument index for the entries of S.
</li>

	<li>
%values :← 空~list（各項が［
IDL 値, または`MISSING^
］のいずれかになる）
◎
Initialize values to be an empty list, where each entry will be either an IDL value or the special value “missing”.
</li>

	<li>
%i :← 0
◎
Initialize i to 0.
</li>

	<li>
<p>
~WHILE %i &lt; %d ：
◎
While i &lt; d:
</p>
		<ol>
			<li>
%V := %arg<sub>%i</sub>
◎
Let V be argi.
</li>
			<li>
<p>
%type := %S から任意に選んだ~entryの `ol-type-list^ の中の~index %i に位置する型
◎
Let type be the type at index i in the type list of any entry in S.
</p>

<div class="note"><p>
この時点では %S のすべての~entryにおいて，その~index %i に位置する［
`ol-type-list^ の型, および
`ol-optionality-list^の`省略可否 値$
］は 同じである。
<span class="trans-note">【
（下で利用されている）既定~値も
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22883">同じになる必要がある</a>
ように思われるが？
】</span>
◎
All entries in S at this point have the same type and optionality value at index i.
</p></div>
</li>

			<li>
%optionality := %S から任意に選んだ~entryの `ol-optionality-list^ の中の~index %i に位置する`省略可否 値$
◎
Let optionality be the value at index i in the list of optionality values of any entry in S.
</li>

			<li id="cp-if-optional">
<p>
~IF［
%optionality ＝ “`省略可^C”
］~AND［
%V ＝ `undefined^v
］
⇒
◎
If optionality is “optional” and V is undefined, then:
</p>
				<ol>
					<li>
~IF
~index %i に位置する引数は `既定~値$を伴って宣言されている
~THEN
その既定~値を %values に付加する
◎
If the argument at index i is declared with a default value, then append to values that default value.
</li>
					<li>
~ELSE
~THEN
`MISSING^ を %values に付加する
◎
Otherwise, append to values the special value “missing”.
</li>
				</ol>
			</li>

			<li id="cp-append-convert1">
~ELSE
~THEN
%V を IDL 型 %type に`toIDL^した結果を %values に付加する
◎
Otherwise, append to values the result of converting V to IDL type type.
</li>
			<!--cp-inc-i-->
		</ol>
	</li>

	<li>
<p>
~IF
%i ＝ %d
<span class="trans-note">【すなわち， %S に複数の~entryがある】</span>
⇒
◎
If i = d, then:
</p>

		<ol>
			<li>
<p>
%V := %arg<sub>%i</sub>
◎
Let V be argi.
</p>
<div class="note"><p>
これが多重定義の解決-に利用されることになる引数になる。
◎
This is the argument that will be used to resolve which overload is selected.
</p></div>

			</li>
			<li>
~IF［
%V ＝ `undefined^v
］~AND［
%S の~entryに［
その `ol-optionality-list^ の中の~index %i に位置する`省略可否 値$
］ ＝ “`省略可^C” なるものが在る
］
~THEN
他のすべての~entryを %S から除去する
◎
If V is undefined, and there is an entry in S whose list of optionality values has “optional” at index i, then remove from S all other entries.
</li>

			<li>
~ELIF
［
%V ~IN { `null^v, `undefined^v }
］~AND［
%S の~entryに［
その `ol-type-list^ の中の~index %i に位置する型が `~nullable型を内包する$
］ようなものが在る
］
~THEN
他のすべての~entryを %S から除去する
◎
↓</li>
			<li>
<p>
~ELIF
下の表の中に，次のいずれも満たすような行が在る：
</p>
				<ul>
					<li>
%V は行の一列目の条件を満たす。
</li>
					<li>
%S の~entryに，次を満たすものが在る：［
その `ol-type-list^ の中の~index %i に位置する型 %T
］は［
行の二列目に挙げられる型の集合 %Types
］に<a href="#type-compatible">型互換</a>である。
</li>
				</ul>

<p>
~THEN
表の中のそのような行のうち，最初の行について、［
上の二番目の条件に該当する %S の~entry†
］以外の~entryすべてを，
%S から除去する
</p>

<p>
ここで、型 %T が，（`~nullable$でも `共用体~型$ でもない）型の集合
%Types に
<dfn id="type-compatible">型互換</dfn>
であるとは、
%T が次のいずれかを満たすことを意味する：
</p>

				<ul>
					<li>
%T は %Types に属する
</li>
					<li>
%T は`~nullable$型であり, かつ
その`内部型$は %Types に属する
</li>
					<li>
%T は`共用体~型$, または`~nullable$共用体~型である, かつ
その`平坦化~mb型$の中に %Types に属するものが在る
</li>
				</ul>

<p class="trans-note">【†
下の表のどの行についても、二列目に挙げられた型たちは，どの 2 つも互いに`判別可能$でない。
したがって、
%S （`有効~多重定義~集合$）, %i （`判別引数~index$）の定義により、どの行についても，`型互換$な %S の~entryは，高々１個になる。
】【
簡潔にするため、この段は，原文の記述を再構成している。
】</p>


<table border>
<col span="1" style="width:50%;" /><col/>
<thead><tr><th>%V が満たす条件
</th><th>%Types
</th></tr></thead>

<tbody><tr><td>
%V ~IN { `null^v, `undefined^v }
◎
Otherwise: if V is null or undefined, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`辞書~型$
◎
• a nullable type
• a dictionary type
• a union type that includes a nullable type or that has a dictionary type in its flattened members
◎
then remove from S all other entries.

</td></tr><tr><td>
`~platform~obj$である
◎
Otherwise: if V is a platform object, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
%V が実装する`~ifc型$, `object$T
◎
• an interface type that V implements
• object
• a nullable version of any of the above types
• a union type or a nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr class="v2 L2"><td>
`RegExp^t ~objである
◎
Otherwise: if V is a RegExp object and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`RegExp$T, `object$T
<!-- 原文 重複＊ -->
◎
• RegExp
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr class="v2"><td>
`DOMException^t ~objである
◎
Otherwise: if V is a DOMException platform object and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`DOMException$T, `Error$T, `object$T
◎
• DOMException
• Error
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr class="v2"><td>
`Error^t ~objである（すなわち， `ErrorData^es `internal_slot^を持つ）
◎
Otherwise: if V is an Error object (that is, it has an [[ErrorData]] internal slot) and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`Error$T, `object$T
◎
• Error
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.


</td></tr><tr class="v2"><td>
`ArrayBufferData^es `internal_slot^を持つ
◎
Otherwise: if V is an object with an [[ArrayBufferData]] internal slot and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`ArrayBuffer$T, `object$T
◎
• ArrayBuffer
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr class="v2"><td>
`DataView^es `internal_slot^を持つ
◎
Otherwise: if V is an object with a [[DataView]] internal slot and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`DataView$T, `object$T
◎
• DataView
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr class="v2"><td>
`TypedArrayName^es `internal_slot^を持つ
◎
Otherwise: if V is an object with a [[TypedArrayName]] internal slot and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
［
型~名が %V の `TypedArrayName^es `internal_slot^ に等しい `有型~配列~型$
］, `object$T
◎
• a typed array type whose name is equal to the value of V’s [[TypedArrayName]] internal slot
• object
• a nullable version of either of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
`IsCallable$A( %V ) ＝ ~true
◎
Otherwise: if IsCallable(V) is true, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`呼戻~関数$ 型, `object$T
◎
• a callback function type
• object
• a nullable version of any of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr class="v2"><td>
<p>
［
~native `RegExp^t ~objを除く任意の種類の~objである
］~AND［
次を遂行した結果の %method ≠ `undefined^v
］：
</p>

<ol>
	<li>
%method := `GetMethod$A( %V, `iterator_symbol^ ) の結果
</li>
	<li>
`ReturnIfAbrupt$A( %method )
</li>
</ol>

◎
Otherwise: if V is any kind of object except for a native RegExp object, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`連列~型$, `凍結~配列~型$
◎
• a sequence type
• a frozen array type
• a nullable version of any of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
and after performing the following steps,
◎
Let method be the result of GetMethod(V, @@iterator).
◎
ReturnIfAbrupt(method).
◎
method is not undefined, then remove from S all other entries.

</td></tr><tr><td>
~native `RegExp^t ~objを除く任意の種類の~objである
◎
Otherwise: if V is any kind of object except for a native RegExp object, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`呼戻~ifc$型, `辞書~型$, `object$T
◎
• a callback interface type
• a dictionary type
• object
• a nullable version of any of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
`Boolean^t 値である
◎
Otherwise: if V is a Boolean value, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`boolean$T
◎
• boolean
• a nullable boolean
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
`Number^t 値である
◎
Otherwise: if V is a Number value, and there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`実数~型$
◎
• a numeric type
• a nullable numeric type
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`文字列~型$
◎
• a string type
• a nullable version of any of the above types
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`実数~型$
◎
• a numeric type
• a nullable numeric type
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
</td><td>
`boolean$T
◎
• boolean
• a nullable boolean
• a union type or nullable union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

</td></tr><tr><td>
無条件
◎
Otherwise: if there is an entry in S that has any at position i of its type list, then remove from S all other entries.
</td><td>
`any$T

</td></tr></tbody></table>

			</li>
			<li>
~ELSE
~THEN
~THROW `TypeError^t
◎
Otherwise: throw a TypeError.
</li>
		</ol>
	</li>

	<li>
%entry := %S の（~~唯一の）~entry
◎
↓</li>
	<li>
%callable := %entry の `ol-callable^ （ `演算$／`拡張属性$ ）
◎
Let callable be the operation or extended attribute of the single entry in S.
</li>


	<li class="v2">
<p>
~IF［
%i ＝ %d
］~AND［
%method ≠ `undefined^v
］⇒
◎
If i = d and method is not undefined, then
</p>
		<ol>
			<li>
%V := %arg<sub>%i</sub>
◎
Let V be argi.
</li>
			<li>
%T := %entry の `ol-type-list^ の中の~index %i に位置する型
◎
Let T be the type at index i in the type list of the remaining entry in S.
</li>
			<li>
~IF
%T は`連列~型$である
~THEN
［
%V, %method
］から，型 %T の`連列~値を作成-$した結果を， %values に付加する
◎
If T is a sequence type, then append to values the result of creating a sequence of type T from V and method.
</li>

			<li>
~ELSE（ %T は`凍結~配列~型$である）
~THEN
［
%V, %method
］から，型 %T の`凍結~配列~値を作成-$した結果を， %values に付加する
◎
Otherwise, T is a frozen array type. Append to values the result of creating a frozen array of type T from V and method.
</li>


			<!--cp-inc-i-->
		</ol>
	</li>

	<li>
<p>
~WHILE %i &lt; %argcount ：
◎
While i &lt; argcount:
</p>

		<ol>
			<li>
%V := %arg<sub>%i</sub>
◎
Let V be argi.
</li>
			<li>
%type := %entry の `ol-type-list^ の中の~index %i に位置する型
◎
Let type be the type at index i in the type list of the remaining entry in S.
</li>
			<li>
%optionality := %entry の `ol-optionality-list^ の中の~index %i に位置する`省略可否 値$
◎
Let optionality be the value at index i in the list of optionality values of the remaining entry in S.
</li>

			<!--cp-if-optional-->
			<!--cp-append-convert1-->
			<!--cp-inc-i-->
		</ol>
	</li>

	<li>
<p>
~WHILE %i &lt; %callable が宣言している引数~個数：
◎
While i is less than the number of arguments callable is declared to take:
</p>

		<ol>
			<li>
~IF
%callable の~index %i に位置する引数に
`既定~値$
が宣言されている
~THEN
その既定~値を %values に付加する
◎
If callable’s argument at index i is declared with a default value, then append to values that default value.
</li>

			<li>
~ELIF
%callable の~index %i に位置する引数は`可変個~引数$でない
~THEN
`MISSING^を %values に付加する
◎
Otherwise, if callable’s argument at index i is not variadic, then append to values the special value “missing”.
</li>
			<!--cp-inc-i-->
		</ol>
	</li>

	<li>
~RET ~pair &lt;%callable, %values&gt;
◎
Return the pair &lt;callable, values&gt;.
</li>

</ol>

<div class="note">

<p>
多重定義~解決~algoは、~callされている［
多重定義された`関数類$
］の識別に加えて、
ECMAScript 引数~値から，それぞれに対応する IDL 値への変換を遂行する。
概略的には次の様に演算する。
◎
The overload resolution algorithm performs both the identification of which overloaded operation, constructor, etc. is being called, and the conversion of the ECMAScript argument values to their corresponding IDL values. Informally, it operates as follows.
</p>

<p>
まず、関数に渡された ECMAScript 引数の個数を考慮に入れつつ，妥当な多重定義の選定が行われる：
◎
First, the selection of valid overloads is done by considering the number of ECMAScript arguments that were passed in to the function:
</p>
	<ul>
		<li>
最長の多重定義~引数~listより多い引数が渡された場合、余分な引数は無視する。
◎
If there are more arguments passed in than the longest overload argument list, then they are ignored.
</li>

		<li>
余分な引数を無視した後の引数の個数と，同じ個数の引数をとれる多重定義のみが考慮の対象になる。
もし無ければ， `TypeError^t が投出される。
◎
After ignoring these trailing arguments, only overloads that can take this exact number of arguments are considered. If there are none, then a TypeError is thrown.
</li>
	</ul>

<p>
~~正しい個数の引数をとる，多重定義の集合が得られたなら、
ECMAScript 値は左から右の順に変換される。
多重定義に対する制約の定義から、この時点で複数の多重定義の候補がある場合、引数~listの中で，最終的に選定される多重定義を判別する際の~~基準となる位置がある。
これが`判別引数~index$である。
◎
Once we have a set of possible overloads with the right number of arguments, the ECMAScript values are converted from left to right. The nature of the restrictions on overloading means that if we have multiple possible overloads at this point, then there will be one position in the argument list that will be used to distinguish which overload we will finally select; this is the distinguishing argument index.
</p>

<p>
まず最初に，判別引数より左に位置する引数を変換する（これらの引数については、同じ~indexに位置する他の多重定義の引数と同じ型であることが要件にされている）。
<!-- 判別引数~indexまで到達したなら、 -->
次に、対応し得る IDL 型を決定するために，判別引数~indexの位置に渡された ECMAScript 値の型を検分する。
これにより、呼出されることになる多重定義の最終的な選定が可能になる。
渡された値が `undefined^v であって, かつ
この位置に随意~引数を伴う多重定義がある場合、その多重定義が選定される。
このとき，渡された値の型に対する妥当な多重定義が無ければ、 `TypeError^t が投出される。
判別引数~indexに位置する値の検分は副作用を持たない。
多重定義~解決~algoを走らせることに因る唯一の副作用は、
ECMAScript 値から IDL 値への変換-に因るものに限られる。
◎
We first convert the arguments to the left of the distinguishing argument. (There is a requirement that an argument to the left of the distinguishing argument index has the same type as in the other overloads, at the same index.) Then we inspect the type of the ECMAScript value that is passed in at the distinguishing argument index to determine which IDL type it may correspond to. This allows us to select the final overload that will be invoked. If the value passed in is undefined and there is an overload with an optional argument at this position, then we will choose that overload. If there is no valid overload for the type of value passed in here, then we throw a TypeError. The inspection of the value at the distinguishing argument index does not have any side effects; the only side effects that come from running the overload resolution algorithm are those that come from converting the ECMAScript values to IDL values.
</p>

<p>
この段階で，利用する多重定義が決定されたことになる。
しかる後、判別引数に後続する残りの引数~値も左から右の順に変換する。
ここでも，前述の余分な引数は、無視される。
◎
At this point, we have determined which overload to use. We now convert the remaining arguments, from the distinguishing argument onwards, again ignoring any additional arguments that were ignored due to being passed after the last possible argument.
</p>

<p>
随意~引数の ECMAScript 値からそれに等価な IDL 値へ変換する際には、
`undefined^v は，［
随意~引数に`既定~値$が在ればそれに／
無ければ`MISSING^に
］変換されることになる。
◎
When converting an optional argument’s ECMAScript value to its equivalent IDL value, undefined will be converted into the optional argument’s default value, if it has one, or a special value “missing” otherwise.
</p>

<p>
しかしながら、`可変個~引数$に対応する随意~引数に対する `undefined^v は，`MISSING^とは見なされない。
この場合の `undefined^v 値は、必須の引数と同様に，`可変個~引数$の型に変換されることになる。
◎
Optional arguments corresponding to a final, variadic argument do not treat undefined as a special “missing” value, however. The undefined value is converted to the type of variadic argument as would be done for a non-optional argument.
</p>
</div>

		</section>
		<section id="es-interfaces">
<h3 title="Interfaces">4.6. ~ifc</h3>


<p>
所与の ECMAScript 大域環境 %G にて`公開され$ている，どの`~ifc$ %I に対しても、 %I が次のいずれかの条件：
◎
For every interface that is exposed in a given ECMAScript global environment and:
</p>

<ul>
	<li>
`呼戻~ifc$である, かつ
`定数$を伴って宣言されている
◎
is a callback interface that has constants declared on it, or
</li>
	<li>
非~呼戻`~ifc$である, かつ
`NoInterfaceObject$x `拡張属性$を伴わずに宣言されている
◎
is a non-callback interface that is not declared with the [NoInterfaceObject] extended attribute,
</li>
</ul>


<div>
<p>
を満たすならば， %I に対応する 次のように特徴付けられる~propが %G の大域~obj上に存在し~MUST：
</p>

<ul>
	<li>
名前は %I の`識別子$。
</li>
	<li>
値は
`~ifc~obj@
と呼ばれる~obj
— この~objの特徴については、下の
`interface-object$sec
にて述べる。
</li>
	<li id="cp-has-attr-TFT">
属性 `TFT^desc を持つ。
</li>
</ul>

◎
a corresponding property MUST exist on the ECMAScript environment's global object. The name of the property is the identifier of the interface, and its value is an object called the interface object.
◎
The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. The characteristics of an interface object are described in section 4.6.1 below.
</div>


<div class="p">
<p>
加えて、 %G において
`NamedConstructor$x 拡張属性を伴って`公開され$る，どの~ifcに対しても、対応する 次のように特徴付けられる~propが %G の大域~obj上に存在し~MUST：
</p>

<ul>
	<li>
名前は `=^sym の直後に現れる `identifier$g
</li>
	<li>
値は、その~ifcを実装する~objの構築を可能にする,
`有名~構築子@
と呼ばれる~obj
— この構築子の特徴については、下の
`named-constructors$sec
にて述べる。
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
In addition, for every [NamedConstructor] extended attribute on an exposed interface, a corresponding property MUST exist on the ECMAScript global object. The name of the property is the identifier that occurs directly after the “=”, and its value is an object called a named constructor, which allows construction of objects that implement the interface. The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. The characteristics of a named constructor are described in section 4.6.2 below.
</div>


			<section>
<h4 class="trans-note">4.6.X. 【この訳に特有の定義】</h4>

<p>
共通の記述を集約するため、この訳では次の非公式な定義を導入する（加えて、原文の定義を，より見通しのよい~~形に変形してもいる）：
</p>

<div>
<p>
所与の~prop %p が ~ifc %A に対する
`通例の場所に存在する@
とは，次を意味する：
</p>

<ul>
	<li>
%A が
`Global$x ／ `PrimaryGlobal$x
注釈付きの~ifcでないならば、 %p は %A の`~ifc原型~obj$上に存在する。
</li>

	<li>
また、ある
`Global$x ／ `PrimaryGlobal$x
注釈付きの~ifc %G が存在して， %A が %G の`広義~帰結~ifc$であるならば、 %p は（前項に加えて，） %G を実装する単独の~obj上に存在する。
</li>
</ul>
◎
If the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on the single object that implements the interface.
◎
Otherwise, if the interface is a consequential interface of a [Global]- or [PrimaryGlobal]-annotated interface, then the property exists on the single object that implements the [Global]- or [PrimaryGlobal]-annotated interface as well as on the consequential interface’s interface prototype object.
◎
Otherwise, the property exists solely on the interface’s interface prototype object.
</div>

<!-- ＊

~ifcが 'Global$x 拡張属性を伴って宣言されている

	その~ifcを実装する単独の~obj上に存在

他の場合，~ifcが 'Global$x 注釈付きの~ifc %G の'帰結~ifc$である

	その帰結~ifcの'~ifc原型~obj$, および
	%G を実装する単独の~obj
	上に存在

他の場合、~propは，その~ifcの'~ifc原型~obj$上においてのみ存在

-->


			</section>
			<section id="interface-object">
<h4 title="Interface object">4.6.1. ~ifc~obj</h4>


<p>
所与の非~呼戻`~ifc$に対応する~ifc~objは、`関数~obj$である。
それは、下の
`es-constants$sec, `es-operations$sec
にて述べる様に，その~ifc上に定義される
`定数$, `静的~演算$
のそれぞれに対応する~propを持つ。
◎
The interface object for a given non-callback interface is a function object. It has properties that correspond to the constants and static operations defined on that interface, as described in sections 4.6.6 and 4.6.8 below.
</p>

<p>
非~呼戻~ifc %A に対応する~ifc~objの `Prototype^es 内的~propの値は、次のように決定される：
◎
The [[Prototype]] internal property of an interface object for a non-callback interface is determined as follows:
</p>

<ol>
	<li>
%A が他の何らかの~ifc %B を継承する場合、
%B に対応する~ifc~obj。
◎
If the interface inherits from some other interface, the value of [[Prototype]] is the interface object for that other interface.
</li>

	<li>
他の場合、
`FunctionPrototype^ （ `ECMA-262$r 6.1.7.4 節）。
◎
If the interface doesn't inherit from any other interface, the value of [[Prototype]] is %FunctionPrototype% ([ECMA-262], section 6.1.7.4).
</li>
</ol>

<div class="p">
<p>
非~呼戻~ifcに対応する~ifc~objは、次のように特徴付けられる~propを持た~MUST：
</p>

<ul>
	<li id="cp-name-is-prototype">
名前は `prototype^l
</li>
	<li>
値は
`~ifc原型~obj@
と呼ばれる~obj
— この~objは、その~ifc上に定義される［
`正則~属性$, `正則~演算$
］のそれぞれに対応する~propを持つ。
詳細は
`interface-prototype-object$sec
にて述べる。
</li>
	<li id="cp-has-attr-FFF">
属性 `FFF^desc を持つ
</li>
</ul>

◎
An interface object for a non-callback interface MUST have a property named “prototype” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } whose value is an object called the interface prototype object. This object has properties that correspond to the regular attributes and regular operations defined on the interface, and is described in more detail in section 4.6.4 below.
</div>

<div class="note"><p>
非~呼戻~ifcに対応する~ifc~objは `関数~obj$なので、
`typeof^c 演算子が その種の~ifc~objに適用されるときには，
"`function^v" を返すようになることも意味する。
◎
Since an interface object for a non-callback interface is a function object the typeof operator will return "function" when applied to such an interface object.
</p></div>

<p>
呼戻~ifcに対応する~ifc~objの `Prototype^es 内的~propは、
Object.prototype ~objで~MUST。
◎
The internal [[Prototype]] property of an interface object for a callback interface MUST be the Object.prototype object.
</p>

<div class="note v2"><p>
呼戻~ifcに対応する~ifc~objが存在するのは，その`~ifc$上に`定数$が宣言されている場合に限られることに留意。
存在する場合、それらは関数~objではない。
◎
Remember that interface objects for callback interfaces only exist if they have constants declared on them; when they do exist, they are not function objects.
</p></div>


				<section id="es-interface-call">
<h5 title="Interface object [[Call]] method">4.6.1.1. ~ifc object `Call^es ~meth</h5>



<p>
`~ifc$が `Constructor$x `拡張属性$（構築子）を伴って宣言されている場合、
その`~ifc~obj$は，その~ifcを実装する~objを作成する関数として~callし得るものになる。
構築子を持たない~ifcが関数として~callされた場合は，例外が投出されることになる。
◎
If the interface is declared with a [Constructor] extended attribute, then the interface object can be called as a function to create an object that implements that interface. Interfaces that do not have a constructor will throw an exception when called as a function.
</p>

<p>
`~ifc~obj$の `Call^es 内的~methは、
%arg<sub>0..%n−1</sub> を構築子に渡された引数~値の~list,
%I を対応する`~ifc$とするとき，次の様に挙動する：
◎
The internal [[Call]] method of the interface object behaves as follows, assuming arg0..n−1 is the list of argument values passed to the constructor, and I is the interface:
</p>

<ol class="algorithm">
	<li>
~IF
%I は `Constructor$x `拡張属性$を伴って宣言されていない
~THEN
~THROW `TypeError^t
◎
If I was not declared with a [Constructor] extended attribute, then throw a TypeError.
</li>
	<li>
%id := %I の識別子
◎
Let id be the identifier of interface I.
</li>
	<li id="cp-call-method1">
%S :← %I 上の［
`識別子$ %id,
引数個数 %n
］の構築子からなる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for constructors with identifier id on interface I and with argument count n.
</li>
	<li id="cp-call-method2">
&lt;%constructor, %values&gt; := 
%S と %arg<sub>0..%n−1</sub> を`多重定義~解決~algo$に渡した結果
◎
Let &lt;constructor, values&gt; be the result of passing S and arg0..n−1 to the overload resolution algorithm.
</li>
	<li id="cp-call-method3">
%R := %values を一連の引数~値として， %constructor の記述に挙げられている手続きを遂行した結果
◎
Let R be the result of performing the actions listed in the description of constructor with values as the argument values.
</li>
	<li id="cp-call-method4">
~RET %R を型 %I の ECMAScript `~ifc型$ 値に`toES^した結果
◎
Return the result of converting R to an ECMAScript interface type value I.
</li>
</ol>

<p>
`~ifc~obj$の `Call^es 内的~methが返す値は、~ifc %I を実装する~objで~MUST。
この~objは~ifc~objが属する ECMAScript 大域環境にも結付けられてい~MUST。
◎
If the internal [[Call]] method of the interface object returns normally, then it MUST return an object that implements interface I. This object also MUST be associated with the ECMAScript global environment associated with the interface object.
</p>

<div class="p">
<p>
呼戻でない~ifc %I に対応する~ifc~objは、次のように特徴付けられる~propを持た~MUST：
</p>

<ul>
	<li>
名前は `length^l
</li>
	<li id="cp-has-attr-FFT">
属性 `FFT^desc を持つ
</li>
	<li>
値は 下に与える手続きから決定される `Number^t 値
</li>
</ul>

◎
Interface objects for non-callback interfaces MUST have a property named “length” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } whose value is a Number. If the [Constructor] extended attribute does not appear on the interface definition, then the value is 0. Otherwise, the value is determined as follows:
</div>

<ol class="algorithm">
	<li>
~IF
%I の定義には `Constructor$x 拡張属性は現れない
~THEN
~RET 0
◎
↑</li>

	<li>
%id := ~ifc %I の識別子
◎
Let id be the identifier of interface I.
</li>
	<li id="cp-constructor-overload1">
%S :← `~ifc$ %I 上の［
`識別子$ %id,
引数個数 0
］の構築子からなる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for constructors with identifier id on interface I and with argument count 0.
</li>
	<li id="cp-constructor-overload2">
~RET %S の中の~entryの引数~listの長さのうち，最小の長さ
◎
Return the length of the shortest argument list of the entries in S.
</li>
</ol>

<div class="p v2">
<p>
どの~ifc~objも、次のように特徴付けられる~propを持た~MUST：
<ul>
	<li>
名前は `name^l
</li>
	<li>
値は 対応する~ifcの識別子
</li>
	<!--cp-has-attr-FFT-->
</ul>

◎
All interface objects MUST have a property named “name” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } whose value is the identifier of the corresponding interface.
</div>


				</section>
				<section id="es-interface-hasinstance">
<h5 title="Interface object [[HasInstance]] method">4.6.1.2. ~ifc object `HasInstance^es ~meth</h5>

<p>
どの~ifc~obj %A に対しても，その `HasInstance^es 内的~methは、
%V をその引数とするとき，次の様に挙動し~MUST：
◎
The internal [[HasInstance]] method of every interface object A MUST behave as follows, assuming V is the object argument passed to [[HasInstance]]:
</p>

<ol>
	<li>
~IF
%V は ~objでない
~THEN
~RET `false^v
◎
If V is not an object, return false.
</li>
	<li>
%O := ~prop名 `prototype^l により， %A の `Get^es ~methを~callした結果
◎
Let O be the result of calling the [[Get]] method of A with property name “prototype”.
</li>
	<li>
~IF
%O は ~objでない
~THEN
~THROW `TypeError^t
◎
If O is not an object, throw a TypeError exception.
</li>
	<li>
~IF
%V は［
%O を`~ifc原型~obj$に持つ`~ifc$
］を実装する`~platform~obj$である
~THEN
~RET `true^v
◎
If V is a platform object that implements the interface for which O is the interface prototype object, return true.
</li>
	<li>
<p>
~WHILE ~T：
◎
Repeat:
</p>
		<ol>
			<li>
%V ← %V の `Prototype^es 内的~propの値
◎
Set V to the value of the [[Prototype]] internal property of V.
</li>
			<li>
~IF
%V ＝ `null^v
~THEN
~RET `false^v
◎
If V is null, return false.
</li>
			<li>
~IF
%O と %V が同じ~objを指している
~THEN
~RET `true^v
◎
If O and V refer to the same object, return true.
</li>
		</ol>
	</li>
</ol>



				</section>
			</section>
			<section id="named-constructors">
<h4 title="Named constructors">4.6.2. 有名~構築子</h4>


<p>
`有名~構築子$は、`識別子$（ %id とする）を伴う１個~以上の
`NamedConstructor$x `拡張属性$により 存在することになる，`関数~obj$である。
それは、その拡張属性が現れる`~ifc$（ %I とする）を実装する~objの構築を可能にする， `Call^es 内的~prop を持た~MUST。
それは、
%arg<sub>0..%n−1</sub> を構築子に渡された引数~値の~listとするとき，次の様に挙動する：
◎
A named constructor that exists due to one or more [NamedConstructor] extended attributes with a given identifier is a function object. It MUST have a [[Call]] internal property, which allows construction of objects that implement the interface on which the [NamedConstructor] extended attributes appear. It behaves as follows, assuming arg0..n−1 is the list of argument values passed to the constructor, id is the identifier of the constructor specified in the extended attribute named argument list, and I is the interface on which the [NamedConstructor] extended attribute appears:
</p>

<ol class="algorithm">
	<!--cp-call-method1-->
	<!--cp-call-method2-->
	<!--cp-call-method3-->
	<!--cp-call-method4-->
</ol>

<p><!-- copy* -->
`有名~構築子$の `Call^es 内的~methが返す値は、~ifc %I を実装する~objで~MUST。
この~objは、その`有名~構築子$が属する ECMAScript 大域環境に属してい~MUST。
◎
If the internal [[Call]] method of the named constructor returns normally, then it MUST return an object that implements interface I. This object also MUST be associated with the ECMAScript global environment associated with the named constructor.
</p>

<div class="p">
<p>
有名~構築子は、次のように特徴付けられる~propを持た~MUST：
</p>

<ul>
	<li>
名前は `length^l
</li>
	<!--cp-has-attr-FFT-->
	<li>
値は、次に与える手続きから決定される `Number^t
</li>
</ul>
◎
A named constructor MUST have a property named “length” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } whose value is a Number determined as follows:
</div>

<ol class="algorithm">
	<!--cp-constructor-overload1-->
	<!--cp-constructor-overload2-->
</ol>


<div class="p v2">

<p>
有名~構築子は、次のように特徴付けられる~propを持た~MUST：
</p>

<ul>
	<li>
名前は `name^l
</li>
	<li>
値は 構築子に利用されている識別子。
</li>
	<!--cp-has-attr-FFT-->
</ul>

◎
A named constructor MUST have a property named “name” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } whose value is the identifier used for the named constructor.
</div>

<div class="p">

<p>
有名~構築子は、次のように特徴付けられる~propも持た~MUST：
</p>
<ul>
	<!--cp-name-is-prototype-->
	<li>
値は `NamedConstructor$x `拡張属性$が現れた`~ifc$に対応する`~ifc原型~obj$。
</li>
	<!--cp-has-attr-FFF-->
</ul>

◎
A named constructor MUST also have a property named “prototype” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } whose value is the interface prototype object for the interface on which the [NamedConstructor] extended attribute appears.
</div>

			</section>
			<section id="es-dictionary-constructors" class="v2">
<h4 title="Dictionary constructors">4.6.3. 辞書~構築子</h4>

<div class="p">
<p>
１個~以上の `Constructor$x `拡張属性$を持ち, かつ
所与の ECMAScript 大域環境にて`公開され$ているような，どの`辞書$型に対しても、次のように特徴付けられる~propが，その大域環境の大域~obj上に存在し~MUST：
</p>

<ul>
	<li>
名前は その辞書の`識別子$
</li>
	<li>
値は
`辞書~構築子@
と呼ばれる`関数~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
For every dictionary type that has one or more [Constructor] extended attributes and which is exposed in a given ECMAScript global environment, a corresponding property MUST exist on the ECMAScript environment's global object. The name of the property is the identifier of the dictionary, and its value is a function object called the dictionary constructor.
◎
The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</div>

<p>
その`~ifc~obj$の `Call^es 内的~methは、［
%arg<sub>0..%n−1</sub> を構築子に渡された引数~値の~list,
%D をその`辞書$型
］とするとき，次の様に挙動する：
◎
The internal [[Call]] method of the interface object behaves as follows, assuming arg0..n−1 is the list of argument values passed to the constructor, and D is the dictionary type:
</p>

<ol class="algorithm">
	<li>
%id := %D の識別子
◎
Let id be the identifier of dictionary type D.
</li>

	<li>
%S :← %D 上の［
`識別子$ %id,
引数個数 %n
］の構築子からなる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for constructors with identifier id on dictionary type D and with argument count n.
</li>

	<!--cp-call-method2-->
	<!--cp-call-method3-->
	<li>
~RET %R を［
型 %D の ECMAScript 辞書~値
］に`toES^した結果
◎
Return the result of converting R, which is a dictionary value of type D, to an ECMAScript value.
</li>

</ol>


<p>
`有名~構築子$の `Call^es 内的~methが返す値は、［
`辞書~構築子$が属する ECMAScript 大域環境
］に属する~objで~MUST。
◎
If the internal [[Call]] method of the named constructor returns normally, then it MUST return an object that is associated with the ECMAScript global environment associated with the dictionary constructor.
</p>

<div class="p">
<p>
辞書~構築子~objは、次のように特徴付けられる~propを持た~MUST：
</p>

<ul>
	<li>
名前は `length^l
</li>
	<!--cp-has-attr-FFT-->
	<li>
値は 下に与える手続きにより決定される `Number^t
</li>
</ul>
◎
A dictionary constructor object MUST have a property named “length” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } whose value is a Number determined as follows:
</div>


<ol class="algorithm">
	<li>
%id := その辞書~型の識別子
◎
Let id be the identifier of the dictionary type.
</li>

	<li>
%S :← その辞書~型~上の［
`識別子$ %id,
引数個数 0
］の構築子からなる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for constructors with identifier id on dictionary D and with argument count 0.
</li>

	<!--cp-constructor-overload2-->
</ol>

<div class="p">
<p>
辞書~構築子~objは、次のように特徴付けられる~propを持た~MUST：
</p>

<ul>
	<li>
名前は `name^l
</li>
	<li>
値は その辞書の識別子
</li>
	<!--cp-has-attr-FFT-->
</ul>
◎
A dictionary constructor object MUST have a property named “name” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } whose value is the identifier of the dictionary.
</div>


			</section>
			<section id="interface-prototype-object">
<h4 title="Interface prototype object">4.6.4. ~ifc原型~obj</h4>


<p>
定義されたどの非~呼戻`~ifc$に対しても、その~ifcが `NoInterfaceObject$x `拡張属性$を伴って宣言されたかどうかに関わらず，対応する`~ifc原型~obj$が存在し~MUST。
個々の~ifcに対し，その~ifc原型~objは、その~ifc上に定義される［
`正則~属性$, `正則~演算$
］のそれぞれに対応する~propを持つ。
これらの~propについての詳細は
`es-attributes$sec, `es-operations$sec
にて述べる。
◎
There MUST exist an interface prototype object for every non-callback interface defined, regardless of whether the interface was declared with the [NoInterfaceObject] extended attribute. The interface prototype object for a particular interface has properties that correspond to the regular attributes and regular operations defined on that interface. These properties are described in more detail in sections 4.6.7 and 4.6.8 below.
</p>

<p>
`~ifc~obj$と同様に，~ifc原型~objも その~ifc上に定義される`定数$に対応する~propを持つ（下の
`es-constants$sec
にて述べる）。
◎
As with the interface object, the interface prototype object also has properties that correspond to the constants defined on that interface, described in section 4.6.6 below.
</p>

<div class="p">
<p>
その~ifc上に `NoInterfaceObject$x 拡張属性が指定されていない場合、その~ifc原型~objは，次のように特徴付けられる~propを持た~MUST：
</p>

<ul>
	<li>
名前は `constructor^l
</li>
	<li>
値は その~ifcに対応する~ifc~objへの参照
</li>
	<!--cp-has-attr-TFT-->
</ul>

◎
If the [NoInterfaceObject] extended attribute was not specified on the interface, then the interface prototype object MUST also have a property named “constructor” with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } whose value is a reference to the interface object for the interface.

</div>


<p>
所与の~ifc %A に対応する`~ifc原型~obj$は、次に与える値をとる， `Prototype^es 内的~propを持た~MUST：
◎
The interface prototype object for a given interface A MUST have an internal [[Prototype]] property whose value is returned from the following steps:
</p>

<ol class="algorithm">
	<li>
%A が
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴って宣言されていて, かつ
`有名~propを~supportする$ならば、下の
`named-properties-object$sec
にて定義される， %A に対応する`有名~prop~obj$
◎
If A is declared with the [Global] or [PrimaryGlobal] extended attribute, and A supports named properties, then return the named properties object for A, as defined in section 4.6.5 below.
</li>
	<li>
<p>
他の場合：
◎
Otherwise,
</p>
		<ol class="algorithm" id="cp-get-proto">
			<li>
%A が別の~ifc %B を継承するように宣言されているならば、
%B に対応する`~ifc原型~obj$
◎
If A is declared to inherit from another interface, then return the interface prototype object for the inherited interface.
</li>

			<li class="v2">
他の場合，
%A が `LegacyArrayClass$x 拡張属性を伴って宣言されているならば、
`ArrayPrototype^ （ `ECMA-262$r 6.1.7.4 節）
◎
Otherwise, if A is declared with the [LegacyArrayClass] extended attribute, then return %ArrayPrototype% ([ECMA-262], section 6.1.7.4).
</li>

			<li class="v2">
他の場合、
`ObjectPrototype^ （ `ECMA-262$r 6.1.7.4 節）
◎
Otherwise, return %ObjectPrototype% ([ECMA-262], section 6.1.7.4).
</li>
		</ol>
	</li>
</ol>

<div class="note">
<p>
`NoInterfaceObject$x `拡張属性$を伴って定義された`~ifc$に対応する`~ifc原型~obj$は、その~ifcが非`追補~ifc$
として利用されているならば~access可能になる。
例えば、次の IDL  では：
◎
The interface prototype object of an interface that is defined with the [NoInterfaceObject] extended attribute will be accessible if the interface is used as a non-supplemental interface. For example, with the following IDL:
</p>

<pre class="idl-code">
[NoInterfaceObject]
interface Foo {
};

partial interface Window {
  attribute Foo foo;
};
</pre>

<p>
`~ifc~obj$を通して
~ifc原型~objに~accessすることはできない（ `window.Foo^c として存在しないので）。
しかしながら、
`Foo^T の~instanceは，その `Prototype^es 内的~prop値の取得 —
この例では， `Object.getPrototypeOf(window.foo)^c
— により，~ifc原型~objを公開し得る。
◎
it is not possible to access the interface prototype object through the interface object (since it does not exist as window.Foo). However, an instance of Foo can expose the interface prototype object by gettings its internal [[Prototype]] property value – Object.getPrototypeOf(window.foo) in this example.
</p>

<p>
~ifcがもっぱら`追補~ifc$として利用されている場合、その~ifc原型~objを `Prototype^es 内的~propの値にとる~objは存在しないので、~ifc原型~objに~accessする仕方はないことになる。
そのような場合、この~objが存在しないことは，受容し得る最適化になる。
◎
If the interface is used solely as a supplemental interface, then there will be no way to access its interface prototype object, since no object will have the interface prototype object as its internal [[Prototype]] property value. In such cases, it is an acceptable optimization for this object not to exist.
</p>
</div>

<div class="v2 L2">

<div class="p">
<p>
~ifcのいずれかの`広義~帰結~ifc$が，［
`Unscopable$x 拡張属性を伴って宣言された`~ifc~mb$
］を持つ場合（そのような~mbからなる集合を %M とする）、その~ifc原型~obj上には，次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `unscopables_symbol^ ~symbol
</li>
	<li>
値は 次の手続きで作成される~obj
</li>
</ul>
◎
If the interface or any of its consequential interfaces has any interface member declared with the [Unscopable] extended attribute, then there MUST be a property on the interface prototype object whose name is the @@unscopables symbol and whose value is an object created as follows:
</div>

<ol class="algorithm">
	<li>
%object := 式 `({})^c により作成されるものと同じ，新たな~obj
◎
Let object be a new object created as if by the expression ({}).
</li>

	<li>
%M 内の各 %m に対し：
( ~prop名 %m の`識別子$, ~pdesc `TTT-T^desc, 真偽~flag `false^v )
を引数に，
%object の `DefineOwnProperty^es ~methを~callする
◎
For each of the aforementioned interface members declared with the [Unscopable] extended attribute, call the [[DefineOwnProperty]] method of object passing the identifier of the interface member as the property name, Property Descriptor { [[Value]]: true, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and false.
</li>
	<li>
~RET %object
◎
Return object.
</li>
</ol>

</div>


<p>
`~ifc原型~obj$の `~class文字列$は［
`~ifc$の`識別子$,
文字列 `Prototype^l 
］の連結である。
◎
The class string of an interface prototype object is the concatenation of the interface’s identifier and the string “Prototype”.
</p>
			</section>
			<section id="named-properties-object">
<h4 title="Named properties object">4.6.5. 有名~prop~obj</h4>


<p>
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴って宣言されていて, かつ
`有名~propを~supportする$
どの`~ifc$に対しても、その~ifcに対応する
`有名~prop~obj@
と呼ばれる~objが存在し~MUST。
◎
For every interface declared with the [Global] or [PrimaryGlobal] extended attribute that supports named properties, there MUST exist an object known as the named properties object for that interface.
</p>

<p>
所与の~ifc %A に対応する`有名~prop~obj$は、次に従って決定される値をとる， `Prototype^es 内的~propを持た~MUST：
◎
The named properties object for a given interface A MUST have an internal [[Prototype]] property whose value is returned from the following steps:
</p>

<!--cp-get-proto-->

<p>
`有名~prop~obj$の `~class文字列$は［
`~ifc$の`識別子$,
文字列 `Properties^l
］の連結である。
◎
The class string of a named properties object is the concatenation of the interface’s identifier and the string “Properties”.
</p>

				<section id="named-properties-object-getownproperty">
<h5 title="Named properties object [[GetOwnProperty]] method">4.6.5.1. 有名~prop~obj `GetOwnProperty^es ~meth</h5>


<p>
どの`有名~prop~obj$についても，その `GetOwnProperty^es 内的~methは［
~obj %O,
~prop名 %P
］を伴って~callされたときには，次の様に挙動し~MUST：
◎
The internal [[GetOwnProperty]] method of every named properties object MUST behave as follows when called with object O and property name P:
</p>

<ol class="algorithm">
	<li>
%A := `有名~prop~obj$ %O に対する`~ifc$
◎
Let A be the interface for the named properties object O.
</li>
	<li>
<p>
%object := %O が属する ECMAScript 大域環境に属する， %A を実装する~~唯一の~obj
<!--  -->
◎
Let object be the sole object from O’s ECMAScript global environment that implements A.
</p>

<div class="note"><p>
例えば，`~ifc$が HTML5 で定義される `Window^T ~ifc
（ `HTML5$r, 5.2 節）
であるならば、この大域環境の window ~objが~~唯一の~objになる。
◎
For example, if the interface is the Window interface as defined in HTML5 ([HTML5], section 5.2), then the sole object will be this global environment’s window object.
</p></div>

</li>
	<li>
<p>
~IF［
( ~prop名 %P, ~obj %object )
を~~入力に，`有名~propの可視性判定~algo$を走らせた結果 ＝ true
⇒
◎
If the result of running the named property visibility algorithm with property name P and object object is true, then:
</p>
		<ol>
			<li>
%operation := `有名~prop取得子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property getter.
</li>

			<li id="cp-let-uninitialized">
%value :← 未初期化の変数
◎
Let value be an uninitialized variable.
</li>
			<li id="cp-determine-ifndef">
~IF
%operation は `識別子$なしに定義されている
~THEN
%value ← ［
名前 %P に対し，~ifcの記述に挙げられている
`有名~propの値を決定する$
手続きを遂行した結果
］
◎
If operation was defined without an identifier, then set value to the result of performing the steps listed in the interface description to determine the value of a named property with P as the name.
</li>
			<li id="cp-set-as-desc1">
~ELSE
~THEN
%value ← ［
( %P )
を引数に， %operation の記述に挙げられている手続きを遂行した結果
］
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the steps listed in the description of operation with P as the only argument value.
</li>

			<li>
<p id="cp-ret-new-desc">
~RET 次の様な新たな
<a href="~ES6#sec-property-descriptor-specification-type">~pdesc</a>
（ `ECMA-262$r 6.2.4 節）：
◎
Let desc be a newly created Property Descriptor ([ECMA-262], section 6.2.4) with no fields.
</p>

<div>
&nbsp;&nbsp; `TET-V^desc — ここで：

				<ul>
					<li id="cp-let-convert2">
%V := %value を ECMAScript 値に`toES^した結果
</li>
					<li>
%E := ［
%A が実装するある~ifcに， `LegacyUnenumerableNamedProperties$x `拡張属性$が伴われているならば `false^v ／
~ELSE_ `true^v
］
</li>
				</ul>

◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If A implements an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then set desc.[[Enumerable]] to false, otherwise set it to true.
◎
Set desc.[[Writable]] to true and desc.[[Configurable]] to true.
◎
Return desc.
</div>
			</li>
		</ol>
	</li>

	<li id="cp-return-GetOwnProperty">
~RET
( %P )
を引数に，
%O 上の
<a href="~ES6#sec-ordinary-object-internal-methods-and-internal-data-properties-getownproperty-p">既定の `GetOwnProperty^es 内的~meth</a>
（ `ECMA-262$r 9.1.5 節）
を~callした結果
◎
Return the result of calling the default [[GetOwnProperty]] internal method ([ECMA-262], section 9.1.5) on O passing P as the argument.
</li>
</ol>

				</section>
				<section id="named-properties-object-defineownproperty">

<h5 title="Named properties object [[DefineOwnProperty]] method">4.6.5.2. 有名~prop~obj `DefineOwnProperty^es ~meth</h5>

<p>
どの`有名~prop~obj$についても，その `DefineOwnProperty^es 内的~methは、［
~obj %O,
~prop名 %P
］を伴って~callされたときには，次の様に挙動し~MUST。
語 
`~REJECT@
は、 ECMA-262 により定義される “Reject” と同じである
— すなわち，
“ %Throw ＝ `true^v ならば `TypeError^t 例外を`投出^し, 他の場合は `false^v を返す”
ことを意味する。
◎
The internal [[DefineOwnProperty]] method of every named properties object MUST behave as follows when called with object O and property name P. The term “Reject” is used in the same sense as that defined in ECMA-262, namely, to mean “If Throw is true, then throw a TypeError exception, otherwise return false”. 
</p>

<ol class="algorithm">
	<li>
~REJECT
◎
Reject.
</li>
</ol>

				</section>
				<section id="named-properties-object-delete">

<h5 title="Named properties object [[Delete]] method">4.6.5.3. 有名~prop~obj `Delete^es ~meth</h5>

<p>
どの`有名~prop~obj$についても，その `Delete^es 内的~methは、［
~obj %O,
~prop名 %P
］を伴って~callされたときには，次の様に挙動し~MUST。
◎
The internal [[Delete]] method of every named properties object MUST behave as follows when called with object O and property name P.
</p>

<ol class="algorithm v2">
	<li>
~RET `false^v
◎
Return false.
</li>
</ol>


				</section>
			</section>
<!-- 
					<div id='mixin-prototype' class='section'>
	<h4>Mixin prototype objects</h4>
...
...
					</div>
-->
			<section id="es-constants">
<h4 title="Constants">4.6.6. 定数</h4>


<p>
`~ifc$上で定義され, かつ`公開され$ている どの`定数$に対しても、次のように特徴付けられる，対応する~propが存在し~MUST：
◎
For each exposed constant defined on an interface A, there MUST be a corresponding property. The property has the following characteristics:
</p>
<ul>
	<li>
名前は 定数の`識別子$。
◎
The name of the property is the identifier of the constant.
</li>

	<li><p id="cp-proploc0">
~propは ~ifcに対する`通例の場所に存在する$。
◎
The location of the property is determined as follows:
• If the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on the single object that implements the interface.
• Otherwise, if the interface is a consequential interface of a [Global]- or [PrimaryGlobal]-annotated interface, then the property exists on the single object that implements the [Global]- or [PrimaryGlobal]-annotated interface as well as on the consequential interface’s interface prototype object.
• Otherwise, the property exists solely on the interface’s interface prototype object.
</p></li>

	<li>
値は 定数の IDL 値を ECMAScript 値に`toES^した結果。
◎
The value of the property is that which is obtained by converting the constant’s IDL value to an ECMAScript value.
</li>
	<li id="cp-has-desc-FTF">
属性 `FTF^desc を持つ。
◎
The property has attributes { [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }.
</li>
</ul>

<p>
加えて、<!-- ~ifcに＊ -->`~ifc原型~obj$が在る場合は、同じ特徴を有する~propが，その~obj上にも存在し~MUST。
◎
In addition, a property with the same characteristics MUST exist on the interface object, if that object exists.
</p>
			</section>
			<section id="es-attributes">
<h4 title="Attributes">4.6.7. 属性</h4>


<p>
`~ifc$において，その いずれかの`広義~帰結~ifc$により `公開され$ている各 `属性$（以下， `属性^ と記す）に対しては、次のように特徴付けられる，対応する~propが存在し~MUST：
◎
For each exposed attribute of the interface, whether it was declared on the interface itself or one of its consequential interfaces, there MUST exist a corresponding property. The characteristics of this property are as follows:
</p>

<ul>
	<li>
名前は `属性^ の`識別子$
◎
The name of the property is the identifier of the attribute.
</li>

	<li>
<p id="cp-proploc">
~propの所在は次の様にして決定される：
◎
The location of the property is determined as follows:
</p>

		<ul>

			<li class="v2">
`属性^ が`静的~属性$である場合、対応する単独の~propが， ~ifcに対する`~ifc~obj$上に存在する。
◎
If the attribute is a static attribute, then there is a single corresponding property and it exists on the interface’s interface object.
</li>
			<li>
他の場合， `属性^ が~ifc上で`偽装不可$であるならば、~propは，
~ifcを実装するどの~obj上にも存在する。
◎
Otherwise, if the attribute is unforgeable on the interface or if the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on every object that implements the interface.
◎
↓</li>
			<li id="cp-exist-normal-loc">
他の場合、~propは ~ifcに対する`通例の場所に存在する$。
◎
↑
◎
Otherwise, if the interface is a consequential interface of a [Global]- or [PrimaryGlobal]-annotated interface, then the property exists on the single object that implements the [Global]- or [PrimaryGlobal]-annotated interface as well as on the consequential interface’s interface prototype object.
◎
Otherwise, the property exists solely on the interface’s interface prototype object.
</li>
		</ul>
	</li>

	<li>
<p>
属性
<span class="descriptor">{&nbsp;[[Get]]: %G, [[Set]]: %S, [[Enumerable]]: `true^v, [[Configurable]]: %configurable&nbsp;}</span>
を持つ。ここで：
◎
The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]: true, [[Configurable]]: configurable }, where:
</p>
		<ul>
			<li>
%configurable は［
`属性^ が `Unforgeable$x 拡張属性を伴って宣言されているならば `false^v ／
~ELSE_ `true^v
］
◎
configurable is false if the attribute was declared with the [Unforgeable] extended attribute and true otherwise;
</li>
			<li>
%G は下で定義される`属性~取得子$
◎
G is the attribute getter, defined below; and
</li>
			<li>
%S は下で定義される`属性~設定子$
◎
S is the attribute setter, also defined below.
</li>
		</ul>
	</li>
</ul>

<p>
`属性~取得子@
は、被呼出時の挙動が次で与えられる， `Function^t ~obj %F である：
◎
The attribute getter is a Function object whose behavior when invoked is as follows:
</p>
<!-- not defined V, O -->
<ol class="algorithm">
	<li>
%idlValue :← IDL 値をとる未初期化の変数
◎
Let idlValue be an IDL value determined as follows.
</li>

	<li>
<p id="cp-if-regular-attr">
~IF
`属性^ は `正則~属性$である
⇒
◎
If the attribute is a regular attribute, then:
</p>
		<ol>
			<li>
<p id="cp-let-I-for-attr">
%I := この（ `属性^ に対応している）~propが`~ifc原型~obj$上に現れるような，`~ifc$
◎
Let I be the interface whose interface prototype object this property corresponding to the attribute appears on.
</p>

<div class="note"><p>
このことは、 `属性^ が`~implements_st$により~ifc上にて可用になったとしても、
%I は `属性^ が元々宣言された方ではなく，~implements_stの左側の~ifcであることを意味する。
◎
This means that even if an implements statement was used to make an attribute available on the interface, I is the interface on the left hand side of the implements statement, and not the one that the attribute was originally declared on.
</p></div>
			</li>

			<li id="cp-let-O-this-value">
%O := `this^v 値
◎
Let O be the this value.
</li>

			<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, %F, `属性^ の`識別子$, `取得子^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function that implements the attribute getter,
• the identifier of the attribute, and
• the type “getter”.
</li>

			<li>
<p>
~IF
%O は %I を実装する`~platform~obj$でない
⇒
◎
If O is not a platform object that implements I, then:
</p>
				<ol>
					<li>
~IF
`属性^ が `LenientThis$x `拡張属性$を伴って指定されている
~THEN
~RET `undefined^v
◎
If the attribute was specified with the [LenientThis] extended attribute, then return undefined.
</li>
					<li>
~ELSE
~THEN
~THROW `TypeError^t
◎
Otherwise, throw a TypeError.
</li>
				</ol>
			</li>

			<li>
%idlValue ← %O を~objとして、［
`属性^，あるいは［
`属性^ がその`取得子を継承-$するように宣言されている場合は，継承された属性
］］の記述に挙げられている，取得~時に生じる手続きを遂行した結果
◎
Set idlValue to be the result of performing the actions listed in the description of the attribute that occur when getting (or those listed in the description of the inherited attribute, if this attribute is declared to inherit its getter), with O as the object.
</li>
		</ol>
	</li>

	<li class="v2">
~ELSE （すなわち `属性^ は`静的~属性$）
~THEN
%idlValue ← `属性^ の記述に挙げられている，取得~時に生じる手続きを遂行した結果
◎
Otherwise, the attribute is a static attribute. Set idlValue to be the result of performing the actions listed in the description of the attribute that occur when getting.
</li>

	<li>
~RET %idlValue を ECMAScript 値に`toES^した結果
◎
Let V be the result of converting idlValue to an ECMAScript value.
◎
Return V.
</li>
</ol>

<p id="cp-length-is-0">
この `Function^t ~objの `length^l ~propの値は、 `Number^t 値 `0^v である。
◎
The value of the Function object’s “length” property is the Number value 0.
</p>

<p>
この `Function^t ~objの `name^l ~propの値は、［
`get^l , 属性の識別子
］を連結して得られる `String^t 値である。
◎
The value of the Function object’s “name” property is a String whose value is the concatenation of “get ” and the identifier of the attribute.
</p>

<p>
`属性~設定子@
は、 `属性^ の宣言に `readonly^c が伴われていて, かつ［
`PutForwards$x, `Replaceable$x
］のいずれの`拡張属性$も伴われていない場合、 `undefined^v である。
他の場合、被呼出時の挙動が次で与えられる， `Function^t ~obj %F である：
◎
The attribute setter is undefined if the attribute is declared readonly and has neither a [PutForwards] nor a [Replaceable] extended attribute declared on it. Otherwise, it is a Function object whose behavior when invoked is as follows:
</p>
<ol class="algorithm">

	<li>
~IF
%F に引数が渡されていない
~THEN
~THROW `TypeError^t
◎
If no arguments were passed to the Function, then throw a TypeError.
</li>

	<li>
%V := %F に渡された第一~引数の値
◎
Let V be the value of the first argument passed to the Function.
</li>


	<li>
<!--cp-if-regular-attr-->

		<ol>
			<li><!--cp-let-I-for-attr--></li>
			<!--cp-let-O-this-value-->

			<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, %F, 属性の`識別子$, `設定子^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function that implements the attribute setter,
• the identifier of the attribute, and
• the type “setter”.
</li>

			<li>
%validThis := ［
%O が %I を実装する`~platform~obj$ならば
`true^v ／
~ELSE_ `false^v
］
◎
Let validThis be true if O is a platform object that implements I, or false otherwise.
</li>

			<li>
~IF［
%validThis ＝ `false^v
］~AND［
`属性^ は `LenientThis$x `拡張属性$を伴って指定されていない
］
~THEN
~THROW `TypeError^t
◎
If validThis is false and the attribute was not specified with the [LenientThis] extended attribute, then throw a TypeError.
</li>

			<li>
<p>
~IF
`属性^ は `Replaceable$x 拡張属性を伴って宣言されている
⇒
◎
If the attribute is declared with a [Replaceable] extended attribute, then:
</p>
				<ol>
					<li>
%P := `属性^ の識別子
◎
Let P be the identifier of the attribute.
</li>
					<li>
( ~prop名 %P, ~pdesc `TTT-V^desc, 真偽~flag `false^v )
を引数に，
%O の `DefineOwnProperty^es ~methを~callする
◎
Call the [[DefineOwnProperty]] method of O passing property name P, Property Descriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }, and false.
</li>
					<li>
~RET `undefined^v
◎
Return undefined.
</li>
				</ol>
			</li>

			<li>
~IF
%validThis ＝ `false^v
~THEN
~RET `undefined^v
◎
If validThis is false, then return undefined.
</li>

			<li>
<p>
~IF
`属性^ は `PutForwards$x 拡張属性を伴って宣言されている：
◎
If the attribute is declared with a [PutForwards] extended attribute, then:
</p>
				<ol>
					<li>
%Q := `属性^ の識別子を~prop名に利用して， %O 上の `Get^es ~methを~callした結果
◎
Let Q be the result of calling the [[Get]] method on O using the identifier of the attribute as the property name.
</li>
					<li>
~IF
%Q は ~objでない
~THEN
~THROW `TypeError^t
◎
If Q is not an object, then throw a TypeError.
</li>
					<li>
%A := `PutForwards$x 拡張属性により識別される属性
◎
Let A be the attribute identified by the [PutForwards] extended attribute.
</li>
					<li>
%A の識別子を~prop名に, %V を値に利用して，
%Q 上の `Put^es ~methを~callする
◎
Call the [[Put]] method on Q using the identifier of A as the property name and V as the value.
</li>
					<li>
~RET `undefined^v
◎
Return undefined.
</li>
				</ol>
			</li>
		</ol>
	</li>

	<li>
<p>
%idlValue := 次で決定される IDL 値：
◎
Let idlValue be an IDL value determined as follows:
</p>
		<ul>
			<li>
<p>
~IF
`属性^ の型は `列挙$である
⇒
◎
If the type of the attribute is an enumeration, then:
</p>
				<ol>
					<li>
%S := `ToString$A( %V )
◎
Let S be the result of calling ToString(V).
</li>
					<li>
~IF
%S は `列挙~値$のいずれでもない
~THEN
~RET `undefined^v
◎
If S is not one of the enumeration’s values, then return undefined.
</li>
					<li>
%idlValue は %S に等しい列挙~値
◎
The value of idlValue is the enumeration value equal to S.
</li>
				</ol>
			</li>
			<li>
~ELSE
~THEN
%idlValue は %V を IDL 値に`toIDL^した結果
◎
Otherwise, the type of the attribute is not an enumeration. The value of idlValue is the result of converting V to an IDL value.
</li>
		</ul>
	</li>

	<li>
%idlValue を値として, 加えて［
`属性^ が`正則~属性$であるならば %O を~objとして
］， `属性^ の設定が生じる際の記述に挙げられている手続きを遂行する
◎
If the attribute is a regular attribute, then perform the actions listed in the description of the attribute that occur when setting, with O as the object and idlValue as the value.
◎
Otherwise, the attribute is a static attribute. Perform the actions listed in the description of the attribute that occur when setting with idlValue as the value.
</li>

	<li>
~RET `undefined^v
◎
Return undefined.
</li>
</ol>

<p id="cp-length-is-1">
この `Function^t ~objの `length^l ~propの値は、 `Number^t 値 `1^v である。
◎
The value of the Function object’s “length” property is the Number value 1.
</p>

<p>
この `Function^t ~objの `name^l ~propの値は、［
`set^l , 属性の識別子
］を連結して得られる `String^t 値である。
◎
The value of the Function object’s “name” property is a String whose value is the concatenation of “set ” and the identifier of the attribute.
</p>



<div class="note"><p>
１個の IDL 属性に対応する~propは【~~通常は】１個に限られるが、~accessor~prop［
取得子／設定子
］には，［［
その IDL 属性に対応する~prop
］が~accessされた
］~objを指す `this^v 値が渡されるので、それらの~propは，~instance特有の~dataを公開できる。
◎
Although there is only a single property for an IDL attribute, since accessor property getters and setters are passed a this value for the object on which property corresponding to the IDL attribute is accessed, they are able to expose instance-specific data.
</p></div>

<div class="note"><p>
`読専$`属性$に対応する~propへの代入を試みた結果は、それを行う~scriptが strict mode であるかどうかに依存して異なる挙動になることに注意。
strict mode の場合、その種の代入により `TypeError^t が投出されることになる。
strict mode でない場合、代入の試みは無視されることになる。
◎
Note that attempting to assign to a property corresponding to a read only attribute results in different behavior depending on whether the script doing so is in strict mode. When in strict mode, such an assignment will result in a TypeError being thrown. When not in strict mode, the assignment attempt will be ignored.
</p></div>

			</section>
			<section id="es-operations">
<h4 title="Operations">4.6.8. 演算</h4>

<p>
`~ifc$上に定義され, かつ`公開され$ている`演算$の各~一意な`識別子$ごとに、次のように特徴付けられる，対応する~propが存在し~MUST
—
ただし、［
その`識別子$,
引数個数 0
］の`演算$からなる`有効~多重定義~集合$が空~集合である場合
<span class="trans-note">【
要するに演算が識別子を伴わない場合？
】</span>
は除く（以下，当の演算を `演算^ と記す）：
◎
For each unique identifier of an exposed operation defined on the interface, there MUST exist a corresponding property, unless the effective overload set for that identifier and operation and with an argument count of 0 has no entries.
◎
The characteristics of this property are as follows:
</p>

<ul>
	<li>
名前は `演算^ の`識別子$
◎
The name of the property is the identifier.
</li>

	<li>
<!--cp-proploc-->
		<ul>
			<li>
`演算^ が`静的~演算$である場合、~propは ~ifcに対する`~ifc~obj$上に存在する。
◎
If the operation is static, then the property exists on the interface object.
</li>

			<li><!-- copy* -->
他の場合， `演算^ が~ifc上で`偽装不可$であるならば、~propは，~ifcを実装するどの~obj上にも存在する。
◎
Otherwise, if the operation is unforgeable on the interface or if the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on every object that implements the interface.
◎
↓</li>
			<!--cp-exist-normal-loc-->
		</ul>
	</li>

	<li>
属性 `BTB^desc を持つ。
ここで %B は［
`演算^ が~ifc上で`偽装不可$である場合は `false^v ／
~ELSE_ `true^v
］である。
◎
The property has attributes { [[Writable]]: B, [[Enumerable]]: true, [[Configurable]]: B }, where B is false if the operation is unforgeable on the interface, and true otherwise.
</li>
	<li id="cp-value-is-a-func-F">
値は 下に与える `Function^t ~obj %F 。
◎
↓</li>
</ul>

<p>
`演算^ を実装する %F は、［
%id := `識別子$,
%arg<sub>0..%n−1</sub> := 関数に渡す引数~値の~list
］を渡したときに，次の様に挙動し~MUST：
◎
The value of the property is a Function object whose behavior is as follows, assuming id is the identifier, arg0..n−1 is the list of argument values passed to the function:
</p>


<ol class="algorithm">
	<li>
<p id="cp-try-steps">
~TRY：
◎
Try running the following steps:
</p>
		<ol>
			<li>
<p>
%I := この（ `演算^ に対応している）~propが`~ifc原型~obj$上（静的~演算の場合は`~ifc~obj$上）に現れるような，`~ifc$
◎
Let I be the interface whose interface prototype object (or interface object, for a static operation) this property corresponding to the operation appears on.
</p>

<div class="note"><p>
このことは、 `演算^ が`~implements_st$により~ifc上にて可用になったとしても、
%I は `演算^ が元々宣言された方ではなく，~implements_stの左側の~ifcであることを意味する。
◎
This means that even if an implements statement was used to make an operation available on the interface, I is the interface on the left hand side of the implements statement, and not the one that the operation was originally declared on.
</p></div>
			</li>
			<li>
<p>
%O := 次で定まる値：
◎
Let O be a value determined as follows:
</p>
<!-- ❖changed ul → ol -->
				<ol>
					<li>
~IF
`演算^ は 静的~演算である
~THEN
%O ← `null^v
◎
If the operation is a static operation, then O is null.
</li>
					<li class="L2">
~ELIF［
`演算^ が現れる`~ifc$は
`ImplicitThis$x `拡張属性$を持つ
］~AND［
`this^v 値 ~IN { `null^v, `undefined^v }
］
~THEN
%O ← `Function^t ~objに結付けられている ECMAScript 大域~obj
◎
Otherwise, if the interface on which the operation appears has an [ImplicitThis] extended attribute, and the this value is null or undefined, then O is the ECMAScript global object associated with the Function object.
</li>
					<li>
~ELIF
`this^v 値 ≠ `null^v
~THEN
%O ← その `this^v 値
◎
Otherwise, if the this value is not null, then O is the this value.
</li>
					<li><!-- copy -->
~ELSE
~THEN
~THROW `TypeError^t
◎
Otherwise, throw a TypeError.
</li>
				</ol>
			</li>

			<li><!-- copy* -->
~IF
%O は `~platform~obj$である
~THEN
( %O, %F, `演算^ の`識別子$, `~meth^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function that implements the operation,
• the identifier of the operation, and
• the type “method”.
</li>

			<li>
~IF［
%O ≠ `null^v
］~AND［
%O は ~ifc %I を実装する`~platform~obj$でない
］
~THEN
~THROW `TypeError^t
◎
If O is not null and is also not a platform object that implements interface I, throw a TypeError.
</li>
			<li><!-- copy* -->
%S := `~ifc$ %I 上の，［
`識別子$ %id,
引数個数 %n
］の［
`演算^ が正則~演算である場合は`正則~演算$ ／
静的~演算である場合は`静的~演算$
］からなる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for regular operations (if the operation is a regular operation) or for static operations (if the operation is a static operation) with identifier id on interface I and with argument count n.
</li>
			<li id="cp-let-resolution">
&lt;%operation, %values&gt; :=
%S と %arg<sub>0..%n−1</sub> を`多重定義~解決~algo$に渡した結果
◎
Let &lt;operation, values&gt; be the result of passing S and arg0..n−1 to the overload resolution algorithm.
</li>
			<li>
%R := 
( %values )
を引数に，
%operation の記述に挙げられている手続きを（ `演算^ が静的~演算でないならば %O 上で）遂行した結果
◎
Let R be the result of performing (on O, if the operation is not a static operation) the actions listed in the description of operation with values as the argument values.
</li>
			<li>
~RET %R を［
`演算^ の返値に宣言された型
］の ECMAScript 値に`toES^した結果
◎
Return the result of converting R to an ECMAScript value of the type op is declared to return.
</li><!-- op -->
		</ol>
	</li>
	<li class="v2">
<p id="cp-catch-ex">
~CATCH：
◎
And then, if an exception was thrown:
</p>
		<ol>
			<li>
<p id="cp-ret_t-is-promise">
~IF
`演算^ の`返値型$は `~promise型$である
⇒
◎
If the operation has a return type that is a promise type, then:
</p>
				<ol id="cp-promise-reject">
					<li>
%reject := `Promise^.reject の初期~値
◎
Let reject be the initial value of %Promise%.reject.
</li>
					<li>
~RET ［
`this^v ~objとして `Promise^,
単独の引数として `投出された例外$
］を渡して， %reject を~callした結果
◎
Return the result of calling reject with %Promise% as the this object and the exception as the single argument value.
</li>

				</ol>
			</li>
			<li id="cp-else-rethrow">
~THROW `投出された例外$
◎
Otherwise, end these steps and allow the exception to propagate.
</li>

		</ol>
	</li>
</ol>

<p>
この `Function^t object の `length^l ~propの値は、次の様にして決定される `Number^t である：
◎
The value of the Function object’s “length” property is a Number determined as follows:
</p>

<ol class="algorithm">
	<li><!-- copy* -->
%S := `~ifc$ %I 上の，［
`識別子$ %id,
引数個数 0
］の［
`演算^ が正則~演算である場合は`正則~演算$ ／
静的~演算である場合は`静的~演算$
］からなる`有効~多重定義~集合$
◎
Let S be the effective overload set for regular operations (if the operation is a regular operation) or for static operations (if the operation is a static operation) with identifier id on interface I and with argument count 0.
</li>
	<!--cp-constructor-overload2-->
</ol>


<p>
この `Function^t ~objの `name^l ~propの値は、演算の識別子による `String^t 値である。
◎
The value of the Function object’s “name” property is a String whose value is the identifier of the operation.
</p>


				<section id="es-stringifier">
<h5 title="Stringifiers">4.6.8.1. 文字列化子</h5>

<p>
`~ifc$が`公開され$ている`文字列化子$（以下 `文字列化子^ と記す）を持つ場合、次のように特徴付けられる~propが存在し~MUST：
◎
If the interface has an exposed stringifier, then there MUST exist a property with the following characteristics:
</p>

<ul>
	<li id="cp-name-is-tostr">
名前は `toString^l
◎
The name of the property is “toString”.
</li>

	<li><!-- copy* -->
~propの所在は：
`文字列化子^ が~ifc上で`偽装不可$であるか, または
~ifcが
`Global$x ／ `PrimaryGlobal$x
拡張属性を伴って宣言されているならば、~ifcを実装するどの~obj上にも存在する。
他の場合、~ifcの`~ifc原型~obj$上に存在する。
◎
If the stringifier is unforgeable on the interface or if the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on every object that implements the interface. Otherwise, the property exists on the interface prototype object.
</li>

	<li>
属性 `BTB^desc を持つ。
ここで %B は［
`文字列化子^ が~ifc上で`偽装不可$である場合は `false^v ／
~ELSE_ `true^v
］である。
◎
The property has attributes { [[Writable]]: B, [[Enumerable]]: true, [[Configurable]]: B }, where B is false if the stringifier is unforgeable on the interface, and true otherwise.
</li>

	<li>
値は 下に与える `Function^t ~obj %F 。
◎
↓</li>
</ul>

<p>
~prop値 %F は、被呼出時には次の様に挙動し~MUST：
◎
The value of the property is a Function object, which behaves as follows:
</p>

<ol class="algorithm">
	<li id="cp-call-ToObject">
%O := `this^v 値~上で `ToObject$A を~callした結果
◎
Let O be the result of calling ToObject on the this value.
</li>

	<li><!-- copy* -->
~IF
%O は `~platform~obj$である
~THEN
( %O, %F, `文字列化子^ の`識別子$, `~meth^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function that implements the stringifier,
• the identifier of the stringifier, and
• the type “method”.
</li>

	<li>
~IF
%O は［
`文字列化子^ を宣言する~ifcを実装する~obj
］でない
~THEN
~THROW `TypeError^t
◎
If O is not an object that implements the interface on which the stringifier was declared, then throw a TypeError.
</li>

	<li>
%V :← 未初期化の変数
◎
Let V be an uninitialized variable.
</li>

	<li>
<p>
`stringifier^c が指定されている場所に応じて：
◎
Depending on where stringifier was specified:
</p>
		<dl class="switch">
			<dt>
`属性$上
◎
on an attribute
</dt>
			<dd><!-- copy* -->
%V ← %O を~objとして、［
その属性, あるいは［
その属性がその`取得子を継承-$するように宣言されている場合は，継承された属性
］］の記述に挙げられている，取得~時に生じる手続きを遂行した結果
◎
Set V to the result of performing the actions listed in the description of the attribute that occur when getting (or those listed in the description of the inherited attribute, if this attribute is declared to inherit its getter), with O as the object.
</dd>

			<dt>
識別子を伴う`演算$上
◎
on an operation with an identifier
</dt>
			<dd>
%V ← %O を `this^v 値として, 引数は渡さずに、その演算の記述に挙げられている手続きを遂行した結果
◎
Set V to the result of performing the actions listed in the description of the operation, using O as the this value and passing no arguments.
</dd>
			<dt>
識別子を伴わない`演算$上
◎
on an operation with no identifier
</dt>
			<dd>
%V ← ~ifcの`文字列化の挙動$を遂行した結果
◎
Set V to the result of performing the stringification behavior of the interface.
</dd>
		</dl>
</li>


	<li>
~RET
%V を `String^t 値に`toES^した結果
◎
Return the result of converting V to a String value.
</li>
</ol>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `toString^l である。
◎
The value of the Function object’s “name” property is the String value “toString”.
</p>

				</section>
				<section id="es-serializer" class="v2">
<h5 title="Serializers">4.6.8.2. 直列化子</h5>

<div class="p">
<p>
`公開され$ている`直列化子$（以下 `直列化子^ と記す）を持つ`~ifc$に対しては、次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `toJSON^l
</li>
	<!--cp-value-is-a-func-F-->
	<li id="cp-has-attr-TTT">
属性 `TTT^desc を持つ
</li>
</ul>

◎
If the interface has an exposed serializer, then a property MUST exist whose name is “toJSON”, with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a Function object.
</div>


<!--cp-proploc0-->

<p>
~prop値 %F は、被呼出時には次の様に挙動し~MUST：
◎
The property’s Function object, when invoked, MUST behave as follows:
</p>

<ol class="algorithm">
	<!--cp-call-ToObject-->
	<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, %F, `直列化子^の`識別子$, `~meth^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function that implements the serializer,
• the identifier of the serializer, and
• the type “method”.
</li>
	<li>
~IF
%O は［
`直列化子^ を宣言する~ifc
］を実装する~objでない
~THEN
~THROW `TypeError^t
◎
If O is not an object that implements the interface on which the serializer was declared, then throw a TypeError.
</li>
	<li>
<p>
`直列化子^ の `serializer^c の指定のされ方に応じて：
◎
Depending on how serializer was specified:
</p>

		<dl class="switch">
			<dt>
識別子を伴う`演算$上に指定されたものである場合
◎
on an operation with an identifier
</dt>
			<dd>
				<ol class="algorithm">
					<li>
~RET %O を `this^v 値に利用して, 引数を渡さずに，演算の記述に挙げられている手続きを遂行した結果
◎
Return the result of performing the actions listed in the description of the operation, using O as the this value and passing no arguments.
</li>
				</ol>
			</dd>
			<dt>
~keywordとして指定されたものである場合
— `直列化~pattern$の有無に関わらず
◎
as a keyword, either with or without a serialization pattern
</dt>
			<dd>
				<ol class="algorithm">
					<li>
%S := ~obj %O に対する~ifcの`直列化の挙動$を呼出した結果の`直列化ed値$
◎
Let S be the serialized value that is the result of invoking the serialization behavior of the interface for object O.
</li>
					<li>
~RET
%S を`直列化値toES^した結果
◎
Return the result of converting S to an ECMAScript value.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>


<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `toJSON^l である。
◎
The value of the Function object’s “name” property is the String value “toJSON”.
</p>

<p>
`直列化ed値から ECMAScript 値に変換-@
する手続きは，次で定義される：
◎
The following steps define how to convert a serialized value to an ECMAScript value:
</p>

<ol class="algorithm">
	<li>
%S := `直列化ed値$
◎
Let S be the serialized value.
</li>
	<li>
<p>
%S の型に応じて：
◎
Depending on the type of S:
</p>

		<dl class="switch">
			<dt>~map◎a map</dt>
			<dd>
				<ol class="algorithm">
					<li>
%O := 式 `({})^c により作成されるものと同じ，新たな~obj
◎
Let O be a new object created as if by the expression ({}).
</li>
					<li>
<p>
~FOR
%S 内の~EACH ( ~entry ) に対し，それらが~mapに追加された順に：
◎
For each entry in S, in the order they were added to the map:
</p>

						<ol>
							<li>
%V := ~entryの~valueを`直列化値toES^した結果
◎
Let V be the result of converting the value of the entry to an ECMAScript value.
</li>
							<li>
%P := ~entryの~key
◎
Let P be the entry’s key.
</li>
							<li>
( ~prop名 %P, ~pdesc `TTT-V^desc, `false^v )
を引数に，
%O の `DefineOwnProperty^es 内的~methを~callする
◎
Call the [[DefineOwnProperty]] internal method of O passing property name P, Property Descriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }, and false as arguments.
</li>
						</ol>
					</li>
					<li>
~RET %O
◎
Return O.
</li>
				</ol>
			</dd>
			<dt>~list◎a list</dt>
			<dd>
				<ol class="algorithm">
					<li>
%A :=
式 `[]^c で作成されるものと同じ，新たな `Array^t ~obj
◎
Let A be a new Array object created as if by the expression [].
</li>
					<li>
%index := 0
◎
Let index be 0.
</li>
					<li>
<p>
~WHILE %index &lt; %S 内の要素~数：
◎
While index is less than the number of elements in S:
</p>

						<ol>
							<li>
%V := %S 内の~index %index に位置する要素の値を`直列化値toES^した結果
◎
Let V be the result of converting the value of the element in S at index index to an ECMAScript value.
</li>
							<li>
%P := `ToString$A( %index )
◎
Let P be ToString(index).
</li>
							<li>
( ~prop名 %P, ~pdesc `TTT-V^desc, `false^v )
を引数に，
%A の `DefineOwnProperty^es 内的~methを~callする
<span class="trans-note">【原文の %O を %A に修正】</span>
◎
Call the [[DefineOwnProperty]] internal method of O passing property name P, Property Descriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }, and false as arguments.
</li>
						</ol>
					</li>
					<li>
~RET %A
◎
Return A.
</li>
				</ol>
			</dd>
			<dt>他の直列化ed値◎any other serialized value</dt>
			<dd>
				<ol class="algorithm">
					<li>
~RET %S を ECMAScript 値に`toES^した結果
◎
Let V be the result of converting S to an ECMAScript value.
◎
Return V.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

				</section>
			</section>
			<section id="es-iterators" class="v2">
<h4 title="Common iterator behavior">4.6.9. 反復子に共通する挙動</h4>

				<section id="es-iterator">
<h5 title="@@iterator">4.6.9.1. ~iterator0</h5>

<p >
所与の`~ifc$が，次のいずれかを持つならば…：
◎
If the interface has any of the following:
</p>

<ul>
	<li>
`可反復~宣言$
◎
an iterable declaration
</li>

	<li>
`有index~prop取得子$, および［
名前 `length^c の，`整数~型$の`属性$
］
◎
an indexed property getter and an integer-typed attribute named “length”
</li>
	<li class="L2">
`~maplike 宣言$
◎
a maplike declaration
</li>
	<li class="L2">
`~setlike 宣言$
◎
a setlike declaration
</li>
</ul>

<div class="p">
<p>
…ならば、次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `~iterator0^l ~symbol
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TFT-->
</ul>

◎
then a property MUST exist whose name is the @@iterator symbol, with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<p id="cp-F-is-given-as-follows">
~prop値 %F は、次で与えられる：
◎
↓</p>

<dl class="switch">
	<dt>
~ifcは `有index~prop取得子$を定義している場合：
◎
↓</dt>
	<dd>
`ArrayProto_values^ （ `ECMA-262$r 6.1.7.4 節）。
◎
If the interface defines an indexed property getter, then the Function object is %ArrayProto_values% ([ECMA-262], section 6.1.7.4).
</dd>

	<dt>
~ifcは`~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then the Function, when invoked, MUST behave as follows:
</dt>
	<dd>
<p id="cp-F-must-behave-as-follows">
被呼出時には次の様に挙動し~MUST：
◎
↑</p>

<ol class="algorithm">
	<li id="cp-let-ToObject-this">
%object := `this^v 値~上の `ToObject$A を~callした結果
◎
Let object be the result of calling ToObject on the this value.
</li>

	<li id="cp-iterator-security-check">
~IF
%object は `~platform~obj$である
~THEN
( %object, %F, `~iterator0^l, `~meth^C )
に対し，`保安検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the ECMAScript global environment associated with this Function,
• the identifier “@@iterator”, and
• the type “method”.
</li>

	<li>
%interface := `可反復~宣言$が宣言されている`~ifc$
◎
Let interface be the interface the iterable declaration is on.
</li>

	<li id="cp-throw-if-not-impl">
~IF
%object は［
%interface を実装する`~platform~obj$
］でない
~THEN
~THROW `TypeError^t
◎
If object is not a platform object that implements interface, then throw a TypeError.
</li>

	<li>
~RET ［
%interface,
~target %object,
反復子の種類 `key+value^C
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind “key+value”.
◎
Return iterator.
</li>
</ol>
	</dd>

	<dt class="L2">
~ifcは `~maplike 宣言$／`~setlike 宣言$を持つ場合：
◎
If the interface has a maplike declaration or setlike declaration, then the Function object that is the value of the @@iterator property, when invoked, MUST behave as follows:
</dt>
	<dd class="L2">
<!--cp-F-must-behave-as-follows-->

<ol class="algorithm">
	<!--cp-let-ToObject-this-->
	<!--cp-iterator-security-check-->
	<li>
~IF
%object は［
`~maplike 宣言$ ／ `~setlike 宣言$
を定義する`~ifc$を実装する`~platform~obj$
］でない
~THEN
~THROW `TypeError^t
◎
If object is not a platform object that implements the interface on which the maplike declaration or setlike declaration is defined, then throw a TypeError.
</li>

	<li>
<p>
~IF
~ifcは`~maplike 宣言$を持つ ⇒
◎
If the interface has a maplike declaration, then:
</p>
		<ol>
			<li>
%backing := %object の `BackingMap^es `internal_slot^の値
◎
Let backing be the value of the [[BackingMap]] internal slot of object.
</li>
			<li>
~RET `CreateMapIterator$A(%backing, `key+value^l)
◎
Return CreateMapIterator(backing, "key+value").
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE ⇒
◎
Otherwise:
</p>
		<ol>
			<li>
%backing := %object の `BackingSet^es `internal_slot^の値
◎
Let backing be the value of the [[BackingSet]] internal slot of object.
</li>
			<li>
~RET `CreateSetIterator$A(%backing, `value^l)
◎
Return CreateSetIterator(backing, "value").
</li>
		</ol>
	</li>
</ol>
	</dd>

</dl>

<p>
%F の `length^l ~propの値は、 `Number^t 値 `0^v である。
◎
The value of the @@iterator Function object’s “length” property is the Number value 0.
</p>

<p>
%F の `name^l ~propの値は、当の~ifcが［［
`~pair反復子$ ／ `~maplike 宣言$
］を持つならば `String^t 値 `entries^l ／
`~setlike 宣言$を持つならば `String^t 値 `values^l
］である。
◎
The value of the @@iterator Function object’s “name” property is the String value “entries” if the interface has a pair iterator or a maplike declaration and the String “values” if the interface has a setlike declaration.
</p>


				</section>
				<section id="es-forEach">
<h5 title="forEach">4.6.9.2. forEach</h5>

<p>
`~ifc$が次のいずれかを持つならば：
◎
If the interface has any of the following:
</p>

<ul>
	<li>
`可反復~宣言$
◎
an iterable declaration
</li>
	<li class="L2">
`~maplike 宣言$
◎
a maplike declaration
</li>
	<li class="L2">
`~setlike 宣言$
◎
a setlike declaration
</li>
</ul>


<div class="p">
<p>
…ならば、次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `forEach^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
then a property named “forEach” MUST exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>
~ifcは `有index~prop取得子$を定義している場合：
◎
↓</dt>
	<dd>
`ArrayProto_values^ （ `ECMA-262$r 6.1.7.4 節）の
`forEach^l ~data-propの初期~値。
◎
If the interface defines an indexed property getter, then the Function object is the initial value of the “forEach” data property of %ArrayPrototype% ([ECMA-262], section 6.1.7.4).
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
</dt>
	<dd>
<p>
［
その~ifcが，その`~pair反復子$を代わりに 次に示す［
`演算$, および注釈文による定義
］を持つと見なしたときに，存在することになるものと同じ~挙動：
◎
If the interface has a pair iterator, then the Function MUST have the same behavior as one that would exist assuming the interface had this operation instead of the iterable declaration:
</p>

<pre class="idl-code">
void forEach(Function %callback, optional any %thisArg);
</pre>

<p>
◎
with the following prose definition:
</p>

<ol class="algorithm">
	<li>
%O := `this^v 値
◎
Let O be the this value.
</li>
	<li>
%pairs := `反復される値~pair$の~list
◎
Let pairs be the list of value pairs to iterate over.
</li>
	<li>
<p>
~FOR
%pairs 内の~EACH ( %pairs ) に対し，順に：
◎
Let i be 0.
◎
While i is less than the length of pairs:
</p>
		<ol>
			<li>
%pair := %pairs 内で~index %i に位置する~entry
◎
Let pair be the entry in pairs at index i.
</li>
			<li>
%key := %pair の~key
◎
Let key be pair’s key.
</li>
			<li>
%value := %pair の値
◎
Let value be pair’s value.
</li>
			<li>
`呼戻 this 値$に %thisArg （引数が渡されなかった場合は `undefined^v ）を,
引数に ( %value, %key, %O ) を渡して，
%callback を<a href="#es-invoking-callback-functions">呼出す</a>
◎
Invoke callback with thisArg (or undefined, if the argument was not supplied) as the callback this value and value, key and O as its arguments.
</li>
			<li>
現在の`反復される値~pair$の~listに %pairs で更新する
◎
Update pairs to the current list of value pairs to iterate over.
◎
Set i to i + 1.
</li>
		</ol>
	</li>
</ol>

	</dd>

	<dt class="L2">
~ifcは `~maplike 宣言$／`~setlike 宣言$を持つ場合：
◎
If the interface has a maplike declaration or setlike declaration then the Function, when invoked, MUST behave as follows:
</dt>
	<dd class="L2">
<!--cp-F-must-behave-as-follows-->

<ol class="algorithm">
	<!--cp-let-ToObject-this-->
	<li>
~IF
%object は `~platform~obj$である
~THEN
( %object, %F, `forEach^l, `~meth^C )
に対し，`保安検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the ECMAScript global environment associated with this Function,
• the identifier “forEach”, and
• the type “method”.
</li>

	<li>
%interface := `~maplike 宣言$／`~setlike 宣言$が宣言されている`~ifc$
◎
Let interface be the interface on which the maplike declaration or setlike declaration is declared.
</li>
	<!--cp-throw-if-not-impl-->
	<li>
%callbackFn := ［
この関数に引数が渡されているならば その第一~引数の値 ／
~ELSE_ `undefined^v
］
◎
Let callbackFn be the value of the first argument passed to the function, or undefined if the argument was not supplied.
</li>
	<li>
~IF
`IsCallable$A( %callbackFn ) ~EQ `false^v
~THEN
~THROW `TypeError^t
◎
If IsCallable(callbackFn) is false, throw a TypeError.
</li>
	<li>
%thisArg := ［
関数に第二~引数が渡されているならば その引数の値 ／
~ELSE `undefined^v
］
◎
Let thisArg be the value of the second argument passed to the function, or undefined if the argument was not supplied.
</li>

	<li>
%backing := ~ifcが［
`~maplike 宣言$ ／ `~setlike 宣言$
］のいずれを持つかに応じて， %object の［
`BackingMap^es ／ `BackingSet^es
］`internal_slot^ の値
◎
Let backing be the value of the [[BackingMap]] internal slot of object, if the interface has a maplike declaration, or the [[BackingSet]] internal slot of object otherwise.
</li>

	<li>
<p>
%callbackWrapper := 被呼出時に次の様に挙動する `Function^t ：
◎
Let callbackWrapper be a Function that, when invoked, behaves as follows:
</p>

		<ol>
			<li>
%v, %k := 順に，関数に渡された 最初の, 第二~引数
◎
Let v and k be the first two arguments passed to the function.
</li>
			<li>
%thisArg := `this^v 値
◎
Let thisArg be the this value.
</li>
			<li>
［
~thisArg: %thisArg,
~argList: ( %v, %k, %object )
］を渡して
%callbackFn の`Call^es 内的~methを~callする
◎
Call the [[Call]] internal method of callbackFn with thisArg as thisArgument and v, k and object as argumentsList.
</li>
		</ol>

<div class="note"><p>
%callbackWrapper 関数は、単純に，第三~引数に %object を渡して ~~入力の %callbackFn を~callする
— その内的［
`BackingMap^es ／ `BackingSet^es
］~objではなく。
◎
The callbackWrapper function simply calls the incoming callbackFn with object as the third argument rather than its internal [[BackingMap]] or [[BackingSet]] object.
</p></div>

<div class="ednote"><p>
~script作者は、［
forEach が~callされる度に， %callbackWrapper が新たな関数になる
］かどうか，観測し得るだろうか？
［
環境を capture <!-- ＊ -->した唯一の関数が在ること
］を指定する仕方として，何が最良になるだろうか？
◎
Can the script author observe that callbackWrapper might be a new function every time forEach is called? What's the best way of specifying that there's only one function that has captured an environment?
</p></div>

	</li>

	<li>
%forEach := 
( `forEach^l, %backing )
を引数に，
%backing の `Get^es~内的~methを~callした結果
◎
Let forEach be the result of calling the [[Get]] internal method of backing with “forEach” and backing as arguments.
</li>
	<li>
~IF
`IsCallable$A( %forEach ) ~EQ `false^v
~THEN
~THROW `TypeError^t
◎
If IsCallable(forEach) is false, throw a TypeError.
</li>
	<li>
［
~thisArg: %backing,
~argList: ( %callbackWrapper, %thisArg )
］を渡して
%forEach の `Call^es 内的~methを~callする
◎
Call the [[Call]] internal method of forEach with backing as thisArgument and callbackWrapper and thisArg as argumentsList.
</li>
	<li>
~RET `undefined^v
◎
Return undefined.
</li>

</ol>

	</dd>
</dl>

<!--cp-length-is-1-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `forEach^l である。
◎
The value of the Function object’s “name” property is the String value “forEach”.
</p>

				</section>
			</section>
			<section id="es-iterable" class="v2">
<h4 title="Iterable declarations">4.6.10. 可反復~宣言</h4>

				<section id="es-iterable-entries">
<h5 title="entries">4.6.10.1. entries</h5>

<div class="p">
<p>
`可反復~宣言$を持つ`~ifc$には、次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `entries^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration, then a property named “entries” MUST exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>~ifcは`値~反復子$を持つ場合：</dt>
	<dd>
`ArrayProto_values^ （ `ECMA-262$r 6.1.7.4 節）の
`entries^l ~data-propの初期~値。
◎
If the interface has a value iterator, then the Function object is the initial value of the “entries” data property of %ArrayPrototype% ([ECMA-262], section 6.1.7.4).
</dd>

	<dt>~ifcは`~pair反復子$を持つ場合：
</dt>
	<dd>
`iterator_symbol^ ~propの値で与えられる `Function^t ~obj。
◎
If the interface has a pair iterator, then the Function object is the value of the @@iterator property.
</dd>
</dl>

				</section>
				<section id="es-iterable-keys">
<h5 title="keys">4.6.10.2. keys</h5>


<div class="p">
<p>
`可反復~宣言$を持つ`~ifc$には、次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `keys^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration, then a property named “keys” MUST exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>~ifcは`値~反復子$を持つ場合：</dt>
	<dd>
`ArrayProto_values^ （ `ECMA-262$r 6.1.7.4 節）の
`keys^l ~data-propの初期~値。
◎
If the interface has a value iterator, then the Function object is the initial value of the “keys” data property of %ArrayPrototype% ([ECMA-262], section 6.1.7.4).
</dd>

	<dt>~ifcは`~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then the Function, when invoked, MUST behave as follows:
</dt>
	<dd>
<!--cp-F-must-behave-as-follows-->

<ol class="algorithm">
	<!--cp-let-ToObject-this-->
	<li>
~IF
%object は `~platform~obj$である
~THEN
( %object, %F, `keys^l, `~meth^C )
に対し，`保安検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the ECMAScript global environment associated with this Function,
• the identifier “keys”, and
• the type “method”.
</li>

	<li id="cp-let-ifc-iterable-declared">
%interface := `可反復~宣言$が宣言されている`~ifc$
◎ 
Let interface be the interface on which the iterable declaration is declared on.
</li>
	<!--cp-throw-if-not-impl-->

	<li>
~RET ［
%interface,
~target %object,
反復子の種類 `key^C
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind “key”.
◎
Return iterator.
</li>

</ol>
	</dd>
</dl>


<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `keys^l である。
◎
The value of the Function object’s “name” property is the String value “keys”.
</p>

				</section>
				<section id="es-iterable-values">
<h5 title="values">4.6.10.3. values</h5>

<div class="p">
<p>
`可反復~宣言$を持つ`~ifc$には、次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `values^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration, then a property named “values” MUST exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>~ifcは`値~反復子$を持つ場合：</dt>
	<dd>
`iterator_symbol^ ~propの値で与えられる `Function^t ~obj。
◎
If the interface has a value iterator, then the Function object is the value of the @@iterator property.
</dd>

	<dt>~ifcは`~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then the Function, when invoked, MUST behave as follows:
</dt>
	<dd>
<!--cp-F-must-behave-as-follows-->

<ol class="algorithm">
	<!--cp-let-ToObject-this-->
	<li>
~IF
%object は `~platform~obj$である
~THEN
( %object, %F, `entries^l, `~meth^C )
に対し，`保安検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the ECMAScript global environment associated with this Function,
• the identifier “entries”, and
• the type “method”.
</li>

	<!--cp-let-ifc-iterable-declared-->
	<!--cp-throw-if-not-impl-->
	<li>
~RET ［
%interface,
~target %object,
反復子の種類 `value^C
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind “value”.
◎
Return iterator.
</li>
</ol>

	</dd>
</dl>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `values^l である。
◎
The value of the Function object’s “name” property is the String value “entries”.
</p>


				</section>
				<section id="es-default-iterator-object">
<h5 title="Default iterator objects">4.6.10.4. 既定の反復子~obj</h5>


<p>
所与の［
`~ifc$, ~target, 反復の種類
］に対する
`既定の反復子~obj@
とは、~objであって，その
`Prototype^es 内的~prop が，その~ifcの`反復子~原型~obj$であるものである。
◎
A default iterator object for a given interface, target and iteration kind is an object whose internal [[Prototype]] property is the iterator prototype object for the interface.
</p>

<p>
`既定の反復子~obj$は、次の３つの値を内的に持つ：
◎
A default iterator object has three internal values:
</p>

<dl>
	<dt>~target</dt>
	<dd>
反復される値を供給する~obj
◎
its target, which is an object whose values are to be iterated,
</dd>

	<dt>種類</dt>
	<dd>
反復の種類
<span class="trans-note">【
`key^C, `value^C, `key+value^C のいずれか
】</span>

◎
its kind, which is the iteration kind,
</dd>

	<dt>~index</dt>
	<dd>
一連の値のうち，反復されることになる値を指す、現在の~index。
◎
its index, which is the current index into the values value to be iterated.
</dd>

</dl>


<div class="note"><p>
既定の反復子~objは、`~pair反復子$のみに利用される
—
`値~反復子$は、現在は，~objの`被support~prop~index$上を反復するように制約されており、標準の ECMAScript `Array^t 反復子~objを利用する。
<!-- #dfn-supported-indexed-properties＊誤記？ -->
◎
Default iterator objects are only used for pair iterators; value iterators, as they are currently restricted to iterating over an object’s supported indexed properties, use standard ECMAScript Array iterator objects.
</p></div>

<p>
`既定の反復子~obj$が最初に作成されたときの~indexは、 0 にされる。
◎
When a default iterator object is first created, its index is set to 0.
</p>

<p>
所与の`~ifc$に対する`既定の反復子~obj$の `~class文字列$は、［
その~ifcの`識別子$,
文字列 `Iterator^l 
］の連結である。
◎
The class string of a default iterator object for a given interface is the result of concatenting the identifier of the interface and the string “ Iterator”.
</p>
<!-- ＊？“Iterator” -->

				</section>
				<section id="es-iterator-prototype-object">
<h5 title="Iterator prototype object">4.6.10.5. 反復子~原型~obj</h5>

<p>
`~pair反復子$を持つどの`~ifc$に対しても、
`反復子~原型~obj@
と呼ばれる~objが存在する。
それは、その~ifcに対する`既定の反復子~obj$の原型としての~~役割を担う。
◎
The iterator prototype object for a given interface is an object that exists for every interface that has a pair iterator. It serves as the prototype for default iterator objects for the interface.
</p>

<p>
`反復子~原型~obj$の `Prototype^es 内的~propは、
`IteratorPrototype^ で~MUST。
◎
The internal [[Prototype]] property of an iterator prototype object MUST be %IteratorPrototype% ([ECMA-262], section 6.1.7.4).
</p>

<div class="p">
<p>
`反復子~原型~obj$は、次のように特徴付けられる~propを持た~MUST：
</p>

<ul>
	<li>
名前は `next^l
</li>
	<li>
値は 下に与える様に挙動する`関数~obj$
</li>
	<!--cp-has-attr-TTT-->
</ul>

◎
An iterator prototype object MUST have a property named “next” with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object that behaves as follows:
</div>

<ol class="algorithm">
	<li>
%interface := その`反復子~原型~obj$が存在する`~ifc$
◎
Let interface be the interface for which the iterator prototype object exists.
</li>
	<!--cp-let-ToObject-this-->
	<li>
~IF
%object は `~platform~obj$である
~THEN
( %object, この `Function^t, `next^l, `~meth^C )
に対し，`保安検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the ECMAScript global environment associated with this Function,
• the identifier “next”, and
• the type “method”.
</li>
	<li>
~IF
%object は %interface に対する`既定の反復子~obj$でない
~THEN
~THROW `TypeError^t
◎
If object is not a default iterator object for interface, then throw a TypeError.
</li>

	<li>
%target := %object の~target
◎
Let target be object’s target.
</li>
	<li>
%index := %object の~index
◎
Let index be object’s index.
</li>
	<li>
%kind := %object の種類
◎
Let kind be object’s kind.
</li>
	<li>
<p>
%values := `反復される値~pair$の~list
◎
Let values be the list of value pairs to iterate over.
</p>

<p class="trans-note">【
変数 %target が~algoのどこにも利用されていない —
この段で %values を供給する~objを指すと見られるが。
】</p>

	</li>

	<li>
%len := %values の長さ
◎
Let len be the length of values.
</li>
	<li>
~IF
%object の~index ≥ %len
~THEN
~RET
`CreateIterResultObject$A(`undefined^v, `true^v)
◎
If object’s index is greater than or equal to len, then return CreateIterResultObject(undefined, true).
</li>
	<li>
%pair ~LET %values 内の %index に位置する~entry
◎
Let pair be the entry in values at index index.
</li>
	<li>
<p>
%result :=
%kind の値に応じて，次で決定される値：
◎
Let result be a value determined by the value of kind:
</p>

		<dl class="switch">
			<dt>`key^C</dt>
			<dd>
<ol class="algorithm">
	<li id="cp-let-idlkey-of-pair">
%idlKey := %pair の~key
◎
Let idlKey be pair’s key.
</li>
	<li id="cp-idlKey-toES">
%key ~LET %idlKey を ECMAScript 値に`toES^した結果
◎
Let key be the result of converting idlKey to an ECMAScript value.
</li>
	<li>
%result ← %key
◎
result is key.
</li>
</ol>
			</dd>

			<dt>`value^C</dt>
			<dd>
<ol class="algorithm">
	<li id="cp-let-idlValue-of-pair">
%idlValue := %pair の~key
◎
Let idlValue be pair’s value.
</li>
	<li id="cp-idlValue-toES">
%value := %idlValue を ECMAScript 値に`toES^した結果
◎
Let value be the result of converting idlValue to an ECMAScript value.
</li>
	<li>
%result ← %value
◎
result is value.
</li>
</ol>
			</dd>

			<dt>`key+value^C</dt>
			<dd>
<ol class="algorithm">
	<!--cp-let-idlkey-of-pair-->
	<!--cp-let-idlValue-of-pair-->
	<!--cp-idlKey-toES-->
	<!--cp-idlValue-toES-->
	<li>
%array := `ArrayCreate$A( 2 ) を遂行した結果
◎
Let array be the result of performing ArrayCreate(2).
</li>
	<li>
`CreateDataProperty$A( %array, `0^l, %key ) を~callする
◎
Call CreateDataProperty(array, "0", key).
</li>
	<li>
`CreateDataProperty$A( %array, `1^l, %value ) を~callする
◎
Call CreateDataProperty(array, "1", value).
</li>
	<li>
%result ← %array
◎
result is array.
</li>
</ol>
			</dd>
		</dl>
	</li>
	<li>
~RET
`CreateIterResultObject$A( %result, `false^v )
◎
Return CreateIterResultObject(result, false).
</li>

</ol>

<p>
所与の`~ifc$に対する`反復子~原型~obj$の `~class文字列$は［
その~ifcの`識別子$,
文字列 `Iterator^l
］の連結である。
◎
The class string of an iterator prototype object for a given interface is the result of concatenting the identifier of the interface and the string “Iterator”.
</p>

				</section>
			</section>
			<section id="es-maplike" class="v2 L2">
<h4 title="Maplike declarations">4.6.11. ~maplike 宣言</h4>

<p>
`~maplike 宣言$を持つ`~ifc$
— この節を通して， %A と記される —
を実装する どの~objも，
`BackingMap^es `internal_slot^ を持た~MUST。
— それは、初期~時には，新たに作成された `Map^t ~objに設定される。
この `Map^t ~objの `MapData^es 内的~slotが，~objの一連の`~map~entry$になる。
◎
Any object that implements an interface that has a maplike declaration MUST have a [[BackingMap]] internal slot, which is initially set to a newly created Map object. This Map object’s [[MapData]] internal slot is the object’s map entries.
</p>

<p>
%A の`~ifc原型~obj$上には、いくつかの追加の~propが存在する。
これらの追加の~propは、以下の各 下位~節にて述べられる。
◎
If an interface A is declared with a maplike declaration, then there exists a number of additional properties on A’s interface prototype object. These additional properties are described in the sub-sections below.
</p>

<p>
それらの~propのうち一部のものは、以下において［
所与の関数~名に対し，
`内的~map~objへ転送する@
ような`関数~obj$ 値を持つ
］ように定義される。
その種の関数は、被呼出時に次の様に挙動する：
◎
Some of the properties below are defined to have a function object value that forwards to the internal map object for a given function name. Such functions behave as follows when invoked:
</p>

<ol class="algorithm">
	<!--cp-let-O-this-value-->
	<li id="cp-let-arguments-passed">
%arguments := 関数に渡された引数の~list
◎
Let arguments be the list of arguments passed to this function.
</li>
	<li id="cp-let-name-function-name">
%name := 関数~名
◎
Let name be the function name.
</li>
	<li id="cp-security-check-name">
~IF
%O は `~platform~obj$である
~THEN
( %O, この `Function^t, %name, `~meth^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function,
• an identifier equal to name, and
• the type “method”.
</li>

	<li id="cp-throw-if-O-not-obj">
~IF
%O は %A を実装する~objでない
~THEN
~THROW `TypeError^t
◎
If O is not an object that implements A, then throw a TypeError.
</li>

	<li id="cp-let-map-BackingMap">
%map :=
%O の `BackingMap^es `internal_slot^ の値である `Map^t ~obj
◎
Let map be the Map object that is the value of O’s [[BackingMap]] internal slot.
</li>
	<li id="cp-Get-name-map">
%function :=
( %name, %map )
を引数に，
%map の `Get^es 内的~methを~callした結果
◎
Let function be the result of calling the [[Get]] internal method of map passing name and map as arguments.
</li>

	<li id="cp-throw-if-IsCallable-funciton-false">
~IF
`IsCallable$A( %function ) ~EQ `false^v
~THEN
~THROW `TypeError^t
◎
If IsCallable(function) is false, then throw a TypeError.
</li>
	<li>
~RET ［
~thisArg: %map,
~argList: %arguments
］を渡して
%function の `Call^es 内的~methを~callした結果
◎
Return the result of calling the [[Call]] internal method of function with map as thisArg and arguments as argumentsList.
</li>
  </ol>

				<section id="es-map-size">
<h5 title="size">4.6.11.1. size</h5>
<p>
%A の`~ifc原型~obj$上には，次のように特徴付けられる~propが存在し~MUST：
◎
There MUST exist a property named “size” on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
名前は `size^l
◎
↑</li>
	<li>
属性
<span class="descriptor">{&nbsp;[[Get]]: %G, [[Enumerable]]: `false^v, [[Configurable]]: `true^v&nbsp;}</span>
を持つ。
ここで %G は、次項にて定義される
`~map~size取得子@
である。
◎
The property has attributes { [[Get]]: G, [[Enumerable]]: false, [[Configurable]]: true }, where G is the interface’s map size getter, defined below.
</li>
	<li>
<p>
`~map~size取得子$は、被呼出時の挙動が次で与えられる， `Function^t ~obj：
◎
The map size getter is a Function object whose behavior when invoked is as follows:
</p>

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li id="cp-security-check-size">
~IF
%O は `~platform~obj$である
~THEN
( %O, この `Function^t, `size^l, `取得子^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function,
• the identifier “size”, and
• the type “getter”.
</li>

			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li>
~RET
( `size^l, %map )
を引数に，
%map の `Get^es 内的~methを~callした結果
◎
Return the result of calling the [[Get]] internal method of map passing “size” and map as arguments.
</li>

		</ol>
<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `size^l である。
◎
The value of the Function object’s “name” property is the String value “size”.
</p>

	</li>
</ul>


				</section>
				<section id="es-map-entries">
<h5 title="entries">4.6.11.2. entries</h5>

<div class="p">
<p>
%A の`~ifc原型~obj$上には、次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `entries^l
</li>
	<li>
値は `iterator_symbol^ ~propの値で与えられる`関数~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
A property named “entries” MUST exist on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the function object that is the value of the @@iterator property.
</div>


				</section>
				<section id="es-map-keys-values">
<h5 title="keys and values">4.6.11.3. keys, values</h5>

<p>
名前［
`keys^l ／ `values^l
］に対しては、
%A の`~ifc原型~obj$上には，次のように特徴付けられる 同じ名前の~propが存在し~MUST。
◎
For both of “keys” and “values”, there MUST exist a property with that name on A’s interface prototype object with the following characteristics:
</p>


<ul>
	<li id="cp-has-TFT">
属性 `TFT^desc を持つ。
◎
The property has attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</li>
	<li>
値は `内的~map~objへ転送する$ `Function^t ~obj。
◎
The value of the property is a Function object that forwards that name to the internal map object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、 `String^t 値［
`keys^l ／ `values^l
］である。
◎
The value of the Function object’s “name” property is the String value “keys” or “values”, correspondingly.
</p>

				</section>
				<section id="es-map-get-has">
<h5 title="get and has">4.6.11.4. get, has</h5>

<p>
名前［
`get^l ／ `has^l
］に対しては、
%A の`~ifc原型~obj$上には，次のように特徴付けられる 同じ名前の~propが存在し~MUST。
◎
For both of “get” and “has”, there MUST exist a property with that name on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<p id="cp-value-is-Function-as">
値は 被呼出時に次の様に挙動する `Function^t ~obj：
◎
The value of the property is a Function object that behaves as follows when invoked:
</p>

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
%name := ~propの名前（ `get^l または `has^l ）。
◎
Let name be the name of the property – “get” or “has”.
</li>

			<!--cp-security-check-name-->
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li id="cp-let-keyType">
%keyType := `~maplike 宣言$にて指定された~key型
◎
Let keyType be the key type specified in the maplike declaration.
</li>
			<!--cp-Get-name-map-->
			<li id="cp-let-keyArg-1st-arg">
%keyArg := ［
この関数に引数が渡されているならば その第一~引数の値 ／
~ELSE_ `undefined^v
］
◎
Let keyArg be the first argument passed to this function, or undefined if not supplied.
</li>
			<li id="cp-keyArg-toIDL-keyIDL">
%keyIDL := %keyArg を型 %keyType の IDL 値に`toIDL^した結果
◎
Let keyIDL be the result of converting keyArg to an IDL value of type keyType.
</li>
			<li id="cp-keyIDL-toES-key">
%key := %keyIDL を ECMAScript 値に`toES^した結果
◎
Let key be the result of converting keyIDL to an ECMAScript value.
</li>
			<li>
~RET ［
~thisArg: %map,
~argList: ( %key )
］を渡して
%function の `Call^es 内的~methを~callした結果
◎
Return the result of calling the [[Call]] internal method of function with map as thisArg and the single value key as argumentsList.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この `Function^t ~objの `name^l ~propの値は、 `String^t 値［
`get^l ／ `has^l
］である。
◎
The value of the Function object’s “name” property is the String value “get” or “has”, correspondingly.
</p>

				</section>
				<section id="es-map-clear">
<h5 title="clear">4.6.11.5. clear</h5>

<p>
%A のどの`広義~帰結~ifc$も識別子 `clear^l の`~ifc~mb$を宣言しない, かつ
%A は可書~maplike 宣言を伴って宣言されている場合、
%A の`~ifc原型~obj$上には，次のように特徴付けられる~propが存在し~MUST：
◎
If A and A’s consequential interfaces do not declare an interface member with identifier “clear”, and A was declared with a read–write maplike declaration, then a property named “clear” and the following characteristics MUST exist on A’s interface prototype object:
</p>


<ul>
	<li>
名前は `clear^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
値は `内的~map~objへ転送する$`Function^t ~obj。
◎
The value of the property is a Function object that forwards “clear” to the internal map object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `clear^l である。
◎
The value of the Function object’s “name” property is the String value “clear”.
</p>

				</section>
				<section id="es-map-delete">
<h5 title="delete">4.6.11.6. delete</h5>


<p>
%A のどの`広義~帰結~ifc$も，識別子 `delete^l の`~ifc~mb$を宣言しない, かつ
%A は可書~maplike 宣言を伴って宣言されている場合、
%A の`~ifc原型~obj$上には，次のように特徴付けられる~propが存在し~MUST：
◎
If A and A’s consequential interfaces do not declare an interface member with identifier “delete”, and A was declared with a read–write maplike declaration, then a property named “delete” and the following characteristics MUST exist on A’s interface prototype object:
</p>

<ul>
	<li>
名前は `delete^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-Function-as-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, この `Function^t, `delete^l, `~meth^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function,
• the identifier “delete”, and
• the type “method”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<!--cp-let-keyType-->
			<li>
%function :=
( `delete^l, %map )
を引数に，
%map の `Get^es 内的~methを~callした結果
◎
Let function be the result of calling the [[Get]] internal method of map passing “delete” and map as arguments.
</li>
			<!--cp-let-keyArg-1st-arg-->
			<!--cp-keyArg-toIDL-keyIDL-->
			<!--cp-keyIDL-toES-key-->
			<li>
~RET ［
~thisArg: %map,
~argList: ( %key )
］を渡して
%function の `Call^es 内的~methを~callした結果
◎
Return the result of calling the [[Call]] internal method of function with map as thisArg and the single value key as argumentsList.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `delete^l である。
◎
The value of the Function object’s “name” property is the String value “delete”.
</p>

				</section>
				<section id="es-map-set">
<h5 title="set">4.6.11.7. set</h5>

<p>
%A のどの`広義~帰結~ifc$も，［
識別子 `set^l の`~ifc~mb$を宣言しない, かつ
%A は可書~maplike 宣言を伴って宣言されている
］ならば、
%A の`~ifc原型~obj$上には，次のように特徴付けられる~propが存在し~MUST：
◎
If A and A’s consequential interfaces do not declare an interface member with identifier “set”, and A was declared with a read–write maplike declaration, then a property named “set” and the following characteristics MUST exist on A’s interface prototype object:
</p>


<ul>
	<li>
名前は `set^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-Function-as-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, この `Function^t, `set^l, `~meth^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function,
• the identifier “set”, and
• the type “method”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li>
%keyType, %valueType := 順に，`~maplike 宣言$にて指定された~key型, ~value型
◎
Let keyType and valueType be the key and value types specified in the maplike declaration.
</li>
			<li>
%function :=
( `set^l, %map )
を引数に，
%map の `Get^es 内的~methを~callした結果
◎
Let function be the result of calling the [[Get]] internal method of map passing “set” and map as arguments.
</li>
	<!--cp-let-keyArg-1st-arg-->

			<li>
%valueArg :=［
この関数に第二~引数が渡されているならば その値 ／
~ELSE_ `undefined^v
］
◎
Let valueArg be the second argument passed to this function, or undefined if not supplied.
</li>

			<!--cp-keyArg-toIDL-keyIDL-->
			<li>
%valueIDL := %valueArg を型 %valueType の IDL 値に`toIDL^した結果
◎
Let valueIDL be the result of converting valueArg to an IDL value of type valueType.
</li>
			<!--cp-keyIDL-toES-key-->
			<li>
%value := %valueIDL を ECMAScript 値に`toES^した結果
◎
Let value be the result of converting valueIDL to an ECMAScript value.
</li>
			<li>
%result :=［
~thisArg: %map,
~argList: ( %key, %value )
］を渡して
%function の `Call^es 内的~methを~callした結果
◎
Let result be the result of calling the [[Call]] internal method of function with map as thisArg and key and value as argumentsList.
</li>
			<li id="cp-assert-result-non-abrupt">
`Assert$：
%result は `abrupt completion$ （ “中途完了” ）でない
◎
Assert: result is not an abrupt completion.
</li>
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
	</li>
</ul>

<p>
この `Function^t ~objの `length^l ~propの値は、 `Number^t 値 `2^v である。
◎
The value of the Function object’s “length” property is the Number value 2.
</p>

<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `set^l である。
◎
The value of the Function object’s “name” property is the String value “set”.
</p>

				</section>
			</section>
			<section id="es-setlike" class="v2 L2">
<h4 title="Setlike declarations">4.6.12. ~setlike 宣言</h4>

<p>
`~setlike 宣言$を持つ`~ifc$
— この節を通して， %A と記される —
を実装するどの~objも，
`BackingSet^es `internal_slot^ を持た~MUST
— それは、初期~時には，新たに作成された `Set^t ~objに設定される。
この `Map^t ~objの `SetData^es 内的~slotが，~objの一連の`~set~entry$になる。
◎
Any object that implements an interface that has a setlike declaration MUST have a [[BackingSet]] internal slot, which is initially set to a newly created Set object. This Set object’s [[SetData]] internal slot is the object’s set entries.
</p>

<p>
%A の`~ifc原型~obj$上には、いくつかの追加の~propが存在する。
これらの追加の~propは、以下の各 下位~節にて述べられる。
◎
If an interface A is declared with a setlike declaration, then there exists a number of additional properties on A’s interface prototype object. These additional properties are described in the sub-sections below.
</p>

<p>
それらの~propのうち一部のものは、以下にて
所与の関数~名に対し，
`内的~set~objへ転送する@
ような`関数~obj$ 値を持つように定義される。
その種の関数は、被呼出時に次の様に挙動する：
◎
Some of the properties below are defined to have a function object value that forwards to the internal set object for a given function name. Such functions behave as follows when invoked:
</p>
  
<ol class="algorithm">
	<!--cp-let-O-this-value-->
	<!--cp-let-arguments-passed-->
	<!--cp-let-name-function-name-->
	<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, この `Function^t, %name, `~meth^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function,
• an identifier equal to name, and
• the type “method”.
</li>

	<!--cp-throw-if-O-not-obj-->
	<li id="cp-let-set-BackingSet">
%set :=
%O の `BackingSet^es `internal_slot^ の値である `Set^t ~obj
◎
Let set be the Set object that is the value of O’s [[BackingSet]] internal slot.
</li>
	<li id="cp-Get-name-set">
%function :=
( %name, %set )
を引数に，
%set の `Get^es 内的~methを~callした結果
◎
Let function be the result of calling the [[Get]] internal method of set passing name and set as arguments.
</li>
	<!--cp-throw-if-IsCallable-funciton-false-->
	<li>
~RET ［
~thisArg: %set,
~argList: %arguments
］を渡して
%function の `Call^es 内的~methを~callした結果
◎
Return the result of calling the [[Call]] internal method of function with set as thisArg and arguments as argumentsList.
</li>
</ol>

				<section id="es-set-size">
<h5 title="size">4.6.12.1. size</h5>


<p>
%A の`~ifc原型~obj$上には，次のように特徴付けられる~propが存在し~MUST：
◎
There MUST exist a property named “size” on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
名前は `size^l
◎
↑</li>
	<li>
属性
<span class="descriptor">{&nbsp;[[Get]]: %G, [[Enumerable]]: `false^v, [[Configurable]]: `true^v&nbsp;}</span>
を持つ。
ここで %G は、下に定義される
`~set~size取得子@
である。
◎
The property has attributes { [[Get]]: G, [[Enumerable]]: false, [[Configurable]]: true }, where G is the interface’s set size getter, defined below.
	</li>
</ul>

<p>
`~set~size取得子$は、被呼出時の挙動が次で与えられる， `Function^t ~objである：
◎
The set size getter is a Function object whose behavior when invoked is as follows:
</p>

		<ol class="algorithm">
	<!--cp-let-O-this-value-->
	<!--cp-security-check-size-->
	<!--cp-throw-if-O-not-obj-->
	<!--cp-let-set-BackingSet-->
			<li>
~RET
( `size^l, %set )
を引数に，
%set の `Get^es 内的~methを~callした結果
◎
Return the result of calling the [[Get]] internal method of set passing “size” and set as arguments.
</li>
		</ol>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `size^l である。
◎
The value of the Function object’s “name” property is the String value “size”.
</p>

				</section>
				<section id="es-set-values">
<h5 title="values">4.6.12.2. values</h5>

<div class="p">
<p>
%A の`~ifc原型~obj$上には、次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `values^l
</li>
	<li>
値は `iterator_symbol^ ~propの値で与えられる`関数~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
A property named “values” MUST exist on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the function object that is the value of the @@iterator property.
</div>


				</section>
				<section id="es-set-entries-keys">
<h5 title="entries and keys">4.6.12.3. entries, keys</h5>


<p>
名前［
`entries^l ／ `keys^l,
］に対しては、
%A の`~ifc原型~obj$上には，次のように特徴付けられる 同じ名前の~propが存在し~MUST。
◎
For both of “entries” and “keys”, there MUST exist a property with that name on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
値は `内的~set~objへ転送する$ `Function^t ~obj。
◎
The value of the property is a Function object that forwards that name to the internal set object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、 `String^t 値［
`entries^l ／ `keys^l
］である。
◎
The value of the Function object’s “name” property is the String value “entries” or “keys”, correspondingly.
</p>


				</section>
				<section id="es-set-has">
<h5 title="has">4.6.12.4. has</h5>

<p>
%A の`~ifc原型~obj$上には，次のように特徴付けられる~propが存在し~MUST。
◎
There MUST exist a property with named “has” on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
名前は `has^l
◎
↑</li>

	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-Function-as-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
~IF
%O は `~platform~obj$である
~THEN
( %O, この `Function^t, `has^l, `~meth^C )
に対し，`保安検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the ECMAScript global environment associated with this Function,
• the identifier “has”, and
• the type “method”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-set-BackingSet-->
			<li>
%type := `~setlike 宣言$にて指定された~value型
◎
Let type be the value type specified in the setlike declaration.
</li>
			<li>
%function :=
( `has^l, %set )
を引数に，
%set の `Get^es 内的~methを~callした結果
◎
Let function be the result of calling the [[Get]] internal method of set passing “has” and set as arguments.
</li>
			<li id="cp-let-arg-1st-arg">
%arg := ［
この関数に引数が渡されているならば その第一~引数の値 ／
~ELSE_ `undefined^v
］
◎
Let arg be the first argument passed to this function, or undefined if not supplied.
</li>
			<li id="cp-arg-toIDL-type">
%idlValue := %arg を型 %type の IDL 値に `toIDL^した結果
◎
Let idlValue be the result of converting arg to an IDL value of type type.
</li>
			<!--cp-idlValue-toES-->
			<li>
~RET ［
~thisArg: %set,
~argList: ( %value )
］を渡して
%function の `Call^es 内的~methを~callした結果
◎
Return the result of calling the [[Call]] internal method of function with set as thisArg and the single value value as argumentsList.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `has^l である。
◎
The value of the Function object’s “name” property is the String value “has”.
</p>

				</section>
<!-- es-set-add-delete？ -->
				<section id="es-add-delete">
<h5 title="add and delete">4.6.12.5. add, delete</h5>


<p>
名前［
`add^l ／ `delete^l
］に対しては、次の２条件：
◎
For both of “add” and “delete”, if:
</p>

<ul>
	<li>
%A のどの`広義~帰結~ifc$も，その名前に合致する識別子を伴う`~ifc~mb$を宣言していない
◎
A and A’s consequential interfaces do not declare an interface member with a matching identifier, and
</li>
	<li>
%A は可書`~maplike 宣言$を伴って宣言されている
◎
A was declared with a read–write setlike declaration,
</li>
</ul>

<p>
がいずれも満たされるならば、
%A の`~ifc原型~obj$上には，次のように特徴付けられる 同じ名前の~propが存在し~MUST：
◎
then a property with that name and the following characteristics MUST exist on A’s interface prototype object:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-Function-as-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
%name := ~propの名前（ `add^l または `delete^l ）。
◎
Let name be the name of the property – “add” or “delete”.
</li>
			<!--cp-security-check-name-->
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-set-BackingSet-->
			<li>
%type := `~setlike 宣言$に指定された値~型
◎
Let type be the value type specified in the setlike declaration.
</li>
			<!--cp-Get-name-set-->
			<!--cp-let-arg-1st-arg-->
			<!--cp-arg-toIDL-type-->
			<!--cp-idlValue-toES-->
			<li>
%result := ［
~thisArg: %set,
~argList: ( %value )
］を渡して
%function の `Call^es 内的~methを~callした結果
◎
Let result be the result of calling the [[Call]] internal method of function with set as thisArg and the single value value as argumentsList.
</li>
			<!--cp-assert-result-non-abrupt-->
			<li>
~RET ［
%name ~EQ `delete^l ならば %result ／
~ELSE_ %O
］
◎
If name is "delete", then:
• Return result.
◎
Otherwise:
• Return O.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この `Function^t ~objの `name^l ~propの値は、 `String^t 値［
`add^l ／ `delete^l
］である。
◎
The value of the Function object’s “name” property is the String value “add” or “delete”, correspondingly.
</p>

				</section>
				<section id="es-set-clear">
<h5 title="clear">4.6.12.6. clear</h5>

<p>
%A のどの`広義~帰結~ifc$も，合致する識別子を伴う`~ifc~mb$を宣言しない,
かつ %A は可書~setlike 宣言を伴って宣言されている場合、
%A の`~ifc原型~obj$上には，次のように特徴付けられる~propが存在し~MUST：
◎
If A and A’s consequential interfaces do not declare an interface member with a matching identifier, and A was declared with a read–write setlike declaration, then a property named “clear” and the following characteristics MUST exist on A’s interface prototype object:
</p>

<ul>
	<li>
名前は `clear^l
◎
↑</li>

	<!--cp-has-TFT-->
	<li>
値は `内的~set~objへ転送する$ `Function^t ~obj。
◎
The value of the property is a Function object that forwards “clear” to the internal set object.
</li>
	</ul>

<!--cp-length-is-0-->
<p>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `clear^l である。
◎
The value of the Function object’s “name” property is the String value “clear”.
</p>

				</section>
			</section>
			<section id="initializing-objects-from-iterables" class="v2">
<h4 title="Initializing objects from iterables">4.6.13. 可反復から~objを初期化する</h4>


<p>
~mapや~setの様な~ifcの模倣を試みる，一部の~objでは、構築子の~parameterとして可反復（ “反復し得るもの” ）を受容し，自身を以下に述べる仕方で初期化することが求められることになる。
この節では、その種の~objにて
ECMAScript 仕様と同じ仕方でそうするために呼出せる，~algoを提供して、組込みの `Map^t, `Set^t ~objと同じに挙動するようにする。
◎
Some objects, which are attempting to emulate map- and set-like interfaces, will want to accept iterables as constructor parameters and initialize themselves in this way. Here we provide some algorithms that can be invoked in order to do so in the same way as in the ECMAScript spec, so that those objects behave the same as the built-in Map and Set objects.
</p>

<p>
可反復 %iterable から，~obj %destination に，追加子~meth名 %adder により，
`~map要素を追加する@
ときは、次の手続きを遂行する：
◎
To add map elements from an iterable iterable to an object destination with adder method name adder, perform the following steps:
</p>


<ol class="algorithm">
	<li>
~IF
`Type^( %destination ) ≠ Object
~THEN
~THROW `TypeError^t
◎
If Type(destination) is not Object, then, throw a TypeError exception.
</li>
	<li>
~IF
%iterable は `不在$
~THEN
%iterable := `undefined^v
◎
If iterable is not present, let iterable be undefined.
</li>

	<li>
~IF
%iterable ~IN { `undefined^v, `null^v }
~THEN
%iter := `undefined^v
◎
If iterable is either undefined or null, then let iter be undefined.
</li>
	<li>
<p>
~ELSE
◎
Else,
</p>
		<ol>
			<li>
%adder := `Get^(%destination, %adder) の結果
◎
Let adder be the result of Get(destination, adder).
</li>
			<li>
`ReturnIfAbrupt$A( %adder )
◎
ReturnIfAbrupt(adder).
</li>
			<li>
~IF
`IsCallable$A( %adder ) ＝ `false^v
~THEN
~THROW `TypeError^t
◎
If IsCallable(adder) is false, throw a TypeError exception.
</li>
			<li>
%iter := `GetIterator$A( %iterable )
の結果
◎
Let iter be the result of GetIterator(iterable).
</li>
			<li>
`ReturnIfAbrupt$A( %iter )
◎
ReturnIfAbrupt(iter).
</li>
		</ol>
	</li>

	<li>
~IF
%iter ＝ `undefined^v
~THEN
~RET
◎
If iter is undefined, then return.
</li>

	<li>

<p>
~WHILE ~T：
◎
Repeat
</p>
		<ol>
			<li>
%next := `IteratorStep$A( %iter ) の結果
◎
Let next be the result of IteratorStep(iter).
</li>
			<li>
`ReturnIfAbrupt$A( %next )
◎
ReturnIfAbrupt(next).
</li>
			<li>
~IF
%next ＝ `false^v
~THEN
~RET `NormalCompletion$A( %destination )
◎
If next is false, then return NormalCompletion(destination).
</li>
			<li>
%nextItem := `IteratorValue$A( %next )
◎
Let nextItem be IteratorValue(next).
</li>
			<li>
`ReturnIfAbrupt$A( %nextItem )
◎
ReturnIfAbrupt(nextItem).
</li>
			<li>
~IF
`Type^( %nextItem ) ≠ Object
~THEN
~THROW `TypeError^t
◎
If Type(nextItem) is not Object, then throw a TypeError exception.
</li>
			<li>
%k := `Get^(%nextItem, `0^l) の結果
◎
Let k be the result of Get(nextItem, '0').
</li>
			<li>
`ReturnIfAbrupt$A( %k )
◎
ReturnIfAbrupt(k).
</li>
			<li>
%v := `Get^(%nextItem, `1^l) の結果
◎
Let v be the result of Get(nextItem, '1').
</li>
			<li>
`ReturnIfAbrupt$A( %v )
◎
ReturnIfAbrupt(v).
</li>
			<li>
%status := ［
~thisArg: %destination,
~argList: ( %k, %v )
］を渡して
%adder の `Call^es 内的~methを~callした結果
◎
Let status be the result of calling the [[Call]] internal method of adder with destination as thisArgument and (k, v) as argumentsList.
</li>
			<li>
`ReturnIfAbrupt$A( %status )
◎
ReturnIfAbrupt(status).
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="es-implements-statements">
<h3 title="Implements statements">4.7. ~implements_st</h3>


<p>
~ifc %A の`~ifc原型~obj$は、 %A のすべての`帰結~ifc$に対し、その~ifc原型~obj上に存在する［
`定数$,
`属性$,
`演算$
［
`可反復~宣言$ ／
`~maplike 宣言$ ／
`~setlike 宣言$
］］のそれぞれについて，対応する~propの複製を持た~MUST。
演算に対しては、~propが `Function^t ~obj値を伴う~data-propである所では，~propの各~複製ごとに元のものと異なる `Function^t ~objを持た~MUST。
同様に，属性に対しても、~accessor~propの各~複製ごとに，その取得子に対し, また
その設定子に対しても同様に、元のものと異なる `Function^t ~objを持た~MUST。
◎
The interface prototype object of an interface A MUST have a copy of each property that corresponds to one of the constants, attributes, operations, iterable declarations, maplike declarations and setlike declarations that exist on all of the interface prototype objects of A’s consequential interfaces. For operations, where the property is a data property with a Function object value, each copy of the property MUST have distinct Function objects. For attributes, each copy of the accessor property MUST have distinct Function objects for their getters, and similarly with their setters.
</p>



<div class="note">

<p>
［
~implements_stにより 存在が与えられる複製
］の値である `Function^t ~objの~callを通して，`演算$が呼出されたときは、その~objが，~~実際に［
その~propを持つ`~ifc原型~obj$に対応する`~ifc$を実装するもの
］であることを確認するために、 `this^v 値が検査される。
◎
When invoking an operation by calling a Function object that is the value of one of the copies that exists due to an implements statement, the this value is checked to ensure that it is an object that implements the interface corresponding to the interface prototype object that the property is on.
</p>

<p>
例えば次の IDL 片を考える：
◎
For example, consider the following IDL:
</p>

<pre class="idl-code">
interface A {
  void f();
};

interface B { };
B implements A;

interface C { };
C implements A;
</pre>

<p>
（ `B^T ではなく，）`A^T や `C^T を実装する~obj上で
`B.prototype.f^c
を~callした結果は、 `TypeError^T の投出になる。
しかしながら、 `B^T や `C^T を実装する~obj上では
`A.prototype.f^c
の~callは成功することになる。
これは、 ECMAScript において IDL 演算の呼出がどのように働くかを定義する，
`es-operations$sec
の~algoにより取扱われる。
◎
Attempting to call B.prototype.f on an object that implements A (but not B) or one that implements C will result in a TypeError being thrown. However, calling A.prototype.f on an object that implements B or one that implements C would succeed. This is handled by the algorithm in section 4.6.8 that defines how IDL operation invocation works in ECMAScript.
</p>

<p>
同様の挙動が IDL `属性$に対応する取得子や設定子の `Function^t ~objにも要求され、`es-attributes$sec
にて取扱われる。
◎
Similar behavior is required for the getter and setter Function objects that correspond to an IDL attributes, and this is handled in section 4.6.7.
</p>
</div>

		</section>
		<section id="es-platform-objects">
<h3 title="Platform objects implementing interfaces">4.8. ~ifcを実装している~platform~obj</h3>


<p>
どの`~platform~obj$も、`初期~obj$とちょうど同じ様に，大域環境に属する。
各~platform~objがどの大域環境に（または、代理を通して，どの大域~objに）属するか，についての言明-は Web IDL を利用する仕様が責を負う。
◎
Every platform object is associated with a global environment, just as the initial objects are. It is the responsibility of specifications using Web IDL to state which global environment (or, by proxy, which global object) each platform object is associated with.
</p>

<p>
１つ以上の~ifcを実装する~platform~objの
`主~ifc@
とは、それが実装する［
`追補~ifc$でない~ifc
］のうち，継承階層において最も末端の~ifcである。
~platform~objの `Prototype^es 内的~propの値は、`~platform~obj$が属する大域環境に属する，`主~ifc$の`~ifc原型~obj$である。
◎
The primary interface of a platform object that implements one or more interfaces is the most-derived non-supplemental interface that it implements. The value of the internal [[Prototype]] property of the platform object is the interface prototype object of the primary interface from the platform object’s associated global environment.
</p>

<p>
所与の`~platform~obj$が属する大域環境は、その作成-後に
`変化-@
し得る。
~platform~objが属する大域環境が変化した場合、その `Prototype^es 内的~prop は，その新たな大域環境に属する `主~ifc$の`~ifc原型~obj$に，即時に更新され~MUST。
◎
The global environment that a given platform object is associated with can change after it has been created. When the global environment associated with a platform object is changed, its internal [[Prototype]] property MUST be immediately updated to be the interface prototype object of the primary interface from the platform object’s newly associated global environment.
</p>
<!-- 
The value of the host object’s internal [[Prototype]] property is determined as follows:
...
...
-->

<!-- 
of that interface.
determined as follows:
...
...
...
-->

<p>
`Unforgeable$x 注釈付きの~ifcを実装する, かつ［
自身が実装するどの~ifcも，`偽装不可$である`文字列化子$は持たない
］ような，どの~platform~objも、次のように特徴付けられる~propを持た~MUST：
◎
Every platform object that implements an [Unforgeable]-annotated interface and which does not have a stringifier that is unforgeable on any of the interfaces it implements MUST have a property with the following characteristics:
</p>

<ul>
	<!--cp-name-is-tostr-->
	<!--cp-has-desc-FTF-->
	<li>
値は、
`Object.prototype.toString^c の初期~値である，
`ObjProto_toString^ （ `ECMA-262$r 6.1.7.4 節）。
◎
The value of the property is %ObjProto_toString% ([ECMA-262], section 6.1.7.4), the initial value of Object.prototype.toString.
</li>
</ul>


<p class="v2">
`Unforgeable$x 注釈付きの~ifcを実装する，どの~platform~objも、それが，［
それが実装するどの~ifc上にも，`偽装不可$である`直列化子$を持たない
］ならば、次のように特徴付けられる~propを持た~MUST：
◎
Every platform object that implements an [Unforgeable]-annotated interface and which does not have a serializer that is unforgeable on any of the interfaces it implements MUST have a property with the following characteristics:
</p>

<ul class="v2">
	<li>
名前は `toJSON^l 。
◎
The name of the property is “toJSON”.
</li>

	<!--cp-has-desc-FTF-->

	<li>
値は `undefined^v 。
◎
The value of the property is undefined.
</li>
</ul>

<p>
`Unforgeable$x 注釈付きの~ifcを実装する，どの~platform~objも、次のように特徴付けられる~propを持た~MUST：
◎
Every platform object that implements an [Unforgeable]-annotated interface MUST have a property with the following characteristics:
</p>

<ul>
	<li>
名前は `valueOf^l 。
◎
The name of the property is “valueOf”.
</li>

	<!--cp-has-desc-FTF-->
	<li>
<p>
値は 挙動が次で与えられる `Function^t ~obj：
◎
The value of the property is a Function object whose behavior is as follows:
</p>
		<ol class="algorithm">
			<li>
~RET `this^v 値
◎
Return the this value.
</li>
		</ol>

<p>
この `Function^t ~objが
`既定の偽装不可 valueOf 関数@
である。
◎
This Function object is the default unforgeable valueOf function.
</p>
	</li>
	<li><!--cp-length-is-0--></li>
	<li>
この `Function^t ~objの `name^l ~propの値は、
`String^t 値 `valueOf^l である。
◎
The value of the Function object’s “name” property is the String value “valueOf”.
</li>

</ul>

<p>
１個~以上の~ifcを実装する~platform~objの `~class文字列$は、~platform~objの`主~ifc$の`識別子$で~MUST。
◎
The class string of a platform object that implements one or more interfaces MUST be the identifier of the primary interface of the platform object.
</p>



			<section id="indexed-and-named-properties">
<h4 title="Indexed and named properties">4.8.1. 有index~propと有名~prop</h4>

<p>
`~platform~obj$が実装する`~ifc$が［
<!-- supports indexed or named properties -->
`有index~propを~supportする$, または`有名~propを~supportする$
］場合、その~objは，~objの［有index／有名］~propに対応する，追加の~propを持って現れることになる。
これらの~propは，~obj上の “真の” 自前の~propではないが、
`GetOwnProperty^es 内的~methにより公開されて見えるようにされる。
◎
If a platform object implements an interface that supports indexed or named properties, the object will appear to have additional properties that correspond to the object’s indexed and named properties. These properties are not “real” own properties on the object, but are made to look like they are by being exposed by the [[GetOwnProperty]] internal method.
</p>

<p>
しかしながら，
`Global$x ／ `PrimaryGlobal$x
`拡張属性$が利用されている場合、有名~propは
その~obj上ではなく，［
原型鎖~内の~objである, `有名~prop~obj$
］上に公開される。
◎
However, when the [Global] or [PrimaryGlobal] extended attribute has been used, named properties are not exposed on the object but on another object in the prototype chain, the named properties object.
</p>

<p>
~objが`有index~propを~supportする$ような複数の~ifcを実装することは許容され得る。
しかしながら，そのような場合、［
~objにおける`被support~prop~index$の定義が競合していたり，それらの~ifcのいずれかが その~platform~objに対する`追補~ifc$である
］場合に、［
~objが持つように現れることになる追加の~prop
］がどれになるか, あるいは［
その有index~propに関する正確な挙動
］がどうなるか，については、未定義である。
同じことは、有名~propについても該当する。
◎
It is permissible for an object to implement multiple interfaces that support indexed properties. However, if so, and there are conflicting definitions as to the object’s supported property indices, or if one of the interfaces is a supplemental interface for the platform object, then it is undefined what additional properties the object will appear to have, or what its exact behavior will be with regard to its indexed properties. The same applies for named properties.
</p>

<p>
［
~platform~objが実装する，継承階層において最も末端の~ifc
］上で定義される`有index~prop取得子$が、［
配列~indexによる~objに対する~indexingの際の挙動
］を定義する。
`有index~prop設定子$に対しても同様になる。
先祖の~ifcによる，これらの特殊~演算の定義は、この仕方で上書きできる。
◎
The indexed property getter that is defined on the derived-most interface that the platform object implements is the one that defines the behavior when indexing the object with an array index. Similarly for indexed property setters. This way, the definitions of these special operations from ancestor interfaces can be overridden.
</p>


<p>
［
［有index／有名］~propを~supportする~ifc
］を実装する~platform~objは，fixed になれない：<!-- not fixed length -->
すなわち，その［
`Object.freeze^c,
`Object.seal^c,
`Object.preventExtensions^c
］いずれかが それらの~obj上で~callされた場合、これらの関数は `TypeError^t を`投出^し~MUST。
同様に，［
`Global$x ／ `PrimaryGlobal$x
］の利用により有名~propを公開する`~ifc原型~obj$も、上の３つの関数が~callされた際に，
`TypeError^t を`投出^し~MUST。
◎
Platform objects implementing an interface that supports indexed or named properties cannot be fixed; if Object.freeze, Object.seal or Object.preventExtensions is called on one of these objects, the function MUST throw a TypeError. Similarly, an interface prototype object that exposes named properties due to the use of [Global] or [PrimaryGlobal] also MUST throw a TypeError if one of the three functions above is called on it.
</p>


<p>
~objが有index~propを~supportしていることにより，存在しているかのように現れる各~propの名前を
`配列~index~prop名@
という。
それは、次の~algoが ~true を返すような~prop名 %P である：
◎
The name of each property that appears to exist due to an object supporting indexed properties is an array index property name, which is a property name P such that Type(P) is String and for which the following algorithm returns true:
</p>

<ol class="algorithm">
	<li>
~IF
`Type^(%P) ≠ `String^t
~THEN
~RET ~false
◎
↑</li>
	<li>
%i := `ToUint32$A( %P )
◎
Let i be ToUint32(P).
</li>
	<li>
%s := `ToString$A( %i )
◎
Let s be ToString(i).
</li>
	<li>
~IF［
%s ≠ %P
］~OR［
%i ＝ 2`32^sup&nbsp;−&nbsp;1
］
~THEN
~RET ~false
◎
If s ≠ P or i = 2^32 − 1, then return false.
</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

<!-- 
Specifications can state that certain named properties are
@*resolved-before-prototype-properties.
...
-->

<div class="p">
<p>
所与の~platform~obj %O 上の~prop名は， %O が次を満たす`~ifc$ %I を実装するとき，
`偽装不可~prop名@
とされる：
</p>

<ul>
	<li>
%I はその~prop名を識別子とする`~ifc~mb$を持ち, かつ
</li>
	<li>
その~mbは［
%O が実装するいずれかの~ifc
］上で`偽装不可$である。
</li>
</ul>

<p>
~objが `Unforgeable$x 注釈付きの`~ifc$を実装する場合、［
`toString^l, `valueOf^l
］も，その~objにおいて`偽装不可~prop名$になる。
</p>
◎
A property name is an unforgeable property name on a given platform object if the object implements an interface that has an interface member with that identifier and that interface member is unforgeable on any of the interfaces that O implements. If the object implements an [Unforgeable]-annotated interface, then “toString” and “valueOf” are also unforgeable property names on that object.
</div>


<p>
所与の有名~propを~obj上に公開するかどうかは、
`有名~propの可視性判定~algo@
を利用して決定される。
一部の有名~propは、［
`OverrideBuiltins$x `拡張属性$が利用されたかどうか
］に依存して，~obj上に公開されなくなる。
この~algoは、
( ~prop名 %P, ~obj %O )
を~~入力にとり，次に従って演算する：
◎
The named property visibility algorithm is used to determine if a given named property is exposed on an object. Some named properties are not exposed on an object depending on whether the [OverrideBuiltins] extended attribute was used. The algorithm operates as follows, with property name P and object O:
</p>

<ol class="algorithm">
	<li>
~IF
%P は %O 上の`偽装不可~prop名$である
~THEN
~RET ~false
◎
If P is an unforgeable property name on O, then return false.
</li>

	<li>
~IF
%O が実装する ある~ifcに，［
識別子 %P の, `Unforgeable$x 注釈付きの属性
］が伴われている
~THEN
~RET ~false
◎
If O implements an interface with an [Unforgeable]-annotated attribute whose identifier is P, then return false.
</li>

	<li>
~IF
%P は %O の`被support~prop名$でない
~THEN
~RET ~false
◎
If P is not a supported property name of O, then return false.
</li>
	<li>
~IF
%O が実装する ある~ifcが， `OverrideBuiltins$x `拡張属性$を持つ
~THEN
~RET ~true
◎
If O implements an interface that has the [OverrideBuiltins] extended attribute, then return true.
</li>
	<li>
~IF
%O は 名前 %P の自前の~propを持つ
~THEN
~RET ~false
◎
If O has an own property named P, then return false.
</li>

	<li>
%prototype :← %O の `Prototype^es 内的~prop の値
◎
Initialize prototype to be the value of the internal [[Prototype]] property of O.
</li>
	<li>
<p>
~WHILE %prototype ≠ `null^v ：
◎
While prototype is not null:
</p>
		<ol>
			<li>
~IF［
%prototype は `有名~prop~obj$でない
］~AND［
%prototype は 名前 %P の自前の~propを持つ
］
~THEN
~RET ~false
◎
If prototype is not a named properties object, and prototype has an own property named P, then return false.
</li>
			<li>
%prototype ← %prototype の `Prototype^es 内的~prop の値
◎
Set prototype to be the value of the internal [[Prototype]] property of prototype.
</li>
		</ol>
	</li>
	<li>
~RET ~true
◎
Return true.
</li>
</ol>

<div class="note">

<p>
これにより、有名~propを伴う~objに対する~prop解決が次の順序で行えるようになる：
◎
This should ensure that for objects with named properties, property resolution is done in the following order:
</p>
	<ol>
		<li>
有index~prop
◎
Indexed properties.
</li>
		<li>
偽装不可である属性／演算
◎
Unforgeable attributes and operations.
</li>
		<li>
<p>
`OverrideBuiltins$x である場合：
◎
Then, if [OverrideBuiltins]:
</p>
			<ol>
				<li>
有名~prop
◎
Named properties.
</li>
				<li>
自前の~prop
◎
Own properties.
</li>
				<li>
原型鎖からの~prop
◎
Properties from the prototype chain.
</li>
			</ol>
		</li>
		<li>
<p>
他の場合（ `OverrideBuiltins$x でない場合）：
◎
Otherwise, if not [OverrideBuiltins]:
</p>
			<ol>
				<li>
自前の~prop
◎
Own properties.
</li>
				<li>
原型鎖からの~prop
◎
Properties from the prototype chain.
</li>
				<li>
有名~prop
◎
Named properties.
</li>
			</ol>
		</li>
	</ol>
</div>

<p>
`取得子$の~supportは
~platform~obj `GetOwnProperty^es ~meth（`getownproperty$sec）
により取扱われ、`設定子$については
~platform~obj `DefineOwnProperty^es ~meth（`defineownproperty$sec）, および
~platform~obj `Set^es ~meth（`platformobjectset$sec）
により取扱われる。
◎
Support for getters is handled by the platform object [[GetOwnProperty]] method defined in section 4.8.3, and for setters by the platform object [[DefineOwnProperty]] method defined in section 4.8.7 and the platform object [[Set]] method defined in section 4.8.6.
</p>
			</section>
			<section id="getownproperty-guts">
<h4 title="The PlatformObjectGetOwnProperty abstract operation">4.8.2. <span class="prop">PlatformObjectGetOwnProperty</span> 抽象演算</h4>

<p>
抽象演算
<span class="prop">PlatformObjectGetOwnProperty</span>
は、
( ~obj %O, ~prop名 %P, 真偽~値 %ignoreNamedProps )
を~~渡して~callされたとき，次の手続きを遂行する:
◎
The PlatformObjectGetOwnProperty abstract operation performs the following steps when called with an object O, a property name P, and a boolean ignoreNamedProps value:
</p>

<ol class="algorithm">
	<li>
<p id="cp-if-support-and-index">
~IF［
%O は `有index~propを~supportする$
］~AND［
%P は `配列~index~prop名$である
］
⇒
◎
If O supports indexed properties and P is an array index property name, then:
</p>
		<ol>
			<li id="cp-ToUint32-2">
%index := `ToUint32$A( %P )
◎
Let index be the result of calling ToUint32(P).
</li>
			<li>
<p>
~IF
%index は `被support~prop~index$である
⇒
◎
If index is a supported property index, then:
</p>
				<ol>
					<li>
%operation := `有index~prop取得子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the indexed property getter.
</li>

					<!--cp-let-uninitialized-->
					<li><!-- copy* -->
~IF
%operation は `識別子$を伴わずに定義されている
~THEN
%value ← ［
~index %index に対し，~ifcの記述に挙げられている
`有index~propの値を決定する$
手続きを遂行した結果
］
◎
If operation was defined without an identifier, then set value to the result of performing the steps listed in the interface description to determine the value of an indexed property with index as the index.
</li>
					<li><!-- copy* -->
~ELSE
~THEN
%value ← ［
( %index )
を引数に， %operation の記述に挙げられている手続きを遂行した結果
］
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the steps listed in the description of operation with index as the only argument value.
</li>

					<li>
<!--cp-ret-new-desc-->
<div>
&nbsp;&nbsp; `BTT-V^desc — ここで：

						<ul>
							<!--cp-let-convert2-->
							<li>
%B := ［
%O が実装するある~ifcに，`有index~prop設定子$が伴われている ならば `true^v ／
~ELSE_ `false^v
］
</li>
						</ul>
◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If O implements an interface with an indexed property setter, then set desc.[[Writable]] to true, otherwise set it to false.
◎
Set desc.[[Enumerable]] and desc.[[Configurable]] to true.
◎
Return desc.
</div>
					</li>
				</ol>
			</li>
			<li>
%ignoreNamedProps ← ~true
◎
Set ignoreNamedProps to true.
			</li>
		</ol>
	</li>

	<li>
<p>
~IF ［
%O は `有名~propを~supportする$
］~AND［
%O は
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴う`~ifc$を実装しない
］~AND［
( ~prop名 %P, ~obj %O )
を~~入力に，`有名~propの可視性判定~algo$を走らせた結果 ＝ ~true
］~AND［
%ignoreNamedProps ~EQ ~false
］
⇒
◎
If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute, the result of running the named property visibility algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
</p>
		<ol>
			<li>
%operation := `有名~prop取得子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property getter.
</li>

			<!--cp-let-uninitialized-->
			<!--cp-determine-ifndef-->
			<!--cp-set-as-desc1-->

			<li>
<!--cp-ret-new-desc-->
<div>
&nbsp;&nbsp; `BET-V^desc — ここで：

				<ul>
					<!--cp-let-convert2-->
					<li>
%B := ［
%O が実装するある~ifcに，`有名~prop設定子$が伴われている ならば `true^v
<!-- and
O does not implement an interface with the [Global] extended attribute
...
--> ／
~ELSE_ `false^v
］
</li>
					<li>
%E := ［
%O が実装するある~ifcに， `LegacyUnenumerableNamedProperties$x `拡張属性$が伴われているならば `false^v ／
~ELSE_ `true^v
］
</li>
				</ul>
◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If O implements an interface with a named property setter, then set desc.[[Writable]] to true, otherwise set it to false.
◎
If O implements an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then set desc.[[Enumerable]] to false, otherwise set it to true.
◎
Set desc.[[Configurable]] to true.
◎
Return desc.
</div>
			</li>
		</ol>
	</li>
	<!--cp-return-GetOwnProperty-->
</ol>
			</section>
			<section id="getownproperty">
<h4 title="Platform object [[GetOwnProperty]] method">4.8.3. ~platform~obj `GetOwnProperty^es ~meth</h4>

<p>
［
`有index~propを~supportする$, または`有名~propを~supportする$
<!-- supports indexed or named properties -->
］`~ifc$を実装する どの`~platform~obj$ %O に対しても，その `GetOwnProperty^es 内的~methは、
( ~prop名 %P )
を引数に~callされたときには，次の様に挙動し~MUST：
◎
The internal [[GetOwnProperty]] method of every platform object O that implements an interface which supports indexed or named properties MUST behave as follows when called with property name P:
</p>

<ol>
	<li>
~RET
( %O, %P, `false^v )
を引数に，抽象演算 `PlatformObjectGetOwnProperty^ を呼出した結果
◎
Return the result of invoking the PlatformObjectGetOwnProperty abstract operation with O, P, and false as arguments.
</li>
</ol>

			</section>
			<section id="invoking-indexed-setter">
<h4 title="Invoking a platform object indexed property setter">4.8.4. ~platform~obj~有index~prop~設定子の呼出し</h4>

<p>
( ~prop~名 %P, ECMAScript 値 %V )
を~~渡して
`有index~prop設定子を呼出す@
ときは、次の手続きを遂行し~MUST：
◎
To invoke an indexed property setter with property name P and ECMAScript value V, the following steps MUST be performed:
</p>

<ol class="algorithm">
	<!--cp-ToUint32-2-->
	<li>
%creating := ［
%index が`被support~prop~index$でないならば ~true ／
~ELSE_ ~false
］
◎
Let creating be true if index is not a supported property index, and false otherwise.
</li>
	<li>
%operation := `有index~prop設定子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the indexed property setter.
</li>
	<li id="cp-2nd-arg">
%T := %operation の第二~引数の型
◎
Let T be the type of the second argument of operation.
</li>
	<li id="cp-V-toIDL-T">
%value := %V を型 %T の IDL 値に`toIDL^した結果
◎
Let value be the result of converting V to an IDL value of type T.
</li>
	<li>
<p id="cp-ifdef-no-id">
~IF
%operation は `識別子$を伴わずに定義されている
⇒
◎
If operation was defined without an identifier, then:
</p>
		<ol>
			<li>
~IF
%creating ＝ ~true
~THEN
( ~index %index, 値 %value )
に対し，~ifcの記述に挙げられている
`新たな有index~propを設定する$
手続きを遂行する
◎
If creating is true, then perform the steps listed in the interface description to set the value of a new indexed property with index as the index and value as the value.
</li>
			<li>
~ELSE
~THEN
( ~index %index, 値 %value )
に対し，~ifcの記述に挙げられている
`既存の有index~propを設定する$
手続きを遂行する
◎
Otherwise, creating is false. Perform the steps listed in the interface description to set the value of an existing indexed property with index as the index and value as the value.
</li>
		</ol>
	</li>

	<li id="cp-ifdef-op-id">
~ELSE
~THEN
( %index, %value )
を引数に，
%operation の記述に挙げられている手続きを遂行する
◎
Otherwise, operation was defined with an identifier. Perform the steps listed in the description of operation with index and value as the two argument values.
</li>

</ol>


			</section>
			<section id="invoking-named-setter">
<h4 title="Invoking a platform object named property setter">4.8.5. ~platform~obj~有名~prop設定子の呼出し</h4>

<p>
( ~prop~名 %P, ECMAScript 値 %V )
を~~渡して
`有名~prop設定子を呼出す@
ときは、次の手続きを遂行し~MUST：
◎
To invoke a named property setter with property name P and ECMAScript value V, the following steps MUST be performed:
</p>

<ol class="algorithm">
	<li id="cp-let-creating">
%creating := ［
%P は`被support~prop名$であるならば~true ／
~ELSE_ ~false
］
◎
Let creating be true if P is not a supported property name, and false otherwise.
</li>
	<li>
%operation := `有名~prop設定子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property setter.
</li>
	<!--cp-2nd-arg-->
	<!--cp-V-toIDL-T-->
	<li>
<!--cp-ifdef-no-id-->
		<ol>
			<li>
~IF
%creating ＝ ~true
~THEN
( 名前 %P, 値 %value )
に対し，~ifcの記述に挙げられている
`新たな有名~propを設定する$
手続きを遂行する
◎
If creating is true, then perform the steps listed in the interface description to set the value of a new named property with P as the name and value as the value.
</li>
			<li>
~ELSE
~THEN
( 名前 %P, 値 %value )
に対し，~ifcの記述に挙げられている
`既存の有名~propを設定する$
手続きを遂行する
◎
Otherwise, creating is false. Perform the steps listed in the interface description to set the value of an existing named property with P as the name and value as the value.
</li>
		</ol>
	</li>
	<!--cp-ifdef-op-id-->
</ol>

			</section>
			<section id="platformobjectset">
<h4 title="Platform object [[Set]] method">4.8.6. ~platform~obj `Set^es ~meth</h4>

<p>
［
`有index~propを~supportする$, または`有名~propを~supportする$
<!-- supports indexed or named properties -->
］`~ifc$を実装する どの`~platform~obj$ %O に対しても，その `Set^es 内的~methは、
( ~prop名 %P, 値 %V, ECMAScript 言語~値 %Receiver )
を引数に~callされたときには，次の様に挙動し~MUST：
◎
The internal [[Set]] method of every platform object O that implements an interface which supports indexed or named properties MUST behave as follows when called with property name P, value V, and ECMAScript language value Receiver:
</p>

<ol class="algorithm">
	<li>
<p>
~IF
%O ~EQ %Receiver
⇒
◎
If O and Receiver are the same object, then:
</p>

		<ol>
			<li><p>
~IF［
%O は `有index~propを~supportする$
］~AND［
%P は`配列~index~prop名$である
］~AND［
%O が実装するある~ifcに，`有index~prop設定子$が伴われている
］
⇒
◎
If O supports indexed properties, P is an array index property name, and O implements an interface with an indexed property setter, then:
</p>

				<ol>
					<li>
( %P, %V )
を~~渡して
`有index~prop設定子を呼出す$
◎
Invoke the indexed property setter with P and V.
</li>
					<li>
~RET `true^v
◎
Return true.
</li>
				</ol>
			</li>

			<li><p>
~IF［
%O は `有名~propを~supportする$
］~AND［
`Type^( %P ) ＝ `String^t
］~AND［
%P は`配列~index~prop名$である
］~AND［
%O が実装するある~ifcに，`有名~prop設定子$が伴われている
］
⇒
◎
If O supports named properties, Type(P) is String, P is not an array index property name, and O implements an interface with a named property setter, then:
</p>

				<ol>
					<li>
( %P, %V )
を~~渡して
`有名~prop設定子を呼出す$
◎
Invoke the named property setter with P and V.
</li>
					<li>
~RET `true^v
◎
Return true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%ownDesc :=
( %O, %P, `true^v )
を引数に，抽象演算 `PlatformObjectGetOwnProperty^ を呼出した結果。
◎
Let ownDesc be the result of invoking the PlatformObjectGetOwnProperty abstract operation with O, P, and true as arguments.
</li>
	<li>
<a href="~ES6#sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver">既定の `Set^es 内的~meth</a>
の手続きにおける［
段 3〜11
］を遂行する（ `ECMA-262$r, 9.1.9 節）
◎
Perform steps 3-11 of the default [[Set]] internal method ([ECMA-262], section 9.1.9).
</li>
</ol>


			</section>
			<section id="defineownproperty">
<h4 title="Platform object [[DefineOwnProperty]] method">4.8.7. ~platform~obj `DefineOwnProperty^es ~meth</h4>

<p>
［<!-- supports indexed or named properties -->
`有index~propを~supportする$, または`有名~propを~supportする$
］`~ifc$を実装する どの`~platform~obj$ %O に対しても，その `DefineOwnProperty^es 内的~methは、［
~prop名 %P,
~pdesc %Desc,
真偽~flag %Throw
］を伴って~callされたときには，次の様に挙動し~MUST。
◎
The internal [[DefineOwnProperty]] method of every platform object O that implements an interface which supports indexed or named properties MUST behave as follows when called with property name P, Property Descriptor Desc and boolean flag Throw.
</p>


<ol class="algorithm">
	<li>
<p>
~IF［
%O は `有index~propを~supportする$
］~AND［
%P は`配列~index~prop名$である
］
⇒
◎
If O supports indexed properties and P is an array index property name, then:
</p>
		<ol>
			<li id="cp-reject-ifnot-IsDataDescriptor">
~IF
`IsDataDescriptor$A( %Desc )
を~callした結果 ＝ `false^v
~THEN
~REJECT
◎
If the result of calling IsDataDescriptor(Desc) is false, then Reject.
</li>
			<li>
~IF
%O が実装する どの~ifcにも，`有index~prop設定子$は伴われていない
~THEN
~REJECT
◎
If O does not implement an interface with an indexed property setter, then Reject.
</li>
			<li>
( %P, %Desc.`Value^es )
を~~渡して
`有index~prop設定子を呼出す$
◎
Invoke the indexed property setter with P and Desc.[[Value]].
</li>
			<li>
~RET
`true^v
。
◎
Return true.
</li>
		</ol>
	</li>

	<li>
<p><!-- copy* -->
~IF［
%O は `有名~propを~supportする$
］~AND［
%O は
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴う`~ifc$を実装しない
］~AND［
%P は %O の `Unforgeable$x ~prop名でない
］
⇒
◎
If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute and P is not an unforgeable property name of O, then:
</p>
		<ol>
			<!--cp-let-creating-->

<!--
<li>If <var>creating</var> is false and <var>O</var> implements an interface with the <a class='xattr' href='#Global'>[Global]</a> or <a class='xattr' href='#PrimaryGlobal'>[PrimaryGlobal]</a>
  <a class='dfnref' href='#dfn-extended-attribute'>extended attribute</a>, then:
  <ol>
    <li>If the result of calling <a href='http://es5.github.com/#x8.10.1' class='dfnref external'>IsAccessorDescriptor</a>(<var>Desc</var>) is <span class='esvalue'>true</span>, then:
      <ol>
        <li>Create an own accessor property named <var>P</var> on <var>O</var> whose <span class='prop'>[[Get]]</span>,
          <span class='prop'>[[Set]]</span>, <span class='prop'>[[Enumerable]]</span> and <span class='prop'>[[Configurable]]</span>
          attribute values are described by <var>Desc</var>.  If the value of an attribute field of <var>Desc</var> is absent,
          the attribute of the newly created property is set to its default value (<a href='#ref-ECMA-262'>[ECMA-262]</a>, section 8.6.1).</li>
      </ol>
    </li>
    <li>Otherwise:
      <ol>
        <li>Create an own data property named <var>P</var> on <var>O</var> whose <span class='prop'>[[Value]]</span>,
          <span class='prop'>[[Writable]]</span>, <span class='prop'>[[Enumerable]]</span> and <span class='prop'>[[Configurable]]</span>
          attribute values are described by <var>Desc</var>.  If the value of an attribute field of <var>Desc</var> is absent,
          the attribute of the newly created property is set to its default value (<a href='#ref-ECMA-262'>[ECMA-262]</a>, section 8.6.1).</li>
      </ol>
    </li>
    <li>Return <span class='esvalue'>true</span>.</li>
  </ol>
</li>
-->
			<li>
<p>
~IF
<!--Otherwise, if-->［
%O が実装するある~ifcに， `OverrideBuiltins$x `拡張属性$が伴われている
］~OR［
%O は 名前 %P の自前の~propを持たない
］
⇒
◎
If O implements an interface with the [OverrideBuiltins] extended attribute or O does not have an own property named P, then:
</p>
				<ol>
					<li>
~IF［
%creating ＝ ~false
］~AND［
%O が実装する どの~ifcにも，`有名~prop設定子$は伴われていない
］
~THEN
~REJECT
◎
If creating is false and O does not implement an interface with a named property setter, then Reject.
</li>
					<li>
<p>
~IF
%O が実装する ある~ifcに，`有名~prop設定子$が伴われている
⇒
◎
If O implements an interface with a named property setter, then:
</p>
						<ol>
							<!--cp-reject-ifnot-IsDataDescriptor-->
							<li>
( %P, %Desc.`Value^es )
を~~渡して
`有名~prop設定子を呼出す$
◎
Invoke the named property setter with P and Desc.[[Value]].
</li>
							<li>
~RET `true^v
◎
Return true.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>

	<li>
~IF
%O は
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴う`~ifc$を実装していない
~THEN
%Desc.`Configurable^es ← `true^v
◎
If O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute, then set Desc.[[Configurable]] to true.
</li>
	<li>
( %P, %Desc, %Throw )
を引数に，
%O 上の
<a href="~ES6#sec-ordinary-object-internal-methods-and-internal-data-properties-defineownproperty-p-desc">既定の `DefineOwnProperty^es 内的~meth</a>
（ `ECMA-262$r 9.1.6 節）
を~callする
◎
Call the default [[DefineOwnProperty]] internal method ([ECMA-262], section 9.1.6) on O passing P, Desc, and Throw as arguments.
</li>
</ol>


			</section>
			<section id="delete">
<h4 title="Platform object [[Delete]] method">4.8.8. ~platform~obj `Delete^es ~meth</h4>


<p>
［
`有index~propを~supportする$, または`有名~propを~supportする$
］
<!-- supports indexed or named properties -->
`~ifc$を実装する
どの`~platform~obj$ %O においても，その `Delete^es 内的~methは、~prop名 %P を伴って~callされたときには，次の様に挙動し~MUST。
◎
The internal [[Delete]] method of every platform object O that implements an interface which supports indexed or named properties MUST behave as follows when called with property name P.
</p>



<ol class="algorithm">
	<li>
<!--cp-if-support-and-index-->
		<ol>
			<!--cp-ToUint32-2-->
			<li>
~IF
%index は `被support~prop~index$でない
~THEN
~RET `true^v
◎
If index is not a supported property index, then return true.
</li>
			<li>
~RET `false^v
◎
Return false.
</li>
		</ol>
	</li>

	<li>
<p><!-- copy* -->
~IF［
%O は `有名~propを~supportする$
］~AND［
%O は
`Global$x ／ `PrimaryGlobal$x
`拡張属性$を伴う`~ifc$を実装しない
］~AND［
( ~prop名 %P, ~obj %O )
を~~入力に，`有名~propの可視性判定~algo$を~callした結果 ＝ ~true
］
⇒
◎
If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute and the result of calling the named property visibility algorithm with property name P and object O is true, then:
</p>
		<ol>
			<li>
~IF
%O が実装する どの~ifcにも，`有名~prop削除子$は伴われていない
~THEN
~RET `false^v
◎
If O does not implement an interface with a named property deleter, then false.
</li>
			<li>
%operation := `有名~prop削除子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property deleter.
</li>
			<li>
<!--cp-ifdef-no-id-->
				<ol>
					<li>
名前 %P に対し，既存の有名~propを削除するために、~ifcの記述に挙げられている
`既存の有名~propを削除する$
手続きを遂行する
◎
Perform the steps listed in the interface description to delete an existing named property with P as the name.
</li>
					<li>
~IF
手続きから削除の失敗-が指示された
~THEN
~RET `false^v
◎
If the steps indicated that the deletion failed, then false.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
⇒
◎
Otherwise, operation was defined with an identifier:
</p>
				<ol>
					<li>
( %P )
を引数に，
%operation の記述に挙げられている手続きを遂行する
◎
Perform the steps listed in the description of operation with P as the only argument value.
</li>
					<li>
~IF［
%operation は `返値型$ `boolean$T を伴って宣言されている
］~AND［
その手続きから `false^V が返された
］
~THEN
~RET `false^v
◎
If operation was declared with a return type of boolean and the steps returned false, then false.
</li>

				</ol>
			</li>
			<li id="cp-return-true">
~RET `true^v
◎
Return true.
</li>
		</ol>
	</li>

	<li>
<p>
~IF
%O は 名前 %P の自前の~propを持つ
⇒
◎
If O has an own property with name P, then:
</p>
		<ol>
			<li>
~IF
その~propは~configurableでない
~THEN
~RET `false^v
◎
If the property is not configurable, then false.
</li>
			<li>
~ELSE
~THEN
その~propを %O から除去する
◎
Otherwise, remove the property from O.
</li>
		</ol>
	</li>
	<!--cp-return-true-->
</ol>
			</section>
			<section id="call">
<h4 title="Platform object [[Call]] method">4.8.9. ~platform~obj `Call^es ~meth</h4>


<p>
少なくとも１つの`旧来呼出子$を伴う`~ifc$ %I を実装する，どの`~platform~obj$ %O においても，その `Call^es 内的~methは、
%arg<sub>0..%n−1</sub> を `Call^es に渡される引数~値の~listとするとき，次の様に挙動し~MUST。
◎
The internal [[Call]] method of every platform object O that implements an interface I with at least one legacy caller MUST behave as follows, assuming arg0..n−1 is the list of argument values passed to [[Call]]:
</p>

<ol class="algorithm">
	<li>
%S :← %I 上の，［
引数個数 %n
］の旧来呼出子からなる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for legacy callers on I and with argument count n.
</li>
	<!--cp-let-resolution-->
	<li>
( %values )
を引数に，旧来呼出子 %operation の記述に挙げられている手続きを遂行する
◎
Perform the actions listed in the description of the legacy caller operation with values as the argument values.
</li>
	<li>
~RET ［
その %operation の返値として宣言されている型が
`void$T ならば `undefined^v ／
~ELSE_ 前段の返値を ECMAScript 値に`toES^した結果
］
◎
Return the result of converting the return value from those actions to an ECMAScript value of the type operation is declared to return (or undefined if operation is declared to return void).
</li>
</ol>
			</section>
			<section id="property-enumeration">
<h4 title="Property enumeration">4.8.10. ~prop列挙</h4>


<p>
この文書は、
`~ifc$を実装しているすべての`~platform~obj$に対する（または
<a href="#es-exception-objects">例外を表現する~platform~obj</a>
に対する）
完全な~prop列挙~順序は定義しない。
しかしながら，~platform~objが［
`有index~propを~supportする$, または`有名~propを~supportする$
<!-- supports indexed or named properties -->
］~ifcを実装する場合、その~obj上の~propは次の順序により列挙され~MUST：
◎
This document does not define a complete property enumeration order for all platform objects implementing interfaces (or for platform objects representing exceptions). However, if a platform object implements an interface that supports indexed or named properties, then properties on the object MUST be enumerated in the following order:
</p>

<ol>
	<li>
最初に，~objが`有index~propを~supportする$場合、その~objの`被support~prop~index$が数的~順序で列挙される。
◎
If the object supports indexed properties, then the object’s supported property indices are enumerated first, in numerical order.
</li>
	<li>
次に，~objが［
`有名~propを~supportする$, かつ
`LegacyUnenumerableNamedProperties$x `拡張属性$を伴う~ifcは実装しない
］場合、その~objの被support~prop名のうち，［
`有名~propの可視性判定~algo$に従って可視であるもの
］が、`被support~prop名$の集合に（仕様により）定義された順序で列挙される。
◎
If the object supports named properties and doesn't implement an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then the object’s supported property names that are visible according to the named property visibility algorithm are enumerated next, in the order given in the definition of the set of supported property names.
</li>
	<li>
最後に、自前の~prop, および~objの原型鎖からの~propのうち，列挙可能なものが未定義の順序で列挙される。
◎
Finally, any enumerable own properties or properties from the object’s prototype chain are then enumerated, in no defined order.
</li>
</ol>

<div class="note"><p>
ECMAScript 仕様の将来~versionでは~prop列挙のための全順序が定義され得る。
◎
Future versions of the ECMAScript specification may define a total order for property enumeration.
</p></div>

			</section>
		</section>
		<section id="es-user-objects">
<h3 title="User objects implementing callback interfaces">4.9. 呼戻~ifcを実装する利用者~obj</h3>


<p>
上の
`idl-objects$sec
に述べた様に、
`呼戻~ifc$は，~scriptの中で ECMAScript ~objにより実装され得る。
次の場合分けにより、所与の~objが［
呼戻~ifcを実装している利用者~obj
］と見なされるかどうかが決定される。
◎
As described in section 3.9 above, callback interfaces can be implemented in script by an ECMAScript object. The following cases determine whether and how a given object is considered to be a user object implementing a callback interface:
</p>

<ul>
	<li>
<p>
~ifcが（下で定義される）`単一~演算~呼戻~ifc$である場合、
~native `RegExp^t ~obj以外の どの~objも、その~ifcを実装するものと見なされる。
その演算（または多重定義されている演算の集合）の実装は次で与えられる：
◎
If the interface is a single operation callback interface (defined below) then any object apart from a native RegExp object is considered to implement the interface. The implementation of the operation (or set of overloaded operations) is as follows:
</p>
		<ul>
			<li>
~objが`呼出可能$である場合、その演算（または多重定義されている演算の集合）の実装はその 呼出可能 ~obj自身になる。
◎
If the object is callable, then the implementation of the operation (or set of overloaded operations) is the callable object itself.
</li>
			<li>
他の場合（すなわち~objは`呼出可能$でない）、その演算（または多重定義されている演算の集合）の実装は、その演算の`識別子$を~prop名
<span class="trans-note">【†1】</span>
として，その~obj上の `Get^es 内的~methを呼出した結果になる。<!--  -->
◎
Otherwise, the object is not callable. The implementation of the operation (or set of overloaded operations) is the result of invoking the internal [[Get]] method on the object with a property name that is the identifier of the operation.
</li>
		</ul>
	</li>
	<li>
他の場合（ ~ifcは`単一~演算~呼戻~ifc$でない）、
<!-- `~platform~obj$でなく, かつ -->
~native `RegExp^t ~obj以外の どの~objも、その~ifcを実装するものと見なされる。
所与の`識別子$を伴って~ifc上に宣言される各~演算に対し、その実装は，その識別子を~prop名として，その~obj上の `Get^es を呼出した結果になる。
◎
Otherwise, the interface is not a single operation callback interface. Any object that is not a native RegExp object is considered to implement the interface. For each operation declared on the interface with a given identifier, the implementation is the result of invoking [[Get]] on the object with a property name that is that identifier.
</li>
</ul>

<p>
`単一~演算~呼戻~ifc@
とは、次のすべてを満たす`呼戻~ifc$である：
◎
A single operation callback interface is a callback interface that:
</p>
<ul>
	<li>
別の~ifcを`継承-$するように宣言されていない,
◎
is not declared to inherit from another interface,
</li>

	<li>
`属性$を持たない,
◎
has no attributes, and
</li>
	<li>
すべてが同じ`識別子$を持つ１個~以上の`正則~演算$があり，他のものはない。
◎
has one or more regular operations that all have the same identifier, and no others.
</li>
</ul>

<p class="trans-note">【
例えば DOM の 
<a href="https://dom.spec.whatwg.org/#eventlistener">`EventListener^T</a>
~ifc。
その唯一の~mbの識別子 `handleEvent^c が上述の~prop名（ †1 ）にあたる。
】</p>

<p>
IDL 引数~値の~list %idlarg<sub>0..%n−1</sub>
を伴う，`利用者~obj$の`演算$（以下， `演算^ と記す）の~callは、次の~algoに従う。
ここで
`呼戻 this 値@
とは、`呼出可能$~objが`単一~演算~呼戻~ifc$の実装として与えられた際に `this^v 値として利用される値である。
既定では， `undefined^v が`呼戻 this 値$に利用されるが、これは他の仕様により上書きされても~MAY。
<span class="trans-note">【
例えば上述の `EventListener^T ~objの場合，（大抵の仕様では）その~objの登録先の~obj（
<a href="https://dom.spec.whatwg.org/#eventtarget">`EventTarget^T</a>
）が呼戻 this 値にされている。
】</span>
◎
A user object’s operation is called with a list of IDL argument values idlarg0..n−1 by following the algorithm below. The callback this value is the value to use as the this value when a callable object was supplied as the implementation of a single operation callback interface. By default, undefined is used as the callback this value, however this MAY be overridden by other specifications.
</p>

<ol class="algorithm">

	<li>
<!--cp-try-steps-->
		<ol>
			<li id="cp-let-V-user-obj">
%V := その利用者~objを表現する，［
その利用者~objが実装している`~ifc型$
］の IDL 値
◎
Let V be the IDL callback interface type value that represents the user object implementing the interface.
</li>

			<li id="cp-let-O-es-of-V">
%O := %V に対応する ECMAScript ~obj
◎
Let O be the ECMAScript object corresponding to V.
</li>

			<li>
%X := `演算^ の実装 —
すなわち［［
~ifcは `単一~演算~呼戻~ifc$である
］~AND［
`IsCallable$A( %O ) ＝ ~true
］ならば %O ／
~ELSE_， `演算^ の識別子を~prop名として %O の `Get^es 内的~methを~callした結果
］<!-- ❖ -->
◎
Let X be the implementation of the operation. If the interface is a single operation callback interface and IsCallable(O) is true, then X is O. Otherwise, X is the result of calling the internal [[Get]] method of O with the identifier of the operation as the property name.
</li>
			<li>
~IF
`Type^( %X ) が Object でない
~THEN
~THROW `TypeError^t
◎
If Type(X) is not Object, throw a TypeError exception.
</li>
			<li>
~IF
`IsCallable$A( %X ) ＝ ~false
~THEN
~THROW `TypeError^t
◎
If IsCallable(X) is false, then throw a TypeError exception.
</li>
			<li>
%this := ［［
~ifc が`単一~演算~呼戻~ifc$でない
］~OR［
`IsCallable$A( %O ) ＝ ~false
］ならば %O ／
~ELSE_ `呼戻 this 値$
］
◎
Let this be O if the interface is not a single operation callback interface or if IsCallable(O) is false, and the callback this value otherwise.
</li>


			<li>
%arg<sub>0..%n−1</sub> :=  ECMAScript 値の~list：
ここで %arg<sub>%i</sub> は
%idlarg<sub>%i</sub> を ECMAScript 値に`toES^した結果
◎
Let arg0..n−1 be a list of ECMAScript values, where argi is the result of converting idlargi to an ECMAScript value.
</li>

			<li id="cp-let-script-cobj">
%script := %V に結付けられている`呼戻~文脈$
◎
Let script be the callback context associated with V.
</li>
			<li id="cp-push-script">
%script を `stack-of-incumbent-script^ `HTML$r に push する
◎
Push script on to the stack of incumbent scripts. [HTML]
</li>
			<li id="cp-let-R-uninit">
%R :← 未初期化の変数
◎
Let R be an uninitialized variable.
</li>

			<li>
<p id="cp-try">
~TRY：
◎
Try running the following step:
</p>
				<ol>
					<li>
%R ←
%this を `this^v 値に,
%arg<sub>0..%n−1</sub> を引数~値として，
%X の `Call^es ~methを呼出した結果
◎
Set R to the result of invoking the [[Call]] method of X, providing this as the this value and arg0..n−1 as the argument values.
</li>
				</ol>
			</li>

			<li id="cp-pop-script-rethrow">
<p>
（例外の投出の有無に関わらず）<br>
`stack-of-incumbent-script^ から %script を pop する
◎
And then, whether or not an exception was thrown:
• Pop script off the stack of incumbent scripts.
</p>

<p>
~CATCH：
</p>
				<ol>
					<li>
~THROW `投出された例外$
◎
If an exception was thrown, end these steps, and allow it to propagate.
</li>
				</ol>
			</li>

			<li>
~IF
`演算^ の返値型が `void$T
~THEN
~RET
◎
If the operation’s return type is void, return.
</li>
			<li id="cp-return-convert-to-IDL">
~RET %R を `演算^ の返値型と同じ型の IDL 値に`toIDL^した結果
◎
Return the result of converting R to an IDL value of the same type as the operation’s return type.
</li>
		</ol>
	</li>
	<li class="v2">
<!--cp-catch-ex-->
		<ol>
			<li>
<!--cp-ret_t-is-promise-->
				<!--cp-promise-reject-->
			</li>
			<!--cp-else-rethrow-->
		</ol>
	</li>
</ol>

<p>
`~ifc$上に`定数$が宣言されているとしても、
ECMAScript ~objが，その~ifcを実装している`利用者~obj$と見なされるために，それらの定数に対応する~propを持つ必要はないことに注意。
◎
Note that ECMAScript objects need not have properties corresponding to constants on them to be considered as user objects implementing interfaces that happen to have constants declared on them.
</p>

<p>
`利用者~obj$の`属性$の IDL 値が取得0されるときは、次の~algoに従う：
◎
The value of a user object’s attribute is retrieved using the following algorithm:
</p>

<ol class="algorithm">

	<li>
<!--cp-try-steps-->
		<ol>
			<!--cp-let-V-user-obj-->
			<!--cp-let-O-es-of-V-->

			<li id="cp-let-P-id">
%P := その属性の`識別子$
◎
Let P be the identifier of the attribute.
</li>


			<!--cp-let-script-cobj-->
			<!--cp-push-script-->
			<!--cp-let-R-uninit-->

			<li>
<!--cp-try-->
				<ol>
					<li>
%R ← ~prop名 %P により， %O の `Get^es ~methを呼出した結果
◎
Set R to the result of invoking the [[Get]] method of O with property name P.
</li>
				</ol>
			</li>

			<!--cp-pop-script-rethrow-->

			<li>
~RET %R をその属性の型と同じ型の IDL 値に`toIDL^した結果
◎
Return the result of converting R to an IDL value of the same type as the attribute’s type.
</li>
		</ol>
	</li>
	<li class="v2">
<!--cp-catch-ex-->
		<ol>
			<li>
<p><!-- cp-ret_t-is-promise -->
~IF
属性の`返値型$は `~promise型$である
⇒
◎
If the attribute has a return type that is a promise type, then:
</p>
				<!--cp-promise-reject-->
			</li>
			<!--cp-else-rethrow-->
		</ol>
	</li>
</ol>

<p>
`利用者~obj$の`属性$の値に IDL 値 %value が設定されるときは、次の~algoに従う：
◎
The value of a user object’s attribute is set using the following algorithm:
</p>

<ol class="algorithm">
	<!--cp-let-V-user-obj-->
	<!--cp-let-O-es-of-V-->
	<!--cp-let-P-id-->

	<li>
%W := %value を ECMAScript 値に`toES^した結果
◎
Let V be the IDL value to be assigned to the attribute.
◎
Let W be the result of converting V to an ECMAScript value.
</li>

	<!--cp-let-script-cobj-->
	<!--cp-push-script-->
	<li>
<!--cp-try-->
		<ol>
			<li>
( ~prop名 %P, 値 %W )
を引数に， %O の `Put^es ~methを呼出す
◎
Invoke the [[Put]] method of O with property name P and value W.
</li>
		</ol>
	</li>

	<!--cp-pop-script-rethrow-->
</ol>

		</section>
		<section id="es-invoking-callback-functions">
<h3 title="Invoking callback functions">4.10. 呼戻~関数の呼出し</h3>


<p>
`呼戻~関数$値として利用されている ECMAScript `呼出可能$~objの~callのされ方は、前~節で述べた，`利用者~obj$上の`演算$の~callと同様である。
それぞれが［
IDL 値, または<!-- *of the special value ( of → or) -->
（与えられていない随意~引数を表現する）`MISSING^
］である値の~list %arg<sub>0..%n−1</sub> を伴う，
`呼出可能$~objの~callは、次の~algoに従う。
既定では、`呼戻~関数$を呼出す際の`呼戻 this 値$は，他の仕様により上書きされない限り `undefined^v である。
◎
An ECMAScript callable object that is being used as a callback function value is called in a manner similar to how operations on user objects are called (as described in the previous section). The callable object is called with a list of values arg0..n−1, each of which is either an IDL value of the special value “missing” (representing a missing optional argument), by following the algorithm below. By default, the callback this value when invoking a callback function is undefined, unless overridden by other specifications.
</p>

<ol class="algorithm">

	<li>
<!--cp-try-steps-->
		<ol>
			<li>
%V := IDL `呼戻~関数~型$の値
◎
Let V be the IDL callback function type value.
</li>

			<li>
%F := %V に対応する ECMAScript ~obj
◎
Let F be the ECMAScript object corresponding to V.
</li>

			<li>
%R ← `undefined^v
◎
Let R be an uninitialized variable.
◎
If IsCallable(F) is false, then set R to the value undefined.
</li>
			<li>
<p>
~IF
`IsCallable$A( %F ) ≠ ~false
⇒
◎
Otherwise,
</p>

				<ol>
					<li>
%values :← ECMAScript 値の空~list
◎
Initialize values to be an empty list of ECMAScript values.
</li>
					<li>
%count :← 0
◎
Initialize count to 0.
</li>
					<li>
%i :← 0
◎
Initialize i to 0.
</li>

					<li>
<!--cp-while-i-n-->
						<ol>
							<li>
~IF
%arg<sub>%i</sub> ~EQ `MISSING^
~THEN
%values に ECMAScript `undefined^v 値を付加する
◎
If argi is the special value “missing”, then append to values the ECMAScript undefined value.
</li>
							<li>
~ELSE （すなわち %arg<sub>%i</sub> は IDL 値）
~THEN
%arg<sub>%i</sub> を ECMAScript 値に`toES^した結果を %values に付加する；<br>
%count ← %i + 1
◎
Otherwise, argi is an IDL value. Append to values the result of converting argi to an ECMAScript value, and set count to i + 1.
</li>
							<!--cp-inc-i-->
						</ol>
					</li>

					<li>
%values の長さを %count 個に切り詰める。
◎
Truncate values to have length count.
</li>

					<!--cp-let-script-cobj-->
					<!--cp-push-script-->

					<li>
<!--cp-try-->
						<ol>
							<li>
%R ← ［
`this^v 値として `呼戻 this 値$,
引数~listとして %values
］を~~渡して
%F の `Call^es ~methを呼出した結果
◎
Set R to the result of invoking the [[Call]] method of F, providing the callback this value as the this value and values as the argument values.
</li>
						</ol>
					</li>

					<!--cp-pop-script-rethrow-->

				</ol>
			</li>


			<li><!-- copy* -->
~IF
呼戻~関数の返値型は `void$T
~THEN
~RET
◎
If the callback function’s return type is void, return.
</li>

			<li>
~RET %R を呼戻~関数の返値型と同じ型の IDL 値に`toIDL^した結果
◎
Return the result of converting R to an IDL value of the same type as the callback function’s return type.
</li>

		</ol>
	</li>
	<li class="v2">
<!--cp-catch-ex-->
		<ol>
			<li>
<p>
~IF
呼戻~関数の`返値型$は `~promise型$である
⇒
◎
If the callback function has a return type that is a promise type, then:
</p>
				<!--cp-promise-reject-->
			</li>
			<!--cp-else-rethrow-->
		</ol>
	</li>
</ol>
		</section>
		<section id="es-exceptions" class="v2">
<h3 title="Exceptions">4.11. 例外</h3>

<p class="trans-note">【
この節の内容は、第１版から一新されている。
】</p>

<div class="p">
<p>
ECMAScript 大域~obj上には、次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `DOMException^l
</li>
	<li>
値は
`DOMException 構築子~obj@
と呼ばれる~obj（次節にて述べる）
</li>
	<!--cp-has-attr-TFT-->
</ul>

<p>
それは、旧来の DOMException ~code定数への~accessを提供し，
`DOMException$T の~instanceを構築できるようにする。
</p>

◎
There MUST exist a property on the ECMAScript global object whose name is “DOMException” and value is an object called the DOMException constructor object, which provides access to legacy DOMException code constants and allows construction of DOMException instances. The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</div>


			<section id="es-DOMException-constructor-object">
<h4 title="DOMException constructor object">4.11.1. DOMException 構築子~obj</h4>

<p>
`DOMException 構築子~obj$は、
`Prototype^es 値 `Error^ （ `ECMA-262$r 6.1.7.4 節）は伴わない，関数~objで~MUST。
◎
The DOMException constructor object MUST be a function object but with a [[Prototype]] value of %Error% ([ECMA-262], section 6.1.7.4).
</p>

<p>
</p>


<div class="p">
<p>
`~error名~一覧$に挙げられた どの旧来~codeに対しても，
`DOMException 構築子~obj$上に，次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
その名前と値は、一覧に指示されている名前と値
</li>
	<li>
属性 `FTF^desc を持つ
</li>
</ul>
◎
For every legacy code listed in the error names table, there MUST be a property on the DOMException constructor object whose name and value are as indicated in the table. The property has attributes { [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }.
</div>

<div class="p">
<p>
`DOMException 構築子~obj$は、次のように特徴付けられる~propを持た~MUST：
</p>

<ul>
	<!--cp-name-is-prototype-->
	<li>
値は
`DOMException 原型~obj@
と呼ばれる~obj（ `es-DOMException-prototype-object$secにて述べる）
</li>
	<!--cp-has-attr-FFF-->
</ul>

<p>
この~objは、その例外~上に宣言されている旧来~code値への~accessも提供する。
</p>

◎
The DOMException constructor object MUST also have a property named “prototype” with attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } whose value is an object called the DOMException prototype object. This object also provides access to the legacy code values.
</div>


				<section id="es-DOMException-call">
<h5 title="DOMException(message, name)">4.11.1.1. DOMException(%message, %name)</h5>

<p>
DOMException 関数が，引数 ( %message, %name ) を伴って，~callされたときは、次の手続きを行う：
◎
When the DOMException function is called with arguments message and name, the following steps are taken:
</p>

<ol>
	<li>
%F := the active 関数~obj
<span class="trans-note">【
<a href="~ES6#sec-execution-contexts">the active function object</a>
】</span>
◎
Let F be the active function object.
</li>
	<li>
%newTarget := ［
NewTarget ~EQ `undefined^v ならば %F ／
~ELSE_ NewTarget
］
<span class="trans-note">【
<a href="~ES6#sec-function-environment-records">`NewTarget^es</a>？
】</span>
◎
If NewTarget is undefined, let newTarget be F, else let newTarget be NewTarget.
</li>
	<li>
%super := %F.`GetPrototypeOf^es()
◎
Let super be F.[[GetPrototypeOf]]().
</li>
	<li>
`ReturnIfAbrupt$A(%super)
◎
ReturnIfAbrupt(super).
</li>
	<li>
~IF
`IsConstructor$A(%super) ~EQ `false^v
~THEN
~THROW `TypeError^t
◎
If IsConstructor(super) is false, throw a TypeError exception.
</li>
	<li>
%O := `Construct$A(%super, «%message», %newTarget)
◎
Let O be Construct(super, «‍message», newTarget).
</li>

	<li>
<p>
~IF
%name ~NEQ `undefined^v
：
◎
If name is not undefined, then
</p>
		<ol>
			<li>
%name := `ToString$A(%name)
◎
Let name be ToString(name).
</li>
			<li>
%status := `DefinePropertyOrThrow$A(%O, `name^l, `TFT-name^desc )
◎
Let status be DefinePropertyOrThrow(O, "name", PropertyDescriptor{[[Value]]: name, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).
</li>
			<li>
`ReturnIfAbrupt$A(%status)
◎
ReturnIfAbrupt(status).
</li>
			<li>
%code := ［
~error名に対し`~error名~一覧$に旧来~codeが指示されていれば それ ／
~ELSE_ `0^v
］
◎
Let code be the legacy code indicated in the error names table for error name name, or 0 if there is none.
</li>
			<li>
%status := `DefinePropertyOrThrow$A(%O, `code^l, `TFT-code^desc)
◎
Let status be DefinePropertyOrThrow(O, "code", PropertyDescriptor{[[Value]]: code, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).
</li>
			<li>
`ReturnIfAbrupt$A(%status)
◎
ReturnIfAbrupt(status).
</li>
		</ol>
	</li>
	<li>
~RET %O
◎
Return O.
</li>
</ol>

				</section>
			</section>
			<section id="es-DOMException-prototype-object">
<h4 title="DOMException prototype object">4.11.2. DOMException 原型~obj</h4>

<p>
`DOMException 原型~obj$は、
`ErrorPrototype^ （ `ECMA-262$r 6.1.7.4 節）を値にとる `Prototype^es 内的~propを持た~MUST。
◎
The DOMException prototype object MUST have an internal [[Prototype]] property whose value is %ErrorPrototype% ([ECMA-262], section 6.1.7.4).
</p>

<p>
`DOMException 原型~obj$の`~class文字列$は、 `DOMExceptionPrototype^l で~MUST。
◎
The class string of the DOMException prototype object is “DOMExceptionPrototype”.
</p>

<div class="p">
<p>
`DOMException 原型~obj$上には、次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `constructor^l
</li>
	<li>
値は `DOMException 構築子~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>

◎
There MUST be a property named “constructor” on the DOMException prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the DOMException constructor object.
</div>

<div class="p">
<p>
`~error名~一覧$に挙げられた どの旧来~codeに対しても，
`DOMException 原型~obj$上に，次のように特徴付けられる~propが存在し~MUST：
</p>

<ul>
	<li>
その名前と値は、一覧に指示されている名前と値
</li>
	<li>
属性 `FTF^desc を持つ
</li>
</ul>
◎
For every legacy code listed in the error names table, there MUST be a property on the DOMException prototype object whose name and value are as indicated in the table. The property has attributes { [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }.
</div>

			</section>
		</section>
		<section id="es-exception-objects" class="v2">
<h3 title="Exception objects">4.12. 例外~obj</h3>

<p class="trans-note">【
この節の内容は、第１版から一新されている。
】</p>

<p>
`単純例外$は、対応する型の~native ECMAScript ~objにより表現される。
◎
Simple exceptions are represented by native ECMAScript objects of the corresponding type.
</p>

<p>
`DOMException$ は、 `DOMException 原型~obj$を継承する`~platform~obj$により表現される。
◎
DOMExceptions are represented by platform objects that inherit from the DOMException prototype object.
</p>

<p>
<p>
ECMAScript 内で DOMException を表現している，どの~platform~objも、`初期~obj$と丁度~同じ様に大域環境に属する。
通常のように, あるいは `new^c 式の一部として，`DOMException 構築子~obj$の~callにより作成された例外~objが属する大域環境は、
`DOMException 構築子~obj$自身が属する大域環境と同じで~MUST。
◎
Every platform object representing a DOMException in ECMAScript is associated with a global environment, just as the initial objects are. When an exception object is created by calling the DOMException constructor object, either normally or as part of a new expression, then the global environment of the newly created object is associated with MUST be the same as for the DOMException constructor object itself.
</p>

<p>
その
`DOMException$ ~obj %O の `Prototype^es 内的~propの値は、 %O が属する大域環境に属する `DOMException 原型~obj$で~MUST。
◎
The value of the internal [[Prototype]] property of a DOMException object MUST be the DOMException prototype object from the global environment the exception object is associated with.
</p>

<p>
`DOMException$ ~objの `~class文字列$は， `DOMException^l で~MUST。
◎
The class string of a DOMException object MUST be “DOMException”.
</p>

<div class="note"><p>
DOMException ~objの意図は、［
`Object.prototype.toString^c に渡されたときに応答が異なることと, 
`code^l ~propを持つこと
］を除いて， ECMAScript 仕様が定義する他の種々の~native `Error^t ~objと同様になることである。
~native `Error^t ~obj上に
— 例えば~stack~traceや~error行番号などを公開するような —
非標準の~propを与える実装は、それらを例外~obj上にも公開しなければならないことになる。
◎
The intention is for DOMException objects to be just like the other various native Error objects that the ECMAScript specification defines, apart from responding differently to being passed to Object.prototype.toString and it having a “code” property. If an implementation places non-standard properties on native Error objects, exposing for example stack traces or error line numbers, then these ought to be exposed on exception objects too.
</p></div>

		</section>
		<section id="es-creating-throwing-exceptions" class="v2">
<h3 title="Creating and throwing exceptions">4.13. 例外の作成と投出</h3>

<p class="trans-note">【
この節の内容は、第１版から一新されている。
】</p>

<p>
最初に、
`現在の大域環境@
を，次の~algoを走らせた結果として定義する：
◎
First, we define the current global environment as the result of running the following algorithm:
</p>

<ol class="algorithm">
	<li>

<p>
%F := ECMAScript ~call~stack上の最上層の~callの中で `this^v 値に利用されている `Function^t ~obj
— ここで， %F は次のいずれかの IDL 構成子に対応する：
</p>

<ul ><li>`属性$
</li><li>`演算$
</li><li>`有index~prop$
</li><li>`有名~prop$
</li><li>`Constructor$x
</li><li>`有名~構築子$
</li><li>`文字列化子$
</li></ul>

◎
Let F be the Function object used as the this value in the top-most call on the ECMAScript call stack where F corresponds to an IDL attribute, operation, indexed property, named property, constructor, named constructor or stringifier.
</li>

	<li>
<p>
~RET %F に対応する IDL 構成子に応じて，次で与えられる`~ifc$
<span class="trans-note">【を表現する`~platform~obj$】</span>
が属する大域環境
◎
↓</p>

		<dl class="switch">
			<dt>属性</dt>
			<dt>演算</dt>
			<dt>文字列化子</dt>
			<dd>
その定義が現れる~ifc
◎
If F corresponds to an attribute, operation or stringifier, then return the global environment associated with the interface that definition appears on.
</dd>

			<dt>有index~prop</dt>
			<dt>有名~prop</dt>
			<dd>
その~propの［
取得子／設定子／削除子
］が定義されている~ifc
◎
Otherwise, if F corresponds to an indexed or named property, then return the global environment associated with the interface that the indexed or named property getter, setter or deleter was defined on.
</dd>

			<dt>有名~構築子</dt>
			<dt>`~ifc~obj$である構築子</dt>
			<dd>
その構築子に対応する~ifc
◎
Otherwise, if F is a named constructor for an interface, or is an interface object for an interface that is a constructor, then return the global environment associated with that interface.
</dd>

			<dt>例外~field取得子†</dt>
			<dd>
その例外~fieldが定義されている例外
◎
Otherwise, F is an exception field getter. Return the global environment associated with the exception on which the exception field was defined.
</dd>
			<dd class="trans-note">【†
この項は不要であろう（仕様の更新に伴う削除漏れ — 例外~field取得子は，過去版に定義されていたが、その記述は現在~削除されている）。
】</dd>
		</dl>
	</li>
</ol>



<p>
［
名前 %N, ~UAにより定義される~message %M
］（ %M は随意）を伴う，`単純例外$／ `DOMException$ %E
を`作成する$ときは、次の手続きに従わ~MUST：
◎
When a simple exception or DOMException E is to be created, with error name N and optional user agent-defined message M, the following steps MUST be followed:
</p>

<ol class="algorithm">

	<li>
%M := ［
%M が指定されていないならば `undefined^v ／
~ELSE_ %M を `String^t 値に`toES^した結果
］
◎
If M was not specified, let M be undefined. Otherwise, let it be the result of converting M to a String value.
</li>
	<li>
%N := %N を `String^t 値に`toES^した結果
◎
Let N be the result of converting N to a String value.
</li>
	<li>
<p>
%args := %E の型に応じて，次で与えられる ECMAScript 値の~list：
◎
Let args be a list of ECMAScript values.
</p>
		<dl class="switch">
			<dt>`DOMException$◎E is DOMException</dt>
			<dd>
(`undefined^v, %N)
◎
args is (undefined, N).
</dd>

			<dt>`単純例外$◎E is a simple exception</dt>
			<dd>
(%M)
◎
args is (M)
</dd>

		</dl>

	<li>
%G := `現在の大域環境$
◎
Let G be the current global environment.
</li>

	<li>
<p>
%X := %E の型に応じて，次で与えられる~obj：
◎
Let X be an object determined based on the type of E:
</p>
		<dl class="switch">
			<dt>`DOMException$◎E is DOMException</dt>
			<dd>
%G に属する， `DOMException 構築子~obj$
◎
X is the DOMException constructor object from the global environment G.
</dd>

			<dt>`単純例外$◎E is a simple exception</dt>
			<dd>
%G に属する，対応する ECMAScript error のための構築子
◎

X is the constructor for the corresponding ECMAScript error from the global environment G.
</dd>

		</dl>
	</li>

	<li>
~RET %args を引数~listとして， %X を関数として~callした結果
◎
Let O be the result of calling X as a function with args as the argument list.
◎
Return O.
</li>
</ol>


<p>
［
`~error名$ %N, ~UAにより定義される~message %M
］（ %M は随意）を伴う，
IDL `単純例外$／ `DOMException$ %E を`投出する$ときは、次の手続きに従わ~MUST：
◎
When a simple exception or DOMException E is to be thrown, with error name N and optional user agent-defined message M, the following steps MUST be followed:
</p>

<ol>
	<li>
%O := ［
`~error名$ %N,
~message %M
］を伴う，指定された例外 %E を`作成-$した結果
◎
Let O be the result of creating the specified exception E with error name N and optional user agent-defined message M.
</li>

	<li>
%O を投出する
◎
Throw O.
</li>

</ol>

<div class="note">

<p>
上の~algoは、
<a href="#es-exception-objects">例外を表現する~platform~obj</a>
が， `Function^t %F から［
%F が出自にする大域環境
］の外へ伝播することを制約しない。
例えば、次の IDL を考える：
◎
The above algorithms do not restrict platform objects representing exceptions propagating out of a Function to be ones that are associated with the global environment where that Function object originated. For example, consider the IDL:
</p>

<pre class="idl-code">
interface A {

  // <span title="Calls computeSquareRoot on m, passing x as its argument."
>( %x ) を引数に %m 上の `computeSquareRoot^M を~call</span>
  double doComputation(MathUtils m, double x);
};

interface MathUtils {
  // <span title="If x is negative, throws a NotSupportedError.  Otherwise, returns the square root of x."
>%x が負ならば `NotSupportedError^t を投出。そうでなければ %x の平方根を返す。</span>
  double computeSquareRoot(double x);
};
</pre>

<p>
異なる大域環境に属する `MathUtils^T ~objを doComputation に渡した場合、投出される例外は，その大域環境に属する：
◎
If we pass a MathUtils object from a different global environment to doComputation, then the exception thrown will be from that global environment:
</p>

<pre class="es-code">
var a = getA();                      // <span title="An A object from this global environment."
>この大域環境に属する~obj</span>
var m = otherWindow.getMathUtils();  // <span title="A MathUtils object from a different global environment."
>異なる大域環境に属する `MathUtils^T ~obj</span>

a instanceof Object;                 // <!--cp-eval-true-->
m instanceof Object;                 // <!--cp-eval-false-->
m instanceof otherWindow.Object;     // <!--cp-eval-true-->

try {
  a.doComputation(m, -1);
} catch (e) {
  e instanceof DOMException;          // <!--cp-eval-false-->
  e instanceof otherWindow.DOMException;  // <!--cp-eval-true-->
}
</pre>
</div>

<p>
この文書が ECMAScript 組込みの `Error^t ~instanceの投出に課す，どの要件も、
`現在の大域環境$に属する組込みのものを利用し~MUST。
◎
Any requirements in this document to throw an instance of an ECMAScript built-in Error MUST use the built-in from the current global environment.
</p>
		</section>
		<section id="es-handling-exceptions">
<h3 title="Handling exceptions">4.14. 例外の取扱い</h3>


<p>
ECMAScript 言語束縛のどの~algoも, 処理~要件も、
ECMAScript 例外を~catchしない。
ECMAScript `Function^v がこの節の要件により呼出され，その `Function^v が例外の投出により終了したときはいつでも、その例外は~call元まで（そこで~catchされない場合は更にその~call元まで，等々）伝播し~MUST。
◎
None of the algorithms or processing requirements in the ECMAScript language binding catch ECMAScript exceptions. Whenever an ECMAScript Function is invoked due to requirements in this section and that Function ends due to an exception being thrown, that exception MUST propagate to the caller, and if not caught there, to its caller, and so on.
</p>

<div class="example">
<p>
次の `IDL 片$は２つの`~ifc$と１つの`例外$を定義する。
`ExceptionThrower^T 上の `valueOf^M 属性は、その値の取得-が試みられたときに常に例外を投出するように定義されている。
◎
The following IDL fragment defines two interfaces and an exception. The valueOf attribute on ExceptionThrower is defined to throw an exception whenever an attempt is made to get its value.
</p>

<pre class="idl-code">
interface Dahut {
  attribute DOMString type;
};

interface ExceptionThrower {
  // <span title="This attribute always throws a NotSupportedError and never returns a value."
>この属性は常に `NotSupportedError^t を投出し，決して値を返さない。</span>
  attribute long valueOf<!-- getraises(NotSupportedError)-->;
};
</pre>

<p>
ECMAScript 実装がこの~ifcを~supportしているとするとき、例外は次の~codeの様に取扱われる：
◎
Assuming an ECMAScript implementation supporting this interface, the following code demonstrates how exceptions are handled:
</p>

<pre class="es-code">
var d = getDahut();              // <span title="Obtain an instance of Dahut."
>`Dahut^T の~instanceを得る。</span>
var et = getExceptionThrower();  // <span title="Obtain an instance of ExceptionThrower."
>`ExceptionThrower^T の~instanceを得る。</span>

try {
  d.type = { toString: function() { throw "abc"; } };
} catch (e) {
  /* <span title="The string &quot;abc&quot; is caught here, since as part of the conversion
from the native object to a string, the anonymous function
was invoked, and none of the [[DefaultValue]], ToPrimitive or
ToString algorithms are defined to catch the exception."
>文字列 `abc^l はここで~catchされる。何故なら、~native~objから
   文字列への変換の一環として匿名~関数が呼出され，
   `DefaultValue^es, ToPrimitive, ToString のいずれの~algoも，
   例外を~catchするように定義されていないので。</span> */
}

try {
  d.type = { toString: { } };
} catch (e) {
  /* <span title="An exception is caught here, since an attempt is made to invoke
[[Call]] on the native object that is the value of toString property."
>例外はここで~catchされる。 toString ~propの値である
   ~native~obj上で `Call^es の呼出しが試みられるので。</span> */
}

d.type = et;
  /* <span title="An uncaught NotSupportedError DOMException is thrown here, since the
[[DefaultValue]] algorithm attempts to get the value of the
&quot;valueOf&quot; property on the ExceptionThrower object.
The exception propagates out of this block of code."
>~catchされなかった `NotSupportedError^t `DOMException$ は ここで投出される。
   `DefaultValue^es ~algoは， `ExceptionThrower^T ~obj上の
   `valueOf^l ~propの値の取得-を試みるので。
   例外はこの~code~blockの外へ伝播する。</span> */
</pre>
</div>
		</section>
	</section>
	<section id="common">
<h2 title="Common definitions">5. 共通の定義</h2>


<p>
この節では、すべての`適合~実装$が~supportし~MUST，いくつかの共通の定義を指定する。
◎
This section specifies some common definitions that all conforming implementations MUST support.
</p>

		<section id="common-ArrayBufferView" class="v2">
<h3 title="ArrayBufferView">5.1. ArrayBufferView</h3>

<pre class="idl-code">
typedef (Int8Array or Int16Array or Int32Array or
         Uint8Array or Uint16Array or Uint32Array or Uint8ClampedArray or
         Float32Array or Float64Array or DataView) ArrayBufferView;
</pre>

<p>
`ArrayBufferView^T ~typedefは、
`ArrayBuffer$T 上の~viewを提供する~objを表現するために利用される。
◎
The ArrayBufferView typedef is used to represent objects that provide a view on to an ArrayBuffer.
</p>


		</section>

		<section id="common-BufferSource" class="v2">
<h3 title="BufferSource">5.2. BufferSource</h3>

<pre class="idl-code">
typedef (ArrayBufferView or ArrayBuffer) BufferSource;
</pre>


<p>
`BufferSource^T ~typedefは、
`ArrayBuffer$T ~obj自身, または
`ArrayBuffer$T 上の~viewを提供する~objを表現するために利用される。
◎
The BufferSource typedef is used to represent objects that are either themselves an ArrayBuffer or which provide a view on to an ArrayBuffer. 
</p>


		</section>
		<section id="common-DOMTimeStamp">
<h3 title="DOMTimeStamp">5.3. DOMTimeStamp</h3>


<pre class="idl-code">
typedef unsigned long long DOMTimeStamp;
</pre>

<p>
`DOMTimeStamp^T 型は、ミリ秒数を表現するために利用される。
（何らかの起点に相対的な）絶対的な時間として，または相対的な時間差として。
この型を利用する仕様は、ミリ秒数の解釈され方も定義する必要がある。
◎
The DOMTimeStamp type is used for representing a number of milliseconds, either as an absolute time (relative to some epoch) or as a relative amount of time. Specifications that use this type will need to define how the number of milliseconds is to be interpreted.
</p>
		</section>
		<section id="common-Function">
<h3 title="Function">5.4. Function</h3>


<pre class="idl-code">
callback Function = any (any... arguments);
</pre>

<p>
`Function^T `呼戻~関数$型は、渡される引数や返値の種類に制約のない関数~値を表現するために利用される。
◎
The Function callback function type is used for representing function values with no restriction on what arguments are passed to it or what kind of value is returned from it.
</p>
		</section>
		<section id="common-VoidFunction">
<h3 title="VoidFunction">5.5. VoidFunction</h3>


<pre class="idl-code">
callback VoidFunction = void ();
</pre>

<p>
`VoidFunction^T `呼戻~関数$型は
引数をとらず, 値を返さない関数~値を表現するために利用される。
◎
The VoidFunction callback function type is used for representing function values that take no arguments and do not return any value.
</p>
		</section>
	</section>
	<section id="extensibility">
<h2 title="Extensibility">6. 拡張性</h2>

~INFORMATIVE

<p>
言語束縛の要件に対する拡張は、この文書~内で定義される拡張属性と競合しない`拡張属性$を利用して指定できる。
［
私的なプロジェクト特有の利用
］のための拡張は、他の仕様に現れる `IDL 片$に含められるべきではない。
他の仕様の用途に要求される拡張は、この文書の将来~versionに取り込まれるためには，
<cite>Web IDL</cite> の担当グループ（この文書が書かれた時点では
<a href="http://www.w3.org/WebPlatform/WG/">W3C Web Platform Working Group</a>
）による~~調整を通すことが推奨される。
◎
Extensions to language binding requirements can be specified using extended attributes that do not conflict with those defined in this document. Extensions for private, project-specific use should not be included in IDL fragments appearing in other specifications. It is recommended that extensions that are required for use in other specifications be coordinated with the group responsible for work on Web IDL, which at the time of writing is the W3C Web Platform Working Group, for possible inclusion in a future version of this document.
</p>

<p>
IDL 言語の他の側面の拡張は極力~避けられるべきである。
◎
Extensions to any other aspect of the IDL language are strongly discouraged.
</p>
	</section>
	<section id="referencing">
<h2 title="Referencing this specification">7. この仕様を参照するとき</h2>

~INFORMATIVE

<p>
一つ以上の`IDL 片$を利用して Web ~platform~ifcを定義する他の仕様は、この仕様を参照することになるものと期待されている。
それらの仕様には、 IDL が この仕様の記述に従って解釈されることを指示する，次の様な~~文を含ませることを勧める：
◎
It is expected that other specifications that define Web platform interfaces using one or more IDL fragments will reference this specification. It is suggested that those specifications include a sentence such as the following, to indicate that the IDL is to be interpreted as described in this specification:
</p>

<blockquote>
この仕様の付録 A の中の IDL 片は、この仕様が規範とする参照文献にて定義される IDL 片とともに，［
“Web IDL” 仕様に述べられる， <em>適合 IDL 片の集合</em> に課される要件
］に従って、解釈され~MUST。<!--  -->
<a class="placeholder">[WEBIDL]</a>
◎
The IDL fragment in Appendix A of this specification must, in conjunction with the IDL fragments defined in this specification's normative references, be interpreted as required for conforming sets of IDL fragments, as described in the “Web IDL” specification. [WEBIDL]
</blockquote>

<p>
加えて、この仕様を参照する仕様における，~UAのための適合性クラスは、この仕様の
`適合~実装$クラスを参照することを勧める：
◎
In addition, it is suggested that the conformance class for user agents in referencing specifications be linked to the conforming implementation class from this specification:
</p>

<blockquote>
適合 FooML ~UAは、 “Web IDL” 仕様の記述に則り，この仕様の付録 A に示されている IDL 片に対しても <em>適合~実装</em> で~MUST。
<a class="placeholder">[WEBIDL]</a>
◎
A conforming FooML user agent must also be a conforming implementation of the IDL fragment in Appendix A of this specification, as described in the “Web IDL” specification. [WEBIDL]
</blockquote>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">8. 謝辞</h2>

~INFORMATIVE

<p>
編集者は、この仕様に~~寄与された，次の方々に感謝する：
</p>
<p>
The editor would like to thank the following people for contributing
to this specification:

Glenn Adams,
David Andersson,
L.&nbsp;David Baron,
Art Barstow,
Nils Barth,
Robin Berjon,
David Bruant,
Jan-Ivar Bruaroey,
Marcos Cáceres,
Giovanni Campagna,
Domenic Denicola,
Michael Dyck,
Brendan Eich,
João Eiras,
Gorm Haug Eriksen,
Sigbjorn Finne,
David Flanagan,
Aryeh Gregor,
Dimitry Golubovsky,
James Graham,
Aryeh Gregor,
Kartikaya Gupta,
Marcin Hanclik,
Jed Hartman,
Stefan Haustein,
Dominique Hazaël-Massieux,
Ian Hickson,
Björn Höhrmann,
Kyle Huey,
Lachlan Hunt,
Oliver Hunt,
Jim Jewett,
Wolfgang Keller,
Anne van Kesteren,
Olav Junker Kjær,
Magnus Kristiansen,
Takeshi Kurosawa,
Yves Lafon,
Travis Leithead,
Jim Ley,
Kevin Lindsey,
Jens Lindström,
Peter Linss,
呂康豪 (Kang-Hao Lu),
Kyle Machulis,
Mark Miller,
Ms2ger,
Andrew Oakley,
岡坂&nbsp;史紀 (Shiki Okasaka),
Jason Orendorff,
Olli Pettay,
Simon Pieters,
Andrei Popescu,
François Remy,
Tim Renouf,
Alex Russell,
Takashi Sakamoto,
Doug Schepers,
Jonas Sicking,
Garrett Smith,
Geoffrey Sneddon,
Jungkee Song,
Josh Soref,
Maciej Stachowiak,
Anton Tayanovskyy,
Peter Van der Beken,
Jeff Walden,
Allen Wirfs-Brock,
Jeffrey Yasskin and
Collin Xu.
</p>

<p>
編集者が休みの間、この文書を維持されていた Sam Weinig に特別な謝意を。
◎
Special thanks also go to Sam Weinig for maintaining this document while the editor was unavailable to do so.
</p>
	</section>

</div><!-- id="sections" -->

<div id="appendices">
	<section id="idl-grammar">
<h2 title="A. IDL grammar">A. IDL 文法</h2>


<p>
この節では、開始~記号 `Definitions$g が `IDL 片$全体に合致する，
LL(1) 文法を定義する。
◎
This section defines an LL(1) grammar whose start symbol, Definitions, matches an entire IDL fragment.
</p>


<p>
文法~内の各~生成規則は、その右側に，１個~以上の 終端／非~終端 記号の並び, または［
記号なしを指示する epsilon （ ε ）
］を持つ。
大文字から始まる記号は，非~終端~記号であり、引用符で括られた記号は，引用符~内のテキストに正確に合致する終端~記号である。
小文字から始まる記号は次の様な正規表現に合致する終端~記号である
（Perl 5 の正規表現~構文 `PERLRE$r を利用）：
◎
Each production in the grammar has on its right hand side either a non-zero sequence of terminal and non-terminal symbols, or an epsilon (ε) which indicates no symbols. Symbols that begin with an uppercase letter are non-terminal symbols. Symbols within quotes are terminal symbols that are matched with the exact text between the quotes. Symbols that begin with a lowercase letter are terminal symbols that are matched by the regular expressions (using Perl 5 regular expression syntax [PERLRE]) as follows:
</p>

<dl class="grammar" id="terminals">
<dt id="prod-integer">`integer^g</dt>
<dd class="regex">-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)</dd>

<dt id="prod-float">`float^g</dt>
<dd class="regex">-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)</dd>

<dt id="prod-identifier">`identifier^g</dt>
<dd class="regex">_?[A-Za-z][0-9A-Z_a-z-]*</dd>

<dt id="prod-string">`string^g</dt>
<dd class="regex">"[^"]*"</dd>

<dt id="prod-whitespace">`whitespace^g</dt>
<dd class="regex">[\t\n\r ]+</dd>

<dt id="prod-comment">`comment^g</dt>
<dd class="regex">\/\/.*|\/\*(.|\n)*?\*\/</dd>
<dt id="prod-other">`other^g</dt>
<dd class="regex">[^\t\n\r 0-9A-Za-z]</dd>

</dl>

<p>
~tok化は Unicode 文字~並び `UNICODE$r に対し演算する。
~tok化の際には、最長合致が利用され~MUST。
例えば，入力テキストが
“<span class="input">a1</span>”
であるなら、それは１個の `identifier$g に~tok化され，
`identifier$g と `integer$g には分離されない。
最長合致が［
上に挙げた，名前を持つ終端~記号の いずれか
］と［
文法~内の，引用符で括られた終端~記号
］のいずれにも合致し得る場合、後者の終端~記号に~tok化され~MUST。
したがって、入力テキスト
“<span class="input">long</span>”
は，
`identifier$g `long^l ではなく，引用符で括られた終端~記号 `long^sym
として~tok化され、
“<span class="input">.</span>”
は，
`other$g
ではなく，引用符で括られた終端~記号
`.^sym
として~tok化される。
◎
The tokenizer operates on a sequence of Unicode characters [UNICODE]. When tokenizing, the longest possible match MUST be used. For example, if the input text is “a1”, it is tokenized as a single identifier, and not as a separate identifier and integer. If the longest possible match could match one of the above named terminal symbols or one of the quoted terminal symbols from the grammar, it MUST be tokenized as the quoted terminal symbol. Thus, the input text “long” is tokenized as the quoted terminal symbol "long" rather than an identifier called “long”, and “.” is tokenized as the quoted terminal symbol "." rather than an other.
</p>

<p>
IDL 構文においては、文字の大小は，文法~内で利用される引用符で括られた終端~記号と
`identifier$g 終端~記号に利用される値の，いずれにおいても区別される。
したがって、例えば入力テキスト
“<span class="input">Const</span>”
は，引用符で括られた終端~記号
`const^sym ではなく `identifier$g として~tok化され、
`識別子$ `A^l を伴う`~ifc$は， `a^l を伴うそれとは異なるものになり、
また，`拡張属性$ `constructor^x が `Constructor$x 拡張属性に認識されることはない。
◎
The IDL syntax is case sensitive, both for the quoted terminal symbols used in the grammar and the values used for identifier terminals. Thus, for example, the input text “Const” is tokenized as an identifier rather than the quoted terminal symbol "const", an interface with identifier “A” is distinct from one named “a”, and an extended attribute [constructor] will not be recognized as the [Constructor] extended attribute.
</p>

<p>
`whitespace$g や `comment$g からなる任意~個数の終端~記号が、構文解析される入力テキストにおける，他のどの終端~記号の合間にも、暗黙的に許容される。
それらの `whitespace$g や `comment$g は、構文解析~時には無視される。
◎
Implicitly, any number of whitespace and comment terminals are allowed between every other terminal in the input text being parsed. Such whitespace and comment terminals are ignored while parsing.
</p>


<p>
次の LL(1) 文法の開始~記号 `Definitions$g が `IDL 片$に合致する：
◎
The following LL(1) grammar, starting with Definitions, matches an IDL fragment:
</p>

<p class="trans-note">【
見出しをクリックするとその文法~記号の~~参照元が示される（上の終端~記号の表も同様）。
】<br>
【
次の文法記号は第１版から削除-／置換されている：
<span class="sym">
AttributeOrOperation（ → AttributeOrOperationOrIterator ）,
StringifierAttributeOrOperation,
Operation（ → OperationOrIterator ）,
Qualifiers
<!-- OperationRest -->
</span>
】</p>

<!-- place holder for the over all grammar table -->
<div id="_p-grammar-table"></div>

<div class="note"><p>
非~終端~記号 `Other$g は、
`(^sym, `)^sym,
`[^sym, `]^sym,
`{^sym, `}^sym,
`,^sym
を除く，任意の１個の終端~記号に合致する。
◎
The Other non-terminal matches any single terminal symbol except for "(", ")", "[", "]", "{", "}" and ",".
</p></div>

<p>
非~終端~記号 `ExtendedAttribute$g は，任意の空でない終端~記号の並びに合致するが（丸括弧, 角括弧, 波括弧が対になっていて, かつ `,^sym ~tokがそれらの括弧対の間にのみ現れる限り）、それらの可能な並びのうち一部のみが
この仕様で定義される`拡張属性$に利用される —
これらの拡張属性に利用される構文については
`idl-extended-attributes$sec
に。
◎
While the ExtendedAttribute non-terminal matches any non-empty sequence of terminal symbols (as long as any parentheses, square brackets or braces are balanced, and the "," token appears only within those balanced brackets), only a subset of those possible sequences are used by the extended attributes defined in this specification — see section 3.11 for the syntaxes that are used by these extended attributes.
</p>
	</section>
	<section id="references">
<h2 title="References">B. 参照文献</h2>

		<section id="normative-references">
<h3 title="Normative references">B.1. 文献（規範的）</h3>

<dl>
	<dt class="v2">[ECMA-262]</dt>
	<dd>ECMAScript Language Specification, 6th Edition, A. Wirfs-Brock, Editor. Ecma International, 8 November 2013 (Working Draft).</dd>
	<dd>http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts</dd>
	<dd>http://people.mozilla.org/~jorendorff/es6-draft.html</dd>
	<dd>https://tc39.github.io/ecma262/</dd>
	<dd>http://www.ecma-international.org/ecma-262/6.0/</dd>

	<dt>[IEEE-754]</dt>
	<dd>IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985). Institute of Electrical and Electronics Engineers, 1985.</dd>

	<dt>[PERLRE]</dt>
	<dd>Perl regular expressions (Perl 5.8.8). The Perl Foundation, February 2006.
	<dd>http://www.perl.com/doc/manual/html/pod/perlre.html</dd>
	<dd class="trans-ja-refs"><a href="http://perldoc.jp/docs/perl/5.14.1/perlre.pod">日本語訳</a></dd>

	<dt>[RFC2119]</dt>
	<dd>Key words for use in RFCs to Indicate Requirement Levels,
S. Bradner.  IETF, March 1997.</dd>
	<dd>http://tools.ietf.org/html/rfc2119</dd>

	<dt>[RFC2781]</dt>
	<dd>UTF-16, an encoding of ISO 10646,
P. Hoffmann and F. Yergeau.  IETF, February 2000.</dd>
	<dd>http://tools.ietf.org/html/rfc2781</dd>

	<dt>[RFC3629]</dt>
	<dd>UTF-8, a transformation format of ISO 10646,
F. Yergeau.  IETF, November 2003.</dd>
	<dd>http://tools.ietf.org/html/rfc3629</dd>

	<dt>[SECURE-CONTEXTS]</dt>
	<dd>Secure Contexts. M. West and Y. Zhu, Editors.  World Wide Web Consortium, October 2015.</dd>
	<dd>https://w3c.github.io/webappsec-secure-contexts/</dd>

	<dt>[TYPEDARRAYS]</dt>
	<dd>Typed Array Specification,
V. Vukicevic and K. Russell, eds.  The Khronos Group, 08 February 2011.</dd>
	<dd>https://www.khronos.org/registry/typedarray/specs/1.0/</dd>

	<dt>[UNICODE]</dt>
	<dd>The Unicode Standard,
Version 6.0 or later.  The Unicode Consortium.  Mountain View, California, 2011.
ISBN 978-1-936213-01-6.</dd>
	<dd>http://www.unicode.org/versions/Unicode6.0.0/</dd>
</dl>
		</section>
		<section id="informative-references">
<h3 title="Informative references">B.2. 文献（参考）</h3>

<dl>
	<dt>[DOM]</dt>
	<dd>DOM Standard.
A. van Kesteren, A. Gregor and Ms2ger, Editors.  WHATWG, 22 July 2013.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>

	<dt>[DOM3CORE]</dt>
	<dd>Document Object Model (DOM) Level 3 Core Specification.
A. Le Hors, et al., Editors.  World Wide Web Consortium, April 2004.</dd>
	<dd>http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/</dd>

	<dt>[HTML5]</dt>
	<dd>HTML5.
I. Hickson, Editor.  World Wide Web Consortium, May 2011.</dd>
	<dd>http://www.w3.org/TR/2011/WD-html5-20110525/</dd>

	<dt>[HTML]</dt><!-- 追加 -->
	<dd>HTML,
I. Hickson, Editor. WHATWG, 30 July 2013.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

	<dt>[OMGIDL]</dt>
	<dd>CORBA 3.1 – OMG IDL Syntax and Semantics chapter.
Object Management Group, January 2008.</dd>
	<dd>http://www.omg.org/cgi-bin/doc?formal/08-01-04.pdf</dd>

	<dt>[WEBIDL-JAVA]</dt>
	<dd>Java langage binding for Web IDL.
World Wide Consortium, work in progress.</dd>
	<dd>http://dev.w3.org/2006/webapi/WebIDL/java.html</dd>

	<dt>[XMLNS]</dt>
	<dd>Namespaces in XML 1.0 (Third Edition),
T. Bray, D. Hollander, A. Layman, R. Tobin, H. Thompson, eds. World Wide Web Consortium, 8 December 2009.</dd>
	<dd>http://www.w3.org/TR/2009/REC-xml-names-20091208/</dd>

</dl>
		</section>
	</section>
	<section id="changes">
<h2 title="Changes">C. 変更点</h2>

~INFORMATIVE

<p>
この文書の各~発行における主要な変更点を以下に挙げる。
第１版の開発時における変更点については、その仕様の
<a href="http://heycam.github.io/webidl/v1.html#changes">変更点の節</a>
を~~参照のこと。
◎
The following is a list of substantial changes to the document on each publication. For the list of changes during the development of the First Edition of this specification, see that document's Changes appendix.
</p>

<dl class="changes">

	<dt>現在の編集者草案◎Current editor’s draft</dt>
	<dd>
<p>
以下は、第 2 版のみに対する変更点（最近のものから順に挙げる）：
</p>
		<ul class="v2">
			<li>
`SecureContext$x 拡張属性を追加した。
◎
Added the [SecureContext] extended attribute.
</li>
			<li>
ES6 に合わせるため、 `Unscopeable^x 拡張属性の名称を `Unscopable$x に変更した。
◎
Changed from [Unscopeable] to [Unscopable] to match ES6 better.
</li>
			<li>
用語 “列挙不可（ unenumerable ）” とそれに関わる注釈文を除去して、拡張属性 `LegacyUnenumerableNamedProperties$x に置換した。
◎
Removed the term "unenumerable" and its associated prose and replaced it by the extended attribute [LegacyUnenumerableNamedProperties].
</li>

			<li>
他の仕様が~objの内的~methを上書きすることを許容した。
◎
Allowed object internal methods to be overridden by other specifications.
</li>
			<li>
`保安検査を遂行する$~hookに~parameterを追加した。
◎
Added some more parameters to the “perform a security check” hook.
</li>
			<li>
すべての `Function^t ~objに対し、 `name^l ~propを定義した（演算, および属性の取得子と設定子に対するそれも含めて）。
◎
Defined the “name” property for all Function objects (including those for operations and attribute getters and setters).
</li>
			<li>
`Date^T 型を除去した。
◎
Removed the Date type.
</li>
			<li>
`定数$の識別子に対する
`length^l, `name^l
の利用を不許可にした。
◎
Disallowed “length” and “name” from being used as identifiers of constants.
</li>
			<li>
`FrozenArray_T^ 型を追加した。
◎
Added a FrozenArray&lt;T&gt; type.
</li>
			<li>
`ArrayClass^x を `LegacyArrayClass$x に改称した。
◎
Renamed [ArrayClass] to [LegacyArrayClass].
</li>
			<li>
`~varT[]^T  配列~型を除去した。
◎
Removed T[] array types.
</li>
			<li>
`NewObject^x を，~promise型を返すものにも許容した。
◎
Allowed [NewObject] to be used on things with a promise type.
</li>
			<li>
~maplike／~setlike が誤った~objに演算していた，種々の事例を修正した。
◎
Fix various cases in which maplike/setlike were operating on the wrong objects.
</li>
			<li>
~ifcの［
広義~帰結~ifc, 被継承~ifc
］の中に，複数の［
~maplike, ~setlike, 可反復
］宣言が現れるのを不許可にした。
また、［
~maplike／~setlike／可反復
］が宣言された~ifcの［
広義~帰結~ifc, 被継承~ifc
］についても，関連の制約される~mb名（ `entries^l, `values^l など）を不許可にした。
◎
Disallow maplike, setlike and iterable declarations from appearing more than once on an interface and its inherited and consequential interfaces. Also disallow the relevant restricted member names (such as “entries” and “values”) on the inherited and consequential interfaces.
</li>
			<li>
`stringifier^c を伴う属性には、
`USVString$T 型も許容されるようにした。
◎
Allowed stringifier attributes to have type USVString.
</li>
			<li>
ES6 に合致するよう、［
~ifc~obj, 有名~構築子, 辞書~構築子
］に `name^l ~propを追加した。
◎
Gave interface objects, named constructors, and dictionary constructors a "name" property to match ES6.
</li>
			<li>
辞書~構築子~上の `length^l ~propを，~configurableにした。
◎
Made the "length" property on dictionary constructors configurable.
</li>
			<li>
`ArrayBuffer$T, `DataView$T, 有型~配列~objに対する型を追加した。
◎
Added types for ArrayBuffer, DataView and typed array objects.
</li>
			<li>
`USVString^T を追加するとともに、
IDL における文字列~literalは，すべての［
文字列~型の［
~optional引数, 辞書~mb 既定~値
］］に値を与えるために利用できるようにした。
◎
Added USVString and allowed string literals in IDL to be used to give values for all string-typed optional argument and dictionary member default values.
</li>
			<li>
連列を［
辞書, 呼戻~関数, すべての~ifc型
］から判別可能にした。
◎
Made sequences distinguishable from dictionaries, callback functions, and all interface types.
</li>
			<li>
IDL 例外を除去し,
`DOMException$T を baked in。<!-- ＊ -->
`Error^t および `DOMException$T を型として追加した。
◎
Removed IDL exceptions, baked in DOMException, and added Error and DOMException as types.
</li>
			<li>
`MapLike^x を除去して，
`可反復~宣言$, `~maplike 宣言$, `~setlike 宣言$
を追加した。
◎
Removed [MapLike] and added iterable, maplike and setlike declarations.
</li>

			<li id="toString">
独自の `Object.prototype.toString^c 定義を除去し，代わりに
`~class文字列$が ~obj上の 
`toStringTag_symbol^ ~propに波及するように定義した。
◎
Removed the custom Object.prototype.toString definition and instead defined class strings to influence the @@toStringTag property on objects.
</li>
			<li>
`Unscopable^x 拡張属性を追加した。
◎
Added the [Unscopable] extended attribute.
</li>
			<li>
ES 値から IDL 連列~値への変換を，どの可反復も連列に変換し得るように書き換えた。
◎
Rewrote ES to IDL sequence conversion so that any iterable is
convertible to a sequence.
</li>
			<li>
`promise_T^ 型のための文法~生成規則を追加し， `void$T も %T に許容した。
◎
Added grammar production for Promise&lt;T&gt; types and allowed T to be void.
</li>


			<li>
`Map^t 構築子と同じように挙動する，
“可反復から~objを初期化する”
ための定義を追加した。
◎
Added a definition to "initialize an object from an iterable", which behaves like the Map constructor.
</li>


			<li>
連列~型の演算~引数や辞書~mbの既定~値に利用できる
`[]^c を追加した。
◎
Added a default value [] that can be used for
sequence-typed operation argument default values and
dictionary member default values.
</li>
			<li>
~promise型を追加した。
◎
Added promise types.
</li>
			<li>
`NewObject^x, `SameObject^x 拡張属性を追加した。
◎
Added the [NewObject] and [SameObject] extended attributes.
</li>
			<li>
辞書に対する `Constructor^x の指定を可能にした。
◎
Allowed [Constructor] to be specified on dictionaries.
</li>
			<li>
`RegExp^t 型を追加した。
◎
Added a RegExp type.
</li>
			<li>
~ifc上で宣言し得る反復子を追加した。
◎
Added iterators that can be declared on interfaces.
</li>
			<li>
有index~propを伴う~objに `iterator_symbol^ ~propを追加した。
◎
Added an @@iterator method to objects with indexed properties.
</li>
			<li>
ECMAScript 6th Edition に更新した。
◎
Updated to ECMAScript 6th Edition.
</li>
			<li>
直列化子を追加した。
◎
Added serializers.
</li>
			<li>
ECMAScript String 値のparticular encodingを伴わない 8 ~bit文字列を表現するための，
`ByteString^t 型を追加した。
◎
Added a ByteString type, for representing 8 bit strings without a particular encoding as ECMAScript String values.
</li>
			<li>
静的~属性を追加した。
◎
Added static attributes.
</li>
		</ul>

<!-- below are changes in v1 too -->
<p>
以下は、第 1 版, 第 2 版に加えられた変更点（最近のものから順に挙げる）：
</p>


		<ul>
			<li>
~ifcは、それが継承する~ifcが大域環境に`公開され$ないならば，自身もまた`公開され$ないことを明らかに。
◎
Make it clear that an interface can't be exposed in a global where its parent interface is not exposed.
</li>
			<li>
尾部に位置する辞書~型の演算~引数は、辞書~型が必須~辞書~mbを持たない場合には，随意にできるようにした。
◎
Allow dictionary-typed trailing-position operation arguments not to be optional, if and only if the dictionary type has a required dictionary member.
</li>
			<li>
有名／有index
設定子をより良く取扱えるようにするため、~platform~obj `Set^es 内的~methを追加した。
◎
Added a platform object [[Set]] internal method to handle named and indexed setters better.
</li>
			<li>
作成子の概念を除去した
— 設定子が常に作成子でもある。
◎
Removed the concept of creators; setters are always also creators.
</li>
			<li>
`NoInterfaceObject^x を伴わない~ifcによる
`NoInterfaceObject^x ~ifcの継承ingを不許可にした。
◎
Disallowed an interface without [NoInterfaceObject] inheriting from a [NoInterfaceObject] interface.
</li>
			<li>
有index~prop削除子を除去した。
◎
Removed indexed deleters.
</li>
			<li>
［［
継承階層の根元でない~ifc
］の~ifc~obj
］の原型は，その先祖~ifcの~ifc~objにした。
◎
Made the prototype of an interface object of a non-root
interface be the interface object of its ancestor interface.
</li>
			<li>
非~呼戻~ifc~objの `prototype^l ~propの~prop属性を明確化した。
◎
Clarified the property attributes of the "prototype" property of non-callback interface objects.
</li>


			<li>
~ifc~obj／有名~構築子
上の `length^l ~propを，~configurableにした。
◎
Made the "length" property on interface objects and named constructors configurable.
</li>
			<li>
辞書~mbを必須にする仕方を追加した。
◎
Added a way to mark dictionary members as required.
</li>
			<li>
識別子の最初の文字の後には，ハイフンも許容した。
◎
Allowed hyphens in identifiers after the first character.
</li>
			<li>
`Exposed^x についての言及を［
~ifc上の~mbに対する値<!-- ＊ -->には，その~ifc上の値が（もしあれば）既定で利用される
］ことを明らかにするよう修正した。
◎
Fix [Exposed] text to make it clear that the value on the interface, if any, is used as the value for its members by default.
</li>
			<li>
`Exposed^x など，識別子~listを引数にとる拡張属性の文法を修正した。
◎
Fixed the grammar for extended attributes that take an identifier list,
such as [Exposed].
</li>
			<li>
[[Enumerable]] が `false^v にされた~propを公開できるようにするための語 “列挙不可” を追加した。
◎
Add a term "unenumerable" to allow named properties to be exposed as properties with [[Enumerable]] set to false.
</li>
			<li>
`Exposed^x, `PrimaryGlobal^x 拡張属性を追加した。
それに伴い， `Global^x に識別子を利用できるようにした。
◎
Added the [Exposed] and [PrimaryGlobal] extended attributes and allowed an identifier to be used with [Global].
</li>
			<li>
`TreatUndefinedAs^x を削除した。
◎
Removed [TreatUndefinedAs].
</li>
			<li>
`TreatNonCallableAsNull^x を `TreatNonObjectAsNull^x に改称した上で、その意味論を，任意の~objが許容されるように変更した。
`TreatNonObjectAsNull^x の場合に生じ得るようになった［
~objが呼出可能でないときの，呼戻~関数の呼出
］に際しては、何もしないものとするよう，変更した。
◎
Renamed [TreatNonCallableAsNull] to [TreatNonObjectAsNull] and changed its semantics to allow any object. Changed callback function invocation to be a no-op when the object is not callable, which can now happen in the [TreatNonObjectAsNull] case.
</li>
			<li>
呼戻に対する既定の `this^v 値を `null^v から `undefined^v に変更した。
◎
Changed the default this value for callbacks from null to undefined.
</li>
			<li>
有名~prop~objが関数~objでなければならない要件を削除した。
◎
Removed the requirement for named properties objects to be function objects.
</li>
			<li>
有名~prop~obj上における~propの定義を不許可にした。
◎
Disallowed properties from being defined on a named properties object.
</li>
			<li>
有名~propの可視性判定~algoの無限~loopを修正した。
◎
Fixed infinite loop in named property visibility algorithm.
</li>
			<li>
文字列化子と直列化子は、属性や演算に委譲される挙動において，
`Get^es や `Call^es を利用しないようにした。
◎
Made stringifiers and serializers not use [[Get]] or [[Call]] for the their attribute or operation delegated behavior.
</li>
			<li>
enum ~listの末尾に，余分な~commaを許容した。
◎
Allowed trailing optional comma in enum lists.
</li>
			<li>
呼戻~ifc上に定義される静的~ifc~mbは、不許可にした。
◎
Disallowed static interface members from being defined on a callback interface.
</li>
			<li>
演算の呼出し／属性に対する~accessの際に，保安検査のための hook を追加した。
◎
Added a hook to do a security check when invoking an operation or accessing an attribute.
</li>
			<li>
呼戻が~incumbent~scriptに対しどのように波及するかを定義した。
◎
Defined how callbacks influence the incumbent script.
</li>
			<li>
~~省略された随意~引数~supportするため，呼戻~関数の呼出され方を変更した。
◎
Changed how callback functions are invoked to support missing optional arguments.
</li>
			<li>
`NamedPropertiesObject^x を `Global^x に改称した。
それは今や、~ifc~mbに対する~propが~ifc原型~objではなく，~obj自身の上に現れるようにする。
◎
Renamed [NamedPropertiesObject] to [Global], which now also causes properties for interface members to appear on the object itself rather than on the interface prototype object.
</li>
			<li>
他の primitive 型から `boolean$T を~~分離した。
［
`boolean$T, `実数~型$, `DOMString$T
］を，判別可能にした。
◎
Split out boolean from the other primitive types. Made boolean, numeric types and DOMString distinguishable.
</li>
			<li>
設定子, 作成子, 削除子
のいずれかを持つ~ifcには，取得子が在することを要求した。
◎
Required a getter to be present on an interface if it has a setter, creator or delete.
</li>
			<li>
`Unforgeable^x を，［
演算／~ifc
］にも適用されるように拡張した。
◎
Extended [Unforgeable] to apply to operations and interfaces.
</li>
			<li>
すべての演算~引数は随意として指定できるようにされ、
`undefined^v 引数~値は、~~省略された随意~引数~値として扱われる様に，挙動を元に戻した。
有効~多重定義~集合と多重定義~解決~algoにはこれが織り込まれると同時に，
判別引数~indexには `undefined^v 値も渡せるようになり，その~indexに位置する随意~引数を伴う多重定義が選定されるようにした。
同時に `TreatUndefinedAs=Missing^x も削除した。
◎
Allowed all operation arguments to be specified as being optional and changed back to the behavior of undefined being treated as a missing optional argument value. Modified the effective overload set and overload resolution algorithms to take this into account, as well as allowing an undefined value passed as the argument value at the distinguishing index to select the overload with an optional argument at that index. Also removed [TreatUndefinedAs=Missing].
</li>
			<li>
ECMAScript 値から IDL 辞書への変換~algoを，値 `undefined^v を伴う~propは存在しないものとして扱うように変更した。
◎
Changed the ECMAScript to IDL dictionary conversion algorithm to treat a property with the value undefined as missing.
</li>
			<li>
`typedef^c ~keywordの後に拡張属性を与えられる能を削除した。
その特色機能は利用されていないので。
◎
Removed the ability to put extended attributes after the typedef keyword, as that feature is unused.
</li>
			<li>
`long long$T, `unsigned long long$T の変換~algoを、連続的な範囲を正しく特定して，
`Number^t から得られる整数が一意に表現されるように修正した。
◎
Fixed the long long and unsigned long long conversion algorithms to correctly identify the range of contiguous, exactly, uniquely representable integers you can get from a Number.
</li>
			<li>
~implements_stを利用して mixed in された 演算, 属性~取得子, 属性~設定子に対する `Function^t ~objが各~ifcごとに異なるものであり、それぞれの `Function^t の複製が［
その `Function^t ~objを~ifc原型~obj上に持つ~ifc
］を実装する~obj上でのみ働くことについて、明確化した。
◎
Clarified that Function objects for operations and attribute getters and setters are distinct on each interface they are mixed in to using an implements statement, and that each copy of the Function works only on objects that implement the interface whose interface prototype object the Function object is on.
</li>
			<li>
初期~objの~list内の有名~prop~objに言及した。
◎
Mention the named properties object in the list of initial objects.
</li>
			<li>
他の window からの~objがそれらの instanceof であるものと見なされるようにするため
~ifc~obj上の custom `HasInstance^es を復活した。
◎
Added back a custom [[HasInstance]] on interface objects to allow objects from other windows to be considered instanceof them.
</li>
			<li>
`unrestricted double$T に対する変換~algoを利用して
`Number^t 値から `any$T への変換を修正した。
◎
Fixed conversion of Number values to any by using the conversion algorithm for unrestricted double.
</li>
			<li>
定数と静的~演算を除くどの構成子の識別子にも `prototype^l を許容した。
◎
Allowed an identifier to be “prototype” for any construct except constants and static operations.
</li>
			<li>
利用者~obj定義における、呼戻~ifcが複数の演算を持っているときでも `Call^es 内的~methが演算の実装として扱われるバグを修正した。
◎
Fixed a bug in the user object definition where the internal [[Call]] method would be treated as the implementation of an operation even if the callback interface had more than one operation.
</li>
			<li>
一貫性のため、多重定義~解決~algoと共用体~型の変換~algoを~~調整した。
◎
Further tweaked the overload resolution algorithm and union type conversion algorithm for consistency.
</li>
			<li>
IDL 属性 における `Unforgeable$x の出現について、その属性が宣言されている~ifcを別の~ifcが継承している場合の制約を解禁しつつ、継承している~ifcは同じ識別子を持つ属性を持たないものとする要件を追加した。
◎
Lifted the restriction on [Unforgeable] appearing on an IDL attribute if another interface inherits from the one the attribute is declared on, but required that the inheriting interface not have an attribute with the same identifier.
</li>
			<li>
属性~設定子に引数が渡されなかった場合に `undefined^v と見なす代わりに例外を投出するようにした。
◎
Made attribute setters throw if no argument was passed to them, instead of assuming undefined.
</li>
			<li>
辞書は自身を参照できないようにした。
◎
Prevented dictionaries from referencing themselves.
</li>
			<li>
`Array^t でない ECMAScript ~obj から連列~型や配列~型への変換を許容するため、連列, 配列, 辞書 は再び判別可能でないものとした。
◎
Made sequences, arrays and dictionaries undistingishable again, thereby allowing non-Array ECMAScript objects to be converted to sequence and array types.
</li>
			<li>
例外を投出する際のその各種~field値についての要件を追加した。
◎
Added a requirement to state what the values of an exception’s fields are when throwing it.
</li>
			<li>
IDL 演算 に対する Function ~obj上の `length^l ~propを，要求されている引数の最小の個数を返すように，変更した。
◎
Changed the “length” property on Function objects for IDL operations to return the smallest number of required arguments.
</li>
			<li>
辞書が演算~引数や辞書~mbの型に利用されている場合は~nullableになれないことを明確化した。
◎
Clarified that dictionaries may not be nullable when used as the type of an operation argument or dictionary member.
</li>
			<li>
構築子を持たない~ifc~obj上の `length^l ~propの値を指定した。
◎
Specify the value of the “length” property on interface objects that do not have constructors.
</li>
			<li>
~objが有indexおよび有名~propのいずれも~supportする場合に配列~index~propを
有名~propとして扱わないように。
◎
Do not treat array index properties as named properties if an object supports both indexed and named properties.
</li>
			<li>
随意~引数が後続するような，辞書~型の引数も随意とすることを必須化し、その種の随意~引数は，既定~値として常に空の辞書を持つと見なされることに。
また、辞書~型は、~nullable型の内側での利用は不許可にされ, ~nullable型とも判別可能でなくした。
◎
Require that dictionary type arguments followed by optional arguments must also be optional, and that such optional arguments always are assumed to have a default value of an empty dictionary. Also disallow dictionary types from being used inside nullable types and from being considered distinguishable from nullable types.
</li>
			<li>
辞書~mbには常に既定~値が在するものと見なされる。
◎
Always consider dictionary members with default values as present.
</li>
			<li>
明確性のため， `Clamp^x ~algoを~~調整した。
◎
Tweak [Clamp] algorithms for clarity.
</li>
			<li>
例外~objが `Class^es “Error” を持つことを要求した。
それらが~native Error ~objと同様の非標準~propを持つことに言及した。
◎
Require exception objects to have [[Class]] “Error” and suggest that they have any non-standard properties that native Error objects do.
</li>
			<li>
whitespace ~tokの正規表現の誤りを修正した。
◎
Fixed a bug in the whitespace token regular expression.
</li>
			<li>
属性や<!-- ＊ -->例外~fieldの型として，共用体~型の内側における辞書の利用を明示的に不許可にした。
◎
Explicitly disallow dictionaries from being used inside union types as the type of an attribute or exception field.
</li>
			<li>
判別可能の定義における、~nullable共用体~型と, ~nullable~mb型を持つ非~nullable共用体~型とが判別可能であった誤りを修正した。
◎
Fixed a bug in the definition of distinguishability where a nullable union type and a non-nullable union type that has a nullable member type were considered distinguishable.
</li>
			<li>
~implements_stにおける呼戻~ifcの利用を不許可にした。
◎
Disallowed callback interfaces from being used in implements statements.
</li>
			<li>
“例外~型” を “例外~名” に改称した。
◎
Renamed “exception types” to “exception names”.
</li>
			<li>
非~呼戻 ~ifcに対し呼戻~ifcからの継承ingを不許可にした。
◎
Disallowed non-callback interfaces from inheriting from callback interfaces.
</li>
			<li>
有index~propを伴う~platform~objから連列~型への変換のための~algoを、存在すら不確かな `length^l ~propの取得ではなく，その~prop~indexの集合についての内的~知識を利用するように，変更した。
◎
Changed the algorithm for conversion from a platform object with indexed properties to a sequence type to use its internal knowledge of the set of property indexes rather than getting the "length" property, which may not even exist.
</li>
			<li>
32 ~bit型を選択する良い理由がない限り，
`float^T より `double^T の利用が選好されることについての警告を追加した。
◎
Added a warning to prefer the use of double to float, unless there are good reasons to choose the 32 bit type.
</li>
			<li>
演算~引数の既定~値に課される制約を、
“既定~値を持つ随意~引数の左側に位置するすべての随意~引数は既定~値を持たなければならない”
に変更した（以前は、右側，とされていた）。
◎
Changed the restriction on operation argument default values so that all optional arguments to the left of one with a default value must also have default values. (Previously, this was to the right.)
</li>
		</ul>
	</dd>
</dl>

	</section>
</div><!-- id="appendices" -->

</main><!-- id="MAIN" -->

<p id="END_DOCUMENT" >&nbsp;&nbsp;&nbsp;</p><!-- ＊？ -->

</body></html>
<!-- 
<span class="comment">// ([^<]+)</span>
→
// <span title=
	"$1"
	>$1</span>

	●＊廃
	列挙不可:#dfn-unenumerable

	作成子
	例外~field:exception-field
	例外~field取得子:exception-field-getter
	例外~ifc~obj:exception-interface-object
		es-DOMException-constructor-object
	例外~ifc原型~obj:exception-interface-prototype-object
		es-DOMException-prototype-object
	
	例外~mb:exception-member
	例外~名:exception-name
	
	定義済み~例外:predefined-exception
	既定の偽装不可 toString 関数:default-unforgeable-toString-function
	反復子の挙動:iterator-behavior
	反復状態:iterator-state
	反復子~obj:iterator-object
	反復型:iterated-type
	反復子:iterator
	有index~prop削除子:indexed-property-deleter／150120
150706
	適合 IDL 片:conforming-idl-fragment
	固定長:fixed-length
	可変長:variable-length
	継承-:inherit-exception
	配列読専:<a class="dfnref" href="#dfn-read-only-array">読専</a>
array_T:<a class="idltype" href="#idl-array">~varT[]</a>
	es-array:4.2.26
	platform-array-object-getownproperty:4.2.26.1
	platform-array-object-defineownproperty:4.2.26.2
	platform-array-object-delete:4.2.26.3
3.10.25:idl-array
4.2.25:es-array
3.10.27 idl-Date
4.2.28 es-Date
~platform配列~obj:platform-array-object
<p id="es-to-array"></p>
<p id="array-to-es"></p>
	legacyiterable
-->
