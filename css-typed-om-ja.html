<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Typed OM Level 1（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>
.js, .js-value, .js-slot {
	color: #006633;
}
.js-value {
	font-family: sans-serif0, sans-serif;
}

/* アルゴリズム */

*.algorithm {
	padding: .5em;
	border: thin solid #ddd;
	border-radius: .5em;
	margin: .5em 0;
}

#_x_sum_values > tr > td:first-child {
	white-space: nowrap;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	var source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 180208 spec

}

function expand(){

	var class_map = {
		p: 'property',
		v: 'value',
		u: 'unit',
		f: 'func',
		t: 'type',
		at: 'at-rule',
		css: 'css',
		e: 'element',
		a: 'attr',
		at: 'at-rule',
		E: 'error',
		sl: 'js-slot',
		U: 'code-point',
	};

	var tag_map = {
		p: 'code',
		f: 'code',
		u: 'code',
		v: 'code',
		t: 'var',
		at: 'code',
		I: 'code',
		I0: 'code',
		mC: 'code',
		C: 'code',
		m: 'code',
		m0: 'code',
		m1: 'code',
		E: 'code',
		a: 'code',
		css: 'code',
		c: 'code',
		sl: 'span',
		U: 'span',
		i: 'i',
	};

	var link_map = this.link_map;
	var ctx_ifc = '';
	var ctx_ifc1 = ''; // local

	return this.html.replace(
		/%[~\w\-\/一-鿆あ-ん]+|`(.+?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	return '<var>' + match.slice(1).replace(/\/(.+)/, '<sub>$1</sub>') + '</var>';
}

var text = key;
var href = '';
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'I': // set context & local context
	ctx_ifc1 = key.toLowerCase();
	if( indicator === '@'){
		ctx_ifc = ctx_ifc1;
	}
//	href = '#' + ctx_ifc1;
	break;
case 'II': // only set local context
	ctx_ifc1 = key.toLowerCase();
	return '';
case 'I0': // set context
	ctx_ifc = key.toLowerCase();
	klass = 'I';
	break;
case 'C':
	href = '#dom-' + key.toLowerCase() + '-' + key.toLowerCase();
	text = 'Constructor';
	break;
case 'm': // IDL member
case 'm1':
case 'mC':
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	switch(klass){
	case 'm':
		href = '#dom-' + ctx_ifc + '-' + key.toLowerCase();
		break;
	case 'm1':
		href = '#dom-' + ctx_ifc1 + '-' + key.toLowerCase();
		break;
	case 'mC':
		href = '#dom-' + key.toLowerCase() + '-' + key.toLowerCase();
		break;
	}
//	klass = 'm';
	break;
case 't': // type
	text = '&lt;' + key + '&gt;';
	break;
case 'f': // 
	text = key + '()';
	break;
case 'U': // code point
	text = 'U+' + key;
	break;
case 'at': // at-rule
	text = '@' + key;
	break;
case 'E': // error
	href = '~WEBIDL#' + key.toLowerCase();
	break;
case 'l': // literal
	return '"<code class="literal">' + text + '</code>"'
case 'sl': // internal slot
	text = '[[' + text + ']]';
	break;
case 'en': // english words
	return '<span lang="en-x-a0">' + key + '</span>'
	break;
case 'issue':
	return(
'<a href="https://github.com/w3c/css-houdini-drafts/issues/' + key + '">issue#' + key + '</a>'
	);
}

var classname = class_map[klass];

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}
return text;

	}
}
</script>


<script type="text/plain" id="_source_data">

●●options

spec_date:2018-02-08
trans_update:2018-02-12
	page_state_key:CSS
original_url:https://drafts.css-houdini.org/css-typed-om-1/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:paint,css
conformance:css
copyright:2018,use
trans_1st_pub:2018-02-12


●●original_id_map
dom-cssstylevalue-stringifier:CSSStyleValue-stringification-behavior
dom-cssunparsedvalue-getter:cssunparsedvalue-indexed-getter
dom-cssnumericarray-getter:cssnumericarray-indexed-getter
dom-csstransformvalue-getter:csstransformvalue-indexed-getter
dom-stylepropertymapreadonly-stringifier:StylePropertyMapReadOnly-stringification-behavior
dom-csstransformcomponent-stringifier:CSSTransformComponent-stringification-behavior


●●link_map

	●IDL
Exposed:~WEBIDL#Exposed
SameObject:~WEBIDL#SameObject

E.SyntaxError:~WEBIDL#syntaxerror
E.TypeError:~WEBIDL#exceptiondef-typeerror
E.RangeError:~WEBIDL#exceptiondef-rangeerror

I.DOMMatrix:~GEOMETRY1#dommatrix
I.DOMMatrixReadOnly:~GEOMETRY1#dommatrixreadonly
I.Element:~DOM4#element
I.StylePropertyMap:#stylepropertymap
I.StylePropertyMapReadOnly:#stylepropertymapreadonly
I.USVString:~WEBIDL#idl-USVString
I.UpdateFunction:#callbackdef-updatefunction

I.CSSImageValue:#cssimagevalue
I.CSSKeywordValue:#csskeywordvalue
I.CSSMathInvert:#cssmathinvert
I.CSSMathMax:#cssmathmax
I.CSSMathMin:#cssmathmin
I.CSSMathNegate:#cssmathnegate
I.CSSMathOperator:#enumdef-cssmathoperator
I.CSSMathProduct:#cssmathproduct
I.CSSMathSum:#cssmathsum
I.CSSMathValue:#cssmathvalue
I.CSSMatrixComponent:#cssmatrixcomponent
I.CSSMatrixComponentOptions:#dictdef-cssmatrixcomponentoptions
I.CSSNumberish:#typedefdef-cssnumberish
I.CSSNumericBaseType:#enumdef-cssnumericbasetype
I.CSSNumericType:#dictdef-cssnumerictype
I.CSSNumericArray:#cssnumericarray
I.CSSNumericValue:#cssnumericvalue
I.CSSPerspective:#cssperspective
I.CSSPositionValue:#csspositionvalue
I.CSSResourceState:#enumdef-cssresourcestate
I.CSSResourceValue:#cssresourcevalue
I.CSSRotate:#cssrotate
I.CSSScale:#cssscale
I.CSSSkew:#cssskew
I.CSSSkewX:#cssskewx
I.CSSSkewY:#cssskewy
I.CSSStyleRule:~CSSOM1#cssstylerule
I.CSSStyleValue:#cssstylevalue
I.CSSTransformComponent:#csstransformcomponent
I.CSSTransformValue:#csstransformvalue
I.CSSTranslate:#csstranslate
I.CSSURLImageValue:#cssurlimagevalue
I.CSSUnitValue:#cssunitvalue
I.CSSUnparsedValue:#cssunparsedvalue
I.CSSVariableReferenceValue:#cssvariablereferencevalue
I.CSSUnparsedSegment:#typedefdef-cssunparsedsegment

I.CSSKeywordish:#typedefdef-csskeywordish
I.ElementCSSInlineStyle:~CSSOM1#elementcssinlinestyle


	DOMString:~WEBIDL#idl-DOMString
	boolean:~WEBIDL#idl-boolean
	double:~WEBIDL#idl-double
	unsigned long:~WEBIDL#idl-unsigned-long

sl.tokens:#dom-cssunparsedvalue-tokens-slot


	Constructor:#dom-csskeywordvalue-csskeywordvalue
	Constructor:#dom-cssmathinvert-cssmathinvert
	Constructor:#dom-cssmathmax-cssmathmax
	Constructor:#dom-cssmathmin-cssmathmin
	Constructor:#dom-cssmathnegate-cssmathnegate
	Constructor:#dom-cssmathproduct-cssmathproduct
	Constructor:#dom-cssmathsum-cssmathsum
	Constructor:#dom-cssmatrixcomponent-cssmatrixcomponent
	Constructor:#dom-cssperspective-cssperspective
	Constructor:#dom-csspositionvalue-csspositionvalue
	Constructor:#dom-cssrotate-cssrotate
	:#dom-cssrotate-cssrotate-x-y-z-angle
	Constructor:#dom-cssscale-cssscale
	Constructor:#dom-cssskew-cssskew
	Constructor:#dom-csstransformvalue-csstransformvalue
	Constructor:#dom-csstranslate-csstranslate
	Constructor:#dom-cssunitvalue-cssunitvalue
	Constructor:#dom-cssurlimagevalue-cssurlimagevalue
	Constructor:#dom-cssvariablereferencevalue-cssvariablereferencevalue

m.~TCis2D:#dom-csstransformcomponent-is2d
m.getComputedStyle:~CSSOM1#dom-window-getcomputedstyle

	m.add:#dom-cssnumericvalue-add
	m.div:#dom-cssnumericvalue-div
	m.equals:#dom-cssnumericvalue-equals
	m.max:#dom-cssnumericvalue-max
	m.min:#dom-cssnumericvalue-min
	m.mul:#dom-cssnumericvalue-mul
	m.parse:#dom-cssnumericvalue-parse
	m.sub:#dom-cssnumericvalue-sub
	m.to:#dom-cssnumericvalue-to
	m.toSum:#dom-cssnumericvalue-tosum


	m.styleMap:#dom-cssstylerule-attributestylemap
	m.attributeStyleMap:#dom-element-attributestylemap
	m.computedStyleMap:#dom-element-computedstylemap

	m.ax:#dom-cssskew-ax
	m.ay:#dom-cssskew-ay

	m.CSSVariableReferenceValue:#dom-cssvariablereferencevalue-cssvariablereferencevalue
	m.fallback:#dom-cssvariablereferencevalue-fallback
	m.variable:#dom-cssvariablereferencevalue-variable

	m.get:#dom-stylepropertymapreadonly-get
	m.getAll:#dom-stylepropertymapreadonly-getall

	m.intrinsicHeight:#dom-cssimagevalue-intrinsicheight
	m.intrinsicRatio:#dom-cssimagevalue-intrinsicratio
	m.intrinsicWidth:#dom-cssimagevalue-intrinsicwidth

	m.is2D:#dom-csstransformvalue-is2d
	m.toMatrix:#dom-csstransformvalue-tomatrix

	m.length:#dom-cssperspective-length
	m.length:#dom-cssunparsedvalue-length
	m.length:#dom-cssnumericarray-length
	m.length:#dom-csstransformvalue-length

	m.matrix:#dom-cssmatrixcomponent-matrix


	m.operator:#dom-cssmathvalue-operator
	
	m.parse:#dom-cssstylevalue-parse

	m.parseAll:#dom-cssstylevalue-parseall
	m.set:#dom-stylepropertymap-set
	m.state:#dom-cssresourcevalue-state

	m.unit:#dom-cssunitvalue-unit
	m.update:#dom-stylepropertymap-update
	#dom-stylepropertymap-update-property-updatefn

	m.url:#dom-cssurlimagevalue-url

	m.value:#dom-csskeywordvalue-value
	m.value:#dom-cssmathinvert-value
	m.value:#dom-cssmathnegate-value
	m.value:#dom-cssunitvalue-value

	m.values:#dom-cssmathmax-values
	m.values:#dom-cssmathmin-values
	m.values:#dom-cssmathproduct-values
	m.values:#dom-cssmathsum-values


	m.x:#dom-csspositionvalue-x
	m.angle:#dom-cssrotate-angle
	m.x:#dom-cssrotate-x
	m.x:#dom-cssscale-x
	m.x:#dom-csstranslate-x
	m.y:#dom-csspositionvalue-y
	m.y:#dom-cssrotate-y
	m.y:#dom-cssscale-y
	m.y:#dom-csstranslate-y
	m.z:#dom-cssrotate-z
	m.z:#dom-cssscale-z
	m.z:#dom-csstranslate-z


	●CSS
f.translate:~TRANSFORM#funcdef-transform-translate
f.calc:~CSSVAL#funcdef-calc
f.matrix:~TRANSFORM#funcdef-transform-matrix
f.matrix3d:~TRANSFORM2#funcdef-matrix3d
f.max:~CSSVAL#funcdef-max
f.min:~CSSVAL#funcdef-min
f.perspective:~TRANSFORM2#funcdef-perspective
f.rotate:~TRANSFORM#funcdef-transform-rotate
f.rotate3d:~TRANSFORM2#funcdef-rotate3d
f.rotateX:~TRANSFORM2#funcdef-rotatex
f.rotateY:~TRANSFORM2#funcdef-rotatey
f.rotateZ:~TRANSFORM2#funcdef-rotatez
f.scale:~TRANSFORM#funcdef-transform-scale
f.scale3d:~TRANSFORM2#funcdef-scale3d
f.scaleX:~TRANSFORM#funcdef-transform-scalex
f.scaleY:~TRANSFORM#funcdef-transform-scaley
f.scaleZ:~TRANSFORM2#funcdef-scalez
f.skew:~TRANSFORM#funcdef-transform-skew
f.skewX:~TRANSFORM#funcdef-transform-skewx
f.skewY:~TRANSFORM#funcdef-transform-skewy
f.translate3d:~TRANSFORM2#funcdef-translate3d
f.translateX:~TRANSFORM#funcdef-transform-translatex
f.translateY:~TRANSFORM#funcdef-transform-translatey
f.translateZ:~TRANSFORM2#funcdef-translatez
f.var:~CSSVAR#funcdef-var

f.linear-gradient:~CSSIMAGE#funcdef-linear-gradient
f.radial-gradient:~CSSIMAGE#funcdef-radial-gradient




p.animation:~CSSANIM#propdef-animation
p.background-color:~CSSBG#propdef-background-color
p.background-image:~CSSBG#propdef-background-image
p.background-position:~CSSBG#propdef-background-position
p.background-repeat:~CSSBG#propdef-background-repeat
p.background-size:~CSSBG#propdef-background-size
p.border-bottom-left-radius:~CSSBG#propdef-border-bottom-left-radius
p.border-bottom-right-radius:~CSSBG#propdef-border-bottom-right-radius
p.border-bottom-width:~CSSBG#propdef-border-bottom-width
p.border-color:~CSSBG#propdef-border-color
p.border-image-outset:~CSSBG#propdef-border-image-outset
p.border-image-repeat:~CSSBG#propdef-border-image-repeat
p.border-image-slice:~CSSBG#propdef-border-image-slice
p.border-image-source:~CSSBG#propdef-border-image-source
p.border-image-width:~CSSBG#propdef-border-image-width
p.border-image:~CSSBG#propdef-border-image
p.border-left-width:~CSSBG#propdef-border-left-width
p.border-right-width:~CSSBG#propdef-border-right-width
p.border-style:~CSSBG#propdef-border-style
p.border-top-left-radius:~CSSBG#propdef-border-top-left-radius
p.border-top-right-radius:~CSSBG#propdef-border-top-right-radius
p.border-top-width:~CSSBG#propdef-border-top-width
p.box-sizing:~SIZING#propdef-box-sizing
p.clear:~CSS2VISUREN#propdef-clear
p.color:~CSSCOLOR#propdef-color
	p.color:~CSSWG/css-color-3/#color0
p.content:~CSSCONTENT#propdef-content
p.counter-reset:~CSSWG/css-lists-3/#propdef-counter-reset
p.cursor:~CSSUI#propdef-cursor
p.display:~CSSDISP#propdef-display
p.float:~CSS2VISUREN#propdef-float
p.font-size:~CSSFONT#propdef-font-size
p.font-style:~CSSFONT#propdef-font-style
p.font-weight:~CSSFONT#propdef-font-weight
p.height:~CSS2VISUDET#propdef-height
p.line-height:~CSS2VISUDET#propdef-line-height
p.list-style-image:~CSSWG/css-lists-3/#propdef-list-style-image
p.list-style-position:~CSSWG/css-lists-3/#propdef-list-style-position
p.list-style-type:~CSSWG/css-lists-3/#propdef-list-style-type
p.margin-bottom:~CSS2BOX#propdef-margin-bottom
p.margin-left:~CSS2BOX#propdef-margin-left
p.margin-right:~CSS2BOX#propdef-margin-right
p.margin-top:~CSS2BOX#propdef-margin-top
p.max-height:~CSS2VISUDET#propdef-max-height
p.max-width:~CSS2VISUDET#propdef-max-width
p.min-height:~CSS2VISUDET#propdef-min-height
p.min-width:~CSS2VISUDET#propdef-min-width
p.object-position:~CSSIMAGE#propdef-object-position
p.opacity:~CSSCOLOR#propdef-opacity
p.outline-color:~CSSUI#propdef-outline-color
p.outline-style:~CSSUI#propdef-outline-style
p.outline-width:~CSSUI#propdef-outline-width
p.overflow-x:~CSSOVERFLOW3#propdef-overflow-x
p.overflow-y:~CSSOVERFLOW3#propdef-overflow-y
p.padding-bottom:~CSS2BOX#propdef-padding-bottom
p.padding-left:~CSS2BOX#propdef-padding-left
p.padding-right:~CSS2BOX#propdef-padding-right
p.padding-top:~CSS2BOX#propdef-padding-top
p.text-align:~CSSTEXT#propdef-text-align
p.text-decoration-color:~CSSTEXTDECOR#propdef-text-decoration-color
p.text-decoration-line:~CSSTEXTDECOR#propdef-text-decoration-line
p.text-decoration-style:~CSSTEXTDECOR#propdef-text-decoration-style
p.text-overflow:~CSSUI#propdef-text-overflow
p.text-transform:~CSSTEXT#propdef-text-transform
p.transform:~TRANSFORM#propdef-transform
p.transition-delay:~TRANSITION#propdef-transition-delay
p.transition-duration:~TRANSITION#propdef-transition-duration
p.vertical-align:~CSSINLINE#propdef-vertical-align
p.visibility:~CSS2VISUFX#propdef-visibility
p.white-space:~CSSTEXT#propdef-white-space
p.width:~CSS2VISUDET#propdef-width

p.position:~CSS2VISUREN#propdef-position
	p.position:~CSSPOS#propdef-position
p.top:~CSS2VISUREN#propdef-top
	p.top:~CSSPOS#propdef-top
p.right:~CSS2VISUREN#propdef-right
	p.right:~CSSPOS#propdef-right
p.bottom:~CSS2VISUREN#propdef-bottom
	p.bottom:~CSSPOS#propdef-bottom
p.left:~CSS2VISUREN#propdef-left
	p.left:~CSSPOS#propdef-left
p.z-index:~CSS2VISUREN#propdef-z-index
	p.z-index:~CSSPOS#propdef-z-index



t.angle-percentage:~CSSVAL#typedef-angle-percentage
t.angle:~CSSVAL#angle-value
	t.calc():~CSSVAL#funcdef-calc
t.color:~CSSCOLOR#typedef-color
	t.color:~CSSWG/css-color-3/#valuea-def-color
t.custom-ident:~CSSVAL#identifier-value
t.custom-property-name:~CSSVAR#typedef-custom-property-name
t.dimension-token:~CSSSYN#typedef-dimension-token
t.dimension:~CSSVAL#typedef-dimension
t.flex:~CSSGRID#typedef-flex
t.frequency:~CSSVAL#frequency-value
t.image:~CSSIMAGE#typedef-image
t.ident:~CSSVAL#typedef-ident
t.length-percentage:~CSSVAL#typedef-length-percentage
t.length:~CSSVAL#length-value
t.number-percentage:~CSSVAL#typedef-number-percentage
t.number-token:~CSSSYN#typedef-number-token
t.number:~CSSVAL#number-value
t.percentage-token:~CSSSYN#typedef-percentage-token
t.percentage:~CSSVAL#percentage-value
t.position:~CSSVAL#typedef-position
t.resolution:~CSSVAL#resolution-value
t.time-percentage:~CSSVAL#typedef-time-percentage
t.time:~CSSVAL#time-value
t.transform-function:~TRANSFORM#typedef-transform-function
t.transform-list:~TRANSFORM#typedef-transform-list
t.url:~CSSVAL#url-value

v.auto:~CSSPOS#valdef-top-auto
v.currentcolor:~CSSCOLOR#valdef-color-currentcolor
v.red:~CSSCOLOR#valdef-color-red
v.stretch:~CSSBG#valdef-border-image-repeat-stretch
v.fill:~CSSBG#border-image-slice-fill

u.em:~CSSVAL#em
u.in:~CSSVAL#in
u.px:~CSSVAL#px


演算で写像する:#_map-items

~list値をとる:#list-valued-properties
単独の値をとる:#single-valued-properties
妥当な~CSS~prop名:#valid-css-property
~prop名を検査して正規化する:#_check-and-normalize-a-property

~map~entryたち:#stylepropertymapreadonly-map-entries
単位~mapの積をとる:#product-of-two-unit-maps

算出d~StylePropertyMap:#computed-stylepropertymap
宣言d~StylePropertyMap:#declared-stylepropertymap

~CSS値を反復成分に細分化する:#subdivide-into-iterations
~CSS値を正規化する:#normalize-a-css-value
~style値を正規化する:#normalize-a-style-value
変形~関数を正規化する:#normalize-a-transform-function
数量~値を正規化する:#normalize-a-numeric-value
var() 参照を正規化する:#normalize-a-var-reference
識別子を正規化する:#normalize-an-identifier
変形~listを正規化する:#normalize-a-transform-list
~fallbackの成分~値を正規化する:#normalize-a-list-of-component-values
数式を正規化する:#cssmath-normalize-a-math-expression

単独の値から x/y を決定する:#from-single-keyword
~keyword, 長さから x/y を決定する:#from-keyword-and-length

反復する値たち:#_values-to-iterate-over
変形~成分~list:#_transform-components
~custom~prop名~文字列:#custom-property-name-string


~keywordに類する値を規格化する:#rectify-a-keywordish-value
実数に類する値を規格化する:#rectify-a-numberish-value

反数にする:#cssmath-negate
純~単位:#_zero-or-one-unit
百分率hint:#cssnumericvalue-percent-hint
百分率hintを適用する:#apply-the-percent-hint
総和~値:#sum-value
sum.値:#sum-value-value
総和~値を作成する:#create-a-sum-value
型を乗算する:#cssnumericvalue-multiply-two-types
型:#cssnumericvalue-type
基底~型:#cssnumericvalue-base-type
型を作成する:#create-a-type
型を加算する:#add-two-types
単位~map:#sum-value-unit-map
単位~mapから型を作成する:#create-a-type-from-a-unit-map
逆数にする:#cssmath-invert
単位~値を変換する:#convert-a-cssunitvalue
~CSSStyleValueを構文解析する:#parse-a-cssstylevalue
総和~値~itemから単位~値を作成する:#create-a-cssunitvalue-from-a-sum-value-item
~CSSUnitValueを作成する:#create-a-cssunitvalue-from-a-pair

新たな単位~値を作成する:#create-a-cssunitvalue-from-a-pair

合致-:#cssnumericvalue-match
~CSS生成規則に合致する:#match-a-css-production
等しい数量~値:#equal-numeric-value



互換~単位:~CSSVAL#compatible-units
正準的~単位:~CSSVAL#canonical-unit
~math関数:~CSSVAL#math-function
相対~長さ:~CSSVAL#relative-length

~custom~prop:~CSSVAR#custom-property
代用され:~CSSVAR#substitute-a-var
~is2D:~GEOMETRY1#matrix-is-2d
	m.is2D:~GEOMETRY1#dom-dommatrixreadonly-is2d
~3D変形~関数:~TRANSFORM2#3d-transform-functions
~2D変形~関数:~TRANSFORM#two-d-transform-functions

生成元clean~flag:~CSSOM1#concept-css-style-sheet-origin-clean-flag
解決値:~CSSOM1#resolved-value

	●INFRA
符号位置:~INFRA#code-point
文字列:~INFRA#string
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
区切って連結-:~INFRA#string-concatenate

~list:~INFRA#list
~item:~INFRA#list-item
~key:~INFRA#map-key
~size:~INFRA#list-size
空:~INFRA#list-is-empty
前付加する:~INFRA#list-prepend
除去する:~INFRA#list-remove
付加する:~INFRA#list-append
空にする:~INFRA#list-empty
	~EACH:~INFRA#list-iterate
	＊包含する:~FETCH#header-list-contains

有順序~map:~INFRA#ordered-map
~map:~INFRA#ordered-map
map.値:~INFRA#map-value
map.~key:~INFRA#map-key
~entry:~INFRA#map-entry
	~map:~INFRA#ordered-map
map.除去する:~INFRA#map-remove
map.設定する:~INFRA#map-set
	存在する:~INFRA#map-exists
	~EACH0:~INFRA#map-iterate

~tuple:~INFRA#tuple
~supportされる~CSS~prop:~CSSOM1#supported-css-property


	~THROW:~WEBIDL#dfn-throw
呼出す:~WEBIDL#invoke-a-callback-function
文字列化の挙動:~WEBIDL#dfn-stringification-behavior
被support~prop~index:~WEBIDL#dfn-supported-property-indices
有index取得子:~WEBIDL#dfn-indexed-property-getter
有index設定子:~WEBIDL#dfn-indexed-property-setter
値~反復子:~WEBIDL#dfn-value-iterator

識別子:~CSSSYN#identifier
文法に則って構文解析する:~CSSSYN#css-parse-something-according-to-a-css-grammar
成分~値:~CSSSYN#component-value
成分~値を構文解析する:~CSSSYN#parse-a-component-value


略式~prop:~CASCADE#shorthand-property
算出d値:~CASCADE#computed-value


	●他
	…/issues/148
	…/issues/186
	…/issues/268
	…/issues/276
	…//issues/350#issuecomment-294690156

	~TRANSFORM#mathematical-description
	~TRANSFORM2#mathematical-description

	§:#declared-stylepropertymap-objects
	:#type-of-a-cssmathvalue
	:#type-of-a-cssunitvalue
	§:#computed-stylepropertymapreadonly-objects
	§:#cssom-serialization
	§:#stylevalue-normalization

	~CSSOM1#serializing-css-values

	:#serialize-a-cssunparsedvalue
	:#serialize-a-cssvariablereferencevalue
	:#serialize-a-csskeywordvalue
	:#serialize-a-cssunitvalue
	:#serialize-a-csstransformvalue
	:#serialize-a-csstranslate
	:#serialize-a-cssrotate
	:#serialize-a-cssscale
	:#serialize-a-cssskew
	:#serialize-a-cssskewx
	:#serialize-a-cssskewy
	:#serialize-a-cssperspective
	:#serialize-a-cssmatrixcomponent


●●words_table1
	TC39:https://tc39.github.io/ecma262/
	DOM4:https://dom.spec.whatwg.org/
	WEBIDL:https://heycam.github.io/webidl/
	INFRA:https://infra.spec.whatwg.org/
	CSSOM1:https://drafts.csswg.org/cssom-1/
GEOMETRY1:geometry-ja.html
	https://drafts.fxtf.org/geometry-1/
	CSSSYN:https://drafts.csswg.org/css-syntax-3/
	CSSVAL:https://drafts.csswg.org/css-values-3/
	CSSVAL:https://drafts.csswg.org/css-values-4/
	TRANSFORM:https://drafts.csswg.org/css-transforms-1/
	TRANSFORM2:https://drafts.csswg.org/css-transforms-2/
	CSSBG:https://drafts.csswg.org/css-backgrounds-3/

TCis2D:is2D
is2DM:is2D
●●words_table


	●Typed OM／演算
CSSStyleValue:
StylePropertyMap:
CSSUnitValue:
TypedOM:Typed OM
is2D:is 2D

hint::::ヒント
vector::::ベクトル
math:
2D:
3D:
	4×4:4x4

行列:matrix::~
単位行列:identity matrix::~
	単位行列:identity
回転:rotation::~
回転角:angle::~
拡縮:scale::~
並進:translation::~
座標:coordinate::~

整数:integer::~
数量:numeric::~
実数:number::数
	~keywordに類する:keywordish
	実数に類する:numberish:
百分率hint:percent hint:百分率 hint::百分率ヒント

式:expression::~
数式:math expression::~
軸:axis:~
単位:unit::~
	単位なしの:unitless
変数:variable:~
単位元:identity::~
累乗数:power::~
	半群:semi-group
	関数:func
演算-:operate:~
演算:operation:~
加算-:add::~
加算:addition::~
減算-:subtract::~
減算:subtraction::~
除算:division::~
乗算-:multiply::~
乗算:multiplication::~
反数-:negate::~
反数に:negate::~
反数:negation::~
	加法逆元
逆数:inverse::~
逆数-:invert::~
逆数に:invert::~
	乗法逆元:reciprocal
乗法的:multiplicative::~
総和:sum::~
最大:maximum::~
積:product::~
算術:arithmetic::~
可換:commutative::~
結合的:associative::~
	結合律を満たす:N-ary
	monoid
	semi-group
簡約-:reduce:~
換算率:conversion ratio:~
規格化-:rectify:~

正規化-:normalize::~
正規化:normalization::~
	正規化し直され:renormalized

丸めら:round さ:~
切詰めら:clamp さ:切り詰めら
変換-:convert:~
変換:conversion:~
	conversation
	距離:distance:~

	●IDL ／データ型／primitives
typedef:
IDL:
JS:JavaScript
call:
	result of calling:~callした結果
callback:
class::::クラス
上位class:superclass::上位 class:上位クラス
下位class:subclass::下位 class:下位クラス
entry::::エントリ
error::::エラー
live:
field::::フィールド
flag::::フラグ
index::::
有index:indexed::有 index
tuple::::タプル
item::::アイテム
key::::
list::::リスト
	~list値をとる:list-valued
	単独の値をとる:single-valued
	〜のみからなる:single-valued
map::::マップ
member::::メンバ
method::::メソッド
node::::ノード
obj:object:::オブジェクト
pair::::ペア
size::::サイズ
slot::::スロット
instance::::インスタンス
interface::::インタフェース

空:empty:~
辞書:dictionary::~::ディクショナリ
構築子:constructor::~::コンストラクタ
構築-:construct::~
反復子:iterator::~
設定-:set::~
設定子:setter::~
投出-:throw::~
取得子:getter::~
被support:supported::被 support:被サポート
引数:argument:~
型:type::~
有型:typed::~
	型~付け:typing
有順序:ordered::~
順序:order::~
	順序:ordering

真偽値:boolean::~
値:value:~
	下位-値:subvalue／sub-value
属性:attribute:~
例外:exception:~
連列:sequence::~

呼出され:invoke され:呼び出され
呼出す:invoke する:呼び出す
被呼出時:被 invoke 時:~
	被呼出時:called on
変異可能:mutable:~
継承-:inherit:~


	●構文／直列化
ASCII:
comma::::カンマ
space:
text::::テキスト
token::::トークン
top-level::::トップレベル

構文:syntax:~
構文解析-:parse:~
構文解析器:parser:~
合致-:match:~
照合:matching:~
	区切られ:separated::~
	区切りの:-separated::~
生成規則:production:~
	接頭辞:prefix
文字列:string:~
文字列化-:stringify:~
文字列化:stringification:~
連結-:concatenate:~
分割-:split:~
識別子:identifier:~
小文字:lowercase:~
成分:component:~
符号位置:code point:~
	符号位置の昇順:increasing code point order
文法:grammar:~

細分化-:subdivide:~
細分-:divide:~
直列化-:serialize:~
直列化:serialization:~

	`-^l:dashes HYPHEN-MINUS

	●CSS
CSS:
CSSOM:
calc:
url:
keyword::::キーワード
layout::::レイアウト
style::::スタイル
stylesheet::::スタイルシート
	`px^css 単位の:pixel
prop:property:::プロパティ
custom::::カスタム
offset::::オフセット
正準的:canonical::~
互換:compatible::~
百分率:percentage::~
略式:shorthand::~
	略式でない:longhand:~
画像:image::~
層:layer::~
変形-:transform::~
変形:transform::~

	`linear-gradient$f:linear gradient
	`radial-gradient$f:radial gradient
横幅:width::~
縦幅:height::~
横:horizontal::~
縦:vertical::~
縦横比:aspect ratio::~
角度:angle::~
関数:function::~
規則:rule:~
疑似:pseudo::~
視覚的:visual:~
次元:dimension::~
色:color::~
長さ:length::~
内在的:intrinsic::~
辺:edge:~

木:tree::~::ツリー
要素:element:~
疑似要素:pseudo-element:~
容器:container:::コンテナ

	＊
算出d:computed::算出
	算出d値:computed value
算出-:compute::~
算出:computation::~

宣言d:declared::宣言
宣言-:declare::~
宣言:declaration::~

解決-:resolve::~
解決値:resolved value::~

	●仕様
API:
model::::モデル
factory::::ファクトリ
fallback::::フォールバック
snapshot::::スナップショット
privacy::::プライバシー
security::::セキュリティ
	略せる:shortcut
UA:user agent:UA
overhead::::オーバーヘッド
algo:algorithm:::アルゴリズム
support::::サポート
version::::バージョン
approach::::アプローチ
暗黙的:implicit:~
一貫性:consistency:~
一義的:unambiguous:~
	可能:possible:~
可用:available:~
課題:issue:~
概念:concept:~
関連する:relevant な:~
規定-:dictate:~
記述-:describe:~
記述:description:~
却下-:reject:~
旧来の:legacy:~
共通の:common な:~
共通する:common な:~
作者:author:~
仕方:way:~
仕様:spec:~
	仕様~化:spec up
事例:case:~
実際:actual:~
実際の:actual な:~
手順:procedure:~
手続き:steps:~
純粋:pure:~
将来:future:~
状況下:circumstances:~
人間工学:ergonomics:~
正しく:correct に:~
直に:direct に:~
直接的:direct:~
通常の:normal:~
適切:appropriate:~
特色機能:feature:~
	特に:some particular
特別:special:~
	特異な:special singular
必要:need:~
標準の:standard な:~
複雑な:complicated:~
明示的:explicit:~
目的:purpose:~
有意:significant:~
理由:reason:~
略記:shorthand:~
容易:ease:~
段:step:~
抽象:abstract:~
抽象的:abstract:~
注釈文:prose:~
精確:precise:~
一般:general:~
付録:appendix:~
方式:manner:~
不用意:accidental:~
資質:nature:~
厳格:rigorous:~
共通する:common な:~
手作業:hand-wavey:~
純粋:pure:~
不変則:invariant:~

	注記:note
	例:example
	ずっと簡潔に:much less verbosely
	現時点:at the moment
	おそらく:probably
	わかるよね:you know what we mean
	上述の:The above talk about
	:per
	-:we

	●仕様（動詞
依拠-:rely:~
依存-:depend:~
影響-:affect:~
壊す:break する:~
挙動:behavior:ふるまい
決定-:determine:~
結付けら:associate さ:~
効果:effect:~
考慮-:consider:~
考慮点:considerations:~
高性能:performant:~
最適化:optimization:~
実装-:implement:~
指示-:indicate:~
指定-:specify:~
指定d:specified:指定
	-:attempt
受容-:accept:~
処理能:performance:~
序論:introduction:~
詳細な:detailed:~
情報:information:~
遂行-:perform:~
制約-:restrict:~
制約:restriction:~
設計-:design:~
設計:design:~
組織化-:organize:~
単純化-:simplify:~
定義-:define:~
定義:definition:~
未定義:undefined:~
供-:provide:~
組入れる:incorporate する:組み入れる
導入-:introduce:~
被る:incur する:~
避ける:avoid する:~
防ぐ:prevent する:~
明確化:clarification:~
要求-:require:~
孕む:involve する:~
関係-:relate:~
確保-:ensure:~
解釈-:interpret:~
許容-:allow:~
	-可能に:allow
認識-:recognize:~
適用-:apply:~
利用者:user:~
削除-:delete:~
意味-:mean:~
有意義:meaningful:~
意図的:intentional:~
意図-:intend:~
見なさ:consider:~
手助け:facilitate:~
観測-:observe:~
	観測-可能:observable
拘束:constraint:~
期待-:expect:~
	面した:face した
	利用-可能:usable
	書かれ:written
	気を配る:care
	壊れ:break
	知る:know
	選ばれ:chose
	渡され:ask for
	~~留意-:recall

	●未分類（動詞
host::::ホスト
cast:
下層の:underlying:~
開始-:start:~
関与-:participate:~
具現化:rendering:~
形成-:form:~
継続-:continue:~
検査-:check:~
検索取得-:retrieve:~
見出す:find する:~
見出され:find され:~
現れる:appear する:~
公開-:expose:~
更新-:update:~
作成-:create:~
作動化-:activate:~
作動中の:active:~
参照:reference:~
失敗-:fail:~
失敗:failure:~
成功:success:~
実行:execution:~
取得-:get:~
処理-:process:~
処理待ち:pending:~
	下位-処理-:sub-process
初期:initial:~
	初期~時には:initially
初期化-:initialize:~
除去-:remove:~
省略-:omit:~
生産-:produce:~
生成-:generate:~
格納-:store:~
置換-:replace:~
代用され:substitute され:置き換えられ
	代用されない:un-substituted

抽出-:extract:~

入子の:nested:入れ子の
入子あり:nested:入れ子

	前付加-:prepend
組合せれ:combine でき:組み合せれ
組合わせ:combination:組み合せ
操作:manipulation:~
相違-:differ:~
相互作用-:interact:~
調整:adjustment:~

追加-:add:~
追加:addition:~
追跡-:track:~
添付-attach::~
	転換:turn into:~
塗り:paint:~

読込まれ:load::読み込まれ::ロードされ
入力:input:~
反映-:reflect:~
反復-:iterate:~
反復:iteration:~
反復成分:iterations:~

表現-:represent:~
表現:representation:~
評価-:evaluate:~
	評価し直され:reevaluate
付加-:append:~

変化-:change:~
変更-:change:~
包含-:contain:~
	-:containing
包装-:wrap:~
埋込まれ:embed され:埋め込まれ
利用-:use:~

相互作用-:interact:やりとり
遷移:transition:~
改変-:modify:~
走らす:run する:~
走らせ:run し:~
	返す:return
	になる:becoming
	切り替え:flip
	-:switch
	元へ戻す:back
	別々に分ける／別々に:separate
	~~出力:print out
	置かれ:put
	列挙:enum:~
	-:putting

	●未分類
URL:
access::::アクセス
	access可能:accessible
code::::コード
data::::データ
fetch::::
inline::::インライン
loop::::ループ
network::::ネットワーク
option::::オプション
sort::::ソート
status::::ステータス
	表:table

生成元clean:origin-clean::生成元 clean
相対:relative:~
静的:static:~
基底:base:~
構造:structure:~
再帰的:recursive:~
資源:resource::~:リソース
準備済み:ready::~

状態:state:~
相対的:relative:~
即時:immediate:~
存在-:exist:~
妥当:valid:~
	妥当でない:invalid:~
片:fragment:~
等価:equivalent:~
内部:internal:~
	内部~algo:using the original value of ／internal algorithm
内側:inside:~
内容:content:~
範囲:range:~
	範囲が制約された:range-restricted
非同期的な:asynchronous:~
部位:portion:~
複合的:complex:~
複製:copy:~
文書:document:~
文脈:context:~
頁:page:::ページ
登録-:register:~
名:name:~
名前:name:~
裸の:naked::~
和集合:union:~
並列的:parallel:~
数学的:mathematical:~
	生の:raw
	~~成分:entry
	等し:equal
	複数片からなる連続的な:multiple	successive
	PEMDAS precedence
	項:term
	-:categories
	分類:-
	一度に 2 個ずつ:manually add them pair-wise
	変形~成分~list:<a>values to iterate over</a>


	●指示語
新たな:new:~
全部的:full:~
単独の:single:~
旧-:old:~
新-:new:~
下位-:sub-:~
既存の:existing:~
既知の:known:~
左端:left:~
上端:top:~
	末尾:end
	-:maximal
	〜に基づく:based
	〜の代わりに:instead
	~~要約:abstract
	いくつかの:several
	いくつでも:any number of
	ここ:here
	この:this
	これらの:these
	しかしながら，:however
	したがって:thus
	すなわち、:meaning
	すべての:all
	その:that
	そのような:such
	それら:they
	それらの:their
	それらの:those
	それらを:them
	とする:assuming:
	になる:become
	に過ぎない:just a
	単に／だけ:just
	に則って:according to
	に則って:accordingly
	べき:should
	もっぱら:solely
	扱う:treat
	以前:previous
	異なる:different
	異なる:differently
	一致:identical
	右辺の:RHS::::
	下:below
	何であれ:Regardless of what
	介:via
	各:each
	結果:result
	結果の:resulting
	見よ:see
	現在:currently
	現在の:current
	個:zero／:one／:two
	個々の:individual
	個数:how many
	0 :zero
	2 個づつ:pair
	個目:second
	後:after
	後続-｜従う:follow
	再度:again
	最も小さい:smallest
	最も大きい:largest
	最後:last
	最初:first
	次の:the following
	所では:place
	所与の:given
	与-:give
	書ける:write
	除-:except
	上:above
	場合によっては:possibly
	常に:always
	大概は:almost always
	生-:occur
	節:section
	前:before
	側:side
	他の:other
	他の場合:otherwise
	多い:often
	多くの:many
	対応-:correspond
	渡-:pass
	等々:etc
	等し:equal
	同じ:same
	内側:inside
	表す:express
	複数の:more than one
	複数の／いくつか／:multiple
	区切らな:separate
	別の:another
	別個の:distinct
	返す:return
	未知の:unknown
	戻-:back
	様なlike
	用いて:using
	両者:both
	類似的:similar
	類似的に:similarly
	一握りの:the only 〜 certain
	元の:original
	合間:between
	常に:always
	もの:thing
	残りの:the rest of
	まだ:yet
	一体:whole
	〜化:version
	間に:during
	唯一の~entryの／-:sole
	何個でも:unbounded
	~~末端:leaf／eventually terminating
	個別に:individually
	ほとんど／:most
	最小限の:minimal
	すべての:every

	●algo
arg:
num:
	不定:auto
	向き:bias
	%val
	%num
	%型/3:finalType
	%基底~型:baseType
	%文字列:str:#4
	%関数:func:#21
	%値~list:thisAndValue
	%~item:item1:#3
	%新~item:~item2:#3
	-:few
	-:together
	-:fresh
	-:provisionally
	-:revert
	-:~funcMatrix
	%基底~型:baseType
	%U:units1
	%V:units2
	%cssText:cssText
	-:remaining
	-:remainder
	-:subsequence
	-:part
	-:followed by
	-:outlined in
	-:consist
	-:body
	-:came
	-:SPACE
	%括弧なし:paren-less
	-:continue to the next step
	-:beyond
	-:temp
	%値~list:temp values
	%複数:~parseMultiple
	%一時~list~temp
	-:norm 

●●ref_normative

[CSS-ANIMATIONS-1]
    Dean Jackson; et al. CSS Animations Level 1. 30 November 2017. WD. URL: https://www.w3.org/TR/css-animations-1/ 
[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. CSS Color Module Level 3. 5 December 2017. CR. URL: https://www.w3.org/TR/css-color-3/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 5 July 2016. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-CONTENT-3]
    Elika Etemad; Dave Cramer. CSS Generated Content Module Level 3. 2 June 2016. WD. URL: https://www.w3.org/TR/css-content-3/ 
[CSS-DISPLAY-3]
    Elika Etemad. CSS Display Module Level 3. 20 July 2017. WD. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-FONTS-3]
    John Daggett. CSS Fonts Module Level 3. 3 October 2013. CR. URL: https://www.w3.org/TR/css-fonts-3/ 
[CSS-GRID-1]
    Tab Atkins Jr.; Elika Etemad; Rossen Atanassov. CSS Grid Layout Module Level 1. 14 December 2017. CR. URL: https://www.w3.org/TR/css-grid-1/ 
[CSS-INLINE-3]
    Dave Cramer; Elika Etemad; Steve Zilles. CSS Inline Layout Module Level 3. 24 May 2016. WD. URL: https://www.w3.org/TR/css-inline-3/ 
[CSS-LISTS-3]
    Tab Atkins Jr.. CSS Lists and Counters Module Level 3. 20 March 2014. WD. URL: https://www.w3.org/TR/css-lists-3/ 
[CSS-OVERFLOW-3]
    David Baron; Florian Rivoal. CSS Overflow Module Level 3. 31 May 2016. WD. URL: https://www.w3.org/TR/css-overflow-3/ 
[CSS-POSITION-3]
    Rossen Atanassov; Arron Eicholz. CSS Positioned Layout Module Level 3. 17 May 2016. WD. URL: https://www.w3.org/TR/css-position-3/ 
[CSS-SIZING-3]
    Elika Etemad. CSS Intrinsic & Extrinsic Sizing Module Level 3. 7 February 2017. WD. URL: https://www.w3.org/TR/css-sizing-3/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS-TEXT-3]
    Elika Etemad; Koji Ishii. CSS Text Module Level 3. 22 August 2017. WD. URL: https://www.w3.org/TR/css-text-3/ 
[CSS-TEXT-DECOR-3]
    Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 3. 1 August 2013. CR. URL: https://www.w3.org/TR/css-text-decor-3/ 
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. CSS Transforms Module Level 1. 30 November 2017. WD. URL: https://www.w3.org/TR/css-transforms-1/ 
[CSS-TRANSFORMS-2]
    CSS Transforms Module Level 2 URL: https://drafts.csswg.org/css-transforms-2/ 
[CSS-TRANSITIONS-1]
    David Baron; Dean Jackson; Brian Birtles. CSS Transitions. 30 November 2017. WD. URL: https://www.w3.org/TR/css-transitions-1/ 
[CSS-UI-4]
    Florian Rivoal. CSS Basic User Interface Module Level 4. 22 December 2017. WD. URL: https://www.w3.org/TR/css-ui-4/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 29 September 2016. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VARIABLES-1]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS22]
    Bert Bos. Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification. 12 April 2016. WD. URL: https://www.w3.org/TR/CSS22/ 
[CSS3-IMAGES]
    Elika Etemad; Tab Atkins Jr.. CSS Image Values and Replaced Content Module Level 3. 17 April 2012. CR. URL: https://www.w3.org/TR/css3-images/ 
[CSSOM-1]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[GEOMETRY-1]
    Simon Pieters; Dirk Schulze; Rik Cabanier. Geometry Interfaces Module Level 1. 25 November 2014. CR. URL: https://www.w3.org/TR/geometry-1/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●
ref_informative


●●trans_metadata
<p>
~THIS_PAGEは、 W3C により編集者草案として公開された
<a href="~SPEC_URL">CSS Typed OM Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新 発行バージョン
    https://www.w3.org/TR/css-typed-om-1/ 
以前のバージョン
    https://www.w3.org/TR/2016/WD-css-typed-om-1-20160607/ 

フィードバック
	<a href="mailto:public-houdini@w3.org?subject=%5Bcss-typed-om%5D%20YOUR%20TOPIC%20HERE">public-houdini@w3.org</a> with subject line “<kbd>[css-typed-om] <i>… message topic …</i></kbd>” (<a href="http://lists.w3.org/Archives/Public/public-houdini/" rel="discussion">archives</a>)</span>

最新の課題
	<a href="https://github.com/w3c/css-houdini-drafts/issues/">GitHub</a>
編集
	<a href="mailto:shanestephens@google.com">Shane Stephens</a>
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
	<a href="mailto:nainar@google.com">Naina Raisinghani</a> (Google)

commit 履歴
	https://github.com/w3c/css-houdini-drafts/commits/master
</script>


</head><body>

<header>


	<hgroup>
<h1>CSS Typed OM Level 1</h1>
	</hgroup>
</header>


<div id="MAIN" style="display:none;">
	<section id="abstract">
<h2 title="Abstract">~~要約</h2>


<p>
~CSSOM値~文字列を~JSにおいて有意義な型の表現に変換したり，元へ戻すことは、有意な処理能~overheadを被り得る。
この仕様は、~CSS値を有型~JS~objとして公開して，高性能な操作を手助けする。
◎
Converting CSSOM value strings into meaningfully typed JavaScript representations and back can incur a significant performance overhead. This specification exposes CSS values as typed JavaScript objects to facilitate their performant manipulation.
</p>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<!-- 
この節では、発行時点における…
 -->
これは編集者草案の~~公開の複製です…
<span class="trans-note">【
以下，この節の他の内容は
<a href="css-common-ja.html#status" >CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>
	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSOM（ Cascading Style Sheets Object Model ）値~文字列を~JSにおいて有意義な型の表現に変換したり, それを元に戻すことは、有意な処理能~overheadを被り得る。
この仕様は、~CSS値を有型~JS~objとして公開して，高性能な操作を手助けする。
◎
Converting Cascading Style Sheets Object Model (CSSOM) value strings into meaningfully typed JavaScript representations and back can incur a significant performance overhead. This specification exposes CSS values as typed JavaScript objects to facilitate their performant manipulation.
</p>

<p>
この仕様により公開される~APIは、人間工学より，処理能を高めるために設計されている
— 特に，次に挙げる点を考慮する下で：
◎
The API exposed by this specification is designed for performance rather than ergonomics. Some particular considerations:
</p>

<ul>
	<li>
検索取得される［
~CSS値の~JS表現
］は、変異可能でない
— 代わりに，更新-は~APIを用いて明示的に設定され~MUST。
◎
retrieved JavaScript representations of CSS values are not mutable - instead updates must explicitly be set using the API.
</li>
	<li>
各種~objは、~accessの容易さより一貫性のために組織化される。
例えば，長さは `px^css 単位の数量~値をとることが多いが、
`calc^f 式や~keywordも長さとして妥当なので、宣言d `CSSNumericValue$I 
【`宣言d~StylePropertyMap$内のそれ】
は，最初に明示的に `CSSUnitValue$I に~castしない限り実数として扱えない。
【 ~cast — 具体的には `CSSNumericValue^II `to()$m1 ~methodを用いて。】
◎
objects are organized for consistency rather than ease of access. For example, even though lengths are often numeric pixel values, a declared CSSNumericValue can’t be treated as a number without first explicitly casting it to a CSSUnitValue, as calc expressions and keywords are also valid lengths.
</li>
</ul>



	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
また、簡潔に述べるため，次の定義も導入している。
</p>

<p>
所与の`~list$ %~list を，各~itemから何かを得る
`演算で写像する@
ときは、次を走らす：
<!-- ＊~listの置換-＋複製を利用？ -->
</p>

<ol>
	<li>
%結果~list ~LET 新たな`~list$
</li>
	<li>
%~list 内の~EACH( %~item ) に対し
⇒
%結果~list に［
所与の演算を %~item に適用した結果
］を`付加する$
</li>
	<li>
~RET %結果~list
</li>
</ol>

<p>
~IDL属性 %m に対する “%m 内部~slot” という表記は、当の~obj上の %m に対応する内部~data~fieldを指す（原文にて，そのような表記を利用している~IDL属性には、［
その属性を~memberに持つ~interfaceを実装する各~obj上に，そのような~data~fieldが在る
］ことが，暗黙的に規定されている）。
</p>


	</section>
	<section id="stylevalue-objects">
<h2 title="CSSStyleValue objects">2. `CSSStyleValue^I ~obj</h2>

<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
interface `CSSStyleValue@I {
    `stringifier$m;
    [`Exposed$=Window] static `CSSStyleValue$I `parse$m(DOMString %property, DOMString %cssText);
    [`Exposed$=Window] static sequence&lt;`CSSStyleValue$I&gt; `parseAll$m(DOMString %property, DOMString %cssText);
};
</pre>


<p>
`CSSStyleValue$I ~objは、~TypedOM~APIを介して~access可能なすべての
~CSS値の基底~classを与える。
◎
CSSStyleValue objects are the base class of all CSS Values accessible via the Typed OM API.
</p>

<p>
直接的に~supportできる `CSSStyleValue$I の下位classが まだない値も，
`CSSStyleValue$I ~objとして表現される。
そのような~objは、それを得るために構文解析された~prop用に限り妥当になると見なされる。
◎
Values that can’t yet be directly supported by a CSSStyleValue subclass are also represented as CSSStyleValue objects. These CSSStyleValue objects are only considered valid for the property that it was parsed with.
</p>

<dl class="idl-def">
	<dt>`stringifier@m</dt>
	<dd>
`文字列化の挙動$は、
<a href="#stylevalue-normalization">`CSSStyleValue^I の正規化 節</a>
に従って，此れが表現する値を正規化した表現を返す。
◎
The stringification behavior of CSSStyleValue objects is to return a normalized representation (see §5 CSSStyleValue normalization) of the value the CSSStyleValue object represents.
</dd>

	<dt>`parse(property, cssText)@m</dt>
	<dd>
被呼出時には、次を遂行し~MUST
⇒
`~CSSStyleValueを構文解析する$( %property, %cssText, %複数~flag ~SET ~F )
◎
The parse(property, cssText) method, when invoked, must parse a CSSStyleValue with property property, cssText cssText, and parseMultiple set to false.
</dd>

	<dt>`parseAll(property, cssText)@m</dt>
	<dd>
被呼出時には、次を遂行し~MUST
⇒
`~CSSStyleValueを構文解析する$( %property, %cssText, %複数~flag ~SET ~T )
◎
The parseAll(DOMString property, DOMString cssText), when invoked, must parse a CSSStyleValue with property property, cssText cssText, and parseMultiple set to true.
</dd>
</dl>

<div class="algorithm">

<p>
`~CSSStyleValueを構文解析する@
ときは、所与の
( `文字列$ %~prop, `文字列$ %cssText, 真偽値 %複数~flag )
に対し、次を走らす：
◎
To parse a CSSStyleValue given a string property, a string cssText, and a parseMultiple flag, run these steps:
</p>

<ol>
	<li>
%~prop ~SET `~prop名を検査して正規化する$( %~prop )
◎
If property is not a custom property name string, let property be property ASCII lowercased.
◎
If property is not a valid CSS property, throw a TypeError and exit this algorithm.
</li>
	<li>
~IF［
%複数~flag  ~EQ ~T
］~AND［
%~prop は`単独の値をとる$
］
⇒
~THROW `TypeError$E
◎
If parseMultiple is true, but property is a single-valued property, throw a TypeError and exit this algorithm.
</li>
	<li>
%一体~値 ~LET 次の結果
⇒
%cssText を %~prop の`文法に則って構文解析する$
⇒
~IF［
失敗した
］
⇒
~THROW `TypeError$E
◎
Attempt to parse cssText according to property’s grammar. If this fails, throw a TypeError and exit this algorithm. Otherwise, let whole value be the parsed result.
</li>
	<li>
%値~list ~LET `~CSS値を反復成分に細分化する$( %一体~値, %~prop )
◎
Subdivide into iterations whole value, according to property, and let values be the result.
</li>
	<li>
%値~list ~SET %値~list を，各 %~item に対し次を得る`演算で写像する$
⇒
`~CSS値を正規化する$( %~item, %~prop )
◎
For each value in values, replace it with the result of normalizing value for property.
</li>
	<li>
~RET ［
%複数~flag ~EQ ~F ならば %値~list[0] ／
~ELSE_ %値~list
］
◎
If parseMultiple is false, return values[0]. Otherwise, return values.
</li>
</ol>
</div>

<div class="algorithm">

<p>
`~CSS値を反復成分に細分化する@
ときは、所与の
( ~CSS値 %一体~値, ~prop %~prop )
に対し，次を走らす：
◎
To subdivide into iterations a CSS value whole value for a property property, execute the following steps:
</p>

<ol>
	<li>
~IF［
%~prop は`単独の値をとる$
］
⇒
~RET 新たな`~list$ « %一体~値 »
◎
If property is a single-valued property, return a list containing whole value.
</li>
	<li>
~RET
%一体~値 を［
%~prop 用に適切な，個々の反復成分
］に細分した結果が成す，同順の反復成分からなる`~list$
◎
Otherwise, divide whole value into individual iterations, as appropriate for property, and return a list containing the iterations in order.
</li>
</ol>
</div>

<div class="note">
<p>注記：
`~list値をとる$~propを何個かの反復成分に細分する方法は、意図的に未定義であり，現時点では手作業である。
<em>一般には</em>、~top-levelの~commaで分割するだけで済む（文法における ~top-levelの
<code class="prod">&lt;%foo&gt;#</code>
項に対応する）。
しかしながら，~propによっては、反復成分を~commaで区切らない旧来のもの（ `counter-reset$p など）や，特異な値（一般に `none^v ）を利用して
<strong>0 個の反復成分</strong>を指示するもの（ `animation$p など）もある。
◎
How to divide a list-valued property into iterations is intentionally undefined and hand-wavey at the moment. Generally, you just split it on top-level commas (corresponding to a top-level &lt;foo&gt;# term in the grammar), but some legacy properties (such as counter-reset) don’t separate their iterations with commas, and some properties (such as animation) use a special singular value (generally none) to indicate zero iterations.
</p>

<p>
将来には，厳格に定義されるものと期待されているが、現時点では，明示的に
“わかるよね”
である。
◎
It’s expected to be rigorously defined in the future, but at the moment is explicitly a "you know what we mean" thing.
</p>
</div>


<div class="algorithm">

<p>
`~prop名を検査して正規化する@
ときは、所与の
( 文字列 %property )
に対し，次を走らす：
</p>

【この~algoは、他所に共通する記述を集約するために、この訳にて導入している。】

<ol>
	<li>
~IF［
%property は`~custom~prop名~文字列$でない
］
⇒
%property ~LET `~ASCII小文字~化する$( %property )
</li>
	<li>
~IF［
%property は`妥当な~CSS~prop名$でない
］
⇒
~THROW `TypeError$E
</li>
	<li>
~RET %property
</li>
</ol>
<!-- 
If property is not a custom property name string, let property be property ASCII lowercased.
If property is not a valid CSS property, throw a TypeError and exit this algorithm.
-->
◎
↓↓</div>

	</section>
	<section id="the-stylepropertymap">
<h2 title="The StylePropertyMap">3. `StylePropertyMap^I</h2>

<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
interface `StylePropertyMapReadOnly@I {
    readonly maplike&lt;DOMString, sequence&lt;`CSSStyleValue$I&gt;&gt;;
    any `get$m(DOMString %property);
    /* <span class="comment">
ここでの `any^c は
`(undefined or CSSStyleValue)^c を意味する
— <a href="https://github.com/heycam/webidl/issues/60">https://github.com/heycam/webidl/issues/60</a> を見よ。
◎
'any' means (undefined or CSSStyleValue) here, see https://github.com/heycam/webidl/issues/60
</span> */
    sequence&lt;`CSSStyleValue$I&gt; `getAll$m(DOMString %property);
    boolean `has@m(DOMString %property);<!-- ＊ -->
    `stringifier@m;<!-- ＊ -->
};

callback `UpdateFunction@I = `CSSStyleValue$I (`CSSStyleValue$I %oldValue);

[`Exposed$=Window]
interface `StylePropertyMap@I : `StylePropertyMapReadOnly$I {
    maplike&lt;DOMString, sequence&lt;`CSSStyleValue$I&gt;&gt;;
    void `append$m(DOMString %property, (`CSSStyleValue$I or DOMString)... %values);
    void `delete$m(DOMString %property);
    void `set$m(DOMString %property, (`CSSStyleValue$I or DOMString)... %values);
    void `update$m(DOMString %property, `UpdateFunction$I %updateFunction);
};
</pre>


<p>
各 `StylePropertyMapReadOnly$I ~objには
`~map~entryたち@
が結付けられる。
それは`有順序~map$であり、その各~entryは，~prop名を与える文字列を `CSSStyleValue$I ~objの~listに対応付ける。
この~listがどう初期化されるかは、 `CSSStyleValue$I がどこで利用されるかに依存して異なる（
<a href="#computed-stylepropertymapreadonly-objects">算出d `StylePropertyMapReadOnly^I ~obj</a>,
<a href="#declared-stylepropertymap-objects">宣言d＆~inline `StylePropertyMap^I ~obj</a>
各~節を見よ）。
◎
A StylePropertyMapReadOnly object has associated map entries, which is a map of property names (string) → values (list of CSSStyleValue objects). This list is initialized differently depending on where the CSSStyleValue is used (see §3.1 Computed StylePropertyMapReadOnly objects and §3.2 Declared &amp; Inline StylePropertyMap objects). 
</p>

<p>
他が指定されない限り、初期~時における`~map~entryたち$の順序は、各~entryの~keyに基づく：
◎
Unless otherwise stated, the initial ordering of the map entries is based on the key of each entry:
</p>

<ol>
	<li>
符号位置の昇順による，~customでない（~CSSが定義する）~propたち。
（~customでない~propは、 `StylePropertyMap$I 内では，常に小文字~化されることに注意。
◎
Non-custom properties, sorted in increasing code-point order. (Note that non-custom properties are always lowercased in StylePropertyMaps.)
</li>
	<li>
符号位置の昇順による，~customでない~prop。
◎
Custom properties, sorted in increasing code-point order.
</li>
</ol>

<p>
一部の~CSS~propは、
`~list値をとる@
— 例： `background-image$p, `animation$p など。
その種の値は，大概は ~comma区切りの並列的な文法~項の~listであり（例外は， `counter-reset$p の様な一握りの旧来の~prop）、それを成す複数の “値のそれぞれ” は，同じ仕方で解釈されることを指示する。
他の~propは、（場合によっては複合的な）
`単独の値をとる@
とされる
— 例： `color$p など。
◎
Some CSS properties are list-valued properties, such as background-image or animation; their value is a list of parallel grammar terms, almost always comma-separated (the only exceptions are certain legacy properties like counter-reset), indicating multiple distinct "values" interpreted in the same way. Other properties, such as color, are single-valued properties; they take only a single (possibly complex) value.
</p>

<p class="issue">
どの~propが~list値をとり，どれがそうでないか精確に定義する
— おそらく付録にて。
`644$issue
◎
w3c/css-houdini-drafts/644[css-typed-om]Define precisely which properties are list-valued and which aren't, probably in an appendix.
</p>

<div class="note">

<p>注記：
~CSS~propには、`単独の値をとる$ものから`~list値をとる$ように遷移した例が，いくつかある。
~propが`単独の値をとる$頃に書かれた~codeが，将来に`~list値をとる$ようになったときにも壊れないことを確保するため、
`StylePropertyMap$I は `multi-map^en にされている†
— それは，各~keyごとに値の<em>~list</em>を格納するが、各~keyに対し，単独の値しかないかのように相互作用-可能にする††。
◎
There are multiple examples of CSS properties that have transitioned from being single-valued to list-valued. To ensure that code written at a time when a property was single-valued does not break when it becomes list-valued in the future, the StylePropertyMap is a multi-map; it stores list of values for each key, but allows you to interact with it as if there was only a single value for each key as well.
</p>

<p class="trans-note">【†
`maplike^c 宣言を通して — この “`multi-map^en” は、単に “一対多” を表すと見受けられる。
】【††
`get()^m ~methodを通して。
】</p>

<p>
このことは、 `StylePropertyMap$I 内の単独の~prop用の複数の値は，その~propの値を成す複数片からなる連続的な定義を表現しないことを意味する。
それらは代わりに、単独の~prop値において，複数の~comma区切りの下位-値を表現する
— `background-image$p ~prop内の各 “層” の様に。
◎
This means that multiple values for a single property in a StylePropertyMap do not represent multiple successive definition of that property’s value; instead, they represent multiple comma-separated sub-values in a single property value, like each "layer" in a background-image property.
</p>
</div>


<dl class="idl-def">
	<dt>`append(property, ...values)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The append(property, ...values) method, when called on a StylePropertyMap this, must perform the following steps:
</p>

		<ol>
			<li>
%property ~SET `~prop名を検査して正規化する$( %property )
◎
If property is not a custom property name string, let property be property ASCII lowercased.
◎
If property is not a valid CSS property, throw a TypeError and exit this algorithm.
</li>
			<li>
~IF［
%property は`単独の値をとる$
<!-- ＊~list値をとる$でない -->
］
⇒
~THROW `TypeError$E
◎
If property is not a list-valued property, throw a TypeError and exit this algorithm.
</li>
			<li>
%~prop~map ~LET 此れの`~map~entryたち$
◎
Let props be this’s map entries.
</li>
			<li>
~IF［
%~prop~map[ %property ] ~EQ ε
］
⇒
%~prop~map[ %property ] ~SET 空`~list$
◎
If props[property] does not exist, set props[property] to an empty list.
</li>
			<li>
%values を成す ~EACH( %値 ) に対し
⇒
%~prop~map[ %property ] に次の結果を`付加する$
⇒
`~style値を正規化する$( %property, %値 )
◎
Let temp values be an empty list.
◎
For each value in values, normalize a style value with property and value, and append the returned value to temp values.
◎
Append the entries of temp values to props[property].
</li>
		</ol>
	</dd>

	<dt>`delete(property)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST
◎
The delete(property) method, when called on a StylePropertyMap this, must perform the following steps:
</p>

		<ol>
			<li>
%property ~SET `~prop名を検査して正規化する$( %property )
◎
If property is not a custom property name string, let property be property ASCII lowercased.
◎
If property is not a valid CSS property, throw a TypeError and exit this algorithm.
</li>
			<li>
此れの`~map~entryたち$[ %property ] ~SET ε
◎
If this’s map entries contains property, remove it.
</li>
</ol>
	</dd>
</dl>

<div class="algorithm">

<p>
`~style値を正規化する@
ときは、所与の
( `文字列$ %~prop, `文字列$または `CSSStyleValue$I %値 )
に対し， %値 の型に応じて次を走らす：
◎
To normalize a style value, given a string property and a string or CSSStyleValue value:
</p>

<dl class="switch">
	<dt>
`CSSStyleValue$I
◎
If value is a CSSStyleValue,
</dt>
	<dd>
		<ol>
			<li>
~IF［
%~prop は`~list値をとる$
］~AND［
%値 は %~prop の`~CSS生成規則に合致する$
<!-- ＊property iteration of property -->
］
⇒
~RET %値
</li>
			<li>
~THROW `TypeError$E
</li>
		</ol>
◎
If value does not match the grammar of a list-valued property iteration of property, throw a TypeError and exit this algorithm. Otherwise, return the value.
</dd>

	<dt>
`DOMString^I
◎
If value is a DOMString,
</dt>

	<dd>
		<ol>
			<li>
~RET 次の結果
⇒
`~CSSStyleValueを構文解析する$( %~prop, %値, %複数~flag ~SET ~F )
◎
Parse a CSSStyleValue with property property, cssText value, and parseMultiple set to false, and return the result.
</li>
		</ol>

<p class="note">注記：
これは `TypeError$E を投出することもある。
◎
Note: This can throw a TypeError instead.
</p>
	</dd>
</dl>

</div>

<div class="algorithm">

<p>
`CSSStyleValue$I がどの
`~CSS生成規則に合致する@
とされるかは、次の規則に基づく：
◎
A CSSStyleValue is said to match a CSS production based on the following rules:
</p>

<ul>
	<li>
`CSSKeywordValue$I は、常に `ident$t に合致する。
◎
A CSSKeywordValue always matches &lt;ident&gt;.
</li>
	<li>
`CSSTransformValue$I は、常に `transform-list$t に合致する。
◎
A CSSTransformValue always matches &lt;transform-list&gt;.
</li>
	<li>
`CSSPositionValue$I は、常に `position$t に合致する。
◎
A CSSPositionValue always matches &lt;position&gt;.
</li>
	<li>
`CSSNumericValue$I は［
その型が`合致-$するもの
］に合致する。
◎
A CSSNumericValue matches what its type matches.
</li>
	<li>
`CSSURLImageValue$I は、常に `url$t に合致する。
◎
A CSSURLImageValue always matches &lt;url&gt;.
</li>
	<li>
`CSSImageValue$I の下位classは、常に `image$t に合致する。
◎
Any subclass of CSSImageValue always matches &lt;image&gt;.
</li>
</ul>
</div>


<dl class="idl-def">
<!-- ＊ -->
	<dt>`StylePropertyMapReadOnly^II `get(property)@m1</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The get(property) method, when called on a StylePropertyMap this, must perform the following steps:
</p>
		<ol>
			<li>
%property ~SET `~prop名を検査して正規化する$( %property )
◎
If property is not a custom property name string, let property be property ASCII lowercased.
◎
If property is not a valid CSS property, throw a TypeError and exit this algorithm.
</li>
			<li>
%~prop~map ~LET 此れの`~map~entryたち$
◎
Let props be this’s map entries.
</li>
			<li>
~IF［
%~prop~map[ %property ] ~NEQ ε
］
⇒
~RET %~prop~map[ %property ][0]
◎
If props[property] exists, return props[property][0].
</li>
			<li>
~RET `undefined^c
<!-- ＊js -->
◎
Otherwise, return undefined.
</li>
		</ol>
	</dd>

<!-- ＊ -->
	<dt>`StylePropertyMapReadOnly^II`getAll(property)@m1</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The getAll(property) method, when called on a StylePropertyMap this, must perform the following steps:
</p>
		<ol>
			<li>
%property ~SET `~prop名を検査して正規化する$( %property )
◎
If property is not a custom property name string, let property be property ASCII lowercased.
◎
If property is not a valid CSS property, throw a TypeError and exit this algorithm.
</li>
			<li>
%~prop~map ~LET 此れの`~map~entryたち$
◎
Let props be this’s map entries.
</li>
			<li>
~IF［
%~prop~map[ %property ] ~NEQ ε
］
⇒
~RET %~prop~map[ %property ]
◎
If props[property] exists, return props[property].＼
</li>
			<li>
~RET 空`~list$
◎
Otherwise, return an empty list.
</li>
		</ol>
	</dd>

	<dt>`set(property, ...values)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The set(property, ...values) method, when called on a StylePropertyMap this, must perform the following steps:
</p>

		<ol>
			<li>
%property ~SET `~prop名を検査して正規化する$( %property )
◎
If property is not a custom property name string, let property be property ASCII lowercased.
◎
If property is not a [valid CSS property, throw a TypeError and exit this algorithm.
</li>
			<li>
~IF［
%property は`単独の値をとる$
］~AND［
%values 内に複数の`~item$がある
］
⇒
~THROW `TypeError$E
◎
If property is a single-valued property and values has more than one item, throw a TypeError and exit this algorithm.
</li>
			<li>
%~prop~map ~LET 此れの`~map~entryたち$
◎
Let props be this’s map entries.
</li>
			<li>
%~prop~map[ %property ] ~SET 空`~list$
◎
If props[property] exists, remove it.
◎
Let values to set be an empty list.
</li>
			<li>
%values を成す ~EACH( %値 ) に対し
⇒
%~prop~map[ %property ] に次の結果を付加する
⇒
`~style値を正規化する$( %property, %値 )
◎
For each value in values, normalize a style value for property and value, and append the result to values to set.
◎
Set props[property] to values to set.
</li>
		</ol>

<p class="note">注記：
%property は削除されてから, また追加され、`有順序~map$の末尾に置かれる
— これにより、`略式~prop$に面したときでも，期待される挙動を与える。
◎
Note: The property is deleted then added back so that it gets put at the end of the ordered map, which gives the expected behavior in the face of shorthand properties.
</p>

	</dd>

<!--＊-->
	<dt id="dom-stylepropertymap-update-property-updatefn">`update(property, updateFunction)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The update(property, updateFn) method, when called on a StylePropertyMap this, must perform the following steps:
</p>

		<ol>
			<li>
%旧-値 ~LET ( %property )
を渡して，此れ上で
`StylePropertyMapReadOnly^II `get()$m1 の内部~algoを~callした結果
◎
Let old value be the result of calling this.get(property) (using the original value of get()).
</li>
			<li>
%新-値 ~LET 次の結果
⇒
%旧-値 を渡して， %updateFunction を`呼出す$
◎
Let new value be the result of invoking updateFn with old value.
</li>
			<li>
(%property, %新-値 )
を渡して，此れ上で `set()$m の内部~algoを~callする
◎
Call this.set(property, new value) (using the original value of set()).
</li>
		</ol>
	</dd>
</dl>


<p class="issue">
~listを［
取得する／設定する
］ための `updateAll()^m ~methodは必要か？
`645$issue
◎
w3c/css-houdini-drafts/645[css-typed-om] Do we need an updateAll() method that gets and sets a list?
</p>

<p>
どの［
`算出d~StylePropertyMap$,
`宣言d~StylePropertyMap$
］~objも，~liveである
— すなわち，これらの~obj上の属性や~methodは、~dataの~snapshotではなく，実際の下層の~dataに演算し~MUST。
◎
Computed StylePropertyMaps and declared StylePropertyMaps are all live objects: the attributes and methods on these objects must operate on the actual underlying data, not a snapshot of the data.
</p>


<p>
`--foo^p の様に 2 個の `002D^U ( `-^l  ) から開始される`文字列$ は、
`~custom~prop名~文字列@
とされる。
（これは， `custom-property-name$t 生成規則に対応するが、`識別子$ではなく`文字列$に適用されるので，~CSS構文解析器を呼出すことなく利用できる／され得る。）
◎
A string is a custom property name string if it starts with two dashes (U+002D HYPHEN-MINUS), like --foo. (This corresponds to the &lt;custom-property-name&gt; production, but applies to strings, rather than identifiers; it can be used without invoking the CSS parser.)
</p>

<p>
次を満たす`文字列$は、
`妥当な~CSS~prop名@
とされる
⇒
［
`~custom~prop名~文字列$である
］~OR［
~UAが認識する~CSS~prop名である
【`~supportされる~CSS~prop$】
］
◎
A string is a valid CSS property if it is a custom property name string, or is a CSS property name recognized by the user agent.
</p>


<p class="issue">
`StylePropertyMap^I 上の残りの~methodにも詳細な記述を追加する。
`148$issue
◎
w3c/css-houdini-drafts/148[css-typed-om] add detailed descriptions of the rest of the methods on StylePropertyMap
</p>

<p class="issue">
文字列化の挙動。
`268$issue
◎
w3c/css-houdini-drafts/268[css-typed-om] Stringification behavior
</p>

<p class="issue">
`StylePropertyMap^I は、`~custom~prop$とどう相互作用するべきかを記述する。
`276$issue
◎
w3c/css-houdini-drafts/276[css-typed-om] Describe how the StylePropertyMaps should interact with custom properties
</p>




		<section id="computed-stylepropertymapreadonly-objects">
<h3 title="Computed StylePropertyMapReadOnly objects">3.1. 算出d `StylePropertyMapReadOnly^I ~obj</h3>

<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
partial interface `Element$I0 {
    `StylePropertyMapReadOnly$I `computedStyleMap$m();
};
</pre>


<p>
`算出d~StylePropertyMap@
~objは， `Element$I の`算出d値$を表現する。
それは、 `computedStyleMap()$m ~methodを~callして~accessされる。
◎
Computed StylePropertyMap objects represent the computed values of an Element, and are accessed by calling the computedStyleMap() method.
</p>

<dl class="idl-def">
	<dt>`computedStyleMap()@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The computedStyleMap() method must, when called on an Element this, perform the following steps:
</p>
	<ol>
		<li>
<p>
~RET
~live `StylePropertyMapReadOnly$I ~obj
— この~objの`~map~entryたち$は：
◎
Return a live StylePropertyMapReadOnly object, whose map entries are＼
</p>
			<ul>
				<li>
次に該当する すべての~propの［
名前, `算出d値$
］からなるとする
⇒＃
~UAが~supportする略式でない~CSS~prop,
登録されている`~custom~prop$,
登録されていない`~custom~prop$のうち 此れ上にて その初期~値に設定されていないもの
◎
the name and computed value of every longhand CSS property supported by the User Agent, every registered custom property, and every non-registered custom property which is not set to its initial value on this,＼
</li>
				<li>
`~map~entryたち$の定義に述べた順序に~sortされるとする。
【~liveなので、更新されるたびに，~sortし直されることになる。】
<!-- 
~prop名の符号位置~順による，~CSSが定義する~propたち,
~prop名の符号位置~順による，~custom~propたち
 -->
◎
ordered by putting CSS-defined properties before custom properties, then sorting by code-point order of property name within those two categories.
</li>
				</ul>
			</li>
		</ol>
	</dd>
</dl>

<p class="note">注記：
`getComputedStyle()$m と同様に、この~methodは［
`生成元clean~flag$ ~EQ ~OFF
］にされた~stylesheetからの情報を公開し得る。
◎
Note: like Window.getComputedStyle(), this method can expose information from stylesheets with the origin-clean flag unset.
</p>


<p class="note">注記：
この~methodが返す `StylePropertyMapReadOnly$I は、
`getComputedStyle()$m に利用される`解決値$の概念ではなく，<em>実際の</em>`算出d値$を表現する。
したがって，一部の~prop（ `width$p など）に対しては、 `getComputedStyle()$m と異なる値を返すこともある。
◎
Note: The StylePropertyMapReadOnly returned by this method represents the actual computed values, not the resolved value concept used by Window.getComputedStyle(). It can thus return different values than Window.getComputedStyle() for some properties (such as width).
</p>

<p class="note">注記：
<a href="https://github.com/w3c/css-houdini-drafts/issues/350#issuecomment-294690156">WG resolution</a>
により、疑似要素の~styleは，この~methodを
新たな `PseudoElement^I ~interfaceに追加することで得られるようになるものと意図されている（ `getComputedStyle()$m が 2 個目の引数（ %pseudoElt ）を用いて行う様にはせずに）。
◎
Note: Per WG resolution, pseudo-element styles are intended to be obtainable by adding this method to the new PseudoElement interface (rather than using a pseudoElt argument like Window.getComputedStyle() does).
</p>


		</section>
		<section id="declared-stylepropertymap-objects">
<h3 title="Declared &amp; Inline StylePropertyMap objects">3.2. 宣言d／~inline `StylePropertyMap^I ~obj</h3>

<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
partial interface `CSSStyleRule$I0 {
    [`SameObject$] readonly attribute `StylePropertyMap$I `styleMap$m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
partial interface `ElementCSSInlineStyle$I0 {
    [`SameObject$] readonly attribute `StylePropertyMap$I `attributeStyleMap$m;
};
</pre>


<p>
`宣言d~StylePropertyMap@
~objは、［
~style規則 ／ 
~inline~style
］内に埋込まれた
( ~prop / 値 )
~pairたちが成す~styleを表現する：
◎
Declared StylePropertyMap objects represent style property-value pairs embedded in a style rule or inline style, and＼
</p>

<ul>
	<li>
<p>
それは、次の属性を介して~accessされる：
</p>
		<ul>
			<li>
~style規則に対しては、
`CSSStyleRule$I ~objの
`styleMap@m1
属性
</li>
			<li>
~inline~styleに対しては、
（ `Element^I などの） `ElementCSSInlineStyle$I ~interfaceを実装する~objの
`attributeStyleMap@m1
属性
</li>
		</ul>
◎
are accessed via the styleMap attribute of CSSStyleRule objects, or the attributeStyleMap attribute of objects implementing the ElementCSSInlineStyle interface (such as Elements).
</li>
	<li>
その`~map~entryたち$は、~objの構築-時に，次のように初期化されるとする
⇒
各~propのうち，~objが表現する［
~style規則 ／~inline~style
］の内側に妥当な値を伴うものごとに， 1 個の~entryを包含する
◎
When constructed, the map entries for declared StylePropertyMap objects is initialized to contain an entry for each property with a valid value inside the CSSStyleRule or inline style that the object represents, in the same order as the CSSStyleRule or inline style.
</li>
</ul>

		</section>
	</section>
	<section id="stylevalue-subclasses">
<h2 title="CSSStyleValue subclasses">4. `CSSStyleValue^I の下位class</h2>


		<section id="unparsedvalue-objects">
<h3 title="CSSUnparsedValue objects">4.1. `CSSUnparsedValue^I ~obj</h3>


<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSUnparsedValue@C(sequence&lt;`CSSUnparsedSegment$I&gt; %members)]
interface `CSSUnparsedValue@I : `CSSStyleValue$I {
    `iterable$m&lt;`CSSUnparsedSegment$I&gt;;
    readonly attribute unsigned long `length$m;
    `getter$m `CSSUnparsedSegment$I (unsigned long %index);
    `setter$m `CSSUnparsedSegment$I (unsigned long %index, `CSSUnparsedSegment$I %val);
};

typedef (DOMString or `CSSVariableReferenceValue$I) `CSSUnparsedSegment@I;
<!-- ＊分割して下へ移動 -->
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSVariableReferenceValue$C(DOMString %variable, optional `CSSUnparsedValue$I %fallback)]
interface `CSSVariableReferenceValue@I {
    attribute DOMString `variable$m;
    readonly attribute `CSSUnparsedValue$I? `fallback$m;
};
</pre>

<p>
`CSSUnparsedValue$I ~objは、`~custom~prop$を参照する値を表現する。
それは、［
`DOMString^I として与えられる文字列~片,
`CSSVariableReferenceValue$I ~objとして与えられる変数~参照
］が~~混在する`~list$であり、~objは，それらの値を反復する。
この~listは、~objの
`tokens@sl
内部~slotに格納される。
◎
CSSUnparsedValue objects represent values that reference custom properties. They represent a list of string fragments and variable references.
◎
They have a [[tokens]] internal slot, which is a list of DOMStrings and CSSVariableReferenceValue objects. This list is the object’s values to iterate over.
</p>

<!-- ＊
`CSSUnparsedValue@I
 -->
<dl class="idl-def">
	<dt>`iterable@m</dt>
	<dt>`length@m</dt>
	<dt>`getter@m</dt>
	<dt>`setter@m</dt>
	<dd>
これらのふるまい（
`値~反復子$,
`被support~prop~index$,
`有index取得子$,
`有index設定子$
）は、此れの `tokens$sl に基づくとする。
◎
The length attribute indicates how many string fragments and variable references are contained within the CSSUnparsedValue.
◎
The indexed getter retrieves the string fragment or variable reference at the provided index.
</dd>
</dl>

<!-- ＊
`CSSVariableReferenceValue^I0
 -->

<dl class="idl-def">
	<dt>`variable@m</dt>
	<dd>
<p>
設定子は、所与の
( 文字列 %variable )
に対し，次を走らせ~MUST：
◎
The variable attribute of a CSSVariableReferenceValue this must, on setting a variable variable, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%variable は`~custom~prop名~文字列$でない
］
⇒
~THROW `TypeError$E
◎
If variable is not a custom property name string, throw a TypeError, and exit this algorithm.
</li>
			<li>
此れの `variable$m 内部~slot ~SET %variable
◎
Otherwise, set this’s variable internal slot to variable.
</li>
		</ol>
	</dd>

	<dt>`fallback@m</dt>
	<dd>
【言及されていないが、単に構築子にて設定された値を返すであろう。】
</dd>

	<dt>`CSSVariableReferenceValue(variable, fallback)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSVariableReferenceValue(variable, fallback) constructor must, when called, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%variable は`~custom~prop名~文字列$でない
］
⇒
~THROW `TypeError$E
◎
If variable is not a custom property name string, throw a TypeError, and exit this algorithm.
</li>
			<li>
~IF［
%~fallback は与えられていない
］
⇒
%~fallback ~SET ~NULL
</li>
			<li>
~RET 次のようにされt新たな `CSSVariableReferenceValue$I
⇒＃
`variable$m 内部~slot ~SET %variable,
`fallback$m 内部~slot ~SET %~fallback
◎
Return a new CSSVariableReferenceValue with its variable internal slot set to variable and its fallback internal slot set to fallback (if passed) or null otherwise.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="keywordvalue-objects">
<h3 title="CSSKeywordValue objects">4.2. `CSSKeywordValue^I ~obj</h3>

<p>
`CSSKeywordValue$I
~objは、［
~CSS~keyword／他の`識別子$
］を表現する。
◎
CSSKeywordValue objects represent CSS keywords and other identifiers.
</p>


<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSKeywordValue$C(DOMString %value)]
interface `CSSKeywordValue@I : `CSSStyleValue$I {
    attribute DOMString `value$m;
};
</pre>


<dl class="idl-def">
	<dt>`CSSKeywordValue(value)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST
◎
The CSSKeywordValue(value) constructor must, when called, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%value ~EQ 空~文字列
］
⇒
~THROW `TypeError$E
◎
If value is an empty string throw a TypeError and exit this algorithm.
</li>
			<li>
~RET 次のようにされた新たな `CSSKeywordValue$I
⇒
`value$m1 内部~slot ~SET %value
◎
Otherwise, return a new CSSKeywordValue with its value internal slot set to value.
</li>
		</ol>
	</dd>
</dl>


<p>
`CSSKeywordValue$I が受容される所では、次の~typedefと~algoを利用することにより，生の `DOMString^I も受容される：
◎
Any place that accepts a CSSKeywordValue also accepts a raw DOMString, by using the following typedef and algorithm:
</p>


<pre class="idl">
typedef (DOMString or `CSSKeywordValue$I) `CSSKeywordish@I;
</pre>


<div class="algorithm">

<p>
`~keywordに類する値を規格化する@
ときは、所与の
( %値 )
に対し， %値 の型に応じて次を返す：
</p>

<dl class="switch">
	<dt>`CSSKeywordValue$I</dt>
	<dd>
%値
</dd>

	<dt>`DOMString^I</dt>
	<dd>
次のようにされた新たな `CSSKeywordValue$I ~obj
⇒
`value$m 内部~slot ~SET %値
</dd>
</dl>

◎
To rectify a keywordish value val, perform the following steps:
• If val is a CSSKeywordValue, return val.
• If val is a DOMString, return a new CSSKeywordValue with its value internal slot set to val.
</div>


<!-- 
`CSSKeywordValue^I0
 -->

<dl class="idl-def">
	<dt>`value@m</dt>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The value attribute of a CSSKeywordValue this must, on setting a value value, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%value ~EQ 空~文字列
］
⇒
~THROW `TypeError$E
◎
If value is an empty string, throw a TypeError, and exit this algorithm.
</li>
			<li>
~RET 次のようにされた新たな `CSSKeywordValue$I
⇒
此れの `value$m 内部~slot ~SET %value
◎
Otherwise, set this’s value internal slot, to value.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="numeric-objects">
<h3 title="Numeric Values:">4.3. 数量~値</h3>


<p>
`CSSNumericValue$I ~objは、その資質から数量である~CSS値を表現する（
`number$t, `percentage$t, `dimension$t
など）。
次の 2 つの~interfaceが `CSSNumericValue$I を継承する：
◎
CSSNumericValue objects represent CSS values that are numeric in nature (&lt;number&gt;s, &lt;percentage&gt;s, &lt;dimension&gt;s). There are two interfaces that inherit from CSSNumericValue:
</p>

<ul>
	<li>
`CSSUnitValue$I ~objは、単独の単位~型を包含する値を表現する（例： `42px^v ）。
◎
CSSUnitValue objects represent values that contain a single unit type (for example "42px").
</li>
	<li>
`CSSMathValue$I ~objは、複数の ( 値/単位 ) ~pairを包含し得るような，数式を表現する
（例： `calc(56em + 10%)^v ）。
◎
CSSMathValue objects represent math expressions, which can contain more than one value/unit (for example "calc(56em + 10%)").
</li>
</ul>


<p>
`CSSNumericValue$I ~objが表現する値の範囲は、制約されない。
妥当などの数量~値も、 `CSSNumericValue$I により表現できる。
その値が`宣言d~StylePropertyMap$上に設定されても，［
切詰められる／ 丸められる／ 却下される
］ことはない。
［
切詰められる／丸められる
］のは、~styleを算出する間に生じることになる。
◎
CSSNumericValue objects are not range-restricted. Any valid numeric value can be represented by a CSSNumericValue, and that value will not be clamped, rounded, or rejected when set on a declared StylePropertyMap. Instead, clamping and/or rounding will occur during computation of style.
</p>

<div class="example">

<p>
次の~codeは妥当である：
◎
The following code is valid
</p>
<pre class="lang-js">
myElement.attributeStyleMap.set("opacity", CSS.number(3));
myElement.attributeStyleMap.set("z-index", CSS.number(15.4));

console.log(myElement.attributeStyleMap.get("opacity").value); // 3
console.log(myElement.attributeStyleMap.get("z-index").value); // 15.4

var %computedStyle = myElement.computedStyleMap();
var %opacity = computedStyle.get("opacity");
var %zIndex = computedStyle.get("z-index");
</pre>


<p>
実行~後の %opacity の値は `1^v になり（ `opacity$p は範囲が制約される），
%zIndex の値は `15^v になる（ `z-index$p は整数~値に丸められる）。
◎
After execution, the value of opacity is 1 (opacity is range-restricted), and the value of zIndex is 15 (z-index is rounded to an integer value).
</p>
</div>


<p class="note">注記：
変数~参照を組入れる “数量~値” は、代わりに `CSSUnparsedValue$I ~objとして表現され、
~keywordは `CSSKeywordValue$I ~objとして表現されることになる。
◎
Note: "Numeric values" which incorporate variable references will instead be represented as CSSUnparsedValue objects, and keywords as CSSKeywordValue objects.
</p>

<p>
`CSSNumericValue$I が受容される所では、次の~typedefと~algoを利用することにより，生の `double^I も受容される：
◎
Any place that accepts a CSSNumericValue also accepts a raw double, by using the following typedef and algorithm:
</p>


<pre class="idl">
typedef (double or `CSSNumericValue$I) `CSSNumberish@I;
</pre>

<div class="algorithm">

<p>
`実数に類する値を規格化する@
ときは、所与の
( %~num )
に対し，次を遂行する：
◎
To rectify a numberish value num, perform the following steps:
</p>

<ol>
	<li>
~IF［
%~num は `CSSNumericValue$I 型である
］
⇒
~RET %~num
◎
If num is a CSSNumericValue, return num.
</li>
	<li>
~Assert：
%~num は `double^I 型である
◎
If num is a double,＼
</li>
	<li>
~RET 次のようにされた新たな `CSSUnitValue$I
⇒＃
`value$m1 内部~slot ~SET %~num；
`unit$m1 内部~slot ~SET `number^l
◎
return a new CSSUnitValue with its value internal slot set to num and its unit internal slot set to "number".
</li>
</ol>
</div>



			<section id="numeric-value">
<h4 title="Common Numeric Operations, and the CSSNumericValue Superclass">4.3.1. 共通の数量~演算と `CSSNumericValue^I 上位class</h4>

<p>
すべての数量~CSS値（
`number$t, `percentage$t, `dimension$t 
）は、
`CSSNumericValue$I ~interfaceの下位classにより表現される。
◎
All numeric CSS values (&lt;number&gt;s, &lt;percentage&gt;s, and &lt;dimension&gt;s) are represented by subclasses of the CSSNumericValue interface.
</p>


<pre class="idl">
enum `CSSNumericBaseType@I {
    "`length@m",
    "`angle@m",
    "`time@m",
    "`frequency@m",
    "`resolution@m",
    "`flex@m",
    "`percent@m",
};

dictionary `CSSNumericType@I {
    long `length@m;
    long `angle@m;
    long `time@m;
    long `frequency@m;
    long `resolution@m;
    long `flex@m;
    long `percent@m;
    `CSSNumericBaseType$I `percentHint@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
interface `CSSNumericValue@I : `CSSStyleValue$I {
    `CSSNumericValue$I `add$m(`CSSNumberish$I... %values);
    `CSSNumericValue$I `sub$m(`CSSNumberish$I... %values);
    `CSSNumericValue$I `mul$m(`CSSNumberish$I... %values);
    `CSSNumericValue$I `div$m(`CSSNumberish$I... %values);
    `CSSNumericValue$I `min$m(`CSSNumberish$I... %values);
    `CSSNumericValue$I `max$m(`CSSNumberish$I... %values);

    boolean `equals$m(`CSSNumberish$I... %value);

    `CSSUnitValue$I `to$m(DOMString %unit);
    `CSSMathSum$I `toSum$m(DOMString... %units);
    `CSSNumericType$I `type$m();

    [`Exposed$=Window] static `CSSNumericValue$I `parse$m(DOMString %cssText);
};
</pre>


<p>
上位class `CSSNumericValue$I の各種~methodは、すべての数量~値に遂行できる演算を表現する。
◎
The methods on the CSSNumericValue superclass represent operations that all numeric values can perform.
</p>


<p>
以下に、各種 次元に遂行できる算術~演算を与える：
◎
The following are the arithmetic operations you can perform on dimensions:
</p>

<dl class="idl-def">
	<dt>`add(...values)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The add(...values) method, when called on a CSSNumericValue this, must perform the following steps:
</p>
		<ol>
			<li>
%値~list ~LET 此れは `CSSMathSum$I ~objであるならば 此れの `values$m1 内部~slot ／
~ELSE_ « 此れ »
◎
↓</li>
			<li>
%values を成す~EACH( %値 ) に対し
⇒
%値~list に次の結果を`付加する$
⇒
`実数に類する値を規格化する$( %値 )
◎
Replace each item of values with the result of rectifying a numberish value for the item.
◎
If this is a CSSMathSum object, prepend the items in this’s values internal slot to values. Otherwise, prepend this to values.
</li>
			<li>
~IF［
%値~list 内のどの`~item$も `CSSUnitValue$I である
］~AND［
%値~list 内のすべての`~item$の `unit$m1 は互いに同じ %単位 である
］
⇒
~RET 次のようにされた新たな `CSSUnitValue$I ~obj
⇒＃
`unit$m1 内部~slot ~SET %単位<!-- 此れの＊ `unit$m1 内部~slot -->,
`value$m1 内部~slot ~SET ［ %値~list 内のすべての`~item$の `value$m1 内部~slot ］の総和
◎
If all of the items in values are CSSUnitValues and have the same unit, return a new CSSUnitValue whose unit internal slot is set to this’s unit internal slot, and value internal slot is set to the sum of the value internal slots of the items in values.
</li>
			<li>
%型 ~LET `型を加算する$( %値~list 内のすべての`~item$の`型$ )
◎
Let type be the result of adding the types of every item in values.＼
</li>
			<li>
~IF［
%型 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If type is failure, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSMathSum$I ~obj
⇒
`values$m1 内部~slot ~SET %値~list
◎
Return a new CSSMathSum object whose values internal slot is set to values.
</li>
		</ol>
	</dd>

	<dt>`sub(...values)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The sub(...values) method, when called on a CSSNumericValue this, must perform the following steps:
</p>
		<ol>
			<li>
%values ~SET %values が成す~listを［
各 %~item に対し，次の結果を`反数にする$
］`演算で写像する$
⇒
`実数に類する値を規格化する$( %~item )
◎
Replace each item of values with the result of rectifying a numberish value for the item, then negating the value.
</li>
			<li>
~RET ( %values ) を渡して，此れ上で `add()$m の内部~algoを~callした結果
◎
Return the result of calling the add() internal algorithm with this and values.
</li>
		</ol>
	</dd>
	<dd class="algorithm">
<p>
`CSSNumericValue$I %V を
`反数にする@
ときは：
◎
To negate a CSSNumericValue this:
</p>
		<ol>
			<li>
~IF［
%V は `CSSMathNegate$I ~objである
］
⇒
~RET %V の `value$m1 内部~slot
◎
If this is a CSSMathNegate object, return this’s value internal slot.
</li>
			<li>
~IF［
%V は `CSSUnitValue$I ~objである
］
⇒
~RET 次のようにされた新たな `CSSUnitValue$I
⇒＃
`unit$m1 内部~slot ~SET %V の`unit$m1 内部~slot,
`value$m1 内部~slot ~SET %V の `value$m1 内部~slotの反数
◎
If this is a CSSUnitValue object, return a new CSSUnitValue with the same unit internal slot as this, and a value internal slot set to the negation of this’s.
</li>
			<li>
~RET 次のようにされた新たな `CSSMathNegate$I ~obj
⇒
`value$m1 内部~slot ~SET %V
◎
Otherwise, return a new CSSMathNegate object whose value internal slot is set to this.
</li>
		</ol>
	</dd>

	<dt>`mul(...values)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The mul(...values) method, when called on a CSSNumericValue this, must perform the following steps:
</p>
		<ol>
			<li>
%値~list ~LET 此れは `CSSMathProduct$I ~objであるならば 此れの `values$m1 内部~slot ／
~ELSE_ « 此れ »
◎
↓</li>
			<li>
%values を成す~EACH( %値 ) に対し
⇒
%値~list に次の結果を`付加する$
⇒
`実数に類する値を規格化する$( %値 )
◎
Replace each item of values with the result of rectifying a numberish value for the item.
◎
If this is a CSSMathProduct object, prepend the items in this’s values internal slot to values. Otherwise, prepend this to values.
</li>
			<li>
<p>
~IF［
%値~list 内の どの`~item$も `CSSUnitValue$I である
］：
</p>
				<ol>
					<li>
%単位 ~LET %値~list 内の`~item$のうち［
その `unit$m1 内部~slot ~NEQ `number^l
］を満たすものの個数に応じて
⇒＃
0 個ならば `number^l
1 個ならば その`~item$の `unit$m1 内部~slot  ／
2 個以上ならば ε
</li>
					<li>
~IF［
%単位 ~NEQ ε
］
⇒
~RET 次のようにされた新たな `CSSUnitValue$I ~obj
⇒＃
`unit$m1 内部~slot ~SET %単位,
`value$m1 内部~slot ~SET { %値~list 内のすべての`~item$の `value$m1 内部~slot } の積
</li>
				</ol>

◎
If all of the items in values are CSSUnitValues with unit internal slot set to "number", return a new CSSUnitValue whose unit internal slot is set to "number", and value internal slot is set to the product of the value internal slots of the items in values.
◎
If all of the items in values are CSSUnitValues with unit internal slot set to "number" except one which is set to unit, return a new CSSUnitValue whose unit internal slot is set to unit, and value internal slot is set to the product of the value internal slots of the items in values.
</li>
			<li>
%型 ~LET `型を乗算する$( %値~list 内のすべての`~item$の`型$ )
◎
Let type be the result of multiplying the types of every item in values.＼
</li>
			<li>
~IF［
%型 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If type is failure, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSMathProduct$I ~obj
⇒
`values$m1 内部~slot ~SET %値~list
◎
Return a new CSSMathProduct object whose values internal slot is set to values.
</li>
		</ol>
	</dd>

	<dt>`div(...values)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The div(...values) method, when called on a CSSNumericValue this, must perform the following steps:
</p>
		<ol>
			<li>
%values ~SET %values が成す~listを［
各 %~item に対し，次の結果を`逆数にする$
］`演算で写像する$
⇒
`実数に類する値を規格化する$( %~item )
◎
Replace each item of values with the result of rectifying a numberish value for the item, then inverting the value.
</li>
			<li>
~RET ( %values ) を渡して，此れ上で `mul()$m の内部~algoを~callした結果
◎
Return the result of calling the mul() internal algorithm with this and values.
</li>
		</ol>
	</dd>

	<dd class="algorithm">
<p>
`CSSNumericValue$I %V を
`逆数にする@
ときは：
◎
To invert a CSSNumericValue this:
</p>
		<ol>
			<li>
~IF［
%V は `CSSMathInvert$I ~objである
］
⇒
~RET %V の `value$m1 内部~slot
◎
If this is a CSSMathInvert object, return this’s value internal slot.
</li>
			<li>
<p>
~IF［
%V は `CSSUnitValue$I ~objである
］~AND［
%V の `unit$m1 内部~slot ~EQ `number^l
］：
◎
If this is a CSSUnitValue object with unit internal slot set to "number":
</p>
				<ol>
					<li>
~IF［
%V の `value$m1 内部~slot ~EQ 0
］
⇒
~THROW `RangeError$E
◎
If this’s value internal slot is set to 0, throw a RangeError.
</li>
					<li>
~RET 次のようにされた新たな `CSSUnitValue$I ~obj
⇒＃
`unit$m1 内部~slot ~SET `number^l
`value$m1 内部~slot ~SET %V の `value$m1 内部~slot の逆数
◎
Else return a new CSSUnitValue with the unit internal slot set to "number", and a value internal slot set to the inverse of this’s.
</li>
				</ol>
			</li>
			<li>
~RET 次のようにされた新たな `CSSMathInvert$I ~obj
⇒
`value$m1 内部~slot ~SET %V
◎
Otherwise, return a new CSSMathInvert object whose value internal slot is set to this.
</li>
		</ol>
	</dd>

	<dt>`min(...values)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The min(...values) method, when called on a CSSNumericValue this, must perform the following steps:
</p>
		<ol>
			<li>
%値~list ~LET 此れは `CSSMathMin$I ~objであるならば 此れの `values$m1 内部~slot／
~ELSE_ « 此れ »
◎
↓</li>
			<li>
%values を成す~EACH( %値 ) に対し
⇒
%値~list に次の結果を`付加する$
⇒
`実数に類する値を規格化する$( %値 )
◎
Replace each item of values with the result of rectifying a numberish value for the item.
◎
If this is a CSSMathMin object, prepend the items in this’s values internal slot to values. Otherwise, prepend this to values.
</li>
			<li>
~IF［
%値~list 内のどの`~item$も `CSSUnitValue$I ~objである
］~AND［
%値~list 内のすべての`~item$の `unit$m1 は互いに同じ %単位 である
］
⇒
~RET 次のようにされた新たな `CSSUnitValue$I ~obj
⇒＃
`unit$m1 内部~slot ~SET %単位<!-- 此れの＊ `unit$m1 内部~slot -->,
`value$m1 内部~slot ~SET { %値~list 内のすべての`~item$の `value$m1 内部~slot値 } の最小
◎
If all of the items in values are CSSUnitValues and have the same unit, return a new CSSUnitValue whose unit internal slot is set to this’s unit internal slot, and value internal slot is set to the minimum of the value internal slots of the items in values.
</li>
			<li>
%型 ~LET `型を加算する$( %値~list 内のすべての`~item$の`型$ )
◎
Let type be the result of adding the types of every item in values.＼
</li>
			<li>
~IF［
%型 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
。
◎
If type is failure, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSMathMin$I ~obj
⇒
`values$m1 内部~slot ~SET %値~list
◎
Return a new CSSMathMin object whose values internal slot is set to values.
</li>
		</ol>
	</dd>

	<dt>`max(...values)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The max(...values) method, when called on a CSSNumericValue this, must perform the following steps:
</p>
		<ol>
			<li>
%値~list ~LET 此れは `CSSMathMax$I ~objであるならば 此れの `values$m1 内部~slot／
~ELSE_ « 此れ »
◎
↓</li>
			<li>
%values を成す~EACH( %値 ) に対し
⇒
%値~list に次の結果を`付加する$
⇒
`実数に類する値を規格化する$( %値 )
◎
Replace each item of values with the result of rectifying a numberish value for the item.
◎
If this is a CSSMathMax object, prepend the items in this’s values internal slot to values. Otherwise, prepend this to values.
</li>
			<li>
~IF［
%値~list 内のどの`~item$も `CSSUnitValue$I ~objである
］~AND［
%値~list 内のすべての`~item$の `unit$m1 は互いに同じ %単位 である
］
⇒
~RET 次のようにされた新たな `CSSUnitValue$I ~obj
⇒＃
`unit$m1 内部~slot ~SET %単位<!-- 此れの＊ `unit$m1 内部~slot -->,
`value$m1 内部~slot ~SET { %値~list 内のすべての`~item$の `value$m1 内部~slot値 } の最大
◎
If all of the items in values are CSSUnitValues and have the same unit, return a new CSSUnitValue whose unit internal slot is set to this’s unit internal slot, and value internal slot is set to the maximum of the value internal slots of the items in values.
</li>
			<li>
%型 ~LET `型を加算する$( %値~list 内のすべての`~item$の`型$ )
◎
Let type be the result of adding the types of every item in values.＼
</li>
			<li>
~IF［
%型 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If type is failure, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSMathMax$I ~obj
⇒
`values$m1 内部~slot ~SET %値~list
◎
Return a new CSSMathMax object whose values internal slot is set to values.
</li>
		</ol>
	</dd>

	<dt>`equals(...values)@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The equals(...values) method, when called on a CSSNumericValue this, must perform the following steps:
</p>
		<ol>
			<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%values を成すどの %値 も次を満たす
⇒
( 此れ, `実数に類する値を規格化する$( %値 ) )
は`等しい数量~値$である
◎
Replace each item of values with the result of rectifying a numberish value for the item.
◎
For each item in values, if the item is not an equal numeric value to this, return false.
◎
Return true.
</li>
		</ol>
	</dd>

	<dd class="algorithm">
<p>
2 つの `CSSNumericValue$I ~obj
( %V1, %V2 )
は、次を走らせた結果が ~T になるならば
`等しい数量~値@
であるとされる：
◎
To determine whether two CSSNumericValues value1 and value2 are equal numeric values, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%V1, %V2 の~interfaceは相異なる
<!-- members of ≠ interface member -->
］
⇒
~RET ~F
◎
If value1 and value2 are not members of the same interface, return false.
</li>
			<li>
<p>
%V1 の~interfaceに応じて：
</p>
				<dl class="switch">
					<dt>`CSSUnitValue$I
◎
If value1 and value2 are both CSSUnitValues,＼
</dt>
					<dd>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
`CSSUnitValue^II
［
%V1 の `unit$m1 内部~slot ~EQ %V2 の `unit$m1 内部~slot
］~AND［
%V1 の `value$m1 内部~slot ~EQ %V2 の `value$m1 内部~slot
］
◎
return true if they have equal unit and value internal slots, or false otherwise.
</dd>

					<dt>`CSSMathSum$I</dt>
					<dt>`CSSMathProduct$I</dt>
					<dt>`CSSMathMin$I</dt>
					<dt>`CSSMathMax$I
◎
If value1 and value2 are both CSSMathSums, CSSMathProducts, CSSMathMins, or CSSMathMaxs:
</dt>
					<dd>
						<ol>
							<li>
%~size ~LET %V1 の `CSSMathSum^II `values$m1 内部~slotの`~size$
◎
↓</li>
							<li>
~IF［
%~size ~NEQ %V2 の `CSSMathSum^II `values$m1 内部~slotの`~size$
］
⇒
~RET ~F
◎
If value1’s values and value2s values internal slots have different sizes, return false.
</li>
							<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
どの %i ~IN { 0 〜 %~size ~MINUS 1 } に対しても
⇒
( %V1 の `values$m1 内部~slot[ %i ], %V2 の `values$m1 内部~slot[ %i ] )
は`等しい数量~値$である
◎
If any item in value1’s values internal slot does not have a corresponding item in value2’s values internal slot that is an equal numeric value, return false
◎
Return true.
</li>
						</ol>
					</dd>

					<dt>`CSSMathNegate$I</dt>
					<dt>`CSSMathInvert$I
◎
Assert: value1 and value2 are both CSSMathNegates or CSSMathInverts.
</dt>
					<dd>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
( %V1 の `CSSMathNegate^II `value$m1, %V2 の `value$m1 )
は`等しい数量~値$である
◎
Return whether value1’s value and value2’s value are equal numeric values.
</dd>
				</dl>
			</li>
		</ol>
	</dd>

	<dt>`to(unit)@m</dt>
	<dd>
この~methodは、可能なら，此れを［
%unit に指定された単位を伴う，別の `CSSNumericValue$I
］に変換する。
◎
The to(unit) method converts an existing CSSNumericValue this into another one with the specified unit, if possible.＼
</dd>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
When called, it must perform the following steps:
</p>
		<ol>
			<li>
%型 ~LET `型を作成する$( %unit )
◎
Let type be the result of creating a type from unit.＼
</li>
			<li>
~IF［
%型 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If type is failure, throw a SyntaxError.
</li>
			<li>
%総和 ~LET `総和~値を作成する$( 此れ )
◎
Let sum be the result of creating a sum value from this.＼
</li>
			<li>
~IF［
%総和 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If sum is failure, throw a TypeError.
</li>
			<li>
~IF［
%総和 の`~size$ ~NEQ 1
］
⇒
~THROW `TypeError$E
◎
If sum has more than one item, throw a TypeError.＼
</li>
			<li>
%単位~値 ~LET `総和~値~itemから単位~値を作成する$( %総和[0] )
◎
Otherwise, let item be the result of creating a CSSUnitValue from the sole item in sum, then＼
</li>
			<li>
%単位~値 ~SET `単位~値を変換する$( %単位~値, %unit )
◎
converting it to unit.＼
</li>
			<li>
~IF［
%単位~値 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If item is failure, throw a TypeError.
</li>
			<li>
~RET %単位~値
◎
Return item.
</li>
		</ol>
	</dd>
	<dd class="algorithm">

<p>
`総和~値~itemから単位~値を作成する@
ときは、所与の
( `総和~値$を成すある~item %~item )
に対し，次を遂行する：
</p>

		<ol>
			<li>
( %~key, %N ) ~LET %~item の`単位~map$を成す`~entry$の個数に応じて
⇒＃
0 個ならば ( `number^l, 1 )
1 個ならば その~entryの ( `~key$map, `値$map ) ／
2 個以上ならば ( ε, ε )
</li>
			<li>
~IF［
%N ~NEQ 1
］
⇒
~RET `失敗^i
</li>
			<li>
~RET 次のようにされた新たな `CSSUnitValue$I ~obj
⇒＃
`unit$m1 内部~slot ~SET %~key,
`value$m1 内部~slot ~SET %~item の`値$sum
</li>
		</ol>

◎
When asked to create a CSSUnitValue from a sum value item item, perform the following steps:
• If item has more than one entry in its unit map, return failure.
• If item has no entries in its unit map, return a new CSSUnitValue whose unit internal slot is set to "number", and whose value internal slot is set to item’s value.
• Otherwise, item has a single entry in its unit map. If that entry’s value is anything other than 1, return failure.
• Otherwise, return a new CSSUnitValue whose unit internal slot is set to that entry’s key, and whose value internal slot is set to item’s value.
</dd>

	<dt>`toSum(...units)@m</dt>
	<dd>
<p>
この~methodは、可能なら此れを［
%units に指定された単位たちのみを伴う，一連の `CSSUnitValue$I
］からなる `CSSMathSum$I に変換する（ `to()$m に似るが、結果~内に複数の単位が~~混在することも許容する）。
%units が省略されて~callされた場合、単に此れを［
此れを成す `CSSUnitValue$I たちの最小限の総和
］に単純化する。
◎
The toSum(...units) method converts an existing CSSNumericValue this into a CSSMathSum of only CSSUnitValues with the specified units, if possible. (It’s like to(), but allows the result to have multiple units in it.) If called without any units, it just simplifies this into a minimal sum of CSSUnitValues.
</p>

<p>
被呼出時には、次を遂行し~MUST：
◎
When called, it must perform the following steps:
</p>
		<ol>
			<li>
%単位~list ~LET %units が成す引数~list
</li>
			<li>
%単位~list 内の~EACH( %単位 ) に対し
⇒
~IF［
`型を作成する$( %単位 ) ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
For each unit in units, if the result of creating a type from unit is failure, throw a SyntaxError.
</li>
			<li>
%総和 ~LET `総和~値を作成する$( 此れ )
◎
Let sum be the result of creating a sum value from this.＼
</li>
			<li>
~IF［
%総和 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If sum is failure, throw a TypeError.
</li>
			<li>
%値~list ~LET %総和 を［
`総和~値~itemから単位~値を作成する$
］`演算で写像する$
◎
Let values be the result of creating a CSSUnitValue for each item in sum.＼
</li>
			<li>
~IF［
`失敗^i ~IN %値~list
］
⇒
~THROW `TypeError$E
◎
If any item of values is failure, throw a TypeError.
</li>
			<li>
<p>
~IF［
%単位~list は`空$である
］：
</p>
				<ol>
					<li>
%値~list を［
その各`~item$の `CSSUnitValue^II `unit$m1 内部~slotの`符号位置$
］順に~sortする
</li>
					<li>
~RET 次のようにされた新たな `CSSMathSum$I ~obj
⇒
`values$m1 内部~slot ~SET %値~list
</li>
				</ol>

◎
If units is empty, sort values in code point order according to the unit internal slot of its items, then return a new CSSMathSum object whose values internal slot is set to values.
</li>
			<li>
%結果~list ~LET 空`~list$
◎
Otherwise, let result initially be an empty list.＼
</li>
			<li>
<p>
%単位~list 内の~EACH( %単位 ) に対し：
◎
For each unit in units:
</p>

				<ol>
					<li>
%合計 ~LET 0
◎
Let temp initially be a new CSSUnitValue whose unit internal slot is set to unit and whose value internal slot is set to 0.
</li>
					<li>
<p>
%値~list 内の~EACH( %値 ) に対し：
◎
For each value in values:
</p>
						<ol>
							<li>
%値の単位 ~LET %値 の`CSSUnitValue^II `unit$m1 内部~slot
◎
Let value unit be value’s unit internal slot.
</li>
							<li>
~IF［
( %値の単位, %単位 )
は`互換~単位$でない
<!-- ＊number の取り扱いは？ -->
］
⇒
~CONTINUE
◎
If value unit is a compatible unit with unit, then:
</li>
							<li>
%合計 ~INCBY %値 の `value$m1 内部~slotの値 ~MUL ( %値の単位 から %単位 への換算率 )
<!-- ＊
単位~値を変換する$( 値, 単位 ) を簡素化
 -->
◎
convert value to unit.
◎
Increment temp’s value internal slot by the value of value’s value internal slot.
</li>
							<li>
%値~list から %値 を`除去する$
◎
Remove value from values.
</li>
						</ol>
					</li>
					<li>
%結果~list に 次のようにされた新たな `CSSUnitValue$I ~objを`付加する$
⇒＃
`unit$m1 内部~slot ~SET %単位,
`value$m1 内部~slot ~SET %合計
◎
Append temp to result.
</li>
				</ol>
			</li>
			<li>
~IF［
%値~list は空でない
］
⇒
~THROW `TypeError$E
<span class="note">
渡されたどの単位にも互換でない単位の値が，此れ内にある。
</span>
◎
If values is not empty, throw a TypeError. this had units that you didn’t ask for.
</li>
			<li>
~RET 次のようにされた新たな `CSSMathSum$I ~obj
⇒
`values$m1 内部~slot ~SET %結果~list
◎
Return a new CSSMathSum object whose values internal slot is set to result.
</li>
		</ol>
	</dd>

	<dt>`type()@m</dt>
	<dd>
この~methodは、此れの`型$の表現を返す。
◎
The type() method returns a representation of the type of this.
</dd>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
When called, it must perform the following steps:
</p>

		<ol>
			<li>
%結果 ~LET 新たな `CSSNumericType$I 辞書
◎
Let result be a new CSSNumericType.
</li>
			<li>
此れの`型$を成す ~EACH( %基底~型 → %累乗数 ) に対し
⇒
~IF［
%累乗数 ~NEQ 0
］
⇒
%結果[ %基底~型 ] ~SET %累乗数
◎
For each baseType → power in the type of this,
• If power is not 0, set result[baseType] to power.
</li>
			<li>
~IF［
此れの`型$の`百分率hint$ ~NEQ ~NULL
］
⇒
%結果 の `percentHint$m1 ~SET 此れの`型$の`百分率hint$
◎
If the percent hint of this is not null,
• Set percentHint to the percent hint of this.
</li>
			<li>
~RET %結果
◎
Return result.
</li>
		</ol>
	</dd>
</dl>


<p>
`総和~値@
は、何個かの単位~付きの実数の総和により，
`CSSNumericValue$I を抽象的に表現する（単位は、場合によっては複合的になる）。
が、`総和~値$で表現できない `CSSNumericValue$I もある。
◎
A sum value is an abstract representation of a CSSNumericValue as a sum of numbers with (possibly complex) units. Not all CSSNumericValues can be expressed as a sum value.
</p>

<div class="p">
<p>
`総和~値$は`~list$であり、その各~itemは，
(
`値@sum,
`単位~map@
)
が成す`~tuple$である：
</p>
<ul>
	<li>
`値$sumは、実数を与える。
</li>
	<li>
`単位~map$は、`有順序~map$であり，［
単位を与える文字列
］を［
累乗数を与える整数
］に対応付ける。
</li>
</ul>

◎
A sum value is a list. Each entry in the list is a tuple of a value, which is a number, and a unit map, which is a map of units (strings) to powers (integers).
</div>

<div class="example">

<p>
~CSS値と それに等価な`総和~値$の例：
</p>

<table><thead><tr><th>~CSS値
<th>`総和~値$（備考）
</thead><tbody id="_x_sum_values">

<tr><td>`1px^v
<td>« (1, «[`px^l → 1]») »

<tr><td>`calc(1px + 1in)^v
<td>« (97, «[`px^l → 1]») »
<br>（`in$u , `px$u は`互換~単位$であり， `px$u はそれらの`正準的~単位$なので。）

<tr><td>`calc(1px + 2em)^v
<td>« (1, «[`px^l → 1]»), (2, «[`em^l → 1]») »

<tr><td>`calc(1px + 2%)^v
<td>« (1, «[`px^l → 1]»), (2, «[`percent^l → 1]») »
<br>（百分率は、他の単位に加算するのは許容されるが，`型$内の単位の様に別の単位に解決されることはない。）

<tr><td>`calc(1px * 2em)^v
<td>« (2, «[`em^l → 1, `px^l → 1]») »

<tr><td>`calc(1px + 1deg)^v
<td>（算出は妥当でないので`総和~値$として表現できない。）

<tr><td>`calc(1px * 2deg)^v
<td>« (2, «[`deg^l → 1, `px^l → 1]») »

</tbody></table>


◎
Here are a few examples of CSS values, and their equivalent sum values:
• 1px becomes «(1, «["px" → 1]»)»
• calc(1px + 1in) becomes «(97, «["px" → 1]»)» (because in and px are compatible units, and px is the canonical unit for them)
• calc(1px + 2em) becomes «(1, «["px" → 1]»), (2, «["em" → 1]»)»
• calc(1px + 2%) becomes «(1, «["px" → 1]»), (2, «["percent" → 1]»)» (percentages are allowed to add to other units, but aren’t resolved into another unit, like they are in a type)
• calc(1px * 2em) becomes «(2, «["em" → 1, "px" → 1]»)»
• calc(1px + 1deg) can’t be represented as a sum value because it’s an invalid computation
• calc(1px * 2deg) becomes «(2, «["deg" → 1, "px" → 1]»)»
</div>

<div class="algorithm">

<p>
所与の `CSSNumericValue$I %N から
`総和~値を作成する@
ときは、 %N の~classに応じて：
◎
To create a sum value from a CSSNumericValue this, the steps differ based on this’s class:
</p>

<dl class="switch">
	<dt>`CSSUnitValue$I</dt>
	<dd>
		<ol>
			<li>
%単位 ~LET %N の `unit$m1 内部~slotの値
◎
Let unit be the value of this’s unit internal slot, and＼
</li>
			<li>
%値 ~LET %N の `value$m1 内部~slotの値
◎
value be the value of this’s value internal slot.
</li>
			<li>
~IF［
%単位 ~EQ `number^l
］
⇒
~RET  « ( %値, «[ ]» ) »
◎
↓</li>
			<li>
~IF［
%単位 はある`正準的~単位$ %U の`互換~単位$である
］
⇒＃
%値 ~SET %値 ~MUL ( %単位 から %U への換算率 )；
%単位 ~SET %U 【を表現する文字列】
◎
If unit is a member of a set of compatible units, and is not the set’s canonical unit, multiply value by the conversion ratio between unit and the canonical unit, and change unit to the canonical unit.
</li>
			<li>
~RET « (%値, «[%単位 → 1]») »
◎
If unit is "number", return «(value, «[ ]»)».
◎
Otherwise, return «(value, «[unit → 1]»)».
</li>
		</ol>
	</dd>

	<dt>`CSSMathSum$I</dt>
	<dd>
		<ol>
			<li>
%値~list ~LET 空~list
◎
Let values initially be an empty list.
</li>
			<li>
<p>
%N の `values$m1 内部~slot内の~EACH( %~item ) に対し：
◎
For each item in this’s values internal slot:
</p>
				<ol>
					<li>
%値 ~LET `総和~値を作成する$( %~item )
◎
Let value be the result of creating a sum value from item.＼
</li>
					<li>
~IF［
%値 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If value is failure, return failure.
</li>
					<li>
<p>
%値 を成す~EACH( %下位-値 ) に対し：
◎
For each subvalue of value:
</p>

						<ol>
							<li>
~IF［
%値~list 内にある`~item$ %~item があって，［
%~item, %下位-値
］の`単位~map$は互いに一致する
<!-- ＊一致するの定義 -->
］
⇒
%~item の`値$sum ~INCBY %下位-値 の`値$sum
◎
If values already contains an item with the same unit map as subvalue, increment that item’s value by the value of subvalue.
</li>
							<li>
~ELSE
⇒
%値~list に %下位-値 を`付加する$
◎
Otherwise, append subvalue to values.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%型~list ~LET %値~list を［
`単位~mapから型を作成する$
］`演算で写像する$
◎
Create a type from the unit map of each item of values, and＼
</li>
			<li>
~IF［
`型を加算する$( %型~list を成すすべての型 ) ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
add all the types together.＼
◎
If the result is failure, return failure.
</li>
			<li>
~RET %値~list
◎
Return values.
</li>
		</ol>
	</dd>

	<dt>`CSSMathNegate$I</dt>
	<dd>
		<ol>
			<li>
%値~list ~LET `総和~値を作成する$( %N の `value$m1 内部~slot )
◎
Let values be the result of creating a sum value from this’s value internal slot.
</li>
			<li>
~IF［
%値~list ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If values is failure, return failure.
</li>
			<li>
%値~list 内の~EACH( `~item$ ) に対し
⇒
~itemの`値$sumを反数にする
◎
Negate the value of each item of values.
</li>
			<li>
~RET %値~list
◎
Return values.
</li>
		</ol>
	</dd>

	<dt>`CSSMathProduct$I</dt>
	<dd>
		<ol>
			<li>
%値~list ~LET `総和~値$ «(1, «[ ]»)»
（すなわち， `1^v から取得されるもの）
◎
Let values initially be the sum value «(1, «[ ]»)». (I.e. what you’d get from 1.)
</li>
			<li>
<p>
%N の `values$m1 内部~slot内の~EACH( %~item ) に対し：
◎
For each item in this’s values internal slot:
</p>

				<ol>
					<li>
%新-値~list ~LET `総和~値を作成する$( %~item )
◎
Let new values be the result of creating a sum value from item.＼
</li>
					<li>
%一時~list ~LET 空`~list$
◎
Let temp initially be an empty list.
</li>
					<li>
~IF［
%新-値~list ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If new values is failure, return failure.
</li>
					<li>
<p>
%値~list 内の~EACH( %~item ) に対し
⇒
%新-値~list 内の~EACH( %新~item ) に対し
⇒
%一時~list に次に与える`~tuple$を付加する：
</p>
								<ul>
									<li>
`値$sum ~SET %~item の`値$sum ~MUL %新~item の`値$sum
</li>
									<li>
`単位~map$ ~SET ［
`単位~mapの積をとる$( %~item の`単位~map$, %新~item の`単位~map$ )
］の結果から， 0 を値にとる`~entry$はすべて除去した結果
</li>
								</ul>
◎
For each item1 in values:
• For each item2 in new values:
•• Let item be a tuple with its value set to the product of the values of item1 and item2, and its unit map set to the product of the unit maps of item1 and item2, with all entries with a zero value removed.
•• Append item to temp.
</li>
					<li>
%値~list ~SET %一時~list
◎
Set values to temp.
</li>
				</ol>
			</li>
			<li>
~RET %値~list
◎
Return values.
</li>
		</ol>
	</dd>

	<dt>`CSSMathInvert$I</dt>
	<dd>
		<ol>
			<li>
%値~list ~LET `総和~値を作成する$( %N の `value$m1 内部~slot )
◎
Let values be the result of creating a sum value from this’s value internal slot.
</li>
			<li>
~IF［
%値~list ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If values is failure, return failure.
</li>
			<li>
~IF［
`値$sum の`~size$ ~GT 1
］
⇒
~RET `失敗^i
◎
If the length of values is more than one, return failure.
</li>
			<li>
<p>
%値~list 内の ~EACH( %~item ) に対し：
</p>
				<ol>
					<li>
%~item の`値$sum ~SET その逆数（乗法逆元を見出す）
</li>
					<li>
%~item の`単位~map$内の ~EACH( %~entry ) に対し
⇒
%~entry の`値$map ~SET その反数（加法逆元を見出す）
</li>
				</ol>

◎
Invert (find the reciprocal of) the value of the item in values, and negate the value of each entry in its unit map.
</li>
			<li>
~RET %値~list
◎
Return values.
</li>
		</ol>
	</dd>

	<dt>`CSSMathMin$I</dt>
	<dt>`CSSMathMax$I</dt>
	<dd>
		<ol>
			<li>
%総和~値~list ~LET %N の `values$m1 内部~slotを［
`総和~値を作成する$
］`演算で写像する$
◎
Let args be the result of creating a sum value for each item in this’s values internal slot.
</li>
			<li>
~IF［
`失敗^i ~IN %総和~値~list
］~OR［
ある`総和~値$ ~IN %総和~値~list があって，その`~size$ ~GT 1
］
⇒
~RET `失敗^i
◎
If any item of args is failure, or has a length greater than one, return failure.
</li>
			<li>
%~item~list ~LET %総和~値~list を［
%~item に対し， %~item[0] を得る
］`演算で写像する$
◎
↓</li>
			<li>
~IF［
%~item~list 内に ある 2 つの~itemがあって，それらの`単位~map$は互いに一致しない
<!-- ＊一致するの定義 -->
］
⇒
~RET `失敗^i
◎
If not all of the unit maps among the items of args are identical, return failure.
</li>
			<li>
%値~list ~LET %~item~list を［
~itemの`値$sumを得る
］`演算で写像する$
◎
↓</li>
			<li>
%N の~classに応じて
⇒＃
`CSSMathMin$I ならば %値~list 内の最も小さい値 ／
`CSSMathMax$I ならば %値~list 内の最も大きい値
◎
Return the item of args whose sole item has the smallest value.
◎
CSSMathMax
◎
Let args be the result of creating a sum value for each item in this’s values internal slot.
◎
If any item of args is failure, or has a length greater than one, return failure.
◎
If not all of the unit maps among the items of args are identical, return failure.
◎
Return the item of args whose sole item has the largest value.
</li>
		</ol>
	</dd>
</dl>

</div>

<div class="algorithm">

<p>
`単位~mapから型を作成する@
ときは、所与の
( %単位~map )
に対し：
◎
To create a type from a unit map unit map:
</p>

<ol>
	<li>
%型~list ~LET 空`~list$
◎
Let types be an initially empty list.
</li>
	<li>
<p>
%単位~map 内の~EACH( %単位 → %累乗数 ) に対し：
◎
For each unit → power in unit map:
</p>
		<ol>
			<li>
%型 ~LET `型を作成する$( %単位 )
◎
Let type be the result of creating a type from unit.
</li>
			<li>
%型 を成す唯一の~entry<!-- ＊ -->の`値$map ~SET %累乗数
◎
Set type’s sole value to power.
</li>
			<li>
%型~list に %型 を`付加する$
◎
Append type to types.
</li>
		</ol>
	</li>
	<li>
~RET `型を乗算する$( %型~list を成すすべての`~item$ )
◎
Return the result of multiplying all the items of types.
</li>
</ol>

</div>

<div class="algorithm">

<p>
`単位~mapの積をとる@
ときは、所与の
( `単位~map$ %U, `単位~map$ %V )
に対し，次を走らす：
◎
The product of two unit maps units1 and units2 is the result given by the following steps:
</p>

<ol>
	<li>
%結果 ~LET  %U の複製
◎
Let result be a copy of units1.
</li>
	<li>
<p>
%V 内の ~EACH( %単位 → %累乗数 ) に対し：
◎
For each unit → power in units2:
</p>

		<ol>
			<li>
~IF［
%結果[ %単位 ] ~NEQ ε
］
⇒
%結果[ %単位 ] ~INCBY %累乗数
◎
If result[unit] exists, increment result[unit] by power.
</li>
			<li>
~ELSE
⇒
%結果[ %単位 ] ~SET %累乗数
◎
Otherwise, set result[unit] to power.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<dl class="idl-def">
	<dt>`parse(cssText)@m</dt>
	<dd>
<p>
この静的~methodは、~CSSを包含している文字列から直接的に `CSSNumericValue$I を構築-可能にする。
◎
The parse() method allows a CSSNumericValue to be constructed directly from a string containing CSS. Note that this is a static method, existing directly on the CSSNumericValue interface object, rather than on CSSNumericValue instances.
</dd>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The parse(cssText) method, when called, must perform the following steps:
</p>

<ol>
	<li>
%結果 ~LET `成分~値を構文解析する$( %cssText )
◎
Parse a component value from cssText and let result be the result.＼
</li>
	<li>
~IF［
%結果 ~EQ 構文~error
］
⇒
~THROW `SyntaxError$E
◎
If result is a syntax error, throw a SyntaxError and abort this algorithm.
</li>
	<li>
~IF［
%結果 は ［
`number-token$t,
`percentage-token$t,
`dimension-token$t,
`~math関数$
］のいずれかである
］
⇒
~RET `数量~値を正規化する$( %結果 )
◎
If result is not a &lt;number-token&gt;, &lt;percentage-token&gt;, &lt;dimension-token&gt;, or a math function, throw a SyntaxError and abort this algorithm.
◎
Normalize a numeric value result, and return the result.
</li>
	<li>
~THROW `SyntaxError$E
◎
↑</li>
		</ol>
	</dd>
</dl>



			</section>
			<section id="numeric-typing">
<h4 title="Numeric Value Typing">4.3.2. 数量~値の型~付け</h4>

<div class="p">
<p>
各 `CSSNumericValue$I ~objには、
`型@
が結付けられる：
</p>

<ul>
	<li>
`型$は、各`基底~型$を整数に対応付ける`有順序~map$である。
</li>
	<li>
次に挙げるものが
`基底~型@
とされる
⇒＃
`length^l,
`angle^l,
`time^l,
`frequency^l,
`resolution^l,
`flex^l,
`percent^l
</li>
	<li>
<p>
`型$は、常に，次の拘束を満たす
⇒
どの`基底~型$ %基底~型 に対しても
⇒
`型$[ %基底~型 ] ~NEQ ε
</p>

<p class="trans-note">【
この拘束は、この訳による追加である。
原文の`型$は，初期~時は空とされているが、あらゆる箇所で，所与の
( `型$ %型, `基底~型$ %~key )
に対する 2 つの条件［
%型[ %~key ] ~EQ ε （ %~key を`~key$とする`~entry$は無い）
］, ［
%型[ %~key ] ~EQ 0
］は 常に同じに扱われるので、前者を後者に統合して，他所の条件分岐を簡略化している。
それに伴い，新たな`型$の~instanceは、常に，この拘束を満たすように作成される
— `型を作成する$~algoを通して, または既存の`型$を複製して。
】</p>
	</li>
	<li>
`型$を成す~entryたちの順序は、常に，上に挙げた`基底~型$の順序に従うとする。
</li>
	<li>
<p>
各`型$には、
`百分率hint@
も結付けられる。
それは、［
~NULL または `percent^l 以外の`基底~型$
］のいずれかをとり，他が指定されない限り ~NULL をとる。
</p>

<p class="trans-note">【
この仕様は、どの`型$ %型 に対しても，次の不変則：［
%型 の`百分率hint$ ~EQ ~NULL
］~OR［
%型[ `percent^l ] ~EQ 0 
］を保ち続ける。
この訳では、この不変則も利用して，原文の［
`型を加算する$／`型を乗算する$
］~algoを論理的に単純化している（入力の`型$がこの不変則を満たさない場合の結果は、原文の~algoと異なり得る（原文も，この不変則を念頭に記されているように見受けられるが））。
】</p>
	</li>
</ul>

◎
Each CSSNumericValue has an associated type, which is a map of base types to integers, and an associated percent hint. The base types are "length", "angle", "time", "frequency", "resolution", "flex", and "percent". The ordering of a type’s entries always matches this base type ordering. The percent hint is either null or a base type other than "percent".
</div>

<div class="algorithm">

<p>
`型を作成する@
ときは、所与の
( 文字列 %単位 （省略時は `number^l ） )
に対し，次を遂行する：
◎
To create a type from a string unit, follow the appropriate branch of the following:
</p>

<ol>
	<li>
<p>
%単位 ~LET 下の表の左列に挙げる分類のうち， %単位 が該当する行の右列に与える値
</p>

<table><tbody>
<tr><td>`number^l
<td>ε
<tr><td>`percent^l
<td>`percent^l
<tr><td>`length$t 単位
 <td>`length^l
<tr><td>`angle$t 単位
 <td>`angle^l
<tr><td>`time$t 単位
 <td>`time^l
<tr><td>`frequency$t 単位
 <td>`frequency^l
<tr><td>`resolution$t 単位
 <td>`resolution^l
<tr><td>`flex$t 単位
<td>`flex^l
<tr><td>その他
<td>`失敗^i
</tbody></table>

◎
unit is "number"
• Return «[ ]» (empty map)
◎
unit is "percent"
• Return «[ "percent" → 1 ]»
◎
unit is a &lt;length&gt; unit
• Return «[ "length" → 1 ]»
◎
unit is an &lt;angle&gt; unit
• Return «[ "angle" → 1 ]»
◎
unit is a &lt;time&gt; unit
• Return «[ "time" → 1 ]»
◎
unit is a &lt;frequency&gt; unit
• Return «[ "frequency" → 1 ]»
◎
unit is a &lt;resolution&gt; unit
• Return «[ "resolution" → 1 ]»
◎
unit is a &lt;flex&gt; unit
• Return «[ "flex" → 1 ]»
</li>
	<li>
~IF［
%単位 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
anything else
• Return failure.
</li>
	<li>
%型 ~LET 新たな`有順序~map$<!-- «[ ]» -->
</li>
	<li>
<p>
~EACH( `基底~型$ %基底~型 ) に対し，`基底~型$に挙げた順に
⇒
%型[ %基底~型 ] ~SET 0
</p>

<p class="trans-note">【
この段は、この訳による`型$の定義に対する改変に伴い，追加している。
】</p>

	</li>
	<li>
~IF［
%単位 ~NEQ ε
］
⇒
%型[ %単位 ] ~SET 1
</li>
	<li>
%型 の`百分率hint$ ~SET ~NULL
◎
In all cases, the associated percent hint is null.
</li>
	<li>
~RET %型
</li>
</ol>

</div>

<div class="algorithm">

<p>
`型を加算する@
ときは、所与の
( `型$ %型/1, `型$ %型/2 )
に対し，次を遂行する：
◎
To add two types type1 and type2, perform the following steps:
</p>

<p class="trans-note">【
入力は 3 個以上与えられ得る（この節の末尾の注記を見よ）。
】【
ここでは、`百分率hint$にて述べた不変則も利用して，原文の~algoを単純化している。
】</p>

<ol>
	<li>
%~hint ~LET %型/1 の`百分率hint$
◎
↓</li>
	<li>
~IF［
%~hint ~NEQ ~NULL
］
⇒
~IF［
%型/2 の`百分率hint$ ~NIN { ~NULL, %~hint }
］
⇒
~RET `失敗^i
— %型/1, %型/2 は加算できない
◎
Replace type1 with a fresh copy of type1, and type2 with a fresh copy of type2. Let finalType be a new type with an initially empty ordered map and an initially null percent hint.
◎
If both type1 and type2 have non-null percent hints with different values
• The types can’t be added. Return failure.
</li>
	<li>
~ELSE
⇒
%~hint ~SET %型/2 の`百分率hint$
◎
↓</li>
	<li>
<p>
~IF［
%~hint ~NEQ ~NULL
］
⇒
~IF［
%型/1, %型/2 は %~hint に関して`同値である^i
］
⇒
~GOTO `成功^i
</p>

<p>
ここで、［
%~hint に関して`同値である^i
］とは、次がいずれも満たされることを意味する：
</p>
		<ul>
			<li>
どの`基底~型$ %~key ~NIN { `percent^l, %~hint } に対しても
⇒
%型/1[ %~key ] ~EQ %型/2[ %~key ]
</li>
			<li>
%型/1[ `percent^l ] ~PLUS %型/1[ %~hint ] ~EQ
%型/2[ `percent^l ] ~PLUS %型/2[ %~hint ]
</li>
		</ul>

◎
If type1 has a non-null percent hint hint and type2 doesn’t
• Apply the percent hint hint to type2.
• Vice versa if type2 has a non-null percent hint and type1 doesn’t.
◎
Otherwise
• Continue to the next step.
◎
If all the entries of type1 with non-zero values are contained in type2 with the same value, and vice-versa
• Copy all of type1’s entries to finalType, and then copy all of type2’s entries to finalType that finalType doesn’t already contain. Set finalType’s percent hint to type1’s percent hint. Return finalType.
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
~IF［
どの`基底~型$ %~key に対しても， %型/1[ %~key ] ~EQ %型/2[ %~key ]
］
⇒
~GOTO `成功^i
</li>
			<li>
~IF［
ある `percent^l 以外の`基底~型$ %~hint/3 があって，
%型/1, %型/2 は %~hint/3 に関して`同値である^i
］
⇒＃
%~hint ~SET %~hint/3 （該当する %~hint/3 は、一意に定まる）；
~GOTO `成功^i
</li>
		</ol>
◎
If type1 and/or type2 contain "percent" with a non-zero value, and type1 and/or type2 contain a key other than "percent" with a non-zero value
• For each base type other than "percent" hint:
•• Provisionally apply the percent hint hint to both type1 and type2.
•• If, afterwards, all the entries of type1 with non-zero values are contained in type2 with the same value, and vice versa, then copy all of type1’s entries to finalType, and then copy all of type2’s entries to finalType that finalType doesn’t already contain. Set finalType’s percent hint to hint. Return finalType.
•• Otherwise, revert type1 and type2 to their state at the start of this loop.
• If the loop finishes without returning finalType, then the types can’t be added. Return failure.
• Note: You can shortcut this in some cases by just checking the sum of all the values of type1 vs type2. If the sums are different, the types can’t be added.
</li>
	<li>
~RET `失敗^i
— %型/1, %型/2 は加算できない
◎
Otherwise
• The types can’t be added. Return failure.
</li>
	<li>
<p>
`成功^i：
</p>
		<ol>
			<li>
%型 ~SET %型/1 の複製
</li>
			<li>
~IF［
%~hint ~NEQ ~NULL
］
⇒
%型 に`百分率hintを適用する$( %~hint )
</li>
			<li>
~RET %型
</li>
		</ol>
◎
↑</li>
</ol>

</div>

<div class="algorithm">

<p>
`型$ %型 に
`百分率hintを適用する@
ときは、所与の
( `基底~型$ %~hint )
に対し，次を遂行する：
◎
To apply the percent hint hint to a type, perform the following steps:
</p>

<ol>
	<li>
%型[ %~hint ] ~INCBY %型[`percent^l ]
◎
If type doesn’t contain hint, set type[hint] to 0.
◎
If type contains "percent", add type["percent"] to type[hint], then＼
</li>
	<li>
%型[`percent^l ] ~SET 0
◎
set type["percent"] to 0.
</li>
	<li>
%型 の`百分率hint$ ~SET %~hint
◎
Set type’s percent hint to hint.
</li>
</ol>
</div>

<div class="algorithm">

<p>
`型を乗算する@
ときは、所与の
( `型$ %型/1, `型$ %型/2 )
に対し，次を遂行する：
◎
To multiply two types type1 and type2, perform the following steps:
</p>

<p class="trans-note">【
入力は 3 個以上与えられ得る（この節の末尾の注記を見よ）。
】【
ここでは、`百分率hint$にて述べた不変則も利用して，原文の~algoを単純化している。
】</p>

<ol>
	<li>
%型 ~LET `型を作成する$()
◎
Replace type1 with a fresh copy of type1, and type2 with a fresh copy of type2. Let finalType be a new type with an initially empty ordered map and an initially null percent hint.
</li>
	<li>
%~hint ~LET %型/1 の`百分率hint$
</li>
	<li>
~IF［
%~hint ~NEQ ~NULL
］
⇒
~IF［
%型/2 の`百分率hint$ ~NIN { ~NULL, %~hint }
］
⇒
~RET `失敗^i
— %型/1, %型/2 は乗算できない
◎
If both type1 and type2 have non-null percent hints with different values, the types can’t be multiplied. Return failure.
</li>
	<li>
~ELSE
⇒
%~hint ~SET %型/2 の`百分率hint$
◎
If type1 has a non-null percent hint hint and type2 doesn’t, apply the percent hint hint to type2.
◎
Vice versa if type2 has a non-null percent hint and type1 doesn’t.
</li>
	<li>
~EACH( `基底~型$ %基底~型 ) に対し
⇒
%型[ %~key ] ~SET %型/1[ %基底~型 ] ~PLUS %型/2[ %基底~型 ]
◎
Copy all of type1’s entries to finalType, then for each baseType → power of type2:
• If finalType[baseType] exists, increment its value by power.
• Otherwise, set finalType[baseType] to power.
</li>
	<li>
~IF［
%~hint ~NEQ ~NULL
］
⇒
%型 に`百分率hintを適用する$( %~hint )
◎
Set finalType’s percent hint to type1’s percent hint.
</li>
	<li>
~RET %型
◎
Return finalType.
</li>
</ol>

</div>

<p>
所与の`型$ %型 が所与の~CSS生成規則に
`合致-@
するかどうかは，次に従って定義される：
◎
A type is said to match a CSS production in some circumstances:
</p>

<ul>
	<li>
<p>
この定義の目的においては、
%型 の
`純~単位@
とは、次をいずれも満たす %単位 が［
在るならばそれ ／
無いならば ε
］とする：
</p>
		<ul>
			<li>
［
%単位 ~EQ `number^l
］~OR［［
%単位 は`基底~型$である
］~AND［
%型[ %単位 ] ~EQ 1
］］
</li>
			<li>
どの`基底~型$ %~key も，次を満たす
⇒
［
%~key ~EQ %単位 
］~OR［
%型[ %~key ] ~EQ 0
］
</li>
		</ul>
<p class="trans-note">【
この定義は、以下を簡潔に述べるため，この訳に導入している。
%型 は、`純~単位$に応じて［
`number^l ならば無次元量（単位なし） ／
`percentage^l ならば何らかの単位に相対的な一次元量 ／
他の非 ε 値ならば単位 %単位 の一次元量 ／
ε ならば多重次元量
］を表す。
】</p>

	</li>

	<li>
<p>
%型 は次を満たすならば
`length$t に`合致-$するとされる
⇒
［
`純~単位$ ~EQ `length^l
］~AND［
`百分率hint$ ~EQ ~NULL
］
</p>

<p>
`angle$t,
`time$t,
`frequency$t,
`resolution$t,
`flex$t
に対しても，同様に定義される。
</p>
◎
A type matches &lt;length&gt; if its only non-zero entry is «[ "length" → 1 ]» and its percent hint is null. Similarly for &lt;angle&gt;, &lt;time&gt;, &lt;frequency&gt;, &lt;resolution&gt;, and &lt;flex&gt;.
</li>
	<li>
%型 は次を満たすならば
`percentage$t に`合致-$するとされる
⇒
`純~単位$ ~EQ `percentage^l
◎
A type matches &lt;percentage&gt; if its only non-zero entry is «[ "percent" → 1 ]».
</li>
	<li>
<p>
%型 は次を満たすならば
`length-percentage$t に`合致-$するとされる
⇒
`純~単位$ ~IN { `length^l, `percentage^l }
</p>

<p>
`angle-percentage$t,
`time-percentage$t,
等々に対しても，同様に定義される。
</p>

◎
A type matches &lt;length-percentage&gt; if its only non-zero entry is either «[ "length" → 1 ]» or «[ "percentage" → 1 ]» Same for &lt;angle-percentage&gt;, &lt;time-percentage&gt;, etc.
</li>
	<li>
<p>
%型 は次を満たすならば
`number$t に`合致-$するとされる
⇒
［
`純~単位$ ~EQ `number^l
］~AND［
`百分率hint$ ~EQ ~NULL
］
◎
A type matches &lt;number&gt; if it has no non-zero entries and its percent hint is null.
</li>
	<li>
<p>
%型 は次を満たすならば
`number-percentage$t に`合致-$するとされる
⇒
`純~単位$ ~IN { `number^l, `percentage^l }
◎
A type matches &lt;number-percentage&gt; if it has no non-zero entries, or its only non-zero entry is «[ "percentage" → 1 ]».
</li>
</ul>

<p>
仕様には、文法において
`length-percentage$t の代わりに
<span class="prod">[`length$t | `percentage$t]</span>
を利用して，注釈文にて
`length$t と `percentage$t を組合せれるものと指定しているものも多い。
照合の目的においては、これらの事例は `length-percentage$t として扱われるべきである。
`angle-percentage$t, 等々に対しても同様に扱われるべきである。
◎
Many specifications use ''[ &lt;length&gt; | &lt;percentage&gt; ]'' instead of ''&lt;length-percentage&gt;'' in their grammar, and specify in prose that the &lt;length&gt; and &lt;percentage&gt; can be combined. For the purposes of matching, these cases should be treated as &lt;length-percentage&gt;. Similarly for &lt;angle-percentage&gt;, etc.
</p>


<p class="note">注記：
`型$の集合は、加算の下で半群（ `semi-group^en ）を形成し，乗算の下で単位元を有する半群（ `monoid^en ）を形成する（
<!-- 
`百分率hint$に~NULLを伴う «[ ]»
-->
`型を作成する$() の結果が乗法的~単位元を与える）。
すなわち、それらは結合的, かつ可換である。
したがって仕様は、何個でも一義的に`型を加算する$ことができる
— 一度に 2 個ずつ`型を加算する$よう記すことに代えて。
◎
Note: Types form a semi-group under both addition and a monoid under multiplication (with the multiplicative identity being «[ ]» with a null percent hint), meaning that they’re associative and commutative. Thus the spec can, for example, add an unbounded number of types together unambiguously, rather than having to manually add them pair-wise.
</p>

			</section>
			<section id="simple-numeric">
<h4 title="Value + Unit: CSSUnitValue objects">4.3.3. 単位~付きの値： `CSSUnitValue^I ~obj</h4>

<p>
単独の単位として表せる数量~値（あるいは裸の実数／百分率）は `CSSUnitValue$I として表現される。
◎
Numeric values that can be expressed as a single unit (or a naked number or percentage) are represented as CSSUnitValues.
</p>

<div class="example">

<p>
例えば~stylesheet内の値 `5px^v は、次のようにされた `CSSUnitValue$I により表現される
⇒＃
`value^m 属性 ~SET 5,
`unit^m 属性 ~SET `px^l
◎
For example, the value 5px in a stylesheet will be represented by a CSSUnitValue with its value attribute set to 5 and its unit attribute set to "px".
</p>
<p>
類似的に,
~stylesheet内の値 `10^v は、次のようにされた `CSSUnitValue$I により表現される
⇒＃
`value^m 属性 ~SET 10,
`unit^m 属性 ~SET `number^l
◎
Similarly, the value 10 in a stylesheet will be represented by a CSSUnitValue with its value attribute set to 10 and its unit attribute set to "number".
</p>
</div>


<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSUnitValue$C(double %value, DOMString %unit)]
interface `CSSUnitValue@I : `CSSNumericValue$I {
    attribute double `value@m;
    readonly attribute DOMString `unit@m;
};
</pre>

<dl class="idl-def">
	<dt>`CSSUnitValue(value, unit)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSUnitValue(value, unit) constructor must, when called, perform the following steps:
</p>
		<ol>
			<li>
~IF［
`型を作成する$( %unit ) ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If creating a type from unit returns failure, throw a TypeError and abort this algorithm.
</li>
			<li>
~RET 次のようにされた新たな `CSSUnitValue$I
⇒＃
`value$m 内部~slot ~SET %値,
`unit$m ~SET %単位
◎
Return a new CSSUnitValue with its value internal slot set to value and its unit set to unit.
</li>
		</ol>
	</dd>
</dl>

<div class="algorithm">

<p>
<dfn id="type-of-a-cssunitvalue">`CSSUnitValue$I %V の`型$</dfn>
は、次の結果になる
⇒
`型を作成する$( %V の `unit$m 内部~slot )
◎
The type of a CSSUnitValue is the result of creating a type from its unit internal slot.
</p>
</div>

<div class="algorithm">

<p>
`~CSSUnitValueを作成する@
ときは、所与の
( %実数, %単位 )
に対し，次のようにされた新たな `CSSUnitValue$I ~objを返す
⇒＃
`value$m 内部~slot ~SET %実数,
`unit$m 内部~slot ~SET %単位
◎
To create a CSSUnitValue from a pair (num, unit), return a new CSSUnitValue object with its value internal slot set to num, and its unit internal slot set to unit.
</p>
</div>

<p class="example">
例えば、次の結果は `new CSSUnitValue(5, "px")^c の結果と等価な~objになる
⇒
`~CSSUnitValueを作成する$( 5, `px^l )
◎
For example, creating a CSSUnitValue from (5, "px") creates an object equivalent to new CSSUnitValue(5, "px").
</p>

<p class="note">注記：
これは、仕様~内部の~algoであり、単純に，必要なときに単位~付きの値を容易に作成するためにある。
◎
Note: This is a spec-internal algorithm, meant simply to make it easier to create unit values in algorithms when needed.
</p>


<div class="algorithm">

<p>
`単位~値を変換する@
ときは、所与の
( `CSSUnitValue$I ~obj %単位~値, 単位 %単位 )
に対し，次を遂行する：
◎
To convert a CSSUnitValue this to a unit unit, perform the following steps:
</p>

<ol>
	<li>
%旧-単位 ~LET %単位~値 の `unit$m 内部~slotの値
◎
Let old unit be the value of this’s unit internal slot,＼
</li>
	<li>
%旧-値 ~LET %単位~値 の `value$m 内部~slotの値
◎
and old value be the value of this’s value internal slot.
</li>
	<li>
~IF［
( %旧-単位, %単位 )
は`互換~単位$でない
］
⇒
~RET `失敗^i
◎
If old unit and unit are not compatible units, return failure.
</li>
	<li>
~RET 次のようにされた新たな `CSSUnitValue$I ~obj
⇒＃
`unit$m 内部~slot ~SET %単位,
`value$m 内部~slot ~SET %旧-値 ~MUL ( %旧-単位 から %単位 への換算率 )
◎
Return a new CSSUnitValue whose unit internal slot is set to unit, and whose value internal slot is set to old value multiplied by the conversation ratio between old unit and unit.
</li>
</ol>
</div>



			</section>
			<section id="complex-numeric">
<h4 title="Complex Numeric Values: CSSMathValue objects">4.3.4. 複合的な数量~値： `CSSMathValue^I ~obj</h4>


<p>
単独の ( 値, 単位 ) 組より複雑な数量~値は，
`CSSMathValue$I 下位classたちが成す木により表現され、その各~~末端~nodeは `CSSUnitValue$I ~objになる。
~CSSにおける`~math関数$（ `calc$f, `min$f, `max$f ）は、この仕方で表現される。
◎
Numeric values that are more complicated than a single value+unit are represented by a tree of CSSMathValue subclasses, eventually terminating in CSSUnitValue objects at the leaf nodes. The calc(), min(), and max() functions in CSS are represented in this way.
</p>

<div class="example">

<p>
例えば~CSS値
`calc(1em + 5px)^v
は、
`CSSMathSum(CSS.em(1), CSS.px(5))^c
の様に，
`CSSMathSum$I により表現されることになる。
◎
For example, the CSS value calc(1em + 5px) will be represented by a CSSMathSum like CSSMathSum(CSS.em(1), CSS.px(5)).
</p>
<p>
`calc(1em + 5px * 2)^v の様な複合的な式は、
`CSSMathSum(CSS.em(1), CSSMathProduct(CSS.px(5), 2))^c
の様な入子の構造により表現されることになる。
◎
A more complex expression, like calc(1em + 5px * 2), will be represented by a nested structure like CSSMathSum(CSS.em(1), CSSMathProduct(CSS.px(5), 2)).
</p>
</div>


<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
interface `CSSMathValue@I : `CSSNumericValue$I {
    readonly attribute `CSSMathOperator$I `operator$m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSMathSum$C(`CSSNumberish$I... %args)]
interface `CSSMathSum@I : `CSSMathValue$I {
    readonly attribute `CSSNumericArray$I `values@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSMathProduct$C(`CSSNumberish$I... %args)]
interface `CSSMathProduct@I : `CSSMathValue$I {
    readonly attribute `CSSNumericArray$I `values@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSMathNegate$C(`CSSNumberish$I %arg)]
interface `CSSMathNegate@I : `CSSMathValue$I {
    readonly attribute `CSSNumericValue$I `value@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSMathInvert$C(`CSSNumberish$I %arg)]
interface `CSSMathInvert@I : `CSSMathValue$I {
    readonly attribute `CSSNumericValue$I `value@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSMathMin$C(`CSSNumberish$I... %args)]
interface `CSSMathMin@I : `CSSMathValue$I {
    readonly attribute `CSSNumericArray$I `values@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSMathMax$C(`CSSNumberish$I... %args)]
interface `CSSMathMax@I : `CSSMathValue$I {
    readonly attribute `CSSNumericArray$I `values@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
interface `CSSNumericArray@I {
    iterable&lt;`CSSNumericValue$I&gt;;
    readonly attribute unsigned long `length$m;
    `getter$m `CSSNumericValue$I (unsigned long %index);
};

enum `CSSMathOperator@I {
    "`sum@m",
    "`product@m",
    "`negate@m",
    "`invert@m",
    "`min@m",
    "`max@m",
};
</pre>

<p class="note">注記：
`CSSMathValue$I は、純粋な上位classであり，直接的には構築できない。
それは，もっぱら、すべての “~math” 演算に共通する属性を~hostするためにある。
◎
Note: CSSMathValue, being a pure superclass, cannot be directly constructed. It exists solely to host the common attributes of all the "math" operations.
</p>


<dl class="idl-def">
	<dt>`CSSMathValue^II `operator@m1</dt>
	<dd>
<p>
取得子は、此れの~interfaceに応じて，次の表の右列に与える文字列（
`CSSMathOperator$I 列挙~値
）を返さ~MUST：
</p>

<table><thead><tr><th>~interface
<th>結果
</thead><tbody>

<tr><td>`CSSMathSum$I
<td>`sum^l

<tr><td>`CSSMathProduct$I
<td>`product^l

<tr><td>`CSSMathMin$I
<td>`min^l

<tr><td>`CSSMathMax$I
<td>`max^l

<tr><td>`CSSMathNegate$I
<td>`negate^l

<tr><td>`CSSMathInvert$I
<td>`invert^l

</tbody></table>

◎
The operator attribute of a CSSMathValue this must, on getting, return the following string, depending on the interface of this:
◎
CSSMathSum
• "sum"
CSSMathProduct
• "product"
CSSMathMin
• "min"
CSSMathMax
• "max"
CSSMathNegate
• "negate"
CSSMathInvert
• "invert"
◎
Note: These are all instances of the CSSMathOperator enum.
</dd>

	<dt>`CSSMathSum(...args)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSMathSum(...args) constructor must, when called, perform the following steps:
</p>
		<ol>
			<li>
%args ~SET %args が成す~listを［
`実数に類する値を規格化する$
］`演算で写像する$
◎
Replace each item of args with the result of rectifying a numberish value for the item.
</li>
			<li>
~IF［
%args は`空$である
］
⇒
~THROW `SyntaxError$E
◎
If args is empty, throw a SyntaxError.
</li>
			<li>
%型 ~LET `型を加算する$( %args を成すすべての`~item$の`型$ )
◎
Let type be the result of adding the types of all the items of args.＼
</li>
			<li>
~IF［
%型 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If type is failure, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSMathSum$I ~obj
⇒
`values$m1 内部~slot ~SET %args
◎
Return a new CSSMathSum whose values internal slot is set to args.
</li>
</ol>

</dd>

	<dt>`CSSMathMin(...args)@mC</dt>
	<dt>`CSSMathMax(...args)@mC</dt>
	<dd>
これらの構築子は、次を除いて `CSSMathSum()$mC と同じに定義される
⇒
最後の段においては、順に，新たな［
`CSSMathMin$I, `CSSMathMax$I
］~objを返す
◎
The CSSMathMin(...args) and CSSMathMax(...args) constructors are defined identically to the above, except that in the last step they return a new CSSMathMin or CSSMathMax object, respectively.
</dd>

	<dt>`CSSMathProduct(...args)@mC</dt>
	<dd>
この構築子は、次を除いて `CSSMathSum()$mC と同じに定義される
⇒＃
3 番目の段においては，`型を加算する$に代えて`型を乗算する$を用いる, および
最後の段においては `CSSMathProduct$I ~objを返す
◎
The CSSMathProduct(...args) constructor is defined identically to the above, except that in step 3 it multiplies the types instead of adding, and in the last step it returns a CSSMathProduct.
</dd>

	<dt>`CSSMathNegate(arg)@mC</dt>
	<dd>
この構築子の被呼出時には、次のようにされた新たな `CSSMathNegate$I ~objを返さ~MUST
⇒
`value$m1 内部~slot ~SET `実数に類する値を規格化する$( %arg )
◎
The CSSMathNegate(arg) constructor must, when called, perform the following steps:
• Replace arg with the result of rectifying a numberish value for arg.
• Return a new CSSMathNegate whose value internal slot is set to arg.
</dd>

	<dt>`CSSMathInvert(arg)@mC</dt>
	<dd>
この構築子の被呼出時には、次のようにされた新たな `CSSMathInvert$I ~objを返さ~MUST
⇒
`value$m1 内部~slot ~SET `実数に類する値を規格化する$( %arg )
◎
The CSSMathInvert(arg) constructor is defined identically to the above, except that in the last step it returns a new CSSMathInvert object.
</dd>
</dl>

<p>
<dfn id="type-of-a-cssmathvalue">`CSSMathValue$I %M の`型$</dfn>
は、
%M の~classに応じて，次で与えられる：
◎
The type of a CSSMathValue depends on its class:
</p>

<dl class="switch">
	<dt>`CSSMathSum$I</dt>
	<dd>
`型を加算する$( %M の `values$m1 内部~slot内の各`~item$の`型$ )
</dd>

	<dt>`CSSMathMin$I</dt>
	<dd>
`型を加算する$( %M の `values$m1 内部~slot内の各`~item$の`型$ )
</dd>

	<dt>`CSSMathMax$I</dt>
	<dd>
`型を加算する$( %M の `values$m1 内部~slot内の各`~item$の`型$ )
◎
The type is the result of adding the types of each of the items in its values internal slot.
</dd>

	<dt>`CSSMathProduct$I</dt>
	<dd>
`型を乗算する$( %M の `values$m1 内部~slot内の各`~item$の`型$ )
◎
The type is the result of multiplying the types of each of the items in its values internal slot.
</dd>

	<dt>`CSSMathNegate$I</dt>
	<dd>
%M の `value$m1 内部~slotの`型$
◎
The type is the same as the type of its value internal slot.
</dd>

	<dt>`CSSMathInvert$I</dt>
	<dd>
%M の `value$m1 内部~slotの`型$を，それを成すすべての~entryの`値$mapを反数にした結果。
◎
The type is the same as the type of its value internal slot, but with all values negated.
</dd>
</dl>

<p>
`CSSNumericArray^I0 の：
<!-- ＊ -->
◎
↓</p>

<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
この属性は、此れが包含する `CSSNumericValue$I の個数を指示する。
◎
The length attribute of CSSNumericArray indicates how many CSSNumericValues are contained within the CSSNumericArray.
</dd>

	<dt>`getter@m</dt>
	<dd>
供された~indexにある `CSSNumericValue$I を検索取得する。
◎
The indexed getter of CSSNumericArray retrieves the CSSNumericValue at the provided index.
</dd>
</dl>


			</section>
			<section id="numeric-factory">
<h4 title="Numeric Factory Functions">4.3.5. 数量~factory関数</h4>


<p>
次の~factory関数を利用すれば、
構築子を直に用いるより，ずっと簡潔に新たな数量~値を作成できる。
◎
The following factory functions can be used to create new numeric values much less verbosely than using the constructors directly.
</p>


<pre class="idl">
partial namespace `CSS^I0 {
    `CSSUnitValue$I `number@m(double %value);
    `CSSUnitValue$I `percent@m(double %value);

    // `length^t
    `CSSUnitValue$I `em@m(double %value);
    `CSSUnitValue$I `ex@m(double %value);
    `CSSUnitValue$I `ch@m(double %value);
    `CSSUnitValue$I `ic@m(double %value);
    `CSSUnitValue$I `rem@m(double %value);
    `CSSUnitValue$I `lh@m(double %value);
    `CSSUnitValue$I `rlh@m(double %value);
    `CSSUnitValue$I `vw@m(double %value);
    `CSSUnitValue$I `vh@m(double %value);
    `CSSUnitValue$I `vi@m(double %value);
    `CSSUnitValue$I `vb@m(double %value);
    `CSSUnitValue$I `vmin@m(double %value);
    `CSSUnitValue$I `vmax@m(double %value);
    `CSSUnitValue$I `cm@m(double %value);
    `CSSUnitValue$I `mm@m(double %value);
    `CSSUnitValue$I `Q@m(double %value);
    `CSSUnitValue$I `in@m(double %value);
    `CSSUnitValue$I `pt@m(double %value);
    `CSSUnitValue$I `pc@m(double %value);
    `CSSUnitValue$I `px@m(double %value);

    // `angle^t
    `CSSUnitValue$I `deg@m(double %value);
    `CSSUnitValue$I `grad@m(double %value);
    `CSSUnitValue$I `rad@m(double %value);
    `CSSUnitValue$I `turn@m(double %value);

    // `time^t
    `CSSUnitValue$I `s@m(double %value);
    `CSSUnitValue$I `ms@m(double %value);

    // `frequency^t
    `CSSUnitValue$I `Hz@m(double %value);
    `CSSUnitValue$I `kHz@m(double %value);

    // `resolution^t
    `CSSUnitValue$I `dpi@m(double %value);
    `CSSUnitValue$I `dpcm@m(double %value);
    `CSSUnitValue$I `dppx@m(double %value);

    // `flex^t
    `CSSUnitValue$I `fr@m(double %value);
};
</pre>

<div class="algorithm">

<p class="idl-def">
上に定義されたどの名前 %N （ `number^l, `px^l, 等々）の~methodも，所与の
( %value )
を渡して~callされたときは、次のようにされた新たな `CSSUnitValue$I ~objを返さ~MUST
⇒＃
`value$m1 内部~slot ~SET %value,
`unit$m1 内部~slot ~SET %N
◎
All of the above methods must, when called with a double value, return a new CSSUnitValue whose value internal slot is set to value and whose unit internal slot is set to the name of the method as defined here.
◎
Note: The unit used does not depend on the current name of the function, if it’s stored in another variable; let foo = CSS.px; let val = foo(5); does not return a {value: 5, unit: "foo"} CSSUnitValue. The above talk about names is just a shorthand to avoid defining the unit individually for all ~20 functions.
</p>

</div>

<div class="example">

<p>
例えば，新たな `CSSPositionValue$I を作成するときは、次の様な~codeに代えて：
◎
For example, rather than creating a new CSSPositionValue with code like:
</p>

<pre class="lang-js">
let %pos = new CSSPositionValue(
    new CSSUnitValue(5, "px"),
    new CSSUnitValue(10, "px")
);
</pre>

<p>
次の様に書ける：
◎
One can instead write:
</p>


<pre class="lang-js">
let pos = new CSSPositionValue(CSS.px(5), CSS.px(10));
</pre>
</div>



			</section>
		</section>
		<section id="transformvalue-objects">
<h3 title="CSSTransformValue objects">4.4. `CSSTransformValue^I ~obj</h3>


<p>
`CSSTransformValue$I ~objは、
`transform$p ~propに利用される
`transform-list$t 値を表現する。
それら 
個々の `transform-function$t 値を表現する
1 個~以上の `CSSTransformComponent$I を “包含する”。
◎
CSSTransformValue objects represent &lt;transform-list&gt; values, used by the transform property. They "contain" one or more CSSTransformComponents, which represent individual &lt;transform-function&gt; values.
</p>


<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSTransformValue$C(sequence&lt;`CSSTransformComponent$I&gt; %transforms)]
interface `CSSTransformValue@I : `CSSStyleValue$I {
    iterable&lt;`CSSTransformComponent$I&gt;;
    readonly attribute unsigned long `length$m;
    `getter$m `CSSTransformComponent$I (unsigned long %index);
    `setter$m `CSSTransformComponent$I (unsigned long %index, `CSSTransformComponent$I %val);

    readonly attribute boolean `is2D$m;
    `DOMMatrix$I `toMatrix$m();
};
</pre>

<p>
各 `CSSTransformValue$I には、反復する値たち
【<a href="~WEBAIDL#idl-iterable">参照</a>】
として，
`変形~成分~list@
が結付けられる。
それは、 `CSSTransformComponent$I ~objの`~list$である。
◎
A CSSTransformValue’s values to iterate over is a list of CSSTransformComponents.
</p>

<dl class="idl-def">
	<dt>`CSSTransformValue(transforms)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSTransformValue(transforms) constructor must, when called, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%transforms は空である
］
⇒
~THROW `TypeError$E
◎
If transforms is empty, throw a TypeError.
</li>
			<li>
次のようにされた新たな `CSSTransformValue$I
⇒
`変形~成分~list$ ~SET %transforms に等価な同順の`~list$
◎
Return a new CSSTransformValue whose values to iterate over is transforms.
</li>
		</ol>
	</dd>

	<dt>`is2D@m</dt>
	<dd>
取得子は、此れの`変形~成分~list$内に次を満たす~itemが［
在るならば ~F ／
無いならば ~T
］を返さ~MUST
⇒
~itemの `~TCis2D$m 属性 ~EQ ~F
◎
The is2D attribute of a CSSTransformValue this must, on getting, return true if, for each func in this’s values to iterate over, the func’s is2D attribute would return true; otherwise, the attribute returns false.
</dd>

	<dt>`toMatrix()@m</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The toMatrix() method of a CSSTransformValue this must, when called, perform the following steps:
</p>


		<ol>
			<li>
%行列 ~LET 単位行列で初期化された新たな `DOMMatrix$I
◎
Let matrix be a new DOMMatrix, initialized to the identity matrix,＼
</li>
			<li>
%行列 の`~is2D$ ~SET ~T
◎
with its is2D internal slot set to true.
</li>
			<li>
<p>
此れの`変形~成分~list$内の~EACH( %関数 ) に対し：
◎
For each func in this’s values to iterate over:
</p>

				<ol>
					<li>
%行列 ~SET %行列 に［
次を~callした結果の `DOMMatrix$I で表現される行列
］を右から乗算した結果
⇒
`CSSTransformComponent^II `toMatrix(%func)$m1
◎
Let funcMatrix be the DOMMatrix returned by calling toMatrix() on func.
◎
Set matrix to the result of multiplying matrix and the matrix represented by funcMatrix.
</li>
				</ol>
			</li>
			<li>
~RET %行列
◎
Return matrix.
</li>
		</ol>
	</dd>

	<dt>`length@m</dt>
	<dt>`getter@m</dt>
	<dt>`setter@m</dt>
	<dd>
これらのふるまい（
`被support~prop~index$,
`有index取得子$,
`有index設定子$
）は、此れの `変形~成分~list$ に基づくとする。
◎
The length attribute indicates how many transform components are contained within the CSSTransformValue.
◎
The indexed getter retrieves the transform component at the provided index.
</dd>
</dl>

<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
interface `CSSTransformComponent@I {
    `stringifier@m;
    attribute boolean `is2D$m;
    `DOMMatrix$I `toMatrix$m();
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSTranslate$C(`CSSNumericValue$I %x, `CSSNumericValue$I %y, optional `CSSNumericValue$I %z)]
interface `CSSTranslate@I : `CSSTransformComponent$I {
    attribute `CSSNumericValue$I `x@m;
    attribute `CSSNumericValue$I `y@m;
    attribute `CSSNumericValue$I `z@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSRotate$C(`CSSNumericValue$I %angle),
 <a href="#dom-cssrotate-cssrotate-x-y-z-angle">Constructor</a>(`CSSNumberish$I %x, `CSSNumberish$I %y, `CSSNumberish$I %z, `CSSNumericValue$I %angle)]
interface `CSSRotate@I : `CSSTransformComponent$I {
    attribute `CSSNumberish$I `x$m;
    attribute `CSSNumberish$I `y$m;
    attribute `CSSNumberish$I `z$m;
    attribute `CSSNumericValue$I `angle@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSScale$C(`CSSNumberish$I %x, `CSSNumberish$I %y, optional `CSSNumberish$I %z)]
interface `CSSScale@I : `CSSTransformComponent$I {
    attribute `CSSNumberish$I `x$m;
    attribute `CSSNumberish$I `y$m;
    attribute `CSSNumberish$I `z$m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSSkew$C(`CSSNumericValue$I %ax, `CSSNumericValue$I %ay)]
interface `CSSSkew@I : `CSSTransformComponent$I {
    attribute `CSSNumericValue$I `ax@m;
    attribute `CSSNumericValue$I `ay@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSSkewX$C(`CSSNumericValue$I %ax)]
interface `CSSSkewX@I : `CSSTransformComponent$I {
    attribute `CSSNumericValue$I `ax@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSSkewY$C(`CSSNumericValue$I %ay)]
interface `CSSSkewY@I : `CSSTransformComponent$I {
    attribute `CSSNumericValue$I `ay@m;
};

/* <span class="comment">
`skew(x,y)^css が表現する変形は、
`skewX(x) skewY(y)^css と<em>同じではない</em>ことに注意。
よって、~interfaceも別々にされている。
◎
Note that skew(x,y) is *not* the same as skewX(x) skewY(y), thus the separate interfaces for all three.
</span> */

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSPerspective$C(`CSSNumericValue$I %length)]
interface `CSSPerspective@I : `CSSTransformComponent$I {
    attribute `CSSNumericValue$I `length@m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSMatrixComponent$C(`DOMMatrixReadOnly$I %matrix, optional `CSSMatrixComponentOptions$I %options)]
interface `CSSMatrixComponent@I : `CSSTransformComponent$I {
    attribute `DOMMatrix$I `matrix@m;
};

dictionary `CSSMatrixComponentOptions@I {
    boolean `is2D@m = false;
};
</pre>


<dl class="idl-def">
	<dt>`~TCis2D@m</dt>
	<dd>
この属性は、変形が~2D, ~3Dのどちらなのかを指示する。
~T のときは、変形の属性のうち~3D変形に関連するもの（ `CSSTranslate^II `z$m1 属性など）による，此れが表現する変形に対する効果はなくなる。
◎
The is2D attribute indicates whether the transform is 2D or 3D. When it’s true, the attributes of the transform that are relevant to 3D transforms (such as the CSSTranslate.z attribute) simply have no effect on the transform they represent.
</dd>
	<dd class="note">注記：
これは~objの直列化, および
~objに “等価な 4×4 行列” などの概念に影響する。
◎
Note: This affects the serialization of the object, and concepts such as the object’s "equivalent 4x4 matrix".
</dd>
	<dd>
<p>
次に挙げる~obj上の，この属性の設定子は、何もしては~MUST_NOT：
</p>
		<ul>
			<li id="dom-cssskewy-is2d">
`CSSSkew$I,
`CSSSkewX$I,
`CSSSkewY$I
</li>
			<li id="dom-cssperspective-is2d">
`CSSPerspective$I
</li>
		</ul>

【編集の都合により、ここの記述は、原文から移動している。】

<p class="note">注記：
［
`skew$f ／ `skewX$f ／ `skewY$f
］関数は常に~2D変形を表現する。
`perspective$f 関数は常に~3D変形を表現する。
</p>

◎
↓↓</dd>
	<dd>
<details class="note">
<summary>
`~TCis2D$m の設計~上の考慮点
◎
is2D Design Considerations
</summary>

<p>
旧来の理由から，~2D変形と~3D変形は、効果は互いに一致していても，別個とされる。
`translateZ(0px)^v による変形は単位行列になると定義されていようが，~UAが当の要素~用に何らかの~3D基づく最適化を作動化する点で，頁~上に観測-可能な効果がある。
◎
For legacy reasons, 2D and 3D transforms are distinct, even if they have identical effects; a translateZ(0px) has observable effects on a page, even tho it’s defined to be an identity transform, as the UA activates some 3D-based optimizations for the element.
</p>

<p>
これを反映する仕方にはいくつかある
— ~3Dに関係する属性を `nullable^c にする ／
~2D, ~3D ~interfaceを別々に分ける,
等々 —
が、現在の設計（作者が切り替えて挙動を規定できる）を選んでいるわけは、ほとんどの状況下において，作者が ~2D, ~3Dのどっちかか気を配る必要なく 変形に対し演算-可能にしつつ、~2D変形が “不用意に切り替えられて” ~3Dになるのも防ぐためである。
◎
There were several possible ways to reflect this—nullable 3D-related attributes, separate 2D and 3D interfaces, etc—but we chose the current design (an author-flippable switch that dictates the behavior) because it allows authors to, in most circumstances, operate on transforms without having to care whether they’re 2D or 3D, but also prevents "accidentally" flipping a 2D transform into becoming 3D.
</p>
</details>

	</dd>

	<dt>`CSSTransformComponent^II `toMatrix()@m1</dt>
	<dd>
<p>
被呼出時には、次を遂行し~MUST：
◎
The toMatrix() method of a CSSTransformComponent this must, when called, perform the following steps:
</p>
		<ol>
			<li>
<p>
%M ~LET 次のように初期化された，新たな `DOMMatrix$I ~obj：
◎
Let matrix be a new DOMMatrix object, initialized to＼
</p>
				<ul>
					<li>
%M は［
`CSS-TRANSFORMS-1$r の
<a href="~TRANSFORM#mathematical-description">変形~関数の数学的~記述</a>
【または <a href="~TRANSFORM2#mathematical-description">~3D変形~関数の数学的~記述</a>】
］に定義される，此れに等価な変形~行列を表現する
◎
this’s equivalent 4x4 transform matrix, as defined in CSS Transforms 1 §15 Mathematical Description of Transform Functions, and＼
</li>
					<li>
<p>
%M の`~is2D$ ~SET 此れの `~TCis2D$m 内部~slotと同じ値
◎
with its is2D internal slot set to the same value as this’s is2D internal slot.
</p>

<p class="note">注記：
`~TCis2D$m は、 `CSSTransformComponent$I が表現する変形が［
何になるか，したがって等価な行列は何になるか
］に影響することに~~留意されたし。
◎
Note: Recall that the is2D flag affects what transform, and thus what equivalent matrix, a CSSTransformComponent represents.
</p>

					</li>
				</ul>
			</li>
			<li>
~IF［
前~段にて行列を生成するときに孕まれる `length$t に `px$u と`互換~単位$でないもの（`相対~長さ$や `percentage$t など）がある
］
⇒
~THROW `TypeError$E
— そのような行列を成す各~~成分は、 `px$u 単位に相対的に定義されるので。
◎
As the entries of such a matrix are defined relative to the px unit, if any &lt;length&gt;s in this involved in generating the matrix are not compatible units with px (such as relative lengths or percentages), throw a TypeError.
</li>
			<li>
~RET %M
◎
Return matrix.
</li>
		</ol>
	</dd>

	<dt>`CSSTranslate(x, y, z)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSTranslate(x, y, z) constructor must, when invoked, perform the following steps:
</p>
		<ol>
			<li>
%is2D ~LET ~F
◎
↓</li>
			<li>
~IF［
%z は与えられていない
］
⇒＃
%z ~SET `~CSSUnitValueを作成する$( 0, `px^l )；
%is2D ~SET ~T
◎
↓</li>
			<li>
~IF［
%x, %y いずれかは `length-percentage$t に`合致-$しない
］~OR［
%z は`length$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If x or y don’t match &lt;length-percentage&gt;, throw a TypeError.
◎
If z was passed, but doesn’t match &lt;length&gt;, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSTranslate$I ~obj,
⇒＃
`x$m1 内部~slot ~SET %x,
`y$m1 内部~slot ~SET %y,
`z$m1 内部~slot ~SET %z,
`~TCis2D$m 内部~slot ~SET %is2D
◎
Let this be a new CSSTranslate object, with its x and y internal slots set to x and y.
◎
If z was passed, set this’s z internal slot to z, and set this’s is2D internal slot to false.
◎
If z was not passed, set this’s z internal slot to new unit value of (0, "px"), and set this’s is2D internal slot to true.
◎
Return this.
</li>
		</ol>
	</dd>

<!-- ＊CSSTranslate^I0
	<dt>x@m</dt>
	<dt>y@m</dt>
	<dt>z@m</dt>
 -->


	<dt>`CSSRotate(angle)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSRotate(angle) constructor must, when invoked, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%angle は `angle$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If angle doesn’t match &lt;angle&gt;, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSRotate$I ~obj
⇒＃
`angle$m1 内部~slot ~SET %angle
`x$m1 内部~slot ~SET `~CSSUnitValueを作成する$( 0, `number^l ),
`y$m1 内部~slot ~SET `~CSSUnitValueを作成する$( 0, `number^l ),
`z$m1 内部~slot ~SET `~CSSUnitValueを作成する$( 1, `number^l ),
`~TCis2D$m 内部~slot ~SET ~T
◎
Return a new CSSRotate with its angle internal slot set to angle, its x and y internal slots set to new unit values of (0, "number"), its z internal slot set to a new unit value of (1, "number"), and its is2D internal slot set to true.
</li>
		</ol>
	</dd>

<!-- ＊ -->
	<dt id="dom-cssrotate-cssrotate-x-y-z-angle">`CSSRotate(x, y, z, angle )^m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSRotate(x, y, z, angle) constructor must, when invoked, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%angle は `angle$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If angle doesn’t match &lt;angle&gt;, throw a TypeError.
</li>
			<li>
%x ~SET `実数に類する値を規格化する$( %x )
◎
↓</li>
			<li>
%y ~SET `実数に類する値を規格化する$( %y )
◎
↓</li>
			<li>
%z ~SET `実数に類する値を規格化する$( %z )
◎
Let x, y, and z be replaced by the result of rectifying a numberish value.
</li>
			<li>
~IF［
%x, %y, %z
のいずれかは `number$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If x, y, or z don’t match &lt;number&gt;, throw a TypeError.
</li>
	<li>
~RET 次のようにされた新たな `CSSRotate$I ~obj
⇒＃
`angle$m1 内部~slot ~SET %angle,
`x$m1 内部~slot ~SET %x,
`y$m1 内部~slot ~SET %y,
`z$m1 内部~slot ~SET %z,
`~TCis2D$m 内部~slot ~SET ~F
◎
Return a new CSSRotate with its angle internal slot set to angle, its x, y, z internal slots set to x, y, and z, and its is2D internal slot set to false.
</li>
		</ol>
	</dd>

<!-- `CSSRotate^I0 -->
	<dt>`x@m</dt>
	<dt>`y@m</dt>
	<dt>`z@m</dt>
	<dd>
これらの属性の設定子は、次を走らせ~MUST
⇒
当の属性に対応する内部~slot ~SET `実数に類する値を規格化する$( 所与の値 )
◎
The x, y, and z attributes must, on setting to a new value val, rectify a numberish value from val and set the corresponding internal slot to the result of that.
</dd>

	<dt>`CSSScale(x, y, z)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSScale(x, y, z) constructor must, when invoked, perform the following steps:
</p>
		<ol>
			<li>
%is2D ~LET ~F
◎
↓</li>
			<li>
~IF［
%z は与えられていない
］
⇒＃
%z ~SET `~CSSUnitValueを作成する$( 1, `number^l )；
%is2D ~SET ~T
◎
↓</li>
			<li>
%x ~SET `実数に類する値を規格化する$( %x )
◎
↓</li>
			<li>
%y ~SET `実数に類する値を規格化する$( %y )
◎
↓</li>
			<li>
%z ~SET `実数に類する値を規格化する$( %z )
◎
Let x, y, and z (if passed) be replaced by the result of rectifying a numberish value.
</li>
			<li>
~IF［
%x, %y, %z
のいずれかは `number$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If x, y, or z (if passed) don’t match &lt;number&gt;, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSScale$I ~obj
⇒＃
`x$m1 内部~slot ~SET %x,
`y$m1 内部~slot ~SET %y
`z$m1 内部~slot ~SET %z,
`~TCis2D$m 内部~slot ~SET %is2D
◎
Let this be a new CSSScale object, with its x and y internal slots set to x and y.
◎
If z was passed, set this’s z internal slot to z, and set this’s is2D internal slot to false.
◎
If z was not passed, set this’s z internal slot to a new unit value of (1, "number"), and set this’s is2D internal slot to true.
◎
Return this.
</li>
		</ol>
	</dd>

<!-- `CSSScale^I0 -->
	<dt>`x@m</dt>
	<dt>`y@m</dt>
	<dt>`z@m</dt>
	<dd>
これらの属性の設定子は、次を走らせ~MUST
⇒
当の属性に対応する内部~slot ~SET `実数に類する値を規格化する$( 所与の値 )
◎
The x, y, and z attributes must, on setting to a new value val, rectify a numberish value from val and set the corresponding internal slot to the result of that.
</dd>

	<dt>`CSSSkew(ax, ay)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSSkew(ax, ay) constructor must, when invoked, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%ax, %ay
のいずれかは `angle$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If ax or ay do not match &lt;angle&gt;, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSSkew$I ~obj
⇒＃
`ax$m1 内部~slot ~SET %ax,
`ay$m1 内部~slot ~SET %ay,
`~TCis2D$m 内部~slot ~SET ~T
◎
Return a new CSSSkew object with its ax and ay internal slots set to ax and ay, and its is2D internal slot set to true.
</li>
		</ol>
	</dd>

	<dt>`CSSSkewX(ax)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSSkewX(ax) constructor must, when invoked, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%ax は `angle$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If ax does not match &lt;angle&gt;, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSSkewX$I ~obj
⇒＃
`ax$m1 内部~slot ~SET %ax,
`~TCis2D$m 内部~slot ~SET ~T
◎
Return a new CSSSkewX object with its ax internal slot set to ax, and its is2D internal slot set to true.
</li>
		</ol>
	</dd>

	<dt>`CSSSkewY(ay)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSSkewY(ay) constructor must, when invoked, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%ay は `angle$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If ay does not match &lt;angle&gt;, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSSkewY$I ~obj
⇒＃
`ay$m1 内部~slot ~SET %ay,
`~TCis2D$m 内部~slot ~SET ~T
◎
Return a new CSSSkewY object with its ay internal slot set to ay, and its is2D internal slot set to true.
</li>
		</ol>
	</dd>

	<dd>
◎
↑↑The is2D attribute of a CSSSkew, CSSSkewX, or CSSSkewY object must, on setting, do nothing. 
◎
↑↑Note: skew(), skewX(), and skewY() functions always represent 2D transforms.
</dd>

	<dt>`CSSPerspective(length)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSPerspective(length) constructor must, when invoked, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%length は `length$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If length does not match &lt;length&gt;, throw a TypeError.
</li>
			<li>
~RET 次のようにされた新たな `CSSPerspective$I ~obj
⇒＃
`length$m1 内部~slot ~SET %length,
`~TCis2D$m 内部~slot ~SET ~F
◎
Return a new CSSPerspective object with its length internal slot set to length, and its is2D internal slot set to false.
</li>
		</ol>
	</dd>

	<dd>
◎
↑↑The is2D attribute of a CSSPerspective object must, on setting, do nothing.
◎
↑↑Note: perspective() functions always represent 3D transforms.
</dd>

	<dt>`CSSMatrixComponent(matrix, options)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
</p>
		<ol>
			<li>
%is2D ~LET %matrix の`~is2D$
</li>
			<li>
~IF［
%options は与えられている
］
⇒
%is2D ~SET %options の `CSSMatrixComponentOptions^II `is2D$m1 ~member
</li>
			<li>
~RET 次のようにされた新たな `CSSMatrixComponent$I ~obj
⇒＃
`matrix$m1 内部~slot ~SET %matrix,
`~TCis2D$m 内部~slot ~SET %is2D
</li>
		</ol>
◎
The CSSMatrixComponent(matrix, options) constructor must, when invoked, perform the following steps:
◎
Let this be a new CSSMatrixComponent object with its matrix internal slot set to matrix.
◎
If options was passed, set this’s is2D internal slot to the options’s is2D member.
◎
Otherwise, set this’s is2D internal slot to the value of matrix’s is2D internal slot.
◎
Return this.
</dd>
</dl>

<div class="note">

<p>注記：
`CSSTransformComponent$I ~objに対応する下層の変形~関数は、いくつもあり得る。
例えば `CSSTranslate$I ~objは、
( `x$m1, `y$m1, `z$m1 )
値に
( `10px^v, `0px^v, `0px^v )
を伴うならば，次のいずれも表現し得る
⇒＃
`translate(10px)^v ／
`translate(10px, 0)^v ／
`translateX(10px)^v ／
`translate3d(10px, 0, 0)^v
◎
Each CSSTransformComponent can correspond to one of a number of underlying transform functions. For example, a CSSTranslate with an x value of 10px and y &amp; z values of 0px could represent any of the following:
• translate(10px)
• translate(10px, 0)
• translateX(10px)
• translate3d(10px, 0, 0)
</p>

<p>
しかしながら，文字列化されるときは、その `~TCis2D$m 内部~slotに応じて，常に次を~~出力することになる
⇒＃
~T ならば `translate(10px, 0px)^v ／
~F ならば `translate3d(10px, 0px, 0px)^v
◎
When stringified, however, it will always print out either translate(10px, 0px) or translate3d(10px, 0px, 0px), depending on whether its is2D internal slot is true or false, respectively.
</p>
</div>



		</section>
		<section id="positionvalue-objects">
<h3 title="CSSPositionValue objects">4.5. `CSSPositionValue^I ~obj</h3>


<p>
`CSSPositionValue$I ~objは、
`object-position$p などの~propに利用される
`position$t 値を表現する。
◎
CSSPositionValue objects represent &lt;position&gt; values, used by properties such as object-position.
</p>


<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSPositionValue$C(`CSSNumericValue$I %x, `CSSNumericValue$I %y)]
interface `CSSPositionValue@I : `CSSStyleValue$I {
    attribute `CSSNumericValue$I `x$m;
    attribute `CSSNumericValue$I `y$m;
};
</pre>


<p>
［
`x$m ／ `y$m
］属性は、容器の［
左端 ／ 上端
］辺からの~offsetを表す。
◎
The x attribute expresses the offset from the left edge of the container. y expresses the offset from the top edge of the container.
</p>

<dl class="idl-def">
	<dt>`CSSPositionValue(x, y)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSPositionValue(x, y) constructor must, when called, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%x, %y
のいずれかは `length-percentage$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If x or y doesn’t match &lt;length-percentage&gt;, throw a TypeError.
</li>
	<li>
~RET 次のようにされた新たな `CSSPositionValue$I ~obj
⇒＃
`x$m 内部~slot ~SET %x,
`y$m 内部~slot ~SET %y
◎
Otherwise, return a new CSSPositionValue whose x internal slot is set to x, and whose y internal slot is set to y.
</li>
		</ol>
	</dd>

	<dt>`x@m</dt>
	<dd>
<p>
設定子は、次を遂行し~MUST：
◎
The x and y attribute of a CSSPositionValue this must, on setting a value value, perform the following steps:
</p>
		<ol>
			<li>
~IF［
所与の値 は `length-percentage$t に`合致-$しない
］
⇒
~THROW `TypeError$E
◎
If value doesn’t match &lt;length-percentage&gt;, throw a TypeError.
</li>
			<li>
此れの `x$m 内部~slot ~SET 所与の値
◎
Otherwise, set this’s x or y internal slot, as appropriate, to value.
</li>
		</ol>
	</dd>
	<dd>
取得子は、 `x$m 内部~slotの値を返さ~MUST。
◎
On reading, the attributes must return the value of the x or y internal slot, as appropriate.
</dd>

	<dt>`y@m</dt>
	<dd>
設定子と取得子は、 `x$m と同様に定義されるとする。
</dd>
</dl>

<div class="example">

<p>
`position$t 値は~keywordや値が成す複雑な組合わせを受容するが、~TypedOMでは，
<a href="#positionvalue-normalization">`CSSPositionValue^I の正規化</a>
節に従って，常に 2 個だけの~offsetに単純化される。
例えば、次の~stylesheetは：
◎
&lt;position&gt; values accept a complicated combination of keywords and values, but Typed OM always simplifies to just two offsets as per the §5.6 CSSPositionValue normalization algorithm. For example, the following style sheet:
</p>

<pre class="lang-css">
.example {
    object-position: center bottom 10px;
}
</pre>

<p>
次の挙動を生産することになる：
◎
Will produce the following behavior:
</p>

<pre class="lang-js">
let %map = document.querySelector('.example').computedStyleMap();

%map.get('object-position').x;
// CSS.percent(50)

%map.get('object-position').y;
// CSSMathSum(CSS.percent(100), CSS.px(-10))
</pre>
</div>



		</section>
		<section id="resourcevalue-objects">
<h3 title="CSSResourceValue objects">4.6. `CSSResourceValue^I ~obj</h3>


<pre class="idl">
enum `CSSResourceState@I {
    "`unloaded@m", "`loading@m", "`loaded@m", "`error@m"
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
interface `CSSResourceValue@I : `CSSStyleValue$I {
    readonly attribute `CSSResourceState$I `state$m;
};
</pre>

<p>
`CSSResourceValue$I ~objは、［
利用-可能になる前に非同期的な~network~fetchを要し得る
］ような~CSS値を表現する。
◎
CSSResourceValue objects represent CSS values that may require an asynchronous network fetch before being usable.
</p>

<p class="idl-def">
`CSSResourceValue$I ~objは、次のいずれかの状態にあり，その
`state@m
属性~値に反映される：
◎
A CSSResourceValue is in one of the following states, as reflected in the value of the state attribute:
</p>

<dl>
	<dt>`unloaded^l</dt>
	<dd>
資源は準備済みでなく，それ用に作動中の~fetchもない。
◎
The resource is not ready and is not actively being fetched
</dd>

	<dt>`loading^l</dt>
	<dd>
資源は準備済みではないが，その~fetchは処理-中にある。
◎
The resource is not ready, but is in the process of being fetched
</dd>

	<dt>`loaded^l</dt>
	<dd>
資源は具現化~用に準備済みである。
◎
The resource is ready for rendering
</dd>

	<dt>`error^l</dt>
	<dd>
資源は~fetchできなかったか，~fetchされた資源は妥当でない。
◎
The resource can’t be fetched, or the fetched resource is invalid
</dd>
</dl>

<p>
~network~dataを要求しない `CSSResourceValue$I ~obj（例えば `linear-gradient$f／`radial-gradient$f ）の `state$m1 は、 `loaded^l に初期化される。
◎
CSSResourceValue objects that do not require network data (for example linear and radial gradients) are initialized with state "loaded".
</p>


<div class="example">

<p>
例えば `url$t 生成規則に合致する画像は，即時に利用できるが、画像~dataが~fetchされるまでは，視覚的~変化-は生じないことになる。
`CSSResourceValue$I ~objは、読込まれた状態を追跡する値を `CSSResourceState$I 列挙を介して供することにより，これを表現する。
◎
For example, images that match the &lt;url&gt; production can be used immediately, but will not result in a visual change until the image data is fetched. CSSResourceValue objects represent this by providing values that track loaded state via the CSSResourceState enum.
</p>
</div>

<p class="issue">
`Worklet^I の中で構築される `CSSResourceValues^I の
状態は `unloaded^l にされるべきである。
`186$issue
◎
w3c/css-houdini-drafts/186[css-worklets] [css-typed-om] CSSResourceValues constructed within Worklets should have state "unloaded".
</p>



		</section>
		<section id="imagevalue-objects">
<h3 title="CSSImageValue objects">4.7. `CSSImageValue^I ~obj</h3>


<pre class="idl">
[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet)]
interface `CSSImageValue@I : `CSSResourceValue$I {
    readonly attribute double? `intrinsicWidth$m;
    readonly attribute double? `intrinsicHeight$m;
    readonly attribute double? `intrinsicRatio$m;
};

[`Exposed$=(Window, Worker, PaintWorklet, LayoutWorklet),
 `CSSURLImageValue$C(`USVString$I %url)]
interface `CSSURLImageValue@I : `CSSImageValue$I {
    readonly attribute `USVString$I `url$m;
};
</pre>


<p>
`CSSImageValue$I0 ~objは、 `image$t 生成規則をとる~prop用の値を表現する
— 例えば
⇒
`background-image$p,
`list-style-image$p,
`border-image-source$p
◎
CSSImageValue objects represent values for properties that take &lt;image&gt; productions, for example background-image, list-style-image, and border-image-source.
</p>

<dl class="idl-def">
	<dt>`intrinsicWidth@m</dt>
	<dt>`intrinsicHeight@m</dt>
	<dt>`intrinsicRatio@m</dt>
	<dd>
これらの属性は、それぞれ：
［
此れの `state$m1 ~EQ `loaded^l
］の下では，［
資源は内在的［
横幅, 縦幅, 縦横比
］（同順）を有する
］ならば，資源の対応する値を反映し~MUST
— 他の場合、 ~NULL にされ~MUST。
◎
If the CSSImageValue's state is "loaded", and the resource has an intrinsic width, height, or aspect ratio, then intrinsicWidth, intrinsicHeight, and intrinsicRatio must reflect the resource’s corresponding value. In all other cases, the attributes must be null.
</dd>
	<dd class="issue">
`Worklet^I の中で構築される `CSSResourceValues^I の状態は `unloaded^l にされるべきである。
`186$issue
◎
w3c/css-houdini-drafts/186[css-worklets] [css-typed-om] CSSResourceValues constructed within Worklets should have state "unloaded".
</dd>
</dl>


<!-- 
＊`CSSURLImageValue@I
 -->
<p>
`CSSURLImageValue$I ~objは、 `url$t 生成規則に合致するような `CSSImageValue$I を表現する。
これらの~objの
`url@m
属性は、画像を参照する~URLを包含する。
◎
CSSURLImageValue objects represent CSSImageValues that match the &lt;url&gt; production. For these objects, the url attribute contains the URL that references the image.
</p>

<dl class="idl-def">
	<dt>`CSSURLImageValue(url)@mC</dt>
	<dd>
<p>
この構築子の被呼出時には、次を遂行し~MUST：
◎
The CSSURLImageValue(url) constructor must, when called, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%~url を `url$t として正しく構文解析できない
］
⇒
~THROW `TypeError$E
◎
If the url passed into the constructor doesn’t correctly parse as a &lt;url&gt;, throw a TypeError and exit this algorithm.
</li>
			<li>
~RET 次のようにされた新たな `CSSURLImageValue$I ~obj
⇒＃
`url$m 内部~slot ~SET %~url
◎
Else, return a new CSSURLImageValue with its url internal slot set to url.
</li>
		</ol>
	</dd>
</dl>

<p class="issue">
`ColorValue^I を仕様~化する。
`159$issue
◎
w3c/css-houdini-drafts/159[css-typed-om] Spec up ColorValue
</p>

		</section>
	</section>
	<section id="stylevalue-normalization">
<h2 title="CSSStyleValue normalization">5. `CSSStyleValue^I の正規化</h2>


<p>
この節は、抽象~CSS値から~TypedOM~objを構築する
— 所与の~prop用の
`~CSS値を正規化する@
—
方法を述べる。
◎
This section describes how Typed OM objects are constructed from abstract CSS values (aka how to normalize a CSS value for a given property).
</p>

<p>
~propの文法がここに挙げるいずれかの型より複合的である場合、それは，生の `CSSStyleValue$I に正規化する
<!-- ＊？数式を正規化する$ -->
— その
<a href="#dom-cssstylevalue-stringifier">文字列化の挙動</a>
として、当の~propの~CSSOM直列化を生産するような。
◎
If a property’s grammar is more complex than one of the types listed here, it normalizes to a raw CSSStyleValue, with a stringification behavior that produces the CSSOM serialization of the property.
</p>

<p class="issue">
文字列化の挙動。
`268$issue
◎
w3c/css-houdini-drafts/268[css-typed-om] Stringification behavior
</p>

		<section id="normalize-tokens">
<h3 title="Raw CSS tokens: properties with var() references">5.1. 生の~CSS~token： `var^f 参照を伴う~prop</h3>

<p>
`代用され$ない `var$f 参照を伴う~prop値は、~propの他の部分の文法が何であれ，`成分~値$の`~list$として表現され、~TypedOMにおいては `CSSUnparsedValue$I になる。
◎
Regardless of what the property’s grammar is otherwise, a property value with an un-substituted var() reference is represented as a list of component values, which becomes a CSSUnparsedValue in the Typed OM.
</p>

<div class="algorithm">

<p>
`~fallbackの成分~値を正規化する@
ときは、所与の
( %~list )
に対し：
</p>

<ol>
	<li>
%結果~list ~LET 新たな`~list$
</li>
	<li>
%成分~文字列 ~LET ε
</li>
	<li>
<p>
%~list 内の ~EACH( %成分 ) に対し：
</p>
		<ol>
			<li>
<p>
~IF［
%成分 は `var$f 参照である
］：
</p>
				<ol>
					<li>
~IF［
%成分~文字列 ~NEQ ε
］
⇒
%結果~list に %成分~文字列 を付加する
</li>
					<li>
%成分~文字列 ~SET ε
</li>
					<li>
%結果~list に次の結果を付加する
⇒
`var() 参照を正規化する$( %成分 )
</li>
				</ol>
			</li>
			<li>
~ELIF［
%成分~文字列 ~NEQ ε
］
⇒
%成分~文字列 に %成分 の直列化を付加する
</li>
			<li>
~ELSE
⇒
%成分~文字列 ~SET %成分 の直列化
</li>
		</ol>
	</li>
	<li>
~IF［
%成分~文字列 ~NEQ ε
］
⇒
%結果~list に %成分~文字列 を付加する
</li>
	<li>
~RET 次のようにされた新たな `CSSUnparsedValue$I ~obj
⇒
`tokens$sl ~SET %結果~list
</li>
</ol>

◎
To normalize a list of component values from a list:
• Replace all var() references in list with CSSVariableReferenceValue objects, as described in §5.2 var() References.
• Replace each remaining maximal subsequence of component values in list with a single string of their concatenated serializations.
• Return a new CSSUnparsedValue whose [[tokens]] slot is set to list.
</div>

<div class="example">

<p>
文字列
`calc(42px + var(--foo, 15em) + var(--bar, var(--far) + 15px))^l
は、次に与える順の連列を包含する `CSSUnparsedValue$I に変換される：
◎
The string "calc(42px + var(--foo, 15em) + var(--bar, var(--far) + 15px))" is converted into a CSSUnparsedValue that contains a sequence with:
</p>

<ol>
	<li>
`calc(42px + ^l
◎
the string "calc(42px + "
</li>
	<li>
<p>
次のようにされた `CSSVariableReferenceValue$I ：
◎
a CSSVariableReferenceValue with:
</p>
		<ul>
			<li>
`variable$m1 ~SET `--foo^l
◎
variable "--foo"
</li>
			<li>
`fallback$m1 ~SET ［
` 15em^l のみからなる連列
］を伴う `CSSUnparsedValue$I
◎
fallback a CSSUnparsedValue with a single-valued sequence containing " 15em"
</li>
		</ul>
	</li>
	<li>
` + ^l
◎
the string " + "
</li>
	<li>
<p>
次のようにされた `CSSVariableReferenceValue$I ：
◎
a CSSVariableReferenceValue with:
</p>

		<ul>
			<li>
`variable$m1 ~SET `--bar^l
◎
variable "--bar"
</li>
			<li>
<p>
`fallback$m1 ~SET 次の連列を包含している  `CSSUnparsedValue$I ：
◎
fallback a CSSUnparsedValue with a sequence containing:
</p>

				<ol>
					<li>
` ^l
◎
the string " "
</li>
					<li>
<p>
次を伴う `CSSVariableReferenceValue$I
◎
a CSSVariableReferenceValue with
</p>

						<ol>
							<li>
`variable$m1  ~SET `--far^l
◎
variable "--far"
</li>
							<li>
`fallback$m1  ~SET ~NULL
◎
fallback null
</li>
						</ol>
					</li>
					<li>
` + 15px^l
◎
the string " + 15px"
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
`)^l
◎
the string ")"
</li>
</ol>

</div>



		</section>
		<section id="normalize-var">
<h3 title="var() References">5.2. `var^f 参照</h3>


<p>
`var$f 参照は、~TypedOMにおいては
`CSSVariableReferenceValue$I
になる。
◎
var() references become CSSVariableReferenceValues in the Typed OM.
</p>

<div class="algorithm">

<p>
`var() 参照を正規化する@
ときは、所与の
( `var$f 参照 %var ) に対し：
</p>

<ol>
	<li>
%fallback ~LET ~NULL
</li>
	<li>
~IF［
%var には~fallback値は在る
］
⇒
%fallback ~SET `~fallbackの成分~値を正規化する$( その値 )
</li>
	<li>
~RET 次のようにされた新たな `CSSVariableReferenceValue$I
⇒＃
`variable$m1 内部~slot ~SET %var の名を与える `custom-ident$t の直列化,
`fallback$m1 内部~slot ~SET %fallback
</li>
</ol>

◎
To normalize a var() reference var:
• Let object be a new CSSVariableReferenceValue.
• Set object’s variable internal slot to the serialization of the &lt;custom-ident&gt; providing the variable name.
• If var has a fallback value, set object’s fallback internal slot to the result of normalizing the fallback’s component values. Otherwise, set it to null.
• Return object.
</div>



		</section>
		<section id="normalize-ident">
<h3 title="Identifier Values">5.3. 識別子~値</h3>


<p>
~CSS`識別子$は、~TypedOMにおいては `CSSKeywordValue$I になる。
◎
CSS identifiers become CSSKeywordValues in the Typed OM.
</p>

<div class="algorithm">

<p>
`識別子を正規化する@
ときは、所与の
( `識別子$ %識別子 )
に対し：
◎
To normalize an identifier ident:
</p>

<ol>
	<li>
~RET 次のようにされた新たな `CSSKeywordValue$I ~obj
⇒＃
`value$m1 内部~slot ~SET %識別子 の直列化
◎
Return a new CSSKeywordValue with its value internal slot set to the serialization of ident.
</li>
</ol>
</div>

		</section>
		<section id="normalize-numeric">
<h3 title="&lt;number&gt;, &lt;percentage&gt;, and &lt;dimension&gt; values">5.4. `number^t ／ `percentage^t ／ `dimension^t 値</h3>


<p>
~CSS［
`number$t ／ `percentage$t ／ `dimension$t
］値は、~TypedOMにおいては `CSSNumericValue$I になる。
◎
CSS &lt;number&gt;, &lt;percentage&gt;, and &lt;dimension&gt; values become CSSNumericValues in the Typed OM.
</p>

<div class="algorithm">

<p>
`数量~値を正規化する@
ときは、所与の
( %~num )
に対し：
◎
To normalize a numeric value num:
</p>

<ol>
	<li>
~IF［
%~num は`~math関数$である
］
⇒
~RET `数式を正規化する$( %~num )
◎
If num is a calc(), min(), or max() expression, normalize a math expression from num and return the result.
</li>
	<li>
%単位 ~LET %~num に応じて
⇒＃
`number$t であるならば `number^l ／
`percentage$t であるならば `percent^l ／
`dimension$t であるならば⇒＃
%~num は 単位なしの値 `0^v であるならば `px^l ／
~ELSE_  %~num の単位
◎
↓</li>
	<li>
~RET 次のようにされた新たな `CSSUnitValue$I ~obj
⇒＃
`value$m1 内部~slot ~SET %~num の数量~値,
`unit$m1 内部~slot ~SET %単位
◎
If num is the unitless value 0 and num is a &lt;dimension&gt;, return a new CSSUnitValue with its value internal slot set to 0, and its unit internal slot set to "px".
◎
Return a new CSSUnitValue with its value internal slot set to the numeric value of num, and its unit internal slot set to "number" if num is a &lt;number&gt;, "percent" if num is a &lt;percentage&gt;, and num’s unit if num is a &lt;dimension&gt;.
</li>
</ol>
</div>

<div class="algorithm">

<p>
`数式を正規化する@
ときは、所与の
( %式 )
に対し：
◎
To normalize a math expression num:
</p>

<ol>
	<li>
<p>
~IF［
%式 は［
`min$f ／ `max$f
］式である
］：
◎
If num is a min() or max() expression:
</p>
		<ol>
			<li>
%値~list ~LET `数式を正規化する$( %式 と同じ引数たちをとる `calc$f 式 )
◎
Let values be the result of normalizing the arguments to the expression, treating each argument as if it were the contents of a calc() expression.
</li>
			<li>
<p>
~RET %式 に応じて：
</p>
				<ul class="switch">
					<li>
`min$f 式ならば
⇒
次のようにされた新たな `CSSMathMin$I ~obj
⇒
`values$m1 内部~slot ~SET %値~list
</li>
					<li>
`max$f 式ならば
⇒
次のようにされた新たな `CSSMathMax$I ~obj
⇒
`values$m1 内部~slot ~SET %値~list
</li>
				</ul>
◎
Return a new CSSMathMin or CSSMathMax object, respectively, with its values internal slot set to values.
</li>
		</ol>
	</li>
	<li>
~Assert：
%式 は `calc$f 式である
◎
Assert: Otherwise, num is a calc().
</li>
	<li>
<p>
標準の `PEMDAS precedence^en
【<a href="https://en.wikipedia.org/wiki/Order_of_operations">四則演算の優先順位</a>】
規則を用いて, および次の［
例外／明確化
］の下で、 %式 の引数たちを式~木に転換する：
◎
Turn num’s argument into an expression tree using standard PEMDAS precedence rules, with the following exceptions/clarification:
</p>

		<ul>
			<li>
減算は、右辺の引数を特別な `反数-^i ~node内に包装した上で，加算であるものと扱う。
◎
Treat subtraction as instead being addition, with the RHS argument instead wrapped in a special "negate" node.
</li>
			<li>
除算は、右辺の引数を特別な `逆数-^i ~node内に包装した上で，乗算であるものと扱う。
◎
Treat division as instead being multiplication, with the RHS argument instead wrapped in a special "invert" node.
</li>
			<li>
［
加算／乗算
］~nodeは、 N 項演算子（ `N-ary^en ）である
— すなわち、~nodeは引数をいくつでもとれる。
◎
Addition and multiplication are N-ary; each node can have any number of arguments.
</li>
			<li>
式~内の値の個数は 1 個だけで，演算はない場合、それを，単独の引数を伴う加算~nodeとして扱う。
◎
If an expression has only a single value in it, and no operation, treat it as an addition node with the single argument.
</li>
		</ul>
	</li>
	<li>
<p>
次に従って，式~木を~objに再帰的に変形する：
◎
Recursively transform the expression tree into objects, as follows:
</p>

		<dl class="switch">
			<dt>
加算~node
◎
addition node
</dt>
			<dd>
次のようにされた新たな `CSSMathSum$I ~objにする
⇒
`values$m1 内部~slot ~SET その引数たちが成す~list
◎
becomes a new CSSMathSum object, with its values internal slot set to its list of arguments
</dd>

			<dt>
乗算~node
◎
multiplication node
</dt>
			<dd>
次のようにされた新たな `CSSMathProduct$I ~objにする
⇒
`values$m1 内部~slot ~SET その引数たちが成す~list
◎
becomes a new CSSMathProduct object, with its values internal slot set to its list of arguments
</dd>

			<dt>
反数-~node
◎
negate node
</dt>
			<dd>
次のようにされた新たな `CSSMathNegate$I ~objにする
⇒
`value$m1 内部~slot ~SET その引数
◎
becomes a new CSSMathNegate object, with its value internal slot set to its argument
</dd>

			<dt>
逆数-~node
◎
invert node
</dt>
			<dd>
次のようにされた新たな `CSSMathInvert$I ~objにする
⇒
`value$m1 内部~slot ~SET その引数
◎
becomes a new CSSMathInvert object, with its value internal slot set to its argument
</dd>

			<dt>
~~末端~node
◎
leaf node
</dt>
			<dd>
【~nodeの種類に応じて，他所に定義されるように】
適切に正規化する。
◎
normalized as appropriate
</dd>
		</dl>
	</li>
</ol>

<div class="example">

<p>
例えば,
`calc(1px - 2 * 3em)^v
次の構造を生産する：
◎
For example, calc(1px - 2 * 3em) produces the structure:
</p>

<pre>
CSSMathSum(
    CSS.px(1),
    CSSMathNegate(
        CSSMathProduct(
            2,
            CSS.em(3)
        )
    )
)
</pre>
</div>

<div class="example">

<p>
加算と乗算は、 N 項演算子（ `N-ary^en ）なので、
`calc(1px + 2px + 3px)^v
は，次の構造を生産する：
◎
Note that addition and multiplication are N-ary, so calc(1px + 2px + 3px) produces the structure:
</p>

<pre>
CSSMathSum(
    CSS.px(1),
    CSS.px(2),
    CSS.px(3)
)
</pre>

<p>
一方で
`calc(calc(1px + 2px) + 3px)^v
は，次の構造を生産する：
◎
but calc(calc(1px + 2px) + 3px) produces the structure:
</p>

<pre>
CSSMathSum(
    CSSMathSum(
        CSS.px(1),
        CSS.px(2)
    ),
    CSS.px(3)
)
</pre>

</div>

<p class="note">注記：
値を算出するこの処理-は、異なる単位を互いに一致する 1 つに変形して，結果の式を単純化することもある／しても~MAY。
例えば
`calc(1px + 2em)^v
に対しては、指定d値としての結果は
`CSSMathSum(CSS.px(1), CSS.em(2))^c
になるが，算出d値としての結果は
`CSS.px(33)^c
に類する値を与えることになる（その文脈における `em$u の値に依存する）。
◎
Note: The value computation process may transform different units into identical ones, simplifying the resulting expression. For example, calc(1px + 2em) as a specified value results in a CSSMathSum(CSS.px(1), CSS.em(2)), but as a computed value will give CSS.px(33) or similar (depending on the value of an em in that context).
</p>
</div>

		</section>
		<section id="transformvalue-normalization">
<h3 title="&lt;transform-list&gt; and &lt;transform-function&gt; values">5.5. `transform-list^t ／ `transform-function^t 値</h3>


<p>
~TypedOMにおいては、
~CSS `transform-list$t 値は `CSSTransformValue$I になり，
~CSS `transform-function$t 値は `CSSTransformComponent$I になる。
◎
CSS &lt;transform-list&gt; values become CSSTransformValues in the Typed OM, while CSS &lt;transform-function&gt; values become CSSTransformComponents.
</p>

<div class="algorithm">

<p>
`変形~listを正規化する@
ときは、所与の
( `transform-list$t %~list )
に対し：
◎
To normalize a &lt;transform-list&gt; list:
</p>

<ol>
	<li>
~RET 次のようにされた新たな `CSSTransformValue$I ~obj
⇒
`変形~成分~list$ ~SET %~list を［
`変形~関数を正規化する$
］`演算で写像する$
◎
Return a new CSSTransformValue whose values to iterate over are the result of mapping the normalize a &lt;transform-function&gt; algorithm over list.
</li>
</ol>
</div>

<div class="algorithm">

<p>
`変形~関数を正規化する@
ときは、所与の
( `transform-function$t %関数 )
に対し，次を遂行する：
◎
To normalize a &lt;transform-function&gt; func, perform the appropriate set of steps below, based on func:
</p>

<ol>
	<li>
%O ~LET ε
◎
↓↓</li>
	<li>
<p>
%関数 に応じて：
</p>

		<dl class="switch">
			<dt>`matrix$f</dt>
			<dt>`matrix3d$f — 3D</dt>
			<dd>
				<ol>
					<li>
%行列 ~LET %関数 と同じ情報を表現している行列を表現する `DOMMatrix$I ~obj
</li>
					<li>
%O ~SET 次のようにされた新たな `CSSMatrixComponent$I ~obj
⇒＃
`matrix$m1 内部~slot ~SET %行列
</li>
				</ol>
◎
Return a new CSSMatrixComponent object, whose matrix internal slot is set to a 4x4 matrix representing the same information as func, and whose is2D internal slot is true if func is matrix(), and false otherwise.
</dd>

			<dt>`translate$f</dt>
			<dt>`translateX$f</dt>
			<dt>`translateY$f</dt>
			<dt>`translate3d$f — 3D</dt>
			<dt>`translateZ$f — 3D</dt>
			<dd>
				<ol>
					<li>
( %x, %y, %z ) ~LET  %関数 内に指定された，~3D並進~vectorの ( x, y, z ) 成分を与える引数
— 対応する引数がない（~2D変形~関数の場合の z など）, または省略された成分には `0px^v が指定されたものと扱う
</li>
					<li>
%O ~SET 次のようにされた新たな `CSSTranslate$I ~obj
⇒＃
`x$m1 内部~slot ~SET `数量~値を正規化する$( %x ),
`y$m1 内部~slot ~SET `数量~値を正規化する$( %y ),
`z$m1 内部~slot ~SET `数量~値を正規化する$( %z )
</li>
				</ol>
◎
Return a new CSSTranslate object, whose x, y, and z internal slots are set to the normalization of the specified x/y/z offsets, or the normalization of 0px if not specified in func, and whose is2D internal slot is true if func is translate(), translateX(), or translateY(), and false otherwise.
</dd>

			<dt>`scale$f</dt>
			<dt>`scaleX$f</dt>
			<dt>`scaleY$f</dt>
			<dt>`scale3d$f — 3D</dt>
			<dt>`scaleZ$f — 3D</dt>
			<dd>
				<ol>
					<li>
( %x, %y, %z ) ~LET %関数 内に指定された~3D拡縮~vectorの ( x, y, z ) 成分を与える引数
— 対応する引数がない（ ~2D変形~関数の場合の z など）, または省略された成分には `1^v が指定されたものと扱う
</li>
					<li>
%O ~SET 次のようにされた新たな `CSSScale$I ~obj
⇒＃
`x$m1 内部~slot ~SET `数量~値を正規化する$( %x ),
`y$m1 内部~slot ~SET `数量~値を正規化する$( %y ),
`z$m1 内部~slot ~SET `数量~値を正規化する$( %z )
</li>
				</ol>
◎
Return a new CSSScale object, whose x, y, and z internal slots are set to the specified x/y/z scales, or to 1 if not specified in func and whose is2D internal slot is true if func is scale(), scaleX(), or scaleY(), and false otherwise.
</dd>

			<dt>`rotate$f</dt>
			<dt>`rotate3d$f — 3D</dt>
			<dt>`rotateX$f — 3D</dt>
			<dt>`rotateY$f — 3D</dt>
			<dt>`rotateZ$f — 3D</dt>
			<dd>
				<ol>
					<li>
%角度 ~LET %関数 内に指定された回転角を与える引数
</li>
					<li>
( %x, %y, %z ) ~LET %関数 内に指定された，~3D回転~軸~vectorの ( x, y, z ) 成分を与える引数
— 対応する引数がない（~2D変形~関数の場合など）, または省略された［
x ／ y ／ z
］成分には［
`0^v ／ `0^v ／ `1^v
］が指定されたものと扱う
</li>
					<li>
%O ~SET 次のようにされた新たな `CSSRotate$I ~obj
⇒＃
`angle$m1 内部~slot ~SET `数量~値を正規化する$( %角度 ),
`x$m1 内部~slot ~SET `数量~値を正規化する$( %x ),
`y$m1 内部~slot ~SET `数量~値を正規化する$( %y ),
`z$m1 内部~slot ~SET `数量~値を正規化する$( %z )
</li>
				</ol>
◎
Return a new CSSRotate object, whose angle internal slot is set to the normalization of the specified angle, and whose x, y, and z internal slots are set to the specified rotation axis coordinates, or the implicit axis coordinates if not specified in func and whose is2D internal slot is true if func is rotate(), and false otherwise.
</dd>

			<dt>`skew$f</dt>
			<dd>
				<ol>
					<li>
( %ax, %ay ) ~LET それぞれ順に，
%関数 内に ( x, y ) 角度を与える引数が［
指定されていれば それ／
~ELSE_ `0deg^v
］
</li>
					<li>
%O ~SET 次のようにされた新たな `CSSSkew$I ~obj
⇒＃
`ax$m1 内部~slot ~SET `数量~値を正規化する$( %ax ),
`ay$m1 内部~slot ~SET `数量~値を正規化する$( %ay )
</li>
				</ol>

◎
Return a new CSSSkew object, whose ax and ay internal slots are set to the normalization of the specified x and y angles, or the normalization of 0deg if not specified in func, and whose is2D internal slot is true.
</dd>

			<dt>`skewX$f</dt>
			<dd>
				<ol>
					<li>
%ax ~LET %関数 内に x 角度を与える引数が［
指定されていれば それ／
~ELSE_ `0deg^v
］
</li>
					<li>
%O ~SET 次のようにされた新たな `CSSSkewX$I ~obj
⇒＃
`ax$m1 内部~slot ~SET `数量~値を正規化する$( %ax )
</li>
				</ol>

◎
Return a new CSSSkewX object, whose ax internal slot is set to the normalization of the specified x angle, or the normalization of 0deg if not specified in func, and whose is2D internal slot is true.
</dd>

			<dt>`skewY$f</dt>
			<dd>
				<ol>
					<li>
%ay ~LET %関数 内に y 角度を与える引数が［
指定されていれば それ／
~ELSE_ `0deg^v
］
</li>
					<li>
%O ~SET 次のようにされた新たな `CSSSkewY$I ~obj
⇒＃
`ay$m1 内部~slot ~SET `数量~値を正規化する$( %ay )
</li>
				</ol>

◎
Return a new CSSSkewY object, whose ay internal slot is set to the normalization of the specified y angle, or the normalization of 0deg if not specified in func, and whose is2D internal slot is true.
</dd>


			<dt>`perspective$f — 3D</dt>
			<dd>
				<ol>
					<li>
%距離 ~LET %関数 内に指定された引数
</li>
					<li>
%O ~SET 次のようにされた新たな `CSSPerspective$I ~obj
⇒＃
`length$m1 内部~slot ~SET `数量~値を正規化する$( %距離 )
</li>
				</ol>
◎
Return a new CSSPerspective object, whose length internal slot is set to the normalization of the specified length and whose is2D internal slot is false.
</dd>
		</dl>
	</li>
	<li>
%O の `~TCis2D$m 内部~slot ~SET %関数 に応じて
⇒＃
`~2D変形~関数$ならば ~T ／
`~3D変形~関数$ならば ~F （上の場合分けにて “3D” が付与されたもの）
◎
↑↑</li>
	<li>
~RET %O
◎
↑↑</li>
</ol>

</div>


		</section>
		<section id="positionvalue-normalization">
<h3 title="CSSPositionValue normalization">5.6. `CSSPositionValue^I の正規化</h3>

<div class="algorithm">

<p>
~CSS `position$t 値 %V は、次を遂行した結果の `CSSPositionValue$I になる：
◎
CSS &lt;position&gt; values become CSSPositionValues in the Typed OM, with x and y components determined via the following process. If this process, or any sub-process referenced by this process fails, then normalization as a whole fails.
</p>

<p class="trans-note">【†
原文の~algoは、 %V が `position$t に合致していない場合に `失敗^i を返す。
が，ここでは、 %V は `position$t に合致しているものと見做す（原文の記述は、 %V として渡され得る値の範囲が指定されていないため，意図が曖昧になっているので）
— 代わりに，原文にて `失敗^i を返す箇所は、すべて ~Assert に置換する。
~Assert に記される条件が満たされない場合、手続き全体を中止して `失敗^i を返すことになる。
】【
明快にするため、この節の~algoには，かなり手を加えている（ ~Assert に対応する箇所を移動するなど）。
】</p>

<ol>
	<li>
<p>
~Assert：
%V を成す成分の個数は 1 〜 4 個であり、どの成分も次のいずれかである：
</p>
		<ul>
			<li>
~keyword ~IN { `center^v, `left^v, `right^v, `top^v, `bottom^v }
</li>
			<li>
`length-percentage$t （長さ ／ 百分率 ／ ~calc式 ）
— 以下、ここでは “長さ” と総称する。
</li>
		</ul>
【この段は、この訳による補完。】
</li>
	<li>
( %C1, %C2, %C3, %C4 )
~LET 順に，
%V を成す( 1, 2, 3, 4 ) 個目の成分が［
あれば それ ／
なければ ε
］
◎
↓</li>
	<li>
( %値/1, %向き/1, %値/2, %向き/2 ) ~LET ( ε, ε, ε, ε )
◎
Initialize both x and y to a CSSNumericValue value representing 50%.
</li>
	<li>
<p>
~IF［
%C3 ~EQ ε
］：
</p>
		<ol>
			<li>
~IF［
%C2 ~EQ ε
］
⇒
%C2 ~SET `center^v
</li>
			<li>
( %値/1, %向き/1 ) ~SET `単独の値から x/y を決定する$( %C1 )
</li>
			<li>
( %値/2, %向き/2 ) ~SET `単独の値から x/y を決定する$( %C2 )
</li>
			<li>
~Assert：
［
%向き/1 ~NEQ `縦^i
］~OR［
%C2 は~keywordである
］
</li>
			<li>
~Assert：
［
%向き/2 ~NEQ `横^i
］~OR［
%C1 は~keywordである
］
</li>
		</ol>
◎
If the provided value is a single keyword, length, percentage, or calc expression, then follow the procedure outlined in §5.6.1 Determining x or y from a single value with value given by the provided value and an auto bias.
◎
Otherwise, if the provided value consists of a combination of two keywords, then:
• follow the procedure outlined in §5.6.1 Determining x or y from a single value with value given by the first keyword and an auto bias.
• if bias is horizontal, set it to vertical. Otherwise, set it to horizontal.
• follow the procedure again with value given by the second keyword, using the existing bias.
◎
Otherwise, if the provided value consists of a combination of two keywords, lengths, percentages, and calc expressions, then follow the procedure outlined in §5.6.1 Determining x or y from a single value with value given by the first part of the provided value and a horizontal bias, then follow the procedure again with value given by the second part of the provided value and a vertical bias.
</li>
	<li>
<p>
~ELSE
◎
Otherwise:
</p>
		<ol>
			<li>
~IF［
%C1 は~keywordである
］~AND［
%C2 は長さである
］
⇒
( %値/1, %向き/1 ) ~SET `~keyword, 長さから x/y を決定する$( %C1, %C2 )
◎
if the provided value starts with a keyword followed by a length, percentage, or calc expression, then follow the procedure outlined in §5.6.2 Determining x or y from a keyword and a length with keyword set to the keyword, length set to the length, percentage, or calc expression, and auto bias.
</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
~Assert：
%C4 ~EQ ε
</li>
					<li>
( %値/1, %向き/1 ) ~SET `単独の値から x/y を決定する$( %C1 )；
</li>
					<li>
%C4 ~SET %C3
</li>
					<li>
%C3 ~SET %C2
</li>
				</ol>

◎
otherwise, follow the procedure outlined in §5.6.1 Determining x or y from a single value with value set to the first component of the provided value and an auto bias.
◎
if bias is horizontal, set it to vertical. Otherwise, set it to horizontal.
</li>
			<li>
~IF［
%C4 ~EQ ε
］
⇒
( %値/2, %向き/2 ) ~SET `単独の値から x/y を決定する$( %C3 )
◎
if the remainder of the provided value is a single keyword, length, percentage or calc expression, follow the procedure outlined in §5.6.1 Determining x or y from a single value with value set to the keyword and the existing bias.
</li>
			<li>
~ELIF［
%C3 は~keywordである
］~AND［
%C4 は長さである
］
⇒
( %値/2, %向き/2 ) ~SET `~keyword, 長さから x/y を決定する$( %C3, %C4 )
◎
otherwise, if the remainder of the provided value consists of a keyword followed by a length, percentage or calc expression, follow the procedure outlined in §5.6.2 Determining x or y from a keyword and a length with keyword set to the keyword, length set to the length, percentage, or calc expression, and the existing bias.
</li>
			<li>
~Assert：
この段に達することはない
◎
Otherwise, the process fails.
</li>
		</ol>
	</li>
	<li>
~Assert：
［
`不定^i ~IN {%向き/1, %向き/2 }
］~OR［
%向き/1 ~NEQ %向き/2 
］
◎
↑↑</li>
	<li>
~IF［
%向き/1 ~EQ `縦^i
］
⇒
%値/1, %値/2 を入れ替える
◎
↑↑</li>
	<li>
~RET 次のようにされた新たな `CSSPositionValue$I
⇒＃
`x$m1 内部~slot ~SET %値/1,
`y$m1 内部~slot ~SET %値/2
◎
↑↑</li>
</ol>

</div>

<div class="algorithm">
<p>
`単独の値から x/y を決定する@
ときは、所与の
( %値 )
に応じて：
◎
●5.6.1. Determining x or y from a single value
◎
The following process sets a value for either x or y, depending on an input value and bias. The process also updates bias based on the value.
</p>

<ol>
	<li>
( %値, %向き ) ~SET %値 に応じて
⇒＃
`center^v ならば ( `50%^v, `不定^i )  ／
`left^v ならば ( `0%^v, `横^i ) ／
`right^v ならば ( `100%^v, `横^i ) ／
`top^v ならば ( `0%^v, `縦^i ) ／
`bottom^v ならば ( `100%^v, `縦^i ) ／
~ELSE_ ( %値, `不定^i )
◎
If value is the keyword "left" and bias is not vertical, then set x to a CSSNumericValue value representing 0% and bias to horizontal and exit this process.
◎
If value is the keyword "right" and bias is not vertical, then set x to a CSSNumericValue value representing 100% and bias to horizontal and exit this process.
◎
If value is the keyword "top" and bias is not horizontal, then set y to a CSSNumericValue value representing 0% and bias to vertical and exit this process.
◎
If value is the keyword "bottom" and bias is not horizontal, then set y to a CSSNumericValue value representing 100% and bias to vertical and exit this process.
</li>
	<li>
~RET ( `数量~値を正規化する$( %値 ), %向き )
◎
If value matches the &lt;length-percentage&gt; production, then set norm to the result of normalizing |value| as a numeric value. If bias is vertical, set y to norm, otherwise set x to norm and bias to horizontal. Exit this process.
◎
If value is not the keyword "center", then this process fails.
</li>
</ol>
</div>

<div class="algorithm">

<p>
`~keyword, 長さから x/y を決定する@
ときは、入力
( %~keyword, %長さ )
に応じて：
◎
●5.6.2. Determining x or y from a keyword and a length
◎
The following process sets a value for either x ory, depending on an input keyword, length, and bias. The process also updates bias based on the keyword and length.
</p>

<ol>
	<li>
~Assert：
%~keyword ~NEQ `center^v
</li>
	<li>
( %値, %向き ) ~LET `単独の値から x/y を決定する$( %~keyword )
◎
follow the procedure outlined in §5.6.1 Determining x or y from a single value with value given by keyword, using the provided bias
</li>
	<li>
%調整 ~LET `数量~値を正規化する$( %長さ )
◎
let adjustment be the result of normalizing |length| as a numeric value.
</li>
	<li>
~IF［
%~keyword ~IN { `right^v, `bottom^v }
］
⇒
%調整 ~SET 0 長さ から %調整 を減算した結果
◎
If the keyword is "right" or "bottom", let adjustment be the result of subtracting adjustment from a zero length.
</li>
	<li>
%値 に %調整 を加算する
【この “加算-” と前~段の “減算-” の詳細は、述べられていない。】
◎
amend x (if bias is horizontal) or y (if bias is vertical) by adding adjustment to it.
</li>
	<li>
~RET ( %値, %向き )
◎
↑</li>
</ol>

</div>

		</section>
		<section id="resourcevalue-normalization">
<h3 title="CSSResourceValue normalization">5.7. `CSSResourceValue^I の正規化</h3>

<p>
`CSSResourceValue$I 資源~参照を正規化するときは
⇒
`state$m1 ~SET 次に与える値
⇒＃
参照は妥当でないならば `error^l ／
~ELSE_ ~network~dataが要求されるならば `loading^l ／
~ELSE_ `loaded^l
◎
Resource references are normalized by determining whether the reference is invalid (in which case state is set to error) or requires network data (in which case state is set to loading). If data is not required and the reference is valid then state is set to loaded.
</p>

<p>
`state$m1 が `loading^l に設定された場合、処理待ち~dataが可用になった時点で画像~参照は，上の規則に則って評価し直される。
◎
If state is set to loading then the image reference is reevaluated once the pending data becomes available, according to the same rules referenced above.
</p>

<p>
`CSSResourceValue$I ~objに対しては、正規化が失敗することはない。
◎
Normalization does not fail for CSSResourceValue objects.
</p>

<div class="example">

<p>
文字列
`url(bike.png)^l
は、次のようにされた `CSSURLImageValue$I に変換される
⇒＃
`url$m1 ~SET `bike.png^v,
`CSSResourceValue^II `state$m1 ~SET `unloaded^v,
`CSSImageValue^II `intrinsicWidth$m1 ~SET ~NULL,
`intrinsicHeight$m1 ~SET ~NULL,
`intrinsicRatio$m1 ~SET ~NULL
◎
The string 'url(bike.png)' is converted into a CSSURLImageValue with state set to unloaded and the url set to bike.png. The intrinsicWidth, intrinsicHeight and intrinsicRatio are all set to null.
</p>
</div>

		</section>
		<section id="property-stle-value-normalization">
<h3 title="List of CSS properties to their CSSStyleValue normalization">5.8. `CSSStyleValue^I に正規化される~CSS~propの~list</h3>


<p>
次の表に、各種~propの［
指定d値, 算出d値
］が どの型の `CSSStyleValue$I ~objに正規化され得るかを挙げる：
◎
The table below lists out the possible CSSStyleValues that each property could normalize to, depending on its specified or computed value.
</p>

<table><thead><tr><th>~CSS~prop
<th>指定d値
<th>算出d値
</thead><tbody>

<tr><td>`display$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`margin-top$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`margin-left$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`margin-bottom$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`margin-right$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`width$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`height$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`background-color$p
</td><td>`CSSColorValue^I, `CSSKeywordValue^I
</td><td>`CSSColorValue^I
</td></tr>

<tr><td>`color$p
</td><td>`CSSColorValue^I, `CSSKeywordValue^I
</td><td>`CSSColorValue^I
</td></tr>

<tr><td>`padding-left$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`padding-top$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`padding-bottom$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`padding-right$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`border-style$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`border-color$p
</td><td>`CSSColorValue^I, `CSSKeywordValue^I
</td><td>`CSSColorValue^I
</td></tr>

<tr><td>`border-left-width$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`border-top-width$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`border-bottom-width$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`border-right-width$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`position$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`font-size$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`top$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`left$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`bottom$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`right$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`text-align$p
</td><td>`CSSKeywordValue^I
</td><td>
</td></tr>

<tr><td>`font-weight$p
</td><td>`CSSKeywordValue^I, `CSSStyleValue^I
</td><td>`CSSKeywordValue^I, `CSSStyleValue^I
</td></tr>

<tr><td>`float$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`opacity$p
</td><td>`CSSNumericValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`text-decoration-style$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`text-decoration-line$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`text-decoration-color$p
</td><td>`CSSColorValue^I
</td><td>`CSSColorValue^I
</td></tr>

<tr><td>`line-height$p
</td><td>c【？】
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`vertical-align$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`white-space$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`z-index$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`cursor$p
</td><td>`CSSKeywordValue^I, `CSSImageValue^I
</td><td>`CSSKeywordValue^I, `CSSImageValue^I
</td></tr>

<tr><td>`background-image$p
</td><td>`CSSImageValue^I, `CSSKeywordValue^I
</td><td>`CSSImageValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`border-top-left-radius$p
</td><td>`CSSNumericValue^I, `CSSStyleValue^I
</td><td>`CSSStyleValue^I
</td></tr>

<tr><td>`border-top-right-radius$p
</td><td>`CSSNumericValue^I, `CSSStyleValue^I
</td><td>`CSSStyleValue^I
</td></tr>

<tr><td>`border-bottom-left-radius$p
</td><td>`CSSNumericValue^I, `CSSStyleValue^I
</td><td>`CSSStyleValue^I
</td></tr>

<tr><td>`border-bottom-right-radius$p
</td><td>`CSSNumericValue^I, `CSSStyleValue^I
</td><td>`CSSStyleValue^I
</td></tr>

<tr><td>`min-height$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`max-height$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`min-width$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`max-width$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`visibility$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`background-position$p
</td><td>`CSSPositionValue^I
</td><td>`CSSPositionValue^I
</td></tr>

<tr><td>`content$p
</td><td>`CSSKeywordValue^I, `CSSResourceValue^I, `CSSStyleValue^I
</td><td>`CSSKeywordValue^I, `CSSResourceValue^I, `CSSStyleValue^I
</td></tr>

<tr><td>`box-sizing$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`outline-color$p
</td><td>`CSSColorValue^I
</td><td>`CSSColorValue^I
</td></tr>

<tr><td>`outline-style$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`outline-width$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`background-repeat$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`font-style$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`background-size$p
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I, `CSSStyleValue^I
</td><td>`CSSNumericValue^I, `CSSKeywordValue^I, `CSSStyleValue^I
</td></tr>

<tr><td>`clear$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`text-overflow$p
</td><td>`CSSKeywordValue^I, `CSSStyleValue^I
</td><td>`CSSKeywordValue^I, `CSSStyleValue^I
</td></tr>

<tr><td>`transform$p
</td><td>`CSSTransformValue^I
</td><td>`CSSTransformValue^I
</td></tr>

<tr><td>`overflow-y$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`overflow-x$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`text-transform$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`list-style-image$p
</td><td>`CSSImageValue^I, `CSSKeywordValue^I
</td><td>`CSSImageValue^I, `CSSKeywordValue^I
</td></tr>

<tr><td>`list-style-position$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`list-style-type$p
</td><td>`CSSKeywordValue^I
</td><td>`CSSKeywordValue^I
</td></tr>

<tr><td>`transition-duration$p
</td><td>`CSSNumericValue^I
</td><td>`CSSNumericValue^I
</td></tr>

<tr><td>`transition-delay$p
</td><td>`CSSNumericValue^I
</td><td>`CSSNumericValue^I
</td></tr></tbody></table>
		</section>
	</section>
	<section id="stylevalue-serialization">
<h2 title="CSSStyleValue Serialization">6. `CSSStyleValue^I の直列化</h2>


<p>
`CSSStyleValue$I 値を直列化する仕方は、それがどう構築されたかに依存する：
◎
The way that a CSSStyleValue serializes is dependent on how the value was constructed.
</p>

<ul>
	<li>
`DOMString^I %s から構築された場合
⇒
直列化は %s になる。
◎
if the value was constructed from a DOMString
• the serialization is the DOMString from which the value was constructed.
</li>
	<li>
~IDL構築子を用いて構築された場合
⇒
この節の下位-節にて指定される。
◎
otherwise, if the value was constructed using an IDL constructor
• the serialization is specified in the sections below.
</li>
	<li>
~CSSOMから抽出された場合
⇒
<a href="#cssom-serialization">~CSSOMからの値の直列化</a>
節にて指定される。
◎
otherwise, if the value was extracted from the CSSOM
• the serialization is specified in §6.8 Serialization from CSSOM Values below.
</li>
</ul>

<div class="example">

<p>
例えば：
◎
For example:
</p>


<pre class="lang-js">
var %length1 = CSSNumericValue.parse("42.0px");
%length1.toString(); // "42.0px"

var %length2 = CSS.px(42.0);
%length2.toString(); // "42px";

element.style.width = "42.0px";
var %length3 = element.attributeStyleMap.get('width');
%length3.toString(); // "42px";
</pre>
</div>



		<section id="unparsedvalue-serialization">
<h3 title="CSSUnparsedValue Serialization">6.1. `CSSUnparsedValue^I の直列化</h3>

<div class="algorithm">
<p>
`CSSUnparsedValue$I %O を
<dfn id="serialize-a-cssunparsedvalue">直列化する</dfn>
ときは：
◎
To serialize a CSSUnparsedValue this:
</p>

<ol>
	<li>
%s ~LET 空`文字列$
◎
Let s initially be the empty string.
</li>
	<li>
<p>
%O の `tokens$sl 内部~slot内の~EACH( %~item ) に対し：
◎
For each item in this’s [[tokens]] internal slot:
</p>
		<ol>
			<li>
%s に［
%~item に応じて，次に与える結果
］を付加する
⇒＃
`DOMString^I ならば %~item ／
`CSSVariableReferenceValue$I であるならば %~item を直列化した結果
◎
If item is a DOMString, append it to s.
◎
Otherwise, item is a CSSVariableReferenceValue. Serialize it, then append the result to s.
</li>
		</ol>
	</li>
	<li>
~RET %s
◎
Return s.
</li>
</ol>
</div>


<div class="algorithm">
<p>
`CSSVariableReferenceValue$I0 %O を
<dfn id="serialize-a-cssvariablereferencevalue">直列化する</dfn>
ときは：
</p>

<ol>
	<li>
%fallback ~LET %O の `fallback$m 内部~slot
</li>
	<li>
~IF［
%fallback ~EQ ~NULL
］
⇒
%fallback ~SET 空~文字列
</li>
	<li>
~ELSE
⇒
%fallback ~SET 次を順に連結した結果
⇒＃
`, ^l,
%fallback を直列化した結果
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`var(^l,
%O の `variable$m 内部~slot,
%fallback,
`)^l
</li>
</ol>

◎
To serialize a CSSVariableReferenceValue this:
• Let s initally be the string "var(".
• Append this’s variable internal slot to s.
• If this’s fallback internal slot is not null, append ", " to s, then serialize the fallback internal slot and append it to s.
• Append ")" to s and return s.
</div>

		</section>
		<section id="keywordvalue-serialization">
<h3 title="CSSKeywordValue Serialization">6.2. `CSSKeywordValue^I の直列化</h3>

<div class="algorithm">

<p>
`CSSKeywordValue$I0 %O を
<dfn id="serialize-a-csskeywordvalue">直列化する</dfn>
ときは：
◎
To serialize a CSSKeywordValue this:
</p>

<ol>
	<li>
~RET %O の `value$m 内部~slot
◎
Return this’s value internal slot.
</li>
</ol>
</div>

		</section>
		<section id="numericvalue-serialization">
<h3 title="CSSUnitValue Serialization">6.3. `CSSUnitValue^I の直列化</h3>

<div class="algorithm">

<p>
`CSSUnitValue$I %O を
<dfn id="serialize-a-cssunitvalue">直列化する</dfn>
ときは：
◎
To serialize a CSSUnitValue this:
</p>

<ol>
	<li>
%単位 ~LET %O の `unit$m1 内部~slot
◎
Let value and unit be this‘s value and unit internal slots.
</li>
	<li>
<p>
~RET 次を順に連結した結果：
◎
↓</p>
		<ol>
			<li>
`CSSOM-1$r に従って，［
%O の `value$m1 内部~slot
］が与える~CSS値から `number$t に
<a href="~CSSOM1#serializing-css-values">直列化-</a>した結果
◎
Set s to the result of serializing a &lt;number&gt; from value, per CSS Object Model (CSSOM) §serializing-css-values.
</li>
			<li>
%単位 に応じて 次に与える文字列
⇒＃
`number^l ならば空~文字列 ／
`percentage^l ならば `%^l ／
~ELSE_ %単位
◎
If unit is "number", return s.
◎
Otherwise, if unit is "percentage", append "%" to s, then return s.
◎
Otherwise, append unit to s, then return s.
</li>
		</ol>
	</li>
</ol>
</div>


		</section>
		<section id="calc-serialization">
<h3 title="CSSMathValue Serialization">6.4. `CSSMathValue^I の直列化</h3>

<div class="algorithm">
<p>
`CSSMathValue$I ~obj %O を直列化するときは、所与の
( 真偽値 %入子あり （省略時は ~F ） , 真偽値 %括弧なし （省略時は ~F ） )
に対し，次を走らす：
◎
To serialize a CSSMathValue this, with additional flags nested, a boolean (defaulting to false if unspecified), and paren-less, a boolean (defaulting to false if unspecified):
</p>

<ol>
	<li>
<p>
~IF［
%O は［
`CSSMathMin$I0 ／
`CSSMathMax$I
］である
］
⇒
~RET 次を順に連結した結果：
◎
Let s initially be the empty string.
◎
If this is a CSSMathMin or CSSMathMax:
</p>
		<ol>
			<li>
%O に応じて
⇒＃
`CSSMathMin$I ならば `min(^l ／
`CSSMathMax$I ならば `max(^l
◎
Append "min(" or "max(" to s, as appropriate.
</li>
			<li>
次の結果を `, ^l で`区切って連結-$した結果
⇒
%O の `values$m 内部~slotを，次に与える`演算で写像する$
⇒
~itemを直列化する( %入子あり ~SET ~T, %括弧なし ~SET ~T ) 
◎
For each arg in this’s values internal slot, serialize arg with nested and paren-less both true, and append the result to s, appending a ", " between successive values.
</li>
			<li>
`)^l
◎
Append ")" to s and return s.
</li>
		</ol>
	</li>
	<li>
%s ~LET 次に与える値
⇒＃
%括弧なし ~EQ ~T ならば 空~文字列 ／
~ELSE_ %入子あり ~EQ ~T ならば `(^l ／
~ELSE_ `calc(^l
◎
↓↓</li>
	<li>
<p>
~IF［
%O は `CSSMathSum$I である
］：
◎
Otherwise, if this is a CSSMathSum:
• If paren-less is true, continue to the next step; otherwise, if nested is true, append "(" to s; otherwise, append "calc(" to s.
</p>
		<ol>
			<li>
<p>
%O の `values$m1 内部~slot内の ~EACH( %~arg ) に対し：
</p>
				<ol>
					<li>
~IF［
この反復は初回である
］
⇒
何もしない
</li>
					<li>
~ELIF［
%~arg は `CSSMathNegate$I である
］
⇒＃
%s に ` - ^l を付加する；
%~arg ~SET %~arg の `value$m1 内部~slot
</li>
					<li>
~ELSE
⇒
%s に ` + ^l を付加する
</li>
				</ol>
◎
Serialize the first item in this’s values internal slot with nested set to true, and append the result to s.
◎
For each arg in this’s values internal slot beyond the first:
• If arg is a CSSMathNegate, append " - " to s, then serialize arg’s value internal slot with nested set to true, and append the result to s.
• Otherwise, append " + " to s, then serialize arg with nested set to true, and append the result to s.
• ↓↓If paren-less is false, append ")" to s,
• ↓↓Return s.
</li>
			<li>
%s に次を付加する
⇒
%~arg を直列化する( %入子あり ~SET ~T )
◎
↑</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%O は `CSSMathNegate$I である
］：
◎
Otherwise, if this is a CSSMathNegate:
• If paren-less is true, continue to the next step; otherwise, if nested is true, append "(" to s; otherwise, append "calc(" to s.
</p>

		<ol>
			<li>
%s に次を順に付加する
⇒＃
`-^l,
%O の `value$m1 内部~slot を直列化する( %入子あり ~SET ~T )
◎
Append "-" to s.
◎
Serialize this’s value internal slot with nested set to true, and append the result to s.
◎
↓↓If paren-less is false, append ")" to s,
◎
↓↓Return s.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%O は `CSSMathProduct$I である
］：
◎
Otherwise, if this is a CSSMathProduct:
• If paren-less is true, continue to the next step; otherwise, if nested is true, append "(" to s; otherwise, append "calc(" to s.
</p>

		<ol>
			<li>
<p>
%O の `values$m1 内部~slot内の ~EACH( %~arg ) に対し：
</p>
				<ol>
					<li>
~IF［
この反復は初回である
］
⇒
何もしない
</li>
					<li>
~ELIF［
%~arg は `CSSMathInvert$I である
］
⇒＃
%s に ` / ^l を付加する；
%~arg ~SET %~arg の `value$m1 内部~slot
</li>
					<li>
~ELSE
⇒
%s に ` * ^l を付加する
</li>
				</ol>
◎
Serialize the first item in this’s values internal slot with nested set to true, and append the result to s.
◎
For each arg in this’s values internal slot beyond the first:
• If arg is a CSSMathInvert, append " / " to s, then serialize arg’s value internal slot with nested set to true, and append the result to s.
• Otherwise, append " * " to s, then serialize arg with nested set to true, and append the result to s.
• ↓↓If paren-less is false, append ")" to s,
• ↓↓Return s.
</li>
			<li>
%s に次を付加する
⇒
%~arg を直列化する( %入子あり ~SET ~T )
◎
↑</li>
		</ol>
	</li>
	<li>
~ELIF［
%O は `CSSMathInvert$I である
］
⇒
%s に次を順に付加する
⇒＃
`1 / ^l,
%O の `value$m1 内部~slotを直列化する( %入子あり ~SET ~T )
◎
Otherwise, if this is a CSSMathInvert:
• If paren-less is true, continue to the next step; otherwise, if nested is true, append "(" to s; otherwise, append "calc(" to s.
• Append "1 / " to s.
• Serialize this’s value internal slot with nested set to true, and append the result to s.
• ↓↓If paren-less is false, append ")" to s,
• ↓↓Return s.
</li>
	<li>
~IF［
%括弧なし ~EQ ~F
］
⇒
%s に `)^l を付加する
◎
↑↑</li>
	<li>
~RET %s
◎
↑↑</li>
</ol>
</div>

		</section>
		<section id="transformvalue-serialization">
<h3 title="CSSTransformValue and CSSTransformComponent Serialization">6.5. `CSSTransformValue^I, `CSSTransformComponent^I の直列化</h3>

<div class="algorithm">

<p>
`CSSTransformValue$I %O を
<dfn id="serialize-a-csstransformvalue">直列化する</dfn>
ときは：
◎
To serialize a CSSTransformValue this:
</p>

<ol>
	<li>
~RET 次の結果を ` ^l で`区切って連結-$した結果
⇒
%O の`変形~成分~list$を［
~itemを直列化する
］`演算で写像する$
◎
Return the result of serializing each item in this’s values to iterate over, then concatenating them separated by " ".
</li>
</ol>
</div>

<div class="algorithm">

<p>
`CSSTranslate$I0 %O を
<dfn id="serialize-a-csstranslate">直列化する</dfn>
ときは：
◎
To serialize a CSSTranslate this:
</p>

<ol>
	<li>
( %x, %y, %z ) ~LET 順に， %O の［
`x$m, `y$m, `z$m
］内部~slotを直列化した結果
◎
↓</li>
	<li>
~IF［
%O の `CSSTransformValue^II `is2D$m1 内部~slot ~EQ ~T
］
⇒
~RET 次を順に連結した結果
⇒＃
`translate3d(^l,
%x,
`, ^l,
%y,
`, ^l,
%z,
`)^l
◎
Let s initially be the empty string.
◎
If this’s is2D internal slot is true:
• Append "translate3d(" to s.
• Serialize this’s x internal slot, and append it to s.
• Append ", " to s.
• Serialize this’s y internal slot, and append it to s.
• Append ", " to s.
• Serialize this’s z internal slot, and append it to s.
• Append ")" to s, and return s.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`translate(^l,
%x,
`, ^l,
%y,
`)^l
◎
Otherwise:
• Append "translate(" to s.
• Serialize this’s x internal slot, and append it to s.
• Append ", " to s.
• Serialize this’s y internal slot, and append it to s.
• Append ")" to s, and return s.
</li>
</ol>

</div>

<div class="algorithm">

<p>
`CSSRotate$I0 %O を
<dfn id="serialize-a-cssrotate">直列化する</dfn>
ときは：
◎
To serialize a CSSRotate this:
</p>

<ol>
	<li>
( %x, %y, %z, %a ) ~LET 順に， %O の［
`x$m, `y$m, `z$m, `angle$m
］内部~slotを直列化した結果
◎
↓</li>
	<li>
%s ~LET 空`文字列$
◎
Let s initially be the empty string.
</li>
	<li>
~IF［
%O の `CSSTransformValue^II `is2D$m1 内部~slot ~EQ ~T
］
⇒
~RET 次を順に連結した結果
⇒＃
`rotate3d(^l,
%x,
`, ^l,
%y,
`, ^l,
%z,
`,^l,
%a,
`)^l
◎
If this’s is2D internal slot is true:
• Append "rotate3d(" to s.
• Serialize this’s x internal slot, and append it to s.
• Append ", " to s.
• Serialize this’s y internal slot, and append it to s.
• Append ", " to s.
• Serialize this’s z internal slot, and append it to s.
• Append "," to s.
• Serialize this’s angle internal slot, and append it to s.
• Append ")" to s, and return s.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`rotate(^l,
%a,
`)^l
◎
Otherwise:
◎
Append "rotate(" to s.
• Serialize this’s angle internal slot, and append it to s.
• Append ")" to s, and return s.
</li>
</ol>
</div>

<div class="algorithm">

<p>
`CSSScale$I0 %O を
<dfn id="serialize-a-cssscale">直列化する</dfn>
ときは：
◎
To serialize a CSSScale this:
</p>

<ol>
	<li>
( %x, %y, %z ) ~LET 順に， %O の［
`x$m, `y$m, `z$m
］内部~slotを直列化した結果
◎
↓</li>
	<li>
<p>
~IF［
%O の `CSSTransformValue^II `is2D$m1 内部~slot ~EQ ~F
］
⇒
~RET 次を順に連結した結果
⇒＃
`scale3d(^l,
%x,
`, ^l,
%y,
`, ^l,
%z,
`)^l
◎
Let s initially be the empty string.
◎
If this’s is2D internal slot is true: ＊原文誤 false
• Append "scale3d(" to s.
• Serialize this’s x internal slot, and append it to s.
• Append ", " to s.
• Serialize this’s y internal slot, and append it to s.
• Append ", " to s.
• Serialize this’s z internal slot, and append it to s.
• Append ")" to s, and return s.
</li>
	<li>
~IF［
%O の
( `x$m 内部~slot, `y$m 内部~slot )
は`等しい数量~値$である
］
⇒
~RET 次を順に連結した結果
⇒＃
`scale(^l,
%x,
`)^l
◎
Otherwise:
• Append "scale(" to s.
• Serialize this’s x internal slot, and append it to s.
◎
If this’s x and y internal slots are equal numeric values, append ")" to s and return s.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`scale(^l,
%x,
`, ^l,
%y,
`)^l
◎
Otherwise, append ", " to s.
• Serialize this’s y internal slot, and append it to s.
• Append ")" to s, and return s.
</li>
</ol>
</div>

<div class="algorithm">

<p>
`CSSSkew$I0 %O を
<dfn id="serialize-a-cssskew">直列化する</dfn>
ときは：
◎
To serialize a CSSSkew this:
</p>

<ol>
	<li>
( %ax, %ay ) ~LET 順に， %O の［
`ax$m, `ay$m
］内部~slotを直列化した結果
◎
↓</li>
	<li>
~IF［
%O の `ay$m 内部~slotは `CSSUnitValue$I であって，その `value$m1 ~EQ 0
］
⇒
~RET 次を順に連結した結果
⇒＃
`skew(^l,
%ax,
`)^l
◎
Let s initially be a string containing "skew(".
◎
Serialize this’s ax internal slot, and append it to s.
◎
If this’s ay internal slot is a CSSUnitValue with a value of 0, then append ")" to s and return s.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
`skew(^l,
%ax,
`, ^l,
%ay,
`)^l
◎
Otherwise, append ", " to s.
• Serialize this’s ay internal slot, and append it to s.
• Append ")" to s, and return s.
</li>
</ol>
</div>

<p class="algorithm">
`CSSSkewX$I0 %O を
<dfn id="serialize-a-cssskewx">直列化する</dfn>
ときは、次を順に連結した結果を返す
⇒＃
`skewX(^l,
%O の `ax$m 内部~slotを直列化した結果,
`)^l
◎
To serialize a CSSSkewX this:
• Let s initially be a string containing "skewX(".
• Serialize this’s ax internal slot, and append it to s.
• Append ")" to s, and return s.
</p>

<p class="algorithm">
`CSSSkewY$I0 %O を
<dfn id="serialize-a-cssskewy">直列化する</dfn>
ときは、次を順に連結した結果を返す
⇒＃
`skewX(^l,
%O の `ay$m 内部~slotを直列化した結果,
`)^l
◎
To serialize a CSSSkewY this:
• Let s initially be a string containing "skewX(".
• Serialize this’s ay internal slot, and append it to s.
• Append ")" to s, and return s.
</p>

<p class="algorithm">
`CSSPerspective$I0 %O を
<dfn id="serialize-a-cssperspective">直列化する</dfn>
ときは、次を順に連結した結果を返す
⇒＃
`perspective(^l,
%O の `length$m 内部~slotを直列化した結果,
`)^l
◎
To serialize a CSSPerspective this:
• Let s initially be a string containing "perspective(".
• Serialize this’s length internal slot, and append it to s.
• Append ")" to s, and return s.
</p>

<p class="algorithm">
`CSSMatrixComponent$I0 %O を
<dfn id="serialize-a-cssmatrixcomponent">直列化する</dfn>
ときは、次の結果を返す
⇒
%O の `matrix$m 内部~slotの<a>直列化</a>
【この直列化は、まだ定義されていない。】
◎
To serialize a CSSMatrixComponent this:
• Return the serialization of this’s matrix internal slot.
</p>


		</section>
		<section id="positionvalue-serialization">
<h3 title="CSSPositionValue Serialization">6.6. `CSSPositionValue^I の直列化</h3>

<div class="algorithm">

<p>
`CSSPositionValue$I ~obj %O を直列化した結果は
⇒
［
%O の［
`x$m1, `y$m1
］属性~値を，それぞれ上の `CSSNumericValue$I ~obj用の規則に則って順に直列化した結果
］を~spaceで区切って順に連結した結果とする。
◎
CSSPositionValue objects are serialized by:
• serializing the x attribute according to the rules for CSSNumericValue objects above.
• serializing the y attribute according to the rules for CSSNumericValue objects above.
• returning the concatenation of the two serializations (x before y), separated by a space.
</p>
</div>


		</section>
		<section id="urlimagevalue-serialization">
<h3 title="CSSURLImageValue Serialization">6.7. `CSSURLImageValue^I の直列化</h3>

<div class="algorithm">
<p>
`CSSURLImageValue$I ~obj %O を直列化するときは、次を順に連結した結果を返す
⇒＃
`url("^l,
%O の `url$m1 値,
`")^l
◎
CSSURLImageValue objects are serialized to the string given by 'url("' + url + '")'.
</p>
</div>


		</section>
		<section id="cssom-serialization">
<h3 title="Serialization from CSSOM Values">6.8. ~CSSOMからの値の直列化</h3>


<p>
~UAにより~CSSOM内の値から生産され，作者により直接的に構築されていない
`CSSStyleValue$I ~objは、どの~propから得られたかに応じて，次の規則に則って直列化される
【以下に現れる~CSS~keyword値は、すべて小文字に正規化されているとする】
：
◎
CSSStyleValue objects produced by the user agent from values in the CSSOM, rather than directly constructed by the author, are serialized according to the following rules, depending on the property they came from:
</p>


<dl>
	<dt>`background-color$p</dt>
	<dd>
`color$p に対するときと同じ。
◎
If the value is the currentcolor keyword, return "currentcolor".
◎
Otherwise, return the result of serializing the &lt;color&gt; value.
</dd>

	<dt>`border-color$p</dt>
	<dd>
`color$p に対するときと同じ。
◎
If the value is the currentcolor keyword, return "currentcolor".
◎
Otherwise, return the result of serializing the &lt;color&gt; value.
</dd>

	<dt>`border-image$p</dt>
	<dd>
		<ol>
			<li>
%値~list ~LET 空`~list$
◎
Let values initially be the empty list.
</li>
			<li>
~IF［
`border-image-source$p ~NEQ `none^v
］
⇒
%値~list に `border-image-source$p を直列化した結果を付加する
◎
If border-image-source is not none, serialize border-image-source and append it to values.
</li>
			<li>
~IF［
`border-image-slice$p は［［
すべての側に `100%^v を指定している
］でない
］~AND［
`fill$v ~keywordを省略している
］］
⇒＃
%値~list に `border-image-slice$p を直列化した結果を付加する
◎
If border-image-slice does not specify 100% for all sides and omits the fill keyword, serialize border-image-slice and append it to values.
</li>
			<li>
%接頭辞 ~LET  `// ^l （ `002F^U, `002F^U, `0020^U ）
◎
↓</li>
			<li>
<p>
~IF［
`border-image-width$p は ある側に `1^v 以外を指定している
］：
</p>
				<ol>
					<li>
%接頭辞 ~SET `/ ^l （ `002F^U, `0020^U ）
</li>
					<li>
%値~list に［
次を順に連結した結果
］を付加する
⇒＃
%接頭辞,
`border-image-width$p を直列化した結果
</li>
				</ol>
<!-- 
append "/" = prepend ？
紛らわしい
 -->
◎
If border-image-width does not specify 1 for all sides, append "/ " (U+002F FORWARD SLASH followed by U+0020 SPACE) to the result of serializing border-image-width and append it to values.
</li>
			<li>
<p>
~IF［
`border-image-outset$p は ある側に `0^v 以外を指定している
］
⇒
%値~list に［
次を順に連結した結果
］を付加する
⇒＃
%接頭辞,
`border-image-outset$p を直列化した結果
◎
If border-image-outset does not specify 0 for all sides:
• ↑If the previous border-image-width step did not append anything to values, let prefix be "// " (two U+002F FORWARD SLASH characters followed by U+0020 SPACE); otherwise let prefix be "/ " (U+002F FORWARD SLASH followed by U+0020 SPACE)
• Append prefix to the result of serializing border-image-outset and append it to values.
</li>
			<li>
~IF［
`border-image-repeat$p は両~軸とも `stretch$v でない
］
⇒
%値~list に`border-image-repeat$p を直列化した結果を付加する
◎
If border-image-repeat is not stretch in both axises, serialize border-image-repeat and append it to values.
</li>
			<li>
~IF［
%値~list は`空$である
］
⇒
%値~list に `none^l を付加する
◎
If values is empty, append "none" to values.
</li>
			<li>
~RET %値~list を ` ^l ( `0020^U ) で`区切って連結-$した結果
◎
Return the result of concatenating all the items in values, separated by " " (U+0020 SPACE).
</li>
		</ol>
	</dd>

	<dt>`bottom$p</dt>
	<dd>
`top$p に対するときと同じ。
◎
If the value is the auto keyword, return "auto".
◎
If the value is of type &lt;length&gt;, return the result of serializing the &lt;length&gt; value.
◎
Otherwise, return the result of serializing the &lt;percentage&gt; value.
</dd>

	<dt>`color$p</dt>
	<dd>
		<ol>
			<li>
~IF［
~propの値は `currentcolor$v ~keyword
］
⇒
~RET  `currentcolor^l
◎
If the value is the currentcolor keyword, return "currentcolor".
</li>
			<li>
~RET `color$t 値を直列化した結果
◎
Otherwise, return the result of serializing the &lt;color&gt; value.
</li>
		</ol>
	</dd>

	<dt>`left$p</dt>
	<dd>
`top$p に対するときと同じ。
◎
If the value is the auto keyword, return "auto".
◎
If the value is of type &lt;length&gt;, return the result of serializing the &lt;length&gt; value.
◎
Otherwise, return the result of serializing the &lt;percentage&gt; value.
</dd>

	<dt>`opacity$p</dt>
	<dd>
		<ol>
			<li>
~IF［
~propの値は `number$t 型である
］
⇒
~RET  `number^t 値を直列化した結果
◎
If the value is of type &lt;number&gt;, return the result of serializing the &lt;number&gt; value.
</li>
			<li>
~RET `percentage$t 値を直列化した結果
◎
Otherwise, return the result of serializing the &lt;percentage&gt; value.
</li>
		</ol>
	</dd>


	<dt>`right$p</dt>
	<dd>
`top$p に対するときと同じ。
◎
If the value is the auto keyword, return "auto".
◎
If the value is of type &lt;length&gt;, return the result of serializing the &lt;length&gt; value.
◎
Otherwise, return the result of serializing the &lt;percentage&gt; value.
</dd>

	<dt>`top$p</dt>
	<dd>
		<ol>
			<li>
~IF［
~propの値は `auto$v ~keyword
］
⇒
~RET  `auto^l
◎
If the value is the auto keyword, return "auto".
</li>
			<li>
~IF［
~propの値は `length$t 型である
］
⇒
~RET `length$t 値を直列化した結果
◎
If the value is of type &lt;length&gt;, return the result of serializing the &lt;length&gt; value.
</li>
			<li>
~RET `percentage$t 値を直列化した結果
◎
Otherwise, return the result of serializing the &lt;percentage&gt; value.
</li>
		</ol>
	</dd>
</dl>



		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">7. ~security 考慮点</h2>


<p>
これらの特色機能により導入される既知の~security課題は無い。
◎
There are no known security issues introduced by these features.
</p>



	</section>
	<section id="privacy-considerations">
<h2 title="Privacy Considerations">8. ~privacy 考慮点</h2>


<p>
これらの特色機能により導入される既知の~privacy課題は無い。
◎
There are no known privacy issues introduced by these features.
</p>


	</section>

</main></div>

<!-- TODO
	`values$m1, `value$m1 総称
 -->