<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Mixed Content（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<!--%script -->
<script >
var source_data;

COMMON_DATA.page_state_key = 'webappsec';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://w3c.github.io/webappsec-mixed-content/',
		spec_status: 'ED',
		main: 'MAIN',
		fill_text_link: '#_versions > dd',
		ref_data: '.ref_data',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:英語+漢字:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked 160523 spec

	return options;
}

function expand(mapping1){
	var link_map = this.link_map;
	var nesting = '';
	var class_map = {
		P: 'production', // protocol element
		dir: 'directive',
		h: 'header',
		e: 'element',
		a: 'attr',
		et: 'event-type',
		css: 'css',
		E: 'error',
		tnote: 'trans-note',
	};
	var tag_map = {
		P: 'code',
		dir: 'code',
		h: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		css: 'code',
		I: 'code',
		m: 'code',
		E: 'code',
		v: 'var',
		c: 'code',
		s: 'samp',
		i: 'i',
		tnote: 'span'
	}

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/◎[^`<◎]*|⇒|【.*?】|%[\u4E00-\u9FFF~\w\-]+|`(.*?)([$@^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {
	switch(match.charAt(0)){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}
	//◎
	var result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // 文献
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'l': //literal
	return '"<code class="literal">' + key +'</code>"'
	break;
}

if(tag) {
	text = '<' + tag +
		(classname ? ' class="' + classname + '">' : '>') +
		text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}
</script>


<!--%語彙 -->
<script type="text/plain" id="words_table">

	ABNF:
	API:
	Document:
	NPAPI
	Integrity
	SVG
Service-Worker:Service Worker
UI:
Worker:
	Working Group


	●仕様
UA:user agent:UA
hook::::フック
	hooking
team::::
critical::::
access::::アクセス
accessibility::::アクセス容易性:アクセシビリティ
algo:algorithm:::アルゴリズム
app:application:::アプリ
bug::::バグ
feedback::::フィードバック
registry::::レジストリ
vendor::::ベンダ
version::::バージョン
	~~提出:file
opt-in::::オプトイン
	取り入れる
	opting-in
option::::オプション
一般:general:~
上書き:override:~
不作為:inadvertent:~
不用意:accidental:~
世界:world:~
	両者:both:~
中心的な:central:~
主張-:claim:~
期待:expectation:~
原則:principle:~
保証:guarantee:~
事例:case:~
	事実:fact:~
	からといって:fact:~
今日:today:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
代表的:typical:~
作者:author:~
依拠-:rely:~
保つ:keep する:~
可能0:possible:可能
各種用語:terminology:~
変更点:changes:~
	-:variant:~
奨励-:encourage:~
	ないことを奨励:discourage:~
実装-:implement:~
定義-:define:~
定義:definition:~
実施上は:practical には:~
実用上は:practical には:~
実用的:practical:~
	実用的でない:impractical:~
実際:actual:~
将来:future:~
導入-:introduce:~
広範:wide:~
念頭:mind:~
意味-:mean:~
意図-:intend:~
意図:intent:~
指図-:instruct:~
指定-:specify:~
指示-:indicate:~
指示:indication:~
指示子:indicator:~
挙動:behavior:ふるまい
推奨-:recommend:~
提供-:provide:~
提供0-:offer:提供
支援技術:assistive technologies:~
暗黙的:implicit:~
最善:best:~
有意:significant:~
概説する:outline する:要旨を述べる
概説した:outline した:要旨を述べた

	求め:want:~
	決して:never:~
	決め-:decide:~
決定-:determine:~
決定:determination:~
混同-:confuse:~
	confusion
無関係な:unrelated:~
特定0の:particular:ある特定の
特徴:characteristic:~
特色機能:feature:~
目標:goal:~
考慮点:considerations:~
熟慮:careful consideration:~
要件:requirement:~
要件:requirements:~
要求-:require:~
	要約:abstract:~
見なさ:consider さ:~
規範的:normative:~
解釈-:interpret:~
設計-:design:~
説明-:explain:~
相当:substantial:~
確保-:ensure:~
示唆:suggestion:~
示唆-:suggest:~
健全:sane:~
共通的:common:~
利点:advantage:~
利用者:user:~:::ユーザ
	利用者:she:~
	利用者の:her:~
	利用-:use:~
制作-:produce:~
制約-:restrict:~
制約:restriction:~
制限-:limit:~
限界:limitation:~
劣化-:degrade:~
	劣化ing:degrading:~
単純:simple:~
取扱う:handle する:取り扱う
可用:available:~
効果:effect:~
述べた:describe した:~
述べら:describe さ:~
述べる:describe する:~
追加:addition:~
課題:issue:~
論じた:discuss した:~
論じら:discuss さ:~
通常は:normal には:~
達成-:achieve:~
降格-:downgrade:~
除外-:exclude:~
適切:appropriate:~
適合性:conformance:~
適正:proper:~
適用-:apply:~
開発者:developer:~
関係する:related:~
分類法:categorization:~
分類:category:~
分類-:categorize:~
公式的:formal:~
	低~risk:low-risk:~
	おそれ:risk
決断:decision:決定
按配よく:nuanced に:~
正誤表:errata:~
見做せる:assume できる:~
試みる:attempt する:~
詳細:details:~
用語:term:~
能:ability:~
詳細:details:~
認識-:recognize:~
特別:special:~
概念:concept:~
立場-:position:~
手段:means:~
手続き:steps:~
抑制-:reduce:~
抑止-:suppress:~
利用率:usage:~
	用法／使われ

	依然として:still:~
	利する:behalf of
	対象にする:cover:~
	則って:according:~
	ほぼ至る所:near ubiquitious::~
	最終的な:the end
	今の所は:for now

	形作る:carveout
	箇所:carveout
	carve-out
	carve

	もちろん:of course
	対処する:deal with
	扱って:dealing with
	取り下げ:drop
	選択肢:choice
	confusing
	何らかの類の:some sort of
	用立てる:make use of
	〜過ぎ:too
	時を経るに伴い:as time goes on
	好例:good example
	該当する:falls into
	等々:and so on
	具体例として:for instance
	頃から:around
	およそ、〜ことになる:presumably
	である限り:provided
	されるべき:ought
	計り知れなく~~寄与された:invaluable
	集め:gather
	ごく説明的なもの:super hand-wavey
	特に:really:
	手入れ:trim
	してくれる:upheld
	ごく:very
	禁じられる:banned from
	そのようなわけで:To this end
	一部:part of
	済ますわけにはいかない:can’t get away
	以上の:above and beyond
	採る:take する:~
	それ自体:in and of itself
	のみならず:not only
	勧告候補:CR
	年月にわたり:over the years
	向けの:-facing
	in order to
	避ける:avoid:~
	見よ:see:~
	謝辞:acknowledgement:~
	重要な点として:importantly:~
	関する:regarding:~
	類似する:similar:~
	例:example:~
	個々の:individual:~
	常に:always:~
	全面的に:outright:~
	必要:need:~
	必要とされ:necessary:~
	必要性:necessity:~
	扱い:treatment:~
	扱う:treat:~
	更:further:~
	~~主要な:key:~


	●network
CSP:
Fetch:
HTTP:
HTTPS:
Internet:
URL:
WebSocket:
cookie::::
channel::::チャンネル
url::::
web::::
site::::サイト
	~web~site:website
fetch::::
fetching:::fetch 処理
navi:navigation:::ナビ
form::::フォーム
network::::ネットワーク
流れる:flow する:~
cache::::キャッシュ
client::::クライアント
TLS-handshake::::TLS ハンドシェイク
header::::ヘッダ
page::::ページ
redirect::::リダイレクト
scheme::::スキーム
server::::サーバ
service::::サービス
service-worker:service worker
window:
伝送路:wire::~
読取って:read して:読み取って
	読込-:load:~
	読込み:load され:読み込まれ
読込まれ:load され::読み込まれ::ロードされ
読込み:loading::読み込み::ローディング
読込む:load する::読み込む::ロードする
読込んだ:load した::読み込んだ::ロードした
提出:submission::~
送達-:deliver:~
通信-:communicate:~
通信:communication:~
	やりとり:communication
受信-:receive::~
送信-:send::~
通過:passthrough::~
接続-:connect::~::コネクト
接続:connection::~::コネクション
経由-:hop::~
発行-:make:~
起動元:initiator::~
応答-:respond::~::レスポンド
応答:response::~::レスポンス
要請:request::~::リクエスト
確立-:establish:~
行先:destination::~
不透明な:opaque::~
絞込み:filtered::~
昇格-:upgrade::~::アップグレード
昇格:upgrade::~::アップグレード
	通じて:over
	上層:top of
	重ねる:layer

	●mixed／CSP
指令:directive::~::ディレクティブ
混在:mixed::~
報告-:report::~
違反:violation::~
通知-:notify:~
資源:resource::~:リソース
下位資源:subresource::~:下位リソース
検査-:check::~::チェック
検査:check::~::チェック
	検査-法:checking
検分-:examine:~
検出-:detect:~
検証0-:verify:検証
継承-:inherit:~
	継承-法:inheriting
埋込まれ:embed され::埋め込まれ
埋込まな:embed しな::埋め込まな
埋込みの:embedded::埋め込みの
埋込む:embed する::埋め込む
埋込める:embed できる::埋め込める
埋込元:embedder::埋め込み元
埋込んで:embed して::埋め込んで
	embedding
先天的:a priori:~
後天的:a posteriori:~
厳格:strict::~
施策:policy::~:ポリシー
施行-:enforce::~
許容-:allow::~
許容ed:Allowed::許容される
阻止-:block::~::ブロック
阻止法:blocking::~::ブロック法
阻止ed:Blocked::阻止される::ブロックされる
阻止可能:blockable::~::ブロック可能
	随意に阻止可能:optionally-blockable:~
随意:optional::~
禁制-:prohibit:~
禁制:prohibit:~
状態0:status::状態
状態:state::~
大域:global::~::グローバル

	●保安
property::::プロパティ
token::::トークン
privacy::::プライバシー
risk::::リスク
alert:

流通:traffic::~::トラフィック
主体:entity:~
中間者:man-in-the-middle:~
介在者:middlemen:~
仲介-:mediate:~

保安:security::~:セキュリティ
保安的:secure::~:セキュア
非保安的:insecure::~:非セキュア


保護-:protect:~
保護:protection:~
被保護:protected:~
弱めら:weaken さ:~
弱体化-:compromise:~
強く:strong に:~
強制-:force:~
	強制的に
強度:strength:~
強要-:coerce:~
攻撃:attack:~
攻撃者:attacker:~
暗号化-:encrypt::~
暗号化:encryption::~
	暗号化されてない:unencrypted:~
完全性:integrity::~
盗聴-:eavesdrop:~
確約-:assure:~
確約:assurance:~
能動的:active:~
脅威:threat:~
裏口:back door:~
自明:trivial:~
安全:safe:~
表明:assert:~
表明:assertion:~
証明書:certificate:~
認証-:authenticate::~
認証:authentication::~
未認証の:unauthenticated::~
未認証:unauthenticated::~
認証済み:authenticated::~
警告-:warn:~
警告:warning:~
軽減-:mitigate:~
迂回-:bypass:~
防止-:prevent:~
洗浄する:launder する:仕立て上げる
重視-:outweigh:~
破滅的:catastrophic:~
危険:dangerous:~
無防備:wide open:~
	疑念なく:in the clear
実害:real impact:~
	抗して:against:~
	改ざんされた:corrupted:~
傍受:interception:~

	●未分類
bit::::ビット
code::::コード
call:
console-message:console message:::コンソールメッセージ
data::::データ
error::::エラー
event::::イベント
field::::フィールド
flag::::フラグ
handler::::ハンドラ
icon::::アイコン
instance::::インスタンス
interface::::インタフェース
level::::レベル
list::::リスト
mode::::モード
obj:object:::オブジェクト
plugin::::プラグイン
script::::スクリプト
	特別に扱うspecial-case::::
tag::::タグ
target::::
top-level::::トップレベル
worker::::
frame::::フレーム
	framed
email::::メール
下位集合:subset:~
親:parent:~
閲覧文脈:browsing context::~
環境:environment:~
入子に:nest:入れ子に
入子の:nested:入れ子の
関連する:relevant な:~
捕えれ:catch でき:~
環境設定-:configure:~
設定-:set:~
設定:setting:~
設定群:settings:~
構築子:constructor:~
構築-:construct:~
失敗-:fail:~
中止-:abort:~
公開-:expose:~
具現化-:render::~::レンダー
包含-:contain:~
参照-:reference:~
反映-:reflect:~
取得-:get:~
可能化-:enable:~
合成-:synthesize:~
実行-:execute:~
実行:executing:~
実行可能:executable:~
生成-:generate:~
続行-:proceed:~
置換-:replace:~
	代用-:replace:~
表示-:display:~
誘発-:trigger:~
除去-:remove:~
提示-:present:~
在する:present する:在る
	在:presence:存在
存在0:presence:存在
改変-:modify:~
改変:modification:~
更新-:update:~
作成-:create:~
遂行-:perform:~
保持-:hold:~


体験:experience:~
例外:exception:~
	もれなく:exception:~
	満たす
名:name:~
	名前
値:value:~
集合:set:~
内側:inside:~
内容:content:~
生成元:origin:~
出自:origin:~
出自に:originate:~


初期:initial:~
制御:control:~
動作:action:~
十分:sufficient:~
外側:outside:~

孕む:involve する:~
理想:perfect:~

所与の:given:与えられた
局面:scenario:~
属性:attribute:~
	序論:introduction:~
成功-:succeed:~
成功裡:successful:~
投出:throw:~
	一貫する:consistent:~
文書:document:~
文法:grammar:~
	参照先:references:~
文脈:context:~
新たな:new:~
既存の:existing:~
早期の:early:~
	最初の:first:~

	後者:latter:~
期間:period:~

条件:condition:~
段:step:~
現在:currently:~
現在の:current:~
画像:image:~
直接的:direct:~
種別:type:~
	種:kind:~
細かい:granular な:~
組合せ:combination:~
	結果:result:~
	し続ける:continue:~
自動的:automatic:~
複製:copy:~
要素:element:~
音声:audio:~
動画:video:~

担当の:responsible:~
	担当する:responsible:~
部位:portion:範囲
壊す:break する:~
叩かな:hit しな:~

	〜に基づく:based:~
	〜の代わりに:instead:~
	あいにく:unfortunately:~
	おそらく:probably:~
	おそれ:fear:~
	この:this:~
	これらの:these:~
	ごく:quite:~
	しかしながら，:however:~
	したがって:therefore:~
	すべての:all:~
	その:that:~
	そのような:such:~
	それも，:caveat:~
	それら:they:~
	それらの:those:~
	それらを:them:~
	べき:should:~
	べく:intent:~
	まるごと:entirely:~
	一つ:one:~
	一体として／:together:~
	三つ:three:~
	上:above:~

	encrypted:~
	与-:give:~
	2 つ:two:~
	2 番目の:second:~
	介:via:~
	他の:other:~
	他の場合:otherwise:~
	元々:originally:~
	元の:original:~
	各:each:~
	同じ:same:~
	含-:include:~
	多い:often:~
	後:after:~
	数:number:~
	数多の:many, many:~
	現れ:appear:~
	生-:occur:~
	等々:etc:~
	節:section:~
	終えた:finish:~
	自身:itself:~
	返す:return:~
	逆に:reverse:~
	通:through:~
	選ぶ:choose:~
	高く／高:high:~
	Chrome
	~data ~bit~s
	低い:low
	“~~削除” “~~返信”:"Delete email" and "Reply"

	across
	最後の方:at the bottom
	最初の方:at the top
	end
enter:
	everything
	filed
	注目:focused
	強制的に失敗させるforce-failing
	合間に居座る:sit inbetween
	found
	gave
	goes
	help
	helped
	said
	seem
	shocking amounts of work
	もの:signal
	剥ぎ取るstrip
	toward
	we
	賞賛すべきwonderful
	~risk下:at-risk:
	低い~less
	CORS が可能化:CORS-enabled
	-:split:~
	10 年:decade:~
	-:indeed:~

	入って来る:incoming
	-:informative
	know

	no longer
	失われ:lost
	lots of
	made
	moving
	nor
	note
	nothing
	part
	past
	place
	potentially
	準備:preparing
</script>

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
</script>

<!--%置換語 -->
<script type="text/plain" id="words_table1">
RFC6455:RFC6455-ja.html
SW:http://www.w3.org/TR/service-workers/
	http://tools.ietf.org/html/rfc6455
data_scheme:<code class="scheme">data:</code>
</script>


<!--%links -->

<script type="text/plain" id="_link_map">
文書:#_document
	~HTMLdom#document
I.Document:~HTMLdom#document
I.EventSource:http://www.w3.org/TR/eventsource/#the-eventsource-interface
I.ServiceWorkerGlobalScope:~SW#service-worker-global-scope
I.ServiceWorker:~SW#service-worker-interface
I.WebSocket:~WEBSOCKET#the-websocket-interface
I.Window:~BROWSERS#window
I.XMLHttpRequest:~XHR#interface-xmlhttprequest
I.WorkerGlobalScope:~WORKERS#workerglobalscope

m.WebSocket():~WEBSOCKET#dom-websocket
m.onerror:~WEBSOCKET#handler-websocket-onerror
m.fetch():~FETCH#dom-global-fetch
m.onfetch():~SW#service-worker-global-scope-onfetch-attribute

et.fetch:~SW#service-worker-global-scope-fetch-event

e.meta:~HEmetadata#the-meta-element
	~HTML51/document-metadata.html#the-meta-element

e.form:~HEforms#the-form-element
	~HTML51/sec-forms.html#the-form-element
e.picture:~HEimages#the-picture-element
e.img:~HEimages#the-img-element
e.source:~HEimages#the-source-element
e.video:~HEmedia#the-video-element
e.audio:~HEmedia#the-audio-element
	~HTMLemb = ~HTML51/semantics-embedded-content.html

a.action:~HTMLforms#attr-fs-action
	a.action:~HTML51/element-attrdef-form-action

a.crossorigin:~HEimages#attr-img-crossorigin

l.block-all-mixed-content:#block-all-mixed-content
dir.block-all-mixed-content:#block-all-mixed-content
dir.img-src:~CSP3#directive-img-src

h.Content-Security-Policy:~CSP3#header-content-security-policy
P.directive-name:~CSP3#grammardef-directive-name
P.directive-value:~CSP3#grammardef-directive-value

css.background-image:~CSSBG#background-image
css.border-image:~CSSBG#border-image


	If a request proceeds:#should-block-fetch

先天的に認証済み~URL:#a-priori-authenticated-url
	a priori authenticated URLs:#a-priori-authenticated-url
	a priori authenticated:#a-priori-authenticated-url
埋込んでいる文書:#embedding-document
	埋込んでいる:#embedding-document
混在~内容:#mixed-content
	混在:#mixed-content
阻止可能:#blockable
阻止可能な内容:#category-blockable
随意に阻止可能:#optionally-blockable
随意に阻止可能な内容:#category-optionally-blockable

通過~要請:#passthrough-request
	＊混在~内容の検査~厳格化~flag:
混在~内容の厳格な検査-法~flag
厳格~検査~flag:#strict-mixed-content-checking-flag
厳格~mode:#strict-mode
未認証の応答:#unauthenticated-response
未認証:#unauthenticated-response

	~§1~Introduction:#intro
	~§4.2~Opting-in:#strict-opt-in
~opt-inの継承-法 節:#strict-nesting
設定群は混在~保安的~文脈を禁制するか？:#categorize-settings-object
要請の~fetchingは混在~内容として阻止されるべきか？:#should-block-fetch
要請に対する応答は混在~内容として阻止されるべきか？:#should-block-response
	~§6~Modifications~to~WebSocket~sに対する改変:#websockets-integration

~UIに課される要件 節:#requirements-ux
利用者による制御 節:#requirements-user-controls
	~service~worker:#service-workers
更なる動作 節:#further-action

	~REALLY~SHOULD~NOT:http://tools.ietf.org/html/rfc6919#section-3
	~bug~#28841:https://www.w3.org/Bugs/Public/show_bug.cgi?id=28841
	正誤表#4398:http://www.rfc-editor.org/errata_search.php?rfc=6455&amp;eid=4398
	節~5.3:http://www.w3.org/TR/wsc-ui/#securepage
	通~which:~BROWSERS#browsing-context-nested-through
	“混在~内容”:~TR/2008/REC-xml-20081126/#sec-mixed-content

~URLは信用に価し得るか？:~SECURE-CONTEXT#is-url-trustworthy

rq.~URL:~FETCH#concept-request-url
rq.~window:~FETCH#concept-request-window
rq.~client:~FETCH#concept-request-client
rq.~mode:~FETCH#concept-request-mode
rq.~target閲覧文脈:#
	＊~FETCH#concept-request-target-browsing-context
rq.~url:~FETCH#concept-request-url
rq.種別:~FETCH#concept-request-type
rq.行先:~FETCH#concept-request-destination
rq.起動元:~FETCH#concept-request-initiator
rs.~HTTPS状態:~FETCH#concept-response-https-state
rs.~url:~FETCH#concept-response-url
~navi要請:~FETCH#navigation-request
不透明な絞込み応答:~FETCH#concept-filtered-response-opaque
応答:~FETCH#concept-response
要請:~FETCH#concept-request
~scheme:~URLSpec#concept-url-scheme

~plugin:~HTMLINFRA#plugin
	＊？
~HTTPS状態:~WAPI#https-state
	＊~FETCH#concept-response-https-state
~CSP~list:~HTMLdom#concept-document-csp-list
	EV status:https://cabforum.org/about-ev-ssl/
~WebSocket接続を確立する~algo:~RFC6455#section-4.1
~WebSocket接続を失敗させ:~RFC6455#section-7.1.7
混在~保安的~文脈:https://tools.ietf.org/html/rfc6797#section-12.4

	頃から:https://twitter.com/ericlaw/status/469813922908758016
	version 4:https://support2.microsoft.com/default.aspx?scid=kb;EN-US;Q261188


大域~obj:~WAPI#global-object
x.大域~obj:~WAPI#concept-settings-object-global
担当の文書:~WAPI#responsible-document
環境~設定群~obj:~WAPI#settings-object
関連する設定群~obj:~WAPI#relevant-settings-object

~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-contexts
	~BROWSERS#nested-browsing-context
親~閲覧文脈:~BROWSERS#parent-browsing-context
通して入子に:~BROWSERS#browsing-context-nested-through
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc

新たな文書の作成-時:~NAVI#initialise-the-document-object
	~HTML51/browsers.html#initializing-a-new-document-object

違反~objを作成-:~CSP3#create-violation-for-global
指令:~CSP3#directives
	~CSP3#directive
指令~集合:~CSP3#policy-directive-set
指令~名:~CSP3#directive-name
施行-:~CSP3#enforced
	~CSP3#enforce
資源:~CSP3#violation-resource
違反を報告-:~CSP3#report-violation

~Fetch~event:#_fetch-event

</script>

<!--%style -->
<style>

.report {
	color: green;
}

.scheme {
	color: #006633;
}

samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

pre.http-code {
	background: #EEE;
}
pre.html-code {
	background: #FFE;
}

i {
	color: purple;
}

</style>



</head>

<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>Mixed Content 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">Mixed Content</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2016-07-21</time>
（公開：<time>2016-05-30</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>

<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1 id="title">混在内容 — Mixed Content</h1>
<h2 id="subtitle">2016 年 7 月 20 日付 編集者草案</h2>
	</hgroup>

<dl id="_versions">

	<dt title="This version:">このバージョン</dt>
	<dt title="Editor’s Draft:">編集者草案</dt>
	<dd>https://w3c.github.io/webappsec-mixed-content/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>http://www.w3.org/TR/mixed-content/</dd>

	<dt title="Previous versions:">以前のバージョン</dt>
	<dd>http://www.w3.org/TR/2015/CR-mixed-content-20151008/</dd>

	<dt title="Version History:">バージョン履歴</dt>
	<dd>https://github.com/w3c/webappsec-mixed-content/commits/master/index.src.html</dd>

	<dt title="Feedback:">フィードバック</dt>
	<dd><span><a href="mailto:public-webappsec@w3.org?subject=%5Bmixed-content%5D%20YOUR%20TOPIC%20HERE">public-webappsec@w3.org</a> with subject line “<kbd>[mixed-content] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-webappsec/" rel="discussion">archives</a>)</span></dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="mailto:mkwst@google.com">Mike West</a> (Google Inc.)</dd>

	<dt>Participate:</dt>
	<dd><span><a href="https://github.com/w3c/webappsec-mixed-content/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-mixed-content/issues">open issues</a>)</span></dd>

</dl>


<small class="copyright" data-fill-with="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</small>

</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、［
暗号化され, かつ認証済みの
］文書の文脈~下で、~UAが［
暗号化されていない, または未認証の
］接続を通じた［
内容の~fetching
］をどう取扱うべきかについて述べる。
◎
This specification describes how a user agent should handle fetching of content over unencrypted or unauthenticated connections in the context of an encrypted and authenticated document.
</p>



	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
この節では、発行時点における…
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>
に委譲
】</span></p>

<!-- 


This is a public copy of the editors’ draft. It is provided for discussion only and may change at any moment. Its publication here does not imply endorsement of its contents by W3C. Don’t cite this document other than as work in progress.

Changes to this document may be tracked at https://github.com/w3c/webappsec.

The (archived) public mailing list public-webappsec@w3.org (see instructions) is preferred for discussion of this specification. When sending e-mail, please put the text “mixed-content” in the subject, preferably like this: “[mixed-content] …summary of comment…”

This document was produced by the Web Application Security Working Group.

This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.

This document is governed by the 1 September 2015 W3C Process Document.

The following features are at-risk, and may be dropped during the CR period:

    The passthrough request concept, and the related carveout in the blocking algorithms. 

“At-risk” is a W3C Process term-of-art, and does not necessarily imply that the feature is in danger of being dropped or delayed. It means that the WG believes the feature may have difficulty being interoperably implemented in a timely manner, and marking it as such allows the WG to drop the feature if necessary when transitioning to the Proposed Rec stage, without having to publish a new Candidate Rec without the feature first.

-->

<p>
<strong>
この文書に対する変更点は、
<a href="https://github.com/w3c/webappsec">https://github.com/w3c/webappsec</a>
に。
</strong>
◎
Changes to this document may be tracked at https://github.com/w3c/webappsec.
</p>

<p>
この文書は
<a href="http://www.w3.org/2011/webappsec/">Web Application Security Working Group</a>
により制作されました。
◎
This document was produced by the Web Application Security Working Group.
</p>

<p>
次の特色機能は
<a href="w3c-common-ja.html#at-risk">~risk下</a>
にあり，勧告候補の期間~中に取下げらるかもしれません：
◎
The following features are at-risk, and may be dropped during the CR period:
</p>

<ul>

	<li>
`通過~要請$の概念, および 各種 阻止法~algoにおける それに関係する箇所。
◎
The passthrough request concept, and the related carveout in the blocking algorithms.
</li>
</ul>


	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
利用者が、保安的~channel（例えば~HTTPS）を通じて，成功裡に
`example.com^s から資源を読込んだとき、~UAは，利用者の
保安／~privacy
に~criticalな，次の三つを表明できる：
◎
When a user successfully loads a resource from example.com over a secure channel (HTTPS, for example), the user agent is able to make three assertions critical to the user’s security and privacy:
</p>

<ul>
	<li>
利用者が通信している~serverは、紛れもなく，利用者の要請が経由した数多の~serverのどれでもない， `example.com^s であると主張することが許容される。
接続は、<strong>認証済み</strong>になれる。
◎
The user is communicating with a server that is allowed to claim to be example.com, and not one of the many, many servers through which her request has hopped. The connection can be authenticated.
</li>
	<li>
利用者と `example.com^s との通信は、介在者により自明に盗聴され得ない。
利用者が［
発行した要請, 受信した応答
］のいずれも<strong>暗号化されている</strong>ので。
◎
The user’s communications with example.com cannot be trivially eavesdropped upon by middlemen, because the requests she makes and the responses she receives are encrypted.
</li>
	<li>
暗号化と認証は，<strong>~dataの完全性</strong>を保証するので、利用者と `example.com^s との通信は，介在者により自明に改変され得ない。
◎
The user’s communications with example.com cannot be trivially modified by middlemen, the encryption and authentication provide a guarantee of data integrity.
</li>
</ul>

<div class="p">
<p>
これらの表明は一体として、利用者に次の二点を確約する：
</p>

<ul ><li>`example.com^s が，利用者の要請を読取って応答できる唯一の主体であること（
caveat: without shocking amounts of work
【それも，多量の仕事をこなす必要なく？】
）
</li><li>利用者が受信する~dataは，`example.com^s が実際に送信したものであること
</li></ul>

◎
Together, these assertions give the user some assurance that example.com is the only entity that can read and respond to her requests (caveat: without shocking amounts of work) and that the bits she’s received are indeed those that example.com actually sent.
</div>

<p>
しかしながら、これらの表明の強度は，暗号化され，かつ認証された当の資源が，非保安的~channelを通じて下位資源（~script, 画像, 等々）を要請したときには、相当に弱められる。
非保安的~要請は，中間者~攻撃に無防備になるので、それらの資源~要請による結果，状態0が混在することになる。
あいにく，このような局面はごく共通的にある。
◎
The strength of these assertions is substantially weakened, however, when the encrypted and authenticated resource requests subresources (scripts, images, etc) over an insecure channel. Those resource requests result in a resource whose status is mixed, as insecure requests are wide open for man-in-the-middle attacks. This scenario is unfortunately quite common.
</p>

<p>
この仕様は、~UAがこれらの保安と~privacyの~riskを［
それらの~riskに疑念なく不作為に通信する資源の能を制限する
］ことにより，軽減できる方法について詳細を述べる。
◎
This specification details how a user agent can mitigate these risks to security and privacy by limiting a resource’s ability to inadvertently communicate in the clear.
</p>

<p class="note">注記：
この文書に述べるどれもが、特に新しいものではなく，年月にわたり一つ以上の~UAに現れたものばかりである
—
<a href="https://support.microsoft.com/en-us/kb/261188">~version 4</a>
の<a href="https://twitter.com/ericlaw/status/469813922908758016">頃から</a>の Internet Explorer を始めとして、混在~内容に対し利用者に~alertしている。
◎
Note: Nothing described in this document is really new; everything covered here has appeared in one or more user agents over the years: Internet Explorer led the way, alerting users to mixed content since around version 4.
</p>

	</section>
	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IN, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
用語
`文書@
は、 `Document$I ~objの略記である。
</p>


	</section>
	<section id="terms">
<h2 title="Key Concepts and Terminology">2. ~~主要な概念と各種用語</h2>

<dl>
	<dt>`混在~内容@ （ mixed content ）</dt>
	<dd>
<p>
次の両者を満たす`要請$は、`混在~内容$とされる：
</p>

<ul><li>その`~url$rqは`先天的に認証済み~URL$でない
</li><li>その読込みを担当する文脈では、混在~保安~文脈の禁制が要求されている†
</li></ul>

◎
A request is mixed content if its url is not a priori authenticated, and the context responsible for loading it requires prohibits mixed security contexts (see §5.1 Does settings prohibit mixed security contexts? for a normative definition of the latter).
</dd>
	<dd>
<p>
次の両者を満たす`応答$は、`混在~内容$とされる：
</p>

<ul><li>`未認証の応答$である
</li><li>その読込みを担当する文脈では、混在~保安~文脈の禁制が要求されている†
</li></ul>

◎
A response is mixed content if it is an unauthenticated response, and the context responsible for loading it requires prohibits mixed security contexts.
</dd>
	<dd>†
規範的な定義は、`設定群は混在~保安的~文脈を禁制するか？$を見よ。
◎
↑</dd>


	<dd class="example">
<p>
混在~内容を制約する文脈（例：
`https://secure.example.com/^s
）の内側では：
◎
Inside a context that restricts mixed content (https://secure.example.com/, for example):
</p>
		<ul>
			<li>
`http://example.com/script.js^s にある~scriptに対する要請は`混在~内容$になる。
この`要請$は`阻止可能$になるので、~UAは，資源を読込む代わりに~network~errorを返すことになる。
◎
A request for the script http://example.com/script.js is mixed content. As script requests are blockable, the user agent will return a network error rather than loading the resource.
</li>
			<li>
`http://example.com/image.png^s にある画像に対する要請は`混在~内容$になる。
この`要請$は`随意に阻止可能$になるので、~UAは
その画像を読込むかもしれない
— その場合、画像~資源~自身は`混在~内容$になる。
◎
A request for the image http://example.com/image.png is mixed content. As image requests are optionally-blockable, the user agent might load the image, in which case the image resource itself would be mixed content.
</li>
		</ul>
	</dd>
	<dd>
混在~内容を制約する文脈の中に，混在~内容が読込まれた場合（上の例の 2 番目に示したように）、その文脈は（ `RFC6797$r に定義されるように）`混在~保安的~文脈$と見なされる。
◎
If mixed content is loaded into a context that restricts mixed content (as in #2 above), that context is considered a mixed security context (as defined in [RFC6797]).
</dd>
	<dd class="leaf note">注記：
“混在~内容” は、元々は
`WSC-UI$r の
<a href="~TR/wsc-ui/#securepage">5.3 節</a>
にて定義された。
この文書は、それによる初期の定義を更新する。
◎
Note: "Mixed content" was originally defined in section 5.3 of [WSC-UI]. This document updates that initial definition.
</dd>
	<dd class="leaf note">注記：
`XML$r も，無関係な
<a href="~TR/2008/REC-xml-20081126/#sec-mixed-content">混在~内容</a>
の概念を定義しているが、この用語は，各~UAにわたる保安~文脈のほぼ至る所で 10 年以上 使われ続けているので、実用上は混同されるおそれは少ないであろう。
◎
Note: [XML] also defines an unrelated "mixed content". concept. This is potentially confusing, but given the term’s near ubiquitious usage in a security context across user agents for more than a decade, the practical risk of confusion seems low.
</dd>

	<dt> `先天的に認証済み~URL@ （ a priori authenticated URL ）</dt>
	<dd>
<p>
特定0の~URL %url への要請は、次のいずれかが満たされるならば，
傍受と改変の~riskを軽減する仕方で送達されることが
<em>先天的に</em> 既知となる：
◎
We know a priori that a request to a particular URL (url) will be delivered in a way that mitigates the risks of interception and modifications if either of the following statements is true:
</p>
		<ul>
			<li>
`~URLは信用に価し得るか？$( %url ) ~EQ `価し得る^i
`SECURE-CONTEXTS$r
◎
The algorithm defined in Secure Contexts §is-url-trustworthy returns "Potentially Trustworthy" when executed upon url [SECURE-CONTEXTS].
</li>
			<li>
<p>
%url の`~scheme$ ~EQ `data^l
◎
url’s scheme is "data".
</p>

<p class="note">注記：
ここでは `data^c ~URLは特別な事例として扱う
— それらは特に信用に価し得るとは見なされないが、~networkは決して叩かないので，混在~内容として阻止したいと望まれてもいない。
◎
Note: We special case data URLs here, as we don’t consider them particularly trustworthy, but we also don’t wish to block them as mixed content, as they never hit the network.
</p>
			</li>
		</ul>
	</dd>

	<dt> `未認証の応答@ （ unauthenticated response ）</dt>
	<dd>
<p>
`応答$ %応答 は、次の両者を満たすならば，未認証であることが <em>後天的に</em> 既知となる。
◎
We know a posteriori that a response (response) is unauthenticated if both of the following statements are true:

</p>

		<ul>
			<li>
%応答 の`~url$rsは`先天的に認証済み~URL$である
◎
response’s url is a priori authenticated.
</li>
			<li>
%応答 の`~url$rs の`~scheme$ ~IN { `https^l, `wss^l }
~AND
%応答 の`~HTTPS状態$rs ~IN { `modern^l }
◎
If response’s url’s scheme is "https" or "wss", response’s HTTPS state is "modern".
</li>
		</ul>
	</dd>
	<dd class="trans-note">【
明らかに、語が示唆する意味と正反対の定義。
おそらく仕様の誤りであろう。
】</dd>

	<dt>`埋込んでいる文書@ （ embedding document ）</dt>
	<dd>
`文書$ %A が`属する閲覧文脈$が `文書$ %B を`通して入子に$されているとき、
%B を指して， %A を埋込んでいる文書という。
`HTML51$r
◎
Given a Document A, the embedding document of A is the Document through which A’s browsing context is nested [HTML5].
</dd>

</dl>

	</section>
	<section id="categories">
<h2 title="Content Categories">3. 内容の分類</h2>

<p>
理想~世界では、各~UAには，あらゆる`混在~内容$をもれなく阻止することが要求されることになるが、あいにく今日の~Internetにおいては，それは実用的でない。
~UAは、より按配よく制約しなければ，相当~数の~web~siteで利用者~体験の劣化は避けられなくなる。
◎
In a perfect world, each user agent would be required to block all mixed content without exception. Unfortunately, that is impractical on today’s Internet; a user agent needs to be more nuanced in its restrictions to avoid degrading the experience on a substantial number of websites.
</p>

<p>
そのことを念頭に、ここでは，混在~内容を［
`随意に阻止可能な内容$, `阻止可能な内容$
］の 2 つに分類する。
◎
With that in mind, we here split mixed content into two categories: §3.1 Optionally-blockable Content and §3.2 Blockable Content.
</p>

<p class="note">注記：
この仕様の将来~versionは、世界の`混在~内容$すべてが阻止される方へ進むべく，この分類法を更新することになる
— それが最終的な目標であるが、今の所は，ここまでが最善である。
◎
Note: Future versions of this specification will update this categorization with the intent of moving towards a world where all mixed content is blocked; that is the end goal, but this is the best we can do for now.
</p>


		<section id="category-optionally-blockable">
<h3 title="Optionally-blockable Content">3.1. 随意に阻止可能な内容</h3>

<p>
［
資源／`要請$
］は、［
`混在~内容$としての用法を許容する~risk
］より，［
~webの有意な部位を壊す~risk
］の方が重視されるとき、
`随意に阻止可能@
（ optionally-blockable ）とされる。
これは、当の資源~種別の混在~利用率が十分に高いこと，および
資源それ自体は低~riskであることによる。
資源~種別が随意に阻止可能である事実が，<em>安全である</em>ことを意味するわけではない
— 単純に，他の種別の資源より破滅的な危険~度は低いことを意味する。
例えば画像や~iconは、~appの~interfaceにおいて中心的な~UI要素になることが多い。
攻撃者が~emailの［
“~~削除”, “~~返信”
］を表す~iconを逆にした場合、利用者に実害が及ぶことになる。
◎
A resource or request is optionally-blockable when the risk of allowing its usage as mixed content is outweighed by the risk of breaking significant portions of the web. This could be because mixed usage of the resource type is sufficiently high, and because the resource is low-risk in and of itself. The fact that these resource types are optionally-blockable does not mean that they are safe, simply that they’re less catastrophically dangerous than other resource types. For example, images and icons are often the central UI elements in an application’s interface. If an attacker reversed the "Delete email" and "Reply" icons, there would be real impact to users.
</p>

<p>
この分類の内容には次のものが含まれる：
◎
This category of content includes:
</p>

<ul>
	<li>
<p>
`img$e ／ CSS （
`background-image$css, `border-image$css, 等々
）を介して読込まれる画像
◎
Images loaded via img or CSS (background-image, border-image, etc) 
</p>

<p class="note">注記：
これには、画像として読込まれる SVG 文書も含まれる。
それらには、~scriptの実行や，下位資源の読込みは禁じられるので。
`picture$e を介して読込まれる画像は含まれない。
◎
Note: This includes SVG documents loaded as images, as they are banned from executing script or loading subresources. It does not include images loaded via picture.
</p>

	</li>
	<li>
`video$e ／ `source$e 要素を介して読込まれる動画
◎
Video loaded via video and source
</li>
	<li>
`audio$e ／ `source$e 要素を介して読込まれる音声
◎
Audio loaded via audio and source
</li>
</ul>

<p class="note">注記：
この分類は、`要請の~fetchingは混在~内容として阻止されるべきか？$において，［
CORS が可能化された要請は 強制的に失敗させる
］ことにより、更に制限される。
これは、
<samp >&lt;`img$e `crossorigin$a ...&gt;</samp>
を介して読込まれる混在~内容~画像は阻止されることを意味する。
上に挙げたものは、［
この分類に該当する内容は，［
全面的に阻止するには，広範に利用され過ぎている
］ものに<em>限られる</em>
］とする、一般~原則の好例である。
Working Group は、時を経るに伴い，より阻止可能な下位集合を形作ることを意図している。
◎
Note: We further limit this category in §5.3 Should fetching request be blocked as mixed content? by force-failing any CORS-enabled request. This means that mixed content images loaded via &lt;img crossorigin ...&gt; will be blocked. This is a good example of the general principle that content falls into this category only when it is too widely used to be blocked outright. The Working Group intends to carve out more blockable subsets as time goes on.
</p>

		</section>
		<section id="category-blockable">
<h3 title="Blockable Content">3.2. 阻止可能な内容</h3>

<p>
`随意に阻止可能$でない，どの［
資源 ／ `要請$
］も
`阻止可能@
（ blockable ）とされる。
この種の内容の代表的な例には、
~script,
`~plugin$~data,
`XMLHttpRequest$I を介して要請される~data,
等々がある。
◎
Any resource or request that isn’t optionally-blockable is blockable. Typical examples of this kind of content include scripts, plugin data, data requested via XMLHttpRequest, and so on.
</p>

<p class="note">注記：
`~navi要請$は、`~top-level閲覧文脈$を~targetすることもあるが，混在~内容とは見なされない。
詳細は、`要請の~fetchingは混在~内容として阻止されるべきか？$を見よ。
◎
Note: Navigation requests might target top-level browsing contexts; these are not considered mixed content. See §5.3 Should fetching request be blocked as mixed content? for details.
</p>

<p class="note">注記：
~pluginが自身に利するために発行する要請は、阻止可能になる。
しかしながら、~UAが常に，そのような要請を仲介する立場にあるとは限らないことも認識されている。
具体例として、 NPAPI ~pluginは，直接的な~network~accessを有することが多く、一般に~UAをまるごと迂回できる。
~plugin~vendorには、自身における混在~内容の検査-法を実装して，この文書に概説する~riskを軽減することが推奨される。
◎
Note: Note that requests made on behalf of a plugin are blockable. We recognize, however, that user agents aren’t always in a position to mediate these requests. NPAPI plugins, for instance, often have direct network access, and can generally bypass the user agent entirely. We recommend that plugin vendors implement mixed content checking themselves to mitigate the risks outlined in this document.
</p>


		</section>
	</section>
	<section id="strict-checking">
<h2 title="Strict Mixed Content Checking">4. 混在~内容の厳格な検査-法</h2>

<p>
作者は、［
`随意に阻止可能$, `阻止可能$
］の両~混在~内容とも阻止するような，より厳格な混在~内容の検査-法を可能化することを選んでも~MAY。
これにより、利用者による上書き~option（`利用者による制御 節$）も抑止され、利用者に提示される保安~UIが混在~内容により劣化することは
— `~UIに課される要件 節$に述べるように —
決してないことが確約される。
◎
In order to give authors assurance that mixed content will never degrade the security UI presented to their users (as described in §7.3 UI Requirements), authors may choose to enable a stricter variant of mixed content checking which will both block optionally-blockable and blockable mixed content, and suppress the user override options discussed in §7.4 User Controls.
</p>

<p>
そのようなわけで、各［
`文書$／`閲覧文脈$
］は，
<dfn>混在~内容に対する厳格な検査-法~flag</dfn>
（ strict mixed content checking flag ）
— 以下，
`厳格~検査~flag@
と略記する —
を有する。
それは、他が指定されない限り ~OFF にされる。
この~flagは［
`要請の~fetchingは混在~内容として阻止されるべきか？$ ／
`要請に対する応答は混在~内容として阻止されるべきか？$
］にて`文書$が
`厳格~mode@
（ strict mode ）下にあるかどうか決定するときに検査される。
◎
To this end, Document objects and browsing contexts have a strict mixed content checking flag which is set to false unless otherwise specified. This flag is checked in both §5.3 Should fetching request be blocked as mixed content? and §5.4 Should response to request be blocked as mixed content? to determine whether the Document is in strict mode.
</p>

<div class="example">

<p>
`文書$は、次のいずれかにより，自身の中に厳格~modeを~opt-inして~MAY：
</p>

<ul>
	<li>
<p>
次の様な `Content-Security-Policy$h ~HTTP~headerを送達するか：
◎
A Document may opt itself into strict mode by either delivering a Content-Security-Policy HTTP header, like:
</p>

<pre class="http-code">
Content-Security-Policy: `block-all-mixed-content$dir
</pre>

	</li>
	<li>
<p>
または、`埋込んでいる文書$の `meta$e 要素に次の様な施策を与える：
◎
or by embedding the policy in a meta element, like:
</p>

<pre class="html-code">
&lt;meta http-equiv="Content-Security-Policy"
      content="`block-all-mixed-content$dir"&gt;
</pre>

	</li>
</ul>

</div>


<p class="note">注記：
混在~内容の厳格な検査-法は、埋込みの内容にも継承される。
ある~pageが厳格~modeを~opt-inした場合、~frame内に入子にされた~pageにおいても
— `~opt-inの継承-法 節$に述べるように —
混在~内容の読込みは防止されることになる。
◎
Note: Strict mixed content checking is inherited by embedded content; if a page opts into strict mode, framed pages will be prevented from loading mixed content, as described in §4.3 Inheriting an opt-in.
</p>



		<section id="strict-effects">
<h3 title="Effects">4.1. 効果</h3>

<p>
［
`文書$の`厳格~検査~flag$ ~EQ ~ON
］の場合、~UAには，次が要求される：
◎
If a Document's strict mixed content checking flag is set to true, the user agent MUST:
</p>

<ol>
	<li>
`随意に阻止可能$な混在~内容を，`阻止可能$であったかのように扱う。
◎
treat optionally-blockable mixed content as though it were blockable.
</li>
	<li>
<p>
利用者には、`阻止可能$な混在~内容の読込みを強制する仕組みを提供しない。
◎
NOT provide users with a mechanism for forcing blockable mixed content to load.
</p>

<p class="note">注記：
この要件は、`利用者による制御 節$における示唆を上書きする。
◎
Note: This requirement overrides the suggestion in §7.4 User Controls.
</p>

	</li>
<li>
<p>
混在~内容の存在0について，いかなる指示も利用者~向けに提供しない。
◎
NOT provide any user-facing indication that mixed content is present.
</p>

<p class="note">注記：
この要件は、`~UIに課される要件 節$における示唆を上書きする。
上の 1 番目と 2 番目の要件の組合せにより，［
当の~pageの文脈~下では，混在~内容は決して読込まれない
］ことが確保され、そうしても安全なので。
◎
Note: This requirement overrides the suggestion in §7.3 UI Requirements, which is safe to do since the combination of the first and second requirements above ensure that mixed content will never load in this page’s context.
</p>

<p class="note">注記：
この要件には、~console-messageなどの，開発者~向けの指示子は含まれない。
◎
Note: This requirement does not include developer-facing indicators such as console messages.
</p>
	</li>
	<li>
これらの要件が、［
`入子の閲覧文脈$に属するどの`文書$にも適用される
］ことを
— `~opt-inの継承-法 節$に述べるように —
確保する。
◎
ensure that these requirements are applied to any Document in a nested browsing context, as described in §4.3 Inheriting an opt-in.
</li>
</ol>

		</section>
		<section id="strict-opt-in">
<h3 title="Opting-in">4.2. ~opt-in法</h3>

<p>
作者は、~CSP指令 `CSP3$r
`block-all-mixed-content@dir
を介して，`文書$の中に 混在~内容の厳格な検査-法を~opt-inして~MAY。
この指令は次の ABNF 文法を介して定義される。
◎
Authors may opt a Document into strict mixed content checking via a block-all-mixed-content Content Security Policy directive [CSP2], defined via the following ABNF grammar.
</p>

<pre class="ABNF">
`directive-name$P  = "block-all-mixed-content"
`directive-value$P = ""
</pre>

<p>
`block-all-mixed-content$dir 指令を`施行-$するときは、被保護~資源の`厳格~検査~flag$を ~ON にする。
◎
When enforcing the block-all-mixed-content directive, set the protected resource’s strict mixed content checking flag to true.
</p>

<p>
この指令は、~page上の混在~内容に対する違反~報告を誘発することになる。
詳細は、`要請の~fetchingは混在~内容として阻止されるべきか？$に。
◎
This directive will trigger violation reports for mixed content on a page. Details are found in §5.3 Should fetching request be blocked as mixed content?.
</p>

<p class="note">注記：
個々の指令を設定すれば、類似する効果を より細かい~levelで達成できる。
例えば
<samp>`img-src$dir https:</samp>
は、非保安的~画像の読込みを防止することになる。
◎
Note: A similar effect may be achieved on a more granular level by setting individual directives. For example img-src https: would prevent insecure images from loading.
</p>



		</section>
		<section id="strict-nesting">
<h3 title="Inheriting an opt-in">4.3. ~opt-inの継承-法</h3>

<p>
~UAは、すべての`入子の閲覧文脈$に対し，次に従って`厳格~検査~flag$を継承させ~MUST：
◎
If a Document's strict mixed content checking flag is set, the user agent MUST ensure that all nested browsing contexts inherit the setting in the following ways:
</p>

<ul>
	<li>
`入子の閲覧文脈$ %文脈 の作成-時には
⇒
［
%文脈 を`埋込んでいる文書$の`厳格~検査~flag$ ~EQ ~ON
］ならば
⇒
%文脈 の`厳格~検査~flag$も ~ON にする
◎
When a nested browsing context context is created, set its strict mixed content checking flag to true if context’s embedding document’s strict mixed content checking flag is set to true.
</li>
	<li>
`新たな文書の作成-時$には
⇒
［
その`文書$ %文書 が`属する閲覧文脈$の`厳格~検査~flag$ ~EQ ~ON
］ならば
⇒
%文書 の`厳格~検査~flag$も ~ON にする
◎
When creating a new Document object, set its strict mixed content checking flag to true if its browsing context’s strict mixed content checking flag is true.
</li>
</ul>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Insecure Content in Secure Contexts">5. 保安的な文脈における非保安的~内容</h2>

<p>
高~levelからは、次の~algoにより，特定0の要請が［
成功するべきか,
~network~errorになるべき
］かどうか，~UAは決定できるようになる：
◎
At a high level, the following algorithms allow user agents to determine whether particular requests should succeed, or should result in network errors.
</p>

<ul>
	<li>
~algo［
`要請の~fetchingは混在~内容として阻止されるべきか？$
］は、
~fetch `FETCH$r ~algoの最初の方で，［
`先天的に認証済み~URL$でない`~url$rqへの~network流通を阻止する
］ために~callされる。
この~hookは、初期~要請のみならず，すべての~redirectも捕えれることを確保する。
◎
Fetch calls the algorithm defined in §5.3 Should fetching request be blocked as mixed content? at the top of the fetching algorithm in order to block network traffic to URLs which are not a priori authenticated [FETCH]. Hooking into Fetch here ensures that we catch not only the initial request, but all redirects as well.
</li>
	<li>
<p>
~algo［
`要請に対する応答は混在~内容として阻止されるべきか？$
］もまた、~fetch~algoの最後の方で，［
`未認証の応答$を阻止する
］ために~callされる。
この~hookは、次のために必要とされる：
</p>
<ul><li>`ServiceWorker$I により［
改変-／合成-
］された資源を検出する
</li><li>~TLS-handshakeを終えた後に，応答が`未認証の応答$であるかどうか決定する
</li></ul>
<p>
詳細は、［
`要請に対する応答は混在~内容として阻止されるべきか？$
］の段 4.1, 4.2 を見よ。
【この段~番号はおそらく誤り】
</p>
◎
Further, Fetch calls the algorithm defined in §5.4 Should response to request be blocked as mixed content? at the bottom of the fetching algorithm in order to block unauthenticated responses. This hook is necessary to detect resources modified or synthesized by a ServiceWorker, as well as to determine whether a response is unauthenticated once the TLS-handshake has finished. See steps 4.1 and 4.2 of the algorithm defined in §5.4 Should response to request be blocked as mixed content? for detail.
</li>
	<li>
<p>
~algo［
`設定群は混在~保安的~文脈を禁制するか？$
］は、［
非保安的~要請は阻止されるべきかどうか決定する
］ために，次の箇所から利用される：
</p>

<ul><li>`要請の~fetchingは混在~内容として阻止されるべきか？$
</li><li>`要請に対する応答は混在~内容として阻止されるべきか？$
</li><li><a href="#websockets-integration">~WebSocketに対する改変</a>
節
</li></ul>

◎
The algorithm defined in §5.1 Does settings prohibit mixed security contexts? is used by both §5.3 Should fetching request be blocked as mixed content? and §5.4 Should response to request be blocked as mixed content?, as well as §6 Modifications to WebSockets in order to determine whether an insecure request ought to be blocked.
</li>
</ul>



		<section id="categorize-settings-object">
<h3 title="Does settings prohibit mixed security contexts?">5.1. %設定群 は混在~保安~文脈を禁制するか？</h3>

<p>
`文書$, ~worker
のいずれも，`環境~設定群~obj$を有する。
この %設定群 は、［
混在~内容を制約するかどうか
］を決定するために，次の~algoに則って検分され得る。
この~algoは、［
`禁制する^i, `禁制しない^i
］のいずれかを返す：
◎
Both documents and workers have environment settings objects which may be examined according to the following algorithm in order to determine whether they restrict mixed content. This algorithm returns "Prohibits Mixed Security Contexts" or "Does Not Prohibit Mixed Security Contexts", as appropriate.
◎
Given an environment settings object (settings):
</p>

<!-- 
<p class="trans-note">【
原文によるこの返り値の記述は一貫していないので、この訳では
Prohibits Mixed Security Contexts
Restricts Mixed Content
Restricts Mixed Security Context
Does Not Prohibit Mixed Security Contexts
Does Not Restrict Mixed Security Contexts
】</p>
 -->

<ol>
	<li>
~IF［
%設定群 の`~HTTPS状態$ ~NEQ `none^l
］
⇒
~RET `禁制する^i
◎
If settings’ HTTPS state is not "none", then return "Prohibits Mixed Security Contexts".
</li>
	<li>
<p>
~IF［
%設定群 の`担当の文書$ %文書 はある
］：
◎
If settings has a responsible document document, then:
</p>

		<ol>
			<li>
<p>
~WHILE［
%文書 を`埋込んでいる文書$はある
］
：
◎
While document has an embedding document:
</p>

				<ol>
					<li>
%文書 ~SET %文書 を`埋込んでいる文書$
◎
Set document to document’s embedding document.
</li>
					<li>
%埋込元~設定群 ~LET %文書 の`大域~obj$に`関連する設定群~obj$
◎
Let embedder settings be document’s global object’s relevant settings object.
</li>
	<li>
~IF［
%埋込元~設定群 の`~HTTPS状態$ ~NEQ `none^l
］
⇒
~RET `禁制する^i
◎
If embedder settings’ HTTPS state is not "None", then return "Prohibits Mixed Security Contexts".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET `禁制しない^i
◎
Return "Does Not Restrict Mixed Security Contexts".
</li>
</ol>

<div class="note">

<p>注記：
文書を`埋込んでいる文書$がある場合、~UAは，文書~自身のみならず，文書を入子にしている`~top-level閲覧文脈$も検査する必要がある
— それが、［［
利用者が読込んだ資源の保安~状態0
］に関する利用者の期待
］を制御する文脈なので。
例えば：
◎
If a document has an embedding document, a user agent needs to check not only the document itself, but also the top-level browsing context in which the document is nested, as that is the context which controls the user’s expectations regarding the security status of the resource she’s loaded. For example:
</p>

<ul class="example">
	<li>
`http://a.com^s が `http://evil.com^s を読込む場合
⇒
`evil.com^s への非保安的~要請は、許容されることになる
— `a.com^s は 保安的~接続を通じて読込まれていないので。
◎
http://a.com loads http://evil.com. The insecure request will be allowed, as a.com was not loaded over a secure connection.
</li>
	<li>
`https://a.com^s が `http://evil.com^s を読込む場合
⇒
`evil.com^s への非保安的~要請は、阻止されることになる
— `a.com^s は 保安的~接続を通じて読込まれたので。
◎
https://a.com loads http://evil.com. The insecure request will be blocked, as a.com was loaded over a secure connection.
</li>
	<li>
`http://a.com^s が~frame内に `https://b.com^s を入子にしていて，
`b.com^s は `http://evil.com^s を読込む場合
⇒
`evil.com^s への非保安的~要請は阻止されることになる
— `a.com^s は そうでなくても， `b.com^s は 保安的~接続を通じて読込まれたので。
◎
http://a.com frames https://b.com, which loads http://evil.com. In this case, the insecure request to evil.com will be blocked, as b.com was loaded over a secure connection, even though a.com was not.
</li>
	<li>
`https://a.com^s が~frame内に ~data_scheme ~URLを入子にしていて，その ~data_scheme ~URLは `http://evil.com^s を読込む場合
⇒
`evil.com^s への非保安的~要請は阻止されることになる
— ~top-level文脈における ~data_scheme ~URLは 混在~内容を阻止しないが，
`a.com^s は 保安的~接続を通じて読込まれたので。
◎
https://a.com frames a data: URL, which loads http://evil.com. In this case, the insecure request to evil.com will be blocked, as a.com was loaded over a secure connection, even though the framed data: URL would not block mixed content if loaded in a top-level context.

data: URL is not a priori authenticated.
</li>
</ul>

</div>

		</section>
		<section id="is-passthrough">
<h3 title="Is request a passthrough request?">5.2. %要請 は通過~要請であるか？</h3>

<p class="trans-note">【
この節／以下の節に定義される各種~algoに現れる文字列~定数（ `fetch^l など）には、現在の `Fetch$r 仕様の更新に伴い，整合しなくなったものがある。
】</p>


<p>
`通過~要請$とは、`閲覧文脈$内で（例えば，文書~内の `img$e ~tagを介して）作成された`要請$であるが，
~Service-Workerにより~serviceされたものを指す（例：
`onfetch()$m ~event~handler の中で
<samp>`fetch^m(%event.request)</samp>
を~callすることにより）。
<a href="#service-workers">~Service-Worker 節</a>
にて述べるように，［
~web開発者が，~service-workerを［［
`随意に阻止可能$な混在~内容への要請に依拠する，既存の~site
］の上層に重ねる
］ことを許容するため、この種の要請は，特別に扱われる。
◎
A passthrough request is a request (request) which is created in a browsing context (e.g. via an img tag in a document), but serviced by a Service Worker (e.g. by calling fetch(e.request) from within an onfetch event handler). As described in §7.5 Service Workers, we special-case these kinds of requests in order to allow web developers to layer service workers on top of an existing site which relies on requesting optionally-blockable mixed content.
</p>

<p>
より公式的には、`要請$ %要請は，次のいずれの条件も満たすとき，
`通過~要請@
（ passthrough request ）とされる
`FETCH$r ：
◎
More formally, request is a passthrough request if the following conditions hold [FETCH]:
</p>

<ol>
	<li>
<p>
%要請 の`起動元$rq ~EQ `fetch^l<!-- ＊ -->
◎
request’s initiator is fetch
</p>

<p class="note">注記：
要請が複製されるとき（上の例の
<samp>`fetch^m(%event.request)</samp>
のように）、元の `context^c 【単に “文脈”？ 】
は失われる。
この条件は，そのような要請を扱っていることを確保するが、［［
`要請の~fetchingは混在~内容として阻止されるべきか？$
］により［
`阻止可能$な要請が，先ず~Service-Workerに~enterする
］ことは防止される
］ことに，暗黙的に依拠する。
◎
Note: When a request is copied (as in the fetch(e.response) example above), the original context is lost. Here, we ensure that we’re dealing with such a request, but we implicitly rely on §5.3 Should fetching request be blocked as mixed content? preventing blockable requests from entering a Service Worker in the first place.
</p>

	</li>
	<li>
<p>
%要請 の`~window$rqは、`環境~設定群~obj$である（したがって， `no-window^l でない）
◎
request’s window is an environment settings object (and, therefore, not no-window)
</p>

<p class="note">注記：
これは、［
何らかの類の警告を，（`~UIに課される要件 節$に述べるように）利用者に具現化できる
］ことを確保するため、［
`~window$rqが， `FETCH$r により［
当の要請を担当する`環境~設定群~obj$
］に適正に設定されている
］ことに依拠する。
◎
Note: We rely on the window property being properly set by [FETCH] to the environment settings object responsible for the request in order to ensure that we can render some sort of warning to the user (as described in §7.3 UI Requirements).
</p>
	</li>
	<li>
<p>
%要請 の`~client$rqの`大域~obj$xは、
`ServiceWorkerGlobalScope$I ~objである。
◎
request’s client’s global object is a ServiceWorkerGlobalScope object.
</p>

<p class="note">注記：
これは、［
`~client$rqが要請の出自
【<a href="~FETCH#concept-request-origin">要請の生成元</a>？】
を反映する
］ことに依拠する。
重要な点として、~Service-Workerの内側を出自にする %要請 は，`通過~要請$しかない。
◎
Note: We rely on the client property to reflect the origin of the request. Importantly, request is only a passthrough request if it originated inside a Service Worker.
</p>
	</li>
</ol>


		</section>
		<section id="should-block-fetch">
<h3 title="Should fetching request be blocked as mixed content?">5.3. %要請 の~fetchingは混在~内容として阻止されるべきか？</h3>

<p class="note">注記：
~Fetch仕様は、要請をまるごと阻止する†べきかどうか決定するために，この~algoの中へ~hookする。
† 例えば 当の要請は、`阻止可能$な内容に対するものであり，保安的~接続を通じて読込まれることは ないと<em>見做せる</em>ことから。
◎
Note: The Fetch specification hooks into this algorithm to determine whether a request should be entirely blocked (e.g. because the request is for blockable content, and we can assume that it won’t be loaded over a secure connection).
</p>


<p>
~UAは、次の~algoを介して，所与の`要請$ %要請 を続行するべきかどうかを決定する：
◎
Given a Request request, a user agent determines whether the Request request should proceed or not via the following algorithm:
</p>

<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `許容ed^i：
◎
Return allowed if one or more of the following conditions are met:
</p>
		<ul>
			<li>
`設定群は混在~保安的~文脈を禁制するか？$( %要請 の`~client$rq )
の結果 ~EQ `禁制しない^i
◎
§5.1 Does settings prohibit mixed security contexts? returns "Does Not Restrict Mixed Security Contexts" when applied to request’s client.
</li>
			<li>
%要請 の`~url$rqは`先天的に認証済み~URL$である
◎
request’s url is a priori authenticated.
</li>
			<li>
~UAは
— `利用者による制御 節$に述べるように —
`混在~内容$を許容するよう指図されている
◎
The user agent has been instructed to allow mixed content, as described in §7.4 User Controls).
</li>
			<li>
<p>
［
%要請 の`行先$rq ~EQ `document^l
］~AND［
%要請 の`~target閲覧文脈$rqの`親~閲覧文脈$ ~EQ ε
］
◎
request’s destination is "document", and request’s target browsing context has no parent browsing context.
</p>

<p class="note">注記：
~top-level~naviは，混在~内容~検査からは除外されるが、~UAは，非保安的~form提出に対しては 混在~内容~検査を施行することを選んで~MAY（`更なる動作 節$を見よ）。
◎
Note: We exclude top-level navigations from mixed content checks, but user agents MAY choose to enforce mixed content checks on insecure form submissions (see §7.6 Further Action).
</p>
			</li>
		</ul>
	</li>
	<li>
<p>
~FOR
%要請 の`~client$rqの`~CSP~list$内の ~EACH( %施策 ) に対し：
◎
For each policy in request’s client’s CSP list:
</p>
		<ol>
			<li>
<p>
~IF［
%施策 の`指令~集合$内に［
`指令~名$ ~EQ `block-all-mixed-content$dir
］なる`指令$がある
］：
◎
If policy’s directive set contains a directive whose name is "block-all-mixed-content":
</p>
				<ol>
					<li>
%違反 ~LET
( %要請 の`~client$rqの`大域~obj$x, %施策, `block-all-mixed-content^l )
から`違反~objを作成-$した結果
◎
Let violation be the result of executing the algorithm defined in Content Security Policy §2.3.1 Create a violation object for global, policy, and directive on request’s client’s global object, policy, and "block-all-mixed-content".
</li>
					<li>
%違反 の`資源$ ~SET %要請 の`~url$rq
◎
Set violation’s resource to request’s url.
</li>
					<li>
%違反 を用いて`違反を報告-$する
◎
Execute the algorithm defined in Content Security Policy §5.3 Report a violation on violation.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `阻止ed^i：
◎
Return blocked if one or more of the following conditions are met:
</p>
		<ul>
			<li>
~UAは
— `利用者による制御 節$に述べるように —
`随意に阻止可能$な混在~内容を阻止するよう環境設定されている
◎
The user agent is configured to block optionally-blockable mixed content, as described in §7.4 User Controls.
</li>
			<li>
%要請 の`~client$rqの`厳格~検査~flag$ ~EQ ~ON
◎
request’s client’s strict mixed content checking flag is true.
</li>
			<li>
%要請 の`~mode$rq ~IN
{ `CORS^l, `CORS-with-forced-preflight^l }
◎
request’s mode is CORS or CORS-with-forced-preflight.
</li>
		</ul>
	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `許容ed^i：
◎
Return allowed if one or more of the following conditions are met:
</p>
		<ul>
			<li>
［
%要請 の`起動元$rq ~EQ `fetch^l
］~AND［
`行先$rq ~EQ `subresource^l
］~AND［
%要請 は`通過~要請$である
］
◎
request’s initiator is "fetch" and destination is "subresource", and request is a passthrough request.
</li>
			<li>
［
%要請 の`種別$rq ~EQ `image^l
］~AND［
`起動元$rq ~NEQ `imageset^l
］
◎
request’s type is "image", and initiator is not "imageset".
</li>
			<li>
%要請 の`種別$rq ~EQ `video^l
◎
request’s type is "video".
</li>
			<li>
%要請 の`種別$rq ~EQ `audio^l
◎
request’s type is "audio".
</li>
		</ul>
	</li>
	<li>
~RET `阻止ed^i
◎
Return blocked.
</li>
</ol>

<p class="note">注記：
~Service-Workerが［
`文書$から生成される`~Fetch~event$に呼応して `no-cors^l 要請を発行する
］ような~eventに際し，その要請が`随意に阻止可能$になることを許容するため、
`fetch^m を特別に扱う
— その場合の要請の`~client$rqは，［
`大域~obj$xが `Window$I ~objである
］ような`環境~設定群~obj$になる（他方、~Service-Workerによる要請の`~client$rqは， `WorkerGlobalScope$I ~objになる）。
◎
Note: We special-case fetch to allow it as optionally-blockable in the event that a Service Worker is making a no-cors request in response to a Fetch event generated from a Document. In that case, the request’s client property will be an environment settings object whose global object is a Window object (the Service Worker’s request’s client, on the other hand, will be a WorkerGlobalScope object.
</p>

<p class="trans-note">【
`~Fetch~event@
— ~Service-Worker `SW$r 仕様の
<a href="~SW#execution-context-events" >~event節</a>
に定義される各種~eventの総称を指すように思われるが、特に
`fetch^et ~eventを指しているのかもしれない。
】</p>

		</section>
		<section id="should-block-response">
<h3 title="Should response to request be blocked as mixed content?">5.4. %要請 に対する %応答 は混在~内容として阻止されるべきか？</h3>

<p class="note">注記：
<a href="#should-block-fetch">要請が続行される</a>
場合でも，依然として、対する応答を，それを生成した接続の状態に基づいて 阻止するよう求められることがある（例：
要請は`阻止可能$であるが，接続は`未認証$であるためなど）。
加えて，［
~Service-Workerが、`阻止可能$な要請に対し，不用意に`未認証の応答$を返さない
］ことも確保する必要がある。
この~algoは、これらを決定するために利用される。
◎
Note: If a request proceeds, we still might want to block the response based on the state of the connection that generated the response (e.g. because the request is blockable, but the connection is unauthenticated), and we also need to ensure that a Service Worker doesn’t accidentally return an unauthenticated response for a blockable request. This algorithm is used to make that determination.
</p>

<p>
~UAは、次の~algoに従って，所与の
( `要請$ %要請, `応答$ %応答 )
に対し，応答を返すべきかどうかを決定する：
◎
Given a request request and response response, the user agent determines what response should be returned via the following algorithm:
</p>

<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `許容ed^i：
◎
Return allowed if one or more of the following conditions are met:
</p>
		<ol>
			<li>
`設定群は混在~保安的~文脈を禁制するか？$( %要請 の`~client$rq )
の結果 ~EQ `禁制しない^i
◎
§5.1 Does settings prohibit mixed security contexts? returns Does Not Restrict Mixed Content when applied to request’s client.
</li>
			<li>
%応答 の`~HTTPS状態$rs ~EQ `modern^l
◎
response’s HTTPS state is modern.
</li>
			<li>
~UAは
— `利用者による制御 節$に述べるように —
`混在~内容$を許容するよう指図されている。
◎
The user agent has been instructed to allow mixed content, as described in §7.4 User Controls).
</li>
			<li>
<p>
［
%要請 の`行先$rq ~EQ `document^l
］~AND［
%要請 の`~target閲覧文脈$rqの`親~閲覧文脈$はない
］
◎
request’s destination is "document", and request’s target browsing context has no parent browsing context.
</p>

<p class="note">注記：
~top-level~naviは，混在~内容~検査からは除外されるが、~UAは，非保安的~form提出に対しては 混在~内容~検査を施行することを選んで~MAY（`更なる動作 節$を見よ）。
◎
Note: We exclude top-level navigations from mixed content checks, but user agents MAY choose to enforce mixed content checks on insecure form submissions (see §7.6 Further Action).
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `阻止ed^i：
◎
Return blocked if one or more of the following conditions are met:
</p>
		<ol>
			<li>
~UAは
— `利用者による制御 節$に述べるように —
`随意に阻止可能$な混在~内容を阻止するよう環境設定されている
◎
The user agent is configured to block optionally-blockable mixed content, as described in §7.4 User Controls.
</li>
			<li>
%要請 の`~client$rqの`厳格~検査~flag$ ~EQ ~ON
◎
request’s client’s strict mixed content checking flag is true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%応答 は`不透明な絞込み応答$である
］~AND［
次のいずれかが満たされる
］
⇒
~RET `許容ed^i：
◎
Return allowed if response is an opaque filtered response and one or more of the following conditions are met:
</p>
		<ol>
			<li>
［
%要請 の`起動元$rq ~EQ `fetch^l
］~AND［
%要請 は`通過~要請$である
］
◎
request’s initiator is "fetch", and request is a passthrough request.
</li>
			<li>
［
%要請 の`種別$rq ~EQ `image^l
］~AND［
`起動元$rq ~NEQ `imageset^l
］
◎
request’s type is "image", and initiator is not "imageset".
</li>
			<li>
%要請 の`種別$rq ~EQ `video^l
◎
request’s type is "video".
</li>
			<li>
%要請 の`種別$rq ~EQ `audio^l。
◎
request’s type is "audio".
</li>
		</ol>
	</li>
	<li>
~RET `阻止ed^i
◎
Return blocked.
</li>
</ol>


		</section>
	</section>
	<section id="websockets-integration">
<h2 title="Modifications to WebSockets">6. ~WebSocketに対する改変</h2>

<p>
`WebSocket()$m 構築子~algo
`WEBSOCKETS$r
は、次に従って改変される：
◎
The WebSocket() constructor algorithm [WEBSOCKETS] is modified as follows:
</p>

<ul>
	<li>
現在の段 2 を除去する
◎
Remove the current step 2.
</li>
</ul>

<p class="note">注記：
この示唆は
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28841">bug #28841</a>
に対し~~提出されたものである。
`WEBSOCKETS$r
◎
Note: This suggestion is filed as bug #28841 against [WEBSOCKETS].
</p>

<p>
`~WebSocket接続を確立する~algo$
`RFC6455$r
は、次に従って改変される：
◎
The Establish a WebSocket Connection algorithm [RFC6455] is modified as follows:
</p>

<ol>
	<li>
<p>
現在の段 1 の後に，次の段を遂行する：
◎
After the current step 1, perform the following step:
</p>
		<ol>
			<li>
［
%secure ~EQ ~F
］~AND［
`設定群は混在~保安的~文脈を禁制するか？$( %~client の`大域~obj$xに`関連する設定群~obj$ )
の結果 ~EQ `禁制する^i
］ならば
⇒
~clientは、`~WebSocket接続を失敗させ$た上で，接続を中止し~MUST
`RFC6455$r
◎
If secure is false, and the algorithm in §5.1 Does settings prohibit mixed security contexts? returns "Restricts Mixed Security Context" when applied to client’s global object’s relevant settings object, then the client MUST fail the WebSocket connection and abort the connection [RFC6455].
</li>
		</ol>
	</li>
	<li>
<p>
現在の段 5 の後に，次の段を遂行する：
◎
After the current step 5, perform the following step:
</p>
		<ol start="6">
			<li>
<p>
［
%secure ~EQ ~T
］~AND［
段 5 で遂行した ~TLS-handshakeの結果による~HTTPS状態 ~EQ `deprecated^l
］ならば
⇒
~clientは`~WebSocket接続を失敗させ$た上で，接続を中止し~MUST
`RFC6455$r
◎
If secure is true, and the TLS handshake performed in step 5 results in an HTTPS state of "deprecated", then the client MUST fail the WebSocket connection and abort the connection [RFC6455].
</p>

<p class="issue">
この段は、ごく説明的なものに過ぎない。
<span class="trans-note">【
参考：
`Fetch$r 仕様の
<a href="~FETCH#websocket-protocol">~WebSocketに対する改め節</a>
。
】</span>
◎
This is super hand-wavey.
</p>

			</li>
		</ol>
	</li>
</ol>


<p class="note">注記：
`RFC6455$r に対する
<a href="http://www.rfc-editor.org/errata_search.php?rfc=6455&amp;eid=4398">正誤表 #4398</a>
として~~提出されている。
◎
Note: Filed as errata #4398 against [RFC6455].
</p>


<p>
これらの変更点により、
`WebSocket$I ~objの構築-時に `SecurityError^E 例外が直に投出されることはなくなり、それに代わって，［
接続を阻止して`~WebSocket接続を失敗させ$る
］ことに依拠することになる
— 開発者は、 `WebSocket$I ~objの `onerror$m ~handlerを通して，それを捕えれる。
これにより、［
`XMLHttpRequest$I ／ `EventSource$I ／ `fetch()$m
］と 挙動が一貫するようになる。
◎
These changes together mean that we’ll no longer throw a SecurityError exception directly upon constructing a WebSocket object, but will instead rely upon blocking the connection and triggering the fail the WebSocket connection algorithm, which developers can catch by hooking a WebSocket object’s onerror handler. This is consistent with the behavior of XMLHttpRequest, EventSource, and Fetch.
</p>

	</section>
	<section id="security-considerations">
<h2 title="Security and Privacy Considerations">7. 保安, および~privacy上の考慮点</h2>

		<section id="limitations">
<h3 title="Limitations">7.1. 限界</h3>

<p>
混在~内容の阻止法は、<a href="#intro">序論 節</a>にて論じた保証を確保してくれる。
しかしながら，その保証は、［
能動的な~network攻撃者が，伝送路を流れる［
~code／内容
］の~criticalな~bitを置換する
］ことに抗して，開発者や利用者を保護することに<em>限られる</em>ことに注意。
それは、［
弱体化され，改ざんされた資源を送信するよう強要された~server
］に抗する保護は~~提供しない。
◎
Blocking mixed content allows us to ensure that the guarantees discussed in §1 Introduction are upheld. Note, however, that those guarantees only protect developers and users against active network attackers who would otherwise be able to replace critical bits of code or content on the wire as it flows past. They do not protect against a compromised server that itself is coerced into sending corrupted resources.
</p>

<p>
Subresource Integrity （ “下位資源の完全性” ）
`SRI$r などの仕組みは、この種の脅威に~~対処するために設計されている。
~web開発者には、可能0なときは，それを用立てることを推奨する。
◎
Mechanisms such as Subresource Integrity [SRI] are designed to deal with this kind of threat, and we recommend that web developers make use of them whenever possible.
</p>

		</section>
		<section id="requirements-forms">
<h3 title="Form Submission">7.2. ~form提出</h3>

<p>
`文書$ %文書 に対し，［
`設定群は混在~保安的~文脈を禁制するか？$( %文書 に`関連する設定群~obj$ )
の結果 ~EQ `禁制する^i
］の場合、~UAは， %文書 内に［
値が`先天的に認証済み~URL$でない `action$a 属性
］を有する `form$e 要素が在するときには，そのことを利用者に警告しても~MAY。
◎
If §5.1 Does settings prohibit mixed security contexts? returns Restricts Mixed Content when applied to a Document's relevant settings object, then a user agent MAY choose to warn users of the presence of one or more form elements with action attributes whose values are not a priori authenticated URLs.

incumbent
</p>

<p class="note">注記：
例えば現在の Chrome は、非保安的~form動作を伴う~pageの~UIを，非保安的~画像を表示する~pageに対するときと同じに扱う。
◎
Note: Chrome, for example, currently gives the same UI treatment to a page with an insecure form action as it does for a page that displays an insecure image.
</p>

<p>
~UAは更に、そのような`文書$からの~form提出を
— 文書が`~top-level閲覧文脈$に属する場合でも —
`阻止可能$な要請と扱って~MAY。
◎
Further, a user agent MAY treat form submissions from such a Document as a blockable request, even if the submission occurs in the top-level browsing context.
</p>

		</section>
		<section id="requirements-ux">
<h3 title="UI Requirements">7.3. ~UIに課される要件</h3>

<p>
~UAは、［
通常~時には、`~top-level閲覧文脈$が保安的であるときは，そのことを利用者に指示する
］のであれば：
◎
If a user agent would normally indicate to the user that the top-level browsing context is secure, then:
</p>

<ul>
	<li>
<p>
`混在~内容$への`要請$に対する応答として資源を返すことにより，当の文脈を`混在~保安的~文脈$に降格するときは（`要請$は `随意に阻止可能$である，あるいは `阻止可能$な`要請$を許容するよう環境設定されていることにより）：
</p>
		<ul>
			<li>
利用者に，同じ［
保安的であることの指示
］を提供しては~MUST_NOT。
</li>
			<li>
代わりに，`混在~内容$の存在0を指示する~SHOULDである。
</li>
		</ul>

◎
When the user agent downgrades a context to a mixed security context by returning a resource in response to a mixed content request (either because the request is optionally-blockable, or because the user agent is configured to allow blockable requests), the user agent MUST NOT provide the user with that same indication.
◎
The user agent SHOULD instead give an indication that mixed content is present.
</li>
</ul>

<p>
~UAは，混在~内容の存在0を指示するときは、支援技術の利用者にも，~accessibility API を通して それを可用にし~MUST。
◎
If a mixed content indication is present, it MUST be made available through accessibility APIs for users of assistive technologies.
</p>

<p class="note">注記：
この節の要件は、
<a href="https://cabforum.org/about-ev-ssl/">EV 状態0</a>
`CAB$r の文脈においても保持される。
EV 証明書の指示子により，［
混在~内容に対する違反を，利用者~向けに通知する必要性
］が上書きされることはない。
◎
Note: This requirement holds even in the context of an EV status [CAB]. An EV certificate’s indicator does not override the necessity to notify users of mixed content violations.
</p>

		</section>
		<section id="requirements-user-controls">
<h3 title="User Controls">7.4. 利用者による制御</h3>

<p>
~UAは、<strong>すべて</strong>の`混在~内容$を`阻止可能$として扱う（すなわち，`随意に阻止可能$な混在~内容であっても阻止する）かどうかについて，利用者が直接的に決める能を提供0して~MAY。
◎
A user agent MAY offer users the ability to directly decide whether or not to treat all mixed content as blockable (meaning that even optionally-blockable mixed content would be blocked).
</p>

<p class="note">注記：
提供された場合、利用者には，そのような~optionの利点を採ることが<em>強く推奨される</em>。
◎
Note: It is strongly recommended that users take advantage of such an option if provided.
</p>

<p>
~UAは、特定0の~page上で［
`阻止可能$な混在~内容を阻止する決断
］を上書きする
【阻止しなくする】
能を，利用者に提供0して~MAY。
◎
A user agent MAY offer users the ability to override its decision to block blockable mixed content on a particular page.
</p>

<p class="note">注記：
実施上は、~UAはおそらく，そのような裏口を提供0したままで済ますわけにはいかない。
すなわち、混在~scriptを許容する~optionは，特に危険である。
~UAは，そのような選択肢を
— 熟慮の下で［
孕まれる~riskについて利用者に伝え, やりとりする
］ことなく —
提示することは，~~本当はやってはいけない（
<a href="~IETF/rfc6919#section-3">REALLY SHOULD NOT</a>
`RFC6919$r
）
。
◎
Note: Practically, a user agent probably can’t get away with not offering such a back door. That said, allowing mixed script is in particular a very dangerous option, and each user agent REALLY SHOULD NOT [RFC6919] present such a choice to users without careful consideration and communication of the risk involved.
</p>

<p>
そのような制御を提供0する~UAは、支援技術の利用者に対しても，~accessibility API を通して提供0し~MUST。
◎
Any such controls offered by a user agent MUST also be offered through accessibility APIs for users of assistive technologies.
</p>

		</section>
		<section id="service-workers">
<h3 title="Service Workers">7.5. ~Service-Worker</h3>

<p>
~Service-Workerは，文書と~network手段との合間に居座るので、その文脈~下で発行される要請に対しては，特別に扱う必要がある。
特に，~Service-Workerは、非保安的~要請に対しては，それが文書から誘発されたのであれば（したがって、その要請は`随意に阻止可能$な文脈~下で利用されることは，およそ確保されることになる），その結果を~cacheできるべきである。
しかしながら、そのような非保安的な結果は，~Service-Worker向けには公開できない。
また、~Service-Workerには，［
`随意に阻止可能$な要請に対する応答を，`阻止可能$な要請に対する応答に洗浄する
］ことも許容されるべきでない。
◎
The fact that Service Workers sit inbetween a document and the network means that we need to special-case requests made in those contexts. In particular, they should be able to cache the results of insecure requests, provided that those requests were triggered from a document (which, presumably, ensures that they’ll be used in an optionally-blockable context). Those insecure results, however, cannot be exposed to the Service Worker, nor should the Service Worker be allowed to launder responses to optionally-blockable requests into responses to blockable requests.
</p>

<p>
そのようなわけで：
◎
To that end:
</p>

<ol>
	<li>
<p>
［
`要請の~fetchingは混在~内容として阻止されるべきか？$
］には、 `fetch^m による要請の`起動元$rqに対し，ある carve-out がある
— それには［
~Service-Workerが、`~Fetch~event$に対する応答の一部として，要請を複製できるようにする
］意図がある（例：
`fetch(event.response)^m
は、~event~handlerの内側では，実行可能になるべきである）。
◎
§5.3 Should fetching request be blocked as mixed content? has some carve-outs for the fetch request initiator, with the intent of allowing a Service Worker to copy a request as part of its response to a Fetch event (e.g. fetch(event.response) should be executable inside the event handler.
</p>

<p>
`~Fetch~event$の文脈の外側で実行される `fetch()^m は、`阻止可能$と扱われ続けることになる。
この外側には、もちろん，文書~文脈も含まれる。
◎
fetch will continue to be treated as blockable when executed outside the context of a Fetch event, which of course includes document contexts.
</p>
	</li>
	<li>
`要請に対する応答は混在~内容として阻止されるべきか？$は、［
入って来る応答に備わる保安~特徴が，要請に許容されるそれと同じ
］かどうかを検証0する。
すなわち，~Service-Workerは、［
保安的~scriptに対する要請
］に対しては，［
非保安的~資源に対し~cacheされた応答
］で~~代用できないことになる。
◎
§5.4 Should response to request be blocked as mixed content? verifies that the incoming response has the same security characteristics that were allowed for the request. That is, a Service Worker will not be able to replace a request for a secure script with a cached response for an insecure resource.
</li>
</ol>


		</section>
		<section id="further-action">
<h3 title="Further Action">7.6. 更なる動作</h3>

<p>
~UAには、開発者に混在~内容を埋込まないことを奨励するため，この文書に概説した要件~以上の，更なる動作を採ることが奨励される。
◎
A user agent is encouraged to take further action above and beyond the requirements this document outlines in order to discourage developers from embedding mixed content.
</p>

<p>
具体例として、~UAは次を採ることもできる：
◎
For instance, a user agent could:
</p>

<ol>
	<li>
`Strict-Transport-Security^h ~header~fieldの存在0を，［
すべての内容を`阻止可能$に分類するよう強制する `RFC6797$r
］, あるいは［
混在~内容の検査-時に`厳格~mode$を可能化する
］ものとして解釈する。
◎
Interpret the presence of a Strict-Transport-Security header field as forcing all content into the blockable category [RFC6797], or as a signal to enable strict mode for mixed content checking.
</li>
	<li>
`混在~内容$であって`随意に阻止可能$な資源に対する要請を，利用者の~riskが抑制されるように改変する
— ~cookieその他の認証~tokenを要請から剥ぎ取ったり，~schemeの自動的な昇格を試みる，等々。
<!-- 
http: URL に対する要請に先立って，~schemeを https: に違えて要請する？
 -->
◎
Modify requests for optionally-blockable resources which are mixed content in order to reduce the risk to users: cookies and other authentication tokens could be stripped from the requests, automatic scheme upgrades could be attempted, and so on.
</li>
	<li>
`入子の閲覧文脈$の内側にある`随意に阻止可能$な資源を，`阻止可能$として扱って、~siteが，混在~内容が導入されるおそれなく資源を埋込めるようにする。
◎
Treat optionally-blockable resources inside nested browsing contexts as blockable, to allow sites to embed resources without fear of introducing mixed content.
</li>
</ol>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">8. IANA 考慮点</h2>

<p>
~CSP指令~registry `RFC7762$r は、次の指令および参照先で更新されるべきである：
◎
The Content Security Policy Directive registry should be updated with the following directives and references [RFC7762]:
</p>

<dl>
	<dt>`block-all-mixed-content$dir</dt>
	<dd>
この文書（ <a href="#strict-opt-in">~opt-in法 節</a> ）
◎
This document (see §4.2 Opting-in)
</dd>

</dl>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">9. 謝辞</h2>

<p>
WebAppSec WG から集められた，賞賛すべき~feedbackに加えて、
Chrome の保安~teamは，この仕様の準備に計り知れなく~~寄与された。
特に、早期に多数の~feedbackを寄せられた各~氏：
Chris Palmer, Chris Evans, Ryan Sleevi, Michal Zalewski, Ken Buchanan, and Tom Sepez
。
Fetch を説明され、この仕様への~interfaceを定義することに助力された
Anne van Kesteren 氏。
この仕様を注目させ, 手入れし, 健全に保つことに助力された Brian Smith 氏。
◎
In addition to the wonderful feedback gathered from the WebAppSec WG, the Chrome security team was invaluable in preparing this specification. In particular, Chris Palmer, Chris Evans, Ryan Sleevi, Michal Zalewski, Ken Buchanan, and Tom Sepez gave lots of early feedback. Anne van Kesteren explained Fetch and helped define the interface to this specification. Brian Smith helped keep the spec focused, trim, and sane.
</p>


	</section>

</main></div><!-- MAIN/MAIN0 -->

	<section id="conformance">
<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>
<!-- 

Conformance
Document conventions

Conformance requirements are expressed with a combination of descriptive assertions and RFC 2119 terminology. The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in the normative parts of this document are to be interpreted as described in RFC 2119. However, for readability, these words do not appear in all uppercase letters in this specification.

All of the text of this specification is normative except sections explicitly marked as non-normative, examples, and notes. [RFC2119]

Examples in this specification are introduced with the words “for example” or are set apart from the normative text with class="example", like this:

This is an example of an informative example.

Informative notes begin with the word “Note” and are set apart from the normative text with class="note", like this:

Note, this is an informative note.
Conformant Algorithms

Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("must", "should", "may", etc) used in introducing the algorithm.

Conformance requirements phrased as algorithms or specific steps can be implemented in any manner, so long as the end result is equivalent. In particular, the algorithms defined in this specification are intended to be easy to understand and are not intended to be performant. Implementers are encouraged to optimize.

-->



	</section>
	<section id="index">
<h2 title="Index">索引</h2>

<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>

	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範的）</h3>


<p class="trans-note">【
[SW] は、この訳による補完。
】</p>

<script type="text/plain" class="ref_data">
[CSP3]
    Mike West. Content Security Policy Level 3. 21 June 2016. WD. URL: https://w3c.github.io/webappsec-csp/ 
[CSS-BACKGROUNDS-3]
    CSS Backgrounds and Borders Module Level 3 URL: https://drafts.csswg.org/css-backgrounds-3/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HTML51]
    Steve Faulkner; et al. HTML 5.1. 21 June 2016. CR. URL: https://w3c.github.io/html/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC6455]
    I. Fette; A. Melnikov. The WebSocket Protocol. December 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6455 
[RFC6797]
    J. Hodges; C. Jackson; A. Barth. HTTP Strict Transport Security (HSTS). November 2012. Proposed Standard. URL: https://tools.ietf.org/html/rfc6797 
[RFC7762]
    M. West. Initial Assignment for the Content Security Policy Directives Registry. January 2016. Informational. URL: https://tools.ietf.org/html/rfc7762 
[SECURE-CONTEXTS]
    Mike West. Secure Contexts. 19 July 2016. WD. URL: https://w3c.github.io/webappsec-secure-contexts/ 
[WEBSOCKETS]
    Ian Hickson. The WebSocket API. 20 September 2012. CR. URL: https://www.w3.org/TR/websockets/ 
[WHATWG-URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
</script>


		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<script type="text/plain" class="ref_data">
[CAB]
    CA/Browser Forum Baseline Requirements v1.3.7. 8 July, 2016. URL: https://cabforum.org/baseline-requirements-documents/ 
[RFC6919]
    R. Barnes; S. Kent; E. Rescorla. Further Key Words for Use in RFCs to Indicate Requirement Levels. 1 April 2013. Experimental. URL: https://tools.ietf.org/html/rfc6919 
[SRI]
    Devdatta Akhawe; et al. Subresource Integrity. 23 June 2016. REC. URL: https://w3c.github.io/webappsec-subresource-integrity/ 
[WSC-UI]
    Thomas Roessler; Anil Saldhana. Web Security Context: User Interface Guidelines. 12 August 2010. REC. URL: https://www.w3.org/TR/wsc-ui/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml 
</script>




		</section>
	</section>
	<section id="issues-index">
<h2 title="Issues Index" data-cycling=".issue">課題索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>

	</section>
