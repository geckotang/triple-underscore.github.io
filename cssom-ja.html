<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Object Model (CSSOM) （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>
td:first-child, th:first-child {
	border-right: 1px solid gray;
}
tr{
	border-top: 1px solid gray;
}

thead > tr:first-child {
	border-top: none;
	border-bottom: 2px solid black;
}

/* HTTP ヘッダ名 */
.header {
	color: #035;
	font-weight: bold;
}

th[colspan]{
	padding: 0.5em;
}
</style>

<!--
dd > ol:first-child {
	padding-left:0;
}

 -->

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	var source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 170308 spec

}

function expand(){

	var class_map = {
		p: 'property',
		d: 'descriptor',
		ps: 'pseudo',
		pe: 'pseudo',
		v: 'value',
		t: 'type',
		td: 'type',
		css: 'css',
		e: 'element',
		a: 'attr',
		at: 'at-rule',
		E: 'error',
		h: 'header',
		U0: 'code-point',
	};

	var tag_map = {
		p: 'code',
		d: 'code',
		ps: 'code',
		pe: 'code',
		I: 'code',
		m: 'code',
		e: 'code',
		E: 'code',
		a: 'code',
		at: 'code',
		h: 'code',
		css: 'code',
		xmlss: 'code',
		c: 'code',
		U0: 'span',
		td: 'var',
		v: 'code',
		t: 'var',
		i: 'i',
//		V: 'var',
	};

	var link_map = this.link_map;
	var idl_ifc = '';

	return this.html.replace(
		/❝.|%[~\w\-一-鿆あ-ん]+|`(.+?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
//	var t = match.charAt(0);
	switch(match[0]){
	case '❝':
		return (
			'<span class="code-point">U+' +
( ('000' + match.charCodeAt(1).toString(16).toUpperCase()).slice(-4) ) +
			'</span> (<span class="char-symbol">' + match[1] + '</span>)'
		);
	default: //%
		return '<var>' + match.slice(1) + '</var>';
	}
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'I': // IDL interface
	if((indicator === '@') || (indicator === '!')){
		idl_ifc = key;
	}
	href = '#' + key.toLowerCase();
	break;
//case 'mb': // IDL dictionary member
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = '#dom-' + (
		(key === idl_ifc) ? idl_ifc : (idl_ifc + '-' + key)
	).toLowerCase();
	break;
case 'ps': // pseudo
	text = ':' + key;
	break;
case 'pe': // pseudo element
	text = '::' + key;
	break;
case 'at': // at-rule
	text = '@' + key;
	break;
case 't': // type
	text = '&lt;' + key + '&gt;';
	break;
case 'td': // desc value type
	text = '&lt;‘<code class="descriptor">' + key + '</code>’&gt;';
	klass = 'd';
	break;
case 'U0': // code point
	text = 'U+' + key;
	break;
case 'E': // error
	href = '~WEBIDL#' + key.toLowerCase();
	break;
case 'l': // literal
	return '"<code class="literal">' + text + '</code>"'
case 'v': // variables
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}
return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Object Model (CSSOM)
spec_date:2017-09-29
trans_update:2017-10-26
page_state_key:CSS
original_url:https://drafts.csswg.org/cssom-1/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2017,permissive
trans_1st_pub:2012-05-31


●●original_id_map


ascii-case-insensitive:
whitespace:
ignored:
concept-node:
cascaded-value:
computed-value:
used-value:
initial-value:
specified-value:
shorthand:
longhand:
canonical-order:

selector:
selectors-list:
complex-selector:
compound-selector:
simple-selector:
universal-selector:
attribute-selector:
id-selector:
type-selector:
class-selector:
pseudo-class:
pseudo-element:
combinator:

namespace-prefix:
default-namespace:
null-namespace:
page-selector:
margin-at-rules:
list-of-css-page-selectors:

serialize-a-css-longhands:
css-style-rule:


●●words_table1


XMLSS:http://www.w3.org/TR/xml-stylesheet/
	XMLSS:XML/xml-stylesheet-ja.html
CSSFONT4:https://drafts.csswg.org/css-fonts-4/#cssfontfacerule0

APPEND: <span class="op">&lt;&lt;</span> 
SP: <span class="op">SPACE</span> 
RA:readonly attribute
UL:unsigned long
US:unsigned short
MediaList: <code>MediaList</code> 
ACI:<sub>大小無視</sub>

camel_cased_attr:<var>camel_cased_attribute</var>
webkit_cased_attr:<var>webkit_cased_attribute</var>
dashed_attr:<var>dashed_attribute</var>
cssText0:cssText


●●words_table



	●仕様
API:
UA:user agent:UA::ユーザエージェント
vendor:::ベンダ
algo:algorithm::アルゴリズム
utility:::ユーティリティ
bug:::バグ
cost:::コスト

特色機能:feature:~
作者:author:~
利用者:user:~
作者定義:author-defined:作者定義の
定義-:define:~
定義:definition:~
定義表:definition table:~
指定:sepcify:~
仕様:spec:~
	specification
実装:implementation:~
実装-:implement:~
要件:requirements:~
拡張-:extend:~
拡張:extension:~
適切:appropriate:~
概念:concept:~
適用-:apply:~
導入-:introduce:~
影響-:affect:~
歴史的:historical:~
変更点:changes:~
明示的:explicit:~
互換性:compatibility:~
相互運用性:interoperability:~
厳密:strict:~
技術的:technical:~
適合性:conformance:~
取組む:address する:取り組む
展開-:expand:~
中核:core:~
非推奨:deprecated:~
廃用に:obsolete:~
予期-:expect:~
拘束:constraint:~
更新:update:~
省略可:optional:~
意味論:semantics:~
本質的:essential:~
直接的:direct:~
上書き:override:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
結付け:association:結び付け
将来的:future:~
予約-:reserved:~
依存-:depend:~
発行版:publications:~
網羅的:exhaustive:~
編集上の:editorial:~
関連の:related:~
指定-:specify:~
許容-:allow:~
	許容されない:disallow
特定0の:particular:ある特定の
位置付け:status:~
特別:special:~
一般:general:~
仕事:work:~
仮想の:hypothetical:~
基本的:basic:~
実際:actual:~
履歴:history:~
改訂:revisions:~
標準:standard:~
機能:function:~
汎用の:generic:~
登録-:register:~
	registration
編集者草案:Editor’s Draft
試験-:test:~
	試験し易く:testability
課題:issue:~
配備済みの:deployed:~
情報:information:~
抽象的:abstract:~
custom:::カスタム
手続き:steps:~
段:step:~

仕方:way:~
	方法:how
共通する:common な:~
目的:purpose:~
実質的:effective:~
相違:difference:~
避ける:avoid する:~
孕まれ:involve され:~
観測-:observe:~
	観測され得る:observable
要求-:require:~
	~~目的:oriented towards
	他方:On the other hand
	あるいは、:alternatively
	一方で:whereas
	選んで:choice
	特に:specifically
	各種用語／用語:terminology
	意味-:mean
	修正:fixes
	参照文献
	向上-:improve:~
	序論:introduction
	用例集:Examples
	管理
	草案:draft:~
	詳細:specific／specificity
	謝辞
	注記:
	例:example
	略記:-
	備考:-
	明確:-
	規定:-
	可能:-
	状況:circumstance
	総称:
	必要
	意味
	呼称:-

	●fetch
url:
address:::アドレス
URL:
LOCAL:
intranet:::イントラネット
protocol:::プロトコル
header:::ヘッダ
fetch:
fetching:::fetch 処理
network:::ネットワーク
referrer:::リファラ
符号化方式:encoding:~::エンコーディング
label:::ラベル
資源:resource::~:リソース
要請:request::~:リクエスト
応答:response::~:レスポンス
生成元:origin::~:オリジン
非同一生成元:cross-origin::~:クロスオリジン
同一生成元:same-origin::~:同一オリジン
	inputURL:input URL:入力~URL
所在:location::~
give-up:give up


	●IDL
member:::メンバ
access:::アクセス
obj:object::オブジェクト
ifc:interface::インタフェース
meth:method::メソッド
instance:::インスタンス
prolog:::プロローグ

構築子:constructor:~::コンストラクタ
	投出:throw:~
再投出-:re-throw:~
例外:exception:~
継承-:inherit:~
	継承:inheritance:~
被support:supported:被 support:被サポート
読専:readonly:読み取り専用
読取り:reading:読み取り
凍結:frozen:~
配列:array:~
正則属性:regular attribute:~
拡張属性:extended attribute:~
取得子:getter:~
設定子:setter:~
	On getting:
	On setting:
注釈付き:annotated:~
被呼出時:被 invoke 時:~
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
呼出す:invoke する:呼び出す
呼出さ:invoke し:呼び出さ
呼出し:invoking:呼び出し
返さ:return し:~
返され:return され:~
返す:return する:~
部分的:partial:~


	●DOM
DOM:
文書:document:~
要素:element:~
属性:attribute:~
	要素~名:element name:~
	属性~名:attribute name:~
	属性~値:attribute value:~
疑似属性:pseudo-attribute:~
名前空間:namespace::~
	名前空間~接頭辞:namespace prefix:~
接頭辞:prefix::~
接頭dash:dash prefix::dash 接頭
処理命令:processing instruction:~
過去互換:quirks::~
node:::ノード
親:parent::~
子:child::~
tree:::ツリー

	●CSS
CSS:
style:::スタイル
styling:::スタイル付け
ss:style sheet::スタイルシート
class:::クラス
margin:::マージン
important:
cascaded:::カスケード
cascading:::カスケード法
box:::ボックス
pixel:::ピクセル
prop:property::プロパティ
略式:shorthand:~
下位prop:sub-properties:下位 properties:下位プロパティ
	longhand
記述子:descriptor:~
初期値:initial value:~
使用値:used value:~
算出値:computed value:~
指定値:specified value:~
解決値:resolved value:~
疑似要素:pseudo-element:~
疑似類:pseudo-class:疑似 class:疑似クラス
結合子:combinator::~
	コンビネータ
	属性~選択子
	~class選択子
	型~選択子
選択子:selector::~:セレクタ
全称:universal::~
単体:simple::~
合体:compound::~
複体:complex::~
選択子群:group of selectors::選択子グループ:セレクタグループ

規則:rule::~:ルール
	規則集合
集合:set:~::セット
規則列:rules::規則リスト:ルールリスト
媒体:media::~:メディア
特能:feature::~
照会:query::クエリ
	媒体照会~list:media query list::媒体クエリリスト:メディアクエリ リスト
宣言-:declare:~
宣言:declaration:~
宣言列:declarations:宣言 list:宣言リスト
遷移:transition::~
算出-:compute:~
絶対的:absolute:~
相対的:relative:~
絶対:absolute:~
相対:relative:~
単位:unit:~
数値:numeric value:~
解像度:resolution:~
周波数:frequency:~
整数:integer:~
色:color:~
長さ:length:~
有位置の:positioned:~

具現化:rendering:~::レンダリング
呈示hint:presentational hints:呈示 hint:呈示ヒント


	●構文
ASCII:
comma:::カンマ
semicolon:::セミコロン
escape:::エスケープ
	ダッシュ:dash:~
keyword:
newline:
UTF-8:
surrogate:::サロゲート
文字大小区別:case-sensitive:~
文字大小:case:~
大小区別:case-sensitive:~
大小無視:case-insensitive:~
識別子:identifier:~
文字列:string:~
空白:whitespace:~
空:empty:~
正規化-:normalize:~
直列化-:serialize:直列化::シリアル化
	直列化-法:serializing
	直列化-済み:serialized
直列化:serialization:~::シリアル化

構文解析器:parser:~::パーサ
構文解析-:parse:~::パース
構文解析法:parsing:~::パース法
構文解析:parsing:~::パース処理
解析済み:parsed:~::パース済み
大文字:uppercase:~
小文字:lowercase:~
小文字先頭:lowercase first:~
辞書式:lexicographical:~
正準的:canonical:~
正準形:canonical form:~
符号位置:code point::~
符号単位:code unit::~

順序:order:~
有順序:ordered:~
成分値:component value:~
成分:component:~
構文:syntax:~
文法:grammar:~
文字:character:~
名前:name:~
名:name:~
省略済:trimmed:省略済み
基数:base:~
基数10:base-ten:10 進
数字:digit:~
選好-:prefer::~
選好:preferred::~
選好順:preferred order:~
指定順:specified order:~
	区切子:delimiter 1
	区切り:-separated 17
整形式の:well-formed:~
失敗:failure:~

	●未分類（動詞
準備済み:ready::~
走って:run して:~
走らす:run する:~
走らせ:run し:~
合致-:match:~::マッチ
可能化-:enable::~
可能化:enabled::~
不能化-:disable::~
不能化:disabled::~
代替-:alternate::~
代替:alternative::~
持続化-:persist::~
持続化:persisting::~
持続的:persistent::~
阻んで:block して::~:ブロックして
封入-:enclose:包含
入子に:nest:入れ子に
選択-:select:選択
選択:selecting:~
作成-:create:~
	作成-時:create 時:~
設定-:set:~
変更-:change:~
改変:modifing:~
	~~変更:mutating
変異-:mutate:~
変異可能:mutable:~
除去-:remove:~
付加-:append:~
挿入-:insert:~
追加-:add:~
下層の:underlying:~
参照:reference:~
	~~参照:refer:~
表現:representation:~
表現-:represent:~
公開-:expose:~
決定-:determine:~
変化:change:~
初期:initial:~
初期化-:initialize:~
無視-:ignore:~
失敗-:fail:~
解決-:resolve:~
操作:manipulation:~
操作-:manipulate:~
往来:round-trip:~
中止-:abort:~
停止-:stop:~
待機-:wait:~
置換-:replace:~
置換:replacement:~
到達-:reach:~
埋込みの:embedded:埋め込みの
反映-:reflect:~
提供-:provide:~
格納-:store:~
落とし:drop し:~
落とさ:drop さ:~
読込み:loading:読み込み
否定形:negated:~
関係:relation:~
必須の:required:~
移行-:move:~
比較:comparison:~
比較-:compare:~
取得-:get:~
生成-:generate:~
保全-:preserve:~
	所与の:given
	対応付ける:map する:~
	対応
	対応-:map
	反復:-
	存続:-
	処理:processing
	処理前:before
	処理後:after
	前置-:precede
	除外-:excluding／omitting
	~~混在: 1
	遂行-:perform:~
	読み取る:read
	返す:return
	書かれ:write
	変換:〜to
	転換-:turn into
	連結:concatenation／
	存在:exist
	不在:absent
	呼ばれ／:named
	~~反映:updated as appropriate
	在る:is present

	●未分類
web:
SVG:
IDL:
CORS:
metadata:::メタデータ
script:::スクリプト
	alpha:::アルファ
inline:::インライン
live:
flag:::フラグ
list:::リスト
link:::リンク
parameter:::パラメタ
error:::エラー
index:
source:::ソース
macro:
text:::テキスト
	type:::種別
null:
	inclusion:
field:::フィールド
collection:::コレクション
	~chain:::チェイン
title:::タイトル
support:::サポート
mode:::モード
title:::タイトル
data:::データ
dot:::ドット
event-loop:event loop::イベントループ

基底:base:~
優先度:priority::~
既定:default:~::デフォルト
既定の:default:~::デフォルト
状態:state:~
内容:content:~
	内容~属性:content attribute:~
頁:page::ページ
型:type::~
所有者:owner::~
block:::ブロック

種別:type::~

文脈:context:~
item:::アイテム
引数:argument:~
値:value:~
新たな:new:~
頁:page::ページ
ゼロ:zero:~
メモリ:memory:~
	プラットフォーム:platform:~
	カスケード:cascade:~
	モジュール:module:~
言語:language:~
範囲:range:~
静的:static:~
空間:space:~
環境:environment:~
大域:global:~::グローバル
選択肢:option:~
形式:format:~
関数:function:~
	~RET:terminate these steps
不透明:opaque:~

	可能:
	関数記法:functional equivalent
	-:literal
	変数:-
	区別:-
	省略:-
	出力:output／
	別途
	進数
	小数部
	用途
	秒数
	過程
	種類:-
	非負:non-negative
	負:negative
	一覧:table／list
	一致:identical／
	入力:input
	利用:
	位置:position／
	minus
	per
	節:section

	●指示語
現在の:current:~
	現在:currently
内部的:internal:~
正確:exact:~
	最後の:last:~
	最初の:first:~
	以前:formerly
	唯一:only
	前後
	一方
	個数
	以外
	先頭
	一連
	以下
	任意
	他の場合:otherwise
	同じ:same
	個目の:second／third
	一部
	部分
	複数
	特定
	全体
	自身
	先行
	内部
	末尾
	該当
	後続
	当該
	個以上
	時点
	各種
	場合
	結果:result
	初回
	回目
	以上
	余分
	列目
	最短形の:shortest form possible
	最短の:shortest
	限られた~~範囲:less-widely
	総数
	最高位:greatest 〜 order
	part
	最小個数


●●link_map



	●IDL
CEReactions:~HEcustom#cereactions
TreatNullAs:~WEBIDL#TreatNullAs
SameObject:~WEBIDL#SameObject
PutForwards:~WEBIDL#PutForwards
NoInterfaceObject:~WEBIDL#NoInterfaceObject
NewObject:~WEBIDL#NewObject
LegacyArrayClass:~WEBIDL#LegacyArrayClass
Exposed:~WEBIDL#Exposed

CSSOMString:#typedefdef-cssomstring
USVString:~WEBIDL#idl-USVString
DOMString:~WEBIDL#idl-DOMString
I.CSSOMString:#typedefdef-cssomstring
I.USVString:~WEBIDL#idl-USVString
I.DOMString:~WEBIDL#idl-DOMString
I.CSSMediaRule:~CSSCOND#cssmediarule

I.Element:~DOM4#element
I.Document:~DOM4#document
I.ProcessingInstruction:~DOM4#processinginstruction

I.CSSFontFaceRule:~CSSFONT4#cssfontfacerule0
I.CSSPseudoElement:~CSSPSEUDO#csspseudoelement

	m.Window.getComputedStyle:#dom-window-getcomputedstyle
m.cssText:#dom-cssstyledeclaration-csstext
m.~cssText0:#dom-cssrule-csstext
m.mediaText:#dom-medialist-mediatext
m.StyleSheet.href:#dom-stylesheet-href
m.StyleSheet.media:#dom-stylesheet-media
m.CSS.escape:#dom-css-escape


m.~camel_cased_attr:#dom-cssstyledeclaration-camel-cased-attribute
m.~webkit_cased_attr:#dom-cssstyledeclaration-webkit-cased-attribute
m.~dashed_attr:#dom-cssstyledeclaration-dashed-attribute

m.stringifier:#MediaList-stringification-behavior

	●css
	＊t.selector:~SELECTORS#typedef-selector
t.selector-list:~SELECTORS#typedef-selector-list
	selectors_group 生成規則:~TR/css3-selectors/#grammar
	// TODO
t.angle:~CSSVAL#angle-value
t.number:~CSSVAL#number-value
t.length:~CSSVAL#length-value
t.frequency:~CSSVAL#frequency-value
t.identifier:~CSSVAL#identifier
	~CSSSYN#typedef-ident-token
t.integer:~CSSVAL#integer-value
t.percentage:~CSSVAL#percentage-value
t.resolution:~CSSVAL#resolution-value
t.string:~CSSVAL#string-value
t.time:~CSSVAL#time-value
t.uri:~CSSVAL#url-value
t.shape:~CSS2VISUFX#value-def-shape
		~CSSSHAPE#typedef-basic-shape
t.family-name:~CSSFONT#family-name-value
t.color:~CSSCOLOR#typedef-color
t.page-selector-list:~CSSPAGE#typedef-page-selector-list

	t.alphavalue:~CSSCOLOR#
	t.counter:~CSSCOUNTER#
	t.absolute-size:~XXXXX#typedef-
	t.border-width:~CSSBG#typedef-
		t.line-width:~CSSBG#typedef-line-width
	t.border-style:~CSSBG#typedef-
		t.line-style:~CSSBG#typedef-line-style
	t.margin-width:~CSS2BOX#value-def-margin-width
	t.padding-width:~CSS2BOX##value-def-padding-width
	t.bottom:~XXXXX#typedef-
	t.right:~XXXXX#typedef-
	t.left:~XXXXX#typedef-
	t.top:~XXXXX#typedef-
	t.generic-family:~CSSFONT#generic-family-value
	t.generic-voice:~CSSSPEECH#voice-family-generic-voice
	t.specific-voice:
		~CSSSPEECH#voice-family-name
	t.relative-size:~XXXXX#typedef-

p.line-height:~CSS2VISUDET#propdef-line-height

p.width:~CSS2VISUDET#propdef-width
p.height:~CSS2VISUDET#propdef-height
p.margin-bottom:~CSS2BOX#propdef-margin-bottom
p.margin-left:~CSS2BOX#propdef-margin-left
p.margin-right:~CSS2BOX#propdef-margin-right
p.margin-top:~CSS2BOX#propdef-margin-top
p.margin:~CSS2BOX#propdef-margin
p.padding-bottom:~CSS2BOX#propdef-padding-bottom
p.padding-left:~CSS2BOX#propdef-padding-left
p.padding-right:~CSS2BOX#propdef-padding-right
p.padding-top:~CSS2BOX#propdef-padding-top
p.padding:~CSS2BOX#propdef-padding

p.block-size:~CSSLOGICAL#propdef-block-size
p.inline-size:~CSSLOGICAL#propdef-inline-size
p.margin-block-end:~CSSLOGICAL#propdef-margin-block-end
p.margin-block-start:~CSSLOGICAL#propdef-margin-block-start
p.margin-inline-end:~CSSLOGICAL#propdef-margin-inline-end
p.margin-inline-start:~CSSLOGICAL#propdef-margin-inline-start
p.padding-block-end:~CSSLOGICAL#propdef-padding-block-end
p.padding-block-start:~CSSLOGICAL#propdef-padding-block-start
p.padding-inline-end:~CSSLOGICAL#propdef-padding-inline-end
p.padding-inline-start:~CSSLOGICAL#propdef-padding-inline-start
p.inset-block-end:~CSSLOGICAL#propdef-inset-block-end
p.inset-block-start:~CSSLOGICAL#propdef-inset-block-start
p.inset-inline-end:~CSSLOGICAL#propdef-inset-inline-end
p.inset-inline-start:~CSSLOGICAL#propdef-inset-inline-start

p.bottom:~CSS2VISUREN#propdef-bottom
p.left:~CSS2VISUREN#propdef-left
p.right:~CSS2VISUREN#propdef-right
p.top:~CSS2VISUREN#propdef-top

p.display:~CSS2VISUREN#propdef-display
	p.display:~CSSDISP#propdef-display

p.border:~CSSBG#propdef-border
p.border-style:~CSSBG#propdef-border-style
p.border-color:~CSSBG#propdef-border-color
p.border-width:~CSSBG#propdef-border-width

p.font-size:~CSSFONT#propdef-font-size

p.background-color:~CSSBG#propdef-background-color
	p.background-color:~CSS2/colors.html#propdef-background-color

p.border-block-end-color:~CSSLOGICAL#propdef-border-block-end-color
p.border-block-start-color:~CSSLOGICAL#propdef-border-block-start-color
p.border-inline-end-color:~CSSLOGICAL#propdef-border-inline-end-color
p.border-inline-start-color:~CSSLOGICAL#propdef-border-inline-start-color

p.border-bottom-color:~CSSBG#propdef-border-bottom-color
p.border-left-color:~CSSBG#propdef-border-left-color
p.border-right-color:~CSSBG#propdef-border-right-color
p.border-top-color:~CSSBG#propdef-border-top-color
	p.border-<X>-color:~CSS2BOX#propdef-border-<X>-color

p.box-shadow:~CSSBG#propdef-box-shadow
p.caret-color:~CSSUI#propdef-caret-color
p.color:~CSSCOLOR#propdef-color
p.outline-color:~CSSUI#propdef-outline-color
	p.outline-color:~CSS2/ui.html#propdef-outline-color


	at.charset:~CSSSYN#at-ruledef-charset
at.import:~CASCADE#at-ruledef-import
at.media:~CSSCOND#at-ruledef-media
at.namespace:~CSSNS#at-ruledef-namespace
at.page:~CSSPAGE#at-ruledef-page
	at.fontface:~CSSFONT#at-ruledef-fontface

d.width:~MQ4#descdef-media-width
d.height:~MQ4#descdef-media-height
d.device-width:~MQ4#descdef-media-device-width
d.device-height:~MQ4#descdef-media-device-height
d.orientation:~MQ4#descdef-media-orientation
d.aspect-ratio:~MQ4#descdef-media-aspect-ratio
d.device-aspect-ratio:~MQ4#descdef-media-device-aspect-ratio
d.color:~MQ4#descdef-media-color
d.color-index:~MQ4#descdef-media-color-index
d.monochrome:~MQ4#descdef-media-monochrome
d.resolution:~MQ4#descdef-media-resolution
d.scan:~MQ4#descdef-media-scan
d.grid:~MQ4#descdef-media-grid

d.font-family:~CSSFONT#descdef-font-face-font-family

	~CSSFONT4#descdef-font-face-*
d.src:~CSSFONT#descdef-font-face-src
d.unicode-range:~CSSFONT#descdef-font-face-unicode-range
d.font-variant:~CSSFONT#descdef-font-face-font-variant
d.font-feature-settings:~CSSFONT#descdef-font-face-font-feature-settings
d.font-stretch:~CSSFONT#descdef-font-face-font-stretch
d.font-weight:~CSSFONT#descdef-font-face-font-weight
d.font-style:~CSSFONT#descdef-font-face-font-style

pe.before:~CSSPSEUDO#selectordef-before
pe.after:~CSSPSEUDO#selectordef-after
	~CSSWG/selectors-3/#sel-before
	~CSSWG/selectors-3/#sel-after

ps.lang():~SELECTORS#lang-pseudo
ps.nth-child():~SELECTORS#nth-child-pseudo
ps.nth-last-child():~SELECTORS#nth-last-child-pseudo
ps.nth-of-type():~SELECTORS#nth-of-type-pseudo
ps.nth-last-of-type():~SELECTORS#nth-last-of-type-pseudo
ps.not():~SELECTORS#not-pseudo


	●
h.Default-Style:#http-default-style
	<code>Default-Style</code>
h.Link:https://tools.ietf.org/html/rfc5988#section-5

r.DOM:#biblio-whatwg-dom
r.ENCODING:#biblio-whatwg-encoding
r.URL:#biblio-whatwg-url

~give-up:#_give-up
~ACI:#ascii-case-insensitive

~CSS~ssを作成する:#create-a-css-style-sheet
~CSS~ssを追加する:#add-a-css-style-sheet
~CSS~ssを除去する:#remove-a-css-style-sheet

結付けられている~CSS~ss:#associated-css-style-sheet
媒体~照会~collection:#medialist-collection-of-media-queries
	compare-media-queries:比較
媒体~照会を比較する:#compare-media-queries
~MediaList~objを作成する:#create-a-medialist-object
文書~ss~list:#document-css-style-sheets

解決値:#resolved-value
解決値は特別:#resolved-value-special-case-property
~CSS規則:#css-rule
~index番の規則として挿入する:#insert-a-css-rule
~index番の規則を除去する:#remove-a-css-rule

~supportされる~CSS~prop:#supported-css-property
~CSS~prop名に変換する:#idl-attribute-to-css-property
~IDL属性~名に変換する:#css-property-to-idl-attribute

指定順:#concept-declarations-specified-order
選好順:#concept-shorthands-preferred-order

~CSS~ss:#css-style-sheet
持続的~CSS~ss:#persistent-css-style-sheet
~CSS宣言を設定する:#set-a-css-declaration
~CSS宣言の優先度を設定する:#set-a-css-declaration-priority
~CSS宣言の値を設定する:#set-a-css-declaration-value

	//css-declaration-
~CSS宣言:#css-declaration
~CSS宣言~block:#css-declaration-block
~prop名:#css-declaration-property-name
値:#css-declaration-value
~important~flag:#css-declaration-important-flag
大小区別~flag:#css-declaration-case-sensitive-flag

	//cssstyledeclaration-
読専~flag:#cssstyledeclaration-readonly-flag
宣言列:#cssstyledeclaration-declarations
親~CSS規則:#cssstyledeclaration-parent-css-rule
所有者~node:#cssstyledeclaration-owner-node

	//concept-css-style-sheet_
ss.種別:#concept-css-style-sheet-type
ss.所在:#concept-css-style-sheet-location
ss.親~CSS~ss:#concept-css-style-sheet-parent-css-style-sheet
ss.所有者~node:#concept-css-style-sheet-owner-node
ss.所有者~CSS規則:#concept-css-style-sheet-owner-css-rule
ss.媒体:#concept-css-style-sheet-media
ss.~title:#concept-css-style-sheet-title
ss.代替-~flag:#concept-css-style-sheet-alternate-flag
ss.不能化~flag:#concept-css-style-sheet-disabled-flag
ss.~CSS規則列:#concept-css-style-sheet-css-rules
ss.origin-clean ~flag:#concept-css-style-sheet-origin-clean-flag
	//escape-a-
文字を符号位置として~escapeする:#escape-a-character-as-code-point
文字を~escapeする:#escape-a-character

	//parse-a-
~CSS宣言~blockとして構文解析する:#parse-a-css-declaration-block
~CSS頁~選択子~listとして構文解析する:#parse-a-list-of-css-page-selectors
~CSS規則として構文解析する:#parse-a-css-rule
~CSS値として構文解析する:#parse-a-css-value
選択子~listとして構文解析する:#parse-a-group-of-selectors
媒体~照会~listとして構文解析する:#parse-a-media-query-list
媒体~照会として構文解析する:#parse-a-media-query

	// concept-css-rule_
親~規則:#concept-css-rule-parent-css-rule
親~ss:#concept-css-rule-parent-css-style-sheet
~text:#concept-css-rule-text
種別:#concept-css-rule-type
子~規則列:#concept-css-rule-child-css-rules

	// serialize-a-
~comma区切りで直列化する:#serialize-a-comma-separated-list
空白~区切りで直列化する:#serialize-a-whitespace-separated-list
識別子を直列化する:#serialize-an-identifier
宣言列を直列化する:#serialize-a-css-declaration-block
~CSS宣言を直列化する:#serialize-a-css-declaration

page.構文解析-:#parse-a-list-of-css-page-selectors
page.直列化-:#serialize-a-list-of-css-page-selectors

~CSS規則を直列化する:#serialize-a-css-rule
~CSS成分値を直列化する:#serialize-a-css-component-value
~CSS値を直列化する:#serialize-a-css-value
下位prop~listを直列化する:#serialize-a-css-longhands
選択子~listを直列化する:#serialize-a-group-of-selectors
媒体~特能~値を直列化する:#serialize-a-media-feature-value
媒体~照会~listを直列化する:#serialize-a-media-query-list
媒体~照会を直列化する:#serialize-a-media-query
選択子を直列化する:#serialize-a-selector
単体~選択子を直列化する:#serialize-a-simple-selector
文字列を直列化する:#serialize-a-string
~CSS~URLに直列化する:#serialize-a-url
~LOCALに直列化する:#serialize-a-local

	// *-css-style-sheet-set-
~CSS~ss集合:#css-style-sheet-set
~CSS~ss集合~名:#css-style-sheet-set-name
可能化~CSS~ss集合:#enabled-css-style-sheet-set
~CSS~ss集合を可能化する:#enable-a-css-style-sheet-set
~CSS~ss集合を選択する:#select-a-css-style-sheet-set
ss.選択した:#select-a-css-style-sheet-set
最後の~CSS~ss集合~名:#last-css-style-sheet-set-name
選好される~CSS~ss集合~名:#preferred-css-style-sheet-set-name
選好される~CSS~ss集合~名を変更する:#change-the-preferred-css-style-sheet-set-name

~CSS~ss資源を~fetchする:#fetch-a-css-style-sheet
	unset:#unset
	set:#set


	// external terms

空白:#whitespace
無視される:#ignored
算出値:#computed-value
使用値:#used-value
~cascaded値:#cascaded-value

初期値:#initial-value
指定値:#specified-value
略式~prop:#shorthand
下位prop:#longhand
正準的~順序:#canonical-order


名前空間~接頭辞:#namespace-prefix
既定の名前空間:#default-namespace
~null名前空間:#null-namespace

~CSS頁~選択子~list:#list-of-css-page-selectors
頁~選択子:#page-selector
~margin at-規則:#margin-at-rules

~supportされる~styling言語:#supported-styling-language

全称~選択子:#universal-selector
単体~選択子:#simple-selector
	selectors3
group of selectors:#group-of-selectors
	selectors4
選択子~list:#selectors-list
選択子:#selector
複体~選択子:#complex-selector
合体~選択子:#compound-selector
属性~選択子:#attribute-selector

ID 選択子:#id-selector
型~選択子:#type-selector
~class選択子:#class-selector
疑似類:#pseudo-class
疑似要素:#pseudo-element
結合子:#selector-combinator

~CSS~style規則:#css-style-rule

媒体~照会:#_media-query
媒体~特能:#_media-feature
	媒体~種別:#media-type
~prolog:#prolog

~CSS~pixel:~CSSVAL#px
有位置の要素:~CSS2VISUREN#positioned-element

	// 外部リンク
xml-stylesheet 処理命令:~XMLSS#dt-xml-stylesheet
	#dt-xml-stylesheet-processing-instruction
疑似属性:~XMLSS#dt-pseudo-attribute
xmlss.charset:~XMLSS#PA-charset
xmlss.href:~XMLSS#PA-href
xmlss.title:~XMLSS#PA-title
xmlss.alternate:~XMLSS#PA-alternate
xmlss.type:~XMLSS#PA-type
xmlss.media:~XMLSS#PA-media

文書~基底~URL:~HTMLurl#document-base-url
Content-Type ~metadata:~HTMLurl#content-type

生成元:~ORIGIN#concept-origin

~URL:~URL1#concept-url
	 URL 
絶対~URL文字列:~URL1#absolute-url-string
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer

~fetching:~FETCH#concept-fetch
~fetch:~FETCH#concept-fetch
~network~error:~FETCH#concept-network-error
要請:~FETCH#concept-request
rq.~url:~FETCH#concept-request-url
	 url 
rq.生成元:~FETCH#concept-request-origin
rq.~referrer:~FETCH#concept-request-referrer
	 ~referrer


符号単位:~INFRA#code-unit
~surrogate:~INFRA#surrogate
	符号位置:~INFRA#code-point
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化:~INFRA#ascii-lowercase
~ASCII大文字~化:~INFRA#ascii-uppercase
~ASCII 16 進~数字（小文字）:~INFRA#ascii-lower-hex-digit

~CORS同一生成元:~HTMLurl#cors-same-origin
文字大小区別:~HTMLINFRA#case-sensitive


	~DOM4#〜
~tree順序:~DOM4#concept-tree-order
過去互換~mode:~DOM4#concept-document-quirks
~node文書:~DOM4#concept-node-document
子:~DOM4#concept-tree-child
~address:~DOM4#concept-document-url
doc.~address:~HTMLdom#the-document%27s-address
~node:~DOM4#concept-node
~data:~DOM4#concept-cd-data
内容~属性:~DOM4#concept-attribute
	投出:~DOM4#concept-throw
後続:~DOM4#concept-tree-following
文書:~DOM4#concept-document
文書の文字~符号化方式:~DOM4#concept-document-encoding


環境~符号化方式:~CSSSYN#environment-encoding
~labelから符号化方式を取得する:~ENCODING#concept-encoding-get

被support~prop~index:~WEBIDL#dfn-supported-property-indices
識別子:~WEBIDL#dfn-identifier
	正則属性:#＊webidl.dfn-regular-attribute
凍結~配列:~WEBIDL#idl-frozen-array

現在の大域~obj:~WAPI#current-global-object
結付けられている文書:~WINDOW#concept-document-window
~event-loop:~WAPI#event-loop

~ss準備済み~flag:~HEmetadata#style-sheet-ready
~scriptを阻んでいる~ss:~HEmetadata#a-style-sheet-that-is-blocking-scripts

~custom~prop:~CSSVAR#custom-property
~custom~prop名:~CSSVAR#custom-property


●●spec_metadata



最新発行バージョン
	https://www.w3.org/TR/cssom-1/

編集者草案
	https://drafts.csswg.org/cssom/

以前のバージョン
	https://www.w3.org/TR/2016/WD-cssom-1-20160317/
	https://www.w3.org/TR/2015/WD-cssom-1-20150529/
	https://www.w3.org/TR/2013/WD-cssom-20131205/
	https://www.w3.org/TR/2011/WD-cssom-20110712/
	https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/

テスト一式
	http://test.csswg.org/suites/cssom-1_dev/nightly-unstable

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/cssom-1">GitHub Issues</a>

編集
	<a href="mailto:daniel.glazman@disruptive-innovations.com">Daniel Glazman</a> (<a href="http://disruptive-innovations.com/">Disruptive Innovations</a>)

前任編集者
	<a href="mailto:simonp@opera.com">Simon Pieters</a> (Opera Software AS)
	<a href="http://www.w3.org/wiki/User:Gadams">Glenn Adams</a> (Cox Communications, Inc.) <a href="mailto:glenn.adams@cos.com">glenn.adams@cos.com</a>
	<a href="https://annevankesteren.nl/">Anne van Kesteren</a> (Opera Software ASA) <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>

旧来の課題リスト
	<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=CSS&amp;component=CSSOM&amp;resolution=---">Bugzilla</a>


●●ref_normative
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 5 July 2016. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-CONDITIONAL-3]
    CSS Conditional Rules Module Level 3 URL: https://www.w3.org/TR/css3-conditional/ 
[CSS-DISPLAY-3]
    Elika Etemad. CSS Display Module Level 3. 20 July 2017. WD. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-FONTS-4]
    John Daggett; Myles Maxfield. CSS Fonts Module Level 4. 11 July 2017. WD. URL: https://www.w3.org/TR/css-fonts-4/ 
[CSS-LOGICAL-1]
    Rossen Atanassov; Elika Etemad. CSS Logical Properties and Values Level 1. 18 May 2017. WD. URL: https://www.w3.org/TR/css-logical-1/ 
[CSS-NAMESPACES-3]
    Elika Etemad. CSS Namespaces Module Level 3. 20 March 2014. REC. URL: https://www.w3.org/TR/css-namespaces-3/ 
[CSS-POSITION-3]
    Rossen Atanassov; Arron Eicholz. CSS Positioned Layout Module Level 3. 17 May 2016. WD. URL: https://www.w3.org/TR/css-position-3/ 
[CSS-UI-3]
    Tantek Çelik; Florian Rivoal. CSS Basic User Interface Module Level 3 (CSS3 UI). 2 March 2017. CR. URL: https://www.w3.org/TR/css-ui-3/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 29 September 2016. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VARIABLES-1]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSS21]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2 
[CSS22]
    Bert Bos. Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification. 12 April 2016. WD. URL: https://www.w3.org/TR/CSS22/ 
[CSS3-BACKGROUND]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 9 September 2014. CR. URL: https://www.w3.org/TR/css3-background/ 
[CSS3-COLOR]
    Tantek Çelik; Chris Lilley; David Baron. CSS Color Module Level 3. 7 June 2011. REC. URL: https://www.w3.org/TR/css3-color 
[CSS3-CONDITIONAL]
    David Baron. CSS Conditional Rules Module Level 3. 4 April 2013. CR. URL: https://www.w3.org/TR/css3-conditional/ 
[CSS3-SELECTORS]
    Tantek Çelik; et al. Selectors Level 3. 29 September 2011. REC. URL: https://www.w3.org/TR/css3-selectors/ 
[CSS3CASCADE]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 3. 19 May 2016. CR. URL: https://www.w3.org/TR/css-cascade-3/ 
[CSS3PAGE]
    Melinda Grant; et al. CSS Paged Media Module Level 3. 14 March 2013. WD. URL: https://www.w3.org/TR/css3-page/ 
[CSS3SYN]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MEDIAQUERIES-4]
    Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4. 5 September 2017. CR. URL: https://www.w3.org/TR/mediaqueries-4/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECTORS4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 2 May 2013. WD. URL: https://www.w3.org/TR/selectors4/ 
[SVG2]
    Nikos Andronikos; et al. Scalable Vector Graphics (SVG) 2. 15 September 2016. CR. URL: https://www.w3.org/TR/SVG2/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml 
[XML-STYLESHEET]
    James Clark; Simon Pieters; Henry Thompson. Associating Style Sheets with XML documents 1.0 (Second Edition). 28 October 2010. REC. URL: https://www.w3.org/TR/xml-stylesheet


●●ref_informative
[CSS-FONTS-3]
    John Daggett. CSS Fonts Module Level 3. 3 October 2013. CR. URL: https://www.w3.org/TR/css-fonts-3/ 
[DOM-LEVEL-2-STYLE]
    Chris Wilson; Philippe Le Hégaret. Document Object Model (DOM) Level 2 Style Specification. 13 November 2000. REC. URL: https://www.w3.org/TR/DOM-Level-2-Style/ 
[SVG11]
    Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Object Model (CSSOM)</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<!-- ＊
	Window:window
	Element:element
MediaList:medialist
StyleSheet:stylesheet
CSS:css
CSSStyleSheet:cssstylesheet
StyleSheetList:stylesheetlist
Document:document
ProcessingInstruction:
Element:
LinkStyle:linkstyle
CSSRuleList:cssrulelist
CSSRule:cssrule
CSSStyleRule:cssstylerule
CSSCharsetRule:csscharsetrule
CSSImportRule:cssimportrule
CSSGroupingRule:cssgroupingrule
CSSPageRule:csspagerule
CSSMarginRule:cssmarginrule
CSSNamespaceRule:cssnamespacerule
CSSStyleDeclaration:cssstyledeclaration
ElementCSSInlineStyle:elementcssinlinestyle
GetStyleUtils:getstyleutils
PseudoElement:pseudoelement



CSS21/
	cascade.at-import:`import^at
	syndata.ignore
	cascade.used-value:使用値
	cascade.computed-value:算出値
	cascade.specified-value:指定値
	cascade.at-import:`import^at

namespace.namespace-prefix:名前空間接頭辞
namespace.default-namespace:既定の名前空間


selectors
http://www.w3.org/TR/css3-selectors/

selectors.pseudo_element:疑似要素
	CSS21/selector.html#pseudo-element
selectors.combinators:結合子
	CSS21/selector.html#universal-selector
selectors.universal-selector:全称~選択子
selectors.simple-selectors:単体~選択子
selectors.attribute-selectors:属性~選択子
	CSS21/selector.html#attribute-selectors
selectors.id-selectors:ID 選択子
	CSS21/selector.html#id-selectors
selectors.pseudo-class:疑似類
	CSS21/selector.html#pseudo-class-selectors
selectors.type-selectors:型選択子
	CSS21/selector.html#type-selectors
selectors.sequence:単体選択子シーケンス
selectors.selectors:選択子
	CSS21/selector.html
selectors.class-selector:類選択子
	selectors.grouping:選択子の~group化

selectors.negation:否定疑似クラス

-->


</head>

<body>

<header>


	<hgroup>
<h1>CSSOM — CSS オブジェクトモデル</h1>
<h2>CSS Object Model</h2>
	</hgroup>
</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
CSSOM は、 Media Queries, Selectors, および~CSS自身のための（汎用の構文解析／直列化の規則も含めた）~APIを定義する。
◎
CSSOM defines APIs (including generic parsing and serialization rules) for Media Queries, Selectors, and of course CSS itself.
</p>

~CSSisaLANG

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
この文書は <abbr title="Cascading Style Sheet">CSS</abbr> Object Model （以下， “<abbr title="CSS Object Model">CSSOM</abbr>” ）の中核をなす特色機能を規定する。
CSSOM に基づく他の仕様, および他の~CSS関連の仕様は、これらの特色機能に対する拡張を定義する。
◎
This document formally specifies the core features of the CSS Object Model (CSSOM). Other documents in the CSSOM family of specifications as well as other CSS related specifications define extensions to these core features.
</p>

<p>
CSSOM の中核をなす特色機能は、作者定義~scriptから~style関連の状態~情報への~accessおよび操作を可能にするための，基本的な能力を提供することを~~目的とする。
◎
The core features of the CSSOM are oriented towards providing basic capabilities to author-defined scripts to permit access to and manipulation of style related state information and processes.
</p>

<div>
<p>
以下で定義される特色機能は、 W3C DOM Working Group の手による先行の仕様, 主に
`DOM-LEVEL-2-STYLE$r
を基にしている。
この文書の目的は：
</p>

<ul><li>（試験し易さと相互運用性を向上させるため）より技術的な詳細を提供して，先行の仕事を向上させる。
</li><li>限られた~~範囲にしか実装されておらず，この文脈において最早~本質的とは見なされていない一部の特色機能を、非推奨に, もしくは除去する。
</li><li>広く実装されてきている, あるいはそうなるものと予期されている，ある種の拡張を新たに指定する。
</li></ul>

◎
The features defined below are fundamentally based on prior specifications of the W3C DOM Working Group, primarily [DOM-LEVEL-2-STYLE]. The purposes of the present document are (1) to improve on that prior work by providing more technical specificity (so as to improve testability and interoperability), (2) to deprecate or remove certain less-widely implemented features no longer considered to be essential in this context, and (3) to newly specify certain extensions that have been or expected to be widely implemented.
</div>
	</section>

	<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~ON, ~OFF, ~IN, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
加えて、次の記法も用いる：
</p>

<table>
<thead><tr><th style="min-width: 10em;">記法
<th>意味

</thead>

<tbody><tr><th>%s ~APPEND %a ~APPEND %b ~APPEND …
<td>
左辺の文字列 %s の末尾に後続の文字列 %a, %b, … を示された順に~~付加する演算を表す。
式として用いられた場合、結果の %s がその値になる。

<tr><th>~SP
<td>
<em>1 個の</em> space 文字 `0020^U0 を表す。

<tr><th>
`~ACI@
<td>
この表記が添えられた ~EQ／~NEQ／~IN／~NIN は、
`~ASCII大小無視$による比較に基づくことを意味する。

</tbody></table>

<p>
`Document$I ~objを指して，単に`文書$とも記すことにする。
</p>

<p>
整数~index %~index に対する “%~index 番” という表記は、
0 番から数えるとする。
</p>

	</section>

	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様は、次の文書から一部の用語を取り入れている：
`DOM$r
`HTML$r
`CSS3SYN$r
`ENCODING$r
`URL$r
`FETCH$r
`XML-STYLESHEET$r
`XML$r
◎
This specification employs certain terminology from the following documents: DOM, HTML, CSS Syntax, Encoding, URL, Fetch, Associating Style Sheets with XML documents and XML. [DOM] [HTML] [CSS3SYN] [ENCODING] [URL] [FETCH] [XML-STYLESHEET] [XML]
</p>

<p>
`A^I を~ifcとするとき， “`A^I ~ifcを実装する~obj” の略記として、語 “`A^I ~obj” が用いられる。
◎
When this specification talks about object A where A is actually an interface, it generally means an object implementing interface A.
</p>

<p>
<dfn>set</dfn><!-- id="set" --> ／ <dfn>unset</dfn><!-- id="unset" -->
は、~flagや変数の
`true^c ／ `false^c
値を表す。
これらの語は、一部の値を `true^c ／ `false^c に~~変更する際にも用いられる。
【他の仕様の和訳との一貫性をとるため、この訳では，この語は利用せず，<a href="#_conventions">前節</a>に述べた ~ON, ~OFF を用いる。】
◎
The terms set and unset to refer to the true and false values of binary flags or variables, respectively. These terms are also used as verbs in which case they refer to mutating some value to make it true or false, respectively.
</p>

<p>
`~supportされる~styling言語@
は~CSSを指す。
◎
The term supported styling language refers to CSS.
</p>

<p class="note">注記：
UA が他の~styling言語も~supportするようになった場合，この仕様も必要に応じて更新されることが予期されている。
◎
Note: If another styling language becomes supported in user agents, this specification is expected to be updated as necessary.
</p>

<p>
`~supportされる~CSS~prop@
は、~UAが実装する~CSS~propであって，~vendor接頭辞~付きの~propも含まれるが、`~custom~prop$は除外される。
この仕様における比較~目的においては、`~supportされる~CSS~prop$は小文字~化されてい~MUST。
◎
The term supported CSS property refers to a CSS property that the user agent implements, including any vendor-prefixed properties, but excluding custom properties. A supported CSS property must be in its lowercase form for the purpose of comparisons in this specification.
</p>

<p>
この仕様においては、どの要素に対しても［
`before$pe, `after$pe
］疑似要素は，存在するものと見なされる
— それらに対する~boxは生成されないとしても。
◎
In this specification the ::before and ::after pseudo-elements are assumed to exist for all elements even if no box is generated for them.
</p>

<p>
~IDL~ifc~member（~meth／属性）から別の~memberが呼ばれるときは、~UAは，~memberの内部~APIを呼出さ~MUST
— すなわち、作者は~custom ECMAScript ~propや関数で上書きして，~memberのふるまいを変更することはできない。
◎
When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can’t change the behavior by overriding attributes or methods with custom properties or functions in ECMAScript.
</p>

<p>
特に指定されない限り、文字列の比較は `文字大小区別$で行われる。
◎
Unless otherwise stated, string comparisons are done in a case-sensitive manner.
</p>


<p class="trans-note">【
他の仕様からの，この仕様で利用される語の一部を下の一覧に挙げる
】</p>

<table><thead><tr><th style="min-width:10em;">語
<th style="min-width:14em;">参照先／原語表記  — 備考
</thead>

<tbody><tr><th colspan="2">
以下は， `CSS21$r にて定義される：

<tr><th>`無視される@
<td><a href="~CSS22/syndata.html#ignore">ignore</a>

</tbody><tbody><tr><th colspan="2" scope="rowgroup">
以下は， `CSS3CASCADE$r にて定義される：

<tr><th>`~cascaded値@
<td><a href="~CASCADE#cascaded-value">cascaded value</a>

<tr><th>`算出値@
<td><a href="~CASCADE#computed-value">computed value</a>

<tr><th>`使用値@
<td><a href="~CASCADE#used-value">used value</a>


<!-- 
cascade.at-import:`import^at
 -->

<tr><th>`初期値@
<td><a href="~CASCADE#initial-value">initial value</a>


<tr><th>`指定値@
<td><a href="~CASCADE#specified-value">specified value</a>


<tr><th>`略式~prop@
<td><a href="~CASCADE#shorthand-property">shorthand</a>
—
関連する一連の`下位prop$をまとめて指定する~prop


<tr><th>`下位prop@
<td><a href="~CASCADE#longhand">longhand sub-properties</a>


<tr><th>`正準的~順序@
<td>“canonical order” 
—
所与の`略式~prop$を規定する仕様において，その~propの定義表の中の値~定義 欄に示されている`下位prop$を直列化する順序を意味する（定義表の中で別途，その順序を指定する欄が設けられることもある）。


<!-- 
規則集合
<a href="~CSS22/syndata.html#rule-sets">rule set</a>,
~CSS宣言~block
<a href="~CSS22/syndata.html#rule-sets">declaration block</a>,
~CSS宣言
<a href="~CSS22/syndata.html#declaration">declaration</a>,
呈示hint
<a href="~CASCADE#preshint" >presentational hints</a>,
-->

</tbody><tbody><tr><th colspan="2" scope="rowgroup">
以下は， `SELECTORS4$r にて定義される：

<tr><th>`選択子@
<td><a href="~SELECTORS#selector">selector</a>
—
以下に挙げられる “選択子~list” と “〜選択子” の総称。

<tr><th>`選択子~list@
<td><a href="~SELECTORS#selector-list">selector list</a>
—
原文には Selectors Level 3 までの呼称
`group of selectors@
（“選択子群”）が用いられているが、この訳では， Selectors Level 4 に基づく呼称に変更している。

<tr><th>`複体~選択子@
<td><a href="~SELECTORS#complex">complex selector</a>
— 
`結合子$で連結された`合体~選択子$の並び。
Selectors Level 4 にて（選択子の構造をより明確に述べるために）導入された語。
一部の~algoの定義を明確化するため，この訳ではこの語を利用する。

<tr><th>`合体~選択子@
<td><a href="~SELECTORS#compound">compound selector</a>

<tr><th>`単体~選択子@
<td><a href="~SELECTORS#simple">simple selector</a>

<tr><th>`全称~選択子@
<td><a href="~SELECTORS#universal-selector">universal selector</a>

<tr><th>`属性~選択子@
<td><a href="~SELECTORS#attribute-selector">attribute selector</a>

<tr><th>`ID 選択子@
<td><a href="~SELECTORS#id-selector">ID selector</a>

<tr><th>`型~選択子@
<td><a href="~SELECTORS#type-selector">type selector</a>

<tr><th>`~class選択子@
<td><a href="~SELECTORS#class-selector">class selector</a>



<tr><th>`疑似類@
<td><a href="~SELECTORS#pseudo-class">pseudo-class</a>


<tr><th>`疑似要素@
<td><a href="~SELECTORS#pseudo-element">pseudo-element</a>


<tr><th>`結合子@
<td><a href="~SELECTORS#selector-combinator">combinator</a>

</tbody><tbody><tr><th colspan="2" scope="rowgroup">
以下は， `CSS3NAMESPACE$r にて定義される：

<tr><th>`名前空間~接頭辞@
<td><a href="~CSSNS#namespace-prefix">namespace prefix</a>

<tr><th>`既定の名前空間@
<td><a href="~CSSNS#default-namespace">default namespace</a>


<tr><th>`~null名前空間@
<td><a href="~CSSNS#terminology">null namespace</a>
— どの名前空間にも属さないことを意味する。

</tbody><tbody><tr><th colspan="2" scope="rowgroup">
以下は， `CSS3PAGE$r にて定義される：

<tr><th>`頁~選択子@
<td><a href="~CSSPAGE#page-selectors">page selector</a>

<tr><th>`~margin at-規則@
<td><a href="~CSSPAGE#margin-at-rules">margin at-rules</a>
— page-margin box を作成する種々の at-規則の総称

<tr><th>`~CSS頁~選択子~list@
<td>`page-selector-list$t
— `頁~選択子$の，~comma区切りによる~list

</tbody><tbody><tr><th colspan="2" scope="rowgroup">
以下は， `MEDIAQUERIES-4$r にて定義される：

<tr><th>`媒体~照会@
<td><a href="~MQ4#media">media query</a>

<tr><th>`媒体~特能@
<td><a href="~MQ4#mq-features">media feature</a>

</tbody></table>



		<section id="common-serializing-idioms">
<h3 title="Common Serializing Idioms">2.1. 直列化-時の成句的な手続き</h3>

<p class="algo-head">
`文字を~escapeする@
ときは、所与の
( 文字 %c )
に対し，次を返す
⇒＃
❝\
~APPEND %c
◎
To escape a character means to create a string of "\" (U+005C), followed by the character.
</p>

<p class="algo-head">
`文字を符号位置として~escapeする@
ときは、所与の
( 文字 %c )
に対し，次を返す
⇒＃
❝\
~APPEND 基数 16 の下で， %c の Unicode 符号位置を最小個数の`~ASCII 16 進~数字（小文字）$で表現する文字~並び
~APPEND ~SP
◎
To escape a character as code point means to create a string of "\" (U+005C), followed by the Unicode code point as the smallest possible number of hexadecimal digits in the range 0-9 a-f (U+0030 to U+0039 and U+0061 to U+0066) to represent the code point in base 16, followed by a single SPACE (U+0020).
</p>

<p class="algo-head">
`識別子を直列化する@
ときは、所与の
( 文字列 %入力 )
に対し，次を走らせた結果を返す：
◎
To serialize an identifier means to create a string represented by the concatenation of, for each character of the identifier:
</p>

<p class="trans-note">【
これは
<a href="~CSSVAL#identifier">~CSS識別子</a>
を作成する。
】</p>

<ol>
	<li>
~IF［
%入力 ~EQ ❝-
］
⇒
~RET `文字を~escapeする$( ❝- )
◎
↓↓</li>
	<li>
%結果 ~LET 空~文字列
◎
↑</li>
	<li>
<p>
%入力 内の ~EACH ( 文字 %c ) に対し，先頭から順に
⇒
%結果
~APPEND ［
%c に応じて，次で与えられる文字列
］：
◎
↑</p>

		<dl class="switch">
			<dt>`0000^U0 NULL</dt>
			<dd>
`FFFD^U0 REPLACEMENT CHARACTER
◎
If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
</dd>

			<dt>`0001^U0 〜 `001F^U0</dt>
			<dt>`007F^U0</dt>
			<dd>
`文字を符号位置として~escapeする$( %c )
◎
If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F, then the character escaped as code point.
</dd>

			<dt>❝0 〜 ❝9</dt>
			<dd>
				<ol>
					<li>
~IF［
これは初回の反復である
］
⇒
`文字を符号位置として~escapeする$( %c )
</li>
					<li>
~ELIF［
これは 2 回目の反復である
］~AND［
%入力 の最初の文字 ~EQ ❝-
］
⇒
`文字を~escapeする$( %c )
</li>
					<li>
~ELSE
⇒
%c
</li>
			</ol>
◎
If the character is the first character and is in the range [0-9] (U+0030 to U+0039), then the character escaped as code point.
◎
If the character is the second character and is in the range [0-9] (U+0030 to U+0039) and the first character is a "-" (U+002D), then the character escaped as code point.
◎
↓
◎
↑↑
If the character is the first character and is a "-" (U+002D), and there is no second character, then the escaped character.
</dd>

			<dt>`0080^U0 以上</dt>
			<dt>❝-</dt>
			<dt>❝_</dt>
			<dt>❝A 〜 ❝Z</dt>
			<dt>❝a 〜 ❝z</dt>
			<dd>
%c
◎
If the character is not handled by one of the above rules and is greater than or equal to U+0080, is "-" (U+002D) or "_" (U+005F), or is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to U+005A), or \[a-z] (U+0061 to U+007A), then the character itself.
</dd>

			<dt>その他</dt>
			<dd>
`文字を~escapeする$( %c )
◎
Otherwise, the escaped character.
</dd>

		</dl>
	</li>
	<li>
~RET %結果
◎
↑</li>
</ol>


<p class="algo-head">
`文字列を直列化する@
ときは、所与の
( 文字列 %入力 )
に対し，次を走らせた結果を返す：
◎
To serialize a string means＼
</p>

<p class="trans-note">【
これは
<a href="~CSSVAL#string">~CSS文字列</a>
を作成する。
】</p>

<ol>
	<li>
%結果 ~LET ❝"
◎
to create a string represented by '"' (U+0022), followed by＼
</li>
	<li>
<p>
%入力 内の ~EACH ( 文字 %c ) に対し，先頭から順に
⇒
%結果
~APPEND ［
%c に応じて，次で与えられる文字列
］
⇒＃
`0000^U0 NULL ならば `FFFD^U0 REPLACEMENT CHARACTER ／
{ `0001^U0 〜 `001F^U0, `007F^U0 } ならば `文字を符号位置として~escapeする$( %c ) ／
{ ❝", ❝\ } ならば `文字を~escapeする$( %c ) ／
~ELSE_  %c
◎
the result of applying the rules below to each character of the given string, followed by '"' (U+0022):
◎
If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
◎
If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F, the character escaped as code point.
◎
If the character is '"' (U+0022) or "\" (U+005C), the escaped character.
◎
Otherwise, the character itself.
</li>
	<li>
%結果
~APPEND ❝"
◎
↑</li>
	<li>
~RET %結果
◎
↑</li>
</ol>


<p class="note">注記：
❝' は~escapeされない。
文字列は常に ❝" で括られた形で直列化されるので。
◎
Note: "'" (U+0027) is not escaped because strings are always serialized with '"' (U+0022).
</p>

<p class="algo-head">
`~CSS~URLに直列化する@
ときは、所与の
( 文字列 %url )
に対し，次を返す
⇒＃
`url(^l
~APPEND `文字列を直列化する$( %url )
~APPEND ❝)
◎
To serialize a URL means to create a string represented by "url(", followed by the serialization of the URL as a string, followed by ")".
</p>

<p class="algo-head">
`~LOCALに直列化する@
ときは、所与の
( 文字列 %url )
に対し，次を返す
⇒＃
`local(^l
~APPEND `文字列を直列化する$( %url )
~APPEND ❝)
◎
To serialize a LOCAL means to create a string represented by "local(", followed by the serialization of the URL as a string, followed by ")".
</p>

<p class="algo-head">
`~comma区切りで直列化する@
ときは、所与の
( 文字列~list %~list )
に対し
⇒
%~list 内の~EACH ( 文字列  ) を，
`, ^l （すなわち［
❝, ~APPEND ~SP
］）で区切って ~list順に連結した結果を返す（~listが空ならば空~文字列になる）。
◎
To serialize a comma-separated list concatenate all items of the list in list order while separating them by ", ", i.e., COMMA (U+002C) followed by a single SPACE (U+0020).
</p>

<p class="algo-head">
`空白~区切りで直列化する@
ときは、所与の
( 文字列~list %~list )
に対し
⇒
%~list 内の~EACH ( 文字列  ) を，
~SP で区切って ~list順に連結した結果を返す。
◎
To serialize a whitespace-separated list concatenate all items of the list in list order while separating them by " ", i.e., a single SPACE (U+0020).
</p>

<p class="note">注記：
上の規則により~listを直列化する際には、その先頭／末尾に余分な空白は挿入されない。
特に指定されない限り、空~listは，空~文字列に直列化される。
◎
Note: When serializing a list according to the above rules, extraneous whitespace is not inserted prior to the first item or subsequent to the last item. Unless otherwise specified, an empty list is serialized as the empty string.
</p>

		</section>
	</section>
	<section id="cssomstring-type">
<h2 title="CSSOMString">3. `CSSOMString^I</h2>

<p>
CSSOM ~ifcにおいては、ほとんどの文字列に
`CSSOMString@I
型が利用される。
各~実装は、それを
`USVString$I, `DOMString$I
のいずれかとして定義することを選ぶことになる：
◎
Most strings in CSSOM interfaces use the CSSOMString type. Each implementation chooses to define it as either USVString or DOMString:
</p>

<pre class="idl">
typedef `USVString$ `CSSOMString@;
</pre>

<p>
あるいは：
◎
Or, alternatively:
</p>

<pre class="idl">
typedef DOMString CSSOMString;
</pre>

<div class="note">

<p>
注記：
この相違が~web内容から観測され得るのは、`~surrogate$符号単位が孕まれるときに限られる。
`DOMString$I は それらを保全する一方で、
`USVString$I は それらを `FFFD^U0 REPLACEMENT CHARACTER に置換する。
◎
The difference is only observable from web content when surrogate code units are involved. DOMString would preserve them, whereas USVString would replace them with U+FFFD REPLACEMENT CHARACTER.
</p>

<p>
実装は、実質的に，この置換を行うか行わないか選べることになる。
◎
This choice effectively allows implementations to do this replacement, but does not require it.
</p>

<p>
`USVString$I を利用すれば、実装は，メモリ内で文字列を内部的に表現するときに~UTF-8を利用-可能になる。
特に`~surrogate$符号位置は，整形式の~UTF-8には許容されないので、実質的にこの置換が要求される。
◎
Using USVString enables an implementation to use UTF-8 internally to represent strings in memory. Since well-formed UTF-8 specifically disallows surrogate code points, it effectively requires this replacement.
</p>

<p>
他方、文字列を 16-bit `符号単位$として内部的に表現する実装は、この置換を行う~cost避けることを選好するかもしれない。
◎
On the other hand, implementations that internally represent strings as 16-bit code units might prefer to avoid the cost of doing this replacement.
</p>

</div>

	</section>
	<section id="media-queries">
<h2 title="Media Queries">4. 媒体~照会</h2>

<p>
`媒体~照会$は Media Queries 仕様にて定義される。
この節では、~APIや直列化の形も含めた，`媒体~照会$を取り巻く種々の概念を定義する。
◎
Media queries are defined by the Media Queries specification. This section defines various concepts around media queries, including their API and serialization form.
</p>

		<section id="parsing-media-queries">
<h3 title="Parsing Media Queries">4.1. 媒体~照会の構文解析法</h3>

<p class="algo-head">
`媒体~照会~listとして構文解析する@
~algoは，Media Queries 仕様にて定義される。
これは、所与の文字列に対し，一連の`媒体~照会$からなる~listを返す。
◎
To parse a media query list for a given string s into a media query list is defined in the Media Queries specification. Return the list of media queries that the algorithm defined there gives.
</p>

<p class="note">注記：
結果が “無視される”
【 “ignored” 】
`媒体~照会$は、 `not all^l に転換されることになる。
◎
Note: A media query that ends up being "ignored" will turn into "not all".
</p>

<p class="algo-head">
`媒体~照会として構文解析する@
ときは、所与の
( 文字列 %文字列 )
に対し，［
`媒体~照会~listとして構文解析する$( %文字列 )
］の結果に含まれる`媒体~照会$の個数が［
1 個だけならば その`媒体~照会$ ／
~ELSE_ ~NULL
］を返す。
◎
To parse a media query for a given string s means to follow the parse a media query list steps and return null if more than one media query is returned or a media query if a single media query is returned.
</p>

<p class="note">注記：
ここでも， “無視される” `媒体~照会$は、 `not all^l に転換されることになる。
◎
Note: Again, a media query that ends up being "ignored" will turn into "not all".
</p>
		</section>
		<section id="serializing-media-queries">
<h3 title="Serializing Media Queries">4.2. 媒体~照会の直列化-法</h3>

<p class="algo-head">
`媒体~照会~listを直列化する@
ときは、所与の
( 媒体~照会~list %~list )
に対し，次を走らす：
◎
To serialize a media query list run these steps:
</p>

<div class="p">
<ol>
	<li>
%結果~list ~LET %~list 内の各~itemに
`媒体~照会を直列化する$
を適用して得られる同順の~list
</li>
	<li>
~RET `~comma区切りで直列化する$( %結果~list )
</li>
</ol>

◎
If the media query list is empty return the empty string and terminate these steps.
◎
Serialize each media query in the list of media queries, in the same order as they appear in the list of media queries, and then serialize the list.
</div>

<p class="algo-head">
`媒体~照会を直列化する@
ときは、所与の
( `媒体~照会$ %媒体~照会 )
に対し，次を走らす：
◎
To serialize a media query let s be the empty string, run the steps below, and finally return s:
</p>

<ol>
	<li>
%文字列 ~LET 空~文字列
◎
↑</li>
	<li>
~IF［
%媒体~照会 は否定形である
］
⇒
%文字列
~APPEND `not^l
~APPEND ~SP
◎
If the media query is negated append "not", followed by a single SPACE (U+0020), to s.
</li>
	<li>
%型 ~LET 次の結果を`~ASCII小文字~化$した結果
⇒
`識別子を直列化する$( %媒体~照会 の媒体~型 )
◎
Let type be the serialization as an identifier of the media type of the media query, converted to ASCII lowercase.
</li>
	<li>
~IF［
%媒体~照会 に`媒体~特能$は含まれていない
］
⇒
~RET %文字列
~APPEND %型
◎
If the media query does not contain media features append type, to s, then return s and terminate this algorithm.
</li>
	<li>
~IF［
%型 ≠ `all^l
］~OR［
%媒体~照会 は否定形である
］
⇒
%文字列
~APPEND %型
~APPEND ~SP
~APPEND `and^l
~APPEND ~SP
◎
If type is not "all" or if the media query is negated append type, followed by a single SPACE (U+0020), followed by "and", followed by a single SPACE (U+0020), to s.
</li>
	<li>
<p>
%媒体~照会 内の~EACH ( `媒体~特能$ %特能 ) に対し，辞書式~順序で：
◎
Sort the media features in lexicographical order.
◎
Then, for each media feature:
</p>

		<ol>
			<li>
%文字列
~APPEND ❝(
~APPEND［
%特能 の名前を`~ASCII小文字~化$した結果
］
◎
Append a "(" (U+0028), followed by the media feature name, converted to ASCII lowercase, to s.
</li>
			<li>
~IF［
%特能 に値は与えられている
］
⇒
%文字列
~APPEND ❝:
~APPEND ~SP
~APPEND `媒体~特能~値を直列化する$( %特能 の値 )
◎
If a value is given append a ":" (U+003A), followed by a single SPACE (U+0020), followed by the serialized media feature value, to s.
</li>
			<li>
%文字列
~APPEND ❝)
◎
Append a ")" (U+0029) to s.
</li>
			<li>
~IF［
この反復は最後でない
］
⇒
%文字列
~APPEND ~SP
~APPEND `and^l
~APPEND ~SP
◎
If this is not the last media feature append a single SPACE (U+0020), followed by "and", followed by a single SPACE (U+0020), to s.
</li>
		</ol>
	</li>
	<li>
~RET %文字列
◎
</li>
</ol>

<div class="example">
<p>
例を示す（長い行は折り~~返されている）：
◎
Here are some examples of input (first column) and output (second column):
</p>

<table>
<thead><tr><th>入力◎ Input
<th>出力◎ Output
</thead>

<tbody><tr><td>`not screen and (min-WIDTH:5px) AND (max-width:40px)^css
<td>`not screen and (max-width: 40px) and (min-width: 5px)^css

<tr><td>`all and (color) and (color)^css
<td>`(color)^css

</tbody>
</table>

</div>

			<section id="serializing-media-feature-values">
<h4 title="Serializing Media Feature Values">4.2.1. 媒体~特能~値の直列化-法</h4>

<p class="issue">
これは~CSS値の直列化に対応付けることを通して定義されるべきであろう
— その上で，`媒体~特能$については~CSS値を通して定義されるように。
◎
This should probably be done in terms of mapping it to serializing CSS values as media features are defined in terms of CSS values after all.
</p>

<p class="algo-head">
`媒体~特能~値を直列化する@
ときは、所与の
( 名前 %v の`媒体~特能$の値 )
に対し，下の一覧の最初の列から， %v に一致する行の 2 列目に記されている直列化~形式を用いる：
◎
To serialize a media feature value named v locate v in the first column of the table below and use the serialization format described in the second column:
</p>

<table><thead><tr><th>`媒体~特能$◎ Media Feature
<th>直列化◎ Serialization
</thead>

<tbody><tr><td>`width$d
<td>~UNSPECIFIED

<tr><td>`height$d
<td>~UNSPECIFIED

<tr><td>`device-width$d
<td>~UNSPECIFIED

<tr><td>`device-height$d
<td>~UNSPECIFIED

<tr><td>`orientation$d
<td>
値に応じて：［
`portrait^v ならば `portrait^l ／
`landscape^v ならば `landscape^l
］
◎
If the value is portrait: "portrait". If the value is landscape: "landscape".

<tr><td>`aspect-ratio$d
<td>~UNSPECIFIED

<tr><td>`device-aspect-ratio$d
<td>~UNSPECIFIED

<tr><td>`color$d
<td>~UNSPECIFIED

<tr><td>`color-index$d
<td>~UNSPECIFIED

<tr><td>`monochrome$d
<td>~UNSPECIFIED

<tr><td>`resolution$d
<td>~UNSPECIFIED

<tr><td>`scan$d
<td>
値に応じて：［
`progressive^v ならば `progressive^l ／
`interlace^v ならば `interlace^l
］
◎
If the value is progressive: "progressive". If the value is interlace: "interlace".

<tr><td>`grid$d
<td>~UNSPECIFIED

</tbody></table>

<p>
他の仕様はこの一覧を拡張でき，また~vendor接頭辞~付きの`媒体~特能$は~custom直列化~形式を持ち得る。
◎
Other specifications can extend this table and vendor-prefixed media features can have custom serialization formats as well.
</p>

			</section>
		</section>
		<section id="comparing-media-queries">
<h3 title="Comparing Media Queries">4.3. 媒体~照会の比較-法</h3>

<p>
`媒体~照会を比較する@
ときは、所与の 2 個の`媒体~照会$
( %m1, %m2 )
に対し，［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返す
⇒
`媒体~照会を直列化する$( %m1 ) ~EQ `媒体~照会を直列化する$( %m2 )
◎
To compare media queries m1 and m2 means to serialize them both and return true if they are a case-sensitive match and false if they are not.
</p>
		</section>
		<section id="the-medialist-interface">
<h3 title="The MediaList Interface">4.4. `MediaList^I ~ifc</h3>

<p>
`MediaList$I ~ifcを実装する~objには，
`媒体~照会~collection@
が結付けられる。
◎
An object that implements the MediaList interface has an associated collection of media queries.
</p>

<pre class="idl">
[`Exposed$=Window,
 `LegacyArrayClass$]
interface `MediaList@I {
  `stringifier@m attribute [`TreatNullAs$=EmptyString] `CSSOMString$ `mediaText$m;
  ~RA ~UL `length$m;
  getter `CSSOMString$? `item$m(~UL %index);
  void `appendMedium$m(`CSSOMString$ %medium);
  void `deleteMedium$m(`CSSOMString$ %medium);
};
</pre>

<p>
~objの`被support~prop~index$は、
0 以上［
~collectionで表現される`媒体~照会~collection$に含まれている媒体~照会の総数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of media queries in the collection of media queries represented by the collection. If there are no such media queries, then there are no supported property indices.
</p>

<p class="algo-head">
`~MediaList~objを作成する@
ときは、所与の
( 文字列 %~text )
に対し，次を走らす：
◎
To create a MediaList object with a string text, run the following steps:
</p>

<ol>
	<li>
%MediaList ~LET 新たな `MediaList$I ~obj
◎
Create a new MediaList object.
</li>
	<li>
%MediaList の `mediaText$m 属性 ~SET %~text
◎
Set its mediaText attribute to text.
</li>
	<li>
~RET %MediaList
◎
Return the newly created MediaList object.
</li>
</ol>


<dl class="idl-def">
	<dt>`mediaText@m</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
`媒体~照会~listを直列化する$( 此れの`媒体~照会~collection$ )
◎
The mediaText attribute, on getting, must return a serialization of the collection of media queries.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
Setting the mediaText attribute must run these steps:
</p>

		<ol>
			<li>
此れの`媒体~照会~collection$を空にする
◎
Empty the collection of media queries.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
~RET
◎
If the given value is the empty string terminate these steps.
</li>
			<li>
此れの`媒体~照会~collection$に，次の結果を成す すべての媒体~照会を付加する
⇒
`媒体~照会~listとして構文解析する$( 所与の値 )
◎
Append all the media queries as a result of parsing the given value to the collection of media queries.
</li>
		</ol>
	</dd>

	<dt>`item(index)@m</dt>
	<dd>
被呼出時には、［
%index が範囲~外ならば ~NULL ／
~ELSE_ 次の結果
］を返さ~MUST
⇒
`媒体~照会~listを直列化する$( 此れの`媒体~照会~collection$内の %index 番の`媒体~照会$ )
◎
The item(index) method must return a serialization of the media query in the collection of media queries given by index, or null, if index is greater than or equal to the number of media queries in the collection of media queries.
</dd>

	<dt>`length@m</dt>
	<dd>
取得子は、此れの`媒体~照会~collection$に含まれる`媒体~照会$の個数を返さ~MUST。
◎
The length attribute must return the number of media queries in the collection of media queries.
</dd>

	<dt>`appendMedium(medium)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The appendMedium(medium) method must run these steps:
</p>

		<ol>
			<li>
%m ~LET `媒体~照会として構文解析する$( %medium )
◎
Let m be the result of parsing the given value.
</li>
			<li>
~IF［
%m ~EQ ~NULL
］
⇒
~RET
◎
If m is null terminate these steps.
</li>
			<li>
此れの`媒体~照会~collection$内の ~EACH( %n ) に対し
⇒
~IF［
`媒体~照会を比較する$( %m, %n ) ~EQ ~T
］
⇒
~RET
◎
If comparing m with any of the media queries in the collection of media queries returns true terminate these steps.
</li>
			<li>
此れの`媒体~照会~collection$に %m を付加する
◎
Append m to the collection of media queries.
</li>
		</ol>
	</dd>

	<dt>`deleteMedium(medium)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The deleteMedium(medium) method must run these steps:
</p>

		<ol>
			<li>
%m ~LET `媒体~照会として構文解析する$( %medium )
◎
Let m be the result of parsing the given value.
</li>
			<li>
~IF［
%m ~EQ ~NULL
］
⇒
~RET
◎
If m is null terminate these steps.
</li>
			<li>
此れの`媒体~照会~collection$内の ~EACH( %n ) に対し
⇒
~IF［
`媒体~照会を比較する$( %m, %n ) ~EQ ~T
］
⇒＃
%n を此れの`媒体~照会~collection$から除去する
◎
Remove any media query from the collection of media queries for which comparing the media query with m returns true.＼
</li>
			<li>
~IF［
前~段で除去されたものはない
］
⇒
~THROW `NotFoundError$E
◎
If nothing was removed, then throw a NotFoundError exception.
</li>
		</ol>
	</dd>
</dl>


		</section>
	</section>
	<section id="selectors">
<h2 title="Selectors">5. 選択子</h2>

<p>
`選択子$は Selectors 仕様にて定義される。
この節では主にそれらを直列化する方法を定義する。
◎
Selectors are defined in the Selectors specification. This section mainly defines how to serialize them.
</p>

		<section id="parsing-selectors">
<h3 title="Parsing Selectors">5.1. 選択子の構文解析法</h3>

<p class="algo-head">
`選択子~listとして構文解析する@
ときは、所与の
( 文字列 %値 )
に対し
⇒
Selectors 仕様にて定義されている `selector-list$t を用いて
%値 を構文解析して，それが［
失敗しなかったならば 結果の`選択子~list$ ／
失敗した場合は ~NULL
］を返す。
◎
To parse a group of selectors means to parse the value using the selectors_group production defined in the Selectors specification and return either a group of selectors if parsing did not fail or null if parsing did fail.
</p>
		</section>
		<section id="serializing-selectors">
<h3 title="Serializing Selectors">5.2. 選択子の直列化-法</h3>

<p class="algo-head">
`選択子~listを直列化する@
ときは、所与の
( `選択子~list$ %~list )
に対し，次の結果を返す
⇒
`~comma区切りで直列化する$( %~list 内の各~itemに `選択子を直列化する$を適用して得られる同順の~list )
◎
To serialize a group of selectors serialize each selector in the group of selectors and then serialize a comma-separated list of these serializations.
</p>

<p class="algo-head">
`選択子を直列化する@
ときは、所与の
( `複体~選択子$ %複体~選択子 )
に対し，次を走らせた結果の文字列を返す：
◎
To serialize a selector＼
</p>

<ol>
	<li>
%結果 ~LET 空~文字列
◎
let s be the empty string,＼
</li>
	<li>
<p>
%複体~選択子 内の~EACH ( `合体~選択子$ %合体~選択子 ) に対し，順に：
◎
run the steps below for each part of the chain of the selector, and finally return s:
</p>

		<ol>
			<li>
~IF［
%合体~選択子 は 1 個の`全称~選択子$のみからなる
］
⇒
%結果
~APPEND `単体~選択子を直列化する$( %合体~選択子 )
◎
If there is only one simple selector in the compound selectors which is a universal selector, append the result of serializing the universal selector to s.
</li>
			<li>
~ELSE
⇒
%合体~選択子 内の~EACH ( `単体~選択子$ %単体~選択子 ) に対し
⇒
~IF［
%単体~選択子 は`全称~選択子$でない
］~OR［
%単体~選択子 の`名前空間~接頭辞$は`既定の名前空間$でない名前空間に対応する
］
⇒
%結果
~APPEND `単体~選択子を直列化する$( %単体~選択子 )
◎
Otherwise, for each simple selector in the compound selectors that is not a universal selector of which the namespace prefix maps to a namespace that is not the default namespace serialize the simple selector and append the result to s.
</li>
			<li>
<p>
~IF［
%合体~選択子 は %複体~選択子 内の最後の`合体~選択子$でない
］：
</p>
				<ol>
					<li>
%結果
~APPEND ~SP
</li>
					<li>
%結合子 ~LET %合体~選択子 と次の`合体~選択子$の合間にある`結合子$
</li>
					<li>
~IF［
%結合子 は ~SP のみでない
］
⇒
%結果
~APPEND %結合子
~APPEND ~SP
</li>
				</ol>

◎
If this is not the last part of the chain of the selector append a single SPACE (U+0020), followed by the combinator "&gt;", "+", "~", "&gt;&gt;", "||", as appropriate, followed by another single SPACE (U+0020) if the combinator was not whitespace, to s.
</li>
			<li>
~ELIF［
%合体~選択子 内に`疑似要素$がある
］
⇒
%結果
~APPEND `::^l
~APPEND その疑似要素の名前
◎
If this is the last part of the chain of the selector and there is a pseudo-element, append "::" followed by the name of the pseudo-element, to s.
</li>
		</ol>
	</li>
	<li>
~RET %結果
</li>
</ol>

<p class="algo-head">
`単体~選択子を直列化する@
ときは、所与の
( `単体~選択子$ %選択子 )
に対し，
%選択子 の種別に応じて，次を走らせた結果の文字列を返す：
◎
To serialize a simple selector let s be the empty string, run the steps below, and finally return s:
</p>

<dl class="switch">
	<dt>`型~選択子$</dt>
	<dt>`全称~選択子$</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET 空~文字列
◎
↑</li>
			<li>
%接頭辞 ~LET %選択子 の`名前空間~接頭辞$
◎
↓</li>
			<li>
~IF［
%接頭辞 は［
`~null名前空間$でも
`既定の名前空間$でもない名前空間
］に対応する
］
⇒
%結果
~APPEND `識別子を直列化する$( %接頭辞 )
~APPEND ❝|
◎
If the namespace prefix maps to a namespace that is not the default namespace and is not the null namespace (not in a namespace) append the serialization of the namespace prefix as an identifier, followed by a "|" (U+007C) to s.
</li>
			<li>
~IF［
%接頭辞 は`~null名前空間$に対応する
］
⇒
%結果
~APPEND ❝|
◎
If the namespace prefix maps to a namespace that is the null namespace (not in a namespace) append "|" (U+007C) to s.
</li>
			<li>
~IF［
%選択子 は`型~選択子$である
］
⇒
%結果
~APPEND `識別子を直列化する$( 要素~名 )
◎
If this is a type selector append the serialization of the element name as an identifier to s.
</li>
			<li>
~ELSE （ %選択子 は`全称~選択子$である）
⇒
%結果
~APPEND ❝*
◎
If this is a universal selector append "*" (U+002A) to s.
</li>
			<li>
~RET %結果
◎
↑</li>
		</ol>
	</dd>

	<dt>`属性~選択子$</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET ❝[
◎
Append "[" (U+005B) to s.
</li>
			<li>
%接頭辞 ~LET %選択子 の`名前空間~接頭辞$
◎
↓</li>
			<li>
~IF［
%接頭辞 は`~null名前空間$でない名前空間に対応する
］
⇒
%結果
~APPEND `識別子を直列化する$( %接頭辞 )
~APPEND ❝|
◎
If the namespace prefix maps to a namespace that is not the null namespace (not in a namespace) append the serialization of the namespace prefix as an identifier, followed by a "|" (U+007C) to s.
</li>
			<li>
%結果
~APPEND `識別子を直列化する$( %選択子 の属性~名 )
◎
Append the serialization of the attribute name as an identifier to s.
</li>
			<li>
<p>
~IF［
%選択子 に属性~値が指定されている
］：
</p>

				<ol>
					<li>
%区切子 ~LET `属性~選択子$の種別に応じて，次のいずれか適切なもの
⇒＃
❝=,
`~=^l,
`|=^l,
"<code class="literal">^=</code>",
"<code class="literal">$=</code>",
`*=^l
</li>
					<li>
%結果
~APPEND %区切子
~APPEND `文字列を直列化する$( %選択子 の属性~値 )
</li>
			</ol>
◎
If there is an attribute value specified, append "=", "~=", "|=", "^=", "$=", or "*=" as appropriate (depending on the type of attribute selector), followed by the serialization of the attribute value as a string, to s.
</li>
			<li>
<p>
~IF［
属性~選択子 has the case-sensitivity flag present†
］
⇒
%結果
~APPEND ~SP
~APPEND ❝i
◎
If the attribute selector has the case-sensitivity flag present, append " i" (U+0020 U+0069) to s.
</p>

<p class="trans-note">【†
属性~値の
<a href="~SELECTORS#attribute-case">文字大小は区別されない</a>
なら真
— “case-sensitivity” と意味が正反対であるが。
】</p>

</li>

			<li>
%結果
~APPEND ❝]
◎
Append "]" (U+005D) to s.
</li>
			<li>
~RET %結果
◎
↑</li>
		</ol>
	</dd>

	<dt>`~class選択子$</dt>
	<dd>
~RET
❝.
~APPEND `識別子を直列化する$( %選択子 の class 名 )
◎
Append a "." (U+002E), followed by the serialization of the class name as an identifier to s.
</dd>

	<dt>`ID 選択子$</dt>
	<dd>
~RET
❝#
~APPEND `識別子を直列化する$( %選択子 の ID )
◎
Append a "#" (U+0023), followed by the serialization of the ID as an identifier to s.
</dd>

	<dt>`疑似類$</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET ❝:
~APPEND その`疑似類$の名前
◎
↓</li>
			<li>
~IF［
%選択子 は引数をとる`疑似類$でない
］
⇒
~RET %結果
◎
If the pseudo-class does not accept arguments append ":" (U+003A), followed by the name of the pseudo-class, to s.
</li>
			<li>
<p>
~RET %結果
~APPEND ❝(
~APPEND［
%選択子 の`疑似類$に応じて，次で与えられる文字列
］
~APPEND ❝)
：
◎
Otherwise, append ":" (U+003A), followed by the name of the pseudo-class, followed by "(" (U+0028), followed by the value of the pseudo-class argument(s) determined as per below, followed by ")" (U+0029), to s.
</p>
				<dl class="switch">
					<dt>`lang()$ps</dt>
					<dd>
`~comma区切りで直列化する$( 各 引数~値に`文字列を直列化する$ を適用して得られる同順の~list )
◎
The serialization of a comma-separated list of each argument’s serialization as a string, preserving relative order.
</dd>

					<dt>`nth-child()$ps</dt>
					<dt>`nth-last-child()$ps</dt>
					<dt>`nth-of-type()$ps</dt>
					<dt>`nth-last-of-type()$ps</dt>
					<dd>
<a href="~CSSSYN#serializing-anb">&lt;an+b&gt; の直列化-法</a>
`CSS3SYN$r
に従って，引数~値を直列化した結果
◎
The result of serializing the value using the rules to serialize an &lt;an+b&gt; value.
</dd>

					<dt>`not()$ps</dt>
					<dd>
`選択子~listを直列化する$( 引数~値 )
◎
The result of serializing the value using the rules for serializing a group of selectors.
</dd>
				</dl>
			</li>
		</ol>
	</dd>
</dl>

		</section>
	</section>
	<section id="css-object-model">
<h2 title="CSS">6. ~CSS</h2>

		<section id="css-style-sheets">
<h3 title="CSS Style Sheets">6.1. ~CSS~ss</h3>

<p>
`~CSS~ss@
とは、~CSS仕様にて定義される~ssを表現する抽象的な概念である。
CSSOM においては、`~CSS~ss$は `CSSStyleSheet$I ~objにより表現される。
各`~CSS~ss$ %~ss には、以下に挙げる状態~itemが結付けられる：
◎
A CSS style sheet is an abstract concept that represents a style sheet as defined by the CSS specification. In the CSSOM a CSS style sheet is represented as a CSSStyleSheet object. A CSS style sheet has a number of associated state items:
</p>

<dl>
	<dt>`種別@ss◎ type</dt>
	<dd>
`text/css^l
◎
The literal string "text/css".
</dd>

	<dt>`所在@ss◎ location</dt>
	<dd>
作成-時に指定される。
［
%~ss が埋込みの`~CSS~ss$である場合は ~NULL ／
~ELSE_ %~ss に対する最初の
【リダイレクト前の】
要請の`絶対~URL文字列$
］。
%~ss が存続する限り，変化しない。
◎
Specified when created. The absolute-URL string of the first request of the CSS style sheet or null if the CSS style sheet was embedded. Does not change during the lifetime of the CSS style sheet.
</dd>

	<dt>`親~CSS~ss@ss◎ parent CSS style sheet</dt>
	<dd>
作成-時に指定される。
%~ss の親の`~CSS~ss$が［
あれば それ ／
なければ ~NULL
］
◎
Specified when created. The CSS style sheet that is the parent of the CSS style sheet or null if there is no associated parent.
</dd>

	<dt>`所有者~node@ss◎ owner node</dt>
	<dd>
作成-時に指定される。
%~ss に結付けられている~DOM~nodeが［
あれば それ ／
なければ ~NULL
］。
<!-- 
HTML の場合は style 要素／link rel="stylesheet"／xml-style-sheet …
 -->
◎
Specified when created. The DOM node associated with the CSS style sheet or null if there is no associated DOM node.
</dd>

	<dt>`所有者~CSS規則@ss◎ owner CSS rule</dt>
	<dd>
作成-時に指定される。
`親~CSS~ss$ssの中で， %~ss のinclusion
【 `import$at ？ 】
を生じさせた`~CSS規則$が［
あればそれ ／
なければ ~NULL
］
◎
Specified when created. The CSS rule in the parent CSS style sheet that caused the inclusion of the CSS style sheet or null if there is no associated rule.
</dd>

	<dt>`媒体@ss◎ media</dt>
	<dd>
作成-時に指定される， `MediaList$I ~obj
◎
Specified when created. The MediaList object associated with the CSS style sheet.
</dd>
	<dd>
<p>
この~propに文字列が指定された場合、`媒体$ssは，次の結果に設定され~MUST
⇒
`~MediaList~objを作成する$( その文字列 )
◎
If this property is specified to a string, the media must be set to the return value of invoking create a MediaList object steps for that string.
</dd>
	<dd>
<!-- `MediaList!I -->
<p>
この~propに`所有者~node$ssのある属性 %属性 が指定された場合
【 すなわち、 %属性 を参照するように指定された場合】
：
◎
If this property is specified to an attribute of the owner node,＼
</p>
		<ul>
			<li>
`媒体$ssは，次の結果に設定され~MUST
⇒
`~MediaList~objを作成する$( %属性 の値 )
◎
the media must be set to the return value of invoking create a MediaList object steps for the value of that attribute.＼
</li>
			<li>
%属性 が［
設定-／変更-／除去-
］される度に、`媒体$ssの `mediaText$m 属性は［
%属性 が不在になったならば ~NULL ／
~ELSE_ %属性 の新たな値
］に設定され~MUST。
◎
Whenever the attribute is set, changed or removed, the media’s mediaText attribute must be set to the new value of the attribute, or to null if the attribute is absent.
</li>
		</ul>

<p class="note">注記：
`媒体$ssの `mediaText$m 属性の値が変化しても， %属性 は変化しない。
◎
Note: Changing the media’s mediaText attribute does not change the corresponding attribute on the owner node.
</p>
	</dd>

	<dt>`~title@ss◎ title</dt>
	<dd>
作成-時に指定される。
`~CSS~ss$の~title。
空~文字列もとり得る。
◎
Specified when created. The title of the CSS style sheet, which can be the empty string.
</dd>
	<dd class="example">
<p>
次の例では、最初の~ssの`~title$ssは空~文字列ではなく，2 個目と 3 個目の~ssについては、空~文字列になる。
◎
In the following, the title is non-empty for the first style sheet, but is empty for the second and third style sheets.
</p>

<pre class="lang-ml">
&lt;style title="papaya whip"&gt;
  body { background: #ffefd5; }
&lt;/style&gt;
</pre>

<pre class="lang-ml">
&lt;style title=""&gt;
  body { background: orange; }
&lt;/style&gt;
</pre>

<pre class="lang-ml">
&lt;style&gt;
  body { background: brown; }
&lt;/style&gt;
</pre>

	</dd>
	<dd>
この~propが`所有者~node$ssの属性に指定された場合、`~title$ssは，その属性~値に設定され~MUST。
属性が［
設定-／変更-／除去-
］されるときは 常に、`~title$ssは［
その属性が不在になったならば空~文字列 ／
~ELSE_ その属性の新たな値
］に設定され~MUST。
◎
If this property is specified to an attribute of the owner node, the title must be set to the value of that attribute. Whenever the attribute is set, changed or removed, the title must be set to the new value of the attribute, or to the empty string if the attribute is absent.
</dd>

	<dt>`代替-~flag@ss◎ alternate flag</dt>
	<dd>
作成-時に指定される。
~ON, ~OFF のいずれか。
既定は ~OFF 。
◎
Specified when created. Either set or unset. Unset by default.
</dd>
	<dd class="example">
<p>
次の`~CSS~ss$は，`代替-~flag$ssが ~ON にされる：
◎
The following CSS style sheets have their alternate flag set:
</p>

<pre class="lang-ml">
&lt;?xml-stylesheet alternate="yes" title="x" href="data:text/css,…"?&gt;
</pre>

<pre class="lang-ml">
&lt;link rel="alternate stylesheet" title="x" href="data:text/css,…"&gt;
</pre>

	</dd>

	<dt>`不能化~flag@ss◎ disabled flag</dt>
	<dd>
~ON, ~OFF のいずれか。
既定は ~OFF 。
◎
Either set or unset. Unset by default.
</dd>
	<dd class="note">注記：
~OFF であっても，必ずしも`~CSS~ss$が具現化に実際に利用されるとは限らない。
◎
Note: Even when unset it does not necessarily mean that the CSS style sheet is actually used for rendering.
</dd>


	<dt>`~CSS規則列@ss◎ CSS rules</dt>
	<dd>
`~CSS~ss$に結付けられている一連の`~CSS規則$からなる~list。
◎
The CSS rules associated with the CSS style sheet.
</dd>


	<dt>`origin-clean ~flag@ss</dt>
	<dd>
作成-時に指定される。
~ON, ~OFF のいずれか。
~ON の場合，~APIによる`~CSS規則列$ssに対する読取りと改変が許容される。
◎
Specified when created. Either set or unset. If it is set, the API allows reading and modifying of the CSS rules.
</dd>
</dl>

			<section id="the-stylesheet-interface">
<h4 title="The StyleSheet Interface">6.1.1. `StyleSheet^I ~ifc</h4>

<p>
`StyleSheet$I
~ifcは、抽象的な基底~ssを表現する。
◎
The StyleSheet interface represents an abstract, base style sheet.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `StyleSheet@I {
  ~RA `CSSOMString$ `type$m;
  ~RA `USVString$? `href$m;
  ~RA (`Element$I or `ProcessingInstruction$I)? `ownerNode$m;
  ~RA `StyleSheet$I? `parentStyleSheet$m;
  ~RA `DOMString$? `title$m;
  [`SameObject$, `PutForwards$=`mediaText$m] ~RA `MediaList$I `media$m;
  attribute boolean `disabled$m;
};
</pre>

<dl class="idl-def">
	<dt>`type@m</dt>
	<dd>
取得子は、此れの`種別$ssを返さ~MUST。
◎
The type attribute must return the type.
</dd>

	<dt>`href@m</dt>
	<dd>
取得子は、此れの`所在$ssを返さ~MUST。
◎
The href attribute must return the location.
</dd>

	<dt>`ownerNode@m</dt>
	<dd>
取得子は、此れの`所有者~node$ssを返さ~MUST。
◎
The ownerNode attribute must return the owner node.
</dd>

	<dt>`parentStyleSheet@m</dt>
	<dd>
取得子は、此れの`親~CSS~ss$ss
【 を表現する `StyleSheet$I （（を継承する~ifc）を実装する）~obj】
を返さ~MUST。
◎
The parentStyleSheet attribute must return the parent CSS style sheet.
</dd>

	<dt>`title@m</dt>
	<dd>
取得子は、［
此れの`~title$ss ~NEQ 空~文字列ならば それ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The title attribute must return the title or null if title is the empty string.
</dd>

	<dt>`media@m</dt>
	<dd>
取得子は、此れの`媒体$ssを返さ~MUST。
◎
The media attribute must return the media.
</dd>

	<dt>`disabled@m</dt>
	<dd>
取得子は、［
此れの`不能化~flag$ss ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The disabled attribute, on getting, must return true if the disabled flag is set, or false otherwise.＼
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
此れの`不能化~flag$ss ~SET［
新たな値 ~EQ ~T ならば ~ON ／
~ELSE_ ~OFF
］
◎
On setting, the disabled attribute must set the disabled flag if the new value is true, or unset the disabled flag otherwise.
</dd>

</dl>

			</section>
			<section id="the-cssstylesheet-interface">
<h4 title="The CSSStyleSheet Interface">6.1.2. `CSSStyleSheet^I ~ifc</h4>

<p>
`CSSStyleSheet$I ~ifcは `~CSS~ss$を表現する。
◎
The CSSStyleSheet interface represents a CSS style sheet.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSStyleSheet@I : `StyleSheet$I {
  ~RA `CSSRule$I? `ownerRule$m;
  [`SameObject$] ~RA `CSSRuleList$I `cssRules$m;
  ~UL `insertRule$m(`CSSOMString$ %rule, optional ~UL %index = 0);
  void `deleteRule$m(~UL %index);
};
</pre>

<dl class="idl-def">
	<dt>`ownerRule@m</dt>
	<dd>
取得子は、此れの`所有者~CSS規則$ss
【を表現する `CSSRule$I （（を継承する~ifc）を実装する）~obj】
を返さ~MUST。
~NULL 以外の値を返す場合は、どの取得-~accessに対しても，常に同じ値を返さ~MUST。
◎
The ownerRule attribute must return the owner CSS rule. If a value other than null is ever returned, then that same value must always be returned on each get access.
</dd>

	<dt>`cssRules@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The cssRules attribute must follow these steps:
</p>

		<ol>
			<li>
~IF［
此れの`origin-clean ~flag$ss ~EQ ~OFF
］
⇒
~THROW `SecurityError$E
◎
If the origin-clean flag is unset, throw a SecurityError exception.
</li>
			<li>
<p>
~RET
此れの`~CSS規則列$ssを表現する，読専かつ~liveである `CSSRuleList$I ~obj
◎
Return a read-only, live CSSRuleList object representing the CSS rules.
</p>

<p class="note">注記：
返される `CSSRuleList$I ~objは、（作者による~script側からは）読専であったとしても、~liveであり，内容が変化しないことを意味するわけではない。
例えば、 `insertRule()$m や `deleteRule()$m ~methの呼出しによる変更は、返された~objに反映される。
◎
Note: Even though the returned CSSRuleList object is read-only (from the perspective of client-authored script), it can nevertheless change over time due to its liveness status. For example, invoking the insertRule() or deleteRule() methods can result in mutations reflected in the returned object.
</p>
			</li>
		</ol>
	</dd>

	<dt>`insertRule(rule, index)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The insertRule(rule, index) method must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れの`origin-clean ~flag$ss ~EQ ~OFF
］
⇒
~THROW `SecurityError$E
◎
If the origin-clean flag is unset, throw a SecurityError exception.
</li>
			<li>
~RET
`~index番の規則として挿入する$( 此れ上の `cssRules$m から返される`~CSS規則列$ss, %rule, %index )
◎
Return the result of invoking insert a CSS rule rule in the CSS rules at index.
</li>
		</ol>
	</dd>

	<dt>`deleteRule(index)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The deleteRule(index) method must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れの`origin-clean ~flag$ss ~EQ ~OFF
］
⇒
~THROW `SecurityError$E
◎
If the origin-clean flag is unset, throw a SecurityError exception.
</li>
			<li>
`~index番の規則を除去する$( 此れの`~CSS規則列$ss, %index )
◎
Remove a CSS rule in the CSS rules at index.
</li>
		</ol>
	</dd>
</dl>

			</section>
		</section>
		<section id="style-sheet-collections">
<h3 title="CSS Style Sheet Collections">6.2. ~CSS~ss~collection</h3>

<p>
以下に、各 `文書$に結付けられる，種々の新たな概念が定義される
◎
Below various new concepts are defined that are associated with each Document object.
</p>

<p>
各 `文書$には、
`文書~ss~list@
と呼ばれる，ゼロ個以上の`~CSS~ss$からなる~listが結付けられる。
これは、［
`文書$に結付けられている`~CSS~ss$
］すべてを含む，`~tree順序$による~listである。
但し， HTTP `Link$h ~headerから作成される`~CSS~ss$は、それらの~headerに現れる順に，~listの先頭に置かれる。
◎
Each Document has an associated list of zero or more CSS style sheets, named the document CSS style sheets. This is an ordered list that contains all CSS style sheets associated with the Document, in tree order, with CSS style sheets created from HTTP Link headers first, if any, in header order.
</p>

<p class="algo-head">
`~CSS~ssを作成する@
ときは、次を走らす：
◎
To create a CSS style sheet, run these steps:
</p>

<ol>
	<li>
<p>
新たな`~CSS~ss$ ~objを作成し，その各種~propを指定された値に設定した上で、`文書~ss~list$に その`~CSS~ssを追加する$
◎
Create a new CSS style sheet object and set its properties as specified.
◎
Then run the add a CSS style sheet steps for the newly created CSS style sheet.
</p>

<p class="warning">
`origin-clean ~flag$ss ~EQ ~OFF の下では、これにより，利用者の~intranetからの情報が公開され得る。
◎
If the origin-clean flag is unset, this can expose information from the user’s intranet.
</p>
	</li>
</ol>

<p class="algo-head">
`~CSS~ssを追加する@
ときは、所与の
( ~CSS~ss %~ss )
に対し，次を走らす：
◎
To add a CSS style sheet, run these steps:
</p>

<ol>
	<li>
<p>
%~ss を，`文書~ss~list$内の適切な位置に追加する
</p>

<p>
（手続きの以下の部分は`不能化~flag$ssについての取り扱いになる）
</p>

◎
Add the CSS style sheet to the list of document CSS style sheets at the appropriate location. The remainder of these steps deal with the disabled flag.
</li>
	<li>
~IF［
%~ss の`不能化~flag$ss ~EQ ~ON
］
⇒
~RET
◎
If the disabled flag is set, terminate these steps.
</li>
	<li>
%~title ← %~ss の`~title$ss
◎
↓</li>
	<li>
~IF［
%~title ~NEQ 空~文字列
］~AND［
%~ss の`代替-~flag$ss ~EQ ~OFF
］~AND［
`選好される~CSS~ss集合~名$ ~EQ 空~文字列
］
⇒
`選好される~CSS~ss集合~名を変更する$( %~title )
◎
If the title is not the empty string, the alternate flag is unset, and preferred CSS style sheet set name is the empty string change the preferred CSS style sheet set name to the title.
</li>
	<li>
%~CSS~ss集合~名 ~LET［
`最後の~CSS~ss集合~名$ ~NEQ ~NULL ならば それ  ／
~ELSE_ `選好される~CSS~ss集合~名$ 
］
◎
↓</li>
	<li>
%~ss の`不能化~flag$ss ~SET ［
%~title ~IN { 空~文字列, %~CSS~ss集合~名 } ならば ~OFF ／
~ELSE_ ~ON
］
◎
If any of the following is true unset the disabled flag and terminate these steps:
◎
• The title is the empty string.
◎
• The last CSS style sheet set name is null and the title is a case-sensitive match for the preferred CSS style sheet set name.
◎
• The title is a case-sensitive match for the last CSS style sheet set name.
◎
Set the disabled flag.
</li>
</ol>


<p class="algo-head">
`~CSS~ssを除去する@
ときは、所与の
( `~CSS~ss$ %~ss )
に対し，次を走らす：
◎
To remove a CSS style sheet, run these steps:
</p>

<ol>
	<li>
`文書~ss~list$から %~ss を除去する
◎
Remove the CSS style sheet from the list of document CSS style sheets.
</li>
	<li>
%~ss の［
`親~CSS~ss$ss,
`所有者~node$ss,
`所有者~CSS規則$ss
］ ~SET ~NULL
◎
Set the CSS style sheet’s parent CSS style sheet, owner node and owner CSS rule to null.
</li>
</ol>

<p>
`持続的~CSS~ss@
とは、`文書~ss~list$に属する`~CSS~ss$のうち，［
その`~title$ss ~EQ 空~文字列
］~AND［
その`代替-~flag$ss ~EQ ~OFF
］なるものである。
◎
A persistent CSS style sheet is a CSS style sheet from the document CSS style sheets whose title is the empty string and whose alternate flag is unset.
</p>

<p>
`~CSS~ss集合@
とは、`文書~ss~list$に属する`~CSS~ss$のうち，［
空~文字列でない`~title$ss
］が互いに一致するものからなる，有順序~collectionである。
◎
A CSS style sheet set is an ordered collection of one or more CSS style sheets from the document CSS style sheets which have an identical title that is not the empty string.
</p>

<p>
`~CSS~ss集合$に属する各`~CSS~ss$に共通する`~title$ssは、
`~CSS~ss集合~名@
と呼ばれる。
◎
A CSS style sheet set name is the title the CSS style sheet set has in common.
</p>

<p>
`~CSS~ss集合$は、［
それに属するどの`~CSS~ss$の`不能化~flag$ssも ~OFF にされている
］ならば，
`可能化~CSS~ss集合@
という。
◎
An enabled CSS style sheet set is a CSS style sheet set of which each CSS style sheet has its disabled flag unset.
</p>

<p class="algo-head">
`~CSS~ss集合を可能化する@
ときは、所与の
( 文字列 %名前 )
に対し，次を走らす：
◎
To enable a CSS style sheet set with name name, run these steps:
</p>


<ol>
	<li>
`文書~ss~list$内の ~EACH ( `~CSS~ss$ %~ss ) に対し
⇒
~IF［
%~ss の`~title$ss ~NEQ 空~文字列
］
⇒
%~ss の`不能化~flag$ss ~SET［
%~ss の`~title$ss ~EQ %名前 ならば ~OFF ／
~ELSE_ ~ON
］
◎
If name is the empty string, set the disabled flag for each CSS style sheet that is in a CSS style sheet set and terminate these steps.
◎
Unset the disabled flag for each CSS style sheet in a CSS style sheet set whose CSS style sheet set name is a case-sensitive match for name and set it for all other CSS style sheets in a CSS style sheet set.
</li>
</ol>

<p class="algo-head">
`~CSS~ss集合を選択する@
ときは、所与の
( 文字列 %名前 )
に対し，次を走らす：
◎
To select a CSS style sheet set with name name, run these steps:
</p>

<ol>
	<li>
`~CSS~ss集合を可能化する$( %名前 )
◎
enable a CSS style sheet set with name name.
</li>
	<li>
`最後の~CSS~ss集合~名$ ~SET %名前
◎
Set last CSS style sheet set name to name.
</li>
</ol>

<p>
`最後の~CSS~ss集合~名@
とは、［
どの`~CSS~ss集合$を最後に`選択した$ssか
］を決定するための概念である。
その初期~時の値は ~NULL である。
◎
A last CSS style sheet set name is a concept to determine what CSS style sheet set was last selected. Initially its value is null.
</p>

<p>
`選好される~CSS~ss集合~名@
とは、［
どの`~CSS~ss$について，`不能化~flag$ssを ~OFF にする必要があるか
］を決定するための概念である。
その初期~時の値は空~文字列である。
◎
A preferred CSS style sheet set name is a concept to determine which CSS style sheets need to have their disabled flag unset. Initially its value is the empty string.
</p>

<p class="algo-head">
`選好される~CSS~ss集合~名を変更する@ 
ときは、所与の
( 名前 %名前 )
に対し，次を走らす：
◎
To change the preferred CSS style sheet set name with name name, run these steps:
</p>

<ol>
	<li>
%current ~LET
`選好される~CSS~ss集合~名$
◎
Let current be the preferred CSS style sheet set name.
</li>
	<li>
`選好される~CSS~ss集合~名$ ~SET %名前
◎
Set preferred CSS style sheet set name to name.
</li>
	<li>
~IF［
%名前 ~NEQ %current
］~AND［
`最後の~CSS~ss集合~名$ ~EQ ~NULL
］
⇒
`~CSS~ss集合を可能化する$( %名前 )
◎
If name is not a case-sensitive match for current and last CSS style sheet set name is null enable a CSS style sheet set with name name.
</li>
</ol>

			<section id="the-http-default-style-header">
<h4 title="The HTTP Default-Style Header">6.2.1. HTTP `Default-Style^h ~header</h4>

<p>
HTTP `Default-Style$h ~headerを利用すれば、`選好される~CSS~ss集合~名$を設定して，どの`~CSS~ss集合$が（初期~時に）`可能化~CSS~ss集合$にされるかに波及させられる。
◎
The HTTP Default-Style header can be used to set the preferred CSS style sheet set name influencing which CSS style sheet set is (initially) the enabled CSS style sheet set.
</p>

<p>
~UAは，次をし~MUST【いつ？】
⇒
~EACH ( HTTP `Default-Style$h ~header %~header ) に対し，~headerが現れる順に
⇒
`選好される~CSS~ss集合~名を変更する$( %~header の値 )
◎
For each HTTP Default-Style header, in header order, the user agent must change the preferred CSS style sheet set name with name being the value of the header.
</p>
			</section>
			<section id="the-stylesheetlist-sequence">

<h4 title="The StyleSheetList Interface">6.2.2. `StyleSheetList^I ~ifc</h4>

<p>
`StyleSheetList$I ~ifcは`~CSS~ss$の有順序~collectionを表現する。
◎
The StyleSheetList interface represents an ordered collection of CSS style sheets.
</p>

<pre class="idl">
[`Exposed$=Window,
 `LegacyArrayClass$]
interface `StyleSheetList@I {
  getter `StyleSheet$I? `item$m(~UL %index);
  ~RA ~UL `length$m;
};
</pre>

<p>
~objの`被support~prop~index$は、
0 以上［
~collectionで表現される~ssの総数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of CSS style sheets represented by the collection. If there are no such CSS style sheets, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>`item(index)@m</dt>
	<dd>
被呼出時には、此れの~collection内に %index 番の~ssが［
在れば それ ／
無ければ ~NULL
］を返さ~MUST。
◎
The item(index) method must return the indexth CSS style sheet in the collection. If there is no indexth object in the collection, then the method must return null.
</dd>

	<dt>`length@m</dt>
	<dd>
取得子は、此れの~collectionで表現される~ssの総数を返さ~MUST。
◎
The length attribute must return the number of CSS style sheets represented by the collection.
</dd>
</dl>

			</section>
			<section id="extensions-to-the-document-interface">
<h4 title="Extensions to the Document Interface">6.2.3. `Document^I ~ifcに対する拡張</h4>

<pre class="idl">
partial interface `Document!I {
  [`SameObject$] ~RA `StyleSheetList$I `styleSheets$m;
};
</pre>


<dl class="idl-def">
	<dt>`styleSheets@m</dt>
	<dd>
取得子は、此れの`文書~ss~list$を表現する
`StyleSheetList$I ~collectionを返さ~MUST。
◎
The styleSheets attribute must return a StyleSheetList collection representing the document CSS style sheets.
</dd>
</dl>


			</section>
		</section>
		<section id="style-sheet-association">
<h3 title="Style Sheet Association">6.3. ~ssの結付け</h3>

<p>
この節では、`~CSS~ss$の`所有者~node$ssが実装する必要がある~ifcを定義する。
`xml-stylesheet 処理命令$, および［
~link関係~型に `stylesheet^l を含むような HTTP `Link$h ~header
］に課される要件を定義する。
◎
This section defines the interface an owner node of a CSS style sheet has to implement and defines the requirements for xml-stylesheet processing instructions and HTTP Link headers when the link relation type is an ASCII case-insensitive match for "stylesheet".
</p>

			<section id="fetching-css-style-sheets">

<h4 title="Fetching CSS style sheets">6.3.1. ~CSS~ssの~fetching</h4>

<p>
`~CSS~ss資源を~fetchする@
ときは、所与の
( %解析済み~URL, %~referrer, %文書 ),
および
一連の~parameter %parameters （省略可，`要請$を作成する際の入力に利用される）
に対し，次を走らす：
◎
To fetch a CSS style sheet with parsed URL parsed URL, referrer referrer, document document, optionally a set of parameters parameters (used as input to creating a request), follow these steps:
</p>

<ol>
	<li>
%生成元 ~LET %文書 の`生成元$
◎
Let origin be document’s origin.
</li>
	<li>
%要請 ~LET 次のようにされた，新たな`要請$
⇒＃
`~url$rq ~SET %解析済み~URL,
`生成元$rq ~SET %生成元,
`~referrer$rq ~SET %~referrer
◎
Let request be a new request, with the url parsed URL, origin origin, referrer referrer, and＼
</li>
	<li>
~IF［
%parameters は与えられている
］
⇒
%parameters に従って， %要請 の他の~parameterを設定する
◎
if specified the set of parameters parameters.
</li>
	<li>
%応答 ~LET %要請 を用いて`~fetch$した結果
（ %応答 が得られるまで待機する）
◎
Let response be the result of fetching request.
◎
Wait until response is available.
</li>
	<li>
~IF［
%応答 ~EQ `~network~error$
］
⇒
~RET ~error
◎
If response is a network error, return an error.
</li>
	<li>
<p>
~IF［
%応答 の`Content-Type ~metadata$は `~supportされる~styling言語$でない
］：
</p>
			<ol>
				<li>
~IF［
%文書 は`過去互換~mode$下にある
］~AND［
%応答 は `~CORS同一生成元$である
］
⇒
%応答 の`Content-Type ~metadata$を `text/css^c に変更する
</li>
				<li>
~ELSE
⇒
~RET ~error
</li>
			</ol>

◎
If document is in quirks mode, response is CORS-same-origin and the Content-Type metadata of response is not a supported styling language change the Content-Type metadata of response to text/css.
◎
If response is not in a supported styling language return an error.
</li>
	<li>
~RET %応答
◎
Return response.
</li>
</ol>

			</section>
			<section id="the-linkstyle-interface">
<h4 title="The LinkStyle Interface">6.3.2. `LinkStyle^I ~ifc</h4>

<p>
~nodeに
`結付けられている~CSS~ss@
とは、`文書~ss~list$に属する`~CSS~ss$であって，
その`所有者~node$ssが `LinkStyle$I ~ifcを実装するものである。
【所有者~node と~nodeは同じでないこともあるのだろうか？】
◎
The associated CSS style sheet of a node is the CSS style sheet in the list of document CSS style sheets of which the owner node implements the LinkStyle interface.
</p>

<pre class="idl">
[`Exposed$=Window,
 `NoInterfaceObject$]
interface `LinkStyle@I {
  ~RA `StyleSheet$I? `sheet$m;
};
</pre>

<dl class="idl-def">
	<dt>`sheet@m</dt>
	<dd>
取得子は、~nodeに`結付けられている~CSS~ss$が［
あればそれ ／
なければ ~NULL
］を返さ~MUST。
◎
The sheet attribute must return the associated CSS style sheet for the node or null if there is no associated CSS style sheet.
</dd>
	<dd class="example">
<p>
次の例において、~UAが~CSS（ `text/css^c ）を~supportしつつ，（仮想の） `text/example-sheets^c は~supportしていないとする。
この場合、前者の `style^e 要素の `sheet$m 属性は，~ssを表現する `StyleSheet$I ~objを返すが、後者の `style^e 要素の `sheet$m 属性は，~NULL を返す。
◎
In the following fragment, the first style element has a sheet attribute that returns a StyleSheet object representing the style sheet, but for the second style element, the sheet attribute returns null, assuming the user agent supports CSS (text/css), but does not support the (hypothetical) ExampleSheets (text/example-sheets).
</p>

<pre class="lang-ml">
&lt;style type="text/css"&gt;
  body { background:lime }
&lt;/style&gt;
</pre>
<pre class="lang-ml">
&lt;style type="text/example-sheets"&gt;
  $(body).background := lime
&lt;/style&gt;
</pre>

	</dd>
</dl>


<p class="note">注記：
~nodeが~ssを~~参照するかどうかは、当該の~nodeの意味論を定義する仕様により定義される。
◎
Note: Whether or not the node refers to a style sheet is defined by the specification that defines the semantics of said node.
</p>
			</section>
			<section id="requirements-on-specifications">
<h4 title="Requirements on specifications">6.3.3. 仕様に課される要件</h4>

<p>
~DOMを通して~ssを結付ける新たな仕方を導入する仕様は、どの~nodeが `LinkStyle$I ~ifcを実装するかを定義するべきである。
その場合、どの時点で`~CSS~ssを作成する$かも定義され~MUST。
◎
Specifications introducing new ways of associating style sheets through the DOM should define which nodes implement the LinkStyle interface. When doing so, they must also define when a CSS style sheet is created.
</p>



			</section>
			<section id="requirements-on-user-agents-implementing-the-xml-stylesheet-processing-instruction">
<h4 title="Requirements on User Agents Implementing the xml-stylesheet processing instruction">6.3.4. xml-stylesheet 処理命令を実装する~UAに課される要件</h4>

<pre class="idl">
`ProcessingInstruction$I implements `LinkStyle$I;
</pre>


<p>
`~prolog@
とは、 `文書$の`子$であって，
`文書$のどの子`Element$I にも`後続$しないような`~node$（の集合）を意味する。
◎
The prolog refers to nodes that are children of the document and are not following the Element child of the document, if any.
</p>

<p>
`ProcessingInstruction$I `~node$ %node
が［
`~prolog$の一部を成すものに［
なった／ならなくなった
］とき，あるいは その
`~data$ が変化したとき
］には、次を走らせ~MUST：
◎
When a ProcessingInstruction node node becomes part of the prolog, is no longer part of the prolog, or has its data changed, these steps must be run:
</p>


<ol>

	<li>
~IF［
この~algoの~instanceが
%node に対し現在~走っている
］
⇒＃
その~instanceを中止する；
適用-可能なら，結付けられている`~fetching$も停止する
◎
If an instance of this algorithm is currently running for node, abort that instance, and stop the associated fetching if applicable.
</li>
	<li>
~IF［
%node に`結付けられている~CSS~ss$ %~ss がある
］
⇒
`~CSS~ssを除去する$( %~ss )
◎
If node has an associated CSS style sheet, remove it.
</li>
	<li>
~IF［
%node は `xml-stylesheet 処理命令$でない
］
⇒
~RET
◎
If node is not an xml-stylesheet processing instruction, terminate these steps.
</li>
	<li>
~IF［
%node に `href$xmlss `疑似属性$が指定されてない
］
⇒
~RET
◎
If node does not have an href pseudo-attribute, terminate these steps.
</li>
	<li>
%~title ~LET ［
%node に `title$xmlss `疑似属性$が指定されているならば その値 ／
~ELSE_空~文字列
］
◎
Let title be the value of the title pseudo-attribute or the empty string if the title pseudo-attribute is not specified.
</li>
	<li>
~IF［
%node に `alternate$xmlss `疑似属性$が指定されていて，その値 ~EQ `yes^l
］~AND［
%~title ~EQ 空~文字列
］
⇒
~RET
◎
If there is an alternate pseudo-attribute whose value is a case-sensitive match for "yes" and title is the empty string terminate these steps.
</li>
	<li>
~IF［
%node に `type$xmlss `疑似属性$が指定されていて，その値は`~supportされる~styling言語$でない
］
⇒
~UAの任意選択で
⇒
~RET
◎
If there is a type pseudo-attribute whose value is not a supported styling language the user agent may terminate these steps.
</li>
	<li>
%入力~URL ~LET
%node の `href$xmlss `疑似属性$に指定されている値
◎
Let input URL be the value specified by the href pseudo-attribute.
</li>
	<li>
%文書 ~LET %node の`~node文書$
◎
Let document be node’s node document
</li>
	<li>
%基底~URL ~LET %文書 の`文書~基底~URL$
◎
Let base URL be document’s document base URL.
</li>
	<li>
%~referrer ~LET %文書 の`~address$
◎
Let referrer be document’s address.
</li>
	<li>
%解析済み~URL ~LET `~URL構文解析する$( %入力~URL )
◎
Let parsed URL be the return value of invoking the URL parser with the string input URL and the base URL base URL.
</li>
	<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~RET
◎
If parsed URL is failure, terminate these steps.
</li>
	<li>
%応答 ~LET
`~CSS~ss資源を~fetchする$( %解析済み~URL, %~referrer, %文書 )
◎
Let response be the result of fetching a CSS style sheet with parsed URL parsed URL, referrer referrer and document document.
</li>
	<li>
~IF［
%応答 ~EQ ~error
］
⇒
~RET
◎
If response is an error, terminate these steps.
</li>
	<li>
<p>
次の~propを伴う`~CSS~ssを作成する$：
◎
Create a CSS style sheet with the following properties:
</p>

		<dl>
			<dt>`所在$ss</dt>
			<dd>
`~URLを直列化する$( %解析済み~URL )
◎
The result of invoking the URL serializer with parsed URL.
</dd>

			<dt>`親~CSS~ss$ss</dt>
			<dd>
~NULL
◎
null.
</dd>

			<dt>`所有者~node$ss</dt>
			<dd>
%node
◎
node.
</dd>

			<dt>`所有者~CSS規則$ss</dt>
			<dd>
~NULL
◎
null.
</dd>

			<dt>`媒体$ss</dt>
			<dd>
`media$xmlss `疑似属性$の値が与えられていればそれ ／
いなければ空~文字列
◎
The value of the media pseudo-attribute if any, or the empty string otherwise.
</dd>

			<dt>`~title$ss</dt>
			<dd>
%~title
◎
title.
</dd>

			<dt>`代替-~flag$ss</dt>
			<dd>
`alternate$xmlss `疑似属性$の値 ~EQ `yes^l ならば ~ON ／
~ELSE_ ~OFF
◎
Set if the alternate pseudo-attribute value is a case-sensitive match for "yes", or unset otherwise.
</dd>

			<dt>`origin-clean ~flag$ss</dt>
			<dd>
%応答 は `~CORS同一生成元$であるならば ~ON ／
~ELSE_ ~OFF
◎
Set if response is CORS-same-origin, or unset otherwise.
</dd>

		</dl>

<p>
~CSS`環境~符号化方式$は、次を走らせた結果とする：
◎
The CSS environment encoding is the result of running the following steps:
</p>

		<ol>
			<li>
~IF［
要素は `charset$xmlss `疑似属性$を持つ
］
⇒
~IF［
`~labelから符号化方式を取得する$( その疑似属性の値 ) ~NEQ `失敗^i
］
⇒
~RET その結果
◎
If the element has a charset pseudo-attribute, get an encoding from that pseudo-attribute’s value. If that succeeds, return the resulting encoding and abort these steps.
</li>
			<li>
~RET `文書の文字~符号化方式$
◎
Otherwise, return the document’s character encoding. [DOM]
</li>
		</ol>
	</li>
</ol>


<p>
<a href="~HTMLxml#xml-parser">XML 構文解析器</a>
%構文解析器
から作成される`文書$の文脈の下で，この節の~~規則を用いて［
`xml-stylesheet 処理命令$を表現する `ProcessingInstruction$I `~node$ %node
］から参照される~ss %~ss は、次のすべてを満たすとき，`~scriptを阻んでいる~ss$と呼ばれる：
◎
A style sheet referenced by an xml-stylesheet processing instruction using the rules in this section, in the context of the Document of an XML parser is said to be a style sheet that is blocking scripts if＼
</p>

<ul>
	<li>
%node は %構文解析器 により作成されたものである
◎
the ProcessingInstruction node was created by that Document's parser, and＼
</li>
	<li>
%node の作成-時に %~ss は可能化されている
◎
the style sheet was enabled when the node was created by the parser, and＼
</li>
	<li>
%~ss の`~ss準備済み~flag$は まだ ~ON にされていない
◎
the style sheet ready flag is not yet set, and,＼
</li>
	<li>
<p>
`~event-loop$が 最後に上の~algoの最初の段に到達した時点で：
</p>
		<ul>
			<li>
%node はその`文書$ 内に在った
</li>
			<li>
~UA は %~ss をまだ`~give-up$していない
— ~UA は %~ss をいつでも`~give-up$してよい。
</li>
		</ul>
◎
the last time the event loop reached step 1, the node was in that Document, and the user agent hasn’t given up on that particular style sheet yet.
A user agent may give up on such a style sheet at any time.
</li>
</ul>

<p class="trans-note">【
`~give-up@
が正確に何を意味するかは、この仕様のみからは確定できない。
この時点では~give-upしたとしても， %~ss は後で処理されるかもしれない。
】</p>


			</section>
			<section id="requirements-on-user-agents-implementing-the-http-link-header">
			
<h4 title="Requirements on User Agents Implementing the HTTP Link Header">6.3.5. HTTP `Link^h ~headerを実装する~UAに課される要件</h4>

<p class="atrisk">
~EACH ( HTTP `Link$h ~header ) に対しては、次の手続きを走らせ~MUST：
◎
For each HTTP Link header＼
</p>

<ol>
	<li>
%~header値 ~LET `Link$h ~headerの値
◎
of which＼
</li>
	<li>
%関係~型~list ~LET ［
%~header値 の中の一連の~link関係~型（ `relation-type^c ）からなる集合
］
◎
one of the link relation types＼
</li>
	<li>
~IF［
`stylesheet^l ~NIN `~ACI$ %関係~型~list
］
⇒
~RET
◎
is an ASCII case-insensitive match for "stylesheet" these steps must be run:
</li>
	<li>
%~title ~LET ［
%~header値 の中に `title^l ~parameterが在れば，それらのうち 最初のものの値 ／
無ければ 空~文字列
］
◎
Let title be the value of the first of all the title parameters. If there are no such parameters it is the empty string.
</li>
	<li>
~IF［
%~title ~EQ 空~文字列
］~AND［
`alternate^l ~IN `~ACI$ %関係~型~list
］
⇒
~RET
◎
If one of the (other) link relation types is an ASCII case-insensitive match for "alternate" and title is the empty string terminate these steps.
</li>
	<li>
%入力~URL ~LET %~header値 に指定されている URI-Reference
<span class="issue">（より詳細に規定する必要あり）</span>
◎
Let input URL be the value specified. Be more specific
</li>
	<li>
%文書 ~LET 文書
◎
↓</li>
	<li>
%基底~URL ~LET %文書 の`文書~基底~URL$
<span class="issue">この時点で文書~objは在るのか？</span>
◎
Let base URL be the document’s document base URL. Is there a document at this point?
</li>

	<li>
%~referrer ~LET %文書 の`~address$doc
◎
Let referrer be the document’s address.
</li>

	<li>
%生成元 ~LET %文書 の`生成元$
◎
Let origin be the document’s origin.
</li>
	<li>
%解析済み~URL ~LET `~URL構文解析する$( %入力~URL )
◎
Let parsed URL be the return value of invoking the URL parser with the string input URL and the base URL base URL.
</li>
	<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~RET
◎
If parsed URL is failure, terminate these steps.
</li>
	<li>
<p>
%応答 ~LET
`~CSS~ss資源を~fetchする$( %解析済み~URL, %~referrer, %文書 )
◎
Let response be the result of fetching a CSS style sheet with parsed URL parsed URL, referrer referrer and document being the document.
</p>

<p class="issue">
HTML 構文解析器が過去互換~modeかどうかまだ決定していなかった場合はどうする？
◎
What if the HTML parser hasn’t decided on quirks/non-quirks yet?
</p>
	</li>
	<li>
<p>
次の~propを伴う`~CSS~ssを作成する$
◎
Create a CSS style sheet with the following properties:
</p>

		<dl>
			<dt>`所在$ss</dt>
			<dd>
`~URLを直列化する$( %解析済み~URL )
◎
The result of invoking the URL serializer with parsed URL.
</dd>

			<dt>`所有者~node$ss</dt>
			<dd>
~NULL
◎
null.
</dd>

			<dt>`親~CSS~ss$ss</dt>
			<dd>
~NULL
◎
null.
</dd>

			<dt>`所有者~CSS規則$ss</dt>
			<dd>
~NULL
◎
null.
</dd>

			<dt>`媒体$ss</dt>
			<dd>
最初の `media^c ~parameterの値
◎
The value of the first media parameter.
</dd>

			<dt>`~title$ss</dt>
			<dd>
%~title
◎
title.
</dd>

			<dt>`代替-~flag$ss</dt>
			<dd>
［
`alternate^l ~IN `~ACI$ %関係~型~list
ならば~ON ／
~ELSE_ ~OFF
］
◎
Set if one of the specified link relation type for this HTTP Link header is an ASCII case-insensitive match for "alternate", or false otherwise.
</dd>

			<dt>`origin-clean ~flag$ss</dt>
			<dd>
%応答 は `~CORS同一生成元$であるならば ~ON ／
~ELSE_ ~OFF
◎
Set if response is CORS-same-origin, or unset otherwise.
</dd>

		</dl>
	</li>
</ol>


<div class="p">
<p>
この節の~~規則を用いて HTTP `Link$h ~headerから参照される~ss %~ss のうち，所与の時点で 次のすべてを満たすものは、`~scriptを阻んでいる~ss$とされる
— ~UA は，そのような~ssをいつでも`~give-up$してよい：
</p>

<ul>
	<li>
%~ss は，その作成-時に可能化されている
</li>
	<li>
%~ss の`~ss準備済み~flag$ ~EQ ~OFF
</li>
	<li>
~UA は， %~ss をまだ`~give-up$していない
</li>
</ul>

◎
A style sheet referenced by a HTTP Link header using the rules in this section is said to be a style sheet that is blocking scripts if the style sheet was enabled when created, and the style sheet ready flag is not yet set, and the user agent hasn’t given up on that particular style sheet yet. A user agent may give up on such a style sheet at any time.
</div>

			</section>
		</section>
		<section id="css-rules">
<h3 title="CSS Rules">6.4. ~CSS規則</h3>

<p>
`~CSS規則@
とは、~CSS仕様にて定義される規則を表す，抽象的な概念である。
`~CSS規則$は、 `CSSRule$I ~ifcを継承する~ifcを実装する~objで表現される。
それには，以下の状態~itemが結付けられる
【括弧内は，~itemに対応する `CSSRule!I の属性~member（この訳による補足）】
◎
A CSS rule is an abstract concept that denotes a rule as defined by the CSS specification. A CSS rule is represented as an object that implements a subclass of the CSSRule interface, and which has the following associated state items:
</p>

<dl>
	<dt>`種別@（ `type$m ）◎ type</dt>
	<dd>
特定0の［
規則の種別
］に結付けられている，非負~整数。
この~itemは、規則の作成-時に初期化されなければならず，変更されることはない。
【 `CSSRule$I を継承する特定の~ifcに対応する。】
◎
A non-negative integer associated with a particular type of rule. This item is initialized when a rule is created and cannot change.
</dd>

	<dt>`~text@（ `~cssText0$m ）◎ text</dt>
	<dd>
~ss内での直接的な利用に適するような，規則の~text表現。
この~itemは規則の作成-時に初期化されなければならず，規則が存続する間 変更され得る。
◎
A text representation of the rule suitable for direct use in a style sheet. This item is initialized when a rule is created and can be changed.
</dd>

	<dt>`親~規則@（ `parentRule$m ）◎ parent CSS rule</dt>
	<dd>
この規則を封入している別の`~CSS規則$への参照か, または ~NULL。
この~itemは規則の作成-時に［
そのような別の規則があるならばそれ ／
~ELSE_ ~NULL
］に初期化される。
これは，~NULLに変更され得る。
◎
A reference to an enclosing CSS rule or null. If the rule has an enclosing rule when it is created, then this item is initialized to the enclosing rule; otherwise it is null. It can be changed to null.
</dd>

	<dt>`親~ss@（ `parentStyleSheet$m ）◎ parent CSS style sheet</dt>
	<dd>
親の`~CSS~ss$への参照か, または ~NULL。
この~itemは、規則の作成-時に結付けられている~ssへの参照に初期化される。
これは，~NULLに変更され得る。
◎
A reference to a parent CSS style sheet or null. This item is initialized to reference an associated style sheet when the rule is created. It can be changed to null.
</dd>

	<dt>`子~規則列@◎ child CSS rules</dt>
	<dd>
子 `~CSS規則$の~list。
この~listは変異し得る。
◎
A list of child CSS rules. The list can be mutated.
</dd>

</dl>

<p>
上の状態~itemに加え、各`~CSS規則$には，その`種別$に則って他の状態~itemも結付けられ得る。
◎
In addition to the above state, each CSS rule may be associated with other state in accordance with its type.
</p>

<p class="algo-head">
`~CSS規則として構文解析する@
ときは、所与の
( 文字列 %文字列 )
に対し，次を走らす：
◎
To parse a CSS rule from a string string, run the following steps:
</p>

<ol>
	<li>
%規則 ~LET %文字列 から
<a href="~CSSSYN#parse-a-rule">規則を構文解析-</a>した結果
◎
Let rule be the return value of invoking parse a rule with string.
</li>
	<li>
~IF［
%規則 ~EQ 構文~error
］
⇒
~RET %規則
◎
If rule is a syntax error, return rule.
</li>
	<li>
%解析済み規則 ~LET
適切な~CSS仕様に従って
%規則 を構文解析した上で，`無視される$ものは落とした結果
⇒
~IF［
~style規則~全体が落とされた
］
⇒
~RET 構文~error
◎
Let parsed rule be the result of parsing rule according to the appropriate CSS specifications, dropping parts that are said to be ignored. If the whole style rule is dropped, return a syntax error.
</li>
	<li>
~RET %解析済み規則
◎
Return parsed rule. 
</li>
</ol>

<p class="algo-head">
`~CSS規則を直列化する@
ときは、所与の
( `~CSS規則$ %規則 )
に対し，その`種別$
【に対応する~ifc】
に応じて，次で与えられる文字列を返す：
◎
To serialize a CSS rule, perform one of the following in accordance with the CSS rule’s type:
</p>

<dl class="switch">
	<dt>`CSSStyleRule!I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET
⇒＃
`選択子~listを直列化する$( %規則 が表現している`~CSS~style規則$の`選択子~list$ )
~APPEND ~SP
~APPEND ❝{
~APPEND ~SP
◎
The result of concatenating the following:
◎
The result of performing serialize a group of selectors on the rule’s associated selectors.
◎
The string " { ", i.e., a single SPACE (U+0020), followed by LEFT CURLY BRACKET (U+007B), followed by a single SPACE (U+0020).
</li>
			<li>
~IF［
%規則 が表現している`~CSS~style規則$の`宣言列$
【 `style$m 】
は空でない
］
⇒＃
%結果
~APPEND `宣言列を直列化する$( その宣言列 )
~APPEND ~SP
◎
The result of performing serialize a CSS declaration block on the rule’s associated declarations.
◎
If the rule is associated with one or more declarations, the string " ", i.e., a single SPACE (U+0020).
</li>
			<li>
~RET %結果
~APPEND ❝}
◎
The string "}", RIGHT CURLY BRACKET (U+007D).
</li>
		</ol>
	</dd>

	<dt>`CSSImportRule!I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET
⇒＃
"<code class="literal">@import</code>"
~APPEND ~SP
~APPEND `~CSS~URLに直列化する$( %規則 の所在【 `href$m 】 )
◎
The result of concatenating the following:
◎
The string "@import" followed by a single SPACE (U+0020).
◎
The result of performing serialize a URL on the rule’s location.
</li>
			<li>
~IF［
%規則 に結付けられている媒体~list %媒体~list
【 `media$m ／ `媒体~照会~collection$ 】
は空でない
］
⇒＃
%結果
~APPEND~SP
~APPEND `媒体~照会~listを直列化する$( %媒体~list )
◎
If the rule’s associated media list is not empty, a single SPACE (U+0020) followed by the result of performing serialize a media query list on the media list.
</li>
			<li>
~RET %結果
~APPEND ❝;
◎
The string ";", i.e., SEMICOLON (U+003B).
</li>
		</ol>

<div class="example">
<pre class="lang-css">
`import$at url(`import.css^l);
</pre>

<pre class="lang-css">
`import$at url(`print.css^l) print;
</pre>

</div>

	</dd>

	<dt>`CSSMediaRule$I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET
⇒＃
`@media^l
~APPEND ~SP
~APPEND `媒体~照会~listを直列化する$( %規則 の媒体~照会~list 【`媒体~照会~collection$】 )
~APPEND ~SP
~APPEND ❝{
◎
The result of concatenating the following:
◎
The string "@media", followed by a single SPACE (U+0020).
◎
The result of performing serialize a media query list on rule’s media query list.
◎
A single SPACE (U+0020), followed by the string "{", i.e., LEFT CURLY BRACKET (U+007B), followed by a newline.
</li>
			<li>
%規則 の`子~規則列$内の~EACH( %子~規則 ) に対し
⇒＃
%結果
~APPEND ~newline
~APPEND ~SP
~APPEND ~SP
~APPEND `~CSS規則を直列化する$( %子~規則 )
◎
The result of performing serialize a CSS rule on the each rule, seperated by a newline and indented by two spaces, in rule’s CSSRules list.
</li>
			<li>
~RET %結果
~APPEND ~newline
~APPEND ❝}
◎
A newline, followed by the string "}", i.e., RIGHT CURLY BRACKET (U+007D)
</li>
		</ol>
	</dd>
	<dd class="trans-note">【
~newlineは `000A^U0 (LF) と思われる。
】</dd>

	<dt>`CSSFontFaceRule$I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET
⇒＃
`@font-face {^l
~APPEND ~SP
~APPEND `font-family:^l
~APPEND ~SP
~APPEND `文字列を直列化する$( %規則 の `font-family$td )
~APPEND ❝;
◎
The result of concatenating the following:
◎
The string "@font-face {", followed by a single SPACE (U+0020).
◎
The string "font-family:", followed by a single SPACE (U+0020).
◎
The result of performing serialize a string on the rule’s font family name.
◎
The string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
<p>
~IF［
%規則 内に `src$d 記述子は在る
<!-- associated source list is not empty -->
］：
</p>
				<ol>
					<li>
%~source~list ~LET 
%規則 の `src$td 内の各~sourceに［
`~CSS~URLに直列化する$ ／ `~LOCALに直列化する$
］のいずれか適切な方を適用して得られる同順の~list
</li>
					<li>
%結果 ~APPEND 次の結果
⇒＃
~SP
~APPEND `src:^l
~APPEND ~SP
~APPEND `~comma区切りで直列化する$( %~source~list )
~APPEND ❝;
</li>
				</ol>
◎
If the rule’s associated source list is not empty, follow these substeps:
◎
A single SPACE (U+0020), followed by the string "src:", followed by a single SPACE (U+0020).
◎
The result of invoking serialize a comma-separated list on performing serialize a URL or serialize a LOCAL for each source on the source list.
◎
The string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `unicode-range$d 記述子は在る
］
⇒＃
%結果
~APPEND ~SP
~APPEND `unicode-range:^l
~APPEND ~SP
~APPEND %規則 の `unicode-range$td を直列化した結果
~APPEND ❝;
◎
If rule’s associated unicode-range descriptor is present, a single SPACE (U+0020), followed by the string "unicode-range:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;‘unicode-range’&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `font-variant$d 記述子は在る
］
⇒＃
%結果
~APPEND ~SP
~APPEND `font-variant:^l
~APPEND ~SP
~APPEND %規則 の `font-variant$td を直列化した結果
~APPEND ❝;
◎
If rule’s associated font-variant descriptor is present, a single SPACE (U+0020), followed by the string "font-variant:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;‘font-variant’&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `font-feature-settings$d 記述子は在る
］
⇒＃
%結果
~APPEND ~SP
~APPEND `font-feature-settings:^l
~APPEND ~SP
~APPEND %規則 の `font-feature-settings$td を直列化した結果
~APPEND ❝;
◎
If rule’s associated font-feature-settings descriptor is present, a single SPACE (U+0020), followed by the string "font-feature-settings:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;‘font-feature-settings’&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `font-stretch$d 記述子は在る
］
⇒＃
%結果
~APPEND ~SP
~APPEND `font-stretch:^l
~APPEND ~SP
~APPEND %規則 の `font-stretch$td を直列化した結果
~APPEND ❝;
◎
If rule’s associated font-stretch descriptor is present, a single SPACE (U+0020), followed by the string "font-stretch:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;‘font-stretch’&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `font-weight$d 記述子は在る
］
⇒＃
%結果
~APPEND ~SP
~APPEND `font-weight:^l
~APPEND ~SP
~APPEND %規則 の `font-weight$td を直列化した結果
~APPEND ❝;
◎
If rule’s associated font-weight descriptor is present, a single SPACE (U+0020), followed by the string "font-weight:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;‘font-weight’&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `font-style$d 記述子は在る
］
⇒＃
%結果
~APPEND ~SP
~APPEND `font-style:^l
~APPEND ~SP
~APPEND %規則 の `font-style$td を直列化した結果
~APPEND ❝;
◎
If rule’s associated font-style descriptor is present, a single SPACE (U+0020), followed by the string "font-style:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;‘font-style’&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~RET %結果
~APPEND ~SP
~APPEND ❝}
◎
A single SPACE (U+0020), followed by the string "}", i.e., RIGHT CURLY BRACKET (U+007D).
</li>
		</ol>

<p class="issue">
`CSSFontFaceRule$I の各種 記述子の値を直列化する方法を定義する必要がある。
◎
Need to define how the CSSFontFaceRule descriptors' values are serialized.
</p>
	</dd>

	<dt>`CSSPageRule$I</dt>
	<dd class="issue">
直列化する方法を定義する必要がある。
◎
Need to define how CSSPageRule is serialized.
</dd>

	<dt>`CSSNamespaceRule!I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET
"<code class="literal">@namespace</code>"
~APPEND ~SP
</li>
			<li>
~IF［
`prefix$m 属性の値 ~NEQ 空~文字列
］
⇒＃
~RET %結果
~APPEND `識別子を直列化する$( その属性~値 )
~APPEND ~SP
~APPEND `~CSS~URLに直列化する$( `namespaceURI$m 属性の値 )
~APPEND ❝;
◎
The literal string "@namespace", followed by a single SPACE (U+0020), followed by the serialization as an identifier of the prefix attribute (if any), followed by a single SPACE (U+0020) if there is a prefix, followed by the serialization as URL of the namespaceURI attribute, followed the character ";" (U+003B).
</li>
		</ol>
	</dd>
</dl>


<p class="algo-head">
`~index番の規則として挿入する@
ときは、所与の
( `~CSS規則列$ss %~list, `~CSS規則$ %規則, %index )
に対し，次を走らす：
◎
To insert a CSS rule rule in a CSS rule list list at index index, follow these steps:
</p>

<ol>
	<li>
~IF［
%index ~GT %~list の~item数
］
⇒
~THROW `IndexSizeError$E
◎
Set length to the number of items in list.
◎
If index is greater than length, then throw an IndexSizeError exception.
</li>
	<li>
%解析済み規則 ~SET `~CSS規則として構文解析する$( %規則 )
◎
Set new rule to the results of performing parse a CSS rule on argument rule.
</li>
	<li>
~IF［
%解析済み規則 ~EQ 構文~error
］
⇒
~THROW `SyntaxError$E
◎
If new rule is a syntax error, throw a SyntaxError exception.
</li>
	<li>
<p>
~IF［
~CSS仕様 `CSS21$r に規定される拘束に反するために，指定された %index （ゼロが先頭）に %解析済み規則 を挿入できない
］
⇒
~THROW `HierarchyRequestError$E
◎
If new rule cannot be inserted into list at the zero-index position index due to constraints specified by CSS, then throw a HierarchyRequestError exception. [CSS21]
</p>

<p class="note">注記：
例えば、~CSS~ssは，~style規則の後に `import$at at-規則を含められない。
◎
Note: For example, a CSS style sheet cannot contain an @import at-rule after a style rule.
</p>
	</li>
	<li>
~IF［
%解析済み規則 は `namespace$at at-規則である
］~AND［
%~list 内に［
`import$at at-規則, `namespace$at at-規則
］以外のものが含まれている
］
⇒
~THROW `InvalidStateError$E
◎
If new rule is an @namespace at-rule, and list contains anything other than @import at-rules, and @namespace at-rules, throw an InvalidStateError exception.
</li>
	<li>
%解析済み規則 を %~list 内の %index 番の~itemになるように挿入する
◎
Insert new rule into list at the zero-indexed position index.
</li>
	<li>
~RET %index
◎
Return index.
</li>
</ol>

<p class="algo-head">
`~index番の規則を除去する@
ときは、所与の
( `~CSS規則列$ss %~list, %index )
に対し，次を走らす：
◎
To remove a CSS rule from a CSS rule list list at index index, follow these steps:
</p>

<ol>
	<li>
~IF［
%index ~GTE %~list の長さ
］
⇒
~THROW `IndexSizeError$E
◎
Set length to the number of items in list.
◎
If index is greater than or equal to length, then throw an IndexSizeError exception.
</li>
	<li>
%規則 ~SET %~list 内の %index 番の`~CSS規則$
◎
Set old rule to the indexth item in list.
</li>
	<li>
~IF［
%規則 は `namespace$at at-規則である
］~AND［
%~list 内に［
`import$at at-規則, `namespace$at at-規則
］以外のものが含まれている
］
⇒
~THROW `InvalidStateError$E
◎
If old rule is an @namespace at-rule, and list contains anything other than @import at-rules, and @namespace at-rules, throw an InvalidStateError exception.
</li>
	<li>
 %~list から %index 番の %規則 を除去する
◎
Remove rule old rule from list at the zero-indexed position index.
</li>
	<li>
%規則 の［
`親~規則$ ／ `親~ss$
］ ~SET ~NULL
◎
Set old rule’s parent CSS rule and parent CSS style sheet to null.
</li>
</ol>


			<section id="the-cssrulelist-sequence">
<h4 title="The CSSRuleList Interface">6.4.1. `CSSRuleList^I ~ifc</h4>

<p>
`CSSRuleList$I ~ifcは、
`~CSS~style規則$の有順序~collectionを表現する。
◎
The CSSRuleList interface represents an ordered collection of CSS style rules.
</p>

<pre class="idl">
[`Exposed$=Window,
 `LegacyArrayClass$]
interface `CSSRuleList@I {
  getter `CSSRule$I? `item$m(~UL %index);
  ~RA ~UL `length$m;
};
</pre>

<p>
`CSSRuleList$I ~obj %O の`被support~prop~index$は、
0 以上［
%O が表現する~collectionを成す `CSSRule$I ~objの総数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of CSSRule objects represented by the collection. If there are no such CSSRule objects, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>`item(index)@m</dt>
	<dd>
被呼出時には、次を返さ~MUST
⇒
%index は此れの`被support~prop~index$であるならば
此れが表現する~collectionの中で %index 番の `CSSRule$I ~obj ／
~ELSE_ ~NULL
◎
The item(index) method must return the indexth CSSRule object in the collection. If there is no indexth object in the collection, then the method must return null.
</dd>

	<dt>`length@m</dt>
	<dd>
取得子は、此れが表現する~collectionを成す `CSSRule$I ~objの総数を返さ~MUST。
◎
The length attribute must return the number of CSSRule objects represented by the collection.
</dd>
</dl>

			</section>
			<section id="the-cssrule-interface">
<h4 title="The CSSRule Interface">6.4.2. `CSSRule^I ~ifc</h4>

<p>
`CSSRule$I ~ifcは，抽象的な基底`~CSS~style規則$を表現する。
各種`~CSS~style規則$は、その種別に応じて，この~ifcを継承する別々の~ifcで表現される。
◎
The CSSRule interface represents an abstract, base CSS style rule. Each distinct CSS style rule type is represented by a distinct interface that inherits from this interface.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSRule@I {
  const ~US `STYLE_RULE$m = 1;
  const ~US `CHARSET_RULE@m = 2; // <span class="comment" title="historical">歴史的</span>
  const ~US `IMPORT_RULE$m = 3;
  const ~US `MEDIA_RULE$m = 4;
  const ~US `FONT_FACE_RULE$m = 5;
  const ~US `PAGE_RULE$m = 6;
  const ~US `MARGIN_RULE$m = 9;
  const ~US `NAMESPACE_RULE$m = 10;
  ~RA ~US `type$m;
  attribute `CSSOMString$ `~cssText0$m;
  ~RA `CSSRule$I? `parentRule$m;
  ~RA `CSSStyleSheet$I? `parentStyleSheet$m;
};
</pre>

<dl class="idl-def">
	<dt>`type@m</dt>
	<dd>
<p>
取得子は、此れがどの~ifcの~instanceであるかに応じて，次で与えられる値を返さ~MUST：
◎
The type attribute must return the CSS rule type, as follows:
</p>
		<ol class="switch">
			<li>
`CSSStyleRule$I
⇒
`STYLE_RULE@m （数値 1 ）
◎
If the object is a CSSStyleRule
• Return STYLE_RULE (numeric value 1).
</li>
			<li>
`CSSImportRule$I
⇒
`IMPORT_RULE@m （数値 3 ）
◎
If the object is a CSSImportRule
• Return IMPORT_RULE (numeric value 3).
</li>
			<li>
`CSSMediaRule$I
⇒
`MEDIA_RULE@m （数値 4 ）
◎
If the object is a CSSMediaRule
• Return MEDIA_RULE (numeric value 4).
</li>
			<li>
`CSSFontFaceRule$I
⇒
`FONT_FACE_RULE@m （数値 5 ）
◎
If the object is a CSSFontFaceRule
• Return FONT_FACE_RULE (numeric value 5).
</li>
			<li>
`CSSPageRule$I
⇒
`PAGE_RULE@m （数値 6 ）
◎
If the object is a CSSPageRule
• Return PAGE_RULE (numeric value 6).
</li>
			<li>
`CSSMarginRule$I
⇒
`MARGIN_RULE@m （数値 9 ）
◎
If the object is a CSSMarginRule
• Return MARGIN_RULE (numeric value 9).
</li>
			<li>
`CSSNamespaceRule$I
⇒
`NAMESPACE_RULE@m （数値 10 ）
◎
If the object is a CSSNamespaceRule
• Return NAMESPACE_RULE (numeric value 10).
</li>
			<li>
その他
⇒
<a href="https://wiki.csswg.org/spec/cssom-constants">CSSOM Constants</a>
wiki ページにて定義されている値
◎
Otherwise
• Return a value defined on the CSSOM Constants wiki page.
</li>
		</ol>

<p class="note">注記：
値 0 は、以前は `UNKNOWN_RULE^m として知られていたが，この仕様により廃用にされた。
この値は、将来的にも利用されないものとして，予約されることになる。
◎
Note: The value 0, formerly known as UNKNOWN_RULE, is made obsolete by this specification. This value will not be re-allocated in the future and will remain reserved.
</p>
	</dd>

	<dt>`~cssText0@m</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
`~CSS規則を直列化する$( 此れの`~CSS規則$ )
◎
The cssText attribute must return a serialization of the CSS rule.＼
</dd>
	<dd>
設定子は、何もしては~MUST_NOT。
◎
On setting the cssText attribute must do nothing.
</dd>

	<dt>`parentRule@m</dt>
	<dd>
取得子は、此れの`親~規則$を返さ~MUST。
◎
The parentRule attribute must return the parent CSS rule.
</dd>
	<dd class="note">注記：
例えば、 `media$at は規則を封入し得る。
その場合、`parentRule$m は非 ~NULL になる。
封入する規則がないときの `parentRule$m は~NULLになる。
◎
Note: For example, @media can enclose a rule, in which case parentRule would be non-null; in cases where there is no enclosing rule, parentRule will be null.
</dd>

	<dt>`parentStyleSheet@m</dt>
	<dd>
取得子は、此れの`親~ss$を返さ~MUST。
◎
The parentStyleSheet attribute must return the parent CSS style sheet.
</dd>
	<dd class="note">注記：
~NULLが返されるような唯一の状況は
~CSS~ssから
<a href="#remove-a-css-rule">除去されたとき</a>
である。
◎
Note: The only circumstance where null is returned when a rule has been removed.
</dd>
	<dd class="note">注記：
`文書$から［
`LinkStyle$I ~ifcを実装する `Node^I
］が除去されても，（それだけでは） `CSSRule$I から `CSSStyleSheet$I への参照は到達できなくなるわけではない。
◎
Note: Removing a Node that implements the LinkStyle interface from a Document instance does not (by itself) cause the CSSStyleSheet referenced by a CSSRule to be unreachable.
</dd>
</dl>

			</section>
			<section id="the-cssstylerule-interface">
<h4 title="The CSSStyleRule Interface">6.4.3. `CSSStyleRule^I ~ifc</h4>

<p>
`CSSStyleRule$I ~ifcは`~CSS~style規則$を表現する。
◎
The CSSStyleRule interface represents a style rule.
</p>

<p class="trans-note">【
`~CSS~style規則@
とは、`選択子~list$と`~CSS宣言~block$の組である。
略して “~style規則” とも記される。
】</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSStyleRule@I : `CSSRule$I {
  attribute `CSSOMString$ `selectorText$m;
  [`SameObject$, `PutForwards$=`cssText$m] ~RA `CSSStyleDeclaration$I `style$m;
};
</pre>

<dl class="idl-def">
	<dt>`selectorText@m</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
`選択子~listを直列化する$( 結付けられている`選択子~list$ )
◎
The selectorText attribute, on getting, must return the result of serializing the associated group of selectors.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
On setting the selectorText attribute these steps must be run:
</p>

		<ol>
			<li>
%~list ~LET `選択子~listとして構文解析する$( 所与の値 )
◎
Run the parse a group of selectors algorithm on the given value.
</li>
			<li>
~IF［
%~list ~NEQ ~NULL
］
⇒
結付けられている`選択子~list$ ~SET %~list
◎
If the algorithm returns a non-null value replace the associated group of selectors with the returned value.
◎
Otherwise, if the algorithm returns a null value, do nothing.
</li>
		</ol>
	</dd>

	<dt>`style@m</dt>
	<dd>
取得子は、［
次のようにされた，~style規則
］を表現する `CSSStyleDeclaration$I ~objを返さ~MUST
<!-- 
すなわち，`~CSS宣言~block$を表現する~obj
 -->
⇒＃
`読専~flag$ ~SET ~OFF,
`宣言列$ ~SET この規則の中で宣言された一連の宣言からなる，`指定順$による宣言列,
`親~CSS規則$ ~SET 此れ,
`所有者~node$ ~SET ~NULL
◎
The style attribute must return a CSSStyleDeclaration object for the style rule, with the following properties:
◎
readonly flag
• Unset.
declarations
• The declared declarations in the rule, in specified order. 
parent CSS rule
• The context object.
owner node
• Null. 
</dd>
</dl>

<p>
`指定順@
による宣言列とは、その順序は指定された順序と同じであるが，`略式~prop$については`正準的~順序$で`下位prop$に展開されているものを意味する。
同じ~propが（`略式~prop$の展開-後に）複数~回~現れる場合、~cascadingにおいて最高位のもののみが，指定された所に位置するものとして，表現され~MUST。
`CSS3CASCADE$r
◎
The specified order for declarations is the same as specified, but with shorthand properties expanded into their longhand properties, in canonical order. If a property is specified more than once (after shorthand expansion), only the one with greatest cascading order must be represented, at the same relative position as it was specified. [CSS3CASCADE]
</p>


			</section>
			<section id="the-cssimportrule-interface">
<h4 title="The CSSImportRule Interface">6.4.4. `CSSImportRule^I ~ifc</h4>

<p>
`CSSImportRule$I ~ifcは `import$at at-規則を表現する。
◎
The CSSImportRule interface represents an @import at-rule.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSImportRule@I : `CSSRule$I {
  ~RA `USVString$ `href$m;
  [`SameObject$, `PutForwards$=`mediaText$m] ~RA `MediaList$I `media$m;
  [`SameObject$] ~RA `CSSStyleSheet$I `styleSheet$m;
};
</pre>

<dl class="idl-def">
	<dt>`href@m</dt>
	<dd>
取得子は、 `import$at at-規則に指定された <span>URL</span> を返さ~MUST。<!-- ＊ -->
◎
The href attribute must return the URL specified by the @import at-rule.
</dd>
	<dd class="note">注記：
解決された URL を取得するには，結付けられている`~CSS~ss$の `StyleSheet.href$m 属性を利用する。
◎
Note: To get the resolved URL use the href attribute of the associated CSS style sheet.
</dd>

	<dt>`media@m</dt>
	<dd>
取得子は、結付けられている`~CSS~ss$の `StyleSheet.media$m 属性の値を返さ~MUST。
◎
The media attribute must return the value of the media attribute of the associated CSS style sheet.
</dd>

	<dt>`styleSheet@m</dt>
	<dd>
取得子は、結付けられている`~CSS~ss$を返さ~MUST。
◎
The styleSheet attribute must return the associated CSS style sheet.
</dd>
	<dd class="note">注記：
~ssの読込みに失敗した場合、`~CSS規則列$ssは単に空にされる。
すなわち， `import$at at-規則には常に`~CSS~ss$が結付けられる。
◎
Note: If loading of the style sheet fails its CSS rules list is simply empty, i.e., an @import at-rule always has an associated CSS style sheet.
</dd>
</dl>


			</section>
			<section id="the-cssgroupingrule-interface">

<h4 title="The CSSGroupingRule Interface">6.4.5. `CSSGroupingRule^I ~ifc</h4>

<p>
`CSSGroupingRule$I
~ifcは 自身の内部に他の規則を入子にする at-規則を表現する。
◎
The CSSGroupingRule interface represents an at-rule that contains other rules nested inside itself.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSGroupingRule@I : `CSSRule$I {
  [`SameObject$] ~RA `CSSRuleList$I `cssRules$m;
  ~UL `insertRule$m(`CSSOMString$ %rule, optional ~UL %index = 0);
  void `deleteRule$m(~UL %index);
};
</pre>

<dl class="idl-def">
	<dt>`cssRules@m</dt>
	<dd>
取得子は、此れの`子~規則列$を表現する `CSSRuleList$I ~objを返さ~MUST。
◎
The cssRules attribute must return a CSSRuleList object for the child CSS rules.
</dd>

	<dt>`insertRule(rule, index)@m</dt>
	<dd>
被呼出時には、次の結果を返さ~MUST
⇒
`~index番の規則として挿入する$( 此れの`子~規則列$, %rule, %index )
◎
The insertRule(rule, index) method must return the result of invoking insert a CSS rule rule into the child CSS rules at index.
</dd>

	<dt>`deleteRule(index)@m</dt>
	<dd>
被呼出時には、次を走らせ~MUST。
⇒
`~index番の規則を除去する$( 此れの`子~規則列$, %index )
◎
The deleteRule(index) method must remove a CSS rule from the child CSS rules at index.
</dd>
</dl>

			</section>
			<section id="the-cssmediarule-interface">
<h4 title="The CSSMediaRule Interface">6.4.6. `CSSMediaRule^I ~ifc</h4>

<p>
`CSSMediaRule$I ~ifcは、 `CSS3-CONDITIONAL$r にて定義される。
◎
The CSSMediaRule interface is defined in CSS Conditional Rules. [CSS3-CONDITIONAL]
</p>

			</section>
			<section id="the-csspagerule-interface">
<h4 title="The CSSPageRule Interface">6.4.7. `CSSPageRule^I ~ifc</h4>
<p>
`CSSPageRule$I ~ifcは `page$at at-規則を表現する。
◎
The CSSPageRule interface represents an @page at-rule.
</p>

<p class="issue">
`~CSS頁~選択子~list$を
`構文解析-@page ／
`直列化-@page
するための~~規則を定義する必要がある。
◎
Need to define the rules for parse a list of CSS page selectors and serialize a list of CSS page selectors.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSPageRule@I : `CSSGroupingRule$I {
  attribute `CSSOMString$ `selectorText$m;
  [`SameObject$, `PutForwards$=`cssText$m] ~RA `CSSStyleDeclaration$I `style$m;
};
</pre>

<dl class="idl-def">
	<dt>`selectorText@m</dt>
	<dd>
取得子は、［
結付けられている`~CSS頁~選択子~list$を `直列化-$pageした結果
］を返さ~MUST。
◎
The selectorText attribute, on getting, must return the result of serializing the associated list of CSS page selectors.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
On setting the selectorText attribute these steps must be run:
</p>

<ol>
	<li>
%値 ~LET `~CSS頁~選択子~listとして構文解析する$( 所与の値 )
◎
Run the parse a list of CSS page selectors algorithm on the given value.
</li>
	<li>
~IF［
%値 ~NEQ ~NULL
］
⇒
結付けられている`~CSS頁~選択子~list$ ~SET %値
◎
If the algorithm returns a non-null value replace the associated list of CSS page selectors with the returned value.
◎
Otherwise, if the algorithm returns a null value, do nothing.
</li>
</ol>

	</dd>

	<dt>`style@m</dt>
	<dd>
取得子は、［
次のようにされた， `page$at at-規則
］を表現する `CSSStyleDeclaration$I ~objを返さ~MUST
⇒＃
`読専~flag$ ~SET ~OFF,
`宣言列$ ~SET この規則の中で宣言された一連の宣言からなる，`指定順$による宣言列,
`親~CSS規則$ ~SET 此れ,
`所有者~node$ ~SET ~NULL
◎
The style attribute must return a CSSStyleDeclaration object for the @page at-rule, with the following properties:
◎
readonly flag
• Unset.
declarations
• The declared declarations in the rule, in specified order. 
parent CSS rule
• The context object.
owner node
• Null. 
</dd>
</dl>


			</section>
			<section id="the-cssmarginrule-interface">

<h4 title="The CSSMarginRule Interface">6.4.8. `CSSMarginRule^I ~ifc</h4>

<p>
`CSSMarginRule$I ~ifcは `page$at at-規則の中の
`~margin at-規則$ （例えば `top-left^at ）を表現する。
`CSS3PAGE$r
◎
The CSSMarginRule interface represents a margin at-rule (e.g. @top-left) in an @page at-rule. [CSS3PAGE]
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSMarginRule@I : `CSSRule$I {
  ~RA `CSSOMString$ `name$m;
  [`SameObject$, `PutForwards$=`cssText$m] ~RA `CSSStyleDeclaration$I `style$m;
};
</pre>


<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
取得子は、`~margin at-規則$の名前を返さ~MUST。
文字  <code>@</code> は名前に含まれない。
`CSS3SYN$r
◎
The name attribute must return the name of the margin at-rule. The @ character is not included in the name. [CSS3SYN]
</dd>

	<dt>`style@m</dt>
	<dd>
<p>
取得子は、［
次のようにされた， `~margin at-規則$
］を表現する `CSSStyleDeclaration$I ~objを返さ~MUST
⇒＃
`読専~flag$ ~SET ~OFF,
`宣言列$ ~SET この規則の中で宣言された一連の宣言からなる，`指定順$による宣言列,
`親~CSS規則$ ~SET 此れ,
`所有者~node$ ~SET ~NULL
◎
The style attribute must return a CSSStyleDeclaration object for the margin at-rule, with the following properties:
◎
readonly flag
• Unset.
declarations
• The declared declarations in the rule, in specified order. 
parent CSS rule
• The context object.
owner node
• Null. 
</dd>
</dl>

			</section>
			<section id="the-cssnamespacerule-interface">
<h4 title="The CSSNamespaceRule Interface">6.4.9. `CSSNamespaceRule^I ~ifc</h4>

<p>
`CSSNamespaceRule$I ~ifcは `namespace$at at-規則を表現する。
◎
The CSSNamespaceRule interface represents an @namespace at-rule.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSNamespaceRule@I : `CSSRule$I {
  readonly attribute `CSSOMString$ `namespaceURI$m;
  readonly attribute `CSSOMString$ `prefix$m;
};
</pre>


<dl class="idl-def">
	<dt>`namespaceURI@m</dt>
	<dd>
取得子は、此れの名前空間
【名前空間 URI】
を返さ~MUST。
◎
The namespaceURI attribute must return the namespace of the @namespace at-rule.
</dd>

	<dt>`prefix@m</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
此れの`名前空間~接頭辞$があれば それ ／
なければ空~文字列
◎
The prefix attribute must return the prefix of the @namespace at-rule or the empty string if there is no prefix.
</dd>
</dl>

			</section>
		</section>
		<section id="css-declarations">

<h3 title="CSS Declarations">6.5. ~CSS宣言</h3>

<p>
`~CSS宣言@
とは、~DOMにおいては~objとして公開されない抽象的な概念である。
各 `~CSS宣言$には、次のものが結付けられる：
◎
A CSS declaration is an abstract concept that is not exposed as an object in the DOM. A CSS declaration has the following associated properties:
</p>

<p class="trans-note">【
CSS2 の
<a href="~CSS22/syndata.html#declaration">declaration</a>
— すなわち［
~prop名: 値
］の組に対応する。
】</p>

<dl class="def-list">
	<dt>`~prop名@◎ property name</dt>
	<dd>
宣言の~prop名
◎
The property name of the declaration. 
</dd>

	<dt>`値@◎ value</dt>
	<dd>
宣言の値を成す成分値たちからなる~listとして表現される
◎
The value of the declaration represented as a list of component values. 
</dd>

	<dt>`~important~flag@◎ important flag</dt>
	<dd>
変更-可能な ~ON, ~OFF の 2 値をとり得る。
◎
Either set or unset. Can be changed.
</dd>
	<dd class="trans-note">【
<code>!important</code> 宣言の有無に対応する
】</dd>

	<dt>`大小区別~flag@◎ case-sensitive flag</dt>
	<dd>
`~prop名$が その仕様により文字大小区別とされているとき ~ON にされ, 他の場合は ~OFF にされる。
◎
Set if the property name is defined to be case-sensitive according to its specification, otherwise unset.
</dd>
	<dd class="trans-note">【
ほぼ
<a href="~CSSVAR#defining-variables">~custom~prop用</a>
のもの
】</dd>

</dl>

		</section>
		<section id="css-declaration-blocks">
<h3 title="CSS Declaration Blocks">6.6. ~CSS宣言~block</h3>

<p>
`~CSS宣言~block@
とは、値が結付けられている~CSS~prop（ `~CSS宣言$とも呼ばれる）からなる，有順序~collectionである。
~DOMにおいては， `CSSStyleDeclaration$I ~objが`~CSS宣言~block$を表現する。
各 `~CSS宣言~block$には，次のものが結付けられる：
◎
A CSS declaration block is an ordered collection of CSS properties with their associated values, also named CSS declarations. In the DOM a CSS declaration block is a CSSStyleDeclaration object. A CSS declaration block has the following associated properties:
</p>

<p class="trans-note">【
CSS2 の
<a href="~CSS22/syndata.html#rule-sets">declaration block</a>
に対応する
】</p>

<dl class="def-list">
	<dt>`読専~flag@◎ readonly flag</dt>
	<dd>
~objの操作が［
可能ならば ~OFF ／
不可ならば ~ON
］にされる。
特に指定されない限り，~OFF 。
◎
Unset if the object can be manipulated. Set if it can not be manipulated. Unless otherwise stated it is unset.
</dd>

	<dt>`宣言列@◎ declarations</dt>
	<dd>
~objに結付けられている一連の`~CSS宣言$。
◎
The CSS declarations associated with the object.
</dd>

	<dt>`親~CSS規則@◎ parent CSS rule</dt>
	<dd>
`~CSS宣言~block$が結付けられている`~CSS規則$があれば それ ／
無ければ ~NULL
◎
The CSS rule that the CSS declaration block is associated with, if any, or null otherwise.
</dd>
 
	<dt>`所有者~node@◎ owner node</dt>
	<dd>
`~CSS宣言~block$が結付けられている `Element$I があれば それ ／
無ければ ~NULL
◎
The Element that the CSS declaration block is associated with, if any, or null otherwise.
</dd>

</dl>

<p class="algo-head">
`~CSS宣言~blockとして構文解析する@
ときは、所与の
( 文字列 %文字列 )
に対し，次を走らす：
◎
To parse a CSS declaration block from a string string, follow these steps:
</p>

<ol>
	<li>
%宣言~list ~LET %文字列 を
<a href="~CSSSYN#parse-a-list-of-declarations">宣言~listとして構文解析する</a>
した結果
◎
Let declarations be the return value of invoking parse a list of declarations with string.
</li>
	<li>
%解析済み宣言~list ~LET 新たな空~list
◎
Let parsed declarations be a new empty list.
</li>
	<li>
<p>
%宣言~list 内の~EACH ( %宣言 ) に対し：
◎
For each item declaration in declarations, follow these substeps:
</p>

		<ol>
			<li>
%解析済み宣言 ~LET 適切な~CSS仕様に従って
%宣言 を構文解析し，`無視される$ものは落とした結果
◎
Let parsed declaration be the result of parsing declaration according to the appropriate CSS specifications, dropping parts that are said to be ignored. If the whole declaration is dropped, let parsed declaration be null.
</li>
			<li>
~IF［
前~段により宣言~全体は落とされてはいない（ %解析済み宣言 は空でない）
］
⇒
%解析済み宣言~list に %解析済み宣言 を付加する
◎
If parsed declaration is not null, append it to parsed declarations. 
</li>
		</ol>
	</li>
	<li>
~RET %解析済み宣言~list
◎
Return parsed declarations.
</li>
</ol>

<p class="algo-head">
`~CSS宣言を直列化する@
ときは、所与の
( %~prop名, %値, %~important~flag )
に対し，次に従う：
◎
To serialize a CSS declaration with property name property, value value and optionally an important flag set, follow these steps:
</p>

<ol>
	<li>
%結果 ~LET 次の結果
⇒＃
%~prop名
~APPEND ❝:
~APPEND ~SP
~APPEND %値
◎
Let s be the empty string.
◎
Append property to s.
◎
Append ": " (U+003A U+0020) to s.
◎
Append value to s.
</li>
	<li>
~IF［
%important ~EQ ~ON
］
⇒＃
%結果
~APPEND ~SP
~APPEND `!important^l <span class="code-point">(U+0021 U+0069 U+006D U+0070 U+006F U+0072 U+0074 U+0061 U+006E U+0074)</span>
◎
If the important flag is set, append " !important" (U+0020 U+0021 U+0069 U+006D U+0070 U+006F U+0072 U+0074 U+0061 U+006E U+0074) to s.
</li>
	<li>
%結果 ~APPEND ❝;
◎
Append ";" (U+003B) to s.
</li>
	<li>
~RET %結果
◎
Return s.
</li>
</ol>


<p class="algo-head">
`宣言列を直列化する@
ときは、所与の
( `~CSS宣言~block$の`宣言列$ %宣言~list )
に対し，次を走らす：
◎
To serialize a CSS declaration block declaration block means to run the steps below:
</p>


<ol>
	<li>
%~list ~LET 空~list
◎
Let list be an empty array.
</li>
	<li>
%直列化-済み集合 ~LET 空~集合
◎
Let already serialized be an empty array.
</li>
	<li>
<p>
%宣言~list 内の
~EACH ( `~CSS宣言$ %宣言 ) に対し：
◎
Declaration loop: For each CSS declaration declaration in declaration block’s declarations, follow these substeps:
</p>

		<ol>
			<li>
%~prop名 ~LET %宣言 の`~prop名$
◎
Let property be declaration’s property name.
</li>
			<li>
~IF［
%~prop名 ~IN %直列化-済み集合
］
⇒
~CONTINUE
◎
If property is in already serialized, continue with the steps labeled declaration loop.
</li>
			<li>
<p>
~IF［
%~prop名 に対応する`略式~prop$は 一つ以上ある
］：
◎
If property maps to one or more shorthand properties,＼
</p>

<p class="trans-note">【
“対応する（ map to ）” —
どうも定義がはっきりしないが、
%~prop名 は必ずしも（末端の）`下位prop$のみを指すわけではないようにも思われる：
例えば`略式~prop$［
`border-style$p,
`border-color$p,
`border-width$p
］は，直列化の際に，より上位の`略式~prop$ `border$p にまとめられるようにするために，
`border$p に “対応する” ものとも考えられる。
】</p>

				<ol>

					<li>
%略式~prop~list ~LET
それらの`略式~prop$の`選好順$による~list
◎
let shorthands be an array of those shorthand properties, in preferred order, and follow these substeps:
</li>
					<li>
<p>
%下位prop~list ~LET ［
%宣言~list 内の`~CSS宣言$のうち，次の両者を満たすもの
］すべてからなる~list：
</p>
		<ul>
			<li>
宣言の`~prop名$ ~NIN %直列化-済み集合
</li>
			<li>
宣言の`~prop名$ ~EQ ［
%略式~prop~list 内の ある`略式~prop$の ある下位propの名前
］
</li>
		</ul>

◎
Let longhands be an array consisting of all CSS declarations in declaration block’s declarations that that are not in already serialized and have a property name that maps to one of the shorthand properties in shorthands.
</li>
					<li>
<p>
%略式~prop~list 内の ~EACH ( %略式~prop ) に対し：
◎
Shorthand loop: For each shorthand in shorthands, follow these substeps:
</p>

						<ol>
							<li>
%下位prop名~集合 ~LET［
%略式~prop の すべての`下位prop$の`~prop名$
］からなる集合
◎
↓</li>
							<li>
%現~下位prop~list ~LET ［
%下位prop~list 内の`~CSS宣言$のうち，［
その`~prop名$ ~IN %下位prop名~集合
］なるもの
］すべてからなる~list
◎
↓
</li>
							<li>
~IF［
%現~下位prop~list の~item数 ~LT %下位prop名~集合 の~item数
］
⇒
~CONTINUE
◎
If all properties that map to shorthand are not present in longhands, continue with the steps labeled shorthand loop.
◎
Let current longhands be an empty array.
◎
Append all CSS declarations in longhands have a property name that maps to shorthand to current longhands.
</li>
		<li>
%important ~LET ［
%現~下位prop~list の最初の`~CSS宣言$
］の`~important~flag$
◎
↓</li>
							<li>
~IF［
%現~下位prop~list 内に［
`~important~flag$ ~NEQ %important
］なる`~CSS宣言$はある
］
⇒
~CONTINUE
◎
If there is one or more CSS declarations in current longhands have their important flag set and one or more with it unset, continue with the steps labeled shorthand loop.
</li>
							<li>
%値 ~LET `下位prop~listを直列化する$( %現~下位prop~list )
◎
Let value be the result of invoking serialize a CSS value of current longhands.
</li>
							<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~CONTINUE
◎
If value is the empty string, continue with the steps labeled shorthand loop.
</li>
							<li>
%~list に次の結果を付加する
⇒
`~CSS宣言を直列化する$( %略式~prop, %値, %important )
◎
Let serialized declaration be the result of invoking serialize a CSS declaration with property name shorthand, value value, and the important flag set if the CSS declarations in current longhands have their important flag set.
◎
Append serialized declaration to list.
</li>
							<li>
%直列化-済み集合 ~SET ［
%直列化-済み集合 と %下位prop名~集合
］の和集合
◎
Append the property names of all items of current longhands to already serialized.
</li>
							<li>
%下位prop~list から %現~下位prop~list に含まれる~itemすべてを除去する
◎
Remove the items present in current longhands from longhands.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~IF［
%~prop名 ~IN %直列化-済み集合
］
⇒
~CONTINUE
◎
If property is in already serialized, continue with the steps labeled declaration loop.
</li>
			<li>
%値 ~LET `~CSS値を直列化する$( %宣言 の`値$ )
◎
Let value be the result of invoking serialize a CSS value of declaration.
</li>
			<li>
%~list に次の結果を付加する
⇒
`~CSS宣言を直列化する$( %~prop名, %値, %宣言 の`~important~flag$ )
◎
Let serialized declaration be the result of invoking serialize a CSS declaration with property name property, value value, and the important flag set if declaration has its important flag set.
◎
Append serialized declaration to list.
</li>
			<li>
%~prop名 を %直列化-済み集合 に~~追加する
◎
Append property to already serialized.
</li>
		</ol>
	</li><li>
~RET %~list を~SPで区切って連結した結果
◎
Return list joined with " " (U+0020).
</li>
</ol>

<p class="note">注記：
空の`~CSS宣言~block$を直列化した結果は、空~文字列になる。
◎
Note: The serialization of an empty CSS declaration block is the empty string.
</p>

<p class="note">注記：
空でない`~CSS宣言~block$を直列化した結果の，先頭／末尾 には、空白は含まれない。
すなわち，最初の~prop名の前, および最後の~prop値の最後の~semicolon区切子の後には、空白は現れない。
◎
Note: The serialization of a non-empty CSS declaration block does not include any surrounding whitespace, i.e., no whitespace appears before the first property name and no whitespace appears after the final semicolon delimiter that follows the last property value.
</p>

<p>
`略式~prop$~list %略式~prop~list の
`選好順@
は、次で与えられる：
◎
The preferred order of a list of shorthand properties shorthands is as follows:
</p>

<ol>
	<li>
%略式~prop~list を辞書式~順序に~~整列する
◎
Order shorthands lexicographically.
</li>
	<li>
%略式~prop~list 内の ❝- から始まる~itemすべてを、それらの相対的~順序は保ったまま，~listの末尾に回す
◎
Move all items in shorthands that begin with "-" (U+002D) last in the list, retaining their relative order.
</li>
	<li>
%略式~prop~list 内の［
❝- から始まる
］~AND［
`-webkit-^l からは始まらない
］ような~itemすべてを、それらの相対的~順序は保ったまま，~listの末尾に回す
◎
Move all items in shorthands that begin with "-" (U+002D) but do not begin with "-webkit-" last in the list, retaining their relative order.
</li>
	<li>
<p>
%略式~prop~list を
【先行の段で末尾に回されたものは，その順位を保ちつつ？】
対応する`下位prop$の個数が多い順に並べる
◎
Order shorthands by the number of longhand properties that map to it, with the greatest number first.
</p>

<p class="trans-note">【
例えば
`border-style$p よりも `border$p の方が <em>末端の</em> `下位prop$の個数が多くなるので，先に来るものと考えられる。
】</p>

	</li>
</ol>


			<section id="the-cssstyledeclaration-interface">
<h4 title="The CSSStyleDeclaration Interface">6.6.1. `CSSStyleDeclaration^I ~ifc</h4>

<p>
`CSSStyleDeclaration$I
~ifcは，下層の状態も含めた`~CSS宣言~block$を表現する。
この下層の状態は `CSSStyleDeclaration$I ~instanceの~sourceに依存する。
◎
The CSSStyleDeclaration interface represents a CSS declaration block, including its underlying state, where this underlying state depends upon the source of the CSSStyleDeclaration instance.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSStyleDeclaration@I {
  [`CEReactions$] attribute `CSSOMString$ `cssText$m;
  ~RA ~UL `length$m;
  getter `CSSOMString$ `item$m(~UL %index);
  `CSSOMString$ `getPropertyValue$m(`CSSOMString$ %property);
  `CSSOMString$ `getPropertyPriority$m(`CSSOMString$ %property);
  [`CEReactions$] void `setProperty$m(
      `CSSOMString$ %property,
      [`TreatNullAs$=EmptyString] `CSSOMString$ %value,
      [`TreatNullAs$=EmptyString] optional `CSSOMString$ %priority = ""
  );
  [`CEReactions$] void `setPropertyValue$m(
      `CSSOMString$ %property,
      [`TreatNullAs$=EmptyString] `CSSOMString$ %value
  );
  [`CEReactions$] void `setPropertyPriority$m(
      `CSSOMString$ %property,
      [`TreatNullAs$=EmptyString] `CSSOMString$ %priority
  );
  [`CEReactions$] `CSSOMString$ `removeProperty$m(`CSSOMString$ %property);
  ~RA `CSSRule$I? `parentRule$m;
  [`CEReactions$] attribute [`TreatNullAs$=EmptyString] `CSSOMString$ `cssFloat$m;
};
</pre>

<p>
~objの`被support~prop~index$は、
0 以上［
此れの`宣言列$に含まれている`~CSS宣言$の総数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of CSS declarations in the declarations. If there are no such CSS declarations, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>`cssText@m</dt>
	<dd>
<p>
取得子は、次の結果を返さ~MUST
⇒
`宣言列を直列化する$( 此れの`宣言列$ )
◎
The cssText attribute must return the result of serializing the declarations.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
Setting the cssText attribute must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの`読専~flag$ ~EQ ~ON
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, throw a NoModificationAllowedError exception and terminate these steps.
</li>
			<li>
此れの`宣言列$を空にする
◎
Empty the declarations.
</li>
			<li>
%items ~LET `~CSS宣言~blockとして構文解析する$( 所与の値 )
◎
Parse the given value and,＼
</li>
			<li>
~IF［
%items は空~listでない
］
⇒
%items を，`指定順$により 此れの`宣言列$に挿入する
◎
if the return value is not the empty list, insert the items in the list into the declarations, in specified order.
</li>
		</ol>
	</dd>

	<dt>`length@m</dt>
	<dd>
取得子は、此れの`宣言列$に含まれている`~CSS宣言$の個数を返さ~MUST。
◎
The length attribute must return the number of CSS declarations in the declarations.
</dd>

	<dt>`item(index)@m</dt>
	<dd>
被呼出時には、此れの`宣言列$内の %index 番の`~CSS宣言$の`~prop名$を返さ~MUST。
◎
The item(index) method must return the property name of the CSS declaration at position index.
</dd>

	<dt>`getPropertyValue(property)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getPropertyValue(property) method must run these steps:
</p>

		<ol>
			<li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
				<ol>
					<li>
%property ~LET %property を`~ASCII小文字~化$した結果
◎
Let property be property converted to ASCII lowercase.
</li>
					<li>
<p>
~IF［
%property は `略式~prop$の名前である
］：
</p>

						<ol>
							<li>
%下位prop名~集合 ~LET %property のすべての`下位prop$の名前からなる集合
</li>
							<li>
%宣言~list ~LET［
此れの`宣言列$内の~CSS宣言のうち，［
`~prop名$ ~IN %下位prop名~集合
］なるもの
］からなる，`正準的~順序$による~list
</li>
							<li>
~IF［
%宣言~list の~item数 ~LT %下位prop名~集合 の~item数
］
⇒
~RET 空~文字列
</li>
							<li>
~IF［
%宣言~list 内のすべての~CSS宣言の`~important~flag$は、互いに同じである
］
⇒
~RET `下位prop~listを直列化する$( %宣言~list )
</li>
							<li>
~RET 空~文字列
</li>
						</ol>

◎
If property is a shorthand property, then follow these substeps:
• Let list be a new empty array.
• For each longhand property longhand that property maps to, in canonical order, follow these substeps:
•• If longhand is a case-sensitive match for a property name of a CSS declaration in the declarations, let declaration be that CSS declaration, or null otherwise.
•• If declaration is null, return the empty string and terminate these steps.
•• Append the declaration to list.
• If important flags of all declarations in list are same, return the serialization of list and terminate these steps.
• Return the empty string. 
</li>
				</ol>
			</li>
			<li>
~IF［
此れの`宣言列$内に
`~prop名$ ~EQ %property なる`~CSS宣言$がある
］
⇒
~RET
`~CSS値を直列化する$( その宣言の`値$ )
◎
If property is a case-sensitive match for a property name of a CSS declaration in the declarations, return the result of invoking serialize a CSS value of that declaration and terminate these steps.
</li>
			<li>
~RET 空~文字列
◎
Return the empty string.
</li>
		</ol>
	</dd>

	<dt>`getPropertyPriority(property)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getPropertyPriority(property) method must run these steps:
</p>

		<ol>
			<li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
				<ol>
					<li>
%property ~LET %property を`~ASCII小文字~化$した結果
◎
Let property be property converted to ASCII lowercase.
</li>
					<li>
<p>
~IF［
%property は`略式~prop$の名前である
］：
◎
If property is a shorthand property, follow these substeps:
</p>
						<ol>
							<li>
%property に対応する ~EACH ( `下位prop$ %下位prop ) に対し
⇒
~IF［
( %下位prop ) を引数に 此れ上の `getPropertyPriority()$m を呼出した結果
~NEQ `important^l
］
⇒
~RET 空~文字列
◎
Let list be a new array.
◎
For each longhand property longhand that property maps to, append the result of invoking getPropertyPriority() with longhand as argument to list.
</li>
							<li>
~RET `important^l
◎
If all items in list are the string "important", return the string "important" and terminate these steps.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~IF［
此れの`宣言列$内に［
`~prop名$ ~EQ %property
］~AND［
`~important~flag$ ~EQ ~ON
］なる`~CSS宣言$はある
］
⇒
~RET `important^l
◎
If property is a case-sensitive match for a property name of a CSS declaration in the declarations that has the important flag set, return the string "important".
</li>
			<li>
~RET 空~文字列
◎
Return the empty string.
</li>
		</ol>
	</dd>
	<dd class="example">
例えば
<code class="css">background-color:`lime^v !IMPORTANT;</code>
に対し 返される値は `important^l になるであろう。
◎
E.g. for background-color:lime !IMPORTANT the return value would be "important".
</dd>

	<dt>`setProperty(property, value, priority)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setProperty(property, value, priority) method must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの`読専~flag$ ~EQ ~ON
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, throw a NoModificationAllowedError exception and terminate these steps.
</li>
			<li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
				<ol>
					<li>
%property ~LET %property を`~ASCII小文字~化$した結果
◎
Let property be property converted to ASCII lowercase.
</li>
					<li>
~IF［
%property は `~supportされる~CSS~prop$でない
］
⇒
~RET
◎
If property is not a case-sensitive match for a supported CSS property, terminate this algorithm.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%value ~EQ 空~文字列
］：
</p>
				<ol>
					<li>
( %property ) を引数に 此れ上の `removeProperty()$m を呼出す
</li>
					<li>
~RET
</li>
				</ol>
◎
If value is the empty string, invoke removeProperty() with property as argument and terminate this algorithm.
</li>
			<li>
~IF［
%priority ~NIN `~ACI$ {  空~文字列, `important^l }
］
⇒
~RET
◎
If priority is not the empty string and is not an ASCII case-insensitive match for the string "important", terminate this algorithm.
</li>
			<li>
<p>
%成分値~list ~LET
`~CSS値として構文解析する$( %value, %property )
◎
Let component value list be the result of parsing value for property property.
</p>

<p class="note">注記：
%value は `!important^l を含み得ない。
◎
Note: value can not include "!important".
</p>

			</li>
			<li>
~IF［
%成分値~list ~EQ ~NULL
］
⇒
~RET
◎
If component value list is null terminate these steps.
</li>
			<li>
%~important~flag ~LET ［
%priority ~NEQ 空~文字列ならば ~ON ／
~ELSE_ ~OFF
］
◎
↓</li>
			<li>
~IF［
%property はある`略式~prop$の名前である
］
⇒
%property に対応する ~EACH ( `下位prop$ %下位prop ) に対し, `正準的~順序$で
⇒
次を与える下で，`~CSS宣言を設定する$
⇒＃
此れの`宣言列$,
%下位prop,
%成分値~list 内の %下位prop を成す部分,
%~important~flag
◎
If property is a shorthand property, then for each longhand property longhand that property maps to, in canonical order, set the CSS declaration longhand with the appropriate value(s) from component value list, with the important flag set if priority is not the empty string, and unset otherwise, and with the list of declarations being the declarations.
</li>
			<li>
~ELSE
⇒
次を与える下で，`~CSS宣言を設定する$
⇒＃
此れの`宣言列$,
%property,
%成分値~list,
%~important~flag
◎
Otherwise, set the CSS declaration property with value component value list, with the important flag set if priority is not the empty string, and unset otherwise, and with the list of declarations being the declarations.
</li>
		</ol>
	</dd>
	<dd>

<p class="algo-head">
`~CSS宣言を設定する@
ときは、所与の
( %宣言~list, %~prop名, %成分値~list, %~important~flag )
に対し，次を走らす：
◎
To set a CSS declaration property with a value component value list and optionally with an important flag set, in a list of declarations declarations, follow these steps:
</p>

		<ol>
			<li>
~IF［
%宣言~list 内に［
`~prop名$ ~EQ %~prop名
］なる`~CSS宣言$はある
］
⇒
%宣言 ~LET その`~CSS宣言$
◎
If property is a case-sensitive match for a property name of a CSS declaration in declarations, let declaration be that CSS declaration.
</li>
			<li>
~ELSE
⇒＃
%宣言 ~LET `~prop名$ %~prop名 を伴う新たな`~CSS宣言$；
%宣言~list に %宣言 を付加する
◎
Otherwise, append a new CSS declaration with the property name property to declarations and let declaration be that CSS declaration.
</li>
			<li>
%宣言 の`値$ ~SET %成分値~list
◎
Set declaration’s value to component value list.
</li>
			<li>
%宣言 の`~important~flag$ ~SET %important
◎
If the important flag is set, set declaration’s important flag. Otherwise, unset declaration’s important flag.
</li>
		</ol>
	</dd>

	<dt>`setPropertyValue(property, value)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setPropertyValue(property, value) method must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの`読専~flag$ ~EQ ~ON
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, throw a NoModificationAllowedError exception and terminate these steps.
</li>
			<li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
				<ol>
					<li>
%property ~LET %property を`~ASCII小文字~化$した結果
◎
Let property be property converted to ASCII lowercase.
</li>
					<li>
~IF［
%property は `~supportされる~CSS~prop$でない
］
⇒
~RET
◎
If property is not a case-sensitive match for a supported CSS property, terminate this algorithm.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%value ~EQ 空~文字列
］：
</p>
				<ol>
					<li>
( %property ) を引数に 此れ上の `removeProperty()$m を呼出す
</li>
					<li>
~RET
</li>
				</ol>
◎
If value is the empty string, invoke removeProperty() with property as argument and terminate this algorithm.
</li>
			<li>
<p>
%成分値~list ~LET
`~CSS値として構文解析する$( %value, %property )
◎
Let component value list be the result of parsing value for property property.
</p>

<p class="note">注記：
%value は `!important^l を含み得ない。
◎
Note: value can not include "!important".
</p>

			</li>
			<li>
~IF［
%成分値~list ~EQ ~NULL
］
⇒
~RET
◎
If component value list is null terminate these steps.
</li>
			<li>
~IF［
%property はある`略式~prop$の名前である
］
⇒
%property に対応する ~EACH ( `下位prop$ %下位prop ) に対し, `正準的~順序$で
⇒
`~CSS宣言の値を設定する$( 此れの`宣言列$, %下位prop, %成分値~list 内の %下位prop を成す部分 )
◎
If property is a shorthand property, then for each longhand property longhand that property maps to, in canonical order, set the CSS declaration value longhand to the appropriate value(s) from component value list, and with the list of declarations being the declarations.
</li>
			<li>
~ELSE
⇒
`~CSS宣言の値を設定する$( 此れの`宣言列$, %property, %成分値~list )
◎
Otherwise, set the CSS declaration value property to the value component value list, and with the list of declarations being the declarations.
</li>
		</ol>
	</dd>
	<dd>

<p class="algo-head">
`~CSS宣言の値を設定する@
ときは、所与の
( %宣言~list, %~prop名, %成分値~list )
に対し，次を走らす：
◎
To set a CSS declaration value to a value component value list in a list of declarations declarations, follow these steps:
</p>

		<ol>
			<li>
~IF［
%宣言~list 内に［
`~prop名$ ~EQ %~prop名
］なる`~CSS宣言$はある
］
⇒
%宣言 ~LET その`~CSS宣言$
◎
If property is a case-sensitive match for a property name of a CSS declaration in declarations, let declaration be that CSS declaration.
</li>
			<li>
~ELSE
⇒＃
%宣言 ~LET `~prop名$ %~prop名 を伴う新たな`~CSS宣言$；
%宣言~list に %宣言 を付加する
◎
Otherwise, append a new CSS declaration with the property name property to declarations and let declaration be that CSS declaration.
</li>
			<li>
%宣言 の`値$ ~SET %成分値~list
◎
Set declaration’s value to component value list.
</li>
		</ol>
	</dd>

	<dt>`setPropertyPriority(property, priority)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setPropertyPriority(property, priority) method must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの`読専~flag$ ~EQ ~ON
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, throw a NoModificationAllowedError exception and terminate these steps.
</li>
			<li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
				<ol>
					<li>
%property ~LET %property を`~ASCII小文字~化$した結果
◎
Let property be property converted to ASCII lowercase.
</li>
					<li>
~IF［
%property は`~supportされる~CSS~prop$でない
］
⇒
~RET
◎
If property is not a case-sensitive match for a supported CSS property, terminate this algorithm.
</li>
				</ol>
			</li>
			<li>
~IF［
%priority ~NIN `~ACI$ { 空~文字列, `important^l }
］
⇒
~RET
◎
If priority is not the empty string and is not an ASCII case-insensitive match for the string "important", terminate this algorithm.
</li>
			<li>
%~important~flag ~LET ［
%priority ~NEQ 空~文字列ならば ~ON ／
~ELSE_ ~OFF
］
◎
↓</li>
			<li>
~IF［
%property は ある`略式~prop$の名前である
］
⇒
%property に対応する ~EACH ( `下位prop$ %下位prop ) に対し, `正準的~順序$で
⇒
`~CSS宣言の優先度を設定する$( 此れの`宣言列$, %下位prop, %~important~flag )
◎
If property is a shorthand property, then for each longhand property longhand that property maps to, in canonical order, set the CSS declaration priority longhand with the important flag set if priority is not the empty string, and unset otherwise, and with the list of declarations being the declarations.
</li>
			<li>
~ELSE
⇒
`~CSS宣言の優先度を設定する$( 此れの`宣言列$, %property, %~important~flag )
◎
Otherwise, set the CSS declaration priority property with the important flag set if priority is not the empty string, and unset otherwise, and with the list of declarations being the declarations.
</li>
		</ol>
	</dd>
	<dd>
<p class="algo-head">
`~CSS宣言の優先度を設定する@
ときは、所与の
( %宣言~list, %~prop名, %~important~flag )
に対し，次を走らす：
◎
To set a CSS declaration priority property optionally with an important flag set, in a list of declarations declarations, follow these steps:
</p>

		<ol>
			<li>
~IF［
%宣言~list 内に［
`~prop名$ ~EQ %~prop名
］なる`~CSS宣言$はある
］
⇒
その`~CSS宣言$の`~important~flag$ ~SET %important
◎
If property is a case-sensitive match for a property name of a CSS declaration in declarations, let declaration be that CSS declaration.
◎
Otherwise, terminate these steps.
◎
If the important flag is set, set declaration’s important flag. Otherwise, unset declaration’s important flag.
</li>
		</ol>
	</dd>

	<dt>`removeProperty(property)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeProperty(property) method must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの`読専~flag$ ~EQ ~ON
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, throw a NoModificationAllowedError exception and terminate these steps.
</li>
			<li>
~IF［
%property は`~custom~prop名$でない
］
⇒
%property ~SET %property を`~ASCII小文字~化$した結果
◎
If property is not a custom property, let property be property converted to ASCII lowercase. 
</li>
			<li>
%値 ~LET
( %property ) を引数に 此れ上の `getPropertyValue()$m を呼出した結果
◎
Let value be the return value of invoking getPropertyValue() with property as argument.
</li>
			<li>
~IF［
%property は ある`略式~prop$の名前である
］
⇒
%property に対応する ~EACH ( `下位prop$ %下位prop ) に対し <!-- $ canonical-orderで -->
⇒
( %下位prop ) を引数に 此れ上の `removeProperty()$m を呼出す
◎
If property is a shorthand property, for each longhand property longhand that property maps to, invoke removeProperty() with longhand as argument.
</li>
			<li>
此れの`宣言列$から，［
`~prop名$ ~EQ %property
］なる`~CSS宣言$を（もしあれば）除去する
◎
Otherwise, if property is a case-sensitive match for a property name of a CSS declaration in the declarations, remove that CSS declaration.
</li>
			<li>
~RET %値
◎
Return value.
</li>
		</ol>
	</dd>

	<dt>`parentRule@m</dt>
	<dd>
取得子は、此れの`親~CSS規則$を返さ~MUST。
◎
The parentRule attribute must return the parent CSS rule.
</dd>

	<dt>`cssFloat@m</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
( `float^l ) を引数に 此れ上の `getPropertyValue()$m を呼出した結果
◎
The cssFloat attribute, on getting, must return the result of invoking getPropertyValue() with float as argument.＼
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
次を引数に 此れ上の `setProperty()$m を呼出す（例外は再投出する）
⇒
( `float^l, 所与の値 )
（ 3 個目の引数は省略する）
◎
On setting, the attribute must invoke setProperty() with float as first argument, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</dd>
</dl>

<p>
`~supportされる~CSS~prop$に含まれる各~propに対し、次の部分的~ifcが適用される。
ここで， ~camel_cased_attr は、次の結果で与えられる名前とする
⇒
`~IDL属性~名に変換する$( その~prop名 )
◎
For each CSS property property that is a supported CSS property, the following partial interface applies where camel-cased attribute is obtained by running the CSS property to IDL attribute algorithm for property.
</p>

<pre class="idl">
partial interface `CSSStyleDeclaration$I {
  [`CEReactions$] attribute [`TreatNullAs$=EmptyString] `CSSOMString$ _`~camel_cased_attr$m;
};
</pre>


<p class="trans-note">【
~IDLにおける先頭の ❝_ は、属性の識別子の一部ではなく，~IDL構文の一部（~escape）であることに注意。
】</p>


<dl class="idl-def">
	<dt>`~camel_cased_attr@m</dt>
	<dd>
<p>
取得子は、次の結果を返さ~MUST
⇒
次を引数に 此れ上の `getPropertyValue()$m を呼出す
⇒
( `~CSS~prop名に変換する$( この属性の名前 ) )
◎
The camel-cased attribute attribute, on getting, must return the result of invoking getPropertyValue() with the argument being the result of running the IDL attribute to CSS property algorithm for camel-cased attribute.
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
次を引数に 此れ上の `setProperty()$m を呼出す（例外は再投出する）
⇒
( `~CSS~prop名に変換する$( この属性の名前 ), 所与の値 )
（ 3 個目の引数は省略する）
◎
Setting the camel-cased attribute attribute must invoke setProperty() with the first argument being the result of running the IDL attribute to CSS property algorithm for camel-cased attribute, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</dd>
	<dd class="example">
例えば `font-size$p ~propに対しては， `fontSize^m ~IDL属性が在ることになる。
◎
For example, for the font-size property there would be a fontSize IDL attribute.
</dd>
</dl>

<p>
~propのうち［
`~supportされる~CSS~prop$である
］~AND［
その名前の頭部は文字列 `-webkit-^l に一致する
］ものには、次の部分的~ifcが適用される。
ここで， ~webkit_cased_attr は、次の結果で与えられる名前とする
⇒
`~IDL属性~名に変換する$( その~propの名前, %小文字先頭~flag ~SET ~ON )
◎
For each CSS property property that is a supported CSS property and that begins with the string -webkit-, the following partial interface applies where webkit-cased attribute is obtained by running the CSS property to IDL attribute algorithm for property, with the lowercase first flag set.
</p>

<pre class="idl">
partial interface `CSSStyleDeclaration$I {
  [`CEReactions$] attribute [`TreatNullAs$=EmptyString] `CSSOMString$ _`~webkit_cased_attr$m;
};
</pre>


<dl class="idl-def">
	<dt>`~webkit_cased_attr@m</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
( 下に与える %属性~名 )
を引数に 此れ上の `getPropertyValue()$m を呼出す
◎
The webkit-cased attribute
attribute, on getting, must return the result of invoking getPropertyValue() with the argument being the result of running the IDL attribute to CSS property algorithm for webkit-cased attribute, with the dash prefix flag set.
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
次を引数に 此れ上の `setProperty()$m を呼出す（例外は再投出する）
⇒
( 下に与える %属性~名, 所与の値 )
（ 3 個目の引数は省略する）
◎
Setting the webkit-cased attribute attribute must invoke setProperty() with the first argument being the result of running the IDL attribute to CSS property algorithm for webkit-cased attribute, with the dash prefix flag set, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</dd>
	<dd>
ここでの %属性~名 は、次の結果で与えられるとする
⇒
`~CSS~prop名に変換する$( この属性の名前, %接頭dash~flag ~SET ~ON )
◎
↑</dd>
	<dd class="example">
例えば，~UAが `-webkit-transform^p ~propを~supportするならば、
`webkitTransform^m ~IDL属性が在ることになる。
`~camel_cased_attr$m 属性に対する規則により，
`WebkitTransform^m ~IDL属性も在ることになる。
◎
For example, if the user agent supports the -webkit-transform property, there would be a webkitTransform IDL attribute. There would also be a WebkitTransform IDL attribute because of the rules for camel-cased attributes.
</dd>
</dl>


<p>
［
`~supportされる~CSS~prop$であって，かつ
~prop名に ❝- が含まれる
］ような，各  %~prop に対しては、次の部分的~ifcが適用される
— ここで，~dashed_attr は その %~prop の名前とする：
◎
For each CSS property property that is a supported CSS property, except for properties that have no "-" (U+002D) in the property name, the following partial interface applies where dashed attribute is property.
</p>


<pre class="idl">
partial interface `CSSStyleDeclaration$I {
  [`CEReactions$] attribute [`TreatNullAs$=EmptyString] `CSSOMString$ _`~dashed_attr$m;
};
</pre>


<dl class="idl-def">
	<dt>`~dashed_attr@m</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
( この属性の名前 )
を引数に 此れ上の `getPropertyValue()$m を呼出す
◎
The dashed attribute attribute, on getting, must return the result of invoking getPropertyValue() with the argument being dashed attribute.
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
次を引数に 此れ上の `setProperty()$m を呼出す（例外は再投出する）
⇒
( この属性の名前, 所与の値 )
（ 3 個目の引数は省略する）
◎
Setting the dashed attribute attribute must invoke setProperty() with the first argument being dashed attribute, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</dd>
	<dd class="example">
<p>
例えば `font-size$p ~propに対しては、 ~IDL属性 `font-size^m が在ることになる。
JavaScript においては、 %要素 を
<a href="~HTMLINFRA#html-elements">HTML 要素</a>
とするとき，この~propは 次の様に~accessできる：
◎
For example, for the 'font-size' property there would be a font-size IDL attribute. In JavaScript, the property can be accessed as follows, assuming element is an HTML element:
</p>

<pre class="lang-js">
%要素.style['font-size'];
</pre>
	</dd>
</dl>

<p class="algo-head">
`~IDL属性~名に変換する@
~algoは、所与の
( %~prop名, %小文字先頭~flag （省略時は ~OFF） )
に対し，次に従う：
◎
The CSS property to IDL attribute algorithm for property, optionally with a lowercase first flag set, is as follows:
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
%次~大文字~化 ~LET ~F
◎
Let uppercase next be unset.
</li>
	<li>
~IF［
%小文字先頭~flag ~EQ ~ON
］
⇒
%~prop名 から最初の文字を除去する
◎
If the lowercase first flag is set, remove the first character from property. </li>
	<li>
<p>
%~prop名 内の~EACH ( 文字 %c ) に対し：
◎
For each character c in property:
</p>
		<ol>
			<li>
~IF［
%c ~EQ ❝-
］
⇒
%次~大文字~化 ~SET ~T
◎
If c is "-" (U+002D), let uppercase next be set.
</li>
			<li>
~ELIF［
%次~大文字~化 ~EQ ~T
］
⇒＃
%次~大文字~化 ~SET ~F；
%出力 ~APPEND［ %c を`~ASCII大文字~化$した結果 ］
◎
Otherwise, if uppercase next is set, let uppercase next be unset and append c converted to ASCII uppercase to output.
</li>
			<li>
~ELSE
⇒
%出力
~APPEND %c
◎
Otherwise, append c to output.
</li>
		</ol>

	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="algo-head">
`~CSS~prop名に変換する@
~algoは、所与の
( %~IDL属性~名, %接頭dash~flag （省略時は ~OFF ）)
に対し，次に従う：
◎
The IDL attribute to CSS property algorithm for attribute, optionally with a dash prefix flag set, is as follows:
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
				<li>
~IF［
%接頭dash~flag ~EQ ~ON
］
⇒
%出力
~APPEND ❝-
◎
If the dash prefix flag is set, append "-" (U+002D) to output.
</li>
	<li>
<p>
%~IDL属性~名 内の~EACH ( 文字 %c ) に対し：
◎
For each character c in attribute:
</p>
		<ol>
			<li>
~IF［
%c ~IN { ❝A 〜 ❝Z }
］
⇒＃
%出力 ~APPEND ❝-
~APPEND %c を`~ASCII小文字~化$した結果
◎
If c is in the range U+0041 to U+005A (ASCII uppercase), append "-" (U+002D) followed by c converted to ASCII lowercase to output.
</li>
			<li>
~ELSE
⇒
%出力
~APPEND %c
◎
Otherwise, append c to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

			</section>
		</section>
		<section id="css-values">
<h3 title="CSS Values">6.7. ~CSS値</h3>

			<section id="parsing-css-values">
<h4 title="Parsing CSS Values">6.7.1. ~CSS値の構文解析法</h4>

<p class="algo-head">
`~CSS値として構文解析する@
ときは、所与の
( %値, %~prop名 )
に対し，次を走らす：
◎
To parse a CSS value value for a given property means to follow these steps:
</p>

<ol>
	<li>
%~list ~LET
%値 から
<a href="~CSSSYN#parse-a-list-of-component-values">成分値~listを構文解析-</a>
した結果
◎
Let list be the value returned by invoking parse a list of component values from value.
</li>
	<li>
~IF［
%~list は~CSS仕様の［
名前 %~prop名 の~prop
］の文法に合致する
］
⇒
~RET %~list
◎
Match list against the grammar for the property property in the CSS specification.
</li>
	<li>
~RET ~NULL
◎
If the above step failed, return null.
◎
Return list.
</li>
</ol>


<p class="note">注記：
`!important^l 宣言は、~propの値~空間の一部を成さないので，
`~CSS値として構文解析する$
の結果は~NULLになる。
◎
Note: "!important" declarations are not part of the property value space and will therefore cause parse a CSS value to return null.
</p>

			</section>
			<section id="serializing-css-values">
<h4 title="Serializing CSS Values">6.7.2. ~CSS値の直列化-法</h4>


<p class="algo-head">
<!-- `略式~prop$ %略式~prop に対応する ＊-->
`下位prop~listを直列化する@
ときは、所与の
( `下位prop$の`~CSS宣言$からなる~list %~list )
に対し，次を走らす：
◎
To serialize a CSS value of a CSS declaration declaration or a list of longhand CSS declarations list, follow these rules:
◎
If this algorithm is invoked with a list list, follow these substeps:
</p>

<p class="trans-note">【
原文では後述の
`~CSS値を直列化する$ ~algoと一緒にされて定義されているが、入力と処理内容が別物なので，この訳では 2 つに分割している。
】</p>

<ol>
	<li>
%略式~prop ~LET %~list の中のすべての`下位prop$に正確に対応する`略式~prop$
— そのような %略式~prop が複数ある場合
<span class="trans-note">【具体例？】</span>
は
`選好順$において先に来るものを選ぶ
◎
Let shorthand be the shorthand property that exactly maps to all the longhand properties in list. If there are multiple such shorthand properties, use the first in preferred order.
</li>
	<li>
<p>
~IF［
%略式~prop は その文法の下で %~list の一連の値を表現できない
］
⇒
~RET 空~文字列
◎
If shorthand cannot represent the values of list in its grammar, return the empty string and terminate these steps.
</p>
<p class="trans-note">【
例えば %~list の中の各~宣言に対する !important の有無が統一されていない場合は？
（空~文字列が返される？）。
】</p>

</li>
	<li>
%省略済~list ~LET 空~list
◎
Let trimmed list be a new empty array.
</li>
	<li>
%~list 内の~EACH ( `~CSS宣言$ %宣言 ) に対し
⇒
~IF［
%宣言 の`値$ ~NEQ `初期値$ ~OR
%宣言 は %略式~prop の必須の成分である
］
⇒
%省略済~list に %宣言 を付加する
◎
For each CSS declaration declaration in list, if declaration’s value is not the initial value, or if declaration is a required component of the shorthand property, append declaration to trimmed list.
</li>
	<li>
~IF［
%省略済~list は空である
］
⇒
%省略済~list に［
%~list 内の最初の~itemの値
］を付加する
◎
If trimmed list is empty, append the value of the first item in list to trimmed list.
</li>
	<li>
%値~list ~LET 空~list
◎
Let values be a new empty array.
</li>
	<li>
%省略済~list 内の~EACH ( `~CSS宣言$ %宣言 ) に対し
⇒
%値~list に次の結果を付加する
⇒
`~CSS値を直列化する$( %宣言 )
◎
For each CSS declaration declaration in trimmed list, invoke serialize a CSS value of declaration, and append the result to values.
</li>
	<li>
~RET %値~list を %略式~prop の文法に従って適切に連結した結果
◎
Return the result of joining values as appropriate according to the grammar of shorthand and terminate these steps.
</li>
</ol>

<p class="algo-head">
`~CSS値を直列化する@
ときは、所与の
( `~CSS宣言$ %宣言, その`値$ %値 )
に対し，次を走らす：
◎
↑</p>

<ol>
	<li>
%値~list ~LET 空~list
◎
Let values be a new empty array.
</li>
	<li>
%値 内の~EACH( %成分 ) に対し
⇒
%値~list に次の結果を付加する
⇒
`~CSS成分値を直列化する$( %成分 )
◎
Append the result of invoking serialize a CSS component value of declaration’s value to values.
</li>
	<li>
~IF［
%宣言 の`~prop名$の文法は空白~区切りとして定義されている
］
⇒
~RET `空白~区切りで直列化する$( %値~list )
◎
If the grammar of the property name of declaration is defined to be whitespace-separated, return the result of invoking serialize a whitespace-separated list of values and terminate these steps.
</li>
	<li>
~IF［
%宣言 の`~prop名$の文法は~comma区切りとして定義されている
］
⇒
~RET `~comma区切りで直列化する$( %値~list )
◎
If the grammar of the property name of declaration is defined to be comma-separated, return the result of invoking serialize a comma-separated list of values.
</li>
</ol>


<p class="algo-head">
`~CSS成分値を直列化する@
ときは、所与の %値 に対し，その型に応じて 次に従う：
◎
To serialize a CSS component value depends on the component, as follows:
</p>

<dl class="switch">
	<dt>keyword値</dt>
	<dd>
~RET %値 を`~ASCII小文字~化$した結果
◎
The keyword converted to ASCII lowercase.
</dd>

	<dt>`angle$t</dt>
	<dd>
~RET 次の結果
⇒＃
%値 の `number^t 成分を `number^t として直列化した結果
~APPEND %値 の単位を表す 当該の仕様にて定義される正準形の文字列
◎
The &lt;number&gt; component serialized as per &lt;number&gt; followed by the unit in canonical form as defined in its respective specification.
</dd>

	<dt>`color$t</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
%値 は`解決値$または`算出値$の成分である
］：
◎
If &lt;color&gt; is a component of a resolved or computed value, then return the color using the rgb() or rgba() functional notation as follows:
</p>

<p>
（これは `rgb()^l ／ `rgba()^l 関数記法による直列化を与える）
◎
If the alpha component of the color is equal to one, then return the serialization of the rgb() functional equivalent of the opaque color.
◎
If the alpha component of the color is not equal to one, then return the serialization of the rgba() functional equivalent of the non-opaque color.
◎
The serialization of the rgb() functional equivalent is the concatenation of the following:
</p>
				<ol>
					<li>
%alpha ~LET %値 が表現する色の alpha 成分
</li>
					<li>
%結果 ~LET ［
%alpha ~EQ 1 （不透明）ならば `rgb(^l ／ ~ELSE_ `rgba(^l
］
◎
The string "rgb(".
◎
The shortest base-ten integer serialization of the color’s red component.
◎
The string ", ".
◎
The shortest base-ten serialization of the color’s green component.
◎
The string ", ".
◎
The shortest base-ten serialization of the color’s blue component.
◎
The string ")".
◎
The serialization of the rgba() functional equivalent is the concatenation of the following:
◎
The string "rgba(".
</li>
					<li>
%RGB ~LET %値 が表現する色の
( red, green, blue )
成分【 0 〜 255 の整数】
を，順に 最短の基数10整数 に直列化して得られる長さ 3 の~list
◎
The shortest base-ten serialization of the color’s red component.
◎
The string ", ".
◎
The shortest base-ten serialization of the color’s green component.
◎
The string ", ".
◎
The shortest base-ten serialization of the color’s blue component.
</li>
					<li>
~IF［
%alpha ~NEQ 1
］
⇒
%RGB に［
%alpha を `alphavalue^t として直列化した結果
］を付加する
◎
The string ", ".
◎
The serialization of the color’s alpha component as an &lt;alphavalue&gt;.
</li>
					<li>
~RET %結果
~APPEND `~comma区切りで直列化する$( %RGB )
~APPEND ❝)
◎
The string ")".
◎
In the above rules, the string ", " denotes a COMMA (U+002C) followed by a single SPACE (U+0020).
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %値 は`指定値$の成分である）：
◎
If &lt;color&gt; is a component of a specified value, then return the color as follows:
</p>
				<ol>
					<li>
~IF［
%値 が表現する色は 作者により明示的に指定されたものである
］
⇒
~RET 作者により指定された元の（文字列としての）色~値
◎
If the color was explicitly specified by the author, then return the original, author specified color value.
</li>
					<li>
~RET `算出値$の成分であったとしたときに返されることになる値
◎
Otherwise, return the value that would be returned if the color were a component of a computed value.
</li>
				</ol>

<p class="issue">
作者による`指定値$における文字大小は、正規化すべきか？
あるいは，保全されるべきか？
◎
Should author specified values be normalized for case? Or should original case be preserved?
</p>
			</li>
		</ol>
	</dd>

	<dt>`alphavalue^t</dt>
	<dd>
<p>
~IF［
%値 は内部的に 0 〜 255 の範囲の整数（すなわち， 8-bit 符号なし整数）として表現されている
］：
◎
If the value is internally represented as an integer between 0 and 255 inclusive (i.e. 8-bit unsigned integer), follow these steps:
</p>
			<ol>
				<li>
%alpha ~LET その整数
◎
Let alpha be the given integer.
</li>
				<li>
~IF［
0 〜 100 の範囲の整数のうち, ［［
2.55 倍してから最も近い整数に丸めた結果（二数が等距離にある場合は切り上げる）
］ ~EQ %alpha
］になるものがある
］
⇒
%rounded ~LET その整数 ÷ 100
◎
If there exists an integer between 0 and 100 inclusive that, when multiplied with 2.55 and rounded to the closest integer (rounding up if two values are equally close), equals alpha, let rounded be that integer divided by 100.
</li>
				<li>
~ELSE
⇒
%rounded ~LET %alpha ÷ 0.255 を最も近い整数に丸めた結果（二数が等距離にある場合は切り上げる） ÷ 1000
◎
Otherwise, let rounded be alpha divided by 0.255 and rounded to the closest integer (rounding up if two values are equally close), divided by 1000.
</li>
				<li>
~RET %rounded を `number^t として直列化した結果
◎
Return the result of serializing rounded as a &lt;number&gt;.
</li>
			</ol>

<p>
~RET %値 を `number^t として直列化した結果
◎
Otherwise, return the result of serializing the given value as a &lt;number&gt;.
</p>
	</dd>

	<dt>`counter^t</dt>
	<dd>
		<ol>
			<li>
%~list ~LET %値 を成す一連の~CSS成分値からなる~list
◎
↓</li>
			<li>
%結果 ~LET %~list 内の~item数に応じて
⇒＃
3 個ならば `counters(^l ／
2 個ならば `counter(^l
◎
The return value of the following algorithm:
◎
Let s be the empty string.
◎
If &lt;counter&gt; has three CSS component values append the string "counters(" to s.
◎
If &lt;counter&gt; has two CSS component values append the string "counter(" to s.
◎
Let list be a list of CSS component values belonging to &lt;counter&gt;,＼
</li>
			<li>
~IF［
%~list 内の最後の~item ~EQ `decimal^l
］
⇒
%~list から最後の~itemを除去する
◎
omitting the last CSS component value if it is "decimal".
</li>
			<li>
%~list ~SET %~list 内の各~itemに
`~CSS成分値を直列化する$を適用して得られる同順の~list
</li>
			<li>
~RET 
%結果
~APPEND `~comma区切りで直列化する$( %~list )
~APPEND ❝)
◎
Let each item in list be the result of invoking serialize a CSS component value on that item.
◎
Append the result of invoking serialize a comma-separated list on list to s.
◎
Append ")" (U+0029) to s.
◎
Return s. 
</li>
		</ol>
	</dd>

	<dt>`frequency$t</dt>
	<dd>
~RET 次の結果
⇒＃
%値 が表現する hertz 単位の周波数を `number^t として直列化した結果
~APPEND `hz^l
◎
The frequency in hertz serialized as per &lt;number&gt; followed by the literal string "hz".
</dd>

	<dt>`identifier$t</dt>
	<dd>
~RET 次の結果
⇒
`識別子を直列化する$( %値 )
◎
The identifier serialized as an identifier.
</dd>

	<dt>`integer$t</dt>
	<dd>
~RET 次の結果
⇒＃
%値 は負ならば ❝- ／ ~ELSE_ 空~文字列
~APPEND［%値 を表す  ❝0 〜 ❝9 を用いた最短形の基数10整数 ］
◎
A base-ten integer using digits 0-9 (U+0030 to U+0039) in the shortest form possible, preceded by "-" (U+002D) if it is negative.
</dd>

	<dt>`length$t</dt>
	<dd>
		<ol>
			<li>
~IF［
%値 が表す長さ ~EQ 0
］
⇒
~RET `0px^l
◎
A length of zero is represented by the literal string "0px".
</li>
			<li>
<p>
~IF［
%値 は絶対~長さ表す
］
⇒
~RET 次の結果
⇒＃
長さが表現する millimeter 単位による数を `number^t として直列化した結果
~APPEND `mm^l
◎
Absolute lengths: the number of millimeters serialized as per &lt;number&gt; followed by the literal string "mm".
</p>

<p class="issue">
Rumor has it absolute lengths will become relative lengths. Centimeters would be compatible with &lt;resolution&gt;...
<span class="trans-note">【？】</span>
</p>
			</li>
			<li>
~IF［
%値 は相対~長さ表す
］
⇒
~RET 次の結果
⇒＃
長さの `number^t 成分を `number^t として直列化した結果
~APPEND 当該の仕様にて定義される単位を表す正準形の文字列
◎
Relative lengths: the &lt;number&gt; component serialized as per &lt;number&gt; followed by the unit in its canonical form as defined in its respective specification.
</li>
		</ol>
	</dd>

	<dt>`number$t</dt>
	<dd>
<p>
~RET %値 を表す ❝0 〜 ❝9 を用いた最短形の基数10数
— 小数部がある場合は ❝. で区切った上で，
【小数部が？】
6 桁を超えるときは値を丸め、負の場合は ❝- を前置する
◎
A base-ten number using digits 0-9 (U+0030 to U+0039) in the shortest form possible, using "." to separate decimals (if any), rounding the value if necessary to not produce more than 6 decimals, preceded by "-" (U+002D) if it is negative.
</p>

<p class="note">注記：
科学的記数法は利用されない。
◎
Note: scientific notation is not used.
</p>
	</dd>

	<dt>`percentage$t</dt>
	<dd>
~RET 次の結果
⇒＃
%値 の `number^t 成分を `number^t として直列化した結果
~APPEND ❝%
◎
The &lt;number&gt; component serialized as per &lt;number&gt; followed by the literal string "%" (U+0025).
</dd>

	<dt>`resolution$t</dt>
	<dd>
~RET 次の結果
⇒＃
%値 が表現する， 1 `~CSS~pixel$あたりの~dot数による解像度を `number^t として直列化した結果
~APPEND `dppx^l
◎
The resolution in dots per CSS pixel serialized as per &lt;number&gt; followed by the literal string "dppx".
</dd>

	<dt>`shape$t</dt>
	<dd>
~RET 次の結果
⇒＃
`rect(^l
~APPEND `~comma区切りで直列化する$( %値 を成す各 ~CSS成分値に`~CSS成分値を直列化する$を適用して得られる同順の~list )
~APPEND ❝)
◎
The return value of the following algorithm:
• Let s be the string "rect(".
• Let list be a list of the CSS component values belonging to &lt;shape&gt;.
• Let each item in list be the result of invoking serialize a CSS component value of that item.
• Append the result of invoking serialize a comma-separated list on list to s.
• Append ")" (U+0029) to s.
• Return s.
</dd>

	<dt>`string$t</dt>
	<dt>`family-name$t</dt>
	<dt>`specific-voice^t</dt>
	<dd>
~RET 次の結果
⇒
`文字列を直列化する$( %値 )
◎
The string serialized as a string. 
</dd>

	<dt>`time$t</dt>
	<dd>
~RET 次の結果
⇒＃
［%値 が表現する秒~単位による数］を `number^t として直列化した結果
~APPEND ❝s
◎
The time in seconds serialized as per &lt;number&gt; followed by the literal string "s".
</dd>

	<dt>`uri$t</dt>
	<dd>
~RET `~CSS~URLに直列化する$( %値 が与える`絶対~URL文字列$ )
◎
The absolute-URL string serialized as URL.
</dd>
</dl>

<p>
`absolute-size^t, `border-width^t, `border-style^t, `bottom^t, `generic-family^t, `generic-voice^t, `left^t, `margin-width^t, `padding-width^t, `relative-size^t, `right^t, `top^t
は、この仕様では~macroと見なされる。
これらはすべて上に示された成分の~instanceを表現する。
◎
&lt;absolute-size&gt;, &lt;border-width&gt;, &lt;border-style&gt;, &lt;bottom&gt;, &lt;generic-family&gt;, &lt;generic-voice&gt;, &lt;left&gt;, &lt;margin-width&gt;, &lt;padding-width&gt;, &lt;relative-size&gt;, &lt;right&gt;, and &lt;top&gt;, are considered macros by this specification. They all represent instances of components outlined above.
</p>

<p class="issue">
この節を除去することも考えられる —
上の定義をその~CSS成分を定義する CSS3／CSS4 の過程のどこかの草案に移行させることにより。
◎
One idea is that we can remove this section somewhere in the CSS3/CSS4 timeline by moving the above definitions to the drafts that define the CSS components.
</p>

				<section id="examples-0">
<h5 title="Examples">6.7.2.1. 用例集</h5>

<p>
ここに、指定値<!-- specified-value -->に対する処理の前後の結果を示す，いくつかの例を挙げる：
“処理前” の列は 作者が~ssに記したものを表し,
“処理後” の列は~DOMが返すことになる値を表す。
◎
Here are some examples of before and after results on specified values. The before column could be what the author wrote in a style sheet, while the after column shows what querying the DOM would return.
</p>

<div class="example">

<table><thead><tr><th>処理前◎ Before
<th>処理後◎ After
</thead>

<tbody><tr><td>`background: none^css
<td>`background: rgba(0, 0, 0, 0)^css

<tr><td>`outline: none^css
<td>`outline: invert^css

<tr><td>`border: none^css
<td>`border: medium^css

<tr><td>`list-style: none^css
<td>`list-style: disc^css

<tr><td>`margin: 0 1px 1px 1px^css
<td>`margin: 0px 1px 1px^css

<tr><td>`azimuth: behind left^css
<td>`azimuth: 220deg^css

<tr><td>`font-family: a, 'b"', serif^css
<td>`font-family: "a", "b\"", serif^css

<tr><td>`content: url('h)i') '\[\]'^css
<td>`content: url("h)i") "[]"^css

<tr><td>`azimuth: leftwards^css
<td>`azimuth: leftwards^css

<tr><td>`color: rgb(18, 52, 86)^css
<td>`color: #123456^css

<tr><td>`color: rgba(000001, 0, 0, 1)^css
<td>`color: #000000^css

</tbody></table>

<p class="issue">
これらの一部は新たな規則で更新される必要がある。
◎
Some of these need to be updated per the new rules.
</p>
</div>

				</section>
			</section>
		</section>
	</section>
	<section id="dom-access-to-css-declaration-blocks">
<h2 title="DOM Access to CSS Declaration Blocks">7. ~CSS宣言~blockへの~DOM~access</h2>

		<section id="the-elementcssinlinestyle-interface">
<h3 title="The ElementCSSInlineStyle Interface">7.1. `ElementCSSInlineStyle^I ~ifc</h3>

<p>
`ElementCSSInlineStyle$I
~ifcは、要素の~inline  ~style~propへの~accessを提供する。
◎
The ElementCSSInlineStyle interface provides access to inline style properties of an element.
</p>

<pre class="idl">
[`Exposed$=Window,
`NoInterfaceObject$]
interface `ElementCSSInlineStyle@I {
  [`SameObject$, `PutForwards$=cssText] ~RA `CSSStyleDeclaration$I `style$m;
};
</pre>

<dl class="idl-def">
	<dt>`style@m</dt>
	<dd>
<p>
取得子は、［
次のようにされた，~live`~CSS宣言~block$
］を返さ~MUST
⇒＃
`読専~flag$ ~SET ~OFF,
`宣言列$ ~SET `~CSS宣言~blockとして構文解析する$( `指定順$による，要素の `style^a 内容~属性の値† ),
`親~CSS規則$ ~SET ~NULL,
`所有者~node$ ~SET 此れ
</p>

<p>
この`宣言列$は：
</p>
		<ul>
			<li>†
`style^a 内容~属性が不在の場合は、空~listとする。
</li>
			<li>
変異したときは、要素の `style^a 内容~属性の値も次の結果にされ~MUST
⇒
`宣言列を直列化する$( この`宣言列$ )
</li>
			<li>
`style^a 内容~属性が
設定-／変更-／除去-
された際には，それに応じて適切に更新され~MUST。
</li>
		</ul>
◎
The style attribute must return a live CSS declaration block with the following properties:
◎
readonly flag
• Unset. 
◎
declarations
• The result of parsing the style content attribute, in specified order. If the style content attribute is absent, the object represents an empty list of CSS declarations. Mutating the declarations must set the style content attribute on the context object to the serialization of the declarations. If the style content attribute is set, changed or removed, the declarations must be updated as appropriate. 
parent CSS rule
• Null. 
owner node
• The context object.
</dd>
</dl>


<p>
~UAが HTML を~supportする場合は，次の~IDLが適用される：
`HTML$r
◎
If the user agent supports HTML, the following IDL applies: [HTML]
</p>

<pre class="idl">
<a href="~HTMLdom#htmlelement">HTMLElement</a> implements `ElementCSSInlineStyle$I;
</pre>

<p>
~UAが~SVGを~supportする場合は，次の~IDLが適用される：
`SVG11$r
◎
If the user agent supports SVG, the following IDL applies: [SVG]
</p>

<pre class="idl">
SVGElement implements `ElementCSSInlineStyle$I;
</pre>


		</section>
		<section id="extensions-to-the-window-interface">
<h3 title="Extensions to the Window Interface">7.2. `Window^I ~ifcに対する拡張</h3>

<pre class="idl">
partial interface `Window@I {
  [`NewObject$] `CSSStyleDeclaration$I `getComputedStyle$m(`Element$I %elt, optional `CSSOMString$? %pseudoElt);
};
</pre>

<dl class="idl-def">
	<dt>`getComputedStyle(elt, pseudoElt)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getComputedStyle(elt, pseudoElt) method must run these steps:
</p>

		<ol>
			<li>
%文書 ~LET 此れに結付けられている`文書$
◎
Let doc be the Document associated with the Window object on which the method was invoked.
</li>
			<li>
%要素 ~LET %elt
◎
Let obj be elt.
</li>
			<li>
~IF［
%pseudoElt ~IN `~ACI$ { `:before^l, `::before^l }
］
⇒
%要素 ~LET %elt の `before$pe 疑似要素
◎
If pseudoElt is as an ASCII case-insensitive match for either ':before' or '::before' let obj be the ::before pseudo-element of elt.
</li>
			<li>
~IF［
%pseudoElt ~IN `~ACI$ { `:after^l, `::after^l }
］
⇒
%要素 ~LET %elt の `after$pe 疑似要素
◎
If pseudoElt is as an ASCII case-insensitive match for either ':after' or '::after' let obj be the ::after pseudo-element of elt.
</li>
			<li>
<p>
~RET 次のようにされた，~live`~CSS宣言~block$
⇒＃
`読専~flag$ ~SET ~ON,
`宣言列$ ~SET 下に与えるもの,
`親~CSS規則$ ~SET ~NULL,
`所有者~node$ ~SET %要素
</p>

<p>
`宣言列$は
⇒
辞書式~順序による，すべての［
`~supportされる~CSS~prop$である`下位prop$
］からなる。
その各~propの値は、 %文書 に結付けられている~style規則を用いて，その~propについて %要素 に対し算出される `解決値$で与えられる。
</p>

<p class="note">注記：
これは、 %要素 が異なる文書に属していても（例えば `XMLHttpRequest^I を通して~fetchされたもの）、［［［
（`~CSS宣言~block$を算出するために）
`getComputedStyle()$m が呼出された大域~obj
］に結付けられている文書
］に結付けられている~style規則
］が用いられることを意味する。
</p>

◎
Return a live CSS declaration block with the following properties:
◎
readonly flag
• Set. 
declarations
• All longhand properties that are supported CSS properties, in lexicographical order, with the value being the resolved value computed for obj using the style rules associated with doc.
• Note: This means that even if obj is in a different document (e.g. one fetched via XMLHttpRequest) it will still use the style rules associated with the document that is associated with the global object on which getComputedStyle() was invoked to compute the CSS declaration block.
parent CSS rule
• Null. 
owner node
• obj. 
</li>
		</ol>
	</dd>
</dl>

<p class="warning">
`getComputedStyle()$m
~methは、`origin-clean ~flag$ss ~EQ ~OFF の下でも，`~CSS~ss$からの情報を公開する。
◎
The getComputedStyle() method exposes information from CSS style sheets with the origin-clean flag unset.
</p>

		</section>
	</section>
	<section id="utility-apis">

<h2 title="Utility APIs">8. ~utility~API</h2>

		<section id="the-css.escape()-method">

<h3 title="The CSS.escape() Method">8.1. `CSS.escape()^m ~meth</h3>

<p>
`CSS$I ~ifcは、他に属さない有用な~CSSに関係する機能を保持する。
◎
The CSS interface holds useful CSS-related functions that do not belong elsewhere.
<!-- 
The CSS interface is defined in CSS Conditional Rules Module. [CSS3-CONDITIONAL]
 -->
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSS@I {
  static `CSSOMString$ `escape$m(`CSSOMString$ %ident);
};
</pre>

<dl class="idl-def">
	<dt>`escape(ident)@m</dt>
	<dd>
この静的~methの被呼出時には、次の結果を返さ~MUST
⇒
`識別子を直列化する$( %ident )
◎
The escape(ident) method must return the result of invoking serialize an identifier of ident.
</dd>

	<dd class="example">
<p>
`escape()$m ~methを利用して直列化すれば、未知の文字列でも，選択子の一部として利用できるようになる：
◎
For example, to serialize a string for use as part of a selector, the escape() method can be used:
</p>

<pre class="lang-js">
var %element = document.querySelector(
  '#' + CSS.escape(%id) + ' &gt; img'
);
</pre>

<p>
厳密には、~escape不要な文字まで~escapeするが：
◎
The escape() method can also be used for escaping strings, although it escapes characters that don’t strictly need to be escaped:
</p>

<pre>
var %element = document.querySelector(
  'a[href="#' + CSS.escape(%fragment) + '"]'
);
</pre>

	</dd>
</dl>

<p>
`CSS$I ~ifc上に静的~関数を定義する仕様は、格納したい状態があるならば、`現在の大域~obj$に`結付けられている文書$に格納するべきである。
◎
Specifications that define static functions on the CSS interface and want to store some state should store the state on the current global object’s associated Document.
</p>

		</section>
	</section>
	<section id="resolved-values">
<h2 title="Resolved Values">9. 解決値</h2>

<p>
`Window!I の `getComputedStyle()$m は、歴史的に，要素や`疑似要素$の “`算出値$” を返すように定義されていた。
しかしながら，配備済みの~scriptとの互換性のために `getComputedStyle()$m の実装は変えるわけにいかない一方で、“`算出値$” の概念は，~CSSの改訂に伴って変化してきている。
この課題に取組むため、この仕様は
`解決値@
の概念を導入する。
◎
getComputedStyle() was historically defined to return the "computed value" of an element or pseudo-element. However, the concept of "computed value" changed between revisions of CSS while the implementation of getComputedStyle() had to remain the same for compatibility with deployed scripts. To address this issue this specification introduces the concept of a resolved value.
</p>

<p class="algo-head">
所与の下位propに対する`解決値$は，~propの種類に応じて次で与えられる：
◎
The resolved value for a given longhand property can be determined as follows:
</p>

<dl class="switch">
	<dt>`background-color$p
	<dt>`border-block-end-color$p
	<dt>`border-block-start-color$p
	<dt>`border-bottom-color$p
	<dt>`border-inline-end-color$p
	<dt>`border-inline-start-color$p
	<dt>`border-left-color$p
	<dt>`border-right-color$p
	<dt>`border-top-color$p
	<dt>`box-shadow$p
	<dt>`caret-color$p
	<dt>`color$p
	<dt>`line-height$p
	<dt>`outline-color$p
	<dt id="resolved-value-special-case-property-like-color">
他の仕様にて［
解決値は `color^p の様に特別
］と定義される~prop
◎
A resolved value special case property like color defined in another specification 
</dt>
	<dd>
`使用値$
◎
The resolved value is the used value.
</dd>

	<dt>`block-size$p</dt>
	<dt>`height$p</dt>
	<dt>`inline-size$p</dt>
	<dt>`margin-block-end$p</dt>
	<dt>`margin-block-start$p</dt>
	<dt>`margin-bottom$p</dt>
	<dt>`margin-inline-end$p</dt>
	<dt>`margin-inline-start$p</dt>
	<dt>`margin-left$p</dt>
	<dt>`margin-right$p</dt>
	<dt>`margin-top$p</dt>
	<dt>`padding-block-end$p</dt>
	<dt>`padding-block-start$p</dt>
	<dt>`padding-bottom$p</dt>
	<dt>`padding-inline-end$p</dt>
	<dt>`padding-inline-start$p</dt>
	<dt>`padding-left$p</dt>
	<dt>`padding-right$p</dt>
	<dt>`padding-top$p</dt>
	<dt>`width$p</dt>
	<dt id="resolved-value-special-case-property-like-height">
他の仕様にて［
解決値は `height^p の様に特別
］と定義される~prop
◎
A resolved value special case property like height defined in another specification
</dt>
	<dd>
<p>
次のいずれも満たされるならば `使用値$ ／
~ELSE_ `算出値$：
</p>

<ul ><li>~propは要素または`疑似要素$に適用されている
</li><li>当の要素~上の `display$p ~propの`解決値$ ~NIN { `none^v, `contents^v }
</li></ul>

◎
If the property applies to the element or pseudo-element and the resolved value of the display property is not none or contents, then the resolved value is the used value. Otherwise the resolved value is the computed value.
</dd>

	<dt>`bottom$p</dt>
	<dt>`left$p</dt>
	<dt>`inset-block-end$p</dt>
	<dt>`inset-block-start$p</dt>
	<dt>`inset-inline-end$p</dt>
	<dt>`inset-inline-start$p</dt>
	<dt>`right$p</dt>
	<dt>`top$p</dt>
	<dt id="resolved-value-special-case-property-like-top">
他の仕様にて［
解決値は `top^p の様に特別
］と定義される~prop
◎
A resolved value special case property like top defined in another specification 
</dt>
	<dd>
<p>
次のいずれも満たされるならば `使用値$ ／
~ELSE_ `算出値$：
</p>

<ul ><li>~propは，`有位置の要素$に適用されている
</li><li>当の要素~上の `display$p ~propの`解決値$ ~NIN { `none^v, `contents^v }
</li><li>~propは，拘束過多でない
</li></ul>
◎
If the property applies to a positioned element and the resolved value of the display property is not none or contents, and the property is not over-constrained, then the resolved value is the used value. Otherwise the resolved value is the computed value.
</dd>

	<dt>
他の仕様にて
`解決値は特別@
と定義される~prop。
◎
A resolved value special case property defined in another specification
</dt>
	<dd>
関連する仕様により定義される。
◎
As defined in the relevant specification.
</dd>
	<dt>その他の~prop</dt>
	<dd>
`算出値$
◎
The resolved value is the computed value.
</dd>
</dl>

	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">10. IANA Considerations</h2>

		<section id="default-style">
<h3 title="Default-Style">10.1. `Default-Style^h ~header~field</h3>

<div >
<p>
この節では、
Permanent Message Header Field Registry
に登録するための~header~fieldについて述べる。
</p>

<table><tbody>
<tr><th>~header~field名
<td>`Default-Style@h
<tr><th>適用し得る~protocol
<td>http
<tr><th>位置付け
<td>標準
<tr><th>~~作成／~~変更 管理
<td>W3C
<tr><th>仕様~文書
<td>この文書
<tr><th>関連~情報
<td>なし
</tbody></table>

◎
This section describes a header field for registration in the Permanent Message Header Field Registry.
◎
• Header field name
•• Default-Style
• Applicable protocol
•• http
• Status
•• standard
• Author/Change controller
•• W3C
• Specification document(s)
•• This document is the relevant specification.
• Related information
•• None.
</div>


		</section>
	</section>
	<section id="change-history">
<h2 title="Change History">11. 変更~履歴</h2>

<p>
この節では、この仕様の各~発行版の間の変更点の一部を文書~化する。
この節は，網羅的なものではない。
~bug修正および編集上の変更点は、一般に挙げられない。
◎
This section documents some of the changes between publications of this specification. This section is not exhaustive. Bug fixes and editorial changes are generally not listed.
</p>

		<section id="changes-from-5-december-2013">
<h3 title="Changes From 5 December 2013">11.1. 2013 年 12 月 5 日以降の変更点</h3>

<ul>

	<li>
代替~ss用の~API 
— `Document$I 上の次の~memberは除去された
⇒
`selectedStyleSheetSet^m,
`lastStyleSheetSet^m,
`preferredStyleSheetSet^m,
`styleSheetSets^m,
`enableStyleSheetsForSet()^m
◎
API for alternative stylesheets is removed: selectedStyleSheetSet, lastStyleSheetSet, preferredStyleSheetSet, styleSheetSets, enableStyleSheetsForSet() on Document.
</li>
	<li>
`Element$I ／ `PseudoElement^I ~ifc上の
`pseudo()^m ~methは除去された。
◎
The pseudo() method on Element and the PseudoElement interface is removed.
</li>
	<li>
`Element$I 上の次の属性は除去された
⇒
`cascadedStyle^m, `defaultStyle^m, `rawComputedStyle^m, `usedStyle^m
◎
The cascadedStyle, defaultStyle, rawComputedStyle and usedStyle IDL attributes on Element are removed.
</li>
	<li>
`CSSRule$I 上の `~cssText0$m 属性~設定子は、何もしないように変更された。
◎
The cssText IDL attribute’s setter on CSSRule is changed to do nothing.
</li>
	<li>
`CSSStyleDeclaration$I 上に `~webkit_cased_attr$m
— `webkitFoo^m の形の属性（小文字の `w^c ） —
が追加された。
◎
IDL attributes of the form webkitFoo (with lowercase w) on CSSStyleDeclaration are added.
</li>
	<li>
`CSSNamespaceRule$I は、読専に変更された。
◎
CSSNamespaceRule is changed back to readonly.
</li>
	<li>
`CSSStyleSheet!I の `insertRule()$m における
`charset^at の取り扱いは、除去された。
◎
Handling of @charset in insertRule() is removed.
</li>
	<li>
`CSSCharsetRule^I は再び除去された。
◎
CSSCharsetRule is removed again.
</li>
	<li>
識別子／文字列の直列化が変更された。
◎
Serialization of identifiers and strings is changed.
</li>
	<li>
選択子の直列化は、今や［
結合子 `&gt;&gt;^l, `||^l
］, および［
属性~選択子における `i^l ~flag
］も~supportする。
◎
Serialization of selectors now supports combinators "&gt;&gt;" and "||" and the "i" flag in attribute selectors.
</li>
	<li>
`lang()$ps の直列化が変更された。
◎
Serialization of :lang() is changed.
</li>
	<li>
`color$t, `number$t
の直列化が変更された。
◎
Serialization of &lt;color&gt; and &lt;number&gt; is changed.
</li>
	<li>
`CSSStyleDeclaration!I 上の `setProperty()$m は変更された。
◎
setProperty() on CSSStyleDeclaration is changed.
</li>
</ul>

		</section>
		<section id="changes-from-12-july-2011-to-5-december-2013">
<h3 title="Changes From 12 July 2011 To 5 December 2013">11.2. 2011 年 7 月 12 日から 2013 年 12 月 5 日までの変更点</h3>

<ul>
	<li>
非同一生成元~ssの読み取りや変更は許容されない。
◎
Cross-origin stylesheets are not allowed to be read or changed.
</li>
	<li>
`CSSCharsetRule$I ~ifc が再び導入された。
◎
CSSCharsetRule is re-introduced.
</li>
	<li>
`CSSGroupingRule$I, `CSSMarginRule$I が導入された。
◎
CSSGroupingRule and CSSMarginRule are introduced.
</li>
	<li>
`CSSNamespaceRule$I は今や変異可能である。
◎
CSSNamespaceRule is now mutable.
</li>
	<li>
`~CSS宣言~blockとして構文解析する$, および
~CSS宣言~blockに対する
`宣言列を直列化する$
が定義された。
◎
Parse and serialize a CSS declaration block is now defined.
</li>
	<li>
<!-- `CSSStyleDeclaration!I -->
`setProperty()$m,
`getPropertyValue()$m,
等々に対する略式~propが~supportされた。
◎
Shorthands are now supported in setProperty(), getPropertyValue(), et al.
</li>
	<li>
`setPropertyValue()$m,
`setPropertyPriority()$m
が導入された。
◎
setPropertyValue() and setPropertyPriority() are introduced.
</li>
	<li>
種々の~ifcにおける `style^m, `media^m 属性は、
WebIDL 拡張属性 [`PutForwards$] 注釈付きにされた。
◎
The style and media attributes of various interfaces are annotated with the [PutForwards] WebIDL extended attribute.
</li>
	<li>
`Element!I 上に `pseudo()^m ~methが導入された。†
◎
The pseudo() method on Element is introduced.
</li>
	<li>
`PseudoElement^I ~ifc が導入された。†
◎
The PseudoElement interface is introduced.
</li>
	<li>
`Element$I, `PseudoElement^I 上に
<!-- GetStyleUtils!I -->
`cascadedStyle^m,
`rawComputedStyle^m,
`usedStyle^m
属性が導入された。†
◎
The cascadedStyle, rawComputedStyle and usedStyle attributes on Element and PseudoElement are introduced.
</li>
	<li>
静的~meth `CSS.escape()$m が導入された。
◎
The CSS.escape() static method is introduced. 
</li>
</ul>

<p class="trans-note">【†
いったん導入されたが、再び削除された。
】</p>

		</section>
	</section>

</main></div>
<!-- MAIN -->

	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様の作成に寄与された次の方々に感謝する：
</p>

<p lang="en-x-a0">
The editors would like to thank

Alexey Feldgendler,
Benjamin Poulain,
Björn Höhrmann,
Boris Zbasky,
Brian Kardell,
Chris Dumez,
Christian Krebs,
Daniel Glazman,
David Baron,
Domenic Denicola,
Dominique Hazael-Massieux,
<i>fantasai</i>,
Hallvord R. M. Steen,
Ian Hickson,
John Daggett,
Lachlan Hunt,
Mike Sherov,
Myles C. Maxfield,
Morten Stenshorne,
Ms2ger,
Nazım Can Altınova,
Øyvind Stenhaug,
Peter Sloetjes,
Philip Jägenstedt,
Philip Taylor,
Richard Gibson,
Robert O’Callahan,
Simon Sapin,
Sjoerd Visscher,
Sylvain Galineau,
Tarquin Wilton-Jones,
Xidorn Quan, and
Zack Weinberg

for contributing to this specification.
</p>

<p>
加えて、代替スタイルシート API, および
CSS 値の正準化（現在は “直列化”）規則の初期のバージョンを書かれた Ian Hickson 氏に特別な謝意を。
<span lang="en">
Additional thanks to Ian Hickson for writing the initial version of the alternative style sheets API and canonicalization (now serialization) rules for CSS values.
</span></p>

	</section>
	<section>

<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
