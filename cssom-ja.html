<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Object Model (CSSOM) （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

//COMMON_DATA.page_state_key = '___CSS';
COMMON_DATA.init = function(expanded){

	var options = {
		original_url: 'https://drafts.csswg.org/cssom/',
		spec_status: 'ED',
		main: 'MAIN',
		fill_text_link: '#_versions > dd, #references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
//		link_map2: Util.getMapping('_link_map2'),
		toc_main: 'MAIN',
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 161114 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		p: 'property',
		d: 'descriptor',
		ps: 'pseudo',
		pe: 'pseudo',
		css: 'css',
		v: 'value',
		t: 'type',
		e: 'element',
		a: 'attr',
		at: 'at-rule',
//		mb: 'dictionary-member',
//		l: 'literal',
		E: 'error',
		h: 'header',
		cp: 'code-point',
		tnote: 'trans-note'
	};

	var tag_map = {
		p: 'code',
		d: 'code',
		ps: 'code',
		pe: 'code',
		I: 'code',
		m: 'code',
//		mb: 'code',
//		et: 'code',
		e: 'code',
		E: 'code',
		a: 'code',
		at: 'code',
//		l: 'code',
		h: 'code',
		css: 'code',
		xmlss: 'code',
		c: 'code',
		cp: 'span',
		v: 'code',
		t: 'var',
//		V: 'var',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎`]*|❝.|%[~\w\-一-鿆]+|`(.+?)([$@!\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
//	var t = match.charAt(0);
	switch(match[0]){
	case '%':
		return '<var>' + match.slice(1) + '</var>';
	case '❝':
		return (
			'<span class="code-point">U+' +
( ('000' + match.charCodeAt(1).toString(16).toUpperCase()).slice(-4) ) +
			'</span>（ "<code class="literal">' + match[1] + '</code>" ）'
		);
	case '⇒':
		if(match[1] === '！'){
			in_idl = true;
			nesting += '</pre>';
			return '<pre class="idl">';
		} else {
			nesting += '</span>';
			return '：<span class="block">';
		}
	case '◎':
		if(in_idl) {
			result = nesting;
			in_idl = false;
		} else {
			result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
		}
		nesting = '';
		return result;
	default: //＊
		return match;
	}//◎
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'I': // IDL interface
	if((indicator === '@') || (indicator === '!')){
		idl_ifc = key;
	}
	href = '#' + key.toLowerCase();
	if(in_idl) tag = '';
	break;
//case 'mb': // IDL dictionary member
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = '#dom-' + (
		(key === idl_ifc) ? idl_ifc : (idl_ifc + '-' + key)
	).toLowerCase();
	if(in_idl) tag = '';
	break;
case 'ps': // pseudo
	text = ':' + key;
	break;
case 'pe': // pseudo element
	text = '::' + key;
	break;
case 'at': // at-rule
	text = '@' + key;
	break;
case 't': // at-rule
	text = '&lt;' + key + '&gt;';
	break;
case 'cp': // code point
	text = 'U+' + key;
	break;
case 'E': // error
	href = '~WEBIDL#' + key.toLowerCase();
	break;
case 'l': // literal
	return '"<code class="literal">' + text + '</code>"'
case 'v': // variables
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}
return text;

	}
}
</script>
<!-- 
	var n = text.indexOf('.');
	if(n > 0){
		text = text.slice(n + 1);
		href = '#dom-' + text.replace(/\./, '-');
	} else {

-->

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
ascii-case-insensitive:
whitespace:
ignored:
concept-node:
cascaded-value:
computed-value:
used-value:
initial-value:
specified-value:
shorthand:
longhand:
canonical-order:

selector:
selectors-list:
complex-selector:
compound-selector:
simple-selector:
universal-selector:
attribute-selector:
id-selector:
type-selector:
class-selector:
pseudo-class:
pseudo-element:
combinator:

namespace-prefix:
default-namespace:
null-namespace:
page-selector:
margin-at-rules:
list-of-css-page-selectors:

after-pseudo_element:
before-pseudo_element:
environment-encoding:
get-an-encoding:
documents-character-encoding:
context-object:


serialize-a-css-longhands:
css-style-rule:
	media-query:
	media-feature:
	media-type:


</script>




<!-- ＊
	Window:window
	Element:element
MediaList:medialist
StyleSheet:stylesheet
CSS:css
CSSStyleSheet:cssstylesheet
StyleSheetList:stylesheetlist
Document:document
ProcessingInstruction:
Element:
LinkStyle:linkstyle
CSSRuleList:cssrulelist
CSSRule:cssrule
CSSStyleRule:cssstylerule
CSSCharsetRule:csscharsetrule
CSSImportRule:cssimportrule
CSSGroupingRule:cssgroupingrule
CSSMediaRule:cssmediarule
CSSPageRule:csspagerule
CSSMarginRule:cssmarginrule
CSSNamespaceRule:cssnamespacerule
CSSStyleDeclaration:cssstyledeclaration
ElementCSSInlineStyle:elementcssinlinestyle
GetStyleUtils:getstyleutils
PseudoElement:pseudoelement



CSS21/
	cascade.at-import:`import^at
	syndata.ignore
	cascade.used-value:使用値
	cascade.computed-value:算出値
	cascade.specified-value:指定値
	cascade.at-import:`import^at

namespace.namespace-prefix:名前空間接頭辞
namespace.default-namespace:既定の名前空間


selectors
http://www.w3.org/TR/css3-selectors/

selectors.pseudo_element:疑似要素
	CSS21/selector.html#pseudo-element
selectors.combinators:結合子
	CSS21/selector.html#universal-selector
selectors.universal-selector:全称~選択子
selectors.simple-selectors:単体~選択子
selectors.attribute-selectors:属性~選択子
	CSS21/selector.html#attribute-selectors
selectors.id-selectors:ID 選択子
	CSS21/selector.html#id-selectors
selectors.pseudo-class:疑似類
	CSS21/selector.html#pseudo-class-selectors
selectors.type-selectors:型選択子
	CSS21/selector.html#type-selectors
selectors.sequence:単体選択子シーケンス
selectors.selectors:選択子
	CSS21/selector.html
selectors.class-selector:類選択子
	selectors.grouping:選択子の~group化

selectors.negation:否定疑似クラス

-->

<!--% interface prefix -->

<!--%置換語 -->
<script type="text/plain" id="words_table1">
XMLSS:http://www.w3.org/TR/xml-stylesheet/
	XMLSS:XML/xml-stylesheet-ja.html

APPEND: <span class="op">&lt;&lt;</span> 
SP: <span class="op">SPACE</span> 
RA:readonly attribute
DS:DOMString
UL:unsigned long
US:unsigned short
MediaList: <code>MediaList</code> 
ACI:<sub>大小無視</sub>

camel_cased_attr:<var>camel_cased_attribute</var>
webkit_cased_attr:<var>webkit_cased_attribute</var>
dashed_attr:<var>dashed_attribute</var>
cssText0:cssText

</script>

<!--%語彙 -->
<script type="text/plain" id="words_table">
此れ:<b>これ°</b>

	●仕様
UI:user interface:UI::ユーザインタフェース
UA:user agent:UA::ユーザエージェント
model:::モデル
vendor:::ベンダ
algo:algorithm::アルゴリズム
browser:::ブラウザ
utility:::ユーティリティ
bug:::バグ

特色機能:feature:~
作者:author:~
利用者:user:~
作者定義:author-defined:作者定義の
定義-:define:~
定義:definition:~
定義表:definition table:~
指定:sepcify:~
仕様:spec:~
	specification
実装:implementation:~
実装-:implement:~
要件:requirements:~
拡張-:extend:~
拡張:extension:~
適切:appropriate:~
概念:concept:~
適用-:apply:~
導入-:introduce:~
影響-:affect:~
歴史的:historical:~
変更点:changes:~
明示的:explicit:~
互換性:compatibility:~
相互運用性:interoperability:~
厳密:strict:~
技術的:technical:~
適合性:conformance:~
取組む:address する:取り組む
展開-:expand:~
中核:core:~
非推奨:deprecated:~
廃用に:obsolete:~
予期-:expect:~
拘束:constraint:~
更新:update:~
省略可:optional:~
意味論:semantics:~
本質的:essential:~
直接的:direct:~
上書き:override:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
結付け:association:結び付け
将来的:future:~
予約-:reserved:~
依存-:depend:~
発行版:publications:~
網羅的:exhaustive:~
編集上の:editorial:~
関連の:related:~
指定-:specify:~
許容-:allow:~
特定0の:particular:ある特定の
位置付け:status:~

	●fetch
url:
address:::アドレス
URL:
intranet:::イントラネット
protocol:::プロトコル
header:::ヘッダ
fetch:
fetching:
network:::ネットワーク
referrer:::リファラ
符号化方式:encoding:~::エンコーディング
資源:resource::~:リソース
要請:request::~:リクエスト
応答:response::~:レスポンス
生成元:origin::~:オリジン
非同一生成元:cross-origin::~:クロスオリジン
同一生成元:same-origin::~:同一オリジン
	inputURL:input URL:入力~URL
所在:location::~
give-up:give up


	●IDL
signature:::シグネチャ
member:::メンバ
access:::アクセス
obj:object::オブジェクト
ifc:interface::インタフェース
meth:method::メソッド
instance:::インスタンス
prolog:::プロローグ

構築子:constructor:~::コンストラクタ
投出:throw:~
再投出:re-throw:~
例外:exception:~
継承-:inherit:~
	継承:inheritance:~
被support:supported:被 support:被サポート
読専:readonly:読み取り専用
読取り:reading:読み取り
凍結:frozen:~
配列:array:~
正則属性:regular attribute:~
拡張属性:extended attribute:~
取得子:getter:~
設定子:setter:~
注釈付き:annotated:~
被呼出時:被 invoke 時:~
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
呼出す:invoke する:呼び出す
呼出さ:invoke し:呼び出さ
呼出し:invoking:呼び出し
返さ:return し:~
返され:return され:~
返す:return する:~
部分的:partial:~


	●DOM
DOM:
文書:document:~
要素:element:~
属性:attribute:~
	要素~名:element name:~
	属性~名:attribute name:~
	属性~値:attribute value:~
疑似属性:pseudo-attribute:~
名前空間:namespace::~
	名前空間~接頭辞:namespace prefix:~
接頭辞:prefix::~
接頭dash:dash prefix::dash 接頭
処理命令:processing instruction:~
過去互換:quirks::~
node:::ノード
親:parent::~
子:child::~
tree:::ツリー

	●CSS
css:CSS
style:::スタイル
styling:::スタイル付け
ss:style sheet::スタイルシート
ssset:CSS style sheet set::CSS スタイルシート集合:CSS スタイルシートセット

class:::クラス
margin:::マージン
important:
cascaded:::カスケード
cascading:::カスケード法
box:::ボックス
pixel:::ピクセル

prop:property::プロパティ
略式:shorthand:~
下位prop:sub-properties:下位 properties:下位プロパティ
	longhand
初期値:initial value:~
使用値:used value:~
算出値:computed value:~
指定値:specified value:~
解決値:resolved value:~
疑似要素:pseudo-element:~
疑似類:pseudo-class:疑似 class:疑似クラス
結合子:combinator::~
	コンビネータ
	属性~選択子
	~class選択子
	型~選択子
選択子:selector::~:セレクタ
選択子~list:selector list::選択子リスト:セレクタリスト
全称:universal::~
単体:simple::~
合体:compound::~
複体:complex::~
選択子群:group of selectors::選択子グループ:セレクタグループ

規則:rule::~:ルール
	規則集合
集合:set:~::セット
規則列:rules::規則リスト:ルールリスト
媒体:media::~:メディア
特能:feature::~
照会:query::クエリ
	媒体照会~list:media query list::媒体クエリリスト:メディアクエリ リスト
宣言-:declare:~
宣言:declaration:~
宣言列:declarations:宣言 list:宣言リスト
遷移:transition::~
animation:::アニメーション
算出-:compute:~
絶対的:absolute:~
相対的:relative:~
絶対:absolute:~
単位:unit:~
数値:numeric value:~
解像度:resolution:~
周波数:frequency:~
整数:integer:~
色:color:~
長さ:length:~
有位置の:positioned:~

具現化法:rendering:~::レンダリング
具現化:rendering:~::レンダリング
呈示hint:presentational hints:呈示 hint:呈示ヒント


	●構文
ASCII:
comma:::カンマ
semicolon:::セミコロン
escape:::エスケープ
	ダッシュ:dash:~
keyword:
文字大小区別:case-sensitive:~
大小区別:case-sensitive:~
大小無視:case-insensitive:~
	文字大小:case
識別子:identifier:~
空文字列:empty string:~
文字列:string:~
空白:whitespace:~
空:empty:~
正規化-:normalize:~

直列化器:serializer:~::シリアライザ
直列化法:serializing:直列化::シリアライズ法
直列化-:serialize:直列化::シリアライズ
直列化:serialization:~::シリアル化
直列化済:serialized:直列化済み::シリアライズ済み

構文解析器:parser:~::パーサ
構文解析-:parse:~::パース
構文解析法:parsing:~::パース法
構文解析:parsing:~::パース処理
解析済:parsed:解析済み::パース済み
大文字:uppercase:~
小文字:lowercase:~
小文字先頭:lowercase first:~
辞書式:lexicographical:~
正準的:canonical:~
正準形:canonical form:~
符号位置:code point::~:コードポイント
順序:order:~
有順序:ordered:~
成分値:component value:~
成分:component:~
構文:syntax:~
文法:grammar:~
文字:character:~
名前:name:~
名:name:~
省略済:trimmed:省略済み
基数:base:~
基数10:base-ten:10 進
数字:digit:~
選好:preferred::~
選好順:preferred order:~
指定順:specified order:~
	区切子:delimiter 1
	区切り:-separated 17


	●未分類
metadata:::メタデータ
script:::スクリプト
alpha:::アルファ
inline:::インライン
live:
flag:::フラグ
list:::リスト
parameter:::パラメタ
error:::エラー
index:
source:::ソース
macro:
level:::レベル
sequence:
text:::テキスト
	type:::種別
null:
	inclusion:
view:::ビュー
field:::フィールド
collection:::コレクション
	~chain:::チェイン
title:::タイトル
support:::サポート
mode:::モード
title:::タイトル
data:::データ
dot:::ドット
event-loop:event loop::イベントループ

走って:run して:~
走らす:run する:走らせる
走らせ:run し:~

基底:base:~
優先度:priority::~
合致:match:~::マッチ
既定:default:~::デフォルト
既定の:default:~::デフォルト

状態:state:~
	最後の:last:~
	最初の:first:~
可能化-:enable::~
可能化:enabled::~
不能化-:disable::~
不能化:disabled::~
内容:content:~
	内容~属性:content attribute:~
頁:page::ページ
型:type::~
代替-:alternate::~
代替:alternative::~
持続的:persistent::~
持続化-:persist::~
持続化:persisting::~
所有者:owner::~
準備済み:ready::~
block:::ブロック
阻んで:block して::~:ブロックして
種別:type::~:タイプ
封入-:enclose:包含
入子に:nest:入れ子に
文脈:context:~

選択-:select:選択
選択:selecting:~

作成-:create:~
	作成-時:create 時:~
設定-:set:~
変更-:change:~
改変:modifing:~
	~~変更:mutating
変異-:mutate:~
除去-:remove:~
付加-:append:追加
挿入-:insert:~
追加-:add:~
項目:item:~

引数:argument:~
値:value:~
新たな:new:~
表現:representation:~
表現-:represent:~
頁:page::ページ
ゼロ:zero:~
メモリ:memory:~
	プラットフォーム:platform:~
	カスケード:cascade:~
	モジュール:module:~
情報:information:~
公開-:expose:~
決定-:determine:~
言語:language:~
変化:change:~
初期:initial:~
初期化-:initialize:~
無視-:ignore:~
抽象的:abstract:~
変異可能:mutable:~
下層の:underlying:~
範囲:range:~
参照:reference:~
	~~参照:refer:~
失敗-:fail:~
否定形:negated:~
解決-:resolve:~
静的:static:~
空間:space:~
環境:environment:~
対話操作:interaction:~
操作:manipulation:~
操作-:manipulate:~
往来:round-trip:~
現在の:current:~
大域:global:~::グローバル
独自:custom:~
custom:::カスタム
選択肢:option:~
手動:manual:~
中止-:abort:~
停止-:stop:~
待機-:wait:~
置換-:replace:~
到達-:reach:~
埋込みの:embedded:埋め込みの

形式:format:~
反映-:reflect:~
提供-:provide:~
手続き:steps:~
	段:step
格納-:store:~
落とし:drop し:~
落とさ:drop さ:~
読込み:loading:読み込み
所与の:given:与えられた
関数:function:~
	~RET:terminate these steps
</script>

<!--% 他の語
概要: 1
可能: 1
基本的: 1
機能: 1
試験し易く:testability 1
仕事: 1
関数記法:functional 記法
	略記: 1
	再構成: 1
	補完: 1
備考: 1
別途: 1
構造: 1
明確: 1
最小個数: 1
初回: 1
回目: 1
以上: 1
余分: 1
複数個: 1
出力: 1
対応付: 1
列目: 1
適宜:as appropriate 1
実際: 1

所属: 1
選定: 1
視点: 1
表示: 1
基本: 1
同類: 1
言及: 1
同様: 1
何故: 1
過去: 1
編集者: 1
順当: 1
期待:good hope
仮想:hypothetical 1


可能: 1
以前: 1
唯一: 1
状況: 1
複数回: 1
最高位: 1
~~混在: 1
任意: 1
正確: 1
必須: 1


完全に不透明:opaque
大小: 1
保全: 1
除外: 1
進数: 1
小数部: 1
指数部:exponent:~
前置: 1
用途: 1
秒数: 1
過程: 1
草案:draft:~
移行: 1
用例集:Examples 1
前後: 1
既存:deployed
変遷:change 1
課題: 1

登録: 1
標準: 1
管理: 1
参照文献: 1
変更履歴: 1
修正: 1
一般: 1
謝辞: 1
先行: 2
向上: 2
詳細: 2
内部: 2
内部的:internal
用語: 2
記述: 2
総称: 2
共通: 2
反復: 2
末尾: 2
方法: 2
存続: 2
~~反映:updated as appropriate
該当: 2
後続: 2
処理:processing／ 2
処理前:before 2
処理後:after 2
一方: 2
特定: 2
全体: 2
種類: 2
現在:current 2
自身: 2
非負:non-negative 1
負:negative
比較: 3
変数: 3
文字大小: 3
区別: 3
形式: 3
同値: 3
部分: 3
成立: 3
複数: 3
当該: 3
省略: 3
規定: 4
目的: 4
制限:limitations／limit 4
一覧:table／list 4
呼称: 4
取得: 4
個以上: 4
一致: 4
個数: 4
最短形の:shortest form possible 2
最短の:shortest 4
限られた~~範囲:less-widely
	生成: 5
以外: 5
時点: 5
先頭: 6
総数: 6
一連: 7
変換:turn into／〜to〜 7
必要: 8
番目: 8
意味: 9
各種: 9
連結:concatenation／ 10
入力:input／ 11
以下: 12
一部: 13
利用: 13
存在: 14
位置:position／ 15
対応: 19
注記: 33
場合: 65
結果: 119

例:example

literal string
	maps: 6

意味する:means
	medium:
	metadata:
	minus: 5
	named: 4
otherwise:他の場合
	owner: 10
	page:
	part: 6
	patent: 5
	per: 10
	遂行-:perform:~
	range: 5
	read:読み取る
link relation type
result:結果
return:返す
same:同じ
second:２番目の
section:節
sequence:並び
On setting: 10

	steps:手続き

 -->


<!--% リンク置換データ -->

<script type="text/plain" id="_link_map">

	●IDL
CEReactions:~HEcustom#cereactions
TreatNullAs:~WEBIDL#TreatNullAs
SameObject:~WEBIDL#SameObject
PutForwards:~WEBIDL#PutForwards
NoInterfaceObject:~WEBIDL#NoInterfaceObject
NewObject:~WEBIDL#NewObject
LegacyArrayClass:~WEBIDL#LegacyArrayClass

	I.Element:~DOM4#element
	I.Document:~DOM4#document
I.CSSFontFaceRule:~CSSFONT#cssfontfacerule
I.CSSPseudoElement:~CSSWG/css-pseudo-4/#csspseudoelement

	m.Window.getComputedStyle:#dom-window-getcomputedstyle
m.cssText:#dom-cssstyledeclaration-csstext
m.~cssText0:#dom-cssrule-csstext
m.mediaText:#dom-medialist-mediatext
m.StyleSheet.href:#dom-stylesheet-href
m.StyleSheet.media:#dom-stylesheet-media
m.CSS.escape:#dom-css-escape


m.~camel_cased_attr:#dom-cssstyledeclaration-camel-cased-attribute
m.~webkit_cased_attr:#dom-cssstyledeclaration-webkit-cased-attribute
m.~dashed_attr:#dom-cssstyledeclaration-dashed-attribute

	●css
	＊t.selector:~SELECTORS#typedef-selector
t.selector-list:~SELECTORS#typedef-selector-list
	selectors_group 生成規則:~TR/css3-selectors/#grammar
	// TODO
t.angle:~CSSVAL#angle-value
t.number:~CSSVAL#number-value
t.length:~CSSVAL#length-value
t.frequency:~CSSVAL#frequency-value
t.identifier:~CSSVAL#identifier
	~CSSSYN#typedef-ident-token
t.integer:~CSSVAL#integer-value
t.percentage:~CSSVAL#percentage-value
t.resolution:~CSSVAL#resolution-value
t.string:~CSSVAL#string-value
t.time:~CSSVAL#time-value
t.uri:~CSSVAL#url-value
t.shape:~CSS2VISUFX#value-def-shape
		~CSSSHAPE#typedef-basic-shape
t.family-name:~CSSFONT#family-name-value
t.color:~CSSCOLOR#typedef-color

	t.alphavalue:~CSSCOLOR#
	t.counter:~CSSCOUNTER#
	t.absolute-size:~XXXXX#typedef-
	t.border-width:~CSSBG#typedef-
		t.line-width:~CSSBG#line-width
	t.border-style:~CSSBG#typedef-
		t.line-style:~CSSBG#line-style
	t.margin-width:~CSS2BOX#value-def-margin-width
	t.padding-width:~CSS2BOX##value-def-padding-width
	t.bottom:~XXXXX#typedef-
	t.right:~XXXXX#typedef-
	t.left:~XXXXX#typedef-
	t.top:~XXXXX#typedef-
	t.generic-family:~CSSFONT#generic-family-value
	t.generic-voice:~CSSSPEECH#voice-family-generic-voice
	t.specific-voice:
		~CSSSPEECH#voice-family-name
	t.relative-size:~XXXXX#typedef-

p.line-height:~CSS2VISUDET#propdef-line-height

p.width:~CSS2VISUDET#propdef-width
p.height:~CSS2VISUDET#propdef-height
p.margin-bottom:~CSS2BOX#propdef-margin-bottom
p.margin-left:~CSS2BOX#propdef-margin-left
p.margin-right:~CSS2BOX#propdef-margin-right
p.margin-top:~CSS2BOX#propdef-margin-top
p.margin:~CSS2BOX#propdef-margin
p.padding-bottom:~CSS2BOX#propdef-padding-bottom
p.padding-left:~CSS2BOX#propdef-padding-left
p.padding-right:~CSS2BOX#propdef-padding-right
p.padding-top:~CSS2BOX#propdef-padding-top
p.padding:~CSS2BOX#propdef-padding

p.block-size:~CSSLOGICAL#propdef-block-size
p.inline-size:~CSSLOGICAL#propdef-inline-size
p.margin-block-end:~CSSLOGICAL#propdef-margin-block-end
p.margin-block-start:~CSSLOGICAL#propdef-margin-block-start
p.margin-inline-end:~CSSLOGICAL#propdef-margin-inline-end
p.margin-inline-start:~CSSLOGICAL#propdef-margin-inline-start
p.padding-block-end:~CSSLOGICAL#propdef-padding-block-end
p.padding-block-start:~CSSLOGICAL#propdef-padding-block-start
p.padding-inline-end:~CSSLOGICAL#propdef-padding-inline-end
p.padding-inline-start:~CSSLOGICAL#propdef-padding-inline-start
p.offset-block-end:~CSSLOGICAL#propdef-offset-block-end
p.offset-block-start:~CSSLOGICAL#propdef-offset-block-start
p.offset-inline-end:~CSSLOGICAL#propdef-offset-inline-end
p.offset-inline-start:~CSSLOGICAL#propdef-offset-inline-start

p.bottom:~CSS2VISUREN#propdef-bottom
p.left:~CSS2VISUREN#propdef-left
p.right:~CSS2VISUREN#propdef-right
p.top:~CSS2VISUREN#propdef-top

p.display:~CSS2VISUREN#propdef-display
	p.display:~CSSDISP#propdef-display

p.border:~CSSBG#border
p.border-style:~CSSBG#border-style
p.border-color:~CSSBG#border-color
p.border-width:~CSSBG#border-width

p.font-size:~CSSFONT#propdef-font-size


p.background-color:~CSSBG#background-color
	p.background-color:~CSS2/colors.html#propdef-background-color
p.border-block-end-color:~CSSLOGICAL#propdef-border-block-end-color
p.border-block-start-color:~CSSLOGICAL#propdef-border-block-start-color
p.border-bottom-color:~CSSBG#border-bottom-color
	p.border-bottom-color:~CSS2BOX#propdef-border-bottom-color
p.border-inline-end-color:~CSSLOGICAL#propdef-border-inline-end-color
p.border-inline-start-color:~CSSLOGICAL#propdef-border-inline-start-color
p.border-left-color:~CSSBG#border-left-color
	p.border-left-color:~CSS2BOX#propdef-border-left-color
p.border-right-color:~CSSBG#border-right-color
	p.border-right-color:~CSS2BOX#propdef-border-right-color
p.border-top-color:~CSSBG#border-top-color
	p.border-top-color:~CSS2BOX#propdef-border-top-color
p.box-shadow:~CSSBG#box-shadow
p.caret-color:~CSSUI#propdef-caret-color
p.color:~CSSCOLOR#propdef-color
p.outline-color:~CSSUI#propdef-outline-color
	p.outline-color:~CSS2/ui.html#propdef-outline-color


	at.charset:~CSSSYN#at-ruledef-charset
at.import:~CASCADE#at-ruledef-import
at.media:~CSSCOND#at-ruledef-media
at.namespace:~CSSNS#at-ruledef-namespace
at.page:~CSSPAGE#at-ruledef-page
	at.fontface:~CSSFONT#at-ruledef-fontface

d.width:~MQ4#descdef-media-width
d.height:~MQ4#descdef-media-height
d.device-width:~MQ4#descdef-media-device-width
d.device-height:~MQ4#descdef-media-device-height
d.orientation:~MQ4#descdef-media-orientation
d.aspect-ratio:~MQ4#descdef-media-aspect-ratio
d.device-aspect-ratio:~MQ4#descdef-media-device-aspect-ratio
d.color:~MQ4#descdef-media-color
d.color-index:~MQ4#descdef-media-color-index
d.monochrome:~MQ4#descdef-media-monochrome
d.resolution:~MQ4#descdef-media-resolution
d.scan:~MQ4#descdef-media-scan
d.grid:~MQ4#descdef-media-grid

pe.before:#before-pseudo_element
pe.after:#after-pseudo_element

ps.lang():~SELECTORS#lang-pseudo
ps.nth-child():~SELECTORS#nth-child-pseudo
ps.nth-last-child():~SELECTORS#nth-last-child-pseudo
ps.nth-of-type():~SELECTORS#nth-of-type-pseudo
ps.nth-last-of-type():~SELECTORS#nth-last-of-type-pseudo
ps.not():~SELECTORS#not-pseudo


	●
h.Default-Style:#http-default-style
	<code>Default-Style</code>
h.Link:https://tools.ietf.org/html/rfc5988#section-5

r.DOM:#biblio-whatwg-dom
r.ENCODING:#biblio-whatwg-encoding
r.URL:#biblio-whatwg-url

~give-up:#_give-up
~ACI:#ascii-case-insensitive

	＊add-a-style-sheet:追加
追加-:#add-a-css-style-sheet
作成-:#create-a-css-style-sheet
ss.除去-:#remove-a-css-style-sheet

結付けられている~css~ss:#associated-css-style-sheet
媒体~照会~collection:#medialist-collection-of-media-queries
	compare-media-queries:比較
同値:#_eq-media-queries
~MediaList~objを作成-:#create-a-medialist-object
	<code>MediaList</code> ~objを作成-
文書~ss~list:#document-css-style-sheets
~css~prop名に変換:#idl-attribute-to-css-property
解決値:#resolved-value
~css規則:#css-rule
挿入-:#insert-a-css-rule
除去-:#remove-a-css-rule

~supportされる~css~prop:#supported-css-property
指定順:#concept-declarations-specified-order
選好順:#concept-shorthands-preferred-order

IDL 属性~名に変換:#css-property-to-idl-attribute
~css~ss:#css-style-sheet
持続的~css~ss:#persistent-css-style-sheet
	~css~propを設定-:#set-a-css-property
~css宣言を設定-:#set-a-css-declaration
~css宣言の優先度を設定-:#set-a-css-declaration-priority
~css宣言の値を設定-:#set-a-css-declaration-value

	//css-declaration-
~css宣言:#css-declaration
~css宣言~block:#css-declaration-block
~prop名:#css-declaration-property-name
値:#css-declaration-value
~important~flag:#css-declaration-important-flag
大小区別~flag:#css-declaration-case-sensitive-flag

	//cssstyledeclaration-
読専~flag:#cssstyledeclaration-readonly-flag
宣言列:#cssstyledeclaration-declarations
親~css規則:#cssstyledeclaration-parent-css-rule
所有者~node:#cssstyledeclaration-owner-node

	//concept-css-style-sheet_
ss.種別:#concept-css-style-sheet-type
ss.所在:#concept-css-style-sheet-location
ss.親~css~ss:#concept-css-style-sheet-parent-css-style-sheet
ss.所有者~node:#concept-css-style-sheet-owner-node
ss.所有者~css規則:#concept-css-style-sheet-owner-css-rule
ss.媒体:#concept-css-style-sheet-media
ss.~title:#concept-css-style-sheet-title
ss.代替-~flag:#concept-css-style-sheet-alternate-flag
ss.不能化~flag:#concept-css-style-sheet-disabled-flag
ss.~css規則列:#concept-css-style-sheet-css-rules
ss.origin-clean ~flag:#concept-css-style-sheet-origin-clean-flag
	//escape-a-
符号位置として~escape:#escape-a-character-as-code-point
~escape:#escape-a-character

	//parse-a-
~css宣言~blockとして構文解析-:#parse-a-css-declaration-block
~css頁~選択子の~listとして構文解析-:#parse-a-list-of-css-page-selectors
~css規則として構文解析-:#parse-a-css-rule
~css値として構文解析-:#parse-a-css-value
選択子~listとして構文解析-:#parse-a-group-of-selectors
媒体~照会~listとして構文解析-:#parse-a-media-query-list
媒体~照会として構文解析-:#parse-a-media-query

	// concept-css-rule_
親~規則:#concept-css-rule-parent-css-rule
親~ss:#concept-css-rule-parent-css-style-sheet
~text:#concept-css-rule-text
種別:#concept-css-rule-type
子~規則列:#concept-css-rule-child-css-rules

	// serialize-a-
~comma区切りで直列化-:#serialize-a-comma-separated-list
空白~区切りで直列化-:#serialize-a-whitespace-separated-list
識別子として直列化-:#serialize-an-identifier
宣言列として直列化-:#serialize-a-css-declaration-block
	直列化-
~css宣言を直列化-:#serialize-a-css-declaration
page.直列化-:#serialize-a-list-of-css-page-selectors
	直列化-
~css規則として直列化-:#serialize-a-css-rule
	直列化-
~css成分値として直列化-:#serialize-a-css-component-value
	直列化-
~css値として直列化-:#serialize-a-css-value
	直列化-
下位prop~listとして直列化-:#serialize-a-css-longhands
	直列化-
選択子~listとして直列化-:#serialize-a-group-of-selectors
	直列化-
媒体~特能~値として直列化-:#serialize-a-media-feature-value
	直列化-
媒体~照会~listとして直列化-:#serialize-a-media-query-list
媒体~照会として直列化-:#serialize-a-media-query
	直列化-
選択子として直列化-:#serialize-a-selector
	直列化-
単体~選択子として直列化-:#serialize-a-simple-selector
	直列化-
文字列として直列化-:#serialize-a-string
~URLとして直列化-:#serialize-a-url
	URL として直列化-

	// *-css-style-sheet-set-
~ssset:#css-style-sheet-set
~ssset名:#css-style-sheet-set-name
可能化~ssset:#enabled-css-style-sheet-set
~sssetを可能化-:#enable-a-css-style-sheet-set
~sssetを選択-:#select-a-css-style-sheet-set
ss.選択した:#select-a-css-style-sheet-set
最後の~ssset名:#last-css-style-sheet-set-name
選好~ssset名:#preferred-css-style-sheet-set-name
選好~ssset名を変更-:#change-the-preferred-css-style-sheet-set-name

~css~ss資源を~fetch:#fetch-a-css-style-sheet
	unset:#unset
	set:#set

	文書の文字~符号化方式:#document\'s-character-encoding
文書の文字~符号化方式:#documents-character-encoding
環境~符号化方式:#environment-encoding
符号化方式を取得:#get-an-encoding

	// external terms

空白:#whitespace
無視される:#ignored
算出値:#computed-value
使用値:#used-value
~cascaded値:#cascaded-value

初期値:#initial-value
指定値:#specified-value
略式~prop:#shorthand
下位prop:#longhand
正準的~順序:#canonical-order


名前空間~接頭辞:#namespace-prefix
既定の名前空間:#default-namespace
~null名前空間:#null-namespace

~css頁~選択子の~list:#list-of-css-page-selectors
頁~選択子:#page-selector
~margin at-規則:#margin-at-rules

~supportされる~styling言語:#supported-styling-language

全称~選択子:#universal-selector
単体~選択子:#simple-selector
	selectors3
group of selectors:#group-of-selectors
	selectors4
選択子~list:#selectors-list
選択子:#selector
複体~選択子:#complex-selector
合体~選択子:#compound-selector
属性~選択子:#attribute-selector

ID 選択子:#id-selector
型~選択子:#type-selector
~class選択子:#class-selector
疑似類:#pseudo-class
疑似要素:#pseudo-element
結合子:#combinator

~css~style規則:#css-style-rule

媒体~照会:#_media-query
媒体~特能:#_media-feature
	媒体~種別:#media-type
~prolog:#prolog

有位置の要素:~CSS2VISUREN#positioned-element

	// 外部リンク
xml-stylesheet 処理命令:~XMLSS#dt-xml-stylesheet
	#dt-xml-stylesheet-processing-instruction
疑似属性:~XMLSS#dt-pseudo-attribute
xmlss.charset:~XMLSS#PA-charset
xmlss.href:~XMLSS#PA-href
xmlss.title:~XMLSS#PA-title
xmlss.alternate:~XMLSS#PA-alternate
xmlss.type:~XMLSS#PA-type
xmlss.media:~XMLSS#PA-media

文書~基底~URL:~HTMLINFRA#document-base-url
生成元:~BROWSERS#concept-origin

Content-Type ~metadata:~HTMLINFRA#content-type
~URL:~URLSpec#concept-url
	 URL 
絶対~URL:~URLSpec#syntax-url-absolute
	絶対 URL
~URL構文解析器:~URLSpec#concept-url-parser
	 URL 構文解析器
~URL直列化器:~URLSpec#concept-url-serializer
	 URL 直列化器

~fetching:~FETCH#concept-fetch
~network~error:~FETCH#concept-network-error
要請:~FETCH#concept-request
rq.~url:~FETCH#concept-request-url
	 url 
rq.生成元:~FETCH#concept-request-origin
rq.~referrer:~FETCH#concept-request-referrer
	 ~referrer
CORS 同一生成元:#cors-same-origin

~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化:~INFRA#ascii-lowercase
~ASCII大文字~化:~INFRA#ascii-uppercase
文字大小区別:~HTMLINFRA#case-sensitive
	~DOM4#〜
~tree順序:~DOM4#concept-tree-order
過去互換~mode:~DOM4#concept-document-quirks
~node文書:~DOM4#concept-node-document
子:~DOM4#concept-tree-child
~address:~DOM4#concept-document-url
doc.~address:~HTMLdom#the-document%27s-address
~node:#concept-node
~data:~DOM4#concept-cd-data
内容~属性:~DOM4#concept-attribute
	投出:~DOM4#concept-throw
後続:~DOM4#concept-tree-following
文書:#document
	文書:~DOM4#concept-document
context object:~DOM4#context-object

被support~prop~index:~WEBIDL#dfn-supported-property-indices
識別子:~WEBIDL#dfn-identifier
	正則属性:#＊webidl.dfn-regular-attribute
凍結~配列:~WEBIDL#idl-frozen-array

現在の大域~obj:~WAPI#current-global-object
結付けられている文書:~BROWSERS#concept-document-window
~event-loop:~WAPI#event-loop

~ss準備済み~flag:~HEmetadata#style-sheet-ready
~scriptを阻んでいる~ss:~HEmetadata#a-style-sheet-that-is-blocking-scripts

~custom~prop:~CSSVAR#custom-property
~custom~prop名:~CSSVAR#custom-property
</script>

<!--% style-->

<style>


td:first-child, th:first-child {
	border-right: 1px solid gray;
}
tr{
	border-top: 1px solid gray;
}

thead > tr:first-child {
	border-top: none;
	border-bottom: 2px solid black;
}

ol.concat > li {
	list-style-type: none;
}

/* HTTP ヘッダ名 */
.header {
	color: #035;
	font-weight: bold;
}

.code-point {
	font-family: sans-serif0, sans-serif;
}


dfn > code {
	background-color: #FFC;
} /* 追加 */


th[colspan]{
	padding: 0.5em;
}
</style>

<!--
dd > ol:first-child {
	padding-left:0;
}

 -->

</head>

<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>


<aside class="trans-meta">
<h1>CSS Object Model (CSSOM) 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">CSS Object Model (CSSOM)</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2017-01-12</time>
（公開：<time>2012-05-31</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>

<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1 id="cssom" title="CSS Object Model (CSSOM)">CSS オブジェクトモデル (CSSOM)</h1>
<h2>2017 年 1 月 12 日付 編集者草案</h2>
	</hgroup>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dt title="Editor’s Draft:">編集者草案</dt>
	<dd>https://drafts.csswg.org/cssom/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>https://www.w3.org/TR/cssom-1/</dd>

	<dt title="Previous Versions:">以前のバージョン</dt>
	<dd>https://www.w3.org/TR/2016/WD-cssom-1-20160317/</dd>
	<dd>https://www.w3.org/TR/2015/WD-cssom-1-20150529/</dd>
	<dd>https://www.w3.org/TR/2013/WD-cssom-20131205/</dd>
	<dd>https://www.w3.org/TR/2011/WD-cssom-20110712/</dd>
	<dd>https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/</dd>

	<dt title="Test Suite:">テスト一式</dt>
	<dd>http://test.csswg.org/suites/cssom-1_dev/nightly-unstable</dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="#issues-index">仕様内</a></dd>
	<dd><a href="https://github.com/w3c/csswg-drafts/labels/cssom-1">GitHub Issues</a></dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="mailto:simonp@opera.com">Simon Pieters</a> (Opera Software ASA)</dd>
	<dd><a href="mailto:daniel.glazman@disruptive-innovations.com">Daniel Glazman</a> (<a href="http://disruptive-innovations.com/">Disruptive Innovations</a>)</dd>

	<dt title="Former Editors:">前任編集者</dt>
	<dd><a href="http://www.w3.org/wiki/User:Gadams">Glenn Adams</a> (Cox Communications, Inc.) <a href="mailto:glenn.adams@cos.com">glenn.adams@cos.com</a></dd>
	<dd><a href="https://annevankesteren.nl/">Anne van Kesteren</a> (Opera Software ASA) <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a></dd>

	<dt title="Legacy issues list:">旧来の課題リスト</dt>
	<dd><a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=CSS&amp;component=CSSOM&amp;resolution=---">Bugzilla</a></dd>

</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2017 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
</small>

</header>

	<section id="abstract">
<h2 title="Abstract">要約</h2>

  <p>
CSSOM は、 Media Queries, Selectors, および CSS 自身のための（一般的な構文解析と直列化の規則も含めた） API を定義する。
<span lang="en">
CSSOM defines APIs (including generic parsing and serialization rules) for Media Queries, Selectors, and of course CSS itself.
</span></p>


<p>
<a href="http://www.w3.org/TR/CSS/">CSS</a>
は、（ HTML や XML などの）構造を備える文書から，
スクリーン, 紙, スピーチ, 等々
の媒体への具現化法を記述するための言語である。
<span lang="en">
CSS is a language for describing the rendering of structured documents (such as HTML and XML) on screen, on paper, in speech, etc.
</span></p>


	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<span class="trans-note">【
以下、この節の内容は
<a href="css-common-ja.html#status" >CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>

	</section>

<main id="MAIN" style="display:none;">

	<section id="introduction">
<h2 title="Introduction">1. 概要</h2>

<p>
この文書は <abbr title="Cascading Style Sheet">CSS</abbr> Object Model （以下， “<abbr title="CSS Object Model">CSSOM</abbr>” ）の中核をなす特色機能を規定する。
CSSOM に基づく他の仕様, および他の CSS 関連の仕様は、これらの特色機能に対する拡張を定義する。
◎
This document formally specifies the core features of the CSS Object Model (CSSOM). Other documents in the CSSOM family of specifications as well as other CSS related specifications define extensions to these core features.
</p>

<p>
CSSOM の中核をなす特色機能は、作者定義~scriptから~style関連の状態~情報への~accessおよび操作を可能にするための，基本的な能力を提供することを目的とする。
◎
The core features of the CSSOM are oriented towards providing basic capabilities to author-defined scripts to permit access to and manipulation of style related state information and processes.
</p>

<div>
<p>
以下で定義される特色機能は、 W3C DOM Working Group の手による先行の仕様, 主に
`DOM-LEVEL-2-STYLE$r
を基にしている。
この文書の目的は：
</p>

<ul>
	<li>（試験し易さと相互運用性を向上させるため）より技術的な詳細を提供して，先行の仕事を向上させる。</li>
	<li>限られた~~範囲にしか実装されておらず，この文脈において最早~本質的とは見なされていない一部の特色機能を、非推奨に, もしくは除去する。</li>
	<li>広く実装されてきている, あるいはそうなるものと予期されている，ある種の拡張を新たに指定する。</li>
</ul>

◎
The features defined below are fundamentally based on prior specifications of the W3C DOM Working Group, primarily [DOM-LEVEL-2-STYLE]. The purposes of the present document are (1) to improve on that prior work by providing more technical specificity (so as to improve testability and interoperability), (2) to deprecate or remove certain less-widely implemented features no longer considered to be essential in this context, and (3) to newly specify certain extensions that have been or expected to be widely implemented.
</div>
	</section>

	<section id="_conventions">
<h3 class="trans-note">【日本語訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~ON, ~OFF, ~IN, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
加えて、次の記法も用いる：
</p>

<table>
<thead><tr><th style="min-width: 10em;">記法
</th><th>意味

</th></tr></thead>

<tbody><tr><th>%s ~APPEND %a ~APPEND %b ~APPEND …
</th><td>
左辺の文字列 %s の末尾に後続の文字列 %a, %b, … を示された順に~~付加する演算を表す。
式として用いられた場合、結果の %s がその値になる。

</td></tr><tr><th>~SP
</th><td>
<em>１個の</em> space 文字 `0020^cp を表す。

</td></tr><tr><th>
`~ACI@
</th><td>
この表記が添えられた ~EQ／~NEQ／~IN／~NIN は、
`~ASCII大小無視$による比較に基づくことを意味する。

</td></tr></tbody></table>

	</section>

	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様は、次の文書から一部の用語を取り入れている：
`DOM$r
`HTML$r
`CSS3SYN$r
`ENCODING$r
`URL$r
`FETCH$r
`XML-STYLESHEET$r
`XML$r
◎
This specification employs certain terminology from the following documents: DOM, HTML, CSS Syntax, Encoding, URL, Fetch, Associating Style Sheets with XML documents and XML. [DOM] [HTML] [CSS3SYN] [ENCODING] [URL] [FETCH] [XML-STYLESHEET] [XML]
</p>

<p>
`A^I を~ifcとするとき， “`A^I ~ifcを実装する~obj” の略記として、語 “`A^I ~obj” が用いられる。
◎
When this specification talks about object A where A is actually an interface, it generally means an object implementing interface A.
</p>

<p>
<dfn>set</dfn><!-- id="set" --> ／ <dfn>unset</dfn><!-- id="unset" -->
は、~flagや変数の
`true^c ／ `false^c
値を表す。
これらの語は、一部の値を `true^c ／ `false^c に~~変更する際にも用いられる。
<span class="trans-note">【
他の仕様の和訳との一貫性をとるため、この訳では，この語は利用せず，<a href="#_conventions">前節</a>に述べた ~ON, ~OFF を用いる。
】</span>
◎
The terms set and unset to refer to the true and false values of binary flags or variables, respectively. These terms are also used as verbs in which case they refer to mutating some value to make it true or false, respectively.
</p>

<p>
`~supportされる~styling言語@
は CSS を指す。
◎
The term supported styling language refers to CSS.
</p>

<p class="note">注記：
UA が他の~styling言語も~supportするようになった場合，この仕様も必要に応じて更新されることが予期されている。
◎
Note: If another styling language becomes supported in user agents, this specification is expected to be updated as necessary.
</p>

<p>
`~supportされる~css~prop@
は、~UAが実装する~css~propであって，~vendor接頭辞~付きの~propも含まれるが、`~custom~prop$は除外される。
この仕様における比較~目的においては、`~supportされる~css~prop$は小文字~化されてい~MUST。
◎
The term supported CSS property refers to a CSS property that the user agent implements, including any vendor-prefixed properties, but excluding custom properties. A supported CSS property must be in its lowercase form for the purpose of comparisons in this specification.
</p>

<p>
この仕様においては、どの要素に対しても［
`before$pe, `after$pe
］疑似要素は，存在するものと見なされる
— それらに対する~boxは生成されないとしても。
◎
In this specification the ::before and ::after pseudo-elements are assumed to exist for all elements even if no box is generated for them.
</p>

<p>
IDL ~ifc~member（~meth／属性）から別の~memberが呼ばれるときは、~UAは，~memberの内部 API を呼出さ~MUST
— すなわち、作者は独自の ECMAScript ~propや関数で上書きして，~memberのふるまいを変更することはできない。
◎
When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can’t change the behavior by overriding attributes or methods with custom properties or functions in ECMAScript.
</p>

<p>
特に指定されない限り、文字列の比較は `文字大小区別$で行われる。
◎
Unless otherwise stated, string comparisons are done in a case-sensitive manner.
</p>


<p class="trans-note">【
他の仕様からの，この仕様で利用される語の一部を下の一覧に挙げる
】</p>

<table><thead><tr><th style="min-width:10em;">語
</th><th style="min-width:14em;">参照先／原語表記  — 備考
</th></tr></thead>

<tbody><tr><th colspan="2">
以下は， `CSS21$r にて定義される：

<!-- 
</th></tr><tr><th>`空白@<!-&45; ＊ -&45;>
</th><td><a href="~CSS22/syndata.html#whitespace">whitespace</a>
 -->

</th></tr><tr><th>`無視される@
</th><td><a href="~CSS22/syndata.html#ignore">ignore</a>

</td></tr><tr><th colspan="2">
以下は， `CSS3CASCADE$r にて定義される：

</th></tr><tr><th>`~cascaded値@
</th><td><a href="~CASCADE#cascaded-value">cascaded value</a>

</td></tr><tr><th>`算出値@
</th><td><a href="~CASCADE#computed-value">computed value</a>

</td></tr><tr><th>`使用値@
</th><td><a href="~CASCADE#used-value">used value</a>
</td></tr>

<!-- 
cascade.at-import:`import^at
 -->

<tr><th>`初期値@
</th><td><a href="~CASCADE#initial-value">initial value</a>
</td></tr>

<tr><th>`指定値@
</th><td><a href="~CASCADE#specified-value">specified value</a>
</td></tr>

<tr><th>`略式~prop@
</th><td><a href="~CASCADE#shorthand-property">shorthand</a>
—
関連する一連の`下位prop$をまとめて指定する~prop
</td></tr>

<tr><th>`下位prop@
</th><td><a href="~CASCADE#longhand">longhand sub-properties</a>
</td></tr>

<tr><th>`正準的~順序@
</th><td>“canonical order” 
—
所与の`略式~prop$を規定する仕様において，その~propの定義表の中の値~定義 欄に示されている`下位prop$を直列化する順序を意味する（定義表の中で別途，その順序を指定する欄が設けられることもある）。
</td></tr>

<!-- 
規則集合
<a href="~CSS22/syndata.html#rule-sets">rule set</a>,
~css宣言~block
<a href="~CSS22/syndata.html#rule-sets">declaration block</a>,
~css宣言
<a href="~CSS22/syndata.html#declaration">declaration</a>,
呈示hint
<a href="~CASCADE#preshint" >presentational hints</a>,
-->

<tr><th colspan="2">
以下は， `SELECTORS4$r にて定義される：

</th></tr><tr><th>`選択子@
</th><td><a href="~SELECTORS#selector">selector</a>
—
以下に挙げられる “選択子~list” と “〜選択子” の総称。

</td></tr><tr><th>`選択子~list@
</th><td><a href="~SELECTORS#selector-list">selector list</a>
—
原文には Selectors Level 3 までの呼称
`group of selectors@
（“選択子群”）が用いられているが、この訳では， Selectors Level 4 に基づく呼称に変更している。
</td></tr>
<tr><th>`複体~選択子@
</th><td><a href="~SELECTORS#complex">complex selector</a>
— 
`結合子$で連結された`合体~選択子$の並び。
Selectors Level 4 にて（選択子の構造をより明確に述べるために）導入された語。
一部の~algoの定義を明確化するため，この訳ではこの語を利用する。

</td></tr><tr><th>`合体~選択子@
</th><td><a href="~SELECTORS#compound">compound selector</a>

</td></tr><tr><th>`単体~選択子@
</th><td><a href="~SELECTORS#simple">simple selector</a>

</td></tr><tr><th>`全称~選択子@
</th><td><a href="~SELECTORS#universal-selector">universal selector</a>
</td></tr>

<tr><th>`属性~選択子@
</th><td><a href="~SELECTORS#attribute-selector">attribute selector</a>
</td></tr>

<tr><th>`ID 選択子@
</th><td><a href="~SELECTORS#id-selector">ID selector</a>
</td></tr>

<tr><th>`型~選択子@
</th><td><a href="~SELECTORS#type-selector">type selector</a>
</td></tr>

<tr><th>`~class選択子@
</th><td><a href="~SELECTORS#class-selector">class selector</a>
</td></tr>


<tr><th>`疑似類@
</th><td><a href="~SELECTORS#pseudo-class">pseudo-class</a>
</td></tr>

<tr><th>`疑似要素@
</th><td><a href="~SELECTORS#pseudo-element">pseudo-element</a>
</td></tr>

<tr><th>`結合子@
</th><td><a href="~SELECTORS#combinator">combinator</a>

</td></tr><tr><th colspan="2">
以下は， `CSS3NAMESPACE$r にて定義される：

</th></tr><tr><th>`名前空間~接頭辞@
</th><td><a href="~CSSNS#namespace-prefix">namespace prefix</a>

</td></tr><tr><th>`既定の名前空間@
</th><td><a href="~CSSNS#default-namespace">default namespace</a>
</td></tr>

<tr><th>`~null名前空間@
</th><td><a href="~CSSNS#terminology">null namespace</a>
— どの名前空間にも属さないことを意味する。

</td></tr><tr><th colspan="2">
以下は， `CSS3PAGE$r にて定義される：

</th></tr><tr><th>`頁~選択子@
</th><td><a href="~CSSPAGE#page-selectors">page selector</a>

</td></tr><tr><th>`~margin at-規則@
</th><td><a href="~CSSPAGE#margin-at-rules">margin at-rules</a>
— page-margin box を作成する種々の at-規則の総称

</td></tr><tr><th>`~css頁~選択子の~list@
</th><td><a href="~CSSPAGE#page_selector_list">page_selector_list</a>
— `頁~選択子$の，~comma区切りによる~list


</td></tr><tr><th colspan="2">
以下は， `MEDIAQUERIES-4$r にて定義される：

</th></tr><tr><th>`媒体~照会@
</th><td><a href="~MQ4#media">media query</a>

</td></tr><tr><th>`媒体~特能@
</th><td><a href="~MQ4#mq-features">media feature</a>

</td></tr><tr><th colspan="2">
以下は， `DOM$r にて定義される：

</th></tr><tr><th>`文書の文字~符号化方式@
</th><td>
<a href="~DOM4#concept-document-encoding">document’s character encoding</a>

</td></tr><tr><th>`Document@I
</th><td><a href="~DOM4#interface-document">Document</a>
— `Document^I ~objを指して，単に`文書$とも記すことにする。

</td></tr><tr><th>`Element@I
</th><td><a href="~DOM4#interface-element">Element</a>

</td></tr><tr><th>`ProcessingInstruction@I
</th><td><a href="~DOM4#interface-processinginstruction">ProcessingInstruction</a>

</td></tr><tr><th>`~node@
</th><td><a href="~DOM4#concept-node">node</a>

</td></tr><tr><th colspan="2">
以下は，その他の仕様にて定義される：

</th></tr><tr><th>`before@pe, `after@pe 疑似要素
</th><td>
<a href="~TR/css-pseudo-4/#selectordef-before">`before^pe</a>,
<a href="~TR/css-pseudo-4/#selectordef-after">`after^pe</a>
— `CSS-PSEUDO-4$r

</td></tr><tr><th>`環境~符号化方式@
</th><td><a href="~CSSSYN#environment-encoding">environment encoding</a>
— `CSS3SYN$r

</td></tr><tr><th>`符号化方式を取得@
</th><td><a href="~ENCODING#concept-encoding-get">get an encoding</a>
— `ENCODING$r

</td></tr><tr><th>`CORS 同一生成元@
</th><td>
<a href="~HTMLINFRA#cors-same-origin">CORS-same-origin</a>
— `HTML$r

</td></tr></tbody></table>


<!-- 
<tr><th colspan="2">
以下は，
<a href="~MQ4" >Media Queries</a>
にて定義される：
</th></tr><tr><th>@media-query
</th><td><a href="~MQ4#media0" >media query</a>

</td></tr><tr><th>@media-feature
</th><td><a href="~MQ4#media1" >media feature</a>
</td></tr>

	<dt>各種~error名 <code><var>XXX</var>Error</code></dt>
	<dd><p>
WebIDL 仕様の
<a href="http://heycam.github.io/webidl/#idl-DOMException-error-names">~error名</a>
</dd>

selectors.grouping:選択子の~group化

	selectors3 := http://www.w3.org/TR/css3-selectors/
selectors3#simple-selector
selectors3#sequence
selectors3#universal-selector
selectors3#grouping

selectors:selectors3#selector
attribute-selectors:selectors3#attribute-selectors
id-selectors:selectors3#id-selectors
type-selectors:selectors3#type-selectors
class-html:selectors3#class-html
pseudo-classes:selectors3#pseudo-classes
pseudo-elements:selectors3#pseudo-elements
combinators:selectors3#combinators
-->


		<section id="common-serializing-idioms">
<h3 title="Common Serializing Idioms">2.1. 直列化-時の成句的な手続き</h3>

<p class="algo-head">
文字 %c を
`~escape@
するときは、文字列［
❝\ ~APPEND %c
］を生成する。
◎
To escape a character means to create a string of "\" (U+005C), followed by the character.
</p>

<p class="algo-head">
文字 %c を
`符号位置として~escape@
するときは、文字列［
❝\
~APPEND［
基数 16 の下で， %c の Unicode 符号位置を最小個数の 16 進~数字（ { ❝0 〜 ❝9, ❝a 〜 ❝f } の文字）で表現する文字~並び
］~APPEND ~SP
］を生成する。
◎
To escape a character as code point means to create a string of "\" (U+005C), followed by the Unicode code point as the smallest possible number of hexadecimal digits in the range 0-9 a-f (U+0030 to U+0039 and U+0061 to U+0066) to represent the code point in base 16, followed by a single SPACE (U+0020).
</p>

<p class="algo-head">
文字列 %入力 を
`識別子として直列化-@
するときは、次を走らせた結果を返す：
◎
To serialize an identifier means to create a string represented by the concatenation of, for each character of the identifier:
</p>

<p class="trans-note">【
これは
<a href="~CSSVAL#identifier">~css識別子</a>
を生成する
】</p>


<ol>
 <li>
~IF［
%入力 ~EQ ❝-
］
⇒
~RET ❝- を`~escape$した結果
◎
↓↓</li>
 <li>
%文字列 ~LET 空文字列
◎
↑</li>
 <li>
<p>
~FOR
%入力 内の ~EACH ( 文字 %c ) に対し順に，
%c に応じて：
◎
↑</p>

  <dl class="switch">
   <dt>`0000^cp（ NULL ）</dt>
   <dd>
%文字列
~APPEND
`FFFD^cp（ REPLACEMENT CHARACTER ）
◎
If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
</dd>

   <dt>`0001^cp 〜 `001F^cp</dt>
   <dt>`007F^cp</dt>
   <dd>
%文字列
~APPEND［
%c を`符号位置として~escape$した結果
］
◎
If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F, then the character escaped as code point.
</dd>

   <dt>❝0 〜 ❝9</dt>
   <dd>
    <ol>
     <li>
~IF［
これは初回の反復である
］
⇒
%文字列
~APPEND［
%c を`符号位置として~escape$した結果
］
</li>
     <li>
~ELIF［
これは２回目の反復である
］~AND［
%入力 の最初の文字 ~EQ ❝-
］
⇒
%文字列
~APPEND［
%c を`~escape$した結果
］
</li>
     <li>
~ELSE
⇒
%文字列
~APPEND %c
</li>
   </ol>
◎
If the character is the first character and is in the range [0-9] (U+0030 to U+0039), then the character escaped as code point.
◎
If the character is the second character and is in the range [0-9] (U+0030 to U+0039) and the first character is a "-" (U+002D), then the character escaped as code point.
◎
↓
◎
↑↑
If the character is the first character and is a "-" (U+002D), and there is no second character, then the escaped character.
</dd>

   <dt>`0080^cp 以上</dt>
   <dt>❝-</dt>
   <dt>❝_</dt>
   <dt>❝A 〜 ❝Z</dt>
   <dt>❝a 〜 ❝z</dt>
   <dd>
%文字列
~APPEND %c
◎
If the character is not handled by one of the above rules and is greater than or equal to U+0080, is "-" (U+002D) or "_" (U+005F), or is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to U+005A), or \[a-z] (U+0061 to U+007A), then the character itself.
</dd>

   <dt>その他</dt>
   <dd>
%文字列
~APPEND［
%c を`~escape$した結果
］
◎
Otherwise, the escaped character.
</dd>

  </dl>
 </li>
 <li>
~RET %文字列
◎
↑</li>
</ol>


<p class="algo-head">
文字列 %入力 を
`文字列として直列化-@
するときは、次を走らせた結果を返す：
◎
To serialize a string means to create a string represented by '"' (U+0022), followed by the result of applying the rules below to each character of the given string, followed by '"' (U+0022):
</p>

<p class="trans-note">【
これは
<a href="~CSSVAL#string">~css文字列</a>
を生成する
】</p>


<ol>
 <li>
%文字列 ~LET ❝"
◎
↑</li>
 <li>
<p>
~FOR
%入力 内の ~EACH ( 文字 %c ) に対し順に，
%c に応じて：
◎
↑</p>

  <dl class="switch">
   <dt>`0000^cp（ NULL ）</dt>
   <dd>
%文字列
~APPEND［
`FFFD^cp（ REPLACEMENT CHARACTER ）
を`符号位置として~escape$した結果
］
◎
If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD) escaped as code point.
</dd>

   <dt>`0001^cp 〜 `001F^cp</dt>
   <dt>`007F^cp</dt>
   <dd>
%文字列
~APPEND［
%c を`符号位置として~escape$した結果
］
◎
If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F, the character escaped as code point.
</dd>

   <dt>❝"</dt>
   <dt>❝\</dt>
   <dd>
%文字列
~APPEND［
%c を`~escape$した結果
］
◎
If the character is '"' (U+0022) or "\" (U+005C), the escaped character.
</dd>

   <dt>その他</dt>
   <dd>
%文字列
~APPEND %c
◎
Otherwise, the character itself.
</dd>
  </dl>
 </li>
 <li>
%文字列
~APPEND ❝"
◎
↑</li>
 <li>
~RET %文字列
◎
↑</li>
</ol>


<p class="note">注記：
❝' は~escapeされない。
文字列は常に ❝" で括られた形で直列化されるので。
◎
Note: "'" (U+0027) is not escaped because strings are always serialized with '"' (U+0022).
</p>

<p class="algo-head">
所与の文字列 %url を
`~URLとして直列化-@
するときは
⇒
文字列［
`url(^l
~APPEND［
%url を `文字列として直列化-$した結果
］
~APPEND ❝)
］を生成する。
◎
To serialize a URL means to create a string represented by "url(", followed by the serialization of the URL as a string, followed by ")".
</p>

<p class="algo-head">
文字列の~listを
`~comma区切りで直列化-@
するときは
⇒
~listの中の~EACH ( 文字列  ) を，
`, ^l （すなわち［
❝, ~APPEND ~SP
］）で区切って ~list順に連結する。
◎
To serialize a comma-separated list concatenate all items of the list in list order while separating them by ", ", i.e., COMMA (U+002C) followed by a single SPACE (U+0020).
</p>

<p class="algo-head">
文字列の~listを
`空白~区切りで直列化-@
するときは
⇒
~listの中の~EACH ( 文字列  ) を， ~SP で区切って ~list順に連結する。
◎
To serialize a whitespace-separated list concatenate all items of the list in list order while separating them by " ", i.e., a single SPACE (U+0020).
</p>

<p class="note">注記：
上の規則により~listを直列化する際には、その先頭／末尾に余分な空白は挿入されない。
特に指定されない限り、空~listは，空文字列に直列化される。
◎
Note: When serializing a list according to the above rules, extraneous whitespace is not inserted prior to the first item or subsequent to the last item. Unless otherwise specified, an empty list is serialized as the empty string.
</p>

		</section>
	</section>
	<section id="media-queries">
<h2 title="Media Queries">3. 媒体~照会</h2>

<p>
`媒体~照会$は Media Queries 仕様にて定義される。
この節では、 API や直列化の形も含めた，`媒体~照会$を取り巻く種々の概念を定義する。
◎
Media queries are defined by the Media Queries specification. This section defines various concepts around media queries, including their API and serialization form.
</p>

		<section id="parsing-media-queries">
<h3 title="Parsing Media Queries">3.1. 媒体~照会の構文解析法</h3>

<p class="algo-head">
所与の文字列を
`媒体~照会~listとして構文解析-@
する~algoは，Media Queries 仕様にて定義される。
これは，一連の`媒体~照会$からなる~listを返す。
◎
To parse a media query list for a given string s into a media query list is defined in the Media Queries specification. Return the list of media queries that the algorithm defined there gives.
</p>

<p class="note">注記：
結果が “無視される”
<span class="trans-note">【
“ignored”
】</span>
`媒体~照会$は、 `not all^l に変換されることになる。
◎
Note: A media query that ends up being "ignored" will turn into "not all".
</p>

<p class="algo-head">
所与の文字列 %文字列 を
`媒体~照会として構文解析-@
するときは
⇒
［
%文字列 を`媒体~照会~listとして構文解析-$した結果
］に含まれる`媒体~照会$の個数が，［
1 個ならば その`媒体~照会$ ／
~ELSE_ ~NULL
］を返す。
◎
To parse a media query for a given string s means to follow the parse a media query list steps and return null if more than one media query is returned or a media query if a single media query is returned.
</p>

<p class="note">注記：
ここでも， “無視される” `媒体~照会$は、 `not all^l に変換されることになる。
◎
Note: Again, a media query that ends up being "ignored" will turn into "not all".
</p>
		</section>
		<section id="serializing-media-queries">
<h3 title="Serializing Media Queries">3.2. 媒体~照会の直列化法</h3>

<p class="algo-head">
媒体~照会~list %~list を
`媒体~照会~listとして直列化-@
するときは、次を走らす：
◎
To serialize a media query list run these steps:
</p>

<ol>
 <li>
~IF［
%~list は空である
］
⇒
~RET 空文字列
◎
If the media query list is empty return the empty string and terminate these steps.
</li>
 <li>
~RET ［
%~list 内の ~EACH ( `媒体~照会$ ) を `媒体~照会として直列化-$して得られる，
%~list の順序による~list
］を，`~comma区切りで直列化-$した結果
◎
Serialize each media query in the list of media queries, in the same order as they appear in the list of media queries, and then serialize the list.
</li>
</ol>

<p class="algo-head">
`媒体~照会$ %媒体~照会 を
`媒体~照会として直列化-@
するときは、次を走らす：
◎
To serialize a media query let s be the empty string, run the steps below, and finally return s:
</p>

<ol>
 <li>
%文字列 ~LET 空文字列
◎
↑</li>
 <li>
~IF［
%媒体~照会 は否定形である
］
⇒
%文字列
~APPEND `not^l
~APPEND ~SP
◎
If the media query is negated append "not", followed by a single SPACE (U+0020), to s.
</li>
 <li>
%型 ~LET
%媒体~照会 の媒体~型を `識別子として直列化-$した上で，`~ASCII小文字~化$した結果
◎
Let type be the serialization as an identifier of the media type of the media query, converted to ASCII lowercase.
</li>
 <li>
~IF［
%媒体~照会 に`媒体~特能$は含まれていない
］
⇒
~RET %文字列
~APPEND %型
◎
If the media query does not contain media features append type, to s, then return s and terminate this algorithm.
</li>
 <li>
~IF［
%型 ≠ `all^l
］~OR［
%媒体~照会 は否定形である
］
⇒
%文字列
~APPEND %型
~APPEND ~SP
~APPEND `and^l
~APPEND ~SP
◎
If type is not "all" or if the media query is negated append type, followed by a single SPACE (U+0020), followed by "and", followed by a single SPACE (U+0020), to s.
</li>
 <li>
<p>
%媒体~照会 内の~EACH ( `媒体~特能$ %特能 ) に対し，辞書式~順序で：
◎
Sort the media features in lexicographical order.
◎
Then, for each media feature:
</p>

  <ol>
   <li>
%文字列
~APPEND ❝(
~APPEND［
%特能 の名前を`~ASCII小文字~化$した結果
］
◎
Append a "(" (U+0028), followed by the media feature name, converted to ASCII lowercase, to s.
</li>
   <li>
~IF［
%特能 に値は与えられている
］
⇒
%文字列
~APPEND ❝:
~APPEND ~SP
~APPEND［
%特能 の値を `媒体~特能~値として直列化-$した結果
］
◎
If a value is given append a ":" (U+003A), followed by a single SPACE (U+0020), followed by the serialized media feature value, to s.
</li>
   <li>
%文字列
~APPEND ❝)
◎
Append a ")" (U+0029) to s.
</li>
   <li>
~IF［
この反復は最後でない
］
⇒
%文字列
~APPEND ~SP
~APPEND `and^l
~APPEND ~SP
◎
If this is not the last media feature append a single SPACE (U+0020), followed by "and", followed by a single SPACE (U+0020), to s.
</li>
  </ol>
 </li>
 <li>
~RET %文字列
◎
</li>
</ol>

<div class="example">
<p>
例を示す（長い行は折り~~返されている）：
◎
Here are some examples of input (first column) and output (second column):
</p>

<table>
<thead><tr><th>入力◎Input
</th><th>出力◎Output
</th></tr></thead>

<tbody><tr><td>`not screen and (min-WIDTH:5px) AND (max-width:40px)^css
</td><td>`not screen and (max-width: 40px) and (min-width: 5px)^css

</td></tr><tr><td>`all and (color) and (color)^css
</td><td>`(color)^css

</td></tr></tbody>
</table>

</div>

			<section id="serializing-media-feature-values">
<h4 title="Serializing Media Feature Values">3.2.1. 媒体~特能~値の直列化法</h4>

<p class="issue">
これは~css値の直列化に対応付けることを通して定義されるべきであろう
— その上で，`媒体~特能$については~css値を通して定義されるように。
◎
This should probably be done in terms of mapping it to serializing CSS values as media features are defined in terms of CSS values after all.
</p>

<p class="algo-head">
名前 %v の`媒体~特能$の値を
`媒体~特能~値として直列化-@
するときは、下の一覧の最初の列から， %v に一致する行の２列目に記されている直列化~形式を用いる：
◎
To serialize a media feature value named v locate v in the first column of the table below and use the serialization format described in the second column:
</p>

<table><thead><tr><th>`媒体~特能$◎Media Feature
</th><th>直列化◎Serialization
</th></tr></thead>

<tbody><tr><td>`width$d
</td><td>~UNSPECIFIED

</td></tr><tr><td>`height$d
</td><td>~UNSPECIFIED

</td></tr><tr><td>`device-width$d
</td><td>~UNSPECIFIED

</td></tr><tr><td>`device-height$d
</td><td>~UNSPECIFIED

</td></tr><tr><td>`orientation$d
</td><td>
値 ~EQ `portrait^v ならば `portrait^l,<br>
値 ~EQ `landscape^v ならば `landscape^l
◎
If the value is portrait: "portrait". If the value is landscape: "landscape".

</td></tr><tr><td>`aspect-ratio$d
</td><td>~UNSPECIFIED

</td></tr><tr><td>`device-aspect-ratio$d
</td><td>~UNSPECIFIED

</td></tr><tr><td>`color$d
</td><td>~UNSPECIFIED

</td></tr><tr><td>`color-index$d
</td><td>~UNSPECIFIED

</td></tr><tr><td>`monochrome$d
</td><td>~UNSPECIFIED

</td></tr><tr><td>`resolution$d
</td><td>~UNSPECIFIED

</td></tr><tr><td>`scan$d
</td><td>
値 ~EQ `progressive^v ならば `progressive^l,<br>
値 ~EQ `interlace^v ならば `interlace^l
◎
If the value is progressive: "progressive". If the value is interlace: "interlace".

</td></tr><tr><td>`grid$d
</td><td>~UNSPECIFIED

</td></tr></tbody></table>

<p>
他の仕様はこの一覧を拡張でき，また~vendor接頭辞~付きの`媒体~特能$は独自の直列化~形式を持ち得る。
◎
Other specifications can extend this table and vendor-prefixed media features can have custom serialization formats as well.
</p>

			</section>
		</section>
		<section id="comparing-media-queries">
<h3 title="Comparing Media Queries">3.3. 媒体~照会の比較</h3>

<p>
２つの`媒体~照会$ %m1 と %m2 が
`同値@
であるとは、それらを`媒体~照会として直列化-$した結果が同じになることを意味する。
<span class="trans-note">【
簡潔に記すため，当訳では原文の語 “比較” （
<dfn id="compare-media-queries">compare media queries</dfn>
）から 言い回しを変えている。
】</span>
◎
To compare media queries m1 and m2 means to serialize them both and return true if they are a case-sensitive match and false if they are not.
</p>
		</section>
		<section id="the-medialist-interface">
<h3 title="The MediaList Interface">3.4. `MediaList^I ~ifc</h3>

<p>
`MediaList$I ~ifcを実装する~objには，
`媒体~照会~collection@
が結付けられる。
◎
An object that implements the MediaList interface has an associated collection of media queries.
</p>

⇒！
[`LegacyArrayClass$]
interface `MediaList@I {
  [`TreatNullAs$=EmptyString] stringifier attribute ~DS `mediaText$m;
  ~RA ~UL `length$m;
  getter ~DS? `item$m(~UL %index);
  void `appendMedium$m(~DS %medium);
  void `deleteMedium$m(~DS %medium);
};◎

<p>
~objの
`被support~prop~index$
の範囲は［
0 〜 ( ( ~collectionで表現される`媒体~照会~collection$に含まれている媒体~照会の総数 ) ~MINUS 1 )
］である（~collectionが空なら存在しないことになる）。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of media queries in the collection of media queries represented by the collection. If there are no such media queries, then there are no supported property indices.
</p>

<p class="algo-head">
文字列 %~text に対し，
`~MediaList~objを作成-@
するときは、次を走らす：
◎
To create a MediaList object with a string text, run the following steps:
</p>

<ol>
 <li>
%MediaList ~LET 新たな `MediaList$I ~obj
◎
Create a new MediaList object.
</li>
 <li>
%MediaList の `mediaText$m 属性 ~SET %~text
◎
Set its mediaText attribute to text.
</li>
 <li>
~RET %MediaList
◎
Return the newly created MediaList object.
</li>
</ol>


<dl class="idl-def">
	<dt>`mediaText@m</dt>
	<dd>
取得子は、［
此れの`媒体~照会~collection$を `媒体~照会~listとして直列化-$した結果
］を返さ~MUST。
◎
The mediaText attribute, on getting, must return a serialization of the collection of media queries.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
Setting the mediaText attribute must run these steps:
</p>

<ol>
 <li>
此れの`媒体~照会~collection$を空にする
◎
Empty the collection of media queries.
</li>
 <li>
~IF［
所与の値 ~EQ 空文字列
］
⇒
~RET
◎
If the given value is the empty string terminate these steps.
</li>
 <li>
［
所与の値を`媒体~照会~listとして構文解析-$した結果
］に含まれるすべての媒体~照会を，此れの`媒体~照会~collection$に付加する
◎
Append all the media queries as a result of parsing the given value to the collection of media queries.
</li>
</ol>

</dd>

	<dt>`item(index)@m</dt>
	<dd>
<p>
被呼出時には、［
%index が範囲~外ならば ~NULL ／
~ELSE_ ［
此れの`媒体~照会~collection$の中で %index に位置する`媒体~照会$
］を`媒体~照会~listとして直列化-$した結果
］を返さ~MUST。
◎
The item(index) method must return a serialization of the media query in the collection of media queries given by index, or null, if index is greater than or equal to the number of media queries in the collection of media queries.
</p>

</dd>

	<dt>`length@m</dt>
	<dd>
取得子は、此れの`媒体~照会~collection$に含まれる`媒体~照会$の個数を返さ~MUST。
◎
The length attribute must return the number of media queries in the collection of media queries.
</dd>

	<dt>`appendMedium(medium)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The appendMedium(medium) method must run these steps:
</p>

<ol>
 <li>
%m ~LET
%medium を`媒体~照会として構文解析-$した結果
◎
Let m be the result of parsing the given value.
</li>
 <li>
~IF［
%m ~EQ ~NULL
］
⇒
~RET
◎
If m is null terminate these steps.
</li>
 <li>
~IF［
此れの`媒体~照会~collection$ の中に %m と`同値$な`媒体~照会$は無い
］
⇒
%m を此れの`媒体~照会~collection$に付加する
◎
If comparing m with any of the media queries in the collection of media queries returns true terminate these steps.
◎
Append m to the collection of media queries.
</li>
</ol>

</dd>

	<dt>`deleteMedium(medium)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The deleteMedium(medium) method must run these steps:
</p>

<ol>
 <li>
%m ~LET
%medium を`媒体~照会として構文解析-$した結果
◎
Let m be the result of parsing the given value.
</li>
 <li>
~IF［
%m ~EQ ~NULL
］
⇒
~RET
◎
If m is null terminate these steps.
</li>
 <li>
~IF［
此れの`媒体~照会~collection$ の中に %m と`同値$な`媒体~照会$は在る
］
⇒
その媒体~照会を此れの`媒体~照会~collection$から除去する
◎
Remove any media query from the collection of media queries for which comparing the media query with m returns true. If nothing was removed, then throw a NotFoundError exception.
</li>
 <li>
~ELSE
⇒
~THROW `NotFoundError$E
◎
↑</li>
</ol>
	</dd>
</dl>


		</section>
	</section>
	<section id="selectors">
<h2 title="Selectors">4. 選択子</h2>

<p>
`選択子$は Selectors 仕様にて定義される。
この節では主にそれらを直列化する方法を定義する。
◎
Selectors are defined in the Selectors specification. This section mainly defines how to serialize them.
</p>

		<section id="parsing-selectors">
<h3 title="Parsing Selectors">4.1. 選択子の構文解析法</h3>

<p class="algo-head">
所与の値を
`選択子~listとして構文解析-@
するときは
⇒
Selectors 仕様にて定義されている
<del>`selector^t</del>
<ins>`selector-list$t</ins>
を用いてその値を構文解析して，それが［
失敗しなかったならば 結果の`選択子~list$ ／
失敗した場合は ~NULL
］を返す。
◎
To parse a group of selectors means to parse the value using the selectors_group production defined in the Selectors specification and return either a group of selectors if parsing did not fail or null if parsing did fail.
</p>
		</section>
		<section id="serializing-selectors">
<h3 title="Serializing Selectors">4.2. 選択子の直列化法</h3>

<p class="algo-head">
`選択子~list$を
`選択子~listとして直列化-@
するときは
⇒
選択子~list内の~EACH ( `複体~選択子$ ) を`選択子として直列化-$して得られる~listを`~comma区切りで直列化-$する。
◎
To serialize a group of selectors serialize each selector in the group of selectors and then serialize a comma-separated list of these serializations.
</p>

<p class="algo-head">
`複体~選択子$を
`選択子として直列化-@
するときは、次を走らせた結果の %文字列 を返す：
◎
To serialize a selector let s be the empty string, run the steps below for each part of the chain of the selector, and finally return s:
</p>

<ol>
 <li>
%文字列 ~LET 空文字列
◎
↑</li>
 <li>
<p>
`複体~選択子$内の~EACH ( `合体~選択子$ %seq ) に対し，順に：
◎
↑</p>

  <ol>
   <li>
~IF［
%seq は１個の`全称~選択子$のみからなる
<!-- 
%seq は１個の`単体~選択子$のみからなる`合体~選択子$である ~AND
それは`全称~選択子$である
 -->
］
⇒
%文字列
~APPEND［
その`全称~選択子$を`単体~選択子として直列化-$した結果
］
◎
If there is only one simple selector in the compound selectors which is a universal selector, append the result of serializing the universal selector to s.
</li>
   <li>
~ELSE
⇒
%seq 内の~EACH ( `単体~選択子$ %選択子 ) に対し
⇒
~IF［
%選択子 は`全称~選択子$でない
］~OR［
%選択子 の`名前空間~接頭辞$は`既定の名前空間$でない名前空間に対応する
］
⇒
%文字列
~APPEND［
%選択子 を`単体~選択子として直列化-$した結果
］
◎
Otherwise, for each simple selector in the compound selectors that is not a universal selector of which the namespace prefix maps to a namespace that is not the default namespace serialize the simple selector and append the result to s.
</li>
   <li>
<p>
~IF［
%seq は最後の`合体~選択子$でない
<span class="trans-note">【
すなわち，`結合子$が後続する
】</span>
］：
</p>
    <ol>
     <li>
%文字列
~APPEND ~SP
</li>
     <li>
<p>
~IF［
`結合子$ %結合子 は ~SP のみでない
］
⇒
%文字列
~APPEND %結合子
~APPEND ~SP
</p>

<p>
%結合子 は次のいずれか適切なものとする
⇒
`003E^cp（ `&gt;^l ）,
❝+,
❝~,
`&gt;&gt;^l,
`||^l
</p>

     </li>
    </ol>

◎
If this is not the last part of the chain of the selector append a single SPACE (U+0020), followed by the combinator "&gt;", "+", "~", "&gt;&gt;", "||", as appropriate, followed by another single SPACE (U+0020) if the combinator was not whitespace, to s.
</li>
   <li>
~ELIF［
%seq 内に`疑似要素$がある
］
⇒
%文字列
~APPEND `::^l
~APPEND その疑似要素の名前
◎
If this is the last part of the chain of the selector and there is a pseudo-element, append "::" followed by the name of the pseudo-element, to s.
</li>
  </ol>
 </li>
 <li>
~RET %文字列
</li>
</ol>

<p>
`単体~選択子$ %選択子 を
`単体~選択子として直列化-@
するときは、次を走らせた結果の %文字列 を返す：
◎
To serialize a simple selector let s be the empty string, run the steps below, and finally return s:
</p>

<ol>
 <li>
<p>
%文字列 ~LET 空文字列
◎
↑</p></li>
 <li>
<p>
%選択子 の種別に応じて：
◎
↓</p>

  <dl class="switch">
   <dt>`型~選択子$</dt>
   <dt>`全称~選択子$</dt>
   <dd>
    <ol>
     <li>
%接頭辞 ~LET %選択子 の`名前空間~接頭辞$
◎
↓</li>
     <li>
~IF［
%接頭辞 は［
`~null名前空間$でも
`既定の名前空間$でもない名前空間
］に対応する
］
⇒
%文字列
~APPEND［
%接頭辞 を`識別子として直列化-$した結果
］
~APPEND ❝|
◎
If the namespace prefix maps to a namespace that is not the default namespace and is not the null namespace (not in a namespace) append the serialization of the namespace prefix as an identifier, followed by a "|" (U+007C) to s.
</li>
     <li>
~IF［
%接頭辞 は`~null名前空間$に対応する
］
⇒
%文字列
~APPEND ❝|
◎
If the namespace prefix maps to a namespace that is the null namespace (not in a namespace) append "|" (U+007C) to s.
</li>
     <li>
~IF［
%選択子 は`型~選択子$である
］
⇒
%文字列
~APPEND［
要素~名を`識別子として直列化-$した結果
］
◎
If this is a type selector append the serialization of the element name as an identifier to s.
</li>
     <li>
~ELSE （ %選択子 は`全称~選択子$である）
⇒
%文字列
~APPEND ❝*
◎
If this is a universal selector append "*" (U+002A) to s.
</li>
    </ol>
   </dd>

   <dt>`属性~選択子$</dt>
   <dd>
    <ol>
     <li>
%接頭辞 ~LET %選択子 の`名前空間~接頭辞$
◎
↓</li>
     <li>
%文字列
~APPEND ❝[
◎
Append "[" (U+005B) to s.
</li>
     <li>
~IF［
%接頭辞 は`~null名前空間$でない名前空間に対応する
］
⇒
%文字列
~APPEND［
%接頭辞 を`識別子として直列化-$した結果
］
~APPEND ❝|
◎
If the namespace prefix maps to a namespace that is not the null namespace (not in a namespace) append the serialization of the namespace prefix as an identifier, followed by a "|" (U+007C) to s.
</li>
     <li>
%文字列
~APPEND［
%選択子 の属性~名を`識別子として直列化-$した結果
］
◎
Append the serialization of the attribute name as an identifier to s.
</li>
     <li>
<p>
~IF［
%選択子 に属性~値が指定されている
］：
</p>

      <ol>
       <li>
%区切子 ~LET `属性~選択子$の種別に応じて，次のいずれか適切なもの
⇒
❝=,
`~=^l,
`|=^l,
"<code class="literal">^=</code>",
"<code class="literal">$=</code>",
`*=^l
</li>
       <li>
%文字列
~APPEND %区切子
~APPEND［
%選択子 の属性~値を`文字列として直列化-$した結果
］
</li>
     </ol>
◎
If there is an attribute value specified, append "=", "~=", "|=", "^=", "$=", or "*=" as appropriate (depending on the type of attribute selector), followed by the serialization of the attribute value as a string, to s.
</li>
     <li>
<p>
~IF［
属性~選択子の case-sensitivity ~flag†
~EQ ~ON
］
⇒
%文字列
~APPEND ~SP
~APPEND ❝i
◎
If the attribute selector has the case-sensitivity flag present, append " i" (U+0020 U+0069) to s.
</p>

<p class="trans-note">【†
属性~値の
<a href="~SELECTORS#attribute-case">文字大小が区別される</a>
なら ~ON 。
】</p>

	</li>

     <li>
%文字列
~APPEND ❝]
◎
Append "]" (U+005D) to s.
</li>
    </ol>
   </dd>

   <dt>`~class選択子$</dt>
   <dd>
%文字列
~APPEND ❝.
~APPEND［
%選択子 の class 名を`識別子として直列化-$した結果
］
◎
Append a "." (U+002E), followed by the serialization of the class name as an identifier to s.
</dd>

   <dt>`ID 選択子$</dt>
   <dd>
%文字列
~APPEND ❝#
~APPEND［
%選択子 の ID を`識別子として直列化-$した結果
］
◎
Append a "#" (U+0023), followed by the serialization of the ID as an identifier to s.
</dd>

   <dt>`疑似類$</dt>
   <dd>
    <ol>
     <li>
%文字列
~APPEND ❝:
~APPEND その`疑似類$の名前
◎
If the pseudo-class does not accept arguments append ":" (U+003A), followed by the name of the pseudo-class, to s.
◎
Otherwise, append ":" (U+003A), followed by the name of the pseudo-class, followed by "(" (U+0028), followed by the value of the pseudo-class argument(s) determined as per below, followed by ")" (U+0029), to s.
</li>
     <li>
<p>
~IF［
%選択子 は引数をとる`疑似類$である
］：
◎
↑</p>
      <ol>
       <li>
%文字列
~APPEND ❝(
◎
↑</li>
       <li>
<p>
%選択子 の`疑似類$に応じて：
◎
↑</p>
        <dl class="switch">
         <dt>`lang()$ps</dt>
         <dd>
%文字列
~APPEND ［
~EACH ( 引数~値 ) を`文字列として直列化-$して得られる~list
］を`~comma区切りで直列化-$した結果
◎
The serialization of a comma-separated list of each argument’s serialization as a string, preserving relative order.
</dd>

         <dt>`nth-child()$ps</dt>
         <dt>`nth-last-child()$ps</dt>
         <dt>`nth-of-type()$ps</dt>
         <dt>`nth-last-of-type()$ps</dt>
         <dd>
%文字列
~APPEND［［
<a href="~CSSSYN#serializing-anb">&lt;an+b&gt; 直列化法</a>
の~~規則
`CSS3SYN$r
］に従って引数~値を直列化した結果
］
◎
The result of serializing the value using the rules to serialize an &lt;an+b&gt; value.
</dd>

         <dt>`not()$ps</dt>
         <dd>
%文字列
~APPEND［
引数~値を`選択子~listとして直列化-$した結果
］
◎
The result of serializing the value using the rules for serializing a group of selectors.
</dd>
        </dl>
       </li>
       <li>
%文字列
~APPEND ❝)
◎
↑</li>
      </ol>
     </li>
    </ol>
   </dd>
  </dl>
 </li>
 <li>
<p>
~RET %文字列
◎
↑</p></li>
</ol>

		</section>
	</section>
	<section id="css-object-model">
<h2 title="CSS">5. CSS</h2>

		<section id="css-style-sheets">
<h3 title="CSS Style Sheets">5.1. ~css~ss</h3>

<p>
`~css~ss@
とは、 CSS 仕様にて定義される~ssを表現する抽象的な概念である。
CSSOM においては、`~css~ss$は `CSSStyleSheet$I ~objにより表現される。
各`~css~ss$ %~ss には、以下に挙げる状態~項目が結付けられる：
◎
A CSS style sheet is an abstract concept that represents a style sheet as defined by the CSS specification. In the CSSOM a CSS style sheet is represented as a CSSStyleSheet object. A CSS style sheet has a number of associated state items:
</p>

<dl>
 <dt>`種別@ss◎type</dt>
 <dd>
`text/css^l
◎
The literal string "text/css".
</dd>

 <dt>`所在@ss◎location</dt>
 <dd>
作成-時に指定される。
［
%~ss が埋込みの`~css~ss$である場合は ~NULL ／
~ELSE_ %~ss に対する最初の
<span class="trans-note">【
リダイレクト前の
】</span>
要請の`絶対~URL$
］。
%~ss が存続する限り，変化しない。
◎
Specified when created. The absolute URL of the first request of the CSS style sheet or null if the CSS style sheet was embedded. Does not change during the lifetime of the CSS style sheet.
</dd>

 <dt>`親~css~ss@ss◎parent CSS style sheet</dt>
 <dd>
作成-時に指定される。
%~ss の親の`~css~ss$が［
あれば それ ／
なければ ~NULL
］
◎
Specified when created. The CSS style sheet that is the parent of the CSS style sheet or null if there is no associated parent.
</dd>

 <dt>`所有者~node@ss◎owner node</dt>
 <dd>
作成-時に指定される。
%~ss に結付けられている~DOM~nodeが［
あれば それ ／
なければ ~NULL
］。
<!-- 
HTML の場合は style 要素／link rel="stylesheet"／xml-style-sheet …
 -->
◎
Specified when created. The DOM node associated with the CSS style sheet or null if there is no associated DOM node.
</dd>

 <dt>`所有者~css規則@ss◎owner CSS rule</dt>
 <dd>
作成-時に指定される。
`親~css~ss$ssの中で， %~ss のinclusion
<span class="trans-note">【
`import$at
？
】</span>
を生じさせた`~css規則$が［
あればそれ ／
なければ ~NULL
］
◎
Specified when created. The CSS rule in the parent CSS style sheet that caused the inclusion of the CSS style sheet or null if there is no associated rule.
</dd>

 <dt>`媒体@ss◎media</dt>
 <dd>
作成-時に指定される， `MediaList$I ~obj
◎
Specified when created. The MediaList object associated with the CSS style sheet.
</dd>
 <dd>
<p>
この~propに文字列が指定された場合、`媒体$ssには，［
その文字列に対し `~MediaList~objを作成-$した結果
］が設定され~MUST。
◎
If this property is specified to a string, the media must be set to the return value of invoking create a MediaList object steps for that string.
</dd>
 <dd>
<!-- `MediaList!I -->
<p>
この~propに`所有者~node$ssの属性 %属性 が指定された場合、`媒体$ssには，［
%属性 の値に対し `~MediaList~objを作成-$した結果
］が設定され~MUST。
%属性 が［
設定-／変更-／除去-
］される度に、`媒体$ssの `mediaText$m 属性は［
%属性 が存在しなくなったならば ~NULL ／
~ELSE_ %属性 の新たな値
］に設定され~MUST。
<span class="trans-note">【
すなわち、 %属性 を参照するように，指定された場合。
】</span>
◎
If this property is specified to an attribute of the owner node, the media must be set to the return value of invoking create a MediaList object steps for the value of that attribute. Whenever the attribute is set, changed or removed, the media’s mediaText attribute must be set to the new value of the attribute, or to null if the attribute is absent.
</p>

<p class="note">注記：
`媒体$ssの `mediaText$m 属性の値が変化しても， %属性 は変化しない。
◎
Note: Changing the media’s mediaText attribute does not change the corresponding attribute on the owner node.
</p>
 </dd>

 <dt>`~title@ss◎title</dt>
 <dd>
作成-時に指定される。
`~css~ss$の~title。
空文字列もとり得る。
◎
Specified when created. The title of the CSS style sheet, which can be the empty string.
</dd>
 <dd class="example">
<p>
次の例では、最初の~ssの`~title$ssは空文字列ではなく，2 個目と 3 個目の~ssについては、空文字列になる。
◎
In the following, the title is non-empty for the first style sheet, but is empty for the second and third style sheets.
</p>

<pre class="lang-ml">
&lt;style title="papaya whip"&gt;
  body { background: #ffefd5; }
&lt;/style&gt;
</pre>

<pre class="lang-ml">
&lt;style title=""&gt;
  body { background: orange; }
&lt;/style&gt;
</pre>

<pre class="lang-ml">
&lt;style&gt;
  body { background: brown; }
&lt;/style&gt;
</pre>

 </dd>
 <dd>
この~propが`所有者~node$ssの属性に指定された場合、`~title$ssは，その属性~値に設定され~MUST。
属性が
設定-／変更-／除去-
されるときは 常に、`~title$ssは［
その属性が存在しなくなったならば空文字列 ／
~ELSE_ その属性の新たな値
］に設定され~MUST。
◎
If this property is specified to an attribute of the owner node, the title must be set to the value of that attribute. Whenever the attribute is set, changed or removed, the title must be set to the new value of the attribute, or to the empty string if the attribute is absent.
</dd>

 <dt>`代替-~flag@ss◎alternate flag</dt>
 <dd>
作成-時に指定される。
~ON, ~OFF のいずれか。
既定は ~OFF 。
◎
Specified when created. Either set or unset. Unset by default.
</dd>
 <dd class="example">
<p>
次の`~css~ss$は，`代替-~flag$ssが ~ON にされる：
◎
The following CSS style sheets have their alternate flag set:
</p>

<pre class="lang-ml">
&lt;?xml-stylesheet alternate="yes" title="x" href="data:text/css,…"?&gt;
</pre>

<pre class="lang-ml">
&lt;link rel="alternate stylesheet" title="x" href="data:text/css,…"&gt;
</pre>

 </dd>

 <dt>`不能化~flag@ss◎disabled flag</dt>
 <dd>
~ON, ~OFF のいずれか。
既定は ~OFF 。
◎
Either set or unset. Unset by default.
</dd>
 <dd class="note">注記：
~OFF であっても，必ずしも`~css~ss$が具現化に実際に利用されるとは限らない。
◎
Note: Even when unset it does not necessarily mean that the CSS style sheet is actually used for rendering.
</dd>


 <dt>`~css規則列@ss◎CSS rules</dt>
 <dd>
`~css~ss$に結付けられている一連の`~css規則$からなる~list。
◎
The CSS rules associated with the CSS style sheet.
</dd>


 <dt>`origin-clean ~flag@ss</dt>
 <dd>
作成-時に指定される。
~ON, ~OFF のいずれか。
~ON の場合， API による`~css規則列$ssに対する読取りと改変が許容される。
◎
Specified when created. Either set or unset. If it is set, the API allows reading and modifying of the CSS rules.
</dd>
</dl>

			<section id="the-stylesheet-interface">
<h4 title="The StyleSheet Interface">5.1.1. `StyleSheet^I ~ifc</h4>

<p>
`StyleSheet$I
~ifcは、抽象的な基底~ssを表現する。
◎
The StyleSheet interface represents an abstract, base style sheet.
</p>

⇒！
interface `StyleSheet@I {
  ~RA ~DS `type$m;
  ~RA ~DS? `href$m;
  ~RA (`Element$I or `ProcessingInstruction$I)? `ownerNode$m;
  ~RA `StyleSheet$I? `parentStyleSheet$m;
  ~RA ~DS? `title$m;
  [`SameObject$, `PutForwards$=`mediaText$m] ~RA `MediaList$I `media$m;
  attribute boolean `disabled$m;
};◎

<dl class="idl-def">
	<dt>`type@m</dt>
	<dd>
取得子は、此れの`種別$ssを返さ~MUST。
◎
The type attribute must return the type.
</dd>

	<dt>`href@m</dt>
	<dd>
取得子は、此れの`所在$ssを返さ~MUST。
◎
The href attribute must return the location.
</dd>

	<dt>`ownerNode@m</dt>
	<dd>
取得子は、此れの`所有者~node$ssを返さ~MUST。
◎
The ownerNode attribute must return the owner node.
</dd>

	<dt>`parentStyleSheet@m</dt>
	<dd>
取得子は、此れの`親~css~ss$ss
<span class="trans-note">【
を表現する `StyleSheet$I （（を継承する~ifc）を実装する）~obj
】</span>
を返さ~MUST。
◎
The parentStyleSheet attribute must return the parent CSS style sheet.
</dd>

	<dt>`title@m</dt>
	<dd>
取得子は、［
此れの`~title$ss ~NEQ 空文字列ならば それ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The title attribute must return the title or null if title is the empty string.
</dd>

	<dt>`media@m</dt>
	<dd>
取得子は、此れの`媒体$ssを返さ~MUST。
◎
The media attribute must return the media.
</dd>

	<dt>`disabled@m</dt>
	<dd>
取得子は、［
此れの`不能化~flag$ss ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
↓</dd>
	<dd>
設定子は、［
此れの`不能化~flag$ss ~SET［
新たな値 ~EQ ~T ならば ~ON ／
~ELSE_ ~OFF
］］にし~MUST。
◎
The disabled attribute, on getting, must return true if the disabled flag is set, or false otherwise. On setting, the disabled attribute must set the disabled flag if the new value is true, or unset the disabled flag otherwise.
</dd>

</dl>

			</section>
			<section id="the-cssstylesheet-interface">
<h4 title="The CSSStyleSheet Interface">5.1.2. `CSSStyleSheet^I ~ifc</h4>

<p>
`CSSStyleSheet$I ~ifcは `~css~ss$を表現する。
◎
The CSSStyleSheet interface represents a CSS style sheet.
</p>

⇒！
interface `CSSStyleSheet@I : `StyleSheet$I {
  ~RA `CSSRule$I? `ownerRule$m;
  [`SameObject$] ~RA `CSSRuleList$I `cssRules$m;
  ~UL `insertRule$m(~DS %rule, ~UL %index);
  void `deleteRule$m(~UL %index);
};◎

<dl class="idl-def">
	<dt>`ownerRule@m</dt>
	<dd>
取得子は、此れの`所有者~css規則$ss
<span class="trans-note">【
を表現する `CSSRule$I （（を継承する~ifc）を実装する）~obj
】</span>
を返さ~MUST。
~NULL 以外の値を返す場合は、どの取得~accessに対しても，常に同じ値を返さ~MUST。
◎
The ownerRule attribute must return the owner CSS rule. If a value other than null is ever returned, then that same value must always be returned on each get access.
</dd>

	<dt>`cssRules@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The cssRules attribute must follow these steps:
</p>

<ol>
 <li>
~IF［
此れの`origin-clean ~flag$ss ~EQ ~OFF
］
⇒
~THROW `SecurityError$E
◎
If the origin-clean flag is unset, throw a SecurityError exception.
</li>
 <li>
<p>
~RET
此れの`~css規則列$ssを表現する，読専かつ~liveである `CSSRuleList$I ~obj
◎
Return a read-only, live CSSRuleList object representing the CSS rules.
</p>

<p class="note">注記：
返される `CSSRuleList$I ~objは、（作者による~script側からは）読専であったとしても、~liveであり，内容が変化しないことを意味するわけではない。
例えば、 `insertRule()$m や `deleteRule()$m ~methの呼出しによる変更は、返された~objに反映される。
◎
Note: Even though the returned CSSRuleList object is read-only (from the perspective of client-authored script), it can nevertheless change over time due to its liveness status. For example, invoking the insertRule() or deleteRule() methods can result in mutations reflected in the returned object.
</p>
 </li>
</ol>
</dd>

	<dt>`insertRule(rule, index)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The insertRule(rule, index) method must run the following steps:
</p>

<ol>
 <li>
~IF［
此れの`origin-clean ~flag$ss ~EQ ~OFF
］
⇒
~THROW `SecurityError$E
◎
If the origin-clean flag is unset, throw a SecurityError exception.
</li>
 <li>
~RET
%rule を此れ上の `cssRules$m から返される`~css規則列$ssの %index の位置に`挿入-$した結果
◎
Return the result of invoking insert a CSS rule rule in the CSS rules at index.
</li>
</ol>

</dd>

	<dt>`deleteRule(index)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The deleteRule(index) method must run the following steps:
</p>

<ol>
 <li>
~IF［
此れの`origin-clean ~flag$ss ~EQ ~OFF
］
⇒
~THROW `SecurityError$E
◎
If the origin-clean flag is unset, throw a SecurityError exception.
</li>
 <li>
此れの`~css規則列$ssから %index に位置する規則を`除去-$する
◎
Remove a CSS rule in the CSS rules at index.
</li>
</ol>
	</dd>
</dl>

			</section>
		</section>
		<section id="style-sheet-collections">
<h3 title="CSS Style Sheet Collections">5.2. ~css~ss~collection</h3>

<p>
以下に、各 `文書$に結付けられる，種々の新たな概念が定義される
◎
Below various new concepts are defined that are associated with each Document object.
</p>

<p>
各 `文書$には、
`文書~ss~list@
と呼ばれる，ゼロ個以上の`~css~ss$からなる~listが結付けられる。
これは、［
`文書$に結付けられている`~css~ss$
］すべてを含む，`~tree順序$による~listである。
但し， HTTP `Link$h ~headerから作成される`~css~ss$は、それらの~headerに現れる順に，~listの先頭に置かれる。
◎
Each Document has an associated list of zero or more CSS style sheets, named the document CSS style sheets. This is an ordered list that contains all CSS style sheets associated with the Document, in tree order, with CSS style sheets created from HTTP Link headers first, if any, in header order.
</p>

<p class="algo-head">
~css~ssを
`作成-@
するときは、次を走らす：
◎
To create a CSS style sheet, run these steps:
</p>

<ol>
 <li>
<p>
新たな`~css~ss$ ~objを作成し，その各種~propを指定された値に設定した上で，`文書~ss~list$に`追加-$する
◎
Create a new CSS style sheet object and set its properties as specified.
◎
Then run the add a CSS style sheet steps for the newly created CSS style sheet.
</p>

<p class="warning">
`origin-clean ~flag$ss ~EQ ~OFF の下では、これにより，利用者の~intranetからの情報が公開され得る。
◎
If the origin-clean flag is unset, this can expose information from the user’s intranet.
</p>
 </li>
</ol>

<p class="algo-head">
~css~ss %sheet を
`追加-@
するときは、次を走らす：
◎
To add a CSS style sheet, run these steps:
</p>

<ol>
 <li>
<p>
%sheet を，`文書~ss~list$内の適切な位置に追加する
</p>

<p>
（手続きの以下の部分は`不能化~flag$ssについての取り扱いになる）
</p>

◎
Add the CSS style sheet to the list of document CSS style sheets at the appropriate location. The remainder of these steps deal with the disabled flag.
</li>
 <li>
~IF［
%sheet の`不能化~flag$ss ~EQ ~ON
］
⇒
~RET
◎
If the disabled flag is set, terminate these steps.
</li>
 <li>
%~title ← %sheet の`~title$ss
◎
↓</li>
 <li>
~IF［
%~title ~NEQ 空文字列
］~AND［
%sheet の`代替-~flag$ss ~EQ ~OFF
］~AND［
`選好~ssset名$ ~EQ 空文字列
］
⇒
%~title を用いて`選好~ssset名を変更-$する
◎
If the title is not the empty string, the alternate flag is unset, and preferred CSS style sheet set name is the empty string change the preferred CSS style sheet set name to the title.
</li>
 <li>
%~ssset名 ~LET［
`最後の~ssset名$ ~NEQ ~NULL ならば それ  ／
~ELSE_ `選好~ssset名$ 
］
◎
↓</li>
 <li>
%sheet の`不能化~flag$ss ~SET ［
%~title ~IN { 空文字列, %~ssset名 } ならば ~OFF ／
~ELSE_ ~ON
］
◎
If any of the following is true unset the disabled flag and terminate these steps:
◎
• The title is the empty string.
◎
• The last CSS style sheet set name is null and the title is a case-sensitive match for the preferred CSS style sheet set name.
◎
• The title is a case-sensitive match for the last CSS style sheet set name.
◎
Set the disabled flag.
</li>
</ol>


<p class="algo-head">
`~css~ss$ %sheet を
`除去-@ss
するときは、次を走らす：
◎
To remove a CSS style sheet, run these steps:
</p>

<ol>
 <li>
`文書~ss~list$から %sheet を除去する
◎
Remove the CSS style sheet from the list of document CSS style sheets.
</li>
 <li>
%sheet の［
`親~css~ss$ss,
`所有者~node$ss,
`所有者~css規則$ss
］ ~SET ~NULL
◎
Set the CSS style sheet’s parent CSS style sheet, owner node and owner CSS rule to null.
</li>
</ol>

<p>
`持続的~css~ss@
とは、`文書~ss~list$に属する`~css~ss$のうち，［
その`~title$ss ~EQ 空文字列
］~AND［
その`代替-~flag$ss ~EQ ~OFF
］なるものである。
◎
A persistent CSS style sheet is a CSS style sheet from the document CSS style sheets whose title is the empty string and whose alternate flag is unset.
</p>

<p>
`~ssset@
とは、`文書~ss~list$に属する`~css~ss$のうち，［
空文字列でない`~title$ss
］が互いに一致するものからなる，有順序~collectionである。
◎
A CSS style sheet set is an ordered collection of one or more CSS style sheets from the document CSS style sheets which have an identical title that is not the empty string.
◎
A CSS style sheet set name is the title the CSS style sheet set has in common.
</p>

<p>
`~ssset$に属する各`~css~ss$に共通する`~title$ssは、
`~ssset名@
と呼ばれる。
◎
A CSS style sheet set name is the title the CSS style sheet set has in common.
</p>

<p>
`~ssset$は、［
それに属するどの`~css~ss$の`不能化~flag$ssも ~OFF にされている
］ならば，
`可能化~ssset@
という。
◎
An enabled CSS style sheet set is a CSS style sheet set of which each CSS style sheet has its disabled flag unset.
</p>

<p class="algo-head">
名前 %名前 を用いて，
`~sssetを可能化-@
するときは、次を走らす：
◎
To enable a CSS style sheet set with name name, run these steps:
</p>


<ol>
 <li>
`文書~ss~list$内の ~EACH ( `~css~ss$ %sheet ) に対し
⇒
~IF［
%sheet の`~title$ss ~NEQ 空~文字列
］
⇒
%sheet の`不能化~flag$ss ~SET［
%sheet の`~title$ss ~EQ %名前 ならば ~OFF ／
~ELSE_ ~ON
］
◎
If name is the empty string, set the disabled flag for each CSS style sheet that is in a CSS style sheet set and terminate these steps.
◎
Unset the disabled flag for each CSS style sheet in a CSS style sheet set whose CSS style sheet set name is a case-sensitive match for name and set it for all other CSS style sheets in a CSS style sheet set.
</li>
</ol>

<p class="algo-head">
名前 %名前 の
`~sssetを選択-@
するときは、次を走らす：
◎
To select a CSS style sheet set with name name, run these steps:
</p>

<ol>
 <li>
名前 %名前 を用いて，`~sssetを可能化-$する
◎
enable a CSS style sheet set with name name.
</li>
 <li>
`最後の~ssset名$ ~SET %名前
◎
Set last CSS style sheet set name to name.
</li>
</ol>

<p>
`最後の~ssset名@
とは、［
どの`~ssset$を最後に`選択した$ssか
］を決定するための概念である。
その初期~時の値は ~NULL である。
◎
A last CSS style sheet set name is a concept to determine what CSS style sheet set was last selected. Initially its value is null.
</p>

<p>
`選好~ssset名@
とは、［
どの`~css~ss$について，`不能化~flag$ssを ~OFF にする必要があるか
］を決定するための概念である。
その初期~時の値は空文字列である。
◎
A preferred CSS style sheet set name is a concept to determine which CSS style sheets need to have their disabled flag unset. Initially its value is the empty string.
</p>

<p class="algo-head">
名前 %名前 を用いて
<dfn id="change-the-preferred-css-style-sheet-set-name">選好~ssset名を変更-</dfn>
するときは、次を走らす：
◎
To change the preferred CSS style sheet set name with name name, run these steps:
</p>

<ol>
 <li>
%current ~LET
`選好~ssset名$
◎
Let current be the preferred CSS style sheet set name.
</li>
 <li>
`選好~ssset名$ ~SET %名前
◎
Set preferred CSS style sheet set name to name.
</li>
 <li>
~IF［
%名前 ~NEQ %current
］~AND［
`最後の~ssset名$ ~EQ ~NULL
］
⇒
名前 %名前 を用いて，`~sssetを可能化-$する
◎
If name is not a case-sensitive match for current and last CSS style sheet set name is null enable a CSS style sheet set with name name.
</li>
</ol>

			<section id="the-http-default-style-header">
<h4 title="The HTTP Default-Style Header">5.2.1. HTTP `Default-Style^h ~header</h4>

<p>
HTTP `Default-Style$h ~headerを利用すれば、`選好~ssset名$を設定して，どの`~ssset$が（初期~時に）`可能化~ssset$にされるかに波及させられる。
◎
The HTTP Default-Style header can be used to set the preferred CSS style sheet set name influencing which CSS style sheet set is (initially) the enabled CSS style sheet set.
</p>

<p>
~UAは，~EACH ( HTTP `Default-Style$h ~header ) に対し，~headerに現れる順序で、その値を名前に用いて，`選好~ssset名を変更-$し~MUST。
◎
For each HTTP Default-Style header, in header order, the user agent must change the preferred CSS style sheet set name with name being the value of the header.
</p>
			</section>
			<section id="the-stylesheetlist-sequence">

<h4 title="The StyleSheetList Interface">5.2.2. `StyleSheetList^I ~ifc</h4>

<p>
`StyleSheetList$I ~ifcは`~css~ss$の有順序~collectionを表現する。
◎
The StyleSheetList interface represents an ordered collection of CSS style sheets.
</p>

⇒！
[`LegacyArrayClass$]
interface `StyleSheetList@I {
  getter `StyleSheet$I? `item$m(~UL %index);
  ~RA ~UL `length$m;
};◎

<p>
~objの
`被support~prop~index$
の範囲は［
0 〜 ( ( ~collectionで表現される~ssの総数 ) ~MINUS 1 )
］である（~collectionが空なら存在しないことになる）。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of CSS style sheets represented by the collection. If there are no such CSS style sheets, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>`item(index)@m</dt>
	<dd>
被呼出時には、此れの~collectionの中で %index に位置する~ssが［
在れば それ ／
無ければ ~NULL
］を返さ~MUST。
◎
The item(index) method must return the indexth CSS style sheet in the collection. If there is no indexth object in the collection, then the method must return null.
</dd>

	<dt>`length@m</dt>
	<dd>
取得子は、此れの~collectionで表現される~ssの総数を返さ~MUST。
◎
The length attribute must return the number of CSS style sheets represented by the collection.
</dd>
</dl>

			</section>
			<section id="extensions-to-the-document-interface">
<h4 title="Extensions to the Document Interface">5.2.3. `Document^I ~ifcに対する拡張</h4>

⇒！
partial interface `Document!I {
  [`SameObject$] ~RA `StyleSheetList$I `styleSheets$m;
};◎


<dl class="idl-def">
	<dt>`styleSheets@m</dt>
	<dd>
取得子は、此れの`文書~ss~list$を表現する
`StyleSheetList$I ~collectionを返さ~MUST。
◎
The styleSheets attribute must return a StyleSheetList collection representing the document CSS style sheets.
</dd>
</dl>


			</section>
		</section>
		<section id="style-sheet-association">
<h3 title="Style Sheet Association">5.3. ~ssの結付け</h3>

<p>
この節では、`~css~ss$の`所有者~node$ssが実装する必要がある~ifcを定義する。
`xml-stylesheet 処理命令$, および［
link relation type に `stylesheet^l を含むような HTTP `Link$h ~header
］に課される要件を定義する。
◎
This section defines the interface an owner node of a CSS style sheet has to implement and defines the requirements for xml-stylesheet processing instructions and HTTP Link headers when the link relation type is an ASCII case-insensitive match for "stylesheet".
</p>

			<section id="fetching-css-style-sheets">

<h4 title="Fetching CSS style sheets">5.3.1. ~css~ssの~fetching</h4>

<div class="p">

<p>
`~css~ss資源を~fetch@
するときは、次を入力に：
</p>

<ul>
	<li>
解析済~URL: %解析済~URL
</li>
	<li>
~referrer: %~referrer
</li>
	<li>
文書: %文書
</li>
	<li>
一連の~parameter: %parameters
（省略可，`要請$を作成する際の入力に利用される）
</li>
</ul>

<p>
次を走らす：
</p>
◎
To fetch a CSS style sheet with parsed URL parsed URL, referrer referrer, document document, optionally a set of parameters parameters (used as input to creating a request), follow these steps:
</div>




<ol>
	<li>
%生成元 ~LET %文書 の`生成元$
◎
Let origin be document’s origin.
</li>
	<li>
<p>
%要請 ~LET 次のようにされた，新たな`要請$
</p>

<ul ><li>`~url$rq ~SET %解析済~URL
</li><li>`生成元$rq ~SET %生成元
</li><li>`~referrer$rq ~SET %~referrer
</li><li> その他の~parameter ~SET %parameters（与えられていれば）
</li></ul>

◎
Let request be a new request, with the url parsed URL, origin origin, referrer referrer, and if specified the set of parameters parameters.
</li>
	<li>
%応答 ~LET %要請 による`~fetching$の結果
（ %応答 が得られるまで待機する）
◎
Let response be the result of fetching request.
◎
Wait until response is available.
</li>
	<li>
~IF［
%応答 ~EQ `~network~error$
］
⇒
~RET ~error
◎
If response is a network error, return an error.
</li>
	<li>
~IF［
%doc は`過去互換~mode$下にある
］~AND［
%応答 は `CORS 同一生成元$である
］~AND［
%応答 の`Content-Type ~metadata$は `~supportされる~styling言語$でない
］
⇒
%応答 の`Content-Type ~metadata$を <code>text/css</code> に変更する
◎
If document is in quirks mode, response is CORS-same-origin and the Content-Type metadata of response is not a supported styling language change the Content-Type metadata of response to text/css.
</li>
	<li>
~IF［
%応答 は`~supportされる~styling言語$でない
］
⇒
~RET ~error
◎
If response is not in a supported styling language return an error.
</li>
	<li>
~RET %応答
◎
Return response.
</li>
</ol>

			</section>
			<section id="the-linkstyle-interface">
<h4 title="The LinkStyle Interface">5.3.2. `LinkStyle^I ~ifc</h4>

<p>
~nodeに
`結付けられている~css~ss@
とは、`文書~ss~list$に属する`~css~ss$であって，
その`所有者~node$ssが `LinkStyle$I ~ifcを実装するものである。
<span class="trans-note">【
所有者~node と~nodeは同じでないこともあるのだろうか？
】</span>
◎
The associated CSS style sheet of a node is the CSS style sheet in the list of document CSS style sheets of which the owner node implements the LinkStyle interface.
</p>

⇒！
[`NoInterfaceObject$]
interface `LinkStyle@I {
  ~RA `StyleSheet$I? `sheet$m;
};◎

<dl class="idl-def">
	<dt>`sheet@m</dt>
	<dd>
取得子は、~nodeに`結付けられている~css~ss$が［
あればそれ ／
なければ ~NULL
］を返さ~MUST。
◎
The sheet attribute must return the associated CSS style sheet for the node or null if there is no associated CSS style sheet.
</dd>
	<dd class="example">
<p>
次の例において、~UAが CSS （ <code>text/css</code> ）を~supportしつつ，（仮想の） <code>text/example-sheets</code> は~supportしていないとする。
この場合、前者の `style^e 要素の `sheet$m 属性は，~ssを表現する `StyleSheet$I ~objを返すが、後者の `style^e 要素の `sheet$m 属性は，~NULL を返す。
◎
In the following fragment, the first style element has a sheet attribute that returns a StyleSheet object representing the style sheet, but for the second style element, the sheet attribute returns null, assuming the user agent supports CSS (text/css), but does not support the (hypothetical) ExampleSheets (text/example-sheets).
</p>

<pre class="lang-ml">
&lt;style type="text/css"&gt;
  body { background:lime }
&lt;/style&gt;
</pre>
<pre class="lang-ml">
&lt;style type="text/example-sheets"&gt;
  $(body).background := lime
&lt;/style&gt;
</pre>

	</dd>
</dl>


<p class="note">注記：
~nodeが~ssを~~参照するかどうかは、当該の~nodeの意味論を定義する仕様により定義される。
◎
Note: Whether or not the node refers to a style sheet is defined by the specification that defines the semantics of said node.
</p>
			</section>
			<section id="requirements-on-specifications">
<h4 title="Requirements on specifications">5.3.3. 仕様に課される要件</h4>

<p>
~DOMを通して~ssを結付ける新たな方法を導入する仕様は、どの~nodeが `LinkStyle$I ~ifcを実装するかを定義するべきである。
その場合、どの時点で`~css~ss$が`作成-$されるかも定義され~MUST。
◎
Specifications introducing new ways of associating style sheets through the DOM should define which nodes implement the LinkStyle interface. When doing so, they must also define when a CSS style sheet is created.
</p>



			</section>
			<section id="requirements-on-user-agents-implementing-the-xml-stylesheet-processing-instruction">
<h4 title="Requirements on User Agents Implementing the xml-stylesheet processing instruction">5.3.4. xml-stylesheet 処理命令を実装する~UAに課される要件</h4>

⇒！
`ProcessingInstruction$I implements `LinkStyle$I;◎


<p>
`~prolog@
とは、 `文書$の`子$であって，
`文書$のどの子`Element$I にも`後続$しないような`~node$（の集合）を意味する。
◎
The prolog refers to nodes that are children of the document and are not following the Element child of the document, if any.
</p>

<p>
`ProcessingInstruction$I `~node$ %node
が［
`~prolog$の一部を成すものに［
なった／ならなくなった
］とき，あるいは その
`~data$ が変化したとき
］には、次を走らせ~MUST：
◎
When a ProcessingInstruction node node becomes part of the prolog, is no longer part of the prolog, or has its data changed, these steps must be run:
</p>


<ol>

 <li>
~IF［
この~algoの~instanceが
%node に対し現在~走っている
］
⇒
その~instanceを中止する；<br>
適用-可能なら，結付けられている`~fetching$も停止する
◎
If an instance of this algorithm is currently running for node, abort that instance, and stop the associated fetching if applicable.
</li>
 <li>
~IF［
%node に`結付けられている~css~ss$がある
］
⇒
それを`除去-$ssする
◎
If node has an associated CSS style sheet, remove it.
</li>
 <li>
~IF［
%node は `xml-stylesheet 処理命令$でない
］
⇒
~RET
◎
If node is not an xml-stylesheet processing instruction, terminate these steps.
</li>
 <li>
~IF［
%node は
`href$xmlss `疑似属性$を持たない
］
⇒
~RET
◎
If node does not have an href pseudo-attribute, terminate these steps.
</li>
 <li>
%~title ~LET ［
`title$xmlss `疑似属性$が指定されている場合はその値 ／
~ELSE_空文字列
］
◎
Let title be the value of the title pseudo-attribute or the empty string if the title pseudo-attribute is not specified.
</li>
 <li>
~IF［
`alternate$xmlss `疑似属性$が与えられていて その値 ~EQ `yes^l
］~AND［
%~title ~EQ 空文字列
］
⇒
~RET
◎
If there is an alternate pseudo-attribute whose value is a case-sensitive match for "yes" and title is the empty string terminate these steps.
</li>
 <li>
~IF［
`type$xmlss `疑似属性$が与えられていて，その値は`~supportされる~styling言語$でない
］
⇒
~UAの任意選択で
⇒
~RET
◎
If there is a type pseudo-attribute whose value is not a supported styling language the user agent may terminate these steps.
</li>
 <li>
%入力~URL ~LET `href$xmlss `疑似属性$に指定されている値
◎
Let input URL be the value specified by the href pseudo-attribute.
</li>
 <li>
%文書 ~LET %node の`~node文書$
◎
Let document be node’s node document
</li>
 <li>
%基底~URL ~LET %文書 の`文書~基底~URL$
◎
Let base URL be document’s document base URL.
</li>
 <li>
%~referrer ~LET %文書 の`~address$
◎
Let referrer be document’s address.
</li>
 <li>
%解析済~URL ~LET %入力~URL を`~URL構文解析器$にかけた結果
◎
Let parsed URL be the return value of invoking the URL parser with the string input URL and the base URL base URL.
</li>
 <li>
~IF［
%解析済~URL ~EQ failue
］
⇒
~RET
◎
If parsed URL is failure, terminate these steps.
</li>
 <li>
%応答 ~LET
(
解析済~URL: %解析済~URL,
~referrer: %~referrer,
文書: %文書
) を入力に，`~css~ss資源を~fetch$した結果
◎
Let response be the result of fetching a CSS style sheet with parsed URL parsed URL, referrer referrer and document document.
</li>
 <li>
~IF［
%応答 ~EQ ~error
］
⇒
~RET
◎
If response is an error, terminate these steps.
</li>
 <li>
<p>
次の~propを伴う~css~ssを`作成-$する：
◎
Create a CSS style sheet with the following properties:
</p>

  <dl>
   <dt>`所在$ss</dt>
   <dd>
%解析済~URL を `~URL直列化器$にかけた結果
◎
The result of invoking the URL serializer with parsed URL.
</dd>

   <dt>`親~css~ss$ss</dt>
   <dd>
~NULL
◎
null.
</dd>

   <dt>`所有者~node$ss</dt>
   <dd>
%node
◎
node.
</dd>

   <dt>`所有者~css規則$ss</dt>
   <dd>
~NULL
◎
null.
</dd>

   <dt>`媒体$ss</dt>
   <dd>
`media$xmlss `疑似属性$の値が与えられていればそれ ／
いなければ空文字列
◎
The value of the media pseudo-attribute if any, or the empty string otherwise.
</dd>

   <dt>`~title$ss</dt>
   <dd>
%~title
◎
title.
</dd>

   <dt>`代替-~flag$ss</dt>
   <dd>
`alternate$xmlss `疑似属性$の値 ~EQ `yes^l ならば ~ON ／
~ELSE_ ~OFF
◎
Set if the alternate pseudo-attribute value is a case-sensitive match for "yes", or unset otherwise.
</dd>

   <dt>`origin-clean ~flag$ss</dt>
   <dd>
%応答 は `CORS 同一生成元$であるならば ~ON ／
~ELSE_ ~OFF
◎
Set if response is CORS-same-origin, or unset otherwise.
</dd>

  </dl>


  <p>
~css`環境~符号化方式$は、次を走らせた結果である：
◎
The CSS environment encoding is the result of running the following steps:
</p>

  <ol>
   <li>
~IF［
要素は `charset$xmlss `疑似属性$を持つ
］
⇒
~IF［
その疑似属性の値から`符号化方式を取得$した結果 ~NEQ failure
］
⇒
~RET その結果
◎
If the element has a charset pseudo-attribute, get an encoding from that pseudo-attribute’s value. If that succeeds, return the resulting encoding and abort these steps.
</li>
   <li>
~RET `文書の文字~符号化方式$
◎
Otherwise, return the document’s character encoding. [DOM]
</li>
  </ol>
 </li>
</ol>


<div class="p">
<p>
<a href="~HTML5/xhtml.html#xml-parser">XML 構文解析器</a>
%構文解析器
から生成される`文書$の文脈の下で，この節の~~規則を用いて［
`xml-stylesheet 処理命令$を表現する `ProcessingInstruction$I `~node$ %node
］から参照される~ss %sheet は、次のすべてを満たすとき，`~scriptを阻んでいる~ss$と呼ばれる
— ~UA は %sheet をいつでも`~give-up$してよい：
</p>

<ul>
	<li>
%node は %構文解析器 により作成されたものである
</li>
	<li>
%node の作成-時に %sheet は可能化-されている
</li>
	<li>
%sheet の`~ss準備済み~flag$は まだ ~ON にされていない
</li>
	<li>
`~event-loop$が 最後に上の~algoの最初の段に到達したときには，
%node はその`文書$ 内に在った
</li>
	<li>
~UA は %sheet をまだ`~give-up$していない
</li>
</ul>

<p class="trans-note">【
`~give-up@
が正確に何を意味するかは、この仕様のみからは確定できない。
この時点では~give-upしたとしても， %sheet は後で処理されるかもしれない。
】</p>


◎
A style sheet referenced by an xml-stylesheet processing instruction using the rules in this section, in the context of the Document of an XML parser is said to be a style sheet that is blocking scripts if the ProcessingInstruction node was created by that Document's parser, and the style sheet was enabled when the node was created by the parser, and the style sheet ready flag is not yet set, and, the last time the event loop reached step 1, the node was in that Document, and the user agent hasn’t given up on that particular style sheet yet. A user agent may give up on such a style sheet at any time.
</div>


			</section>
			<section id="requirements-on-user-agents-implementing-the-http-link-header">
			
<h4 title="Requirements on User Agents Implementing the HTTP Link Header">5.3.5. HTTP `Link^h ~headerを実装する~UAに課される要件</h4>

<p class="atrisk">
~EACH ( HTTP `Link$h ~header ) に対しては、次の手続きを走らせ~MUST：
◎
For each HTTP Link header of which one of the link relation types is an ASCII case-insensitive match for "stylesheet" these steps must be run:
</p>

<ol>
 <li>
%~header ~LET `Link$h ~headerの値
◎
↓</li>
 <li>
%relation-types ~LET ［
%~header の中の一連の link relation type からなる集合
］
◎
↓</li>
 <li>
~IF［
`stylesheet^l ~NIN `~ACI$ %relation-types
］
⇒
~RET
◎
↓</li>
 <li>
%~title ~LET ［
%~header の中に `title^l ~parameterが在れば，それらのうち 最初のものの値 ／
無ければ 空文字列
］
◎
Let title be the value of the first of all the title parameters. If there are no such parameters it is the empty string.
</li>
 <li>
~IF［
%~title ~EQ 空文字列
］~AND［
`alternate^l ~IN `~ACI$ %relation-types
］
⇒
~RET
◎
If one of the (other) link relation types is an ASCII case-insensitive match for "alternate" and title is the empty string terminate these steps.
</li>
 <li>
%入力~URL ~LET %~header に指定されている URI-Reference
<span class="issue">（より詳細に規定する必要あり）</span>
◎
Let input URL be the value specified. Be more specific
</li>
 <li>
%文書 ~LET 文書
◎
↓</li>
 <li>
%基底~URL ~LET %文書 の`文書~基底~URL$
<span class="issue">この時点で文書~objは存在するのか？</span>
◎
Let base URL be the document’s document base URL. Is there a document at this point?
</li>

 <li>
%~referrer ~LET %文書 の`~address$doc
◎
Let referrer be the document’s address.
</li>

 <li>
%生成元 ~LET %文書 の`生成元$
◎
Let origin be the document’s origin.
</li>
 <li>
%解析済~URL ~LET %入力~URL を`~URL構文解析器$にかけた結果
◎
Let parsed URL be the return value of invoking the URL parser with the string input URL and the base URL base URL.
</li>
 <li>
~IF［
%解析済~URL ~EQ failue
］
⇒
~RET
◎
If parsed URL is failure, terminate these steps.
</li>
 <li>
<p>
%応答 ~LET
(
解析済~URL: %解析済~URL,
~referrer: %~referrer,
文書: %文書
) を入力に，`~css~ss資源を~fetch$した結果
◎
Let response be the result of fetching a CSS style sheet with parsed URL parsed URL, referrer referrer and document being the document.
</p>

<p class="issue">
HTML 構文解析器が過去互換~modeかどうかまだ決定していなかった場合はどうする？
◎
What if the HTML parser hasn’t decided on quirks/non-quirks yet?
</p>
 </li>
 <li>
<p>
次の~propを伴う~css~ssを`作成-$する
◎
Create a CSS style sheet with the following properties:
</p>

  <dl>
   <dt>`所在$ss</dt>
   <dd>
%解析済~URL を `~URL直列化器$にかけた結果
◎
The result of invoking the URL serializer with parsed URL.
</dd>

   <dt>`所有者~node$ss</dt>
   <dd>
~NULL
◎
null.
</dd>

   <dt>`親~css~ss$ss</dt>
   <dd>
~NULL
◎
null.
</dd>

   <dt>`所有者~css規則$ss</dt>
   <dd>
~NULL
◎
null.
</dd>

   <dt>`媒体$ss</dt>
   <dd>
最初の `media^c ~parameterの値
◎
The value of the first media parameter.
</dd>

   <dt>`~title$ss</dt>
   <dd>
%~title
◎
title.
</dd>

   <dt>`代替-~flag$ss</dt>
   <dd>
［
`alternate^l ~IN `~ACI$ %relation-types
ならば~ON ／
~ELSE_ ~OFF
］
◎
Set if one of the specified link relation type for this HTTP Link header is an ASCII case-insensitive match for "alternate", or false otherwise.
</dd>

   <dt>`origin-clean ~flag$ss</dt>
   <dd>
%応答 は `CORS 同一生成元$であるならば ~ON ／
~ELSE_ ~OFF
◎
Set if response is CORS-same-origin, or unset otherwise.
</dd>

  </dl>
 </li>
</ol>


<div class="p">
<p>
この節の~~規則を用いて HTTP `Link$h ~headerから参照される~ssのうち，所与の時点で 次のすべてを満たすものは、`~scriptを阻んでいる~ss$と呼ばれる
— ~UA は，その種の~ss %sheet をいつでも`~give-up$してよい：
</p>

<ul>
	<li>
%sheet は，その作成-時に可能化されている
</li>
	<li>
%sheet の`~ss準備済み~flag$は，まだ ~OFF
</li>
	<li>
~UA は， %sheet をまだ`~give-up$していない
</li>
</ul>

◎
A style sheet referenced by a HTTP Link header using the rules in this section is said to be a style sheet that is blocking scripts if the style sheet was enabled when created, and the style sheet ready flag is not yet set, and the user agent hasn’t given up on that particular style sheet yet. A user agent may give up on such a style sheet at any time.
</div>

			</section>
		</section>
		<section id="css-rules">
<h3 title="CSS Rules">5.4. CSS 規則</h3>

<p>
`~css規則@
とは、 CSS 仕様にて定義される規則を表す，抽象的な概念である。
`~css規則$は、 `CSSRule$I ~ifcを継承する~ifcを実装する~objで表現される。
それには，以下の状態~項目が結付けられる
<span class="trans-note">【
括弧内は，項目に対応する `CSSRule!I の属性~member（この訳による補足）
】</span>：
◎
A CSS rule is an abstract concept that denotes a rule as defined by the CSS specification. A CSS rule is represented as an object that implements a subclass of the CSSRule interface, and which has the following associated state items:
</p>

<dl>
 <dt>`種別@（ `type$m ）◎type</dt>
 <dd>
特定0の［
規則の種別
］に結付けられている，非負~整数。
この項目は、規則の作成-時に初期化されなければならず，変更されることはない。
<span class="trans-note">【
`CSSRule$I を継承する特定の~ifcに対応する。
】</span>
◎
A non-negative integer associated with a particular type of rule. This item is initialized when a rule is created and cannot change.
</dd>

 <dt>`~text@（ `~cssText0$m ）◎text</dt>
 <dd>
~ss内での直接的な利用に適するような，規則の~text表現。
この項目は規則の作成-時に初期化されなければならず，規則が存続する間 変更され得る。
◎
A text representation of the rule suitable for direct use in a style sheet. This item is initialized when a rule is created and can be changed.
</dd>

 <dt>`親~規則@（ `parentRule$m ）◎parent CSS rule</dt>
 <dd>
この規則を封入している別の`~css規則$への参照か, または ~NULL。
この項目は規則の作成-時に［
そのような別の規則があるならばそれ ／
~ELSE_ ~NULL
］に初期化される。
これは，~NULLに変更され得る。
◎
A reference to an enclosing CSS rule or null. If the rule has an enclosing rule when it is created, then this item is initialized to the enclosing rule; otherwise it is null. It can be changed to null.
</dd>

 <dt>`親~ss@（ `parentStyleSheet$m ）◎parent CSS style sheet</dt>
 <dd>
親の`~css~ss$への参照か, または ~NULL。
この項目は、規則の作成-時に結付けられている~ssへの参照に初期化される。
これは，~NULLに変更され得る。
◎
A reference to a parent CSS style sheet or null. This item is initialized to reference an associated style sheet when the rule is created. It can be changed to null.
</dd>

 <dt>`子~規則列@◎child CSS rules</dt>
 <dd>
子 `~css規則$の~list。
この~listは変異し得る。
◎
A list of child CSS rules. The list can be mutated.
</dd>

</dl>

<p>
上の状態~項目に加え、各`~css規則$には，その`種別$に則って他の状態~項目も結付けられ得る。
◎
In addition to the above state, each CSS rule may be associated with other state in accordance with its type.
</p>

<p class="algo-head">
文字列 %文字列 を
`~css規則として構文解析-@
するときは，次を走らす：
◎
To parse a CSS rule from a string string, run the following steps:
</p>

<ol>
 <li>
%規則 ~LET %文字列 を
<a href="~CSSSYN#parse-a-rule">規則として構文解析-</a>
した結果
◎
Let rule be the return value of invoking parse a rule with string.
</li>
 <li>
~IF［
%規則 ~EQ 構文~error
］
⇒
~RET %規則
◎
If rule is a syntax error, return rule.
</li>
 <li>
%解析済~規則 ~LET 適切な CSS 仕様に従って
%規則 を構文解析し，`無視される$ものは落とした結果
<br>
~IF［
~style規則~全体が落とされた
］
⇒
~RET 構文~error
◎
Let parsed rule be the result of parsing rule according to the appropriate CSS specifications, dropping parts that are said to be ignored. If the whole style rule is dropped, return a syntax error.
</li>
 <li>
~RET %解析済~規則
◎
Return parsed rule. 
</li>
</ol>

<p class="algo-head">
`~css規則$ %規則 を
`~css規則として直列化-@
するときは、その`種別$
<span class="trans-note">【
に対応する~ifc
】</span>
に応じて，次を遂行する：
◎
To serialize a CSS rule, perform one of the following in accordance with the CSS rule’s type:
</p>

<dl class="switch">
 <dt>`CSSStyleRule!I</dt>
 <dd>
<p>
次を連結した結果：
◎
The result of concatenating the following:
</p>
  <ol>
   <li>
［
%規則 が表現している`~css~style規則$の`選択子~list$
］を `選択子~listとして直列化-$した結果
◎
The result of performing serialize a group of selectors on the rule’s associated selectors.
</li>
   <li>
~APPEND ~SP
~APPEND ❝{
~APPEND ~SP
◎
The string " { ", i.e., a single SPACE (U+0020), followed by LEFT CURLY BRACKET (U+007B), followed by a single SPACE (U+0020).
</li>
   <li>
~APPEND［
%規則 が表現している`~css~style規則$
］の`宣言列$
<span class="trans-note">【
`style$m
】</span>
］を `宣言列として直列化-$した結果
］
◎
The result of performing serialize a CSS declaration block on the rule’s associated declarations.
</li>
   <li>
~APPEND［
%規則 が表現している`~css~style規則$に宣言がないならば 空文字列 ／
~ELSE_ ~SP
］
◎
If the rule is associated with one or more declarations, the string " ", i.e., a single SPACE (U+0020).
</li>
   <li>
❝}
◎
The string "}", RIGHT CURLY BRACKET (U+007D).
</li></ol>
 </dd>

 <dt>`CSSImportRule!I</dt>
 <dd>
<p>
次を連結した結果：
◎
The result of concatenating the following:
</p>
  <ol>
   <li>
"<code class="literal">@import</code>"
~APPEND ~SP
◎
The string "@import" followed by a single SPACE (U+0020).
</li>
   <li>
~APPEND［
%規則 の所在
<span class="trans-note">【
`href$m
】</span>
を`~URLとして直列化-$した結果
］
◎
The result of performing serialize a URL on the rule’s location.
</li>
   <li>
~APPEND［
%規則 に結付けられている媒体~list
<span class="trans-note">【
`media$m
】</span>
は空でないならば［
~SP
~APPEND［
その媒体~listを`媒体~照会~listとして直列化-$した結果
］］ ／
~ELSE_ 空文字列
］
◎
If the rule’s associated media list is not empty, a single SPACE (U+0020) followed by the result of performing serialize a media query list on the media list.
</li>
   <li>
~APPEND ❝;
◎
The string ";", i.e., SEMICOLON (U+003B).
</li>
</ol>

<div class="example">
<pre class="lang-css">
`import$at url(`import.css^l);
</pre>

<pre class="lang-css">
`import$at url(`print.css^l) print;
</pre>

</div>

 </dd>

 <dt>`CSSMediaRule$I</dt>
 <dd class="issue">
~UNSPECIFIED
◎
Issue: ...
</dd>

 <dt>`CSSFontFaceRule$I</dt>
 <dd class="issue">
~UNSPECIFIED
◎
Issue: ...
</dd>

 <dt>`CSSPageRule$I</dt>
 <dd class="issue">
~UNSPECIFIED
◎
Issue: ...
</dd>

 <dt>`CSSNamespaceRule!I</dt>
 <dd>
"<code class="literal">@namespace</code>"<br>
~APPEND ~SP<br>
~APPEND［
`prefix$m 属性の値 ~NEQ 空文字列 ならば［［
それを`識別子として直列化-$した結果
］~APPEND ~SP
］］／
~ELSE_ 空文字列
］<br>
~APPEND［
`namespaceURI$m 属性の値を`~URLとして直列化-$した結果
］<br>
~APPEND 文字 ❝;
◎
The literal string "@namespace", followed by a single SPACE (U+0020), followed by the serialization as an identifier of the prefix attribute (if any), followed by a single SPACE (U+0020) if there is a prefix, followed by the serialization as URL of the namespaceURI attribute, followed the character ";" (U+003B).
</dd>
</dl>


<p class="algo-head">
`~css規則$ %規則 を `~css規則列$ss %~list の %index の位置に
`挿入-@
するときは、次を走らす：
◎
To insert a CSS rule rule in a CSS rule list list at index index, follow these steps:
</p>

<ol>
 <li>
~IF［
%index ~GT %~list の項目~数
］
⇒
~THROW `IndexSizeError$E
◎
Set length to the number of items in list.
◎
If index is greater than length, then throw an IndexSizeError exception.
</li>
 <li>
%解析済~規則 ~SET %規則 を`~css規則として構文解析-$した結果
◎
Set new rule to the results of performing parse a CSS rule on argument rule.
</li>
 <li>
~IF［
%解析済~規則 ~EQ 構文~error
］
⇒
~THROW `SyntaxError$E
◎
If new rule is a syntax error, throw a SyntaxError exception.
</li>
 <li>
<p>
~IF［
CSS 仕様
`CSS21$r
に規定される拘束に反するために，指定された %index （ゼロが先頭）に %解析済~規則 を挿入できない
］
⇒
~THROW `HierarchyRequestError$E
◎
If new rule cannot be inserted into list at the zero-index position index due to constraints specified by CSS, then throw a HierarchyRequestError exception. [CSS21]
</p>

<p class="note">注記：
例えば、~css~ssは，~style規則の後に `import$at at-規則を含められない。
◎
Note: For example, a CSS style sheet cannot contain an @import at-rule after a style rule.
</p>
 </li>
 <li>
~IF［
%解析済~規則 は `namespace$at at-規則である
］~AND［
%~list 内に［
`import$at at-規則, `namespace$at at-規則
］以外のものが含まれている
］
⇒
~THROW `InvalidStateError$E
◎
If new rule is an @namespace at-rule, and list contains anything other than @import at-rules, and @namespace at-rules, throw an InvalidStateError exception.
</li>
 <li>
%解析済~規則 を %~list の中の %index が指す位置（ゼロが先頭）に挿入する。
◎
Insert new rule into list at the zero-indexed position index.
</li>
 <li>
~RET %index
◎
Return index.
</li>
</ol>

<p class="algo-head">
`~css規則列$ss %~list から %index に位置する `~css規則$を
`除去-@
するときは、次を走らす：
◎
To remove a CSS rule from a CSS rule list list at index index, follow these steps:
</p>

<ol>
 <li>
~IF［
%index ~GTE %~list の長さ
］
⇒
~THROW `IndexSizeError$E
◎
Set length to the number of items in list.
◎
If index is greater than or equal to length, then throw an IndexSizeError exception.
</li>
 <li>
%規則 ~SET %~list 内の %index に位置する（ゼロが先頭）`~css規則$
◎
Set old rule to the indexth item in list.
</li>
 <li>
~IF［
%規則 は `namespace$at at-規則である
］~AND［
%~list 内に［
`import$at at-規則, `namespace$at at-規則
］以外のものが含まれている
］
⇒
~THROW `InvalidStateError$E
◎
If old rule is an @namespace at-rule, and list contains anything other than @import at-rules, and @namespace at-rules, throw an InvalidStateError exception.
</li>
 <li>
 %~list から %index に位置する %規則 を除去する
◎
Remove rule old rule from list at the zero-indexed position index.
</li>
 <li>
%規則 の［
`親~規則$ ／ `親~ss$
］ ~SET ~NULL
◎
Set old rule’s parent CSS rule and parent CSS style sheet to null.
</li>
</ol>


			<section id="the-cssrulelist-sequence">
<h4 title="The CSSRuleList Interface">5.4.1. `CSSRuleList^I ~ifc</h4>

<p>
`CSSRuleList$I ~ifcは、
`~css~style規則$の有順序~collectionを表現する。
◎
The CSSRuleList interface represents an ordered collection of CSS style rules.
</p>

⇒！
[`LegacyArrayClass$]
interface `CSSRuleList@I {
  getter `CSSRule$I? `item$m(~UL %index);
  ~RA ~UL `length$m;
};◎

<p>
~objの
`被support~prop~index$
の範囲は［
0 〜 ( ( ~collectionで表現される `CSSRule$I の総数 ) ~MINUS 1 )
］である（~collectionが空なら存在しないことになる）。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of CSSRule objects represented by the collection. If there are no such CSSRule objects, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>`item(index)@m</dt>
	<dd>
被呼出時には、此れの~collectionの中で %index に位置する `CSSRule$I ~objが［
在れば それ ／
無ければ ~NULL
］を返さ~MUST。
◎
The item(index) method must return the indexth CSSRule object in the collection. If there is no indexth object in the collection, then the method must return null.
</dd>

	<dt>`length@m</dt>
	<dd>
取得子は、此れの~collectionで表現される `CSSRule$I ~objの総数を返さ~MUST。
◎
The length attribute must return the number of CSSRule objects represented by the collection.
</dd>
</dl>

			</section>
			<section id="the-cssrule-interface">
<h4 title="The CSSRule Interface">5.4.2. `CSSRule^I ~ifc</h4>

<p>
`CSSRule$I ~ifcは，抽象的な基底`~css~style規則$を表現する。
各種`~css~style規則$は、その種別に応じて，この~ifcを継承する別々の~ifcで表現される。
◎
The CSSRule interface represents an abstract, base CSS style rule. Each distinct CSS style rule type is represented by a distinct interface that inherits from this interface.
</p>

⇒！
interface `CSSRule@I {
  const ~US `STYLE_RULE$m = 1;
  const ~US `CHARSET_RULE@m = 2; // <span class="comment" title="historical">歴史的</span>
  const ~US `IMPORT_RULE$m = 3;
  const ~US `MEDIA_RULE$m = 4;
  const ~US `FONT_FACE_RULE$m = 5;
  const ~US `PAGE_RULE$m = 6;
  const ~US `MARGIN_RULE$m = 9;
  const ~US `NAMESPACE_RULE$m = 10;
  ~RA ~US `type$m;
  attribute ~DS `~cssText0$m;
  ~RA `CSSRule$I? `parentRule$m;
  ~RA `CSSStyleSheet$I? `parentStyleSheet$m;
};◎

<dl class="idl-def">
	<dt>`type@m</dt>
	<dd>
<p>
取得子は、此れがどの~ifcの~instanceであるかに応じて，次で与える値を返さ~MUST：
◎
The type attribute must return the CSS rule type, as follows:
</p>


<dl class="switch">
 <dt>`CSSStyleRule$I◎If the object is a CSSStyleRule</dt>
 <dd>
`STYLE_RULE@m （数値 1 ）
◎
Return STYLE_RULE (numeric value 1).
</dd>

 <dt>`CSSImportRule$I◎If the object is a CSSImportRule</dt>
 <dd>
`IMPORT_RULE@m （数値 3 ）
◎
Return IMPORT_RULE (numeric value 3).
</dd>

 <dt>`CSSMediaRule$I◎If the object is a CSSMediaRule</dt>
 <dd>
`MEDIA_RULE@m （数値 4 ）
◎
Return MEDIA_RULE (numeric value 4).
</dd>

 <dt>`CSSFontFaceRule$I◎If the object is a CSSFontFaceRule</dt>
 <dd>
`FONT_FACE_RULE@m （数値 5 ）
◎
Return FONT_FACE_RULE (numeric value 5).
</dd>

 <dt>`CSSPageRule$I◎If the object is a CSSPageRule</dt>
 <dd>
`PAGE_RULE@m （数値 6 ）
◎
Return PAGE_RULE (numeric value 6).
</dd>

 <dt>`CSSMarginRule$I◎If the object is a CSSMarginRule</dt>
 <dd>
`MARGIN_RULE@m （数値 9 ）
◎
Return MARGIN_RULE (numeric value 9).
</dd>

 <dt>`CSSNamespaceRule$I◎If the object is a CSSNamespaceRule</dt>
 <dd>
`NAMESPACE_RULE@m （数値 10 ）
◎
Return NAMESPACE_RULE (numeric value 10).
</dd>

 <dt>その他◎Otherwise</dt>
 <dd>
<a href="https://wiki.csswg.org/spec/cssom-constants">CSSOM Constants</a>
wiki ページにて定義されている値
◎
Return a value defined on the CSSOM Constants wiki page.
</dd>

</dl>

<p class="note">注記：
値 0 は、以前は `UNKNOWN_RULE^m として知られていたが，この仕様により廃用にされた。
この値は、将来的にも利用されないものとして，予約されることになる。
◎
Note: The value 0, formerly known as UNKNOWN_RULE, is made obsolete by this specification. This value will not be re-allocated in the future and will remain reserved.
</p>

</dd>

	<dt>`~cssText0@m</dt>
	<dd>
取得子は、［
此れの`~css規則$を`~css規則として直列化-$した結果
］を返さ~MUST。
◎
↓</dd>
	<dd>
設定子は、何もしては~MUST_NOT。
◎
The cssText attribute must return a serialization of the CSS rule. On setting the cssText attribute must do nothing.
</dd>

	<dt>`parentRule@m</dt>
	<dd>
取得子は、此れの`親~規則$を返さ~MUST。
◎
The parentRule attribute must return the parent CSS rule.
</dd>
	<dd class="note">注記：
例えば、 `media$at は規則を封入し得る。
その場合、`parentRule$m は非 ~NULL になる。
封入する規則がないときの `parentRule$m は~NULLになる。
◎
Note: For example, @media can enclose a rule, in which case parentRule would be non-null; in cases where there is no enclosing rule, parentRule will be null.
</dd>

	<dt>`parentStyleSheet@m</dt>
	<dd>
取得子は、此れの`親~ss$を返さ~MUST。
◎
The parentStyleSheet attribute must return the parent CSS style sheet.
</dd>
	<dd class="note">注記：
~NULLが返されるような唯一の状況は
~css~ssから`除去-$されたときである。
◎
Note: The only circumstance where null is returned when a rule has been removed.
</dd>
	<dd class="note">注記：
`文書$から［
`LinkStyle$I ~ifcを実装する `Node^I
］が除去されても，（それだけでは） `CSSRule$I から `CSSStyleSheet$I への参照は到達できなくなるわけではない。
◎
Note: Removing a Node that implements the LinkStyle interface from a Document instance does not (by itself) cause the CSSStyleSheet referenced by a CSSRule to be unreachable.
</dd>
</dl>

			</section>
			<section id="the-cssstylerule-interface">
<h4 title="The CSSStyleRule Interface">5.4.3. `CSSStyleRule^I ~ifc</h4>

<p>
`CSSStyleRule$I ~ifcは`~css~style規則$を表現する。
◎
The CSSStyleRule interface represents a style rule.
</p>

<p class="trans-note">【
`~css~style規則@
とは、`選択子~list$と`~css宣言~block$の組である。
略して “~style規則” とも記される。
】</p>


⇒！
interface `CSSStyleRule@I : `CSSRule$I {
  attribute ~DS `selectorText$m;
  [`SameObject$, `PutForwards$=`cssText$m] ~RA `CSSStyleDeclaration$I `style$m;
};◎

<dl class="idl-def">
	<dt>`selectorText@m</dt>
	<dd>
取得子は、［
結付けられている`選択子~list$を`選択子~listとして直列化-$した結果
］を返さ~MUST。
◎
The selectorText attribute, on getting, must return the result of serializing the associated group of selectors.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
On setting the selectorText attribute these steps must be run:
</p>

<ol>
  <li>
%~list ~LET 所与の値を`選択子~listとして構文解析-$した結果
◎
Run the parse a group of selectors algorithm on the given value.
</li>
  <li>
~IF［
%~list ~NEQ ~NULL
］
⇒
結付けられている`選択子~list$ ~SET %~list
◎
If the algorithm returns a non-null value replace the associated group of selectors with the returned value.
◎
Otherwise, if the algorithm returns a null value, do nothing.
</li>
	</ol>
</dd>

	<dt>`style@m</dt>
	<dd>
<p>
取得子は、［
各種~propが次のようにされた，~style規則
］を表現する `CSSStyleDeclaration$I ~objを返さ~MUST：
<!-- 
<span class="trans-note">【
すなわち，`~css宣言~block$を表現する~obj
】</span>
 -->
◎
The style attribute must return a CSSStyleDeclaration object for the style rule, with the following properties:
</p>

<dl>
 <dt>`読専~flag$</dt>
 <dd>~OFF◎Unset.</dd>

 <dt>`宣言列$</dt>
 <dd>
この規則の中で宣言された一連の宣言からなる，`指定順$による宣言列
◎
The declared declarations in the rule, in specified order.
</dd>

 <dt>`親~css規則$</dt>
 <dd>此れ◎The context object.</dd>

 <dt>`所有者~node$</dt>
 <dd>~NULL◎Null.</dd>
</dl>

	</dd>
</dl>

<p>
`指定順@
による宣言列とは、その順序は指定された順序と同じであるが，`略式~prop$については`正準的~順序$で`下位prop$に展開されているものを意味する。
同じ~propが（`略式~prop$の展開-後に）複数回~現れる場合、~cascadingにおいて最高位のもののみが，指定された所に位置するものとして，表現され~MUST。
`CSS3CASCADE$r
◎
The specified order for declarations is the same as specified, but with shorthand properties expanded into their longhand properties, in canonical order. If a property is specified more than once (after shorthand expansion), only the one with greatest cascading order must be represented, at the same relative position as it was specified. [CSS3CASCADE]
</p>


			</section>
			<section id="the-cssimportrule-interface">
<h4 title="The CSSImportRule Interface">5.4.4. `CSSImportRule^I ~ifc</h4>

<p>
`CSSImportRule$I ~ifcは `import$at at-規則を表現する。
◎
The CSSImportRule interface represents an @import at-rule.
</p>

⇒！
interface `CSSImportRule@I : `CSSRule$I {
  ~RA ~DS `href$m;
  [`SameObject$, `PutForwards$=`mediaText$m] ~RA `MediaList$I `media$m;
  [`SameObject$] ~RA `CSSStyleSheet$I `styleSheet$m;
};◎

<dl class="idl-def">
	<dt>`href@m</dt>
	<dd>
取得子は、 `import$at at-規則に指定された <span>URL</span> を返さ~MUST。<!-- ＊ -->
◎
The href attribute must return the URL specified by the @import at-rule.
</dd>
	<dd class="note">注記：
解決された URL を取得するには，結付けられている`~css~ss$の `StyleSheet.href$m 属性を利用する。
◎
Note: To get the resolved URL use the href attribute of the associated CSS style sheet.
</dd>

	<dt>`media@m</dt>
	<dd>
取得子は、結付けられている`~css~ss$の `StyleSheet.media$m 属性の値を返さ~MUST。
◎
The media attribute must return the value of the media attribute of the associated CSS style sheet.
</dd>

	<dt>`styleSheet@m</dt>
	<dd>
取得子は、結付けられている`~css~ss$を返さ~MUST。
◎
The styleSheet attribute must return the associated CSS style sheet.
</dd>
	<dd class="note">注記：
~ssの読込みに失敗した場合、`~css規則列$ssは単に空にされる。
すなわち， `import$at at-規則には常に`~css~ss$が結付けられる。
◎
Note: If loading of the style sheet fails its CSS rules list is simply empty, i.e., an @import at-rule always has an associated CSS style sheet.
</dd>
</dl>


			</section>
			<section id="the-cssgroupingrule-interface">

<h4 title="The CSSGroupingRule Interface">5.4.5. `CSSGroupingRule^I ~ifc</h4>

<p>
`CSSGroupingRule$I
~ifcは 自身の内部に他の規則を入子にする at-規則を表現する。
◎
The CSSGroupingRule interface represents an at-rule that contains other rules nested inside itself.
</p>

⇒！
interface `CSSGroupingRule@I : `CSSRule$I {
  [`SameObject$] ~RA `CSSRuleList$I `cssRules$m;
  ~UL `insertRule$m(~DS %rule, ~UL %index);
  void `deleteRule$m(~UL %index);
};◎

<dl class="idl-def">
	<dt>`cssRules@m</dt>
	<dd>
取得子は、此れの`子~規則列$を表現する `CSSRuleList$I ~objを返さ~MUST。
◎
The cssRules attribute must return a CSSRuleList object for the child CSS rules.
</dd>

	<dt>`insertRule(rule, index)@m</dt>
	<dd>
被呼出時には、［
%rule を此れの`子~規則列$の %index の位置に`挿入-$した結果
］を返さ~MUST。
◎
The insertRule(rule, index) method must return the result of invoking insert a CSS rule rule into the child CSS rules at index.
</dd>

	<dt>`deleteRule(index)@m</dt>
	<dd>
被呼出時には、此れの`子~規則列$から
%index に位置する `~css規則$を`除去-$し~MUST。
◎
The deleteRule(index) method must remove a CSS rule from the child CSS rules at index.
</dd>
</dl>

			</section>
			<section id="the-cssmediarule-interface">
<h4 title="The CSSMediaRule Interface">5.4.6. `CSSMediaRule^I ~ifc</h4>

<p>
`CSSMediaRule$I
~ifcは `media$at at-規則を表現する。
◎
The CSSMediaRule interface represents an @media at-rule.
</p>

⇒！
interface `CSSMediaRule@I : `CSSGroupingRule$I {
  [`SameObject$, `PutForwards$=`mediaText$m] ~RA `MediaList$I `media$m;
};◎

<dl class="idl-def">
	<dt>`media@m</dt>
	<dd>
取得子は、 `media$at at-規則に指定されている`媒体~照会$の~listを表現する
`MediaList$I ~objを返さ~MUST。
◎
The media attribute must return a MediaList object for the list of media queries specified with the @media at-rule.
</dd>
</dl>

			</section>
			<section id="the-csspagerule-interface">
<h4 title="The CSSPageRule Interface">5.4.7. `CSSPageRule^I ~ifc</h4>
<p>
`CSSPageRule$I ~ifcは `page$at at-規則を表現する。
◎
The CSSPageRule interface represents an @page at-rule.
</p>

<p class="issue">
~css頁~選択子の~listを
<dfn id="parse-a-list-of-css-page-selectors">構文解析する</dfn>
ための, および
`直列化-@page
するための~~規則を定義する必要がある。
◎
Need to define the rules for parse a list of CSS page selectors and serialize a list of CSS page selectors.
</p>

⇒！
interface `CSSPageRule@I : `CSSGroupingRule$I {
  attribute ~DS `selectorText$m;
  [`SameObject$, `PutForwards$=`cssText$m] ~RA `CSSStyleDeclaration$I `style$m;
};◎

<dl class="idl-def">
	<dt>`selectorText@m</dt>
	<dd>
取得子は、［
結付けられている`~css頁~選択子の~list$を `直列化-$pageした結果
］を返さ~MUST。
◎
The selectorText attribute, on getting, must return the result of serializing the associated list of CSS page selectors.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
On setting the selectorText attribute these steps must be run:
</p>

<ol>
 <li>
%値 ~LET 所与の値を`~css頁~選択子の~listとして構文解析-$した結果
◎
Run the parse a list of CSS page selectors algorithm on the given value.
</li>
 <li>
~IF［
%値 ~NEQ ~NULL
］
⇒
結付けられている`~css頁~選択子の~list$ ~SET %値
◎
If the algorithm returns a non-null value replace the associated list of CSS page selectors with the returned value.
◎
Otherwise, if the algorithm returns a null value, do nothing.
</li>
</ol>

	</dd>

	<dt>`style@m</dt>
	<dd>
<p>
取得子は、［
各種~propが次のようにされた， `page$at at-規則
］を表現する `CSSStyleDeclaration$I ~objを返さ~MUST：
◎
The style attribute must return a CSSStyleDeclaration object for the @page at-rule, with the following properties:
</p>

<dl>
 <dt>`読専~flag$</dt>
 <dd>~OFF◎Unset.</dd>

 <dt>`宣言列$</dt>
 <dd>
この規則の中で宣言された一連の宣言からなる，`指定順$による宣言列
◎
The declared declarations in the rule, in specified order.
</dd>

 <dt>`親~css規則$</dt>
 <dd>此れ◎The context object.</dd>

 <dt>`所有者~node$</dt>
 <dd>~NULL◎Null.</dd>

</dl>
	</dd>
</dl>


			</section>
			<section id="the-cssmarginrule-interface">

<h4 title="The CSSMarginRule Interface">5.4.8. `CSSMarginRule^I ~ifc</h4>

<p>
`CSSMarginRule$I ~ifcは `page$at at-規則の中の
`~margin at-規則$ （例えば `top-left^at ）を表現する。
`CSS3PAGE$r
◎
The CSSMarginRule interface represents a margin at-rule (e.g. @top-left) in an @page at-rule. [CSS3PAGE]
</p>

⇒！
interface `CSSMarginRule@I : `CSSRule$I {
  ~RA ~DS `name$m;
  [`SameObject$, `PutForwards$=`cssText$m] ~RA `CSSStyleDeclaration$I `style$m;
};◎


<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
取得子は、`~margin at-規則$の名前を返さ~MUST。
文字  <code>@</code> は名前に含まれない。
`CSS3SYN$r
◎
The name attribute must return the name of the margin at-rule. The @ character is not included in the name. [CSS3SYN]
</dd>

	<dt>`style@m</dt>
	<dd>
<p>
取得子は、［
各種~propが次のようにされた， `~margin at-規則$
］を表現する `CSSStyleDeclaration$I ~objを返さ~MUST：
◎
The style attribute must return a CSSStyleDeclaration object for the margin at-rule, with the following properties:
</p>

<dl>
 <dt>`読専~flag$</dt>
 <dd>~OFF◎Unset.</dd>

 <dt>`宣言列$</dt>
 <dd>
この規則の中で宣言された一連の宣言からなる，`指定順$による宣言列
◎
The declared declarations in the rule, in specified order.
</dd>

 <dt>`親~css規則$</dt>
 <dd>此れ◎The context object.</dd>

 <dt>`所有者~node$</dt>
 <dd>~NULL◎Null.</dd>
</dl>

	</dd>
</dl>

			</section>
			<section id="the-cssnamespacerule-interface">
<h4 title="The CSSNamespaceRule Interface">5.4.9. `CSSNamespaceRule^I ~ifc</h4>

<p>
`CSSNamespaceRule$I ~ifcは `namespace$at at-規則を表現する。
◎
The CSSNamespaceRule interface represents an @namespace at-rule.
</p>

⇒！
interface `CSSNamespaceRule@I : `CSSRule$I {
  readonly attribute ~DS `namespaceURI$m;
  readonly attribute ~DS `prefix$m;
};◎


<dl class="idl-def">
	<dt>`namespaceURI@m</dt>
	<dd>
取得子は、此れの名前空間
<span class="trans-note">【
名前空間 URI
】</span>を返さ~MUST。
◎
The namespaceURI attribute must return the namespace of the @namespace at-rule.
</dd>

	<dt>`prefix@m</dt>
	<dd>
取得子は、［
此れの`名前空間~接頭辞$があれば それ ／
なければ空文字列
］を返さ~MUST。
◎
The prefix attribute must return the prefix of the @namespace at-rule or the empty string if there is no prefix.
</dd>
</dl>

			</section>
		</section>
		<section id="css-declarations">

<h3 title="CSS Declarations">5.5. ~css宣言</h3>

<p>
`~css宣言@
とは、~DOMにおいては~objとして公開されない抽象的な概念である。
各 `~css宣言$には、次のものが結付けられる：
◎
A CSS declaration is an abstract concept that is not exposed as an object in the DOM. A CSS declaration has the following associated properties:
</p>

<p class="trans-note">【
CSS2 の
<a href="~CSS22/syndata.html#declaration">declaration</a>
— すなわち［
~prop名: 値
］の組に対応する。
】</p>

<dl>
 <dt>`~prop名@◎property name</dt>
 <dd>
宣言の~prop名
◎
The property name of the declaration. 
</dd>

 <dt>`値@◎value</dt>
 <dd>
宣言の値を成す成分値たちからなる~listとして表現される
◎
The value of the declaration represented as a list of component values. 
</dd>

 <dt>`~important~flag@◎important flag</dt>
 <dd>
変更-可能な ~ON, ~OFF ２値をとり得る。
◎
Either set or unset. Can be changed.
</dd>
 <dd class="trans-note">【
<code>!important</code> 宣言の有無に対応する
】</dd>

 <dt>`大小区別~flag@◎case-sensitive flag</dt>
 <dd>
`~prop名$が その仕様により文字大小区別とされているとき ~ON にされ, 他の場合は ~OFF にされる。
◎
Set if the property name is defined to be case-sensitive according to its specification, otherwise unset.
</dd>
 <dd class="trans-note">【
ほぼ
<a href="~CSSVAR#defining-variables">~custom~prop用</a>
のもの
】</dd>

</dl>

		</section>
		<section id="css-declaration-blocks">
<h3 title="CSS Declaration Blocks">5.6. ~css宣言~block</h3>

<p>
`~css宣言~block@
とは、値が結付けられている~css~prop（ `~css宣言$とも呼ばれる）からなる，有順序~collectionである。
~DOMにおいては， `CSSStyleDeclaration$I ~objが`~css宣言~block$を表現する。
各 `~css宣言~block$には，次のものが結付けられる：
◎
A CSS declaration block is an ordered collection of CSS properties with their associated values, also named CSS declarations. In the DOM a CSS declaration block is a CSSStyleDeclaration object. A CSS declaration block has the following associated properties:
</p>

<p class="trans-note">【
CSS2 の
<a href="~CSS22/syndata.html#rule-sets">declaration block</a>
に対応する
】</p>

<dl>
 <dt>`読専~flag@◎readonly flag</dt>
 <dd>
~objの操作が［
可能ならば ~OFF ／
不可ならば ~ON
］にされる。
特に指定されない限り，~OFF 。
◎
Unset if the object can be manipulated. Set if it can not be manipulated. Unless otherwise stated it is unset.
</dd>

 <dt>`宣言列@◎declarations</dt>
 <dd>
~objに結付けられている一連の`~css宣言$。
◎
The CSS declarations associated with the object.
</dd>

 <dt>`親~css規則@◎parent CSS rule</dt>
 <dd>
`~css宣言~block$が結付けられている`~css規則$があれば それ ／
無ければ ~NULL
◎
The CSS rule that the CSS declaration block is associated with, if any, or null otherwise.
</dd>
 
 <dt>`所有者~node@◎owner node</dt>
 <dd>
`~css宣言~block$が結付けられている `Element$I があれば それ ／
無ければ ~NULL
◎
The Element that the CSS declaration block is associated with, if any, or null otherwise.
</dd>

</dl>

<p class="algo-head">
文字列 %文字列 を
`~css宣言~blockとして構文解析-@
するときは，次を走らす：
◎
To parse a CSS declaration block from a string string, follow these steps:
</p>

<ol>
 <li>
%宣言~list ~LET %文字列 を
<a href="~CSSSYN#parse-a-list-of-declarations">宣言の~listとして構文解析-</a>
した結果
◎
Let declarations be the return value of invoking parse a list of declarations with string.
</li>
 <li>
%解析済~宣言~list ~LET 新たな空~list
◎
Let parsed declarations be a new empty list.
</li>
 <li>
<p>
%宣言~list 内の~EACH ( %宣言 ) に対し：
◎
For each item declaration in declarations, follow these substeps:
</p>

  <ol>
   <li>
%解析済~宣言 ~LET 適切な CSS 仕様に従って
%宣言 を構文解析し，`無視される$ものは落とした結果
◎
Let parsed declaration be the result of parsing declaration according to the appropriate CSS specifications, dropping parts that are said to be ignored. If the whole declaration is dropped, let parsed declaration be null.
</li>
   <li>
~IF［
前~段により宣言~全体は落とされてはいない（ %解析済~宣言 ~NEQ 空）
］
⇒
%解析済~宣言~list に %解析済~宣言 を付加する
◎
If parsed declaration is not null, append it to parsed declarations. 
</li>
  </ol>
 </li>
 <li>
~RET %解析済~宣言~list
◎
Return parsed declarations.
</li>
</ol>

<p class="algo-head">
(
~prop名: %~prop名,
値: %値,
%~important~flag: %important
)
を伴う
`~css宣言を直列化-@
するときは、次を走らす：
◎
To serialize a CSS declaration with property name property, value value and optionally an important flag set, follow these steps:
</p>

<ol>

 <li>
%文字列 ~LET 空文字列
◎
Let s be the empty string.
</li>
 <li>
%文字列
~APPEND %~prop名
◎
Append property to s.
</li>
 <li>
%文字列
~APPEND ❝:
~APPEND ~SP
◎
Append ": " (U+003A U+0020) to s.
</li>
 <li>
%文字列
~APPEND %値
◎
Append value to s.
</li>
 <li>
~IF［
%important ~EQ ~ON
］
⇒
%文字列
~APPEND ~SP
~APPEND "<code class="literal">!important</code>"
<span class="code-point">(U+0021 U+0069 U+006D U+0070 U+006F U+0072 U+0074 U+0061 U+006E U+0074)</span>
◎
If the important flag is set, append " !important" (U+0020 U+0021 U+0069 U+006D U+0070 U+006F U+0072 U+0074 U+0061 U+006E U+0074) to s.
</li>
 <li>
%文字列
~APPEND ❝;
◎
Append ";" (U+003B) to s.
</li>
 <li>
~RET %文字列
◎
Return s.
</li>
</ol>


<p class="algo-head">
`~css宣言~block$の`宣言列$ %宣言~list を
`宣言列として直列化-@
するときは、次を走らす：
◎
To serialize a CSS declaration block declaration block means to run the steps below:
</p>


<ol>
 <li>
%~list ~LET 空~list
◎
Let list be an empty array.
</li>
 <li>
%直列化済~集合 ~LET 空~集合
◎
Let already serialized be an empty array.
</li>
 <li>
<p>
~FOR
%宣言~list 内の
~EACH ( `~css宣言$ %宣言 ) に対し：
◎
Declaration loop: For each CSS declaration declaration in declaration block’s declarations, follow these substeps:
</p>

  <ol>
   <li>
%~prop名 ~LET %宣言 の`~prop名$
◎
Let property be declaration’s property name.
</li>
   <li>
~IF［
%~prop名 ~IN %直列化済~集合
］
⇒
~CONTINUE
◎
If property is in already serialized, continue with the steps labeled declaration loop.
</li>
   <li>
<p>
~IF［
%~prop名 に対応する`略式~prop$は 一つ以上ある
］：
◎
If property maps to one or more shorthand properties, let shorthands be an array of those shorthand properties, in preferred order, and follow these substeps:
</p>

<p class="trans-note">【
“対応する（ map to ）” —
どうも定義がはっきりしないが、
%~prop名 は必ずしも（末端の）`下位prop$のみを指すわけではないようにも思われる：
例えば`略式~prop$［
`border-style$p,
`border-color$p,
`border-width$p
］は，直列化の際に，より上位の`略式~prop$ `border$p にまとめられるようにするために，
`border$p に “対応する” ものとも考えられる。
】</p>

    <ol>

     <li>
%略式~prop~list ~LET
それらの`略式~prop$の`選好順$による~list
◎
↑</li>
     <li>
<p>
%下位prop~list ~LET ［
%宣言~list 内の`~css宣言$のうち，次の両者を満たすもの
］すべてからなる~list：
</p>
		<ul>
			<li>
宣言の`~prop名$ ~NIN %直列化済~集合
</li>
			<li>
宣言の`~prop名$ ~EQ ［
%略式~prop~list 内の ある`略式~prop$の ある下位propの名前
］
</li>
		</ul>

◎
Let longhands be an array consisting of all CSS declarations in declaration block’s declarations that that are not in already serialized and have a property name that maps to one of the shorthand properties in shorthands.
</li>
     <li>
<p>
~FOR
%略式~prop~list 内の ~EACH ( %略式~prop ) に対し：
◎
Shorthand loop: For each shorthand in shorthands, follow these substeps:
</p>

      <ol>
       <li>
%下位prop名~集合 ~LET［
%略式~prop の すべての`下位prop$の`~prop名$
］からなる集合
◎
↓</li>
       <li>
%現~下位prop~list ~LET ［
%下位prop~list 内の`~css宣言$のうち，［
その`~prop名$ ~IN %下位prop名~集合
］なるもの
］すべてからなる~list
◎
↓
</li>
       <li>
~IF［
%現~下位prop~list の項目~数 ~LT %下位prop名~集合 の項目~数
］
⇒
~CONTINUE
◎
If all properties that map to shorthand are not present in longhands, continue with the steps labeled shorthand loop.
◎
Let current longhands be an empty array.
◎
Append all CSS declarations in longhands have a property name that maps to shorthand to current longhands.
</li>
		<li>
%important ~LET ［
%現~下位prop~list の最初の`~css宣言$
］の`~important~flag$
◎
↓</li>
       <li>
~IF［
%現~下位prop~list 内に［
`~important~flag$ ~NEQ %important
］なる`~css宣言$はある
］
⇒
~CONTINUE
◎
If there is one or more CSS declarations in current longhands have their important flag set and one or more with it unset, continue with the steps labeled shorthand loop.
</li>
       <li>
%値 ~LET %現~下位prop~list を`下位prop~listとして直列化-$した結果
◎
Let value be the result of invoking serialize a CSS value of current longhands.
</li>
       <li>
~IF［
%値 ~EQ 空文字列
］
⇒
~CONTINUE
◎
If value is the empty string, continue with the steps labeled shorthand loop.
</li>
       <li>
［
( ~prop名: %略式~prop, 値: %値, %~important~flag: %important )
を伴う `~css宣言を直列化-$した結果
］を %~list に付加する
◎
Let serialized declaration be the result of invoking serialize a CSS declaration with property name shorthand, value value, and the important flag set if the CSS declarations in current longhands have their important flag set.
◎
Append serialized declaration to list.
</li>
       <li>
%直列化済~集合 ~SET ［
%直列化済~集合 と %下位prop名~集合
］の和集合
◎
Append the property names of all items of current longhands to already serialized.
</li>
       <li>
%下位prop~list から %現~下位prop~list に含まれる項目すべてを除去する
◎
Remove the items present in current longhands from longhands.
</li>
      </ol>
    </li></ol>
   </li><li>
~IF［
%~prop名 ~IN %直列化済~集合
］
⇒
~CONTINUE
◎
If property is in already serialized, continue with the steps labeled declaration loop.
</li>
   <li>
%値 ~LET %宣言 の`値$を`~css値として直列化-$した結果
◎
Let value be the result of invoking serialize a CSS value of declaration.
</li>
   <li>
［
(
~prop名: %~prop名,
値: %値,
%~important~flag: %宣言 の`~important~flag$
)
を伴う `~css宣言を直列化-$した結果
］を %~list に付加する
◎
Let serialized declaration be the result of invoking serialize a CSS declaration with property name property, value value, and the important flag set if declaration has its important flag set.
◎
Append serialized declaration to list.
</li>
   <li>
%~prop名 を %直列化済~集合 に~~追加する
◎
Append property to already serialized.
</li>
  </ol>
 </li><li>
~RET %~list を~SPで区切って連結した結果
◎
Return list joined with " " (U+0020).
</li>
</ol>

<p class="note">注記：
空の`~css宣言~block$を直列化した結果は、空文字列になる。
◎
Note: The serialization of an empty CSS declaration block is the empty string.
</p>

<p class="note">注記：
空でない`~css宣言~block$を直列化した結果の，先頭／末尾 には、空白は含まれない。
すなわち，最初の~prop名の前, および最後の~prop値の最後の~semicolon区切子の後には、空白は現れない。
◎
Note: The serialization of a non-empty CSS declaration block does not include any surrounding whitespace, i.e., no whitespace appears before the first property name and no whitespace appears after the final semicolon delimiter that follows the last property value.
</p>

<p>
`略式~prop$の~list %略式~prop~list の
`選好順@
は、次で与えられる：
◎
The preferred order of a list of shorthand properties shorthands is as follows:
</p>

<ol>
 <li>
%略式~prop~list を辞書式~順序に~~整列する
◎
Order shorthands lexicographically.
</li>
 <li>
%略式~prop~list 内の ❝- から始まる項目すべてを、それらの相対的~順序は保ったまま，~listの末尾に回す
◎
Move all items in shorthands that begin with "-" (U+002D) last in the list, retaining their relative order.
</li>
 <li>
%略式~prop~list 内の［
❝- から始まる
］~AND［
`-webkit-^l からは始まらない
］ような項目すべてを、それらの相対的~順序は保ったまま，~listの末尾に回す
◎
Move all items in shorthands that begin with "-" (U+002D) but do not begin with "-webkit-" last in the list, retaining their relative order.
</li>
 <li>
<p>
%略式~prop~list を
<span class="trans-note">【
先行の段で末尾に回されたものは，その順位を保ちつつ？
】</span>
対応する`下位prop$の個数が多い順に並べる
◎
Order shorthands by the number of longhand properties that map to it, with the greatest number first.
</p>

<p class="trans-note">【
例えば
`border-style$p よりも `border$p の方が <em>末端の</em> `下位prop$の個数が多くなるので，先に来るものと考えられる。
】</p>

 </li>
</ol>


			<section id="the-cssstyledeclaration-interface">
<h4 title="The CSSStyleDeclaration Interface">5.6.1. `CSSStyleDeclaration^I ~ifc</h4>

<p>
`CSSStyleDeclaration$I
~ifcは，下層の状態も含めた`~css宣言~block$を表現する。
この下層の状態は `CSSStyleDeclaration$I ~instanceの~sourceに依存する。
◎
The CSSStyleDeclaration interface represents a CSS declaration block, including its underlying state, where this underlying state depends upon the source of the CSSStyleDeclaration instance.
</p>

⇒！
interface `CSSStyleDeclaration@I {
  [`CEReactions$] attribute ~DS `cssText$m;
  ~RA ~UL `length$m;
  getter ~DS `item$m(~UL %index);
  ~DS `getPropertyValue$m(~DS %property);
  ~DS `getPropertyPriority$m(~DS %property);
  [`CEReactions$] void `setProperty$m(
      ~DS %property,
      [`TreatNullAs$=EmptyString] ~DS %value,
      [`TreatNullAs$=EmptyString] optional ~DS %priority = ""
  );
  [`CEReactions$] void `setPropertyValue$m(
      ~DS %property,
      [`TreatNullAs$=EmptyString] ~DS %value
  );
  [`CEReactions$] void `setPropertyPriority$m(
      ~DS %property,
      [`TreatNullAs$=EmptyString] ~DS %priority
  );
  [`CEReactions$] ~DS `removeProperty$m(~DS %property);
  ~RA `CSSRule$I? `parentRule$m;
  [`CEReactions$, `TreatNullAs$=EmptyString] attribute ~DS `cssFloat$m;
};◎

<p>
~objの
`被support~prop~index$
の範囲は［
0 〜 ( ( 此れの`宣言列$に含まれている`~css宣言$の総数 ) ~MINUS 1 )
］である（ `~css宣言$が無ければ存在しないことになる）。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of CSS declarations in the declarations. If there are no such CSS declarations, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>`cssText@m</dt>
	<dd>
<p>
取得子は、［
此れの`宣言列$を `宣言列として直列化-$した結果
］を返さ~MUST。
◎
The cssText attribute must return the result of serializing the declarations.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
Setting the cssText attribute must run these steps:
</p>

<ol>
 <li>
~IF［
此れの`読専~flag$ ~EQ ~ON
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, throw a NoModificationAllowedError exception and terminate these steps.
</li>
 <li>
此れの`宣言列$を空にする
◎
Empty the declarations.
</li>
 <li>
%items ~LET 所与の値を`~css宣言~blockとして構文解析-$した結果；<br>
~IF［
%items は空~listでない
］
⇒
%items を，`指定順$により 此れの`宣言列$に挿入する
◎
Parse the given value and, if the return value is not the empty list, insert the items in the list into the declarations, in specified order.
</li>
</ol>

	</dd>

	<dt>`length@m</dt>
	<dd>
取得子は、此れの`宣言列$に含まれている`~css宣言$の個数を返さ~MUST。
◎
The length attribute must return the number of CSS declarations in the declarations.
</dd>

	<dt>`item(index)@m</dt>
	<dd>
被呼出時には、此れの`宣言列$内の %index に位置する`~css宣言$の`~prop名$を返さ~MUST。
◎
The item(index) method must return the property name of the CSS declaration at position index.
</dd>

	<dt>`getPropertyValue(property)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getPropertyValue(property) method must run these steps:
</p>

<ol>
 <li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
  <ol>
   <li>
%property ~LET %property を`~ASCII小文字~化$した結果
◎
Let property be property converted to ASCII lowercase.
</li>
   <li>
<p>
~IF［
%property は `略式~prop$の名前である
］：
</p>

    <ol>
     <li>
%下位prop名~集合 ~LET %property のすべての`下位prop$の名前からなる集合
</li>
     <li>
%宣言~list ~LET［
此れの`宣言列$内の~css宣言のうち，［
`~prop名$ ~IN %下位prop名~集合
］なるもの
］からなる，`正準的~順序$による~list
</li>
     <li>
~IF［
%宣言~list の項目~数 ~LT %下位prop名~集合 の項目~数
］
⇒
~RET 空文字列
</li>
     <li>
~IF［
%宣言~list 内のすべての~css宣言の`~important~flag$は、互いに同じである
］
⇒
~RET %宣言~list を`下位prop~listとして直列化-$した結果
</li>
     <li>
~RET 空文字列
</li>
    </ol>

<div lang="en" style="white-space:pre-wrap;">
If property is a shorthand property, then follow these substeps:
• Let list be a new empty array.
• For each longhand property longhand that property maps to, in canonical order, follow these substeps:
•• If longhand is a case-sensitive match for a property name of a CSS declaration in the declarations, let declaration be that CSS declaration, or null otherwise.
•• If declaration is null, return the empty string and terminate these steps.
•• Append the declaration to list.
• If important flags of all declarations in list are same, return the serialization of list and terminate these steps.
• Return the empty string. 
</div>
   </li>
  </ol>
 </li>
 <li>
~IF［
此れの`宣言列$内に
`~prop名$ ~EQ %property なる`~css宣言$がある
］
⇒
~RET
その宣言の`値$を`~css値として直列化-$した結果
◎
If property is a case-sensitive match for a property name of a CSS declaration in the declarations, return the result of invoking serialize a CSS value of that declaration and terminate these steps.
</li>
 <li>
~RET 空文字列
◎
Return the empty string.
</li>
</ol>

</dd>

	<dt>`getPropertyPriority(property)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getPropertyPriority(property) method must run these steps:
</p>

<ol>
 <li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
  <ol>
   <li>
%property ~LET %property を`~ASCII小文字~化$した結果
◎
Let property be property converted to ASCII lowercase.
</li>
   <li>
<p>
~IF［
%property は`略式~prop$の名前である
］：
</p>

    <ol>
     <li>
~FOR
%property に対応する ~EACH ( `下位prop$ %下位prop ) に対し
⇒
~IF［
( %下位prop )
を引数に 此れ上の `getPropertyPriority()$m を呼出した結果
~NEQ `important^l
］
⇒
~RET 空文字列
◎</li>
     <li>
~RET `important^l
</li>
    </ol>

<div lang="en" style="white-space:pre-wrap;">
If property is a shorthand property, follow these substeps:

• Let list be a new array.
• For each longhand property longhand that property maps to, append the result of invoking getPropertyPriority() with longhand as argument to list.
• If all items in list are the string "important", return the string "important" and terminate these steps.
</div>
   </li>
  </ol>
 </li>
 <li>
~IF［
此れの`宣言列$内に［
`~prop名$ ~EQ %property
］~AND［
`~important~flag$ ~EQ ~ON
］なる`~css宣言$はある
］
⇒
~RET `important^l
◎
If property is a case-sensitive match for a property name of a CSS declaration in the declarations that has the important flag set, return the string "important".
</li>
 <li>
~RET 空文字列
◎
Return the empty string.
</li>
</ol>
	</dd>
	<dd class="example">
例えば
<code class="css">background-color:`lime^v !IMPORTANT;</code>
に対し 返される値は `important^l になるであろう。
◎
E.g. for background-color:lime !IMPORTANT the return value would be "important".
</dd>

	<dt>`setProperty(property, value, priority)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setProperty(property, value, priority) method must run these steps:
</p>

<ol>
 <li>
~IF［
此れの`読専~flag$ ~EQ ~ON
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, throw a NoModificationAllowedError exception and terminate these steps.
</li>
 <li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
  <ol>
   <li>
%property ~LET %property を`~ASCII小文字~化$した結果
◎
Let property be property converted to ASCII lowercase.
</li>
   <li>
~IF［
%property は `~supportされる~css~prop$でない
］
⇒
~RET
◎
If property is not a case-sensitive match for a supported CSS property, terminate this algorithm.
</li>
  </ol>
 </li>
 <li>
~IF［
%value ~EQ 空文字列
］
⇒
( %property )
を引数に 此れ上の `removeProperty()$m を呼出す；<br>
~RET
◎
If value is the empty string, invoke removeProperty() with property as argument and terminate this algorithm.
</li>
 <li>
~IF［
%priority ~NIN `~ACI$ {  空文字列, `important^l }
］
⇒
~RET
◎
If priority is not the empty string and is not an ASCII case-insensitive match for the string "important", terminate this algorithm.
</li>
 <li>
<p>
%成分値~list ~LET %value を［
名前 %property の~prop
］の`~css値として構文解析-$した結果
◎
Let component value list be the result of parsing value for property property.
</p>

<p class="note">注記：
%value は "<code class="literal">!important</code>" を含み得ない。
◎
Note: value can not include "!important".
</p>

 </li>
 <li>
~IF［
%成分値~list ~EQ ~NULL
］
⇒
~RET
◎
If component value list is null terminate these steps.
</li>
 <li>
~IF［
%property はある`略式~prop$の名前である
］
⇒
~FOR
%property に対応する ~EACH ( `下位prop$ %下位prop ) に対し, `正準的~順序$で
⇒
此れの`宣言列$に，次を伴う`~css宣言を設定-$する
⇒
名前: %下位prop,<br>
値: %成分値~list 内の %下位prop に対応する部分,<br>
%~important~flag: ［
%priority ~NEQ 空文字列ならば ~ON ／
~ELSE_ ~OFF
］
◎
If property is a shorthand property, then for each longhand property longhand that property maps to, in canonical order, set the CSS declaration longhand with the appropriate value(s) from component value list, with the important flag set if priority is not the empty string, and unset otherwise, and with the list of declarations being the declarations.
</li>
 <li>
~ELSE
⇒
此れの`宣言列$に，次を伴う`~css宣言を設定-$する
⇒
名前: %property,<br>
値: %成分値~list,<br>
%~important~flag: ［
%priority ~NEQ 空文字列ならば ~ON ／
~ELSE_ ~OFF
］
◎
Otherwise, set the CSS declaration property with value component value list, with the important flag set if priority is not the empty string, and unset otherwise, and with the list of declarations being the declarations.
</li>
</ol>
	</dd>
</dl>

<p>
宣言~list %宣言~list に，
(
名前: %~prop名,
値: %成分値~list,
%~important~flag: %important
) を伴う
`~css宣言を設定-@
するときは、次を走らす：
◎
To set a CSS declaration property with a value component value list and optionally with an important flag set, in a list of declarations declarations, follow these steps:
</p>

<ol>
 <li>
~IF［
%宣言~list 内に［
`~prop名$ ~EQ %~prop名
］なる`~css宣言$はある
］
⇒
%宣言 ~LET その`~css宣言$
◎
If property is a case-sensitive match for a property name of a CSS declaration in declarations, let declaration be that CSS declaration.
</li>
 <li>
~ELSE
⇒
%宣言 ~LET `~prop名$ %~prop名 を伴う新たな`~css宣言$；<br>
%宣言 を %宣言~list に付加する
◎
Otherwise, append a new CSS declaration with the property name property to declarations and let declaration be that CSS declaration.
</li>
 <li>
%宣言 の`値$ ~SET %成分値~list
◎
Set declaration’s value to component value list.
</li>
 <li>
%宣言 の`~important~flag$ ~SET %important
◎
If the important flag is set, set declaration’s important flag. Otherwise, unset declaration’s important flag.
</li>
</ol>



<dl class="idl-def">
	<dt>`setPropertyValue(property, value)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setPropertyValue(property, value) method must run these steps:
</p>

<ol>
 <li>
~IF［
此れの`読専~flag$ ~EQ ~ON
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, throw a NoModificationAllowedError exception and terminate these steps.
</li>
 <li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
  <ol>
   <li>
%property ~LET %property を`~ASCII小文字~化$した結果
◎
Let property be property converted to ASCII lowercase.
</li>
   <li>
~IF［
%property は `~supportされる~css~prop$でない
］
⇒
~RET
◎
If property is not a case-sensitive match for a supported CSS property, terminate this algorithm.
</li>
  </ol>
 </li>
 <li>
~IF［
%value ~EQ 空文字列
］
⇒
( %property )
を引数に 此れ上の `removeProperty()$m を呼出す；<br>
~RET
◎
If value is the empty string, invoke removeProperty() with property as argument and terminate this algorithm.
</li>
 <li>
<p>
%成分値~list ~LET %value を［
名前 %property の~prop
］の`~css値として構文解析-$した結果
◎
Let component value list be the result of parsing value for property property.
</p>

<p class="note">注記：
%value は "<code class="literal">!important</code>" を含み得ない。
◎
Note: value can not include "!important".
</p>

 </li>
 <li>
~IF［
%成分値~list ~EQ ~NULL
］
⇒
~RET
◎
If component value list is null terminate these steps.
</li>
 <li>
~IF［
%property はある`略式~prop$の名前である
］
⇒
~FOR
%property に対応する ~EACH ( `下位prop$ %下位prop ) に対し, `正準的~順序$で
⇒
此れの`宣言列$の中で，
( 名前: %下位prop, 値: %成分値~list 内の %下位prop に対応する部分 )
を入力に`~css宣言の値を設定-$する
◎
If property is a shorthand property, then for each longhand property longhand that property maps to, in canonical order, set the CSS declaration value longhand to the appropriate value(s) from component value list, and with the list of declarations being the declarations.
</li>
 <li>
~ELSE
⇒
此れの`宣言列$の中で，
( 名前: %property, 値: %成分値~list )
を入力に`~css宣言の値を設定-$する
⇒

◎
Otherwise, set the CSS declaration value property to the value component value list, and with the list of declarations being the declarations.
</li>
</ol>

	</dd>
</dl>

<p class="algo-head">
宣言~list %宣言~list の中で，
(
名前: %~prop名
値: %成分値~list
) を入力に
`~css宣言の値を設定-@
するときは、次を走らす：
◎
To set a CSS declaration value to a value component value list in a list of declarations declarations, follow these steps:
</p>

<ol>
 <li>
~IF［
%宣言~list 内に［
`~prop名$ ~EQ %~prop名
］なる`~css宣言$はある
］
⇒
%宣言 ~LET その`~css宣言$
◎
If property is a case-sensitive match for a property name of a CSS declaration in declarations, let declaration be that CSS declaration.
</li>
 <li>
~ELSE
⇒
%宣言 ~LET `~prop名$ %~prop名 を伴う新たな`~css宣言$；<br>
%宣言 を %宣言~list に付加する
◎
Otherwise, append a new CSS declaration with the property name property to declarations and let declaration be that CSS declaration.
</li>
 <li>
%宣言 の`値$ ~SET %成分値~list
◎
Set declaration’s value to component value list.
</li>
</ol>


<dl class="idl-def">
	<dt>`setPropertyPriority(property, priority)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setPropertyPriority(property, priority) method must run these steps:
</p>

<ol>
 <li>
~IF［
此れの`読専~flag$ ~EQ ~ON
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, throw a NoModificationAllowedError exception and terminate these steps.
</li>
 <li>
%property ~LET %property を`~ASCII小文字~化$した結果
◎
Let property be property converted to ASCII lowercase.
</li>
 <li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
  <ol>
   <li>
~IF［
%property は`~supportされる~css~prop$でない
］
⇒
~RET
◎
If property is not a case-sensitive match for a supported CSS property, terminate this algorithm.
</li>
   <li>
~IF［
%priority ~NIN `~ACI$ { 空文字列, `important^l }
］
⇒
~RET
◎
If priority is not the empty string and is not an ASCII case-insensitive match for the string "important", terminate this algorithm.
</li>
  </ol>
 </li>
 <li>
%~important ~LET ［
%priority ~NEQ 空文字列ならば ~ON ／
~ELSE_ ~OFF
］
◎
↓</li>
 <li>
~IF［
%property は ある`略式~prop$の名前である
］
⇒
~FOR
%property に対応する ~EACH ( `下位prop$ %下位prop ) に対し, `正準的~順序$で
⇒
此れの`宣言列$の中で，
( %下位prop, %~important )
を入力に
`~css宣言の優先度を設定-$する
◎
If property is a shorthand property, then for each longhand property longhand that property maps to, in canonical order, set the CSS declaration priority longhand with the important flag set if priority is not the empty string, and unset otherwise, and with the list of declarations being the declarations.
</li>
 <li>
~ELSE
⇒
此れの`宣言列$の中で，
( %property, %~important )
を入力に
`~css宣言の優先度を設定-$する
◎
Otherwise, set the CSS declaration priority property with the important flag set if priority is not the empty string, and unset otherwise, and with the list of declarations being the declarations.
</li>
</ol>
	</dd>
</dl>

<p>
宣言~list %宣言~list の中で，
( %~prop名, %~important )
を入力に
`~css宣言の優先度を設定-@
するときは、次を走らす：
◎
To set a CSS declaration priority property optionally with an important flag set, in a list of declarations declarations, follow these steps:
</p>

<ol>
 <li>
~IF［
%宣言~list 内に［
`~prop名$ ~EQ %~prop名
］なる`~css宣言$はある
］
⇒
その`~css宣言$の`~important~flag$ ~SET %important
◎
If property is a case-sensitive match for a property name of a CSS declaration in declarations, let declaration be that CSS declaration.
◎
Otherwise, terminate these steps.
◎
If the important flag is set, set declaration’s important flag. Otherwise, unset declaration’s important flag.
</li>
</ol>


<dl class="idl-def">
	<dt>`removeProperty(property)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeProperty(property) method must run these steps:
</p>

<ol>
 <li>
~IF［
此れの`読専~flag$ ~EQ ~ON
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, throw a NoModificationAllowedError exception and terminate these steps.
</li>
 <li>
~IF［
%property は`~custom~prop名$でない
］
⇒
%property ~SET %property を`~ASCII小文字~化$した結果
◎
If property is not a custom property, let property be property converted to ASCII lowercase. 
</li>
 <li>
%値 ~LET
( %property )
を引数に 此れ上の `getPropertyValue()$m を呼出した結果
◎
Let value be the return value of invoking getPropertyValue() with property as argument.
</li>
 <li>
~IF［
%property は ある`略式~prop$の名前である
］
⇒
~FOR
%property に対応する ~EACH ( `下位prop$ %下位prop ) に対し <!-- $ canonical-orderで -->
⇒
( %下位prop )
を引数に 此れ上の `removeProperty()$m を呼出す
◎
If property is a shorthand property, for each longhand property longhand that property maps to, invoke removeProperty() with longhand as argument.
</li>
 <li>
此れの`宣言列$から，［
`~prop名$ ~EQ %property
］なる`~css宣言$を（もしあれば）除去する
◎
Otherwise, if property is a case-sensitive match for a property name of a CSS declaration in the declarations, remove that CSS declaration.
</li>
 <li>
~RET %値
◎
Return value.
</li>
</ol>

	</dd>

	<dt>`parentRule@m</dt>
	<dd>
取得子は、此れの`親~css規則$を返さ~MUST。
◎
The parentRule attribute must return the parent CSS rule.
</dd>

	<dt>`cssFloat@m</dt>
	<dd>
取得子は、［
( `float^l )
を引数に 此れ上の `getPropertyValue()$m を呼出した結果
］を返さ~MUST。
◎
↓</dd>
	<dd>
設定子は、
( `float^l, 所与の値 )
を引数に 此れ上の `setProperty()$m を呼出さ~MUST（ 3 個目の引数は省略する）。
例外は再投出され~MUST。
◎
The cssFloat attribute, on getting, must return the result of invoking getPropertyValue() with float as argument. On setting, the attribute must invoke setProperty() with float as first argument, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</dd>
</dl>

<p>
`~supportされる~css~prop$に含まれる各~propに対し、次の部分的~ifcが適用される。
ここで， ~camel_cased_attr は、その~prop名を`IDL 属性~名に変換$した名前である。
◎
For each CSS property property that is a supported CSS property, the following partial interface applies where camel-cased attribute is obtained by running the CSS property to IDL attribute algorithm for property.
</p>

⇒！
partial interface `CSSStyleDeclaration$I {
  [`CEReactions$, `TreatNullAs$=EmptyString] attribute ~DS _`~camel_cased_attr$m;
};◎


<p class="trans-note">【
IDL における先頭の ❝_ は、属性の識別子の一部ではなく， IDL 構文の一部（~escape）であることに注意。
】</p>


<dl class="idl-def">
	<dt>`~camel_cased_attr@m</dt>
	<dd>
<p>
取得子は、［
( この属性の名前を`~css~prop名に変換$した結果 )
を引数に 此れ上の `getPropertyValue()$m を呼出した結果
］を返さ~MUST。
◎
The camel-cased attribute attribute, on getting, must return the result of invoking getPropertyValue() with the argument being the result of running the IDL attribute to CSS property algorithm for camel-cased attribute.
</dd>
	<dd>
設定子は、
( この属性の名前を`~css~prop名に変換$した結果, 所与の値 )
を引数に 此れ上の `setProperty()$m を呼出さ~MUST（ 3 個目の引数は省略する）
— 例外は再投出され~MUST。
◎
Setting the camel-cased attribute attribute must invoke setProperty() with the first argument being the result of running the IDL attribute to CSS property algorithm for camel-cased attribute, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</dd>
	<dd class="example">
例えば `font-size$p ~propに対しては， `fontSize^m IDL 属性が存在することになる。
◎
For example, for the font-size property there would be a fontSize IDL attribute.
</dd>
</dl>

<p>
［
`~supportされる~css~prop$であって, かつ
文字列 `-webkit-^l から始まる
］ような各 %~prop に対し、次の部分的~ifcが適用される。
ここで， ~webkit_cased_attr は、［
%小文字先頭~flag ~SET ~ON
］の下で， %~prop を`IDL 属性~名に変換$して得られる名前である：
◎
For each CSS property property that is a supported CSS property and that begins with the string -webkit-, the following partial interface applies where webkit-cased attribute is obtained by running the CSS property to IDL attribute algorithm for property, with the lowercase first flag set.
</p>

⇒！
partial interface `CSSStyleDeclaration$I {
  [`CEReactions$, `TreatNullAs$=EmptyString] attribute DOMString _`~webkit_cased_attr$m;
};
◎


<dl class="idl-def">
	<dt>`~webkit_cased_attr@m</dt>
	<dd>
取得子は、
( 下に与える %属性~名 )
を引数に 此れ上の `getPropertyValue()$m を呼出した結果を返さ~MUST。
◎
The webkit-cased attribute
attribute, on getting, must return the result of invoking getPropertyValue() with the argument being the result of running the IDL attribute to CSS property algorithm for webkit-cased attribute, with the dash prefix flag set.
</dd>
	<dd>
設定子は、
( 下に与える %属性~名, 所与の値 )
を引数に 此れ上の `setProperty()$m を呼出さ~MUST（ 3 個目の引数は省略する）
— 例外は再投出され~MUST
◎
Setting the webkit-cased attribute attribute must invoke setProperty() with the first argument being the result of running the IDL attribute to CSS property algorithm for webkit-cased attribute, with the dash prefix flag set, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</dd>
	<dd>
ここでの %属性~名 は、［
%接頭dash~flag ~SET ~ON
］の下に，この属性の名前を`~css~prop名に変換$した結果とする。
◎
↑</dd>
	<dd class="example">
例えば，~UAが `-webkit-transform^p ~propを~supportするならば、
`webkitTransform^m IDL 属性が在ることになる。
`~camel_cased_attr$m 属性に対する規則により，
`WebkitTransform^m IDL 属性も在ることになる。
◎
For example, if the user agent supports the -webkit-transform property, there would be a webkitTransform IDL attribute. There would also be a WebkitTransform IDL attribute because of the rules for camel-cased attributes.
</dd>
</dl>


<p>
［
`~supportされる~css~prop$であって，かつ
~prop名に ❝- が含まれる
］ような，各  %~prop に対しては、次の 部分的~ifcが適用される
— ここで，~dashed_attr は その %~prop の名前とする：
◎
For each CSS property property that is a supported CSS property, except for properties that have no "-" (U+002D) in the property name, the following partial interface applies where dashed attribute is property.
</p>


⇒！
partial interface `CSSStyleDeclaration$I {
  [`CEReactions$, `TreatNullAs$=EmptyString] attribute DOMString _`~dashed_attr$m;
};◎


<dl class="idl-def">
	<dt>`~dashed_attr@m</dt>
	<dd>
取得子は、［
( この属性の名前 )
を引数に 此れ上の `getPropertyValue()$m を呼出した結果
］を返さ~MUST。
◎
The dashed attribute attribute, on getting, must return the result of invoking getPropertyValue() with the argument being dashed attribute.
</dd>
	<dd>
設定子は、
( この属性の名前, 所与の値 )
を引数に 此れ上の `setProperty()$m を呼出さ~MUST（ 3 個目の引数は省略する）
— 例外は再投出され~MUST。
◎
Setting the dashed attribute attribute must invoke setProperty() with the first argument being dashed attribute, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</dd>
	<dd class="example">
<p>
例えば `font-size$p ~propに対しては、 IDL 属性 `font-size^m が存在することになる。
JavaScript においては、 %要素 を
<a href="~HTMLINFRA#html-elements">HTML 要素</a>
とするとき，この~propは 次の様に~accessできる：
◎
For example, for the 'font-size' property there would be a font-size IDL attribute. In JavaScript, the property can be accessed as follows, assuming element is an HTML element:
</p>

<pre class="lang-js">
%要素.style['font-size'];
</pre>
	</dd>
</dl>

<p class="algo-head">
%小文字先頭~flag の下で，所与の~css~prop名 %~prop を
`IDL 属性~名に変換@
する~algoは次で与えられる：
◎
The CSS property to IDL attribute algorithm for property, optionally with a lowercase first flag set, is as follows:
</p>

<ol>
	<li>
%出力 ~LET 空文字列
◎
Let output be the empty string.
</li>
	<li>
%次~大文字~化 ~LET ~F
◎
Let uppercase next be unset.
</li>
    <li>
~IF［
%小文字先頭~flag ~EQ ~ON
］
⇒
%~prop から最初の文字を除去する
◎
If the lowercase first flag is set, remove the first character from property. </li>
	<li>
<p>
~FOR
~prop 内の~EACH ( 文字 %c ) に対し：
◎
For each character c in property:
</p>
		<ol>
			<li>
~IF［
%c ~EQ ❝-
］
⇒
%次~大文字~化 ~SET ~T
◎
If c is "-" (U+002D), let uppercase next be set.
</li>
			<li>
~ELIF［
%次~大文字~化 ~EQ ~T
］
⇒
%次~大文字~化 ~SET ~F；<br>
%出力
~APPEND［
%c を`~ASCII大文字~化$した結果
］
◎
Otherwise, if uppercase next is set, let uppercase next be unset and append c converted to ASCII uppercase to output.
</li>
			<li>
~ELSE
⇒
%出力
~APPEND %c
◎
Otherwise, append c to output.
</li>
		</ol>

	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="algo-head">
%接頭dash~flag の下で，所与の IDL 属性~名を
`~css~prop名に変換@
する~algoは次で与えられる：
◎
The IDL attribute to CSS property algorithm for attribute, optionally with a dash prefix flag set, is as follows:
</p>

<ol>
	<li>
%出力 ~LET 空文字列
◎
Let output be the empty string.
</li>
    <li>
~IF［
%接頭dash~flag ~EQ ~ON
］
⇒
%出力
~APPEND ❝-
◎
If the dash prefix flag is set, append "-" (U+002D) to output.
</li>
	<li>
<p>
~FOR
IDL 属性~名~内の~EACH ( 文字 %c ) に対し：
◎
For each character c in attribute:
</p>
		<ol>
			<li>
~IF［
%c ~IN { ❝A 〜 ❝Z }
］
⇒
%出力
~APPEND ❝-
~APPEND［
%c を`~ASCII小文字~化$した結果
］
◎
If c is in the range U+0041 to U+005A (ASCII uppercase), append "-" (U+002D) followed by c converted to ASCII lowercase to output.
</li>
			<li>
~ELSE
⇒
%出力
~APPEND %c
◎
Otherwise, append c to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

			</section>
		</section>
		<section id="css-values">
<h3 title="CSS Values">5.7. ~css値</h3>

			<section id="parsing-css-values">
<h4 title="Parsing CSS Values">5.7.1. ~css値の構文解析法</h4>

<p class="algo-head">
所与の %値 を所与の［
名前 %~prop名 の~prop
］の`~css値として構文解析-@
するときは、次を走らす：
◎
To parse a CSS value value for a given property means to follow these steps:
</p>

<ol>
 <li>
%~list ~LET
%値 から
<a href="~CSSSYN#parse-a-list-of-component-values">成分値の~listを構文解析-</a>
した結果
◎
Let list be the value returned by invoking parse a list of component values from value.
</li>
 <li>
~IF［
%~list は CSS 仕様の［
名前 %~prop名 の~prop
］の文法に合致する
］
⇒
~RET %~list
◎
Match list against the grammar for the property property in the CSS specification.
</li>
 <li>
~RET ~NULL
◎
If the above step failed, return null.
◎
Return list.
</li>
</ol>


<p class="note">注記：
"<code class="literal">!important</code>"
宣言は、~propの値~空間の一部ではなく，したがって`~css値として構文解析-$した結果は~NULLになる。
◎
Note: "!important" declarations are not part of the property value space and will therefore cause parse a CSS value to return null.
</p>

			</section>
			<section id="serializing-css-values">
<h4 title="Serializing CSS Values">5.7.2. ~css値の直列化法</h4>


<p class="algo-head">
<!-- `略式~prop$ %略式~prop に対応する ＊-->
［
`下位prop$の`~css宣言$からなる~list %~list
］を
`下位prop~listとして直列化-@
するときは、次を走らす：
◎
To serialize a CSS value of a CSS declaration declaration or a list of longhand CSS declarations list, follow these rules:
◎
If this algorithm is invoked with a list list, follow these substeps:
</p>

<p class="trans-note">【
原文では後述の~css値を`~css値として直列化-$する~algoと一緒にされて定義されているが、入力と処理内容が別物なので，この訳では２つに分割している。
】</p>

<ol>
 <li>
%略式~prop ~LET %~list の中のすべての`下位prop$に正確に対応する`略式~prop$
— そのような %略式~prop が複数ある場合
<span class="trans-note">【具体例？】</span>
は
`選好順$において先に来るものを選ぶ
◎
Let shorthand be the shorthand property that exactly maps to all the longhand properties in list. If there are multiple such shorthand properties, use the first in preferred order.
</li>
 <li>
<p>
~IF［
%略式~prop は その文法の下で %~list の一連の値を表現できない
］
⇒
~RET 空文字列
◎
If shorthand cannot represent the values of list in its grammar, return the empty string and terminate these steps.
</p>
<p class="trans-note">【
例えば %~list の中の各~宣言に対する !important の有無が統一されていない場合は？
（空文字列が返される？）。
】</p>

</li>
 <li>
%省略済~list ~LET 空~list
◎
Let trimmed list be a new empty array.
</li>
 <li>
%~list 内の~EACH ( `~css宣言$ %宣言 ) に対し
⇒
~IF［
%宣言 の`値$ ~NEQ `初期値$ ~OR
%宣言 は %略式~prop の必須の成分である
］
⇒
%宣言 を %省略済~list に付加する
◎
For each CSS declaration declaration in list, if declaration’s value is not the initial value, or if declaration is a required component of the shorthand property, append declaration to trimmed list.
</li>
 <li>
~IF［
%省略済~list は空である
］
⇒
%~list 内の最初の項目の値を %省略済~list に付加する
◎
If trimmed list is empty, append the value of the first item in list to trimmed list.
</li>
 <li>
%値~list ~LET 空~list
◎
Let values be a new empty array.
</li>
 <li>
%省略済~list 内の~EACH ( `~css宣言$ %宣言 ) に対し
⇒
［
%宣言 を`~css値として直列化-$した結果
］を %値~list に付加する
◎
For each CSS declaration declaration in trimmed list, invoke serialize a CSS value of declaration, and append the result to values.
</li>
 <li>
~RET %値~list を %略式~prop の文法に従って適切に連結した結果
◎
Return the result of joining values as appropriate according to the grammar of shorthand and terminate these steps.
</li>
</ol>

<p class="algo-head">
`~css宣言$ %宣言 の`値$ %値 を
`~css値として直列化-@
するときは、次を走らす：
◎
↑</p>

<ol>
 <li>
%値~list ~LET 空~list
◎
Let values be a new empty array.
</li>
 <li>
~FOR
%値 内の~EACH( %成分 ) に対し
⇒
［
%成分 を`~css成分値として直列化-$した結果
］を %値~list に付加する
◎
Append the result of invoking serialize a CSS component value of declaration’s value to values.
</li>
 <li>
~IF［
%宣言 の`~prop名$の文法は空白~区切りとして定義されている
］
⇒
~RET %値~list を`空白~区切りで直列化-$した結果
◎
If the grammar of the property name of declaration is defined to be whitespace-separated, return the result of invoking serialize a whitespace-separated list of values and terminate these steps.
</li>
 <li>
~IF［
%宣言 の`~prop名$の文法は~comma区切りとして定義されている
］
⇒
~RET %値~list を`~comma区切りで直列化-$した結果
◎
If the grammar of the property name of declaration is defined to be comma-separated, return the result of invoking serialize a comma-separated list of values.
</li>
</ol>


<p class="algo-head">
所与の %成分 を
`~css成分値として直列化-@
した結果は、 %成分 の型に応じて，次で与えられる：
◎
To serialize a CSS component value depends on the component, as follows:
</p>

<dl class="switch">
 <dt>keyword</dt>
 <dd>
~keywordを`~ASCII小文字~化$した結果
◎
The keyword converted to ASCII lowercase.
</dd>

 <dt>`angle$t</dt>
 <dd>
［
`number^t 成分を `number^t として直列化した結果
］<br>
~APPEND［
当該の仕様にて定義される単位を表す正準形の文字列
］
◎
The &lt;number&gt; component serialized as per &lt;number&gt; followed by the unit in canonical form as defined in its respective specification.
</dd>

 <dt>`color$t</dt>
 <dd>
  <dl>
   <dt>`color^t は`解決値$または`算出値$の成分である場合：
◎
If &lt;color&gt; is a component of a resolved or computed value, then return the color using the rgb() or rgba() functional notation as follows:
</dt>
   <dd><!-- en-box -->

<p>
%comma_space ~LET ［
❝,
~APPEND ~SP
］
</p>

<p>
結果は次の連結（ `rgb()^l ／ `rgba()^l 関数記法による直列化）：
◎
If the alpha component of the color is equal to one, then return the serialization of the rgb() functional equivalent of the opaque color.
◎
If the alpha component of the color is not equal to one, then return the serialization of the rgba() functional equivalent of the non-opaque color.
◎
The serialization of the rgb() functional equivalent is the concatenation of the following:
</p>
    <ol>
     <li>
色の~alpha成分が［
~EQ 1 （不透明）ならば `rgb(^l ／
~NEQ 1 ならば `rgba(^l
］
◎
The string "rgb(".
◎
The shortest base-ten integer serialization of the color’s red component.
◎
The string ", ".
◎
The shortest base-ten serialization of the color’s green component.
◎
The string ", ".
◎
The shortest base-ten serialization of the color’s blue component.
◎
The string ")".
◎
The serialization of the rgba() functional equivalent is the concatenation of the following:
◎
The string "rgba(".
</li>
     <li>
~APPEND［
色の赤（ red ）成分の，最短の基数10整数 直列化
］
◎
The shortest base-ten serialization of the color’s red component.
</li>
     <li>
~APPEND %comma_space
◎
The string ", ".
</li>
     <li>
~APPEND［
色の緑（ green ）成分の，最短の基数10整数 直列化
］
◎
The shortest base-ten serialization of the color’s green component.
</li>
     <li>
~APPEND %comma_space
◎
The string ", ".
</li>
     <li>
~APPEND［
色の青（ blue ）成分の，最短の基数10整数 直列化
］
◎
The shortest base-ten serialization of the color’s blue component.
</li>
     <li>
<p>
~IF［
色の~alpha成分 ~NEQ 1
］
⇒
~APPEND %comma_space
~APPEND［
色の~alpha成分を `alphavalue^t として直列化した結果
］
◎
The string ", ".
◎
The serialization of the color’s alpha component as an &lt;alphavalue&gt;.
</p>
     </li>
     <li>
~APPEND ❝)
◎
The string ")".
◎
In the above rules, the string ", " denotes a COMMA (U+002C) followed by a single SPACE (U+0020).
</li>
    </ol>
   </dd>

   <dt>
`color^t は`指定値$の成分である場合：
◎
If &lt;color&gt; is a component of a specified value, then return the color as follows:
</dt>
   <dd>
<p>
色は作者により明示的に指定されたものであるならば，作者により指定された元の（文字列としての）色~値
／
~ELSE_ 色は`算出値$の成分であったとしたときに返されることになる値
◎
If the color was explicitly specified by the author, then return the original, author specified color value.
◎
Otherwise, return the value that would be returned if the color were a component of a computed value.
</p>

<p class="issue">
作者による`指定値$における文字の大小は、正規化すべきか？
あるいは，保全されるべきか？
◎
Should author specified values be normalized for case? Or should original case be preserved?
</p>
   </dd>

   <dt>`alphavalue^t</dt>
   <dd>
<p>
~IF［
値は内部的に 0 〜 255 の範囲の整数（すなわち， 8-bit 符号なし整数）として表現されている
］：
◎
If the value is internally represented as an integer between 0 and 255 inclusive (i.e. 8-bit unsigned integer), follow these steps:
</p>
     <ol>
      <li>
%alpha ~LET その整数
◎
Let alpha be the given integer.
</li>
      <li>
~IF［
0 〜 100 の範囲の整数のうち, ［［
2.55 倍してから最も近い整数に丸めた結果（二数が等距離にある場合は切り上げる）
］ ~EQ %alpha
］になるものがある
］
⇒
%rounded ~LET その整数 ÷ 100
◎
If there exists an integer between 0 and 100 inclusive that, when multiplied with 2.55 and rounded to the closest integer (rounding up if two values are equally close), equals alpha, let rounded be that integer divided by 100.
</li>
      <li>
~ELSE
⇒
%rounded ~LET %alpha ÷ 0.255 を最も近い整数に丸めた結果（二数が等距離にある場合は切り上げる） ÷ 1000
◎
Otherwise, let rounded be alpha divided by 0.255 and rounded to the closest integer (rounding up if two values are equally close), divided by 1000.
</li>
      <li>
~RET %rounded を `number^t として直列化した結果
◎
Return the result of serializing rounded as a &lt;number&gt;.
</li>
     </ol>

<p>
~RET 所与の値を `number^t として直列化した結果
◎
Otherwise, return the result of serializing the given value as a &lt;number&gt;.
</p>
   </dd>
  </dl>
 </dd>

 <dt>`counter^t</dt>
 <dd>
<p>
次の連結：
◎
The return value of the following algorithm:
</p>

  <ol>
   <li>
`counter^t 内の~css成分値の個数が［
３個ならば `counters(^l ／
２個ならば `counter(^l
］
◎
Let s be the empty string.
◎
If &lt;counter&gt; has three CSS component values append the string "counters(" to s.
◎
If &lt;counter&gt; has two CSS component values append the string "counter(" to s.
</li>
   <li>
~APPEND［［
`counter^t 内の~EACH ( ~css成分値 ) を`~css成分値として直列化-$して得られる~list —
ただし，最後の~css成分値 ~EQ `decimal^l のときはそれを除外する
］を`~comma区切りで直列化-$した結果
］
◎
Let list be a list of CSS component values belonging to &lt;counter&gt;, omitting the last CSS component value if it is "decimal".
◎
Let each item in list be the result of invoking serialize a CSS component value on that item.
◎
Append the result of invoking serialize a comma-separated list on list to s.
</li>
   <li>
~APPEND ❝)
◎
Append ")" (U+0029) to s.
◎
Return s. 
</li>
  </ol>
 </dd>

 <dt>`frequency$t</dt>
 <dd>
［［
所与の値が表現する hertz 単位の周波数
］を `number^t として直列化した結果
］~APPEND `hz^l
◎
The frequency in hertz serialized as per &lt;number&gt; followed by the literal string "hz".
</dd>

 <dt>`identifier$t</dt>
 <dd>
`識別子として直列化-$した結果
◎
The identifier serialized as an identifier.
</dd>

 <dt>`integer$t</dt>
 <dd>
［
負ならば ❝- ／
~ELSE_ 空文字列
］<br>
~APPEND［
❝0 〜 ❝9 を用いた最短形の基数10整数
］
◎
A base-ten integer using digits 0-9 (U+0030 to U+0039) in the shortest form possible, preceded by "-" (U+002D) if it is negative.
</dd>

 <dt>`length$t</dt>
 <dd>
  <dl>
   <dt>長さ ~EQ ゼロ</dt>
   <dd>
`0px^l
◎
A length of zero is represented by the literal string "0px".
</dd>

   <dt>長さは絶対的である</dt>
   <dd>
［［
長さが表現する millimeter 単位による数
］を `number^t として直列化した結果
］
~APPEND `mm^l
◎
Absolute lengths: the number of millimeters serialized as per &lt;number&gt; followed by the literal string "mm".
</dd>
   <dd class="issue">
Rumor has it absolute lengths will become relative lengths. Centimeters would be compatible with &lt;resolution&gt;...
<span class="trans-note">【？】</span>
</dd>

   <dt>長さは相対的である</dt>
   <dd>
［
長さの `number^t 成分を `number^t として直列化した結果
］<br>
~APPEND［
当該の仕様にて定義される単位を表す正準形の文字列
］
◎
Relative lengths: the &lt;number&gt; component serialized as per &lt;number&gt; followed by the unit in its canonical form as defined in its respective specification.
</dd>
  </dl>
 </dd>

 <dt>`number$t</dt>
 <dd>
<p>
❝0 〜 ❝9 を用いた最短形の基数10数
— 小数部がある場合は ❝. で区切った上で，
<span class="trans-note">【
小数部が？
】</span>
6 桁を超えるときは値を丸め、負の場合は ❝- を前置する
◎
A base-ten number using digits 0-9 (U+0030 to U+0039) in the shortest form possible, using "." to separate decimals (if any), rounding the value if necessary to not produce more than 6 decimals, preceded by "-" (U+002D) if it is negative.
</p>

<p class="note">注記：
科学的記数法は利用されない。
◎
Note: scientific notation is not used.
</p>
 </dd>

 <dt>`percentage$t</dt>
 <dd>
［
所与の値の `number^t 成分を `number^t として直列化した結果
］
~APPEND ❝%
◎
The &lt;number&gt; component serialized as per &lt;number&gt; followed by the literal string "%" (U+0025).
</dd>

 <dt>`resolution$t</dt>
 <dd>
［［
所与の値が表現する， 1 CSS ~pixelあたりの~dot数による解像度
］を `number^t として直列化した結果
］
~APPEND `dppx^l
◎
The resolution in dots per CSS pixel serialized as per &lt;number&gt; followed by the literal string "dppx".
</dd>

 <dt>`shape$t</dt>
 <dd>
<p>
`rect(^l<br>
~APPEND［［
`shape^t 内の~EACH ( ~css成分値 ) を`~css成分値として直列化-$して得られる~list
］を`~comma区切りで直列化-$した結果
］<br>
~APPEND ❝)
</p>

<div lang="en" style="white-space:pre-wrap;">
The return value of the following algorithm:
• Let s be the string "rect(".
• Let list be a list of the CSS component values belonging to &lt;shape&gt;.
• Let each item in list be the result of invoking serialize a CSS component value of that item.
• Append the result of invoking serialize a comma-separated list on list to s.
• Append ")" (U+0029) to s.
• Return s.
</div>
 </dd>

 <dt>`string$t</dt>
 <dt>`family-name$t</dt>
 <dt>`specific-voice^t</dt>
 <dd>
`文字列として直列化-$した結果
◎
The string serialized as a string. 
</dd>

 <dt>`time$t</dt>
 <dd>
［［
所与の値が表現する秒~単位による数
］を `number^t として直列化した結果
］
~APPEND ❝s
◎
The time in seconds serialized as per &lt;number&gt; followed by the literal string "s".
</dd>

 <dt>`uri$t</dt>
 <dd>
`絶対~URL$を`~URLとして直列化-$した結果
◎
The absolute URL serialized as URL.
</dd>
</dl>

<p>
`absolute-size^t, `border-width^t, `border-style^t, `bottom^t, `generic-family^t, `generic-voice^t, `left^t, `margin-width^t, `padding-width^t, `relative-size^t, `right^t, `top^t
は、この仕様では~macroと見なされる。
これらはすべて上に示された成分の~instanceを表現する。
◎
&lt;absolute-size&gt;, &lt;border-width&gt;, &lt;border-style&gt;, &lt;bottom&gt;, &lt;generic-family&gt;, &lt;generic-voice&gt;, &lt;left&gt;, &lt;margin-width&gt;, &lt;padding-width&gt;, &lt;relative-size&gt;, &lt;right&gt;, and &lt;top&gt;, are considered macros by this specification. They all represent instances of components outlined above.
</p>

<p class="issue">
この節を除去することも考えられる —
上の定義をその~css成分を定義する CSS3／CSS4 の過程のどこかの草案に移行させることにより。
◎
One idea is that we can remove this section somewhere in the CSS3/CSS4 timeline by moving the above definitions to the drafts that define the CSS components.
</p>

				<section id="examples-0">
<h5 title="Examples">5.7.2.1. 用例集</h5>

<p>
ここに、指定値<!-- specified-value -->に対する処理の前後の結果を示す，いくつかの例を挙げる：
“処理前” の列は 作者が~ssに記したものを表し,
“処理後” の列は~DOMが返すことになる値を表す。
◎
Here are some examples of before and after results on specified values. The before column could be what the author wrote in a style sheet, while the after column shows what querying the DOM would return.
</p>

<div class="example">

<table><thead><tr><th>処理前◎Before
</th><th>処理後◎After
</th></tr></thead>

<tbody><tr><td>`background: none^css
</td><td>`background: rgba(0, 0, 0, 0)^css

</td></tr><tr><td>`outline: none^css
</td><td>`outline: invert^css

</td></tr><tr><td>`border: none^css
</td><td>`border: medium^css

</td></tr><tr><td>`list-style: none^css
</td><td>`list-style: disc^css

</td></tr><tr><td>`margin: 0 1px 1px 1px^css
</td><td>`margin: 0px 1px 1px^css

</td></tr><tr><td>`azimuth: behind left^css
</td><td>`azimuth: 220deg^css

</td></tr><tr><td>`font-family: a, 'b"', serif^css
</td><td>`font-family: "a", "b\"", serif^css

</td></tr><tr><td>`content: url('h)i') '\[\]'^css
</td><td>`content: url("h)i") "[]"^css

</td></tr><tr><td>`azimuth: leftwards^css
</td><td>`azimuth: leftwards^css

</td></tr><tr><td>`color: rgb(18, 52, 86)^css
</td><td>`color: #123456^css

</td></tr><tr><td>`color: rgba(000001, 0, 0, 1)^css
</td><td>`color: #000000^css

</td></tr></tbody></table>

<p class="issue">
これらの一部は新たな規則で更新される必要がある。
◎
Some of these need to be updated per the new rules.
</p>
</div>

				</section>
			</section>
		</section>
	</section>
	<section id="dom-access-to-css-declaration-blocks">
<h2 title="DOM Access to CSS Declaration Blocks">6. ~css宣言~blockへの~DOM~access</h2>

		<section id="the-elementcssinlinestyle-interface">
<h3 title="The ElementCSSInlineStyle Interface">6.1. `ElementCSSInlineStyle^I ~ifc</h3>

<p>
`ElementCSSInlineStyle$I
~ifcは、要素の~inline  ~style~propへの~accessを提供する。
◎
The ElementCSSInlineStyle interface provides access to inline style properties of an element.
</p>

⇒！
[`NoInterfaceObject$]
interface `ElementCSSInlineStyle@I {
  [`SameObject$, `PutForwards$=cssText] ~RA `CSSStyleDeclaration$I `style$m;
};◎

<dl class="idl-def">
	<dt>`style@m</dt>
	<dd>
<p>
取得子は、［
各種~propが次のようにされた，~live`~css宣言~block$
］を返さ~MUST：
◎
The style attribute must return a live CSS declaration block with the following properties:
</p>

<dl>
 <dt>`読専~flag$</dt>
 <dd>~OFF◎Unset.</dd>

 <dt>`宣言列$</dt>
 <dd>
要素の `style^a 内容~属性を`指定順$により`~css宣言~blockとして構文解析-$した結果。
`style^a 内容~属性が存在しない場合，この~objは空の［
`~css宣言$の~list
］を表現する。
`宣言列$が変異されるときは、要素の `style^a 内容~属性<!-- `内容~属性$ -->の値も［
`CSSStyleDeclaration$I の`宣言列$を `宣言列として直列化-$した結果
］にされ~MUST。
`style^a 内容~属性が
設定-／変更-／除去-
された際には，それに応じて`宣言列$も適宜~更新され~MUST。
◎
The result of parsing the style content attribute, in specified order. If the style content attribute is absent, the object represents an empty list of CSS declarations. Mutating the declarations must set the style content attribute on the context object to the serialization of the declarations. If the style content attribute is set, changed or removed, the declarations must be updated as appropriate.
</dd>

 <dt>`親~css規則$</dt>
 <dd>~NULL◎Null.</dd>

 <dt>`所有者~node$</dt>
 <dd>此れ◎The context object.</dd>
</dl>
	</dd>
</dl>


<p>
~UAが HTML を~supportする場合は，次の IDL が適用される：
`HTML$r
◎
If the user agent supports HTML, the following IDL applies: [HTML]
</p>

⇒！
<a href="~HTMLdom#htmlelement">HTMLElement</a> implements `ElementCSSInlineStyle$I;◎

<p>
~UAが SVG を~supportする場合は，次の IDL が適用される：
`SVG$r
◎
If the user agent supports SVG, the following IDL applies: [SVG]
</p>

⇒！
SVGElement implements `ElementCSSInlineStyle$I;◎


		</section>
		<section id="extensions-to-the-window-interface">
<h3 title="Extensions to the Window Interface">6.2. `Window^I ~ifcに対する拡張</h3>

⇒！
partial interface `Window@I {
  [`NewObject$] `CSSStyleDeclaration$I `getComputedStyle$m(`Element$I %elt, optional ~DS? %pseudoElt);
};◎

<dl class="idl-def">
	<dt>`getComputedStyle(elt, pseudoElt)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getComputedStyle(elt, pseudoElt) method must run these steps:
</p>

<ol>
 <li>
%文書 ~LET 此れに結付けられている`文書$
◎
Let doc be the Document associated with the Window object on which the method was invoked.
</li>
 <li>
%要素 ~LET %elt
◎
Let obj be elt.
</li>
 <li>
~IF［
%pseudoElt ~IN `~ACI$ { `:before^l, `::before^l }
］
⇒
%要素 ~LET %elt の `before$pe 疑似要素
◎
If pseudoElt is as an ASCII case-insensitive match for either ':before' or '::before' let obj be the ::before pseudo-element of elt.
</li>
 <li>
~IF［
%pseudoElt ~IN `~ACI$ { `:after^l, `::after^l }
］
⇒
%要素 ~LET %elt の `after$pe 疑似要素
◎
If pseudoElt is as an ASCII case-insensitive match for either ':after' or '::after' let obj be the ::after pseudo-element of elt.
</li>
 <li>

<p>
~RET 各種~propが次のようにされた，~live`~css宣言~block$：
◎
Return a live CSS declaration block with the following properties:
</p>

  <dl>
   <dt>`読専~flag$</dt>
   <dd>
~ON
◎
Set.
</dd>

   <dt>`宣言列$</dt>
   <dd>
<p>
辞書式~順序による，すべての［
`~supportされる~css~prop$である`下位prop$
］からなる。
その各~propの値は、 %文書 に結付けられている~style規則を用いて，その~propについて %要素 に対し算出される `解決値$で与えられる。
◎
All longhand properties that are supported CSS properties, in lexicographical order,  with the value being the resolved value computed for obj using the style rules associated with doc.
</dd>
   <dd class="note">注記：
これは、 %要素 が異なる文書に属していても（例えば `XMLHttpRequest^I を通して取得されたもの）、［［［
（`~css宣言~block$を算出するために）
`getComputedStyle()$m が呼出された大域~obj
］に結付けられている文書
］に結付けられている~style規則
］が用いられることを意味する。
◎
Note: This means that even if obj is in a different document (e.g. one fetched via XMLHttpRequest) it will still use the style rules associated with the document that is associated with the global object on which getComputedStyle() was invoked to compute the CSS declaration block.
</dd>

   <dt>`親~css規則$</dt>
   <dd>~NULL
◎
Null.
</dd>

   <dt>`所有者~node$</dt>
   <dd>%要素
◎
obj.
</dd>
</dl>

 </li>
</ol>

</dd>
</dl>

<p class="warning">
`getComputedStyle()$m
~methは、`origin-clean ~flag$ss ~EQ ~OFF の下でも，`~css~ss$からの情報を公開する。
◎
The getComputedStyle() method exposes information from CSS style sheets with the origin-clean flag unset.
</p>

		</section>
	</section>
	<section id="utility-apis">

<h2 title="Utility APIs">7. ~utility API</h2>

		<section id="the-css.escape()-method">

<h3 title="The CSS.escape() Method">7.1. `CSS.escape()^m ~meth</h3>

<p>
`CSS$I ~ifcは、他に属さない有用な CSS に関係する機能を保持する。
◎
The CSS interface holds useful CSS-related functions that do not belong elsewhere.
<!-- 
The CSS interface is defined in CSS Conditional Rules Module. [CSS3-CONDITIONAL]
 -->
</p>

⇒！
interface `CSS@I {
  static ~DS `escape$m(~DS %ident);
};◎

<dl class="idl-def">
	<dt>`escape(ident)@m</dt>
	<dd>
この静的~methの被呼出時には、［
%ident を `識別子として直列化-$した結果
］を返さ~MUST。
◎
The escape(ident) method must return the result of invoking serialize an identifier of ident.
</dd>

	<dd class="example">
<p>
`escape()$m ~methを利用して直列化すれば、未知の文字列でも，選択子の一部として利用できるようになる：
◎
For example, to serialize a string for use as part of a selector, the escape() method can be used:
</p>

<pre class="lang-js">
var %element = document.querySelector(
  '#' + CSS.escape(%id) + ' &gt; img'
);
</pre>

<p>
厳密には、~escape不要な文字まで~escapeするが：
◎
The escape() method can also be used for escaping strings, although it escapes characters that don’t strictly need to be escaped:
</p>

<pre>
var %element = document.querySelector(
  'a[href="#' + CSS.escape(%fragment) + '"]'
);
</pre>

	</dd>
</dl>

<p>
`CSS$I ~ifc上に静的~関数を定義する仕様は、格納したい状態があるならば、`現在の大域~obj$に`結付けられている文書$に格納するべきである。
◎
Specifications that define static functions on the CSS interface and want to store some state should store the state on the current global object’s associated Document.
</p>

		</section>
	</section>
	<section id="resolved-values">
<h2 title="Resolved Values">8. 解決値</h2>

<p>
`Window!I の `getComputedStyle()$m は、歴史的に，要素や`疑似要素$の “`算出値$” を返すように定義されていた。
しかしながら，既存の~scriptとの互換性のために `getComputedStyle()$m の実装は変えるわけにいかない一方で、“`算出値$” の概念は， CSS の変遷に伴って変化してきている。
この課題に取組むため、この仕様は
`解決値@
の概念を導入する。
◎
getComputedStyle() was historically defined to return the "computed value" of an element or pseudo-element. However, the concept of "computed value" changed between revisions of CSS while the implementation of getComputedStyle() had to remain the same for compatibility with deployed scripts. To address this issue this specification introduces the concept of a resolved value.
</p>

<p class="algo-head">
所与の下位propに対する`解決値$は，~propの種類に応じて次で与えられる：
◎
The resolved value for a given longhand property can be determined as follows:
</p>

<dl class="switch">
	<dt>`background-color$p
	<dt>`border-block-end-color$p
	<dt>`border-block-start-color$p
	<dt>`border-bottom-color$p
	<dt>`border-inline-end-color$p
	<dt>`border-inline-start-color$p
	<dt>`border-left-color$p
	<dt>`border-right-color$p
	<dt>`border-top-color$p
	<dt>`box-shadow$p
	<dt>`caret-color$p
	<dt>`color$p
	<dt>`line-height$p
	<dt>`outline-color$p
	<dd>
`使用値$
◎
The resolved value is the used value.
</dd>

	<dt>`block-size$p</dt>
	<dt>`height$p</dt>
	<dt>`inline-size$p</dt>
	<dt>`margin-block-end$p</dt>
	<dt>`margin-block-start$p</dt>
	<dt>`margin-bottom$p</dt>
	<dt>`margin-inline-end$p</dt>
	<dt>`margin-inline-start$p</dt>
	<dt>`margin-left$p</dt>
	<dt>`margin-right$p</dt>
	<dt>`margin-top$p</dt>
	<dt>`padding-block-end$p</dt>
	<dt>`padding-block-start$p</dt>
	<dt>`padding-bottom$p</dt>
	<dt>`padding-inline-end$p</dt>
	<dt>`padding-inline-start$p</dt>
	<dt>`padding-left$p</dt>
	<dt>`padding-right$p</dt>
	<dt>`padding-top$p</dt>
	<dt>`width$p</dt>
	<dd>
<p>
次のいずれも満たされるならば `使用値$ ／
~ELSE_ `算出値$：
</p>

<ul ><li>~propは要素または`疑似要素$に適用されている
</li><li>当の要素~上の `display$p ~propの`解決値$ ~NIN { `none^v, `contents^v }
</li></ul>

◎
If the property applies to the element or pseudo-element and the resolved value of the display property is not none or contents, then the resolved value is the used value. Otherwise the resolved value is the computed value.
</dd>

	<dt>`bottom$p</dt>
	<dt>`left$p</dt>
	<dt>`offset-block-end$p</dt>
	<dt>`offset-block-start$p</dt>
	<dt>`offset-inline-end$p</dt>
	<dt>`offset-inline-start$p</dt>
	<dt>`right$p</dt>
	<dt>`top$p</dt>
	<dd>
<p>
次のいずれも満たされるならば `使用値$ ／
~ELSE_ `算出値$：
</p>

<ul ><li>~propは，`有位置の要素$に適用されている
</li><li>当の要素~上の `display$p ~propの`解決値$ ~NIN { `none^v, `contents^v }
</li><li>~propは，拘束過多でない
</li></ul>
◎
If the property applies to a positioned element and the resolved value of the display property is not none or contents, and the property is not over-constrained, then the resolved value is the used value. Otherwise the resolved value is the computed value.
</dd>

	<dt>その他の~prop</dt>
	<dd>
`算出値$
◎
The resolved value is the computed value.
</dd>
</dl>

	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">9. IANA Considerations</h2>

		<section id="default-style">
<h3 title="Default-Style">9.1. `Default-Style^h ~header~field</h3>

<p>
この節では、
Permanent Message Header Field Registry
に登録される~header~fieldについて述べる。
◎
This section describes a header field for registration in the Permanent Message Header Field Registry.
</p>

  <dl>
   <dt>~header~field名◎Header field name</dt>
   <dd>`Default-Style@h</dd>
   <dt>適用し得る~protocol◎Applicable protocol</dt>
   <dd>http</dd>
   <dt>位置付け◎Status</dt>
   <dd>標準◎standard</dd>
   <dt>~~作成／~~変更 管理◎Author/Change controller</dt>
   <dd>W3C</dd>
   <dt>仕様~文書◎Specification document(s)</dt>
   <dd>この文書◎This document is the relevant specification.</dd>
   <dt>関連~情報◎Related information</dt>
   <dd>なし◎None.</dd>
  </dl>

		</section>
	</section>
	<section id="change-history">
<h2 title="Change History">10. 変更履歴</h2>

<p>
この節では、この仕様の各~発行版の間の変更点の一部を文書~化する。
この節は，網羅的なものではない。
~bug修正および編集上の変更点は、一般に挙げられない。
◎
This section documents some of the changes between publications of this specification. This section is not exhaustive. Bug fixes and editorial changes are generally not listed.
</p>

		<section id="changes-from-5-december-2013">
<h3 title="Changes From 5 December 2013">10.1. 2013 年 12 月 5 日以降の変更点</h3>

<ul>

	<li>
代替~ss用の API 
— `Document$I 上の次の~memberは除去された
⇒
`selectedStyleSheetSet^m,
`lastStyleSheetSet^m,
`preferredStyleSheetSet^m,
`styleSheetSets^m,
`enableStyleSheetsForSet()^m
◎
API for alternative stylesheets is removed: selectedStyleSheetSet, lastStyleSheetSet, preferredStyleSheetSet, styleSheetSets, enableStyleSheetsForSet() on Document.
</li>
	<li>
`Element$I ／ `PseudoElement^I ~ifc上の
`pseudo()^m ~methは除去された。
◎
The pseudo() method on Element and the PseudoElement interface is removed.
</li>
	<li>
`Element$I 上の次の属性は除去された
⇒
`cascadedStyle^m, `defaultStyle^m, `rawComputedStyle^m, `usedStyle^m
◎
The cascadedStyle, defaultStyle, rawComputedStyle and usedStyle IDL attributes on Element are removed.
</li>
	<li>
`CSSRule$I 上の `~cssText0$m 属性~設定子は、何もしないように変更された。
◎
The cssText IDL attribute’s setter on CSSRule is changed to do nothing.
</li>
	<li>
`CSSStyleDeclaration$I 上に `~webkit_cased_attr$m
— `webkitFoo^m の形の属性（小文字の `w^c ） —
が追加された。
◎
IDL attributes of the form webkitFoo (with lowercase w) on CSSStyleDeclaration are added.
</li>
	<li>
`CSSNamespaceRule$I は、読専に変更された。
◎
CSSNamespaceRule is changed back to readonly.
</li>
	<li>
`CSSStyleSheet!I の `insertRule()$m における
`charset^at の取り扱いは、除去された。
◎
Handling of @charset in insertRule() is removed.
</li>
	<li>
`CSSCharsetRule^I は再び除去された。
◎
CSSCharsetRule is removed again.
</li>
	<li>
識別子／文字列の直列化が変更された。
◎
Serialization of identifiers and strings is changed.
</li>
	<li>
選択子の直列化は、今や［
結合子 `&gt;&gt;^l, `||^l
］, および［
属性~選択子における `i^l ~flag
］も~supportする。
◎
Serialization of selectors now supports combinators "&gt;&gt;" and "||" and the "i" flag in attribute selectors.
</li>
	<li>
`lang()$ps の直列化が変更された。
◎
Serialization of :lang() is changed.
</li>
	<li>
`color$t, `number$t
の直列化が変更された。
◎
Serialization of &lt;color&gt; and &lt;number&gt; is changed.
</li>
	<li>
`CSSStyleDeclaration!I 上の `setProperty()$m は変更された。
◎
setProperty() on CSSStyleDeclaration is changed.
</li>
</ul>

		</section>
		<section id="changes-from-12-july-2011-to-5-december-2013">
<h3 title="Changes From 12 July 2011 To 5 December 2013">10.2. 2011 年 7 月 12 日から 2013 年 12 月 5 日までの変更点</h3>

<ul>
	<li>
非同一生成元~ssの読み取りや変更は許容されない。
◎
Cross-origin stylesheets are not allowed to be read or changed.
</li>
	<li>
`CSSCharsetRule$I ~ifc が再び導入された。
◎
CSSCharsetRule is re-introduced.
</li>
	<li>
`CSSGroupingRule$I, `CSSMarginRule$I が導入された。
◎
CSSGroupingRule and CSSMarginRule are introduced.
</li>
	<li>
`CSSNamespaceRule$I は今や変異可能である。
◎
CSSNamespaceRule is now mutable.
</li>
	<li>
`~css宣言~blockとして構文解析-$, および
~css宣言~blockの `宣言列として直列化-$が定義された。
◎
Parse and serialize a CSS declaration block is now defined.
</li>
	<li>
<!-- `CSSStyleDeclaration!I -->
`setProperty()$m,
`getPropertyValue()$m,
等々に対する略式~propが~supportされた。
◎
Shorthands are now supported in setProperty(), getPropertyValue(), et al.
</li>
	<li>
`setPropertyValue()$m,
`setPropertyPriority()$m
が導入された。
◎
setPropertyValue() and setPropertyPriority() are introduced.
</li>
	<li>
種々の~ifcにおける `style^m, `media^m 属性は、
WebIDL 拡張属性 [`PutForwards$] 注釈付きにされた。
◎
The style and media attributes of various interfaces are annotated with the [PutForwards] WebIDL extended attribute.
</li>
	<li>
`Element!I 上に `pseudo()^m ~methが導入された。†
◎
The pseudo() method on Element is introduced.
</li>
	<li>
`PseudoElement^I ~ifc が導入された。†
◎
The PseudoElement interface is introduced.
</li>
	<li>
`Element$I, `PseudoElement^I 上に
<!-- GetStyleUtils!I -->
`cascadedStyle^m,
`rawComputedStyle^m,
`usedStyle^m
属性が導入された。†
◎
The cascadedStyle, rawComputedStyle and usedStyle attributes on Element and PseudoElement are introduced.
</li>
	<li>
静的~meth `CSS.escape()$m が導入された。
◎
The CSS.escape() static method is introduced. 
</li>
</ul>

<p class="trans-note">【†
いったん導入されたが、再び削除された。
】</p>

		</section>
	</section>

</main><!--  id="MAIN" -->

	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様の作成に寄与された次の方々に感謝する：
</p>

<p>
The editors would like to thank

Alexey Feldgendler,
Benjamin Poulain,
Björn Höhrmann,
Boris Zbasky,
Brian Kardell,
Christian Krebs,
Daniel Glazman,
David Baron,
Domenic Denicola,
Dominique Hazael-Massieux,
<i>fantasai</i>,
Hallvord R. M. Steen,
Ian Hickson,
John Daggett,
Lachlan Hunt,
Mike Sherov,
Myles C. Maxfield,
Morten Stenshorne,
Ms2ger,
Øyvind Stenhaug,
Peter Sloetjes,
Philip Jägenstedt,
Philip Taylor,
Richard Gibson,
Robert O’Callahan,
Simon Sapin,
Sjoerd Visscher,
Sylvain Galineau,
Tarquin Wilton-Jones,
Xidorn Quan, and
Zack Weinberg

for contributing to this specification.
</p>

<p>
加えて、代替スタイルシート API, および
~css値の正準化（現在は “直列化”）規則の初期のバージョンを記述された Ian Hickson 氏に特別な謝意を。
<span lang="en">
Additional thanks to Ian Hickson for writing the initial version of the alternative style sheets API and canonicalization (now serialization) rules for CSS values.
</span></p>

	</section>
	<section>

<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>

	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>

<dl>

	<dt>[CSS-BACKGROUNDS-3]</dt>
	<dd>CSS Backgrounds and Borders Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-backgrounds-3/</dd>

	<dt>[CSS-CASCADE-4]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4.</dd>
	<dd>http://dev.w3.org/csswg/css-cascade/</dd>

	<dt>[CSS-COLOR-3]</dt>
	<dd>CSS Color Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-color-3/</dd>

	<dt>[CSS-COLOR-4]</dt>
	<dd>Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4.</dd>
	<dd>https://drafts.csswg.org/css-color/</dd>

	<dt>[CSS-DISPLAY-3]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3.</dd>
	<dd>http://dev.w3.org/csswg/css-display/</dd>

	<dt>[CSS-LOGICAL-PROPS-1]</dt>
	<dd>CSS Logical Properties Module Level 1</dd>
	<dd>https://drafts.csswg.org/css-logical-props-1/</dd>

	<dt>[CSS-NAMESPACES-3]</dt>
	<dd>Elika Etemad. CSS Namespaces Module Level 3.</dd>
	<dd>http://dev.w3.org/csswg/css-namespaces/</dd>

	<dt>[CSS-POSITION-3]</dt>
	<dd>Rossen Atanassov; Arron Eicholz. CSS Positioned Layout Module Level 3.</dd>
	<dd>https://drafts.csswg.org/css-position/</dd>

	<dt>[CSS-PSEUDO-4]</dt>
	<dd>Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4.</dd>
	<dd>https://drafts.csswg.org/css-pseudo-4/</dd>

	<dt>[CSS-UI-3]</dt>
	<dd>Tantek Çelik; Florian Rivoal. CSS Basic User Interface Module Level 3 (CSS3 UI).</dd>
	<dd>http://dev.w3.org/csswg/css-ui/</dd>

	<dt>[CSS-VALUES-3]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3.</dd>
	<dd>https://drafts.csswg.org/css-values/</dd>

	<dt>[CSS-VARIABLES-1]</dt>
	<dd>Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1.</dd>
	<dd>http://dev.w3.org/csswg/css-variables/</dd>

	<dt>[CSS21]</dt>
	<dd>Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC.</dd>
	<dd>https://www.w3.org/TR/CSS2</dd>

	<dt>[CSS22]</dt>
	<dd>Bert Bos. Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification.</dd>
	<dd>http://dev.w3.org/csswg/css2/</dd>

	<dt>[CSS3CASCADE]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 3.</dd>
	<dd>https://drafts.csswg.org/css-cascade-3/</dd>

	<dt>[CSS3PAGE]</dt>
	<dd>Melinda Grant; et al. CSS Paged Media Module Level 3. 14 March 2013. WD.</dd>
	<dd>https://www.w3.org/TR/css3-page/</dd>

	<dt>[CSS3SYN]</dt>
	<dd>Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3.</dd>
	<dd>http://dev.w3.org/csswg/css-syntax/</dd>

	<dt>[DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>

	<dt>[ENCODING]</dt>
	<dd>Anne van Kesteren. Encoding Standard. Living Standard.</dd>
	<dd>https://encoding.spec.whatwg.org/</dd>

	<dt>[FETCH]</dt>
	<dd>Anne van Kesteren. Fetch Standard. Living Standard.</dd>
	<dd>https://fetch.spec.whatwg.org/</dd>

	<dt>[HTML]</dt>
	<dd>Anne van Kesteren; et al. HTML Standard. Living Standard.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

	<dt>[MEDIAQUERIES-4]</dt>
	<dd>Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4.</dd>
	<dd>https://drafts.csswg.org/mediaqueries-4/</dd>

<!-- 
	<dt>[RFC2119]</dt>
 -->

	<dt>[SELECTORS-4]</dt>
	<dd>Selectors Level 4</dd>
	<dd>https://drafts.csswg.org/selectors-4/</dd>

	<dt>[SVG2]</dt>
	<dd>Nikos Andronikos; et al. Scalable Vector Graphics (SVG) 2.</dd>
	<dd>https://svgwg.org/svg2-draft/</dd>

	<dt>[URL]</dt>
	<dd>Anne van Kesteren. URL Standard. Living Standard.</dd>
	<dd>https://url.spec.whatwg.org/</dd>

	<dt>[WebIDL]</dt>
	<dd>Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL.</dd>
	<dd>https://heycam.github.io/webidl/</dd>

	<dt>[XML]</dt>
	<dd>Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC.</dd>
	<dd>https://www.w3.org/TR/xml</dd>

	<dt>[XML-STYLESHEET]</dt>
	<dd>James Clark; Simon Pieters; Henry Thompson. Associating Style Sheets with XML documents 1.0 (Second Edition). 28 October 2010. REC.</dd>
	<dd>https://www.w3.org/TR/xml-stylesheet</dd>
</dl>


		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<dl>

	<dt>[CSS-FONTS-3]</dt>
	<dd>John Daggett. CSS Fonts Module Level 3.</dd>
	<dd>http://dev.w3.org/csswg/css-fonts/</dd>

	<dt>[DOM-LEVEL-2-STYLE]</dt>
	<dd>Chris Wilson; Philippe Le Hégaret. Document Object Model (DOM) Level 2 Style Specification. 13 November 2000. REC.</dd>
	<dd>https://www.w3.org/TR/DOM-Level-2-Style/</dd>

	<dt>[SVG]</dt>
	<dd>Jon Ferraiolo. Scalable Vector Graphics (SVG) 1.0 Specification. 4 September 2001. REC.</dd>
	<dd>https://www.w3.org/TR/SVG/</dd>
</dl>

		</section>
	</section>

	<section>
<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>

	</section>
	<section>
<h2 id="idl-index" title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<h2 id="issues-index" title="Issues Index" data-cycling=".issue">課題索引</h2>

<p class="trans-note">【
これらの節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>


</body>
