<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Flexible Box Layout Module Level 1 （変更点）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script >
var source_data;

COMMON_DATA.page_state_key = '___CSS';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://drafts.csswg.org/css-flexbox/',
		spec_status: 'ED',
		main: 'MAIN',
		fill_text_link: '#_versions > dd, #references dd',
	};

	Util.DEFERRED.push(
		function(){
			COMMON_DATA.altURL = EMPTY_FUNC;
		}
	)

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		val_prop_map: Util.getMapping('_val_prop_map'),
		toc_main: 'MAIN0',
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};

	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 170216

	return options;
}

function expand(mapping1){
	var link_map = this.link_map;
	var val_prop_map = this.val_prop_map;

	var nesting = '';

	var class_map = {
		p: 'property',
		pe: 'pseudo',
		d: 'descriptor',
		v: 'value',
		t: 'type',
	};

	var tag_map = {
		p: 'code',
		pe: 'code',
		d: 'code',
		v: 'code',
		t: 'var',
		V: 'var',
	};

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/【.*?】|⇒|◎[^<◎`]*|%[\w~一-鿆]+|`(.{1,40}?)([$@\^!])(\w*)(?::([\w\-]+))?/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass, values){
if(!indicator) {
	switch(match.charAt(0)){
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	case '◎':
	default:
	}
	var result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'pe': 
	text = '::' + key;
	break;
case 'v': // css values
	if(values){
		href = '~CSSFLEX#valdef-' + val_prop_map[values] + '-' + key
		values = '';
	}
	break;
case 't': // typedef
	text = '&lt;' + key + '&gt;';
	break;
case 'cg':
	text = '変更箇所';
	href = '~CSSFLEX#' + key;
	break;
case 'iS':
	return (
		'<a href="~WGFLEX/issues-' + key + '">Issue '
		+ key.replace(/^.+?(?=\d+$)/, '') + '</a>'
	);
default:
}


if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

if(values) {
	text = 
		'<code class="css">'
		+ text
		+ ': <code class="value">'
		+ values.replace(/_/g, ' ')
		+ '</code></code>'
}

return text;

	}
}



</script>


<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
</script>

<script type="text/plain" id="_val_prop_map">
min:min-width
d:display
f:flex
fd:flex-direction
fg:flex-grow
fs:flex-shrink
fb:flex-basis
fw:flex-wrap
ff:flex-flow
o:order
j:justify-content
ais:align-items
as:align-self
ac:align-content

</script>

<!--%置換データ -->
<script type="text/plain" id="words_table1">
WGFLEX:https://drafts.csswg.org/css-flexbox-1

auto_v:<code class="value">auto</code> 
min-height:min-height
min-width:min-width
</script>

<!--%語彙置換データ-->
<script type="text/plain" id="words_table">
	●仕様
拘束:constraint:~
	拘束-:constrain:~
競合:conflict:~
	言明:asserted
期待:expectation:~
受容-:accept:~
	反映:Pass 〜 through
省略-:omit:~
単純化-:simplify:~
相互作用:interaction:~
検査-:check:~
利用-:use:~
復元-:restore:~
暗黙の:implied:~
暗黙:implicit:~
依存-:depend:~
導入-:introduce:~
定めら:state さ:~
実装-:implement:~
実装:implementation:~
影響-:affect:~
改善-:improve:~
改善:improvements:~
文書化-:document:~
関係-:relate:~
削除-:delete:~
許容-:allow:~
理解-:understand:~
指示-:indicate:~
意味:meaning:~
意味-:mean:~
決定-:determine:~
決定:determination:~
適用-:apply:~
主要な:substantive な:~
取扱う:handle する:取り扱う
取扱い:handling:取り扱い
取扱われ:handle され:取り扱われ
修正-:fix:~
挙動:behavior:ふるまい
挙動する:behave する:ふるまう
変更点:changes:~
変更:change:~
定義-:define:~
定義:definition:~
明確化-:clarify:~
明確化:clarifications:~
	追加-:add
	追加:addition
	追加の:additional:
更新:update:~
強制-:force:~
解く:solve する:~
正しい:correct な:~
正した:correct した:~
保つ:keep する:~
	hacky 
復帰-:revert:~
指定-:specify:~
指定:specified:~
精確:precise:~
拡張:extension:~
拡張-:extend:~

	●
algo:algorithm::アルゴリズム
bugfixes::bug 修正:バグ修正
comment:::コメント
module:::モジュール
tool:::ツール
~~転化する:transmute
~~転化する:transmute
一貫する:consistent になる:~
不必要:unnecessary:~
不用意:accidental:~
不良:bad:~
事例:case:~
仕方:way:~
仕様:spec:~
代替の:alternative:~
位置付け:status:~
作者:author:~
共通して:common に:~
判定基準:criteria:~
勧告候補:Candidate Recommendation:~
単独の:single:~
各種用語:terminology:~
問題:problem:~
容易:easy:~
将来:future:~
提案:proposal:~
改称-:rename:~
整合する:consistent になる:~
明示的:explicit:~
最終草案:Last Call Working Draft:~
有意な:significant:~
混同:confusion:~
特別:special:~
発行:publication:~
目的:purpose:~
直接的:direct:~
経験則:heuristic:~
編集上の:editorial:~
自明:trivial:~
草案:draft:~
著作:authoring:~
要件:requirement:~
規範的:normative:~
誤り:error:~
適合性:conformance:~
重要:important:~
集積:disposition::~

	~~優先
	~~訂正
	上述: 1
	下回
	不備:omission:~
	以前: 4
	依然として，:still
	先立: 1
	十分: 1
	参照: 2
	同様:like
	場合: 2
	大部分: 2
	対応: 2
	当該節: 1
	打ち消し:negation
	整合性をとる:for consistency
	日付: 9
	旧内容: 1
	最早:no longer 
	注記:note:~
	用意: 6
	相互参照: 1
	結果: 3
	自身: 1
	補完:box fixup
	解消:
	解消:fixing
	詳細: 2
	誤解:confusing
	通常: 1
	過去: 2

	●CSS
animation:::アニメーション
keyword:::キーワード
	下位~prop:longhand
prop:property::プロパティ
略式:shorthand:~
table:::
text:::テキスト
子:child:~
略式:shorthand:~
呈示-:present:~
呈示:presentation:~
強制分断:forced-break::~
初期値:initial value:~
指定値:specified value:~
空白:white-space:~
疑似要素:pseudo-element:~

改変文書順:order-modified document order:~
文書順:document order:~


	●layout
box:::ボックス
col:column
row:
flex::::フレックス
flexible:
flow:::フロー
fraction:::
line:::ライン
margin:::マージン
padding:::パディング
border:::ボーダー
min:min-:最小-
max:max-:最大-
size:::サイズ
sizing:::サイズ法
layout:::レイアウト
軸:axis:~
直交:orthogonal:~
合成-:synthesize::~
主:main::主:メイン
主size:main-size::主サイズ:メインサイズ
主軸:main-axis:main 軸:主軸:メイン軸
交叉:cross::交叉:クロス
交叉size:cross-size::交叉サイズ:クロスサイズ
交叉軸:cross-axis:cross 軸:~:クロス軸

自動的:automatic:~
自動:auto:~
内在的:intrinsic:~
整列-:align::~
整列:alignment::~
空間的:spatial:~
基底:basis::~
base:::基底
縮短:shrink::~
係数:factor:~
整形:formatting:~
整形-:format:~
文脈:context:~
分断:break::~
	-法
伸張-:stretch:~
基底線:baseline::~:ベースライン
静的:static:~
位置:position:~
確定性:definiteness:~
最小内容:min-content:~
最大内容:max-content:~
断片化:fragmentation:~
包装-:wrap::~
包装box:wrapper box:wrapper ボックス:包装ボックス
縦横比:aspect-ratio:~::アスペクト比
駒:item::アイテム
不定:indefinite:~
確定的:definite:~
絶対位置の:absolutely-positioned:絶対位置にされた
絶対位置:absolutely-positioned:~
解決-:resolve:~
	解決-法:resolving:~
解決:resolution:~
最短収納-:shrink-wrap:~
内縁:inner:~
外縁:outer:~
匿名:anonymous:~
塊:block::ブロック
浮動体:float::~:フロート
容器:container::コンテナ
次元:dimension:~
包含塊:containing block::包含ブロック
包含-:contain:~
行内:inline::~:インライン
	横幅:width:~
縦幅:height:~
行内塊:inline-block::行内ブロック:インラインブロック


zero:::ゼロ
要素:element:~
調整:adjustment:~
調整-:adjust:~
総和:sum:~
算出-:compute:~
算出:computation:~
算出値:computed value:~
計算-:calculate:~
計算:calculation:~
切詰める:clamp する:切り詰める
切詰めら:clamp さ:切り詰めら
切詰:clamped:切り詰め

内容:content:~
百分率:percentage:~::パーセント

	●未分類
	auto:::
mode:::モード
navi:navigation::ナビ
構造:structure:~
作成-:create:~
作成:creation:~
即時:immediate:~
	~~取得:retrieve
連続性:continuity:~
不連続性:discontinuity:~
合致-:match:~
長さ:length:~

値:value:~
演算-:operate:~
正規化-:normalize:~
等価:equivalent:~
成分:component:~
連続的:continuous:~
変換:conversion:~
	変換-:convert:~
終端:end:~
置換-:replace:~
集合:set:~
	以下
除去-:remove:~
順序:order:~
規則:rule:~
	~~拡張:expand:~

	処理: 1
	最小: 1
	最後の:last
	同期:in sync
	本数: 1
	最小: 1
	近付: 1
相対的:relative:~



</script>


<!--%links -->
<script type="text/plain" id="_link_map">



p.break-inside:~CSSBREAK#propdef-break-inside
p.align-content:~CSSFLEX#propdef-align-content
p.align-self:~CSSFLEX#propdef-align-self
p.display:~CSSDISP#propdef-display
p.flex-basis:~CSSFLEX#propdef-flex-basis
p.flex-basis:~CSSFLEX#propdef-flex-basis
p.flex:~CSSFLEX#propdef-flex
p.float:~CSS2VISUREN#propdef-float
p.height:~CSS2VISUDET#propdef-height
p.justify-self:~CSSFLEX#propdef-justify-self
p.min-width:~CSS2VISUDET#propdef-min-width
p.order:~CSSFLEX#propdef-order
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.width:~CSS2VISUDET#propdef-width
	v.content:~CSSFLEX#valdef-flex-basis-content




p.margin:~CSS2BOX#propdef-margin
p.margin-left:~CSS2BOX#propdef-margin-left
p.margin-top:~CSS2BOX#propdef-margin-top
	p.page-break-after:~CSS22/page.html#propdef-page-break-after
	p.page-break-before:~CSS22/page.html#propdef-page-break-before
p.max-height:~CSS2VISUDET#propdef-max-height
p.max-width:~CSS2VISUDET#propdef-max-width
p.min-height:~CSS2VISUDET#propdef-min-height
p.~min-height:~CSSFLEX#min-size-auto
p.~min-width:~CSSFLEX#min-size-auto
p.vertical-align:~CSS2VISUDET#propdef-vertical-align
	p.vertical-align:~CSSINLINE#propdef-vertical-align
p.visibility:~CSS2VISUFX#propdef-visibility
p.clear:~CSS2VISUREN#propdef-clear

	p.justify-content:~CSSALIGN#justify-content
	p.align-content:~CSSALIGN#align-content
p.break-after:~CSSBREAK#propdef-break-after
p.break-before:~CSSBREAK#propdef-break-before
p.break-*:~CSSBREAK#propdef-break-before


p.position:~CSS2VISUREN#propdef-position
p.z-index:~CSS2VISUREN#propdef-z-index
p.white-space:~CSSTEXT#propdef-white-space

p.box-sizing:~CSSUI#propdef-box-sizing
p.writing-mode:~CSSWM#propdef-writing-mode
p.direction:~CSSWM#propdef-direction
	
p.display:~CSS2VISUREN#propdef-display


pe.first-line:~CSSWG/css-pseudo-4/#selectordef-first-line
pe.first-letter:~CSSWG/css-pseudo-4/#selectordef-first-letter
~flex駒:~CSSFLEX#flex-item
~flex容器:~CSSFLEX#flex-container
~flex基底:~CSSFLEX#flex-flex-basis
~flex~base~size:~CSSFLEX#flex-base-size
~flex縮短~係数:~CSSFLEX#flex-flex-shrink-factor
	v.max-content:~SIZING#valdef-width-max-content
v.min-content:~SIZING#valdef-width-min-content
v.visible:~CSSOVERFLOW3#valdef-overflow-visible



確定的:~CSSFLEX#definite
不定:~CSSFLEX#definite
主軸:~CSSFLEX#main-axis
主size:~CSSFLEX#main-size
主size~prop:~CSSFLEX#main-size-property
交叉軸:~CSSFLEX#cross-axis
交叉size~prop:~CSSFLEX#cross-size-property
交叉size:~CSSFLEX#cross-size
仮の主size:~CSSFLEX#hypothetical-main-size
伸張-:~CSSFLEX#stretched

~flex~line:~CSSFLEX#flex-line
単line:~CSSFLEX#single-line-flex-container
複line:~CSSFLEX#multi-line-flex-container

自動的~最小~size:~CSSFLEX#automatic-minimum-size
改変文書順:~CSSFLEX#order-modified-document-order
~flexible長さ:~CSSFLEX#flexible-length
~flexible長さの解決-法:~CSSFLEX#resolve-flexible-lengths
指定~size:~CSSFLEX#specified-size
主sizeの決定:~CSSFLEX#main-sizing
内容~size:~CSSFLEX#content-size
~flexible:~CSSFLEX#flexible


交叉軸 基底線~集合:~CSSFLEX#cross-axis-baseline
主軸 基底線~集合:~CSSFLEX#main-axis-baseline

整列~基底線:~CSSALIGN#alignment-baseline
静的~位置:~CSS2VISUDET#static-position
内在的~sizing:~SIZING#intrinsic-sizing
最小内容 拘束:~SIZING#min-content-constraint
最大内容 拘束:~SIZING#max-content-constraint
基底線を合成-:~CSSALIGN#synthesize-baselines
合成-:~CSSALIGN#synthesize-baselines

基底線~集合:~CSSALIGN#baseline-export
塊~容器:~CSSDISP#block-container
塊~化:~CSSDISP#blockify
浮動体:~CSS2VISUREN#floats
絶対位置の:~CSS2VISUREN#absolutely-positioned

</script>

</head>
<body >

<aside class="trans-meta">
<h1>CSS Flexible Box Layout Module Level 1 （変更点）</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a id="_SPEC_URL">CSS Flexible Box Layout Module Level 1</a>
の変更点の節を日本語に翻訳したものです。
他の詳細は、
<a href="css-flexbox-ja.html">その仕様の日本語訳</a>
に準じるとします。
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

</aside>


<div id="MAIN" style="display:none;">

	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
この節では、以前までの発行からの変更点を文書化する。
◎
This section documents the changes since previous publications.
</p>

<p class="trans-note">【
この訳では、原文の修正箇所の引用は省略する（最近のものは，この訳の当該箇所へのリンク “《変更箇所》” に置換している）。
詳細は原文をあたられたし。
】</p>

	</section>

<main id="MAIN0">

		<section id="changes-20160526">
<h3 title="Changes since the 26 May 2016 CR">2016 年 5 月 26 日付 勧告候補からの変更点</h3>

<p>
<a href="~WGFLEX/issues-cr-20160526/issues-cr-20160526">~commentの集積</a>
も用意されている。
◎
A Disposition of Comments is also available.
</p>

			<section id="change-201605-substantive">
<h4 title="Substantive Changes and Bugfixes">主要な変更点と~bugfixes</h4>

<ul>
	<li id="change-2016-align-self-as-specified">
実装を容易にするため、 `align-self$p に対する `auto^v 値は，常にそれ自身に算出されることに。
この算出は、
<a href="#change-2015-align-self-auto">関係する以前の変更</a>
により，絶対位置の要素のために要する。
(<a href="https://github.com/w3c/csswg-drafts/issues/440">Issue 440</a>)
◎
For ease of implementation, auto value of align-self now computes to itself always. See related previous change requiring this computation for absolutely-positioned elements. (Issue 440)
</li>
	<li id="change-2016-baseline-alignment">
`~flex駒$が［
直交~flowにある ／ 基底線を持たない
］場合に、その`整列~基底線$は，駒の~border~boxから`合成-$するように変更した。
◎
Change flex items in orthogonal flows and flex items without a baseline to both synthesize their alignment baseline from the flex item’s border box.
</li>
	<li id="change-2016-main-cross-baseline">
`交叉軸 基底線~集合$の定義における`主軸$と`交叉軸$の誤りを修正した。
(<a href="https://github.com/w3c/csswg-drafts/issues/792">Issue 792</a>)
◎
Fix main/cross error in definition of cross-axis baseline set. (Issue 792)
</li>
	<li id="change-2016-table-wrapper">
不用意に削除した~flex駒としての~tableについての~textを復元した。
<a href="#change-2015-anonymous-fixup">匿名~boxの変更点</a>
を見よ。
(<a href="https://github.com/w3c/csswg-drafts/issues/547">Issue 547</a>)
《`cg-change-2016-table-wrapper$cg》
◎
Restore accidentally-deleted text about tables as flex items. See anonymous box change. (Issue 547)
</li>
	<li id="change-2016-auto-margin-abspos">
自動~marginは、絶対位置の~flex容器である子の`静的~位置$を計算する目的においては
~zeroに扱われることを明確化した。
(<a href="https://github.com/w3c/csswg-drafts/issues/665">Issue 665</a>)
《`cg-change-2016-auto-margin-abspos$cg（追加）》
◎
Clarified that auto margins are treated as zero for the purpose of calculating a absolutely-positioned flex container child’s static position. (Issue 665)
</li>
	<li>
<a href="~CSSFLEX#intrinsic-main-sizes">~flex容器の内在的~主sizeの計算</a>
にて ~max`主size~prop$以下に切詰めるときの結果が、~min`主size~prop$を下回らないように~~訂正。
◎
When clamping by the max main size property in the calculation of the flex container’s intrinsic size, be sure to floor by the min main size property.
</li>
</ul>

			</section>
			<section id="change-201605-clarify">
<h4 title=" Clarifications">明確化</h4>

<ul>
	<li>
`~flex駒$にしか定義していなかった
`主size$, `交叉size$
を，`~flex容器$にも定義されるようにした。
(<a href="https://github.com/w3c/csswg-drafts/issues/981">Issue 981</a>)
◎
Made sure that main size and cross size are defined for flex containers as well as for flex items. (Issue 981)
</li>
</ul>

			</section>
		</section>
		<section id="changes-20160301">
<h3 title="Changes since the 1 March 2016 CR">2016 年 3 月 1 日付 勧告候補からの変更点</h3>

<p>
<a href="~WGFLEX/issues-cr-20160301">~commentの集積</a>
も用意されている。
◎
A Disposition of Comments is also available.
</p>

			<section id="change-201603-substantive">
<h4 title="Substantive Changes and Bugfixes">主要な変更点と~bugfixes</h4>

<ul>
	<li id="change-2016-intrinsic-percentage">
内在的`自動的~最小~size$を計算するときの百分率の取扱いを定義した。
（ `cr-20160301#issue-3$iS ）
《`cg-2016-intrinsic-percentage-1$cg, `cg-2016-intrinsic-percentage-2$cg（追加）》
◎
Define how percentages are handled when calculating intrinsic automatic minimum sizes. (Issue 3)
</li>
	<li id="change-2016-definite-indefinite">
［
`確定的$, `不定$
］の定義を，この~module内に直に記す代わりに
`CSS3-SIZING$r による（より正しい）定義を指すようにした。
（ `cr-20160301#issue-10$iS ）
《`cg-2016-definite-indefinite$cg（更新）》
◎
Switched definite and indefinite to refer to the (more correct) definitions in [CSS3-SIZING] instead of defining them inline in this module. (Issue 10)
</li>
	<li id="change-2016-abspos-no-order">
~flex~boxにおける絶対位置の子は、もはや
`order$p ~propから影響されなくなった。
（ `cr-20160301#issue-12$iS ）
《`cg-2016-abspos-no-order$cg（更新）》
◎
Abspos children of a flexbox no longer respond to the order property. (Issue 12)
</li>
	<li id="change-2016-baseline-sets">
<a href="~CSSFLEX#flex-baselines">~flex容器の基底線</a>
節を，`基底線~集合$と
<a href="~CSSALIGN#last-baseline-alignment">最後の基底線による整列</a>
も織り込むように更新した。
（ `cr-20160301#issue-13$iS）
◎
Updated §8.5 Flex Container Baselines to account for baseline sets and last-baseline alignment. (Issue 13)) 
</li>
</ul>



			</section>
			<section id="change-201604-clarify">
<h4 title=" Clarifications">明確化</h4>

<ul>

	<li id="change-2016-spatial-nav">
空間的~navi~modeにおいて `order$p を取扱うことが許容されることを明確化した
（ `cr-20160301#issue-1$iS ）
《`cg-2016-spatial-nav$cg（追加）》
◎
Clarify that spatial navigation modes are allowed to handle order. (Issue 1)
</li>
	<li id="change-2016-definite-3">
<a href="~CSSFLEX#definite-sizes">確定的~size／不定~size</a>
節における確定性についての追加の事例に対する相互参照を~~追加。
（ `cr-20160301#issue-2$iS ）
《`cg-2016-definite-3$cg（追加）》
◎
Cross-reference an additional case of definiteness in §9.8 Definite and Indefinite Sizes (Issue 2)
</li>
	<li id="change-2016-auto-content-wording">
百分率による解決できない`~flex基底$値が，
`content$v:fb に~~転化されることについての言い回しを改善した。
（ `cr-20160301#issue-6$iS ）
◎
Improve wording for how unresolveable percentage flex basis values transmute to content. (Issue 6)
《`cg-2016-auto-content-wording$cg（更新）》
</li>
	<li id="change-2016-inflexible-definite">
`~flex基底$が`確定的$である非~flexible駒の~sizeは`確定的$になることを明確化した。
（ `cr-20160301#issue-8$iS,
`cr-20160301#issue-11$iS ）
《`cg-2016-inflexible-definite-1$cg, `cg-2016-inflexible-definite-2$cg（追加）》
◎
Clarify that inflexible items with a definite flex basis have a definite size. (Issue 8, Issue 11)
</li>
	<li id="change-2016-reword-min-auto">
`auto$v:min 値の定義をより理解しやすい定義に言い換えた。
（ `cr-20160301#issue-9$iS ）
《`cg-2016-reword-min-auto$cg（更新）》
◎
Reworded definition of the auto value to be easier to understand. (Issue 9)
</li>
	<li>
その他の自明な編集上の改善。
◎
Miscellaneous trivial editorial improvements.
</li>
</ul>


			</section>
		</section>
		<section id="changes-201505">
<h3 title="Changes since the 14 May 2015 LCWD">2015 年 5 月 14 日付 最終草案からの変更点</h3>


<p>
<a href="~WGFLEX/issues-lc-20150514">~commentの集積</a>
も用意されている。
◎
A Disposition of Comments is also available.
</p>

			<section id="change-201505-substantive">
<h4 title="Substantive Changes and Bugfixes">主要な変更点と~bugfixes</h4>

<ul>
	<li id="change-2015-flex-basis-zero">
`flex$p 略式~propに対する，［
`flex-basis$p 省略-時における
<a href="#change-2012-flex-basis-zero">変更</a>
］は、~~元の `0^v に戻された
— それは、内在的~sizeの問題を解くにあたって hacky な仕方であり、
<a href="~CSSFLEX#intrinsic-sizes">内在的~size 節</a>
の正しい実装の下では，不必要であった（また 不良な結果を与えてもいた）ので。
（ `lc-20150514#issue-13$iS ）
《`cg-flex-basis-zero-1$cg, `cg-flex-basis-zero-2$cg（更新）》
◎
Revert flex shorthand change of omitted flex-basis back to 0, since that was a hacky way of solving an intrinsic size problem, and isn’t needed (and gives bad results) given a correct implementation of §9.9 Intrinsic Sizes. (Issue 13)
</li>
	<li id="change-2015-anonymous-fixup">
`~flex駒$を決定する際は、各~要素ごとに直接的に演算するように変更した
— その匿名~包装boxではなく。 
（ `lc-20150514#issue-6$iS ）
《`cg-anonymous-fixup-1$cg, `cg-anonymous-fixup-2$cg（更新）》
◎
Changed flex item determination to operate on each element directly, and not on its anonymous wrapper box, if any. (Issue 6)
</li>
	<li id="change-2015-min-auto-intrinsic-percentages">
~boxの内容に対する百分率による~sizingは、［
~box上の `~min-width$p:auto により課される~size調整
］も織り込むものと定義した。
（ `lc-20150514#issue-3$iS ）
《`cg-min-auto-intrinsic-percentages$cg（更新）》
◎
Defined that any size adjustment imposed by a box’s min-width: auto is consulted when percentage-sizing any of its contents. (Issue 3)
</li>
	<li id="change-2015-intrinsic-sizing">
~flexibleでない駒を取扱うための`内在的~sizing$の規則を正した。
（ `lc-20150514#issue-1$iS ）
《`cg-intrinsic-sizing$cg（更新）》
◎
Correct instrinsic sizing rules to handle inflexible items. (Issue 1).
</li>
    <li id="change-2015-intrinsic-items">
~flex容器の主軸~沿いの`内在的~sizing$における誤りを正した。
（ `lc-20150514#issue-1$iS ）
《`cg-intrinsic-items-1$cg, `cg-intrinsic-items-2$cg（更新）》
◎
Correct errors in flex container main-axis intrinsic sizing. (Issue 1)
</li>
	<li id="change-2015-intrinsic-cross-container">
`~flex容器$の交叉軸~沿いの`内在的~sizing$における誤りを正した。
加えて、複line ~col~flex容器に対し 共通して実装されている 最小内容~sizingの経験則を指定した。
（ `lc-20150514#issue-12$iS ）
《`cg-intrinsic-cross-container$cg（更新）》
◎
Correct errors in flex container cross-axis intrinsic sizing, and specify commonly-implemented min-content sizing heuristic for multi-line column flex containers. (Issue 12)
</li>
	<li id="change-2015-a11y-tools">
著作~toolに対する明示的な適合性の判定基準
— 作者から明示的に指示されない限り，呈示と DOM 順序との同期を保つとする —
を追加した。
（ `lc-20150514#issue-8$iS ）
《`cg-a11y-tools-1$cg, `cg-a11y-tools-2$cg（更新）》
◎
Add explicit conformance criteria on authoring tools to keep presentation and DOM order in sync unless author explicitly indicates a desire to make them out-of-sync. (Issue 8)
</li>
	<li id="change-2015-align-self-auto">
`align-self$p ／ `justify-self$p
に対する値 `auto^v は、
`CSS-ALIGN-3$r によるこれらの~propの将来の拡張との整合性をとるため，
絶対位置の要素に対しては，そのままの値に算出されるものと定義した。
（ `lc-20150514#issue-5$iS ）
<!-- 
《cg-align-self-auto$cg（更新）》
 -->
◎
Defined that an align-self or justify-self value of auto computes to itself on absolutely-positioned elements, for consistency with future extensions of these properties in [CSS-ALIGN-3]. (Issue 5)
</li>
	<li id="change-2015-percentage-margins">
百分率による
~margin／~padding
は、~~元の，個々の軸に相対的とするよう戻した。
《`cg-percentage-margins$cg（更新）》
◎
Revert change to make percentage margins and padding relative to their own axes; instead allow both behaviors. (Issue 11, Issue 16)
</li>
    <li id="change-2015-min-max-constraint">
~flex駒の~sizingにおける［
`最小内容 拘束$／`最大内容 拘束$
］の取扱いを追加した。
《`cg-min-max-constraint$cg（追加）》
◎
Handle min/max constraints in sizing flex items.
</li>
    <li id="changes-2015-first-fragment">
~flex容器における断片化 規則の打ち消しを正した。
以前の定義では、どの事例でも
`break-inside$p に対しては暗黙に `avoid^v の挙動とされていた。
（`lc-20150514#issue-5$iS）
《`cg-first-fragment$cg（更新）》
◎
Correct negation in flex container fragmentation rule: previous definition implied break-inside: avoid behavior in all cases. (Issue 5)
</li>
</ul>

			</section>
			<section id="change-201505-clarify">
<h4 title="Clarifications">明確化</h4>
<ul>
	<li>
小さな編集上の改善と例の中の誤りを修正した。
◎
Miscellaneous minor editorial improvements and fixes to errors in examples. 
</ul>

			</section>
		</section>
		<section id="changes-201409">
<h3 title="Changes since the 25 September 2014 LCWD">2014 年 9 月 25 日付 最終草案からの変更点</h3>


<p>
<a href="~WGFLEX/issues-lc-20140925">~commentの集積</a>
も用意されている。
◎
A Disposition of Comments is also available.
</p>

			<section id="change-201409-substantive">
<h4 title="Substantive Changes and Bugfixes">主要な変更点と~bugfixes</h4>



<ul>
	<li id="change-201409-content">
`flex-basis$p:auto を，その元々の意味に戻した上で、内容に基づく自動的~sizingを明示的に指定する，
`flex-basis^p:content ~keywordを追加した。
（`lc-20140925#issue-10$iS）
◎
Reverted flex-basis: auto to its original meaning. Added flex-basis: content keyword to explicitly specify automatic content-based sizing. (Issue 10)
</li>
	<li id="change-201409-align-content-wrapping">
`align-content$p が適用し得るかどうかを、結果の`~flex~line$の本数ではなく，包装し得るかどうかに依存するようにした。
（`lc-20140925#issue-4$iS）
<!-- 
the cross size of each line is the minimum size necessary…
Note, this property has no effect on a single-line flex container.…
Only multi-line flex containers…
If the flex container is single-line and has a definite cross size…
If the flex container is single-line, then clamp…
-->
◎
Made applicability of align-content depend on wrappability rather than number of resulting flex lines. (Issue 4)
<!-- 
	When a flex container has multiple lines, In a multi-line flex container (even one with only a single line), the cross size of each line is the minimum size necessary [...] When a flex container (even a multi-line one) has only one line, In a single-line flex container, the cross size of the line is the cross size of the flex container, and align-content has no effect.

	Note, this property has no effect when the flex container has only a single line. on a single-line flex container.

	Only flex containers with multiple lines multi-line flex containers ever have free space in the cross-axis for lines to be aligned in, because in a flex container with a single line single-line flex container the sole line automatically stretches to fill the space.

	If the flex container has only one flex line (even if it’s a multi-line flex container) is single-line and has a definite cross size, the cross size of the flex line is the flex container’s inner cross size.

	If the flex container has only one flex line (even if it’s a multi-line flex container), is single-line, then clamp the line’s cross-size to be within the container’s computed min and max cross-size properties.
-->
</li>


	<li id="change-201409-algo-breaks">
仕様の競合を解決するため、強制分断の挙動について言明していた~textを除去して，断片化の節への参照に置換した。
（`lc-20140925#issue-18$iS）
◎
Removed text that asserted forced breaking behavior, replaced with reference to fragmentation section. This resolves a conflict in the spec. (Issue 18)
<!-- 
	collect consecutive items one by one until the first time that the next collected item would not fit into the flex container’s inner main size, ( or until a forced break is encountered , see §10 Fragmenting Flex Layout) . [...] A break is forced wherever the CSS2.1 page-break-before/page-break-after [CSS21] or the CSS3 break-before/break-after [CSS3-BREAK] properties specify a fragmentation break.
 -->
</li>
	<li id="change-201409-inner-base-size">
`~flex縮短~係数$は，（外縁でなく）<em>内縁</em>の`~flex~base~size$との積をとるように変更した。
（`lc-20140925#issue-9$iS）
◎
Change the flex shrink factor to multiply by the inner (not outer) flex base size. (Issue 9)
<!-- 
	For every unfrozen item on the line, multiply its flex shrink factor by its outer inner flex base size, and note this as its scaled flex shrink factor.
 -->
</li>

	<li id="change-201409-neither">
誤記修正。
（`lc-20140925#issue-6$iS）
◎
Add back in missing “n” in “neither”... (Issue 6)
<!-- 
	If the cross size property of the flex item computes to auto, and n either of the cross-axis margins are auto, the flex item is stretched.
 -->
</li>
	<li id="change-201409-flexed-definite-container">
~flex駒の~flexされた主sizeが`確定的$になるためには、
`~flex容器$の`主size$も`確定的$で~MUSTことを指定した。
（`lc-20140925#issue-20$iS）
◎
Specify that the flex container’s main size must also be definite for a flex item’s flexed main size to be definite. (Issue 20)
<!-- 
	[If] ... the flex item has a definite flex basis, and the flex container has a definite main size, the flex item’s main size must be treated as definite ...
 -->
</li>

	<li id="change-201409-min-auto-specified-size">
`指定~size$が定義されるための要件から，［
`~flex基底$ が `content$v:fb にされていること
］を除去した（指定~sizeは、内在的~sizeより小さいときは常に，それより~~優先されるべきである。
これは特に、作者の期待に違わないようにするときに重要になる
— 例えば：
<samp>&lt;img src="…" width=40 height=40 title="100x100 image"&gt;</samp>
）
（`lc-20140925#issue-25$iS）
◎
Remove the requirement that the flex basis be content for the specified size to be defined. The specified size should always win if it is smaller than the intrinsic size. This is particularly important to maintain author expectations for, e.g. &lt;img src="…" width=40 height=40 title="100x100 image"&gt;.
<!-- 
	If the item’s computed flex-basis is content and its computed main size property is definite, then the specified size is that size 
 -->
</li>
	<li>
~flex駒が`塊~化$される前に匿名~塊の作成が生じる要件を除去した（ `display^p:table-cell の様なものなど）。
（それに代わって、すべての子は，今や即時に`塊~化$される
— `絶対位置の$~box／`浮動体$の挙動と一貫するように。）
◎
Remove the requirement that anonymous block creation (for things like display: table-cell) occur before flex item blockification. (Instead, all children now blockify immediately, consistent with abspos/float behavior.)
</li>
</ul>

			</section>
			<section id="change-201409-clarify">
<h4 title="Clarifications">明確化</h4>

<ul>

	<li id="change-201409-unclamped-size">
`~flex~base~size$は切詰められないことを明確化した。
（`lc-20140925#issue-21$iS）
◎
Clarify that flex base size is unclamped. (Issue 21)
<!-- 
	When determining the flex base size, the item’s min and max main size properties are ignored (no clamping occurs).

	The hypothetical main size is the item’s flex base size clamped according to its min and max main size properties.
 -->
</li>
	<li id="change-201409-table-wrappers">
~table包装boxについての注記の位置付けを，規範的に戻した
— 以前の草案で不用意に変更されていたので。
（<a href="~WGFLEX/issues-lc-20140925#issue-2">Issue  2</a>）
◎
Restored normative status of note about table wrapper boxes normative; it had been accidentally changed in the previous draft. (Issue 2)
</li>
	<li id="change-201409-display-longhands">
`display$p の各種 下位~propへの参照を除去した。
それらは、 CSS Display Level 3 から除去されることになるので。
◎
Removed references to display property longhands, since they will be removed from CSS Display Level 3.
</li>
	<li id="change-201409-layout-vs-size">
不必要な再~layoutを課さないように言い回しを変更した。
（`lc-20140925#issue-22$iS）
◎
Change wording to not imply an unnecessary layout pass. (Issue 22)
<!-- 
	Otherwise, lay out size the item into the available space using its used flex basis in place of its main size, treating a value of content as max-content. 
 -->
</li>
	<li id="change-201409-clamped-specified">
`height^p:auto の定義における
“切詰~size” を “指定~size” に改称した。
◎
Renamed “clamped size” to “specified size” in the definition of height: auto.
</li>
	<li>
種々の自明な~~修正。
◎
Various trivial fixes.
</li>
</ul>

			</section>
		</section>
		<section id="changes-201403">
<h3 title="Changes since the 25 March 2014 LCWD">2014 年 3 月 25 日付 最終草案からの変更点</h3>

<p>
<a href="~WGFLEX/issues-lc-140325">~commentの集積</a>
も用意されている。
◎
A Disposition of Comments is also available.
</p>


			<section id="changes-201403-substantive">
<h4 title="Substantive Changes and Bugfixes">主要な変更点と~bugfixes</h4>

<p>
<a href="~TR/2014/WD-css-flexbox-1-201403/">2014 年 3 月 25 日付 最終草案</a>
から，以下の有意な変更が加えられた：
◎
The following significant changes were made since the 25 March 2014 Last Call Working Draft
</p>


<ul>
	<li id="change-201403-min-auto-not">
（`lc-140325#issue-11$iS,
`lc-140325#issue-13$iS,
`lc-140325#issue-18$iS）
◎
Fixed errors (missing negation, unspecified axis) in definition of min-width: auto. (Issues 11, 18, 30)
</li>

<!-- 
	On a flex item whose overflow is not visible in the main axis ,
 -->
	<li id="change-201403-min-auto-ratio">
内在的~縦横比を有する駒を特別に取扱うために、
`~min-width$p:auto の定義は~~拡張され，書き直された。
（`lc-140325#issue-16$iS, `lc-140325#issue-28$iS ）
◎
Expanded and rewrote definition of min-width: auto to add special handling of items with intrinsic ratios. (Issues 16 and 28)
</li>

<!-- 
	On a flex item whose overflow is not visible, the following table gives the minimum size: [see table]
	this keyword specifies as the minimum size the smaller of:
		the min-content size, or
		the computed width/height, if that value is definite. 
 -->

	<li id="change-201403-min-auto-main-size-basis">
`~min-width$p:auto を調整した
—
~flex基底が`主size~prop$から~~取得されたときの，主sizeの算出値にのみ適用されるように。
（`lc-140325#issue-19$iS）
◎
Adjusted min-width: auto to only apply the computed main size as a minimum in cases where the flex basis was retrieved from the main size property. (Issue 19)
</li>


<!-- 
	… is defined if the item’s computed flex-basis is auto and its computed main size property is definite …
 -->

	<li id="change-201403-min-auto-intrinsic-percentages">
~boxの `~min-width$p:auto により課される~size調整は、~boxの内容に対する百分率による~sizingには，織り込まれないものと定義した。
（`lc-140325#issue-27$iS ）
この変更は、
<a href="#change-2015-min-auto-intrinsic-percentages">逆の定義に戻された</a>
。
◎
Defined that any size adjustment imposed by a box’s min-width: auto is not consulted when percentage-sizing any of its contents. (Issue 27) This change was later reverted with an opposite definition.
</li>

<!-- 
	In order to prevent cycling sizing, the auto value of min-height and max-height does not factor into the percentage size resolution of the box’s contents. For example, a percentage-height block whose flex item parent has height: 120em; min-height: auto will size itself against height: 120em regardless of the impact that min-height might have on the used size of the flex item.
 -->

	<li id="change-201403-flex-basis-auto">
新たな~keyword `main-size^v を導入した
（`lc-140325#issue-20$iS ）。
この変更は、後に戻された
—
代わりに `content$v:fb ~keywordを導入して同じ問題を解消する，代替の提案により。
◎
Introduced extra main-size keyword to flex-basis so that “lookup from main-size property” and “automatic sizing” behaviors could each be explicitly specified. (Issue 20) This change was later reverted with an alternative proposal solving the same problem by instead introducing the content keyword.
</li>

	<li id="change-201403-definite-flexing">
~flex基底が確定的な~flex駒は主軸でも確定的になるよう定義して、駒~自身は~flexibleである場合でも百分率で~sizeされた子を解決できるようにした。
（`lc-140325#issue-26$iS）
◎
Defined flex items with a definite flex basis to also be definite in the main axis, allowing resolution of percentage-sized children even when the item itself is flexible. (Issue 26)
</li>

<!-- 
	If a percentage is going to be resolved against a flex item’s main size, and the flex item has a definite flex basis, the main size must be treated as definite for the purpose of resolving the percentage, and the percentage must resolve against the flexed main size of the flex item (that is, after the layout algorithm below has been completed for the flex item’s flex container, and the flex item has acquired its final size).
 -->
	<li id="change-201403-clamp-single-line">
（`lc-140325#issue-9$iS）
◎
Clamp a single line flexbox’s line cross size to the container’s own min/max, even when the container’s size is indefinite. (Issue 9)
</li>

<!-- 
		The used cross-size of the flex line is the largest of the numbers found in the previous two steps and zero.

		If the flex container has only one flex line (even if it’s a multi-line flex container), then clamp the line’s cross-size to be within the container’s computed min and max cross-size properties. Note that if CSS 2.1’s definition of min/max-width/height applied more generally, this behavior would fall out automatically.
 -->

	<li id="change-201403-resolve-flex">
新たな`~flexible長さの解決-法$ 節における種々のエラーの修正（
`flex^p:0 から `flex^p:1 への連続性のための， 2014 年 3 月の書き直しを見よ）。
過去の勧告候補に合致させるため，編集上の構造を復帰させた。
（`lc-140325#issue-3$iS,
`lc-140325#issue-4$iS,
`lc-140325#issue-8$iS,
`lc-140325#issue-10$iS,
`lc-140325#issue-15$iS）
◎
Fixed various errors in the new Resolving Flexible Lengths section (see March 2014 rewrite to create continuity between flex: 0 and flex: 1) and reverted the editorial structure to match the old Candidate Recommendation. (Issues 3, 4, 8, 10, 15)
</li>

	<li id="change-201403-max-intrinsic">
単に~flex駒の max-content ~sizeの総和をとるのではなく，~flex~fractionごとに正規化することにより、
<a href="~CSSFLEX#intrinsic-sizes">~flex容器の最大内容~sizing</a>
が，~flex処理の挙動を織り込むように修正
（`lc-140325#issue-39$iS）
◎
Fixed max-content sizing of flex containers to account for flexing behavior by normalizing per flex fraction rather than merely summing the max-content sizes of the flex items. (Issue 39)
</li>

	<li id="change-201403-flex-animation">
`flex$p ~propが，~animationを常に受容するように更新。
0 と非 0 値の間の不連続性は、今や
<a href="#change-2012-flex-continuity">解消された</a>。
（`lc-140325#issue-5$iS）
◎
Updated flex property to accept animations always, now that the discontinuity between 0 and non-0 values has been fixed. (Issue 5)
</li>

</ul>
 

			</section>
			<section id="changes-201403-clarify">
<h4 title="Clarifications">明確化</h4>

<p>
<a href="~TR/2014/WD-css-flexbox-1-201403/">2014 年 3 月 25 日付 最終草案</a>
から，以下の有意な変更が加えられた：
◎
The following significant changes were made since the 25 March 2014 Last Call Working Draft
</p>

<ul>
	<li id="change-201403-css21-staticpos">
<p>
（`lc-140325#issue-12$iS）
◎
Clarified how the static position of an absolutely-positioned child of a flex container is calculated by introducing an explanation of the effect more closely tied with CSS2.1 concepts and terminology. (Issue 12)
</li>


<!-- 
	Its The static position of an absolutely-positioned child of a flex container is calculated by first doing full flex layout without the absolutely-positioned children, then positioning each absolutely-positioned child determined such that the child is positioned as if it were the sole flex item in the flex container, assuming both the child and the flex container were fixed-size boxes of their used size.

	In other words, the static position of an absolutely positioned child of a flex container is determined after flex layout by setting the child’s static-position rectangle to the flex container’s content box, then aligning the absolutely positioned child within this rectangle according to the justify-content value of the flex container and the align-self value of the child itself.
 -->

	<li id="change-201403-abspos-ordering">
~flex容器~内で絶対位置の子に対する
`order^p の適用を明確化した。
◎
Clarified application of order to absolutely-positioned children of the flex container: 
</li>


<!-- 
	An absolutely-positioned child of a flex container does not participate in flex layout beyond the reordering step . However, it does participate in the reordering step (see order), which has an effect in their painting order.

	The order property controls the order in which flex items children of a flex container appear within their flex container…

	Unless otherwise specified by a future specification, this property has no effect on boxes that are not flex items children of a flex container .

	Note: Absolutely-positioned children of a flex container do not participate in flex layout, but are reordered together with any flex item children.
 -->



	<li id="change-201403-clarify-stretched">
（確定性のような）特別な挙動の目的のために、
`伸張-$された~flex駒が何であるかを明確化した。
（`lc-140325#issue-25$iS）
◎
Clarified what a stretched flex item is for the purposes of special behavior (like definiteness). (Issue 25)
</li>
<!-- 
	If the cross size property of the flex item computes to auto, and either of the cross-axis margins are auto, the flex item is stretched. Its its used value …

 -->
</ul>


			</section>
		</section>
		<section id="changes-2012">
<h3 title="Changes since the 18 September 2012 Candidate Recommendation">2012 年 9 月 18 日付 勧告候補からの変更点</h3>

<p>
<a href="~WGFLEX/issues-cr-2012">~commentの集積</a>
も用意されている。
◎
A Disposition of Comments is also available.
</p>

			<section id="changes-2014-substantive">
<h4 title="Substantive Changes and Bugfixes">主要な変更点と~bugfixes</h4>

<p>
<a href="~TR/2012/CR-css3-flexbox-20120918/">2012 年 9 月 18 日付 勧告候補</a>
から，以下の有意な変更が加えられた：
◎
The following significant changes were made since the 18 September 2012 Candidate Recommendation:
</p>


<ul>
	<li id="change-2012-min-width">
<p>
`~min-width$p ／ `~min-height$p
に対する新たな初期値 `auto$v:min の挙動を変更した。
◎
Changed the behavior of the new auto initial value of min-width/min-height to
</p>

		<ul>
			<li>
`overflow$p が `visible$v かどうかも織り込まれた。
`overflow$p が明示的に取扱われるときに、（不必要に）内容すべてを示すに十分な~sizeを強制するものと誤解されないように。
◎
Take into account whether overflow is visible, since when overflow is explicitly handled, it is confusing (and unnecessary) to force enough size to show all the content.
</li>

			<li>
暗黙の最小~sizeが，指定された~sizeより決して大きくならないように、
`width$p ／ `height$p
の指定値も織り込まれた。
◎
Take into account the specified width/height, so that the implied minimum is never greater than the specified size.
</li>

			<li>
~flex駒~上では、（ `min-content$v に，ではなく）初期値~自身に算出される
— それらは最早（上述の変更により）等価でないので。
◎
Compute to itself (not to min-content) on flex items, since they are no longer equivalent (due to above changes).
</li>
		</ul>

<p>
（`cr-2012#issue-19$iS）
◎
(Issue 19)
</p>
	</li>
<!-- 
	auto

		When used as the value of a flex item’s min main size property, this keyword indicates a minimum of the min-content size, to help ensure that the item is large enough to fit its contents.

		It is intended that this will compute to the min-content keyword when the specification defining it ([CSS3-SIZING]) is sufficiently mature.

		On a flex item whose overflow is not visible, this keyword specifies as the minimum size the smaller of:
			the min-content size, or
			the computed width/height, if that value is definite. 
 -->

	<li id="change-2012-percent-margins"><p>
~flex駒~上における百分率による~margin／~paddingは、それらの対応する次元に相対的に解決されることを指定した — 塊のときの様に 包含塊の行内~次元ではなく。
（`cr-2012#issue-16$iS）
【この挙動は再び~~訂正された。】
◎
Specified that percentage margins/paddings on flex items are resolved against their respective dimensions, not the inline dimension of the containing block like blocks do. (Issue 16)
</li>


<!-- 
	Percentage margins and paddings on flex items are always resolved against their respective dimensions; unlike blocks, they do not always resolve against the inline dimension of their containing block.
 -->

	<li id="change-2012-stretch-definite"><p>
単独の~lineからなる~flex容器の~sizeが確定的かどうかが、伸張された駒にも反映されるようにした。
（`cr-2012#issue-3$iS）
◎
Pass definiteness of a single-line flex container’s size through to any stretched items. (Issue 3)
</li>

<!-- 
	As a special case for handling stretched flex items, if a single-line flex container has a definite cross size, the outer cross size of any flex items with align-self: stretch is the flex container’s inner cross size (clamped to the flex item’s min and max cross size) and is considered definite.
 -->

	<li id="change-2012-stretch-auto"><p>
伸張され, 縦幅が `auto^v にされている~flex駒の内容における百分率は、再layoutにより解決されるようにされた。
（`cr-2012#issue-3$iS)
◎
Allow percentages inside a stretched auto-height flex item to resolve by requiring a relayout pass. (Issue 3)
</li>

<!-- 
	If the flex item has align-self: stretch, redo layout for its contents, treating this used size as its definite cross size so that percentage-sized children can be resolved.

	Note that this step does not affect the main size of the flex item, even if it has an intrinsic aspect ratio.
 -->

	<li id="change-2012-intrinsic-ratio"><p>
内在的~縦横比も
<a href="~CSSFLEX#algo-main-item">主sizeの計算</a>に取り込まれるようにされた。
（`cr-2012#issue-8$iS）
◎
Allow intrinsic aspect ratios to inform the main-size calculation. (Issue 8)
</li>

<!-- 
	If the flex item has ...
		an intrinsic aspect ratio,
		a flex basis of auto, and
		a definite cross size 

	then the flex base size is calculated from its inner cross size and the flex item’s intrinsic aspect ratio.
 -->

	<li id="change-2012-main-depend-cross"><p>
`主size$が`交叉size$に依存するときの`仮の主size$を定義した。
（`cr-2012#issue-23$iS）
◎
Define hypothetical main size when the main size depends on the cross size. (Issue 23)
</li>

<!-- 
	If a cross size is needed to determine the main size (e.g. when the flex item’s main size is in its block axis) and the flex item’s cross size is auto and not definite, in this calculation use fit-content as the flex item’s cross size.
 -->

	<li id="change-2012-intrinsic-sizes"><p>
<a href="~CSSFLEX#intrinsic-sizes">~flex容器の内在的~size</a>を定義した。
◎
Defined the intrinsic sizes of flex containers.
</li>

<!-- 
	Determine the main size of the flex container using its main size property. In this calculation, the min content main size of the flex container is the maximum of the flex container’s items' min-content size contributions, and the max content main size of the flex container is the sum of the flex container’s items' max-content size contributions. The min-content/max-content main size contribution of an item is its outer hypothetical main size when sized under a min-content/max-content constraint (respectively). For this computation, ‘auto’ margins on flex items are treated as ‘0’.

	The max-content main size of a flex container is the sum of the flex container’s items' max-content contributions in the main axis. The min-content main size of a single-line flex container is the sum of the flex container’s items' min-content contributions in the main axis; for a multi-line container, it is the largest of those contributions.

	The min-content cross size and max-content cross size of a flex container are the cross size of the flex container after performing layout into the given available main-axis space and infinite available cross-axis space.

	The main-size min-content/max-content contribution of a flex item is its outer hypothetical main size when sized under a min-content/max-content constraint (respectively).

	See [CSS3-SIZING] for a definition of the terms in this section.
 -->

	<li id="change-2012-flex-line-bug"><p>
`~flex~line$の~sizeの決定における不備を修正した
—
`単line$の~flex~boxの~sizeは、確定的でないときには，その内容~sizeにされるように。
◎
Correct an omission in the flex-line size determination, so a single-line flexbox will size to its contents if it doesn’t have a definite size.
</li>
<!-- 
	If the flex container has only one flex line (even if it’s a multi-line flex container) and has a definite cross size , the cross size of the flex line is the flex container’s inner cross size.
 -->

	<li id="change-2012-flex-line-floor"><p>
`~flex~line$の~sizeは，負になるときは 0 に切り上げられる。
（`cr-2012#issue-2$iS）
◎
Flex lines have their size floored at 0. (Issue 2)
</li>

<!-- 
	The used cross-size of the flex line is the larger largest of the numbers found in the previous two steps and zero .
 -->

	<li id="change-2012-atomic-painting"><p>
~flex駒は、塊ではなく，行内~塊と同様に塗られる。
（`cr-2012#issue-18$iS）
◎
Flex items paint like inline blocks rather than blocks. (Issue 18)
</li>

<!-- 
	Flex items paint exactly the same as block-level elements in the normal flow inline blocks [CSS21] .
 -->

	<li id="change-2012-flex-basis-zero"><p>
`flex$p 略式~propから省略された `flex-basis$p 成分は、今や， `0px^v の代わりに `0%^v に解決される。
不定~sizeに相対的に解決される百分率は `auto$v:min として挙動する
— その方が最短収納された~flex容器における挙動がより良くなるので。
（`cr-2012#issue-20$iS）
◎
An omitted flex-basis component of the flex shorthand now resolves to 0% instead of 0px. Because percentages resolved against indefinite sizes behave as auto, this gives better behavior in shrink-wrapped flex containers. (Issue 20)
</p>

<!-- 
	When omitted from the flex shorthand, its specified value is 0% the length zero .

	flex: <positive-number>
		Equivalent to flex: <positive-number> 1 0px0%. 
 -->

<p class="note">注記：
この変更は
<a href="#change-2015-flex-basis-zero">元に戻された</a>。
◎
Note: This change was reverted.
</p>

	</li>
	<li id="change-2012-unresolvable-basis"><p>
解決し得ない百分率による`~flex~base~size$を、 `auto^v に見なされるように定義した。
◎
Defined that an unresolvable percentage flex base size is treated as auto.
</li>

<!-- 
	percentage values of flex-basis are resolved against the flex item’s containing block, i.e. its flex container, and if that containing block’s size is indefinite, the result is undefined the same as a main size of auto .
 -->

	<li id="change-2012-static-pos">
<p>
`~flex容器$の絶対位置の子の`静的~位置$を，
Grid Layout と整合するように単純化した。
（`cr-2012#issue-6$iS）
◎
Simplified the static position of abspos children of flex containers to be consistent with Grid Layout. (Issue 6)
</p>

	</li>

<!-- 
	An absolutely-positioned child of a flex container does not participate in flex layout beyond the reordering step.

	However, if both left and right or both top and bottom are auto, then the used value of those properties are computed from its static position, as follows:

	If both left and right are auto, the flex item must be positioned so that its main-start or cross-start edge (whichever is in the horizontal axis) is aligned with the static position. If both top and bottom are auto, the flex item must be positioned so that its main-start or cross-start edge (whichever is in the vertical axis) is aligned with the static position.

	In the main axis,
		If there is a subsequent in-flow flex item on the same flex line, the static position is the outer main-start edge of that flex item.
		Otherwise, if there is a preceding in-flow flex item on the same flex line, the static position is the outer main-end edge of that flex item.
		Otherwise, the static position is determined by the value of justify-content on the flex container as if the static position were represented by a zero-sized flex item. 

	In the cross axis,
		If there is a preceding in-flow flex item, the static position is the cross-start edge of the flex line that item is in.
		Otherwise, the static position is the cross-start edge of the first flex line. 

	The static position is intended to more-or-less match the position of an anonymous 0×0 in-flow flex-start-aligned flex item that participates in flex layout, the primary difference being that any packing spaces due to justify-content: space-around or justify-content: space-between are suppressed around the hypothetical item: between it and the next item if there is a real item after it, else between it and the previous item (if any) if there isn’t.

	Its static position is calculated by first doing full flex layout without the absolutely-positioned children, then positioning each absolutely-positioned child as if it were the sole flex item in the flex container, assuming both the child and the flex container were fixed size boxes of their used size.
	For example, by default, the static position of an absolutely positioned child aligns it to the main-start/cross-start corner, corresponding to the default values of justify-content and align-content on the flex container. Setting justify-content:center on the flex container, however, would center it in the main axis.
 -->

	<li id="change-2012-flex-continuity"><p>
過去の仕様の
<a href="~TR/2012/CR-css3-flexbox-20120918/#resolve-flexible-lengths">当該節</a>
をこの仕様の`~flexible長さの解決-法$ 節に更新した：
その~algoを，~flex係数の総和が~zeroに近付くときに連続的に挙動するように変更した（総和 ≥ 1 の場合は変わりなし）。
（`cr-2012#issue-30$iS）
◎
Changed algorithm for resolving flexible lengths to make behavior continuous as the sum of the flex factors approaches zero. (No change for a sum ≥ 1.) (Issue 30) Replaces this section with this one.
</li>

</ul>


			</section>
			<section id="changes-2014-clarify">
<h4 title="Clarifications">明確化</h4>


<p>
次の有意な明確化も行われた：
◎
The following significant clarifications were also made:
</p>

<ul>

	<li id="clarify-2012-abspos-items"><p>
~flex容器の中の絶対位置の子は、今や（各種用語の混同を避けるため）
“~flex駒” とは呼ばれなくなった。
（ Issue ??）
◎
Absolutely positioned children of a flex container are no longer called "flex items" (to avoid terminology confusion). (??)
</li>

<!-- 
	Name: 	order
	Applies to: 	flex items and absolutely-positioned children of flex containers

	Re-order the flex items and absolutely positioned flex container children according to their order.
 -->

	<li id="clarify-2012-float-display"><p>
`float$p が 依然として， `display$p の算出値に影響することを明確化した（~flex駒の決定に先立って，~boxを補完する規則に影響し得る）。
（`cr-2012#issue-7$iS）
◎
Clarified that float still affects the computed display (which may affect box-fixup rules that run prior to flex item determination). (Issue 7)
</li>

<!-- 
	float and clear have no effect on a flex item , and do not take it out-of-flow. However, the float property can still affect box generation by influencing the display property’s computed value.
 -->

	<li id="clarify-2012-white-space"><p>
“空白” が意味するものを明確化した。
（`cr-2012#issue-26$iS）
◎
Clarify what is meant by “white space”. (Issue 26)
</li>

<!-- 
	However, an anonymous flex item that contains only white space (i.e. characters that can be affected by the white-space property) is not rendered, as if it were display:none.
 -->

	<li id="clarify-2012-table-anon-boxes"><p>
~table 匿名~boxの生成が，~table内~要素に対する算出値の変換の際に生じることを明確化した。
◎
Clarified that table anonymous box generation occurs in place of computed value conversion for internal table elements.
</li>
	<li id="clarify-2012-display-blockification">
<p>
~flex駒の決定と
<a href="~TR/css-display/">CSS Display Module Level 3</a>
にて定義された `display-inside^p ／ `display-outside^p のふるまいとの相互作用を明確化した。
◎
Clarified interaction of flex item determination with display-inside / display-outside (the new longhands of display defined in the CSS Display Module Level 3).
</p>
<!-- 
	If the specified display-outside of an in-flow child of an element that generates a flex container is inline-level, it computes to block-level. (This effectively converts any inline display values to their block equivalents.)
 -->

<p>注記：
この変更は
<a href="#change-201409-display-longhands">元に戻された</a>
◎
Note: This change was reverted.
</p>
	</li>

	<li id="clarify-2012-overflow-flex-containers"><p>
`overflow$p は~flex容器にも適用されることを明確化した。
◎
Clarified that overflow applies to flex containers.
</li>

	<li id="clarify-2012-first-line-letter"><p>
疑似要素
`first-line$pe ／ `first-letter$pe
は、~flex容器には適用されないことを明確化した（それらは`塊~容器$でないので）。
◎
Clarified that ::first-line and ::first-letter pseudo-elements do not apply to flex containers (because they are not block containers).
</li>

	<li id="clarify-2012-stretch-computed-auto"><p>
`stretch$v:ais に対しては、`交叉size~prop$の <em>算出値</em> が `auto^v にされているかどうかが検査されることを明確化した。
すなわち、（確定的~sizeに対して解決されないために）
`auto^v として挙動する，百分率による交叉sizeは、伸張されないことを意味する。
（`cr-2012#issue-5$iS）
◎
Clarify that stretch checks for the computed value of the cross-size property being auto, which means that percentage cross-sizes that behave as auto (because they don’t resolve against definite sizes) aren’t stretched. (Issue 5)
</li>

<!-- 

	stretch

		If the cross size property of the flex item is computes to auto, its used value is …

	Determine the used cross size of each flex item. If a flex item has align-self: stretch, its computed cross size property is auto, and …
 -->

	<li id="clarify-2012-flex-container-sizing"><p>
整形~文脈の規則が，~flex容器の主sizeの決定に利用されることを明確化した。
◎
Clarify that the rules of the formatting context are used for determining the flex container’s main size.
</li>

<!-- 
	Determine the main size of the flex container using the rules of the formatting context in which it participates its main size property . 
 -->

	<li id="clarify-2012-painting-order"><p>
塗りの際には、素の文書順に代わって `order$p による`改変文書順$が用いられることを明確化した。
（これは `order$p 節にてすでに定められていたが、塗り順序の節では定められていなかった）
◎
Clarified that order-modified document order is used instead of raw document order when painting. (This was already stated in the order section, but not in the section explicitly about painting order.)
</li>
	<li id="clarify-2012-line-breaking"><p>
~line分断-法を，［
~lineの終端に来る，~sizeが~zero以下の~flex駒
］を精確に取扱うように，明確化した。
（`cr-2012#issue-1$iS）
◎
Clarified line-breaking to precisely handle negatively-sized flex items and zero-size items at the end of a line. (Issue 1)
</li>

<!-- 
	Otherwise, starting from the first uncollected item, collect consecutive items one by one until the first time that the next collected item would not fit into the flex container’s inner main size, or until a forced break is encountered. If the very first uncollected item wouldn’t fit, collect just it into the line as many consecutive flex items as will fit or until a forced break is encountered (but collect at least one) into the flex container’s inner main size into a flex line .

	Note that items with zero main size will never start a line unless they’re the very first items in the flex container, or they’re preceded by a forced break. The "collect as many" line will collect them zero-sized flex items onto the end of the previous line even if the last non-zero item exactly "filled up" the line.
 -->

	<li id="clarify-2012-clamping"><p>
~flex 容器の交叉~sizeは依然として，~flex容器の［
~min, ~max
］~propで切詰められることを明確化した。
（`cr-2012#issue-24$iS）
◎
Clarified that flex container cross sizes are still clamped by the flex container’s min/max properties. (Issue 24)
</li>
<!-- 
		If the cross size property is a definite size, use that, clamped by the min and max cross size properties of the flex container .
		Otherwise, use the sum of the flex lines' cross sizes, clamped by the min and max cross size properties of the flex container . 
 -->

</ul>

			</section>
		</section>

</main></div><!-- id="MAIN0" -->


