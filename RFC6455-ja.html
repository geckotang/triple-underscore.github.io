<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>RFC 6455 - The WebSocket Protocol （日本語訳）</title>
<meta name="Keywords" content="RFC,WebSocket,HTML5,仕様,和訳" />

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="RFC-common.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

COMMON_DATA.init = function(expanded){
	if(!expanded) supply();

	return {
		original_url: 'http://tools.ietf.org/html/rfc6455',
		spec_status: 'IETFPR',
		no_original_dfn: true,
		main: 'MAIN',
		toc: 'toc',
		alt_refs: 'section-14',
		ref_id_prefix: 'ref-',
		word_switch: 'replace_table'
	};

// del_j(); 検証済み

	function supply(){
//		var ref_titles = Object.create(null);
		repeat('a', supply_links);
	
		function supply_links(a){
			var href = a.getAttribute('href');
			if(href){
				if(href.slice(0,2) === './'){
					a.href = 'http://tools.ietf.org/html/' + href.slice(2);
				}
				return;
			}
			var key = a.textContent;
			var c = key[key.length-1];
			switch(c){
			case ']' :
				if(key[0] === '[' ) {
					a.href = '#ref-'+ key.slice(1,-1);
	//				a.title = ref_titles[key];
				}
				return;
			case '節' :
				a.href= '#section-' + key.slice(0, -2);
				return;
			case 'タ' : // ... データ
				a.href= '#data-' + key.slice(0, -4);
				return;
			}
		}
	}
}

</script>

<script id="replace_table" type="text/plain">
	切断:closure
	切断-:close
	切断2:closing
	切断1:closure
	切断事由:close reason
	切断ハンドシェイク:closing handshake
	close コード:close code
	接続切断:connection close
接続待ち:pending connections

	オープン:open
終了:terminate
エージェント:agent
リダイレクト:redirect
パケット:packet
直列化:serialize
構文解析:parse
構文解析法:parsing
トンネル:tunnel
復号:decode
	妥当性を検証:validate
妥当:valid
	妥当でない:invalid
検証:verify
ゼロ:zero
ソケット:socket
多重化:multiplexing
負荷:load
負荷分散装置:load balancer
負荷委譲:offload
保護-:protect
保護:protection
ランダム:random
無作為:random
キャッシュ:cache
trusted:trusted
	trusted でない:untrusted
	track
完全性:integrity
遅延:delay
	変換:convert
悪意のある:malicious
入力:input
機密性:confidentiality
着信:incoming
発信:outgoing
ページ:page
ウェブ:web
伝送-:transmit
伝送:transmission
転送:transfer
伝送路:wire
チャンネル:channel
レベル:level
メソッド:method
暗号化:encrypt
	encrypt されていない:unencrypted
バッファ:buffer
トラフィック:traffic
トランスポート:transport
アドレス:address
アドレス法:addressing
クッキー:cookie
ハッシュ:hash
ピア:peer
確立:establish
処理:process
サイズ:size
パラメタ:parameter
サポート:support
中止:abort
フラグ:flag
サービス:service
オプション:option
	任意選択
アクセス:access
ピュニコード:punycode

	optional
整数:integer
	初期:initial
仕組み:mechanism
通信基盤:infrastructure
文脈:context
素片:fragment
識別子:identifier
識別:identify
ボディ:body
失敗:fail
失敗1:failure
合致:match
アルゴリズム:algorithm
攻撃:attack
攻撃者:attacker
ポリシー:policy
通信:communication
通信-:communicate
	対象:subject
下層:underlying
ネットワーク:network
段:step
手続き:steps
状態:state
オクテット:octet
スクリプト:script
中継点:intermediary
順序:order
認証:authentication
認証-:authenticate
空:empty
リモート:remote
成分:component
層:layer
	重ね:layered
種別:type
	タイプ:type

折衝-:negotiate
折衝処理:negotiating
折衝:negotiation
	ネゴシエート:negotiate
	ネゴシエーション:negotiation
事由:reason
文字:character
プロキシ:proxy
エラー:error
エラーコード:error code
構文:syntax
ブラウザ:browser
断片:fragment
断片化:fragmentation
	（の様態）
断片化-:fragment 化
	fragment 化された:fragmented 
	fragment 化されていない:unfragmented
	要件:requirement
	開始:start
絶対:absolute
相対:relative
リスト:list
内包:include
構成子:construct
規則:rule
生成規則:production
形式:format
形式1:form

データ形式:format
継続:continuation
正常:normal
異常:abnormal
透過型:intercepting
安定的:stable
利用者:user
双方向:bidirectional

バイナリ:binary
符号化:encode
符号化方式:encoding
スキーム:scheme
単独の:single
バイト:byte
テキスト:text
リソース:resource
文字列:string
空文字列:empty string
登録-:register
登録:registration
登録済みの:registered
レジストリ:registry
セキュリティ:security
セキュア:secure
トークン:token
受理:accept
	acceptance
送信:send
	送信:sending
送信側:sender
受信:receive
	受信:receiving
	送受信:sending／receiving
受信先:recipient
受信側:receiver
返信:reply
生成元:origin
ポート:port
クリア:clear
セット:set
ビット:bit
応答:response
応答可能:responsive
応答-:respond
マスキングキー:masking key
	マスキング:masking
	mask の適用
マスク:mask
	マスクを解除する:unmask
	マスクされていない:unmasked
opcode:opcode
アプリケーション:application
ホスト:host
ペイロード:payload
リクエスト:request
要請:request
	制御:control
キー:key
長さ:length
端点:endpoint
	エンドポイント
コード:code
メッセージ:message
メッセージング:messaging
バージョン:version
	versioned
	バージョン付け:versioning
ステータスコード:status code
ステータス:status
拡張:extension
	拡張可能:extensible
	拡張性:extensibility
プロトコル:protocol
下位プロトコル:subprotocol
フィールド:field
ハンドシェイク:handshake
	ヘッダ:header
	ヘッダフィールド:header field
ヘッダ:header field
クライアント:client
フレーム:frame
フレームヘッダ:frame header
フレーミング:framing
接続:connection
接続-:connect
再接続:reconnect
データ:data
サーバ:server
再構築:reassembly
予約:reserve
	予約済:reserved
予約済み:reserved
意味論:semantics
	semantic meaning
交互挿入:interleave
待機:wait
文字大小無視:case-insensitive
証明書:certificate
特色機能:feature
	ウェブブラウザ:web browser
	ウェブページ:web page
	リモートホスト:remote host
番号:number
	テキストフレーム:text frame
	テキストデータ:text data
	テキストメッセージ:text message
	バイナリフレーム:binary frame
	バイナリデータ:binary data
	バイナリメッセージ:binary message
	データフレーム:data frame
	セキュリティモデル:security model

バックオフ:backoff
ユースケース:use-case
ライブラリ:library
フレームワーク:framework
エスケープ:escape
エスケープ復元後:unescaping 後
エンドツーエンド:end-to-end
パスワード:password
サイト:site
キュー:queue
メタデータ:metadata
ローカル:local
ストリーム:stream
フィルタリング:filtering
クエリ:query
パーセント:percent
クラス:class
スタック:stack
パターン:pattern
プラットフォーム:platform
プロパティ:property
リッスン:listen
セッション:session
	ベース:base
基礎部:base
モデル:model
グループ:group
改訂版:revisions
キーワード:keyword
インジェクション:injection
コール:call
ダウンロード:download
ダウン:down
	アクション:action
データセンター:data center
オプトイン:opt-in
ポーリング:polling
正誤表:errata
フィードバック:feedback
ストリーミング:streaming
コミュニティ:community
オーバーヘッド:overhead
インターフェース:interface
コンポーネント:component
トレードオフ:trade-off
ソフトウェア:software
ドメイン:domain
メジャー:major
正規化:normalization
変種:variant
連絡先:Contact
終端値:terminal value
文字集合:character set
双路:two-way
共通名:common name
既定:default
可用:available
要素:element:~
名:name:~
	// 複合語
サービス供与:serve
サーバ側:server-side
クライアント側:client-side
クロス生成元:cross-origin
カプセル化:encapsulate
登録ポリシー:registration policy

ホスト名:host name
制御メッセージ:control message
制御フレーム:control frame
符号化データ:encoded data
文字符号化スキーム:character-encoding scheme
パーセント符号化形:percent-encoded form


</script>
<!-- 
開いた:open した
開く:open する
開接？開設？
再開:reopen
開かれ:open され
開いて:open して
開いている接続:open 中の接続
接続開始ハンドシェイク:opening ハンドシェイク

閉じる:closeする
閉接？閉鎖？
閉じられ:closeされ
閉じ:closeし
閉接ハンドシェイク
接続閉鎖ハンドシェイク:closing

バージョン番号:version number
コード番号:code number
応答コード:response code

最上位ビット:most significant bit
高レベル:high-level
継続フレーム:continuation frame
実ネット:wild
未サポート:unsupported

セレクタ:selector
テキストのtextual
コメント:comment

 -->
<!-- 
Connection
Data
Binary
Text
Close
Ping
Pong
Protocol

clean~clean
closing
closure
open
	reopen~再~open
opening
 -->
<!--%style -->
<style type="text/css">
/* 定義語句へのリンク */
a.dfnref {
	color: maroon;
}

/* ヘッダフィールド名 */
b {
	color: #035;
}

dl.defs > dt {
	color: maroon;
}

code.code {
	color: black;
}

#framing-table {
	border-collapse: separate;
	border-spacing: 1px 1px;
	margin:1em 2em;
}
#framing-table td, #framing-table th {
	border: solid black 1px;
	min-width:1em;
	text-align:center;
}
#framing-table th {
	border: none;
	text-align:left;
	padding:0;
}
#framing-table td {
	padding:0;
	background: #EEE;
}
#framing-table a {
}

</style>



<!-- 
&#x200B; ZERO WIDTH SPACE
-->

</head>

<body >


<div style="display:none;">
<input id="_page_config" value="" type="hidden">
</div>


<aside class="trans-meta">

<h1>RFC6455 — The WebSocket Protocol 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、 IETF による， 2011 年 12 月発行 PROPOSED STANDARD
<a href="http://www.ietf.org/rfc/rfc6455.txt">RFC 6455</a>
（<a href="http://tools.ietf.org/html/rfc6455">HTML 版</a>）
"The WebSocket Protocol"
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html" >他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2016-04-25</time>
（公開：<time>2012-04-06</time> ）
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン
— CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります
— 原文ソース比較 検証済み）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<table class="meta-info"><tbody><tr><th colspan="2">
Internet Engineering Task Force (IETF)

</th></tr><tr><th title="Request for Comments">RFC
</th><td>6455

</td></tr><tr><th title="Category">分類
</th><td>Standards Track

</td></tr><tr><th>ISSN
</th><td>2070-1721

</td></tr></tbody></table>

<table class="meta-info"><tbody><tr><th>編集
</th><td>
I. Fette, Google, Inc.;<br />
A. Melnikov, Isode Ltd.

</td></tr><tr><th>発行
</th><td>2011 年 12 月

</td></tr></tbody></table>

</header>

<!-- ＊
<header >
<h2 style="text-align: right;">PROPOSED STANDARD</h2>
<div style="">
Internet Engineering Task Force (IETF)<br />
Request for Comments: 6455<br />
Category: Standards Track<br />
ISSN: 2070-1721<br />
<br />
I. Fette, Google, Inc. A. Melnikov, Isode Ltd. December 2011
</div>
</header>
 -->

<h1 title="The WebSocket Protocol">WebSocket Protocol</h1>

<h2 title="Abstract">要約</h2>

<p>
WebSocket Protocol は、制御された環境下で信頼できないコードを実行しているクライアントと，そのコードからの通信に対するオプトインを備えるリモート­ホストとの間の双路通信を可能にする。
利用されるセキュリティ­モデルは、ウェブ­ブラウザ間で共通して用いられている，生成元（ origin ）に基づくセキュリティ­モデルである。
プロトコルは、 TCP の上に重ねられる， opening ハンドシェイク, および後続の基本的なメッセージ フレーミングからなる。
この技術の目標は、サーバとの双路通信を必要とする，ブラウザに基づくアプリケーションのために、複数の HTTP 接続の open （例えば， XMLHttpRequest や &lt;iframe&gt; と長いポーリングを併用するものなど）に依拠しない仕組みを提供することである。
<span lang="en">
The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the origin-based security model commonly used by web browsers. The protocol consists of an opening handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using XMLHttpRequest or &lt;iframe&gt;s and long polling).
</span></p>

<h2 title="Status of This Memo">このメモの位置付け</h2>

<p>
これは、 Internet Standards Track 文書である。
<span lang="en">
This is an Internet Standards Track document.
</span></p>

<p>
この文書は、
<abbr title="Internet Engineering Task Force">IETF</abbr>
よる成果物であり，
IETF コミュニティの合意を表現するものである。
それは、公開の評価を受け，
<abbr title="Internet Engineering Steering Group">IESG</abbr>
から発行が承認されたものである。
Internet 標準についての更なる情報は
<a href="http://tools.ietf.org/html/rfc5741#section-2">RFC5741 2 節</a>
に見られる。
<span lang="en">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
</span></p>

<p>
この文書の現在の位置付け, 正誤表, フィードバックの仕方についての情報は、
<a href="http://www.rfc-editor.org/info/rfc6455">http://www.rfc-editor.org/info/rfc6455</a>
から得られる。
<span lang="en">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6455.
</span></p>

<h5 title="Copyright Notice">著作権の告知</h5>

<p>
Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p>
この文書は、その発行の日付から有効な、
<a href="http://tools.ietf.org/html/bcp78">BCP 78</a>,
<!-- http://tools.ietf.org/rfc/bcp/bcp78.txt -->
および IETF Trust の IETF Documents に対する Legal Provisions Relating の対象になる（
<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>
）。
これらの文書には，この文書に関するあなたの権利と制約条項が述べらているので、入念に査読されたし。
この文書から取り出された Code Components は、
Trust Legal Provisions の Section 4.e 
に述べられるように， Simplified BSD License テキストを含んでいなければならず、
Simplified BSD License に述べられるように，無保証で提供される。
<span lang="en">
This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
</span></p>

<nav class="toc" id="toc">
<h2 title="Table of Contents">目次</h2>
<!-- 自動生成 -->
</nav>

<main id="MAIN">

<section id="section-1">

<h2 title="Introduction">1. 導入</h2>

	<section id="section-1.1">

<h3 title="Background">1.1. 背景</h3>

<p>
<em>この節は参考である。</em>
<span lang="en">
_This section is non-normative._
</span></p>

<p>
歴史的に、クライアント↔サーバ間の双方向­通信を必要とする ウェブ アプリケーション（例えば，インスタントメッセンジャや, ゲームアプリケーション）の作成においては、サーバから更新をポーリングするために，上流への通知を別個の HTTP コールとして送信する間、 HTTP の濫用を要していた <a>[RFC6202]</a> 。
<span lang="en">
Historically, creating web applications that need bidirectional communication between a client and a server (e.g., instant messaging and gaming applications) has required an abuse of HTTP to poll the server for updates while sending upstream notifications as distinct HTTP calls [RFC6202].
</span></p>

<p>
これは様々な問題を引き起こす：
<span lang="en">
This results in a variety of problems:
</span></p>

<ul>

	<li>
サーバは、クライアントのそれぞれに対し，多数の下層 TCP 接続の利用を強いられる：
クライアントへの情報の送信に一つ，着信メッセージのそれぞれに新たなものを一つずつ。
<span lang="en">
The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client and a new one for each incoming message.
</span></li>

	<li>
クライアントからサーバへのメッセージのそれぞれに HTTP ヘッダが含まれるため、伝送路プロトコルのオーバーヘッドが高くなる。
<span lang="en">
The wire protocol has a high overhead, with each client-to-server message having an HTTP header.
</span></li>

	<li>
クライアント側スクリプトは、返信を追跡するために，発信­接続から着信­接続への対応付けを維持管理しなければならない。
<span lang="en">
The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.
</span></li>

</ul>

<p>
より単純な解決策は、両方向のトラフィックのために，単独の TCP 接続を利用するものになるであろう。
これが、 WebSocket Protocol が提供するものである。
それは， WebSocket API
<a>[WSAPI]</a>
との併用により、ウェブ­ページからリモート­サーバへの双路­通信のための， HTTP ポーリングに代わるものを提供する。
<span lang="en">
A simpler solution would be to use a single TCP connection for traffic in both directions. This is what the WebSocket Protocol provides. Combined with the WebSocket API [WSAPI], it provides an alternative to HTTP polling for two-way communication from a web page to a remote server.
</span></p>

<p>
同じ技法は様々なウェブ­アプリケーションにも利用できる：
ゲーム, 相場表示機, 複数­利用者から同時編集可能なアプリケーション,
サーバ側のサービスがリアルタイムに反映される利用者インターフェース，等々。
<span lang="en">
The same technique can be used for a variety of web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.
</span></p>

<p>
WebSocket Protocol は、現存の通信基盤からの利点（プロキシ, フィルタリング, 認証）を得るために HTTP をトランスポート層に利用している，既存の双方向­通信­技術に、なり代わるものを目指して設計されている。
HTTP には元々，双方向­通信の用途は想定されていないので（更なる論は <a>[RFC6202]</a> を見よ）、その種の技術は，効率性と信頼性のトレードオフとして実装されていた。
WebSocket Protocol は、現存の HTTP 通信基盤の環境下における，既存の双方向 HTTP 技術の目標に取り組むものである。
そのようなわけで、現在の環境に固有の 多少の複雑さも伴うことにはなるが、それは、
HTTP のポート 80 と 443 を通して働くように，加えて HTTP プロキシや中継点をサポートするように設計されている。
しかしながら，その設計は WebSocket を HTTP に限定するものではなく、将来の実装はプロトコル全体を再発明することなく，専用のポートを通した，より単純なハンドシェイクを利用するものにもなり得る。
この最後の点は、対話的メッセージングのトラフィック パターンが標準の HTTP のトラフィックに近似しないものであり，一部のコンポーネントにおいては過度の負荷を誘引し得ることから、重要である。
<span lang="en">
The WebSocket Protocol is designed to supersede existing bidirectional communication technologies that use HTTP as a transport layer to benefit from existing infrastructure (proxies, filtering, authentication). Such technologies were implemented as trade-offs between efficiency and reliability because HTTP was not initially meant to be used for bidirectional communication (see [RFC6202] for further discussion). The WebSocket Protocol attempts to address the goals of existing bidirectional HTTP technologies in the context of the existing HTTP infrastructure; as such, it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries, even if this implies some complexity specific to the current environment. However, the design does not limit WebSocket to HTTP, and future implementations could use a simpler handshake over a dedicated port without reinventing the entire protocol. This last point is important because the traffic patterns of interactive messaging do not closely match standard HTTP traffic and can induce unusual loads on some components.
</span></p>

	</section>
	<section id="section-1.2">

<h3 title="Protocol Overview">1.2. プロトコルの概観</h3>

<p>
<em>この節は参考である。</em>
<span lang="en">
_This section is non-normative._
</span></p>

<p>
このプロトコルは、ハンドシェイクおよびデータ転送の，２つのパートからなる：
<span lang="en">
The protocol has two parts: a handshake and the data transfer.
</span></p>

<p>
次のような形のクライアントからのハンドシェイクに対し：
<span lang="en">
The handshake from the client looks as follows:
</span></p>

<pre class="example">
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</pre>

<p>
サーバからのハンドシェイクは次のような形をとる：
<span lang="en">
The handshake from the server looks as follows:
</span></p>

<pre class="example">
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
</pre>

<p>
クライアントからの先頭行は Request-Line 形式に従う。
サーバからの先頭行は Status-Line 形式に従う。
Request-Line と Status-Line の生成規則は <a>[RFC2616]</a> にて定義される。
<span lang="en">
The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format. The Request-Line and Status-Line productions are defined in [RFC2616].
</span></p>

<p>
いずれの場合も，先頭行の後に順序のない一連の HTTP ヘッダが続く。
これらのヘッダの意味は、この文書の <a>4 節</a> にて指定される。
クッキー <a>[RFC6265]</a> などの追加のヘッダも在ってよい。
ヘッダの形式と その構文解析法は， <a>[RFC2616]</a> にて定義される。
<span lang="en">
An unordered set of header fields comes after the leading line in both cases. The meaning of these header fields is specified in Section 4 of this document. Additional header fields may also be present, such as cookies [RFC6265]. The format and parsing of headers is as defined in [RFC2616].
</span></p>

<p>
クライアントとサーバの両者がそれぞれのハンドシェイクを送信した後，ハンドシェイクが成功したならば、データ転送パートが開始される。
これは、それぞれの側が互いに独立に, 自身の意向によりデータを送信できる，双路­通信チャンネルである。
<span lang="en">
Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can, independently from the other, send data at will.
</span></p>

<p>
ハンドシェイクの成功後、クライアントとサーバは，この仕様において “メッセージ” と呼ばれる，概念的な単位で区切られたデータを 相互に転送しあう。
伝送路­上では， 1 個のメッセージは 1 個以上のフレームから構成される。
WebSocket メッセージは特定のネットワーク層フレーミングに対応しなければならないわけではなく、断片化されたメッセージは，中継点において合併／分割され得る。
<span lang="en">
After a successful handshake, clients and servers transfer data back and forth in conceptual units referred to in this specification as "messages". On the wire, a message is composed of one or more frames. The WebSocket message does not necessarily correspond to a particular network layer framing, as a fragmented message may be coalesced or split by an intermediary.
</span></p>


<div class="p">
<p id="frame-type">
フレームには種別（ type ）が結び付けられる。
同じメッセージに属するそれぞれのフレームは，同じ種別のデータを含む。
おおまかに言えば、種別は次のものに分類される：
</p>

<ul>
	<li>
テキスト­データ用途（ UTF-8 <a>[RFC3629]</a> テキストとして解釈される）,
</li>
	<li>
バイナリ­データ用途（それらの解釈はアプリケーションに委ねられる）,
</li>
	<li>
制御フレーム用途（アプリケーションのためのデータを運ぶものではなく，接続が close されるべき旨の信号を送るなど，プロトコル­レベルの信号通信のためのもの）。
</li>
</ul>

<p>
このバージョンのプロトコルは 6 種類のフレーム種別を定義し，残る 10 種類は将来利用のために予約済み<!--1-->とする。
</p>

<span lang="en">
A frame has an associated type. Each frame belonging to the same message contains the same type of data. Broadly speaking, there are types for textual data (which is interpreted as UTF-8 [RFC3629] text), binary data (whose interpretation is left up to the application), and control frames (which are not intended to carry data for the application but instead for protocol-level signaling, such as to signal that the connection should be closed). This version of the protocol defines six frame types and leaves ten reserved for future use.
</span>
</div>

	</section>
	<section id="section-1.3">

<h3 title="Opening Handshake">1.3. opening ハンドシェイク</h3>

<p>
<em>この節は参考である。</em>
<span lang="en">
_This section is non-normative._
</span></p>

<p>
opening ハンドシェイクは、単独のポートを，サーバとやりとりする HTTP クライアント,
および サーバとやりとりする WebSocket クライアント，のいずれからも利用できるようにするため、
HTTP に基づくサーバ側ソフトウェアや中継点との互換性が保たれることが意図されている。
その目的のため， WebSocket クライアントのハンドシェイクは HTTP Upgrade リクエストになる：
<span lang="en">
The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. To this end, the WebSocket client's handshake is an HTTP Upgrade request:
</span></p>

<pre class="example">
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</pre>

<p>
<a>[RFC2616]</a> に従い、クライアントから送信されるハンドシェイクの中のヘッダの順序は任意であり，受信されるヘッダの順序は有意ではない。
<span lang="en">
In compliance with [RFC2616], header fields in the handshake may be sent by the client in any order, so the order in which different header fields are received is not significant.
</span></p>

<p>
GET メソッド <a>[RFC2616]</a> の "Request-URI" は， WebSocket 接続の端点†
の識別に用いられ、１個の IP アドレスによる複数ドメインにわたるサービス供与，および
単独のサーバによる複数の WebSocket 端点に対するサービス供与が可能になる。
<span lang="en">
The "Request-URI" of the GET method [RFC2616] is used to identify the endpoint of the WebSocket connection, both to allow multiple domains to be served from one IP address and to allow multiple WebSocket endpoints to be served by a single server.
</span></p>

<p class="trans-note">【†
“端点（ endpoint ）” ：クライアント, サーバ（ネットワーク通信の始端, 終端（順不同））の両者をひっくるめて指す総称。
対義語は “中継点（ intermediary ）”。
端点と同じ意味で，語 “ピア（ peer ）” も用いられる（
<a href="https://tools.ietf.org/html/rfc7540#section-2.2">HTTP/2 の定義</a>
によれば、この語は，論の主題とされている端点から見た，他方の端点を指すとされている）。
】</p>

<p>
クライアントは、 <a>[RFC2616]</a> に従い，利用中のホストがどれなのかクライアントとサーバ間で互いの一致を検証できるように，そのハンドシェイクの
<b>Host</b> ヘッダ内にホスト名を内包させる。
<span lang="en">
The client includes the hostname in the |Host| header field of its handshake as per [RFC2616], so that both the client and the server can verify that they agree on which host is in use.
</span></p>

<p>
WebSocket Protocol には、オプションの選択に利用できる，追加のヘッダもある。
このバージョンにて可用な代表的なオプションには、下位プロトコル セレクタ（ <b>Sec-WebSocket-Protocol</b> ）,
クライアントがサポートする拡張のリスト（ <b>Sec-WebSocket-Extensions</b> ）,
<b>Origin</b> ヘッダ，などがある。
<!-- over -->
<b>Sec-WebSocket-Protocol</b> リクエスト
ヘッダは、クライアントが受理し得る下位プロトコル（ WebSocket Protocol 層­上の，アプリケーション­レベルのプロトコル）の指示に利用できる。
サーバは、受理­可能なプロトコルのうち，いずれか１個または０個を選択して、そのプロトコルが選択されたことを指示するために，ハンドシェイクにてその値を返す。
<span lang="en">
Additional header fields are used to select options in the WebSocket Protocol. Typical options available in this version are the subprotocol selector (|Sec-WebSocket-Protocol|), list of extensions support by the client (|Sec-WebSocket-Extensions|), |Origin| header field, etc. The |Sec-WebSocket-Protocol| request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket Protocol) are acceptable to the client. The server selects one or none of the acceptable protocols and echoes that value in its handshake to indicate that it has selected that protocol.
</span></p>

<pre class="example">
Sec-WebSocket-Protocol: chat
</pre>

<p>
<b>Origin</b> ヘッダ <a>[RFC6454]</a> は、ウェブ­ブラウザの中で WebSocket API を利用するスクリプトによる，権限のないクロス生成元による WebSocket サーバの利用から 保護するために利用される。
サーバには、 WebSocket 接続リクエストを生成するスクリプトの生成元が伝えられる。
サーバは，この生成元からの接続の受理を望まない場合、適切な HTTP エラーコードを送信して，接続を拒否できる。
このヘッダは，ブラウザ­クライアントから送信される。
非ブラウザ­クライアントの場合、その種のクライアントの文脈において意味をなすのであれば，このヘッダが送信されてもよい。
<span lang="en">
The |Origin| header field [RFC6454] is used to protect against unauthorized cross-origin use of a WebSocket server by scripts using the WebSocket API in a web browser. The server is informed of the script origin generating the WebSocket connection request. If the server does not wish to accept connections from this origin, it can choose to reject the connection by sending an appropriate HTTP error code. This header field is sent by browser clients; for non-browser clients, this header field may be sent if it makes sense in the context of those clients.
</span></p>

<p>
最後に、サーバは， WebSocket 接続でない接続を受理しないようにするために、クライアントに対し，クライアントによる WebSocket ハンドシェイクを受信したことを立証しなければならない。
これにより、攻撃者が XMLHttpRequest
<a>[XMLHttpRequest]</a>
やフォーム<!-- submission  -->を用いて巧妙に細工されたパケットを送信して， WebSocket サーバを騙そうとする試みは防止される。
<span lang="en">
Finally, the server has to prove to the client that it received the client's WebSocket handshake, so that the server doesn't accept connections that are not WebSocket connections. This prevents an attacker from tricking a WebSocket server by sending it carefully crafted packets using XMLHttpRequest [XMLHttpRequest] or a form submission.
</span></p>

<p>
ハンドシェイクの受信を立証するためには、サーバは、２つの情報­片をとり，それらを結合して、応答を形成する必要がある。
最初の情報­片は、クライアント ハンドシェイクの
<b>Sec-WebSocket-Key</b> ヘッダから得られるものである：
<span lang="en">
To prove that the handshake was received, the server has to take two pieces of information and combine them to form a response. The first piece of information comes from the |Sec-WebSocket-Key| header field in the client handshake:
</span></p>

<pre class="example">
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
</pre>

<p>
このヘッダに対し、サーバはその値（上のヘッダに示されているように base64 符号化 <a>[RFC4648]</a> されたものから，頭部と尾部の空白を取り除いたもの）を取得し，文字列の形をとる もう１つの情報­片 — GUID （大域的一意識別子, Globally Unique Identifier, <a>[RFC4122]</a> ）
"<code >258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>"
と連結する。
<!-- 大域的一意識別子 http://ja.wikipedia.org/wiki/GUID -->
これは、 WebSocket Protocol を解さないネットワーク端点から利用されることはないものと見込まれている。
この連結結果に対し， SHA-1 ハッシュ（ 160 ビット） <a>[FIPS.180-3]</a> をとって，更に base64 符号化（
<a>[RFC4648]</a> <a href="./rfc4648#section-4">4 節</a>
参照）を施したものが、サーバのハンドシェイクにて返される。
<span lang="en">
For this header field, the server has to take the value (as present in the header field, e.g., the base64-encoded [RFC4648] version minus any leading and trailing whitespace) and concatenate this with the Globally Unique Identifier (GUID, [RFC4122]) "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" in string form, which is unlikely to be used by network endpoints that do not understand the WebSocket Protocol. A SHA-1 hash (160 bits) [FIPS.180-3], base64-encoded (see Section 4 of [RFC4648]), of this concatenation is then returned in the server's handshake.
</span></p>

<div>
<p>
上の例で具体的に示すなら、
<b>Sec-WebSocket-Key</b> ヘッダの値が
"<samp>dGhlIHNhbXBsZSBub25jZQ==</samp>"
であるなら、サーバは：
</p>

<ol>
	<li>
まず、文字列
"<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>"
を連結して
"<samp>dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</samp>"
を形成する。
</li>

	<li>
次に、その SHA-1 ハッシュをとり，値［
<samp>0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea</samp>
］を得る。
</li>

	<li>
最後に、この値を base64 符号化（
<a>[RFC4648]</a> <a href="./rfc4648#section-4">4 節</a>
参照）して得られる値
"<samp>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</samp>"
が，
<b>Sec-WebSocket-Accept</b> ヘッダの中に返されることになる。
</li>
</ol>

<p lang="en">
Concretely, if as in the example above, the |Sec-WebSocket-Key| header field had the value "dGhlIHNhbXBsZSBub25jZQ==", the server would concatenate the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" to form the string "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11". The server would then take the SHA-1 hash of this, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded (see Section 4 of [RFC4648]), to give the value "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=". This value would then be echoed in the |Sec-WebSocket-Accept| header field.</p>
</div>

<p>
サーバからのハンドシェイクは，クライアントからのハンドシェイクよりもずっと単純になる。
最初の行はステータスコード 101 を伴う HTTP Status-Line になる：
<span lang="en">
The handshake from the server is much simpler than the client handshake. The first line is an HTTP Status-Line, with the status code 101:
</span></p>

<pre class="example">
HTTP/1.1 101 Switching Protocols
</pre>

<p>
101 以外のどのステータスコードも
WebSocket ハンドシェイクが完了しておらず，
HTTP の意味論が依然として適用されることを指示する。
ステータスコードの後にヘッダが続く。
<span lang="en">
Any status code other than 101 indicates that the WebSocket handshake has not completed and that the semantics of HTTP still apply. The headers follow the status code.
</span></p>

<p>
<b>Connection</b> と <b>Upgrade</b> ヘッダが HTTP Upgrade を構成する。
<!--  -->
<b>Sec-WebSocket-Accept</b> ヘッダは、サーバが接続を受理する意向があるかどうかを指示する。
もし在るならば，このヘッダは
<b>Sec-WebSocket-Key</b>
内に送信されたクライアントの nonce に，定義­済みの GUID を付加してハッシュをとったものを内包していなければならない。
他のすべての値は、サーバによる接続の受理に解釈されてはならない。
<span lang="en">
The |Connection| and |Upgrade| header fields complete the HTTP Upgrade. The |Sec-WebSocket-Accept| header field indicates whether the server is willing to accept the connection. If present, this header field must include a hash of the client's nonce sent in |Sec-WebSocket-Key| along with a predefined GUID. Any other value must not be interpreted as an acceptance of the connection by the server.
</span></p>

<pre class="example">
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</pre>

<p>
これらのヘッダは、スクリプトされたページに対し， WebSocket クライアントから検査される。
<b>Sec-WebSocket-Accept</b> の値が予期される値に合致しない場合,
または このヘッダを欠いている場合,
または HTTP ステータスコードが 101 でない場合、接続は確立されず，
WebSocket フレームは送信されないことになる。
<span lang="en">
These fields are checked by the WebSocket client for scripted pages. If the |Sec-WebSocket-Accept| value does not match the expected value, if the header field is missing, or if the HTTP status code is not 101, the connection will not be established, and WebSocket frames will not be sent.
</span></p>

<p>
オプションのヘッダを内包することもできる。
このバージョンのプロトコルにおける主要なオプション ヘッダは、サーバが選択した下位プロトコルを指示する， <b>Sec-WebSocket-Protocol</b> である。
WebSocket クライアントは、自身がハンドシェイクに指定した下位プロトコル値のうちの一つを，サーバが内包したかどうか検証する。
複数の下位プロトコルを話せるサーバは、クライアントのハンドシェイクに基づいて，いずれか 1 つを選択して、そのハンドシェイクに指定しなければならない。
<span lang="en">
Option fields can also be included. In this version of the protocol, the main option field is |Sec-WebSocket-Protocol|, which indicates the subprotocol that the server has selected. WebSocket clients verify that the server included one of the values that was specified in the WebSocket client's handshake. A server that speaks multiple subprotocols has to make sure it selects one based on the client's handshake and specifies it in its handshake.
</span></p>

<pre class="example">
Sec-WebSocket-Protocol: chat
</pre>

<p>
サーバは、 <a>[RFC6265]</a> の記述に従って，クッキーに関係するオプション ヘッダを設定することにより、クッキーを
<a class="dfnref" href="#dfn-cookie-during-handshake">設定する</a>
こともできる。
<span lang="en">
The server can also set cookie-related option fields to _set_ cookies, as described in [RFC6265].
</span></p>

	</section>
	<section id="section-1.4">

<h3 title="Closing Handshake">1.4. closing ハンドシェイク</h3>

<p>
<em>この節は参考である。</em>
<span lang="en">
_This section is non-normative._
</span></p>

<p>
closing ハンドシェイクは， opening ハンドシェイクよりもずっと単純である。
<span lang="en">
The closing handshake is far simpler than the opening handshake.
</span></p>

<p>
いずれのピアも、 closing ハンドシェイクを始めるために，指定された制御の並びを含んだデータを伴う制御フレームを送信できる（ <a>5.5.1 節</a> にて詳細を述べる）。
その種のフレームが受信された際には、相方のピアは，まだ送信していなければ，応答として Close フレームを送信する。
最初に送信した側のピアは，<!-- _that_ -->その制御フレームを受信した際に、それ以上のデータが来ないものとして，接続を安全に close する。
<!-- in~the~knowledge~that -->
<span lang="en">
Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake (detailed in Section 5.5.1). Upon receiving such a frame, the other peer sends a Close frame in response, if it hasn't already sent one. Upon receiving _that_ control frame, the first peer then closes the connection, safe in the knowledge that no further data is forthcoming.
</span></p>

<p>
接続の close を指示する制御フレームの送信を済ませたピアは、それ以上のデータを送信しない。
接続の close を指示する制御フレームを受信したピアは、それ以降の受信データを破棄する。
<span lang="en">
After sending a control frame indicating the connection should be closed, a peer does not send any further data; after receiving a control frame indicating the connection should be closed, a peer discards any further data received.
</span></p>

<p>
双方のピアが，同時に，このハンドシェイクを起動しても 安全である。
<span lang="en">
It is safe for both peers to initiate this handshake simultaneously.
</span></p>

<p>
closing ハンドシェイクは、特に透過型プロキシや他の中継点が介在する場合において，
TCP closing ハンドシェイクが常に信頼し得るエンドツーエンドになるとは限らない意味で、
TCP closing ハンドシェイク（ FIN/ACK ）を補完することが意図されている。
<span lang="en">
The closing handshake is intended to complement the TCP closing handshake (FIN/ACK), on the basis that the TCP closing handshake is not always reliable end-to-end, especially in the presence of intercepting proxies and other intermediaries.
</span></p>

<p>
Close フレームを送信して，その応答の Close フレームを待機することにより、データが不必要に失われ得る一定の状況を回避できる。
例えば，何らかのプラットフォームにおいて，データが受信キューに残ったままソケットが close された場合、 RST パケットが送信され、読み取り待ちのデータがあったとしても，その RST を受信した側の <code class="code">recv()</code> は失敗する。
<span lang="en">
By sending a Close frame and waiting for a Close frame in response, certain cases are avoided where data may be unnecessarily lost. For instance, on some platforms, if a socket is closed with data in the receive queue, a RST packet is sent, which will then cause recv() to fail for the party that received the RST, even if there was data waiting to be read.
</span></p>

	</section>
	<section id="section-1.5">

<h3 title="Design Philosophy">1.5. 設計理念</h3>

<p>
<em>この節は参考である。</em>
<span lang="en">
_This section is non-normative._
</span></p>

<p>
WebSocket Protocol は、フレーミングは最小限に留めるべき，という原理に基づいて設計されている（フレーミングは、プロトコルをストリームではなくフレームに基づくものにすること, および Unicode テキストとバイナリのフレームの区別をサポートすること、のためのみに限られている）。
メタデータは、アプリケーション層により， WebSocket の一つ上の層に重ねられることが予期されている — メタデータがアプリケーション層により， TCP の一つ上の層に重ねられるのと同じ様に（例えば， HTTP ）。
<span lang="en">
The WebSocket Protocol is designed on the principle that there should be minimal framing (the only framing that exists is to make the protocol frame-based instead of stream-based and to support a distinction between Unicode text and binary frames). It is expected that metadata would be layered on top of WebSocket by the application layer, in the same way that metadata is layered on top of TCP by the application layer (e.g., HTTP).
</span></p>

<p>
概念的には， WebSocket は、ちょうど，次だけを行う TCP の一つ上の層である：
<span lang="en">
Conceptually, WebSocket is really just a layer on top of TCP that does the following:
</span></p>

<ul>
	<li>
ブラウザのための，ウェブ生成元に基づくセキュリティ­モデルを追加する
<span lang="en">
adds a web origin-based security model for browsers
</span></li>

	<li>
１個のポート上における複数のサービスを,
および １個の IP アドレス上における複数のホスト名をサポートするための、アドレス法とプロトコル命名の仕組みを追加する
<span lang="en">
adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address
</span></li>

	<li>
TCP の一つ上にフレーミングの仕組みを持つ層を重ねることにより、
TCP の下層の IP パケットの仕組みを（長さ制限を取り払いつつ）取り戻す
<span lang="en">
layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits
</span></li>

	<li>
プロキシや他の中継点が介在していても働くように設計された、追加の closing ハンドシェイクを帯域内（ in-band ）に内包する
<!--  -->
<span lang="en">
includes an additional closing handshake in-band that is designed to work in the presence of proxies and other intermediaries
</span></li>
</ul>

<p>
それ以外のものは、 WebSocket には加えられない。
基本的に，それは、 Web の制約下において，ちょうど，スクリプトに生の TCP を露出させるに近いものが意図されている。
また、そのハンドシェイクを妥当な HTTP Upgrade リクエストに仕立て上げることにより，
サーバがポートを HTTP サーバと共有できるようにも設計されている。
クライアント↔サーバ間のメッセージングの確立に他のプロトコルを利用することも考えられるが、 WebSocket の意図は、 HTTP や（プロキシなどの）現存の HTTP 通信基盤と共存できるような，それらの通信基盤との併用下において セキュリティ面で TCP に近い安全さを備えつつ、利用法を単純化して，単純な事を単純なままに保つことも念頭に（メッセージ意味論の追加など）、比較的単純なプロトコルを提供する所にある。<!--  -->
<span lang="en">
Other than that, WebSocket adds nothing. Basically it is intended to be as close to just exposing raw TCP to script as possible given the constraints of the Web. It's also designed in such a way that its servers can share a port with HTTP servers, by having its handshake be a valid HTTP Upgrade request. One could conceptually use other protocols to establish client-server messaging, but the intent of WebSockets is to provide a relatively simple protocol that can coexist with HTTP and deployed HTTP infrastructure (such as proxies) and that is as close to TCP as is safe for use with such infrastructure given security considerations, with targeted additions to simplify usage and keep simple things simple (such as the addition of message semantics).
</span></p>

<p>
プロトコルは，拡張可能なように意図されている。
将来のバージョンでは、おそらく，多重化などの追加の概念も導入されることになるものと見込まれている。
<span lang="en">
The protocol is intended to be extensible; future versions will likely introduce additional concepts such as multiplexing.
</span></p>

	</section>
	<section id="section-1.6">

<h3 title="Security Model">1.6. セキュリティ­モデル</h3>

<p>
<em>この節は参考である。</em>
<span lang="en">
_This section is non-normative._
</span></p>

<p>
WebSocket Protocol がウェブ­ページから利用される際に， WebSocket サーバに接触できるウェブ­ページを制約するため、 WebSocket Protocol では，ウェブ­ブラウザ間で利用されている生成元（ origin ）モデルが採用されている。
当然， WebSocket Protocol が専用のクライアントから直接的に利用される場合（すなわち，ウェブ­ブラウザを通したウェブ­ページからではなく）、クライアントは任意の生成元­文字列を提供できるので，生成元モデルは有用なものにならない。
<span lang="en">
The WebSocket Protocol uses the origin model used by web browsers to restrict which web pages can contact a WebSocket server when the WebSocket Protocol is used from a web page. Naturally, when the WebSocket Protocol is used by a dedicated client directly (i.e., not from a web page through a web browser), the origin model is not useful, as the client can provide any arbitrary origin string.
</span></p>

<p>
このプロトコルは、必要ならば HTTP サーバがこのプロトコルをオプトインでサポートできるようにしつつ、
SMTP <a>[RFC5321]</a> や HTTP のような現存のプロトコルのサーバとの接続の確立は，失敗するように意図されている。
これは、ハンドシェイクを厳格かつ精巧にして，ハンドシェイクの完成まで 接続に挿入できるデータを制限することにより（したがってサーバへの波及も制限される）、達成される。
<span lang="en">
This protocol is intended to fail to establish a connection with servers of pre-existing protocols like SMTP [RFC5321] and HTTP, while allowing HTTP servers to opt-in to supporting this protocol if desired. This is achieved by having a strict and elaborate handshake and by limiting the data that can be inserted into the connection before the handshake is finished (thus limiting how much the server can be influenced).
</span></p>

<p>
同様に、他のプロトコル，特に HTTP から WebSocket サーバに向けてデータが送信される際にも、接続の確立が失敗するように意図されている。
例えば，あり得そうなものとして、 HTML の “フォーム” が WebSocket サーバに submit された場合など。
これは主に、サーバに対し，ハンドシェイクを読み取った事実の立証を要求することにより、達成される。
すなわち，サーバからのハンドシェイクは、 WebSocket クライアントによってのみ送信され得る適切な要素†を含んでいる場合にのみ可能になるようにされている。
特に，この仕様が書かれた時点においては、攻撃者は， HTML と XMLHttpRequest
<a>[XMLHttpRequest]</a> 
などの JavaScript API のみを利用するウェブ­ブラウザからは， <b>Sec-</b> で始まるヘッダを設定し得ない。
<span lang="en">
It is similarly intended to fail to establish a connection when data from other protocols, especially HTTP, is sent to a WebSocket server, for example, as might happen if an HTML "form" were submitted to a WebSocket server. This is primarily achieved by requiring that the server prove that it read the handshake, which it can only do if the handshake contains the appropriate parts, which can only be sent by a WebSocket client. In particular, at the time of writing of this specification, fields starting with |Sec-| cannot be set by an attacker from a web browser using only HTML and JavaScript APIs such as XMLHttpRequest [XMLHttpRequest].
</span></p>

<p class="trans-note">【†
要素 — おそらく、プロトコル要素（
<a href="http://tools.ietf.org/html/rfc6365#section-6">RFC6365, 6 節</a>
）を指す。
他所の一部の “要素” も同様。
】</p>

	</section>
	<section id="section-1.7">

<h3 title="Relationship to TCP and HTTP">1.7. TCP および HTTP との関係</h3>

<p>
<em>この節は参考である。</em>
<span lang="en">
_This section is non-normative._
</span></p>

<p>
WebSocket Protocol は、 TCP に基づく，独立のプロトコルである。
その HTTP との関係は、そのハンドシェイクが HTTP サーバからは Upgrade リクエストとして解釈される点のみに限られている。
<span lang="en">
The WebSocket Protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.
</span></p>

<p>
WebSocket Protocol の既定においては、通常の WebSocket 接続にはポート 80 が利用され， TLS （ Transport Layer Security ） <a>[RFC2818]</a> を通してトンネルされた WebSocket 接続にはポート 443 が利用される。
<span lang="en">
By default, the WebSocket Protocol uses port 80 for regular WebSocket connections and port 443 for WebSocket connections tunneled over Transport Layer Security (TLS) [RFC2818].
</span></p>


	</section>
	<section id="section-1.8">

<h3 title="Establishing a Connection">1.8. 接続の確立</h3>

<p>
<em>この節は参考である。</em>
<span lang="en">
_This section is non-normative._
</span></p>

<p>
HTTP サーバと共有されているポートに接続が設けられる際は（ポート 80 と 443 へのトラフィックではごく普通に生じ得る状況）、その接続は， HTTP サーバからは Upgrade offer を伴う通常の GET リクエストに見えることになる。
IP アドレスが１個だけで, すべてのトラフィックが単独のホスト名の単独のサーバと行き交うような，比較的単純な配置においては、これは，配備されることになる WebSocket Protocol に基づくシステムにとり, 実用的なやり方になり得る。
より精巧な（例えば，負荷分散装置や複数のサーバを伴う）配置においては、
HTTP サーバから分離された， WebSocket 接続のための専用のホストの組み合わせの方が、おそらく管理し易いものになる。
この仕様が書かれた時点では、ポート 80 上と 443 上では接続の成功率が大きく異なっていて，ポート 443 の方がずっと高いことは記しておくべきだが、これは，時の経過に伴い変わり得るものでもある。
<span lang="en">
When a connection is to be made to a port that is shared by an HTTP server (a situation that is quite likely to occur with traffic to ports 80 and 443), the connection will appear to the HTTP server to be a regular GET request with an Upgrade offer. In relatively simple setups with just one IP address and a single server for all traffic to a single hostname, this might allow a practical way for systems based on the WebSocket Protocol to be deployed. In more elaborate setups (e.g., with load balancers and multiple servers), a dedicated set of hosts for WebSocket connections separate from the HTTP servers is probably easier to manage. At the time of writing of this specification, it should be noted that connections on ports 80 and 443 have significantly different success rates, with connections on port 443 being significantly more likely to succeed, though this may change with time.
</span></p>

	</section>
	<section id="section-1.9">

<h3 title="Subprotocols Using the WebSocket Protocol">1.9. WebSocket プロトコルを利用する下位プロトコル</h3>

<p>
<em>この節は参考である。</em>
<span lang="en">
_This section is non-normative._
</span></p>

<p>
クライアントは、ハンドシェイクの中に
<b>Sec-WebSocket-Protocol</b> ヘッダを内包することにより，サーバに対し, 特定の下位プロトコルの利用をリクエストできる。
指定された場合，接続が確立されるためには、サーバは，その応答において，同じ名前のヘッダに, クライアントが選択した下位プロトコル値のいずれか一つを内包する必要がある。
<span lang="en">
The client can request that the server use a specific subprotocol by including the |Sec-WebSocket-Protocol| field in its handshake. If it is specified, the server needs to include the same field and one of the selected subprotocol values in its response for the connection to be established.
</span></p>

<p>
これらの下位プロトコル名は、 <a>11.5 節</a> に従って登録されるべきである。
衝突の可能性を回避するため、下位プロトコルの考案者のドメイン名の ASCII バージョンを含む名前の利用が推奨される。
例えば、ある団体が Web に散在する多数のサーバへの実装が予期される Chat 下位プロトコルを作成して，それが
"<samp>chat.example.com</samp>"
と命名されたとして、別の組織が，競合する下位プロトコルを
"<samp>chat.example.org</samp>"
と命名していた場合、その２つの下位プロトコルは、サーバにおいて利用する下位プロトコルを，クライアントから送信される値に基づいて 動的に選択する形をとることにより、同時に実装され得るものになる。
<span lang="en">
These subprotocol names should be registered as per Section 11.5. To avoid potential collisions, it is recommended to use names that contain the ASCII version of the domain name of the subprotocol's originator. For example, if Example Corporation were to create a Chat subprotocol to be implemented by many servers around the Web, they could name it "chat.example.com". If the Example Organization called their competing subprotocol "chat.example.org", then the two subprotocols could be implemented by servers simultaneously, with the server dynamically selecting which subprotocol to use based on the value sent by the client.
</span></p>

<p>
下位プロトコルは、その名前を変更することにより，後方互換性を保たない形でバージョン付けできる。
例えば
"<samp>bookings.example.net</samp>"
から
"<samp>v2.bookings.example.net</samp>"
へ，等々。
これらの下位プロトコルは完全に別々の WebSocket クライアントと見なされることになる。
後方互換性を保つバージョン付けは、同じ下位プロトコル文字列を再利用して，この種の拡張性をサポートするように, 実際の下位プロトコルを注意深く設計することにより、実装できる。
<span lang="en">
Subprotocols can be versioned in backward-incompatible ways by changing the subprotocol name, e.g., going from "bookings.example.net" to "v2.bookings.example.net". These subprotocols would be considered completely separate by WebSocket clients. Backward-compatible versioning can be implemented by reusing the same subprotocol string but carefully designing the actual subprotocol to support this kind of extensibility.
</span></p>

	</section>
</section>
<section id="section-2">

<h2 title="Conformance Requirements">2. 適合性の要件</h2>

<p>
“参考” と明示的に記された節に加えて，この仕様­内のすべての 図式, 例, 注記 は規定ではない。
他のすべては規定である。
<span lang="en">
All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
</span></p>

<p>
この文書におけるキーワード：
「〜しなければ（〜しては）<em class="rfc2119">ならない</em>」 = “MUST (NOT)”,
「<em class="rfc2119">要求される</em>」= REQUIRED,
「〜する<em class="rfc2119">べき</em>である（でない）」 = “SHOULD (NOT)”,
「<em class="rfc2119" title="recommended">推奨される</em>」 = “RECOMMENDED”,
「〜しても<em class="rfc2119">よい</em>」 = “MAY”,
「<em class="rfc2119" title="optional">任意選択</em>」 = “OPTIONAL”,
は、 <a>[RFC2119]</a> に則って解釈されるものとする。
<span lang="en">
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
</span></p>

<p>
アルゴリズムの中の命令的言い回しによる要件（例えば “先頭部のスペース文字並びを取り除く” ,  “ false を返してこの手続きを中止する” など）は、アルゴリズムを引用する際に利用されているキーワード（「〜しなければ<em class="rfc2119">ならない</em>」, 「〜する<em class="rfc2119">べき</em>」, 「〜しても<em class="rfc2119">よい</em>」, 等々）の意味の下に解釈されることになる。
<!-- （"MUST", " SHOULD", " MAY"） -->
<span lang="en">
Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("MUST", "SHOULD", "MAY", etc.) used in introducing the algorithm.
</span></p>

<p>
アルゴリズムまたは特定の手続きとして記される適合性の要件は、最終的な結果が等価になるのであれば，どのように実装されてもよい。
（特に、この仕様で定義されるアルゴリズムは追い易くなるように記述されており，パフォーマンスは考慮されていない。）
<span lang="en">
Conformance requirements phrased as algorithms or specific steps MAY be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow and not intended to be performant.)
</span></p>

		<section id="section-2.1">

<h3 title="Terminology and Other Conventions">2.1. 各種用語とその他の表記規約</h3>

<p>
<dfn class="term-def" id="dfn-ascii">ASCII</dfn>
は
<a>[ANSI.X3-4.1986]</a>
で定義される文字符号化スキームとする。
<span lang="en">
_ASCII_ shall mean the character-encoding scheme defined in [ANSI.X3-4.1986].
</span></p>

<p>
この文書は、STD 63 <a>[RFC3629]</a> で定義される， UTF-8 値と UTF-8 表記­形式を参照する。
<span lang="en">
This document makes reference to UTF-8 values and uses UTF-8 notational formats as defined in STD 63 [RFC3629].
</span></p>


<p>
次のスタイルが用いられる：
<span class="trans-note">【
原文は素のテキストなので、 “文字によるマークアップ” が施されている。
】</span>
</p>

<ul>
	<li>
名前の付いたアルゴリズムや定義のような主要な語句は、
<dfn class="term-def" id="sample-def">語句（定義）</dfn>,
または
<a class="dfnref" href="#sample-def">語句（リンク）</a>
のように示される。
<span lang="en">
Key terms such as named algorithms or definitions are indicated like _this_.
</span></li>

	<li>
ヘッダ名は、
<b>Sample-Header-Field</b> のように示される。
<span class="trans-note">【
この訳の中の語 “ヘッダ” は、ほぼすべて， “header field” の略記である（原文の “header field” の略語 “field” の対訳も “ヘッダ” に統一している）。
】</span>
<span lang="en">
Names of header fields or variables are indicated like |this|.
</span></li>

	<li>
変数（または その値）は、
<var>variable</var>
のように示される。
<span lang="en">
Variable values are indicated like /this/.
</span></li>
</ul>

<p>
この文書は、
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させる</a>
手続きを参照する。
その手続きは <a>7.1.7 節</a> にて定義される。
<span lang="en">
This document references the procedure to _Fail the WebSocket Connection_. This procedure is defined in Section 7.1.7.
</span></p>

<p>
文字列の
<dfn class="term-def" id="dfn-to-lowercase">ASCII 小文字化</dfn>
とは、
U+0041 〜 U+005A （ LATIN CAPITAL LETTER A 〜 LATIN CAPITAL LETTER Z ）の範囲のすべての文字を対応する
U+0061 〜 U+007A （ LATIN SMALL LETTER A 〜 LATIN SMALL LETTER Z ）の範囲の文字に置換することを意味する。
<span lang="en">
_Converting a string to ASCII lowercase_ means replacing all characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL LETTER Z).
</span></p>

<p>
２つの文字列の
<dfn class="term-def" id="dfn-case-insensitive">ASCII 文字大小無視による比較</dfn>
とは、 U+0041 〜 U+005A （すなわち LATIN CAPITAL LETTER A 〜 LATIN CAPITAL LETTER Z ）の範囲の文字と対応する U+0061 〜 U+007A （すなわち LATIN SMALL LETTER A 〜 LATIN SMALL LETTER Z ）の範囲の文字は同一視することを除き，それぞれの文字の符号位置ごとに厳密な比較を行うことを意味する。 
<span lang="en">
Comparing two strings in an _ASCII case-insensitive_ manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.
</span></p>

<p>
この文書の用語 "URI" は <a>[RFC3986]</a> にて定義される。
<span lang="en">
The term "URI" is used in this document as defined in [RFC3986].
</span></p>

<p>
実装が WebSocket Protocol の一部として，データを
<a class="dfnref" href="#dfn-to-send"> 送信する</a>
必要が生じた際は、実際の伝送を任意に遅延させても<em class="rfc2119">よい</em>。
例えば，より少数の IP パケットで送信するために データをバッファするなど。
<span lang="en">
When an implementation is required to _send_ data as part of the WebSocket Protocol, the implementation MAY delay the actual transmission arbitrarily, e.g., buffering data so as to send fewer IP packets.
</span></p>

<p>
この文書は、節に応じて， <a>[RFC5234]</a> と <a>[RFC2616]</a> の ABNF 変種のいずれも利用することに注意。
<span lang="en">
Note that this document uses both [RFC5234] and [RFC2616] variants of ABNF in different sections.
</span></p>

		</section>
	</section>


<section id="section-3">

<h2 title="WebSocket URIs">3. WebSocket URI</h2>

<p>
この仕様は、 <a>[RFC5234]</a> にて定義される ABNF 構文，および
URI 仕様 <a>[RFC3986]</a> にて定義される用語と ABNF 生成規則を用いて，２つの URI スキームを定義する。
<span lang="en">
This specification defines two URI schemes, using the ABNF syntax defined in RFC 5234 [RFC5234], and terminology and ABNF productions defined by the URI specification RFC 3986 [RFC3986].
</span></p>


<pre class="ABNF">
ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]
wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]

host = &lt;host, <a>[RFC3986]</a> <a href="./rfc3986#section-3.2.2">3.2.2 節</a>の定義による&gt;

port = &lt;port, <a>[RFC3986]</a> <a href="./rfc3986#section-3.2.3">3.2.3 節</a>の定義による&gt;
path = &lt;path-abempty, <a>[RFC3986]</a> <a href="./rfc3986#section-3.3">3.3 節</a>の定義による&gt;
query = &lt;query, <a>[RFC3986]</a> <a href="./rfc3986#section-3.4">3.4 節</a>の定義による&gt;
</pre>

<!-- 
<pre>
ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]
wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]

host = &lt;host, defined in <a href="./rfc3986#section-3.2.2">[RFC3986], Section&nbsp;3.2.2</a>&gt;

port = &lt;port, defined in <a href="./rfc3986#section-3.2.3">[RFC3986], Section&nbsp;3.2.3</a>&gt;
path = &lt;path-abempty, defined in <a href="./rfc3986#section-3.3">[RFC3986], Section&nbsp;3.3</a>&gt;
query = &lt;query, defined in <a href="./rfc3986#section-3.4">[RFC3986], Section&nbsp;3.4</a>&gt;
</pre>
-->

<p>
<code class="ABNF">port</code> 成分は<em class="rfc2119">任意選択</em>である。
"<code>ws</code>" に対する既定のポート番号は 80 であり，
"<code>wss</code>" に対する既定のポート番号は 443 である。
<span lang="en">
The port component is OPTIONAL; the default for "ws" is port 80, while the default for "wss" is port 443.
</span></p>

<p>
URI は、スキーム成分が "<code>wss</code>" に文字大小無視で合致するとき， “セキュア” と呼ばれる（ “セキュア­フラグがセットされた” と呼ばれる）。
<span lang="en">
The URI is called "secure" (and it is said that "the secure flag is set") if the scheme component matches "wss" case-insensitively.
</span></p>

<p>
 “リソース名” （ <a>4.1 節</a> の <var>resource name</var> ）は、次を連結したものから構築できる：
<span lang="en">
The "resource-name" (also known as /resource name/ in Section 4.1) can be constructed by concatenating the following:
</span></p>

<ul>
	<li>
<code class="ABNF">path</code> 成分が［
空でなければ <code class="ABNF">path</code> 成分 ／
空の場合は "<code>/</code>"
］
<span lang="en">
"/" if the path component is empty
</span>
<span lang="en">
the path component
</span></li>

	<li>
<code class="ABNF">query</code> 成分が［
空でなければ［
"<code>?</code>",
<code class="ABNF">query</code> 成分
］の並び ／
空の場合は空文字列
］
<span lang="en">
"?" if the query component is non-empty
</span>
<span lang="en">
the query component
</span></li>
</ul>

<p>
WebSocket URI の文脈においては、素片­識別子は無意味であり，これらの URI に利用されては<em class="rfc2119">ならない</em>。
他の URI スキーム同様、素片の開始を指示しない文字 "<code>#</code>" は <code>%23</code> にエスケープされなければ<em class="rfc2119">ならない</em>。
<span lang="en">
Fragment identifiers are meaningless in the context of WebSocket URIs and MUST NOT be used on these URIs. As with any URI scheme, the character "#", when not indicating the start of a fragment, MUST be escaped as %23.
</span></p>

</section>
<section id="section-4">

<h2 title="Opening Handshake">4. opening ハンドシェイク</h2>

	<section id="section-4.1">

<h3 title="Client Requirements">4.1. クライアントに課される要件</h3>

<div class="p">
<p>
<a class="dfnref" href="#dfn-to-establish">WebSocket 接続を確立する</a>
ためには、この節で定義されるように，クライアントは、接続を open してハンドシェイクを送信する。
接続は、初期­時には
<dfn class="term-def" id="dfn-CONNECTING-state">CONNECTING 状態</dfn>
にあるものと定義される。

クライアントは、接続を open するにあたって，次のものを入力に供する必要がある：
</p>

<ul>
	<li>
<a>3 節</a> にて述べた， WebSocket URI の成分
<var>host</var>, <var>port</var>, <var>resource name</var>, 
および <var>secure</var> フラグ
</li>
	<li>
利用する
下位プロトコルのリスト <var>protocols</var>, および
拡張のリスト <var>extensions</var>
</li>
	<li>
<var>origin</var> （クライアントがウェブ­ブラウザの場合）。
</li>
</ul>


<span lang="en">
To _Establish a WebSocket Connection_, a client opens a connection and sends a handshake as defined in this section. A connection is defined to initially be in a CONNECTING state. A client will need to supply a /host/, /port/, /resource name/, and a /secure/ flag, which are the components of a WebSocket URI as discussed in Section 3, along with a list of /protocols/ and /extensions/ to be used. Additionally, if the client is a web browser, it supplies /origin/.
</span>

</div>

<p>
制御環境下で稼働しているクライアント，例えば，特定のキャリアに拘束された携帯電話機上のブラウザでは、接続の管理をネットワーク上の他のエージェントに負荷委譲しても<em class="rfc2119">よい</em>。
その種の状況におけるクライアントは、この仕様の目的においては，その携帯機ソフトウェアとその種の任意のエージェントの両方を内包するものと見なされる。
<span lang="en">
Clients running in controlled environments, e.g., browsers on mobile handsets tied to specific carriers, MAY offload the management of the connection to another agent on the network. In such a situation, the client for the purposes of this specification is considered to include both the handset software and any such agents.
</span></p>

<p>
クライアントは、上述の入力の下に，
<dfn class="term-def" id="dfn-to-establish">WebSocket 接続を確立する</dfn>
ときは、接続を open し, opening ハンドシェイクを送信し,
サーバからのハンドシェイク応答を読み取らなければ<em class="rfc2119">ならない</em>。
接続がどのように open されるべきで,
opening ハンドシェイクにおいて何が送信されるべきで,
サーバからの応答がどのように解釈されるべきか，についての正確な要件は、この節の以下の部分で述べる。
以下のテキストにおける， "<var>host</var>" や "<var>secure</var> フラグ" などの <a>3 節</a> の語は、その節の定義に従うものとして用いられる。
<span lang="en">
When the client is to _Establish a WebSocket Connection_ given a set of (/host/, /port/, /resource name/, and /secure/ flag), along with a list of /protocols/ and /extensions/ to be used, and an /origin/ in the case of web browsers, it MUST open a connection, send an opening handshake, and read the server's handshake in response. The exact requirements of how the connection should be opened, what should be sent in the opening handshake, and how the server's response should be interpreted are as follows in this section. In the following text, we will use terms from Section 3, such as "/host/" and "/secure/ flag" as defined in that section.
</span></p>

<ol>
<!-- 1 -->
	<li>
このアルゴリズムに渡される WebSocket URI の成分
( <var>host</var>, <var>port</var>, <var>resource-name</var>, <var>secure</var> フラグ )
は、 <a>3 節</a> にて指定される WebSocket URI の仕様に従って妥当でなければ<em class="rfc2119">ならない</em>。
成分のどれか一つでも妥当でない場合、クライアントは，
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させて</a>,
この手続きを中止しなければ<em class="rfc2119">ならない</em>。
<span class="trans-note">【
<a href="http://www.rfc-editor.org/errata_search.php?rfc=6455&amp;eid=4398">正誤表</a>による追記あり（ Held for Document Update ）。
<var>secure</var> フラグが false の場合の  Mixed Content に関する取り扱いについて述べている。
】</span>
<span lang="en">
The components of the WebSocket URI passed into this algorithm (/host/, /port/, /resource name/, and /secure/ flag) MUST be valid according to the specification of WebSocket URIs specified in Section 3. If any of the components are invalid, the client MUST _Fail the WebSocket Connection_ and abort these steps.
</span></li>

<!-- 2 -->
	<li>
<p>
<del >ホスト <var>host</var> とポート <var>port</var> の組で識別されるリモート­ホスト（ IP アドレス）</del>
<ins >同じ［ IP アドレスとポートの組］</ins>
への WebSocket 接続がすでにある場合、
クライアントは、そのリモート­ホストが別の名前として既知であるとしても，その接続が確立されるか, または その接続が失敗するまで，待機しなければ<em class="rfc2119">ならない</em>。
<ins>どの一つの［ IP アドレスとポートの組］に対しても</ins>，
<a href="#dfn-CONNECTING-state">CONNECTING 状態</a> にある接続が同時に複数存在しては<em class="rfc2119">ならない</em>。
同じ IP アドレス<ins >とポートの組</ins>に対し，複数の接続が同時に試みられている場合、クライアントは、以下の手続きを実行している間，複数の接続が存在しないように, それらを直列化しなければ<em class="rfc2119">ならない</em>。
<span class="trans-note">【<a href="http://www.rfc-editor.org/errata_search.php?rfc=6455">正誤表</a>による修正（ Verified ）】</span>
<span lang="en">
<!-- 
If the client already has a WebSocket connection to the remote host (IP address) identified by /host/ and port /port/ pair, even if the remote host is known by another name, the client MUST wait until that connection has been established or for that connection to have failed. There MUST be no more than one connection in a CONNECTING state. If multiple connections to the same IP address are attempted simultaneously, the client MUST serialize them so that there is no more than one connection at a time running through the following steps.
-->
If the client already has a WebSocket connection to the
<del >remote host (IP address) identified by /host/ and port /port/ pair</del>
<ins >same IP address and port pair</ins>,
even if the remote host is known by another name, the client MUST wait until that connection has been established or for that connection to have failed. There MUST be no more than one connection in
<del >a CONNECTING state</del>
<ins >the CONNECTING state for any IP address and port pair</ins>.
If multiple connections to the same IP address
<ins >and port pair</ins>
are attempted simultaneously, the client MUST serialize them so that there is no more than one connection at a time running through the following steps.
</span></p>

<p>
クライアントがリモート­ホストの IP アドレスを決定できない場合（例えば，すべての通信が DNS クエリ自体を行うプロキシ­サーバを通して行われるために）、クライアントは，この段の目的においては 各ホスト名が別個のリモート­ホストを参照しているものと見なさなければ<em class="rfc2119">ならず</em>，代わりに 同時の接続待ち<!--1-->の総数を適度に低い数に制限する<em class="rfc2119">べき</em>である（例えば，クライアントが <samp>a.example.com</samp> と <samp>b.example.com</samp> への同時の接続待ち<!--1-->を許容し得るとしても，単独のホストに対し 30 個の同時­接続がリクエストされた場合、許容されなくなり得る）。
例えば，ウェブ­ブラウザ文脈の下では、クライアントは、同時の接続待ち<!--1-->数を制限するにあたり，利用者が開いているタブウィンドウ数を考慮に入れる必要がある。
<span lang="en">
If the client cannot determine the IP address of the remote host (for example, because all communication is being done through a proxy server that performs DNS queries itself), then the client MUST assume for the purposes of this step that each host name refers to a distinct remote host, and instead the client SHOULD limit the total number of simultaneous pending connections to a reasonably low number (e.g., the client might allow simultaneous pending connections to a.example.com and b.example.com, but if thirty simultaneous connections to a single host are requested, that may not be allowed). For example, in a web browser context, the client needs to consider the number of tabs the user has open in setting a limit to the number of simultaneous pending connections.
</span></p>

<p class="note">注記：
これにより、単にリモート­ホストへ向けて多数の WebSocket 接続を open するような，スクリプトによる DoS 攻撃（ denial-of-service attack ）は、より困難になる。
更に、サーバは，攻撃された際には、接続の closing 前に一時停止して, クライアントによる再接続の頻度を抑制することにより，自身の負荷を軽減できる。
<span lang="en">
NOTE: This makes it harder for a script to perform a denial-of-service attack by just opening a large number of WebSocket connections to a remote host. A server can further reduce the load on itself when attacked by pausing before closing the connection, as that will reduce the rate at which the client reconnects.
</span></p>

<p class="note">注記：
クライアントが単独のリモート­ホスト向けて確立できる WebSocket 接続の総数に，制限はない。
サーバは、すでに接続­数が過度にあるホスト／IP アドレスからの接続の受理を拒んだり，あるいは
高­負荷を被った際には, リソースを浪費している接続を切断<!--0-->できる。
<span lang="en">
NOTE: There is no limit to the number of established WebSocket connections a client can have with a single remote host. Servers can refuse to accept connections from hosts/IP addresses with an excessive number of existing connections or disconnect resource-hogging connections when suffering high load.
</span></p>

	</li>
<!-- 3 -->
	<li>
<p>
<dfn class="term-def" id="dfn-proxy-usage"> プロキシの用法</dfn>：
クライアントは、［
WebSocket Protocol を利用して
ホスト <var>host</var>, ポート <var>port</var> に接続する際に，プロキシを利用するように設定されている
］場合には、そのプロキシに接続して，
ホスト <var>host</var>, ポート <var>port</var>
に向けて, TCP 接続を open する旨を求める<em class="rfc2119">べき</em>である。
<!--  -->
<span lang="en">
_Proxy Usage_: If the client is configured to use a proxy when using the WebSocket Protocol to connect to host /host/ and port /port/, then the client SHOULD connect to that proxy and ask it to open a TCP connection to the host given by /host/ and the port given by /port/.
</span></p>

<div class="example">

<p>例：
例えば，クライアントが、すべてのトラフィックに HTTP プロキシを利用していて，サーバ <samp>example.com</samp> のポート 80 への接続を試行している場合、次の行をプロキシ­サーバに送信することになるだろう：
<span lang="en">
EXAMPLE: For example, if the client uses an HTTP proxy for all traffic, then if it was to try to connect to port 80 on server example.com, it might send the following lines to the proxy server:
</span></p>

<pre class="example">
CONNECT example.com:80 HTTP/1.1
Host: example.com
</pre>

<p>
パスワードがある場合の接続は次のようになるだろう：
<span lang="en">
If there was a password, the connection might look like:
</span></p>

<pre class="example">
CONNECT example.com:80 HTTP/1.1
Host: example.com
Proxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=
</pre>

</div>

<p>
クライアントがプロキシを利用するように設定されていない場合、
ホスト <var>host</var>, ポート <var>port</var>
に向けて，直接の TCP 接続が open される<em class="rfc2119">べき</em>である。
<span lang="en">
If the client is not configured to use a proxy, then a direct TCP connection SHOULD be opened to the host given by /host/ and the port given by /port/.
</span></p>

<p class="note">注記：
WebSocket 接続のためのプロキシを他のプロキシとは別に選択するための，明示的な UI を供さない実装は、可用であれば， SOCKS5 <a>[RFC1928]</a> プロキシを WebSocket 接続に利用することが奨励される。
それができない場合、
HTTP 接続­用に設定されたプロキシを通して，
HTTPS 接続­用に設定されたプロキシを利用することが望ましい。
<span lang="en">
NOTE: Implementations that do not expose explicit UI for selecting a proxy for WebSocket connections separate from other proxies are encouraged to use a SOCKS5 [RFC1928] proxy for WebSocket connections, if available, or failing that, to prefer the proxy configured for HTTPS connections over the proxy configured for HTTP connections.
</span></p>

<p>
プロキシ自動設定スクリプトのために渡される URI は、
<a>3 節</a> の WebSocket URI の定義に従って，
<var>host</var>, <var>port</var>, <var>resource-name</var>, <var>secure</var> フラグ
から構築されていなければ<em class="rfc2119">ならない</em>。
<span lang="en">
For the purpose of proxy autoconfiguration scripts, the URI to pass the function MUST be constructed from /host/, /port/, /resource name/, and the /secure/ flag using the definition of a WebSocket URI as given in Section 3.
</span></p>

<p class="note">注記：
プロキシ自動設定スクリプトにおいては、 WebSocket Protocol であるかどうかは，スキームから判別できる（暗号化されていない接続に対しては "<code>ws</code>", 暗号化された接続に対しては "<code>wss</code>" ）
<span lang="en">
NOTE: The WebSocket Protocol can be identified in proxy autoconfiguration scripts from the scheme ("ws" for unencrypted connections and "wss" for encrypted connections).
</span></p>

	</li>
<!-- 4 -->
	<li>
直接­接続が失敗した, あるいは利用しているプロキシがエラーを返したなどの理由で，接続を open できなかった場合、クライアントは，
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させて</a>,
接続の試みを中止しなければ<em class="rfc2119">ならない</em>。
<span lang="en">
If the connection could not be opened, either because a direct connection failed or because any proxy used returned an error, then the client MUST _Fail the WebSocket Connection_ and abort the connection attempt.
</span></li>
<!-- 5 -->
	<li>
<p>
<var>secure</var> が true の場合、クライアントは、接続を open した後, ハンドシェイク­データ <a>[RFC2818]</a> を送信する前までに，接続を通して TLS ハンドシェイクを行わなければ<em class="rfc2119">ならない</em>。
これが失敗した場合（例えば，サーバの証明書を検証できなかったとき）、クライアントは、
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させて</a>,
接続を中止しなければ<em class="rfc2119">ならない</em>。
他の場合、このチャンネル上の以降の通信はすべて，暗号化されたトンネル <a>[RFC5246]</a> を通して実行されなければ<em class="rfc2119">ならない</em>。
<span lang="en">
If /secure/ is true, the client MUST perform a TLS handshake over the connection after opening the connection and before sending the handshake data [RFC2818]. If this fails (e.g., the server's certificate could not be verified), then the client MUST _Fail the WebSocket Connection_ and abort the connection. Otherwise, all further communication on this channel MUST run through the encrypted tunnel [RFC5246].
</span></p>

<p>
クライアントは、 TLS ハンドシェイクの Server Name Indication 拡張 <a>[RFC6066]</a> を利用しなければ<em class="rfc2119">ならない</em>。
<span lang="en">
Clients MUST use the Server Name Indication extension in the TLS handshake [RFC6066].
</span></p>
	</li>
</ol>

<p>
サーバへの接続がいったん確立されたなら（プロキシ経由の, または TLS 暗号化トンネルを通した接続も含め）、クライアントは，サーバへ向けて opening ハンドシェイクを送信しなければ<em class="rfc2119">ならない</em>。
ハンドシェイクは、必須の, およびオプションのヘッダのリストを伴う，
HTTP Upgrade リクエストからなる。
このハンドシェイクには次に挙げる要件が課される。
<span lang="en">
Once a connection to the server has been established (including a connection via a proxy or over a TLS-encrypted tunnel), the client MUST send an opening handshake to the server. The handshake consists of an HTTP Upgrade request, along with a list of required and optional header fields. The requirements for this handshake are as follows.
</span></p>

<ol>
<!-- 1 -->
	<li>
ハンドシェイクは <a>[RFC2616]</a> の指定に従って 妥当な HTTP リクエストでなければ<em class="rfc2119">ならない</em>。
<span lang="en">
The handshake MUST be a valid HTTP request as specified by [RFC2616].
</span></li>
<!-- 2 -->
	<li>
<p>
リクエストのメソッドは GET であって, かつ
HTTP バージョンは 1.1 以上
でなければ<em class="rfc2119">ならない</em>。
<span lang="en">
The method of the request MUST be GET, and the HTTP version MUST be at least 1.1.
</span></p>

<p class="example">
例えば， WebSocket URI が <samp>"ws://example.com/chat"</samp> ならば、送信される最初の行は <samp>"GET /chat HTTP/1.1"</samp> になっているべきである。
<span lang="en">
For example, if the WebSocket URI is "ws://example.com/chat", the first line sent should be "GET /chat HTTP/1.1".
</span></p>

	</li>
<!-- 3 -->
	<li>
リクエストの "Request-URI" の部分は、<a>3 節</a> で定義される <var>resource-name</var> （相対 URI ）に合致するか，または
構文解析された際に対応する ws／wss URI に合致する
<var>resource-name</var>, <var>host</var>, <var>port</var> 
を持つような 絶対 http／https URI に合致しなければ<em class="rfc2119">ならない</em>。
<span lang="en">
The "Request-URI" part of the request MUST match the /resource name/ defined in Section 3 (a relative URI) or be an absolute http/https URI that, when parsed, has a /resource name/, /host/, and /port/ that match the corresponding ws/wss URI.
</span></li>

<!-- 4 -->
	<li>
リクエストは、［
オプションで（あるいは，既定のポートを利用しない場合は）［ "<code>:</code>", <var>port</var> ］が後続する， <var>host</var>
］を値にとる <b>Host</b> ヘッダを含んでいなければ<em class="rfc2119">ならない</em>
<span lang="en">
The request MUST contain a |Host| header field whose value contains /host/ plus optionally ":" followed by /port/ (when not using the default port).
</span></li>

<!-- 5 -->
	<li>
リクエストは
<b>Upgrade</b> ヘッダを含んでいて, かつ
その値はキーワード "<code>websocket</code>" を内包していなければ<em class="rfc2119">ならない</em>
<span lang="en">
The request MUST contain an |Upgrade| header field whose value MUST include the "websocket" keyword.
</span></li>


<!-- 6 -->
	<li>
リクエストは
<b>Connection</b> ヘッダを含んでいて, かつ
その値は "<code>Upgrade</code>" トークンを内包していなければ<em class="rfc2119">ならない</em>。
<span lang="en">
The request MUST contain a |Connection| header field whose value MUST include the "Upgrade" token.
</span></li>

<!-- 7 -->
	<li>
<p>
リクエストは
<b>Sec-WebSocket-Key</b> ヘッダを内包していて, かつ
その値は、無作為に選ばれた 16 バイト値を base64 符号化した nonce でなければ<em class="rfc2119">ならない</em>（
<a>[RFC4648]</a> <a href="./rfc4648#section-4">4 節</a>
を見よ）。
nonce は、それぞれの接続ごとに，無作為に選ばれなければ<em class="rfc2119">ならない</em>。
<span class="trans-note">【 nonce ：一度限りのもの（ “number used once” ）】</span>
<span lang="en">
The request MUST include a header field with the name |Sec-WebSocket-Key|. The value of this header field MUST be a nonce consisting of a randomly selected 16-byte value that has been base64-encoded (see Section 4 of [RFC4648]). The nonce MUST be selected randomly for each connection.
</span></p>

<p class="note">注記：
例えば，無作為に選ばれた値がバイトの並び
<samp>0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10</samp>
であった場合、ヘッダの値は
<del>"<samp >AQIDBAUGBwgJCgsMDQ4PEC==</samp>"</del>
<ins>"<samp>AQIDBAUGBwgJCgsMDQ4PEA==</samp>"</ins>
になる。
<span class="trans-note">【<a href="http://www.rfc-editor.org/errata_search.php?rfc=6455">正誤表</a>による修正（ Verified ）】</span>
<span lang="en">
NOTE: As an example, if the randomly selected value was the sequence of bytes 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, the value of the header field would be "AQIDBAUGBwgJCgsMDQ4PEC=="
</span></p>

	</li>
<!-- 8 -->
	<li>
<p>
ブラウザ クライアントからのリクエストは、
<b>Origin</b> ヘッダ <a>[RFC6454]</a> を内包しなければ<em class="rfc2119">ならない</em>。
接続が非ブラウザ クライアントからのものである場合、リクエストは，そのクライアントの意味論がブラウザ クライアントに対してここに述べられるユースケースに合致するならば、このヘッダを内包しても<em class="rfc2119">よい</em>。
このヘッダの値は、接続を確立­中のコードが属する実行文脈の生成元を ASCII に直列化したものである。
このヘッダの値がどのように構築されるかについての詳細は、 <a>[RFC6454]</a> を見よ。
<span lang="en">
The request MUST include a header field with the name |Origin| [RFC6454] if the request is coming from a browser client. If the connection is from a non-browser client, the request MAY include this header field if the semantics of that client match the use-case described here for browser clients. The value of this header field is the ASCII serialization of origin of the context in which the code establishing the connection is running. See [RFC6454] for the details of how this header field value is constructed.
</span></p>

<p>
例として，
<samp>www.example.com</samp>
からダウンロードされたコードが
<samp>ww2.example.com</samp>
へ向けて接続の確立を試みる場合、ヘッダの値は
"<samp>http://www.example.com</samp>"
になるであろう。
<span lang="en">
As an example, if code downloaded from www.example.com attempts to establish a connection to ww2.example.com, the value of the header field would be "http://www.example.com".
</span></p>

	</li>
<!-- 9 -->
	<li>
<p>
リクエストは
<b>Sec-WebSocket-Version</b> ヘッダを内包していて, かつ
その値は 13 でなければ<em class="rfc2119">ならない</em>。
<span lang="en">
The request MUST include a header field with the name |Sec-WebSocket-Version|. The value of this header field MUST be 13.
</span></p>

<p class="note">注記：
この文書の草案のバージョン番号（ -09, -10, -11, -12 ）が公示されたが（それらのほとんどは、伝送路プロトコルに対する変更ではなく，編集上の変更や明確化からなる）、番号 9, 10, 11, 12 は <b>Sec-WebSocket-Version</b> の妥当な番号としては利用されていない。
これらの値は IANA レジストリに予約済み<!--1-->であるが、これまでも利用されておらず，今後も利用されることはない。
<span lang="en">
NOTE: Although draft versions of this document (-09, -10, -11, and -12) were posted (they were mostly comprised of editorial changes and clarifications and not changes to the wire protocol), values 9, 10, 11, and 12 were not used as valid values for Sec-WebSocket-Version. These values were reserved in the IANA registry but were not and will not be used.
</span></p>

	</li>
<!-- 10 -->
	<li id="subprotocol-req"><p>
リクエストは
<b>Sec-WebSocket-Protocol</b> ヘッダを内包しても<em class="rfc2119">よい</em>。
もし在れば，この値は、クライアントが<!-- ~speak を -->希望する順序にカンマ区切りで並べられた，１個以上の下位プロトコルを指示する。
この値を構成する各­要素は、 <a>[RFC2616]</a> の定義に従って， U+0021 〜 U+007E の範囲の文字からなる，区切り文字を含まず, 空でない，文字列でなければ<em class="rfc2119">ならず</em>、それぞれが一意的でなければ<em class="rfc2119">ならない</em>。
このヘッダ値に対する ABNF は <code>1#token</code> であり，その構成子と規則の定義は <a>[RFC2616]</a> にて与えられる。
<span lang="en">
The request MAY include a header field with the name |Sec-WebSocket-Protocol|. If present, this value indicates one or more comma-separated subprotocol the client wishes to speak, ordered by preference. The elements that comprise this value MUST be non-empty strings with characters in the range U+0021 to U+007E not including separator characters as defined in [RFC2616] and MUST all be unique strings. The ABNF for the value of this header field is 1#token, where the definitions of constructs and rules are as given in [RFC2616].
</span></li>


<!-- 11 -->
	<li>
リクエストは
<b>Sec-WebSocket-Extensions</b> ヘッダを内包しても<em class="rfc2119">よい</em>。
もし在れば，この値は、クライアントが<!-- ~speak -->希望する，１個以上のプロトコル­レベルの拡張を指示する。
このヘッダの解釈と形式は <a>9.1 節</a> にて述べる。
<span lang="en">
The request MAY include a header field with the name |Sec-WebSocket-Extensions|. If present, this value indicates the protocol-level extension(s) the client wishes to speak. The interpretation and format of this header field is described in Section 9.1.
</span></li>


<!-- 12 -->
	<li>
リクエストは、例えばクッキー <a>[RFC6265]</a> や
<b>Authorization</b> ヘッダ<a>[RFC2616]</a> のような認証に関係するヘッダなど，他の任意のヘッダを内包しても<em class="rfc2119">よい</em>。
それらは、それらを定義する文書に従って処理される。
<span lang="en">
The request MAY include any other header fields, for example, cookies [RFC6265] and/or authentication-related header fields such as the |Authorization| header field [RFC2616], which are processed according to documents that define them.
</span></li>

</ol>

<p id="validate-server-response">
クライアントは、 opening ハンドシェイクを送信したなら、更にデータを送信する前に，サーバからの応答を待機しなければ<em class="rfc2119">ならない</em>。
クライアントは、以下のようにサーバ応答の妥当­性を検証しなければ<em class="rfc2119">ならない</em>：
<span lang="en">
Once the client's opening handshake has been sent, the client MUST wait for a response from the server before sending any further data. The client MUST validate the server's response as follows:
</span></p>

<ol>
<!-- 1 -->
	<li>
サーバから受信されたステータスコードが 101 でない場合、クライアントは応答を HTTP <a>[RFC2616]</a> の手続きに従って取り扱う。
特に，クライアントは、 401 ステータスコードを受信した際には，認証を行い得る。
サーバは、 3xx ステータスコードを用いてクライアントをリダイレクトし得る（ただし，クライアントがそれに追随することは要求されていない），等々。
他の場合、次へ進む。
<span lang="en">
If the status code received from the server is not 101, the client handles the response per HTTP [RFC2616] procedures. In particular, the client might perform authentication if it receives a 401 status code; the server might redirect the client using a 3xx status code (but clients are not required to follow them), etc. Otherwise, proceed as follows.
</span></li>


<!-- 2 〜 6 -->
	<li>
<p>
応答が次に該当する場合、クライアントは
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させ</a>
なければ<em class="rfc2119">ならない</em>：
<span lang="en">
↓</span></p>
		<ul>
			<li>
応答は
<b>Upgrade</b> ヘッダを欠いている場合、あるいは
<b>Upgrade</b> ヘッダ値は "<code>websocket</code>" に ASCII 文字大小無視で合致しない値を含んでいる場合。
<span lang="en">
If the response lacks an |Upgrade| header field or the |Upgrade| header field contains a value that is not an ASCII case-insensitive match for the value "websocket", the client MUST _Fail the WebSocket Connection_.
</span></li>
<!-- 3 -->
			<li>
応答は
<b>Connection</b> ヘッダを欠いている場合、あるいは
<b>Connection</b> ヘッダ値は "<code>Upgrade</code>" に ASCII 文字大小無視で合致するトークンを含んでいない場合。
<span lang="en">
If the response lacks a |Connection| header field or the |Connection| header field doesn't contain a token that is an ASCII case-insensitive match for the value "Upgrade", the client MUST _Fail the WebSocket Connection_.
</span></li>

<!-- 4 -->
			<li>
応答は
<b>Sec-WebSocket-Accept</b> ヘッダを欠いている場合、あるいは
<b>Sec-WebSocket-Accept</b> ヘッダ値は，頭部と尾部の空白を無視した上で,［
（ base64 復号されてない，文字列としての） <b>Sec-WebSocket-Key</b> の値と文字列
"<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>"
とを連結してから SHA-1 をとった結果を base64 符号化した値
］でない場合。
<span lang="en">
If the response lacks a |Sec-WebSocket-Accept| header field or the |Sec-WebSocket-Accept| contains a value other than the base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-Key| (as a string, not base64-decoded) with the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" but ignoring any leading and trailing whitespace, the client MUST _Fail the WebSocket Connection_.
</span></li>

<!-- 5 -->
			<li>
応答は
<b>Sec-WebSocket-Extensions</b> ヘッダを内包していて, かつ
そのヘッダ値は クライアントのハンドシェイクには無かった拡張の利用を指示している場合（サーバがクライアントからリクエストされなかった拡張を指示した）。
（どの拡張がリクエストされたかを決定するための，このヘッダの構文解析法については、 <a>9.1 節</a> にて論じられる。）
<span lang="en">
If the response includes a |Sec-WebSocket-Extensions| header field and this header field indicates the use of an extension that was not present in the client's handshake (the server has indicated an extension not requested by the client), the client MUST _Fail the WebSocket Connection_. (The parsing of this header field to determine which extensions are requested is discussed in Section 9.1.)
</span></li>

<!-- 6 -->
			<li>
応答は
<b>Sec-WebSocket-Protocol</b> ヘッダを内包していて, かつ
そのヘッダ値は クライアントのハンドシェイクには無かった下位プロトコルの利用を指示している場合（サーバがクライアントからリクエストされなかった下位プロトコルを指示した）。
<span lang="en">
If the response includes a |Sec-WebSocket-Protocol| header field and this header field indicates the use of a subprotocol that was not present in the client's handshake (the server has indicated a subprotocol not requested by the client), the client MUST _Fail the WebSocket Connection_.
</span></li>
		</ul>
	</li>


</ol>

<p>
サーバの応答が，この節と <a>4.2.2 節</a> に定義されているサーバのハンドシェイクに課される要件に適合していない場合、クライアントは
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させ</a>
なければ<em class="rfc2119">ならない</em>。
<span lang="en">
If the server's response does not conform to the requirements for the server's handshake as defined in this section and in Section 4.2.2, the client MUST _Fail the WebSocket Connection_.
</span></p>

<p>
<a>[RFC2616]</a> に従い、 HTTP リクエストと HTTP 応答のいずれについても，すべてのヘッダ名における文字の大小は無視されることに注意。
<span lang="en">
Please note that according to [RFC2616], all header field names in both HTTP requests and HTTP responses are case-insensitive.
</span></p>

<p>
サーバ応答の妥当性が上で与えられたように検証されたとき、
<dfn class="term-def" id="dfn-established">WebSocket 接続が確立された</dfn>
と言い， WebSocket 接続は
<dfn class="term-def" id="dfn-OPEN-state">OPEN 状態</dfn>
にあるとされる。
<dfn class="term-def" id="dfn-extensions-in-use">利用中の拡張</dfn>
は、サーバのハンドシェイクに供された
<b>Sec-WebSocket-Extensions</b> ヘッダの値に等しい値の（空にもなり得る）文字列であるか, または
そのヘッダがサーバのハンドシェイクに無かった場合は null 値であるものと定義される。
<dfn class="term-def" id="dfn-subprotocol-in-use">利用中の下位プロトコル</dfn>
は、サーバのハンドシェイクに供された
<b>Sec-WebSocket-Protocol</b> ヘッダの値であるか, または
そのヘッダがサーバのハンドシェイクに無かった場合は null 値であるものと定義される。
加えて，サーバのハンドシェイクに（ <a>[RFC6265]</a> の定義に従った）クッキーが設定されるべきであることを指示するヘッダがある場合、これらのクッキーを指して
<dfn class="term-def" id="dfn-cookie-during-handshake">サーバの opening ハンドシェイクの間に設定されるクッキー</dfn>
と呼ぶ。
<span lang="en">
If the server's response is validated as provided for above, it is said that _The WebSocket Connection is Established_ and that the WebSocket Connection is in the OPEN state. The _Extensions In Use_ is defined to be a (possibly empty) string, the value of which is equal to the value of the |Sec-WebSocket-Extensions| header field supplied by the server's handshake or the null value if that header field was not present in the server's handshake. The _Subprotocol In Use_ is defined to be the value of the |Sec-WebSocket-Protocol| header field in the server's handshake or the null value if that header field was not present in the server's handshake. Additionally, if any header fields in the server's handshake indicate that cookies should be set (as defined by [RFC6265]), these cookies are referred to as _Cookies Set During the Server's Opening Handshake_.
</span></p>


	</section>
	<section id="section-4.2">

<h3 title="Server-Side Requirements">4.2. サーバ側に課される要件</h3>

<p>
サーバは接続の管理をネットワーク上の他のエージェントに負荷委譲しても<em class="rfc2119">よい</em>。
例えば負荷分散装置（ load balancer ）や逆プロキシ（ reverse proxy ）など。
<!-- 
ロードバランサ
負荷分散装置
http://ja.wikipedia.org/wiki/%E3%83%AD%E3%83%BC%E3%83%89%E3%83%90%E3%83%A9%E3%83%B3%E3%82%B5

逆プロキシ／リバースプロキシ
http://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%90%E3%83%BC%E3%82%B9%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7

-->
その種の状況では、サーバは，この仕様の目的においては、サーバ側の通信基盤のすべての部分，最初の機器から TCP 接続の終了まで、リクエストの処理と応答の送信についてサーバ側に帰着されるすべてを内包するものと見なされる。
<span lang="en">
Servers MAY offload the management of the connection to other agents on the network, for example, load balancers and reverse proxies. In such a situation, the server for the purposes of this specification is considered to include all parts of the server-side infrastructure from the first device to terminate the TCP connection all the way to the server that processes requests and sends responses.
</span></p>

<p class="example">例：
データセンターは、適切なハンドシェイクを伴う WebSocket リクエストに応答するサーバを持つことがあり，接続を，実際にデータ­フレームを処理する別サーバに 渡し得る。
この仕様の目的においては、 “サーバ” は，両者のコンピュータの組み合わせになる。
<span lang="en">
EXAMPLE: A data center might have a server that responds to WebSocket requests with an appropriate handshake and then passes the connection to another server to actually process the data frames. For the purposes of this specification, the "server" is the combination of both computers.
</span></p>


		<section id="section-4.2.1">

<h4 title="Reading the Client's Opening Handshake">4.2.1. クライアントからの opening ハンドシェイクの読み取り</h4>

<p>
クライアントは、 WebSocket 接続を開始するとき，自身の分担の opening ハンドシェイクを送信する。
サーバは、サーバ側分担のハンドシェイクの生成に必要な情報を取得するために，少なくともこのハンドシェイクの一部分を構文解析しなければならない。
<span lang="en">
When a client starts a WebSocket connection, it sends its part of the opening handshake. The server must parse at least part of this handshake in order to obtain the necessary information to generate the server part of the handshake.
</span></p>

<p>
クライアントの opening ハンドシェイクは、以下に挙げる部分からなる。
サーバは、ハンドシェイクの読み取り中に，クライアントが下の記述に合致するハンドシェイクを送信していないことを検出した場合（ <a>[RFC2616]</a> に従って，ヘッダの順序は重要でないことに注意） — ハンドシェイクの成分に指定されている ABNF 文法への違反も含め，それに限られず — クライアントからのハンドシェイクの処理を停止して，適切なエラーコードを伴う HTTP 応答（ <code class="res">400 Bad Request</code> など）を返さなければ<em class="rfc2119">ならない</em>。
<span lang="en">
The client's opening handshake consists of the following parts. If the server, while reading the handshake, finds that the client did not send a handshake that matches the description below (note that as per [RFC2616], the order of the header fields is not important), including but not limited to any violations of the ABNF grammar specified for the components of the handshake, the server MUST stop processing the client's handshake and return an HTTP response with an appropriate error code (such as 400 Bad Request).
</span></p>

<ul>
<!-- 1 -->
	<li>
<a>3 節</a> で定義される <var>resource-name</var> として解釈されるべきである "Request-URI" <a>[RFC2616]</a> または（ <var>resource-name</var> を含んでいる絶対 HTTP／HTTPS URI ）を内包している， HTTP/1.1 以上の GET リクエスト。
<span lang="en">
An HTTP/1.1 or higher GET request, including a "Request-URI" [RFC2616] that should be interpreted as a /resource name/ defined in Section 3 (or an absolute HTTP/HTTPS URI containing the /resource name/).
</span></li>

<!-- 2 -->
	<li>
サーバの権限（ authority ）を含んでいる
<b>Host</b> ヘッダ。
<span lang="en">
A |Host| header field containing the server's authority.
</span></li>

<!-- 3 -->
	<li>
ASCII 文字大小無視の値として値 "<code>websocket</code>" を含んでいる，
<b>Upgrade</b> ヘッダ。
<span lang="en">
An |Upgrade| header field containing the value "websocket", treated as an ASCII case-insensitive value.
</span></li>

<!-- 4 -->
	<li>
ASCII 文字大小無視の値としてトークン "<code>Upgrade</code>" を内包する，
<b>Connection</b> ヘッダ。
<span lang="en">
A |Connection| header field that includes the token "Upgrade", treated as an ASCII case-insensitive value.
</span></li>

<!-- 5 -->
	<li>
base64 に符号化された値（
<a>[RFC4648]</a> <a href="./rfc4648#section-4">4 節</a>
参照）であって，復号されたときに長さ 16 バイトの値になる，
<b>Sec-WebSocket-Key</b> ヘッダ。
<span lang="en">
A |Sec-WebSocket-Key| header field with a base64-encoded (see Section 4 of [RFC4648]) value that, when decoded, is 16 bytes in length.
</span></li>

<!-- 6 -->
	<li>
値 13 の
<b>Sec-WebSocket-Version</b> ヘッダ。
<span lang="en">
A |Sec-WebSocket-Version| header field, with a value of 13.
</span></li>

<!-- 7 -->
	<li>
オプションで、 <b>Origin</b> ヘッダ。
このヘッダは、すべてのブラウザ クライアントから送信される。
このヘッダを欠く接続の試みは、ブラウザ クライアントからのものと解釈される<em class="rfc2119">べき</em>でない。
<span lang="en">
Optionally, an |Origin| header field. This header field is sent by all browser clients. A connection attempt lacking this header field SHOULD NOT be interpreted as coming from a browser client.
</span></li>

<!-- 8 -->
	<li>
オプションで、クライアントの希望順に並べられた，下位プロトコルを指示する値のリストを伴う，
<b>Sec-WebSocket-Protocol</b> ヘッダ。
<!-- ~speak -->
<span lang="en">
Optionally, a |Sec-WebSocket-Protocol| header field, with a list of values indicating which protocols the client would like to speak, ordered by preference.
</span></li>

<!-- 9 -->
	<li>
オプションで、クライアントの希望順に並べられた，拡張を指示する値のリストを伴う，
<b>Sec-WebSocket-Extensions</b> ヘッダ。
このヘッダの解釈については <a>9.1 節</a> にて論じられる。
<span lang="en">
Optionally, a |Sec-WebSocket-Extensions| header field, with a list of values indicating which extensions the client would like to speak. The interpretation of this header field is discussed in Section 9.1.
</span></li>

<!-- 10 -->
	<li>
オプションで、サーバに向けて，クッキーを送信したり認証をリクエストする際に用いられる，他のヘッダ。
未知のヘッダは <a>[RFC2616]</a> に従って無視される。
<span lang="en">
Optionally, other header fields, such as those used to send cookies or request authentication to a server. Unknown header fields are ignored, as per [RFC2616].
</span></li>

</ul>

		</section>
		<section id="section-4.2.2">

<h4 title="Sending the Server's Opening Handshake">4.2.2. サーバによる opening ハンドシェイクの送信</h4>

<p>
サーバは、クライアントがサーバへの WebSocket 接続を確立する際に，その接続を受理して, opening ハンドシェイクを送信するためには、次の手続きを完了しなければ<em class="rfc2119">ならない</em>：
<span lang="en">
When a client establishes a WebSocket connection to a server, the server MUST complete the following steps to accept the connection and send the server's opening handshake.
</span></p>

<ol>
<!-- 1 -->
	<li>
接続が HTTPS （ HTTP-over-TLS ）ポートに対して生じたものである場合、接続を通して TLS ハンドシェイクを行う。
これに失敗した場合（例えば，クライアントが extended client hello "<code class="code">server_name</code>" <!--  -->においてサーバがホストしないホスト名を指示した場合）、接続を close する。
他の場合、接続における，それ以降の（サーバのハンドシェイクも含む）すべての通信は、暗号化されたトンネル <a>[RFC5246]</a> を通して実行されなければ<em class="rfc2119">ならない</em>。
<span lang="en">
If the connection is happening on an HTTPS (HTTP-over-TLS) port, perform a TLS handshake over the connection. If this fails (e.g., the client indicated a host name in the extended client hello "server_name" extension that the server does not host), then close the connection; otherwise, all further communication for the connection (including the server's handshake) MUST run through the encrypted tunnel [RFC5246].
</span></li>

<!-- 2 -->
	<li>
サーバは、例えば <a>[RFC2616]</a> に述べられるように，対応する <b>WWW-Authenticate</b> ヘッダを伴う 401 ステータスコードを返すことにより，追加のクライアント認証を行うことができる。
<span lang="en">
The server can perform additional client authentication, for example, by returning a 401 status code with the corresponding |WWW-Authenticate| header field as described in [RFC2616].
</span></li>

<!-- 3 -->
	<li>
サーバは、 3xx ステータスコード <a>[RFC2616]</a> を用いて，
クライアントをリダイレクトしても<em class="rfc2119">よい</em>。
この段は、上述の認証オプションの段と伴に，その前後いずれにも生じ得ることに注意。
<!-- together with -->
<span lang="en">
The server MAY redirect the client using a 3xx status code [RFC2616]. Note that this step can happen together with, before, or after the optional authentication step described above.
</span></li>

<!-- 4 -->
	<li>
<p>
次の情報を確定させる：
<span lang="en">
Establish the following information:
</span></p>

		<dl class="defs">
			<dt title="/origin/"><var>origin</var></dt>
			<dd>
クライアントからのハンドシェイクの中の
<b>Origin</b> ヘッダは、接続を確立­中のスクリプトの生成元を指示する。
生成元は ASCII に直列化され，小文字化される。
サーバは、この情報を着信­接続を受理するかどうかの判断材料にしても<em class="rfc2119">よい</em>。
サーバが生成元の妥当性を検証しない場合、どこからの接続も受理することになる。
この接続の受理を望まない場合、適切な HTTP エラーコード（例えば， <code class="res">403 Forbidden</code> ）を返して，この節にて述べている WebSocket ハンドシェイクを中止しなければ<em class="rfc2119">ならない</em>。
更なる詳細は <a>10 節</a> を参照。
<span lang="en">
The |Origin| header field in the client's handshake indicates the origin of the script establishing the connection. The origin is serialized to ASCII and converted to lowercase. The server MAY use this information as part of a determination of whether to accept the incoming connection. If the server does not validate the origin, it will accept connections from anywhere. If the server does not wish to accept this connection, it MUST return an appropriate HTTP error code (e.g., 403 Forbidden) and abort the WebSocket handshake described in this section. For more detail, refer to Section 10.
</span></dd>

			<dt title="/key/"><var>key</var></dt>
			<dd>
クライアントからのハンドシェイクの中の
<b>Sec-WebSocket-Key</b> ヘッダは、復号された時の長さが 16 バイトになる， base64 符号化­値を内包する。
この値は、接続の受理を指示するために，サーバのハンドシェイクの作成に（符号化されたままの形で）利用される。
サーバは、 <b>Sec-WebSocket-Key</b> 値を base64 から復号する必要はない。
<span lang="en">
The |Sec-WebSocket-Key| header field in the client's handshake includes a base64-encoded value that, if decoded, is 16 bytes in length. This (encoded) value is used in the creation of the server's handshake to indicate an acceptance of the connection. It is not necessary for the server to base64-decode the |Sec-WebSocket-Key| value.
</span></dd>

			<dt title="/version/"><var>version</var></dt>
			<dd>
クライアントからのハンドシェイクの中の
<b>Sec-WebSocket-Version</b> ヘッダは、クライアントが通信を試みている WebSocket Protocol のバージョンを内包する。
このバージョンがサーバが解せるバージョンに合致しない場合、サーバは、この節にて述べられる WebSocket ハンドシェイクを中止して，
適切な HTTP エラーコード（ <code class="res">426 Upgrade Required</code> など），および サーバが解せる一つ以上のバージョンを指示する
<b>Sec-WebSocket-Version</b> ヘッダを送信しなければ<em class="rfc2119">ならない</em>。
<span lang="en">
The |Sec-WebSocket-Version| header field in the client's handshake includes the version of the WebSocket Protocol with which the client is attempting to communicate. If this version does not match a version understood by the server, the server MUST abort the WebSocket handshake described in this section and instead send an appropriate HTTP error code (such as 426 Upgrade Required) and a |Sec-WebSocket-Version| header field indicating the version(s) the server is capable of understanding.
</span></dd>

			<dt title="/resource name/"><var>resource name</var></dt>
			<dd>
サーバから提供されるサービスの識別子。
サーバが複数のサービスを提供する場合、値はクライアントからのハンドシェイクの中の， GET メソッドの "Request-URI"  <a>[RFC2616]</a> の中に与えられたリソース名から導出されるべきである。
リクエストされたサービスが可用でない場合、サーバは、適切な HTTP エラーコード（ <code class="res">404 Not Found</code> など）を送信して，
WebSocket ハンドシェイクを中止しなければ<em class="rfc2119">ならない</em>。
<span lang="en">
An identifier for the service provided by the server. If the server provides multiple services, then the value should be derived from the resource name given in the client's handshake in the "Request-URI" [RFC2616] of the GET method. If the requested service is not available, the server MUST send an appropriate HTTP error code (such as 404 Not Found) and abort the WebSocket handshake.
</span></dd>

			<dt title="/subprotocol/"><var>subprotocol</var></dt>
			<dd>
サーバにて利用できる下位プロトコルを表現する単独の値であるか, または null 。
選ばれる値は、クライアントからのハンドシェイクの中から，具体的には
<b>Sec-WebSocket-Protocol</b> ヘッダの値の中からサーバがこの接続に用いることにする一つを（もしあれば）選択することにより、導出されなければ<em class="rfc2119">ならない</em>。
クライアントからのハンドシェイクにそのようなヘッダが含まれていないか, または サーバがクライアントがリクエストした下位プロトコルのどれにも同意しない場合、受理­可能な値は null のみになる。
そのようなヘッダの不在は null 値と等価である（すなわち，サーバが提示されたどの下位プロトコルにも同意しない場合、その応答に
<b>Sec-WebSocket-Protocol</b> ヘッダを返しては<em class="rfc2119">ならない</em>）。
この目的においては、空文字列は null 値と同じではなく，このヘッダに対する合法な値ではない。
このヘッダ値の ABNF は <code class="ABNF">(token)</code> であり，その構成子と規則の定義は <a>[RFC2616]</a> にて与えられる。
<span lang="en">
Either a single value representing the subprotocol the server is ready to use or null. The value chosen MUST be derived from the client's handshake, specifically by selecting one of the values from the |Sec-WebSocket-Protocol| field that the server is willing to use for this connection (if any). If the client's handshake did not contain such a header field or if the server does not agree to any of the client's requested subprotocols, the only acceptable value is null. The absence of such a field is equivalent to the null value (meaning that if the server does not wish to agree to one of the suggested subprotocols, it MUST NOT send back a |Sec-WebSocket-Protocol| header field in its response). The empty string is not the same as the null value for these purposes and is not a legal value for this field. The ABNF for the value of this header field is (token), where the definitions of constructs and rules are as given in [RFC2616].
</span></dd>

			<dt title="/extensions/"><var>extensions</var></dt>
			<dd>
サーバにて利用できるプロトコル­レベルの拡張を表現する，リスト（空にもなり得る）。
サーバが複数の拡張をサポートする場合、値はクライアントからのハンドシェイクの中から，具体的には
<b>Sec-WebSocket-Extensions</b> ヘッダから１個以上の値を選択することにより，導出されなければ<em class="rfc2119">ならない</em>。
そのようなヘッダの不在は null 値と等価である。
この目的においては、空文字列は null 値と同じではない。
クライアントからリストされなかった拡張がリストされては<em class="rfc2119">ならない</em>。
これらの値の選択と解釈の仕方は <a>9.1 節</a> にて論じられる。
<!--  -->
<span lang="en">
A (possibly empty) list representing the protocol-level extensions the server is ready to use. If the server supports multiple extensions, then the value MUST be derived from the client's handshake, specifically by selecting one or more of the values from the |Sec-WebSocket-Extensions| field. The absence of such a field is equivalent to the null value. The empty string is not the same as the null value for these purposes. Extensions not listed by the client MUST NOT be listed. The method by which these values should be selected and interpreted is discussed in Section 9.1.
</span></dd>
		</dl>

	</li>
<!-- 5 -->
	<li>
<p>
サーバは、着信­接続の受理を選ぶ場合、以下を指示する妥当な HTTP 応答で
返信しなければ<em class="rfc2119">ならない</em>。
<span lang="en">
If the server chooses to accept the incoming connection, it MUST reply with a valid HTTP response indicating the following.
</span></p>

		<ol>
		<!-- 1 -->
			<li>
<a>[RFC2616]</a> に従う， 101 応答コードを伴う Status-Line 。
その種の応答は、
"<samp>HTTP/1.1 101 Switching Protocols</samp>"
のような形をとるであろう。
<span lang="en">
A Status-Line with a 101 response code as per RFC 2616 [RFC2616]. Such a response could look like "HTTP/1.1 101 Switching Protocols".
</span></li>
		<!-- 2 -->
			<li>
<a>[RFC2616]</a> に従う，値 "<code>websocket</code>" にされた
<b>Upgrade</b> ヘッダ。
<span lang="en">
An |Upgrade| header field with value "websocket" as per RFC 2616 [RFC2616].
</span></li>
		<!-- 3 -->
			<li>
値 "<code >Upgrade</code>" にされた
<b>Connection</b> ヘッダ。
<span lang="en">
A |Connection| header field with value "Upgrade".
</span></li>
		<!-- 4 -->
			<li>
<p>
<b>Sec-WebSocket-Accept</b> ヘッダ。
このヘッダの値は、上の <a>4.2.2 節</a> 第 4 段で定義される <var>key</var> と文字列
"<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>"
を連結した値から SHA-1 ハッシュをとって得られる 20 バイト値を，
base64 に符号化（
<a>[RFC4648]</a> <a href="./rfc4648#section-4">4 節</a>
）することにより、構築される。
<span lang="en">
A |Sec-WebSocket-Accept| header field. The value of this header field is constructed by concatenating /key/, defined above in step 4 in Section 4.2.2, with the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", taking the SHA-1 hash of this concatenated value to obtain a 20-byte value and base64-encoding (see Section 4 of [RFC4648]) this 20-byte hash.
</span></p>

<p>
このヘッダの ABNF  <a>[RFC2616]</a> 
は次で定義される：
<span lang="en">
The ABNF [RFC2616] of this header field is defined as follows:
</span></p>

<pre class="ABNF">
Sec-WebSocket-Accept   = base64-value-non-empty
base64-value-non-empty = (1*base64-data [ base64-padding ]) |
                         base64-padding
base64-data      = 4base64-character
base64-padding   = (2base64-character "==") |
                   (3base64-character "=")
base64-character = ALPHA | DIGIT | "+" | "/"
</pre>



<div class="note">
<p>注記：
例えば、クライアントからのハンドシェイクの
<b>Sec-WebSocket-Key</b> ヘッダの値が
"<samp>dGhlIHNhbXBsZSBub25jZQ==</samp>"
であったなら、サーバは：
</p>

<ol>
	<li>
まず、文字列
"<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>"
を付加して，文字列
"<samp>dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</samp>"
を形成する。
</li>

	<li>
次に、その SHA-1 ハッシュをとり，値［
<samp>0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea</samp>
］を得る。
</li>

	<li>
最後に、この値を base64 符号化して得られる値
"<samp>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</samp>"
が，
<b>Sec-WebSocket-Accept</b> ヘッダに返されることになる。
</li>
</ol>

<p lang="en">
NOTE: As an example, if the value of the |Sec-WebSocket-Key| header field in the client's handshake were "dGhlIHNhbXBsZSBub25jZQ==", the server would append the string "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" to form the string "dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11". The server would then take the SHA-1 hash of this string, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded, to give the value "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", which would be returned in the |Sec-WebSocket-Accept| header field.
</p>
</div>


			</li>
		<!-- 5 -->
			<li>
オプションで、
<a>4.2.2 節</a> の第 4 段で定義される <var>subprotocol</var> を値にとる，
<b>Sec-WebSocket-Protocol</b> ヘッダ。
<span lang="en">
Optionally, a |Sec-WebSocket-Protocol| header field, with a value /subprotocol/ as defined in step 4 in Section 4.2.2.
</span></li>
		<!-- 6 -->
			<li>
オプションで、
<a>4.2.2 節</a> の第 4 段で定義される <var>extensions</var> を値にとる，
<b>Sec-WebSocket-Extensions</b> ヘッダ。
複数の拡張を利用する場合、それらすべてを単独の
<b>Sec-WebSocket-Extensions</b> ヘッダ内にリストするか, あるいは複数個の
<b>Sec-WebSocket-Extensions</b> ヘッダに分割してあてがうこともできる。
<span lang="en">
Optionally, a |Sec-WebSocket-Extensions| header field, with a value /extensions/ as defined in step 4 in Section 4.2.2. If multiple extensions are to be used, they can all be listed in a single |Sec-WebSocket-Extensions| header field or split between multiple instances of the |Sec-WebSocket-Extensions| header field.
</span></li>
		</ol>
	</li>
</ol>

<p>
これにより、サーバのハンドシェイクは完了する。
サーバがこれらの手続きを WebSocket ハンドシェイクを中止せずに完遂した場合、サーバは WebSocket 接続が確立されたものと見なし， WebSocket 接続は
<a class="dfnref" href="#dfn-OPEN-state">OPEN 状態</a>
になる。
この時点から，サーバはデータの送信（および受信）を始めてよい。
<span lang="en">
This completes the server's handshake. If the server finishes these steps without aborting the WebSocket handshake, the server considers the WebSocket connection to be established and that the WebSocket connection is in the OPEN state. At this point, the server may begin sending (and receiving) data.
</span></p>

		</section>
	</section>
	<section id="section-4.3">

<h3 title="Collected ABNF for New Header Fields Used in Handshake">4.3.  ハンドシェイクに用いられる新たなヘッダの ABNF 総覧</h3>

<p>
この節では、
<a>[RFC2616]</a> <a href="./rfc2616#section-2.1">2.1 節</a>
による， “暗黙の *LWS 規則” も内包する，
ABNF 構文／規則が利用される。
<span class="trans-note">【 *LWS ：省略可能（ “*” ）な連続空白（ Linear White Space, “線形空白”）】</span>
<span lang="en">
This section is using ABNF syntax/rules from Section 2.1 of [RFC2616], including the "implied *LWS rule".
</span></p>

<p>
この節では， ABNF において次の規約が用いられることに注意：
ABNF 規則の名前うち，一部のものは、対応するヘッダ名に対応する。
その種の規則は、対応するヘッダの値を表記する。
例えば， <code>Sec-WebSocket-Key</code> ABNF 規則は、
<b>Sec-WebSocket-Key</b> ヘッダの値の構文を記述する。
名前の中に "<code class="ABNF">-Client</code>" 接尾辞を伴う ABNF 規則は、クライアントからサーバへ向けて送信されるリクエストにおいてのみ用いられる。
名前の中に "<code class="ABNF">-Server</code>" 接尾辞を伴う ABNF 規則は、サーバからクライアントへ向けて送信される応答においてのみ用いられる。
例えば，
ABNF 規則 <code class="ABNF">Sec-WebSocket-Protocol-Client</code> は、クライアントからサーバに向けて送信される，
<b>Sec-WebSocket-Protocol</b> ヘッダ値の構文を記述する。
<span lang="en">
Note that the following ABNF conventions are used in this section. Some names of the rules correspond to names of the corresponding header fields. Such rules express values of the corresponding header fields, for example, the Sec-WebSocket-Key ABNF rule describes syntax of the |Sec-WebSocket-Key| header field value. ABNF rules with the "-Client" suffix in the name are only used in requests sent by the client to the server; ABNF rules with the "-Server" suffix in the name are only used in responses sent by the server to the client. For example, the ABNF rule Sec-WebSocket-Protocol-Client describes syntax of the |Sec-WebSocket-Protocol| header field value sent by the client to the server.
</span></p>

<p>
クライアントは、次の新たなヘッダを，サーバへのハンドシェイクにて送信できる：
<span lang="en">
The following new header fields can be sent during the handshake from the client to the server:
</span></p>

<pre class="ABNF">
Sec-WebSocket-Key = base64-value-non-empty
Sec-WebSocket-Extensions = extension-list
Sec-WebSocket-Protocol-Client = 1#token
Sec-WebSocket-Version-Client = version

base64-value-non-empty = (1*base64-data [ base64-padding ]) |
                          base64-padding
base64-data      = 4base64-character
base64-padding   = (2base64-character "==") |
                   (3base64-character "=")
base64-character = ALPHA | DIGIT | "+" | "/"
extension-list = 1#extension
extension = extension-token *( ";" extension-param )
extension-token  = registered-token
registered-token = token

extension-param  = token [ "=" (token | quoted-string) ]
    ; <span title="When using the quoted-string syntax variant, the value">quoted-string 構文を利用する場合、</span>
    ; <span title="after quoted-string unescaping MUST conform to the"
>quoted-string のエスケープ復元後の値は</span>
    ; <span title="'token' ABNF.">'token' ABNF に適合しなければ<em class="rfc2119">ならない</em></span>
NZDIGIT         = "1" | "2" | "3" | "4" | "5" | "6" |
                  "7" | "8" | "9"
version = DIGIT | (NZDIGIT DIGIT) |
          ("1" DIGIT DIGIT) | ("2" DIGIT DIGIT)
          ; <span title="Limited to 0-255 range, with no leading zeros">0 〜 255 の範囲に制限され, かつ先頭のゼロは不可。</span>
</pre>

<p>
サーバは、次の新たなヘッダを，クライアントへのハンドシェイクにて送信できる：
<span lang="en">
The following new header fields can be sent during the handshake from the server to the client:
</span></p>

<pre class="ABNF">
Sec-WebSocket-Extensions = extension-list
Sec-WebSocket-Accept     = base64-value-non-empty
Sec-WebSocket-Protocol-Server = token
Sec-WebSocket-Version-Server  = 1#version
</pre>

	</section>
	<section id="section-4.4">

<h3 title="Supporting Multiple Versions of WebSocket Protocol">4.4. 複数のバージョンの WebSocket Protocol のサポート</h3>

<p>
この節では、クライアントとサーバにおいて，複数のバージョンの WebSocket Protocol をサポートするための指針を提供する。
<span lang="en">
This section provides some guidance on supporting multiple versions of the WebSocket Protocol in clients and servers.
</span></p>

<p>
クライアントは、 WebSocket バージョン告知機能（
<b>Sec-WebSocket-Version</b> ヘッダ）を利用して，希望する WebSocket Protocol のバージョンを（クライアントで最新にサポートされているものである必要はない）初期­時にリクエストできる。
サーバがリクエストされたバージョンをサポートし, かつ
ハンドシェイク­メッセージの他の部分も妥当であれば、サーバはそのバージョンを受理することになる。<!--  -->
サーバがリクエストされたバージョンをサポートしない場合、利用を希望するすべてのバージョンを含んでいる
<b>Sec-WebSocket-Version</b> ヘッダ（または複数の
<b>Sec-WebSocket-Version</b> ヘッダ）により，応答しなければ<em class="rfc2119">ならない</em>。
このとき，クライアントは、告知されたバージョンのいずれかをサポートするならば，新たなバージョン値を用いて WebSocket ハンドシェイクを繰り返すことができる。
<span lang="en">
Using the WebSocket version advertisement capability (the |Sec-WebSocket-Version| header field), a client can initially request the version of the WebSocket Protocol that it prefers (which doesn't necessarily have to be the latest supported by the client). If the server supports the requested version and the handshake message is otherwise valid, the server will accept that version. If the server doesn't support the requested version, it MUST respond with a |Sec-WebSocket-Version| header field (or multiple |Sec-WebSocket-Version| header fields) containing all versions it is willing to use. At this point, if the client supports one of the advertised versions, it can repeat the WebSocket handshake using a new version value.
</span></p>

<p>
上述のバージョン折衝の例を示す：
<span lang="en">
The following example demonstrates version negotiation described above:
</span></p>

<pre class="example">
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
...
Sec-WebSocket-Version: 25
</pre>


<p>
サーバからの応答は次のような形をとり得る：
<span lang="en">
The response from the server might look as follows:
</span></p>

<pre class="example">
HTTP/1.1 400 Bad Request
...
Sec-WebSocket-Version: 13, 8, 7
</pre>

<p>
前記のサーバからの応答は次のような形もとり得ることに注意：
<span lang="en">
Note that the last response from the server might also look like:
</span></p>

<pre class="example">
HTTP/1.1 400 Bad Request
...
Sec-WebSocket-Version: 13
Sec-WebSocket-Version: 8, 7
</pre>

<p>
クライアントは、今度は，バージョン 13 に適合するハンドシェイクを繰り返す：
<span lang="en">
The client now repeats the handshake that conforms to version 13:
</span></p>

<pre class="example">
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
...
Sec-WebSocket-Version: 13
</pre>



	</section>
</section>
<section id="section-5">

<h2 title="Data Framing">5.  データのフレーミング</h2>

	<section id="section-5.1">

<h3 title="Overview">5.1. 概観</h3>

<p>
WebSocket Protocol においては，データはフレームの並びにより伝送される。
（透過型プロキシなどの）ネットワーク中継点による混同を回避するため，および <a>10.3 節</a> にて更に論じられるセキュリティ上の理由から、クライアントは，サーバに向けて送信するすべてのフレームをマスクしなければ<em class="rfc2119">ならない</em>
（更なる詳細は <a>5.3 節</a> を見よ）。
（マスクの適用は WebSocket Protocol が TLS を通して実行されているかどうかに関係なく行われることに注意。）
サーバは、マスクされていないフレームを受信した際には，接続を close しなければ<em class="rfc2119">ならない</em>。
この場合，サーバは、 <a>7.4.1 節</a> の定義に従って，ステータスコード 1002 （プロトコル­エラー）を伴う Close フレームを送信しても<em class="rfc2119">よい</em>。
サーバは、クライアントに送信するどのフレームもマスクしては<em class="rfc2119">ならない</em>。
クライアントは、マスクされたフレームを検出したときには，接続を close しなければ<em class="rfc2119">ならない</em>。
この場合、 <a>7.4.1 節</a> に定義されるステータスコード 1002 （プロトコル­エラー）を用いても<em class="rfc2119">よい</em>。
（これらの規則は、将来­仕様においては，緩和され得る。）
<span lang="en">
In the WebSocket Protocol, data is transmitted using a sequence of frames. To avoid confusing network intermediaries (such as intercepting proxies) and for security reasons that are further discussed in Section 10.3, a client MUST mask all frames that it sends to the server (see Section 5.3 for further details). (Note that masking is done whether or not the WebSocket Protocol is running over TLS.) The server MUST close the connection upon receiving a frame that is not masked. In this case, a server MAY send a Close frame with a status code of 1002 (protocol error) as defined in Section 7.4.1. A server MUST NOT mask any frames that it sends to the client. A client MUST close a connection if it detects a masked frame. In this case, it MAY use the status code 1002 (protocol error) as defined in Section 7.4.1. (These rules might be relaxed in a future specification.)
</span></p>

<p>
フレーミング プロトコルの基礎部は、 opcode によるフレームの種別, およびペイロードの長さを定義し， <a>Extension データ</a>と <a>Application データ</a>（および，この２つを併せた <a>Payload データ</a>）が占める指定域を定義する。
一部のビットと opcode は、プロトコルの将来の発展のために予約済み<!--1-->である。
<span lang="en">
The base framing protocol defines a frame type with an opcode, a payload length, and designated locations for "Extension data" and "Application data", which together define the "Payload data". Certain bits and opcodes are reserved for future expansion of the protocol.
</span></p>

<p>
データ­フレームは、クライアントとサーバのいずれからでも，
opening ハンドシェイクの完了後から その端点が Close フレーム（ <a>5.5.1 節</a> ）を送信し終える前までのいつでも，伝送されて<em class="rfc2119">よい</em>。
<span lang="en">
A data frame MAY be transmitted by either the client or the server at any time after opening handshake completion and before that endpoint has sent a Close frame (Section 5.5.1).
</span></p>

	</section>
	<section id="section-5.2">

<h3 title="Base Framing Protocol">5.2. フレーミング プロトコルの基礎部</h3>

<p>
データ転送パートのための伝送路データ形式は、この節にて ABNF  <a>[RFC5234]</a> を用いて詳細に渡り述べられる。
（この文書の他の節と異なり，この節の ABNF はビットのグループを対象にしていることに注意。
各グループのビット長はコメント内に指示される。
伝送路­上に符号化される際の最上位ビットは、 ABNF においては左端に位置する。）
フレーミングのより高次の概観は次の図により与えられる。
この図とこの節の以下で指定される ABNF との間に不一致がある場合、この図の方が優先される。
<span lang="en">
This wire format for the data transfer part is described by the ABNF [RFC5234] given in detail in this section. (Note that, unlike in other sections of this document, the ABNF in this section is operating on groups of bits. The length of each group of bits is indicated in a comment. When encoded on the wire, the most significant bit is the leftmost in the ABNF). A high-level overview of the framing is given in the following figure. In a case of conflict between the figure below and the ABNF specified later in this section, the figure is authoritative.
</span></p>

<div style="overflow:auto;">
<table id="framing-table">
	<thead>
		<tr>
<th colspan="10">0</th>
<th colspan="10">1</th>
<th colspan="10">2</th>
<th colspan="2">3</th>
		</tr>
		<tr>
<th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th>
<th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th>
<th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th>
<th>0</th><th>1</th>
		</tr>
	</thead>
	<tbody>
		<tr>
<td><a href="#data-FIN">F<br>I<br>N</a></td>
<td><a href="#data-RSV">R<br>S<br>V<br>1</a></td>
<td><a href="#data-RSV">R<br>S<br>V<br>2</a></td>
<td><a href="#data-RSV">R<br>S<br>V<br>3</a></td>
<td colspan="4"><a href="#data-opcode" >opcode</a><br>(4 bit)</td>
<td><a href="#data-MASK">M<br>A<br>S<br>K</a></td>
<td colspan="7" style="border-right-style: dashed"><a href="#data-payload-length">Payload 長</a><br>(7 bit)</td>
<td colspan="16" style="border-style: solid dashed solid none;">延長 Payload 長<br>(16/64 bit)<br>
（ Payload 長 == 126/127 の場合）</td>
		</tr>
		<tr>
<td colspan="32" style="border-style: solid none solid dashed;">延長 Payload 長（続き），（ Payload 長 == </td>
		</tr>
		<tr>
<td colspan="16" style="border-left-style: none">127 の場合）</td>
<td colspan="16" style="border-right-style: none"><a href="#data-Masking-key">Masking-key</a> （ MASK が 1 の場合）</td>
		</tr>
		<tr>
<td colspan="16" style="border-left-style: none">Masking-key （続き）</td>
<td colspan="16" style="border-right-style: none"><a>Payload データ</a></td>
		</tr>
		<tr>
<td colspan="32" style="border-style: none; line-height:1.7; background:transparent;">…</td>
		</tr>
		<tr>
<td colspan="32" style="border-style: solid none solid none;">Payload データ（続き）</td>
		</tr>
		<tr>
<td colspan="32" style="border-style: none; line-height:1.7; background:transparent;">…</td>
		</tr>
		<tr>
<td colspan="24" style="border-left-style: none; border-right-style: none;">Payload データ（続き）</td>
<td colspan="8" style="border-style: none; background:transparent;">…</td>
		</tr>
	</tbody>
</table>
</div>

<pre style="line-height:1">
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
</pre>

<dl class="defs">

	<dt id="data-FIN" title="FIN:  1 bit">FIN： 1 ビット</dt>
	<dd>
メッセージの中の最後の断片である（ 1 の場合）かどうかを指示する。
最初の断片が最後の断片になっていても<em class="rfc2119">よい</em>。
<span lang="en">
Indicates that this is the final fragment in a message. The first fragment MAY also be the final fragment.
</span></dd>

	<dt id="data-RSV" title="RSV1, RSV2, RSV3:  1 bit each">RSV1, RSV2, RSV3： 各 1 ビット <span class="trans-note">【“予約済み<!--1-->ビット”】</span></dt>
	<dd>
非ゼロ値に対する意味を定義する拡張が折衝されていない限り、 0 でなければ<em class="rfc2119">ならない</em>。
非ゼロ値が受信されたにも関わらず，折衝されたどの拡張もそのような非ゼロ値の意味を定義していない場合、受信した側の端点は，
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させ</a>
なければ<em class="rfc2119">ならない</em>。
<span lang="en">
MUST be 0 unless an extension is negotiated that defines meanings for non-zero values. If a nonzero value is received and none of the negotiated extensions defines the meaning of such a nonzero value, the receiving endpoint MUST _Fail the WebSocket Connection_.
</span></dd>

	<dt id="data-opcode" title="Opcode:  4 bits">opcode： 4 ビット</dt>
	<dd>
<a>Payload データ</a>の解釈を定義する。
未知の opcode が受信された場合、受信­側 端点は
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させ</a>
なければ<em class="rfc2119">ならない</em>。
<span lang="en">
Defines the interpretation of the "Payload data". If an unknown opcode is received, the receiving endpoint MUST _Fail the WebSocket Connection_. The following values are defined.
</span></dd>

	<dd>
<p>
次の値が定義されている：
</p>

<ul>
	<li>
%x0 は継続フレームを表す
<span lang="en">
%x0 denotes a continuation frame
</span></li>
	<li>
%x1 はテキスト­フレームを表す
<span lang="en">
%x1 denotes a text frame
</span></li>
	<li>
%x2 はバイナリ­フレームを表す
<span lang="en">
%x2 denotes a binary frame
</span></li>
	<li>
%x3-7 は追加の非­制御フレーム用に予約済み<!--1-->
<span lang="en">
%x3-7 are reserved for further non-control frames
</span></li>
	<li>
%x8 は接続の close を表す
<span lang="en">
%x8 denotes a connection close
</span></li>
	<li>
%x9 は ping を表す
<span lang="en">
%x9 denotes a ping
</span></li>
	<li>
%xA は pong を表す
<span lang="en">
%xA denotes a pong
</span></li>
	<li>
%xB-F は追加の制御フレーム用に予約済み<!--1-->
<span lang="en">
%xB-F are reserved for further control frames
</span></li>
</ul>

	</dd>

	<dt id="data-MASK" title="Mask:  1 bit">Mask： 1 ビット</dt>
	<dd>
<a>Payload データ</a>がマスクされているかどうかを定義する。
1 にされている場合、 <!-- masking-key --><a href="#data-Masking-key" >Masking-key</a> の中にマスキングキーが在り、 <a>5.3 節</a> に従って，
<a>Payload データ</a>のマスクを解除する際に用いられる。
クライアントからサーバへ送信される すべてのフレームにおいて、このビットは 1 にされる。
<span lang="en">
Defines whether the "Payload data" is masked. If set to 1, a masking key is present in masking-key, and this is used to unmask the "Payload data" as per Section 5.3. All frames sent from client to server have this bit set to 1.
</span></dd>

	<dt id="data-payload-length" title="Payload length:  7 bits, 7+16 bits, or 7+64 bits">Payload 長： 7, 7+16, 7+64 ビットのいずれか</dt>
	<dd>
バイト数による <a>Payload データ</a>の長さ：
0 〜 125 の場合、それがそのままペイロードの長さになる。
126 の場合、後続の 2 バイトが 16 ビット非負­整数に解釈されてペイロードの長さになる。
127 の場合、後続の 8 バイトが 64 ビット非負­整数（最上位ビットは 0 でなければ<em class="rfc2119">ならない</em>）に解釈されてペイロードの長さになる。
複バイトによる長さ数量はネットワーク­バイト順序で表記される。<!--  -->
いかなる場合も、長さの符号化には最小のバイト数が用いられなければ<em class="rfc2119">ならない</em>ことに注意。
例えば， 124 バイトの文字列に対し、その長さが 126, 0, 124 の並びに符号化されることはない。
ペイロードの長さは、 <a>Extension データ</a>の長さと <a>Application データ</a>の長さの和である。
<a>Extension データ</a>の長さはゼロもあり得る。
この場合のペイロードの長さは <a>Application データ</a>の長さになる。
<span lang="en">
The length of the "Payload data", in bytes: if 0-125, that is the payload length. If 126, the following 2 bytes interpreted as a 16-bit unsigned integer are the payload length. If 127, the following 8 bytes interpreted as a 64-bit unsigned integer (the most significant bit MUST be 0) are the payload length. Multibyte length quantities are expressed in network byte order. Note that in all cases, the minimal number of bytes MUST be used to encode the length, for example, the length of a 124-byte-long string can't be encoded as the sequence 126, 0, 124. The payload length is the length of the "Extension data" + the length of the "Application data". The length of the "Extension data" may be zero, in which case the payload length is the length of the "Application data".
</span></dd>

	<dt id="data-Masking-key" title="Masking-key:  0 or 4 bytes">Masking-key： 0 バイトまたは 4 バイト</dt>
	<dd>
クライアントからサーバへ送信されるすべてのフレームは、フレーム内に含められた 32 ビット値によりマスクされる。
マスク­ビットが 1 にされている場合、このフィールドが在る。
マスク­ビットが 0 にされている場合、このフィールドは無い。
クライアントからサーバへのマスクの適用についての詳細は <a>5.3 節</a> を見よ。
<span lang="en">
All frames sent from the client to the server are masked by a 32-bit value that is contained within the frame. This field is present if the mask bit is set to 1 and is absent if the mask bit is set to 0. See Section 5.3 for further information on client-to-server masking.
</span></dd>

	<dt id="data-Payload" title="Payload data:  (x+y) bytes">Payload データ： ( x + y )  バイト</dt>
	<dd>
<a>Payload データ</a>は、 <a>Extension データ</a>と <a>Application データ</a>を連結したものとして定義される。
<span lang="en">
The "Payload data" is defined as "Extension data" concatenated with "Application data".
</span></dd>

	<dt id="data-Extension" title="Extension data:  x bytes">Extension データ： x バイト</dt>
	<dd>
<a>Extension データ</a>は、拡張が折衝されていない限り， 0 バイトになる。
どの拡張も <a>Extension データ</a>の長さ, または
その算出方法を指定しなければ<em class="rfc2119">ならず</em>，かつ
拡張がそれをどのように利用するかが opening ハンドシェイクの間に折衝されなければ<em class="rfc2119">ならない</em>。
<!--  -->
在る場合、 <a>Extension データ</a>の長さは，総ペイロード長に内包される。
<span lang="en">
The "Extension data" is 0 bytes unless an extension has been negotiated. Any extension MUST specify the length of the "Extension data", or how that length may be calculated, and how the extension use MUST be negotiated during the opening handshake. If present, the "Extension data" is included in the total payload length.
</span></dd>

	<dt id="data-Application" title="Application data:  y bytes">Application データ： y バイト</dt>
	<dd>
<a>Extension データ</a>の後のフレームの残りの部分を占める任意の <a>Application データ</a>。
<a>Application データ</a>の長さはペイロードの長さから <a>Extension データ</a>の長さを引いたものに等しい。
<span lang="en">
Arbitrary "Application data", taking up the remainder of the frame after any "Extension data". The length of the "Application data" is equal to the payload length minus the length of the "Extension data".
</span></dd>

</dl>

<p>
フレーミング プロトコルの基礎部は、次の ABNF  <a>[RFC5234]</a> により形式的に定義される。
このデータの表現はバイナリであり， ASCII 文字でないことに注意。
したがって，値 %x0 または %x1 をとる長さ  1 ビットのフィールドは、ASCII 符号化方式（文字 "<code>0</code>" または "<code>1</code>" ）による全部的バイト（オクテット）ではなく，値 0 または 1 をとる単独のビットで表現される。
値 %x0-F をとる長さ  4 ビットのフィールドもまた、これらの値をとる ASCII 文字や全部的バイト（オクテット）では<em>なく</em>， 4 ビットで表現される。
<a>[RFC5234]</a> は、文字­符号化方式を指定しない：
<span lang="en">
The base framing protocol is formally defined by the following ABNF [RFC5234]. It is important to note that the representation of this data is binary, not ASCII characters. As such, a field with a length of 1 bit that takes values %x0 / %x1 is represented as a single bit whose value is 0 or 1, not a full byte (octet) that stands for the characters "0" or "1" in the ASCII encoding. A field with a length of 4 bits with values between %x0-F again is represented by 4 bits, again NOT by an ASCII character or full byte (octet) with these values. [RFC5234] does not specify a character encoding:
</span></p>

<blockquote style="font-style:italic;"><p >
“終端値の並び（ string ）に解決される規則は、文字の列（ characters ）と呼ばれることがある。
ABNF においては、各­文字は単なる非負­整数である。
ある種の文脈においては、値から文字集合（ ASCII など）への特定の写像（符号化方式）が指定されることになる。”
<span lang="en">
"Rules resolve into a string of terminal values, sometimes called characters. In ABNF, a character is merely a non-negative integer. In certain contexts, a specific mapping (encoding) of values into a character set (such as ASCII) will be specified."
</span></p></blockquote>

<p>
ここで指定される符号化方式は、各­終端値が符号化される際のビット数が，各フィールドごとに異なり得るものとして指定される、バイナリ符号化方式である。
<span lang="en">
Here, the specified encoding is a binary encoding where each terminal value is encoded in the specified number of bits, which varies for each field.
</span></p>


<pre class="ABNF">
ws-frame                = frame-fin           ; <span title="1 bit in length">長さ 1 ビット</span>
                          frame-rsv1          ; <span title="1 bit in length">長さ 1 ビット</span>
                          frame-rsv2          ; <span title="1 bit in length">長さ 1 ビット</span>
                          frame-rsv3          ; <span title="1 bit in length">長さ 1 ビット</span>
                          frame-opcode        ; <span title="4 bits in length">長さ 4 ビット</span>
                          frame-masked        ; <span title="1 bit in length">長さ 1 ビット</span>
                          frame-payload-length
                          ; <span title="either 7, 7+16, or 7+64 bits in length">長さ 7, 7+16, 7+64 ビットいずれか</span>

                          [ frame-masking-key ]  ; <span title="32 bits in length">長さ 32 ビット</span>
                          frame-payload-data
                          ; <span title="n*8 bits in length, where n &gt;= 0">長さ n×8 ビット ( n &gt;= 0 )</span>

frame-fin               = %x0 ; <span title="more frames of this message follow">このメッセージの後続フレームがある</span>
                        / %x1 ; <span title="final frame of this message">このメッセージの最後のフレーム</span>
                              ; <span title="1 bit in length">長さ 1 ビット</span>

frame-rsv1              = %x0 / %x1
                          ; <span title="1 bit in length, MUST be 0 unless">長さ 1 ビット，拡張が折衝されて</span>
                          ; <span title="negotiated otherwise">いない限り 0 でなければ<em class="rfc2119">ならない</em></span>

frame-rsv2              = %x0 / %x1
                          ; <span title="1 bit in length, MUST be 0 unless">長さ 1 ビット，拡張が折衝されて</span>
                          ; <span title="negotiated otherwise">いない限り 0 でなければ<em class="rfc2119">ならない</em></span>

frame-rsv3              = %x0 / %x1
                          ; <span title="1 bit in length, MUST be 0 unless">長さ 1 ビット，拡張が折衝されて</span>
                          ; <span title="negotiated otherwise">いない限り 0 でなければ<em class="rfc2119">ならない</em></span>

frame-opcode            = frame-opcode-non-control /
                          frame-opcode-control /
                          frame-opcode-cont

frame-opcode-cont       = %x0 ; <span title="frame continuation">継続フレーム</span>

frame-opcode-non-control= %x1 ; <span title="text frame">テキスト­フレーム</span>
                        / %x2 ; <span title="binary frame">バイナリ­フレーム</span>
                        / %x3-7 ; <span title="reserved for further non-control frames">更なる非­制御フレーム用に予約済み<!--1--></span>
                                ; <span title="4 bits in length,">長さ 4 ビット</span>

frame-opcode-control    = %x8 ; <span title="connection close">接続の close</span>
                        / %x9 ; <span title="ping">ping</span>
                        / %xA ; <span title="pong">pong</span>
                        / %xB-F ; <span title="reserved for further control frames">更なる制御フレーム用に予約済み<!--1--></span>
                                ; <span title="4 bits in length">長さ 4 ビット</span>

frame-masked            = %x0
                        ; <span title="frame is not masked, no frame-masking-key">フレームはマスクされていない，frame-masking-key は無い</span>
                        / %x1
                        ; <span title="frame is masked, frame-masking-key present">フレームはマスク済み，frame-masking-key は在る</span>
                        ; <span title="1 bit in length">長さ 1 ビット</span>

frame-payload-length    = ( %x00-7D )
                        / ( %x7E frame-payload-length-16 )
                        / ( %x7F frame-payload-length-63 )
                        ; <span title="7, 7+16, or 7+64 bits in length, respectively">長さ 7, 7+16, 7+64 ビットいずれか（同順）</span>

frame-payload-length-16 = %x0000-FFFF ; <span title="16 bits in length">長さ 16 ビット</span>

frame-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF
                        ; <span title="64 bits in length">長さ 64 ビット</span>

frame-masking-key       = 4( %x00-FF )
                        ; <span title="present only if frame-masked is 1"><code>frame-masked</code> が 1 のときのみ在る</span>
                        ; <span title="32 bits in length">長さ 32 ビット</span>

frame-payload-data      = (frame-masked-extension-data
                           frame-masked-application-data)
                        ; <span title="when frame-masked is 1"><code>frame-masked</code> が 1 のとき</span>
                          / (frame-unmasked-extension-data
                            frame-unmasked-application-data)
                        ; <span title="when frame-masked is 0"><code>frame-masked</code> が 0 のとき</span>

frame-masked-extension-data     = *( %x00-FF )
                        ; <span title="reserved for future extensibility">将来の拡張性のために予約済み<!--1--></span>
                        ; <span title="n*8 bits in length, where n &gt;= 0">長さ n×8 ビット ( n &gt;= 0 )</span>

frame-masked-application-data   = *( %x00-FF )
                        ; <span title="n*8 bits in length, where n &gt;= 0">長さ n×8 ビット ( n &gt;= 0 )</span>

frame-unmasked-extension-data   = *( %x00-FF )
                        ; <span title="reserved for future extensibility">将来の拡張性のために予約済み<!--1--></span>
                        ; <span title="n*8 bits in length, where n &gt;= 0">長さ n×8 ビット ( n &gt;= 0 )</span>

frame-unmasked-application-data = *( %x00-FF )
                        ; <span title="n*8 bits in length, where n &gt;= 0">長さ n×8 ビット ( n &gt;= 0 )</span>
</pre>

	</section>
	<section id="section-5.3">

<h3 title="Client-to-Server Masking">5.3. クライアントからサーバへのマスクの適用</h3>

<p>
マスクされたフレームでは、 <a>5.2 節</a> の定義に従って，
<code class="ABNF">frame-masked</code> フィールドが 1 にされていなければ<em class="rfc2119">ならない</em>。
<span lang="en">
A masked frame MUST have the field frame-masked set to 1, as defined in Section 5.2.
</span></p>

<p>
<a>5.2 節</a> にて定義したように、マスキングキーは，そのフレーム内に
<code class="ABNF">frame-masking-key</code>
として完全に含まれる。
それは、同じ節で <a>Extension データ</a>と <a>Application データ</a>を内包する <a>Payload データ</a>として定義された,
<code class="ABNF">frame-payload-data</code>
を，マスクするために用いられる。
<span lang="en">
The masking key is contained completely within the frame, as defined in Section 5.2 as frame-masking-key. It is used to mask the "Payload data" defined in the same section as frame-payload-data, which includes "Extension data" and "Application data".
</span></p>

<p>
マスキングキーは、クライアントにより無作為に選ばれる 32 ビット値である。
マスクされたフレームを準備する際には、クライアントは、許容される 32 ビット値の集合から，新規にマスキングキーを取り出さなければ<em class="rfc2119">ならない</em>。
マスキングキーは予測不能になる必要がある。
したがって、マスキングキーは，平均情報量（ entropy ）の強い源から導出されなければ<em class="rfc2119">ならず</em>、与えられたフレームに対するマスキングキーからの, 後続のフレームに対するマスキングキーの予測が，サーバやプロキシにとって容易になっては<em class="rfc2119">ならない</em>。
マスキングキーの予測不能性は、悪意のある<!--1-->アプリケーションの作者が伝送路­上に現れるバイトを選定できなくするために，本質的である。
セキュリティに敏感なアプリケーションにとり，情報量の源として相応しいとされるものについては、 <a>[RFC4086]</a> にて論じられている。
<!--  -->
<span lang="en">
The masking key is a 32-bit value chosen at random by the client. When preparing a masked frame, the client MUST pick a fresh masking key from the set of allowed 32-bit values. The masking key needs to be unpredictable; thus, the masking key MUST be derived from a strong source of entropy, and the masking key for a given frame MUST NOT make it simple for a server/proxy to predict the masking key for a subsequent frame. The unpredictability of the masking key is essential to prevent authors of malicious applications from selecting the bytes that appear on the wire. RFC 4086 [RFC4086] discusses what entails a suitable source of entropy for security-sensitive applications.
</span></p>

<p>
マスクの適用は <a>Payload データ</a>の長さには影響しない。
マスクされたデータからマスクされていないデータへの, あるいはその逆への変換には、次のアルゴリズムが適用される。
変換には、その向きに関係なく，同じアルゴリズムが適用される。
すなわち、同じ手続きが，データに対するマスクの適用と解除のいずれにも，適用される。
<span lang="en">
The masking does not affect the length of the "Payload data". To convert masked data into unmasked data, or vice versa, the following algorithm is applied. The same algorithm applies regardless of the direction of the translation, e.g., the same steps are applied to mask the data as to unmask the data.
</span></p>

<p>
変換­後のデータの i 番目のオクテット（ "<code class="code">transformed-octet-i</code>", 0 番目が最初）は、元データの i 番目のオクテット（ "<code class="code">original-octet-i</code>" ）と, マスキングキーの i modulo 4 番目に位置するオクテット（ "<code class="code">masking-key-octet-j</code>" ）との XOR （排他的論理和）である：
<span lang="en">
Octet i of the transformed data ("transformed-octet-i") is the XOR of octet i of the original data ("original-octet-i") with octet at index i modulo 4 of the masking key ("masking-key-octet-j"):
</span></p>

<pre>j                   = i MOD 4
transformed-octet-i = original-octet-i XOR masking-key-octet-j
</pre>

<p>
フレーミングの中で
<code class="ABNF">frame-payload-length</code>
により指示されるペイロードの長さは、マスキングキーの長さを内包<em>しない</em>。
それは、 <a>Payload データ</a>の長さであり，マスキングキーに後続するバイトの個数である。
<span lang="en">
The payload length, indicated in the framing as frame-payload-length, does NOT include the length of the masking key. It is the length of the "Payload data", e.g., the number of bytes following the masking key.
</span></p>

	</section>
	<section id="section-5.4">

<h3 title="Fragmentation">5.4. 断片化</h3>

<p>
断片化の主な目的は、メッセージが開始される際に，メッセージのバッファを要することなく，未知サイズのメッセージを送信できるようにする所にある。
仮にメッセージを断片化できないとした場合、端点は，最初のバイトが送信される前にその長さを数え上げるため, メッセージ全体をバッファしなければならなくなる。
断片化が可能であれば、サーバや中継点は、バッファを適度なサイズにした上で，バッファが満杯になり次第, 断片をネットワークに書き出せるようになる。
<span lang="en">
The primary purpose of fragmentation is to allow sending a message that is of unknown size when the message is started without having to buffer that message. If messages couldn't be fragmented, then an endpoint would have to buffer the entire message so its length could be counted before the first byte is sent. With fragmentation, a server or intermediary may choose a reasonable size buffer and, when the buffer is full, write a fragment to the network.
</span></p>

<p>
断片化の第二のユースケースは、多重化にある。
巨大なメッセージを１個の論理チャンネル上に流して，出力チャンネルを占有させるのは好ましくないので。
<!--  -->
多重化においては、出力チャンネルの共有を適化できるように，メッセージをより小さな断片に自由に分割できる必要がある。
（この文書では多重化­拡張については述べられないことに注意。）
<span lang="en">
A secondary use-case for fragmentation is for multiplexing, where it is not desirable for a large message on one logical channel to monopolize the output channel, so the multiplexing needs to be free to split the message into smaller fragments to better share the output channel. (Note that the multiplexing extension is not described in this document.)
</span></p>

<p>
拡張から特に指定されない限り，フレーム<span class="trans-note">【断片­化のされ方】</span>は意味論を持たない。
中継点は、拡張がクライアント↔サーバ間で折衝されていない場合、あるいは何らかの拡張が折衝されていても，中継点が 折衝されているすべての拡張について解せる, かつ これらの拡張の存在下においてフレームの合併や分割の仕方を知っている場合は、フレームの合併や分割を行い得る。
このことから、拡張の不在の下では，送信側と受信側は, 特定のフレーム境界の有無に依存してはならないことになる。
<span lang="en">
Unless specified otherwise by an extension, frames have no semantic meaning. An intermediary might coalesce and/or split frames, if no extensions were negotiated by the client and the server or if some extensions were negotiated, but the intermediary understood all the extensions negotiated and knows how to coalesce and/or split frames in the presence of these extensions. One implication of this is that in absence of extensions, senders and receivers must not depend on the presence of specific frame boundaries.
</span></p>

<p>
次の規則が断片化に適用される：
<span lang="en">
The following rules apply to fragmentation:
</span></p>

<ul>
	<li>
断片化されていないメッセージは、
FIN ビットがセットされ（ <a>5.2 節</a> ）, opcode が 0 以外にされた，単独のフレームからなる。
<span lang="en">
An unfragmented message consists of a single frame with the FIN bit set (Section 5.2) and an opcode other than 0.
</span></li>

	<li>
<p>
断片化されたメッセージは、
FIN ビットがクリアされ, opcode が 0 以外にされた，１個のフレームから始まり、
FIN ビットがクリアされ, opcode が 0 にされた，０個以上のフレームが後続し、
FIN ビットがセットされ, opcode が 0 にされた，１個のフレームで終了する。
断片化されたメッセージは、概念的には、断片のペイロードを順に連結したペイロードを持つ，単独のより大きなメッセージと等価である。
しかしながら，拡張の存在下では、拡張が <a>Extension データ</a>の解釈を定義するので，これは成り立たない。
例えば、
<a>Extension データ</a>が最初の断片にのみ在って，後続の断片にも適用されるかもしれないし、それぞれの断片ごとに，その断片のみに適用される <a>Extension データ</a>が在るかもしれない。
<a>Extension データ</a>が不在の場合の断片化の様態を次の例に示す：
<span lang="en">
A fragmented message consists of a single frame with the FIN bit clear and an opcode other than 0, followed by zero or more frames with the FIN bit clear and the opcode set to 0, and terminated by a single frame with the FIN bit set and an opcode of 0. A fragmented message is conceptually equivalent to a single larger message whose payload is equal to the concatenation of the payloads of the fragments in order; however, in the presence of extensions, this may not hold true as the extension defines the interpretation of the "Extension data" present. For instance, "Extension data" may only be present at the beginning of the first fragment and apply to subsequent fragments, or there may be "Extension data" present in each of the fragments that applies only to that particular fragment. In the absence of "Extension data", the following example demonstrates how fragmentation works.
</span></p>


<p class="example">例：
３個の断片として送信されるテキスト メッセージにおいては、
最初の断片は opcode が 0x1 に, FIN ビットはクリアされ、
２番目の断片は opcode が 0x0 に, FIN ビットはクリアされ、
３番目の断片は opcode が 0x0 に, FIN ビットはセットされることになる。
<span lang="en">
EXAMPLE: For a text message sent as three fragments, the first fragment would have an opcode of 0x1 and a FIN bit clear, the second fragment would have an opcode of 0x0 and a FIN bit clear, and the third fragment would have an opcode of 0x0 and a FIN bit that is set.
</span></p>


	</li>
	<li>
断片化されたメッセージの合間に制御フレーム（ <a>5.5 節</a> を見よ）が挿入されても<em class="rfc2119">よい</em>。
制御フレーム自身は断片化されては<em class="rfc2119">ならない</em>。
<span lang="en">
Control frames (see Section 5.5) MAY be injected in the middle of a fragmented message. Control frames themselves MUST NOT be fragmented.
</span></li>

	<li>
メッセージの断片は、送信側から送信された順序で受信先に送達されなければ<em class="rfc2119">ならない</em>。
<span lang="en">
Message fragments MUST be delivered to the recipient in the order sent by the sender.
</span></li>

	<li>
あるメッセージに属するいくつかの断片と別のメッセージに属するいくつかの断片とが、互いに交互挿入されては<em class="rfc2119">ならない</em>。
ただし、拡張が折衝されていて，それにより交互挿入が解釈可能になっている場合を除く。
<span lang="en">
The fragments of one message MUST NOT be interleaved between the fragments of another message unless an extension has been negotiated that can interpret the interleaving.
</span></li>

	<li>
端点は、断片化されたメッセージの合間に挟まれた制御フレームを取り扱えなければ<em class="rfc2119">ならない</em>。
<span lang="en">
An endpoint MUST be capable of handling control frames in the middle of a fragmented message.
</span></li>

	<li>
送信側は、非­制御メッセージに対しては，任意サイズの断片を作成して<em class="rfc2119">よい</em>。
<span lang="en">
A sender MAY create fragments of any size for non-control messages.
</span></li>

	<li>
クライアントとサーバは、断片化されたメッセージと断片化されていないメッセージのいずれの受信もサポートしなければ<em class="rfc2119">ならない</em>。
<span lang="en">
Clients and servers MUST support receiving both fragmented and unfragmented messages.
</span></li>

	<li>
制御フレームは断片化され得ないので、中継点は、制御フレームの断片化の様態に変更を試みては<em class="rfc2119">ならない</em>。
<span lang="en">
As control frames cannot be fragmented, an intermediary MUST NOT attempt to change the fragmentation of a control frame.
</span></li>

	<li>
中継点は、いずれかの<a href="#data-RSV" >予約済み<!--1-->ビット</a>値が用いられていて, かつ これらの値の意味を知らない場合、メッセージの断片化の様態を変更しては<em class="rfc2119">ならない</em>。
<span lang="en">
An intermediary MUST NOT change the fragmentation of a message if any reserved bit values are used and the meaning of these values is not known to the intermediary.
</span></li>

	<li>
中継点は、拡張が折衝されていて, かつ 折衝された拡張の意味論に通じていないならば、接続の文脈下のどのメッセージの断片化の様態も変更しては<em class="rfc2119">ならない</em>。
同様に， WebSocket 接続により生じた WebSocket ハンドシェイクを見ない（したがって、その内容についても通知されていない）中継点は、その種の接続のどのメッセージの断片化の様態も変更しては<em class="rfc2119">ならない</em>。
<span lang="en">
An intermediary MUST NOT change the fragmentation of any message in the context of a connection where extensions have been negotiated and the intermediary is not aware of the semantics of the negotiated extensions. Similarly, an intermediary that didn't see the WebSocket handshake (and wasn't notified about its content) that resulted in a WebSocket connection MUST NOT change the fragmentation of any message of such connection.
</span></li>

	<li>
これらの規則の帰結として、同じメッセージに属する すべての断片の種別は，それらの最初の断片の opcode で設定された種別と同じに揃うことになる。
<!--  -->
制御フレームは断片化できないので、同じメッセージに属するすべての断片の種別は、［
テキスト, バイナリ, ［
いずれかの予約済み<!--1--> opcode
］］のいずれかに揃えられなければ<em class="rfc2119">ならない</em>。
<span lang="en">
As a consequence of these rules, all fragments of a message are of the same type, as set by the first fragment's opcode. Since control frames cannot be fragmented, the type for all fragments in a message MUST be either text, binary, or one of the reserved opcodes.
</span></li>
</ul>

<p class="note">注記：
仮に制御フレームを挿入できないとした場合、例えば， ping の待ち時間は、大きいメッセージの背後に回されたときに不必要に長くされる。
それゆえ、断片化されたメッセージの合間に挟まれた制御フレームの取り扱いも要件にされている。
<span lang="en">
NOTE: If control frames could not be interjected, the latency of a ping, for example, would be very long if behind a large message. Hence, the requirement of handling control frames in the middle of a fragmented message.
</span></p>

<p class="note">実装に対する注記：
拡張の不在の下では、受信側はフレーム全体をバッファしなくても処理できる。
例えば，ストリーミング API が用いられている場合、フレームの一部をアプリケーションに送達できる。
しかしながら、この前提は，将来のどの WebSocket 拡張においても成立するとは限らないことに注意。
<span lang="en">
IMPLEMENTATION NOTE: In the absence of any extension, a receiver doesn't have to buffer the whole frame in order to process it. For example, if a streaming API is used, a part of a frame can be delivered to the application. However, note that this assumption might not hold true for all future WebSocket extensions.
</span></p>

	</section>
	<section id="section-5.5">

<h3 title="Control Frames">5.5. 制御フレーム</h3>

<p>
制御フレームは， opcode の最上位ビットが 1 かどうかで識別される。
制御フレームに対し現時点で定義済みの opcode には、 0x8 （ Close ）, 0x9 （ Ping ）, 0xA （ Pong ）がある。
0xB 〜 0xF の opcode はまだ定義されていないが、追加の制御フレームのために予約済み<!--1-->である。
<span lang="en">
Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Opcodes 0xB-0xF are reserved for further control frames yet to be defined.
</span></p>

<p>
制御フレームは，WebSocket の状態について通信するために用いられる。
制御フレームは，断片化されたメッセージの合間に挿入できる。
<span lang="en">
Control frames are used to communicate state about the WebSocket. Control frames can be interjected in the middle of a fragmented message.
</span></p>

<p>
すべての制御フレームは、ペイロードの長さが 125 バイト以下でなければ<em class="rfc2119">ならず</em>，断片化されては<em class="rfc2119">ならない</em>。
<span lang="en">
All control frames MUST have a payload length of 125 bytes or less and MUST NOT be fragmented.
</span></p>

		<section id="section-5.5.1">

<h4 title="Close">5.5.1. Close</h4>

<p>
Close フレームは opcode 0x8 を持つ。
<span lang="en">
The Close frame contains an opcode of 0x8.
</span></p>

<p>
Close フレームは， closing の事由を指示するボディ（フレームの <a>Application データ</a>部分）を含んでも<em class="rfc2119">よい</em>。
例えば：
端点がシャットダウン中にある,
端点が大き過ぎるフレームを受信している,
端点が予期される形式に適合していないフレームを受信した，等々。
ボディが存在する場合、ボディの最初の２バイトは、 <a>7.4 節</a> にて定義される <var>code</var> 値をとるステータスコードを表現する，（ネットワーク­バイト順序で）2 バイトの非負­整数でなければ<em class="rfc2119">ならない</em>。
2 バイト整数に後続して、ボディには， UTF-8 符号化された <var>reason</var> 値のデータが含まれていても<em class="rfc2119">よい</em>。
その解釈はこの仕様では定義されない。
このデータは、人が読めるようにされる必要はないが，デバッグや問題に関わる情報を接続を open したスクリプトに渡すのには有用になり得る。
このデータは 人から読めるものになっている保証はないので、クライアントは末端­利用者にそれを示しては<em class="rfc2119">ならない</em>。
<span lang="en">
The Close frame MAY contain a body (the "Application data" portion of the frame) that indicates a reason for closing, such as an endpoint shutting down, an endpoint having received a frame too large, or an endpoint having received a frame that does not conform to the format expected by the endpoint. If there is a body, the first two bytes of the body MUST be a 2-byte unsigned integer (in network byte order) representing a status code with value /code/ defined in Section 7.4. Following the 2-byte integer, the body MAY contain UTF-8-encoded data with value /reason/, the interpretation of which is not defined by this specification. This data is not necessarily human readable but may be useful for debugging or passing information relevant to the script that opened the connection. As the data is not guaranteed to be human readable, clients MUST NOT show it to end users.
</span></p>

<p>
クライアントからサーバへ送信される Close フレームは、 <a>5.3 節</a> に従ってマスクされなければならない。
<span lang="en">
Close frames sent from client to server must be masked as per Section 5.3.
</span></p>

<p>
アプリケーションは、 Close フレームを送信した後は，それ以上データ­フレームを送信しては<em class="rfc2119">ならない</em>。
<span lang="en">
The application MUST NOT send any more data frames after sending a Close frame.
</span></p>

<p>
Close フレームを受信した端点は、その前に Close フレームを送信していなかったならば，応答として Close フレームを送信しなければ<em class="rfc2119">ならない</em>。
（概して，応答として Close フレームを送信する際は、端点は受信したステータスコードを返す。）
行い得る限り早くする<em class="rfc2119">べき</em>である。
端点は、現在のメッセージの送信を終えるまで，
Close フレームの送信を遅延しても<em class="rfc2119">よい</em>。
（例えば，断片化されたメッセージの大部分をすでに送信していた場合、端点は Close フレームを送信する前に残りの断片を送信しても<em class="rfc2119">よい</em>）。
しかしながら，すでに Close フレームを送信した相手側の端点がデータの処理を続行する保証はない。
<span lang="en">
If an endpoint receives a Close frame and did not previously send a Close frame, the endpoint MUST send a Close frame in response. (When sending a Close frame in response, the endpoint typically echos the status code it received.) It SHOULD do so as soon as practical. An endpoint MAY delay sending a Close frame until its current message is sent (for instance, if the majority of a fragmented message is already sent, an endpoint MAY send the remaining fragments before sending a Close frame). However, there is no guarantee that the endpoint that has already sent a Close frame will continue to process data.
</span></p>

<p>
Close メッセージの送信と受信の両方を終えた端点は、
WebSocket 接続は close されたものと見なして，
下層の TCP 接続を close しなければ<em class="rfc2119">ならない</em>。
サーバは、下層の TCP 接続を即時に close しなければ<em class="rfc2119">ならない</em>。
クライアントは、サーバが接続を close するまで待機する<em class="rfc2119">べき</em>であるが、例えばサーバからの TCP Close を適度な時間内に受信できなかったときなど，
Close メッセージの送信と受信を終えた後に，いつでも接続を close して<em class="rfc2119">よい</em>。
<span lang="en">
After both sending and receiving a Close message, an endpoint considers the WebSocket connection closed and MUST close the underlying TCP connection. The server MUST close the underlying TCP connection immediately; the client SHOULD wait for the server to close the connection but MAY close the connection at any time after sending and receiving a Close message, e.g., if it has not received a TCP Close from the server in a reasonable time period.
</span></p>

<p>
クライアントとサーバの双方が同時に Close メッセージを送信した場合、いずれの端点も Close メッセージを送信し，受信することになる。
この場合も WebSocket 接続が close されたものと見なして，下層の TCP 接続を close すべきである。
<span lang="en">
If a client and server both send a Close message at the same time, both endpoints will have sent and received a Close message and should consider the WebSocket connection closed and close the underlying TCP connection.
</span></p>

		</section>
		<section id="section-5.5.2">

<h4 title="Ping">5.5.2. Ping</h4>

<p>
Ping フレームは opcode 0x9 を持つ。
<span lang="en">
The Ping frame contains an opcode of 0x9.
</span></p>

<p>
Ping フレームは <a>Application データ</a>を内包しても<em class="rfc2119">よい</em>。
<span lang="en">
A Ping frame MAY include "Application data".
</span></p>

<p>
端点が Ping フレームを受領した際には、すでに Close フレームを受信していない限り，応答として Pong フレームを送信しなければ<em class="rfc2119">ならない</em>。
行い得る限り早く， Pong フレームで応答する<em class="rfc2119">べき</em>である。
Pong フレームについては <a>5.5.3 節</a> にて論じられる。
<span lang="en">
Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in response, unless it already received a Close frame. It SHOULD respond with Pong frame as soon as is practical. Pong frames are discussed in Section 5.5.3.
</span></p>

<p>
端点は、接続が確立されてから，接続が close されるまで、いつでも，
Ping フレームを送信して<em class="rfc2119">よい</em>。
<span lang="en">
An endpoint MAY send a Ping frame any time after the connection is established and before the connection is closed.
</span></p>

<p class="note">注記：
Ping フレームは、接続維持（ keepalive ）, あるいはリモートの端点がまだ応答可能かどうかの検証に用をなし得る。
<span lang="en">
NOTE: A Ping frame may serve either as a keepalive or as a means to verify that the remote endpoint is still responsive.
</span></p>

		</section>
		<section id="section-5.5.3">

<h4 title="Pong">5.5.3. Pong</h4>

<p>
Pong フレームは opcode 0xA を持つ。
<span lang="en">
The Pong frame contains an opcode of 0xA.
</span></p>

<p>
Ping および Pong フレームに適用される要件の詳細は <a>5.5.2 節</a> に述べられている。
<span lang="en">
Section 5.5.2 details requirements that apply to both Ping and Pong frames.
</span></p>

<p>
Ping フレームに対する応答として送信される Pong フレームの <a>Application データ</a>は、返信­対象の Ping フレームのメッセージ­ボディのそれと同一でなければならない。
<span lang="en">
A Pong frame sent in response to a Ping frame must have identical "Application data" as found in the message body of the Ping frame being replied to.
</span></p>

<p>
Ping フレームを受信した端点は、より以前の Ping フレームに対する Pong フレームをまだ応答として送信していない場合、直近に処理された Ping フレームに対する Pong フレームのみの送信を採択しても<em class="rfc2119">よい</em>。
<span lang="en">
If an endpoint receives a Ping frame and has not yet sent Pong frame(s) in response to previous Ping frame(s), the endpoint MAY elect to send a Pong frame for only the most recently processed Ping frame.
</span></p>

<p>
Pong フレームは，請求が無いときに送信されても<em class="rfc2119">よい</em>。
これは、単方向の鼓動として機能する。
請求されていない Pong フレームに対する応答は予期されていない。
<span lang="en">
A Pong frame MAY be sent unsolicited. This serves as a unidirectional heartbeat. A response to an unsolicited Pong frame is not expected.
</span></p>

		</section>
	</section>
	<section id="section-5.6">

<h3 title="Data Frames">5.6. データ­フレーム</h3>

<p>
データ­フレーム（すなわち，非­制御フレーム）は、 opcode の最上位ビットが 0 かどうかで識別される。 
現時点でデータ­フレームに定義されている opcode は、
0x1 （ Text ）, 0x2 （ Binary ）
<span class="trans-note">【
および 0x00 （ Continuation ）†
】</span>
である。
opcode 0x3 〜 0x7 はまだ定義されていないが，追加の非­制御フレームのために予約済み<!--1-->である。
<span lang="en">
Data frames (e.g., non-control frames) are identified by opcodes where the most significant bit of the opcode is 0. Currently defined opcodes for data frames include 0x1 (Text), 0x2 (Binary). Opcodes 0x3-0x7 are reserved for further non-control frames yet to be defined.
</span></p>

<p>
データ­フレームはアプリケーション層や拡張­層のデータを運ぶ。
opcode はデータの解釈を決定する：
<span lang="en">
Data frames carry application-layer and/or extension-layer data. The opcode determines the interpretation of the data:
</span></p>

<dl class="defs">
	<dt id="data-Text">Text</dt>
	<dd>
<a>Payload データ</a>は UTF-8 に符号化されたテキスト­データである。
個々のテキスト­フレームは部分的な UTF-8 の並びを内包し得るが、メッセージ全体としては妥当な UTF-8 を含まなければ<em class="rfc2119">ならない</em>ことに注意。
再構築されたメッセージにおいて妥当でない UTF-8 は、
<a>8.1 節</a> の記述に従って取り扱われる。
<span lang="en">
The "Payload data" is text data encoded as UTF-8. Note that a particular text frame might include a partial UTF-8 sequence; however, the whole message MUST contain valid UTF-8. Invalid UTF-8 in reassembled messages is handled as described in Section 8.1.
</span></dd>

	<dt id="data-Binary">Binary</dt>
	<dd>
<a>Payload データ</a>は任意のバイナリ­データであり、その解釈はもっぱら
アプリケーション層に委ねられる。
<span lang="en">
The "Payload data" is arbitrary binary data whose interpretation is solely up to the application layer.
</span></dd>

	<dt id="data-Continuation">Continuation</dt>
	<dd class="trans-note">【†
この項目は，
<a href="http://www.rfc-editor.org/errata_search.php?rfc=6455&amp;eid=4672">正誤表</a>による追加であり（ Reported — まだ Verified ではない）、そこでは，
“仕様の他所との整合性をとるためには、 Continuation フレーム（継続フレーム）は，データ­フレームに分類されるべき”
と述べられている。
】</dd>
	<dd class="trans-note">
このフレーム（ opcode 0x00 ）には、常に，FIN ビットがクリアされた
Text／Binary フレームが先行する（ <a>5.2 節</a>を見よ）。
<a>Payload データ</a>は、同じメッセージの，直前に伝送された Text／Binary フレームの次の断片（ <a>5.4 節</a>を見よ）を包含し、メッセージの最初の断片と同じ仕方で解釈されなければ<em class="rfc2119">ならない</em>。
<span lang="en">
These frames MUST be always preceeded by either Text or Binary frame with FIN bit clear (See Section 5.2). The "Payload data" contains next fragment (See section 5.4) of the message whose transmission were opened by the latest Text or Binary frame and MUST be interpreted in the same way as the initial fragment of the message.
】</span></dd>

</dl>


	</section>
	<section id="section-5.7">

<h3 title="Examples">5.7. 例</h3>

<ul><!-- class="EXAMPLE" -->
	<li><p>マスクされていないテキスト­メッセージを含む単独のフレーム：
<span lang="en">A single-frame unmasked text message</span></p>
<pre class="example">
0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f <span title="(contains &quot;Hello&quot;)"
>（ "Hello" を含む）</span></pre>
	</li>
	<li><p>マスクされたテキスト­メッセージを含む単独のフレーム：
<span lang="en">A single-frame masked text message</span></p>
<pre class="example">
0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 <span title="(contains &quot;Hello&quot;)"
>（ "Hello" を含む）</span></pre>
	</li>
	<li><p>断片化されたマスクされていないテキスト­メッセージ：
<span lang="en">A fragmented unmasked text message</span></p>
<pre class="example">
0x01 0x03 0x48 0x65 0x6c <span title="(contains &quot;Hello&quot;)"
>（ "Hel" を含む）</span>
0x80 0x02 0x6c 0x6f <span title="(contains &quot;lo&quot;)"
>（ "lo" を含む）</span></pre>
	</li>
	<li><p>マスクされていない Ping リクエストとマスクされた <del>Ping</del> <ins>Pong</ins> 応答：
<span class="trans-note">【<a href="http://www.rfc-editor.org/errata_search.php?rfc=6455">正誤表</a>による修正（ Held for Document Update ）】</span>
<span lang="en">Unmasked Ping request and masked <del>Ping</del><ins>Pong</ins> response</span></p>
<pre class="example">
0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f
<span title="(contains a body of &quot;Hello&quot;, but the contents of the body are arbitrary)"
>（ "Hello" をボディに含むが，ボディの中身は任意）</span>
0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58
<span title="(contains a body of &quot;Hello&quot;, matching the body of the ping)"
>（ ping のボディに合致する "Hello" をボディに含む）</span></pre>
	</li>
	<li><p>256 バイトのバイナリ­メッセージを含む単独のマスクされていないフレーム：
<span lang="en">256 bytes binary message in a single unmasked frame</span></p>
<pre class="example">
0x82 0x7E 0x0100 <span title="[256 bytes of binary data]"
>[256 バイトのバイナリ­データ]</span></pre>
	</li>
	<li><p>64Kb のバイナリ­メッセージを含む単独のマスクされていないフレーム：
<span lang="en">64KiB binary message in a single unmasked frame</span></p>
<pre class="example">
0x82 0x7F 0x0000000000010000 <span title="[65536 bytes of binary data]"
>[65536 バイトのバイナリ­データ]</span></pre>
	</li>
</ul>

	</section>
	<section id="section-5.8">

<h3 title="Extensibility">5.8. 拡張性</h3>

<div class="p">
<p>
このプロトコルは基本のプロトコルに機能を追加する拡張が許容されるように設計されている。
接続の端点は、利用する拡張があれば，
opening ハンドシェイクの間に折衝しなければ<em class="rfc2119">ならない</em>。
この仕様は、次のものを拡張­用途に提供する：
</p>
<ul>
	<li>
opcode 0x3 〜 0x7, 0xB 〜 0xF
</li>
	<li>
<a>Extension データ</a>フィールド
</li>
	<li>
フレームヘッダの
<code class="ABNF">frame-rsv1</code>,
<code class="ABNF">frame-rsv2</code>,
<code class="ABNF">frame-rsv3</code>
ビット
<span class="trans-note">【“予約済み<!--1-->ビット”】</span>
</li>
</ul>

<p >
拡張の折衝についての詳細は、 <a>9.1 節</a> にて論じられる。
予想される拡張の利用の一部を以下に挙げる。
このリストは完全なものでも，規範的なものでもない。
</p>

<span lang="en">
The protocol is designed to allow for extensions, which will add capabilities to the base protocol. The endpoints of a connection MUST negotiate the use of any extensions during the opening handshake. This specification provides opcodes 0x3 through 0x7 and 0xB through 0xF, the "Extension data" field, and the frame-rsv1, frame-rsv2, and frame-rsv3 bits of the frame header for use by extensions. The negotiation of extensions is discussed in further detail in Section 9.1. Below are some anticipated uses of extensions. This list is neither complete nor prescriptive.
</span></div>

<ul>
	<li>
<a>Extension データ</a>を <a>Payload データ</a>の中で <a>Application データ</a>の前に置いてよい。
<span lang="en">
"Extension data" may be placed in the "Payload data" before the "Application data".
</span></li>
	<li>
<a href="#data-RSV" >予約済み<!--1-->ビット</a>はフレームごとに必要に応じて配分できる。
<span lang="en">
Reserved bits can be allocated for per-frame needs.
</span></li>
	<li>
予約済み<!--1--> opcode 値を定義することができる。
<span lang="en">
Reserved opcode values can be defined.
</span></li>
	<li>
より多くの opcode 値が必要であれば、<a href="#data-RSV" >予約済み<!--1-->ビット</a>を opcode フィールドに配分できる。
<span lang="en">
Reserved bits can be allocated to the opcode field if more opcode values are needed.
</span></li>
	<li>
<a href="#data-RSV" >予約済み<!--1-->ビット</a>や “拡張”  opcode を、より大きな opcode やより多くのフレームごとのビットを定義するために，
<a>Payload データ</a>の外
<span class="trans-note">【？】</span>
に追加のビットを配分することにより、定義することができる。
<span lang="en">
A reserved bit or an "extension" opcode can be defined that allocates additional bits out of the "Payload data" to define larger opcodes or more per-frame bits.
</span></li>
</ul>

	</section>
</section>
<section id="section-6">

<h2 title="Sending and Receiving Data">6. データの送信と受信</h2>

	<section id="section-6.1">

<h3 title="Sending Data">6.1. データの送信</h3>

<p>
WebSocket 接続を通して， <var>data</var> から構成される
<dfn class="term-def" id="dfn-to-send">WebSocket メッセージを送信する</dfn>
ときは、端点は，次の手続きを行わなければ<em class="rfc2119">ならない</em>。
<span lang="en">
To _Send a WebSocket Message_ comprising of /data/ over a WebSocket connection, an endpoint MUST perform the following steps.
</span></p>

<ol>

<!-- 1 -->
	<li>
端点は、 WebSocket 接続の
<a class="dfnref" href="#dfn-OPEN-state">OPEN 状態</a>
を確保しなければ<em class="rfc2119">ならない</em>（ <a>4.1 節</a>, <a>4.2.2 節</a> 参照）。
いつの時点においても， WebSocket 接続の状態が変化した場合、端点は以下の手続きを中止しなければ<em class="rfc2119">ならない</em>。
<!-- 変更 -->
<span lang="en">
The endpoint MUST ensure the WebSocket connection is in the OPEN state (cf. Sections 4.1 and 4.2.2.) If at any point the state of the WebSocket connection changes, the endpoint MUST abort the following steps.
</span></li>
<!-- 2 -->
	<li>
端点は、 WebSocket フレーム内の <var>data</var> を <a>5.2 節</a> の定義に従って，カプセル化しなければ<em class="rfc2119">ならない</em>。
送信されるデータが大きいとき, あるいは 端点がデータ送信の開始を望む時点では まだデータ全体が可用になっていない場合、端点は，代わりに <a>5.4 節</a> の定義に従って，データを一連のフレームにカプセル化しても<em class="rfc2119">よい</em>。
<span lang="en">
An endpoint MUST encapsulate the /data/ in a WebSocket frame as defined in Section 5.2. If the data to be sent is large or if the data is not available in its entirety at the point the endpoint wishes to begin sending the data, the endpoint MAY alternately encapsulate the data in a series of frames as defined in Section 5.4.
</span></li>
<!-- 3 -->
	<li>
データを含んでいる最初のフレームの opcode （ <code class="ABNF">frame-opcode</code> ）は、テキストまたはバイナリ­データとして 受信先に解釈されることになるデータに適切な， <a>5.2 節</a> による値に設定されなければ<em class="rfc2119">ならない</em>。
<span lang="en">
The opcode (frame-opcode) of the first frame containing the data MUST be set to the appropriate value from Section 5.2 for data that is to be interpreted by the recipient as text or binary data.
</span></li>
<!-- 4 -->
	<li>
データを含んでいる最後のフレームの FIN ビット（ <code class="ABNF">frame-fin</code> ）は、 <a>5.2 節</a> の定義に従って，
1 にされなければ<em class="rfc2119">ならない</em>。
<span lang="en">
The FIN bit (frame-fin) of the last frame containing the data MUST be set to 1 as defined in Section 5.2.
</span></li>
<!-- 5 -->
	<li>
データがクライアントから送信される場合、その各フレームは，
<a>5.3 節</a> の定義に従って，マスクされなければ<em class="rfc2119">ならない</em>。
<span lang="en">
If the data is being sent by the client, the frame(s) MUST be masked as defined in Section 5.3.
</span></li>
<!-- 6 -->
	<li>
WebSocket 接続において，何らかの拡張（ <a>9 節</a> ）が折衝されている場合、それらの拡張の定義に従って，追加の考慮点が適用され得る。
<span lang="en">
If any extensions (Section 9) have been negotiated for the WebSocket connection, additional considerations may apply as per the definition of those extensions.
</span></li>
<!-- 7 -->
	<li>
形成済みの各フレームは、下層のネットワーク接続を通して伝送されなければ<em class="rfc2119">ならない</em>。
<span lang="en">
The frame(s) that have been formed MUST be transmitted over the underlying network connection.
</span></li>

</ol>

	</section>
	<section id="section-6.2">

<h3 title="Receiving Data">6.2. データの受信</h3>

<p>
端点は、 WebSocket データを受信するために，下層のネットワーク接続をリッスンする。
着信データは、 <a>5.2 節</a> の定義に従って， WebSocket フレームとして構文解析されなければ<em class="rfc2119">ならない</em>。
制御フレーム（ <a>5.5 節</a> ）が受信された際には、 <a>5.5 節</a> の定義に従って，取り扱わなければ<em class="rfc2119">ならない</em>。
端点は、データ­フレームの受信（ <a>5.6 節</a> ）に際し，
<a>5.2 節</a> にて opcode （ <code class="ABNF">frame-opcode</code> ）に定義された，データの <var>type</var> を記録しておかなければ<em class="rfc2119">ならない</em>。
このフレームの <a>Application データ</a>がメッセージの <var>data</var> として定義される。
フレームが断片化されていないメッセージ（ <a>5.4 節</a> ）を構成する場合、種別 <var>type</var>，データ <var>data</var> の
<dfn class="term-def" id="dfn-received">WebSocket メッセージが受信された</dfn>
と言う。
フレームが断片化されたメッセージの一部である場合、 <var>data</var> を形成するために、後続のデータ­フレームからの <a>Application データ</a>が連結される。
FIN ビット（ <code class="ABNF">frame-fin</code> ）で指示される最後の断片が受信されたとき、（断片の <a>Application データ</a>の連結により構成される）データ <var>data</var> と（断片化されたメッセージの最初のフレームで記録された）種別 <var>type</var> の
<dfn class="term-def">WebSocket メッセージが受信された</dfn>
と言う。
後続のデータ­フレームは、新たな WebSocket メッセージに属するものとして，解釈されなければ<em class="rfc2119">ならない</em>。
<span lang="en">
To receive WebSocket data, an endpoint listens on the underlying network connection. Incoming data MUST be parsed as WebSocket frames as defined in Section 5.2. If a control frame (Section 5.5) is received, the frame MUST be handled as defined by Section 5.5. Upon receiving a data frame (Section 5.6), the endpoint MUST note the /type/ of the data as defined by the opcode (frame-opcode) from Section 5.2. The "Application data" from this frame is defined as the /data/ of the message. If the frame comprises an unfragmented message (Section 5.4), it is said that _A WebSocket Message Has Been Received_ with type /type/ and data /data/. If the frame is part of a fragmented message, the "Application data" of the subsequent data frames is concatenated to form the /data/. When the last fragment is received as indicated by the FIN bit (frame-fin), it is said that _A WebSocket Message Has Been Received_ with data /data/ (comprised of the concatenation of the "Application data" of the fragments) and type /type/ (noted from the first frame of the fragmented message). Subsequent data frames MUST be interpreted as belonging to a new WebSocket message.
</span></p>

<p>
拡張（ <a>9 節</a> ）は、特に何がメッセージ境界をなすのかも含めて，データの読み取り方の意味論を変更しても<em class="rfc2119">よい</em>。
拡張は、ペイロードの中の <a>Application データ</a>の前に <a>Extension データ</a>を追加することに加えて， <a>Application データ</a>に（圧縮などの）手を加えても<em class="rfc2119">よい</em>。
<span lang="en">
Extensions (Section 9) MAY change the semantics of how data is read, specifically including what comprises a message boundary. Extensions, in addition to adding "Extension data" before the "Application data" in a payload, MAY also modify the "Application data" (such as by compressing it).
</span></p>

<p>
サーバは、クライアントから受信したデータ­フレームのマスクを，
<a>5.3 節</a> に従って除去しなければ<em class="rfc2119">ならない</em>。
<span lang="en">
A server MUST remove masking for data frames received from a client as described in Section 5.3.
</span></p>


	</section>
</section>
<section id="section-7">

<h2 title="Closing the Connection">7. 接続の closing</h2>

	<section id="section-7.1">

<h3 title="Definitions">7.1. 定義</h3>

		<section id="section-7.1.1">

<h4 title="Close the WebSocket Connection">7.1.1. WebSocket 接続を close する</h4>

<p>
<dfn class="term-def" id="dfn-to-close">WebSocket 接続を close する</dfn>ときは、端点は，下層の TCP 接続を close する。
端点は、 TLS セッションも含め， clean に TCP 接続を close するメソッドを用いる<em class="rfc2119">べき</em>である。
適用可能ならば，受信された後続のバイトも破棄する。
端点は、攻撃されたときなど，どうしても必要ならば，接続を close して<em class="rfc2119">よい</em>。
<!--  -->
<span lang="en">
To _Close the WebSocket Connection_, an endpoint closes the underlying TCP connection. An endpoint SHOULD use a method that cleanly closes the TCP connection, as well as the TLS session, if applicable, discarding any trailing bytes that may have been received. An endpoint MAY close the connection via any means available when necessary, such as when under attack.
</span></p>

<p>
下層の TCP 接続は、ほとんどの通常の事例では，サーバが TIME_WAIT 状態を保持するようにするため、クライアントではなく，まずサーバから close される<em class="rfc2119">べき</em>である。
（これにより、最大セグメント寿命の２倍の期間（ 2MSL — 2 maximum segment lifetime ）、サーバは接続を再 open しないようになる,
~while<!--  -->
より高い seq 番号による新たな SYN に際しては， TIME_WAIT 接続が即時に再 open されるので、対応するサーバへの影響は存在しない
<span class="trans-note">【？】</span>
）。
異常な事例においては（適度な時間内にサーバから TCP Close を受信していないときなど）クライアントから TCP Close を起動しても<em class="rfc2119">よい</em>。
そのようなわけで、サーバが
<a class="dfnref" href="#dfn-to-close">WebSocket 接続を close する</a>
指示を受けたときは，即時に TCP Close を起動する<em class="rfc2119">べき</em>であり、クライアントが同じ指示を受けたときは，サーバからの TCP Close を待機する<em class="rfc2119">べき</em>である。
<span lang="en">
The underlying TCP connection, in most normal cases, SHOULD be closed first by the server, so that it holds the TIME_WAIT state and not the client (as this would prevent it from re-opening the connection for 2 maximum segment lifetimes (2MSL), while there is no corresponding server impact as a TIME_WAIT connection is immediately reopened upon a new SYN with a higher seq number). In abnormal cases (such as not having received a TCP Close from the server after a reasonable amount of time) a client MAY initiate the TCP Close. As such, when a server is instructed to _Close the WebSocket Connection_ it SHOULD initiate a TCP Close immediately, and when a client is instructed to do the same, it SHOULD wait for a TCP Close from the server.
</span></p>

<div>
<p>
Berkeley ソケットを利用して， clean な closure を得るための、 C 言語による例：
</p>

<ol>
	<li>
<code class="code">SHUT_WR</code> を引数に，ソケットに対し <code class="code">shutdown()</code> を呼び出す。
</li>

	<li>
値 0 が返されるまで， <code class="code">recv()</code> を呼び出す。
（値 0 はピアがきちんと shutdown を行ったことを指示する）
</li>

	<li>
ソケットに対し <code class="code">close()</code> を呼び出す。
</li>
</ol>

<p lang="en">
As an example of how to obtain a clean closure in C using Berkeley sockets, one would call shutdown() with SHUT_WR on the socket, call recv() until obtaining a return value of 0 indicating that the peer has also performed an orderly shutdown, and finally call close() on the socket.
</p>
</div>

		</section>
		<section id="section-7.1.2">

<h4 title="Start the WebSocket Closing Handshake">7.1.2. WebSocket closing ハンドシェイクを開始する</h4>

<p>
ステータスコード（ <a>7.4 節</a> ） <var>code</var>, および
オプションの close 事由（ <a>7.1.6 節</a> ） <var>reason</var> をパラメタに
<dfn class="term-def" id="dfn-to-start-closing-handshake">WebSocket closing ハンドシェイクを開始する</dfn>
ときは、端点は <a>5.5.1 節</a> の記述に従って，ステータスコードが <var>code</var> にされ, close 事由が <var>reason</var> にされた，
Close 制御フレームを送信しなければ<em class="rfc2119">ならない</em>。
いったん，端点が Close 制御フレームを送信し, 受信したなら、その端点は <a>7.1.1 節</a> の定義に従って，
<a class="dfnref" href="#dfn-to-close">WebSocket 接続を close する</a>
<em class="rfc2119">べき</em>である。
<span lang="en">
To _Start the WebSocket Closing Handshake_ with a status code (Section 7.4) /code/ and an optional close reason (Section 7.1.6) /reason/, an endpoint MUST send a Close control frame, as described in Section 5.5.1, whose status code is set to /code/ and whose close reason is set to /reason/. Once an endpoint has both sent and received a Close control frame, that endpoint SHOULD _Close the WebSocket Connection_ as defined in Section 7.1.1.
</span></p>


		</section>
		<section id="section-7.1.3">

<h4 title="The WebSocket Closing Handshake is Started">7.1.3. WebSocket closing ハンドシェイクが開始された</h4>

<p>
Close 制御フレームを送信または受信したとき，
<dfn class="term-def" id="dfn-closing-handshake-started">WebSocket closing ハンドシェイクが開始された</dfn>
と言い、その WebSocket 接続は
<dfn class="term-def" id="dfn-CLOSING-state">CLOSING 状態</dfn>
に入る。
<span lang="en">
Upon either sending or receiving a Close control frame, it is said that _The WebSocket Closing Handshake is Started_ and that the WebSocket connection is in the CLOSING state.
</span></p>

		</section>
		<section id="section-7.1.4">

<h4 title="The WebSocket Connection is Closed">7.1.4. WebSocket 接続が close された</h4>

<p>
下層の TCP 接続が close されたとき，
<dfn class="term-def" id="dfn-closed">WebSocket 接続は close された</dfn>
と言い、その WebSocket 接続は
<dfn class="term-def" id="dfn-CLOSED-state">CLOSED 状態</dfn>
に入る。
WebSocket closing ハンドシェイクの完了後，
TCP 接続が close された場合、 WebSocket 接続は
<dfn class="term-def" id="dfn-closed-cleanly">clean に</dfn>
close されたと言う。
<span lang="en">
When the underlying TCP connection is closed, it is said that _The WebSocket Connection is Closed_ and that the WebSocket connection is in the CLOSED state. If the TCP connection was closed after the WebSocket closing handshake was completed, the WebSocket connection is said to have been closed _cleanly_.
</span></p>

<p>
WebSocket 接続が確立できなかったときも
<a class="dfnref" href="#dfn-closed">WebSocket 接続は close された</a>
と言うが、
<a class="dfnref" href="#dfn-closed-cleanly">clean に</a>
とは言わない。
<span lang="en">
If the WebSocket connection could not be established, it is also said that _The WebSocket Connection is Closed_, but not _cleanly_.
</span></p>

		</section>
		<section id="section-7.1.5">

<h4 title="The WebSocket Connection Close Code">7.1.5. WebSocket 接続の close コード</h4>

<p>
<a>5.5.1 節</a>, <a>7.4 節</a> にて定義されるように、
Close 制御フレームは， closure の事由を指示するステータスコードを含み得る。
WebSocket 接続の closing は，いずれの端点からも（同時の可能性も含めて）起動され得る。
<dfn class="term-def" id="dfn-close-code">WebSocket 接続の close コード</dfn>
は、このプロトコルを実装しているアプリケーションが最初に受信した Close 制御フレームに含まれているステータスコード（ <a>7.4 節</a> ）として定義される。
この Close 制御フレームがステータスコードを含んでいない場合、
<a class="dfnref" href="#dfn-close-code">WebSocket 接続の close コード</a>
は 1005 であるものと見なされる。
<a class="dfnref" href="#dfn-closed">WebSocket 接続が close されて</a>
いて、かつ
その端点で他に Close 制御フレームが受信されなかった場合（下層のトランスポート層の接続が失われた場合などに生じ得る）、
<a class="dfnref" href="#dfn-close-code">WebSocket 接続の close コード</a>
は 1006 であるものと見なされる。
<span lang="en">
As defined in Sections 5.5.1 and 7.4, a Close control frame may contain a status code indicating a reason for closure. A closing of the WebSocket connection may be initiated by either endpoint, potentially simultaneously. _The WebSocket Connection Close Code_ is defined as the status code (Section 7.4) contained in the first Close control frame received by the application implementing this protocol. If this Close control frame contains no status code, _The WebSocket Connection Close Code_ is considered to be 1005. If _The WebSocket Connection is Closed_ and no Close control frame was received by the endpoint (such as could occur if the underlying transport connection is lost), _The WebSocket Connection Close Code_ is considered to be 1006.
</span></p>

<p class="note">注記：
２つの端点において
<a class="dfnref" href="#dfn-close-code">WebSocket 接続の close コード</a>
の値に一致を見ないことも起こり得る。
例えば，リモートの端点が Close フレームを送信したが、ローカルのアプリケーションは，まだそのソケットの受信バッファから Close フレームを含んでいるデータを読み取れてなく，かつ
そのローカルのアプリケーションが独立に接続を close することにして Close フレームを送信した場合、いずれの端点も Close フレームを送信し, 受信し，それ以上 Close フレームを送信しないことになる。
それぞれの端点は相手の端点から送信されたステータスコードを
<a class="dfnref" href="#dfn-close-code">WebSocket 接続の close コード</a>
として見ることになる。
そのため、両者の端点がほぼ同じ時刻に
<a class="dfnref" href="#dfn-to-start-closing-handshake">WebSocket closing ハンドシェイクの開始</a>
を独立に行った場合、互いの
<a class="dfnref" href="#dfn-close-code">WebSocket 接続の close コード</a>
の値が一致しないことが起こり得る。
<span lang="en">
NOTE: Two endpoints may not agree on the value of _The WebSocket Connection Close Code_. As an example, if the remote endpoint sent a Close frame but the local application has not yet read the data containing the Close frame from its socket's receive buffer, and the local application independently decided to close the connection and send a Close frame, both endpoints will have sent and received a Close frame and will not send further Close frames. Each endpoint will see the status code sent by the other end as _The WebSocket Connection Close Code_. As such, it is possible that the two endpoints may not agree on the value of _The WebSocket Connection Close Code_ in the case that both endpoints _Start the WebSocket Closing Handshake_ independently and at roughly the same time.
</span></p>

		</section>
		<section id="section-7.1.6">

<h4 title="The WebSocket Connection Close Reason">7.1.6. WebSocket 接続の close 事由</h4>

<p>
<a>5.5.1 節</a>, <a>7.4 節</a> にて定義されるように、 Close 制御フレームは、 closure の事由を指示するステータスコードに伴って， UTF-8 符号化されたデータも含み得る。
そのデータの解釈は端点に委ねられ，このプロトコルでは定義されない。
WebSocket 接続の closing は、同時刻の可能性も含め，いずれの端点からも起動され得る。
<dfn class="term-def" id="dfn-close-reason">WebSocket 接続の close 事由</dfn>
は、このプロトコルを実装するアプリケーションで受信された最初の Close 制御フレームに含められたステータスコード（ <a>7.4 節</a> ）に後続する， UTF-8 符号化データとして、定義される。
Close 制御フレームにその種のデータがない場合、
<a class="dfnref" href="#dfn-close-reason">WebSocket 接続の close 事由</a>
は空文字列である。
<span lang="en">
As defined in Sections 5.5.1 and 7.4, a Close control frame may contain a status code indicating a reason for closure, followed by UTF-8-encoded data, the interpretation of said data being left to the endpoints and not defined by this protocol. A closing of the WebSocket connection may be initiated by either endpoint, potentially simultaneously. _The WebSocket Connection Close Reason_ is defined as the UTF-8-encoded data following the status code (Section 7.4) contained in the first Close control frame received by the application implementing this protocol. If there is no such data in the Close control frame, _The WebSocket Connection Close Reason_ is the empty string.
</span></p>

<p class="note">注記：
<a>7.1.5 節</a> と同じ論法により、２つの端点の
<a class="dfnref" href="#dfn-close-reason">WebSocket 接続の close 事由</a>
に一致を見ないことも起こり得る。
<span lang="en">
NOTE: Following the same logic as noted in Section 7.1.5, two endpoints may not agree on _The WebSocket Connection Close Reason_.
</span></p>

		</section>
		<section id="section-7.1.7">

<h4 title="Fail the WebSocket Connection">7.1.7. WebSocket 接続を失敗させる</h4>

<p>
アルゴリズムと仕様の一部は、端点に対し，
<dfn class="term-def" id="dfn-to-fail">WebSocket 接続を失敗させる</dfn>
ことを要求する。
そのためには、クライアントは
<a class="dfnref" href="#dfn-to-close">WebSocket 接続を close</a>
しなければ<em class="rfc2119">ならず</em>，問題を適切な仕方により利用者に報告しても<em class="rfc2119">よい</em>（とりわけ開発者に有用になるであろう）。
同様に、サーバは
<a class="dfnref" href="#dfn-to-close">WebSocket 接続を close</a>
しなければ<em class="rfc2119">ならず</em>，問題をログにとる<em class="rfc2119">べき</em>である。
<span lang="en">
Certain algorithms and specifications require an endpoint to _Fail the WebSocket Connection_. To do so, the client MUST _Close the WebSocket Connection_, and MAY report the problem to the user (which would be especially useful for developers) in an appropriate manner. Similarly, to do so, the server MUST _Close the WebSocket Connection_, and SHOULD log the problem.
</span></p>

<p>
端点において
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させる</a>
ことが要求された時点に先立って，
<a class="dfnref" href="#dfn-established">WebSocket 接続が確立されている</a>
場合、端点は、
<a class="dfnref" href="#dfn-to-close">WebSocket 接続の close</a>
に移行する前に，適切なステータスコード（ <a>7.4 節</a> ）を伴う Close フレームを送信する<em class="rfc2119">べき</em>である。
端点は、最初の段階で， WebSocket 接続を失敗させたエラーの性質から, 相手側が Close フレームの受信とその処理を行える見込みがないと判断したきは、
Close フレームの送信を省略しても<em class="rfc2119">よい</em>。
端点は、
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させる</a>
指示を受けた後は，リモート端点からのデータの処理の試みを（ Close フレームへの応答も含め）続行しては<em class="rfc2119">ならない</em>。
<span lang="en">
If _The WebSocket Connection is Established_ prior to the point where the endpoint is required to _Fail the WebSocket Connection_, the endpoint SHOULD send a Close frame with an appropriate status code (Section 7.4) before proceeding to _Close the WebSocket Connection_. An endpoint MAY omit sending a Close frame if it believes the other side is unlikely to be able to receive and process the Close frame, due to the nature of the error that led the WebSocket connection to fail in the first place. An endpoint MUST NOT continue to attempt to process data (including a responding Close frame) from the remote endpoint after being instructed to _Fail the WebSocket Connection_.
</span></p>

<p>
上に指示されたもの，および
アプリケーション層（例えば， WebSocket API を利用するスクリプト）から指定されたときを除き、クライアントは接続を close する<em class="rfc2119">べき</em>でない。
<span lang="en">
Except as indicated above or as specified by the application layer (e.g., a script using the WebSocket API), clients SHOULD NOT close the connection.
</span></p>

		</section>
	</section>
	<section id="section-7.2">

<h3 title="Abnormal Closure">7.2. 異常な closure</h3>

		<section id="section-7.2.1">

<h4 title="Client-Initiated Closure">7.2.1. クライアントから開始される closure</h4>

<p>
一部のアルゴリズムにおいては、特に opening ハンドシェイクの間に，
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させる</a>
ことが クライアントに要求される。
そのためには、クライアントは， <a>7.1.7 節</a> の定義に従って
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させ</a>
なければ<em class="rfc2119">ならない</em>。
<span lang="en">
Certain algorithms, in particular during the opening handshake, require the client to _Fail the WebSocket Connection_. To do so, the client MUST _Fail the WebSocket Connection_ as defined in Section 7.1.7.
</span></p>

<p>
どの時点においても，下層のトランスポート層の接続が予期せず失われた場合、クライアントは
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させ</a>
なければ<em class="rfc2119">ならない</em>。
<span lang="en">
If at any point the underlying transport layer connection is unexpectedly lost, the client MUST _Fail the WebSocket Connection_.
</span></p>

<p>
上に指示されたもの，および
アプリケーション層（例えば， WebSocket API を利用するスクリプト）から指定されたときを除き、クライアントは接続を close する<em class="rfc2119">べき</em>でない。
<span lang="en">
Except as indicated above or as specified by the application layer (e.g., a script using the WebSocket API), clients SHOULD NOT close the connection.
</span></p>

		</section>
		<section id="section-7.2.2">

<h4 title="Server-Initiated Closure">7.2.2. サーバから開始される closure</h4>

<p>
一部のアルゴリズムでは、 opening ハンドシェイクの間に，サーバに対し
<dfn class="term-def" id="dfn-abort">WebSocket 接続の中止</dfn>
<!-- 
<a class="dfnref" href="#">WebSocket 接続を中止</a>
term-def ? -->
が要求または推奨される。
そのためには、サーバは単純に
<a class="dfnref" href="#dfn-to-close">WebSocket 接続を close</a>
（ <a>7.1.1 節</a> ）
しなければ<em class="rfc2119">ならない</em>。
<span lang="en">
Certain algorithms require or recommend that the server _Abort the WebSocket Connection_ during the opening handshake. To do so, the server MUST simply _Close the WebSocket Connection_ (Section 7.1.1).
</span></p>

		</section>
		<section id="section-7.2.3">

<h4 title="Recovering from Abnormal Closure">7.2.3. 異常な closure からの復帰</h4>

<p>
異常な closure が起きる事由はいくつもある。
その種の closure が一時的なエラーによる場合、再接続により，良好な接続と通常の運用を回復し得る。
その種の closure が一時的でない問題に起因する場合もある。
その場合、広範のクライアントのそれぞれが異常な closure を経験していて，即時に, かつ継続的に再接続を試行した場合、サーバは多数のクライアントからの再接続の試行により， DoS 攻撃に相当する高負荷に晒され得る。
そのような展開による結果、適時にサービスを復帰できない, あるいは復帰がずっと困難なものになり得る。
<span lang="en">
Abnormal closures may be caused by any number of reasons. Such closures could be the result of a transient error, in which case reconnecting may lead to a good connection and a resumption of normal operations. Such closures may also be the result of a nontransient problem, in which case if each deployed client experiences an abnormal closure and immediately and persistently tries to reconnect, the server may experience what amounts to a denial-of-service attack by a large number of clients trying to reconnect. The end result of such a scenario could be that the service is unable to recover in a timely manner or recovery is made much more difficult.
</span></p>

<p>
これを防止するため、クライアントは、この節で述べたような異常な closure が起きた後に再接続を試行する際には，何らかの形のバックオフを利用する<em class="rfc2119">べき</em>である。
<!-- backoff
http://www.atmarkit.co.jp/fwin2k/network/tcpip006/tcpip04.html
-->
<span lang="en">
To prevent this, clients SHOULD use some form of backoff when trying to reconnect after abnormal closures as described in this section.
</span></p>

<p>
最初の再接続の試みは、ランダムな時間だけ遅延される<em class="rfc2119">べき</em>である。
このランダムな遅延を選ぶためのパラメタの決定は、クライアントに委ねられる。
0 〜 5 秒までのランダムな値は、初期の遅延として適度なものである。
もっとも，クライアントは、実装の経験とアプリケーションの特性に基づいて，異なる間隔を遅延の長さに選択しても<em class="rfc2119">よい</em>。
<span lang="en">
The first reconnect attempt SHOULD be delayed by a random amount of time. The parameters by which this random delay is chosen are left to the client to decide; a value chosen randomly between 0 and 5 seconds is a reasonable initial delay though clients MAY choose a different interval from which to select a delay length based on implementation experience and particular application.
</span></p>

<p>
最初の再接続の試みが失敗した場合、後続の再接続では，べき乗打切り待機法（ truncated binary exponential backoff ）などを用いて，遅延の間隔を漸増させる<em class="rfc2119">べき</em>である。
<span lang="en">
Should the first reconnect attempt fail, subsequent reconnect attempts SHOULD be delayed by increasingly longer amounts of time, using a method such as truncated binary exponential backoff.
</span></p>

		</section>
	</section>
	<section id="section-7.3">

<h3 title="Normal Closure of Connections">7.3. 接続の正常な closure</h3>

<p>
サーバは、必要に応じて, いつでも， WebSocket 接続を close して<em class="rfc2119">よい</em>。
クライアントは WebSocket 接続を任意に close する<em class="rfc2119">べき</em>でない。
いずれの場合も、端点は
<a class="dfnref" href="#dfn-to-start-closing-handshake">WebSocket closing ハンドシェイクの開始</a>
手続き（ <a>7.1.2 節</a> ）へ移行して， closure に起動する。
<span lang="en">
Servers MAY close the WebSocket connection whenever desired. Clients SHOULD NOT close the WebSocket connection arbitrarily. In either case, an endpoint initiates a closure by following the procedures to _Start the WebSocket Closing Handshake_ (Section 7.1.2).
</span></p>

	</section>
	<section id="section-7.4">

<h3 title="Status Codes">7.4. ステータスコード</h3>

<p>
すでに確立されている接続の closing に際しては（例えば， opening ハンドシェイクが完了した後に Close フレームを送信する際）、端点は closure の事由を指示しても<em class="rfc2119">よい</em>。
端点によるこの事由の解釈，および
端点がこの事由に基づいてとるべき動作は、この仕様では定義されないままにされている。
この仕様は、一連の定義済みステータスコードを定義し，拡張, フレームワーク, アプリケーションが利用できる それらのコード範囲を指定する。
ステータスコード, および それに結び付けられるテキストのメッセージは、 Close フレームのオプションの成分である。
<span lang="en">
When closing an established connection (e.g., when sending a Close frame, after the opening handshake has completed), an endpoint MAY indicate a reason for closure. The interpretation of this reason by an endpoint, and the action an endpoint should take given this reason, are left undefined by this specification. This specification defines a set of pre-defined status codes and specifies which ranges may be used by extensions, frameworks, and end applications. The status code and any associated textual message are optional components of a Close frame.
</span></p>

		<section id="section-7.4.1">

<h4 title="Defined Status Codes">7.4.1. 定義済みのステータスコード</h4>

<p>
端点は、 Close フレームを送信するときに，以下の定義済みのステータスコードを利用して<em class="rfc2119">よい</em>。
<span lang="en">
Endpoints MAY use the following pre-defined status codes when sending a Close frame.
</span></p>

<dl class="defs">

	<dt>1000</dt>
	<dd>
1000 は、正常な closure を指示する。
確立された接続の目的が果たされたことを意味する。
<span lang="en">
1000 indicates a normal closure, meaning that the purpose for which the connection was established has been fulfilled.
</span></dd>

	<dt>1001</dt>
	<dd>
1001 は、端点が “消失” したことを指示する。
サーバがダウンしたり，ブラウザがページからどこか他へ遷移したときなど。
<span lang="en">
1001 indicates that an endpoint is "going away", such as a server going down or a browser having navigated away from a page.
</span></dd>

	<dt>1002</dt>
	<dd>
1002 は、端点がプロトコル­エラーにより接続を終了していることを指示する。
<span lang="en">
1002 indicates that an endpoint is terminating the connection due to a protocol error.
</span></dd>

	<dt>1003</dt>
	<dd>
1003 は、端点が受理できないデータを受信したなどの理由で，接続を終了していることを指示する（例えば，テキスト­データのみ解せる端点がバイナリ­メッセージを受信したとき、これを送信しても<em class="rfc2119">よい</em>）。
<span lang="en">
1003 indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).
</span></dd>

	<dt>1004</dt>
	<dd>
予約済み<!--1-->。
固有の意味は、将来に定義されることになるであろう。
<span lang="en">
Reserved. The specific meaning might be defined in the future.
</span></dd>

	<dt>1005</dt>
	<dd>
1005 は、予約済み<!--1-->の値であり，端点により Close 制御フレームのステータスコードに設定されては<em class="rfc2119">ならない</em>。
これは、どのステータスコードも実際には供されていないことを指示するステータスコードを必要とするアプリケーションのためのものとして，指定を受けている。
<span lang="en">
1005 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that no status code was actually present.
</span></dd>

	<dt>1006</dt>
	<dd>
1006 は、予約済み<!--1-->の値であり，端点により Close 制御フレームのステータスコードに設定されては<em class="rfc2119">ならない</em>。
これは、接続が異常に（例えば， Close 制御フレームの送信や受信­抜きに） close されたことを指示するステータスコードを必要とするアプリケーションのためのものとして，指定を受けている。
<span lang="en">
1006 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed abnormally, e.g., without sending or receiving a Close control frame.
</span></dd>

	<dt>1007</dt>
	<dd>
1007 は、受信したメッセージ内のデータがメッセージの種別と整合していない理由で，端点が接続を終了していることを指示する
（例えば，テキスト­メッセージ内の非 UTF-8 <a>[RFC3629]</a> ）。
<span lang="en">
1007 indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [RFC3629] data within a text message).
</span></dd>

	<dt>1008</dt>
	<dd>
1008 は、ポリシーに違反しているメッセージを受信した理由で，端点が接続を終了していることを指示する。
これは、より相応しいステータスコード（例えば， 1003 や 1009 ）が他にないとき, または ポリシーについての固有の詳細を隠す必要があるときに返し得る，汎用のステータスコードである。
<span lang="en">
1008 indicates that an endpoint is terminating the connection because it has received a message that violates its policy. This is a generic status code that can be returned when there is no other more suitable status code (e.g., 1003 or 1009) or if there is a need to hide specific details about the policy.
</span></dd>

	<dt>1009</dt>
	<dd>
1009 は、端点が処理するには大き過ぎるメッセージを受信した理由で，接続を終了していることを指示する。
<span lang="en">
1009 indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process.
</span></dd>

	<dt>1010</dt>
	<dd>
1010 は、一つ以上の拡張が折衝されることが予期されているのに，サーバが WebSocket ハンドシェイクの応答メッセージの中にそれらを返さなかった理由で，端点（クライアント）が接続を終了していることを指示する。
Close フレームの <var>reason</var> 部には、必要な拡張のリストが出現する<em class="rfc2119">べき</em>である。
サーバは、代わりに WebSocket ハンドシェイクを失敗させられるので，このステータスコードを利用することはないことに注意。
<span lang="en">
1010 indicates that an endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn't return them in the response message of the WebSocket handshake. The list of extensions that are needed SHOULD appear in the /reason/ part of the Close frame. Note that this status code is not used by the server, because it can fail the WebSocket handshake instead.
</span></dd>

	<dt>1011</dt>
	<dd>
1011 は、サーバがリクエストを果たせないような，予期しない状況に遭遇した理由で、接続を終了していることを指示する。
<span class="trans-note">【<a href="http://www.rfc-editor.org/errata_search.php?rfc=6455">正誤表</a>による修正提案（ Held for Document Update ）あり： “サーバ” → “端点” 】</span>
<span lang="en">
1011 indicates that a server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.
</span></dd>

	<dt>1015</dt>
	<dd>
1015 は、予約済み<!--1-->の値であり，端点により Close 制御フレームのステータスコードに設定されては<em class="rfc2119">ならない</em>。
これは、TLS ハンドシェイクを行った際の失敗<!--1-->により（例えば，サーバが証明書を検証できないなど），接続が close されたことを指示するステータスコードを必要とするアプリケーションのためのものとして，指定を受けている。
<span lang="en">
1015 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).
</span></dd>

</dl>

		</section>
		<section id="section-7.4.2">

<h4 title="Reserved Status Code Ranges">7.4.2. 予約済み<!--1-->ステータスコードの範囲</h4>

<dl class="defs">

	<dt>0-999</dt>
	<dd>
範囲 0-999 のステータスコードは、利用されない。
<span lang="en">
Status codes in the range 0-999 are not used.
</span></dd>

	<dt>1000-2999</dt>
	<dd>
範囲 1000-2999 のステータスコードは、このプロトコルとその将来の改訂版, および 恒久的で容易に可用な 公開の仕様で指定される拡張による定義のために，予約済み<!--1-->である。
<span lang="en">
Status codes in the range 1000-2999 are reserved for definition by this protocol, its future revisions, and extensions specified in a permanent and readily available public specification.
</span></dd>

	<dt>3000-3999</dt>
	<dd>
範囲 3000-3999 のステータスコードは、ライブラリ, フレームワーク, アプリケーション 利用のために，予約済み<!--1-->である。
これらのステータスコード は、 IANA により直接的に登録される。
これらのコードの解釈は、このプロトコルでは未定義である。
<span lang="en">
Status codes in the range 3000-3999 are reserved for use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by this protocol.
</span></dd>

	<dt>4000-4999</dt>
	<dd>
範囲 4000-4999 のステータスコードは、私的利用のために予約済み<!--1-->なので，登録できない。
これらのコードは WebSocket アプリケーションとの事前の取り決めにより利用できる。
これらのコードの解釈は、このプロトコルでは定義されない。
<span lang="en">
Status codes in the range 4000-4999 are reserved for private use and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by this protocol.
</span></dd>

</dl>

		</section>
	</section>
</section>
<section id="section-8">

<h2 title="Error Handling">8. エラーの取り扱い</h2>

	<section id="section-8.1">

<h3 title="Handling Errors in UTF-8-Encoded Data">8.1. UTF-8 符号化データにおけるエラーの取り扱い</h3>

<p>
端点がバイト­ストリームを UTF-8 として解釈する際に，そのバイト­ストリームが実際には妥当な UTF-8 ストリームではなかった場合、その端点は
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させ</a>
なければ<em class="rfc2119">ならない</em>。
この規則は、 opening ハンドシェイクの間にも, 後続のデータ交換の間にも，いずれにも適用される。
<span lang="en">
When an endpoint is to interpret a byte stream as UTF-8 but finds that the byte stream is not, in fact, a valid UTF-8 stream, that endpoint MUST _Fail the WebSocket Connection_. This rule applies both during the opening handshake and during subsequent data exchange.
</span></p>


	</section>
</section>
<section id="section-9">

<h2 title="Extensions">9. 拡張</h2>

<p>
WebSocket クライアントは、この仕様の拡張をリクエストしても<em class="rfc2119">よい</em>。
WebSocket サーバは、クライアントからリクエストされた拡張の一部またはすべてを
受理して<em class="rfc2119">よい</em>。
サーバは、クライアントからリクエストされていない拡張を応答しては<em class="rfc2119">ならない</em>。
クライアント↔サーバ間の折衝の中に，拡張のパラメタが内包される場合、これらのパラメタは，パラメタを適用する拡張の仕様に則って選ばれなければ<em class="rfc2119">ならない</em>。
<span lang="en">
WebSocket clients MAY request extensions to this specification, and WebSocket servers MAY accept some or all extensions requested by the client. A server MUST NOT respond with any extension not requested by the client. If extension parameters are included in negotiations between the client and the server, those parameters MUST be chosen in accordance with the specification of the extension to which the parameters apply.
</span></p>

	<section id="section-9.1">

<h3 title="Negotiating Extensions">9.1. 拡張の折衝処理</h3>

<p>
クライアントは、HTTP ヘッダの通常の規則（
<a>[RFC2616]</a> <a href="./rfc2616#section-4.2">4.2 節</a>
参照）に従って，
<b>Sec-WebSocket-Extensions</b> ヘッダを内包することにより、拡張をリクエストする。
ヘッダの値は，次の ABNF <a>[RFC2616]</a> にて定義される。
この節では “暗黙の *LWS 規則” も内包する，
<a>[RFC2616]</a> による ABNF 構文／規則が用いられることに注意。
折衝の間に，下記 ABNF に適合しない値がクライアントまたはサーバで受信された場合、そのような不正な形式<!--1-->のデータを受信した側は即時に
<a class="dfnref" href="#dfn-to-fail">WebSocket 接続を失敗させ</a>
なければ<em class="rfc2119">ならない</em>。
<span lang="en">
A client requests extensions by including a |Sec-WebSocket-Extensions| header field, which follows the normal rules for HTTP header fields (see [RFC2616], Section 4.2) and the value of the header field is defined by the following ABNF [RFC2616]. Note that this section is using ABNF syntax/rules from [RFC2616], including the "implied *LWS rule". If a value is received by either the client or the server during negotiation that does not conform to the ABNF below, the recipient of such malformed data MUST immediately _Fail the WebSocket Connection_.
</span></p>

<pre class="ABNF">
Sec-WebSocket-Extensions = extension-list
extension-list = 1#extension
extension = extension-token *( ";" extension-param )
extension-token = registered-token
registered-token = token
extension-param = token [ "=" (token | quoted-string) ]
    ; <span title="When using the quoted-string syntax variant, the value">quoted-string 構文を利用する場合、</span>
    ; <span title="after quoted-string unescaping MUST conform to the"
>quoted-string エスケープ復元後の値は</span>
    ; <span title="'token' ABNF.">'token' ABNF に適合しなければ<em class="rfc2119">ならない</em></span>
</pre>

<p>
他の HTTP ヘッダと同様、このヘッダは，複数行に渡って，分割されたり結合されても<em class="rfc2119">よい</em>ことに注意。
よって，次は：
<span lang="en">
Note that like other HTTP header fields, this header field MAY be split or combined across multiple lines. Ergo, the following are equivalent:
</span></p>

<pre class="example">
Sec-WebSocket-Extensions: foo
Sec-WebSocket-Extensions: bar; baz=2
</pre>

<p>
正確に次と等価である：
<span lang="en">
is exactly equivalent to
</span></p>

<pre class="example">
Sec-WebSocket-Extensions: foo, bar; baz=2
</pre>

<p>
利用されるどの拡張トークンも，登録済みの<!--1-->トークンでなければ<em class="rfc2119">ならない</em>（ <a>11.4 節</a> を見よ）。
与えられた拡張に伴なって供されるパラメタは、その拡張のために定義されたものでなければ<em class="rfc2119">ならない</em>。
クライアントは，告知された拡張を申し入れるのみであり、サーバがその拡張の利用を指示しない限り，それらを利用しては<em class="rfc2119">ならない</em>ことに注意。
<span lang="en">
Any extension-token used MUST be a registered token (see Section 11.4). The parameters supplied with any given extension MUST be defined for that extension. Note that the client is only offering to use any advertised extensions and MUST NOT use them unless the server indicates that it wishes to use the extension.
</span></p>

<p>
拡張の順序は有意であることに注意。
複数の拡張­間のやりとりが拡張を定義する文書において定義されても<em class="rfc2119">よい</em>。
そのような定義がない場合、クライアントのリクエストにリストされたヘッダの順序は，最初のオプションを最高位として，クライアントが利用を希望する順序を表現しているものと解釈する。
サーバの応答にリストされる拡張は、接続に実際に利用される拡張を表現する。
もし，拡張がデータやフレーミングに手を加えることがある場合、データに対する操作の順序は、 opening ハンドシェイクにおけるサーバの応答にリストされた拡張の順序と同じであるものと見なされるべきである。
<span lang="en">
Note that the order of extensions is significant. Any interactions between multiple extensions MAY be defined in the documents defining the extensions. In the absence of such definitions, the interpretation is that the header fields listed by the client in its request represent a preference of the header fields it wishes to use, with the first options listed being most preferable. The extensions listed by the server in response represent the extensions actually in use for the connection. Should the extensions modify the data and/or framing, the order of operations on the data should be assumed to be the same as the order in which the extensions are listed in the server's response in the opening handshake.
</span></p>

<p>
例えば，２つの拡張 "<samp>foo</samp>" と "<samp>bar</samp>" があって，サーバから送信された
<b>Sec-WebSocket-Extensions</b> ヘッダが値 "<samp>foo, bar</samp>" を持つ場合、データに対する操作は、<samp>foo</samp> を作用させた後に <samp>bar</samp> を作用させる形に，<!-- bar(foo(data)) のような形に、 -->データ自身に対する変更（圧縮など）やフレーミングに対する変更は、 “スタック” され得る。
<span lang="en">
For example, if there are two extensions "foo" and "bar" and if the header field |Sec-WebSocket-Extensions| sent by the server has the value "foo, bar", then operations on the data will be made as bar(foo(data)), be those changes to the data itself (such as compression) or changes to the framing that may "stack".
</span></p>

<p>
受理­可能な拡張のヘッダの<!-- 非規定 -->例（読み易くするため，長い行は折り返されている）：
<span lang="en">
Non-normative examples of acceptable extension header fields (note that long lines are folded for readability):
</span></p>

<pre class="example">
Sec-WebSocket-Extensions: deflate-stream
Sec-WebSocket-Extensions: mux; max-channels=4; flow-control,
deflate-stream
Sec-WebSocket-Extensions: private-extension
</pre>

<p>
サーバは、クライアントからリクエストされた１個以上の拡張を
<b>Sec-WebSocket-Extensions</b> ヘッダに内包することにより，受理する。
拡張パラメタの解釈、およびクライアントからリクエストされたパラメタの集合に対し，サーバから妥当な応答を構成するための要素については、それらの拡張が個別に定義することになる。
<span lang="en">
A server accepts one or more extensions by including a |Sec-WebSocket-Extensions| header field containing one or more extensions that were requested by the client. The interpretation of any extension parameters, and what constitutes a valid response by a server to a requested set of parameters by a client, will be defined by each such extension.
</span></p>

	</section>
	<section id="section-9.2">

<h3 title="Known Extensions">9.2. 既知の拡張</h3>

<p>
拡張は、実装が追加のプロトコル特色機能をオプトインするための仕組みを提供する。
この文書は いかなる拡張も定義しないが、実装は別々に定義された拡張を利用して<em class="rfc2119">よい</em>。
<span lang="en">
Extensions provide a mechanism for implementations to opt-in to additional protocol features. This document doesn't define any extension, but implementations MAY use extensions defined separately.
</span></p>

	</section>
</section>
<section id="section-10">

<h2 title="Security Considerations">10. セキュリティ上の考慮点</h2>

<p>
この節では、WebSocket Protocol に適用され得る，いくつかのセキュリティ上の考慮点について述べる。
固有のセキュリティ上の考慮点は、この節の下位節にて述べられる。
<span lang="en">
This section describes some security considerations applicable to the WebSocket Protocol. Specific security considerations are described in subsections of this section.
</span></p>

	<section id="section-10.1">

<h3 title="Non-Browser Clients">10.1. 非ブラウザ クライアント</h3>

<p>
WebSocket Protocol は、ウェブ­ブラウザなどの信頼できるアプリケーションの内部で実行されている悪意のある<!--1--> JavaScript から保護する。
例えば，
<b>Origin</b> ヘッダの検査（下を見よ）など。
追加の詳細は <a>1.6 節</a> を見よ。
そのような前提は、より<!--  --> capable なクライアントの場合には成立しない。
<span lang="en">
The WebSocket Protocol protects against malicious JavaScript running inside a trusted application such as a web browser, for example, by checking of the |Origin| header field (see below). See Section 1.6 for additional details. Such assumptions don't hold true in the case of a more-capable client.
</span></p>

<p>
このプロトコルは、ウェブ­ページ内のスクリプトからの利用が想定されているが、ホストから直接的にも利用できる。
そのようなホストは自身に利するようにふるまうので、サーバを誤誘導するように偽装された
<b>Origin</b> ヘッダも送信し得る。
したがって、サーバは，既知の生成元からのスクリプトと直接的にやりとりしていると見なすことには慎重になるべきで、予期されない方法でアクセスされている可能性を考慮しなければならない。
特に、サーバは，どの入力も妥当であるものと信用すべきではない。
<span lang="en">
While this protocol is intended to be used by scripts in web pages, it can also be used directly by hosts. Such hosts are acting on their own behalf and can therefore send fake |Origin| header fields, misleading the server. Servers should therefore be careful about assuming that they are talking directly to scripts from known origins and must consider that they might be accessed in unexpected ways. In particular, a server should not trust that any input is valid.
</span></p>

<p class="example">例：
サーバは、入力を SQL クエリの一部に利用する際に，自身が SQL インジェクションの感染源にならないように、すべての入力テキストを SQL サーバに渡す前にエスケープすべきである。
<span lang="en">
EXAMPLE: If the server uses input as part of SQL queries, all input text should be escaped before being passed to the SQL server, lest the server be susceptible to SQL injection.
</span></p>

	</section>
	<section id="section-10.2">

<h3 title="Origin Considerations">10.2. 生成元についての考慮点</h3>

<p>
任意のウェブ­ページでなく，一定のサイトのみに属するウェブ­ページからの入力を処理することが想定されているサーバは、
<b>Origin</b> ヘッダの値が予期されている生成元であるかどうか，検証する<em class="rfc2119">べき</em>である。
生成元がサーバにとって受理できない場合、
HTTP <code class="res">403 Forbidden</code> ステータスコード
を含ませた返信により， WebSocket ハンドシェイクに応答する<em class="rfc2119">べき</em>である。
<span lang="en">
Servers that are not intended to process input from any web page but only for certain sites SHOULD verify the |Origin| field is an origin they expect. If the origin indicated is unacceptable to the server, then it SHOULD respond to the WebSocket handshake with a reply containing HTTP 403 Forbidden status code.
</span></p>

<p>
<b>Origin</b> ヘッダは、概して，信頼できるクライアントの文脈の下で実行されている JavaScript アプリケーションの作者が 信頼できない主体であるときの 攻撃­事例からの保護を供する。
<!--  -->
クライアント自身は、サーバと接触することができ，
<b>Origin</b> ヘッダの仕組みにより，その種の通信­特権を JavaScript アプリケーションにまで広げるかどうかを決定する。
その意図は、非ブラウザによる接続の確立を防止するのではなく、信頼できるブラウザが潜在的に悪意のある<!--1--> JavaScript の制御下にあっても， WebSocket ハンドシェイクを偽装できなくする所にある。
<span lang="en">
The |Origin| header field protects from the attack cases when the untrusted party is typically the author of a JavaScript application that is executing in the context of the trusted client. The client itself can contact the server and, via the mechanism of the |Origin| header field, determine whether to extend those communication privileges to the JavaScript application. The intent is not to prevent non-browsers from establishing connections but rather to ensure that trusted browsers under the control of potentially malicious JavaScript cannot fake a WebSocket handshake.
</span></p>

	</section>
	<section id="section-10.3">

<h3 title="Attacks On Infrastructure (Masking)">10.3. 通信基盤に対する攻撃（マスクの適用）</h3>

<p>
端点が WebSocket 経由による攻撃の標的になることに加えて、プロキシなどの，ウェブ通信基盤の他の部分も攻撃の対象になり得る。
<span lang="en">
In addition to endpoints being the target of attacks via WebSockets, other parts of web infrastructure, such as proxies, may be the subject of an attack.
</span></p>

<p>
このプロトコルが開発されていくに伴い、実ネットに配備されている caching プロキシを汚染に導くような，プロキシに対する攻撃のクラスを実証する実験が実施された
<a>[TALKING]</a>
。
攻撃の一般的な手口は、 “攻撃者の” 制御下にあるサーバへの接続を確立させ、
WebSocket Protocol による接続の確立を真似るように HTTP 接続­上で UPGRADE を行い、その UPGRADE された接続を通して，特定の既知のリソースに対する GET リクエストに似せるように（攻撃の中では、ごくありふれた，広告配信ネットワーク上のアクセス記録やリソースのためのスクリプトに似た何か），後続してデータを送信するものであった。
リモートのサーバは、偽装された GET リクエストに対する応答に似た何かで応答することになるであろう。
この応答がゼロでない割合の中継点にキャッシュされることにより，キャッシュが汚染される。
この攻撃による結果、利用者が攻撃者の制御下のウェブ­サイトを気付かずに訪問したとするとき、攻撃者はその利用者のキャッシュや同じキャッシュを共有する他の利用者のそれを汚染することにより，他の生成元に属する悪意のある<!--1-->スクリプトを実行させられる可能性が生じ、ウェブのセキュリティ­モデルが危うくされる。
<span lang="en">
As this protocol was being developed, an experiment was conducted to demonstrate a class of attacks on proxies that led to the poisoning of caching proxies deployed in the wild [TALKING]. The general form of the attack was to establish a connection to a server under the "attacker's" control, perform an UPGRADE on the HTTP connection similar to what the WebSocket Protocol does to establish a connection, and subsequently send data over that UPGRADEd connection that looked like a GET request for a specific known resource (which in an attack would likely be something like a widely deployed script for tracking hits or a resource on an ad-serving network). The remote server would respond with something that looked like a response to the fake GET request, and this response would be cached by a nonzero percentage of deployed intermediaries, thus poisoning the cache. The net effect of this attack would be that if a user could be convinced to visit a website the attacker controlled, the attacker could potentially poison the cache for that user and other users behind the same cache and run malicious script on other origins, compromising the web security model.
</span></p>

<p>
中継点に対するその種の攻撃を回避するためには、アプリケーションから供されたデータに HTTP に準じないフレーミングを施すだけでは十分でない。
それぞれの非準拠の中継点が、そのような非 HTTP フレーミングを素通りさせずに，フレーム­ペイロードに対し不正に動作しているかどうかを、包括的に検出したり試験することは不可能なので。
したがって，防御策として、クライアントからサーバへのデータすべてにマスクをかけることにより，リモートのスクリプト（攻撃者）が 伝送路に出現するデータがどのように送信されるか を制御できなくし、中継点から誤って HTTP リクエストに解釈され得るようなメッセージは構築できないようにされている。
<span lang="en">
To avoid such attacks on deployed intermediaries, it is not sufficient to prefix application-supplied data with framing that is not compliant with HTTP, as it is not possible to exhaustively discover and test that each nonconformant intermediary does not skip such non-HTTP framing and act incorrectly on the frame payload. Thus, the defense adopted is to mask all data from the client to the server, so that the remote script (attacker) does not have control over how the data being sent appears on the wire and thus cannot construct a message that could be misinterpreted by an intermediary as an HTTP request.
</span></p>

<p>
クライアントは、データを提供する末端アプリケーションからは予測できないようなアルゴリズムを用いて，各フレームごとに新たなマスキングキーを選ばなければ<em class="rfc2119">ならない</em>。
例えば、各マスキングキーを暗号論的に強い乱数生成器から取り出すなど。
同じキーが用いられたり，次のキーがどのように選ばれるかについて解読可能なパターンが存在する場合、攻撃者はマスクされた際に HTTP リクエストに見え得るメッセージを送信­可能になる（攻撃者が伝送路­上の目的のメッセージを取得して，次に用いられるマスキングキーによりマスクを施せば、クライアントがマスキングキーを適用したときに，データのマスクは実質的に解除されることになる。）
<span lang="en">
Clients MUST choose a new masking key for each frame, using an algorithm that cannot be predicted by end applications that provide data. For example, each masking could be drawn from a cryptographically strong random number generator. If the same key is used or a decipherable pattern exists for how the next key is chosen, the attacker can send a message that, when masked, could appear to be an HTTP request (by taking the message the attacker wishes to see on the wire and masking it with the next masking key to be used, the masking key will effectively unmask the data when the client applies it).
</span></p>

<p>
ひとたびクライアントからフレームの伝送が始まったなら、そのフレームのペイロード（アプリケーションから供されたデータ）は，アプリケーションから手を加えられないようにする必要がある。
さもなくば，攻撃者は、長いフレームを送信して，初期データが既知の値である所から（例えばすべてゼロ），データの最初の部分を受領した際に利用されているマスキングキーを算出し、フレーム内のまだ送信されていないデータに対し，マスクされた際に HTTP リクエストに見えるように手を加えることが可能になる（これは前段落で述べた、既知の, または予測可能なマスキングキーを用いたときの問題と本質的に同じである）。
追加のデータが送信されたり, 送信されつつあるデータが何らかの方法で変更された場合、その新たな／変更されたデータは，新たなフレーム内で, したがって新たなマスキングキーにより，送信されなければならない。
手短かに言えば、フレームの伝送が始まった時点から，その内容にリモートのスクリプト（アプリケーション）から手が加えられるようになってはならない。
<span lang="en">
It is also necessary that once the transmission of a frame from a client has begun, the payload (application-supplied data) of that frame must not be capable of being modified by the application. Otherwise, an attacker could send a long frame where the initial data was a known value (such as all zeros), compute the masking key being used upon receipt of the first part of the data, and then modify the data that is yet to be sent in the frame to appear as an HTTP request when masked. (This is essentially the same problem described in the previous paragraph with using a known or predictable masking key.) If additional data is to be sent or data to be sent is somehow changed, that new or changed data must be sent in a new frame and thus with a new masking key. In short, once transmission of a frame begins, the contents must not be modifiable by the remote script (application).
</span></p>

<p>
対抗して保護すべき脅威モデルは、クライアントが送信するデータが HTTP リクエストとして現れることである。
したがって、マスクされる必要のあるチャンネルは，クライアントからサーバへのデータになる。
サーバからクライアントへのデータは，応答に似せ得るが、そのためにはクライアントもリクエストを偽造できなければならない。
そのような理由から、両方向ともデータをマスクする必要があるとは考えられていない（サーバからクライアントへのデータはマスクされない）。
<span lang="en">
The threat model being protected against is one in which the client sends data that appears to be an HTTP request. As such, the channel that needs to be masked is the data from the client to the server. The data from the server to the client can be made to look like a response, but to accomplish this request, the client must also be able to forge a request. As such, it was not deemed necessary to mask data in both directions (the data from the server to the client is not masked).
</span></p>

<p>
マスクの適用により提供される保護にも関わらず，非準拠の HTTP プロキシは、依然として，マスクを適用しないクライアントとサーバによる，この種の攻撃からの汚染に脆弱性があることになる。
<span lang="en">
Despite the protection provided by masking, non-compliant HTTP proxies will still be vulnerable to poisoning attacks of this type by clients and servers that do not apply masking.
</span></p>

	</section>
	<section id="section-10.4">

<h3 title="Implementation-Specific Limits">10.4. 実装ごとに固有の制限</h3>

<p>
複数フレームからの再構築­後のフレーム­サイズまたは総メッセージ­サイズに対し，自身に, あるいはプラットフォームごとに固有の制限がある実装は、これらの制限の超過から自身を保護しなければ<em class="rfc2119">ならない</em>。
（例えば，悪意のある<!--1-->端点は、単独の巨大フレーム（例えば，サイズが 2 の 60 乗）を送信したり, 断片化されたメッセージの一部をなす 小フレームの長大なストリームを送信することにより，そのピアの記憶域の枯渇や DoS 攻撃を仕掛け得る。）
そのような実装は、フレーム­サイズ, および複数フレームからの再構築­後の総メッセージ­サイズに制限を課する<em class="rfc2119">べき</em>である。
<span lang="en">
Implementations that have implementation- and/or platform-specific limitations regarding the frame size or total message size after reassembly from multiple frames MUST protect themselves against exceeding those limits. (For example, a malicious endpoint can try to exhaust its peer's memory or mount a denial-of-service attack by sending either a single big frame (e.g., of size 2**60) or by sending a long stream of small frames that are a part of a fragmented message.) Such an implementation SHOULD impose a limit on frame sizes and the total message size after reassembly from multiple frames.
</span></p>

	</section>
	<section id="section-10.5">

<h3 title="WebSocket Client Authentication">10.5. WebSocket クライアント認証</h3>

<p>
このプロトコルは、 WebSocket ハンドシェイクの間にサーバがクライアントを認証できるような，特定の方法は規定しない。
WebSocket サーバは、クッキー, HTTP 認証, TLS 認証など，汎用 HTTP サーバにて可用な，任意のクライアント認証の仕組みを利用できる。
<span lang="en">
This protocol doesn't prescribe any particular way that servers can authenticate clients during the WebSocket handshake. The WebSocket server can use any client authentication mechanism available to a generic HTTP server, such as cookies, HTTP authentication, or TLS authentication.
</span></p>

	</section>
	<section id="section-10.6">

<h3 title="Connection Confidentiality and Integrity">10.6. 接続の機密性と完全性</h3>

<p>
接続の機密性と完全性は、WebSocket Protocol を TLS （ wss URI ）を通して実行することにより提供される。
WebSocket の実装は、 TLS をサポートしなければ<em class="rfc2119">ならず</em>，それらのピアと通信するときは使用する<em class="rfc2119">べき</em>である。
<span lang="en">
Connection confidentiality and integrity is provided by running the WebSocket Protocol over TLS (wss URIs). WebSocket implementations MUST support TLS and SHOULD employ it when communicating with their peers.
</span></p>

<p>
TLS を利用する接続において TLS が提供する利点の大きさは、TLS ハンドシェイクの間に折衝されるアルゴリズムの強度に大きく依存する。
例えば、一部の TLS 暗号の仕組みは接続の機密性を提供しない。
適度なレベルの保護を達成するためには，クライアントは、 Strong TLS アルゴリズムのみを利用するべきである。
"Web Security Context：User Interface Guidelines"
<a>[W3C.REC-wsc-ui-20100812]</a>
に， Strong TLS アルゴリズムを構成する要素について論じられている。
<a>[RFC5246]</a> の
<a href="./rfc5246#appendix-A.5">Appendix A.5</a>
と
<a href="./rfc5246#appendix-D.3">Appendix D.3</a>
にて、追加の手引きを見られる。
<span lang="en">
For connections using TLS, the amount of benefit provided by TLS depends greatly on the strength of the algorithms negotiated during the TLS handshake. For example, some TLS cipher mechanisms don't provide connection confidentiality. To achieve reasonable levels of protection, clients should use only Strong TLS algorithms. "Web Security Context: User Interface Guidelines" [W3C.REC-wsc-ui-20100812] discusses what constitutes Strong TLS algorithms. [RFC5246] provides additional guidance in Appendix A.5 and Appendix D.3.
</span></p>

	</section>
	<section id="section-10.7">

<h3 title="Handling of Invalid Data">10.7. 妥当でないデータの取り扱い</h3>

<p>
着信データの妥当­性は、クライアント, サーバの両者において検証されなければ<em class="rfc2119">ならない</em>。
どの時点であれ、端点は、妥当でないデータ
— 自身が解し得ない, または 入力の安全性を決定するにあたって何らかの基準に違反しているデータ, あるいは予期される値に対応しない opening ハンドシェイク（例えば，クライアントのリクエスト内の不正な path や生成元） —
に直面した場合には， TCP 接続を落としても<em class="rfc2119">よい</em>。
妥当でないデータが WebSocket ハンドシェイクの成功後に受信された場合、端点は、
<a class="dfnref" href="#dfn-to-close">WebSocket 接続の close</a>
に移行する前に，適切なステータスコードを伴う Close フレームを（ <a>7.4 節</a> ）送信する<em class="rfc2119">べき</em>である。
適切なステータスコードを伴う Close フレームの利用は、問題の診断を支援する。
妥当でないデータが WebSocket ハンドシェイクの間に送信されてきた場合、サーバは適切な HTTP <a>[RFC2616]</a> ステータスコードを返す<em class="rfc2119">べき</em>である。
<span lang="en">
Incoming data MUST always be validated by both clients and servers. If, at any time, an endpoint is faced with data that it does not understand or that violates some criteria by which the endpoint determines safety of input, or when the endpoint sees an opening handshake that does not correspond to the values it is expecting (e.g., incorrect path or origin in the client request), the endpoint MAY drop the TCP connection. If the invalid data was received after a successful WebSocket handshake, the endpoint SHOULD send a Close frame with an appropriate status code (Section 7.4) before proceeding to _Close the WebSocket Connection_. Use of a Close frame with an appropriate status code can help in diagnosing the problem. If the invalid data is sent during the WebSocket handshake, the server SHOULD return an appropriate HTTP [RFC2616] status code.
</span></p>

<p>
誤った符号化方式を用いたテキスト­データの送信から生じる，共通的なセキュリティ問題のクラスがある。
このプロトコルは、種別 Text のメッセージは，（ Binary 他の種別とは対照的に） UTF-8 符号化データを含むものと指定している。
長さも依然として指示されており、このプロトコルを実装するアプリケーションは，フレームが実際に終端する所を決定する際に 長さを利用すべきであるが、不適切な符号化方式によるデータの送信は，依然として，このプロトコル上に構築されたアプリケーションの前提を覆し得るものであり、データの誤解釈による，データの喪失や潜在的セキュリティ­バグを導き得る。
<span lang="en">
A common class of security problems arises when sending text data using the wrong encoding. This protocol specifies that messages with a Text data type (as opposed to Binary or other types) contain UTF-8-encoded data. Although the length is still indicated and applications implementing this protocol should use the length to determine where the frame actually ends, sending data in an improper encoding may still break assumptions that applications built on top of this protocol may make, leading to anything from misinterpretation of data to loss of data or potential security bugs.
</span></p>

	</section>
	<section id="section-10.8">

<h3 title="Use of SHA-1 by the WebSocket Handshake">10.8. WebSocket ハンドシェイクによる SHA-1 の利用</h3>

<p>
この文書で述べられた WebSocket ハンドシェイクは、衝突耐性や第二原像攻撃
<span class="trans-note">【<a href="http://ja.wikipedia.org/wiki/%E5%8E%9F%E5%83%8F%E6%94%BB%E6%92%83" >参考</a>】</span>
に対する耐性など，いかなる SHA-1 のプロパティにも依存しない（ <a>[RFC4270]</a> に述べられるように）。
<span lang="en">
The WebSocket handshake described in this document doesn't depend on any security properties of SHA-1, such as collision resistance or resistance to the second pre-image attack (as described in [RFC4270]).
</span></p>

	</section>
</section>

<section id="section-11">

<h2 title="IANA Considerations">11. IANA Considerations</h2>

	<section id="section-11.1">

<h3 title="Registration of New URI Schemes">11.1. 新たな URI スキームの登録</h3>

		<section id="section-11.1.1">

<h4 title="Registration of &quot;ws&quot; Scheme">11.1.1. "ws" スキームの登録</h4>

<p>
<b>ws</b> URI は、 WebSocket サーバとリソース名を識別する。
<span lang="en">
A |ws| URI identifies a WebSocket server and resource name.
</span></p>

<dl>
	<dt title="URI scheme name">URI スキーム名</dt>
	<dd>ws</dd>

	<dt title="Status">位置付け</dt>
	<dd>
恒久的
<span lang="en">
Permanent
</span></dd>

	<dt title="URI scheme syntax">URI スキーム構文</dt>
	<dd>
<p>
ABNF <a>[RFC5234]</a> 構文および
URI 仕様 <a>[RFC3986]</a> の ABNF の終端記号を用いて：
<span lang="en">
Using the ABNF [RFC5234] syntax and ABNF terminals from the URI specification [RFC3986]:
</span></p>

<pre class="ABNF">
"ws:" "//" authority path-abempty [ "?" query ]
</pre>
</dd>

</dl>

<p>
<code class="ABNF">path-abempty</code> と <code class="ABNF">query</code> <a>[RFC3986]</a> 成分は、要望されたサービスの種類を識別するために，サーバへ送信されるリソース名を形成する。
他の成分は、 <a>[RFC3986]</a> に述べられる意味を持つ。
<span lang="en">
The &lt;path-abempty&gt; and &lt;query&gt; [RFC3986] components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in [RFC3986].
</span></p>

<dl>
	<dt title="URI scheme semantics">URI スキーム意味論</dt>
	<dd>
このスキームのための唯一の運用は、 WebSocket Protocol を利用して接続を open することである。
<span lang="en">
The only operation for this scheme is to open a connection using the WebSocket Protocol.
</span></dd>

	<dt title="Encoding considerations">符号化方式についての考慮点</dt>
	<dd>
上で定義された構文から除外されたホスト成分­内の文字は、
<a>[RFC3987]</a> またはその後継文書の指定に従って， Unicode から ASCII に変換されなければ<em class="rfc2119">ならない</em>。
スキームに基づく正規化の目的においては、ホスト成分の Internationalized Domain Name （ IDN ）形式<!--1-->とそれらの punycode への変換は，等価なものと見なされる（
<a>[RFC3987]</a> <a href="./rfc3987#section-5.3.3">5.3.3 節</a>
参照）。
<!-- Punycode
http://ja.wikipedia.org/wiki/Punycode
-->
<span lang="en">
Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII as specified in [RFC3987] or its replacement. For the purposes of scheme-based normalization, Internationalized Domain Name (IDN) forms of the host component and their conversions to punycode are considered equivalent (see Section 5.3.3 of [RFC3987]).
</span></dd>

	<dd>
上で定義された構文から除外された，他の成分­内の文字は、まず， UTF-8 に符号化した上で，結果のバイト並びを［
URI <a>[RFC3986]</a>, IRI （国際化リソース識別子） <a>[RFC3987]</a>
］仕様の定義に従って，パーセント符号化形に置換することにより、
Unicode から ASCII へ変換されなければ<em class="rfc2119">ならない</em>。
<span lang="en">
Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI [RFC3986] and Internationalized Resource Identifier (IRI) [RFC3987] specifications.
</span></dd>

	<dt title="Applications/protocols that use this URI scheme name">この URI スキーム名を利用するアプリケーション／プロトコル</dt>
	<dd>WebSocket Protocol</dd>

	<dt title="Interoperability considerations">相互運用性についての考慮点</dt>
	<dd>
WebSocket の利用は HTTP バージョン 1.1 以上の利用を要求する。
<span lang="en">
Use of WebSocket requires use of HTTP version 1.1 or higher.
</span></dd>

	<dt title="Security considerations">セキュリティ上の考慮点</dt>
	<dd>
 “<a href="#section-10"> セキュリティ上の考慮点</a>” 節を見よ。
<span lang="en">
See "Security Considerations" section.
</span></dd>

	<dt title="Contact">連絡先</dt>
	<dd>HYBI WG &lt;hybi@ietf.org&gt;</dd>

	<dt title="Author/Change controller">作成／変更管理</dt>
	<dd>IETF &lt;iesg@ietf.org&gt;</dd>

	<dt title="References">参照</dt>
	<dd><a href="./rfc6455">RFC 6455</a></dd>

</dl>

		</section>
		<section id="section-11.1.2">

<h4 title="Registration of &quot;wss&quot; Scheme">11.1.2. "wss" スキームの登録</h4>

<p>
<b>wss</b> URI は、 WebSocket サーバとリソース名を識別し，その接続を通るトラフィックが TLS により保護されることになることを指示する（データの機密性と完全性および端点の認証などの， TLS の標準的な利点も含め）。
<span lang="en">
A |wss| URI identifies a WebSocket server and resource name and indicates that traffic over that connection is to be protected via TLS (including standard benefits of TLS such as data confidentiality and integrity and endpoint authentication).
</span></p>

<dl>
	<dt title="URI scheme name">URI スキーム名</dt>
	<dd>wss</dd>

	<dt title="Status">位置付け</dt>
	<dd>
恒久的
<span lang="en">
Permanent
</span></dd>

	<dt title="URI scheme syntax">URI スキーム構文</dt>
	<dd>
<p>
ABNF <a>[RFC5234]</a> 構文および
URI 仕様 <a>[RFC3986]</a> の ABNF の終端記号を用いて：
<span lang="en">
Using the ABNF [RFC5234] syntax and ABNF terminals from the URI specification [RFC3986]:
</span></p>

<pre class="ABNF">
"wss:" "//" authority path-abempty [ "?" query ]
</pre>

	</dd>
	<dd>
<p><!-- copy* -->
<code class="ABNF">path-abempty</code> と <code class="ABNF">query</code> 成分は、要望されたサービスの種類を識別するために，サーバへ送信されるリソース名を形成する。
他の成分は、 <a>[RFC3986]</a> に述べられる意味を持つ。
<span lang="en">
The &lt;path-abempty&gt; and &lt;query&gt; components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in [RFC3986].
</span></dd>

	<dt title="URI scheme semantics">URI スキーム意味論</dt>
	<dd>
このスキームのための唯一の運用は、 WebSocket Protocol を利用して， TLS により暗号化された接続を open することである。
<span lang="en">
The only operation for this scheme is to open a connection using the WebSocket Protocol, encrypted using TLS.
</span></dd>

	<dt title="Encoding considerations">符号化方式についての考慮点</dt>
	<dd>
<!-- copy* -->
上で定義された構文から除外されたホスト成分­内の文字は、
<a>[RFC3987]</a> またはその後継文書の指定に従って，
Unicode から ASCII へ変換されなければ<em class="rfc2119">ならない</em>。
スキームに基づく正規化の目的においては、 IDN 形式<!--1-->によるホスト成分と, それをピュニコード
<span class="trans-note">【 punycode — <a href="http://ja.wikipedia.org/wiki/Punycode" >参考</a>】</span>
へ変換したものとは，等価なものと見なされる（
<a>[RFC3987]</a> <a href="./rfc3987#section-5.3.3">5.3.3 節</a>
参照）。
<span lang="en">
Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII as specified in [RFC3987] or its replacement. For the purposes of scheme-based normalization IDN forms of the host component and their conversions to punycode are considered equivalent (see Section 5.3.3 of [RFC3987]).
</span></dd>
	<dd>
<!-- copy* -->
上で定義された構文から除外された，他の成分­内の文字は、まず， UTF-8 に符号化した上で，結果のバイト並びを［
URI <a>[RFC3986]</a>, IRI <a>[RFC3987]</a>
］仕様の定義に従って，パーセント符号化形に置換することにより、
Unicode から ASCII へ変換されなければ<em class="rfc2119">ならない</em>。
<span lang="en">
Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI [RFC3986] and IRI [RFC3987] specifications.
</span></dd>

	<dt title="Applications/protocols that use this URI scheme name">この URI スキーム名を利用するアプリケーション／プロトコル</dt>
	<dd>
TLS を通した WebSocket Protocol
<span lang="en">
WebSocket Protocol over TLS
</span></dd>

	<dt title="Interoperability considerations">相互運用性についての考慮点</dt>
	<dd>
<!-- copy -->
WebSocket の利用は HTTP バージョン 1.1 以上の利用を要求する。
<span lang="en">
Use of WebSocket requires use of HTTP version 1.1 or higher.
</span></dd>

	<dt title="Security considerations">セキュリティ上の考慮点</dt>
	<dd>
<!-- copy -->
“<a href="#section-10"> セキュリティ上の考慮点</a>” 節を見よ。
<span lang="en">
See "Security Considerations" section.
</span></dd>

	<dt title="Contact">連絡先</dt>
	<dd>HYBI WG &lt;hybi@ietf.org&gt;</dd>

	<dt title="Author/Change controller">作成／変更管理</dt>
	<dd>IETF &lt;iesg@ietf.org&gt;</dd>

	<dt title="References">参照</dt>
	<dd><a href="./rfc6455">RFC 6455</a></dd>

</dl>

		</section>
	</section>
	<section id="section-11.2">

<h3 title="Registration of the &quot;WebSocket&quot; HTTP Upgrade Keyword">11.2. "WebSocket" HTTP Upgrade キーワードの登録</h3>

<p>
この節では、 <a>[RFC2817]</a> に従って， HTTP Upgrade Tokens Registry に登録されたキーワードを定義する。
<span lang="en">
This section defines a keyword registered in the HTTP Upgrade Tokens Registry as per RFC 2817 [RFC2817].
</span></p>

<dl>

	<dt title="Name of token">トークンの名前</dt>
	<dd>WebSocket</dd>
	
	<dt title="Author/Change controller">作成／変更管理</dt>
	<dd>IETF &lt;iesg@ietf.org&gt;</dd>
	
	<dt title="Contact">連絡先</dt>
	<dd>HYBI &lt;hybi@ietf.org&gt;</dd>
	
	<dt title="References">参照</dt>
	<dd><a href="./rfc6455">RFC 6455</a></dd>

</dl>

	</section>
	<section id="section-11.3">

<h3 title="Registration of New HTTP Header Fields">11.3. 新たな HTTP ヘッダの登録</h3>

		<section id="section-11.3.1">

<h4>11.3.1. <b>Sec-WebSocket-Key</b></h4>

<p>
この節では、
Permanent Message Header Field Names レジストリ <a>[RFC3864]</a>
に登録されたヘッダを述べる。
<span lang="en">
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
</span></p>

<dl>

	<dt title="Header field name">ヘッダ名</dt>
	<dd><b>Sec-WebSocket-Key</b></dd>
	
	<dt title="Applicable protocol">適用可能なプロトコル</dt>
	<dd>http</dd>
	
	<dt title="Status">位置付け</dt>
	<dd>
標準
<span lang="en">
standard
</span></dd>

	<dt title="Author/Change controller">作成／変更管理</dt>
	<dd>IETF</dd>
	
	<dt title="Specification document(s)">仕様­文書</dt>
	<dd><a href="./rfc6455">RFC 6455</a></dd>
	
	<dt title="Related information">関連情報</dt>
	<dd>
このヘッダは WebSocket opening ハンドシェイクにおいてのみ利用される。
<span lang="en">
This header field is only used for WebSocket opening handshake.
</span></dd>

</dl>

<p>
<b>Sec-WebSocket-Key</b> ヘッダは WebSocket opening ハンドシェイクの中で利用される。
これは、サーバが妥当な WebSocket opening ハンドシェイクを受信したことを立証するための一環として，クライアントからサーバへ送信されるものであり、サーバが利用する情報の一部を供する。
これは、 "疑わない" （ unsuspecting ） WebSocket サーバへ向けてデータ送信を濫用する非 WebSocket クライアント（例えば， HTTP クライアント）からの接続を，サーバが受理しないようにすることを支援する。
<span lang="en">
The |Sec-WebSocket-Key| header field is used in the WebSocket opening handshake. It is sent from the client to the server to provide part of the information used by the server to prove that it received a valid WebSocket opening handshake. This helps ensure that the server does not accept connections from non-WebSocket clients (e.g., HTTP clients) that are being abused to send data to unsuspecting WebSocket servers.
</span></p>

<p>
<b>Sec-WebSocket-Key</b> ヘッダは、一個の HTTP リクエストの中に複数回出現しては<em class="rfc2119">ならない</em>。
<span lang="en">
The |Sec-WebSocket-Key| header field MUST NOT appear more than once in an HTTP request.
</span></p>

		</section>
		<section id="section-11.3.2">

<h4>11.3.2. <b>Sec-WebSocket-Extensions</b></h4>

<p><!-- copy* -->
この節では、
Permanent Message Header Field Names レジストリ <a>[RFC3864]</a> 
に登録されたヘッダを述べる。
<span lang="en">
This section describes a header field for registration in the Permanent Message Header Field Names registry [RFC3864].
</span></p>

<dl>

	<dt title="Header field name">ヘッダ名</dt>
	<dd><b>Sec-WebSocket-Extensions</b></dd>
	
	<dt title="Applicable protocol">適用可能なプロトコル</dt>
	<dd>http</dd>
	
	<dt title="Status">位置付け</dt>
	<dd>
標準
<span lang="en">
standard
</span></dd>

	<dt title="Author/Change controller">作成／変更管理</dt>
	<dd>IETF</dd>
	
	<dt title="Specification document(s)">仕様­文書</dt>
	<dd><a href="./rfc6455">RFC 6455</a></dd>
	
	<dt title="Related information">関連情報</dt>
	<dd>
<!-- copy -->
このヘッダは WebSocket opening ハンドシェイクにおいてのみ利用される。
<span lang="en">
This header field is only used for WebSocket opening handshake.
</span></dd>

</dl>

<p>
<b>Sec-WebSocket-Extensions</b> ヘッダは WebSocket opening ハンドシェイクの中で利用される。
クライアントからサーバへ初期­時に送信され，後続して，接続の間に利用するプロトコル­レベルの一連の拡張への同意を示すために，サーバからクライアントへ送信される。
<span lang="en">
The |Sec-WebSocket-Extensions| header field is used in the WebSocket opening handshake. It is initially sent from the client to the server, and then subsequently sent from the server to the client, to agree on a set of protocol-level extensions to use for the duration of the connection.
</span></p>

<p>
一個の HTTP リクエストの中に複数の
<b>Sec-WebSocket-Extensions</b> ヘッダが出現しても<em class="rfc2119">よい</em>（すべての値を含んでいる単独の <b>Sec-WebSocket-Extensions</b> ヘッダと論理的に同じ）。
<del>
しかしながら，一個の HTTP 応答の中では、複数の
<b>Sec-WebSocket-Extensions</b> ヘッダが出現しては<em class="rfc2119">ならない</em>。
</del>
<span class="trans-note">【<a href="http://www.rfc-editor.org/errata_search.php?rfc=6455">正誤表</a>による修正（ Verified ）：】</span>
<ins>
また、一個の HTTP 応答の中に複数の
<b >Sec-WebSocket-Extensions</b> ヘッダが出現しても<em class="rfc2119">よい</em>（すべての値を含んでいる単独の <b>Sec-WebSocket-Extensions</b> ヘッダと論理的に同じ）。
</ins>
<span lang="en">
The |Sec-WebSocket-Extensions| header field MAY appear multiple times in an HTTP request (which is logically the same as a single |Sec-WebSocket-Extensions| header field that contains all values. <del>However, the |Sec-WebSocket-Extensions| header field MUST NOT appear more than once in an HTTP response.</del>
<ins>The |Sec-WebSocket-Extensions| header field MAY appear multiple 
times in an HTTP response (which is logically the same as a single
|Sec-WebSocket-Extensions| header field that contains all values).</ins>
</span></p>

		</section>
		<section id="section-11.3.3">

<h4>11.3.3. <b>Sec-WebSocket-Accept</b></h4>

<p><!-- copy -->
この節では
Permanent Message Header Field Names レジストリ <a>[RFC3864]</a> 
に登録されたヘッダを述べる。
<span lang="en">
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
</span></p>

<dl>

	<dt title="Header field name">ヘッダ名</dt>
	<dd><b>Sec-WebSocket-Accept</b></dd>
	
	<dt title="Applicable protocol">適用可能なプロトコル</dt>
	<dd>http</dd>
	
	<dt title="Status">位置付け</dt>
	<dd>
標準
<span lang="en">
standard
</span></dd>

	<dt title="Author/Change controller">作成／変更管理</dt>
	<dd>IETF</dd>
	
	<dt title="Specification document(s)">仕様­文書</dt>
	<dd><a href="./rfc6455">RFC 6455</a></dd>
	
	<dt title="Related information">関連情報</dt>
	<dd>
<!-- copy -->
このヘッダは WebSocket opening ハンドシェイクにおいてのみ利用される。
<span lang="en">
This header field is only used for the WebSocket opening handshake.
</span></dd>

</dl>

<p>
<b>Sec-WebSocket-Accept</b> ヘッダは WebSocket opening ハンドシェイクの中で利用される。
サーバが WebSocket 接続に起動する意向があることを立証するために、サーバからクライアントへ送信される。
<span lang="en">
The |Sec-WebSocket-Accept| header field is used in the WebSocket opening handshake. It is sent from the server to the client to confirm that the server is willing to initiate the WebSocket connection.
</span></p>

<p>
<b>Sec-WebSocket-Accept</b> ヘッダは、一個の HTTP 応答の中に複数回出現しては<em class="rfc2119">ならない</em>。
<span lang="en">
The |Sec-WebSocket-Accept| header MUST NOT appear more than once in an HTTP response.
</span></p>

		</section>
		<section id="section-11.3.4">

<h4>11.3.4. <b>Sec-WebSocket-Protocol</b></h4>

<p><!-- copy -->
この節では
Permanent Message Header Field Names レジストリ <a>[RFC3864]</a> 
に登録されたヘッダを述べる。
<span lang="en">
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
</span></p>

<dl>
	<dt title="Header field name">ヘッダ名</dt>
	<dd><b>Sec-WebSocket-Protocol</b></dd>
	
	<dt title="Applicable protocol">適用可能なプロトコル</dt>
	<dd>http</dd>
	
	<dt title="Status">位置付け</dt>
	<dd>
標準
<span lang="en">
standard
</span></dd>

	<dt title="Author/Change controller">作成／変更管理</dt>
	<dd>IETF</dd>
	
	<dt title="Specification document(s)">仕様­文書</dt>
	<dd><a href="./rfc6455">RFC 6455</a></dd>
	
	<dt title="Related information">関連情報</dt>
	<dd>
<!-- copy -->
このヘッダは WebSocket opening ハンドシェイクにおいてのみ利用される。
<span lang="en">
This header field is only used for the WebSocket opening handshake.
</span></dd>

</dl>

<p>
<b>Sec-WebSocket-Protocol</b> ヘッダは WebSocket opening ハンドシェイクの中で利用される。
接続の下位プロトコルの確認のために、クライアントからサーバへ送信され，サーバからクライアントへ返信される。
これにより，スクリプトは、下位プロトコルを選択した上で，サーバがその下位プロトコルの役務に同意したことを確かめられるようになる。
<span lang="en">
The |Sec-WebSocket-Protocol| header field is used in the WebSocket opening handshake. It is sent from the client to the server and back from the server to the client to confirm the subprotocol of the connection. This enables scripts to both select a subprotocol and be sure that the server agreed to serve that subprotocol.
</span></p>

<p><!-- copy* -->
一個の HTTP リクエストの中に複数の
<b>Sec-WebSocket-Protocol</b> ヘッダが出現しても<em class="rfc2119">よい</em>（すべての値を含んでいる単独の <b>Sec-WebSocket-Protocol</b> ヘッダと論理的に同じ）。
しかしながら，一個の HTTP 応答の中では，複数の
<b>Sec-WebSocket-Protocol</b> ヘッダが出現しては<em class="rfc2119">ならない</em>。
<span lang="en">
The |Sec-WebSocket-Protocol| header field MAY appear multiple times in an HTTP request (which is logically the same as a single |Sec-WebSocket-Protocol| header field that contains all values). However, the |Sec-WebSocket-Protocol| header field MUST NOT appear more than once in an HTTP response.
</span></p>


		</section>
		<section id="section-11.3.5">

<h4>11.3.5. <b>Sec-WebSocket-Version</b></h4>

<p><!-- copy -->
この節では、
Permanent Message Header Field Names レジストリ <a>[RFC3864]</a> 
に登録されたヘッダを述べる。
<span lang="en">
This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].
</span></p>

<dl>

	<dt title="Header field name">ヘッダ名</dt>
	<dd><b>Sec-WebSocket-Version</b></dd>
	
	<dt title="Applicable protocol">適用可能なプロトコル</dt>
	<dd>http</dd>
	
	<dt title="Status">位置付け</dt>
	<dd>
標準
<span lang="en">
standard
</span></dd>

	<dt title="Author/Change controller">作成／変更管理</dt>
	<dd>IETF</dd>
	
	<dt title="Specification document(s)">仕様­文書</dt>
	<dd><a href="./rfc6455">RFC 6455</a></dd>

	<dt title="Related information">関連情報</dt>
	<dd>
<!-- copy -->
このヘッダは WebSocket opening ハンドシェイクにおいてのみ利用される。
<span lang="en">
This header field is only used for the WebSocket opening handshake.
</span></dd>

</dl>

<p>
<b>Sec-WebSocket-Version</b> ヘッダは WebSocket opening ハンドシェイクにおいて利用される。
これは接続のプロトコル­バージョンを指示するために，クライアントからサーバへ送信される。
これにより、サーバは， opening ハンドシェイクとそのデータに後続して送信されたデータを正しく解釈でき、サーバがデータを安全な仕方で解釈できない場合には接続を close できるようになる。
<b>Sec-WebSocket-Version</b> ヘッダは、クライアントから受信されたバージョンがサーバが解せるバージョンに合致しないときの WebSocket ハンドシェイク­エラーの際にも，サーバからクライアントへ送信される。
その場合、このヘッダは，サーバでサポートされるプロトコル­バージョンを内包する。
<span lang="en">
The |Sec-WebSocket-Version| header field is used in the WebSocket opening handshake. It is sent from the client to the server to indicate the protocol version of the connection. This enables servers to correctly interpret the opening handshake and subsequent data being sent from the data, and close the connection if the server cannot interpret that data in a safe manner. The |Sec-WebSocket-Version| header field is also sent from the server to the client on WebSocket handshake error, when the version received from the client does not match a version understood by the server. In such a case, the header field includes the protocol version(s) supported by the server.
</span></p>

<p>
必ずしも、より上のバージョン番号が，より下のバージョン番号と後方互換であることは、期待されていないことに注意。
<span lang="en">
Note that there is no expectation that higher version numbers are necessarily backward compatible with lower version numbers.
</span></p>

<p><!-- copy* -->
一個の HTTP リクエストの中に
<b>Sec-WebSocket-Version</b> ヘッダが複数回出現しても<em class="rfc2119">よい</em>（すべての値を含んでいる単独の
<b>Sec-WebSocket-Version</b> ヘッダと論理的に同じ）。
しかしながら，一個の HTTP 応答の中では、
<b>Sec-WebSocket-Version</b> ヘッダが複数回出現しては<em class="rfc2119">ならない</em>。
<span lang="en">
The |Sec-WebSocket-Version| header field MAY appear multiple times in an HTTP response (which is logically the same as a single |Sec-WebSocket-Version| header field that contains all values). However, the |Sec-WebSocket-Version| header field MUST NOT appear more than once in an HTTP request.
</span></p>

		</section>
	</section>
	<section id="section-11.4">

<h3 title="WebSocket Extension Name Registry">11.4. WebSocket 拡張名レジストリ</h3>

<p>
この仕様は、 <a>[RFC5226]</a> に提示される原則に則り， WebSocket Protocol と併用される WebSocket 拡張­名のための、新たな IANA レジストリを作成する。
<span lang="en">
This specification creates a new IANA registry for WebSocket Extension names to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].
</span></p>

<p>
このレジストリの一部として、 IANA は以下の情報を維持管理する：
<span lang="en">
As part of this registry, IANA maintains the following information:
</span></p>

<dl>

	<dt title="Extension Identifier">拡張­識別子</dt>
	<dd>
この仕様の <a>11.3.2 節</a> にて登録される，
<b>Sec-WebSocket-Extensions</b> ヘッダに利用されることになる拡張の識別子。
値は、この仕様の <a>9.1 節</a> で定義されている <code class="ABNF">extension-token</code> に課される要件に適合しなければならない。
<span lang="en">
The identifier of the extension, as will be used in the |Sec-WebSocket-Extensions| header field registered in Section 11.3.2 of this specification. The value must conform to the requirements for an extension-token as defined in Section 9.1 of this specification.
</span></dd>

	<dt title="Extension Common Name">拡張­共通名</dt>
	<dd>
拡張を一般に参照するための，拡張の名前。
<span lang="en">
The name of the extension, as the extension is generally referred to.
</span></dd>

	<dt title="Extension Definition">拡張­定義</dt>
	<dd>
WebSocket Protocol と伴用される拡張が定義される文書への参照
<span lang="en">
A reference to the document in which the extension being used with the WebSocket Protocol is defined.
</span></dd>

	<dt title="Known Incompatible Extensions">既知の非互換­拡張</dt>
	<dd>
この拡張と非互換であることが既知である拡張の，識別子のリスト
<span lang="en">
A list of extension identifiers with which this extension is known to be incompatible.
</span></dd>

</dl>

<p>
WebSocket Extension 名は、
"First Come First Served" IANA 登録ポリシー <a>[RFC5226]</a>
の対象になる。
<span lang="en">
WebSocket Extension names are to be subject to the "First Come First Served" IANA registration policy [RFC5226].
</span></p>

<p>
このレジストリには初期­値は存在しない。
<span lang="en">
There are no initial values in this registry.
</span></p>

	</section>
	<section id="section-11.5">

<h3 title="WebSocket Subprotocol Name Registry">11.5. WebSocket 下位プロトコル名レジストリ</h3>

<p><!-- copy* -->
この仕様は、 <a>[RFC5226]</a> に提示される原則に則り， WebSocket Protocol と併用される WebSocket 下位プロトコル名のための、新たな IANA レジストリを作成する。
<span lang="en">
This specification creates a new IANA registry for WebSocket Subprotocol names to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].
</span></p>

<p><!-- copy -->
このレジストリの一部として、 IANA は以下の情報を維持管理する：
<span lang="en">
As part of this registry, IANA maintains the following information:
</span></p>

<dl>
	<dt title="Subprotocol Identifier">下位プロトコル識別子</dt>
	<dd>
この仕様の <a>11.3.4 節</a> にて登録される，
<b>Sec-WebSocket-Protocol</b> ヘッダに利用されることになる，下位プロトコルの識別子。
値は、この仕様の <a>4.1 節</a> の<a href="#subprotocol-req">第 10 項</a>で与えられた要件に適合しなければならない
— すなわち，値は、 <a>[RFC2616]</a>
に定義されるトークン
<span class="trans-note">【 <code>token</code> 生成規則に合致】</span>
でなければならない。
<span lang="en">
The identifier of the subprotocol, as will be used in the |Sec-WebSocket-Protocol| header field registered in Section 11.3.4 of this specification. The value must conform to the requirements given in item 10 of Section 4.1 of this specification -- namely, the value must be a token as defined by RFC 2616 [RFC2616].
</span></dd>

	<dt title="Subprotocol Common Name">下位プロトコル共通名</dt>
	<dd>
下位プロトコルを一般に参照するための，下位プロトコルの名前。
<span lang="en">
The name of the subprotocol, as the subprotocol is generally referred to.
</span></dd>

	<dt title="Subprotocol Definition">下位プロトコル定義</dt>
	<dd>
<!-- copy* -->
WebSocket Protocol と伴用される下位プロトコルが定義される文書への参照
<span lang="en">
A reference to the document in which the subprotocol being used with the WebSocket Protocol is defined.
</span></dd>

</dl>

<p><!-- copy* -->
WebSocket Subprotocol 名は、
"First Come First Served" IANA 登録ポリシー <a>[RFC5226]</a>
の対象になる。
<span lang="en">
WebSocket Subprotocol names are to be subject to the "First Come First Served" IANA registration policy [RFC5226].
</span></p>


	</section>
	<section id="section-11.6">

<h3 title="WebSocket Version Number Registry">11.6. WebSocket バージョン番号レジストリ</h3>

<p><!-- copy* -->
この仕様は、 <a>[RFC5226]</a> に提示される原則に則り， WebSocket Protocol と併用される WebSocket バージョン番号のための、新たな IANA レジストリを作成する。
<span lang="en">
This specification creates a new IANA registry for WebSocket Version Numbers to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].
</span></p>

<p><!-- copy -->
このレジストリの一部として、 IANA は以下の情報を維持管理する：
<span lang="en">
As part of this registry, IANA maintains the following information:
</span></p>

<dl>
	<dt title="Version Number">バージョン番号</dt>
	<dd>
<b>Sec-WebSocket-Version</b> ヘッダの中で利用されるバージョン番号は、この仕様の <a>4.1 節</a> にて指定される。
値は、 0 〜 255 の範囲の非負­整数でなければならない。
<span lang="en">
The version number to be used in the |Sec-WebSocket-Version| is specified in Section 4.1 of this specification. The value must be a non-negative integer in the range between 0 and 255 (inclusive).
</span></dd>

	<dt title="Reference">参照</dt>
	<dd>
新たなバージョン番号またはバージョン番号を伴う草案の名前を要請している RFC （下を見よ）。
<span lang="en">
The RFC requesting a new version number or a draft name with version number (see below).
</span></dd>

	<dt title="Status">位置付け</dt>
	<dd>
"Interim" （暫定）または "Standard" （標準）のいずれか。
下の記述を見よ。
<span lang="en">
Either "Interim" or "Standard". See below for description.
</span></dd>

</dl>

<p>
バージョン番号は、 "Interim" または "Standard" として指定されている。
<span lang="en">
A version number is designated as either "Interim" or "Standard".
</span></p>

<p>
"Standard" バージョン番号は、RFC の中で文書­化され、この RFC で定義されるバージョンのような， WebSocket プロトコルのメジャーかつ安定的なバージョンを識別するために利用される。
"Standard" バージョン番号は、
"IETF Review" IANA 登録ポリシー <a>[RFC5226]</a>
の対象になる。
<span lang="en">
A "Standard" version number is documented in an RFC and used to identify a major, stable version of the WebSocket protocol, such as the version defined by this RFC. "Standard" version numbers are subject to the "IETF Review" IANA registration policy [RFC5226].
</span></p>

<p>
"Interim" バージョン番号は、 Internet-Draft の中で文書­化され、この RFC の発行前に開発されたバージョンなど，実装者による， WebSocket プロトコルの頒布バージョンとの識別や相互運用を支援するために利用される。
"Interim" バージョン番号は、initial Designated Experts である HYBI Working Group の chairs（または， working group が解散したときは， IETF Applications Area の Area Directors ）からの， "Expert Review" IANA 登録ポリシー <a>[RFC5226]</a> の対象になる。
<span lang="en">
An "Interim" version number is documented in an Internet-Draft and used to help implementors identify and interoperate with deployed versions of the WebSocket protocol, such as versions developed before the publication of this RFC. "Interim" version numbers are subject to the "Expert Review" IANA registration policy [RFC5226], with the chairs of the HYBI Working Group (or, if the working group closes, the Area Directors for the IETF Applications Area) being the initial Designated Experts.
</span></p>

<p>
IANA は、以下の，レジストリの初期­値を追加した。
<span lang="en">
IANA has added initial values to the registry as follows.
</span></p>

<table>
	<caption></caption>
	<thead><tr>
<th title="Version Number"> バージョン番号</th>
<th title="Reference">参照</th>
<th title="Status">位置付け</th>
	</tr></thead>
	<tbody>
<tr><td>0</td><td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-00">draft-ietf-hybi-thewebsocketprotocol-00</a>
</td><td>Interim </td></tr>
<tr><td>1</td><td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-01">draft-ietf-hybi-thewebsocketprotocol-01</a>
</td><td>Interim </td></tr>
<tr><td>2</td><td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-02">draft-ietf-hybi-thewebsocketprotocol-02</a>
</td><td>Interim </td></tr>
<tr><td>3</td><td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-03">draft-ietf-hybi-thewebsocketprotocol-03</a>
</td><td>Interim </td></tr>
<tr><td>4</td><td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-04">draft-ietf-hybi-thewebsocketprotocol-04</a>
</td><td>Interim </td></tr>
<tr><td>5</td><td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-05">draft-ietf-hybi-thewebsocketprotocol-05</a>
</td><td>Interim </td></tr>
<tr><td>6</td><td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-06">draft-ietf-hybi-thewebsocketprotocol-06</a>
</td><td>Interim </td></tr>
<tr><td>7</td><td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-07">draft-ietf-hybi-thewebsocketprotocol-07</a>
</td><td>Interim </td></tr>
<tr><td>8</td><td>
<a href="./draft-ietf-hybi-thewebsocketprotocol-08">draft-ietf-hybi-thewebsocketprotocol-08</a>
</td><td>Interim </td></tr>
<tr><td>9</td><td>Reserved</td><td></td></tr>
<tr><td>10</td><td>Reserved</td><td></td></tr>
<tr><td>11</td><td>Reserved</td><td></td></tr>
<tr><td>12</td><td>Reserved</td><td></td></tr>
<tr><td>13</td><td><a href="./rfc6455">RFC 6455</a></td><td>Standard</td></tr>
	</tbody>
</table>


	</section>
	<section id="section-11.7">

<h3 title="WebSocket Close Code Number Registry">11.7. WebSocket  close コード番号レジストリ</h3>

<p><!-- copy* -->
この仕様は、 <a>[RFC5226]</a> に提示される原則に則り，
WebSocket Protocol と併用される WebSocket  close コード番号のための、新たな IANA レジストリを作成する。
<span lang="en">
This specification creates a new IANA registry for WebSocket Connection Close Code Numbers in accordance with the principles set out in RFC 5226 [RFC5226].
</span></p>

<p><!-- copy -->
このレジストリの一部として、 IANA は以下の情報を維持管理する：
<span lang="en">
As part of this registry, IANA maintains the following information:
</span></p>

<dl>

	<dt title="Status Code">ステータスコード</dt>
	<dd>
Status Code は、この文書の <a>7.4 節</a> に従って
WebSocket 接続 closure の事由を表す。
ステータスコードは 1000 〜 4999 の範囲の整数である。
<span lang="en">
The Status Code denotes a reason for a WebSocket connection closure as per Section 7.4 of this document. The status code is an integer number between 1000 and 4999 (inclusive).
</span></dd>

	<dt title="Meaning">意味</dt>
	<dd>
ステータスコードが持つ意味。
それぞれのステータスコードは一意的な意味を持っていなければならない。
<span lang="en">
The meaning of the status code. Each status code has to have a unique meaning.
</span></dd>

	<dt title="Contact">連絡先</dt>
	<dd>
ステータスコードを予約した主体の連絡先。
<span lang="en">
A contact for the entity reserving the status code.
</span></dd>

	<dt title="Reference">参照</dt>
	<dd>
ステータスコードとそれらの意味の定義を要請している安定的な文書。
これは、範囲 1000-2999 のステータスコードに要求され，範囲 3000-3999 のステータスコードに推奨される。
<span lang="en">
The stable document requesting the status codes and defining their meaning. This is required for status codes in the range 1000-2999 and recommended for status codes in the range 3000-3999.
</span></dd>

</dl>

<p>
WebSocket Close Code Numbers は、それらの範囲に依存して，異なる登録­要件の対象になる。
［
このプロトコルとその後続バージョン, または拡張
］用途のステータスコードの要請は［
"Standards Action",
"Specification Required" （ "Designated Expert" も伴われることになる），
"IESG Review" IANA 登録ポリシー
］のいずれかの対象になり、範囲 1000-2999 に対して認可されるべきである。
［
ライブラリ／フレームワーク／アプリケーション
］用途のステータスコードの要請は、
“First Come First Served" IANA 登録ポリシーの対象になり、範囲 3000-3999 に対して認可されるべきである。
範囲 4000-4999 のステータスコードは Private Use （私的利用）の指定を受けている。
その要請は、［
WebSocket Protocol （またはその将来バージョン） ／
拡張 ／
［
ライブラリ／フレームワーク／アプリケーション
］］の，どの用途でステータスコードを要請しているかを指示するべきである。
<span lang="en">
WebSocket Close Code Numbers are subject to different registration requirements depending on their range. Requests for status codes for use by this protocol and its subsequent versions or extensions are subject to any one of the "Standards Action", "Specification Required" (which implies "Designated Expert"), or "IESG Review" IANA registration policies and should be granted in the range 1000-2999. Requests for status codes for use by libraries, frameworks, and applications are subject to the "First Come First Served" IANA registration policy and should be granted in the range 3000-3999. The range of status codes from 4000-4999 is designated for Private Use. Requests should indicate whether they are requesting status codes for use by the WebSocket Protocol (or a future version of the protocol), by extensions, or by libraries/frameworks/applications.
</span></p>

<p><!-- copy -->
IANA は、以下のレジストリの初期­値を追加した。
<span lang="en">
IANA has added initial values to the registry as follows.
</span></p>

<table>
	<thead><tr>
<th title="Status Code">ステータスコード</th>
<th title="Meaning"> 意味</th>
<th title="Contact">連絡先</th>
<th title="Reference">参照</th>
	</tr></thead>
	<tbody>
<tr><td>1000</td><td>
正常な closure <span lang="en">Normal Closure</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC&nbsp;6455</a></td></tr>
<tr><td>1001</td><td>
消失 <span lang="en">Going Away</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1002</td><td>
プロトコル­エラー <span lang="en">Protocol error</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1003</td><td>
未サポートのデータ <span lang="en">Unsupported Data</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1004</td><td>
---予約済み<!--1-->---- <span lang="en">---Reserved----</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1005</td><td>
ステータスが受信されなかった <span lang="en">No Status Rcvd</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1006</td><td>
異常な closure <span lang="en">Abnormal Closure</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1007</td><td>
妥当でないフレーム ペイロード­データ<span lang="en">Invalid frame payload data</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1008</td><td>
ポリシー違反 <span lang="en">Policy Violation</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1009</td><td>
大き過ぎるメッセージ <span lang="en">Message Too Big</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1010</td><td>
必須の拡張<span lang="en">Mandatory Ext.</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1011</td><td>
サーバ内部のエラー <span lang="en">Internal Server Error</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><td>1015</td><td>
TLS ハンドシェイク <span lang="en">TLS handshake</span>
</td><td>hybi@ietf.org</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
	</tbody>
</table>


	</section>
	<section id="section-11.8">

<h3 title="WebSocket Opcode Registry">11.8. WebSocket opcode レジストリ</h3>

<p><!-- copy* -->
この仕様は、 <a>[RFC5226]</a> に提示される原則に則り，
WebSocket Protocol と併用される WebSocket opcode のための、新たな IANA レジストリを作成する。
<span lang="en">
This specification creates a new IANA registry for WebSocket Opcodes in accordance with the principles set out in RFC 5226 [RFC5226].
</span></p>

<p><!-- copy -->
このレジストリの一部として、 IANA は以下の情報を維持管理する：
<span lang="en">
As part of this registry, IANA maintains the following information:
</span></p>

<dl>

	<dt title="Opcode">Opcode</dt>
	<dd>
opcode は、WebSocket フレームのフレーム種別を表す。
<a>5.2 節</a> の定義に従って，
opcode は、 0 〜 15 の範囲の整数である。
<span lang="en">
The opcode denotes the frame type of the WebSocket frame, as defined in Section 5.2. The opcode is an integer number between 0 and 15, inclusive.
</span></dd>

	<dt title="Meaning">意味</dt>
	<dd>
opcode 値の意味。
<span lang="en">
The meaning of the opcode value.
</span></dd>

	<dt title="Reference">参照</dt>
	<dd>
opcode を要請している仕様。
<span lang="en">
The specification requesting the opcode.
</span></dd>

</dl>

<p>
WebSocket Opcode 番号は、
"Standards Action" IANA 登録ポリシー <a>[RFC5226]</a>
の対象である。
<span lang="en">
WebSocket Opcode numbers are subject to the "Standards Action" IANA registration policy [RFC5226].
</span></p>

<p><!-- copy -->
IANA は、以下のレジストリの初期­値を追加した。
<span lang="en">
IANA has added initial values to the registry as follows.
</span></p>


<table>
	<caption></caption>
	<thead><tr>
<th>Opcode</th>
<th title="Meaning"> 意味</th>
<th title="Reference">参照</th>
	</tr></thead>
	<tbody>
<tr><th>0 </th><td>Continuation Frame</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><th>1 </th><td>Text Frame</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><th>2 </th><td>Binary Frame</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><th>8 </th><td>Connection Close Frame</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><th>9 </th><td>Ping Frame</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
<tr><th>10</th><td>Pong Frame</td><td><a href="./rfc6455">RFC 6455</a></td></tr>
	</tbody>

</table>


	</section>
	<section id="section-11.9">

<h3 title="WebSocket Framing Header Bits Registry">11.9. WebSocket フレーミング ヘッダ ビット レジストリ</h3>

<p><!-- copy* -->
この仕様は、 <a>[RFC5226]</a> に提示される原則に則り， WebSocket Protocol と併用される WebSocket フレーミング ヘッダ ビットのための、新たな IANA レジストリを作成する。
このレジストリは、 <a>5.2 節</a> の RSV1, RSV2, RSV3 ビットの割り当てを統制する。
<span lang="en">
This specification creates a new IANA registry for WebSocket Framing Header Bits in accordance with the principles set out in RFC 5226 [RFC5226]. This registry controls assignment of the bits marked RSV1, RSV2, and RSV3 in Section 5.2.
</span></p>

<p>
これらのビットは、この仕様の将来バージョンまたは拡張のために，予約済み<!--1-->である。
<span lang="en">
These bits are reserved for future versions or extensions of this specification.
</span></p>

<p>
WebSocket Framing Header Bits の割り当ては、
"Standards Action" IANA 登録ポリシー <a>[RFC5226]</a>
の対象になる。
<span lang="en">
WebSocket Framing Header Bits assignments are subject to the "Standards Action" IANA registration policy [RFC5226].
</span></p>

	</section>
</section>
<section id="section-12">

<h2 title="Using the WebSocket Protocol from Other Specifications">12. 他の仕様からの WebSocket プロトコルの利用</h2>

<p>
WebSocket Protocol は、動的な作者定義の内容のための，汎用の仕組みを提供するためのものとして、他の仕様からの利用が意図されている。
例えば，スクリプトのための API を定義する仕様の中で。
<span lang="en">
The WebSocket Protocol is intended to be used by another specification to provide a generic mechanism for dynamic author-defined content, e.g., in a specification defining a scripted API.
</span></p>

<p>
その種の仕様は、まず，次に挙げるものを伴うアルゴリズムを提供して
<a class="dfnref" href="#dfn-to-establish">WebSocket Connection を確立</a>
する必要がある：
<span lang="en">
Such a specification first needs to _Establish a WebSocket Connection_, providing that algorithm with:
</span></p>

<ul>
	<li>
<var>host</var> および <var>port</var> からなる宛先。
<span lang="en">
The destination, consisting of a /host/ and a /port/.
</span></li>
	<li>
一組のホスト, ポート下において複数のサービスの識別を可能にする， <var>resource-name</var> 。
<span lang="en">
A /resource name/, which allows for multiple services to be identified at one host and port.
</span></li>
	<li>
<var>secure</var> フラグ。
接続が暗号化される場合は true をとり，他の場合は false をとる。
<span lang="en">
A /secure/ flag, which is true if the connection is to be encrypted and false otherwise.
</span></li>
	<li>
接続のための信任を与える生成元 <a>[RFC6454]</a> の ASCII 直列化。
<!--  -->
<span lang="en">
An ASCII serialization of an origin [RFC6454] that is being made responsible for the connection.
</span></li>
	<li>
オプションで， WebSocket 接続­上に重ねられる層になるプロトコルを識別する文字列。
<!--  -->
<span lang="en">
Optionally, a string identifying a protocol that is to be layered over the WebSocket connection.
</span></li>
</ul>

<p>
<var>host</var>, <var>port</var>, <var>resource-name</var>, <var>secure</var> フラグは、通常， WebSocket URI の成分を構文解析する手続きを用いて URI から得られる。
これらの手続きは、 URI が WebSocket を指定していなければ失敗する。
<span lang="en">
The /host/, /port/, /resource name/, and /secure/ flag are usually obtained from a URI using the steps to parse a WebSocket URI's components. These steps fail if the URI does not specify a WebSocket.
</span></p>

<p>
接続が close されることになるときは，いつでも、仕様は
<a class="dfnref" href="#dfn-to-close">WebSocket 接続を close する</a>
アルゴリズムを利用する必要がある（ <a>7.1.1 節</a> ）。
<span lang="en">
If at any time the connection is to be closed, then the specification needs to use the _Close the WebSocket Connection_ algorithm (Section 7.1.1).
</span></p>

<p>
いつ
<a class="dfnref" href="#dfn-closed">WebSocket 接続が close される</a>
かは、 <a>7.1.4 節</a> にて定義されている。
<span lang="en">
Section 7.1.4 defines when _The WebSocket Connection is Closed_.
</span></p>

<p>
接続が open の間、仕様は
<a class="dfnref" href="#dfn-to-send">WebSocket メッセージが受信された</a>
（ <a>6.2 節</a> ）ときの場合を取り扱う必要がある。
<span lang="en">
While a connection is open, the specification will need to handle the cases when _A WebSocket Message Has Been Received_ (Section 6.2).
</span></p>

<p>
何らかのデータを open 接続に送信するためには、仕様は
<a class="dfnref" href="#dfn-to-send">WebSocket メッセージを送信する</a>
必要がある（ <a>6.1 節</a> ）。
<span lang="en">
To send some data /data/ to an open connection, the specification needs to _Send a WebSocket Message_ (Section 6.1).
</span></p>


</section>
<section id="section-13">

<h2 title="Acknowledgements">13. 謝辞</h2>

<p>
このプロトコルの元々の著者であり，編集者であった Ian Hickson 氏に特別な謝意を。
この仕様の初期の設計は、WHATWG と WHATWG のメーリングリストの多数の人々の関与から恩恵を受けている。
その仕様に対する寄与は、節として記録されてはいないが，その仕様に寄与された方々すべての一覧は、
<a href="http://whatwg.org/html5">http://whatwg.org/html5</a>
の WHATWG HTML 仕様に掲載されている。
<span lang="en">
Special thanks are due to Ian Hickson, who was the original author and editor of this protocol. The initial design of this specification benefitted from the participation of many people in the WHATWG and WHATWG mailing list. Contributions to that specification are not tracked by section, but a list of all who contributed to that specification is given in the WHATWG HTML specification at http://whatwg.org/html5.
</span></p>

<p>
この仕様の "<a href="#section-5">Data Framing</a>" 節に，多量の文章を寄稿してくれた John Tamplin 氏に特別な謝意を。
<span lang="en">
Special thanks also to John Tamplin for providing a significant amount of text for the "Data Framing" section of this specification.
</span></p>

<p>
この仕様の "Data Masking" 節に，多量の文章と背景調査を寄稿／提供してくれた Adam Barth 氏に特別な謝意を。
<span lang="en">
Special thanks also to Adam Barth for providing a significant amount of text and background research for the "Data Masking" section of this specification.
</span></p>

<p>
Lisa Dusseault 氏からの Apps Area 評価（と，この仕事の開始の支援に）,
Richard Barnes 氏からの Gen-Art 評価,
Magnus Westerlund 氏からの Transport Area Review に特別な謝意を。
舞台裏で不断に働き，この仕事を完了に向けて推進した過去の HYBI WG および現在の WG chairs に特別な謝意を： Joe Hildebrand, Salvatore Loreto, Gabriel Montenegro 氏。
前述のすべてに加えて， responsible Area Director の Peter Saint-Andre 氏に特別な謝意を。
<span lang="en">
Special thanks to Lisa Dusseault for the Apps Area review (and for helping to start this work), Richard Barnes for the Gen-Art review, and Magnus Westerlund for the Transport Area Review. Special thanks to HYBI WG past and present WG chairs who tirelessly worked behind the scene to move this work toward completion: Joe Hildebrand, Salvatore Loreto, and Gabriel Montenegro. And last but not least, special thank you to the responsible Area Director Peter Saint-Andre.
</span></p>

<p>
HYBI WG メーリングリストの議論に加わり，アイデアや詳細な評価を提供された次の方々に謝意を（この一覧はおそらく完全でない）：
<span lang="en">
Thank you to the following people who participated in discussions on the HYBI WG mailing list and contributed ideas and/or provided detailed reviews (the list is likely to be incomplete): 
</span></p>

<div>
Greg Wilkins, John Tamplin, Willy Tarreau, Maciej Stachowiak, Jamie Lokier, Scott Ferguson, Bjoern Hoehrmann, Julian Reschke, Dave Cridland, Andy Green, Eric Rescorla, Inaki Baz Castillo, Martin Thomson, Roberto Peon, Patrick McManus, Zhong Yu, Bruce Atherton, Takeshi Yoshino, Martin J. Duerst, James Graham, Simon Pieters, Roy T. Fielding, Mykyta Yevstifeyev, Len Holgate, Paul Colomiets, Piotr Kulaga, Brian Raymor, Jan Koehler, Joonas Lehtolahti, Sylvain Hellegouarch, Stephen Farrell, Sean Turner, Pete Resnick, Peter Thorson, Joe Mason, John Fallows, and Alexander Philippou.
</div>

<p>
上に挙げられているからと言って、彼らがこの仕事の最終成果を承認していることを意味するわけではないことに注意。
<span lang="en">
Note that people listed above didn't necessarily endorse the end result of this work.
</span></p>

</section>
<section id="section-14">

<h2 title="References">14. 参照文献</h2>

	<section id="section-14.1">

<h3 title="Normative References">14.1. 文献（規範的）</h3>

<dl>

	<dt>[ANSI.X3-4.1986]</dt>
	<dd>
American National Standards Institute,
<i>"Coded Character Set - 7-bit American Standard Code for Information Interchange"</i>,
ANSI X3.4, 1986.
</dd>

	<dt>[FIPS.180-3]</dt>
	<dd>
National Institute of Standards and Technology,
<i>"Secure Hash Standard"</i>,
FIPS PUB 180-3,
October 2008,
&lt;<a href="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf">http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf</a>&gt;.

<div class="trans-ja-refs">
<a href="http://www.ipa.go.jp/security/rfc/RFC3174JA.html">日本語訳（ RFC 3174 ）</a>
<a href="http://www7b.biglobe.ne.jp/~k-west/SSLandTLS/rfc3174-Ja.txt">日本語訳（ RFC 3174 ）</a>
</div>

	</dd>

	<dt>[RFC1928]</dt>
	<dd>
Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and
L. Jones,
<i>"SOCKS Protocol Version 5"</i>,
<a href="./rfc1928">RFC 1928</a>,
March 1996.
	</dd>

	<dt>[RFC2119]</dt>
	<dd>
Bradner, S.,
<i>"Key words for use in RFCs to Indicate Requirement Levels"</i>,
<a href="./bcp14">BCP 14</a>,
<a href="./rfc2119">RFC 2119</a>,
March 1997.
	</dd>

	<dt>[RFC2616]</dt>
	<dd>
Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
Masinter, L., Leach, P., and T. Berners-Lee,
<i>"Hypertext Transfer Protocol -- HTTP/1.1"</i>,
<a href="./rfc2616">RFC 2616</a>,
June 1999.
	</dd>

	<dt>[RFC2817]</dt>
	<dd>
Khare, R. and S. Lawrence,
<i>"Upgrading to TLS Within HTTP/1.1"</i>,
<a href="./rfc2817">RFC 2817</a>,
May 2000.
	</dd>

	<dt>[RFC2818]</dt>
	<dd>
Rescorla, E.,
<i>"HTTP Over TLS"</i>,
<a href="./rfc2818">RFC 2818</a>,
May 2000.
	</dd>

	<dt>[RFC3629]</dt>
	<dd>
Yergeau, F.,
<i>"UTF-8, a transformation format of ISO 10646"</i>,
STD 63,
<a href="./rfc3629">RFC 3629</a>,
November 2003.
	</dd>

	<dt>[RFC3864]</dt>
	<dd>
Klyne, G., Nottingham, M., and J. Mogul,
<i>"Registration Procedures for Message Header Fields"</i>,
<a href="./bcp90">BCP 90</a>,
<a href="./rfc3864">RFC 3864</a>,
September 2004.
	</dd>

	<dt>[RFC3986]</dt>
	<dd>
Berners-Lee, T., Fielding, R., and L. Masinter,
<i>"Uniform Resource Identifier (URI): Generic Syntax"</i>,
STD 66,
<a href="./rfc3986">RFC 3986</a>,
January 2005.
	</dd>

	<dt>[RFC3987]</dt>
	<dd>
Duerst, M. and M. Suignard,
<i>"Internationalized Resource Identifiers (IRIs)"</i>,
<a href="./rfc3987">RFC 3987</a>,
January 2005.
	</dd>

	<dt>[RFC4086]</dt>
	<dd>
Eastlake, D., Schiller, J., and S. Crocker,
<i>"Randomness Requirements for Security"</i>,
<a href="./bcp106">BCP 106</a>,
<a href="./rfc4086">RFC 4086</a>,
June 2005.
	</dd>

	<dt>[RFC4648]</dt>
	<dd>
Josefsson, S.,
<i>"The Base16, Base32, and Base64 Data Encodings"</i>,
<a href="./rfc4648">RFC 4648</a>,
October 2006.
	</dd>

	<dt>[RFC5226]</dt>
	<dd>
Narten, T. and H. Alvestrand,
<i>"Guidelines for Writing an IANA Considerations Section in RFCs"</i>,
<a href="./bcp26">BCP 26</a>,
<a href="./rfc5226">RFC 5226</a>,
May 2008.
	</dd>

	<dt>[RFC5234]</dt>
	<dd>
Crocker, D. and P. Overell,
<i>"Augmented BNF for Syntax Specifications: ABNF"</i>,
STD 68,
<a href="./rfc5234">RFC 5234</a>,
January 2008.
	</dd>

	<dt>[RFC5246]</dt>
	<dd>
Dierks, T. and E. Rescorla,
<i>"The Transport Layer Security (TLS) Protocol Version 1.2"</i>,
<a href="./rfc5246">RFC 5246</a>,
August 2008.
	</dd>

	<dt>[RFC6066]</dt>
	<dd>
Eastlake, D.,
<i>"Transport Layer Security (TLS) Extensions: Extension Definitions"</i>,
<a href="./rfc6066">RFC 6066</a>,
January 2011.
	</dd>

	<dt>[RFC6454]</dt>
	<dd>
Barth, A.,
<i>"The Web Origin Concept"</i>,
<a href="./rfc6454">RFC 6454</a>,
December 2011.
	</dd>
</dl>

	</section>
	<section id="section-14.2">

<h3 title="Informative References">14.2. 文献（参考）</h3>

<dl>

	<dt>[RFC4122]</dt>
	<dd>
Leach, P., Mealling, M., and R. Salz,
<i>"A Universally Unique IDentifier (UUID) URN Namespace"</i>,
<a href="./rfc4122">RFC 4122</a>,
July 2005.
	</dd>

	<dt>[RFC4270]</dt>
	<dd>
Hoffman, P. and B. Schneier,
<i>"Attacks on Cryptographic Hashes in Internet Protocols"</i>,
<a href="./rfc4270">RFC 4270</a>,
November 2005.
	</dd>

	<dt>[RFC5321]</dt>
	<dd>
Klensin, J.,
<i>"Simple Mail Transfer Protocol"</i>,
<a href="./rfc5321">RFC 5321</a>,
October 2008.
	</dd>

	<dt>[RFC6202]</dt>
	<dd>
Loreto, S., Saint-Andre, P., Salsano, S., and G. Wilkins,
<i>"Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP"</i>,
<a href="./rfc6202">RFC 6202</a>,
April 2011.
	</dd>

	<dt>[RFC6265]</dt>
	<dd>
Barth, A.,
<i>"HTTP State Management Mechanism"</i>,
<a href="./rfc6265">RFC 6265</a>,
April 2011.
	</dd>

	<dt>[TALKING]</dt>
	<dd>
Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C.
Jackson,
<i>"Talking to Yourself for Fun and Profit"</i>,
2010,
&lt;<a href="http://w2spconf.com/2011/papers/websocket.pdf">http://w2spconf.com/2011/papers/websocket.pdf</a>&gt;.
	</dd>

	<dt>[W3C.REC-wsc-ui-20100812]</dt>
	<dd>
Roessler, T. and A. Saldhana,
<i>"Web Security Context: User Interface Guidelines"</i>,
World Wide Web Consortium
Recommendation REC-wsc-ui-20100812, August 2010,
&lt;<a href="http://www.w3.org/TR/2010/REC-wsc-ui-20100812/">http://www.w3.org/TR/2010/REC-wsc-ui-20100812/</a>&gt;.

<br />
Latest version available at
&lt;<a href="http://www.w3.org/TR/wsc-ui/">http://www.w3.org/TR/wsc-ui/</a>&gt;.
	</dd>

	<dt>[WSAPI]</dt>
	<dd>
Hickson, I.,
<i>"The WebSocket API"</i>,
W3C Working Draft WD-
websockets-20110929,
September 2011,
&lt;<a href="http://www.w3.org/TR/2011/WD-websockets-20110929/">http://www.w3.org/TR/2011/WD-websockets-20110929/</a>&gt;.

<br />
Latest version available at
&lt;<a href="http://www.w3.org/TR/websockets/">http://www.w3.org/TR/websockets/</a>&gt;.
	</dd>

	<dt>[XMLHttpRequest]</dt>
	<dd>
van Kesteren, A., Ed.,
<i>"XMLHttpRequest"</i>,
W3C Candidate Recommendation CR-XMLHttpRequest-20100803,
August 2010,
&lt;<a href="http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/">http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/</a>&gt;.

<br />
Latest version available at
&lt;<a href="http://www.w3.org/TR/XMLHttpRequest/">http://www.w3.org/TR/XMLHttpRequest/</a>&gt;.
	</dd>

</dl>

	</section>
</section>

</main>

<footer>
<h4 title="Authors’ Addresses">著作者アドレス</h4>

<dl >
	<dt>Ian Fette, Google, Inc.</dt>
	<dd>
EMail: ifette+ietf@google.com<br />
URI:   http://www.ianfette.com/
</dd>

	<dt>Alexey Melnikov, Isode Ltd.</dt>
	<dd>
5 Castle Business Village,
36 Station Road,
Hampton, Middlesex  TW12 2BX,
UK,<br />
EMail: Alexey.Melnikov@isode.com
</dd>
</dl>
</footer>

</body></html>

<!-- 

インスタントメッセンジャ:instant messaging
	ウェブブラウザ
	セキュリティ­モデル
正誤表:errata
オプトイン:opted-in
キャリア:carrier
大域的一意識別子:Globally Unique Identifier
ケース:cases
ゲームアプリケーション:gaming applications
コード:code
コミュニティ:community
コメント:comment
コンピュータ:computer
カンマ:comma
システム:system
シャットダウン:shutdown
スペース:space
セレクタ:selector
タブウィンドウ:tab window
デバッグ:debug
ネット:net
パート:part
バグ:bug
パフォーマンス:performance
フォーム:form
ブラウザ:browser
リアルタイム:real time
ログ:log

サービス供与:serve
そのためには:accomplish
とりわけ:especially
役務:serve
用をなす:serve
	機能する:serve


リソースを浪費:resource-hogging
圧縮-:compress
圧縮:compression
取り扱い:handling
取り扱う:handle
宛先:destination
安全:safe
安全性:safety
暗号:cipher
暗号論的に:cryptographic
暗黙の:implied
位置付け:Status
依拠-:rely
依然:still
依存-:depend
意向:willing
意図:intent
意味:meaning
意味論:semantic
異なる:different
異常に:abnormally
移行-:proceed
維持管理:maintain
違反-:violate
違反:violation
一つ上の:top of
一意的:unique
一時停止:pausing
一時的:transient
一致:agree
一般に:generally
一般的:general
一般的な手口:general form
一部:part
部:part
一部分:part
一連の:set
隠す:hide
運ぶ:carry
運用:operation
波及:influence
永続的:permanent
延長:extended
汚染:poisoning
応答可能:responsive
恩恵を受けている:benefit
下位節:sub sections
可能性:potential
果たす:fulfill
課す:impose
過度の:unusual
解し得:understand
取り組む:attempt to address
解決:resolve
解決策:solution
解散:close
解釈:interpret
解釈可能:can interpret
解読可能:decipherable
回避:avoid
回復:resumption
開始:begin
起動-:initiate
開発-:develop
開発者:developer
概して:typically
概観:overview
概念:concept
概念的:conceptual
拡張可能:extensible
拡張性:extensibility
拡張名:extension name
確かめられる:be sure
確定:Establish
確認:confirm
確保:ensure
割り当て:assignment
割合:percentage
完遂:finish
完成:finished
完全:safe
完了-:complete
完了:completion
完了後:completion
感染源:susceptible
表記規約:convension
環境:environment
	管理:controller
	管理:manage
緩和:relaxed
間隔:interval
関係:relationship
関係なく:regardless
関与:participation
関連:relate
関連情報:relate information
含-:contain
危うく:compromising
基準:criteria
基本の:base



基本的:basic
寄与:contribution
既存の:existing
既知の:known
機器:device
機能:capability
機能:function
帰結:consequence
帰着:all the way
気付かずに:convinced
規定:normative
規定:prescribe
規範的な:prescriptive
規約:convention
記憶域の枯渇:exhaust memory
記述:description
記録:note
記録:track
生じる:arise
偽装:fake
偽造:forge
技術:technology
技法:technique
議論:discussions
求める:ask
巨大:big
拒絶:refuse
拒否:reject
許容:allow
供する:supply
競合:competing
共存:coexist
共通の:common
共有-:share
境界:boundary
強いられる:forced
強度:strength
脅威:threat
近似:closely match
区切り文字:separator character
区別:distinction
具体的:specifically
空白:whitespace
繰り返す:repeat
形式:form
形式的:formally
形成:form
形成済:formed
携帯機:handset
携帯電話機上:mobile handsets 上
経験:experience
晒され
経由:via
継続的:persistently
軽減:reduce
欠いている:lack
欠いている:missing
決定-:decide
決定:determine
結び付け:associate
結果:result
検査:check
検出:detect
検出:discover
検出:find
権限:authority
権利:rights
見なされる:considered
見なす:assume
見なす:consider
見込まれている:intended
元の:original
原則:principle
原理:principle
厳格:strict
厳密な:exactly
源:source
現在:current
現時点:currently
現存:existing
現存の:existing
言語:language
限定:limit
限定:limit
鼓動:heartbeat
互換性:compatible
後継文書:replacement
後続:subsequent
後続の:trailing
後方互換:backward compatible
後方互換性:backward-compatible
後方互換性を保たない:backward-incompatible
語句:term
誤った:wrong
誤解釈:misinterpret
誤誘導:mislead
交換:exchange
公開:public
実質的:effectively
効率性:efficiency
巧妙:carefully
広げる:extend
広告:advertise
広告配信:ad-serving
広範:widely
恒久的:permanent
拘束:tied
更新:update
構築-:construct
考えられていない:not deemed
考案者:originator
考慮:consider
考慮点:considerations
行:line
行い得る限り:as soon as practical
高次:high-level
同意-／同意を示す:agree
合意:consensus
合間:middle
合併:coalesce
結合-:combine
合法:legal
告知:advertisement
告知機能:advertisement capability
国際化:Internationalized
困難:difficult
混同:confuse
左端:leftmost
査読:review
再発明:reinventing
再利用:reuse
最後の:final
最高位:most preferable
最終成果:end result
最終的な結果:end result
最初の:first
最初の段階:first place
最小の:minimal
最小限に:minimal
最上位:most significant
最新に／直前の:latest
最大セグメント寿命:maximum segment lifetimes
採択:elect
細工:craft
作者:author
作者定義:author-defined
作成:create
参照:refer
参照:reference
参照文献:references
算出:compute
暫定:Interim
仕掛け:try
仕事:work
仕組み:mechanism
仕方:manner
仕様:specification
仕様文書:Specification document(s)
使用:employ
始まる:begin
	指示-:indicate
	指示:indication
	指示を受ける:instructed
指針:guidance
手引き:guidance
指定:specify
指定を受け:designate
指定域:designated locations
支援:help
私的:private
私的利用:private 利用
試み:attempt
試験:test
試行:try
事前の取り決め:prior agreements
事例:cases
自身:itself
自体:itself
自動設定:autoconfiguration
自由:free
失われた:lost
実行／稼働:run
実行:execute
実際:actual 
実証する実験が実施:an experiment was conducted to demonstrate
実装-:implement
実装ごとに固有の:implementation-specific
実用的:practical
写像:mapping
主体:entity
主体:party
主要な:main
取得:obtain
手を加える:modify
手続き:procedure
手短か:In short,
種類:kind
受理:acceptance
受領:receipt
終端:terminal
終端記号（ABNF）:terminals
十分:sufficient
有意:significant
出現:appear
出力チャンネル:output channel
準備:prepare
初期:initial
初期時:initially
初期値:initial value
除外:exclude
除去:remove
奨励:encourage
将来:future
将来仕様:future specification
将来利用:future use
小:small
小文字:lowercase
小文字化:lowercased に
承認:endorse
消失:going away
省略:omit
衝突:collision
衝突耐性:collision resistance
詳細:detail
上流:upstream
情報:information
情報片:pieces of information
情報量:entropy
状況:condition
信号:signal
	信号を送る
信号通信:signaling
信任を与える:responsible
信用:trust
信頼:trust
信頼し得る:reliable
信頼性:reliability
慎重:careful
新しく:recently
新たな:new
新規:fresh
申し入れる:offering
真似:similar to
診断:diagnosing
進める:proceed
人々:people
図:figure
図式:diagrams
推奨-:recommend
推進:move
数え上げる:count
数量:quantities
制限:limit
制御:control
制約:restrict
制約下:constraints
制約条件:restriction
成功した:successful
成功率:success rates
整合:consistent
きちんと:orderly
正確:exact
正しく:correctly
不正な:incorrect
不正な形式の:malformed
不正に:incorrectly
正確には:really just
正規化:normalization
生成-:generate
生成元:origin
精巧:elaborate
請求が無い:unsolicited
脆弱性:vulnerable
切断:disconnect
接触-:contact
接続維持:keepalive
接尾辞:suffix
設けられる:made
設計:design
設計理念:design philosophy
設定:configure
節:section
先頭:leading
先頭行:leading line
占有:monopolize
潜在的:potential
選ばれ:chosen
選択:select
選定:selecting
遷移:navigate away
前提:assumption
漸増:increasingly
全部的:full
満杯:full
素通り:skip
素片:fragment
組:pair
双路通信:two-way communication
喪失:loss
	想定／意図／企図:intend
挿入-:insert
挿入:interject
挿入(fragment):inject

操作:operation
運用:operation
相互運用:interoperate
相互運用性:interoperability
相場表示機:stock tickers
総:total
草案:draft
送信側:sender send 
遭遇:encounter
即時:immediate
続行:continue
介在:presence
存在下:presence
有無:presence
在る／示す／供-／:present
無い:not present
多量:significant
妥当性〜検証:validated
対応-:correspond
対応:corresponding
対応付け:mapping
対照的:oppose
対話的:interactive
耐性:resistance
帯域内:in-band
待ち時間:latency
代替:alternative
代表的:typical
大きく:greatly
大きく:significantly
大小は無視される:case-insensitive
第二原像攻撃:second pre-image attack
達成:achieve
単位:unit
単純:simple
単純化-:simplify
単独の:single
単方向:unidirectional
段落:paragraph
値:value
置かれて:place
置換-:replace
中身:contents
注意深く:careful
慎重:careful
注記:note
超過:exceeding
長い:long
長大:long
直近:most recently
直接の:direct
直接的:directly
追加-:add
追加:addition
追随:follow
追跡:track
通じている:aware of 
伝え:inform
通知:notification
停止:stop
定義-:define
定義:definition
定義済:predefined
公示-:post
提供-:provide
提示-:set out
提示-:suggest
適化:better
適合-:conform
適合性:conformance
適時:timely manner
適切な:appropriate
相応しい:suitable
適度:reasonable
適用-:apply
適用され得る:applicable
適用可能:applicable
典型的:typical
展開:scenario
電話機:handset
渡す:pass
当然:Naturally
等価:equivalent
統制:control
頭部:leading
動作-:act
動作:action
動的:dynamic
同じ:same
同一:identical
同一視:considered to match
同時の:simultaneous
同時刻:simultaneously
同時編集可能:simultaneous editing
導出-:derive
導入-:introduce
導入:introduction
特権:privilege
性質:nature
特色機能:feature
特定の:specific
独立:independent
読み易く:readability
読み取り:read
内部:inside
内容:content
日付:date
任意:arbitrarily
任意:arbitrary
任意選択:optional
認可:grant
破棄:discard
背景調査:background research
背後:behind
送達-:deliver
配置:setups
配備:deploy
配分:allocate
発行:publication
発展:expansion
伴われる:imply
判断:believe
判断材料:part of a determination
判別:identified
反映:exposing
供-:expose
露出:exposing
汎用:generic
範囲:range
頒布:deployed
比較:comparing
比較的単純:relatively simple
非:non
非互換:incompatible
非準拠:nonconformant
非負:unsigned
尾部:trailing
必須:Mandatory
必須の:required
	特定の／の特性:particular
	必ずしも／わけではない／とは限らない:necessarily
	必要／要する:need
標準:standard
標準的:standard
標的:target
表す:denote
表記:express
表現:represent
評価:review
頻度:rate
敏感な:sensitive
不一致:conflict
不可能:not possible
不在:absence
不断に:tirelessly
不適切:improper
不必要:unnecessarily
付加:append
符号位置:code point
舞台裏:behind the scene 
部分:part
部分:portion
部分的:partial
復帰:recover
復元後:unescaping
複雑さ:complexity
複数:multiple
複数行:multiple lines
覆す:break
分割:split
分離:separate from
文字並び:characters
文書:document
文書化:documented
文章:text
文法:grammar
文脈下:context 下
併用:used with
則って／則り:in accordance with
平均情報量:entropy
並び:sequence
別名:another name
変化:change
変換:transform
変換:translation
変更:change
	変更管理:Change controller
変数:variable
編集者:editor
編集上:editorial
返す:send back
保持:hold
保証:guarantee
補完:complement
包括的:exhaustively
報告:report
方向:direction
方法:way
訪問:visit
防御策:defense adopted
防止:prevent
本質的:essential
末端:end
満杯:full
未知の:unknown
未定義:undefined
無視:ignore
無保証:without warranty
名:name
名前:name
命名:naming
命令的言い回し:phrased in the imperative
明確化:clarifications
明示的:explicit
目的:purpose
目標:goal
問題:problem
問題に関わる:relevant
役務:serve
優先される:authoritative
有効:effect
有用:useful
誘引:induce
予期-:expect
予期:expectation
予期しない:unexpected
予想される:anticipate
予測:predict
予測可能:predictable
予測不能:unpredictable
予測不能性:unpredictability
予防:prefix
容易に可用:readily available
用語:term
各種用語:terminology
要求:require
要件:requirements

要約:Abstract
抑制:reduce
軽減:reduce
落とす:drop 
乱数生成器:random number generator.
濫用:abuse
利点:benefit
可用:available
立証:prove
両方向:both directions
良好な:good
量:amount
例:example
歴史的:historical
連結-:concatenate
連絡先:contact


論法:logic
論理:logic
論理的:logical
話す:speak


	通常:normal
	通常の:regular
	以下: 18
	以外: 4
	以降: 2
	以上: 10
	以前: 1
	相手: 1
	相手側: 2
	側:party

	構成:compose
	構成する:constitute
	希望:preference
	希望／望ましい:prefer
	希望／望む:wish
	構成する／よりなる:comprise
	述べる:describe
	準じ:compliant
	復唱／返される／返す:echo
	要望／必要なら:desired
	論／論じる:discuss

	application の特性:particular application
	ふるまう:act
	もっぱら:solely
	やりとり:interaction
	やりとり:talking
	位置する:
	一環:
	一個:
	一組:
	一定:
	一度限り:
	一部機能: 1
	一覧:list
	引数:with
	引用:
	下記: 1
	可能: 9
	可能性: 7
	各種: 1
	各要素: 1
	環境下: 2
	希望順: 2
	期間: 1
	個以上: 6
	個数: 1
	個別: 1
	枯渇: 1
	今後: 1
	今度: 1
	採用:uses
	作用: 2
	参考: 14
	散在:around
	算出方法: 1
	仕様内:
	仕立: 1
	事実: 1
	時の経過:time
	時間: 2
	時間内: 2
	時刻:time
	時点: 9
	次項: 1
	次第: 1
	実行文脈:context
	集合: 2
	上述: 2
	場合: 135
	数
	制御下: 3
	制御環境下: 1
	成功後:successful
	成立: 2
	先頭部: 1
	先立: 1
	専用: 3
	前記: 1
	前後: 1
	前述: 1
	前段落: 1
	全体: 7
	組織: 1
	双方: 2
	層上: 1
	相当: 1
	相方: 1
	総数: 2
	総覧: 2
	側:-side
	側分担: 1
	則って／則り:accordance 
	多少: 1
	多数: 5
	対象: 14
	待ち:pending-
	大部分:majority
	断片化の様態:fragmentation
	働く／仕事:work
	同時: 10
	同順: 1
	同様: 5
	導く:lead
	念頭: 1
番号:number
	番目: 6
	必要性:necessarily
	不可: 1
	複数個: 1
	複数存在: 1
	分担: 1
	分類: 1
	文献: 4
	併用下: 1
	別個: 2
	変換後:
	変数名: 1
	無意味: 1
	唯一: 2
	用途: 8
	用法: 1
	要素: 4
	利用: 113
	利用中: 3
	利用法: 1
	理由: 9
	両者: 5
	両方: 2
	連結結果: 1

ある団体:Example Corporation
ごく普通に:quite likely

べき乗打切り待機法:truncated binary exponential backoff
マスクを解除:unmask
より少数の:fewer

	:-based 
	~presentしない:absent 
	capabilities~1
	capable~4
	case~20
	choose:選
	chooses~1
	consists~5
	denial-of-service attack DoS~attack
	further~20
	further~information 詳細
	high~3
	higher~5
	instead~5
	look
	mean~1
	means~4
	necessary~5
	non~normative 参考／~normativeでない
	nonconformant~1
	notify
	offer
	parts~5
	行う:perform
	prefer:望
	ready~to~use 利用できる
	reasonably~1
	return 返
	semantic meaning
	subsequently
	unexpectedly~1
	ゆえに:Ergo
	以上:or higher
	完全
	強:strong
	具体的に:specifically
	人から読める:human readable
	単純に:simply
	特に:specifically
	頒布／広範の／配備（訳さない）:deployed
	必要とする:expect
〜（TLS etc.） 〜を通して:over
〜に基づく:-base 
（それ）以上の:further


-->
<!-- 

([ァ-ヴー]) (?=[ァ-ヴー])
([一-龠]) (?=[一-龠])

-->


<!--
接続­切断
登録­要件
断片­化
文書­化­
高­負荷
素片­識別子
拡張­識別子
非互換­拡張
多重化­拡張
妥当­性
負荷­分散装置
文字­符号化
セキュア­フラグ
成分­内
仕様­文書
初期­時
初期­値
制御­環境下
タブ­ウィンドウ


ウェブ­サイト:web site
リモート­サーバ:remote server
プロキシ­サーバ:proxy server


ハンドシェイク­データ: data
フレーム­ペイロード­データ: data
双路­通信:two-way communication
双方向­通信: communication
発信­接続
着信­接続
同時­接続
直接­接続
プロトコル­レベル
アプリケーション­レベル
プロトコル­エラー:protocol error
	フレーム­種別:frame type
フレームヘッダ:frame header
フレーム­ペイロード:frame payload
フレーム­サイズ:frame size
メッセージ­サイズ
受理­可能
生成元­情報
生成元­文字列
情報­片
セキュリティ­バグ
-->