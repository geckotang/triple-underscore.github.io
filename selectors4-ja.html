<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Selectors Level 4 （日本語訳）</title>
<meta name="keywords" content="選択子,セレクタ,selector,疑似,クラス,スタイルシート,CSS,仕様,W3C">

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

COMMON_DATA.page_state_key = '___CSS';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://drafts.csswg.org/selectors/',
		spec_status: 'ED',
		fill_text_link: '#_versions > dd, #references dd',
		main: 'MAIN',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
		alt_refs: 'references'
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked 160322 spec

	return options;
}


function expand(mapping1){
	var link_map = this.link_map;
	var class_map = {
		ps: 'pseudo',
		pe: 'pseudo-element',
		prod: 'production',
		v: 'value',
		t: 'type',
		p: 'property',
		e: 'element',
		a: 'attr',
		css: 'css',
		S: 'css',
		cp: 'code-point',
	};

	var tag_map = {
		ps: 'code',
		pe: 'code',
		prod: 'var',
		v: 'code',
		t: 'var',
		p: 'code',
		e: 'code',
		a: 'code',
		css: 'code',
		S: 'samp',
		s: 'samp',
		I: 'code',
		c: 'code',
		cp: 'span',
		i: 'i',
		V: 'var',
		NOTE: 'span'
	}


	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/◎[^<◎]*|【.*?】|❝.|%[\w~一-鿆]+|`(.+?)([$@§!\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	// 目次構築
	Util.rebuildToc('MAIN0', '_toc_list0');

	function create_html(match, key, indicator, klass){
if(!indicator) {
	switch(match.charAt(0)){
	case '❝':
		return (
' "<code class="char">' + match.charAt(1) + '<\/code>"' +
'<span class="code-point"> (U+' + 
( ('000' + match.charCodeAt(1).toString(16).toUpperCase()).slice(-4) ) +
')</span>'
		);
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '◎':
	default:
		return '<span lang="en">' + match.slice(1) + '<\/span>';
	}
}


var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'ps': // pseudo-class
	href = '#' + key.match(/[^(]+/)[0] + '-pseudo';
	text = ':' + key;
	break;
case 'pe': // pseudo-class
	text = '::' + key;
	break;
case 'PS': // pseudo-class section
	href = '#the-' + key.match(/[^(]+/)[0] + '-pseudo';
	text = '<code class="pseudo">:' + key + '</code> 疑似類';
	break;
case 'prod': // production
	href = '#prod-' + key;
	break;
case 't': // typedef
	href = '#typedef-' + key;
	text = '&lt;' + key + '&gt;';
	break;
case 'cp': //
	text = '(U+' + key + ')';
	break;
default:
}


if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	if(indicator === '§'){
		href = link_map[ key + '§'];
	} else {
		href = link_map[klass ? (klass + '.' + key) : key] || href;
	}
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '§':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}


}

</script>


<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
subject-indicator:
AnB-notation:

drop-pseudo:selectordef-drop-function
drop-pseudo0:selectordef-drop

nth-last-of-type-pseudo:nth-last-of-type
not-pseudo:negation-pseudo
pseudo-element_syntax:pseudo-element%20syntax
user-invalid-pseudo:user-error-pseudo
	typedef-selector-list:typedef-selector


</script>
<!-- 


scope_relative_selector_list:
scope_relative_selector:
complex_selector:
combinator0:
	`combinator^prod
compound_selector_list:
compound_selector:
simple_selector_list:
simple_selector:
type_selector:

-->

<!--% 置換データ -->
<script type="text/plain" id="words_table1">

AnB:<code class="css"><var>A</var>n+<var>B</var></code>
AnBth:<a href="#AnB-notation">A×<var>n</var> + B 番目（ <var>n</var> ≥ 0 ）</a>

note21:<a href="#_note21" class="trans-note">【†1】</a>
E:<var>E</var>
F:<var>F</var>
S:<var>S</var>
n:<var>n</var>

scope_ps:<code class="pseudo">:scope</code> 
drop0:<a href="#drop-pseudo0"><code class="pseudo">:drop</code></a>

SCOPING:https://drafts.csswg.org/css-scoping-1/

</script>
<!-- 結合子
cb-descendant:<code class="css">&gt;&gt;</code>
cb-column:<code class="css">||</code>
cb-child:<code class="css">&gt;</code>
cb-adjacent:<code class="css">+</code>
cb-descendant:selectordef-descendant
cb-column:selectordef-column
cb-child:selectordef-child
cb-adjacent:selectordef-adjacent

-->
<!--% 語彙置換データ
英数_／漢字
-->

<script type="text/plain" id="words_table">

失敗:failure:~
成功:success:~

	●一般語
形成-:form:~
tag:::タグ
下位tag:subtag::下位タグ
pattern:::パタン
演算子:operator:~
data:::データ
level:::レベル
module:::モジュール
token:::トークン
	トークン化器:tokenizer
text:::テキスト
markup:::マークアップ
code:::コード
prop:property::プロパティ

文字列:string:~
部分文字列:substring:~
空文字列:empty string:~
空:empty:~
関数:function:~
接尾辞:suffix:~
接頭辞:prefix:~
引数:argument:~
名前:name:~
名:name:~
命名-:name:~
値:value:~
表現-:represent:~
表現:representation:表現
文字:character:~
大小:case:~
文字大小:character case:文字 case:~
文字大小無視:case-insensitive:~
	文字大小の区別:case sensitivity
文脈:context:~
文脈上の:contextual:~

error:::エラー
access:::アクセス
method:::メソッド

項目:item:~

生成規則:production:~
構文解析-:parse:~::パース
文法:grammar:~
文法上:grammatical:~
文法記号:grammar term:~
状態:state:~

成分:component:~

	●DOM
instance:::インスタンス
list:::リスト
node:::ノード
call:
shadow:
	host:
識別子:identifier:~
素片:fragment:~
文書片:document fragment:~
文書順:document order:~
根:root::~:ルート
木:tree::~:ツリー
部分木:subtree::~:サブツリー
	文書~木
	要素~木
文書:document:~
	文書~言語
木構造:tree structure:tree 構造:~:ツリー構造
	木~構造たる部分:tree-ness
構造:structure:~
属性:attribute:~
属性値:attribute value:~
属性名:attribute name:~
属性存在:attribute presence:~
同胞:siblings:~
同胞群:sibling 群:~
同胞要素:element siblings:~
要素:element:~
親:parent:~
子:child:~
要素名:element name:~
要素型:element type:~
子孫:descendant:~
先祖:ancestor:~
内容:content:~
	空:empty:~
	emptiness:空かどうか
展開名:expanded element name:~
fragment:
実体参照:entity reference:~
処理命令:processing instruction:~
文書型宣言:doctype declaration:~

	●文書言語
mode:::モード
object:::オブジェクト
符号位置:code point:~
動的:dynamic:~


既定:default:~::デフォルト
既定の:default:~::デフォルト
既定値:default value:~::デフォルト値
hook:::フック

意味論:semantics:~::セマンティクス
構文:syntax:~::シンタックス
構文論的:syntactical:~
構文的:syntactic:~
構文上は:syntactic には:~
小構文:microsyntax:~
host:::ホスト
model:::モデル
support:::サポート
UI:user interface:UI::ユーザインタフェース

名前空間:namespace:~
	no名前空間:どの名前空間にも属さない
接頭辞:prefix:~::プレフィックス
区切子:separator:~
	::セパレータ
有修飾名:qualified name:~
修飾名:qualified name:~
局所名:local name:~::ローカル名
宣言-:declare:~
宣言法:declaring:~
宣言:declaration:~
未宣言:undeclared:~
	オプション:optional:~

subset:::サブセット
部分集合:subset:~

外部:external:~
内部:internal:~
集合:set:~
	空集合:nothing

processor:::プロセッサ
過去互換:quirks:~
事例:case:~

	●
表記体系:writing system:~
標準中国語:Chinese:~
方言:dialect:~
繁体字:traditional Chinese:~

	●仕様（動詞
推奨-:recommend:~
	RECOMMENDing
非推奨に:deprecate:~
要求-:require:~
必須:required:~
実装:implementation:~
実装-:implement:~
実装者:implementor:~
適合-:conform:~
非適合:non-conforming:~
適合性:conformance:~
除去-:remove:~
	移動-:move:~
	欠如-:lack:~
取扱われ:handle され:取り扱われ
取扱う:handle する:取り扱う
取扱い:handling:取り扱い
適応-:accommodate:~
見做され:assume され:~
意図-:intend:~
意図:intent:~
省略-:omit:~
省略:omitting:~
省略可能:optional:~
省略可:optional:~
判別-:distinguish:~
受容-:accept:~
許容-:allow:~
創出-:create:~
影響-:affect:~
適用-:apply:~
	可能にする:permit
定義-:define:~
定義:definition:~
認識-:recognize:~
認知-:recognize:~
	unrecognized
相違:difference:~
提供-:provide:~
提供0-:offer:提供
依存-:depend:~
独立:independent:~
独立して:independent に:~
指定-:specify:~
拡張-:extend:~
拡張:extension:~
制約-:restrict:~
制約:restriction:~
拘束:constraints:~
拘束-:constrain:~
考慮-:consider:~
考慮点:considerations:~
決定-:determine:~
指示-:indicate:~
上書き:override:~
除外-:exclude:~
配慮:care:~
違反-:violate:~
保証-:guarantee:~
濫用-:abuse:~
記述-:describe:~
	述べる
記述:description:~
試みる:attempt する:~
分類-:classify:~
考査:review:~
解釈-:interpret:~
解釈:interpretation:~
制限:limit:~
	限定されない:not limited
制限ion:limitation:制限
設計-:design:~
導入-:introduce:~
正しく:correct に:~
正した:correct した:~
挙動:behavior:ふるまい
	はっきりさせる:clarify:~
働く:work する:~

	●仕様
明示的:explicit:~
暗黙的:implicit:~
	暗黙／言外:implied
任意選択:optional:~
仕様:spec:~
	specification
作者:author:~
作者定義の:author-defined:~
UA:user agent:UA::ユーザエージェント
利用者:user:~::ユーザ
互換性:compatibility:~
将来:future:~
将来の:future:~
後継版:successor:~
app:application::アプリ
要件:requirements:~
正式:normative:~
参考:non-normative:~
	参考:informative:~
勧告:recommendation:~

特色機能:feature:~
	特色機能~一式:featureset
意味論的:semantic:~
能:ability:機能
	関心:interest:~

側面:aspect:~
手頃:reasonable:~
各種用語:terminology:~
効率的:efficient:~
	一緒くたにconflated
既存の:existing:~
能力:capabilities:~
注釈文:prose:~
	詳細:details:~
特有:-specific:ごとに固有
特有の:specific な:~
特定の:specific:~
範囲:range:~
情報:information:~
知識:knowledge:~
目的:purpose:~
概念:concept:~
	概念:notion:~
概念的:conceptual:~
	基本的:basic:~
抽象的:abstract:~
抽象化:abstraction:~
判定基準:criteria:~
特定0の:particular:ある特定の
仕組み:mechanism:~
適切:appropriate:~
関係性:relationship:~
直接的:direct:~
状況:situation:~
実践:practice:~
不正:incorrect:~
因子:factor:~
効果:effect:~
意識的:significant:~
	意識的にやりとり:significantly interact
強力:powerful:~
有用:useful:~
汎用的:generic:~
多彩:rich:~
技術:technology:~
旧来の:legacy:~
理由:reason:~
実施:practice:~
不便:awkward:~
不可能:impossible:~
同意:consent:~
相互作用:interaction:~
概観:overview:~
制御:control:~
無用な:useless:~
特別:special:~
機能性:functionality:~
重要:important:~
	~~重要:-critical
適正:proper:~
未知:unknown:~
未知の:unknown:~
手順:procedure:手続き
注記:Note:~
環境:environment:~
変更点:changes:~
仕方:way:~
組込みの:built-in:組み込みの
明瞭:clear:~
首:primary:主
第一:primary:~
自前の:own:~

	●CSS
style:::スタイル
stylesheet:::スタイルシート
	style:style付けする
layout:::レイアウト
規則:rule:~
媒体:media::~:メディア
呈示-:present:~
呈示様式:presentation:~
無視:ignore:~
断片:fragment::~
box:::ボックス
screen:::スクリーン
発話:speech::~:スピーチ
具現化-:render:~::レンダー
具現化:rendering:~::レンダリング
具現化法:rendering:~::レンダリング

	音声化:speech rendering:~


~render:::レンダー
描画:render:~
公開-:expose:~

	●Selectors
profile:::プロファイル
動的:dynamic::~
静的:static::~
完全:complete::~

詳細度:specificity::~
	より詳細度が高い:more specific
照合処理:matching::照合
照合:match::~
部分照合:substring matching::~
	:マッチング
	matching
	合致処理／合致検出／照合
合致-:match::~
	:マッチ
	合致対象:match::~
評価-:evaluate:~
評価:evaluation:~
評価法:evaluating:~
特能:feature:特色::フィーチャ
無特能:featureless:無特色::フィーチャレス

無効:invalid::~
	無効にする:invalidate
妥当性:validity::~
	妥当性を検証しない:non-validating
妥当:valid::~
	妥当なものとして:validly
有効:valid::~

選択対象:subjects::~
group:::グループ

選択子:selector::~:セレクタ
選択-:select:~
選択ion:selection:選択
選択済みの:select 済みの:~
選択済み:selected:~
選択処理:selection:~

class:
相対的:relative:~

全称:universal::~
単体:simple::~
型:type::~
相対:relative::~
合体:compound::~
複体:complex::~

	合体~選択子
	複体~選択子
	全称~選択子
	子孫~選択子
	子~選択子
	型~選択子
	単体~選択子
	~class選択子
	相対~選択子
	属性~選択子
	ID 選択子

基本的な:elemental:~
		basic

格子構造:grid-structural::格子構造 :グリッド構造
所属関係:relationship:~


結合子:combinator::~
	~column結合子
	子孫~結合子
	子~結合子:child combinator::~
次同胞:next-sibling::次-同胞 
後続同胞:following-sibling::後続-同胞 
広義同胞:inclusive sibling::~

	次同胞~結合子
	後続同胞~結合子

疑似要素:pseudo-element::~
出自の:originating:~
	出自の要素

視野:scope::視野:スコープ
視野付き:scoped::視野付き:スコープ付き
視野根:scoping root::~:スコーピングルート
視野要素:scoping element:scoping 要素:視野の根要素:スコーピング要素

絞込む:filter する::絞り込む
絞込まれ:filter され::絞り込まれ
	絞込んだ:filter した:絞り込んだ
	絞り込み:filtered／filtering
	拡張絞り込み:extended filtering 1

	scoping-root:scoping root
	scoping-element:scoping 要素
virtual:
	仮想？
絶対化:absolutize::~
絶対的:absolute::~
起点要素:reference element:reference 要素:~
起点:reference point:~

自然言語:language:~
	自然言語に関する:linguistic
言語:language:~
言語範囲:language range:~
wildcard:::ワイルドカード
subcode:

記法:notation:~
関数形:functional::~
省略形:shorthand::~


	●Selectors 疑似クラス
	疑似:pseudo
疑似類:pseudo-class::疑似クラス
方向性:directionality::書字方向性
	方向性疑似類:directionality pseudo-class:方向性疑似類

関数形:functional::~
構造上の:structural:~
関係上の:relational:~::リレーショナル
	木~構造上の
	否定~疑似類:negation pseudo-class::否定 疑似クラス
	範囲~疑似類:range pseudo-class::範囲 疑似クラス
	選択済み疑似類:selected-option pseudo-class::選択済み疑似クラス
	mutability 可変性？内容可変？変更可否？
変更可否:mutability::~
	利用者~動作:user action:~::ユーザアクション
	利用者~対話:user-interaction::~:ユーザインタラクション

否定:negation::~
論理和:matches-any::~
型指定:typed::~
仮入力例示:placeholder-shown::~
仮入力:placeholder::~

既定option:default option:既定の option:既定の選択肢:デフォルトオプション
	選択肢:choices／option／

不定値:indeterminate-value::~
必須随意:optionality::必須／随意

子付番:child-indexed::~
付番:index::~
	numbering:番号付け
	indexes
	indexed
周期:step:~
	差分:offset:差分

格子:grid:~::グリッド
table:::テーブル
cell:::セル
column:::カラム
縦筋:column:列
横筋:row:行
初行:first line::最初の行
初字:first letter::最初の字

時系列再生:time-dimensional canvas:~
時間軸:timeline:~
時系列順:time-based order:~
時系列:time-dimensional:~
現在要素:current-element:~
未来要素:future-element:~
過去要素:past-element:~

再生位置:playback position:~
現在表示中:currently-displayed:~

再生-:play:~
	再生-中:playing:~
一時停止-:pause:~
停止-:stop:~
再開-:resume:~
事由:reason:~
buffer:::バッファ
~~質:quality

一般化:generalized:~
一般:general:~
汎的:generic:~

	●network
hyperlink:::ハイパーリンク
source:::ソース
link:::リンク
anchor:::アンカー

履歴:history:~
局所:local:~
	target:リンク先
生成元:origin:~::オリジン
path:::パス
	source_anchor:source anchor:リンク元
	所属:membership:~
	ID-typed:ID型にされている

資源:resource::リソース
所在:location:~
query:::クエリ
	クエリ法:querying
	素片識別子
site:::サイト
頁:page::ページ
header:::ヘッダ

	●UI
対話性:interactivity:~:インタラクティブ性
対話的:interactive::~:インタラクティブ
対話:interaction::~:インタラクション

操作不可:disabled::~
操作可:enabled::~
読専:readonly:読み取り専用

利用者入力:user-input:~::ユーザ入力
入力:input:~
入力値:input value:input 値:~

不定の:indeterminate:~
強調:highlight:強調表示

focus:
	focused:focus を得ている
hover:
	hovering:hover 状態
	hovered-over
	ドラッグ:drag:~
	ドロップ:drop:~
	being dragged:drag中の
drag:
drop:
	drop先:drop target
target:
drag-and-drop:drag＆drop

動作:action:~::アクション
作動中:active:~::アクティブ
作動化-:activate:~::アクティベート
作動可能:activatable:~::アクティベータブル
作動化:activation:~::アクティベーション
作動期間:active 期間:~::アクティブ期間

送信:submit:~

未訪問の:unvisited:~
未訪問:unvisited:~
訪問済み:visited:~
form:::フォーム
	choices／
	排他的な~~選択肢:alternatives
改め:alter し:~
改めら:alter さ:~
	改め得る:alterable

	●UI 部品／機器

check:::チェック
mouse:::マウス
button:::ボタン
pointer:::ポインタ
pointing:::ポインタ指示::~
keyboard:::キーボード
event:::イベント
装置:device:~
機器:device:~
接触判定:hit-testing:~
interface:::インタフェース
control:::コントロール
label:::ラベル
menu:::メニュー
context:::コンテキスト
popup:::ポップアップ
進捗meter:progress meter::プログレスメータ
cursor:::カーソル
button:::ボタン
radio:::ラジオ
	ラジオグループ:radio group:~
checkbox:::チェックボックス
slider:::スライダ
select::選択::セレクト


	●文字名
comma:::カンマ
区切りの:-separated:~
colon:::コロン
	space → SPACE
asterisk:::アスタリスク
hyphen:::ハイフン
	スラッシュ:slash:~
正符号:plus sign:~
tilde:::チルダ
backslash:::バックスラッシュ
escape:::エスケープ
	escaping — エスケープ処理
空白:whitespace:~
終止符:full stop:~
	white space
角括弧:bracket:~
番号記号:number sign:~
	大なり記号:greater-than sign:~
	hash:
	pipe:
	vertical bar
	sign:符号

	●未分類
keyword:::キーワード
browser:::ブラウザ
literal:::リテラル
protocol:::プロトコル
boolean:::ブーリアン
述語:predicate:~
test:::テスト
flag:::フラグ
slot:::スロット
algo:algorithm::アルゴリズム
	バージョン:version:~
schema:::スキーマ
privacy:::プライバシー
security:::セキュリティ

hardware:::ハードウェア
pen:::ペン
system:::システム
video:::ビデオ
hint:::ヒント
	コメント:comment:~
top-level:::トップレベル
filter:::フィルタ
file:::ファイル
on:::オン

置換-:replace:~
組合せ:combination:組み合せ
組合せる:combine する:組み合せる
入子:入れ子

等価:equivalent:~
等価性:equivalence:~
種別:type:~
	先行:precede:~
解決-:resolve:~
解決:resolution:~
階層的:hierarchical:~
	階層:
	参照:reference, referencing, see
	指す:refer
	参照元:referring
比較:comparison:~
比較-:compare:~
		comparing
	順序:order:~
開始:start:~

拡張0-:expand:拡張
展開-:expand out:~

生成-:generate:~
共有-:share:~
条件:condition:~
処理能:performance:~
最適化-:optimize:~

現在の:current:~
	結果:result:~
集合:set:~
形式:format:~
論理的:logical:~
	分割:divide:~
構造的:structural:~
継承-:inherit:~
正規化:normalize:~
検索:find:~
獲得:acquire:~
失った:lose した:~
規範:normative:~
設定-:set:~
順序:order:~
有順序:ordered:~
演算:operation:~
反応:response:~
視覚的:visual:~
検知-:detect:~
記憶域:storage:~
	＊局所的:local:~
計算:calculating:~
計算-:calculate:~
選択済み:select 済み:~
単語:word:~
内側:inside:~
識別:identify:~
和集合:union:~
画像:image:~
動画:video:~::ビデオ
音声:audio:~
包含関係:containment:~
束縛-:bind:~
束縛法:binding:~
隣接性:adjacency:~
改行:linebreak:~
字幕:subtitle:~
連結:concatenate:~
表示:display:~
	奇数:odd:~
	偶数:even:~
構築-:construct:~
照合検索:searching:~
一意:unique:~
成功裡:successful:~
段落:paragraph:~
改変-:modify:~
graph:::グラフ
近隣:neighbors:~
反映-:reflect:~
包含-:contain:~
library:::ライブラリ
抽出-:extract:~
縞模様:zebra-stripe:~
背景色:background color:~
単純:simple:~
初期:initial:~
	初期~時:initially
読取る:read する:読み取る
読取って:read して:読み取って
読込まれ:load され:読み込まれ
整列-:sort:~
拡充-:populate:~
到達-:reach:~
解放-:release:~
検査法:checking:検査
増大-:increase:~
終端-:end:~
単独の:single:~
自動的:automatic:~

</script>

<!--% 他の語
見出す:find する:~
散らばって:scattered throughout
付き合わせて検査する cross-check
ある部分:some extent
定めて:state して
難しく:difficult:~
実際には:actually:~
扱い:treatment
今や棄てられた:now trashed
旧:older
成す:constituent
先頭の~colon:initial punctuation
緩い:lax

揃:align
境界:boundaries
収まら:fit しな
別形へ投影した:alternate projection
推定-:infer
~~方式:approach
不規則なもの:craziness
~~採用:taken from
未入力:omission／field was blank／omitted-but-required
~~考慮に入れられているthought if it became
疑似類による絞り込み:pseudo-classing
見出し:heading:~
引用文:quotations:~
意味:meaning:~
意味-:mean:~

~~複合~compound
普通の:regular:~
実用:usable
中核をなす:core component 1
逆向き:in reverse 1
密接な統合:close integration 1
無関係:irrelevance 1
表現力:-
過去:the past
未来:the future
操作中:-
有無が未設定:neither 〜 nor
他種:
上記参照:
多種多様:wildly varying
現実的:realistical 1
現実的に負荷が高過ぎる:unfortunately too slow to realistically
移行: 1
総称: 1
変換:changing
置換: 1

最後以外: 1
依然として:still 1
一種: 1
何故: 1
実行: 1
最短:shortest 1

互いに排他的:mutually exclusive 1
両立し得ない:mutually exclusive 2
	:characteristics 1
選定:chosen 1
採用/選ぶ:choose
:choice
以前: 1
同一視: 1
以上: 1
処理規則: 1
~~特別な追加~情報:extra information
地点:point 1
当該: 1
一致する／同じに:identical 1
前者:former 1

~~見出し:title
個別/個別的:individual 1
閉じ角括弧:closing bracket 1
用意: 1
対象外: 1
両方: 1
相当の力:considerable power 1
関連付けられた:associated: 1

地位: 1
取得: 1
周囲の:surrounding 1
直近の:closest 1

ベルギー・フランス語／ドイツ語:Belgian French／German: 1
フランス語:
新機能:new 1
一定期間が経過:some amount of time 1
措置:measures 1
非負~整数:non-negative integer 1
点線:dashed 1
一貫: 1
対象範囲: 1
直下:underneath 1
代理:aliases 1
期間:period 1
大半: 1
実際の:actual 2

通例
通例の:as usual
概して:typical に:~
大概の:typical:
ことが:commonly多い

多数: 1
少数: 1
生来的:in nature 1

完了率:percent completion
別物: 1
随意: 1
一度: 1
移動: 1
次第: 1
最大: 2
一定周期:cycle 1
前提: 1
~~成分:portion 1
交替的に float 配置:alternate the position of floated 1
上述: 1
付加: 1
2 次元: 2D
二重:double 2
普及している:common 1
一定: 1
自体: 1
策定: 1
便宜: 1
分離:split out 1

理由:due to
一覧: 2
終わる:end
始まる:begin
始まる:starting
操作: 2
略記: 2
操作可否: 2

仕分け:categorization 2
現時点: 2
	感嘆符:exclamation mark 2
複数個: 2
外側: 2

~~規則: 2
後者:latter 2
可能性: 2


個以上持: 2
float 配置:floated 1
配置:place 1
用例: 2
部品: 2
類似:similar 2
一部分: 2
親子関係:parentage/childhood relationship 2
主導:-primary 2

最高: 2

要約-:summarize/summary/Abstract
以下: 3
例示:show 3
有無: 3
処理: 3
変更:change 3
唯一: 3
同時:simultaneous 3
位置:position 3
自身以外: 3
最も近い先祖:innermost ancestor
個数: 3
左右され:sensitive
未選択の:with no pre-selected choice
選択済みの:initially-selected

通常:normal 4
通例の:as usual

括弧:parentheses 4
前後:before/after, and/or after 4
直後:immediately followed by 4
前置／先頭に挿入-:prepend:~

~~単独:alone
所属: 4
手続き: 4
用途: 5
分類
種類:kind/ 5
部分:part 5
表す:express 5
場所: 5
限定: 5
両者: 6
可能: 6
存在:presence／exist／ 6
方法:how 6
必要: 6
対応: 7
自身: 7
同様:similar 7
全体:entire 8
先頭の:leading 8
一連: 8
以外: 8
直前に位置する:immediately preceded 4
指示している:indicating
注意:note that 8
後続: 9
追加: 9
個以上: 10
付与: 11
一部: 12
一方: 14
複数:multiple/several 14
一致: 15
最後:last 18
番目:th 19
状態: 21
利用: 23
区切: 24
任意: 27
最初:first 28
対象: 29
場合: 87

節:section
例:example

最初の:first
 〜も:optionally
ふるまう:acts
動作対象:acting on

形／成し／form:form
切り替え:toggled
やりとり:interact-
誤り:error

元の:source

呼び出され:invoke
at-規則:at-rule
最も深い:deepest
番目の:th
行う:perform-
もしあれば:if any
many多くの
set一連の
Otherwise他の場合
平坦な:flat
満たす:satisfying
課され:impose
やり方／適用／手法:method
取り消す:cancels out
-:observe
まとめる:condense
示す:illustrate
すべての場合に対応する:catch all cases
緑:green
-:conceivably
疑わしい:suspect
~~組み合わせ:mixtures
style付け状態:stylistic states
必要なら:if necessary
守る:preserve
外す:stripped
〜されないようにする:prevents
無い:missing
要する:requiring
呼び出し:call
labelが付与された:labelled
押して:press して:~
離す:release する:~
一方で:meanwhile
受け取る:receive
内容を改め得る:alterable
変えられる:altered
交替的／順繰りに／別形:alternate
素の〜:standalone
数える／数に入れる:count
空でない:non-zero length
指す:address
色:color
望まれる:desired
孫:grandchild
遠い:later
等しい:equal
大きさ:size
切詰めら:clamp さ:切り詰めら
協力-:contribute
協力:contributions
超え:overflow
Repeated occurrances繰り返し:
新たな:new
imply:
機能する:function
連なり:chain
並び:sequence
前後:around
呼ばれ:called
戻す／返す:return
在る:lies
外側:outside
どこでも:anywhere
入子の:nested
高い:higher
問わない:regard
namespaced:
扱える:aware
３番目の:third
人の:human
任意の:arbitrary／any
持ち運ぶ:carry
carrying:

sense:
means:
suggestions:
forward:
necessarily:
comments:
include-:
including:
host-language-dependent:
possibility:
whichever:
-:conversely
zone:
queries:
potentially:
operation:
move:
consisting:
hand:
others:
process:
long:
key:
everyone:
basis:
case-sensitive
greater:
あてがう:assign
指す／~~指定する:designate
後続するすべての:possibly indirect
欠く:lacks
より低く:lower
語:term
間:during

／実:true
ある／一部の:certain
式:expression
含まれる:contained
行:line
前の:previous
生じる:occur
記され／書き出された:written
扱う:treat-
表示:display-
負の:negative
〜に基づいて:with respect to
より大きい:larger
等しければ:tied
対象に:takes
字:letter
対応-:correspond
checkされた状態／状態:checked
 checkされていない3:unchecked
〜に関わりなく:regardless
一致:exactly
正の:positive
避ける:avoid
異なる:different
異ならせる:differentiate
異なるように:differently
含んで:containing
追加／加えて:addition-
代わりに:instead
決して:never
〜のまま:left
主に:primarily
主:primary
指している／:pointing
いくつかの／複数の／挙げる:several
既に:already
possibly:
現れる:appear
全:full
それ自身:itself
起こり得る／可能／:possible
follows:
 属する:belong-
restriction:
stylesheet:style sheet
別の:another

determining:
含:include
含む:contain
time:
２番目の:second
見なす／考慮／考える:consider
見なされる:considered
取り除く:drop-/left out
形／成し／form:form
与え-:give-
挙げられる:listed
同じ:same
用い:use-
 〜に基づいて:based on
絞り込む:filtering
~~付随する:attach された
リスク:risk:~
置き換える:replaces
年月に渡り:years
	reachable

	traversing
探索look for
性質:quality
簡潔:compact:~

steps
pretty much:-
well-defined
最低限:at minimum:~
~~分類:distinguisher
似た役割を担う:serves a similar purpose
~~概念:notion

~~適切な~suitable
~~生成するproducing

well-defined
一体多:one-to-many
より高次の:higher-level
分離する:separated／
対応付ける:map
指針:guidance:~
おそらく:probably
型~名
十分:sufficient
安定的:robustly
欠落を埋める:bridge the gap

sole:
exact:
keeping:
happens:
probably:
doesn:
further:
put:
know:
pre:
prior:
seems:
known:
と:versus
taken:
ほとんど:almost
manner:
whenever:
elsewhere:
prev:
namely:
none:
say:
doing:
noted:
close:
following:
least:
now:
hits:

mostly:
constitutes:
although:
beyond:
per:
whereas:
則って:according
扱える:aware
taking:
therefore:
over:
among:
need:
things:
due:
respectively:
once:
sometimes:
adds:
made:
anything:
exist:
just:
make:
using:
three:
how:
〜でも〜でもない:neither 〜nor
〜に対して:against
followed:
consists:
like:
whose:
non:
case:
２つの:two
ほとんどの:most
もの:ones
次の:next
rather:
having:
please:
else:
better:
four:
whatever:
4:fourth


-->


<!--%links -->
<script type="text/plain" id="_link_map">

	<compound-selector>:#typedef-compound-selector
	<id-selector>:#typedef-id-selector
	<relative-selector>:#typedef-relative-selector
	<selector>:#typedef-selector

	API ~hook:#api-hooks
	DTD 内で与えられる属性の既定値:#def-values
ID 選択子:#id-selector
ID 選択子§:#id-selectors
名前空間:#type-nmsp
型:#type-selectors
詳細度:#specificity
	名前空間 接頭辞:#namespace-prefix
	● production: id = text = key
	combinator:combinator0



	● §疑似類 id= 
	blank:the-blank-pseudo
	empty:the-empty-pseudo
	first-child:the-first-child-pseudo
	first-of-type:the-first-of-type-pseudo
	last-child:the-last-child-pseudo
	last-of-type:the-last-of-type-pseudo
	nth-child():the-nth-child-pseudo
	nth-column():the-nth-column-pseudo
	nth-last-child():the-nth-last-child-pseudo
	nth-last-column():the-nth-last-column-pseudo
	nth-last-match():the-nth-last-match-pseudo
	nth-last-of-type():the-nth-last-of-type-pseudo
	nth-match():the-nth-match-pseudo
	nth-of-type():the-nth-of-type-pseudo
	only-child:the-only-child-pseudo
	only-of-type:the-only-of-type-pseudo
	root:the-root-pseudo

	●値（参照元なし）
	active:valdef-drop-active
	invalid:valdef-drop-invalid
	valid:valdef-drop-valid

	r.DOM:#biblio-whatwg-dom

選択子:#selector
選択子~照合~list:#selector-match-list
選択子を評価-:#evaluate-a-selector
評価-:#evaluate-a-selector
選択子として構文解析-:#parse-a-selector
選択子の構文解析-法§:#parse-selector
選択子の概観§:#overview
選択子の構文と構造§:#syntax
選択子の評価法§:#evaluating-selectors
選択子の詳細度の計算§:#specificity-rules
合致する:#match

疑似要素:#pseudo-element
疑似要素§:#pseudo-elements
疑似要素の種別§:#pseudo-element-types
出自の要素:#originating-element

木に対し選択子を照合する§:#match-against-tree
木に対し選択子を照合:#match-a-selector-against-a-tree
要素に対し選択子を照合する§:#match-against-element
要素に対し選択子を照合:#match-a-selector-against-an-element
同胞群:#_siblings

単体~選択子:#simple
合体~選択子:#compound
複体~選択子:#complex
の~list:#list-of-simple-selectors
選択子~list:#selector-list
選択子~list§:#grouping
部分照合 属性~選択子§:#attribute-substrings
全称~選択子:#universal-selector
全称~選択子§:#the-universal-selector
ID 選択子§:#id-selectors
~class選択子§:#class-html
~class選択子:#class-selector
基本的な選択子§:#elemental-selectors
基本的な選択子における名前空間§:#type-nmsp
型~選択子:#type-selector
型（~tag名）選択子§:#type-selectors
属性存在／属性値~選択子§:#attribute-representation
属性~選択子:#attribute-selector
属性~選択子§:#attribute-selectors
属性~選択子と名前空間§:#attrnmsp
格子構造~選択子§:#table-pseudos

相対~選択子:#relative-selector
相対~選択子§:#relative
相対~選択子の~listを絶対化:#absolutize-list
絶対化:#absolutize
相対~選択子として構文解析-:#parse-a-relative-selector
相対~選択子の構文解析-法§:#parse-relative-selector
相対~選択子の絶対化§:#absolutizing

無効な選択子:#invalid-selector
無効な選択子と~errorの取扱い§:#invalid
	fast vs complete 選択子~profile§:#profiles
視野根:#scoping-root
視野要素:#scoping-element
視野付き選択子:#scoped-selector
視野付き:#scoped-selector
視野付き選択子§:#scoping
~scope_ps要素:#scope-element
選択対象:#subject-of-a-selector
~virtual:#virtual-scoping-root

結合子:#combinator
結合子§:#combinators
~column結合子:#column-combinator
~column結合子§:#the-column-combinator
後続同胞~結合子:#following-sibling-combinator
後続同胞~結合子§:#general-sibling-combinators
子孫~結合子:#descendant-combinator
子孫~結合子§:#descendant-combinators
子~結合子:#child-combinator
子~結合子§:#child-combinators
次同胞~結合子:#next-sibling-combinator
次同胞~結合子§:#adjacent-sibling-combinators

疑似類:#pseudo-class
疑似類§:#pseudo-classes
範囲~疑似類§:#range-pseudos
自然言語 疑似類§:#the-lang-pseudo
自然言語:#language
自然言語に関する疑似類§:#linguistic-pseudos
言語範囲:#language-range
論理和 疑似類§:#matches
論理的な組合せ§:#logical-combination
起点要素 疑似類§:#the-scope-pseudo
過去要素 疑似類§:#the-past-pseudo
選択済み疑似類§:#checked
関数形~疑似類:#functional-pseudo-classes
~drag-and-drop疑似類§:#drag-pseudos
~pointer~hover疑似類§:#the-hover-pseudo
target 疑似類§:#the-target-pseudo
所在 疑似類§:#location
~hyperlink疑似類§:#the-any-link-pseudo
~link履歴 疑似類§:#link
不定値 疑似類§:#indeterminate
仮入力例示 疑似類§:#placeholder
作動化 疑似類§:#the-active-pseudo
入力 疑似類§:#input-pseudos
入力~focus疑似類§:#the-focus-pseudo
一般化 入力~focus疑似類§:#the-focus-within-pseudo

利用者~動作 疑似類§:#useraction-pseudos
利用者~対話 疑似類§:#user-pseudos
否定~疑似類§:#negation
型指定 子付番 疑似類§:#typed-child-index
変更可否 疑似類§:#rw-pseudos
妥当性 疑似類§:#validity-pseudos
子付番 疑似類§:#child-index
必須随意 疑似類§:#opt-pseudos
操作可否 疑似類§:#enableddisabled
方向性 疑似類§:#the-dir-pseudo
既定option 疑似類§:#the-default-pseudo
時系列 疑似類§:#time-pseudos
未来要素 疑似類§:#the-future-pseudo
構造と各種用語§:#structure
構造上の疑似類:#structural-pseudo-classes
構造上の疑似類§:#structural-pseudos
関係上の疑似類§:#relational
現在要素 疑似類§:#the-current-pseudo

~host言語:#host-language
文書~言語:#document-language
無特能:#featureless
静的~profile:#static-profile
動的~profile:#dynamic-profile
~data~model§:#data-model
~module間の相互作用§:#placement

入力~controlの状態§:#input-states
入力値の検査法§:#ui-validity
入力値の状態§:#input-value-states
API ~hook§:#api-hooks
	DTD 内で与えられる属性の既定値§:#def-values
名前空間§:#namespaces

変更点§:#changes

空白:#whitespace
宣言-:#nsdecl
未宣言:#nsdecl
属性値の文字大小の区別§:#attribute-case
文字大小の区別§:#case-sensitive

序論§:#context
文法§:#grammar
表記規約§:#conventions
適合性§:#conformance
適合性の定義とその適用対象§:#conformance-classes
	試験的実装§:#experimental
	部分的実装§:#partial
	特能:#feature


ps.paused:#selectordef-paused
ps.playing:#selectordef-playing

	●外部
ps.host:~SCOPING#selectordef-host
ps.host-context():~SCOPING#selectordef-host-context
ps.dir(ltr):~SELECTORS-HTML#selector-ltr
ps.dir(rtl):~SELECTORS-HTML#selector-rtl
p.direction:~CSSWM#propdef-direction
a.dropzone:~HTMLDND#the-dropzone-attribute

	●＊
t.any-value:~CSSSYN#typedef-any-value
t.attr-matcher:#typedef-attr-matcher
t.attr-modifier:#typedef-attr-modifier
t.attribute-selector:#typedef-attribute-selector
t.class-selector:#typedef-class-selector
t.column-token:~CSSSYN#typedef-column-token
t.combinator:#typedef-combinator
t.complex-selector-list:#typedef-complex-selector-list
t.complex-selector:#typedef-complex-selector
t.compound-selector-list:#typedef-compound-selector-list
t.compound-selector:#typedef-compound-selector
t.dash-match-token:~CSSSYN#typedef-dash-match-token
t.delim-token:~CSSSYN#typedef-delim-token
t.function-token:~CSSSYN#typedef-function-token
t.hash-token:~CSSSYN#typedef-hash-token
t.id-selector:#typedef-id-selector
t.ident-token:~CSSSYN#typedef-ident-token
t.ident:~CSSVAL#typedef-ident
t.include-match-token:~CSSSYN#typedef-include-match-token
t.ns-prefix:#typedef-ns-prefix
t.prefix-match-token:~CSSSYN#typedef-prefix-match-token
t.pseudo-class-selector:#typedef-pseudo-class-selector
t.pseudo-element-selector:#typedef-pseudo-element-selector
t.relative-selector-list:#typedef-relative-selector-list
t.relative-selector:#typedef-relative-selector
t.selector-list:#typedef-selector-list
t.simple-selector-list:#typedef-simple-selector-list
t.simple-selector:#typedef-simple-selector
t.string-token:~CSSSYN#typedef-string-token
t.string:~CSSVAL#string-value
t.substring-match-token:~CSSSYN#typedef-substring-match-token
t.suffix-match-token:~CSSSYN#typedef-suffix-match-token
t.type-selector:#typedef-type-selector
t.whitespace-token:~CSSSYN#typedef-whitespace-token
t.wq-name:#typedef-wq-name

	|:~CSSVAL#comb-one
	#:~CSSVAL#mult-comma
	*:~CSSVAL#mult-zero-plus
	+:~CSSVAL#mult-one-plus
	?:~CSSVAL#mult-opt


pe.before:~CSSWG/css-pseudo-4/#selectordef-before
pe.after:~CSSWG/css-pseudo-4/#selectordef-after
pe.first-line:~CSSWG/css-pseudo-4/#selectordef-first-line
pe.first-letter:~CSSWG/css-pseudo-4/#selectordef-first-letter
	＊content:~SCOPING#selectordef-content
pe.slotted:~SCOPING#selectordef-slotted

ps.-moz-ui-valid:https://developer.mozilla.org/en-US/docs/Web/CSS/%3A-moz-ui-valid
ps.-moz-ui-invalid:https://developer.mozilla.org/en-US/docs/Web/CSS/%3A-moz-ui-invalid
	ident:~CSSVAL#typedef-ident
	string:~CSSVAL#string-value

I.Element:~DOM4#interface-element
I.Text:~DOM4#interface-text
I.Comment:~DOM4#interface-comment
I.ProcessingInstruction:~DOM4#interface-processinginstruction
I.EntityReference:~DOM4#entityreference
I.DocumentFragment:~DOM4#interface-documentfragment
I.DocumentType:~DOM4#interface-documenttype
I.Document:~HTMLDOM#document
	~DOM4#interface-document
c.querySelector():~DOM4#dom-parentnode-queryselector

ASCII 文字大小無視:~DOM4#ascii-case-insensitive
	~HTML5/selectors.html#case-sensitivity

木:~DOM4#concept-tree
根:~DOM4#concept-tree-root
子孫:~DOM4#concept-tree-descendant
~shadow木:~DOM4#concept-shadow-tree
~shadowも含む子孫:~DOM4#concept-shadow-including-descendant
	~shadowも含む広義子孫:~DOM4#concept-shadow-including-inclusive-descendant
~shadowも含む木~順序:~DOM4#concept-shadow-including-tree-order
~shadowも含む根:~DOM4#concept-shadow-including-root
~shadow~host:~DOM4#element-shadow-host

素片:~URLSpec#concept-url-fragment


既定の名前空間:~CSSNS#default-namespace
CSS 有修飾名:~CSSNS#css-qualified-name
	#css-qnames
過去互換~mode:~DOM4#concept-document-quirks

~escape処理規則:~CSS21/syndata.html#characters
識別子:~CSSSYN#identifier


CSS 識別子:~CSS21/syndata.html#value-def-identifier
CSS 文字列:~CSS21/syndata.html#strings

断片:~CSSDISP#fragment
~box:~CSSDISP#box
~box木:~CSSDISP#box-tree

文書~要素:~DOM4#document-element
広義同胞:~DOM4#concept-tree-inclusive-sibling

</script>

<!-- 
空白~処理に影響される文字:~CSSTEXT#white-space-rules
CSS style 属性:~CSSSTYLEATTR#interpret
~AnB 小構文:~CSSSYN#anb-production
視野付き style 要素:~HTML5/semantics.html#the-style-element
作動可能な要素:~SELECTORS-HTML#selector-active
~focusを獲得し得る要素:~SELECTORS-HTML#selector-focus
media 要素の現在の再生位置に相対的:http://dev.w3.org/html5/webvtt/#the-past-and-future-pseudo-classes
e.html:~HTML5/semantics.html#the-html-element
	at.namespace:~CSSNS#declaration

参照:~HTML5/selectors.html#selector-hover
参照:~HTML5/scripting.html#selector-enabled
参照:~HTML5/scripting.html#selector-disabled
参照:~HTML5/scripting.html#selector-read-only
参照:~HTML5/scripting.html#selector-default
参照:~HTML5/scripting.html#selector-checked
参照:~HTML5/scripting.html#selector-indeterminate

e.html:~HTML5/semantics.html#the-html-element
p.display:~CSS2VISUREN#propdef-display
p.visibility:~CSS2VISUFX#propdef-visibility
	~CSS21/visufx.html#propdef-visibility
要素
A
B
DIALOGUE
EXAMPLE
FOO

e.a:semantics.html#the-a-element
e.area:embedded-content.html#the-area-element
e.body:semantics.html#the-body-element
e.button:forms.html#the-button-element
e.data:semantics.html#the-data-element
e.div:semantics.html#the-div-element
e.dl:semantics.html#the-dl-element
e.dt:semantics.html#the-dt-element
e.em:semantics.html#the-em-element
e.h1:semantics.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h2:semantics.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.html:semantics.html#the-html-element
e.img:embedded-content.html#the-img-element
e.input:forms.html#the-input-element
e.label:forms.html#the-label-element
e.li:semantics.html#the-li-element
e.link:semantics.html#the-link-element
e.menu:forms.html#the-menu-element
e.meta:semantics.html#the-meta-element
e.object:embedded-content.html#the-object-element
e.ol:semantics.html#the-ol-element
e.option:forms.html#the-option-element
e.p:semantics.html#the-p-element
e.pre:semantics.html#the-pre-element
e.q:semantics.html#the-q-element
e.section:semantics.html#the-section-element
e.select:forms.html#the-select-element
e.small:semantics.html#the-small-element
e.span:semantics.html#the-span-element
e.td:tables.html#the-td-element
e.tr:tables.html#the-tr-element

-->


<!--% style -->

<style type="text/css" >

/*
a.sec::before {
	content:"§";
}

.prod {
	color: #214869;
}

*/

pre, samp {
	color: #214869;
}

code.char {
	color: red;
}
span.code-point {
	color: gray;
}

code.property {
	color: darkblue;
}


#_overview_ tr.header1 {
	background:#FEE;
	border-top: 2px inset gray;
	border-bottom: 1px solid gray;
}
#_overview_ tr.header1 > th {
	font-weight: normal;
}
#_overview_ tr.header1 > th > a:first-child{
	font-weight: bold;
}

#_overview_ tr {
	border-top: solid #CCC 1px;
}

	/* Level */
.L3 {
	background: #F8F8E8;
}
.L4 {
	background: #F8F8CC;
}



</style>
<!-- 
#_overview_ tr:nth-child(even) {
	background:#EFF;
}


code.css::before {
	content: "‘"
}
code.css::after {
	content: "’"
}
-->

</head>

<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">
<h1>Selectors Level 4 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">Selectors Level 4</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2016-06-21</time>
（公開：<time>2012-06-23</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<div><a href="http://www.w3.org/" id="_W3C">W3C</a></div>

	<hgroup>
<h1 id="title">選択子 — Selectors Level 4</h1>
<h2>2016 年 6 月 20 日付 編集者草案</h2>
	</hgroup>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dd>https://drafts.csswg.org/selectors/</dd>

	<dt title="Latest version:">最新発行バージョン（ Level 3 ）</dt>
	<dd>https://www.w3.org/TR/selectors4/</dd>

	<dt title="Previous Versions:">以前の発行バージョン</dt>
	<dd>https://www.w3.org/TR/2013/WD-selectors4-20130502/</dd>
	<dd>https://www.w3.org/TR/2012/WD-selectors4-20120823/</dd>
	<dd>https://www.w3.org/TR/2011/WD-selectors4-20110929/</dd>

	<dt title="Test Suite:">テスト一式</dt>
	<dd>http://test.csswg.org/suites/selectors-4_dev/nightly-unstable/</dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="https://github.com/w3c/csswg-drafts/issues/">GitHub</a></dd>
	<dd><a href="#issues-index">仕様内</a></dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)</dd>
	<dd><a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)</dd>

	<dt title="Former Editors:">前任編集者</dt>
	<dd><a href="http://www.tantek.com/" lang="tr">Tantek Çelik</a></dd>
	<dd>Daniel Glazman</dd>
	<dd>Ian Hickson</dd>
	<dd>Peter Linss</dd>
	<dd>John Williams</dd>
</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright" rel=license>Copyright</a> © 2016 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
<a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
<a href="http://www.keio.ac.jp/">Keio</a>,
<a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
</small>
	</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
Selectors （~~選択子, ~~セレクタ）とは、文書~内の~nodeを選択するために利用し得る いくつかの技術のうちの一つであり，~node木の中の要素を対象に合致する~patternである。
Selectors は HTML および  XML における利用に最適化されてきており，処理能が~~重要な~codeの中でも実用になるように設計されている。
<abbr title="Cascading Style Sheets">CSS</abbr>
（ Cascading Style Sheets ）においては，文書~内の要素に~style付けの~propを束縛するために Selectors が利用される点で，その中核をなしている。
Selectors Level 4 は
<a href="#select">[SELECT]</a> に既存の選択子について述べ、更に
CSS や他の言語に必要になり得る新たな選択子を導入する。
<span lang="en">
Selectors are patterns that match against elements in a tree, and as such form one of several technologies that can be used to select nodes in a document. Selectors have been optimized for use with HTML and XML, and are designed to be usable in performance-critical code. They are a core component of CSS (Cascading Style Sheets), which uses Selectors to bind style properties to elements in the document. Selectors Level 4 describes the selectors that already exist in [SELECT], and further introduces new selectors for CSS and other languages that may need them.
</span></p>

<p>
<a href="http://www.w3.org/TR/CSS/">CSS</a>
は、（ HTML や XML などの）構造を備える文書から
~screen, 紙, 発話, 等々
の媒体への具現化法を記述するための言語である。
<span lang="en">
CSS is a language for describing the rendering of structured documents (such as HTML and XML) on screen, on paper, in speech, etc.
</span></p>


<p class="trans-note">【
Selectors — この仕様も含めた，選択子を規定する各種~levelの Selectors 仕様の総称
】</p>

	</section>
	<section id="status">
<h2 title="Status of this Document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<span class="trans-note">【
以下、この節の他の内容は
<a href="css-common-ja.html#status" >CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>


<p id="_at_risk_">
次の特色機能は
<a href="css-common-ja.html#at-risk">リスク下</a>
にあり， CR 期間に取り下げられる可能性があります。
<span lang="en">
The following features are at-risk, and may be dropped during the CR period:
</span></p>

<ul >
	<li>
`~column結合子$
◎
the column combinator
</li>

	<li>
`drop()$ps 疑似類
◎
the :drop() pseudo-class
</li>

	<li>
`read-write$ps 疑似類
◎
the :read-write pseudo-class
</li>

</ul>

	</section>

	<nav class="toc" id="contents">
<h2 title="Table of Contents">目次</h2>
<ol id="_toc_list0"></ol>

	</nav>

<main id="MAIN0">

	<section id="context">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
選択子とは、木~構造の中の要素を対象に，要素が選択子に合致するかどうかを~testするための、~boolean述語である。
◎
A selector is a boolean predicate that takes an element in a tree structure and tests whether the element matches the selector or not.
</p>

<p>
これらの式には多くの用途がある：
◎
These expressions may be used for many things:
</p>

<ul>
   <li>
`DOM$r にて定義される `element.matches()^c 関数などにおいて，要素が何らかの判定基準に合致するかどうかを直接的に~testする。
◎
directly on an element to test whether it matches some criteria, such as in the element.matches() function defined in [DOM]
</li>

<li>
`DOM$r にて定義される
`document.queryAll()^c
関数や,
あるいは CSS ~style規則の選択子を通して、要素がなす~node木~全体から，判定基準に合致する要素の集合に絞込む。
◎
applied to an entire tree of elements to filter it into a set of elements that match the criteria, such as in the document.queryAll() function defined in [DOM] or the selector of a CSS style rule.
</li>

<li>
<a href="http://haml.info/">HAML</a>
や
<a href="http://en.wikipedia.org/wiki/Zen_Coding">Zen Coding</a>
などのように、“逆向き” に用いて，与えられた選択子に合致するような~markupを生成する。
◎
used "in reverse" to generate markup that would match a given selector, such as in HAML or Zen Coding
</li></ul>

<p>
Selectors Level 1, 2, 3 は、それぞれ
<a href="~TR/REC-CSS1">CSS1</a>,
<a href="~CSS21/">CSS2.1</a>,
<a href="~TR/css3-selectors/">Selectors Level 3</a>
仕様に規定され，これらは選択子の機能性の~subsetであるものとして定義される。
この~moduleは Selectors Level 4 を規定する。
◎
Selectors Levels 1, 2, and 3 are defined as the subsets of selector functionality defined in the CSS1, CSS2.1, and Selectors Level 3 specifications, respectively. This module defines Selectors Level 4.
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
この~moduleは、
`SELECT$r および `CSS21$r
にて CSS のために定義された選択子の定義を置き換え, その集合を拡張する。
◎
This module replaces the definitions of and extends the set of selectors defined for CSS in [SELECT] and [CSS21].
</p>

<p>
具現化~木の中の抽象的な要素を定義する`疑似要素$選択子は、この仕様の一部をなすものではない：
汎的~構文についてはここで述べられるが，それらの具現化~modelとの密接な統合, および  DOM queries 他の無関係な用途，などの~~理由から、他の~moduleにて定義されることになる。
◎
Pseudo-element selectors, which define abstract elements in a rendering tree, are not part of this specification: their generic syntax is described here, but, due to their close integration with the rendering model and irrelevance to other uses such as DOM queries, they will be defined in other modules.
</p>
		</section>
	</section>
	<section id="overview">
<h2 title="Selectors Overview">2. 選択子の概観</h2>

<p>
<em>この節は参考であり，後続の節を要約するものに過ぎない。</em>
◎
This section is non-normative, as it merely summarizes the following sections.
</p>

<p class="trans-note">【
“選択子” という対訳に馴染みが悪ければウィンドウ下端の切り替え機能を利用されたし。
】</p>

<p>
選択子は、構造を表現する。
この構造は、文書~木の中でどの要素が選択子に合致するかを決定するための条件として（例えば CSS 規則における）, あるいは
その構造に対応する HTML や XML の素片の flat な記述として，利用し得る。
◎
A selector represents a structure. This structure can be used as a condition (e.g. in a CSS rule) that determines which elements a selector matches in the document tree, or as a flat description of the HTML or XML fragment corresponding to that structure.
</p>

<p>
選択子の表現力は、単純な要素名から多彩な文脈上の表現までに渡る。
◎
Selectors may range from simple element names to rich contextual representations.
</p>

<p>
選択子の構文は，次の一覧に要約される：
◎
The following table summarizes the Selector syntax:
</p>

<p class="trans-note">【
以下において， “ ~E 要素” とは、型（~tag名）が ~E である要素を意味する。
】<br>【
“分類” の見出しは訳者による追加。
】</p>

<table id="_overview_" class="data">

<colgroup>
<col class="pattern">
<col class="meaning">
<col class="section">
<col class="level">
</colgroup>

<thead><tr class="header1"><th colspan="4">分類
</th></tr><tr><th>~pattern◎Pattern
</th><th>表現される`選択対象$◎Represents
</th><th>節◎Section
</th><th>Level
</th></tr></thead>

<tbody><tr class="header1"><th colspan="4">
`基本的な選択子§
</th></tr>
<!-- 
elemental-selectors
	type-selectors
	type-nmsp
	universal-selector
-->
<tr><td>`*^css
</td><td>
任意の要素
◎
any element
</td><td>`全称~選択子§
</td><td>2

</td></tr><tr><td>`~E^css
</td><td>
任意の ~E 要素
◎
an element of type E
</td><td>`型（~tag名）選択子§
</td><td>1

</td></tr></tbody>

<tbody><tr class="header1"><th colspan="4">
`論理的な組合せ§
</th></tr>
<!-- 
logical-combination
grouping
matches
negation
-->
<tr class="L3"><td><code class="css">~E:not(%s1, %s2)</code>
</td><td>
`合体~選択子$ %s1, %s2 の両者に合致しない ~E 要素
◎
an E element that does not match either compound selector s1 or compound selector s2
</td><td>`否定~疑似類§
</td><td>3/4

</td></tr><tr class="L4"><td><code class="css">~E:matches(%s1, %s2)</code>
</td><td>
`合体~選択子$ %s1, %s2 の少なくとも一方には合致する ~E 要素
◎
an E element that matches compound selector s1 and/or compound selector s2
</td><td>`論理和 疑似類§
</td><td>4

</td></tr><tr class="L4"><td><code class="css">~E:has(%rs1, %rs2)</code>
</td><td>
~E を `~scope_ps要素$とした下で， %rs1, %rs2 のいずれかを`相対~選択子$として評価したときに、何らかの要素に合致するような， ~E
◎
an E element, if either of the relative selectors rs1 or rs2, when evaluated with E as the :scope elements, match an element 
</td><td>`関係上の疑似類§
</td><td>4

</td></tr></tbody>

<tbody><tr class="header1"><th colspan="4">
`属性~選択子§
</th></tr>
<!-- 
attribute-representation
attribute-substrings
attribute-case
attrnmsp
def-values
class-html
id-selectors
-->
<tr><td><code class="css">~E.%warning</code>
</td><td>
%warning ~class に属する ~E 要素
（要素が属する~classがどのように決定されるかは，文書~言語により指定される）。
◎
an E element belonging to the class warning (the document language specifies how class is determined).
</td><td>`~class選択子§
</td><td>1

</td></tr><tr><td><code class="css">~E#%myid</code>
</td><td>
ID が %myid に一致する ~E 要素
◎
an E element with ID equal to myid.
</td><td>`ID 選択子§
</td><td>1

</td></tr><tr><td><code class="css">~E[`foo^a]</code>
</td><td>
`foo^a 属性を伴う ~E 要素
◎
an E element with a foo attribute
</td><td>`属性存在／属性値~選択子§
</td><td>2

</td></tr><tr><td><code class="css">~E[`foo^a="%bar"]</code>
</td><td>
`foo^a 属性値が %bar に一致する ~E 要素
◎
an E element whose foo attribute value is exactly equal to bar
</td><td>`属性存在／属性値~選択子§
</td><td>2

</td></tr><tr class="L4"><td><code class="css">~E[`foo^a="%bar" i]</code>
</td><td>
`ASCII 文字大小無視$の下で， `foo^a 属性値が %bar に一致する ~E 要素
◎
an E element whose foo attribute value is exactly equal to any (ASCII-range) case-permutation of bar
</td><td>`属性値の文字大小の区別§
</td><td>4

</td></tr><tr><td><code class="css">~E[`foo^a~="%bar"]</code>
</td><td>
`foo^a 属性値を`空白$区切りで分割したときに，いずれかの項が %bar に一致する ~E 要素
◎
an E element whose foo attribute value is a list of whitespace-separated values, one of which is exactly equal to bar
</td><td>`属性存在／属性値~選択子§
</td><td>2

</td></tr><tr class="L3"><td><code class="css">~E[`foo^a^="%bar"]</code>
</td><td>
`foo^a 属性値が文字列 %bar から始まる ~E 要素
◎
an E element whose foo attribute value begins exactly with the string bar
</td><td>`部分照合 属性~選択子§
</td><td>3

</td></tr><tr class="L3"><td><code class="css">~E[`foo^a$="%bar"]</code>
</td><td>
`foo^a 属性値が文字列 %bar で終わる ~E 要素
◎
an E element whose foo attribute value ends exactly with the string bar
</td><td>`部分照合 属性~選択子§
</td><td>3

</td></tr><tr class="L3"><td><code class="css">~E[`foo^a*="%bar"]</code>
</td><td>
`foo^a 属性値が %bar を部分文字列として包含する ~E 要素
◎
an E element whose foo attribute value contains the substring bar
</td><td>`部分照合 属性~選択子§
</td><td>3

</td></tr><tr><td><code class="css">~E[`foo^a|="%en"]</code>
</td><td>
`foo^a 属性値を~hyphen区切りで分割したときに，その最初の項が %en に一致する ~E 要素
◎
an E element whose foo attribute value is a hyphen-separated list of values beginning with en
</td><td>`属性存在／属性値~選択子§
</td><td>2

</td></tr></tbody>

<tbody><tr class="header1"><th colspan="4">
`自然言語に関する疑似類§
</th></tr>
<!-- 
the-dir-pseudo
the-lang-pseudo
 -->

<tr class="L4"><td>`~E:dir(ltr)^css
</td><td>
方向性が left-to-right の ~E 要素
（方向性がどのように決定されるかは文書~言語が指定する）
◎
an element of type E in with left-to-right directionality (the document language specifies how directionality is determined)
</td><td>`方向性 疑似類§
</td><td>4

</td></tr><tr><td>`~E:lang(zh, "*-hant")^css
</td><td>
言語~tagが［
標準中国語（そのどの方言／表記体系も含む）, あるいは繁体字で記されたもの
］として付与された下にある ~E 要素
◎
an element of type E tagged as being either in Chinese (any dialect or writing system) or othewise written with traditional Chinese characters
</td><td>`自然言語 疑似類§
</td><td>2/4

</td></tr></tbody>

<tbody><tr class="header1"><th colspan="4">
`所在 疑似類§（
以下における “~link” とは、~hyperlinkの~source~anchorを意味する
）
</th></tr>
<!-- 
the-any-link-pseudo
link
the-target-pseudo
the-scope-pseudo
 -->
<tr class="L4"><td>`~E:any-link^css
</td><td>
~linkである ~E 要素
◎
an E element being the source anchor of a hyperlink
</td><td>`~hyperlink疑似類§
</td><td>4

</td></tr><tr><td>`~E:link^css
</td><td>
~targetが未訪問の~linkである ~E 要素
◎
an E element being the source anchor of a hyperlink of which the target is not yet visited
</td><td>`~link履歴 疑似類§
</td><td>1

</td></tr><tr><td>`~E:visited^css
</td><td>
~targetが訪問済み~linkである ~E 要素
◎
an E element being the source anchor of a hyperlink of which the target is already visited
</td><td>`~link履歴 疑似類§
</td><td>1

</td></tr><tr class="L3"><td>`~E:target^css
</td><td>
参照元 URL から~targetにされている ~E 要素
◎
an E element being the target of the referring URL
</td><td>`target 疑似類§
</td><td>3

</td></tr><tr class="L4"><td>`~E:scope^css
</td><td>
`~scope_ps要素$に~~指定されている ~E 要素
◎
an E element being a designated reference element
</td><td>`起点要素 疑似類§
</td><td>4

</td></tr></tbody>


<tbody><tr class="header1"><th colspan="4">
`時系列 疑似類§
</th></tr>
<!-- 
the-current-pseudo
the-past-pseudo
the-future-pseudo
-->

<tr class="L4"><td>`~E:current^css
</td><td>
時系列再生の下で現在~呈示~中の ~E 要素
◎
an E element that is currently presented in a time-dimensional canvas
</td><td>`現在要素 疑似類§
</td><td>4

</td></tr><tr class="L4"><td>`~E:current(~S)^css
</td><td>
最も階層が深い `current$ps 要素であって, 選択子 ~S に合致する ~E 要素。
【？】
◎
an E element that is the deepest :current element that matches selector s
</td><td>`現在要素 疑似類§
</td><td>4

</td></tr><tr class="L4"><td>`~E:past^css
</td><td>
時系列再生の下で過去に現れた ~E 要素
◎
an E element that is in the past in a time-dimensional canvas
</td><td>`過去要素 疑似類§
</td><td>4

</td></tr><tr class="L4"><td>`~E:future^css
</td><td>
時系列再生の下で未来に現れる ~E 要素
◎
an E element that is in the future in a time-dimensional canvas
</td><td>`未来要素 疑似類§
</td><td>4

</td></tr></tbody>


<tbody><tr class="header1"><th colspan="4">
`利用者~動作 疑似類§
</th></tr>
<!-- 
the-hover-pseudo
the-active-pseudo
the-focus-pseudo
drag-pseudos
-->

<tr><td>`~E:active^css
</td><td>
作動化された ~E 要素
◎
an E element that is in an activated state
</td><td>`作動化 疑似類§
</td><td>1

</td></tr><tr><td>`~E:hover^css
</td><td>
~cursorが指している要素, またはその要素を子孫に持つ
~E 要素
◎
an E element that is under the cursor, or that has a descendant under the cursor
</td><td>`~pointer~hover疑似類§
</td><td>2

</td></tr><tr><td>`~E:focus^css
</td><td>
利用者入力の~focusを得ている ~E 要素
◎
an E element that has user input focus
</td><td>`入力~focus疑似類§
</td><td>2

</td></tr><tr class="L4"><td>`~E:focus-within^css
</td><td>
`~E:focus^css に合致する要素, および その先祖
【この項目は、訳者による補完】
</td><td>`一般化 入力~focus疑似類§
</td><td>4？</td></tr>

<!-- 
E:drop
an E element that can possibly receieve a drop
E:drop(active)
an E element that is the current drop target for the item being dragged
E:drop(valid)
an E element that could receive the item currently being dragged
E:drop(invalid)
an E element that cannot receive the item currently being dragged, but could receive some other item
 -->



<tr class="L4"><td>`~E:drop^css
</td><td>
~drag操作の~drop先である ~E 要素
— （次の３項も含め，）~drag操作中に限り，適用される
◎
an E element that can possibly receive a drop
</td><td>`~drag-and-drop疑似類§
</td><td>4

</td></tr><tr class="L4"><td>`~E:drop(active)^css
</td><td>
~dragしている項目がその場で~dropされたとするときに，それを受け取る ~E 要素
◎
an E element that is the current drop target for the item being dragged
</td><td>`~drag-and-drop疑似類§
</td><td>4

</td></tr><tr class="L4"><td>`~E:drop(valid)^css
</td><td>
~dragしている項目に対し “有効な” ~drop先である ~E 要素
◎
an E element that could receive the item currently being dragged
E:drop(invalid)
</td><td>`~drag-and-drop疑似類§
</td><td>4

</td></tr><tr class="L4"><td>`~E:drop(invalid)^css
</td><td>
~dragしている項目に対しては “無効な” ~drop先である ~E 要素
◎
an E element that cannot receive the item currently being dragged, but could receive some other item
</td><td>`~drag-and-drop疑似類§
</td><td>4</td></tr>
	</tbody>



<tbody><tr class="header1"><th colspan="4">
`入力 疑似類§（
“UI” は “利用者~interface” の略語
）
</th></tr>
<!-- 
input-states
enableddisabled
rw-pseudos
placeholder
the-default-pseudo
input-value-states
checked
indeterminate
ui-validity
validity-pseudos
range-pseudos
opt-pseudos
user-pseudos
 -->

<tr class="L3"><td>`~E:enabled^css<br>`~E:disabled^css
</td><td>
それぞれ、［
操作可／操作不可
］にされている，型 ~E の~UI要素
◎
a user interface element E that is enabled or disabled, respectively
</td><td>`操作可否 疑似類§
</td><td>3

</td></tr><tr class="L3"><td>`~E:read-only^css<br>`~E:read-write^css
</td><td>
それぞれ、利用者が内容を［
改め得る／改め得ない
］ような，型 ~E の~UI要素
◎
a user interface element E that is user alterable, or not
</td><td>`変更可否 疑似類§
</td><td>3-UI/4

</td></tr><tr class="L3"><td>`~E:placeholder-shown^css
</td><td>
現在~仮入力~textを例示している，型 ~E の入力~control
◎
an input control currently showing placeholder text
</td><td>`仮入力例示 疑似類§
</td><td>3-UI/4

</td></tr><tr class="L3"><td>`~E:default^css
</td><td>
一連の選択肢の中で既定の選択肢にされている，型 ~E の~UI要素
◎
a user interface element E that is the default item in a group of related choices
</td><td>`既定option 疑似類§
</td><td>3-UI/4

</td></tr><tr class="L3"><td>`~E:checked^css
</td><td>
~checkまたは選択されている，型 ~E の~UI要素 
（~radio~buttonや~checkboxなど）
◎
a user interface element E that is checked/selected (for instance a radio-button or checkbox)
</td><td>`選択済み疑似類§
</td><td>3

</td></tr><tr class="L4"><td>`~E:indeterminate^css
</td><td>
不定の（~checkの有無が未設定の）状態にある，型 ~E の~UI要素
◎
a user interface element E that is in an indeterminate state (neither checked nor unchecked)
</td><td>`不定値 疑似類§
</td><td>4

</td></tr><tr class="L3"><td>`~E:valid^css<br>`~E:invalid^css
</td><td>
それぞれ、入力値が［
妥当である／妥当でない
］ような，型 ~E の利用者入力~要素
◎
a user-input element E that meets, or doesn’t, its data validity semantics
</td><td>`妥当性 疑似類§
</td><td>3-UI/4

</td></tr><tr class="L3"><td>`~E:in-range^css<br>`~E:out-of-range^css
</td><td>
それぞれ、入力値が［
範囲~内／範囲~外
］にある，型 ~E の利用者入力~要素
◎
a user-input element E whose value is in-range/out-of-range
</td><td>`範囲~疑似類§
</td><td>3-UI/4</td></tr>

<tr class="L3"><td>`~E:required^css<br>`~E:optional^css
</td><td>
それぞれ、入力が必須［
である／でない
］，型 ~E の利用者入力~要素
◎
a user-input element E that requires/does not require input
</td><td>`必須随意 疑似類§
</td><td>3-UI/4</td></tr>

<tr class="L3"><td>`~E:user-invalid^css
</td><td>
入力値が不正な（妥当でない, 範囲~外, 必須にもかかわらず未入力）†，型 ~E の利用者入力~要素
【†かつ，利用者により何らかの入力も行われているような】
◎
a user-altered user-input element E with incorrect input (invalid, out-of-range, omitted-but-required)
</td><td>`利用者~対話 疑似類§
</td><td>3-UI/4</td></tr>


	</tbody>

<tbody><tr class="header1"><th colspan="4">
`構造上の疑似類§（
以下における “同胞” とは、“同胞要素” の略記であり，同じ親を共有する一連の要素を意味する（同じ親の子~nodeのうち，~textなど他種の~nodeを除外した要素~nodeのみからなる~list））。
</th></tr>
<!-- 
anb
anb-syntax
anb-grammar
child-index
 -->
<tr class="L3"><td>`~E:root^css
</td><td>
文書の根である ~E 要素
◎
an E element, root of the document
</td><td>`root$PS</td><td>3

</td></tr><tr class="L3"><td>`~E:empty^css
</td><td>
（ Text ~nodeも含め）子~nodeを持たない ~E 要素
◎
an E element that has no children (not even text nodes)
</td><td>`empty$PS</td><td>3

</td></tr><tr class="L4"><td>`~E:blank^css
</td><td>
`空白$以外の内容を持たない ~E 要素
◎
an E element that has no content except maybe white space
</td><td>`blank$PS</td><td>4

</td></tr><tr class="L3"><td>`~E:nth-child(~n [of ~S]?)^css
</td><td>
同胞の中で ~S に合致するような ~n 番目の ~E 要素
◎
an E element, the n-th child of its parent matching sel
</td><td>`nth-child()$PS</td><td>3

</td></tr><tr class="L3"><td>`~E:nth-last-child(~n [of ~S]?)^css
</td><td>
同胞の中で ~S に合致するような最後から ~n 番目の ~E 要素
◎
an E element, the n-th child of its parent matching sel, counting from the last one
</td><td>`nth-last-child()$PS</td><td>3

</td></tr><tr><td>`~E:first-child^css
</td><td>
同胞の中で最初の ~E 要素
◎
an E element, first child of its parent
</td><td>`first-child$PS</td><td>2

</td></tr><tr class="L3"><td>`~E:last-child^css
</td><td>
同胞の中で最後の ~E 要素
◎
an E element, last child of its parent
</td><td>`last-child$PS</td><td>3

</td></tr><tr class="L3"><td>`~E:only-child^css
</td><td>
自身以外に同胞は無い ~E 要素
◎
an E element, only child of its parent
</td><td>`only-child$PS</td><td>3

</td></tr><tr class="L3"><td>`~E:nth-of-type(~n)^css
</td><td>
同胞の中の ~E 要素のうち ~n 番目のもの
◎
an E element, the n-th sibling of its type
</td><td>`nth-of-type()$PS</td><td>3

</td></tr><tr class="L3"><td>`~E:nth-last-of-type(~n)^css
</td><td>
同胞の中の ~E 要素のうち最後から ~n 番目のもの
◎
an E element, the n-th sibling of its type, counting from the last one
</td><td>`nth-last-of-type()$PS</td><td>3

</td></tr><tr class="L3"><td>`~E:first-of-type^css
</td><td>
同胞の中の ~E 要素のうち最初のもの
◎
an E element, first sibling of its type
</td><td>`first-of-type$PS
</td><td>3

</td></tr><tr class="L3"><td>`~E:last-of-type^css
</td><td>
同胞の中の ~E 要素のうち最後のもの
◎
an E element, last sibling of its type
</td><td>`last-of-type$PS</td><td>3

</td></tr><tr class="L3"><td>`~E:only-of-type^css
</td><td>
同胞の中の ~E 要素が自身のみであるもの
◎
an E element, only sibling of its type
</td><td>`only-of-type$PS</td><td>3

</td></tr></tbody>

<tbody><tr class="header1"><th colspan="4">
`結合子§（
語  “同胞” は上記参照
）
</th></tr>

<tr><td>`~E ~F^css
</td><td>
~E 要素の子孫である ~F 要素
◎
an F element descendant of an E element
</td><td>`子孫~結合子§
</td><td>1</td></tr>
<tr class="L4"><td>`~E &gt;&gt; ~F^css
</td><td>
同上
</td><td>同上</td><td>4

</td></tr><tr><td>`~E &gt; ~F^css
</td><td>
~E 要素の子である ~F 要素
◎
an F element child of an E element
</td><td>`子~結合子§
</td><td>2

</td></tr><tr><td>`~E + ~F^css
</td><td>
同胞の中で， ~E 要素の直後にある ~F 要素
◎
an F element immediately preceded by an E element
</td><td>`次同胞~結合子§
</td><td>2

</td></tr><tr class="L3"><td>`~E ~ ~F^css
</td><td>
同胞の中で， ~E 要素に後続している ~F 要素
◎
an F element preceded by an E element
</td><td>`後続同胞~結合子§
</td><td>3

</td></tr></tbody>

<tbody><tr class="header1"><th colspan="4">
`格子構造~選択子§
</th></tr>

<tr class="L4"><td>`~F || ~E^css
</td><td>
格子／~table内の， ~F 要素で表現される~columnに属する~cellを表現する ~E 要素
◎
an E element that represents a cell in a grid/table belonging to a column represented by an element F
</td><td>`~column結合子§
</td><td>4

</td></tr><tr class="L4"><td>`~E:nth-column(~n)^css
</td><td>
格子／~table内の ~n 番目の~columnに属する~cellを表現する ~E 要素
◎
an E element that represents a cell belonging to the nth column in a grid/table
</td><td>`nth-column()$PS</td><td>4

</td></tr><tr class="L4"><td>`~E:nth-last-column(~n)^css
</td><td>
格子／~table内の最後から ~n 番目の~columnに属する~cellを表現する ~E 要素
◎
an E element that represents a cell belonging to the nth column in a grid/table, counting from the last one
</td><td>`nth-last-column()$PS</td><td>4</td></tr>
</tbody>

</table>

<p class="note">注記：
一部の Level 4 選択子（上の一覧で "3-UI" と記されているもの）は
`CSS3UI$r
にて導入されたものである。
◎
Note: Some Level 4 selectors (noted above as "3-UI") were introduced in [CSS3UI].
</p>

		<section id="profiles">
<h3 title="Dynamic vs Static Selector Profiles">2.1. 選択子の <i>動的</i> vs <i>静的</i> ~profile</h3>

<p>
選択子は，多種多様な処理能の文脈~下で利用される。
あいにく、一部の強力な選択子は，処理能に左右され易い文脈に含めるには 現実的に負荷が高過ぎる。
これに適応するため、 Selectors 仕様には 2 種類の~profileが定義される：
◎
Selectors are used in many different contexts, with wildly varying performance characteristics. Some powerful selectors are unfortunately too slow to realistically include in the more performance-sensitive contexts. To accommodate this, two profiles of the Selectors spec are defined:
</p>

<dl>
	<dt>`動的~profile@</dt>
	<dd>
<p>
`動的~profile$は、~browserにおける動的な CSS 選択子の照合処理も含めた，任意の文脈の下での利用に適切になるものである。
次のもの以外の，この文書にて定義されるすべての選択子が含まれる：
◎
The dynamic profile is appropriate for use in any context, including dynamic browser CSS selector matching. It includes every selector defined in this document, except for:
</p>

<ul><li>
`has()$ps 疑似類
◎
The :has() pseudo-class
</li></ul>

	</dd>

	<dt>`静的~profile@</dt>
	<dd>
`静的~profile$は，処理能にあまり左右されない文脈の下で適切になる。
特に，静的な文書~木に対し選択子を評価する文脈~下で適切になる。
例えば、 `DOM$r にて定義される `query()^c ~methodは，静的~profileを用いるべきである。
これには，この文書に定義されるすべての選択子が含まれる。
◎
The static profile is appropriate for contexts which aren’t extremely performance sensitive; in particular, it’s appropriate for contexts which evaluate selectors against a static document tree. For example, the query() method defined in [DOM] should use the static profile. It includes all of the selectors defined in this document.
</dd></dl>

<p>
Selectors Level 4 に適合する CSS 実装は、 CSS 選択処理に際しては，`動的~profile$を用い~MUST。
`動的~profile$を利用する実装は、~profileに含まれない選択子を，未知の／無効なものとして扱わ~MUST。
◎
CSS implementations conformant to Selectors Level 4 must use the dynamic profile for CSS selection. Implementations using the dynamic profile must treat selectors that are not included in the profile as unknown and invalid.
</p>

<p class="issue">
“動的” ／ “静的” ~profileへの仕分けは，実装者による考査を要する。
現時点では動的~profileに仕分けられていないものが，
CSS Selectors にて手頃に行えるならば、それらは移行されるべきである。
◎
The categorization of things into the "dynamic" or "static" profiles needs implementor review. If some things currently not in the dynamic profile can reasonably be done in CSS Selectors, we should move them.
</p>

		</section>
	</section>
	<section id="syntax">
<h2 title="Selector Syntax and Structure">3. 選択子の構文と構造</h2>

		<section id="structure">
<h3 title="Structure and Terminology">3.1. 構造と各種用語</h3>


<p>
語
`選択子@
（ selector ）は、［
`単体~選択子$,
`合体~選択子$,
`複体~選択子$,
`選択子~list$
］の総称である。
◎
The term selector can refer to a simple selector, compound selector, complex selector, or selector list.
</p>

<p class="trans-note">【
この仕様の中では、`複体~選択子$の意味で用いられることが多い。
この種の<a href="#_note1_">同一視</a>は、“一定範囲の要素を選択する” という機能上の観点からは同等に扱える意味で 理に適う面もある一方で，定義などが解り難くなる面もあるので、この訳では必要に応じて注釈を加えている。
】</p>


<p>
`単体~選択子@
（ simple selector ）は、特定0の側面に合致する要素を表現する。
それは、次のいずれかである：
`型~選択子$,
`全称~選択子$,
`属性~選択子$,
`~class選択子$,
`ID 選択子$,
`疑似類$
◎
A simple selector represents an element matched by a particular aspect. A type selector, universal selector, attribute selector, class selector, ID selector, or pseudo-class is a simple selector.
</p>

<p>
`合体~選択子@
（ compound selector ）は、`結合子$で区切られていない`単体~選択子$の並びである。
それは、それが包含するすべての`単体~選択子$に合致するような要素を表現する。
`型~選択子$／`全称~選択子$が並びに包含されるならば、それは先頭に来~MUST。
◎
A compound selector is a sequence of simple selectors that are not separated by a combinator. It represents an element that matches all of the simple selectors it contains. If it contains a type selector or universal selector, that selector must come first in the sequence. Only one type selector or universal selector is allowed in the sequence.
</p>

<p class="note">注記：
空白も妥当な`結合子$である。
`合体~選択子$の中の`単体~選択子$の合間には、空白は許容されない。
◎
Note: As whitespace is a valid combinator, no whitespace is allowed between the simple selectors in a compound selector.
</p>

<p>
`複体~選択子@
（ complex selector ）は、`結合子$で区切られた， 1 個以上の`合体~選択子$の並びである。
◎
A complex selector is a sequence of one or more compound selectors separated by combinators.
</p>

<p class="trans-note" id="_note1_">【
これらの語は，上述の様に階層的な関係で区別されるものであるが、（構文上は／機能的には）同時に：
(1) `型~選択子$や`全称~選択子$は， 1 個の`単体~選択子$からなる`合体~選択子$と見なすこともでき,
(2) `合体~選択子$は， 1 個のそれからなる`複体~選択子$と見なすこともでき,
(3) `複体~選択子$は， 1 個のそれからなる`選択子~list$と見なすこともできる。
その結果， 1 個の`単体~選択子$は，`選択子~list$と見なせることになり、`合体~選択子$の（先頭からの）一部分はまた `合体~選択子$と見なすことことができ，`複体~選択子$の一部分はまた `複体~選択子$と見なすこともできる, 等々になる。

従って，例えば、複体~選択子に適用される~algoや要件は，型~選択子などの単体~選択子や合体~選択子，等々にも（それを複体~選択子と見なした下で）適用されることになる。
】</p>

<div>
<p>
`結合子@
（ combinator ）は、両側にある`合体~選択子$の間の特定0の種類の関係性を表現する。
Selectors Level 4 の結合子には次の 4 種がある：
</p>

<ul>
	<li>
`子孫~結合子$（`空白$）
</li>
	<li>
`子~結合子$（大なり記号, "<code class="char">&gt;</code>" `003E^cp ）
</li>
	<li>
`次同胞~結合子$（正符号, ❝+ ）
</li>
	<li>
`後続同胞~結合子$（~tilde, ❝~ ）
</li>
</ul>

◎
A combinator represents a particular kind of relationship between the elements matched by the compound selectors on either side. Combinators in Selectors level 4 include: the descendant combinator (white space), the child combinator (U+003E, &gt;), the next-sibling combinator (U+002B, +), and the following-sibling combinator (U+007E, ~).

</div>

<p>
［
`単体~選択子$／`合体~選択子$／`複体~選択子$
］
`の~list@
とは、これらいずれかの選択子からなる~comma区切りの~listである。
いずれでもよい場合 ／ 周囲の注釈文から明らかな場合は、単に
`選択子~list@
とも称される。
既定では、`複体~選択子$`の~list$の意味になる。
詳細は、`選択子~list§ 節を見よ。
◎
A list of simple/compound/complex selectors is a comma-separated list of simple, compound, or complex selectors. This is also called just a selector list when the type is either unimportant or specified in the surrounding prose; if the type is important and unspecified, it defaults to meaning a list of complex selectors. See §4.1 Selector Lists for further details on selector lists.
</p>


<p>
選択子の
`選択対象@
とは、その選択子が表現するもの（ to be about ）として定義される要素たちである：
◎
The subject of a selector is the element(s) that selector is defined to be about:
</p>

<ul>
	<li>
`単体~選択子$に対しては、その選択子により表現される任意の要素である。
◎
For a simple selector, it is any element represented by that selector.
</li>
	<li>
`合体~選択子$に対しては、それを成す`単体~選択子$すべてに合致するような，任意の要素である。
◎
For a compound selector, it is any element that matches all of its composite simple selectors.
</li>
	<li>
`複体~選択子$に対しては、その最後の`合体~選択子$に合致するような，任意の要素【をその前の部分を成す合体~選択子たちで絞り込んだもの（詳細は、下の段落に）】
である。
◎
For a complex selector, it is any element that matches the last compound selector in the selector.
</li>
	<li>
`選択子~list$に対しては、その~list内のいずれかの`選択子$に合致するような，任意の要素である。
◎
For a selector list, it is any element that matches any of the selectors in the list.
</li>

</ul>


<p>
選択子の`選択対象$であるような要素は、その選択子に
`合致する@
とされる。
したがって、単独の`合体~選択子$からなる選択子は、それ
【を成す単体~選択子たち】
による要件すべてを満たすような，どの要素にも合致する。
選択子【複体~選択子】に［
別の`合体~選択子$と`結合子$
］を前置することは、要素がその選択子に合致するための，追加の拘束を課すことになる。
よって，選択子の`選択対象$は、常に，最後の`合体~選択子$により表現される要素たちの部分集合になる。
◎
An element is said to match a selector if it is a subject of that selector. Thus a selector consisting of a single compound selector matches any element satisfying its requirements. Prepending another compound selector and a combinator to a sequence imposes additional matching constraints, so the subjects of a complex selector are always a subset of the elements represented by its last compound selector.
</p>


<p class="issue">
これを［
複体~選択子は，その最後の合体~選択子を “表現する”
］と称して， less wishy-washy にできるか？
あるいは、［
%a + %b
］は、［
同胞の関係性の下で，%a と %b の両者を “表現する”
］と述べる必要があるか？
◎
Can we make this less wishy-washy by saying that a complex selector “represents” its last compound selector? Or do we need to have a + b “represent” both an "a" and a "b" in a sibling relationship?
</p>


<p class="issue">
疑似要素は，ここでは取扱われていないが、取扱われるべき。
◎
Pseudo-elements aren’t handled here, and should be.
</p>


		</section>
		<section id="data-model">

<h3 title="Data Model">3.2. ~data~model</h3>


<p>
選択子は、 DOM 木 `DOM$r などの要素~木に対し評価される。
この仕様においては、“文書~木”, あるいは “~source文書” とも称される。
◎
Selectors are evaluated against an element tree such as the DOM. [DOM] Within this specification, this may be referred to as the "document tree" or "source document".
</p>


<p>
各~要素は、次に挙げる 5 種の側面
【これらは、以下では “特能（ feature ）” と総称される】
に基いて選択される
— いずれも文字列として照合される：
◎
Each element may have any of the following five aspects, which can be selected against, all of which are matched as strings:
</p>


<ul>
	<li>
要素の型（~tag名としても周知）
◎
The element’s type (also known as its tag name).
</li>

	<li>
要素の名前空間
◎
The element’s namespace.
</li>

	<li>
ID
◎
An ID.
</li>

	<li>
要素が属する~class（名前を持つ~group）たち
◎
Classes (named groups) to which it belongs.
</li>

	<li>
［
名前, 値
］の対である，属性
◎
Attributes, which are name-value pairs.
</li>

</ul>


<p>
個々の要素には、上述のうち いくつかの特能を欠くものもある中で，
`無特能@
のもの
— すなわち，どの特能も備えないもの —
もある。
`無特能$の要素は，どの選択子にも合致しない
— 明示的に合致するとされるものを除いて。
`無特能$の要素に合致するような選択子は、既定の名前空間 `CSS3NAMESPACE$r も無視して合致し~MUST
◎
While individual elements may lack any of the above features, some elements are featureless. A featureless element does not match any selector at all, except those it is explicitly defined to match. If a given selector is allowed to match a featureless element, it must do so while ignoring the default namespace. [CSS3NAMESPACE]
</p>

<div class="example">
<p>
例えば、`~shadow木$の中の`~shadow~host$は，`無特能$であり、
`host$ps および `host-context()$ps
を除く，<em >どの</em> `疑似類$にも合致しない。
◎
For example, the shadow host in a shadow tree is featureless, and can’t be matched by any pseudo-class except for :host and :host-context().)
</p>
</div>

<p>
選択子の多くは、
`文書~言語@
（すなわち，文書~木の言語と意味論）の意味論に依存したり，
`~host言語@
（すなわち，選択子 構文を利用している言語）の意味論に依存する。
例えば、 `lang()$ps 選択子は、要素が自然言語にどう結び付けられるかを定義する際に，`文書~言語$（例： HTML ）に依存する。
少し異なる例として、 `first-line$pe 疑似要素は、それが何を表現し，それが表現するものに対し何ができるかを定義する際に，`~host言語$（例： CSS ）に依存する。
◎
Many of the selectors depend on the semantics of the document language
(i.e. the language and semantics of the document tree) and/or the semantics of the host language (i.e. the language that is using selectors syntax). For example, the :lang() selector depends on the document language (e.g. HTML) to define how an element is associated with a language. As a slightly different example, the ::first-line pseudo-element depends on the host language (e.g. CSS) to define what a ::first-line pseudo-element represents and what it can do.
</p>



		</section>
		<section id="scoping">
<h3 title="Scoped Selectors">3.3. 視野付き選択子</h3>

<p>
~host~appは、対象の範囲を文書の特定0の部分木, あるいは文書の一片†に絞る，
`視野付き選択子@
を採用することがある。
この部分木の根は
`視野根@
と呼ばれる††。
それは、“真の” 要素（
`視野要素@
と呼ばれる）であるか，
`~virtual@
のもの（ `DocumentFragment$I など）†††いずれかになる。
◎
Some host applications may choose to scope selectors to a particular subtree or fragment of the document. The root of the scoping subtree is called the scoping root, and may be either a true element (the scoping element) or a virtual one (such as a DocumentFragment).
</p>

<p class="trans-note">【†
`Document^I ~nodeの部分木でないもの（†††）も含め，根が `root$ps に合致しない要素~木
】【††
すなわち，対象の範囲を見渡す “視点”
】</p>

<p>
`視野付き$にされた選択子は、その`視野根$の子孫である要素のみに合致する。
（選択子の残りの部分に対する照合には制約はない
— 視野に入る必要があるのは、`選択対象$になる要素に限られる。）†
◎
When a selector is scoped, it matches an element only if the element is a descendant of the scoping root. (The rest of the selector can match unrestricted; it’s only the final matched elements that must be within the scope.)
</p>

<p class="trans-note">【†
すなわち、視野付きでない下で合致した要素たちを，`視野根$の子孫のみを残すように絞込む。
】</p>


<div class="example">
<p>
例えば， `DOM$r にて定義される要素~上の `querySelector()$c 関数では、作者は，選択子を，その要素による`視野付き$にする下で評価できる。
◎
For example, the element.querySelector() function defined in [DOM] allows the author to evalute a scoped selector relative to the element it’s called on.
</p>

<p>
`widget.querySelector("a")^c
の様な~callは、 `widget^e 要素の内側にある `a^e 要素のみを見出すことになる
— 文書~内に散らばっている他の `a^e 要素は無視して。
◎
A call like widget.querySelector("a") will thus only find a elements inside of the widget element, ignoring any other as that might be scattered throughout the document.
</p>

</div>

<p class="note">注記：
文脈において，選択子に対し`~scope_ps要素$が明示的に定義されていない場合、`視野根$が`~scope_ps要素$になる。
◎
Note: If the context does not explicitly define any :scope elements for the selector, the scoping root is a :scope element.
</p>


		</section>
		<section id="relative">
<h3 title="Relative Selectors">3.4. 相対~選択子</h3>

<p>
ある種の文脈~下では
`相対~選択子@
が受容される。
それは、ある `~scope_ps要素$（すなわち， `scope$ps に合致する要素<!-- またはvirtual？ -->）に相対的な要素を表現する選択子のための，一種の省略形である。
`相対~選択子$においては、 `scope$ps 疑似類がすでに伴われているものを除く，それぞれの`複体~選択子$の先頭に、暗黙的に "`:scope ^css" （ `scope$ps 疑似類と SPACE （子孫~結合子）の並び）が存在するものとみなされる。
これにより、選択子の構文は`結合子$（ `combinator$prod 生成規則）から開始できるようになる。
ただし，`相対~選択子$は、その照合処理の前に `絶対化$され~MUST。
◎
Certain contexts may accept relative selectors, which are a shorthand for selectors that represent elements relative to a :scope element (i.e. an element that matches :scope). In a relative selector, “:scope ” (the :scope pseudo-class followed by a space) is implied at the beginning of each complex selector that does not already contain the :scope pseudo-class. This allows the selector to begin syntactically with a combinator. However, it must be absolutized before matching.
</p>

<p class="trans-note">【
すなわち，“相対” は、`構造と各種用語§ 節にて定義される各種~選択子の階層~関係とは関係ない，並立する概念であり、従来の選択子を拡張するものである。
したがって、次節の`絶対化$は，従来の選択子も受容し、相対~選択子を受容する文脈は，従来の選択子も受容し得る。
例えば，相対~選択子を引数にとる `has()$ps は、その節の例に示されている様に，実際には従来の選択子も受容する。
】</p>

<p>
絶対化された`相対~選択子$は、追加で`視野付き$にもなり得る。
◎
Relative selectors, once absolutized, can additionally be scoped.
</p>

			<section id="absolutizing">
<h4 title="Absolutizing a Relative Selector">3.4.1. 相対~選択子の絶対化</h4>

<p>
【複体~選択子としての】
`相対~選択子$の
`絶対化@
は、次で与えられる：
◎
To absolutize a relative selector:
</p>

<ol>
	<li>
<p>
`~scope_ps要素$が不在, かつ
選択子が `~virtual$視野根により`視野付き$にされているならば：
◎
If there are no :scope elements and the selector is scoped to a virtual scoping root:
</p>

		<ol>
			<li>
選択子が`子~結合子$から開始されている場合、その`子~結合子$を除去する。
選択子は今や、追加の拘束
— 選択子の中の最初の`合体~選択子$は，親を持たない要素のみに合致するものとする
— を伴って、絶対的である。
◎
If the selector starts with a child combinator, remove the child combinator. The selector is now absolute, with the additional constraint that the first compound selector in the selector only matches elements without a parent.
</li>

			<li>
他の場合，選択子が［
空白~形による`子孫~結合子$
］でない`結合子$から開始されている場合、選択子を `not()$ps に変更する。
<span class="note">
これは、何にも合致しないことが保証される，妥当かつ最短の選択子になる。
</span>
◎
Otherwise, if the selector starts with any combinator other than the white space form of the descendant combinator, change the selector to :not(*). This is the shortest selector that is valid, but guaranteed to match nothing.
</li>

			<li>
他の場合、選択子はすでに絶対的である。
◎
Otherwise, the selector is already absolute.
</li>

		</ol>
	</li>

	<li>
<p>
他の場合：
◎
Otherwise:
</p>

		<ol>
			<li>
選択子が［
空白~形による`子孫~結合子$
］でない`結合子$から開始されている場合、その先頭に`合体~選択子$として `scope$ps を挿入する。
◎
If the selector starts with a combinator other than the white space form of the descendant combinator, prepend :scope as the initial compound selector.
</li>

			<li>
他の場合、選択子の［
~top-level, または`関数形~疑似類$に対する 1 個の引数
］において，【その先頭に】 `scope$ps 疑似類が与えられていない場合、その先頭に［
`scope$ps , ［
空白~形による`子孫~結合子$
］］の並びを挿入する。
◎
 Otherwise, if the selector does not contain any instance of the :scope pseudo-class (either at the top-level or as an argument to a functional pseudo-class), prepend :scope followed by the white space form of the descendant combinator.
</li>

			<li>
他の場合、選択子はすでに絶対的である。
◎
Otherwise, the selector is already absolute.
</li>

		</ol>
	</li>
</ol>

<p class="trans-note">【
実際には、上に述べた様に`絶対化$は，従来の選択子も受容する
— 既定の `~scope_ps要素$（文書の根~要素）の下では，実質的に恒等変換として働く。
】</p>


<p>
【選択子~listとしての】
`相対~選択子の~listを絶対化@
するときは、~list内の各 `相対~選択子$を絶対化する。

◎
To absolutize a relative selector list, absolutize each relative selector in the list.
</p>

			</section>
		</section>
		<section id="pseudo-classes">
<h3 title="Pseudo-classes">3.5. 疑似類</h3>

<p>
`疑似類@
は、文書~木の外側にある情報に基づく選択を, あるいは
他の`単体~選択子$を用いて表すには不便または不可能な選択ionを可能にするような，`単体~選択子$である。
疑似類は、文書~自身は変化しなくとも，［
利用者が文書とやりとりする間に，要素は疑似類を獲得したり, 失ったりし得る
］点で動的でもある。
`疑似類$は、［
文書~source／文書~木に現れたり，それを改変する
］ことはない。
◎
Pseudo-classes are simple selectors that permit selection based on information that lies outside of the document tree or that can be awkward or impossible to express using the other simple selectors. They can also be dynamic, in the sense that an element can acquire or lose a pseudo-class while a user interacts with the document, without the document itself changing. Pseudo-classes do not appear in or modify the document source or document tree.
</p>

<div class="p">
<p>
`疑似類$の構文は，次の並びで与えられる：
</p>

<ol>
	<li>
~colon ❝:
</li>
	<li>
`識別子$である，`疑似類$の名前
</li>
	<li>
`関数形~疑似類@
である場合は：
丸括弧で括られた 0 個以上の引数
</li>
</ol>

◎
The syntax of a pseudo-class consists of a ":" (U+003A COLON) followed by the name of the pseudo-class as a CSS identifier, and, in the case of a functional pseudo-class, a pair of parentheses containing its arguments.
</div>

<p class="example">
例えば、
`valid$ps は普通の疑似類であり,
`lang()$ps は`関数形~疑似類$である。
◎
For example, :valid is a regular pseudo-class, and :lang() is a functional pseudo-class.
</p>

<p>
すべての CSS ~keywordと同様に、`疑似類$の名前は `ASCII 文字大小無視$である。
~colonと`疑似類$の名前の間には，`空白$は許容されない。
また，通例の CSS 構文と同様、関数の名前と後続の開き括弧の間にも`空白$は許容されない（しがたって， CSS `function-token$t を形成する）。
通例の CSS 構文と同様、他から指定されない限り，関数形~疑似類の各~引数の周囲には，`空白$は許容される。
◎
Like all CSS keywords, pseudo-class names are ASCII case-insensitive. No white space is allowed between the colon and the name of the pseudo-class, nor, as usual for CSS syntax, between a functional pseudo-class’s name and its opening parenthesis (which thus form a CSS function token). Also as usual, white space is allowed around the arguments inside the parentheses of a functional pseudo-class unless otherwise specified.
</p>

<p>
`疑似類$は、他の`単体~選択子$と同様に，選択子に包含されるすべての`合体~選択子$において許容されるが、`型~選択子$, または`全称~選択子$（もし在れば）に後続し~MUST。
◎
Like other simple selectors, pseudo-classes are allowed in all compound selectors contained in a selector, and must follow the type selector or universal selector, if present.
</p>

<p class="note">注記：
`疑似類$には、互いに排他的になるものもある（それらを包含している`合体~選択子$は 妥当であるが，何にも合致しないことになる）。
他のものは，同じ要素に同時に適用し得る。
◎
Note: Some pseudo-classes are mutually exclusive (such that a compound selector containing them, while valid, will never match anything), while others can apply simultaneously to the same element.
</p>

		</section>


		<section id="pseudo-elements">
<h3 title="Pseudo-elements">3.6. 疑似要素</h3>

<p>
ある種の`疑似類$が，文書~木に直接的に現れない追加の状態~情報を表現するのと同様に、
`疑似要素@
は，文書~木に直接的に現れないような <em>要素</em> を表現する。
それらは、文書~言語が提供するものを超えるような，文書~木についての抽象化を創出するために利用される。
例えば、疑似要素を，文書~言語の要素に対応しないような文書の部位（要素~境界と揃わない範囲や，その木~構造の中に収まらないものも含め）を選択するために利用できる
— 例えば、［
文書~木に含まれない内容や，
文書~木を別形へ投影した内容
］を表現したり、あるいは，［
~style付け ／ ~layout ／ 利用者とのやりとり ／ その他，文書~木に反映されないような処理
］により提供される情報に依拠する。
◎
Similar to how certain pseudo-classes represent additional state information not directly present in the document tree, a pseudo-element represents an element not directly present in the document tree. They are used to create abstractions about the document tree beyond those provided by the document tree. For example, pseudo-elements can be used to select portions of the document that do not correspond to a document-language element (including such ranges as don’t align to element boundaries or fit within its tree structure); that represent content not in the document tree or in an alternate projection of the document tree; or that rely on information provided by styling, layout, user interaction, and other processes that are not reflected in the document tree.
</p>

<p class="trans-note">【
“疑似要素” という語は、この種の抽象的な要素をそのまま指すこともあれば，そのような要素を選択する選択子を指すこともある。
後者は、実際には， “疑似要素~選択子” の略称と考えられる。
】</p>


<div class="example">
<p>
例えば、文書~言語は，要素~内容の 初行の初字に~accessする仕組みを提供0しないが、それらにも~styleをあてがえるようにする`疑似要素$はある（
`first-letter$pe, `first-line$pe
）。
とりわけ， `first-line$pe の事例では、疑似要素が内容のどの部位を表現するかは，文書~木からは推定できない~layout情報に依存することに注意。
◎
For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content, but there exist pseudo-elements (::first-letter and ::first-line) that allow those things to be styled. Notice especially that in the case of ::first-line, which portion of content is represented by the pseudo-element depends on layout information that cannot be inferred from the document tree.
</p>

<p>
`疑似要素$は、任意の要素の前後に追加の内容を挿入する `before$pe, `after$pe 疑似要素など，文書に元から存在しないような内容も表現し得る。
◎
Pseudo-elements can also represent content that doesn’t exist in the source document at all, such as the ::before and ::after pseudo-elements which allow additional content to be inserted before or after the contents of any element.
</p>

</div>


<p>
`疑似類$と同様、`疑似要素$も，［
文書~source／文書~木
］内には現れず，それを改変することもない。
したがって疑似要素は、`構造上の疑似類$の解釈にも，［
疑似要素の［
`出自の要素$, または その木
］に該当するような，他の選択子
］の解釈にも影響しない。
◎
Like pseudo-classes pseudo-elements do not appear in or modify the document source or document tree. Accordingly, they also do not affect the interpretation of structural pseudo-classes or other selectors pertaining to their originating element or its tree.
</p>

<p>
~host言語は、［
どの疑似要素が存在し, その型は何で, どのような能を備えるか
］を定義する。
CSS に存在する疑似要素は、［
`CSS21$r （ Level 2 ）,
`SELECT$r （ Level 3 ）,
`CSS-PSEUDO-4$r （ Level 4 ）
］にて定義される。
◎
The host language defines which pseudo-elements exist, their type, and their abilities. Pseudo-elements that exist in CSS are defined in [CSS21] (Level 2), [SELECT] (Level 3), and [CSS-PSEUDO-4] (Level 4).
</p>

			<section id="pseudo-element_syntax">
<h4 title="Syntax">3.6.1. 構文</h4>

<p>
`疑似要素$の構文は，［
"`::^css" （ 2 個の ❝: ~colon）,
［
`識別子$である，`疑似要素$の名前
］］の並びで与えられる。
`疑似要素$の名前は， `ASCII 文字大小無視$である。
2 個の~colonの間や, ~colonと`疑似要素$の名前の間には，`空白$は許容されない。
◎
The syntax of a pseudo-element is "::" (two U+003A COLON characters) followed by the name of the pseudo-element as an identifier. Pseudo-element names are ASCII case-insensitive. No white space is allowed between the two colons, or between the colons and the name.
</p>


<p>
<a href="~TR/CSS1">CSS Level 1</a> ／
<a href="~CSS2" >CSS Level 2</a>
では、疑似要素と疑似類は，ともに 単独の~colonによる構文で一緒くたにされていたので、~UAは，以前の Level 1 ／ 2 疑似要素（
`before$pe,
`after$pe,
`first-line$pe,
`first-letter$pe
）に対しては，~colon 1 個による記法も受容し~MUST。
この，互換性のための記法は、他の疑似要素には許容されない。
この構文は非推奨にされたので、作者は，これらの疑似要素にも Level 3 以上の二重~colon構文を利用するべきである。
◎
Because CSS Level 1 and CSS Level 2 conflated pseudo-elements and pseudo-classes by sharing a single-colon syntax for both, user agents must also accept the previous one-colon notation for the Level 1 &amp; 2 pseudo-elements (::before, ::after, ::first-line, and ::first-letter). This compatibility notation is not allowed any other pseudo-elements. However, as this syntax is deprecated, authors should use the Level 3+ double-colon syntax for these pseudo-elements.
</p>

<p>
`疑似要素$は `無特能$であり、他のどの選択子にも合致し得ない。
◎
Pseudo-elements are featureless, and so can’t be matched by any other selector.
</p>

			</section>
			<section id="pseudo-element-attachment">
<h4 title="Binding to the Document Tree">3.6.2. 文書~木への束縛法</h4>

<p>
`疑似要素$は，木~内に独立して存在することはない
— それは常に、その
`出自の要素@
と呼ばれる，頁~上の別の要素に束縛される。
構文的には、`疑似要素$は，その`出自の要素$を表現している`合体~選択子$の直後に続く。
この`合体~選択子$が省略された場合、それは，`全称~選択子$ `*^S であるものと見做される。
◎
Pseudo-elements do not exist independently in the tree: they are always bound to another element on the page, called their originating element. Syntactically, a pseudo-element immediately follows the compound selector representing its originating element. If this compound selector is omitted, it is assumed to be the universal selector *.
</p>

<div class="example">
<p>
例えば、選択子 `div a::before^S において，頭部の選択子に合致する `a^e 要素は、~~付随する `before$pe 疑似要素に対する`出自の要素$になる。
◎
For example, in the selector div a::before, the a elements matched by the selector are the originating elements for the ::before pseudo-elements attached to them.
</p>

<p>
選択子 `::first-line^S は，`*::first-line^S に等価であり、文書~内の各 要素<em>ごとに</em>，その `first-line$pe 疑似要素を選択する。
◎
The selector ::first-line is equivalent to *::first-line, which selects the ::first-line pseudo-element on every element in the document.
</p>
</div>


<p>
`疑似要素$ ~S を含んでいる選択子においては、選択子の中の
~S より前の部分が， ~S に対する`出自の要素$を選択し、
~S より後の部分があるならば，それは ~S 自身に適用される（次節を見よ）。
◎
When a pseudo-element is encountered in a selector, the part of the selector before the pseudo-element selects the originating element for the pseudo-element; the part of the selector after it, if any, applies to the pseudo-element itself. (See below.)
</p>


			</section>
			<section id="pseudo-element-states">
<h4 title="Pseudo-classing Pseudo-elements">3.6.3. 疑似要素に対する疑似類による絞り込み</h4>

<p>
`疑似要素$には、その直後に
`利用者~動作 疑似類§の任意の組合せが続いていてもよい
— その事例では、`疑似要素$は，それらの疑似類に対応する状態にあるときにのみ，表現される。
これらの疑似類が その`疑似要素$上でも合致し得るかどうかは、当の
`疑似類$と`疑似要素$
の定義に依存する
— 他から指定されない限り，これらの`疑似類$は，`疑似要素$上で合致することはない。
◎
A pseudo-element may be immediately followed by any combination of the user action pseudo-classes, in which case the pseudo-element is represented only when it is in the corresponding state. Whether these pseudo-classes can match on the pseudo-element depends on the pseudo-class and pseudo-element”s definitions: unless otherwise-specified, none of these pseudo-classes will match on the pseudo-element.
</p>


<p class="issue">
上に示した疑似類を包含しているときも
`not()$ps, `matches()$ps
を利用できるのかどうか，はっきりさせる。
◎
Clarify that :not() and :matches() can be used when containing abovementioned pseudos.
</p>

<div class="example">
<p>
例えば、 `hover$ps 疑似類は，どの`疑似要素$にも適用し得るものと指定されているので、
`::first-line:hover^S
は，初行~上に~hoverされたときに合致することになる。
一方で、
`focus$ps, `first-line$pe
のいずれも［
`first-line$pe に `focus$ps を適用し得る
］ものと定義されてはいないので、選択子 `::first-line:focus^S に合致するものは，決してないことになる。
◎
For example, since the :hover pseudo-class specifies that it can apply to any pseudo-element, ::first-line:hover will match when the first line is hovered. However, since neither :focus nor ::first-line define that :focus can apply to ::first-line, the selector ::first-line:focus will never match anything.
</p>

<p class="issue">
`::first-line:not(:focus)^S
は，何にでも合致するのか？
◎
Does ::first-line:not(:focus) match anything?
</p>

<p>
`::first-line:hover^S と `:hover::first-line^S とは、かなり異なることに注意。
後者は、~hoverされた どの`出自の要素$に対しても，その初行に合致する。
例えば,
`:hover::first-line^S
は，段落の二行目に~hoverされたときでも，段落の初行に合致する一方で、
`::first-line:hover^S
は，初行~自身に~hoverされたときにのみ合致する。
◎
Notice that ::first-line:hover is is very different from :hover::first-line, which matches the first line of any originating element that is hovered! For example, :hover::first-line also matches the first line of a paragraph when the second line of the paragraph is hovered, whereas ::first-line:hover only matches if the first line itself is hovered.
</p>
</div>

<p class="note">注記：
将来の仕様から指定されない限り，
`利用者~動作 疑似類§
以外の疑似類は、疑似要素と~~複合されたときには，有効でなくなるので、例えば
`::before:first-child^S
は，`無効な選択子$になる。
◎
Note: Note that, unless otherwise specified in a future specification, pseudo-classes other than the user action pseudo-classes are not valid when compounded to a pseudo-element; so, for example, ::before:first-child is an invalid selector.
</p>


			</section>
			<section id="pseudo-element-structure">
<h4 title="Internal Structure">3.6.4. 内部~構造</h4>

<p>
一部の`疑似要素$は、内部~構造を持つものと定義されている。
その種の`疑似要素$には，その関係性を表すために［
`子~結合子$／`子孫~結合子$
］が後続していてもよい。
他の疑似要素については、`結合子$が後続するものは `無効な選択子$になる。
◎
Some pseudo-elements are defined to have internal structure. These pseudo-elements may be followed by child/descendant combinators to express those relationships. Selectors containing combinators after the pseudo-element are otherwise invalid.
</p>

<div class="example">
<p>
例えば、
`::first-letter + span^S,
`::first-letter em^S
は，いずれも無効な選択子になる。
しかしながら、 `:shadow$ps は，内部~構造を持つものと定義されているため、
`::shadow &gt; p^S
は，選択子として有効になる。
◎
For example, ::first-letter + span and ::first-letter em are invalid selectors. However, since ::shadow is defined to have internal structure, ::shadow &gt; p is a valid selector.
</p>

</div>

<p class="note">注記：
既存の疑似要素の能力が，将来の仕様により拡張0されることもあるので、現在は無効でも（例 `::first-line :any-link^S ），未来には有効になるものは，あり得る。
◎
Note: A future specification may expand the capabilities of existing pseudo-elements, so some of these currently-invalid selectors (e.g. ::first-line :any-link) may become valid in the future.
</p>


<p>
そのような`疑似要素$の子たちは，同時に他の要素の子にもなり得るので、`選択子~照合~list$を有向循環~graphに転換し得る。
しかしながら、それらの具現化は，`~box木$の木~構造たる部分は維持される様に定義され~MUST。
◎
The children of such pseudo-elements can simultaneously be children of other elements, too, turning the selector match list into a directed acyclic graph. However, at least in CSS, their rendering must be defined so as to maintain the tree-ness of the box tree.
</p>

<div class="example">
<p>
例えば， `content^pe 疑似要素†は、そこへ distribute<!-- ＊ -->される要素をその一連の子として扱う。
<span class="trans-note">【†
`slotted$pe に改称された。
】</span>
すなわち、次の~code片が与えられたとするとき：
◎
For example, the ::content pseudo-element treats elements distributed to it as its children. This means that, given the following fragment:
</p>

<pre>&lt;div&gt;
  &lt;span&gt;foo&lt;/span&gt;
  &lt;"shadow root"&gt;
    &lt;content&gt;&lt;/content&gt;
  &lt;/"shadow root"&gt;
&lt;/div&gt;
</pre>

<p>
選択子 `div &gt; span^S と `div::shadow ::content &gt; span^S が、同じ要素を，異なる~pathを介して選択することを意味する。
◎
the selectors div &gt; span and div::shadow ::content &gt; span select the same element via different paths.
</p>

<p>
しかしながら、具現化-時には，`~box木$の木~構造が維持されるように、 `span^e 要素は， `div^e 要素ではなく `content^e 要素の子であったかの様に，~boxを生成する。
◎
However, when rendered, the &lt;span&gt; element generates boxes as if it were the child of the &lt;content&gt; element, rather than the &lt;div&gt; element, so the tree structure of the box tree is maintained.
</p>
</div>

			</section>
		</section>
		<section id="case-sensitive">
<h3 title="Characters and case sensitivity">3.7. 文字大小の区別</h3>

<p>
すべての Selectors 構文は、その制御~下にない次の部分を除いて， ASCII 範囲の中で文字の大小は区別されない（すなわち， "a" 〜 "z" と "A" 〜 "Z" は対応する文字が同一視される）：
文書~言語の［
要素名／属性名／属性値
］における文字大小の区別は，文書~言語に依存する。
◎
All Selectors syntax is case-insensitive within the ASCII range (i.e. [a-z] and [A-Z] are equivalent), except for the following parts, which are not under the control of Selectors: the case-sensitivity of document language element names, attribute names, and attribute values depends on the document language.
</p>

<div class="example">
<p>
例えば HTML の下では，要素名と属性名は
<a href="~HTML5/selectors.html#case-sensitivity">ASCII 文字大小無視</a>
であるが、 XML の下では，文字大小は区別される。
◎
For example, in HTML, element and attribute names are ASCII case-insensitive, but in XML, they are case-sensitive.
</p>
</div>

<p>
名前空間 接頭辞の文字大小の区別については `CSS3NAMESPACE$r にて定義される。
`言語範囲$の文字大小の区別は `lang()$ps 節にて定義される。
◎
Case sensitivity of namespace prefixes is defined in [CSS3NAMESPACE]. Case sensitivity of language ranges is defined in the :lang() section.
</p>

<div class="p">

<p>
Selectors における
`空白@
とは、次の符号位置のみからなる，（空でない）文字列である：
</p>

<ul>
	<li>
SPACE `0020^cp
</li>
	<li>
TAB `0009^cp
</li>
	<li>
LINE FEED `000A^cp
</li>
	<li>
CARRIAGE RETURN `000D^cp
</li>
	<li>
FORM FEED `000C^cp
</li>
</ul>

<p>
空白に似た他の符号位置
— 例えば EM SPACE `2003^cp や IDEOGRAPHIC SPACE `3000^cp —
は，決して`空白$の一部にはならない。
</p>
◎
White space in Selectors consists of the code points SPACE (U+0020), TAB (U+0009), LINE FEED (U+000A), CARRIAGE RETURN (U+000D), and FORM FEED (U+000C) can occur in whitespace. Other space-like code points, such as EM SPACE (U+2003) and IDEOGRAPHIC SPACE (U+3000), are never part of white space.
</div>

<p>
Selectors における符号位置は、 CSS2 の`~escape処理規則$ `CSS21$r に則って，~backslash ❝\ により~escapeできる。
文字~escape処理は， Selectors の中でその文字が持ち得る特別な意味を “取り消す”ことに注意。
例えば，選択子
`#foo&gt;a^css
は`結合子$を包含しているが、
`#foo\&gt;a^css
は 代わりに ID "`foo&gt;a^s" の要素を選択する。
◎
Code points in Selectors can be escaped with a backslash according to the same escaping rules as CSS. [CSS21] Note that escaping a code point "cancels out" any special meaning it may have in Selectors. For example, the selector #foo&gt;a contains a combinator, but #foo\&gt;a instead selects an element with the id foo&gt;a.
</p>

		</section>
		<section id="namespaces">
<h3 title="Declaring Namespace Prefixes">3.8. 名前空間 接頭辞の宣言法</h3>

<p>
一部の選択子は，名前空間 接頭辞を~supportする。
名前空間 接頭辞を
`宣言-@
する仕組みは、 Selectors を利用する言語により指定されるべきである。
言語が名前空間 接頭辞の宣言の仕組みを指定しない場合、いかなる接頭辞も宣言されない。
CSS においては、名前空間 接頭辞は
<a href="~CSSNS#declaration"><code class="css">@namespace</code></a>
規則 `CSS3NAMESPACE$r により宣言される。
◎
Certain selectors support namespace prefixes. The mechanism by which namespace prefixes are declared should be specified by the language that uses Selectors. If the language does not specify a namespace prefix declaration mechanism, then no prefixes are declared. In CSS, namespace prefixes are declared with the @namespacerule. [CSS3NAMESPACE]
</p><!-- ＊namespacerule -->

		</section>
		<section id="invalid">
<h3 title="Invalid Selectors and Error Handling">3.9. 無効な選択子と~errorの取扱い</h3>

<p>
~UA は、以下に与える
`無効な選択子@
（ “妥当でない” 選択子）を取扱うための~~規則に従わ~MUST：
◎
User agents must observe the rules for handling invalid selectors:
</p>

<ul>
	<li>
選択子における構文解析-~error
— 例えば，認識されない~tokenや, 構文解析のある地点にて許容されない~token —
は、当該の選択子を無効にする。
◎
a parsing error in a selector, e.g. an unrecognized token or a token which is not allowed at the current parsing point, causes that selector to be invalid.
</li>

	<li>
`未宣言$の名前空間 接頭辞を包含している`単体~選択子$は、無効である。
◎
a simple selector containing an undeclared namespace prefix is invalid
</li>

	<li>
無効な［
`単体~選択子$／`結合子$／~token
］を包含している選択子は無効である。
◎
a selector containing an invalid simple selector, an invalid combinator or an invalid token is invalid.
</li>

	<li>
無効な選択子を包含している`選択子~list$は無効である。
◎
a selector list containing an invalid selector is invalid.
</li>

	<li>
空の選択子
— すなわち，`合体~選択子$を包含しないもの —
は、無効である。
◎
an empty selector, i.e. one that contains no compound selector, is invalid.
</li>

</ul>

<p>
`無効な選択子$は、空集合を表現し，何にも合致しない。
◎
An invalid selector represents, and therefore matches, nothing.
</p>

		</section>
	</section>
	<section id="logical-combination">
<h2 title="Logical Combinations">4. 論理的な組合せ</h2>

		<section id="grouping">
<h3 title="Selector Lists">4.1. 選択子~list</h3>

<p>
~comma（ ❝, ）で区切られた選択子の~list
— `選択子~list$ —
は、その中のそれぞれの`複体~選択子$により個別に選択された要素すべての和集合を表現する。
例えば CSS においては、いくつかの選択子が同じ宣言を共有するときに，それらが~comma区切りの~listに~group化されてもよい。
~commaの前後には，`空白$が現れてもよい。
◎
A comma-separated list of selectors represents the union of all elements selected by each of the individual selectors in the selector list. (A comma is U+002C.) For example, in CSS when several selectors share the same declarations, they may be grouped into a comma-separated list. White space may appear before and/or after the comma.
</p>

<p class="trans-note">【
“選択子~list（ selector list ）” は， Selectors Level 3 までの “選択子の~group （ groups of selectors ）” に該当する（順序を含意する “~list” に改称されたのは、CSSOM などの仕様にて選択子の処理~model（直列化）を規定する際に，この名称の方が適切なためと見られる）。
】</p>

<div class="example">
<p>
宣言が互いに一致する３つの規則を一つにまとめることを考える：
◎
CSS example: In this example, we condense three rules with identical declarations into one. Thus,
</p>

<pre>
h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>

<p>
これは、次と等価になる：
◎
is equivalent to:
</p>

<pre>h1, h2, h3 { font-family: sans-serif }</pre>

</div>

<p>
<strong>注意</strong>:
この例では，すべての選択子が妥当なので等価性が成り立つが、これらのうち一つでも無効なものがあった場合，`選択子~list$全体が無効になる。
後者の書き方の場合，３つの見出し要素すべてに対する規則が無効にされることになる一方、前者の書き方の場合，個別的に無効にされることになる。
◎
Warning: the equivalence is true in this example because all the selectors are valid selectors. If just one of these selectors were invalid, the entire selector list would be invalid. This would invalidate the rule for all three heading elements, whereas in the former case only one of the three individual heading rules would be invalidated.
</p>

<div class="example">
<p>
無効な CSS の例：
◎
Invalid CSS example:
</p>

<pre>
h1 { font-family: sans-serif }
h2..foo { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>

<p>
は、次と等価ではない：
◎
is not equivalent to:
</p>

<pre>h1, h2..foo, h3 { font-family: sans-serif }</pre>

<p>
上の選択子（ `h1, h2..foo, h3^S ）は全体として無効であり，~style規則~全体が取り除かれるので。
（選択子が~group化されていなければ、 `h2..foo^css に対する規則のみが取り除かれる。）
◎
because the above selector (h1, h2..foo, h3) is entirely invalid and the entire style rule is dropped. (When the selectors are not grouped, only the rule for h2..foo is dropped.)
</p></div>

		</section>
		<section id="matches">
<h3 title="The Matches-any Pseudo-class: :matches()">4.2. 論理和 疑似類	`matches()^ps</h3>

<p>
論理和（ “matches-any” ） 疑似類
`matches()@ps
は、`選択子~list$を引数にとる`関数形~疑似類$である。
それは
その引数で表現される要素を表現する。
◎
The matches-any pseudo-class, :matches(), is a functional pseudo-class taking a selector list as its argument. It represents an element that is represented by its argument.
</p>

<p>
疑似要素は，論理和 疑似類では表現し得ない
— それらは `matches()$ps の中では妥当でない。
◎
Pseudo-elements cannot be represented by the matches-any pseudo-class; they are not valid within :matches().
</p>

<p>
既定の名前空間~宣言は、
`matches()$ps 疑似類【の引数】の中のどの選択子に対しても，その`選択対象$を表現している`合体~選択子$には，それが［
明示的に［
`全称~選択子$ ／ `型~選択子$
］を包含してる場合
］を除き，影響しない。
◎
Default namespace declarations do not affect the compound selector representing the subject of any selector within a :matches() pseudo-class, unless that compound selector contains an explicit universal selector or type selector.
</p>


<div class="example">
<p>
次の選択子は、名前空間を問わず，
~hover／~focus
された任意の要素に合致する。
したがって その照合処理は、既定の名前空間に属する要素のみに限定されない。
◎
For example, the following selector matches any element that is being hovered or focused, regardless of its namespace. In particular, it is not limited to only matching elements in the default namespace that are being hovered or focused.
</p>

<pre>*|*:matches(:hover, :focus)</pre>

<p>
一方で次の選択子は、~hover／~focusされた要素のうち，既定の名前空間に属するもののみを表現する【既定の名前空間は宣言-済みとする】。
`matches()$ps 記法の中で明示的に`全称~選択子$が用いられているので：
◎
The following selector, however, represents only hovered or focused elements that are in the default namespace, because it uses an explicit universal selector within the :matches() notation:
</p>

<pre>*|*:matches(*:hover, *:focus)</pre>

</div>

		</section>
		<section id="negation">
<h3 title="The Negation Pseudo-class: :not()">4.3. 否定~疑似類	`not()^ps</h3>

<p>
否定~疑似類
`not()@ps
は、`選択子~list$を引数にとる`関数形~疑似類$である。
それは，その引数で表現されない要素を表現する。
◎
The negation pseudo-class, :not(), is a functional pseudo-class taking a selector list as an argument. It represents an element that is not represented by its argument.
</p>

<p class="note">注記：
Selectors Level 3 においては、単独の`単体~選択子$のみが `not()$ps の引数に許容されていた。
◎
Note: In Selectors Level 3, only a single simple selector was allowed as the argument to :not().
</p>

<p>
`疑似要素$は否定~疑似類では表現し得ない
— それらは `not()$ps の中では妥当でない。
◎
Pseudo-elements cannot be represented by the negation pseudo-class; they are not valid within :not().
</p>

<div class="example">
<p>
次の選択子は， HTML 文書の中で操作不可にされていないすべての
`button^e 要素に合致する。
◎
For example, the following selector matches all button elements in an HTML document that are not disabled.
</p>

<pre>button:not([DISABLED])</pre>

<p>
次の選択子は
`FOO^e 要素~以外のすべてを表現する：
◎
The following selector represents all but FOO elements.
</p>

<pre>*:not(FOO)</pre>

<p>
次の`合体~選択子$は、
~link以外のすべての HTML 要素【 HTML 名前空間に属する要素】を表現する。
◎
The following compound selector represents all HTML elements except links.
</p>

<pre>html|*:not(:link):not(:visited)</pre>

</div>

<p>
`matches()$ps に対するときと同様に，既定の名前空間~宣言は、
`not()$ps 疑似類の中のどの選択子に対しても，その`選択対象$を表現している`合体~選択子$には，それが明示的に［
`全称~選択子$ ／ `型~選択子$
］を包含している場合を除き，影響しない（ `matches()$ps の例を見よ）。
◎
As with :matches(), default namespace declarations do not affect the compound selector representing the subject of any selector within a :not() pseudo-class, unless that compound selector contains an explicit universal selector or type selector. (See :matches() for examples.)
</p>

<p class="note">注記：
`not()$ps 疑似類を用いれば “無用な” 選択子も記せる。
例えば `:not(*|*)^S は、どの要素も表現しない。
あるいは `div:not(span)^S は、`詳細度$がより高くなることを除いて， `div^S と等価になる。
◎
Note: The :not() pseudo-class allows useless selectors to be written. For instance :not(*|*), which represents no element at all, or div:not(span), which is equivalent to div but with a higher specificity.
</p>

		</section>
		<section id="relational">
<h3 title="The Relational Pseudo-class: :has()">4.4. 関係上の疑似類： `has()^ps</h3>

<p>
関係上の疑似類
`has()@ps
は、`相対~選択子$による`選択子~list$を引数にとる`関数形~疑似類$である。
それは、次を満たす 要素 ~E を表現する：
<span class="block">
選択子~listの中のいずれかの`相対~選択子$ ~S について、
~E を`~scope_ps要素$とした下で， ~S を`絶対化$した上で, `評価-$したときに，合致する要素が存在する。
</span>
◎
The relational pseudo-class, :has(), is a functional pseudo-class taking a relative selector list as an argument. It represents an element if any of the relative selectors, when absolutized and evaluated with the element as the :scope elements, would match at least one element.
</p>

<div class="example">
<p>
例えば、次の選択子は， `img^e を子に持つ `a^e 要素のみに合致する：
◎
For example, the following selector matches only &lt;a&gt; elements that contain an &lt;img&gt; child:
</p>


<pre>a:has(&gt; img)</pre>

<p>
次の選択子は，別の `dt^e 要素が直後に続く `dt^e 要素に合致する：
◎
The following selector matches a &lt;dt&gt; element immediately followed by another &lt;dt&gt; element:
</p>

<pre>dt:has(+ dt)</pre>

<p>
次の選択子は、見出し要素を包含しない `section^e 要素に合致する：
◎
The following selector matches &lt;section&gt; elements that don’t contain any heading elements:
</p>

<pre>section:not(:has(h1, h2, h3, h4, h5, h6))</pre>

<p>
上の選択子における順序は重要であることに注意。
2 つの疑似類の入子を次の様に入れ替えた場合：
◎
Note that ordering matters in the above selector. Swapping the nesting of the two pseudo-classes, like:
</p>

<pre>section:has(:not(h1, h2, h3, h4, h5, h6))</pre>

<p>
見出し要素でない何らかの要素を包含するような，どの `section^e 要素にも合致することになる。
◎
...would result matching any &lt;section&gt; element which contains anything that’s not a header element.
</p>

</div>

		</section>
	</section>
	<section id="elemental-selectors">
<h2 title="Elemental selectors">5. 基本的な選択子</h2>

		<section id="type-selectors">
<h3 title="Type (tag name) selector">5.1. 型（~tag名）選択子</h3>

<p>
`型~選択子@
は、文書~言語の要素型の名前であり，文書~木における その要素型の~instanceを表現する。
◎
A type selector is the name of a document language element type, and represents an instance of that element type in the document tree.
</p>

<p class="example">
例えば 選択子 `h1^S は、文書~内の `h1^e 要素を表現する。
◎
For example, the selector h1 represents an h1 element in the document.
</p>

<p>
`型~選択子$は、 `CSS 有修飾名$
— 任意選択で名前空間 接頭辞も伴うような，`識別子$ —
として記される。
`CSS3NAMESPACE$r
（`基本的な選択子における名前空間§ 節を見よ。）
◎
A type selector is written as a CSS qualified name: an identifier with an optional namespace prefix. [CSS3NAMESPACE] (See §5.3 Namespaces in Elemental Selectors.)
</p>

		</section>
		<section id="the-universal-selector">
<h3 title="Universal selector">5.2. 全称~選択子</h3>

<p>
`全称~選択子@
は、特別な`型~選択子$であり，どの要素型の要素も表現する。
◎
The universal selector is a special type selector, that represents an element of any element type.
</p>

<p>
それは、 局所名として 1 個の~asterisk（ ❝* ）を伴う `CSS 有修飾名$として記される。
`型~選択子$と同様に，`全称~選択子$も、ある名前空間に属する要素のみに制約するように，名前空間で修飾でき、`基本的な選択子における名前空間§ 節にて定義されるように，既定の名前空間に影響される。
◎
It is written a CSS qualified name with an asterisk (* U+002A) as the local name. Like a type selector, the universal selector can be qualified by a namespace, restricting it to only elements belonging to that namespace, and is affected by a default namespace as defined in §5.3 Namespaces in Elemental Selectors.
</p>

<p>
要素が`無特能$でない限り，`全称~選択子$の存在は，［
要素が選択子に合致するかどうか
］に効果を持たない。
（`無特能$の要素は，`全称~選択子$も含め どの選択子にも合致しない。）
◎
Unless an element is featureless, the presence of a universal selector has no effect on whether the element matches the selector. (Featureless elements do not match any selector, including the universal selector.)
</p>

<div class="example">

<ul>
	<li>
`*[hreflang|=en]^S
と
`[hreflang|=en]^S
は等価。
◎
*[hreflang|=en] and [hreflang|=en] are equivalent,
</li>

	<li>
`*.warning^S
と
`.warning^S
は等価。
◎
*.warning and .warning are equivalent,
</li>

	<li>
`*#myid^S
と
`#myid^S
は等価。
◎
*#myid and #myid are equivalent.
</li></ul>

</div>

<p>
`全称~選択子$は，他の`型~選択子$と同じ構文~規則に従う：
`合体~選択子$においては、それは，高々 1 回まで, かつ最初の`単体~選択子$として現れ~MUST。
◎
The universal selector follows the same syntax rules as other type selectors: only one can appear per compound selector, and it must be the first simple selector in the compound selector.
</p>

<p class="note">注記：
照合処理の挙動には効果を持たなくとも、`全称~選択子$を追加すれば，選択子は読み易くなることがある。
例えば `div :first-child^S は `div:first-child^S に見誤り易い。
`div *:first-child^S の方が違いが明白になる。
◎
Note: In some cases, adding a universal selector can make a selector easier to read, even though it has no effect on the matching behavior. For example, div :first-child and div:first-child are somewhat difficult to tell apart at a quick glance, but writing the former as div *:first-child makes the difference obvious.
</p>



		</section>
		<section id="type-nmsp">
<h4 title="Namespaces in Elemental Selectors">5.3. 基本的な選択子における名前空間</h4>

<p>
［
`型~選択子$／`全称~選択子$
］には，任意選択で名前空間~成分も許容される。
すなわち，要素名には、すでに`宣言-$済みの名前空間 接頭辞が，名前空間~区切子
❝| 
で区切られた上で 前置されてよい。
それは、各 形に応じて，次の意味を持つ：
◎
Type selectors and universal selectors allow an optional namespace component: a namespace prefix that has been previously declared may be prepended to the element name separated by the namespace separator “vertical bar” (| U+007C). (See, e.g., [XML-NAMES] for the use of namespaces in XML.) It has the following meaning in each form:
</p>


<dl>
	<dt><code class="css">%ns|~E</code></dt>
	<dd>
名前空間 %ns に属するような，名前 ~E の要素
◎
elements with name E in namespace ns
</dd>

	<dt>`*|~E^css</dt>
	<dd>
どの名前空間にも属さないものも含め, 任意の名前空間に属するような，名前 ~E の要素
◎
elements with name E in any namespace, including those without a namespace
</dd>

	<dt>`|~E^css</dt>
	<dd>
どの名前空間にも属さない，名前 ~E の要素
◎
elements with name E without a namespace
</dd>

	<dt>`~E^css</dt>
	<dd>
`既定の名前空間$が`宣言-$されていない場合、これは `*|~E^css に等価になる。
他の場合、%ns を既定の名前空間とするときの <code class="css">%ns|~E</code> に等価になる。
◎
if no default namespace has been declared for selectors, this is equivalent to *|E. Otherwise it is equivalent to ns|E where ns is the default namespace.
</dd>
</dl>

<div class="example">
<p>
次の CSS において：
◎
CSS examples:
</p>

<pre>
@namespace foo url(http://www.example.com);
foo|h1 { color: blue }  /* 規則 1 */
foo|* { color: yellow } /* 規則 2 */
|h1 { color: red }      /* 規則 3 */
*|h1 { color: green }   /* 規則 4 */
h1 { color: green }     /* 規則 5 */</pre>

<p>
規則 1 は
名前空間 "<samp>http://www.example.com</samp>"
に属する `h1^e 要素のみに合致することになる。
◎
The first rule (not counting the @namespace at-rule) will match only h1 elements in the "http://www.example.com" namespace.
</p>

<p>
規則 2 は
名前空間 "<samp>http://www.example.com</samp>"
に属するすべての要素に合致することになる。
◎
The second rule will match all elements in the "http://www.example.com" namespace.
</p>

<p>
規則 3 は、どの名前空間にも属さない `h1^e 要素のみに合致することになる。
◎
The third rule will match only h1 elements with no namespace.
</p>

<p>
規則 4 は、（どの名前空間に属さないものも含む）任意の名前空間の
`h1^e 要素に合致することになる。
◎
The fourth rule will match h1 elements in any namespace (including those without any namespace).
</p>

<p>
規則 5 は、既定の名前空間が定義されていないので，規則 4 に等価になる。
◎
The last rule is equivalent to the fourth rule because no default namespace has been defined.
</p>

</div>


<p>
`型~選択子$を含まない`合体~選択子$は、`既定の名前空間$が宣言されている下では，依然として 既定の名前空間に属する要素のみに合致する。
◎
If a default namespace is declared, compound selectors without type selectors in them still only match elements in that default namespace.
</p>

<div class="example">
<p>
例えば，次の~stylesheetに対しては：
◎
For example, in the following stylesheet:
</p>

<pre>
@namespace url("http://example.com/foo");
.special { ... }
</pre>

<p>
選択子 `.special^S は、（ DOM においては名前空間と対にされる）型~名への参照が現れていないが，名前空間 "`http://example.com/foo^s" に属する要素にのみ合致する。
◎
The .special selector only matches elements in the "http://example.com/foo" namespace, even though no reference to the type name (which is paired with the namespace in the DOM) appeared.
</p>

</div>

<p>
`未宣言$の名前空間 接頭辞を伴うような［
`型~選択子$／`全称~選択子$
］は、`無効な選択子$である。
◎
A type selector or universal selector containing a namespace prefix that has not been previously declared is an invalid selector.
</p>




		</section>
	</section>
	<section id="attribute-selectors">
<h2 title="Attribute selectors">6. 属性~選択子</h2>

<p>
Selectors では，要素の属性の表現も許容される。
選択子が要素に対し合致する式として用いられるとき、
`属性~選択子@
は、その要素がその属性~選択子で表現される属性に合致する属性を持つとき，その要素に合致するものと見なされ~MUST。
◎
Selectors allow the representation of an element’s attributes. When a selector is used as an expression to match against an element, an attribute selector must be considered to match an element if that element has an attribute that matches the attribute represented by the attribute selector.
</p>

<p class="issue">
<a href="http://lists.w3.org/Archives/Public/www-style/2011Mar/0215.html">複数個の値の照合処理</a>
のために~comma区切りの構文を追加するか？
例えば， `[rel ~=next, prev, up, first, last]^S
◎
Add comma-separated syntax for multiple-value matching? e.g. [rel ~= next, prev, up, first, last]
</p>

		<section id="attribute-representation">
<h3 title="Attribute presence and value selectors">6.1. 属性存在／属性値 選択子</h3>

<p>
CSS2 では４種の`属性~選択子$が導入されている：
◎
CSS2 introduced four attribute selectors:
</p>

<dl>
	<dt><code class="css">[`att^a]</code></dt>
	<dd>
`att^a 属性【名前が "att" である属性】を伴うような要素を表現する。
属性の値は問わない。
◎
Represents an element with the att attribute, whatever the value of the attribute.
</dd>

	<dt><code class="css">[`att^a=%val]</code></dt>
	<dd>
値が %val 【が表現する文字列】に一致する `att^a 属性を伴うような要素を表現する。
◎
Represents an element with the att attribute whose value is exactly "val".
</dd>

	<dt><code class="css">[`att^a~=%val]</code></dt>
	<dd>
［
値を`空白$で区切って得られる単語~listのいずれかの単語に %val が一致する
］`att^a 属性を伴うような要素を表現する。
%val に`空白$が含まれている場合、何も表現しないことになる（単語は`空白$で<em>区切られる</em>ので）。
%val が空文字列の場合も，何も表現しないことになる。
◎
Represents an element with the att attribute whose value is a whitespace-separated list of words, one of which is exactly "val". If "val" contains whitespace, it will never represent anything (since the words are separated by spaces). Also if "val" is the empty string, it will never represent anything.
</dd>

	<dt><code class="css">[`att^a|=%val]</code></dt>
	<dd>
［
値が %val に一致するか, または
値の先頭が［ %val, ❝- ］の並びである
］ `att^a 属性を伴うような要素を表現する。
これは主に BCP 47 （ `BCP47$r ） またはその後継版の言語~subcodeに合致させる用途が意図されている（例えば  HTML の `a^e 要素の `hreflang^a 属性）。
`lang^a 属性（または `xml:lang^a 属性）に対する言語~subcode合致については `lang()$ps を見よ。
【~subcode — いわゆる下位tag（ subtag ）？あるいはそれに同等／代わるもの？】
◎
Represents an element with the att attribute, its value either being exactly "val" or beginning with "val" immediately followed by "-" (U+002D). This is primarily intended to allow language subcode matches (e.g., the hreflang attribute on the a element in HTML) as described in BCP 47 ([BCP47]) or its successor. For lang (or xml:lang) language subcode matching, please see the :lang pseudo-class.
</dd></dl>

<p>
属性値に照合される %val は、
`ident-token$t または `string-token$t
として与えられ~MUST。
`CSS3SYN$r
<span class="trans-note">【
CSS 識別子（前者）の条件を満たさない~~一般の文字列は、引用符で括る（後者）必要がある。
】</span>
◎
Attribute values must be &lt;ident-token&gt;s or &lt;string-token&gt;s. [CSS3SYN]
</p>

<div class="example">
<p lang="en">Examples:</p>

<p>
次の`属性~選択子$は、
`title^a 属性を伴う `h1^e 要素を表現する。
属性の値は問わない：
◎
The following attribute selector represents an h1 element that carries the title attribute, whatever its value:
</p>

<pre>h1[`title^a]</pre>

<p>
次の例の選択子は、 `class^a 属性の値が "`example^s" に一致する `span^e 要素を表現する：
◎
In the following example, the selector represents a span element whose class attribute has exactly the value "example":
</p>

<pre>span[`class^a="example"]</pre>

<p>
複数の`属性~選択子$を用いれば、要素の複数の属性, あるいは同じ属性に対する複数の条件を表現できる。
次の選択子は、
`hello^a 属性値が "`Cleveland^s" に一致し, かつ
`goodbye^a 属性値が "`Columbus^s" に一致するような，
`span^e 要素を表現する：
◎
Multiple attribute selectors can be used to represent several attributes of an element, or several conditions on the same attribute. Here, the selector represents a span element whose hello attribute has exactly the value "Cleveland" and whose goodbye attribute has exactly the value "Columbus":
</p>

<pre>span[`hello^a="Cleveland"][`goodbye^a="Columbus"]</pre>

<p>
次の CSS 規則は， "`=^css" と "`~=^css" の相違を示すものになる：
最初の選択子は、例えば `rel^a 属性の値が
"`copyright copyleft copyeditor^s"
である `a^e 要素にも合致することになる。
2 番目の選択子は、 `href^a 属性の値が
`http://www.w3.org/^s"
に一致する `a^e 要素のみに合致することになる。
◎
The following CSS rules illustrate the differences between "=" and "~=". The first selector would match, for example, an a element with the value "copyright copyleft copyeditor" on a rel attribute. The second selector would only match an a element with an href attribute having the exact value "http://www.w3.org/".
</p>

<pre>a[`rel^a~="copyright"] { ... }
a[`href^a="http://www.w3.org/"] { ... }</pre>

<p>
次の選択子は，
`hreflang^a 属性が "`fr^s" に一致する
`a^e 要素を表現する：
◎
The following selector represents an a element whose hreflang attribute is exactly "fr".
</p>

<pre>a[`hreflang^a=fr]</pre>

<p>
次の選択子は，
`hreflang^a 属性の値が "`en^s" から始まる `a^e 要素を表現する
— すなわち， "`en^s", "`en-US^s", "`en-scouse^s" なども含まれる：
◎
The following selector represents an a element for which the value of the hreflang attribute begins with "en", including "en", "en-US", and "en-scouse":
</p>

<pre>a[`hreflang^a|="en"]</pre>

<p>
次の 2 つの選択子は、
`character^a 属性がそれぞれ別の値をとる，
`DIALOGUE^e 要素を表現する
◎
The following selectors represent a DIALOGUE element whenever it has one of two different values for an attribute character:
</p>

<pre>
DIALOGUE[`character^a=romeo]
DIALOGUE[`character^a=juliet]</pre>

</div>

		</section>
		<section id="attribute-substrings">
<h3 title="Substring matching attribute selectors">6.2. 部分照合 属性~選択子</h3>

<p>
属性値の一部をなす文字列との照合処理のために，次の３種の`属性~選択子$が提供される：
◎
Three additional attribute selectors are provided for matching substrings in the value of an attribute:
</p>

<dl>
	<dt><code class="css">[`att^a^=%val]</code></dt>
	<dd>
値が “接頭辞” %val から始まる `att^a 属性を伴うような要素を表現する。
%val が空文字列である場合、この選択子は何も表現しない。
◎
Represents an element with the att attribute whose value begins with the prefix "val". If "val" is the empty string then the selector does not represent anything.
</dd>

	<dt><code class="css">[`att^a$=%val]</code></dt>
	<dd>
値が “接尾辞” %val で終端する `att^a 属性を伴うような要素を表現する。
%val が空文字列である場合、この選択子は何も表現しない。
◎
Represents an element with the att attribute whose value ends with the suffix "val". If "val" is the empty string then the selector does not represent anything.
</dd>

	<dt><code class="css">[`att^a*=%val]</code></dt>
	<dd>
［
値のどこかに文字列 %val を包含している `att^a 属性
］を伴うような要素を表現する。
%val が空文字列である場合、この選択子は何も表現しない。
◎
Represents an element with the att attribute whose value contains at least one instance of the substring "val". If "val" is the empty string then the selector does not represent anything.
</dd></dl>

<p>
属性値に照合される %val は、
`ident-token$t または `string-token$t
として与えられ~MUST。
◎
Attribute values must be &lt;ident-token&gt;s or &lt;string-token&gt;s.
</p>

<div class="example">

<p>
次の選択子は、画像を参照している HTML `object^e 要素を表現する：
◎
Examples: The following selector represents an HTML object element, referencing an image:
</p>

<pre>object[`type^a^="image/"]</pre>

<p>
次の選択子は
`href^a 属性の値が "<samp>.html</samp>" で終端している
HTML `a^e 要素を表現する：
◎
The following selector represents an HTML a element with an href attribute whose value ends with ".html".
</p>

<pre>a[`href^a$=".html"]</pre>

<p>
次の選択子は［
`title^a 属性の値が部分文字列として "`hello^s" を包含する
］ような， HTML  の段落を表現する：
◎
The following selector represents an HTML paragraph with a title attribute whose value contains the substring "hello"
</p>

<pre>p[`title^a*="hello"]</pre>

</div>

		</section>
		<section id="attribute-case">
<h3 title="Case-sensitivity">6.3. 属性値の文字大小の区別</h3>

<p>
既定では、選択子の中の 属性名や属性値 の文字大小が区別されるかどうかは，文書~言語に依存する。
文書~言語が定める~~規則に関わりなく，属性値を文字大小無視で合致させるため、
`属性~選択子$の
閉じ角括弧 ❝] の直前に，識別子 ❝i を含ませる方法が用意されている。
この~flagが在るときは、~UAは，属性の値を `ASCII 文字大小無視$の下で合致させ~MUST。
他の Selectors 構文と同様、識別子 ❝i 自身も `ASCII 文字大小無視$である。
◎
By default case-sensitivity of attribute names and values in selectors depends on the document language. To match attribute values case-insensitively regardless of document language rules, the attribute selector may include the identifier i before the closing bracket (]). When this flag is present, UAs must match the attribute’s value case-insensitively within the ASCII range. Like the rest of Selectors syntax, the i identifier is case-insensitive within the ASCII range.
</p>

<div class="example">
<p>
次の CSS 規則は、属性値の文字大小が区別される XML 環境の下でも，
`frame^a 属性の値が
`hsides^s,
`HSIDES^s,
`hSides^s,
等々として表現される値 `hsides^s をとるとき，~style付けを与えることになる。
◎
The following rule will style the frame attribute when it has a value of hsides, whether that value is represented as hsides, HSIDES, hSides, etc. even in an XML environment where attribute values are case-sensitive.
</p>

<pre>[`frame^a=hsides i] { border-style: solid none; }</pre>
</div>

<p class="trans-note">【
"i" の存在は、構文上は，後方互換にならないと見られる（未~supportの場合，全体が無効にされる）。
】</p>


		</section>
		<section id="attrnmsp">
<h3 title="Attribute selectors and namespaces">6.4. 属性~選択子と名前空間</h3>

<p>
`属性~選択子$の中の属性名は，`CSS 有修飾名$として与えられる：
属性名には、`宣言-$済みの名前空間 接頭辞が，名前空間~区切子
❝|
で区切られた上で，前置されてもよい。
Namespaces in XML 勧告 `XML-NAMES$r の規定に倣い、`既定の名前空間$は，属性には適用されない。
したがって，名前空間~成分を伴わない`属性~選択子$は、どの名前空間にも属さない属性のみを対象にする（ <code class="css">|`attr^a</code> に等価）。
名前空間 接頭辞として、~asteriskが用いられてもよい。
これは、属性名の名前空間を問わずに選択子を合致させることを指示する。
◎
The attribute name in an attribute selector is given as a CSS qualified name: a namespace prefix that has been previously declared may be prepended to the attribute name separated by the namespace separator "vertical bar" (|). In keeping with the Namespaces in the XML recommendation, default namespaces do not apply to attributes, therefore attribute selectors without a namespace component apply only to attributes that have no namespace (equivalent to |attr). An asterisk may be used for the namespace prefix indicating that the selector is to match all attribute names without regard to the attribute’s namespace.
</p>

<p>
属性名に`未宣言$の名前空間 接頭辞を伴うような`属性~選択子$は、`無効な選択子$である。
◎
An attribute selector with an attribute name containing a namespace prefix that has not been previously declared is an invalid selector.
</p>

<div class="example">
<p>
次の CSS において：
◎
CSS examples:
</p>

<pre>
@namespace foo "http://www.example.com";
[foo|`att^a=val] { color: blue } /* 規則 1 */
[*|`att^a] { color: yellow }     /* 規則 2 */
[|`att^a] { color: green }       /* 規則 3 */
[`att^a] { color: green }        /* 規則 4 */</pre>

<p>
規則 1 は、［
値  "`val^s" をとり, かつ
"`http://www.example.com^s"
名前空間に属する
］ `att^a 属性を伴う要素のみに合致することになる。
◎
The first rule will match only elements with the attribute att in the "http://www.example.com" namespace with the value "val".
</p>

<p>
規則 2 は、（どの名前空間にも属さないものも含め）属性の名前空間を問わず， `att^a 属性を伴う要素のみに合致することになる。
◎
The second rule will match only elements with the attribute att regardless of the namespace of the attribute (including no namespace).
</p>

<p>
規則 3,4 は等価であり，いずれも どの名前空間にも属さない
`att^a 属性を伴う要素のみに合致することになる。
◎
The last two rules are equivalent and will match only elements with the attribute att where the attribute is not in a namespace.
</p></div>

		</section>
		<section id="def-values">
<h3 title="Default attribute values in DTDs">6.5. DTD 内で与えられる属性の既定値</h3>

<p>
`属性~選択子$は、文書~木の中の属性値を表現する。
文書~木がどのように構築されるかは、 Selectors の対象外である。
一部の文書~形式では， DTD その他の場所で属性の既定値が定義されることもあるが、それらは，文書~木に現れない限り `属性~選択子$により選択されることはない。
選択子は、既定値が文書~木に含まれるかどうかに関わりなく，働くように設計されるべきである。
◎
Attribute selectors represent attribute values in the document tree. How that document tree is constructed is outside the scope of Selectors. In some document formats default attribute values can be defined in a DTD or elsewhere, but these can only be selected by attribute selectors if they appear in the document tree. Selectors should be designed so that they work whether or not the default values are included in the document tree.
</p>

<p>
例えば、
XML ~UAは DTD の “外部~subset” を読取ってもよいとされているが，<em>要求されてはいない</em>。
一方で、文書の “内部~subset” の中で与えられる［
属性の既定値
］については，その~~探索が<em>要求されている</em>。
（これらの~subsetの定義については，例えば `XML10$r を参照。）
DTD の外部~subsetにて定義される［
属性の既定値
］が，文書~木の中に現れるかどうかは、~UAに依存する。
◎
For example, a XML UA may, but is not required to, read an “external subset” of the DTD, but is required to look for default attribute values in the document’s “internal subset”. (See, e.g., [XML10] for definitions of these subsets.) Depending on the UA, a default attribute value defined in the external subset of the DTD might or might not appear in the document tree.
</p>

<p>
XML 名前空間を認識する~UAは、その名前空間の知識を利用して，属性の既定値が文書~内に在ったかのように扱ってもよいとされているが、要求されてはいない。
（例えば、 XHTML ~UAには，組込みの XHTML  DTD についての知識を利用することは要求されていない。
XML 1.0 名前空間の詳細は、例えば `XML-NAMES$r を参照。）
◎
A UA that recognizes an XML namespace may, but is not required to use its knowledge of that namespace to treat default attribute values as if they were present in the document. (For example, an XHTML UA is not required to use its built-in knowledge of the XHTML DTD. See, e.g., [XML-NAMES] for details on namespaces in XML 1.0.)
</p>

<p class="note">注記：
概して、実装は，外部~subsetを無視する。
これは、 XML 仕様にて定義されている，妥当性を検証しない~processorの挙動に対応する。
◎
Note: Typically, implementations choose to ignore external subsets. This corresponds to the behaviour of non-validating processors as defined by the XML specification.
</p>

<div class="example">

<p>
既定値に "`decimal^s" をとる `radix^a 属性を伴う `EXAMPLE^e 要素を考える。
 DTD 片が次の様になっているとして：
◎
Consider an element EXAMPLE with an attribute radix that has a default value of "decimal". The DTD fragment might be
</p>

<pre class="dtd-example">&lt;!ATTLIST EXAMPLE radix (decimal,octal) "decimal"&gt;</pre>

<p>
~stylesheetに次の CSS 規則が与えられている場合：
◎
If the style sheet contains the rules
</p>

<pre>
EXAMPLE[`radix^a=decimal] { /* <span class="comment">…既定の~prop設定…</span> */ }
EXAMPLE[`radix^a=octal]   { /* <span class="comment">…他の設定…</span> */ }◎
EXAMPLE[radix=decimal] { /* ... default property settings ... */ }
EXAMPLE[radix=octal]   { /* ... other settings... */ }
</pre>

<p>
最初の規則は
`radix^a 属性が既定を通して設定されるような
— すなわち，明示的には設定されない
— 要素には合致しないかもしれない。
すべての場合に対応するためには、既定値に対する`属性~選択子$を取り除く必要がある：
◎
the first rule might not match elements whose radix attribute is set by default, i.e. not set explicitly. To catch all cases, the attribute selector for the default value must be dropped:
</p>

<pre>
EXAMPLE                { /* <span class="comment">…既定の~prop設定…</span> */ }
EXAMPLE[`radix^a=octal]   { /* <span class="comment">…他の設定…</span> */ }◎
EXAMPLE                { /* ... default property settings ... */ }
EXAMPLE[radix=octal]   { /* ... other settings... */ }
</pre>

<p>
ここでは，選択子
<samp>EXAMPLE[`radix^a=octal]</samp>
は，`型~選択子$~~単独より`詳細度$が高いので、 2 番目の規則の~style宣言は，［
`radix^a 属性値が "`octal^s"
］の要素も対象にする最初の規則を上書きすることになる。
既定の場合のみを対象にするような すべての~prop宣言は、非~既定の場合を対象にする~style規則で上書きできるように，配慮する必要がある。
◎
Here, because the selector ''EXAMPLE[radix=octal]'' is more specific than the type selector alone, the style declarations in the second rule will override those in the first for elements that have a radix attribute value of "octal". Care has to be taken that all property declarations that are to apply only to the default case are overridden in the non-default cases' style rules.
</p></div>

		</section>
		<section id="class-html">
<h3 title="Class selectors">6.6. ~class選択子</h3>

<p>
`~class選択子@
は［
❝. （“終止符”）,
識別子
］の並びとして与えられる。
それは、識別子により識別される “~class” に <em>属する</em> 要素を表現する。
【下の例に見られる様に，要素は同時に複数の~classに属し得る。】
~classは文書~言語により定義される。
例えば `HTML5$r, `SVG11$r, `MATHML$r における~classへの所属は，
`class^a 属性により与えられる：
これらの言語では、local `class^a 属性に適用される
`~=^css 記法に等価になる（すなわち
<code class="css">[`class^a~=%identifier]</code>
）。
【 “local” — 名前空間の文脈で要素に局所的，の意味と見られる】
◎
The class selector is given as a full stop (. U+002E) immediately followed by an identifier. It represents an element belonging to the class identified by the identifier, as defined by the document language. For example, in [HTML5], [SVG11], and [MATHML] membership in a class is given by the class attribute: in these languages it is equivalent to the ~= notation applied to the local class attribute (i.e. [class~=identifier]).
</p>

<div class="example">
<p>
CSS 例をいくつか示す：
◎
CSS examples:
</p>

<p>
次の様にして、
<samp>`class^a~="pastoral"</samp>
を伴うすべての要素に，~style情報をあてがうことができる：
◎
We can assign style information to all elements with class~="pastoral" as follows:
</p>

<pre>*.pastoral { color: green }  /* all elements with class~=pastoral */</pre>

<p>
または単に
◎
or just
</p>

<pre>.pastoral { color: green }  /* all elements with class~=pastoral */</pre>

<p>
次のものは
<samp>`class^a~="pastoral"</samp>
を伴う `h1^e 要素にのみ~styleをあてがう：
◎
The following assigns style only to H1 elements with class~="pastoral":
</p>

<pre>H1.pastoral { color: green }  /* H1 elements with class~=pastoral */</pre>

<p>
これらの規則の下では、下の最初の `h1^e 要素~instanceは，その~textは green にされない一方、 2 番目のものはそうなる：
◎
Given these rules, the first H1 instance below would not have green text, while the second would:
</p>

<pre>
&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;</pre>

<p>
次の規則は、
`class^a 属性に
`pastoral^s および `marine^s の両方を含む
`空白$区切りの値の~list
があてがわれているような，任意の `p^e 要素に合致する：
◎
The following rule matches any P element whose class attribute has been assigned a list of whitespace-separated values that includes both pastoral and marine:
</p>

<pre>p.pastoral.marine { color: green }</pre>

<p>
この規則は
<samp>`class^a="pastoral blue aqua marine"</samp>
に対しては合致するが、
<samp>`class^a="pastoral blue"</samp>
に対しては合致しない。
◎
This rule matches when class="pastoral blue aqua marine" but does not match for class="pastoral blue".
</p></div>

<p class="note">注記：
CSS は “class” 属性に相当の力を与えているので、作者は，関連付けられた呈示様式をほとんど持たない要素（ HTML の `div^e や `span^e 要素など）に基づいて自前の “文書~言語” を設計し, “class” 属性を通して~style情報あてがうことも可能であるが、この実践はできれば避けられるべきである。
文書~言語の構造的~要素は，広く認知-／受容されている意味を備えていることが多い一方で、作者定義の class はそうでないであろうから。
◎
Note: Because CSS gives considerable power to the "class" attribute, authors could conceivably design their own "document language" based on elements with almost no associated presentation (such as div and span in HTML) and assigning style information through the "class" attribute. Authors should avoid this practice since the structural elements of a document language often have recognized and accepted meanings and author-defined classes may not.
</p>

<p class="note">注記：
要素が複数の~class属性を持つ場合
【文書~言語に複数種の［ ~classの意味論を備えるような属性］が規定されている下で？】
、それらの値は~classの照合検索の前に space で区切って連結され~MUST。
しかしながら、現時点では， working group はこのような状況があり得るものと考えていない。
したがって，この挙動は、この仕様においては参考であり，規範ではない。
◎
Note: If an element has multiple class attributes, their values must be concatenated with spaces between the values before searching for the class. As of this time the working group is not aware of any manner in which this situation can be reached, however, so this behavior is explicitly non-normative in this specification.
</p>


<p>
`過去互換~mode$の文書に対しては、~class名は，`ASCII 文字大小無視$で照合され~MUST
— 他所における`~class選択子$は，大小を区別する。
◎
When matching against a document which is in quirks mode, class names must be matched ASCII case-insensitively; class selectors are otherwise case-sensitive.
</p>

		</section>
		<section id="id-selectors">
<h3 title="ID selectors">6.7. ID 選択子</h3>

<p>
文書~言語には， ID 型であるものとして宣言される属性を備えているものもある。
ID 型の属性は、それを有する要素の型に関わりなく，同じ文書の中で
— その文書が文書~言語に適合する限り —
複数のそれが同じ値をとり得ない点で、特別な~~地位にある。
文書~言語が何であれ、 ID 型にされている属性は，要素を一意に識別する目的に利用できる。
HTML においては、すべての ID 型の属性は `id^c と命名されている。
XML ~appは ID 型の属性を異なるものに命名し得るが、同じ制約が適用される。
要素のどの属性が “ID 属性” であるとされるかは，文書~言語が定義する。
◎
Document languages may contain attributes that are declared to be of type ID. What makes attributes of type ID special is that no two such attributes can have the same value in a conformant document, regardless of the type of the elements that carry them; whatever the document language, an ID typed attribute can be used to uniquely identify its element. In HTML all ID attributes are named id; XML applications may name ID attributes differently, but the same restriction applies. Which attribute on an element is considered the “ID attribute“ is defined by the document language.
</p>

<p>
`ID 選択子@
は［
❝# （“番号記号”）,
ID 値
］の並びで記される。
ID 値は `CSS 識別子$で~MUST。
 ID 選択子は、その中の識別子に合致する ID を持つ要素~instance表現する。
（非適合~文書においては，複数の要素が同じ ID 選択子に合致することが起こり得る。）
◎
An ID selector consists of a “number sign” (U+0023, #) immediately followed by the ID value, which must be a CSS identifier. An ID selector represents an element instance that has an identifier that matches the identifier in the ID selector. (It is possible in non-conforming documents for multiple elements to match a single ID selector.)
</p>

<div class="example">
<p>
次の ID 選択子は、 ID 型の属性値が "`chapter1^s" であるような， `h1^e 要素を表現する：
◎
Examples: The following ID selector represents an h1 element whose ID-typed attribute has the value "chapter1":
</p>

<pre>h1#chapter1</pre>

<p>
次の ID 選択子は、 ID 型の属性値が "`chapter1^s" であるような，任意の要素を表現する：
◎
The following ID selector represents any element whose ID-typed attribute has the value "chapter1":
</p>

<pre>#chapter1</pre>

<p>
次の選択子は、 ID 型の属性値が "`z98y^s" であるような，任意の要素を表現する：
◎
The following selector represents any element whose ID-typed attribute has the value "z98y".
</p>

<pre>*#z98y</pre>

</div>

<p class="note">注記：
XML 1.0 `XML10$rにおいては、どの属性が要素の ID を与えるかについての情報は， DTD もしくは~schemaに含められる。
~UAは XML を構文解析する際に，常に DTD を読取るとは限らないので、何が要素 ID を与えるのか知り得ない可能性がある（~UAは，名前空間~特有の知識を持ち得るので、その場合はどれが ID 属性なのか決定し得るが）。
~stylesheet作者は、~UAがその種の情報を取得しない可能性もあることが判っているか疑わしいときには、代わりに通常の`属性~選択子$を用いるべきである：
`#p371^S の代わりに <samp class="css">[`name^a=p371]</samp> 等々。
◎
Note: In XML 1.0 [XML10], the information about which attribute contains an element’s IDs is contained in a DTD or a schema. When parsing XML, UAs do not always read the DTD, and thus may not know what the ID of an element is (though a UA may have namespace-specific knowledge that allows it to determine which attribute is the ID attribute for that namespace). If a style sheet author knows or suspects that a UA may not know what the ID of an element is, he should use normal attribute selectors instead: ''[name=p371] instead of #p371''.
</p>

<p>
【文書~言語にて複数種の［ ID の意味論を備えるような属性］が規定されている下で，】
要素が複数の ID 属性を持つ場合、 ID 選択子の目的においては，それらすべてがその要素の ID として扱われ~MUST。
その種の状況は
xml:id,  DOM3 Core,  XML DTD, 名前空間~特有の知識の~~組み合わせにより生じ得る。
◎
If an element has multiple ID attributes, all of them must be treated as IDs for that element for the purposes of the ID selector. Such a situation could be reached using mixtures of xml:id, DOM3 Core, XML DTDs, and namespace-specific knowledge.
</p>


<p>
`過去互換~mode$の文書に対しては、 ID は，`ASCII 文字大小無視$で照合され~MUST
— 他所における`ID 選択子$は，大小を区別する。
◎
When matching against a document which is in quirks mode, IDs must be matched ASCII case-insensitively; ID selectors are otherwise case-sensitive.
</p>


		</section>
	</section>
	<section id="linguistic-pseudos">
<h2 title="Linguistic Pseudo-classes">7. 自然言語に関する疑似類</h2>

		<section id="the-dir-pseudo">
<h3 title="The Directionality Pseudo-class: :dir()">7.1. 方向性 疑似類	`dir()^ps</h3>

<p>
`dir()@ps
疑似類により，文書の自然言語
【の表記体系  — writing system 】
から決定される方向性に基づいて要素を表現するような選択子を記せるようになる。
例えば `HTML5$r では、
`dir^a 属性, 周囲の~text, その他の因子
の組合せ基づいて，
<a href="~SELECTORS-HTML#selector-ltr">要素の方向性を決定する方法</a>
が定められている。
`dir()$ps 疑似類は、~style付け状態に基づく選択はしない  —
例えば，その照合処理に CSS `direction$p ~propは影響しない。
◎
The :dir() pseudo-class allows the author to write selectors that represent an element based on its directionality as determined by the document language. For example, [HTML5] defines how to determine the directionality of an element, based on a combination of the dir attribute, the surrounding text, and other factors. The :dir() pseudo-class does not select based on stylistic states—for example, the CSS direction property does not affect whether it matches.
</p>

<p>
疑似類 `dir(ltr)$ps は、左横書き（ left-to-right ）の方向性 （ `ltr^s ）を備える要素を表現する。
疑似類 `dir(rtl)$ps は、右横書き（ right-to-left ）の方向性 （ `rtl^s ）を備える要素を表現する。
`dir()$ps がとる引数は、単独の識別子で~MUST。
他の場合、選択子は無効になる。
識別子と括弧の間に`空白$が挟まれていてもよい。
`ltr^s, `rtl^s 以外の値も無効ではないが、【現時点では】何にも合致しない。
（将来の~markup仕様が他の種類の方向性を定義した場合、対応する値が許容されるように， Selectors も拡張されるであろう。）
◎
The pseudo-class :dir(ltr) represents an element that has a directionality of left-to-right (ltr). The pseudo-class :dir(rtl) represents an element that has a directionality of right-to-left (rtl). The argument to :dir() must be a single identifier, otherwise the selector is invalid. White space is optionally allowed between the identifier and the parentheses. Values other than ltr and rtl are not invalid, but do not match anything. (If a future markup spec defines other directionalities, then Selectors may be extended to allow corresponding values.)
</p>

<p>
`:dir(C)^css と
<code class="css">[`dir^a=C]</code>
の相違は、後者が要素~上の与えられた属性に対してのみ，比較を遂行する一方で、
`:dir(C)^css
疑似類は，比較の際に ~UA が備える文書の意味論についての知識が利用される点にある。
例えば、 HTML の要素の方向性は、
`dir^a 属性を持たない子にも，妥当な `dir^a 属性を持つ先祖があれば，それらのうちの直近のものに備わる方向性を継承する。
別の例として、
<samp>[`dir^a=auto]</samp>
に合致する HTML の要素は、その内容から解決される方向性に依存して，
`dir(ltr)$ps
または
`dir(rtl)$ps
に合致することになる。
`HTML5$r
◎
The difference between :dir(C) and ''[dir=C]'' is that ''[dir=C]'' only performs a comparison against a given attribute on the element, while the :dir(C) pseudo-class uses the UAs knowledge of the document’s semantics to perform the comparison. For example, in HTML, the directionality of an element inherits so that a child without a dir attribute will have the same directionality as its closest ancestor with a valid dir attribute. As another example, in HTML, an element that matches ''[dir=auto]'' will match either :dir(ltr) or :dir(rtl) depending on the resolved directionality of the elements as determined by its contents. [HTML5]
</p>

		</section>
		<section id="the-lang-pseudo">
<h3 title="The Language Pseudo-class: :lang()">7.2. 自然言語 疑似類	`lang()^ps</h3>

<p>
文書~言語において，要素~内容の自然言語（人が話す言語）を決定する方法が指定されている場合、その自然言語に基づく要素を表現する選択子を記せるようになる。
`lang()@ps
疑似類は、その引数に挙げられた いずれかの自然言語に属する要素を表現する。
引数は 1 個以上の`言語範囲$からなる~comma区切りの~listで与えられる。
選択子が妥当になるためには、 `lang()$ps の中の各
`言語範囲@
が，妥当な ［
`ident$t または `string$t
］で~MUST（例えば ~asteriskを包含する言語範囲は、文字列として引用符で括られ~MUST）。
◎
If the document language specifies how the (human) content language of an element is determined, it is possible to write selectors that represent an element based on its language. The :lang() pseudo-class represents an element that is in one of the languages listed in its argument. It accepts a comma-separated list of one or more language ranges as its argument. Each language range in :lang() must be a valid CSS &lt;ident&gt; or &lt;string&gt;. (Language ranges containing asterisks, for example, must be quoted as strings.)
</p>

<p>
要素の
`自然言語@
は、文書~言語により定義される。
例えば HTML `HTML401$r では，`自然言語$は［
`lang^a 属性,
`meta^e 要素からの情報,
加えて（例えば HTTP ~headerからの）~protocol
］の組合せから決定される。
XML 言語では、
<code class="attr">xml:lang</code>
属性を利用して，要素の言語~情報を指示できる。
◎
The language of an element is defined by the document language. For example, in HTML [HTML401], the language is determined by a combination of the lang attribute, information from meta elements, and possibly also the protocol (e.g. from HTTP headers). XML languages can use the xml:lang attribute to indicate language information for an element.
</p>

<p>
要素の`自然言語$は、（必要なら BCP 47 構文に正規化された上で）
`RFC4647$r 3.3.2 節
<cite>Matching of Language Tags</cite>
（“自然言語~tagの照合処理”）の
<i>extended filtering</i>
（ “拡張絞り込み” ）演算により与えられる
<i>language range</i>
（ “言語範囲” ）に合致するとき、`言語範囲$に合致するとされる。
<!-- 和訳 “言語~tagの照合”
http://ofmind.net/doc/rfc/ja/4647
 -->
照合は， `ASCII 文字大小無視$の下で遂行される。
この比較においては、`言語範囲$が妥当な自然言語~codeであるかどうか考慮する必要は無い。
◎
The element’s language matches a language range if the element’s language (normalized to BCP 47 syntax if necessary) matches the given language range in an extended filtering operation per [RFC4647] Matching of Language Tags (section 3.3.2). The matching is performed case-insensitively within the ASCII range. The language range does not need to be a valid language code to perform this comparison.
</p>

<p class="note">注記：
文書および~protocolにおいては， BCP 47 `BCP47$r またはその後継版の~codeを利用して、あるいは XML `XML10$r に基づく文書においては， <code class="attr">xml:lang</code> 属性を通して、自然言語を指示することが推奨される。
<q><a href="http://www.w3.org/International/questions/qa-lang-2or3.html">FAQ:  2 文字または 3 文字の言語~code</a></q>
参照。
◎
Note: It is recommended that documents and protocols indicate language using codes from BCP 47 [BCP47] or its successor, and by means of xml:lang attributes in the case of XML-based documents [XML10]. See "FAQ: Two-letter or three-letter language codes."
</p>

<div class="example">

<p>
次のうち最初の 2 つの選択子は，それぞれ
ベルギー・フランス語, ドイツ語
で書かれた HTML 文書を表現し、その次の 2 つの選択子は，それぞれの自然言語に属する任意の要素の子である “引用文” `q^e 要素を表現する：
◎
Examples: The two following selectors represent an HTML document that is in Belgian French or German. The two next selectors represent q quotations in an arbitrary element in Belgian French or German.
</p>

<pre>
html:lang(fr-be)
html:lang(de)
:lang(fr-be) &gt; q
:lang(de) &gt; q</pre>

</div>

<p class="note">
`:lang(C)^css
と
`|=^css
演算子との相違は、
`|=^css
演算子が要素~上に与えられた属性に対してのみ比較を遂行する一方、
`:lang(C)^css
疑似類は，比較を行う際に~UAが備える文書の意味論についての知識が利用される点にある。
◎
Note: One difference between :lang(C) and the ''|='' operator is that the ''|='' operator only performs a comparison against a given attribute on the element, while the :lang(C) pseudo-class uses the UAs knowledge of the document’s semantics to perform the comparison.
</p>

<div class="example">
<p>
次の HTML 例では、
<code class="css">[`lang^a|=fr]</code> には，（ `lang^a 属性を持つ） `body^e のみが合致する一方で、
`:lang(fr)^css には `body^e と `p^e の両者が合致する（両者ともフランス語に属するものとされるので）。
`p^e は `lang^a 属性を持たないので， <code class="css">[`lang^a|=fr]</code> に合致しない。
◎
In this HTML example, only the BODY matches ''[lang|=fr]'' (because it has a LANG attribute) but both the BODY and the P match :lang(fr) (because both are in French). The P does not match the ''[lang|=fr]'' because it does not have a LANG attribute.
</p>

<pre>
&lt;body lang=fr&gt;
  &lt;p&gt;Je suis français.&lt;/p&gt;
&lt;/body&gt;</pre>

</div>


<div class="example">
<p>
`:lang(C)^css と
`|=^css
演算子のもう一つの相違は、
`:lang(C)^css が暗黙的に~wildcard照合処理を遂行する点にある。
◎
Another difference between :lang(C) and the ''|='' operator is that :lang(C) performs implicit wildcard matching.
</p>

<p>
例えば `:lang(de-DE)^S は、次のすべてに合致することになる：
"`de-DE^s",
"`de-DE-1996^s",
"`de-Latn-DE^s",
"`de-Latf-DE^s",
"`de-Latn-DE-1996^s"
。
一方で <samp class="css">[`lang^a|=de-DE]</samp> は、これらのうち
"`de-DE^s"
と
"`de-DE-1996^s"
のみに合致することになる。 
◎
For example, :lang(de-DE) will match all of de-DE, de-DE-1996, de-Latn-DE, de-Latf-DE, de-Latn-DE-1996, whereas of those ''[lang|=de-DE] will only match de-DE'' and de-DE-1996.
</p>

<p>
最初の下位tag（第一~自然言語）については~wildcardによる照合処理を遂行するためには、 1 個の~asteriskが用いられ~MUST：
例えば `*-CH^S は
"`de-CH^s",
"`it-CH^s",
"`fr-CH^s",
"`rm-CH^s"
のすべてに合致することになる。
◎
To perform wildcard matching on the first subtag (the primary language), an asterisk must be used: *-CH will match all of de-CH, it-CH, fr-CH, and rm-CH.
</p>
</div>

<p class="note">注記：
~wildcard自然言語~照合処理は， Level 4 にて新たに~~導入された。
◎
Note: Wildcard language matching is new in Level 4.
</p>

		</section>
	</section>
	<section id="location">
<h2 title="Location Pseudo-classes">8. 所在 疑似類</h2>

		<section id="the-any-link-pseudo">
<h3 title="The Hyperlink Pseudo-class: :any-link">8.1. ~hyperlink疑似類	`any-link^ps</h3>

<p>
`any-link@ps
疑似類は、~hyperlinkの~source~anchorとしてふるまう要素を表現する。
例えば `HTML5$r では、
`href^a 属性を伴う任意の `a^e, `area^e, `link^e 要素が~hyperlinkであり，
`any-link$ps にも
<a href="~SELECTORS-HTML#selector-link">合致する</a>
。
それは `link$ps または `visited$ps に合致する要素に合致する。
すなわち，
`:matches(:link, :visited)^css
と等価である。
◎
The :any-link pseudo-class represents an element that acts as the source anchor of a hyperlink. For example, in [HTML5], any a, area, or link elements with an href attribute are hyperlinks, and thus match :any-link. It matches an element if the element would match :link or :visited, equivalent to :matches(:link, :visited).
</p>

<p class="issue">
この疑似類にもっとよい名前は？
◎
Any better name suggestions for this pseudo?
</p>

		</section>
		<section id="link">
<h3 title="The Link History Pseudo-classes: :link and :visited">8.2. ~link履歴 疑似類	`link^ps, `visited^ps</h3>

<p>
~UA は、未訪問の
<a href="#the-any-link-pseudo">~hyperlink</a>
を訪問済みのそれと異なる表示にすることが多い。
Selectors は、それらを判別する疑似類
`link@ps
および
`visited@ps
を提供する：
◎
User agents commonly display unvisited hyperlinks differently from previously visited ones. Selectors provides the pseudo-classes :link and :visited to distinguish them:
</p>

<ul>
   <li>
`link$ps 疑似類は、未訪問の~linkを対象にする。
◎
The :link pseudo-class applies to links that have not yet been visited.
</li>

<li>
`visited$ps 疑似類は、利用者により訪問済み~linkを対象にする。
◎
The :visited pseudo-class applies once the link has been visited by the user.
</li></ul>

<p>
~UA は、一定期間が経過した訪問済み~linkを未訪問の `link$ps 状態に戻してもよい。
◎
After some amount of time, user agents may choose to return a visited link to the (unvisited) :link state.
</p>

<p>
2 つの状態は両立しない。
◎
The two states are mutually exclusive.
</p>

<div class="example">

<p>
次の選択子は、 `footnote^s ~classに属していて, かつ 既に訪問済みの~linkを表現する：
◎
The following selector represents links carrying class footnote and already visited:
</p>

<pre>.footnote:visited</pre>

</div>

<p>
~stylesheet作者が 利用者の同意なしに利用者が訪問済みの~siteを調べる目的に，
`link$ps ／ `visited$ps
疑似類を濫用することも可能なので、~UAは，~linkを 訪問済みか未訪問かに応じて異なるように具現化しつつ，利用者の~privacyを守るために、すべての~linkを未訪問の~linkとして扱うなど, 他の措置を実装してもよい。
◎
Since it is possible for style sheet authors to abuse the :link and :visited pseudo-classes to determine which sites a user has visited without the user’s consent, UAs may treat all links as unvisited links or implement other measures to preserve the user’s privacy while rendering visited and unvisited links differently.
</p>

<p class="trans-note">【
例えば 一部の~browserでは、 `visited^ps に指定し得る~styleは，レイアウトも含め，他のどの部分の状態にも影響しないもの（ほぼ色のみ）に限られている
（<a href="https://dev.mozilla.jp/2010/04/plugging-the-css-history-leak/">~~参考</a>）。
】</p>

		</section>
		<section id="the-target-pseudo">
<h3 title="The Target Pseudo-class: :target">8.3. target 疑似類	`target^ps</h3>


<p>
文書~言語によっては、文書の URL は、文書~自身のみならず，
URL の`素片$を介して 文書の <em>中の</em> 特定の要素を指す。
この仕方で指される要素は、文書の~target要素とされる。
◎
In some document languages, the document’s URL can further point to specific elements within the document via the URL’s fragment. The elements pointed to in this way are the target elements of the document.
</p>

<div class="example">
<p>
HTML における素片は、頁~内で同じ ID を伴う要素を指す。
例えば URL
`https://example.com/index.html#section2^s
は、
`https://example.com/index.html^s
にある文書~内の
`id="section2"^s
の要素を指す。
◎
In HTML the fragment points to the element in the page with the same ID. The url https://example.com/index.html#section2, for example, points to the element with id="section2" in the document at https://example.com/index.html. 
</p>
</div>


<p>
`target@ps
疑似類は、文書の~target要素に合致する。
文書の URL が素片~識別子を伴わない場合、その文書に~target要素はない。
◎
The :target pseudo-class matches the document’s target elements. If the document’s URL has no fragment identifier, then the document has no target elements.
</p>

<div class="example">

<pre>p.note:target</pre>

<p>
この選択子は、参照元 URL から~target要素にされていて,
`note^s ~classに属するような， `p^e 要素を表現する：
</p>
</div>


<div class="example">

<p>
次のものは、 `target$ps 疑似類を利用して
~target要素の色を red にし，その先頭に画像を配置する：
◎
CSS example: Here, the :target pseudo-class is used to make the target element red and place an image before it, if there is one:
</p>

<pre>
:target { color : red }
:target::before { content : url(target.png) }</pre>

</div>

		</section>
		<section id="the-scope-pseudo">
<h3 title="The Reference Element Pseudo-class: :scope">8.4. 起点要素 疑似類	`scope^ps</h3>

<p>
ある種の文脈の下では、選択子は，明示的な
`~scope_ps要素@
の集合に対し、照合される。
これは、［
選択子を合致させる際の対象範囲
］の起点にされるような，要素の（空もとり得る）集合である。
例えば、 `DOM$r の `querySelector()$c の引数に指定されるものなど。
<!-- ＊廃
ものや,
`HTML5$r の
<a href="~HTML5/semantics.html#the-style-element">視野付き style 要素</a>
の親~要素など。
 -->
◎
In some contexts, selectors can be matched with an explicit set of :scope elements. This is is a (potentially empty) set of elements that provide a reference point for selectors to match against, such as that specified by the querySelector() call in [DOM], or the parent element of a scoped &lt;style&gt; element in [HTML5].

</p>
<p>
`scope@ps
疑似類は、`~scope_ps要素$とされている任意の要素を表現する。
`~scope_ps要素$が明示的に指定されていないが，選択子が`視野付き$,
かつ その`視野根$は要素である場合、 `scope$ps は，`視野根$を表現する。
他の場合、それは，文書の根を表現する（ `root$ps に等価になる）。
この疑似類を文書の根~要素でない特定の要素に合致させることを意図する仕様は、`視野根$（`視野付き選択子$を利用している場合）, あるいは 
`~scope_ps要素$とされる集合を，明示的に定義し~MUST。
◎
The :scope pseudo-class represents any element that is a :scope element. If the :scope elements are not explicitly specified, but the selector is scoped and the scoping root is an element, then :scope represents the scoping root; otherwise, it represents the root of the document (equivalent to :root). Specifications intending for this pseudo-class to match specific elements rather than the document’s root element must define either a scoping root (if using scoped selectors) or an explicit set of :scope elements.
</p>


		</section>
	</section>
	<section id="useraction-pseudos">
<h2 title="User Action Pseudo-classes">9. 利用者~動作 疑似類</h2>

<p>
対話的~UAは、利用者による動作に対する反応として，具現化法を変えることがある。
Selectors は、利用者による動作の対象にされている要素を選択するための，数種の疑似類を提供する。
（これらの疑似類は，非~対話的~UAにおいても妥当であるが、どの要素にも決して合致しない。）
◎
Interactive user agents sometimes change the rendering in response to user actions. Selectors provides several pseudo-classes for the selection of an element the user is acting on. (In non-interactive user agents, these pseudo-classes are valid, but never match any element.)
</p>

<p>
これらの疑似類は両立し得る。
要素はこれら複数の疑似類に同時に合致し得る。
◎
These pseudo-classes are not mutually exclusive. An element may match several pseudo-classes at the same time.
</p>

<div class="example">
<p lang="en">Examples:</p>

<pre>
a:link    /* <span class="comment">未訪問の~link</span> */
a:visited /* <span class="comment">訪問済み~link</span> */
a:hover   /* <span class="comment">利用者による~hover</span> */
a:active  /* <span class="comment">作動中の~link</span> */◎
a:link    /* unvisited links */
a:visited /* visited links */
a:hover   /* user hovers */
a:active  /* active links */</pre>

<p>
動的~疑似類を組合せる用例：
◎
An example of combining dynamic pseudo-classes:
</p>

<pre>
a:focus
a:focus:hover</pre>

<p>
2 番目の選択子は、疑似類 `focus^ps, `hover^ps の両者に合致するような
`a^e 要素に合致する。
◎
The last selector matches a elements that are in the pseudo-class :focus and in the pseudo-class :hover.
</p></div>

<p class="note">注記：
この節にて定義される一部の疑似類を適用するために必要になる，接触判定の詳細は、将来に定義されることになる。
◎
Note: The specifics of hit-testing, necessary to know when several of the pseudo-classes defined in this section apply, are not yet defined, but will be in the future.
</p>


		<section id="the-hover-pseudo">
<h3 title="The Pointer Hover Pseudo-class: :hover">9.1. ~pointer~hover 疑似類	`hover^ps</h3>

<p>
`hover@ps
疑似類は、利用者が~pointing装置で，要素を指していて、実際に作動化させる必要はない間に適用される。
例えば，視覚的~UAでは、~cursor（~mouse~pointer）が［
要素により生成された`~box$
］上を~hoverしたとき，この疑似類が適用されるであろう。
~hardware制限ionにより~hover~~状態を検知できない対話的~UA（例えば~pen機器）は、この機能を~supportしなくとも，`適合性§には反しない。
◎
The :hover pseudo-class applies while the user designates an element with a pointing device, but does not necessarily activate it. For example, a visual user agent could apply this pseudo-class when the cursor (mouse pointer) hovers over a box generated by the element. Interactive user agents that cannot detect hovering due to hardware limitations (e.g., a pen device that does not detect hovering) are still conforming.
</p>

<p>
`active$ps に合致するような`~shadowも含む子孫$を持つ要素も，
`active$ps に合致する。
◎
An element also matches :hover if one of its shadow-including descendants matches :hover.
</p>

<p>
文書~言語は、 `hover$ps に合致し得る要素について，追加の仕方を定義してよい。
例えば `HTML5$r では、~labelが付与された~control要素は，その~labelを与えている `label^e 要素が~hoverされたとき， `hover$ps に合致するものとされている（
<a href="~HTML5/selectors.html#selector-hover">参照</a>
）。
◎
Document languages may define additional ways in which an element can match :hover. For example, [HTML5] defines a labeled control element as matching :hover when its label is hovered.
</p>

<p class="note">注記：
`hover$ps の状態は、要素の<!-- 子 -->子孫が~pointing装置で指されたときにも適用し得るので、~pointing装置の直下にない要素が `hover$ps の対象になることも起こり得る。
◎
Note: Since the ':hover' state can apply to an element because its child is designated by a pointing device, then it is possible for ':hover' to apply to an element that is not underneath the pointing device.
</p>

<p>
`hover$ps 疑似類は任意の`疑似要素$に適用できる。
◎
The :hover pseudo-class can apply to any pseudo-element.
</p>

		</section>
		<section id="the-active-pseudo">
<h3 title="The Activation Pseudo-class: :active">9.2. 作動化 疑似類	`active^ps</h3>

<p>
`active@ps
疑似類は、利用者により作動化された要素を対象にする。
例えば，利用者が~mouse~buttonを押してから離すまでの間。
複数の~mouse~buttonを備える~systemでは、第一~button／第一~作動化~button（概して， “左” ~mouse~button）, あるいはそれを代理するもののみが， `active$ps の対象になる。
◎
The :active pseudo-class applies while an element is being activated by the user. For example, between the times the user presses the mouse button and releases it. On systems with more than one mouse button, :active applies only to the primary or primary activation button (typically the "left" mouse button), and any aliases thereof.
</p>

<p>
`active$ps になれる要素には、文書~言語／実装 特有の制限があり得る。
例えば `HTML5$r では、一連の
<a href="~SELECTORS-HTML#selector-active">作動可能な要素</a>
を定義している。
◎
There may be document language or implementation specific limits on which elements can become :active. For example, [HTML5] defines a list of activatable elements.
</p>

<p>
`active$ps に合致するような`~shadowも含む子孫$を持つ要素も，
`active$ps に合致する。
◎
An element also matches :active if one of its shadow-including descendants matches :active.
</p>

<p>
文書~言語は、 `active$ps に合致し得る要素について，追加の仕方を定義してよい。
◎
Document languages may define additional ways in which an element can match :active.
</p>

<p class="note">注記：
要素は同時に
`visited$ps かつ `active$ps（あるいは
`link$ps かつ `active$ps
）になり得る。
◎
Note: An element can be both ':visited' and ':active' (or ':link' and ':active').
</p>

		</section>
		<section id="the-focus-pseudo">
<h3 title="The Input Focus Pseudo-class: :focus">9.3. 入力~focus疑似類	`focus^ps</h3>

<p>
`focus@ps
疑似類は、要素が~focusを得ている（［
~keyboard／~mouse ~event, その他の形
］による入力を受容する）間だけ，適用される。
◎
The :focus pseudo-class applies while an element has the focus (accepts keyboard or mouse events, or other forms of input).
</p>

<p>
~focusを獲得できる要素には，文書~言語／実装に特有の制限があり得る。
例えば `HTML5$r は，一連の
<a href="~SELECTORS-HTML#selector-focus">~focusを獲得し得る要素</a>
を定めている。
<!-- 原文誤記：#selector-active → #selector-focus -->
◎
There may be document language or implementation specific limits on which elements can acquire :focus. For example, [HTML5] defines a list of activatable elements.
</p>


<p>
文書~言語が，［
要素が `active$ps に合致し得るような仕方
］を追加で定義している場合、同じ仕方が，
`focus$ps に合致する要素にも適用され~MUST
—
`focus$ps に合致する要素の親【先祖？】は，
`focus$ps に合致しては~MUST_NOTことを除いて。
◎
If the document language has defined additional ways by which an element can match :active, the same ways must apply to elements matching :focus as well, except that the parent of an element that matches :focus must not match :focus.
</p>

		</section>
		<section id="the-focus-within-pseudo">

<h3 title="The Generalized Input Focus Pseudo-class: :focus-within">9.4. 一般化 入力~focus疑似類	`focus-within^ps</h3>

<p>
`focus-within@ps
疑似類は、
`focus$ps 疑似類が適用される要素に適用される。
◎
The :focus-within pseudo-class applies to elements for which the :focus pseudo class applies.
</p>

<p>
`focus-within$ps に合致するような`~shadowも含む子孫$を持つ要素も，
`focus-within$ps に合致する。
◎
An element also matches :focus-within if one of its shadow-including descendants matches :focus.
</p>

		</section>
		<section id="drag-pseudos">
<h3 title="The Drag-and-Drop Pseudo-class: :drop and :drop()">9.5. ~drag-and-drop疑似類	`drop^ps と `drop()^ps</h3>

<p>
<dfn id="drop-pseudo0">`drop^ps</dfn>
<!-- `drop@ps  -->
疑似類は、利用者が “~dropし得る” 項目を “~dragしている” あるいは概念的な意味で “持ち運んでいる” 間にのみ適用され、文書~言語により “~drop先” として定義されているすべての要素に合致する。
例えば HTML では
`dropzone$a
属性が指定された要素が “~drop先” であるものとされる。
◎
The :drop pseudo-class applies to all elements that are drop targets, as defined by the document language, while the user is “dragging” or otherwise conceptually carrying an item to be “dropped”. For example, in HTML the dropzone attribute specified that an element is a drop target.
</p>

<p>
`drop()@ps
<!-- 
<dfn id="drop0">`drop()^ps</dfn>
 -->
`関数形~疑似類$は ~drop0 と同じになるが、一部の~drop先を除外する追加の~filterも指定できる。
その構文は次で与えられる：
◎
The :drop() functional pseudo-class is identical to :drop, but allows additional filters to be specified that can exclude some drop targets. Its syntax is:
</p>

<pre class="prod">:drop( [ active || valid || invalid ]? )</pre>

<p>
各~keywordの意味は：
◎
The keywords have the following meanings:
</p>

<dl>
	<dt id="valdef-drop-active">`active^v</dt>

	<dd>
~drag操作に対する現在の~drop先にのみ合致する。
すなわち，利用者がその場所で~dragを解放したならば，それがこの~drop先に~dropされることになる。
◎
The drop target is the current drop target for the drag operation. That is, if the user were to release the drag, it would be dropped onto this drop target.
</dd>

	<dt id="valdef-drop-valid">`valid^v</dt>
	<dd>
<p>
文書~言語にて，~drop先に対する “有効” ／ “無効” の概念が規定されている場合、これは，現在~dragされている~objectに対し，有効な~drop先であるときのみ合致する。
他の場合、すべての~drop先に合致する。
◎
If the document language has a concept of “valid” and “invalid” drop targets, this only matches if the drop target is valid for the object currently being dragged. Otherwise, it matches all drop targets.
</p>

<p>
例えば， HTML の `dropzone$a 属性は、~drop先が，与えられた型の文字列や~fileのみを受容するように指定し得る。
◎
For example, HTML’s dropzone attribute can specify that the drop target only accepts strings or files that are set to a given type.
</p>
	</dd>

	<dt id="valdef-drop-invalid">`invalid^v</dt>
	<dd>
文書~言語にて，~drop先に対する “有効” ／ “無効” の概念が規定されている場合、これは，現在~dragされている~objectに対し，無効な~drop先であるときのみ合致する。
他の場合、すべての~drop先に合致する。
◎
If the document language has a concept of “valid” and “invalid” drop targets, this only matches if the drop target is invalid for the object currently being dragged. Otherwise, it matches nothing.
</dd>

</dl>

<p>
引数に複数の~keywordを組合せることもできる。
この場合、合致する~drop先は，それらの~keywordによる~~条件をすべてを満たすことを意味する。
例えば 
`:drop(valid active)^S
は、現在の~drop先であって, <em>かつ</em> 有効なもののみに合致することになる。
◎
Multiple keywords can be combined in the argument, representing only drop targets that satisfy all of the keywords. For example, :drop(valid active) will match the active drop target if it’s valid, but not if it’s invalid.
</p>

<p>
引数に~keywordが一つも与えられなかった場合、
`drop()$ps は ~drop0 と同じ意味
— すなわち，どの~drop先にも合致することになる。
◎
If no keywords are given in the argument, :drop() has the same meaning as :drop—it matches every drop target.
</p>

<p class="issue">
<a href="http://forums.mozillazine.org/viewtopic.php?f=18&amp;t=2633249">このscenario</a>
を例にして示す。
◎
Turn this scenario into an example.
</p>


		</section>
	</section>
	<section id="time-pseudos">
<h2 title="Time-dimensional Pseudo-classes">10. 時系列 疑似類</h2>

<p>
この節の疑似類は、何らかの時間軸の下で，現在表示中の, あるいはその作動期間に基づいて，要素を分類する。
文書を発話として具現化するときや,
WebVTT を利用して~videoを表示する間に，字幕を描画するなどの用途がある。
◎
These pseudo-classes classify elements with respect to the currently-displayed or active position in some timeline, such as during speech rendering of a document, or during the display of a video using WebVTT to render subtitles.
</p>

<p>
CSS はこの時間軸を定義しない。
それは~host言語が定義し~MUST。
これらの疑似類は、時間軸が定義されていない要素に合致しては~MUST_NOT。
◎
CSS does not define this timeline; the host language must do so. If there is no timeline defined for an element, these pseudo-classes must not match the element.
</p>

<p class="note">注記：
`current$ps 要素の先祖もまた `current$ps になるが、
`future$ps 要素の先祖も `future$ps になる必要はない。
与えられた要素は、少なくとも `current$ps, `past$ps, `future$ps のいずれかに合致する。
◎
Note: Ancestors of a :current element are also :current, but ancestors of a :past or :future element are not necessarily :past or :future as well. A given element matches at most one of :current, :past, or :future.
</p>


		<section id="the-current-pseudo">
<h3 title="The Current-element Pseudo-class: :current">10.1. 現在要素 疑似類	`current^ps</h3>

<p>
`current@ps
疑似類は、現在表示中の要素, またはその先祖の要素を表現する。
◎
The :current pseudo-class represents the element, or an ancestor of the element, that is currently being displayed.
</p>

<p>
`matches()$ps と同様に`合体~選択子$の~listを引数にとる，関数形の
<dfn id="selectordef-current">`current()^ps</dfn>
もある。
この場合、 ~E を `current$ps 要素とするとき， ~E が引数にも合致するならば ~E 自身を表現し、合致しない場合は［
~E の先祖であって, 引数に合致する要素のうち ~E に最も近い先祖
］を表現する（どれにも合致しない場合は何も表現しない）。
◎
Its alternate form :current(), like :matches(), takes a list of compound selectors as its argument: it represents the :current element that matches the argument or, if that does not match, the innermost ancestor of the :current element that does. (If neither the :current element nor its ancestors match the argument, then the selector does not represent anything.)
</p>

<p class="trans-note">【
`current$ps 要素  —
例えば `elem:current(…)^css
の様に記されているとき，“最も近い先祖” は `elem^css 型でもなければならないのか？
それとも `elem^css 型の `current^ps 要素の先祖のうち引数に合致するような “最も近い先祖” なのかどっち？
】</p>

<div class="example">
<p>
例えば 次の規則は、文書を発話として具現化するときに，読み上げられる段落, または~list項目を強調することになる：
◎
For example, the following rule will highlight whichever paragraph or list item is being read aloud in a speech rendering of the document:
</p>

<pre>
:current(p, li, dt, dd) {
  background: yellow;
}</pre>
</div>



		</section>
		<section id="the-past-pseudo">
<h3 title="The Past-element Pseudo-class: :past">10.2. 過去要素 疑似類	`past^ps</h3>

<p>
`past@ps
疑似類は、全体が `current$ps 要素より先に生じるものと定義されている，任意の要素を表現する。
例えば、 WebVTT 仕様は `past$ps 疑似類を
<a href="http://dev.w3.org/html5/webvtt/#the-past-and-future-pseudo-classes">media 要素の現在の再生位置に相対的</a>
なものとして定義する。
文書~言語に要素の時系列順が定義されていない場合、これは `current$ps 要素に先行するすべての同胞要素を表現する。
◎
The :past pseudo-class represents any element that is defined to occur entirely prior to a :current element. For example, the WebVTT spec defines the :past pseudo-class relative to the current playback position of a media element. If a time-based order of elements is not defined by the document language, then this represents any element that is a (possibly indirect) previous sibling of a :current element.
</p>

		</section>
		<section id="the-future-pseudo">
<h3 title="The Future-element Pseudo-class: :future">10.3. 未来要素 疑似類	`future^ps</h3>

<p>
`future@ps
疑似類は、全体が `current$ps 要素より後に生じるものと定義されている，任意の要素を表現する。
例えば、 WebVTT 仕様では `future$ps 疑似類を
<a href="http://dev.w3.org/html5/webvtt/#the-past-and-future-pseudo-classes">media 要素の現在の再生位置に相対的</a>
なものとして定義する。
文書~言語により要素の時系列順が定義されていない場合、これは `current$ps 要素に後続するすべての同胞要素を表現する。
◎
The :future pseudo-class represents any element that is defined to occur entirely after a :current element. For example, the WebVTT spec defines the :future pseudo-class relative to the current playback position of a media element. If a time-based order of elements is not defined by the document language, then this represents any element that is a (possibly indirect) next sibling of a :current element.
</p>

		</section>
	</section>
	<section id="resource-pseudos">
<h2 title="Resource State Pseudos">11. 資源~状態~疑似類</h2>

<p>
この節の疑似類は、特に画像／動画などの 読込まれた資源を表現する要素に適用され、作者が，それらを何らかの “状態” の~~質に基づいて選択できるようにする。
◎
The pseudo-classes in this section apply to elements that represent loaded resources, particularly images/videos, and allow authors to select them based on some quality of their "state".
</p>



		<section id="video-state">
<h3 title="Video/Audio Play State: the :playing and :paused pseudo-classes">11.1. 動画／音声 再生-状態： `playing^ps, `paused^ps 疑似類</h3>

<p>
`playing@ps 疑似類は、［
“再生-中”, “一時停止-中” になれるような，音声や動画の類の資源
］を表現していて，
“再生-中にある”
ような要素を表現する（これには、要素が明示的に再生されているときの他に、
“~buffer中”
にあるなど、利用者の意図によらない何らかの事由で一時的に停止されていて，その事由が解決された時点で自動的に再開する状態も含まれる。）
◎
The :playing pseudo-class represents an element representing an audio, video, or similar resource that is capable of being "played" or "paused", when that element is "playing". (This includes both when the element is explicitly playing, and when it’s temporarily stopped for some reason not connected to user intent, but will automatically resume when that reason is resolved, such as a "buffering" state.)
</p>

<p>
`paused@ps 疑似類は、同じ要素を表現するが，それが再生-中でないときに合致する（これには、明示的に
“一時停止された”
状態の他に，
“読込まれたが，まだ作動化されていない”
ことにより再生-中でない状態も含まれる）。
◎
The :paused pseudo-class represents the same elements, but instead match when the element is not "playing". (This includes both an explicit "paused" state, and other non-playing states like "loaded, hasn’t been activated yet", etc.)
</p>
		</section>
	</section>
	<section id="input-pseudos">
<h2 title="The Input Pseudo-classes">12. 入力 疑似類</h2>

<p>
この節の疑似類の大半は、 HTML の `input^e 要素など，利用者からの入力をとる要素を対象にする。
◎
The pseudo-classes in this section mostly apply to elements that take user input, such as HTML’s input element.
</p>

		<section id="input-states">
<h3 title="Input Control States">12.1. 入力~controlの状態</h3>

			<section id="enableddisabled">
<h4 title="The :enabled and :disabled Pseudo-classes">12.1.1. 操作可否 疑似類	`enabled^ps, `disabled^ps</h4>

<p>
疑似類
`enabled@ps
／
`disabled@ps
は、それぞれ， 操作可／操作不可 にされた~UI要素を表現する。
その種の要素は対応する 操作不可／操作可 の状態も備える。
◎
The :enabled pseudo-class represents user interface elements that are in an enabled state; such elements have a corresponding disabled state.
◎
Conversely, the :disabled pseudo-class represents user interface elements that are in a disabled state; such elements have a corresponding enabled state.
</p>

<p>
何が~UI要素とされ，操作可／操作不可の状態がどのように定まるのかは~host言語に依存する。
大概の文書では、ほとんどの要素が `enabled$ps ／ `disabled$ps  の対象にならない。
例えば `HTML5$r では、対話的~要素のうち，操作不可にされていないものが `enabled^ps である（
<a href="~SELECTORS-HTML#selector-enabled">参照</a>
）とされ，明示的に操作不可にされている要素が `disabled^ps である（
<a href="~SELECTORS-HTML#selector-disabled">参照</a>
）とされている。
◎
What constitutes an enabled state, a disabled state, and a user interface element is host-language-dependent. In a typical document most elements will be neither :enabled nor :disabled. For example, [HTML5] defines non-disabled interactive elements to be :enabled, and any such elements that are explicitly disabled to be :disabled.
</p>

<p class="note">注記：
利用者が与えられた~UI要素とやりとりできるかどうかに影響する CSS ~propは、それが `enabled$ps や `disabled$ps に合致するかどうかに影響しない。
例えば， `display^p や `visibility^p ~propは、要素の 操作可／操作不可 の状態に対し，効果を持たない。
◎
Note: CSS properties that might affect a user’s ability to interact with a given user interface element do not affect whether it matches :enabled or :disabled; e.g., the display and visibility properties have no effect on the enabled/disabled state of an element.
</p>

			</section>
			<section id="rw-pseudos">
<h4 title="The Mutability Pseudo-classes: :read-only and :read-write">12.1.2. 変更可否 疑似類	`read-only^ps, `read-write^ps</h4>

<p>
`read-write@ps
は、文書~言語により定義される，利用者が内容を改め得る要素に合致する。
他のものは
`read-only@ps
である。
◎
An element matches :read-write if it is user-alterable, as defined by the document language. Otherwise, it is :read-only.
</p>

<p>
例えば `HTML5$r では、操作不可にされてなく, かつ読専でない
`input^e 要素, あるいは
`contenteditable^a 属性が true 状態にあるような，任意の要素が `read-write^ps とされている（
<a href="~SELECTORS-HTML#selector-read-only">参照</a>
）。
◎
For example, in [HTML5] a non-disabled non-readonly &lt;input&gt; element is :read-write, as is any element with the contenteditable attribute set to the true state.
</p>

			</section>
			<section id="placeholder">
<h4 title="The Placeholder-shown Pseudo-class: :placeholder-shown">12.1.3. 仮入力例示 疑似類	`placeholder-shown^ps</h4>

<p>
入力~要素は、利用者~向けの~hintとして仮入力~textを例示することがある。
例えば `HTML5$r の `placeholder^a 属性。
`placeholder-shown@ps
疑似類は、そのような仮入力~textを例示している入力~要素に合致する。
◎
Input elements can sometimes show placeholder text as a hint to the user on what to type in. See, for example, the placeholder attribute in [HTML5]. The :placeholder-shown pseudo-class matches an input element that is showing such placeholder text.
</p>

			</section>
			<section id="the-default-pseudo">
<h4 title="The Default-option Pseudo-class: :default">12.1.4. 既定option 疑似類	`default^ps</h4>

<p>
`default@ps
疑似類は、一連の要素の中で既定の選択肢にされているような，~UI要素を対象にする。
複数のものが既定にされていてもよい。
概して，
~context~menu項目,
~button,
~select~list,
~select~menu
が対象になる。
◎
The :default pseudo-class applies to the one or more UI elements that are the default among a set of similar elements. Typically applies to context menu items, buttons and select lists/menus.
</p>

<p>
例えば、一連の~buttonの中の既定の送信~buttonや,
~popup~menuの中の既定optionなど。
多数の選択肢がある~groupの中では<!-- （ピザ注文のトッピングなど） -->，複数の要素が `default$ps に合致し得る。
例えば `HTML5$r では、［
~formの中の “既定の” ~button,
`select^e 要素のうち初期~時に選択済みの `option^e 要素（複数も可）,
その他の少数の要素
］が、 `default$ps に合致するものとされている（
<a href="~SELECTORS-HTML#selector-default">参照</a>
）。
◎
One example is the default submit button among a set of buttons. Another example is the default option from a popup menu. In a select-many group (such as for pizza toppings), multiple elements can match :default. For example, [HTML5] defines that :default matches the “default button” in a form, the initially-selected &lt;option&gt;(s) in a &lt;select&gt;, and a few other elements.
</p>
			</section>
		</section>
		<section id="input-value-states">
<h3 title="Input Value States">12.2. 入力値の状態</h3>

			<section id="checked">
<h4 title="The Selected-option Pseudo-class: :checked">12.2.1. 選択済み疑似類	`checked^ps</h4>

<p>
~radio~buttonや~checkboxは，利用者により 2 つの状態に切り替えられ得る。
また、一部の~menu項目は，利用者がそれらを選択したときに “~checkされた状態” になる。
その種の要素が “~on” に切り替えられたとき
`checked@ps
疑似類の対象になる。
例えば `HTML5$r では、［
~checkされた状態の ~checkbox ／ ~radio~button,
選択済みの `option^e 要素
］が `checked^ps に合致するものと定義されている（
<a href="~SELECTORS-HTML#selector-checked">参照</a>
）。
◎
Radio and checkbox elements can be toggled by the user. Some menu items are "checked" when the user selects them. When such elements are toggled "on" the :checked pseudo-class applies. For example, [HTML5] defines that checked checkboxes, radio buttons, and selected &lt;option&gt; elements match :checked.
</p>

<p>
`checked$ps 疑似類は生来的に動的であり，利用者の動作により改められ得るものであるが、文書の中の意味論を与える属性の存在（
`HTML5$r の `selected^a 属性や `checked^a 属性など）に基づくものでもあるので，【静的なものも含めた】すべての媒体に適用される。
◎
While the :checked pseudo-class is dynamic in nature, and can altered by user action, since it can also be based on the presence of semantic attributes in the document (such as the selected and checked attributes in [HTML5]), it applies to all media.
</p>

<div class="example">
<p>
否定~疑似類を用いれば~checkされていない~checkboxも選択できる：
◎
An unchecked checkbox can be selected by using the negation pseudo-class:
</p>

<pre>input[type=checkbox]:not(:checked)</pre>

</div>

			</section>
			<section id="indeterminate">
<h4 title="The Indeterminate-value Pseudo-class: :indeterminate">12.2.2. 不定値 疑似類	`indeterminate^ps</h4>

<p>
`indeterminate@ps
疑似類は、値が不定の状態にある~UI要素を対象にする。
例えば、 ~radio~button／~checkbox の~UI要素は~checkの有無が切り替えられ得るが、そのいずれでもない不定の状態をとることがある。
同様に、進捗meterは完了率が未知であるときに，不定の状態をとり得る。
例えば `HTML5$r では、~checkboxがどのようなときに `indeterminate^ps に合致するかを定めている（
<a href="~SELECTORS-HTML#selector-indeterminate">参照</a>
）。
◎
The :indeterminate pseudo-class applies to UI elements whose value is in an indeterminate state. For example, radio and checkbox elements can be toggled between checked and unchecked states, but are sometimes in an indeterminate state, neither checked nor unchecked. Similarly a progress meter can be in an indeterminate state when the percent completion is unknown. For example, [HTML5] defines how checkboxes can be made to match :indeterminate.
</p>

<p>
`checked$ps 疑似類と同様に、 `indeterminate$ps も すべての媒体に適用される。
例えば，初期~時は未選択の~radio~groupの部品は、静的~表示の下でも `indeterminate$ps になる。
◎
Like the :checked pseudo-class, :indeterminate applies to all media. Components of a radio-group initialized with no pre-selected choice, for example, would be :indeterminate even in a static display.
</p>

			</section>
		</section>
		<section id="ui-validity">
<h3 title="Input Value-checking">12.3. 入力値の検査法</h3>

			<section id="validity-pseudos">
<h4 title="The Validity Pseudo-classes: :valid and :invalid">12.3.1. 妥当性 疑似類	`valid^ps, `invalid^ps</h4>

<p>
要素は，その内容あるいは値が文書~言語（例えば `XFORMS11$r や `HTML5$r ）により定義される~data妥当性~意味論に則って 妥当であるかどうかに従って，
`valid@ps （妥当である）／
`invalid@ps （妥当でない）
とされる。
~data妥当性~意味論を欠く要素は、これらの疑似類の対象にならない。
◎
An element is :valid or :invalid when its contents or value is, respectively, valid or invalid with respect to data validity semantics defined by the document language (e.g. [XFORMS11] or [HTML5]). An element which lacks data validity semantics is neither :valid nor :invalid.
</p>

<p class="note">注記：
拘束がなく, したがって常に `valid$ps になる要素と，~data妥当性~意味論を全く備えず, したがって `valid$ps でも `invalid$ps でもないものは、別物であることに注意。
例えば HTML では、 `p^e 要素や拘束のない `type="text"^s の `input^e 要素は，~data妥当性~意味論を備えないので、これらの疑似類に合致することは決してない。
◎
Note: There is a difference between an element which has no constraints, and thus would always be :valid, and one which has no data validity semantics at all, and thus is neither :valid nor :invalid. In HTML, for example, an &lt;input type="text"&gt; element may have no constraints, but a p element has no validity semantics at all, and so it never matches either of these pseudo-classes.
</p>

			</section>
			<section id="range-pseudos">
<h4 title="The Range Pseudo-classes: :in-range and :out-of-range">12.3.2. 範囲~疑似類	`in-range^ps, `out-of-range^ps</h4>

<p>
`in-range@ps
および
`out-of-range@ps
疑似類は、範囲に制限ionを備える要素のみに適用される。
要素は，要素に束縛されている値が文書~言語により定義される範囲の 範囲~内／範囲~外 にあるかに従って、それぞれ
`in-range$ps ／ `out-of-range$ps 
になる。
~data範囲に制限のない要素や, ~form~controlでない要素は、 `in-range$ps ／ `out-of-range$ps の対象にならない。
例えば 1 〜 10 の値のみを表現する~slider~controlとして呈示されている `slider^e 要素は，その値が 11 であれば `out-of-range$ps  になる。
あるいは、 "A", "B", "C" のみを~~選択肢に持つ~popup~menuとして呈示されている `menu^e 要素が値  "E" にされているときも。
◎
The :in-range and :out-of-range pseudo-classes apply only to elements that have range limitations. An element is :in-range or :out-of-range when the value that the element is bound to is in range or out of range with respect to its range limits as defined by the document language. An element that lacks data range limits or is not a form control is neither :in-range nor :out-of-range. E.g. a slider element with a value of 11 presented as a slider control that only represents the values from 1-10 is :out-of-range. Another example is a menu element with a value of "E" that happens to be presented in a popup menu that only has choices "A", "B" and "C".
</p>

			</section>
			<section id="opt-pseudos">
<h4 title="The Optionality Pseudo-classes: :required and :optional">12.3.3. 必須随意 疑似類	`required^ps, `optional^ps</h4>

<p>
~formをなす~form部品の要素は、その~formが妥当なものとして送信~可能になるために，その値が
必須なのか／随意（ optional ）なのか
に応じて
`required@ps ／ `optional@ps
の対象になる。
~form要素でない要素は、これらの対象にならない。
◎
A form element is :required or :optional if a value for it is, respectively, required or optional before the form it belongs to can be validly submitted. Elements that are not form elements are neither required nor optional.
</p>

<p class="trans-note">【
例えば HTML の下では、
`form^e 要素の外で用いられた `input^e 要素などの~form部品は，
“~form要素” とは見なされないかもしれない。
】</p>

			</section>
			<section id="user-pseudos">
<h4 title="The User-interaction Pseudo-class: :user-invalid">12.3.4. 利用者~対話 疑似類	`user-invalid^ps</h4>

<p>
`user-invalid@ps †
疑似類は、入力値が不正であるが，利用者がそれに対するやりとりを行った <em>後にのみ</em> 対象になる要素を表現する。
`user-invalid$ps 疑似類は、利用者が~formの送信を試みてから
利用者が再びその~form要素と意識的にやりとりする前までの間の，［
`invalid$ps ,
`out-of-range$ps ,
未~入力の `required$ps
］の要素に合致し~MUST。
~UA は，利用者に向けて~errorを強調することが適切であるときには、そのような要素に合致させてもよい。
例えば~UAは、利用者が一度 何らかの~textを~~手入力してから別の要素に~focusを移動させたときに， `invalid$ps な要素を `user-invalid$ps 合致するようにした上で、利用者が入力を成功裡に正した後にのみ，合致しないようにしてもよい。
【† 2015 年 9 月： ":user-error" から改称された。】
◎
The :user-invalid pseudo-class represents an element with incorrect input, but only after the user has significantly interacted with it. The :user-error pseudo-class must match an :invalid, :out-of-range, or blank-but-:required elements between the time the user has attempted to submit the form and before the user has interacted again with the form element. User-agents may allow it to match such elements at other times, as would be appropriate for highlighting an error to the user. For example, a UA may choose to have :user-error match an :invalid element once the user has typed some text into it and changed the focus to another element, and to stop matching only after the user has successfully corrected the input.
</p>

<div class="example">
<p>
例えば、次の文書~片における入力は、頁が読込まれ次第（初期~時の値（ `value=11^s ）が最大~値（ `max=10^s ）を超えているので）， `invalid$ps に合致することになるが、利用者が要素と意識的にやりとりするか,
それが属する~formの送信を試みるまでは， `user-invalid$ps に合致しない。
◎
For example, the input in the following document fragment would match :invalid as soon as the page is loaded (because it the initial value violates the max-constraint), but it won’t match :user-error until the user significantly interacts with the element, or attempts to submit the form it’s part of.
</p>



<pre>
&lt;form&gt;
  &lt;label&gt;
    Volume:
    &lt;input name='vol' type=number min=0 max=10 value=11&gt;
  &lt;/label&gt;
  ...
&lt;/form&gt;</pre>

</div>

<p class="issue">
`-moz-ui-invalid$ps と付き合わせて検査する。
◎
Cross-check with :-moz-ui-invalid.
</p>

<p class="issue">
WG による解決に従って
`-moz-ui-invalid$ps を `user-valid^ps として追加する。
◎
Add :-moz-ui-valid as :user-valid per WG resolution.
</p>

<p class="issue">
<a href="https://lists.w3.org/Archives/Public/www-style/2014Feb/0511.html">`dirty^ps 疑似類</a>
の提案を評価する必要がある。
◎
Evaluate proposed :dirty pseudo-class
</p>

<p class="issue">
これ（および `invalid$ps, `valid$ps ）が
`form^e, `fieldset^e 
要素にも適用し得ることを明確化する。
◎
Clarify that this (and :invalid/:valid) can apply to form and fieldset elements.
</p>



			</section>
		</section>
	</section>
	<section id="structural-pseudos">
<h2 title="Tree-Structural pseudo-classes">13. 木~構造上の疑似類</h2>

<p>
`構造上の疑似類@
は、［
文書~木の中に在るが, 他の`単体~選択子$や`結合子$では表現し得ないような，~~特別な追加~情報
］に基づく選択ionを可能にするために，導入された概念である。
◎
Selectors introduces the concept of structural pseudo-classes to permit selection based on extra information that lies in the document tree but cannot be represented by other simple selectors or combinators.
</p>

<p>
素の~textなどの非~要素~nodeは、親の中での子の位置（ “付番” ）の計算-時には数えられない。
この付番は 1 から開始される。
◎
Standalone text and other non-element nodes are not counted when calculating the position of an element in the list of children of its parent. When calculating the position of an element in the list of children of its parent, the index numbering starts at 1.
</p>

<p>
`構造上の疑似類$は文書~木 内の要素のみに適用される
—
それらは決して，`疑似要素$に合致しては~MUST_NOT。
◎
The structural pseudo-classes only apply to elements in the document tree; they must never match pseudo-elements.
</p>


		<section id="the-root-pseudo">
<h3 title=":root pseudo-class">13.1. `root^ps 疑似類</h3>

<p>
`root@ps
疑似類は、文書の根である要素を表現する。
◎
The :root pseudo-class represents an element that is the root of the document.
</p>

<p>
例えば DOM 文書においては、 `root$ps 疑似類は `Document$I ~objectの根~要素†に合致する。
HTML では、これは
<a href="~HTML5/semantics.html#the-html-element">`html^e</a>
要素になる（スクリプトにより文書が改変されない限り）。
◎
For example, in a DOM document, the :root pseudo-class matches the root element of the Document object. In HTML, this would be the html element (unless scripting has been used to modify the document).
</p>

<p class="trans-note">【†
紛らわしいが、文書~木の根（ `Document^I ）ではなく，その子であって, <em>要素である</em>ような，（唯一の）`文書~要素$を意味する。
】</p>

		</section>
		<section id="the-empty-pseudo">
<h3 title=":empty pseudo-class">13.2. `empty^ps 疑似類</h3>

<p>
`empty@ps
疑似類は、内容が “空” の要素を表現する。
文書~木の語で言い換えるなら、要素が空かどうかに影響するものは，［
要素~node（ `Element$I ）, および
空でない~dataを含む内容~node（ `DOM$r の~text~node（ `Text$I ）や実体参照（ `EntityReference$I ）など）
］であり，［
コメント（ `Comment$I ）, 処理命令（ `ProcessingInstruction$I ）, 他の~node
］は影響してはならない。
◎
The :empty pseudo-class represents an element that has no children at all. In terms of the document tree, only element nodes and content nodes (such as [DOM] text nodes, and entity references) whose data has a non-zero length must be considered as affecting emptiness; comments, processing instructions, and other nodes must not affect whether an element is considered empty or not.
</p>

<p class="trans-note">【
各~node種別の括弧内の~interface名は、訳者補足。
最新の DOM4 `DOM$r では：
“他の~node” は、文書（ `Document$I ）, 文書片（ `DocumentFragment$I ）, 文書型宣言（ `DocumentType$I ）を指す。
また、実体参照は廃止されている（置換後の状態において解釈されることになると見られる）。
】</p>


<div class="example">

<p>
`p:empty^S
は次の片に対する有効な表現になる：
◎
Examples: p:empty is a valid representation of the following fragment:
</p>

<pre>&lt;p&gt;&lt;/p&gt;</pre>

<p>
`foo:empty^S
は次の片に対する有効な表現にはならない：
◎
foo:empty is not a valid representation for the following fragments:
</p>

<pre>&lt;foo&gt;bar&lt;/foo&gt;</pre>

<pre>&lt;foo&gt;&lt;bar&gt;bla&lt;/bar&gt;&lt;/foo&gt;</pre>

<pre>&lt;foo&gt;this is not &lt;bar&gt;:empty&lt;/bar&gt;&lt;/foo&gt;</pre>

</div>

		</section>
		<section id="the-blank-pseudo">
<h3 title=":blank pseudo-class">13.3. `blank^ps 疑似類</h3>

<p>
`blank@ps
疑似類は、内容が
<a href="~CSSTEXT#white-space-rules">空白~処理に影響される文字</a>
`CSS3TEXT$r
のみからなる要素にも 追加で合致することを除いて， `empty$ps 疑似類と同様である。
◎
The :blank pseudo-class is like the :empty pseudo-class, except that it additionally matches elements that only contain code points affected by whitespace processing. [CSS3TEXT]
</p>

<div class="example">
<p>
例えば、次の要素は改行が含まれているので， `blank$ps には合致するが, `empty$ps には合致しない：
◎
For example, the following element matches :blank, but not :empty, because it contains at least one linebreak, and possibly other whitespace:
</p>

<pre>&lt;p&gt;<br>&lt;/p&gt;</pre>

</div>

<p class="issue">
`blank$ps の様な名前は、 `empty$ps との相違が明瞭でなく，好ましくない。
Moz が利用している
`-moz-whitespace-only^ps
は明瞭だが，少々長い。
他に良案は？
◎
We don’t like the name :blank—it doesn’t clearly convey a difference from :empty. Moz uses :-moz-whitespace-only, which is clear but a little wordy. Any other suggestions?
</p>

		</section>
		<section id="child-index">
<h3 title="Child-indexed Pseudo-classes">13.4. 子付番 疑似類</h3>


<p>
この節にて定義される疑似類は、要素の`同胞群$における付番
【要素はその同胞群の中で何番目に位置するか】
に基づいて選択する。
◎
The pseudo-classes defined in this section select elements based on their index amongst their inclusive siblings.
</p>

<p>
この節, および後続の節に現れる
<dfn id="AnB-notation">~AnB 記法</dfn>
の詳細は、
CSS Syntax Module `CSS3SYN$r にて<a href="~CSSSYN#anb-microsyntax">定義される</a>。
</p>

<p class="note">注記：
Selectors 3 では、これらの選択子について［［
要素の親の，子~list
］における，要素の付番
］に基いて，要素を選択するものとして述べていた（この記述は、この very 節, および いくつかの疑似類の下で生き残る【？】）。
要素が親を持たない場合や, 要素の親が要素でない場合を除外する理由はないので、同胞たち（`同胞群$）の中での要素の相対的な付番と言い換えられた。
◎
Note: Selectors 3 described these selectors as selecting elements based on their index in the child list of their parents. (This description survives in the name of this very section, and the names of several of the pseudo-classes.) As there was no reason to exclude them from matching elements without parents, or with non-element parents, they have been rephrased to refer to an element’s relative index amongst its siblings.
</p>


<p>
【用語定義追加：】
要素 ~E の
`同胞群@
とは、 ~E と`広義同胞$の関係にある要素たちからなる集合である（ ~E 自身は常に含まれる）。
単に “同胞群” と記されたときは、文書~木~内の何らかの要素の`同胞群$を意味する。
</p>

<div class="trans-note">
<p >【
定義により、親が要素でない要素（例えば `html^e 要素）であっても，その`同胞群$は、要素を含む（要素のみからなる）集合になる。
しかしながら，現実の（ある割合の）~browser実装では、親~要素の存在が要求されている
— 例えば，選択子 `html:first-child^css は、 `html^e 要素に合致しない（その同胞群は空集合と見做されている。
あるいは、 HTML の文脈に限って，どこかでそう規定されているのかもしれない）。
】</p>

</div>



			<section id="the-nth-child-pseudo">
<h4 title=":nth-child() pseudo-class">13.4.1. `nth-child()^ps 疑似類</h4>

<p>
疑似類~記法
`nth-child(~AnB [of ~S]? )@ps
は、各 `同胞群$ごとに，その中で［
`選択子~list$ ~S に合致するもの
］のうち， ~AnBthの要素を表現する。
◎
The :nth-child(An+B [of S]? ) pseudo-class notation represents the An+Bth element that matches the selector list S among its inclusive siblings.
</p>

<p>
`of ~S^css が省略された場合の既定の `~S^css は，`全称~選択子$ `*^css になる。
◎
The CSS Syntax Module [CSS3SYN] defines the An+B notation. If S is omitted, it defaults to *.
</p>

<p>
この選択子は、例えば，~table内の横筋を飛び飛びに選択したり, 段落の~text色を一定周期で順繰りに変えていく用途に利用できる。
◎
For example, this selector could address every other row in a table, and could be used to alternate the color of paragraph text in a cycle of four.
</p>

<div class="example">
<p lang="en">Examples:</p>

<pre>
:nth-child(even)   /* <span class="comment">2, 4, 6, … 番目の要素を表現する</span> */
:nth-child(10n-1)  /* <span class="comment">9, 19, 29, … 番目の要素を表現する</span> */
:nth-child(10n+9)  /* <span class="comment">同じ</span> */
:nth-child(10n+-1) /* <span class="comment">構文が妥当でないので無視される</span> */◎
:nth-child(even)   /* represents the 2nd, 4th, 6th, etc elements
:nth-child(10n-1)  /* represents the 9th, 19th, 29th, etc elements */
:nth-child(10n+9)  /* Same */
:nth-child(10n+-1) /* Syntactically invalid, and would be ignored */</pre>
</div>

<div class="example">
<p>
引数に選択子も渡せば、その選択子に合致するものから， N 番目の要素を選択できる。
例えば、次の選択子は、 `important^s ~classに属する~list項目のうちの，最初の 3 個に合致する：
◎
By passing a selector argument, we can select the Nth element that matches that selector. For example, the following selector matches the first three “important” list items, denoted by the .important class:
</p>

<pre>:nth-child(-n+3 of li.important)</pre>

<p>
これは、引数に与えた選択子を，次の様に関数の外側に出したものとは異なることに注意：
◎
Note that this is different from moving the selector outside of the function, like:
</p>

<pre>li.important:nth-child(-n+3)</pre>

<p>
この選択子は、単に最初の 3 個の~list項目のうち， `important^s ~classに属するものを選択する。
◎
This selector instead just selects the first three children if they also happen to be "important" list items.
</p>

</div>



<div class="example">
<p>
引数に選択子を用いて、~tableを正しく縞模様にさせる例を示す。
◎
Here’s another example of using the selector argument, to ensure that zebra-striping a table works correctly.
</p>

<p>
通常，~tableの横筋を縞模様にするときは、次の様な CSS を用いることになるだろう：
◎
Normally, to zebra-stripe a table’s rows, an author would use CSS similar to the following:
</p>

<pre>
tr {
  background: white;
}
tr:nth-child(even) {
  background: silver;
}
</pre>

<p>
しかしながら，いずれかの横筋が隠されて表示されなくなった場合、それを挟む同じ背景色の横筋が隣り合い，~patternが崩れる。
横筋が HTML の `hidden^a 属性により隠されるとするなら、次の CSS により，どの横筋が隠されようが，背景色は適正に交替され、一連の横筋は安定的に縞模様になる：
◎
However, if some of the rows are hidden and not displayed, this can break up the pattern, causing multiple adjacent rows to have the same background color. Assuming that rows are hidden with the [hidden] attribute in HTML, the following CSS would zebra-stripe the table rows robustly, maintaining a proper alternating background regardless of which rows are hidden:
</p>

<pre>
tr {
  background: white;
}
tr:nth-child(even of :not([hidden])) {
  background: silver;
}
</pre>


</div>



			</section>
			<section id="the-nth-last-child-pseudo">
<h4 title=":nth-last-child() pseudo-class">13.4.2. `nth-last-child()^ps 疑似類</h4>

<p>
疑似類~記法
`nth-last-child(~AnB [of ~S]? )@ps
は、各 `同胞群$ごとに，その中で［
`選択子~list$ ~S に合致するもの
］のうち，最後から~AnBthの要素を表現する。
◎
The :nth-last-child(An+B [of S]? ) pseudo-class notation represents the An+Bth element that matches the selector list S among its inclusive siblings, counting backwards from the end.
</p>

<p>
`of ~S^css が省略された場合の既定の `~S^css は，`全称~選択子$ `*^css になる。
◎
The CSS Syntax Module [CSS3SYN] defines the An+B notation. If S is omitted, it defaults to *.
</p>

<div class="example">
<p lang="en">Examples:</p>

<pre>
tr:nth-last-child(-n+2)  /* <span class="comment">
HTML ~table内の最後の 2 本の横筋を表現する
◎
represents the two last rows of an HTML table
</span> */

foo:nth-last-child(odd)  /* <span class="comment">
`同胞群$の中で，最後から数えて，奇数~番目にある foo 要素を表現する
◎
represents all odd foo elements in their parent element, counting from the last one
</span> */</pre>
</div>

			</section>
			<section id="the-first-child-pseudo">
<h4 title=":first-child pseudo-class">13.4.3. `first-child^ps 疑似類</h4>

<p>
`first-child@ps
疑似類は、各 `同胞群$ごとに，その中の最初の要素を表現する。
これは
`:nth-child(1)^css
と同じである。
◎
The :first-child pseudo-class represents an element that if first among its inclusive siblings. Same as :nth-child(1).
</p>

<div class="example">

<p>
次の選択子は
`div^e 要素の最初の子である
`p^e 要素を表現する：
◎
Examples: The following selector represents a p element that is the first child of a div element:
</p>

<pre>div &gt; p:first-child</pre>

<p>
この選択子は、次の片の `div^e 要素の内側の `p^e 要素を表現する：
◎
This selector can represent the p inside the div of the following fragment:
</p>

<pre>
&lt;p&gt; .note の前の最後の P&lt;/p&gt;
&lt;div class="note"&gt;
&lt;p&gt; .note 内の最初の P&lt;/p&gt;
&lt;/div&gt;◎
&lt;p&gt; The last P before the note.&lt;/p&gt;
&lt;div class="note"&gt;
&lt;p&gt; The first P inside the note.&lt;/p&gt;
&lt;/div&gt;</pre>

<p>
が、次の片の 2 番目の `p^e 要素は表現しない：
◎
but cannot represent the second p in the following fragment:
</p>

<pre>
&lt;p&gt; .note の前の最後の P&lt;/p&gt;
&lt;div class="note"&gt;
&lt;h2&gt; Note &lt;/h2&gt;
&lt;p&gt; .note 内の最初の P&lt;/p&gt;
&lt;/div&gt;◎
&lt;p&gt; The last P before the note.&lt;/p&gt;
&lt;div class="note"&gt;
&lt;h2&gt; Note &lt;/h2&gt;
&lt;p&gt; The first P inside the note.&lt;/p&gt;
&lt;/div&gt;</pre>

<p>
通例においては，次の 2 つの選択子は等価になる：
◎
The following two selectors are usually equivalent:
</p>

<pre>
* &gt; a:first-child   /* <span class="comment">
a は任意の要素の最初の子~要素
◎
a is first child of any element
</span> */
a:first-child       /* <span class="comment">
同じ（ a は根~要素でないとする）
◎
Same (assuming a is not the root element)
</span> */
</pre>

</div>

			</section>
			<section id="the-last-child-pseudo">
<h4 title=":last-child pseudo-class">13.4.4. `last-child^ps 疑似類</h4>

<p>
`last-child@ps
疑似類は、各 `同胞群$ごとに，その中の最後の要素を表現する。
これは
`:nth-last-child(1)^css
と同じである。
◎
The :last-child pseudo-class represents an element that is last among its inclusive siblings. Same as :nth-last-child(1).
</p>

<div class="example">

<p>
次の選択子は
“有順序~list” `ol^e 要素の最後の子である
“~list項目” `li^e 要素を表現する：
◎
Example: The following selector represents a list item li that is the last child of an ordered list ol.
</p>

<pre>ol &gt; li:last-child</pre>

</div>

			</section>
			<section id="the-only-child-pseudo">
<h4 title=":only-child pseudo-class">13.4.5. `only-child^ps 疑似類</h4>

<p>
`only-child@ps
疑似類は、自身の他に同胞要素は存在しないものを表現する。
これは，［
`:first-child:last-child^css ／
`:nth-child(1):nth-last-child(1)^css
］と同じになるが、`詳細度$は これらより低くなる。
◎
The :only-child pseudo-class represents an element that has no siblings. Same as :first-child:last-child or :nth-child(1):nth-last-child(1), but with a lower specificity.
</p>

			</section>
		</section>
		<section id="typed-child-index">
<h3 title="Typed Child-indexed Pseudo-classes">13.5. 型指定 子付番 疑似類</h3>

<p>
この節の`疑似類$は，`子付番 疑似類§に類似するが、
<strong><a href="#type-selectors">同じ型の要素</a>の集合に限定された中で</strong>，要素の`同胞群$における要素の付番に基づいて解決される。
<!-- ＊ 原文 pseudo-element 誤記 -->
◎
The pseudo-elements in this section are similar to the Child Index Pseudo-classes, but they resolve based on an element’s index among elements of the same type (tag name) in their sibling list.
</p>

			<section id="the-nth-of-type-pseudo">
<h4 title=":nth-of-type() pseudo-class">13.5.1. `nth-of-type()^ps 疑似類</h4>

<p>
疑似類~記法
`nth-of-type(~AnB)@ps
は、各 `同胞群$ごとに，その中で［
互いに`型$が同じ, かつ 同じ`名前空間$に属するような要素たち
］のうち，~AnBthのものを表現する。
◎
The :nth-of-type(An+B) pseudo-class notation represents the An+Bth element with the same namespace and type among its inclusive siblings.
◎
The CSS Syntax Module [CSS3SYN] defines the An+B notation.
</p>

<div class="example">

<p>
これにより，複数の画像を交替的に float 配置させられる：
◎
CSS example: This allows an author to alternate the position of floated images:
</p>

<pre>
img:nth-of-type(2n+1) { float: right; }
img:nth-of-type(2n) { float: left; }</pre>

<p class="trans-note">【
仮に， `img^css を`全称~選択子$に置き換えたなら、`同胞群$を各 要素~型ごとに~group分けした下で，各~groupごとに個別に適用されることになる。
<!-- および，各 名前空間？ -->
】</p>

</div>

<p class="note">注記：
要素の型が事前に既知ならば、この疑似類は，型~選択子も伴う `nth-child()$ps の利用に等価になる。
すなわち、 `img:nth-of-type(2)^s は， `*:nth-child(2 of img)^s と等価になる。
◎
Note: If the type of the element is known ahead of time, this pseudo-class is equivalent to using :nth-child() with a type selector. That is, img:nth-of-type(2) is equivalent to *:nth-child(2 of img).
</p>


			</section>
			<section id="the-nth-last-of-type-pseudo">
<h4 title=":nth-last-of-type() pseudo-class">13.5.2. `nth-last-of-type()^ps 疑似類</h4>

<p>
疑似類~記法
`nth-last-of-type(~AnB)@ps
は、各 `同胞群$ごとに，その中で［
互いに`型$が同じ, かつ 同じ`名前空間$に属するような要素たち
］のうち，最後から~AnBthのものを表現する。
◎
The :nth-last-of-type(An+B) pseudo-class notation represents the An+Bth element with the same namespace and type among its inclusive siblings, counting backwards from the end.
◎
The CSS Syntax Module [CSS3SYN] defines the An+B notation.
</p>

<div class="example">

<p>
次の選択子により、 `body^e 要素の子であって, 最初と最後を除くすべての `h2^e 要素を表現することが可能になる：
◎
Example: To represent all h2 children of an XHTML body except the first and last, one could use the following selector:
</p>

<pre>body &gt; h2:nth-of-type(n+2):nth-last-of-type(n+2)</pre>

<p>
この場合，`not()$ps を用いる方法もある（選択子の記述は同じ長さに）：
◎
In this case, one could also use :not(), although the selector ends up being just as long:
</p>

<pre>body &gt; h2:not(:first-of-type):not(:last-of-type)</pre>

</div>

			</section>
			<section id="the-first-of-type-pseudo">
<h4 title=":first-of-type pseudo-class">13.5.3. `first-of-type^ps 疑似類</h4>

<p>
`first-of-type@ps
疑似類は、各 `同胞群$ごとに，その中で［
互いに`型$が同じ, かつ 同じ`名前空間$に属するような要素たち
］のうち，最初のものを表現する。
これは
`:nth-of-type(1)^css
と同じである。
◎
The :first-of-type pseudo-class represents an element that is the first with a particular namespace and type among its inclusive siblings. Same as :nth-of-type(1).
</p>

<div class="example">

<p>
次の選択子は、“定義~list” `dl^e の中で最初の“定義~~見出し” `dt^e を表現する。
すなわち この `dt^e は親の `dl^e 要素の子~要素~listの中で，その型の最初の要素になる：
◎
Example: The following selector represents a definition title dt inside a definition list dl, this dt being the first of its type in the list of children of its parent element.
</p>

<pre>dl dt:first-of-type</pre>

<p>
これは，次の例の最初の 2 つの `dt^e 要素に対する有効な記述になるが，３番目のものについてはそうならない：
◎
It is a valid description for the first two dt elements in the following example but not for the third one:
</p>

<pre>
&lt;dl&gt;
  &lt;dt&gt;gigogne&lt;/dt&gt;
  &lt;dd&gt;
    &lt;dl&gt;
      &lt;dt&gt;fusée&lt;/dt&gt;
      &lt;dd&gt;multistage rocket&lt;/dd&gt;
      &lt;dt&gt;table&lt;/dt&gt;
      &lt;dd&gt;nest of tables&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/dd&gt;
&lt;/dl&gt;</pre>

</div>

			</section>
			<section id="the-last-of-type-pseudo">
<h4 title=":last-of-type pseudo-class">13.5.4. `last-of-type^ps 疑似類</h4>

<p>
`last-of-type@ps
疑似類は、各 `同胞群$ごとに，その中で［
互いに`型$が同じ, かつ 同じ`名前空間$に属するような要素たち
］のうち，最後のものを表現する。
これは
`:nth-last-of-type(1)^css
と同じである。
◎
The :last-of-type pseudo-class represents an element that is the first with a particular namespace and type among its inclusive siblings, counting backwards from the end. Same as :nth-last-of-type(1).
</p>

<div class="example">

<p>
次の選択子は、~tableの各 “横筋” `tr^e 要素の最後の “~data~cell” `td^e 要素を表現する：
◎
Example: The following selector represents the last data cell td of a table row tr.
</p>

<pre>tr &gt; td:last-of-type</pre>

</div>

			</section>
			<section id="the-only-of-type-pseudo">
<h4 title=":only-of-type pseudo-class">13.5.5. `only-of-type^ps 疑似類</h4>

<p>
`only-of-type@ps
疑似類は、自身の他に［
互いに`型$が同じ, かつ 同じ`名前空間$に属するような同胞要素
］は存在しない要素を表現する。
これは，［
`:first-of-type:last-of-type^css ／
`:nth-of-type(1):nth-last-of-type(1)^css
］と同じになるが、`詳細度$はこれらより低くなる。
◎
The :only-of-type pseudo-class represents an element that has no siblings with the same namespace and type Same as :first-of-type:last-of-type or :nth-of-type(1):nth-last-of-type(1), but with a lower specificity.
</p>

			</section>
		</section>
	</section>
	<section id="combinators">
<h2 title="Combinators">14. 結合子</h2>

		<section id="descendant-combinators">
<h3 title="Descendant combinator ( ) or (&gt;&gt;)">14.1. 子孫~結合子	( SPACE ) または (`&gt;&gt;^css)</h3>


<p>
文書~木の中で，別の要素の子孫であるような要素を記述する選択子が望まれることがある（例えば
“ `h1^e 要素に包含されている `em^e 要素”
）。
`子孫~結合子@
は、その種の関係性を表す。
構文上は、次の２種の形をとる：
◎
At times, authors may want selectors to describe an element that is the descendant of another element in the document tree (e.g., "an em element that is contained within an H1 element"). The descendant combinator expresses such a relationship. It has two syntactic forms:
</p>

<ol>
	<li>
２つの`合体~選択子$を区切る`空白$,
<em>または</em>
◎
whitespace that separates two compound selectors or
</li>

	<li>
二重にされた子~選択子（
<dfn id="selectordef-descendant">`&gt;&gt;^css</dfn>
）
◎
A doubled child selector (&gt;&gt;)
</li>
</ol>

<p>
［
`A B^css
］または［
`A &gt;&gt; B^css
］の形による選択子は、何らかの先祖である `A^e 要素の子孫であるような，任意の `B^e 要素を表現する。
◎
A selector of the form A B or A &gt;&gt; B' represents an element B that is an arbitrary descendant of some ancestor element A.
</p>


<div class="example">
<p>
次の選択子を考える：
◎
Examples: For example, consider the following selector:
</p>

<pre>h1 em</pre>

<p>
これは、 `h1^e 要素の子孫である `em^e 要素を表現する。
それは次の片の一部分に対する有効な記述になる:
◎
It represents an em element being the descendant of an h1 element. It is a correct and valid, but partial, description of the following fragment:
</p>

<pre>
&lt;h1&gt;この&lt;span class="myclass"&gt;見出し行は
&lt;em&gt;とても&lt;/em&gt;重要です&lt;/span&gt;&lt;/h1&gt;</pre>
<!-- 
&lt;h1&gt;This &lt;span class="myclass"&gt;headline
is &lt;em&gt;very&lt;/em&gt; important&lt;/span&gt;&lt;/h1&gt;
-->
<p>
次の選択子：
◎
The following selector:
</p>

<pre>div * p</pre>

<p>
は、
`div^e 要素の孫（子の子）またはより遠い子孫である
`p^e 要素を表現する。
"`*^css" の両側にある`空白$は`全称~選択子$の一部をなさないことに注意。
この`空白$は`結合子$である  — すなわち，
`div^e 要素が 何らかの要素 ~E の先祖であって, かつ
~E が `p^e 要素の先祖でなければならないことを指示している。
◎
represents a p element that is a grandchild or later descendant of a div element. Note the whitespace on either side of the "*" is not part of the universal selector; the whitespace is a combinator indicating that the div must be the ancestor of some element, and that that element must be an ancestor of the p. The following selector, which combines descendant combinators and attribute selectors, represents an element that (1) has the href attribute set and (2) is inside a p that is itself inside a div:
</p>

<p>
`子孫~結合子$と`属性~選択子§を組合せる次の選択子は、
`href^a 属性が設定されていて, かつ
`div^e 要素の内側にある `p^e 要素の内側にあるような要素を表現する：
◎
↑</p>

<pre>div p *[`href^a]</pre>

</div>

<p class="note">注記：
空白~形は CSS Level 1 から存在している一方、
`&gt;&gt;^css 形は Level 4 から導入された。
それは、子孫~結合子を可視の非~空白~形にして，
`子~結合子$（ `&gt;^css ）と［
~shadowを貫く（ shadow-piercing ）子孫~結合子
］（ `&gt;&gt;&gt;^css ） `CSS-SCOPING-1$r の間の欠落を埋めるために導入された。
◎
Note: Note that the whitespace form has existed since CSS Level 1, whereas the &gt;&gt; form is introduced in Level 4. It was introduced to give the descendant combinator a visible, non-whitespace form and to bridge the gap between the child combinator (&gt;) and the shadow-piercing descendant combinator (&gt;&gt;&gt;) [CSS-SCOPING-1].
</p>


		</section>
		<section id="child-combinators">
<h3 title="Child combinator (&gt;)">14.2. 子~結合子	(`&gt;^css)</h3>

<p>
`子~結合子@
は、要素と要素の親子関係を記述し， 2 つの`合体~選択子$を区切る
“大なり記号” 符号位置（
<dfn id="selectordef-child">`&gt;^css</dfn>
`003E^cp
）で記される。
◎
A child combinator describes a childhood relationship between two elements. A child combinator is made of the "greater-than sign" (U+003E, &gt;) code point and separates two compound selectors.
</p>

<div class="example">
<p>
次の選択子は、 `body^e 要素の子であるような `p^e 要素を表現する：
◎
Examples: The following selector represents a p element that is child of body:
</p>

<pre>body &gt; p</pre>

<p>
`子孫~結合子$と`子~結合子$を組合せる用例：
◎
The following example combines descendant combinators and child combinators.
</p>

<pre>div ol&gt;li p</pre>
   <!-- LEAVE THOSE SPACES OUT! see below -->
<p>
これは
`li^e 要素の子孫であるような `p^e 要素を表現するが，
`li^e 要素は `ol^e 要素の子でなければならず，
`ol^e 要素は `div^e 要素の子孫で~MUST。

結合子 "`&gt;^css" の前後の`空白$が省略されていることに注意。
◎
It represents a p element that is a descendant of an li element; the li element must be the child of an ol element; the ol element must be a descendant of a div. Notice that the optional white space around the "&gt;" combinator has been left out.
</p></div>

<p>
要素の最初の子を選択するような類いのものについては、上述の`構造上の疑似類§ 節を見よ。
◎
For information on selecting the first child of an element, please see the section on the :first-child pseudo-class above.
</p>

		</section>
		<section id="adjacent-sibling-combinators">
<h3 title="Next-sibling combinator (+)">14.3. 次同胞~結合子	(`+^css)</h3>

<p>
`次同胞~結合子@
は、 2 つの`合体~選択子$を区切る
“正符号” 符号位置（
<dfn id="selectordef-adjacent">`+^css</dfn>
`002B^cp
）で記される。
2 つの`合体~選択子$で表現される要素は、文書~木の中で同じ親を共有し，最初の`合体~選択子$で表現される要素が  2 番目のもので表現される要素の直前に位置する。
要素でない~node（例えば，要素~間に挟まれた~text）は、要素の隣接性を考慮する際には無視される。
◎
The next-sibling combinator is made of the “plus sign” (U+002B, +) code point that separates two compound selectors. The elements represented by the two compound selectors share the same parent in the document tree and the element represented by the first compound selector immediately precedes the element represented by the second one. Non-element nodes (e.g. text between elements) are ignored when considering the adjacency of elements.
</p>

<div class="example">
<p>
次の選択子は、 `math^e 要素の直後に位置する `p^e 要素を表現する：
◎
Examples: The following selector represents a p element immediately following a math element:
</p>

<pre>math + p</pre>

<p>
次の選択子は、`属性~選択子$が付加されている
—
`h1^e 要素が `opener^s ~classに属する拘束が追加されている
—
ことを除いて，前の例のものと概念的に同様になる：
◎
The following selector is conceptually similar to the one in the previous example, except that it adds an attribute selector — it adds a constraint to the h1 element, that it must have class="opener":
</p>

<pre>h1.opener + h2</pre>

</div>

		</section>
		<section id="general-sibling-combinators">
<h3 title="Following-sibling combinator (~)">14.4. 後続同胞~結合子	(`~^css)</h3>

<p>
`後続同胞~結合子@
は、 2 つの`合体~選択子$を区切る
“~tilde” 符号位置（
<dfn id="selectordef-sibling">`~^css</dfn>
`007E^cp
）で記される。
2 つの`合体~選択子$で表現される要素は、文書~木の中で同じ親を共有し，最初の`合体~選択子$で表現される要素が， 2 番目のもので表現される要素よりも先行する（直前でなくともよい）。
◎
The following-sibling combinator is made of the "tilde" (U+007E, ~) code point that separates two compound selectors. The elements represented by the two compound selectors share the same parent in the document tree and the element represented by the first compound selector precedes (not necessarily immediately) the element represented by the second one.
</p>

<div class="example">

<pre>h1 ~ pre</pre>

<p>
は、 `h1^e 要素に後続する `pre^e 要素を表現する。
それは次の片の一部分に対する有効な記述になる：
◎
represents a pre element following an h1. It is a correct and valid, but partial, description of:
</p>

<pre>
&lt;h1&gt;~~関数 a の~~定義&lt;/h1&gt;
&lt;p&gt;この表のすべての図には Function a(x) を~~適用すること。&lt;/p&gt;
&lt;pre&gt;function a(x) = 12x/13.5&lt;/pre&gt;</pre>
<!-- 
&lt;h1&gt;Definition of the function a&lt;/h1&gt;
&lt;p&gt;Function a(x) has to be applied to all figures in the table.&lt;/p&gt;
&lt;pre&gt;function a(x) = 12x/13.5&lt;/pre&gt;
-->
</div>

		</section>
	</section>
	<section id="table-pseudos">
<h2 title="Grid-Structural Selectors">15. 格子構造~選択子</h2>

<p>
2 次元~格子の~cellの（その横筋と縦筋への）二重の所属関係は、階層的~markup言語における親子関係では，一方のみしか 表現し得ず、もう一方の所属関係は，文書~言語の意味論において明示的／暗黙的に定義され~MUST。
2 つの最も普及している階層的~markup言語である HTML と DocBook の両者とも，~markupは横筋~主導であり（すなわち，横筋への所属関係が階層で表現される）、縦筋については言外に与えられ~MUST。
<!--  -->
その種の縦筋への言外の所属関係を表現し得るようにするため、
`~column結合子$ および `nth-column()$ps , `nth-last-column()$ps  疑似類が定義される。
縦筋~主導の文書~言語においては、これらの疑似類は，横筋への所属関係に合致する。
◎
The double-association of a cell in a 2D grid (to its row and column) cannot be represented by parentage in a hierarchical markup language. Only one of those associations can be represented hierarchically: the other must be explicitly or implicitly defined in the document language semantics. In both HTML and DocBook, two of the most common hierarchical markup languages, the markup is row-primary (that is, the row associations are represented hierarchically); the columns must be implied. To be able to represent such implied column-based relationships, the column combinator and the :nth-column() and :nth-last-column() pseudo-classes are defined. In a column-primary format, these pseudo-classes match against row associations instead.
</p>

		<section id="the-column-combinator">
<h3 title="Column combinator">15.1. ~column結合子</h3>

<p>
`~column結合子@
は、~column要素
【［行／列］主導の階層的~markup言語の下で［列／行］を指示する要素】
が表現する~columnへの~cell要素の所属関係を表現し，
文字 ❝| を 2 個~並べて記される（
<dfn id="selectordef-column">`||^css</dfn>
）。
~columnへの所属は，文書~言語の意味論のみに基づいて決定される
— 要素が呈示されるかどうかや, どのように呈示されるかに関わりなく。
複数の~columnに属する~cell要素は、それらのどの~columnへの所属を指示する選択子でも，表現される。
◎
The column combinator, which consists of two pipes (||) represents the relationship of a column element to a cell element belonging to the column it represents. Column membership is determined based on the semantics of the document language only: whether and how the elements are presented is not considered. If a cell element belongs to more than one column, it is represented by a selector indicating membership in any of those columns.
</p>

<div class="example">
<p>
次の例では，~cell C, E, G に~style（ `background: gray^S, 等々）が適用される。
◎
The following example makes cells C, E, and G gray.
</p>

<pre>
col.selected || td {
  background: gray;
  color: white;
  font-weight: bold;
}</pre>

<pre>
&lt;table&gt;
      &lt;col span="2"    &gt; &lt;col class="selected"&gt;
  &lt;tr&gt;&lt;td&gt; A &lt;td&gt;      B &lt;td&gt; C
  &lt;tr&gt;&lt;td colspan="2"&gt; D &lt;td&gt; E
  &lt;tr&gt;&lt;td&gt; F &lt;td colspan="2"&gt; G
&lt;/table&gt;</pre>

</div>

		</section>
		<section id="the-nth-column-pseudo">
<h3 title=":nth-column() pseudo-class">15.2. `nth-column()^ps 疑似類</h3>

<p>
疑似類~記法
`nth-column(~AnB)@ps
は、同胞の~column間で~AnBthの~columnに属する~cell要素を表現する。
~columnへの所属の定義は、`~column結合子$を見よ。
◎
The :nth-column(An+B) pseudo-class notation represents a cell element belonging to a column that has An+B-1 columns before it, for any positive integer or zero value of n. Column membership is determined based on the semantics of the document language only: whether and how the elements are presented is not considered. If a cell element belongs to more than one column, it is represented by a selector indicating any of those columns.
◎
The CSS Syntax Module [CSS3SYN] defines the An+B notation.
</p>

		</section>
		<section id="the-nth-last-column-pseudo">
<h3 title=":nth-last-column() pseudo-class">15.3. `nth-last-column()^ps 疑似類</h3>

<p>
疑似類~記法
`nth-last-column(~AnB)@ps
は、同胞†の~column間で最後から~AnBthの~columnに属する~cell要素を表現する。
~columnへの所属の定義は、`~column結合子$を見よ。
【†どの~columnが互いに “同胞” とされるかについては、文書~言語が規定することになるであろう。】
◎
The :nth-last-column(An+B) pseudo-class notation represents a cell element belonging to a column that has An+B-1 columns after it, for any positive integer or zero value of n. Column membership is determined based on the semantics of the document language only: whether and how the elements are presented is not considered. If a cell element belongs to more than one column, it is represented by a selector indicating any of those columns.
◎
The CSS Syntax Module [CSS3SYN] defines the An+B notation.
</p>

		</section>
	</section>
	<section id="specificity-rules">
<h2 title="Calculating a selector’s specificity">16. 選択子の詳細度の計算</h2>

<p>
選択子（`複体~選択子$）の
`詳細度@
は、次の様にして，与えられた要素に対して計算される：
◎
A selector’s specificity is calculated for a given element as follows:
</p>

<!-- 
詳細度： CSS の下では，（概ね）ある出自~levelの~style適用の優先順位を与える。
-->

<ul>
	<li>
選択子の中の `ID 選択子$の個数を数える（ = %A ）
◎
count the number of ID selectors in the selector (= A)
</li>

	<li>
選択子の中の［
`~class選択子$, `属性~選択子$, `疑似類§
］の個数を数える（ = %B ）
◎
count the number of class selectors, attributes selectors, and pseudo-classes in the selector (= B)
</li>

	<li>
選択子の中の［
`型~選択子$, `疑似要素$
］の個数を数える（ = %C ）
◎
count the number of type selectors and pseudo-elements in the selector (= C)
</li>

	<li>
`全称~選択子$は無視する
◎
ignore the universal selector
</li></ul>

<p>
`選択子~list$の詳細度は、~list内の［
要素に合致するような複体~選択子
］のうち，その詳細度が最大のものになる。
【したがって、詳細度は，どの要素に合致したかにも依存することになる。】
◎
If the selector is a selector list, this number is calculated for each selector in the list, and the specificity of the entire selector is the largest of any individual selector in the list that matches the element.
</p>


<p>
疑似類のうち少数のものは、他の選択子に対する “評価~文脈” を提供し、詳細度は，それらの内容, および どう合致するかにより定義される：
◎
A few pseudo-classes provide "evaluation contexts" for other selectors, and so have their specificity defined by their contents and how they match:
</p>

<ul>
	<li>
<p>
`matches()$ps 疑似類の詳細度は、その引数である選択子~listの詳細度に置換される。
（選択子~全体の詳細度は、 `matches()$ps を外した下で，すべての組合せを全部的に展開したもの†と等価になる。）
◎
The specificity of a :matches() pseudo-class is replaced by the specificity of its selector list argument. (The full selector’s specificity is equivalent to expanding out all the combinations in full, without :matches().)
</p>

<p class="trans-note">【†
例えば［
`X &gt; :matches( Y1, Y2 ) &gt; Z^S
］のような形なら、［
`X &gt; Y1 &gt; Z, X &gt; Y2 &gt; Z^S
］のように，全体として選択子~listの形に展開することを意味すると思われる。
】</p>

	</li>
	<li>
同様に［
`nth-child()$ps ／
`nth-last-child()$ps ／
`nth-of-type()$ps ／
`nth-last-of-type()$ps
］選択子の詳細度は、疑似類~自身の詳細度（ 1 個の疑似類~選択子として数える）に，（もしあれば）その引数である選択子~listの詳細度を加算したものになる。
◎
Similarly, the specificity of an :nth-child(), :nth-last-child(), :nth-of-type(), or :nth-last-of-type() selector is the specificity of the pseudo class itself (counting as one pseudo-class selector) plus the specificity of its selector list argument (if any).
</li>
	<li>
`not()$ps 疑似類の詳細度は、［
その引数である選択子~list内で，最も詳細度の高い`複体~選択子$
］の詳細度に置換される。
◎
The specificity of a :not() pseudo-class is replaced by the specificity of the most specific complex selector in its selector list argument.
</li></ul>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<ul>
	<li>
<p>
`:matches(em, #foo)^S
の詳細度は：
</p>
		<ul>
			<li>
`em^e に合致したときは，`型~選択子$に対するときと同様に
( 0,0,1 ) になる。
</li>
			<li>
`em id=foo^e に合致したときは、 `ID 選択子$に対するときと同様に
( 1,0,0 ) になる。
</li>
		</ul>

◎
:matches(em, #foo) has a specificity of (0,0,1)--like a tag selector--when matched against &lt;em&gt;, and a specificity of (1,0,0)--like an ID selector--when matched against &lt;em id=foo&gt;.
</li>
	<li>

<p>
`:nth-child(even of li, .item)^S
の詳細度は：
</p>
		<ul>
			<li>
`li^e に合致したときは、［
`型~選択子$ ＋ 1 個の疑似類
］に対するときと同様に
( 0,1,1 ) になる。
</li>
			<li>
`li class=item id=foo^e に合致したときは、［
`~class選択子$ ＋ 1 個の疑似類
］に対するときと同様に
( 0,2,0 ) になる。
</li>
		</ul>

◎
:nth-child(even of li, .item) has a specificity of (0,1,1)--like a tag selector plus a pseudo-class--when matched against &lt;li&gt;, and a specificity of (0,2,0)--like a class selector plus a pseudo-class--when matched against &lt;li class=item id=foo&gt;.
</li>
	<li>
`:not(em, #foo)^S
の詳細度は、どの要素に合致しようが， `ID 選択子$に対するときと同様に
( 1,0,0 ) になる。
◎
:not(em, #foo) has a specificity of (1,0,0)--like an ID selector--whenever it matches any element.
</li>
</ul>

</div>

<p>
詳細度の比較では、３成分が順に（~~辞書式に）比較される：
%A 値が大きい方の詳細度がより高く、
%A 値が等しければ %B 値が大きい方の詳細度がより高く、
%B 値も等しければ %C 値が大きい方の詳細度がより高く、
すべての値が等しければ 2 つの詳細度は等しい。
◎
Specificities are compared by comparing the three components in order: the specificity with a larger A value is more specific; if the two A values are tied, then the specificity with a larger B value is more specific; if the two B values are also tied, then the specificity with a larger C value is more specific; if all the values are tied, the two specifities are equal.
</p>

<p>
記憶域に限りがあるときは、実装は %A, %B, %C の大きさに制限ionを課してよい。
その場合、その制限を超えた値は，その制限~内に切り詰められ~MUST。
◎
Due to storage limitations, implementations may have limitations on the size of A, B, or C. If so, values higher than the limit must be clamped to that limit, and not overflow.
</p>

<div class="example">
<p lang="en">Examples:</p>

<pre>
*               /* a=0 b=0 c=0 */
LI              /* a=0 b=0 c=1 */
UL LI           /* a=0 b=0 c=2 */
UL OL+LI        /* a=0 b=0 c=3 */
H1 + *[`REL^a=up]  /* a=0 b=1 c=1 */
UL OL LI.red    /* a=0 b=1 c=3 */
LI.red.level    /* a=0 b=2 c=1 */
#x34y           /* a=1 b=0 c=0 */
#s12:not(FOO)   /* a=1 b=0 c=1 */
.foo :matches(.bar, #baz)   /*
<span class="comment">
合致する要素に依存して， (a, b, c) =
(0, 2, 0) または (1, 1, 0)
のいずれかになる。
◎
Either a=1 b=1 c=0
or a=0 b=2 c=0, depending
on the element being matched.
</span> */</pre>

</div>

<p class="note">注記：
同じ`単体~選択子$の繰り返しは許容され、詳細度を増大させる。
◎
Note: Repeated occurrences of the same simple selector are allowed and do increase specificity.
</p>

<p class="note">注記：
HTML `style^a 属性にて指定される~styleの詳細度については、
`CSSSTYLEATTR$r の
<a href="~CSSSTYLEATTR#interpret">CSS style 属性</a>
にて述べられている。
◎
Note: The specificity of the styles specified in an HTML style attribute is described in CSS Style Attributes. [CSSSTYLEATTR]
</p>

	</section>
	<section id="grammar">
<h2 title="Grammar">17. 文法</h2>
<a id="formal-syntax"></a>

<pre class="prod">
`selector-list@t
    = `complex-selector-list$t

`complex-selector-list@t
    = `complex-selector$t#

`compound-selector-list@t
    = `compound-selector$t#

`simple-selector-list@t
    = `simple-selector$t#

`relative-selector-list@t
    = `relative-selector$t#

`complex-selector@t
    = `compound-selector$t [ `combinator$t? `compound-selector$t ]*

`relative-selector@t
    = `combinator$t? `complex-selector$t

`combinator@t
    = '&gt;&gt;'
    | '&gt;'
    | '+'
    | '~'
    | `column-token$t

`compound-selector@t
    = `simple-selector$t+

`simple-selector@t
    = `type-selector$t
    | `id-selector$t
    | `class-selector$t
    | `attribute-selector$t
    | `pseudo-class-selector$t
    | `pseudo-element-selector$t

`type-selector@t
    = `wq-name$t
    | `ns-prefix$t '*'

`ns-prefix@t
    = [ `ident-token$t? | '*' ]? '|'

`wq-name@t
    = `ns-prefix$t? `ident-token$t

`id-selector@t
    = `hash-token$t

`class-selector@t '.' `ident-token$t

`attribute-selector@t
    = '[' `wq-name$t ']'
    | '['
          `wq-name$t `attr-matcher$t
          [ `string-token$t | `ident-token$t ]
          `attr-modifier$t?
      ']'

`attr-matcher@t
    = '='
    | `include-match-token$t
    | `dash-match-token$t
    | `prefix-match-token$t
    | `suffix-match-token$t
    | `substring-match-token$t

`attr-modifier@t
    = i

`pseudo-class-selector@t
    = ':' `ident-token$t
    | ':' `function-token$t `any-value$t ')'

`pseudo-element-selector@t
    = ':' `pseudo-class-selector$t
</pre>

<p>
上の文法に加えて、次の規則も適用される：
◎
In addition to the above grammar, the following rules apply:
</p>

<ul>
	<li>
`compound-selector$t が包含できる `type-selector$t
は高々 1 個まであり、包含する場合は，その中で最初の `simple-selector$t で~MUST。
◎
A &lt;compound-selector&gt; can contain at most one &lt;type-selector&gt;, and if it does, that must be the first &lt;simple-selector&gt; in it.
</li>

	<li>
<p>
次に挙げる所には、空白は許容されない：
</p>
		<ul>
			<li>
`compound-selector$t を成す `simple-selector$t たちの合間
</li>
			<li>
［
`type-selector$t, `class-selector$t, `wq-name$t, `ns-prefix$t
］どうしの合間。
</li>
			<li>
［
`pseudo-class-selector$t ／
`pseudo-element-selector$t
］の，先頭の~colon ❝: と次の~tokenとの合間。
</li>
		</ul>
◎
A &lt;compound-selector&gt; does not allow any whitespace between its constituent &lt;simple-selector&gt;s.
◎
No whitespace is allowed between the constituents of a &lt;type-selector&gt;, &lt;class-selector&gt;, &lt;wq-name&gt;, or &lt;ns-prefix&gt;, or between the initial punctuation and second token of &lt;pseudo-class-selector&gt;s and &lt;pseudo-element-selector&gt;s.
</li>

	<li>
一部の旧 `疑似要素$（
`before$pe, `after$pe, `first-line$pe, `first-letter$pe
）は、旧来の理由から，先頭の~colonが 1 個だけの
`pseudo-class-selector$t 文法を利用して記せる。
◎
Some older pseudo-elements (::before, ::after, ::first-line, and ::first-letter) can, for legacy reasons, be written using the &lt;pseudo-class-selector&gt; grammar, with only a single ":" character at their start.
</li>

	<li>
`id-selector$t 内の `hash-token$t の値は、`識別子$で~MUST。
◎
In &lt;id-selector&gt;, the &lt;hash-token&gt;’s value must be an identifier.
</li>
</ul>

<p class="issue">
“疑似要素は、複体~選択子ごとに，その最後の合体~選択子として 1 個まで”
とする規則は、今や，棄てられたものと見なしてよいだろうか？
実施においては、すべての実装は，少なくともある部分で この規則に違反している。
◎
Should I consider the "only one pseudo-element per complex selector, at the end of the last compound selector" rule now trashed? In practice, all implementations violate that rule to at least some extent.
</p>

<p class="note">注記：
上の文法は、 `complex-selector$t 内の 2 個の `compound-selector$t の合間の結合子は、省略可能と定めている。
その目的は、文法上に限られる
—
<a href="~CSSVAL#value-defs">CSS 値~定義~構文</a>による，空白の緩い扱いは、空白に <em>なれる</em>ような文法記号を指示し難くしている。
`結合子$の “省略” は、実際には，ちょうど`子孫~結合子$を指定することにあたる。
◎
Note: The grammar above states that a combinator is optional between two &lt;compound-selector&gt;s in a &lt;complex-selector&gt;. This is only for grammatical purposes, as the CSS Value Definition Syntax’s lax treatment of whitespace makes it difficult to indicate that a grammar term can be whitespace. "Omitting" a combinator is actually just specifying the descendant combinator.
</p>


	</section>
	<section id="api-hooks">
<h2 title="API Hooks">18. API ~hook</h2>

<p>
この節では， Selectors の概念を利用する仕様の策定に便宜を図るため、他の仕様から呼び出し得る，いくつかの API ~hookを定義する。
◎
To aid in the writing of specs that use Selectors concepts, this section defines several API hooks that can be invoked by other specifications.
</p>


		<section id="evaluating-selectors">
<h3 title="Evaluating a Selector">18.1. 選択子の評価法</h3>

<p>
この節では、要素の集合に対し，
`選択子を評価-@
する方法を述べる。
この~algoは、次を入力にとる：
◎
This section describes how to evaluate a selector against a set of elements.
</p>

<dl>
	<dt>%選択子 （必須）</dt>
	<dd>
`選択子$。
◎
↓</dd>

	<dt>`根~要素たち^V （必須）</dt>
	<dd>
%選択子 の照合~対象とされる，
1 個~以上の`木$の根~要素からなる集合。
`根~要素たち^V 内のすべての要素の`根$は，同じで~MUST。
◎
APIs using this algorithm must provide a selector, and one or more root elements indicating the trees that will be searched by the selector. All of the root elements must share the same root, or else calling this algorithm is invalid.
◎
Callers may optionally provide:
</dd>

	<dt>%視野根 （省略可）</dt>
	<dd>
%選択子 は視野付きであることを指示する，`視野根$  。
指定されなかった場合、 %選択子 の視野は絞られない。
◎
a scoping root, indicating that the selector is scoped. If not specified, the selector defaults to being unscoped.
</dd>
	<dt>`~scope_ps要素$の集合（省略可）</dt>
	<dd>
`scope$ps 疑似類を解決するための， `~scope_ps要素$の集合。
既定の集合は、空とする。
◎
a set of :scope elements, for resolving the :scope pseudo-class against. If not specified, the set defaults to being empty.
</dd>
	<dd>
%選択子 が`相対~選択子$である場合、`~scope_ps要素$の集合は，空であっては~MUST_NOT。
◎
If the selector is a relative selector, the set of :scope elements must not be empty.
</dd>
	<dd class="note">注記：
%選択子 が`視野付き$の場合、視野根が自動的に`~scope_ps要素$とされるので、異なる結果が望まれない限り，明示的に供される必要はない。
◎
Note: Note that if the selector is scoped, the scoping root is automatically taken as the :scope element, so it doesn’t have to be provided explicitly unless a different result is desired.
</dd>

	<dt>`許容される対象^V （省略可）</dt>
	<dd>
どの種類の`疑似要素$が， %選択子 に合致する対象として許容されるかについて。
既定では、すべての`疑似要素$が許容される。
◎
which pseudo-elements are allowed to show up in the match list, if any. If not specified, this defaults to allowing all pseudo-elements.
</dd>

</dl>

<p>
~algoは、次を実行し~MUST：
◎
↓</p>

<ol>
	<li>
`選択子~照合~list@
— 以下，単に %~list —
を拡充する。
初期~時の %~list は、［
`根~要素たち^V, および `根~要素たち^V 内の各 要素の`子孫$すべて
］とする。
◎
A selector is evaluated against some initial list of elements: the selector match list. The selector match list is initially populated with the root elements provided to the algorithm, and all their descendants.
</li>
	<li>
%選択子 を［
%~list を絞込む`単体~選択子$, および
この~listを新たな %~list に変換する［
`結合子$／`疑似要素$
］］により、左から右の順に処理する。
◎
The selector is processed from left to right in order, with simple selectors filtering the selector match list, and combinators and pseudo-elements changing the selector match list into something new.
</li>
	<li>
%選択子 が`視野付き$ならば、
%~list を［
%視野根 の`子孫$のみを包含する
］ように絞込む。
◎
If the selector is scoped, then after the selector is finished processing, the selector match list must be filtered to contain only elements that are descendants of the scoping root.
</li>
	<li>
%~list を［
`許容される対象^V とされる［
要素／`疑似要素$
］のみを包含する
］ように絞込む。
◎
After the selector is finished matching, the selector match list must be filtered to only contain elements and pseudo-elements allowed by the invoker of this algorithm.
</li>

</ol>

<p>
この処理を終えた結果の %~list に属する要素が、
%選択子 に合致するとされる。
要素の順序も考慮される必要があり、他から指定されない限り，`~shadowも含む木~順序$で整列され~MUST。
◎
When this process is done, the elements in the selector match list are the elements said to match the selector. If the order of elements matter, they must be sorted in shadow-including tree order, unless otherwise specified.
</p>


<div class="example">

<p>
例えば，文書に対し選択子
"`div &gt; i.name^S"
を評価する場合：
</p>

<ol>
	<li>
初期の`選択子~照合~list$
— 上の %~list —
は，文書~内のすべての要素からなる。
</li>
	<li>
最初に，型~選択子 "`div^css" が評価され、 %~list は，~tag名 "`div^s" の要素のみに絞込まれる。
</li>
	<li>
次に，結合子 "`&gt;^css" が評価され、 %~list 内の各~要素は，それらの子~要素に置換される。
</li>
	<li>
次に，型~選択子 "`i^css" が評価され、 %~list は，~tag名 "`i^s" の要素のみに絞込まれる。
</li>
	<li>
最後に，~class選択子 "`.name^css" が評価され、 %~list は， "`name^s" ~class に属する要素のみに絞込まれる。
</li>
</ol>

◎
For example, to evaluate the selector "div &gt; i.name" against a document, the selector match list is first set to all the elements in the entire document. Then, the "div" type selector is evaluated, filtering the selector match list to only contain elements with a tagname of "div". Then, the "&gt;" child combinator is evaluated, transforming the selector match list by replacing each element currently in it with the element’s children. Then, the "i" type selector is evaluated, filtering the selector match list to only contain elements with a tagname of "i". Finally, the ".name" class selector is evaluated, filtering the selector match list to only contain elements with a class of "name".
</div>

<p class="note">注記：
選択子を右から左の順に評価する実装~例も多々ある。
多くの事例において，その方がより効率的になるので。
それは，通例のように、仕様による~algoと同じ結果を返す限り，全く妥当である。
◎
Note: Many implementations of selectors instead evaluate them right to left, as it’s more efficient to do so in many cases. This, as usual, is completely valid, as long as it results in the same elements being returned as the spec’s algorithm would.
</p>

<p class="issue">
`選択子~照合~list$における，疑似要素の［
他の要素に対する相対的な順序
］が未定義。
今の所，この情報を公開する文脈はないが、最終的には，何かが公開される前に 決めておく必要がある。
<!-- <em>is</em> exposed -->
◎
The relative position of pseudo-elements in the selector match list is undefined. There’s not yet a context that exposes this information, but we need to decide on something eventually, before something is exposed.
</p>




		</section>
		<section id="parse-a-selector">
<h3 title="Parse A Selector">18.2. 選択子の構文解析-法</h3>

<p>
この節では、所与の文字列 %~source を
`選択子として構文解析-@
する方法を定義する。
これは、［
複体~選択子の~list, または `失敗^i
］を返す：
◎
This section defines how to parse a selector from a string source. It returns either a complex selector list, or failure.
</p>

<ol>
	<li>
%選択子 を［
%~source を `selector-list$t として構文解析した結果
］とする。
%~source がこの文法に合致していない場合、
`失敗^i を返す。
◎
Let selector be the result of parsing source as a &lt;selector-list&gt;. If it does not match the grammar, return failure.
</li>
	<li>
%選択子 の中に~UAが認識できない単体~選択子が含まれている, または
%選択子 が何らかの仕方で妥当でない場合（例えば，`未宣言$の名前空間 接頭辞が含まれているなど）、
`失敗^i を返す。
◎
Otherwise, if any simple selectors in selector are not recognized by the user agent, or selector is otherwise invalid in some way (such as, for example, containing an undeclared namespace prefix), return failure.
</li>
	<li>
%選択子 を返す。
◎
Otherwise, return selector.
</li></ol>


		</section>
		<section id="parse-relative-selector">
<h3 title="Parse A Relative Selector">18.3. 相対~選択子の構文解析-法</h3>

<p>
この節では、`~scope_ps要素$ %refs が与えられた下で，文字列 %~source を
`相対~選択子として構文解析-@
する手順を定義する。
これは、複体~選択子の~list, または `失敗^i を返す。
◎
This section defines how to parse a relative selector from a string source, against :scope elements refs. It returns either a complex selector list, or failure.
</p>

<ol>
	<li>
%選択子 を［
%~source を `relative-selector-list$t として構文解析した結果
］とする。
%~source がこの文法に合致していない場合、
`失敗^i を返す。
◎
Let selector be the result of parsing source as a &lt;relative-selector-list&gt;. If it does not match the grammar, return failure.
</li>

	<li>
%選択子 内に~UAから認識し得ない単体~選択子がある, あるいは
%選択子 が何らかの仕方で妥当でない（例えば`未宣言$の名前空間 接頭辞が含まれているなど）場合、
`失敗^i を返す。
◎
Otherwise, if any simple selectors in selector are not recognized by the user agent, or selector is otherwise invalid in some way (such as, for example, containing an undeclared namespace prefix), return failure.
</li>
	<li>
%refs を`~scope_ps要素$に用いて， %選択子 を`絶対化$した結果を返す。
◎
Otherwise, absolutize selector with refs as the :scope elements.
◎
Return selector.
</li>

</ol>

		</section>
		<section id="match-against-tree">
<h3 title="Match a Selector Against A Tree">18.4. 木に対し選択子を照合する</h3>

<p>
この節では、
`木に対し選択子を照合@
する方法を定義する。
◎
This section defines how to match a selector against a tree.
</p>

<div>
<p>
この~algoを呼び出す API は、次を入力に供さ~MUST：
</p>

<ul>
	<li>
%選択子
— 選択子。
</li>
	<li>
`根~要素たち^V
— 照合~対象とされる いくつかの木の根~要素からなる集合。
</li>
</ul>
◎
APIs calling this algorithm must provide a selector, and a set of root elements of the trees to be matched against. They may optionally provide:
</div>

<p>
加えて、それぞれについて任意選択で，次のものを供してもよい：
◎
↑
</p>

<ul>
	<li>
%視野根
— %選択子 は視野付きであることを指示する，`視野根$。
指定されなかった場合、 %選択子 の視野は絞られない。
◎
A scoping root indicating the selector is scoped. If not specified, the selector defaults to being unscoped.
</li>

	<li>
`scope$ps 疑似類に合致するものとされる`~scope_ps要素$の集合。
指定されていない場合の既定の`~scope_ps要素$の集合は、［
選択子が`視野付き選択子$であるならば `視野根$ ／
他の場合は `根~要素たち^V
］。
◎
A set of :scope elements, which will match the :scope pseudo-class. If not specified, then if the selector is a scoped selector, the set of :scope elements default to the scoping root; otherwise, it defaults to the root elements.
</li>

	<li>
合致し得る`疑似要素$の種類。
指定されていない場合の既定は，すべての疑似要素。
◎
Which pseudo-elements are allowed to show up in the match list. If not specified, this defaults to allowing all pseudo-elements.
</li>

</ul>

<p>
この~algoは，要素からなる~listを返す（空にもなり得る）：
◎
This algorithm returns a (possible empty) list of elements.
</p>

<ol>
	<li>
この~algoに供されたものと同じ引数で`選択子を評価-$した結果を返す。
◎
Evaluate a selector with the same arguments provided to this algorithm, and return the result.
</li>
</ol>

		</section>
		<section id="match-against-element">

<h3 title="Match a Selector Against an Element">18.5 要素に対し選択子を照合する</h3>

<p>
`要素に対し選択子を照合@
する方法を述べる。
◎
This section defines how to match a selector against an element.
</p>

<p>
この~algoを呼び出す API は、入力に
( 選択子: %選択子； 要素: %要素 )
を供さ~MUST。
また，任意選択で［
`木に対し選択子を照合$する~algoに述べたものと同じ［
任意選択の引数
］］を供してもよい。
◎
APIs calling this algorithm must provide a selector and an element. They may optionally provide the same optional arguments as described in the algorithm to match a selector against a tree.
</p>

<p>
この~algoは `成功^i または `失敗^i を返す：
◎
This algorithm returns either success or failure.
</p>

<ol>
	<li>
%根~要素 :← %要素 の最も先祖の要素
◎
Let root element be the "root ancestor" of element: the element found by traversing parent links from element until an element without a parent is encountered.
</li>

	<li>
`合致した要素たち^V :← ［
%選択子,
%根~要素,
この~algoに渡された［
任意選択の引数
］］を入力に，`選択子を評価-$した結果
◎
Evaluate a selector with selector and root element, and any optional arguments passed to this algorithm. Let matched elements be the result.
</li>

	<li>
`合致した要素たち^V 内に %要素 が［
在れば `成功^i ／ 無ければ  `失敗^i
］を返す
◎
If element is in matched elements, return success. Otherwise, return failure.
</li>
</ol>

		</section>
	</section>

	<section id="dom-mapping">
<h2 title="Appendix A: Guidance on Mapping Source Documents &amp; Data to an Element Tree">19. ~source文書~dataから要素~木へ対応付けるための~~指針</h2>

~INFORMATIVE

<p>
DOM が述べる要素の木~構造は強力かつ有用である一方で、木~構造に基づく~dataを記述する，どの言語を~model化するにも（あるいは~graph構造に基づくものでも，~~適切な解釈の下で）十分に汎的である。
◎
The element tree structure described by the DOM is powerful and useful, but generic enough to model pretty much any language that describes tree-based data (or even graph-based, with a suitable interpretation).
</p>

<p>
HTML の様な一部の言語は、資源から DOM ~objectを~~生成するための well-defined な手順をすでに備えている。
Selectors をそうでない言語による文書に適用するためには、その種の手順が，その言語に定義され~MUST。
◎
Some languages, like HTML, already have well-defined procedures for producing a DOM object from a resource. If a given language does not, such a procedure must be defined in order for Selectors to apply to documents in that language.
</p>

<p>
文書~言語は、最低限，何が DOM の “要素” の概念に対応するかを定義し~MUST。
◎
At minimum, the document language must define what maps to the DOM concept of an "element".
</p>

<p>
首な，~node間の一対多の関係性
— 木~構造における親から子への,
あるいは ~graph構造における~nodeからその近隣への
関係性 —
が、要素の子~nodeとして反映されるべきである。
◎
The primary one-to-many relationship between nodes—parent/child in tree-based structures, element/neighbors in graph-based structures—should be reflected as the child nodes of an element.
</p>

<p>
可能なら、要素の他の特能（ feature ）も，
<a href="#data-model">DOM における同じ特能</a>
に似た役割を担う何かに対応付けるべきである：
◎
Other features of the element should be mapped to something that serves a similar purpose to the same feature in DOM:
</p>

<dl>
	<dt>型◎type</dt>
	<dd>
<p>
文書~言語が、その要素たちを異なる要素~groupに判別し得るような~~基本的な~~概念（ notion ）として，何らかの “型” を備えているならば、それが， “型” 特能として反映されるべきである。
◎
If the elements in the document language have some notion of "type" as a basic distinguisher between different groups of elements, it should be reflected as the "type" feature.
</p>

<p>
この “型” を， “~~基本的な” 名前と, それらの名前をより高次の “名前空間” ~groupに分離し得るならば、後者は “名前空間” 特能として反映されるべきである。
他の場合、要素は “名前空間” 特能を持つべきでなく，名前~全体が “型” 特能として反映されるべきである。
◎
If this "type" can be separated into a "basic" name and a "namespace" that groups names into higher-level groups, the latter should be reflected as the "namespace" feature. Otherwise, the element shouldn’t have a "namespace" feature, and the entire name should be reflected as the "type" feature.
</p>

	<dt>ID◎id</dt>
	<dd>
<p>
要素の何らかの側面が，文書~全体に渡り一意な識別子として~~機能する場合、それが， “ID”  特能に対応付けられべきである。
◎
If some aspect of the element functions as a unique identifier across the document, it should be mapped to the "id" feature.
</p>

<p class="note">注記：
HTML においては、要素が持ち得る ID は 1 個に限られているが，一般にはそのように制約されるべきではない。
ID の重要な性質は、各 ID が単独の要素に結び付くことであり、単独の要素は，複数の ID を妥当に持ち得る。
◎
Note: While HTML only allows an element to have a single ID, this should not be taken as a general restriction. The important quality of an ID is that each ID should be associated with a single element; a single element can validly have multiple IDs.
</p>

	<dt>~classと属性◎classes and attributes</dt>
	<dd><p>
要素を識別するときに有用になる側面ではあるが，一般に，文書の中の一意な要素にはならないものは、［
“~label” （それ自体が文字列になるもの）／
“~prop” （名前と値の対）
］のいずれに等価になるかに依存して，［
“~class” ／ “属性”
］特能に対応付けられるべきである。
◎
Aspects of the element that are useful for identifying the element, but are not generally unique to elements within a document, should be mapped to the "class" or "attribute" features depending on if they’re something equivalent to a "label" (a string by itself) or a "property" (a name/value pair)
</p></dd>

	<dt>疑似類と疑似要素◎pseudo-classes and pseudo-attributes<!-- ＊誤記 --></dt>
	<dd>
<p>
疑似類に合致する, あるいは 疑似要素を持つような要素は、明示的に定義され~MUST。
◎
If any elements match any pseudo-classes or have any pseudo-elements, that must be explicitly defined.
</p>

<p class="issue">
`has()$ps や `matches()$ps の様に，一部の疑似類は <em >構文論的</em> なので、常に働くべきであり、それについて どこかで指示される必要がある。
構造上の疑似類は、子~listが順序を有するならば，常に働くであろう。
◎
Some pseudo-classes are *syntactical*, like :has() and :matches(), and thus should always work. Need to indicate that somewhere. Probably the structural pseudos always work whenever the child list is ordered.
</p>
	</dd>
</dl>

<div class="example">
<p>
例えば、
<a href="http://jsonselect.org/">JSONSelect</a>
は， JSON 文書から情報を抽出するために選択子を利用する~libraryである。
◎
For example, JSONSelect is a library that uses selectors to extract information from JSON documents.
</p>

<ul>
	<li>
JSON 文書の各［
array, object, boolean, string, number, null
］が，木~構造を成す “要素” になる。
array ／ object 要素は，その内容を子として持つ。
◎
The "elements" of the JSON document are each array, object, boolean, string, number, or null. The array and object elements have their contents as children.
</li>

	<li>
各~要素の型はその JS 型~名：
"array", "object", 等々になる。
◎
Each element’s type is its JS type name: "array", "object", etc.
</li>

	<li>
object の子は、その key を~classとして持つ。
◎
Children of an object have their key as a class.
</li>

	<li>
array の子は
`first-child$ps, `nth-child()$ps,
等々の疑似類に合致する。
◎
Children of an array match the :first-child, :nth-child(), etc pseudo-classes.
</li>

	<li>
根 object は `root$ps に合致する。
◎
The root object matches :root.
</li>

	<li>
特定0の［
値をとる, あるいは 部分文字列を包含する
］ような
boolean／number／string
要素に合致させるための
`val()^ps,
`contains()^ps
疑似類も追加で定義する。
◎
It additionally defines :val() and :contains() pseudo-classes, for matching boolean/number/string elements with a particular value or which contain a particular substring.
</li>

</ul>

<p>
この構造は、選択子による，JSON 文書に対する強力で簡潔な~query法を与えるに十分なものになる。
◎
This structure is sufficient to allow powerful, compact querying of JSON documents with selectors.
</p>
</div>

	</section>
	<section id="changes">
<h2 title="Changes">20. 変更点</h2>

<p>
<a href="https://www.w3.org/TR/2013/WD-selectors4-20130502/">2 May 2013 Working Draft</a>
からの有意な変更点は：
◎
Significant changes since the 2 May 2013 Working Draft include:
</p>

<ul>
	<li>
`視野付き選択子$から`相対~選択子$を分離した。
これらは独立に呼び出され得る，異なる概念なので。
◎
Split out relative selectors from scoped selectors, as these are different concepts that can be independently invoked.
</li>
	<li>
相対~選択子を絶対化するための規則を変更した。
課題：
List changes + rationale?
◎
Changed rules for absolutizing a relative selector. Issue: List changes + rationale?
</li>
	<li>
対象指示子（ subject indicator ）の特色機能を
`has()$ps
に置換した。
◎
Replaced subject indicator feature with :has().
</li>
	<li>
`active-drop-target^ps,
`valid-drop-target^ps,
`invalid-drop-target^ps
を `drop()$ps に変更した。
◎
Changed the :active-drop-target, :valid-drop-target, :invalid-drop-target with :drop().
</li>
	<li>
<a href="~CSSSYN#anb-production">~AnB</a>
小構文の定義を CSS Syntax 仕様に移動した。
課題：意味論的な定義については，おそらく ここに戻されるべきである。
◎
Moved definition of &lt;An+B&gt; microsyntax to CSS Syntax. Issue: Semantic definition should probably move back here.
</li>

	<li>
<p>
次の新たな節を追加した：
◎
Added new sections:
</p>

		<ul>
			<li>
`選択子の評価法§ 節。
<a href="https://lists.w3.org/Archives/Public/www-style/2015Mar/0432.html" >課題</a>
◎
Evaluating a Selector Issue: https://lists.w3.org/Archives/Public/www-style/2015Mar/0432.html
</li>
			<li>
`~data~model§ 節。
課題：
XML に対する木を定義する必要がある。
◎
Data Model Issue: Need to define tree for XML.
</li>
			<li>
`API ~hook§ 節。
◎
API Hooks
</li>
		</ul>
	</li>
	<li>
`matches()$ps,
`not()$ps,
`nth-match()^ps,
`nth-last-match()^ps
の中の結合子に対する制約を除去した。
課題：
これの実装はあるのか？
そうでないなら、 level 4 に対しては，この制約は保ったほうが良いかも？
◎
Removed restriction on combinators within :matches(), :not(), :nth-match(), and :nth-last-match(). Issue: Do we have implementations of this? If not, maybe it’s better to keep the restriction for level 4?
</li>
	<li>
`選択子~list$の`詳細度$を定義した。
(Why?)
◎
Defined specificity of a selector list. (Why?)
</li>
	<li>
関心が欠如しているので、
`local-link^ps, および
参照~結合子は除去した。
◎
Removed the :local-link and reference combinator for lack of interest.
</li>
</ul>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">21. 謝辞</h2>

<p>
CSS working group は、この仕様の基礎を成している仕様も含め，年月に渡り
<a href="https://www.w3.org/TR/css3-selectors">以前の Selectors 仕様</a>
に協力されてきたすべての方々に感謝する。
更に、 Selectors Level 4 に特に協力をされた次の方々に，特別な謝意を：
</p>

<div>
The CSS working group would like to thank everyone who contributed to the previous Selectors specifications over the years, as those specifications formed the basis for this one. In particular, the working group would like to extend special thanks to the following for their specific contributions to Selectors Level 4: L. David Baron, Andrew Fedoniouk, Ian Hickson, Grey Hodge, Lachlan Hunt, Jason Cranford Teague
</div>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">22. ~privacy／~security上の考慮点</h2>

<p>
選択子は， DOM を手動で辿ることですでに可能である能を超えるものは提供しないので、この仕様は、新たな
~privacy／~security
上の考慮点を導入するものではない。
◎
This specification introduces no new privacy or security considerations,
as selectors do not provide any ability not already possible by walking the DOM manually.
</p>

	</section>

</main></div><!-- MAIN -->

	<section id="conformance">
<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この節（およびその下位節）の内容は
<a href="css-common-ja.html#conformance">CSS 日本語訳 共通ページ</a>
に委譲
】</p>


<!--
<h2 id="Tests">Tests</h2>

<p>This specification has <a
href="http://www.w3.org/Style/CSS/Test/CSS3/Selectors/current/">a test
suite</a> allowing user agents to verify their basic conformance to
the specification. This test suite does not pretend to be exhaustive
and does not cover all possible combined cases of Selectors.
-->


	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>

<dl>

	<dt>[CSS-DISPLAY-3]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 15 October 2015. WD.</dd>
	<dd>http://dev.w3.org/csswg/css-display/</dd>

	<dt>[CSS-PSEUDO-4]</dt>
	<dd>Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. 7 June 2016. WD.</dd>
	<dd>https://drafts.csswg.org/css-pseudo-4/</dd>

	<dt>[CSS-VALUES]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 11 June 2015. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-values/</dd>

	<dt>[CSS-WRITING-MODES-3]</dt>
	<dd>Elika Etemad; Koji Ishii. CSS Writing Modes Level 3. 15 December 2015. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-writing-modes-3/</dd>

	<dt>[CSS21]</dt>
	<dd>Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC.</dd>
	<dd>https://www.w3.org/TR/CSS2</dd>

	<dt>[CSS3NAMESPACE]</dt>
	<dd>Elika Etemad. CSS Namespaces Module Level 3. 20 March 2014. REC.</dd>
	<dd>http://dev.w3.org/csswg/css-namespaces/</dd>

	<dt>[CSS3SYN]</dt>
	<dd>Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-syntax/</dd>

	<dt>[CSS3TEXT]</dt>
	<dd>Elika Etemad; Koji Ishii. CSS Text Module Level 3. 10 October 2013. LCWD.</dd>
	<dd>http://dev.w3.org/csswg/css-text-3/</dd>

	<dt>[DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>

	<dt>[HTML]</dt>
	<dd>Ian Hickson. HTML Standard. Living Standard.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

<!-- 
	<dt>[RFC2119]</dt>
 -->

	<dt>[SELECT]</dt>
	<dd>Tantek Çelik; et al. Selectors Level 3. 29 September 2011. REC.</dd>
	<dd>https://www.w3.org/TR/css3-selectors/</dd>

	<dt>[SVG2]</dt>
	<dd>Nikos Andronikos; et al. Scalable Vector Graphics (SVG) 2. 15 September 2015. WD.</dd>
	<dd>https://svgwg.org/svg2-draft/</dd>

	<dt>[WHATWG-URL]</dt>
	<dd>Anne van Kesteren; Sam Ruby. URL Standard. Living Standard.</dd>
	<dd>https://url.spec.whatwg.org/</dd>
</dl>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>


<dl>

	<dt>[BCP47]</dt>
	<dd>A. Phillips; M. Davis. Tags for Identifying Languages. September 2009. IETF Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/bcp47</dd>

	<dt>[CSS-SCOPING-1]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Scoping Module Level 1. 3 April 2014. WD.</dd>
	<dd>http://dev.w3.org/csswg/css-scoping/</dd>

	<dt>[CSS3UI]</dt>
	<dd>Tantek Çelik; Florian Rivoal. CSS Basic User Interface Module Level 3 (CSS3 UI). 7 July 2015. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-ui/</dd>

	<dt>[CSSSTYLEATTR]</dt>
	<dd>Tantek Çelik; Elika Etemad. CSS Style Attributes. 7 November 2013. REC.</dd>
	<dd>http://dev.w3.org/csswg/css-style-attr/</dd>

	<dt>[HTML401]</dt>
	<dd>Dave Raggett; Arnaud Le Hors; Ian Jacobs. HTML 4.01 Specification. 24 December 1999. REC.</dd>
	<dd>https://www.w3.org/TR/html401</dd>

	<dt>[HTML5]</dt>
	<dd>Ian Hickson; et al. HTML5. 28 October 2014. REC.</dd>
	<dd>https://www.w3.org/html/wg/drafts/html/master/</dd>

	<dt>[MATHML]</dt>
	<dd>Patrick D F Ion; Robert R Miner. Mathematical Markup Language (MathML) 1.01 Specification. 7 July 1999. REC.</dd>
	<dd>https://www.w3.org/TR/MathML/</dd>

	<dt>[RFC4647]</dt>
	<dd>A. Phillips; M. Davis. Matching of Language Tags. September 2006. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc4647</dd>

	<dt>[SVG11]</dt>
	<dd>Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC.</dd>
	<dd>https://www.w3.org/TR/SVG11/</dd>

	<dt>[XFORMS11]</dt>
	<dd>John Boyer. XForms 1.1. 20 October 2009. REC.</dd>
	<dd>https://www.w3.org/TR/xforms11/</dd>

	<dt>[XML-NAMES]</dt>
	<dd>Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC.</dd>
	<dd>https://www.w3.org/TR/xml-names</dd>

	<dt>[XML10]</dt>
	<dd>Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC.</dd>
	<dd>https://www.w3.org/TR/xml</dd>
</dl>



		</section>
	</section>
	<section id="index">
<h2 title="Index">索引</h2>

<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>
	</section>
	<section id="property-index">
<h2 title="Property index">プロパティ索引</h2>

<p>
この仕様に定義されているプロパティは無い。
</p>

	</section>
	<section id="issues-index">
<h2 title="Issues Index" data-cycling=".issue">課題 索引</h2>

<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>

	</section>

