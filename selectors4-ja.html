<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Selectors Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

COMMON_DATA.page_state_key = '___CSS';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://drafts.csswg.org/selectors/',
		spec_status: 'ED',
		fill_text_link: '#_versions > dd, #references dd',
		main: 'MAIN',
		ref_data: '.ref_data',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked 170808 spec

	return options;
}


function expand(mapping1){
	var link_map = this.link_map;
	var class_map = {
		ps: 'pseudo',
		pe: 'pseudo-element',
		prod: 'production',
		v: 'value',
		t: 'type',
		p: 'property',
		e: 'element',
		a: 'attr',
		css: 'css',
		S: 'css',
		U0: 'code-point',
	};

	var tag_map = {
		ps: 'code',
		pe: 'code',
		prod: 'var',
		v: 'code',
		t: 'var',
		p: 'code',
		e: 'code',
		a: 'code',
		css: 'code',
		S: 'samp',
		s: 'samp',
		I: 'code',
		c: 'code',
		U0: 'span',
		i: 'i',
		V: 'var',
		NOTE: 'span'
	}

	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|【.*?】|%[\w~一-鿆あ-ん]+|`(.+?)([$@§!\^])(\w*)/g,
			create_html
		),
		mapping1
	);


	function create_html(match, key, indicator, klass){
if(!indicator) {
	switch(match.charAt(0)){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	case '◎':
	default:
		var result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
		nesting = '';
		return result;
	}
}


var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'ps': // pseudo-class
	href = '#' + key.match(/[^(]+/)[0] + '-pseudo';
	text = ':' + key;
	break;
case 'pe': // pseudo-class
	text = '::' + key;
	break;
case 'PS': // pseudo-class section
	href = '#the-' + key.match(/[^(]+/)[0] + '-pseudo';
	text = '<code class="pseudo">:' + key + '</code> 疑似類';
	break;
case 'prod': // production
	href = '#prod-' + key;
	break;
case 't': // typedef
	href = '#typedef-' + key;
	text = '&lt;' + key + '&gt;';
	break;
case 'U': // 
	text = '<span class="code-point">U+' + key + '</span> (<span class="char-symbol">&#x' + key + ';</span>)';
	break;
case 'U0': //
	text = 'U+' + key;
	break;
default:
}


if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	if(indicator === '§'){
		href = link_map[ key + '§'];
	} else {
		href = link_map[klass ? (klass + '.' + key) : key] || href;
	}
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '§':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}


}

</script>


<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
subject-indicator:
AnB-notation:

drop-pseudo:selectordef-drop-function
drop-pseudo0:selectordef-drop

not-pseudo:negation-pseudo
pseudo-element_syntax:pseudo-element%20syntax
user-invalid-pseudo:user-error-pseudo

</script>
<!-- 


scope_relative_selector_list:
scope_relative_selector:
complex_selector:
combinator0:
	`combinator^prod
compound_selector_list:
compound_selector:
simple_selector_list:
simple_selector:
type_selector:

-->

<!--% 置換データ -->
<script type="text/plain" id="words_table1">

AnB:<code class="css"><var>A</var>n+<var>B</var></code>
AnBth:<a href="#AnB-notation">A×<var>n</var> + B 個目（ <var>n</var> ≥ 0 ）</a>

note21:<a href="#_note21" class="trans-note">【†1】</a>
E:<var>E</var>
F:<var>F</var>
S:<var>S</var>
n:<var>n</var>

scope_ps:<code class="pseudo">:scope</code> 
drop0:<a href="#drop-pseudo0"><code class="pseudo">:drop</code></a>

SCOPING:https://drafts.csswg.org/css-scoping-1/

</script>
<!-- 結合子
cb-descendant:<code class="css">&gt;&gt;</code>
cb-column:<code class="css">||</code>
cb-child:<code class="css">&gt;</code>
cb-adjacent:<code class="css">+</code>
cb-descendant:selectordef-descendant
cb-column:selectordef-column
cb-child:selectordef-child
cb-adjacent:selectordef-adjacent

-->
<!--% 語彙置換データ
英数_／漢字
-->

<script type="text/plain" id="words_table">


	●DOM
instance:::インスタンス
list:::リスト
node:::ノード
call:
method:::メソッド
shadow:
	host:
識別子:identifier:~
素片:fragment:~
文書片:document fragment:~
文書順:document order:~
根:root::~:ルート
木:tree::~:ツリー
部分木:subtree::~:サブツリー
	文書~木
	要素~木
平坦:flat::~
文書:document:~
	文書~言語
木構造:tree structure:tree 構造:~:ツリー構造
	木~構造たる部分:tree-ness
構造:structure:~
属性:attribute:~
存在0:presence:存在
同胞:siblings:~
同胞群:sibling 群:~
同胞要素:element siblings:~
要素:element:~
親:parent:~
子:child:~
	親子関係:parentage／childhood relationship
子孫:descendant:~
	孫:grandchild
先祖:ancestor:~
	最も近い先祖:innermost ancestor
内容:content:~
実体参照:entity reference:~
処理命令:processing instruction:~
文書型宣言:doctype declaration:~


	●構文
ASCII:
token:::トークン
	トークン化器:tokenizer
pattern:::パタン
文字列:string:~
部分文字列:substring:~
空:empty:~
	空かどうか:emptiness
関数:function:~
接尾辞:suffix:~
接頭辞:prefix:~
区切子:separator:~
区切りの:-separated:~
文字:character:~
大小:case:~
文字大小:character case:文字 case:~
大小無視:case-insensitive:~
	大小を区別:case-sensitive
	文字大小の区別:case sensitivity
生成規則:production:~
構文解析-:parse:~::パース
文法:grammar:~
文法上:grammatical:~
文法記号:grammar term:~
成分:component:~
形成-:form:~
符号位置:code point:~

構文:syntax:~
構文論的:syntactical:~
構文的:syntactic:~
構文上は:syntactic には:~
小構文:microsyntax:~
	括弧:parentheses
	閉じ角括弧:closing bracket

	●文字名
comma:::カンマ
colon:::コロン
	space → SPACE
asterisk:::アスタリスク
hyphen:::ハイフン
tilde:::チルダ
backslash:::バックスラッシュ
escape:::エスケープ
	エスケープ処理:escaping
	hash:
	pipe:
	vertical bar
	sign:符号
正符号:plus sign:~
空白:whitespace:~
終止符:full stop:~
	white space
角括弧:bracket:~
番号記号:number sign:~
	大なり記号:greater-than sign:~

	●文書言語
ID:
名前空間:namespace:~
	どの名前空間にも属さない:no namespace
有修飾:qualified:~
修飾-:qualify:~
局所:local:~::ローカル
	局所的:local:~
宣言-:declare:~
	宣言-法:declaring:~
宣言:declaration:~
未宣言:undeclared:~
	オプション:optional:~

subset:::サブセット
部分集合:subset:~

外部:external:~
内部:internal:~
集合:set:~
	空集合:nothing

	●仕様（動詞
推奨-:recommend:~
	RECOMMENDing
非推奨に:deprecate:~
要求-:require:~
実装:implementation:~
実装-:implement:~
実装者:implementor:~
適合-:conform:~
非適合:non-conforming:~
適合性:conformance:~
除去-:remove:~
	欠如-:lack:~
取扱われ:handle され:取り扱われ
取扱う:handle する:取り扱う
取扱い:handling:取り扱い
適応-:accommodate:~
見做され:assume され:~
意図-:intend:~
意図:intent:~
省略-:omit:~
省略:omitting:~
省略可能:optional:~
省略可:optional:~
判別-:distinguish:~
	distinguisher
受容-:accept:~
許容-:allow:~
創出-:create:~
影響-:affect:~
適用-:apply:~
	可能にする:permit
定義-:define:~
	undefined
定義:definition:~
認識-:recognize:~
認知-:recognize:~
	unrecognized
相違:difference:~
提供-:provide:~
提供0-:offer:提供
依存-:depend:~
	に依存:-dependent:
独立:independent:~
独立して:independent に:~
指定-:specify:~
拡張-:extend:~
拡張:extension:~
制約-:restrict:~
制約:restriction:~
拘束:constraints:~
拘束-:constrain:~
考慮-:consider:~
考慮点:considerations:~
考える:consider する:~
見なさ:consider さ:~
決定-:determine:~
指示-:indicate:~
指示子:indicator:~
上書き:override:~
除外-:exclude:~
配慮:care:~
違反-:violate:~
保証-:guarantee:~
濫用-:abuse:~
記述-:describe:~
	述べる
記述:description:~
試みる:attempt する:~
分類-:classify:~
考査:review:~
解釈-:interpret:~
解釈:interpretation:~
制限-:limit:~
制限:limitation:~
設計-:design:~
導入-:introduce:~
正しく:correct に:~
正した:correct した:~
挙動:behavior:ふるまい
明確化-:clarify:~
働く:work する:~
示唆-:suggest:~
避けら:avoid さ:~
欲され:desire され:~

	まとめる:condense
	今や棄てられた:now trashed
	仕分け:categorization
	~~代理:aliases
	似た役割を担う:serves a similar purpose
	則って:according
	協力-:contribute／contributions
	取り消す:cancels out
	取り除く:drop-/left out
	守る:preserve
	定めて:state して
	実用:usable
	密接な統合:close integration
	対応付ける:map
	対象に:takes
	扱える:aware
	推定-:infer
	機能する:function
	用い:use-
	用意:-
	略記:-
	示す:illustrate
	移行:
	策定:
	置き換える:replaces
	行う:perform-
	表す:express
	要する:requiring
	要約-:summarize/summary/Abstract
	課され:impose
	選定:chosen
	関連付けられた:associated
	-:observe
	-:carrying
	know:
	known:
	記され:noted
	倣い:In keeping with:
	に因り:due to
	疑わしい:suspect
	追加の:additional:~
	追加／加えて:addition-
	made:
	make:
	say:
	意味-:mean:~
	意味:meaning:~
	扱い:treatment
	扱う:treat-
	持ち運ぶ:carry
	散らばって:scattered throughout
	満たす:satisfy
	求められ:authors 〜 want
	欠く:lack する:~
	欠落を埋める:bridge the gap
	採用/選ぶ:choose
	〜に基づいて:based on

	●仕様
API:
UA:user agent:UA::ユーザエージェント
app:application::アプリ
host:::ホスト
hook:::フック
model:::モデル
support:::サポート
level:::レベル
module:::モジュール
version:::バージョン
意味論:semantics:~
意味論的:semantic:~
過去互換:quirks:~
明示的:explicit:~
暗黙的:implicit:~
	暗黙／言外:implied
任意選択で:optional に:~
任意選択の:optional:~
仕様:spec:~
	specification
作者:author:~
作者定義の:author-defined:~
利用者:user:~::ユーザ
互換性:compatibility:~
将来:future:~
将来の:future:~
後継版:successor:~
要件:requirements:~
正式:normative:~
参考:non-normative:~
	参考:informative:~
勧告:recommendation:~

特色機能:feature:~
	特色機能~一式:featureset
能:ability:~
	関心:interest:~

側面:aspect:~
手頃:reasonable:~
各種用語:terminology:~
	一緒くたにconflated
既存の:existing:~
能力:capabilities:~
注釈文:prose:~
	詳細:details:~
特有:-specific:ごとに固有
特有の:specific な:~
特定の:specific:~
範囲:range:~
情報:information:~
知識:knowledge:~
目的:purpose:~
概念:concept:~
	概念:notion:~
概念的:conceptual:~
	基本的:basic:~
抽象的:abstract:~
抽象化:abstraction:~
判定基準:criteria:~
特定0の:particular:ある特定の
仕組み:mechanism:~
適切:appropriate:~
関係性:relationship:~
直接的:direct:~
間接的:indirect:~
状況:situation:~
実践:practice:~
不正:incorrect:~
要因:factor:~
効果:effect:~
意識的:significant:~
	意識的にやりとり:significantly interact
強力:powerful:~
有用:useful:~
汎用的:generic:~
汎用:generic:~
一般化:generalized:~
一般:general:~
多彩:rich:~
技術:technology:~
旧来の:legacy:~
理由:reason:~
実施:practice:~
不便:awkward:~
不可能:impossible:~
同意:consent:~
相互作用:interaction:~
概観:overview:~
制御:control:~
無用な:useless:~
特別:special:~
機能性:functionality:~
重要:important:~
	~~重要:-critical
適正:proper:~
未知:unknown:~
未知の:unknown:~
手順:procedure:手続き
注記:Note:~
環境:environment:~
変更点:changes:~
変更-:change:~
仕方:way:~
組込みの:built-in:組み込みの
明瞭:clear:~
首:primary:主
第一:primary:~
自前の:own:~
処理器:processor:~::プロセッサ
事例:case:~
有意:significant:~
課題:issue:~
概して:typical に:~
	大概の:typical:~
明白:obvious:~
指針:guideline:~
手引き:guidance:~
経験則:heuristics:~
native:::ネイティブ
OS:operating system:OS
模倣-:emulate:~
	注目:attention:~
risk:::リスク
条件:condition:~
処理能:performance:~
		処理能に左右され易い:wildly varying performance characteristics
最適化-:optimize:~
成功裡:successful:~
自動的:automatic:~
相応しい:suitable な:~
結付けら:associate さ:結び付けら
基礎:basis:~
通常は:normal には:~
通常の:normal な:~
通例の:usual な:~
通例的:usual:~

	●仕様（その他
	方法:how
	~~概念:notion
	~~規則
	〜に基づいて／に従って:with respect to
	〜に関わりなく:regardless
	おそらく:probably
	ことが多い:commonly
	すべての場合に対応する:catch all cases
	と:versus
	やり方／適用／手法:method
	より高次の:higher-level
	一対多:one-to-many
	一定期間が経過:some amount of time
	一方で:meanwhile
	一貫:
	互いに排他的／両立し得ない:mutually exclusive
	中核をなす:core component
	依然として:still
	便宜:
	個別／個別的:individual
	処理規則
	別形へ投影した:alternate projection
	利用
	可能性
	同一視
	同様:similar
	~~地位
	場合
	~~安定的:robust
	実際:actual／
	左右され:sensitive
	対象外:
	年月に渡り:years
	必要:
	必要なら:if necessary
	性質:quality
	措置:measures
	新機能:new
	旧:older
	普及している:common
	普通の:regular
	最低限:at minimum
	注意。:note that
	無関係:irrelevance
	現実的に負荷が高過ぎる:unfortunately too slow to realistically
	現時点:
	生来的:in nature
	用例:an example
	用途:-
	相当の力:considerable power
	簡潔:compact
	総称:
	緩い:lax な
	自体:
	表現力:-
	語:term
	見誤り易い:somewhat difficult to tell apart at a quick glance
	難しく:difficult:~
	類似:similar
	~~特別な追加~情報:extra information
	／実:true
	 〜も:optionally
	例示:show
	-:conceivably
	-:Conversely,
	例:example
	足る:sufficient
	better:
	-:although
	-:beyond
	need
	seems
	choice
	further
	how
	like
	-:manner
	必要はない:necessarily
	per:
	please:
	得る:potentially:
	-:pretty much
	rather:
	点で:sense
	〜？:suggestions:
	ので／したがって:therefore:
	well-defined
	〜一方:whereas
	-:address

	●CSS
style:::スタイル
	style:style付けする
	style付け状態:stylistic states
stylesheet:style sheet::スタイルシート
prop:property::プロパティ
layout:::レイアウト
規則:rule:~
	at-規則:at-rule
媒体:media::~:メディア
呈示-:present:~
呈示様式:presentation:~
無視:ignore:~
box:::ボックス
発話:speech::~:スピーチ
具現化-:render:~::レンダー
	具現化-法:rendering
具現化:rendering:~::レンダリング
	音声化:speech rendering:~
描画:render:~
公開-:expose:~

	●Selectors
profile:::プロファイル
動的:dynamic::~
静的:static::~
完全:complete::~

詳細度:specificity::~
	より詳細度が高い:more specific
照合:matching::~
照合-:match::~
部分照合:substring matching::~
合致-:match::~
	:マッチ
	合致対象:match::~
評価-:evaluate:~
評価:evaluation:~
	評価-法:evaluating
特能:feature:特色::フィーチャ
無特能:featureless:無特色::フィーチャレス

無効:invalid::~
	無効にする:invalidate
妥当性:validity::~
	妥当性を検証しない:non-validating
妥当:valid::~
	妥当なものとして:validly
有効:valid::~

選択対象:subjects::~
group:::グループ

選択子:selector::~:セレクタ
選択-:select:~
	選択-済み:selected:~
選択:selection:~
	選択-済みのものがない:with no pre-selected choice

class:
相対的:relative:~

全称:universal::~
単体:simple::~
型:type::~
相対:relative::~
合体:compound::~
複体:complex::~

	合体~選択子
	複体~選択子
	全称~選択子
	子孫~選択子
	子~選択子
	型~選択子
	単体~選択子
	~class選択子
	相対~選択子
	属性~選択子
	~ID選択子

基本的な:elemental:~
		basic

格子構造:grid-structural::格子構造 :グリッド構造
所属関係:association:~
	所属:membership:~

結合子:combinator::~
	~column結合子
	子孫~結合子
	子~結合子:child combinator::~
次同胞:next-sibling::次-同胞 
後続同胞:subsequent-sibling::後続-同胞 
広義同胞:inclusive sibling::~

	次同胞~結合子
	後続同胞~結合子

疑似要素:pseudo-element::~
出自の:originating:~
	出自の要素

視野:scope::視野:スコープ
視野付き:scoped::視野付き:スコープ付き
視野根:scoping root::~:スコーピングルート
視野要素:scoping element:scoping 要素:視野の根要素:スコーピング要素

絞込む:filter する::絞り込む
絞込まれ:filter され::絞り込まれ
	絞込んだ:filter した:絞り込んだ
	絞り込み:filtered／filtering
	拡張絞り込み:extended filtering 1

	scoping-root:scoping root
	scoping-element:scoping 要素
virtual:
	仮想？
絶対化:absolutize::~
絶対的:absolute::~
起点要素:reference element:reference 要素:~
起点:reference point:~

自然言語:language:~
	自然言語に関する:linguistic
言語:language:~
言語範囲:language range:~
wildcard:::ワイルドカード
subcode:

記法:notation:~
関数形:functional::~
省略形:shorthand::~


	●Selectors 疑似クラス
	疑似:pseudo
疑似類:pseudo-class::疑似クラス
方向性:directionality::書字方向性
	方向性疑似類:directionality pseudo-class:方向性疑似類

関数形:functional::~
構造上の:structural:~
関係上の:relational:~::リレーショナル
	木~構造上の
	否定~疑似類:negation pseudo-class::否定 疑似クラス
	範囲~疑似類:range pseudo-class::範囲 疑似クラス
	選択-済み疑似類:selected-option pseudo-class::選択-済み疑似クラス
変更可否:mutability::~
	利用者~動作:user action:~::ユーザアクション
	利用者~対話:user-interaction::~:ユーザインタラクション

否定:negation::~
論理和:matches-any::~
有型:typed::~
仮入力例示:placeholder-shown::~
仮入力:placeholder::~

既定option:default option:既定の option:既定の選択肢:デフォルトオプション
	選択肢:choices／option

不定:indeterminate:~
不定の:indeterminate:~
必須随意:optionality::必須／随意
	随意:optional／必須:required

子付番:child-indexed::~
付番:index::~
	numbering:番号付け
	indexes
	indexed
周期:step:~
	差分:offset:差分

格子:grid:~::グリッド
table:::テーブル
cell:::セル
column:::カラム
col:column::列
row:::行
初行:first line::最初の行
初字:first letter::最初の字

時系列再生:time-dimensional canvas:~
時間軸:timeline:~
時系列順:time-based order:~
時系列:time-dimensional:~
現在要素:current-element:~
未来要素:future-element:~
過去要素:past-element:~
未来:future:~
過去:past:~

再生位置:playback position:~
現在表示中:currently-displayed:~

再生-:play:~
	再生-中:playing:~
一時停止-:pause:~
停止-:stop:~
再開-:resume:~
事由:reason:~
buffer:::バッファ
~~質:quality

	●network
hyperlink:::ハイパーリンク
source:::ソース
link:::リンク
anchor:::アンカー

履歴:history:~
	target:リンク先
生成元:origin:~::オリジン
path:::パス
	source_anchor:source anchor:リンク元
	ID-typed:ID型にされている

資源:resource::~:リソース
所在:location:~
query:::クエリ
	クエリ法:querying
	queries
	素片識別子
site:::サイト
頁:page::ページ
header:::ヘッダ

	●UI
UI:user interface:UI::ユーザインタフェース
対話性:interactivity:~:インタラクティブ性
対話的:interactive::~:インタラクティブ
対話:interaction::~:インタラクション

不能化-:disable::~
不能化:disabled::~
可能化-:enable::~
可能化:enabled::~
	操作可否
読専:readonly:読み取り専用

利用者入力:user-input:~::ユーザ入力
入力:input:~
強調:highlight:強調表示

focus:
	focused:focus を得ている
移動-:move:~
hover:
	hovering:hover 状態
	hovered-over
	ドラッグ:drag:~
	ドロップ:drop:~
	being dragged:drag中の
drag:
drop:
	drop先:drop target
target:
drag-and-drop:drag＆drop

動作:action:~::アクション
	動作の対象:acting on
作動中:active:~::アクティブ
作動化-:activate:~::アクティブ化
作動可能:activatable:~::アクティブ化可能
作動化:activation:~::アクティブ化
作動期間:active 期間:~::アクティブ期間

提出-:submit:~

未訪問の:unvisited:~
未訪問:unvisited:~
訪問済み:visited:~
form:::フォーム
	choices／
	排他的な~~選択肢:alternatives
改め:alter し:~
改めら:alter さ:~
改めれ:alter でき:~
	alterable
欄:field:~
誘発-:trigger:~
環:ring:~
tab-key:tab:タブキー
click:::クリック
dialog:::ダイアログ
押して:press して:~
離す:release する:~
	未入力:omission／field was blank／omitted-but-required
	完了率:percent completion

	●UI 部品／機器

check:::チェック
	checkされていない:unchecked
	checkされた状態／状態:checked
mouse:::マウス
button:::ボタン
pointer:::ポインタ
pointing:::ポインタ指示::~
keyboard:::キーボード
event:::イベント
装置:device:~
機器:device:~
接触判定:hit-testing:~
interface:::インタフェース
control:::コントロール
label:::ラベル
	labelが付与された:labelled
menu:::メニュー
context:::コンテキスト
popup:::ポップアップ
進捗計:progress meter::~:プログレスメータ
cursor:::カーソル
button:::ボタン
radio:::ラジオ
	ラジオグループ:radio group:~
checkbox:::チェックボックス
slider:::スライダ
select::選択::セレクト

	●未分類（動詞
置換-:replace:~
組合せ:combination:組み合せ
組合せる:combine する:組み合せる
入子:nesting:入れ子
	先行:precede:~
解決-:resolve:~
解決:resolution:~
	参照:reference, referencing, see
	指す:refer
	参照元:referring
比較:comparison:~
比較-:compare:~
		comparing
開始:start:~
拡張0-:expand:拡張
展開-:expand out:~
生成-:generate:~
共有-:share:~
保守-:maintain:~
	分割:divide:~
正規化-:normalize:~
継承-:inherit:~
見出す:find する:~
獲得-:acquire:~
失った:lose した:~
規範:normative:~
設定-:set:~
順序:order:~
有順序:ordered:~
検出-:detect:~
計算-:calculate:~
	計算-法:calculating
識別-:identify:~
束縛-:bind:~
	束縛-法:binding
連結-:concatenate:~
表示:display:~
構築-:construct:~
反応:response:~
反映-:reflect:~
包含-:contain:~
包含関係:containment:~
抽出-:extract:~
読取る:read する:読み取る
読取って:read して:読み取って
読込まれ:load され:読み込まれ
	-:sort:~
拡充-:populate:~
到達-:reach:~
解放-:release:~
検査-:check:~
	検査-法:checking
	突き合わせて検査-:cross-check
増大-:increase:~
終端-:end:~
描かれ:draw され
追加-:add:~
改変-:modify:~
生産-:produce:~
受取る:receive する:受け取る
受取れる:receive できる:受け取れる
受取った:receive した:受け取った
配置-:place:~
存在-:exist:~
照合検索-:search:~
伝播-:propagate:~
	~~複合~compound
	問わない:regard
	始まる:begin
	始まる:starting
	属する:belong-
	対応-:correspond
	在る:lies
	~~分離:split out
	与え-:give
	分離-:separate:~
	切り替え:toggled
	切詰めら:clamp さ:切り詰めら
	前置／先頭に挿入-:prepend
	挿入-:insert:~
	区切
	収まら:fit しな:~
	取得
	含:include
	含まれる:contained
	含む:contain
	含んで:containing
	呼ばれ:called
	呼び出:invoke／call
	検索:look for
	揃:align
	操作:operation:~
	操作中:-
	操作可否
	形／成し／form:form
	実行
	成す:constituent
	constitutes
	戻す／返す:return
	数える／数に入れる:count
	現れる:appear
	生じる:occur
	終わる:end
	絞り込む:filtering
	記され／書き出された:written
	挙げられる:listed
	指している／:pointing
	指す／~~指定する:designate
	~~付随する:attach された
	最も先祖の要素:traversing parent links from element until an element without a parent is encountered
	consisting
	consists
	doing
	having
	hits
	happen
	using
	put
	include
	move:
	process:
	take
	あてがう:assign
	ふるまう:acts
	やりとり:interact-
	Repeated occurrances繰り返し:

	●未分類
HTML:
XML:
DOM:
CSS:
keyword:::キーワード
browser:::ブラウザ
script:::スクリプト
literal:::リテラル
protocol:::プロトコル
boolean:::ブーリアン
述語:predicate:~
test:::テスト
flag:::フラグ
slot:::スロット
algo:algorithm::アルゴリズム
	バージョン:version:~
schema:::スキーマ
privacy:::プライバシー
security:::セキュリティ

hardware:::ハードウェア
pen:::ペン
system:::システム
video:::ビデオ
hint:::ヒント
comment:::コメント
top-level:::トップレベル
filter:::フィルタ
file:::ファイル
on:::オン

名前:name:~
名:name:~
命名-:name:~
値:value:~
引数:argument:~
mode:::モード
obj:object::オブジェクト
動的:dynamic:~
既定:default:~::デフォルト
既定の:default:~::デフォルト

表記体系:writing system:~
標準中国語:Chinese:~
方言:dialect:~
繁体字:traditional Chinese:~
tag:::タグ
下位tag:subtag::下位タグ
data:::データ
text:::テキスト
markup:::マークアップ
code:::コード
error:::エラー
access:::アクセス
表現-:represent:~
表現:representation:表現
演算子:operator:~
演算:operation:~
失敗:failure:~
成功:success:~
文脈:context:~
文脈上の:contextual:~
item:::アイテム
状態:state:~


等価:equivalent:~
等価性:equivalence:~
種別:type:~
階層的:hierarchical:~
	階層:


	結果:result:~
集合:set:~
	一連の:set
和集合:union:~
形式:format:~
論理的:logical:~
構造的:structural:~
演算:operation:~
視覚的:visual:~
記憶域:storage:~

単語:word:~
内側:inside:~
画像:image:~
動画:video:~::ビデオ
音声:audio:~
隣接性:adjacency:~
改行:linebreak:~
字幕:subtitle:~
	奇数:odd:~
	偶数:even:~
一意:unique:~
段落:paragraph:~
graph:::グラフ
近隣:neighbors:~
library:::ライブラリ
縞模様:zebra-stripe:~
背景:background:~
色:color:~
	green
	red
単純:simple:~
初期:initial:~
	初期~時:initially
可視の:visible な:~
	~~組み合わせ:mixtures
式:expression:~
引用文:quotations:~
見出し:heading:~
	~~見出し:title
	~~見出し行:headline
境界:boundary:~

	高い:higher
	より遠い:later
	2 次元: 2D
	greater
	key
	long
	none
	pre
	time
	フランス語:French
	ベルギー・フランス語／ドイツ語:Belgian French／German
	一定周期:cycle
	一覧
	並び:sequence
	主:primary
	主に:primarily
	主導:-primary
	交替的に float ~~配置:alternate the position of floated
	交替的／順繰りに／別形:alternate
	付与
	位置／:position
	処理
	可能
	地点:point
	大きさ:size
	人:human
	期間:period
	正の:positive
	負の:negative
	点線:dashed
	無い:missing
	次第
	種類:kind／
	空でない:non-zero length
	等しい:equal
	等しければ:tied
	節:section
	~text~node:standalone text
	行:line
	部品:component／
	~~限定

	●指示／限定語
候補:candidate:~
所与の:与えられた
単独の:single:~
現在の:current:~
新たな:new:~
	他の場合:otherwise
	among:
	すべての方々:everyone
	whichever:
	ほとんど:mostly／almost／most
	決して:never
	既に:already
	非:non:
	別物
	代わりに:instead
	他種:
	ある部分:some extent
	ある／一部の:certain
	上述:
	上記参照
	anything
	elsewhere
	else
	followed
	following
	follows
	now
	just
	things
	three
	whatever:
	whenever:
	whose
	多くの:many
	least
	once
	others
	over
	prev
	prior
	sole
	sometimes
	~~単独:alone
	~~成分:portion
	〜でも〜でもない:neither 〜nor
	〜に対して:against
	いくつかの／複数の／挙げる:several
	それ自身:itself
	どこでも:anywhere
	もしあれば:if any
	もの:ones
	一度
	一方
	一種
	一連
	一部
	一部分
	両方
	両者
	以上
	以下
	以前
	以外
	任意の:arbitrary／any
	個
	個
	個数
	個目:second／third／fourth／th
	最も深い:deepest
	最初:first
	最後:last
	次の:next
	自身
	個／つ:two／four:
	全:full
	全体:entire
	別の:another
	前の:previous
	前後:around
	前後:before/after, and/or after
	前者:former
	後者:latter
	同じ:same
	唯一
	外側:outside
	周囲の:surrounding
	多数
	少数:a few
	対象
	対象範囲
	後続
	元の:source
	間:during
	複数:multiple/several
	複数個の値:multiple-value
	先頭の:leading
	先頭の~colon:initial punctuation
	最大
	最短:shortest
	場所
	直下:underneath
	直前に位置する:immediately preceded
	直後:immediately followed by
	直近の:closest
	respectively
	異なる:different
	異ならせる:differentiate
	異なるように:differently
	絞り込み:-classing
	同時:simultaneous
	当該
	有無
	有無が~~未設定:neither 〜 nor
	より低く:lower
	より大きい:larger
	後続／先行するすべての:(possibly indirect) next／previous
	他方:On the other hand
	場合によっては:possibly
	一致:exactly equal
	一致する／同じに:identical
	起こり得る／可能／:possible
	超え:overflow
	部分:part
	逆向き:in reverse
	二重:double

</script>


<!--%links -->
<script type="text/plain" id="_link_map">

	DTD 内で与えられる属性の既定~値:#def-values
~ID選択子:#id-selector
~ID選択子§:#id-selectors
名前空間:#type-nmsp
型:#type-selectors
詳細度:#specificity
	名前空間 接頭辞:#namespace-prefix


選択子:#selector
選択子として構文解析-:#parse-a-selector
選択子の構文解析-法§:#parse-selector
選択子の概観§:#overview
選択子の構文と構造§:#syntax
選択子の詳細度の計算-法§:#specificity-rules
合致する:#selector-match

疑似要素:#pseudo-element
疑似要素§:#pseudo-elements
疑似要素の種別§:#pseudo-element-types
出自の要素:#originating-element

木に対し選択子を照合する§:#match-against-tree
木に対し選択子を照合-:#match-a-selector-against-a-tree
要素に対し選択子を照合する§:#match-against-element
要素に対し選択子を照合-:#match-a-selector-against-an-element
要素に対し複体~選択子を照合-:#match-a-complex-selector-against-an-element
疑似要素に対し選択子を照合する§:#match-against-pseudo-element
疑似要素に対し選択子を照合-:#match-a-selector-against-a-pseudo-element
同胞群:#_siblings

単体~選択子:#simple
合体~選択子:#compound
複体~選択子:#complex
の~list:#list-of-simple-selectors
選択子~list:#selector-list
選択子~list§:#grouping
部分照合 属性~選択子§:#attribute-substrings
全称~選択子:#universal-selector
全称~選択子§:#the-universal-selector
~ID選択子§:#id-selectors
~class選択子§:#class-html
~class選択子:#class-selector
基本的な選択子§:#elemental-selectors
基本的な選択子における名前空間§:#type-nmsp
型~選択子:#type-selector
型（~tag名）選択子§:#type-selectors
属性~存在0／属性~値~選択子§:#attribute-representation
属性~選択子:#attribute-selector
属性~選択子§:#attribute-selectors
属性~選択子と名前空間§:#attrnmsp
格子構造~選択子§:#table-pseudos

相対~選択子:#relative-selector
相対~選択子§:#relative
相対~選択子の~listを絶対化:#absolutize-list
絶対化:#absolutize
相対~選択子として構文解析-:#parse-a-relative-selector
相対~選択子の構文解析-法§:#parse-relative-selector
相対~選択子の絶対化§:#absolutizing

無効な選択子:#invalid-selector
無効な選択子と~errorの取扱い§:#invalid
	fast vs complete 選択子~profile§:#profiles
視野根:#scoping-root
視野要素:#scoping-element
視野付き選択子:#scoped-selector
視野付き:#scoped-selector
視野付き選択子§:#scoping
~scope_ps要素:#scope-element
選択対象:#selector-subject
~virtual:#virtual-scoping-root
結合子:#selector-combinator
結合子§:#combinators
~column結合子:#column-combinator
~column結合子§:#the-column-combinator
後続同胞~結合子:#subsequent-sibling-combinator
後続同胞~結合子§:#general-sibling-combinators
子孫~結合子:#descendant-combinator
子孫~結合子§:#descendant-combinators
子~結合子:#child-combinator
子~結合子§:#child-combinators
次同胞~結合子:#next-sibling-combinator
次同胞~結合子§:#adjacent-sibling-combinators

疑似類:#pseudo-class
疑似類§:#pseudo-classes
範囲~疑似類§:#range-pseudos
自然言語 疑似類§:#the-lang-pseudo
自然言語:#language
自然言語に関する疑似類§:#linguistic-pseudos
言語範囲:#language-range
論理和 疑似類§:#matches
論理的な組合せ§:#logical-combination
起点要素 疑似類§:#the-scope-pseudo
過去要素 疑似類§:#the-past-pseudo
選択-済み疑似類§:#checked
関数形~疑似類:#functional-pseudo-classes
~drag-and-drop疑似類§:#drag-pseudos
~pointer~hover疑似類§:#the-hover-pseudo
target 疑似類§:#the-target-pseudo
所在 疑似類§:#location
~hyperlink疑似類§:#the-any-link-pseudo
~link履歴 疑似類§:#link
不定 疑似類§:#indeterminate
仮入力例示 疑似類§:#placeholder
作動化 疑似類§:#the-active-pseudo
入力 疑似類§:#input-pseudos
入力~focus疑似類§:#the-focus-pseudo
入力~focus環 疑似類§:#the-focusring-pseudo
一般化 入力~focus疑似類§:#the-focus-within-pseudo

利用者~動作 疑似類§:#useraction-pseudos
利用者~対話 疑似類§:#user-pseudos
否定~疑似類§:#negation
有型 子付番 疑似類§:#typed-child-index
変更可否 疑似類§:#rw-pseudos
妥当性 疑似類§:#validity-pseudos
子付番 疑似類§:#child-index
必須随意 疑似類§:#opt-pseudos
操作可否 疑似類§:#enableddisabled
方向性 疑似類§:#the-dir-pseudo
既定option 疑似類§:#the-default-pseudo
時系列 疑似類§:#time-pseudos
未来要素 疑似類§:#the-future-pseudo
構造と各種用語§:#structure
構造上の疑似類:#structural-pseudo-classes
構造上の疑似類§:#structural-pseudos
関係上の疑似類§:#relational
現在要素 疑似類§:#the-current-pseudo

~host言語:#host-language
文書~言語:#document-language
無特能:#featureless
静的~profile:#static-profile
動的~profile:#dynamic-profile
~data~model§:#data-model
~module間の相互作用§:#placement

入力~controlの状態§:#input-states
入力~値の検査-法§:#ui-validity
入力~値の状態§:#input-value-states
~API~hook§:#api-hooks
	DTD 内で与えられる属性の既定~値§:#def-values
名前空間§:#namespaces

変更点§:#changes

空白:#whitespace
宣言-:#nsdecl
未宣言:#nsdecl
属性~値の文字大小の区別§:#attribute-case
文字大小の区別§:#case-sensitive

序論§:#context
文法§:#grammar
表記規約§:#conventions
適合性§:#conformance
適合性の定義とその適用対象§:#conformance-classes
	試験的実装§:#experimental
	部分的実装§:#partial
	特能:#feature


	● production: id = text = key
	combinator:combinator0

	● §疑似類 id= 
	blank:the-blank-pseudo
	empty:the-empty-pseudo
	first-child:the-first-child-pseudo
	first-of-type:the-first-of-type-pseudo
	last-child:the-last-child-pseudo
	last-of-type:the-last-of-type-pseudo
	nth-child():the-nth-child-pseudo
	nth-column():the-nth-column-pseudo
	nth-last-child():the-nth-last-child-pseudo
	nth-last-column():the-nth-last-column-pseudo
	nth-last-match():the-nth-last-match-pseudo
	nth-last-of-type():the-nth-last-of-type-pseudo
	nth-match():the-nth-match-pseudo
	nth-of-type():the-nth-of-type-pseudo
	only-child:the-only-child-pseudo
	only-of-type:the-only-of-type-pseudo
	root:the-root-pseudo

	●値（参照元なし）
	active:valdef-drop-active
	invalid:valdef-drop-invalid
	valid:valdef-drop-valid

ps.paused:#selectordef-paused
ps.playing:#selectordef-playing

	●外部
ps.host:~SCOPING#selectordef-host
ps.host-context():~SCOPING#selectordef-host-context
ps.dir(ltr):~HTMLselectors#selector-ltr
ps.dir(rtl):~HTMLselectors#selector-rtl
ps.-moz-ui-invalid:https://developer.mozilla.org/en-US/docs/Web/CSS/%3A-moz-ui-invalid
	ps.-moz-ui-valid:https://developer.mozilla.org/en-US/docs/Web/CSS/%3A-moz-ui-valid

pe.before:~CSSWG/css-pseudo-4/#selectordef-before
pe.after:~CSSWG/css-pseudo-4/#selectordef-after
pe.first-line:~CSSWG/css-pseudo-4/#selectordef-first-line
pe.first-letter:~CSSWG/css-pseudo-4/#selectordef-first-letter
pe.shadow:~TR/css-scoping-1/#selectordef-shadow
pe.content:~TR/css-scoping-1/#selectordef-content
pe.slotted:~SCOPING#selectordef-slotted


p.display:~CSSDISP#propdef-display
	~CSS2VISUREN#propdef-display
p.visibility:~CSS2VISUFX#propdef-visibility
p.direction:~CSSWM#propdef-direction

e.html:~HEmetadata#the-html-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
e.a:~HEtextlevel#the-a-element
e.em:~HEtextlevel#the-em-element
e.q:~HEtextlevel#the-q-element
e.span:~HEtextlevel#the-span-element

e.div:~HEgrouping#the-div-element
e.dl:~HEgrouping#the-dl-element
e.dt:~HEgrouping#the-dt-element
e.li:~HEgrouping#the-li-element
e.menu:~HEgrouping#the-menu-element
e.ol:~HEgrouping#the-ol-element
e.p:~HEgrouping#the-p-element
e.pre:~HEgrouping#the-pre-element

e.body:~HEsections#the-body-element
e.section:~HEsections#the-section-element
	e.h1:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
	e.h2:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements

e.area:~HEimages#the-area-element
e.img:~HEimages#the-img-element
e.object:~HEembed#the-object-element

e.input:~HEinput#the-input-element
e.form:~HEforms#the-form-element
e.fieldset:~HEforms#the-fieldset-element
e.button:~HEforms#the-button-element
e.label:~HEforms#the-label-element
e.option:~HEforms#the-option-element
e.select:~HEforms#the-select-element

e.td:~HEtables#the-td-element
e.tr:~HEtables#the-tr-element

	a.placeholder:~HEinput#attr-input-placeholder
	a.placeholder:~HEforms#attr-textarea-placeholder
	a.contenteditable
	a.selected
	a.checked
	●＊
t.any-value:~CSSSYN#typedef-any-value
t.attr-matcher:#typedef-attr-matcher
t.attr-modifier:#typedef-attr-modifier
t.attribute-selector:#typedef-attribute-selector
t.class-selector:#typedef-class-selector
t.combinator:#typedef-combinator
t.complex-selector-list:#typedef-complex-selector-list
t.complex-selector:#typedef-complex-selector
t.compound-selector-list:#typedef-compound-selector-list
t.compound-selector:#typedef-compound-selector
t.delim-token:~CSSSYN#typedef-delim-token
t.function-token:~CSSSYN#typedef-function-token
t.hash-token:~CSSSYN#typedef-hash-token
t.id-selector:#typedef-id-selector
t.ident-token:~CSSSYN#typedef-ident-token
t.ident:~CSSVAL#typedef-ident
t.ns-prefix:#typedef-ns-prefix
t.pseudo-class-selector:#typedef-pseudo-class-selector
t.pseudo-element-selector:#typedef-pseudo-element-selector
t.relative-selector-list:#typedef-relative-selector-list
t.relative-selector:#typedef-relative-selector
t.selector-list:#typedef-selector-list
t.simple-selector-list:#typedef-simple-selector-list
t.simple-selector:#typedef-simple-selector
t.string-token:~CSSSYN#typedef-string-token
t.string:~CSSVAL#string-value
t.type-selector:#typedef-type-selector
t.whitespace-token:~CSSSYN#typedef-whitespace-token
t.wq-name:#typedef-wq-name

	|:~CSSVAL#comb-one
	#:~CSSVAL#mult-comma
	*:~CSSVAL#mult-zero-plus
	+:~CSSVAL#mult-one-plus
	?:~CSSVAL#mult-opt

	ident:~CSSVAL#typedef-ident
	string:~CSSVAL#string-value

I.Element:~DOM4#interface-element
I.Text:~DOM4#interface-text
I.Comment:~DOM4#interface-comment
I.ProcessingInstruction:~DOM4#interface-processinginstruction
I.EntityReference:~DOM4#entityreference
I.DocumentFragment:~DOM4#documentfragment
I.DocumentType:~DOM4#interface-documenttype
I.Document:~DOM4#interface-document
	~HTMLdom#document
c.querySelector():~DOM4#dom-parentnode-queryselector

平坦~木:~SCOPING#flat-tree

木:~DOM4#concept-tree
根:~DOM4#concept-tree-root
子孫:~DOM4#concept-tree-descendant
木~順序:~DOM4#concept-tree-order
~shadow木:~DOM4#concept-shadow-tree
~shadowも含む木~順序:~DOM4#concept-shadow-including-tree-order
~shadowも含む根:~DOM4#concept-shadow-including-root
~shadow~host:~DOM4#element-shadow-host

過去互換~mode:~DOM4#concept-document-quirks

素片:~URLSpec#concept-url-fragment

~ASCII大小無視:~INFRA#ascii-case-insensitive


既定の名前空間:~CSSNS#default-namespace
~CSS有修飾~名:~CSSNS#css-qualified-name
	#css-qnames

~escape処理規則:~CSS22/syndata.html#characters
識別子:~CSSSYN#identifier

~CSS識別子:~CSS22/syndata.html#value-def-identifier

~box:~CSSDISP#css-box
~box木:~CSSDISP#css-box-tree

文書~要素:~DOM4#document-element
広義同胞:~DOM4#concept-tree-inclusive-sibling

</script>

<!-- 
空白~処理に影響される文字:~CSSTEXT#white-space-rules
CSS style 属性:~CSSSTYLEATTR#interpret
~AnB 小構文:~CSSSYN#anb-production
視野付き style 要素:~HEmetadata#the-style-element
作動可能な要素:~HTMLselectors#selector-active
~focusを獲得し得る要素:~HTMLselectors#selector-focus
media 要素の現在の再生位置に相対的:http://dev.w3.org/html5/webvtt/#the-past-and-future-pseudo-classes
	at.namespace:~CSSNS#declaration

-->


<!--% style -->

<style type="text/css" >

/*
a.sec::before {
	content:"§";
}

.prod {
	color: #214869;
}

*/

pre, samp {
	color: #214869;
}

code.property {
	color: darkblue;
}


#_overview_ tr.header1 {
	background:#FEE;
	border-top: 2px inset gray;
	border-bottom: 1px solid gray;
}
#_overview_ tr.header1 > th {
	font-weight: normal;
}
#_overview_ tr.header1 > th > a:first-child{
	font-weight: bold;
}

#_overview_ tr {
	border-top: solid #CCC 1px;
}

	/* Level */
.L3 {
	background: #F8F8E8;
}
.L4 {
	background: #F8F8CC;
}



</style>
<!-- 
#_overview_ tr:nth-child(even) {
	background:#EFF;
}


code.css::before {
	content: "‘"
}
code.css::after {
	content: "’"
}
-->

</head>

<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">
<h1>Selectors Level 4 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">Selectors Level 4</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2017-08-18</time>
（公開：<time>2012-06-23</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1 id="title">選択子 — Selectors Level 4</h1>
<h2>2017 年 8 月 17 日付 編集者草案</h2>
	</hgroup>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dd>https://drafts.csswg.org/selectors/</dd>

	<dt title="Latest version:">最新発行バージョン</dt>
	<dd>https://www.w3.org/TR/selectors4/</dd>

	<dt title="Previous Versions:">以前の発行バージョン</dt>
	<dd>https://www.w3.org/TR/2013/WD-selectors4-20130502/</dd>
	<dd>https://www.w3.org/TR/2012/WD-selectors4-20120823/</dd>
	<dd>https://www.w3.org/TR/2011/WD-selectors4-20110929/</dd>

	<dt title="Test Suite:">テスト一式</dt>
	<dd>http://test.csswg.org/suites/selectors-4_dev/nightly-unstable/</dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="#issues-index">仕様内</a></dd>
	<dd><a href="https://github.com/w3c/csswg-drafts/labels/selectors-4">GitHub Issues</a></dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)</dd>
	<dd><a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)</dd>

	<dt title="Former Editors:">前任編集者</dt>
	<dd><a href="http://www.tantek.com/" lang="tr">Tantek Çelik</a></dd>
	<dd>Daniel Glazman</dd>
	<dd>Ian Hickson</dd>
	<dd>Peter Linss</dd>
	<dd>John Williams</dd>
</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2017 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">permissive document license</a> rules apply.
</small>
	</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
Selectors （~~選択子, ~~セレクタ）とは、文書~内の~nodeを選択するために利用し得る いくつかの技術のうちの一つであり，~node木の中の要素たちと照合するための~patternである。
Selectors は~HTMLおよび~XMLにおける利用に最適化されてきており，処理能が~~重要な~code内でも実用になるように設計されている。
<abbr title="Cascading Style Sheets">~CSS</abbr>
（ Cascading Style Sheets ）においては，文書~内の要素に~style付けの~propを束縛するために Selectors が利用される点で，その中核を成している。
Selectors Level 4 は、 `SELECT$r に既存の選択子について述べることに加え，~CSSや他の言語に必要になり得る新たな選択子を導入する。
◎
Selectors are patterns that match against elements in a tree, and as such form one of several technologies that can be used to select nodes in a document. Selectors have been optimized for use with HTML and XML, and are designed to be usable in performance-critical code. They are a core component of CSS (Cascading Style Sheets), which uses Selectors to bind style properties to elements in the document. Selectors Level 4 describes the selectors that already exist in [SELECT], and further introduces new selectors for CSS and other languages that may need them.
</p>

<p class="trans-note">【
Selectors — この仕様も含めた，選択子を規定する各種~levelの Selectors 仕様の総称
】</p>

~CSSisaLANG

	</section>
	<section id="status">
<h2 title="Status of this Document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<span class="trans-note">【
以下、この節の他の内容は
<a href="css-common-ja.html#status" >CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>


<p id="_at_risk_">
次の特色機能は
<a href="css-common-ja.html#at-risk">~risk下</a>
にあり， CR 期間に取り下げられる可能性があります。
◎
The following features are at-risk, and may be dropped during the CR period:
</p>

<ul >
	<li>
`~column結合子$
◎
the column combinator
</li>
	<li>
`drop()$ps 疑似類
◎
the :drop() pseudo-class
</li>
	<li>
`read-write$ps 疑似類
◎
the :read-write pseudo-class
</li>
</ul>

	</section>

<main id="MAIN0">

	<section id="context">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
選択子とは、木~構造の中の要素を対象に，要素が選択子に合致するかどうかを~testするための、~boolean述語である。
◎
A selector is a boolean predicate that takes an element in a tree structure and tests whether the element matches the selector or not.
</p>

<p>
これらの式には多くの用途がある：
◎
These expressions may be used for many things:
</p>

<ul>
   <li>
`DOM$r にて定義される `element.matches()^c 関数などにおいて，要素が何らかの判定基準に合致するかどうかを直接的に~testする。
◎
directly on an element to test whether it matches some criteria, such as in the element.matches() function defined in [DOM]
</li>
	<li>
`DOM$r にて定義される
`document.queryAll()^c
関数や,
あるいは~CSS~style規則の選択子を通して、要素がなす~node木~全体から，判定基準に合致する要素の集合に絞込む。
◎
applied to an entire tree of elements to filter it into a set of elements that match the criteria, such as in the document.queryAll() function defined in [DOM] or the selector of a CSS style rule.
</li>
	<li>
<a href="http://haml.info/">HAML</a>
や
<a href="https://en.wikipedia.org/wiki/Emmet_(software)">Emmet</a>
などのように、“逆向き” に用いて，与えられた選択子に合致するような~markupを生成する。
◎
used "in reverse" to generate markup that would match a given selector, such as in HAML or Emmet.
</li>
</ul>

<p>
Selectors Level 1, 2, 3 は、それぞれ
<a href="~TR/REC-CSS1">CSS1</a>,
<a href="~CSS22/">CSS2.1</a>,
<a href="~TR/css3-selectors/">Selectors Level 3</a>
仕様に規定され，これらは選択子の機能性の~subsetであるものとして定義される。
この~moduleは Selectors Level 4 を規定する。
◎
Selectors Levels 1, 2, and 3 are defined as the subsets of selector functionality defined in the CSS1, CSS2.1, and Selectors Level 3 specifications, respectively. This module defines Selectors Level 4.
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
この~moduleは、
`SELECT$r および `CSS21$r
にて~CSSのために定義された選択子の定義を置き換え, その集合を拡張する。
◎
This module replaces the definitions of and extends the set of selectors defined for CSS in [SELECT] and [CSS21].
</p>

<p>
具現化~木の中の抽象的な要素を定義する`疑似要素$選択子は、この仕様の一部をなすものではない：
汎用~構文についてはここで述べられるが、それらの具現化~modelとの密接な統合, および~DOM queries 他の無関係な用途などに因り、他の~moduleにて定義されることになる。
◎
Pseudo-element selectors, which define abstract elements in a rendering tree, are not part of this specification: their generic syntax is described here, but, due to their close integration with the rendering model and irrelevance to other uses such as DOM queries, they will be defined in other modules.
</p>
		</section>
		<section id="_conventions">
<h3 class="trans-note">【日本語訳に固有の表記規約】</h3>

<p>
この訳に利用される記号
ε, ~LET, ~EQ, ~ON, ~IF, ~RET,
等々の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>
		</section>
	</section>
	<section id="overview">
<h2 title="Selectors Overview">2. 選択子の概観</h2>

<p>
<em>この節は参考であり，後続の節を要約するものに過ぎない。</em>
◎
This section is non-normative, as it merely summarizes the following sections.
</p>

<p class="trans-note">【
“選択子” という対訳に馴染みが悪ければウィンドウ下端の切り替え機能を利用されたし。
】</p>

<p>
選択子は、構造を表現する。
この構造は、文書~木の中でどの要素が選択子に合致するかを決定するための条件として（例えば~CSS規則における）, あるいは
その構造に対応する~HTMLや~XMLの素片の flat な記述として，利用し得る。
◎
A selector represents a structure. This structure can be used as a condition (e.g. in a CSS rule) that determines which elements a selector matches in the document tree, or as a flat description of the HTML or XML fragment corresponding to that structure.
</p>

<p>
選択子の表現力は、単純な要素~名から多彩な文脈上の表現までに渡る。
◎
Selectors may range from simple element names to rich contextual representations.
</p>

<p>
選択子の構文は，次の一覧に要約される：
◎
The following table summarizes the Selector syntax:
</p>

<p class="trans-note">【
以下において， “ ~E 要素” とは、型（~tag名）が ~E である要素を意味する。
】<br>【
“分類” の見出しは訳者による追加。
】</p>

<table id="_overview_" class="data">

<colgroup>
<col class="pattern">
<col class="meaning">
<col class="section">
<col class="level">
</colgroup>

<thead><tr class="header1"><th colspan="4">分類
<tr><th>~pattern◎Pattern
<th>表現される`選択対象$◎Represents
<th>節◎Section
<th>Level
</thead>

<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`基本的な選択子§

<!-- 
elemental-selectors
	type-selectors
	type-nmsp
	universal-selector
-->
<tr><td>`*^css
<td>
任意の要素
◎
any element
<td>`全称~選択子§
<td>2

<tr><td>`~E^css
<td>
任意の ~E 要素
◎
an element of type E
<td>`型（~tag名）選択子§
<td>1

</tbody>

<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`論理的な組合せ§

<!-- 
logical-combination
grouping
matches
negation
-->
<tr class="L3"><td><code class="css">~E:not(%s1, %s2)</code>
<td>
`合体~選択子$ %s1, %s2 の両者に合致しない ~E 要素
◎
an E element that does not match either compound selector s1 or compound selector s2
<td>`否定~疑似類§
<td>3/4

<tr class="L4"><td><code class="css">~E:matches(%s1, %s2)</code>
<td>
`合体~選択子$ %s1, %s2 の少なくとも一方には合致する ~E 要素
◎
an E element that matches compound selector s1 and/or compound selector s2
<td>`論理和 疑似類§
<td>4

<tr class="L4"><td><code class="css">~E:has(%rs1, %rs2)</code>
<td>
~E を `~scope_ps要素$とした下で， %rs1, %rs2 のいずれかを`相対~選択子$として評価したときに、何らかの要素に合致するような， ~E
◎
an E element, if either of the relative selectors rs1 or rs2, when evaluated with E as the :scope elements, match an element 
<td>`関係上の疑似類§
<td>4

</tbody>

<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`属性~選択子§

<!-- 
attribute-representation
attribute-substrings
attribute-case
attrnmsp
def-values
class-html
id-selectors
-->
<tr><td><code class="css">~E.%warning</code>
<td>
%warning ~class に属する ~E 要素
（要素が属する~classがどのように決定されるかは，文書~言語により指定される）。
◎
an E element belonging to the class warning (the document language specifies how class is determined).
<td>`~class選択子§
<td>1

<tr><td><code class="css">~E#%myid</code>
<td>
~IDが %myid に一致する ~E 要素
◎
an E element with ID equal to myid.
<td>`~ID選択子§
<td>1

<tr><td><code class="css">~E[`foo^a]</code>
<td>
`foo^a 属性を有する ~E 要素
◎
an E element with a foo attribute
<td>`属性~存在0／属性~値~選択子§
<td>2

<tr><td><code class="css">~E[`foo^a="%bar"]</code>
<td>
`foo^a 属性~値が %bar に一致する ~E 要素
◎
an E element whose foo attribute value is exactly equal to bar
<td>`属性~存在0／属性~値~選択子§
<td>2

<tr class="L4"><td><code class="css">~E[`foo^a="%bar" i]</code>
<td>
`~ASCII大小無視$の下で， `foo^a 属性~値が %bar に一致する ~E 要素
◎
an E element whose foo attribute value is exactly equal to any (ASCII-range) case-permutation of bar
<td>`属性~値の文字大小の区別§
<td>4

<tr><td><code class="css">~E[`foo^a~="%bar"]</code>
<td>
`foo^a 属性~値を`空白$区切りで分割したときに，いずれかの項が %bar に一致する ~E 要素
◎
an E element whose foo attribute value is a list of whitespace-separated values, one of which is exactly equal to bar
<td>`属性~存在0／属性~値~選択子§
<td>2

<tr class="L3"><td><code class="css">~E[`foo^a^="%bar"]</code>
<td>
`foo^a 属性~値が文字列 %bar から始まる ~E 要素
◎
an E element whose foo attribute value begins exactly with the string bar
<td>`部分照合 属性~選択子§
<td>3

<tr class="L3"><td><code class="css">~E[`foo^a$="%bar"]</code>
<td>
`foo^a 属性~値が文字列 %bar で終わる ~E 要素
◎
an E element whose foo attribute value ends exactly with the string bar
<td>`部分照合 属性~選択子§
<td>3

<tr class="L3"><td><code class="css">~E[`foo^a*="%bar"]</code>
<td>
`foo^a 属性~値が %bar を部分文字列として包含する ~E 要素
◎
an E element whose foo attribute value contains the substring bar
<td>`部分照合 属性~選択子§
<td>3

<tr><td><code class="css">~E[`foo^a|="%en"]</code>
<td>
`foo^a 属性~値を~hyphen区切りで分割したときに，その最初の項が %en に一致する ~E 要素
◎
an E element whose foo attribute value is a hyphen-separated list of values beginning with en
<td>`属性~存在0／属性~値~選択子§
<td>2

</tbody>

<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`自然言語に関する疑似類§

<!-- 
the-dir-pseudo
the-lang-pseudo
 -->

<tr class="L4"><td>`~E:dir(ltr)^css
<td>
方向性が left-to-right の ~E 要素
（方向性がどのように決定されるかは文書~言語が指定する）
◎
an element of type E in with left-to-right directionality (the document language specifies how directionality is determined)
<td>`方向性 疑似類§
<td>4

<tr><td>`~E:lang(zh, "*-hant")^css
<td>
言語~tagが［
標準中国語（そのどの方言／表記体系も含む）, あるいは繁体字で記されたもの
］として付与された下にある ~E 要素
◎
an element of type E tagged as being either in Chinese (any dialect or writing system) or otherwise written with traditional Chinese characters
<td>`自然言語 疑似類§
<td>2/4

</tbody>

<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`所在 疑似類§（
以下における “~link” とは、~hyperlinkの~source~anchorを意味する
）

<!-- 
the-any-link-pseudo
link
the-target-pseudo
the-scope-pseudo
 -->
<tr class="L4"><td>`~E:any-link^css
<td>
~linkである ~E 要素
◎
an E element being the source anchor of a hyperlink
<td>`~hyperlink疑似類§
<td>4

<tr><td>`~E:link^css
<td>
~targetが未訪問の~linkである ~E 要素
◎
an E element being the source anchor of a hyperlink of which the target is not yet visited
<td>`~link履歴 疑似類§
<td>1

<tr><td>`~E:visited^css
<td>
~targetが訪問済み~linkである ~E 要素
◎
an E element being the source anchor of a hyperlink of which the target is already visited
<td>`~link履歴 疑似類§
<td>1

<tr class="L3"><td>`~E:target^css
<td>
参照元 URL から~targetにされている ~E 要素
◎
an E element being the target of the referring URL
<td>`target 疑似類§
<td>3

<tr class="L4"><td>`~E:scope^css
<td>
`~scope_ps要素$に~~指定されている ~E 要素
◎
an E element being a designated reference element
<td>`起点要素 疑似類§
<td>4

</tbody>


<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`時系列 疑似類§

<!-- 
the-current-pseudo
the-past-pseudo
the-future-pseudo
-->

<tr class="L4"><td>`~E:current^css
<td>
時系列再生の下で現在~呈示-中の ~E 要素
◎
an E element that is currently presented in a time-dimensional canvas
<td>`現在要素 疑似類§
<td>4

<tr class="L4"><td>`~E:current(~S)^css
<td>
最も階層が深い `current$ps 要素であって, 選択子 ~S に合致する ~E 要素。
【？】
◎
an E element that is the deepest :current element that matches selector s
<td>`現在要素 疑似類§
<td>4

<tr class="L4"><td>`~E:past^css
<td>
時系列再生の下で過去に現れた ~E 要素
◎
an E element that is in the past in a time-dimensional canvas
<td>`過去要素 疑似類§
<td>4

<tr class="L4"><td>`~E:future^css
<td>
時系列再生の下で未来に現れる ~E 要素
◎
an E element that is in the future in a time-dimensional canvas
<td>`未来要素 疑似類§
<td>4

</tbody>


<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`利用者~動作 疑似類§

<!-- 
the-hover-pseudo
the-active-pseudo
the-focus-pseudo
drag-pseudos
-->

<tr><td>`~E:active^css
<td>
作動化された ~E 要素
◎
an E element that is in an activated state
<td>`作動化 疑似類§
<td>1

<tr><td>`~E:hover^css
<td>
~cursorが指している要素, またはその要素を子孫に持つ
~E 要素
◎
an E element that is under the cursor, or that has a descendant under the cursor
<td>`~pointer~hover疑似類§
<td>2

<tr><td>`~E:focus^css
<td>
利用者入力の~focusを得ている ~E 要素
◎
an E element that has user input focus
<td>`入力~focus疑似類§
<td>2

<tr><td>`~E:focus-ring^css
<td>
利用者入力の~focusを得ている ~E 要素のうち，~UAが その要素に対し ~focus環その他の指示子が描かれるべきと決定したもの
◎
an E element that has user input focus, and the UA has determined that a focus ring or other indicator should be drawn for that element
<td>`入力~focus環 疑似類§
<td>4

<tr class="L4"><td>`~E:focus-within^css
<td>
`~E:focus^css に合致する要素, および その先祖
【この項目は、訳者による補完】
<td>`一般化 入力~focus疑似類§
<td>4？

<tr class="L4"><td>`~E:drop^css
<td>
~dropされた~itemを場合によっては受取れる ~E 要素
— （次の 3 項も含め，）~drag操作中に限り，適用される
◎
an E element that can possibly receive a drop
<td>`~drag-and-drop疑似類§
<td>4

<tr class="L4"><td>`~E:drop(active)^css
<td>
~dragしている~itemがその場で~dropされたとするときに，それを受取る ~E 要素
◎
an E element that is the current drop target for the item being dragged
<td>`~drag-and-drop疑似類§
<td>4

<tr class="L4"><td>`~E:drop(valid)^css
<td>
~dragしている~itemに対し “有効な” ~drop先である ~E 要素
◎
an E element that could receive the item currently being dragged
E:drop(invalid)
<td>`~drag-and-drop疑似類§
<td>4

<tr class="L4"><td>`~E:drop(invalid)^css
<td>
~dragしている~itemに対しては “無効な” ~drop先である ~E 要素
◎
an E element that cannot receive the item currently being dragged, but could receive some other item
<td>`~drag-and-drop疑似類§
<td>4
	</tbody>



<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`入力 疑似類§（
“UI” は “利用者~interface” の略語
）

<!-- 
input-states
enableddisabled
rw-pseudos
placeholder
the-default-pseudo
input-value-states
checked
indeterminate
ui-validity
validity-pseudos
range-pseudos
opt-pseudos
user-pseudos
 -->

<tr class="L3"><td>`~E:enabled^css<br>`~E:disabled^css
<td>
順に、［
可能化-, 不能化-
］されている，型 ~E の~UI要素
◎
a user interface element E that is enabled or disabled, respectively
<td>`操作可否 疑似類§
<td>3

<tr class="L3"><td>`~E:read-only^css<br>`~E:read-write^css
<td>
順に、利用者が内容を［
改めれる, 改めれない
］ような，型 ~E の~UI要素
◎
a user interface element E that is user alterable, or not
<td>`変更可否 疑似類§
<td>3-UI/4

<tr class="L3"><td>`~E:placeholder-shown^css
<td>
現在~仮入力~textを例示している，型 ~E の入力~control
◎
an input control currently showing placeholder text
<td>`仮入力例示 疑似類§
<td>3-UI/4

<tr class="L3"><td>`~E:default^css
<td>
一連の選択肢の中で既定の選択肢にされている，型 ~E の~UI要素
◎
a user interface element E that is the default item in a group of related choices
<td>`既定option 疑似類§
<td>3-UI/4

<tr class="L3"><td>`~E:checked^css
<td>
~checkまたは選択されている，型 ~E の~UI要素 
（~radio~buttonや~checkboxなど）
◎
a user interface element E that is checked/selected (for instance a radio-button or checkbox)
<td>`選択-済み疑似類§
<td>3

<tr class="L4"><td>`~E:indeterminate^css
<td>
不定の（~checkの有無が~~未設定の）状態にある，型 ~E の~UI要素
◎
a user interface element E that is in an indeterminate state (neither checked nor unchecked)
<td>`不定 疑似類§
<td>4

<tr class="L3"><td>`~E:valid^css<br>`~E:invalid^css
<td>
順に、入力~値が［
妥当である, 妥当でない
］ような，型 ~E の利用者入力~要素
◎
a user-input element E that meets, or doesn’t, its data validity semantics
<td>`妥当性 疑似類§
<td>3-UI/4

<tr class="L3"><td>`~E:in-range^css<br>`~E:out-of-range^css
<td>
順に、入力~値が［
範囲~内, 範囲~外
］にある，型 ~E の利用者入力~要素
◎
a user-input element E whose value is in-range/out-of-range
<td>`範囲~疑似類§
<td>3-UI/4

<tr class="L3"><td>`~E:required^css<br>`~E:optional^css
<td>
順に、入力が必須［
である, でない
］，型 ~E の利用者入力~要素
◎
a user-input element E that requires/does not require input
<td>`必須随意 疑似類§
<td>3-UI/4

<tr class="L3"><td>`~E:user-invalid^css
<td>
入力~値が不正な（妥当でない†, 範囲~外†, 必須にもかかわらず未入力），型 ~E の利用者入力~要素
【†かつ，利用者から何か入力されているような】
◎
a user-altered user-input element E with incorrect input (invalid, out-of-range, omitted-but-required)
<td>`利用者~対話 疑似類§
<td>3-UI/4


	</tbody>

<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`構造上の疑似類§（
以下における “同胞” とは、 “同胞要素” の略記であり（~textなど他種の~nodeは除外される），同じ親を共有する（正確には，同じ`同胞群$に属する），`木~順序$による一連の要素を意味する）。

<!-- 
anb
anb-syntax
anb-grammar
child-index
 -->
<tr class="L3"><td>`~E:root^css
<td>
文書の根である ~E 要素
◎
an E element, root of the document
<td>`root$PS<td>3

<tr class="L3"><td>`~E:empty^css
<td>
（ Text ~nodeも含め）子~nodeを持たない ~E 要素
◎
an E element that has no children (not even text nodes)
<td>`empty$PS<td>3

<tr class="L4"><td>`~E:blank^css
<td>
`空白$以外の内容を持たない ~E 要素
◎
an E element that has no content except maybe white space
<td>`blank$PS<td>4

<tr class="L3"><td>`~E:nth-child(~n [of ~S]?)^css
<td>
同胞の中で ~S に合致するような ~n 個目の要素であって， ~E 要素であるもの
◎
an E element, the n-th child of its parent matching sel
<td>`nth-child()$PS<td>3

<tr class="L3"><td>`~E:nth-last-child(~n [of ~S]?)^css
<td>
同胞の中で ~S に合致するような最後から ~n 個目の要素であって， ~E 要素であるもの
◎
an E element, the n-th child of its parent matching sel, counting from the last one
<td>`nth-last-child()$PS<td>3

<tr><td>`~E:first-child^css
<td>
同胞の中で最初の要素であって， ~E 要素であるもの
◎
an E element, first child of its parent
<td>`first-child$PS<td>2

<tr class="L3"><td>`~E:last-child^css
<td>
同胞の中で最後の要素であって， ~E 要素であるもの
◎
an E element, last child of its parent
<td>`last-child$PS<td>3

<tr class="L3"><td>`~E:only-child^css
<td>
自身以外に同胞は無い ~E 要素
◎
an E element, only child of its parent
<td>`only-child$PS<td>3

<tr class="L3"><td>`~E:nth-of-type(~n)^css
<td>
同胞の中の ~E 要素のうち， ~n 個目のもの
◎
an E element, the n-th sibling of its type
<td>`nth-of-type()$PS<td>3

<tr class="L3"><td>`~E:nth-last-of-type(~n)^css
<td>
同胞の中の ~E 要素のうち，最後から ~n 個目のもの
◎
an E element, the n-th sibling of its type, counting from the last one
<td>`nth-last-of-type()$PS<td>3

<tr class="L3"><td>`~E:first-of-type^css
<td>
同胞の中の ~E 要素のうち，最初のもの
◎
an E element, first sibling of its type
<td>`first-of-type$PS
<td>3

<tr class="L3"><td>`~E:last-of-type^css
<td>
同胞の中の ~E 要素のうち，最後のもの
◎
an E element, last sibling of its type
<td>`last-of-type$PS<td>3

<tr class="L3"><td>`~E:only-of-type^css
<td>
同胞である ~E 要素が自身の他にないもの
◎
an E element, only sibling of its type
<td>`only-of-type$PS<td>3

</tbody>

<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`結合子§（
語  “同胞” は上記参照
）


<tr><td>`~E ~F^css
<td>
~E 要素の子孫である ~F 要素
◎
an F element descendant of an E element
<td>`子孫~結合子§
<td>1
<tr class="L4"><td>`~E &gt;&gt; ~F^css
<td>
同上
<td>同上<td>4

<tr><td>`~E &gt; ~F^css
<td>
~E 要素の子である ~F 要素
◎
an F element child of an E element
<td>`子~結合子§
<td>2

<tr><td>`~E + ~F^css
<td>
同胞の中で， ~E 要素の直後にある ~F 要素
◎
an F element immediately preceded by an E element
<td>`次同胞~結合子§
<td>2

<tr class="L3"><td>`~E ~ ~F^css
<td>
同胞の中で， ~E 要素に後続している ~F 要素
◎
an F element preceded by an E element
<td>`後続同胞~結合子§
<td>3

</tbody>

<tbody><tr class="header1"><th colspan="4" scope="rowgroup">
`格子構造~選択子§


<tr class="L4"><td>`~F || ~E^css
<td>
格子／~table内の， ~F 要素で表現される~columnに属する~cellを表現する ~E 要素
◎
an E element that represents a cell in a grid/table belonging to a column represented by an element F
<td>`~column結合子§
<td>4

<tr class="L4"><td>`~E:nth-column(~n)^css
<td>
格子／~table内の ~n 個目の~columnに属する~cellを表現する ~E 要素
◎
an E element that represents a cell belonging to the nth column in a grid/table
<td>`nth-column()$PS<td>4

<tr class="L4"><td>`~E:nth-last-column(~n)^css
<td>
格子／~table内の最後から ~n 個目の~columnに属する~cellを表現する ~E 要素
◎
an E element that represents a cell belonging to the nth column in a grid/table, counting from the last one
<td>`nth-last-column()$PS<td>4
</tbody>

</table>

<p class="note">注記：
一部の Level 4 選択子（上の一覧で "3-UI" と記されているもの）は
`CSS3UI$r
にて導入されたものである。
◎
Note: Some Level 4 selectors (noted above as "3-UI") were introduced in [CSS3UI].
</p>

		<section id="profiles">
<h3 title="Dynamic vs Static Selector Profiles">2.1. 選択子の <i>動的</i> vs <i>静的</i> ~profile</h3>

<p>
選択子は，多種多様な処理能の文脈~下で利用される。
あいにく、一部の強力な選択子は，処理能に左右され易い文脈に含めるには 現実的に負荷が高過ぎる。
これに適応するため、 Selectors 仕様には 2 種類の~profileが定義される：
◎
Selectors are used in many different contexts, with wildly varying performance characteristics. Some powerful selectors are unfortunately too slow to realistically include in the more performance-sensitive contexts. To accommodate this, two profiles of the Selectors spec are defined:
</p>

<dl>
	<dt>`動的~profile@</dt>
	<dd>
<p>
`動的~profile$は、~browserにおける動的な~CSS選択子の照合も含めた，任意の文脈の下での利用に適切になるものである。
次のもの以外の，この文書にて定義されるすべての選択子が含まれる：
◎
The dynamic profile is appropriate for use in any context, including dynamic browser CSS selector matching. It includes every selector defined in this document, except for:
</p>

<ul><li>
`has()$ps 疑似類
◎
The :has() pseudo-class
</li></ul>

	</dd>

	<dt>`静的~profile@</dt>
	<dd>
`静的~profile$は，処理能にあまり左右されない文脈の下で適切になる。
特に，静的な文書~木に対し選択子を評価する文脈~下で適切になる。
例えば、 `DOM$r にて定義される `query()^c ~methodは，静的~profileを用いるべきである。
これには，この文書に定義されるすべての選択子が含まれる。
◎
The static profile is appropriate for contexts which aren’t extremely performance sensitive; in particular, it’s appropriate for contexts which evaluate selectors against a static document tree. For example, the query() method defined in [DOM] should use the static profile. It includes all of the selectors defined in this document.
</dd></dl>

<p>
Selectors Level 4 に適合する~CSS実装は、~CSSによる選択に際しては，`動的~profile$を用い~MUST。
`動的~profile$を利用する実装は、~profileに含まれない選択子を，未知の／無効なものとして扱わ~MUST。
◎
CSS implementations conformant to Selectors Level 4 must use the dynamic profile for CSS selection. Implementations using the dynamic profile must treat selectors that are not included in the profile as unknown and invalid.
</p>

<p class="issue">
“動的” ／ “静的” ~profileへの仕分けは，実装者による考査を要する。
現時点では動的~profileに仕分けられていないものが，
CSS Selectors にて手頃に行えるならば、それらは移行されるべきである。
◎
The categorization of things into the "dynamic" or "static" profiles needs implementor review. If some things currently not in the dynamic profile can reasonably be done in CSS Selectors, we should move them.
</p>

		</section>
	</section>
	<section id="syntax">
<h2 title="Selector Syntax and Structure">3. 選択子の構文と構造</h2>

		<section id="structure">
<h3 title="Structure and Terminology">3.1. 構造と各種用語</h3>


<p>
語
`選択子@
（ selector ）は、［
`単体~選択子$,
`合体~選択子$,
`複体~選択子$,
`選択子~list$
］の総称である。
◎
The term selector can refer to a simple selector, compound selector, complex selector, or selector list.
</p>

<p class="trans-note">【
この仕様の中では、`複体~選択子$の意味で用いられることが多い。
この種の<a href="#_note1_">同一視</a>は、“一定範囲の要素を選択する” という機能上の観点からは同等に扱える意味で 理に適う面もある一方で，定義などが解り難くなる面もあるので、この訳では必要に応じて注釈を加えている。
】</p>


<p>
`単体~選択子@
（ simple selector ）は、特定0の側面に合致する要素を表現する。
それは、次のいずれかである：
`型~選択子$,
`全称~選択子$,
`属性~選択子$,
`~class選択子$,
`~ID選択子$,
`疑似類$
◎
A simple selector represents an element matched by a particular aspect. A type selector, universal selector, attribute selector, class selector, ID selector, or pseudo-class is a simple selector.
</p>

<p>
`合体~選択子@
（ compound selector ）は、`結合子$で区切られていない`単体~選択子$の並びである。
それは、それが包含するすべての`単体~選択子$に合致するような要素を表現する。
`型~選択子$／`全称~選択子$が並びに包含されるならば、それは先頭に来~MUST。
◎
A compound selector is a sequence of simple selectors that are not separated by a combinator. It represents an element that matches all of the simple selectors it contains. If it contains a type selector or universal selector, that selector must come first in the sequence. Only one type selector or universal selector is allowed in the sequence.
</p>

<p class="note">注記：
空白も妥当な`結合子$である。
`合体~選択子$の中の`単体~選択子$の合間には、空白は許容されない。
◎
Note: As whitespace is a valid combinator, no whitespace is allowed between the simple selectors in a compound selector.
</p>

<p>
`複体~選択子@
（ complex selector ）は、`結合子$で区切られた， 1 個以上の`合体~選択子$の並びである。
◎
A complex selector is a sequence of one or more compound selectors separated by combinators.
</p>

<p class="trans-note" id="_note1_">【
これらの語は，上述の様に階層的な関係で区別されるものであるが、（構文上は／機能的には）同時に：
(1) `型~選択子$や`全称~選択子$は， 1 個の`単体~選択子$からなる`合体~選択子$と見なすこともでき,
(2) `合体~選択子$は， 1 個のそれからなる`複体~選択子$と見なすこともでき,
(3) `複体~選択子$は， 1 個のそれからなる`選択子~list$と見なすこともできる。
その結果， 1 個の`単体~選択子$は，`選択子~list$と見なせることになり、`合体~選択子$の（先頭からの）一部分はまた `合体~選択子$と見なすことことができ，`複体~選択子$の一部分はまた `複体~選択子$と見なすこともできる, 等々になる。

従って，例えば、複体~選択子に適用される~algoや要件は，型~選択子などの単体~選択子や合体~選択子，等々にも（それを複体~選択子と見なした下で）適用されることになる。
】</p>

<div>
<p>
`結合子@
（ combinator ）は、両側にある`合体~選択子$の間の特定0の種類の関係性を表現する。
Selectors Level 4 の結合子には次の 4 種がある：
</p>

<ul>
	<li>
`子孫~結合子$（`空白$）
</li>
	<li>
`子~結合子$（ “大なり記号”, `003E^U ）
</li>
	<li>
`次同胞~結合子$（“正符号”, `002B^U ）
</li>
	<li>
`後続同胞~結合子$（ “~tilde”, `007E^U ）
</li>
</ul>

◎
A combinator represents a particular kind of relationship between the elements matched by the compound selectors on either side. Combinators in Selectors level 4 include: the descendant combinator (white space), the child combinator (U+003E, &gt;), the next-sibling combinator (U+002B, +), and the subsequent-sibling combinator (U+007E, ~).

</div>

<p>
［
`単体~選択子$／`合体~選択子$／`複体~選択子$
］
`の~list@
とは、これらいずれかの選択子からなる~comma区切りの~listである†。
いずれでもよい場合 ／ 周囲の注釈文から明らかな場合は、単に
`選択子~list@
とも称される。
既定では、`複体~選択子$`の~list$の意味になる。
詳細は、`選択子~list§ 節を見よ。
◎
A list of simple/compound/complex selectors is a comma-separated list of simple, compound, or complex selectors. This is also called just a selector list when the type is either unimportant or specified in the surrounding prose; if the type is important and unspecified, it defaults to meaning a list of complex selectors. See §4.1 Selector Lists for further details on selector lists.
</p>

<p class="trans-note">【†
~listが空の場合（空白のみ）、`無効な選択子$になる。
】</p>


<p>
選択子の
`選択対象@
とは、当の選択子【を利用する特色機能】の対象になるもの（ to be about ）として定義される要素たちである：
◎
The subject of a selector is the element(s) that selector is defined to be about:
</p>

<ul>
	<li>
`単体~選択子$に対しては、当の選択子により表現される任意の要素である。
◎
For a simple selector, it is any element represented by that selector.
</li>
	<li>
`合体~選択子$に対しては、それを成す`単体~選択子$すべてに合致するような，任意の要素である。
【すなわち、論理~積】
◎
For a compound selector, it is any element that matches all of its composite simple selectors.
</li>
	<li>
`複体~選択子$に対しては、その最後の`合体~選択子$に合致するような，任意の要素【をその前の部分を成す［合体~選択子と結合子］たちで絞り込んだもの（下の段落を見よ）】
である。
◎
For a complex selector, it is any element that matches the last compound selector in the selector.
</li>
	<li>
`選択子~list$に対しては、その~list内のいずれかの`選択子$に合致するような，任意の要素である。
【すなわち、論理~和】
◎
For a selector list, it is any element that matches any of the selectors in the list.
</li>
</ul>


<p>
選択子の`選択対象$であるような要素は、その選択子に
`合致する@
とされる。
したがって、単独の`合体~選択子$からなる選択子は、それ
【を成す各 単体~選択子】
による要件すべてを満たすような，どの要素にも合致する。
選択子【複体~選択子】に［
別の`合体~選択子$と`結合子$
］を前置することは、要素がその選択子に合致するための，追加の拘束を課すことになる。
よって，選択子の`選択対象$は、常に，最後の`合体~選択子$により表現される要素たちの部分集合になる。
◎
An element is said to match a selector if it is a subject of that selector. Thus a selector consisting of a single compound selector matches any element satisfying its requirements. Prepending another compound selector and a combinator to a sequence imposes additional matching constraints, so the subjects of a complex selector are always a subset of the elements represented by its last compound selector.
</p>


<p class="issue">
これを［
複体~選択子は，その最後の合体~選択子を “表現する”
］と称して， less wishy-washy にできるか？
あるいは、［
%a + %b
］は、［
同胞の関係性の下で，%a と %b の両者を “表現する”
］と述べる必要があるか？
◎
Can we make this less wishy-washy by saying that a complex selector “represents” its last compound selector? Or do we need to have a + b “represent” both an "a" and a "b" in a sibling relationship?
</p>


<p class="issue">
疑似要素は，ここでは取扱われていないが、取扱われるべき。
◎
Pseudo-elements aren’t handled here, and should be.
</p>


		</section>
		<section id="data-model">

<h3 title="Data Model">3.2. ~data~model</h3>


<p>
選択子は、~DOM木 `DOM$r などの要素~木に対し評価される。
この仕様においては、“文書~木”, あるいは “~source文書” とも称される。
◎
Selectors are evaluated against an element tree such as the DOM. [DOM] Within this specification, this may be referred to as the "document tree" or "source document".
</p>


<p>
各~要素は、次に挙げる 5 種の側面
【これらは、以下では “特能（ feature ）” と総称される】
に基いて選択される
— いずれも文字列として照合される：
◎
Each element may have any of the following five aspects, which can be selected against, all of which are matched as strings:
</p>


<ul>
	<li>
要素の型（~tag名としても周知）
◎
The element’s type (also known as its tag name).
</li>
	<li>
要素の名前空間
◎
The element’s namespace.
</li>
	<li>
~ID
◎
An ID.
</li>
	<li>
要素が属する~class（名前を持つ~group）たち
◎
Classes (named groups) to which it belongs.
</li>
	<li>
［
名前, 値
］の対である，属性
◎
Attributes, which are name-value pairs.
</li>
</ul>


<p>
個々の要素には、上述のうち いくつかの特能を欠くものもある中で，
`無特能@
のもの
— すなわち，どの特能も備えないもの —
もある。
`無特能$の要素は，どの選択子にも合致しない
— 明示的に合致するとされるものを除いて。
`無特能$の要素に合致するような選択子は、既定の名前空間 `CSS3NAMESPACE$r も無視して合致し~MUST
◎
While individual elements may lack any of the above features, some elements are featureless. A featureless element does not match any selector at all, except those it is explicitly defined to match. If a given selector is allowed to match a featureless element, it must do so while ignoring the default namespace. [CSS3NAMESPACE]
</p>

<div class="example">
<p>
例えば、`~shadow木$の中の`~shadow~host$は，`無特能$であり、
`host$ps および `host-context()$ps
を除く，<em >どの</em> `疑似類$にも合致しない。
◎
For example, the shadow host in a shadow tree is featureless, and can’t be matched by any pseudo-class except for :host and :host-context().)
</p>
</div>

<p>
選択子の多くは、
`文書~言語@
（すなわち，文書~木の言語と意味論）の意味論に依存したり，
`~host言語@
（すなわち，選択子 構文を利用している言語）の意味論に依存する。
例えば、 `lang()$ps 選択子は、要素が自然言語にどう結付けられるかを定義する際に，`文書~言語$（例： ~HTML）に依存する。
少し異なる例として、 `first-line$pe 疑似要素は、それが何を表現し，それが表現するものに対し何ができるかを定義する際に，`~host言語$（例： ~CSS）に依存する。
◎
Many of the selectors depend on the semantics of the document language
(i.e. the language and semantics of the document tree) and/or the semantics of the host language (i.e. the language that is using selectors syntax). For example, the :lang() selector depends on the document language (e.g. HTML) to define how an element is associated with a language. As a slightly different example, the ::first-line pseudo-element depends on the host language (e.g. CSS) to define what a ::first-line pseudo-element represents and what it can do.
</p>



		</section>
		<section id="scoping">
<h3 title="Scoped Selectors">3.3. 視野付き選択子</h3>

<p>
~host~appは、対象の範囲を文書の特定0の部分木, あるいは文書の一片†に絞る，
`視野付き選択子@
（ scoped selector）を採用することがある。
この部分木の根は
`視野根@
（ scoping root ）と呼ばれる††。
それは、“真の” 要素（
`視野要素@
（ scoping element ）と呼ばれる）であるか，
`~virtual@
のもの（ `DocumentFragment$I など）†††いずれかになる。
◎
Some host applications may choose to scope selectors to a particular subtree or fragment of the document. The root of the scoping subtree is called the scoping root, and may be either a true element (the scoping element) or a virtual one (such as a DocumentFragment).
</p>

<p class="trans-note">【†
`Document^I ~nodeの部分木でないもの（†††）も含め，根が `root$ps に合致しない要素~木
】【††
すなわち，対象の範囲を見渡す “視点”
】</p>

<p>
`視野付き$にされた選択子は、その`視野根$の子孫である要素のみに合致する。
（選択子の残りの部分に対する照合には制約はない
— 視野に入る必要があるのは、`選択対象$になる要素に限られる。）†
◎
When a selector is scoped, it matches an element only if the element is a descendant of the scoping root. (The rest of the selector can match unrestricted; it’s only the final matched elements that must be within the scope.)
</p>

<p class="trans-note">【†
すなわち、視野付きでない下で合致した要素たちを，`視野根$の子孫のみを残すように絞込む。
】</p>


<div class="example">
<p>
例えば， `DOM$r にて定義される要素~上の `querySelector()$c 関数では、作者は，選択子を，その要素による`視野付き$にする下で評価できる。
◎
For example, the element.querySelector() function defined in [DOM] allows the author to evaluate a scoped selector relative to the element it’s called on.
</p>

<p>
`widget.querySelector("a")^c
の様な~callは、 `widget^e 要素の内側にある `a^e 要素のみを見出すことになる
— 文書~内に散らばっている他の `a^e 要素は無視して。
◎
A call like widget.querySelector("a") will thus only find a elements inside of the widget element, ignoring any other as that might be scattered throughout the document.
</p>

</div>

<p class="note">注記：
文脈において，選択子に対し`~scope_ps要素$が明示的に定義されていない場合、`視野根$が`~scope_ps要素$になる。
◎
Note: If the context does not explicitly define any :scope elements for the selector, the scoping root is a :scope element.
</p>


		</section>
		<section id="relative">
<h3 title="Relative Selectors">3.4. 相対~選択子</h3>

<p>
ある種の文脈~下では
`相対~選択子@
が受容される。
それは、ある `~scope_ps要素$（すなわち， `scope$ps に合致する要素<!-- またはvirtual？ -->）に相対的な要素を表現する選択子のための，一種の省略形である。
`相対~選択子$においては、 `scope$ps 疑似類がすでに伴われているものを除く，それぞれの`複体~選択子$の先頭に、暗黙的に "`:scope ^css" （ `scope$ps 疑似類と SPACE （子孫~結合子）の並び）が在るものとみなされる。
これにより、選択子の構文は`結合子$（ `combinator$prod 生成規則）から開始できるようになる。
ただし，`相対~選択子$は、その照合の前に `絶対化$され~MUST。
◎
Certain contexts may accept relative selectors, which are a shorthand for selectors that represent elements relative to a :scope element (i.e. an element that matches :scope). In a relative selector, “:scope ” (the :scope pseudo-class followed by a space) is implied at the beginning of each complex selector that does not already contain the :scope pseudo-class. This allows the selector to begin syntactically with a combinator. However, it must be absolutized before matching.
</p>

<p class="trans-note">【
すなわち，“相対” は、`構造と各種用語§ 節にて定義される各種~選択子の階層~関係とは関係ない，並立する概念であり、従来の選択子を拡張するものである。
したがって、次節の`絶対化$は，従来の選択子も受容し、相対~選択子を受容する文脈は，従来の選択子も受容し得る。
例えば，相対~選択子を引数にとる `has()$ps は、その節の例に示されている様に，実際には従来の選択子も受容する。
】</p>

<p>
絶対化された`相対~選択子$は、追加で`視野付き$にもなり得る。
◎
Relative selectors, once absolutized, can additionally be scoped.
</p>

			<section id="absolutizing">
<h4 title="Absolutizing a Relative Selector">3.4.1. 相対~選択子の絶対化</h4>

<p class="algo-head">
【複体~選択子としての】
`相対~選択子$ ~S の
`絶対化@
は、次で与えられる：
◎
To absolutize a relative selector:
</p>

<ol>
	<li>
<p>
~IF［
`~scope_ps要素$は不在
］~AND［
~S は `~virtual$視野根により`視野付き$にされている
］：
◎
If there are no :scope elements and the selector is scoped to a virtual scoping root:
</p>

		<ol>
			<li>
~IF［
~S は`子~結合子$から開始されている
］
⇒
~RET ~S からその`子~結合子$を除去した結果
— ただし，結果の選択子は、［
その最初の`合体~選択子$は，親が無い要素のみに合致する
］とする追加の拘束を伴うとする。
◎
If the selector starts with a child combinator, remove the child combinator. The selector is now absolute, with the additional constraint that the first compound selector in the selector only matches elements without a parent.
</li>
			<li>
~IF［
~S は［
空白~形による`子孫~結合子$
］でない`結合子$から開始されている
］
⇒
~RET `not()$ps
<span class="note">
これは、何にも合致しないことが保証される，妥当かつ最短の選択子になる。
</span>
◎
Otherwise, if the selector starts with any combinator other than the white space form of the descendant combinator, change the selector to :not(*). This is the shortest selector that is valid, but guaranteed to match nothing.
</li>
			<li>
~RET ~S
（すでに絶対的である。）
◎
Otherwise, the selector is already absolute.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>

		<ol>
			<li>
~IF［
~S は［
空白~形による`子孫~結合子$
］でない`結合子$から開始されている
］
⇒
~RET ~S の先頭に`合体~選択子$として `scope$ps を挿入した結果
◎
If the selector starts with a combinator other than the white space form of the descendant combinator, prepend :scope as the initial compound selector.
</li>
			<li>
~IF［
~S の［
~top-level, または`関数形~疑似類$に対する 1 個の引数
］において，【その先頭に】 `scope$ps 疑似類は与えられていない
］
⇒
~RET ~S の先頭に［
`scope$ps , ［
空白~形による`子孫~結合子$
］］並びを挿入した結果
◎
 Otherwise, if the selector does not contain any instance of the :scope pseudo-class (either at the top-level or as an argument to a functional pseudo-class), prepend :scope followed by the white space form of the descendant combinator.
</li>
			<li>
~RET ~S
（すでに絶対的である。）
◎
Otherwise, the selector is already absolute.
</li>
		</ol>
	</li>
</ol>

<p class="trans-note">【
実際には、上に述べた様に`絶対化$は，従来の選択子も受容する
— 既定の `~scope_ps要素$（文書の根~要素）の下では，実質的に恒等変換として働く。
】</p>


<p>
【選択子~listとしての】
`相対~選択子の~listを絶対化@
するときは、~list内の各 `相対~選択子$を絶対化する。

◎
To absolutize a relative selector list, absolutize each relative selector in the list.
</p>

			</section>
		</section>
		<section id="pseudo-classes">
<h3 title="Pseudo-classes">3.5. 疑似類</h3>

<p>
`疑似類@
は、文書~木の外側にある情報に基づく選択を, あるいは
他の`単体~選択子$を用いて表すには不便または不可能な選択を可能にするような，`単体~選択子$である。
疑似類は、文書~自身は変化しなくとも，［
利用者が文書とやりとりする間に，要素は疑似類を獲得したり, 失ったりし得る
］点で動的でもある。
`疑似類$は、［
文書~source／文書~木に現れたり，それを改変する
］ことはない。
◎
Pseudo-classes are simple selectors that permit selection based on information that lies outside of the document tree or that can be awkward or impossible to express using the other simple selectors. They can also be dynamic, in the sense that an element can acquire or lose a pseudo-class while a user interacts with the document, without the document itself changing. Pseudo-classes do not appear in or modify the document source or document tree.
</p>

<div class="p">
<p>
`疑似類$の構文は，次の並びで与えられる：
</p>

<ol>
	<li>
~colon（ `003A^U ）
</li>
	<li>
`識別子$である，`疑似類$の名前
</li>
	<li>
`関数形~疑似類@
である場合は：
丸括弧で括られた 0 個以上の引数
</li>
</ol>

◎
The syntax of a pseudo-class consists of a ":" (U+003A COLON) followed by the name of the pseudo-class as a CSS identifier, and, in the case of a functional pseudo-class, a pair of parentheses containing its arguments.
</div>

<p class="example">
例えば、
`valid$ps は普通の疑似類であり,
`lang()$ps は`関数形~疑似類$である。
<span class="trans-note">【
`drop$ps, `drop()$ps
のように、同じ名前に対し，関数形とそうでない 2 種類がある場合もある。
】</span>

◎
For example, :valid is a regular pseudo-class, and :lang() is a functional pseudo-class.
</p>

<p>
すべての~CSS~keywordと同様に、`疑似類$の名前は `~ASCII大小無視$である。
~colonと`疑似類$の名前の間には，`空白$は許容されない。
また，通例の~CSS構文と同様、関数の名前と後続の開き括弧の間にも`空白$は許容されない（しがたって， ~CSS `function-token$t を形成する）。
通例の~CSS構文と同様、他から指定されない限り，関数形~疑似類の各~引数の周囲には，`空白$は許容される。
◎
Like all CSS keywords, pseudo-class names are ASCII case-insensitive. No white space is allowed between the colon and the name of the pseudo-class, nor, as usual for CSS syntax, between a functional pseudo-class’s name and its opening parenthesis (which thus form a CSS function token). Also as usual, white space is allowed around the arguments inside the parentheses of a functional pseudo-class unless otherwise specified.
</p>

<p>
`疑似類$は、他の`単体~選択子$と同様に，選択子に包含されるすべての`合体~選択子$において許容されるが、`型~選択子$, または`全称~選択子$（もし在れば）に後続し~MUST。
◎
Like other simple selectors, pseudo-classes are allowed in all compound selectors contained in a selector, and must follow the type selector or universal selector, if present.
</p>

<p class="note">注記：
`疑似類$には、互いに排他的になるものもある（それらを包含している`合体~選択子$は 妥当であるが，何にも合致しないことになる）。
他のものは，同じ要素に同時に適用し得る。
◎
Note: Some pseudo-classes are mutually exclusive (such that a compound selector containing them, while valid, will never match anything), while others can apply simultaneously to the same element.
</p>

		</section>


		<section id="pseudo-elements">
<h3 title="Pseudo-elements">3.6. 疑似要素</h3>

<p>
ある種の`疑似類$が，文書~木に直接的に現れない追加の状態~情報を表現するのと同様に、
`疑似要素@
は，文書~木に直接的に現れないような <em>要素</em> を表現する。
それらは、文書~言語が提供するものを超えるような，文書~木についての抽象化を創出するために利用される。
例えば、疑似要素を，文書~言語の要素に対応しないような文書の部位（要素~境界と揃わない範囲や，その木~構造の中に収まらないものも含め）を選択するために利用できる
— 例えば、［
文書~木に含まれない内容や，
文書~木を別形へ投影した内容
］を表現したり、あるいは，［
~style付け ／ ~layout ／ 利用者とのやりとり ／ その他，文書~木に反映されないような処理
］により提供される情報に依拠する。
◎
Similar to how certain pseudo-classes represent additional state information not directly present in the document tree, a pseudo-element represents an element not directly present in the document tree. They are used to create abstractions about the document tree beyond those provided by the document tree. For example, pseudo-elements can be used to select portions of the document that do not correspond to a document-language element (including such ranges as don’t align to element boundaries or fit within its tree structure); that represent content not in the document tree or in an alternate projection of the document tree; or that rely on information provided by styling, layout, user interaction, and other processes that are not reflected in the document tree.
</p>

<p class="trans-note">【
“疑似要素” という語は、この種の抽象的な要素をそのまま指すこともあれば，そのような要素を選択する選択子を指すこともある。
後者は、実際には， “疑似要素~選択子” の略称と考えられる。
】</p>


<div class="example">
<p>
例えば、文書~言語は，要素~内容の 初行の初字に~accessする仕組みを提供0しないが、それらにも~styleをあてがえるようにする`疑似要素$はある（
`first-letter$pe, `first-line$pe
）。
とりわけ， `first-line$pe の事例では、疑似要素が内容のどの部位を表現するかは，文書~木からは推定できない~layout情報に依存することに注意。
◎
For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content, but there exist pseudo-elements (::first-letter and ::first-line) that allow those things to be styled. Notice especially that in the case of ::first-line, which portion of content is represented by the pseudo-element depends on layout information that cannot be inferred from the document tree.
</p>

<p>
`疑似要素$は、任意の要素の前後に追加の内容を挿入する `before$pe, `after$pe 疑似要素など，文書に元から存在しないような内容も表現し得る。
◎
Pseudo-elements can also represent content that doesn’t exist in the source document at all, such as the ::before and ::after pseudo-elements which allow additional content to be inserted before or after the contents of any element.
</p>

</div>


<p>
`疑似類$と同様、`疑似要素$も，［
文書~source／文書~木
］内には現れず，それを改変することもない。
したがって疑似要素は、`構造上の疑似類$の解釈にも，［
疑似要素の［
`出自の要素$, または その木
］に該当するような，他の選択子
］の解釈にも影響しない。
◎
Like pseudo-classes pseudo-elements do not appear in or modify the document source or document tree. Accordingly, they also do not affect the interpretation of structural pseudo-classes or other selectors pertaining to their originating element or its tree.
</p>

<p>
［
どの疑似要素が存在し, その型は何で, どのような能を備えるか
］は、~host言語が定義する。
~CSSに存在する疑似要素は、［
`CSS21$r （ Level 2 ）,
`SELECT$r （ Level 3 ）,
`CSS-PSEUDO-4$r （ Level 4 ）
］にて定義される。
◎
The host language defines which pseudo-elements exist, their type, and their abilities. Pseudo-elements that exist in CSS are defined in [CSS21] (Level 2), [SELECT] (Level 3), and [CSS-PSEUDO-4] (Level 4).
</p>

			<section id="pseudo-element_syntax">
<h4 title="Syntax">3.6.1. 構文</h4>

<p>
`疑似要素$の構文は，［
"`::^css" （ 2 個の `003A^U 並び）,
［
`識別子$である，`疑似要素$の名前
］］並びで与えられる。
`疑似要素$の名前は， `~ASCII大小無視$である。
2 個の~colonの間や, ~colonと`疑似要素$の名前の間には，`空白$は許容されない。
◎
The syntax of a pseudo-element is "::" (two U+003A COLON characters) followed by the name of the pseudo-element as an identifier. Pseudo-element names are ASCII case-insensitive. No white space is allowed between the two colons, or between the colons and the name.
</p>


<p>
<a href="~TR/CSS1">CSS Level 1</a> ／
<a href="~CSS2" >CSS Level 2</a>
では、疑似要素と疑似類は，ともに 単独の~colonによる構文で一緒くたにされていたので、~UAは，以前の Level 1 ／ 2 疑似要素（
`before$pe,
`after$pe,
`first-line$pe,
`first-letter$pe
）に対しては，~colon 1 個による記法も受容し~MUST。
この，互換性のための記法は、他の疑似要素には許容されない。
この構文は非推奨にされたので、作者は，これらの疑似要素にも Level 3 以上の二重~colon構文を利用するべきである。
◎
Because CSS Level 1 and CSS Level 2 conflated pseudo-elements and pseudo-classes by sharing a single-colon syntax for both, user agents must also accept the previous one-colon notation for the Level 1 &amp; 2 pseudo-elements (::before, ::after, ::first-line, and ::first-letter). This compatibility notation is not allowed any other pseudo-elements. However, as this syntax is deprecated, authors should use the Level 3+ double-colon syntax for these pseudo-elements.
</p>

<p>
`疑似要素$は `無特能$であり、他のどの選択子にも合致し得ない。
◎
Pseudo-elements are featureless, and so can’t be matched by any other selector.
</p>

			</section>
			<section id="pseudo-element-attachment">
<h4 title="Binding to the Document Tree">3.6.2. 文書~木への束縛-法</h4>

<p>
`疑似要素$は，木~内に独立して存在することはない
— それは常に、その
`出自の要素@
と呼ばれる，頁~上の別の要素に束縛される。
構文的には、`疑似要素$は，その`出自の要素$を表現している`合体~選択子$の直後に続く。
この`合体~選択子$が省略された場合、それは，`全称~選択子$ `*^S であるものと見做される。
◎
Pseudo-elements do not exist independently in the tree: they are always bound to another element on the page, called their originating element. Syntactically, a pseudo-element immediately follows the compound selector representing its originating element. If this compound selector is omitted, it is assumed to be the universal selector *.
</p>

<div class="example">
<p>
例えば、選択子 `div a::before^S において，頭部の選択子に合致する `a^e 要素は、~~付随する `before$pe 疑似要素に対する`出自の要素$になる。
◎
For example, in the selector div a::before, the a elements matched by the selector are the originating elements for the ::before pseudo-elements attached to them.
</p>

<p>
選択子 `::first-line^S は，`*::first-line^S に等価であり、文書~内の各 要素<em>ごとに</em>，その `first-line$pe 疑似要素を選択する。
◎
The selector ::first-line is equivalent to *::first-line, which selects the ::first-line pseudo-element on every element in the document.
</p>
</div>


<p>
`疑似要素$ ~S を含んでいる選択子においては、選択子の中の
~S より前の部分が， ~S に対する`出自の要素$を選択し、
~S より後の部分があるならば，それは ~S 自身に適用される（次節を見よ）。
◎
When a pseudo-element is encountered in a selector, the part of the selector before the pseudo-element selects the originating element for the pseudo-element; the part of the selector after it, if any, applies to the pseudo-element itself. (See below.)
</p>


			</section>
			<section id="pseudo-element-states">
<h4 title="Pseudo-classing Pseudo-elements">3.6.3. 疑似要素に対する疑似類による絞り込み</h4>

<p>
`疑似要素$には、その直後に
`利用者~動作 疑似類§の任意の組合せが続いていてもよい
— その事例では、`疑似要素$は，それらの疑似類に対応する状態にあるときにのみ，表現される。
これらの疑似類が その`疑似要素$上でも合致し得るかどうかは、当の
`疑似類$と`疑似要素$
の定義に依存する
— 他から指定されない限り，これらの`疑似類$は，`疑似要素$上で合致することはない。
◎
A pseudo-element may be immediately followed by any combination of the user action pseudo-classes, in which case the pseudo-element is represented only when it is in the corresponding state. Whether these pseudo-classes can match on the pseudo-element depends on the pseudo-class and pseudo-element”s definitions: unless otherwise-specified, none of these pseudo-classes will match on the pseudo-element.
</p>


<p class="issue">
上に示した疑似類を包含しているときも
`not()$ps, `matches()$ps
を利用できるのかどうか，明確化する。
◎
Clarify that :not() and :matches() can be used when containing above-mentioned pseudos.
</p>

<div class="example">
<p>
例えば、 `hover$ps 疑似類は，どの`疑似要素$にも適用し得るものと指定されているので、
`::first-line:hover^S
は，初行~上に~hoverされたときに合致することになる。
一方で、
`focus$ps, `first-line$pe
のいずれも［
`first-line$pe に `focus$ps を適用し得る
］ものと定義されてはいないので、選択子 `::first-line:focus^S に合致するものは，決してないことになる。
◎
For example, since the :hover pseudo-class specifies that it can apply to any pseudo-element, ::first-line:hover will match when the first line is hovered. However, since neither :focus nor ::first-line define that :focus can apply to ::first-line, the selector ::first-line:focus will never match anything.
</p>

<p class="issue">
`::first-line:not(:focus)^S
は，何にでも合致するのか？
◎
Does ::first-line:not(:focus) match anything?
</p>

<p>
`::first-line:hover^S と `:hover::first-line^S とは、かなり異なることに注意。
後者は、~hoverされた どの`出自の要素$に対しても，その初行に合致する。
例えば,
`:hover::first-line^S
は，段落の二行目に~hoverされたときでも，段落の初行に合致する一方で、
`::first-line:hover^S
は，初行~自身に~hoverされたときにのみ合致する。
◎
Notice that ::first-line:hover is is very different from :hover::first-line, which matches the first line of any originating element that is hovered! For example, :hover::first-line also matches the first line of a paragraph when the second line of the paragraph is hovered, whereas ::first-line:hover only matches if the first line itself is hovered.
</p>
</div>

<p class="note">注記：
将来の仕様から指定されない限り，
`利用者~動作 疑似類§
以外の疑似類は、疑似要素と~~複合されたときには，有効でなくなるので、例えば
`::before:first-child^S
は，`無効な選択子$になる。
◎
Note: Note that, unless otherwise specified in a future specification, pseudo-classes other than the user action pseudo-classes are not valid when compounded to a pseudo-element; so, for example, ::before:first-child is an invalid selector.
</p>


			</section>
			<section id="pseudo-element-structure">
<h4 title="Internal Structure">3.6.4. 内部~構造</h4>

<p>
一部の`疑似要素$は、内部~構造を持つものと定義されている。
その種の`疑似要素$には，その関係性を表すために［
`子~結合子$／`子孫~結合子$
］が後続していてもよい。
他の疑似要素については、`結合子$が後続するものは `無効な選択子$になる。
◎
Some pseudo-elements are defined to have internal structure. These pseudo-elements may be followed by child/descendant combinators to express those relationships. Selectors containing combinators after the pseudo-element are otherwise invalid.
</p>

<div class="example">
<p>
例えば、
`::first-letter + span^S,
`::first-letter em^S
は，いずれも無効な選択子になる。
しかしながら、 `shadow$pe は，内部~構造を持つものと定義されているため、
`::shadow &gt; p^S
は，選択子として有効になる。
◎
For example, ::first-letter + span and ::first-letter em are invalid selectors. However, since ::shadow is defined to have internal structure, ::shadow &gt; p is a valid selector.
</p>

</div>

<p class="note">注記：
既存の疑似要素の能力が，将来の仕様により拡張0されることもあるので、現在は無効でも（例 `::first-line :any-link^S ），未来には有効になるものは，あり得る。
◎
Note: A future specification may expand the capabilities of existing pseudo-elements, so some of these currently-invalid selectors (e.g. ::first-line :any-link) may become valid in the future.
</p>


<p>
そのような`疑似要素$の子たちは，同時に他の要素の子にもなり得る。
しかしながら、少なくとも~CSSにおける それらの具現化は，`~box木$の木~構造たる部分は保守される様に定義され~MUST。
◎
The children of such pseudo-elements can simultaneously be children of other elements, too. However, at least in CSS, their rendering must be defined so as to maintain the tree-ness of the box tree.
</p>

<div class="example">
<p>
例えば， `content$pe 疑似要素†は、そこへ distribute<!-- ＊ -->される要素をその一連の子として扱う。
<span class="trans-note">【†
`slotted$pe に改称された。
】</span>
すなわち、次の~code片が与えられたとするとき：
◎
For example, the ::content pseudo-element treats elements distributed to it as its children. This means that, given the following fragment:
</p>

<pre class="lang-ml">
&lt;div&gt;
  &lt;span&gt;foo&lt;/span&gt;
  &lt;"shadow root"&gt;
    &lt;content&gt;&lt;/content&gt;
  &lt;/"shadow root"&gt;
&lt;/div&gt;
</pre>

<p>
選択子 `div &gt; span^S と `div::shadow ::content &gt; span^S が、同じ要素を，異なる~pathを介して選択することを意味する。
◎
the selectors div &gt; span and div::shadow ::content &gt; span select the same element via different paths.
</p>

<p>
しかしながら、具現化-時には，`~box木$の木~構造が保守されるように、 `span^e 要素は， `div^e 要素ではなく `content^e 要素の子であったかの様に，~boxを生成する。
◎
However, when rendered, the &lt;span&gt; element generates boxes as if it were the child of the &lt;content&gt; element, rather than the &lt;div&gt; element, so the tree structure of the box tree is maintained.
</p>
</div>

			</section>
		</section>
		<section id="case-sensitive">
<h3 title="Characters and case sensitivity">3.7. 文字大小の区別</h3>

<p>
すべての Selectors 構文は、その制御~下にない次の部分を除いて，
~ASCII範囲の中で文字の大小は区別されない（すなわち， "a" 〜 "z" と "A" 〜 "Z" は対応する文字が同一視される）：
文書~言語の［
要素~名／属性~名／属性~値
］における文字大小の区別は，文書~言語に依存する。
◎
All Selectors syntax is case-insensitive within the ASCII range (i.e. [a-z] and [A-Z] are equivalent), except for the following parts, which are not under the control of Selectors: the case-sensitivity of document language element names, attribute names, and attribute values depends on the document language.
</p>

<div class="example">
<p>
例えば~HTMLの下では，要素~名と属性~名は
<a href="~HTMLselectors#case-sensitivity-of-selectors">~ASCII大小無視</a>
であるが、~XMLの下では，文字大小は区別される。
◎
For example, in HTML, element and attribute names are ASCII case-insensitive, but in XML, they are case-sensitive.
</p>
</div>

<p>
名前空間 接頭辞の文字大小の区別については `CSS3NAMESPACE$r にて定義される。
`言語範囲$の文字大小の区別は `lang()$ps 節にて定義される。
◎
Case sensitivity of namespace prefixes is defined in [CSS3NAMESPACE]. Case sensitivity of language ranges is defined in the :lang() section.
</p>

<div class="p">

<p>
Selectors における
`空白@
とは、次の符号位置のみからなる，（空でない）文字列である：
</p>

<ul ><li>`0020^U0 SPACE
</li><li>`0009^U0 TAB
</li><li>`000A^U0 LINE FEED 
</li><li>`000D^U0 CARRIAGE RETURN
</li><li>`000C^U0 FORM FEED
</li></ul>

<p>
空白に似た他の符号位置
— 例えば
`2003^U0 EM SPACE
や
`3000^U0 IDEOGRAPHIC SPACE
—
は，決して`空白$の一部にはならない。
</p>
◎
White space in Selectors consists of the code points SPACE (U+0020), TAB (U+0009), LINE FEED (U+000A), CARRIAGE RETURN (U+000D), and FORM FEED (U+000C) can occur in whitespace. Other space-like code points, such as EM SPACE (U+2003) and IDEOGRAPHIC SPACE (U+3000), are never part of white space.
</div>

<p>
Selectors における符号位置は、 CSS2 の`~escape処理規則$ `CSS21$r に則って，~backslash `005C^U により~escapeできる。
文字~escape処理は， Selectors の中でその文字が持ち得る特別な意味を “取り消す”ことに注意。
例えば，選択子
`#foo&gt;a^css
は`結合子$を包含しているが、
`#foo\&gt;a^css
は 代わりに~ID "`foo&gt;a^s" の要素を選択する。
◎
Code points in Selectors can be escaped with a backslash according to the same escaping rules as CSS. [CSS21] Note that escaping a code point "cancels out" any special meaning it may have in Selectors. For example, the selector #foo&gt;a contains a combinator, but #foo\&gt;a instead selects an element with the id foo&gt;a.
</p>

		</section>
		<section id="namespaces">
<h3 title="Declaring Namespace Prefixes">3.8. 名前空間 接頭辞の宣言-法</h3>

<p>
一部の選択子は，名前空間 接頭辞を~supportする。
名前空間 接頭辞を
`宣言-@
する仕組みは、 Selectors を利用する言語により指定されるべきである。
言語が名前空間 接頭辞の宣言の仕組みを指定しない場合、いかなる接頭辞も宣言されない。
~CSSにおいては、名前空間 接頭辞は
<a href="~CSSNS#declaration"><code class="css">@namespace</code></a>
規則 `CSS3NAMESPACE$r により宣言される。
◎
Certain selectors support namespace prefixes. The mechanism by which namespace prefixes are declared should be specified by the language that uses Selectors. If the language does not specify a namespace prefix declaration mechanism, then no prefixes are declared. In CSS, namespace prefixes are declared with the @namespacerule. [CSS3NAMESPACE]
</p><!-- ＊namespacerule -->

		</section>
		<section id="invalid">
<h3 title="Invalid Selectors and Error Handling">3.9. 無効な選択子と~errorの取扱い</h3>

<p>
次に挙げるものは
`無効な選択子@
（ “妥当でない” 選択子）とされる
— ~UA は、その取扱い規則に従わ~MUST：
◎
User agents must observe the rules for handling invalid selectors:
</p>

<ul>
	<li>
選択子において構文解析-~errorがある
— 例えば，認識されない~tokenや, 構文解析-時のある地点にて許容されない~tokenを含むもの。
◎
a parsing error in a selector, e.g. an unrecognized token or a token which is not allowed at the current parsing point, causes that selector to be invalid.
</li>
	<li>
`未宣言$の名前空間 接頭辞を包含している`単体~選択子$。
◎
a simple selector containing an undeclared namespace prefix is invalid
</li>
	<li>
無効な［
`単体~選択子$／`結合子$／~token
］を包含している選択子。
◎
a selector containing an invalid simple selector, an invalid combinator or an invalid token is invalid.
</li>
	<li>
無効な選択子を包含している`選択子~list$。
◎
a selector list containing an invalid selector is invalid.
</li>
	<li>
空の選択子
— すなわち，`合体~選択子$を包含しないもの。
◎
an empty selector, i.e. one that contains no compound selector, is invalid.
</li>
</ul>

<p>
`無効な選択子$は、空集合を表現するので，何にも合致しない。
◎
An invalid selector represents, and therefore matches, nothing.
</p>

		</section>
	</section>
	<section id="logical-combination">
<h2 title="Logical Combinations">4. 論理的な組合せ</h2>

		<section id="grouping">
<h3 title="Selector Lists">4.1. 選択子~list</h3>

<p>
~comma（ `002C^U ）で区切られた選択子の~list
— `選択子~list$ —
は、その中のそれぞれの`複体~選択子$により個別に選択された要素すべての和集合を表現する。
例えば~CSSにおいては、いくつかの選択子が同じ宣言を共有するときに，それらが~comma区切りの~listに~group化されてもよい。
~commaの前後には，`空白$が現れてもよい。
◎
A comma-separated list of selectors represents the union of all elements selected by each of the individual selectors in the selector list. (A comma is U+002C.) For example, in CSS when several selectors share the same declarations, they may be grouped into a comma-separated list. White space may appear before and/or after the comma.
</p>

<p class="trans-note">【
“選択子~list（ selector list ）” は， Selectors Level 3 までの “選択子の~group （ groups of selectors ）” に該当する（順序を含意する “~list” に改称されたのは、CSSOM などの仕様にて選択子の処理~model（直列化）を規定する際に，この名称の方が適切なためと見られる）。
】</p>

<div class="example">
<p>
宣言が互いに一致する 3 つの規則を一つにまとめることを~~考える：
◎
CSS example: In this example, we condense three rules with identical declarations into one. Thus,
</p>

<pre class="lang-css">
h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }
</pre>

<p>
これは、次と等価になる：
◎
is equivalent to:
</p>

<pre class="lang-css">
h1, h2, h3 { font-family: sans-serif }
</pre>

</div>

<p>
<strong>注意</strong>：
この例では，すべての選択子が妥当なので等価性が成り立つが、これらのうち一つでも無効なものがあった場合，`選択子~list$全体が無効になる。
後者の書き方の場合， 3 個の見出し要素すべてに対する規則が無効にされることになる一方、前者の書き方の場合，個別的に無効にされることになる。
◎
Warning: the equivalence is true in this example because all the selectors are valid selectors. If just one of these selectors were invalid, the entire selector list would be invalid. This would invalidate the rule for all three heading elements, whereas in the former case only one of the three individual heading rules would be invalidated.
</p>

<div class="example">
<p>
無効な~CSSの例：
◎
Invalid CSS example:
</p>

<pre class="lang-css">
h1 { font-family: sans-serif }
h2..foo { font-family: sans-serif }
h3 { font-family: sans-serif }
</pre>

<p>
は、次と等価ではない：
◎
is not equivalent to:
</p>

<pre class="lang-css">
h1, h2..foo, h3 { font-family: sans-serif }
</pre>

<p>
上の選択子（ `h1, h2..foo, h3^S ）は全体として無効であり，~style規則~全体が取り除かれるので。
（選択子が~group化されていなければ、 `h2..foo^css に対する規則のみが取り除かれる。）
◎
because the above selector (h1, h2..foo, h3) is entirely invalid and the entire style rule is dropped. (When the selectors are not grouped, only the rule for h2..foo is dropped.)
</p></div>

		</section>
		<section id="matches">
<h3 title="The Matches-any Pseudo-class: :matches()">4.2. 論理和 疑似類	`matches()^ps</h3>

<p>
論理和（ “matches-any” ） 疑似類
`matches()@ps
は、`選択子~list$を引数にとる`関数形~疑似類$である。
それは
その引数で表現される要素を表現する。
◎
The matches-any pseudo-class, :matches(), is a functional pseudo-class taking a selector list as its argument. It represents an element that is represented by its argument.
</p>

<p>
疑似要素は，論理和 疑似類では表現し得ない
— それらは `matches()$ps の中では妥当でない。
◎
Pseudo-elements cannot be represented by the matches-any pseudo-class; they are not valid within :matches().
</p>

<p>
既定の名前空間~宣言は、
`matches()$ps 疑似類【の引数】の中のどの選択子に対しても，その`選択対象$を表現している`合体~選択子$には，それが［
明示的に［
`全称~選択子$ ／ `型~選択子$
］を包含してる場合
］を除き，影響しない。
◎
Default namespace declarations do not affect the compound selector representing the subject of any selector within a :matches() pseudo-class, unless that compound selector contains an explicit universal selector or type selector.
</p>


<div class="example">
<p>
次の選択子は、名前空間を問わず，
~hover／~focus
された任意の要素に合致する。
したがって その照合は、既定の名前空間に属する要素のみに制限されない。
◎
For example, the following selector matches any element that is being hovered or focused, regardless of its namespace. In particular, it is not limited to only matching elements in the default namespace that are being hovered or focused.
</p>

<pre class="lang-css">
*|*:matches(:hover, :focus)
</pre>

<p>
一方で次の選択子は、~hover／~focusされた要素のうち，既定の名前空間に属するもののみを表現する【既定の名前空間は宣言-済みとする】。
`matches()$ps 記法の中で明示的に`全称~選択子$が用いられているので：
◎
The following selector, however, represents only hovered or focused elements that are in the default namespace, because it uses an explicit universal selector within the :matches() notation:
</p>

<pre class="lang-css">
*|*:matches(*:hover, *:focus)
</pre>

</div>

		</section>
		<section id="negation">
<h3 title="The Negation Pseudo-class: :not()">4.3. 否定~疑似類	`not()^ps</h3>

<p>
否定~疑似類
`not()@ps
は、`選択子~list$を引数にとる`関数形~疑似類$である。
それは，その引数で表現されない要素を表現する。
◎
The negation pseudo-class, :not(), is a functional pseudo-class taking a selector list as an argument. It represents an element that is not represented by its argument.
</p>

<p class="note">注記：
Selectors Level 3 においては、単独の`単体~選択子$のみが `not()$ps の引数に許容されていた。
◎
Note: In Selectors Level 3, only a single simple selector was allowed as the argument to :not().
</p>

<p>
`疑似要素$は否定~疑似類では表現し得ない
— それらは `not()$ps の中では妥当でない。
◎
Pseudo-elements cannot be represented by the negation pseudo-class; they are not valid within :not().
</p>

<div class="example">
<p>
次の選択子は、~HTML文書の中で不能化されていないすべての `button$e 要素に合致する。
◎
For example, the following selector matches all button elements in an HTML document that are not disabled.
</p>

<pre class="lang-css">
button:not([DISABLED])
</pre>

<p>
次の選択子は、 `FOO^e 要素~以外のすべてを表現する：
◎
The following selector represents all but FOO elements.
</p>

<pre class="lang-css">
*:not(FOO)
</pre>

<p>
次の`合体~選択子$は、
~link以外のすべての~HTML要素【 ~HTML名前空間に属する要素】を表現する。
◎
The following compound selector represents all HTML elements except links.
</p>

<pre class="lang-css">
html|*:not(:link):not(:visited)
</pre>

</div>

<p>
`matches()$ps に対するときと同様に，既定の名前空間~宣言は、
`not()$ps 疑似類の中のどの選択子に対しても，その`選択対象$を表現している`合体~選択子$には，それが明示的に［
`全称~選択子$ ／ `型~選択子$
］を包含している場合を除き，影響しない（ `matches()$ps の例を見よ）。
◎
As with :matches(), default namespace declarations do not affect the compound selector representing the subject of any selector within a :not() pseudo-class, unless that compound selector contains an explicit universal selector or type selector. (See :matches() for examples.)
</p>

<p class="note">注記：
`not()$ps 疑似類を用いれば “無用な” 選択子も記せる。
例えば `:not(*|*)^S は、どの要素も表現しない。
あるいは `div:not(span)^S は、`詳細度$がより高くなることを除いて， `div^S と等価になる。
◎
Note: The :not() pseudo-class allows useless selectors to be written. For instance :not(*|*), which represents no element at all, or div:not(span), which is equivalent to div but with a higher specificity.
</p>

		</section>
		<section id="relational">
<h3 title="The Relational Pseudo-class: :has()">4.4. 関係上の疑似類： `has()^ps</h3>

<p>
関係上の疑似類
`has()@ps
は、`相対~選択子$による`選択子~list$を引数にとる`関数形~疑似類$である。
それは、次を満たす 要素 ~E を表現する
⇒
選択子~listの中のいずれかの`相対~選択子$ ~S について、［
~E を`~scope_ps要素$とする下で， ~S を`絶対化$した上で評価したとき
］に，合致する要素がある。
◎
The relational pseudo-class, :has(), is a functional pseudo-class taking a relative selector list as an argument. It represents an element if any of the relative selectors, when absolutized and evaluated with the element as the :scope elements, would match at least one element.
</p>

<div class="example">
<p>
例えば，次の選択子は、 `img^e を子に持つ `a^e 要素のみに合致する：
◎
For example, the following selector matches only &lt;a&gt; elements that contain an &lt;img&gt; child:
</p>


<pre class="lang-css">
a:has(&gt; img)
</pre>

<p>
次の選択子は、別の `dt^e 要素が直後に続く `dt^e 要素に合致する：
◎
The following selector matches a &lt;dt&gt; element immediately followed by another &lt;dt&gt; element:
</p>

<pre class="lang-css">
dt:has(+ dt)
</pre>

<p>
次の選択子は、見出し要素を包含しない `section^e 要素に合致する：
◎
The following selector matches &lt;section&gt; elements that don’t contain any heading elements:
</p>

<pre class="lang-css">
section:not(:has(h1, h2, h3, h4, h5, h6))
</pre>

<p>
上の選択子における順序は重要であることに注意。
2 つの疑似類の入子を次の様に入れ替えた場合：
◎
Note that ordering matters in the above selector. Swapping the nesting of the two pseudo-classes, like:
</p>

<pre class="lang-css">
section:has(:not(h1, h2, h3, h4, h5, h6))
</pre>

<p>
見出し要素でない何らかの要素を包含するような，どの `section^e 要素にも合致することになる。
◎
...would result matching any &lt;section&gt; element which contains anything that’s not a header element.
</p>

</div>

		</section>
	</section>
	<section id="elemental-selectors">
<h2 title="Elemental selectors">5. 基本的な選択子</h2>

		<section id="type-selectors">
<h3 title="Type (tag name) selector">5.1. 型（~tag名）選択子</h3>

<p>
`型~選択子@
は、文書~言語の要素~型の名前であり，文書~木における その要素~型の~instanceを表現する。
◎
A type selector is the name of a document language element type, and represents an instance of that element type in the document tree.
</p>

<p class="example">
例えば 選択子 `h1^S は、文書~内の `h1^e 要素を表現する。
◎
For example, the selector h1 represents an h1 element in the document.
</p>

<p>
`型~選択子$は、`~CSS有修飾~名$
— 任意選択で名前空間 接頭辞も伴うような，`識別子$ —
として記される。
`CSS3NAMESPACE$r
（`基本的な選択子における名前空間§ 節を見よ。）
◎
A type selector is written as a CSS qualified name: an identifier with an optional namespace prefix. [CSS3NAMESPACE] (See §5.3 Namespaces in Elemental Selectors.)
</p>

		</section>
		<section id="the-universal-selector">
<h3 title="Universal selector">5.2. 全称~選択子</h3>

<p>
`全称~選択子@
は、特別な`型~選択子$であり，どの要素~型の要素も表現する。
◎
The universal selector is a special type selector, that represents an element of any element type.
</p>

<p>
それは、 局所~名として 1 個の~asterisk （ `002A^U ）を伴う`~CSS有修飾~名$として記される。
`型~選択子$と同様に，`全称~選択子$も、ある名前空間に属する要素のみに制約するように，名前空間で修飾でき、`基本的な選択子における名前空間§ 節にて定義されるように，既定の名前空間に影響される。
◎
It is written a CSS qualified name with an asterisk (* U+002A) as the local name. Like a type selector, the universal selector can be qualified by a namespace, restricting it to only elements belonging to that namespace, and is affected by a default namespace as defined in §5.3 Namespaces in Elemental Selectors.
</p>

<p>
選択子が`全称~選択子$を含んでいても，`無特能$の要素に合致するかどうかに効果を及ぼすことはない（`無特能$の要素は，`全称~選択子$も含め どの選択子にも合致しない）。
◎
Unless an element is featureless, the presence of a universal selector has no effect on whether the element matches the selector. (Featureless elements do not match any selector, including the universal selector.)
</p>

<p class="trans-note">【
`全称~選択子$を表す~wildcard `002A^U は、
（名前空間は脇に置くなら）
“ある要素~型 ~E に置き換えたとき合致するならば，合致する”
ことを表す。
】</p>

<div class="example">

<ul>
	<li>
`*[hreflang|=en]^S
と
`[hreflang|=en]^S
は等価。
◎
*[hreflang|=en] and [hreflang|=en] are equivalent,
</li>
	<li>
`*.warning^S
と
`.warning^S
は等価。
◎
*.warning and .warning are equivalent,
</li>
	<li>
`*#myid^S
と
`#myid^S
は等価。
◎
*#myid and #myid are equivalent.
</li></ul>

</div>

<p>
`全称~選択子$は，他の`型~選択子$と同じ構文~規則に従う：
`合体~選択子$においては、それは，高々 1 回まで, かつ最初の`単体~選択子$として現れ~MUST。
◎
The universal selector follows the same syntax rules as other type selectors: only one can appear per compound selector, and it must be the first simple selector in the compound selector.
</p>

<p class="note">注記：
照合の挙動には効果を持たなくとも、`全称~選択子$を追加すれば，選択子は読み易くなることがある。
例えば `div :first-child^S は `div:first-child^S に見誤り易い。
`div *:first-child^S の方が違いが明白になる。
◎
Note: In some cases, adding a universal selector can make a selector easier to read, even though it has no effect on the matching behavior. For example, div :first-child and div:first-child are somewhat difficult to tell apart at a quick glance, but writing the former as div *:first-child makes the difference obvious.
</p>



		</section>
		<section id="type-nmsp">
<h4 title="Namespaces in Elemental Selectors">5.3. 基本的な選択子における名前空間</h4>

<p>
［
`型~選択子$／`全称~選択子$
］には，任意選択で名前空間~成分も許容される。
すなわち，要素~名には、すでに`宣言-$済みの名前空間 接頭辞が，名前空間~区切子 `007C^U で区切られた上で 前置されてよい。
それは、各 形に応じて，次の意味を持つ：
◎
Type selectors and universal selectors allow an optional namespace component: a namespace prefix that has been previously declared may be prepended to the element name separated by the namespace separator “vertical bar” (| U+007C). (See, e.g., [XML-NAMES] for the use of namespaces in XML.) It has the following meaning in each form:
</p>


<dl>
	<dt><code class="css">%ns|~E</code></dt>
	<dd>
名前空間 %ns に属するような，名前 ~E の要素
◎
elements with name E in namespace ns
</dd>

	<dt>`*|~E^css</dt>
	<dd>
どの名前空間にも属さないものも含め, 任意の名前空間に属するような，名前 ~E の要素
◎
elements with name E in any namespace, including those without a namespace
</dd>

	<dt>`|~E^css</dt>
	<dd>
どの名前空間にも属さない，名前 ~E の要素
◎
elements with name E without a namespace
</dd>

	<dt>`~E^css</dt>
	<dd>
`既定の名前空間$が`宣言-$されていない場合、これは `*|~E^css に等価になる。
他の場合、%ns を既定の名前空間とするときの <code class="css">%ns|~E</code> に等価になる。
◎
if no default namespace has been declared for selectors, this is equivalent to *|E. Otherwise it is equivalent to ns|E where ns is the default namespace.
</dd>
</dl>

<div class="example">
<p>
次の~CSSにおいて：
◎
CSS examples:
</p>

<pre class="lang-css">
@namespace foo url(http://www.example.com);
foo|h1 { color: blue }  /* 規則 1 */
foo|* { color: yellow } /* 規則 2 */
|h1 { color: red }      /* 規則 3 */
*|h1 { color: green }   /* 規則 4 */
h1 { color: green }     /* 規則 5 */
</pre>

<p>
規則 1 は
名前空間 "<samp>http://www.example.com</samp>"
に属する `h1^e 要素のみに合致することになる。
◎
The first rule (not counting the @namespace at-rule) will match only h1 elements in the "http://www.example.com" namespace.
</p>

<p>
規則 2 は
名前空間 "<samp>http://www.example.com</samp>"
に属するすべての要素に合致することになる。
◎
The second rule will match all elements in the "http://www.example.com" namespace.
</p>

<p>
規則 3 は、どの名前空間にも属さない `h1^e 要素のみに合致することになる。
◎
The third rule will match only h1 elements with no namespace.
</p>

<p>
規則 4 は、（どの名前空間に属さないものも含む）任意の名前空間の
`h1^e 要素に合致することになる。
◎
The fourth rule will match h1 elements in any namespace (including those without any namespace).
</p>

<p>
規則 5 は、既定の名前空間が定義されていないので，規則 4 に等価になる。
◎
The last rule is equivalent to the fourth rule because no default namespace has been defined.
</p>

</div>


<p>
`型~選択子$を含まない`合体~選択子$は、`既定の名前空間$が宣言されている下では，依然として 既定の名前空間に属する要素のみに合致する。
◎
If a default namespace is declared, compound selectors without type selectors in them still only match elements in that default namespace.
</p>

<div class="example">
<p>
例えば，次の~stylesheetに対しては：
◎
For example, in the following style sheet:
</p>

<pre class="lang-css">
@namespace url("http://example.com/foo");
.special { ... }
</pre>

<p>
選択子 `.special^S は、（~DOMにおいては名前空間と対にされる）型~名への参照が現れていないが，名前空間 "`http://example.com/foo^s" に属する要素にのみ合致する。
◎
The .special selector only matches elements in the "http://example.com/foo" namespace, even though no reference to the type name (which is paired with the namespace in the DOM) appeared.
</p>

</div>

<p>
`未宣言$の名前空間 接頭辞を伴うような［
`型~選択子$／`全称~選択子$
］は、`無効な選択子$である。
◎
A type selector or universal selector containing a namespace prefix that has not been previously declared is an invalid selector.
</p>




		</section>
	</section>
	<section id="attribute-selectors">
<h2 title="Attribute selectors">6. 属性~選択子</h2>

<p>
Selectors では，要素の属性の表現も許容される。
選択子が要素に対し合致する式として用いられるとき、
`属性~選択子@
は、その要素がその属性~選択子で表現される属性に合致する属性を有するとき，その要素に合致するものと見なされ~MUST。
◎
Selectors allow the representation of an element’s attributes. When a selector is used as an expression to match against an element, an attribute selector must be considered to match an element if that element has an attribute that matches the attribute represented by the attribute selector.
</p>

<p class="issue">
<a href="https://lists.w3.org/Archives/Public/www-style/2011Mar/0215.html">複数個の値の照合</a>
のために~comma区切りの構文を追加するか？
例えば， `[rel ~=next, prev, up, first, last]^S
◎
Add comma-separated syntax for multiple-value matching? e.g. [rel ~= next, prev, up, first, last]
</p>

		<section id="attribute-representation">
<h3 title="Attribute presence and value selectors">6.1. 属性~存在0／属性~値 選択子</h3>

<p>
CSS2 では 4 種の`属性~選択子$が導入されている：
◎
CSS2 introduced four attribute selectors:
</p>

<dl>
	<dt><code class="css">[`att^a]</code></dt>
	<dd>
`att^a 属性【名前が "att" である属性】を有するような要素を表現する。
属性の値は問わない。
◎
Represents an element with the att attribute, whatever the value of the attribute.
</dd>

	<dt><code class="css">[`att^a=%val]</code></dt>
	<dd>
［
`att^a 属性を有していて,
その値は %val 【が表現する文字列】に一致する
］ような要素を表現する。
◎
Represents an element with the att attribute whose value is exactly "val".
</dd>

	<dt><code class="css">[`att^a~=%val]</code></dt>
	<dd>
［
`att^a 属性を有していて,
その値を`空白$で区切って得られる単語~listのいずれかの単語に %val が一致する
］ような要素を表現する。
%val に`空白$が含まれている場合、何も表現しないことになる（単語は`空白$で<em>区切られる</em>ので）。
%val が空~文字列の場合も，何も表現しないことになる。
◎
Represents an element with the att attribute whose value is a whitespace-separated list of words, one of which is exactly "val". If "val" contains whitespace, it will never represent anything (since the words are separated by spaces). Also if "val" is the empty string, it will never represent anything.
</dd>

	<dt><code class="css">[`att^a|=%val]</code></dt>
	<dd>
［
`att^a 属性を有していて,
その値は［
 %val に一致するか, または［
%val, `002D^U
］並びで始まる
］］ような要素を表現する。
これは主に BCP 47 （ `BCP47$r ） またはその後継版の言語~subcodeに合致させる用途が意図されている（例えば~HTMLの `a$e 要素の `hreflang^a 属性）。
`lang^a 属性（または `xml:lang^a 属性）に対する言語~subcode合致については `lang()$ps を見よ。
【~subcode — いわゆる下位tag（ subtag ）？あるいはそれに同等／代わるもの？】
◎
Represents an element with the att attribute, its value either being exactly "val" or beginning with "val" immediately followed by "-" (U+002D). This is primarily intended to allow language subcode matches (e.g., the hreflang attribute on the a element in HTML) as described in BCP 47 ([BCP47]) or its successor. For lang (or xml:lang) language subcode matching, please see the :lang pseudo-class.
</dd>
</dl>

<p>
属性~値に照合される %val は、
`ident-token$t または `string-token$t
として与えられ~MUST。
`CSS3SYN$r
<span class="trans-note">【
~CSS識別子（前者）の条件を満たさない~~一般の文字列は、引用符で括る（後者）必要がある。
】</span>
◎
Attribute values must be &lt;ident-token&gt;s or &lt;string-token&gt;s. [CSS3SYN]
</p>

<div class="example">
<p lang="en">Examples:</p>

<p>
次の`属性~選択子$は、
`title^a 属性を有する `h1^e 要素を表現する。
属性の値は問わない：
◎
The following attribute selector represents an h1 element that carries the title attribute, whatever its value:
</p>

<pre class="lang-css">
h1[`title^a]
</pre>

<p>
次の例の選択子は、 `class^a 属性の値が "`example^s" に一致する `span^e 要素を表現する：
◎
In the following example, the selector represents a span element whose class attribute has exactly the value "example":
</p>

<pre class="lang-css">
span[`class^a="example"]
</pre>

<p>
複数の`属性~選択子$を用いれば、要素の複数の属性, あるいは同じ属性に対する複数の条件を表現できる。
次の選択子は、
`hello^a 属性~値が "`Cleveland^s" に一致し, かつ
`goodbye^a 属性~値が "`Columbus^s" に一致するような，
`span^e 要素を表現する：
◎
Multiple attribute selectors can be used to represent several attributes of an element, or several conditions on the same attribute. Here, the selector represents a span element whose hello attribute has exactly the value "Cleveland" and whose goodbye attribute has exactly the value "Columbus":
</p>

<pre class="lang-css">
span[`hello^a="Cleveland"][`goodbye^a="Columbus"]
</pre>

<p>
次の~CSS規則は， "`=^css" と "`~=^css" の相違を示すものになる：
最初の選択子は、例えば `rel^a 属性の値が
"`copyright copyleft copyeditor^s"
である `a^e 要素にも合致することになる。
2 個目の選択子は、 `href^a 属性の値が
`http://www.w3.org/^s"
に一致する `a^e 要素のみに合致することになる。
◎
The following CSS rules illustrate the differences between "=" and "~=". The first selector would match, for example, an a element with the value "copyright copyleft copyeditor" on a rel attribute. The second selector would only match an a element with an href attribute having the exact value "http://www.w3.org/".
</p>

<pre class="lang-css">
a[`rel^a~="copyright"] { ... }
a[`href^a="http://www.w3.org/"] { ... }
</pre>

<p>
次の選択子は、
`hreflang^a 属性が "`fr^s" に一致する
`a^e 要素を表現する：
◎
The following selector represents an a element whose hreflang attribute is exactly "fr".
</p>

<pre class="lang-css">
a[`hreflang^a=fr]
</pre>

<p>
次の選択子は、
`hreflang^a 属性の値が "`en^s" から始まる `a^e 要素を表現する
— すなわち， "`en^s", "`en-US^s", "`en-scouse^s" なども含まれる：
◎
The following selector represents an a element for which the value of the hreflang attribute begins with "en", including "en", "en-US", and "en-scouse":
</p>

<pre class="lang-css">
a[`hreflang^a|="en"]
</pre>

<p>
次の 2 つの選択子は、
`character^a 属性がそれぞれ別の値をとる，
`DIALOGUE^e 要素を表現する
◎
The following selectors represent a DIALOGUE element whenever it has one of two different values for an attribute character:
</p>

<pre class="lang-css">
DIALOGUE[`character^a=romeo]
DIALOGUE[`character^a=juliet]
</pre>

</div>

		</section>
		<section id="attribute-substrings">
<h3 title="Substring matching attribute selectors">6.2. 部分照合 属性~選択子</h3>

<p>
属性~値の一部をなす文字列との照合のために，次の 3 種の`属性~選択子$が提供される：
◎
Three additional attribute selectors are provided for matching substrings in the value of an attribute:
</p>

<dl>
	<dt><code class="css">[`att^a^=%val]</code></dt>
	<dd>
［
`att^a 属性を有していて, その値は “接頭辞” %val から始まる
］ような要素を表現する。
%val が空~文字列である場合、この選択子は何も表現しない。
◎
Represents an element with the att attribute whose value begins with the prefix "val". If "val" is the empty string then the selector does not represent anything.
</dd>

	<dt><code class="css">[`att^a$=%val]</code></dt>
	<dd>
［
`att^a 属性を有していて,
その値は “接尾辞” %val で終端する
］ような要素を表現する。
%val が空~文字列である場合、この選択子は何も表現しない。
◎
Represents an element with the att attribute whose value ends with the suffix "val". If "val" is the empty string then the selector does not represent anything.
</dd>

	<dt><code class="css">[`att^a*=%val]</code></dt>
	<dd>
［
`att^a 属性を有していて,
その値は どこかに文字列 %val を包含している
］ような要素を表現する。
%val が空~文字列である場合、この選択子は何も表現しない。
◎
Represents an element with the att attribute whose value contains at least one instance of the substring "val". If "val" is the empty string then the selector does not represent anything.
</dd></dl>

<p>
属性~値に照合される %val は、
`ident-token$t または `string-token$t
として与えられ~MUST。
◎
Attribute values must be &lt;ident-token&gt;s or &lt;string-token&gt;s.
</p>

<div class="example">

<p>
次の選択子は、画像を参照している~HTML `object$e 要素を表現する：
◎
Examples: The following selector represents an HTML object element, referencing an image:
</p>

<pre class="lang-css">
object[`type^a^="image/"]
</pre>

<p>
次の選択子は、
`href^a 属性の値が "<samp>.html</samp>" で終端している
~HTML `a$e 要素を表現する：
◎
The following selector represents an HTML a element with an href attribute whose value ends with ".html".
</p>

<pre class="lang-css">
a[`href^a$=".html"]
</pre>

<p>
次の選択子は、［
`title^a 属性の値が部分文字列として "`hello^s" を包含する
］ような，~HTML `p^e 要素を表現する：
◎
The following selector represents an HTML paragraph with a title attribute whose value contains the substring "hello"
</p>

<pre class="lang-css">
p[`title^a*="hello"]
</pre>

</div>

		</section>
		<section id="attribute-case">
<h3 title="Case-sensitivity">6.3. 属性~値の文字大小の区別</h3>

<p>
既定では、選択子の中の 属性~名や属性~値 の文字大小が区別されるかどうかは，文書~言語に依存する。
文書~言語が定める~~規則に関わりなく，属性~値を大小無視で合致させるため、`属性~選択子$の閉じ角括弧 `005D^U の直前に，識別子 `0069^U を含ませる方法が用意されている。
この~flagが在るときは、~UAは，属性の値を `~ASCII大小無視$の下で合致させ~MUST。
他の Selectors 構文と同様、識別子 `0069^U 自身も `~ASCII大小無視$である。
◎
By default case-sensitivity of attribute names and values in selectors depends on the document language. To match attribute values case-insensitively regardless of document language rules, the attribute selector may include the identifier i before the closing bracket (]). When this flag is present, UAs must match the attribute’s value case-insensitively within the ASCII range. Like the rest of Selectors syntax, the i identifier is case-insensitive within the ASCII range.
</p>

<div class="example">
<p>
次の~CSS規則は、属性~値の文字大小が区別される~XML環境の下でも，
`frame^a 属性の値が
`hsides^s,
`HSIDES^s,
`hSides^s,
等々として表現される値 `hsides^s をとるとき，~style付けを与えることになる。
◎
The following rule will style the frame attribute when it has a value of hsides, whether that value is represented as hsides, HSIDES, hSides, etc. even in an XML environment where attribute values are case-sensitive.
</p>

<pre class="lang-css">
[`frame^a=hsides i] { border-style: solid none; }
</pre>
</div>

<p class="trans-note">【
"i" の存在は、構文上は，後方互換にならないと見られる（未~supportの場合，全体が無効にされる）。
】</p>


		</section>
		<section id="attrnmsp">
<h3 title="Attribute selectors and namespaces">6.4. 属性~選択子と名前空間</h3>

<p>
`属性~選択子$の中の属性~名は，`~CSS有修飾~名$として与えられる：
属性~名には、`宣言-$済みの名前空間 接頭辞が，名前空間~区切子 `007C^U で区切られた上で，前置されてもよい。
Namespaces in XML 勧告 `XML-NAMES$r の規定に倣い、`既定の名前空間$は，属性には適用されない。
したがって，名前空間~成分を伴わない`属性~選択子$は、どの名前空間にも属さない属性のみを対象にする（ <code class="css">|`attr^a</code> に等価）。
名前空間 接頭辞として、~asteriskが用いられてもよい。
これは、属性~名の名前空間を問わずに選択子を合致させることを指示する。
◎
The attribute name in an attribute selector is given as a CSS qualified name: a namespace prefix that has been previously declared may be prepended to the attribute name separated by the namespace separator "vertical bar" (|). In keeping with the Namespaces in the XML recommendation, default namespaces do not apply to attributes, therefore attribute selectors without a namespace component apply only to attributes that have no namespace (equivalent to |attr). An asterisk may be used for the namespace prefix indicating that the selector is to match all attribute names without regard to the attribute’s namespace.
</p>

<p>
属性~名に`未宣言$の名前空間 接頭辞を伴うような`属性~選択子$は、`無効な選択子$である。
◎
An attribute selector with an attribute name containing a namespace prefix that has not been previously declared is an invalid selector.
</p>

<div class="example">
<p>
次の~CSSにおいて：
◎
CSS examples:
</p>

<pre class="lang-css">
@namespace foo "http://www.example.com";
[foo|`att^a=val] { color: blue } /* 規則 1 */
[*|`att^a] { color: yellow }     /* 規則 2 */
[|`att^a] { color: green }       /* 規則 3 */
[`att^a] { color: green }        /* 規則 4 */
</pre>

<p>
規則 1 は、［
値  "`val^s" をとり, かつ
"`http://www.example.com^s"
名前空間に属する
］ `att^a 属性を有する要素のみに合致することになる。
◎
The first rule will match only elements with the attribute att in the "http://www.example.com" namespace with the value "val".
</p>

<p>
規則 2 は、（どの名前空間にも属さないものも含め）属性の名前空間を問わず， `att^a 属性を有する要素のみに合致することになる。
◎
The second rule will match only elements with the attribute att regardless of the namespace of the attribute (including no namespace).
</p>

<p>
規則 3,4 は等価であり，いずれも どの名前空間にも属さない
`att^a 属性を有する要素のみに合致することになる。
◎
The last two rules are equivalent and will match only elements with the attribute att where the attribute is not in a namespace.
</p></div>

		</section>
		<section id="def-values">
<h3 title="Default attribute values in DTDs">6.5. DTD 内で与えられる属性の既定~値</h3>

<p>
`属性~選択子$は、文書~木の中の属性~値を表現する。
文書~木がどのように構築されるかは、 Selectors の対象外である。
一部の文書~形式では， DTD その他の場所で属性の既定~値が定義されることもあるが、それらは，文書~木に現れない限り `属性~選択子$により選択されることはない。
選択子は、既定~値が文書~木に含まれるかどうかに関わりなく，働くように設計されるべきである。
◎
Attribute selectors represent attribute values in the document tree. How that document tree is constructed is outside the scope of Selectors. In some document formats default attribute values can be defined in a DTD or elsewhere, but these can only be selected by attribute selectors if they appear in the document tree. Selectors should be designed so that they work whether or not the default values are included in the document tree.
</p>

<p>
例えば、~XML~UAは， DTD の “外部~subset” を読取ってもよいとされているが、<em>要求されてはいない</em>。
一方で、文書の “内部~subset” の中で与えられる［
属性の既定~値
］については，その~~検索が<em>要求されている</em>。
（これらの~subsetの定義については，例えば `XML10$r を参照。）
DTD の外部~subsetにて定義される［
属性の既定~値
］が，文書~木の中に現れるかどうかは、~UAに依存する。
◎
For example, a XML UA may, but is not required to, read an “external subset” of the DTD, but is required to look for default attribute values in the document’s “internal subset”. (See, e.g., [XML10] for definitions of these subsets.) Depending on the UA, a default attribute value defined in the external subset of the DTD might or might not appear in the document tree.
</p>

<p>
~XML名前空間を認識する~UAは、その名前空間の知識を利用して，属性の既定~値が文書~内に在ったかのように扱ってもよいとされているが、要求されてはいない。
（例えば、 XHTML ~UAには，組込みの XHTML  DTD についての知識を利用することは要求されていない。
XML 1.0 名前空間の詳細は、例えば `XML-NAMES$r を参照。）
◎
A UA that recognizes an XML namespace may, but is not required to use its knowledge of that namespace to treat default attribute values as if they were present in the document. (For example, an XHTML UA is not required to use its built-in knowledge of the XHTML DTD. See, e.g., [XML-NAMES] for details on namespaces in XML 1.0.)
</p>

<p class="note">注記：
概して、実装は，外部~subsetを無視する。
これは、~XML仕様にて定義されている，妥当性を検証しない処理器の挙動に対応する。
◎
Note: Typically, implementations choose to ignore external subsets. This corresponds to the behavior of non-validating processors as defined by the XML specification.
</p>

<div class="example">

<p>
既定~値に "`decimal^s" をとる `radix^a 属性を有する `EXAMPLE^e 要素を考える。
 DTD 片が次の様になっているとして：
◎
Consider an element EXAMPLE with an attribute radix that has a default value of "decimal". The DTD fragment might be
</p>

<pre class="dtd-example">&lt;!ATTLIST EXAMPLE radix (decimal,octal) "decimal"&gt;
</pre>

<p>
~stylesheetに次の~CSS規則が与えられている場合：
◎
If the style sheet contains the rules
</p>

<pre class="lang-css">
EXAMPLE[`radix^a=decimal] { /* <span class="comment">…既定の~prop設定…</span> */ }
EXAMPLE[`radix^a=octal]   { /* <span class="comment">…他の設定…</span> */ }◎
EXAMPLE[radix=decimal] { /* ... default property settings ... */ }
EXAMPLE[radix=octal]   { /* ... other settings... */ }
</pre>

<p>
最初の規則は
`radix^a 属性が既定を通して設定されるような
— すなわち，明示的には設定されない
— 要素には合致しないかもしれない。
すべての場合に対応するためには、既定~値に対する`属性~選択子$を取り除く必要がある：
◎
the first rule might not match elements whose radix attribute is set by default, i.e. not set explicitly. To catch all cases, the attribute selector for the default value must be dropped:
</p>

<pre class="lang-css">
EXAMPLE                { /* <span class="comment">…既定の~prop設定…</span> */ }
EXAMPLE[`radix^a=octal]   { /* <span class="comment">…他の設定…</span> */ }◎
EXAMPLE                { /* ... default property settings ... */ }
EXAMPLE[radix=octal]   { /* ... other settings... */ }
</pre>

<p>
ここでは，選択子
<samp>EXAMPLE[`radix^a=octal]</samp>
は，`型~選択子$~~単独より`詳細度$が高いので、 2 個目の規則の~style宣言は，［
`radix^a 属性~値が "`octal^s"
］の要素も対象にする最初の規則を上書きすることになる。
既定の場合のみを対象にするような すべての~prop宣言は、非~既定の場合を対象にする~style規則で上書きできるように，配慮する必要がある。
◎
Here, because the selector ''EXAMPLE[radix=octal]'' is more specific than the type selector alone, the style declarations in the second rule will override those in the first for elements that have a radix attribute value of "octal". Care has to be taken that all property declarations that are to apply only to the default case are overridden in the non-default cases' style rules.
</p>

</div>

		</section>
		<section id="class-html">
<h3 title="Class selectors">6.6. ~class選択子</h3>

<p>
`~class選択子@
は［
“終止符” `002E^U, 識別子
］並びとして与えられる。
それは、識別子により識別される “~class” に <em>属する</em> 要素を表現する。
【下の例に見られる様に，要素は同時に複数の~classに属し得る。】
~classは文書~言語により定義される。
例えば `HTML5$r, `SVG11$r, `MATHML$r における~classへの所属は，
`class^a 属性により与えられる：
これらの言語では、local `class^a 属性に適用される
`~=^css 記法に等価になる（すなわち
<code class="css">[`class^a~=%identifier]</code>
）。
【 “local” — 名前空間の文脈で要素に局所的，の意味と見られる】
◎
The class selector is given as a full stop (. U+002E) immediately followed by an identifier. It represents an element belonging to the class identified by the identifier, as defined by the document language. For example, in [HTML5], [SVG11], and [MATHML] membership in a class is given by the class attribute: in these languages it is equivalent to the ~= notation applied to the local class attribute (i.e. [class~=identifier]).
</p>

<div class="example">
<p>
~CSS例をいくつか示す：
◎
CSS examples:
</p>

<p>
次の様にして、
<samp>`class^a~="pastoral"</samp>
を伴うすべての要素に，~style情報をあてがうことができる：
◎
We can assign style information to all elements with class~="pastoral" as follows:
</p>

<pre class="lang-css">
*.pastoral { color: green }  /* all elements with class~=pastoral */
</pre>

<p>
または単に
◎
or just
</p>

<pre class="lang-css">
.pastoral { color: green }  /* all elements with class~=pastoral */
</pre>

<p>
次のものは
<samp>`class^a~="pastoral"</samp>
を伴う `h1^e 要素にのみ~styleをあてがう：
◎
The following assigns style only to H1 elements with class~="pastoral":
</p>

<pre class="lang-css">
H1.pastoral { color: green }  /* H1 elements with class~=pastoral */
</pre>

<p>
これらの規則の下では、下の 1 個目の `h1^e 要素~instanceは，その~textは green にされない一方、 2 個目のものはそうなる：
◎
Given these rules, the first H1 instance below would not have green text, while the second would:
</p>

<pre class="lang-ml">
&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;
</pre>

<p>
次の規則は、
`class^a 属性に
`pastoral^s および `marine^s の両方を含む
`空白$区切りの値の~list
があてがわれているような，任意の `p^e 要素に合致する：
◎
The following rule matches any P element whose class attribute has been assigned a list of whitespace-separated values that includes both pastoral and marine:
</p>

<pre class="lang-css">
p.pastoral.marine { color: green }
</pre>

<p>
この規則は
<samp>`class^a="pastoral blue aqua marine"</samp>
に対しては合致するが、
<samp>`class^a="pastoral blue"</samp>
に対しては合致しない。
◎
This rule matches when class="pastoral blue aqua marine" but does not match for class="pastoral blue".
</p></div>

<p class="note">注記：
~CSSは “class” 属性に相当の力を与えているので、作者は，関連付けられた呈示様式をほとんど持たない要素（~HTMLの `div$e や `span$e 要素など）に基づいて自前の “文書~言語” を設計し, “class” 属性を通して~style情報あてがうことも可能であるが、この実践はできれば避けられるべきである。
文書~言語の構造的~要素は，広く認知-／受容されている意味を備えていることが多い一方で、作者定義の class はそうでないであろうから。
◎
Note: Because CSS gives considerable power to the "class" attribute, authors could conceivably design their own "document language" based on elements with almost no associated presentation (such as div and span in HTML) and assigning style information through the "class" attribute. Authors should avoid this practice since the structural elements of a document language often have recognized and accepted meanings and author-defined classes may not.
</p>

<p class="note">注記：
要素が複数の~class属性を有する場合
【文書~言語に複数種の［ ~classの意味論を備えるような属性］が規定されている下で？】
、それらの値は~classを照合検索する前に space で区切って連結され~MUST。
しかしながら、現時点では， working group はこのような状況があり得るものと考えていない。
したがって，この挙動は、この仕様においては参考であり，規範ではない。
◎
Note: If an element has multiple class attributes, their values must be concatenated with spaces between the values before searching for the class. As of this time the working group is not aware of any manner in which this situation can be reached, however, so this behavior is explicitly non-normative in this specification.
</p>


<p>
`過去互換~mode$の文書に対しては、~class名は，`~ASCII大小無視$で照合され~MUST
— 他所における`~class選択子$は，大小を区別する。
◎
When matching against a document which is in quirks mode, class names must be matched ASCII case-insensitively; class selectors are otherwise case-sensitive.
</p>

		</section>
		<section id="id-selectors">
<h3 title="ID selectors">6.7. ~ID選択子</h3>

<p>
文書~言語には，~ID型であるものとして宣言される属性を備えているものもある。
~ID型の属性は、それを有する要素の型に関わりなく，同じ文書の中で
— その文書が文書~言語に適合する限り —
複数のそれが同じ値をとり得ない点で、特別な~~地位にある。
文書~言語が何であれ、~ID型にされている属性は，要素を一意に識別する目的に利用できる。
~HTMLにおいては、すべての~ID型の属性は `id^c と命名されている。
~XML~appは~ID型の属性を異なるものに命名し得るが、同じ制約が適用される。
要素のどの属性が “~ID属性” であるとされるかは，文書~言語が定義する。
◎
Document languages may contain attributes that are declared to be of type ID. What makes attributes of type ID special is that no two such attributes can have the same value in a conformant document, regardless of the type of the elements that carry them; whatever the document language, an ID typed attribute can be used to uniquely identify its element. In HTML all ID attributes are named id; XML applications may name ID attributes differently, but the same restriction applies. Which attribute on an element is considered the “ID attribute“ is defined by the document language.
</p>

<p>
`~ID選択子@
は［
“番号記号” `0023^U,
~ID値
］並びで記される。
~ID値は `~CSS識別子$で~MUST。
 ~ID選択子は、その中の識別子に合致する~IDを持つ要素~instanceを表現する。
（非適合~文書においては，複数の要素が同じ~ID選択子に合致することが起こり得る。）
◎
An ID selector consists of a “number sign” (U+0023, #) immediately followed by the ID value, which must be a CSS identifier. An ID selector represents an element instance that has an identifier that matches the identifier in the ID selector. (It is possible in non-conforming documents for multiple elements to match a single ID selector.)
</p>

<div class="example">
<p>
次の~ID選択子は、~ID型の属性~値が "`chapter1^s" であるような， `h1^e 要素を表現する：
◎
Examples: The following ID selector represents an h1 element whose ID-typed attribute has the value "chapter1":
</p>

<pre class="lang-css">
h1#chapter1
</pre>

<p>
次の ~ID選択子は、~ID型の属性~値が "`chapter1^s" であるような，任意の要素を表現する：
◎
The following ID selector represents any element whose ID-typed attribute has the value "chapter1":
</p>

<pre class="lang-css">
#chapter1
</pre>

<p>
次の選択子は、~ID型の属性~値が "`z98y^s" であるような，任意の要素を表現する：
◎
The following selector represents any element whose ID-typed attribute has the value "z98y".
</p>

<pre class="lang-css">
*#z98y
</pre>

</div>

<p class="note">注記：
XML 1.0 `XML10$rにおいては、どの属性が要素の~IDを与えるかについての情報は， DTD もしくは~schemaに含められる。
~UAは~XMLを構文解析する際に，常に DTD を読取るとは限らないので、何が要素~IDを与えるのか知り得ない可能性がある（~UAは，名前空間~特有の知識を持ち得るので、その場合はどれが~ID属性なのか決定し得るが）。
~stylesheet作者は、~UAがその種の情報を取得しない可能性もあることが判っているか疑わしいときには、代わりに通常の`属性~選択子$を用いるべきである：
`#p371^S の代わりに <samp class="css">[`name^a=p371]</samp> 等々。
◎
Note: In XML 1.0 [XML10], the information about which attribute contains an element’s IDs is contained in a DTD or a schema. When parsing XML, UAs do not always read the DTD, and thus may not know what the ID of an element is (though a UA may have namespace-specific knowledge that allows it to determine which attribute is the ID attribute for that namespace). If a style sheet author knows or suspects that a UA may not know what the ID of an element is, he should use normal attribute selectors instead: ''[name=p371] instead of #p371''.
</p>

<p>
【文書~言語にて複数種の［~IDの意味論を備えるような属性］が規定されている下で，】
要素が複数の~ID属性を有する場合、~ID選択子の目的においては，それらすべてがその要素の~IDとして扱われ~MUST。
その種の状況は
xml:id,  DOM3 Core,  XML DTD, 名前空間~特有の知識の~~組み合わせにより生じ得る。
◎
If an element has multiple ID attributes, all of them must be treated as IDs for that element for the purposes of the ID selector. Such a situation could be reached using mixtures of xml:id, DOM3 Core, XML DTDs, and namespace-specific knowledge.
</p>


<p>
`過去互換~mode$の文書に対しては、~IDは，`~ASCII大小無視$で照合され~MUST
— 他所における`~ID選択子$は，大小を区別する。
◎
When matching against a document which is in quirks mode, IDs must be matched ASCII case-insensitively; ID selectors are otherwise case-sensitive.
</p>


		</section>
	</section>
	<section id="linguistic-pseudos">
<h2 title="Linguistic Pseudo-classes">7. 自然言語に関する疑似類</h2>

		<section id="the-dir-pseudo">
<h3 title="The Directionality Pseudo-class: :dir()">7.1. 方向性 疑似類	`dir()^ps</h3>

<p>
`dir()@ps
疑似類により，文書の自然言語
【の表記体系  — writing system 】
から決定される方向性に基づいて要素を表現するような選択子を記せるようになる。
例えば `HTML5$r では、［
`dir^a 属性, 周囲の~text, その他の要因
］の組合せ基づいて，
<a href="~HTMLselectors#selector-ltr">要素の方向性を決定する方法</a>
が定められている。
`dir()$ps 疑似類による選択-は、~style付け状態に基づかない  —
例えば，その照合に~CSS `direction$p ~propは影響しない。
◎
The :dir() pseudo-class allows the author to write selectors that represent an element based on its directionality as determined by the document language. For example, [HTML5] defines how to determine the directionality of an element, based on a combination of the dir attribute, the surrounding text, and other factors. The :dir() pseudo-class does not select based on stylistic states—for example, the CSS direction property does not affect whether it matches.
</p>

<p>
疑似類 `dir(ltr)$ps は、左横書き（ left-to-right ）の方向性 （ `ltr^s ）を備える要素を表現する。
疑似類 `dir(rtl)$ps は、右横書き（ right-to-left ）の方向性 （ `rtl^s ）を備える要素を表現する。
`dir()$ps がとる引数は、単独の識別子で~MUST。
他の場合、選択子は無効になる。
識別子と括弧の間に`空白$が挟まれていてもよい。
`ltr^s, `rtl^s 以外の値も無効ではないが、【現時点では】何にも合致しない。
（将来の~markup仕様が他の種類の方向性を定義した場合、対応する値が許容されるように， Selectors も拡張されるであろう。）
◎
The pseudo-class :dir(ltr) represents an element that has a directionality of left-to-right (ltr). The pseudo-class :dir(rtl) represents an element that has a directionality of right-to-left (rtl). The argument to :dir() must be a single identifier, otherwise the selector is invalid. White space is optionally allowed between the identifier and the parentheses. Values other than ltr and rtl are not invalid, but do not match anything. (If a future markup spec defines other directionalities, then Selectors may be extended to allow corresponding values.)
</p>

<p>
`:dir(C)^css と
<code class="css">[`dir^a=C]</code>
の相違は、後者が要素~上の与えられた属性に対してのみ，比較を遂行する一方で、
`:dir(C)^css
疑似類は，比較の際に ~UA が備える文書の意味論についての知識が利用される点にある。
例えば、~HTMLの要素の方向性は、
`dir^a 属性を有さない子にも，妥当な `dir^a 属性を有する先祖があれば，それらのうちの直近のものに備わる方向性を継承する。
別の例として、
<samp>[`dir^a=auto]</samp>
に合致する~HTMLの要素は、その内容から解決される方向性に依存して，
`dir(ltr)$ps
または
`dir(rtl)$ps
に合致することになる。
`HTML5$r
◎
The difference between :dir(C) and ''[dir=C]'' is that ''[dir=C]'' only performs a comparison against a given attribute on the element, while the :dir(C) pseudo-class uses the UAs knowledge of the document’s semantics to perform the comparison. For example, in HTML, the directionality of an element inherits so that a child without a dir attribute will have the same directionality as its closest ancestor with a valid dir attribute. As another example, in HTML, an element that matches ''[dir=auto]'' will match either :dir(ltr) or :dir(rtl) depending on the resolved directionality of the elements as determined by its contents. [HTML5]
</p>

		</section>
		<section id="the-lang-pseudo">
<h3 title="The Language Pseudo-class: :lang()">7.2. 自然言語 疑似類	`lang()^ps</h3>

<p>
文書~言語において，要素~内容の自然言語（人が話す言語）を決定する方法が指定されている場合、その自然言語に基づく要素を表現する選択子を記せるようになる。
`lang()@ps
疑似類は、その引数に挙げられた いずれかの自然言語に属する要素を表現する。
引数は 1 個以上の`言語範囲$からなる~comma区切りの~listで与えられる。
選択子が妥当になるためには、 `lang()$ps の中の各
`言語範囲@
が，妥当な ［
`ident$t または `string$t
］で~MUST（例えば ~asteriskを包含する言語範囲は、文字列として引用符で括られ~MUST）。
◎
If the document language specifies how the (human) content language of an element is determined, it is possible to write selectors that represent an element based on its language. The :lang() pseudo-class represents an element that is in one of the languages listed in its argument. It accepts a comma-separated list of one or more language ranges as its argument. Each language range in :lang() must be a valid CSS &lt;ident&gt; or &lt;string&gt;. (Language ranges containing asterisks, for example, must be quoted as strings.)
</p>

<p>
要素の
`自然言語@
は、文書~言語により定義される。
例えば~HTML `HTML401$r では，`自然言語$は［
`lang^a 属性,
`meta$e 要素からの情報,
場合によっては~protocol（例えば HTTP ~headerからの）
］の組合せから決定される。
~XML言語では、
<code class="attr">xml:lang</code>
属性を利用して，要素の言語~情報を指示できる。
◎
The language of an element is defined by the document language. For example, in HTML [HTML401], the language is determined by a combination of the lang attribute, information from meta elements, and possibly also the protocol (e.g. from HTTP headers). XML languages can use the xml:lang attribute to indicate language information for an element.
</p>

<p>
要素の`自然言語$は、（必要なら BCP 47 構文に正規化された上で）
`RFC4647$r 3.3.2 節
<cite>Matching of Language Tags</cite>
（“自然言語~tagの照合”）の
<i>extended filtering</i>
（ “拡張絞り込み” ）演算により与えられる
<i>language range</i>
（ “言語範囲” ）に合致するとき、`言語範囲$に合致するとされる。
<!-- 和訳 “言語~tagの照合”
http://ofmind.net/doc/rfc/ja/4647
 -->
照合は， `~ASCII大小無視$の下で遂行される。
この比較においては、`言語範囲$が妥当な自然言語~codeであるかどうか考慮する必要は無い。
◎
The element’s language matches a language range if the element’s language (normalized to BCP 47 syntax if necessary) matches the given language range in an extended filtering operation per [RFC4647] Matching of Language Tags (section 3.3.2). The matching is performed case-insensitively within the ASCII range. The language range does not need to be a valid language code to perform this comparison.
</p>

<p class="note">注記：
文書および~protocolにおいては， BCP 47 `BCP47$r またはその後継版の~codeを利用して、あるいは~XML `XML10$r に基づく文書においては， <code class="attr">xml:lang</code> 属性を通して、自然言語を指示することが推奨される。
<q><a href="http://www.w3.org/International/questions/qa-lang-2or3.html">FAQ:  2 文字または 3 文字の言語~code</a></q>
参照。
◎
Note: It is recommended that documents and protocols indicate language using codes from BCP 47 [BCP47] or its successor, and by means of xml:lang attributes in the case of XML-based documents [XML10]. See "FAQ: Two-letter or three-letter language codes."
</p>

<div class="example">

<p>
次のうち最初の 2 つの選択子は，それぞれ
ベルギー・フランス語, ドイツ語
で書かれた~HTML文書を表現し、その次の 2 つの選択子は，それぞれの自然言語に属する任意の要素の子である “引用文” `q$e 要素を表現する：
◎
Examples: The two following selectors represent an HTML document that is in Belgian French or German. The two next selectors represent q quotations in an arbitrary element in Belgian French or German.
</p>

<pre class="lang-css">
html:lang(fr-be)
html:lang(de)
:lang(fr-be) &gt; q
:lang(de) &gt; q
</pre>

</div>

<p class="note">
`:lang(C)^css
と
`|=^css
演算子との相違は、
`|=^css
演算子が要素~上に与えられた属性に対してのみ比較を遂行する一方、
`:lang(C)^css
疑似類は，比較を行う際に~UAが備える文書の意味論についての知識が利用される点にある。
◎
Note: One difference between :lang(C) and the ''|='' operator is that the ''|='' operator only performs a comparison against a given attribute on the element, while the :lang(C) pseudo-class uses the UAs knowledge of the document’s semantics to perform the comparison.
</p>

<div class="example">
<p>
次の~HTML例では、
<code class="css">[`lang^a|=fr]</code> には，（ `lang^a 属性を有する） `body$e のみが合致する一方で、
`:lang(fr)^css には `body$e と `p$e の両者が合致する（両者ともフランス語に属するものとされるので）。
`p$e は `lang^a 属性を有さないので， <code class="css">[`lang^a|=fr]</code> に合致しない。
◎
In this HTML example, only the BODY matches ''[lang|=fr]'' (because it has a LANG attribute) but both the BODY and the P match :lang(fr) (because both are in French). The P does not match the ''[lang|=fr]'' because it does not have a LANG attribute.
</p>

<pre class="lang-ml">
&lt;body lang=fr&gt;
  &lt;p&gt;Je suis français.&lt;/p&gt;
&lt;/body&gt;
</pre>

</div>


<div class="example">
<p>
`:lang(C)^css と
`|=^css
演算子のもう一つの相違は、
`:lang(C)^css が暗黙的に~wildcard照合を遂行する点にある。
◎
Another difference between :lang(C) and the ''|='' operator is that :lang(C) performs implicit wildcard matching.
</p>

<p>
例えば `:lang(de-DE)^S は、次のすべてに合致することになる：
"`de-DE^s",
"`de-DE-1996^s",
"`de-Latn-DE^s",
"`de-Latf-DE^s",
"`de-Latn-DE-1996^s"
。
一方で <samp class="css">[`lang^a|=de-DE]</samp> は、これらのうち
"`de-DE^s"
と
"`de-DE-1996^s"
のみに合致することになる。 
◎
For example, :lang(de-DE) will match all of de-DE, de-DE-1996, de-Latn-DE, de-Latf-DE, de-Latn-DE-1996, whereas of those ''[lang|=de-DE] will only match de-DE'' and de-DE-1996.
</p>

<p>
最初の下位tag（第一~自然言語）については~wildcardによる照合を遂行するためには、 1 個の~asteriskが用いられ~MUST：
例えば `*-CH^S は
"`de-CH^s",
"`it-CH^s",
"`fr-CH^s",
"`rm-CH^s"
のすべてに合致することになる。
◎
To perform wildcard matching on the first subtag (the primary language), an asterisk must be used: *-CH will match all of de-CH, it-CH, fr-CH, and rm-CH.
</p>
</div>

<p class="note">注記：
~wildcard自然言語~照合は， Level 4 にて新たに~~導入された。
◎
Note: Wildcard language matching is new in Level 4.
</p>

		</section>
	</section>
	<section id="location">
<h2 title="Location Pseudo-classes">8. 所在 疑似類</h2>

		<section id="the-any-link-pseudo">
<h3 title="The Hyperlink Pseudo-class: :any-link">8.1. ~hyperlink疑似類	`any-link^ps</h3>

<p>
`any-link@ps
疑似類は、~hyperlinkの~source~anchorとしてふるまう要素を表現する。
例えば `HTML5$r では、
`href^a 属性を有する任意の `a$e, `area$e, `link$e 要素が~hyperlinkであり，
`any-link$ps にも
<a href="~HTMLselectors#selector-link">合致する</a>
。
それは `link$ps または `visited$ps に合致する要素に合致する。
すなわち，
`:matches(:link, :visited)^css
と等価である。
◎
The :any-link pseudo-class represents an element that acts as the source anchor of a hyperlink. For example, in [HTML5], any a, area, or link elements with an href attribute are hyperlinks, and thus match :any-link. It matches an element if the element would match :link or :visited, equivalent to :matches(:link, :visited).
</p>

<p class="issue">
この疑似類にもっとよい名前は？
◎
Any better name suggestions for this pseudo?
</p>

		</section>
		<section id="link">
<h3 title="The Link History Pseudo-classes: :link and :visited">8.2. ~link履歴 疑似類	`link^ps, `visited^ps</h3>

<p>
~UA は、未訪問の
<a href="#the-any-link-pseudo">~hyperlink</a>
を訪問済みのそれと異なる表示にすることが多い。
Selectors は、それらを判別する疑似類
`link@ps
および
`visited@ps
を提供する：
◎
User agents commonly display unvisited hyperlinks differently from previously visited ones. Selectors provides the pseudo-classes :link and :visited to distinguish them:
</p>

<ul>
   <li>
`link$ps 疑似類は、未訪問の~linkを対象にする。
◎
The :link pseudo-class applies to links that have not yet been visited.
</li>
<li>
`visited$ps 疑似類は、利用者により訪問済み~linkを対象にする。
◎
The :visited pseudo-class applies once the link has been visited by the user.
</li></ul>

<p>
~UA は、一定期間が経過した訪問済み~linkを未訪問の `link$ps 状態に戻してもよい。
◎
After some amount of time, user agents may choose to return a visited link to the (unvisited) :link state.
</p>

<p>
2 つの状態は両立し得ない。
◎
The two states are mutually exclusive.
</p>

<div class="example">

<p>
次の選択子は、 `footnote^s ~classに属していて, かつ 既に訪問済みの~linkを表現する：
◎
The following selector represents links carrying class footnote and already visited:
</p>

<pre class="lang-css">
.footnote:visited
</pre>

</div>

<p>
~stylesheet作者が 利用者の同意なしに利用者が訪問済みの~siteを調べる目的に，
`link$ps ／ `visited$ps
疑似類を濫用することも可能なので、~UAは，~linkを 訪問済みか未訪問かに応じて異なるように具現化しつつ，利用者の~privacyを守るために、すべての~linkを未訪問の~linkとして扱うなど, 他の措置を実装してもよい。
◎
Since it is possible for style sheet authors to abuse the :link and :visited pseudo-classes to determine which sites a user has visited without the user’s consent, UAs may treat all links as unvisited links or implement other measures to preserve the user’s privacy while rendering visited and unvisited links differently.
</p>

<p class="trans-note">【
例えば 多くの~browserでは、 `visited^ps に指定し得る~styleは，~layoutも含め，他のどの状態にも影響しないもの（ほぼ色のみ）に限られている
（<a href="https://dev.mozilla.jp/2010/04/privacy-related-changes-coming-to-css-vistited/">~~参考</a>）。
】</p>

		</section>
		<section id="the-target-pseudo">
<h3 title="The Target Pseudo-class: :target">8.3. target 疑似類	`target^ps</h3>


<p>
文書~言語によっては、文書の URL は、文書~自身のみならず，
URL の`素片$を介して 文書の <em>中の</em> 特定の要素を指す。
この仕方で指される要素は、文書の~target要素とされる。
◎
In some document languages, the document’s URL can further point to specific elements within the document via the URL’s fragment. The elements pointed to in this way are the target elements of the document.
</p>

<div class="example">
<p>
~HTMLにおける素片は、頁~内で同じ~IDを有する要素を指す。
例えば URL
`https://example.com/index.html#section2^s
は、
`https://example.com/index.html^s
にある文書~内の
`id="section2"^s
の要素を指す。
◎
In HTML the fragment points to the element in the page with the same ID. The url https://example.com/index.html#section2, for example, points to the element with id="section2" in the document at https://example.com/index.html. 
</p>
</div>


<p>
`target@ps
疑似類は、文書の~target要素に合致する。
文書の URL が素片~識別子を伴わない場合、その文書に~target要素はない。
◎
The :target pseudo-class matches the document’s target elements. If the document’s URL has no fragment identifier, then the document has no target elements.
</p>

<div class="example">

<pre class="lang-css">
p.note:target
</pre>

<p>
この選択子は、参照元 URL から~target要素にされていて,
`note^s ~classに属するような， `p^e 要素を表現する：
◎
This selector represents a p element of class note that is the target element of the referring URL.
</p>
</div>


<div class="example">

<p>
次のものは、 `target$ps 疑似類を利用して
~target要素の色を red にし，その先頭に画像を配置する：
◎
CSS example: Here, the :target pseudo-class is used to make the target element red and place an image before it, if there is one:
</p>

<pre class="lang-css">
:target { color : red }
:target::before { content : url(target.png) }
</pre>

</div>

		</section>
		<section id="the-scope-pseudo">
<h3 title="The Reference Element Pseudo-class: :scope">8.4. 起点要素 疑似類	`scope^ps</h3>

<p>
ある種の文脈の下では、選択子は，明示的な
`~scope_ps要素@
の集合に対し、照合される。
これは、［
選択子を合致させる際の対象範囲
］の起点にされるような，要素の（空もとり得る）集合である。
例えば、 `DOM$r の `querySelector()$c の引数に指定されるものなど。
◎
In some contexts, selectors can be matched with an explicit set of :scope elements. This is is a (potentially empty) set of elements that provide a reference point for selectors to match against, such as that specified by the querySelector() call in [DOM].
</p>

<p>
`scope@ps
疑似類は、`~scope_ps要素$とされている任意の要素を表現する。
`~scope_ps要素$が明示的に指定されていないが，選択子が`視野付き$,
かつ その`視野根$は要素である場合、 `scope$ps は，`視野根$を表現する。
他の場合、それは，文書の根を表現する（ `root$ps に等価になる）。
この疑似類を文書の根~要素でない特定の要素に合致させることを意図する仕様は、`視野根$（`視野付き選択子$を利用している場合）, あるいは 
`~scope_ps要素$とされる集合を，明示的に定義し~MUST。
◎
The :scope pseudo-class represents any element that is a :scope element. If the :scope elements are not explicitly specified, but the selector is scoped and the scoping root is an element, then :scope represents the scoping root; otherwise, it represents the root of the document (equivalent to :root). Specifications intending for this pseudo-class to match specific elements rather than the document’s root element must define either a scoping root (if using scoped selectors) or an explicit set of :scope elements.
</p>


		</section>
	</section>
	<section id="useraction-pseudos">
<h2 title="User Action Pseudo-classes">9. 利用者~動作 疑似類</h2>

<p>
対話的~UAは、利用者による動作に対する反応として，具現化-法を変えることがある。
Selectors は、利用者による動作の対象にされている要素を選択するための，数種の疑似類を提供する。
（これらの疑似類は，非~対話的~UAにおいても妥当であるが、どの要素にも決して合致しない。）
◎
Interactive user agents sometimes change the rendering in response to user actions. Selectors provides several pseudo-classes for the selection of an element the user is acting on. (In non-interactive user agents, these pseudo-classes are valid, but never match any element.)
</p>

<p>
これらの疑似類は両立し得る。
要素はこれら複数の疑似類に同時に合致し得る。
◎
These pseudo-classes are not mutually exclusive. An element may match several pseudo-classes at the same time.
</p>

<div class="example">
<p lang="en">Examples:</p>

<pre class="lang-css">
a:link    /* <span class="comment">未訪問の~link</span> */
a:visited /* <span class="comment">訪問済み~link</span> */
a:hover   /* <span class="comment">利用者による~hover</span> */
a:active  /* <span class="comment">作動中の~link</span> */◎
a:link    /* unvisited links */
a:visited /* visited links */
a:hover   /* user hovers */
a:active  /* active links */
</pre>

<p>
動的~疑似類を組合せる用例：
◎
An example of combining dynamic pseudo-classes:
</p>

<pre class="lang-css">
a:focus
a:focus:hover
</pre>

<p>
2 個目の選択子は、疑似類 `focus^ps, `hover^ps の両者に合致するような
`a^e 要素に合致する。
◎
The last selector matches a elements that are in the pseudo-class :focus and in the pseudo-class :hover.
</p></div>

<p class="note">注記：
この節にて定義される一部の疑似類を適用するために必要になる，接触判定の詳細は、将来に定義されることになる。
◎
Note: The specifics of hit-testing, necessary to know when several of the pseudo-classes defined in this section apply, are not yet defined, but will be in the future.
</p>


		<section id="the-hover-pseudo">
<h3 title="The Pointer Hover Pseudo-class: :hover">9.1. ~pointer~hover 疑似類	`hover^ps</h3>

<p>
`hover@ps
疑似類は、利用者が~pointing装置で，要素を指していて、実際に作動化させる必要はない間に適用される。
例えば，視覚的~UAでは、~cursor（~mouse~pointer）が［
要素により生成された`~box$
］上を~hoverしたとき，この疑似類が適用されるであろう。
~hardware制限に因り~hover~~状態を検出できない対話的~UA（例えば~pen機器）は、この機能を~supportしなくとも，`適合性§には反しない。
◎
The :hover pseudo-class applies while the user designates an element with a pointing device, but does not necessarily activate it. For example, a visual user agent could apply this pseudo-class when the cursor (mouse pointer) hovers over a box generated by the element. Interactive user agents that cannot detect hovering due to hardware limitations (e.g., a pen device that does not detect hovering) are still conforming.
</p>

<p>
要素のいずれかの子孫が［
`平坦~木$（~text~nodeなどの非~要素~nodeも含む）内にあって，上の条件に合致する
］ならば、要素も `hover$ps に合致する。
◎
An element also matches :hover if one of its descendants in the flat tree (including non-element nodes, such as text nodes) matches the above conditions.
</p>

<p>
文書~言語は、要素が `hover$ps に合致し得る追加の仕方を定義してよい。
例えば `HTML5$r は、~labelが付与された~control要素は，その~labelを与えている `label$e 要素が~hoverされたとき， `hover$ps に合致するものと定義している（
<a href="~HTMLselectors#selector-hover">参照</a>
）。
◎
Document languages may define additional ways in which an element can match :hover. For example, [HTML5] defines a labeled control element as matching :hover when its label is hovered.
</p>

<p class="note">注記：
`hover$ps の状態は、要素の<!-- 子 -->子孫が~pointing装置で指されたときにも適用し得るので、~pointing装置の直下にない要素が `hover$ps の対象になることも起こり得る。
◎
Note: Since the ':hover' state can apply to an element because its child is designated by a pointing device, then it is possible for ':hover' to apply to an element that is not underneath the pointing device.
</p>

<p>
`hover$ps 疑似類は任意の`疑似要素$に適用できる。
◎
The :hover pseudo-class can apply to any pseudo-element.
</p>

		</section>
		<section id="the-active-pseudo">
<h3 title="The Activation Pseudo-class: :active">9.2. 作動化 疑似類	`active^ps</h3>

<p>
`active@ps
疑似類は、利用者により作動化された要素を対象にする。
例えば，利用者が~mouse~buttonを押してから離すまでの間。
複数の~mouse~buttonを備える~systemでは、第一~button／第一~作動化~button（概して， “左” ~mouse~button）, あるいはそれを~~代理するもののみが， `active$ps の対象になる。
◎
The :active pseudo-class applies while an element is being activated by the user. For example, between the times the user presses the mouse button and releases it. On systems with more than one mouse button, :active applies only to the primary or primary activation button (typically the "left" mouse button), and any aliases thereof.
</p>

<p>
`active$ps になれる要素には、文書~言語／実装 特有の制限-があり得る。
例えば `HTML5$r では、一連の
<a href="~HTMLselectors#selector-active">作動可能な要素</a>
を定義している。
◎
There may be document language or implementation specific limits on which elements can become :active. For example, [HTML5] defines a list of activatable elements.
</p>

<p>
要素のいずれかの子孫が［
`平坦~木$（~text~nodeなどの非~要素~nodeも含む）内にあって，上の条件に合致する
］ならば、要素も `active$ps に合致する。
◎
An element also matches :active if one of its descendants in the flat tree (including non-element nodes, such as text nodes) matches the above conditions.
</p>

<p>
文書~言語は、要素が `active$ps に合致し得る追加の仕方を定義してよい。
◎
Document languages may define additional ways in which an element can match :active.
</p>

<p class="note">注記：
要素は同時に
`visited$ps かつ `active$ps（あるいは
`link$ps かつ `active$ps
）になり得る。
◎
Note: An element can be both ':visited' and ':active' (or ':link' and ':active').
</p>

		</section>
		<section id="the-focus-pseudo">
<h3 title="The Input Focus Pseudo-class: :focus">9.3. 入力~focus疑似類	`focus^ps</h3>

<p>
`focus@ps
疑似類は、要素が~focusを得ている（［
~keyboard／~mouse ~event, その他の形
］による入力を受容する）間だけ，適用される。
◎
The :focus pseudo-class applies while an element has the focus (accepts keyboard or mouse events, or other forms of input).
</p>

<p>
~focusを獲得できる要素には，文書~言語／実装に特有の制限-があり得る。
例えば `HTML$r は，一連の
<a href="~HTMLinteraction#focusable-area">~focus可能域</a>
を定義している。
◎
There may be document language or implementation specific limits on which elements can acquire :focus. For example, [HTML] defines a list of focusable areas.
</p>

<p>
文書~言語は、要素が `focus$ps に合致し得る追加の仕方を定義してよい
— ただし、`focus$ps 疑似類は，要素の親に自動的に伝播しては~MUST_NOT（親への合致-が欲される場合は `focus-within$ps を見よ）。
他の仕組みに因り伝播される結果，親~要素に適用されることはあってもよいが、単に親であるだけでは，そうならないことに注意。
◎
Document languages may define additional ways in which an element can match :focus, except that the :focus pseudo class must not automatically propagate to the parent element (see :focus-within if matching on the parent is desired). Note: it may still apply to the parent element if made to propagate due to other mechanisms, but not merely due to being the parent.
</p>

		</section>
		<section id="the-focusring-pseudo">
<h3 title="The Input Focus-Ring Pseudo-class: :focus-ring">9.4.  入力~focus環 疑似類： `focus-ring^ps</h3>

<p>
`focus-ring@ps
疑似類は、要素が `focus$ps 疑似類に合致していて, なおかつ
~UAが，［
その~focusは要素~上に特別に指示されるべき
］と（概して， “~focus環” を介して）経験則を介して決定したものに適用される。
◎
The :focus-ring pseudo-class applies while an element matches the :focus pseudo-class, and the UA determines via heuristics that the focus should be specially indicated on the element (typically via a "focus ring").
</p>

<div class="example">

<p>
例えば，~UAは概して、~text要素~上に それらが~focusされ次第，その内容に~keyboard入力が影響する事が注目されるように ~focus指示子を表示する。
◎
For example, UAs typically display focus indicators on text elements whenever they’re focused, to draw attention to the fact that keyboard input will affect their contents.
</p>

<p>
他方，~UAは概して、~buttonに対しては，それが~keyboard対話により~focusされた（文書を~tab-keyで巡回するなど）ときに限り~focus指示子を表示する
—
そのような対話~後の~focusの移動-先は，常に直ぐに明白になるとは限らないので
, but not【？】
~buttonを~mouse~pointerで~clickするなどの より “明白な” 対話により~focusされたとき。
◎
On the other hand, they typically only display focus indicators on buttons when they were focused by a keyboard interaction (such as tabbing thru the document), because it’s not always immediately obvious where the focus will move after such an interaction, but not when they were focused by more "obvious" interactions, like clicking on the button with a mouse pointer.
</p>

</div>

<div class="advisement">

<p>
頁~作者は、~focusされた状態の要素に~styleをあてがうために
`focus$ps ／ `focus-ring$ps
を利用するかどうか決める際には、以下に挙げる指針に従うべきである：
◎
Page authors should follow these guidelines when deciding whether to use :focus or :focus-ring to style the focused state of an element:
</p>

<ul>
	<li>
要素が  “~nativeな” ~focus指示子の挙動（~text欄や~buttonなど）を備える場合は、 `focus-ring$ps を利用する。
◎
If the element has "native" focus indicator behavior (such as text fields or buttons), use :focus-ring.
</li>
	<li>
他の場合，要素が~text入力を模倣している, または
~keyboard対話を受取るよう<em>意図され</em>た何かである場合は、
`focus$ps を利用する。
◎
Otherwise, if the element is emulating a text input, or something else that is intended to receive keyboard interaction, use :focus.
</li>
	<li>
他の場合、 `focus-ring$ps を利用する。
◎
Otherwise, use :focus-ring.
</li>
</ul>

</div>

<p>
~UAが要素~上の~focusを［
特別に指示するかどうか ／ いつ特別に指示するか
］は、~UAに依存する。
~UAが 要素を `focus-ring$ps に合致させるかどうかは、個々の~UAのみならず, 自身が稼働している~OSや利用者~設定に応じて異なり得る。
◎
When UAs choose to specially indicate focus on an element, or whether they specially indicate focus at all, is UA-dependent. Different UAs, the same UA on different operating systems, or the same UA on the same OS, but with different user settings, can make different choices as to when an element matches :focus-ring.
</p>

<div class="example">

<p>
次の指針が、 `focus-ring$ps を “~nativeな” ~focus環の挙動を伴わない要素にいつ適用するかを選ぶ経験則として示唆される：
◎
The following guidelines are suggested heuristics for choosing when to apply :focus-ring to elements without "native" focus ring behavior:
</p>

<ul>
	<li>
要素が~keyboard対話を介して~focusを受取った場合、間接的なもの
— ~keyboardを用いて~buttonを押すことにより~dialogを誘発するなど —
も含め， `focus-ring$ps を適用する。
◎
If the element received focus via a keyboard interaction, including indirectly, such as triggering a dialog by pressing a button using the keyboard, apply :focus-ring.
</li>
	<li>
要素が~focusされている間に~keyboard~eventが生じた場合、~keyboard対話により~focusされていない場合でも `focus-ring$ps を適用する。
◎
If a keyboard event occurs while an element is focused, even if the element wasn’t focused by a keyboard interaction, apply :focus-ring.
</li>
</ul>

</div>

		</section>
		<section id="the-focus-within-pseudo">

<h3 title="The Generalized Input Focus Pseudo-class: :focus-within">9.5. 一般化 入力~focus疑似類	`focus-within^ps</h3>

<p>
`focus-within@ps
疑似類は、
`focus$ps 疑似類が適用される要素に適用される。
◎
The :focus-within pseudo-class applies to elements for which the :focus pseudo class applies.
</p>

<p>
要素のいずれかの子孫が［
`平坦~木$（~text~nodeなどの非~要素~nodeも含む）内にあって，
`focus$ps に合致するための条件に合致する
］ならば、要素も `focus-within$ps に合致する。
◎
An element also matches :focus-within if one of its descendants in the flat tree (including non-element nodes, such as text nodes) matches the conditions for matching :focus.
</p>

		</section>
		<section id="drag-pseudos">
<h3 title="The Drag-and-Drop Pseudo-class: :drop and :drop()">9.6. ~drag-and-drop疑似類	`drop^ps と `drop()^ps</h3>

<p>
<dfn id="drop-pseudo0">`drop^ps</dfn>
<!-- `drop@ps  -->
疑似類は、利用者が “~dropし得る” ~itemを “~dragしている” あるいは概念的な意味で “持ち運んでいる” 間にのみ適用され、文書~言語により “~drop先” として定義されているすべての要素に合致する。
<del>例えば~HTMLでは `dropzone^a 属性が指定された要素が “~drop先” であるものとされる。</del>
【この属性は、<a href="https://github.com/whatwg/html/issues/2331">除去された</a>】
◎
The :drop pseudo-class applies to all elements that are drop targets, as defined by the document language, while the user is “dragging” or otherwise conceptually carrying an item to be “dropped”. For example, in HTML the dropzone attribute specified that an element is a drop target.
</p>

<p>
`drop()@ps
<!-- 
<dfn id="drop0">`drop()^ps</dfn>
 -->
`関数形~疑似類$は ~drop0 と同じになるが、一部の~drop先を除外する追加の~filterも指定できる。
その構文は次で与えられる：
◎
The :drop() functional pseudo-class is identical to :drop, but allows additional filters to be specified that can exclude some drop targets. Its syntax is:
</p>

<pre class="prod">:drop( [ active || valid || invalid ]? )
</pre>

<p>
各~keywordの意味は：
◎
The keywords have the following meanings:
</p>

<dl>
	<dt id="valdef-drop-active">`active^v</dt>

	<dd>
~drag操作に対する現在の~drop先にのみ合致する。
すなわち，利用者がその場所で~dragを解放したならば，それがこの~drop先に~dropされることになる。
◎
The drop target is the current drop target for the drag operation. That is, if the user were to release the drag, it would be dropped onto this drop target.
</dd>

	<dt id="valdef-drop-valid">`valid^v</dt>
	<dd>
文書~言語にて，~drop先に対する “有効” ／ “無効” の概念が規定されている場合、これは，現在~dragされている~objに対し，有効な~drop先であるときのみ合致する。
他の場合、すべての~drop先に合致する。
◎
If the document language has a concept of “valid” and “invalid” drop targets, this only matches if the drop target is valid for the object currently being dragged. Otherwise, it matches all drop targets.
</dd>
	<dd>
<del>例えば，~HTMLの `dropzone^a 属性は、~drop先が，与えられた型の文字列や~fileのみを受容するように指定し得る。</del>
◎
For example, HTML’s dropzone attribute can specify that the drop target only accepts strings or files that are set to a given type.
</dd>

	<dt id="valdef-drop-invalid">`invalid^v</dt>
	<dd>
文書~言語にて，~drop先に対する “有効” ／ “無効” の概念が規定されている場合、これは，現在~dragされている~objに対し，無効な~drop先であるときのみ合致する。
他の場合、すべての~drop先に合致する。
◎
If the document language has a concept of “valid” and “invalid” drop targets, this only matches if the drop target is invalid for the object currently being dragged. Otherwise, it matches nothing.
</dd>

</dl>

<p>
引数に複数の~keywordを組合せることもできる。
この場合、合致する~drop先は，それらの~keywordによる~~条件をすべてを満たすことを意味する。
例えば 
`:drop(valid active)^S
は、現在の~drop先であって, <em>かつ</em> 有効なもののみに合致することになる。
◎
Multiple keywords can be combined in the argument, representing only drop targets that satisfy all of the keywords. For example, :drop(valid active) will match the active drop target if it’s valid, but not if it’s invalid.
</p>

<p>
引数に~keywordが一つも与えられなかった場合、
`drop()$ps は ~drop0 と同じ意味
— すなわち，どの~drop先にも合致することになる。
◎
If no keywords are given in the argument, :drop() has the same meaning as :drop—it matches every drop target.
</p>

<p class="issue">
<a href="http://forums.mozillazine.org/viewtopic.php?f=18&amp;t=2633249">このscenario</a>
を例にして示す。
◎
Turn this scenario into an example.
</p>


		</section>
	</section>
	<section id="time-pseudos">
<h2 title="Time-dimensional Pseudo-classes">10. 時系列 疑似類</h2>

<p>
この節の疑似類は、何らかの時間軸の下で，現在表示中の, あるいはその作動期間に基づいて，要素を分類する。
文書を発話として具現化するときや,
WebVTT を利用して~videoを表示する間に，字幕を描画するなどの用途がある。
◎
These pseudo-classes classify elements with respect to the currently-displayed or active position in some timeline, such as during speech rendering of a document, or during the display of a video using WebVTT to render subtitles.
</p>

<p>
~CSSはこの時間軸を定義しない。
それは~host言語が定義し~MUST。
これらの疑似類は、時間軸が定義されていない要素に合致しては~MUST_NOT。
◎
CSS does not define this timeline; the host language must do so. If there is no timeline defined for an element, these pseudo-classes must not match the element.
</p>

<p class="note">注記：
`current$ps 要素の先祖もまた `current$ps になるが、
`future$ps 要素の先祖も `future$ps になる必要はない。
与えられた要素は、少なくとも `current$ps, `past$ps, `future$ps のいずれかに合致する。
◎
Note: Ancestors of a :current element are also :current, but ancestors of a :past or :future element are not necessarily :past or :future as well. A given element matches at most one of :current, :past, or :future.
</p>


		<section id="the-current-pseudo">
<h3 title="The Current-element Pseudo-class: :current">10.1. 現在要素 疑似類	`current^ps</h3>

<p>
`current@ps
疑似類は、現在表示中の要素, またはその先祖の要素を表現する。
◎
The :current pseudo-class represents the element, or an ancestor of the element, that is currently being displayed.
</p>

<p>
`matches()$ps と同様に`合体~選択子$の~listを引数にとる，関数形の
<dfn id="selectordef-current">`current()^ps</dfn>
もある。
この場合、 ~E を `current$ps 要素とするとき， ~E が引数にも合致するならば ~E 自身を表現し、合致しない場合は［
~E の先祖であって, 引数に合致する要素のうち ~E に最も近い先祖
］を表現する（どれにも合致しない場合は何も表現しない）。
◎
Its alternate form :current(), like :matches(), takes a list of compound selectors as its argument: it represents the :current element that matches the argument or, if that does not match, the innermost ancestor of the :current element that does. (If neither the :current element nor its ancestors match the argument, then the selector does not represent anything.)
</p>

<p class="trans-note">【
`current$ps 要素  —
例えば `elem:current(…)^css
の様に記されているとき，“最も近い先祖” は `elem^css 型でもなければならないのか？
それとも `elem^css 型の `current^ps 要素の先祖のうち引数に合致するような “最も近い先祖” なのかどっち？
】</p>

<div class="example">
<p>
例えば 次の規則は、文書を発話として具現化するときに，読み上げられる段落, または~list~itemを強調することになる：
◎
For example, the following rule will highlight whichever paragraph or list item is being read aloud in a speech rendering of the document:
</p>

<pre class="lang-css">
:current(p, li, dt, dd) {
  background: yellow;
}
</pre>
</div>



		</section>
		<section id="the-past-pseudo">
<h3 title="The Past-element Pseudo-class: :past">10.2. 過去要素 疑似類	`past^ps</h3>

<p>
`past@ps
疑似類は、全体が `current$ps 要素より先に生じるものと定義されている，任意の要素を表現する。
例えば、 WebVTT 仕様は `past$ps 疑似類を
<a href="http://dev.w3.org/html5/webvtt/#the-past-and-future-pseudo-classes">media 要素の現在の再生位置に相対的</a>
なものとして定義する。
文書~言語に要素の時系列順が定義されていない場合、これは `current$ps 要素に先行するすべての同胞要素を表現する。
◎
The :past pseudo-class represents any element that is defined to occur entirely prior to a :current element. For example, the WebVTT spec defines the :past pseudo-class relative to the current playback position of a media element. If a time-based order of elements is not defined by the document language, then this represents any element that is a (possibly indirect) previous sibling of a :current element.
</p>

		</section>
		<section id="the-future-pseudo">
<h3 title="The Future-element Pseudo-class: :future">10.3. 未来要素 疑似類	`future^ps</h3>

<p>
`future@ps
疑似類は、全体が `current$ps 要素より後に生じるものと定義されている，任意の要素を表現する。
例えば、 WebVTT 仕様では `future$ps 疑似類を
<a href="http://dev.w3.org/html5/webvtt/#the-past-and-future-pseudo-classes">media 要素の現在の再生位置に相対的</a>
なものとして定義する。
文書~言語により要素の時系列順が定義されていない場合、これは `current$ps 要素に後続するすべての同胞要素を表現する。
◎
The :future pseudo-class represents any element that is defined to occur entirely after a :current element. For example, the WebVTT spec defines the :future pseudo-class relative to the current playback position of a media element. If a time-based order of elements is not defined by the document language, then this represents any element that is a (possibly indirect) next sibling of a :current element.
</p>

		</section>
	</section>
	<section id="resource-pseudos">
<h2 title="Resource State Pseudos">11. 資源~状態~疑似類</h2>

<p>
この節の疑似類は、特に画像／動画などの 読込まれた資源を表現する要素に適用され、作者が，それらを何らかの “状態” の~~質に基づいて選択できるようにする。
◎
The pseudo-classes in this section apply to elements that represent loaded resources, particularly images/videos, and allow authors to select them based on some quality of their "state".
</p>



		<section id="video-state">
<h3 title="Video/Audio Play State: the :playing and :paused pseudo-classes">11.1. 動画／音声 再生-状態： `playing^ps, `paused^ps 疑似類</h3>

<p>
`playing@ps 疑似類は、［
“再生-中”, “一時停止-中” になれるような，音声や動画の類の資源
］を表現していて，
“再生-中にある”
ような要素を表現する（これには、要素が明示的に再生されているときの他に、
“~buffer中”
にあるなど、利用者の意図によらない何らかの事由で一時的に停止されていて，その事由が解決された時点で自動的に再開する状態も含まれる。）
◎
The :playing pseudo-class represents an element representing an audio, video, or similar resource that is capable of being "played" or "paused", when that element is "playing". (This includes both when the element is explicitly playing, and when it’s temporarily stopped for some reason not connected to user intent, but will automatically resume when that reason is resolved, such as a "buffering" state.)
</p>

<p>
`paused@ps 疑似類は、同じ要素を表現するが，それが再生-中でないときに合致する（これには、明示的に
“一時停止された”
状態の他に，
“読込まれたが，まだ作動化されていない”
ことにより再生-中でない状態も含まれる）。
◎
The :paused pseudo-class represents the same elements, but instead match when the element is not "playing". (This includes both an explicit "paused" state, and other non-playing states like "loaded, hasn’t been activated yet", etc.)
</p>
		</section>
	</section>
	<section id="input-pseudos">
<h2 title="The Input Pseudo-classes">12. 入力 疑似類</h2>

<p>
この節の疑似類のほとんどは、~HTMLの `input$e 要素など，利用者からの入力をとる要素を対象にする。
◎
The pseudo-classes in this section mostly apply to elements that take user input, such as HTML’s input element.
</p>

		<section id="input-states">
<h3 title="Input Control States">12.1. 入力~controlの状態</h3>

			<section id="enableddisabled">
<h4 title="The :enabled and :disabled Pseudo-classes">12.1.1. 操作可否 疑似類	`enabled^ps, `disabled^ps</h4>

<p>
［
`enabled@ps
／
`disabled@ps
］疑似類は、［
可能化-／不能化-
］された~UI要素を表現する。
その種の要素は対応する 不能化／可能化 の状態も備える。
◎
The :enabled pseudo-class represents user interface elements that are in an enabled state; such elements have a corresponding disabled state.
◎
Conversely, the :disabled pseudo-class represents user interface elements that are in a disabled state; such elements have a corresponding enabled state.
</p>

<p>
何が~UI要素とされ，［
可能化／不能化
］の状態がどのように定まるのかは~host言語に依存する。
大概の文書では、ほとんどの要素は［
`enabled$ps ／ `disabled$ps
］の対象にならない。
例えば `HTML5$r では、対話的~要素のうち，不能化されていないものが `enabled^ps である（
<a href="~HTMLselectors#selector-enabled">参照</a>
）とされ，明示的に不能化されている要素が `disabled^ps である（
<a href="~HTMLselectors#selector-disabled">参照</a>
）とされている。
◎
What constitutes an enabled state, a disabled state, and a user interface element is host-language-dependent. In a typical document most elements will be neither :enabled nor :disabled. For example, [HTML5] defines non-disabled interactive elements to be :enabled, and any such elements that are explicitly disabled to be :disabled.
</p>

<p class="note">注記：
利用者が与えられた~UI要素とやりとりできるかどうかに影響する~CSS~propは、それが［
`enabled$ps ／ `disabled$ps
］に合致するかどうかに影響しない。
例えば， `display$p や `visibility$p ~propは、要素の［
可能化／不能化
］の状態に対し，効果を持たない。
◎
Note: CSS properties that might affect a user’s ability to interact with a given user interface element do not affect whether it matches :enabled or :disabled; e.g., the display and visibility properties have no effect on the enabled/disabled state of an element.
</p>

			</section>
			<section id="rw-pseudos">
<h4 title="The Mutability Pseudo-classes: :read-only and :read-write">12.1.2. 変更可否 疑似類	`read-only^ps, `read-write^ps</h4>

<p>
`read-write@ps
は、文書~言語により，利用者が内容を改めれるものと定義される要素に合致する。
他のものは
`read-only@ps
に合致する。
◎
An element matches :read-write if it is user-alterable, as defined by the document language. Otherwise, it is :read-only.
</p>

<div >
<p>
例えば `HTML5$r では、次のいずれかに該当する要素が `read-write^ps とされている（
<a href="~HTMLselectors#selector-read-only">参照</a>
）：
</p>

<ul><li>不能化されていない, かつ読専でない `input$e 要素
</li><li>`contenteditable^a 属性が true 状態にあるような，任意の要素
</li></ul>

◎
For example, in [HTML5] a non-disabled non-readonly &lt;input&gt; element is :read-write, as is any element with the contenteditable attribute set to the true state.
</div>

			</section>
			<section id="placeholder">
<h4 title="The Placeholder-shown Pseudo-class: :placeholder-shown">12.1.3. 仮入力例示 疑似類	`placeholder-shown^ps</h4>

<p>
入力~要素は、利用者~向けの~hintとして仮入力~textを例示することがある。
例えば `HTML5$r の `placeholder^a 属性。
`placeholder-shown@ps
疑似類は、そのような仮入力~textを例示している入力~要素に合致する。
◎
Input elements can sometimes show placeholder text as a hint to the user on what to type in. See, for example, the placeholder attribute in [HTML5]. The :placeholder-shown pseudo-class matches an input element that is showing such placeholder text.
</p>

			</section>
			<section id="the-default-pseudo">
<h4 title="The Default-option Pseudo-class: :default">12.1.4. 既定option 疑似類	`default^ps</h4>

<p>
`default@ps
疑似類は、一連の要素の中で既定の選択肢にされているような，~UI要素を対象にする。
複数のものが既定にされていてもよい。
概して，
~context~menu~item,
~button,
~select~list,
~select~menu
が対象になる。
◎
The :default pseudo-class applies to the one or more UI elements that are the default among a set of similar elements. Typically applies to context menu items, buttons and select lists/menus.
</p>

<p>
例えば、一連の~buttonの中の既定の提出-~buttonや,
~popup~menuの中の既定optionなど。
多数の選択肢がある~groupの中では<!-- （ピザ注文のトッピングなど） -->，複数の要素が `default$ps に合致し得る。
例えば `HTML5$r では、［
~formの中の “既定の” ~button,
`select$e 要素のうち初期~時に選択-済みの `option$e 要素（複数も可）,
その他の少数の要素
］が、 `default$ps に合致するものとされている（
<a href="~HTMLselectors#selector-default">参照</a>
）。
◎
One example is the default submit button among a set of buttons. Another example is the default option from a popup menu. In a select-many group (such as for pizza toppings), multiple elements can match :default. For example, [HTML5] defines that :default matches the “default button” in a form, the initially-selected &lt;option&gt;(s) in a &lt;select&gt;, and a few other elements.
</p>
			</section>
		</section>
		<section id="input-value-states">
<h3 title="Input Value States">12.2. 入力~値の状態</h3>

			<section id="checked">
<h4 title="The Selected-option Pseudo-class: :checked">12.2.1. 選択-済み疑似類	`checked^ps</h4>

<p>
~radio~buttonや~checkboxは，利用者により 2 つの状態に切り替えられ得る。
また、一部の~menu~itemは，利用者がそれを選択したとき “~checkされた状態” になる。
その種の要素が “~on” に切り替えられたとき
`checked@ps
疑似類の対象になる。
例えば `HTML5$r では、［
~checkされている［
~checkbox ／ ~radio~button
］ ／
選択されている `option$e 要素
］が `checked^ps に合致するものと定義されている（
<a href="~HTMLselectors#selector-checked">参照</a>
）。
◎
Radio and checkbox elements can be toggled by the user. Some menu items are "checked" when the user selects them. When such elements are toggled "on" the :checked pseudo-class applies. For example, [HTML5] defines that checked checkboxes, radio buttons, and selected &lt;option&gt; elements match :checked.
</p>

<p>
`checked$ps 疑似類は生来的に動的であり，利用者の動作により改められ得るものであるが、文書の中の意味論を与える属性の存在（
`HTML5$r の `selected^a 属性や `checked^a 属性など）に基づくものでもあるので，【静的~媒体も含む】すべての媒体に適用される。
◎
While the :checked pseudo-class is dynamic in nature, and can altered by user action, since it can also be based on the presence of semantic attributes in the document (such as the selected and checked attributes in [HTML5]), it applies to all media.
</p>

<div class="example">
<p>
否定~疑似類を用いれば、~checkされていない~checkboxも選択できる：
◎
An unchecked checkbox can be selected by using the negation pseudo-class:
</p>

<pre class="lang-css">
input[type=checkbox]:not(:checked)
</pre>

</div>

			</section>
			<section id="indeterminate">
<h4 title="The Indeterminate-value Pseudo-class: :indeterminate">12.2.2. 不定 疑似類	`indeterminate^ps</h4>

<p>
`indeterminate@ps
疑似類は、値が不定の状態にある~UI要素を対象にする。
例えば、~UI要素［
~radio~button／~checkbox
］は，~checkの有無が切り替えられ得るが、そのいずれでもない不定の状態をとることもある。
同様に、進捗計は完了率が未知であるときに，不定の状態をとり得る。
例えば `HTML5$r では、~checkboxがどのようなときに `indeterminate^ps に合致するかを定めている（
<a href="~HTMLselectors#selector-indeterminate">参照</a>
）。
◎
The :indeterminate pseudo-class applies to UI elements whose value is in an indeterminate state. For example, radio and checkbox elements can be toggled between checked and unchecked states, but are sometimes in an indeterminate state, neither checked nor unchecked. Similarly a progress meter can be in an indeterminate state when the percent completion is unknown. For example, [HTML5] defines how checkboxes can be made to match :indeterminate.
</p>

<p>
`checked$ps 疑似類と同様に、 `indeterminate$ps も すべての媒体に適用される。
例えば，初期~時に選択-済みのものがない~radio~groupの各~部品は、静的~表示の下でも `indeterminate$ps になる。
◎
Like the :checked pseudo-class, :indeterminate applies to all media. Components of a radio-group initialized with no pre-selected choice, for example, would be :indeterminate even in a static display.
</p>

			</section>
		</section>
		<section id="ui-validity">
<h3 title="Input Value-checking">12.3. 入力~値の検査-法</h3>

			<section id="validity-pseudos">
<h4 title="The Validity Pseudo-classes: :valid and :invalid">12.3.1. 妥当性 疑似類	`valid^ps, `invalid^ps</h4>

<p>
要素は，その内容あるいは値が文書~言語（例えば `XFORMS11$r や `HTML5$r ）により定義される~data妥当性~意味論に則って 妥当であるかどうかに従って，
`valid@ps （妥当である）／
`invalid@ps （妥当でない）
とされる。
~data妥当性~意味論を欠く要素は、これらの疑似類の対象にならない。
◎
An element is :valid or :invalid when its contents or value is, respectively, valid or invalid with respect to data validity semantics defined by the document language (e.g. [XFORMS11] or [HTML5]). An element which lacks data validity semantics is neither :valid nor :invalid.
</p>

<p class="note">注記：
拘束がなく, したがって常に `valid$ps になる要素と，~data妥当性~意味論を全く備えず, したがって `valid$ps でも `invalid$ps でもないものは、別物であることに注意。
例えば~HTMLでは、
`type="text"^s の `input$e 要素は，拘束なしになり得る一方で、
`p$e 要素は，~data妥当性~意味論を備えず これらの疑似類に合致することは決してない。
◎
Note: There is a difference between an element which has no constraints, and thus would always be :valid, and one which has no data validity semantics at all, and thus is neither :valid nor :invalid. In HTML, for example, an &lt;input type="text"&gt; element may have no constraints, but a p element has no validity semantics at all, and so it never matches either of these pseudo-classes.
</p>

			</section>
			<section id="range-pseudos">
<h4 title="The Range Pseudo-classes: :in-range and :out-of-range">12.3.2. 範囲~疑似類	`in-range^ps, `out-of-range^ps</h4>

<p>
［
`in-range@ps
／
`out-of-range@ps
］疑似類が適用されるのは、範囲に制限がある要素に限られる。
要素に束縛されている値が，文書~言語により定義される範囲の［
範囲~内／範囲~外
］にあるならば、要素は［
`in-range$ps ／ `out-of-range$ps 
］に合致する。
~data範囲に制限-のない要素や, ~form~controlでない要素は、［
`in-range$ps ／ `out-of-range$ps 
］の対象にならない。
例えば 1 〜 10 の値のみを表現する~slider~controlとして呈示されている `slider^e 要素は，その値が 11 であれば `out-of-range$ps  になる。
あるいは、~~選択肢が "A", "B", "C" のみからなる~popup~menuとして呈示されている `menu$e 要素の値が "E" にされているときも。
◎
The :in-range and :out-of-range pseudo-classes apply only to elements that have range limitations. An element is :in-range or :out-of-range when the value that the element is bound to is in range or out of range with respect to its range limits as defined by the document language. An element that lacks data range limits or is not a form control is neither :in-range nor :out-of-range. E.g. a slider element with a value of 11 presented as a slider control that only represents the values from 1-10 is :out-of-range. Another example is a menu element with a value of "E" that happens to be presented in a popup menu that only has choices "A", "B" and "C".
</p>

			</section>
			<section id="opt-pseudos">
<h4 title="The Optionality Pseudo-classes: :required and :optional">12.3.3. 必須随意 疑似類	`required^ps, `optional^ps</h4>

<p>
~form要素【~form部品の総称】は、それが属する~formが妥当なものとして提出-可能になるために，その値が
必須（ required ）なのか／随意（ optional ）なのか
に応じて
`required@ps ／ `optional@ps
の対象になる。
~form要素でない要素は、これらの対象にならない。
◎
A form element is :required or :optional if a value for it is, respectively, required or optional before the form it belongs to can be validly submitted. Elements that are not form elements are neither required nor optional.
</p>

<p class="trans-note">【
文面からは、
~HTML `form$e 要素の外で用いられた `input$e 要素などの~form部品は，
“~form要素でない”
とも読めそうだが、そうでもないようだ（
<a href="~HTMLselectors#selector-required">~HTML仕様の該当する記述</a>
）。
】</p>

			</section>
			<section id="user-pseudos">
<h4 title="The User-interaction Pseudo-class: :user-invalid">12.3.4. 利用者~対話 疑似類	`user-invalid^ps</h4>

<p>
`user-invalid@ps †
疑似類は、入力~値が不正であるが，利用者がそれに対するやりとりを行った <em>後にのみ</em> 対象になる要素を表現する。
`user-invalid$ps 疑似類は、利用者が~formの提出-を試みてから
利用者が再びその~form要素と意識的にやりとりする前までの間の，［
`invalid$ps ,
`out-of-range$ps ,
未~入力の `required$ps
］の要素に合致し~MUST。
~UA は，利用者に向けて~errorを強調することが適切であるときには、そのような要素に合致させてもよい。
例えば~UAは、利用者が一度 何らかの~textを~~手入力してから別の要素に~focusを移動させたときに， `invalid$ps な要素を `user-invalid$ps 合致するようにした上で、利用者が入力を成功裡に正した後にのみ，合致しないようにしてもよい。
【† 2015 年 9 月： ":user-error" から改称された。】
◎
The :user-invalid pseudo-class represents an element with incorrect input, but only after the user has significantly interacted with it. The :user-error pseudo-class must match an :invalid, :out-of-range, or blank-but-:required elements between the time the user has attempted to submit the form and before the user has interacted again with the form element. User-agents may allow it to match such elements at other times, as would be appropriate for highlighting an error to the user. For example, a UA may choose to have :user-error match an :invalid element once the user has typed some text into it and changed the focus to another element, and to stop matching only after the user has successfully corrected the input.
</p>

<div class="example">
<p>
例えば、次の文書~片における入力は、頁が読込まれ次第（初期~時の値（ `value=11^s ）が最大~値（ `max=10^s ）を超えているので）， `invalid$ps に合致することになるが、利用者が要素と意識的にやりとりするか,
それが属する~formの提出-を試みるまでは， `user-invalid$ps に合致しない。
◎
For example, the input in the following document fragment would match :invalid as soon as the page is loaded (because it the initial value violates the max-constraint), but it won’t match :user-error until the user significantly interacts with the element, or attempts to submit the form it’s part of.
</p>



<pre class="lang-ml">
&lt;form&gt;
  &lt;label&gt;
    Volume:
    &lt;input name='vol' type=number min=0 max=10 value=11&gt;
  &lt;/label&gt;
  ...
&lt;/form&gt;
</pre>

</div>

<p class="issue">
`-moz-ui-invalid$ps と突き合わせて検査する。
◎
Cross-check with :-moz-ui-invalid.
</p>

<p class="issue">
WG による解決に従って
`-moz-ui-invalid$ps を `user-valid^ps として追加する。
◎
Add :-moz-ui-valid as :user-valid per WG resolution.
</p>

<p class="issue">
<a href="https://lists.w3.org/Archives/Public/www-style/2014Feb/0511.html">`dirty^ps 疑似類</a>
の提案を評価する必要がある。
◎
Evaluate proposed :dirty pseudo-class
</p>

<p class="issue">
これ（および `invalid$ps, `valid$ps ）が
`form$e, `fieldset$e 
要素にも適用し得ることを明確化する。
◎
Clarify that this (and :invalid/:valid) can apply to form and fieldset elements.
</p>



			</section>
		</section>
	</section>
	<section id="structural-pseudos">
<h2 title="Tree-Structural pseudo-classes">13. 木~構造上の疑似類</h2>

<p>
`構造上の疑似類@
は、［
文書~木の中に在るが, 他の`単体~選択子$や`結合子$では表現し得ないような，~~特別な追加~情報
］に基づく選択を可能にするために，導入された概念である。
◎
Selectors introduces the concept of structural pseudo-classes to permit selection based on extra information that lies in the document tree but cannot be represented by other simple selectors or combinators.
</p>

<p>
~text~nodeなどの非~要素~nodeは、親の中での子の位置（ “付番” ）の計算-時には数えられない。
この付番は 1 から開始される。
◎
Standalone text and other non-element nodes are not counted when calculating the position of an element in the list of children of its parent. When calculating the position of an element in the list of children of its parent, the index numbering starts at 1.
</p>

<p>
`構造上の疑似類$は文書~木 内の要素のみに適用される
—
それらは決して，`疑似要素$に合致しては~MUST_NOT。
◎
The structural pseudo-classes only apply to elements in the document tree; they must never match pseudo-elements.
</p>


		<section id="the-root-pseudo">
<h3 title=":root pseudo-class">13.1. `root^ps 疑似類</h3>

<p>
`root@ps
疑似類は、文書の根である要素を表現する。
◎
The :root pseudo-class represents an element that is the root of the document.
</p>

<p>
例えば~DOM文書においては、 `root$ps 疑似類は `Document$I ~objの根~要素†に合致する。
~HTMLでは、これは `html$e 要素になる（~scriptにより文書が改変されない限り）。
◎
For example, in a DOM document, the :root pseudo-class matches the root element of the Document object. In HTML, this would be the html element (unless scripting has been used to modify the document).
</p>

<p class="trans-note">【†
紛らわしいが、文書~木の根（ `Document^I ）ではなく，`文書~要素$
— すなわち，根の子であって, <em>要素である</em>（唯一の）要素 —
を意味する。
】</p>

		</section>
		<section id="the-empty-pseudo">
<h3 title=":empty pseudo-class">13.2. `empty^ps 疑似類</h3>

<p>
`empty@ps
疑似類は、内容が “空” の要素を表現する。
文書~木の語で言い換えるなら、要素が空かどうかに影響するものは，［
要素~node（ `Element$I ）, および
空でない~dataを含む内容~node（ `DOM$r の~text~node（ `Text$I ）や実体参照（ `EntityReference$I ）など）
］であり，［
~comment（ `Comment$I ）, 処理命令（ `ProcessingInstruction$I ）, 他の~node
］は影響してはならない。
◎
The :empty pseudo-class represents an element that has no children at all. In terms of the document tree, only element nodes and content nodes (such as [DOM] text nodes, and entity references) whose data has a non-zero length must be considered as affecting emptiness; comments, processing instructions, and other nodes must not affect whether an element is considered empty or not.
</p>

<p class="trans-note">【
各~node種別の括弧内の~interface名は、訳者補足。
最新の DOM4 `DOM$r では：
“他の~node” は、文書（ `Document$I ）, 文書片（ `DocumentFragment$I ）, 文書型宣言（ `DocumentType$I ）を指す。
また、 `EntityReference$I （~DOMの文脈における実体参照）は廃止されている（置換後の状態において解釈されることになると見られる）。
】</p>


<div class="example">

<p>
`p:empty^S
は次の片に対する有効な表現になる：
◎
Examples: p:empty is a valid representation of the following fragment:
</p>

<pre class="lang-ml">
&lt;p&gt;&lt;/p&gt;
</pre>

<p>
`foo:empty^S
は次の片に対する有効な表現にはならない：
◎
foo:empty is not a valid representation for the following fragments:
</p>

<pre class="lang-ml">
&lt;foo&gt;bar&lt;/foo&gt;
</pre>

<pre class="lang-ml">
&lt;foo&gt;&lt;bar&gt;bla&lt;/bar&gt;&lt;/foo&gt;
</pre>

<pre class="lang-ml">
&lt;foo&gt;this is not &lt;bar&gt;:empty&lt;/bar&gt;&lt;/foo&gt;
</pre>

</div>

		</section>
		<section id="the-blank-pseudo">
<h3 title=":blank pseudo-class">13.3. `blank^ps 疑似類</h3>

<p>
`blank@ps
疑似類は、内容が
<a href="~CSSTEXT#white-space-rules">空白~処理に影響される文字</a>
`CSS3TEXT$r
のみからなる要素にも 追加で合致することを除いて， `empty$ps 疑似類と同様である。
◎
The :blank pseudo-class is like the :empty pseudo-class, except that it additionally matches elements that only contain code points affected by whitespace processing. [CSS3TEXT]
</p>

<div class="example">
<p>
例えば，次の要素は、改行が含まれているので，
`blank$ps には合致するが `empty$ps には合致しない：
◎
For example, the following element matches :blank, but not :empty, because it contains at least one linebreak, and possibly other whitespace:
</p>

<pre class="lang-ml">
&lt;p&gt;<br>&lt;/p&gt;
</pre>

</div>

<p class="issue">
`blank$ps の様な名前は、 `empty$ps との相違が明瞭でなく，好ましくない。
Moziila が利用している
`-moz-whitespace-only^ps
は明瞭だが，少々長い。
他に良案は？
◎
We don’t like the name :blank—it doesn’t clearly convey a difference from :empty. Moz uses :-moz-whitespace-only, which is clear but a little wordy. Any other suggestions?
</p>

		</section>
		<section id="child-index">
<h3 title="Child-indexed Pseudo-classes">13.4. 子付番 疑似類</h3>


<p>
この節にて定義される疑似類は、要素の`同胞群$における付番
【要素はその同胞群の中で何個目に位置するか】
に基づいて選択する。
◎
The pseudo-classes defined in this section select elements based on their index amongst their inclusive siblings.
</p>

<p>
この節, および後続の節に現れる
<dfn id="AnB-notation">~AnB 記法</dfn>
の詳細は、
CSS Syntax Module `CSS3SYN$r にて<a href="~CSSSYN#anb-microsyntax">定義される</a>。
</p>

<p class="note">注記：
Selectors 3 では、これらの選択子を，［［［
要素の親の，子~list
］における，要素の付番
］に基づいて要素を選択するもの
］として述べていた（この記述は、この節~自体, および いくつかの疑似類の下でも，生き残る）。
が、要素の親が無いあるいは要素でない場合を除外する理由はないので、同胞たち（`同胞群$）の中での要素の相対的な付番と言い換えられた。
◎
Note: Selectors 3 described these selectors as selecting elements based on their index in the child list of their parents. (This description survives in the name of this very section, and the names of several of the pseudo-classes.) As there was no reason to exclude them from matching elements without parents, or with non-element parents, they have been rephrased to refer to an element’s relative index amongst its siblings.
</p>

<p class="trans-note">【
以下を簡潔に述べるため、この訳では，次の用語を導入する：
】</p>

<p>
要素 ~E の
`同胞群@
とは、 ~E と`広義同胞$の関係にある要素たちからなる，`木~順序$による集合である（ ~E 自身は常に含まれる）。
単に “同胞群” と記されたときは、文書~木~内のある要素の`同胞群$を意味する。
</p>

<div class="trans-note">
<p >【
定義により、親が要素でない要素（例えば `html$e 要素）であっても，その`同胞群$は、要素を含む（要素のみからなる）集合になる。
しかしながら，現実の（いくつかの）~browser実装では、親~要素の存在が要求されている
— 例えば，選択子 `html:first-child^css は、 `html^e 要素に合致しない（その同胞群は空集合と見做されている。
あるいは、~HTMLの文脈に限って，どこかでそう規定されているのかもしれない）。
】</p>

</div>



			<section id="the-nth-child-pseudo">
<h4 title=":nth-child() pseudo-class">13.4.1. `nth-child()^ps 疑似類</h4>

<p>
疑似類~記法
`nth-child(~AnB [of ~S]? )@ps
は、各 `同胞群$ごとに，その中で［
`選択子~list$ ~S に合致するもの
］のうち， ~AnBthの要素を表現する。
◎
The :nth-child(An+B [of S]? ) pseudo-class notation represents elements that are among An+Bth elements from the list composed of their inclusive siblings that match the selector list S.
</p>

<p>
`of ~S^css が省略された場合の既定の `~S^css は，`全称~選択子$ `*^css になる。
◎
The An+B notation and its interpretation are defined in CSS Syntax 3 §6 The An+B microsyntax. If S is omitted, it defaults to *.
</p>

<p>
この選択子は、例えば，~table内の~rowを飛び飛びに選択したり, 段落の~text色を一定周期で順繰りに変えていく用途に利用できる。
◎
For example, this selector could address every other row in a table, and could be used to alternate the color of paragraph text in a cycle of four.
</p>

<div class="example">
<p lang="en">Examples:</p>

<pre class="lang-css">
:nth-child(even)   /* <span class="comment">2, 4, 6, … 個目の要素を表現する</span> */
:nth-child(10n-1)  /* <span class="comment">9, 19, 29, … 個目の要素を表現する</span> */
:nth-child(10n+9)  /* <span class="comment">同じ</span> */
:nth-child(10n+-1) /* <span class="comment">構文が妥当でないので無視される</span> */◎
:nth-child(even)   /* represents the 2nd, 4th, 6th, etc elements
:nth-child(10n-1)  /* represents the 9th, 19th, 29th, etc elements */
:nth-child(10n+9)  /* Same */
:nth-child(10n+-1) /* Syntactically invalid, and would be ignored */
</pre>
</div>

<div class="example">
<p>
引数に選択子も渡せば、その選択子に合致するものから， N 個目の要素を選択できる。
例えば，次の選択子は、 `important^s ~classに属する~list~itemのうちの，最初の 3 個に合致する：
◎
By passing a selector argument, we can select the Nth element that matches that selector. For example, the following selector matches the first three “important” list items, denoted by the .important class:
</p>

<pre class="lang-css">
:nth-child(-n+3 of li.important)
</pre>

<p>
これは、引数に与えた選択子を，次の様に関数の外側に出したものとは異なることに注意：
◎
Note that this is different from moving the selector outside of the function, like:
</p>

<pre class="lang-css">
li.important:nth-child(-n+3)
</pre>

<p>
この選択子は、単に最初の 3 個の~list~itemのうち， `important^s ~classに属するものを選択する。
◎
This selector instead just selects the first three children if they also happen to be "important" list items.
</p>

</div>



<div class="example">
<p>
引数に選択子を用いて、~tableを正しく縞模様にさせる例を示す。
◎
Here’s another example of using the selector argument, to ensure that zebra-striping a table works correctly.
</p>

<p>
通常は，~tableの~rowを縞模様にするときは、次の様な~CSSを用いることになるだろう：
◎
Normally, to zebra-stripe a table’s rows, an author would use CSS similar to the following:
</p>

<pre class="lang-css">
tr {
  background: white;
}
tr:nth-child(even) {
  background: silver;
}
</pre>

<p>
しかしながら，いずれかの~rowが隠されて表示されなくなった場合、それを挟む同じ背景~色の~rowが隣り合い，~patternが崩れる。
~rowが~HTMLの `hidden^a 属性により隠されるとするなら、次の~CSSにより，どの~rowが隠されようが，背景は適正に交替され、一連の~rowは~~安定的に縞模様になる：
◎
However, if some of the rows are hidden and not displayed, this can break up the pattern, causing multiple adjacent rows to have the same background color. Assuming that rows are hidden with the [hidden] attribute in HTML, the following CSS would zebra-stripe the table rows robustly, maintaining a proper alternating background regardless of which rows are hidden:
</p>

<pre class="lang-css">
tr {
  background: white;
}
tr:nth-child(even of :not([hidden])) {
  background: silver;
}
</pre>


</div>



			</section>
			<section id="the-nth-last-child-pseudo">
<h4 title=":nth-last-child() pseudo-class">13.4.2. `nth-last-child()^ps 疑似類</h4>

<p>
疑似類~記法
`nth-last-child(~AnB [of ~S]? )@ps
は、各 `同胞群$ごとに，その中で［
`選択子~list$ ~S に合致するもの
］のうち，最後から~AnBthの要素を表現する。
◎
The :nth-last-child(An+B [of S]? ) pseudo-class notation represents elements that are among An+Bth elements from the list composed of their inclusive siblings that match the selector list S, counting backwards from the end.
</p>

<p>
`of ~S^css が省略された場合の既定の `~S^css は，`全称~選択子$ `*^css になる。
◎
The CSS Syntax Module [CSS3SYN] defines the An+B notation. If S is omitted, it defaults to *.
</p>

<div class="example">
<p lang="en">Examples:</p>

<pre class="lang-css">
tr:nth-last-child(-n+2)  /* <span class="comment">
~HTML~table内の最後の 2 本の~rowを表現する
◎
represents the two last rows of an HTML table
</span> */

foo:nth-last-child(odd)  /* <span class="comment">
`同胞群$の中で，最後から数えて，奇数~個目にある `foo^e 要素を表現する
◎
represents all odd foo elements in their parent element, counting from the last one
</span> */
</pre>
</div>

			</section>
			<section id="the-first-child-pseudo">
<h4 title=":first-child pseudo-class">13.4.3. `first-child^ps 疑似類</h4>

<p>
`first-child@ps
疑似類は、各 `同胞群$ごとに，その中の最初の要素を表現する。
これは
`:nth-child(1)^css
と同じである。
◎
The :first-child pseudo-class represents an element that if first among its inclusive siblings. Same as :nth-child(1).
</p>

<div class="example">

<p>
次の選択子は、
`div^e 要素の最初の子である
`p^e 要素を表現する：
◎
Examples: The following selector represents a p element that is the first child of a div element:
</p>

<pre class="lang-css">
div &gt; p:first-child
</pre>

<p>
この選択子は、次の片の `div^e 要素の内側の `p^e 要素を表現する：
◎
This selector can represent the p inside the div of the following fragment:
</p>

<pre class="lang-ml">
&lt;p&gt; .note の前の最後の P&lt;/p&gt;
&lt;div class="note"&gt;
&lt;p&gt; .note 内の最初の P&lt;/p&gt;
&lt;/div&gt;◎
&lt;p&gt; The last P before the note.&lt;/p&gt;
&lt;div class="note"&gt;
&lt;p&gt; The first P inside the note.&lt;/p&gt;
&lt;/div&gt;
</pre>

<p>
が、次の片の 2 個目の `p^e 要素は表現しない：
◎
but cannot represent the second p in the following fragment:
</p>

<pre class="lang-ml">
&lt;p&gt; .note の前の最後の P&lt;/p&gt;
&lt;div class="note"&gt;
&lt;h2&gt; Note &lt;/h2&gt;
&lt;p&gt; .note 内の最初の P&lt;/p&gt;
&lt;/div&gt;◎
&lt;p&gt; The last P before the note.&lt;/p&gt;
&lt;div class="note"&gt;
&lt;h2&gt; Note &lt;/h2&gt;
&lt;p&gt; The first P inside the note.&lt;/p&gt;
&lt;/div&gt;
</pre>

<p>
通例的には，次の 2 つの選択子は等価になる：
◎
The following two selectors are usually equivalent:
</p>

<pre class="lang-css">
* &gt; a:first-child   /* <span class="comment">
a は任意の要素の最初の子~要素
◎
a is first child of any element
</span> */
a:first-child       /* <span class="comment">
同じ（ a は根~要素でないとする）
◎
Same (assuming a is not the root element)
</span> */
</pre>

</div>

			</section>
			<section id="the-last-child-pseudo">
<h4 title=":last-child pseudo-class">13.4.4. `last-child^ps 疑似類</h4>

<p>
`last-child@ps
疑似類は、各 `同胞群$ごとに，その中の最後の要素を表現する。
これは
`:nth-last-child(1)^css
と同じである。
◎
The :last-child pseudo-class represents an element that is last among its inclusive siblings. Same as :nth-last-child(1).
</p>

<div class="example">

<p>
次の選択子は、
“有順序~list” `ol$e 要素の最後の子である
“~list~item” `li$e 要素を表現する：
◎
Example: The following selector represents a list item li that is the last child of an ordered list ol.
</p>

<pre class="lang-css">
ol &gt; li:last-child
</pre>

</div>

			</section>
			<section id="the-only-child-pseudo">
<h4 title=":only-child pseudo-class">13.4.5. `only-child^ps 疑似類</h4>

<p>
`only-child@ps
疑似類は、自身の他に同じ`同胞群$に属する要素は無いものを表現する
— これは，［
`:first-child:last-child^css ／
`:nth-child(1):nth-last-child(1)^css
］と同じになるが、`詳細度$は これらより低くなる。
◎
The :only-child pseudo-class represents an element that has no siblings. Same as :first-child:last-child or :nth-child(1):nth-last-child(1), but with a lower specificity.
</p>

			</section>
		</section>
		<section id="typed-child-index">
<h3 title="Typed Child-indexed Pseudo-classes">13.5. 有型 子付番 疑似類</h3>

<p>
この節の`疑似類$は，`子付番 疑似類§に類似するが、
<strong><a href="#type-selectors">同じ型の要素</a>の集合に~~限定された中で</strong>，要素の`同胞群$における要素の付番に基づいて解決される。
<!-- ＊ 原文 pseudo-element 誤記 -->
◎
The pseudo-elements in this section are similar to the Child Index Pseudo-classes, but they resolve based on an element’s index among elements of the same type (tag name) in their sibling list.
</p>

			<section id="the-nth-of-type-pseudo">
<h4 title=":nth-of-type() pseudo-class">13.5.1. `nth-of-type()^ps 疑似類</h4>

<p>
疑似類~記法
`nth-of-type(~AnB)@ps
は、
`:nth-child(~AnB of ~S)^css
に合致するものと同じ要素たちを表現する
— ここで ~S は、合致させる要素に合致するような［
名前空間 接頭辞と`型~選択子$
］である。
例えば，~HTML `img$e 要素がこの`疑似類$に合致するかどうかを考えるとき、
~S は `html|img^css になる（ `html^css に対する適切な名前空間は`宣言-$済みとする）。
◎
The :nth-of-type(An+B) pseudo-class notation represents the same elements that would be matched by :nth-child(|An+B| of S), where S is a type selector and namespace prefix matching the element in question. For example, when considering whether an HTML img element matches this pseudo-class, the S in question is html|img (assuming an appropriate html namespace is declared).
</p>

<div class="example">

<p>
これにより，複数の画像を交替的に `float^p ~~配置させられる：
◎
CSS example: This allows an author to alternate the position of floated images:
</p>

<pre class="lang-css">
img:nth-of-type(2n+1) { float: right; }
img:nth-of-type(2n) { float: left; }
</pre>

<p class="trans-note">【
仮に， `img^css を`全称~選択子$（ `*^css ）に置き換えたなら、各 要素~型ごとに個別に適用した結果の和集合を表現することになる。
言い換えれば， `*:nth-of-type(~AnB)^css は、［
ある`型$ ~E があって， `~E:nth-of-type(~AnB)^css に合致するもの
］すべてを表現する（ `:nth-child(~AnB)^css とは異なる）。
】</p>


</div>

<p class="note">注記：
要素の型が事前に既知ならば、この疑似類は，型~選択子も伴う `nth-child()$ps の利用に等価になる。
すなわち、 `img:nth-of-type(2)^s は， `*:nth-child(2 of img)^s と等価になる。
◎
Note: If the type of the element is known ahead of time, this pseudo-class is equivalent to using :nth-child() with a type selector. That is, img:nth-of-type(2) is equivalent to *:nth-child(2 of img).
</p>


			</section>
			<section id="the-nth-last-of-type-pseudo">
<h4 title=":nth-last-of-type() pseudo-class">13.5.2. `nth-last-of-type()^ps 疑似類</h4>

<p>
疑似類~記法
`nth-last-of-type(~AnB)@ps
は、
`:nth-last-child(~AnB of ~S)^css
に合致するものと同じ要素たちを表現する
— ここで ~S は、合致させる要素に合致するような［
名前空間 接頭辞と`型~選択子$
］である。
例えば，~HTML `img$e 要素がこの`疑似類$に合致するかどうかを考えるとき、
~S は `html|img^css になる（ `html^css に対する適切な名前空間は`宣言-$済みとする）。
◎
The :nth-last-of-type(An+B) pseudo-class notation represents the same elements that would be matched by :nth-last-child(|An+B| of S), where S is a type selector and namespace prefix matching the element in question. For example, when considering whether an HTML img element matches this pseudo-class, the S in question is html|img (assuming an appropriate html namespace is declared).
</p>

<div class="example">

<p>
次の選択子により、 `body^e 要素の子であって, 最初と最後を除くすべての `h2^e 要素を表現することが可能になる：
◎
Example: To represent all h2 children of an XHTML body except the first and last, one could use the following selector:
</p>

<pre class="lang-css">
body &gt; h2:nth-of-type(n+2):nth-last-of-type(n+2)
</pre>

<p>
この場合，`not()$ps を用いる方法もある（選択子の記述は同じ長さに）：
◎
In this case, one could also use :not(), although the selector ends up being just as long:
</p>

<pre class="lang-css">
body &gt; h2:not(:first-of-type):not(:last-of-type)
</pre>

</div>

			</section>
			<section id="the-first-of-type-pseudo">
<h4 title=":first-of-type pseudo-class">13.5.3. `first-of-type^ps 疑似類</h4>

<p>
`first-of-type@ps
疑似類は、
`:nth-of-type(1)^css
に合致するものと同じ要素たちを表現する。
◎
The :first-of-type pseudo-class represents the same element as :nth-of-type(1).
</p>

<div class="example">

<p>
次の選択子は、“定義~list” `dl$e の中で最初の“定義~~見出し” `dt$e を表現する。
すなわち この `dt^e は親の `dl^e 要素の子~要素~listの中で，その型の最初の要素になる：
◎
Example: The following selector represents a definition title dt inside a definition list dl, this dt being the first of its type in the list of children of its parent element.
</p>

<pre class="lang-css">
dl dt:first-of-type
</pre>

<p>
これは，次の例の最初の 2 個の `dt^e 要素に対する有効な記述になるが， 3 個目のものについてはそうならない：
◎
It is a valid description for the first two dt elements in the following example but not for the third one:
</p>

<pre class="lang-ml">
&lt;dl&gt;
  &lt;dt&gt;gigogne&lt;/dt&gt;
  &lt;dd&gt;
    &lt;dl&gt;
      &lt;dt&gt;fusée&lt;/dt&gt;
      &lt;dd&gt;multistage rocket&lt;/dd&gt;
      &lt;dt&gt;table&lt;/dt&gt;
      &lt;dd&gt;nest of tables&lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/dd&gt;
&lt;/dl&gt;
</pre>

</div>

			</section>
			<section id="the-last-of-type-pseudo">
<h4 title=":last-of-type pseudo-class">13.5.4. `last-of-type^ps 疑似類</h4>

<p>
`last-of-type@ps
疑似類は、
`:nth-last-of-type(1)^css
に合致するものと同じ要素たちを表現する。
◎
The :last-of-type pseudo-class represents the same element as :nth-last-of-type(1).
</p>

<div class="example">

<p>
次の選択子は、~tableの各 “~row” `tr$e 要素の最後の “~data~cell” `td$e 要素を表現する：
◎
Example: The following selector represents the last data cell td of a table row tr.
</p>

<pre class="lang-css">
tr &gt; td:last-of-type
</pre>

</div>

			</section>
			<section id="the-only-of-type-pseudo">
<h4 title=":only-of-type pseudo-class">13.5.5. `only-of-type^ps 疑似類</h4>

<p>
`only-of-type@ps
疑似類は、
`:first-of-type:last-of-type^css
に合致するものと同じ要素たちを表現する。
◎
The :only-of-type pseudo-class represents the same element as :first-of-type:last-of-type.
</p>

			</section>
		</section>
	</section>
	<section id="combinators">
<h2 title="Combinators">14. 結合子</h2>

		<section id="descendant-combinators">
<h3 title="Descendant combinator ( ) or (&gt;&gt;)">14.1. 子孫~結合子	( SPACE ) または ( `&gt;&gt;^css )</h3>


<p>
文書~木の中で，別の要素の子孫であるような要素を記述する選択子が求められることがある（例えば
“ `h1^e 要素に包含されている `em^e 要素”
）。
`子孫~結合子@
は、その種の関係性を表す。
構文上は、次の 2 種の形をとる：
◎
At times, authors may want selectors to describe an element that is the descendant of another element in the document tree (e.g., "an em element that is contained within an H1 element"). The descendant combinator expresses such a relationship. It has two syntactic forms:
</p>

<ol>
	<li>
2 つの`合体~選択子$を区切る`空白$,
<em>または</em>
◎
whitespace that separates two compound selectors or
</li>
	<li>
二重にされた子~選択子
—
<dfn id="selectordef-descendant">`&gt;&gt;^css</dfn>
◎
A doubled child selector (&gt;&gt;)
</li>
</ol>

<p>
［
`A B^css ／ `A &gt;&gt; B^css
］の形による選択子は、何らかの先祖である `A^e 要素の子孫であるような，任意の `B^e 要素を表現する。
◎
A selector of the form A B or A &gt;&gt; B' represents an element B that is an arbitrary descendant of some ancestor element A.
</p>


<div class="example">
<p>
次の選択子を考える：
◎
Examples: For example, consider the following selector:
</p>

<pre class="lang-css">
h1 em
</pre>

<p>
これは、 `h1^e 要素の子孫である `em^e 要素を表現する。
それは次の片の一部分に対する有効な記述になる:
◎
It represents an em element being the descendant of an h1 element. It is a correct and valid, but partial, description of the following fragment:
</p>

<pre class="lang-ml">
&lt;h1&gt;この&lt;span class="myclass"&gt;~~見出し行は
&lt;em&gt;とても&lt;/em&gt;重要です&lt;/span&gt;&lt;/h1&gt;
</pre>
<!-- 
&lt;h1&gt;This &lt;span class="myclass"&gt;headline
is &lt;em&gt;very&lt;/em&gt; important&lt;/span&gt;&lt;/h1&gt;
-->
<p>
次の選択子：
◎
The following selector:
</p>

<pre class="lang-css">
div * p
</pre>

<p>
は、
`div^e 要素の孫（子の子）またはより遠い子孫である
`p^e 要素を表現する。
"`*^css" の両側にある`空白$は`全称~選択子$の一部をなさないことに注意。
この`空白$は`結合子$である  — すなわち，
`div^e 要素が 何らかの要素 ~E の先祖であって, かつ
~E が `p^e 要素の先祖でなければならないことを指示している。
◎
represents a p element that is a grandchild or later descendant of a div element. Note the whitespace on either side of the "*" is not part of the universal selector; the whitespace is a combinator indicating that the div must be the ancestor of some element, and that that element must be an ancestor of the p.＼
</p>

<p>
`子孫~結合子$と`属性~選択子§を組合せる次の選択子は、
`href^a 属性が設定されていて, かつ
`div^e 要素の内側にある `p^e 要素の内側にあるような要素を表現する：
◎
The following selector, which combines descendant combinators and attribute selectors, represents an element that (1) has the href attribute set and (2) is inside a p that is itself inside a div:
</p>

<pre class="lang-css">
div p *[`href^a]
</pre>

</div>

<p class="note">注記：
空白~形は CSS Level 1 から存在している一方、
`&gt;&gt;^css 形は Level 4 から導入された。
それは、子孫~結合子を可視の非~空白~形にして，
`子~結合子$（ `&gt;^css ）と［
~shadowを貫く（ shadow-piercing ）子孫~結合子
］（ `&gt;&gt;&gt;^css ） `CSS-SCOPING-1$r の間の欠落を埋めるために導入された。
◎
Note: Note that the whitespace form has existed since CSS Level 1, whereas the &gt;&gt; form is introduced in Level 4. It was introduced to give the descendant combinator a visible, non-whitespace form and to bridge the gap between the child combinator (&gt;) and the shadow-piercing descendant combinator (&gt;&gt;&gt;) [CSS-SCOPING-1].
</p>


		</section>
		<section id="child-combinators">
<h3 title="Child combinator (&gt;)">14.2. 子~結合子	( `&gt;^css )</h3>

<p>
`子~結合子@
は、要素と要素の親子関係を記述し， 2 つの`合体~選択子$を区切る
“大なり記号”
— `003E^U0
<dfn id="selectordef-child">`&gt;^css</dfn> 
—
で記される。
◎
A child combinator describes a childhood relationship between two elements. A child combinator is made of the "greater-than sign" (U+003E, &gt;) code point and separates two compound selectors.
</p>

<div class="example">
<p>
次の選択子は、 `body^e 要素の子であるような `p^e 要素を表現する：
◎
Examples: The following selector represents a p element that is child of body:
</p>

<pre class="lang-css">
body &gt; p
</pre>

<p>
`子孫~結合子$と`子~結合子$を組合せる用例：
◎
The following example combines descendant combinators and child combinators.
</p>

<pre class="lang-css">
div ol&gt;li p
</pre>
   <!-- LEAVE THOSE SPACES OUT! see below -->
<p>
これは
`li$e 要素の子孫であるような `p$e 要素を表現するが，
`li$e 要素は `ol$e 要素の子でなければならず，
`ol$e 要素は `div$e 要素の子孫で~MUST。

結合子 "`&gt;^css" の前後の`空白$が省略されていることに注意。
◎
It represents a p element that is a descendant of an li element; the li element must be the child of an ol element; the ol element must be a descendant of a div. Notice that the optional white space around the "&gt;" combinator has been left out.
</p></div>

<p>
要素の最初の子を選択するような類いのものについては、上述の`構造上の疑似類§ 節を見よ。
◎
For information on selecting the first child of an element, please see the section on the :first-child pseudo-class above.
</p>

		</section>
		<section id="adjacent-sibling-combinators">
<h3 title="Next-sibling combinator (+)">14.3. 次同胞~結合子	( `+^css )</h3>

<p>
`次同胞~結合子@
は、 2 つの`合体~選択子$を区切る
“正符号”
— `002B^U0
<dfn id="selectordef-adjacent">`+^css</dfn>
—
で記される。
この 2 つの`合体~選択子$で表現される要素は、文書~木の中で同じ親を共有し，
1 個目の`合体~選択子$で表現される要素が
2 個目のもので表現される要素の直前に位置する。
要素でない~node（例えば，要素~間に挟まれた~text）は、要素の隣接性を考慮する際には無視される。
◎
The next-sibling combinator is made of the “plus sign” (U+002B, +) code point that separates two compound selectors. The elements represented by the two compound selectors share the same parent in the document tree and the element represented by the first compound selector immediately precedes the element represented by the second one. Non-element nodes (e.g. text between elements) are ignored when considering the adjacency of elements.
</p>

<div class="example">
<p>
次の選択子は、 `math^e 要素の直後に位置する `p^e 要素を表現する：
◎
Examples: The following selector represents a p element immediately following a math element:
</p>

<pre class="lang-css">
math + p
</pre>

<p>
次の選択子には、`属性~選択子$が追加されている
— `h1^e 要素は `opener^s ~classに属するとする拘束も追加されている —
ことを除いて，前の例のものと概念的に同様になる：
◎
The following selector is conceptually similar to the one in the previous example, except that it adds an attribute selector — it adds a constraint to the h1 element, that it must have class="opener":
</p>

<pre class="lang-css">
h1.opener + h2
</pre>

</div>

		</section>
		<section id="general-sibling-combinators">
<h3 title="Subsequent-sibling combinator (~)">14.4. 後続同胞~結合子	( `~^css )</h3>

<p>
`後続同胞~結合子@
は、 2 つの`合体~選択子$を区切る
“~tilde”
— `007E^U0
<dfn id="selectordef-sibling">`~^css</dfn>
—
で記される。
この 2 つの`合体~選択子$で表現される要素は、文書~木の中で同じ親を共有し，
1 個目の`合体~選択子$で表現される要素が，
2 個目のもので表現される要素よりも先行する（直前でなくともよい）。
◎
The subsequent-sibling combinator is made of the "tilde" (U+007E, ~) code point that separates two compound selectors. The elements represented by the two compound selectors share the same parent in the document tree and the element represented by the first compound selector precedes (not necessarily immediately) the element represented by the second one.
</p>

<div class="example">

<pre class="lang-css">
h1 ~ pre
</pre>

<p>
は、 `h1^e 要素に後続する `pre^e 要素を表現する。
それは次の片の一部分に対する有効な記述になる：
◎
represents a pre element following an h1. It is a correct and valid, but partial, description of:
</p>

<pre class="lang-ml">
&lt;h1&gt;~~関数 a の~~定義&lt;/h1&gt;
&lt;p&gt;この表のすべての図には Function a(x) を~~適用すること。&lt;/p&gt;
&lt;pre&gt;function a(x) = 12x/13.5&lt;/pre&gt;
</pre>
<!-- 
&lt;h1&gt;Definition of the function a&lt;/h1&gt;
&lt;p&gt;Function a(x) has to be applied to all figures in the table.&lt;/p&gt;
&lt;pre&gt;function a(x) = 12x/13.5&lt;/pre&gt;
-->
</div>

		</section>
	</section>
	<section id="table-pseudos">
<h2 title="Grid-Structural Selectors">15. 格子構造~選択子</h2>

<p>
2 次元~格子の~cellの（その~rowと~colへの）二重の所属関係は、階層的~markup言語における親子関係では，一方のみしか 表現し得ず、もう一方の所属関係は，文書~言語の意味論において明示的／暗黙的に定義され~MUST。
2 つの最も普及している階層的~markup言語である~HTMLと DocBook の両者とも，~markupは~row主導であり（すなわち，~rowへの所属関係が階層で表現される）、~colについては言外に与えられ~MUST。
<!--  -->
その種の~colへの言外の所属関係を表現し得るようにするため、
`~column結合子$ および `nth-column()$ps , `nth-last-column()$ps  疑似類が定義される。
~col主導の文書~言語においては、これらの疑似類は，~rowへの所属関係に合致する。
◎
The double-association of a cell in a 2D grid (to its row and column) cannot be represented by parentage in a hierarchical markup language. Only one of those associations can be represented hierarchically: the other must be explicitly or implicitly defined in the document language semantics. In both HTML and DocBook, two of the most common hierarchical markup languages, the markup is row-primary (that is, the row associations are represented hierarchically); the columns must be implied. To be able to represent such implied column-based relationships, the column combinator and the :nth-column() and :nth-last-column() pseudo-classes are defined. In a column-primary format, these pseudo-classes match against row associations instead.
</p>

		<section id="the-column-combinator">
<h3 title="Column combinator">15.1. ~column結合子</h3>

<p>
`~column結合子@
は、~column要素
【［行／列］主導の階層的~markup言語の下で［列／行］を指示する要素】
が表現する~columnへの~cell要素の所属関係を表現し，
2 個の `007C^U 並び
—
<dfn id="selectordef-column">`||^css</dfn>
—
で記される。
~columnへの所属は，文書~言語の意味論のみに基づいて決定される
— 要素が呈示されるかどうかや, どのように呈示されるかに関わりなく。
複数の~columnに属する~cell要素は、それらのどの~columnへの所属を指示する選択子でも，表現される。
◎
The column combinator, which consists of two pipes (||) represents the relationship of a column element to a cell element belonging to the column it represents. Column membership is determined based on the semantics of the document language only: whether and how the elements are presented is not considered. If a cell element belongs to more than one column, it is represented by a selector indicating membership in any of those columns.
</p>

<div class="example">
<p>
次の例では，~cell C, E, G に~style（ `background: gray^S, 等々）が適用される。
◎
The following example makes cells C, E, and G gray.
</p>

<pre class="lang-css">
col.selected || td {
  background: gray;
  color: white;
  font-weight: bold;
}
</pre>

<pre class="lang-ml">
&lt;table&gt;
      &lt;col span="2"    &gt; &lt;col class="selected"&gt;
  &lt;tr&gt;&lt;td&gt; A &lt;td&gt;      B &lt;td&gt; C
  &lt;tr&gt;&lt;td colspan="2"&gt; D &lt;td&gt; E
  &lt;tr&gt;&lt;td&gt; F &lt;td colspan="2"&gt; G
&lt;/table&gt;
</pre>

</div>

		</section>
		<section id="the-nth-column-pseudo">
<h3 title=":nth-column() pseudo-class">15.2. `nth-column()^ps 疑似類</h3>

<p>
疑似類~記法
`nth-column(~AnB)@ps
は、同胞の~column間で~AnBthの~columnに属する~cell要素を表現する。
~columnへの所属の定義は、`~column結合子$を見よ。
◎
The :nth-column(An+B) pseudo-class notation represents a cell element belonging to a column that has An+B-1 columns before it, for any positive integer or zero value of n. Column membership is determined based on the semantics of the document language only: whether and how the elements are presented is not considered. If a cell element belongs to more than one column, it is represented by a selector indicating any of those columns.
◎
The CSS Syntax Module [CSS3SYN] defines the An+B notation.
</p>

		</section>
		<section id="the-nth-last-column-pseudo">
<h3 title=":nth-last-column() pseudo-class">15.3. `nth-last-column()^ps 疑似類</h3>

<p>
疑似類~記法
`nth-last-column(~AnB)@ps
は、同胞†の~column間で最後から~AnBthの~columnに属する~cell要素を表現する。
~columnへの所属の定義は、`~column結合子$を見よ。
【†どの~columnが互いに “同胞” とされるかについては、文書~言語が規定することになるであろう。】
◎
The :nth-last-column(An+B) pseudo-class notation represents a cell element belonging to a column that has An+B-1 columns after it, for any positive integer or zero value of n. Column membership is determined based on the semantics of the document language only: whether and how the elements are presented is not considered. If a cell element belongs to more than one column, it is represented by a selector indicating any of those columns.
◎
The CSS Syntax Module [CSS3SYN] defines the An+B notation.
</p>

		</section>
	</section>
	<section id="specificity-rules">
<h2 title="Calculating a selector’s specificity">16. 選択子の詳細度の計算-法</h2>

<p>
選択子（`複体~選択子$）の
`詳細度@
は、次の様にして，与えられた要素に対して計算される：
◎
A selector’s specificity is calculated for a given element as follows:
</p>

<!-- 
詳細度： ~CSSの下では，（概ね）ある出自~levelの~style適用の優先順位を与える。
-->

<ul>
	<li>
選択子の中の `~ID選択子$の個数を数える（ = %A ）
◎
count the number of ID selectors in the selector (= A)
</li>
	<li>
選択子の中の［
`~class選択子$, `属性~選択子$, `疑似類§
］の個数を数える（ = %B ）
◎
count the number of class selectors, attributes selectors, and pseudo-classes in the selector (= B)
</li>
	<li>
選択子の中の［
`型~選択子$, `疑似要素$
］の個数を数える（ = %C ）
◎
count the number of type selectors and pseudo-elements in the selector (= C)
</li>
	<li>
`全称~選択子$は無視する
◎
ignore the universal selector
</li></ul>

<p>
`選択子~list$の詳細度は、~list内の［
要素に合致するような`複体~選択子$
］のうち，その詳細度が最大のものになる。
【したがって、詳細度は，どの要素に合致したかにも依存することになる。】
◎
If the selector is a selector list, this number is calculated for each selector in the list, and the specificity of the entire selector is the largest of any individual selector in the list that matches the element.
</p>


<p>
疑似類のうち少数のものは、他の選択子に対する “評価~文脈” を提供し、詳細度は，それらの内容, および どう合致するかにより定義される：
◎
A few pseudo-classes provide "evaluation contexts" for other selectors, and so have their specificity defined by their contents and how they match:
</p>

<ul>
	<li>
<p>
`matches()$ps 疑似類の詳細度は、その引数である選択子~listの詳細度に置換される。
（選択子~全体の詳細度は、 `matches()$ps を外した下で，すべての組合せを全部的に展開したもの†と等価になる。）
◎
The specificity of a :matches() pseudo-class is replaced by the specificity of its selector list argument. (The full selector’s specificity is equivalent to expanding out all the combinations in full, without :matches().)
</p>

<p class="trans-note">【†
例えば［
`X &gt; :matches( Y1, Y2 ) &gt; Z^S
］のような形なら、［
`X &gt; Y1 &gt; Z, X &gt; Y2 &gt; Z^S
］のように，全体として選択子~listの形に展開することを意味すると思われる。
】</p>

	</li>
	<li>
同様に［
`nth-child()$ps ／
`nth-last-child()$ps ／
`nth-of-type()$ps ／
`nth-last-of-type()$ps
］選択子の詳細度は、疑似類~自身の詳細度（ 1 個の疑似類~選択子として数える）に，（もしあれば）その引数である選択子~listの詳細度を加算したものになる。
◎
Similarly, the specificity of an :nth-child(), :nth-last-child(), :nth-of-type(), or :nth-last-of-type() selector is the specificity of the pseudo class itself (counting as one pseudo-class selector) plus the specificity of its selector list argument (if any).
</li>
	<li>
`not()$ps 疑似類の詳細度は、［
その引数である選択子~list内で，最も詳細度の高い`複体~選択子$
］の詳細度に置換される。
◎
The specificity of a :not() pseudo-class is replaced by the specificity of the most specific complex selector in its selector list argument.
</li></ul>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<ul>
	<li>
<p>
`:matches(em, #foo)^S
の詳細度は：
</p>
		<ul>
			<li>
`em^e に合致したときは，`型~選択子$に対するときと同様に
( 0,0,1 ) になる。
</li>
			<li>
`em id=foo^e に合致したときは、`~ID選択子$に対するときと同様に
( 1,0,0 ) になる。
</li>
		</ul>

◎
:matches(em, #foo) has a specificity of (0,0,1)--like a tag selector--when matched against &lt;em&gt;, and a specificity of (1,0,0)--like an ID selector--when matched against &lt;em id=foo&gt;.
</li>
	<li>

<p>
`:nth-child(even of li, .item)^S
の詳細度は：
</p>
		<ul>
			<li>
`li^e に合致したときは、［
`型~選択子$ ＋ 1 個の疑似類
］に対するときと同様に
( 0,1,1 ) になる。
</li>
			<li>
`li class=item id=foo^e に合致したときは、［
`~class選択子$ ＋ 1 個の疑似類
］に対するときと同様に
( 0,2,0 ) になる。
</li>
		</ul>

◎
:nth-child(even of li, .item) has a specificity of (0,1,1)--like a tag selector plus a pseudo-class--when matched against &lt;li&gt;, and a specificity of (0,2,0)--like a class selector plus a pseudo-class--when matched against &lt;li class=item id=foo&gt;.
</li>
	<li>
`:not(em, #foo)^S
の詳細度は、どの要素に合致しようが，`~ID選択子$に対するときと同様に
( 1,0,0 ) になる。
◎
:not(em, #foo) has a specificity of (1,0,0)--like an ID selector--whenever it matches any element.
</li>
</ul>

</div>

<p>
詳細度の比較では、 3 成分が順に（~~辞書式に）比較される：
%A 値が大きい方の詳細度がより高く、
%A 値が等しければ %B 値が大きい方の詳細度がより高く、
%B 値も等しければ %C 値が大きい方の詳細度がより高く、
すべての値が等しければ 2 つの詳細度は等しい。
◎
Specificities are compared by comparing the three components in order: the specificity with a larger A value is more specific; if the two A values are tied, then the specificity with a larger B value is more specific; if the two B values are also tied, then the specificity with a larger C value is more specific; if all the values are tied, the two specificities are equal.
</p>

<p>
記憶域に限りがあるときは、実装は %A, %B, %C の大きさを制限を課してよい。
その場合、その制限-を超えた値は，その制限-内に切り詰められ~MUST。
◎
Due to storage limitations, implementations may have limitations on the size of A, B, or C. If so, values higher than the limit must be clamped to that limit, and not overflow.
</p>

<div class="example">
<p lang="en">Examples:</p>

<pre class="lang-css">
*               /* a=0 b=0 c=0 */
LI              /* a=0 b=0 c=1 */
UL LI           /* a=0 b=0 c=2 */
UL OL+LI        /* a=0 b=0 c=3 */
H1 + *[`REL^a=up]  /* a=0 b=1 c=1 */
UL OL LI.red    /* a=0 b=1 c=3 */
LI.red.level    /* a=0 b=2 c=1 */
#x34y           /* a=1 b=0 c=0 */
#s12:not(FOO)   /* a=1 b=0 c=1 */
.foo :matches(.bar, #baz)   /*
<span class="comment">
合致する要素に依存して， (a, b, c) =
(0, 2, 0) または (1, 1, 0)
のいずれかになる。
◎
Either a=1 b=1 c=0
or a=0 b=2 c=0, depending
on the element being matched.
</span> */
</pre>

</div>

<p class="note">注記：
同じ`単体~選択子$の繰り返しは許容され、詳細度を増大させる。
◎
Note: Repeated occurrences of the same simple selector are allowed and do increase specificity.
</p>

<p class="note">注記：
~HTML `style^a 属性にて指定される~styleの詳細度については、
`CSSSTYLEATTR$r の
<a href="~CSSSTYLEATTR#interpret">~CSS~style属性</a>
にて述べられている。
◎
Note: The specificity of the styles specified in an HTML style attribute is described in CSS Style Attributes. [CSSSTYLEATTR]
</p>

	</section>
	<section id="grammar">
<h2 title="Grammar">17. 文法</h2>

<a id="formal-syntax"></a>

<p>
選択子は、以下の文法に則って
<a href="~CSSSYN#css-parse-something-according-to-a-css-grammar">構文解析-</a>される：
◎
Selectors are parsed according to the following grammar:
</p>


<pre class="prod">
`selector-list@t
    = `complex-selector-list$t

`complex-selector-list@t
    = `complex-selector$t#

`compound-selector-list@t
    = `compound-selector$t#

`simple-selector-list@t
    = `simple-selector$t#

`relative-selector-list@t
    = `relative-selector$t#

`complex-selector@t
    = `compound-selector$t [ `combinator$t? `compound-selector$t ]*

`relative-selector@t
    = `combinator$t? `complex-selector$t

`combinator@t
    = '&gt;&gt;'
    | '&gt;'
    | '+'
    | '~'
    | [ '|' '|' ]

`compound-selector@t
    = `simple-selector$t+

`simple-selector@t
    = `type-selector$t
    | `id-selector$t
    | `class-selector$t
    | `attribute-selector$t
    | `pseudo-class-selector$t
    | `pseudo-element-selector$t

`type-selector@t
    = `wq-name$t
    | `ns-prefix$t? '*'

`ns-prefix@t
    = [ `ident-token$t? | '*' ]? '|'

`wq-name@t
    = `ns-prefix$t? `ident-token$t

`id-selector@t
    = `hash-token$t

`class-selector@t
    = '.' `ident-token$t

`attribute-selector@t
    = '[' `wq-name$t ']'
    | '['
          `wq-name$t `attr-matcher$t
          [ `string-token$t | `ident-token$t ]
          `attr-modifier$t?
      ']'

`attr-matcher@t
    = [ '~' | '|' | '^' | '$' | '*' ]? '='

`attr-modifier@t
    = i

`pseudo-class-selector@t
    = ':' `ident-token$t
    | ':' `function-token$t `any-value$t ')'

`pseudo-element-selector@t
    = ':' `pseudo-class-selector$t
</pre>

<p>
上の文法に加えて、次の規則も適用される：
◎
In addition to the above grammar, the following rules apply:
</p>

<ul>
	<li>
`compound-selector$t が包含できる `type-selector$t
は高々 1 個まであり、包含する場合は，その中で最初の `simple-selector$t で~MUST。
◎
A &lt;compound-selector&gt; can contain at most one &lt;type-selector&gt;, and if it does, that must be the first &lt;simple-selector&gt; in it.
</li>
	<li>
<p>
次に挙げる所には、空白は許容されない：
</p>
		<ul>
			<li>
`compound-selector$t を成す `simple-selector$t たちの合間。
</li>
			<li>
［
`type-selector$t, `class-selector$t, `wq-name$t, `ns-prefix$t
］どうしの合間。
</li>
			<li>
［
`pseudo-class-selector$t ／
`pseudo-element-selector$t
］の，先頭の~colon `003A^U と次の~tokenとの合間。
</li>
		</ul>
◎
A &lt;compound-selector&gt; does not allow any whitespace between its constituent &lt;simple-selector&gt;s.
◎
No whitespace is allowed between the constituents of a &lt;type-selector&gt;, &lt;class-selector&gt;, &lt;wq-name&gt;, or &lt;ns-prefix&gt;, or between the initial punctuation and second token of &lt;pseudo-class-selector&gt;s and &lt;pseudo-element-selector&gt;s.
</li>
	<li>
一部の旧 `疑似要素$（
`before$pe, `after$pe, `first-line$pe, `first-letter$pe
）は、旧来の理由から，先頭の~colonが 1 個だけの
`pseudo-class-selector$t 文法を利用して記せる。
◎
Some older pseudo-elements (::before, ::after, ::first-line, and ::first-letter) can, for legacy reasons, be written using the &lt;pseudo-class-selector&gt; grammar, with only a single ":" character at their start.
</li>
	<li>
`id-selector$t 内の `hash-token$t の値は、`識別子$で~MUST。
◎
In &lt;id-selector&gt;, the &lt;hash-token&gt;’s value must be an identifier.
</li>
</ul>

<p class="issue">
“疑似要素は、複体~選択子ごとに，その最後の合体~選択子として 1 個まで”
とする規則は、今や棄てられたものと見なしてよいだろうか？
実施においては、すべての実装は，少なくともある部分で この規則に違反している。
◎
Should I consider the "only one pseudo-element per complex selector, at the end of the last compound selector" rule now trashed? In practice, all implementations violate that rule to at least some extent.
</p>

<p class="note">注記：
上の文法は、 `complex-selector$t 内の 2 個の `compound-selector$t の合間の結合子は、省略可能と定めている。
その目的は、文法上に限られる
—
<a href="~CSSVAL#value-defs">~CSS値~定義~構文</a>による，空白の緩い扱いは、空白に <em>なれる</em>ような文法記号を指示し難くしている。
`結合子$の “省略” は、実際には，ちょうど`子孫~結合子$を指定することにあたる。
◎
Note: The grammar above states that a combinator is optional between two &lt;compound-selector&gt;s in a &lt;complex-selector&gt;. This is only for grammatical purposes, as the CSS Value Definition Syntax’s lax treatment of whitespace makes it difficult to indicate that a grammar term can be whitespace. "Omitting" a combinator is actually just specifying the descendant combinator.
</p>


	</section>
	<section id="api-hooks">
<h2 title="API Hooks">18. ~API~hook</h2>

<p>
この節では， Selectors の概念を利用する仕様の策定に便宜を図るため、他の仕様から呼び出せる，いくつかの~API~hookを定義する。
◎
To aid in the writing of specs that use Selectors concepts, this section defines several API hooks that can be invoked by other specifications.
</p>

		<section id="parse-a-selector">
<h3 title="Parse A Selector">18.1. 選択子の構文解析-法</h3>

<p class="algo-head">
`選択子として構文解析-@
するときは、所与の文字列 %~source に対し，［
`複体~選択子$の~list, または `失敗^i
］を返す：
◎
This section defines how to parse a selector from a string source. It returns either a complex selector list, or failure.
</p>

<ol>
	<li>
%選択子 ~LET %~source を `selector-list$t として構文解析した結果
⇒
~IF［
%~source は この文法に合致していない
］
⇒
~RET `失敗^i
◎
Let selector be the result of parsing source as a &lt;selector-list&gt;. If it does not match the grammar, return failure.
</li>
	<li>
~IF［
%選択子 内に~UAが認識できない単体~選択子がある
］~OR［
%選択子 は何らかの仕方で妥当でない（例えば，`未宣言$の名前空間 接頭辞が含まれている）
］
⇒
~RET `失敗^i
◎
Otherwise, if any simple selectors in selector are not recognized by the user agent, or selector is otherwise invalid in some way (such as, for example, containing an undeclared namespace prefix), return failure.
</li>
	<li>
~RET %選択子
◎
Otherwise, return selector.
</li>
</ol>


		</section>
		<section id="parse-relative-selector">
<h3 title="Parse A Relative Selector">18.2. 相対~選択子の構文解析-法</h3>

<p class="algo-head">
`相対~選択子として構文解析-@
するときは、所与の
( 文字列 %~source, `~scope_ps要素$ %refs )
に対し，［
`複体~選択子$の~list, または `失敗^i
］を返す。
◎
This section defines how to parse a relative selector from a string source, against :scope elements refs. It returns either a complex selector list, or failure.
</p>

<ol>
	<li>
%選択子 ~LET %~source を `relative-selector-list$t として構文解析した結果
⇒
~IF［
%~source は この文法に合致していない
］
⇒
~RET `失敗^i
◎
Let selector be the result of parsing source as a &lt;relative-selector-list&gt;. If it does not match the grammar, return failure.
</li>
	<li>
~IF［
%選択子 内に~UAが認識できない単体~選択子がある
］~OR［
%選択子 は何らかの仕方で妥当でない（例えば，`未宣言$の名前空間 接頭辞が含まれている）
］
⇒
~RET `失敗^i
◎
Otherwise, if any simple selectors in selector are not recognized by the user agent, or selector is otherwise invalid in some way (such as, for example, containing an undeclared namespace prefix), return failure.
</li>
	<li>
~RET %refs を`~scope_ps要素$に用いて， %選択子 を`絶対化$した結果
◎
Otherwise, absolutize selector with refs as the :scope elements.
◎
Return selector.
</li>
</ol>

		</section>
		<section id="match-against-element">
<h3 title="Match a Selector Against an Element">18.3. 要素に対し選択子を照合する</h3>

<p class="algo-head">
`要素に対し選択子を照合-@
するときは、所与の：
◎
This section defines how to match a selector against an element.
</p>

<ul>
	<li>
%選択子
— `選択子~list$
◎
APIs using this algorithm must provide a selector and＼
</li>
	<li>
%要素
◎
an element.
</li>
	<li>
<p>
`scope$ps 疑似類を解決するための， `~scope_ps要素$の集合（省略時は空~集合）
◎
Callers may optionally provide:
◎
a set of :scope elements, for resolving the :scope pseudo-class against. If not specified, the set defaults to being empty.
</p>

<p class="issue">
`scope$ps の定義に合致するよう，省略時の既定は 根~要素にするべきか？
◎
Should it instead default to the root element, to match the definition of :scope?
</p>

<p>
%選択子 が`相対~選択子$である場合、この集合は，空であっては~MUST_NOT。
◎
If the selector is a relative selector, the set of :scope elements must not be empty.
</p>

<p class="trans-note">【
原文の~algoには、この`~scope_ps要素$の集合がどう適用されるか，（明示的には）何も述べられていない。
（暗黙的に）`~scope_ps要素$の規則に従うと見られるが。
以下の各~節の~algoも同様。
】</p>

	</li>
</ul>

<p>
に対し， `成功^i または `失敗^i を返す：
◎
This algorithm returns either success or failure.
</p>

<ol>
	<li>
%選択子 内の ~EACH( `複体~選択子$ %複体 ) に対し
⇒
~IF［
( %複体, %要素 )
を与える下で，`要素に対し複体~選択子を照合-$した結果 ~EQ `成功^i
］
⇒
~RET `成功^i
◎
For each complex selector in the given selector (which is taken to be a list of complex selectors), match the complex selector against element, as described in the following paragraph. If the matching returns success for any complex selector, then the algorithm return success; otherwise it returns failure.
</li>
	<li>
~RET `失敗^i
</li>
</ol>

<p class="algo-head">
`要素に対し複体~選択子を照合-@
するときは、所与の
( `複体~選択子$ %複体, %要素 )
に対し，次を走らせた結果を返す：
◎
To match a complex selector against an element, process it compound selector at a time, in right-to-left order. This process is defined recursively as follows:
</p>

<ol>
	<li>
%複体 の末尾の（最も右の）`合体~選択子$ 内の ~EACH( `単体~選択子$ %単体 ) に対し
⇒
~IF［
%単体 は %要素 に合致しない
］
⇒
~RET  `失敗^i
◎
If any simple selectors in the rightmost compound selector does not match the element, return failure.
</li>
	<li>
~IF［
%複体 は 1 個の`合体~選択子$のみからなる
］
⇒
~RET `成功^i
◎
Otherwise, if there is only one compound selector in the complex selector, return success.
</li>
	<li>
<p>
%要素たち ~LET %複体 内の最後の`結合子$により %要素 に関係し得るような，可能なすべての要素からなる集合
</p>

<p class="trans-note">【
例えば`子孫~結合子$の場合、 %要素 の先祖すべてからなる集合になるであろう。
】</p>
◎
Otherwise, consider all possible elements that could be related to this element by the rightmost combinator.＼
</li>
	<li>
%複体 ~SET %複体 から［
末尾の`合体~選択子$, 最後の`結合子$
］を除去した結果の`複体~選択子$
◎
If the operation of matching the selector consisting of this selector with the rightmost compound selector and rightmost combinator removed＼
</li>
	<li>
%要素たち 内の~EACH( %E ) に対し
⇒
~IF［
( %複体, %E )
を与える下で，`要素に対し複体~選択子を照合-$した結果 ~EQ `成功^i
］
⇒
~RET `成功^i
◎
against any one of these elements returns success, then return success. Otherwise, return failure.
</li>
	<li>
~RET  `失敗^i
</li>
</ol>


		</section>
		<section id="match-against-pseudo-element">
<h3 title="Match a Selector Against a Pseudo-element">18.4. 疑似要素に対し選択子を照合する</h3>

<p class="algo-head">
`疑似要素に対し選択子を照合-@
するときは、所与の：
◎
This section defines how to match a selector against a pseudo-element.
</p>

<ul>
	<li>
%選択子
— `選択子~list$
◎
APIs using this algorithm must provide a selector and＼
</li>
	<li>
%疑似要素
— `疑似要素$
◎
a pseudo-element.＼
</li>
	<li>
%他の引数たち （省略可）
— `要素に対し選択子を照合-$する~algoに述べたものと同じ引数
◎
They may optionally provide the same things they may optionally provide to the algorithm to match a selector against an element.
</li>
</ul>

<p>
に対し， `成功^i または `失敗^i を返す：
◎
This algorithm returns success or failure.
</p>

<ol>
	<li>
<p>
%選択子 内の~EACH( `複体~選択子$ %複体 ) に対し：
◎
For each complex selector in the given selector, if both:
</p>

		<ol>
			<li>
~IF［
%複体 の末尾の`単体~選択子$は %疑似要素 に合致しない
］
⇒
~CONTINUE
◎
the rightmost simple selector in the complex selector matches pseudo-element, and
</li>
			<li>
%複体 ~SET %複体 から末尾の`単体~選択子$を除去した結果
</li>
			<li>
~IF［
( %複体, %疑似要素 の`出自の要素$, %他の引数たち )
を与える下で，`要素に対し複体~選択子を照合-$した結果 ~EQ  `成功^i
］
⇒
~RET `成功^i
◎
the result of running match a complex selector against an element on the remainder of the complex selector (with just the rightmost simple selector of its rightmost complex selector removed), pseudo-element’s corresponding element, and any optional parameters provided to this algorithm returns success,
◎
then return success.
</li>
		</ol>
	</li>
	<li>
~RET  `失敗^i 
◎
Otherwise (that is, if this doesn’t happen for any of the complex selectors in selector), return failure.
</li>
</ol>

		</section>
		<section id="match-against-tree">
<h3 title="Match a Selector Against a Tree">18.5. 木に対し選択子を照合する</h3>

<p class="algo-head">
`木に対し選択子を照合-@
するときは、所与の：
◎
This section defines how to match a selector against a tree.
◎
APIs using this algorithm must provide＼
</p>

<ul>
	<li>
%選択子
— `選択子~list$
◎
a selector, and＼
</li>
	<li>
%根~要素たち
— %選択子 を照合する対象とされる， 1 個~以上の`木$【部分木】の根~要素からなる集合。
%根~要素たち 内のすべての要素の`根$は，同じで~MUST。
◎
one or more root elements indicating the trees that will be searched by the selector. All of the root elements must share the same root, or else calling this algorithm is invalid.
◎
They may optionally provide:
</li>
	<li>
<p>
%視野根 （省略時は ε ）
— %選択子 は視野付きであることを指示する`視野根$。
省略時には、視野は絞られないことになる。
◎
A scoping root indicating the selector is scoped. If not specified, the selector defaults to being unscoped.
</p>

<p class="issue">
これは今や %根~要素たち と~~重なって冗長である。
◎
This is now redundant with the root elements.
</p>
	</li>
	<li>
<p>
`scope$ps 疑似類に合致するものとされる`~scope_ps要素$の集合。
省略時の既定は、［
%選択子 が`視野付き選択子$であるならば `視野根$ ／
他の場合は %根~要素たち
］。
◎
A set of :scope elements, which will match the :scope pseudo-class. If not specified, then if the selector is a scoped selector, the set of :scope elements default to the scoping root; otherwise, it defaults to the root elements.
</p>

<p class="note">注記：
%選択子 が`視野付き$の場合、視野根は自動的に`~scope_ps要素$とされるので、異なる結果が欲されない限り，明示的に供される必要はない。
◎
Note: Note that if the selector is scoped, the scoping root is automatically taken as the :scope element, so it doesn’t have to be provided explicitly unless a different result is desired.
</p>
	</li>
	<li>
<p>
合致し得る`疑似要素$の種類（省略時は、すべての疑似要素）。
◎
Which pseudo-elements are allowed to show up in the match list. If not specified, this defaults to allowing all pseudo-elements.
</p>

<p class="issue">
本当に この様に取扱われる疑似要素は
`before$pe, `after$pe
に限られる。<!-- ＊ -->
◎
Only the ::before and ::after pseudo-elements are really handled in any way remotely like this.
</p>
	</li>
</ul>

<p>
要素たちからなる~listを返す（空にもなり得る）：
◎
This algorithm returns a (possibly empty) list of elements.
</p>

<ol>
	<li>
%候補~要素たち ~LET %根~要素たち とそれらの子孫~要素すべてからなる，`~shadowも含む木~順序$による~list
— 他が指定されない限り。
◎
Start with a list of candidate elements, which are the the root elements and all of their descendant elements, sorted in shadow-including tree order, unless otherwise specified.
</li>
	<li>
~IF［
%視野根 ~NEQ ε
］
⇒
%候補~要素たち から %視野根 の`子孫$でない要素すべてを除去する
◎
If an optional scoping root was provided, then remove from the candidate elements any elements that are not descendants of the scoping root.
</li>
	<li>
%結果~list ~LET 空~list
◎
Initialize the selector match list to empty.
</li>

	<li>
<p>
%候補~要素たち 内の~EACH( %要素 ) に対し：
◎
For each element in the set of candidate elements:
</p>
		<ol>
			<li>
( %要素, %選択子 )
を与える下で，`要素に対し選択子を照合-$した結果 ~EQ `成功^i 
⇒
%結果~list に %要素 を追加する
◎
If the result of match a selector against an element for element and selector is success, add element to the selector match list.
</li>
			<li>
<p>
%要素 を`出自の要素$とする疑似要素のうち，合致し得るとされる ~EACH( %疑似要素 ) に対し
⇒
~IF［
( %疑似要素, %選択子 )
を与える下で，`疑似要素に対し選択子を照合-$した結果 ~EQ `成功^i
］
⇒
%結果~list に %疑似要素 を追加する
◎
For each possible pseudo-element associated with element that is one of the pseudo-elements allowed to show up in the match list, if the result of match a selector against a pseudo-element for the pseudo-element and selector is success, add the pseudo-element to the selector match list.
</p>

<p class="issue">
%結果~list における，疑似要素と他の要素との順序が定義されていない。
今の所，この情報を公開する文脈はないが、最終的には，何かが公開される前に決めておく必要がある。
◎
The relative position of pseudo-elements in selector match list is undefined. There’s not yet a context that exposes this information, but we need to decide on something eventually, before something is exposed.
</p>
			</li>
		</ol>
	</li>
</ol>

		</section>
	</section>
	<section id="dom-mapping">
<h2 title="Appendix A: Guidance on Mapping Source Documents &amp; Data to an Element Tree">19. ~source文書~dataから要素~木へ対応付けるための手引き</h2>

~INFORMATIVE

<p>
~DOMが述べる要素の木~構造は強力かつ有用である一方で、木~構造に基づく~dataを記述する，どの言語を~model化するにも（あるいは~graph構造に基づくものでも，相応しい解釈の下で）十分に汎用的である。
◎
The element tree structure described by the DOM is powerful and useful, but generic enough to model pretty much any language that describes tree-based data (or even graph-based, with a suitable interpretation).
</p>

<p>
~HTMLの様な一部の言語は、資源から~DOM~objを生産するための well-defined な手順をすでに備えている。
Selectors をそうでない言語による文書に適用するためには、その種の手順が，その言語に定義され~MUST。
◎
Some languages, like HTML, already have well-defined procedures for producing a DOM object from a resource. If a given language does not, such a procedure must be defined in order for Selectors to apply to documents in that language.
</p>

<p>
文書~言語は、最低限，何が~DOMの “要素” の概念に対応するかを定義し~MUST。
◎
At minimum, the document language must define what maps to the DOM concept of an "element".
</p>

<p>
首な，~node間の一対多の関係性
— 木~構造における親から子への,
あるいは ~graph構造における~nodeからその近隣への
関係性 —
が、要素の子~nodeとして反映されるべきである。
◎
The primary one-to-many relationship between nodes—parent/child in tree-based structures, element/neighbors in graph-based structures—should be reflected as the child nodes of an element.
</p>

<p>
可能なら、要素の他の特能（ feature ）も，
<a href="#data-model">~DOMにおける同じ特能</a>
に似た役割を担う何かに対応付けるべきである：
◎
Other features of the element should be mapped to something that serves a similar purpose to the same feature in DOM:
</p>

<dl>
	<dt>型◎type</dt>
	<dd>
<p>
文書~言語が、その要素たちを異なる要素~groupに判別し得るような~~基本的な~~概念（ notion ）として，何らかの “型” を備えているならば、それが， “型” 特能として反映されるべきである。
◎
If the elements in the document language have some notion of "type" as a basic distinguisher between different groups of elements, it should be reflected as the "type" feature.
</p>

<p>
この “型” を， “~~基本的な” 名前と, それらの名前をより高次の “名前空間” ~groupに分離し得るならば、後者は “名前空間” 特能として反映されるべきである。
他の場合、要素は “名前空間” 特能を持つべきでなく，名前~全体が “型” 特能として反映されるべきである。
◎
If this "type" can be separated into a "basic" name and a "namespace" that groups names into higher-level groups, the latter should be reflected as the "namespace" feature. Otherwise, the element shouldn’t have a "namespace" feature, and the entire name should be reflected as the "type" feature.
</p>

	<dt>~ID◎id</dt>
	<dd>
<p>
要素の何らかの側面が，文書~全体に渡り一意な識別子として~~機能する場合、それが， “~ID”  特能に対応付けられべきである。
◎
If some aspect of the element functions as a unique identifier across the document, it should be mapped to the "id" feature.
</p>

<p class="note">注記：
~HTMLにおいては、要素が持ち得る~IDは 1 個に限られているが，一般にはそのように制約されるべきではない。
~IDの重要な性質は、各~IDが単独の要素に結付けられることであり、単独の要素は，複数の~IDを妥当に持ち得る。
◎
Note: While HTML only allows an element to have a single ID, this should not be taken as a general restriction. The important quality of an ID is that each ID should be associated with a single element; a single element can validly have multiple IDs.
</p>

	<dt>~classと属性◎classes and attributes</dt>
	<dd>
要素を識別するときに有用になる側面ではあるが，一般に，文書の中の一意な要素にはならないものは、［
“~label” （それ自体が文字列になるもの）／
“~prop” （名前と値の対）
］のいずれに等価になるかに依存して，［
“~class” ／ “属性”
］特能に対応付けられるべきである。
◎
Aspects of the element that are useful for identifying the element, but are not generally unique to elements within a document, should be mapped to the "class" or "attribute" features depending on if they’re something equivalent to a "label" (a string by itself) or a "property" (a name/value pair)
</dd>

	<dt>疑似類と疑似要素◎pseudo-classes and pseudo-attributes<!-- ＊誤記 --></dt>
	<dd>
疑似類に合致する, あるいは 疑似要素を持つような要素は、明示的に定義され~MUST。
◎
If any elements match any pseudo-classes or have any pseudo-elements, that must be explicitly defined.
</dd>
	<dd class="issue">
`has()$ps や `matches()$ps の様に，一部の疑似類は <em >構文論的</em> なので、常に働くべきであり、それについて どこかで指示される必要がある。
構造上の疑似類は、子~listが順序を有するならば，常に働くであろう。
◎
Some pseudo-classes are *syntactical*, like :has() and :matches(), and thus should always work. Need to indicate that somewhere. Probably the structural pseudos always work whenever the child list is ordered.
</dd>
</dl>

<div class="example">
<p>
例えば、
<a href="https://github.com/lloyd/JSONSelect">JSONSelect</a>
は， JSON 文書から情報を抽出するために選択子を利用する~libraryである。
◎
For example, JSONSelect is a library that uses selectors to extract information from JSON documents.
</p>

<ul>
	<li>
JSON 文書の各［
array, object, boolean, string, number, null
］が，木~構造を成す “要素” になる。
array ／ object 要素は，その内容を子として持つ。
◎
The "elements" of the JSON document are each array, object, boolean, string, number, or null. The array and object elements have their contents as children.
</li>
	<li>
各~要素の型はその JS 型~名：
"array", "object", 等々になる。
◎
Each element’s type is its JS type name: "array", "object", etc.
</li>
	<li>
object の子は、その key を~classとして持つ。
◎
Children of an object have their key as a class.
</li>
	<li>
array の子は
`first-child$ps, `nth-child()$ps,
等々の疑似類に合致する。
◎
Children of an array match the :first-child, :nth-child(), etc pseudo-classes.
</li>
	<li>
根 object は `root$ps に合致する。
◎
The root object matches :root.
</li>
	<li>
特定0の［
値をとる, あるいは 部分文字列を包含する
］ような
boolean／number／string
要素に合致させるための
`val()^ps,
`contains()^ps
疑似類も追加で定義する。
◎
It additionally defines :val() and :contains() pseudo-classes, for matching boolean/number/string elements with a particular value or which contain a particular substring.
</li>
</ul>

<p>
この構造は、選択子による，JSON 文書に対する強力で簡潔な~query法を与えるに足るものになる。
◎
This structure is sufficient to allow powerful, compact querying of JSON documents with selectors.
</p>
</div>

	</section>
	<section id="changes">
<h2 title="Changes">20. 変更点</h2>

<p>
<a href="https://www.w3.org/TR/2013/WD-selectors4-20130502/">2 May 2013 Working Draft</a>
からの有意な変更点は：
◎
Significant changes since the 2 May 2013 Working Draft include:
</p>

<ul>
	<li>
`視野付き選択子$から`相対~選択子$を~~分離した。
これらは独立に呼び出され得る，異なる概念なので。
◎
Split out relative selectors from scoped selectors, as these are different concepts that can be independently invoked.
</li>
	<li>
<p>
相対~選択子を絶対化するための規則を変更した。
◎
Changed rules for absolutizing a relative selector.
</p>

<p class="issue">
List changes + rationale?
</p>
	</li>
	<li>
対象指示子（ subject indicator ）の特色機能を
`has()$ps
に置換した。
◎
Replaced subject indicator feature with :has().
</li>
	<li>
`active-drop-target^ps,
`valid-drop-target^ps,
`invalid-drop-target^ps
を `drop()$ps に変更した。
◎
Changed the :active-drop-target, :valid-drop-target, :invalid-drop-target with :drop().
</li>
	<li>
<p>
<a href="~CSSSYN#anb-production">~AnB</a>
小構文の定義を CSS Syntax 仕様に移動した。
◎
Moved definition of &lt;An+B&gt; microsyntax to CSS Syntax.
</p>
<p class="issue">
意味論的な定義については，おそらく ここに戻されるべきである。
◎
Semantic definition should probably move back here.
</p>
	</li>
	<li>
<p>
次の新たな節を追加した：
◎
Added new sections:
</p>

		<ul>
			<li>
<p>
`~data~model§ 節。
◎
§3.2 Data Model
</p>

<p class="issue">
~XMLに対する木を定義する必要がある。
◎
Need to define tree for XML.
</p>
			</li>
			<li>
<p>
`~API~hook§ 節。
◎
§18 API Hooks
</p>

<p class="issue">
この仕様の以前の~versionは、
<a id="evaluate-a-selector"></a>
<a id="evaluating-selectors">選択子の評価-法</a>
節を定義していたが、その節はもう無い。
その節を参照している仕様は、`木に対し選択子を照合-$する~algoを参照するべきである。
◎
Note that earlier versions of this section defined a section on evaluating a selector, but that section is no longer present. Specifications referencing that section should instead reference the algorithm to match a selector against a tree. 
</p>
			</li>
		</ul>
	</li>
	<li>
<p>
`matches()$ps,
`not()$ps,
`nth-match()^ps,
`nth-last-match()^ps
の中の結合子に対する制約を除去した。
◎
Removed restriction on combinators within :matches(), :not(), :nth-match(), and :nth-last-match().
</p>
<p class="issue">
これの実装はあるのか？
そうでないなら、~level 4 に対しては，この制約は保ったほうが良いかも？
◎
Do we have implementations of this? If not, maybe it’s better to keep the restriction for level 4?
</p>
	</li>
	<li>
`選択子~list$の`詳細度$を定義した。
(Why?)
◎
Defined specificity of a selector list. (Why?)
</li>
	<li>
関心が欠如しているので、
`local-link^ps, および
参照~結合子は除去した。
◎
Removed the :local-link and reference combinator for lack of interest.
</li>
</ul>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgements">21. 謝辞</h2>

<p>
CSS working group は、この仕様の基礎を成している仕様も含め，年月に渡り
<a href="https://www.w3.org/TR/css3-selectors">以前の Selectors 仕様</a>
に協力されてきたすべての方々に感謝する。
更に、 Selectors Level 4 に特に協力された次の方々に，特別な謝意を：
</p>

<p lang="en-x-a0">
The CSS working group would like to thank everyone who contributed to the previous Selectors specifications over the years, as those specifications formed the basis for this one. In particular, the working group would like to extend special thanks to the following for their specific contributions to Selectors Level 4: L. David Baron, Andrew Fedoniouk, Ian Hickson, Grey Hodge, Lachlan Hunt, Jason Cranford Teague
</p>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">22. ~privacy／~security上の考慮点</h2>

<p>
選択子は，~DOMを手動で辿ることですでに可能である能を超えるものは提供しないので、この仕様は、新たな
~privacy／~security
上の考慮点を導入するものではない。
◎
This specification introduces no new privacy or security considerations,
as selectors do not provide any ability not already possible by walking the DOM manually.
</p>

	</section>

</main></div><!-- MAIN -->

	<section id="conformance">
<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この節（およびその下位節）の内容は
<a href="css-common-ja.html#conformance">CSS 日本語訳 共通ページ</a>
に委譲
】</p>


<!--
<h2 id="Tests">Tests</h2>

<p>This specification has <a
href="http://www.w3.org/Style/CSS/Test/CSS3/Selectors/current/">a test
suite</a> allowing user agents to verify their basic conformance to
the specification. This test suite does not pretend to be exhaustive
and does not cover all possible combined cases of Selectors.
-->


	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>

<script type="text/plain" class="ref_data">
[CSS-DISPLAY-3]
    Elika Etemad. CSS Display Module Level 3. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. URL: https://www.w3.org/TR/css-pseudo-4/ 
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. CSS Scoping Module Level 1. URL: https://www.w3.org/TR/css-scoping-1/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-WRITING-MODES-3]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 3. URL: https://www.w3.org/TR/css-writing-modes-3/ 
[CSS21]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2 
[CSS3NAMESPACE]
    Elika Etemad. CSS Namespaces Module Level 3. URL: https://www.w3.org/TR/css-namespaces-3/ 
[CSS3SYN]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS3TEXT]
    Elika Etemad; Koji Ishii. CSS Text Module Level 3. URL: https://www.w3.org/TR/css-text-3/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECT]
    Tantek Çelik; et al. Selectors Level 3. 29 September 2011. REC. URL: https://www.w3.org/TR/css3-selectors/ 
[SVG2]
    Nikos Andronikos; et al. Scalable Vector Graphics (SVG) 2. URL: https://www.w3.org/TR/SVG2/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
</script>


		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<script type="text/plain" class="ref_data">
[BCP47]
    A. Phillips; M. Davis. Tags for Identifying Languages. September 2009. IETF Best Current Practice. URL: https://tools.ietf.org/html/bcp47 
[CSS22]
    Bert Bos. Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification. URL: https://www.w3.org/TR/CSS22/ 
[CSS3UI]
    Tantek Çelik; Florian Rivoal. CSS Basic User Interface Module Level 3 (CSS3 UI). URL: https://www.w3.org/TR/css-ui-3/ 
[CSSSTYLEATTR]
    Tantek Çelik; Elika Etemad. CSS Style Attributes. URL: https://www.w3.org/TR/css-style-attr 
[HTML401]
    Dave Raggett; Arnaud Le Hors; Ian Jacobs. HTML 4.01 Specification. 24 December 1999. REC. URL: https://www.w3.org/TR/html401 
[HTML5]
    Ian Hickson; et al. HTML5. URL: https://www.w3.org/TR/html5/ 
[MATHML]
    Patrick D F Ion; Robert R Miner. Mathematical Markup Language (MathML) 1.01 Specification. 7 July 1999. REC. URL: https://www.w3.org/TR/MathML/ 
[RFC4647]
    A. Phillips; M. Davis. Matching of Language Tags. September 2006. Best Current Practice. URL: https://tools.ietf.org/html/rfc4647 
[SVG11]
    Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/ 
[XFORMS11]
    John Boyer. XForms 1.1. 20 October 2009. REC. URL: https://www.w3.org/TR/xforms11/ 
[XML-NAMES]
    Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names 
[XML10]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml 
</script>




		</section>
	</section>
	<section id="index">
<h2 title="Index">索引</h2>

<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>
	</section>
	<section id="property-index">
<h2 title="Property index">プロパティ索引</h2>

<p>
この仕様に定義されているプロパティは無い。
</p>

	</section>
	<section id="issues-index">
<h2 title="Issues Index" data-cycling=".issue">課題 索引</h2>

<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>

	</section>
