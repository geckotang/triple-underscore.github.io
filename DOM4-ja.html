<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>DOM Standard 日本語訳</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<!--%内容置換生成 -->
<script >

var source_data;

COMMON_DATA.init = function(expanded){

	var options = {
		spec_status: 'LS',
		original_url: 'https://dom.spec.whatwg.org/',
		main: 'MAIN',
		fill_text_link: '#references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};

	if(expanded) return options;


	var ifc_names = E('_ifc_names').firstChild.data
	.replace(/^\w+$/mg, function(name){
		return name + ':#' + name.toLowerCase();
	});

	source_data = {
		html    : E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map1'),
		ifc_names: Util.get_mapping(ifc_names),
		levels: 'ほぼ英語:英語主体:漢字＋英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

/*
	repeat('dl.idl-def > dt', function(e){
		e.parentNode.replaceChild(C('p'), e)
	});
	Util.del_j(); // checked: 160420 spec
*/

	return options;
}

function expand(mapping1){
	E('MAIN').innerHTML = Util.replaceWords1(create_html(this), mapping1);

// 要素複製 ( Opera requires optional args, null, null)
	var visited = Object.create(null), node, e;
	var it = document.createNodeIterator(E('MAIN'), NodeFilter.SHOW_COMMENT, null, null);
	while(node = it.nextNode()){
		var id = node.data;
		if(id.slice(0,3) !== 'cp-') continue;
		e = visited[id];
		if(!e) {
			e = E(id);
			if(e) {
				e.removeAttribute('id');
				visited[id] = e;
			} else {
				console.log('source undefined:' + id);
				continue;
			}
		}
		node.parentNode.replaceChild(e.cloneNode(true), node);
	}

// 目次構築
	Util.rebuildToc('MAIN');
}

function create_html(source_data){
	var link_map = source_data.link_map;
	var ifc_names = source_data.ifc_names;

	var in_idl = false;
	var nesting = ''
	, context_ifc = '';// prefix 省略時の既定 interface 名
	return source_data.html.replace(
		/⇒！?|◎[^<◎]*|%[\u4E00-\u9FFF~\w\-]+|([\^@$]@?)([\w\.]+)(\([ \w,\[\]=…]*\))?|`(.+?)([\^@$])(\w*)/g,
		replacer
	);

	function bpGenerate(str){
		return '<div class="bp-example">'
		+ str.replace(/([\|\[\]\(\)])(\w?)/g, function(match, t, w){
			switch(t) {
			case '|':
				return w ? '<span class="m">|<br>' + w + '</span>' : '|';
			case '(':
				return w ? '<i class="' + w + '">' : '<i>';
			case '[':
				return w ? '<b class="' + w + '">' : '<b>';
			case ')':
				return '</i>';
			case ']':
				return '</b>';
			}
		})
		+ '</div>';
	}

	function replacer(match, ind0, key, args, text, ind2, suffix){
		if(text){
			var href;
			var key = text;
			suffix = suffix || '';
			switch(suffix){
			case 'r':
				return (
'<a href="#biblio-' + text.toLowerCase() + '">[' +  text  + ']</a>'
				);
				break;
			case 'b': // 
				return '<b>' + text + '</b>';
				break;
			case 'i': // 
				text = '<i class="i">' + text + '</i>';
				break;
			case 'l': // literal
				text = '"<code class="literal">' + text + '</code>"';
				break;
			case 'E':
				text = '<code class="error">' + text + '</code>';
				break;
			case 'e': // element tag
				text = '<code class="element">' + text + '</code>';
				break;
			case 'A': // attr name
				text = '<code class="attr">' + text + '</code>';
				break;
			case 'et': // event type
				text = '<code class="event-type">' + text + '</code>';
				break;
			case 'prod': // 生成規則
				text = '<code class="production">' + text + '</code>';
				break;
			case 'c': // codes
				text = '<code>' + text + '</code>';
				break;
			case 'V': // var
				text = '<var>' + text + '</var>';
				break;
			case 'f': // flags
				text = '<i class="flag">' + text + '~flag</i>';
				break;
			case 'bpex':
				return bpGenerate(text);
				break;
			case 'cite':
				return '<cite>' + text + '</cite>';
				break;
			default:
				break;
			}
			if(ind2 === '^'){
				return text;
			}
			href = link_map[suffix ? key + '.' + suffix : key];
			if(!href){
				console.log(text);
				return match;
			}
			switch(ind2){
			case '$': 
				return '<a href="' + href + '">' + text + '</a>';
			case '@':
				return '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
			}
			return match;
		} else if(key){
			// idl contructs
			var text = key, href;
			if(!args && ( key in ifc_names ) ){
				href = ifc_names[key];
				if(ind0.length > 1){
//				if(ind0.charAt(1) === '@'){
					context_ifc = key;//.toLowerCase();
				}
			} else {
				var ifc = context_ifc;
				var dot = key.indexOf('.');
				if(dot >=0 ){
					ifc = key.slice(0, dot);
					key = text = key.slice(dot + 1); //text
				}
				href = (
					'#dom-' + ifc + '-' + (
						(key === 'Constructor') ? ifc : key
					)
				).toLowerCase();
				if(args){
text += args.replace(/(\w+)(\s=\s\w+)?/g, '<var>$1</var>$2');
				}
				
			}
			if(!in_idl){
				text = '<code>' + text + '</code>';
			}

			switch(ind0.charAt(0)){
			case '^':
				return text;
			case '$':
				return '<a href="' + href + '" >' + text + '</a>';
			case '@':
				return '<dfn id="' + href.slice(1) + '" >' + text + '</dfn>';
			}
		} else {
			if(match.charAt(0) === '%'){
				return '<var>' + match.slice(1) + '</var>';
			}
			switch(match){
			case '⇒':
				nesting += '</span>';
				return '：<span class="block">';
			case '⇒！':
				in_idl = true;
				nesting += '</pre>';
				return '<pre class="idl">';
			}//◎
			if(in_idl) {
				result = nesting;
				in_idl = false;
			} else {
				result =
					nesting
					+ '<span lang="en">'
					+ match.slice(1).trim()
					+ '</span>';
			}
			nesting = '';
			return result;
		}
	}
}
</script>


<!--%置換データ -->
<script type="text/plain" id="words_table1">
	a:
	b:
	c:
AN:<a class="op" href="#concept-tree-ancestor">⊃</a>
DE:<a class="op" href="#concept-tree-descendant">⊂</a>
iAN:<a class="op" href="#concept-tree-inclusive-ancestor">⊇</a>
iDE:<a class="op" href="#concept-tree-inclusive-descendant">⊆</a>

US:unsigned short
B:boolean
CUS:const unsigned short
CUL:const unsigned long
UL:unsigned long
DS:DOMString
RA:readonly attribute

COLOR_R:<span style="color:red;">赤色区間</span>
COLOR_X:<span style="color:#0C0;">緑色区間</span>
COLOR_Y:<span style="color:blue;">青色区間</span>

SHADOW:https://w3c.github.io/webcomponents/spec/shadow/
SW:https://slightlyoff.github.io/ServiceWorker/spec/service_worker/
TOUCHEVENTS:touch-events-ja.html
	https://www.w3.org/TR/touch-events/#touchevent-interface
WEBSTORAGE:WebStorage-ja.html
	~HTML5/webstorage.html

Text0: <code>Text</code> 
scope-ps: <code class="css">:scope</code> 
SPECBUGS:https://www.w3.org/Bugs/Public/show_bug.cgi
	https://html.spec.whatwg.org/multipage/scripting.html
is0:<code class="attr">is</code> 
</script>


<!--%語彙置換データ -->
<script type="text/plain" id="words_table">
HTML:
SVG:
XML:
XMLNS:
ID:
DOM:
	●node tree
木:tree::~:ツリー
部分木:subtree::~:部分ツリー:サブツリー
node::::ノード
shadow:
light:
closed-shadow-hidden:
root:
深優先前順走査:preorder, depth-first traversal:深さ優先かつ前順による走査
根:root::~::ルート
先祖:ancestor::~
子孫:descendant::~
	広義:inclusive::~
広義先祖:inclusive ancestor::~
広義子孫:inclusive descendant::~
親:parent::~
子:child::~
同胞:sibling::~
広義同胞:inclusive sibling::~

最初0:最初?
最後0:最後?
	最初0の:first?:最初の?
	最後0の:last?最後の?

兄:前?の sibling::前?の同胞
弟:次?の sibling::次?の同胞

基準:reference:~
	ref:reference:基準
	基準子:reference child:基準-child:基準-子


文書:document::~
文書順:document order::~
文書片:document fragment::~::文書フラグメント
文書URL:URL
断片:fragment::文書片::フラグメント
文書型:doctype::~
要素:element::~
属性0:attribute°::属性°

片:fragment:~:::フラグメント
指数:index::~::インデックス
接続-:connect:~
	~~孤立する:alone

	●動詞
走らす:run する:走らせる
走らせ:run し:~
走らさ:run さ:走らさ
	走り:run し:~
	走り終えた
	実行-:execute:~

先行-:precede::~
後続-:follow::~
関与-:participate:~
	のpartを成す／関与する
受入-:adopt::~
受入:adoption::~
	受入れる／取り込む

前挿入:pre-insert:~
挿入-:insert:挿入
挿入:insertion:挿入
前除去-:pre-remove:~
前除去ing:pre-removing:前除去
除去-:remove:~
除去:removal:~
除去ing:removing:除去
除去済み:removed:~
被除去:remove される:~
	toBeRemovedNode
置換-:replace:~
付加-:append:~
設定-:set:~
未設定に:unset:~
取得-:get:~
変更-:change:~
変更:change:~
変化:change:~
改変-:modify:~
移動-:move:~
追加-:add:追加
	追加:addition:~
反映-:reflect:~
検証-:validate:~
無効化-:invalidate:~
検証:validation:~
妥当:valid:~
抽出-:extract:~
選択-:select:~
選択:selecting:~

連結-:concatenate:~
登録-:register:~
複製:copy::~
符号化方式:encoding:~:::エンコーディング
	符号化:encode:~:::エンコード
	復号:decode:~:::デコード
clone::::クローン
cloning::::クローン
整列-:sort:~

内容属性:content attribute::~
内容:content::~
内容型:content type::~

遭遇-:encounter:~

	●IDL
此れ:<b>これ°</b>
文脈obj:context object:文脈 object:::文脈オブジェクト
obj:object::::オブジェクト

被取得時:被 get 時:~
被設定時:被 set 時:~
index:

取得子:getter::~::ゲッタ
設定子:setter::~::セッタ
反復器:iterator::~::イテレータ
配列:array::~
演算-:operate:~
値:value::~
真偽値:boolean::~
数値:numeric value::~
引数:argument::~
属性:attribute::~
拡張属性:extended attribute::~
返値:return value::返り値
返され:return され:~
返す:return する:~
返さ:return し:~
返し:return し:~

呼出す:invoke する:呼び出す
呼出-:invoke:呼び出
呼出さな:invoke しな:呼び出さな
	呼出され／呼出して／呼出した
呼出ing:invoking:呼び出し
呼出:invocation:呼び出し
被呼出時:被 invoke 時:~
callback:::::コールバック
	呼戻
call:::::コール
文字列化-:stringify:~
文字列化の:stringification:~
文字列化子:stringifier:~
構築子:constructor::~::コンストラクタ
型:type:~
種別:type:~

大域:global::~::グローバル
	上位大域:superglobal::上位の大域::上位のグローバル
error::::エラー
例外:exception::~
例外投出あり:rethrow any exceptions:~
投出:throw::~
	再投出:re-throw::再 throw:再投出
辞書:dictionary:::ディクショナリ
field::::フィールド
継承-:inherit:~
派生:derived:~
初期化-:initialize::~
初期化:initializing::~
初期化時:initialize 時::~
初期化済み:initialized::初期化済み
初期時:initial 時:~
	initially
初期値:initial value::~
member::::メンバ
meth:method:::メソッド
mixin:
ifc:interface:::インタフェース
catch:::::キャッチ
message::::メッセージ
関数:function::~
識別子:identifier:~
定数:constant:~
抽象:abstract::~
作成-:create:~
作成:creation:~
作成時:create 時:~
prop:property:::プロパティ
静的:static:~
live:
static:
符号単位:code unit::~
単位:unit:~
在する:present する:在る
	有無:presence:~
不在:not present:~
	~~不在:absence:~


	●文字 data
大小区別:case-sensitive::文字大小区別
大小無視:case-insensitive::~
文字:character:~
文字列:string:~
空文字列:empty string:~
部分文字列:substring:~
空白類:whitespace:~
space::::スペース
区切り:-separated:~
変異可能:mutable:~
分割-:split::~
大文字化:uppercase 化:~
小文字化:lowercase 化:~
被support:supported:::被サポート
token::::トークン
tokens::token 列::トークン列
length:::長さ

class::::クラス
classes:::class 列::クラス列

連続的:contiguous::~
count:::::カウント
符号位置:code point:~


解析-:parse::構文解析::パース
解析器:parser::構文解析器::パーサ
直列化-:serialize::~::シリアライズ
	直列化:serialization::~::シリアル化
直列化器:serializer::~::シリアライザ

	●event
event::::イベント
listener::::リスナ
target:
関係target:relatedTarget::関係 target
再target:retarget::再 target
上書target:target override::上書き target

経路:path::~
発火-:fire::~
発火:firing::~
発火法:firing::発火
配送:dispatch::~::ディスパッチ
配送法:dispatching::~::ディスパッチ法
被取消:canceled::取消::キャンセル
受動:passive::~
composed:
	＊構成経路:composed::
取消:cancel::~::キャンセル
取消せ:cancel でき::~::キャンセルでき
	取消せな uncancelable
取消さな:cancel しな::~::キャンセルしな
伝播-:propagate::~
伝播:propagation::~
伝播即停止:stop immediate propagation::~
伝播停止:stop propagation::~
停止:stop:~
相:phase::~::フェイズ
合成:synthetic::~

task::::タスク
	下位~task
極小task:microtask::極小 task:極小タスク:マイクロタスク
並列的:parallel:~

通達-:signal::~
通達:signal::~
	通達-時:signaling::~
通達法:signaling::~
通達抑止:suppress signal::~

複合:compound::~


	●名前空間
局所名:local name:local 名:~
ns:namespace::名前空間
	名前空間接頭辞:namespace prefix::~
接頭辞:prefix::~
接頭-:prefix::~
publicID:public ID::公開識別子
systemID:system ID::system 識別子:システム識別子
locate::特定
有修飾:qualified:~

生成規則:production::~

mode::::モード
文書mode:mode:::モード

	●変異
変異:mutation::~
変異-:mutate::~
記録:record::~::レコード
観測-:observe::~::オブザーブ
観測:observing::~::オブザービング
観測中の:observing::~::オブザーブ中の
観測法:observing::~::オブザーブ法
	観測-可能:observable
	観測器:observer::~:オブザーバ
ob:observer::観測器:オブザーバ
抑止ob:suppress observers::観測器 抑止:オブザーバ抑止


記録待行列:record queue::記録 待ち行列::レコードキュー
待行列:queue::待ち行列::キュー
待入する:queue する::待ち行列に入れる::キューする
待入れる:enqueue する::待ち行列に入れる::エンキューする
待入れら:enqueue さ::待ち行列に入れら::エンキューさ

待入済み:queued::追加済み::キュー済み
登録済:registered::登録済み
一時:transient:~
追加済nodes:addedNodes::追加された node たち:追加されたノードたち
除去済nodes:removedNodes::除去された node たち:除去されたノードたち
	nextSibling::次?の sibling:次?の同胞
	previousSibling::前?の sibling:前?の同胞

新たな:new:~
旧-:old:旧
新-:new:新
	旧値:oldValue::~
報告-:report:~
通知:notify:~
	~~通知:notification
見守:interested:見守り
除去対象:nodes to remove:~

	●custom
custom::::カスタム
	~custom化:customize
反応:reaction::~::リアクション
昇格:upgrade::~::アップグレード
	定義済み
組込みの:built-in::~
検索-:look up::~

	●slot
slot:
slotable:
slotables:::slotable たち
割当先:assign 先::あてがい先
割当され:assign され::あてがわれ
割当する:assign する::あてがう
割当法:assigning::あてがい方
見出す:find する:~
見出-:find:~
見出法:finding:見出し方
平坦化-:flatten:~

	●Range
範囲0:range°::範囲°
	~~範囲
offset:::::オフセット
境界点:boundary point::~
前bp:before::'前'
後bp:after::'後'
等bp:equal::'等'
位置bp:position::位置
設定bp:set::設定

始点:start::~
終点:end::~
元始点:original start:元の start:元の始点
元終点:original end:元の end:元の終点
被包含:contained:~
半被包含:partially contained:~
半被包含子:partially contained child:半被包含 child:半被包含の子
被包含子列:contained children:被包含 children:被包含 子リスト
被包含子:contained child:被包含 child:被包含の子
包含-:contain:~

中身:内容
first::最初の
last::最後の
交わる:intersect する:~
交わら:intersect し:~

	●collection
走査-:traverse::~::トラバース
走査:traversal::~::トラバーサル
collection::::コレクション
filter::::フィルタ
	濾過器
	濾過する
選択子:selector::~::セレクタ
評価-:evaluate::~
評価:evaluation::~

視野根:scoping root::~::スコーピングルート
視野:scope::~::スコープ

合致:match:~:::マッチ
合致-:match:~:::マッチ
照合-:match:~:::マッチ
収集-:collect:~
bitmask::::ビットマスク

	●仕様
algo:algorithm:::アルゴリズム
app:application:::アプリ
UA:user agent:UA:::ユーザエージェント
support::::サポート
vendor::::ベンダ
version::::バージョン
platform::::プラットフォーム
memory::::メモリ
community:::コミュニティ
download:::ダウンロード
feedback:::フィードバック
model::::モデル
markup::::マークアップ
keyword::::キーワード
console::::コンソール
debug::::デバッグ
log::::ログ
proprietary::::プロプライエタリ
option::::オプション
仕様:spec:~
特色機能:feature::~::フィーチャ
適用仕様:applicable specifications:適用し得る仕様
適用-:apply:~
段:step:~:::ステップ
手続き:steps:~
適合性:conformance:~
適合-:conform:~
適合:conforming:~
旧来の:legacy:~
別名:alias:~
歴史上:historical:~
歴史上の:historical:~
歴史的:historical:~
判定基準:criteria:~
拡張性:extensibility:~
拡張:extension:~
相互運用性:interoperability:~
実装:implementation:~
実装-:implement:~
実装依存:implementation-dependent:~
文書作成者:author:~
利用者:user:~
標準:standard:~
対話的:interactive:~
対話:interaction:~
多彩:rich:~
明示的:explicit:~
暗黙的:implicit:~
省略-:omit:~
互換性:compatibility:~
互換名:compatibility name:~
設計:design:~
設計者:designer:~
目標:goals:~
概念:concept:~
更新:update:~
要件:requirements:~
定めら:state さ:~
解釈-:interpret:~
許容-:allow:~
資源:resource:::リソース
依存関係:dependencies:~
導入-:introduce:~
予期-:expect:~
期待-:expect:~
変更点:changes:~
過去互換:quirks::~
限定的互換:limited-quirks::~
非過去互換:no-quirks::非 過去互換
省略可:optional::~
	省略時は
概して:typical に:~
一般的:general:~
一般:general:~
共通的に:common に:よく
共通0:common::共通の
共通の:common::~

指定-:specify:~
	~~指定:flag:
未定義:undefined:~
定義済み:defined:~
定義-:define:~
定義:definition:~
定義法:defining:~
指示-:indicate:~
	~~指示:instruct
提供-:provide:~
意図的:intentional:~
機能性:functionality:~
一貫する:consistent になる:~
一貫させ:consistent にす:~

結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
結付け:associate し:結び付け

所与の:given:与えられた

特定の:specific:~
特有の:-specific な:~
取扱い:handling:取り扱い
	特別:special
	特にspecific／specifically
既存の:existing:~
挙動:behavior:ふるまい
挙動する:behave:ふるまう
制御:control:~
最適化:optimization:~
最適化-:optimize:~
処理能:performance:~
副作用:side effects:~
所産:artifact:~
奨励-:encourage:~
開発者:developer:~
局面:scenario:~
効率的:efficient:~
問題:problem:~
軽減-:mitigate:~
理想的:ideal:~
要求-:require:~
劇的:dramatic:~
将来的:future:~
援助-:aid:~
実際:actual:~
実際の:actual:~
成功裡:successful:~
単純化-:simplify:~
同義語:synonymous:~
影響-:affect:~
影響0:impact:影響
拘束:constraints:~
拘束-:constrain:~
保障-:guarantee:~
無視-:ignore:~
自動的:automatic:~
冗長:redundant:~
改訂:revision:~
	説明-:explain:~
可読性:readability:~
確保-:ensure:~
収束-:converge:~
	想定-:suppose
正しく:correct に:~

	●未分類（動詞
抑止-:suppress:~
試行-:try:~
可能化-:enable:~
不能化-:disable:~
不能化:disabling:~
中止-:abort:~
代入-:assign:~
代入:assignment:~
変換-:convert:~
検査-:check:~
検査:check:~
構築-:construct:~
構築法:constructing:~
比較:comparison:~
比較-:compare:~
決定-:determine:~
経過-:pass:~
表現-:represent:~
追跡-:track:~
公開-:expose:~
進行中:ongoing:~
重複:duplicate:~
到達-:reach:~
阻む:block する:~:::ブロックする
破棄-:discard:~
動作:action:~
活動:activity:~
関係-:relate:~
関係性:relationship:~
添付けら:attach さ:添え付けら
上書き:override:~

	●未分類
ASCII:
関連する:relevant な:~
失敗:failure:~
失敗-:fail:~
Web:
viable::大体
疑似類:pseudo-class::疑似 class:疑似クラス
状態:state::~
brand:
open:
access::::アクセス
bit::::ビット
code::::コード
data::::データ
flag::::フラグ
form::::フォーム
submit:::送信
gc:garbage collection:::ガーベジ収集:ガーベジコレクション
hex:16進
hook::::フック
host::::ホスト
hyphen::::ハイフン
instance::::インスタンス
list::::リスト
macro::::マクロ
multimedia::::マルチメディア
network::::ネットワーク
page:::ページ
pointer::::ポインタ
scrolling::::スクロール処理
script::::スクリプト
service:
worker:
source::::ソース
tag::::タグ
text::::テキスト
touch:
view::::ビュー
wheel:
集合:set:~
下位:sub:~
一意:unique:~
下層:underlying:~
環境設定:configurations:~
事例:case:~

先頭一致:prefix match:~
内的:internal:内部



	一致する:identical:~
名:name:~
名前:name:~
命名-:name:~
改称-:rename:~
同期:synchronous:~
文書型名:name:名前
基底URL:base URL:基底 URL
変数:variable:~
完了:completion:~
実体参照:entity reference:~
格納:storing:~
実質的:effective:~
整数:integer:~
文脈:context:~
方向:direction:~
既定:default:~
既定の:default:~
時刻:time:~
非決定的な:non-deterministic:~
有順序の:ordered:順序付けられた
順序:order:~
有順序:ordered:~
条件:condition:~

構造:structure:~
正確:exact:~
精確:precise:~
閲覧文脈:browsing context::~

現在の:current:~
生成元:origin::~::オリジン
不透明な:opaque::~
画像:image:~
相対的:relative:~
空:empty:~
等価:equivalent:~
階層的:hierarchical:~
非同期:asynchronous:~
	内部処理用の:bookkeeping purposes

</script>

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
ordered-sets:ordered%20sets
dom-domtokenlist-stringifier:DOMTokenList-stringification-behavior
</script>
<!--%ifc -->
<script type="text/plain" id="_ifc_names">

Attr
CharacterData
CustomEvent
CustomEventInit:#dictdef-customeventinit
Comment
ChildNode
CDATASection
NonDocumentTypeChildNode
Document
DocumentFragment
ShadowRoot
ShadowRootInit:#dictdef-shadowrootinit
ShadowRootMode:#enumdef-shadowrootmode
DocumentOrShadowRoot
GetRootNodeOptions:#dictdef-getrootnodeoptions

DOMImplementation
DocumentType
Element
ElementCreationOptions:#dictdef-elementcreationoptions
Elements
Event
EventInit:#dictdef-eventinit
EventListener:#callbackdef-eventlistener
EventTarget
EventListenerOptions
AddEventListenerOptions
HTMLCollection
MutationCallback
MutationObserver
MutationObserverInit:#dictdef-mutationobserverinit
MutationRecord
NamedNodeMap
Node
NodeFilter:#callbackdef-nodefilter
NodeIterator
NodeList
ProcessingInstruction
Range
ParentNode
NonElementParentNode
DOMTokenList
TreeWalker
Text
XMLDocument

	●→ 廃止
RangeException
MutationEvent
MutationNameEvent

DOMConfiguration
DOMError
DOMErrorHandler
DOMImplementationList
DOMImplementationSource
DOMLocator
DOMObject
DOMStringList
DOMUserData
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler


HTMLElement:~HTMLDOM#htmlelement
HTMLHtmlElement:~HTMLmetadata#htmlhtmlelement
HTMLSlotElement:~HTMLSCRIPT#htmlslotelement

ServiceWorkerGlobalScope:~SW#service-worker-global-scope-interface
Window:~BROWSERS#window

AnimationEvent:~CSSANIM#animationevent
BeforeUnloadEvent:~HTML5/browsers.html#beforeunloadevent
CloseEvent:~HTML5/comms.html#closeevent
CompositionEvent:~UIEVENTS#compositionevent
	#interface-compositionevent
	CustomEvent
	DeviceMotionEvent:
	DeviceOrientationEvent:
DragEvent:~HTMLDND#dragevent
ErrorEvent:~WAPI#errorevent
FocusEvent:~UIEVENTS#focusevent
	#interface-focusevent
	Event
WheelEvent:~UIEVENTS#wheelevent
	#interface-wheelevent
HashChangeEvent:~HTML5/browsers.html#hashchangeevent
IDBVersionChangeEvent:~INDEXEDDB#idl-def-idbversionchangeevent
KeyboardEvent:~UIEVENTS#interface-keyboardevent
MessageEvent:~HTML5/comms.html#messageevent
MouseEvent:~UIEVENTS#interface-mouseevent
PageTransitionEvent:~HTML5/browsers.html#pagetransitionevent
PopStateEvent:~HTML5/browsers.html#popstateevent
ProgressEvent:~XHR#interface-progressevent
StorageEvent:~WEBSTORAGE#storageevent
SVGZoomEvent:~SVG11/script.html#InterfaceSVGZoomEvent
TouchEvent:~TOUCHEVENTS#touchevent-interface
TrackEvent:~HTML5/embedded-content.html#trackevent
TransitionEvent:~TRANSITION#Events-TransitionEvent
UIEvent:~UIEVENTS#interface-uievent
	WebGLContextEvent:

DOMTimeStamp:~WEBIDL#DOMTimeStamp
DOMString:~WEBIDL#idl-domstring
DOMException:~WEBIDL#idl-DOMException

</script>

<!--%リンク置換データ
-->
<script type="text/plain" id="_link_map1">

script.e:~HTMLSCRIPT#the-script-element
input.e:~HTML5/forms.html#the-input-element
title.e:~HTMLmetadata#the-title-element
html.e:~HTMLmetadata#the-html-element
head.e:~HTMLmetadata#the-head-element
body.e:~HTMLsections#the-body-element
template.e:~HTMLSCRIPT#the-template-element
slot.e:~HTMLSCRIPT#the-slot-element

open.l:#dom-shadowrootmode-open
closed.l:#dom-shadowrootmode-closed

CEReactions:~HTMLCUSTOM#cereactions

最初0:#_first_obj
最後0:#_last_obj

文脈obj:#context-object
	＊投出:#concept-throw
適用仕様:#other-applicable-specifications


	●event
初期化済み.f:#initialized-flag
伝播即停止.f:#stop-immediate-propagation-flag
伝播停止.f:#stop-propagation-flag
被取消.f:#canceled-flag
配送.f:#dispatch-flag
受動~listener内.f:#in-passive-listener-flag
~composed.f:#composed-flag

type.i:#_type
callback.i:#_callback
capture.i:#_capture
passive.i:#_passive
once.i:#_once
removed.i:#_removed

item.i:#_item
target.i:#_target
関係target.i:#_relatedTarget

再target:#retarget
配送:#concept-event-dispatch
~event:#concept-event
関係target:#event-relatedtarget
再targetする手続き:#event-retargeting-steps
経路:#event-path
発火-:#concept-event-fire
呼出す:#concept-event-listener-invoke
内部的に呼出す:#concept-event-listener-inner-invoke
内部的に呼出した:#concept-event-listener-inner-invoke
初期化-:#concept-event-initialize
~listener~list:#_listener-list
~event~listener:#concept-event-listener
	type.i:#listener-type
	callback.i:#listener-callback
	capture.i:#listener-capture
平坦化-:#concept-flatten-options
もっと平坦化-:#event-flatten-more
親~targetを取得-:#get-the-parent


	●node／木
~ID:#concept-id

親~要素:#parent-element

子:#concept-tree-child
親:#concept-tree-parent
先祖:#concept-tree-ancestor
子孫:#concept-tree-descendant
広義先祖:#concept-tree-inclusive-ancestor
広義子孫:#concept-tree-inclusive-descendant
共通の広義先祖:#_common-inclusive-ancestor

最初0の子:#concept-tree-first-child
最後0の子:#concept-tree-last-child
先行-:#concept-tree-preceding
後続-:#concept-tree-following
指数:#concept-tree-index
兄:#concept-tree-previous-sibling
弟:#concept-tree-next-sibling
関与-:#concept-tree-participate
同胞:#concept-tree-sibling
広義同胞:#concept-tree-inclusive-sibling

木:#concept-tree
~node木:#concept-node-tree
文書~木:#concept-document-tree
根:#concept-tree-root
木~順序:#concept-tree-order
対応する要素~ifc:#concept-element-interface

文書~木~内:#in-a-document-tree
文書~内:#in-a-document

受入-:#concept-node-adopt
受入-時の手続き:#concept-node-adopt-ext
付加-:#concept-node-append
挿入-:#concept-node-insert
挿入:#concept-node-insert
挿入-時の手続き:#concept-node-insert-ext
前挿入:#concept-node-pre-insert
挿入し得るかどうか検証する:#concept-node-ensure-pre-insertion-validity
前除去-:#concept-node-pre-remove
前除去-時の手続き:#nodeiterator-pre-removing-steps
除去-:#concept-node-remove
除去-時の手続き:#concept-node-remove-ext
置換-:#concept-node-replace
すべて置換-:#concept-node-replace-all
隣に挿入-:#insert-adjacent

~clone:#concept-node-clone
~clone時の手続き:#concept-node-clone-ext

~filterにかける:#concept-node-filter
~filterにかけた:#concept-node-filter
~length:#concept-node-length
	長さ
~node文書:#concept-node-document
~node:#concept-node
空:#concept-node-empty
等しい:#concept-node-equals


文書片:#_concept-documentfragment
文字~data~node:#_concept-cdata-node
~host:#concept-documentfragment-host
~hostも含む広義先祖:#concept-tree-host-including-inclusive-ancestor


	●shadow
~light木:#concept-light-tree
~shadow木:#concept-shadow-tree
~shadow~host:#element-shadow-host
~shadow根:#concept-shadow-root
~mode.sR:#shadowroot-mode
~shadowも含む子孫:#concept-shadow-including-descendant
~shadowも含む広義子孫:#concept-shadow-including-inclusive-descendant
~shadowも含む先祖:#concept-shadow-including-ancestor
~shadowも含む広義先祖:#concept-shadow-including-inclusive-ancestor
~shadowも含む木~順序:#concept-shadow-including-tree-order
~shadowも含む深優先前順走査:#shadow-including-preorder-depth-first-traversal
接続され:#connected
~shadowも含む根:#concept-shadow-including-root
	#in-a-shadow-including-document
~closed-shadow-hidden:#concept-closed-shadow-hidden

	●slot
~slot:#concept-slot
~slotable:#concept-slotable
~slot名:#slot-name
~slotable名:#slotable-name
	＊名前.sL:#slot-name
	＊名前.sB:#slotable-name
~slotを見出す:#find-a-slot
~slotを見出-:#find-a-slot
~slotableたちを見出す:#find-slotables
~slotableたちを見出-:#find-slotables
平坦化された~slotableたちを見出す:#find-flattened-slotables
平坦化された~slotableたちを見出-:#find-flattened-slotables
~slotを割当先にする:#assign-a-slot
~slotを割当する:#assign-a-slot
割当先~slot:#slotable-assigned-slot
割当先がある:#slotable-assigned
割当されている~nodeたち:#slot-assigned-nodes
	~slotable~list:#slot-assigned-nodes
~slotableたちを割当する:#assign-slotables
~slotableたちを割当する.tree:#assign-slotables-for-a-tree
	＊木に~slotableたちを割当する
通達~slot~list:#signal-slot-list
~slotの変化を通達する:#signal-a-slot-change

	●文書／文書片／名前空間
文書:#concept-document
符号化方式:#concept-document-encoding
内容型:#concept-document-content-type
文書URL:#concept-document-url
種別:#concept-document-type
生成元:#concept-document-origin
~mode:#concept-document-mode
	文書mode
文書~基底URL:~HTMLINFRA#document-base-url


限定的互換~mode:#concept-document-limited-quirks
非過去互換~mode:#concept-document-no-quirks
過去互換~mode:#concept-document-quirks
文書型:#concept-doctype
文書型名:#concept-doctype-name

~HTML文書:#html-document
~HTML~ns:#html-namespace
~SVG~ns:#svg-namespace
~XML文書:#xml-document
~XML~ns:#xml-namespace
~XMLNS~ns:#xmlns-namespace

~ns接頭辞を~locate:#locate-a-namespace-prefix
~nsを~locate:#locate-a-namespace
内的 createElementNS 手続き:#internal-createelementns-steps

~publicID:#concept-doctype-publicid
~systemID:#concept-doctype-systemid

	●text node／文字列／cdata
新たな~text~node:#_a-new-text-node

~ASCII大小無視:#ascii-case-insensitive
大小区別:#case-sensitive
先頭一致:#prefix-match
収集-:#collect-a-code-point-sequence
~ASCII小文字化:#converted-to-ascii-lowercase
~ASCII大文字化:#converted-to-ascii-uppercase
~ASCII空白類を読み飛ばす:#skip-whitespace
有順序~集合 解析器:#concept-ordered-set-parser
有順序~集合 直列化器:#concept-ordered-set-serializer

分割-:#concept-text-split
~dataを置換-:#concept-cd-replace
~data:#concept-cd-data
~dataの部分文字列:#concept-cd-substring

狭義の~Text0~node:#exclusive-text-node
連続的な~Text0~node列:#contiguous-text-nodes
連続的な狭義の~Text0~node列:#contiguous-exclusive-text-nodes
連続的な同胞~列:#_contiguous-nodes

	●要素／属性
文書~要素:#document-element
要素:#concept-element
局所名:#concept-element-local-name
~shadow根.elm:#concept-element-shadow-root
有修飾~名:#concept-element-qualified-name
~ns接頭辞:#concept-element-namespace-prefix
~ns:#concept-element-namespace
有修飾~名として検証-:#validate
検証して抽出-:#validate-and-extract
属性0~list:#concept-element-attribute
有する:#concept-element-attribute-has
有して:#concept-element-attribute-has
有さない:#concept-element-attribute-has
	持たない:#concept-element-attribute-has
属性0を設定-:#concept-element-attributes-set
付加-.a:#concept-element-attributes-append
除去-.a:#concept-element-attributes-remove
変更-.a:#concept-element-attributes-change
置換-.a:#concept-element-attributes-replace
属性0値を設定-:#concept-element-attributes-set-value
既存の属性0値を設定-:#set-an-existing-attribute-value
属性0値を取得-:#concept-element-attributes-get-value
属性0を取得-:#concept-element-attributes-get-by-name
	属性0を名前により取得-
属性0を取得-.ns:#concept-element-attributes-get-by-namespace
	属性0を~nsと局所名により取得-
属性0を除去-:#concept-element-attributes-remove-by-name
	属性0を名前により除去-
属性0を除去-.ns:#concept-element-attributes-remove-by-namespace
	属性0を~nsと局所名により除去-

属性0:#concept-attribute
属性0.nm:#concept-named-attribute
属性0の変更~手続き:#concept-element-attributes-change-ext
属性0を変更する手続き:#concept-element-attributes-change-ext
属する要素:#concept-attribute-element
有修飾~名.a:#concept-attribute-qualified-name
値.a:#concept-attribute-value
~ns.a:#concept-attribute-namespace
~ns接頭辞.a:#concept-attribute-namespace-prefix
局所名.a:#concept-attribute-local-name

要素.nm:#concept-namednodemap-element
属性0~list.nm:#concept-namednodemap-attribute
~classes:#concept-class
~classesに含む要素の~list:#concept-getelementsbyclassname
有修飾~名に持つ要素の~list:#concept-getelementsbytagname
( ~ns, 局所名 ) に持つ要素の~list:#concept-getelementsbytagnamens

反映-:#concept-reflect


	●custom要素
要素を作成-:#concept-create-element
新たな要素:#concept-create-element
定義済み:#concept-element-defined
~custom:#concept-element-custom
~custom要素~状態:#concept-element-custom-element-state
~custom要素~定義:#concept-element-custom-element-definition
~is0値:#concept-element-is-value

名前.cD:~HTMLCUSTOM#concept-custom-element-definition-name
局所名.cD:~HTMLCUSTOM#concept-custom-element-definition-local-name
構築子.cD:~HTMLCUSTOM#concept-custom-element-definition-constructor
妥当な~custom要素~名:~HTMLCUSTOM#valid-custom-element-name
~custom要素~構築子:~HTMLCUSTOM#custom-element-constructor
~custom要素~callback反応を待入れる:~HTMLCUSTOM#enqueue-a-custom-element-callback-reaction
~custom化された組込みの要素:~HTMLCUSTOM#customized-built-in-element
~custom要素~定義を検索-:~HTMLCUSTOM#look-up-a-custom-element-definition
昇格を試行する:~HTMLCUSTOM#concept-try-upgrade
昇格:~HTMLCUSTOM#concept-upgrade-an-element
~custom要素~昇格~反応を待入れる:~HTMLCUSTOM#enqueue-a-custom-element-upgrade-reaction


	●変異
待入する:#queue-a-mutation-record
	変異~meth~macro:#mutation-method-macro
~nodeに変換-:#converting-nodes-into-a-node
~nodeたちを~nodeに変換-:#converting-nodes-into-a-node
~callback.mo:#concept-mo-callback

記録待行列:#concept-mo-queue
変異~ob 複合~極小task待入済み.f:#mutation-observer-compound-microtask-queued-flag
変異~ob 複合~極小taskを待入する:#queue-a-mutation-observer-compound-microtask
変異~obに通知:#notify-mutation-observers
変異~ob 通知~list:#_mutation-observer-notify-list

登録済~ob:#registered-observer
一時~登録済~ob:#transient-registered-observer
~ob~list:#_observer-list
観測している~node~list:#_observing-nodes
	“observed nodes”?
	抑止ob.f:#_suppress-observers-flag


	●範囲
範囲0:#concept-range
根.rg:#concept-range-root
中身を抽出-.rg:#concept-range-extract
中身を~clone.rg:#concept-range-clone
中身に挿入-.rg:#concept-range-insert
中身として選択-.rg:#concept-range-select
中身.rg:#_concept-range-content

終点~node:#concept-range-end-node
終点~offset:#concept-range-end-offset
終点:#concept-range-end
始点~node:#concept-range-start-node
始点~offset:#concept-range-start-offset
始点:#concept-range-start

境界点:#concept-range-bp
後bp:#concept-range-bp-after
前bp:#concept-range-bp-before
等bp:#concept-range-bp-equal
~offset:#concept-range-bp-offset

位置bp:#concept-range-bp-position
設定bp:#concept-range-bp-set

被包含:#contained
半被包含:#partially-contained

	●token list
~tokens:#concept-dtl-tokens
被support~token集合.dtl:#concept-supported-tokens
更新~手続き:#concept-dtl-update
直列化-手続き:#concept-dtl-serialize
検証-.dtl:#concept-domtokenlist-validation
要素.dtl:#_dtl-element
属性0の局所名.dtl:#_dtl-localname
検査する.dtl:#_dtl-check-token

	●node iterator
表現-:#represented-by-the-collection
反復器~collection:#iterator-collection
~live:#concept-collection-live
~static:#concept-collection-static
~collection:#concept-collection
~filter:#_collection-filter
根.cl:#_collection-root
~filter~callback:#concept-traversal-filter
根~node:#concept-traversal-root
whatToShow ~bitmask:#concept-traversal-whattoshow
~target:#concept-pi-target

子を走査-:#concept-traverse-children
同胞を走査-:#concept-traverse-siblings
走査-:#concept-nodeiterator-traverse


	●選択子
視野の下で照合-:#scope-match-a-selectors-string
~scope-ps要素:~SELECTORS4#scope-element
選択子として解析-:~SELECTORS4#parse-a-selector
視野根:~SELECTORS4#scoping-root
選択子として評価-:~SELECTORS4#evaluate-a-selector
照合-:~SELECTORS4#match-a-selector-against-an-element

	●WEBIDL
~callback this 値:~WEBIDL#dfn-callback-this-value
符号単位:~WEBIDL#dfn-code-unit
辞書~member:~WEBIDL#dfn-dictionary-member
識別子:~WEBIDL#dfn-identifier

被support ~prop~index:~WEBIDL#dfn-supported-property-indices
被support ~prop名:~WEBIDL#dfn-supported-property-names
投出:~WEBIDL#dfn-throw
可変個引数:~WEBIDL#dfn-variadic
LegacyUnenumerableNamedProperties:~WEBIDL#LegacyUnenumerableNamedProperties
利用者~objの演算を~call:~WEBIDL#call-a-user-objects-operation
~callback関数を呼出す:~WEBIDL#invoke-a-callback-function

	●他
~ASCII空白類:~ENCODING#ascii-whitespace
直列化-:~URLSpec#concept-url-serializer
URL:~URLSpec#concept-url
utf-8:~ENCODING#utf-8

Char.prod:https://www.w3.org/TR/xml/#NT-Char
Name.prod:https://www.w3.org/TR/xml/#NT-Name
QName.prod:https://www.w3.org/TR/xml-names/#NT-QName
PrefixedName.prod:https://www.w3.org/TR/xml-names/#NT-PrefixedName

~HTML解析器:~HTML5/syntax.html#html-parser
並列的:~HTMLINFRA#in-parallel
	~HTML5/infrastructure.html#in-parallel
その例外を報告する:~WAPI#report-the-exception
関連する大域~obj:~WAPI#concept-relevant-global
現在の大域~obj:~WAPI#current-global-object

生成元.x:~BROWSERS#concept-origin
不透明な生成元:~BROWSERS#concept-origin-opaque
Unicode に直列化-:~BROWSERS#unicode-serialisation-of-an-origin
閲覧文脈:~BROWSERS#browsing-context
互いに関係するかつ生成元も類似する閲覧文脈~群:~BROWSERS#unit-of-related-similar-origin-browsing-contexts
属する閲覧文脈:~BROWSERS#concept-document-bc
結付けられている文書:~BROWSERS#concept-document-window

~service~worker:~SW#dfn-service-worker
~script資源:~SW#dfn-script-resource
評価されたことがある~flag:~SW#dfn-has-ever-been-evaluated-flag


前順.wiki:http://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_%28%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%29#.E8.B5.B0.E6.9F.BB.E6.B3.95
深さ優先.wiki:http://ja.wikipedia.org/wiki/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2


Construct.AO:https://tc39.github.io/ecma262/#sec-construct

</script>

<!-- 
pre.idl::before {
	position: absolute;
	margin: -0.5em 0 0 -3.3em;
	width: 1.8em;
	z-index: -1;
	padding: 0.5em;

	content: "IDL";
	font: bold small sans-serif;
	background: white;
	color: gray;
	border: thin solid;
	border-right: none;
	border-radius: 0.5em 0 0 0.5em;
}

-->

<!--%style -->
<style>
*[lang="en"] {
	white-space: pre-line;
}

i.i {
	color: purple;
	font-weight: bold;
	font-family: serif0, serif;
}
.flag {
	
}

var {
	font-family: serif0, serif;
}

.bp-example {
	text-align: center;
	font-size: 14px;
	white-space: pre;
	overflow: auto;
	font-family: monospace0, monospace;
	padding-bottom: 3em;
	color: #555;
}
.bp-example * {
	font-family: monospace0, monospace;
	font-style:normal;
	position:relative;
	top: 6px;
	border-top: solid #AAA 3px;
}
.bp-example i {
	border-top-color: red;
	color: red;
}
.bp-example .x {
	border-top-color: #0C0;
}
.bp-example .y {
	border-top-color: blue;
}
.bp-example .m {
	border: none;
	top: 0;
	display: inline-block;
	vertical-align: top;
}


div.trans-note {
	margin: 1em;
	border: solid green 2px;
	padding: 0.5em;
}

/*
	border-left: solid #DDD 1em;
	padding-left: 0.5em;
*/
.domTree samp {
	border: 1px solid green;
}


</style>

</head>

<body>

<!--%UI -->
<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">

<h1>DOM Standard （ “DOM4” ） 日本語訳</h1>

<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/" >WHATWG</a>
による，副題の日付時点の
<a href="https://dom.spec.whatwg.org/" >DOM Standard</a>
仕様（通称 “DOM-LS”, “DOM4”, “DOM Core” ）を日本語に翻訳したものです（内容は
<a href="https://www.w3.org/">W3C</a>
による
<a href="https://www.w3.org/TR/dom/" >DOM 仕様</a>
とほぼ同じですが，より新しいです）。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-09-02</time>
（公開： <time>2012-01-28</time>）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBzdHJva2U9IiMzYzc5MGEiIHN0cm9rZS13aWR0aD0iMTAiIGZpbGw9IiNmZmYiPgo8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIvPgo8cGF0aCBkPSJtNTAsMjV2MTVsLTE1LDEwLTEwLDE1bTEwLTE1bDEwLDE1bTUtMjVsMTUsMTAsMTAsMTVtLTEwLTE1bC0xMCwxNSIvPgo8L3N2Zz4K"
></a>

	<hgroup>
<h1>DOM</h1>
<h2>Living Standard — 最終更新 2016 年 9 月 1 日</h2>
	</hgroup>

<dl>
	<dt>Participate:</dt>
	<dd><a href="https://github.com/whatwg/dom">GitHub whatwg/dom</a> (<a href="https://github.com/whatwg/dom/issues/new">new issue</a>, <a href="https://github.com/whatwg/dom/issues">open issues</a>, <a href="https://www.w3.org/Bugs/Public/buglist.cgi?component=DOM&amp;product=WebAppsWG&amp;resolution=---">legacy open bugs</a>)</dd>
	<dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/dom/commits">GitHub whatwg/dom/commits</a></dd>
	<dd><a href="https://twitter.com/thedomstandard">@thedomstandard</a></dd>

	<dt>各国語翻訳（非規範的）</dt>
	<dd>日本語（このページ）</dd>

</dl>

</header>

	<section id="abstract">

<h2 title="Abstract">要約</h2>

<p>
DOM は、プラットフォームに中立的な，イベント／ノードツリーのモデルを定義する。
<span lang="en">
DOM defines a platform-neutral model for events and node trees.
</span></p>

	</section>

<nav id="contents" class="toc">
<h2 title="Table of Contents">目次</h2>
<ol id="_toc_list"></ol>
</nav>

<main id="MAIN" style="display:none;">

	<section id="goals">

<h2 title="Goals">目標</h2>

<p>
この仕様は~DOMを標準~化する。
次を行うことにより：
◎
This specification standardizes the DOM. It does so as follows:
</p>

<ol>
 <li>
<div class="p">
<p>
次に挙げる仕様を整理統合し：
</p>

<ul ><li>`DOM Level 3 Core^cite `DOM-Level-3-Core$r
</li><li>`Element Traversal^cite `ELEMENTTRAVERSAL$r
</li><li>`Selectors API Level 2^cite `SELECTORS-API2$r
</li><li>`DOM Level 3 Events^cite `uievents-20031107$r
の "DOM Event Architecture" 章と "Basic Event Interfaces" 章
（特定の型の~eventは~DOM標準には属さない）
</li><li>`DOM Level 2 Traversal and Range^cite `DOM-Level-2-Traversal-Range$r
</li></ul>

<p>
それらを：
</p>

◎
By consolidating DOM Level 3 Core [DOM-Level-3-Core], Element Traversal [ELEMENTTRAVERSAL], Selectors API Level 2 [SELECTORS-API2], the "DOM Event Architecture" and "Basic Event Interfaces" chapters of DOM Level 3 Events [uievents-20031107] (specific types of events do not belong in the DOM Standard), and DOM Level 2 Traversal and Range [DOM-Level-2-Traversal-Range], and:
</div>

<ul>
   <li>
可能な所では JavaScript ecosystem に合わせ，
◎
Aligning them with the JavaScript ecosystem where possible.
</li>

   <li>
既存の実装に揃わせ，
◎
Aligning them with existing implementations.
</li>

   <li>
可能な限り単純化する。
◎
Simplifying them as much as possible.
</li>
  </ul>
 </li>

 <li>
~HTML標準 `HTML$r から，この~DOM標準の一部として指定されるべき特色機能を移行させる。
◎
By moving features from the HTML Standard [HTML] that make more sense to be specified as part of the DOM Standard.
</li>

 <li>

<p>
`DOM Level 3 Events^cite
`uievents-20031107$r
の，問題のあった古い~modelの "Mutation Events" 章と "Mutation Name Event Types" 章に代わるものを定義する。
◎
By defining a replacement for the "Mutation Events" and "Mutation Name Event Types" chapters of DOM Level 3 Events [uievents-20031107] as the old model was problematic.
</p>

<p class="note">注記：
この結果、古い~modelは実装から除去されることが期待されている。
◎
The old model is expected to be removed from implementations in due course.
</li>

<li>
新たな特色機能を定義して、共通の~DOM操作を単純化する。
◎
By defining new features that simplify common DOM operations.
</li>

</ol>

	</section>
	<section id="conformance">

<h2 title="Conformance">1. 適合性</h2>

<p>
明示的に規定でないものと記された節に加え，この仕様におけるすべての図式, 例, 注記は規定ではない。
他のすべては規定である。
◎
All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
</p>

<p>
この文書における~keyword：
「〜しなければ（〜しては）<em class="rfc2119">ならない</em>」 = “MUST (NOT)”,
「〜す<em class="rfc2119">べき</em>である（でない）」 = “SHOULD (NOT)”,
「〜しても<em class="rfc2119">よい</em>」 = “MAY”,
は、 RFC 2119 に則って解釈されるものとする。
可読性のため、この仕様ではこれらの語が
<span class="trans-note">【原文では】</span>
~~大文字で出現することはない。
`RFC2119$r
<br>
<span class="trans-note">【REQUIRED, SHALL, RECOMMENDED, OPTIONAL は利用されないので省略。】</span>
◎
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. For readability, these words do not appear in all uppercase letters in this specification. [RFC2119]
</p>

<p>
~algoの中の命令的な句による要件（例えば
<q>先頭部の~space文字 並びを取り除く</q>,
<q>~F を返して この手続きを終了</q>,
等々）は、~algoを引用する際に利用されている~keyword（ 「〜し~MUST」, 「〜すべき」, 「〜してもよい」, 等々）の意味の下に解釈されることになる。
◎
Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and terminate these steps") are to be interpreted with the meaning of the keyword ("must", "should", "may", etc.) used in introducing the algorithm.
</p>

<p>
~algoまたは 特定の手続きとして記される適合性の要件は、最終的な結果が等価になるのであれば，どのように実装されてもよい。
（特に、この仕様で定義される~algoは追い易くなるように記述されており，処理能は考慮されていない。）
◎
Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant.)
</p>

<p id="hardwareLimitations">
~UAは拘束のない入力に実装~特有の制限を課してもよい。
例えば、 DoS 攻撃の防止, ~memory使い切りに対する保護, ~platform特有の制限の回避など。
◎
User agents may impose implementation-specific limits on otherwise unconstrained inputs,
e.g. to prevent denial of service attacks, to guard against running out of memory, or to work around platform-specific limitations.
</p>

<p>
~methまたは属性が他の~methや属性を~callするときは、例えば文書作成者が属性や~methを~custom JavaScript ~prop／関数で上書きしたとしても，挙動が変更されないようにするため、~UAはその属性や~methの内的 API を呼び出さ~MUST。
◎
When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can’t change the behavior by overriding attributes or methods with custom properties or functions in JavaScript.
</p>

<p>
他が定められない限り、文字列の比較は`大小区別$に基づくとする。
◎
Unless otherwise stated, string comparisons are done in a case-sensitive manner.
</p>

		<section id="dependencies">

<h3 title="Dependencies">1.1. 依存関係</h3>

<p>
この仕様の IDL 片は、 Web IDL 仕様に述べられる，適合 IDL 片に課される要件に従うものとして、解釈され~MUST。
`WEBIDL$r
◎
The IDL fragments in this specification must be interpreted as required for conforming IDL fragments, as described in the Web IDL specification. [WEBIDL]
</p>

<p>
この仕様の一部の用語は
`Encoding^cite,
`Selectors^cite,
`Web IDL^cite,
`XML^cite,
`Namespaces in XML^cite
にて定義される。
`ENCODING$r
`SELECTORS4$r
`WEBIDL$r
`XML$r
`XML-NAMES$r
◎
Some of the terms used in this specification are defined in Encoding, Selectors, Web IDL, XML, and Namespaces in XML. [ENCODING] [SELECTORS4] [WEBIDL] [XML] [XML-NAMES]
</p>

		</section>
		<section id="extensibility">

<h3 title="Extensibility">1.2. 拡張性</h3>

<p>
この仕様に対する~vendor特有の~proprietaryな拡張は、行わないことが強く求められる。
文書作成者はその種の拡張を利用してはならない。
そのような行為は、懸案~内容への~accessが特定の~UAの利用者に限られてしまい，相互運用性の悪化と利用者~層の細分化を招くことになるので。
◎
Vendor-specific proprietary extensions to this specification are strongly discouraged. Authors must not use such extensions, as doing so reduces interoperability and fragments the user base, allowing only users of specific user agents to access the content in question.
</p>

<p>
拡張が必要になったときは、それに則って~DOM標準が更新されるか，あるいは
`適用仕様@†
のために提供される［
拡張性のための~hook
］を利用するような，新たな標準が書かれ得る。
◎
When extensions are needed, the DOM Standard can be updated accordingly, or a new standard can be written that hooks into the provided extensibility hooks for applicable specifications.
</p>

<p class="trans-note">【†
`HTML$r に定義されるそれ（
<a href="~HTMLCONFORM#other-applicable-specifications">applicable specifications</a>
）と同様
— この仕様~自身も含まれる。
】</p>


		</section>
	</section>
	<section id="terminology">

<h2 title="Terminology">2. 各種用語</h2>

<p>
語
`文脈obj@
とは、論の対象の［
~algo／属性~取得子／属性~設定子／~meth
］が~callされた~objを指す。
文脈objが一義的に定まる場合は省略される。
◎
The term context object means the object on which the algorithm, attribute getter, attribute setter, or method being discussed was called. When the context object is unambiguous, the term can be omitted.
</p>

<p class="trans-note">【
この訳では、より簡潔に，太字で
“此れ”
と記す。
また、一義的でも（ほぼ）省略していない。
】</p>


		<section id="_conventions">
<h3 class="trans-note">【日本語訳に固有の表記規約】</h3>

<p>
この仕様を通して，よく用いられる［
“結付けられる”,
“初期化される”,
“新たな … （を作成-）” 
］等々の句については、
<a href="index.html#common-wording">~~共通の慣用表現</a>を~~参照されたし。
</p>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, ~EACH (…), ~RET, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
<small>（
尚、 ~THROW, ~RET について，現時点のこの仕様には、例外を投出した後／値を返した後にも，並列的に実行を継続する~algoは規定されていない。
）</small>
</p>

<p>
加えて、記号［
~AN, ~DE, ~iAN, ~iDE
］も，~nodeの親子関係の記述に利用される（定義は次~節に）。
</p>

<p>
太字の “此れ” は，`文脈obj$を意味する。
</p>

<p>
記述を容易にするため、次の（非公式な）定義を導入する：
所与の［
有限個の~objからなる全順序~集合（例えば`木$や~list）の部分集合（例えば ある条件を満たすものなど）
］ %S に対し，その［
`最初0@ ／ `最後0@
］のものとは、 %S が空（例えば，条件を満たす~objが存在しない）ならば ~NULL であり，そうでなければ その全順序において %S の中で［
最初 ／ 最後
］に位置する~objである。
“最初” ／ “最後” がこの意味で用いられる所（ ~NULL もとり得る所）では、常に（ WebIDL 方式に倣って） "?" が付記される。
</p>

<p>
整数 %index に対する “%index 番” は 0 番目から数えるものとする。
</p>

		</section>

		<section id="trees">

<h3 title="Trees">2.1. 木</h3>
<!-- Sorry reddit, this is not /r/trees -->

<p>
`木@
とは、有限の階層的な木~構造を意味する。
`木~順序@
は、深優先前順走査に基づく。
◎
A tree is a finite hierarchical tree structure. In tree order is preorder, depth-first traversal of a tree.
</p>

<div class="trans-note" id="example-tree">
<p>【 `深さ優先$wiki, `前順$wiki 】：
この方式による木の走査-は、~HTMLや~XML文書の~source~text表現における，要素の開始~tagや~text内容（より一般的には`文字~data~node$）が現れる順序を表現する（ゆえに， “文書順” と呼ばれることもある）。
この順序を反映するように木の一例を可視化した模式図を下に示す。
図の 左端／右端 が~sourceの 先頭／末尾 に対応する。
図の横線が，木の中の各~nodeとそれが~source内を占める~~範囲（要素の開始~tag〜終了~tag, あるいは文字~dataの先頭〜末尾）を表し、それらの上下関係が木の階層（~nodeの入子~階層）を表す。
図の中の各~文字は文字~dataの各~文字に対応し，それらがなす各~COLOR_Rが`文字~data~node$が占める~~範囲を表す。
~nodeの順序はこれらの横線の左端の位置から決定される。
最上層の横線がこの木の根~node（根元）を表し，この順序における先頭になる。
</p>

`[&nbsp;[&nbsp;]&nbsp;(~sourceに)&nbsp;[&nbsp;(現れる)&nbsp;[&nbsp;(順序が)&nbsp;]&nbsp;[&nbsp;(そのまま)&nbsp;[&nbsp;(木~順序に)&nbsp;]&nbsp;]&nbsp;(なる)&nbsp;]&nbsp;]^bpex

<p>
この図に対応する~sourceは次の様になる（簡単にするため，`e^e 要素と~text内容のみから構成されている）：
</p>

<pre>
&lt;e&gt;&lt;e&gt;&lt;/e&gt;~sourceに&lt;e&gt;現れる&lt;e&gt;順序が&lt;/e&gt;&lt;e&gt;そのまま&lt;e&gt;木~順序に&lt;/e&gt;&lt;/e&gt;なる&lt;/e&gt;&lt;/e&gt;
</pre>

</div>


<p>
`木$に
`関与-@
する~objは、他の~objまたは~NULL をとる
`親@
を持ち，有順序の, 0 個以上の
`子@
~objを持つ。
`親$ ~objが %B である~obj %A は， %B の子である。
◎
An object that participates in a tree has a parent, which is either another object or null, and an ordered list of zero or more child objects. An object A whose parent is object B is a child of B.
</p>

<p class="trans-note">【
同じ~objが複数の（互いに根が異なる）木に関与することはない（少なくともこの仕様の中では）。
】</p>

<p>
~objの
`根@
とは、［
~objの`親$ ~EQ ~NULL
］ならば~obj自身であり，他の場合は~objの`親$の`根$である。
`木$の`根$は、その`木$に`関与-$している~objであって，［
`親$ ~EQ ~NULL
］なるものである。
◎
The root of an object is itself, if its parent is null, or else it is the root of its parent. The root of a tree is any object participating in that tree whose parent is null.
</p>

<p>
~obj %A が~obj %B の
`子孫@
であるとは、次を意味する
⇒
［
%A は %B の`子$である
］~OR［
%A は %B のある`子孫$の`子$である
］
◎
An object A is called a descendant of an object B, if either A is a child of B or A is a child of an object C that is a descendant of B.
</p>

<p class="trans-note">【
%A ⊂ %B とも記す。
】【
%A 自身が %A の`子孫$になることはない。
】</p>

<p>
~obj %A が~obj %B の
`広義子孫@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`子孫$である
］
◎
An inclusive descendant is an object or one of its descendants.
</p>

<p class="trans-note">【
%A ⊆ %B とも記す。
】</p>

<p class="trans-note"><small>【
“広義” という対訳は，よいとは言えないが、より忠実に “自身も含めた子孫” などと訳すのでは，用語として定義する意義
— 他から簡潔に参照できるようにする —
も失われる（単に “自身または子孫” と記すのと同じことになる）。
】</small></p>

<p>
~obj %A が~obj %B の
`先祖@
であるとは、次を意味する
⇒
%B は %A の`子孫$である
◎
An object A is called an ancestor of an object B if and only if B is a descendant of A.
</p>

<p class="trans-note">【
%A ⊃ %B とも記す。
】</p>

<p>
~obj %A が~obj %B の
`広義先祖@
であるとは、次を意味する
⇒
［
%A は %B と同じである
］~OR［
%A は %B の`先祖$である
］
◎
An inclusive ancestor is an object or one of its ancestors.
</p>

<p class="trans-note">【
%A ⊇ %B とも記す。
】</p>

<p>
~obj %A が~obj %B の
`同胞@
（ “兄弟” ）であるとは、次を意味する
⇒
［
%A の`親$ ~NEQ ~NULL
］~AND［
%A の`親$ ~EQ %B の`親$
］
◎
An object A is called a sibling of an object B, if and only if B and A share the same non-null parent.
</p>

<p class="trans-note">【
定義により， %A 自身も
<em>親が非~NULLならば</em>
%A の`同胞$になる。
この仕様の中では、この点について特に注意を要する箇所は（現時点では）ないが。
例えば、この同胞の定義を
“%A と %B は同じでない”
と解釈したとしても，この仕様の残りの部分には影響しない。
】</p>

<p>
~obj %A が~obj %B の
`広義同胞@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`同胞$である
］
◎
An inclusive sibling is an object or one of its siblings.
</p>

<p class="trans-note">【
%A 自身は，親が~NULLであっても %A の広義同胞になる点で、`同胞$の定義と異なる。
この定義は、もっぱら他の仕様のためにあり，この仕様~内では利用されない。
】</p>
<!-- https://github.com/whatwg/dom/issues/55 -->

<p>
~obj %A が~obj %B に
`先行-@
するとは、次を意味する
⇒
［
%A と %B は同じ`木$に関与する
］~AND［
`木~順序$において %A は %B より前に位置する
］
<!-- * A ≺ B -->
◎
An object A is preceding an object B if A and B are in the same tree and A comes before B in tree order.
</p>

<p>
~obj %A が~obj %B に
`後続-@
するとは、次を意味する
⇒
［
%A と %B は同じ`木$に関与する
］~AND［
`木~順序$において %A は %B より後に位置する
］
<!-- * A ≻ B -->
◎
An object A is following an object B if A and B are in the same tree and A comes after B in tree order.
</p>

<p>
~objの
`最初0の子@
とは、~objの`子$のうち，`最初0$のものである。
◎
The first child of an object is its first child or null if it has no children.
</p>

<p>
~objの
`最後0の子@
とは、~objの`子$のうち，`最後0$のものである。
◎
The last child of an object is its last child or null if it has no children.
</p>

<p>
~objの
`兄@
とは、~objに`先行-$する`同胞$のうち，`最後0$のものである。
◎
The previous sibling of an object is its first preceding sibling or null if it has no preceding sibling.
</p>

<p>
~objの
`弟@
とは、~objに`後続-$する`同胞$のうち，`最初0$のものである。
◎
The next sibling of an object is its first following sibling or null if it has no following sibling.
</p>

<p>
~objの
`指数@
とは、~objに`先行-$する`同胞$の個数である。
◎
The index of an object is its number of preceding siblings.
</p>

		</section>
		<section id="strings">

<h3 title="Strings">2.2. 文字列</h3>

<p>
２つの文字列を
`大小区別@
で比較するとは、各 文字ごとに，符号位置を正確に比較することを意味する。
◎
Comparing two strings in a case-sensitive manner means comparing them exactly, code point for code point.
</p>


<p>
２つの文字列の
`~ASCII大小無視@
で比較するとは、~~範囲 { U+0041 〜 U+005A } 
（ LATIN CAPITAL LETTER A 〜 LATIN CAPITAL LETTER Z ）の文字と,
対応する~~範囲 { U+0061 〜 U+007A }
（ LATIN SMALL LETTER A 〜 LATIN SMALL LETTER Z ）の文字は同一視することを除き、各 文字ごとに，符号位置を正確に比較することを意味する。
◎
Comparing two strings in a ASCII case-insensitive manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z), inclusive, and the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z), inclusive, are considered to also match.
</p>

<p class="algo-head">
文字列の
`~ASCII大文字化@
とは、文字列の中の~~範囲
{ U+0061 〜 U+007A } に入る文字すべてを，対応する~~範囲
{ U+0041 〜 U+005A } の文字に置換することを意味する。
◎
Converting a string to ASCII uppercase means replacing all characters in the range U+0061 to U+007A, inclusive, with the corresponding characters in the range U+0041 to U+005A, inclusive.
</p>

<p class="algo-head">
文字列の
`~ASCII小文字化@
とは、文字列の中の~~範囲
{ U+0041 〜 U+005A } に入る文字すべてを，対応する~~範囲
{ U+0061 〜 U+007A } の文字に置換することを意味する。
◎
Converting a string to ASCII lowercase means replacing all characters in the range U+0041 to U+005A, inclusive, with the corresponding characters in the range U+0061 to U+007A, inclusive.
</p>

<p class="algo-head">
文字列 %pattern が文字列 %s に
`先頭一致@
するとは、 %pattern は %s より長くなく, かつ
%s の末尾部分を %pattern の長さになるまで切り取ったとき、２つの文字列が互いに合致することをいう。
<span class="trans-note">【この語は、この仕様の中では利用されていない。】</span>
◎
A string pattern is a prefix match for a string s when pattern is not longer than s and truncating s to pattern’s length leaves the two strings as matches of each other.
</p>

		</section>
		<section id="ordered-sets">

<h3 title="Ordered sets">2.3. 有順序~集合</h3>

<p class="trans-note">【
有順序~集合
— 全順序である集合、言い換えれば，~listであって，その各項が~listの中で一意である
】</p>

<p class="algo-head">
文字列 %入力 を
`有順序~集合 解析器@
にかけるときは、次を走らす：
◎
The ordered set parser takes a string input and then runs these steps:
</p>

<ol>
 <li>
%位置 ~LET 0 （ %入力 の先頭を指す~pointer）
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>

 <li>
%tokens ~LET 空~list（~tokenからなる有順序~集合）
◎
Let tokens be an ordered set of tokens, initially empty.
</li>

 <li>
`~ASCII空白類を読み飛ばす$
◎
Skip ASCII whitespace.
</li>

 <li>
<p>
~WHILE［
%位置 ~LT %入力 の長さ
］：
◎
While position is not past the end of input:
</p>
  <ol>
   <li>
%token ~LET `~ASCII空白類$でない符号位置の並びを`収集-$した結果
◎
Collect a code point sequence of code points that are not ASCII whitespace.
</li>

   <li>
~IF［
%token ~NIN %tokens
］
⇒
%token を %tokens に付加する
◎
If the collected string is not in tokens, append the collected string to tokens.
</li>

   <li>
`~ASCII空白類を読み飛ばす$
◎
Skip ASCII whitespace.
</li>

  </ol>
 </li>
 <li>
~RET %tokens
◎
Return tokens.
</li>
</ol>

<p class="algo-head">
%符号位置~集合 に含まれる符号位置の並びを
`収集-@
するときは、次を走らす：
◎
To collect a code point sequence of code points, run these steps:
</p>

<ol>
 <li>
%入力, %位置 はこの手続きを呼出した~algoの，同じ名前の変数とする。
◎
Let input and position be the same variables as those of the same name in the algorithm that invoked these steps.
</li>

 <li>
%結果 ~LET 空文字列
◎
Let result be the empty string.
</li>

 <li>
~WHILE［
%位置 ~LT %入力 の長さ
］~AND［
%位置 が指す符号位置 ~IN %符号位置~集合
］
⇒
その符号位置を %結果 の末尾に付加する；<br>
%位置 ~INCBY 1
◎
While position does not point past the end of input and the code point at position is one of code points, append that code point to the end of result and advance position to the next code point in input.
</li>

 <li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="algo-head">
`~ASCII空白類を読み飛ばす@
とは、`~ASCII空白類$の並びを`収集-$して，その返値は破棄することを意味する。
◎
To skip ASCII whitespace means to collect a code point sequence of ASCII whitespace and discard the return value.
</p>

<p class="algo-head">
文字列からなる有順序~集合 %S を
`有順序~集合 直列化器@
にかけるときは、［
%S が空~集合ならば 空文字列 ／
~ELSE_ %S 内の各 <!-- EACH --> 文字列を U+0020 区切りで連結した結果
］を返す。
◎
The ordered set serializer takes a set and returns the concatenation of the strings in set, separated from each other by U+0020, if set is non-empty, and the empty string otherwise.
</p>

		</section>
		<section id="selectors">
<h3 title="Selectors">2.4. 選択子</h3>


<p class="algo-head">
文字列 %選択子 を %node の
`視野の下で照合-@
するときは、次を走らす：
◎
To scope-match a selectors string selectors against a node, run these steps:
</p>

<ol>
 <li>
%S ~LET
%選択子 を`選択子として解析-$した結果
`SELECTORS4$r
◎
Let s be the result of parse a selector selectors. [SELECTORS4]
</li>
 <li>
~IF［
%S ~EQ `失敗^i
］
⇒
~THROW `SyntaxError^E
◎
If s is failure, throw a SyntaxError.
</li>
 <li>
~RET
%node を`視野根$に利用する下で、
%node の`根$に対し， %S を`選択子として評価-$した結果
`SELECTORS4$r
◎
Return the result of evaluate a selector s against node’s root using scoping root node. [SELECTORS4].
</li>

</ol>

<p class="note">注記：
選択子の中の~nsに対する~supportは、計画されておらず，追加されることはない。
◎
Support for namespaces within selectors is not planned and will not be added.
</p>

		</section>
		<section id="namespaces">
<h3 title="Namespaces">2.5. ~ns</h3>

<p>
`~HTML~ns@
は
`http://www.w3.org/1999/xhtml^c
である。
◎
The HTML namespace is http://www.w3.org/1999/xhtml.
</p>

<p>
`~SVG~ns@
は
`http://www.w3.org/2000/svg^c
である。
◎
The SVG namespace is http://www.w3.org/2000/svg.
</p>

<p>
`~XML~ns@
は
`http://www.w3.org/XML/1998/namespace^c
である。
◎
The XML namespace is http://www.w3.org/XML/1998/namespace.
</p>

<p>
`~XMLNS~ns@
は
`http://www.w3.org/2000/xmlns/^c
である。
◎
The XMLNS namespace is http://www.w3.org/2000/xmlns/.
</p>


<p class="algo-head">
%名前 を
`有修飾~名として検証-@
するときは、次を走らす：
◎
To validate a qualifiedName, run these steps:
</p>

<ol>
 <li>
~IF［
%名前 は `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError^E
◎
If qualifiedName does not match the Name production, then throw an InvalidCharacterError.
</li>

 <li>
~IF［
%名前 は `QName$prod 生成規則に合致しない
］
⇒
~THROW `NamespaceError^E
◎
If qualifiedName does not match the QName production, then throw a NamespaceError.
</li>
</ol>

<p class="algo-head">
( %~ns, %名前 ) に対し
`検証して抽出-@
するときは、次を走らす：
◎
To validate and extract a namespace and qualifiedName, run these steps:
</p>

<ol>
 <li id="cp-normalize-ns">
~IF［
%~ns ~EQ 空文字列
］
⇒
%~ns ~SET ~NULL
◎
If namespace is the empty string, set it to null.
</li>

 <li>
%名前 を`有修飾~名として検証-$する
（例外投出あり）
◎
Validate qualifiedName. Rethrow any exceptions.
</li>

 <li>
%接頭辞 ~LET ~NULL
◎
Let prefix be null.
</li>

 <li>
%局所名 ~LET %名前
◎
Let localName be qualifiedName.
</li>

 <li>
~IF［
%名前 は `:^l (U+003A) を含む
<span class="trans-note">【 `PrefixedName$prod 生成規則に合致】</span>
］
⇒
( %接頭辞, %局所名 ) ~SET
%名前 をそこで分割して得られる ( 前の部分, 後の部分 )
◎
If qualifiedName contains a ":" (U+003E), then split the string on it and set prefix to the part before and localName to the part after.
</li>

 <li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
↓</p>

  <ul>
   <li>
［
%~ns ~EQ ~NULL
］~AND［
%接頭辞 ~NEQ ~NULL
］
◎
If prefix is non-null and namespace is null, then throw a NamespaceError.
</li>

   <li>
［
%~ns ~NEQ `~XML~ns$
］~AND［
%接頭辞 ~EQ `xml^l
］
◎
If prefix is "xml" and namespace is not the XML namespace, then throw a NamespaceError.
</li>

   <li>
［
%~ns ~NEQ `~XMLNS~ns$
］~AND［［
%名前 ~EQ `xmlns^l
］~OR［
%接頭辞 ~EQ `xmlns^l
］］
◎
If either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace, then throw a NamespaceError.
</li>

   <li>
［
%~ns ~EQ `~XMLNS~ns$
］~AND［
%名前 ~NEQ `xmlns^l
］~AND［
%接頭辞 ~NEQ `xmlns^l
］
◎
If namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns", then throw a NamespaceError.
</li>
  </ul>

<p>
…ならば
⇒
~THROW `NamespaceError^E
◎
↑</p>

 </li>

 <li>
~RET ( %~ns, %接頭辞, %局所名 )
◎
Return namespace, prefix, and localName.
</li>

</ol>


		</section>
	</section>
	<section id="events">

<h2 title="Events">3. ~event</h2>

		<section id="introduction-to-dom-events">

<h3 title="Introduction to “DOM Events”">3.1. “DOM Events” 概説</h3>

<!-- ^@EventTarget -->

<p>
Web ~platformを全体を通して，`~event$は、~network活動や利用者との対話など，何かが生じた際に通達するために，~objに向けて`配送$される。
これらの~objは $EventTarget ~ifcを実装し，
その $addEventListener() を~callすることにより
`~event$を観測するための`~event~listener$を追加できる：
◎
Throughout the web platform events are dispatched to objects to signal an occurrence, such as network activity or user interaction. These objects implement the EventTarget interface and can therefore add event listeners to observe events by calling addEventListener():
</p>

<div class="example">
<pre class="js-code">
%obj.addEventListener("load", imgFetched)

function imgFetched(%ev) {
  // <span class="comment" title="great success">成功裡に load できた</span>
  …
}</pre>

</div>

<p>
`~event~listener$は、
$removeEventListener()
~methに同じ引数を渡すことにより除去できる。
◎
Event listeners can be removed by utilizing the removeEventListener() method, passing the same arguments.
</p>

<!-- ^@Event -->

<p>
`~event$もまた~objであり，
$Event ~ifc（またはその派生~ifc）を実装する。
上の例では、 %ev が`~event$である。
それは `~event~listener$の `callback$i （概して上に示したような JavaScript Function ）に引数として渡される。
`~event~listener$は、まず，`~event$の $type 属性~値（上の例では `load^l ）をその~~制御に利用する。
`~event$の $target 属性~値は`~event$の`配送$先の~obj（上の例の %obj ）を返す。
◎
Events are objects too and implement the Event interface (or a derived interface). In the example above ev is the event. It is passed as argument to event listener’s callback (typically a JavaScript Function as shown above). Event listeners key off the event’s type attribute value ("load" in the above example). The event’s target attribute value returns the object to which the event was dispatched (obj above).
</p>

<p id="synthetic-events">
概して、`~event$は，利用者との対話や何らかの~task完了の結果，~UAにより`配送$されるものであるが、~app自身も`~event$を`配送$できる（合成~eventと共通的に呼ばれている）：
◎
Now while typically events are dispatched by the user agent as the result of user interaction or the completion of some task, applications can dispatch events themselves, commonly known as synthetic events:
</p>

<div class="example"><pre>// <span class="comment" title="add an appropriate event listener">~custom~event~listenerを追加-</span>
obj.addEventListener("cat", function(%e) { process(%e.detail) })

// <span class="comment" title="create and dispatch the event">~eventを作成して配送する</span>
var %event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
%obj.dispatchEvent(%event)</pre></div>

<p>
通達-時の他にも、`~event$は，処理の中で次に起きる出来事を~appに制御させる~~目的で利用されることがある。
例えば，~form~submit処理の一環として、 $type 属性~値が `submit^l の`~event$が`配送$される。
この`~event$の $preventDefault() ~methが呼出されると，~formは~submitされずに終了されることになる。
~appにより`配送$される`~event$（合成~event）を通して，この機能性を利用する場合、 $EventTarget.dispatchEvent() ~methの返値も利用できる：
◎
Apart from signaling, events are sometimes also used to let an application control what happens next in an operation. For instance as part of form submission an event whose type attribute value is "submit" is dispatched. If this event’s preventDefault() method is invoked, form submission will be terminated. Applications who wish to make use of this functionality through events dispatched by the application (synthetic events) can make use of the return value of the dispatchEvent() method:
</p>

<div class="example">

<pre class="js-code">
if(%obj.dispatchEvent(%event)) {
  // <span class="comment" title="event was not canceled, time for some magic">~eventは取消されなかった。手品の時間だ。</span>
  …
}</pre>

</div>

<div class="p">
<p>
`~event$が`木$に`関与-$する~obj（例えば`要素$）に向けて`配送$される場合、その~eventは，その~objの`先祖$ 上の`~event~listener$にも到達し得る：
</p>

<ol>
	<li>
最初は、~objの各 `先祖$に対し，
`capture$i 変数が ~T にされている`~event~listener$が`木~順序$で呼出される。
</li>
	<li>
次に、~obj自身の`~event~listener$が呼出される。
</li>
	<li>
最後に、`~event$の $bubbles 属性~値が true のときにのみ，~objの各 `先祖$に対し
<span class="trans-note">【
`capture$i 変数が ~F にされている
】</span>
`~event~listener$が，今度は`木~順序$の逆順に呼出される。
</li>
</ol>

◎
When an event is dispatched to an object that participates in a tree (e.g. an element), it can reach event listeners on that object’s ancestors too. First all object’s ancestor event listeners whose capture variable is set to true are invoked, in tree order. Second, object’s own event listeners are invoked. And finally, and only if event’s bubbles attribute value is true, object’s ancestor event listeners are invoked again, but now in reverse tree order.
</div>

<div class="example">
<p>
`~event$が`木$内で働く様子を例で示す：
◎
Lets look at an example of how events work in a tree:
</p>

<pre class="html-code">
&lt;!doctype html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Boring example&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;Hello <mark>&lt;span id=x&gt;world&lt;/span&gt;</mark>!&lt;/p&gt;
  &lt;script&gt;
<code
>function test(%event) {
  debug(%event.target, %event.currentTarget, %event.eventPhase); // A
}
document.addEventListener("hey", test, {capture: true}); // B
document.body.addEventListener("hey", test); // C
var %event = new Event("hey", {bubbles:true})
document.getElementById(<mark>"x"</mark>).dispatchEvent(%event);</code>
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre>
<p>
`debug^c 関数（A）は２度~呼出されることになる。
いずれの呼出ingでも、`~event$の $target 属性~値は <mark>`span^c `要素$</mark> になる。
一度目での $currentTarget 属性~値は`文書$になり（B）,
$eventPhase 属性の値が $CAPTURING_PHASE から $BUBBLING_PHASE に切り替わった後,
２度目では `body^e `要素$になる（C）。
もし`~event~listener$が `span^e `要素$にも登録されていたなら、$eventPhase 属性の値は $AT_TARGET にも切り替わることになる。
◎
The debug function will be invoked twice. Each time the event’s target attribute value will be the span element. The first time currentTarget attribute’s value will be the document, the second time the body element. eventPhase attribute’s value switches from CAPTURING_PHASE to BUBBLING_PHASE. If an event listener was registered for the span element, eventPhase attribute’s value would have been AT_TARGET.
</p>
</div>

		</section>
		<section id="interface-event">

<h3>3.2. ~ifc ^@Event</h3>

⇒！
[$Constructor(~DS %type, optional $EventInit %eventInitDict),
Exposed=(Window,Worker)]
interface @Event {
  ~RA ~DS $type;
  ~RA $EventTarget? $target;
  ~RA $EventTarget? $currentTarget;
  sequence&lt;$EventTarget&gt; $composedPath();

  ~CUS $NONE = 0;
  ~CUS $CAPTURING_PHASE = 1;
  ~CUS $AT_TARGET = 2;
  ~CUS $BUBBLING_PHASE = 3;
  ~RA ~US $eventPhase;

  void $stopPropagation();
  void $stopImmediatePropagation();

  ~RA ~B $bubbles;
  ~RA ~B $cancelable;
  void $preventDefault();
  ~RA ~B $defaultPrevented;
  ~RA ~B $composed;

  [Unforgeable] ~RA ~B $isTrusted;
  ~RA $DOMTimeStamp $timeStamp;

  void $initEvent(~DS %type, ~B %bubbles, ~B %cancelable); // <span id="cp-histroic" class="comment" title="historical">歴史上</span>
};

dictionary @EventInit {
  ~B @EventInit.bubbles = false;
  ~B @EventInit.cancelable = false;
  ~B @EventInit.composed = false;
};
◎


<p>
$Event ~objは、単に
`~event@
とも呼ばれる。
それは、何かが生じたときにそれが通達されるようにする
— 例えば，画像を~downloadし終えたときなど。
◎
An Event object is simply named an event. It allows for signaling that something has occurred, e.g., that an image has completed downloading.
</p>

<p>
各`~event$には、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`関係target@</dt>
	<dd>
~NULL または $EventTarget ~obj 。
他が定められない限り， ~NULL とする。
◎
An event has an associated relatedTarget (null or an EventTarget object). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
他の仕様は ^relatedTarget 属性を定義するときに `関係target$を利用する。
`UIEVENTS$r
◎
Other specifications use relatedTarget to define a relatedTarget attribute. [UIEVENTS]
</dd>

	<dt>`経路@</dt>
	<dd>
<p>
いくつかの組からなる~listであり，初期時は空とする。
その各~組は、次のものからなる：
</p>
		<dl class="def-list">
			<dt>`item@i</dt>
			<dd>
$EventTarget ~obj。
</dd>

			<dt>`target@i</dt>
			<dd>
~NULL または $EventTarget ~obj。
</dd>

			<dt>`関係target@i</dt>
			<dd>
~NULL または $EventTarget ~obj。
</dd>
		</dl>

<p>
そのような組を意図して与えられる値は、
組( %item, %target, %関係target )
のように表記される。
</p>

◎
An event has an associated path. A path is a list of tuples, each of which consists of an item (an EventTarget object), target (null or an EventTarget object), and a relatedTarget (null or an EventTarget object). A tuple is formatted as (item, target, relatedTarget). A path is initially the empty list.
</dd>


</dl>

<p>
`適用仕様$は、`~event$に対し
`再targetする手続き@
を定義して~MAY。
この~algoには、下に述べる`配送$~algoに指示される %~event が渡される
◎
Specifications may define retargeting steps for all or some events. The algorithm is passed event, as indicated in the dispatch algorithm below.
</p>


<dl class="domintro">
 <dt>var %event = new $Event(type [, eventInitDict])</dt>
 <dd>
$type 属性~値が %type にされた，新たな %event を返す。
%eventInitDict 引数（省略可）により，~objの同じ名前の~memberを通して
$bubbles と $cancelable 属性も設定し得る。
◎
Returns a new event whose type attribute value is set to type. The optional eventInitDict argument allows for setting the bubbles and cancelable attributes via object members of the same name.
</dd>

 <dt>%event . $type</dt>
 <dd>
%event の型を返す。
例えば
`click^l,
`hashchange^l,
`submit^l
など。
◎
Returns the type of event, e.g. "click", "hashchange", or "submit".
</dd>


 <dt>%event . $target</dt>
 <dd>
%event の`配送$先の~objを返す。
◎
Returns the object to which event is dispatched.
</dd>

 <dt>%event . $currentTarget</dt>
 <dd>
現在~呼出されている `callback$i を持つ`~event~listener$が登録されている~objを返す。
◎
Returns the object whose event listener’s callback is currently being invoked.
</dd>

 <dt>%event . $composedPath()</dt>
 <dd>
%event の`経路$内にある各 `item$i ~obj（それ上で~listenerが呼出される~obj）からなる~listを返す
— ただし、［
`~shadow根$の`~mode$sR ~EQ `closed^l
］なる`~shadow木$内の`~node$であって， %event の $currentTarget からは到達できないものは、返値から除かれる。
◎
Returns the item objects of event’s path (objects on which listeners will be invoked), except for any nodes in shadow trees of which the shadow root’s mode is "closed" that are not reachable from event’s currentTarget.
</dd>

 <dt>%event . $eventPhase</dt>
 <dd>
`~event$の相：
$NONE, $CAPTURING_PHASE, $AT_TARGET, $BUBBLING_PHASE 
のいずれかを返す。
◎
Returns the event’s phase, which is one of NONE, CAPTURING_PHASE, AT_TARGET, and BUBBLING_PHASE.
</dd>

 <dt>%event . $stopPropagation()</dt>
 <dd>
`木$ 内に`配送$されているとき、この~methを呼び出すことにより，現在の~obj以外の~objには %event が到達しないようになる。
◎
When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.
</dd>

 <dt>%event . $stopImmediatePropagation()</dt>
 <dd>
この~methの呼出ingにより、
%event は 現在の~listenerが走り終えた後に登録された`~event~listener$には到達しなくなり、`木$ 内に`配送$されたときには， %event は他のどの~objにも到達しなくなる。
◎
Invoking this method prevents event from reaching any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any other objects.
</dd>

 <dt>%event . $bubbles</dt>
 <dd>
%event がどう初期化されたかに応じて，~T か~F を返す。
%event がその $target 属性~値の`先祖$へ
`木~順序$の逆順にも遡る場合は ~T を返し,
他の場合は~F を返す。
◎
Returns true or false depending on how event was initialized. True if event goes through its target attribute value’s ancestors in reverse tree order, and false otherwise.
</dd>

 <dt>%event . $cancelable</dt>
 <dd>
%event がどう初期化されたかに応じて，~T か~F を返す。
その返値は常に意味を持つとは限らないが、~T の場合，
%event が`配送$されている間の処理が
$preventDefault()
~methの呼出ingにより取消せることを指示し得る。
<!--  -->
◎
Returns true or false depending on how event was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which event was dispatched, can be canceled by invoking the preventDefault() method.
</dd>

 <dt>%event . $preventDefault()</dt>
 <dd>
$cancelable 属性~値が~T のときに呼出されて，
%event に対する~listenerの実行-中に
$AddEventListenerOptions.passive 属性が ~F に設定された場合、
%event が取消される必要がある旨をその`配送$ 処理に通達する。
◎
If invoked when the cancelable attribute value is true, and while executing a listener for the event with passive set to false, signals to the operation that caused event to be dispatched that it needs to be canceled.
</dd>

 <dt>%event . $defaultPrevented</dt>
 <dd>
~T は、 $preventDefault() が呼出され, 成功裡に取消されたことを指示する。
他の場合は~F を返す。
◎
Returns true if preventDefault() was invoked successfully to indicate cancellation, and false otherwise.
</dd>

 <dt>%event . $composed</dt>
 <dd>
%event がどう初期化されたかに依存して ~T か ~F を返す。
［
%event の $target 属性~値の`根$が $ShadowRoot `~node$である
］ときに，その~nodeを過ぎた先†にある~listenerも呼出す場合は ~T になり、他の場合は~F になる。
◎
Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target attribute value, and false otherwise.
</dd>
 <dd>【†
%~event の`経路$が、`~shadow根$の`~host$を通して別の`~node木$へつながるように，構成される。
】</dd>

 <dt>%event . $isTrusted</dt>
 <dd>
%event が~UA から`配送$されたものである場合は~T を,
他の場合は~F を返す。
◎
Returns true if event was dispatched by the user agent, and false otherwise.
</dd>

 <dt>%event . $timeStamp</dt>
 <dd>
%event の作成~時刻を
1970 年 1 月 1 日 00:00:00 UTC
から経過したミリ秒数で返す。
<!-- initEvent is dead --> 
◎
Returns the creation time of event as the number of milliseconds that passed since 00:00:00 UTC on 1 January 1970.
</dd>

</dl>

<dl class="idl-def">
	<dt>@type</dt>
	<dd>
取得子は、初期化時の値を返さ~MUST。
`~event$の作成時には、この属性は空文字列に初期化され~MUST。
◎
The type attribute must return the value it was initialized to. When an event is created the attribute must be initialized to the empty string.
</dd>

	<dt>@target</dt>
	<dt>@currentTarget</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化時の値を返さ~MUST。
`~event$の作成時には、これらの属性は~NULL に初期化され~MUST。
◎
The target and currentTarget attributes must return the values they were initialized to. When an event is created the attributes must be initialized to null.
</dd>

	<dt>@composedPath()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The composedPath() method, when invoked, must run these steps:
</p>

<ol>
 <li>
%~composed経路 ~LET 新たな空~list
◎
Let composedPath be a new empty list.
</li>
 <li>
%経路 ~LET 此れの`経路$
◎
↓</li>
 <li>
%現~target ~LET 此れの $currentTarget 属性~値
◎
Let currentTarget be context object’s currentTarget attribute value.
</li>
 <li>
~IF［
%現~target は`~node$である
］
⇒
~FOR
此れの %経路 内の~EACH( %組 ) に対し
⇒
~IF［
%組 の `item$i は %現~target から`~closed-shadow-hidden$でない
］
⇒
%組 の `item$i を %~composed経路 に付加する
◎
For each tuple in context object’s path:
◎
If currentTarget is a node and tuple’s item is not closed-shadow-hidden from currentTarget, or currentTarget is not a node, then append tuple’s item to composedPath.
</li>
 <li>
~ELSE
⇒
~FOR
此れの %経路 内の~EACH( %組 ) に対し
⇒
%組 の `item$i を %~composed経路 に付加する
◎
↑</li>
 <li>
~RET %~composed経路
◎
Return composedPath.
</li>
</ol>

<p class="note">注記：
この~algoは、`配送$~algoに対する %~target 引数が`~node$でないときは，
%~event 引数の最終的な`経路$内のどの組も，`~node$を包含しないものと見做している。
◎
This algorithm assumes that when the target argument to the dispatch algorithm is not a node, none of the tuples in event argument’s eventual path will contain a node either.
</p>
	</dd>


	<dt>@eventPhase</dt>
	<dd>
<p>
取得子は、初期化時の値を返さ~MUST。
値は、次のいずれかで~MUST：
◎
The eventPhase attribute must return the value it was initialized to, which must be one of the following:
</p>

<dl>
 <dt>@NONE (数値 0)</dt>
 <dd>
まだ`配送$されていない`~event$はこの相に属する。
◎
Events not currently dispatched are in this phase.
</dd>

 <dt>@CAPTURING_PHASE (数値 1)</dt>
<!-- * numeric value -->
 <dd>
`~event$が`木$に`関与-$する~objに向けて`配送$されるとき、~eventがその $target 属性~値に到達するまでは，この相に属する。
◎
When an event is dispatched to an object that participates in a tree it will be in this phase before it reaches its target attribute value.
</dd>

 <dt>@AT_TARGET (数値 2)</dt>
 <dd>
`~event$が`配送$されるとき、~eventの $target 属性~値 上では，この相に属する。
◎
When an event is dispatched it will be in this phase on its target attribute value.
</dd>

 <dt>@BUBBLING_PHASE (数値 3)</dt>
 <dd>
`~event$が`木$に`関与-$する~objに向けて`配送$されるとき、~eventがその $target 属性~値に到達した後は，この相に属する。
◎
When an event is dispatched to an object that participates in a tree it will be in this phase after it reaches its target attribute value.
</dd>
</dl>

	</dd>
	<dd>
<!-- Initially -->
`~event$の作成時には、この属性は $NONE に初期化され~MUST。
◎
Initially the attribute must be initialized to NONE.
</dd>
</dl>

<p>
各`~event$には、次の~flag（すべて初期時~OFF ）が結付けられる：
◎
Each event has the following associated flags that are all initially unset:
</p>

<div >
<ul><li>`伝播停止@f
</li><li>`伝播即停止@f
</li><li>`被取消@f
</li><li>`受動~listener内@f
</li><li>`~composed@f
</li><li>`初期化済み@f
</li><li>`配送@f
</li></ul>

◎
stop propagation flag
◎
stop immediate propagation flag
◎
canceled flag
◎
in passive listener flag
◎
composed flag
◎
initialized flag
◎
dispatch flag
</div>


<dl class="idl-def">
	<dt>@stopPropagation()</dt>
	<dd>
被呼出時には、次を設定し~MUST
⇒
此れの`伝播停止$f ~SET ~ON
◎
The stopPropagation() method, when invoked, must set the context object’s stop propagation flag.
</dd>

	<dt>@stopImmediatePropagation()</dt>
	<dd>
被呼出時には、次を設定し~MUST
⇒
此れの`伝播停止$f ~SET ~ON；<br>
此れの`伝播即停止$f ~SET ~ON
◎
The stopImmediatePropagation() method, when invoked, must set context object’s stop propagation flag and context object’s stop immediate propagation flag.
</dd>

	<dt>@bubbles</dt>
	<dt>@cancelable</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化時の値を返さ~MUST。
◎
The bubbles and cancelable attributes must return the values they were initialized to.
</dd>

	<dt>@preventDefault()</dt>
	<dd>
被呼出時には、次をし~MUST
⇒
~IF［
此れの $cancelable 属性~値 ~EQ ~T
］~AND［
此れの`受動~listener内$f ~EQ ~OFF
］
⇒
此れの`被取消$f ~SET ~ON
◎
The preventDefault() method, when invoked, must set the canceled flag if the cancelable attribute value is true and the in passive listener flag is unset.
</dd>
	<dd class="note">注記：
これは、 $preventDefault() を呼出しても効果がない局面もあることを意味する。
~UAには、~debugを援助するため，精確な~~原因を開発者~consoleに~logすることが奨励される。
◎
This means there are scenarios where invoking preventDefault() has no effect. User agents are encouraged to log the precise cause in a developer console, to aid debugging.
</dd>

	<dt>@defaultPrevented</dt>
	<dd>
取得子は、［
此れの`被取消$f ~EQ ~ON ならば ~T ／
~ELSE_~F
］を返さ~MUST。
◎
The defaultPrevented attribute’s getter must return true if context object’s canceled flag is set, and false otherwise.
</dd>

	<dt>@composed</dt>
	<dd>
取得子は、［
此れの`~composed$f ~EQ ~ON ならば ~T ／
~ELSE_~F
］を返さ~MUST。
◎
The composed attribute’s getter must return true if context object’s composed flag is set, and false otherwise.
</dd>

	<dt>@isTrusted</dt>
	<dd>
取得子は、初期化時の値を返さ~MUST。
`~event$の作成時には、この属性は~F に初期化され~MUST。
◎
The isTrusted attribute must return the value it was initialized to. When an event is created the attribute must be initialized to false.
</dd>

	<dt>@timeStamp</dt>
	<dd>
取得子は、初期化時の値を返さ~MUST。
`~event$の作成時には、この属性は 1970 年 1 月 1 日 00:00:00 UTC から経過した，閏秒を含まないミリ秒数に初期化され~MUST。
<span class="trans-note">【
JavaScript の `Date^c も同様に閏秒を無視する。
】</span>
<!-- leap seconds are ignored by JavaScript too -->
◎
The timeStamp attribute must return the value it was initialized to. When an event is created the attribute must be initialized to the number of milliseconds that have passed since 00:00:00 UTC on 1 January 1970, ignoring leap seconds.
</dd>
	<dd class="XXX">
これは、変更される見込みが高く，すでに実装を反映しなくなっている。
詳細は
<a href="https://github.com/whatwg/dom/issues/23">dom #23</a>
を見られたし。
◎
This is highly likely to change and already does not reflect implementations well. Please see dom #23 for more details.
</dd>
</dl>


<p class="algo-head">
%event を
( %type, %bubbles, %cancelable )
で
`初期化-@
するときは、
%event の各種［
~flag, 属性
］を次のように初期化し~MUST：
◎
To initialize an event, with type, bubbles, and cancelable, run these steps:
</p>

<ul>
 <li>
`初期化済み$f ~SET ~ON
◎
Set the initialized flag.
</li>

 <li>
( `伝播停止$f, `伝播即停止$f, `被取消$f ) ~SET ( ~OFF, ~OFF, ~OFF )
◎
Unset the stop propagation flag, stop immediate propagation flag, and canceled flag.
</li>

 <li>
$isTrusted 属性 ~SET ~F
◎
Set the isTrusted attribute to false.
</li>

 <li>
$target 属性 ~SET ~NULL
◎
Set the target attribute to null.
</li>

 <li>
$type 属性 ~SET %type
◎
Set the type attribute to type.
</li>

 <li>
$bubbles 属性 ~SET %bubbles
◎
Set the bubbles attribute to bubbles.
</li>

 <li>
$cancelable 属性 ~SET %cancelable
◎
Set the cancelable attribute to cancelable.
</li>
</ul>


<dl class="idl-def">
	<dt>@initEvent(type, bubbles, cancelable)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The initEvent(type, bubbles, cancelable) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
此れの`配送$f ~EQ ~ON
］
⇒
~RET
◎
If context object’s dispatch flag is set, then return.
</li>

 <li>
此れを
( %type, %bubbles, %cancelable )
で`初期化-$する
◎
Initialize context object with type, bubbles, and cancelable. 
</li>

</ol>

	</dd>
	<dd class="note">注記：
$initEvent() は、`~event$が構築子を持つので冗長であり，また $composed も設定できないが、旧来の内容のために~supportされる必要がある。
◎
As events have constructors initEvent() is redundant and incapable of setting composed. It has to be supported for legacy content.
</dd>
</dl>


		</section>
		<section id="interface-customevent">

<h3>3.3. ~ifc ^@CustomEvent</h3>

⇒！
[$Constructor(~DS %type, optional $CustomEventInit %eventInitDict),
Exposed=(Window,Worker)]
interface @CustomEvent : $Event {
  ~RA any $detail;

  void $initCustomEvent(~DS %type, ~B %bubbles, ~B %cancelable, any %detail);
};

dictionary @CustomEventInit : $EventInit {
  any @CustomEventInit.detail = null;
};
◎

<!-- ^@CustomEvent -->
<p>
~custom~dataを運ばせる用途に，
$CustomEvent ~ifcを利用する`~event$を利用できる。
◎
Events using the CustomEvent interface can be used to carry custom data.
</p>

<dl class="domintro">
 <dt>var %event = new $CustomEvent(type [, eventInitDict])</dt>
 <dd>
%eventInitDict 引数（省略可）により，
$detail 属性も設定できることを除き、
$Event の構築子と同様にふるまう。
◎
Works analogously to the constructor for Event except that the optional eventInitDict argument now allows for setting the detail attribute too.
</dd>

 <dt>%event . $detail</dt>
 <dd>
%event の作成時に与えられた~custom~dataを返す。
概して，合成~eventで利用される。
<!-- initCustomEvent is dead -->
◎
Returns any custom data event was created with. Typically used for synthetic events.
</dd>

</dl>

<dl class="idl-def">
	<dt>@detail</dt>
	<dd>
取得子は、初期化時の値を返さ~MUST。
◎
The detail attribute must return the value it was initialized to.
</dd>

	<dt>@initCustomEvent(type, bubbles, cancelable, detail)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The initCustomEvent(type, bubbles, cancelable, detail) method must, when invoked, run these steps:
</p>

<ol>
 <li>
~IF［
此れの`配送$f ~EQ ~ON
］
⇒
~RET
◎
If context object’s dispatch flag is set, terminate these steps.
</li>

 <li>
此れを
( %type, %bubbles, %cancelable )
で`初期化-$する
◎
Initialize the context object with type, bubbles, and cancelable.
</li>

 <li>
此れの $detail 属性 ~SET %detail
◎
Set context object’s detail attribute to detail.
</li>
</ol>

	</dd>
</dl>

		</section>
		<section id="constructing-events">

<h3 title="Constructing events">3.4. ~eventの構築法</h3>

<dl class="idl-def">
	<dt>@Event.Event(type, eventInitDict)</dt>
	<dt>@CustomEvent.CustomEvent(type, eventInitDict)</dt>
<dd>
<p id="concept-event-constructor">
$Event ~ifc, または それを継承する~ifcの構築子の被呼出時には、次を走らせ~MUST：
◎
When a constructor of the Event interface, or of an interface that inherits from the Event interface, is invoked, these steps must be run:
</p>

<ol>
 <li>
%event ~LET 呼出された構築子の~ifcを利用する，新たな`~event$
◎
Create an event that uses the interface the constructor was invoked upon.
</li>

 <li>
%event の`初期化済み$f ~SET ~ON
◎
Set its initialized flag.
</li>

 <li>
%event の $Event.type 属性 ~SET %type 引数に初期化-
◎
Initialize the type attribute to the type argument.
</li>

 <li>
~IF［
%eventInitDict 引数は与えられている
］
⇒
~FOR
その引数に在する~EACH ( `辞書~member$ %m ) に対し
⇒
~IF［
%event は %m の key を`識別子$とする属性を持つ
］
⇒
その属性~値 ~SET %m の値
◎
If there is an eventInitDict argument, then for each dictionary member present, find the attribute on event whose identifier matches the key of the dictionary member and then set the attribute to the value of that dictionary member.
</li>

 <li>
~RET %event
◎
Return the event.
</li>
</ol>

	</dd>
</dl>

		</section>
		<section id="defining-event-interfaces">

<h3 title="Defining event interfaces">3.5. ~event~ifcの定義法</h3>

<p>
一般に、$Event を継承する新たな~ifcを定義する際には，常に
<a href="https://whatwg.org/">WHATWG</a>
または
<a href="https://www.w3.org/2008/webapps/">W3C WebApps WG</a>
~communityからの~feedbackを仰ぐように願う。
◎
In general, when defining a new interface that inherits from Event please always ask feedback from the WHATWG or the W3C WebApps WG community.
</p>

<p>
$CustomEvent ~ifcはその起点に利用できるものだが、 `init*Event()^c の類いの~methは，構築子とかぶって冗長になるので導入しないように。
$Event ~ifcを継承する~ifcがその種の~methを備えているのは、歴史的な理由に限られている。
◎
The CustomEvent interface can be used as starting point. However, do not introduce any init*Event() methods as they are redundant with constructors. Interfaces that inherit from the Event interface that have such a method only have it for historical reasons.
</p>

		</section>
		<section id="interface-eventtarget">

<h3>3.6. ~ifc ^@EventTarget</h3>

⇒！
[Exposed=(Window,Worker)]
interface @EventTarget {
  void $addEventListener(~DS %type, $EventListener? %callback, optional ($AddEventListenerOptions or ~B) %options);
  void $removeEventListener(~DS %type, $EventListener? %callback, optional ($EventListenerOptions or ~B) %options);
  ~B $dispatchEvent($Event %event);
};

callback interface @EventListener {
  void @EventListener.handleEvent($Event %event);
};

dictionary @@EventListenerOptions {
  boolean @capture = false;
};

dictionary @@AddEventListenerOptions : $EventListenerOptions {
  boolean @passive = false;
  boolean @once = false;
};
◎

<p>
$@EventTarget ~objは、何かが起きた時に`~event$が`配送$される~targetを表現する。
◎
The EventTarget object represents the target to which an event is dispatched when something has occurred.
</p>

<p>
各 $EventTarget ~objには、いくつかの~event~listenerからなる，
`~listener~list@
が結付けられる。
◎
Each EventTarget object has an associated list of event listeners.
</p>

<p>
`~event~listener@
を利用すれば、特定の`~event$を観測できる。
◎
An event listener can be used to observe a specific event.
</p>

<p>
各`~event~listener$は、次の~fieldからなる：
◎
An event listener consists of these fields:
</p>

<ul>
	<li>
`type@i
— 文字列
◎
type (a string)
</li>
	<li>
`callback@i
— $EventListener
◎
callback (an EventListener)
</li>
	<li>
`capture@i
— 真偽値（初期時は ~F ）
◎
capture (a boolean, initially false)
</li>
	<li>
`passive@i
— 真偽値（初期時は ~F ）
◎
passive (a boolean, initially false)
</li>
	<li>
`once@i
— 真偽値（初期時は ~F ）
◎
once (a boolean, initially false) 
</li>
	<li>
`removed@i
— 内部処理用の真偽値（初期時は ~F ）
◎
removed (a boolean for bookkeeping purposes, initially false) 
</li>
</ul>


<p class="note">注記：
上の~fieldに示したように， `callback$i は $EventListener であるが、`~event~listener$は，より幅広い概念である。
◎
Although callback is an EventListener, as can be seen from the fields above, an event listener is a broader concept.
</p>

<p>
各 $EventTarget ~objには、`~event$が与えられた下で，~objの
`親~targetを取得-@
する~algoも結付けられる。
それは、［
$EventTarget ~obj, または ~NULL
］を返す。
他から指定されない限り， ~NULL を返す。
◎
Each EventTarget object also has an associated get the parent algorithm, which takes an event event, and returns an EventTarget object. Unless specified otherwise it returns null.
</p>

<p class="note">注記：
［
`~node$ ／ `~shadow根$ ／ `文書$
］は、`親~targetを取得-$する~algoを上書きする。
◎
Nodes, shadow roots, and documents override the get the parent algorithm.
</p>

<p class="trans-note">【
この~algoは、~eventの`配送$時にその伝播`経路$を構築するために利用される。
】</p>


<dl class="domintro">
 <dt>%target . $addEventListener(type, callback [, options])</dt>
 <dd>
 <!-- ^@Event -->
［
$type 属性~値が %type である`~event$
］に対する`~event~listener$を， %target の`~listener~list$に付加する。
%callback 引数が，`~event$が`配送$されたときに呼出される `callback$i として設定される。
◎
Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
</dd>
 <dd>
%options 引数は、~listener特有の~optionを設定する。
互換性のため、これはただの真偽値もとり得る
— その場合、この~methは，正確に［
%options の ^capture ~memberに その値が指定された
］かのように挙動する。
◎
The options argument sets listener-specific options. For compatibility this can be just a boolean, in which case the method behaves exactly as if the value was specified as options’ capture member.
</dd>
 <dd>
%options の $EventListenerOptions.capture ~memberが［
~T ／ ［
~F または不在
］］の場合、
`callback$i は，［
`~event$の $eventPhase 属性~値が［
$BUBBLING_PHASE ／  $CAPTURING_PHASE 
］の間は，呼出されない
］ようになる。
いずれにせよ、`~event$の $eventPhase 属性~値が $AT_TARGET のときは，
`callback$i は呼出される。
◎
When set to true, options’ capture member prevents callback from being invoked when the event’s eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event’s eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event’s eventPhase attribute value is AT_TARGET.
</dd>
 <dd>
%options の $AddEventListenerOptions.passive ~memberに対する ~T は、
`callback$i は $preventDefault() を呼出しても`~event$を取消さないことを指示する。
これは、
<a href="#observing-event-listeners">~event~listenerの観測法</a>
に述べる処理能の最適化を可能化するために利用される
◎
When set to true, options’ passive member indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in §3.7 Observing event listeners.
</dd>

<!-- ^@EventTarget -->
 <dd>
%options の $AddEventListenerOptions.once ~memberが ~T に設定されている場合、~callbackが呼出されるのは一度限りであり，その後には`~event~listener$は除去されることを指示する。
◎
When set to true, options’s once member indicates that the callback will only be invoked once after which the event listener will be removed.
</dd>

 <dd>
`~event~listener$は、重複しない場合（
`type$i, `callback$i, `capture$i
のいずれかが異なる場合）に限り，
%target の`~listener~list$に付加される。
◎
The event listener is appended to target’s list of event listeners and is not appended if it is a duplicate, i.e., having the same type, callback, and capture values.
</dd>

 <dt>%target . $removeEventListener(type, callback [, options])</dt>
 <dd>
引数と同じ［
`type$i, `callback$i, `capture$i
］を持つ`~event~listener$を
%target の`~listener~list$から除去する。
◎
Remove the event listener in target’s list of event listeners with the same type, callback, and options.
</dd>

 <dt>%target . $dispatchEvent(event)</dt>
 <dd>
合成~event %event を %target に向けて`配送$する。
［
 <!-- ^@Event -->
%event の $cancelable 属性~値が ~F であるか, または
%event の $preventDefault() ~methが呼出されていないとき
］は~T，他の場合は~F を返す。
◎
Dispatches a synthetic event event to target and returns true if either event’s cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.
</dd>

</dl>

 <!-- ^@EventTarget -->


<p class="algo-head">
%options を
`平坦化-@
するときは、次を走らす：
◎
To flatten options, run these steps:
</p>

<ol>
 <li>
%capture ~LET ~F
◎
Let capture be false.
</li>
 <li>
~IF［
%options は ~B 型である
］
⇒
%capture ~SET %options
◎
If options is a boolean, set capture to options.
</li>
 <li>
~IF［
%options は辞書~型である
］
⇒
%capture ~SET %options の $EventListenerOptions.capture ~member値
◎
If options is a dictionary, then set capture to options’s capture.
</li>
 <li>
~RET %capture
◎
Return capture and passive.
</li>
</ol>


<p>
%options を
`もっと平坦化-@
するときは、次を走らす：
◎
To flatten more options, run these steps:
</p>

<ol>
 <li id="cp-let-capture-flatten">
%capture ~LET
%options を `平坦化-$した結果
◎
Let capture be the result of flattening options.
</li>
 <li>
( %once, %passive ) ~LET ( ~F, ~F )
◎
Let once and passive be false.
</li>
 <li>
~IF［
%options は辞書~型である
］
⇒
( %passive, %once ) ~SET
%options の
( $AddEventListenerOptions.passive, $AddEventListenerOptions.once )
~member値
◎
If options is a dictionary, then set passive to options’s passive and once to options’s once.
</li>
 <li>
~RET
( %capture, %passive, %once )
◎
Return capture, passive, and once.
</li>
</ol>

<dl class="idl-def">
	<dt>@addEventListener(type, callback, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The addEventListener(type, callback, options) method, when invoked, must run these steps:
</p>

<ol>
 <li>
<p id="cp-ever-been-evaluated">
~IF［
此れに`関連する大域~obj$ %G は $ServiceWorkerGlobalScope ~objである
］~AND［
%G に結付けられている`~service~worker$の`~script資源$の，`評価されたことがある~flag$ ~EQ ~ON
］`SERVICE-WORKERS$r
⇒
~THROW `TypeError^E
◎
If context object’s relevant global object is a ServiceWorkerGlobalScope object and its associated service worker’s script resource’s has ever been evaluated flag is set, then throw a TypeError. [SERVICE-WORKERS]
</p>

<p class="note">注記：
当の~service~workerに対し許容される~event型の格納を最適化するため, および
~event~listenerに対する非決定的な変更を避けるため、この~methの呼出は，~service~worker~scriptが初めて評価される間にのみ許容される。
◎
To optimize storing the event types allowed for the service worker and to avoid non-deterministic changes to the event listeners, invocation of the method is allowed only during the very first evaluation of the service worker script.
</p>
 </li>
 <li>
~IF［
%callback ~EQ ~NULL
］
⇒
~RET
◎
If callback is null, terminate these steps.
</li>
	<li>
( %capture, %passive, %once ) ~LET
%options を`もっと平坦化-$した結果
◎
Let capture, passive, and once be the result of flattening more options.
</li>
	<li>
~IF［
此れの`~listener~list$内に［
( `type$i, `callback$i, `capture$i )
~EQ
( %type, %callback, %capture )
］なる`~event~listener$が在る
］
⇒
~RET
◎
↓</li>

 <li>
次のように設定された`~event~listener$を，此れの`~listener~list$に付加する
⇒
`type$i ~SET %type ,<br>
`callback$i ~SET %callback ,<br>
`capture$i ~SET %capture ,<br>
`passive$i ~SET %passive ,<br>
`once$i ~SET %once
◎
If context object’s associated list of event listener does not contain an event listener whose type is type, callback is callback, and capture is capture, then append a new event listener to it, whose type is type, callback is callback, capture is capture, passive is passive, and once is once.
</li>

</ol>
	</dd>

	<dt>@removeEventListener(type, callback, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeEventListener(type, callback, options) method, when invoked, must, run these steps
</p>

<ol>
 <li><!--cp-ever-been-evaluated--></li>
 <!--cp-let-capture-flatten-->
 <li>
<p>
~IF［
此れの`~listener~list$内に［
( `type$i, `callback$i, `capture$i )
~EQ
( %type, %callback, %capture )
］なる`~event~listener$ %~listener が在る
］：
</p>
  <ol>
   <li>
%~listener を`~listener~list$から除去する
</li>
   <li>
%~listener の `removed$i ~SET ~T
</li>
  </ol>
◎
If there is an event listener in the associated list of event listeners whose type is type, callback is callback, and capture is capture, then set that event listener’s removed to true and remove it from the associated list of event listeners.
 </li>
</ol>
	</dd>

	<dt>@dispatchEvent(event)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The dispatchEvent(event) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%event の`配送$f ~EQ ~ON
］~OR［
%event の`初期化済み$f ~EQ ~OFF
］
⇒
~THROW `InvalidStateError^E
◎
If event’s dispatch flag is set, or if its initialized flag is not set, then throw an InvalidStateError.
</li>

 <li>
 <!-- ^@Event -->
%event の $isTrusted 属性 ~SET ~F に初期化-
◎
Initialize event’s isTrusted attribute to false.
</li>

 <li>
~RET 此れに向けて %event を`配送$した結果
◎
Return the result of dispatching event to context object.
</li>
</ol>
	</dd>
</dl>


		</section>
		<section id="observing-event-listeners">

<h3 title="Observing event listeners">3.7. ~event~listenerの観測法</h3>

<p>
一般に、開発者は，`~event~listener$の有無が観測され得るものとは予期しない。
`~event~listener$の影響0は、その `callback$i により決定される。
すなわち開発者は、何もしない`~event~listener$を追加するとき，副作用が生じるとは予期しない。
◎
In general, developers do not expect the presence of an event listener to be observable. The impact of an event listener is determined by its callback. That is, a developer adding a no-op event listener would not expect it to have any side effects.
</p>

<p>
あいにく，一部の~event API は、効率的に実装するためには，`~event~listener$の観測が要求される設計になっている。
すなわち、空の~listenerであっても，~appの挙動における処理能に劇的に影響0し得る結果、~listenerの有無が観測され得るようになっている。
例えば ~touch／~wheel ~eventの利用は、非同期~scrollingを阻むことがある。
一部の事例では、この問題は，［
~eventが $cancelable になるのは，非 $AddEventListenerOptions.passive ~listenerが一つ以上あるときに限る
］ように指定することで、軽減できる。
例えば、非 $AddEventListenerOptions.passive $TouchEvent ~listenerは，~scrollingを阻ま~MUSTが、すべての~listenerが $AddEventListenerOptions.passive ならば、
<span class="trans-note">【~UAは】</span>
$TouchEvent を（ $preventDefault() の~callは無視されるように）取消せなくすることで，~scrollingを`並列的$に開始できるようになる。
なので、~eventを配送している~codeは，非 $AddEventListenerOptions.passive ~listenerの~~不在を観測でき、それを利用して配送~中の~eventの $cancelable ~propを ~F にできる。
◎
Unfortunately, some event APIs have been designed such that implementing them efficiently requires observing event listeners. This can make the presence of listeners observable in that even empty listeners can have a dramatic performance impact on the behavior of the application. For example, touch and wheel events which can be used to block asynchronous scrolling. In some cases this problem can be mitigated by specifying the event to be cancelable only when there is at least one non-passive listener. For example, non-passive TouchEvent listeners must block scrolling, but if all listeners are passive then scrolling can be allowed to start in parallel by making the TouchEvent uncancelable (so that calls to preventDefault() are ignored). So code dispatching an event is able to observe the absence of non-passive listeners, and use that to clear the cancelable property of the event being dispatched.
</p>

<p>
新たなどの~event API も，この~propを必要としないように定義されるのが理想的である（論を交わしたければ
<a href="https://lists.w3.org/Archives/Public/public-script-coord/">public-script-coord@<!---->w3.org</a>
を利用されたし）。
◎
Ideally, any new event APIs are defined such that they do not need this property (use public-scrip-coord@w3.org for discussion).
</p>


		</section>
		<section id="dispatching-events">

<h3 title="Dispatching events">3.8. ~eventの配送法</h3>

<!-- ^@Event -->

<p class="algo-head">
%上書target （省略可）が与えられた下で、所与の %target に向けて，`~event$ %~event を
`配送@
するときは、次を走らす：
◎
To dispatch an event to a target, with an optional targetOverride, run these steps:
</p>

<ol>
 <li>
%~event の`配送$f ~SET ~ON
◎
Set event’s dispatch flag.
</li>

 <li>
<p>
~IF［
%上書target は与えられていない
］
⇒
%上書target ~SET %target
◎
If targetOverride is not given, let targetOverride be target.
</p>

<p class="note">注記：
%上書target は、 HTML からのみ，それも ごく限られた~~状況に限って利用される。
◎
The targetOverride argument is only used by HTML and only under very specific circumstances.
</p>
 </li>

 <li>
%関係target ~LET %~event の`関係target$
◎
↓</li>
 <li>
~IF［
%~event の`関係target$ ~NEQ ~NULL
］
⇒
%関係target ~SET %target に対し %関係target を`再target$した結果
◎
Let relatedTarget be the result of retargeting event’s relatedTarget against target if event’s relatedTarget is non-null, and null otherwise.
</li>

 <li>
%~event の`経路$に
組( %target, %上書target, %関係target )
を付加する
◎
Append (target, targetOverride) to event’s path.
</li>

 <li>
%親 ~LET
%~event を与える下で， %target の`親~targetを取得-$した結果
◎
Let parent be the result of invoking target’s get the parent with event.
</li>

 <li>
<p>
~WHILE［
%親 ~NEQ ~NULL
］：
◎
While parent is non-null:
</p>
  <ol>
   <li>
%関係target ~LET %~event の`関係target$
◎
↓</li>
   <li>
~IF［
%~event の`関係target$ ~NEQ ~NULL
］
⇒
%関係target ~SET %親 に対し %関係target を`再target$した結果
◎
Let relatedTarget be the result of retargeting event’s relatedTarget against parent if event’s relatedTarget is non-null, and null otherwise.
</li>
   <li>
~IF［
%target の`根$ は %親 の`~shadowも含む広義先祖$である
］
⇒
%~event の`経路$に
組( %親, ~NULL, %関係target )
を付加する
◎
If target’s root is a shadow-including inclusive ancestor of parent, then append (parent, null, relatedTarget) to event’s path.
</li>
   <li>
~ELIF［
%親 ~EQ %関係target
］
⇒
%親 ~SET ~NULL
◎
Otherwise, if parent and relatedTarget are identical, then set parent to null.
</li>
   <li>
~ELSE
⇒
%target ~SET %親；<br>
%~event の`経路$に
組( %親, %target, %関係target )
を付加する
◎
Otherwise, set target to parent and append (parent, target, relatedTarget) to event’s path.
</li>
	<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
%親 ~SET %~event を与える下で， %親 の`親~targetを取得-$した結果
◎
If parent is non-null, then set parent to the result of invoking parent’s get the parent with event. 
</li>
  </ol>

<p class="trans-note">【
%~event の`経路$はこの段で確定され、以降の手続きで~event~listenerにより~DOMが改変されても，影響されない。
】</p>

 </li>

 <li>
%~event の $eventPhase 属性 ~SET $CAPTURING_PHASE
◎
Set event’s eventPhase attribute to CAPTURING_PHASE.
</li>

 <li>
<p>
~FOR
%~event の`経路$内の~EACH ( %組 ) に対し，逆順に：
◎
For each tuple in event’s path, in reverse order:
</p>
  <ol>
   <li id="cp-last-non-null-target">
%~event の $target 属性 ~SET %~event の`経路$内の［
%組 または %組 に先行する組
］のうち，［
`target$i ~NEQ ~NULL
］なるもののうち，最後の組の `target$i
◎
Set event’s target attribute to the target of the last tuple in event’s path, that is either tuple or preceding tuple, whose target is non-null.
</li>
   <li id="cp-set-relatedTarget">
%~event の`関係target$ ~SET %組 の `関係target$i
◎
Set event’s relatedTarget to tuple’s relatedTarget.
</li>
   <li id="cp-retargeting-steps">
%~event に対し`再targetする手続き$を走らす
◎
Run the retargeting steps with event.
</li>
   <li>
~IF［
%組 の `target$i ~EQ ~NULL
］
⇒
%組 の `item$i を %~event で`呼出す$
◎
If tuple’s target is null, then invoke tuple’s item with event.
</li>
  </ol>
 </li>

 <li>
<p>
~FOR
%~event の`経路$内の~EACH ( %組 ) に対し，順に：
◎
For each tuple in event’s path, in order:
</p>
  <ol>
   <!--cp-last-non-null-target-->
   <!--cp-set-relatedTarget-->
   <!--cp-retargeting-steps-->
   <li>
%~event の $eventPhase 属性 ~SET ［
%組 の `target$i ~NEQ ~NULL ならば $AT_TARGET ／
~ELSE_ $BUBBLING_PHASE
］
◎
If tuple’s target is non-null, then set event’s eventPhase attribute to AT_TARGET.
◎
Otherwise, set event’s eventPhase attribute to BUBBLING_PHASE.
</li>
   <li>
~IF［［
%~event の $eventPhase 属性 ~EQ $BUBBLING_PHASE
］~AND［
%~event の $bubbles 属性 ~EQ ~T
］］~OR［
%~event の $eventPhase 属性 ~EQ $AT_TARGET
］
⇒
%組 の `item$i を %~event で`呼出す$
◎
If either event’s eventPhase attribute is BUBBLING_PHASE and event’s bubbles attribute is true or event’s eventPhase attribute is AT_TARGET, then invoke tuple’s item with event. 
</li>
  </ol>
 </li>

 <li>
%~event の
( `配送$f, `伝播停止$f, `伝播即停止$f ) ~SET ( ~OFF, ~OFF, ~OFF )
◎
Unset event’s dispatch flag, stop propagation flag, and stop immediate propagation flag.
</li>

 <li>
%~event の $eventPhase 属性 ~SET $NONE
◎
Set event’s eventPhase attribute to NONE.
</li>

 <li>
%~event の $currentTarget 属性 ~SET ~NULL
◎
Set event’s currentTarget attribute to null.
</li>

 <li>
%~event の`経路$ ~SET 空~list
◎
Set event’s path to the empty list.
</li>

 <li>
~RET ［
%~event の`被取消$f ~EQ ~ON ならば ~F ／
~ELSE_ ~T
］
◎
Return false if event’s canceled flag is set, and true otherwise.
</li>

</ol>


<p class="algo-head">
%~obj を`~event$ %~event で
`呼出す@
ときは、次を走らす：
◎
To invoke an object with event, run these steps:
</p>


<ol>

 <li>
~IF［
%~event の`伝播停止$f ~EQ ~OFF
］
⇒
~RET
◎
If event’s stop propagation flag is set, then terminate these steps.
</li>

 <li>
%~listener~list ~LET 空~list
◎
Let listeners be the empty list.
</li>


 <li>
<p>
%~obj の`~listener~list$内の ~EACH ( `~event~listener$ %~listener ) に対し
⇒
%~listener への~pointerを %~listener~list に付加する
◎
For each event listener associated with object, append a pointer to the event listener to listeners.
</p>

<p class="note">注記：
これは、この時点以降に追加された~event~listenerは，走らせないようにする。
除去については、 `removed$i ~fieldに因り，依然として効果を及ぼすことに注意。
◎
This avoids event listeners added after this point from being run. Note that removal still has an effect due to the removed field.
</p>
 </li>

 <li>
%~event の $currentTarget 属性 ~SET %~obj に初期化-
◎
Initialize event’s currentTarget attribute to object.
</li>

 <li>
%found ~LET %~obj を %~event で`内部的に呼出した$結果
◎
Let found be the result of running inner invoke object with event.
</li>

 <li>
<p>
~IF［
%found ~EQ ~F
］~AND［
%~event の $type 属性~値は［
下の表のいずれかの行の 1 列目の文字列
］に `~ASCII大小無視$で合致する
］…：
◎
If found is false, run these substeps:
◎
Let originalEventType be event’s type attribute value.
◎
If event’s type attribute value is a match for any of the strings in the first column in the following table, set event’s type attribute value to the string in the second column on the same row as the matching string, and terminate these substeps otherwise.
</p>

<table>
<thead><tr><th>~event型◎Event type
<th>旧来の~event型◎Legacy event type
</th></tr></thead>

<tbody><tr><td>`animationend^l
</td><td>`webkitAnimationEnd^l 

</td></tr><tr><td>`animationiteration^l
</td><td>`webkitAnimationIteration^l 

</td></tr><tr><td>`animationstart^l
</td><td>`webkitAnimationStart^l 

</td></tr><tr><td>`transitionend^l
</td><td>`webkitTransitionEnd^l 
</td></tr></tbody></table>

<p>
…ならば：
</p>

  <ol>
   <li>
%元~event型 ~LET %~event の $type 属性~値
◎
↑</li>
   <li>
%~event の $type 属性~値 ~SET 同じ行の 2 列目の文字列
◎
↑</li>
   <li>
%~obj を %~event で`内部的に呼出す$
◎
Inner invoke object with event.
</li>
   <li>
%~event の $type 属性~値 ~SET %元~event型
◎
Set event’s type attribute value to originalEventType.
</li>
  </ol>
 </li>
</ol>

<p class="algo-head">
%~obj を %~event で
`内部的に呼出す@
ときは、次を走らす：
◎
To inner invoke an object with event, run these steps:
</p>

<ol>
 <li>
%found ~LET ~F
◎
Let found be false.
</li>
 <li>
<p>
~FOR
%~listener~list 内の ~EACH ( `~event~listener$ %~listener ) に対し：
◎
For each listener in listeners, whose removed is false, run these substeps:
</p>
  <ol>
   <li>
~IF［
%~listener の `removed$i ~EQ ~F
］
⇒
~CONTINUE
◎
↑</li>
   <li>
~IF［
%~listener の `type$i ~NEQ %~event の $type 属性~値
］
⇒
~CONTINUE
◎
If event’s type attribute value is not listener’s type, terminate these substeps (and run them for the next event listener).
</li>
   <li>
%found ~SET ~T
◎
Set found to true.
</li>
   <li>
~IF［
%~listener の `capture$i ~EQ ~F
］~AND［
%~event の $eventPhase 属性~値 ~EQ $CAPTURING_PHASE
］
⇒
~CONTINUE
◎
If event’s eventPhase attribute value is CAPTURING_PHASE and listener’s capture is false, terminate these substeps (and run them for the next event listener).
</li>
   <li>
~IF［
%~listener の `capture$i ~EQ ~T
］~AND［
%~event の $eventPhase 属性~値 ~EQ $BUBBLING_PHASE
］
⇒
~CONTINUE
◎
If event’s eventPhase attribute value is BUBBLING_PHASE and listener’s capture is true, terminate these substeps (and run them for the next event listener).
</li>
   <li>
~IF［
%~listener の `once$i ~EQ ~T
］
⇒
%~listener を %~obj の`~listener~list$から除去する
◎
If listener’s once is true, then remove listener from object’s associated list of event listeners.
</li>
   <li>
~IF［
%~listener の `passive$i ~EQ ~T
］
⇒
%~event の`受動~listener内$f ~SET ~ON
◎
If listener’s passive is true, set event’s in passive listener flag.
</li>
   <li>
<p>
次を与える下で，`利用者~objの演算を~call$する：
</p>

<ul ><li>%~listener の `callback$i
</li><li>`handleEvent^l
</li><li>引数~list： ( %~event )
</li><li>`~callback this 値$： %~event の$currentTarget 属性~値
</li></ul>

<p>
~IF［
~callした結果，例外が投出された
］
⇒
`その例外を報告する$
</p>

◎
Call a user object’s operation with listener’s callback, "handleEvent", a list of arguments consisting of event, and event’s currentTarget attribute value as the callback this value. If this throws an exception, report the exception.
</li>
   <li>
%~event の`受動~listener内$f ~SET ~OFF
◎
Unset event’s in passive listener flag.
</li>
   <li>
~IF［
%~event の`伝播即停止$f ~EQ ~ON
］
⇒
~RET %found
◎
If event’s stop immediate propagation flag is set, return found.
</li>
  </ol>
 </li>
 <li>
~RET %found
◎
Return found.
</li>
</ol>


		</section>
		<section id="firing-events">

<h3 title="Firing events">3.9. ~eventの発火法</h3>

<div class="p">
<p class="algo-head">
~obj %O に向けて，名前 %e の~eventを
`発火-@
するとは、次のようにされた新たな`~event$を作成した上で，それを %O に向けて`配送$することを意味する：
</p>

<ul ><li>`~event$は $@Event ~ifcを利用する
</li><li>$type 属性 ~SET %e に初期化-
</li><li>$isTrusted 属性 ~SET ~T に初期化-
</li></ul>

◎
To fire an event named e means that a new event using the Event interface, with its type attribute initialized to e, and its isTrusted attribute initialized to true, is to be dispatched to the given object.
</div>


<p class="note">注記：
~DOMの文脈における~eventの “`発火-$” とは、`~event$の［
作成-, 初期化-, `配送$
］処理の略語であり，この処理過程を記述し易くするものである。
`~event$の
$bubbles や $cancelable
属性も初期化する記述も必要な場合は、
“^cancelable 属性を~T に初期化した上で， ^submit ~eventを`発火-$する”
等々の様に記述することもできる。
◎
Fire in the context of DOM is short for creating, initializing, and dispatching an event. Fire an event makes that process easier to write down. If the event needs its bubbles or cancelable attribute initialized, one could write "fire an event named submit with its cancelable attribute initialized to true".
</p>

		</section>
		<section id="action-versus-occurance">
<h3 title="Action versus occurrence">3.10. 動作 vs. 発生</h3>

<p>
`~event$は、動作（ action ）ではなく，発生（ occurrence ）をしるす（ signify する）ものである。
言葉を代えれば、~algoからの~~通知を表現し，その~algoの進路に（例えば $preventDefault() の呼出ingを通して）働きかけるために利用できるものである。
`~event$は、何らかの~algoを走らすような［
動作／動作を~~起動するもの
］として利用されては~MUST_NOT。
そのような用途のためのものではない。
◎
An event signifies an occurrence, not an action. Phrased differently, it represents a notification from an algorithm and can be used to influence the future course of that algorithm (e.g., through invoking preventDefault()). Events must not be used as actions or initiators that cause some algorithm to start running. That is not what they are for.
</p>

<p class="note">注記：
ここで特に~~強調している~~理由は、以前の~DOMでは，`~event$に “既定の動作” の概念が結付けられていて，人を誤った考えに~~導いていたからである。
`~event$は、動作を表現したり, 引き起こすものではなく，進行中~のものに働きかけるために限って利用できるものである。
◎
This is called out here specifically because previous iterations of the DOM had a concept of "default actions" associated with events that gave folks all the wrong ideas. Events do not represent or cause actions, they can only be used to influence an ongoing one.
</p>

<p class="trans-note">【
<!--  仕様~策定者~向けの記述？ -->
<a href="~SPECBUGS?id=12230">参考</a>
】</p>

		</section>
	</section>
	<section id="nodes">

<h2 title="Nodes">4. ~node</h2>

		<section id="introduction-to-the-dom">

<h3 title="Introduction to “The DOM”">4.1. ~DOM概説</h3>


<p>
~DOM（ “The DOM（ Document Object Model ）” ）は元々，文書（特に，~HTML文書や~XML文書）に対する~accessと操作のための API を意味するものであったが、この仕様における語  “文書” は、短い静的な文書から 多彩な~multimediaを伴う長い小論や報告書，更には本格的な対話的~appまでに渡る、任意の~markupに基づく資源を指すものとして用いられる。
◎
In its original sense, "The DOM" is an API for accessing and manipulating documents (in particular, HTML and XML documents). In this specification, the term "document" is used for any markup-based resource, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications.
</p>
<p>
そのような各~文書は、`~node木$として表現される。
これらの`~node$のうち一部は他の`~node$を`子$に持ち，他のものは葉（末端）~nodeになる。
◎
Each such document is represented as a node tree. Some of the nodes in a tree can have children, while others are always leaves.
</p>

<div class="example">
<p>
次の~HTML文書を例に~~説明する：
◎
To illustrate, consider this HTML document:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;html class=e&gt;
 &lt;head&gt;&lt;title&gt;Aliens?&lt;/title&gt;&lt;/head&gt;
 &lt;body&gt;Why yes.&lt;/body&gt;
&lt;/html&gt;</pre>

<p>
これは次のように表現される：
◎
It is represented as follows:
</p>

<ol class="domTree">
 <li>
  `文書$
  <ol>
   <li class="t10">`文書型$： `DOCTYPE html^c</li>
   <li class="t1">`要素$： `html^e <span class="t2">`class^c=`e^l</span>
    <ol>
     <li class="t1">
      `要素$： `head^e
      <ol>
       <li class="t1">
        `要素$： `title^e
        <ol>
         <li class="t3">$Text： <samp>Aliens?</samp></li>
        </ol>
       </li>
      </ol>
     </li>
     <li class="t3">$Text： <samp>⏎␣</samp></li>
     <li class="t1">
      `要素$： `body^e
      <ol>
       <li class="t3">$Text: <samp>Why yes.⏎</samp></li>
      </ol>
     </li>
    </ol>
   </li>
  </ol>
 </li>
</ol>

</div>

<p>
`~HTML解析器$の~~仕組みから，すべての`~ASCII空白類$が $Text `~node$にされてはいないが、一般的な概念は明らかである。
~~入力の~markupから，`~node$たちが成す`木$が出来上がる。
<!-- You /can/ explain that! harharhar --> 
◎
Note that, due to the magic that is HTML parsing, not all ASCII whitespace were turned into Text nodes, but the general concept is clear. Markup goes in, a tree of nodes comes out.
</p>
<p class="note">注記：
さらに探求してみたければ、最高によくできている
<a href="http://software.hixie.ch/utilities/js/live-dom-viewer/">Live DOM Viewer</a>
を利用するといい。
◎
The most excellent Live DOM Viewer can be used to explore this matter in more detail.
</p>

		</section>
		<section id="node-trees">

<h3 title="Node tree">4.2. ~node木</h3>

<div class="p">
<p>
次に挙げる~ifcを実装する~objが、`木$に`関与-$する：
</p>

<ul ><li>$Document
</li><li>$DocumentType
</li><li>$DocumentFragment
</li><li>$Element
</li><li>$Text
</li><li>$ProcessingInstruction
</li><li>$Comment
</li></ul>

<p>
これらは総称して、単に
`~node@
と呼ばれる。
また、これらが成す木は，
`~node木@
と称される。
</p>

◎
Document, DocumentType, DocumentFragment, Element, Text, ProcessingInstruction, and Comment objects (simply called nodes) participate in a tree, simply named the node tree.
</div>


<p id="_tree-constraints_">
`~node木$には、`~node$の型とそれに許容される`子$との関係性で表される，次の拘束が課される：
◎
A node tree is constrained as follows, expressed as a relationship between the type of node and its allowed children:
</p>

<dl>
 <dt>$Document</dt>
 <dd>

<p>
`木~順序$において，次からなる：
◎
In tree order:
</p>
  <ol>
   <li id="cp-comments-or-PI">
それぞれが $ProcessingInstruction または $Comment である， 0 個以上の~node
◎
Zero or more nodes each of which is ProcessingInstruction or Comment.
</li>

   <li>
0 個または 1 個の $DocumentType ~node
◎
Optionally one DocumentType node.
</li>

   <!--cp-comments-or-PI-->
   <li>
0 個または 1 個の $Element ~node
◎
Optionally one Element node.
</li>

   <!--cp-comments-or-PI-->
  </ol>
 </dd>

 <dt>$DocumentFragment</dt>
 <dt>$Element</dt>
 <dd>
それぞれが $Element, $ProcessingInstruction, $Comment, $Text のいずれかである， 0 個以上の~nodeからなる
◎
Zero or more nodes each of which is Element, Text, ProcessingInstruction, or Comment.
</dd>

 <dt>$DocumentType</dt>
 <dt>$Text</dt>
 <dt>$ProcessingInstruction</dt>
 <dt>$Comment</dt>
 <dd>
子を持たない
◎
None.
</dd>
</dl>

<p class="algo-head">
`~node$ %node の
`~length@
とは、 %node の型に応じて，次で与えられる整数である：
◎
To determine the length of a node node, switch on node: 
</p>

<dl class="switch">

 <dt>$DocumentType</dt>
 <dd>
0
◎
Zero.
</dd>

 <dt>`文字~data~node$◎Text, ProcessingInstruction, Comment</dt>
 <dd>
その`~data$内の`符号単位$の個数
◎
The number of code units in its data.
</dd>

<!-- 他の~node -->
 <dt>$Document</dt>
 <dt>$DocumentFragment</dt>
 <dt>$Element</dt>
 <dd>
その`子$の個数
◎
Its number of children.
</dd>

</dl>

<p>
`~node$が
`空@
であるとは、その`~length$が 0 であることを意味する。
◎
A node is considered empty if its length is zero.
</p>


			<section id="document-trees">
<h4 title="Document tree">4.2.1.文書~木</h4>

<p>
`根$が`文書$であるような`~node木$を
`文書~木@
という。
◎
A document tree is a node tree whose root is a document.
</p>

<p>
`文書$ %D の
`文書~要素@
とは、［
%D を`親$とするような`要素$があれば それ ／
~ELSE_ ~NULL
］である。
◎
The document element of a document is the element whose parent is that document, if it exists, and null otherwise.
</p>

<p class="note">注記：
`~node木$の拘束から、そのような`要素$は唯一つに決まる。
<span class="trans-note">【
例えば`~HTML文書$ならば `html^e 要素。
】</span>
◎
Per the node tree constraints, there can be only one such element.
</p>

<p>
`要素$は、その`根$が`文書$であるとき，
`文書~木~内@
にあるとされる。
◎
An element is in a document tree if its root is a document.
</p>

<p>
`文書~木~内$にある`要素$は、
`文書~内@
にあるともいう。
<span class="note">
用語 `文書~内$は、もはや利用されないものと想定されている。
この用語は、それを利用している標準が，まだ`~shadow木$を織り込むよう更新されていないことを指示する。
</span>
◎
An element is in a document if it is in a document tree. The term in a document is no longer supposed to be used. It indicates that the standard using it has not been updated to account for shadow trees.
</p>


			</section>
			<section id="shadow-trees">
<h4 title="Shadow tree">4.2.2. ~shadow木</h4>

<p>
`根$が`~shadow根$であるような`~node木$は
`~shadow木@
という。
◎
A shadow tree is a node tree whose root is a shadow root.
</p>

<p>
`~shadow根$は常に，その`~host$を通して別の`~node木$に添付けられる。
したがって，`~shadow木$が~~孤立することは決してない。
`~shadow根$の`~host$の`~node木$は、
`~light木@
と呼ばれることもある。
◎
A shadow root is always attached to another node tree through its host. A shadow tree is therefore never alone. The node tree of a shadow root’s host is sometimes referred to as the light tree.
</p>

<p class="note">注記：
`~shadow木$に対応する`~light木$は、それ自身`~shadow木$になり得る。
◎
A shadow tree’s corresponding light tree can be a shadow tree itself.
</p>

<p class="trans-note">【
“~shadow” と違って， “~light” の定義は相対的であり、ある~node木~単独で “~lightである” とは言えない。
】【
“shadow／light” ＝ “日陰／日なた”, “暗／明”
】</p>

<p id="in-a-shadow-including-document">
`要素$は、その`~shadowも含む根$が`文書$であるとき，
`接続され@
ているという。
◎
An element is connected if its shadow-including root is a document.
</p>


				<section id="shadow-tree-slots">
<h5 title="Slots">4.2.2.1. ~slot</h5>

<p>
各`~shadow木$は、
`~slot@
と呼ばれる 0 個以上の`要素$を包含する。
◎
A shadow tree contains zero or more elements that are slots.
</p>

<p class="note">注記：
`~slot$は HTML の `slot$e 要素を通してのみ作成される。
◎
A slot can only be created through HTML’s slot element.
</p>

<p>
各 `~slot$には、文字列である
`~slot名@
が結付けられる
— 他が定められない限り，空文字列とする。
◎
A slot has an associated name (a string). Unless stated otherwise it is the empty string.
</p>


<p class="algo-head">
`~slot$の`~slot名$の更新~時に利用する，`属性0を変更する手続き$は、次で与えられる：
◎
Use these attribute change steps to update a slot’s name:
</p>

<ol>
 <li>
<p>
~IF［
%要素 は `~slot$である
］~AND［
%局所名 ~EQ `name^l
］~AND［
%~ns ~EQ ~NULL
］：
◎
If element is a slot, localName is name, and namespace is null, then:
</p>
  <ol>
   <li id="cp-ret-if-null-empty">
~IF［
( %値, %旧-値 ) は、次のいずれかを満たす
］…：

<ul ><li>%値 ~EQ %旧-値
</li><li>［
%値 ~IN { ~NULL, 空文字列 }
］~AND［
%旧-値 ~IN { ~NULL, 空文字列 }
］
</li></ul>

…ならば
⇒
~RET
◎
If value is oldValue, then return.
◎
If value is null and oldValue is the empty string, then return.
◎
If value is the empty string and oldValue is null, then return.
</li>
   <li>
%要素 の`~slot名$ ~SET［
%値 ~IN { ~NULL, 空文字列 } ならば 空文字列 ／
~ELSE_ %値
］
◎
If value is null or the empty string, then set element’s name to the empty string.
◎
Otherwise, set element’s name to value.
</li>
   <li>
%要素 の`木$に `~slotableたちを割当する$tree
◎
Run assign slotables for a tree with element’s tree.
</li>
 </ol>
</li>
</ol>


<p class="note">注記：
`~shadow木$内の，［
`~slot名$ ~EQ 空文字列
］なる`~slot$のうち，`木~順序$で最初のものは
“既定の~slot”
と呼ばれることもある。
◎
The first slot in a shadow tree, in tree order, whose name is the empty string, is sometimes known as the "default slot".
</p>

<p>
各 `~slot$には、`~slotable$の~listが結付けられる
— 他が定められない限り，空とする。
この~listを指して，`~slot$に
`割当されている~nodeたち@
（ assigned nodes ）という。
◎
A slot has an associated assigned nodes (a list of slotables). Unless stated otherwise it is empty.
</p>


				</section>
				<section id="light-tree-slotables">
<h5 title="Slotables">4.2.2.2. ~slotable</h5>

<p>
［
$Element ／ $Text
］`~node$は、
`~slotable@
である。
◎
Element and Text nodes are slotables.
</p>


<p class="note">注記：
`~slot$も、`~slotable$になり得る。
◎
A slot can be a slotable.
</p>

<p class="trans-note">【
~slotは “はめ込み口”，
~slotableは “はめ込める物”。
】</p>

<p>
各 `~slotable$には、文字列である
`~slotable名@
が結付けられる。
他が定められない限り，空文字列とする。
◎
A slotable has an associated name (a string). Unless stated otherwise it is the empty string.
</p>

<p class="algo-head">
`~slotable$の`~slotable名$の更新~時に利用する，`属性0を変更する手続き$は、次で与えられる：
◎
Use these attribute change steps to update a slotable’s name:
</p>

<ol>
 <li>
<p>
~IF［
%局所名 ~EQ `slot^l
］~AND［
%~ns ~EQ ~NULL
］：
◎
If localName is slot and namespace is null, then:
</p>
  <ol>
   <!--cp-ret-if-null-empty-->
   <li>
%要素 の`~slotable名$ ~SET［
%値 ~IN { ~NULL, 空文字列 } ならば 空文字列 ／
~ELSE_ %値
］
◎
If value is null or the empty string, then set element’s name to the empty string.
◎
Otherwise, set element’s name to value.
</li>
   <li>
~IF［
%要素 の`割当先~slot$ ~NEQ ~NULL
］
⇒
その`~slot$に `~slotableたちを割当する$
◎
If element is assigned, then run assign slotables for element’s assigned slot.
</li>
   <li>
%要素 に対し，`~slotを割当先にする$
◎
Run assign a slot for element.
</li>
  </ol>
 </li>
</ol>

<p>
各 `~slotable$には、
`割当先~slot@
（ assigned slot ）と称される，［
`~slot$, または ~NULL
］が結付けられる。
他が定められない限り，割当先は ~NULL とする。
`割当先~slot$が ~NULL でない`~slotable$は、
`割当先がある@†
（ is assigned ）という。
◎
A slotable has an associated assigned slot (null or a slot). Unless stated otherwise it is null. A slotable is assigned if its assigned slot is non-null.
</p>

<p class="trans-note">【
すなわち、自身がどの`~slot$に割当されるかを指示する。
】【†
この訳では、この語は利用せず，もっぱら前者の語を利用して記す。
】</p>


				</section>
				<section id="finding-slots-and-slotables">
<h5 title="Finding slots and slotables">4.2.2.3. ~slot ／ ~slotableの見出法</h5>

<p class="algo-head">
［
`~open^f （省略時は ~OFF ）
］が与えられた下で，`~slotable$ %~slotable から
`~slotを見出す@
ときは、次を走らす：
◎
To find a slot for a given slotable slotable and an optional open flag (unset unless stated otherwise), run these steps:
</p>

<ol>
 <li>
~IF［
%~slotable の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If slotable’s parent is null, then return null.
</li>
 <li>
%~shadow ~LET %~slotable の`親$の`~shadow根$elm
◎
Let shadow be slotable’s parent’s shadow root.
</li>
 <li>
~IF［
%~shadow ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If shadow is null, then return null.
</li>
 <li>
~IF［
`~open^f ~EQ ~ON
］~AND［
%~shadow の`~mode$sR ~NEQ `open^l
］
⇒
~RET ~NULL
◎
If the open flag is set and shadow’s mode is not "open", then return null.
</li>
 <li>
~RET %~shadow の`木$内の`~slot$のうち，［
その`~slot名$ ~EQ %~slotable の`~slotable名$
］なる`最初0$のもの
◎
Return the first slot in shadow’s tree whose name is slotable’s name, if any, and null otherwise.
</li>
</ol>

<p class="algo-head">
`~slot$ %~slot から
`~slotableたちを見出す@
ときは、次を走らす：
◎
To find slotables for a given slot slot, run these steps:
</p>

<ol>
 <li>
%結果 ~LET 空~list
◎
Let result be an empty list.
</li>
 <li>
~IF［
%~slot の`根$は`~shadow根$でない
］
⇒
~RET %結果
◎
If slot’s root is not a shadow root, then return result.
</li>
 <li>
%~host ~LET %~slot の`根$の`~host$
◎
Let host be slot’s root’s host.
</li>
 <li>
<p>
~FOR
%~host の ~EACH ( `~slotable$である`子$ %~slotable ) に対し，`木~順序$で：
◎
For each slotable child of host, slotable, in tree order, run these substeps:
</p>
  <ol>
   <li>
~IF［
%~slot ~EQ %~slotable から`~slotを見出-$した結果
］
⇒
%~slotable を %結果 に付加する
◎
Let foundSlot be the result of finding a slot given slotable.
◎
If foundSlot is slot, then append slotable to result.
</li>
  </ol>
 </li>
 <li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="algo-head">
`~slot$ %~slot から
`平坦化された~slotableたちを見出す@
ときは、次を走らす：
◎
To find flattened slotables for a given slot slot, run these steps:
</p>

<ol>
 <li>
%結果 ~LET 空~list
◎
Let result be an empty list.
</li>
 <li>
%~slotable~list ~LET
%~slot から`~slotableたちを見出-$した結果
◎
Let slotables be the result of finding slotables given slot.
</li>
 <li>
~IF［
%~slotable~list は空である
］
⇒
~FOR
%~slot の ~EACH ( `子$ %子 ) に対し，`木~順序$で
⇒
~IF［
%子 は`~slotable$である
］
⇒
%子 を %~slotable~list に付加する
◎
If slotables is the empty list, then append each slotable child of slot, in tree order, to slotables.
</li>
 <li>
<p>
~FOR
%~slotable~list 内の ~EACH ( %~node ) に対し：
◎
For each node in slotables, run these substeps:
</p>
  <ol>
   <li>
<p>
~IF［
%~node は`~slot$である
］
⇒
~FOR［
%~node から`平坦化された~slotableたちを見出-$した結果
］内の ~EACH ( `~slotable$ %~slotable ) に対し，順に
⇒
%~slotable を %結果 に付加する
◎
If node is a slot, run these subsubsteps:
◎
Let temporaryResult be the result of finding flattened slotables given node.
◎
Append each slotable in temporaryResult, in order, to result.
</li>
   <li>
~ELSE
⇒
%~node を %結果 に付加する
◎
Otherwise, append node to result.
</li>
  </ol>
 </li>
 <li>
~RET %結果
◎
Return result.
</li>
</ol>

				</section>

				<section id="assigning-slotables-and-slots">
<h5 title="Assigning slotables and slots">4.2.2.4. ~slotableたち／~slotの割当法</h5>

<p class="algo-head">
%通達抑止~flag （省略時は ~OFF ）が与えられた下で，
`~slot$ %~slot に
`~slotableたちを割当する@
ときは、次を走らす：
◎
To assign slotables, for a slot slot with an optional suppress signaling flag (unset unless stated otherwise), run these steps:
</p>


<ol>
 <li>
%~slotable~list ~LET
%~slot から`~slotableたちを見出-$した結果
◎
Let slotables be the result of finding slotables for slot.
</li>
 <li>
~IF［
%通達抑止~flag ~EQ ~OFF
］~AND［
%~slotable~list と %~slot に`割当されている~nodeたち$とは、一致しない
<!-- ＊
順序は関係ある？ない？
-->
］
⇒
%~slot に対し，`~slotの変化を通達する$
◎
If suppress signaling flag is unset, and slotables and slot’s assigned nodes are not identical, then run signal a slot change for slot.
</li>
 <li>
%~slot に`割当されている~nodeたち$ ~SET %~slotable~list
◎
Set slot’s assigned nodes to slotables.
</li>
 <li>
~FOR
%~slotable~list 内の ~EACH ( %~slotable ) に対し
⇒
%~slotable の`割当先~slot$ ~SET %~slot
◎
For each slotable in slotables, set slotable’s assigned slot to slot.
</li>
</ol>

<p class="algo-head">
［
`~slot$の集合 `通達しない~slotたち^V （省略時は空）
］が与えられた下で，`木$ %木 に
`~slotableたちを割当する@tree
ときは、次を走らす：
◎
To assign slotables for a tree, given a tree tree and an optional set of slots noSignalSlots (empty unless stated otherwise), run these steps for each slot slot in tree, in tree order:
</p>

<ol>
 <li>
<p>
~FOR
%木 内の
~EACH ( `~slot$ %~slot ) に対し，`木~順序$で：
◎
↑</p>
  <ol>
   <li>
%通達抑止~flag ~LET［
%~slot ~IN `通達しない~slotたち^V ならば ~ON ／
~ELSE_ ~OFF
］
◎
Let suppress signaling flag be set, if slot is in noSignalSlots, and unset otherwise.
</li>
   <li>
%通達抑止~flag を与える下で，
%~slot に `~slotableたちを割当する$
◎
Run assign slotables for slot with suppress signaling flag.
</li>
  </ol>
 </li>
</ol>



<p class="algo-head">
`~slotable$ %~slotable に対し，
`~slotを割当先にする@
ときは、次を走らす：
◎
To assign a slot, given a slotable slotable, run these steps:
</p>

<ol>
 <li>
%~slot ~LET %~slotable から`~slotを見出-$した結果
◎
Let slot be the result of finding a slot with slotable.
</li>
 <li>
~IF［
%~slot ~NEQ ~NULL
］
⇒
%~slot に `~slotableたちを割当する$
◎
If slot is non-null, then run assign slotables for slot.
</li>
</ol>

				</section>
				<section id="signaling-slot-change">
<h5 title="Signaling slot change">4.2.2.5. ~slot変化の通達法</h5>
<p>
各
`互いに関係するかつ生成元も類似する閲覧文脈~群$
`HTML$r
%閲覧文脈~群
は、
`通達~slot~list@
を持つ。
それは，`~slot$たちからなる~listであり、他が定められない限り，空とする。
◎
Each unit of related similar-origin browsing contexts has a signal slot list (a list of slots). Unless stated otherwise it is empty. [HTML]
</p>

<p class="algo-head">
`~slot$ %~slot に対し，
`~slotの変化を通達する@
ときは、次を走らす：
◎
To signal a slot change, for a slot slot, run these steps:
</p>
<ol>
 <li>
~IF［
%~slot ~NIN %閲覧文脈~群 の`通達~slot~list$
］
⇒
%~slot を %閲覧文脈~群 の`通達~slot~list$に付加する
◎
If slot is not in unit of related similar-origin browsing contexts' signal slot list, append slot to unit of related similar-origin browsing contexts' signal slot list.
</li>
 <li>
~IF［
%~slot の`割当先~slot$ ~NEQ ~NULL
］
⇒
その割当先~slotに対し，`~slotの変化を通達する$
◎
If slot is assigned, then run signal a slot change for slot’s assigned slot.
</li>
 <li>
~ELIF［
%~slot の`親$は`~slot$である
］~AND［
%~slot の`親$に`割当されている~nodeたち$は 空~listである
］
⇒
%~slot の`親$に対し，`~slotの変化を通達する$
◎
Otherwise, if slot’s parent is a slot and slot’s parent’s assigned nodes is the empty list, then run signal a slot change for slot’s parent.
</li>
 <li>
`変異~ob 複合~極小taskを待入する$
◎
Queue a mutation observer compound microtask.
</li>
</ol>
				</section>
			</section>
			<section id="mutation-algorithms">

<h4 title="Mutation algorithms">4.2.3. 変異~algo</h4>

<!--% 挿入検証 -->
<p class="algo-head">
%node を %親 の中で %子 の前に
`挿入し得るかどうか検証する@
ときは、次を走らす：
◎
To ensure pre-insertion validity of a node into a parent before a child, run these steps:
</p>

<!-- Step 1-5 could be shared with concept-node-pre-insert, although step 3
     in pre-insert is a superset (which is fine). Step 6.1.1 could also be
     shared. -->

<ol>

 <li id="cp-throw-if-chardata">
~IF［
%親 は
$Document, $DocumentFragment, $Element `~node$のいずれでもない
］
⇒
~THROW `HierarchyRequestError^E
◎
If parent is not a Document, DocumentFragment, or Element node, throw a HierarchyRequestError.
</li>


 <li id="cp-throw-if-iAN">
~IF［
%node は %親 の`~hostも含む広義先祖$である
］
⇒
~THROW `HierarchyRequestError^E
◎
If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.
</li>

 <li>
~IF［
%子 ~NEQ ~NULL
］~AND［
%子 の`親$ ~NEQ %親
］
⇒
~THROW `NotFoundError^E
◎
If child is not null and its parent is not parent, then throw a NotFoundError.
</li>

 <li id="cp-throw-if-not-doc">
<p>
~IF［
%node は
$DocumentFragment, $DocumentType, $Element, $Text, $ProcessingInstruction, $Comment `~node$
のいずれでもない
］
⇒
~THROW `HierarchyRequestError^E
</p>

<p class="trans-note">【
すなわち “^Document ~nodeである”（何故そのように記されない？）
】</p>

◎
If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or Comment node, throw a HierarchyRequestError.
</li>

 <li id="cp-throw-if-mismatch1">
<p>
~IF［
次のいずれかが満たされる
］
⇒
~THROW `HierarchyRequestError^E
：
</p>
  <ul>
   <li>
［
%node は $Text `~node$ である
］~AND［
%親 は`文書$である
］
</li>
   <li>
［
%node は`文書型$である
］~AND［
%親 は`文書$でない
］
</li>
  </ul>
◎
If either node is a Text node and parent is a document, or node is a doctype and parent is not a document, throw a HierarchyRequestError.
</li>

 <li>
<p id="cp-throw-if-doc-etc">
~IF［
%親 は`文書$である
］~AND［
%node の型に応じて，以下が満たされる
］
⇒
~THROW `HierarchyRequestError^E
◎
If parent is a document, and any of the statements below, switched on node, are true, throw a HierarchyRequestError.
</p>

  <dl class="switch">
   <dt>`文書片$</dt>
   <dd>
<p>
次のいずれかが満たされる：
</p>
    <ul>
     <li id="cp-has-Text-child">
%node は $Text `~node$を`子$に持つ
◎
↓</li>
     <li id="cp-has-element-children">
%node は複数個の`要素$を`子$に持つ
◎
If node has more than one element child or has a Text node child.
</li>
     <li>
<p id="cp-has-an-element-and">
［
%node は 1 個の`要素$を`子$に持つ
］~AND［
次のいずれかが満たされる
］：
</p>
<!-- "inclusively following" -->
<ul id="cp-has-other-doctype"
	><li>%親 は`要素$を`子$に持つ
</li><li>%子 は`文書型$である
</li><li>［
%子 ~NEQ ~NULL
］~AND［
%子 に`後続-$する`文書型$が在る
］
</li></ul>

◎
Otherwise, if node has one element child and either parent has an element child, child is a doctype, or child is not null and a doctype is following child.
</li>
    </ul>
   </dd>

   <dt>`要素$</dt>
   <dd>
<p>
次のいずれかが満たされる：
</p>
    <!--cp-has-other-doctype-->

<!-- "inclusively following" -->
◎
parent has an element child, child is a doctype, or child is not null and a doctype is following child.
   </dd>

   <dt>`文書型$</dt>
   <dd>
<p>
次のいずれかが満たされる：
</p>

<ul>
	<li>%親 は`文書型$を`子$に持つ</li>
	<li>
［
%子 ~EQ ~NULL
］~AND［
%子 に`先行-$する`要素$が在る
］
</li>
	<li>
［
%子 ~EQ ~NULL
］~AND［
%親 は`要素$を`子$に持つ
］
</li>
</ul>

◎
parent has a doctype child, child is non-null and an element is preceding child, or child is null and parent has an element child.
   </dd>
  </dl>
 </li>
</ol>

<!--% 前挿入 -->
<p class="algo-head">
%親 の中で， %node を %子 の前に
`前挿入@
するときは、次を走らす：
◎
To pre-insert a node into a parent before a child, run these steps:
</p>

<ol>
 <li>
%node を %親の中で %子 の前に`挿入し得るかどうか検証する$
◎
Ensure pre-insertion validity of node into parent before child.
</li>

 <li>
%基準~子 ~LET %子
◎
Let reference child be child.
</li>

 <li id="cp-set-next-sibling">
~IF［
%基準~子 ~EQ %node
］
⇒
%基準~子 ~SET %node の`弟$
◎
If reference child is node, set it to node’s next sibling.
</li>
<!-- 
【 "If reference child is a node"？】
 -->

 <li id="cp-adopt">
%node を %親 の `~node文書$に`受入-$する
◎
Adopt node into parent’s node document.
</li>

 <li>
%親 の中で， %node を %基準~子 の前に`挿入-$する
◎
Insert node into parent before reference child.
</li>

 <li>
~RET %node
<!-- technically this is post-insert -->
◎
Return node.
</li>
</ol>


<p>
`適用仕様$は、すべてまたは一部の`~node$に対する
`挿入-時の手続き@
を定義して~MAY。
その~algoには、下の`挿入$~algoにて指示される，挿入される~nodeが渡される。
◎
Specifications may define insertion steps for all or some nodes. The algorithm is passed insertedNode, as indicated in the insert algorithm below.
</p>


<!--% 挿入 -->
<p class="algo-head">
`抑止ob^f（省略時は ~OFF ）が与えられた下で，
%親 の中で， %node を %子 の前に
`挿入-@
するときは、次を走らす：
◎
To insert a node into a parent before a child, with an optional suppress observers flag, run these steps:
</p>

<ol>
 <li>
%count ~LET ［
%node は`文書片$であるならば %node の`子$の個数 ／
~ELSE_ 1
］
◎
Let count be the number of children of node if it is a DocumentFragment node, and one otherwise.
</li>

 <li>
<p>
~IF［
%子 ~NEQ ~NULL
］
⇒
~FOR
~EACH ( `範囲0$ %R ) に対し：
◎
If child is non-null, run these substeps:
</p>

  <ol>
   <li>
~IF［
%R の`始点~node$ ~EQ %親
］~AND［
%R の`始点~offset$ ~GT %子 の`指数$
］
⇒
%R の`始点~offset$ ~INCBY %count
◎
For each range whose start node is parent and start offset is greater than child’s index, increase its start offset by count.
</li>

   <li>
~IF［
%R の`終点~node$ ~EQ %親
］~AND［
%R の`終点~offset$ ~GT %子 の`指数$†
］
⇒
%R の`終点~offset$ ~INCBY %count
◎
For each range whose end node is parent and end offset is greater than child’s index, increase its end offset by count.
</li>
  </ol>

<p class="trans-note">【†
挿入される地点にちょうど一致する［
範囲0の`境界点$
］は、それが`終点$であっても，影響されないことになる
— すなわち，挿入-後は 挿入された~nodeの直前を指す。
その結果，この~algoを利用している後述の`置換-$においては、除去される~nodeの直後または内部を指していた範囲0の境界点は，置換-後は 新たに挿入された~nodeの直前を指すようにされる（~node木の先頭／末尾から相対的な範囲0の始点／終点の位置変化のふるまいが，対称でない — 同様のことは，`~dataを置換-$の~algoにも該当する）。
】</p>
 </li>

 <li id="cp-let-nodes">
%nodes ~LET ［
%node は`文書片$であるならば %node のすべての`子$ ／
~ELSE_ %node のみ
］からなる
<span class="trans-note">【木~順序の】</span>
~list
◎
Let nodes be node’s children if node is a DocumentFragment node, and a list containing solely node otherwise.
</li>

 <li>
~IF［
%node は`文書片$である
］
⇒
~FOR
%node の~EACH ( `子$ ) に対し<!-- 順序は関係なし -->
⇒
［
`抑止ob^f: ~ON
］を与える下で，それを %node から`除去-$する
◎
If node is a DocumentFragment node, remove its children with the suppress observers flag set.
</li>

 <li>

<p>
~IF［
%node は`文書片$である
］
⇒
%node に対する次の様な `childList^l の変異~記録を`待入する$
⇒
除去済nodes: %nodes
◎
If node is a DocumentFragment node, queue a mutation record of "childList" for node with removedNodes nodes.
</p>

<p class="note">注記：
この段では意図的に `抑止ob^f を~~無視する。
◎
This step intentionally does not pay attention to the suppress observers flag.
</p>
 </li>

 <li>
<p>
%nodes 内の ~EACH ( %node ) に対し，`木~順序$で：
◎
For each node in nodes, in tree order, run these substeps:
</p>
  <ol>
   <li>
<p>
~IF［
%子 ~NEQ ~NULL
］
⇒
%node を %子 の前に挿入する
</p>
<p>
~ELSE
⇒
%node を %親 の末尾に挿入する
</p>

<p class="trans-note">【
ここでの挿入-は木への組み込みを意味する。
】</p>
◎
Insert node into parent before child or at the end of parent if child is null.
</li>

   <li>
~IF［
%親 は`~shadow~host$である
］~AND［
%~node は`~slotable$である
］
⇒
%~node に対し，`~slotを割当先にする$
◎
If parent is a shadow host and node is a slotable, then assign a slot for node.
</li>
   <li id="cp-if-parent-assigned-nodes-empty">
~IF［
%親 は`~slot$である
］~AND［
%親 に`割当されている~nodeたち$は 空~listである
］
⇒
%親 に対し，`~slotの変化を通達する$
◎
If parent is a slot whose assigned nodes is the empty list, then run signal a slot change for parent.
</li>
   <li id="cp-assign-slotables-for-tree">
［
%~node の`広義子孫$のうち，`~slot$であるものからなる集合
］を与える下で，
 %~node の`木$に `~slotableたちを割当する$tree
◎
Run assign slotables for a tree with node’s tree and a set containing each inclusive descendant of node that is a slot.
</li>

   <li>
<p>
~FOR
%~node の~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し，`~shadowも含む木~順序$で：
◎
For each shadow-including inclusive descendant inclusiveDescendant of node, in shadow-including tree order, run these subsubsteps:
</p>
    <ol>
     <li>
%広義子孫 を与える下で，`挿入-時の手続き$を走らす
◎
Run the insertion steps with inclusiveDescendant.
</li>
     <li>
<p>
~IF［
%広義子孫 は`接続され$ている
］：
◎
If inclusiveDescendant is connected, then:
</p>
      <ol>
       <li>
~IF［
%広義子孫 は`~custom$である
］
⇒
次を与える下で，`~custom要素~callback反応を待入れる$
⇒
%広義子孫,<br>
~callback名： `connectedCallback^l,<br>
引数~list： 空
◎
If inclusiveDescendant is custom, then enqueue a custom element callback reaction with inclusiveDescendant, callback name "connectedCallback", and an empty argument list.
</li>
       <li>
<p>
~ELSE
⇒
%広義子孫 の`昇格を試行する$
◎
Otherwise, try to upgrade inclusiveDescendant.
</p>

<p class="note">注記：
%広義子孫 が成功裡に昇格された場合、その ^connectedCallback は，要素を`昇格$する~algoの間に自動的に待入れられる。
◎
If this successfully upgrades inclusiveDescendant, its connectedCallback will be enqueued automatically during the upgrade an element algorithm.
</p>
       </li>
      </ol>
     </li>
    </ol>
   </li>
  </ol>
 </li>

 <li>
~IF［
`抑止ob^f ~EQ ~OFF
］
⇒
%親 に対する次の様な `childList^l の変異~記録を`待入する$
⇒
追加済nodes: %nodes,<br>
弟: %子,<br>
兄: ［
%子 ~NEQ ~NULL ならば %子 の`兄$ ／
~ELSE_ %親 の `最後0の子$
］
◎
If suppress observers flag is unset, queue a mutation record of "childList" for parent with addedNodes nodes, nextSibling child, and previousSibling child’s previous sibling or parent’s last child if child is null.
</li>

</ol>



<p class="algo-head">
%node を %親 に
`付加-@
するときは、 %親 の中で， %node を~NULL の前に`前挿入$する。
◎
To append a node to a parent, pre-insert node into parent before null.
</p>


<!--% 置換 -->
<p class="algo-head">
%親 の中で %子 を %node に
`置換-@
するときは、次を走らす：
◎
To replace a child with node within a parent, run these steps:
</p>

<ol>
 <!--cp-throw-if-chardata-->
 <!--cp-throw-if-iAN-->
 <!-- 原文誤記 "inclusive ancestor *of* parent" →-->
 <li>
<p id="cp-throw-if-not-parent">
~IF［
%子 の`親$ ~NEQ %親
］
⇒
~THROW `NotFoundError^E
◎
If child’s parent is not parent, then throw a NotFoundError.
</p>
 </li>

 <!--cp-throw-if-not-doc-->
 <!--cp-throw-if-mismatch1-->

 <li>
<!--cp-throw-if-doc-etc-->

  <dl class="switch">
   <dt>`文書片$</dt>
   <dd>
<p>
次のいずれかが満たされる：
</p>
    <ul>
     <!--cp-has-Text-child-->
     <!--cp-has-element-children-->
     <li>
      <!--cp-has-an-element-and-->
<ul id="cp-has-other-element"
	><li>%親 は［ %子 でない`要素$ ］を`子$に持つ
</li><li>%子 に`後続-$する`文書型$が在る
</li></ul>
◎
Otherwise, if node has one element child and either parent has an element child that is not child or a doctype is following child.
</li>
    </ul>
   </dd>

   <dt>`要素$</dt>
   <dd>
<p>
次のいずれかが満たされる：
</p>
    <!--cp-has-other-element-->

◎
parent has an element child that is not child or a doctype is following child.
   </dd>

   <dt>`文書型$</dt>
   <dd>
<p>
次のいずれかが満たされる：
</p>

<ul><li>%親 は［ %子 でない`文書型$ ］を`子$に持つ
</li><li>%子 に`先行-$する`要素$が在る
</li></ul>

◎
parent has a doctype child that is not child, or an element is preceding child.
   </dd>

  </dl>

<p class="note">注記：
この段は，`挿入し得るかどうか検証する$ ~algoの似た段と異なることに注意。
◎
The above statements differ from the pre-insert algorithm.
</p>
 </li>

 <li>
%基準~子 ~LET %子 の`弟$
◎
Let reference child be child’s next sibling.
</li>

 <!--cp-set-next-sibling-->

 <li>
%兄 ~LET %子 の`兄$
◎
Let previousSibling be child’s previous sibling.
</li>

 <!--cp-adopt-->

 <li>
%除去済nodes ~LET 空~list
◎
Let removedNodes be the empty list.
</li>
 <li>
<p>
~IF［
%子 の`親$ ~NEQ ~NULL
］：
◎
If child’s parent is not null, run these substeps:
</p>
  <ol>
   <li>
%除去済nodes ~SET %子 のみからなる~list；<br>
◎
Set removedNodes to a list solely containing child.
</li>
   <li>
［
`抑止ob^f: ~ON
］を与える下で，
%子 を %親 から`除去-$する
◎
Remove child from its parent with the suppress observers flag set.
</li>
  </ol>

<p class="note">注記：
この段の~~条件は［
%子 ~EQ %node
］の場合に限り，偽になる。
◎
The above can only be false if child is node.
</p>

 </li>

 <!--cp-let-nodes-->

 <li>
［
`抑止ob^f: ~ON
］を与える下で，
%親 の中で， %node を %基準~子 の前に`挿入-$する
◎
Insert node into parent before reference child with the suppress observers flag set.
</li>

 <li>
%親 に対する次の様な `childList^l の変異~記録を`待入する$
⇒
追加済nodes: %nodes,<br>
除去済nodes: %除去済nodes,<br>
弟: %基準~子,<br>
兄: %兄
◎
Queue a mutation record of "childList" for target parent with addedNodes nodes, removedNodes removedNodes, nextSibling reference child, and previousSibling previousSibling.
</li>

 <li>
~RET %子
◎
Return child.
</li>
</ol>

<!--% 全置換 -->
<p class="algo-head">
%親 の内容を %node で
`すべて置換-@
するときは、次を走らす：
◎
To replace all with a node within a parent, run these steps:
</p>

<ol>
 <li>
~IF［
%node ~NEQ ~NULL
］
⇒
%node を %親 の `~node文書$に`受入-$する
◎
If node is not null, adopt node into parent’s node document.
</li>

 <li>
%除去済nodes ~LET %親 のすべての`子$
◎
Let removedNodes be parent’s children.
</li>

 <li>
<p>
%追加済nodes ~LET ［
%node に応じて，次で与えられる~list
］：
</p>
  <dl class="switch">
   <dt>~NULL</dt>
   <dd>
空~list
</dd>
   <dt>`文書片$</dt>
   <dd>
%node のすべての`子$ からなる~list
</dd>

   <dt>その他</dt>
   <dd>
%node のみからなる~list
</dd>
  </dl>

◎
Let addedNodes be the empty list if node is null, node’s children if node is a DocumentFragment node, and a list containing node otherwise.
</li>

 <li>
~FOR
%親 の~EACH ( `子$ %子 ) に対し，`木~順序$で
⇒
［
`抑止ob^f: ~ON
］を与える下で，
%子 を %親 から`除去-$する
◎
Remove all parent’s children, in tree order, with the suppress observers flag set.
</li>

 <li>
~IF［
%node ~NEQ ~NULL
］
⇒
［
`抑止ob^f: ~ON
］を与える下で，
%親 の中で， %node を ~NULL の前に`挿入-$する
◎
If node is not null, insert node into parent before null with the suppress observers flag set.
</li>

 <li>
%親 に対する次の様な `childList^l の変異~記録を`待入する$
⇒
追加済nodes: %追加済nodes,<br>
除去済nodes: %除去済nodes
◎
Queue a mutation record of "childList" for parent with addedNodes addedNodes and removedNodes removedNodes.
</li>

</ol>

<p class="note">注記：
この~algoは `~node木$に課される拘束を検査しない。
仕様の策定者は注意して用いること。
◎
This algorithm does not make any checks with regards to the node tree constraints. Specification authors need to use it wisely.
</p>

<p class="algo-head">
%子 を %親 から
`前除去-@
するときは、次を走らす：
◎
To pre-remove a child from a parent, run these steps:
</p>

<ol>
 <li><!--cp-throw-if-not-parent--></li>

 <li>
%子 を %親 から`除去-$する
◎
Remove child from parent.
</li>

 <li>
~RET %子
 <!-- technically this is post-remove -->
◎
Return child.
</li>
</ol>

<p>
`適用仕様$は、すべてまたは一部の`~node$に対する
`除去-時の手続き@
を定義して~MAY。
その~algoには、下の`除去-$ ~algoにて指示される
( 除去された~node, その元の親（省略可） )
の組が渡される。
◎
Specifications may define removing steps for all or some nodes. The algorithm is passed removedNode, and optionally oldParent, as indicated in the remove algorithm below.
</p>

<!--% 除去 -->
<p class="algo-head">
`抑止ob^f（省略時は ~OFF ）が与えられた下で，
%node を %親 から
`除去-@
するときは、次を走らす：
◎
To remove a node from a parent, with an optional suppress observers flag, run these steps:
</p>

<ol>
 <li>
%指数 ~LET %node の`指数$
◎
Let index be node’s index.
</li>
 <li>
<p>
~FOR
~EACH ( `範囲0$ %R ) に対し：
◎
↓</p>

  <ol>
   <li>
~IF［
%R の`始点~node$ ~iDE %node
］
⇒
%R の`始点~node$ ~SET %親；<br>
%R の`始点~offset$ ~SET %指数
◎
For each range whose start node is an inclusive descendant of node, set its start to (parent, index).
</li>

   <li>
~IF［
%R の`終点~node$ ~iDE %node
］
⇒
%R の`終点~node$ ~SET %親；<br>
%R の`終点~offset$ ~SET %指数
◎
For each range whose end node is an inclusive descendant of node, set its end to (parent, index).
</li>

   <li>
~IF［
%R の`始点~node$ ~EQ %親
］~AND［
%R の`始点~offset$ ~GT %指数
］
⇒
%R の`始点~offset$ ~DECBY 1
◎
For each range whose start node is parent and start offset is greater than index, decrease its start offset by one.
</li>

   <li>
~IF［
%R の`終点~node$ ~EQ %親
］~AND［
%R の`終点~offset$ ~GT %指数
］
⇒
%R の`終点~offset$ ~DECBY 1
◎
For each range whose end node is parent and end offset is greater than index, decrease its end offset by one.
</li>

  </ol>
 </li>


 <li>
［
%反復器 の`根~node$の`~node文書$ ~EQ %node `~node文書$
］なる，~EACH ( $NodeIterator ~obj  %反復器 ) に対し
⇒
( %反復器, %node )
を与える下で，`前除去-時の手続き$を走らす
◎
For each NodeIterator object iterator whose root’s node document is node’s node document, run the NodeIterator pre-removing steps given node and iterator.
</li>

 <li>
%兄 ~LET %node の`兄$
◎
Let oldPreviousSibling be node’s previous sibling.
</li>

 <li>
%弟 ~LET %node の`弟$
◎
Let oldNextSibling be node’s next sibling.
</li>

 <li>
%node を %親 から除去する
<span class="trans-note">【この除去-は木からの切り離しを意味する。】</span>
◎
Remove node from its parent.
</li>

 <li>
~IF［
%~node の`割当先~slot$ ~NEQ ~NULL
］
⇒
その`~slot$に`~slotableたちを割当する$
◎
If node is assigned, then run assign slotables for node’s assigned slot.
</li>
 <!--cp-if-parent-assigned-nodes-empty-->
 <li>
<p>
~IF［［
%~node の`広義子孫$のうち，`~slot$であるもの
］は在る
］：
◎
If node has an inclusive descendant that is a slot, then:
</p>
  <ol>
   <li>
%親 の`木$に `~slotableたちを割当する$tree
◎
Run assign slotables for a tree with parent’s tree.
</li>
   <!--cp-assign-slotables-for-tree-->
  </ol>
 </li>

 <li>
( %node, %親 )
を与える下で，`除去-時の手続き$を走らす
◎
Run the removing steps with node and parent.
</li>

 <li>
<p>
~IF［
%~node は`~custom$である
］
⇒
次を与える下で，`~custom要素~callback反応を待入れる$
⇒
%~node,<br>
~callback名： `disconnectedCallback^l,<br>
引数~list： 空
◎
If node is custom, then enqueue a custom element callback reaction with node, callback name "disconnectedCallback", and an empty argument list.
</p>

<p class="note">注記：
今の所，`~custom$である`要素$には %親 は渡されないのは意図的であるが、将来に必要になった場合は変更され得る。
◎
It is intentional for now that custom elements do not get parent passed. This might change in the future if there is a need.
</p>

 <li>
<p>
~FOR
%~node の~EACH ( `~shadowも含む子孫$ %子孫 ) に対し，`~shadowも含む木~順序$で：
◎
For each shadow-including descendant descendant of node, in shadow-including tree order, run these substeps:
</p>
  <ol>
   <li>
( %子孫, … )
を与える下で，`除去-時の手続き$を走らす
◎
Run the removing steps with descendant.
</li>
   <li>
~IF［
%子孫 は`~custom$である
］
⇒
次を与える下で，`~custom要素~callback反応を待入れる$
⇒
%子孫,<br>
~callback名： `disconnectedCallback^l,<br>
引数~list： 空
◎
If descendant is custom, then enqueue a custom element callback reaction with descendant, callback name "disconnectedCallback", and an empty argument list.
</li>
  </ol>
 </li>
 <li>
~FOR
%親 の~EACH ( `広義先祖$ %広義先祖 ) に対し
⇒
~FOR
%広義先祖 の`~ob~list$ 内の ~EACH ( `登録済~ob$ %O ) に対し
⇒
~IF［
%O の `options^i
］の $MutationObserverInit.subtree ~EQ ~T
⇒
次のように設定された`一時~登録済~ob$を， %node の`~ob~list$に付加する
⇒
`observer^i ~SET %O の `observer^i；<br>
`options^i ~SET %O の `options^i；<br>
`source^i ~SET %O
◎
For each inclusive ancestor inclusiveAncestor of parent, if inclusiveAncestor has any registered observers whose options' subtree is true, then for each such registered observer registered, append a transient registered observer whose observer and options are identical to those of registered and source which is registered to node’s list of registered observers.
</li>

 <li>
~IF［
`抑止ob^f ~EQ ~OFF
］
⇒
%親 に対する次の様な `childList^l の変異~記録を`待入する$
⇒
除去済nodes: %node のみからなる~list,<br>
弟: %弟,<br>
兄: %兄
◎
If suppress observers flag is unset, queue a mutation record of "childList" for parent with removedNodes a list solely containing node, nextSibling oldNextSibling, and previousSibling oldPreviousSibling.
</li>
</ol>


			</section>
			<section id="interface-nonelementparentnode">
<h4>4.2.4. ~mixin ^@NonElementParentNode</h4>

<p class="note">注記：
~Web互換性の理由から、 $getElementById() ~methは，`要素$ 上には（したがって $ParentNode 上にも）公開できない。
◎
Web compatibility prevents the getElementById() method from being exposed on elements (and therefore on ParentNode).
</p>

⇒！
[NoInterfaceObject,
 Exposed=Window]
interface @NonElementParentNode {
  $Element? $getElementById(~DS %elementId);
};
$Document implements $NonElementParentNode;
$DocumentFragment implements $NonElementParentNode;
◎

<dl class="domintro">
 <dt>%node . $getElementById(elementId)</dt>
 <dd>
%node の`子孫$であって, `~ID$が %elementId なる`要素$のうち，`最初0$のものを返す。
◎
Returns the first element within node’s descendants whose ID is elementId.
</dd>

</dl>

<dl class="idl-def">
	<dt>@getElementById(elementId)</dt>
	<dd>
被呼出時には、此れの`子孫$のうち，［
`~ID$ ~EQ %elementId
］なる`要素$のうち，`最初0$のものを返さ~MUST。
◎
The getElementById(elementId) method, when invoked, must return the first element, in tree order, within context object’s descendants, whose ID is elementId, and null if there is no such element otherwise.
</dd>
</dl>
			</section>
			<section id="mixin-documentorshadowroot">

<h4>4.2.5. ~mixin ^@DocumentOrShadowRoot</h4>

⇒！
[NoInterfaceObject,
 Exposed=Window]
interface @DocumentOrShadowRoot {
};

$Document implements $DocumentOrShadowRoot;
$ShadowRoot implements $DocumentOrShadowRoot;
◎


<p class="note">注記：
$DocumentOrShadowRoot ~mixinは、［
`文書$, `~shadow根$
］で共有される API を定義したいと求める他の標準により利用されることが期待されている。
◎
The DocumentOrShadowRoot mixin is expected to be used by other standards that want to define APIs shared between documents and shadow roots.
</p>

			</section>
			<section id="interface-parentnode">

<h4>4.2.6. ~mixin ^@ParentNode</h4>

<p class="algo-head">
`~nodeたちを~nodeに変換-@
する手続きは、所与の
( %nodes, %文書 )
に対し，次を走らす：
◎
To convert nodes into a node, given nodes and document, run these steps:
</p>

<p class="trans-note">【
%nodes は、~nodeと文字列が混在する引数~list。
】</p>

<ol>
 <li>
~FOR
%nodes 内の~EACH ( 文字列 %文字列 ) を
`新たな~text~node$( %文字列, %文書 )
に置換する
◎
Let node be null.
◎
Replace each string in nodes with a new Text node whose data is the string and node document is document.
</li>

 <li>
~IF［
%nodes に含まれる`~node$は一つだけ
］
⇒
~RET その`~node$
◎
If nodes contains one node, set node to that node.
</li>

 <li>
%文書片 ~SET ［
`~node文書$ ~SET %文書
］にされた 新たな`文書片$
◎
↓</li>

 <li>
~FOR
%nodes 内の~EACH ( %node ) に対し
⇒
%node を %文書片 に`付加-$する
（例外投出あり）
◎
Otherwise, set node to a new DocumentFragment whose node document is document, and then append each node in nodes, if any, to it. Rethrow any exceptions.
</li>

 <li>
~RET %文書片
◎
Return node.
</li>

</ol>

⇒！
[NoInterfaceObject,
 Exposed=Window]
interface @@ParentNode {
  [SameObject] ~RA $HTMLCollection $children;
  ~RA $Element? $firstElementChild;
  ~RA $Element? $lastElementChild;
  ~RA ~UL $childElementCount;

  [`CEReactions$, Unscopable] void $prepend((Node or ~DS)... %nodes);
  [`CEReactions$, Unscopable] void $append((Node or ~DS)... %nodes);

  $Element? $querySelector(~DS %selectors);
  [NewObject] $NodeList $querySelectorAll(~DS %selectors);
};
$Document implements $ParentNode;
$DocumentFragment implements $ParentNode;
$Element implements $ParentNode;
◎

<dl class="domintro">
 <dt>%collection = %node . $children</dt>
 <dd>
すべての`子$`要素$を返す。
◎
Returns the child elements.
</dd>

 <dt>%element = %node . $firstElementChild</dt>
 <dd>
`最初0$の，`子$`要素$を返す。
◎
Returns the first child that is an element, and null otherwise.
</dd>

 <dt>%element = %node . $lastElementChild</dt>
 <dd>
`最後0$の，`子$`要素$を返す。
◎
Returns the last child that is an element, and null otherwise.
</dd>

 <dt>%node . $prepend(nodes…)</dt>
 <dd>
%nodes 引数の中の文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の`最初0の子$の前に挿入する。
◎
Inserts nodes before the first child of node, while replacing strings in nodes with equivalent Text nodes.
</dd>

<dd id="cp-throw-if-violate-tree">
`~node木$の拘束に反する場合、 `HierarchyRequestError^E が`投出$される。
◎
Throws a HierarchyRequestError if the constraints of the node tree are violated.
</dd>

 <dt>%node . $append(nodes…)</dt>
 <dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の`最後0の子$の後に挿入する。
◎
Inserts nodes after the last child of node, while replacing strings in nodes with equivalent Text nodes.
</dd>
 <!--cp-throw-if-violate-tree-->

 <dt>%node . $querySelector(selectors)</dt>
 <dd>
%node の`子孫$であって,
%selectors に合致する，`最初0$の`要素$を返す。
◎
Returns the first element that is a descendant of node that matches selectors.
</dd>

 <dt>%node . $querySelectorAll(selectors)</dt>
 <dd>
%node の`子孫$であって,
%selectors に合致する，すべての`要素$を返す。
◎
Returns all element descendants of node that match selectors.
</dd>

</dl>

<dl class="idl-def">
	<dt>@children</dt>
	<dd>
取得子は、次のようにされた $HTMLCollection `~collection$を返さ~MUST
⇒
`根$cl ~SET 此れ,<br>
`~filter$は 此れの`子$`要素$のみに合致する
◎
The children attribute’s getter must return an HTMLCollection collection rooted at context object matching only element children.
</dd>

	<dt>@firstElementChild</dt>
	<dd>
取得子は、此れの`子$`要素$のうち，`最初0$のものを返さ~MUST。
◎
The firstElementChild attribute’s getter must return the first child that is an element, and null otherwise.
</dd>

	<dt>@lastElementChild</dt>
	<dd>
取得子は、此れの`子$`要素$のうち，`最後0$のものを返さ~MUST。
◎
The lastElementChild attribute’s getter must return the last child that is an element, and null otherwise.
</dd>

	<dt>@childElementCount</dt>
	<dd>
取得子は、此れの`子$`要素$の個数を返さ~MUST。
◎
The childElementCount attribute’s getter must return the number of children of context object that are elements.
</dd>

	<dt>@prepend(nodes…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The prepend(nodes) method, when invoked, must run these steps: 
</p>

<ol>
 <li id="cp-convert-nodes">
%node ~LET
( %nodes, 此れの`~node文書$ )
を与える下で，`~nodeたちを~nodeに変換-$した結果
（例外投出あり）
◎
Let node be the result of converting nodes into a node, given nodes and context object’s node document. Rethrow any exceptions.
</li>
 <li>
此れの中で， %node を此れの`最初0の子$の前に`前挿入$する
（例外投出あり）
◎
Pre-insert node into context object before the context object’s first child. Rethrow any exceptions.
</li>
</ol>
	</dd>

	<dt>@append(nodes…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The append(nodes) method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-convert-nodes-->

 <li>
%node を此れに`付加-$する
（例外投出あり）
◎
Append node to context object. Rethrow any exceptions.
</li>
</ol>

	</dd>

	<dt>@querySelector(selectors)</dt>
	<dd>
被呼出時には、［
%selectors を此れの`視野の下で照合-$した結果
］の中の，`最初0$の要素を返さ~MUST。
◎
The querySelector(selectors) method, when invoked, must return the first result of running scope-match a selectors string selectors against context object, if the result is not an empty list, and null otherwise.
</dd>

	<dt>@querySelectorAll(selectors)</dt>
	<dd>
被呼出時には、［
%selectors を此れの`視野の下で照合-$した結果
］を，`~static$なものとして 返さ~MUST。
◎
The querySelectorAll(selectors) method, when invoked, must return the static result of running scope-match a selectors string selectors against the context object.
</dd>
</dl>
			</section>
			<section id="interface-nondocumenttypechildnode">
<h4>4.2.7. ~mixin ^@NonDocumentTypeChildNode</h4>

<p class="note">注記：
~Web互換性の理由から、
$previousElementSibling, $nextElementSibling
属性は，`文書型$ 上には（したがって， $ChildNode 上にも）公開できない。
◎
Web compatibility prevents the previousElementSibling and nextElementSibling attributes from being exposed on doctypes (and therefore on ChildNode).
</p>

⇒！
[NoInterfaceObject,
 Exposed=Window]
interface @NonDocumentTypeChildNode {
  ~RA $Element? $previousElementSibling;
  ~RA $Element? $nextElementSibling;
};
$Element implements $NonDocumentTypeChildNode;
$CharacterData implements $NonDocumentTypeChildNode;
◎

<dl class="domintro">
 <dt>%element = %node . $previousElementSibling</dt>
 <dd>
`先行-$する`同胞$の`要素$のうち，`最後0$のものを返す。
◎
Returns the first preceding sibling that is an element, and null otherwise.
</dd>

 <dt>%element = %node . $nextElementSibling</dt>
 <dd>
`後続-$する`同胞$の`要素$のうち，`最初0$のものを返す。
◎
Returns the first following sibling that is an element, and null otherwise.
</dd>
</dl>

<dl class="idl-def">
	<dt>@previousElementSibling</dt>
	<dd>
取得子は、［
此れの`同胞$である
］~AND［
此れに`先行-$する
］~AND［
`要素$である
］ような~nodeのうち，`最後0$のものを返さ~MUST。
◎
The previousElementSibling attribute’s getter must return the first preceding sibling that is an element, and null otherwise.
</dd>

	<dt>@nextElementSibling</dt>
	<dd>
取得子は、［
此れの`同胞$である
］~AND［
此れに`後続-$する
］~AND［
`要素$である
］ような~nodeのうち，`最初0$のものを返さ~MUST。
◎
The nextElementSibling attribute’s getter must return the first following sibling that is an element, and null otherwise.
</dd>
</dl>

			</section>
			<section id="interface-childnode">

<h4>4.2.8. ~mixin ^@ChildNode</h4>

⇒！
[NoInterfaceObject,
 Exposed=Window]
interface @ChildNode {
  [`CEReactions$, Unscopable] void $before(($Node or ~DS)... %nodes);
  [`CEReactions$, Unscopable] void $after(($Node or ~DS)... %nodes);
  `CEReactions$, [Unscopable] void $replaceWith(($Node or ~DS)... %nodes);
  [`CEReactions$, Unscopable] void $remove();
};
$DocumentType implements $ChildNode;
$Element implements $ChildNode;
$CharacterData implements $ChildNode;
◎

<dl class="domintro">
 <dt>%node . $before(nodes…)</dt>
 <dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の直前に挿入する。
◎
Inserts nodes just before node, while replacing strings in nodes with equivalent Text nodes.
</dd>
 <!--cp-throw-if-violate-tree-->

 <dt>%node . $after(nodes…)</dt>
 <dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の直後に挿入する。
◎
Inserts nodes just after node, while replacing strings in nodes with equivalent Text nodes.
</dd>
 <!--cp-throw-if-violate-tree-->

 <dt>%node . $replaceWith(nodes…)</dt>
 <dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%node を %nodes で置換する。
◎
Replaces node with nodes, while replacing strings in nodes with equivalent Text nodes.
</dd>
 <!--cp-throw-if-violate-tree-->

 <dt>%node . $remove()</dt>
 <dd>
%node を除去する。
◎
Removes node.
</dd>

</dl>

<dl class="idl-def">
	<dt>@before(nodes…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The before(nodes) method, when invoked, must run these steps:
</p>

<ol>
 <li id="cp-let-ctx-parent">
%親 ~LET 此れの`親$
◎
Let parent be context object’s parent.
</li>

 <li id="cp-exit-if-null-parent">
~IF［
%親 ~EQ ~NULL
］
⇒
~RET
◎
If parent is null, terminate these steps.
</li>

 <li>
<p>
%~viable兄 ~LET ［
次のいずれも満たすような~node
］のうち，`最後0$のもの：
</p>
  <ul>
   <li>
此れの`同胞$である
</li>
   <li>
此れに`先行-$する
</li>
   <li>
~node ~NIN ［
%nodes に与えられた引数の集合
］
</li>
  </ul>
◎
Let viablePreviousSibling be context object’s first preceding sibling not in nodes, and null otherwise.
</li>

 <!--cp-convert-nodes-->

 <li>
%~viable兄 ~SET ［
%~viable兄 ~EQ ~NULL ならば %親 の`最初0の子$ ／
~ELSE_ %~viable兄 の`弟$
］
◎
If viablePreviousSibling is null, set it to parent’s first child, and to viablePreviousSibling’s next sibling otherwise.
</li>

 <li>
%親 の中で， %node を %~viable兄 の前に`前挿入$する
（例外投出あり）
◎
Pre-insert node into parent before viablePreviousSibling. Rethrow any exceptions.
</li>
</ol>
	</dd>

	<dt>@after(nodes…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The after(nodes) method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-let-ctx-parent-->
 <!--cp-exit-if-null-parent-->

 <li id="cp-let-viableNextSibling">
<p>
%~viable弟 ~LET ［
次のいずれも満たすような~node
］のうち，`最初0$のもの：
</p>

  <ul>
   <li>
此れの`同胞$である
</li>
   <li>
此れに`後続-$する
</li>
   <li>
~node ~NIN ［
%nodes に与えられた引数の集合
］
</li>
  </ul>

◎
Let viableNextSibling be context object’s first following sibling not in nodes, and null otherwise.
</li>

 <!--cp-convert-nodes-->

 <li>
%親 の中で， %node を %~viable弟 の前に`前挿入$する
（例外投出あり）
◎
Pre-insert node into parent before viableNextSibling.
</li>
</ol>
	</dd>

	<dt>@replaceWith(nodes…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The replaceWith(nodes) method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-let-ctx-parent-->
 <!--cp-exit-if-null-parent-->
 <!--cp-let-viableNextSibling-->
 <!--cp-convert-nodes-->

 <li>
<p>
~IF［
此れの`親$ ~EQ %親
］
⇒
%親 の中で，此れを %node に`置換-$する
（例外投出あり）
◎
If context object’s parent is parent, replace the context object with node within parent. Rethrow any exceptions.
</p>

<p class="note">注記：
此れは %node の中に挿入されていることもある。
◎
Context object could have been inserted into node.
</p>
 </li>
 <li>
~ELSE
⇒
%親 の中で， %node を %~viable弟 の前に`前挿入$する
（例外投出あり）
◎
Otherwise, pre-insert node into parent before viableNextSibling.
</li>

</ol>
	</dd>

	<dt>@remove()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The remove() method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
此れの`親$ ~EQ ~NULL
］
⇒
~RET
◎
If context object’s parent is null, terminate these steps.
</li>

 <li>
此れの`親$から此れを`除去-$する
◎
Remove the context object from context object’s parent.
</li>
</ol>

	</dd>
</dl>


			</section>
			<section id="mixin-slotable">
<h4 title="Mixin: Slotable">4.2.9. ~mixin： ^@Slotable</h4>

<pre class="idl def">
[NoInterfaceObject, Exposed=Window]
interface @Slotable {
  ~RA $HTMLSlotElement? $assignedSlot;
};

$Element implements $Slotable;
$Text implements $Slotable;
</pre>


<dl class="idl-def">
	<dt>@assignedSlot</dt>
	<dd>
取得子は、［
`~open^f ~SET ~ON
］の下で，此れから`~slotを見出-$した結果を返さ~MUST。
◎
The assignedSlot attribute’s getter must return the result of find a slot given context object and with the open flag set.
</dd>
</dl>



			</section>
			<section id="old-style-collections">

<h4 title="Old-style collections: NodeList and HTMLCollection">4.2.10. 古い方式の~collection： ^NodeList と ^HTMLCollection</h4>

<p>
`~collection@
は~DOM~nodeの~listを表現する~objである。
`~collection$は
`~live@
にも
`~static@
にもなり得る。
他が定められない限り、`~collection$は`~live$で~MUST。
◎
A collection is an object that represents a lists of DOM nodes. A collection can be either live or static. Unless otherwise stated, a collection must be live.
</p>

<p>
`~live$である`~collection$の［
属性／~meth
］は、
<span class="trans-note">【~collectionの作成時における】</span>
~dataの snapshot ではなく，
<span class="trans-note">【~accessされる度に その時点における】</span>
実際の下層~dataに対し、演算し~MUST†。
◎
If a collection is live, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.
</p>

<p class="trans-note">【†
従って，~collectionを走査している間に木を改変するような処理があるときは、~collectionの無限増殖に陥いらないよう注意する必要がある。
】【†
`~static$の場合は，逆に、~dataの snapshot に対し演算することになる。
】</p>

<p>
各 `~collection$には、その作成時に
`~filter@
と
`根@cl
が結付けられる。
◎
When a collection is created, a filter and a root are associated with it.
</p>

<p>
`~collection$は、`~collection$の`根$clの`子孫$†`~node$のうち, 所与の`~filter$に合致するもののみを含むような，~viewを
`表現-@
する。
~viewは全順序である。
`木~順序$にできないような要件が特にない限り、`~collection$に含まれる~nodeは，`木~順序$で整列されてい~MUST。
◎
The collection then represents a view of the subtree rooted at the collection’s root, containing only nodes that match the given filter. The view is linear. In the absence of specific requirements to the contrary, the nodes within the collection must be sorted in tree order.
</p>

<p class="trans-note">【†
原文の記述からははっきりしないが、`根$cl自身は~filter対象に含まれないように見受けられる。
】</p>

				<section id="interface-nodelist">
<h5>4.2.10.1. ~ifc ^@NodeList</h5>

<p>
$NodeList ~objは`~node$の`~collection$である。
◎
A NodeList object is a collection of nodes.
</p>

⇒！
[Exposed=Window]
interface @NodeList {
  getter $Node? $item(~UL %index);
  ~RA ~UL $length;
  iterable&lt;$Node&gt;;
};
◎


<dl class="domintro">
 <dt>%collection . $length</dt>
 <dd>
`~collection$に含まれている`~node$の個数を返す。
◎
Returns the number of nodes in the collection.
</dd>

 <dt>%element = %collection . $item(index)</dt>
 <dt>%element = %collection[%index]</dt>
 <dd>
`木~順序$に整列された下で、`~collection$の中で， %index 番の`~node$を返す。
◎
Returns the node with index index from the collection. The nodes are sorted in tree order.
</dd>
</dl>

<p>
~collectionの`被support ~prop~index$の~~範囲は、［
0 〜 ( ~collectionで`表現-$される~nodeの個数~MINUS 1 )
］である（~collectionが空ならば~~範囲も空）。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of nodes represented by the collection. If there are no such elements, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、此れが`表現-$する~nodeの個数を返さ~MUST。
◎
The length attribute must return the number of nodes represented by the collection.
</dd>

	<dt>@item(index)</dt>
	<dd>
被呼出時には、［
此れの中に %index 番の`~node$が在れば その~node ／
無ければ ~NULL
］を返さ~MUST。
◎
The item(index) method must return the indexth node in the collection. If there is no indexth node in the collection, then the method must return null.
</dd>
</dl>

				</section>
				<section id="interface-htmlcollection">

<h5>4.2.10.2. ~ifc ^@HTMLCollection</h5>

⇒！
[Exposed=Window, LegacyUnenumerableNamedProperties]
interface @HTMLCollection {
  ~RA ~UL $length;
  getter $Element? $item(~UL %index);
  getter $Element? $namedItem(~DS %name);
};
◎

<p>
$HTMLCollection ~objは`要素$の`~collection$である。
◎
An HTMLCollection object is a collection of elements.
</p>

<p class="note">注記：
$HTMLCollection は、歴史的な~~理由から~~廃するわけにいかない所産である。
開発者は それを利用し続けても構わないが、新たな API 標準の設計者は それを利用しないこと（代わりに IDL <code >sequence&lt;%T&gt;</code> 型を利用すること）。
◎
HTMLCollection is an historical artifact we cannot rid the web of. While developers are of course welcome to keep using it, new API standard designers ought not to use it (use sequence&lt;T&gt; in IDL instead).
</p>

<dl class="domintro">
 <dt>%collection . $length</dt>
 <dd>
`~collection$に含まれている`要素$の個数を返す。
◎
Returns the number of elements in the collection.
</dd>

 <dt>%element = %collection . $item(index)</dt>
 <dt>%element = %collection[%index]</dt>
 <dd>
`要素$たちを`木~順序$に整列した下での、`~collection$の中で %index 番の`要素$を返す。
◎
Returns the element with index index from the collection. The elements are sorted in tree order.
</dd>

 <dt>%element = %collection . $namedItem(name)</dt>
 <dt>%element = %collection[%name]</dt>
 <dd>
~collectionの中で `~ID$ または名前が %name なる最初の`要素$を返す。
◎
Returns the first element with ID or name name from the collection.
</dd>

</dl>



<p>
~collectionの`被support ~prop~index$の~~範囲は、［
0 〜 ( ~collectionで`表現-$される要素の個数~MINUS 1 )
］である（~collectionが空ならば~~範囲も空）。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of elements represented by the collection. If there are no such elements, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、此れが`表現-$する~nodeの個数を返さ~MUST。
◎
The length attribute’s getter must return the number of nodes represented by the collection.
</dd>

	<dt>@item(index)</dt>
	<dd>
被呼出時には、［
此れの中に %index 番の`要素$が在ればそれ ／
~ELSE_ ~NULL 
］を返さ~MUST。
◎
The item(index) method, when invoked, must return the indexth element in the collection. If there is no indexth element in the collection, then the method must return null.
</dd>
</dl>

<p class="algo-head">
`被support ~prop名$は、次の手続きから返される値たちの~listになる：
◎
The supported property names are the values from the list returned by these steps:
</p>

<ol>
 <li>
%結果 ~LET 空~list
◎
Let result be an empty list.
</li>

 <li>
<p>
~FOR
~collectionで`表現-$される
~EACH ( 要素 %要素 ) に対し，`木~順序$で：
◎
For each element represented by the collection, in tree order, run these substeps:
</p>


  <ol>
   <li>
~IF［
%要素 は `~ID$ %id を持つ
］~AND［
%id ~NIN %結果
］
⇒
%id を %結果 に付加する
◎
If element has an ID which is not in result, append element’s ID to result.
</li>

   <li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 は `name^A `属性0$nmを`有する$
］
⇒
%名前 ~LET その `name^A `属性0$nmの値；<br>
~IF［
%名前 ~NEQ 空文字列
］~AND［
%名前 ~NIN %結果
］
⇒
%名前 を %結果 に付加する
◎
If element is in the HTML namespace and has a name attribute whose value is neither the empty string nor is in result, append element’s name attribute value to result.
</li>

  </ol>
 </li>

 <li>
~RET %結果
◎
Return result.
</li>
</ol>

<dl class="idl-def">
	<dt>@namedItem(name)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The namedItem(key) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%name ~EQ 空文字列
］
⇒
~RET ~NULL
◎
If key is the empty string, return null.
</li>

 <li>
<p>
~RET
此れの中の，次のいずれかを満たす`要素$のうち，`最初0$のもの
◎
Return the first element in the collection for which at least one of the following is true:
</p>

  <ul>
   <li>
要素の`~ID$ ~EQ %name
◎
it has an ID which is key;
</li>
   <li>
［
要素は`~HTML~ns$に属する
］~AND［
要素は［ `値$a ~EQ %name ］なる `name^A `属性0$nmを`有する$
］
◎
it is in the HTML namespace and has a name attribute whose value is key;
◎
or null if there is no such element.
</li>
  </ul>
 </li>
</ol>

	</dd>
</dl>

				</section>
			</section>
		</section>
		<section id="mutation-observers">

<h3 title="Mutation observers">4.3. 変異~ob</h3>

<div class="p">
<p>
各 `互いに関係するかつ生成元も類似する閲覧文脈~群$ `HTML$r
— 以下，この節では単に %閲覧文脈~群 と記す —
には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`変異~ob 複合~極小task待入済み@f</dt>
	<dd>
~flag値
— 初期時は ~OFF。
</dd>

	<dt>`変異~ob 通知~list@</dt>
	<dd>
$MutationObserver ~objの~list
— 初期時は空。
</dd>
	<dd class="trans-note">【
この項は、定義を明確化するため，この訳に導入した非公式な用語である。
】</dd>
</dl>

◎
Each unit of related similar-origin browsing contexts has a mutation observer compound microtask queued flag, which is initially unset, and an associated list of MutationObserver objects, which is initially empty. [HTML]
</div>


<p class="algo-head">
`変異~ob 複合~極小taskを待入する@
ときは、次を走らす：
◎
To queue a mutation observer compound microtask, run these steps:
</p>

<ol>
 <li>
~IF［
`変異~ob 複合~極小task待入済み$f ~EQ ~ON
］
⇒
~RET
◎
If mutation observer compound microtask queued flag is set, terminate these steps.
</li>

 <li>
`変異~ob 複合~極小task待入済み$f ~SET ~ON
◎
Set mutation observer compound microtask queued flag.
</li>

 <li>
`変異~obに通知$するための
<a href="~WAPI#compound-microtask">複合~極小task</a>
を
<a href="~WAPI#queue-a-microtask">待入する</a>
◎
Queue a compound microtask to notify mutation observers.
</li>
</ol>


<p class="algo-head">
`変異~obに通知@
するときは、次を走らす：
◎
To notify mutation observers, run these steps:
</p>

<ol>
 <li>
`変異~ob 複合~極小task待入済み$f ← ~OFF
◎
Unset mutation observer compound microtask queued flag.
</li>

 <li>
%通知~list ~LET `変異~ob 通知~list$の複製
◎
Let notify list be a copy of unit of related similar-origin browsing contexts' list of MutationObserver objects.
</li>

 <li>
%通達~slot~list ~LET
%閲覧文脈~群 の`通達~slot~list$の複製
◎
Let signalList be a copy of unit of related similar-origin browsing contexts' signal slot list.
</li>
 <li>
%閲覧文脈~群 の`通達~slot~list$を空にする
◎
Empty unit of related similar-origin browsing contexts' signal slot list.
</li>
 <li>
  <p>
~FOR
%通知~list 内の~EACH ( $MutationObserver ~obj %MO ) に対し
⇒
次の手続きを走らす
<a href="~WAPI#execute-a-compound-microtask-subtask">複合~極小task下位~taskを実行する</a>
`HTML$r
：
◎
For each MutationObserver object mo in notify list, execute a compound microtask subtask to run these steps: [HTML]
</p>

  <ol>
   <li>
%待行列 ~LET %MO の`記録待行列$の複製
◎
Let queue be a copy of mo’s record queue.
</li>

   <li>
%MO の`記録待行列$を空にする
◎
Empty mo’s record queue.
</li>

   <li>
［
`observer^i ~EQ %MO
］なる
`一時~登録済~ob$ をすべて除去する
<!-- どこから？ -->
◎
Remove all transient registered observers whose observer is mo.
</li>

   <li>
<p >
~IF［
%待行列 は空でない
］：
</p>

    <ol>
     <li>
<p>
次を与える下で，`~callback関数を呼出す$：
</p>

<ul ><li>~callback関数~型の値： %MO の`~callback$mo
</li><li>引数~list： ( %待行列,  %MO )
</li><li>`~callback this 値$： %MO
</li></ul>

     </li>
     <li>
~IF［
前~段で例外が投出された
］
⇒
`その例外を報告する$
</li>
    </ol>

◎
If queue is non-empty, invoke mo’s callback with a list of arguments consisting of queue and mo, and mo as the callback this value. If this throws an exception, report the exception.
</li>

  </ol>
 </li>
 <li>
~FOR
%通達~slot~list 内の
~EACH ( `~slot$ %~slot ) に対し，順に
⇒
%~slot に向けて，名前 `slotchange^et の~eventを［
$Event.bubbles 属性 ~SET ~T
］にした上で`発火-$する
◎
For each slot slot in signalList, in order, fire an event named slotchange, with its bubbles attribute set to true, at slot.
</li>
</ol>

<hr>

<p>
各`~node$には、`登録済~ob$ の~listが結付けられる。
◎
Each node has an associated list of registered observers.
</p>

<span class="trans-note">【
すなわち、その~nodeの変異を観測している~obの~list。
この訳では，
（~nodeの）`~ob~list@
と記す。
】</span>

<p>
`登録済~ob@
は、［
`observer^i （ $MutationObserver ~obj ）,
`options^i （ $MutationObserverInit 辞書 ）
］の組である。
`一時~登録済~ob@
とは、この組に加えて，`登録済~ob$である `source^i も持つ，`登録済~ob$の一種である。
◎
A registered observer consists of an observer (a MutationObserver object) and options (a MutationObserverInit dictionary). A transient registered observer is a specific type of registered observer that has a source which is a registered observer.
</p>

<p class="note">注記：
`一時~登録済~ob$は、所与の`~node$に対し，それが除去された後も`~node$の`子孫$における変異を追跡するために利用される
— これにより、`~node$の`親$にて ^subtree が ~T に設定されているとき，それらの変異は失われないようになる。
◎
Transient registered observers are used to track mutations within a given node’s descendants after node has been removed so they do not get lost when subtree is set to true on node’s parent.
</p>
			<section id="interface-mutationobserver">

<h4>4.3.1. ~ifc ^@MutationObserver</h4>

⇒！
[$Constructor($MutationCallback %callback)]
interface @MutationObserver {
  void $observe($Node %target, optional $MutationObserverInit %options);
  void $disconnect();
  sequence&lt;$MutationRecord&gt; $takeRecords();
};

callback @MutationCallback = void (sequence&lt;$MutationRecord&gt; %mutations, $MutationObserver %observer);

dictionary @MutationObserverInit {
  ~B @MutationObserverInit.childList = false;
  ~B @MutationObserverInit.attributes;
  ~B @MutationObserverInit.characterData;
  ~B @MutationObserverInit.subtree = false;
  ~B @MutationObserverInit.attributeOldValue;
  ~B @MutationObserverInit.characterDataOldValue;
  sequence&lt;~DS&gt; @MutationObserverInit.attributeFilter;
};
◎

<!-- MutationObserver^I -->
<p>
$MutationObserver ~objを
`~node$が成す`木$における変異を観測するために利用できる。
◎
A MutationObserver object can be used to observe mutations to the tree of nodes.
</p>

<p>
各 $MutationObserver ~objには、次の概念が結付けられる： 
◎
Each MutationObserver object has these associated concepts:
</p>

<dl class="def-list">
	<dt>`~callback@mo</dt>
	<dd>
~objの作成時に設定される~callback関数。
◎
A callback set on creation.
</dd>

	<dt>`観測している~node~list@</dt>
	<dd>
次の条件を満たす`~node$からなる~list（初期時は空）
⇒
その~nodeの`~ob~list$の中に，この~objを `observer^i に持つような`登録済~ob$が在る。
◎
A list of nodes on which it is a registered observer’s observer that is initially empty.
</dd>

	<dt>`記録待行列@</dt>
	<dd>
$MutationRecord ~objの~list（初期時は空）
◎
A list of MutationRecord objects called the record queue that is initially empty.
</dd>
</dl>



<dl class="domintro">
 <dt>var %observer = new $MutationObserver(callback)</dt>
 <dd>
$MutationObserver ~objを構築し，その
`~callback$moを %callback にする。
%callback が呼出されるときは、その最初の引数に
$MutationRecord ~objの~listが,
２個目の引数には構築された
$MutationObserver ~objが渡される。
%callback は、 $observe() ~methにより登録済にされた`~node$が変異したとき（した後）に，呼出される。
◎
Constructs a MutationObserver object and sets its callback to callback. The callback is invoked with a list of MutationRecord objects as first argument and the constructed MutationObserver object as second argument. It is invoked after nodes registered with the observe() method, are mutated.
</dd>

 <dt>%observer . $observe(target, options)</dt>
 <dd>
%target （ `~node$ ）を観測して，
%options （ ~obj）に与えた判定基準に基づいて変異を報告するように、~UA に~~指示する。
◎
Instructs the user agent to observe a given target (a node) and report any mutations based on the criteria given by options (an object).
</dd>
 <dd>
<p>
%options 引数により、 ~obj~memberを通して，観測させる変異についての~optionを設定できる。
利用できる~obj~memberは：
◎
The options argument allows for setting mutation observation options via object members. These are the object members that can be used:
</p>
  <dl>
   <dt>$MutationObserverInit.childList</dt>
   <dd>
%target の`子$の変異を観測するときは ~T にする。
◎
Set to true if mutations to target’s children are to be observed.
</dd>

   <dt>$MutationObserverInit.attributes</dt>
   <dd>
%target の`属性0$の変異を観測するときは ~T にする。
$MutationObserverInit.attributeOldValue または $MutationObserverInit.attributeFilter を指定している場合は、省略できる。
◎
Set to true if mutations to target’s attributes are to be observed. Can be omitted if attributeOldValue and/or attributeFilter is specified.
</dd>

   <dt>$MutationObserverInit.characterData</dt>
   <dd>
%target の`~data$の変異を観測するときは ~T にする。
$MutationObserverInit.characterDataOldValue を指定している場合は、省略できる。
◎
Set to true if mutations to target’s data are to be observed. Can be omitted if characterDataOldValue is specified.
</dd>

   <dt>$MutationObserverInit.subtree</dt>
   <dd>
%target のみならず，
%target の`子孫$の変異も観測するときは ~T にする。
◎
Set to true if mutations to not just target, but also target’s descendants are to be observed.
</dd>

   <dt>$MutationObserverInit.attributeOldValue</dt>
   <dd>
$MutationObserverInit.attributes を~T にしているか省略していて，かつ
変異~前の %target の`属性0$ `値$aを記録しておく必要がある場合は ~T にする。
◎
Set to true if attributes is true or omitted and target’s attribute value before the mutation needs to be recorded.
</dd>

   <dt>$MutationObserverInit.characterDataOldValue</dt>
   <dd>
$MutationObserverInit.characterData を~T にしているか省略していて，かつ
変異~前の %target の`~data$を記録しておく必要がある場合は ~T にする。
◎
Set to true if characterData is set to true or omitted and target’s data before the mutation needs to be recorded.
</dd>

   <dt>$MutationObserverInit.attributeFilter</dt>
   <dd>
$MutationObserverInit.attributes を~T にしているか省略していて，かつ
すべての`属性0$の変異を観測する必要はない場合は，必要な`属性0$の（`~ns$a のない）`局所名$aの~listにする。
◎
Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted.
</dd>

  </dl>
 </dd>

 <dt>%observer . $disconnect()</dt>
 <dd>
%observer による変異の観測を停止する。
$observe() ~methが再び用いられるまで，
%observer の`~callback$moは呼出されないことになる。
◎
Stops observer from observing any mutations. Until the observe() method is used again, observer’s callback will not be invoked.
</dd>


 <dt>%observer . $takeRecords()</dt>
 <dd>
`記録待行列$を空にして，空にする前の内容を返す。
◎
Empties the record queue and returns what was in there.
</dd>

</dl>

<dl class="idl-def">
	<dt>@MutationObserver(callback)</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
</p>

<ol>
 <li>
%observer ~LET ［
`~callback$mo ~SET %callback
］にされた，新たな $MutationObserver ~obj
</li>

 <li>
`変異~ob 通知~list$に %observer を付加する
</li>

 <li>
~RET %observer
</li>
</ol>

◎
The MutationObserver(callback) constructor must create a new MutationObserver object with callback set to callback, append it to the unit of related similar-origin browsing contexts' list of MutationObserver objects, and then return it.
</dd>

	<dt>@observe(target, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The observe(target, options) method, when invoked, must run these steps:
</p>

<ol>
 <li>
<p>
~IF［［
%options の $MutationObserverInit.attributeOldValue は在する
］~OR［
%options の $MutationObserverInit.attributeFilter は在する
］］~AND［
%options の $MutationObserverInit.attributes は不在
］
⇒
%options の $MutationObserverInit.attributes ~SET ~T
</p>

<p class="trans-note">【
在する（ is present ）, 不在（ is omitted ）
—
<a href="~WEBIDL#dfn-present">present / not present</a>
（ Web IDL ）
】</p>

◎
If either options’ attributeOldValue or attributeFilter is present and options’ attributes is omitted, set options’ attributes to true.
</li>

 <li>
~IF［
%options の $MutationObserverInit.characterDataOldValue は在する
］~AND［
%options の $MutationObserverInit.characterData は不在
］
⇒
%options の $MutationObserverInit.characterData ~SET ~T
◎
If options’ characterDataOldValue is present and options’ characterData is omitted, set options’ characterData to true.
</li>

 <li>
<p>
~IF［
%options の~memberたちについて，次のいずれかが満たされる
］
⇒
~THROW `TypeError^E ：
◎
↓</p>

  <ul>
   <li>
［
$MutationObserverInit.childList ~EQ ~F
］~AND［
$MutationObserverInit.attributes ~EQ ~F
］~AND［
$MutationObserverInit.characterData ~EQ ~F
］
◎
If none of options’ childList, attributes, and characterData is true, throw a TypeError.
</li>

   <li>
［
$MutationObserverInit.attributeOldValue ~EQ ~T
］~AND［
$MutationObserverInit.attributes ~EQ ~F
］
◎
If options’ attributeOldValue is true and options’ attributes is false, throw a TypeError.
</li>

   <li>
［
$MutationObserverInit.attributeFilter は在する
］~AND［
$MutationObserverInit.attributes ~EQ ~F
］
◎
If options’ attributeFilter is present and options’ attributes is false, throw a TypeError.
</li>

   <li>
［
$MutationObserverInit.characterDataOldValue ~EQ ~T
］~AND［
$MutationObserverInit.characterData ~EQ ~F
］
◎
If options’ characterDataOldValue is true and options’ characterData is false, throw a TypeError.
</li>

  </ul>
 </li>

 <li>
%~ob~list ~LET %target の`~ob~list$
◎
↓</li>

 <li>
<p>
~FOR
%~ob~list 内の，［
`observer^i ~EQ 此れ
］なる ~EACH ( `登録済~ob$ %registered ) に対し：
◎
For each registered observer registered in target’s list of registered observers whose observer is the context object:
</p>


  <ol>
   <li>
%~ob~list 内の，［
`source^i ~EQ %registered
］なる ~EACH ( `一時~登録済~ob$ ) に対し
⇒
%~ob~listから それを除去する
◎
Remove all transient registered observers whose source is registered.
</li>

   <li>
%registered の `options^i を %options に置換する
◎
Replace registered’s options with options.
</li>

  </ol>
 </li>

 <li>
~ELSE
<span class="trans-note">【この ~ELSE がどの条件を指しているのか不明
— %~ob~list 内に［
`observer^i ~EQ 此れ
］なる `登録済~ob$ が存在しない場合？
】</span>
⇒
%~ob~list に，［
`observer^i ~SET 此れ,
`options^i ~SET %options
］にされた 新たな`登録済~ob$を追加する；<br>
此れが`観測している~node~list$に %target を追加する
◎
Otherwise, add a new registered observer to target’s list of registered observers with the context object as the observer and options as the options, and add target to context object’s list of nodes on which it is registered.
</li>
</ol>

	<dt>@disconnect()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>

<ol>
 <li>
~FOR
此れが`観測している~node~list$ 内の~EACH ( `~node$ %node ) に対し，順に
⇒
~FOR
%node の`~ob~list$ 内の，［
`observer^i ~EQ 此れ
］なる~EACH ( `登録済~ob$ ) に対し
⇒
%node の`~ob~list$から それを除去する
</li>

 <li id="cp-empty-record-queue">
此れの`記録待行列$を空にする
</li>

</ol>
◎
The disconnect() method must, for each node node in the context object’s list of nodes, remove any registered observer on node for which the context object is the observer, and also empty context object’s record queue.
</dd>

	<dt>@takeRecords()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>

<ol>
 <li>
%結果 ~LET 此れの`記録待行列$の複製
</li>

 <!--cp-empty-record-queue-->

 <li>
~RET %結果
</li>
</ol>

◎
The takeRecords() method, when invoked, must return a copy of the record queue and then empty the record queue.
</dd>
</dl>

			</section>
			<section id="queueing-a-mutation-record">

<h4 title="Queuing a mutation record">4.3.2. 変異~記録を待入する</h4>

<p class="algo-head">
<span class="trans-note">【変異の観測-対象~node】</span> %target に対する
<span class="trans-note">【変異の種別】</span> %type の変異~記録 {
<span class="block" style="white-space: pre-wrap;"
>名前: %名前,
~ns: %~ns,
旧-値: %旧-値,
追加済nodes: %追加済nodes,
除去済nodes: %除去済nodes,
兄: %兄,
弟: %弟</span>
}
<span class="trans-note">【
変異~記録の~member構成は %type に依存する
】</span>
を
`待入する@
ときは、次を走らす：
◎
To queue a mutation record of type for target with one or more of (depends on type) name name, namespace namespace, oldValue oldValue, addedNodes addedNodes, removedNodes removedNodes, previousSibling previousSibling, and nextSibling nextSibling, run these steps:
</p>

<ol>
 <li>
%見守~ob~集合
~LET
空~集合（［
~optionで文字列と組にされ得る， $MutationObserver ~obj
］からなる集合）
◎
Let interested observers be an initially empty set of MutationObserver objects optionally paired with a string.
</li>

 <li>
%nodes ~LET %target のすべての`広義先祖$
◎
Let nodes be the inclusive ancestors of target.
</li>

 <li>
<p>
~FOR
%nodes 内の~EACH ( %node ) に対し
<span class="trans-note">【順序は？】</span>
⇒
~FOR
%node の`~ob~list$ 内の~EACH ( %登録済~ob ) に対し：
◎
Then, for each node in nodes, and then for each registered observer (with registered observer’s options as options) in node’s list of registered observers, run these substeps:
</p>

  <ol>
   <li>
%options ~LET %登録済~ob の `options^i
◎
↓</li>

   <li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If none of the following are true
</p>

    <ul>
     <li>
［
%node ~NEQ %target
］~AND［
%options の $MutationObserverInit.subtree ~EQ ~F
］
◎
node is not target and options’ subtree is false
</li>
     <li>
［
%type ~EQ `attributes^l
］~AND［
%options の $MutationObserverInit.attributes ~NEQ ~T
］
◎
type is "attributes" and options’ attributes is not true
</li>
     <li>
次のいずれも満たされる：

<ul ><li>%type ~EQ `attributes^l
</li><li>%options に $MutationObserverInit.attributeFilter は在する
</li><li>［
%名前 ~NIN %options の $MutationObserverInit.attributeFilter
］~OR［
%~ns ~NEQ ~NULL
］
</li></ul>
◎
type is "attributes", options’ attributeFilter is present, and options’ attributeFilter does not contain name or namespace is non-null
</li>
     <li>
［
%type ~EQ `characterData^l
］~AND［
%options の $MutationObserverInit.characterData ~NEQ ~T
］
◎
type is "characterData" and options’ characterData is not true
</li>

     <li>
［
%type ~EQ `childList^l
］~AND［
%options の ^childList ~EQ ~F
］
◎
type is "childList" and options’ childList is false
</li>
    </ul>
<p>
…ならば
⇒
~CONTINUE
◎
then run these subsubsteps:
</p>
   </li>
   <li>
%~ob ~LET %登録済~ob の `observer^i
◎
↓</li>
   <li>
~IF［
%~ob ~NIN %見守~ob~集合
］
⇒
%~ob を %見守~ob~集合 に付加する
◎
If registered observer’s observer is not in interested observers, append registered observer’s observer to interested observers.
</li>
   <li>
~IF［
次のいずれかが満たされる
］…：

<ul ><li>［
%type ~EQ `attributes^l
］~AND［
%options の $MutationObserverInit.attributeOldValue ~EQ ~T
］
</li><li>［
%type ~EQ `characterData^l
］~AND［
%options の $MutationObserverInit.characterDataOldValue ~EQ ~T
］
</li></ul>

ならば
⇒
<!-- %見守~ob~集合 内の-->
%~ob と組にされる文字列 ~SET %旧-値
<!-- 
前段で 見守~ob~集合 に追加されなかった場合、この段は飛ばされるべきでは？
-->
◎
If either type is "attributes" and options’ attributeOldValue is true, or type is "characterData" and options’ characterDataOldValue is true, set the paired string of registered observer’s observer in interested observers to oldValue.
</li>
  </ol>
 </li>
 <li>

<p>
~FOR
%見守~ob~集合 ~内の~EACH ( %~ob ) に対し：
◎
Then, for each observer in interested observers, run these substeps:
</p>

<!-- ^@MutationRecord -->
  <ol>
   <li>
<p>
%記録 ~LET 各種~属性が以下の様に設定された，新たな $MutationRecord ~obj ：
◎
↓</p>
<!-- 原文から構造を改変 -->
    <ol>
     <li>
$type ~SET %type；<br>
$target ~SET %target
◎
Let record be a new MutationRecord object with its type set to type and target set to target.
</li>

     <li>
~IF［
%名前 と %~ns は与えられている
］
⇒
$attributeName ~SET %名前；<br>
$attributeNamespace ~SET %~ns<br>
◎
If name and namespace are given, set record’s attributeName to name, and record’s attributeNamespace to namespace.
</li>

     <li>
~IF［
%追加済nodes は与えられている
］
⇒
$addedNodes ~SET %追加済nodes
◎
If addedNodes is given, set record’s addedNodes to addedNodes.
</li>

     <li>
~IF［
%除去済nodes は与えられている
］
⇒
$removedNodes ~SET %除去済nodes
◎
If removedNodes is given, set record’s removedNodes to removedNodes,
</li>

     <li>
~IF［
%兄 は与えられている
］
⇒
$previousSibling ~SET %兄
◎
If previousSibling is given, set record’s previousSibling to previousSibling.
</li>

     <li>
~IF［
%弟 は与えられている
］
⇒
$nextSibling ~SET %弟
◎
If nextSibling is given, set record’s nextSibling to nextSibling.
</li>

     <li>
~IF［
%~ob と組にされている文字列が在る
］
⇒
$oldValue ~SET その文字列
◎
If observer has a paired string, set record’s oldValue to observer’s paired string.
</li>

    </ol>
   </li>

   <li>
%記録 を %~ob の`記録待行列$に付加する
◎
Append record to observer’s record queue.
</li>

  </ol>
 </li>

 <li>
`変異~ob 複合~極小taskを待入する$
◎
Queue a mutation observer compound microtask.
</li>

</ol>

			</section>
			<section id="interface-mutationrecord">

<h4>4.3.3. ~ifc ^@MutationRecord</h4>


⇒！
[Exposed=Window]
interface @MutationRecord {
  ~RA ~DS $type;
  [SameObject] ~RA $Node $target;
  [SameObject] ~RA $NodeList $addedNodes;
  [SameObject] ~RA $NodeList $removedNodes;
  ~RA $Node? $previousSibling;
  ~RA $Node? $nextSibling;
  ~RA ~DS? $attributeName;
  ~RA ~DS? $attributeNamespace;
  ~RA ~DS? $oldValue;
};
◎

<dl class="domintro">
 <dt>%record . $type</dt>
 <dd>
`属性0$に対する変異であった場合は `attributes^l を,<br>
$CharacterData `~node$に対する 変異であった場合は `characterData^l を,<br>
`~node$が成す`木$に対する変異であった場合は `childList^l を返す。
◎
Returns "attributes" if it was an attribute mutation. "characterData" if it was a mutation to a CharacterData node. And "childList" if it was a mutation to the tree of nodes.
</dd>

 <dt>%record . $target</dt>
 <dd>
変異に影響された`~node$を返す — $type に応じて
⇒
`attributes^l に対しては，`属性0$が変化した`要素$。<br>
`characterData^l に対しては，$CharacterData `~node$。<br>
`childList^l に対しては，`子$の~listが変化した`~node$。
◎
Returns the node the mutation affected, depending on the type. For "attributes", it is the element whose attribute changed. For "characterData", it is the CharacterData node. For "childList", it is the node whose children changed.
</dd>

 <dt>%record . $addedNodes</dt>
 <dt>%record . $removedNodes</dt>
 <dd>
順に、［
追加-, 除去-
］された`~node$の~listを返す。
◎
Return the nodes added and removed respectively.
</dd>

 <dt>%record . $previousSibling</dt>
 <dt>%record . $nextSibling</dt>
 <dd>
順に、追加-または除去された`~node$が在れば その［
`兄$, `弟$
］を,
無ければ ~NULL を返す。
◎
Return the previous and next sibling respectively of the added or removed nodes, and null otherwise.
</dd>

 <dt>%record . $attributeName</dt>
 <dd>
変化した`属性0$が在れば その`局所名$aを,
無ければ ~NULL を返す。
◎
Returns the local name of the changed attribute, and null otherwise.
</dd>

 <dt>%record . $attributeNamespace</dt>
 <dd>
変化した`属性0$が在れば その`~ns$を,
無ければ ~NULL を返す。
◎
Returns the namespace of the changed attribute, and null otherwise.
</dd>

 <dt>%record . $oldValue</dt>
 <dd>
$type に応じて，次の値を返す
⇒
`attributes^l に対しては，変化した`属性0$の変化~前の`値$a。<br>
`characterData^l に対しては，変化した`~node$の変化~前の`~data$。<br>
`childList^l に対しては， ~NULL 。
◎
The return value depends on type. For "attributes", it is the value of the changed attribute before the change. For "characterData", it is the data of the changed node before the change. For "childList", it is null.
</dd>

</dl>

<dl class="idl-def">
	<dt>@type</dt>
	<dt>@target</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化時の値を返さ~MUST。 
◎
The type and target attributes must return the values they were initialized to.
</dd>

	<dt>@addedNodes</dt>
	<dt>@removedNodes</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化時の値を返さ~MUST。
他が定められない限り、
$MutationRecord ~objの作成時には，いずれも空の $NodeList に初期化されなければならない。
◎
The addedNodes and removedNodes attributes must return the values they were initialized to. Unless stated otherwise, when a MutationRecord object is created, they must both be initialized to an empty NodeList.
</dd>

	<dt>@previousSibling</dt>
	<dt>@nextSibling</dt>
	<dt>@attributeName</dt>
	<dt>@attributeNamespace</dt>
	<dt>@oldValue</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化時の値を返さ~MUST。
他が定められない限り、
$MutationRecord ~objの作成時には，いずれも~NULL に初期化されなければならない。
◎
The previousSibling, nextSibling, attributeName, attributeNamespace, and oldValue attributes must return the values they were initialized to. Unless stated otherwise, when a MutationRecord object is created, they must be initialized to null.
</dd>
</dl>

			</section>
			<section id="garbage-collection">

<h4 title="Garbage collection">4.3.4. ~gc</h4>

<p>
`~node$は、その`~ob~list$に含まれる`登録済~ob$への，強い参照を持つ。
◎
Nodes have a strong reference to registered observers in their list of registered observers.
</p>

<p>
`~node$の`~ob~list$に含まれる`登録済~ob$は、その`~node$への，弱い参照を持つ。
◎
Registered observers in a node’s list of registered observers have a weak reference to the node.
</p>

			</section>
		</section>
		<section id="interface-node">

<h3>4.4. ~ifc ^@Node</h3>

⇒！
[Exposed=Window]
interface @Node : $EventTarget {
  ~CUS $ELEMENT_NODE = 1;
  ~CUS $ATTRIBUTE_NODE = 2;
  ~CUS $TEXT_NODE = 3;
  ~CUS $CDATA_SECTION_NODE = 4;
  ~CUS @ENTITY_REFERENCE_NODE = 5; // <!--cp-histroic-->
  ~CUS @ENTITY_NODE = 6; // <!--cp-histroic-->
  ~CUS $PROCESSING_INSTRUCTION_NODE = 7;
  ~CUS $COMMENT_NODE = 8;
  ~CUS $DOCUMENT_NODE = 9;
  ~CUS $DOCUMENT_TYPE_NODE = 10;
  ~CUS $DOCUMENT_FRAGMENT_NODE = 11;
  ~CUS @NOTATION_NODE = 12; // <!--cp-histroic-->
  ~RA ~US $nodeType;<!-- NodeExodus

  ~ RA ~ DS N.namespaceURI;
  ~ RA ~ DS N.prefix;
  ~ RA ~ DS N.localName;-->
  ~RA ~DS $nodeName;

  ~RA USVString $baseURI;

  ~RA ~B $isConnected;
  ~RA $Document? $ownerDocument;
  $Node $getRootNode(optional $GetRootNodeOptions %options);
  ~RA $Node? $parentNode;
  ~RA $Element? $parentElement;
  ~B $hasChildNodes();
  [SameObject] ~RA $NodeList $childNodes;
  ~RA $Node? $firstChild;
  ~RA $Node? $lastChild;
  ~RA $Node? $previousSibling;
  ~RA $Node? $nextSibling;

  [`CEReactions$] attribute ~DS? $nodeValue;
  [`CEReactions$] attribute ~DS? $textContent;
  [`CEReactions$] void $normalize();

  [`CEReactions$ NewObject] $Node $cloneNode(optional ~B %deep = false);
  ~B $isEqualNode($Node? %otherNode);
  ~B $isSameNode($Node? %otherNode); // <span class="comment" title="historical alias of ==="
  > `===^c 演算子の歴史上の別名</span>

  ~CUS $DOCUMENT_POSITION_DISCONNECTED = 0x01;
  ~CUS $DOCUMENT_POSITION_PRECEDING = 0x02;
  ~CUS $DOCUMENT_POSITION_FOLLOWING = 0x04;
  ~CUS $DOCUMENT_POSITION_CONTAINS = 0x08;
  ~CUS $DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  ~CUS $DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  ~US $compareDocumentPosition($Node %other);
  ~B $contains($Node? %other);

  ~DS? $lookupPrefix(~DS? %namespace);
  ~DS? $lookupNamespaceURI(~DS? %prefix);
  ~B $isDefaultNamespace(~DS? %namespace);

  [`CEReactions$] $Node $insertBefore($Node %node, $Node? %child);
  [`CEReactions$] $Node $appendChild($Node %node);
  [`CEReactions$] $Node $replaceChild($Node %node, $Node %child);
  [`CEReactions$] $Node $removeChild($Node %child);
};

dictionary @GetRootNodeOptions {
  boolean @composed = false;
};
◎

<p class="note">注記：
$@Node は抽象~ifcであり，`~node$として存在することはない。
それは、すべての`~node$（
$Document,
$DocumentType,
$DocumentFragment,
$Element,
$Text,
$ProcessingInstruction,
$Comment
）から利用される。
◎
Node is an abstract interface and does not exist as node. It is used by all nodes (Document, DocumentType, DocumentFragment, Element, Text, ProcessingInstruction, and Comment).
</p>

<p class="trans-note">【
2016 年 8 月の仕様~変更により、 $Attr も $Node を継承するようにされた。
そのため，この仕様の一部には、上の注記のように，そうでないことを前提にした記述が残っていることに注意。
】</p>

<p>
各`~node$には
`~node文書@
が結付けられる。
それは`文書$であり，作成時に設定される。
◎
Each node has an associated node document, set upon creation, that is a document.
</p>
<p class="note">注記：
`~node$の`~node文書$は
`受入-$ ~algoにより変更され得る。
◎
A node’s node document can be changed by the adopt algorithm.
</p>

<p class="trans-note">【
~nodeが`文書~木~内$になくても，結付けられることになる。
】</p>


<p class="algo-head">
所与の~eventの下で，`~node$ %node の`親~targetを取得-$するときは、［
%node の`割当先~slot$ ~NEQ ~NULL ならば それ ／
~ELSE_ %node の`親$
］を返す。
◎
A node’s get the parent algorithm, given an event, returns the node’s assigned slot, if node is assigned, and node’s parent otherwise.
</p>

<p class="trans-note">【
`文書$は、~nodeの親~targetを取得する~algoを上書きする。
】</p>

<hr>

<dl class="domintro">
 <dt>%node . $nodeType</dt>
 <dd>
<p>
次に挙げる数で表現される,
%node の型を返す：
◎
Returns the type of node, represented by a number from the following list:
</p>

  <dl>
   <dt>$Node . $ELEMENT_NODE `(1)^i</dt>
   <dd>
%node は`要素$である。
◎
node is an element.
</dd>

   <dt>$Node . $TEXT_NODE `(3)^i</dt>
   <dd>
%node は $Text `~node$である。
◎
node is a Text node.
</dd>

   <dt>$Node . $CDATA_SECTION_NODE `(4)^i</dt>
   <dd>
%node は $CDATASection `~node$である。
◎
node is a CDATASection node.
</dd>

   <dt>$Node . $PROCESSING_INSTRUCTION_NODE `(7)^i</dt>
   <dd>
%node は $ProcessingInstruction `~node$である。
◎
node is a ProcessingInstruction node.
</dd>

   <dt>$Node . $COMMENT_NODE `(8)^i</dt>
   <dd>
%node は $Comment `~node$である。
◎
node is a Comment node.
</dd>

   <dt>$Node . $DOCUMENT_NODE `(9)^i</dt>
   <dd>
%node は`文書$である。
◎
node is a document.
</dd>

   <dt>$Node . $DOCUMENT_TYPE_NODE `(10)^i</dt>
   <dd>
%node は`文書型$である。
◎
node is a doctype.
</dd>

   <dt>$Node . $DOCUMENT_FRAGMENT_NODE `(11)^i</dt>
   <dd>
%node は`文書片$である。
◎
node is a DocumentFragment node.
</dd>
  </dl>
 </dd>

 <dt>%node . $nodeName</dt>
 <dd>
<p>
%node の型に応じて，次の文字列を返す：
◎
Returns a string appropriate for the type of node, as follows:
</p>
  <dl>
   <dt>$Element</dt>
   <dd>
その $Element.tagName 属性~値
◎
Its tagName attribute value.
</dd>

   <dt>$Attr</dt>
   <dd>
その `有修飾~名$a
◎
Its qualified name.
</dd>

   <dt>$Text</dt>
   <dd>
`#text^l
◎
"#text".
</dd>

   <dt>$CDATASection</dt>
   <dd>
`#cdata-section^l
◎
"#cdata-section".
</dd>

   <dt>$ProcessingInstruction</dt>
   <dd>
その $target
◎
Its target.
</dd>

   <dt>$Comment</dt>
   <dd>
`#comment^l
◎
"#comment".
</dd>

   <dt>$Document</dt>
   <dd>
`#document^l
◎
"#document".
</dd>

   <dt>$DocumentType</dt>
   <dd>
その`文書型名$
◎
Its name.
</dd>

   <dt>$DocumentFragment</dt>
   <dd>
`#document-fragment^l
◎
"#document-fragment".
</dd>
  </dl>
 </dd>
</dl>

<dl class="idl-def">
	<dt>@nodeType</dt>
	<dd>
<p>
取得子は、此れの型に応じて，次を返さ~MUST（括弧内は数値）：
◎
The nodeType attribute’s getter, when invoked, must return the first matching statement, switching on the context object:
</p>


<dl class="switch"><dt>$Element
</dt><dd>@ELEMENT_NODE (1)

</dd><dt>$Attr
</dt><dd>@ATTRIBUTE_NODE (2)

</dd><dt>$Text
</dt><dd>@TEXT_NODE (3)

</dd><dt>$CDATASection
</dt><dd>@CDATA_SECTION_NODE (4)

</dd><dt>$ProcessingInstruction
</dt><dd>@PROCESSING_INSTRUCTION_NODE (7)

</dd><dt>$Comment
</dt><dd>@COMMENT_NODE (8)

</dd><dt>$Document
</dt><dd>@DOCUMENT_NODE (9)

</dd><dt>$DocumentType
</dt><dd>@DOCUMENT_TYPE_NODE (10)

</dd><dt>$DocumentFragment
</dt><dd>@DOCUMENT_FRAGMENT_NODE (11)

</dd></dl>

	<dt>@nodeName</dt>
	<dd>
<p>
取得子は、此れの型に応じて，次を返さ~MUST。
◎
The nodeName attribute’s getter, when invoked, must return the first matching statement, switching on the context object:
</p>
<!-- copy* -->
<dl class="switch">
 <dt>$Element</dt>
 <dd>
此れの $Element.tagName 属性~値
◎
Its tagName attribute value.
</dd>

 <dt>$Attr</dt>
 <dd>
此れの`有修飾~名$a
◎
Its qualified name.
</dd>

 <dt>$Text</dt>
 <dd>
`#text^l
◎
"#text".
</dd>

 <dt>$CDATASection</dt>
 <dd>
`#cdata-section^l
◎
"#cdata-section".
</dd>

 <dt>$ProcessingInstruction</dt>
 <dd>
此れの`~target$
◎
Its target.
</dd>

 <dt>$Comment</dt>
 <dd>
`#comment^l
◎
"#comment".
</dd>

 <dt>$Document</dt>
 <dd>
`#document^l
◎
"#document".
</dd>

 <dt>$DocumentType</dt>
 <dd>
此れの`文書型名$
◎
Its name.
</dd>

 <dt>$DocumentFragment</dt>
 <dd>
`#document-fragment^l
◎
"#document-fragment".
</dd>
</dl>

	</dd>
</dl>


<dl class="domintro">
 <dt>%node . $baseURI</dt>
 <dd>
%node の`~node文書$の`文書~基底URL$を返す。
◎
Returns node’s node document’s document base URL.
</dd>

</dl>

<dl class="idl-def">
	<dt>@baseURI</dt>
	<dd>
取得子は、此れの`~node文書$の`文書~基底URL$を`直列化-$した結果を返さ~MUST。
◎
The baseURI attribute’s getter must return node document’s document base URL, serialized.
</dd>
</dl>


<dl class="domintro">
 <dt>%node . $isConnected</dt>
 <dd>
［
%node は`接続され$ているならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if node is connected and false otherwise.
</dd>

 <dt>%node . $ownerDocument</dt>
 <dd>
`~node文書$を返す。
`文書$に対しては~NULL を返す。
◎
Returns the node document. Returns null for documents.
</dd>

 <dt>%node . $getRootNode()</dt>
 <dd>
%node の`根$を返す。
◎
Returns node’s root.
</dd>

 <dt>%node . $getRootNode({ composed:true })</dt>
 <dd>
%node の`~shadowも含む根$を返す。
◎
Returns node’s shadow-including root.
</dd>

 <dt>%node . $parentNode</dt>
 <dd>
`親$を返す。
◎
Returns the parent.
</dd>

 <dt>%node . $parentElement</dt>
 <dd>
`親~要素$を返す。
◎
Returns the parent element.
</dd>

 <dt>%node . $hasChildNodes()</dt>
 <dd>
%node が`子$を持っているかどうかを返す。
◎
Returns whether node has children.
</dd>

 <dt>%node . $childNodes</dt>
 <dd>
すべての`子$を返す。
◎
Returns the children.
</dd>

 <dt>%node . $firstChild</dt>
 <dd>
`最初0の子$を返す。
◎
Returns the first child.
</dd>

 <dt>%node . $lastChild</dt>
 <dd>
`最後0の子$を返す。
◎
Returns the last child.
</dd>

 <dt>%node . $previousSibling</dt>
 <dd>
`兄$を返す。
◎
Returns the previous sibling.
</dd>

 <dt>%node . $nextSibling</dt>
 <dd>
`弟$を返す。
◎
Returns the next sibling.
</dd>
</dl>

<dl class="idl-def">
	<dt>@isConnected</dt>
	<dd>
取得子は、［
此れは`接続され$ているならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The isConnected attribute’s getter must return true, if context object is connected, and false otherwise.
</dd>

	<dt>@ownerDocument</dt>
	<dd>
取得子は、［
此れは`文書$である ならば ~NULL ／
~ELSE_ 此れの`~node文書$
］を返さ~MUST。
◎
The ownerDocument attribute’s getter must return null, if the context object is a document, and the context object’s node document otherwise.
</dd>
	<dd class="note">注記：
`文書$の`~node文書$は，`文書$ 自身である。
すべての`~node$は、どの時点であれ，`~node文書$を持つ。
◎
The node document of a document is that document itself. All nodes have a node document at all times.
</dd>

	<dt>@getRootNode(options)</dt>
	<dd>
取得子は、［［
%options の ^composed ~EQ ~T
］ならば 此れの`~shadowも含む根$ ／
~ELSE_ 此れの`根$
］を返さ~MUST。
◎
The getRootNode(options) attribute’s getter must return context object’s shadow-including root if options’s composed is true, and context object’s root otherwise.
</dd>

	<dt>@parentNode</dt>
	<dd>
取得子は、此れの`親$を返さ~MUST。
◎
The parentNode attribute’s getter must return the context object’s parent.
</dd>
	<dd class="note">注記：
$Attr `~node$には親はない。
◎
An Attr node has no parent.
</dd>

	<dt>@parentElement</dt>
	<dd>
取得子は、此れの`親~要素$を返さ~MUST。
◎
The parentElement attribute’s getter must return the context object’s parent element.
</dd>

	<dt>@hasChildNodes()</dt>
	<dd>
被呼出時には、［
此れは`子$を持つならば~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The hasChildNodes() method, when invoked, must return true if the context object has children, and false otherwise.
</dd>

	<dt>@childNodes</dt>
	<dd>
取得子は、次のようにされた $NodeList `~collection$を返さ~MUST
⇒
`根$cl ~SET 此れ,<br>
`~filter$は 此れの`子$のみに合致する
◎
The childNodes attribute’s getter must return a NodeList rooted at the context object matching only children.
</dd>

	<dt>@firstChild</dt>
	<dd>
取得子は、此れの`最初0の子$を返さ~MUST。
◎
The firstChild attribute’s getter must return the context object’s first child.
</dd>

	<dt>@lastChild</dt>
	<dd>
取得子は、此れの`最後0の子$を返さ~MUST。
◎
The lastChild attribute’s getter must return the context object’s last child.
</dd>

	<dt>@previousSibling</dt>
	<dd>
取得子は、此れの`兄$を返さ~MUST。
◎
The previousSibling attribute’s getter must return the context object’s previous sibling.
</dd>
	<dd class="note">注記：
$Attr `~node$には`同胞$はない。
◎
An Attr node has no siblings.
</dd>

	<dt>@nextSibling</dt>
	<dd>
取得子は、此れの`弟$を返さ~MUST。
◎
The nextSibling attribute’s getter must return the context object’s next sibling.
</dd>

	<dt>@nodeValue</dt>
	<dd>
<p>
取得子は、此れの型に応じて，次を返さ~MUST：
</p>

<dl class="switch">
 <dt>$Attr</dt>
 <dd>
此れの`値$a
◎
Context object’s value.
</dd>

 <dt>`文字~data~node$◎Text, ProcessingInstruction, Comment</dt>
 <dd>
此れの`~data$
◎
Context object’s data.
</dd>

 <dt>他の~node</dt>
 <dd>
~NULL
</dd>
</dl>

	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The nodeValue attribute must, on setting, if the new value is null, act as if it was the empty string instead, and then do as described below, depending on the context object:
</p>

<ol>
 <li>
%値 ~LET ［
所与の値 ~NEQ ~NULL ならば それ ／
~ELSE_ 空文字列
］
◎
↑</li>
 <li>
<p>
此れの型に応じて：
</p>

  <dl class="switch">
   <dt>$Attr</dt>
   <dd>
( 此れ, %値 )
で`既存の属性0値を設定-$する
◎
Set an existing attribute value with context object and new value.
</dd>

   <dt>`文字~data~node$◎Text, ProcessingInstruction, Comment</dt>
   <dd>
次を与える下で，此れの`~dataを置換-$する
⇒
~offset: 0,<br>
~count: 此れの`~length$,<br>
~data: %値
◎
Text, ProcessingInstruction, Comment
◎
Replace data with node context object, offset 0, count context object’s length, and data new value.
</dd>

   <dt>他の~node</dt>
   <dd>
何もしない
◎
Do nothing.
</dd>
  </dl>
 </li>
</ol>

</dd>

	<dt>@textContent</dt>
	<dd>
<p>
取得子は、此れの型に応じて，次を返さ~MUST：
◎
The textContent attribute’s getter must return the following, switching on context object:
</p>

<dl class="switch">
 <dt>$DocumentFragment</dt>
 <dt>$Element</dt>
 <dd>
此れのすべての $Text `~node$`子孫$の`~data$を，`木~順序$で連結した結果
◎
The concatenation of data of all the Text node descendants of the context object, in tree order.
</dd>

 <dt>$Attr</dt>
 <dd>
此れの`値$a
◎
Context object’s value.
</dd>

 <dt>`文字~data~node$◎Text, ProcessingInstruction, Comment</dt>
 <dd>
此れの`~data$
◎
Context object’s data.
</dd>

<!-- 他の~node -->
 <dt>$Document</dt>
 <dt>$DocumentType</dt>
 <dd>
~NULL
◎
Null.
</dd>
</dl>

	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The textContent attribute’s setter must, if the given value is null, act as if it was the empty string instead, and then do as described below, switching on context object:
</p>

<ol>
 <li>
%値 ~LET ［
所与の値 ~NEQ ~NULL ならば それ ／
~ELSE_ 空文字列
］
◎
↑</li>

 <li>
<p>
此れの型に応じて：
</p>

  <dl class="switch">

   <dt>$DocumentFragment</dt>
   <dt>$Element</dt>
   <dd>
    <ol>
     <li>
%node ~LET ~NULL
◎
Let node be null.
</li>
     <li>
~IF［
%値 ~NEQ 空文字列
］
⇒
%node ~SET `新たな~text~node$( %値, 此れの`~node文書$ )
◎
If the given value is not the empty string, set node to a new Text node whose data is the given value and node document is context object’s node document.
</li>
     <li>
此れ の内容を %node で`すべて置換-$する
◎
Replace all with node within the context object.
</li>
    </ol>
   </dd>

   <dt>$Attr</dt>
   <dd>
( 此れ, 所与の値 )
で`既存の属性0値を設定-$する
◎
Set an existing attribute value with context object and new value.
</dd>

   <dt>`文字~data~node$◎Text, ProcessingInstruction, Comment</dt>
   <dd>
次を与える下で，此れの`~dataを置換-$する
⇒
~offset: 0,<br>
~count: 此れの`~length$,<br>
~data: %値
◎
Replace data with node context object, offset 0, count context object’s length, and data the given value.
</dd>

<!-- 他の~node -->
   <dt>$Document</dt>
   <dt>$DocumentType</dt>
   <dd>
何もしない
◎
Do nothing.
</dd>

  </dl>
 </li>
</ol>

	</dd>
</dl>


<dl class="domintro">
 <dt>%node . $normalize()</dt>
 <dd>
%node に含まれている`空$の`狭義の~Text0~node$は除去し、`連続的な狭義の~Text0~node列$に対しては，その最初の`~node$に~~後続の`~data$を連結してひとまとめにする。
◎
Removes empty exclusive Text nodes and concatenates the data of remaining contiguous exclusive Text nodes into the first of their nodes.
</dd>
 <dd class="trans-note">【
この記述は、 “除去-” と “連結-” の順序に関し，微妙に正確でない
— 実際の~algoでは、空 ^Text ~nodeのうち，［
最初の~node %N が空でないような`連続的な狭義の~Text0~node列$
］に含まれるものは、後続の空 ^Text ~nodeより先に %N に連結される（その結果として，除去されるが）。
<!-- 
結果の~node木は同じでも，変異の通知~順序は異なり得る。
 -->
】</dd>

</dl>


<dl class="idl-def">
	<dt>@normalize()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The normalize() method, when invoked, must run these steps for each descendant exclusive Text node node of context object:
</p>

<ol>
 <li>
<p>
~FOR
此れの`子孫$である ~EACH ( `狭義の~Text0~node$ %node ) に対し：
◎
Let node be the Text node descendant.
</p>

<p class="trans-note">【
木~順序で。
加えて，~~厳密に述べるなら、このループの処理で木から除去される ^Text ~nodeは（動的に）反復対象から除外する必要もある。
】</p>

  <ol>
   <li>
%~length ~LET %node の`~length$
◎
Let length be node’s length.
</li>

   <li>
%~length ~EQ 0
⇒
%node をその親から`除去-$する；<br>
~CONTINUE
◎
If length is zero, then remove node and continue with the next exclusive Text node, if any.
</li>

   <li>
%除去対象 ~LET %node の`連続的な狭義の~Text0~node列$から %node 自身（常に先頭になる）は除外した結果の~list
◎
↓</li>

   <li>
%data ~LET %除去対象 内の ~EACH ( %text ) の`~data$を順に連結した結果
◎
Let data be the concatenation of the data of node’s contiguous exclusive Text nodes (excluding itself), in tree order.
</li>

   <li>
次を与える下で， %node の`~dataを置換-$する
⇒
~offset: %~length,<br>
~count: 0,<br>
~data: %data
◎
Replace data with node node, offset length, count 0, and data data.
</li>

   <li>
<p>
~FOR
%除去対象 内の ~EACH ( %text ) に対し，順に：
◎
Let currentNode be node’s next sibling.
◎
While currentNode is an exclusive Text node:
</p>

    <ol>
     <li>
<p>
~FOR
~EACH ( `範囲0$ %R ) に対し：
◎

↓</p>
      <ol>
       <li>
~IF［
%R の`始点~node$ ~EQ %text
］
⇒
%R の`始点~offset$ ~INCBY %~length；<br>
%R の`始点~node$ ~SET %node
◎
For each range whose start node is currentNode, add length to its start offset and set its start node to node.
</li>

       <li>
~IF［
%R の`終点~node$ ~EQ %text
］
⇒
%R の`終点~offset$ ~INCBY %~length；<br>
%R の`終点~node$ ~SET %node
◎
For each range whose end node is currentNode, add length to its end offset and set its end node to node.
</li>

       <li>
~IF［
%R の`始点~node$ ~EQ %text の`親$
］~AND［
%R の`始点~offset$ ~EQ %text の`指数$
］
⇒
%R の`始点~node$ ~SET %node；<br>
%R の`始点~offset$ ~SET %~length
◎
For each range whose start node is currentNode’s parent and start offset is currentNode’s index, set its start node to node and its start offset to length.
</li>

       <li>
~IF［
%R の`終点~node$ ~EQ %text の`親$
］~AND［
%R の`終点~offset$ ~EQ %text の`指数$
］
⇒
%R の`終点~node$ ~SET %node；<br>
%R の`終点~offset$ ~SET %~length
◎
For each range whose end node is currentNode’s parent and end offset is currentNode’s index, set its end node to node and its end offset to length.
</li>
      </ol>
     </li>
     <li>
%~length ~INCBY %text の`~length$
◎
Add currentNode’s length to length.
◎
Set currentNode to its next sibling.
</li>

    </ol>
   </li>

   <li>
~FOR
%除去対象 内の~EACH ( %text ) に対し，順に
⇒
%text をその親から`除去-$する
◎
Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.
</li>

  </ol>
 </li>
</ol>

	</dd>
</dl>


<dl class="domintro">
 <dt>%node . $cloneNode([deep = false])</dt>
 <dd>
%node の複製を返す。
%deep が~T の場合、複製には %node の`子孫$も含められる。
◎
Returns a copy of node. If deep is true, the copy also includes the node’s descendants.
</dd>

 <dt>%node . $isEqualNode(otherNode)</dt>
 <dd>
%node と %otherNode が同じ~propを持つかどうかを返す。
◎
Returns whether node and otherNode have the same properties.
</dd>
</dl>


<p>
`適用仕様$は、すべてのまたは一部の`~node$に対し,
`~clone時の手続き@
を定義してもよい。
~algoには，`~clone$ ~algoにて指示される
( %複製, %node, %文書, `~clone子孫^f（省略時は ~OFF ） )
が渡される。
◎
Specifications may define cloning steps for all or some nodes. The algorithm is passed copy, node, document, and an optional clone children flag, as indicated in the clone algorithm.
</p>

<p class="note">注記：
~HTMLは
`script$e ／ `input$e
要素に対する`~clone時の手続き$を定義する。
~SVGもその `script^e 要素に対し同様にされるべきだが、現時点では，呼び出すことはない。
◎
HTML defines cloning steps for script and input elements. SVG ought to do the same for its script elements, but does not call this out at the moment.
</p>


<p class="algo-head">
( `文書^i： %文書, `~clone子孫^f )
（いずれも省略可）が与えられた下で，
%node を
`~clone@
するときは、次を走らす：
◎
To clone a node, with an optional document and clone children flag, run these steps:
</p>



<ol>
 <li>
~IF［
%文書 は与えられていない
］
⇒
%文書 ~LET %node の`~node文書$
◎
If document is not given, let document be node’s node document.
</li>

 <li>
<p>
~IF［
%node は`要素$である
］：
◎
If node is an element, then:
</p>

  <ol>
   <li>
%値 ~LET ［
%node は `is^A `属性0$nmを有するならば その値 ／
~ELSE_ ~NULL
］
◎
↓</li>
   <li>
<p>
%複製 ~LET
`新たな要素$( %文書, %node の`局所名$, %node の`~ns$, %node の`~ns接頭辞$, %値, %同期~custom要素~flag )
— ここで
⇒
%同期~custom要素~flag は ~OFF にするべきである
◎
Let copy be the result of creating an element, given document, node’s local name, node’s namespace, node’s namespace prefix, and the value of node’s is attribute if present (or null if not). The synchronous custom elements flag should be unset.
</li>
   <li>
~FOR
%node の`属性0~list$内の ~EACH ( %属性0 ) に対し
⇒
［
%属性0 を`~clone$した結果
］を %複製 に`付加-$する
◎
For each attribute in node’s attribute list, in order, run these substeps:
• Let copyAttribute be a clone of attribute.
• Append copyAttribute to copy.
</li>
  </ol>
 </li>
 <li>
<p>
~ELSE
⇒
%複製 ~LET  %node の型に応じて，次のように設定された，［
%node と同じ~ifcを実装する新たな`~node$
］：
◎
Otherwise, let copy be a node that implements the same interfaces as node, and fulfills these additional requirements, switching on node:
</p>

  <dl class="switch">
   <dt>$Document</dt>
   <dd>
%複製 の［
`符号化方式$, `内容型$, `文書URL$, `種別$, `~mode$
］ ~SET %node のそれら
◎
Set copy’s encoding, content type, URL, type, and mode, to those of node.
</dd>

   <dt>$DocumentType</dt>
   <dd>
%複製 の［
`文書型名$,
`~publicID$,
`~systemID$
］ ~SET %node のそれら
◎
Set copy’s name, public ID, and system ID, to those of node.
</dd>

   <dt>$Attr</dt>
   <dd>
%複製 の［
`~ns$a,
`~ns接頭辞$a,
`局所名$a,
`値$a,
］ ~SET %node のそれら
◎
Set copy’s namespace, namespace prefix, local name, and value, to those of node.
</dd>

   <dt>$Text</dt>
   <dt>$Comment</dt>
   <dd>
%複製 の`~data$ ~SET %node のそれ
◎
Set copy’s data, to that of node.
</dd>

   <dt>$ProcessingInstruction</dt>
   <dd>
%複製 の［
$ProcessingInstruction.target,
`~data$
］ ~SET %node のそれら
◎
Set copy’s target and data to those of node.
</dd>

<!-- 他の~node -->
   <dt>他の~node</dt>
   <dd>
—
<span class="trans-note">【
すなわち， $DocumentFragment になるが、未策定？複製される項目がない？
】</span>
◎
—
</dd>

  </dl>
 <li>
~IF［
%複製 は`文書$である
］
⇒
%文書 ~SET %複製
◎
↓</li>
 <li>
%複製 の`~node文書$ ~SET %文書
◎
Set copy’s node document and document to copy, if copy is a document, and set copy’s node document to document otherwise.
</li>
 <li>
他の`適用仕様$において %node に対し定義されている`~clone時の手続き$があれば，
( %複製, %node, %文書, `~clone子孫^f )
を与える下で，それを走らす
◎
Run any cloning steps defined for node in other applicable specifications and pass copy, node, document and the clone children flag if set, as parameters.
</li>
 <li>
~IF［
`~clone子孫^f ~EQ ~ON
］
⇒
~FOR
%node の~EACH ( `子$ %子 ) に対し
<span class="trans-note">【木~順序で】</span>
⇒
( `文書^i： %文書, `~clone子孫^f： ~ON )
を与える下で，
%子 を`~clone$した結果を %複製 に付加する
◎
If the clone children flag is set, clone all the children of node and append them to copy, with document as specified and the clone children flag being set.
</li>

 <li>
~RET %複製
◎
Return copy.
</li>

</ol>


<dl class="idl-def">
	<dt>@cloneNode(deep)</dt>
	<dd>
被呼出時には、次を走らせ~MUST：
◎
The cloneNode(deep) method, when invoked, must run these steps:
</dd>
</dl>

<ol>
	<li>
~IF［
此れは`~shadow根$である
］
⇒
~THROW `NotSupportedError^E
◎
If context object is a shadow root, then throw a NotSupportedError.
</li>
	<li>
~RET ［
( `~clone子孫^f：［
%deep ~EQ ~T ならば ~ON ／
~ELSE_ ~OFF
］ )
を与える下で，此れを`~clone$した結果
◎
Return a clone of the context object, with the clone children flag set if deep is true.
</li>
</ol>

<p class="algo-head">
２つの`~node$ %A, %B は、次のいずれの条件も満たすならば，
`等しい@
とされる。
◎
A node A equals a node B if all of the following conditions are true:
</p>

<ul>
 <li>
%A と %B の $nodeType 属性~値は一致する。
◎
A and B’s nodeType attribute value is identical.
</li>

 <li>
<p>
%A の型に応じて，次も等しい：
◎
The following are also equal, depending on A:
</p>

  <dl class="switch">
   <dt>$DocumentType</dt>
   <dd>
`文書型名$,
`~publicID$,
`~systemID$
◎
Its name, public ID, and system ID.
</dd>

   <dt>$Element</dt>
   <dd>
`~ns$,
`~ns接頭辞$,
`局所名$,
［
`属性0~list$内の`属性0$の個数
］
◎
Its namespace, namespace prefix, local name, and its number of attributes in its attribute list.
</dd>

   <dt>$Attr</dt>
   <dd>
`~ns$a,
`局所名$a,
`値$a
◎
Its namespace, local name, and value.
</dd>

   <dt>$ProcessingInstruction</dt>
   <dd>
`~target$,
`~data$
◎
Its target and data.
</dd>

   <dt>$Text</dt>
   <dt>$Comment</dt>
   <dd>
`~data$
◎
Its data.
</dd>

<!-- 他の~node -->
   <dt>その他</dt>
   <dd>
—
</dd>
	<dd class="trans-note">【
すなわち，
$Document, $DocumentFragment （ $ShadowRoot ）
が該当するが、未策定？（少なくとも、 %A と %B が同一であれば，等しいとされるべき？）
<!-- ＊ isEqualNode -->
】</dd>

  </dl>
 </li>
 <li>
%A が`要素$である場合は
⇒
その`属性0~list$内のどの`属性0$ %属性 に対しても
⇒
%B の`属性0~list$内に %属性 に`等しい$`属性0$が在る
◎
If A is an element, each attribute in its attribute list has an attribute that equals an attribute in B’s attribute list.
</li>

<li>
%A と %B は同じ個数の`子$を持つ
◎
A and B have the same number of children.
</li>

<li>
%A のどの`子$も，同じ`指数$に位置する %B の`子$に`等しい$
◎
Each child of A equals the child of B at the identical index.
</li>
</ul>


<dl class="idl-def">
	<dt>@isEqualNode(otherNode)</dt>
	<dd>
被呼出時には、［［
%otherNode ~NEQ ~NULL
］~AND［
此れと %otherNode は`等しい$
］ならば~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The isEqualNode(otherNode) method, when invoked, must return true if otherNode is non-null and context object equals otherNode, and false otherwise.
</dd>

	<dt>@isSameNode(otherNode)</dt>
	<dd>
被呼出時には、［［
%otherNode ~EQ 此れ
］ならば~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The isSameNode(otherNode) method, when invoked, must return true if otherNode is context object, and false otherwise.
</dd>

</dl>


<!-- ADD %node →<code >%node</code> -->
<dl class="domintro">
 <dt>%node . $compareDocumentPosition(other)</dt>
 <dd>

<p>
%node に相対的な %other の位置を指示する~bitmaskを返す。
~bitは次のように設定される：
◎
Returns a bitmask indicating the position of other relative to node. These are the bits that can be set:
</p>

  <dl>
   <dt>$Node . $DOCUMENT_POSITION_DISCONNECTED `(1)^i</dt>
   <dd>
%node と %other が同じ`木$に属さないならば~ON にされる。
◎
Set when node and other are not in the same tree.
</dd>

   <dt>$Node . $DOCUMENT_POSITION_PRECEDING `(2)^i</dt>
   <dd>
%other が %node に`先行-$するならば~ON にされる。
◎
Set when other is preceding node.
</dd>

   <dt>$Node . $DOCUMENT_POSITION_FOLLOWING `(4)^i</dt>
   <dd>
%other が %node に`後続-$するならば~ON にされる。
◎
Set when other is following node.
</dd>

   <dt>$Node . $DOCUMENT_POSITION_CONTAINS `(8)^i</dt>
   <dd>
%other が %node の`先祖$であるならば~ON にされる。
◎
Set when other is an ancestor of node.
</dd>

   <dt>$Node . $DOCUMENT_POSITION_CONTAINED_BY `(16)^i</dt>
   <dd>
%other が %node の`子孫$であるならば~ON にされる。
◎
Set when other is a descendant of node.
</dd>
  </dl>
 </dd>

 <dt>%node . $contains(other)</dt>
 <dd>
%other が %node の`広義子孫$ならば ~T,
他の場合は~F を返す。
◎
Returns true if other is an inclusive descendant of node, and false otherwise.
</dd>
</dl>

<p>
次のものは
$compareDocumentPosition()
が~bitmaskとして返す定数である：
◎
These are the constants compareDocumentPosition() returns as mask:
</p>

<ul><li>@DOCUMENT_POSITION_DISCONNECTED (1)
</li><li>@DOCUMENT_POSITION_PRECEDING (2)
</li><li>@DOCUMENT_POSITION_FOLLOWING (4)
</li><li>@DOCUMENT_POSITION_CONTAINS (8)
</li><li>@DOCUMENT_POSITION_CONTAINED_BY (16, 16進 10)
</li><li>@DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC (32, 16進 20)
</li></ul>


<dl class="idl-def">
	<dt>@compareDocumentPosition(other)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The compareDocumentPosition(other) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
此れ ~EQ %other
］
⇒
~RET 0
◎
If context object is other, then return zero.
</li>
 <li>
( %他~node, %自~node ) ~LET ( %other, 此れ )
◎
Let node1 be other and node2 be context object.
</li>
 <li>
( %他~属性0, %自~属性0 ) ~LET ( ~NULL, ~NULL )
◎
Let attr1 and attr2 be null.
</li>
 <li>
~IF［
%他~node は`属性0$である
］
⇒
%他~属性0 ~SET %他~node；<br>
%他~node ~SET %他~属性0 が`属する要素$
◎
If node1 is an attribute, then set attr1 to node1 and node1 to attr1’s element.
</li>
 <li>
<p>
~IF［
%自~node は`属性0$である
］：
◎
If node2 is an attribute, then:
</p>
  <ol>
   <li>
%自~属性0 ~SET %自~node；<br>
%自~node ~SET %自~属性0 が`属する要素$
◎
Set attr2 to node2 and node2 to attr2’s element.
</li>
   <li>
<p>
~IF［
%他~属性0 ~NEQ ~NULL
］~AND［
%自~属性0 ~NEQ ~NULL
］~AND［
%自~node ~EQ %他~node
］：
◎
If attr1 and node1 are non-null, and node2 is node1, then:
</p>
    <ol>
     <li>
<p>
~FOR
%自~node の`属性0~list$内の
~EACH ( `属性0$ %属性0 ) に対し：
◎
For each attribute attr in node2’s attribute list:
</p>
      <ol>
       <li>
~IF［
( %属性0, %他~属性0 )
は`等しい$
］
⇒
~RET 
$DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS
$DOCUMENT_POSITION_PRECEDING
◎
If attr equals attr1, then return the result of adding DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_PRECEDING.
</li>
       <li>
~IF［
( %属性0, %自~属性0 )
は`等しい$
］
⇒
~RET
$DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS
$DOCUMENT_POSITION_FOLLOWING
◎
If attr equals attr2, then return the result of adding DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_FOLLOWING.
</li>
      </ol>
     </li>
    </ol>
   </li>
  </ol>
 </li>
 <li>
<p>
~IF［
%他~node ~EQ ~NULL
］~OR［
%自~node ~EQ ~NULL
］~OR［
%他~node の`根$ ~NEQ %自~node の`根$
］
⇒
~RET ［
$DOCUMENT_POSITION_DISCONNECTED ~PLUS $DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS ［
$DOCUMENT_POSITION_PRECEDING または $DOCUMENT_POSITION_FOLLOWING
（ただし，いずれが~~選択されるかは一貫するものとする）］
］
◎
If node1 or node2 is null, or node1’s root is not node2’s root, then return the result of adding DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.
</p>

<p class="note">注記：
$DOCUMENT_POSITION_PRECEDING, $DOCUMENT_POSITION_FOLLOWING
のいずれを返値に用いるかは，概して~pointer比較により行われる。
JavaScript 実装においては `Math.random()^c で~~決定し得る。
◎
Whether to return DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is typically implemented via pointer comparison. In JavaScript implementations a cached Math.random() value can be used.
</p>

<p class="trans-note">【
“一貫する”
— 理想的には，各~node木の間の全順序関係も保たれるように一貫させるべきであろう。
】</p>

 </li>
 <li>
~IF［［
%他~node ~AN %自~node
］~AND［
%他~属性0 ~EQ ~NULL
］］~OR［［
%他~node ~EQ %自~node
］~AND［
%自~属性0 ~NEQ ~NULL
］］
⇒
~RET $DOCUMENT_POSITION_CONTAINS ~PLUS $DOCUMENT_POSITION_PRECEDING
◎
If node1 is an ancestor of node2 and attr1 is null, or node1 is node2 and attr2 is non-null, then return the result of adding DOCUMENT_POSITION_CONTAINS to DOCUMENT_POSITION_PRECEDING.
</li>
 <li>
~IF［［
%他~node ~DE %自~node
］~AND［
%自~属性0 ~EQ ~NULL
］］~OR［［
%他~node ~EQ %自~node
］~AND［
%他~属性0 ~NEQ ~NULL
］］
⇒
~RET 
$DOCUMENT_POSITION_CONTAINED_BY ~PLUS $DOCUMENT_POSITION_FOLLOWING
◎
If node1 is a descendant of node2 and attr2 is null, or node1 is node2 and attr1 is non-null, then return the result of adding DOCUMENT_POSITION_CONTAINED_BY to DOCUMENT_POSITION_FOLLOWING.
</li>
 <li>
~IF［
%他~node は %自~node に`先行-$する
］
⇒
~RET $DOCUMENT_POSITION_PRECEDING
◎
If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.
</li>
 <li>
<p>
~RET $DOCUMENT_POSITION_FOLLOWING
◎
Return DOCUMENT_POSITION_FOLLOWING.
</p>

<p class="note">
`属性0$は`木$に`関与-$しないが、この~algoに因り、`属性0$は，［
それを有する`要素$
］の`子$に`先行-$するものとされることになる。
◎
Due to the way attributes are handled in this algorithm this results in a node’s attributes counting as preceding that node’s children, despite attributes not participating in a tree.
</p>
 </li>
</ol>
	</dd>

	<dt>@contains(other)</dt>
	<dd>
<p >
被呼出時には、次を走らせ~MUST：
</p>

<ol>
 <li>
~IF［
%other ~EQ null
］
⇒
~RET ~F
</li>
 <li>
~IF［
%other ~iDE 此れ
］
⇒
~RET ~T
</li>
 <li>
~RET ~F
</li>
</ol>

◎
The contains(other) method, when invoked, must return true if other is an inclusive descendant of context object, and false otherwise (including when other is null).
</dd>
</dl>



<p class="algo-head">
%要素 に対し，
%~ns を用いて
`~ns接頭辞を~locate@
するときは、次を走らす：
◎
To locate a namespace prefix for an element using namespace, run these steps:
</p>

<ol>
 <li>
~IF［
%要素 の`~ns$ ~EQ %~ns
］~AND［
%要素 の`~ns接頭辞$ ~NEQ ~NULL
］
⇒
~RET %要素 の`~ns接頭辞$
◎
If element’s namespace is namespace and its namespace prefix is not null, then return its namespace prefix.
</li>
 <li>
~IF［
%要素 は［
`~ns接頭辞$a ~EQ `xmlns^l
］~AND［
`値$a ~EQ %~ns
］なる`属性0$を`有する$
］
⇒
~RET そのような`属性0$のうち，最初のものの`局所名$a
◎
If element has an attribute whose namespace prefix is "xmlns" and value is namespace, then return element’s first such attribute’s local name.
</li>
 <li>
%親 ~SET %要素 の`親~要素$
◎
↓</li>
 <li>
~IF［
%親 ~NEQ ~NULL
］
⇒
~RET %親 に対し %namespace を用いて `~ns接頭辞を~locate$した結果
◎
If element’s parent element is not null, then return the result of running locate a namespace prefix on that element using namespace.
</li>
 <li>
~RET ~NULL
◎
Return null.
</li>


</ol>

<p class="algo-head">
%node に対し， %接頭辞 を用いて
`~nsを~locate@
するときは、次を走らす：
◎
To locate a namespace for a node using prefix switch on node:
</p>

<ol>
 <li>
  <p>
%node の型に応じて：
◎
↑</p>

  <dl class="switch">
   <dt>$Element</dt><dd>
    <ol>
     <li>
~IF［
%node の`~ns$ ~NEQ ~NULL
］~AND［
%node の`~ns接頭辞$ ~EQ %接頭辞
］
⇒
~RET その`~ns$
◎
If its namespace is not null and its namespace prefix is prefix, then return namespace.
</li>

     <li>
<p>
~IF［
%node は、［
%接頭辞 に応じて，次を満たす
］ような`属性0$ %属性0 （一意に~~定まる）を`有する$
］…：
</p>

      <dl class="switch">
       <dt>%接頭辞 ~NEQ ~NULL の場合：</dt>
       <dd>
［
`~ns$a ~EQ `~XMLNS~ns$
］~AND［
`~ns接頭辞$a ~EQ `xmlns^l
］~AND［
`局所名$a ~EQ %接頭辞
］
</dd>
       <dt>%接頭辞 ~EQ ~NULL の場合：</dt>
       <dd>
［
`~ns$a ~EQ `~XMLNS~ns$
］~AND［
`~ns接頭辞$a ~EQ ~NULL
］~AND［
`局所名$a ~EQ `xmlns^l
］
</dd>

      </dl>
<p>
…ならば
⇒
~RET ［
%属性0 の`値$a ~NEQ 空文字列 ならばそれ ／
~ELSE_ ~NULL
］
</p>

◎
If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is "xmlns", and local name is prefix, or if prefix is null and it has an attribute whose namespace is the XMLNS namespace, namespace prefix is null, and local name is "xmlns", then return its value if it is not the empty string, and null otherwise.
</li>

     <li>
<p id="cp-ret-locate-ns">
%要素 ~LET %node の`親~要素$
◎
If its parent element is null, then return null.
◎
Return the result of running locate a namespace on its parent element using prefix.
</p>
     </li>
    </ol>

   </dd>

   <dt>$Document</dt>
   <dd>
%要素 ~LET %node の`文書~要素$
◎
If its document element is null, return null.
◎
Return the result of running locate a namespace on its document element using prefix.
</dd>

   <dt>$DocumentType</dt>
   <dt>$DocumentFragment</dt>
   <dd><!-- cp-ret-null -->
~RET ~NULL
◎
Return null.
</dd>

   <dt>$Attr</dt>
   <dd>
%要素 ~LET %node が`属する要素$
◎
If its element is null, then return null.
◎
Return the result of running locate a namespace on its element using prefix.
</dd>

   <dt>他の~node（`文字~data~node$）◎Any other node</dt>
   <dd><!--cp-ret-locate-ns--></dd>
  </dl>
 </li>

 <li>
~IF［
%要素 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
↑</li>

 <li>
~RET %要素 に対し， %接頭辞 を用いて `~nsを~locate$した結果
◎
↑</li>

</ol>


<dl class="idl-def">
	<dt>@lookupPrefix(namespace)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The lookupPrefix(namespace) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%namespace ~IN { ~NULL, 空文字列 }
］
⇒
~RET ~NULL
◎
If namespace is null or the empty string, return null.
</li>

 <li>
<p>
%要素 ~LET 此れの型に応じて，次で与えられる［
要素, または ~NULL
］：
◎
Switch on the context object:
</p>

   <dl class="switch">

   <dt>$Element</dt>
   <dd>
此れ
◎
Return the result of locating a namespace prefix for the node using namespace.
</dd>

   <dt>$Document</dt>
   <dd>
此れの`文書~要素$
◎
Return the result of locating a namespace prefix for its document element, if its document element is non-null, and null otherwise.
</dd>

   <dt>$DocumentType</dt>
   <dt>$DocumentFragment</dt>
   <dd>
~NULL
◎
Return null.
</dd>

   <dt>$Attr</dt>
   <dd>
此れが`属する要素$
◎
Return the result of locating a namespace prefix for its element, if its element is non-null, and null otherwise.
</dd>

   <dt>他の~node（`文字~data~node$）◎Any other node</dt>
   <dd>
此れの`親~要素$
◎
Return the result of locating a namespace prefix for its parent element, if its parent element is non-null, and null otherwise.
</dd>

  </dl>
 </li>

 <li>
~RET ［
%要素 ~EQ ~NULL ならば ~NULL ／
~ELSE_ %要素 に対し %namespace を用いて `~ns接頭辞を~locate$した結果
］
◎
↑</li>

</ol>
	</dd>

	<dt>@lookupNamespaceURI(prefix)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The lookupNamespaceURI(prefix) method, when invoked, must run these steps: 
</p>

<ol>
 <li>
~IF［
%prefix ~EQ 空文字列
］
⇒
%prefix ~SET ~NULL
◎
If prefix is the empty string, then set it to null.
</li>
 <li>
~RET 此れに対し， %prefix を用いて `~nsを~locate$した結果
◎
Return the result of running locate a namespace for the context object using prefix.
</li>
</ol>
	</dd>

	<dt>@isDefaultNamespace(namespace)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The isDefaultNamespace(namespace) method, when invoked, must run these steps:
</p>

<ol>
 <li id="cp-normalize-ns0">
~IF［
%namespace ~EQ 空文字列
］
⇒
%namespace ~SET ~NULL
◎
If namespace is the empty string, then set it to null.
</li>

<li>
%既定~ns ~LET 此れに対し，~NULL を用いて `~nsを~locate$した結果
◎
Let defaultNamespace be the result of running locate a namespace for context object using null.
</li>

<li>
~RET ［
%既定~ns ~EQ %namespace ならば ~T ／
~ELSE_ ~F
］
◎
Return true if defaultNamespace is the same as namespace, and false otherwise.
</li>

</ol>
	</dd>

	<dt>@insertBefore(node, child)</dt>
	<dd>
被呼出時には、此れの中で， %node を %child の前に`前挿入$した結果を返さ~MUST。
◎
The insertBefore(node, child) method, when invoked, must return the result of pre-inserting node into context object before child.
</dd>
	<dd class="trans-note">【
~HTMLの `br^e のような空~要素であっても（あるいは `script^e 要素であっても）、子~nodeを挿入でき, 木の一部を成すことになる。
次の $appendChild() も同様。
】</dd>

	<dt>@appendChild(node)</dt>
	<dd>
被呼出時には、 %node を此れに`付加-$した結果を返さ~MUST。
◎
The appendChild(node) method, when invoked, must return the result of appending node to context object.
</dd>

	<dt>@replaceChild(node, child)</dt>
	<dd>
被呼出時には、此れの中で %child を %node に`置換-$した結果を返さ~MUST。
◎
The replaceChild(node, child) method, when invoked, must return the result of replacing child with node within context object.
</dd>

	<dt>@removeChild(child)</dt>
	<dd>
被呼出時には、 %child を此れから`前除去-$した結果を返さ~MUST。
◎
The removeChild(child) method, when invoked, must return the result of pre-removing child from context object.
</dd>
</dl>


<p class="algo-head">
`~node$ %根 に対する， %有修飾~名 を
`有修飾~名に持つ要素の~list@
とは、次のようにされた $HTMLCollection である
⇒
`根$cl ~SET %根,<br>
`~filter$ ~SET ［
%根 の`子孫$である`要素$のうち，次で与えられる %条件 に合致する
］ような`~filter$：
◎
The list of elements with qualified name qualifiedName for a node root is the HTMLCollection returned by the following algorithm:
</p>

<!-- ＊
局所名 = * の場合でも、根は除外される
https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
-->

<ol>
 <li>
~IF［
%有修飾~名 ~EQ `*^l (U+002A)
］
⇒
%条件 ~SET なし
◎
If qualifiedName is "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches only descendant elements.
</li>

 <li>
<p>
~ELIF［
%根 の`~node文書$は`~HTML文書$である
］
⇒
%条件 ~SET 次のいずれかを満たす：
◎
Otherwise, if root’s node document is an HTML document, return a HTMLCollection rooted at root, whose filter matches the following descendant elements:
</p>

  <ul>
   <li>
［
`~ns$ ~EQ `~HTML~ns$
］~AND［
`有修飾~名$ ~EQ %有修飾~名 の`~ASCII小文字化$
］
◎
Whose namespace is the HTML namespace and whose qualified name is qualifiedName, converted to ASCII lowercase.
</li>

<li>
［
`~ns$ ~NEQ `~HTML~ns$
］~AND［
`有修飾~名$ ~EQ %有修飾~名
］
◎
Whose namespace is not the HTML namespace and whose qualified name is qualifiedName.
</li>
</ul>

 </li>
 <li>
~ELSE
⇒
%条件 ~SET ［
`有修飾~名$ ~EQ %有修飾~名
］
◎
Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant elements whose qualified name is qualifiedName.
</li>
</ol>

<p>
以前の~callと同じ引数で呼出されたときは、
%根 の`~node文書$の`種別$が変化していない限り，そのときに返したものと同じ $HTMLCollection ~objを返してもよい。
◎
When invoked with the same argument, and as long as root’s node document’s type has not changed, the same HTMLCollection object may be returned as returned by an earlier call.
</p>

<p class="algo-head">
`~node$ %根 に対する，
( %~ns, %局所名 )
を
`( ~ns, 局所名 ) に持つ要素の~list@
とは、次のようにされた $HTMLCollection である
⇒
`根$cl ~SET %根,<br>
`~filter$ ~SET ［
%根 の`子孫$である`要素$のうち，次で与えられる %条件 に合致する
］ような`~filter$：
◎
The list of elements with namespace namespace and local name localName for a node root is the HTMLCollection returned by the following algorithm:
</p>

<ol>
 <!--cp-normalize-ns-->

 <li>
%C ~LET `*^l (U+002A)
◎
↓</li>

 <li>
~IF［
%~ns ~EQ %C
］~AND［
%局所名 ~EQ %C
］
⇒
%条件 ~SET なし
◎
If both namespace and localName are "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches descendant elements.
</li>

 <li>
~ELIF［
%~ns ~EQ %C
］
⇒
%条件 ~SET ［
`局所名$ ~EQ %局所名
］
◎
Otherwise, if namespace is "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches descendant elements whose local name is localName.
</li>

 <li>
~ELIF［
%局所名 ~EQ %C
］
⇒
%条件 ~SET ［
`~ns$ ~EQ %~ns
］
◎
Otherwise, if localName is "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches descendant elements whose namespace is namespace.
</li>

 <li>
~ELSE
⇒
%条件 ~SET ［
`~ns$ ~EQ %~ns
］~AND［
`局所名$ ~EQ %局所名
］
◎
Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant elements whose namespace is namespace and local name is localName.
</li>
</ol>

<p id="cp-may-return-the-same">
以前の~callと同じ引数で呼出されたときは，そのときに返したものと同じ $HTMLCollection ~objを返してもよい。
◎
When invoked with the same arguments, the same HTMLCollection object may be returned as returned by an earlier call.
</p>

<p class="algo-head">
`~node$ %根 に対する，%classNames を
`~classesに含む要素の~list@
とは、次の~algoが返す $HTMLCollection である：
◎
The list of elements with class names classNames for a node root is the HTMLCollection returned by the following algorithm:
</p>

<ol>
 <li>
%~classes ~LET
%classNames を`有順序~集合 解析器$にかけた結果
◎
Let classes be the result of running the ordered set parser on classNames.
</li>

 <li>
~IF［
%~classes は空である
］
⇒
~RET 空の $HTMLCollection
◎
If classes is the empty set, return an empty HTMLCollection.
</li>

 <li>
<p>
~RET 次のようにされた $HTMLCollection `~collection$
⇒
`根$cl ~SET %根,<br>
`~filter$は［
%根 の`子孫$`要素$であって，その`~classes$は %~classes に含まれるすべての~tokenを含むもの
］に合致する
◎
Return a HTMLCollection rooted at root, whose filter matches descendant elements that have all their classes in classes.
</p>

<p>
`~classes$と %~classes の中の各~tokenの比較は、［
%根 の`~node文書$の`~mode$が `quirks^l ならば `~ASCII大小無視$ ／
~ELSE_ `大小区別$
］で行われ~MUST。
◎
The comparisons for the classes must be done in an ASCII case-insensitive manner if root’s node document’s mode is "quirks", and in a case-sensitive manner otherwise.
</p>
 </li>
</ol>

<!--cp-may-return-the-same-->

		</section>
		<section id="interface-document">

<h3>4.5. ~ifc ^@Document</h3>

⇒！
[$Constructor,
 Exposed=Window]
interface @Document : $Node {
  [SameObject] ~RA $DOMImplementation $implementation;
  ~RA USVString $URL;
  ~RA USVString $documentURI;
  ~RA USVString $origin;
  ~RA ~DS $compatMode;
  ~RA ~DS $characterSet;
  ~RA ~DS $charset; // <span class="comment" id="cp-legacy-characterSet" title="historical alias of .characterSet">$characterSet の歴史上の別名</span>
  ~RA ~DS $inputEncoding; // <!--cp-legacy-characterSet-->
  ~RA ~DS $contentType;

  ~RA $DocumentType? $doctype;
  ~RA $Element? $documentElement;
  $HTMLCollection $getElementsByTagName(~DS %qualifiedName);
  $HTMLCollection $getElementsByTagNameNS(~DS? %namespace, ~DS %localName);
  $HTMLCollection $getElementsByClassName(~DS %classNames);

  [NewObject] $Element $createElement(~DS %localName, optional $ElementCreationOptions %options);
  [NewObject] $Element $createElementNS(~DS? %namespace, ~DS %qualifiedName, optional $ElementCreationOptions %options);
  [NewObject] $DocumentFragment $createDocumentFragment();
  [NewObject] $Text $createTextNode(~DS %data);
  [NewObject] $CDATASection $createCDATASection(~DS %data);
  [NewObject] $Comment $createComment(~DS %data);
  [NewObject] $ProcessingInstruction $createProcessingInstruction(~DS %target, ~DS %data);

  [`CEReactions$ NewObject] $Node $importNode($Node %node, optional ~B %deep = false);
  [`CEReactions$] $Node $adoptNode($Node %node);

  [NewObject] $Attr $createAttribute(~DS %localName);
  [NewObject] $Attr $createAttributeNS(~DS? %namespace, ~DS %qualifiedName);

  [NewObject] $Event $createEvent(~DS %interface);

  [NewObject] $Range $createRange();

  // $NodeFilter<!---->.$NodeFilter.SHOW_ALL = 0xFFFFFFFF
  [NewObject] $NodeIterator $createNodeIterator($Node %root, optional ~UL %whatToShow = 0xFFFFFFFF, optional $NodeFilter? %filter = null);
  [NewObject] $TreeWalker $createTreeWalker($Node %root, optional ~UL %whatToShow = 0xFFFFFFFF, optional $NodeFilter? %filter = null);
};

[Exposed=Window]
interface @XMLDocument : $Document {};

dictionary @@ElementCreationOptions {
  DOMString @is;
};
◎

<!-- 
ElementCreationOptions:dictdef-elementcreationoptions
is:#dom-elementcreationoptions-is

 -->
<p>
$@Document `~node$は、単に
`文書@
とも呼ばれている。
◎
Document nodes are simply known as documents.
</p>


<div class="p">
<p>
各 `文書$には、次のものが結付けられる
— 他に定められない限り，括弧内に示される値をとるとする：
</p>

<dl class="def-list">
	<dt>`符号化方式@（ `utf-8$ ）</dt>
	<dd>
<a href="~ENCODING#encoding">符号化方式</a>
</dd>
	<dt>`内容型@（ `application/xml^l ）</dt>
	<dd>
文字列
</dd>
	<dt>`文書URL@（ `about:blank^l ）</dt>
	<dd>
`URL$
</dd>
	<dt>`生成元@（ `不透明な生成元$ ）</dt>
	<dd>
`生成元$x
</dd>
	<dt>`種別@（ `xml^l ）</dt>
	<dd>
次のいずれか
⇒
`xml^l ／ `html^l
</dd>
	<dt>`~mode@（ `no-quirks^l ）</dt>
	<dd>
次のいずれか
⇒
`no-quirks^l ／ `quirks^l ／ `limited-quirks^l
</dd>

</dl>

<p>
`ENCODING$r `URL$r `HTML$r
</p>

◎
Each document has an associated encoding (an encoding), content type (a string), URL (a URL), origin (an origin), type ("xml" or "html"), and mode ("no-quirks", "quirks", or "limited-quirks"). [ENCODING] [URL] [HTML]
◎
Unless stated otherwise, a document’s encoding is the utf-8 encoding, content type is "application/xml", URL is "about:blank", origin is an opaque origin, type is "xml", and its mode is "no-quirks".
</div>


<div class="p">
<p>
`文書$は、その`種別$に応じて：
</p>

<ul><li>`xml^l ならば
`~XML文書@
であるとされ，
</li><li>`html^l ならば
`~HTML文書@
であるとされる。
</li></ul>

<p>
一部の API の挙動は、この 2 種のいずれであるかにより，影響される。
</p>
◎
A document is said to be an XML document if its type is "xml", and an HTML document otherwise. Whether a document is an HTML document or an XML document affects the behavior of certain APIs.
</div>



<div class="p">

<p>
`文書$は、その`~mode$に応じて：
</p>

<ul ><li>
`no-quirks^l ならば
`非過去互換~mode@
下にあるとされ，
</li><li>
`quirks^l ならば
`過去互換~mode@
下にあるとされ，
</li><li>
`limited-quirks^l ならば
`限定的互換~mode@
下にあるとされる。
</li></ul>
◎
A document is said to be in no-quirks mode if its mode is "no-quirks", quirks mode if its mode is "quirks", and limited-quirks mode if its mode is "limited-quirks".
</div>

<p class="note">注記：
~modeが既定の~modeから変更されるのは、`文書$が，新たな`閲覧文脈$（初期の `about:blank^l ）から，［
DOCTYPE 文字列の有無, およびその値
］に基づいて `~HTML解析器$を通して作成される場合に限られる。
`HTML$r
◎
The mode is only ever changed from the default for documents created by the HTML parser based on the presence, absence, or value of the DOCTYPE string, and by a new browsing context (initial "about:blank"). [HTML]
</p>

<p class="note">注記：
`非過去互換~mode$ は 元々 “標準~mode” として知られ，
`限定的互換~mode$ は かつては “ほぼ標準~mode” と呼ばれていた。
それらは今や標準により定義されたので（また、それらの元々の名称が的外れであることから Ian Hickson が否認したので）、改称された。
◎
No-quirks mode was originally known as "standards mode" and limited-quirks mode was once known as "almost standards mode". They have been renamed because their details are now defined by standards. (And because Ian Hickson vetoed their original names on the basis that they are nonsensical.)
</p>

<div class="p">
<p class="algo-head">
所与の~event %~event の下で，`文書$ %文書 の`親~targetを取得-$するときは：
</p>

<ol>
	<li>
~IF［
%~event の $Event.type 属性~値 ~EQ `load^l
］~OR［
%文書 が`属する閲覧文脈$はない
］
⇒
~RET ~NULL
</li>
	<li>
~RET %文書 に<a href="~BROWSERS#concept-document-window">結付けられている ^Window ~obj</a>
］
</li>
</ol>

◎
A document’s get the parent algorithm, given an event, returns null if event’s type attribute value is "load" or document does not have a browsing context, and the document’s associated Window object otherwise.
</div>

<hr>
<dl class="domintro">
 <dt>var %document = new $Document()</dt>
 <dd>
新たな`文書$を返す。
◎
Returns a new document.
</dd>

 <dt>%document . $implementation</dt>
 <dd>
%document の $DOMImplementation ~objを返す。
◎
Returns document’s DOMImplementation object.
</dd>

 <dt>%document . $URL</dt>
 <dt>%document . $documentURI</dt>
 <dd>
%document の`文書URL$ を返す。
◎
Returns document’s URL.
</dd>


 <dt>%document . $origin</dt>
 <dd>
%document の`生成元$を返す。
◎
Returns document’s origin.
</dd>

 <dt>%document . $compatMode</dt>
 <dd>
%document の`~mode$が［
`quirks^l ならば文字列 `BackCompat^l ／
~ELSE_ `CSS1Compat^l
］を返す。
◎
Returns the string "BackCompat" if document’s mode is "quirks", and "CSS1Compat" otherwise.
</dd>

 <dt>%document . $characterSet</dt>
 <dd>
%document の`符号化方式$を返す。
◎
Returns document’s encoding.
</dd>

 <dt>%document . $contentType</dt>
 <dd>
%document の`内容型$を返す。
◎
Returns document’s content type.
</dd>
</dl>





<dl class="idl-def">
	<dt>@Document()</dt>
	<dd>
この構築子の被呼出時には、次のようにされた，新たな`文書$を返さ~MUST
⇒
`生成元$ ~SET `現在の大域~obj$に`結付けられている文書$の`生成元$ `HTML$r
◎
The Document() constructor, when invoked, must return a new document whose origin is the origin of current global object’s associated Document. [HTML]
</dd>

	<dd class="note">注記：
$DOMImplementation.createDocument() と違って、この構築子は
$XMLDocument ~objではなく，`文書$（ $Document ~obj）を返す。
◎
Unlike createDocument(), this constructor does not return an XMLDocument object, but a document (Document object).
</dd>

	<dt>@implementation</dt>
	<dd>
取得子は、此れ（`文書$）に結付けられている
$DOMImplementation ~objを返さ~MUST。
◎
The implementation attribute’s getter must return the DOMImplementation object that is associated with the document.
</dd>

	<dt>@URL</dt>
	<dt>@documentURI</dt>
	<dd>
これらのいずれも，取得子は、此れの`文書URL$を`直列化-$した結果を返さ~MUST。
◎
The URL attribute’s getter and documentURI attribute’s getter must return the URL, serialized.
</dd>

	<dt>@origin</dt>
	<dd>
取得子は、此れの`生成元$を`Unicode に直列化-$した結果を返さ~MUST。
◎
The origin attribute’s getter must return the Unicode serialization of context object’s origin.
</dd>

	<dt>@compatMode</dt>
	<dd>
取得子は、［
此れの`~mode$ ~EQ `quirks^l ならば `BackCompat^l ／
~ELSE_ `CSS1Compat^l
］を返さ~MUST。
◎
The compatMode attribute’s getter must return "BackCompat" if context object’s mode is "quirks", and "CSS1Compat" otherwise.
</dd>

	<dt>@characterSet</dt>
	<dt>@charset</dt>
	<dt>@inputEncoding</dt>
	<dd>
これらのいずれも，取得子は、此れの`符号化方式$の
<a href="~ENCODING#name">名前</a>
を返さ~MUST。
◎
The characterSet attribute’s getter, charset attribute’s getter, and inputEncoding attribute’s getter, must return context object’s encoding’s name.
</dd>

	<dt>@contentType</dt>
	<dd>
取得子は、此れの`内容型$を返さ~MUST。
◎
The contentType attribute’s getter must return the content type.
</dd>
</dl>


<dl class="domintro">
 <dt>%document . $doctype</dt>
 <dd>
`文書型$が［
在ればそれ ／
無ければ~NULL
］を返す。
◎
Returns the doctype or null if there is none.
</dd>

 <dt>%document . $documentElement</dt>
 <dd>
`文書~要素$を返す。
◎
Returns the document element.
</dd>

 <dt>%collection = %document . $getElementsByTagName(qualifiedName)</dt>
 <dd>
%qualifiedName が `*^l の場合、`子孫$`要素$すべてからなる $HTMLCollection を返す。
◎
If qualifiedName is "*" returns a HTMLCollection of all descendant elements.
</dd>
 <dd>
他の場合、［
`有修飾~名$が %qualifiedName なる `子孫$`要素$
］すべてからなる $HTMLCollection を返す（ `~HTML文書$ 内の`~HTML~ns$に属する`要素$に対しては，大小無視の合致による）。
◎
Otherwise, returns a HTMLCollection of all descendant elements whose qualified name is qualifiedName. (Matches case-insensitively against elements in the HTML namespace within an HTML document.)
</dd>

 <dt>%collection = %document . $getElementsByTagNameNS(namespace, localName)</dt>
 <dd>
%namespace, %localName のいずれも `*^l の場合は、`子孫$`要素$すべてからなる $HTMLCollection を返す。
◎
If namespace and localName are "*" returns a HTMLCollection of all descendant elements.
</dd>
 <dd>
%namespace のみが `*^l の場合は、［
`局所名$が %localName なる `子孫$`要素$
］すべてからなる $HTMLCollection を返す。
◎
If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.
</dd>
 <dd>
%localName のみが `*^l の場合は、［
`~ns$が %namespace なる `子孫$`要素$
］すべてからなる $HTMLCollection を返す。
◎
If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.
</dd>
 <dd>
他の場合は、［
`~ns$が %namespace, かつ `局所名$が %localName なる
`子孫$`要素$
］すべてからなる $HTMLCollection を返す。
◎
Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
</dd>

 <dt>%collection = %document . $getElementsByClassName(classNames)</dt>
 <dt>%collection = %element . $Element.getElementsByClassName(classNames)</dt>
 <dd>
~methが呼出された~obj（`文書$または`要素$）内の`要素$のうち，［
%classNames で与えられる一連の~class名をすべて持つもの
］からなる $HTMLCollection を返す。
%classNames 引数は一連の~class名の~space区切り~listとして解釈される。
◎
Returns a HTMLCollection of the elements in the object on which the method was invoked (a document or an element) that have all the classes given by classNames. The classNames argument is interpreted as a space-separated list of classes.
</dd>

</dl>


<dl class="idl-def">
	<dt>@doctype</dt>
	<dd>
取得子は、［
此れの`子$である
］~AND［
`文書型$である
］ような~nodeのうち，`最初0$のものを返さ~MUST。
◎
The doctype attribute’s getter must return the child of the document that is a doctype, and null otherwise.
</dd>

	<dt>@documentElement</dt>
	<dd>
取得子は、此れの`文書~要素$を返さ~MUST。
◎
The documentElement attribute’s getter must return the document element.
</dd>

	<dt>@getElementsByTagName(qualifiedName)</dt>
	<dd>
被呼出時には、此れに対する， %qualifiedName を`有修飾~名に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagName(qualifiedName) method, when invoked, must return the list of elements with qualified name qualifiedName for the context object.
</dd>
	<dd class="note">注記：
したがって，`~HTML文書$においては、
`document.getElementsByTagName("FOO")^c は
`~HTML~ns$に属さない `FOO^e 要素と
`~HTML~ns$に属する `foo^e 要素に合致し，
`~HTML~ns$に属する `FOO^e 要素には合致しないことになる。
◎
Thus, in an HTML document, document.getElementsByTagName("FOO") will match &lt;FOO&gt; elements that are not in the HTML namespace, and &lt;foo&gt; elements that are in the HTML namespace, but not &lt;FOO&gt; elements that are in the HTML namespace.
</dd>

	<dt>@getElementsByTagNameNS(namespace, localName)</dt>
	<dd>
被呼出時には、此れに対する，
( %namespace, %localName ) を
`( ~ns, 局所名 ) に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagNameNS(namespace, localName) method, when invoked, must return the list of elements with namespace namespace and local name localName for the context object.
</dd>

	<dt>@getElementsByClassName(classNames)</dt>
	<dd>
被呼出時には、此れに対する，%classNames を`~classesに含む要素の~list$を返さ~MUST。
◎
The getElementsByClassName(classNames) method, when invoked, must return the list of elements with class names classNames for the context object.
	</dd>
	<dd class="example">
<p>
次の XHTML 片が与えられたとする：
◎
Given the following XHTML fragment:
</p>

<pre class="html-code">
&lt;div id="example"&gt;
  &lt;p id="<mark>p1</mark>" class="aaa bbb"/&gt;
  &lt;p id="<mark>p2</mark>" class="aaa ccc"/&gt;
  &lt;p id="<mark>p3</mark>" class="bbb ccc"/&gt;
&lt;/div&gt;
</pre>

<p>
<samp>document.getElementById(`example^l).getElementsByClassName(`aaa^l)</samp>
の~callは、その中の 2 個の paragraph 
<mark>p1</mark> と <mark>p2</mark> からなる
$HTMLCollection を返すことになる。
◎
A call to document.getElementById("example").getElementsByClassName("aaa") would return a HTMLCollection with the two paragraphs p1 and p2 in it.
</p>

<p>
一方で，
<samp>getElementsByClassName(`ccc&nbsp;bbb^l)</samp>
の~callは
その中の 1 個の~node <mark>p3</mark> のみを返すことになる。
<samp>document.getElementById(`example^l).getElementsByClassName(`bbb&nbsp;&nbsp;&nbsp;ccc&nbsp;^l)</samp>
の~callも同じものを返すことになる。
◎
A call to getElementsByClassName("ccc bbb") would only return one node, however, namely p3. A call to document.getElementById("example").getElementsByClassName("bbb ccc ") would return the same thing.
</p>

<p>
<samp>getElementsByClassName(`aaa,bbb^l)</samp>
の~callは 1 個の~nodeも返さない。
上のどの要素も `aaa,bbb^c ~classに属さない。
◎
A call to getElementsByClassName("aaa,bbb") would return no nodes; none of the elements above are in the aaa,bbb class.
</p>
	</dd>
</dl>


<dl class="domintro">
 <dt>%element = %document . $createElement(localName [, options])</dt>
 <dd>
`局所名$が %localName であるような，`要素$を返す（ %document が`~HTML文書$である場合， %localName は小文字化される）。
`要素$の`~ns$は，［［
%document が`~HTML文書$である
］または［
%document の`内容型$ ~EQ `application/xhtml+xml^l
］ならば `~HTML~ns$ ／
他の場合は ~NULL
］になる。
◎
Returns an element with localName as local name (if document is an HTML document, localName gets lowercased). The element’s namespace is the HTML namespace when document is an HTML document or document’s content type is "application/xhtml+xml", and null otherwise.
</dd>
 <dd>
%localName が `Name$prod 生成規則に合致しない場合は
`InvalidCharacterError^E 例外が投出される。
◎
If localName does not match the Name production an InvalidCharacterError will be thrown.
</dd>
 <dd id="cp-supplied-is-mb">
%options の $ElementCreationOptions.is ~memberを利用して，`~custom化された組込みの要素$を作成できる。
◎
When supplied, options’ is member can be used to create a customized built-in element.
</dd>

 <dt>%element = %document . $createElementNS(namespace, qualifiedName [, options])</dt>
 <dd>
`~ns$ %namespace に属するような，新たな`要素$を返す。
その［
`~ns接頭辞$, `局所名$
］は、順に，［
%qualifiedName が `:^l (U+003A) を含む
］ならば，それを挟んだ［
前, 後
］の部分，他の場合は［
~NULL, %qualifiedName
］にされる。
◎
Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
</dd>
 <dd>
%qualifiedName が `Name$prod 生成規則に合致しない場合は
`InvalidCharacterError^E 例外が投出される。
◎
If localName does not match the Name production an InvalidCharacterError will be thrown.
</dd>

<!-- *localName -->
 <dd>

<p>
次のいずれかを条件を満たす場合，
`NamespaceError^E 例外が投出される：
◎
If one of the following conditions is true a NamespaceError will be thrown:
</p>

  <ul>
   <li>
%localName は `QName$prod 生成規則に合致しない。
◎
localName does not match the QName production.
</li>

   <li>
%namespace は空文字列であるのに，`~ns接頭辞$は~NULL でない。
◎
Namespace prefix is not null and namespace is the empty string.
</li>

   <li>
%namespace は`~XML~ns$でないのに，`~ns接頭辞$は `xml^l である。
◎
Namespace prefix is "xml" and namespace is not the XML namespace.
</li>

   <li>
%namespace は`~XMLNS~ns$でないのに，
%qualifiedName または`~ns接頭辞$は `xmlns^l である。
◎
qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
</li>

   <li>
%namespace は`~XMLNS~ns$であるのに，
%qualifiedName も`~ns接頭辞$も `xmlns^l でない。
◎
namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
</li>
</ul>
 </dd>
 <!--cp-supplied-is-mb-->

 <dt>%documentFragment = %document . $createDocumentFragment()</dt>
 <dd>
$DocumentFragment `~node$を返す。
◎
Returns a DocumentFragment node.
</dd>

 <dt>%text = %document . $createTextNode(data)</dt>
 <dd>
`~data$が %data にされた，新たな $Text `~node$を返す。
◎
Returns a Text node whose data is data.
</dd>

 <dt>%text = %document . $createCDATASection(data)</dt>
 <dd>
`~data$が %data にされた，新たな $CDATASection `~node$を返す。
◎
Returns a CDATASection node whose data is data.
</dd>

 <dt>%comment = %document . $createComment(data)</dt>
 <dd>
`~data$が %data にされた，新たな $Comment `~node$を返す。
◎
Returns a Comment node whose data is data.
</dd>


 <dt>%processingInstruction = %document . $createProcessingInstruction(target, data)</dt>
 <dd>
<p>
$target が %target にされ, `~data$が %data にされた，新たな $ProcessingInstruction `~node$を返す。
次の場合は `InvalidCharacterError^E 例外が投出される：
</p>

  <ul>
   <li>
%target が `Name$prod 生成規則に合致しない場合。
</li>
   <li>
%data が `?&gt;^l を含んでいる場合。
</li>
  </ul>

◎
Returns a ProcessingInstruction node whose target is target and data is data. If target does not match the Name production an InvalidCharacterError will be thrown. If data contains "?&gt;" an InvalidCharacterError will be thrown.
 </dd>
</dl>

<p>
他が定められない限り，所与の
( 局所名, ~ns )
に
`対応する要素~ifc@
は、 $Element とする。
◎
The element interface for any name and namespace is Element, unless stated otherwise.
</p>

<p class="note">注記：
例えば，~HTML標準は、
( `html$e, `~HTML~ns$ )
に対応するそれを，
$HTMLHtmlElement ~ifcと定義している。
`HTML$r
◎
The HTML Standard will e.g. define that for html and the HTML namespace, the HTMLHtmlElement interface is used. [HTML] 
</p>


<dl class="idl-def">
	<dt>@createElement(localName, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createElement(localName, options) method, when invoked, must run these steps:
</p>


<ol>
 <li>
~IF［
%localName は `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError^E
◎
If localName does not match the Name production, then throw an InvalidCharacterError.
</li>
 <li>
~IF［
此れは`~HTML文書$ である
］
⇒
%localName ~SET %localName の`~ASCII小文字化$
◎
If the context object is an HTML document, let localName be converted to ASCII lowercase.
</li>
 <li id="cp-let-is">
%is ~LET 
%options に $ElementCreationOptions.is ~memberが［
在するならば その値 ／
不在ならば ~NULL
］
◎
Let is be the value of is member of options, or null if no such member exists.
</li>
 <li>
%定義 ~LET
( 此れ, `~HTML~ns$, %localName, %is )
を与える下で，`~custom要素~定義を検索-$した結果
◎
Let definition be the result of looking up a custom element definition, given the context object, the HTML namespace, localName, and is.
</li>
 <li id="cp-def-is-null">
~IF［
%is ~NEQ ~NULL
］~AND［
%定義 ~EQ ~NULL
］
⇒
~THROW `NotFoundError^E
◎
If is is non-null and definition is null, then throw a NotFoundError.
</li>
 <li>
%~ns ~LET ［［
此れは`~HTML文書$である
］~OR［
此れの`内容型$ ~EQ `application/xhtml+xml^l
］ならば `~HTML~ns$ ／
~ELSE_ ~NULL
］
◎
Let namespace be the HTML namespace, if the context object is an HTML document or context object’s content type is "application/xhtml+xml", and null otherwise.
</li>
 <li>
%要素 ~LET
`新たな要素$( 此れ, %localName, %~ns, ~NULL, %is, ~ON )
（例外投出あり）
◎
Let element be the result of creating an element given the context object, localName, namespace, null, is, and with the synchronous custom elements flag set. Rethrow any exceptions.
</li>
 <li id="cp-set-is">
~IF［
%is ~NEQ ~NULL
］
⇒
( `is^l, %is )
を用いて， %要素 の`属性0値を設定-$する
◎
If is is non-null, then set an attribute value for element using "is" and is.
</li>
 <li id="cp-ret-element">
~RET %要素
◎
Return element.
</li>
</ol>

	</dd>
</dl>

<p class="algo-head">
`内的 createElementNS 手続き@
は、所与の
( %文書, %namespace, %qualifiedName, %options )
に対し，次を走らす：
◎
The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as follows:
</p>

<ol>
 <li id="cp-validate-and-extract">
( %~ns, %接頭辞, %局所名 ) ~LET
( %namespace, %qualifiedName ) に対し`検証して抽出-$した結果
（例外投出あり）
◎
Let namespace, prefix, and localName be the result of passing namespace and qualifiedName to validate and extract. Rethrow any exceptions.
</li>
 <!--cp-let-is-->
 <li>
%定義 ~LET
( %文書, %~ns, %局所名, %is )
を与える下で，`~custom要素~定義を検索-$した結果
◎
Let definition be the result of looking up a custom element definition, given the context object, namespace, localName, and is.
</li>
 <!--cp-def-is-null-->
 <li>
%要素 ~LET
`新たな要素$( %文書, %局所名, %~ns, %接頭辞, %is, ~ON )
（例外投出あり）
◎
Let element be the result of creating an element given document, localName, namespace, prefix, is, and with the synchronous custom elements flag set. Rethrow any exceptions.
</li>
 <!--cp-set-is-->
 <!--cp-ret-element-->
</ol>

<dl class="idl-def">
	<dt>@createElementNS(namespace, qualifiedName, options)</dt>
	<dd>
被呼出時には、
( 此れ, %namespace, %qualifiedName, %options )
を与える下で，
`内的 createElementNS 手続き$を走らせた結果を返さ~MUST。
◎
The createElementNS(namespace, qualifiedName, options) method, when invoked, must return the result of running the internal createElementNS steps, given context object, namespace, qualifiedName, and options.
</dd>

	<dt>@createDocumentFragment()</dt>
	<dd>
被呼出時には、次のように設定された 新たな`文書片$を返さ~MUST
⇒
`~node文書$ ~SET 此れ
◎
The createDocumentFragment() method, when invoked, must return a new DocumentFragment node with its node document set to the context object.
</dd>

	<dt>@createTextNode(data)</dt>
	<dd>
被呼出時には、
`新たな~text~node$( %data, 此れ )
を返さ~MUST
◎
The createTextNode(data) method, when invoked, must return a new Text node with its data set to data and node document set to the context object.
</dd>
	<dd class="note">注記：
%data が `Char$prod 生成規則に合致する文字のみからなるかどうかは、検査されない。
◎
No check is performed that data consists of characters that match the Char production.
</dd>

	<dt>@createCDATASection(data)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createCDATASection(data) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
此れは`~HTML文書$である
］
⇒
~THROW `NotSupportedError^E
◎
If context object is an HTML document, then throw a NotSupportedError.
</li>
 <li>
~IF［
%data は文字列 `]]&gt;^l を包含する
］
⇒
~THROW `InvalidCharacterError^E
◎
If data contains the string "]]&gt;", then throw an InvalidCharacterError.
</li>
 <li>
~RET 次のようにされた，新たな $CDATASection `~node$
⇒
( `~data$, `~node文書$ ) ~SET ( %data, 此れ )
◎
Return a new CDATASection node with its data set to data and node document set to the context object.
</li>
</ol>

	</dd>

	<dt>@createComment(data)</dt>
	<dd>
被呼出時には、次のように設定された 新たな $Comment `~node$を返さ~MUST
⇒
`~data$ ~SET %data,<br>
`~node文書$ ~SET 此れ
◎
The createComment(data) method, when invoked, must return a new Comment node with its data set to data and node document set to the context object.
	</dd>
	<dd class="note">注記：
%data が
`Char$prod 生成規則に合致する文字からなるかどうかや,
連続する 2 個の~hyphen（ "--" ）を含むかどうか,
~hyphenで終わるかどうかは、検査されない。
◎
No check is performed that data consists of characters that match the Char production or that it contains two adjacent hyphens or ends with a hyphen.
</dd>

	<dt>@createProcessingInstruction(target, data)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createProcessingInstruction(target, data) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%target は
 <!--<code data-anolis-spec=xml>PITarget</code>-->
`Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError^E
<!-- DOM3 does not check for "xml" -->
◎
If target does not match the Name production, then throw an InvalidCharacterError.
</li>

 <li>
~IF［
%data は文字列 `?&gt;^l を含む
］
⇒
~THROW `InvalidCharacterError^E
 <!-- Gecko does this. -->
◎
If data contains the string "?&gt;", then throw an InvalidCharacterError.
</li>

 <!--<li>
<p>If <var title>target</var> contains a U+003A COLON (":")
 character, <span data-anolis-spec=webidl>throw</span> a
 <code title>NamespaceError</code> exception.-->
 <!-- DOM3 didn’t check this -->
 <li>
~RET 
次のように設定された 新たな $ProcessingInstruction `~node$
⇒
$ProcessingInstruction.target ~SET %target ,<br>
`~data$ ~SET %data ,<br>
`~node文書$ ~SET 此れ
◎
Return a new ProcessingInstruction node, with target set to target, data set to data, and node document set to the context object.
</li>
</ol>

	</dd>
	<dd class="note">注記：
%target が `xml^l または `:^l を含むかどうか,
あるいは %data が `Char$prod 生成規則に合致する文字を含むかどうかは，検査されない。
◎
No check is performed that target contains "xml" or ":", or that data contains characters that match the Char production.
</dd>

</dl>


<dl class="domintro">
 <dt>%clone = %document . $importNode(node [, deep = false])</dt>
 <dd>
%node の複製を返す。
%deep が~T の場合、複製には %node の`子孫$も含められる。
◎
Returns a copy of node. If deep is true, the copy also includes the node’s descendants.
</dd>
 <dd>
%node が`文書$または`~shadow根$である場合，
`NotSupportedError^E 例外が投出される。
◎
If node is a document or a shadow root, throws a NotSupportedError.
</dd>

 <dt>%node = %document . $adoptNode(node)</dt>
 <dd>
%node を他の`文書$から移動させた上で，それを返す。
◎
Moves node from another document and returns it.
</dd>
 <dd>
%node が`文書$である場合，
`NotSupportedError^E 例外が投出される。
%node が`~shadow根$である場合，
`HierarchyRequestError^E 例外が投出される。
◎
If node is a document, throws a NotSupportedError or, if node is a shadow root, throws a HierarchyRequestError.
</dd>
</dl>

<dl class="idl-def">
	<dt>@importNode(node, deep)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The importNode(node, deep) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%node は `文書$または`~shadow根$である
］
⇒
~THROW `NotSupportedError^E
◎
If node is a document or shadow root, then throw a NotSupportedError.
</li>

 <li>
~RET［
( `文書^i： 此れ, `~clone子孫^f：［
%deep ~EQ ~T ならば ~ON ／
~ELSE_ ~OFF
］ )
を与える下で，
%node を`~clone$した結果
◎
Return a clone of node, with context object and the clone children flag set if deep is true.
</li>
</ol>

	</dd>
</dl>

<p>
`適用仕様$は、一部またはすべての`~node$に対し，
`受入-時の手続き@
を定義してよい。
~algoの引数には，`受入-$ ~algoに指示される
%node と %旧-文書 が渡される。
◎
Specifications may define adopting steps for all or some nodes. The algorithm is passed node and oldDocument, as indicated in the adopt algorithm.
</p>

<p class="algo-head">
%node を %文書 に`受入-@するときは、次を走らす：
◎
To adopt a node into a document, run these steps:
</p>

<ol>
 <li>
%旧-文書 ~LET %node の`~node文書$
◎
Let oldDocument be node’s node document.
</li>

 <li>
~IF［
%node の`親$ ~NEQ ~NULL
］
⇒
%node を %node の`親$から`除去-$する
◎
If node’s parent is not null, remove node from its parent.
</li>

 <li>
<p>
~IF［
%文書 ~NEQ %旧-文書
］：
◎
If document is not the same as oldDocument, run these substeps:
</p>
  <ol>
   <li>
<p>
~FOR
%node の ~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants, run these subsubsteps:
</p>
    <ol>
     <li>
%広義子孫 の`~node文書$ ~SET %文書
◎
Set inclusiveDescendant’s node document to document.
</li>
     <li>
~IF［
%広義子孫 は`要素$である
］
⇒
%広義子孫 の`属性0~list$内の ~EACH ( %属性0 ) に対し
⇒
%属性0 の`~node文書$ ~SET %文書
◎
If inclusiveDescendant is an element, then set the node document of each attribute in inclusiveDescendant’s attribute list to document.
</li>
    </ol>
   </li>
   <li>
~FOR
%node の ~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し
⇒
~IF［
%広義子孫 は`~custom$である
］
⇒
次を与える下で，`~custom要素~callback反応を待入れる$
⇒
%広義子孫,<br>
~callback名： `adoptedCallback^l,<br>
引数~list： ( %旧-文書, %文書 )
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants that is a custom element, enqueue a custom element callback reaction with inclusiveDescendant, callback name "adoptedCallback", and an argument list containing oldDocument and document.
</li>
   <li>
~FOR
%node の ~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し，`~shadowも含む木~順序$で
⇒
( %広義子孫, %旧-文書 )
を与える下で，`受入-時の手続き$を走らす
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants, in shadow-including tree order, run the adopting steps with inclusiveDescendant and oldDocument.
</li>
  </ol>
 </li>
</ol>

<dl class="idl-def">
	<dt>@adoptNode(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The adoptNode(node) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%node は`文書$である
］
⇒
~THROW `NotSupportedError^E
◎
If node is a document, then throw a NotSupportedError.
</li>

 <li>
~IF［
%node は`~shadow根$である
］
⇒
~THROW `HierarchyRequestError^E
◎
If node is a shadow root, then throw a HierarchyRequestError.
</li>

 <li>
%node を此れに`受入-$する
◎
Adopt node into the context object.
</li>

 <li>
~RET %node
◎
Return node.
</li>
</ol>

	</dd>

	<dt>@createAttribute(localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createAttribute(localName) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%localName は~XMLの `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError^E
◎
If localName does not match the Name production in XML, then throw an InvalidCharacterError.
</li>

 <li>
~IF［
此れは`~HTML文書$である
］
⇒
%localName ~SET %localName を `~ASCII小文字化$した結果
◎
If the context object is an HTML document, let localName be converted to ASCII lowercase.
</li>

 <li>
~RET 次のように設定された 新たな`属性0$
⇒
`局所名$a ~SET %localName,<br>
`~node文書$ ~SET 此れ
◎
Return a new attribute whose local name is localName and node document is context object.
</li>
</ol>
	</dd>

	<dt>@createAttributeNS(namespace, qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createAttributeNS(namespace, qualifiedName) method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-validate-and-extract-->

 <li>
<p>
~RET 次のように設定された 新たな`属性0$：
</p>

<ul><li>`~ns$a ~SET %~ns
</li><li>`~ns接頭辞$a ~SET %接頭辞
</li><li>`局所名$a ~SET %局所名
</li><li>`~node文書$ ~SET 此れ
</li></ul>

◎
Return a new attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, and node document is context object.
</li>
</ol>

	</dd>

	<dt>@createEvent(interface)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createEvent(interface) method, when invoked, must run these steps:
</p>

<ol>

 <li>
%構築子 ~LET ~NULL
◎
Let constructor be null.
</li>

 <li>
<p>
~IF［
%interface は［
下の表のいずれかの行の 1 列目の文字列
］に `~ASCII大小無視$で合致する
］
⇒
%構築子 ~SET ［
合致した行の 2 列目の~ifc
］の構築子
◎
If interface is an ASCII case-insensitive match for any of the strings in the first column in the following table, then set constructor to the interface in the second column on the same row as the matching string:
</p>

<table><thead><tr><th>文字列◎String
</th><th>~ifc◎Interface
</th><th>仕様（空欄はこの仕様）◎Notes
</th></tr></thead>


<tbody><tr><td>`animationevent^l
</td><td>$AnimationEvent
</td><td>`CSS3-ANIMATIONS$r

</td></tr><tr><td>`beforeunloadevent^l
</td><td>$BeforeUnloadEvent
</td><td>`HTML$r

</td></tr><tr><td>`closeevent^l
</td><td>$CloseEvent
</td><td>同上

</td></tr><tr><td>`compositionevent^l
</td><td>$CompositionEvent
</td><td>`UIEVENTS$r

</td></tr><tr><td>`customevent^l
</td><td>$CustomEvent
</td><td>

</td></tr><tr><td>`devicemotionevent^l
</td><td>^DeviceMotionEvent
</td><td>`DEVICE-ORIENTATION$r

</td></tr><tr><td>`deviceorientationevent^l
</td><td>^DeviceOrientationEvent
</td><td>同上

</td></tr><tr><td>`dragevent^l
</td><td>$DragEvent
</td><td>`HTML$r

</td></tr><tr><td>`errorevent^l
</td><td>$ErrorEvent
</td><td>同上

</td></tr><tr><td>`event^l
</td><td>$Event
</td><td>

</td></tr><tr><td>`events^l
</td><td>同上
</td><td>

</td></tr><tr><td>`focusevent^l
</td><td>$FocusEvent
</td><td>`UIEVENTS$r

</td></tr><tr><td>`hashchangeevent^l
</td><td>$HashChangeEvent
</td><td>`HTML$r

</td></tr><tr><td>`htmlevents^l
</td><td>$Event
</td><td>

</td></tr><tr><td>`idbversionchangeevent^l
</td><td>$IDBVersionChangeEvent
</td><td>`INDEXEDDB$r

</td></tr><tr><td>`keyboardevent^l
</td><td>$KeyboardEvent
</td><td>`UIEVENTS$r

</td></tr><tr><td>`messageevent^l
</td><td>$MessageEvent
</td><td>`HTML$r

</td></tr><tr><td>`mouseevent^l
</td><td>$MouseEvent
</td><td>`UIEVENTS$r

</td></tr><tr><td>`mouseevents^l
</td><td>同上
</td><td>同上

</td></tr><tr><td>`pagetransitionevent^l
</td><td>$PageTransitionEvent
</td><td>`HTML$r

</td></tr><tr><td>`popstateevent^l
</td><td>$PopStateEvent
</td><td>同上

</td></tr><tr><td>`progressevent^l
</td><td>$ProgressEvent
</td><td>`XHR$r

</td></tr><tr><td>`storageevent^l
</td><td>$StorageEvent
</td><td>`HTML$r

</td></tr><tr><td>`svgevents^l
</td><td>$Event
</td><td>

</td></tr><tr><td>`svgzoomevent^l
</td><td>$SVGZoomEvent
</td><td>`SVG$r

</td></tr><tr><td>`svgzoomevents^l
</td><td>同上
</td><td>同上

</td></tr><tr><td>`textevent^l
</td><td>$CompositionEvent
</td><td>`UIEVENTS$r

</td></tr><tr><td>`touchevent^l
</td><td>$TouchEvent
</td><td>`TOUCH-EVENTS$r

</td></tr><tr><td>`trackevent^l
</td><td>$TrackEvent
</td><td>`HTML$r

</td></tr><tr><td>`transitionevent^l
</td><td>$TransitionEvent
</td><td>`CSS3-TRANSITIONS$r

</td></tr><tr><td>`uievent^l
</td><td>$UIEvent
</td><td>`UIEVENTS$r

</td></tr><tr><td>`uievents^l
</td><td>同上
</td><td>同上

</td></tr><tr><td>`webglcontextevent^l
</td><td>^WebGLContextEvent
</td><td>`WEBGL$r

</td></tr><tr><td>`wheelevent^l
</td><td>$WheelEvent
</td><td>`UIEVENTS$r

</td></tr></tbody></table>

 </li>

 <li>
~IF［
%構築子 ~EQ ~NULL
］
⇒
~THROW `NotSupportedError^E
◎
If constructor is null, then throw a NotSupportedError.
</li>
 <li>
<p>
~IF［
%構築子 の初期値 ~EQ undefined
］
⇒
~THROW `NotSupportedError^E
◎
If the initial value of constructor is undefined, then throw a NotSupportedError.
</p>

<p>
概して~UAは、環境設定によっては，~touch~eventの~supportを不能化する
— その場合、 $TouchEvent の初期値は undefined になる。
◎
Typically user agents disable support for touch events in some configurations, in which case the initial value of TouchEvent is undefined.
</p>
 </li>

 <li>
%~event ~LET
( 空文字列 ) を引数に，%構築子 の初期値を
<a href="#concept-event-constructor">呼び出した</a>結果
◎
Let event be the result of invoking the initial value of constructor with the empty string as argument.
</li>

 <li>
%~event の`初期化済み$f ~SET ~OFF
◎
Unset event’s initialized flag.
</li>

 <li>
~RET %~event
◎
Return event.
</li>
</ol>

	</dd>
	<dd class="note">注記：
代わりに，`~event$構築子が利用されるべきである。
◎
Event constructors ought to be used instead.
</dd>

	<dt>@createRange()</dt>
	<dd>
被呼出時には、次のように設定された 新たな`範囲0$を返さ~MUST
⇒
`始点$ ~SET (此れ, 0) ,<br>
`終点$ ~SET (此れ, 0)
◎
The createRange() method, when invoked, must return a new range with (context object, 0) as its start and end.
	</dd>
	<dd class="note">注記：
代わりに， $Range.Range() 構築子が利用されるべきである。
◎
The Range() constructor ought to be used instead.
</dd>

	<dt>@createNodeIterator(root, whatToShow, filter)</dt>
	<dd>
<p>
被呼出時には、次のように設定された 新たな $NodeIterator ~objを返さ~MUST：
◎
The createNodeIterator(root, whatToShow, filter) method, when invoked, must run these steps:
</p>

<ul>
 <li>
`根~node$ ~SET %root
◎
Create a NodeIterator object.
◎
Set root to root and initialize the referenceNode attribute to root.
</li>

 <li>
$NodeIterator.referenceNode 属性 ~SET %root に初期化-
◎
↑</li>

 <li>
$NodeIterator.pointerBeforeReferenceNode 属性 ~SET ~T に初期化-
◎
Initialize the pointerBeforeReferenceNode attribute to true.
</li>

 <li id="cp-set-whatToShow">
`whatToShow ~bitmask$ ~SET %whatToShow
◎
Set whatToShow to whatToShow.
</li>

 <li>
`~filter~callback$ ~SET %filter
◎
Set filter to filter.
◎
Return the newly created NodeIterator object.
</li>

</ul>
	</dd>

	<dt>@createTreeWalker(root, whatToShow, filter)</dt>
	<dd>
<p>
被呼出時には、次のように設定された 新たな $TreeWalker ~objを返さ~MUST：
◎
The createTreeWalker(root, whatToShow, filter) method, when invoked, must run these steps:
</p>

<ul>
 <li>
`根~node$ ~SET %root
◎
Create a TreeWalker object.
◎
Set root to root and initialize the currentNode attribute to root.
</li>

 <li>
$TreeWalker.currentNode 属性 ~SET %root に初期化-
◎
↑</li>

 <!--cp-set-whatToShow-->
 <li>
`~filter~callback$ ~SET %filter
◎
Set filter to filter.
◎
Return the newly created TreeWalker object.
</li>

</ul>

	</dd>
</dl>
			<section id="interface-domimplementation">

<h4>4.5.1. ~ifc ^@DOMImplementation</h4>

<p>
~UA は、`文書$が作成された際には，
$DOMImplementation ~objを作成して, `文書$にそれを結付け~MUST。
◎
User agents must create a DOMImplementation object whenever a document is created and associate it with that document.
</p>

⇒！
[Exposed=Window]
interface @DOMImplementation {
  [NewObject] $DocumentType $createDocumentType(~DS qualifiedName, ~DS publicId, ~DS systemId);
  [NewObject] $XMLDocument $createDocument(~DS? %namespace, [TreatNullAs=EmptyString] ~DS %qualifiedName, optional $DocumentType? %doctype = null);
  [NewObject] $Document $createHTMLDocument(optional ~DS title);

  ~B $hasFeature(); // <span class="comment" id="cp-useless-true" title="useless; always returns true">無用の長物 — 常に true を返す</span>
};
◎

<dl class="domintro">
 <dt>%doctype = %document . $Document.implementation . $createDocumentType( qualifiedName, publicId, systemId )</dt>
 <dd>
所与の［
%qualifiedName, %publicId, %systemId
］を伴う`文書型$を返す。
%qualifiedName が
`Name$prod 生成規則に合致しない場合は
`InvalidCharacterError^E 例外が投出され,
`QName$prod 生成規則に合致しない場合は
`NamespaceError^E 例外が投出される。
◎
Returns a doctype, with the given qualifiedName, publicId, and systemId. If qualifiedName does not match the Name production, an InvalidCharacterError is thrown, and if it does not match the QName production, a NamespaceError is thrown.
</dd>

 <dt>%doc = %document . $Document.implementation . $createDocument( namespace, qualifiedName [, doctype = null] )</dt>
 <dd>
`局所名$が %qualifiedName で`~ns$が %namespace （ %qualifiedName が空文字列でなければ）の`文書~要素$を伴い，
%doctype が与えられていれば`文書型$がそれに設定された
$XMLDocument を返す。
◎
Returns an XMLDocument, with a document element whose local name is qualifiedName and whose namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is given, as its doctype.
</dd>
 <dd>
この~methは、$Document.createElementNS() ~methと同じ例外を，
( %namespace, %qualifiedName )
で呼出したときに投出する。
◎
This method throws the same exceptions as the createElementNS() method, when invoked with namespace and qualifiedName.
</dd>

 <dt>%doc = %document . $Document.implementation . $createHTMLDocument([title])</dt>
 <dd>
基本~構造が構築-済みの`木$を伴う`文書$を返す。
%title 引数が省略されていなければ `title$e 要素も含められる。
◎
Returns a document, with a basic tree already constructed including a title element, unless the title argument is omitted.
</dd>

</dl>


<dl class="idl-def">
	<dt>@createDocumentType(qualifiedName, publicId, systemId)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createDocumentType(qualifiedName, publicId, systemId) method, when invoked, must run these steps:
</p>


<ol>
 <li>
%qualifiedName を`有修飾~名として検証-$する
（例外投出あり）
◎
Validate qualifiedName. Rethrow any exceptions.
</li>

 <li>
<p>
~RET 次のように設定された 新たな`文書型$
</p>

<ul><li>`文書型名$ ~SET %qualifiedName
</li><li>`~publicID$ ~SET %publicId
</li><li>`~systemID$ ~SET %systemId
</li><li>`~node文書$ ~SET 此れに結付けられている`文書$
</li></ul>

◎
Return a new doctype, with qualifiedName as its name, publicId as its public ID, and systemId as its system ID, and with its node document set to the associated document of the context object.
 </li>
</ol>

	</dd>
	<dd class="note">注記：
%publicId を成す符号位置が `PubidChar^prod 生成規則に合致するかどうかや，
%systemId が［
'<code class="literal">"</code>', `'^l
］のいずれも含んでいないかどうかは、検査されない。
◎
No check is performed that publicId code points match the PubidChar production or that systemId does not contain both a '"' and a "'".
</dd>

	<dt>@createDocument(namespace, qualifiedName, doctype)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createDocument(namespace, qualifiedName, doctype) method, when invoked, must run these steps:
</p>

<ol>
 <li>
%文書 ~LET 新たな $XMLDocument
◎
Let document be a new XMLDocument.
</li>

 <li>
%要素 ~LET ~NULL
◎
Let element be null.
</li>

 <li>
~IF［
%qualifiedName ~NEQ 空文字列
］
⇒
%要素 ~SET
( 此れ, %namespace, %qualifiedName, 空~辞書 )
を与える下で，
`内的 createElementNS 手続き$を走らせた結果
（例外投出あり）
◎
If qualifiedName is not the empty string, then set element to the result of running the internal createElementNS steps, given document, namespace, qualifiedName, and an empty dictionary. Rethrow any exceptions.
</li>

 <li>
~IF［
%doctype ~NEQ ~NULL
］
⇒
%doctype を %文書 に`付加-$する
◎
If doctype is non-null, append doctype to document.
</li>

 <li>
~IF［
%要素 ~NEQ ~NULL
］
⇒
%要素 を %文書 に`付加-$する
◎
If element is non-null, append element to document.
</li>

 <li>
%文書 の`生成元$ ~SET 此れに結付けられている`文書$の`生成元$
◎
document’s origin is context object’s associated document’s origin.
</li>


 <li>
<p>
%文書 の`内容型$ ~SET %~ns に応じて，次で与えられる値：
◎
document’s content type is determined by namespace:
</p>

<dl class="switch"
	><dt>`~HTML~ns$
</dt><dd>`application/xhtml+xml^c
</dd><dt>`~SVG~ns$
</dt><dd>`image/svg+xml^c
</dd><dt>他の~ns◎Any other namespace
</dt><dd>`application/xml^c
</dd></dl>

 </li>

 <li>
~RET %文書
◎
Return document.
</li>
</ol>
	</dd>

	<dt>@createHTMLDocument(title)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createHTMLDocument(title) method, when invoked, must run these steps:
</p>

<ol>
 <li>
%文書 ~LET 次のように設定された，新たな`文書$
⇒
`種別$ ~SET `html^l, <br>
`内容型$ ~SET `text/html^l
◎
Let doc be a new document that is an HTML document.
◎
Set doc’s content type to "text/html".
</li>

 <li>
次のように設定された 新たな`文書型$を %文書 に`付加-$する
⇒
`文書型名$ ~SET `html^l ,<br>
`~node文書$ ~SET %文書
◎
Append a new doctype, with "html" as its name and with its node document set to doc, to doc.
</li>
 <li>
`html 要素^V ~LET
`新たな要素$( %文書, `html^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, html, and the HTML namespace, to doc.
</li>
 <li>
`html 要素^V を %文書 に`付加-$する
◎
↑</li>
 <li>
`head 要素^V ~LET
`新たな要素$( %文書, `head^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, head, and the HTML namespace, to the html element created earlier.
</li>
 <li>
`head 要素^V を `html 要素^V に`付加-$する
◎
↑</li>
 <li>
<p>
~IF［
%title 引数は与えられている
］：
◎
If title is given:
</p>
  <ol>
   <li>
`title 要素^V ~LET
`新たな要素$( %文書, `title^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, title, and the HTML namespace, to the head element created earlier.
</li>
   <li>
`title 要素^V を `head 要素^V に`付加-$する
◎
↑</li>
   <li>
`新たな~text~node$( %title, %文書 )
を， `title 要素^V に`付加-$する
◎
Append a new Text node, with its data set to title (which could be the empty string) and its node document set to doc, to the title element created earlier.
</li>

  </ol>
 </li>

 <li>
`新たな要素$( %文書, `body^l, `~HTML~ns$ )
を， `html 要素^V に`付加-$する
◎
Append the result of creating an element given doc, body, and the HTML namespace, to the html element created earlier.
</li>

 <li><!-- cp* -->
%文書 の`生成元$ ~SET 此れに結付けられている`文書$の`生成元$
`HTML$r
◎
doc’s origin is context object’s associated document’s origin.
</li>

 <li>
~RET %文書
◎
Return doc.
</li>
</ol>
	</dd>

	<dt>@hasFeature()</dt>
	<dd>
被呼出時には、 ~T を返さ~MUST：
◎
The hasFeature() method, when invoked, must return true.
	</dd>
	<dd class="note">注記：
$hasFeature()
は元々、~UA が所与の~DOM特色機能の~supportを~~言明しているかどうかを報告するものであったが、経験から、単に望まれる~obj, 属性, ~methの存在-を確かめる用途には信頼が置けない, または不十分であることが判明している。
そのようなわけで、それは最早~利用されないが、古い~pageが働き続けられるようにするために存続している（単に ~T を返す）。
◎
hasFeature() originally would report whether the user agent claimed to support a given DOM feature, but experience proved it was not nearly as reliable or granular as simply checking whether the desired objects, attributes, or methods existed. As such, it is no longer to be used, but continues to exist (and simply returns true) so that old pages don’t stop working.
</dd>
</dl>

			</section>
		</section>
		<section id="interface-documenttype">

<h3>4.6. ~ifc ^@DocumentType</h3>

⇒！
[Exposed=Window]
interface @DocumentType : $Node {
  ~RA ~DS $name;
  ~RA ~DS $publicId;
  ~RA ~DS $systemId;
};
◎


<p>
$DocumentType `~node$は、単に
`文書型@
（ doctype ）とも呼ばれている。
◎
DocumentType nodes are simply known as doctypes.
</p>


<div class="p">
<p>
各 `文書型$には、次のものが結付けられる（いずれも，文字列）：
</p>

<dl class="def-list">
	<dt>`文書型名@</dt>
	<dd>
常に，`文書型$の作成時に与えられる。
</dd>

	<dt>`~publicID@</dt>
	<dt>`~systemID@</dt>
	<dd>
これらは、`文書型$の作成時に明示的に与えられない限り，空文字列とする。
</dd>

</dl>

◎
Doctypes have an associated name, public ID, and system ID.
◎
When a doctype is created, its name is always given. Unless explicitly given when a doctype is created, its public ID and system ID are the empty string.
</div>



<dl class="idl-def">
	<dt>@name</dt>
	<dd>
取得子は、此れの`文書型名$を返さ~MUST。
◎
The name attribute’s getter must return the context object’s name.
</dd>

	<dt>@publicId</dt>
	<dd>
取得子は、此れの`~publicID$を返さ~MUST。
◎
The publicId attribute’s getter must return the context object’s public ID.
</dd>

	<dt>@systemId</dt>
	<dd>
取得子は、此れの`~systemID$を返さ~MUST。
◎
The systemId attribute’s getter must return the context object’s system ID.
</dd>
</dl>

		</section>
		<section id="interface-documentfragment">
<h3>4.7. ~ifc ^@DocumentFragment</h3>

⇒！
[$Constructor,
 Exposed=Window]
interface @DocumentFragment : $Node {
};
◎

<p class="trans-note">【
この訳では， $DocumentFragment `~node$を
`文書片@
と記すことにする。
】</p>

<p>
各 `文書片$には、
`~host@
が結付けられる
— それは，［
~NULL, 異なる`~node木$内にある`要素$
］のいずれかであり、他が定められない限り，~NULL とする。
◎
A DocumentFragment node has an associated host (null or an element in a different node tree). It is null unless otherwise stated.
</p>

<div class="p">
<p>
~obj %A が ~obj %B の
`~hostも含む広義先祖@
であるとは、次のいずれかが満たされることを意味する：
</p>

<ul>
	<li>
%A は %B の`広義先祖$である。
</li>
	<li>
%B の`根$の`~host$ %H は非 ~NULL, かつ
%A は %H の`~hostも含む広義先祖$である。
</li>
</ul>

◎
An object A is a host-including inclusive ancestor of an object B, if either A is an inclusive ancestor of B, or if B’s root has a non-null host and A is a host-including inclusive ancestor of B’s root’s host.
</div>

<p class="note">注記：
`文書片$の`~host$は，~HTMLの `template$e 要素と`~shadow根$で有用になる概念であり、`前挿入$および`置換-$の~algoに影響0する。 
◎
The DocumentFragment node’s host concept is useful for HTML’s template element and for shadow roots, and impacts the pre-insert and replace algorithms.
</p>

<hr>
<dl class="domintro">
 <dt>var %tree = new $DocumentFragment()</dt>
 <dd>
新たな`文書片$を返す。
◎
Returns a new DocumentFragment node.
</dd>
</dl>

<dl class="idl-def">
	<dt>@DocumentFragment()</dt>
	<dd>
この構築子の被呼出時には、次のようにされた新たな`文書片$を返さ~MUST
⇒
`~node文書$ ~SET `現在の大域~obj$に`結付けられている文書$
◎
The DocumentFragment() constructor, when invoked, must return a new DocumentFragment node whose node document is current global object’s associated Document.
</dd>
</dl>

		</section>
		<section id="interface-shadowroot">

<h3>4.8. ~ifc ^@ShadowRoot</h3>

⇒！
[Exposed=Window]
interface @ShadowRoot : $DocumentFragment {
  ~RA $ShadowRootMode $mode;
  ~RA $Element $host;
};

enum @ShadowRootMode { `open@l, `closed@l };
◎


<p>
$ShadowRoot ~nodeは、単に
`~shadow根@
（ shadow root ）とも呼ばれている。
◎
ShadowRoot nodes are simply known as shadow roots.
</p>

<p>
各 `~shadow根$には、
`~mode@sR
が結付けられる。
それは、［
`open^l, `closed^l
］のいずれかである。
◎
Shadow roots have an associated mode("open" or "closed").
</p>

<p>
`~shadow根$の`~host$が ~NULL になることは決してない。
◎
Shadow roots’s associated host is never null.
</p>

<div class="p">
<p>
所与の %~event の下で，`~shadow根$ %根 の`親~targetを取得-$するときは、次を走らす：
</p>

<ol>
	<li>
~IF［
%~event の`~composed$f ~EQ ~OFF
］~AND［
%根 ~EQ ［［［
%~event の`経路$
］内の最初の組
］の `item$i
］の`根$
］
⇒
~RET ~NULL
</li>
	<li>
~RET %根 の`~host$
</li>
</ol>

◎
A shadow root’s get the parent algorithm, given an event, returns null if event’s composed flag is unset and shadow root is the root of event’s path’s first tuple’s item, and shadow root’s host otherwise.
</div>


<dl class="idl-def">
	<dt>@mode</dt>
	<dd>
取得子は、此れの`~mode$sRを返さ~MUST。
◎
The mode attribute’s getter must return the context object’s mode.
</dd>

	<dt>@host</dt>
	<dd>
取得子は、此れの`~host$を返さ~MUST。
◎
The host attribute’s getter must return the context object’s host.
</dd>
</dl>

<hr>

<p>
`~shadowも含む木~順序@
は、`木$に対する`~shadowも含む深優先前順走査$に従う順序である。
`~node木$ %木 に対する
`~shadowも含む深優先前順走査@
は、［
%木 に対する深優先前順走査†
］に従いつつ，
%木 において［
`~shadow~host$である`要素$ %要素
］に遭遇した各所では，［［
%要素 の`~shadow根$elmの`~node木$††
］に対する，`~shadowも含む深優先前順走査$
］に従う。
◎
In shadow-including tree order, is shadow-including preorder, depth-first traversal of a node tree. shadow-including preorder, depth-first traversal of a node tree tree is preorder, depth-first traversal of tree, with for each shadow host encountered in tree, shadow-including preorder, depth-first traversal of that element’s shadow root’s node tree just after it is encountered.
</p>

<p class="trans-note">【†
すなわち，通常の`木~順序$
】【††
すなわち，その~shadow根を`根$とするような`~shadow木$
】</p>


<p>
~obj %O の
`~shadowも含む根@
とは、
%O の`根$を %根 とするとき，［
%根 は`~shadow根$であるならば %根 の`~host$の`~shadowも含む根$ ／
~ELSE_ %根
］である。
◎
The shadow-including root of an object is its root’s host’s shadow-including root, if the object’s root is a shadow root, and its root otherwise.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む子孫@
であるとは、次を意味する
⇒
［
%A は %B の`子孫$である
］~OR［
%A の`根$ %根 は`~shadow根$であって，
%根 の`~host$は %B の`~shadowも含む広義子孫$である
］
◎
An object A is a shadow-including descendant of an object B, if A is a descendant of B, or A’s root is a shadow root and A’s root’s host is a shadow-including inclusive descendant of B.
</p>


<p>
~obj %A が~obj %B の
`~shadowも含む広義子孫@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`~shadowも含む子孫$である
］
◎
A shadow-including inclusive descendant is an object or one of its shadow-including descendants.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む先祖@
であるとは、次を意味する
⇒
%B は %A の`~shadowも含む子孫$である
◎
An object A is a shadow-including ancestor of an object B, if and only if B is a shadow-including descendant of A.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む広義先祖@
であるとは、次を意味する
⇒［
%A ~EQ %B
］~OR［
%A は %B の`~shadowも含む先祖$である
］
◎
A shadow-including inclusive ancestor is an object or one of its shadow-including ancestors.
</p>


<p>
`~node$ %A が `~node$ %B から
`~closed-shadow-hidden@
であるとは、 %A の`根$ %根 が次のすべてを満たすことを意味する：
◎
A node A is closed-shadow-hidden from a node B if all of the following conditions are true:
</p>

<ul>
	<li>
%根 は`~shadow根$である
◎
A’s root is a shadow root.
</li>
	<li>
%根 は %B の`~shadowも含む広義先祖$でない
◎
A’s root is not a shadow-including inclusive ancestor of B.
</li>
	<li>
［
%根 の`~mode$sR ~EQ `closed^l
］~OR［
%根 の`~host$は %B から`~closed-shadow-hidden$である
］
◎
A’s root is a shadow root whose mode is "closed" or A’s root’s host is closed-shadow-hidden from B.
</li>
</ul>

<p class="algo-head">
~obj %B に対し，~obj %A を
`再target@
するときは、次を走らす：
◎
To retarget an object A against an object B, repeat these steps until they return an object:
</p>

<ol>
 <li>
<p>
~WHILE 無条件：
◎
↑</p>
  <ol>
   <li>
%根 ~LET %A の`根$
◎
↓</li>
   <li>
~IF［
%根 は`~shadow根$でない
］~OR［
%根 は %B の`~shadowも含む広義先祖$である
］
⇒
~RET %A
◎
If A’s root is not a shadow root, or A’s root is a shadow-including inclusive ancestor of B, then return A.
</li>
   <li>
%A ~SET %根 の`~host$
◎
Set A to A’s root’s host.
</li>
  </ol>
 </li>
</ol>

<hr>

<p class="XXX">課題：
この~objについての更なる情報は、今の所，
<a href="https://w3c.github.io/webcomponents/spec/shadow/">Shadow DOM</a>
にて見れる。
~DOM標準には、時経過に伴い，それらの詳細が含められることになる。
◎
For now you can find more information about this object in Shadow DOM. The DOM Standard will be updated over time to cover more details.
</p>

		</section>
		<section id="interface-element">

<h3>4.9. ~ifc ^@Element</h3>

⇒！
[Exposed=Window]
interface @Element : $Node {
  ~RA ~DS? $namespaceURI;
  ~RA ~DS? $prefix;
  ~RA ~DS $localName;
  ~RA ~DS $tagName;

  [`CEReactions$] attribute ~DS $id;
  [`CEReactions$] attribute ~DS $className;
  [`CEReactions$ SameObject, PutForwards=$DOMTokenList.value] ~RA $DOMTokenList $classList;
  [`CEReactions$] attribute ~DS $slot;

  boolean $hasAttributes();
  [SameObject] ~RA $NamedNodeMap $attributes;
  sequence&lt;~DS&gt; $getAttributeNames();
  ~DS? $getAttribute(~DS %qualifiedName);
  ~DS? $getAttributeNS(~DS? %namespace, ~DS %localName);
  [`CEReactions$] void $setAttribute(~DS %qualifiedName, ~DS %value);
  [`CEReactions$] void $setAttributeNS(~DS? %namespace, ~DS %qualifiedName, ~DS %value);
  [`CEReactions$] void $removeAttribute(~DS %qualifiedName);
  [`CEReactions$] void $removeAttributeNS(~DS? %namespace, ~DS %localName);
  ~B $hasAttribute(~DS %qualifiedName);
  ~B $hasAttributeNS(~DS? %namespace, ~DS %localName);

  $Attr? $getAttributeNode(~DS %qualifiedName);
  $Attr? $getAttributeNodeNS(~DS? %namespace, ~DS %localName);
  [`CEReactions$] $Attr? $setAttributeNode($Attr %attr);
  [`CEReactions$] $Attr? $setAttributeNodeNS($Attr %attr);
  [`CEReactions$] $Attr $removeAttributeNode($Attr %attr);

  $ShadowRoot $attachShadow($ShadowRootInit %init);
  ~RA $ShadowRoot? $shadowRoot;

  $Element? $closest(~DS %selectors);
  ~B $matches(~DS %selectors);
  ~B $webkitMatchesSelector(~DS %selectors); // <span class="comment" title="historical alias of .characterSet">$matches の歴史上の別名</span>

  $HTMLCollection $getElementsByTagName(~DS %qualifiedName);
  $HTMLCollection $getElementsByTagNameNS(~DS? %namespace, ~DS %localName);
  $HTMLCollection $getElementsByClassName(~DS %classNames);

  [`CEReactions$] $Element? $insertAdjacentElement(~DS %where, $Element %element); // <!--cp-histroic-->
  void $insertAdjacentText(~DS %where, ~DS %data); // <!--cp-histroic-->
};

dictionary @@ShadowRootInit {
  required $ShadowRootMode @mode;
};
◎

<p>
$@Element `~node$は、単に
`要素@
とも呼ばれている。
◎
Element nodes are simply known as elements.
</p>

<p>
各 `要素$には［
`~ns@,
`~ns接頭辞@,
`局所名@,
`~custom要素~状態@,
`~custom要素~定義@,
`~is0値@
］が結付けられる。
これらのいずれの値も，`要素を作成-$するときに初期化される。
◎
Elements have an associated namespace, namespace prefix, local name, custom element state, custom element definition, is value. When an element is created, all of these values are initialized.
</p>

<p>
`要素$の`~custom要素~状態$は、［
`undefined^l ／ `failed^l ／ `uncustomized^l ／ `custom^l
］のいずれかである。
`要素$のうち［
`~custom要素~状態$ ~IN
{ `uncustomized^l ／ `custom^l }
］なるものは、
`定義済み@
という。
`要素$のうち［
`~custom要素~状態$ ~EQ `custom^l
］なるものは、
`~custom@
という。
◎
An element’s custom element state is one of "undefined", "failed", "uncustomized", or "custom". An element whose custom element state is "uncustomized" or "custom" is said to be defined. An element whose custom element state is "custom" is said to be custom.
</p>

<p class="note">注記：
要素が`定義済み$かどうかは、
<a href="~HTMLselectors#selector-defined"><code class="pseudo">:defined</code></a>
疑似類の挙動を決定するときに利用される。
要素が`~custom$であるかどうかは、
<a href="#mutation-algorithms">変異~algo</a>
の挙動を決定するときに利用される。
`failed^l 状態は、`~custom要素~構築子$が初回に正しく実行するのに失敗した場合に，`昇格$により再び実行されないことを確保するために利用される。
◎
Whether or not an element is defined is used to determine the behavior of the :defined pseudo-class. Whether or not an element is custom is used to determine the behavior of the mutation algorithms. The "failed" state is used to ensure that if a custom element constructor fails to execute correctly the first time, it is not executed again by an upgrade.
</p>

<div class="example">
<p>
要素がとり得るこれら 4 種の状態を，次の~codeで~~説明する：
◎
The following code illustrates elements in each of these four states:
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;script&gt;
  window.customElements.define(
    "sw-rey",
    class extends HTMLElement {}
  );
  window.customElements.define(
    "sw-finn",
    class extends HTMLElement {},
    { extends: "p" }
  );
  window.customElements.define(
    "sw-kylo",
    class extends HTMLElement {
      constructor() {
        /* <span class="comment">
`super()^c は、この例からは意図的に省略している。
◎
super() intentionally omitted for this example
</span> */
    }
  });
&lt;/script&gt;

&lt;!-- <span class="comment">
`undefined^l （`定義済み$でも`~custom$でもない）
◎
"undefined" (not defined, not custom)
</span> --&gt;
&lt;sw-han&gt;&lt;/sw-han&gt;
&lt;p is="sw-luke"&gt;&lt;/p&gt;
&lt;p is="asdf"&gt;&lt;/p&gt;

&lt;!-- <span class="comment">
`failed^l （`定義済み$でも`~custom$でもない）
◎
"failed" (not defined, not custom)
</span> --&gt;
&lt;sw-kylo&gt;&lt;/sw-kylo&gt;

&lt;!-- <span class="comment">
`uncustomized^l （`定義済み$であるが`~custom$ではない）
◎
"uncustomized" (defined, not custom)
</span> --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;asdf&gt;&lt;/asdf&gt;

&lt;!-- <span class="comment">
`custom^l （`定義済み$であって`~custom$でもある）
◎
"custom" (defined, custom)
</span> --&gt;
&lt;sw-rey&gt;&lt;/sw-rey&gt;
&lt;p is="sw-finn"&gt;&lt;/p&gt;
</pre>

</div>

<p>
`要素$には
`~shadow根@elm
（ ~NULL, または `~shadow根$）も結付けられる。
他が定められない限り，~NULL とする。
`要素$のうち，［
`~shadow根$elm ~NEQ ~NULL
］なるものは、
`~shadow~host@
とされる。
◎
Elements also have an associated shadow root (null or a shadow root). It is null unless otherwise stated. An element is a shadow host if its shadow root is non-null.
</p>

<p>
`要素$ %要素 の
`有修飾~名@
とは、［
%要素 の`~ns接頭辞$ ~EQ ~NULL ならば %要素 の`局所名$ ／
~ELSE_［
%要素 の`~ns接頭辞$, `:^l, %要素 の`局所名$
］の並びである。
◎
An element’s qualified name is its local name if its namespace prefix is null, and its namespace prefix, followed by ":", followed by its local name, otherwise.
</p>

<p class="note" id="cp-for-readbility">
~UAは、これを内的~slotに持たせて最適化することもできるが、要求されるわけでない。
この概念は、可読性のために，この標準に取り入れられている。
◎
User agents could have this as an internal slot as an optimization, but are not required to do so. The standard has this concept for readability.
</p>


<p class="algo-head">
`要素を作成-@
するときは、所与の
( %文書, %局所名, %~ns, %接頭辞 （省略時は ~NULL ）, %is （省略時は ~NULL ）, %同期~custom要素~flag （省略時は ~OFF ）)
に対し，次の手続きを走らす：
◎
To create an element, given a document, localName, namespace, and optional prefix, is, and synchronous custom elements flag, run these steps: 
</p>

<p class="trans-note">【
この訳では、この手続きを呼出すときは，
“`新たな要素$( %引数~list )”
のように表記する。
】</p>

<ol>
 <li>
%結果 ~LET ~NULL
◎
If prefix was not given, let prefix be null.
◎
If is was not given, let is be null.
◎
Let result be null.
</li>
 <li>
%定義 ~LET
( %文書, %~ns, %局所名, %is )
を与える下で，`~custom要素~定義を検索-$した結果
◎
Let definition be the result of looking up a custom element definition given document, namespace, localName, and is.
</li>
 <li>
<p>
~IF［
%定義 ~NEQ ~NULL
］~AND［
%定義 の`名前$cD ~NEQ %定義 の`局所名$cD
］（すなわち，%定義 は`~custom化された組込みの要素$を表現する）：
◎
If definition is non-null, and definition’s name is not equal to its local name (i.e., definition represents a customized built-in element), then:
</p>
  <ol>
   <li>
%~ifc ~LET
( %局所名, `~HTML~ns$ )
に`対応する要素~ifc$
◎
Let interface be the element interface for localName and the HTML namespace.
</li>
   <li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$：
</p>

<ul ><li>%~ifc を実装する
</li><li>`属性0$は持たない
</li><li>`~ns$ ~SET `~HTML~ns$
</li><li>`~ns接頭辞$ ~SET %接頭辞 
</li><li>`局所名$ ~SET %局所名
</li><li>`~custom要素~状態$ ~SET `undefined^l
</li><li>`~custom要素~定義$ ~SET ~NULL
</li><li>`~is0値$ ~SET %is
</li><li>`~node文書$ ~SET %文書
</li></ul>

◎
Set result to a new element that implements interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "undefined", custom element definition set to null, is value set to is, and node document set to document.
</li>
   <li>
~IF［
%同期~custom要素~flag ~EQ ~ON
］
⇒
%定義 を用いて %要素 を`昇格$する
◎
If the synchronous custom elements flag is set, upgrade element using definition.
</li>
   <li>
~ELSE
⇒
( %結果, %定義 )
を与える下で，`~custom要素~昇格~反応を待入れる$
◎
Otherwise, enqueue a custom element upgrade reaction given result and definition.
</li>
  </ol>
 </li>
 <li>
<p>
~ELIF［
%定義 ~NEQ ~NULL
］：
◎
Otherwise, if definition is non-null, then:
</p>
  <ol>
   <li>
<p>
~IF［
%同期~custom要素~flag ~EQ ~ON
］：
◎
If the synchronous custom elements flag is set:
</p>
    <ol>
     <li>
%C ~LET %定義 の`構築子$cD
◎
Let C be definition’s constructor.
</li>
     <li>
%結果 ~SET
<a href="https://tc39.github.io/ecma262/#sec-construct"><span class="abstract">Construct( %C )</span></a>
（例外投出あり）
◎
Set result to Construct(C). Rethrow any exceptions.
</li>
     <li>
<p>
~IF［
%結果 は $HTMLElement ~ifcを実装しない
］
⇒
~THROW `TypeError^E
◎
If result does not implement the HTMLElement interface, throw a TypeError.
</p>

      <div class="note">
<p>注記：
これは、当の~objが~HTML要素~構築子により割り当てられることを確保するための~brand検査である。
より精確に知りたければ
<a href="https://github.com/heycam/webidl/issues/97">webidl #97</a>
を見よ。
◎
This is meant to be a brand check to ensure that the object was allocated by the a HTML element constructor. See webidl #97 about making this more precise.
HTMLElement 
</p>

<p>
この検査に合格したなら、 %結果 の［
`~custom要素~状態$, `~custom要素~定義$
］はすでに初期化されていることになる。
◎
If this check passes, then result will already have its custom element state and custom element definition initialized. 
</p>
      </div>
     </li>
     <li>
~IF［
%結果 は次のいずれかを満たす
］…：

<ul ><li>%結果 の`属性0~list$は空でない
</li><li>%結果 は`子$を持つ
</li><li>%結果 の`親$ ~NEQ ~NULL
</li><li>%結果 の`~node文書$ ~NEQ %文書
</li><li>
<p>
%結果 の`~ns$ ~NEQ `~HTML~ns$
</p>
<p class="note">注記：
これを書いている時点では、
$HTMLElement ~ifcを実装するどの要素も~HTML~nsに属するので、上の~brand検査から，この検査は冗長であるが、永遠に保障されるわけではない
— 例えば、~SVGと~HTMLのある種の~ifcが収束するような，仕様の変更に直面したときなど。
</p>

</li><li>%結果 の`局所名$ ~NEQ %局所名
</li></ul>

…ならば
⇒
~THROW `NotSupportedError^E

◎
If result’s attribute list is not empty, then throw a NotSupportedError.
◎
If result has children, then throw a NotSupportedError.
◎
If result’s parent is not null, then throw a NotSupportedError.
◎
If result’s node document is not document, then throw a NotSupportedError.
◎
If result’s namespace is not the HTML namespace, then throw a NotSupportedError.
◎
As of the time of this writing, every element that implements the HTMLElement interface is also in the HTML namespace, so this check is currently redundant with the above brand check. However, this is not guaranteed to be true forever in the face of potential specification changes, such as converging certain SVG and HTML interfaces.
◎
If result’s local name is not equal to localName, then throw a NotSupportedError.
</li>
     <li>
%結果 の`~ns接頭辞$ ~SET %接頭辞
◎
Set result’s namespace prefix to prefix.
</li>
     <li>
%結果 の`~is0値$ ~SET ~NULL
◎
Set result’s namespace prefix to prefix.
</li>
    </ol>
   </li>
   <li>
<p>
~ELSE：
◎
Otherwise:
</p>
    <ol>
     <li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$：
</p>

<ul ><li>$HTMLElement を実装する
</li><li>`属性0$は持たない
</li><li>`~ns$ ~SET `~HTML~ns$
</li><li>`~ns接頭辞$ ~SET %接頭辞 
</li><li>`局所名$ ~SET %局所名
</li><li>`~custom要素~状態$ ~SET `undefined^l
</li><li>`~custom要素~定義$ ~SET ~NULL
</li><li>`~is0値$ ~SET ~NULL
</li><li>`~node文書$ ~SET %文書
</li></ul>

◎
Set result to a new element that implements the HTMLElement interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "undefined", custom element definition set to null, is value set to null, and node document set to document.
</li>
     <li>
( %結果, %定義 )
を与える下で，`~custom要素~昇格~反応を待入れる$
◎
Enqueue a custom element upgrade reaction given result and definition.
</li>
     </ol>
    </li>
   </ol>
 </li>
 <li>
<p>
~ELSE：
◎
Otherwise:
</p>
  <ol>
   <li>
%~ifc ~LET 
( %局所名, %~ns )
に`対応する要素~ifc$
◎
Let interface be the element interface for localName and namespace.
</li>
   <li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$：
</p>

<ul ><li>%~ifc を実装する
</li><li>`属性0$は持たない
</li><li>`~ns$ ~SET %~ns
</li><li>`~ns接頭辞$ ~SET %接頭辞 
</li><li>`局所名$ ~SET %局所名
</li><li>`~custom要素~状態$ ~SET `uncustomized^l
</li><li>`~custom要素~定義$ ~SET ~NULL
</li><li>`~is0値$ ~SET %is
</li><li>`~node文書$ ~SET %文書
</li></ul>

◎
Set result to a new element that implements interface, with no attributes, namespace set to namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "uncustomized", custom element definition set to null, is value set to is, and node document set to document.
</li>
   <li>
~IF［
次のいずれも満たされる
］…：

<ul ><li>%~ns ~EQ `~HTML~ns$
</li><li>［
%局所名 は`妥当な~custom要素~名$である
］~OR［
%is ~NEQ ~NULL
］
</li></ul>

…ならば
⇒
%結果 の`~custom要素~状態$ ~SET `undefined^l
◎
If namespace is the HTML namespace, and either localName is a valid custom element name or is is non-null, then set result’s custom element state to "undefined".
</li>
  </ol>
 </li>
 <li>
~RET %結果
◎
Return result.
</li>
</ol>


<p>
`要素$は、有順序の
`属性0~list@
も持ち， $NamedNodeMap
<span class="trans-note">【
~objである $attributes 属性
】</span>
を通して公開される。
`要素$の作成時に明示的に与えられない限り，その`属性0~list$は空である。
`要素$ %要素 が`属性0$ %A を
`有する@
とは、［
%A ~IN %要素 の`属性0~list$
］を意味する。
◎
Elements also have an ordered attribute list exposed through a NamedNodeMap. Unless explicitly given when an element is created, its attribute list is empty. An element has an attribute A if A is in its attribute list.
</p>


<p>
`適用仕様$は、`要素$上の
`属性0を変更する手続き@
を定義して~MAY。
そのような~algoには、当の要素に加えて，
( %局所名, %旧-値, %値, %~ns )
が渡される。
◎
This and other specifications may define attribute change steps for elements. The algorithm is passed element, localName, oldValue, value, and namespace.
</p>


<p class="algo-head">
`要素$ %要素 の（`有する$）`属性0$ %属性0 の`値$aを %値 に
`変更-@a
するときは、次を走らす：
◎
To change an attribute attribute from an element element to value, run these steps:
</p>

<ol>
 <li>
%要素 に対する次の様な `attributes^l の変異~記録を`待入する$
⇒
名前: %属性0 の`局所名$a,<br>
~ns: %属性0 の`~ns$,<br>
旧-値: %属性0 の`値$a
◎
Queue a mutation record of "attributes" for element with name attribute’s local name, namespace attribute’s namespace, and oldValue attribute’s value.
</li>

 <li>
~IF［
%要素 は`~custom$である
］
⇒
次を与える下で，`~custom要素~callback反応を待入れる$
⇒
%要素,<br>
~callback名： `attributeChangedCallback^l,<br>
引数~list：
( %属性0 の`局所名$, %属性0 の`値$a, %値, %属性0 の`~ns$ )
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute’s local name, attribute’s value, value, and attribute’s namespace.
</li>

 <li>
次を渡して，
%要素 上の`属性0を変更する手続き$を走らす
⇒
( %属性0 の`局所名$a, %属性0 の`値$a, %値, %属性0 の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, attribute’s value, value, and attribute’s namespace.
</li>

 <li>
%属性0 の`値$a ~SET %値
◎
Set attribute’s value to value.
</li>

</ol>



<p class="algo-head">
`要素$ %要素 に（それが`有さない$）`属性0$ %属性0 を
`付加-@a
するときは、次を走らす：
◎
To append an attribute attribute to an element element, run these steps:
</p>

<ol>
 <li>
%要素 に対する次の様な `attributes^l の変異~記録を`待入する$
⇒
名前: %属性0 の`局所名$a,<br>
~ns: %属性0 の`~ns$,<br>
旧-値: null
◎
Queue a mutation record of "attributes" for element with name attribute’s local name, namespace attribute’s namespace, and oldValue null.
</li>
 <li>
~IF［
%要素 は`~custom$である
］
⇒
次を与える下で，`~custom要素~callback反応を待入れる$
⇒
%要素,<br>
~callback名： `attributeChangedCallback^l,<br>
引数~list：
( %属性0 の`局所名$, ~NULL, %属性0 の`値$a, %属性0 の`~ns$ )
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute’s local name, null, attribute’s value, and attribute’s namespace.
</li>
 <li>
次を渡して，
%要素 上の`属性0を変更する手続き$を走らす
⇒
( %属性0 の`局所名$a, ~NULL, %属性0 の`値$a, %属性0 の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, null, attribute’s value, and attribute’s namespace.
</li>
 <li>
%属性0 を %要素 の`属性0~list$に付加する
◎
Append the attribute to the element’s attribute list.
</li>
 <li>
%属性0 が`属する要素$ ~SET %要素
◎
Set attribute’s element to element.
</li>
</ol>


<p class="algo-head">
`要素$ %要素 から（それが`有する$）`属性0$ %属性0 を
`除去-@a
するときは、次を走らす：
◎
To remove an attribute attribute from an element element, run these steps:
</p>

<ol>
 <li>
%要素 に対する次の様な `attributes^l の変異~記録を`待入する$
⇒
名前: %属性0 の`局所名$a,<br>
~ns: %属性0 の`~ns$,<br>
旧-値: %属性0 の`値$a
◎
Queue a mutation record of "attributes" for element with name attribute’s local name, namespace attribute’s namespace, and oldValue attribute’s value.
</li>
 <li>
~IF［
%要素 は`~custom$である
］
⇒
次を与える下で，`~custom要素~callback反応を待入れる$
⇒
%要素,<br>
~callback名： `attributeChangedCallback^l,<br>
引数~list：
( %属性0 の`局所名$, %属性0 の`値$a, ~NULL, %属性0 の`~ns$ )
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute’s local name, attribute’s value, null, and attribute’s namespace.
</li>

 <li>
次を渡して，
%要素 上の`属性0を変更する手続き$を走らす
⇒
( %属性0 の`局所名$a, %属性0 の`値$a, ~NULL, %属性0 の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, attribute’s value, null, and attribute’s namespace.
</li>

 <li>
%要素 の`属性0~list$から %属性0 を除去する
◎
Remove attribute from the element’s attribute list.
</li>
 <li>
%属性0 が`属する要素$ ~SET ~NULL
◎
Set attribute’s element to null.
</li>
</ol>

<hr>

<p class="algo-head">
`要素$ %要素 内の`属性0$ %旧-属性0 を `属性0$ %新-属性0 で
`置換-@a
するときは、次を走らす：
◎
To replace an attribute oldAttr by an attribute newAttr in an element element, run these steps:
</p>

<ol>
 <li>
%要素 に対する次の様な `attributes^l の変異~記録を`待入する$
⇒
名前: %旧-属性0 の`局所名$a,<br>
~ns: %旧-属性0 の`~ns$a,<br>
旧-値: %旧-属性0 の`値$a
◎
Queue a mutation record of "attributes" for element with name oldAttr’s local name, namespace oldAttr’s namespace, and oldValue oldAttr’s value.
</li>
 <li>
~IF［
%要素 は`~custom$である
］
⇒
次を与える下で，`~custom要素~callback反応を待入れる$
⇒
%要素,<br>
~callback名： `attributeChangedCallback^l,<br>
引数~list：
( %旧-属性0 の`局所名$, %旧-属性0 の`値$a, %新-属性0 の`値$a, %旧-属性0 の`~ns$ )
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing oldAttr’s local name, oldAttr’s value, newAttr’s value, and oldAttr’s namespace.
</li>

 <li>
次を渡して，
%要素 上の`属性0を変更する手続き$を走らす
⇒
( %旧-属性0 の`局所名$a, %旧-属性0 の`値$a, %新-属性0 の`値$a, %旧-属性0 の`~ns$a )
◎
Run the attribute change steps with element, oldAttr’s local name, oldAttr’s value, newAttr’s value, and oldAttr’s namespace.
</li>

 <li>
%要素 の`属性0~list$内の %旧-属性0 を %新-属性0 で置換する
◎
Replace oldAttr by newAttr in the element’s attribute list.
</li>
 <li>
%旧-属性0 が`属する要素$ ~SET ~NULL
◎
Set oldAttr’s element to null.
</li>
 <li>
%新-属性0 が`属する要素$ ~SET %要素
◎
Set newAttr’s element to element.
</li>
</ol>

<p class="algo-head">
所与の %有修飾~名 を用いて，`要素$ %要素 から
`属性0を取得-@
するときは、次を走らす：
◎
To get an attribute by name given a qualifiedName and element element, run these steps:
</p>

<ol>
 <li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
%有修飾~名 ~LET %有修飾~名 の`~ASCII小文字化$
◎
If element is in the HTML namespace and its node document is an HTML document, let qualifiedName be converted to ASCII lowercase.
</li>

 <li>
~RET %要素 の`属性0~list$ 内の［
`有修飾~名$a ~EQ %有修飾~名
］なる`最初0$の`属性0$
◎
Return the first attribute in element’s attribute list whose qualified name is qualifiedName, and null otherwise.
</li>
</ol>

<p class="algo-head">
所与の
( %~ns, %局所名 )
を用いて，`要素$ %要素 から
`属性0を取得-@ns
するときは、次を走らす：
◎
To get an attribute by namespace and local name given a namespace, localName, and element element, run these steps:
</p>

<ol>
 <!--cp-normalize-ns-->

 <li>
~RET %要素 の`属性0~list$ 内の［
`~ns$a ~EQ %~ns
］~AND［
`局所名$a ~EQ %局所名
］なる`最初0$の`属性0$
◎
Return the attribute in element’s attribute list whose namespace is namespace and local name is localName, if any, and null otherwise.
</li>
</ol>

<p class="algo-head">
( %局所名,  %~ns （省略時は ~NULL ） )
を用いて，`要素$ %要素 から
`属性0値を取得-@
するときは、次を走らす：
◎
To get an attribute value given an element element, localName, and optionally a namespace (null unless stated otherwise), run these steps:
</p>

<ol>
 <li>
%属性0 ~LET
( %局所名,  %~ns )
を用いて， %要素 から`属性0を取得-$nsした結果
◎
Let attr be the result of getting an attribute given namespace, localName, and element.
</li>
 <li>
~RET ［
%属性0 ~EQ ~NULL ならば空文字列 ／
~ELSE_ %属性0 の`値$a
］
◎
If attr is null, then return the empty string.
◎
Return attr’s value.
</li>
</ol>

<p class="algo-head">
所与の`属性0$ %属性0 を用いて`要素$ %要素 の
`属性0を設定-@
するときは、次を走らす：
◎
To set an attribute given an attr and element, run these steps:
</p>

<ol>
 <li>
~IF［
%属性0 が`属する要素$ ~NIN { ~NULL, %要素 }
］
⇒
~THROW `InUseAttributeError^E
◎
If attr’s element is neither null nor element, throw an InUseAttributeError.
</li>

 <li>
%旧-属性0 ~LET
( %属性0 の`~ns$a, %属性0 の`局所名$a )
を用いて， %要素 から`属性0を取得-$nsした結果
◎
Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local name, and element.
</li>

 <li>
~IF［
%旧-属性0 ~EQ %属性0
］
⇒
~RET %属性0
◎
If oldAttr is attr, return attr.
</li>

 <li>
~IF［
%旧-属性0 ~NEQ ~NULL
］
⇒
%要素 内の %旧-属性0 を %属性0 で`置換-$aする
◎
If oldAttr is non-null, replace it by attr in element.
</li>

 <li>
~ELSE
⇒
%要素 に %属性0 を`付加-$aする
◎
Otherwise, append attr to element.
</li>

 <li>
~RET %旧-属性0
◎

Return oldAttr.
</li>
</ol>

<p class="algo-head">
( %局所名, %値 )
, および
( %接頭辞 （省略時は ~NULL ）, %~ns （省略時は ~NULL ） )
を用いて，`要素$ %要素 の
`属性0値を設定-@
するときは、次を走らす：
◎
To set an attribute value for an element element using a localName and value, and an optional prefix, and namespace, run these steps:
</p>

<ol>
 <li>
%属性0 ~LET
( %~ns, %局所名 )
を用いて， %要素 から`属性0を取得-$nsした結果
◎
If prefix is not given, set it to null.
◎
If namespace is not given, set it to null.
◎
Let attribute be the result of getting an attribute given namespace, localName, and element.
</li>

 <li>
~IF［
%属性0 ~NEQ ~NULL
］
⇒
%要素 の %属性0 の値を %値 に`変更-$aする；<br>
~RET
◎
↓</li>

 <li>
<p>
次のように設定された 新たな`属性0$を %要素 に`付加-$aする：
</p>

<ul><li>`~ns$a ~SET %~ns
</li><li>`~ns接頭辞$a ~SET %接頭辞
</li><li>`局所名$a ~SET %局所名
</li><li>`値$a ~SET %値
</li><li>`~node文書$ ~SET %要素 の`~node文書$
</li></ul>
◎
If attribute is null, create an attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, value is value, and node document is element’s node document, then append this attribute to element, and then terminate these steps.
◎
Change attribute from element to value.
 </li>
</ol>

<p class="algo-head">
所与の %有修飾~名 を用いて`要素$ %要素 から
`属性0を除去-@
するときは、次を走らす：
◎
To remove an attribute by name given a qualifiedName and element element, run these steps:
</p>

<ol>
 <li>
%属性0 ~LET %有修飾~名 を用いて %要素 から`属性0を取得-$した結果
◎
Let attr be the result of getting an attribute given qualifiedName and element.
</li>

 <li>
~IF［
%属性0 ~NEQ ~NULL
］
⇒
%要素 から %属性0 を`除去-$aする
◎
If attr is non-null, remove it from element.
</li>

 <li>
~RET %属性0
◎
Return attr.
</li>
</ol>

<p class="algo-head">
所与の
( %~ns, %局所名 )
を用いて，`要素$ %要素 から
`属性0を除去-@ns
するときは、次を走らす：
◎
To remove an attribute by namespace and local name given a namespace, localName, and element element, run these steps:
</p>

<ol>
 <li>
%属性0 ~LET
( %~ns, %局所名 )
を用いて， %要素 から`属性0を取得-$nsした結果
◎
Let attr be the result of getting an attribute given namespace, localName, and element.
</li>

 <li>
~IF［
%属性0 ~NEQ ~NULL
］
⇒
%要素 から %属性0 を`除去-$aする
◎
If attr is non-null, remove it from element.
</li>

 <li>
~RET %属性0
◎
Return attr.
</li>
</ol>

<hr>

<p>
`要素$には、一意な識別子である
`~ID@
が結付けられ得る。
◎
An element can have an associated unique identifier (ID)
</p>
<p class="note">注記：
歴史的に，`要素$は複数の識別子を持ち得ていた。
例えば~HTML `id^A `属性0$nmと DTD を利用して。
この仕様では
`~ID$を~DOMの概念とし，`要素$につき `id^A `属性0$nmで与えられる 1 個に限るとする。
◎
Historically elements could have multiple identifiers e.g., by using the HTML id attribute and a DTD. This specification makes ID a concept of the DOM and allows for only one per element, given by an id attribute.
</p>

<p class="algo-head">
`要素$の`~ID$の更新~時に利用する，`属性0を変更する手続き$は、次で与えられる：
◎
Use these attribute change steps to update an element’s ID:
</p>

<ol>
 <li>
~IF［
%局所名 ~EQ `id^l
］~AND［
%~ns ~EQ ~NULL
］~AND［
%値 ~IN { ~NULL, 空文字列 }
］
⇒
%要素 の`~ID$を未設定にする
◎
If localName is id, namespace is null, and value is null or the empty string, then unset element’s ID.
</li>
 <li>
~ELIF［
%局所名 ~EQ `id^l
］~AND［
%~ns ~EQ ~NULL
］
⇒
%要素 の`~ID$ ~SET %値
◎
Otherwise, if localName is id, namespace is null, then set element’s ID to value.
</li>
</ol>


<p class="note">注記：
この仕様は、どの`要素$に対しても，その［
^class, ^id, ^slot
］`属性0$nmに対する要件を定義しているが、これらの属性0を利用をするかどうかは，適合性の要件にしていない。
◎
While this specification defines requirements for class, id, and slot attributes on any element, it makes no claims as to whether using them is conforming or not.
</p>

<hr>

<p>
`~node$ %N の
`親~要素@
とは、［
%N の`親$が`要素$であるならば それ ／
~ELSE_ ~NULL
］である。
◎
A node’s parent of type Element is known as a parent element. If the node has a parent of a different type, its parent element is null.
</p>

<hr>

<dl class="domintro">
 <dt>%namespace = %element . $namespaceURI</dt>
 <dd>
`~ns$を返す。
◎
Returns the namespace.
</dd>

 <dt>%prefix = %element . $prefix</dt>
 <dd>
`~ns接頭辞$を返す。
◎
Returns the namespace prefix.
</dd>

 <dt>%localName = %element . $localName</dt>
 <dd>
`局所名$を返す。
◎
Returns the local name.
</dd>

 <dt>%qualifiedName = %element . $tagName</dt>
 <dd>
`有修飾~名$を返す。
（ `~HTML文書$ においては返値は大文字化される。）
◎
Returns the qualified name. (The return value is uppercased in an HTML document.)
</dd>
</dl>


<dl class="idl-def">
	<dt>@namespaceURI</dt>
	<dd>
取得子は、此れの`~ns$を返さ~MUST。
◎
The namespaceURI attribute’s getter must return the context object’s namespace.
</dd>

	<dt>@prefix</dt>
	<dd>
取得子は、此れの`~ns接頭辞$を返さ~MUST。
◎
The prefix attribute’s getter must return the context object’s namespace prefix.
</dd>

	<dt>@localName</dt>
	<dd>
取得子は、此れの`局所名$を返さ~MUST。
◎
The localName attribute’s getter must return the context object’s local name.
</dd>

	<dt>@tagName</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The tagName attribute’s getter must run these steps:
</p>

<ol>
 <li>
%有修飾~名 ~LET 此れの`有修飾~名$
◎
Let qualifiedName be context object’s qualified name.
</li>

 <li>
~IF［
此れは`~HTML~ns$に属する
］~AND［
此れの`~node文書$は`~HTML文書$である
］
⇒
~RET %有修飾~名 の`~ASCII大文字化$
◎
If the context object is in the HTML namespace and its node document is an HTML document, let qualifiedName be converted to ASCII uppercase.
</li>

 <li>
~RET %有修飾~名
◎
Return qualifiedName.
</li>
</ol>

	</dd>
</dl>
<hr>

<p class="algo-head">
要素~上の一部の IDL 属性は、所与の %名前 の`属性0$を
`反映-@
するように定義される。
すなわち、次に従うような取得子, 設定子を持た~MUST：
◎
IDL attributes that are defined to reflect a content attribute of a given name, must have a getter and setter that follow these steps:
</p>

<dl>
 <dt>取得子</dt>
 <dd>
( %名前 )
を用いて，此れから`属性0値を取得-$した結果を返す
◎
Return the result of running get an attribute value given context object and name.
</dd>

 <dt>設定子</dt>
 <dd>
( %名前, 所与の値 )
を用いて，此れの`属性0値を設定-$する
◎
Set an attribute value for the context object using name and the given value.
</dd>
</dl>


<dl class="idl-def">
	<dt>@id</dt>
	<dd>
`id^l 内容属性を`反映-$し~MUST。
◎
The id attribute must reflect the "id" content attribute.
</dd>

	<dt>@className</dt>
	<dd>
`class^l 内容属性を`反映-$し~MUST。
◎
The className attribute must reflect the "class" content attribute.
</dd>

	<dt>@classList</dt>
	<dd>
取得子は、次のようにされた $DOMTokenList を返さ~MUST
⇒
`要素$dtl ~SET 此れ,<br>
`属性0の局所名$dtl ~SET ^class
◎
↓</dd>
	<dd>
この属性が返す $DOMTokenList ~objの`~tokens$は、`要素$の
`~classes@
とも呼ばれる。
◎
The classList attribute’s getter must return a DOMTokenList object whose associated element is the context object and whose associated attribute’s local name is class. The tokens of this particular DOMTokenList object are also known as the element’s classes.
</dd>
	<dd class="trans-note">【
[SameObject] が指定されているので、各~要素とこの~objの各~instanceは，一対一に対応する。
】</dd>

	<dt>@slot</dt>
	<dd>
`slot^l 内容属性を`反映-$し~MUST。
◎
The slot attribute must reflect the "slot" content attribute.
</dd>
	<dd class="note">
［
^id, ^class, ^slot
］`属性0$nmは、要素の~nsにかかわらず どの要素~上にも現れ得るので、実質的に，（すべての~nsより）上位の大域~属性になる。
◎
id, class, and slot are effectively superglobal attributes as they can appear on any element, regardless of that element’s namespace.
</dd>


	<dt>@hasAttributes()</dt>
	<dd>
被呼出時には、［
此れの`属性0~list$が空ならば ~F ／
~ELSE_ ~T
］を返さ~MUST。
◎
The hasAttributes() method, when invoked, must return false if context object’s attribute list is empty, and true otherwise.
</dd>

	<dt>@attributes</dt>
	<dd>
取得子は、此れに結付けられている $NamedNodeMap を返さ~MUST。
◎
The attributes attribute’s getter must return the associated NamedNodeMap.
</dd>

	<dt>@getAttributeNames()</dt>
	<dd>
被呼出時には、［
此れの`属性0~list$内の各 `属性0$に対する`有修飾~名$a
］からなる，同じ順序の~list（属性0~listが空ならば空~list）を返さ~MUST。
◎
The getAttributeNames() method, when invoked, must return the qualified names of the attributes in the context object’s attribute list, in order, and the empty sequence otherwise.
</dd>
	<dd class="note">
結果の中の各 名前が一意になることは保障されない。
◎
These are not guaranteed to be unique.
</dd>

	<dt>@getAttribute(qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getAttribute(qualifiedName) method, when invoked, must run these steps:
</p>

<ol>
 <li>
%属性0 ~LET %qualifiedName を用いて此れから`属性0を取得-$した結果
◎
Let attr be the result of getting an attribute given qualifiedName and the context object.
</li>

 <li>
~RET ［
%属性0 ~EQ ~NULL ならば ~NULL ／
~ELSE_ %属性0 の`値$a
］
◎
If attr is null, return null.
◎
Return attr’s value.
</li>

</ol>
	</dd>

	<dt>@getAttributeNS(namespace, localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getAttributeNS(namespace, localName) method, when invoked, must these steps:
</p>

<ol>
 <li>
%属性0 ~LET
( %namespace, %localName )
を用いて，此れから`属性0を取得-$nsした結果
◎
Let attr be the result of getting an attribute given namespace, localName, and the context object.
</li>
 <li>
~IF［
%属性0 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If attr is null, return null.
</li>
 <li>
~RET %属性0 の`値$a
◎
Return attr’s value.
</li>
</ol>

	</dd>

	<dt>@setAttribute(qualifiedName, value)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setAttribute(qualifiedName, value) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%qualifiedName は~XMLの `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError^E
◎
If qualifiedName does not match the Name production in XML, then throw an InvalidCharacterError.
</li>

 <li id="cp-to-lowercase-if-html">
~IF［
此れは`~HTML~ns$に属する
］~AND［
此れの`~node文書$は`~HTML文書$である
］
⇒
%qualifiedName ~SET %qualifiedName の`~ASCII小文字化$
◎
If the context object is in the HTML namespace and its node document is an HTML document, let qualifiedName be converted to ASCII lowercase.
</li>

 <li>
%属性0 ~LET 此れの`属性0~list$内の［
`有修飾~名$a ~EQ %qualifiedName
］なる`属性0$のうち，`最初0$のもの
◎
Let attribute be the first attribute in context object’s attribute list whose qualified name is qualifiedName, and null otherwise.
</li>

 <li>
~IF［
%属性0 ~EQ ~NULL
］
⇒
次のように設定された 新たな`属性0$を，此れの`属性0~list$に`付加-$aする
⇒
`局所名$a ~SET %qualifiedName,<br>
`値$a ~SET %value,<br />
`~node文書$ ~SET 此れの`~node文書$
◎
If attribute is null, create an attribute whose local name is qualifiedName, value is value, and node document is context object’s node document, then append this attribute to context object , and then terminate these steps.
</li>

 <li>
~ELSE
⇒
此れの %属性0 の`値$aを %value に`変更-$aする
◎
Change attribute from context object to value.
</li>

</ol>
	</dd>

	<dt>@setAttributeNS(namespace, qualifiedName, value)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setAttributeNS(namespace, qualifiedName, value) method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-validate-and-extract-->

 <li>
( %局所名, %value ), および
( %接頭辞, %~ns )
を用いて，此れの`属性0値を設定-$する
◎
Set an attribute value for the context object using localName, value, and also prefix and namespace.
</li>
</ol>
	</dd>

	<dt>@removeAttribute(qualifiedName)</dt>
	<dd>
被呼出時には、 %qualifiedName を用いて 此れから`属性0を除去-$し~MUST。
<!-- ＊
and then return undefined.
 -->
◎
The removeAttribute(qualifiedName) method, when invoked, must remove an attribute given qualifiedName and the context object, and then return undefined.
</dd>

	<dt>@removeAttributeNS(namespace, localName)</dt>
	<dd>
被呼出時には、
( %namespace, %localName )
を用いて，此れから`属性0を除去-$nsし~MUST。
<!-- ＊
and then return undefined.
-->
◎
The removeAttributeNS(namespace, localName) method, when invoked, must remove an attribute given namespace, localName, and context object, and then return undefined.
</dd>

	<dt>@hasAttribute(qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The hasAttribute(qualifiedName) method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-to-lowercase-if-html-->

 <li>
~RET ［
此れは［
`有修飾~名$a ~EQ %qualifiedName
］なる`属性0$を`有する$ならば ~T ／
~ELSE_ ~F
］
◎
Return true if the context object has an attribute whose qualified name is qualifiedName, and false otherwise.
</li>

</ol>
	</dd>

	<dt>@hasAttributeNS(namespace, localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The hasAttributeNS(namespace, localName) method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-normalize-ns0-->

 <li>
~RET ［
此れは［
`~ns$a ~EQ %namespace
］~AND［
`局所名$a ~EQ %localName 
］なる`属性0$を`有する$ならば ~T ／
~ELSE_ ~F
］
◎
Return true if the context object has an attribute whose namespace is namespace and local name is localName, and false otherwise.
</li>
</ol>

	</dd>

	<dt>@getAttributeNode(qualifiedName)</dt>
	<dd>
被呼出時には、 %qualifiedName を用いて此れから`属性0を取得-$した結果を返さ~MUST。
◎
The getAttributeNode(qualifiedName) method, when invoked, must return the result of getting an attribute given qualifiedName and context object.
</dd>

	<dt>@getAttributeNodeNS(namespace, localName)</dt>
	<dd>
被呼出時には、
( %namespace, %localName )
を用いて，此れから`属性0を取得-$nsした結果を返さ~MUST。
◎
The getAttributeNodeNS(namespace, localName) method, when invoked, must return the result of getting an attribute given namespace, localName, and the context object.
</dd>

	<dt>@setAttributeNode(attr)</dt>
	<dt>@setAttributeNodeNS(attr)</dt>
	<dd>
これらのいずれも，被呼出時には、
%attr を用いて此れの`属性0を設定-$した結果を返さ~MUST（例外投出あり）。
◎
The setAttributeNode(attr) and setAttributeNodeNS(attr) methods, when invoked, must return the result of setting an attribute given attr and the context object. Rethrow any exceptions.
</dd>

	<dt>@removeAttributeNode(attr)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeAttributeNode(attr) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%attr ~NIN 此れの`属性0~list$
］
⇒
~THROW `NotFoundError^E
◎
If attr is not in context object’s attribute list, then throw a NotFoundError.
</li>

 <li>
此れから %attr を`除去-$aする
◎
Remove attr from context object.
</li>

 <li>
~RET %attr
◎
Return attr.
</li>
</ol>

	</dd>
</dl>

<dl class="domintro">

	<dt>var %shadow = %element . $attachShadow(init)</dt>
	<dd>
%element に対する`~shadow根$を作成した上で，それを返す。
◎
Creates a shadow root for element and returns it.
</dd>

	<dt>var %shadow = %element . $shadowRoot</dt>
	<dd>
%element の`~shadow根$elm %~shadow は非~NULL，かつ %~shadow の［
`~mode$sR ~EQ `open^l
］ならば %~shadow を返す。
他の場合は ~NULL を返す。
◎
Returns element’s shadow root, if any, and if shadow root’s mode is "open", and null otherwise.
</dl>



<dl class="idl-def">
	<dt>@attachShadow(init)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The attachShadow(init) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
此れの`~ns$ ~NEQ `~HTML~ns$
］
⇒
~THROW `NotSupportedError^E
◎
If context object’s namespace is not the HTML namespace, then throw a NotSupportedError.
</li>
 <li>
<p >
~IF［
此れの`局所名$は 次のいずれにも該当しない
］
⇒
~THROW `NotSupportedError^E：
</p>

<ul ><li>`妥当な~custom要素~名$
</li><li>
`article^l,
`aside^l,
`blockquote^l,
`body^l,
`div^l,
`footer^l,
`h1^l,
`h2^l,
`h3^l,
`h4^l,
`h5^l,
`h6^l,
`header^l,
`nav^l,
`p^l,
`section^l,
`span^l
</li></ul>


◎
If context object’s local name is not a valid custom element name, "article", "aside", "blockquote", "body", "div", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "header", "nav", "p", "section", or "span", then throw a NotSupportedError.
</li>
 <li>
~IF［
此れは`~shadow~host$である
］
⇒
~THROW `InvalidStateError^E
◎
If context object is a shadow host, then throw an InvalidStateError.
</li>
 <li>
<p >
%~shadow ~LET 次のようにされた，新たな`~shadow根$
</p>

<ul ><li>`~node文書$ ~SET 此れの`~node文書$
</li><li>`~host$ ~SET 此れ
</li><li>`~mode$sR ~SET %init の $ShadowRootInit.mode
</li></ul>

◎
Let shadow be a new shadow root whose node document is context object’s node document, host is context object, and mode is init’s mode.
</li>
 <li>
此れの`~shadow根$elm ~SET %~shadow
◎
Set context object’s shadow root to shadow.
</li>
 <li>
~RET %~shadow
◎
Return shadow.
</ol>

	</dd>

	<dt>@shadowRoot</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The shadowRoot attribute’s getter must run these steps:
</p>

<ol>
 <li>
%~shadow ~LET 此れの `~shadow根$elm
◎
Let shadow be context object’s shadow root.
</li>
 <li>
~IF［
%~shadow ~EQ ~NULL
］~OR［
%~shadow の`~mode$sR ~EQ `closed^l
］
⇒
~RET ~NULL
◎
If shadow is null or its mode is "closed", then return null.
</li>
 <li>
~RET %~shadow
◎
Return shadow.
</li>
</ol>

	</dd>
</dl>


<hr>





<dl class="domintro">

 <dt>%element . $closest(selectors)</dt>
 <dd>
%element の`広義先祖$であって,  %selectors に合致するような`要素$が［
在れば，それらのうち %element に最も近いもの ／
無ければ ~NULL
］を返す。
◎
Returns the first (starting at element) inclusive ancestor that matches selectors, and null otherwise.
</dd>

 <dt>%element . $matches(selectors)</dt>
 <dd>
%element の`根$に対し %selectors を照合した結果，［
%element が得られるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if matching selectors against element’s root yields element, and false otherwise.
</dd>

</dl>


<dl class="idl-def">
	<dt>@closest(selectors)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The closest(selectors) method, when invoked, must run these steps:
</p>

<ol>
 <li>
%選択子 ~LET
%selectors を`選択子として解析-$した結果
`SELECTORS4$r
◎
Let s be the result of parse a selector from selectors. [SELECTORS4]
</li>

 <li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError^E
◎
If s is failure, throw a SyntaxError.
</li>

 <li>
%要素~list ~LET 此れの`広義先祖$である`要素$からなる，`木~順序$と逆順による~list
◎
Let elements be context object’s inclusive ancestors that are elements, in reverse tree order.
</li>

 <li>
~FOR
%要素~list 内の ~EACH ( %要素 ) に対し
⇒
~IF［［［
`~scope-ps要素$ ~SET 此れ
］の下で， %要素 に対し %選択子 を`照合-$した結果
`SELECTORS4$r
］ ~EQ success
］
⇒
~RET %要素
◎
For each element in elements, if match a selector against an element, using s, element, and :scope element context object, returns success, return element. [SELECTORS4]
</li>

 <li>
~RET ~NULL
◎
Return null.
</li>

</ol>
	</dd>

	<dt>@matches(selectors)</dt>
	<dt>@webkitMatchesSelector(selectors)</dt>
	<dd>
<p>
これらのいずれも，被呼出時には、次を走らせ~MUST：
◎
The matches(selectors) and webkitMatchesSelector(selectors) methods, when invoked, must run these steps:
</p>

<ol>
 <li>
%選択子 ~LET %selectors を`選択子として解析-$した結果
`SELECTORS4$r
◎
Let s be the result of parse a selector from selectors. [SELECTORS4]
</li>

 <li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError^E
◎
If s is failure, throw a SyntaxError.
</li>

 <li>
~RET ［
`~scope-ps要素$ ~SET 此れ
］の下で， 此れ†に対し %選択子 を`照合-$した結果が［
success ならば~T ／
~ELSE_ ~F
］
`SELECTORS4$r
◎
Return true if the result of match a selector against an element, using s, element, and :scope element context object, returns success, and false otherwise. [SELECTORS4] 
</li>
</ol>

<p class="trans-note">【†<!-- ＊ -->
原文は 2 個目の“此れ” の代わりに~~未定義の変数 “%element” が記されているが、誤記と見られる。
】</p>

	</dd>

	<dt>@getElementsByTagName(qualifiedName)</dt>
	<dd>
被呼出時には、此れに対する， %qualifiedName を`有修飾~名に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagName(qualifiedName) method, when invoked, must return the list of elements with qualified name qualifiedName for the context object.
</dd>

	<dt>@getElementsByTagNameNS(namespace, localName)</dt>
	<dd>
被呼出時には、此れに対する，
( %namespace, %localName )
を
`( ~ns, 局所名 ) に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagNameNS(namespace, localName) method, when invoked, must return the list of elements with namespace namespace and local name localName for context object.
</dd>

	<dt>@getElementsByClassName(classNames)</dt>
	<dd>
被呼出時には、此れに対する，%classNames を`~classesに含む要素の~list$を返さ~MUST。
◎
The getElementsByClassName(classNames) method, when invoked, must return the list of elements with class names classNames for context object.
</dd>
</dl>


<hr>

<p class="algo-head">
文字列 %where が与えられた下で，`~node$ %~node を`要素$ %要素 の
`隣に挿入-@
するときは、 %where を `~ASCII小文字化$した結果に応じて：
◎
To insert adjacent, given an element element, string where, and a node node, run the steps associated with the first ASCII case-insensitive match for where:
</p>

<dl class="switch">
 <dt>`beforebegin^l</dt>
 <dd>
  <ol>
   <li>
~IF［
%要素 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If element’s parent is null, return null.
</li>
   <li>
~RET %要素 の`親$の中で， %~node を %要素 の前に`前挿入$した結果
（例外投出あり）
◎
Return the result of pre-inserting node into element’s parent before element. Rethrow any exceptions.
</li>
  </ol>
 </dd>

 <dt>`afterbegin^l</dt>
 <dd>
  <ol>
   <li>
~RET %要素 の中で， %~node を %要素 の`最初0の子$ の前に`前挿入$した結果
（例外投出あり）
◎
Return the result of pre-inserting node into element before element’s first child. Rethrow any exceptions.
</li>
  </ol>
 </dd>

 <dt>`beforeend^l</dt>
 <dd>
  <ol>
   <li>
~RET %要素 の中で， %~node を ~NULL の前に`前挿入$した結果
（例外投出あり）
◎
Return the result of pre-inserting node into element before null. Rethrow any exceptions.
</li>
  </ol>
 </dd>

 <dt>`afterend^l</dt>
 <dd>
  <ol>
   <li>
~IF［
%要素 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If element’s parent is null, return null.
</li>
   <li>
~RET %要素 の`親$ の中で， %~node を %要素 の`弟$ の前に`前挿入$した結果
（例外投出あり）
◎
Return the result of pre-inserting node into element’s parent before element’s next sibling. Rethrow any exceptions.
</li>
  </ol>
 </dd>

 <dt>その他</dt>
 <dd>
  <ol>
   <li>
~THROW `SyntaxError^E
◎
Throw a SyntaxError.
</li>
  </ol>
 </dd>
</dl>


<dl class="idl-def">
	<dt>@insertAdjacentElement(where, element)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>

<ol>
 <li>
~RET
%where を与える下で， %element を此れの`隣に挿入-$した結果
（例外投出あり）
</li>
</ol>
◎
The insertAdjacentElement(where, element) method, when invoked, must return the result of running insert adjacent, given context object, where, and element. Rethrow any exceptions.
</dd>

	<dt>@insertAdjacentText(where, data)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The insertAdjacentText(where, data) method, when invoked, must run these steps:
</p>

<ol>
 <li>
%text ~LET `新たな~text~node$( %data, 此れの`~node文書$ )
◎
Let text be a new Text node whose data is data and node document is context object’s node document.
</li>
 <li>
%where を与える下で， %text を此れの`隣に挿入-$する
（例外投出あり）
◎
Run insert adjacent, given context object, where, and text. Rethrow any exceptions.
</li>
</ol>
	</dd>
	<dd class="note">注記：
この~methは何も返さない
— それを設計しようとする前からすでに存在していたので。
◎
This method returns nothing because it existed before we had a chance to design it.
</dd>

</dl>


			<section id="interface-namednodemap">
<h4>4.9.1 ~ifc ^@NamedNodeMap</h4>

⇒！
[Exposed=Window, LegacyUnenumerableNamedProperties]
interface @NamedNodeMap {
  ~RA ~UL $length;
  getter $Attr? $item(~UL %index);
  getter $Attr? $getNamedItem(~DS %qualifiedName);
  $Attr? $getNamedItemNS(~DS? %namespace, ~DS %localName);
  [`CEReactions$] $Attr? $setNamedItem($Attr %attr);
  [`CEReactions$] $Attr? $setNamedItemNS($Attr %attr);
  [`CEReactions$] $Attr $removeNamedItem(~DS %qualifiedName);
  [`CEReactions$] $Attr $removeNamedItemNS(~DS? %namespace, ~DS %localName);
};
◎

<p>
各 $NamedNodeMap ~objには、`要素$である
`要素@nm
が結付けられる。
◎
A NamedNodeMap has an associated element (an element).
</p>

<p>
$NamedNodeMap ~objの
`属性0~list@nm
とは、~objの`要素$nmの`属性0~list$である。
◎
A NamedNodeMap object’s attribute list is its element’s attribute list.
</p>

<hr>

<p>
$NamedNodeMap ~objの`被support ~prop~index$の~~範囲は、［
0 〜 ( ~objの`属性0~list$nmに含まれている`属性0$の個数 ~MINUS 1 )
］である（属性0~listが空ならば~~範囲も空）。
◎
A NamedNodeMap object’s supported property indices are the numbers in the range zero to the number of attributes in its attribute list map minus one, unless the attribute list is empty, in which case there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、此れの`属性0~list$nmに含まれている`属性0$の個数を返さ~MUST。
◎
The length attribute’s getter must return the number of attributes in the attribute list.
</dd>

	<dt>@item(index)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The item(index) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%index ~GTE 此れの`属性0~list$nmの長さ
］
⇒
~RET ~NULL
◎
If index is equal to or greater than the number of attributes in the attribute list, return null.
</li>

 <li>
~RET 此れの`属性0~list$nm 内の %index 番の`属性0$
◎
Otherwise, return the indexth attribute in the attribute list.
</li>
</ol>

	</dd>
</dl>

<p>
$NamedNodeMap ~objの`被support ~prop名$は、次の手続きの結果で与えられる：
◎
A NamedNodeMap object’s supported property names are the return value of running these steps:
</p>

<ol>
 <li>
%名前~list ~LET 此れの`属性0~list$nm 内の各［
`属性0$の`有修飾~名$a
］からなる，同順の~list
◎
Let names be the qualified names of the attributes in this NamedNodeMap object’s attribute list, with duplicates omitted, in order.
</li>
 <li>
%要素 ~LET 此れの`要素$nm
◎
↓</li>
 <li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
~FOR
%名前~list 内の ~EACH ( %名前 ) に対し
⇒
~IF［
%名前 の `~ASCII小文字化$ ~NEQ %名前
］
⇒
%名前 を %名前~list から除去する
◎
If this NamedNodeMap object’s element is in the HTML namespace and its node document is an HTML document, then for each name in names, run these substeps:
• Let lowercaseName be name, converted to ASCII lowercase.
• If lowercaseName is not equal to name, remove name from names.
</li>
 <li>
~RET %名前~list
◎
Return names.
</li>
</ol>


<dl class="idl-def">
	<dt>@getNamedItem(qualifiedName)</dt>
	<dd>
被呼出時には、 %qualifiedName を用いて，此れの`要素$nmから`属性0を取得-$した結果を返さ~MUST。
◎
The getNamedItem(qualifiedName) method, when invoked, must return the result of getting an attribute given qualifiedName and element.
</dd>

	<dt>@getNamedItemNS(namespace, localName)</dt>
	<dd>
被呼出時には、
( %namespace, %localName )
を用いて，此れの`要素$nmから`属性0を取得-$nsした結果を返さ~MUST。
◎
The getNamedItemNS(namespace, localName) method, when invoked, must return the result of getting an attribute given namespace, localName, and element.
</dd>

	<dt>@setNamedItem(attr)</dt>
	<dt>@setNamedItemNS(attr)</dt>
	<dd>
これらのいずれも，被呼出時には、 %attr を用いて，此れの`要素$nmの`属性0を設定-$した結果を返さ~MUST（例外投出あり）。
◎
The setNamedItem(attr) and setNamedItemNS(attr) methods, when invoked, must return the result of setting an attribute given attr and element. Rethrow any exceptions.
</dd>

	<dt>@removeNamedItem(qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeNamedItem(qualifiedName) method, when invoked, must run these steps:
</p>

<ol>
 <li>
%属性0 ~LET %qualifiedName を用いて，此れの`要素$nmから`属性0を除去-$した結果
◎
Let attr be the result of removing an attribute given qualifiedName and element.
</li>

 <li>
~IF［
%属性0 ~EQ ~NULL
］
⇒
~THROW `NotFoundError^E
◎
If attr is null, then throw a NotFoundError.
</li>

 <li>
~RET %属性0
◎
Return attr.
</li>
</ol>
	</dd>

	<dt>@removeNamedItemNS(namespace, localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeNamedItemNS(namespace, localName) method, when invoked, must run these steps:
</p>

<ol>
 <li>
%属性0 ~LET
( %namespace, %localName )
を用いて，此れの`要素$nmから`属性0を除去-$nsした結果
◎
Let attr be the result of removing an attribute given namespace, localName, and element.
</li>

 <li>
~IF［
%属性0 ~EQ ~NULL
］
⇒
~THROW `NotFoundError^E
◎
If attr is null, then throw a NotFoundError.
</li>

 <li>
~RET %属性0
◎
Return attr.
</li>
</ol>

	</dd>
</dl>

			</section>
			<section id="interface-attr">
<h4>4.9.2. ~ifc ^@Attr</h4>

⇒！
[Exposed=Window]
interface @Attr : $Node {
  ~RA ~DS? $namespaceURI;
  ~RA ~DS? $prefix;
  ~RA ~DS $localName;
  ~RA ~DS $name;
  [`CEReactions$] attribute ~DS $value;

  ~RA Element? $ownerElement;

  ~RA ~B $specified; // <!--cp-useless-true-->
};
◎

<p>
$Attr `~node$は、単に
`属性0@
とも呼ばれている。
それらは IDL 属性と区別するため、内容属性とも呼ばれる
<span class="trans-note">【この訳では， “°” を付けて “属性0” と記すことにする】</span>
。
◎
Attr nodes are simply known as attributes. They are sometimes referred to as content attributes to avoid confusion with IDL attributes.
</p>


<div>
<p>
各 `属性0$は、次に挙げるものを持つ：
</p>

<ul>
	<li>
`~ns@a
（ ~NULL または 空でない文字列）
</li>
	<li>
`~ns接頭辞@a
（ ~NULL  または 空でない文字列）
</li>
	<li>
`局所名@a
（ 空でない文字列）
</li>
	<li>
`値@a
（文字列）
</li>
	<li>
`属する要素@
（ ~NULL または`要素$）
</li>
</ul>
◎
Attributes have a namespace
(null or a non-empty string), namespace prefix
(null or a non-empty string), local name
(a non-empty string), value
(a string), and element
(null or an element).
</div>

<p class="note">注記：
今 設計するなら、単に［
名前, 値
］のみを持つ様にする所 ☹
◎
If designed today they would just have a name and value. ☹
</p>

<p>
`属性0$ %A の
`有修飾~名@a
とは、［
%A の`~ns接頭辞$a ~EQ ~NULL ならば %A の`局所名$a ／
~ELSE_［
%A の`~ns接頭辞$a, `:^l, %A の`局所名$a
］の並びである。
◎
An attribute’s qualified name is its local name if its namespace prefix is null, and its namespace prefix, followed by ":", followed by its local name, otherwise.
</p>

<!--cp-for-readbility-->

<p>
`属性0$が作成されるときは、その`局所名$aが与えられる。
`属性0$の作成時に明示的に与えられない限り，他のものは次のように設定される
⇒
( `~ns$a, `~ns接頭辞$a, `属する要素$, `値$a )
~SET
( ~NULL, ~NULL, ~NULL, 空文字列 )
◎
When an attribute is created, its local name is given. Unless explicitly given when an attribute is created, its namespace, namespace prefix, and element are set to null, and its value is set to the empty string.
</p>

<p>
文字列 %A に対する
<dfn id="concept-named-attribute">%A 属性0</dfn>
という~~表記は、次のように設定された `属性0$を意味する
⇒
( `局所名$a, `~ns$a, `~ns接頭辞$a )
~SET
( %A, ~NULL, ~NULL )
◎
An A attribute is an attribute whose local name is A and whose namespace and namespace prefix are null.
</p>

<hr>

<dl class="idl-def">
	<dt>@namespaceURI</dt>
	<dd>
取得子は、此れの`~ns$aを返さ~MUST。
◎
The namespaceURI attribute’s getter must return the namespace.
</dd>

	<dt>@prefix</dt>
	<dd>
取得子は、此れの`~ns接頭辞$aを返さ~MUST。
◎
The prefix attribute’s getter must return the namespace prefix.
</dd>

	<dt>@localName</dt>
	<dd>
取得子は、此れの`局所名$aを返さ~MUST。
◎
The localName attribute’s getter must return the local name.
</dd>

	<dt>@name</dt>
	<dd>
取得子は、此れの`有修飾~名$aを返さ~MUST。
◎
The name attribute’s getter must return the qualified name.
</dd>
</dl>


<p class="algo-head">
所与の
( `属性0$ %属性0, 文字列 %値 )
で
`既存の属性0値を設定-@
するときは：
◎
The value attribute’s getter must return the value.
◎
To set an existing attribute value, given an attribute attribute and string value, run these steps:
</p>

<ol>
 <li>
~IF［
%属性0 が`属する要素$ ~EQ ~NULL
］
⇒
%属性0 の`値$a ~SET %値
◎
If attribute’s element is null, then set attribute’s value to value.
</li>
 <li>
~ELSE
⇒
%属性0 が`属する要素$上の %属性0 の`値$aを %値 に`変更-$aする
◎
Otherwise, change attribute from attribute’s element to value. 
</li>
</ol>

<dl class="idl-def">
	<dt>@value</dt>
	<dd>
取得子は、此れの`値$aを返さ~MUST。
◎
↑↑</dd>
	<dd>
設定子は、
( 此れ, 所与の値 )
で`既存の属性0値を設定-$し~MUST。
◎
The value attribute’s setter must set an existing attribute value with context object and the given value.
</dd>

	<dt>@ownerElement</dt>
	<dd>
取得子は、此れが`属する要素$を返さ~MUST。
◎
The ownerElement attribute’s getter must return context object’s element.
</dd>

	<dt>@specified</dt>
	<dd>
取得子は、~T を返さ~MUST。
◎
The specified attribute’s getter must return true.
</dd>
</dl>

			</section>
		</section>
		<section id="interface-characterdata">

<h3>4.10. ~ifc ^@CharacterData</h3>

⇒！
[Exposed=Window]
interface @CharacterData : $Node {
  [TreatNullAs=EmptyString] attribute ~DS $data;
  ~RA ~UL $length;
  ~DS $substringData(~UL %offset, ~UL %count);
  void $appendData(~DS %data);
  void $insertData(~UL %offset, ~DS %data);
  void $deleteData(~UL %offset, ~UL %count);
  void $replaceData(~UL %offset, ~UL %count, ~DS %data);
};
◎

<p class="note">注記：
$CharacterData は抽象~ifcであり，`~node$として存在するものではない。
それは［
$Text, $ProcessingInstruction, $Comment
］`~node$から利用される。
◎
CharacterData is an abstract interface and does not exist as node. It is used by Text, ProcessingInstruction, and Comment nodes.
</p>

<p class="trans-note">【
簡潔に記述するため，この訳では，これらの型の~node（ $Text （ $CDATASection も含む）, $ProcessingInstruction, $Comment ）を総称して
`文字~data~node@
と記すことにする（非公式な用語）。
（機能上は異なるものだが）多くの処理で，これらは同等に扱われるので。
】</p>

<p>
$CharacterData ~ifcを継承する
<span class="trans-note">【~ifcを実装する】</span>
各`~node$には
`~data@
と呼ばれる変異可能な文字列が結付けられる。
◎
Each node inheriting from the CharacterData interface has an associated mutable string called data.
</p>

<p class="algo-head">
( ~offset: %offset, ~count: %count, ~data: %data )
を与える下で，~node %node の
`~dataを置換-@
するときは、次を走らす：
◎
To replace data of node node with offset offset, count count, and data data, run these steps:
</p>

<ol>
 <li id="cp-let-node-length">
%~length ~LET %node の`~length$
◎
Let length be node’s length.
</li>

 <li id="cp-throw-size-err">
~IF［
%offset ~GT %~length
］
⇒
~THROW `IndexSizeError^E
◎
If offset is greater than length, then throw an IndexSizeError.
</li>

 <li>
~IF［
%offset ~PLUS %count ~GT %~length
］
⇒
%count ~LET %~length ~MINUS %offset
◎
If offset plus count is greater than length let count be length minus offset.
</li>

 <li>
%node に対する次の様な `characterData^l の変異~記録を`待入する$
⇒
旧-値: %node の`~data$
◎
Queue a mutation record of "characterData" for node with oldValue node’s data.
</li>

 <li>
%挿入点 ~LET %node の`~data$の中の， %offset 個目の`符号単位$の直後を指す位置（ %offset ~EQ 0 は先頭を指す）
◎
↓</li>

 <li>
%挿入点 から末尾側に位置する %count 個の`符号単位$を除去する
◎
↓</li>

 <li>
%挿入点 に %data を挿入する
◎
Insert data into node’s data after offset code units.
◎
Let delete offset be offset plus the number of code units in data.
◎
Starting from delete offset code units, remove count code units from node’s data.
</li>
 <li>
%差分 ~LET %data に含まれている`符号単位$の個数 ~MINUS %count
◎
↓</li>

 <li>
<p>
~FOR
~EACH ( `範囲0$ %R ) に対し：
◎
↓</p>
  <ol>
   <li>
~IF［
%R の`始点~node$ ~EQ %node
］~AND［
%offset ~LT %R の`始点~offset$ ~LTE %offset ~PLUS %count
］
⇒
%R の`始点~offset$ ~SET %offset
◎
For each range whose start node is node and start offset is greater than offset but less than or equal to offset plus count, set its start offset to offset.
</li>

   <li>
<p>
~IF［
%R の`終点~node$ ~EQ %node
］~AND［
%offset ~LT %R の`終点~offset$ ~LTE %offset ~PLUS %count
］
⇒
%R の`終点~offset$ ~SET %offset
</p>
<p class="trans-note">【
範囲0の終点がちょうど置換される~~範囲の末尾を指している場合も，終点は置換した~~範囲の先頭に “寄せられる” ことになる。
】</p>

◎
For each range whose end node is node and end offset is greater than offset but less than or equal to offset plus count, set its end offset to offset.
</li>

   <li>
~IF［
%R の`始点~node$ ~EQ %node
］~AND［
%R の`始点~offset$ ~GT %offset ~PLUS %count
］
⇒
%R の`始点~offset$ ~INCBY %差分
◎
For each range whose start node is node and start offset is greater than offset plus count, increase its start offset by the number of code units in data, then decrease it by count.
</li>

   <li>
~IF［
%R の`終点~node$ ~EQ %node
］~AND［
%R の`終点~offset$ ~GT %offset ~PLUS %count
］
⇒
%R の`終点~offset$ ~INCBY %差分
◎
For each range whose end node is node and end offset is greater than offset plus count, increase its end offset by the number of code units in data, then decrease it by count.
</li>
  </ol>
 </li>
</ol>

<p class="algo-head">
~node %node から
`~dataの部分文字列@
を得るときは、所与の
( ~offset: %offset, ~count: %count )
に対し，次を走らす：
◎
To substring data with node node, offset offset, and count count, run these steps:
</p>

<p class="trans-note">【
この訳では、
“%node の`~dataの部分文字列$( %offset, %count )”
のように表記する。
】</p>

<ol>
 <!--cp-let-node-length-->
 <!--cp-throw-size-err-->

 <li>
~IF［
%offset ~PLUS %count ~GT %~length
］
⇒
%count ~LET %~length ~MINUS %offset
◎
If offset plus count is greater than length, return a string whose value is the code units from the offsetth code unit to the end of node’s data, and then terminate these steps.
</li>

 <li>
~RET 
%node の`~data$の［
%offset 個目の`符号単位$の直後（ %offset ~EQ 0 なら先頭）から，
%count 個の`符号単位$
］並びからなる文字列
◎
Return a string whose value is the code units from the offsetth code unit to the offset+countth code unit in node’s data.
</li>
</ol>

<dl class="idl-def">
	<dt>@data</dt>
	<dd>
取得子は、此れの`~data$を返さ~MUST。
◎
↓</dd>
	<dd>
設定子は、次を与える下で，此れの`~dataを置換-$し~MUST
⇒
~offset: 0,<br>
~count: 此れの`~length$,<br>
~data: 所与の値
◎
The data attribute’s getter must return context object’s data. Its setter must replace data with node context object, offset 0, count context object’s length, and data new value.
</dd>

	<dt>@length</dt>
	<dd>
取得子は、此れの`~length$を返さ~MUST。
◎
The length attribute’s getter must return context object’s length.
</dd>

	<dt>@substringData(offset, count)</dt>
	<dd>
被呼出時には、此れの`~dataの部分文字列$( %offset, %count )
を返さ~MUST
◎
The substringData(offset, count) method, when invoked, must return the result of running substring data with node context object, offset offset, and count count.
</dd>

	<dt>@appendData(data)</dt>
	<dd>
被呼出時には、次を与える下で，此れの`~dataを置換-$し~MUST
⇒
~offset: 此れの`~length$,<br>
~count: 0,<br>
~data: %data
◎
The appendData(data) method, when invoked, must replace data with node context object, offset context object’s length, count 0, and data data.
</dd>

	<dt>@insertData(offset, data)</dt>
	<dd>
被呼出時には、次を与える下で，此れの`~dataを置換-$し~MUST
⇒
~offset: %offset,<br>
~count: 0,<br>
~data: %data
◎
The insertData(offset, data) method, when invoked, must replace data with node context object, offset offset, count 0, and data data.
</dd>

	<dt>@deleteData(offset, count)</dt>
	<dd>
被呼出時には、次を与える下で，此れの`~dataを置換-$し~MUST
⇒
~offset: %offset,<br>
~count: %count,<br>
~data: 空文字列
◎
The deleteData(offset, count) method, when invoked, must replace data with node context object, offset offset, count count, and data the empty string.
</dd>

	<dt>@replaceData(offset, count, data)</dt>
	<dd>
被呼出時には、次を与える下で，此れの`~dataを置換-$し~MUST
⇒
~offset: %offset,<br>
~count: %count,<br>
~data: %data
◎
The replaceData(offset, count, data) method, when invoked, must replace data with node context object, offset offset, count count, and data data.
</dd>
</dl>

		</section>
		<section id="interface-text">

<h3>4.11. ~ifc ^@Text</h3>

⇒！
[$Constructor(optional ~DS %data = ""),
 Exposed=Window]
interface @Text : $CharacterData {
  [NewObject] $Text $splitText(~UL %offset);
  ~RA ~DS $wholeText;
};
◎

<hr>

<dl class="domintro">
 <dt>var %text = new $Text([data = ""])</dt>
 <dd>
`~data$が %data にされた，新たな $Text `~node$を返す。
◎
Returns a new Text node whose data is data.
</dd>

 <dt>%text . $splitText(offset)</dt>
 <dd>
所与の %offset の地点で`~data$を分割し，残りの部分を $Text `~node$として返す。
◎
Splits data at the given offset and returns the remainder as Text node.
</dd>

 <dt>%text . $wholeText</dt>
 <dd>
隣接するすべての`同胞$ $Text `~node$の`~data$を連結した結果を返す。
◎
Returns the combined data of all direct Text node siblings.
</dd>

</dl>


<hr>

<p>
`新たな~text~node@( %文字列, %文書 )
という表記は、次のように設定された 新たな $Text `~node$を意味する
⇒
( `~data$, `~node文書$ ) ~SET ( %文字列, %文書 )
</p>

<p class="trans-note">【
この表記は、簡潔に記述するため，この訳に導入したものである。
】</p>

<p>
`狭義の~Text0~node@
とは、 $CDATASection `~node$でない $Text `~node$である。
◎
An exclusive Text node is a Text node that is not a CDATASection node.
</p>

<div>
<p>
~node %~node の
`連続的な~Text0~node列@
とは、条件［
$Text `~node$である
］を満たす， %~node の`連続的な同胞~列$である。
</p>

<p>
~node %~node の
`連続的な狭義の~Text0~node列@
とは、条件［
`狭義の~Text0~node$である
］を満たす， %~node の`連続的な同胞~列$である。
</p>

<p class="trans-note">【
和訳では、次の手続きを導入して，原文による “連続的な…” の定義を 全く別の形の, 等価な（かつ平易な）定義に変形している。
】</p>


<p class="algo-head">
条件 %条件 を満たす， %~node の
`連続的な同胞~列@
は、次を走らせた結果で与えられる：
</p>

<ol>
	<li>
~Assert：
%~node は %条件 を満たす
</li>
	<li>
~WHILE［
%~node の`兄$は %条件 を満たす
］
⇒
%~node ~SET %~node の`兄$
</li>
	<li>
%~list ~LET 空~list
</li>
	<li>
<p>
~WHILE［
%~node は %条件 を満たす
］：
</p>
		<ol>
			<li>
%~node を %~list に付加する
</li>
			<li>
%~node ~SET %~node の`弟$
</li>
		</ol>
	</li>
	<li>
~RET %~list
</li>
</ol>

◎
The contiguous Text nodes of a node node are node, node’s previous sibling Text node, if any, and its contiguous Text nodes, and node’s next sibling Text node, if any, and its contiguous Text nodes, avoiding any duplicates.
◎
The contiguous exclusive Text nodes of a node node are node, node’s previous sibling exclusive Text node, if any, and its contiguous exclusive Text nodes, and node’s next sibling exclusive Text node, if any, and its contiguous exclusive Text nodes, avoiding any duplicates.
</div>

<hr>


<dl class="idl-def">
	<dt>@Text(data)</dt>
	<dd>
この構築子の被呼出時には、`新たな~text~node$( %data, `現在の大域~obj$に`結付けられている文書$ )
を返さ~MUST
◎
The Text(data) constructor, when invoked, must return a new Text node whose data is data and node document is current global object’s associated Document.
</dd>
</dl>

<p class="algo-head">
$Text `~node$ %node を
~offset %offset の所で
`分割-@
するときは、次を走らす：
◎
To split a Text node node with offset offset, run these steps:
</p>

<ol>
 <!--cp-let-node-length-->
 <!--cp-throw-size-err-->

 <li>
%count ~LET %~length ~MINUS %offset
◎
Let count be length minus offset.
</li>

 <li>
%新-~data ~LET
此れの`~dataの部分文字列$( %offset, %count )
◎
Let new data be the result of substringing data with node node, offset offset, and count count.
</li>

 <li>
%新-~node ~LET `新たな~text~node$( %新-~data, %node の`~node文書$ )
◎
Let new node be a new Text node, with the same node document as node. Set new node’s data to new data.
</li>

 <li>
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>

 <li>
<p>
~IF［
%親 ~NEQ ~NULL
］：
◎
If parent is not null, run these substeps:
</p>
  <ol>
   <li>
%親 の中で， %新-~node を %node の`弟$の前に`挿入-$する
◎
Insert new node into parent before node’s next sibling.
</li>

   <li>
<p>
~FOR
~EACH ( `範囲0$ %R ) に対し：
◎
↓</p>
    <ol>
     <li>
~IF［
%R の`始点~node$ ~EQ %node
］~AND［
%R の`始点~offset$ ~GT %offset
］
⇒
%R の`始点~node$ ~SET %新-~node；<br>
%R の`始点~offset$ ~DECBY %offset
◎
For each range whose start node is node and start offset is greater than offset, set its start node to new node and decrease its start offset by offset.
</li>

     <li>
~IF［
%R の`終点~node$ ~EQ %node
］~AND［
%R の`終点~offset$ ~GT %offset
］
⇒
%R の`終点~node$ ~SET %新-~node；<br>
%R の`終点~offset$ ~DECBY %offset
◎
For each range whose end node is node and end offset is greater than offset, set its end node to new node and decrease its end offset by offset.
</li>

     <li>
~IF［
%R の`始点~node$ ~EQ %親
］~AND［
%R の`始点~offset$ ~EQ %node の`指数$ ~PLUS 1
］
⇒
%R の`始点~offset$ ~INCBY 1
◎
For each range whose start node is parent and start offset is equal to the index of node + 1, increase its start offset by one.
</li>

     <li>
~IF［
%R の`終点~node$ ~EQ %親
］~AND［
%R の`終点~offset$ ~EQ %node の`指数$ ~PLUS 1
］
⇒
%R の`終点~offset$ ~INCBY 1
◎
For each range whose end node is parent and end offset is equal to the index of node + 1, increase its end offset by one.
</li>
    </ol>
   </li>
  </ol>
 </li>

 <li>
次を与える下で， %node の`~dataを置換-$する
⇒
~offset: %offset,<br>
~count: %count,<br>
~data: 空文字列
◎
Replace data with node node, offset offset, count count, and data the empty string.
</li>

 <li>
<p>
~IF［
%親 ~EQ ~NULL
］
⇒
~FOR
~EACH ( `範囲0$ %R ) に対し：
◎
If parent is null, run these substeps:
</p>

  <ol>
   <li>
~IF［
%R の`始点~node$ ~EQ %node
］~AND［
%R の`始点~offset$ ~GT %offset
］
⇒
%R の`始点~offset$ ~SET %offset
◎
For each range whose start node is node and start offset is greater than offset, set its start offset to offset.
</li>

   <li>
~IF［
%R の`終点~node$ ~EQ %node
］~AND［
%R の`終点~offset$ ~GT %offset
］
⇒
%R の`終点~offset$ ~SET %offset
◎
For each range whose end node is node and end offset is greater than offset, set its end offset to offset.
</li>

  </ol>
 </li>

 <li>
~RET %新-~node
◎
Return new node.
</li>
</ol>

<dl class="idl-def">
	<dt>@splitText(offset)</dt>
	<dd>
被呼出時には、~offset %offset の所で
此れを`分割-$し~MUST。
◎
The splitText(offset) method, when invoked, must split context object with offset offset.
</dd>

	<dt>@wholeText</dt>
	<dd>
取得子は、此れの`連続的な~Text0~node列$ 内の ~EACH ( %text ) の`~data$を
`木~順序$で連結した結果を返さ~MUST。
◎
The wholeText attribute, when invoked, must return a concatenation of the data of the contiguous Text nodes of context object, in tree order.
</dd>
</dl>
		</section>
		<section id="interface-cdatasection">

<h3>4.12. ~ifc ^@CDATASection</h3>

⇒！
[Exposed=Window]
interface @CDATASection : $Text {
};
◎

<!--  -->

		</section>
		<section id="interface-processinginstruction">

<h3>4.13. ~ifc ^@ProcessingInstruction</h3>

⇒！
[Exposed=Window]
interface @ProcessingInstruction : $CharacterData {
  ~RA ~DS $target;
};
◎

<p>
各 $ProcessingInstruction `~node$には
`~target@
が結付けられる。
◎
ProcessingInstruction nodes have an associated target.
</p>

<dl class="idl-def">
	<dt>@target</dt>
	<dd>
取得子は、此れの`~target$を返さ~MUST。
◎
The target attribute must return the target.
</dd>
</dl>

		</section>
		<section id="interface-comment">

<h3>4.14. ~ifc ^@Comment</h3>

⇒！
[$Constructor(optional ~DS %data = ""),
 Exposed=Window]
interface @Comment : $CharacterData {
};
◎

<dl class="domintro">
 <dt>var %comment = new $Comment([data = ""])</dt>
 <dd>
`~data$が %data にされた，新たな $Comment `~node$を返す。
◎
Returns a new Comment node whose data is data.
</dd>
</dl>

<dl class="idl-def">
	<dt>@Comment(data)</dt>
	<dd>
この構築子の被呼出時には、次のように設定された 新たな $Comment `~node$を返さ~MUST
⇒
`~data$ ~SET %data,<br>
`~node文書$ ~SET `現在の大域~obj$に`結付けられている文書$
◎
The Comment(data) constructor, when invoked, must return a new Comment node whose data is data and node document is current global object’s associated Document.
</dd>
</dl>

		</section>
	</section>
	<section id="ranges">

<h2 title="Ranges">5. 範囲0</h2>


		<section id="introduction-to-dom-ranges">

<h3 title="Introduction to “DOM Ranges”">5.1. “DOM Ranges” 概説</h3>

<p>
$Range ~obj （ `範囲0$ ）は`~node木$の中の連続する内容を表現する。
各 `範囲0$ は`境界点$と呼ばれる，`始点$と`終点$を持つ。
各 `境界点$は、
( `~node$, 非負~整数~offset )
の組である。
言い換えれば、`範囲0$は`~node木$の中の２つの`境界点$に挟まれる
`中身@rg
を表現する。
◎
A Range object (range) represents a sequence of content within a node tree. Each range has a start and an end which are boundary points. A boundary point is a tuple consisting of a node and a non-negative numeric offset. So in other words, a range represents a piece of content within a node tree between two boundary points.
</p>

<p>
`範囲0$は、編集における 内容の選択や複製に よく利用される。
例えば 次の`~node木$が与えられたとき：
◎
Ranges are frequently used in editing for selecting and copying content.
</p>

<ul class="domTree">
 <li class="t1">`要素$: `p^e
  <ul>
   <li class="t1">`要素$: `img^e,
<span class="t2">^src=`insanity-wolf^l</span>
<span class="t2">^alt=`Little-endian BOM; decode as big-endian!^l</span>
   </li><li class="t3">$Text:
<samp>&nbsp;CSS 2.1 syndata is&nbsp;</samp>
   </li><li class="t1">`要素$: `em^e
    <ul>
     <li class="t3">$Text: <samp>awesome</samp>
    </li></ul>
   </li><li class="t3">$Text: <samp>!</samp>
  </li></ul>
</li></ul>

<p>
次の様にして，
`syndata is awes^l
の並びを表現する`範囲0$が得られる（変数 %p には `p^e `要素$が, %em には `em^e `要素$が，割当されているとする）：
◎
In the node tree above, a range can be used to represent the sequence “syndata is awes”. Assuming p is assigned to the p element, and em to the em element, this would be done as follows:
</p>

<pre class="js-code">
var %range = new Range(),
    %text1 = %p.childNodes[1],
    %text2 = %em.firstChild
%range.setStart(%text1, 9) // <span class="comment">先頭の空白類も数に入れる</span>
%range.setEnd(%text2, 4)
// <span class="comment">%range を<a href="#dom-range-stringifier">文字列化-</a>した結果は、今や先に示した文字列になる</span>
◎
var range = new Range(),
    firstText = p.childNodes[1],
    secondText = em.firstChild
range.setStart(firstText, 9) // do not forget the leading space
range.setEnd(secondText, 4)
// range now stringifies to the aforementioned quote
</pre>



<p class="note">注記：
`範囲0$は、上の`~node木$の ^src や ^alt などの`属性0$は表現できない。
`範囲0$の概念は`~node$に対してのみ有用になる。
◎
Attributes such as src and alt in the node tree above cannot be represented by a range. The ranges concept is only useful for nodes.
</p>

<p>
範囲0は`~node木$に対する変異に影響される。
その種の変異により`範囲0$が無効化されることはなく，可能なら内容の同じ部分を表現するようにされる。
`範囲0$は、その`中身$rgの一部が変異したときなど、`~node木$に対する変異に伴って，必要に応じて それ自身に~~変更が加えられ得る。
◎
Ranges are affected by mutations to the node tree. Such mutations will not invalidate a range and will try to ensure that the range still represents the same piece of content. Necessarily, a range might itself be modified as part of the mutation to the node tree when e.g. part of the content it represents is mutated.
</p>

<p>
詳細は、
`挿入-$／`除去-$の~algo,
$Node.normalize() ~meth,
`~dataを置換-$ ／ `分割-$の~algo
を見よ。
◎
See the insert and remove algorithms, the normalize() method, and the replace data and split algorithms for the hairy details.
</p>

<p class="trans-note">【
例えば範囲0の境界点が~nodeの “内部” を指していて，その~nodeが木から除去された場合、その境界点は “~nodeが抜けた穴” を指すようにされる（始点と終点が別々の木の中を指さないようにされる）。
始点と終点の両者が同じ~nodeの内部を指していたとしても、除去された~nodeの内部を指すことはなく，範囲0は依然として元の木に結付けられたままにされ、範囲0は，その始点と終点が同じ “穴” を指す様に “畳まれる” ことになる。
】</p>

		</section>
		<section id="interface-range">

<h3>5.2. ~ifc ^@Range</h3>

⇒！
[$Constructor, Exposed=Window]
interface @Range {
  ~RA $Node $startContainer;
  ~RA ~UL $startOffset;
  ~RA $Node $endContainer;
  ~RA ~UL $endOffset;
  ~RA ~B $collapsed;
  ~RA $Node $commonAncestorContainer;

  void $setStart($Node %node, ~UL %offset);
  void $setEnd($Node %node, ~UL %offset);
  void $setStartBefore($Node %node);
  void $setStartAfter($Node %node);
  void $setEndBefore($Node %node);
  void $setEndAfter($Node %node);
  void $collapse(optional ~B %toStart = false);
  void $selectNode($Node %node);
  void $selectNodeContents($Node %node);

  ~CUS @START_TO_START = 0;
  ~CUS @START_TO_END = 1;
  ~CUS @END_TO_END = 2;
  ~CUS @END_TO_START = 3;
  short $compareBoundaryPoints(~US %how, $Range %sourceRange);

  [`CEReactions$] void $deleteContents();
  [`CEReactions$, NewObject] $DocumentFragment $extractContents();
  [`CEReactions$, NewObject] $DocumentFragment $cloneContents();
  [`CEReactions$] void $insertNode($Node %node);
  [`CEReactions$] void $surroundContents($Node %newParent);

  [NewObject] $Range $cloneRange();
  void $detach();

  ~B $isPointInRange($Node %node, ~UL %offset);
  short $comparePoint($Node %node, ~UL %offset);

  ~B $intersectsNode($Node %node);

  $stringifier;
};
◎

<p>
$Range ~objは単に
`範囲0@
（ “DOM range”, “~~範囲~obj” ）とも呼ばれている。
◎
Range objects are simply known as ranges.
</p>

<p class="trans-note">【
一般語の “~~範囲” と区別し易くするため、この訳では， “°” を付けて “範囲0” と記すことにする。
】【
各 `範囲0$は、その作成-時からずっと，同じある`~node木$に結付けられ続ける。
仕様には明示的にそう述べられてはいないが、各種~algoの挙動から，そう結論できる。
】</p>

<p>
`境界点@
とは、［
`~node$と, 非負~整数である
`~offset@
］の組である。
<!--  object ではなく複合値 -->
◎
A boundary point is a (node, offset) tuple, where offset is a non-negative integer.
</p>

<p class="trans-note">【
以下では，
“( %node, %offset )”
の様に括弧で括って記される。
】</p>

<p class="note">注記：
一般に，`境界点$の`~offset$は［
0 〜 `境界点$の`~node$の`~length$
］の~~範囲に入る。
`木$を改変する~algo（特に，
`挿入-$, `除去-$, `~dataを置換-$, `分割-$
）は、その`木$に結付けられている一連の`範囲0$も改変する。
◎
Generally speaking, a boundary point’s offset will be between zero and the boundary point’s node length, inclusive. Algorithms that modify a tree (in particular the insert, remove, replace data, and split algorithms) also modify ranges associated with that tree.
</p>

<div class="trans-note">
<p>【
~HTMLや~XMLの~source~textの中では、境界点は，すべての~text~data（`文字~data~node$）を “仮想の” 開始／終了 ~tagで括り, すべての空~要素は 開始／終了 ~tagの組に置換した上で、［各~tag, および文字~dataの各~文字］の一個一個を点に見立てて，~sourceに現れる順に一列に並べたときの，隣接する２つの点の隙間を指すものと見なせる。
</p>

<p>
従って，例えば
"<samp>&lt;b&gt;text&lt;/b&gt;</samp>"
のような~markupの中の，［
開始~tag "<samp>&lt;b&gt;</samp>"
］と［
"<samp>text</samp>" の先頭
］との隙間を指す境界点には、
"<samp>text</samp>" ~node の［
内側（“仮想の”~tagの内側）を指すもの, および
外側を指すもの
］があり、また，境界点は［
"<samp>&lt;br&gt;</samp>"
のような空~tag ／
~dataが空の`文字~data~node$
］の内部も指し得る†。
</p>

<p>†
唯一の~~例外は，`文書型$であり、境界点は文書型の内部は<a href="#concept-range-bp-set">指し得ない</a>ようにされている
— したがってこの~modelでは，一個の “点” になる。
</p>

<p>
文書の~node木の一例とそのすべての境界点を示す模式図を次に示す。
縦棒  "|" が境界点が指し得る位置を表し，ドット "." が文字~dataの各~文字を表す（
<a href="#example-tree" style="text-decoration:underline">先掲の模式図</a>
同様，左端が文書の先頭, 右端が文書の末尾，横線は木の中の各 ~nodeが文書~内を占める~~範囲を表し，~COLOR_Rは`文字~data~node$を表す）：
</p>

`[|*|(|A)|[|[|B]|(|.|)|C(|.|.|)|[|(|.|)|]|[|]|(|.|.|)|[x|0(|.|)|1[|(|.|)|]|2[|(|.|.|.|)|[|(|.|)|]|]|3(|.|.|)|4]|]|(|.|.|)|]^bpex

<p>
境界点を表す縦棒の直上の横線がその境界点の~nodeを表す。
境界点の~offsetは、図の中では，その境界点を表す縦棒の直上の横線直下にあって, その縦棒より左側に位置する縦棒の本数になる（境界点の~nodeが図の~COLOR_Xならば、その直下の各数字がその境界点の~offset）。
</p>

<p>
図の先頭の `*^c は`文書型$を表す（内部に境界点は存在しない）。
その次の孤立した `A^c は~dataが空の`文字~data~node$の内部を指す（唯一の）境界点を表し，その次の `B^c は内容が空の要素の内部を指す境界点を表し，~~後続の 2 個の~COLOR_Rは 2 個の`文字~data~node$が境界点（ `C^c ）を挟んで間を置かずに連続していることを表している。
】</p>

</div>

<p class="algo-head">
2 つの<!-- nodeからなる --> `境界点$
%A = (%node-A, %offset-A) と %B = (%node-B, %offset-B) が同じ `根$rgを持つとき、%B に相対的な %A の
`位置bp@ 
は次の~algoの返値に従って
`前bp@,
`等bp@,
`後bp@,
のいずれかになる：
◎
If the two nodes of boundary points (node A, offset A) and (node B, offset B) have the same root, the position of the first relative to the second is either before, equal, or after, as returned by the following algorithm:
</p>

<p class="trans-note">【
この~algoは２つの境界点に対し，上の模式図における位置関係（左側が “前” ）を算出するものになる。
前／後の関係については、 “ %A は%B <em><b>より</b></em> `前bp$ ／ `後bp$ ” とも記す。
】</p>

<ol>
 <li>
~IF［
%node-A ~EQ %node-B
］
⇒
~RET ［
%offset-A ~EQ %offset-B ならば `等bp$ ／
%offset-A ~LT %offset-B ならば `前bp$ ／
%offset-A ~GT %offset-B ならば `後bp$
］
◎
If node A is the same as node B, return equal if offset A is the same as offset B, before if offset A is less than offset B, and after if offset A is greater than offset B.
</li>

 <li>
~IF［
%node-A は %node-B に`後続-$する
］
⇒
~RET 
%A に相対的な %B の`位置bp$が［
`前bp$ならば `後bp$ ／ `後bp$ならば `前bp$
］
<!-- bp等0にはならない -->
◎
If node A is following node B, compute the position of (node B, offset B) relative to (node A, offset A). If it is before, return after. If it is after, return before.
</li>

 <li>
<p>
~IF［
%node-A ~AN %node-B
］：
◎
If node A is an ancestor of node B:
</p>
  <ol>
   <li>
%子 ~LET %node-B
◎
Let child equal node B.
</li>

   <li>
~WHILE［
%子 の`親$ ~NEQ %node-A
］
⇒
%子 ~SET %子 の`親$
◎
While child is not a child of node A, set child to its parent.
</li>

   <li>
~IF［
%子 の`指数$ ~LT %offset-A
］
⇒
~RET `後bp$
◎
If the index of child is less than offset A, return after.
</li>

  </ol>
 </li>

 <li>
~RET `前bp$
◎
Return before.
</li>
</ol>

<p>
各 `範囲0$には 2 個の`境界点$ — 
`始点@
と
`終点@
— が結付けられる。
◎
Each range has two associated boundary points — a start and end.
</p>

<div class="p">
<p>
便宜のため：
</p>

<ul>
	<li>
(
`始点~node@,
`始点~offset@
) は、順に，`始点$の
( `~node$, `~offset$ )
を指すとする。
</li>
	<li>
(
`終点~node@,
`終点~offset@
) は、順に，`終点$の
( `~node$, `~offset$ )
を指すとする。
</li>
</ul>


◎
For convenience, start node is start’s node, start offset is start’s offset, end node is end’s node, and end offset is end’s offset.
</div>

<p>
`範囲0$の
`根@rg
とは、その`始点~node$の`根$である。
◎
The root of a range is the root of its start node.
</p>

<p class="trans-note">【
`終点~node$の`根$と同じになる（常にそうなるように拘束される）。
】</p>

<p>
所与の`範囲0$ %範囲0 に対し：
◎
↓</p>

<ul>
	<li>
<p>
次のいずれも満たす`~node$ %node は、 %範囲0 に
`被包含@
であるとされる：
</p>
<ul ><li>%node の`根$ ~EQ %範囲0 の`根$rg
</li><li>(%node, 0) は %範囲0 の`始点$より `後bp$
</li><li>(%node, %node の`~length$) は %範囲0 の`終点$より `前bp$
</li></ul>

◎
A node node is contained in a range range if node’s root is the same as range’s root, and (node, 0) is after range’s start, and (node, length of node) is before range’s end.
</li>

	<li>
<p>
次のいずれかを満たす`~node$ %node は、 %範囲0 に
`半被包含@
であるとされる：
</p>

<ul><li>
［
%node ~iAN %範囲0 の`始点~node$
］~AND ［
%node ~iAN %範囲0 の`終点~node$ でない
］
</li><li>
［
%node ~iAN %範囲0 の`始点~node$ でない
］~AND［
%node ~iAN %範囲0 の`終点~node$
］
</li></ul>
◎
A node is partially contained in a range if it is an inclusive ancestor of the range’s start node but not its end node, or vice versa.
</li>
</ul>


<div class="trans-note">
<p>【
次の図は前掲の模式図と同様に木を表したものであり，図の記号 `s^c が始点, `e^c が終点を表すとする。
このとき、図の~COLOR_Xの~nodeが被包含, ~COLOR_Yの~node（始点／終点の一方のみを内部に含む~node）が半被包含になる。
最上層の横線の~nodeは  `s^c, `e^c いずれも含むので、~~定義により，半被包含にはならない。
】</p>

`[|(|.|)|[|]|[y|(y|.|.|s)|]|[x|(x|.|)|]|(x|.|.|.|)|[x|]|(x|.|.|)|[y|(x|.|)|[x|(x|.|)|]|[y|(y|.|.|e.|)|[|(|.|)|]|]|(|.|.|)|]|]^bpex

</div>

<div class="note">
<p>
これらの定義をより理解し易くする事実をいくつか挙げる：
◎
Some facts to better understand these definitions:
</p>

<ul>
 <li>
`範囲0$の`中身$rgは、すべての`被包含$`~node$に加えて，範囲0に入る部分の［［
`始点~node$と`終点~node$
］の内容であって, `文字~data~node$からなるもの
］からなるものとみなせる。
◎
The content that one would think of as being within the range consists of all contained nodes, plus possibly some of the contents of the start node and end node if those are Text, ProcessingInstruction, or Comment nodes.
</li>

 <li>
`範囲0$に`被包含$なる`~node$の集合は、`被包含$`~node$の`親$が常に`被包含$であるとは限らないので，一般に連続的でない。
◎
The nodes that are contained in a range will generally not be contiguous, because the parent of a contained node will not always be contained.
</li>

 <li>
しかしながら，`被包含$`~node$の`子孫$は`被包含$であり、２つの`同胞$が`被包含$であるならば，それらの間に位置するどの`同胞$も`被包含$である。
◎
However, the descendants of a contained node are contained, and if two siblings are contained, so are any siblings that lie between them.
</li>

 <li>
`範囲0$の`始点~node$ と`終点~node$ は決して その範囲0に`被包含$にはならない。
◎
The start node and end node of a range are never contained within it.
</li>

 <li>
最初の`被包含$`~node$（もし在れば）は、常に`始点~node$に`後続-$する。
最後の`被包含$`~node$は、常に`終点~node$の最後の`子孫$と同じか, それに`先行-$する。
<!-- descendant を持たない場合は？ -->
◎
The first contained node (if there are any) will always be after the start node, and the last contained node will always be equal to or before the end node’s last descendant.
</li>


 <li>
半被包含`~node$が存在するのは、`始点~node$ と`終点~node$ が異なるとき, そのときに限る。
◎
There exists a partially contained node if and only if the start node and end node are different.
</li>

 <li>
`始点~node$と`終点~node$の`共通の広義先祖$は、`被包含$にも, `半被包含$にもならない。
◎
The commonAncestorContainer attribute value is neither contained nor partially contained.
</li>

 <li>
<p>
`始点~node$ ~AN `終点~node$
の場合、`始点~node$が，それらに`共通の広義先祖$になる。
その`子$のうち， 1 つだけ（ %c とする）が`半被包含$になる。
このとき，別の`子$ %c1 が`被包含$になるのは、
%c1 が %c に`先行-$するとき, そのときに限る。
`終点~node$ ~AN `始点~node$ である場合はその逆になる。
◎
If the start node is an ancestor of the end node, the common inclusive ancestor will be the start node. Exactly one of its children will be partially contained, and a child will be contained if and only if it precedes the partially contained child. If the end node is an ancestor of the start node, the opposite holds.
</p>

<div class="trans-note">
<p>【
始点~node ~AN 終点~nodeの場合の例。
前と同様，記号 `s^c は始点, `e^c は終点を表す。
この例では図の最上層の~nodeが共通の広義先祖になる。
共通の広義先祖の子のうち、~COLOR_Yの~nodeが上述の %c （共通の広義先祖の子であってかつ半被包含）に該当し，~COLOR_Xの~nodeが被包含の子になる。
（終点~node ~AN 始点~nodeの場合は `s^c と `e^c を入れ替えて，右端から木の順序が開始されていると考えるとよい。）
】</p>

`[|(|.|)|s[x|(|.|)|]|(x|.|.|)|[x|(|.|.|)|]|[y|[|(|.|)|]|(|.|.|e.|)|[|(|.|)|]|]|(|.|.|)|]^bpex

</div>

 </li>
 <li>
`始点~node$ ~iAN `終点~node$ でも, その逆（ ~iDE ）でもない場合、それらの`共通の広義先祖$ %c はいずれの~nodeとも異なるものになる。
このとき、 %c の`子$のうち，ちょうど 2 個が`半被包含$になり、
%c の`子$が`被包含$になるのは，それら 2 個の間に位置するとき, そのときに限る。
◎
If the start node is not an inclusive ancestor of the end node, nor vice versa, the common inclusive ancestor will be distinct from both of them. Exactly two of its children will be partially contained, and a child will be contained if and only if it lies between those two.
</li>

</ul>
</div>


<hr>

<dl class="domintro">
 <dt>var %range = new $Range()</dt>
 <dd>
新たな`範囲0$を返す。
◎
Returns a new range.
</dd>
</dl>

<dl class="idl-def">
	<dt>@Range()</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
</p>

<ol>
	<li>
%文書 ~LET `現在の大域~obj$に`結付けられている文書$
</li>
	<li>
~RET 次のように設定された 新たな $Range
⇒
`始点$ ~SET ( %文書, 0 ) ,<br>
`終点$ ~SET ( %文書, 0 )
</li>
</ol>

◎
The Range() constructor, when invoked, must return a new range with (current global object’s associated Document, 0) as its start and end.
</dd>
</dl>


<dl class="domintro">
 <dt>%node = %range . $startContainer</dt>
 <dd>
%range の`始点~node$を返す。
◎
Returns range’s start node.
</dd>

 <dt>%offset = %range . $startOffset</dt>
 <dd>
%range の`始点~offset$を返す。
◎
Returns range’s start offset.
</dd>

 <dt>%node = %range . $endContainer</dt>
 <dd>
%range の`終点~node$を返す。
◎
Returns range’s end node.
</dd>

 <dt>%offset = %range . $endOffset</dt>
 <dd>
%range の`終点~offset$を返す。
◎
Returns range’s end offset.
</dd>

 <dt>%collapsed = %range . $collapsed</dt>
 <dd>
%range の`始点$と`終点$が同じ場合は~T を,
他の場合は~F を返す。
◎
Returns true if range’s start and end are the same, and false otherwise.
</dd>

 <dt>%container = %range . $commonAncestorContainer</dt>
 <dd>
%range の`始点~node$と`終点~node$の両方の`広義先祖$であるような，最も末端の~nodeを返す。
<span class="trans-note">【原文の “ancestor” （先祖）は~~厳密な記述ではない。】</span>
◎
Returns the node, furthest away from the document, that is an ancestor of both range’s start node and end node.
</dd>
</dl>

<dl class="idl-def">
	<dt>@startContainer</dt>
	<dd>
取得子は、此れの`始点~node$を返さ~MUST。
◎
The startContainer attribute’s getter must return the start node.
</dd>

	<dt>@startOffset</dt>
	<dd>
取得子は、此れの`始点~offset$を返さ~MUST。
◎
The startOffset attribute’s getter must return the start offset.
</dd>

	<dt>@endContainer</dt>
	<dd>
取得子は、此れの`終点~node$を返さ~MUST。
◎
The endContainer attribute’s getter must return the end node.
</dd>

	<dt>@endOffset</dt>
	<dd>
取得子は、此れの`終点~offset$を返さ~MUST。
◎
The endOffset attribute’s getter must return the end offset.
</dd>

	<dt>@collapsed</dt>
	<dd>
取得子は、［
此れの`始点$ ~EQ `終点$ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The collapsed attribute’s getter must return true if start is the same as end, and false otherwise.
</dd>

	<dt>@commonAncestorContainer</dt>
	<dd>
取得子は、此れの
( `始点~node$, `終点~node$ )
の`共通の広義先祖$を返さ~MUST。
◎
The commonAncestorContainer attribute’s getter must run these steps: 
• Let container be start node.
• While container is not an inclusive ancestor of end node, let container be container’s parent.
• Return container.
</dd>
</dl>

<div>
<p class="algo-head">
<span class="trans-note">【この訳では便宜のため，次を定義する：】</span>
同じ木に関与する２つの~node %A, %B の（最も末端の）
`共通の広義先祖@
とは、次の~algoを走らせた結果である：
</p>

<ol>
 <li>
~WHILE［
%A ~iAN %B でない
］
⇒
%A ~SET %A の`親$
</li>
 <li>
~RET %A
</li>
</ol>

◎
↑</div>

<hr>

<p class="trans-note">【
次のブロックは、原文には存在しない，この訳による補完。
ブロックにて挙げる各種~methは、範囲0の片方または両方の境界点を新たな地点に変更する。
片方の境界点（以下， %P ）のみを変更する~methについては、整合性を保つため，もう片方の境界点（以下， %Q ）も必要に応じて~~正される：
すなわち， %Q が［
%P と異なる木の中に位置する, または
%P より［
前bp（始点が変更された場合） ／
後bp（終点が変更された場合）
］に位置する
］ようになった場合、 %P と同じ地点にされる（ 範囲0は “畳まれる” ）。
】</p>

<dl class="domintro">

 <dt>%range . $setStart(node, offset)</dt>
 <dt>%range . $setEnd(node, offset)</dt>
 <dd>
それぞれ，始点／終点を 境界点 (%node, %offset) と同じ位置にする。
</dd>
 <dd>
%node が`文書型$である場合，
`InvalidNodeTypeError^E 例外が投出される。
他の場合，
%offset が %node の`~length$を超えている場合，
`IndexSizeError^E 例外が投出される。
</dd>

 <dt>%range . $setStartBefore(node)</dt>
 <dt>%range . $setStartAfter(node)</dt>
 <dd>
それぞれ，始点を %node の外側の［
始端（下図の `S^c ）／終端（下図の `E^c ）
］に位置させる。
</dd>
 <dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError^E 例外が投出される。
</dd>

 <dt>%range . $setEndBefore(node)</dt>
 <dt>%range . $setEndAfter(node)</dt>
 <dd>
それぞれ，終点を %node の外側の［
始端（下図の `S^c ）／終端（下図の `E^c ）
］に位置させる。
</dd>
 <dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError^E 例外が投出される。
</dd>

 <dd class="trans-note">
（説明用の図式
— %node 引数が，図の~COLOR_Yが表す~nodeに対応しているとする。）


`[|(|.|)|[|(|.|)|S[y|s[|(|.|)|]|(|.|.|.|)|[|]|e]|E(|.|.|)|]|]^bpex

</dd>

 <dt>%range . $collapse(toStart)</dt>
 <dd>
範囲0を “畳む”。
%toStart が~T の場合は 終点を始点と同じ地点に位置させ，他の場合は 始点を終点と同じ地点に位置させる。
</dd>

 <dt>%range . $selectNode(node)</dt>
 <dd>
%node を “選択-” する。
すなわち，始点と終点を %node の外側の両端（上図の `S^c, `E^c ）に位置させる。
</dd>
 <dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError^E 例外が投出される。
</dd>

 <dt>%range . $selectNodeContents(node)</dt>
 <dd>
%node の内容を “選択-” する。
すなわち，始点と終点を %node の内側の両端（上図の `s^c, `e^c ）に位置させる。
</dd>
 <dd>
%node が`文書型$である場合，
`InvalidNodeTypeError^E 例外が投出される。
</dd>

 <dt>%range . $compareBoundaryPoints(how, sourceRange)</dt>
 <dd>
%range の始点または終点（ %how により指示される）が，
%sourceRange の始点または終点（ %how により指示される）に比して［
`前bp$, `等bp$, `後bp$
］のいずれに位置bpするかに応じて、［
−1, 0, 1
］を返す。
 </dd>

 <dd lang="en"><!-- for del_j --></dd>
</dl>


<p class="algo-head">
%範囲0 の
始点／終点
に，`境界点$ (%node, %offset) を
`設定bp@
するときは、次を走らす：
◎
To set the start or end of a range to a boundary point (node, offset), run these steps:
</p>

<ol>
 <li id="cp-throw-if-doctype">
~IF［
%node は`文書型$である
］
⇒
~THROW `InvalidNodeTypeError^E
◎
If node is a doctype, then throw an InvalidNodeTypeError.
</li>

 <li id="cp-throw-if-length">
~IF［
%offset ~GT %node の`~length$
］
⇒
~THROW `IndexSizeError^E
◎
If offset is greater than node’s length, then throw an IndexSizeError.
</li>

 <li>
%境界点 ~LET `境界点$ (%node, %offset)
◎
Let bp be the boundary point (node, offset).
</li>

 <li>
  <dl class="switch">
   <dt>
“始点に設定する” 場合
◎
If these steps were invoked as "set the start"
</dt>
   <dd>
    <ol>
     <li>
~IF［
%境界点 は %範囲0 の`終点$より `後bp$
］~OR［
%範囲0 の`根$rg ~NEQ %node の`根$
］
⇒
%範囲0 の`終点$ ~SET %境界点
◎
If bp is after the range’s end, or if range’s root is not equal to node’s root, set range’s end to bp.
</li>

     <li>
%範囲0 の`始点$ ~SET %境界点
◎
Set range’s start to bp.
</li>

    </ol>
   </dd>

   <dt>
“終点に設定する” 場合
◎
If these steps were invoked as "set the end"
</dt>
   <dd>
    <ol>
     <li>
~IF［
%境界点 は %範囲0 の`始点$より `前bp$
］~OR［
%範囲0 の`根$rg ~NEQ %node の`根$
］
⇒
%範囲0 の`始点$ ~SET %境界点
◎
If bp is before the range’s start, or if range’s root is not equal to node’s root, set range’s start to bp.
</li>

     <li>
%範囲0 の`終点$ ~SET %境界点
◎
Set range’s end to bp.
</li>

    </ol>
   </dd>
  </dl>
 </li>
</ol>

<dl class="idl-def">
	<dt>@setStart(node, offset)</dt>
	<dd>
被呼出時には、此れの始点に，`境界点$ (%node, %offset) を`設定bp$し~MUST。
◎
The setStart(node, offset) method, when invoked, must set the start of context object to boundary point (node, offset).
</dd>

	<dt>@setEnd(node, offset)</dt>
	<dd>
被呼出時には、此れの終点に，`境界点$ (%node, %offset) を`設定bp$し~MUST。
◎
The setEnd(node, offset) method, when invoked, must set the end of context object to boundary point (node, offset).
</dd>

	<dt>@setStartBefore(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setStartBefore(node) method, when invoked, must run these steps: 
</p>

<ol>
 <li id="cp-let-parent">
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>

 <li id="cp-throw-if-null">
~IF［
%親 ~EQ ~NULL
］
⇒
~THROW `InvalidNodeTypeError^E
◎
If parent is null, then throw an InvalidNodeTypeError.
</li>

 <li>
此れの始点に，`境界点$ (%親, %node の`指数$) を`設定bp$する
◎
Set the start of the context object to boundary point (parent, node’s index).
</li>
</ol>
	</dd>

	<dt>@setStartAfter(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setStartAfter(node) method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-let-parent-->
 <!--cp-throw-if-null-->

 <li>
此れの始点に，`境界点$ (%親, %node の`指数$ ~PLUS 1) を`設定bp$する
◎
Set the start of the context object to boundary point (parent, node’s index plus one).
</li>
</ol>
	</dd>

	<dt>@setEndBefore(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setEndBefore(node) method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-let-parent-->
 <!--cp-throw-if-null-->

 <li>
此れの終点に，`境界点$ (%親, %node の`指数$) を`設定bp$する
◎
Set the end of the context object to boundary point (parent, node’s index).
</li>

</ol>
	</dd>

	<dt>@setEndAfter(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setEndAfter(node) when invoked, method must run these steps:
</p>

<ol>
 <!--cp-let-parent-->
 <!--cp-throw-if-null-->

 <li>
此れの終点に，`境界点$ (%親, %node の`指数$ ~PLUS 1) を`設定bp$する
◎
Set the end of the context object to boundary point (parent, node’s index plus one).
</li>
</ol>
	</dd>

	<dt>@collapse(toStart)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>

<ol>
	<li>
~IF［
%toStart ~EQ ~T
］
⇒
`終点$ ~SET `始点$
</li>
	<li>
~ELSE
⇒
`始点$ ~SET `終点$
</li>
</ol>
◎
The collapse(toStart) method, when invoked, must if toStart is true, set end to start, and set start to end otherwise.
</dd>

</dl>

<p class="algo-head">
`~node$ %node を，`範囲0$ %範囲0 の
`中身として選択-@rg
するときは、次を走らす：
◎
To select a node node within a range range, run these steps:
</p>

<ol>
 <!--cp-let-parent-->
 <!--cp-throw-if-null-->

 <li>
%index ~LET %node の`指数$
◎
Let index be node’s index.
</li>

 <li>
%範囲0 の`始点$ ~SET `境界点$ (%親, %index)
◎
Set range’s start to boundary point (parent, index).
</li>

 <li>
%範囲0 の`終点$ ~SET `境界点$ (%親, %index ~PLUS 1)
◎
Set range’s end to boundary point (parent, index plus one).
</li>
</ol>

<dl class="idl-def">
	<dt>@selectNode(node)</dt>
	<dd>
被呼出時には、 %node を，此れの`中身として選択-$rgし~MUST。
◎
The selectNode(node) method, when invoked, must select node within context object.
</dd>

	<dt>@selectNodeContents(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The selectNodeContents(node) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%node は`文書型$である
］
⇒
~THROW `InvalidNodeTypeError^E
◎
If node is a doctype, then throw an InvalidNodeTypeError.
</li>

 <li>
%~length ~LET %node の`~length$
◎
Let length be the length of node.
</li>

 <li>
此れの`始点$ ~SET `境界点$ (%node, 0)
◎
Set start to the boundary point (node, 0).
</li>

 <li>
此れの`終点$ ~SET `境界点$ (%node, %~length)
◎
Set end to the boundary point (node, length).
</li>
</ol>

	</dd>

	<dt>@compareBoundaryPoints(how, sourceRange)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The compareBoundaryPoints(how, sourceRange) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%how ~NIN {
$START_TO_START,
$START_TO_END,
$END_TO_END,
$END_TO_START
}
］
⇒
~THROW `NotSupportedError^E
◎
If how is not one of
• START_TO_START
• START_TO_END
• END_TO_END
• END_TO_START
◎
then throw a NotSupportedError.
</li>

 <li>
~IF［
此れの`根$rg ~NEQ %sourceRange の`根$rg
］
⇒
~THROW `WrongDocumentError^E
◎
If context object’s root is not the same as sourceRange’s root, then throw a WrongDocumentError.
</li>

 <li>
<p>
%how に応じて：
◎
If how is:
</p>
  <dl class="switch">
   <dt>$START_TO_START:</dt>
   <dd>
%基準点 ~LET %sourceRange の`始点$；<br>
%相対点 ~LET 此れの`始点$
◎
Let this point be the context object’s start. Let other point be sourceRange’s start.
</dd>

   <dt>$START_TO_END:</dt>
   <dd>
%基準点 ~LET %sourceRange の`始点$；<br>
%相対点 ~LET 此れの`終点$
◎
Let this point be the context object’s end. Let other point be sourceRange’s start.
</dd>

   <dt>$END_TO_END:</dt>
   <dd>
%基準点 ~LET %sourceRange の`終点$；<br>
%相対点 ~LET 此れの`終点$
◎
Let this point be the context object’s end. Let other point be sourceRange’s end.
</dd>

   <dt>$END_TO_START:</dt>
   <dd>
%基準点 ~LET %sourceRange の`終点$；<br>
%相対点 ~LET 此れの`始点$
◎
Let this point be the context object’s start. Let other point be sourceRange’s end.
</dd>
  </dl>
 </li>

 <li>
~RET ［
%基準点 に相対的な %相対点 の`位置bp$
］に応じて
⇒
［
%基準点 より `前bp$ ならば ~MINUS 1 ／
%基準点 と `等bp$ ならば 0 ／
%基準点 より `後bp$ ならば 1
］
◎
If the position of this point relative to other point is
◎
before
• Return −1.
◎
equal
• Return 0.
◎
after
• Return 1.
</li>
</ol>

</dd>

</dl>

<!-- ^@Range -->

<p class="trans-note">【
次のブロックは、原文には存在しない，この訳による補完。
ブロックにて挙げる各種~methは、主に，範囲0の`中身$rgを操作する。
】</p>

<dl class="domintro">
 <dt>%range . $deleteContents()</dt>
 <dd>
`範囲0$の`中身$rgを削除した上で、範囲0の`境界点$を “畳む”。
</dd>
 <dd>
<p>
`deleteContents()^c の実行例。
図の記号［
`s^c, `e^c
］が順に範囲の［
始点, 終点
］を表すとするとき、図左の~~状態から図右の~~状態になる。
被包含~node（図の ~COLOR_X ）, および
始点／終点~nodeの文字~dataのうち 範囲0に入る部分の文字（図の `+^c ）が除去される。
半被包含~node（図の ~COLOR_Y ）は除去されない。
この例では、始点 `s^c が指す`文字~data~node$は，~dataは空になるが~node自体は残される。
図右の `S^c, `E^c が元の始点, 終点に対応する位置であるが、実行後の始点と終点は，図右の `X^c （共通の広義先祖の直下）を指すようにされることに注意（範囲0は “畳まれる” ）。
始点~node ~iAN 終点~node であった場合、始点の位置は変化しない。
始点~node ~iDE 終点~node であった場合、全体の終端（右端）から相対的な終点の位置は変化しない。
</p>

`[|[|]|[y|(y|s+|)|]|[x|(|.|)|]|[y|(x|.|)|[y|(y|+|+|e.|)|[|]|]|(|.|)|]|] → [|[|]|[y|(y|S)|]|X[y|[y|(y|E.|)|[|]|]|(|.|)|]|]^bpex

</dd>

 <dt>%range . $extractContents()</dt>
 <dd>
`範囲0$の`中身$rgを~cloneした結果を返すと同時に，中身は削除する（ “カット” ）。
機能的には
$cloneContents() と $deleteContents()
の組み合わせと同等になる。
</dd>

 <dt>%range . $cloneContents()</dt>
 <dd>
`範囲0$の`中身を~clone$rgした結果を返す。
返される`中身$rgは、新たな`文書片$で包装される。
</dd>
 <dd>
<p>
^cloneContents() の実行例。
図左の記号［
`s^c, `e^c
］が順に範囲の［
始点, 終点
］を表すとするとき、その間に挟まれた部分の~cloneが図右に示すように得られる（ `S^c, `E^c が元の始点と終点に対応する位置）。
図の~COLOR_Yの 2 個の~nodeが，範囲の`半被包含$の子。
入れ物にあたる それらの`共通の広義先祖$は、~cloneにおいては`文書片$（~COLOR_X）に置換される。
始点 `s^c が属する`文字~data~node$は~dataが空にされるが、~node自体は［
その親から共通の広義先祖の子まで
］の先祖も含めて~cloneされる。
</p>

`[|[|]|[y|(|.|s)|(|.|)|]|(|.|)|[y|(|.|)|[|(|.|.|e.|)|[|]|]|(|.|)|]|] → [x|[y|(|S)|(|.|)|]|(|.|)|[y|(|.|)|[|(|.|.|E)|]|]|]^bpex

</dd>

 <dt>%range . $insertNode(node)</dt>
 <dd>
`範囲0$の`中身$rgの先頭に %node を挿入する（`中身に挿入-$rgする）。
</dd>

 <dt>%range . $surroundContents(%newParent)</dt>
 <dd>
`範囲0$の`中身$rgを %newParent ~nodeで包装する。
それに伴い、範囲0の始点, 終点は， %newParent の（外側の）両端を指すようにされる。
包装するに先立って、
%newParent の元々の子はすべて除去され，
%newParent 自身も元々の親から除去される。
</dd>
 <dd>
<p>
^surroundContents(%newParent) の実行例。
記号 `s^c は始点, `e^c は終点を表すとき、その間の区間に %newParent の “皮” が被せられる（図の~COLOR_Y）。
`Text^c 以外の`半被包含$は許容されないので、始点と終点は `Text^c の層を~~無視すれば同じ親の直下に位置する必要がある（さもなければ例外が投出される）。
図の様に境界点が `Text^c ~node内に位置する場合、その~nodeはそこで分割される。
</p>

`[|(|.|)|s[x|(|.|)|]|[x|(|.|.|)|[|]|]|(|.|e.|)|] → [|(|.|)|s[y|[x|(|.|)|]|[x|(|.|.|)|[|]|]|(|.|)|]|e(|.|)|]^bpex

</dd>

 <dd lang="en"><!-- for del_j --></dd>
</dl>


<dl class="idl-def">
	<dt>@deleteContents()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The deleteContents() method, when invoked, must run these steps:
</p>


<ol>
 <li>
~IF［
`始点$と`終点$は `等bp$
］
⇒
~RET
◎
If start is end, terminate these steps.
</li>

 <li>
( %元始点~node, %元始点~offset, %元終点~node, %元終点~offset )
~LET 順に，此れの
( `始点~node$, `始点~offset$, `終点~node$, `終点~offset$ )
◎
Let original start node, original start offset, original end node, and original end offset be the context object’s start node, start offset, end node, and end offset, respectively.
</li>

 <li>
<p>
~IF［
%元始点~node ~EQ %元終点~node
］~AND［
%元始点~node, %元終点~node は，いずれも`文字~data~node$である
］：
</p>
  <ol>
   <li>
次を与える下で， %元始点~node の`~dataを置換-$する
⇒
~offset: %元始点~offset,<br>
~count: %元終点~offset ~MINUS %元始点~offset,<br>
~data: 空文字列
</li>
   <li>
~RET
</li>
  </ol>
◎
If original start node and original end node are the same, and they are a Text, ProcessingInstruction, or Comment node, replace data with node original start node, offset original start offset, count original end offset minus original start offset, and data the empty string, and then terminate these steps.
 </li>

 <li>
%除去対象 ~LET
此れに`被包含$なるすべての`~node$から，`親$も此れに`被包含$なる`~node$を除いたものからなる，`木~順序$の~list
◎
Let nodes to remove be a list of all the nodes that are contained in the context object, in tree order, omitting any node whose parent is also contained in the context object.
</li>

 <li id="cp-let-new-if">
~IF［
%元始点~node ~iAN %元終点~node
］
⇒
%新-~node ~LET %元始点~node；<br>
%新-~offset ~LET %元始点~offset
◎
If original start node is an inclusive ancestor of original end node, set new node to original start node and new offset to original start offset.
</li>

 <li><!-- cp-new-node-offset -->
<p>
~ELSE：
</p>

<ol>
 <li>
%新-~node ~LET
( %元始点~node, %元終点~node )
の`共通の広義先祖$
</li>

 <li>
%新-~offset ~LET ［
%新-~node の`子$のうち, %元始点~node の`広義先祖$である`~node$ †
］の`指数$ ~PLUS 1
</li>
  </ol>

<p class="trans-note">【
見通しを良くするため、ここの訳は，原文を等価な記述に変形している。
前段の条件の否定が成立することから †の~nodeは必ず存在し， %新-~node に`半被包含$なる子のうち 最初の方になる。
】</p>

  <div lang="en">
<p>Otherwise:</p>
<ol><li>Let reference node equal original start node.
</li><li>While reference node’s parent is not null and is not an inclusive ancestor of original end node, set reference node to its parent.
</li><li>
<p>
Set new node to the parent of reference node, and new offset to one plus the index of reference node.
</p>
<p>
If reference node’s parent were null, it would be the root of the context object, so would be an inclusive ancestor of original end node, and we couldn’t reach this point.
</p>
 </li>
</ol>
  </div>

 </li>

 <li>
~IF［
%元始点~node は`文字~data~node$である
］
⇒
次を与える下で， %元始点~node の`~dataを置換-$する
⇒
~offset: %元始点~offset,<br>
~count: %元始点~node の`~length$ ~MINUS %元始点~offset,<br>
~data: 空文字列
◎
If original start node is a Text, ProcessingInstruction, or Comment node, replace data with node original start node, offset original start offset, count original start node’s length minus original start offset, data the empty string.
</li>

 <li>
~FOR
%除去対象 内の~EACH ( %node ) に対し，`木~順序$で
⇒
%node をその`親$から`除去-$する
◎
For each node in nodes to remove, in tree order, remove node from its parent.
</li>

 <li>
~IF［
%元終点~node は`文字~data~node$である
］
⇒
次を与える下で， %元終点~node の`~dataを置換-$する
⇒
~offset: 0,<br>
~count: %元終点~offset,<br>
~data: 空文字列
◎
If original end node is a Text, ProcessingInstruction, or Comment node, replace data with node original end node, offset 0, count original end offset and data the empty string.
</li>

 <li>
此れの`始点$ ~SET (%新-~node, %新-~offset)；<br>
此れの`終点$ ~SET (%新-~node, %新-~offset)
◎
Set start and end to (new node, new offset).
</li>

</ol>

	</dd>
</dl>

<p class="algo-head">
`範囲0$ %範囲0 の
`中身を抽出-@rg
するときは、次を走らす：
◎
To extract a range range, run these steps:
</p>

<ol>
 <li id="cp-new-frag">
%断片 ~LET 次のように設定された 新たな`文書片$`~node$
⇒
`~node文書$ ~SET %範囲0 の`始点~node$の`~node文書$
◎
Let fragment be a new DocumentFragment node whose node document is range’s start node’s node document.
</li>

 <li id="cp-ret-frag-if">
~IF［
%範囲0 の`始点$と`終点$は `等bp$
］
⇒
~RET %断片
◎
If range’s start is its end, return fragment.
</li>

 <li id="cp-let-bp-vars">
( %元始点~node, %元始点~offset, %元終点~node, %元終点~offset )
~LET 順に， %範囲0 の
( `始点~node$, `始点~offset$, `終点~node$, `終点~offset$ )
◎
Let original start node, original start offset, original end node, and original end offset be range’s start node, start offset, end node, and end offset, respectively.
</li>

 <li>
<p id="cp-if-s-is-e-and">
~IF［
%元始点~node ~EQ %元終点~node
］~AND［
それは`文字~data~node$である
］：
◎
If original start node is original end node, and they are a Text, ProcessingInstruction, or Comment node:
</p>

  <ol>
   <li id="cp-let-clone-s">
%clone ~LET
%元始点~node を`~clone$した結果
◎
Let clone be a clone of original start node.
</li>

   <li id="cp-set-clone-data-1">
%clone の`~data$ ~SET
%元始点~node の`~dataの部分文字列$( %元始点~offset, ( %元終点~offset ~MINUS %元始点~offset ) )
◎
Set the data of clone to the result of substringing data with node original start node, offset original start offset, and count original end offset minus original start offset.
</li>

   <li id="cp-append-clone">
%clone を %断片 に`付加-$する
◎
Append clone to fragment.
</li>

   <li>
次を与える下で， %元始点~node の`~dataを置換-$する
⇒
~offset: %元始点~offset,<br>
~count: %元終点~offset ~MINUS %元始点~offset,<br>
~data: 空文字列
◎
Replace data with node original start node, offset original start offset, count original end offset minus original start offset, and data the empty string.
</li>

   <li id="cp-ret-flag">
~RET %断片
◎
Return fragment.
</li>

  </ol>
 </li>

 <li id="cp-let-common-anc">
%共通0広義先祖 ~LET
( %元始点~node, %元終点~node )
の`共通の広義先祖$
◎
Let common ancestor be original start node.
◎
While common ancestor is not an inclusive ancestor of original end node, set common ancestor to its own parent.
</li>

 <li id="cp-let-1st-pcc-null">
%~first半被包含子 ~LET ~NULL
◎
Let first partially contained child be null.
</li>

 <li id="cp-set-1st-pcc-if">
~IF［
%元始点~node ~iAN %元終点~node
］でない
⇒
%~first半被包含子 ~SET
%共通0広義先祖 の`子$のうち， %範囲0 に`半被包含$なる最初のもの
◎
If original start node is not an inclusive ancestor of original end node, set first partially contained child to the first child of common ancestor that is partially contained in range.
</li>

 <li id="cp-let-last-pcc-null">
%~last半被包含子 ~LET ~NULL
◎
Let last partially contained child be null.
</li>
 <li id="cp-set-last-pcc-if">
  <p>
~IF［
%元終点~node ~iAN %元始点~node
］でない
⇒
%~last半被包含子 ~SET
%共通0広義先祖 の`子$のうち， %範囲0 に`半被包含$なる最後のもの
◎
If original end node is not an inclusive ancestor of original start node, set last partially contained child to the last child of common ancestor that is partially contained in range.
</p>

<p class="note">注記：
これらの変数~代入は実際に常に意味を持つ。
例えば， %元始点~node ~iAN %元終点~node でないならば、 %元始点~node 自身が %範囲0 に半被包含であり，共通の広義先祖の子までの，その先祖すべても同様である。
共通の広義先祖は、 %元終点~node の`広義先祖$になる筈なので，%元始点~node にはなり得ない。
逆の場合も同様である。
また、２つの子がいずれも定義されたなら，それらは決して等しくならないことにも注意。
◎
These variable assignments do actually always make sense. For instance, if original start node is not an inclusive ancestor of original end node, original start node is itself partially contained in range, and so are all its ancestors up until a child of common ancestor. common ancestor cannot be original start node, because it has to be an inclusive ancestor of original end node. The other case is similar. Also, notice that the two children will never be equal if both are defined.
</li>

 <li id="cp-let-contained">
%被包含子列 ~LET
%共通0広義先祖 の`子$のうち， %範囲0 に`被包含$なるものすべてからなる
`木~順序$による~list。
◎
Let contained children be a list of all children of common ancestor that are contained in range, in tree order.
</li>

 <li id="cp-throw-if-a-doctype">
<p>
~IF［
%被包含子列 のうちのいずれかが`文書型$である
］
⇒
~THROW `HierarchyRequestError^E
◎
If any member of contained children is a doctype, then throw a HierarchyRequestError.
</p>

<p class="note">注記：
`文書型$は決して半被包含にはならないので，最初や最後の半被包含~nodeを考える必要はない。
それは 範囲0 の境界点
<span class="trans-note">【始点~node／終点~node】</span>
にはなり得ず, 何かの先祖にもなり得ない。
◎
We do not have to worry about the first or last partially contained node, because a doctype can never be partially contained. It cannot be a boundary point of a range, and it cannot be the ancestor of anything.
</p>
 </li>

 <!--cp-let-new-if-->

 <li>
<p>
~ELSE
⇒
%新-~node ~LET %共通0広義先祖；<br>
%新-~offset ~LET %~first半被包含子 の`指数$ ~PLUS 1
</p>

<p class="trans-note">【ここの訳は、原文の記述と同じ結果を得るものに簡略化している。】</p>

  <div lang="en"><!-- copy* -->
<p>Otherwise:</p>
<ol>
 <li>Let reference node equal original start node.
</li><li>While reference node’s parent is not null and is not an inclusive ancestor of original end node, set reference node to its parent.
</li><li>
<p>
Set new node to the parent of reference node, and new offset to one plus reference node’s index.
</p>
<p class="note">
If reference node’s parent is null, it would be the root of range, so would be an inclusive ancestor of original end node, and we could not reach this point.
</p>
 </li>
</ol>
  </div>

 </li>

 <li>

<p id="cp-if-1st-pcc-is-cdata">
~IF［
%~first半被包含子 は`文字~data~node$である
］：
◎
If first partially contained child is a Text, ProcessingInstruction, or Comment node:
</p>

<p class="note" id="cp-if-1st-pcc-is-cdata-note">
この事例では， %~first半被包含子 は %元始点~node である。
◎
In this case, first partially contained child is original start node.
</p>

  <ol>
   <!--cp-let-clone-s-->

   <li id="cp-set-clone-data-2">
%clone の`~data$ ~SET
%元始点~node の`~dataの部分文字列$( %元始点~offset, ( %元始点~node の`~length$ ~MINUS %元始点~offset ) )
◎
Set the data of clone to the result of substringing data with node original start node, offset original start offset, and count original start node’s length minus original start offset.
</li>

   <!--cp-append-clone-->

   <li>
次を与える下で， %元始点~node の`~dataを置換-$する
⇒
~offset: %元始点~offset,<br>
~count: %元始点~node の`~length$ ~MINUS %元始点~offset,<br>
~data: 空文字列
◎
Replace data with node original start node, offset original start offset, count original start node’s length minus original start offset, and data the empty string.
</li>

  </ol>
 </li>
 <li>

<p id="cp-elseif-1st-pcc-not-null">
~ELIF［
%~first半被包含子 ~NEQ ~NULL
］：
◎
Otherwise, if first partially contained child is not null:
</p>

  <ol>
   <li id="cp-let-clone-1st-pcc">
%clone ~LET %~first半被包含子 を`~clone$した結果
◎
Let clone be a clone of first partially contained child.
</li>

   <!--cp-append-clone-->

   <li id="cp-let-subrange1">
%下位~範囲0 ~LET 次のように設定された 新たな`範囲0$
⇒
`始点$ ~SET (%元始点~node, %元始点~offset),<br>
`終点$ ~SET (%~first半被包含子, %~first半被包含子 の`~length$ )

◎
Let subrange be a new range whose start is (original start node, original start offset) and whose end is (first partially contained child, first partially contained child’s length).
</li>


   <li id="cp-let-subfrag-extract">
%下位~断片 ~LET %下位~範囲0 の`中身を抽出-$rgした結果
◎
Let subfragment be the result of extracting subrange.
</li>

   <li id="cp-append-subfrag">
%下位~断片 を %clone に`付加-$する
◎
Append subfragment to clone.
</li>

  </ol>
 </li>
 <li>
%被包含子列 内の~EACH ( %被包含子 ) に対し
⇒
%被包含子 を %断片 に`付加-$する
◎
For each contained child in contained children, append contained child to fragment.
</li>

 <li>
<p id="cp-if-last-pcc">
~IF［
%~last半被包含子 は`文字~data~node$である
］：
◎
If last partially contained child is a Text, ProcessingInstruction, or Comment node:
</p>

<p class="note" id="cp-if-last-pcc-note">
この事例では， %~last半被包含子 は %元始点~node である。
◎
In this case, last partially contained child is original end node.
</p>

  <ol>
   <li id="cp-let-clone-end">
%clone ~LET %元終点~node を`~clone$した結果
◎
Let clone be a clone of original end node.
</li>

   <li id="cp-set-clone-data-3">
%clone の`~data$ ~SET
%元終点~node の`~dataの部分文字列$( 0, %元終点~offset )
◎
Set the data of clone to the result of substringing data with node original end node, offset 0, and count original end offset.
</li>

   <!--cp-append-clone-->

   <li>
次を与える下で， %元終点~node の`~dataを置換-$する
⇒
~offset: 0,<br>
~count: %元終点~offset,<br>
~data: 空文字列
◎
Replace data with node original end node, offset 0, count original end offset, and data the empty string.
</li>

  </ol>
 </li>

 <li>
<p id="cp-elif-pcc-not-null">
~ELIF［
%~last半被包含子 ~NEQ ~NULL
］：
◎
Otherwise, if last partially contained child is not null:
</p>

  <ol>
   <li id="cp-let-clone-last-pcc">
%clone ~LET %~last半被包含子 を`~clone$した結果
◎
Let clone be a clone of last partially contained child.
</li>

   <!--cp-append-clone-->

   <li id="cp-let-subrange2">
%下位~範囲0 ~LET 次のように設定された 新たな`範囲0$
⇒
`始点$ ~SET (%~last半被包含子, 0),<br>
`終点$ ~SET (%元終点~node, %元終点~offset)
◎
Let subrange be a new range whose start is (last partially contained child, 0) and whose end is (original end node, original end offset).
</li>

   <!--cp-let-subfrag-extract-->
   <!--cp-append-subfrag-->
  </ol>
 </li>

 <li><!--copy* -->
%範囲0 の`始点$ ~SET (%新-~node, %新-~offset)；<br>
%範囲0 の`終点$ ~SET (%新-~node, %新-~offset)
◎
Set range’s start and end to (new node, new offset).
</li>

 <!--cp-ret-flag-->

</ol>

<dl class="idl-def">
	<dt>@extractContents()</dt>
	<dd>
被呼出時には、此れの`中身を抽出-$rgした結果を返さ~MUST。
◎
The extractContents() method, when invoked, must return the result of extracting context object.
</dd>
</dl>

<p class="algo-head">
`範囲0$ %範囲0 の`中身を~clone@rg
するときは、次を走らす：
◎
To clone the contents of a range range, run these steps:
</p>

<ol>

 <!--cp-new-frag-->
 <!--cp-ret-frag-if-->
 <!--cp-let-bp-vars-->

 <li>
  <!--cp-if-s-is-e-and-->

  <ol>
   <!--cp-let-clone-s-->
   <!--cp-set-clone-data-1-->
   <!--cp-append-clone-->
   <!--cp-ret-flag-->
  </ol>
 </li>

 <!--cp-let-common-anc-->

 <!--cp-let-1st-pcc-null-->
 <!--cp-set-1st-pcc-if-->
 <!--cp-let-last-pcc-null-->
 <!--cp-set-last-pcc-if-->

 <!--cp-let-contained-->
 <!--cp-throw-if-a-doctype-->

 <li>
  <!--cp-if-1st-pcc-is-cdata-->
  <!--cp-if-1st-pcc-is-cdata-note-->
  <ol>
   <!--cp-let-clone-s-->
   <!--cp-set-clone-data-2-->
   <!--cp-append-clone--> 
  </ol>
 </li>

 <li>
  <!--cp-elseif-1st-pcc-not-null-->

  <ol>
   <!--cp-let-clone-1st-pcc-->
   <!--cp-append-clone-->
   <!--cp-let-subrange1-->

   <li id="cp-let-subfrag-clone">
%下位~断片 ~LET %下位~範囲0 の`中身を~clone$rgした結果
◎
Let subfragment be the result of cloning the contents of subrange.
</li>
   <!--cp-append-subfrag-->

  </ol>
 </li>

 <li>
<p>
~FOR
%被包含子列 内の~EACH ( %被包含子 ) に対し：
◎
For each contained child in contained children:
</p>

  <ol>
   <li>
%clone ~LET 
( `~clone子孫^f： ~ON )
を与える下で，
%被包含子 を`~clone$した結果
◎
Let clone be a clone of contained child with the clone children flag set.
</li>

   <!--cp-append-clone--> 

  </ol>
 </li>

 <li>
  <!--cp-if-last-pcc-->
  <!--cp-if-last-pcc-note-->

  <ol>
   <!--cp-let-clone-end-->
   <!--cp-set-clone-data-3-->
   <!--cp-append-clone-->
  </ol>
 </li>
 <li>
  <!--cp-elif-pcc-not-null-->

  <ol>
   <!--cp-let-clone-last-pcc-->
   <!--cp-append-clone-->
   <!--cp-let-subrange2-->

   <!--cp-let-subfrag-clone-->
   <!--cp-append-subfrag-->
  </ol>
 </li>
 <!--cp-ret-flag-->

</ol>

<dl class="idl-def">
	<dt>@cloneContents()</dt>
	<dd>
被呼出時には、此れの`中身を~clone$rgした結果を返さ~MUST。
◎
The cloneContents() method, when invoked, must return the result of cloning the contents of context object.
</dd>
</dl>

<p class="algo-head">
`~node$ %node を`範囲0$ %範囲0 の
`中身に挿入-@rg
するときは，次を走らす：
◎
To insert a node node into a range range, run these steps:
</p>

<p class="trans-note">【
`始点$の直後に %node を挿入する。
それに伴い、終点は，末尾側からの相対位置が変化しないように適宜ずらされる（すなわち、挿入-後の 始点／終点 の，先頭／末尾 からの相対位置は不変）。
始点が`文字~data~node$の内部を指している場合、その~nodeは始点の所で 2 つに分割される。
】</p>

<ol>
 <li>
~IF［
%範囲0 の`始点~node$ は［
$ProcessingInstruction または $Comment
］~nodeである
］~OR［［
`親$ ~EQ ~NULL
］なる $Text `~node$である
］~OR［
~EQ %node である
］
⇒
~THROW `HierarchyRequestError^E
◎
If range’s start node is a ProcessingInstruction or Comment node, is a Text node whose parent is null, or is node, then throw a HierarchyRequestError.
</li>

 <li>
%基準~node ~LET ~NULL
◎
Let referenceNode be null.
</li>

 <li>
~IF［
%範囲0 の`始点~node$ は $Text `~node$である
］
⇒
%基準~node ~SET それ
◎
If range’s start node is a Text node, set referenceNode to that Text node.
</li>

 <li>
~ELIF［
`始点~node$ の`子$に［
`指数$ ~EQ `始点~offset$
］なるものが在る
］
⇒
%基準~node ~SET それ
◎
Otherwise, set referenceNode to the child of start node whose index is start offset, and null if there is no such child.
</li>

 <li>
%親 ~LET ［
%基準~node ~NEQ ~NULL ならば その`親$ ／
~ELSE_ %範囲0 の`始点~node$
］
◎
Let parent be range’s start node if referenceNode is null, and referenceNode’s parent otherwise.
</li>

 <li>
%node を %親 の中で %基準~node の前に`挿入し得るかどうか検証する$
◎
Ensure pre-insertion validity of node into parent before referenceNode.
</li>

 <li>
<p >
~IF［
%範囲0 の`始点~node$ は $Text `~node$である
］
⇒
%基準~node ~SET それを %範囲0 の`始点~offset$ の所で`分割-$した結果
</p>
<p class="trans-note">【
`始点~offset$ が 0 でも ^Text ~nodeは`分割-$されることになる。
】</p>
◎
If range’s start node is a Text node, set referenceNode to the result of splitting it with offset range’s start offset.
</li>

 <li>
~IF［
%node ~EQ %基準~node
］
⇒
%基準~node ~SET その`弟$
◎
If node is referenceNode, set referenceNode to its next sibling.
</li>

 <li>
~IF［
%node の`親$ ~NEQ ~NULL
］
⇒
%node を %node の`親$から`除去-$する
◎
If node’s parent is not null, remove node from its parent.
</li>

 <li>
%新-~offset ~LET ［
%基準~node ~NEQ ~NULL ならば その`指数$ ／
~ELSE_ %親 の`~length$
］
◎
Let newOffset be parent’s length if referenceNode is null, and referenceNode’s index otherwise.
</li>

 <li>
%新-~offset ~INCBY ［
%node は`文書片$であるならば その`~length$ ／
~ELSE_ 1
］
◎
Increase newOffset by node’s length if node is a DocumentFragment node, and one otherwise.
</li>

 <li>
%親 の中で， %node を %基準~node の前に`前挿入$する
◎
Pre-insert node into parent before referenceNode.
</li>

 <li>
<p>
~IF［
%範囲0 の`始点$ ~EQ %範囲0 の`終点$
］
⇒
%範囲0 の`終点$ ~SET (%親, %新-~offset)
</p>

<p class="trans-note">【
始点 ~NEQ 終点の場合の終点の位置は，`前挿入$（が呼び出す`挿入-$）の段階で適宜ずらされる。
】</p>

◎
If range’s start and end are the same, set range’s end to (parent, newOffset).
</li>
</ol>

<dl class="idl-def">
	<dt>@insertNode(node)</dt>
	<dd>
被呼出時には、
%node を此れの`中身に挿入-$rgし~MUST。
◎
The insertNode(node) method, when invoked, must insert node into context object.
</dd>

	<dt>@surroundContents(newParent)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The surroundContents(newParent) method, when invoked,, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
此れに`半被包含$なる，
$Text でない`~node$が在る
］
⇒
~THROW `InvalidStateError^E
◎
If a non-Text node is partially contained in the context object, then throw an InvalidStateError.
</li>

 <li>
~IF［
%newParent は
$Document, $DocumentType, $DocumentFragment `~node$
のいずれかである
］
⇒
~THROW `InvalidNodeTypeError^E
◎
If newParent is a Document, DocumentType, or DocumentFragment node, then throw an InvalidNodeTypeError.
</li>

 <li>
%断片 ~LET 此れの`中身を抽出-$rgした結果
◎
Let fragment be the result of extracting context object.
</li>

 <li>
~IF［
%newParent は`子$を持つ
］
⇒
%newParent の内容を ~NULL で`すべて置換-$する
◎
If newParent has children, replace all with null within newParent.
</li>

 <li>
%newParent を此れの`中身に挿入-$rgする
◎
Insert newParent into context object.
</li>

 <li>
<p>
%断片 を %newParent に`付加-$する
</p>

<p class="trans-note">【
%newParent が`文字~data~node$であった場合、（ `中身に挿入-$rgした上で）この段で例外が投出されることになる。
】</p>

◎
Append fragment to newParent.
</li>

 <li>
%newParent を，此れの`中身として選択-$rgする
◎
Select newParent within context object.
</li>

</ol>

	</dd>

	<dt>@cloneRange()</dt>
	<dd>
被呼出時には、次のように設定された 新たな`範囲0$を返さ~MUST
⇒
`始点$ ~SET 此れの`始点$の複製,<br><!--  -->
`終点$ ~SET 此れの`終点$の複製
◎
The cloneRange() method, when invoked, must return a new range with the same start and end as context object.
</dd>

	<dt>@detach()</dt>
	<dd>
被呼出時には、何もしては~MUST_NOT。
◎
The detach() method, when invoked, must do nothing.
Its functionality (disabling a Range object) was removed, but the method itself is preserved for compatibility.
</dd>
	<dd class="note">注記：
この機能性（ ^Range ~objの不能化）は、取り除かれた。
互換性のため存続はするが。
◎
↑</dd>
</dl>


<dl class="domintro">
<!-- 
 <dt>range . cloneRange()†</dt>

 <dt>range . detach()†</dt>
-->

 <dt>%position = %range . $isPointInRange( node, offset )</dt>
 <dd>
境界点 ( %node, %offset ) が %range 内に入る†かどうかを返す。
</dd>

 <dt>%position = %range . $comparePoint( node, offset )</dt>
 <dd>
境界点 ( %node, %offset ) が
%range より前に位置する場合は ~MINUS 1 を,
%range 内に入る†場合は 0 を,
%range より後に位置する場合は 1 を
返す。<!-- * -->
◎
Returns −1 if the point is before the range, 0 if the point is in the range, and 1 if the point is after the range.
</dd>

 <dd>†
境界点が %range のいずれかの境界点に一致する場合も，“入る” と見なされる。
</dd>

 <dt>%intersects = %range . $intersectsNode( node )</dt>
 <dd>
%range が %node と交わるかどうかを返す。
◎
Returns whether range intersects node.
</dd>

 <dd class="trans-note">
<p>【
%node が %range に隣接している場合（ %range の終点（始点）が %node の <em>外側の</em> 始端（終端）を指す境界点に一致する場合）は、“交わらない”。
例えば下図で `s^c, `e^c が %range の境界点を表すとするとき，図の~COLOR_Yが表す %node は交わらない。
】</p>

`[|[y|(|.|)|]|s[|(|.|.|)|e[y|(|.|.|)|]|]|]^bpex

<p>【
一般に、 %node は %範囲0 に
(1) “全部的に包含されている” とき（ `被包含$ ）, または
(2) %範囲0 の始点~node／終点~nodeいずれかの`広義先祖$であるとき、
“交わる”。
】</p>
 </dd>

 <dt>$stringifier</dt>
 <dd>
範囲0を文字列化した結果は、範囲0により “選択-” されているすべての~textになる。
</dd>
</dl>

<p class="trans-note">【
上のブロックに挙げた ^isPointInRange(), ^stringifier は、原文には存在しない，この訳による補完。
】</p>


<dl class="idl-def">
	<dt>@isPointInRange(node, offset)</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The isPointInRange(node, offset) must run these steps:
</p>

<ol>
 <li id="cp-ret-F-if-root">
~IF［
%node の`根$ ~NEQ 此れの`根$rg
］
⇒
~RET ~F
◎
If node’s root is different from the context object’s root, return false.
</li>

 <!--cp-throw-if-doctype-->
 <!--cp-throw-if-length-->

 <li>
~IF［
(%node, %offset) は
`始点$より `前bp$
］~OR［
`終点$より `後bp$
］
⇒
~RET ~F
◎
If (node, offset) is before start or after end, return false.
</li>

 <li>
~RET ~T
◎
Return true.
</li>
</ol>
	</dd>

	<dt>@comparePoint(node, offset)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The comparePoint(node, offset) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%node の`根$ ~NEQ 此れの`根$rg
］
⇒
~THROW `WrongDocumentError^E
◎
If node’s root is different from the context object’s root, then throw a WrongDocumentError.
</li>

 <!--cp-throw-if-doctype-->
 <!--cp-throw-if-length-->

 <li>
~IF［
(%node, %offset) は
`始点$より `前bp$
］
⇒
~RET ~MINUS 1
◎
If (node, offset) is before start, return −1.
</li>

 <li> 
~IF［
(%node, %offset) は
`終点$より `後bp$
］
⇒
~RET 1
◎
If (node, offset) is after end, return 1.
</li>

 <li>
~RET 0
◎
Return 0.
</li>
</ol>

	</dd>

	<dt>@intersectsNode(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The intersectsNode(node) method, when invoked, must run these steps:
</p>

<ol>

 <!--cp-ret-F-if-root-->
 <!--cp-let-parent-->

 <li>
~IF［
%親 ~EQ ~NULL
<!-- すなわち node は根 -->
］
⇒
~RET ~T
◎
If parent is null, return true.
</li>

 <li>
%offset ~LET %node の`指数$
◎
Let offset be node’s index.
</li>

 <li>
~IF［
(%親, %offset) は`終点$より `前bp$
］~AND［
(%親, %offset ~PLUS 1) は`始点$より `後bp$
<!-- selectNode の結果 -->
］
⇒
~RET ~T
◎
If (parent, offset) is before end and (parent, offset + 1) is after start, return true.
</li>

 <li>
~RET ~F
◎
Return false.
</li>
</ol>
	</dd>

	<dt>@stringifier</dt>
	<dd>
<p>
文字列化の挙動は、次を走らせ~MUST：
◎
The stringification behavior must run these steps:
</p>

<ol>
 <li>
%s ~LET 空文字列
◎
Let s be the empty string.
</li>

 <li>
~IF［
`始点~node$ ~EQ `終点~node$
］~AND［
それは $Text `~node$である
］
⇒
~RET ［
その $Text `~node$の`~data$
］の［
`始点~offset$ から`終点~offset$ までの部分文字列
］
◎
If start node is end node, and it is a Text node, return the substring of that Text node’s data beginning at start offset and ending at end offset.
</li>

 <li>
~IF［
`始点~node$ は $Text `~node$である
］
⇒
［
その`~node$の`~data$
］の［
`始点~offset$ から末尾までの部分文字列
］を
%s に付加する
◎
If start node is a Text node, append to s the substring of that node’s data from the start offset until the end.
</li>

 <li>
此れに`被包含$なる ~EACH ( $Text `~node$ ) に対し，`木~順序$で
⇒
その`~data$を %s に付加する
◎
Append to s the concatenation, in tree order, of the data of all Text nodes that are contained in the context object.
</li>

 <li>
~IF［
`終点~node$ は $Text `~node$である
］
⇒
［
その`~node$の`~data$
］の［
先頭から`終点~offset$ までの部分文字列
］を %s に付加する
◎
If end node is a Text node, append to s the substring of that node’s data from its start until the end offset.
</li>

 <li>
~RET %s
◎
Return s.
</li>
</ol>

	</dd>
</dl>


<hr>

<p class="note">注記：
^Range ~ifcに対する拡張として，
<a href="https://w3c.github.io/DOM-Parsing/#widl-Range-createContextualFragment-DocumentFragment-DOMString-fragment">^createContextualFragment()</a>,
<a href="https://drafts.csswg.org/cssom-view/#dom-range-getclientrects">^getClientRects()</a>,
<a href="https://drafts.csswg.org/cssom-view/#dom-range-getboundingclientrect">^getBoundingClientRect()</a>
~methが，他の仕様に定義されている。
`DOM-Parsing$r
`CSSOM-VIEW$r
◎
The createContextualFragment(), getClientRects(), and getBoundingClientRect() methods are defined in other specifications. [DOM-Parsing] [CSSOM-VIEW]
</p>


		</section>
	</section>
	<section id="traversal">

<h2 title="Traversal">6. 走査</h2>

<p>
$NodeIterator ／ $TreeWalker ~objを利用すれば、`~node$`木$を~filterにかけながら走査できる。
◎
NodeIterator and TreeWalker objects can be used to filter and traverse node trees.
</p>

<div class="p">
<p>
各 $NodeIterator ／ $TreeWalker ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`根~node@</dt>
	<dd>
走査-対象にされる部分木の根を与える，`~node$。
</dd>

	<dt>`whatToShow ~bitmask@</dt>
	<dd>
どの型の~nodeを対象にするかを指示する，整数~bitmask。
~bit 1 に対応する型の~nodeのみが~filterを “通過する” 。
</dd>

	<dt>`~filter~callback@</dt>
	<dd>
対象を更に “濾過する” ~~条件を与える $NodeFilter ~obj,
または ~NULL （濾過されない）。
</dd>

</dl>

<p class="trans-note">【
各項目の説明は、訳者による補足。
】</p>

◎
Each NodeIterator and TreeWalker object also has an associated root node, whatToShow bitmask, and filter callback.
</div>


<p class="algo-head">
%node を
`~filterにかける@
ときは、次を走らす：
◎
To filter node run these steps:
</p>

<ol>

 <li>
%n ~LET %node の $Node.nodeType 属性~値~MINUS 1
◎
Let n be node’s nodeType attribute value minus 1.
</li>

 <li>
~IF［
`whatToShow ~bitmask$ の %n 番目の~bit（ 0 番目が最下位~bitとする） ~EQ 0
］
⇒
~RET $NodeFilter.FILTER_SKIP
 <!-- !((1 << (node.nodeType - 1)) & whatToShow) -->
◎
If the nth bit (where 0 is the least significant bit) of whatToShow is not set, return FILTER_SKIP.
</li>

 <li>
~IF［
`~filter~callback$ ~EQ ~NULL
］
⇒
~RET $NodeFilter.FILTER_ACCEPT
◎
If filter is null, return FILTER_ACCEPT.
</li>

 <li>
<p>
~RET 次を与える下で，`利用者~objの演算を~call$した結果（例外投出あり）：
</p>

<ul ><li>`~filter~callback$
</li><li>`acceptNode^l
</li><li>引数~list： ( %node )
</li></ul>

◎
Let result be the return value of call a user object’s operation with filter, "acceptNode", and a list of arguments consisting of node. Rethrow any exceptions.
◎
Return result.
</li>
</ol>




		<section id="interface-nodeiterator">

<h3>6.1. ~ifc ^@NodeIterator</h3>

⇒！
[Exposed=Window]
interface @NodeIterator {
  [SameObject] ~RA $Node $root;
  ~RA $Node $referenceNode;
  ~RA ~B $pointerBeforeReferenceNode;
  ~RA ~UL $whatToShow;
  ~RA $NodeFilter? $filter;

  $Node? $nextNode();
  $Node? $previousNode();

  void $detach();
};
◎

<p class="note">注記：
$NodeIterator ~objは
$Document.createNodeIterator()
~methにより作成できる。
◎
NodeIterator objects can be created using the createNodeIterator() method.
</p>

<p>
各 $NodeIterator ~objには、
`反復器~collection@
が結付けられる。
それは、次のようにされた`~collection$である
⇒
`根$cl ~SET `根~node$,<br>
`~filter$は どの`~node$にも合致する
<!-- ＊ -->
◎
Each NodeIterator object has an associated iterator collection, which is a collection rooted at root, whose filter matches any node.
</p>

<p class="note">注記：
前に示したように、各 $NodeIterator ~objには［
`根~node$,
`whatToShow ~bitmask$,
`~filter~callback$
］が結付けられる。
◎
As mentioned earlier, NodeIterator objects have an associated root node, whatToShow bitmask, and filter callback as well.
</p>

<p class="algo-head">
所与の入力 ( $NodeIterator %反復器, `~node$ %被除去~node ) に対する
`前除去-時の手続き@
は、次で与えられる：
◎
The NodeIterator pre-removing steps given a nodeIterator and toBeRemovedNode, are as follows:
</p>

<ol>
 <li>
~IF［
%被除去~node は［
%反復器 の $referenceNode 属性~値
］の`広義先祖$でない
］
⇒
~RET
◎
If toBeRemovedNode is not an inclusive ancestor of the referenceNode attribute value, terminate these steps.
</li>

 <li>
<p>
~IF［
%反復器 の $pointerBeforeReferenceNode 属性~値 ~EQ ~T
］：
◎
If the pointerBeforeReferenceNode attribute value is true, run these substeps:
</p>

  <ol>
   <li>
%次 ~LET ［
%被除去~node に`後続-$する
］~AND［
%反復器 の`根~node$の`広義子孫$である
］~AND［
%被除去~node の`広義子孫$でない
］ような，`最初0$の`~node$
◎
Let next be toBeRemovedNode’s first following node that is an inclusive descendant of nodeIterator’s root and is not an inclusive descendant of toBeRemovedNode, and null if there is no such node.
</li>
   <li>
~IF［
%次 ~NEQ ~NULL
］
⇒
%反復器 の $referenceNode 属性 ~SET %次；<br>
~RET
◎
If next is non-null, set nodeIterator’s referenceNode attribute to next and terminate these steps.
</li>
   <li>
%反復器 の $pointerBeforeReferenceNode 属性 ~SET ~F
◎
Otherwise, set nodeIterator’s pointerBeforeReferenceNode attribute to false.
◎
Steps are not terminated here.
</li>
  </ol>
 </li>
 <li>
%兄 ~LET %被除去~node の`兄$
◎
↓</li>
 <li>
%反復器 の $referenceNode 属性 ~SET［
%兄 ~EQ ~NULL ならば %被除去~node の`親$ ／
~ELSE_ %兄 の`広義子孫$のうち，`最後0$のもの
］
◎
Set nodeIterator’s referenceNode attribute to toBeRemovedNode’s parent, if toBeRemovedNode’s previous sibling is null, and to the inclusive descendant of toBeRemovedNode’s previous sibling that appears last in tree order otherwise.
</li>
</ol>

<hr>

<dl class="idl-def">
	<dt>@root</dt>
	<dd>
取得子は、`根~node$を返さ~MUST。
◎
The root attribute’s getter must return root.
</dd>

	<dt>@referenceNode</dt>
	<dt>@pointerBeforeReferenceNode</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化時の値を返さ~MUST。
◎
The referenceNode and pointerBeforeReferenceNode attributes must return what they were initialized to.
</dd>
	<dd class="trans-note">【
概念的には、この２つの属性の組により、`走査-$において “次” の~nodeを探索する開始地点を指す，~pointerが表現される。
^referenceNode （初期値は先頭の~node ）が “現在の” ~nodeを表し、真偽値をとる ^pointerBeforeReferenceNode （初期値は ~T ）に従って、~pointerは，現在の~nodeの “直後” （ ~F ）または “直前” （ ~T ）を指す（すなわち、初期時の~pointerは先頭の~nodeの直前を指している）。
】</dd>

	<dt>@whatToShow</dt>
	<dd>
取得子は、`whatToShow ~bitmask$ を返さ~MUST。
◎
The whatToShow attribute’s getter must return whatToShow.
</dd>

	<dt>@filter</dt>
	<dd>
取得子は、`~filter~callback$を返さ~MUST。
◎
The filter attribute’s getter must return filter.
</dd>
</dl>


<p class="algo-head">
所与の %方向 （ '順' または '逆' ）へ，此れ（ $NodeIterator ~obj）を
`走査-@
するときは、次を走らす：
◎
To traverse in direction direction run these steps:
</p>

<ol>
 <li>
%node ~LET
此れの $referenceNode 属性の値
◎
Let node be the value of the referenceNode attribute.
</li>

 <li>
%node直前 ~LET
此れの $pointerBeforeReferenceNode 属性の値
◎
Let before node be the value of the pointerBeforeReferenceNode attribute.
</li>
 <li>
%collection ~LET 此れの`反復器~collection$
◎
↓</li>
 <li>
<p id="cp-repeat">
~WHILE 無条件：
◎
Run these substeps:
</p>
  <ol>
   <li>
<p>
~IF［
%方向 ~EQ '順'
］：
◎
If direction is next
</p>

<div>
<ol>
	<li>
<p>
~IF［
%node直前 ~EQ ~F
］：
</p>

		<ol>
			<li>
%node ~SET %collection の中で %node に`後続-$する`最初0$の`~node$
</li>
			<li>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%node直前 ~SET ~F
</li>
</ol>
◎
If before node is false, let node be the first node following node in the iterator collection. If there is no such node return null. If before node is true, set it to false.
</div>
   </li>
   <li>
<p>
~ELSE（ %方向 ~EQ '逆' ）：
◎
If direction is previous
</p>

<div>
<ol>
	<li>
<p>
~IF［
%node直前 ~EQ ~T
］：
</p>
		<ol>
			<li>
%node ~SET %collection の中で %node に`先行-$する`最後0$の`~node$
</li>
			<li>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%node直前 ~SET ~T
</li>
</ol>
◎
If before node is true, let node be the first node preceding node in the iterator collection. If there is no such node return null. If before node is false, set it to true.
</div>
   </li>

   <li>
~IF［
%node を`~filterにかけた$結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
~BREAK
◎
Filter node and let result be the return value.
◎
If result is FILTER_ACCEPT, go to the next step in the overall set of steps. Otherwise, run these substeps again.
</li>

  </ol>
 </li>
 <li>
此れの $referenceNode 属性 ~SET %node
◎
↓</li>
 <li>
此れの $pointerBeforeReferenceNode 属性 ~SET %node直前
◎
↓</li>
 <li>
~RET %node
◎
Set the referenceNode attribute to node, set the pointerBeforeReferenceNode attribute to before node, and return node.
</li>
</ol>

<p class="trans-note">【
走査の方向が前回と逆向きに切り替わった場合、探索は，前回の走査による
“現在の” ~node（ ^referenceNode ）から開始されることに注意（その次／前の~nodeからではなく）。
探索の結果，`~filter$に合致する~nodeが見出されなかった場合、属性は変更されない。
見出された場合、
^referenceNode は，新たに見出された~nodeにされ、
^pointerBeforeReferenceNode （ “現在の” 走査-方向）は，入力された方向を表すようにされる（ ~F が '順' 方向に対応する）。
】</p>

<dl class="idl-def">
	<dt>@nextNode()</dt>
	<dd>
被呼出時には、 '順' 方向へ，此れを`走査-$した結果を返さ~MUST。
◎
The nextNode() method, when invoked, must traverse in direction next.
</dd>

	<dt>@previousNode()</dt>
	<dd>
被呼出時には、 '逆' 方向へ，此れを`走査-$した結果を返さ~MUST。
◎
The previousNode() method, when invoked, must traverse in direction previous.
</dd>

	<dt>@detach()</dt>
	<dd>
被呼出時には、何もしては~MUST_NOT。
◎
The detach() method, when invoked, must do nothing.
Its functionality (disabling a NodeIterator object) was removed, but the method itself is preserved for compatibility.
</dd>
	<dd class="note">注記：
この機能性（ ^NodeIterator ~objの不能化）は、取り除かれた。
互換性のため存続はするが。
◎
↑</dd>

</dl>


		</section>
		<section id="interface-treewalker">

<h3>6.2. ~ifc ^@TreeWalker</h3>

⇒！
[Exposed=Window]
interface @TreeWalker {
  [SameObject] ~RA $Node $root;
  ~RA ~UL $whatToShow;
  ~RA $NodeFilter? $filter;
           attribute $Node $currentNode;

  $Node? $parentNode();
  $Node? $firstChild();
  $Node? $lastChild();
  $Node? $previousSibling();
  $Node? $nextSibling();
  $Node? $previousNode();
  $Node? $nextNode();
};
◎

<p class="note">注記：
$TreeWalker ~objは
$Document.createTreeWalker()
~methにより作成できる。
◎
TreeWalker objects can be created using the createTreeWalker() method.
</p>

<p class="note">注記：
前に示したように、各 $TreeWalker ~objには
`根~node$,
`whatToShow ~bitmask$,
`~filter~callback$
が結付けられる。
◎
As mentioned earlier TreeWalker objects have an associated root node, whatToShow bitmask, and filter callback.
</p>

<dl class="idl-def">
	<dt>@root</dt>
	<dd>
取得子は、此れの`根~node$を返さ~MUST。
◎
The root attribute’s getter must return root.
</dd>

	<dt>@whatToShow</dt>
	<dd>
取得子は、此れの `whatToShow ~bitmask$ を返さ~MUST。
◎
The whatToShow attribute’s getter must return whatToShow.
</dd>

	<dt>@filter</dt>
	<dd>
取得子は、此れの`~filter~callback$を返さ~MUST。
◎
The filter attribute’s getter must return filter.
</dd>

	<dt>@currentNode</dt>
	<dd>
取得子は、初期化時の値を返さ~MUST。
◎
The currentNode attribute must return what it was initialized to.
</dd>
	<dd>
設定子は、与えられた値に設定し~MUST。
<!-- * -->
◎
Setting the currentNode attribute must set it to the new value.
</dd>

	<dt>@parentNode()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The parentNode() method, when invoked, must run these steps:
</p>

<ol>
 <li id="cp-let-current">
%node ~LET 此れの $currentNode 属性の値
◎
Let node be the value of the currentNode attribute.
</li>

 <li>
<p>
~WHILE［
%node ~NEQ ~NULL
］~AND［
%node ~NEQ `根~node$
］：
◎
While node is not null and is not root, run these substeps:
</p>

  <ol>
   <li>
%node ~SET %node の`親$<!-- * LET -->
◎
Let node be node’s parent.
</li>

   <li>
<p >
~IF［
%node ~NEQ ~NULL
］~AND［
%node を`~filterにかけた$結果 ~EQ $NodeFilter.FILTER_ACCEPT
］：
</p>

<ol ><li>此れの $currentNode 属性 ~SET %node
</li><li>~RET %node
</li></ol>
◎
If node is not null and filtering node returns FILTER_ACCEPT, then set the currentNode attribute to node, return node.
</li>
  </ol>
 </li>
 <li id="cp-TW-ret-null">
~RET ~NULL
◎
Return null.
</li>
</ol>

	</dd>
</dl>

<p class="algo-head">
所与の %側 （ '最初' または '最後' ）へ，此れ（ $TreeWalker ~obj）の
`子を走査-@
するときは、次を走らす：
◎
To traverse children of type type, run these steps:
</p>
<!-- 走査順序（'最初' の場合）
N →
	(SKIP && N.firstChild) || 
	N0.nextSibling || N1.nextSibling || N2.nextSibling || ...
		// Nn = N(n-1).parentNode, N0 = N

-->
<ol>
 <!--cp-let-current-->

 <li>
%node ~SET %側 に応じて［
'最初' ならば %node の`最初0の子$ ／
'最後' ならば %node の`最後0の子$
］
◎
Set node to node’s first child if type is first, and node’s last child if type is last.
</li>

 <li>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If node is null, return null.
</li>

 <li id="concept-traverse-children-main">
<p>
~WHILE 無条件：
◎
Main:
◎
Repeat these substeps: 
</p>

  <ol>
   <li id="cp-let-filter-result">
%結果 ~LET %node を`~filterにかけた$結果
◎
Filter node and let result be the return value.
</li>

   <li id="cp-set-current-if-accept">
<p>
~IF［
%結果 ~EQ $NodeFilter.FILTER_ACCEPT
］：
</p>

<ol ><li>此れの $currentNode 属性 ~SET %node
</li><li>~RET %node
</li></ol>

◎
If result is FILTER_ACCEPT, then set the currentNode attribute to node and return node.
</li>

   <li>
<p>
~IF［
%結果 ~EQ $NodeFilter.FILTER_SKIP
］：
◎
If result is FILTER_SKIP, run these subsubsteps:
</p>
    <ol>
     <li>
%子 ~LET %側 に応じて［
'最初' ならば %node の`最初0の子$ ／
'最後' ならば %node の`最後0の子$
］
◎
Let child be node’s first child if type is first, and node’s last child if type is last.
</li>

     <li>
~IF［
%子 ~NEQ ~NULL
］
⇒
%node ~SET %子；<br>
~CONTINUE
<!-- 
#concept-traverse-children-main へ戻る
-->
◎
If child is not null, set node to child and goto Main.
</li>

    </ol>
   </li>

   <li>
<p>
~WHILE 無条件：
◎
Repeat these subsubsteps:
</p>

    <ol>
     <li>
%同胞 ~LET %側 に応じて［
'最初' ならば %node の`弟$ ／
'最後' ならば %node の`兄$
］
◎
Let sibling be node’s next sibling if type is first, and node’s previous sibling if type is last.
</li>

     <li>
~IF［
%同胞 ~NEQ ~NULL
］
⇒
%node ~SET %同胞；<br>
~BREAK
<!-- 
#concept-traverse-children-main へ戻る
 -->
◎
If sibling is not null, set node to sibling and goto Main.
</li>

     <li>
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>

     <li>
~IF［
%親 ~IN { ~NULL, `根~node$, 此れの $currentNode 属性の値 }
］
⇒
~RET ~NULL
◎
If parent is null, parent is root, or parent is currentNode attribute’s value, return null.
</li>

     <li>
~ELSE
⇒
%node ~SET %親
◎
Otherwise, set node to parent.
</li>

    </ol>
   </li>
  </ol>
 </li>
</ol>

<dl class="idl-def">
	<dt>@firstChild()</dt>
	<dd>
被呼出時には、 '最初' へ，此れの`子を走査-$した結果を返さ~MUST。
◎
The firstChild() method, when invoked, must traverse children of type first.
</dd>

	<dt>@lastChild()</dt>
	<dd>
被呼出時には、 '最後' へ，此れの`子を走査-$した結果を返さ~MUST。
◎
The lastChild() method, when invoked, must traverse children of type last.
</dd>
</dl>


<p class="algo-head">
所与の %方向 （ '順' または '逆' ）へ，此れ（ $TreeWalker ~obj）の
`同胞を走査-@
するときは、次を走らす：
◎
To traverse siblings of type type run these steps:
</p>

<ol>
 <!--cp-let-current-->

 <li>
~IF［
%node ~EQ `根~node$
］
⇒
~RET ~NULL
◎
If node is root, return null.
</li>

 <li>
<!--cp-repeat-->
  <ol>
   <li>
%同胞 ~LET %方向 に応じて［
'順' ならば %node の`弟$ ／
'逆' ならば %node の`兄$
］
◎
Let sibling be node’s next sibling if type is next, and node’s previous sibling if type is previous.
</li>

   <li>
<p>
~WHILE［
%同胞 ~NEQ ~NULL
］：
◎
While sibling is not null, run these subsubsteps:
</p>
    <ol>
     <li>
%node ~SET %同胞
◎
Set node to sibling.
</li>

     <!--cp-let-filter-result-->
     <!--cp-set-current-if-accept-->
     <li>
%同胞 ~SET %方向 に応じて［
'順' ならば %node の`最初0の子$ ／
'逆' ならば %node の`最後0の子$
］
◎
Set sibling to node’s first child if type is next, and node’s last child if type is previous.
</li>

     <li>
~IF［
%結果 ~EQ $NodeFilter.FILTER_REJECT
］~OR［
%同胞 ~EQ ~NULL
］
⇒
%同胞 ~SET %方向 に応じて［
'順' ならば %node の`弟$ ／
'逆' ならば %node の`兄$
］
◎
If result is FILTER_REJECT or sibling is null, then set sibling to node’s next sibling if type is next, and node’s previous sibling if type is previous.
</li>

    </ol>
   </li>

   <li>
%node ~SET その`親$
◎
Set node to its parent.
</li>

   <li>
~IF［
%node ~IN { ~NULL, `根~node$ }
］
⇒
~RET ~NULL
◎
If node is null or is root, return null.
</li>

   <li>
~IF［
%node を`~filterにかけた$結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
~RET ~NULL
◎
Filter node and if the return value is FILTER_ACCEPT, then return null.
◎
Run these substeps again.
</li>

  </ol>
 </li>
</ol>

<dl class="idl-def">
	<dt>@nextSibling()</dt>
	<dd>
被呼出時には、
'順' 方向へ，此れの`同胞を走査-$した結果を返さ~MUST。
◎
The nextSibling() method, when invoked, must traverse siblings of type next.
</dd>

	<dt>@previousSibling()</dt>
	<dd>
被呼出時には、
'逆' 方向へ，此れの`同胞を走査-$した結果を返さ~MUST。
◎
The previousSibling() method, when invoked, must traverse siblings of type previous.
</dd>

	<dt>@previousNode()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The previousNode() method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-let-current-->

 <li>
<p>
~WHILE［
%node ~NEQ `根~node$
］：
◎
While node is not root, run these substeps:
</p>
  <ol>
   <li>
%同胞 ~LET %node の`兄$
◎
Let sibling be the previous sibling of node.
</li>

   <li>
<p>
~WHILE［
%同胞 ~NEQ ~NULL 
］：
◎
While sibling is not null, run these subsubsteps:
</p>
    <ol>
     <li>
%node ~SET %同胞
◎
Set node to sibling.
</li>

     <!--cp-let-filter-result-->

     <li>
<p >
~WHILE［
%結果 ~NEQ $NodeFilter.FILTER_REJECT
］~AND［
%node は`子$を持つ
］：
</p>

<ol ><li>%node ~SET %node の`最後0の子$
</li><li>%結果 ~SET %node を`~filterにかけた$結果
</li></ol>

◎
While result is not FILTER_REJECT and node has a child, set node to its last child and then filter node and set result to the return value.
</li>

     <!--cp-set-current-if-accept-->

     <li>
%同胞 ~SET %node の`兄$
◎
Set sibling to the previous sibling of node.
</li>

    </ol>
   </li>

   <li>
~IF［
%node ~EQ `根~node$
］~OR［
%node の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If node is root or node’s parent is null, return null.
</li>

   <li>
%node ~SET %node の`親$
◎
Set node to its parent.
</li>

   <li>
~IF［
%node を`~filterにかけた$結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
此れの $currentNode 属性 ~SET %node；<br>
~RET %node
◎
Filter node and if the return value is FILTER_ACCEPT, then set the currentNode attribute to node and return node.
</li>

  </ol>
 </li>
 <!--cp-TW-ret-null-->

</ol>
	</dd>

	<dt>@nextNode()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The nextNode() method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-let-current-->

 <li>
%結果 ~LET $NodeFilter.FILTER_ACCEPT
◎
Let result be FILTER_ACCEPT.
</li>

 <li>
<!--cp-repeat-->

  <ol>
   <li>
<p>
~WHILE［
%結果 ~NEQ $NodeFilter.FILTER_REJECT
］~AND［
%node は`子$を持つ
］：
◎
While result is not FILTER_REJECT and node has a child, run these subsubsteps:
</p>

    <ol>
     <li>
%node ~SET %node の`最初0の子$
◎
Set node to its first child.
</li>

     <li id="cp-set-filter-result">
%結果 ~SET %node を`~filterにかけた$結果
◎
Filter node and set result to the return value.
</li>

     <!--cp-set-current-if-accept-->
    </ol>
   </li>

   <li>
<p>
%node ~SET ［
%node に`後続-$する
］~AND［
`根~node$に`後続-$しない†
］ような `最初0$の`~node$
</p>

<p>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
</p>

<p class="trans-note">【†
次の条件も必要では？
“~AND %結果 ~EQ ^FILTER_REJECT の場合は %node の子孫~nodeでもない”
】</p>

◎
If a node is following node and is not following root, set node to the first such node. Otherwise, return null.
   </li>

   <!--cp-set-filter-result-->
   <!--cp-set-current-if-accept-->
   <li>
（次の反復へ）
◎
Run these substeps again.
</li>

  </ol>
 </li>
</ol>

	</dd>
</dl>


		</section>
		<section id="interface-nodefilter">

<h3>6.3. ~ifc ^@NodeFilter</h3>

⇒！
[Exposed=Window]
callback interface @NodeFilter {
  // <span class="comment" title="Constants for acceptNode"
  ><code>$acceptNode()</code> 用の定数</span>
  ~CUS $FILTER_ACCEPT = 1;
  ~CUS $FILTER_REJECT = 2;
  ~CUS $FILTER_SKIP = 3;

  // <span class="comment" title="Constants for whatToShow bitmask"
  >`whatToShow ~bitmask$ 用の定数</span>
  ~CUL $SHOW_ALL = 0xFFFFFFFF;
  ~CUL $SHOW_ELEMENT = 0x1;
  ~CUL $SHOW_ATTRIBUTE = 0x2;
  ~CUL $SHOW_TEXT = 0x4;
  ~CUL $SHOW_CDATA_SECTION = 0x8;
  ~CUL @SHOW_ENTITY_REFERENCE = 0x10; // <!--cp-histroic-->
  ~CUL @SHOW_ENTITY = 0x20; // <!--cp-histroic-->
  ~CUL $SHOW_PROCESSING_INSTRUCTION = 0x40;
  ~CUL $SHOW_COMMENT = 0x80;
  ~CUL $SHOW_DOCUMENT = 0x100;
  ~CUL $SHOW_DOCUMENT_TYPE = 0x200;
  ~CUL $SHOW_DOCUMENT_FRAGMENT = 0x400;
  ~CUL @SHOW_NOTATION = 0x800; // <!--cp-histroic-->

  ~US @acceptNode($Node %node);
};
◎

<p>
$NodeFilter ~objは、`~filter~callback$として利用できる。
また、 `whatToShow ~bitmask$用の定数を提供する。
◎
NodeFilter objects can be used as filter callback and provide constants for the whatToShow bitmask.
</p>

<p class="note">注記：
概して， JavaScript 関数として実装される。
◎
It is typically implemented as a JavaScript function.
</p>

<p>
~callbackの返値には、次の定数が利用できる：
◎
These constants can be used as callback return value:
</p>

<table><thead><tr><th>定数  (値)
</th><th class="trans-note">意味【この列は、訳者による補足】
</th></tr></thead>

<tbody><tr><td style="white-space:nowrap;">@FILTER_ACCEPT (1)
</td><td class="trans-note">~nodeは`~filter$を “通過する”。

</td></tr><tr><td>@FILTER_REJECT (2)
</td><td class="trans-note">~nodeはその子孫も含めて “濾過される”（子孫は`~filter$にかけることなく除外される）。

</td></tr><tr><td>@FILTER_SKIP (3)
</td><td class="trans-note">~node自身は “濾過される” が、その子孫は，依然として`~filter$の対象になり得る。
</td></tr></tbody></table>

<p>
`whatToShow ~bitmask$には、次の定数が利用できる：
◎
These constants can be used for the whatToShow bitmask:
</p>

<ul><li>@SHOW_ALL (4294967295, 16進 FFFFFFFF)
</li><li>@SHOW_ELEMENT (1)
</li><li>@SHOW_ATTRIBUTE (2)
</li><li>@SHOW_TEXT (4)
</li><li>@SHOW_CDATA_SECTION (8)
</li><li>@SHOW_PROCESSING_INSTRUCTION (64, 16進 40)
</li><li>@SHOW_COMMENT (128, 16進 80)
</li><li>@SHOW_DOCUMENT (256, 16進 100)
</li><li>@SHOW_DOCUMENT_TYPE (512, 16進 200)
</li><li>@SHOW_DOCUMENT_FRAGMENT (1024, 16進 400)
</li></ul>


		</section>
	</section>
	<section id="sets">

<h2 title="Sets">7. Set</h2>

<p class="note">
Yes, the name $DOMTokenList is an unfortunate legacy mishap.
</p>

		<section id="interface-domtokenlist">

<h3>7.1. ~ifc ^@DOMTokenList</h3>

⇒！
interface @DOMTokenList {
  ~RA ~UL $length;
  getter ~DS? $item(~UL %index);
  ~B $contains(~DS %token);
  [`CEReactions$] void $add(~DS... %tokens);
  [`CEReactions$] void $remove(~DS... %tokens);
  [`CEReactions$] ~B $toggle(~DS %token, optional ~B %force);
  [`CEReactions$] void $replace(~DS %token, ~DS %newToken );
  ~B $supports(~DS %token);
  [`CEReactions$] @stringifier attribute ~DS $value;
  iterable&lt;~DS&gt;;
};
◎


<div class="p">
<p>
各 $DOMTokenList には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~tokens@</dt>
	<dd>
一連の~tokenからなる有順序~集合。
初期時は空。
</dd>

	<dt>`要素@dtl</dt>
	<dd>
`要素$。
</dd>
	<dt>`属性0の局所名@dtl</dt>
	<dd>
`属性0$の`局所名$a。
</dd>
	<dd>
`適用仕様$は、
$DOMTokenList のためとして，個々の`局所名$aに対し，~tokenの集合である
`被support~token集合@dtl
を定義して~MAY
— この集合は、特に指定されない限り未定義とする。
</dd>

</dl>

◎
A DOMTokenList object has an associated ordered set of tokens, which is initially empty.
◎
A DOMTokenList object also has an associated element and an attribute’s local name.
◎
Specifications may define supported tokens for a DOMTokenList's associated attribute’s local name.
</div>

<p>
$DOMTokenList ~obj %O において，所与の %~token を
`検証-@dtl
するときは、次を走らす：
◎
A DOMTokenList object’s validation steps for a given token are:
</p>

<ul>
 <li>
%~token集合 ~LET %O の`属性0の局所名$dtlに対する`被support~token集合$dtl
◎
↓</li>

 <li>
~IF［
%~token集合 は、未定義である
］
⇒
~THROW `TypeError^E
◎
If the associated attribute’s local name does not define supported tokens, throw a TypeError.
</li>
 <li>
~RET［
%~token の `~ASCII小文字化$ ~IN %~token集合 ならば ~T ／
~ELSE_ ~F
］
◎
Let lowercase token be a copy of token, converted to ASCII lowercase.
◎
If lowercase token is present in supported tokens, return true.
◎
Return false.
</li>
</ul>

<hr>


<p class="algo-head">
所与の $DOMTokenList ~obj %O 対し，
( %要素, %名前 )
は
( %O の`要素$dtl, %O の`属性0の局所名$dtl )
とするとき：
◎
↓</p>

<ul>
	<li>
%O の
`更新~手続き@
は、次を走らす
⇒
( %名前, ［
%O の`~tokens$を`有順序~集合 直列化器$にかけた結果
］ )
を用いて， %要素 の`属性0値を設定-$する
◎
A DOMTokenList object’s update steps are to set an attribute value for the associated element using associated attribute’s local name and the result of running the ordered set serializer for tokens.
</li>
	<li>
%O の
`直列化-手続き@
は、次を返す
⇒
( %名前 )
を用いて， %要素 から`属性0値を取得-$した結果
◎
A DOMTokenList object’s serialize steps are to return the result of running get an attribute value given the associated element and the associated attribute’s local name.
</li>

	<li>
<p>
%要素 上の`属性0を変更する手続き$は、次で与えられる：
◎
A DOMTokenList object has these attribute change steps for its associated element:
</p>

<ol>
 <li>
~IF［
%局所名 ~EQ %名前
］~AND［
%~ns ~EQ ~NULL
］
⇒
%O の`~tokens$ ~SET ［
%値 ~EQ ~NULL ならば空 ／
~ELSE_ %値 を`有順序~集合 解析器$にかけた結果
］
◎
If localName is associated attribute’s local name, namespace is null, and value is null, then set tokens to the empty set.
◎
Otherwise, localName is associated attribute’s local name, namespace is null, then set tokens to value, parsed.
</li>
</ol>
	</li>

	<li>
<p>
%O の作成-時には、次の手続きを走らす：
◎
When a DOMTokenList object is created, run these substeps:
</p>

<ol>
 <li>
%値 ~LET ［
( %名前, ~NULL )
を用いて， %要素 から`属性0を取得-$nsした結果
］の`値$a
◎
Let element be associated element.
◎
Let localName be associated attribute’s local name.
◎
Let value be the result of getting an attribute given null, localName, and element.
</li>
 <li>
次を渡して，
%要素 上の`属性0を変更する手続き$を走らす
⇒
( %名前, %値, %値, ~NULL )
◎
Run the attribute change steps for element, localName, value, value, and null.
</li>
</ol>
	</li>
</ul>








<dl class="domintro">
 <dt>%tokenlist . $length</dt>
 <dd>
~tokenの個数を返す。
◎
Returns the number of tokens.
</dd>

 <dt>%tokenlist . $item(index)</dt>
 <dt>%tokenlist[%index]</dt>
 <dd>
%index 番の~tokenを返す。
◎
Returns the token with index index.
</dd>

 <dt>%tokenlist . $contains(token)</dt>
 <dd>
%token が在れば~T を, 無ければ~F を返す。
◎
Returns true if token is present, and false otherwise.
</dd>

 <dt>%tokenlist . $add(tokens…)</dt>
 <dd>
渡された引数のうち，まだ無いものを追加する。
◎
Adds all arguments passed, except those already present.
</dd>
 <dd>
<span id="cp-throw-if-some-token-is">
<a href="#_throw-if-token-is">下記に該当する場合</a>、例外が投出される。
</span>
◎
Throws a SyntaxError if one of the arguments is the empty string.
◎
Throws an InvalidCharacterError if one of the arguments contains any ASCII whitespace.
</dd>

 <dt>%tokenlist . $remove(tokens…)</dt>
 <dd>
渡された引数のそれぞれを（もし在れば）除去する。
◎
Removes arguments passed, if they are present.
</dd>
 <dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a SyntaxError if one of the arguments is the empty string.
◎
Throws an InvalidCharacterError if one of the arguments contains any ASCII whitespace.
</dd>

 <dt>%tokenlist . $toggle(token [, force])</dt>
 <dd>
<p>
%force に応じて：
</p>

<ul>
	<li>
%force が省略されている場合、
%token の有無を “切り替える”。
すなわち、 %token がすでに在れば除去し，無ければ追加する。
</li>
	<li>
%force ~EQ ~T の場合、 %token を追加する（ $add() と同じ）。
</li>
	<li>
%force ~EQ ~F の場合、 %token を除去する（ $remove() と同じ）。
</li>
</ul>

<p>
その結果、 %token が残っていれば ~T を, 無くなっていれば ~F を返す。
</p>
◎
If force is not given, "toggles" token, removing it if it’s present and adding it if it’s not present. If force is true, adds token (same as add()). If force is false, removes token (same as remove()).
◎
Returns true if token is now present, and false otherwise.
</dd>
 <dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a SyntaxError if token is empty.
◎
Throws an InvalidCharacterError if token contains any spaces.
</dd>

 <dt>%tokenlist . $replace(token, newToken)</dt>
 <dd>
 <dd>
%token を %newToken で置換する。
◎
Replaces token with newToken.
</dd>
 <dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a SyntaxError if one of the arguments is the empty string.
◎
Throws an InvalidCharacterError if one of the arguments contains any ASCII whitespace.
</dd>

 <dt id="_throw-if-token-is">（例外）</dt>
 <dd>
<p>
上の各種~methに所与の文字列~引数のいずれかが，次に該当する場合、対応する例外が投出される：
</p>

  <ul id="cp-throw-if-token-B">
   <li>
空文字列の場合：
`SyntaxError^E
</li>
   <li>
`~ASCII空白類$を含む場合：
`InvalidCharacterError^E
</li>
  </ul>
◎
↑</dd>


 <dt>%tokenlist . $supports(token)</dt>
 <dd>
%token が`被support~token集合$dtlに含まれて［
いれば ~T ／ いなければ ~F
］を返す。
◎
Returns true if token is in the associated attribute’s supported tokens. Returns false otherwise.
</dd>
 <dd>
`属性0の局所名$dtlに対し，`被support~token集合$dtlが定義されていない場合、
`TypeError^E 例外が投出される。
◎
Throws a TypeError if the associated attribute has no supported tokens defined.
</dd>

 <dt>%tokenlist . $value</dt>
 <dd>
結付けられている`~tokens$を文字列として返す。
◎
Returns the associated set as string.
</dd>
 <dd>
設定して結付けられている属性を変更できる。
◎
Can be set, to change the associated attribute.
</dd>

</dl>


<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、［
此れの`~tokens$に含まれている~tokenの個数
］を返さ~MUST。
◎
The length attribute' getter must return the number of tokens in the tokens.
</dd>
</dl>

<p>
~objの`被support ~prop~index$の~~範囲は、［
0 〜
( 此れの`~tokens$に含まれている~tokenの個数 ~MINUS 1 )
］である（`~tokens$が空ならば~~範囲も空）。
◎
The object’s supported property indices are the numbers in the range zero to the number of tokens in tokens minus one, unless tokens is empty, in which case there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@item(index)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The item(index) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~RET ［
%index ~GTE ［
此れの`~tokens$に含まれている~tokenの個数
］ならば~NULL ／
~ELSE_ 此れの`~tokens$の中で %index 番の~token
］
◎
If index is equal to or greater than the number of tokens in tokens, return null.
◎
Return the indexth token in tokens.
</li>
</ol>

	</dd>
</dl>


<div>
<p class="algo-head">
所与の %token を
`検査する@dtl
ときは、次を走らす：
</p>

<ol>
 <li>
~IF［
%token ~EQ 空文字列
］
⇒
~THROW `SyntaxError^E
</li>

 <li>
~IF［
%token は`~ASCII空白類$を含んでいる
］
⇒
~THROW `InvalidCharacterError^E
</li>
</ol>

◎
↓↓</div>


<dl class="idl-def">
	<dt>@contains(token)</dt>
	<dd>
被呼出時には、［
%token ~IN 此れの`~tokens$ ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The contains(token) method, when invoked, must return true if token is in tokens, and false otherwise.
</dd>

	<dt>@add(tokens…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The add(tokens…) method, when invoked, must run these steps:
</p>


<ol>

 <li id="cp-throw-if-invalid-char">
~FOR
%tokens 内の~EACH ( %token ) に対し，与えられた順に
⇒
%token を`検査する$dtl
◎
For each token in tokens, run these substeps:
• If token is the empty string, then throw a SyntaxError.
• If token contains any ASCII whitespace, then throw an InvalidCharacterError.
</li>

 <li>
~FOR
%tokens 内の~EACH ( %token ) に対し，与えられた順に
⇒
~IF［
%token ~NIN 此れの`~tokens$
］
⇒
此れの`~tokens$に %token を付加する
◎
For each token in tokens, in given order, that is not in tokens, append token to tokens.
</li>

 <li id="cp-update-TL">
`更新~手続き$を走らす
◎
Run the update steps.
</li>
<!-- 
追加が生じなかった場合にも更新~手続きは実行されることになる。
 -->
</ol>
	</dd>

	<dt>@remove(tokens…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The remove(tokens…) method, when invoked, must run these steps:
</p>

<ol>
 <!--cp-throw-if-invalid-char-->
 <li>
%tokens 内の各 %token に対し
⇒
~IF［
%token ~IN 此れの`~tokens$
］
⇒
此れの`~tokens$から %token を除去する
◎
For each token in tokens, remove token from tokens.
</li>

 <!--cp-update-TL-->

</ol>
	</dd>

	<dt>@toggle(token, force)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The toggle(token, force) method, when invoked, must run these steps:
</p>

<ol>
 <li>
%token を`検査する$dtl
◎
If token is the empty string, then throw a SyntaxError.
◎
If token contains any ASCII whitespace, then throw an InvalidCharacterError.
</li>

 <li>
<p>
~IF［
%token ~IN 此れの`~tokens$
］：
◎
If token is in tokens, run these substeps:
</p>

  <ol>
   <li>
~IF［
%force は渡されていない
］~OR［
%force ~EQ ~F 
］
⇒
此れの`~tokens$から %token を除去する；<br>
`更新~手続き$を走らす；<br>
~RET ~F
◎
If force is either not passed or is false, then remove token from tokens, run the update steps, and return false.
</li>

 <li>
~ELSE
⇒
~RET ~T
◎
Otherwise, return true.
</li>
  </ol>
 </li>


 <li>
<p>
~ELSE：
◎
Otherwise, run these substeps:
</p>
  <ol>
   <li>
~IF［
%force は渡されている
］~AND［
%force ~EQ ~F
］
⇒
~RET ~F
◎
If force is passed and is false, return false.
</li>
   <li>
此れの`~tokens$に %token を付加する；<br>
`更新~手続き$を走らす；<br>
~RET ~T
◎
Otherwise, append token to tokens, run the update steps, and return true.
</li>
  </ol>
 </li>
</ol>
	</dd>

	<dt>@replace(token, newToken)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The replace(token, newToken) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%token ~EQ 空文字列
］~OR［
%newToken ~EQ 空文字列
］
⇒
~THROW `SyntaxError^E
◎
If either token or newToken is the empty string, then throw a SyntaxError.
</li>
 <li>
~IF［
%token は`~ASCII空白類$を含んでいる
］~OR［
%newToken は`~ASCII空白類$を含んでいる
］
⇒
~THROW `InvalidCharacterError^E
◎
If either token or newToken contains any ASCII whitespace, then throw an InvalidCharacterError.
</li>
 <li>
~IF［
%token ~NIN %tokens
］
⇒
~RET
◎
If token is not in tokens, terminate these steps.
</li>
 <li>
此れの`~tokens$内の %token を %newToken に置換する
◎
Replace token in tokens with newToken.
</li>
 <!--cp-update-TL-->
</ol>

	</dd>
	<dd class="trans-note">【
最初と二番目の段は、
%token, %newToken を順に`検査する$dtlのとは，挙動が異なる（意図的？）。
】</dd>

	<dt>@supports(token)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The supports(token) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~RET 此れにおいて %token を`検証-$dtlした結果
（例外投出あり）
◎
Let result be the return value of validation steps called with token. Rethrow any exceptions.
◎
Return result.
</li>
</ol>
	</dd>

	<dt>@value</dt>
	<dd>
取得子は、此れの`直列化-手続き$を走らせた結果を返さ~MUST。
◎
The value attribute must return the result of running context object’s serialize steps.
</dd>
	<dd>
設定子は、
( 此れの［
`属性0の局所名$dtl
］, 所与の値 )
を用いて，［
此れの`要素$dtl
］の`属性0値を設定-$し~MUST。
◎
Setting the value attribute must set an attribute value for the associated element using associated attribute’s local name and the given value.
</dd>

</dl>

		</section>
	</section>
	<section id="historical">

<h2 title="Historical">8. 歴史（変更点）</h2>

<p>
<a href="#goals">目標</a>
にて説明したように，この仕様は種々の~DOM仕様の大きな改訂である。
この節では変更点の列挙を試みる。
◎
As explained in goals this specification is a significant revision of various DOM specifications. This section attempts to enumerate the changes.
</p>

		<section id="dom-events-changes">

<h3>8.1. DOM Events</h3>

<p>
以下は
`DOM Level 3 Events^cite
の［
"DOM Event Architecture",
"Basic Event Interfaces",
"Mutation Events",
"Mutation Name Event Types"
］各~章に述べられた特色機能に加えられた変更点である。
他の章は
`UI Events^cite 仕様 `UIEVENTS$r
に移行されるものと期待されている。
◎
These are the changes made to the features described in the "DOM Event Architecture", "Basic Event Interfaces", "Mutation Events", and "Mutation Name Event Types" chapters of DOM Level 3 Events. The other chapters are defined by the UI Events specification. [UIEVENTS]
</p>

<ul>
 <li>
~eventは今や構築子を持つ。
◎
Events have constructors now.
</li>

 <li>
@MutationEvent,
@MutationNameEvent
は除去された。
◎
Removes MutationEvent, and MutationNameEvent.
</li>

 <li>
発火-（ fire ）は今や配送（ dispatch ）の同義語ではなく，~eventの初期化も含む。
◎
Fire is no longer synonymous with dispatch, but includes initializing an event.
</li>

 <li>
`伝播停止$f（`伝播即停止$f）と`被取消$fは、配送~後ではなく，
$Event.initEvent()
を呼出した時に~OFF にされる。
◎
The propagation and canceled flags are unset when invoking initEvent() rather than after dispatch.
</li>
</ul>


		</section>
		<section id="dom-core-changes">

<h3>8.2. DOM Core</h3>

<p>
以下は
`DOM Level 3 Core^cite
で述べられた特色機能に加えられた変更点である。
◎
These are the changes made to the features described in DOM Level 3 Core.
</p>

<p>
$DOMString,
$DOMException,
$DOMTimeStamp
は、今や Web IDL にて定義される。
◎
DOMString, DOMException, and DOMTimeStamp are now defined in Web IDL.
</p>

<p>
$Node は今や $EventTarget を継承する。
◎
Node now inherits from EventTarget.
</p>

<p>
`~node$は`文書$ 間を超えて暗黙的に`受入-$される。
◎
Nodes are implicitly adopted across document boundaries.
</p>

<p>
`文書型$は今や常に`~node文書$を持ち，`文書$ 間を超えて移動できる。
◎
Doctypes now always have a node document and can be moved across document boundaries.
</p>

<p>
$ProcessingInstruction は今や
$CharacterData を継承する。
◎
ProcessingInstruction now inherits from CharacterData.
</p>


<p>
<!-- @@Node -->
@hasAttributes(),
@attributes
は、
$Node から $Element へ移動された。
◎
hasAttributes() and attributes moved from Node to Element.
</p>

<p>
@namespaceURI,
@prefix,
@localName
は、
$Node から $Element, $Attr へ移動された。
◎
namespaceURI, prefix, and localName moved from Node to Element and Attr.
</p>

<p>
この節に挙げる，残りの~ifcと~ifc~memberは、~DOM~platformを単純化するために取り除かれた。
この仕様に適合する実装が それらを~supportすることはない。
◎
The remainder of interfaces and interface members listed in this section were removed to simplify the DOM platform. Implementations conforming to this specification will not support them.
</p>


<p class="warning">警告：
以下の特色機能がすべて取り除かれても Web 互換性が保たれるかどうかは、はっきりしない部分もある。
これらの特色機能の一部について，再~導入されるべき根拠を示す~dataがあれば、編集者まで寄せられるよう願う。
◎
It is not yet clear if it would be web-compatible to remove all the following features. The editors welcome any data showing that some of these features should be reintroduced.
</p>

<p>
~ifc：
◎
Interfaces:
</p>

<ul ><li>@DOMConfiguration
</li><li>@DOMError
</li><li>@DOMErrorHandler
</li><li>@DOMImplementationList
</li><li>@DOMImplementationSource
</li><li>@DOMLocator
</li><li>@DOMObject
</li><li>@DOMStringList
</li><li>@DOMUserData
</li><li>@Entity
</li><li>@EntityReference
</li><li>@NameList
</li><li>@Notation
</li><li>@TypeInfo
</li><li>@UserDataHandler
</li></ul>

<p>
~ifc~member：
◎
Interface members:
</p>

<dl>
 <dt>$@Node</dt>
 <dd>
<ul><li>@isSupported
</li><li>@getFeature()
</li><li>@getUserData()
</li><li>@setUserData()
</li></ul>

 </dd>
 <dt>$@Document</dt>
 <dd>
<ul><li>@createCDATASection()
</li><li>@createEntityReference()
</li><li>@xmlEncoding
</li><li>@xmlStandalone
</li><li>@xmlVersion
</li><li>@strictErrorChecking
</li><li>@domConfig
</li><li>@normalizeDocument()
</li><li>@renameNode()
</li></ul>

 </dd>
 <dt>$@DOMImplementation</dt>
 <dd>
  <ul>
<li>@getFeature()</li>
  </ul>

 </dd>
 <dt>$@Attr</dt>
 <dd>
<ul><li>@schemaTypeInfo
</li><li>@isId
</li></ul>
 </dd>

 <dt>$@Element</dt>
 <dd>
<ul><li>@schemaTypeInfo
</li><li>@setIdAttribute()
</li><li>@setIdAttributeNS()
</li><li>@setIdAttributeNode()
</li></ul>
 </dd>
 <dt>$@DocumentType</dt>
 <dd>
<ul><li>@entities
</li><li>@notations
</li><li>@internalSubset
</li></ul>

 </dd>
 <dt>$@Text</dt>
 <dd>
<ul><li>@isElementContentWhitespace
</li><li>@replaceWholeText()
</li></ul>
 </dd>
</dl>

		</section>
		<section id="dom-range-changes">

<h3>8.3. DOM Ranges （範囲0）</h3>

<p>
以下は
`DOM Level 2 Traversal and Range^cite.
の "Document Object Model Range"
章にて述べられている特色機能に加えられた変更点である。
◎
These are the changes made to the features described in the "Document Object Model Range" chapter of DOM Level 2 Traversal and Range.
</p>

<ul>
	<li>
@RangeException
は取り除かれた。
◎
RangeException has been removed.
</li>


	<li>
$@Range ~objは今や`文書$ 間で移動でき，
`文書~木~内$にない`~node$にも利用できる。
◎
Range objects can now be moved between documents and used on nodes that are not in a document tree.
</li>


	<li>
素の $Range() 構築子が出現。
◎
A wild Range() constructor appeared.
</li>

	<li>
新たな~meth
$comparePoint(),
$intersectsNode(),
$isPointInRange()
が追加された。
◎
New methods comparePoint(), intersectsNode(), and isPointInRange() have been added.
</li>

	<li>
$detach は今や何もしない。
◎
detach() is now a no-op.
</li>

	<li>
<a href="#dom-range-stringifier">^toString</a>
は、今や IDL を通して定義される。
◎
toString is now defined through IDL.
</li>

</ul>

		</section>
		<section id="dom-traversal-changes">

<h3>8.4. DOM Traversal （走査）</h3>

<p>
以下は
`DOM Level 2 Traversal and Range^cite
の "Document Object Model Traversal" 章にて述べられている
特色機能に加えられた変更点である。
◎
These are the changes made to the features described in the "Document Object Model Traversal" chapter of DOM Level 2 Traversal and Range.
</p>

<ul>
 <li>
$@Document の
$createNodeIterator(),
$createTreeWalker()
は、今や省略可の引数をとり，最早~DOMには決して取り入れられることはない実体参照を与える４個目の引数は除かれた。
◎
createNodeIterator() and createTreeWalker() now have optional arguments and lack a fourth argument which is no longer relevant given entity references never made it into the DOM.
</li>

 <li>
前述の理由により，
@NodeIterator.expandEntityReferences
属性は $NodeIterator および $TreeWalker ~ifcから除去された。
◎
The expandEntityReferences attribute has been removed from the NodeIterator and TreeWalker interfaces for the aforementioned reason.
</li>

 <li>
~proprietary拡張による実装に足並みを揃えるため、
$@NodeIterator ~objに
$referenceNode, $pointerBeforeReferenceNode
属性が追加された。
◎
The referenceNode and pointerBeforeReferenceNode attributes have been added to NodeIterator objects to align with proprietary extensions of implementations.
</li>

<li>
~UA に足並みを揃えるため、
$nextNode() と $previousNode() は今や
$NodeFilter から呼出されたときに例外を投出し得る。
◎
nextNode() and previousNode() now throw when invoked from a NodeFilter to align with user agents.
</li>


 <li>
$detach は今や何もしない。
◎
detach() is now a no-op.
</li>

</ul>

		</section>
	</section>
</main><!-- id="MAIN" -->

	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り、 DOM を相互運用可能にするために，たくさんの方々が助力され、この標準の目標へ近付けてきた。
同様に多くの方々の助力が，この標準を現在の姿に仕立て上げてきた。
<span lang="en">
There have been a lot of people that have helped make DOM more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</span></p>

<p>
With that, many thanks to

Adam Klein,
Adrian Bateman,
Aleksey Shvayka,
Alex Komoroske,
Alex Russell,
Anthony Ramine,
Arkadiusz Michalski,
Arnaud Le Hors,
Arun Ranganathan,
Björn Höhrmann,
Boris Zbarsky,
Brandon Payton,
Brandon Slade,
Brandon Wallace,
Brian Kardell,
Cameron McCormack,
Chris Dumez,
Chris Paris,
Chris Rebert,
Daniel Glazman,
Darin Fisher,
David Bruant,
David Flanagan,
David Håsäther,
David Hyatt,
Deepak Sherveghar,
Dethe Elza,
Dimitri Glazkov,
Domenic Denicola,
Dominic Cooney,
Dominique Hazaël-Massieux,
Don Jordan,
Doug Schepers,
Elisée Maurer
Elliott Sprehn,
Eric Bidelman,
Erik Arvidsson,
Gavin Nicol,
Geoffrey Sneddon,
Giorgio Liscio,
Glen Huang,
Glenn Adams,
Glenn Maynard,
Hajime Morrita,
Harald Alvestrand,
Hayato Ito,
Henri Sivonen,
Hunan Rostomyan,
Ian Hickson,
Igor Bukanov,
Jacob Rossi,
Jake Archibald,
Jake Verbaten,
James Graham,
James Greene,
James Robinson,
Jeffrey Yasskin,
Jens Lindström,
Jesse McCarthy,
João Eiras,
Joe Kesselman,
John Atkins,
Jonas Sicking,
Jonathan Robie,
Joris van der Wel,
Joshua Bell,
Jungkee Song,
Justin Summerlin,
呂康豪 (Kang-Hao Lu),
Kevin Sweeney,
Koji Ishii,
Lachlan Hunt,
Lauren Wood,
Malte Ubl,
Manish Goregaokar,
Manish Tripathi,
Marcos Caceres,
Mark Miller,
Mats Palmgren,
Mounir Lamouri,
Michael™ Smith,
Mike Champion,
Mike Taylor,
Ojan Vafai,
Oliver Nightingale,
Olli Pettay,
Ondřej Žára,
Peter Sharpe,
Philip Jägenstedt,
Philippe Le Hégaret,
Rafael Weinstein,
Richard Bradshaw,
Rick Byers,
Rick Waldron,
Robbert Broersma,
Robin Berjon,
Roland Steiner,
Rune <span title="Fabulous">F.</span> Halvorsen,
Ruud Steltenpool,
Ryosuke Niwa,
Sam Dutton,
Samuel Giles,
Sebastian Mayr,
Seo Sanghyeon,
Sergey G. Grekhov,
Shiki Okasaka,
Shinya Kawanaka,
Simon Pieters,
Steve Byrne,
Stig Halvorsen,
Tab Atkins,
Takashi Sakamoto,
Takayoshi Kochi,
Theresa O’Connor,
<i>timeless</i>,
Timo Tijhof,
Tobie Langel,
Tom Pixley,
Travis Leithead,
<i>triple-underscore</i>,
Veli Şenol,
Vidur Apparao,
Warren He,
Yehuda Katz,
Yoav Weiss,
Yoichi Osato,
Yoshinori Sano, and
Zack Weinberg

for being awesome!
</p>

<p>
This standard is written by
<a href="//annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="//www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>) with substantial contributions from
Aryeh Gregor (<a href="//www.mozilla.org/">Mozilla</a>,
<a href="mailto:ayg@aryeh.name">ayg@aryeh.name</a>)
and Ms2ger (<a href="//www.mozilla.org/">Mozilla</a>,
<a href="mailto:ms2ger@gmail.com">ms2ger@gmail.com</a>).
</p>

<p>
Part of the revision history of the integration points related to <a href="#concept-element-custom">custom</a> elements can be
found in <a href="https://github.com/w3c/webcomponents">the w3c/webcomponents repository</a>, which
is available under the <a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">W3C Permissive Document License</a>.
</p>

<p>
Per <a href="//creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>,
to
the extent possible under law, the editors have waived all copyright and related or neighboring rights to this work.
</p>


	</section>
	<section id="index">
<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>
	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>



<dl>

	<dt>[CSS-ANIMATIONS-1]</dt>
	<dd>CSS Animations Module Level 1</dd>
	<dd>https://drafts.csswg.org/css-animations-1/</dd>

	<dt>[CSS-TRANSITIONS-1]</dt>
	<dd>CSS Transitions Module Level 1</dd>
	<dd>https://drafts.csswg.org/css-transitions-1/</dd>

	<dt>[CSS3-ANIMATIONS]</dt>
	<dd>Dean Jackson; et al. CSS Animations. 19 February 2013. WD.</dd>
	<dd>https://www.w3.org/TR/css3-animations/</dd>

	<dt>[CSS3-TRANSITIONS]</dt>
	<dd>Dean Jackson; et al. CSS Transitions. 19 November 2013. WD.</dd>
	<dd>http://dev.w3.org/csswg/css-transitions/</dd>

	<dt>[DEVICE-ORIENTATION]</dt>
	<dd>Rich Tibbett; et al. DeviceOrientation Event Specification. 18 August 2016. CR.</dd>
	<dd>https://www.w3.org/TR/orientation-event/</dd>
	<dd>https://w3c.github.io/deviceorientation/spec-source-orientation.html</dd>

	<dt>[ECMASCRIPT]</dt>
	<dd>ECMAScript Language Specification.</dd>
	<dd>https://tc39.github.io/ecma262/</dd>

	<dt>[ENCODING]</dt>
	<dd>Anne van Kesteren. Encoding Standard. Living Standard.</dd>
	<dd>https://encoding.spec.whatwg.org/</dd>

	<dt>[HTML]</dt>
	<dd>Ian Hickson. HTML Standard. Living Standard.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

	<dt>[RFC2119]</dt>
	<dd>S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc2119</dd>

	<dt>[SELECTORS-4]</dt>
	<dd>Selectors Level 4</dd>
	<dd>https://drafts.csswg.org/selectors-4/</dd>

	<dt>[SELECTORS4]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 2 May 2013. WD.</dd>
	<dd>https://www.w3.org/TR/selectors4/</dd>

	<dt>[SERVICE-WORKERS]</dt>
	<dd>Alex Russell; Jungkee Song; Jake Archibald. Service Workers. 25 June 2015. WD.</dd>
	<dd>https://slightlyoff.github.io/ServiceWorker/spec/service_worker/</dd>

	<dt>[SVG]</dt>
	<dd>Jon Ferraiolo. Scalable Vector Graphics (SVG) 1.0 Specification. 4 September 2001. REC.</dd>
	<dd>https://www.w3.org/TR/SVG/</dd>

	<dt>[TOUCH-EVENTS]</dt>
	<dd>Doug Schepers; et al. Touch Events. 10 October 2013. REC.</dd>
	<dd>http://dvcs.w3.org/hg/webevents/raw-file/v1/touchevents.html</dd>

	<dt>[UIEVENTS]</dt>
	<dd>Gary Kacmarcik; Travis Leithead. UI Events. 4 August 2016. WD.</dd>
	<dd>https://github.com/w3c/uievents/</dd><!-- ＊github -->
	<dd>https://w3c.github.io/uievents/</dd>

	<dt>[URL]</dt>
	<dd>Anne van Kesteren. URL Standard. Living Standard.</dd>
	<dd>https://url.spec.whatwg.org/</dd>

	<dt>[WEBGL]</dt>
	<dd>Chris Marrin (Apple Inc.). WebGL Specification, Version 1.0. 10 February 2011.</dd>
	<dd>https://www.khronos.org/registry/webgl/specs/1.0/</dd>

	<dt>[WEBIDL]</dt>
	<dd>Cameron McCormack; Boris Zbarsky. WebIDL Level 1. 8 March 2016. CR.</dd>
	<dd>https://heycam.github.io/webidl/</dd>

	<dt>[XHR]</dt>
	<dd>Anne van Kesteren. XMLHttpRequest Standard. Living Standard.</dd>
	<dd>https://xhr.spec.whatwg.org/</dd>

	<dt>[XML]</dt>
	<dd>Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC.</dd>
	<dd>https://www.w3.org/TR/xml</dd>

	<dt>[XML-NAMES]</dt>
	<dd>Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC.</dd>
	<dd>https://www.w3.org/TR/xml-names</dd>
</dl>


		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>


<dl>

	<dt>[CSSOM-VIEW]</dt>
	<dd>Simon Pieters. CSSOM View Module. 17 March 2016. WD.</dd>
	<dd>https://drafts.csswg.org/cssom-view/</dd>

	<dt>[DOM-Level-2-Traversal-Range]</dt>
	<dd>Joseph Kesselman; et al. Document Object Model (DOM) Level 2 Traversal and Range Specification. 13 November 2000. REC.</dd>
	<dd>https://www.w3.org/TR/DOM-Level-2-Traversal-Range/</dd>

	<dt>[DOM-Level-3-Core]</dt>
	<dd>Arnaud Le Hors; et al. Document Object Model (DOM) Level 3 Core Specification. 7 April 2004. REC.</dd>
	<dd>https://www.w3.org/TR/DOM-Level-3-Core/</dd>

	<dt>[DOM-Parsing]</dt>
	<dd>Travis Leithead. DOM Parsing and Serialization. 17 May 2016. WD.</dd>
	<dd>https://w3c.github.io/DOM-Parsing/</dd>

	<dt>[ELEMENTTRAVERSAL]</dt>
	<dd>Doug Schepers; Robin Berjon. Element Traversal Specification. 22 December 2008. REC.</dd>
	<dd>https://www.w3.org/TR/ElementTraversal/</dd>

	<dt>[INDEXEDDB]</dt>
	<dd>Nikunj Mehta; et al. Indexed Database API. 8 January 2015. REC.</dd>
	<dd>http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html</dd>

	<dt>[SELECTORS-API2]</dt>
	<dd>Lachlan Hunt. Selectors API Level 2. 17 October 2013. NOTE.</dd>
	<dd>http://dev.w3.org/2006/webapi/selectors-api2/</dd>

	<dt>[UIEVENTS-20031107]</dt>
	<dd>Philippe Le Hégaret; Tim Pixley. Document Object Model (DOM) Level 3 Events Specification. 7 November 2003. NOTE.</dd>
	<dd>https://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107</dd>
</dl>

		</section>
	</section>
	<section id="idl-index">
<h2 title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>


<!-- 
	●他の語

参照文献: 1
謝辞: 1
整理統合: 1
大文字: 1
省略: 1
命令的な句: 1
先頭部: 1
引用: 1
最終的: 1
考慮: 1
攻撃: 1
防止: 1
保護: 1
回避: 1
行為: 1
懸案: 1
悪化: 1
細分化: 1
慣用表現: 1
比較: 1
大小比較: 1
所属: 1
増減操作: 1
加減算: 1
実行制御: 1
アルゴリズム: 1
処理内容: 1
継続: 1
親子関係: 1
次節: 1
容易: 1
有限個: 1
全順序集合: 1
部分集合: 1
付記: 1
有限: 1
表現: 1
可視化: 1
上下関係: 1
階層: 1
入子階層: 1
各赤色区間: 1
根元: 1
簡単: 1
広義: 1
対訳: 1
忠実: 1
意義: 1
兄弟: 1
共有: 1
原因:cause
箇所: 1
同一視: 1
末尾部分: 1
各項: 1
計画-:plan:~
目的: 1
一環: 1
手品:magic 1
今度: 1
様子: 1
一度目: 1
度目: 1
現在: 1
実行-中: 1
余分: 1
起点: 1
幅広: 1
正確: 1
片道: 1
合間: 1
時点以降: 1
発生: 1
検知: 1
略語: 1
処理過程: 1
言葉を代えれば:Phrased differently,
通知: 1
進路:future course 1
起動: 1
強調: 1
小論:essays 1
報告書:reports 1
本格的:fully-fledged 1
任意: 1
~~仕組:magic 1
出来上: 1
探求: 1
最高: 1
関係性: 1
後述: 1
位置変化: 1
対称: 1
策定者: 1
混在: 1
十分: 1
判断: 1
不要: 1
単純: 1
無限増殖: 1
見受: 1
類似: 1
一種: 1
指示: 1
不明: 1
依存: 1
ループ: 1
動的: 1
反復対象: 1
選択: 1
名称: 1
的外: 1
否認: 1
一列目: 1
二列目: 1
基本: 1
~~言明:claim 1
経験: 1
信頼: 1
不十分: 1
判明: 1
最早: 1
公開: 1
外部: 1
複数: 1
一対一: 1
未定義: 1
誤記: 1
特別: 1
機能上: 1
同等: 1
編集: 1
両者: 1
括弧: 1
一個一個: 1
見立: 1
一列: 1
例外: 1
一個: 1
ドット: 1
先掲: 1
横線直下: 1
本数: 1
各数字: 1
孤立: 1
位置関係: 1
算出: 1
前掲: 1
定義: 1
理解: 1
事実: 1
上述: 1
ブロック: 1
整合性: 1
説明用: 1
見通: 1
変形: 1
前段: 1
否定: 1
図左: 1
カット: 1
相当: 1
機能的: 1
削除: 1
組合: 1
簡略化: 1
不変: 1
段階: 1
区間: 1
付与: 1
全部的: 1
包含: 1
追加: 1
最下位: 1
概念的: 1
開始地点: 1
逆向: 1
通過: 1
二番目: 1
列挙: 1
警告: 1
根拠: 1
編集者:editors
完全: 1
最早: 1
前述: 1
	各種用語: 2
	日本語訳: 2
固有: 2
	表記規約: 2
歴史:historical
問題: 2
操作: 2
図式: 2
出現: 2
制限: 2
一義的: 2
太字: 2
共通: 2
詳細: 2
表記: 2
非公式: 2
前順: 2
優先: 2
一例: 2
構成: 2
全体: 2
~~制御:key off
以外: 2
ミリ: 2
秒数: 2
効果: 2
閏秒:leap seconds 2
反復: 2
総称: 2
何故: 2
複数個: 2
条件: 2
関係: 2
	括弧内: 2
後続: 2
	未策定: 2
項目: 2
一方: 2
列目: 2
無用の長物:useless 1
有用: 2
区別: 2
末尾側: 2
非負: 2
仮想: 2
隙間: 2
赤色区間: 2
直上: 2
左側: 2
便宜のため:For convenience  1
両方: 2
上図: 2
状態: 2
図右: 2
自体: 2
実行後: 2
相対位置: 2
適宜: 2
	訳者: 2
	前回: 2
妥当性: 2
足並: 2
移行: 3
用語: 3
	簡潔: 3
現時点: 3
全順序:linear 1: 3
番目: 3
左端: 3
最上層: 3
逆順:reverse 3
用途: 3
要求: 3
依然: 3
参考: 3
末端: 3
一致: 3
除外: 3
連続: 3
存続: 3
唯一: 3
挿入点: 3
差分: 3
隣接: 3
内側: 3
直下: 3
片方: 3
始端: 3
両端: 3
実行例: 3
濾過: 3
探索: 3
見出: 3
発生:occurrence
次に起きる出来事:what happens next 1
方式:style 2
右端: 4
厳密: 4
無視: 4
各種: 4
真偽値: 4
一連: 4
補足: 4
補完
終端: 4
可能: 5
規定: 5
終了: 5
参照: 5
模式図: 5
個以上: 5
以前: 5
個目: 5
縦棒: 5
緑色区間: 5
下図: 5
相対点: 5
下記: 5
概説:introduction to 3
横線: 6
直後: 6
時点: 6
外側: 6
記号: 7
理由:mishaps／because 
青色区間: 7
原文: 8
対象: 8
地点: 8
該当: 8
基準点: 8
開始-:start:~
開始: 9
末尾: 9
注意: 9
存在: 11
直前: 11
内部: 11
記述: 12
部分: 12
一部: 14
対応: 14
同様: 14
処理: 15
以下: 16
下位: 16
自身: 17
必要: 18
先頭: 18
満た: 19
内容: 19
個数: 21
範囲: 23
意味-:mean 27
意味:meaning 27
入力: 31
最後: 33
位置: 35
利用: 45
最初: 55
注記: 61
結果:result／- 141
実行:run/execute 149
場合: 164

	●
揃わせ:Aligning
代わるもの:replacement
ミリ秒:msec 2
表され:express
並び:sequence of
特に:in particular
節:section:~
~~特にspecificalに
~~強調called out
働きかける:influence
誤った考え:wrong ideas
人:folks:
~~起動するもの initiators
particular
不要にするreplaces the need
廃するrid of
あいにくUnfortunately,
hairy
何もしないno-op:~
	消去~clear
論を交わしたければdiscussion
~F に ~clear
初めて:very first
割り当てられる:allocate
ごく限られた~~状況:very specific circumstances.
組:tuple
永遠に forever
直面:in the face of
初回:first time
-->

</body>
</html>

