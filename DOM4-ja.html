<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>DOM Standard 日本語訳</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<!--%内容置換生成 -->
<script >

var source_data;

COMMON_DATA.init = function(expanded){

	var options = {
		spec_status: 'LS',
		original_url: 'https://dom.spec.whatwg.org/',
		main: 'MAIN',
		ref_data: '.ref_data',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};

	if(expanded) return options;


	var ifc_names = E('_ifc_names').firstChild.data
	.replace(/^\w+$/mg, function(name){
		return name + ':#' + name.toLowerCase();
	});

	source_data = {
		html : E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		ifc_names: Util.get_mapping(ifc_names),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:漢字＋英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

/*
	repeat('dl.idl-def > dt', function(e){
		e.parentNode.replaceChild(C('p'), e)
	});
	Util.del_j(); // checked: 160420 spec
*/

	return options;
}

function expand(mapping1){
	E('MAIN').innerHTML = Util.replaceWords1(create_html(this), mapping1);

// 要素複製 ( Opera requires optional args, null, null)
	var visited = Object.create(null), node, e;
	var it = document.createNodeIterator(E('MAIN'), NodeFilter.SHOW_COMMENT, null, null);
	while(node = it.nextNode()){
		var id = node.data;
		if(id.slice(0,3) !== 'cp-') continue;
		e = visited[id];
		if(!e) {
			e = E(id);
			if(e) {
				e.removeAttribute('id');
				visited[id] = e;
			} else {
				console.log('source undefined:' + id);
				continue;
			}
		}
		node.parentNode.replaceChild(e.cloneNode(true), node);
	}
}

function create_html(source_data){
	var link_map = source_data.link_map;
	var ifc_names = source_data.ifc_names;

	var in_idl = false;
	var nesting = ''
	, context_ifc = '';// prefix 省略時の既定 interface 名
	return source_data.html.replace(
		/⇒[！＃]*\s*|◎[^<◎]*|%[\w\-~一-鿆あ-ん]+|([\^@$]@?)([\w\.]+)(\([ \w,\[\]=…]*\))?|`(.+?)([\^@$])(\w*)/g,
		replacer
	);

	function bpGenerate(str){
		return '<div class="bp-example">'
		+ str.replace(/([\|\[\]\(\)])(\w?)/g, function(match, t, w){
			switch(t) {
			case '|':
				return w ? '<span class="m">|<br>' + w + '</span>' : '|';
			case '(':
				return w ? '<i class="' + w + '">' : '<i>';
			case '[':
				return w ? '<b class="' + w + '">' : '<b>';
			case ')':
				return '</i>';
			case ']':
				return '</b>';
			}
		})
		+ '</div>';
	}

	function replacer(match, ind0, key, args, text, ind2, suffix){
		if(text){
			var href;
			var key = text;
			suffix = suffix || '';
			switch(suffix){
			case 'r':
				return (
'<a href="#biblio-' + text.toLowerCase() + '">[' +  text  + ']</a>'
				);
				break;
			case 'b': // 
				return '<b>' + text + '</b>';
				break;
			case 'i': // 
				text = '<i>' + text + '</i>';
				break;
			case 'l': // literal
				text = '"<code class="literal">' + text + '</code>"';
				break;
			case 'E':
				text = '<code class="error">' + text + '</code>';
				break;
			case 'e': // element tag
				text = '<code class="element">' + text + '</code>';
				break;
			case 'A': // attr name
				text = '<code class="attr">' + text + '</code>';
				break;
			case 'et': // event type
				text = '<code class="event-type">' + text + '</code>';
				break;
			case 'prod': // 生成規則
				text = '<code class="production">' + text + '</code>';
				break;
			case 'm': // idl member (external)
			case 'c': // codes
				text = '<code>' + text + '</code>';
				break;
			case 'V': // var
				text = '<var>' + text + '</var>';
				break;
			case 'f': // flags
				text = '<i class="flag">' + text + '~flag</i>';
				break;
			case 'bpex':
				return bpGenerate(text);
				break;
			case 'cite':
				return '<cite>' + text + '</cite>';
				break;
			case 'tnote': 
				return '<span class="trans-note">【' + text + '】</span>';
				break;
			default:
				break;
			}
			if(ind2 === '^'){
				return text;
			}
			href = link_map[suffix ? key + '.' + suffix : key];
			if(!href){
				console.log(text);
				return match;
			}
			switch(ind2){
			case '$': 
				return '<a href="' + href + '">' + text + '</a>';
			case '@':
				return '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
			}
			return match;
		} else if(key){
			// idl contructs
			var text = key, href;
			if(!args && ( key in ifc_names ) ){
				href = ifc_names[key];
				if(ind0.length > 1){
//				if(ind0[1] === '@'){
					context_ifc = key;//.toLowerCase();
				}
			} else {
				var ifc = context_ifc;
				var dot = key.indexOf('.');
				if(dot >=0 ){
					ifc = key.slice(0, dot);
					key = text = key.slice(dot + 1); //text
				}
				href = (
					'#dom-' + ifc + '-' + (
						(key === 'Constructor') ? ifc : key
					)
				).toLowerCase();
				if(args){
text += args.replace(/(\w+)(\s=\s\w+)?/g, '<var>$1</var>$2');
				}
			}
			if(!in_idl){
				text = '<code>' + text + '</code>';
			}

			switch(ind0[0]){
			case '^':
				return text;
			case '$':
				return '<a href="' + href + '" >' + text + '</a>';
			case '@':
				return '<dfn id="' + href.slice(1) + '" >' + text + '</dfn>';
			}
		} else {
			switch(match[0]){
			case '%':
				return '<var>' + match.slice(1) + '</var>';
			case '⇒':
				switch(match[1]){
				case '！':
					in_idl = true;
					nesting += '</pre>';
					return '<pre class="idl">';
				case '＃':
					nesting += '</span>';
					return '：<span class="block preline">';
				default:
					nesting += '</span>';
					return '：<span class="block">';
				}
			case '◎':
				var result;
				if(in_idl) {
					result = nesting;
					in_idl = false;
				} else {
					result =
						nesting
						+ '<span lang="en">'
						+ match.slice(1).trim()
						+ '</span>';
				}
				nesting = '';
				return result;
			default: // 
				return match;
			}
		}
	}
}
</script>


<!--%置換データ -->
<script type="text/plain" id="words_table1">
US:unsigned short
B:boolean
CUS:const unsigned short
CUL:const unsigned long
UL:unsigned long
DS:DOMString
RA:readonly attribute

COLOR_R:<span style="color:red;">赤色区間</span>
COLOR_X:<span style="color:#0C0;">緑色区間</span>
COLOR_Y:<span style="color:blue;">青色区間</span>

TOUCHEVENTS:touch-events-ja.html
	https://www.w3.org/TR/touch-events/#touchevent-interface
WEBSTORAGE:WebStorage-ja.html
	~HTML5/webstorage.html

Text: <code>Text</code> 
scope-ps: <code class="pseudo">:scope</code> 
SPECBUGS:https://www.w3.org/Bugs/Public/show_bug.cgi

is0:<code class="attr">is</code> 
</script>


<!--%語彙置換データ -->
<script type="text/plain" id="words_table">

HTML:
SVG:
XML:
XMLNS:
ID:
DOM:
Unicode:
	●node tree
木:tree::~:ツリー
部分木:subtree::~:部分ツリー:サブツリー
node::::ノード
shadow:
light:
closed-shadow-hidden:
深優先前順走査:preorder, depth-first traversal:深さ優先かつ前順による走査
根:root::~::ルート
先祖:ancestor::~
子孫:descendant::~
	広義:inclusive::~
広義先祖:inclusive ancestor::~
広義子孫:inclusive descendant::~
親:parent::~
子:child::~
同胞:sibling::~
広義同胞:inclusive sibling::~

最初0:最初?
最後0:最後?
	最初0の:first?:最初の?
	最後0の:last?最後の?

兄:前?の sibling::前?の同胞
弟:次?の sibling::次?の同胞
	兄弟

基準:reference:~
	ref:reference:基準
	基準子:reference child:基準-child:基準-子


文書:document::~
文書順:document order::~
文書片:document fragment::~::文書フラグメント
URL:
基底:base:~
断片:fragment::文書片::フラグメント
doctype:
要素:element::~
属性o:attribute°::属性°

片:fragment:~:::フラグメント
指数:index::~::インデックス
接続-:connect:~
	~~孤立する:alone

	●動詞
走らす:run する:走らせる
走らせ:run し:~
	走り終えた
実行-:execute:~
遂行-:perform:~

先行-:precede::~
後続-:follow::~
関与-:participate:~
	のpartを成す／関与する
受入-:adopt::~
前挿入:pre-insert:~
挿入-:insert:挿入
挿入:insertion:挿入
前除去-:pre-remove:~
除去-:remove:~
除去:removal:~
被除去:remove される:~
	toBeRemovedNode
置換-:replace:~
付加-:append:~
設定-:set:~
未設定に:unset:~
取得-:get:~
変更-:change:~
変更:change:~
変化:change:~
改変-:modify:~
移動-:move:~
追加-:add:追加
	追加:addition:~
反映-:reflect:~
検証-:validate:~
	validation
無効化-:invalidate:~
妥当:valid:~
抽出-:extract:~
選択-:select:~
選択:selecting:~

連結-:concatenate:~
登録-:register:~
複製:copy::~
符号化方式:encoding:~:::エンコーディング
	符号化:encode:~:::エンコード
	復号:decode:~:::デコード
clone::::クローン
整列-:sort:~
内容:content:~
遭遇-:encounter:~


	●IDL ／ js ／ 
JS:JavaScript
Realm:
realm:
大域:global::~::グローバル
	上位の大域:superglobal

IDL:
此れ:<b>これ°</b>
文脈obj:context object:文脈 object:::文脈オブジェクト
obj:object::::オブジェクト

index:
被support:supported::被 support:被サポート
取得子:getter::~::ゲッタ
設定子:setter::~::セッタ
反復器:iterator::~::イテレータ
演算-:operate:~
演算:operation:~
値:value::~
真偽値:boolean::~
数値:numeric value::~
引数:argument::~
属性:attribute::~
返値:return value::返り値
返され:return され:~
返す:return する:~
返さ:return し:~
返し:return し:~

呼出す:invoke する:呼び出す
呼出-:invoke:呼び出
	呼出され／呼出して／呼出した
呼出:invocation:呼び出し
被呼出時:被 invoke 時:~
callback:::::コールバック
	呼戻
call:::::コール
文字列化-:stringify:~
文字列化の:stringification:~
構築子:constructor::~::コンストラクタ
型:type:~
種別:type:~

例外:exception::~
投出:throw::~
	再投出:re-throw::再 throw:再投出
辞書:dictionary::~::ディクショナリ
field::::フィールド
継承-:inherit:~
派生:derived:~
初期化-:initialize:~
	初期化-済み:initialized
初期化:initializing:~
初期:initial:~
	初期~時:initially
member::::メンバ
meth:method:::メソッド
mixin:
ifc:interface:::インタフェース
catch:::::キャッチ
関数:function::~
識別子:identifier:~
定数:constant:~
抽象:abstract::~
作成-:create:~
作成:creation:~
prop:property:::プロパティ
静的:static::~
live:
static:
符号単位:code unit::~
在する:present する:在る
	有無:presence:~
不在:not present:~
	~~不在:absence:~


	●文字 data
ASCII:
大小区別:case-sensitive::文字大小区別
大小無視:case-insensitive::~
文字:character:~
文字列:string:~
部分文字列:substring:~
空:empty:~
空白:whitespace:~
space::::スペース
区切り:-separated:~
変異可能:mutable:~
分割-:split::~
大文字:uppercase:~
小文字:lowercase:~
token::::トークン
長さ:length:~

class::::クラス
classes:::class 列::クラス列

連続的:contiguous::~
count:::::カウント
符号位置:code point:~


構文解析-:parse::~::パース
構文解析器:parser::~::パーサ
直列化-:serialize::~::シリアル化
直列化:serialization::~::シリアル化
直列化器:serializer::~::シリアライザ

	●event
event::::イベント
listener::::リスナ
listen::::リッスン
target:
関係target:relatedTarget::関係 target
再target:retarget::再 target
上書target:target override::上書き target

経路:path::~
発火-:fire::~
	発火-法:firing
配送-:dispatch::~::ディスパッチ
	配送-法:dispatching
被取消:canceled::取消::キャンセル
受動:passive::~
composed:
	＊構成経路:composed::
取消:cancel::~::キャンセル
取消せ:cancel でき::~::キャンセルでき
	取消せな uncancelable
取消さな:cancel しな::~::キャンセルしな
伝播-:propagate::~
伝播:propagation::~
伝播即停止:stop immediate propagation::~
伝播停止:stop propagation::~
停止-:stop:~
相:phase::~::フェイズ
合成:synthetic::~

task::::タスク
	下位~task
極小task:microtask::極小 task:極小タスク:マイクロタスク
並列的:parallel:~

通達-:signal::~
通達:signal::~
	通達-時:signaling
	通達-法:signaling
複合:compound::~
作動化:activation::~::アクティブ化
作動化の:activation::~::アクティブ化

	●中止
被中止:aborted::~
中止~aborting::~
中止-:abort::~
promise:
	~promiseを返す:promise-returning
応答-:respond:~
却下-:reject::~
即時:immediate:~
未決着の:unsettled::~
注視-:watch:~
続行-:proceed:~

	●名前空間
局所:local::~::ローカル
	局所~名:local name
ns:namespace::名前空間
	名前空間接頭辞:namespace prefix::~
接頭辞:prefix::~
publicID:public ID::public 識別子
systemID:system ID::system 識別子
locate::特定
有修飾:qualified:~

生成規則:production::~
mode::::モード

	●変異
変異:mutation::~
変異-:mutate::~
記録:record::~::レコード
観測-:observe::~::オブザーブ
観測:observing::~::オブザービング
	観測-法:observing
	観測-可能:observable
	観測器:observer::~:オブザーバ
ob:observer::観測器:オブザーバ
抑止ob:suppress observers::観測器 抑止:オブザーバ抑止


記録待行列:record queue::記録 待ち行列::レコードキュー
待行列:queue::待ち行列::キュー
待入する:queue する::待ち行列に入れる::キューする
待入れる:enqueue する::待ち行列に入れる::エンキューする
待入れら:enqueue さ::待ち行列に入れら::エンキューさ

待入済み:queued::追加済み::キュー済み
登録済み:registered::~
一時:transient:~
追加済nodes:addedNodes::追加された node たち:追加されたノードたち
除去済nodes:removedNodes::除去された node たち:除去されたノードたち
	nextSibling::次?の sibling:次?の同胞
	previousSibling::前?の sibling:前?の同胞

新たな:new:~
旧-:old:旧
新-:new:新
	旧-値:oldValue
報告-:report:~
通知-:notify:~
通知:notification:~
有関係:interested:関係する
除去対象:nodes to remove:~

	●custom
custom::::カスタム
	~custom化:customize
反応-:react::~::リアクト
反応:reaction::~::リアクション
昇格:upgrade::~::アップグレード
	定義済み
組込みの:built-in::~
検索-:look up::~

	●slot
slot:
slotable:
割当先:assign 先::あてがい先
割当され:assign され::あてがわれ
割当する:assign する::あてがう
割当法:assigning::あてがい方
見出す:find する:~
見出-:find:~
見出法:finding:見出し方
平坦化-:flatten:~

	●Range
範囲o:range°::範囲°
	~~範囲
offset:::::オフセット
境界点:boundary point::~
前bp:<i>before</i>::<i>前</i>
後bp:<i>after</i>::<i>後</i>
等bp:<i>equal</i>::<i>等</i>
位置bp:position::位置

始端:start::~
終端:end::~
元の:original:~
包含-:contain:~
部分的:partial:~
中身:内容
交わる:intersect する:~
交わら:intersect し:~

	●collection
走査-:traverse::~::トラバース
走査:traversal::~::トラバーサル
collection::::コレクション
filter::::フィルタ
	濾過器
	濾過する
選択子:selector::~::セレクタ
評価-:evaluate::~

視野根:scoping root::~::スコーピングルート
視野:scope::~::スコープ

合致:match:~:::マッチ
合致-:match:~:::マッチ
照合-:match:~:::マッチ
bitmask::::ビットマスク

作動中:active::~::アクティブ

	●仕様
API:
algo:algorithm:::アルゴリズム
app:application:::アプリ
UA:user agent:UA:::ユーザエージェント
Web:
web:
platform::::プラットフォーム
community:::コミュニティ
model::::モデル
console::::コンソール
proprietary::::プロプライエタリ
option::::オプション
仕様:spec:~
特色機能:feature::~::フィーチャ
適用仕様:applicable specifications:適用し得る仕様
段:step:~:::ステップ
手続き:steps:~

support::::サポート
download:::ダウンロード
feedback:::フィードバック
markup::::マークアップ
debug::::デバッグ
log::::ログ
適合性:conformance:~
適合-:conform:~

旧来の:legacy:~
旧来:legacy:~
別名:alias:~
歴史上:historical:~
歴史上の:historical な:~
歴史的:historical:~
理由:reason:~
判定基準:criteria:~
標準:standard:~
対話的:interactive:~
対話:interaction:~
多彩:rich:~
明示的:explicit:~
暗黙的:implicit:~
互換性:compatibility:~
設計者:designer:~
目標:goals:~
概念:concept:~
更新:update:~
資源:resource:::リソース
過去互換:quirks::~
限定的互換:limited-quirks::~
非過去互換:no-quirks::非 過去互換
概して:typical に:~
一般:general:~
共通的に:common に:よく
共通の:common::~
一貫する:consistent になる:~
一貫させ:consistent にす:~
特定の:specific:~
特有の:-specific な:~
	特に:specific／specifically
所産:artifact:~
局面:scenario:~
効率的:efficient:~
問題:problem:~
	problematic
理想的:ideal:~
劇的:dramatic:~
将来:future:~
実際:actual:~
実際の:actual:~
同義語:synonymous:~
自動的:automatic:~
冗長:redundant:~
正しく:correct に:~
重要:important:~
基本:basic:~
単純:simple:~
単純化-:simplify:~
副作用:side effects:~
効果:effect:~
有用:useful:~
	無用の長物:useless
詳細:details:~
一義的:unambiguous:~
program::::プログラム
強く:strong に:~
可用:available:~
中立的:neutral:~
仕組み:mechanism:~
意味論:semantics:~
適度:reasonable:~
仕方:way:~
方式:manner:~
精細:granular:~
複雑:complex:~

	●仕様（動詞
拡張-:extend:~
拡張:extension:~
拡張性:extensibility:~
実装:implementation:~
実装-:implement:~
利用者:user:~
省略-:omit:~
省略可:optional::~
	省略時
設計:design:~
要求-:require:~
	要-:require
要件:requirements:~
定めら:state さ:~
解釈-:interpret:~
許容-:allow:~
導入-:introduce:~
	再~導入:reintroduce
予期-:expect:~
期待-:expect:~
変更点:changes:~
指定-:specify:~
	~~指定:flag:
未定義:undefined:~
定義済み:defined:~
定義-:define:~
定義:definition:~
	定義-法:defining
指示-:indicate:~
	~~指示:instruct
提供-:provide:~
意図的:intentional:~
機能性:functionality:~
結付けら:associate さ:結び付けら
結付け:associate し:結び付け
既存の:existing:~
挙動:behavior:ふるまい
挙動する:behave する:ふるまう
制御:control:~
最適化:optimization:~
最適化-:optimize:~
処理能:performance:~
奨励-:encourage:~
開発者:developer:~
軽減-:mitigate:~
援助-:aid:~
成功裡:successful:~
影響-:affect:~
影響0:impact:影響
拘束:constraints:~
拘束-:constrain:~
保障-:guarantee:~
無視-:ignore:~
改訂:revision:~
	説明-:explain:~
確保-:ensure:~
収束-:converge:~
	想定-:suppose
受容-:accept:~
保全-:preserve:~
依存-:depend:~
経験:experience:~
理解-:understand:~
操作-:manipulate:~
計画-:plan:~
策定者:author:~
作者:author:~
推奨-:recommend:~
推奨:recommendation:~
望み:wishes:~
望む:wish する:~
欲され:desire され:~
依拠-:rely:~
固守-:adhere:~
衝突-:clash:~
避ける:avoid する:~
取除かれ:remove され:取り除かれ

	●未分類（動詞
	抑止-:suppress:~
試行-:try:~
可能化-:enable:~
不能化-:disable:~
不能化:disabling:~
代入-:assign:~
代入:assignment:~
変換-:convert:~
検査-:check:~
検査:check:~
構築-:construct:~
	構築-法:constructing
比較:comparison:~
比較-:compare:~
決定-:determine:~
経過-:pass:~
表現-:represent:~
追跡-:track:~
公開-:expose:~
進行中の:ongoing:~
重複:duplicate:~
到達-:reach:~
阻む:block する:~:::ブロックする
動作:action:~
活動:activity:~
関係-:relate:~
関係性:relationship:~
添付けら:attach さ:添え付けら
上書き:override:~
共有-:share:~
入力:input:~
名:name:~
名前:name:~
改称-:rename:~
完了-:complete:~
完了:completion:~
	所与の:given

	●未分類
thread::::スレッド
	別~thread:cross-thread
list::::リスト
size::::サイズ
集合:set:~
snapshot:
	Checkbox
	Radio
関連する:relevant な:~
失敗:failure:~
失敗-:fail:~
成功:success:~
viable::大体
疑似類:pseudo-class::疑似 class:疑似クラス
状態:state::~
brand:
open:
access::::アクセス
bit::::ビット
code::::コード
data::::データ
flag::::フラグ
form::::フォーム
提出:submission::~
提出-:submit::~
garbage-collection:garbage collection::garbage 収集:ガーベジ収集:ガーベジコレクション
	16進:hex
hook::::フック
host::::ホスト
hyphen::::ハイフン
instance::::インスタンス
multimedia::::マルチメディア
network::::ネットワーク
page:::ページ
pointer::::ポインタ
scrolling::::スクロール処理
script::::スクリプト
sw:service worker
source::::ソース
tag::::タグ
text::::テキスト
touch:
view::::ビュー
wheel:
下位:sub:~
一意:unique:~
下層:underlying:~
環境設定:configurations:~
事例:case:~
内的:internal:内部
	一致する:identical:~
同期:synchronous:~
変数:variable:~
実体参照:entity reference:~
格納:storing:~
実質的:effective:~
整数:integer:~
文脈:context:~
方向:direction:~
既定:default:~
既定の:default:~
強い:strong な:~
弱い:weak な:~
参照:reference:~

時計:clock:~
時刻:time:~
時間差:time:~
時刻印:timestamp:~
	現在時:now
	差分:offset
時刻起点:time origin:~
	マイクロ秒:microseconds
	ミリ秒数:milliseconds
分解能:resolution:~
高分解能な:high resolution:高分解能な
	までの細かさ:minimum
	生じ:occur／occurrence／
換算-:translate:~
調整-:adjust:~
精度:precision:~

非決定的な:non-deterministic:~
順序:order:~
有順序:ordered:~
条件:condition:~

構造:structure:~
正確:exact:~
精確:precise:~
閲覧文脈:browsing context::~

現在の:current:~
生成元:origin::~::オリジン
不透明な:opaque::~
画像:image:~
相対的:relative:~
等価:equivalent:~
階層的:hierarchical:~
非同期:asynchronous:~
	内部処理用の:bookkeeping purposes
環境:environment:~
再帰的:recursive:~

</script>

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
dom-domtokenlist-stringifier:DOMTokenList-stringification-behavior
</script>
<!--%ifc -->
<script type="text/plain" id="_ifc_names">

AbortController
AbortSignal
Attr
CharacterData
CustomEvent
CustomEventInit:#dictdef-customeventinit
Comment
ChildNode
CDATASection
NonDocumentTypeChildNode
Document
DocumentFragment
ShadowRoot
ShadowRootInit:#dictdef-shadowrootinit
ShadowRootMode:#enumdef-shadowrootmode
DocumentOrShadowRoot
GetRootNodeOptions:#dictdef-getrootnodeoptions

DOMImplementation
DocumentType
Element
ElementCreationOptions:#dictdef-elementcreationoptions
Elements
Event
EventInit:#dictdef-eventinit
EventListener:#callbackdef-eventlistener
EventTarget
EventListenerOptions
AddEventListenerOptions
HTMLCollection
MutationCallback
MutationObserver
MutationObserverInit:#dictdef-mutationobserverinit
MutationRecord
NamedNodeMap
Node
NodeFilter:#callbackdef-nodefilter
NodeIterator
NodeList
ProcessingInstruction
Range
ParentNode
NonElementParentNode
DOMTokenList
TreeWalker
Text
XMLDocument

	●→ 廃止
RangeException
MutationEvent
MutationNameEvent

DOMConfiguration
DOMError
DOMErrorHandler
DOMImplementationList
DOMImplementationSource
DOMLocator
DOMObject
DOMStringList:~HTMLcdom#domstringlist
DOMUserData
Entity
EntityReference
NameList
Notation
TypeInfo
UserDataHandler


HTMLElement:~HTMLdom#htmlelement
HTMLHtmlElement:~HEmetadata#htmlhtmlelement
HTMLSlotElement:~HEscripting#htmlslotelement
HTMLUnknownElement:~HTMLdom#htmlunknownelement
ServiceWorkerGlobalScope:~SW#serviceworkerglobalscope
Window:~WINDOW#window

BeforeUnloadEvent:~NAVI#beforeunloadevent
CompositionEvent:~UIEVENTS#compositionevent
	#interface-compositionevent
	CustomEvent
DeviceMotionEvent:https://w3c.github.io/deviceorientation/spec-source-orientation.html#devicemotion
DeviceOrientationEvent:https://w3c.github.io/deviceorientation/spec-source-orientation.html#devicemotion
EventHandler:~WAPI#eventhandler
DragEvent:~HTMLdnd#dragevent
FocusEvent:~UIEVENTS#focusevent
	#interface-focusevent
	Event
HashChangeEvent:~NAVI#hashchangeevent
KeyboardEvent:~UIEVENTS#keyboardevent
	~UIEVENTS#keyboardevent-keyboardevent
	~UIEVENTS#interface-keyboardevent
MessageEvent:~HTMLcomms#messageevent
MouseEvent:~UIEVENTS#mouseevent
	~UIEVENTS#interface-mouseevent
StorageEvent:~WEBSTORAGE#storageevent
TouchEvent:~TOUCHEVENTS#idl-def-touchevent
	TouchEvent:~TOUCHEVENTS#touchevent-interface
	#touchevent-interface
	https://w3c.github.io/touch-events/#idl-def-touchevent
UIEvent:~UIEVENTS#uievent
	~UIEVENTS#interface-uievent
	~UIEVENTS#uievent-uievent


DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
DOMTimeStamp:~WEBIDL#DOMTimeStamp
DOMString:~WEBIDL#idl-domstring
DOMException:~WEBIDL#idl-DOMException

</script>

<!--%リンク置換データ
-->
<script type="text/plain" id="_link_map">

script.e:~HEscripting#the-script-element
input.e:~HEinput#the-input-element
title.e:~HEmetadata#the-title-element
html.e:~HEmetadata#the-html-element
head.e:~HEmetadata#the-head-element
body.e:~HEsections#the-body-element
template.e:~HEscripting#the-template-element
slot.e:~HEscripting#the-slot-element
input.e:~HEinput#the-input-element
area.e:~HEimages#the-area-element

open.l:#dom-shadowrootmode-open
closed.l:#dom-shadowrootmode-closed

CEReactions:~HEcustom#cereactions
Exposed:~WEBIDL#Exposed
Unforgeable:~WEBIDL#Unforgeable
NoInterfaceObject:~WEBIDL#NoInterfaceObject
SameObject:~WEBIDL#SameObject
Unscopable:~WEBIDL#Unscopable
NewObject:~WEBIDL#NewObject
LegacyUnenumerableNamedProperties:~WEBIDL#LegacyUnenumerableNamedProperties
TreatNullAs:~WEBIDL#TreatNullAs
PutForwards:~WEBIDL#PutForwards

TypeError.E:~WEBIDL#exceptiondef-typeerror
AbortError.E:~WEBIDL#aborterror
HierarchyRequestError.E:~WEBIDL#hierarchyrequesterror
InUseAttributeError.E:~WEBIDL#inuseattributeerror
IndexSizeError.E:~WEBIDL#indexsizeerror
InvalidCharacterError.E:~WEBIDL#invalidcharactererror
InvalidNodeTypeError.E:~WEBIDL#invalidnodetypeerror
InvalidStateError.E:~WEBIDL#invalidstateerror
NamespaceError.E:~WEBIDL#namespaceerror
NotFoundError.E:~WEBIDL#notfounderror
NotSupportedError.E:~WEBIDL#notsupportederror
SyntaxError.E:~WEBIDL#syntaxerror
WrongDocumentError.E:~WEBIDL#wrongdocumenterror

click().m:~HTMLinteraction#dom-click
detail.m:~UIEVENTS#dom-uievent-detail
insertAdjacentHTML().m:~DOM-Parsing#dom-element-insertadjacenthtml
createContextualFragment().m:~DOM-Parsing#dfn-createcontextualfragment-fragment
getClientRects().m:~CSSOMVIEW#dom-range-getclientrects
getBoundingClientRect().m:~CSSOMVIEW#dom-range-getboundingclientrect


最初0:#_first_obj
最後0:#_last_obj
旧来（~listenerは投出したか？）~flag.V:#_legacyOutputDidListenersThrowFlag

文脈obj:#context-object
	＊投出:#concept-throw
適用仕様:#other-applicable-specifications
閲覧文脈~群.V:#_unit-of-related-similar-origin-browsing-contexts

	●event
初期化-済み.f:#initialized-flag
伝播即停止.f:#stop-immediate-propagation-flag
伝播停止.f:#stop-propagation-flag
被取消.f:#canceled-flag
配送-.f:#dispatch-flag
受動~listener内.f:#in-passive-listener-flag
~composed.f:#composed-flag

type.evL:#_type
callback.evL:#_callback
capture.evL:#_capture
passive.evL:#_passive
once.evL:#_once
removed.evL:#_removed

item.evP:#_item
target.evP:#_target
関係target.evP:#_relatedTarget

~event:#concept-event
経路:#event-path
~eventを作成する:#concept-event-create
再target:#retarget
関係target:#event-relatedtarget
再targetする手続き:#event-retargeting-steps
配送-:#concept-event-dispatch
発火-:#concept-event-fire
~listenerを呼出す:#concept-event-listener-invoke
~listenerを内部的に呼出す:#concept-event-listener-inner-invoke
初期化する:#concept-event-initialize
~event~listener:#concept-event-listener
~listener~list:#_listener-list
	type.i:#listener-type
	callback.i:#listener-callback
	capture.i:#listener-capture
平坦化-:#concept-flatten-options
もっと平坦化-:#event-flatten-more
親~targetを取得する:#get-the-parent
~event構築子:#concept-event-constructor

作動化の挙動:#eventtarget-activation-behavior
旧来の作動化~前の挙動:#eventtarget-legacy-pre-activation-behavior
旧来の作動化~取消~時の挙動:#eventtarget-legacy-canceled-activation-behavior

	●abort
中止-を通達-.aB:#abortsignal-signal-abort
通達.aB:#abortcontroller-signal
中止する~algoたち.aB:#abortsignal-abort-algorithms
被中止~flag.aB:#abortsignal-aborted-flag
追加-.aB:#abortsignal-add
除去-.aB:#abortsignal-remove

	●node／木
~ID:#concept-id

親~要素:#parent-element

子:#concept-tree-child
子たち:#concept-tree-child
親:#concept-tree-parent
先祖:#concept-tree-ancestor
子孫:#concept-tree-descendant
広義先祖:#concept-tree-inclusive-ancestor
広義子孫:#concept-tree-inclusive-descendant
共通の広義先祖:#_common-inclusive-ancestor

最初0の子:#concept-tree-first-child
最後0の子:#concept-tree-last-child
先行-:#concept-tree-preceding
後続-:#concept-tree-following
指数:#concept-tree-index
兄:#concept-tree-previous-sibling
弟:#concept-tree-next-sibling
関与-:#concept-tree-participate
同胞:#concept-tree-sibling
広義同胞:#concept-tree-inclusive-sibling

木:#concept-tree
~node木:#concept-node-tree
文書~木:#concept-document-tree
根:#concept-tree-root
木~順序:#concept-tree-order
対応する要素~ifc:#concept-element-interface

文書~木~内:#in-a-document-tree
文書~内:#in-a-document

受入-:#concept-node-adopt
受入-時の手続き:#concept-node-adopt-ext
付加-:#concept-node-append
挿入-:#concept-node-insert
挿入:#concept-node-insert
挿入-時の手続き:#concept-node-insert-ext
前挿入:#concept-node-pre-insert
挿入し得るかどうか検証する:#concept-node-ensure-pre-insertion-validity
前除去-:#concept-node-pre-remove
前除去-時の手続き:#nodeiterator-pre-removing-steps
除去-:#concept-node-remove
除去-時の手続き:#concept-node-remove-ext
置換-:#concept-node-replace
すべて置換-:#concept-node-replace-all
隣に挿入-:#insert-adjacent

子~text内容~変更-時の手続き:#concept-node-text-change-ext
子~text内容:#concept-child-text-content

~clone:#concept-node-clone
~clone時の手続き:#concept-node-clone-ext

~filterにかける:#concept-node-filter
~filterにかけた:#concept-node-filter
長さ:#concept-node-length
~node文書:#concept-node-document
~node:#concept-node
空:#concept-node-empty
等しい:#concept-node-equals

文書片:#_concept-documentfragment
文字~data~node:#_concept-cdata-node
~host:#concept-documentfragment-host
~hostも含む広義先祖:#concept-tree-host-including-inclusive-ancestor


	●shadow
~light木:#concept-light-tree
~shadow木:#concept-shadow-tree
~shadow~host:#element-shadow-host
~shadow根:#concept-shadow-root
~mode.sR:#shadowroot-mode
~shadowも含む子孫:#concept-shadow-including-descendant
~shadowも含む広義子孫:#concept-shadow-including-inclusive-descendant
~shadowも含む先祖:#concept-shadow-including-ancestor
~shadowも含む広義先祖:#concept-shadow-including-inclusive-ancestor
~shadowも含む木~順序:#concept-shadow-including-tree-order
~shadowも含む深優先前順走査:#shadow-including-preorder-depth-first-traversal
接続されて:#connected
~shadowも含む根:#concept-shadow-including-root
	#in-a-shadow-including-document
~closed-shadow-hidden:#concept-closed-shadow-hidden

	●slot
~slot:#concept-slot
~slotable:#concept-slotable
~slot名:#slot-name
~slotable名:#slotable-name
	＊名前.sL:#slot-name
	＊名前.sB:#slotable-name
~slotable用に~slotを見出す:#find-a-slot
~slot用に~slotableたちを見出す:#find-slotables
~slot用に平坦化された~slotableたちを見出す:#find-flattened-slotables
割当先~slot:#slotable-assigned-slot
割当先がある:#slotable-assigned
割当されている~nodeたち:#slot-assigned-nodes
~slotableを~slotに割当する:#assign-a-slot
~slotに~slotableたちを割当する:#assign-slotables
木に~slotableたちを割当する:#assign-slotables-for-a-tree
通達~slot~list:#signal-slot-list
~slotの変化を通達する:#signal-a-slot-change

	●文書／文書片／名前空間
文書:#concept-document
符号化方式.doc:#concept-document-encoding
内容~型.doc:#concept-document-content-type
~URL.doc:#concept-document-url
種別.doc:#concept-document-type
生成元.doc:#concept-document-origin
~mode.doc:#concept-document-mode

文書~基底~URL:~HTMLurl#document-base-url
結付けられている文書:~WINDOW#concept-document-window

限定的互換~mode:#concept-document-limited-quirks
非過去互換~mode:#concept-document-no-quirks
過去互換~mode:#concept-document-quirks
~doctype:#concept-doctype
~doctype名:#concept-doctype-name
名前.dT:#concept-doctype-name
~publicID.dT:#concept-doctype-publicid
~systemID.dT:#concept-doctype-systemid


~HTML文書:#html-document
~XML文書:#xml-document

~HTML~ns:~INFRA#html-namespace
~SVG~ns:~INFRA#svg-namespace
~XML~ns:~INFRA#xml-namespace
~XMLNS~ns:~INFRA#xmlns-namespace

~ns接頭辞を~locate:#locate-a-namespace-prefix
~nsを~locate:#locate-a-namespace
内的 createElementNS 手続き:#internal-createelementns-steps


	●text node／文字列／cdata
新たな~Text~node:#_a-new-text-node

符号単位:~INFRA#code-unit
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化:~INFRA#ascii-lowercase
~ASCII大文字~化:~INFRA#ascii-uppercase
~ASCII空白:~INFRA#ascii-whitespace
~ASCII空白で分割-:~INFRA#split-on-ascii-whitespace

大小区別:~HTMLINFRA#case-sensitive

有順序~集合 構文解析器:#concept-ordered-set-parser
有順序~集合 直列化器:#concept-ordered-set-serializer

分割-:#concept-text-split
~dataを置換する:#concept-cd-replace
~data:#concept-cd-data
~dataの部分文字列:#concept-cd-substring

狭義の~Text~node:#exclusive-text-node
連続的な~Text~node列:#contiguous-text-nodes
連続的な狭義の~Text~node列:#contiguous-exclusive-text-nodes
連続的な同胞~列:#_contiguous-nodes

	●要素／属性
文書~要素:#document-element
要素:#concept-element
局所~名:#concept-element-local-name
~shadow根.elm:#concept-element-shadow-root
有修飾~名:#concept-element-qualified-name
~ns接頭辞:#concept-element-namespace-prefix
~ns:#concept-element-namespace
有修飾~名として検証する:#validate
検証して抽出する:#validate-and-extract
属性o~list:#concept-element-attribute
有する:#concept-element-attribute-has
有して:#concept-element-attribute-has
有さない:#concept-element-attribute-has

属性oを設定する:#concept-element-attributes-set
属性oを付加する:#concept-element-attributes-append
属性oを除去する:#concept-element-attributes-remove
属性oを変更する:#concept-element-attributes-change
属性oを置換する:#concept-element-attributes-replace

既存の属性o値を設定する:#set-an-existing-attribute-value
属性o値を設定する:#concept-element-attributes-set-value
属性o値を取得する:#concept-element-attributes-get-value

属性oを名前により取得する:#concept-element-attributes-get-by-name
属性oを名前により除去する:#concept-element-attributes-remove-by-name
属性oを~nsと局所~名により取得する:#concept-element-attributes-get-by-namespace
属性oを~nsと局所~名により除去する:#concept-element-attributes-remove-by-namespace

属性o
属性o:#concept-attribute
属性o.nm:#concept-named-attribute
属性oを変更する手続き:#concept-element-attributes-change-ext
属する要素:#concept-attribute-element
有修飾~名.a:#concept-attribute-qualified-name
値.a:#concept-attribute-value
~ns.a:#concept-attribute-namespace
~ns接頭辞.a:#concept-attribute-namespace-prefix
局所~名.a:#concept-attribute-local-name

要素.nm:#concept-namednodemap-element
属性o~list.nm:#concept-namednodemap-attribute
~classes:#concept-class
~classesに含む要素の~list:#concept-getelementsbyclassname
有修飾~名に持つ要素の~list:#concept-getelementsbytagname
( ~ns, 局所~名 ) に持つ要素の~list:#concept-getelementsbytagnamens

反映-:#concept-reflect


	●custom要素
要素を作成-:#concept-create-element
新たな要素:#concept-create-element
定義済み:#concept-element-defined
~custom:#concept-element-custom
~custom要素~状態:#concept-element-custom-element-state
~custom要素~定義:#concept-element-custom-element-definition
~is0値:#concept-element-is-value

名前.cD:~HEcustom#concept-custom-element-definition-name
局所~名.cD:~HEcustom#concept-custom-element-definition-local-name
構築子.cD:~HEcustom#concept-custom-element-definition-constructor
妥当な~custom要素~名:~HEcustom#valid-custom-element-name
~custom要素~構築子:~HEcustom#custom-element-constructor
~custom要素~callback反応を待入れる:~HEcustom#enqueue-a-custom-element-callback-reaction
~custom化された組込みの要素:~HEcustom#customized-built-in-element
~custom要素~定義を検索する:~HEcustom#look-up-a-custom-element-definition
昇格しようと試行する:~HEcustom#concept-try-upgrade
要素を昇格する:~HEcustom#concept-upgrade-an-element
~custom要素~昇格~反応を待入れる:~HEcustom#enqueue-a-custom-element-upgrade-reaction


	●変異
旧-値:#_paired-string
変異~記録:#_mutation-record
変異~記録を待入する:#queue-a-mutation-record
	変異~meth~macro:#mutation-method-macro
~nodeに変換-:#converting-nodes-into-a-node
~nodeたちを~nodeに変換する:#converting-nodes-into-a-node
~callback.mo:#concept-mo-callback

記録待行列:#concept-mo-queue
変異~ob 複合~極小task待入済み.f:#mutation-observer-compound-microtask-queued-flag
変異~ob 複合~極小taskを待入する:#queue-a-mutation-observer-compound-microtask
変異~obに通知する:#notify-mutation-observers
変異~ob 通知-~list:#_mutation-observer-notify-list

登録済み~ob:#registered-observer
一時~登録済み~ob:#transient-registered-observer
~ob~list:#_observer-list
観測している~node~list:#_observing-nodes
	“observed nodes”?
	抑止ob.f:#_suppress-observers-flag


	●範囲
範囲o:#concept-range
根.rg:#concept-range-root
中身を抽出-.rg:#concept-range-extract
中身を~clone.rg:#concept-range-clone
中身に挿入-.rg:#concept-range-insert
中身として選択-.rg:#concept-range-select
中身.rg:#_concept-range-content

終端~node:#concept-range-end-node
終端~offset:#concept-range-end-offset
終端:#concept-range-end
始端~node:#concept-range-start-node
始端~offset:#concept-range-start-offset
始端:#concept-range-start

境界点:#concept-range-bp
後bp:#concept-range-bp-after
前bp:#concept-range-bp-before
等bp:#concept-range-bp-equal
~offset:#concept-range-bp-offset

位置bp:#concept-range-bp-position
境界点を設定する:#concept-range-bp-set

包含され:#contained
部分的に包含され:#partially-contained

	●token list
~token集合:#concept-dtl-tokens
被support~token集合.dtl:#concept-supported-tokens
更新~手続き:#concept-dtl-update
直列化-手続き:#concept-dtl-serialize
検証-.dtl:#concept-domtokenlist-validation
要素.dtl:#_dtl-element
属性oの局所~名.dtl:#_dtl-localname
検査する.dtl:#_dtl-check-token

	●node iterator
表現-:#represented-by-the-collection
反復器~collection:#iterator-collection
~live:#concept-collection-live
静的:#concept-collection-static
~collection:#concept-collection
~filter:#_collection-filter
根.cl:#_collection-root
作動中~flag:#concept-traversal-active
~filter~callback:#concept-traversal-filter
根~node:#concept-traversal-root
whatToShow ~bitmask:#concept-traversal-whattoshow
~target:#concept-pi-target

子を走査-:#concept-traverse-children
同胞を走査-:#concept-traverse-siblings
走査-:#concept-nodeiterator-traverse

	●INFRA
有順序~集合:~INFRA#ordered-set
付加-.set:~INFRA#set-append
置換-.set:~INFRA#set-replace
~list:~INFRA#list
付加-.list:~INFRA#list-append
	~EACH.list:~INFRA#list-iterate
	~CONTINUE.list:~INFRA#iteration-continue
	包含-.list:~INFRA#list-contain
	~IN.list:~INFRA#list-contain
	~NIN.list:~INFRA#list-contain
空にする.list:~INFRA#list-empty
空.list:~INFRA#list-is-empty
除去-.list:~INFRA#list-remove
挿入-.list:~INFRA#list-insert
置換-.list:~INFRA#list-replace
~size.list:~INFRA#list-size

	●選択子
視野の下で選択子を照合する:#scope-match-a-selectors-string
~scope-ps要素:~SELECTORS4#scope-element
選択子として構文解析する:~SELECTORS4#parse-a-selector
視野根:~SELECTORS4#scoping-root
木に対し選択子を照合する:~SELECTORS4#match-a-selector-against-a-tree
要素に対し選択子を照合する:~SELECTORS4#match-a-selector-against-an-element

	●WEBIDL
~callback this 値:~WEBIDL#dfn-callback-this-value
辞書~member:~WEBIDL#dfn-dictionary-member
識別子:~WEBIDL#dfn-identifier

被support ~prop~index:~WEBIDL#dfn-supported-property-indices
被support ~prop名:~WEBIDL#dfn-supported-property-names
投出:~WEBIDL#dfn-throw
可変個引数:~WEBIDL#dfn-variadic
利用者~objの演算を~call:~WEBIDL#call-a-user-objects-operation
~callback関数を呼出す:~WEBIDL#invoke-a-callback-function
変換-:~WEBIDL#dfn-convert-ecmascript-to-idl-value
~callback関数で構築-:~WEBIDL#construct-a-callback-function

	●他
新たな~promise:~PROMISES#a-new-promise
却下する:~PROMISES#reject-promise
解決する:~PROMISES#resolve-promise

~URL:~URLSpec#concept-url
~URLを直列化する:~URLSpec#concept-url-serializer

utf-8:~ENCODING#utf-8

Char.prod:~TR/xml/#NT-Char
Name.prod:~TR/xml/#NT-Name
QName.prod:~TR/xml-names/#NT-QName
PrefixedName.prod:~TR/xml-names/#NT-PrefixedName

~HTML構文解析器:~HTMLparsing#html-parser
並列的:~HTMLINFRA#in-parallel
その例外を報告する:~WAPI#report-the-exception
関連する大域~obj:~WAPI#concept-relevant-global
現在の大域~obj:~WAPI#current-global-object
関連する~Realm:~WAPI#concept-relevant-realm

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

閲覧文脈:~BROWSERS#browsing-context
互いに関係するかつ生成元も類似する閲覧文脈~群:~BROWSERS#unit-of-related-similar-origin-browsing-contexts
属する閲覧文脈:~BROWSERS#concept-document-bc

~sw:~SW#dfn-service-worker
~script資源:~SW#dfn-script-resource
評価されたことがある~flag:~SW#dfn-has-ever-been-evaluated-flag

~Realm:~TC39#realm
時刻起点:~HRTIME#time-origin

前順.wiki:http://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_%28%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%29#.E8.B5.B0.E6.9F.BB.E6.B3.95
深さ優先.wiki:http://ja.wikipedia.org/wiki/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2


	:~WAPI#compound-microtask
	を
	:~WAPI#queue-a-microtask
	:~WAPI#execute-a-compound-microtask-subtask
	:~ENCODING#encoding
	:~ENCODING#name
	:https://w3c.github.io/webcomponents/spec/shadow/
	:~HTMLselectors#selector-defined
	:#mutation-algorithms

</script>

<!--%style -->
<style>
*[lang="en"] {
	white-space: pre-line;
}

.preline {
	white-space: pre-line;
}

i.i {
	color: purple;
	font-weight: bold;
	font-family: serif0, serif;
}
.flag {
	
}

var {
	font-family: serif0, serif;
}

.bp-example {
	text-align: center;
	font-size: 14px;
	white-space: pre;
	overflow: auto;
	font-family: monospace0, monospace;
	padding-bottom: 3em;
	color: #555;
}
.bp-example * {
	font-family: monospace0, monospace;
	font-style:normal;
	position:relative;
	top: 6px;
	border-top: solid #AAA 3px;
}
.bp-example i {
	border-top-color: red;
	color: red;
}
.bp-example .x {
	border-top-color: #0C0;
}
.bp-example .y {
	border-top-color: blue;
}
.bp-example .m {
	border: none;
	top: 0;
	display: inline-block;
	vertical-align: top;
}


div.trans-note {
	margin: 1em;
	border: solid green 2px;
	padding: 0.5em;
}

/*
	border-left: solid #DDD 1em;
	padding-left: 0.5em;
*/
.domTree samp {
	border: 1px solid green;
}


</style>

</head>

<body>

<!--%UI -->
<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">

<h1>DOM Standard （ “DOM4” ） 日本語訳</h1>

<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/" >WHATWG</a>
による，副題の日付時点の
<a id="_SPEC_URL">DOM Standard</a>
仕様（通称 “DOM-LS”, “DOM4”, “DOM Core” ）を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-09-15</time>
（公開： <time>2012-01-28</time>）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBzdHJva2U9IiMzYzc5MGEiIHN0cm9rZS13aWR0aD0iMTAiIGZpbGw9IiNmZmYiPgo8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIvPgo8cGF0aCBkPSJtNTAsMjV2MTVsLTE1LDEwLTEwLDE1bTEwLTE1bDEwLDE1bTUtMjVsMTUsMTAsMTAsMTVtLTEwLTE1bC0xMCwxNSIvPgo8L3N2Zz4K"
></a>

	<hgroup>
<h1>DOM</h1>
<h2>Living Standard — 最終更新 2017 年 9 月 14 日</h2>
	</hgroup>

<dl>
	<dt>Participate:</dt>
	<dd><a href="https://github.com/whatwg/dom">GitHub whatwg/dom</a></dd>
	<dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/dom/commits">GitHub whatwg/dom/commits</a></dd>
	<dd><a href="https://dom.spec.whatwg.org/commit-snapshots/c3bbdb26007db7bbb93eedda1cf008191e990502/">Snapshot as of this commit</a></dd>
	<dd><a href="https://twitter.com/thedomstandard">@thedomstandard</a></dd>

	<dt>Tests:</dt>
	<dd><a href="https://github.com/w3c/web-platform-tests/tree/master/dom">web-platform-tests dom/</a></dd>

	<dt>各国語翻訳（非規範的）</dt>
	<dd>日本語（このページ）</dd>

</dl>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
~DOMは、~platformに中立的な，［
~event, ~promiseによる活動の中止-法, ~node木
］の~modelを定義する。
◎
DOM defines a platform-neutral model for events, aborting activities and node trees.
</p>

	</section>

<main id="MAIN0">

	<section id="goals">
<h2 title="Goals">目標</h2>

<p>
この仕様は~DOMを標準~化する。
次を行うことにより：
◎
This specification standardizes the DOM. It does so as follows:
</p>

<ol>
	<li>
<div class="p">
<p>
次に挙げる仕様を整理統合し：
</p>

<ul ><li>`DOM Level 3 Core^cite `DOM-Level-3-Core$r
</li><li>`Element Traversal^cite `ELEMENTTRAVERSAL$r
</li><li>`Selectors API Level 2^cite `SELECTORS-API2$r
</li><li>`DOM Level 3 Events^cite `uievents-20031107$r
の "DOM Event Architecture" 章と "Basic Event Interfaces" 章
（特定の型の~eventは~DOM標準には属さない）
</li><li>`DOM Level 2 Traversal and Range^cite `DOM-Level-2-Traversal-Range$r
</li></ul>

<p>
それらを：
</p>

◎
By consolidating DOM Level 3 Core [DOM-Level-3-Core], Element Traversal [ELEMENTTRAVERSAL], Selectors API Level 2 [SELECTORS-API2], the "DOM Event Architecture" and "Basic Event Interfaces" chapters of DOM Level 3 Events [uievents-20031107] (specific types of events do not belong in the DOM Standard), and DOM Level 2 Traversal and Range [DOM-Level-2-Traversal-Range], and:
</div>

		<ul>
			<li>
可能な所では~JS ecosystem に合わせ，
◎
Aligning them with the JavaScript ecosystem where possible.
</li>
			<li>
既存の実装に揃わせ，
◎
Aligning them with existing implementations.
</li>
			<li>
可能な限り単純化する。
◎
Simplifying them as much as possible.
</li>
		</ul>
	</li>
	<li>
~HTML標準 `HTML$r から，この~DOM標準の一部として指定されるべき特色機能を移行させる。
◎
By moving features from the HTML Standard [HTML] that make more sense to be specified as part of the DOM Standard.
</li>
	<li>

<p>
`DOM Level 3 Events^cite
`uievents-20031107$r
の，問題のあった古い~modelの "Mutation Events" 章と "Mutation Name Event Types" 章に代わるものを定義する。
◎
By defining a replacement for the "Mutation Events" and "Mutation Name Event Types" chapters of DOM Level 3 Events [uievents-20031107] as the old model was problematic.
</p>

<p class="note">注記：
この結果、古い~modelは実装から除去されることが期待されている。
◎
The old model is expected to be removed from implementations in due course.
</li>
<li>
新たな特色機能を定義して、共通の~DOM演算を単純化する。
◎
By defining new features that simplify common DOM operations.
</li>
</ol>

	</section>
	<section id="infrastructure">
<h2 title="Infrastructure">1. 基盤</h2>

<p>
この仕様は Infra Standard `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様の一部の用語は
`Encoding^cite,
`Selectors^cite,
`Web IDL^cite,
`XML^cite,
`Namespaces in XML^cite
にて定義される。
`ENCODING$r
`SELECTORS4$r
`WEBIDL$r
`XML$r
`XML-NAMES$r
◎
Some of the terms used in this specification are defined in Encoding, Selectors, Web IDL, XML, and Namespaces in XML. [ENCODING] [SELECTORS4] [WEBIDL] [XML] [XML-NAMES]
</p>

<p>
語
`文脈obj@
とは、論の対象の［
~algo／属性~取得子／属性~設定子／~meth
］が~callされた~objを指す。
文脈objが一義的に定まる場合は省略される。
◎
The term context object means the object on which the algorithm, attribute getter, attribute setter, or method being discussed was called. When the context object is unambiguous, the term can be omitted.
</p>

<p class="trans-note">【
この訳では、より簡潔に，太字で
“此れ”
と記す。
また、一義的でも（ほぼ）省略していない。
】</p>

<p>
拡張が必要になったときは、それに則って~DOM標準が更新されるか，あるいは
`適用仕様@†
のために提供される［
拡張性のための~hook
］を利用するような，新たな標準が書かれ得る。
◎
When extensions are needed, the DOM Standard can be updated accordingly, or a new standard can be written that hooks into the provided extensibility hooks for applicable specifications.
</p>

<p class="trans-note">【†
`HTML$r に定義されるそれ（
<a href="~HTMLINFRA#other-applicable-specifications">applicable specifications</a>
）と同様
— この仕様~自身も含まれる。
】</p>


		<section id="_conventions">
<h3 class="trans-note">【日本語訳に固有の表記規約】</h3>

<p>
この訳では，以下の表記が用いられる：
</p>

<ul>
	<li>
この仕様を通して，よく用いられる［
“結付けられる”,
“初期化される”,
“新たな … ” 
］等々の句については、
<a href="index.html#common-wording">~~共通の慣用表現</a>を~~参照されたし。
</li>
	<li>
~algoや定義の記述に利用されている各種記号（ ε, ~LET, ~EQ, ~IF, ~EACH (…), ~RET, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</li>
	<li>
太字の “此れ” は，`文脈obj$を意味する。
</li>
	<li>
所与の［
有限個の~objからなる有順序~集合（例えば`木$や~list）の部分集合（例えば ある条件を満たすものなど）
］ %S に対し，その［
`最初0@ ／ `最後0@
］のものとは、 %S が空（例えば，条件を満たす~objが存在しない）ならば ~NULL であり，そうでなければ その順序において %S の中で［
最初 ／ 最後
］に在る~objとする。
<small >（
“最初” ／ “最後” がこの意味で用いられる所（ ~NULL にもなり得る所）では、常に（ WebIDL 方式に倣って） "?" が付記される。
）</small>
</li>
	<li>
整数 %index に対する “%index 番” は 0 番から数えるものとする。
</li>
</ul>

		</section>
		<section id="trees">
<h3 title="Trees">1.1. 木</h3>
<!-- Sorry reddit, this is not /r/trees -->

<p>
`木@
とは、有限の階層的な木~構造を意味する。
`木~順序@
は、深優先前順走査に基づく。
◎
A tree is a finite hierarchical tree structure. In tree order is preorder, depth-first traversal of a tree.
</p>

<div class="trans-note" id="example-tree">
<p>【 `深さ優先$wiki, `前順$wiki 】：
この方式による木の走査-は、~HTMLや~XML文書の~source~text表現における，要素の開始~tagや~text内容（より一般には`文字~data~node$）が現れる順序を表現する（ゆえに， “文書順” と呼ばれることもある）。
この順序を反映するように木の一例を可視化した模式図を下に示す。
図の 左端／右端 が~sourceの 先頭／末尾 に対応する。
図の横線が，木の中の各~nodeとそれが~source内を占める~~範囲（要素の開始~tag〜終了~tag, あるいは文字~dataの先頭〜末尾）を表し、それらの上下関係が木の階層（~nodeの入子~階層）を表す。
図の中の各~文字は文字~dataの各~文字に対応し，それらがなす各~COLOR_Rが`文字~data~node$が占める~~範囲を表す。
~nodeの順序はこれらの横線の左端の位置から決定される。
最上層の横線がこの木の根~node（根元）を表し，この順序における先頭になる。
</p>

`[&nbsp;[&nbsp;]&nbsp;(~sourceに)&nbsp;[&nbsp;(現れる)&nbsp;[&nbsp;(順序が)&nbsp;]&nbsp;[&nbsp;(そのまま)&nbsp;[&nbsp;(木~順序に)&nbsp;]&nbsp;]&nbsp;(なる)&nbsp;]&nbsp;]^bpex

<p>
この図に対応する~sourceは次の様になる（簡単にするため，`e^e 要素と~text内容のみから構成されている）：
</p>

<pre>
&lt;e&gt;&lt;e&gt;&lt;/e&gt;~sourceに&lt;e&gt;現れる&lt;e&gt;順序が&lt;/e&gt;&lt;e&gt;そのまま&lt;e&gt;木~順序に&lt;/e&gt;&lt;/e&gt;なる&lt;/e&gt;&lt;/e&gt;
</pre>

</div>


<p>
`木$に
`関与-@
する各~objは、~objまたは~NULL をとる
`親@
を持ち，
0 個以上の~objからなる`有順序~集合$を成す
`子たち@
を持つ。
~obj %A の`親$ %B ~NEQ ~NULL ならば， %A は %B の子である。
◎
An object that participates in a tree has a parent, which is either null or an object, and has children, which is an ordered set of objects. An object A whose parent is object B is a child of B.
</p>

<p class="trans-note">【
~objとその`親$が同じになることはない。
】【
%A は %B の “子である” という句は、［
%A ~IN %B の`子たち$
］を意味する。
】【
同じ~objが同時に複数の~objの子になることはない。
】</p>

<p>
~objの
`根@
とは、［
~objの`親$ ~EQ ~NULL
］ならば~obj自身であり，他の場合は~objの`親$の`根$である。
`木$の`根$は、その`木$に`関与-$している~objであって，［
`親$ ~EQ ~NULL
］なるものである。
◎
The root of an object is itself, if its parent is null, or else it is the root of its parent. The root of a tree is any object participating in that tree whose parent is null.
</p>

<p>
~obj %A が~obj %B の
`子孫@
であるとは、次を意味する
⇒
［
%A は %B の`子$である
］~OR［
%A は %B のある`子孫$の`子$である
］
◎
An object A is called a descendant of an object B, if either A is a child of B or A is a child of an object C that is a descendant of B.
</p>

<p class="trans-note">【
%A 自身が %A の`子孫$になることはない。
】</p>

<p>
~obj %A が~obj %B の
`広義子孫@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`子孫$である
］
◎
An inclusive descendant is an object or one of its descendants.
</p>

<p class="trans-note"><small>【
“広義” という対訳は，よいとは言えないが、より忠実に “自身も含めた子孫” などと訳すのでは，用語として定義する意義
— 他から簡潔に参照できるようにする —
も失われる（単に “自身または子孫” と記すのと同じことになる）。
】</small></p>

<p>
~obj %A が~obj %B の
`先祖@
であるとは、次を意味する
⇒
%B は %A の`子孫$である
◎
An object A is called an ancestor of an object B if and only if B is a descendant of A.
</p>

<p>
~obj %A が~obj %B の
`広義先祖@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`先祖$である
］
◎
An inclusive ancestor is an object or one of its ancestors.
</p>

<p>
~obj %A が~obj %B の
`同胞@
（ “兄弟” ）であるとは、次を意味する
⇒
［
%A の`親$ ~NEQ ~NULL
］~AND［
%A の`親$ ~EQ %B の`親$
］
◎
An object A is called a sibling of an object B, if and only if B and A share the same non-null parent.
</p>

<p class="trans-note">【
定義により， %A 自身も
<em>親が非~NULLならば</em>
%A の`同胞$になる。
この仕様の中では、この点について特に注意を要する箇所は（現時点では）ないが。
例えば、この同胞の定義を
“%A と %B は同じでない”
と解釈したとしても，この仕様の残りの部分には影響しない。
】</p>

<p>
~obj %A が~obj %B の
`広義同胞@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`同胞$である
］
◎
An inclusive sibling is an object or one of its siblings.
</p>

<p class="trans-note">【
%A 自身は，親が~NULLであっても %A の広義同胞になる点で、`同胞$の定義と異なる。
この定義は、もっぱら他の仕様のためにあり，この仕様~内では利用されない。
】</p>
<!-- https://github.com/whatwg/dom/issues/55 -->

<p>
~obj %A が~obj %B に
`先行-@
するとは、次を意味する
⇒
［
%A と %B は同じ`木$に関与する
］~AND［
`木~順序$において %A は %B より前に在る
］
<!-- * A ≺ B -->
◎
An object A is preceding an object B if A and B are in the same tree and A comes before B in tree order.
</p>

<p>
~obj %A が~obj %B に
`後続-@
するとは、次を意味する
⇒
［
%A と %B は同じ`木$に関与する
］~AND［
`木~順序$において %A は %B より後に在る
］
<!-- * A ≻ B -->
◎
An object A is following an object B if A and B are in the same tree and A comes after B in tree order.
</p>

<p>
~objの
`最初0の子@
とは、~objの`子$のうち，`最初0$のものである。
◎
The first child of an object is its first child or null if it has no children.
</p>

<p>
~objの
`最後0の子@
とは、~objの`子$のうち，`最後0$のものである。
◎
The last child of an object is its last child or null if it has no children.
</p>

<p>
~objの
`兄@
とは、~objに`先行-$する`同胞$のうち，`最後0$のものである。
◎
The previous sibling of an object is its first preceding sibling or null if it has no preceding sibling.
</p>

<p>
~objの
`弟@
とは、~objに`後続-$する`同胞$のうち，`最初0$のものである。
◎
The next sibling of an object is its first following sibling or null if it has no following sibling.
</p>

<p>
~objの
`指数@
とは、~objに`先行-$する`同胞$の個数である（なければ 0 になる）。
◎
The index of an object is its number of preceding siblings, or 0 if it has none. 
</p>




		</section>
		<section id="ordered-sets">
<h3 title="Ordered sets">1.2. 有順序~集合</h3>

<p class="algo-head">
文字列 %入力 を
`有順序~集合 構文解析器@
にかけるときは、次を走らす：
◎
The ordered set parser takes a string input and then runs these steps:
</p>

<ol>
	<li>
%入力~token列 ~LET %入力 を`~ASCII空白で分割-$した結果
◎
Let inputTokens be the result of splitting input on ASCII whitespace.
</li>
	<li>
%~token列 ~LET 新たな`有順序~集合$ 
◎
Let tokens be a new ordered set.
</li>
	<li>
%入力~token列 内の~EACH ( %~token ) に対し
⇒
%~token列 に %~token を`付加-$setする
◎
For each token in inputTokens, append token to tokens.
</li>
	<li>
~RET %~token列
◎
Return tokens.
</li>
</ol>

<p class="algo-head">
文字列からなる有順序~集合 %S を
`有順序~集合 直列化器@
にかけるときは、［
%S が空~集合ならば 空~文字列 ／
~ELSE_ %S 内の各 <!-- EACH --> 文字列を U+0020 区切りで連結した結果
］を返す。
◎
The ordered set serializer takes a set and returns the concatenation of the strings in set, separated from each other by U+0020, if set is non-empty, and the empty string otherwise.
</p>

		</section>
		<section id="selectors">
<h3 title="Selectors">1.3. 選択子</h3>


<p class="algo-head">
%node の
`視野の下で選択子を照合する@
ときは、所与の
( 文字列 %選択子 )
に対し，次を走らす：
◎
To scope-match a selectors string selectors against a node, run these steps:
</p>

<ol>
	<li>
%S ~LET `選択子として構文解析する$( %選択子 )
`SELECTORS4$r
◎
Let s be the result of parse a selector selectors. [SELECTORS4]
</li>
	<li>
~IF［
%S ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If s is failure, throw a SyntaxError.
</li>
	<li>
~RET
`木に対し選択子を照合する$( 選択子 %S, 根~要素たち %node の`根$, `視野根$ %node )
`SELECTORS4$r
<!-- ＊原文未更新 -->
◎
Return the result of evaluate a selector s against node’s root using scoping root node. [SELECTORS4].
</li>
</ol>

<p class="note">注記：
選択子の中の~nsに対する~supportは、計画されておらず，追加されることはない。
◎
Support for namespaces within selectors is not planned and will not be added.
</p>

		</section>
		<section id="namespaces">
<h3 title="Namespaces">1.4. ~ns</h3>

<p class="algo-head">
`有修飾~名として検証する@
ときは、所与の
( %名前 )
に対し，次を走らす
⇒
~IF［
%名前 は `Name$prod 生成規則にも `QName$prod 生成規則にも合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
To validate a qualifiedName, throw an InvalidCharacterError if qualifiedName does not match the Name or QName production.
</p>

<p class="algo-head">
`検証して抽出する@
ときは、所与の
( %~ns, %名前 )
に対し，次を走らす：
◎
To validate and extract a namespace and qualifiedName, run these steps:
</p>

<ol>
	<li id="cp-normalize-ns">
~IF［
%~ns ~EQ 空~文字列
］
⇒
%~ns ~SET ~NULL
◎
If namespace is the empty string, set it to null.
</li>
	<li>
`有修飾~名として検証する$( %名前 )
◎
Validate qualifiedName.
</li>
	<li>
%接頭辞 ~LET ~NULL
◎
Let prefix be null.
</li>
	<li>
%局所~名 ~LET %名前
◎
Let localName be qualifiedName.
</li>
	<li>
~IF［
%名前 は `:^l (U+003A) を含む
<span class="trans-note">【
`PrefixedName$prod 生成規則に合致
】</span>
］
⇒
( %接頭辞, %局所~名 ) ~SET
%名前 をそこで分割して得られる ( 前の部分, 後の部分 )
◎
If qualifiedName contains a ":" (U+003E), then split the string on it and set prefix to the part before and localName to the part after.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
↓</p>

		<ul>
			<li>
［
%~ns ~EQ ~NULL
］~AND［
%接頭辞 ~NEQ ~NULL
］
◎
If prefix is non-null and namespace is null, then throw a NamespaceError.
</li>
			<li>
［
%~ns ~NEQ `~XML~ns$
］~AND［
%接頭辞 ~EQ `xml^l
］
◎
If prefix is "xml" and namespace is not the XML namespace, then throw a NamespaceError.
</li>
			<li>
［
%~ns ~NEQ `~XMLNS~ns$
］~AND［［
%名前 ~EQ `xmlns^l
］~OR［
%接頭辞 ~EQ `xmlns^l
］］
◎
If either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace, then throw a NamespaceError.
</li>
			<li>
［
%~ns ~EQ `~XMLNS~ns$
］~AND［
%名前 ~NEQ `xmlns^l
］~AND［
%接頭辞 ~NEQ `xmlns^l
］
◎
If namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns", then throw a NamespaceError.
</li>
		</ul>

<p>
…ならば
⇒
~THROW `NamespaceError$E
◎
↑</p>

	</li>
	<li>
~RET ( %~ns, %接頭辞, %局所~名 )
◎
Return namespace, prefix, and localName.
</li>
</ol>


		</section>
	</section>
	<section id="events">
<h2 title="Events">2. ~event</h2>

		<section id="introduction-to-dom-events">
<h3 title="Introduction to “DOM Events”">2.1. “DOM Events” 序論</h3>

<!-- ^@EventTarget -->

<p>
Web ~platformを全体を通して，`~event$は、~network活動や利用者との対話など，何かが生じた際に通達するために，~objに向けて`配送-$される。
これらの~objは $EventTarget ~ifcを実装し，
その $addEventListener() を~callすることにより
`~event$を観測するための`~event~listener$を追加できる：
◎
Throughout the web platform events are dispatched to objects to signal an occurrence, such as network activity or user interaction. These objects implement the EventTarget interface and can therefore add event listeners to observe events by calling addEventListener():
</p>

<div class="example">
<pre class="js-code">
%obj.addEventListener("load", imgFetched)

function imgFetched(%ev) {
  // <span class="comment" title="great success">成功裡に load できた</span>
  …
}</pre>

</div>

<p>
`~event~listener$は、
$removeEventListener()
~methに同じ引数を渡すことにより除去できる。
◎
Event listeners can be removed by utilizing the removeEventListener() method, passing the same arguments.
</p>

<!-- ^@Event -->

<p>
`~event$もまた~objであり，
$Event ~ifc（またはその派生~ifc）を実装する。
上の例では、 %ev が`~event$である。
それは `~event~listener$の `callback$evL （概して上に示したような~JS Function ）に引数として渡される。
`~event~listener$は、まず，`~event$の $type 属性~値（上の例では `load^l ）をその~~制御に利用する。
`~event$の $target 属性~値は`~event$の`配送-$先の~obj（上の例の %obj ）を返す。
◎
Events are objects too and implement the Event interface (or a derived interface). In the example above ev is the event. It is passed as argument to event listener’s callback (typically a JavaScript Function as shown above). Event listeners key off the event’s type attribute value ("load" in the above example). The event’s target attribute value returns the object to which the event was dispatched (obj above).
</p>

<p id="synthetic-events">
概して、`~event$は，利用者との対話や何らかの~task完了の結果，~UAにより`配送-$されるものであるが、~app自身も`~event$を`配送-$できる（合成~eventと共通的に称されている）：
◎
Now while typically events are dispatched by the user agent as the result of user interaction or the completion of some task, applications can dispatch events themselves, commonly known as synthetic events:
</p>

<div class="example"><pre>// <span class="comment" title="add an appropriate event listener">~custom~event~listenerを追加-</span>
obj.addEventListener("cat", function(%e) { process(%e.detail) })

// <span class="comment" title="create and dispatch the event">~eventを作成して配送する</span>
var %event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
%obj.dispatchEvent(%event)</pre></div>

<p>
通達-時の他にも、`~event$は，演算の中で次に起きる出来事を~appに制御させる~~目的で利用されることがある。
例えば，~form提出の一環として、 $type 属性が `submit^l にされた`~event$が`配送-$される。
この`~event$の $preventDefault() ~methが呼出されると，~formは提出されずに終了されることになる。
~appにより`配送-$される`~event$（合成~event）を通して，この機能性を利用する場合、 $EventTarget.dispatchEvent() ~methの返値も利用できる：
◎
Apart from signaling, events are sometimes also used to let an application control what happens next in an operation. For instance as part of form submission an event whose type attribute value is "submit" is dispatched. If this event’s preventDefault() method is invoked, form submission will be terminated. Applications who wish to make use of this functionality through events dispatched by the application (synthetic events) can make use of the return value of the dispatchEvent() method:
</p>

<div class="example">

<pre class="js-code">
if(%obj.dispatchEvent(%event)) {
  // <span class="comment" title="event was not canceled, time for some magic">~eventは取消されなかった。手品の時間だ。</span>
  …
}</pre>

</div>

<p>
`~event$が`木$に`関与-$する~obj（例えば`要素$）に向けて`配送-$される場合、その~eventは，その~objの`先祖$ 上の`~event~listener$にも到達し得る：
◎
When an event is dispatched to an object that participates in a tree (e.g. an element), it can reach event listeners on that object’s ancestors too.＼
</p>

<ol>
	<li>
最初は、~objの各 `先祖$に対し，
`capture$evL 変数が ~T にされている`~event~listener$が`木~順序$で呼出される。
◎
First all object’s ancestor event listeners whose capture variable is set to true are invoked, in tree order.＼
</li>
	<li>
次に、~obj自身の`~event~listener$が呼出される。
◎
Second, object’s own event listeners are invoked.＼
</li>
	<li>
最後に、`~event$の $bubbles 属性~値が true のときにのみ，~objの各 `先祖$に対し
<span class="trans-note">【
`capture$evL 変数が ~F にされている
】</span>
`~event~listener$が，今度は`木~順序$の逆順に呼出される。
◎
And finally, and only if event’s bubbles attribute value is true, object’s ancestor event listeners are invoked again, but now in reverse tree order.
</li>
</ol>

<div class="example">
<p>
`~event$が`木$内で働く様子を例で示す：
◎
Lets look at an example of how events work in a tree:
</p>

<pre class="html-code">
&lt;!doctype html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Boring example&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;Hello <mark>&lt;span id=x&gt;world&lt;/span&gt;</mark>!&lt;/p&gt;
  &lt;script&gt;
<code
>function test(%e) {
  debug(%e.target, %e.currentTarget, %e.eventPhase); // A
}
document.addEventListener("hey", test, {capture: true}); // B
document.body.addEventListener("hey", test); // C
var %ev = new Event("hey", {bubbles:true})
document.getElementById(<mark>"x"</mark>).dispatchEvent(%ev);</code>
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
`debug^c 関数（A）は 2 度~呼出されることになる。
いずれを呼出したときも、`~event$の $target 属性~値は <mark>`span^c `要素$</mark> になる。
1 度目での $currentTarget 属性~値は`文書$になり（B）,
$eventPhase 属性の値が $CAPTURING_PHASE から $BUBBLING_PHASE に切り替わった後,
2 度目では `body^e `要素$になる（C）。
もし`~event~listener$が `span^e `要素$にも登録されていたなら、$eventPhase 属性の値は $AT_TARGET にも切り替わることになる。
◎
The debug function will be invoked twice. Each time the event’s target attribute value will be the span element. The first time currentTarget attribute’s value will be the document, the second time the body element. eventPhase attribute’s value switches from CAPTURING_PHASE to BUBBLING_PHASE. If an event listener was registered for the span element, eventPhase attribute’s value would have been AT_TARGET.
</p>
</div>

		</section>
		<section id="interface-event">
<h3>2.2. ~ifc ^@Event</h3>

⇒！
[$Constructor(~DS %type, optional $EventInit %eventInitDict),
`Exposed$=(Window,Worker)]
interface @Event {
  ~RA ~DS $type;
  ~RA $EventTarget? $target;
  ~RA $EventTarget? $currentTarget;
  sequence&lt;$EventTarget&gt; $composedPath();

  ~CUS $NONE = 0;
  ~CUS $CAPTURING_PHASE = 1;
  ~CUS $AT_TARGET = 2;
  ~CUS $BUBBLING_PHASE = 3;
  ~RA ~US $eventPhase;

  void $stopPropagation();
           attribute ~B $cancelBubble; // <span class="comment" title="historical alias of .stopPropagation">`stopPropagation()^c の歴史上の別名</span>
  void $stopImmediatePropagation();

  ~RA ~B $bubbles;
  ~RA ~B $cancelable;
  void $preventDefault();
  ~RA ~B $defaultPrevented;
  ~RA ~B $composed;

  [`Unforgeable$] ~RA ~B $isTrusted;
  ~RA $DOMHighResTimeStamp $timeStamp;

  void $initEvent(~DS %type, optional ~B %bubbles = false, optional ~B %cancelable = false); // <span id="cp-histroic" class="comment" title="historical">歴史上</span>
};

dictionary @EventInit {
  ~B @EventInit.bubbles = false;
  ~B @EventInit.cancelable = false;
  ~B @EventInit.composed = false;
};
◎


<p>
$Event ~objは、単に
`~event@
とも称される。
それは、何かが生じたときにそれが通達されるようにする
— 例えば，画像を~downloadし終えたときなど。
◎
An Event object is simply named an event. It allows for signaling that something has occurred, e.g., that an image has completed downloading.
</p>

<p>
各`~event$には、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`関係target@</dt>
	<dd>
~NULL または $EventTarget ~obj 。
他が定められない限り， ~NULL とする。
◎
An event has an associated relatedTarget (null or an EventTarget object). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
他の仕様は ^relatedTarget 属性を定義するときに `関係target$を利用する。
`UIEVENTS$r
◎
Other specifications use relatedTarget to define a relatedTarget attribute. [UIEVENTS]
</dd>

	<dt>`経路@</dt>
	<dd>
<p>
0 個~以上の組からなる~listであり，初期~時は空とする。
その各~組は、次のものからなる：
</p>
		<dl class="def-list">
			<dt>`item@evP</dt>
			<dd>
$EventTarget ~obj。
</dd>

			<dt>`target@evP</dt>
			<dd>
~NULL または $EventTarget ~obj。
</dd>

			<dt>`関係target@evP</dt>
			<dd>
~NULL または $EventTarget ~obj。
</dd>
		</dl>

<p>
そのような組を意図して与えられる値は、
組( %item, %target, %関係target )
のように表記される。
</p>

◎
An event has an associated path. A path is a list of tuples, each of which consists of an item (an EventTarget object), target (null or an EventTarget object), and a relatedTarget (null or an EventTarget object). A tuple is formatted as (item, target, relatedTarget). A path is initially the empty list.
</dd>


</dl>

<p>
`適用仕様$は、`~event$を
`再targetする手続き@
を定義して~MAY。
この~algoには、下に述べる`配送-$~algoに指示される %~event が渡される
◎
Specifications may define retargeting steps for all or some events. The algorithm is passed event, as indicated in the dispatch algorithm below.
</p>


<dl class="domintro">
	<dt>var %event = new $Event(type [, eventInitDict])</dt>
	<dd>
$type 属性~値が %type にされた，新たな %event を返す。
%eventInitDict 引数（省略可）により，~objの同じ名前の~memberを通して
$bubbles と $cancelable 属性も設定し得る。
◎
Returns a new event whose type attribute value is set to type. The optional eventInitDict argument allows for setting the bubbles and cancelable attributes via object members of the same name.
</dd>

	<dt>%event . $type</dt>
	<dd>
%event の型を返す。
例えば
`click^l,
`hashchange^l,
`submit^l
など。
◎
Returns the type of event, e.g. "click", "hashchange", or "submit".
</dd>


	<dt>%event . $target</dt>
	<dd>
%event の`配送-$先の~objを返す。
◎
Returns the object to which event is dispatched.
</dd>

	<dt>%event . $currentTarget</dt>
	<dd>
現在~呼出されている `callback$evL を持つ`~event~listener$が登録されている~objを返す。
◎
Returns the object whose event listener’s callback is currently being invoked.
</dd>

	<dt>%event . $composedPath()</dt>
	<dd>
%event の`経路$内にある各 `item$evP ~obj（それ上で~listenerが呼出される~obj）からなる~listを返す
— ただし、［
`~shadow根$の`~mode$sR ~EQ `closed^l
］なる`~shadow木$内の`~node$であって， %event の $currentTarget からは到達できないものは、返値から除かれる。
◎
Returns the item objects of event’s path (objects on which listeners will be invoked), except for any nodes in shadow trees of which the shadow root’s mode is "closed" that are not reachable from event’s currentTarget.
</dd>

	<dt>%event . $eventPhase</dt>
	<dd>
`~event$の相：
$NONE, $CAPTURING_PHASE, $AT_TARGET, $BUBBLING_PHASE 
のいずれかを返す。
◎
Returns the event’s phase, which is one of NONE, CAPTURING_PHASE, AT_TARGET, and BUBBLING_PHASE.
</dd>

	<dt>%event . $stopPropagation()</dt>
	<dd>
`木$ 内に`配送-$されているとき、この~methを呼び出すことにより，現在の~obj以外の~objには %event が到達しないようになる。
◎
When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.
</dd>

	<dt>%event . $stopImmediatePropagation()</dt>
	<dd>
この~methを呼出すことにより、
%event は 現在の~listenerを走り終えた後に［
それまでに登録された`~event~listener$
］には到達しなくなり、`木$ 内に`配送-$されたときには， %event は他のどの~objにも到達しなくなる。
◎
Invoking this method prevents event from reaching any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any other objects.
</dd>

	<dt>%event . $bubbles</dt>
	<dd>
%event がどう初期化されたかに応じて，~T か~F を返す。
%event がその $target 属性~値の`先祖$へ
`木~順序$の逆順にも遡る場合は ~T を返し,
他の場合は~F を返す。
◎
Returns true or false depending on how event was initialized. True if event goes through its target attribute value’s ancestors in reverse tree order, and false otherwise.
</dd>

	<dt>%event . $cancelable</dt>
	<dd>
%event がどう初期化されたかに応じて，~T か~F を返す。
その返値は常に意味を持つとは限らないが、~T の場合，
%event が`配送-$されている間の演算は
$preventDefault() ~methを呼出すことにより取消せることを指示し得る。
<!--  -->
◎
Returns true or false depending on how event was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which event was dispatched, can be canceled by invoking the preventDefault() method.
</dd>

	<dt>%event . $preventDefault()</dt>
	<dd>
%event の $cancelable 属性~値が ~T にされている下で，［
$AddEventListenerOptions.passive 属性を ~F に設定した %event
］に対する~listenerの実行-中に呼出された場合、
%event が取消される必要がある旨をその`配送-$ 演算に通達する。
◎
If invoked when the cancelable attribute value is true, and while executing a listener for the event with passive set to false, signals to the operation that caused event to be dispatched that it needs to be canceled.
</dd>

	<dt>%event . $defaultPrevented</dt>
	<dd>
~T は、 $preventDefault() が呼出され, 成功裡に取消されたことを指示する。
他の場合は~F を返す。
◎
Returns true if preventDefault() was invoked successfully to indicate cancelation, and false otherwise.
</dd>

	<dt>%event . $composed</dt>
	<dd>
%event がどう初期化されたかに依存して ~T か ~F を返す。
［
%event の $target 属性~値の`根$が $ShadowRoot `~node$である
］ときに，その~nodeを過ぎた先†にある~listenerも呼出す場合は ~T になり、他の場合は~F になる。
◎
Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target attribute value, and false otherwise.
</dd>
	<dd>【†
%~event の`経路$が、`~shadow根$の`~host$を通して別の`~node木$へつながるように，構成される。
】</dd>

	<dt>%event . $isTrusted</dt>
	<dd>
%event が~UA から`配送-$されたものである場合は~T を,
他の場合は~F を返す。
◎
Returns true if event was dispatched by the user agent, and false otherwise.
</dd>

	<dt>%event . $timeStamp</dt>
	<dd>
%event の時刻印を`時刻起点$からのミリ秒数で返す。
◎
Returns the event’s timestamp as the number of milliseconds measured relative to the time origin.
</dd>

</dl>

<dl class="idl-def">
	<dt>@type</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The type attribute must return the value it was initialized to.＼
</dd>
	<dd>
`~event$の作成-時には、この属性は空~文字列に初期化され~MUST。
◎
When an event is created the attribute must be initialized to the empty string.
</dd>

	<dt>@target</dt>
	<dt>@currentTarget</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化-時の値を返さ~MUST。
◎
The target and currentTarget attributes must return the values they were initialized to.＼
</dd>
	<dd>
`~event$の作成-時には、これらの属性は~NULL に初期化され~MUST。
◎
When an event is created the attributes must be initialized to null.
</dd>

	<dt>@composedPath()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The composedPath() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%~composed経路 ~LET 新たな空~list
◎
Let composedPath be a new empty list.
</li>
			<li>
%現~target ~LET 此れの $currentTarget 属性~値
◎
Let currentTarget be context object’s currentTarget attribute value.
</li>
			<li>
<p>
此れの`経路$内の~EACH ( %組 ) に対し：
</p>

				<ol>
					<li>
%item ~LET %組 の `item$evP
</li>
					<li>
<p>
~IF［
次のいずれかが満たされる
］…
</p>

<ul><li>［
%現~target は $Window ~objである
］~AND［
%item は`~node$である
］~AND［
%item は［
%item の`~shadowも含む根$
］から`~closed-shadow-hidden$である
］
</li><li>［
%現~target は`~node$である
］~AND［
%item は %現~target から`~closed-shadow-hidden$である
］
</li></ul>
<p>
…ならば
⇒
~CONTINUE
</p>

					</li>
					<li>
%item を %~composed経路 に付加する
</li>
				</ol>
◎
For each tuple in context object’s path:
• If currentTarget is a Window object, then:
•• If tuple’s item is not a node, or tuple’s item is not closed-shadow-hidden from tuple’s item’s shadow-including root, then append tuple’s item to composedPath.
• Otherwise, if currentTarget is a node and tuple’s item is not closed-shadow-hidden from currentTarget, or currentTarget is not a node, then append tuple’s item to composedPath.
</li>
			<li>
~RET %~composed経路
◎
Return composedPath.
</li>
		</ol>

<p class="note">注記：
この~algoは、`配送-$~algoに対する %target 引数が`~node$でないときは，
%~event 引数の最終的な`経路$内のどの組も，`~node$を包含しないものと見做している。
◎
This algorithm assumes that when the target argument to the dispatch algorithm is not a node, none of the tuples in event argument’s eventual path will contain a node either.
</p>
	</dd>


	<dt>@eventPhase</dt>
	<dd>
<p>
取得子は、初期化-時の値を返さ~MUST。
値は、次のいずれかで~MUST（括弧内は数値）：
◎
The eventPhase attribute must return the value it was initialized to, which must be one of the following:
</p>

		<dl>
			<dt>@NONE (0)</dt>
			<dd>
まだ`配送-$されていない`~event$はこの相に属する。
◎
Events not currently dispatched are in this phase.
</dd>

			<dt>@CAPTURING_PHASE (1)</dt>
<!-- * numeric value -->
			<dd>
`~event$が`木$に`関与-$する~objに向けて`配送-$されるとき、~eventがその $target 属性~値に到達するまでは，この相に属する。
◎
When an event is dispatched to an object that participates in a tree it will be in this phase before it reaches its target attribute value.
</dd>

			<dt>@AT_TARGET (2)</dt>
			<dd>
`~event$が`配送-$されるとき、~eventの $target 属性~値 上では，この相に属する。
◎
When an event is dispatched it will be in this phase on its target attribute value.
</dd>

			<dt>@BUBBLING_PHASE (3)</dt>
			<dd>
`~event$が`木$に`関与-$する~objに向けて`配送-$されるとき、~eventがその $target 属性~値に到達した後は，この相に属する。
◎
When an event is dispatched to an object that participates in a tree it will be in this phase after it reaches its target attribute value.
</dd>
		</dl>
	</dd>
	<dd>
<!-- Initially -->
`~event$の作成-時には、この属性は $NONE に初期化され~MUST。
◎
Initially the attribute must be initialized to NONE.
</dd>
</dl>

<p>
各`~event$には、次の~flagが結付けられる
— いずれも初期~時は ~OFF とする：
◎
Each event has the following associated flags that are all initially unset:
</p>

<div >
<ul><li>`伝播停止@f
</li><li>`伝播即停止@f
</li><li>`被取消@f
</li><li>`受動~listener内@f
</li><li>`~composed@f
</li><li>`初期化-済み@f
</li><li>`配送-@f
</li></ul>

◎
stop propagation flag
◎
stop immediate propagation flag
◎
canceled flag
◎
in passive listener flag
◎
composed flag
◎
initialized flag
◎
dispatch flag
</div>


<dl class="idl-def">
	<dt>@stopPropagation()</dt>
	<dd>
被呼出時には、次を設定し~MUST
⇒
此れの`伝播停止$f ~SET ~ON
◎
The stopPropagation() method, when invoked, must set the context object’s stop propagation flag.
</dd>

	<dt>@cancelBubble</dt>
	<dd>
取得子は、此れの`伝播停止$f に応じて［
~ON ならば ~T ／
~OFF ならば ~F
］を返さ~MUST。
◎
The cancelBubble attribute’s getter must return true if context object’s stop propagation flag is set, and false otherwise.
</dd>

	<dt>@stopImmediatePropagation()</dt>
	<dd>
被呼出時には、次をし~MUST
⇒
此れの ( `伝播停止$f, `伝播即停止$f ) ~SET ( ~ON, ~ON )
◎
The stopImmediatePropagation() method, when invoked, must set context object’s stop propagation flag and context object’s stop immediate propagation flag.
</dd>

	<dt>@bubbles</dt>
	<dt>@cancelable</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化-時の値を返さ~MUST。
◎
The bubbles and cancelable attributes must return the values they were initialized to.
</dd>

	<dt>@preventDefault()</dt>
	<dd>
被呼出時には、次をし~MUST
⇒
~IF［
此れの $cancelable 属性~値 ~EQ ~T
］~AND［
此れの`受動~listener内$f ~EQ ~OFF
］
⇒
此れの`被取消$f ~SET ~ON
◎
The preventDefault() method, when invoked, must set the canceled flag if the cancelable attribute value is true and the in passive listener flag is unset.
</dd>
	<dd class="note">注記：
これは、 $preventDefault() を呼出しても効果がない局面もあることを意味する。
~UAには、~debugを援助するため，精確な~~原因を開発者~consoleに~logすることが奨励される。
◎
This means there are scenarios where invoking preventDefault() has no effect. User agents are encouraged to log the precise cause in a developer console, to aid debugging.
</dd>

	<dt>@defaultPrevented</dt>
	<dd>
取得子は、此れの`被取消$f に応じて［
~ON ならば ~T ／
~OFF ならば ~F
］を返さ~MUST。
◎
The defaultPrevented attribute’s getter must return true if context object’s canceled flag is set, and false otherwise.
</dd>

	<dt>@composed</dt>
	<dd>
取得子は、此れの`~composed$f に応じて［
~ON ならば ~T ／
~OFF ならば ~F
］を返さ~MUST。
◎
The composed attribute’s getter must return true if context object’s composed flag is set, and false otherwise.
</dd>

	<dt>@isTrusted</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The isTrusted attribute must return the value it was initialized to.＼
</dd>
	<dd>
`~event$の作成-時には、この属性は~F に初期化され~MUST。
◎
When an event is created the attribute must be initialized to false.
</dd>
	<dd class="note">注記：
$isTrusted は、`~event$は（ $EventTarget.dispatchEvent() を利用してではなく）~UAにより`配送-$されたかどうかを簡便に指示する。
唯一の旧来の例外は `click()$m であり，~UAに`~event$を［
$isTrusted 属性は ~F に初期化-
］した上で配送させる。
◎
isTrusted is a convenience that indicates whether an event is dispatched by the user agent (as opposed to using dispatchEvent()). The sole legacy exception is click(), which causes the user agent to dispatch an event whose isTrusted attribute is initialized to false.
</dd>

	<dt>@timeStamp</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The timeStamp attribute must return the value it was initialized to.
</dd>
	<dd class="XXX">
既存の
<a href="~HRTIME#clock-resolution">時計~分解能の推奨</a>
に従って、~UAには，この属性の分解能を 5 マイクロ秒までの細かさに設定することが強く奨励される。
`HR-TIME$r
◎
User agents are strongly encouraged to set minimum resolution of the timeStamp attribute to 5 microseconds following the existing clock resolution recommendation. [HR-TIME]
</dd>
</dl>


<p class="algo-head">
%event を
`初期化する@
ときは、所与の
( %type, %bubbles, %cancelable )
に対し，
%event の各種［
~flag, 属性
］を次のように初期化し~MUST：
◎
To initialize an event, with type, bubbles, and cancelable, run these steps:
</p>

<ul>
	<li>
( `初期化-済み$f, `伝播停止$f, `伝播即停止$f, `被取消$f )
~SET
( ~ON, ~OFF, ~OFF, ~OFF )
◎
Set the initialized flag.
◎
Unset the stop propagation flag, stop immediate propagation flag, and canceled flag.
</li>
	<li>
$isTrusted 属性 ~SET ~F
◎
Set the isTrusted attribute to false.
</li>
	<li>
$target 属性 ~SET ~NULL
◎
Set the target attribute to null.
</li>
	<li>
$type 属性 ~SET %type
◎
Set the type attribute to type.
</li>
	<li>
$bubbles 属性 ~SET %bubbles
◎
Set the bubbles attribute to bubbles.
</li>
	<li>
$cancelable 属性 ~SET %cancelable
◎
Set the cancelable attribute to cancelable.
</li>
</ul>


<dl class="idl-def">
	<dt>@initEvent(type, bubbles, cancelable)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The initEvent(type, bubbles, cancelable) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの`配送-$f ~EQ ~ON
］
⇒
~RET
◎
If context object’s dispatch flag is set, then return.
</li>
			<li>
此れを`初期化する$( %type, %bubbles, %cancelable )
◎
Initialize context object with type, bubbles, and cancelable. 
</li>
		</ol>
	</dd>
	<dd class="note">注記：
$initEvent() は、`~event$が構築子を持つので冗長であり，また $composed も設定できないが、旧来の内容のために~supportされる必要がある。
◎
As events have constructors initEvent() is redundant and incapable of setting composed. It has to be supported for legacy content.
</dd>
</dl>


		</section>
		<section id="interface-customevent">
<h3>2.3. ~ifc ^@CustomEvent</h3>

⇒！
[$Constructor(~DS %type, optional $CustomEventInit %eventInitDict),
 `Exposed$=(Window,Worker)]
interface @CustomEvent : $Event {
  ~RA any $detail;

  void $initCustomEvent(~DS %type, optional ~B %bubbles = false, optional ~B %cancelable = false, any %detail = null);
};

dictionary @CustomEventInit : $EventInit {
  any @CustomEventInit.detail = null;
};
◎

<!-- ^@CustomEvent -->
<p>
~custom~dataを運ばせる用途に，
$CustomEvent ~ifcを利用する`~event$を利用できる。
◎
Events using the CustomEvent interface can be used to carry custom data.
</p>

<dl class="domintro">
	<dt>var %event = new $CustomEvent(type [, eventInitDict])</dt>
	<dd>
%eventInitDict 引数（省略可）により，
$detail 属性も設定できることを除き、
$Event の構築子と同様にふるまう。
◎
Works analogously to the constructor for Event except that the optional eventInitDict argument now allows for setting the detail attribute too.
</dd>

	<dt>%event . $detail</dt>
	<dd>
%event の作成-時に与えられた~custom~dataを返す。
概して，合成~eventで利用される。
<!-- initCustomEvent is dead -->
◎
Returns any custom data event was created with. Typically used for synthetic events.
</dd>

</dl>

<dl class="idl-def">
	<dt>@detail</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The detail attribute must return the value it was initialized to.
</dd>

	<dt>@initCustomEvent(type, bubbles, cancelable, detail)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The initCustomEvent(type, bubbles, cancelable, detail) method must, when invoked, run these steps:
</p>

		<ol>
			<li>
~IF［
此れの`配送-$f ~EQ ~ON
］
⇒
~RET
◎
If context object’s dispatch flag is set, then return.
</li>
			<li>
此れを`初期化する$( %type, %bubbles, %cancelable )
◎
Initialize the context object with type, bubbles, and cancelable.
</li>
			<li>
此れの $detail 属性 ~SET %detail
◎
Set context object’s detail attribute to detail.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="constructing-events">
<h3 title="Constructing events">2.4. ~eventの構築-法</h3>

<dl class="idl-def">
	<dt>@Event.Event(type, eventInitDict)</dt>
	<dt>@CustomEvent.CustomEvent(type, eventInitDict)</dt>
	<dd>
<p>
`~event構築子@
— すなわち， $Event ~ifc, または それを継承する~ifcの構築子 —
は、次を走らせ~MUST：
◎
When a constructor of the Event interface, or of an interface that inherits from the Event interface, is invoked, these steps must be run, given the arguments type and eventInitDict: 
</p>

		<ol>
			<li>
%~event ~LET 当の~ifcを利用する，新たな~obj
◎
Create a new object event using this interface.
</li>
			<li>
%~event の`初期化-済み$f ~SET ~ON
◎
Set event’s initialized flag.
</li>
			<li>
%~event の $Event.type 属性 ~SET %type に初期化する
◎
Initialize event’s type attribute to type.
</li>
			<li>
%~event の $timeStamp 属性 ~SET ［
`時刻起点$から［
%~event の`~event構築子$の~callが生じた時点
］までの高分解能な時間差
］を表現している $DOMHighResTimeStamp 値に初期化する
◎
Initialize event’s timeStamp attribute to a DOMHighResTimeStamp representing the high resolution time from the time origin to the occurrence of the call to the event’s constructor.
</li>
			<li>
%eventInitDict に在する~EACH ( `辞書~member$ %m ) に対し
⇒
~IF［
%~event は %m の key を`識別子$とする属性を持つ
］
⇒
その属性~値 ~SET %m の値
◎
For each dictionary member present in eventInitDict, find the attribute on event whose identifier matches the key of the dictionary member and then set the attribute to the value of that dictionary member.
</li>
			<li>
~RET %~event
◎
Return event.
</li>
		</ol>
	</dd>
</dl>

<div class="p">
<p class="algo-head">
`~eventを作成する@
ときは、所与の：
</p>

<ul><li>%~event~ifc （ $Event または それを継承する~ifc ）
</li><li>%~realm （ `~Realm$, 省略時は ε ）
</li></ul>

<p>
に対し，次を走らす：
</p>
◎
To create an event using eventInterface, which must be either Event or an interface that inherits from it, and optionally given a Realm realm, run these steps:
</div>

<ol>
	<li>
<p>
%~event ~LET
%~event~ifc を利用する, %~realm 内の，新たな~obj
— ただし， %~realm ~EQ ε の場合は Web IDL に定義される既定の挙動に従う
◎
Create a new object event using eventInterface. If realm is given, use that Realm; otherwise, use the default behavior defined in Web IDL.
</p>

<p class="XXX">
これを書いている時点では、まだ Web IDL はこの既定の挙動を定義していない。
<a href="https://github.com/heycam/webidl/issues/135">heycam/webidl#135</a>
を見よ。
◎
As of the time of this writing Web IDL does not yet define any default behavior; see heycam/webidl#135.
</p>
	</li>
	<li>
%~event の`初期化-済み$f ~SET ~ON
◎
Set event’s initialized flag.
</li>
	<li>
%辞書~型 ~LET %~event~ifc の構築子が引数に受容する辞書~型（ $EventInit またはそれを継承する辞書~型）
◎
↓</li>
	<li>
%辞書~値 ~LET ~JS `undefined^c 値を %辞書~型 に`変換-$した結果
◎
Let defaultEventInitDict be the result of converting the JavaScript value undefined to the dictionary type accepted by eventInterface’s constructor. (This dictionary type will either be EventInit or a dictionary that inherits from it.)
</li>
	<li>
%辞書~値 に在する~EACH ( `辞書~member$ %m ) に対し
⇒
%~event の［
%m の key を`識別子$とする属性
］の値 ~SET %m の値（すなわち，既定~値）<!-- ＊ -->
◎
For each dictionary member present in defaultEventInitDict, find the attribute on event whose identifier matches the key of the dictionary member and then set the attribute to the default value of that dictionary member.
</li>
	<li>

<p>
%~event の $timeStamp 属性 ~SET ［
`時刻起点$から %~event を通達する時点までの高分解能な時間差
］を表現している $DOMHighResTimeStamp 値
◎
Set event’s timeStamp attribute to a DOMHighResTimeStamp representing the high resolution time from the time origin to the occurrence that the event is signaling.
</p>

<p class="note">注記：
例えば macOS においては、［
入力~動作が生じた時点に対応する ^NSEvent ~objの ^timestamp ~prop
］を介して可用になる。
この事例における $timeStamp 値は、［
`時刻起点$から ^NSEvent による時刻印までの差分
］を，［
<a href="~HRTIME#clock-resolution">時計~分解能を一定の細かさまでに抑える</a>
ように精度を調整する下で，ミリ秒数に換算した結果
］に等価になる。
◎
For example, in macOS the occurrence time for input actions are available via the timestamp property of corresponding NSEvent objects. So in this case, the timeStamp value will be equivalent to the NSEvent’s timestamp offset by time origin, translated in milliseconds, and with its precision adjusted to meet the minimum clock resolution.
</li>
	<li>
%~event の $isTrusted 属性 ~SET ~T に初期化する
◎
Initialize event’s isTrusted attribute to true.
</li>
	<li>
~RET %~event 
◎
Return event.
</li>
</ol>

<p class="note">注記：
`~eventを作成する$手続きは、単純に~eventを`発火-$する代わりに［
`~eventを作成する$, ~eventを`配送-$する
］手続きを別々に呼出す必要がある，他の仕様からの利用が~~意図されている。
これは、~eventの属性が既定の値に正しく初期化されることを確保する。
◎
Create an event is meant to be used by other specifications which need to separately create and dispatch events, instead of simply firing them. It ensures the event’s attributes are initialized to the correct defaults.
</p>

		</section>
		<section id="defining-event-interfaces">
<h3 title="Defining event interfaces">2.5. ~event~ifcの定義-法</h3>

<p>
一般に、$Event を継承する新たな~ifcを定義する際には，常に
<a href="https://whatwg.org/">WHATWG</a>
または
<a href="https://www.w3.org/2008/webapps/">W3C WebApps WG</a>
~communityからの~feedbackを仰ぐように願う。
◎
In general, when defining a new interface that inherits from Event please always ask feedback from the WHATWG or the W3C WebApps WG community.
</p>

<p>
$CustomEvent ~ifcはその出発点に利用できるものだが、 `init*Event()^c の類いの~methは，構築子とかぶって冗長になるので導入しないように。
$Event ~ifcを継承する~ifcがその種の~methを備えているのは、歴史上の理由に限られている。
◎
The CustomEvent interface can be used as starting point. However, do not introduce any init*Event() methods as they are redundant with constructors. Interfaces that inherit from the Event interface that have such a method only have it for historical reasons.
</p>

		</section>
		<section id="interface-eventtarget">
<h3>2.6. ~ifc ^@EventTarget</h3>

⇒！
[$Constructor,
 `Exposed$=(Window,Worker)]
interface @EventTarget {
  void $addEventListener(~DS %type, $EventListener? %callback, optional ($AddEventListenerOptions or ~B) %options);
  void $removeEventListener(~DS %type, $EventListener? %callback, optional ($EventListenerOptions or ~B) %options);
  ~B $dispatchEvent($Event %event);
};

callback interface @EventListener {
  void @EventListener.handleEvent($Event %event);
};

dictionary @@EventListenerOptions {
  boolean @capture = false;
};

dictionary @@AddEventListenerOptions : $EventListenerOptions {
  boolean @passive = false;
  boolean @once = false;
};
◎

<p>
$@EventTarget ~objは、何かが起きた時に`~event$が`配送-$される~targetを表現する。
◎
The EventTarget object represents the target to which an event is dispatched when something has occurred.
</p>

<div class="p">
<p>
各 $EventTarget ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~listener~list@</dt>
	<dd>
0 個~以上の`~event~listener$からなる~list
</dd>
</dl>
◎
Each EventTarget object has an associated list of event listeners.
</div>


<p>
`~event~listener@
を利用すれば、特定の`~event$を観測できる。
◎
An event listener can be used to observe a specific event.
</p>

<p>
各`~event~listener$は、次の~fieldからなる：
◎
An event listener consists of these fields:
</p>

<ul>
	<li>
`type@evL
— 文字列
◎
type (a string)
</li>
	<li>
`callback@evL
— $EventListener
◎
callback (an EventListener)
</li>
	<li>
`capture@evL
— 真偽値,
初期~時は ~F とする。
◎
capture (a boolean, initially false)
</li>
	<li>
`passive@evL
— 真偽値,
初期~時は ~F とする。
◎
passive (a boolean, initially false)
</li>
	<li>
`once@evL
— 真偽値,
初期~時は ~F とする。
◎
once (a boolean, initially false) 
</li>
	<li>
`removed@evL
— 内部処理用の真偽値,
初期~時は ~F とする。
◎
removed (a boolean for bookkeeping purposes, initially false) 
</li>
</ul>


<p class="note">注記：
上の~fieldに示したように， `callback$evL は $EventListener であるが、`~event~listener$は，より広い概念である。
◎
Although callback is an EventListener, as can be seen from the fields above, an event listener is a broader concept.
</p>

<p>
各 $EventTarget ~objには、その
`親~targetを取得する@
~algoも結付けられる。
それは、所与の`~event$に対し，［
$EventTarget ~obj, または ~NULL
］を返す。
他から指定されない限り， ~NULL を返すとする。
◎
Each EventTarget object also has an associated get the parent algorithm, which takes an event event, and returns an EventTarget object. Unless specified otherwise it returns null.
</p>

<p class="note">注記：
［
`~node$ ／ `~shadow根$ ／ `文書$
］は、`親~targetを取得する$~algoを上書きする。
◎
Nodes, shadow roots, and documents override the get the parent algorithm.
</p>

<p class="trans-note">【
この~algoは、~eventの`配送-$時にその伝播`経路$を構築するために利用される。
】【
指定される個々の~algoには、渡された~eventを利用しないものもある（その場合、~eventは省略して記述され得る）。
】</p>

<p>
各 $EventTarget ~objには、
`作動化の挙動@
が結付けられ得る。
この~algoには、`配送-$~algoにて指示されるように，`~event$が渡される。
◎
Each EventTarget object can have an associated activation behavior algorithm. The activation behavior algorithm is passed an event, as indicated in the dispatch algorithm.
</p>

<p class="note">注記：
これが存在するのは、~UAが
ある種の $EventTarget ~objに対し，ある種の動作を遂行するためである
— 例えば `area$e 要素は、合成 $MouseEvent `~event$に呼応して，その $Event.type 属性は `click^l にされる。
それを除去することは、~Web互換性のため できない。
それはまた、今や，何らかの作動化を定義するときに~~尊守されている仕方になっている。
`HTML$r
◎
This exists because user agents perform certain actions for certain EventTarget objects, e.g., the area element, in response to synthetic MouseEvent events whose type attribute is click. Web compatibility prevented it from being removed and it is now the enshrined way of defining an activation of something. [HTML]
</p>

<p>
加えて、`作動化の挙動$を有する各 $EventTarget ~objには、［
`旧来の作動化~前の挙動@,
`旧来の作動化~取消~時の挙動@
］を備えるものもある（片方のみ備えることはない）。
◎
Each EventTarget object that has activation behavior, can additionally have both (not either) a legacy-pre-activation behavior algorithm and a legacy-canceled-activation behavior algorithm. 
</p>

<p class="note">注記
これらの~algoは，［
Checkbox ／ Radio
］状態にある `input$e 要素のみに存在し、他では利用されない。
`HTML$r
◎
These algorithms only exist for checkbox and radio input elements and are not to be used for anything else. [HTML]
</p>

<dl class="domintro">
	<dt>%target = new $EventTarget();</dt>
	<dd>
開発者が`~event$を`配送-$して~listenするために利用できる，新たな $EventTarget ~objを作成する。
◎
Creates a new EventTarget object, which can be used by developers to dispatch and listen for events. 
</dd>

	<dt>%target . $addEventListener(type, callback [, options])</dt>
	<dd>
［
$Event.type 属性~値が %type である`~event$
］に対する`~event~listener$を， %target の`~listener~list$に付加する。
%callback 引数が，`~event$が`配送-$されたときに呼出される `callback$evL として設定される。
◎
Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
</dd>
	<dd>
%options 引数は、~listener特有の~optionを設定する。
互換性のため、これはただの真偽値もとり得る
— その場合、この~methは，正確に［
%options の ^capture ~memberに その値が指定された
］かのように挙動する。
◎
The options argument sets listener-specific options. For compatibility this can be just a boolean, in which case the method behaves exactly as if the value was specified as options’ capture member.
</dd>
	<dd>
%options の $EventListenerOptions.capture ~memberが［
~T ／ ［
~F または不在
］］の場合、
`callback$evL は，［
`~event$の $eventPhase 属性~値が［
$Event.BUBBLING_PHASE ／  $Event.CAPTURING_PHASE 
］の間は，呼出されない
］ようになる。
いずれにせよ、`~event$の $Event.eventPhase 属性~値が $Event.AT_TARGET のときは，
`callback$evL は呼出される。
◎
When set to true, options’ capture member prevents callback from being invoked when the event’s eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event’s eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event’s eventPhase attribute value is AT_TARGET.
</dd>
	<dd>
%options の $AddEventListenerOptions.passive ~memberに対する ~T は、
`callback$evL は $Event.preventDefault() を呼出しても`~event$を取消さないことを指示する。
これは、
<a href="#observing-event-listeners">~event~listenerの観測-法</a>
に述べる処理能の最適化を可能化するために利用される
◎
When set to true, options’ passive member indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in §2.7 Observing event listeners.
</dd>

	<dd>
%options の $AddEventListenerOptions.once ~memberが ~T に設定されている場合、~callbackが呼出されるのは一度限りであり，その後には`~event~listener$は除去されることを指示する。
◎
When set to true, options’s once member indicates that the callback will only be invoked once after which the event listener will be removed.
</dd>

	<dd>
`~event~listener$は、重複しない場合（
`type$evL, `callback$evL, `capture$evL
のいずれかが異なる場合）に限り，
%target の`~listener~list$に付加される。
◎
The event listener is appended to target’s list of event listeners and is not appended if it is a duplicate, i.e., having the same type, callback, and capture values.
</dd>

	<dt>%target . $removeEventListener(type, callback [, options])</dt>
	<dd>
引数と同じ［
`type$evL, `callback$evL, `capture$evL
］を持つ`~event~listener$を
%target の`~listener~list$から除去する。
◎
Remove the event listener in target’s list of event listeners with the same type, callback, and options.
</dd>

	<dt>%target . $dispatchEvent(event)</dt>
	<dd>
合成~event %event を %target に向けて`配送-$する。
［
	<!-- ^@Event -->
%event の $cancelable 属性~値が ~F であるか, または
%event の $preventDefault() ~methが呼出されていないとき
］は~T，他の場合は~F を返す。
◎
Dispatches a synthetic event event to target and returns true if either event’s cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.
</dd>

</dl>

	<!-- ^@EventTarget -->


<p class="algo-head">
%options を
`平坦化-@
するときは、次を走らす：
◎
To flatten options, run these steps:
</p>

<ol>
	<li>
~IF［
%options は ~B 型である
］
⇒
~RET %options
◎
If options is a boolean, then return options.
</li>
	<li>
~RET %options の $EventListenerOptions.capture ~member値
◎
Return options’s capture.
</li>
</ol>


<p class="algo-head">
%options を
`もっと平坦化-@
するときは、次を走らす：
◎
To flatten more options, run these steps:
</p>

<ol>
	<li id="cp-let-capture-flatten">
%capture ~LET
%options を `平坦化-$した結果
◎
Let capture be the result of flattening options.
</li>
	<li>
( %once, %passive ) ~LET ( ~F, ~F )
◎
Let once and passive be false.
</li>
	<li>
~IF［
%options は辞書~型である
］
⇒
( %passive, %once ) ~SET
%options の
( $AddEventListenerOptions.passive, $AddEventListenerOptions.once )
~member値
◎
If options is a dictionary, then set passive to options’s passive and once to options’s once.
</li>
	<li>
~RET
( %capture, %passive, %once )
◎
Return capture, passive, and once.
</li>
</ol>

<dl class="idl-def">
	<dt>@EventTarget()</dt>
	<dd>
この構築子の被呼出時には、新たな $EventTarget を返さ~MUST。
◎
The EventTarget() constructor, when invoked, must return a new EventTarget.
</dd>
	<dd class="note">注記：
他所に定められる既定により、返される $EventTarget の`親~targetを取得する$~algoは，~NULL を返すことになり、［
`作動化の挙動$,
`旧来の作動化~前の挙動$,
`旧来の作動化~取消~時の挙動$
］は無い。
◎
Because of the defaults stated elsewhere, the returned EventTarget's get the parent algorithm will return null, and it will have no activation behavior, legacy-pre-activation behavior, or legacy-canceled-activation behavior.
</dd>
	<dd class="note">注記：
将来には、`親~targetを取得する$~custom~algoも許容され得る。
作者は、それが自身の~programに有用になるなら知らせてほしい。
今の所は、作者が作成したどの $EventTarget も，木~構造には関与しない。
◎
In the future we could allow custom get the parent algorithms. Let us know if this would be useful for your programs. For now, all author-created EventTargets do not participate in a tree structure.
</dd>

	<dt>@addEventListener(type, callback, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The addEventListener(type, callback, options) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
<p id="cp-ever-been-evaluated">
~IF［
此れに`関連する大域~obj$ %G は $ServiceWorkerGlobalScope ~objである
］~AND［
%G に結付けられている`~sw$の`~script資源$の，`評価されたことがある~flag$ ~EQ ~ON
］`SERVICE-WORKERS$r
⇒
~THROW `TypeError$E
◎
If context object’s relevant global object is a ServiceWorkerGlobalScope object and its associated service worker’s script resource’s has ever been evaluated flag is set, then throw a TypeError. [SERVICE-WORKERS]
</p>

<p class="note">注記：
当の~swに対し許容される~event型の格納を最適化するため, および
~event~listenerに対する非決定的な変更を避けるため、この~methの呼出は，~sw~scriptが初めて評価される間にのみ許容される。
◎
To optimize storing the event types allowed for the service worker and to avoid non-deterministic changes to the event listeners, invocation of the method is allowed only during the very first evaluation of the service worker script.
</p>
			</li>
			<li>
~IF［
%callback ~EQ ~NULL
］
⇒
~RET
◎
If callback is null, then return.
</li>
			<li>
( %capture, %passive, %once ) ~LET
%options を`もっと平坦化-$した結果
◎
Let capture, passive, and once be the result of flattening more options.
</li>
			<li>
~IF［
此れの`~listener~list$内に［
( `type$evL, `callback$evL, `capture$evL )
~EQ
( %type, %callback, %capture )
］なる`~event~listener$は在る
］
⇒
~RET
◎
If context object’s associated list of event listener does not contain an event listener whose type is type, callback is callback, and capture is capture, then＼
</li>
			<li>
次のように設定された`~event~listener$を，此れの`~listener~list$に付加する
⇒＃
`type$evL ~SET %type ,
`callback$evL ~SET %callback ,
`capture$evL ~SET %capture ,
`passive$evL ~SET %passive ,
`once$evL ~SET %once
◎
append a new event listener to it, whose type is type, callback is callback, capture is capture, passive is passive, and once is once.
</li>
		</ol>
	</dd>

	<dt>@removeEventListener(type, callback, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeEventListener(type, callback, options) method, when invoked, must, run these steps
</p>

		<ol>
			<li><!--cp-ever-been-evaluated--></li>
			<!--cp-let-capture-flatten-->
			<li>
<p>
~IF［
此れの`~listener~list$内に［
( `type$evL, `callback$evL, `capture$evL )
~EQ
( %type, %callback, %capture )
］なる`~event~listener$ %~listener は在る
］：
◎
If there is an event listener in the associated list of event listeners whose type is type, callback is callback, and capture is capture, then＼
</p>
				<ol>
					<li>
%~listener の `removed$evL ~SET ~T
◎
set that event listener’s removed to true and＼
</li>
					<li>
%~listener を`~listener~list$から除去する
◎
remove it from the associated list of event listeners.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>@dispatchEvent(event)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The dispatchEvent(event) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
%event の`配送-$f ~EQ ~ON
］~OR［
%event の`初期化-済み$f ~EQ ~OFF
］
⇒
~THROW `InvalidStateError$E
◎
If event’s dispatch flag is set, or if its initialized flag is not set, then throw an InvalidStateError.
</li>
			<li>
			<!-- ^@Event -->
%event の $isTrusted 属性 ~SET ~F に初期化する
◎
Initialize event’s isTrusted attribute to false.
</li>
			<li>
~RET 此れに向けて %event を`配送-$した結果
◎
Return the result of dispatching event to context object.
</li>
		</ol>
	</dd>
</dl>


		</section>
		<section id="observing-event-listeners">
<h3 title="Observing event listeners">2.7. ~event~listenerの観測-法</h3>

<p>
一般に、開発者は，`~event~listener$の有無が観測され得るものとは予期しない。
`~event~listener$の影響0は、その `callback$evL により決定される。
すなわち開発者は、何もしない`~event~listener$を追加するとき，副作用が生じるとは予期しない。
◎
In general, developers do not expect the presence of an event listener to be observable. The impact of an event listener is determined by its callback. That is, a developer adding a no-op event listener would not expect it to have any side effects.
</p>

<p>
あいにく，一部の~event~APIは、効率的に実装するためには，`~event~listener$の観測が要求される設計になっている。
すなわち、空の~listenerであっても，~appの挙動における処理能に劇的に影響0し得る結果、~listenerの有無が観測され得るようになっている。
例えば ~touch／~wheel ~eventの利用は、非同期~scrollingを阻むことがある。
一部の事例では、この問題は，［
~eventが $cancelable になるのは，非 $AddEventListenerOptions.passive ~listenerが 1 個~以上あるときに限る
］ように指定することで、軽減できる。
例えば、非 $AddEventListenerOptions.passive $TouchEvent ~listenerは，~scrollingを阻ま~MUSTが、すべての~listenerが $AddEventListenerOptions.passive ならば、
`~UAは^tnote
$TouchEvent を（ $preventDefault() の~callは無視されるように）取消せなくすることで，~scrollingを`並列的$に開始できるようになる。
なので、~eventを配送している~codeは，非 $AddEventListenerOptions.passive ~listenerの~~不在を観測でき、それを利用して配送-中の~eventの $cancelable ~propを ~F にできる。
◎
Unfortunately, some event APIs have been designed such that implementing them efficiently requires observing event listeners. This can make the presence of listeners observable in that even empty listeners can have a dramatic performance impact on the behavior of the application. For example, touch and wheel events which can be used to block asynchronous scrolling. In some cases this problem can be mitigated by specifying the event to be cancelable only when there is at least one non-passive listener. For example, non-passive TouchEvent listeners must block scrolling, but if all listeners are passive then scrolling can be allowed to start in parallel by making the TouchEvent uncancelable (so that calls to preventDefault() are ignored). So code dispatching an event is able to observe the absence of non-passive listeners, and use that to clear the cancelable property of the event being dispatched.
</p>

<p>
新たなどの~event~APIも，この~propを必要としないように定義されるのが理想的である（論を交わしたければ
<a href="https://lists.w3.org/Archives/Public/public-script-coord/">public-script-coord@<!---->w3.org</a>
を利用されたし）。
◎
Ideally, any new event APIs are defined such that they do not need this property (use public-scrip-coord@w3.org for discussion).
</p>


		</section>
		<section id="dispatching-events">
<h3 title="Dispatching events">2.8. ~eventの配送-法</h3>

<!-- ^@Event -->
<div class="p">
<p class="algo-head">
%target に向けて，`~event$ %~event を
`配送-@
するときは、次を走らす
— この手続きには，次も与えられ得る：
</p>

<ul ><li>%旧来~上書target~flag （省略時は ~OFF）
</li><li>`旧来（~listenerは投出したか？）~flag@V
— この~flagは参照渡しであり、加えられた改変は~call元に伝播する（与えられている場合に限り）。
また、（この手続きが間接的に呼出す）`~listenerを内部的に呼出す$ 手続きまで暗黙的に渡されるとする。
`これは、 Indexed Database ~APIのみから利用される。原文は，この~flagの受け渡しをいちいち記述していて煩雑なので、この訳ではこの一文に集約する。^tnote
</li></ul>
◎
To dispatch an event to a target, with an optional legacy target override flag and an optional legacyOutputDidListenersThrowFlag, run these steps: 
</div>

<ol>
	<li>
%~event の`配送-$f ~SET ~ON
◎
Set event’s dispatch flag.
</li>
	<li>
<p>
%上書target ~LET %旧来~上書target~flag に応じて
⇒
~OFF ならば %target ／
~ON ならば %target に`結付けられている文書$ `HTML$r
◎
Let targetOverride be target, if legacy target override flag is not given, and target’s associated Document otherwise. [HTML]
</p>

<p class="note">注記：
%旧来~上書target~flag は、~HTMLからのみ，それも %target が $Window ~objである場合に限り ~ON にされる。
◎
legacy target override flag is only used by HTML and only when target is a Window object.
</p>
	</li>
	<li>
%関係target ~LET ［
%~event の`関係target$ ~EQ ~NULL ならば ~NULL ／
~ELSE_ %関係target を %target に向けて`再target$した結果
］
◎
Let relatedTarget be the result of retargeting event’s relatedTarget against target if event’s relatedTarget is non-null, and null otherwise.
</li>
	<li>
~IF［
%target ~EQ %関係target 
］~AND［
%target ~NEQ %~event  の`関係target$
］
⇒
~RET ~T
◎
If target is relatedTarget and target is not event’s relatedTarget, then return true.
</li>
	<li>
%~event の`経路$に
組( %target, %上書target, %関係target )
を付加する
◎
Append (target, targetOverride) to event’s path.
</li>
	<li>
`作動化~eventか？^V ~LET［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%~event は $MouseEvent ~objである
］~AND［
%~event の $type 属性 ~EQ `click^l
］
◎
Let isActivationEvent be true, if event is a MouseEvent object and event’s type attribute is "click", and false otherwise.
</li>
	<li>
%作動化~target ~LET［
次が満たされるならば %target ／
~ELSE_ ~NULL
］
⇒
［
`作動化~eventか？^V ~EQ ~T
］~AND［
%target は`作動化の挙動$を有する
］
◎
Let activationTarget be target, if isActivationEvent is true and target has activation behavior, and null otherwise.
</li>
	<li>
%親 ~LET
%target の`親~targetを取得する$( %~event )
◎
Let parent be the result of invoking target’s get the parent with event.
</li>
	<li>
<p>
~WHILE［
%親 ~NEQ ~NULL
］：
◎
While parent is non-null:
</p>
		<ol>
			<li>
%関係target ~LET %~event の`関係target$
◎
↓</li>
			<li>
~IF［
%関係target ~NEQ ~NULL
］
⇒
%関係target ~SET %関係target を %親 に向けて`再target$した結果
◎
Let relatedTarget be the result of retargeting event’s relatedTarget against parent if event’s relatedTarget is non-null, and null otherwise.
</li>
			<li>
<p>
~IF［
%target の`根$ は %親 の`~shadowも含む広義先祖$である
］：
◎
If target’s root is a shadow-including inclusive ancestor of parent, then:
</p>

				<ol>
					<li>
<p>
~IF［
`作動化~eventか？^V ~EQ ~T
］~AND［
%~event  の $bubbles 属性 ~EQ ~T
］~AND［
%作動化~target ~EQ ~NULL
］~AND［
%親 は`作動化の挙動$を有する
］
⇒
%作動化~target ~SET %親 
◎
If isActivationEvent is true, event’s bubbles attribute is true, activationTarget is null, and parent has activation behavior, then set activationTarget to parent.
</li>
					<li>
%~event の`経路$に
組( %親, ~NULL, %関係target )
を付加する
◎
Append (parent, null, relatedTarget) to event’s path.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%親 ~EQ %関係target
］
⇒
%親 ~SET ~NULL
◎
Otherwise, if parent and relatedTarget are identical, then set parent to null.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise,＼
</p>
				<ol>
					<li>
%target ~SET %親
◎
set target to parent and then:
</li>
					<li>
~IF［
`作動化~eventか？^V ~EQ ~T
］~AND［
%作動化~target ~EQ ~NULL
］~AND［
%target は`作動化の挙動$を有する
］
⇒
%作動化~target ~SET %target 
◎
If isActivationEvent is true, activationTarget is null, and target has activation behavior, then set activationTarget to target.
</li>
					<li>
%~event の`経路$に
組( %親, %target, %関係target )
を付加する
◎
Append (parent, target, relatedTarget) to event’s path.
</li>
				</ol>
			</li>
			<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
%親 ~SET %親 の`親~targetを取得する$( %~event )
◎
If parent is non-null, then set parent to the result of invoking parent’s get the parent with event. 
</li>
		</ol>

<p class="trans-note">【
%~event の`経路$はこの段で確定され、以降の手続きで~event~listenerにより~DOMが改変されても，影響されない。
】</p>

	</li>
	<li>
%~event の $eventPhase 属性 ~SET $CAPTURING_PHASE
◎
Set event’s eventPhase attribute to CAPTURING_PHASE.
</li>
	<li>
~IF［
%作動化~target ~NEQ ~NULL
］~AND［
%作動化~target は `旧来の作動化~前の挙動$を備えている
］
⇒
その挙動を走らす
◎
If activationTarget is non-null and activationTarget has legacy-pre-activation behavior, then run activationTarget’s legacy-pre-activation behavior.
</li>
	<li>
<p>
%~event の`経路$内の~EACH ( %組 ) に対し，逆順に：
◎
For each tuple in event’s path, in reverse order:
</p>
		<ol>
			<li id="cp-last-non-null-target">
%~event の $target 属性 ~SET %~event の`経路$内の［
%組 または %組 に先行する組
］のうち，［
`target$evP ~NEQ ~NULL
］なるもののうち，最後の組の `target$evP
◎
Set event’s target attribute to the target of the last tuple in event’s path, that is either tuple or preceding tuple, whose target is non-null.
</li>
			<li id="cp-set-relatedTarget">
%~event の`関係target$ ~SET %組 の `関係target$evP
◎
Set event’s relatedTarget to tuple’s relatedTarget.
</li>
			<li id="cp-retargeting-steps">
%~event を`再targetする手続き$を走らす
◎
Run the retargeting steps with event.
</li>
			<li>
~IF［
%組 の `target$evP ~EQ ~NULL
］
⇒
`~listenerを呼出す$( %組 の `item$evP, %~event )
◎
If tuple’s target is null, then invoke tuple’s item with event and legacyOutputDidListenersThrowFlag if given.
</li>
		</ol>
	</li>
	<li>
<p>
%~event の`経路$内の~EACH ( %組 ) に対し，順に：
◎
For each tuple in event’s path, in order:
</p>
		<ol>
			<!--cp-last-non-null-target-->
			<!--cp-set-relatedTarget-->
			<!--cp-retargeting-steps-->
			<li>
%~event の $eventPhase 属性 ~SET ［
%組 の `target$evP ~NEQ ~NULL ならば $AT_TARGET ／
~ELSE_ $BUBBLING_PHASE
］
◎
If tuple’s target is non-null, then set event’s eventPhase attribute to AT_TARGET.
◎
Otherwise, set event’s eventPhase attribute to BUBBLING_PHASE.
</li>
			<li>
~IF［［
%~event の $eventPhase 属性 ~EQ $BUBBLING_PHASE
］~AND［
%~event の $bubbles 属性 ~EQ ~T
］］~OR［
%~event の $eventPhase 属性 ~EQ $AT_TARGET
］
⇒
`~listenerを呼出す$( %組 の `item$evP, %~event )
◎
If either event’s eventPhase attribute is BUBBLING_PHASE and event’s bubbles attribute is true or event’s eventPhase attribute is AT_TARGET, then invoke tuple’s item with event and legacyOutputDidListenersThrowFlag if given.
</li>
		</ol>
	</li>
	<li>
%~event の
( `配送-$f, `伝播停止$f, `伝播即停止$f ) ~SET ( ~OFF, ~OFF, ~OFF )
◎
Unset event’s dispatch flag, stop propagation flag, and stop immediate propagation flag.
</li>
	<li>
%~event の $eventPhase 属性 ~SET $NONE
◎
Set event’s eventPhase attribute to NONE.
</li>
	<li>
%~event の $currentTarget 属性 ~SET ~NULL
◎
Set event’s currentTarget attribute to null.
</li>
	<li>
%~event の`経路$ ~SET 空~list
◎
Set event’s path to the empty list.
</li>
	<li>
<p>
~IF［
%作動化~target ~NEQ ~NULL
］：
◎
If activationTarget is non-null, then:
</p>
		<ol>
			<li>
~IF［
%~event の`被取消$f ~EQ ~OFF
］
⇒
%~event を渡して， %作動化~target の`作動化の挙動$を走らす
◎
If event’s canceled flag is unset, then run activationTarget’s activation behavior with event.
</li>
			<li>
~ELIF［
%作動化~target は `旧来の作動化~取消~時の挙動$を備えている
］
⇒
その挙動を走らす
◎
Otherwise, if activationTarget has legacy-canceled-activation behavior, then run activationTarget’s legacy-canceled-activation behavior.
</li>
		</ol>
	</li>
	<li>
~RET %~event の`被取消$f に応じて［
~ON ならば ~T ／
~OFF ならば ~F
］
◎
Return false if event’s canceled flag is set, and true otherwise.
</li>
</ol>


<p class="algo-head">
`~listenerを呼出す@
ときは、所与の
( %~obj, `~event$ %~event )
に対し，次を走らす：
◎
To invoke an object with event and an optional legacyOutputDidListenersThrowFlag, run these steps:
</p>


<ol>
	<li>
~IF［
%~event の`伝播停止$f ~EQ ~OFF
］
⇒
~RET
◎
If event’s stop propagation flag is set, then return.
</li>
	<li>
%~listener~list ~LET 新たな`~list$
◎
Let listeners be a new list.
</li>
	<li>
<p>
%~obj の`~listener~list$内の~EACH ( `~event~listener$ %~listener ) に対し
⇒
%~listener への~pointerを %~listener~list に`付加-$listする
◎
For each event listener associated with object, append a pointer to the event listener to listeners.
</p>

<p class="note">注記：
これは、この時点以降に追加された~event~listenerは，走らせないようにする。
除去については、 `removed$evL ~fieldに因り，依然として効果を及ぼすことに注意。
◎
This avoids event listeners added after this point from being run. Note that removal still has an effect due to the removed field.
</p>
	</li>
	<li>
%~event の $currentTarget 属性 ~SET %~obj に初期化する
◎
Initialize event’s currentTarget attribute to object.
</li>
	<li>
%見出された ~LET `~listenerを内部的に呼出す$( %~obj, %~event, %~listener~list )
◎
Let found be the result of running inner invoke object with event, listeners, and legacyOutputDidListenersThrowFlag if given.
</li>
	<li>
<p>
~IF［
%見出された ~EQ ~F
］~AND［
%~event の $isTrusted 属性 ~EQ ~T
］~AND［
%~event の $type 属性~値は［
下の表のいずれかの行の 1 列目の文字列
］に `~ASCII大小無視$で合致する
］…：
◎
If found is false and event’s isTrusted attribute is true, then:
◎
Let originalEventType be event’s type attribute value.
◎
If event’s type attribute value is a match for any of the strings in the first column in the following table, set event’s type attribute value to the string in the second column on the same row as the matching string, and return otherwise.
</p>

<table>
<thead><tr><th>~event型◎Event type
<th>旧来の~event型◎Legacy event type
</thead>

<tbody><tr><td>`animationend^l
<td>`webkitAnimationEnd^l 

<tr><td>`animationiteration^l
<td>`webkitAnimationIteration^l 

<tr><td>`animationstart^l
<td>`webkitAnimationStart^l 

<tr><td>`transitionend^l
<td>`webkitTransitionEnd^l 
</tbody></table>

<p>
…ならば：
</p>

		<ol>
			<li>
%元~event型 ~LET %~event の $type 属性~値
◎
↑</li>
			<li>
%~event の $type 属性~値 ~SET 同じ行の 2 列目の文字列
◎
↑</li>
			<li>
`~listenerを内部的に呼出す$( %~obj, %~event, %~listener~list )
◎
Inner invoke object with event, listeners, and legacyOutputDidListenersThrowFlag if given.
</li>
			<li>
%~event の $type 属性~値 ~SET %元~event型
◎
Set event’s type attribute value to originalEventType.
</li>
		</ol>
	</li>
</ol>

<p class="algo-head">
`~listenerを内部的に呼出す@
ときは、所与の
( %~obj, %~event, %~listener~list )
に対し，次を走らす：
◎
To inner invoke an object with event, listeners, and an optional legacyOutputDidListenersThrowFlag, run these steps:
</p>

<ol>
	<li>
%見出された ~LET ~F
◎
Let found be false.
</li>
	<li>
<p>
%~listener~list 内の~EACH ( `~event~listener$ %~listener ) に対し：
◎
For each listener in listeners, whose removed is false:
</p>
		<ol>
			<li>
~IF［
%~listener の `removed$evL ~EQ ~T
］
⇒
~CONTINUE
◎
↑</li>
			<li>
~IF［
%~listener の `type$evL ~NEQ %~event の $type 属性~値
］
⇒
~CONTINUE
◎
If event’s type attribute value is not listener’s type, then continue.
</li>
			<li>
%見出された ~SET ~T
◎
Set found to true.
</li>
			<li>
~IF［
%~listener の `capture$evL ~EQ ~F
］~AND［
%~event の $eventPhase 属性~値 ~EQ $CAPTURING_PHASE
］
⇒
~CONTINUE
◎
If event’s eventPhase attribute value is CAPTURING_PHASE and listener’s capture is false, then continue.
</li>
			<li>
~IF［
%~listener の `capture$evL ~EQ ~T
］~AND［
%~event の $eventPhase 属性~値 ~EQ $BUBBLING_PHASE
］
⇒
~CONTINUE
◎
If event’s eventPhase attribute value is BUBBLING_PHASE and listener’s capture is true, then continue.
</li>
			<li>
~IF［
%~listener の `once$evL ~EQ ~T
］
⇒
%~listener を %~obj の`~listener~list$から除去する
◎
If listener’s once is true, then remove listener from object’s associated list of event listeners.
</li>
			<li>
~IF［
%~listener の `passive$evL ~EQ ~T
］
⇒
%~event の`受動~listener内$f ~SET ~ON
◎
If listener’s passive is true, then set event’s in passive listener flag.
</li>
			<li>
<div class="p">
<p>
次を与える下で，`利用者~objの演算を~call$する：
</p>

<ul ><li>%~listener の `callback$evL
</li><li>`handleEvent^l
</li><li>引数~list： ( %~event )
</li><li>`~callback this 値$： %~event の$currentTarget 属性~値
</li></ul>

<p>
~callした結果，例外が投出されたときは、~catchして：
</p>
◎
Call a user object’s operation with listener’s callback, "handleEvent", a list of arguments consisting of event, and event’s currentTarget attribute value as the callback this value. If this throws an exception, then:
</div>

				<ol>
					<li>
`その例外を報告する$
◎
Report the exception.
</li>
					<li>
~IF［
この手続きを呼出した`配送-$手続きにて
`旧来（~listenerは投出したか？）~flag$V
は与えられている
］
⇒
`旧来（~listenerは投出したか？）~flag$V ~SET ~ON
◎
Set legacyOutputDidListenersThrowFlag if given. 
</li>
				</ol>
<p class="note">注記：
この~flagは、 Indexed Database API `INDEXEDDB$r のみに利用される。
◎
The legacyOutputDidListenersThrowFlag is only used by Indexed Database API. [INDEXEDDB]
</p>
			</li>
			<li>
%~event の`受動~listener内$f ~SET ~OFF
◎
Unset event’s in passive listener flag.
</li>
			<li>
~IF［
%~event の`伝播即停止$f ~EQ ~ON
］
⇒
~RET %見出された
◎
If event’s stop immediate propagation flag is set, then return found.
</li>
		</ol>
	</li>
	<li>
~RET %見出された
◎
Return found.
</li>
</ol>


		</section>
		<section id="firing-events">
<h3 title="Firing events">2.9. ~eventの発火-法</h3>

<div class="p">
<p class="algo-head">
%~target に向けて，名前 %e の
~eventを
`発火-@
するときは、以下の手続きを走らす
— この手続きには、次の~~入力も与えられ得る：
</p>

<ul ><li>%~event構築子 （省略時は $@Event のそれ）
</li><li>%記述
— ~eventの各種~IDL属性を どう初期化するか，についての記述 （省略時は何もしない）
</li><li>%旧来~上書target~flag（省略時は ~OFF ）
</li></ul>

◎
To fire an event named e at target, optionally using an eventConstructor, with a description of how IDL attributes are to be initialized, and a legacy target override flag, run these steps:
◎
If eventConstructor is not given, then let eventConstructor be Event.
</div>

<ol>
	<li>
%~event ~LET
`~eventを作成する$( %~event構築子, %~target に`関連する~Realm$ )
◎
Let event be the result of creating an event given eventConstructor, in the relevant Realm of target.
</li>
	<li>
%~event の $type 属性 ~SET %e に初期化する
◎
Initialize event’s type attribute to e.
</li>
	<li>
<p>
%~event の各種~IDL属性を %記述 に従って初期化する
◎
Initialize any other IDL attributes of event as described in the invocation of this algorithm.
</p>

<p class="note">注記：
ここでは［
$isTrusted 属性 ~SET ~F
］にすることも許容される。
◎
This also allows for the isTrusted attribute to be set to false.
</p>
	</li>
	<li>
~RET
%旧来~上書target~flag を与える下で，
%~event を%~target に向けて`配送-$した結果
◎
Return the result of dispatching event at target, with legacy target override flag set if set.
</li>
</ol>

<p class="note">注記：
~DOMの文脈における~eventの “`発火-$” とは、`~event$を［
<a href="#concept-event-create">作成-</a>して, 初期化して, `配送-$する
］ことの略語であり，この処理過程を記述し易くするものである。
◎
Fire in the context of DOM is short for creating, initializing, and dispatching an event. Fire an event makes that process easier to write down.
</p>

<div class="example" id="firing-events-example">

<p>
`~event$の［
$bubbles や $cancelable
］属性も初期化する記述も必要な場合は、次のように記述することもできる
⇒
“%~target に向けて，名前 ^submit の~eventを， ^cancelable 属性を~T に初期化した上で `発火-$する”
◎
If the event needs its bubbles or cancelable attribute initialized, one could write "fire an event named submit at target with its cancelable attribute initialized to true".
</p>

<p>
あるいは，~custom構築子も必要なときは、次のように記述する等々
⇒
“%~target に向けて，名前 `click^et の, $MouseEvent を利用する~eventを［
`detail$m 属性は 1 に初期化-
］した上で `発火-$する”
◎
Or, when a custom constructor is needed, "fire an event named click at target using MouseEvent with its detail attribute initialized to 1".
</p>

<p class="trans-note">【
このように付帯する記述が長くなる場合、和訳では，その部分を下位ブロックに分けて記す場合が多い。
】</p>

<p>
ときには、返値が重要になることもある：
◎
Occasionally the return value is important:
</p>

<ol>
	<li>
%doAction ~LET %~target に向けて 名前 `like^et の~eventを`発火-$した結果
◎
Let doAction be the result of firing an event named like at target.
	</li>
	<li>
~IF［
%doAction ~EQ ~T
］
⇒
…
◎
If doAction is true, then …
	</li>
</ol>
</div>


		</section>
		<section id="action-versus-occurance">
<h3 title="Action versus occurrence">2.10. 動作 vs. 発生</h3>

<p>
`~event$は、動作（ action ）ではなく，発生（ occurrence ）をしるす（ signify する）ものである。
言葉を代えれば、~algoからの通知を表現し，その~algoの進路に（例えば $preventDefault() を呼出すことを通して）働きかけるために利用できるものである。
`~event$は、何らかの~algoを走らすような［
動作／動作を~~起動するもの
］として利用されては~MUST_NOT。
そのような用途のためのものではない。
◎
An event signifies an occurrence, not an action. Phrased differently, it represents a notification from an algorithm and can be used to influence the future course of that algorithm (e.g., through invoking preventDefault()). Events must not be used as actions or initiators that cause some algorithm to start running. That is not what they are for.
</p>

<p class="note">注記：
ここで特に~~強調している~~理由は、以前の~DOMでは，`~event$に “既定の動作” の概念が結付けられていて，人を誤った考えに~~導いていたからである。
`~event$は、動作を表現したり, 引き起こすものではなく，進行中のものに働きかけるために限って利用できるものである。
◎
This is called out here specifically because previous iterations of the DOM had a concept of "default actions" associated with events that gave folks all the wrong ideas. Events do not represent or cause actions, they can only be used to influence an ongoing one.
</p>

<p class="trans-note">【
<!--  仕様~策定者~向けの記述？ -->
<a href="~SPECBUGS?id=12230">参考</a>
】</p>

		</section>
	</section>
	<section id="aborting-ongoing-activities">
<h2 title="Aborting ongoing activities">3. 進行中の活動の中止-法</h2>

<!-- ^@AbortController -->
<p>
~promiseには，中止するための組込みの仕組みがないが、それを利用している多くの~APIは，中止-の意味論を要求している。
$AbortController は、その要件を~supportするために~~意図されている。
それが提供する $abort() ~methは、 $AbortController に対応している $AbortSignal ~objの状態を切り替える。
中止を~supportしたいと望む~APIは、この~objを受容して, その状態を利用することにより，どう続行するか決定できる。
◎
Though promises do not have a built-in aborting mechanism, many APIs using them require abort semantics. AbortController is meant to support these requirements by providing an abort() method that toggles the state of a corresponding AbortSignal object. The API which wishes to support aborting can accept an AbortSignal object, and use its state to determine how to proceed.
</p>

<p>
$AbortController に依拠する~APIは、新たな `AbortError$E 例外で未決着の~promiseを却下して， $abort() に応答することが奨励される。
◎
APIs that rely upon AbortController are encouraged to respond to abort() by rejecting any unsettled promise with a new DOMException with error name "AbortError".
</p>

<div class="example" id="aborting-ongoing-activities-example">

<p>
ある “何かすごいこと” を行う~meth 
`doAmazingness({ ... })^c があるとする。
この~methは、 $AbortSignal ~objを受容して，次のように中止を~supportできる：
◎
A hypothetical doAmazingness({ ... }) method could accept an AbortSignal object in order to support aborting as follows:
</p>

<pre class="js-code">
const %controller = new AbortController();
const %signal = %controller.signal;

startSpinner();

doAmazingness({ ..., %signal })
  .then(%result =&gt; ...)
  .catch(%err =&gt; {
    if (%err.name == 'AbortError') return;
    showUserErrorMessage();
  })
  .then(() =&gt; stopSpinner());

// …

%controller.abort();
</pre>

<p>
^doAmazingness は、次のように実装することもできる：
◎
doAmazingness could be implemented as follows:
</p>

<pre class="js-code">
function doAmazingness({%signal}) {
  return new Promise((%resolve, %reject) =&gt; {
  	/* <span class="comment">
“すごいこと” を行い始め、終わったら %resolve(%result) を~callする。
また、 %signal も注視する。
◎
Begin doing amazingness, and call resolve(result) when done.
But also, watch for signals:
</span> */
    %signal.addEventListener('abort', () =&gt; {
      /* <span class="comment">
“すごいこと” を行うのを停止してから：
◎
Stop doing amazingness, and:
</span> */
      %reject(new DOMException('Aborted', 'AbortError'));
    });
  });
}
</pre>

<p>
より精細な制御を要する~APIは、必要に応じて
$AbortController, $AbortSignal
両~objを拡張することもできる。
◎
APIs that require more granular control could extend both AbortController and AbortSignal objects according to their needs.
</p>

</div>


		<section id="interface-abortcontroller">
<h3 title="Interface AbortController">3.1. ~ifc ^@AbortController</h3>

⇒！
$Constructor,
 `Exposed$=(Window,Worker)]
interface @AbortController {
  [`SameObject$] readonly attribute $AbortSignal $signal;

  void $abort();
};
◎

<dl class="domintro">
	<dt>%controller  = new $AbortController()</dt>
	<dd>
新たな %controller を，その $signal を［
新たな $AbortSignal ~obj
］に設定した上で返す。
◎
Returns a new controller whose signal is set to a newly created AbortSignal object.
</dd>

	<dt>%controller . $signal</dt>
	<dd>
この~objに結付けられている $AbortSignal ~objを返す。
◎
Returns the AbortSignal object associated with this object.
</dd>
	<dt>%controller . $abort()</dt>
	<dd>
この~methを呼出すと、この~objの $AbortSignal の`被中止~flag$aBを設定した上で、結付けられている活動が中止されることになるよう，~obたちにも通達することになる。
◎
Invoking this method will set this object’s AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.
</dd>
</dl>

<p>
各 $AbortController ~objには、
`通達@aB
（ $AbortSignal ~obj）が結付けられる。
◎
An AbortController object has an associated signal (an AbortSignal object).
</p>

<dl class="idl-def">
	<dt>@AbortController()</dt>
	<dd>
この構築子の被呼出時には、次のようにされた，新たな $AbortController ~objを返さ~MUST
⇒
`通達$aB ~SET 新たな $AbortSignal ~obj
◎
The AbortController() constructor, when invoked, must run these steps:
• Let signal be a new AbortSignal object.
• Let controller be a new AbortController object whose signal is signal.
• Return controller.
</dd>

	<dt>@signal</dt>
	<dd>
取得子は、此れの`通達$aBを返さ~MUST。
◎
The signal attribute’s getter must return context object’s signal.
</dd>

	<dt>@abort()</dt>
	<dd>
被呼出時には、此れの`通達$aBに`中止-を通達-$aBし~MUST
◎
The abort() method, when invoked, must signal abort on context object’s signal.
</dd>
</dl>


		</section>
		<section id="interface-AbortSignal">
<h3 title="Interface AbortSignal">3.2. ~ifc ^@AbortSignal</h3>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface @AbortSignal : $EventTarget {
  readonly attribute ~B $aborted;

  attribute $EventHandler @onabort;
};
</pre>

<dl class="domintro">
	<dt>%signal . $aborted</dt>
	<dd>
この $AbortSignal の $AbortController が，中止するよう通達されて［
いれば ~T ／
いなければ ~F
］を返す。
◎
Returns true if this AbortSignal's AbortController has signaled to abort, and false otherwise.
</dd>
</dl>

<p>
各 $AbortSignal ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`被中止~flag@aB</dt>
	<dd>
他が指定されない限り， ~OFF とする。
◎
An AbortSignal object has an associated aborted flag. It is unset unless specified otherwise.
</dd>

	<dt>`中止する~algoたち@aB</dt>
	<dd>
何個かの~algoからなる`有順序~集合$。
他が指定されない限り，空とする。
これらの~algoは、［
`被中止~flag$aB ~SET ~ON
］にされたとき，実行されることになる。
◎
An AbortSignal object has associated abort algorithms, which is a set of algorithms which are to be executed when its aborted flag is set. Unless specified otherwise, its value is the empty set.
</dd>
</dl>

<p class="algo-head">
~algo %~algo を
$AbortSignal ~obj %通達 に
`追加-@aB
するときは、次を走らす：
◎
To add an algorithm algorithm to an AbortSignal object signal, run these steps:
</p>

<ol>
	<li>
~IF［
%通達 の`被中止~flag$aB ~EQ ~ON
］
⇒
~RET
◎
If signal’s aborted flag is set, then return.
</li>
	<li>
%通達 の`中止する~algoたち$aBに %~algo を`付加-$setする
◎
Append algorithm to signal’s abort algorithms.
</li>
</ol>

<p>
$AbortSignal ~obj %通達 から~algo %A を
`除去-@aB
するときは
⇒
%通達 の`中止する~algoたち$aBから %A を`除去-$listする
◎
To remove an algorithm algorithm from an AbortSignal signal, remove algorithm from signal’s abort algorithms.
</p>

<p class="note">注記：
`中止する~algoたち$aBは、
$abort() に対し適度な仕方で反応するような，複雑な要件を伴う~APIを可能化する。
例えば，所与の~APIの`被中止~flag$aBは、~swなどの別~thread環境へ伝播される必要があるかもしれない。
◎
The abort algorithms enable APIs with complex requirements to react in a reasonable way to abort(). For example, a given API’s aborted flag might need to be propagated to a cross-thread environment, such as a service worker.
</p>


<dl class="idl-def">
	<dt>@aborted</dt>
	<dd>
取得子は、此れの`被中止~flag$aBに応じて［
~ON ならば ~T ／
~OFF ならば ~F
］を返さ~MUST。
◎
The aborted attribute’s getter must return true if context object’s aborted flag is set, and false otherwise.
</dd>
</dl>

<p class="note">注記：
$AbortSignal ~objに対する変化は，対応している $AbortController ~objの望みを表現するが、 $AbortSignal ~objを観測している~APIは，それを無視することも選べる
— 具体例として、演算がすでに完了していた場合など。
◎
Changes to an AbortSignal object represent the wishes of the corresponding AbortController object, but an API observing the AbortSignal object can chose to ignore them. For instance, if the operation has already completed.
</p>

<p class="algo-head">
`中止-を通達-@aB
するときは、所与の
( $AbortSignal ~obj %通達 )
に対し，次を走らす：
◎
To signal abort, given a AbortSignal object signal, run these steps:
</p>

<ol>
	<li>
~IF［
%通達 の`被中止~flag$aB ~EQ ~ON
］
⇒
~RET
◎
If signal’s aborted flag is set, then return.
</li>
	<li>
%通達 の`被中止~flag$aB ~SET ~ON
◎
Set signal’s aborted flag.
</li>
	<li>
%通達 の`中止する~algoたち$aB内の ~EACH( %~algo ) に対し
⇒
%~algo を走らす
◎
For each algorithm in signal’s abort algorithms: run algorithm.
</li>
	<li>
%通達 の`中止する~algoたち$aBを`空にする$list
◎
Empty signal’s abort algorithms.
</li>
	<li>
%通達 に向けて，名前 `abort^et の~eventを`発火-$する
◎
Fire an event named abort at signal.
</li>
</ol>


		</section>
		<section id="abortcontroller-api-integration">
<h3 title="Using AbortController and AbortSignal objects in APIs">3.3. ~APIにおける ^AbortController, ^AbortSignal ~objの用法</h3>

<p>
中止できる演算を表現する~promiseを利用している~web~platform~APIは、次を固守し~MUST：
◎
Any web platform API using promises to represent operations that can be aborted must adhere to the following:
</p>

<ul>
	<li>
^signal 辞書~memberを通して， $AbortSignal ~objを受容すること。
◎
Accept AbortSignal objects through a signal dictionary member.
</li>
	<li>
演算が中止されたときは、 `AbortError$E 例外で~promiseを却下することにより，それを~~伝えること。
◎
Convey that the operation got aborted by rejecting the promise with an "AbortError" DOMException.
</li>
	<li>
<p>
$AbortSignal の`被中止~flag$aBが：
</p>
		<ul>
			<li>
すでに ~ON の場合：
即時に却下すること。
◎
Reject immediately if the AbortSignal's aborted flag is already set, otherwise:
</li>
			<li>
他の場合：
$AbortSignal ~objの変化を観測するときは、`中止する~algoたち$aBによる仕組みを利用すること。
他の~obと衝突し得ない方式でそうすること。
◎
Use the abort algorithms mechanism to observe changes to the AbortSignal object and do so in a manner that does not lead to clashes with other observers.
</li>
		</ul>
	</li>
</ul>

<div class="example" id="aborting-ongoing-activities-spec-example">

<p>
~promiseを返す ある~meth ^doAmazingness(options) 用の手続きは、次のように記すこともできる：
◎
The steps for a promise-returning method doAmazingness(options) could be as follows:
</p>

<ol>
	<li>
%すごいこと ~LET ^doAmazingness が行う何か
◎
↓</li>
	<li>
%p ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li>
<p>
~IF［
%options に ^signal ~memberは在する
］：
◎
If options’ signal member is present, then:
</p>
		<ol>
			<li>
<p>
~IF［
%options の ^signal の`被中止~flag$aB ~EQ ~ON
］：
</p>
				<ol>
					<li>
`AbortError$E 例外で %p を`却下する$
</li>
					<li>
~RET %p
</li>
				</ol>
◎
If options’ signal’s aborted flag is set, then reject p with an "AbortError" DOMException and return p.
</li>
			<li>
<p>
次で与えられる中止-手続きを
%options の ^signal に`追加-$aBする：
◎
Add the following abort steps to options’ signal:
</p>
				<ol>
					<li>
%すごいこと を行うのを停止する
◎
Stop doing amazing things.
</li>
					<li>
`AbortError$E 例外で %p を`却下する$
◎
Reject p with an "AbortError" DOMException.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
次は、`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
%すごい結果 ~LET %すごいこと を行った結果
◎
Let amazingResult be the result of doing some amazing things.
</li>
			<li>
%すごい結果 で %p を`解決する$
◎
Resolve p with amazingResult.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>

</div>

<p>
~promiseを利用していない~APIであっても、可能な限り，上述を固守するべきである。
◎
APIs not using promises should still adhere to the above as much as possible.
</p>

		</section>
	</section>
	<section id="nodes">
<h2 title="Nodes">4. ~node</h2>

		<section id="introduction-to-the-dom">
<h3 title="Introduction to “The DOM”">4.1. ~DOM序論</h3>


<p>
~DOM（ “The DOM（ Document Object Model ）” ）は元々，文書（特に，~HTML文書や~XML文書）に~accessして操作するための~APIを意味するものであったが、この仕様における語  “文書” は、短い静的な文書から 多彩な~multimediaを伴う長い小論や報告書，更には本格的な対話的~appまでに渡る、任意の~markupに基づく資源を指すものとして用いられる。
◎
In its original sense, "The DOM" is an API for accessing and manipulating documents (in particular, HTML and XML documents). In this specification, the term "document" is used for any markup-based resource, ranging from short static documents to long essays or reports with rich multimedia, as well as to fully-fledged interactive applications.
</p>
<p>
そのような各~文書は、`~node木$として表現される。
これらの`~node$のうち一部は他の`~node$を`子$に持ち，他のものは葉（末端）~nodeになる。
◎
Each such document is represented as a node tree. Some of the nodes in a tree can have children, while others are always leaves.
</p>

<div class="example">
<p>
次の~HTML文書を例に~~説明する：
◎
To illustrate, consider this HTML document:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;html class=e&gt;
 &lt;head&gt;&lt;title&gt;Aliens?&lt;/title&gt;&lt;/head&gt;
 &lt;body&gt;Why yes.&lt;/body&gt;
&lt;/html&gt;</pre>

<p>
これは次のように表現される：
◎
It is represented as follows:
</p>

<ol class="domTree"><li>`文書$
	<ol><li>`~doctype$： `DOCTYPE html^c
	</li><li>`要素$： `html^e <span>`class^c=`e^l</span>
		<ol><li>`要素$： `head^e
			<ol><li>`要素$： `title^e
				<ol><li>$Text： <samp>Aliens?</samp>
				</li></ol>
			</li></ol>
		</li><li>$Text： <samp>⏎␣</samp>
		</li><li>`要素$： `body^e
			<ol><li>$Text: <samp>Why yes.⏎</samp>
			</li></ol>
		</li></ol>
	</li></ol>
</li></ol>

</div>

<p>
`~HTML構文解析器$の~~仕組みから，すべての`~ASCII空白$が $Text `~node$にされてはいないが、一般~概念は明らかである。
~~入力の~markupから，`~node$たちが成す`木$が出来上がる。
<!-- You /can/ explain that! harharhar --> 
◎
Note that, due to the magic that is HTML parsing, not all ASCII whitespace were turned into Text nodes, but the general concept is clear. Markup goes in, a tree of nodes comes out.
</p>

<p class="note">注記：
さらに探求してみたければ、最高によくできている
<a href="http://software.hixie.ch/utilities/js/live-dom-viewer/">Live DOM Viewer</a>
を利用するといい。
◎
The most excellent Live DOM Viewer can be used to explore this matter in more detail.
</p>

		</section>
		<section id="node-trees">
<h3 title="Node tree">4.2. ~node木</h3>

<div class="p">
<p>
次に挙げる~ifcを実装する~objが、`木$に`関与-$する：
</p>

<ul ><li>$Document
</li><li>$DocumentType
</li><li>$DocumentFragment
</li><li>$Element
</li><li>$Text
</li><li>$ProcessingInstruction
</li><li>$Comment
</li></ul>

<p>
これらは総称して、単に
`~node@
と呼ばれる。
また、これらが成す木は，
`~node木@
と称される。
</p>

◎
Document, DocumentType, DocumentFragment, Element, Text, ProcessingInstruction, and Comment objects (simply called nodes) participate in a tree, simply named the node tree.
</div>


<p id="_tree-constraints_">
`~node木$には、`~node$の型とそれに許容される`子$との関係性で表される，次の拘束が課される：
◎
A node tree is constrained as follows, expressed as a relationship between the type of node and its allowed children:
</p>

<dl>
	<dt>$Document</dt>
	<dd>

<p>
`木~順序$において，次からなる：
◎
In tree order:
</p>
		<ol>
			<li id="cp-comments-or-PI">
それぞれが $ProcessingInstruction または $Comment である， 0 個以上の~node
◎
Zero or more nodes each of which is ProcessingInstruction or Comment.
</li>
			<li>
0 個または 1 個の $DocumentType ~node
◎
Optionally one DocumentType node.
</li>
			<!--cp-comments-or-PI-->
			<li>
0 個または 1 個の $Element ~node
◎
Optionally one Element node.
</li>
			<!--cp-comments-or-PI-->
		</ol>
	</dd>

	<dt>$DocumentFragment</dt>
	<dt>$Element</dt>
	<dd>
それぞれが $Element, $ProcessingInstruction, $Comment, $Text のいずれかである， 0 個以上の~nodeからなる
◎
Zero or more nodes each of which is Element, Text, ProcessingInstruction, or Comment.
</dd>

	<dt>$DocumentType</dt>
	<dt>$Text</dt>
	<dt>$ProcessingInstruction</dt>
	<dt>$Comment</dt>
	<dd>
子を持たない
◎
None.
</dd>
</dl>

<p class="algo-head">
`~node$ %node の
`長さ@
とは、 %node の型に応じて，次で与えられる整数である：
◎
To determine the length of a node node, switch on node: 
</p>

<dl class="switch">

	<dt>$DocumentType</dt>
	<dd>
0
◎
Zero.
</dd>

	<dt>`文字~data~node$◎Text, ProcessingInstruction, Comment</dt>
	<dd>
その`~data$内の`符号単位$の個数
◎
The number of code units in its data.
</dd>

<!-- 他の~node -->
	<dt>$Document</dt>
	<dt>$DocumentFragment</dt>
	<dt>$Element</dt>
	<dd>
その`子$の個数
◎
Its number of children.
</dd>

</dl>

<p>
`~node$が
`空@
であるとは、［
その`長さ$ ~EQ 0
］を意味する。
◎
A node is considered empty if its length is zero.
</p>


			<section id="document-trees">
<h4 title="Document tree">4.2.1.文書~木</h4>

<p>
`根$が`文書$であるような`~node木$を
`文書~木@
という。
◎
A document tree is a node tree whose root is a document.
</p>

<p>
`文書$ %D の
`文書~要素@
とは、［
%D を`親$とするような`要素$があれば それ ／
~ELSE_ ~NULL
］である。
◎
The document element of a document is the element whose parent is that document, if it exists, and null otherwise.
</p>

<p class="note">注記：
`~node木$の拘束から、そのような`要素$は唯一つに決まる。
<span class="trans-note">【
例えば`~HTML文書$ならば `html^e 要素。
】</span>
◎
Per the node tree constraints, there can be only one such element.
</p>

<p>
`要素$は、その`根$が`文書$であるとき，
`文書~木~内@
にあるとされる。
◎
An element is in a document tree if its root is a document.
</p>

<p>
`文書~木~内$にある`要素$は、
`文書~内@
にあるともいう。
<span class="note">注記：
用語 “`文書~内$” は、もはや利用されないものと想定されている。
この用語は、それを利用している標準が，まだ`~shadow木$を織り込むよう更新されていないことを指示する。
</span>
◎
An element is in a document if it is in a document tree. The term in a document is no longer supposed to be used. It indicates that the standard using it has not been updated to account for shadow trees.
</p>


			</section>
			<section id="shadow-trees">
<h4 title="Shadow tree">4.2.2. ~shadow木</h4>

<p>
`根$が`~shadow根$であるような`~node木$は
`~shadow木@
という。
◎
A shadow tree is a node tree whose root is a shadow root.
</p>

<p>
`~shadow根$は常に，その`~host$を通して別の`~node木$に添付けられる。
したがって，`~shadow木$が~~孤立することは決してない。
`~shadow根$の`~host$が関与している`~node木$は、
`~light木@
と呼ばれることもある。
◎
A shadow root is always attached to another node tree through its host. A shadow tree is therefore never alone. The node tree of a shadow root’s host is sometimes referred to as the light tree.
</p>

<p class="note">注記：
`~shadow木$に対応する`~light木$は、それ自身`~shadow木$になり得る。
◎
A shadow tree’s corresponding light tree can be a shadow tree itself.
</p>

<p class="trans-note">【
“~shadow” と違って， “~light” の定義は相対的であり、ある~node木~単独で “~lightである” とは言えない。
】【
“shadow／light” ＝ “日陰／日なた”, “暗／明”
】</p>

<p id="in-a-shadow-including-document">
`要素$は、その`~shadowも含む根$が`文書$であるとき，
`接続されて@
いるという。
◎
An element is connected if its shadow-including root is a document.
</p>


				<section id="shadow-tree-slots">
<h5 title="Slots">4.2.2.1. ~slot</h5>

<p>
各`~shadow木$は、 0 個以上の，
`~slot@
と呼ばれる`要素$を包含する。
◎
A shadow tree contains zero or more elements that are slots.
</p>

<p class="note">注記：
`~slot$は HTML の `slot$e 要素を通してのみ作成される。
◎
A slot can only be created through HTML’s slot element.
</p>

<div class="p">
<p>
各 `~slot$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~slot名@</dt>
	<dd>
文字列。
他が定められない限り，空~文字列とする。
</dd>
</dl>
◎
A slot has an associated name (a string). Unless stated otherwise it is the empty string.
</div>


<p class="algo-head">
`~slot$の`~slot名$の更新~時に利用する，`属性oを変更する手続き$は、次で与えられる：
◎
Use these attribute change steps to update a slot’s name:
</p>

<ol>
	<li>
~IF［
%要素 は `~slot$でない
］~OR［
%局所~名 ~NEQ `name^l
］~OR［
%~ns ~NEQ ~NULL
］
⇒
~RET
◎
If element is a slot, localName is name, and namespace is null, then:
</li>
	<li id="cp-ret-if-nochange">
~IF［
( %値, %旧-値 ) は、次のいずれかを満たす
］…：

<ul ><li>%値 ~EQ %旧-値
</li><li>［
%値 ~IN { ~NULL, 空~文字列 }
］~AND［
%旧-値 ~IN { ~NULL, 空~文字列 }
］
</li></ul>

…ならば
⇒
~RET
◎
If value is oldValue, then return.
◎
If value is null and oldValue is the empty string, then return.
◎
If value is the empty string and oldValue is null, then return.
</li>
	<li>
%要素 の`~slot名$ ~SET［
%値 ~IN { ~NULL, 空~文字列 } ならば 空~文字列 ／
~ELSE_ %値
］
◎
If value is null or the empty string, then set element’s name to the empty string.
◎
Otherwise, set element’s name to value.
</li>
	<li>
`木に~slotableたちを割当する$( %要素 の`木$ )
◎
Run assign slotables for a tree with element’s tree.
</li>
</ol>


<p class="note">注記：
`~shadow木$内の，［
`~slot名$ ~EQ 空~文字列
］なる`~slot$のうち，`木~順序$で最初のものは
“既定の~slot”
と称されることもある。
◎
The first slot in a shadow tree, in tree order, whose name is the empty string, is sometimes known as the "default slot".
</p>

<div class="p">
<p>
各 `~slot$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`割当されている~nodeたち@ （ assigned nodes ）</dt>
	<dd>
`~slotable$の~list。
他が定められない限り，空とする。
</dd>
</dl>
◎
A slot has an associated assigned nodes (a list of slotables). Unless stated otherwise it is empty.
</div>

				</section>
				<section id="light-tree-slotables">
<h5 title="Slotables">4.2.2.2. ~slotable</h5>

<p>
［
$Element ／ $Text
］`~node$は、
`~slotable@
である。
◎
Element and Text nodes are slotables.
</p>

<p class="note">注記：
`~slot$も、`~slotable$になり得る。
◎
A slot can be a slotable.
</p>

<p class="trans-note">【
~slotは “はめ込み口”，
~slotableは “はめ込める物”。
】</p>

<div class="p">
<p>
各 `~slotable$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~slotable名@</dt>
	<dd>
文字列。
他が定められない限り，空~文字列とする。
</dd>
</dl>
◎
A slotable has an associated name (a string). Unless stated otherwise it is the empty string.
</div>

<p class="algo-head">
`~slotable$の`~slotable名$の更新~時に利用する，`属性oを変更する手続き$は、次で与えられる：
◎
Use these attribute change steps to update a slotable’s name:
</p>

<ol>
	<li>
~IF［
%局所~名 ~NEQ `slot^l
］~OR［
%~ns ~NEQ ~NULL
］
⇒
~RET
◎
If localName is slot and namespace is null, then:
</li>
	<!--cp-ret-if-nochange-->
	<li>
%要素 の`~slotable名$ ~SET［
%値 ~IN { ~NULL, 空~文字列 } ならば 空~文字列 ／
~ELSE_ %値
］
◎
If value is null or the empty string, then set element’s name to the empty string.
◎
Otherwise, set element’s name to value.
</li>
	<li>
~IF［
%要素 の`割当先~slot$ ~NEQ ~NULL
］
⇒
`~slotに~slotableたちを割当する$( その`~slot$ )
◎
If element is assigned, then run assign slotables for element’s assigned slot.
</li>
	<li>
`~slotableを~slotに割当する$( %要素 )
◎
Run assign a slot for element.
</li>
</ol>


<div class="p">
<p>
各 `~slotable$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`割当先~slot@ （ assigned slot ）</dt>
	<dd>
`~slot$, または ~NULL 。
他が定められない限り，~NULL とする。
</dd>
	<dd class="trans-note">【
自身がどの`~slot$に割当されているかを指示する。
】</dd>
	<dd>
<p>
`割当先~slot$が ~NULL でない`~slotable$は、
`割当先がある@
（ is assigned ）という。
</p>

<p class="trans-note">【
この訳では、この用語は利用せず，直接的に［
`割当先~slot$ ~NEQ ~NULL
］と記す。
】</p>

	</dd>

</dl>

◎
A slotable has an associated assigned slot (null or a slot). Unless stated otherwise it is null. A slotable is assigned if its assigned slot is non-null.
</div>



				</section>
				<section id="finding-slots-and-slotables">
<h5 title="Finding slots and slotables">4.2.2.3. ~slot ／ ~slotableの見出法</h5>

<p class="algo-head">
`~slotable用に~slotを見出す@
ときは、所与の
( `~slotable$ %~slotable, `~open^f （省略時は ~OFF ） )
に対し，次を走らす：
◎
To find a slot for a given slotable slotable and an optional open flag (unset unless stated otherwise), run these steps:
</p>

<ol>
	<li>
~IF［
%~slotable の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If slotable’s parent is null, then return null.
</li>
	<li>
%~shadow ~LET %~slotable の`親$の`~shadow根$elm
◎
Let shadow be slotable’s parent’s shadow root.
</li>
	<li>
~IF［
%~shadow ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If shadow is null, then return null.
</li>
	<li>
~IF［
`~open^f ~EQ ~ON
］~AND［
%~shadow の`~mode$sR ~NEQ `open^l
］
⇒
~RET ~NULL
◎
If the open flag is set and shadow’s mode is not "open", then return null.
</li>
	<li>
~RET %~shadow の`木$内の`~slot$のうち，［
その`~slot名$ ~EQ %~slotable の`~slotable名$
］なる`最初0$のもの
◎
Return the first slot in shadow’s tree whose name is slotable’s name, if any, and null otherwise.
</li>
</ol>

<p class="algo-head">
`~slot用に~slotableたちを見出す@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To find slotables for a given slot slot, run these steps:
</p>

<ol>
	<li id="cp-let-result-empty-list">
%結果 ~LET 空~list
◎
Let result be an empty list.
</li>
	<li id="cp-if-not-shadow-root">
~IF［
%~slot の`根$は`~shadow根$でない
］
⇒
~RET %結果
◎
If slot’s root is not a shadow root, then return result.
</li>
	<li>
<p>
%~slot の`根$の`~host$の~EACH ( `~slotable$である`子$ %~slotable ) に対し，`木~順序$で：
◎
Let host be slot’s root’s host.
◎
For each slotable child of host, slotable, in tree order:
</p>
		<ol>
			<li>
~IF［
`~slotable用に~slotを見出す$( %~slotable ) ~EQ %~slot
］
⇒
%~slotable を %結果 に付加する
◎
Let foundSlot be the result of finding a slot given slotable.
◎
If foundSlot is slot, then append slotable to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="algo-head">
`~slot用に平坦化された~slotableたちを見出す@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To find flattened slotables for a given slot slot, run these steps:
</p>

<ol>
	<!--cp-let-result-empty-list-->
	<!--cp-if-not-shadow-root-->
	<li>
%~slotable~list ~LET
`~slot用に~slotableたちを見出す$( %~slot )
◎
Let slotables be the result of finding slotables given slot.
</li>
	<li>
~IF［
%~slotable~list は空である
］
⇒
%~slot の~EACH ( `子$ %子 ) に対し，`木~順序$で
⇒
~IF［
%子 は`~slotable$である
］
⇒
%子 を %~slotable~list に付加する
◎
If slotables is the empty list, then append each slotable child of slot, in tree order, to slotables.
</li>
	<li>
<p>
%~slotable~list 内の~EACH ( %~node ) に対し：
◎
For each node in slotables:
</p>
		<ol>
			<li>
<p>
~IF［
%~node は`~slot$である
］~AND［
%~node の`根$は`~shadow根$である
］
⇒
［
`~slot用に平坦化された~slotableたちを見出す$( %~node )
］内の~EACH ( `~slotable$ %~slotable ) に対し，順に
⇒
%~slotable を %結果 に付加する
◎
If node is a slot whose root is a shadow root, then:
• Let temporaryResult be the result of finding flattened slotables given node.
• Append each slotable in temporaryResult, in order, to result.
</li>
			<li>
~ELSE
⇒
%~node を %結果 に付加する
◎
Otherwise, append node to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

				</section>
				<section id="assigning-slotables-and-slots">
<h5 title="Assigning slotables and slots">4.2.2.4. ~slotableたち／~slotの割当法</h5>

<p class="algo-head">
`~slotに~slotableたちを割当する@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To assign slotables for a slot slot, run these steps: 
</p>


<ol>
	<li>
%~slotable~list ~LET
`~slot用に~slotableたちを見出す$( %~slot )
◎
Let slotables be the result of finding slotables for slot.
</li>
	<li>
~IF［
%~slotable~list と %~slot に`割当されている~nodeたち$とは、一致しない
<!-- ＊
順序は関係ある？ない？
-->
］
⇒
`~slotの変化を通達する$( %~slot )
◎
If slotables and slot’s assigned nodes are not identical, then run signal a slot change for slot.
</li>
	<li>
%~slot に`割当されている~nodeたち$ ~SET %~slotable~list
◎
Set slot’s assigned nodes to slotables.
</li>
	<li>
%~slotable~list 内の~EACH ( %~slotable ) に対し
⇒
%~slotable の`割当先~slot$ ~SET %~slot
◎
For each slotable in slotables, set slotable’s assigned slot to slot.
</li>
</ol>

<p class="algo-head">
`木に~slotableたちを割当する@
ときは、所与の
( `木$ %木 )
に対し，次を走らす
⇒
%木 内の~EACH ( `~slot$ %~slot ) に対し，`木~順序$で
⇒
`~slotに~slotableたちを割当する$( %~slot )
◎
To assign slotables for a tree, given a tree tree, run assign slotables for each slot slot in tree, in tree order.
</p>

<p class="algo-head">
`~slotableを~slotに割当する@
ときは、所与の
( `~slotable$ %~slotable )
に対し、次を走らす：
◎
To assign a slot, given a slotable slotable, run these steps:
</p>

<ol>
	<li>
%~slot ~LET `~slotable用に~slotを見出す$( %~slotable )
◎
Let slot be the result of finding a slot with slotable.
</li>
	<li>
~IF［
%~slot ~NEQ ~NULL
］
⇒
`~slotに~slotableたちを割当する$( %~slot )
◎
If slot is non-null, then run assign slotables for slot.
</li>
</ol>

				</section>
				<section id="signaling-slot-change">
<h5 title="Signaling slot change">4.2.2.5. ~slot変化の通達-法</h5>
<p>
各
`互いに関係するかつ生成元も類似する閲覧文脈~群$
`HTML$r
%閲覧文脈~群
は、
`通達~slot~list@
を持つ。
それは，`~slot$たちからなる~listであり、他が定められない限り，空とする。
◎
Each unit of related similar-origin browsing contexts has a signal slot list (a list of slots). Unless stated otherwise it is empty. [HTML]
</p>

<p class="algo-head">
`~slotの変化を通達する@
ときは、所与の
( `~slot$ %~slot )
に対し，次を走らす：
◎
To signal a slot change, for a slot slot, run these steps:
</p>
<ol>
	<li>
~IF［
%~slot ~NIN %閲覧文脈~群 の`通達~slot~list$
］
⇒
%~slot を %閲覧文脈~群 の`通達~slot~list$に付加する
◎
If slot is not in unit of related similar-origin browsing contexts' signal slot list, append slot to unit of related similar-origin browsing contexts' signal slot list.
</li>
	<li>
`変異~ob 複合~極小taskを待入する$
◎
Queue a mutation observer compound microtask.
</li>
</ol>
				</section>
			</section>
			<section id="mutation-algorithms">
<h4 title="Mutation algorithms">4.2.3. 変異~algo</h4>

<!--% 挿入検証 -->
<p class="algo-head">
%node を %親 の中で %子 の前に
`挿入し得るかどうか検証する@
ときは、次を走らす：
◎
To ensure pre-insertion validity of a node into a parent before a child, run these steps:
</p>

<!-- Step 1-5 could be shared with concept-node-pre-insert, although step 3
     in pre-insert is a superset (which is fine). Step 6.1.1 could also be
     shared. -->

<ol>
	<li id="cp-throw-if-chardata">
~IF［
%親 は
$Document, $DocumentFragment, $Element `~node$のいずれでもない
］
⇒
~THROW `HierarchyRequestError$E
◎
If parent is not a Document, DocumentFragment, or Element node, throw a HierarchyRequestError.
</li>
	<li id="cp-throw-if-iAN">
~IF［
%node は %親 の`~hostも含む広義先祖$である
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.
</li>
	<li>
~IF［
%子 ~NEQ ~NULL
］~AND［
%子 の`親$ ~NEQ %親
］
⇒
~THROW `NotFoundError$E
◎
If child is not null and its parent is not parent, then throw a NotFoundError.
</li>
	<li id="cp-throw-if-not-doc">
<p>
~IF［
%node は
$DocumentFragment, $DocumentType, $Element, $Text, $ProcessingInstruction, $Comment `~node$
のいずれでもない
］
⇒
~THROW `HierarchyRequestError$E
</p>

<p class="trans-note">【
すなわち “^Document ~nodeである”（何故そのように記されない？）
】</p>

◎
If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or Comment node, throw a HierarchyRequestError.
</li>
	<li id="cp-throw-if-mismatch1">
<p>
~IF［
次のいずれかが満たされる
］
⇒
~THROW `HierarchyRequestError$E
：
</p>
		<ul>
			<li>
［
%node は $Text `~node$ である
］~AND［
%親 は`文書$である
］
</li>
			<li>
［
%node は`~doctype$である
］~AND［
%親 は`文書$でない
］
</li>
		</ul>
◎
If either node is a Text node and parent is a document, or node is a doctype and parent is not a document, throw a HierarchyRequestError.
</li>
	<li>
<p id="cp-throw-if-doc-etc">
~IF［
%親 は`文書$である
］~AND［
%node の型に応じて，以下が満たされる
］
⇒
~THROW `HierarchyRequestError$E
◎
If parent is a document, and any of the statements below, switched on node, are true, throw a HierarchyRequestError.
</p>

		<dl class="switch">
			<dt>`文書片$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<li id="cp-has-element-children">
%node は複数個の`要素$を`子$に持つ
◎
If node has more than one element child or＼
</li>
					<li id="cp-has-Text-child">
%node は $Text `~node$を`子$に持つ
◎
has a Text node child.
</li>
					<li>
<p id="cp-has-an-element-and">
［
%node は 1 個の`要素$を`子$に持つ
］~AND［
次のいずれかが満たされる
］：
</p>
<!-- "inclusively following" -->
<ul id="cp-has-other-doctype"
	><li>%親 は`要素$を`子$に持つ
</li><li>%子 は`~doctype$である
</li><li>［
%子 ~NEQ ~NULL
］~AND［
%子 に`後続-$する`~doctype$が在る
］
</li></ul>

◎
Otherwise, if node has one element child and either parent has an element child, child is a doctype, or child is not null and a doctype is following child.
</li>
				</ul>
			</dd>

			<dt>`要素$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<!--cp-has-other-doctype-->
<!-- "inclusively following" -->
◎
parent has an element child, child is a doctype, or child is not null and a doctype is following child.
			</dd>

			<dt>`~doctype$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>

<ul>
	<li>%親 は`~doctype$を`子$に持つ</li>
	<li>
［
%子 ~EQ ~NULL
］~AND［
%子 に`先行-$する`要素$が在る
］
</li>
	<li>
［
%子 ~EQ ~NULL
］~AND［
%親 は`要素$を`子$に持つ
］
</li>
</ul>

◎
parent has a doctype child, child is non-null and an element is preceding child, or child is null and parent has an element child.
			</dd>
		</dl>
	</li>
</ol>

<!--% 前挿入 -->
<p class="algo-head">
%親 の中で， %node を %子 の前に
`前挿入@
するときは、次を走らす：
◎
To pre-insert a node into a parent before a child, run these steps:
</p>

<ol>
	<li>
%node を %親 の中で %子 の前に`挿入し得るかどうか検証する$
◎
Ensure pre-insertion validity of node into parent before child.
</li>
	<li>
%基準~子 ~LET %子
◎
Let reference child be child.
</li>
	<li id="cp-set-next-sibling">
~IF［
%基準~子 ~EQ %node
］
⇒
%基準~子 ~SET %node の`弟$
◎
If reference child is node, set it to node’s next sibling.
</li>
<!-- 
【 "If reference child is a node"？】
 -->

	<li id="cp-adopt">
%node を %親 の `~node文書$に`受入-$する
◎
Adopt node into parent’s node document.
</li>
	<li>
%親 の中で， %node を %基準~子 の前に`挿入-$する
◎
Insert node into parent before reference child.
</li>
	<li>
~RET %node
<!-- technically this is post-insert -->
◎
Return node.
</li>
</ol>


<p>
`適用仕様$は、すべてまたは一部の`~node$に対する
`挿入-時の手続き@
を定義して~MAY。
その~algoには、下の`挿入$~algoにて指示される，挿入される~nodeが渡される。
◎
Specifications may define insertion steps for all or some nodes. The algorithm is passed insertedNode, as indicated in the insert algorithm below.
</p>


<!--% 挿入 -->
<p class="algo-head">
`抑止ob^f（省略時は ~OFF ）が与えられた下で，
%親 の中で， %node を %子 の前に
`挿入-@
するときは、次を走らす：
◎
To insert a node into a parent before a child, with an optional suppress observers flag, run these steps:
</p>

<ol>
	<li>
%count ~LET ［
%node は`文書片$であるならば %node の`子$の個数 ／
~ELSE_ 1
］
◎
Let count be the number of children of node if it is a DocumentFragment node, and one otherwise.
</li>
	<li>
<p>
~IF［
%子 ~NEQ ~NULL
］
⇒
~EACH ( `範囲o$ %R ) に対し：
◎
If child is non-null:
</p>

		<ol>
			<li>
~IF［
%R の`始端~node$ ~EQ %親
］~AND［
%R の`始端~offset$ ~GT %子 の`指数$
］
⇒
%R の`始端~offset$ ~INCBY %count
◎
For each range whose start node is parent and start offset is greater than child’s index, increase its start offset by count.
</li>
			<li>
~IF［
%R の`終端~node$ ~EQ %親
］~AND［
%R の`終端~offset$ ~GT %子 の`指数$†
］
⇒
%R の`終端~offset$ ~INCBY %count
◎
For each range whose end node is parent and end offset is greater than child’s index, increase its end offset by count.
</li>
		</ol>

<p class="trans-note">【†
挿入される地点にちょうど一致する［
範囲oの`境界点$
］は、それが`終端$であっても，影響されないことになる
— すなわち，挿入-後は 挿入された~nodeの直前を指す。
その結果，この~algoを利用している後述の`置換-$においては、除去される~nodeの直後または内部を指していた範囲oの境界点は，置換-後は 新たに挿入された~nodeの直前を指すようにされる（~node木の先頭／末尾から相対的な範囲oの始端／終端の位置変化のふるまいが，対称でない — 同様のことは，`~dataを置換する$~algoにも該当する）。
】</p>
	</li>
	<li id="cp-let-nodes">
%nodes ~LET ［
%node は`文書片$であるならば %node のすべての`子$ ／
~ELSE_ %node のみ
］からなる `木~順序の^tnote
~list
◎
Let nodes be node’s children if node is a DocumentFragment node, and a list containing solely node otherwise.
</li>
	<li>
~IF［
%node は`文書片$である
］
⇒
%node の~EACH ( `子$ ) に対し<!-- 順序は関係なし -->
⇒
［
`抑止ob^f: ~ON
］を与える下で，それを %node から`除去-$する
◎
If node is a DocumentFragment node, remove its children with the suppress observers flag set.
</li>
	<li>

<p>
~IF［
%node は`文書片$である
］
⇒
`変異~記録を待入する$( 次に与える変異~記録 )
⇒＃
~target : %node,
種別 : `childList^l,
除去済nodes : %nodes
◎
If node is a DocumentFragment node, queue a mutation record of "childList" for node with removedNodes nodes.
</p>

<p class="note">注記：
この段では意図的に `抑止ob^f を~~無視する。
◎
This step intentionally does not pay attention to the suppress observers flag.
</p>
	</li>
	<li>
%兄 ~LET ［
%子 ~NEQ ~NULL ならば %子 の`兄$ ／
~ELSE_ %親 の`最後0の子$
］
◎
Let previousSibling be child’s previous sibling or parent’s last child if child is null.
</li>
	<li>
<p>
%nodes 内の~EACH ( %node ) に対し，`木~順序$で：
◎
For each node in nodes, in tree order:
</p>
		<ol>
			<li>
~IF［
%子 ~EQ ~NULL
］
⇒
%node を %親 の`子たち$に`付加-$setする
◎
If child is null, then append node to parent’s children.
</li>
			<li>
~ELSE
⇒
%node を%親 の`子たち$の中で %子 の`指数$の前に`挿入-$listする
◎
Otherwise, insert node into parent’s children before child’s index.
</li>
			<li>
~IF［
%親 は`~shadow~host$である
］~AND［
%~node は`~slotable$である
］
⇒
`~slotableを~slotに割当する$( %~node )
◎
If parent is a shadow host and node is a slotable, then assign a slot for node.
</li>
			<li id="cp-child-text-content-change-steps-if">
~IF［
%~node は $Text ~nodeである
］
⇒
%親 に対する`子~text内容~変更-時の手続き$を走らす
◎
If node is a Text node, run the child text content change steps for parent.
</li>
			<li id="cp-signal-if-assigned-empty">
~IF［
%親 の`根$は`~shadow根$である
］~AND［
%親 は`~slot$である
］~AND［
%親 に`割当されている~nodeたち$は 空~listである
］
⇒
`~slotの変化を通達する$( %親 )
◎
If parent’s root is a shadow root, and parent is a slot whose assigned nodes is the empty list, then run signal a slot change for parent.
</li>
			<li id="cp-assign-slotables-for-tree">
`木に~slotableたちを割当する$( %~node の`木$ )
◎
Run assign slotables for a tree with node’s tree.
</li>
			<li>
<p>
%~node の~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し，`~shadowも含む木~順序$で：
◎
For each shadow-including inclusive descendant inclusiveDescendant of node, in shadow-including tree order:
</p>
				<ol>
					<li>
%広義子孫 を与える下で，`挿入-時の手続き$を走らす
◎
Run the insertion steps with inclusiveDescendant.
</li>
					<li>
~IF［
%広義子孫 は`接続されて$いない
］
⇒
~CONTINUE
◎
If inclusiveDescendant is connected, then:
</li>
					<li>
~IF［
%広義子孫 は`~custom$である
］
⇒
`~custom要素~callback反応を待入れる$(
%広義子孫,
`connectedCallback^l,
空~list
)
◎
If inclusiveDescendant is custom, then enqueue a custom element callback reaction with inclusiveDescendant, callback name "connectedCallback", and an empty argument list.
</li>
					<li>
<p>
~ELSE
⇒
%広義子孫 を`昇格しようと試行する$
◎
Otherwise, try to upgrade inclusiveDescendant.
</p>

<p class="note">注記：
%広義子孫 が成功裡に昇格された場合、その ^connectedCallback は，`要素を昇格する$~algoの間に自動的に待入れられる。
◎
If this successfully upgrades inclusiveDescendant, its connectedCallback will be enqueued automatically during the upgrade an element algorithm.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
`抑止ob^f ~EQ ~OFF
］
⇒
`変異~記録を待入する$( 次に与える変異~記録 )
⇒＃
~target: %親,
種別 : `childList^l,
追加済nodes : %nodes,
弟 : %子,
兄 : %兄
◎
If suppress observers flag is unset, queue a mutation record of "childList" for parent with addedNodes nodes, nextSibling child, and previousSibling previousSibling. 
</li>
</ol>



<p class="algo-head">
%node を %親 に
`付加-@
するときは、 %親 の中で， %node を~NULL の前に`前挿入$する。
◎
To append a node to a parent, pre-insert node into parent before null.
</p>


<!--% 置換 -->
<p class="algo-head">
%親 の中で %子 を %node に
`置換-@
するときは、次を走らす：
◎
To replace a child with node within a parent, run these steps:
</p>

<ol>
	<!--cp-throw-if-chardata-->
	<!--cp-throw-if-iAN-->
	<!-- 原文誤記 "inclusive ancestor *of* parent" →-->
	<li>
<p id="cp-throw-if-not-parent">
~IF［
%子 の`親$ ~NEQ %親
］
⇒
~THROW `NotFoundError$E
◎
If child’s parent is not parent, then throw a NotFoundError.
</p>
	</li>
	<!--cp-throw-if-not-doc-->
	<!--cp-throw-if-mismatch1-->
	<li>
<!--cp-throw-if-doc-etc-->
		<dl class="switch">
			<dt>`文書片$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<ul>
					<!--cp-has-element-children-->
					<!--cp-has-Text-child-->
					<li>
						<!--cp-has-an-element-and-->
<ul id="cp-has-other-element"
	><li>%親 は［ %子 でない`要素$ ］を`子$に持つ
</li><li>%子 に`後続-$する`~doctype$が在る
</li></ul>
◎
Otherwise, if node has one element child and either parent has an element child that is not child or a doctype is following child.
</li>
				</ul>
			</dd>

			<dt>`要素$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>
				<!--cp-has-other-element-->
◎
parent has an element child that is not child or a doctype is following child.
			</dd>

			<dt>`~doctype$</dt>
			<dd>
<p>
次のいずれかが満たされる：
</p>

<ul><li>%親 は［ %子 でない`~doctype$ ］を`子$に持つ
</li><li>%子 に`先行-$する`要素$が在る
</li></ul>

◎
parent has a doctype child that is not child, or an element is preceding child.
			</dd>

		</dl>

<p class="note">注記：
この段は，`挿入し得るかどうか検証する$ ~algoの似た段と異なる。
◎
The above statements differ from the pre-insert algorithm.
</p>
	</li>
	<li>
%基準~子 ~LET %子 の`弟$
◎
Let reference child be child’s next sibling.
</li>
	<!--cp-set-next-sibling-->
	<li>
%兄 ~LET %子 の`兄$
◎
Let previousSibling be child’s previous sibling.
</li>
	<!--cp-adopt-->
	<li>
%除去済nodes ~LET 空~list
◎
Let removedNodes be the empty list.
</li>
	<li>
<p>
~IF［
%子 の`親$ ~NEQ ~NULL
］：
◎
If child’s parent is not null, then:
</p>
		<ol>
			<li>
%除去済nodes ~SET %子 のみからなる~list
◎
Set removedNodes to a list solely containing child.
</li>
			<li>
［
`抑止ob^f: ~ON
］を与える下で，
%子 を %親 から`除去-$する
◎
Remove child from its parent with the suppress observers flag set.
</li>
		</ol>

<p class="note">注記：
この段の~~条件は［
%子 ~EQ %node
］の場合に限り，偽になる。
◎
The above can only be false if child is node.
</p>

	</li>
	<!--cp-let-nodes-->
	<li>
［
`抑止ob^f: ~ON
］を与える下で，
%親 の中で， %node を %基準~子 の前に`挿入-$する
◎
Insert node into parent before reference child with the suppress observers flag set.
</li>
	<li>
`変異~記録を待入する$( 次に与える変異~記録 )
⇒＃
~target : %親,
種別 : `childList^l,
追加済nodes : %nodes,
除去済nodes : %除去済nodes,
弟 : %基準~子,
兄 : %兄
◎
Queue a mutation record of "childList" for target parent with addedNodes nodes, removedNodes removedNodes, nextSibling reference child, and previousSibling previousSibling.
</li>
	<li>
~RET %子
◎
Return child.
</li>
</ol>

<!--% 全置換 -->
<p class="algo-head">
%親 の内容を %node で
`すべて置換-@
するときは、次を走らす：
◎
To replace all with a node within a parent, run these steps:
</p>

<ol>
	<li>
~IF［
%node ~NEQ ~NULL
］
⇒
%node を %親 の `~node文書$に`受入-$する
◎
If node is not null, adopt node into parent’s node document.
</li>
	<li>
%除去済nodes ~LET %親 のすべての`子$
◎
Let removedNodes be parent’s children.
</li>
	<li>
<p>
%追加済nodes ~LET ［
%node に応じて，次で与えられる~list
］：
</p>
		<dl class="switch">
			<dt>~NULL</dt>
			<dd>
空~list
</dd>
			<dt>`文書片$</dt>
			<dd>
%node のすべての`子$ からなる~list
</dd>

			<dt>その他</dt>
			<dd>
%node のみからなる~list
</dd>
		</dl>

◎
Let addedNodes be the empty list if node is null, node’s children if node is a DocumentFragment node, and a list containing node otherwise.
</li>
	<li>
%親 の~EACH ( `子$ %子 ) に対し，`木~順序$で
⇒
［
`抑止ob^f: ~ON
］を与える下で，
%子 を %親 から`除去-$する
◎
Remove all parent’s children, in tree order, with the suppress observers flag set.
</li>
	<li>
~IF［
%node ~NEQ ~NULL
］
⇒
［
`抑止ob^f: ~ON
］を与える下で，
%親 の中で， %node を ~NULL の前に`挿入-$する
◎
If node is not null, insert node into parent before null with the suppress observers flag set.
</li>
	<li>
`変異~記録を待入する$( 次に与える変異~記録 )
⇒＃
~target : %親,
種別 : `childList^l,
追加済nodes : %追加済nodes,
除去済nodes : %除去済nodes
◎
Queue a mutation record of "childList" for parent with addedNodes addedNodes and removedNodes removedNodes.
</li>
</ol>

<p class="note">注記：
この~algoは `~node木$に課される拘束を検査しない。
仕様の策定者は賢く用いること。
◎
This algorithm does not make any checks with regards to the node tree constraints. Specification authors need to use it wisely.
</p>

<p class="algo-head">
%子 を %親 から
`前除去-@
するときは、次を走らす：
◎
To pre-remove a child from a parent, run these steps:
</p>

<ol>
	<li><!--cp-throw-if-not-parent--></li>
	<li>
%子 を %親 から`除去-$する
◎
Remove child from parent.
</li>
	<li>
~RET %子
	<!-- technically this is post-remove -->
◎
Return child.
</li>
</ol>

<p>
`適用仕様$は、すべてまたは一部の`~node$に対する
`除去-時の手続き@
を定義して~MAY。
その~algoには、下の`除去-$ ~algoにて指示される
( 除去された~node, その旧-親（省略可） )
の組が渡される。
◎
Specifications may define removing steps for all or some nodes. The algorithm is passed removedNode, and optionally oldParent, as indicated in the remove algorithm below.
</p>

<!--% 除去 -->
<p class="algo-head">
`抑止ob^f（省略時は ~OFF ）が与えられた下で，
%~node を %親 から
`除去-@
するときは、次を走らす：
◎
To remove a node from a parent, with an optional suppress observers flag, run these steps:
</p>

<ol>
	<li>
%指数 ~LET %~node の`指数$
◎
Let index be node’s index.
</li>
	<li>
<p>
~EACH ( `範囲o$ %R ) に対し：
◎
↓</p>

		<ol>
			<li>
~IF［
%R の`始端~node$ は %~node の`広義子孫$である
］
⇒＃
%R の`始端~node$ ~SET %親；
%R の`始端~offset$ ~SET %指数
◎
For each range whose start node is an inclusive descendant of node, set its start to (parent, index).
</li>
			<li>
~IF［
%R の`終端~node$ は %~node の`広義子孫$である
］
⇒＃
%R の`終端~node$ ~SET %親；
%R の`終端~offset$ ~SET %指数
◎
For each range whose end node is an inclusive descendant of node, set its end to (parent, index).
</li>
			<li>
~IF［
%R の`始端~node$ ~EQ %親
］~AND［
%R の`始端~offset$ ~GT %指数
］
⇒
%R の`始端~offset$ ~DECBY 1
◎
For each range whose start node is parent and start offset is greater than index, decrease its start offset by one.
</li>
			<li>
~IF［
%R の`終端~node$ ~EQ %親
］~AND［
%R の`終端~offset$ ~GT %指数
］
⇒
%R の`終端~offset$ ~DECBY 1
◎
For each range whose end node is parent and end offset is greater than index, decrease its end offset by one.
</li>
		</ol>
	</li>
	<li>
［
%反復器 の`根~node$の`~node文書$ ~EQ %~node `~node文書$
］なる，~EACH ( $NodeIterator ~obj  %反復器 ) に対し
⇒
( %反復器, %~node )
を与える下で，`前除去-時の手続き$を走らす
◎
For each NodeIterator object iterator whose root’s node document is node’s node document, run the NodeIterator pre-removing steps given node and iterator.
</li>
	<li>
%兄 ~LET %~node の`兄$
◎
Let oldPreviousSibling be node’s previous sibling.
</li>
	<li>
%弟 ~LET %~node の`弟$
◎
Let oldNextSibling be node’s next sibling.
</li>
	<li>
%~node を %親 の`子たち$から`除去-$listする
◎
Remove node from its parent’s children.
</li>
	<li>
~IF［
%~node の`割当先~slot$ ~NEQ ~NULL
］
⇒
`~slotに~slotableたちを割当する$( その`~slot$ )
◎
If node is assigned, then run assign slotables for node’s assigned slot.
</li>
			<!--cp-signal-if-assigned-empty-->
	<li>
<p>
~IF［［
%~node の`広義子孫$のうち，`~slot$であるもの
］は在る
］：
◎
If node has an inclusive descendant that is a slot, then:
</p>
		<ol>
			<li>
`木に~slotableたちを割当する$( %親 の`木$ )
◎
Run assign slotables for a tree with parent’s tree.
</li>
			<!--cp-assign-slotables-for-tree-->
		</ol>
	</li>
	<li>
( %~node, %親 )
を与える下で，`除去-時の手続き$を走らす
◎
Run the removing steps with node and parent.
</li>
	<li>
<p>
~IF［
%~node は`~custom$である
］
⇒
`~custom要素~callback反応を待入れる$(
%~node,
`disconnectedCallback^l,
空~list
)
◎
If node is custom, then enqueue a custom element callback reaction with node, callback name "disconnectedCallback", and an empty argument list.
</p>

<p class="note">注記：
今の所，`~custom$である`要素$には %親 は渡されないのは意図的であるが、将来に必要になった場合は変更され得る。
◎
It is intentional for now that custom elements do not get parent passed. This might change in the future if there is a need.
</p>

	<li>
<p>
%~node の~EACH ( `~shadowも含む子孫$ %子孫 ) に対し，`~shadowも含む木~順序$で：
◎
For each shadow-including descendant descendant of node, in shadow-including tree order, then:
</p>
		<ol>
			<li>
( %子孫, … )
を与える下で，`除去-時の手続き$を走らす
◎
Run the removing steps with descendant.
</li>
			<li>
~IF［
%子孫 は`~custom$である
］
⇒
`~custom要素~callback反応を待入れる$(
%子孫,
`disconnectedCallback^l,
空~list
)
◎
If descendant is custom, then enqueue a custom element callback reaction with descendant, callback name "disconnectedCallback", and an empty argument list.
</li>
		</ol>
	</li>
	<li>
%親 の~EACH ( `広義先祖$ %広義先祖 ) に対し
⇒
%広義先祖 の`~ob~list$ 内の~EACH ( `登録済み~ob$ %O ) に対し
⇒
~IF［
%O の `options^i
］の $MutationObserverInit.subtree ~EQ ~T
⇒
次のように設定された`一時~登録済み~ob$を， %~node の`~ob~list$に付加する
⇒
( `observer^i, `options^i, `source^i )
~SET
( %O の `observer^i, %O の `options^i, %O )
◎
For each inclusive ancestor inclusiveAncestor of parent, if inclusiveAncestor has any registered observers whose options' subtree is true, then for each such registered observer registered, append a transient registered observer whose observer and options are identical to those of registered and source which is registered to node’s list of registered observers.
</li>
	<li>
~IF［
`抑止ob^f ~EQ ~OFF
］
⇒
`変異~記録を待入する$( 次に与える変異~記録 )
⇒＃
~target : %親,
種別 : `childList^l,
除去済nodes : %~node のみからなる~list,
弟 : %弟, 
兄 : %兄
◎
If suppress observers flag is unset, queue a mutation record of "childList" for parent with removedNodes a list solely containing node, nextSibling oldNextSibling, and previousSibling oldPreviousSibling.
</li>
	<!--cp-child-text-content-change-steps-if-->
</ol>


			</section>
			<section id="interface-nonelementparentnode">
<h4>4.2.4. ~mixin ^@NonElementParentNode</h4>

<p class="note">注記：
~Web互換性のため、 $getElementById() ~methは，`要素$ 上には（したがって $ParentNode 上にも）公開できない。
◎
Web compatibility prevents the getElementById() method from being exposed on elements (and therefore on ParentNode).
</p>

<p class="trans-note">【
“~mixin”
— ~ifcに対する~mixinという語は、
<a href="~WEBIDL#dfn-implements-statement">implements 文</a>
を通して実装されることを意図して定義されている（追補的な）~ifcを意味する。
】</p>

⇒！
[`NoInterfaceObject$,
 `Exposed$=Window]
interface @NonElementParentNode {
  $Element? $getElementById(~DS %elementId);
};
$Document implements $NonElementParentNode;
$DocumentFragment implements $NonElementParentNode;
◎

<dl class="domintro">
	<dt>%node . $getElementById(elementId)</dt>
	<dd>
%node の`子孫$であって, `~ID$が %elementId なる`要素$のうち，`最初0$のものを返す。
◎
Returns the first element within node’s descendants whose ID is elementId.
</dd>

</dl>

<dl class="idl-def">
	<dt>@getElementById(elementId)</dt>
	<dd>
被呼出時には、此れの`子孫$のうち，［
`~ID$ ~EQ %elementId
］なる`要素$のうち，`最初0$のものを返さ~MUST。
◎
The getElementById(elementId) method, when invoked, must return the first element, in tree order, within context object’s descendants, whose ID is elementId, and null if there is no such element otherwise.
</dd>
</dl>
			</section>
			<section id="mixin-documentorshadowroot">
<h4>4.2.5. ~mixin ^@DocumentOrShadowRoot</h4>

⇒！
[`NoInterfaceObject$,
 `Exposed$=Window]
interface @DocumentOrShadowRoot {
};

$Document implements $DocumentOrShadowRoot;
$ShadowRoot implements $DocumentOrShadowRoot;
◎


<p class="note">注記：
$DocumentOrShadowRoot ~mixinは、［
`文書$, `~shadow根$
］で共有される~APIを定義したいと求める他の標準により利用されることが期待されている。
◎
The DocumentOrShadowRoot mixin is expected to be used by other standards that want to define APIs shared between documents and shadow roots.
</p>

			</section>
			<section id="interface-parentnode">
<h4>4.2.6. ~mixin ^@ParentNode</h4>

<p class="algo-head">
`~nodeたちを~nodeに変換する@
手続きは、所与の
( %nodes, %文書 )
に対し，次を走らす：
◎
To convert nodes into a node, given nodes and document, run these steps:
</p>

<p class="trans-note">【
%nodes は、~nodeと文字列が混在する引数~list。
】</p>

<ol>
	<li>
%nodes 内の~EACH ( 文字列 %文字列 ) を
`新たな~Text~node$( %文字列, %文書 )
に置換する
◎
Let node be null.
◎
Replace each string in nodes with a new Text node whose data is the string and node document is document.
</li>
	<li>
~IF［
%nodes に含まれる`~node$は 1 個だけ
］
⇒
~RET その`~node$
◎
If nodes contains one node, set node to that node.
</li>
	<li>
%文書片 ~LET 新たな`文書片$
◎
Otherwise, set node to a new DocumentFragment＼
</li>
	<li>
%文書片 の`~node文書$ ~SET %文書
◎
whose node document is document, and then＼
</li>
	<li>
%nodes 内の~EACH ( %node ) に対し
⇒
%node を %文書片 に`付加-$する
◎
append each node in nodes, if any, to it.
</li>
	<li>
~RET %文書片
◎
Return node.
</li>
</ol>

⇒！
[`NoInterfaceObject$,
 `Exposed$=Window]
interface @@ParentNode {
  [`SameObject$] ~RA $HTMLCollection $children;
  ~RA $Element? $firstElementChild;
  ~RA $Element? $lastElementChild;
  ~RA ~UL $childElementCount;

  [`CEReactions$, `Unscopable$] void $prepend((Node or ~DS)... %nodes);
  [`CEReactions$, `Unscopable$] void $append((Node or ~DS)... %nodes);

  $Element? $querySelector(~DS %selectors);
  [`NewObject$] $NodeList $querySelectorAll(~DS %selectors);
};
$Document implements $ParentNode;
$DocumentFragment implements $ParentNode;
$Element implements $ParentNode;
◎

<dl class="domintro">
	<dt>%collection = %node . $children</dt>
	<dd>
`子$である`要素$をすべて返す。
◎
Returns the child elements.
</dd>

	<dt>%element = %node . $firstElementChild</dt>
	<dd>
`子$である`要素$のうち，`最初0$のものを返す。
◎
Returns the first child that is an element, and null otherwise.
</dd>

	<dt>%element = %node . $lastElementChild</dt>
	<dd>
 `子$である`要素$のうち，`最後0$のものを返す。
◎
Returns the last child that is an element, and null otherwise.
</dd>

	<dt>%node . $prepend(nodes…)</dt>
	<dd>
%nodes 引数の中の文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の`最初0の子$の前に挿入する。
◎
Inserts nodes before the first child of node, while replacing strings in nodes with equivalent Text nodes.
</dd>

<dd id="cp-throw-if-violate-tree">
`~node木$の拘束に反する場合、 `HierarchyRequestError$E が`投出$される。
◎
Throws a HierarchyRequestError if the constraints of the node tree are violated.
</dd>

	<dt>%node . $append(nodes)</dt>
	<dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の`最後0の子$の後に挿入する。
◎
Inserts nodes after the last child of node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $querySelector(selectors)</dt>
	<dd>
%node の`子孫$であって,
%selectors に合致する，`最初0$の`要素$を返す。
◎
Returns the first element that is a descendant of node that matches selectors.
</dd>

	<dt>%node . $querySelectorAll(selectors)</dt>
	<dd>
%node の`子孫$であって,
%selectors に合致する，すべての`要素$を返す。
◎
Returns all element descendants of node that match selectors.
</dd>

</dl>

<dl class="idl-def">
	<dt>@children</dt>
	<dd>
取得子は、次のようにされた $HTMLCollection `~collection$を返さ~MUST
⇒＃
`根$cl ~SET 此れ,
`~filter$は 此れの`子$である`要素$のみに合致する
◎
The children attribute’s getter must return an HTMLCollection collection rooted at context object matching only element children.
</dd>

	<dt>@firstElementChild</dt>
	<dd>
取得子は、此れの`子$である`要素$のうち，`最初0$のものを返さ~MUST。
◎
The firstElementChild attribute’s getter must return the first child that is an element, and null otherwise.
</dd>

	<dt>@lastElementChild</dt>
	<dd>
取得子は、此れの`子$である`要素$のうち，`最後0$のものを返さ~MUST。
◎
The lastElementChild attribute’s getter must return the last child that is an element, and null otherwise.
</dd>

	<dt>@childElementCount</dt>
	<dd>
取得子は、此れの`子$である`要素$の個数を返さ~MUST。
◎
The childElementCount attribute’s getter must return the number of children of context object that are elements.
</dd>

	<dt>@prepend(nodes)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The prepend(nodes) method, when invoked, must run these steps: 
</p>

		<ol>
			<li id="cp-convert-nodes">
%node ~LET
`~nodeたちを~nodeに変換する$( %nodes, 此れの`~node文書$ )
◎
Let node be the result of converting nodes into a node, given nodes and context object’s node document.
</li>
			<li>
此れの中で， %node を此れの`最初0の子$の前に`前挿入$する
◎
Pre-insert node into context object before the context object’s first child.
</li>
		</ol>
	</dd>

	<dt>@append(nodes)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The append(nodes) method, when invoked, must run these steps:
</p>

		<ol>
			<!--cp-convert-nodes-->
			<li>
%node を此れに`付加-$する
◎
Append node to context object.
</li>
		</ol>
	</dd>

	<dt>@querySelector(selectors)</dt>
	<dd>
被呼出時には、此れの`視野の下で選択子を照合する$( %selectors )
の結果の中の，`最初0$の要素を返さ~MUST。
◎
The querySelector(selectors) method, when invoked, must return the first result of running scope-match a selectors string selectors against context object, if the result is not an empty list, and null otherwise.
</dd>

	<dt>@querySelectorAll(selectors)</dt>
	<dd>
被呼出時には、此れの`視野の下で選択子を照合する$( %selectors )
の結果を，`静的$なものとして 返さ~MUST。
◎
The querySelectorAll(selectors) method, when invoked, must return the static result of running scope-match a selectors string selectors against the context object.
</dd>
</dl>
			</section>
			<section id="interface-nondocumenttypechildnode">
<h4>4.2.7. ~mixin ^@NonDocumentTypeChildNode</h4>

<p class="note">注記：
~Web互換性のため、
$previousElementSibling, $nextElementSibling
属性は，`~doctype$上には（したがって， $ChildNode 上にも）公開できない。
◎
Web compatibility prevents the previousElementSibling and nextElementSibling attributes from being exposed on doctypes (and therefore on ChildNode).
</p>

⇒！
[`NoInterfaceObject$,
 `Exposed$=Window]
interface @NonDocumentTypeChildNode {
  ~RA $Element? $previousElementSibling;
  ~RA $Element? $nextElementSibling;
};
$Element implements $NonDocumentTypeChildNode;
$CharacterData implements $NonDocumentTypeChildNode;
◎

<dl class="domintro">
	<dt>%element = %node . $previousElementSibling</dt>
	<dd>
`先行-$する`同胞$の`要素$のうち，`最後0$のものを返す。
◎
Returns the first preceding sibling that is an element, and null otherwise.
</dd>

	<dt>%element = %node . $nextElementSibling</dt>
	<dd>
`後続-$する`同胞$の`要素$のうち，`最初0$のものを返す。
◎
Returns the first following sibling that is an element, and null otherwise.
</dd>
</dl>

<dl class="idl-def">
	<dt>@previousElementSibling</dt>
	<dd>
取得子は、［
此れの`同胞$である
］~AND［
此れに`先行-$する
］~AND［
`要素$である
］ような~nodeのうち，`最後0$のものを返さ~MUST。
◎
The previousElementSibling attribute’s getter must return the first preceding sibling that is an element, and null otherwise.
</dd>

	<dt>@nextElementSibling</dt>
	<dd>
取得子は、［
此れの`同胞$である
］~AND［
此れに`後続-$する
］~AND［
`要素$である
］ような~nodeのうち，`最初0$のものを返さ~MUST。
◎
The nextElementSibling attribute’s getter must return the first following sibling that is an element, and null otherwise.
</dd>
</dl>

			</section>
			<section id="interface-childnode">
<h4>4.2.8. ~mixin ^@ChildNode</h4>

⇒！
[`NoInterfaceObject$,
 `Exposed$=Window]
interface @ChildNode {
  [`CEReactions$, `Unscopable$] void $before(($Node or ~DS)... %nodes);
  [`CEReactions$, `Unscopable$] void $after(($Node or ~DS)... %nodes);
  [`CEReactions$, `Unscopable$] void $replaceWith(($Node or ~DS)... %nodes);
  [`CEReactions$, `Unscopable$] void $remove();
};
$DocumentType implements $ChildNode;
$Element implements $ChildNode;
$CharacterData implements $ChildNode;
◎

<dl class="domintro">
	<dt>%node . $before(…nodes)</dt>
	<dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の直前に挿入する。
◎
Inserts nodes just before node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $after(…nodes)</dt>
	<dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%nodes を %node の直後に挿入する。
◎
Inserts nodes just after node, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $replaceWith(…nodes)</dt>
	<dd>
%nodes の中の各~文字列は等価な $Text `~node$に置換した上で，
%node を %nodes に置換する。
◎
Replaces node with nodes, while replacing strings in nodes with equivalent Text nodes.
</dd>
	<!--cp-throw-if-violate-tree-->
	<dt>%node . $remove()</dt>
	<dd>
%node を除去する。
◎
Removes node.
</dd>

</dl>

<dl class="idl-def">
	<dt>@before(nodes)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The before(nodes) method, when invoked, must run these steps:
</p>

		<ol>
			<li id="cp-let-ctx-parent">
%親 ~LET 此れの`親$
◎
Let parent be context object’s parent.
</li>
			<li id="cp-exit-if-null-parent">
~IF［
%親 ~EQ ~NULL
］
⇒
~RET
◎
If parent is null, then return.
</li>
			<li>
<p>
%~viable兄 ~LET ［
次のいずれも満たすような~node
］のうち，`最後0$のもの：
</p>
<ul><li>此れの`同胞$である
</li><li>此れに`先行-$する
</li><li>~node ~NIN %nodes に与えられた引数の集合
</li></ul>
◎
Let viablePreviousSibling be context object’s first preceding sibling not in nodes, and null otherwise.
</li>
			<!--cp-convert-nodes-->
			<li>
%~viable兄 ~SET ［
%~viable兄 ~EQ ~NULL ならば %親 の`最初0の子$ ／
~ELSE_ %~viable兄 の`弟$
］
◎
If viablePreviousSibling is null, set it to parent’s first child, and to viablePreviousSibling’s next sibling otherwise.
</li>
			<li>
%親 の中で， %node を %~viable兄 の前に`前挿入$する
◎
Pre-insert node into parent before viablePreviousSibling.
</li>
		</ol>
	</dd>

	<dt>@after(nodes)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The after(nodes) method, when invoked, must run these steps:
</p>

		<ol>
			<!--cp-let-ctx-parent-->
			<!--cp-exit-if-null-parent-->
			<li id="cp-let-viableNextSibling">
<p>
%~viable弟 ~LET ［
次のいずれも満たすような~node
］のうち，`最初0$のもの：
</p>

<ul><li>此れの`同胞$である
</li><li>此れに`後続-$する
</li><li>~node ~NIN %nodes に与えられた引数の集合
</li></ul>

◎
Let viableNextSibling be context object’s first following sibling not in nodes, and null otherwise.
</li>
			<!--cp-convert-nodes-->
			<li>
%親 の中で， %node を %~viable弟 の前に`前挿入$する
◎
Pre-insert node into parent before viableNextSibling.
</li>
		</ol>
	</dd>

	<dt>@replaceWith(nodes)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The replaceWith(nodes) method, when invoked, must run these steps:
</p>

		<ol>
			<!--cp-let-ctx-parent-->
			<!--cp-exit-if-null-parent-->
			<!--cp-let-viableNextSibling-->
			<!--cp-convert-nodes-->
			<li>
<p>
~IF［
此れの`親$ ~EQ %親
］
⇒
%親 の中で，此れを %node に`置換-$する
◎
If context object’s parent is parent, replace the context object with node within parent.
</p>

<p class="note">注記：
此れは %node の中に挿入されていることもある。
◎
Context object could have been inserted into node.
</p>
			</li>
			<li>
~ELSE
⇒
%親 の中で， %node を %~viable弟 の前に`前挿入$する
◎
Otherwise, pre-insert node into parent before viableNextSibling.
</li>
		</ol>
	</dd>

	<dt>@remove()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The remove() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの`親$ ~EQ ~NULL
］
⇒
~RET
◎
If context object’s parent is null, then return.
</li>
			<li>
此れの`親$から此れを`除去-$する
◎
Remove the context object from context object’s parent.
</li>
		</ol>
	</dd>
</dl>


			</section>
			<section id="mixin-slotable">
<h4 title="Mixin Slotable">4.2.9. ~mixin ^@Slotable</h4>

⇒！
[`NoInterfaceObject$,
 `Exposed$=Window]
interface @Slotable {
  ~RA $HTMLSlotElement? $assignedSlot;
};

$Element implements $Slotable;
$Text implements $Slotable;
◎


<dl class="idl-def">
	<dt>@assignedSlot</dt>
	<dd>
取得子は、次を走らせ~MUST
⇒
`~slotable用に~slotを見出す$( 此れ, ~ON )
◎
The assignedSlot attribute’s getter must return the result of find a slot given context object and with the open flag set.
</dd>
</dl>



			</section>
			<section id="old-style-collections">
<h4 title="Old-style collections: NodeList and HTMLCollection">4.2.10. 古い方式の~collection： ^NodeList と ^HTMLCollection</h4>

<p>
`~collection@
は`~node$の~listを表現する~objである。
`~collection$は
`~live@
にも
`静的@
にもなり得る。
他が定められない限り、`~collection$は`~live$で~MUST。
◎
A collection is an object that represents a list of nodes. A collection can be either live or static. Unless otherwise stated, a collection must be live.
</p>

<p>
`~live$である`~collection$の［
属性／~meth
］は、~dataの~snapshotではなく 実際の下層~data†に対し，演算し~MUST††。
◎
If a collection is live, then the attributes and methods on that object must operate on the actual underlying data, not a snapshot of the data.
</p>

<p class="trans-note">【†
すなわち、作成-時の~data（~snapshot）ではなく，~accessされた時点における~data
】【††
従って，~collectionの走査-中に木を改変するときは、~collectionの無限増殖に陥いらないよう注意する必要がある。
】【
`静的$とされている場合は，逆に、~dataの~snapshotに対し演算することになる。
】</p>

<div class="p">
<p>
各 `~collection$の作成-時には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`根@cl</dt>
	<dd>
~collectionの視野を与える。
</dd>
	<dt>`~filter@</dt>
	<dd>
~nodeが~collectionに含められるための条件を与える。
</dd>
</dl>

◎
When a collection is created, a filter and a root are associated with it.
</div>

<p>
`~collection$は、［
その`根$clを根とする部分木の中で，所与の`~filter$に合致する`~node$
］のみを含むような~viewを
`表現-@
する。
この~viewは全順序である
— `~collection$に含められる~nodeたちは、他の要件が指定されない限り，`木~順序$に整列され~MUST。
◎
The collection then represents a view of the subtree rooted at the collection’s root, containing only nodes that match the given filter. The view is linear. In the absence of specific requirements to the contrary, the nodes within the collection must be sorted in tree order.
</p>

<p class="trans-note">【
ほとんどの~collectionでは，`根$cl自身は`~filter$に合致しないが、
$NodeIterator の`反復器~collection$など，そうでないものもある。
】</p>

				<section id="interface-nodelist">
<h5>4.2.10.1. ~ifc ^@NodeList</h5>

<p>
$NodeList ~objは`~node$の`~collection$である。
◎
A NodeList object is a collection of nodes.
</p>

⇒！
[`Exposed$=Window]
interface @NodeList {
  getter $Node? $item(~UL %index);
  ~RA ~UL $length;
  iterable&lt;$Node&gt;;
};
◎


<dl class="domintro">
	<dt>%collection . $length</dt>
	<dd>
`~collection$に含まれている`~node$の個数を返す。
◎
Returns the number of nodes in the collection.
</dd>

	<dt>%element = %collection . $item(index)</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
`木~順序$に整列された下で、`~collection$の中で， %index 番の`~node$を返す。
◎
Returns the node with index index from the collection. The nodes are sorted in tree order.
</dd>
</dl>

<p>
~collection %O の`被support ~prop~index$は、
0 以上［
%O で`表現-$される~nodeの個数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of nodes represented by the collection. If there are no such elements, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、此れが`表現-$する~nodeの個数を返さ~MUST。
◎
The length attribute must return the number of nodes represented by the collection.
</dd>

	<dt>@item(index)</dt>
	<dd>
被呼出時には、［
%index ~NIN { 此れの`被support ~prop~index$ } ならば~NULL ／
~ELSE_  此れの中の %index 番の`~node$
］を返さ~MUST。
◎
The item(index) method must return the indexth node in the collection. If there is no indexth node in the collection, then the method must return null.
</dd>
</dl>

				</section>
				<section id="interface-htmlcollection">
<h5>4.2.10.2. ~ifc ^@HTMLCollection</h5>

⇒！
[`Exposed$=Window,
 `LegacyUnenumerableNamedProperties$]
interface @HTMLCollection {
  ~RA ~UL $length;
  getter $Element? $item(~UL %index);
  getter $Element? $namedItem(~DS %name);
};
◎

<p>
$HTMLCollection ~objは`要素$の`~collection$である。
◎
An HTMLCollection object is a collection of elements.
</p>

<p class="note">注記：
$HTMLCollection は、歴史上の~~理由から~~廃するわけにいかない所産である。
開発者は それを利用し続けても構わないが、新たな~API標準の設計者は それを利用しないこと（代わりに~IDL <code >sequence&lt;%T&gt;</code> 型を利用すること）。
◎
HTMLCollection is an historical artifact we cannot rid the web of. While developers are of course welcome to keep using it, new API standard designers ought not to use it (use sequence&lt;T&gt; in IDL instead).
</p>

<dl class="domintro">
	<dt>%collection . $length</dt>
	<dd>
`~collection$に含まれている`要素$の個数を返す。
◎
Returns the number of elements in the collection.
</dd>

	<dt>%element = %collection . $item(index)</dt>
	<dt>%element = %collection[%index]</dt>
	<dd>
`要素$たちを`木~順序$に整列した下での、`~collection$の中で %index 番の`要素$を返す。
◎
Returns the element with index index from the collection. The elements are sorted in tree order.
</dd>

	<dt>%element = %collection . $namedItem(name)</dt>
	<dt>%element = %collection[%name]</dt>
	<dd>
~collectionの中で `~ID$ または名前が %name なる最初の`要素$を返す。
◎
Returns the first element with ID or name name from the collection.
</dd>

</dl>



<p>
~collection %O の`被support ~prop~index$は、
0 以上［
%O で`表現-$される要素の個数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of elements represented by the collection. If there are no such elements, then there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、此れが`表現-$する~nodeの個数を返さ~MUST。
◎
The length attribute’s getter must return the number of nodes represented by the collection.
</dd>

	<dt>@item(index)</dt>
	<dd>
被呼出時には、［
%index ~NIN { 此れの`被support ~prop~index$ } ならば~NULL ／
~ELSE_  此れの中の %index 番の`~node$
］を返さ~MUST。
◎
The item(index) method, when invoked, must return the indexth element in the collection. If there is no indexth element in the collection, then the method must return null.
</dd>
</dl>

<p class="algo-head">
`被support ~prop名$は、次の手続きが返す値たちの~listとする：
◎
The supported property names are the values from the list returned by these steps:
</p>

<ol>
	<li>
%結果 ~LET 空~list
◎
Let result be an empty list.
</li>
	<li>
<p>
~collectionで`表現-$される~EACH ( 要素 %要素 ) に対し，`木~順序$で：
◎
For each element represented by the collection, in tree order:
</p>


		<ol>
			<li>
~IF［
%要素 は `~ID$ %id を持つ
］~AND［
%id ~NIN %結果
］
⇒
%id を %結果 に付加する
◎
If element has an ID which is not in result, append element’s ID to result.
</li>
			<li>
<p>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 は `name^A `属性o$nmを`有する$
］：
</p>
				<ol>
					<li>
%名前 ~LET その `name^A `属性o$nmの値
</li>
					<li>
~IF［
%名前 ~NEQ 空~文字列
］~AND［
%名前 ~NIN %結果
］
⇒
%名前 を %結果 に付加する
</li>
				</ol>
◎
If element is in the HTML namespace and has a name attribute whose value is neither the empty string nor is in result, append element’s name attribute value to result.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<dl class="idl-def">
	<dt>@namedItem(name)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The namedItem(key) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
%name ~EQ 空~文字列
］
⇒
~RET ~NULL
◎
If key is the empty string, return null.
</li>
			<li>
<p>
~RET
此れの中の，次のいずれかを満たす`要素$のうち，`最初0$のもの
◎
Return the first element in the collection for which at least one of the following is true:
</p>

				<ul>
					<li>
要素の`~ID$ ~EQ %name
◎
it has an ID which is key;
</li>
					<li>
［
要素は`~HTML~ns$に属する
］~AND［
要素は［ `値$a ~EQ %name ］なる `name^A `属性o$nmを`有する$
］
◎
it is in the HTML namespace and has a name attribute whose value is key;
◎
or null if there is no such element.
</li>
				</ul>
			</li>
		</ol>
	</dd>
</dl>

				</section>
			</section>
		</section>
		<section id="mutation-observers">
<h3 title="Mutation observers">4.3. 変異~ob</h3>

<div class="p">
<p>
各 `互いに関係するかつ生成元も類似する閲覧文脈~群$ `HTML$r
— 以下，この節では単に 
`閲覧文脈~群@V
と記す —
には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`変異~ob 複合~極小task待入済み@f</dt>
	<dd>
~flag値
— 初期~時は ~OFF とする。
</dd>

	<dt>`変異~ob 通知-~list@</dt>
	<dd>
$MutationObserver ~objの~list
— 初期~時は空とする。
</dd>
	<dd class="trans-note">【
この項は、定義を明確化するため，この訳に導入した非公式な用語である。
】</dd>
</dl>

◎
Each unit of related similar-origin browsing contexts has a mutation observer compound microtask queued flag, which is initially unset, and an associated list of MutationObserver objects, which is initially empty. [HTML]
</div>


<p class="algo-head">
`変異~ob 複合~極小taskを待入する@
ときは、次を走らす：
◎
To queue a mutation observer compound microtask, run these steps:
</p>

<ol>
	<li>
~IF［
`変異~ob 複合~極小task待入済み$f ~EQ ~ON
］
⇒
~RET
◎
If mutation observer compound microtask queued flag is set, then return.
</li>
	<li>
`変異~ob 複合~極小task待入済み$f ~SET ~ON
◎
Set mutation observer compound microtask queued flag.
</li>
	<li>
`変異~obに通知する$ための
<a href="~WAPI#compound-microtask">複合~極小task</a>
を
<a href="~WAPI#queue-a-microtask">待入する</a>
◎
Queue a compound microtask to notify mutation observers.
</li>
</ol>


<p class="algo-head">
`変異~obに通知する@
ときは、次を走らす：
◎
To notify mutation observers, run these steps:
</p>

<ol>
	<li>
`変異~ob 複合~極小task待入済み$f ← ~OFF
◎
Unset mutation observer compound microtask queued flag.
</li>
	<li>
%通知-~list ~LET `変異~ob 通知-~list$の複製
◎
Let notify list be a copy of unit of related similar-origin browsing contexts' list of MutationObserver objects.
</li>
	<li>
%通達~slot~list ~LET
`閲覧文脈~群$V の`通達~slot~list$の複製
◎
Let signalList be a copy of unit of related similar-origin browsing contexts' signal slot list.
</li>
	<li>
`閲覧文脈~群$V の`通達~slot~list$を空にする
◎
Empty unit of related similar-origin browsing contexts' signal slot list.
</li>
	<li>
		<p>
%通知-~list 内の~EACH ( $MutationObserver ~obj %MO ) に対し
⇒
次の手続きを走らす
<a href="~WAPI#execute-a-compound-microtask-subtask">複合~極小task下位~taskを実行する</a>
`HTML$r
：
◎
For each MutationObserver object mo in notify list, execute a compound microtask subtask to run these steps: [HTML]
</p>

		<ol>
			<li>
%待行列 ~LET %MO の`記録待行列$の複製
◎
Let queue be a copy of mo’s record queue.
</li>
			<li>
%MO の`記録待行列$を空にする
◎
Empty mo’s record queue.
</li>
			<li>
［
`observer^i ~EQ %MO
］なる
`一時~登録済み~ob$ をすべて除去する
<!-- どこから？ -->
◎
Remove all transient registered observers whose observer is mo.
</li>
			<li>
<p >
~IF［
%待行列 は空でない
］：
</p>

				<ol>
					<li>
<p>
次を与える下で，`~callback関数を呼出す$：
</p>

<ul ><li>~callback関数~型の値： %MO の`~callback$mo
</li><li>引数~list： « %待行列,  %MO »
</li><li>`~callback this 値$： %MO
</li></ul>

					</li>
					<li>
前~段で例外が投出されたときは、~catchして
⇒
`その例外を報告する$
</li>
				</ol>

◎
If queue is non-empty, invoke mo’s callback with a list of arguments consisting of queue and mo, and mo as the callback this value. If this throws an exception, report the exception.
</li>
		</ol>
	</li>
	<li>
%通達~slot~list 内の
~EACH ( `~slot$ %~slot ) に対し，順に
⇒
%~slot に向けて，名前 `slotchange^et の~eventを［
$Event.bubbles 属性 ~SET ~T
］にした上で`発火-$する
◎
For each slot slot in signalList, in order, fire an event named slotchange, with its bubbles attribute set to true, at slot.
</li>
</ol>

<hr>

<div class="p">
<p>
各 `~node$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~ob~list@</dt>
	<dd>
0 個~以上の`登録済み~ob$からなる~list。
</dd>
	<dd>
`すなわち、この~nodeにおける変異を観測している~obたち。^tnote
</dd>
</dl>
◎
Each node has an associated list of registered observers.
</div>

<div class="p">
<p>
各
`登録済み~ob@
は、次のものからなる：
</p>

<dl class="def-list">
	<dt>`observer^i</dt>
	<dd>
$MutationObserver ~obj。
</dd>

	<dt>`options^i</dt>
	<dd>
$MutationObserverInit 辞書。
</dd>
</dl>

<p>
`一時~登録済み~ob@
とは、上述に加えて 次のものも持つ，`登録済み~ob$の一種である：
</p>

<dl class="def-list">
	<dt>`source^i</dt>
	<dd>
`登録済み~ob$。
</dd>
</dl>

◎
A registered observer consists of an observer (a MutationObserver object) and options (a MutationObserverInit dictionary). A transient registered observer is a specific type of registered observer that has a source which is a registered observer.
</div>

<p class="note">注記：
`一時~登録済み~ob$は、所与の`~node$に対し，それが除去された後も`~node$の`子孫$における変異を追跡するために利用される
— これにより、`~node$の`親$にて ^subtree が ~T に設定されているときでも，それらの変異は失われずに済む。
◎
Transient registered observers are used to track mutations within a given node’s descendants after node has been removed so they do not get lost when subtree is set to true on node’s parent.
</p>
			<section id="interface-mutationobserver">
<h4>4.3.1. ~ifc ^@MutationObserver</h4>

⇒！
[$Constructor($MutationCallback %callback),
 `Exposed$=Window]
interface @MutationObserver {
  void $observe($Node %target, optional $MutationObserverInit %options);
  void $disconnect();
  sequence&lt;$MutationRecord&gt; $takeRecords();
};

callback @MutationCallback = void (sequence&lt;$MutationRecord&gt; %mutations, $MutationObserver %observer);

dictionary @MutationObserverInit {
  ~B @MutationObserverInit.childList = false;
  ~B @MutationObserverInit.attributes;
  ~B @MutationObserverInit.characterData;
  ~B @MutationObserverInit.subtree = false;
  ~B @MutationObserverInit.attributeOldValue;
  ~B @MutationObserverInit.characterDataOldValue;
  sequence&lt;~DS&gt; @MutationObserverInit.attributeFilter;
};
◎

<!-- MutationObserver^I -->
<p>
$MutationObserver ~objを利用すれば、`~node$が成す`木$における変異を観測できる。
◎
A MutationObserver object can be used to observe mutations to the tree of nodes.
</p>

<p>
各 $MutationObserver ~objには、次の概念が結付けられる： 
◎
Each MutationObserver object has these associated concepts:
</p>

<dl class="def-list">
	<dt>`~callback@mo</dt>
	<dd>
~callback関数。
~objの作成-時に設定される。
◎
A callback set on creation.
</dd>

	<dt>`観測している~node~list@</dt>
	<dd>
次の条件を満たす`~node$からなる~list
— 初期~時は空とする
⇒
その~nodeの`~ob~list$の中に，この~objを `observer^i に持つような`登録済み~ob$が在る。
◎
A list of nodes on which it is a registered observer’s observer that is initially empty.
</dd>

	<dt>`記録待行列@</dt>
	<dd>
$MutationRecord ~objの~list
— 初期~時は空とする。
◎
A list of MutationRecord objects called the record queue that is initially empty.
</dd>
</dl>



<dl class="domintro">
	<dt>var %observer = new $MutationObserver(callback)</dt>
	<dd>
$MutationObserver ~objを構築し，その
`~callback$moを %callback にする。
%callback が呼出されるときは、その 1 〜 2 個目の引数に
( $MutationRecord ~objの~list, 構築された $MutationObserver ~obj )
が渡される。
%callback は、 $observe() ~methにより登録済みにされた`~node$が変異したとき（した後）に，呼出される。
◎
Constructs a MutationObserver object and sets its callback to callback. The callback is invoked with a list of MutationRecord objects as first argument and the constructed MutationObserver object as second argument. It is invoked after nodes registered with the observe() method, are mutated.
</dd>

	<dt>%observer . $observe(target, options)</dt>
	<dd>
%target （ `~node$ ）を観測して，
%options （ ~obj）に与えた判定基準に基づいて変異を報告するように、~UA に~~指示する。
◎
Instructs the user agent to observe a given target (a node) and report any mutations based on the criteria given by options (an object).
</dd>
	<dd>
<p>
%options 引数により、 ~obj~memberを通して，観測させる変異についての~optionを設定できる。
利用できる~obj~memberは：
◎
The options argument allows for setting mutation observation options via object members. These are the object members that can be used:
</p>
		<dl>
			<dt>$MutationObserverInit.childList</dt>
			<dd>
%target の`子$の変異を観測するときは ~T にする。
◎
Set to true if mutations to target’s children are to be observed.
</dd>

			<dt>$MutationObserverInit.attributes</dt>
			<dd>
%target の`属性o$の変異を観測するときは ~T にする。
$MutationObserverInit.attributeOldValue または $MutationObserverInit.attributeFilter を指定している場合は、省略できる。
◎
Set to true if mutations to target’s attributes are to be observed. Can be omitted if attributeOldValue and/or attributeFilter is specified.
</dd>

			<dt>$MutationObserverInit.characterData</dt>
			<dd>
%target の`~data$の変異を観測するときは ~T にする。
$MutationObserverInit.characterDataOldValue を指定している場合は、省略できる。
◎
Set to true if mutations to target’s data are to be observed. Can be omitted if characterDataOldValue is specified.
</dd>

			<dt>$MutationObserverInit.subtree</dt>
			<dd>
%target のみならず，
%target の`子孫$の変異も観測するときは ~T にする。
◎
Set to true if mutations to not just target, but also target’s descendants are to be observed.
</dd>

			<dt>$MutationObserverInit.attributeOldValue</dt>
			<dd>
$MutationObserverInit.attributes を~T にしているか省略していて，かつ
変異~前の %target の`属性o$ `値$aを記録しておく必要がある場合は ~T にする。
◎
Set to true if attributes is true or omitted and target’s attribute value before the mutation needs to be recorded.
</dd>

			<dt>$MutationObserverInit.characterDataOldValue</dt>
			<dd>
$MutationObserverInit.characterData を~T にしているか省略していて，かつ
変異~前の %target の`~data$を記録しておく必要がある場合は ~T にする。
◎
Set to true if characterData is set to true or omitted and target’s data before the mutation needs to be recorded.
</dd>

			<dt>$MutationObserverInit.attributeFilter</dt>
			<dd>
$MutationObserverInit.attributes を~T にしているか省略していて，かつ
すべての`属性o$の変異を観測する必要はない場合は，必要な`属性o$の（`~ns$a のない）`局所~名$aの~listにする。
◎
Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted.
</dd>

		</dl>
	</dd>

	<dt>%observer . $disconnect()</dt>
	<dd>
%observer による変異の観測を停止する。
$observe() ~methが再び用いられるまで，
%observer の`~callback$moは呼出されないことになる。
◎
Stops observer from observing any mutations. Until the observe() method is used again, observer’s callback will not be invoked.
</dd>


	<dt>%observer . $takeRecords()</dt>
	<dd>
`記録待行列$を空にして，空にする前の内容を返す。
◎
Empties the record queue and returns what was in there.
</dd>

</dl>

<dl class="idl-def">
	<dt>@MutationObserver(callback)</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
The MutationObserver(callback) constructor must\
</p>

		<ol>
			<li>
%observer ~LET ［
`~callback$mo ~SET %callback
］にされた，新たな $MutationObserver ~obj
◎
create a new MutationObserver object with callback set to callback,＼
</li>
			<li>
`変異~ob 通知-~list$に %observer を付加する
◎
append it to the unit of related similar-origin browsing contexts' list of MutationObserver objects, and then＼
</li>
			<li>
~RET %observer
◎
return it.
</li>
		</ol>
	</dd>

	<dt>@observe(target, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The observe(target, options) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
<p>
~IF［［
%options の $MutationObserverInit.attributeOldValue は在する
］~OR［
%options の $MutationObserverInit.attributeFilter は在する
］］~AND［
%options の $MutationObserverInit.attributes は不在
］
⇒
%options の $MutationObserverInit.attributes ~SET ~T
</p>

<p class="trans-note">【
在する（ is present ）, 不在（ is omitted ）
—
<a href="~WEBIDL#dfn-present">present / not present</a>
（ Web IDL ）
】</p>

◎
If either options’ attributeOldValue or attributeFilter is present and options’ attributes is omitted, set options’ attributes to true.
</li>
			<li>
~IF［
%options の $MutationObserverInit.characterDataOldValue は在する
］~AND［
%options の $MutationObserverInit.characterData は不在
］
⇒
%options の $MutationObserverInit.characterData ~SET ~T
◎
If options’ characterDataOldValue is present and options’ characterData is omitted, set options’ characterData to true.
</li>
			<li>
<p>
~IF［
%options の~memberたちについて，次のいずれかが満たされる
］
⇒
~THROW `TypeError$E ：
◎
↓</p>

				<ul>
					<li>
［
$MutationObserverInit.childList ~EQ ~F
］~AND［
$MutationObserverInit.attributes ~EQ ~F
］~AND［
$MutationObserverInit.characterData ~EQ ~F
］
◎
If none of options’ childList, attributes, and characterData is true, throw a TypeError.
</li>
					<li>
［
$MutationObserverInit.attributeOldValue ~EQ ~T
］~AND［
$MutationObserverInit.attributes ~EQ ~F
］
◎
If options’ attributeOldValue is true and options’ attributes is false, throw a TypeError.
</li>
					<li>
［
$MutationObserverInit.attributeFilter は在する
］~AND［
$MutationObserverInit.attributes ~EQ ~F
］
◎
If options’ attributeFilter is present and options’ attributes is false, throw a TypeError.
</li>
					<li>
［
$MutationObserverInit.characterDataOldValue ~EQ ~T
］~AND［
$MutationObserverInit.characterData ~EQ ~F
］
◎
If options’ characterDataOldValue is true and options’ characterData is false, throw a TypeError.
</li>
				</ul>
			</li>
			<li>
%~ob~list ~LET %target の`~ob~list$
◎
↓</li>
			<li>
<p>
%~ob~list 内の~EACH ( `登録済み~ob$ %O ) に対し：
◎
For each registered observer registered in target’s list of registered observers＼
</p>

				<ol>
					<li>
~IF［
%O の `observer^i ~NEQ 此れ
］
⇒
~CONTINUE
◎
whose observer is the context object:
</li>
					<li>
%~ob~list 内から，次を満たす`一時~登録済み~ob$をすべて除去する
⇒
その `source^i ~EQ %O
◎
Remove all transient registered observers whose source is registered.
</li>
					<li>
%O の `options^i ~SET %options
◎
Replace registered’s options with options.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
<span class="trans-note">【
この ~ELSE がどの条件を指しているのか不明
— %~ob~list 内に［
`observer^i ~EQ 此れ
］なる `登録済み~ob$ が存在しない場合？
】</span>
：
◎
Otherwise,＼
</p>
				<ol>
					<li>
次のようにされた 新たな`登録済み~ob$を %~ob~list に追加する
⇒＃
`observer^i ~SET 此れ,
`options^i ~SET %options
◎
add a new registered observer to target’s list of registered observers with the context object as the observer and options as the options, and＼
</li>
					<li>
此れが`観測している~node~list$に %target を追加する
◎
add target to context object’s list of nodes on which it is registered.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>@disconnect()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The disconnect() method must,＼
</p>

		<ol>
			<li>
此れが`観測している~node~list$ 内の~EACH ( `~node$ %node ) に対し，順に
⇒
%node の`~ob~list$から，次を満たす`登録済み~ob$をすべて除去する
⇒
その `observer^i ~EQ 此れ
◎
for each node node in the context object’s list of nodes, remove any registered observer on node for which the context object is the observer, and＼
</li>
			<li>
此れの`記録待行列$を空にする
◎
also empty context object’s record queue.
</li>
		</ol>
	</dd>

	<dt>@takeRecords()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The takeRecords() method, when invoked,＼
</p>

		<ol>
			<li>
%結果 ~LET 此れの`記録待行列$の複製
◎
return a copy of the record queue and then＼
</li>
			<li>
此れの`記録待行列$を空にする
◎
empty the record queue.
</li>
			<li>
~RET %結果
◎
↑</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="queueing-a-mutation-record">
<h4 title="Queuing a mutation record">4.3.2. 変異~記録を待入する</h4>

<div class="p">

<p>
各種~algoが`変異~記録を待入する$ときに与える
`変異~記録@
は、次の名前の~fieldからなる：
</p>
<ul><li>~target （変異の観測-対象である`~node$）
</li><li>種別（ `childList^l, `attributes^l, `characterData^l のいずれか）
</li><li>名前（省略時は ε ）
</li><li>~ns（省略時は ε ）
</li><li>旧-値 （省略時は ε — 種別 ~IN { `attributes^l, `characterData^l } の場合は必須）
</li><li>追加済nodes（省略時は ε ）
</li><li>除去済nodes（省略時は ε ）
</li><li>兄（省略時は ε ）
</li><li>弟（省略時は ε ）
</li></ul>

<p class="algo-head">
`変異~記録を待入する@
ときは、所与の
( `変異~記録$ %記録 )
に対し，次を走らす：
</p>

◎
To queue a mutation record of type for target with one or more of (depends on type) name name, namespace namespace, oldValue oldValue, addedNodes addedNodes, removedNodes removedNodes, previousSibling previousSibling, and nextSibling nextSibling, run these steps:
</div>

<ol>
	<li>
%target ~LET %記録 の~target
◎
↑</li>
	<li>
%type ~LET %記録 の種別
◎
↑</li>
	<li>
%有関係~ob集合 ~LET 空~集合
⇒
$MutationObserver ~objの集合
⇒
この集合に付加される各~objには、
`旧-値@
が結付けられる
— 初期~時は ε とする。
◎
Let interested observers be an initially empty set of MutationObserver objects optionally paired with a string.
</li>
	<li>
%nodes ~LET %target のすべての`広義先祖$
◎
Let nodes be the inclusive ancestors of target.
</li>
	<li>
<p>
%nodes 内の~EACH ( %node ) に対し
`順序は？^tnote
⇒
%node の`~ob~list$ 内の~EACH ( %登録済み~ob ) に対し：
◎
For each node in nodes, and then for each registered observer (with registered observer’s options as options) in node’s list of registered observers:
</p>

		<ol>
			<li>
%options ~LET %登録済み~ob の `options^i
◎
↓</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~CONTINUE：
◎
If none of the following are true
</p>

				<ul>
					<li>
［
%node ~NEQ %target
］~AND［
%options の $MutationObserverInit.subtree ~EQ ~F
］
◎
node is not target and options’ subtree is false
</li>
					<li>
［
%type ~EQ `attributes^l
］~AND［
%options の $MutationObserverInit.attributes ~NEQ ~T
］
◎
type is "attributes" and options’ attributes is not true
</li>
					<li>
次のいずれも満たされる：

<ul ><li>%type ~EQ `attributes^l
</li><li>%options に $MutationObserverInit.attributeFilter は在する
</li><li>［
%記録 の名前 ~NIN %options の $MutationObserverInit.attributeFilter
］~OR［
%記録 の~ns ~NEQ ~NULL
］
</li></ul>
◎
type is "attributes", options’ attributeFilter is present, and options’ attributeFilter does not contain name or namespace is non-null
</li>
					<li>
［
%type ~EQ `characterData^l
］~AND［
%options の $MutationObserverInit.characterData ~NEQ ~T
］
◎
type is "characterData" and options’ characterData is not true
</li>
					<li>
［
%type ~EQ `childList^l
］~AND［
%options の ^childList ~EQ ~F
］
◎
type is "childList" and options’ childList is false
</li>
				</ul>
			</li>
			<li>
%~ob ~LET %登録済み~ob の `observer^i
◎
↓</li>
			<li>
~IF［
%~ob ~NIN %有関係~ob集合
］
⇒
%~ob を %有関係~ob集合 に付加する
◎
If registered observer’s observer is not in interested observers, append registered observer’s observer to interested observers.
</li>
			<li>
~IF［
次のいずれかが満たされる
］…：

<ul ><li>［
%type ~EQ `attributes^l
］~AND［
%options の $MutationObserverInit.attributeOldValue ~EQ ~T
］
</li><li>［
%type ~EQ `characterData^l
］~AND［
%options の $MutationObserverInit.characterDataOldValue ~EQ ~T
］
</li></ul>

…ならば
⇒
%~ob の`旧-値$ ~SET %記録 の旧-値
◎
If either type is "attributes" and options’ attributeOldValue is true, or type is "characterData" and options’ characterDataOldValue is true, set the paired string of registered observer’s observer in interested observers to oldValue.
</li>
		</ol>
	</li>
	<li>

<p>
%有関係~ob集合 ~内の~EACH ( %~ob ) に対し：
◎
For each observer in interested observers:
</p>

<!-- ^@MutationRecord -->
		<ol>
			<li>
<p>
%R ~LET 新たな $MutationRecord ~obj 
— %R の各種~属性を以下に従って設定する：
◎
Let record be a new MutationRecord object with＼
</p>

				<ol>
					<li>
$type ~SET %type
◎
its type set to type and＼
</li>
					<li>
$target ~SET %target
◎
target set to target.
</li>
					<li>
~IF［
%記録 の名前 ~NEQ ε
］~AND［
%記録 の~ns ~NEQ ε
］
⇒＃
$attributeName ~SET %記録 の名前；
$attributeNamespace ~SET %記録 の~ns
◎
If name and namespace are given, set record’s attributeName to name, and record’s attributeNamespace to namespace.
</li>
					<li>
~IF［
%記録 の追加済nodes ~NEQ ε
］
⇒
$addedNodes ~SET %記録 の追加済nodes
◎
If addedNodes is given, set record’s addedNodes to addedNodes.
</li>
					<li>
~IF［
%記録 の除去済nodes ~NEQ ε
］
⇒
$removedNodes ~SET %記録 の除去済nodes
◎
If removedNodes is given, set record’s removedNodes to removedNodes,
</li>
					<li>
~IF［
%記録 の兄  ~NEQ ε
］
⇒
$previousSibling ~SET %記録 の兄
◎
If previousSibling is given, set record’s previousSibling to previousSibling.
</li>
					<li>
~IF［
%記録 の弟 ~NEQ ε
］
⇒
$nextSibling ~SET %記録 の弟
◎
If nextSibling is given, set record’s nextSibling to nextSibling.
</li>
					<li>
~IF［
%~ob の`旧-値$ ~NEQ ε
］
⇒
$oldValue ~SET %~ob の`旧-値$
◎
If observer has a paired string, set record’s oldValue to observer’s paired string.
</li>
				</ol>
			</li>
			<li>
%R を %~ob の`記録待行列$に付加する
◎
Append record to observer’s record queue.
</li>
		</ol>
	</li>
	<li>
`変異~ob 複合~極小taskを待入する$
◎
Queue a mutation observer compound microtask.
</li>
</ol>

			</section>
			<section id="interface-mutationrecord">
<h4>4.3.3. ~ifc ^@MutationRecord</h4>


⇒！
[`Exposed$=Window]
interface @MutationRecord {
  ~RA ~DS $type;
  [`SameObject$] ~RA $Node $target;
  [`SameObject$] ~RA $NodeList $addedNodes;
  [`SameObject$] ~RA $NodeList $removedNodes;
  ~RA $Node? $previousSibling;
  ~RA $Node? $nextSibling;
  ~RA ~DS? $attributeName;
  ~RA ~DS? $attributeNamespace;
  ~RA ~DS? $oldValue;
};
◎

<dl class="domintro">
	<dt>%record . $type</dt>
	<dd>
変異の種類に応じて，次を返す
⇒＃
`属性o$に対する変異であった場合は `attributes^l,
$CharacterData `~node$に対する 変異であった場合は `characterData^l,
`~node$が成す`木$に対する変異であった場合は `childList^l
◎
Returns "attributes" if it was an attribute mutation. "characterData" if it was a mutation to a CharacterData node. And "childList" if it was a mutation to the tree of nodes.
</dd>

	<dt>%record . $target</dt>
	<dd>
変異に影響された`~node$を返す — $type に応じて
⇒＃
`attributes^l に対しては，`属性o$が変化した`要素$。
`characterData^l に対しては，$CharacterData `~node$。
`childList^l に対しては，`子$の~listが変化した`~node$。
◎
Returns the node the mutation affected, depending on the type. For "attributes", it is the element whose attribute changed. For "characterData", it is the CharacterData node. For "childList", it is the node whose children changed.
</dd>

	<dt>%record . $addedNodes</dt>
	<dt>%record . $removedNodes</dt>
	<dd>
順に、［
追加-, 除去-
］された`~node$の~listを返す。
◎
Return the nodes added and removed respectively.
</dd>

	<dt>%record . $previousSibling</dt>
	<dt>%record . $nextSibling</dt>
	<dd>
順に、追加-または除去された`~node$が在れば その［
`兄$, `弟$
］を,
無ければ ~NULL を返す。
◎
Return the previous and next sibling respectively of the added or removed nodes, and null otherwise.
</dd>

	<dt>%record . $attributeName</dt>
	<dd>
変化した`属性o$が在れば その`局所~名$aを,
無ければ ~NULL を返す。
◎
Returns the local name of the changed attribute, and null otherwise.
</dd>

	<dt>%record . $attributeNamespace</dt>
	<dd>
変化した`属性o$が在れば その`~ns$を,
無ければ ~NULL を返す。
◎
Returns the namespace of the changed attribute, and null otherwise.
</dd>

	<dt>%record . $oldValue</dt>
	<dd>
$type に応じて，次の値を返す
⇒＃
`attributes^l に対しては，変化した`属性o$の変化~前の`値$a。
`characterData^l に対しては，変化した`~node$の変化~前の`~data$。
`childList^l に対しては， ~NULL 。
◎
The return value depends on type. For "attributes", it is the value of the changed attribute before the change. For "characterData", it is the data of the changed node before the change. For "childList", it is null.
</dd>

</dl>

<dl class="idl-def">
	<dt>@type</dt>
	<dt>@target</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化-時の値を返さ~MUST。 
◎
The type and target attributes must return the values they were initialized to.
</dd>

	<dt>@addedNodes</dt>
	<dt>@removedNodes</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化-時の値を返さ~MUST。
他が定められない限り、
$MutationRecord ~objの作成-時には，いずれも空の $NodeList に初期化されなければならない。
◎
The addedNodes and removedNodes attributes must return the values they were initialized to. Unless stated otherwise, when a MutationRecord object is created, they must both be initialized to an empty NodeList.
</dd>

	<dt>@previousSibling</dt>
	<dt>@nextSibling</dt>
	<dt>@attributeName</dt>
	<dt>@attributeNamespace</dt>
	<dt>@oldValue</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化-時の値を返さ~MUST。
他が定められない限り、
$MutationRecord ~objの作成-時には，いずれも~NULL に初期化されなければならない。
◎
The previousSibling, nextSibling, attributeName, attributeNamespace, and oldValue attributes must return the values they were initialized to. Unless stated otherwise, when a MutationRecord object is created, they must be initialized to null.
</dd>
</dl>

			</section>
			<section id="garbage-collection">
<h4 title="Garbage collection">4.3.4. ~garbage-collection</h4>

<p>
`~node$は、［
その`~ob~list$に含まれる各`登録済み~ob$
］への強い参照を持つ。
◎
Nodes have a strong reference to registered observers in their list of registered observers.
</p>

<p>
［
`~node$の`~ob~list$に含まれる各`登録済み~ob$
］は、その`~node$への弱い参照を持つ。
◎
Registered observers in a node’s list of registered observers have a weak reference to the node.
</p>

			</section>
		</section>
		<section id="interface-node">
<h3>4.4. ~ifc ^@Node</h3>

⇒！
[`Exposed$=Window]
interface @Node : $EventTarget {
  ~CUS $ELEMENT_NODE = 1;
  ~CUS $ATTRIBUTE_NODE = 2;
  ~CUS $TEXT_NODE = 3;
  ~CUS $CDATA_SECTION_NODE = 4;
  ~CUS @ENTITY_REFERENCE_NODE = 5; // <!--cp-histroic-->
  ~CUS @ENTITY_NODE = 6; // <!--cp-histroic-->
  ~CUS $PROCESSING_INSTRUCTION_NODE = 7;
  ~CUS $COMMENT_NODE = 8;
  ~CUS $DOCUMENT_NODE = 9;
  ~CUS $DOCUMENT_TYPE_NODE = 10;
  ~CUS $DOCUMENT_FRAGMENT_NODE = 11;
  ~CUS @NOTATION_NODE = 12; // <!--cp-histroic-->
  ~RA ~US $nodeType;<!-- NodeExodus

  ~ RA ~ DS N.namespaceURI;
  ~ RA ~ DS N.prefix;
  ~ RA ~ DS N.localName;-->
  ~RA ~DS $nodeName;

  ~RA USVString $baseURI;

  ~RA ~B $isConnected;
  ~RA $Document? $ownerDocument;
  $Node $getRootNode(optional $GetRootNodeOptions %options);
  ~RA $Node? $parentNode;
  ~RA $Element? $parentElement;
  ~B $hasChildNodes();
  [`SameObject$] ~RA $NodeList $childNodes;
  ~RA $Node? $firstChild;
  ~RA $Node? $lastChild;
  ~RA $Node? $previousSibling;
  ~RA $Node? $nextSibling;

  [`CEReactions$] attribute ~DS? $nodeValue;
  [`CEReactions$] attribute ~DS? $textContent;
  [`CEReactions$] void $normalize();

  [`CEReactions$ `NewObject$] $Node $cloneNode(optional ~B %deep = false);
  ~B $isEqualNode($Node? %otherNode);
  ~B $isSameNode($Node? %otherNode); // <span class="comment" title="historical alias of ==="
  > `===^c 演算子の歴史上の別名</span>

  ~CUS $DOCUMENT_POSITION_DISCONNECTED = 0x01;
  ~CUS $DOCUMENT_POSITION_PRECEDING = 0x02;
  ~CUS $DOCUMENT_POSITION_FOLLOWING = 0x04;
  ~CUS $DOCUMENT_POSITION_CONTAINS = 0x08;
  ~CUS $DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  ~CUS $DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  ~US $compareDocumentPosition($Node %other);
  ~B $contains($Node? %other);

  ~DS? $lookupPrefix(~DS? %namespace);
  ~DS? $lookupNamespaceURI(~DS? %prefix);
  ~B $isDefaultNamespace(~DS? %namespace);

  [`CEReactions$] $Node $insertBefore($Node %node, $Node? %child);
  [`CEReactions$] $Node $appendChild($Node %node);
  [`CEReactions$] $Node $replaceChild($Node %node, $Node %child);
  [`CEReactions$] $Node $removeChild($Node %child);
};

dictionary @@GetRootNodeOptions {
  boolean @composed = false;
};
◎

<p class="note">注記：
$@Node は抽象~ifcであり，`~node$として存在することはない。
それは、すべての`~node$（
$Document,
$DocumentType,
$DocumentFragment,
$Element,
$Text,
$ProcessingInstruction,
$Comment
）から利用される。
◎
Node is an abstract interface and does not exist as node. It is used by all nodes (Document, DocumentType, DocumentFragment, Element, Text, ProcessingInstruction, and Comment).
</p>

<p class="trans-note">【
2016 年 8 月の仕様~変更により、 $Attr も $Node を継承するようにされたが、
$Attr ~objは`~node$には含められない（木に`関与-$しない）。
】</p>

<div class="p">
<p>
各 `~node$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~node文書@</dt>
	<dd>
`文書$。
作成-時に設定される。
</dd>
</dl>
◎
Each node has an associated node document, set upon creation, that is a document.
</div>


<p class="note">注記：
`~node$の`~node文書$は、`受入-$する~algoにより変更され得る。
◎
A node’s node document can be changed by the adopt algorithm.
</p>

<p class="trans-note">【
~nodeが`文書~木~内$になくても，結付けられることになる。
】</p>

<p class="algo-head">
`~node$ %node の`親~targetを取得する$ときは、［
%node の`割当先~slot$ ~NEQ ~NULL ならば それ ／
~ELSE_ %node の`親$
］を返す。
◎
A node’s get the parent algorithm, given an event, returns the node’s assigned slot, if node is assigned, and node’s parent otherwise.
</p>

<p class="trans-note">【
`文書$は、~nodeの`親~targetを取得する$~algoを上書きする。
】</p>

<hr>

<dl class="domintro">
	<dt>%node . $nodeType</dt>
	<dd>
<p>
次に挙げる数で表現される,
%node の型を返す：
◎
Returns the type of node, represented by a number from the following list:
</p>

		<dl>
			<dt>$Node . $ELEMENT_NODE `(1)^i</dt>
			<dd>
%node は`要素$である。
◎
node is an element.
</dd>

			<dt>$Node . $TEXT_NODE `(3)^i</dt>
			<dd>
%node は $Text `~node$である。
◎
node is a Text node.
</dd>

			<dt>$Node . $CDATA_SECTION_NODE `(4)^i</dt>
			<dd>
%node は $CDATASection `~node$である。
◎
node is a CDATASection node.
</dd>

			<dt>$Node . $PROCESSING_INSTRUCTION_NODE `(7)^i</dt>
			<dd>
%node は $ProcessingInstruction `~node$である。
◎
node is a ProcessingInstruction node.
</dd>

			<dt>$Node . $COMMENT_NODE `(8)^i</dt>
			<dd>
%node は $Comment `~node$である。
◎
node is a Comment node.
</dd>

			<dt>$Node . $DOCUMENT_NODE `(9)^i</dt>
			<dd>
%node は`文書$である。
◎
node is a document.
</dd>

			<dt>$Node . $DOCUMENT_TYPE_NODE `(10)^i</dt>
			<dd>
%node は`~doctype$である。
◎
node is a doctype.
</dd>

			<dt>$Node . $DOCUMENT_FRAGMENT_NODE `(11)^i</dt>
			<dd>
%node は`文書片$である。
◎
node is a DocumentFragment node.
</dd>
		</dl>
	</dd>

	<dt>%node . $nodeName</dt>
	<dd>
<p>
%node の型に応じて，次の文字列を返す：
◎
Returns a string appropriate for the type of node, as follows:
</p>
		<dl>
			<dt>$Element</dt>
			<dd>
その $Element.tagName 属性~値
◎
Its tagName attribute value.
</dd>

			<dt>$Attr</dt>
			<dd>
その `有修飾~名$a
◎
Its qualified name.
</dd>

			<dt>$Text</dt>
			<dd>
`#text^l
◎
"#text".
</dd>

			<dt>$CDATASection</dt>
			<dd>
`#cdata-section^l
◎
"#cdata-section".
</dd>

			<dt>$ProcessingInstruction</dt>
			<dd>
その $target
◎
Its target.
</dd>

			<dt>$Comment</dt>
			<dd>
`#comment^l
◎
"#comment".
</dd>

			<dt>$Document</dt>
			<dd>
`#document^l
◎
"#document".
</dd>

			<dt>$DocumentType</dt>
			<dd>
その`名前$dT
◎
Its name.
</dd>

			<dt>$DocumentFragment</dt>
			<dd>
`#document-fragment^l
◎
"#document-fragment".
</dd>
		</dl>
	</dd>
</dl>

<dl class="idl-def">
	<dt>@nodeType</dt>
	<dd>
<p>
取得子は、此れの型に応じて，次を返さ~MUST（括弧内は数値）：
◎
The nodeType attribute’s getter, when invoked, must return the first matching statement, switching on the context object:
</p>


<dl class="switch"><dt>$Element
</dt><dd>@ELEMENT_NODE (1)

</dd><dt>$Attr
</dt><dd>@ATTRIBUTE_NODE (2)

</dd><dt>$Text
</dt><dd>@TEXT_NODE (3)

</dd><dt>$CDATASection
</dt><dd>@CDATA_SECTION_NODE (4)

</dd><dt>$ProcessingInstruction
</dt><dd>@PROCESSING_INSTRUCTION_NODE (7)

</dd><dt>$Comment
</dt><dd>@COMMENT_NODE (8)

</dd><dt>$Document
</dt><dd>@DOCUMENT_NODE (9)

</dd><dt>$DocumentType
</dt><dd>@DOCUMENT_TYPE_NODE (10)

</dd><dt>$DocumentFragment
</dt><dd>@DOCUMENT_FRAGMENT_NODE (11)

</dd></dl>

	<dt>@nodeName</dt>
	<dd>
<p>
取得子は、此れの型に応じて，次を返さ~MUST：
◎
The nodeName attribute’s getter, when invoked, must return the first matching statement, switching on the context object:
</p>
<!-- copy* -->
<dl class="switch">
	<dt>$Element</dt>
	<dd>
此れの $Element.tagName 属性~値
◎
Its tagName attribute value.
</dd>

	<dt>$Attr</dt>
	<dd>
此れの`有修飾~名$a
◎
Its qualified name.
</dd>

	<dt>$Text</dt>
	<dd>
`#text^l
◎
"#text".
</dd>

	<dt>$CDATASection</dt>
	<dd>
`#cdata-section^l
◎
"#cdata-section".
</dd>

	<dt>$ProcessingInstruction</dt>
	<dd>
此れの`~target$
◎
Its target.
</dd>

	<dt>$Comment</dt>
	<dd>
`#comment^l
◎
"#comment".
</dd>

	<dt>$Document</dt>
	<dd>
`#document^l
◎
"#document".
</dd>

	<dt>$DocumentType</dt>
	<dd>
此れの`名前$dT
◎
Its name.
</dd>

	<dt>$DocumentFragment</dt>
	<dd>
`#document-fragment^l
◎
"#document-fragment".
</dd>
</dl>

	</dd>
</dl>


<dl class="domintro">
	<dt>%node . $baseURI</dt>
	<dd>
%node の`~node文書$の`文書~基底~URL$を返す。
◎
Returns node’s node document’s document base URL.
</dd>

</dl>

<dl class="idl-def">
	<dt>@baseURI</dt>
	<dd>
取得子は、次を走らせた結果を返さ~MUST
⇒
`~URLを直列化する$( 此れの`~node文書$の`文書~基底~URL$ )
◎
The baseURI attribute’s getter must return node document’s document base URL, serialized.
</dd>
</dl>


<dl class="domintro">
	<dt>%node . $isConnected</dt>
	<dd>
［
%node は`接続されて$いるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if node is connected and false otherwise.
</dd>

	<dt>%node . $ownerDocument</dt>
	<dd>
`~node文書$を返す。
`文書$に対しては~NULL を返す。
◎
Returns the node document. Returns null for documents.
</dd>

	<dt>%node . $getRootNode()</dt>
	<dd>
%node の`根$を返す。
◎
Returns node’s root.
</dd>

	<dt>%node . $getRootNode({ composed:true })</dt>
	<dd>
%node の`~shadowも含む根$を返す。
◎
Returns node’s shadow-including root.
</dd>

	<dt>%node . $parentNode</dt>
	<dd>
`親$を返す。
◎
Returns the parent.
</dd>

	<dt>%node . $parentElement</dt>
	<dd>
`親~要素$を返す。
◎
Returns the parent element.
</dd>

	<dt>%node . $hasChildNodes()</dt>
	<dd>
%node が`子$を持っているかどうかを返す。
◎
Returns whether node has children.
</dd>

	<dt>%node . $childNodes</dt>
	<dd>
すべての`子$を返す。
◎
Returns the children.
</dd>

	<dt>%node . $firstChild</dt>
	<dd>
`最初0の子$を返す。
◎
Returns the first child.
</dd>

	<dt>%node . $lastChild</dt>
	<dd>
`最後0の子$を返す。
◎
Returns the last child.
</dd>

	<dt>%node . $previousSibling</dt>
	<dd>
`兄$を返す。
◎
Returns the previous sibling.
</dd>

	<dt>%node . $nextSibling</dt>
	<dd>
`弟$を返す。
◎
Returns the next sibling.
</dd>
</dl>

<dl class="idl-def">
	<dt>@isConnected</dt>
	<dd>
取得子は、［
此れは`接続されて$いるならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The isConnected attribute’s getter must return true, if context object is connected, and false otherwise.
</dd>

	<dt>@ownerDocument</dt>
	<dd>
取得子は、［
此れは`文書$である ならば ~NULL ／
~ELSE_ 此れの`~node文書$
］を返さ~MUST。
◎
The ownerDocument attribute’s getter must return null, if the context object is a document, and the context object’s node document otherwise.
</dd>
	<dd class="note">注記：
`文書$の`~node文書$は，`文書$ 自身である。
すべての`~node$は、どの時点であれ，`~node文書$を持つ。
◎
The node document of a document is that document itself. All nodes have a node document at all times.
</dd>

	<dt>@getRootNode(options)</dt>
	<dd>
被呼出時には、［［
%options の $GetRootNodeOptions.composed ~EQ ~T
］ならば 此れの`~shadowも含む根$ ／
~ELSE_ 此れの`根$
］を返さ~MUST。
◎
The getRootNode(options) method, when invoked, must return context object’s shadow-including root if options’s composed is true, and context object’s root otherwise.
</dd>

	<dt>@parentNode</dt>
	<dd>
取得子は、此れの`親$を返さ~MUST。
◎
The parentNode attribute’s getter must return the context object’s parent.
</dd>
	<dd class="note">注記：
$Attr `~node$には親はない。
◎
An Attr node has no parent.
</dd>

	<dt>@parentElement</dt>
	<dd>
取得子は、此れの`親~要素$を返さ~MUST。
◎
The parentElement attribute’s getter must return the context object’s parent element.
</dd>

	<dt>@hasChildNodes()</dt>
	<dd>
被呼出時には、［
此れは`子$を持つならば~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The hasChildNodes() method, when invoked, must return true if the context object has children, and false otherwise.
</dd>

	<dt>@childNodes</dt>
	<dd>
取得子は、次のようにされた $NodeList `~collection$を返さ~MUST
⇒＃
`根$cl ~SET 此れ,
`~filter$は 此れの`子$のみに合致する
◎
The childNodes attribute’s getter must return a NodeList rooted at the context object matching only children.
</dd>

	<dt>@firstChild</dt>
	<dd>
取得子は、此れの`最初0の子$を返さ~MUST。
◎
The firstChild attribute’s getter must return the context object’s first child.
</dd>

	<dt>@lastChild</dt>
	<dd>
取得子は、此れの`最後0の子$を返さ~MUST。
◎
The lastChild attribute’s getter must return the context object’s last child.
</dd>

	<dt>@previousSibling</dt>
	<dd>
取得子は、此れの`兄$を返さ~MUST。
◎
The previousSibling attribute’s getter must return the context object’s previous sibling.
</dd>
	<dd class="note">注記：
$Attr `~node$には`同胞$はない。
◎
An Attr node has no siblings.
</dd>

	<dt>@nextSibling</dt>
	<dd>
取得子は、此れの`弟$を返さ~MUST。
◎
The nextSibling attribute’s getter must return the context object’s next sibling.
</dd>

	<dt>@nodeValue</dt>
	<dd>
<p>
取得子は、此れの型に応じて，次を返さ~MUST：
</p>

		<dl class="switch">
			<dt>$Attr</dt>
			<dd>
此れの`値$a
◎
Context object’s value.
</dd>

			<dt>`文字~data~node$◎Text, ProcessingInstruction, Comment</dt>
			<dd>
此れの`~data$
◎
Context object’s data.
</dd>

			<dt>他の~node</dt>
			<dd>
~NULL
</dd>
		</dl>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The nodeValue attribute must, on setting,＼
</p>

		<ol>
			<li>
%値 ~LET ［
所与の値 ~NEQ ~NULL ならば それ ／
~ELSE_ 空~文字列
］
◎
if the new value is null, act as if it was the empty string instead, and then＼
</li>
			<li>
<p>
此れの型に応じて：
◎
do as described below, depending on the context object:
</p>

				<dl class="switch">
					<dt>$Attr</dt>
					<dd>
`既存の属性o値を設定する$( 此れ, %値 )
◎
Set an existing attribute value with context object and new value.
</dd>

					<dt>`文字~data~node$◎Text, ProcessingInstruction, Comment</dt>
					<dd>
此れの`~dataを置換する$( 0, 此れの`長さ$, %値 )
◎
Text, ProcessingInstruction, Comment
◎
Replace data with node context object, offset 0, count context object’s length, and data new value.
</dd>

					<dt>他の~node</dt>
					<dd>
何もしない
◎
Do nothing.
</dd>
				</dl>
			</li>
		</ol>
	</dd>

	<dt>@textContent</dt>
	<dd>
<p>
取得子は、此れの型に応じて，次を返さ~MUST：
◎
The textContent attribute’s getter must return the following, switching on context object:
</p>

		<dl class="switch">
			<dt>$DocumentFragment</dt>
			<dt>$Element</dt>
			<dd>
此れのすべての $Text `~node$`子孫$の`~data$を，`木~順序$で連結した結果
◎
The concatenation of data of all the Text node descendants of the context object, in tree order.
</dd>

			<dt>$Attr</dt>
			<dd>
此れの`値$a
◎
Context object’s value.
</dd>

			<dt>`文字~data~node$◎Text, ProcessingInstruction, Comment</dt>
			<dd>
此れの`~data$
◎
Context object’s data.
</dd>

<!-- 他の~node -->
			<dt>$Document</dt>
			<dt>$DocumentType</dt>
			<dd>
~NULL
◎
Null.
</dd>
		</dl>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The textContent attribute’s setter must,＼
</p>

		<ol>
			<li>
%値 ~LET ［
所与の値 ~NEQ ~NULL ならば それ ／
~ELSE_ 空~文字列
］
◎
if the given value is null, act as if it was the empty string instead, and then＼
</li>
			<li>
<p>
此れの型に応じて：
◎
do as described below, switching on context object:
</p>

				<dl class="switch">

					<dt>$DocumentFragment</dt>
					<dt>$Element</dt>
					<dd>
						<ol>
							<li>
%node ~LET ~NULL
◎
Let node be null.
</li>
							<li>
~IF［
%値 ~NEQ 空~文字列
］
⇒
%node ~SET `新たな~Text~node$( %値, 此れの`~node文書$ )
◎
If the given value is not the empty string, set node to a new Text node whose data is the given value and node document is context object’s node document.
</li>
							<li>
此れ の内容を %node で`すべて置換-$する
◎
Replace all with node within the context object.
</li>
						</ol>
					</dd>

					<dt>$Attr</dt>
					<dd>
`既存の属性o値を設定する$( 此れ, 所与の値 )
◎
Set an existing attribute value with context object and new value.
</dd>

					<dt>`文字~data~node$◎Text, ProcessingInstruction, Comment</dt>
					<dd>
此れの`~dataを置換する$( 0, 此れの`長さ$, %値 )
◎
Replace data with node context object, offset 0, count context object’s length, and data the given value.
</dd>

<!-- 他の~node -->
					<dt>$Document</dt>
					<dt>$DocumentType</dt>
					<dd>
何もしない
◎
Do nothing.
</dd>

				</dl>
			</li>
		</ol>
	</dd>
</dl>


<dl class="domintro">
	<dt>%node . $normalize()</dt>
	<dd>
%node に含まれている`空$の`狭義の~Text~node$は除去し、`連続的な狭義の~Text~node列$に対しては，その最初の`~node$に~~後続の`~data$を連結してひとまとめにする。
◎
Removes empty exclusive Text nodes and concatenates the data of remaining contiguous exclusive Text nodes into the first of their nodes.
</dd>
	<dd class="trans-note">【
この記述は、 “除去-” と “連結-” の順序に関し，微妙に正確でない
— 実際の~algoでは、空 ^Text ~nodeのうち，［
最初の~node %N が空でないような`連続的な狭義の~Text~node列$
］に含まれるものは、後続の空 ^Text ~nodeより先に %N に連結される（その結果として，除去されるが）。
<!-- 
結果の~node木は同じでも，変異の通知-順序は異なり得る。
 -->
】</dd>

</dl>


<dl class="idl-def">
	<dt>@normalize()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The normalize() method, when invoked, must run these steps for each descendant exclusive Text node node of context object:
</p>

		<ol>
			<li>
<p>
此れの`子孫$である~EACH ( `狭義の~Text~node$ %node ) に対し：
◎
Let node be the Text node descendant.
</p>

<p class="trans-note">【
木~順序で。
加えて，~~厳密に言えば、このループの中で木から除去される ^Text ~nodeは反復対象から除外する必要もある。
】</p>

				<ol>
					<li>
%長さ ~LET %node の`長さ$
◎
Let length be node’s length.
</li>
					<li>
%長さ ~EQ 0
⇒＃
%node をその親から`除去-$する；
~CONTINUE
◎
If length is zero, then remove node and continue with the next exclusive Text node, if any.
</li>
					<li>
%除去対象 ~LET %node を含む`連続的な狭義の~Text~node列$から %node 自身（常に先頭になる）は除外した結果の~list
◎
↓</li>
					<li>
%data ~LET %除去対象 内の~EACH ( %text ) の`~data$を順に連結した結果
◎
Let data be the concatenation of the data of node’s contiguous exclusive Text nodes (excluding itself), in tree order.
</li>
					<li>
%node の`~dataを置換する$( %長さ, 0, %data )
◎
Replace data with node node, offset length, count 0, and data data.
</li>
					<li>
<p>
%除去対象 内の~EACH ( %text ) に対し，順に：
◎
Let currentNode be node’s next sibling.
◎
While currentNode is an exclusive Text node:
</p>

						<ol>
							<li>
<p>
~EACH ( `範囲o$ %R ) に対し：
◎
↓</p>
								<ol>
									<li>
~IF［
%R の`始端~node$ ~EQ %text
］
⇒＃
%R の`始端~offset$ ~INCBY %長さ；
%R の`始端~node$ ~SET %node
◎
For each range whose start node is currentNode, add length to its start offset and set its start node to node.
</li>
									<li>
~IF［
%R の`終端~node$ ~EQ %text
］
⇒＃
%R の`終端~offset$ ~INCBY %長さ；
%R の`終端~node$ ~SET %node
◎
For each range whose end node is currentNode, add length to its end offset and set its end node to node.
</li>
									<li>
~IF［
%R の`始端~node$ ~EQ %text の`親$
］~AND［
%R の`始端~offset$ ~EQ %text の`指数$
］
⇒＃
%R の`始端~node$ ~SET %node；
%R の`始端~offset$ ~SET %長さ
◎
For each range whose start node is currentNode’s parent and start offset is currentNode’s index, set its start node to node and its start offset to length.
</li>
									<li>
~IF［
%R の`終端~node$ ~EQ %text の`親$
］~AND［
%R の`終端~offset$ ~EQ %text の`指数$
］
⇒＃
%R の`終端~node$ ~SET %node；
%R の`終端~offset$ ~SET %長さ
◎
For each range whose end node is currentNode’s parent and end offset is currentNode’s index, set its end node to node and its end offset to length.
</li>
								</ol>
							</li>
							<li>
%長さ ~INCBY %text の`長さ$
◎
Add currentNode’s length to length.
◎
Set currentNode to its next sibling.
</li>
						</ol>
					</li>
					<li>
%除去対象 内の~EACH ( %text ) に対し，順に
⇒
%text をその親から`除去-$する
◎
Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.
</li>
				</ol>
			</li>
		</ol>
	</dd>
	<dd class="note">注記：
$normalize() は`子~text内容~変更-時の手続き$を走らす必要はない。
それは $Text ~nodeたちを弄り倒すが，`子~text内容$は特に保全するように行うので。
◎
normalize() does not need to run any child text content change steps, since although it messes with Text nodes extensively, it does so specifically in a way that preserves the child text content.
</dd>
</dl>


<dl class="domintro">
	<dt>%node . $cloneNode([deep = false])</dt>
	<dd>
%node の複製を返す。
%deep が~T の場合、複製には %node の`子孫$も含められる。
◎
Returns a copy of node. If deep is true, the copy also includes the node’s descendants.
</dd>

	<dt>%node . $isEqualNode(otherNode)</dt>
	<dd>
%node と %otherNode が同じ~propを持つかどうかを返す。
◎
Returns whether node and otherNode have the same properties.
</dd>
</dl>


<p>
`適用仕様$は、すべてのまたは一部の`~node$に対し,
`~clone時の手続き@
を定義してもよい。
~algoには，`~clone$ ~algoにて指示される
( %複製, %node, %文書, `~clone子孫^f（省略時は ~OFF ） )
が渡される。
◎
Specifications may define cloning steps for all or some nodes. The algorithm is passed copy, node, document, and an optional clone children flag, as indicated in the clone algorithm.
</p>

<p class="note">注記：
~HTMLは
`script$e ／ `input$e
要素に対する`~clone時の手続き$を定義する。
~SVGもその `script^e 要素に対し同様にされるべきだが、現時点では，呼び出すことはない。
◎
HTML defines cloning steps for script and input elements. SVG ought to do the same for its script elements, but does not call this out at the moment.
</p>

<p class="trans-note">【
同じ~nodeに対し，そのような手続きが（例えば，複数の仕様にて）複数~定義された場合、それらを走らす順序も有意になり得るが，言及されていないので想定されていないと思われる。
】</p>

<div class="p">
<p class="algo-head">
%node を
`~clone@
するときは、次を走らす
— この手続きには、次も与えられ得る：
</p>

<ul ><li>%文書 （`文書$, 省略時は ε ）
</li><li>`~clone子孫^f （省略時は ~OFF ） 
</li></ul>

◎
To clone a node, with an optional document and clone children flag, run these steps:
</div>



<ol>
	<li>
~IF［
%文書 ~EQ ε
］
⇒
%文書 ~LET %node の`~node文書$
◎
If document is not given, let document be node’s node document.
</li>
	<li>
<p>
~IF［
%node は`要素$である
］：
◎
If node is an element, then:
</p>

		<ol>
			<li>
%値 ~LET ［
%node は `is^A `属性o$nmを有するならば その値 ／
~ELSE_ ~NULL
］
◎
↓</li>
			<li>
<p>
%複製 ~LET
`新たな要素$( %文書, %node の`局所~名$, %node の`~ns$, %node の`~ns接頭辞$, %値, %同期~custom要素~flag )
— ここで
⇒
%同期~custom要素~flag は ~OFF にするべきである
◎
Let copy be the result of creating an element, given document, node’s local name, node’s namespace, node’s namespace prefix, and the value of node’s is attribute if present (or null if not). The synchronous custom elements flag should be unset.
</li>
			<li>
%node の`属性o~list$内の~EACH ( %属性o ) に対し
⇒
［
%属性o を`~clone$した結果
］を %複製 に`付加-$する
◎
For each attribute in node’s attribute list:
• Let copyAttribute be a clone of attribute.
• Append copyAttribute to copy.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
⇒
%複製 ~LET  %node の型に応じて，次のように設定された［
%node と同じ~ifcを実装する新たな`~node$
］：
◎
Otherwise, let copy be a node that implements the same interfaces as node, and fulfills these additional requirements, switching on node:
</p>

		<dl class="switch">
			<dt>$Document</dt>
			<dd>
%複製 の［
`符号化方式$doc, `内容~型$doc, `~URL$doc, `生成元$doc, `種別$doc, `~mode$doc
］ ~SET %node のそれら
◎
Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.
</dd>

			<dt>$DocumentType</dt>
			<dd>
%複製 の［
`名前$dT,
`~publicID$dT,
`~systemID$dT
］ ~SET %node のそれら
◎
Set copy’s name, public ID, and system ID, to those of node.
</dd>

			<dt>$Attr</dt>
			<dd>
%複製 の［
`~ns$a,
`~ns接頭辞$a,
`局所~名$a,
`値$a
］ ~SET %node のそれら
◎
Set copy’s namespace, namespace prefix, local name, and value, to those of node.
</dd>

			<dt>$Text</dt>
			<dt>$Comment</dt>
			<dd>
%複製 の`~data$ ~SET %node のそれ
◎
Set copy’s data, to that of node.
</dd>

			<dt>$ProcessingInstruction</dt>
			<dd>
%複製 の［
`~target$,
`~data$
］ ~SET %node のそれら
◎
Set copy’s target and data to those of node.
</dd>

<!-- 他の~node -->
			<dt>他の~node</dt>
			<dd>
—
<span class="trans-note">【
すなわち， $DocumentFragment になるが、未策定？複製される項目がない？
】</span>
◎
—
</dd>

		</dl>
	<li>
~IF［
%複製 は`文書$である
］
⇒
%文書 ~SET %複製
◎
↓</li>
	<li>
%複製 の`~node文書$ ~SET %文書
◎
Set copy’s node document and document to copy, if copy is a document, and set copy’s node document to document otherwise.
</li>
	<li>
~IF［
他の`適用仕様$において %node に対し定義されている`~clone時の手続き$がある
］
⇒
( %複製, %node, %文書, `~clone子孫^f )
を与える下で，その手続きを走らす
◎
Run any cloning steps defined for node in other applicable specifications and pass copy, node, document and the clone children flag if set, as parameters.
</li>
	<li>
~IF［
`~clone子孫^f ~EQ ~ON
］
⇒
%node の~EACH ( `子$ %子 ) に対し
`木~順序で^tnote
⇒
( %文書, `~clone子孫^f： ~ON )
を与える下で，
%子 を`~clone$した結果を %複製 に付加する
◎
If the clone children flag is set, clone all the children of node and append them to copy, with document as specified and the clone children flag being set.
</li>
	<li>
~RET %複製
◎
Return copy.
</li>
</ol>


<dl class="idl-def">
	<dt>@cloneNode(deep)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The cloneNode(deep) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れは`~shadow根$である
］
⇒
~THROW `NotSupportedError$E
◎
If context object is a shadow root, then throw a NotSupportedError.
</li>
			<li>
~RET ［
( `~clone子孫^f：［
%deep ~EQ ~T ならば ~ON ／
~ELSE_ ~OFF
］ )
を与える下で，此れを`~clone$した結果
◎
Return a clone of the context object, with the clone children flag set if deep is true.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
2 つの`~node$ %A, %B は、次のいずれの条件も満たすならば，
`等しい@
とされる。
◎
A node A equals a node B if all of the following conditions are true:
</p>

<ul>
	<li>
%A と %B の $nodeType 属性~値は一致する。
◎
A and B’s nodeType attribute value is identical.
</li>
	<li>
<p>
%A の型に応じて，次も等しい：
◎
The following are also equal, depending on A:
</p>

		<dl class="switch">
			<dt>$DocumentType</dt>
			<dd>
`名前$dT,
`~publicID$dT,
`~systemID$dT
◎
Its name, public ID, and system ID.
</dd>

			<dt>$Element</dt>
			<dd>
`~ns$,
`~ns接頭辞$,
`局所~名$,
`属性o~list$の`~size$list
◎
Its namespace, namespace prefix, local name, and its attribute list’s size.
</dd>

			<dt>$Attr</dt>
			<dd>
`~ns$a,
`局所~名$a,
`値$a
◎
Its namespace, local name, and value.
</dd>

			<dt>$ProcessingInstruction</dt>
			<dd>
`~target$,
`~data$
◎
Its target and data.
</dd>

			<dt>$Text</dt>
			<dt>$Comment</dt>
			<dd>
`~data$
◎
Its data.
</dd>

<!-- 他の~node -->
			<dt>その他</dt>
			<dd>
—
</dd>
	<dd class="trans-note">【
すなわち，
$Document, $DocumentFragment （ $ShadowRoot ）
が該当するが、未策定？（少なくとも、 %A と %B が同一であれば，等しいとされるべき？）
<!-- ＊ isEqualNode -->
】</dd>

		</dl>
	</li>
	<li>
%A が`要素$である場合は
⇒
%A が`有する$どの`属性o$ %属性 に対しても
⇒
%B は［
%属性 に`等しい$`属性o$
］を`有する$
◎
If A is an element, each attribute in its attribute list has an attribute that equals an attribute in B’s attribute list.
</li>
<li>
%A と %B は同じ個数の`子$を持つ
◎
A and B have the same number of children.
</li>
<li>
%A のどの`子$も，同じ`指数$に位置する %B の`子$に`等しい$
◎
Each child of A equals the child of B at the identical index.
</li>
</ul>


<dl class="idl-def">
	<dt>@isEqualNode(otherNode)</dt>
	<dd>
被呼出時には、［［
%otherNode ~NEQ ~NULL
］~AND［
此れと %otherNode は`等しい$
］ならば~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The isEqualNode(otherNode) method, when invoked, must return true if otherNode is non-null and context object equals otherNode, and false otherwise.
</dd>

	<dt>@isSameNode(otherNode)</dt>
	<dd>
被呼出時には、［［
%otherNode ~EQ 此れ
］ならば~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The isSameNode(otherNode) method, when invoked, must return true if otherNode is context object, and false otherwise.
</dd>

</dl>


<!-- ADD %node →<code >%node</code> -->
<dl class="domintro">
	<dt>%node . $compareDocumentPosition(other)</dt>
	<dd>

<p>
%node に相対的な %other の位置を指示する~bitmaskを返す。
~bitは次のように設定される：
◎
Returns a bitmask indicating the position of other relative to node. These are the bits that can be set:
</p>

		<dl>
			<dt>$Node . $DOCUMENT_POSITION_DISCONNECTED `(1)^i</dt>
			<dd>
%node と %other が同じ`木$に属さないならば~ON にされる。
◎
Set when node and other are not in the same tree.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_PRECEDING `(2)^i</dt>
			<dd>
%other が %node に`先行-$するならば~ON にされる。
◎
Set when other is preceding node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_FOLLOWING `(4)^i</dt>
			<dd>
%other が %node に`後続-$するならば~ON にされる。
◎
Set when other is following node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_CONTAINS `(8)^i</dt>
			<dd>
%other が %node の`先祖$であるならば~ON にされる。
◎
Set when other is an ancestor of node.
</dd>

			<dt>$Node . $DOCUMENT_POSITION_CONTAINED_BY `(16)^i</dt>
			<dd>
%other が %node の`子孫$であるならば~ON にされる。
◎
Set when other is a descendant of node.
</dd>
		</dl>
	</dd>

	<dt>%node . $contains(other)</dt>
	<dd>
%other が %node の`広義子孫$ならば ~T,
他の場合は~F を返す。
◎
Returns true if other is an inclusive descendant of node, and false otherwise.
</dd>
</dl>

<p class="idl-def">
次のものは
$compareDocumentPosition()
が~bitmaskとして返す定数である（括弧内は数値）：
◎
These are the constants compareDocumentPosition() returns as mask:
</p>

<ul><li>@DOCUMENT_POSITION_DISCONNECTED (1)
</li><li>@DOCUMENT_POSITION_PRECEDING (2)
</li><li>@DOCUMENT_POSITION_FOLLOWING (4)
</li><li>@DOCUMENT_POSITION_CONTAINS (8)
</li><li>@DOCUMENT_POSITION_CONTAINED_BY (16 ~EQ 0x10)
</li><li>@DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC (32 ~EQ 0x20)
</li></ul>


<dl class="idl-def">
	<dt>@compareDocumentPosition(other)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The compareDocumentPosition(other) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
此れ ~EQ %other
］
⇒
~RET 0
◎
If context object is other, then return zero.
</li>
			<li>
( %他~node, %自~node ) ~LET ( %other, 此れ )
◎
Let node1 be other and node2 be context object.
</li>
			<li>
( %他~属性o, %自~属性o ) ~LET ( ~NULL, ~NULL )
◎
Let attr1 and attr2 be null.
</li>
			<li>
~IF［
%他~node は`属性o$である
］
⇒＃
%他~属性o ~SET %他~node；
%他~node ~SET %他~属性o が`属する要素$
◎
If node1 is an attribute, then set attr1 to node1 and node1 to attr1’s element.
</li>
			<li>
<p>
~IF［
%自~node は`属性o$である
］：
◎
If node2 is an attribute, then:
</p>
				<ol>
					<li>
%自~属性o ~SET %自~node；
%自~node ~SET %自~属性o が`属する要素$
◎
Set attr2 to node2 and node2 to attr2’s element.
</li>
					<li>
<p>
~IF［
%他~属性o ~NEQ ~NULL
］~AND［
%自~属性o ~NEQ ~NULL
］~AND［
%自~node ~EQ %他~node
］：
◎
If attr1 and node1 are non-null, and node2 is node1, then:
</p>
						<ol>
							<li>
<p>
%自~node の`属性o~list$内の ~EACH ( %属性o ) に対し：
◎
For each attr in node2’s attribute list:
</p>
								<ol>
									<li>
~IF［
( %属性o, %他~属性o )
は`等しい$
］
⇒
~RET 
$DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS
$DOCUMENT_POSITION_PRECEDING
◎
If attr equals attr1, then return the result of adding DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_PRECEDING.
</li>
									<li>
~IF［
( %属性o, %自~属性o )
は`等しい$
］
⇒
~RET
$DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS
$DOCUMENT_POSITION_FOLLOWING
◎
If attr equals attr2, then return the result of adding DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_FOLLOWING.
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%他~node ~EQ ~NULL
］~OR［
%自~node ~EQ ~NULL
］~OR［
%他~node の`根$ ~NEQ %自~node の`根$
］
⇒
~RET ［
$DOCUMENT_POSITION_DISCONNECTED ~PLUS $DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ~PLUS ［
$DOCUMENT_POSITION_PRECEDING または $DOCUMENT_POSITION_FOLLOWING
（ただし，いずれが~~選択されるかは一貫するものとする）］
］
◎
If node1 or node2 is null, or node1’s root is not node2’s root, then return the result of adding DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.
</p>

<p class="note">注記：
$DOCUMENT_POSITION_PRECEDING, $DOCUMENT_POSITION_FOLLOWING
のいずれを返値に用いるかは，概して~pointer比較により行われる。
~JS実装においては `Math.random()^c で~~決定し得る。
◎
Whether to return DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is typically implemented via pointer comparison. In JavaScript implementations a cached Math.random() value can be used.
</p>

<p class="trans-note">【
“一貫する”
— 理想的には，各~node木どうしの順序も保たれるように一貫させるべきであろう。
】</p>

			</li>
			<li>
~IF［［
%他~node は %自~node の`先祖$である
］~AND［
%他~属性o ~EQ ~NULL
］］~OR［［
%他~node ~EQ %自~node
］~AND［
%自~属性o ~NEQ ~NULL
］］
⇒
~RET $DOCUMENT_POSITION_CONTAINS ~PLUS $DOCUMENT_POSITION_PRECEDING
◎
If node1 is an ancestor of node2 and attr1 is null, or node1 is node2 and attr2 is non-null, then return the result of adding DOCUMENT_POSITION_CONTAINS to DOCUMENT_POSITION_PRECEDING.
</li>
			<li>
~IF［［
%他~node は %自~node の`子孫$である
］~AND［
%自~属性o ~EQ ~NULL
］］~OR［［
%他~node ~EQ %自~node
］~AND［
%他~属性o ~NEQ ~NULL
］］
⇒
~RET 
$DOCUMENT_POSITION_CONTAINED_BY ~PLUS $DOCUMENT_POSITION_FOLLOWING
◎
If node1 is a descendant of node2 and attr2 is null, or node1 is node2 and attr1 is non-null, then return the result of adding DOCUMENT_POSITION_CONTAINED_BY to DOCUMENT_POSITION_FOLLOWING.
</li>
			<li>
~IF［
%他~node は %自~node に`先行-$する
］
⇒
~RET $DOCUMENT_POSITION_PRECEDING
◎
If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.
</li>
			<li>
<p>
~RET $DOCUMENT_POSITION_FOLLOWING
◎
Return DOCUMENT_POSITION_FOLLOWING.
</p>

<p class="note">
`属性o$は`木$に`関与-$しないが、この~algoに因り、`属性o$は，［
それを有する`要素$
］の`子$に`先行-$するものとされることになる。
◎
Due to the way attributes are handled in this algorithm this results in a node’s attributes counting as preceding that node’s children, despite attributes not participating in a tree.
</p>
			</li>
		</ol>
	</dd>

	<dt>@contains(other)</dt>
	<dd>
被呼出時には、［
%other は此れの`広義子孫$であるならば ~T ／
~ELSE_（ %other ~EQ ~NULL の場合も含む） ~F
］を返さ~MUST。
◎
The contains(other) method, when invoked, must return true if other is an inclusive descendant of context object, and false otherwise (including when other is null).
</dd>
</dl>

<p class="algo-head">
%要素 に対し，
%~ns を用いて
`~ns接頭辞を~locate@
するときは、次を走らす：
◎
To locate a namespace prefix for an element using namespace, run these steps:
</p>

<ol>
	<li>
~IF［
%要素 の`~ns$ ~EQ %~ns
］~AND［
%要素 の`~ns接頭辞$ ~NEQ ~NULL
］
⇒
~RET %要素 の`~ns接頭辞$
◎
If element’s namespace is namespace and its namespace prefix is not null, then return its namespace prefix.
</li>
	<li>
~IF［
%要素 は［
`~ns接頭辞$a ~EQ `xmlns^l
］~AND［
`値$a ~EQ %~ns
］なる`属性o$を`有する$
］
⇒
~RET そのような`属性o$のうち，最初のものの`局所~名$a
◎
If element has an attribute whose namespace prefix is "xmlns" and value is namespace, then return element’s first such attribute’s local name.
</li>
	<li>
%親 ~SET %要素 の`親~要素$
◎
↓</li>
	<li>
~IF［
%親 ~NEQ ~NULL
］
⇒
~RET %親 に対し %namespace を用いて `~ns接頭辞を~locate$した結果
◎
If element’s parent element is not null, then return the result of running locate a namespace prefix on that element using namespace.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

<p class="algo-head">
%node に対し， %接頭辞 を用いて
`~nsを~locate@
するときは、次を走らす：
◎
To locate a namespace for a node using prefix, switch on node:
</p>

<ol>
	<li>
		<p>
%node の型に応じて：
◎
↑</p>

		<dl class="switch">
			<dt>$Element</dt><dd>
				<ol>
					<li>
~IF［
%node の`~ns$ ~NEQ ~NULL
］~AND［
%node の`~ns接頭辞$ ~EQ %接頭辞
］
⇒
~RET その`~ns$
◎
If its namespace is not null and its namespace prefix is prefix, then return namespace.
</li>
					<li>
<p>
~IF［
%node は、［
%接頭辞 に応じて，次を満たす
］ような`属性o$ %属性o （一意に~~定まる）を`有する$
］…：
</p>

						<dl class="switch">
							<dt>%接頭辞 ~NEQ ~NULL の場合：</dt>
							<dd>
［
`~ns$a ~EQ `~XMLNS~ns$
］~AND［
`~ns接頭辞$a ~EQ `xmlns^l
］~AND［
`局所~名$a ~EQ %接頭辞
］
</dd>
							<dt>%接頭辞 ~EQ ~NULL の場合：</dt>
							<dd>
［
`~ns$a ~EQ `~XMLNS~ns$
］~AND［
`~ns接頭辞$a ~EQ ~NULL
］~AND［
`局所~名$a ~EQ `xmlns^l
］
</dd>

						</dl>
<p>
…ならば
⇒
~RET ［
%属性o の`値$a ~NEQ 空~文字列 ならばそれ ／
~ELSE_ ~NULL
］
</p>

◎
If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is "xmlns", and local name is prefix, or if prefix is null and it has an attribute whose namespace is the XMLNS namespace, namespace prefix is null, and local name is "xmlns", then return its value if it is not the empty string, and null otherwise.
</li>
					<li>
<p id="cp-ret-locate-ns">
%要素 ~LET %node の`親~要素$
◎
If its parent element is null, then return null.
◎
Return the result of running locate a namespace on its parent element using prefix.
</p>
					</li>
				</ol>
			</dd>

			<dt>$Document</dt>
			<dd>
%要素 ~LET %node の`文書~要素$
◎
If its document element is null, return null.
◎
Return the result of running locate a namespace on its document element using prefix.
</dd>

			<dt>$DocumentType</dt>
			<dt>$DocumentFragment</dt>
			<dd><!-- cp-ret-null -->
~RET ~NULL
◎
Return null.
</dd>

			<dt>$Attr</dt>
			<dd>
%要素 ~LET %node が`属する要素$
◎
If its element is null, then return null.
◎
Return the result of running locate a namespace on its element using prefix.
</dd>

			<dt>他の~node（`文字~data~node$）◎Any other node</dt>
			<dd><!--cp-ret-locate-ns--></dd>
		</dl>
	</li>
	<li>
~IF［
%要素 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
↑</li>
	<li>
~RET %要素 に対し， %接頭辞 を用いて `~nsを~locate$した結果
◎
↑</li>
</ol>


<dl class="idl-def">
	<dt>@lookupPrefix(namespace)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The lookupPrefix(namespace) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
%namespace ~IN { ~NULL, 空~文字列 }
］
⇒
~RET ~NULL
◎
If namespace is null or the empty string, return null.
</li>
			<li>
<p>
%要素 ~LET 此れの型に応じて，次で与えられる［
要素, または ~NULL
］：
◎
Switch on the context object:
</p>

				<dl class="switch">

					<dt>$Element</dt>
					<dd>
此れ
◎
Return the result of locating a namespace prefix for the node using namespace.
</dd>

					<dt>$Document</dt>
					<dd>
此れの`文書~要素$
◎
Return the result of locating a namespace prefix for its document element, if its document element is non-null, and null otherwise.
</dd>

					<dt>$DocumentType</dt>
					<dt>$DocumentFragment</dt>
					<dd>
~NULL
◎
Return null.
</dd>

					<dt>$Attr</dt>
					<dd>
此れが`属する要素$
◎
Return the result of locating a namespace prefix for its element, if its element is non-null, and null otherwise.
</dd>

					<dt>他の~node（`文字~data~node$）◎Any other node</dt>
					<dd>
此れの`親~要素$
◎
Return the result of locating a namespace prefix for its parent element, if its parent element is non-null, and null otherwise.
</dd>

				</dl>
			</li>
			<li>
~RET ［
%要素 ~EQ ~NULL ならば ~NULL ／
~ELSE_ %要素 に対し %namespace を用いて `~ns接頭辞を~locate$した結果
］
◎
↑</li>
		</ol>
	</dd>

	<dt>@lookupNamespaceURI(prefix)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The lookupNamespaceURI(prefix) method, when invoked, must run these steps: 
</p>

		<ol>
			<li>
~IF［
%prefix ~EQ 空~文字列
］
⇒
%prefix ~SET ~NULL
◎
If prefix is the empty string, then set it to null.
</li>
			<li>
~RET 此れに対し， %prefix を用いて `~nsを~locate$した結果
◎
Return the result of running locate a namespace for the context object using prefix.
</li>
		</ol>
	</dd>

	<dt>@isDefaultNamespace(namespace)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The isDefaultNamespace(namespace) method, when invoked, must run these steps:
</p>

		<ol>
			<li id="cp-normalize-ns0">
~IF［
%namespace ~EQ 空~文字列
］
⇒
%namespace ~SET ~NULL
◎
If namespace is the empty string, then set it to null.
</li>
			<li>
%既定~ns ~LET 此れに対し，~NULL を用いて `~nsを~locate$した結果
◎
Let defaultNamespace be the result of running locate a namespace for context object using null.
</li>
			<li>
~RET ［
%既定~ns ~EQ %namespace ならば ~T ／
~ELSE_ ~F
］
◎
Return true if defaultNamespace is the same as namespace, and false otherwise.
</li>
		</ol>
	</dd>

	<dt>@insertBefore(node, child)</dt>
	<dd>
被呼出時には、此れの中で， %node を %child の前に`前挿入$した結果を返さ~MUST。
◎
The insertBefore(node, child) method, when invoked, must return the result of pre-inserting node into context object before child.
</dd>
	<dd class="trans-note">【
~HTMLの `br^e のような空~要素であっても（あるいは `script^e 要素であっても）、子~nodeを挿入でき, 木の一部を成すことになる。
次の $appendChild() も同様。
】</dd>

	<dt>@appendChild(node)</dt>
	<dd>
被呼出時には、 %node を此れに`付加-$した結果を返さ~MUST。
◎
The appendChild(node) method, when invoked, must return the result of appending node to context object.
</dd>

	<dt>@replaceChild(node, child)</dt>
	<dd>
被呼出時には、此れの中で %child を %node に`置換-$した結果を返さ~MUST。
◎
The replaceChild(node, child) method, when invoked, must return the result of replacing child with node within context object.
</dd>

	<dt>@removeChild(child)</dt>
	<dd>
被呼出時には、 %child を此れから`前除去-$した結果を返さ~MUST。
◎
The removeChild(child) method, when invoked, must return the result of pre-removing child from context object.
</dd>
</dl>


<p class="algo-head">
`~node$ %根 に対する， %有修飾~名 を
`有修飾~名に持つ要素の~list@
とは、次のようにされた $HTMLCollection である
⇒＃
`根$cl ~SET %根,
`~filter$は［
%根 の`子孫$である`要素$のうち，次で与えられる %条件 を満たすもの
］に合致する：
◎
The list of elements with qualified name qualifiedName for a node root is the HTMLCollection returned by the following algorithm:
</p>

<!-- ＊
局所~名 = * の場合でも、根は除外される
https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
-->

<ol>
	<li>
~IF［
%有修飾~名 ~EQ `*^l (U+002A)
］
⇒
%条件 ~SET なし
◎
If qualifiedName is "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches only descendant elements.
</li>
	<li>
<p>
~ELIF［
%根 の`~node文書$は`~HTML文書$である
］
⇒
%条件 ~SET 次のいずれかを満たす：
◎
Otherwise, if root’s node document is an HTML document, return a HTMLCollection rooted at root, whose filter matches the following descendant elements:
</p>

		<ul>
			<li>
［
`~ns$ ~EQ `~HTML~ns$
］~AND［
`有修飾~名$ ~EQ %有修飾~名 を`~ASCII小文字~化$した結果
］
◎
Whose namespace is the HTML namespace and whose qualified name is qualifiedName, in ASCII lowercase.
</li>
				<li>
［
`~ns$ ~NEQ `~HTML~ns$
］~AND［
`有修飾~名$ ~EQ %有修飾~名
］
◎
Whose namespace is not the HTML namespace and whose qualified name is qualifiedName.
</li>
</ul>

	</li>
	<li>
~ELSE
⇒
%条件 ~SET ［
`有修飾~名$ ~EQ %有修飾~名
］
◎
Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant elements whose qualified name is qualifiedName.
</li>
</ol>

<p>
以前の~callと同じ引数で呼出されたときは、
%根 の`~node文書$の`種別$docが変化していない限り，そのときに返したものと同じ $HTMLCollection ~objを返してもよい。
◎
When invoked with the same argument, and as long as root’s node document’s type has not changed, the same HTMLCollection object may be returned as returned by an earlier call.
</p>

<p class="algo-head">
`~node$ %根 に対する，
( %~ns, %局所~名 )
を
`( ~ns, 局所~名 ) に持つ要素の~list@
とは、次のようにされた $HTMLCollection である
⇒＃
`根$cl ~SET %根,
`~filter$は［ %根 の`子孫$である`要素$のうち，次で与えられる %条件 を満たすもの ］に合致する：
◎
The list of elements with namespace namespace and local name localName for a node root is the HTMLCollection returned by the following algorithm:
</p>

<ol>
	<!--cp-normalize-ns-->
	<li>
%C ~LET `*^l (U+002A)
◎
↓</li>
	<li>
~IF［
%~ns ~EQ %C
］~AND［
%局所~名 ~EQ %C
］
⇒
%条件 ~SET なし
◎
If both namespace and localName are "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches descendant elements.
</li>
	<li>
~ELIF［
%~ns ~EQ %C
］
⇒
%条件 ~SET ［
`局所~名$ ~EQ %局所~名
］
◎
Otherwise, if namespace is "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches descendant elements whose local name is localName.
</li>
	<li>
~ELIF［
%局所~名 ~EQ %C
］
⇒
%条件 ~SET ［
`~ns$ ~EQ %~ns
］
◎
Otherwise, if localName is "*" (U+002A), return a HTMLCollection rooted at root, whose filter matches descendant elements whose namespace is namespace.
</li>
	<li>
~ELSE
⇒
%条件 ~SET ［
`~ns$ ~EQ %~ns
］~AND［
`局所~名$ ~EQ %局所~名
］
◎
Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant elements whose namespace is namespace and local name is localName.
</li>
</ol>

<p id="cp-may-return-the-same">
以前の~callと同じ引数で呼出されたときは，そのときに返したものと同じ $HTMLCollection ~objを返してもよい。
◎
When invoked with the same arguments, the same HTMLCollection object may be returned as returned by an earlier call.
</p>

<p class="algo-head">
`~node$ %根 に対する，
%classNames を
`~classesに含む要素の~list@
とは、次の~algoが返す $HTMLCollection である：
◎
The list of elements with class names classNames for a node root is the HTMLCollection returned by the following algorithm:
</p>

<ol>
	<li>
%~classes ~LET
%classNames を`有順序~集合 構文解析器$にかけた結果
◎
Let classes be the result of running the ordered set parser on classNames.
</li>
	<li>
~IF［
%~classes は空である
］
⇒
~RET 空の $HTMLCollection
◎
If classes is the empty set, return an empty HTMLCollection.
</li>
	<li>
<p>
~RET 次のようにされた $HTMLCollection `~collection$
⇒＃
`根$cl ~SET %根,
`~filter$は［
%根 の`子孫$`要素$のうち，その`~classes$は［
%~classes に含まれるすべての~tokenを含む
］もの
］に合致する
◎
Return a HTMLCollection rooted at root, whose filter matches descendant elements that have all their classes in classes.
</p>

<p>
`~classes$と %~classes の中の各~tokenの比較は、［
%根 の`~node文書$の`~mode$docが `quirks^l ならば `~ASCII大小無視$ ／
~ELSE_ `大小区別$
］で行われ~MUST。
◎
The comparisons for the classes must be done in an ASCII case-insensitive manner if root’s node document’s mode is "quirks", and in a case-sensitive manner otherwise.
</p>
	</li>
</ol>

<!--cp-may-return-the-same-->
		</section>
		<section id="interface-document">
<h3>4.5. ~ifc ^@Document</h3>

⇒！
[$Constructor,
 `Exposed$=Window]
interface @Document : $Node {
  [`SameObject$] ~RA $DOMImplementation $implementation;
  ~RA USVString $URL;
  ~RA USVString $documentURI;
  ~RA USVString $origin;
  ~RA ~DS $compatMode;
  ~RA ~DS $characterSet;
  ~RA ~DS $charset; // <span class="comment" id="cp-legacy-characterSet" title="historical alias of .characterSet">$characterSet の歴史上の別名</span>
  ~RA ~DS $inputEncoding; // <!--cp-legacy-characterSet-->
  ~RA ~DS $contentType;

  ~RA $DocumentType? $doctype;
  ~RA $Element? $documentElement;
  $HTMLCollection $getElementsByTagName(~DS %qualifiedName);
  $HTMLCollection $getElementsByTagNameNS(~DS? %namespace, ~DS %localName);
  $HTMLCollection $getElementsByClassName(~DS %classNames);

  [`NewObject$] $Element $createElement(~DS %localName, optional $ElementCreationOptions %options);
  [`NewObject$] $Element $createElementNS(~DS? %namespace, ~DS %qualifiedName, optional $ElementCreationOptions %options);
  [`NewObject$] $DocumentFragment $createDocumentFragment();
  [`NewObject$] $Text $createTextNode(~DS %data);
  [`NewObject$] $CDATASection $createCDATASection(~DS %data);
  [`NewObject$] $Comment $createComment(~DS %data);
  [`NewObject$] $ProcessingInstruction $createProcessingInstruction(~DS %target, ~DS %data);

  [`CEReactions$ `NewObject$] $Node $importNode($Node %node, optional ~B %deep = false);
  [`CEReactions$] $Node $adoptNode($Node %node);

  [`NewObject$] $Attr $createAttribute(~DS %localName);
  [`NewObject$] $Attr $createAttributeNS(~DS? %namespace, ~DS %qualifiedName);

  [`NewObject$] $Event $createEvent(~DS %interface);

  [`NewObject$] $Range $createRange();

  // $NodeFilter<!---->.$NodeFilter.SHOW_ALL = 0xFFFFFFFF
  [`NewObject$] $NodeIterator $createNodeIterator($Node %root, optional ~UL %whatToShow = 0xFFFFFFFF, optional $NodeFilter? %filter = null);
  [`NewObject$] $TreeWalker $createTreeWalker($Node %root, optional ~UL %whatToShow = 0xFFFFFFFF, optional $NodeFilter? %filter = null);
};

[`Exposed$=Window]
interface @XMLDocument : $Document {};

dictionary @@ElementCreationOptions {
  DOMString @is;
};
◎

<!-- 
ElementCreationOptions:dictdef-elementcreationoptions
is:#dom-elementcreationoptions-is

 -->
<p>
$@Document `~node$は、単に
`文書@
とも称される。
◎
Document nodes are simply known as documents.
</p>


<div class="p">
<p>
各 `文書$には、次のものが結付けられる
— 他が定められない限り，括弧内に示される値をとるとする：
</p>

<dl class="def-list">
	<dt>`符号化方式@doc（ `utf-8$ ）</dt>
	<dd>
<a href="~ENCODING#encoding">符号化方式</a>
</dd>
	<dt>`内容~型@doc（ `application/xml^l ）</dt>
	<dd>
文字列
</dd>
	<dt>`~URL@doc（ `about:blank^l  †）</dt>
	<dd>
`~URL$
</dd>
	<dd class="trans-note">【†
正確には、 `about:blank^l が表現する `~URL$ （文字列ではない）。
】</dd>
	<dt>`生成元@doc（ `不透明な生成元$ ）</dt>
	<dd>
`生成元$
</dd>
	<dt>`種別@doc（ `xml^l ）</dt>
	<dd>
次のいずれか
⇒
`xml^l ／ `html^l
</dd>
	<dt>`~mode@doc（ `no-quirks^l ）</dt>
	<dd>
次のいずれか
⇒
`no-quirks^l ／ `quirks^l ／ `limited-quirks^l
</dd>

</dl>

<p>
`ENCODING$r `URL$r `HTML$r
</p>

◎
Each document has an associated encoding (an encoding), content type (a string), URL (a URL), origin (an origin), type ("xml" or "html"), and mode ("no-quirks", "quirks", or "limited-quirks"). [ENCODING] [URL] [HTML]
◎
Unless stated otherwise, a document’s encoding is the utf-8 encoding, content type is "application/xml", URL is "about:blank", origin is an opaque origin, type is "xml", and its mode is "no-quirks".
</div>


<div class="p">
<p>
`文書$は、その`種別$docに応じて：
</p>

<ul><li>`xml^l ならば
`~XML文書@
であるとされる。
</li><li>`html^l ならば
`~HTML文書@
であるとされる。
</li></ul>

<p>
一部の~APIの挙動は、この 2 種のいずれであるかにより，影響される。
</p>
◎
A document is said to be an XML document if its type is "xml", and an HTML document otherwise. Whether a document is an HTML document or an XML document affects the behavior of certain APIs.
</div>



<div class="p">

<p>
`文書$は、その`~mode$docに応じて：
</p>

<ul ><li>`no-quirks^l ならば
`非過去互換~mode@
下にあるとされる。
</li><li>`quirks^l ならば
`過去互換~mode@
下にあるとされる。
</li><li>`limited-quirks^l ならば
`限定的互換~mode@
下にあるとされる。
</li></ul>
◎
A document is said to be in no-quirks mode if its mode is "no-quirks", quirks mode if its mode is "quirks", and limited-quirks mode if its mode is "limited-quirks".
</div>

<p class="note">注記：
~modeが既定の~modeから変更されるのは、`文書$が，新たな`閲覧文脈$（初期の `about:blank^l ）から，［
DOCTYPE 文字列の有無, およびその値
］に基づいて `~HTML構文解析器$を通して作成される場合に限られる。
`HTML$r
◎
The mode is only ever changed from the default for documents created by the HTML parser based on the presence, absence, or value of the DOCTYPE string, and by a new browsing context (initial "about:blank"). [HTML]
</p>

<p class="note">注記：
`非過去互換~mode$ は 元々 “標準~mode” として知られ，
`限定的互換~mode$ は かつては “ほぼ標準~mode” と称されていた。
それらは今や標準により定義されたので（また、それらの元々の名称が的外れであることから Ian Hickson が否決したので）、改称された。
◎
No-quirks mode was originally known as "standards mode" and limited-quirks mode was once known as "almost standards mode". They have been renamed because their details are now defined by standards. (And because Ian Hickson vetoed their original names on the basis that they are nonsensical.)
</p>

<div class="p">
<p class="algo-head">
`文書$ %文書 の`親~targetを取得する$ときは、所与の~event %~event に対し：
</p>

<ol>
	<li>
~IF［
%~event の $Event.type 属性~値 ~EQ `load^l
］~OR［
%文書 が`属する閲覧文脈$はない
］
⇒
~RET ~NULL
</li>
	<li>
~RET %文書 に`関連する大域~obj$
</li>
</ol>

◎
A document’s get the parent algorithm, given an event, returns null if event’s type attribute value is "load" or document does not have a browsing context, and the document’s relevant global object otherwise. 

associated Window object otherwise.
</div>

<hr>

<dl class="domintro">
	<dt>var %document = new $Document()</dt>
	<dd>
新たな`文書$を返す。
◎
Returns a new document.
</dd>

	<dt>%document . $implementation</dt>
	<dd>
%document の $DOMImplementation ~objを返す。
◎
Returns document’s DOMImplementation object.
</dd>

	<dt>%document . $URL</dt>
	<dt>%document . $documentURI</dt>
	<dd>
%document の`~URL$doc を返す。
◎
Returns document’s URL.
</dd>


	<dt>%document . $origin</dt>
	<dd>
%document の`生成元$docを返す。
◎
Returns document’s origin.
</dd>

	<dt>%document . $compatMode</dt>
	<dd>
%document の`~mode$docが［
`quirks^l ならば文字列 `BackCompat^l ／
~ELSE_ `CSS1Compat^l
］を返す。
◎
Returns the string "BackCompat" if document’s mode is "quirks", and "CSS1Compat" otherwise.
</dd>

	<dt>%document . $characterSet</dt>
	<dd>
%document の`符号化方式$docを返す。
◎
Returns document’s encoding.
</dd>

	<dt>%document . $contentType</dt>
	<dd>
%document の`内容~型$docを返す。
◎
Returns document’s content type.
</dd>
</dl>





<dl class="idl-def">
	<dt>@Document()</dt>
	<dd>
この構築子の被呼出時には、次のようにされた，新たな`文書$を返さ~MUST
⇒
`生成元$doc ~SET `現在の大域~obj$に`結付けられている文書$の`生成元$doc `HTML$r
◎
The Document() constructor, when invoked, must return a new document whose origin is the origin of current global object’s associated Document. [HTML]
</dd>

	<dd class="note">注記：
$DOMImplementation.createDocument() と違って、この構築子は
$XMLDocument ~objではなく，`文書$（ $Document ~obj）を返す。
◎
Unlike createDocument(), this constructor does not return an XMLDocument object, but a document (Document object).
</dd>

	<dt>@implementation</dt>
	<dd>
取得子は、此れ（`文書$）に結付けられている
$DOMImplementation ~objを返さ~MUST。
◎
The implementation attribute’s getter must return the DOMImplementation object that is associated with the document.
</dd>

	<dt>@URL</dt>
	<dt>@documentURI</dt>
	<dd>
これらのいずれも，取得子は、次を走らせた結果を返さ~MUST
⇒
`~URLを直列化する$( 此れの`~URL$doc )
◎
The URL attribute’s getter and documentURI attribute’s getter must return the URL, serialized.
</dd>

	<dt>@origin</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
`生成元を直列化する$( 此れの`生成元$doc )
◎
The origin attribute’s getter must return the serialization of context object’s origin.
</dd>

	<dt>@compatMode</dt>
	<dd>
取得子は、［
此れの`~mode$doc ~EQ `quirks^l ならば `BackCompat^l ／
~ELSE_ `CSS1Compat^l
］を返さ~MUST。
◎
The compatMode attribute’s getter must return "BackCompat" if context object’s mode is "quirks", and "CSS1Compat" otherwise.
</dd>

	<dt>@characterSet</dt>
	<dt>@charset</dt>
	<dt>@inputEncoding</dt>
	<dd>
これらのいずれも，取得子は、此れの`符号化方式$docの
<a href="~ENCODING#name">名前</a>
を返さ~MUST。
◎
The characterSet attribute’s getter, charset attribute’s getter, and inputEncoding attribute’s getter, must return context object’s encoding’s name.
</dd>

	<dt>@contentType</dt>
	<dd>
取得子は、此れの`内容~型$docを返さ~MUST。
◎
The contentType attribute’s getter must return the content type.
</dd>
</dl>


<dl class="domintro">
	<dt>%document . $doctype</dt>
	<dd>
`~doctype$が［
在ればそれ ／
無ければ~NULL
］を返す。
◎
Returns the doctype or null if there is none.
</dd>

	<dt>%document . $documentElement</dt>
	<dd>
`文書~要素$を返す。
◎
Returns the document element.
</dd>

	<dt>%collection = %document . $getElementsByTagName(qualifiedName)</dt>
	<dd>
%qualifiedName が `*^l の場合、`子孫$`要素$すべてからなる $HTMLCollection を返す。
◎
If qualifiedName is "*" returns a HTMLCollection of all descendant elements.
</dd>
	<dd>
他の場合、［
`有修飾~名$が %qualifiedName なる `子孫$`要素$
］すべてからなる $HTMLCollection を返す（ `~HTML文書$ 内の`~HTML~ns$に属する`要素$に対しては，大小無視の合致による）。
◎
Otherwise, returns a HTMLCollection of all descendant elements whose qualified name is qualifiedName. (Matches case-insensitively against elements in the HTML namespace within an HTML document.)
</dd>

	<dt>%collection = %document . $getElementsByTagNameNS(namespace, localName)</dt>
	<dd>
%namespace, %localName のいずれも `*^l の場合は、`子孫$`要素$すべてからなる $HTMLCollection を返す。
◎
If namespace and localName are "*" returns a HTMLCollection of all descendant elements.
</dd>
	<dd>
%namespace のみが `*^l の場合は、［
`局所~名$が %localName なる `子孫$`要素$
］すべてからなる $HTMLCollection を返す。
◎
If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.
</dd>
	<dd>
%localName のみが `*^l の場合は、［
`~ns$が %namespace なる `子孫$`要素$
］すべてからなる $HTMLCollection を返す。
◎
If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.
</dd>
	<dd>
他の場合は、［
`~ns$が %namespace, かつ `局所~名$が %localName なる
`子孫$`要素$
］すべてからなる $HTMLCollection を返す。
◎
Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
</dd>

	<dt>%collection = %document . $getElementsByClassName(classNames)</dt>
	<dt>%collection = %element . $Element.getElementsByClassName(classNames)</dt>
	<dd>
~methが呼出された~obj（`文書$または`要素$）内の`要素$のうち，［
%classNames で与えられる一連の~class名をすべて持つもの
］からなる $HTMLCollection を返す。
%classNames 引数は一連の~class名の~space区切り~listとして解釈される。
◎
Returns a HTMLCollection of the elements in the object on which the method was invoked (a document or an element) that have all the classes given by classNames. The classNames argument is interpreted as a space-separated list of classes.
</dd>

</dl>


<dl class="idl-def">
	<dt>@doctype</dt>
	<dd>
取得子は、［
此れの`子$である
］~AND［
`~doctype$である
］ような~nodeのうち，`最初0$のものを返さ~MUST。
◎
The doctype attribute’s getter must return the child of the document that is a doctype, and null otherwise.
</dd>

	<dt>@documentElement</dt>
	<dd>
取得子は、此れの`文書~要素$を返さ~MUST。
◎
The documentElement attribute’s getter must return the document element.
</dd>

	<dt>@getElementsByTagName(qualifiedName)</dt>
	<dd>
被呼出時には、此れに対する， %qualifiedName を`有修飾~名に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagName(qualifiedName) method, when invoked, must return the list of elements with qualified name qualifiedName for the context object.
</dd>
	<dd class="note">注記：
したがって，`~HTML文書$においては、
`document.getElementsByTagName("FOO")^c は
`~HTML~ns$に属さない `FOO^e 要素と
`~HTML~ns$に属する `foo^e 要素に合致し，
`~HTML~ns$に属する `FOO^e 要素には合致しないことになる。
◎
Thus, in an HTML document, document.getElementsByTagName("FOO") will match &lt;FOO&gt; elements that are not in the HTML namespace, and &lt;foo&gt; elements that are in the HTML namespace, but not &lt;FOO&gt; elements that are in the HTML namespace.
</dd>

	<dt>@getElementsByTagNameNS(namespace, localName)</dt>
	<dd>
被呼出時には、此れに対する，
( %namespace, %localName ) を
`( ~ns, 局所~名 ) に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagNameNS(namespace, localName) method, when invoked, must return the list of elements with namespace namespace and local name localName for the context object.
</dd>

	<dt>@getElementsByClassName(classNames)</dt>
	<dd>
被呼出時には、此れに対する，
%classNames を`~classesに含む要素の~list$を返さ~MUST。
◎
The getElementsByClassName(classNames) method, when invoked, must return the list of elements with class names classNames for the context object.
	</dd>
	<dd class="example">
<p>
次の XHTML 片が与えられたとする：
◎
Given the following XHTML fragment:
</p>

<pre class="html-code">
&lt;div id="example"&gt;
  &lt;p id="<mark>p1</mark>" class="aaa bbb"/&gt;
  &lt;p id="<mark>p2</mark>" class="aaa ccc"/&gt;
  &lt;p id="<mark>p3</mark>" class="bbb ccc"/&gt;
&lt;/div&gt;
</pre>

<p>
<samp>document.getElementById(`example^l).getElementsByClassName(`aaa^l)</samp>
の~callは、その中の 2 個の paragraph 
<mark>p1</mark> と <mark>p2</mark> からなる
$HTMLCollection を返すことになる。
◎
A call to document.getElementById("example").getElementsByClassName("aaa") would return a HTMLCollection with the two paragraphs p1 and p2 in it.
</p>

<p>
一方で，
<samp>getElementsByClassName(`ccc&nbsp;bbb^l)</samp>
の~callは
その中の 1 個の~node <mark>p3</mark> のみを返すことになる。
<samp>document.getElementById(`example^l).getElementsByClassName(`bbb&nbsp;&nbsp;&nbsp;ccc&nbsp;^l)</samp>
の~callも同じものを返すことになる。
◎
A call to getElementsByClassName("ccc bbb") would only return one node, however, namely p3. A call to document.getElementById("example").getElementsByClassName("bbb ccc ") would return the same thing.
</p>

<p>
<samp>getElementsByClassName(`aaa,bbb^l)</samp>
の~callは 1 個の~nodeも返さない。
上のどの要素も `aaa,bbb^c ~classに属さない。
◎
A call to getElementsByClassName("aaa,bbb") would return no nodes; none of the elements above are in the aaa,bbb class.
</p>
	</dd>
</dl>


<dl class="domintro">
	<dt>%element = %document . $createElement(localName [, options])</dt>
	<dd>
`局所~名$が %localName であるような，`要素$を返す（ %document が`~HTML文書$である場合， %localName は小文字~化される）。
`要素$の`~ns$は，［［
%document が`~HTML文書$である
］または［
%document の`内容~型$doc ~EQ `application/xhtml+xml^l
］ならば `~HTML~ns$ ／
他の場合は ~NULL
］になる。
◎
Returns an element with localName as local name (if document is an HTML document, localName gets lowercased). The element’s namespace is the HTML namespace when document is an HTML document or document’s content type is "application/xhtml+xml", and null otherwise.
</dd>
	<dd>
%localName が `Name$prod 生成規則に合致しない場合は
`InvalidCharacterError$E 例外が投出される。
◎
If localName does not match the Name production an InvalidCharacterError will be thrown.
</dd>
	<dd id="cp-supplied-is-mb">
%options の $ElementCreationOptions.is ~memberを利用して，`~custom化された組込みの要素$を作成できる。
◎
When supplied, options’ is member can be used to create a customized built-in element.
</dd>

	<dt>%element = %document . $createElementNS(namespace, qualifiedName [, options])</dt>
	<dd>
`~ns$ %namespace に属するような，新たな`要素$を返す。
その［
`~ns接頭辞$, `局所~名$
］は、順に，［
%qualifiedName が `:^l (U+003A) を含む
］ならば，それを挟んだ［
前, 後
］の部分，他の場合は［
~NULL, %qualifiedName
］にされる。
◎
Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
</dd>
	<dd>
%qualifiedName が `Name$prod 生成規則に合致しない場合は
`InvalidCharacterError$E 例外が投出される。
◎
If localName does not match the Name production an InvalidCharacterError will be thrown.
</dd>

<!-- *localName -->
	<dd>

<p>
次のいずれかを条件を満たす場合，
`NamespaceError$E 例外が投出される：
◎
If one of the following conditions is true a NamespaceError will be thrown:
</p>

		<ul>
			<li>
%localName は `QName$prod 生成規則に合致しない。
◎
localName does not match the QName production.
</li>
			<li>
%namespace は空~文字列であるのに，`~ns接頭辞$は~NULL でない。
◎
Namespace prefix is not null and namespace is the empty string.
</li>
			<li>
%namespace は`~XML~ns$でないのに，`~ns接頭辞$は `xml^l である。
◎
Namespace prefix is "xml" and namespace is not the XML namespace.
</li>
			<li>
%namespace は`~XMLNS~ns$でないのに，
%qualifiedName または`~ns接頭辞$は `xmlns^l である。
◎
qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
</li>
			<li>
%namespace は`~XMLNS~ns$であるのに，
%qualifiedName も`~ns接頭辞$も `xmlns^l でない。
◎
namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
</li>
</ul>
	</dd>
	<!--cp-supplied-is-mb-->

	<dt>%documentFragment = %document . $createDocumentFragment()</dt>
	<dd>
$DocumentFragment `~node$を返す。
◎
Returns a DocumentFragment node.
</dd>

	<dt>%text = %document . $createTextNode(data)</dt>
	<dd>
`~data$が %data にされた，新たな $Text `~node$を返す。
◎
Returns a Text node whose data is data.
</dd>

	<dt>%text = %document . $createCDATASection(data)</dt>
	<dd>
`~data$が %data にされた，新たな $CDATASection `~node$を返す。
◎
Returns a CDATASection node whose data is data.
</dd>

	<dt>%comment = %document . $createComment(data)</dt>
	<dd>
`~data$が %data にされた，新たな $Comment `~node$を返す。
◎
Returns a Comment node whose data is data.
</dd>


	<dt>%processingInstruction = %document . $createProcessingInstruction(target, data)</dt>
	<dd>
<p>
$target が %target にされ, `~data$が %data にされた，新たな $ProcessingInstruction `~node$を返す。
次の場合は `InvalidCharacterError$E 例外が投出される：
</p>

		<ul>
			<li>
%target が `Name$prod 生成規則に合致しない場合。
</li>
			<li>
%data が `?&gt;^l を含んでいる場合。
</li>
		</ul>

◎
Returns a ProcessingInstruction node whose target is target and data is data. If target does not match the Name production an InvalidCharacterError will be thrown. If data contains "?&gt;" an InvalidCharacterError will be thrown.
	</dd>
</dl>

<p>
他が定められない限り，所与の
( 局所~名, ~ns )
に
`対応する要素~ifc@
は、 $Element とする。
◎
The element interface for any name and namespace is Element, unless stated otherwise.
</p>

<p class="note">注記：
例えば，~HTML標準は、
( `html$e, `~HTML~ns$ )
に対応するそれを，
$HTMLHtmlElement ~ifcと定義している。
`HTML$r
◎
The HTML Standard will e.g. define that for html and the HTML namespace, the HTMLHtmlElement interface is used. [HTML] 
</p>


<dl class="idl-def">
	<dt>@createElement(localName, options)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createElement(localName, options) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%localName は `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If localName does not match the Name production, then throw an InvalidCharacterError.
</li>
			<li>
~IF［
此れは`~HTML文書$ である
］
⇒
%localName ~SET %localName を`~ASCII小文字~化$した結果
◎
If the context object is an HTML document, then set localName to localName in ASCII lowercase.
</li>
			<li id="cp-let-is">
%is ~LET 
%options に $ElementCreationOptions.is ~memberが［
在するならば その値 ／
不在ならば ~NULL
］
◎
Let is be the value of is member of options, or null if no such member exists.
</li>
			<li>
%~ns ~LET ［［
此れは`~HTML文書$である
］~OR［
此れの`内容~型$doc ~EQ `application/xhtml+xml^l
］ならば `~HTML~ns$ ／
~ELSE_ ~NULL
］
◎
Let namespace be the HTML namespace, if the context object is an HTML document or context object’s content type is "application/xhtml+xml", and null otherwise.
</li>
			<li>
%要素 ~LET
`新たな要素$( 此れ, %localName, %~ns, ~NULL, %is, ~ON )
◎
Let element be the result of creating an element given the context object, localName, namespace, null, is, and with the synchronous custom elements flag set.
</li>
			<li id="cp-set-is">
~IF［
%is ~NEQ ~NULL
］
⇒
%要素 の`属性o値を設定する$( `is^l, %is )
◎
If is is non-null, then set an attribute value for element using "is" and is.
</li>
			<li id="cp-ret-element">
~RET %要素
◎
Return element.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
`内的 createElementNS 手続き@
は、所与の
( %文書, %namespace, %qualifiedName, %options )
に対し，次を走らす：
◎
The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as follows:
</p>

<ol>
	<li id="cp-validate-and-extract">
( %~ns, %接頭辞, %局所~名 ) ~LET
`検証して抽出する$( %namespace, %qualifiedName )
◎
Let namespace, prefix, and localName be the result of passing namespace and qualifiedName to validate and extract.
</li>
	<!--cp-let-is-->
	<li>
%要素 ~LET
`新たな要素$( %文書, %局所~名, %~ns, %接頭辞, %is, ~ON )
◎
Let element be the result of creating an element given document, localName, namespace, prefix, is, and with the synchronous custom elements flag set.
</li>
	<!--cp-set-is-->
	<!--cp-ret-element-->
</ol>

<dl class="idl-def">
	<dt>@createElementNS(namespace, qualifiedName, options)</dt>
	<dd>
被呼出時には、
`内的 createElementNS 手続き$( 此れ, %namespace, %qualifiedName, %options )
を返さ~MUST。
◎
The createElementNS(namespace, qualifiedName, options) method, when invoked, must return the result of running the internal createElementNS steps, given context object, namespace, qualifiedName, and options.
</dd>

	<dt>@createDocumentFragment()</dt>
	<dd>
被呼出時には、次のように設定された 新たな`文書片$を返さ~MUST
⇒
`~node文書$ ~SET 此れ
◎
The createDocumentFragment() method, when invoked, must return a new DocumentFragment node with its node document set to the context object.
</dd>

	<dt>@createTextNode(data)</dt>
	<dd>
被呼出時には、
`新たな~Text~node$( %data, 此れ )
を返さ~MUST
◎
The createTextNode(data) method, when invoked, must return a new Text node with its data set to data and node document set to the context object.
</dd>
	<dd class="note">注記：
［
%data が `Char$prod 生成規則に合致しない文字を含む
］かどうかは、検査されない。
◎
No check is performed that data consists of characters that match the Char production.
</dd>

	<dt>@createCDATASection(data)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createCDATASection(data) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
此れは`~HTML文書$である
］
⇒
~THROW `NotSupportedError$E
◎
If context object is an HTML document, then throw a NotSupportedError.
</li>
			<li>
~IF［
%data は文字列 `]]&gt;^l を包含する
］
⇒
~THROW `InvalidCharacterError$E
◎
If data contains the string "]]&gt;", then throw an InvalidCharacterError.
</li>
			<li>
~RET 次のようにされた，新たな $CDATASection `~node$
⇒
( `~data$, `~node文書$ ) ~SET ( %data, 此れ )
◎
Return a new CDATASection node with its data set to data and node document set to the context object.
</li>
		</ol>
	</dd>

	<dt>@createComment(data)</dt>
	<dd>
被呼出時には、次のように設定された 新たな $Comment `~node$を返さ~MUST
⇒
( `~data$, `~node文書$ ) ~SET ( %data, 此れ )
◎
The createComment(data) method, when invoked, must return a new Comment node with its data set to data and node document set to the context object.
	</dd>
	<dd class="note">注記：
%data が［
`Char$prod 生成規則に合致しない文字を含む ／
連続する 2 個の~hyphen（ "--" ）を含む ／
~hyphenで終わる
］かどうかは、検査されない。
◎
No check is performed that data consists of characters that match the Char production or that it contains two adjacent hyphens or ends with a hyphen.
</dd>

	<dt>@createProcessingInstruction(target, data)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createProcessingInstruction(target, data) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%target は
<!--<code data-anolis-spec=xml>PITarget</code>-->
`Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
<!-- DOM3 does not check for "xml" -->
◎
If target does not match the Name production, then throw an InvalidCharacterError.
</li>
			<li>
~IF［
%data は文字列 `?&gt;^l を含む
］
⇒
~THROW `InvalidCharacterError$E
<!-- Gecko does this. -->
◎
If data contains the string "?&gt;", then throw an InvalidCharacterError.
</li>
<!--<li>
<p>If <var title>target</var> contains a U+003A COLON (":")
 character, <span data-anolis-spec=webidl>throw</span> a
<code title>NamespaceError</code> exception.-->
<!-- DOM3 didn’t check this -->
			<li>
~RET 
次のように設定された 新たな $ProcessingInstruction `~node$
⇒
( $ProcessingInstruction.target, `~data$, `~node文書$ )
~SET
( %target, %data, 此れ )
◎
Return a new ProcessingInstruction node, with target set to target, data set to data, and node document set to the context object.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
［
%target が `xml^l または `:^l を含む ／
%data が `Char$prod 生成規則に合致しない文字を含む
］かどうかは、検査されない。
◎
No check is performed that target contains "xml" or ":", or that data contains characters that match the Char production.
</dd>
</dl>


<dl class="domintro">
	<dt>%clone = %document . $importNode(node [, deep = false])</dt>
	<dd>
%node の複製を返す。
%deep が~T の場合、複製には %node の`子孫$も含められる。
◎
Returns a copy of node. If deep is true, the copy also includes the node’s descendants.
</dd>
	<dd>
%node が`文書$または`~shadow根$である場合，
`NotSupportedError$E 例外が投出される。
◎
If node is a document or a shadow root, throws a NotSupportedError.
</dd>

	<dt>%node = %document . $adoptNode(node)</dt>
	<dd>
%node を他の`文書$から移動させた上で，それを返す。
◎
Moves node from another document and returns it.
</dd>
	<dd>
%node が`文書$である場合，
`NotSupportedError$E 例外が投出される。
%node が`~shadow根$である場合，
`HierarchyRequestError$E 例外が投出される。
◎
If node is a document, throws a NotSupportedError or, if node is a shadow root, throws a HierarchyRequestError.
</dd>
</dl>

<dl class="idl-def">
	<dt>@importNode(node, deep)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The importNode(node, deep) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
%node は `文書$または`~shadow根$である
］
⇒
~THROW `NotSupportedError$E
◎
If node is a document or shadow root, then throw a NotSupportedError.
</li>
			<li>
~RET［
( 此れ, `~clone子孫^f：［
%deep ~EQ ~T ならば ~ON ／
~ELSE_ ~OFF
］ )
を与える下で，
%node を`~clone$した結果
◎
Return a clone of node, with context object and the clone children flag set if deep is true.
</li>
		</ol>
	</dd>
</dl>

<p>
`適用仕様$は、一部またはすべての`~node$に対し，
`受入-時の手続き@
を定義してよい。
~algoには、`受入-$する~algoに指示される
( %node, %旧-文書 )
が渡される。
◎
Specifications may define adopting steps for all or some nodes. The algorithm is passed node and oldDocument, as indicated in the adopt algorithm.
</p>

<p class="algo-head">
%node を %文書 に
`受入-@
するときは、次を走らす：
◎
To adopt a node into a document, run these steps:
</p>

<ol>
	<li>
%旧-文書 ~LET %node の`~node文書$
◎
Let oldDocument be node’s node document.
</li>
	<li>
~IF［
%node の`親$ ~NEQ ~NULL
］
⇒
%node を %node の`親$から`除去-$する
◎
If node’s parent is not null, remove node from its parent.
</li>
	<li>
<p>
~IF［
%文書 ~NEQ %旧-文書
］：
◎
If document is not oldDocument, then:
</p>
		<ol>
			<li>
<p>
%node の~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants:
</p>
				<ol>
					<li>
%広義子孫 の`~node文書$ ~SET %文書
◎
Set inclusiveDescendant’s node document to document.
</li>
					<li>
~IF［
%広義子孫 は`要素$である
］
⇒
%広義子孫 の`属性o~list$内の~EACH ( %属性o ) に対し
⇒
%属性o の`~node文書$ ~SET %文書
◎
If inclusiveDescendant is an element, then set the node document of each attribute in inclusiveDescendant’s attribute list to document.
</li>
				</ol>
			</li>
			<li>
%node の~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し
⇒
~IF［
%広義子孫 は`~custom$である
］
⇒
`~custom要素~callback反応を待入れる$(
%広義子孫,
`adoptedCallback^l,
« %旧-文書, %文書 »
)
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants that is custom, enqueue a custom element callback reaction with inclusiveDescendant, callback name "adoptedCallback", and an argument list containing oldDocument and document.
</li>
			<li>
%node の~EACH ( `~shadowも含む広義子孫$ %広義子孫 ) に対し，`~shadowも含む木~順序$で
⇒
( %広義子孫, %旧-文書 )
を与える下で，`受入-時の手続き$を走らす
◎
For each inclusiveDescendant in node’s shadow-including inclusive descendants, in shadow-including tree order, run the adopting steps with inclusiveDescendant and oldDocument.
</li>
		</ol>
	</li>
</ol>

<dl class="idl-def">
	<dt>@adoptNode(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The adoptNode(node) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%node は`文書$である
］
⇒
~THROW `NotSupportedError$E
◎
If node is a document, then throw a NotSupportedError.
</li>
			<li>
~IF［
%node は`~shadow根$である
］
⇒
~THROW `HierarchyRequestError$E
◎
If node is a shadow root, then throw a HierarchyRequestError.
</li>
			<li>
%node を此れに`受入-$する
◎
Adopt node into the context object.
</li>
			<li>
~RET %node
◎
Return node.
</li>
		</ol>
	</dd>

	<dt>@createAttribute(localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createAttribute(localName) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%localName は~XMLの `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If localName does not match the Name production in XML, then throw an InvalidCharacterError.
</li>
			<li>
~IF［
此れは`~HTML文書$である
］
⇒
%localName ~SET %localName を`~ASCII小文字~化$した結果
◎
If the context object is an HTML document, then set localName to localName in ASCII lowercase.
</li>
			<li>
~RET 次のように設定された 新たな`属性o$
⇒＃
`局所~名$a ~SET %localName,
`~node文書$ ~SET 此れ
◎
Return a new attribute whose local name is localName and node document is context object.
</li>
		</ol>
	</dd>

	<dt>@createAttributeNS(namespace, qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createAttributeNS(namespace, qualifiedName) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-validate-and-extract-->
			<li>
<p>
~RET 次のように設定された 新たな`属性o$：
</p>

<ul><li>`~ns$a ~SET %~ns
</li><li>`~ns接頭辞$a ~SET %接頭辞
</li><li>`局所~名$a ~SET %局所~名
</li><li>`~node文書$ ~SET 此れ
</li></ul>

◎
Return a new attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, and node document is context object.
</li>
		</ol>
	</dd>

	<dt>@createEvent(interface)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createEvent(interface) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%構築子 ~LET ~NULL
◎
Let constructor be null.
</li>
			<li>
<p>
~IF［
%interface は［
下の表のいずれかの行の 1 列目の文字列
］に `~ASCII大小無視$で合致する
］
⇒
%構築子 ~SET ［
合致した行の 2 列目の~ifc
］の構築子
◎
If interface is an ASCII case-insensitive match for any of the strings in the first column in the following table, then set constructor to the interface in the second column on the same row as the matching string:
</p>

<table>
<thead><tr><th>文字列◎String
<th>~ifc◎Interface
<th>仕様（空欄はこの仕様）◎Notes
</thead><tbody>

<tr><td>`beforeunloadevent^l
<td>$BeforeUnloadEvent
<td>`HTML$r

<tr><td>`compositionevent^l
<td>$CompositionEvent
<td>`UIEVENTS$r

<tr><td>`customevent^l
<td>$CustomEvent
<td>

<tr><td>`devicemotionevent^l
<td>$DeviceMotionEvent
<td>`DEVICE-ORIENTATION$r

<tr><td>`deviceorientationevent^l
<td>$DeviceOrientationEvent
<td>同上

<tr><td>`dragevent^l
<td>$DragEvent
<td>`HTML$r

<tr><td>`event^l
<td>$Event
<td>

<tr><td>`events^l
<td>同上
<td>

<tr><td>`focusevent^l
<td>$FocusEvent
<td>`UIEVENTS$r

<tr><td>`hashchangeevent^l
<td>$HashChangeEvent
<td>`HTML$r

<tr><td>`htmlevents^l
<td>$Event
<td>

<tr><td>`keyboardevent^l
<td>$KeyboardEvent
<td>`UIEVENTS$r

<tr><td>`messageevent^l
<td>$MessageEvent
<td>`HTML$r

<tr><td>`mouseevent^l
<td>$MouseEvent
<td>`UIEVENTS$r

<tr><td>`mouseevents^l
<td>同上
<td>同上

<tr><td>`storageevent^l
<td>$StorageEvent
<td>`HTML$r

<tr><td>`svgevents^l
<td>$Event
<td>

<tr><td>`textevent^l
<td>$CompositionEvent
<td>`UIEVENTS$r

<tr><td>`touchevent^l
<td>$TouchEvent
<td>`TOUCH-EVENTS$r

<tr><td>`uievent^l
<td>$UIEvent
<td>`UIEVENTS$r

<tr><td>`uievents^l
<td>同上
<td>同上

</tbody></table>

			</li>
			<li>
~IF［
%構築子 ~EQ ~NULL
］
⇒
~THROW `NotSupportedError$E
◎
If constructor is null, then throw a NotSupportedError.
</li>
			<li>
<p>
~IF［
%構築子 が指示する~ifcは，此れに`関連する大域~obj$に公開されていない
］
⇒
~THROW `NotSupportedError$E
◎
If the interface indicated by constructor is not exposed on the relevant global object of the context object, then throw a NotSupportedError.
</p>

<p class="note">注記：
概して~UAは、環境設定によっては，~touch~eventの~supportを不能化する
— その場合、 $TouchEvent ~ifcに対しては，この段が誘発されることになる。
◎
Typically user agents disable support for touch events in some configurations, in which case this clause would be triggered for the interface TouchEvent.
</p>
			</li>
			<li>
%~event ~LET `~eventを作成する$( %構築子 )
◎
Let event be the result of creating an event given constructor.
</li>
			<li>
%~event の $Event.type 属性 ~SET 空~文字列に初期化する
◎
Initialize event’s type attribute to the empty string.
</li>
			<li>
%~event の $Event.timeStamp 属性 ~SET ［
`時刻起点$から現在時までの高分解能な時間差
］を表現している $DOMHighResTimeStamp 値に初期化する
◎
Initialize event’s timeStamp attribute to a DOMHighResTimeStamp representing the high resolution time from the time origin to now.
</li>
			<li>
%event の $Event.isTrusted 属性 ~SET ~F に初期化する
◎
Initialize event’s isTrusted attribute to false.
</li>
			<li>
%~event の`初期化-済み$f ~SET ~OFF
◎
Unset event’s initialized flag.
</li>
			<li>
~RET %~event
◎
Return event.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
代わりに，`~event$構築子が利用されるべきである。
◎
Event constructors ought to be used instead.
</dd>

	<dt>@createRange()</dt>
	<dd>
被呼出時には、次のように設定された 新たな`範囲o$を返さ~MUST
⇒＃
`始端$ ~SET (此れ, 0) ,
`終端$ ~SET (此れ, 0)
◎
The createRange() method, when invoked, must return a new range with (context object, 0) as its start and end.
	</dd>
	<dd class="note">注記：
代わりに， $Range.Range() 構築子が利用されるべきである。
◎
The Range() constructor ought to be used instead.
</dd>

	<dt>@createNodeIterator(root, whatToShow, filter)</dt>
	<dd>
<p>
被呼出時には、次のように設定された 新たな $NodeIterator ~objを返さ~MUST：
◎
The createNodeIterator(root, whatToShow, filter) method, when invoked, must run these steps:
</p>

		<ul>
			<li>
`根~node$ ~SET %root
◎
Create a NodeIterator object.
◎
Set root to root and initialize the referenceNode attribute to root.
</li>
			<li>
$NodeIterator.referenceNode 属性 ~SET %root に初期化する
◎
↑</li>
			<li>
$NodeIterator.pointerBeforeReferenceNode 属性 ~SET ~T に初期化する
◎
Initialize the pointerBeforeReferenceNode attribute to true.
</li>
			<li id="cp-set-whatToShow">
`whatToShow ~bitmask$ ~SET %whatToShow
◎
Set whatToShow to whatToShow.
</li>
			<li>
`~filter~callback$ ~SET %filter
◎
Set filter to filter.
◎
Return the newly created NodeIterator object.
</li>
		</ul>
	</dd>

	<dt>@createTreeWalker(root, whatToShow, filter)</dt>
	<dd>
<p>
被呼出時には、次のように設定された 新たな $TreeWalker ~objを返さ~MUST：
◎
The createTreeWalker(root, whatToShow, filter) method, when invoked, must run these steps:
</p>

		<ul>
			<li>
`根~node$ ~SET %root
◎
Create a TreeWalker object.
◎
Set root to root and initialize the currentNode attribute to root.
</li>
			<li>
$TreeWalker.currentNode 属性 ~SET %root に初期化する
◎
↑</li>
			<!--cp-set-whatToShow-->
			<li>
`~filter~callback$ ~SET %filter
◎
Set filter to filter.
◎
Return the newly created TreeWalker object.
</li>
		</ul>
	</dd>
</dl>
			<section id="interface-domimplementation">
<h4>4.5.1. ~ifc ^@DOMImplementation</h4>

<p>
~UA は、`文書$が作成された際には，
$DOMImplementation ~objを作成して, `文書$にそれを結付け~MUST。
◎
User agents must create a DOMImplementation object whenever a document is created and associate it with that document.
</p>

⇒！
[`Exposed$=Window]
interface @DOMImplementation {
  [`NewObject$] $DocumentType $createDocumentType(~DS qualifiedName, ~DS publicId, ~DS systemId);
  [`NewObject$] $XMLDocument $createDocument(~DS? %namespace, [`TreatNullAs$=EmptyString] ~DS %qualifiedName, optional $DocumentType? %doctype = null);
  [`NewObject$] $Document $createHTMLDocument(optional ~DS title);

  ~B $hasFeature(); // <span class="comment" id="cp-useless-true" title="useless; always returns true">無用の長物 — 常に true を返す</span>
};
◎

<dl class="domintro">
	<dt>%doctype = %document . $Document.implementation . $createDocumentType( qualifiedName, publicId, systemId )</dt>
	<dd>
所与の［
%qualifiedName, %publicId, %systemId
］を伴う`~doctype$を返す。
%qualifiedName が
`Name$prod 生成規則に合致しない場合は
`InvalidCharacterError$E 例外が投出され,
`QName$prod 生成規則に合致しない場合は
`NamespaceError$E 例外が投出される。
◎
Returns a doctype, with the given qualifiedName, publicId, and systemId. If qualifiedName does not match the Name production, an InvalidCharacterError is thrown, and if it does not match the QName production, a NamespaceError is thrown.
</dd>

	<dt>%doc = %document . $Document.implementation . $createDocument( namespace, qualifiedName [, doctype = null] )</dt>
	<dd>
`局所~名$が %qualifiedName で`~ns$が %namespace （ %qualifiedName が空~文字列でなければ）の`文書~要素$を伴い，
%doctype が与えられていれば`~doctype$がそれに設定された
$XMLDocument を返す。
◎
Returns an XMLDocument, with a document element whose local name is qualifiedName and whose namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is given, as its doctype.
</dd>
	<dd>
この~methは、$Document.createElementNS() ~methと同じ例外を，
( %namespace, %qualifiedName )
で呼出したときに投出する。
◎
This method throws the same exceptions as the createElementNS() method, when invoked with namespace and qualifiedName.
</dd>

	<dt>%doc = %document . $Document.implementation . $createHTMLDocument([title])</dt>
	<dd>
基本~構造が構築-済みの`木$を伴う`文書$を返す。
%title 引数が省略されていなければ `title$e 要素も含められる。
◎
Returns a document, with a basic tree already constructed including a title element, unless the title argument is omitted.
</dd>
</dl>


<dl class="idl-def">
	<dt>@createDocumentType(qualifiedName, publicId, systemId)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createDocumentType(qualifiedName, publicId, systemId) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`有修飾~名として検証する$( %qualifiedName )
◎
Validate qualifiedName.
</li>
			<li>
<p>
~RET 次のように設定された 新たな`~doctype$
</p>

<ul><li>`名前$dT ~SET %qualifiedName
</li><li>`~publicID$dT ~SET %publicId
</li><li>`~systemID$dT ~SET %systemId
</li><li>`~node文書$ ~SET 此れに結付けられている`文書$
</li></ul>

◎
Return a new doctype, with qualifiedName as its name, publicId as its public ID, and systemId as its system ID, and with its node document set to the associated document of the context object.
			</li>
		</ol>
	</dd>
	<dd class="note">注記：
［
%publicId を成す符号位置~並びが `PubidChar^prod 生成規則に合致しない ／
%systemId が文字 `"^l や `'^l を含む
］かどうかは、検査されない。
◎
No check is performed that publicId code points match the PubidChar production or that systemId does not contain both a '"' and a "'".
</dd>

	<dt>@createDocument(namespace, qualifiedName, doctype)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createDocument(namespace, qualifiedName, doctype) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%文書 ~LET 新たな $XMLDocument
◎
Let document be a new XMLDocument.
</li>
			<li>
%要素 ~LET ~NULL
◎
Let element be null.
</li>
			<li>
~IF［
%qualifiedName ~NEQ 空~文字列
］
⇒
%要素 ~SET `内的 createElementNS 手続き$( 此れ, %namespace, %qualifiedName, 空~辞書 )
◎
If qualifiedName is not the empty string, then set element to the result of running the internal createElementNS steps, given document, namespace, qualifiedName, and an empty dictionary.
</li>
			<li>
~IF［
%doctype ~NEQ ~NULL
］
⇒
%doctype を %文書 に`付加-$する
◎
If doctype is non-null, append doctype to document.
</li>
			<li>
~IF［
%要素 ~NEQ ~NULL
］
⇒
%要素 を %文書 に`付加-$する
◎
If element is non-null, append element to document.
</li>
			<li>
%文書 の`生成元$doc ~SET 此れに結付けられている`文書$の`生成元$doc
◎
document’s origin is context object’s associated document’s origin.
</li>
			<li>
<p>
%文書 の`内容~型$doc ~SET %~ns に応じて，次で与えられる値：
◎
document’s content type is determined by namespace:
</p>

<dl class="switch"
	><dt>`~HTML~ns$
</dt><dd>`application/xhtml+xml^c
</dd><dt>`~SVG~ns$
</dt><dd>`image/svg+xml^c
</dd><dt>他の~ns◎Any other namespace
</dt><dd>`application/xml^c
</dd></dl>

			</li>
			<li>
~RET %文書
◎
Return document.
</li>
		</ol>
	</dd>

	<dt>@createHTMLDocument(title)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The createHTMLDocument(title) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%文書 ~LET 次のように設定された，新たな`文書$
⇒＃
`種別$doc ~SET `html^l,
`内容~型$doc ~SET `text/html^l
◎
Let doc be a new document that is an HTML document.
◎
Set doc’s content type to "text/html".
</li>
			<li>
次のように設定された 新たな`~doctype$を %文書 に`付加-$する
⇒＃
`名前$dT ~SET `html^l,
`~node文書$ ~SET %文書
◎
Append a new doctype, with "html" as its name and with its node document set to doc, to doc.
</li>
			<li>
`html 要素^V ~LET
`新たな要素$( %文書, `html^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, html, and the HTML namespace, to doc.
</li>
			<li>
`html 要素^V を %文書 に`付加-$する
◎
↑</li>
			<li>
`head 要素^V ~LET
`新たな要素$( %文書, `head^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, head, and the HTML namespace, to the html element created earlier.
</li>
			<li>
`head 要素^V を `html 要素^V に`付加-$する
◎
↑</li>
			<li>
<p>
~IF［
%title 引数は与えられている
］：
◎
If title is given:
</p>
				<ol>
					<li>
`title 要素^V ~LET
`新たな要素$( %文書, `title^l, `~HTML~ns$ )
◎
Append the result of creating an element given doc, title, and the HTML namespace, to the head element created earlier.
</li>
					<li>
`title 要素^V を `head 要素^V に`付加-$する
◎
↑</li>
					<li>
`新たな~Text~node$( %title, %文書 )
を， `title 要素^V に`付加-$する
◎
Append a new Text node, with its data set to title (which could be the empty string) and its node document set to doc, to the title element created earlier.
</li>
				</ol>
			</li>
			<li>
`新たな要素$( %文書, `body^l, `~HTML~ns$ )
を， `html 要素^V に`付加-$する
◎
Append the result of creating an element given doc, body, and the HTML namespace, to the html element created earlier.
</li>
			<li><!-- cp* -->
%文書 の`生成元$doc ~SET 此れに結付けられている`文書$の`生成元$doc
`HTML$r
◎
doc’s origin is context object’s associated document’s origin.
</li>
			<li>
~RET %文書
◎
Return doc.
</li>
		</ol>
	</dd>

	<dt>@hasFeature()</dt>
	<dd>
被呼出時には、 ~T を返さ~MUST：
◎
The hasFeature() method, when invoked, must return true.
	</dd>
	<dd class="note">注記：
$hasFeature()
は元々、~UAが所与の~DOM特色機能の~supportを~~言明しているかどうかを報告するものであったが、経験から，単に欲される~obj, 属性, ~methが存在するかどうか検査する用途にはほど遠いことが~~判明している。
そのようなわけで，それは最早~利用されないが、古い~pageが働き続けられるようにするために存続している（単に ~T を返す）。
◎
hasFeature() originally would report whether the user agent claimed to support a given DOM feature, but experience proved it was not nearly as reliable or granular as simply checking whether the desired objects, attributes, or methods existed. As such, it is no longer to be used, but continues to exist (and simply returns true) so that old pages don’t stop working.
</dd>
</dl>

			</section>
		</section>
		<section id="interface-documenttype">
<h3>4.6. ~ifc ^@DocumentType</h3>

⇒！
[`Exposed$=Window]
interface @DocumentType : $Node {
  ~RA ~DS $name;
  ~RA ~DS $publicId;
  ~RA ~DS $systemId;
};
◎


<p>
$DocumentType `~node$は、単に
`~doctype@
とも称される。
◎
DocumentType nodes are simply known as doctypes.
</p>


<div class="p">
<p>
各 `~doctype$には、次のものが結付けられる（いずれも，文字列）：
</p>

<dl class="def-list">
	<dt>`名前@dT</dt>
	<dd>
常に，`~doctype$の作成-時に与えられる。
</dd>

	<dt>`~publicID@dT</dt>
	<dt>`~systemID@dT</dt>
	<dd>
これらは、`~doctype$の作成-時に明示的に与えられない限り，空~文字列とする。
</dd>

</dl>

◎
Doctypes have an associated name, public ID, and system ID.
◎
When a doctype is created, its name is always given. Unless explicitly given when a doctype is created, its public ID and system ID are the empty string.
</div>



<dl class="idl-def">
	<dt>@name</dt>
	<dd>
取得子は、此れの`名前$dTを返さ~MUST。
◎
The name attribute’s getter must return the context object’s name.
</dd>

	<dt>@publicId</dt>
	<dd>
取得子は、此れの`~publicID$dTを返さ~MUST。
◎
The publicId attribute’s getter must return the context object’s public ID.
</dd>

	<dt>@systemId</dt>
	<dd>
取得子は、此れの`~systemID$dTを返さ~MUST。
◎
The systemId attribute’s getter must return the context object’s system ID.
</dd>
</dl>

		</section>
		<section id="interface-documentfragment">
<h3>4.7. ~ifc ^@DocumentFragment</h3>

⇒！
[$Constructor,
 `Exposed$=Window]
interface @DocumentFragment : $Node {
};
◎

<p class="trans-note">【
この訳では， $DocumentFragment `~node$を
`文書片@
と称することにする。
】</p>

<div class="p">
<p>
各 `文書片$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~host@</dt>
	<dd>
［
~NULL, 異なる`~node木$内にある`要素$
］のいずれかであり、他が定められない限り，~NULL とする。
</dd>
</dl>
◎
A DocumentFragment node has an associated host (null or an element in a different node tree). It is null unless otherwise stated.
</div>

<p>
~obj %A が ~obj %B の
`~hostも含む広義先祖@
であるとは、次のいずれかが満たされることを意味する：
◎
An object A is a host-including inclusive ancestor of an object B, if either＼
</p>

<ul>
	<li>
%A は %B の`広義先祖$である。
◎
A is an inclusive ancestor of B, or＼
</li>
	<li>
%B の`根$の`~host$ %H は非 ~NULL, かつ
%A は %H の`~hostも含む広義先祖$である。
◎
if B’s root has a non-null host and A is a host-including inclusive ancestor of B’s root’s host.
</li>
</ul>

<p class="note">注記：
`文書片$の`~host$は，［
`~shadow根$, ~HTMLの `template$e 要素
］で有用になる概念であり、［
`前挿入$する／`置換-$する
］~algoに影響0する。 
◎
The DocumentFragment node’s host concept is useful for HTML’s template element and for shadow roots, and impacts the pre-insert and replace algorithms.
</p>

<hr>

<dl class="domintro">
	<dt>var %tree = new $DocumentFragment()</dt>
	<dd>
新たな`文書片$を返す。
◎
Returns a new DocumentFragment node.
</dd>
</dl>

<dl class="idl-def">
	<dt>@DocumentFragment()</dt>
	<dd>
この構築子の被呼出時には、次のようにされた新たな`文書片$を返さ~MUST
⇒
`~node文書$ ~SET `現在の大域~obj$に`結付けられている文書$
◎
The DocumentFragment() constructor, when invoked, must return a new DocumentFragment node whose node document is current global object’s associated Document.
</dd>
</dl>

		</section>
		<section id="interface-shadowroot">
<h3>4.8. ~ifc ^@ShadowRoot</h3>

⇒！
[`Exposed$=Window]
interface @ShadowRoot : $DocumentFragment {
  ~RA $ShadowRootMode $mode;
  ~RA $Element $host;
};

enum @ShadowRootMode { `open@l, `closed@l };
◎


<p>
$ShadowRoot ~nodeは、単に
`~shadow根@
（ shadow root ）とも称される。
◎
ShadowRoot nodes are simply known as shadow roots.
</p>

<div class="p">
<p>
各 `~shadow根$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~mode@sR</dt>
	<dd>
［
`open^l, `closed^l
］のいずれか。
</dd>
</dl>
◎
Shadow roots have an associated mode("open" or "closed").
</div>

<p>
`~shadow根$の`~host$が ~NULL になることは決してない。
◎
Shadow roots’s associated host is never null.
</p>

<p>
`~shadow根$ %根 の`親~targetを取得する$ときは、所与の~event %~event に対し，次を走らす：
◎
A shadow root’s get the parent algorithm, given an event,＼
</p>

<ol>
	<li>
~IF［
%~event の`~composed$f ~EQ ~OFF
］~AND［
%根 ~EQ ［［［
%~event の`経路$
］内の最初の組
］の `item$evP
］の`根$
］
⇒
~RET ~NULL
◎
returns null if event’s composed flag is unset and shadow root is the root of event’s path’s first tuple’s item, and＼
</li>
	<li>
~RET %根 の`~host$
◎
shadow root’s host otherwise.
</li>
</ol>


<dl class="idl-def">
	<dt>@mode</dt>
	<dd>
取得子は、此れの`~mode$sRを返さ~MUST。
◎
The mode attribute’s getter must return the context object’s mode.
</dd>

	<dt>@host</dt>
	<dd>
取得子は、此れの`~host$を返さ~MUST。
◎
The host attribute’s getter must return the context object’s host.
</dd>
</dl>

<hr>

<p>
`~node木$ %木 に対する
`~shadowも含む木~順序@
は、
`~shadowも含む深優先前順走査@
と称される，次に従う順序である
⇒
%木 に対する深優先前順走査
`すなわち，通常の木~順序^tnote
に従いつつ，
%木 において［
`~shadow~host$である`要素$ %要素
］に遭遇した各所では，［［
%要素 の`~shadow根$elmを根とする`~node木$
］に対する，`~shadowも含む深優先前順走査$
］に従う。
◎
In shadow-including tree order, is shadow-including preorder, depth-first traversal of a node tree. shadow-including preorder, depth-first traversal of a node tree tree is preorder, depth-first traversal of tree, with for each shadow host encountered in tree, shadow-including preorder, depth-first traversal of that element’s shadow root’s node tree just after it is encountered.
</p>

<p>
~obj %O の
`~shadowも含む根@
とは、
%O の`根$を %根 とするとき，［
%根 は`~shadow根$であるならば %根 の`~host$の`~shadowも含む根$ ／
~ELSE_ %根
］である。
◎
The shadow-including root of an object is its root’s host’s shadow-including root, if the object’s root is a shadow root, and its root otherwise.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む子孫@
であるとは、次を意味する
⇒
［
%A は %B の`子孫$である
］~OR［
%A の`根$ %根 は`~shadow根$であって，
%根 の`~host$は %B の`~shadowも含む広義子孫$である
］
◎
An object A is a shadow-including descendant of an object B, if A is a descendant of B, or A’s root is a shadow root and A’s root’s host is a shadow-including inclusive descendant of B.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む広義子孫@
であるとは、次を意味する
⇒
［
%A ~EQ %B
］~OR［
%A は %B の`~shadowも含む子孫$である
］
◎
A shadow-including inclusive descendant is an object or one of its shadow-including descendants.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む先祖@
であるとは、次を意味する
⇒
%B は %A の`~shadowも含む子孫$である
◎
An object A is a shadow-including ancestor of an object B, if and only if B is a shadow-including descendant of A.
</p>

<p>
~obj %A が~obj %B の
`~shadowも含む広義先祖@
であるとは、次を意味する
⇒［
%A ~EQ %B
］~OR［
%A は %B の`~shadowも含む先祖$である
］
◎
A shadow-including inclusive ancestor is an object or one of its shadow-including ancestors.
</p>

<p>
`~node$ %A が `~node$ %B から
`~closed-shadow-hidden@
であるとは、 %A の`根$ %根 が次のすべてを満たすことを意味する：
◎
A node A is closed-shadow-hidden from a node B if all of the following conditions are true:
</p>

<ul>
	<li>
%根 は`~shadow根$である
◎
A’s root is a shadow root.
</li>
	<li>
%根 は %B の`~shadowも含む広義先祖$でない
◎
A’s root is not a shadow-including inclusive ancestor of B.
</li>
	<li>
［
%根 の`~mode$sR ~EQ `closed^l
］~OR［
%根 の`~host$は %B から`~closed-shadow-hidden$である
］
◎
A’s root is a shadow root whose mode is "closed" or A’s root’s host is closed-shadow-hidden from B.
</li>
</ul>

<p class="algo-head">
~obj %A を ~obj %B に向けて
`再target@
するときは、次を走らす：
◎
To retarget an object A against an object B,＼
</p>

<ol>
	<li>
<p>
~WHILE 無条件：
◎
repeat these steps until they return an object:
</p>
		<ol>
			<li>
%根 ~LET %A の`根$
◎
↓</li>
			<li>
~IF［
%根 は`~shadow根$でない
］~OR［
%根 は %B の`~shadowも含む広義先祖$である
］
⇒
~RET %A
◎
If A’s root is not a shadow root, or A’s root is a shadow-including inclusive ancestor of B, then return A.
</li>
			<li>
%A ~SET %根 の`~host$
◎
Set A to A’s root’s host.
</li>
		</ol>
	</li>
</ol>

<hr>

<p class="XXX">課題：
この~objについての更なる情報は、今の所，
<a href="https://w3c.github.io/webcomponents/spec/shadow/">Shadow DOM</a>
にて見れる。
~DOM標準には、時経過に伴い，それらの詳細が含められることになる。
◎
For now you can find more information about this object in Shadow DOM. The DOM Standard will be updated over time to cover more details.
</p>

		</section>
		<section id="interface-element">
<h3>4.9. ~ifc ^@Element</h3>

⇒！
[`Exposed$=Window]
interface @Element : $Node {
  ~RA ~DS? $namespaceURI;
  ~RA ~DS? $prefix;
  ~RA ~DS $localName;
  ~RA ~DS $tagName;

  [`CEReactions$] attribute ~DS $id;
  [`CEReactions$] attribute ~DS $className;
  [`SameObject$, `PutForwards$=$DOMTokenList.value] ~RA $DOMTokenList $classList;
  [`CEReactions$, `Unscopable$] attribute ~DS $slot;

  boolean $hasAttributes();
  [`SameObject$] ~RA $NamedNodeMap $attributes;
  sequence&lt;~DS&gt; $getAttributeNames();
  ~DS? $getAttribute(~DS %qualifiedName);
  ~DS? $getAttributeNS(~DS? %namespace, ~DS %localName);
  [`CEReactions$] void $setAttribute(~DS %qualifiedName, ~DS %value);
  [`CEReactions$] void $setAttributeNS(~DS? %namespace, ~DS %qualifiedName, ~DS %value);
  [`CEReactions$] void $removeAttribute(~DS %qualifiedName);
  [`CEReactions$] void $removeAttributeNS(~DS? %namespace, ~DS %localName);
  ~B $hasAttribute(~DS %qualifiedName);
  ~B $hasAttributeNS(~DS? %namespace, ~DS %localName);

  $Attr? $getAttributeNode(~DS %qualifiedName);
  $Attr? $getAttributeNodeNS(~DS? %namespace, ~DS %localName);
  [`CEReactions$] $Attr? $setAttributeNode($Attr %attr);
  [`CEReactions$] $Attr? $setAttributeNodeNS($Attr %attr);
  [`CEReactions$] $Attr $removeAttributeNode($Attr %attr);

  $ShadowRoot $attachShadow($ShadowRootInit %init);
  ~RA $ShadowRoot? $shadowRoot;

  $Element? $closest(~DS %selectors);
  ~B $matches(~DS %selectors);
  ~B $webkitMatchesSelector(~DS %selectors); // <span class="comment" title="historical alias of .characterSet">$matches の歴史上の別名</span>

  $HTMLCollection $getElementsByTagName(~DS %qualifiedName);
  $HTMLCollection $getElementsByTagNameNS(~DS? %namespace, ~DS %localName);
  $HTMLCollection $getElementsByClassName(~DS %classNames);

  [`CEReactions$] $Element? $insertAdjacentElement(~DS %where, $Element %element); // <!--cp-histroic-->
  void $insertAdjacentText(~DS %where, ~DS %data); // <!--cp-histroic-->
};

dictionary @@ShadowRootInit {
  required $ShadowRootMode @mode;
};
◎

<p>
$@Element `~node$は、単に
`要素@
とも称される。
◎
Element nodes are simply known as elements.
</p>

<div class="p">
<p>
各 `要素$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt >`~ns@</dt>
	<dt >`~ns接頭辞@</dt>
	<dt >`局所~名@</dt>
	<dt >`~custom要素~状態@</dt>
	<dt >`~custom要素~定義@</dt>
	<dt >`~is0値@</dt>
	<dd>
これらのいずれの値も，`要素を作成-$するときに初期化される。
</dd>
</dl>
◎
Elements have an associated namespace, namespace prefix, local name, custom element state, custom element definition, is value. When an element is created, all of these values are initialized.
</div>


<p>
`要素$の`~custom要素~状態$は、［
`undefined^l, `failed^l, `uncustomized^l, `custom^l
］のいずれかである。
`要素$のうち［
`~custom要素~状態$ ~IN
{ `uncustomized^l, `custom^l }
］なるものは、
`定義済み@
という。
`要素$のうち［
`~custom要素~状態$ ~EQ `custom^l
］なるものは、
`~custom@
という。
◎
An element’s custom element state is one of "undefined", "failed", "uncustomized", or "custom". An element whose custom element state is "uncustomized" or "custom" is said to be defined. An element whose custom element state is "custom" is said to be custom.
</p>

<p class="note">注記：
要素が`定義済み$かどうかは、
<a href="~HTMLselectors#selector-defined"><code class="pseudo">:defined</code></a>
疑似類の挙動を決定するときに利用される。
要素が`~custom$であるかどうかは、
<a href="#mutation-algorithms">変異~algo</a>
の挙動を決定するときに利用される。
`failed^l 状態は、`~custom要素~構築子$が初回に正しく実行するのに失敗した場合に，`要素を昇格する$ときに再び実行されないことを確保するために利用される。
◎
Whether or not an element is defined is used to determine the behavior of the :defined pseudo-class. Whether or not an element is custom is used to determine the behavior of the mutation algorithms. The "failed" state is used to ensure that if a custom element constructor fails to execute correctly the first time, it is not executed again by an upgrade.
</p>

<div class="example">
<p>
要素がとり得るこれら 4 種の状態を，次の~codeで~~説明する：
◎
The following code illustrates elements in each of these four states:
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;script&gt;
  window.customElements.define(
    "sw-rey",
    class extends HTMLElement {}
  );
  window.customElements.define(
    "sw-finn",
    class extends HTMLElement {},
    { extends: "p" }
  );
  window.customElements.define(
    "sw-kylo",
    class extends HTMLElement {
      constructor() {
        /* <span class="comment">
`super()^c は、この例からは意図的に省略している。
◎
super() intentionally omitted for this example
</span> */
    }
  });
&lt;/script&gt;

&lt;!-- <span class="comment">
`undefined^l （`定義済み$でも`~custom$でもない）
◎
"undefined" (not defined, not custom)
</span> --&gt;
&lt;sw-han&gt;&lt;/sw-han&gt;
&lt;p is="sw-luke"&gt;&lt;/p&gt;
&lt;p is="asdf"&gt;&lt;/p&gt;

&lt;!-- <span class="comment">
`failed^l （`定義済み$でも`~custom$でもない）
◎
"failed" (not defined, not custom)
</span> --&gt;
&lt;sw-kylo&gt;&lt;/sw-kylo&gt;

&lt;!-- <span class="comment">
`uncustomized^l （`定義済み$であるが`~custom$ではない）
◎
"uncustomized" (defined, not custom)
</span> --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;asdf&gt;&lt;/asdf&gt;

&lt;!-- <span class="comment">
`custom^l （`定義済み$であって`~custom$でもある）
◎
"custom" (defined, custom)
</span> --&gt;
&lt;sw-rey&gt;&lt;/sw-rey&gt;
&lt;p is="sw-finn"&gt;&lt;/p&gt;
</pre>

</div>

<div class="p">
<p>
各 `要素$には、次のものも結付けられる：
</p>

<dl class="def-list">
	<dt >`~shadow根@elm</dt>
	<dd>
~NULL, または `~shadow根$。
</dd>
	<dd>
他が定められない限り，~NULL とする。
</dd>
	<dd>
~NULL でない場合、当の`要素$は
`~shadow~host@
であるとされる†。
</dd>
	<dd class="trans-note">【†
— すなわち，要素は、`~shadow根$elmを根とする，ある`~shadow木$を~hostしている（要素は、ある`~shadow根$の`~host$である）。
】</dd>
</dl>

◎
Elements also have an associated shadow root (null or a shadow root). It is null unless otherwise stated. An element is a shadow host if its shadow root is non-null.
</div>

<p>
`要素$ %要素 の
`有修飾~名@
は、 %要素 の`~ns接頭辞$ %接頭辞 に応じて，［
~NULL ならば %要素 の`局所~名$ ／
非 ~NULL ならば［
%接頭辞, `:^l, %要素 の`局所~名$
］の並び
］になる。
◎
An element’s qualified name is its local name if its namespace prefix is null, and its namespace prefix, followed by ":", followed by its local name, otherwise.
</p>

<p class="note" id="cp-for-readbility">注記：
~UAは、これを内的~slotに持たせて最適化することもできる。
◎
User agents could have this as an internal slot as an optimization.
</p>

<p class="algo-head">
`要素を作成-@
するときは、所与の
( %文書, %局所~名, %~ns, %接頭辞 （省略時は ~NULL ）, %is （省略時は ~NULL ）, %同期~custom要素~flag （省略時は ~OFF ）)
に対し，次の手続きを走らす：
◎
To create an element, given a document, localName, namespace, and optional prefix, is, and synchronous custom elements flag, run these steps: 
</p>

<p class="trans-note">【
この訳では、この手続きを呼出すときは，
“`新たな要素$( %引数~list )”
のように表記する。
】</p>

<ol>
	<li>
%結果 ~LET ~NULL
◎
If prefix was not given, let prefix be null.
◎
If is was not given, let is be null.
◎
Let result be null.
</li>
	<li>
%定義 ~LET `~custom要素~定義を検索する$( %文書, %~ns, %局所~名, %is )
◎
Let definition be the result of looking up a custom element definition given document, namespace, localName, and is.
</li>
	<li>
<p>
~IF［
%定義 ~NEQ ~NULL
］~AND［
%定義 の`名前$cD ~NEQ %定義 の`局所~名$cD
］（すなわち，%定義 は`~custom化された組込みの要素$を表現する）：
◎
If definition is non-null, and definition’s name is not equal to its local name (i.e., definition represents a customized built-in element), then:
</p>
		<ol>
			<li>
%~ifc ~LET
( %局所~名, `~HTML~ns$ )
に`対応する要素~ifc$
◎
Let interface be the element interface for localName and the HTML namespace.
</li>
			<li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$：
</p>

<ul ><li>%~ifc を実装する
</li><li>`属性o$は有さない
</li><li>`~ns$ ~SET `~HTML~ns$
</li><li>`~ns接頭辞$ ~SET %接頭辞 
</li><li>`局所~名$ ~SET %局所~名
</li><li>`~custom要素~状態$ ~SET `undefined^l
</li><li>`~custom要素~定義$ ~SET ~NULL
</li><li>`~is0値$ ~SET %is
</li><li>`~node文書$ ~SET %文書
</li></ul>

◎
Set result to a new element that implements interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "undefined", custom element definition set to null, is value set to is, and node document set to document.
</li>
			<li>
~IF［
%同期~custom要素~flag ~EQ ~ON
］
⇒
`要素を昇格する$( %定義, %要素 )
◎
If the synchronous custom elements flag is set, upgrade element using definition.
</li>
			<li>
~ELSE
⇒
`~custom要素~昇格~反応を待入れる$( %結果, %定義 )
◎
Otherwise, enqueue a custom element upgrade reaction given result and definition.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%定義 ~NEQ ~NULL
］~AND［
%同期~custom要素~flag ~EQ ~ON
］
⇒
次の手続きを走らすが、例外に対しては，~catchして 下の (A) に~~移行する：
◎
Otherwise, if definition is non-null, then:
◎
If the synchronous custom elements flag is set, then run these steps whilecatching any exceptions:
</p>

		<ol>
			<li>
%C ~LET %定義 の`構築子$cD
◎
Let C be definition’s constructor.
</li>
			<li>
%結果 ~SET
( %C, 空の引数~list )
を与える下で，`~callback関数で構築-$した結果
◎
Set result to the result of constructing C, with no arguments.
</li>
			<li>
<p>
~IF［
%結果 は $HTMLElement ~ifcを実装しない
］
⇒
~THROW `TypeError$E
◎
If result does not implement the HTMLElement interface, then throw a TypeError.
</p>

<div class="note">
<p>注記：
これは、［
当の~objが~HTML要素~構築子により割り当てられること
］を確保するための，~brand検査である。
より精確に知りたければ、
<a href="https://github.com/heycam/webidl/issues/97">webidl #97</a>
を見よ。
◎
This is meant to be a brand check to ensure that the object was allocated by the HTML element constructor. See webidl #97 about making this more precise.
</p>

<p>
この検査に合格したなら、 %結果 の［
`~custom要素~状態$, `~custom要素~定義$
］はすでに初期化されていることになる。
◎
If this check passes, then result will already have its custom element state and custom element definition initialized. 
</p>
</div>
			</li>
			<li>
<p>
~IF［
%結果 は下に挙げるいずれかを満たす
］
⇒
~THROW `NotSupportedError$E：
◎
↓</p>

				<ul>
					<li>
%結果 の`属性o~list$は`空$listでない
◎
If result’s attribute list is not empty, then throw a NotSupportedError.
</li>
					<li>
%結果 は`子$を持つ
◎
If result has children, then throw a NotSupportedError.
</li>
					<li>
%結果 の`親$ ~NEQ ~NULL
◎
If result’s parent is not null, then throw a NotSupportedError.
</li>
					<li>
%結果 の`~node文書$ ~NEQ %文書
◎
If result’s node document is not document, then throw a NotSupportedError.
</li>
					<li>
<p>
%結果 の`~ns$ ~NEQ `~HTML~ns$
◎
If result’s namespace is not the HTML namespace, then throw a NotSupportedError.
</p>

<p class="note">注記：
これを書いている時点では、
$HTMLElement ~ifcを実装するどの要素も~HTML~nsに属するので、上の~brand検査から，この検査は冗長であるが、永遠に保障されるわけではない
— 例えば、~SVGと~HTMLのある種の~ifcが収束するような，仕様の変更に直面したときなど。
◎
As of the time of this writing, every element that implements the HTMLElement interface is also in the HTML namespace, so this check is currently redundant with the above brand check. However, this is not guaranteed to be true forever in the face of potential specification changes, such as converging certain SVG and HTML interfaces.
</p>
					</li>
					<li>
%結果 の`局所~名$ ~NEQ %局所~名
◎
If result’s local name is not equal to localName, then throw a NotSupportedError.
</li>
				</ul>
			</li>
			<li>
%結果 の`~ns接頭辞$ ~SET %接頭辞
◎
Set result’s namespace prefix to prefix.
</li>
			<li>
%結果 の`~is0値$ ~SET ~NULL
◎
Set result’s namespace prefix to prefix.
</li>
		</ol>
<p>
(A)
— 上の手続きにて，例外が投出されたときは：
◎
If any of these steps threw an exception, then:
</p>

		<ol>
			<li>
`その例外を報告する$
◎
Report the exception.
</li>
			<li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$
</p>

<ul ><li>$HTMLUnknownElement ~ifcを実装する
</li><li>属性oは有さない
</li><li>`~ns$ ~SET `~HTML~ns$
</li><li>`~ns接頭辞$ ~SET %接頭辞
</li><li>`局所~名$ ~SET %局所~名
</li><li>`~custom要素~状態$ ~SET `failed^l
</li><li>`~custom要素~定義$ ~SET ~NULL
</li><li>`~is0値$ ~SET ~NULL
</li><li>`~node文書$ ~SET %文書
</li></ul>

◎
Set result to a new element that implements the HTMLUnknownElement interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "failed", custom element definition set to null, is value set to null, and node document set to document.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%定義 ~NEQ ~NULL
］：
◎
↑
◎
Otherwise:
</p>
		<ol>
			<li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$：
</p>

<ul ><li>$HTMLElement を実装する
</li><li>`属性o$は有さない
</li><li>`~ns$ ~SET `~HTML~ns$
</li><li>`~ns接頭辞$ ~SET %接頭辞 
</li><li>`局所~名$ ~SET %局所~名
</li><li>`~custom要素~状態$ ~SET `undefined^l
</li><li>`~custom要素~定義$ ~SET ~NULL
</li><li>`~is0値$ ~SET ~NULL
</li><li>`~node文書$ ~SET %文書
</li></ul>

◎
Set result to a new element that implements the HTMLElement interface, with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "undefined", custom element definition set to null, is value set to null, and node document set to document.
</li>
			<li>
`~custom要素~昇格~反応を待入れる$( %結果, %定義 )
◎
Enqueue a custom element upgrade reaction given result and definition.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~ifc ~LET 
( %局所~名, %~ns )
に`対応する要素~ifc$
◎
Let interface be the element interface for localName and namespace.
</li>
			<li>
<p>
%結果 ~SET 次のようにされた，新たな`要素$：
</p>

<ul ><li>%~ifc を実装する
</li><li>`属性o$は有さない
</li><li>`~ns$ ~SET %~ns
</li><li>`~ns接頭辞$ ~SET %接頭辞 
</li><li>`局所~名$ ~SET %局所~名
</li><li>`~custom要素~状態$ ~SET `uncustomized^l
</li><li>`~custom要素~定義$ ~SET ~NULL
</li><li>`~is0値$ ~SET %is
</li><li>`~node文書$ ~SET %文書
</li></ul>

◎
Set result to a new element that implements interface, with no attributes, namespace set to namespace, namespace prefix set to prefix, local name set to localName, custom element state set to "uncustomized", custom element definition set to null, is value set to is, and node document set to document.
</li>
			<li>
~IF［
次のいずれも満たされる
］…：

<ul ><li>%~ns ~EQ `~HTML~ns$
</li><li>［
%局所~名 は`妥当な~custom要素~名$である
］~OR［
%is ~NEQ ~NULL
］
</li></ul>

…ならば
⇒
%結果 の`~custom要素~状態$ ~SET `undefined^l
◎
If namespace is the HTML namespace, and either localName is a valid custom element name or is is non-null, then set result’s custom element state to "undefined".
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>


<p>
各`要素$は、
`属性o~list@
も持つ。
それは、`~list$であり，
$NamedNodeMap
<span class="trans-note">【
~objを返す $attributes 属性
】</span>
を通して公開される。
`要素$の作成-時に明示的に与えられない限り，その`属性o~list$は`空$listとする。
◎
Elements also have an attribute list, which is a list exposed through a NamedNodeMap. Unless explicitly given when an element is created, its attribute list is empty.
</p>

<p>
`要素$ %要素 が`属性o$ %A を
`有する@
とは、［
%A ~IN %要素 の`属性o~list$
］を意味する。
◎
An element has an attribute A if its attribute list contains A. 
</p>

<p>
`適用仕様$は、`要素$上の
`属性oを変更する手続き@
を定義して~MAY。
そのような~algoには、当の要素に加えて，
( %局所~名, %旧-値, %値, %~ns )
が渡される。
◎
This and other specifications may define attribute change steps for elements. The algorithm is passed element, localName, oldValue, value, and namespace.
</p>

<p class="algo-head">
`要素$ %要素 の
`属性oを変更する@
ときは、所与の
( `属性o$ %属性o, 文字列 %値  )
に対し，次を走らす：
◎
To change an attribute attribute from an element element to value, run these steps:
</p>

<ol>
	<li>
~Assert：
%要素 は %属性o を`有する$
`この段は、この訳による補完^tnote
</li>
	<li>
`変異~記録を待入する$( 次に与える変異~記録 )
⇒＃
~target : %要素,
種別 : `attributes^l,
名前 : %属性o の`局所~名$a,
~ns : %属性o の`~ns$,
旧-値 : %属性o の`値$a
◎
Queue a mutation record of "attributes" for element with name attribute’s local name, namespace attribute’s namespace, and oldValue attribute’s value.
</li>
	<li>
~IF［
%要素 は`~custom$である
］
⇒
`~custom要素~callback反応を待入れる$(
%要素,
`attributeChangedCallback^l,
« %属性o の`局所~名$, %属性o の`値$a, %値, %属性o の`~ns$ »
)
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute’s local name, attribute’s value, value, and attribute’s namespace.
</li>
	<li>
次を渡して，
%要素 上の`属性oを変更する手続き$を走らす
⇒
( %属性o の`局所~名$a, %属性o の`値$a, %値, %属性o の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, attribute’s value, value, and attribute’s namespace.
</li>
	<li>
%属性o の`値$a ~SET %値
◎
Set attribute’s value to value.
</li>
</ol>



<p class="algo-head">
`要素$ %要素 に
`属性oを付加する@
ときは、所与の
( `属性o$ %属性o )
に対し，次を走らす：
◎
To append an attribute attribute to an element element, run these steps:
</p>

<ol>
	<li>
~Assert：
%要素 は %属性o を`有さない$
`この段は、この訳による補完^tnote
</li>
	<li>
`変異~記録を待入する$( 次に与える変異~記録 )
⇒＃
~target : %要素,
種別 : `attributes^l,
名前 : %属性o の`局所~名$a,
~ns : %属性o の`~ns$,
旧-値 : null
◎
Queue a mutation record of "attributes" for element with name attribute’s local name, namespace attribute’s namespace, and oldValue null.
</li>
	<li>
~IF［
%要素 は`~custom$である
］
⇒
`~custom要素~callback反応を待入れる$(
%要素,
`attributeChangedCallback^l,
« %属性o の`局所~名$, ~NULL, %属性o の`値$a, %属性o の`~ns$ »
)
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute’s local name, null, attribute’s value, and attribute’s namespace.
</li>
	<li>
次を渡して，
%要素 上の`属性oを変更する手続き$を走らす
⇒
( %属性o の`局所~名$a, ~NULL, %属性o の`値$a, %属性o の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, null, attribute’s value, and attribute’s namespace.
</li>
	<li>
%属性o を %要素 の`属性o~list$に`付加-$listする
◎
Append the attribute to the element’s attribute list.
</li>
	<li>
%属性o が`属する要素$ ~SET %要素
◎
Set attribute’s element to element.
</li>
</ol>


<p class="algo-head">
`要素$ %要素 から
`属性oを除去する@
ときは、所与の
( `属性o$ %属性o )
に対し，次を走らす：
◎
To remove an attribute attribute from an element element, run these steps:
</p>

<ol>
	<li>
~Assert：
%要素 は %属性o を`有する$
`この段は、この訳による補完^tnote
</li>
	<li>
`変異~記録を待入する$( 次に与える変異~記録 )
⇒＃
~target : %要素,
種別 : `attributes^l,
名前 : %属性o の`局所~名$a,
~ns : %属性o の`~ns$,
旧-値 : %属性o の`値$a
◎
Queue a mutation record of "attributes" for element with name attribute’s local name, namespace attribute’s namespace, and oldValue attribute’s value.
</li>
	<li>
~IF［
%要素 は`~custom$である
］
⇒
`~custom要素~callback反応を待入れる$(
%要素,
`attributeChangedCallback^l,
« %属性o の`局所~名$, %属性o の`値$a, ~NULL, %属性o の`~ns$ »
)
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute’s local name, attribute’s value, null, and attribute’s namespace.
</li>
	<li>
次を渡して，
%要素 上の`属性oを変更する手続き$を走らす
⇒
( %属性o の`局所~名$a, %属性o の`値$a, ~NULL, %属性o の`~ns$a )
◎
Run the attribute change steps with element, attribute’s local name, attribute’s value, null, and attribute’s namespace.
</li>
	<li>
%要素 の`属性o~list$から %属性o を`除去-$listする
◎
Remove attribute from element’s attribute list.
</li>
	<li>
%属性o が`属する要素$ ~SET ~NULL
◎
Set attribute’s element to null.
</li>
</ol>

<hr>

<p class="algo-head">
`要素$ %要素 の
`属性oを置換する@
ときは、所与の
( `属性o$ %旧-属性o, `属性o$ %新-属性o )
に対し，次を走らす：
◎
To replace an attribute oldAttr by an attribute newAttr in an element element, run these steps:
</p>

<ol>
	<li>
~Assert：
%要素 は %旧-属性o を`有する$
`この段は、この訳による補完^tnote
</li>
	<li>
`変異~記録を待入する$( 次に与える変異~記録 )
⇒＃
~target : %要素,
種別 : `attributes^l,
名前 : %旧-属性o の`局所~名$a,
~ns : %旧-属性o の`~ns$a,
旧-値 : %旧-属性o の`値$a
◎
Queue a mutation record of "attributes" for element with name oldAttr’s local name, namespace oldAttr’s namespace, and oldValue oldAttr’s value.
</li>
	<li>
~IF［
%要素 は`~custom$である
］
⇒
`~custom要素~callback反応を待入れる$(
%要素,
`attributeChangedCallback^l,
« %旧-属性o の`局所~名$, %旧-属性o の`値$a, %新-属性o の`値$a, %旧-属性o の`~ns$ »
)
◎
If element is custom, then enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing oldAttr’s local name, oldAttr’s value, newAttr’s value, and oldAttr’s namespace.
</li>
	<li>
次を渡して，
%要素 上の`属性oを変更する手続き$を走らす
⇒
( %旧-属性o の`局所~名$a, %旧-属性o の`値$a, %新-属性o の`値$a, %旧-属性o の`~ns$a )
◎
Run the attribute change steps with element, oldAttr’s local name, oldAttr’s value, newAttr’s value, and oldAttr’s namespace.
</li>
	<li>
%要素 の`属性o~list$内の %旧-属性o を %新-属性o に`置換-$listする
◎
Replace oldAttr by newAttr in element’s attribute list.
</li>
	<li>
%旧-属性o が`属する要素$ ~SET ~NULL
◎
Set oldAttr’s element to null.
</li>
	<li>
%新-属性o が`属する要素$ ~SET %要素
◎
Set newAttr’s element to element.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性oを名前により取得する@
ときは、所与の
( %有修飾~名 )
に対し，次を走らす：
◎
To get an attribute by name given a qualifiedName and element element, run these steps:
</p>

<ol>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
%有修飾~名 ~LET %有修飾~名 を`~ASCII小文字~化$した結果
◎
If element is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII lowercase.
</li>
	<li>
~RET %要素 の`属性o~list$ 内の［
`有修飾~名$a ~EQ %有修飾~名
］なる`最初0$の`属性o$
◎
Return the first attribute in element’s attribute list whose qualified name is qualifiedName, and null otherwise.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性oを~nsと局所~名により取得する@
ときは、所与の
( %~ns, %局所~名 )
に対し、次を走らす：
◎
To get an attribute by namespace and local name given a namespace, localName, and element element, run these steps:
</p>

<ol>
	<!--cp-normalize-ns-->
	<li>
~RET %要素 の`属性o~list$ 内の，次を満たすような`最初0$の`属性o$
⇒
［
`~ns$a ~EQ %~ns
］~AND［
`局所~名$a ~EQ %局所~名
］
◎
Return the attribute in element’s attribute list whose namespace is namespace and local name is localName, if any, and null otherwise.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性o値を取得する@
ときは、所与の
( %局所~名,  %~ns （省略時は ~NULL ） )
に対し，次を走らす：
◎
To get an attribute value given an element element, localName, and optionally a namespace (null unless stated otherwise), run these steps:
</p>

<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %局所~名,  %~ns )
◎
Let attr be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~RET ［
%属性o ~EQ ~NULL ならば空~文字列 ／
~ELSE_ %属性o の`値$a
］
◎
If attr is null, then return the empty string.
◎
Return attr’s value.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性oを設定する@
するときは、所与の
( `属性o$ %属性o )
に対し，次を走らす：
◎
To set an attribute given an attr and element, run these steps:
</p>

<ol>
	<li>
~IF［
%属性o が`属する要素$ ~NIN { ~NULL, %要素 }
］
⇒
~THROW `InUseAttributeError$E
◎
If attr’s element is neither null nor element, throw an InUseAttributeError.
</li>
	<li>
%旧-属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %属性o の`~ns$a, %属性o の`局所~名$a )
◎
Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local name, and element.
</li>
	<li>
~IF［
%旧-属性o ~EQ %属性o
］
⇒
~RET %属性o
◎
If oldAttr is attr, return attr.
</li>
	<li>
~IF［
%旧-属性o ~NEQ ~NULL
］
⇒
%要素 の`属性oを置換する$( %旧-属性o, %属性o )
◎
If oldAttr is non-null, replace it by attr in element.
</li>
	<li>
~ELSE
⇒
%要素 に`属性oを付加する$( %属性o )
◎
Otherwise, append attr to element.
</li>
	<li>
~RET %旧-属性o
◎

Return oldAttr.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性o値を設定する@
ときは、所与の
( %局所~名, %値, %接頭辞 （省略時は ~NULL ）, %~ns （省略時は ~NULL ） )
に対し，次を走らす：
◎
To set an attribute value for an element element using a localName and value, and an optional prefix, and namespace, run these steps:
</p>

<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %~ns, %局所~名 )
◎
If prefix is not given, set it to null.
◎
If namespace is not given, set it to null.
◎
Let attribute be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒＃
%要素 の`属性oを変更する$( %属性o, %値 )；
~RET
◎
↓</li>
	<li>
<p>
%要素 に`属性oを付加する$( 次のように設定された 新たな`属性o$ )：
</p>

<ul><li>`~ns$a ~SET %~ns
</li><li>`~ns接頭辞$a ~SET %接頭辞
</li><li>`局所~名$a ~SET %局所~名
</li><li>`値$a ~SET %値
</li><li>`~node文書$ ~SET %要素 の`~node文書$
</li></ul>
◎
If attribute is null, create an attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, value is value, and node document is element’s node document, then append this attribute to element, and then return.
◎
Change attribute from element to value.
	</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性oを名前により除去する@
ときは、所与の
( %有修飾~名 )
に対し，次を走らす：
◎
To remove an attribute by name given a qualifiedName and element element, run these steps:
</p>

<ol>
	<li>
%属性o ~LET
%要素 の`属性oを名前により取得する$( %有修飾~名 )
◎
Let attr be the result of getting an attribute given qualifiedName and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
%要素 から`属性oを除去する$( %属性o )
◎
If attr is non-null, remove it from element.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>

<p class="algo-head">
`要素$ %要素 の
`属性oを~nsと局所~名により除去する@
ときは、所与の
( %~ns, %局所~名 )
に対し，次を走らす：
◎
To remove an attribute by namespace and local name given a namespace, localName, and element element, run these steps:
</p>

<ol>
	<li>
%属性o ~LET
%要素 の`属性oを~nsと局所~名により取得する$( %~ns, %局所~名 )
◎
Let attr be the result of getting an attribute given namespace, localName, and element.
</li>
	<li>
~IF［
%属性o ~NEQ ~NULL
］
⇒
%要素 から`属性oを除去する$( %属性o )
◎
If attr is non-null, remove it from element.
</li>
	<li>
~RET %属性o
◎
Return attr.
</li>
</ol>

<hr>

<p>
`要素$には、一意な識別子である
`~ID@
が結付けられ得る。
◎
An element can have an associated unique identifier (ID)
</p>
<p class="note">注記：
歴史的に，`要素$は複数の識別子を持ち得ていた。
例えば~HTML `id^A `属性o$nmと DTD を利用して。
この仕様では
`~ID$を~DOMの概念とし，`要素$につき `id^A `属性o$nmで与えられる 1 個に限るとする。
◎
Historically elements could have multiple identifiers e.g., by using the HTML id attribute and a DTD. This specification makes ID a concept of the DOM and allows for only one per element, given by an id attribute.
</p>

<p class="algo-head">
`要素$の`~ID$の更新~時に利用する，`属性oを変更する手続き$は、次で与えられる：
◎
Use these attribute change steps to update an element’s ID:
</p>

<ol>
	<li>
~IF［
%局所~名 ~EQ `id^l
］~AND［
%~ns ~EQ ~NULL
］~AND［
%値 ~IN { ~NULL, 空~文字列 }
］
⇒
%要素 の`~ID$を未設定にする
◎
If localName is id, namespace is null, and value is null or the empty string, then unset element’s ID.
</li>
	<li>
~ELIF［
%局所~名 ~EQ `id^l
］~AND［
%~ns ~EQ ~NULL
］
⇒
%要素 の`~ID$ ~SET %値
◎
Otherwise, if localName is id, namespace is null, then set element’s ID to value.
</li>
</ol>


<p class="note">注記：
この仕様は、どの`要素$に対しても，その［
^class, ^id, ^slot
］`属性o$nmに対する要件を定義しているが、これらの属性oを利用をするかどうかは，適合性の要件にしていない。
◎
While this specification defines requirements for class, id, and slot attributes on any element, it makes no claims as to whether using them is conforming or not.
</p>

<hr>

<p>
`~node$ %N の
`親~要素@
とは、［
%N の`親$が`要素$であるならば それ ／
~ELSE_ ~NULL
］である。
◎
A node’s parent of type Element is known as a parent element. If the node has a parent of a different type, its parent element is null.
</p>

<hr>

<dl class="domintro">
	<dt>%namespace = %element . $namespaceURI</dt>
	<dd>
`~ns$を返す。
◎
Returns the namespace.
</dd>

	<dt>%prefix = %element . $prefix</dt>
	<dd>
`~ns接頭辞$を返す。
◎
Returns the namespace prefix.
</dd>

	<dt>%localName = %element . $localName</dt>
	<dd>
`局所~名$を返す。
◎
Returns the local name.
</dd>

	<dt>%qualifiedName = %element . $tagName</dt>
	<dd>
`有修飾~名$を返す。
（ `~HTML文書$ においては返値は大文字~化される。）
◎
Returns the qualified name. (The return value is uppercased in an HTML document.)
</dd>
</dl>


<dl class="idl-def">
	<dt>@namespaceURI</dt>
	<dd>
取得子は、此れの`~ns$を返さ~MUST。
◎
The namespaceURI attribute’s getter must return the context object’s namespace.
</dd>

	<dt>@prefix</dt>
	<dd>
取得子は、此れの`~ns接頭辞$を返さ~MUST。
◎
The prefix attribute’s getter must return the context object’s namespace prefix.
</dd>

	<dt>@localName</dt>
	<dd>
取得子は、此れの`局所~名$を返さ~MUST。
◎
The localName attribute’s getter must return the context object’s local name.
</dd>

	<dt>@tagName</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The tagName attribute’s getter must run these steps:
</p>

		<ol>
			<li>
%有修飾~名 ~LET 此れの`有修飾~名$
◎
Let qualifiedName be context object’s qualified name.
</li>
			<li>
~IF［
此れは`~HTML~ns$に属する
］~AND［
此れの`~node文書$は`~HTML文書$である
］
⇒
~RET %有修飾~名 の`~ASCII大文字~化$
◎
If the context object is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII uppercase.
</li>
			<li>
~RET %有修飾~名
◎
Return qualifiedName.
</li>
		</ol>
	</dd>
</dl>

<hr>

<p class="algo-head">
`要素$ %要素 上の一部の~IDL属性は、所与の %名前 の`属性o$を
`反映-@
するように定義される。
すなわち、次に従うような取得子, 設定子を持た~MUST：
◎
IDL attributes that are defined to reflect a content attribute of a given name, must have a getter and setter that follow these steps:
</p>

<dl>
	<dt>取得子</dt>
	<dd>
~RET %要素 の`属性o値を取得する$( %名前 )
◎
Return the result of running get an attribute value given context object and name.
</dd>

	<dt>設定子</dt>
	<dd>
%要素 の`属性o値を設定する$( %名前, 所与の値 )
◎
Set an attribute value for the context object using name and the given value.
</dd>
</dl>


<dl class="idl-def">
	<dt>@id</dt>
	<dd>
`id^l 属性oを`反映-$し~MUST。
◎
The id attribute must reflect the "id" content attribute.
</dd>

	<dt>@className</dt>
	<dd>
`class^l 属性oを`反映-$し~MUST。
◎
The className attribute must reflect the "class" content attribute.
</dd>

	<dt>@classList</dt>
	<dd>
取得子は、次のようにされた $DOMTokenList を返さ~MUST
⇒＃
`要素$dtl ~SET 此れ,
`属性oの局所~名$dtl ~SET ^class
◎
↓</dd>
	<dd>
この属性が返す $DOMTokenList ~objの`~token集合$は、`要素$の
`~classes@
とも称される。
◎
The classList attribute’s getter must return a DOMTokenList object whose associated element is the context object and whose associated attribute’s local name is class. The token set of this particular DOMTokenList object are also known as the element’s classes.
</dd>
	<dd class="trans-note">【
[`SameObject$] が指定されているので、各~要素とこの~objの各~instanceは，一対一に対応する。
】</dd>

	<dt>@slot</dt>
	<dd>
`slot^l 属性oを`反映-$し~MUST。
◎
The slot attribute must reflect the "slot" content attribute.
</dd>
	<dd class="note">注記：
［
^id, ^class, ^slot
］`属性o$nmは、要素の~nsにかかわらず どの要素~上にも現れ得るので、実質的に，（すべての~nsより）上位の大域~属性になる。
◎
id, class, and slot are effectively superglobal attributes as they can appear on any element, regardless of that element’s namespace.
</dd>

	<dt>@hasAttributes()</dt>
	<dd>
被呼出時には、［
此れの`属性o~list$は`空$listならば ~F ／
~ELSE_ ~T
］を返さ~MUST。
◎
The hasAttributes() method, when invoked, must return false if context object’s attribute list is empty, and true otherwise.
</dd>

	<dt>@attributes</dt>
	<dd>
取得子は、此れに結付けられている $NamedNodeMap を返さ~MUST。
◎
The attributes attribute’s getter must return the associated NamedNodeMap.
</dd>

	<dt>@getAttributeNames()</dt>
	<dd>
被呼出時には、此れの`属性o~list$ %~list は［
`空$listでないならば［
%~list 内の各 `属性o$の`有修飾~名$a
］からなる同じ順序の`~list$ ／
~ELSE_ 新たな`~list$
］を返さ~MUST 
◎
The getAttributeNames() method, when invoked, must return the qualified names of the attributes in context object’s attribute list, in order, and a new list otherwise.
</dd>
	<dd class="note">注記：
一意になることは保障されない。
◎
These are not guaranteed to be unique.
</dd>

	<dt>@getAttribute(qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getAttribute(qualifiedName) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%属性o ~LET
此れの`属性oを名前により取得する$( %qualifiedName )
◎
Let attr be the result of getting an attribute given qualifiedName and the context object.
</li>
			<li>
~RET ［
%属性o ~EQ ~NULL ならば ~NULL ／
~ELSE_ %属性o の`値$a
］
◎
If attr is null, return null.
◎
Return attr’s value.
</li>
		</ol>
	</dd>

	<dt>@getAttributeNS(namespace, localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getAttributeNS(namespace, localName) method, when invoked, must these steps:
</p>
		<ol>
			<li>
%属性o ~LET
此れの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
Let attr be the result of getting an attribute given namespace, localName, and the context object.
</li>
			<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If attr is null, return null.
</li>
			<li>
~RET %属性o の`値$a
◎
Return attr’s value.
</li>
		</ol>
	</dd>

	<dt>@setAttribute(qualifiedName, value)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setAttribute(qualifiedName, value) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%qualifiedName は~XMLの `Name$prod 生成規則に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If qualifiedName does not match the Name production in XML, then throw an InvalidCharacterError.
</li>
			<li id="cp-to-lowercase-if-html">
~IF［
此れは`~HTML~ns$に属する
］~AND［
此れの`~node文書$は`~HTML文書$である
］
⇒
%qualifiedName ~SET %qualifiedName を`~ASCII小文字~化$した結果
◎
If the context object is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII lowercase.
</li>
			<li>
%属性o ~LET 此れの`属性o~list$内の［
`有修飾~名$a ~EQ %qualifiedName
］なる`属性o$のうち，`最初0$のもの
◎
Let attribute be the first attribute in context object’s attribute list whose qualified name is qualifiedName, and null otherwise.
</li>
			<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
此れに`属性oを付加する$( 次のように設定された 新たな`属性o$ )
⇒＃
`局所~名$a ~SET %qualifiedName,
`値$a ~SET %value,
`~node文書$ ~SET 此れの`~node文書$
◎
If attribute is null, create an attribute whose local name is qualifiedName, value is value, and node document is context object’s node document, then append this attribute to context object, and then return.
</li>
			<li>
~ELSE
⇒
此れの`属性oを変更する$( %属性o, %value )
◎
Change attribute from context object to value.
</li>
		</ol>
	</dd>

	<dt>@setAttributeNS(namespace, qualifiedName, value)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setAttributeNS(namespace, qualifiedName, value) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-validate-and-extract-->
			<li>
此れの`属性o値を設定する$( %局所~名, %value, %接頭辞, %~ns )
◎
Set an attribute value for the context object using localName, value, and also prefix and namespace.
</li>
		</ol>
	</dd>

	<dt>@removeAttribute(qualifiedName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`属性oを名前により除去する$( %qualifiedName )
<!-- ＊
and then return undefined.
 -->
◎
The removeAttribute(qualifiedName) method, when invoked, must remove an attribute given qualifiedName and the context object, and then return undefined.
</dd>

	<dt>@removeAttributeNS(namespace, localName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`属性oを~nsと局所~名により除去する$( %namespace, %localName )
<!-- ＊
and then return undefined.
-->
◎
The removeAttributeNS(namespace, localName) method, when invoked, must remove an attribute given namespace, localName, and context object, and then return undefined.
</dd>

	<dt>@hasAttribute(qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The hasAttribute(qualifiedName) method, when invoked, must run these steps:
</p>

		<ol>
			<!--cp-to-lowercase-if-html-->
			<li>
~RET ［
此れは［
`有修飾~名$a ~EQ %qualifiedName
］なる`属性o$を`有する$ならば ~T ／
~ELSE_ ~F
］
◎
Return true if the context object has an attribute whose qualified name is qualifiedName, and false otherwise.
</li>
		</ol>
	</dd>

	<dt>@hasAttributeNS(namespace, localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The hasAttributeNS(namespace, localName) method, when invoked, must run these steps:
</p>

		<ol>
			<!--cp-normalize-ns0-->
			<li>
~RET ［
此れは［
`~ns$a ~EQ %namespace
］~AND［
`局所~名$a ~EQ %localName 
］なる`属性o$を`有する$ならば ~T ／
~ELSE_ ~F
］
◎
Return true if the context object has an attribute whose namespace is namespace and local name is localName, and false otherwise.
</li>
		</ol>
	</dd>

	<dt>@getAttributeNode(qualifiedName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`属性oを名前により取得する$( %qualifiedName )
◎
The getAttributeNode(qualifiedName) method, when invoked, must return the result of getting an attribute given qualifiedName and context object.
</dd>

	<dt>@getAttributeNodeNS(namespace, localName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
The getAttributeNodeNS(namespace, localName) method, when invoked, must return the result of getting an attribute given namespace, localName, and the context object.
</dd>

	<dt>@setAttributeNode(attr)</dt>
	<dt>@setAttributeNodeNS(attr)</dt>
	<dd>
これらのいずれも，被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`属性oを設定する$( %attr )
◎
The setAttributeNode(attr) and setAttributeNodeNS(attr) methods, when invoked, must return the result of setting an attribute given attr and the context object.
</dd>

	<dt>@removeAttributeNode(attr)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeAttributeNode(attr) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%attr ~NIN 此れの`属性o~list$
］
⇒
~THROW `NotFoundError$E
◎
If context object’s attribute list does not contain attr, then throw a NotFoundError.
</li>
			<li>
此れから`属性oを除去する$( %attr )
◎
Remove attr from context object.
</li>
			<li>
~RET %attr
◎
Return attr.
</li>
		</ol>
	</dd>
</dl>

<dl class="domintro">

	<dt>var %shadow = %element . $attachShadow(init)</dt>
	<dd>
%element に対する`~shadow根$を作成した上で，それを返す。
◎
Creates a shadow root for element and returns it.
</dd>

	<dt>var %shadow = %element . $shadowRoot</dt>
	<dd>
%element の`~shadow根$elm %~shadow は非~NULL，かつ %~shadow の［
`~mode$sR ~EQ `open^l
］ならば %~shadow を返す。
他の場合は ~NULL を返す。
◎
Returns element’s shadow root, if any, and if shadow root’s mode is "open", and null otherwise.
</dl>

<dl class="idl-def">
	<dt>@attachShadow(init)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The attachShadow(init) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れの`~ns$ ~NEQ `~HTML~ns$
］
⇒
~THROW `NotSupportedError$E
◎
If context object’s namespace is not the HTML namespace, then throw a NotSupportedError.
</li>
			<li>
<p>
~IF［
此れの`局所~名$は 次のいずれにも該当しない
］
⇒
~THROW `NotSupportedError$E：
</p>

<ul ><li>`妥当な~custom要素~名$
</li><li>
`article^l,
`aside^l,
`blockquote^l,
`body^l,
`div^l,
`footer^l,
`h1^l,
`h2^l,
`h3^l,
`h4^l,
`h5^l,
`h6^l,
`header^l,
`nav^l,
`nav^l,
`p^l,
`section^l,
`span^l
</li></ul>

◎
If context object’s local name is not a valid custom element name, "article", "aside", "blockquote", "body", "div", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "header", "main" "nav", "p", "section", or "span", then throw a NotSupportedError.
</li>
			<li>
~IF［
此れは`~shadow~host$である
］
⇒
~THROW `InvalidStateError$E
◎
If context object is a shadow host, then throw an InvalidStateError.
</li>
			<li>
<p >
%~shadow ~LET 次のようにされた，新たな`~shadow根$
</p>

<ul ><li>`~node文書$ ~SET 此れの`~node文書$
</li><li>`~host$ ~SET 此れ
</li><li>`~mode$sR ~SET %init の $ShadowRootInit.mode
</li></ul>

◎
Let shadow be a new shadow root whose node document is context object’s node document, host is context object, and mode is init’s mode.
</li>
			<li>
此れの`~shadow根$elm ~SET %~shadow
◎
Set context object’s shadow root to shadow.
</li>
			<li>
~RET %~shadow
◎
Return shadow.
</li>
		</ol>
	</dd>

	<dt>@shadowRoot</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The shadowRoot attribute’s getter must run these steps:
</p>
		<ol>
			<li>
%~shadow ~LET 此れの `~shadow根$elm
◎
Let shadow be context object’s shadow root.
</li>
			<li>
~IF［
%~shadow ~EQ ~NULL
］~OR［
%~shadow の`~mode$sR ~EQ `closed^l
］
⇒
~RET ~NULL
◎
If shadow is null or its mode is "closed", then return null.
</li>
			<li>
~RET %~shadow
◎
Return shadow.
</li>
		</ol>
	</dd>
</dl>

<hr>

<dl class="domintro">

	<dt>%element . $closest(selectors)</dt>
	<dd>
%element の`広義先祖$であって,  %selectors に合致するような`要素$が［
在れば，それらのうち %element に最も近いもの ／
無ければ ~NULL
］を返す。
◎
Returns the first (starting at element) inclusive ancestor that matches selectors, and null otherwise.
</dd>

	<dt>%element . $matches(selectors)</dt>
	<dd>
%element の`根$に対し %selectors を照合した結果，［
%element が得られるならば ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if matching selectors against element’s root yields element, and false otherwise.
</dd>

</dl>


<dl class="idl-def">
	<dt>@closest(selectors)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The closest(selectors) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%選択子 ~LET `選択子として構文解析する$( %selectors )
`SELECTORS4$r
◎
Let s be the result of parse a selector from selectors. [SELECTORS4]
</li>
			<li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If s is failure, throw a SyntaxError.
</li>
			<li>
%要素 ~LET 此れ
◎
↓</li>
			<li>
<p>
~WHILE［
%要素 は`要素$である
］：
</p>
				<ol>
					<li>
~IF［
`要素に対し選択子を照合する$( %要素, %選択子, 此れのみからなる`~scope-ps要素$の集合 ) ~EQ `成功^i
］
⇒
~RET %要素
</li>
					<li>
%要素 ~SET %要素 の`親$
</li>
				</ol>
`SELECTORS4$r

◎
Let elements be context object’s inclusive ancestors that are elements, in reverse tree order.
◎
For each element in elements, if match a selector against an element, using s, element, and :scope element context object, returns success, return element. [SELECTORS4]
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</dd>

	<dt>@matches(selectors)</dt>
	<dt>@webkitMatchesSelector(selectors)</dt>
	<dd>
<p>
これらのいずれも，被呼出時には、次を走らせ~MUST：
◎
The matches(selectors) and webkitMatchesSelector(selectors) methods, when invoked, must run these steps:
</p>

		<ol>
			<li>
%選択子 ~LET `選択子として構文解析する$( %selectors )
`SELECTORS4$r
◎
Let s be the result of parse a selector from selectors. [SELECTORS4]
</li>
			<li>
~IF［
%選択子 ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If s is failure, throw a SyntaxError.
</li>
			<li>
~RET ［
`要素に対し選択子を照合する$( 此れ†, %選択子, 此れのみからなる`~scope-ps要素$の集合 ) ~EQ `成功^i ならば~T ／
~ELSE_ ~F
］
`SELECTORS4$r
◎
Return true if the result of match a selector against an element, using s, element, and :scope element context object, returns success, and false otherwise. [SELECTORS4] 
</li>
		</ol>

<p class="trans-note">【†<!-- ＊ -->
原文は 2 個目の“此れ” の代わりに~~未定義の変数 “%element” が記されているが、誤記と見られる。
】</p>

	</dd>

	<dt>@getElementsByTagName(qualifiedName)</dt>
	<dd>
被呼出時には、此れに対する， %qualifiedName を`有修飾~名に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagName(qualifiedName) method, when invoked, must return the list of elements with qualified name qualifiedName for the context object.
</dd>

	<dt>@getElementsByTagNameNS(namespace, localName)</dt>
	<dd>
被呼出時には、此れに対する，
( %namespace, %localName )
を
`( ~ns, 局所~名 ) に持つ要素の~list$を返さ~MUST。
◎
The getElementsByTagNameNS(namespace, localName) method, when invoked, must return the list of elements with namespace namespace and local name localName for context object.
</dd>

	<dt>@getElementsByClassName(classNames)</dt>
	<dd>
被呼出時には、此れに対する，
%classNames を`~classesに含む要素の~list$を返さ~MUST。
◎
The getElementsByClassName(classNames) method, when invoked, must return the list of elements with class names classNames for context object.
</dd>
</dl>

<hr>

<p class="algo-head">
文字列 %where が与えられた下で，`~node$ %~node を`要素$ %要素 の
`隣に挿入-@
するときは、 %where を`~ASCII小文字~化$した結果に応じて：
◎
To insert adjacent, given an element element, string where, and a node node, run the steps associated with the first ASCII case-insensitive match for where:
</p>

<dl class="switch">
	<dt>`beforebegin^l</dt>
	<dd>
		<ol>
			<li>
~IF［
%要素 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If element’s parent is null, return null.
</li>
			<li>
~RET %要素 の`親$の中で， %~node を %要素 の前に`前挿入$した結果
◎
Return the result of pre-inserting node into element’s parent before element.
</li>
		</ol>
	</dd>

	<dt>`afterbegin^l</dt>
	<dd>
		<ol>
			<li>
~RET %要素 の中で， %~node を %要素 の`最初0の子$ の前に`前挿入$した結果
◎
Return the result of pre-inserting node into element before element’s first child.
</li>
		</ol>
	</dd>

	<dt>`beforeend^l</dt>
	<dd>
		<ol>
			<li>
~RET %要素 の中で， %~node を ~NULL の前に`前挿入$した結果
◎
Return the result of pre-inserting node into element before null.
</li>
		</ol>
	</dd>

	<dt>`afterend^l</dt>
	<dd>
		<ol>
			<li>
~IF［
%要素 の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If element’s parent is null, return null.
</li>
			<li>
~RET %要素 の`親$ の中で， %~node を %要素 の`弟$ の前に`前挿入$した結果
◎
Return the result of pre-inserting node into element’s parent before element’s next sibling.
</li>
		</ol>
	</dd>

	<dt>その他</dt>
	<dd>
		<ol>
			<li>
~THROW `SyntaxError$E
◎
Throw a SyntaxError.
</li>
		</ol>
	</dd>
</dl>


<dl class="idl-def">
	<dt>@insertAdjacentElement(where, element)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The insertAdjacentElement(where, element) method, when invoked, must
</p>

		<ol>
			<li>
~RET
%where を与える下で， %element を此れの`隣に挿入-$した結果
◎
return the result of running insert adjacent, given context object, where, and element.
</li>
		</ol>
	</dd>

	<dt>@insertAdjacentText(where, data)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The insertAdjacentText(where, data) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%text ~LET `新たな~Text~node$( %data, 此れの`~node文書$ )
◎
Let text be a new Text node whose data is data and node document is context object’s node document.
</li>
			<li>
%where を与える下で， %text を此れの`隣に挿入-$する
◎
Run insert adjacent, given context object, where, and text.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
この~methは何も返さない
— それを設計しようとする前からすでに存在していたので。
◎
This method returns nothing because it existed before we had a chance to design it.
</dd>
</dl>

<p class="trans-note">【
参考：
`insertAdjacentHTML()$m `DOM-Parsing$r という同類の便利~methもある。
】</p>


			<section id="interface-namednodemap">
<h4>4.9.1 ~ifc ^@NamedNodeMap</h4>

⇒！
[`Exposed$=Window,
 `LegacyUnenumerableNamedProperties$]
interface @NamedNodeMap {
  ~RA ~UL $length;
  getter $Attr? $item(~UL %index);
  getter $Attr? $getNamedItem(~DS %qualifiedName);
  $Attr? $getNamedItemNS(~DS? %namespace, ~DS %localName);
  [`CEReactions$] $Attr? $setNamedItem($Attr %attr);
  [`CEReactions$] $Attr? $setNamedItemNS($Attr %attr);
  [`CEReactions$] $Attr $removeNamedItem(~DS %qualifiedName);
  [`CEReactions$] $Attr $removeNamedItemNS(~DS? %namespace, ~DS %localName);
};
◎

<div class="p">
<p>
各 $NamedNodeMap ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`要素@nm</dt>
	<dd>
`要素$。
</dd>
</dl>
◎
A NamedNodeMap has an associated element (an element).
</div>

<p>
$NamedNodeMap ~objの
`属性o~list@nm
とは、~objの`要素$nmの`属性o~list$である。
◎
A NamedNodeMap object’s attribute list is its element’s attribute list.
</p>

<hr>

<p>
$NamedNodeMap ~obj %O の`被support ~prop~index$は、
0 以上［
%O の`属性o~list$nmの`~size$list
］未満とする。
◎
A NamedNodeMap object’s supported property indices are the numbers in the range zero to its attribute list’s size minus one, unless the attribute list is empty, in which case there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、此れの`属性o~list$nmの`~size$listを返さ~MUST。
◎
The length attribute’s getter must return the attribute list’s size.
</dd>

	<dt>@item(index)</dt>
	<dd>
被呼出時には、［
%index ~NIN { 此れの`被support ~prop~index$ } ならば~NULL ／
~ELSE_  此れの`属性o~list$nm[ %index ]
］を返さ~MUST。
◎
The item(index) method, when invoked, must run these steps:
• If index is equal to or greater than context object’s attribute list’s size, then return null.
• Otherwise, return context object’s attribute list[index].
</dd>
</dl>

<p>
$NamedNodeMap ~obj %O の`被support ~prop名$は、次の手続きの結果で与えられる：
◎
A NamedNodeMap object’s supported property names are the return value of running these steps:
</p>

<ol>
	<li>
%名前~list ~LET %O の`属性o~list$nm 内の各［
`属性o$の`有修飾~名$a
］からなる，同順の~list
◎
Let names be the qualified names of the attributes in this NamedNodeMap object’s attribute list, with duplicates omitted, in order.
</li>
	<li>
%要素 ~LET %O の`要素$nm
◎
↓</li>
	<li>
~IF［
%要素 は`~HTML~ns$に属する
］~AND［
%要素 の`~node文書$は`~HTML文書$である
］
⇒
%名前~list 内の~EACH ( %名前 ) に対し
⇒
~IF［
%名前 を`~ASCII小文字~化$した結果 ~NEQ %名前
］
⇒
%名前 を %名前~list から除去する
◎
If this NamedNodeMap object’s element is in the HTML namespace and its node document is an HTML document, then for each name in names:
• Let lowercaseName be name, in ASCII lowercase.
• If lowercaseName is not equal to name, remove name from names.
</li>
	<li>
~RET %名前~list
◎
Return names.
</li>
</ol>


<dl class="idl-def">
	<dt>@getNamedItem(qualifiedName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`要素$nmの`属性oを名前により取得する$( %qualifiedName )
◎
The getNamedItem(qualifiedName) method, when invoked, must return the result of getting an attribute given qualifiedName and element.
</dd>

	<dt>@getNamedItemNS(namespace, localName)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`要素$nmの`属性oを~nsと局所~名により取得する$( %namespace, %localName )
◎
The getNamedItemNS(namespace, localName) method, when invoked, must return the result of getting an attribute given namespace, localName, and element.
</dd>

	<dt>@setNamedItem(attr)</dt>
	<dt>@setNamedItemNS(attr)</dt>
	<dd>
これらのいずれも，被呼出時には、次を走らせ~MUST
⇒
~RET 此れの`要素$nmの`属性oを設定する$( %attr )
◎
The setNamedItem(attr) and setNamedItemNS(attr) methods, when invoked, must return the result of setting an attribute given attr and element.
</dd>

	<dt>@removeNamedItem(qualifiedName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeNamedItem(qualifiedName) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%属性o ~LET 此れの`要素$nmの`属性oを名前により除去する$( %qualifiedName )
◎
Let attr be the result of removing an attribute given qualifiedName and element.
</li>
			<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~THROW `NotFoundError$E
◎
If attr is null, then throw a NotFoundError.
</li>
			<li>
~RET %属性o
◎
Return attr.
</li>
		</ol>
	</dd>

	<dt>@removeNamedItemNS(namespace, localName)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The removeNamedItemNS(namespace, localName) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%属性o ~LET
此れの`要素$nmの`属性oを~nsと局所~名により除去する$( %namespace, %localName )
◎
Let attr be the result of removing an attribute given namespace, localName, and element.
</li>
			<li>
~IF［
%属性o ~EQ ~NULL
］
⇒
~THROW `NotFoundError$E
◎
If attr is null, then throw a NotFoundError.
</li>
			<li>
~RET %属性o
◎
Return attr.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="interface-attr">
<h4>4.9.2. ~ifc ^@Attr</h4>

⇒！
[`Exposed$=Window]
interface @Attr : $Node {
  ~RA ~DS? $namespaceURI;
  ~RA ~DS? $prefix;
  ~RA ~DS $localName;
  ~RA ~DS $name;
  [`CEReactions$] attribute ~DS $value;

  ~RA Element? $ownerElement;

  ~RA ~B $specified; // <!--cp-useless-true-->
};
◎

<p>
$Attr `~node$は、単に
`属性o@
とも称される
— ~IDL属性と区別するため、内容~属性とも称される。
`この訳では， “°” を付けて “属性o” と記すことにする^tnote
◎
Attr nodes are simply known as attributes. They are sometimes referred to as content attributes to avoid confusion with IDL attributes.
</p>


<div class="p">
<p>
各 `属性o$は、次に挙げるものを持つ：
</p>

<dl class="def-list">
	<dt>`~ns@a</dt>
	<dd>
~NULL または 空でない文字列
</dd>

	<dt>`~ns接頭辞@a</dt>
	<dd>
~NULL  または 空でない文字列
</dd>

	<dt>`局所~名@a</dt>
	<dd>
空でない文字列
</dd>

	<dt>`値@a</dt>
	<dd>
文字列
</dd>

	<dt>`属する要素@</dt>
	<dd>
~NULL または`要素$
</dd>
</dl>
◎
Attributes have a namespace
(null or a non-empty string), namespace prefix
(null or a non-empty string), local name
(a non-empty string), value
(a string), and element
(null or an element).
</div>

<p class="note">注記：
今 設計するなら、単に［
名前, 値
］のみを持つ様にする所 ☹
◎
If designed today they would just have a name and value. ☹
</p>

<p>
`属性o$ %A の
`有修飾~名@a
は、 %A の`~ns接頭辞$a %接頭辞 に応じて，［
~NULL ならば %A の`局所~名$a ／
非 ~NULL ならば［
%接頭辞, `:^l, %A の`局所~名$a
］の並び
］になる。
◎
An attribute’s qualified name is its local name if its namespace prefix is null, and its namespace prefix, followed by ":", followed by its local name, otherwise.
</p>

<!--cp-for-readbility-->

<p>
`属性o$が作成されるときは、その`局所~名$aが与えられる。
`属性o$の作成-時に明示的に与えられない限り，他のものは次のように設定される
⇒
( `~ns$a, `~ns接頭辞$a, `属する要素$, `値$a )
~SET
( ~NULL, ~NULL, ~NULL, 空~文字列 )
◎
When an attribute is created, its local name is given. Unless explicitly given when an attribute is created, its namespace, namespace prefix, and element are set to null, and its value is set to the empty string.
</p>

<p>
文字列 %A に対する
<dfn id="concept-named-attribute">%A 属性o</dfn>
という~~表記は、次を満たす `属性o$を意味する
⇒
( `局所~名$a, `~ns$a, `~ns接頭辞$a )
~EQ
( %A, ~NULL, ~NULL )
◎
An A attribute is an attribute whose local name is A and whose namespace and namespace prefix are null.
</p>

<hr>

<dl class="idl-def">
	<dt>@namespaceURI</dt>
	<dd>
取得子は、此れの`~ns$aを返さ~MUST。
◎
The namespaceURI attribute’s getter must return the namespace.
</dd>

	<dt>@prefix</dt>
	<dd>
取得子は、此れの`~ns接頭辞$aを返さ~MUST。
◎
The prefix attribute’s getter must return the namespace prefix.
</dd>

	<dt>@localName</dt>
	<dd>
取得子は、此れの`局所~名$aを返さ~MUST。
◎
The localName attribute’s getter must return the local name.
</dd>

	<dt>@name</dt>
	<dd>
取得子は、此れの`有修飾~名$aを返さ~MUST。
◎
The name attribute’s getter must return the qualified name.
</dd>
</dl>


<p class="algo-head">
`既存の属性o値を設定する@
ときは、所与の
( `属性o$ %属性o, 文字列 %値 )
に対し，次を走らす：
◎
The value attribute’s getter must return the value.
◎
To set an existing attribute value, given an attribute attribute and string value, run these steps:
</p>

<ol>
	<li>
~IF［
%属性o が`属する要素$ ~EQ ~NULL
］
⇒
%属性o の`値$a ~SET %値
◎
If attribute’s element is null, then set attribute’s value to value.
</li>
	<li>
~ELSE
⇒
%属性o が`属する要素$の`属性oを変更する$( %属性o, %値 )
◎
Otherwise, change attribute from attribute’s element to value. 
</li>
</ol>

<dl class="idl-def">
	<dt>@value</dt>
	<dd>
取得子は、此れの`値$aを返さ~MUST。
◎
↑↑</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
`既存の属性o値を設定する$( 此れ, 所与の値 )
◎
The value attribute’s setter must set an existing attribute value with context object and the given value.
</dd>

	<dt>@ownerElement</dt>
	<dd>
取得子は、此れが`属する要素$を返さ~MUST。
◎
The ownerElement attribute’s getter must return context object’s element.
</dd>

	<dt>@specified</dt>
	<dd>
取得子は、~T を返さ~MUST。
◎
The specified attribute’s getter must return true.
</dd>
</dl>

			</section>
		</section>
		<section id="interface-characterdata">
<h3>4.10. ~ifc ^@CharacterData</h3>

⇒！
[`Exposed$=Window]
interface @CharacterData : $Node {
  attribute [`TreatNullAs$=EmptyString] ~DS $data;
  ~RA ~UL $length;
  ~DS $substringData(~UL %offset, ~UL %count);
  void $appendData(~DS %data);
  void $insertData(~UL %offset, ~DS %data);
  void $deleteData(~UL %offset, ~UL %count);
  void $replaceData(~UL %offset, ~UL %count, ~DS %data);
};
◎

<p class="note">注記：
$CharacterData は抽象~ifcであり，`~node$として存在するものではない。
それは［
$Text, $ProcessingInstruction, $Comment
］`~node$から利用される。
◎
CharacterData is an abstract interface and does not exist as node. It is used by Text, ProcessingInstruction, and Comment nodes.
</p>

<p>
この~ifcを継承する~ifcを実装する`~node$を総称して，
`文字~data~node@
という（すなわち，
$Text （ $CDATASection も含む）, $ProcessingInstruction, $Comment
）。
</p>

<p class="trans-note">【
この用語は、簡潔に記述するために，この訳に導入した非公式な用語である。
（機能上は異なるものだが）多くの処理で，これらは同等に扱われるので。
】</p>

<div class="p">
<p>
各 `文字~data~node$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~data@</dt>
	<dd>
変異可能な文字列。
</dd>
</dl>
◎
Each node inheriting from the CharacterData interface has an associated mutable string called data.
</div>


<p class="algo-head">
`文字~data~node$ %node の
`~dataを置換する@
ときは、所与の
( %offset, %count, %data )
に対し，次を走らす：
◎
To replace data of node node with offset offset, count count, and data data, run these steps:
</p>

<ol>
	<li id="cp-let-node-length">
%長さ ~LET %node の`長さ$
◎
Let length be node’s length.
</li>
	<li id="cp-throw-size-err">
~IF［
%offset ~GT %長さ
］
⇒
~THROW `IndexSizeError$E
◎
If offset is greater than length, then throw an IndexSizeError.
</li>
	<li>
~IF［
%offset ~PLUS %count ~GT %長さ
］
⇒
%count ~SET %長さ ~MINUS %offset
◎
If offset plus count is greater than length, then set count to length minus offset.
</li>
	<li>
`変異~記録を待入する$( 次に与える変異~記録 )
⇒＃
~target : %node,
種別 : `characterData^l,
旧-値 : %node の`~data$
◎
Queue a mutation record of "characterData" for node with oldValue node’s data.
</li>
	<li>
%挿入点 ~LET %node の`~data$の中の， %offset 個目の`符号単位$の直後を指す位置（ %offset ~EQ 0 は先頭を指す）
◎
↓</li>
	<li>
%挿入点 から末尾側に在る %count 個の`符号単位$を除去する
◎
↓</li>
	<li>
%挿入点 に %data を挿入する
◎
Insert data into node’s data after offset code units.
◎
Let delete offset be offset plus the number of code units in data.
◎
Starting from delete offset code units, remove count code units from node’s data.
</li>
	<li>
%差分 ~LET %data に含まれている`符号単位$の個数 ~MINUS %count
◎
↓</li>
	<li>
<p>
~EACH ( `範囲o$ %R ) に対し：
</p>
		<ol>
			<li>
<p>
~IF［
%R の`始端~node$ ~EQ %node
］：
</p>
				<ol>
					<li>
~IF［
%offset ~LT %R の`始端~offset$ ~LTE %offset ~PLUS %count
］
⇒
%R の`始端~offset$ ~SET %offset
</li>
					<li>
~IF［
%R の`始端~offset$ ~GT %offset ~PLUS %count
］
⇒
%R の`始端~offset$ ~INCBY %差分
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%R の`終端~node$ ~EQ %node
］：
</p>
				<ol>
					<li>
<p>
~IF［
%offset ~LT %R の`終端~offset$ ~LTE %offset ~PLUS %count
］
⇒
%R の`終端~offset$ ~SET %offset
</p>

<p class="trans-note">【
%R の終端がちょうど置換される~~範囲の末尾を指している場合も，終端は置換した~~範囲の先頭に “寄せられる” ことになる。
】</p>

					</li>
					<li>
~IF［
%R の`終端~offset$ ~GT %offset ~PLUS %count
］
⇒
%R の`終端~offset$ ~INCBY %差分
</li>
				</ol>
			</li>
		</ol>
◎
For each range whose start node is node and start offset is greater than offset but less than or equal to offset plus count, set its start offset to offset.
◎
For each range whose end node is node and end offset is greater than offset but less than or equal to offset plus count, set its end offset to offset.
◎
For each range whose start node is node and start offset is greater than offset plus count, increase its start offset by the number of code units in data, then decrease it by count.
◎
For each range whose end node is node and end offset is greater than offset plus count, increase its end offset by the number of code units in data, then decrease it by count.
</li>
	<li>
~IF［
%node は $Text ~nodeである
］~AND［
%node の`親$ ~NEQ ~NULL
］
⇒
%node の`親$に対する`子~text内容~変更-時の手続き$を走らす
◎
If node is a Text node and its parent is not null, run the child text content change steps for node’s parent.
</li>
</ol>

<p class="algo-head">
`~node$ %node から
`~dataの部分文字列@
を得るときは、所与の
( %offset, %count )
に対し，次を走らす：
◎
To substring data with node node, offset offset, and count count, run these steps:
</p>

<ol>
	<!--cp-let-node-length-->
	<!--cp-throw-size-err-->
	<li>
~IF［
%offset ~PLUS %count ~GT %長さ
］
⇒
%count ~LET %長さ ~MINUS %offset
◎
If offset plus count is greater than length, return a string whose value is the code units from the offsetth code unit to the end of node’s data, and then return.
</li>
	<li>
~RET 
%node の`~data$の［
%offset 個目の`符号単位$の直後（ %offset ~EQ 0 なら先頭）から，
%count 個の`符号単位$
］並びからなる文字列
◎
Return a string whose value is the code units from the offsetth code unit to the offset+countth code unit in node’s data.
</li>
</ol>

<dl class="idl-def">
	<dt>@data</dt>
	<dd>
取得子は、此れの`~data$を返さ~MUST。
◎
The data attribute’s getter must return context object’s data.＼
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
此れの`~dataを置換する$( 0, 此れの`長さ$, 所与の値 )
◎
Its setter must replace data with node context object, offset 0, count context object’s length, and data new value.
</dd>

	<dt>@length</dt>
	<dd>
取得子は、此れの`長さ$を返さ~MUST。
◎
The length attribute’s getter must return context object’s length.
</dd>

	<dt>@substringData(offset, count)</dt>
	<dd>
被呼出時には、此れの`~dataの部分文字列$( %offset, %count )
を返さ~MUST
◎
The substringData(offset, count) method, when invoked, must return the result of running substring data with node context object, offset offset, and count count.
</dd>

	<dt>@appendData(data)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`~dataを置換する$( 此れの`長さ$, 0, %data )
◎
The appendData(data) method, when invoked, must replace data with node context object, offset context object’s length, count 0, and data data.
</dd>

	<dt>@insertData(offset, data)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`~dataを置換する$( %offset, 0, %data )
◎
The insertData(offset, data) method, when invoked, must replace data with node context object, offset offset, count 0, and data data.
</dd>

	<dt>@deleteData(offset, count)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`~dataを置換する$( %offset, %count, 空~文字列 )
◎
The deleteData(offset, count) method, when invoked, must replace data with node context object, offset offset, count count, and data the empty string.
</dd>

	<dt>@replaceData(offset, count, data)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`~dataを置換する$( %offset, %count, %data )
◎
The replaceData(offset, count, data) method, when invoked, must replace data with node context object, offset offset, count count, and data data.
</dd>
</dl>

		</section>
		<section id="interface-text">
<h3>4.11. ~ifc ^@Text</h3>

⇒！
[$Constructor(optional ~DS %data = ""),
 `Exposed$=Window]
interface @Text : $CharacterData {
  [`NewObject$] $Text $splitText(~UL %offset);
  ~RA ~DS $wholeText;
};
◎

<hr>

<dl class="domintro">
	<dt>var %text = new $Text([data = ""])</dt>
	<dd>
`~data$が %data にされた，新たな $Text `~node$を返す。
◎
Returns a new Text node whose data is data.
</dd>

	<dt>%text . $splitText(offset)</dt>
	<dd>
所与の %offset の地点で`~data$を分割し，残りの部分を $Text `~node$として返す。
◎
Splits data at the given offset and returns the remainder as Text node.
</dd>

	<dt>%text . $wholeText</dt>
	<dd>
隣接するすべての`同胞$ $Text `~node$の`~data$を連結した結果を返す。
◎
Returns the combined data of all direct Text node siblings.
</dd>

</dl>

<hr>

<p>
`新たな~Text~node@( %文字列, %文書 )
という表記は、次のように設定された 新たな $Text `~node$を意味する
⇒
( `~data$, `~node文書$ ) ~SET ( %文字列, %文書 )
</p>

<p class="trans-note">【
この表記は、簡潔に記述するため，この訳に導入したものである。
】</p>

<p>
`狭義の~Text~node@
とは、 $CDATASection `~node$でない $Text `~node$である。
◎
An exclusive Text node is a Text node that is not a CDATASection node.
</p>

<p>
~node %~node を含む
`連続的な~Text~node列@
とは、条件［
$Text `~node$である
］を満たす， %~node を含む`連続的な同胞~列$である。
◎
The contiguous Text nodes of a node node are node, node’s previous sibling Text node, if any, and its contiguous Text nodes, and node’s next sibling Text node, if any, and its contiguous Text nodes, avoiding any duplicates.
</p>

<p>
~node %~node を含む
`連続的な狭義の~Text~node列@
とは、条件［
`狭義の~Text~node$である
］を満たす， %~node を含む`連続的な同胞~列$である。
◎
The contiguous exclusive Text nodes of a node node are node, node’s previous sibling exclusive Text node, if any, and its contiguous exclusive Text nodes, and node’s next sibling exclusive Text node, if any, and its contiguous exclusive Text nodes, avoiding any duplicates.
</p>

<p class="trans-note">【
この訳では、次の手続きを導入して，原文による “連続的な…” の（再帰的な）定義を、等価な（かつ平坦化された平易な）定義に変形している。
】</p>

<div>

<p class="algo-head">
条件 %条件 を満たす， %~node を含む
`連続的な同胞~列@
は、次を走らせた結果で与えられる：
</p>

<ol>
	<li>
~Assert：
%~node は %条件 を満たす
</li>
	<li>
~WHILE［
%~node の`兄$は %条件 を満たす
］
⇒
%~node ~SET %~node の`兄$
</li>
	<li>
%~list ~LET 空~list
</li>
	<li>
<p>
~WHILE［
%~node は %条件 を満たす
］：
</p>
		<ol>
			<li>
%~node を %~list に付加する
</li>
			<li>
%~node ~SET %~node の`弟$
</li>
		</ol>
	</li>
	<li>
~RET %~list
</li>
</ol>

◎
↑</div>

<p class="algo-head">
`~node$ %~node の
`子~text内容@
は、
%~node の`子$である $Text ~nodeすべての`~data$を，`木~順序$で連結した結果である。
◎
The child text content of a node node is the concatenation of the data of all the Text node children of node, in tree order. 
</p>

<p>
`適用仕様$は、`~node$に対する
`子~text内容~変更-時の手続き@
を定義して~MAY。
◎
This and other specifications may define child text content change steps
for nodes. 
</p>

<hr>

<dl class="idl-def">
	<dt>@Text(data)</dt>
	<dd>
この構築子の被呼出時には、`新たな~Text~node$( %data, `現在の大域~obj$に`結付けられている文書$ )
を返さ~MUST
◎
The Text(data) constructor, when invoked, must return a new Text node whose data is data and node document is current global object’s associated Document.
</dd>
</dl>

<p class="algo-head">
$Text `~node$ %node を
~offset %offset の所で
`分割-@
するときは、次を走らす：
◎
To split a Text node node with offset offset, run these steps:
</p>

<ol>
	<!--cp-let-node-length-->
	<!--cp-throw-size-err-->
	<li>
%count ~LET %長さ ~MINUS %offset
◎
Let count be length minus offset.
</li>
	<li>
%新-~data ~LET
此れの`~dataの部分文字列$( %offset, %count )
◎
Let new data be the result of substringing data with node node, offset offset, and count count.
</li>
	<li>
%新-~node ~LET `新たな~Text~node$( %新-~data, %node の`~node文書$ )
◎
Let new node be a new Text node, with the same node document as node. Set new node’s data to new data.
</li>
	<li>
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>
	<li>
<p>
~IF［
%親 ~NEQ ~NULL
］：
◎
If parent is not null, then:
</p>
		<ol>
			<li>
%親 の中で， %新-~node を %node の`弟$の前に`挿入-$する
◎
Insert new node into parent before node’s next sibling.
</li>
			<li>
<p>
~EACH ( `範囲o$ %R ) に対し：
◎
↓</p>
				<ol>
					<li>
~IF［
%R の`始端~node$ ~EQ %node
］~AND［
%R の`始端~offset$ ~GT %offset
］
⇒＃
%R の`始端~node$ ~SET %新-~node；
%R の`始端~offset$ ~DECBY %offset
◎
For each range whose start node is node and start offset is greater than offset, set its start node to new node and decrease its start offset by offset.
</li>
					<li>
~IF［
%R の`終端~node$ ~EQ %node
］~AND［
%R の`終端~offset$ ~GT %offset
］
⇒＃
%R の`終端~node$ ~SET %新-~node；
%R の`終端~offset$ ~DECBY %offset
◎
For each range whose end node is node and end offset is greater than offset, set its end node to new node and decrease its end offset by offset.
</li>
					<li>
~IF［
%R の`始端~node$ ~EQ %親
］~AND［
%R の`始端~offset$ ~EQ %node の`指数$ ~PLUS 1
］
⇒
%R の`始端~offset$ ~INCBY 1
◎
For each range whose start node is parent and start offset is equal to the index of node + 1, increase its start offset by one.
</li>
					<li>
~IF［
%R の`終端~node$ ~EQ %親
］~AND［
%R の`終端~offset$ ~EQ %node の`指数$ ~PLUS 1
］
⇒
%R の`終端~offset$ ~INCBY 1
◎
For each range whose end node is parent and end offset is equal to the index of node + 1, increase its end offset by one.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%node の`~dataを置換する$( %offset, %count, 空~文字列 )
◎
Replace data with node node, offset offset, count count, and data the empty string.
</li>
	<li>
~RET %新-~node
◎
Return new node.
</li>
</ol>

<dl class="idl-def">
	<dt>@splitText(offset)</dt>
	<dd>
被呼出時には、~offset %offset の所で
此れを`分割-$し~MUST。
◎
The splitText(offset) method, when invoked, must split context object with offset offset.
</dd>

	<dt>@wholeText</dt>
	<dd>
取得子は、此れを含む`連続的な~Text~node列$ 内の~EACH ( %text ) の`~data$を
`木~順序$で連結した結果を返さ~MUST。
◎
The wholeText attribute’s getter must return a concatenation of the data of the contiguous Text nodes of context object, in tree order.
</dd>
</dl>
		</section>
		<section id="interface-cdatasection">
<h3>4.12. ~ifc ^@CDATASection</h3>

⇒！
[`Exposed$=Window]
interface @CDATASection : $Text {
};
◎

<!--  -->

		</section>
		<section id="interface-processinginstruction">
<h3>4.13. ~ifc ^@ProcessingInstruction</h3>

⇒！
[`Exposed$=Window]
interface @ProcessingInstruction : $CharacterData {
  ~RA ~DS $target;
};
◎

<div class="p">
<p>
各 $ProcessingInstruction `~node$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~target@</dt>
	<dd>
文字列。
</dd>
</dl>
◎
ProcessingInstruction nodes have an associated target.
</div>


<dl class="idl-def">
	<dt>@target</dt>
	<dd>
取得子は、此れの`~target$を返さ~MUST。
◎
The target attribute must return the target.
</dd>
</dl>

		</section>
		<section id="interface-comment">
<h3>4.14. ~ifc ^@Comment</h3>

⇒！
[$Constructor(optional ~DS %data = ""),
 `Exposed$=Window]
interface @Comment : $CharacterData {
};
◎

<dl class="domintro">
	<dt>var %comment = new $Comment([data = ""])</dt>
	<dd>
`~data$が %data にされた，新たな $Comment `~node$を返す。
◎
Returns a new Comment node whose data is data.
</dd>
</dl>

<dl class="idl-def">
	<dt>@Comment(data)</dt>
	<dd>
この構築子の被呼出時には、次のように設定された 新たな $Comment `~node$を返さ~MUST
⇒＃
`~data$ ~SET %data,
`~node文書$ ~SET `現在の大域~obj$に`結付けられている文書$
◎
The Comment(data) constructor, when invoked, must return a new Comment node whose data is data and node document is current global object’s associated Document.
</dd>
</dl>

		</section>
	</section>
	<section id="ranges">
<h2 title="Ranges">5. 範囲o</h2>

		<section id="introduction-to-dom-ranges">
<h3 title="Introduction to “DOM Ranges”">5.1. “DOM Ranges” 序論</h3>

<p>
$Range ~obj （ `範囲o$ ）は`~node木$の中の連続する内容を表現する。
各 `範囲o$ は`境界点$と呼ばれる，`始端$と`終端$を持つ。
各 `境界点$は、
( `~node$, 非負~整数~offset )
の組である。
言い換えれば、`範囲o$は`~node木$の中の 2 つの`境界点$に挟まれる
`中身@rg
を表現する。
◎
A Range object (range) represents a sequence of content within a node tree. Each range has a start and an end which are boundary points. A boundary point is a tuple consisting of a node and a non-negative numeric offset. So in other words, a range represents a piece of content within a node tree between two boundary points.
</p>

<p>
`範囲o$は、編集における 内容の選択や複製に よく利用される。
例えば 次の`~node木$が与えられたとき：
◎
Ranges are frequently used in editing for selecting and copying content.
</p>

<ol class="domTree"><li>`要素$: `p^e
	<ol><li>`要素$: `img^e,
		<span>^src=`insanity-wolf^l</span>
		<span>^alt=`Little-endian BOM; decode as big-endian!^l</span>
	</li><li>$Text:
		<samp>&nbsp;CSS 2.1 syndata is&nbsp;</samp>
	</li><li>`要素$: `em^e
		<ol><li>$Text: <samp>awesome</samp>
		</li></ol>
	</li><li>$Text: <samp>!</samp>
	</li></ol>
</li></ol>

<p>
次の様にして，
`syndata is awes^l
の並びを表現する`範囲o$が得られる（変数 %p には `p^e `要素$が, %em には `em^e `要素$が，割当されているとする）：
◎
In the node tree above, a range can be used to represent the sequence “syndata is awes”. Assuming p is assigned to the p element, and em to the em element, this would be done as follows:
</p>

<pre class="js-code">
var %range = new Range(),
    %text1 = %p.childNodes[1],
    %text2 = %em.firstChild
%range.setStart(%text1, 9) /* <span class="comment">
先頭の空白も数に入れる
◎
do not forget the leading space
</span> */
%range.setEnd(%text2, 4)
/* <span class="comment">
%range を<a href="#dom-range-stringifier">文字列化-</a>した結果は、今や先に示した文字列になる
◎
range now stringifies to the aforementioned quote
</span> */
</pre>

<p class="note">注記：
`範囲o$は、上の`~node木$の ^src や ^alt などの`属性o$は表現できない。
`範囲o$の概念は`~node$に対してのみ有用になる。
◎
Attributes such as src and alt in the node tree above cannot be represented by a range. The ranges concept is only useful for nodes.
</p>

<p>
範囲oは`~node木$に対する変異に影響される。
その種の変異により`範囲o$が無効化されることはなく，可能なら内容の同じ部分を表現するようにされる。
`範囲o$は、その`中身$rgの一部が変異したときなど、`~node木$に対する変異に伴って，必要に応じて それ自身に~~変更が加えられ得る。
◎
Ranges are affected by mutations to the node tree. Such mutations will not invalidate a range and will try to ensure that the range still represents the same piece of content. Necessarily, a range might itself be modified as part of the mutation to the node tree when e.g. part of the content it represents is mutated.
</p>

<p>
詳細は、
`挿入-$／`除去-$の~algo,
$Node.normalize() ~meth,
`~dataを置換する$ ／ `分割-$の~algo
を見よ。
◎
See the insert and remove algorithms, the normalize() method, and the replace data and split algorithms for the hairy details.
</p>

<p class="trans-note">【
例えば範囲oの境界点が~nodeの “内部” を指していて，その~nodeが木から除去された場合、その境界点は “~nodeが抜けた穴” を指すようにされる（始端と終端が別々の木の中を指さないようにされる）。
始端と終端の両者が同じ~nodeの内部を指していたとしても、除去された~nodeの内部を指すことはなく，範囲oは依然として元の木に結付けられたままにされ、範囲oは，その始端と終端が同じ “穴” を指す様に “畳まれる” ことになる。
】</p>

		</section>
		<section id="interface-range">
<h3>5.2. ~ifc ^@Range</h3>

⇒！
[$Constructor,
 `Exposed$=Window]
interface @Range {
  ~RA $Node $startContainer;
  ~RA ~UL $startOffset;
  ~RA $Node $endContainer;
  ~RA ~UL $endOffset;
  ~RA ~B $collapsed;
  ~RA $Node $commonAncestorContainer;

  void $setStart($Node %node, ~UL %offset);
  void $setEnd($Node %node, ~UL %offset);
  void $setStartBefore($Node %node);
  void $setStartAfter($Node %node);
  void $setEndBefore($Node %node);
  void $setEndAfter($Node %node);
  void $collapse(optional ~B %toStart = false);
  void $selectNode($Node %node);
  void $selectNodeContents($Node %node);

  ~CUS @START_TO_START = 0;
  ~CUS @START_TO_END = 1;
  ~CUS @END_TO_END = 2;
  ~CUS @END_TO_START = 3;
  short $compareBoundaryPoints(~US %how, $Range %sourceRange);

  [`CEReactions$] void $deleteContents();
  [`CEReactions$, `NewObject$] $DocumentFragment $extractContents();
  [`CEReactions$, `NewObject$] $DocumentFragment $cloneContents();
  [`CEReactions$] void $insertNode($Node %node);
  [`CEReactions$] void $surroundContents($Node %newParent);

  [`NewObject$] $Range $cloneRange();
  void $detach();

  ~B $isPointInRange($Node %node, ~UL %offset);
  short $comparePoint($Node %node, ~UL %offset);

  ~B $intersectsNode($Node %node);

  $stringifier;
};
◎

<p>
$Range ~objは単に
`範囲o@
（ “DOM range”, “~~範囲~obj” ）とも称される。
◎
Range objects are simply known as ranges.
</p>

<p class="trans-note">【
一般語の “~~範囲” と区別し易くするため、この訳では， “°” を付けて “範囲o” と記すことにする。
】【
各 `範囲o$は、その作成-時からずっと，同じある`~node木$に結付けられ続ける。
仕様には明示的にそう述べられてはいないが、各種~algoの挙動から，そう結論できる。
】</p>

<p>
`境界点@
とは、［
`~node$と, 非負~整数である
`~offset@
］の組である。
<!--  object ではなく複合値 -->
◎
A boundary point is a (node, offset) tuple, where offset is a non-negative integer.
</p>

<p class="trans-note">【
以下では，所与の［
`~node$ %node, `~offset$ %offset
］で初期化された`境界点$を、
“境界点( %node, %offset )”
の様に表記する。
】</p>

<p class="note">注記：
一般に，`境界点$の`~offset$は［
0 〜 `境界点$の`~node$の`長さ$
］の~~範囲に入る。
`木$を改変する~algo（特に，
`挿入-$, `除去-$, `~dataを置換する$, `分割-$
）は、その`木$に結付けられている一連の`範囲o$も改変する。
◎
Generally speaking, a boundary point’s offset will be between zero and the boundary point’s node length, inclusive. Algorithms that modify a tree (in particular the insert, remove, replace data, and split algorithms) also modify ranges associated with that tree.
</p>

<div class="trans-note">
<p>【
~HTMLや~XMLの~source~textの中では、境界点は，すべての~text~data（`文字~data~node$）を “仮想の” 開始／終了 ~tagで括り, すべての空~要素は 開始／終了 ~tagの組に置換した上で、［各~tag, および文字~dataの各~文字］の一個一個を点に見立てて，~sourceに現れる順に一列に並べたときの，隣接する 2 つの点の隙間を指すものと見なせる（尚、ここでの “文字” は、~Unicode符号位置ではなく`符号単位$を表すことに注意）。
</p>

<p>
従って，例えば
"<samp>&lt;b&gt;text&lt;/b&gt;</samp>"
のような~markupの中の，［
開始~tag "<samp>&lt;b&gt;</samp>"
］と［
"<samp>text</samp>" の先頭
］との隙間を指す境界点には、
"<samp>text</samp>" ~node の［
内縁（“仮想の”~tagの内縁）を指すもの, および
外縁を指すもの
］があり、また，境界点は［
"<samp>&lt;br&gt;</samp>"
のような空~tag ／
~dataが空の`文字~data~node$
］の内部も指し得る†。
</p>

<p>†
唯一の~~例外は，`~doctype$であり、境界点は~doctypeの内部は<a href="#concept-range-bp-set">指し得ない</a>ようにされている
— したがってこの~modelでは，一個の “点” になる。
</p>

<p>
文書の~node木の一例とそのすべての境界点を示す模式図を次に示す。
縦棒  "|" が境界点が指し得る位置を表し，ドット "." が文字~dataの各~文字を表す（
<a href="#example-tree">先掲の模式図</a>
同様，左端が文書の先頭, 右端が文書の末尾，横線は木の中の各 ~nodeが文書~内を占める~~範囲を表し，~COLOR_Rは`文字~data~node$を表す）：
</p>

`[|*|(|A)|[|[|B]|(|.|)|C(|.|.|)|[|(|.|)|]|[|]|(|.|.|)|[x|0(|.|)|1[|(|.|)|]|2[|(|.|.|.|)|[|(|.|)|]|]|3(|.|.|)|4]|]|(|.|.|)|]^bpex

<p>
境界点を表す縦棒の直上の横線がその境界点の~nodeを表す。
境界点の~offsetは、図の中では，その境界点を表す縦棒の直上の横線直下にあって, その縦棒より左側に位置する縦棒の本数になる（境界点の~nodeが図の~COLOR_Xならば、その直下の各数字がその境界点の~offset）。
</p>

<p>
図の先頭の `*^c は`~doctype$を表す（内部に境界点は無い）。
その次の孤立した `A^c は~dataが空の`文字~data~node$の内部を指す（唯一の）境界点を表し，その次の `B^c は内容が空の要素の内部を指す境界点を表し，~~後続の 2 個の~COLOR_Rは 2 個の`文字~data~node$が境界点（ `C^c ）を挟んで間を置かずに連続していることを表している。
】</p>

</div>

<p class="algo-head">
%A ~EQ `境界点$( %node-A, %offset-A )
と
%B ~EQ `境界点$( %node-B, %offset-B )
が同じ `根$rgを持つとき、
%A の［
%B に相対的な
`位置bp@ 
］は，次の~algoの返値に従って
`前bp@,
`等bp@,
`後bp@,
のいずれかになる：
◎
If the two nodes of boundary points (node A, offset A) and (node B, offset B) have the same root, the position of the first relative to the second is either before, equal, or after, as returned by the following algorithm:
</p>

<p class="trans-note">【
この~algoは 2 つの境界点に対し，上の様な模式図における位置関係（左側が “前bp” ）を算出するものになる。
前bp／後bp
の関係については、 “ %A は%B <em style="font-weight: bold">より</em> `前bp$ ／ `後bp$ ” とも記す。
】</p>

<ol>
	<li>
~IF［
%node-A ~EQ %node-B
］
⇒
~RET ［
%offset-A ~EQ %offset-B ならば `等bp$ ／
%offset-A ~LT %offset-B ならば `前bp$ ／
%offset-A ~GT %offset-B ならば `後bp$
］
◎
If node A is the same as node B, return equal if offset A is the same as offset B, before if offset A is less than offset B, and after if offset A is greater than offset B.
</li>
	<li>
~IF［
%node-A は %node-B に`後続-$する
］
⇒
~RET 
%B は %A より［
`前bp$ ならば `後bp$ ／
`後bp$ ならば `前bp$
］
<!-- bp等0にはならない -->
◎
If node A is following node B, compute the position of (node B, offset B) relative to (node A, offset A). If it is before, return after. If it is after, return before.
</li>
	<li>
<p>
~IF［
%node-A は %node-B の`先祖$である
］：
◎
If node A is an ancestor of node B:
</p>
		<ol>
			<li>
%子 ~LET %node-B
◎
Let child equal node B.
</li>
			<li>
~WHILE［
%子 の`親$ ~NEQ %node-A
］
⇒
%子 ~SET %子 の`親$
◎
While child is not a child of node A, set child to its parent.
</li>
			<li>
~IF［
%子 の`指数$ ~LT %offset-A
］
⇒
~RET `後bp$
◎
If the index of child is less than offset A, return after.
</li>
		</ol>
	</li>
	<li>
~RET `前bp$
◎
Return before.
</li>
</ol>

<div class="p">
<p>
各 `範囲o$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`始端@</dt>
	<dt>`終端@</dt>
	<dd>
いずれも`境界点$。
</dd>
</dl>
◎
Each range has two associated boundary points — a start and end.
</div>

<p>
便宜のため：
◎
For convenience,＼
</p>

<ul>
	<li>
(
`始端~node@,
`始端~offset@
) は、順に，`始端$の
( `~node$, `~offset$ )
を指すとする。
◎
start node is start’s node, start offset is start’s offset,＼
</li>
	<li>
(
`終端~node@,
`終端~offset@
) は、順に，`終端$の
( `~node$, `~offset$ )
を指すとする。
◎
end node is end’s node, and end offset is end’s offset.
</li>
</ul>

<p>
`範囲o$の
`根@rg
とは、その`始端~node$の`根$である。
◎
The root of a range is the root of its start node.
</p>

<p class="trans-note">【
`終端~node$の`根$と同じになる（常にそうなるように拘束される）。
】</p>

<p>
所与の`範囲o$ %範囲o に対し：
◎
↓</p>

<ul>
	<li>
<p>
次をいずれも満たす`~node$ %node は、 %範囲o に
`包含され@
ているとされる：
◎
A node node is contained in a range range if＼
</p>
		<ul>
			<li>
%node の`根$ ~EQ %範囲o の`根$rg
◎
node’s root is the same as range’s root, and＼
</li>
			<li>
`境界点$( %node, 0 ) は %範囲o の`始端$より `後bp$
◎
(node, 0) is after range’s start, and＼
</li>
			<li>
`境界点$( %node, %node の`長さ$ ) は %範囲o の`終端$より `前bp$
◎
(node, length of node) is before range’s end.
</li>
		</ul>
	</li>
	<li>
<p>
次のいずれかを満たす`~node$ %node は、 %範囲o に
`部分的に包含され@
ているとされる：
◎
A node is partially contained in a range if＼
</p>

		<ul>
			<li>
［
%node は %範囲o の`始端~node$の`広義先祖$である
］~AND ［
%node は %範囲o の`終端~node$の`広義先祖$でない
］
◎
it is an inclusive ancestor of the range’s start node but not its end node, or＼
</li>
			<li>
［
%node は %範囲o の`始端~node$の`広義先祖$でない
］~AND［
%node は %範囲o の`終端~node$の`広義先祖$である
］
◎
vice versa.
</li>
		</ul>
	</li>
</ul>


<div class="trans-note">
<p>【
次の図は先掲の模式図と同様に木を表したものであり，図の記号 `s^c が始端, `e^c が終端を表すとする。
このとき、図の~COLOR_Xの~nodeが包含され, ~COLOR_Yの~node（始端／終端の一方のみを内部に含む~node）が部分的に包含される。
最上層の横線の~nodeは 内部に `s^c, `e^c とも含むので、~~定義により，`部分的に包含され$ることはない。
】</p>

`[|(|.|)|[|]|[y|(y|.|.|s)|]|[x|(x|.|)|]|(x|.|.|.|)|[x|]|(x|.|.|)|[y|(x|.|)|[x|(x|.|)|]|[y|(y|.|.|e.|)|[|(|.|)|]|]|(|.|.|)|]|]^bpex

</div>

<div class="note">
<p>注記：
これらの定義をより理解し易くする事実をいくつか挙げる：
◎
Some facts to better understand these definitions:
</p>

<ul>
	<li>
`範囲o$の`中身$rgは、`包含され$ているすべての`~node$に加えて，［
`文字~data~node$であるような［［
`始端~node$ ／ `終端~node$
］の`広義子孫$
］のうち，範囲oに入る部分
］からなるものとみなせる。
◎
The content that one would think of as being within the range consists of all contained nodes, plus possibly some of the contents of the start node and end node if those are Text, ProcessingInstruction, or Comment nodes.
</li>
	<li>
`範囲o$に`包含され$ている`~node$たちの集合は、`包含され$ている`~node$の`親$が常に`包含され$るとは限らないので，一般に連続的でない。
◎
The nodes that are contained in a range will generally not be contiguous, because the parent of a contained node will not always be contained.
</li>
	<li>
しかしながら，`包含され$ている`~node$の`子孫$は`包含され$ており、 2 つの`同胞$が`包含され$ているならば，それらの間に位置するどの`同胞$も`包含され$る。
◎
However, the descendants of a contained node are contained, and if two siblings are contained, so are any siblings that lie between them.
</li>
	<li>
`範囲o$の`始端~node$ と`終端~node$ は決して その範囲oに`包含され$ない。
◎
The start node and end node of a range are never contained within it.
</li>
	<li>
`包含され$ている`~node$のうち、最初のもの（もし在れば）は，常に`始端~node$に`後続-$し、最後のものは，常に`終端~node$の最後の`子孫$と同じか, それに`先行-$する。
<!-- descendant を持たない場合は？ -->
◎
The first contained node (if there are any) will always be after the start node, and the last contained node will always be equal to or before the end node’s last descendant.
</li>
	<li>
部分的に包含される`~node$が存在するのは、`始端~node$ と`終端~node$ が異なるとき, そのときに限る。
◎
There exists a partially contained node if and only if the start node and end node are different.
</li>
	<li>
`始端~node$と`終端~node$の`共通の広義先祖$は、`包含され$ることも, `部分的に包含され$ることもない。
◎
The commonAncestorContainer attribute value is neither contained nor partially contained.
</li>
	<li>
<p>
`始端~node$ %A が `終端~node$ %B の`先祖$である場合：
</p>
<ul ><li>%A が， %A, %B に`共通の広義先祖$になる。
</li><li>%A の`子$のうち， 1 つだけ（ %C とする）が`部分的に包含され$る。
</li><li>%A の別の`子$ %C1 が`包含され$るのは、 %C1 が %C に`先行-$するとき, そのときに限る。
</li></ul>

<div class="trans-note">
<p>【
この場合の例。
前と同様，記号 `s^c は始端, `e^c は終端を表す。
この例では図の最上層の~nodeが共通の広義先祖になる。
共通の広義先祖の子のうち、~COLOR_Yの~nodeが上述の %C （共通の広義先祖の子であってかつ部分的に包含される）に該当し，~COLOR_Xの~nodeが`包含され$る子になる。
】</p>

`[|(|.|)|s[x|(|.|)|]|(x|.|.|)|[x|(|.|.|)|]|[y|[|(|.|)|]|(|.|.|e.|)|[|(|.|)|]|]|(|.|.|)|]^bpex

</div>

<p>
%B が %A の`先祖$である場合、前述の逆になる。
<span  class="trans-note">【
上の図で、 `s^c と `e^c を入れ替えて，右端から木の順序が開始されていると考えるとよい。
】</span></p>

◎
If the start node is an ancestor of the end node, the common inclusive ancestor will be the start node. Exactly one of its children will be partially contained, and a child will be contained if and only if it precedes the partially contained child. If the end node is an ancestor of the start node, the opposite holds.
</li>
	<li>
`始端~node$ %A, `終端~node$ %B とも他方の`広義先祖$でない場合：
%A, %B の`共通の広義先祖$ %先祖 は、 %A とも %B とも異なる。
%先祖 の`子$のうち，ちょうど 2 個が`部分的に包含され$、
%先祖 の`子$が`包含され$るのは，これら 2 個の合間にあるとき, そのときに限る。
◎
If the start node is not an inclusive ancestor of the end node, nor vice versa, the common inclusive ancestor will be distinct from both of them. Exactly two of its children will be partially contained, and a child will be contained if and only if it lies between those two.
</li>
</ul>
</div>

<hr>

<dl class="domintro">
	<dt>var %range = new $Range()</dt>
	<dd>
新たな`範囲o$を返す。
◎
Returns a new range.
</dd>
</dl>

<dl class="idl-def">
	<dt>@Range()</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
</p>
		<ol>
			<li>
%文書 ~LET `現在の大域~obj$に`結付けられている文書$
</li>
			<li>
~RET 次のように設定された 新たな $Range
⇒＃
`始端$ ~SET `境界点$( %文書, 0 ) ,
`終端$ ~SET `境界点$( %文書, 0 )
</li>
		</ol>
◎
The Range() constructor, when invoked, must return a new range with (current global object’s associated Document, 0) as its start and end.
</dd>
</dl>


<dl class="domintro">
	<dt>%node = %range . $startContainer</dt>
	<dd>
%range の`始端~node$を返す。
◎
Returns range’s start node.
</dd>

	<dt>%offset = %range . $startOffset</dt>
	<dd>
%range の`始端~offset$を返す。
◎
Returns range’s start offset.
</dd>

	<dt>%node = %range . $endContainer</dt>
	<dd>
%range の`終端~node$を返す。
◎
Returns range’s end node.
</dd>

	<dt>%offset = %range . $endOffset</dt>
	<dd>
%range の`終端~offset$を返す。
◎
Returns range’s end offset.
</dd>

	<dt>%collapsed = %range . $collapsed</dt>
	<dd>
%range の`始端$と`終端$が同じ場合は~T を,
他の場合は~F を返す。
◎
Returns true if range’s start and end are the same, and false otherwise.
</dd>

	<dt>%container = %range . $commonAncestorContainer</dt>
	<dd>
%range の`始端~node$と`終端~node$の両方の`広義先祖$であるような，最も末端の~nodeを返す。
`原文の “ancestor” （先祖）は~~厳密な記述ではない。^tnote
◎
Returns the node, furthest away from the document, that is an ancestor of both range’s start node and end node.
</dd>
</dl>

<dl class="idl-def">
	<dt>@startContainer</dt>
	<dd>
取得子は、此れの`始端~node$を返さ~MUST。
◎
The startContainer attribute’s getter must return the start node.
</dd>

	<dt>@startOffset</dt>
	<dd>
取得子は、此れの`始端~offset$を返さ~MUST。
◎
The startOffset attribute’s getter must return the start offset.
</dd>

	<dt>@endContainer</dt>
	<dd>
取得子は、此れの`終端~node$を返さ~MUST。
◎
The endContainer attribute’s getter must return the end node.
</dd>

	<dt>@endOffset</dt>
	<dd>
取得子は、此れの`終端~offset$を返さ~MUST。
◎
The endOffset attribute’s getter must return the end offset.
</dd>

	<dt>@collapsed</dt>
	<dd>
取得子は、［
此れの`始端$ ~EQ `終端$ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The collapsed attribute’s getter must return true if start is the same as end, and false otherwise.
</dd>

	<dt>@commonAncestorContainer</dt>
	<dd>
取得子は、此れの
( `始端~node$, `終端~node$ )
の`共通の広義先祖$を返さ~MUST。
◎
The commonAncestorContainer attribute’s getter must run these steps: 
• Let container be start node.
• While container is not an inclusive ancestor of end node, let container be container’s parent.
• Return container.
</dd>
</dl>

<div>
<p class="algo-head">
`この訳では便宜のため，次を定義する：^tnote
同じ木に関与する 2 つの~node %A, %B の（最も末端の）
`共通の広義先祖@
とは、次の~algoを走らせた結果である：
</p>

<ol>
	<li>
~WHILE［
%A は %B の`広義先祖$でない
］
⇒
%A ~SET %A の`親$
</li>
	<li>
~RET %A
</li>
</ol>

◎
↑</div>

<hr>

<p class="trans-note">【
次のブロックは、原文には存在しない，この訳による補完。
ブロックにて挙げる各種~methは、範囲oの片方または両方の境界点を新たな地点に変更する。
片方の境界点（以下， %P ）のみを変更する~methについては、整合性を保つため，もう片方の境界点（以下， %Q ）も必要に応じて~~正される：
すなわち， %Q が［
%P と異なる木の中に在る, または
%P より［
前bp（始端が変更された場合） ／
後bp（終端が変更された場合）
］に位置する
］ようになった場合、 %P と同じ地点にされる（ 範囲oは “畳まれる” ）。
】</p>

<dl class="domintro">

	<dt>%range . $setStart(node, offset)</dt>
	<dt>%range . $setEnd(node, offset)</dt>
	<dd>
それぞれ，始端／終端を `境界点$( %node, %offset ) と同じ位置にする。
</dd>
	<dd>
%node が`~doctype$である場合，
`InvalidNodeTypeError$E 例外が投出される。
他の場合，
%offset が %node の`長さ$を超えている場合，
`IndexSizeError$E 例外が投出される。
</dd>

	<dt>%range . $setStartBefore(node)</dt>
	<dt>%range . $setStartAfter(node)</dt>
	<dd>
それぞれ，始端を %node の外縁の［
始端（下図の `S^c ）／終端（下図の `E^c ）
］に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $setEndBefore(node)</dt>
	<dt>%range . $setEndAfter(node)</dt>
	<dd>
それぞれ，終端を %node の外縁の［
始端（下図の `S^c ）／終端（下図の `E^c ）
］に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dd class="trans-note">
（説明用の図式
— %node 引数が，図の~COLOR_Yが表す~nodeに対応しているとする。）


`[|(|.|)|[|(|.|)|S[y|s[|(|.|)|]|(|.|.|.|)|[|]|e]|E(|.|.|)|]|]^bpex

</dd>

	<dt>%range . $collapse(toStart)</dt>
	<dd>
範囲oを “畳む”。
%toStart が~T の場合は 終端を始端と同じ地点に位置させ，他の場合は 始端を終端と同じ地点に位置させる。
</dd>

	<dt>%range . $selectNode(node)</dt>
	<dd>
%node を “選択-” する。
すなわち，始端と終端を %node の外縁の両端（上図の `S^c, `E^c ）に位置させる。
</dd>
	<dd>
%node の`親$が~NULL の場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $selectNodeContents(node)</dt>
	<dd>
%node の内容を “選択-” する。
すなわち，始端と終端を %node の内縁の両端（上図の `s^c, `e^c ）に位置させる。
</dd>
	<dd>
%node が`~doctype$である場合，
`InvalidNodeTypeError$E 例外が投出される。
</dd>

	<dt>%range . $compareBoundaryPoints(how, sourceRange)</dt>
	<dd>
%range の始端または終端（ %how により指示される）が，
%sourceRange の始端または終端（ %how により指示される）に比して［
`前bp$, `等bp$, `後bp$
］のいずれに位置bpするかに応じて、［
−1, 0, 1
］を返す。
	</dd>

	<dd lang="en"><!-- for del_j --></dd>
</dl>


<p class="algo-head">
`範囲o$ %範囲o の
`境界点を設定する@
ときは、所与の
( %端 ~IN { `始端^i, `終端^i }, `~node$ %node, 非負~整数 %offset )
に対し，次を走らす：
◎
To set the start or end of a range to a boundary point (node, offset), run these steps:
</p>

<ol>
	<li id="cp-throw-if-doctype">
~IF［
%node は`~doctype$である
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If node is a doctype, then throw an InvalidNodeTypeError.
</li>
	<li id="cp-throw-if-length">
~IF［
%offset ~GT %node の`長さ$
］
⇒
~THROW `IndexSizeError$E
◎
If offset is greater than node’s length, then throw an IndexSizeError.
</li>
	<li>
%境界点 ~LET `境界点$( %node, %offset )
◎
Let bp be the boundary point (node, offset).
</li>
	<li>
<p>
~IF［
%端 ~EQ `始端^i
］：
◎
If these steps were invoked as "set the start"
</p>
		<ol>
			<li>
~IF［
%境界点 は %範囲o の`終端$より `後bp$
］~OR［
%範囲o の`根$rg ~NEQ %node の`根$
］
⇒
%範囲o の`終端$ ~SET %境界点
◎
If bp is after the range’s end, or if range’s root is not equal to node’s root, set range’s end to bp.
</li>
			<li>
%範囲o の`始端$ ~SET %境界点
◎
Set range’s start to bp.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ %端 ~EQ `終端^i ）
◎
If these steps were invoked as "set the end"
</p>
		<ol>
			<li>
~IF［
%境界点 は %範囲o の`始端$より `前bp$
］~OR［
%範囲o の`根$rg ~NEQ %node の`根$
］
⇒
%範囲o の`始端$ ~SET %境界点
◎
If bp is before the range’s start, or if range’s root is not equal to node’s root, set range’s start to bp.
</li>
			<li>
%範囲o の`終端$ ~SET %境界点
◎
Set range’s end to bp.
</li>
		</ol>
	</li>
</ol>

<dl class="idl-def">
	<dt>@setStart(node, offset)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`境界点を設定する$( `始端^i, %node, %offset )
◎
The setStart(node, offset) method, when invoked, must set the start of context object to boundary point (node, offset).
</dd>

	<dt>@setEnd(node, offset)</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
此れの`境界点を設定する$( `終端^i, %node, %offset )
◎
The setEnd(node, offset) method, when invoked, must set the end of context object to boundary point (node, offset).
</dd>

	<dt>@setStartBefore(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setStartBefore(node) method, when invoked, must run these steps: 
</p>
		<ol>
			<li id="cp-let-parent">
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>
			<li id="cp-throw-if-null">
~IF［
%親 ~EQ ~NULL
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If parent is null, then throw an InvalidNodeTypeError.
</li>
			<li>
此れの`境界点を設定する$( `始端^i, %親, %node の`指数$ )
◎
Set the start of the context object to boundary point (parent, node’s index).
</li>
		</ol>
	</dd>

	<dt>@setStartAfter(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setStartAfter(node) method, when invoked, must run these steps:
</p>

		<ol>
			<!--cp-let-parent-->
			<!--cp-throw-if-null-->
			<li>
此れの`境界点を設定する$( `始端^i, %親, %node の`指数$ ~PLUS 1 )
◎
Set the start of the context object to boundary point (parent, node’s index plus one).
</li>
		</ol>
	</dd>

	<dt>@setEndBefore(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setEndBefore(node) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-let-parent-->
			<!--cp-throw-if-null-->
			<li>
此れの`境界点を設定する$( `終端^i, %親, %node の`指数$ )
◎
Set the end of the context object to boundary point (parent, node’s index).
</li>
		</ol>
	</dd>

	<dt>@setEndAfter(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setEndAfter(node) when invoked, method must run these steps:
</p>
		<ol>
			<!--cp-let-parent-->
			<!--cp-throw-if-null-->
			<li>
此れの`境界点を設定する$( `終端^i, %親, %node の`指数$ ~PLUS 1 )
◎
Set the end of the context object to boundary point (parent, node’s index plus one).
</li>
		</ol>
	</dd>

	<dt>@collapse(toStart)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The collapse(toStart) method, when invoked, must＼
</p>
		<ol>
			<li>
~IF［
%toStart ~EQ ~T
］
⇒
`終端$ ~SET `始端$
◎
if toStart is true, set end to start, and＼
</li>
			<li>
~ELSE
⇒
`始端$ ~SET `終端$
◎
set start to end otherwise.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
`~node$ %node を，`範囲o$ %範囲o の
`中身として選択-@rg
するときは、次を走らす：
◎
To select a node node within a range range, run these steps:
</p>

<ol>
	<!--cp-let-parent-->
	<!--cp-throw-if-null-->
	<li>
%index ~LET %node の`指数$
◎
Let index be node’s index.
</li>
	<li>
%範囲o の`始端$ ~SET `境界点$( %親, %index )
◎
Set range’s start to boundary point (parent, index).
</li>
	<li>
%範囲o の`終端$ ~SET `境界点$( %親, %index ~PLUS 1 )
◎
Set range’s end to boundary point (parent, index plus one).
</li>
</ol>

<dl class="idl-def">
	<dt>@selectNode(node)</dt>
	<dd>
被呼出時には、 %node を，此れの`中身として選択-$rgし~MUST。
◎
The selectNode(node) method, when invoked, must select node within context object.
</dd>

	<dt>@selectNodeContents(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The selectNodeContents(node) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%node は`~doctype$である
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If node is a doctype, then throw an InvalidNodeTypeError.
</li>
			<li>
%長さ ~LET %node の`長さ$
◎
Let length be the length of node.
</li>
			<li>
此れの`始端$ ~SET `境界点$( %node, 0 )
◎
Set start to the boundary point (node, 0).
</li>
			<li>
此れの`終端$ ~SET `境界点$( %node, %長さ )
◎
Set end to the boundary point (node, length).
</li>
		</ol>
	</dd>

	<dt>@compareBoundaryPoints(how, sourceRange)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The compareBoundaryPoints(how, sourceRange) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%how ~NIN {
$START_TO_START,
$START_TO_END,
$END_TO_END,
$END_TO_START
}
］
⇒
~THROW `NotSupportedError$E
◎
If how is not one of
• START_TO_START
• START_TO_END
• END_TO_END
• END_TO_START
◎
then throw a NotSupportedError.
</li>
			<li>
~IF［
此れの`根$rg ~NEQ %sourceRange の`根$rg
］
⇒
~THROW `WrongDocumentError$E
◎
If context object’s root is not the same as sourceRange’s root, then throw a WrongDocumentError.
</li>
			<li>
<p>
( %基準点, %相対点 ) ~LET %how に応じて，次で与えられる 2 個の`境界点$：
◎
If how is:
</p>
				<dl class="switch">
					<dt>$START_TO_START:</dt>
					<dd>
( %sourceRange の`始端$, 此れの`始端$ )
◎
Let this point be the context object’s start. Let other point be sourceRange’s start.
</dd>

					<dt>$START_TO_END:</dt>
					<dd>
( %sourceRange の`始端$, 此れの`終端$ )
◎
Let this point be the context object’s end. Let other point be sourceRange’s start.
</dd>

					<dt>$END_TO_END:</dt>
					<dd>
( %sourceRange の`終端$, 此れの`終端$ )
◎
Let this point be the context object’s end. Let other point be sourceRange’s end.
</dd>

					<dt>$END_TO_START:</dt>
					<dd>
( %sourceRange の`終端$, 此れの`始端$ )
◎
Let this point be the context object’s start. Let other point be sourceRange’s end.
</dd>
				</dl>
			</li>
			<li>
~RET ［
%基準点 に相対的な %相対点 の`位置bp$
］に応じて
⇒
［
%基準点 より `前bp$ ならば ~MINUS 1 ／
%基準点 と `等bp$ ならば 0 ／
%基準点 より `後bp$ ならば 1
］
◎
If the position of this point relative to other point is
◎
before
• Return −1.
◎
equal
• Return 0.
◎
after
• Return 1.
</li>
		</ol>
	</dd>
</dl>

<!-- ^@Range -->

<p class="trans-note">【
次のブロックは、原文には存在しない，この訳による補完。
ブロックにて挙げる各種~methは、主に，範囲oの`中身$rgを操作する。
】</p>

<dl class="domintro">
	<dt>%range . $deleteContents()</dt>
	<dd>
`範囲o$の`中身$rgを削除した上で、範囲oの`境界点$を “畳む”。
</dd>
	<dd>
<p>
`deleteContents()^c の実行例。
図の記号［
`s^c, `e^c
］が順に範囲の［
始端, 終端
］を表すとするとき、図左の~~状態から図右の~~状態になる。
包含されている~node（図の ~COLOR_X ）, および
始端／終端~nodeの文字~dataのうち 範囲oに入る部分の文字（図の `+^c ）が除去される。
部分的に包含されている~node（図の ~COLOR_Y ）は除去されない。
この例では、始端 `s^c が指す`文字~data~node$は，~dataは空になるが~node自体は残される。
図右の `S^c, `E^c が元の始端, 終端に対応する位置であるが、実行後の始端と終端は，図右の `X^c （共通の広義先祖の直下）を指すようにされることに注意（範囲oは “畳まれる” ）。
始端~nodeが終端~nodeの`広義先祖$であった場合、始端の位置は変化しない。
始端~nodeが終端~node の`広義子孫$であった場合、全体の終端（右端）から相対的な終端の位置は変化しない。
</p>

`[|[|]|[y|(y|s+|)|]|[x|(|.|)|]|[y|(x|.|)|[y|(y|+|+|e.|)|[|]|]|(|.|)|]|] → [|[|]|[y|(y|S)|]|X[y|[y|(y|E.|)|[|]|]|(|.|)|]|]^bpex

</dd>

	<dt>%range . $extractContents()</dt>
	<dd>
`範囲o$の`中身$rgを~cloneした結果を返すと同時に，中身は削除する（ “カット” ）。
機能的には
$cloneContents() と $deleteContents()
の組み合わせと同等になる。
</dd>

	<dt>%range . $cloneContents()</dt>
	<dd>
`範囲o$の`中身を~clone$rgした結果を返す。
返される`中身$rgは、新たな`文書片$で包装される。
</dd>
	<dd>
<p>
^cloneContents() の実行例。
図左の記号［
`s^c, `e^c
］が順に範囲の［
始端, 終端
］を表すとするとき、その間に挟まれた部分の~cloneが図右に示すように得られる（ `S^c, `E^c が元の始端と終端に対応する位置）。
図の~COLOR_Yの 2 個の~nodeが，範囲に`部分的に包含され$ている子。
入れ物にあたる それらの`共通の広義先祖$は、~cloneにおいては`文書片$（~COLOR_X）に置換される。
始端 `s^c が属する`文字~data~node$は~dataが空にされるが、~node自体は［
その親から共通の広義先祖の子まで
］の先祖も含めて~cloneされる。
</p>

`[|[|]|[y|(|.|s)|(|.|)|]|(|.|)|[y|(|.|)|[|(|.|.|e.|)|[|]|]|(|.|)|]|] → [x|[y|(|S)|(|.|)|]|(|.|)|[y|(|.|)|[|(|.|.|E)|]|]|]^bpex

</dd>

	<dt>%range . $insertNode(node)</dt>
	<dd>
`範囲o$の`中身$rgの先頭に %node を挿入する（`中身に挿入-$rgする）。
</dd>

	<dt>%range . $surroundContents(%newParent)</dt>
	<dd>
`範囲o$の`中身$rgを %newParent ~nodeで包装する。
それに伴い、範囲oの始端, 終端は， %newParent の（外縁の）両端を指すようにされる。
包装するに先立って、
%newParent の元々の子はすべて除去され，
%newParent 自身も元々の親から除去される。
</dd>
	<dd>
<p>
^surroundContents(%newParent) の実行例。
記号 `s^c は始端, `e^c は終端を表すとき、それらに挟まれた区間が %newParent で包装される（図の~COLOR_Y）。
`部分的に包含され$るものは `Text^c 以外に許容されないので、始端と終端は `Text^c の層を~~無視すれば同じ親の直下に位置する必要がある（さもなければ例外が投出される）。
図の様に境界点が `Text^c ~node内に位置する場合、その~nodeはそこで分割される。
</p>

`[|(|.|)|s[x|(|.|)|]|[x|(|.|.|)|[|]|]|(|.|e.|)|] → [|(|.|)|s[y|[x|(|.|)|]|[x|(|.|.|)|[|]|]|(|.|)|]|e(|.|)|]^bpex

</dd>

	<dd lang="en"><!-- for del_j --></dd>
</dl>


<dl class="idl-def">
	<dt>@deleteContents()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The deleteContents() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
`始端$と`終端$は `等bp$
］
⇒
~RET
◎
If start is end, then return.
</li>
			<li>
( %元の始端~node, %元の始端~offset, %元の終端~node, %元の終端~offset )
~LET 順に，此れの
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
Let original start node, original start offset, original end node, and original end offset be the context object’s start node, start offset, end node, and end offset, respectively.
</li>
			<li>
<p>
~IF［
%元の始端~node ~EQ %元の終端~node
］~AND［
%元の始端~node, %元の終端~node は，いずれも`文字~data~node$である
］：
</p>
				<ol>
					<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の終端~offset ~MINUS %元の始端~offset, 空~文字列 )
</li>
					<li>
~RET
</li>
				</ol>
◎
If original start node and original end node are the same, and they are a Text, ProcessingInstruction, or Comment node, replace data with node original start node, offset original start offset, count original end offset minus original start offset, and data the empty string, and then return.
</li>
			<li>
%除去対象 ~LET ［
此れに`包含され$ている`~node$のうち，`親$も此れに`包含され$ているものは除いたもの
］からなる，`木~順序$の~list
◎
Let nodes to remove be a list of all the nodes that are contained in the context object, in tree order, omitting any node whose parent is also contained in the context object.
</li>
			<li id="cp-let-new-if">
~IF［
%元の始端~node は %元の終端~node の`広義先祖$である
］
⇒＃
%新-~node ~LET %元の始端~node；
%新-~offset ~LET %元の始端~offset
◎
If original start node is an inclusive ancestor of original end node, set new node to original start node and new offset to original start offset.
</li>
			<li><!-- cp-new-node-offset -->
<p>
~ELSE：
</p>
		<ol>
			<li>
%新-~node ~LET
( %元の始端~node, %元の終端~node )
の`共通の広義先祖$
</li>
			<li>
%新-~offset ~LET ［
%新-~node の`子$のうち, %元の始端~node の`広義先祖$である`~node$ †
］の`指数$ ~PLUS 1
</li>
				</ol>

<p class="trans-note">【
見通しを良くするため、ここの訳は，原文を等価な記述に変形している。
前~段の条件の否定が成立することから † に該当する~nodeは必ず存在し， %新-~node に`部分的に包含され$ている子のうち 最初のものになる。
】</p>

◎
Otherwise:
• Let reference node equal original start node.
• While reference node’s parent is not null and is not an inclusive ancestor of original end node, set reference node to its parent.
• Set new node to the parent of reference node, and new offset to one plus the index of reference node.
• If reference node’s parent were null, it would be the root of the context object, so would be an inclusive ancestor of original end node, and we couldn’t reach this point.
</li>
			<li>
~IF［
%元の始端~node は`文字~data~node$である
］
⇒
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の始端~node の`長さ$ ~MINUS %元の始端~offset, 空~文字列 )
◎
If original start node is a Text, ProcessingInstruction, or Comment node, replace data with node original start node, offset original start offset, count original start node’s length minus original start offset, data the empty string.
</li>
			<li>
%除去対象 内の~EACH ( %node ) に対し，`木~順序$で
⇒
%node をその`親$から`除去-$する
◎
For each node in nodes to remove, in tree order, remove node from its parent.
</li>
			<li>
~IF［
%元の終端~node は`文字~data~node$である
］
⇒
%元の終端~node の`~dataを置換する$( 0, %元の終端~offset, 空~文字列 )
◎
If original end node is a Text, ProcessingInstruction, or Comment node, replace data with node original end node, offset 0, count original end offset and data the empty string.
</li>
			<li>
此れの`始端$ ~SET `境界点$( %新-~node, %新-~offset )；<br>
此れの`終端$ ~SET `境界点$( %新-~node, %新-~offset )
◎
Set start and end to (new node, new offset).
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
`範囲o$ %範囲o の
`中身を抽出-@rg
するときは、次を走らす：
◎
To extract a range range, run these steps:
</p>

<ol>
	<li id="cp-new-frag">
%断片 ~LET 次のように設定された 新たな`文書片$`~node$
⇒
`~node文書$ ~SET %範囲o の`始端~node$の`~node文書$
◎
Let fragment be a new DocumentFragment node whose node document is range’s start node’s node document.
</li>
	<li id="cp-ret-frag-if">
~IF［
%範囲o の`始端$と`終端$は `等bp$
］
⇒
~RET %断片
◎
If range’s start is its end, return fragment.
</li>
	<li id="cp-let-bp-vars">
( %元の始端~node, %元の始端~offset, %元の終端~node, %元の終端~offset )
~LET 順に， %範囲o の
( `始端~node$, `始端~offset$, `終端~node$, `終端~offset$ )
◎
Let original start node, original start offset, original end node, and original end offset be range’s start node, start offset, end node, and end offset, respectively.
</li>
	<li>
<p id="cp-if-s-is-e-and">
~IF［
%元の始端~node ~EQ %元の終端~node
］~AND［
それは`文字~data~node$である
］：
◎
If original start node is original end node, and they are a Text, ProcessingInstruction, or Comment node:
</p>

		<ol>
			<li id="cp-let-clone-s">
%clone ~LET
%元の始端~node を`~clone$した結果
◎
Let clone be a clone of original start node.
</li>
			<li id="cp-set-clone-data-1">
%clone の`~data$ ~SET
%元の始端~node の`~dataの部分文字列$( %元の始端~offset, ( %元の終端~offset ~MINUS %元の始端~offset ) )
◎
Set the data of clone to the result of substringing data with node original start node, offset original start offset, and count original end offset minus original start offset.
</li>
			<li id="cp-append-clone">
%clone を %断片 に`付加-$する
◎
Append clone to fragment.
</li>
			<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の終端~offset ~MINUS %元の始端~offset, 空~文字列 )
◎
Replace data with node original start node, offset original start offset, count original end offset minus original start offset, and data the empty string.
</li>
			<li id="cp-ret-flag">
~RET %断片
◎
Return fragment.
</li>
		</ol>
	</li>
	<li id="cp-let-common-anc">
%共通の広義先祖 ~LET
( %元の始端~node, %元の終端~node )
の`共通の広義先祖$
◎
Let common ancestor be original start node.
◎
While common ancestor is not an inclusive ancestor of original end node, set common ancestor to its own parent.
</li>
	<li id="cp-let-1st-pcc-null">
%最初の部分的に包含されている子 ~LET ~NULL
◎
Let first partially contained child be null.
</li>
	<li id="cp-set-1st-pcc-if">
~IF［
%元の始端~node は %元の終端~node の`広義先祖$でない
］
⇒
%最初の部分的に包含されている子 ~SET
%範囲o に`部分的に包含され$ている［
%共通の広義先祖 の`子$
］のうち，最初のもの
◎
If original start node is not an inclusive ancestor of original end node, set first partially contained child to the first child of common ancestor that is partially contained in range.
</li>
	<li id="cp-let-last-pcc-null">
%最後の部分的に包含されている子 ~LET ~NULL
◎
Let last partially contained child be null.
</li>
	<li id="cp-set-last-pcc-if">
		<p>
~IF［
%元の終端~node は %元の始端~node の`広義先祖$でない
］
⇒
%最後の部分的に包含されている子 ~SET
%範囲o に`部分的に包含され$ている［
%共通の広義先祖 の`子$
］のうち，最後のもの
◎
If original end node is not an inclusive ancestor of original start node, set last partially contained child to the last child of common ancestor that is partially contained in range.
</p>

<p class="note">注記：
これらの変数~代入は実際に常に~~意味を成す。
例えば， %元の始端~node が %元の終端~node の`広義先祖$でない場合、［
%元の始端~node ~EQ %共通の広義先祖
］にはなり得ないので［
%元の始端~node の広義先祖であって %共通の広義先祖 の子孫でもあるもの
］が 1 つ以上あり，それらは %範囲o に`部分的に包含され$、それらのうち %共通の広義先祖 の子であるものが該当するものになる。
逆の場合も同様になる。
また、 2 つの子がいずれも定義されたなら，それらは決して等しくならないことにも注意。
◎
These variable assignments do actually always make sense. For instance, if original start node is not an inclusive ancestor of original end node, original start node is itself partially contained in range, and so are all its ancestors up until a child of common ancestor. common ancestor cannot be original start node, because it has to be an inclusive ancestor of original end node. The other case is similar. Also, notice that the two children will never be equal if both are defined.
</li>
	<li id="cp-let-contained">
%包含されている子たち ~LET
%共通の広義先祖 の`子$のうち， %範囲o に`包含され$ているものすべてからなる
`木~順序$による~list
◎
Let contained children be a list of all children of common ancestor that are contained in range, in tree order.
</li>
	<li id="cp-throw-if-a-doctype">
<p>
~IF［
%包含されている子たち 内に`~doctype$がある
］
⇒
~THROW `HierarchyRequestError$E
◎
If any member of contained children is a doctype, then throw a HierarchyRequestError.
</p>

<p class="note">注記：
`~doctype$が`部分的に包含され$ることは決してないので、部分的に包含される~nodeを気にする必要はない。
それは 範囲o の境界点
`始端~node／終端~node^tnote
にはなり得ず, 何かの先祖にもなり得ない。
◎
We do not have to worry about the first or last partially contained node, because a doctype can never be partially contained. It cannot be a boundary point of a range, and it cannot be the ancestor of anything.
</p>
	</li>
	<!--cp-let-new-if-->
	<li>
<p>
~ELSE
⇒＃
%新-~node ~LET %共通の広義先祖；
%新-~offset ~LET %最初の部分的に包含されている子 の`指数$ ~PLUS 1
</p>

<p class="trans-note">【ここの訳は、原文の記述と同じ結果を得るものに簡略化している。】</p>

◎
Otherwise:
• Let reference node equal original start node.
• While reference node’s parent is not null and is not an inclusive ancestor of original end node, set reference node to its parent.
• Set new node to the parent of reference node, and new offset to one plus reference node’s index.
• If reference node’s parent is null, it would be the root of range, so would be an inclusive ancestor of original end node, and we could not reach this point.
</li>
	<li>

<p id="cp-if-1st-pcc-is-cdata">
~IF［
%最初の部分的に包含されている子 は`文字~data~node$である
］：
◎
If first partially contained child is a Text, ProcessingInstruction, or Comment node:
</p>

<p class="note" id="cp-if-1st-pcc-is-cdata-note">
この事例では， %最初の部分的に包含されている子 は %元の始端~node である。
◎
In this case, first partially contained child is original start node.
</p>

		<ol>
			<!--cp-let-clone-s-->
			<li id="cp-set-clone-data-2">
%clone の`~data$ ~SET
%元の始端~node の`~dataの部分文字列$( %元の始端~offset, ( %元の始端~node の`長さ$ ~MINUS %元の始端~offset ) )
◎
Set the data of clone to the result of substringing data with node original start node, offset original start offset, and count original start node’s length minus original start offset.
</li>
			<!--cp-append-clone-->
			<li>
%元の始端~node の`~dataを置換する$( %元の始端~offset, %元の始端~node の`長さ$ ~MINUS %元の始端~offset, 空~文字列 )
◎
Replace data with node original start node, offset original start offset, count original start node’s length minus original start offset, and data the empty string.
</li>
		</ol>
	</li>
	<li>

<p id="cp-elseif-1st-pcc-not-null">
~ELIF［
%最初の部分的に包含されている子 ~NEQ ~NULL
］：
◎
Otherwise, if first partially contained child is not null:
</p>

		<ol>
			<li id="cp-let-clone-1st-pcc">
%clone ~LET %最初の部分的に包含されている子 を`~clone$した結果
◎
Let clone be a clone of first partially contained child.
</li>
			<!--cp-append-clone-->
			<li id="cp-let-subrange1">
%下位~範囲o ~LET 次のように設定された 新たな`範囲o$
⇒＃
`始端$ ~SET `境界点$( %元の始端~node, %元の始端~offset ),
`終端$ ~SET `境界点$( %最初の部分的に包含されている子, %最初の部分的に包含されている子 の`長さ$ )
◎
Let subrange be a new range whose start is (original start node, original start offset) and whose end is (first partially contained child, first partially contained child’s length).
</li>
			<li id="cp-let-subfrag-extract">
%下位~断片 ~LET %下位~範囲o の`中身を抽出-$rgした結果
◎
Let subfragment be the result of extracting subrange.
</li>
			<li id="cp-append-subfrag">
%下位~断片 を %clone に`付加-$する
◎
Append subfragment to clone.
</li>
		</ol>
	</li>
	<li>
%包含されている子たち 内の~EACH ( %包含されている子 ) に対し
⇒
%包含されている子 を %断片 に`付加-$する
◎
For each contained child in contained children, append contained child to fragment.
</li>
	<li>
<p id="cp-if-last-pcc">
~IF［
%最後の部分的に包含されている子 は`文字~data~node$である
］：
◎
If last partially contained child is a Text, ProcessingInstruction, or Comment node:
</p>

<p class="note" id="cp-if-last-pcc-note">注記：
この事例では， %最後の部分的に包含されている子 は %元の始端~node である。
◎
In this case, last partially contained child is original end node.
</p>

		<ol>
			<li id="cp-let-clone-end">
%clone ~LET %元の終端~node を`~clone$した結果
◎
Let clone be a clone of original end node.
</li>
			<li id="cp-set-clone-data-3">
%clone の`~data$ ~SET
%元の終端~node の`~dataの部分文字列$( 0, %元の終端~offset )
◎
Set the data of clone to the result of substringing data with node original end node, offset 0, and count original end offset.
</li>
			<!--cp-append-clone-->
			<li>
%元の終端~node の`~dataを置換する$( 0, %元の終端~offset, 空~文字列 )
◎
Replace data with node original end node, offset 0, count original end offset, and data the empty string.
</li>
		</ol>
	</li>
	<li>
<p id="cp-elif-pcc-not-null">
~ELIF［
%最後の部分的に包含されている子 ~NEQ ~NULL
］：
◎
Otherwise, if last partially contained child is not null:
</p>

		<ol>
			<li id="cp-let-clone-last-pcc">
%clone ~LET %最後の部分的に包含されている子 を`~clone$した結果
◎
Let clone be a clone of last partially contained child.
</li>
			<!--cp-append-clone-->
			<li id="cp-let-subrange2">
%下位~範囲o ~LET 次のように設定された 新たな`範囲o$
⇒＃
`始端$ ~SET `境界点$( %最後の部分的に包含されている子, 0 ),
`終端$ ~SET `境界点$( %元の終端~node, %元の終端~offset )
◎
Let subrange be a new range whose start is (last partially contained child, 0) and whose end is (original end node, original end offset).
</li>
			<!--cp-let-subfrag-extract-->
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<li><!--copy* -->
%範囲o の`始端$ ~SET `境界点$( %新-~node, %新-~offset )；<br>
%範囲o の`終端$ ~SET `境界点$( %新-~node, %新-~offset )
◎
Set range’s start and end to (new node, new offset).
</li>
	<!--cp-ret-flag-->
</ol>

<dl class="idl-def">
	<dt>@extractContents()</dt>
	<dd>
被呼出時には、此れの`中身を抽出-$rgした結果を返さ~MUST。
◎
The extractContents() method, when invoked, must return the result of extracting context object.
</dd>
</dl>

<p class="algo-head">
`範囲o$ %範囲o の`中身を~clone@rg
するときは、次を走らす：
◎
To clone the contents of a range range, run these steps:
</p>

<ol>
	<!--cp-new-frag-->
	<!--cp-ret-frag-if-->
	<!--cp-let-bp-vars-->
	<li>
		<!--cp-if-s-is-e-and-->
		<ol>
			<!--cp-let-clone-s-->
			<!--cp-set-clone-data-1-->
			<!--cp-append-clone-->
			<!--cp-ret-flag-->
		</ol>
	</li>
	<!--cp-let-common-anc-->
	<!--cp-let-1st-pcc-null-->
	<!--cp-set-1st-pcc-if-->
	<!--cp-let-last-pcc-null-->
	<!--cp-set-last-pcc-if-->
	<!--cp-let-contained-->
	<!--cp-throw-if-a-doctype-->
	<li>
		<!--cp-if-1st-pcc-is-cdata-->
		<!--cp-if-1st-pcc-is-cdata-note-->
		<ol>
			<!--cp-let-clone-s-->
			<!--cp-set-clone-data-2-->
			<!--cp-append-clone--> 
		</ol>
	</li>
	<li>
		<!--cp-elseif-1st-pcc-not-null-->
		<ol>
			<!--cp-let-clone-1st-pcc-->
			<!--cp-append-clone-->
			<!--cp-let-subrange1-->
			<li id="cp-let-subfrag-clone">
%下位~断片 ~LET %下位~範囲o の`中身を~clone$rgした結果
◎
Let subfragment be the result of cloning the contents of subrange.
</li>
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<li>
<p>
%包含されている子たち 内の~EACH ( %包含されている子 ) に対し：
◎
For each contained child in contained children:
</p>

		<ol>
			<li>
%clone ~LET 
( `~clone子孫^f： ~ON )
を与える下で，
%包含されている子 を`~clone$した結果
◎
Let clone be a clone of contained child with the clone children flag set.
</li>
			<!--cp-append-clone--> 

		</ol>
	</li>
	<li>
		<!--cp-if-last-pcc-->
		<!--cp-if-last-pcc-note-->
		<ol>
			<!--cp-let-clone-end-->
			<!--cp-set-clone-data-3-->
			<!--cp-append-clone-->
		</ol>
	</li>
	<li>
		<!--cp-elif-pcc-not-null-->
		<ol>
			<!--cp-let-clone-last-pcc-->
			<!--cp-append-clone-->
			<!--cp-let-subrange2-->
			<!--cp-let-subfrag-clone-->
			<!--cp-append-subfrag-->
		</ol>
	</li>
	<!--cp-ret-flag-->
</ol>

<dl class="idl-def">
	<dt>@cloneContents()</dt>
	<dd>
被呼出時には、此れの`中身を~clone$rgした結果を返さ~MUST。
◎
The cloneContents() method, when invoked, must return the result of cloning the contents of context object.
</dd>
</dl>

<p class="algo-head">
`~node$ %node を`範囲o$ %範囲o の
`中身に挿入-@rg
するときは，次を走らす：
◎
To insert a node node into a range range, run these steps:
</p>

<p class="trans-note">【
`始端$の直後に %node を挿入する。
それに伴い、終端は，末尾側からの相対位置が変化しないように適宜ずらされる（すなわち、挿入-後の 始端／終端 の，先頭／末尾 からの相対位置は不変）。
始端が`文字~data~node$の内部を指している場合、その~nodeは始端の所で 2 つに分割される。
】</p>

<ol>
	<li>
( %始端~node, %始端~offset ) ~LET %範囲o の ( `始端~node$, `始端~offset$ )
◎
↓</li>
	<li>
<p>
~IF［
%始端~node は次のいずれかを満たす
］
⇒
~THROW `HierarchyRequestError$E
：
</p>

<ul ><li>$ProcessingInstruction ~nodeである
</li><li>$Comment ~nodeである
</li><li>［
$Text `~node$である
］~AND［
`親$ ~EQ ~NULL
］
</li><li>%始端~node ~EQ %node
</li></ul>

◎
If range’s start node is a ProcessingInstruction or Comment node, is a Text node whose parent is null, or is node, then throw a HierarchyRequestError.
</li>
	<li>
%基準~node ~LET ~NULL
◎
Let referenceNode be null.
</li>
	<li>
~IF［
%始端~node は $Text `~node$である
］
⇒
%基準~node ~SET %始端~node
◎
If range’s start node is a Text node, set referenceNode to that Text node.
</li>
	<li>
~ELIF［
%始端~node の`子$に［
`指数$ ~EQ %始端~offset
］なるものが在る
］
⇒
%基準~node ~SET それ
◎
Otherwise, set referenceNode to the child of start node whose index is start offset, and null if there is no such child.
</li>
	<li>
%親 ~LET ［
%基準~node ~NEQ ~NULL ならば その`親$ ／
~ELSE_ %始端~node
］
◎
Let parent be range’s start node if referenceNode is null, and referenceNode’s parent otherwise.
</li>
	<li>
%node を %親 の中で %基準~node の前に`挿入し得るかどうか検証する$
◎
Ensure pre-insertion validity of node into parent before referenceNode.
</li>
	<li>
<p >
~IF［
%始端~node は $Text `~node$である
］
⇒
%基準~node ~SET %始端~node を %始端~offset の所で`分割-$した結果
</p>
<p class="trans-note">【
%始端~offset が 0 でも ^Text ~nodeは`分割-$されることになる。
】</p>
◎
If range’s start node is a Text node, set referenceNode to the result of splitting it with offset range’s start offset.
</li>
	<li>
~IF［
%node ~EQ %基準~node
］
⇒
%基準~node ~SET %node の`弟$
◎
If node is referenceNode, set referenceNode to its next sibling.
</li>
	<li>
~IF［
%node の`親$ ~NEQ ~NULL
］
⇒
%node を %node の`親$から`除去-$する
◎
If node’s parent is not null, remove node from its parent.
</li>
	<li>
%新-~offset ~LET ［
%基準~node ~NEQ ~NULL ならば その`指数$ ／
~ELSE_ %親 の`長さ$
］
◎
Let newOffset be parent’s length if referenceNode is null, and referenceNode’s index otherwise.
</li>
	<li>
%新-~offset ~INCBY ［
%node は`文書片$であるならば その`長さ$ ／
~ELSE_ 1
］
◎
Increase newOffset by node’s length if node is a DocumentFragment node, and one otherwise.
</li>
	<li>
%親 の中で， %node を %基準~node の前に`前挿入$する
◎
Pre-insert node into parent before referenceNode.
</li>
	<li>
<p>
~IF［
%範囲o の`始端$ ~EQ %範囲o の`終端$
］
⇒
%範囲o の`終端$ ~SET `境界点$( %親, %新-~offset )
</p>

<p class="trans-note">【
始端 ~NEQ 終端の場合の終端の位置は，`前挿入$（が呼び出す`挿入-$）の段階で適宜ずらされる。
】</p>

◎
If range’s start and end are the same, set range’s end to (parent, newOffset).
</li>
</ol>

<dl class="idl-def">
	<dt>@insertNode(node)</dt>
	<dd>
被呼出時には、
%node を此れの`中身に挿入-$rgし~MUST。
◎
The insertNode(node) method, when invoked, must range insert node into context object.
</dd>

	<dt>@surroundContents(newParent)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The surroundContents(newParent) method, when invoked,, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れに`部分的に包含され$ている, かつ
$Text でない`~node$が在る
］
⇒
~THROW `InvalidStateError$E
◎
If a non-Text node is partially contained in the context object, then throw an InvalidStateError.
</li>
			<li>
~IF［
%newParent は
$Document, $DocumentType, $DocumentFragment `~node$
のいずれかである
］
⇒
~THROW `InvalidNodeTypeError$E
◎
If newParent is a Document, DocumentType, or DocumentFragment node, then throw an InvalidNodeTypeError.
</li>
			<li>
%断片 ~LET 此れの`中身を抽出-$rgした結果
◎
Let fragment be the result of extracting context object.
</li>
			<li>
~IF［
%newParent は`子$を持つ
］
⇒
%newParent の内容を ~NULL で`すべて置換-$する
◎
If newParent has children, replace all with null within newParent.
</li>
			<li>
%newParent を此れの`中身に挿入-$rgする
◎
Range insert newParent into context object.
</li>
			<li>
<p>
%断片 を %newParent に`付加-$する
</p>

<p class="trans-note">【
%newParent が`文字~data~node$であった場合、（ `中身に挿入-$rgした上で）この段で例外が投出されることになる。
】</p>

◎
Append fragment to newParent.
</li>
			<li>
%newParent を，此れの`中身として選択-$rgする
◎
Select newParent within context object.
</li>
		</ol>
	</dd>

	<dt>@cloneRange()</dt>
	<dd>
被呼出時には、次のように設定された 新たな`範囲o$を返さ~MUST
⇒＃
`始端$ ~SET 此れの`始端$の複製,<!--  -->
`終端$ ~SET 此れの`終端$の複製
◎
The cloneRange() method, when invoked, must return a new range with the same start and end as context object.
</dd>

	<dt>@detach()</dt>
	<dd>
被呼出時には、何もしては~MUST_NOT。
◎
The detach() method, when invoked, must do nothing.＼
</dd>
	<dd class="note">注記：
この機能性（ ^Range ~objの不能化）は、取除かれた。
互換性のため存続はするが。
◎
Its functionality (disabling a Range object) was removed, but the method itself is preserved for compatibility.
</dd>
</dl>


<dl class="domintro">
<!-- 
	<dt>range . cloneRange()†</dt>

	<dt>range . detach()†</dt>
-->

	<dt>%position = %range . $isPointInRange( node, offset )</dt>
	<dd>
`境界点$( %node, %offset ) が %range 内に入る†かどうかを返す。
</dd>

	<dt>%position = %range . $comparePoint( node, offset )</dt>
	<dd>
`境界点$( %node, %offset ) が
%range より前に位置する場合は ~MINUS 1 を,
%range 内に入る†場合は 0 を,
%range より後に位置する場合は 1 を
返す。<!-- * -->
◎
Returns −1 if the point is before the range, 0 if the point is in the range, and 1 if the point is after the range.
</dd>

	<dd class="trans-note">【†
境界点が %range のいずれかの境界点に一致する場合も，“入る” と見なされる。
】</dd>

	<dt>%intersects = %range . $intersectsNode( node )</dt>
	<dd>
%range が %node と交わるかどうかを返す。
◎
Returns whether range intersects node.
</dd>

	<dd class="trans-note">
<p>【
%node が %range に隣接している場合（ %range の終端（始端）が %node の <em>外縁の</em> 始端（終端）を指す境界点に一致する場合）は、“交わらない”。
例えば下図で `s^c, `e^c が %range の境界点を表すとするとき，図の~COLOR_Yが表す %node は交わらない。
】</p>

`[|[y|(|.|)|]|s[|(|.|.|)|e[y|(|.|.|)|]|]|]^bpex

<p>【
一般に、 %node は %範囲o に
(1) `包含され$ているとき, または
(2) %範囲o の始端~node／終端~nodeいずれかの`広義先祖$であるとき、
“交わる”。
】</p>
	</dd>

	<dt>$stringifier</dt>
	<dd>
範囲oを文字列化した結果は、範囲oにより “選択-” されているすべての~textになる。
</dd>
</dl>

<p class="trans-note">【
上のブロックに挙げた ^isPointInRange(), ^stringifier は、原文には存在しない，この訳による補完。
】</p>


<dl class="idl-def">
	<dt>@isPointInRange(node, offset)</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The isPointInRange(node, offset) must run these steps:
</p>
		<ol>
			<li id="cp-ret-F-if-root">
~IF［
%node の`根$ ~NEQ 此れの`根$rg
］
⇒
~RET ~F
◎
If node’s root is different from the context object’s root, return false.
</li>
			<!--cp-throw-if-doctype-->
			<!--cp-throw-if-length-->
			<li>
~IF［
`境界点$( %node, %offset ) は［［
此れの`始端$より `前bp$
］~OR［
此れの`終端$より `後bp$
］］］
⇒
~RET ~F
◎
If (node, offset) is before start or after end, return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</dd>

	<dt>@comparePoint(node, offset)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The comparePoint(node, offset) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%node の`根$ ~NEQ 此れの`根$rg
］
⇒
~THROW `WrongDocumentError$E
◎
If node’s root is different from the context object’s root, then throw a WrongDocumentError.
</li>
			<!--cp-throw-if-doctype-->
			<!--cp-throw-if-length-->
			<li>
~IF［
`境界点$( %node, %offset ) は
此れの`始端$より `前bp$
］
⇒
~RET ~MINUS 1
◎
If (node, offset) is before start, return −1.
</li>
			<li> 
~IF［
`境界点$( %node, %offset ) は
此れの`終端$より `後bp$
］
⇒
~RET 1
◎
If (node, offset) is after end, return 1.
</li>
			<li>
~RET 0
◎
Return 0.
</li>
		</ol>
	</dd>

	<dt>@intersectsNode(node)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The intersectsNode(node) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-ret-F-if-root-->
			<!--cp-let-parent-->
			<li>
~IF［
%親 ~EQ ~NULL
<!-- すなわち node は根 -->
］
⇒
~RET ~T
◎
If parent is null, return true.
</li>
			<li>
%offset ~LET %node の`指数$
◎
Let offset be node’s index.
</li>
			<li>
~IF［
`境界点$( %親, %offset ) は
此れの`終端$より`前bp$
］~AND［
`境界点$( %親, %offset ~PLUS 1 ) は
此れの`始端$より`後bp$
<!-- selectNode の結果 -->
］
⇒
~RET ~T
◎
If (parent, offset) is before end and (parent, offset + 1) is after start, return true.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</dd>

	<dt>@stringifier</dt>
	<dd>
<p>
文字列化の挙動は、次を走らせ~MUST：
◎
The stringification behavior must run these steps:
</p>
		<ol>
			<li>
%s ~LET 空~文字列
◎
Let s be the empty string.
</li>
			<li>
~IF［
`始端~node$ ~EQ `終端~node$
］~AND［
それは $Text `~node$である
］
⇒
~RET ［
その $Text `~node$の`~data$
］の［
`始端~offset$ から`終端~offset$ までの部分文字列
］
◎
If start node is end node, and it is a Text node, return the substring of that Text node’s data beginning at start offset and ending at end offset.
</li>
			<li>
~IF［
`始端~node$ は $Text `~node$である
］
⇒
［
その`~node$の`~data$
］の［
`始端~offset$ から末尾までの部分文字列
］を
%s に付加する
◎
If start node is a Text node, append to s the substring of that node’s data from the start offset until the end.
</li>
			<li>
此れに`包含され$ている~EACH ( $Text `~node$ ) に対し，`木~順序$で
⇒
その`~data$を %s に付加する
◎
Append to s the concatenation, in tree order, of the data of all Text nodes that are contained in the context object.
</li>
			<li>
~IF［
`終端~node$ は $Text `~node$である
］
⇒
［
その`~node$の`~data$
］の［
先頭から`終端~offset$ までの部分文字列
］を %s に付加する
◎
If end node is a Text node, append to s the substring of that node’s data from its start until the end offset.
</li>
			<li>
~RET %s
◎
Return s.
</li>
		</ol>
	</dd>
</dl>

<hr>

<p class="note">注記：
^Range ~ifcに対する拡張として、他の仕様にて
`createContextualFragment()$m,
`getClientRects()$m,
`getBoundingClientRect()$m
~methが定義されている。
`DOM-Parsing$r
`CSSOM-VIEW$r
◎
The createContextualFragment(), getClientRects(), and getBoundingClientRect() methods are defined in other specifications. [DOM-Parsing] [CSSOM-VIEW]
</p>


		</section>
	</section>
	<section id="traversal">
<h2 title="Traversal">6. 走査</h2>

<p>
$NodeIterator ／ $TreeWalker ~objを利用すれば、`~node$`木$を~filterにかけながら走査できる。
◎
NodeIterator and TreeWalker objects can be used to filter and traverse node trees.
</p>

<div class="p">
<p>
各 $NodeIterator ／ $TreeWalker ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`作動中~flag@</dt>
	<dd>
再帰的な呼出を避けるためにある。
初期~時は ~OFF 。
</dd>

	<dt>`根~node@</dt>
	<dd>
走査-対象にされる部分木の根を与える，`~node$。
</dd>

	<dt>`whatToShow ~bitmask@</dt>
	<dd>
どの型（ $Node.nodeType ）の~nodeを走査するかを指示する，整数~bitmask。
1 にされた~bitに対応する型の~nodeのみが~filterを “通過する” 。
</dd>

	<dt>`~filter~callback@</dt>
	<dd>
対象を更に “濾過する” ~~条件を与える $NodeFilter ~obj,
または ~NULL （濾過されない）。
</dd>

</dl>

<p class="trans-note">【
作動中~flag以外の各項目の説明は、訳者による補足。
】</p>

◎
Each NodeIterator and TreeWalker object has an associated active flag to avoid recursive invocations. It is initially unset.
◎
Each NodeIterator and TreeWalker object also has an associated root node, whatToShow bitmask, and filter callback.
</div>


<p class="algo-head">
%node を
`~filterにかける@
ときは、次を走らす：
◎
To filter node run these steps:
</p>

<ol>
	<li>
~IF［
`作動中~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidStateError$E
◎
If the active flag is set, then throw an InvalidStateError.
</li>
	<li>
%n ~LET %node の $Node.nodeType 属性~値~MINUS 1
◎
Let n be node’s nodeType attribute value minus 1.
</li>
	<li>
~IF［
`whatToShow ~bitmask$ の %n 番目の~bit（ 0 番目が最下位~bitとする） ~EQ 0
］
⇒
~RET $NodeFilter.FILTER_SKIP
	<!-- !((1 << (node.nodeType - 1)) & whatToShow) -->
◎
If the nth bit (where 0 is the least significant bit) of whatToShow is not set, then return FILTER_SKIP.
</li>
	<li>
~IF［
`~filter~callback$ ~EQ ~NULL
］
⇒
~RET $NodeFilter.FILTER_ACCEPT
◎
If filter is null, then return FILTER_ACCEPT.
</li>
	<li>
`作動中~flag$ ~SET ~ON
◎
Set the active flag.
</li>
	<li>
<p>
%結果 ~LET 次を与える下で，`利用者~objの演算を~call$した結果：
</p>

<ul ><li>`~filter~callback$
</li><li>`acceptNode^l
</li><li>引数~list： « %node »
</li></ul>

<p>
~callした結果，例外が投出されたときは、~catchして：
</p>

<ol ><li>`作動中~flag$ ~SET ~OFF
</li><li>~THROW その例外
</li></ol>

◎
Let result be the return value of call a user object’s operation with filter, "acceptNode", and a list of arguments consisting of node. If that throws an exception, then unset the active flag and rethrow the exception.
</li>
	<li>
`作動中~flag$ ~SET ~OFF
◎
Unset the active flag.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

		<section id="interface-nodeiterator">
<h3>6.1. ~ifc ^@NodeIterator</h3>

⇒！
[`Exposed$=Window]
interface @NodeIterator {
  [`SameObject$] ~RA $Node $root;
  ~RA $Node $referenceNode;
  ~RA ~B $pointerBeforeReferenceNode;
  ~RA ~UL $whatToShow;
  ~RA $NodeFilter? $filter;

  $Node? $nextNode();
  $Node? $previousNode();

  void $detach();
};
◎

<p class="note">注記：
$NodeIterator ~objは
$Document.createNodeIterator()
~methにより作成できる。
◎
NodeIterator objects can be created using the createNodeIterator() method.
</p>

<div class="p">
<p>
各 $NodeIterator ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`反復器~collection@</dt>
	<dd>
次のようにされた`~collection$
⇒＃
`根$cl ~SET `根~node$,
`~filter$は どの`~node$にも合致する
</dd>
</dl>

◎
Each NodeIterator object has an associated iterator collection, which is a collection rooted at root, whose filter matches any node.
</div>

<p class="note">注記：
前に示したように、各 $NodeIterator ~objには［
`作動中~flag$,
`根~node$,
`whatToShow ~bitmask$,
`~filter~callback$
］が結付けられる。
◎
As mentioned earlier, NodeIterator objects have an associated active flag, root node, whatToShow bitmask, and filter callback as well.
</p>

<p class="algo-head">
`前除去-時の手続き@
は、所与の
( $NodeIterator %反復器, `~node$ %被除去~node )
に対し，次に従う：
◎
The NodeIterator pre-removing steps given a nodeIterator and toBeRemovedNode, are as follows:
</p>

<ol>
	<li>
~IF［
%被除去~node は［
%反復器 の $referenceNode 属性~値
］の`広義先祖$でない
］
⇒
~RET
◎
If toBeRemovedNode is not an inclusive ancestor of the referenceNode attribute value, then return.
</li>
	<li>
<p>
~IF［
%反復器 の $pointerBeforeReferenceNode 属性~値 ~EQ ~T
］：
◎
If the pointerBeforeReferenceNode attribute value is true, then:
</p>

		<ol>
			<li>
<p>
%次 ~LET 次をすべて満たす`~node$ %N のうち，`最初0$のもの：
</p>

<ul><li>%N は %被除去~node に`後続-$する
</li><li>%N は %反復器 の`根~node$の`広義子孫$である
</li><li>%N は %被除去~node の`広義子孫$でない
</li></ul>

◎
Let next be toBeRemovedNode’s first following node that is an inclusive descendant of nodeIterator’s root and is not an inclusive descendant of toBeRemovedNode, and null if there is no such node.
</li>
			<li>
~IF［
%次 ~NEQ ~NULL
］
⇒＃
%反復器 の $referenceNode 属性 ~SET %次；
~RET
◎
If next is non-null, then set nodeIterator’s referenceNode attribute to next and return.
</li>
			<li>
%反復器 の $pointerBeforeReferenceNode 属性 ~SET ~F
◎
Otherwise, set nodeIterator’s pointerBeforeReferenceNode attribute to false.
◎
Steps are not terminated here.
</li>
		</ol>
	</li>
	<li>
%兄 ~LET %被除去~node の`兄$
◎
↓</li>
	<li>
%反復器 の $referenceNode 属性 ~SET［
%兄 ~EQ ~NULL ならば %被除去~node の`親$ ／
~ELSE_ %兄 の`広義子孫$のうち，`最後0$のもの
］
◎
Set nodeIterator’s referenceNode attribute to toBeRemovedNode’s parent, if toBeRemovedNode’s previous sibling is null, and to the inclusive descendant of toBeRemovedNode’s previous sibling that appears last in tree order otherwise.
</li>
</ol>

<hr>

<dl class="idl-def">
	<dt>@root</dt>
	<dd>
取得子は、`根~node$を返さ~MUST。
◎
The root attribute’s getter must return root.
</dd>

	<dt>@referenceNode</dt>
	<dt>@pointerBeforeReferenceNode</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化-時の値を返さ~MUST。
◎
The referenceNode and pointerBeforeReferenceNode attributes must return what they were initialized to.
</dd>
	<dd class="trans-note">【
概念的には、この 2 つの属性の組により、`走査-$において “次” の~nodeを探索する開始地点を指す，~pointerが表現される。
^referenceNode （初期~値は先頭の~node（`根~node$））が “現在の” ~nodeを表し、真偽値をとる ^pointerBeforeReferenceNode （初期~値は ~T ）に従って、~pointerは，現在の~nodeの “直後” （ ~F ）または “直前” （ ~T ）を指す（すなわち、初期~時の~pointerは先頭の~nodeの直前を指している）。
】</dd>

	<dt>@whatToShow</dt>
	<dd>
取得子は、`whatToShow ~bitmask$ を返さ~MUST。
◎
The whatToShow attribute’s getter must return whatToShow.
</dd>

	<dt>@filter</dt>
	<dd>
取得子は、`~filter~callback$を返さ~MUST。
◎
The filter attribute’s getter must return filter.
</dd>
</dl>


<p class="algo-head">
所与の %方向 （ `順^i または `逆^i ）へ，此れ（ $NodeIterator ~obj）を
`走査-@
するときは、次を走らす：
◎
To traverse in direction direction run these steps:
</p>

<ol>
	<li>
%node ~LET
此れの $referenceNode 属性の値
◎
Let node be the value of the referenceNode attribute.
</li>
	<li>
%node直前 ~LET
此れの $pointerBeforeReferenceNode 属性の値
◎
Let before node be the value of the pointerBeforeReferenceNode attribute.
</li>
	<li>
%collection ~LET 此れの`反復器~collection$
◎
↓</li>
	<li>
<p id="cp-repeat">
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
<p>
~IF［
%方向 ~EQ `順^i
］：
◎
If direction is next
</p>

				<ol>
					<li>
<p>
~IF［
%node直前 ~EQ ~F
］：
◎
If before node is false,＼
</p>

						<ol>
							<li>
%node ~SET %collection の中で %node に`後続-$する`最初0$の`~node$
◎
let node be the first node following node in the iterator collection.＼
</li>
							<li>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If there is no such node return null.＼
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%node直前 ~SET ~F
◎
If before node is true, set it to false.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %方向 ~EQ `逆^i ）：
◎
If direction is previous
</p>

				<ol>
					<li>
<p>
~IF［
%node直前 ~EQ ~T
］：
◎
If before node is true,＼
</p>
						<ol>
							<li>
%node ~SET %collection の中で %node に`先行-$する`最後0$の`~node$
◎
let node be the first node preceding node in the iterator collection.＼
</li>
							<li>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If there is no such node, then return null.＼
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%node直前 ~SET ~T
◎
If before node is false, set it to true.
</li>
				</ol>
			</li>
			<li>
~IF［
%node を`~filterにかけた$結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
~BREAK
◎
Filter node and let result be the return value.
◎
If result is FILTER_ACCEPT, then break.
</li>
		</ol>
	</li>
	<li>
此れの $referenceNode 属性 ~SET %node
◎
Set the referenceNode attribute to node,＼
</li>
	<li>
此れの $pointerBeforeReferenceNode 属性 ~SET %node直前
◎
set the pointerBeforeReferenceNode attribute to before node, and＼
</li>
	<li>
~RET %node
◎
return node.
</li>
</ol>

<p class="trans-note">【
走査の方向が前回と逆向きに切り替わった場合、探索は，前回の走査による
“現在の” ~node（ ^referenceNode ）から開始されることに注意（その次／前の~nodeからではなく）。
探索の結果，`~filter$に合致する~nodeが見出されなかった場合、属性は変更されない。
見出された場合、
^referenceNode は，新たに見出された~nodeにされ、
^pointerBeforeReferenceNode （ “現在の” 走査-方向）は，~~入力された方向を表すようにされる（ ~F が `順^i 方向に対応する）。
】</p>

<dl class="idl-def">
	<dt>@nextNode()</dt>
	<dd>
被呼出時には、 `順^i 方向へ，此れを`走査-$した結果を返さ~MUST。
◎
The nextNode() method, when invoked, must return the result of traversing in direction next.
</dd>

	<dt>@previousNode()</dt>
	<dd>
被呼出時には、 `逆^i 方向へ，此れを`走査-$した結果を返さ~MUST。
◎
The previousNode() method, when invoked, must return the result of traversing in direction previous.
</dd>

	<dt>@detach()</dt>
	<dd>
被呼出時には、何もしては~MUST_NOT。
◎
The detach() method, when invoked, must do nothing.＼
</dd>
	<dd class="note">注記：
この機能性（ ^NodeIterator ~objの不能化）は、取除かれた。
互換性のため存続はするが。
◎
Its functionality (disabling a NodeIterator object) was removed, but the method itself is preserved for compatibility.
</dd>

</dl>


		</section>
		<section id="interface-treewalker">
<h3>6.2. ~ifc ^@TreeWalker</h3>

⇒！
[`Exposed$=Window]
interface @TreeWalker {
  [`SameObject$] ~RA $Node $root;
  ~RA ~UL $whatToShow;
  ~RA $NodeFilter? $filter;
           attribute $Node $currentNode;

  $Node? $parentNode();
  $Node? $firstChild();
  $Node? $lastChild();
  $Node? $previousSibling();
  $Node? $nextSibling();
  $Node? $previousNode();
  $Node? $nextNode();
};
◎

<p class="note">注記：
$TreeWalker ~objは
$Document.createTreeWalker()
~methにより作成できる。
◎
TreeWalker objects can be created using the createTreeWalker() method.
</p>

<p class="note">注記：
前に示したように、各 $TreeWalker ~objには
`根~node$,
`whatToShow ~bitmask$,
`~filter~callback$
が結付けられる。
◎
As mentioned earlier TreeWalker objects have an associated root node, whatToShow bitmask, and filter callback.
</p>

<dl class="idl-def">
	<dt>@root</dt>
	<dd>
取得子は、此れの`根~node$を返さ~MUST。
◎
The root attribute’s getter must return root.
</dd>

	<dt>@whatToShow</dt>
	<dd>
取得子は、此れの `whatToShow ~bitmask$ を返さ~MUST。
◎
The whatToShow attribute’s getter must return whatToShow.
</dd>

	<dt>@filter</dt>
	<dd>
取得子は、此れの`~filter~callback$を返さ~MUST。
◎
The filter attribute’s getter must return filter.
</dd>

	<dt>@currentNode</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The currentNode attribute must return what it was initialized to.
</dd>
	<dd>
設定子は、与えられた値に設定し~MUST。
<!-- * -->
◎
Setting the currentNode attribute must set it to the new value.
</dd>

	<dt>@parentNode()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The parentNode() method, when invoked, must run these steps:
</p>
		<ol>
			<li id="cp-let-current">
%node ~LET 此れの $currentNode 属性の値
◎
Let node be the value of the currentNode attribute.
</li>
			<li>
<p>
~WHILE［
%node ~NEQ ~NULL
］~AND［
%node ~NEQ `根~node$
］：
◎
While node is not null and is not root:
</p>

				<ol>
					<li>
%node ~SET %node の`親$<!-- * LET -->
◎
Let node be node’s parent.
</li>
					<li>
<p >
~IF［
%node ~NEQ ~NULL
］~AND［
%node を`~filterにかけた$結果 ~EQ $NodeFilter.FILTER_ACCEPT
］：
◎
If node is not null and filtering node returns FILTER_ACCEPT, then＼
</p>

						<ol>
							<li>
此れの $currentNode 属性 ~SET %node
◎
set the currentNode attribute to node,＼
</li>
							<li>
~RET %node
◎
return node.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li id="cp-TW-ret-null">
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
所与の %側 （ `最初^i または `最後^i ）から，此れ（ $TreeWalker ~obj）の
`子を走査-@
するときは、次を走らす：
◎
To traverse children of type type, run these steps:
</p>
<!-- 走査順序（`最初^i の場合）
N →
	(SKIP && N.firstChild) || 
	N0.nextSibling || N1.nextSibling || N2.nextSibling || ...
		// Nn = N(n-1).parentNode, N0 = N

-->
<ol>
	<!--cp-let-current-->
	<li>
%node ~SET %側 に応じて［
`最初^i ならば %node の`最初0の子$ ／
`最後^i ならば %node の`最後0の子$
］
◎
Set node to node’s first child if type is first, and node’s last child if type is last.
</li>
	<li>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If node is null, return null.
</li>
	<li id="concept-traverse-children-main">
<p>
~WHILE 無条件：
◎
Main: while true: 
</p>

		<ol>
			<li id="cp-let-filter-result">
%結果 ~LET %node を`~filterにかけた$結果
◎
Filter node and let result be the return value.
</li>
			<li id="cp-set-current-if-accept">
<p>
~IF［
%結果 ~EQ $NodeFilter.FILTER_ACCEPT
］：
◎
If result is FILTER_ACCEPT, then＼
</p>
				<ol>
					<li>
此れの $currentNode 属性 ~SET %node
◎
set the currentNode attribute to node and＼
</li>
					<li>
~RET %node
◎
return node.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%結果 ~EQ $NodeFilter.FILTER_SKIP
］：
◎
If result is FILTER_SKIP, then:
</p>
				<ol>
					<li>
%子 ~LET %側 に応じて［
`最初^i ならば %node の`最初0の子$ ／
`最後^i ならば %node の`最後0の子$
］
◎
Let child be node’s first child if type is first, and node’s last child if type is last.
</li>
					<li>
<p>
~IF［
%子 ~NEQ ~NULL
］：
◎
If child is not null,＼
</p>
						<ol>
							<li>
%node ~SET %子
◎
set node to child and
</li>
							<li>
~CONTINUE
◎
goto Main.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<!--cp-repeat-->
				<ol>
					<li>
%同胞 ~LET %側 に応じて［
`最初^i ならば %node の`弟$ ／
`最後^i ならば %node の`兄$
］
◎
Let sibling be node’s next sibling if type is first, and node’s previous sibling if type is last.
</li>
					<li>
<p>
~IF［
%同胞 ~NEQ ~NULL
］：
◎
If sibling is not null,＼
</p>
						<ol>
							<li>
%node ~SET %同胞
◎
set node to sibling and＼
</li>
							<li>
~BREAK
◎
goto Main.
</li>
						</ol>
					</li>
					<li>
%親 ~LET %node の`親$
◎
Let parent be node’s parent.
</li>
					<li>
~IF［
%親 ~IN { ~NULL, `根~node$, 此れの $currentNode 属性の値 }
］
⇒
~RET ~NULL
◎
If parent is null, parent is root, or parent is currentNode attribute’s value, return null.
</li>
					<li>
~ELSE
⇒
%node ~SET %親
◎
Otherwise, set node to parent.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<dl class="idl-def">
	<dt>@firstChild()</dt>
	<dd>
被呼出時には、 `最初^i から，此れの`子を走査-$した結果を返さ~MUST。
◎
The firstChild() method, when invoked, must traverse children of type first.
</dd>

	<dt>@lastChild()</dt>
	<dd>
被呼出時には、 `最後^i から，此れの`子を走査-$した結果を返さ~MUST。
◎
The lastChild() method, when invoked, must traverse children of type last.
</dd>
</dl>


<p class="algo-head">
所与の %方向 （ `順^i または `逆^i ）へ，此れ（ $TreeWalker ~obj）の
`同胞を走査-@
するときは、次を走らす：
◎
To traverse siblings of type type run these steps:
</p>

<ol>
	<!--cp-let-current-->
	<li>
~IF［
%node ~EQ `根~node$
］
⇒
~RET ~NULL
◎
If node is root, return null.
</li>
	<li>
<!--cp-repeat-->
		<ol>
			<li>
%同胞 ~LET %方向 に応じて［
`順^i ならば %node の`弟$ ／
`逆^i ならば %node の`兄$
］
◎
Let sibling be node’s next sibling if type is next, and node’s previous sibling if type is previous.
</li>
			<li>
<p>
~WHILE［
%同胞 ~NEQ ~NULL
］：
◎
While sibling is not null:
</p>
				<ol>
					<li>
%node ~SET %同胞
◎
Set node to sibling.
</li>
					<!--cp-let-filter-result-->
					<!--cp-set-current-if-accept-->
					<li>
%同胞 ~SET %方向 に応じて［
`順^i ならば %node の`最初0の子$ ／
`逆^i ならば %node の`最後0の子$
］
◎
Set sibling to node’s first child if type is next, and node’s last child if type is previous.
</li>
					<li>
~IF［
%結果 ~EQ $NodeFilter.FILTER_REJECT
］~OR［
%同胞 ~EQ ~NULL
］
⇒
%同胞 ~SET %方向 に応じて［
`順^i ならば %node の`弟$ ／
`逆^i ならば %node の`兄$
］
◎
If result is FILTER_REJECT or sibling is null, then set sibling to node’s next sibling if type is next, and node’s previous sibling if type is previous.
</li>
				</ol>
			</li>
			<li>
%node ~SET その`親$
◎
Set node to its parent.
</li>
			<li>
~IF［
%node ~IN { ~NULL, `根~node$ }
］
⇒
~RET ~NULL
◎
If node is null or is root, return null.
</li>
			<li>
~IF［
%node を`~filterにかけた$結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒
~RET ~NULL
◎
Filter node and if the return value is FILTER_ACCEPT, then return null.
</li>
		</ol>
	</li>
</ol>

<dl class="idl-def">
	<dt>@nextSibling()</dt>
	<dd>
被呼出時には、
`順^i 方向へ，此れの`同胞を走査-$した結果を返さ~MUST。
◎
The nextSibling() method, when invoked, must traverse siblings of type next.
</dd>

	<dt>@previousSibling()</dt>
	<dd>
被呼出時には、
`逆^i 方向へ，此れの`同胞を走査-$した結果を返さ~MUST。
◎
The previousSibling() method, when invoked, must traverse siblings of type previous.
</dd>

	<dt>@previousNode()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The previousNode() method, when invoked, must run these steps:
</p>

		<ol>
			<!--cp-let-current-->
			<li>
<p>
~WHILE［
%node ~NEQ `根~node$
］：
◎
While node is not root:
</p>
				<ol>
					<li>
%同胞 ~LET %node の`兄$
◎
Let sibling be the previous sibling of node.
</li>
					<li>
<p>
~WHILE［
%同胞 ~NEQ ~NULL 
］：
◎
While sibling is not null:
</p>
						<ol>
							<li>
%node ~SET %同胞
◎
Set node to sibling.
</li>
							<!--cp-let-filter-result-->
							<li>
<p >
~WHILE［
%結果 ~NEQ $NodeFilter.FILTER_REJECT
］~AND［
%node は`子$を持つ
］：
</p>

<ol ><li>%node ~SET %node の`最後0の子$
</li><li>%結果 ~SET %node を`~filterにかけた$結果
</li></ol>

◎
While result is not FILTER_REJECT and node has a child, set node to its last child and then filter node and set result to the return value.
</li>
							<!--cp-set-current-if-accept-->
							<li>
%同胞 ~SET %node の`兄$
◎
Set sibling to the previous sibling of node.
</li>
						</ol>
					</li>
					<li>
~IF［
%node ~EQ `根~node$
］~OR［
%node の`親$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If node is root or node’s parent is null, return null.
</li>
					<li>
%node ~SET %node の`親$
◎
Set node to its parent.
</li>
					<li>
~IF［
%node を`~filterにかけた$結果 ~EQ $NodeFilter.FILTER_ACCEPT
］
⇒＃
此れの $currentNode 属性 ~SET %node；
~RET %node
◎
Filter node and if the return value is FILTER_ACCEPT, then set the currentNode attribute to node and return node.
</li>
				</ol>
			</li>
			<!--cp-TW-ret-null-->
		</ol>
	</dd>

	<dt>@nextNode()</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The nextNode() method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-let-current-->
			<li>
%結果 ~LET $NodeFilter.FILTER_ACCEPT
◎
Let result be FILTER_ACCEPT.
</li>
			<li>
<!--cp-repeat-->
				<ol>
					<li>
<p>
~WHILE［
%結果 ~NEQ $NodeFilter.FILTER_REJECT
］~AND［
%node は`子$を持つ
］：
◎
While result is not FILTER_REJECT and node has a child:
</p>
						<ol>
							<li>
%node ~SET %node の`最初0の子$
◎
Set node to its first child.
</li>
							<li id="cp-set-filter-result">
%結果 ~SET %node を`~filterにかけた$結果
◎
Filter node and set result to the return value.
</li>
							<!--cp-set-current-if-accept-->
						</ol>
					</li>
					<li>
<p>
%node ~SET ［
%node に`後続-$する
］~AND［
`根~node$に`後続-$しない†
］ような `最初0$の`~node$
</p>

<p>
~IF［
%node ~EQ ~NULL
］
⇒
~RET ~NULL
</p>

<p class="trans-note">【†
次の条件も必要では？
“~AND %結果 ~EQ ^FILTER_REJECT の場合は %node の子孫~nodeでもない”
】</p>

◎
If a node is following node and is not following root, set node to the first such node. Otherwise, return null.
					</li>
					<!--cp-set-filter-result-->
					<!--cp-set-current-if-accept-->
				</ol>
			</li>
		</ol>
	</dd>
</dl>


		</section>
		<section id="interface-nodefilter">
<h3>6.3. ~ifc ^@NodeFilter</h3>

⇒！
[`Exposed$=Window]
callback interface @NodeFilter {
  // <span class="comment" title="Constants for acceptNode"
  ><code>$acceptNode()</code> 用の定数</span>
  ~CUS $FILTER_ACCEPT = 1;
  ~CUS $FILTER_REJECT = 2;
  ~CUS $FILTER_SKIP = 3;

  // <span class="comment" title="Constants for whatToShow bitmask"
  >`whatToShow ~bitmask$ 用の定数</span>
  ~CUL $SHOW_ALL = 0xFFFFFFFF;
  ~CUL $SHOW_ELEMENT = 0x1;
  ~CUL $SHOW_ATTRIBUTE = 0x2;
  ~CUL $SHOW_TEXT = 0x4;
  ~CUL $SHOW_CDATA_SECTION = 0x8;
  ~CUL @SHOW_ENTITY_REFERENCE = 0x10; // <!--cp-histroic-->
  ~CUL @SHOW_ENTITY = 0x20; // <!--cp-histroic-->
  ~CUL $SHOW_PROCESSING_INSTRUCTION = 0x40;
  ~CUL $SHOW_COMMENT = 0x80;
  ~CUL $SHOW_DOCUMENT = 0x100;
  ~CUL $SHOW_DOCUMENT_TYPE = 0x200;
  ~CUL $SHOW_DOCUMENT_FRAGMENT = 0x400;
  ~CUL @SHOW_NOTATION = 0x800; // <!--cp-histroic-->

  ~US @acceptNode($Node %node);
};
◎

<p>
$NodeFilter ~objは、`~filter~callback$として利用できる。
また、 `whatToShow ~bitmask$用の定数を提供する。
◎
NodeFilter objects can be used as filter callback and provide constants for the whatToShow bitmask.
</p>

<p class="note">注記：
概して，~JS関数として実装される。
◎
It is typically implemented as a JavaScript function.
</p>

<p class="idl-def">
~callbackの返値には、次の定数を利用できる（括弧内は数値）
`各~項目の説明は、訳者による補足^tnote：
◎
These constants can be used as callback return value:
</p>

<dl>
	<dt>@FILTER_ACCEPT (1)</dt>
	<dd>
~nodeは`~filter$を “通過する”。
</dd>

	<dt>@FILTER_REJECT (2)</dt>
	<dd>
~nodeはその子孫も含めて “濾過される”（子孫は`~filter$にかけることなく除外される）。
</dd>

	<dt>@FILTER_SKIP (3)</dt>
	<dd>
~node自身は “濾過される” が、その子孫は，依然として`~filter$の対象になり得る。
</dd>
</dl>


<p class="idl-def">
`whatToShow ~bitmask$には、次の定数を利用できる（括弧内は数値）：
◎
These constants can be used for the whatToShow bitmask:
</p>

<ul><li>@SHOW_ALL (4294967295 ~EQ 0xFFFFFFFF)
</li><li>@SHOW_ELEMENT (1)
</li><li>@SHOW_ATTRIBUTE (2)
</li><li>@SHOW_TEXT (4)
</li><li>@SHOW_CDATA_SECTION (8)
</li><li>@SHOW_PROCESSING_INSTRUCTION (64 ~EQ 0x40)
</li><li>@SHOW_COMMENT (128 ~EQ 0x80)
</li><li>@SHOW_DOCUMENT (256 ~EQ 0x100)
</li><li>@SHOW_DOCUMENT_TYPE (512 ~EQ 0x200)
</li><li>@SHOW_DOCUMENT_FRAGMENT (1024 ~EQ 0x400)
</li></ul>


		</section>
	</section>
	<section id="sets">
<h2 title="Sets">7. Set</h2>

<p class="note">
Yes, the name $DOMTokenList is an unfortunate legacy mishap.
</p>

		<section id="interface-domtokenlist">
<h3>7.1. ~ifc ^@DOMTokenList</h3>

⇒！
[`Exposed$=Window]
interface @DOMTokenList {
  ~RA ~UL $length;
  getter ~DS? $item(~UL %index);
  ~B $contains(~DS %token);
  [`CEReactions$] void $add(~DS... %tokens);
  [`CEReactions$] void $remove(~DS... %tokens);
  [`CEReactions$] ~B $toggle(~DS %token, optional ~B %force);
  [`CEReactions$] void $replace(~DS %token, ~DS %newToken );
  ~B $supports(~DS %token);
  [`CEReactions$] @stringifier attribute ~DS $value;
  iterable&lt;~DS&gt;;
};
◎


<div class="p">
<p>
各 $DOMTokenList には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~token集合@</dt>
	<dd>
一連の~tokenからなる`有順序~集合$
— 初期~時は空とする。
</dd>

	<dt>`要素@dtl</dt>
	<dd>
`要素$。
</dd>
	<dt>`属性oの局所~名@dtl</dt>
	<dd>
`属性o$の`局所~名$a。
</dd>
</dl>

◎
A DOMTokenList object has an associated token set (a set), which is initially empty.
◎
A DOMTokenList object also has an associated element and an attribute’s local name.
</div>

<p>
`適用仕様$は、個々の`局所~名$aに対し，
$DOMTokenList 用として
`被support~token集合@dtl
を定義して~MAY
— これは、一連の~tokenからなる集合であり，特に指定されない限り ε （未定義）とする。
◎
Specifications may define supported tokens for a DOMTokenList's associated attribute’s local name.
</p>

<p class="algo-head">
$DOMTokenList ~obj %O において，所与の %~token を
`検証-@dtl
するときは、次を走らす：
◎
A DOMTokenList object’s validation steps for a given token are:
</p>

<ul>
	<li>
%~token集合 ~LET %O の`属性oの局所~名$dtlに対する`被support~token集合$dtl
◎
↓</li>
	<li>
~IF［
%~token集合 ~EQ ε
］
⇒
~THROW `TypeError$E
◎
If the associated attribute’s local name does not define supported tokens, throw a TypeError.
</li>
	<li>
~RET［
%~token を`~ASCII小文字~化$した結果 ~IN %~token集合 ならば ~T ／
~ELSE_ ~F
］
◎
Let lowercase token be a copy of token, in ASCII lowercase.
◎
If lowercase token is present in supported tokens, return true.
◎
Return false.
</li>
</ul>

<hr>


<p class="algo-head">
所与の $DOMTokenList ~obj %O 対し，
( %要素, %名前 )
は
( %O の`要素$dtl, %O の`属性oの局所~名$dtl )
とするとき：
◎
↓</p>

<ul>
	<li>
<p>
%O の
`更新~手続き@
は、次を走らす：
◎
A DOMTokenList object’s update steps are:
</p>
		<ol>
			<li>
~IF［
%要素 の`属性o~list$は空である
］~AND［
%O の`~token集合$は空である
］
⇒
~RET
◎
If the associated element does not have an associated attribute and token set is empty, then return.
</li>
			<li>
%要素 の`属性o値を設定する$( %名前, ［
%O の`~token集合$を`有順序~集合 直列化器$にかけた結果
］ )
◎
Set an attribute value for the associated element using associated attribute’s local name and the result of running the ordered set serializer for token set.
</li>
		</ol>
	</li>
	<li>
%O の
`直列化-手続き@
は、次を返す
⇒
%要素 の`属性o値を取得する$( %名前 )
◎
A DOMTokenList object’s serialize steps are to return the result of running get an attribute value given the associated element and the associated attribute’s local name.
</li>
	<li>
<p>
%要素 上の`属性oを変更する手続き$は、次で与えられる：
</p>

		<ol>
			 <li>
<p>
~IF［
%局所~名 ~EQ %名前
］~AND［
%~ns ~EQ ~NULL
］：
</p>
				<ol>
					<li>
~IF［
%値 ~EQ ~NULL
］
⇒
%O の`~token集合$を`空にする$list
</li>
					 <li>
~ELSE
⇒
%O の`~token集合$ ~SET %値 を`有順序~集合 構文解析器$にかけた結果
</li>
				</ol>
◎
If localName is associated attribute’s local name, namespace is null, and value is null, then empty token set.
◎
Otherwise, if localName is associated attribute’s local name, namespace is null, then set token set to value, parsed.
</li>
		</ol>
	</li>
	<li>
<p>
%O の作成-時には、次を走らす：
◎
When a DOMTokenList object is created, then:
</p>

<ol>
	<li>
%値 ~LET ［
%要素 の`属性oを~nsと局所~名により取得する$( %名前, ~NULL )
］の`値$a
◎
Let element be associated element.
◎
Let localName be associated attribute’s local name.
◎
Let value be the result of getting an attribute given null, localName, and element.
</li>
	<li>
次を渡して，
%要素 上の`属性oを変更する手続き$を走らす
⇒
( %名前, %値, %値, ~NULL )
◎
Run the attribute change steps for element, localName, value, value, and null.
</li>
</ol>
	</li>
</ul>


<dl class="domintro">
	<dt>%tokenlist . $length</dt>
	<dd>
~tokenの個数を返す。
◎
Returns the number of tokens.
</dd>

	<dt>%tokenlist . $item(index)</dt>
	<dt>%tokenlist[%index]</dt>
	<dd>
%index 番の~tokenを返す。
◎
Returns the token with index index.
</dd>

	<dt>%tokenlist . $contains(token)</dt>
	<dd>
%token が在れば~T を, 無ければ~F を返す。
◎
Returns true if token is present, and false otherwise.
</dd>

	<dt>%tokenlist . $add(tokens…)</dt>
	<dd>
渡された引数のうち，まだ無いものを追加する。
◎
Adds all arguments passed, except those already present.
</dd>
	<dd>
<span id="cp-throw-if-some-token-is">
<a href="#_throw-if-token-is">下記に該当する場合</a>、例外が投出される。
</span>
◎
Throws a SyntaxError if one of the arguments is the empty string.
◎
Throws an InvalidCharacterError if one of the arguments contains any ASCII whitespace.
</dd>

	<dt>%tokenlist . $remove(tokens…)</dt>
	<dd>
渡された引数のそれぞれを（もし在れば）除去する。
◎
Removes arguments passed, if they are present.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a SyntaxError if one of the arguments is the empty string.
◎
Throws an InvalidCharacterError if one of the arguments contains any ASCII whitespace.
</dd>

	<dt>%tokenlist . $toggle(token [, force])</dt>
	<dd>
<p>
%force に応じて：
</p>

<ul>
	<li>
%force が省略されている場合、
%token の有無を “切り替える”。
すなわち、 %token がすでに在れば除去し，無ければ追加する。
</li>
	<li>
%force ~EQ ~T の場合、 %token を追加する（ $add() と同じ）。
</li>
	<li>
%force ~EQ ~F の場合、 %token を除去する（ $remove() と同じ）。
</li>
</ul>

<p>
その結果、 %token が残っていれば ~T を, 無くなっていれば ~F を返す。
</p>
◎
If force is not given, "toggles" token, removing it if it’s present and adding it if it’s not present. If force is true, adds token (same as add()). If force is false, removes token (same as remove()).
◎
Returns true if token is now present, and false otherwise.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a SyntaxError if token is empty.
◎
Throws an InvalidCharacterError if token contains any spaces.
</dd>

	<dt>%tokenlist . $replace(token, newToken)</dt>
	<dd>
	<dd>
%token を %newToken に置換する。
◎
Replaces token with newToken.
</dd>
	<dd>
<!--cp-throw-if-some-token-is-->
◎
Throws a SyntaxError if one of the arguments is the empty string.
◎
Throws an InvalidCharacterError if one of the arguments contains any ASCII whitespace.
</dd>

	<dt id="_throw-if-token-is">（例外）</dt>
	<dd>
<p>
上の各種~methに所与の文字列~引数のいずれかが，次に該当する場合、対応する例外が投出される：
</p>

		<ul id="cp-throw-if-token-B">
			<li>
空~文字列の場合：
`SyntaxError$E
</li>
			<li>
`~ASCII空白$を含む場合：
`InvalidCharacterError$E
</li>
		</ul>
◎
↑</dd>


	<dt>%tokenlist . $supports(token)</dt>
	<dd>
%token が`被support~token集合$dtlに含まれて［
いれば ~T ／ いなければ ~F
］を返す。
◎
Returns true if token is in the associated attribute’s supported tokens. Returns false otherwise.
</dd>
	<dd>
`属性oの局所~名$dtlに対し，`被support~token集合$dtlが定義されていない場合、
`TypeError$E 例外が投出される。
◎
Throws a TypeError if the associated attribute has no supported tokens defined.
</dd>

	<dt>%tokenlist . $value</dt>
	<dd>
結付けられている`~token集合$を文字列として返す。
◎
Returns the associated set as string.
</dd>
	<dd>
設定して結付けられている属性を変更できる。
◎
Can be set, to change the associated attribute.
</dd>

</dl>


<dl class="idl-def">
	<dt>@length</dt>
	<dd>
取得子は、［
此れの`~token集合$の`~size$list
］を返さ~MUST。
◎
The length attribute' getter must return context object’s token set’s size.
</dd>
</dl>

<p>
$DOMTokenList ~obj %O の`被support ~prop~index$は、
0 以上［
%O の`~token集合$の`~size$list
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to object’s token set’s size minus one, unless token set is empty, in which case there are no supported property indices.
</p>

<dl class="idl-def">
	<dt>@item(index)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The item(index) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%index ~NIN { 此れの`被support ~prop~index$ }
］
⇒
~RET ~NULL
◎
If index is equal to or greater than context object’s token set’s size, then return null.
</li>
			<li>
~RET 此れの`~token集合$[ %index ]
◎
Return context object’s token set[index].
</li>
		</ol>
	</dd>
</dl>


<div>
<p class="algo-head">
所与の %token を
`検査する@dtl
ときは、次を走らす：
</p>

<ol>
	<li>
~IF［
%token ~EQ 空~文字列
］
⇒
~THROW `SyntaxError$E
</li>
	<li>
~IF［
%token は`~ASCII空白$を含んでいる
］
⇒
~THROW `InvalidCharacterError$E
</li>
</ol>

◎
↓↓</div>


<dl class="idl-def">
	<dt>@contains(token)</dt>
	<dd>
被呼出時には、［
%token ~IN 此れの`~token集合$ ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The contains(token) method, when invoked, must return true if context object’s token set[token] exists, and false otherwise.
</dd>

	<dt>@add(tokens…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The add(tokens…) method, when invoked, must run these steps:
</p>
		<ol>
			<li id="cp-throw-if-invalid-char">
%tokens 内の~EACH ( %token ) に対し，与えられた順に
⇒
%token を`検査する$dtl
◎
For each token in tokens:
• If token is the empty string, then throw a SyntaxError.
• If token contains any ASCII whitespace, then throw an InvalidCharacterError.
</li>
			<li>
%tokens 内の~EACH ( %token ) に対し
⇒
此れの`~token集合$に %token を`付加-$setする
◎
For each token in tokens, append token to context object’s token set.
</li>
			<li id="cp-update-TL">
`更新~手続き$を走らす
◎
Run the update steps.
</li>
<!-- 
追加が生じなかった場合にも更新~手続きは実行されることになる。
 -->
		</ol>
	</dd>

	<dt>@remove(tokens…)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The remove(tokens…) method, when invoked, must run these steps:
</p>
		<ol>
			<!--cp-throw-if-invalid-char-->
			<li>
%tokens 内の各 %token に対し
⇒
此れの`~token集合$から %token を`除去-$listする
◎
For each token in tokens, remove token from context object’s token set.
</li>
			<!--cp-update-TL-->
		</ol>
	</dd>

	<dt>@toggle(token, force)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The toggle(token, force) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%token を`検査する$dtl
◎
If token is the empty string, then throw a SyntaxError.
◎
If token contains any ASCII whitespace, then throw an InvalidCharacterError.
</li>
			<li>
<p>
~IF［
%token ~IN 此れの`~token集合$
］：
◎
If context object’s token set[token] exists, then:
</p>
				<ol>
					<li>
<p>
~IF［
%force は与えられてない
］~OR［
%force ~EQ ~F
］：
</p>
<ol ><li>此れの`~token集合$から %token を`除去-$listする
</li><li>`更新~手続き$を走らす
</li><li>~RET ~F
</li></ol>
◎
If force is either not given or is false, then remove token from context object’s token set, run the update steps and return false.
</li>
					<li>
~ELSE
⇒
~RET ~T
◎
Otherwise, return true.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%force は与えられてない
］~OR［
%force ~EQ ~T
］：
</p>

<ol ><li>此れの`~token集合$に %token を`付加-$setする
</li><li>`更新~手続き$を走らす
</li><li>~RET ~T
</li></ol>

◎
Otherwise, if force not given or is true, append token to context object’s token set, run the update steps, and return true.
</li>
			<li>
~RET ~F
◎
Return false.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
~web互換性のため、 $toggle() に対しては，`更新~手続き$を常に走らすとは限らない。
◎
The update steps are not always run for toggle() for web compatibility.
</dd>

	<dt>@replace(token, newToken)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The replace(token, newToken) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%token ~EQ 空~文字列
］~OR［
%newToken ~EQ 空~文字列
］
⇒
~THROW `SyntaxError$E
◎
If either token or newToken is the empty string, then throw a SyntaxError.
</li>
			<li>
~IF［
%token は`~ASCII空白$を含んでいる
］~OR［
%newToken は`~ASCII空白$を含んでいる
］
⇒
~THROW `InvalidCharacterError$E
◎
If either token or newToken contains any ASCII whitespace, then throw an InvalidCharacterError.
</li>
			<li>
~IF［
%token ~NIN %tokens
］
⇒
~RET
◎
If token is not in tokens, then return.
</li>
			<li>
~IF［
%token ~NIN 此れの`~token集合$
］
⇒
~RET
◎
If context object’s token set does not contain token, then return.
</li>
			<li>
此れの`~token集合$内で %token を %newToken に`置換-$setする
◎
Replace token in context object’s token set with newToken.
</li>
			<!--cp-update-TL-->
		</ol>
	</dd>
	<dd class="note">注記：
~web互換性のため、 $replace() に対しては，`更新~手続き$を常に走らすとは限らない。
◎
The update steps are not always run for toggle() for web compatibility.
</dd>
	<dd class="trans-note">【
最初と二番目の段は、
%token, %newToken を順に`検査する$dtlのとは，挙動が異なる（意図的？）。
】</dd>

	<dt>@supports(token)</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The supports(token) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~RET 此れにおいて %token を`検証-$dtlした結果
◎
Let result be the return value of validation steps called with token.
◎
Return result.
</li>
		</ol>
	</dd>

	<dt>@value</dt>
	<dd>
取得子は、此れの`直列化-手続き$を走らせた結果を返さ~MUST。
◎
The value attribute must return the result of running context object’s serialize steps.
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
此れの`要素$dtlの`属性o値を設定する$( 此れの`属性oの局所~名$dtl, 所与の値 )
◎
Setting the value attribute must set an attribute value for the associated element using associated attribute’s local name and the given value.
</dd>

</dl>

		</section>
	</section>
	<section id="historical">
<h2 title="Historical">8. 歴史上の変更点</h2>

<p>
<a href="#goals">目標</a>
にて説明したように，この仕様は種々の~DOM仕様の大きな改訂である。
この節では変更点の列挙を試みる。
◎
As explained in goals this specification is a significant revision of various DOM specifications. This section attempts to enumerate the changes.
</p>

		<section id="dom-events-changes">
<h3>8.1. DOM Events</h3>

<p>
以下は
`DOM Level 3 Events^cite
の［
"DOM Event Architecture",
"Basic Event Interfaces",
"Mutation Events",
"Mutation Name Event Types"
］各~章に述べられた特色機能に加えられた変更点である。
他の章は
`UI Events^cite 仕様 `UIEVENTS$r
に移行されるものと期待されている。
◎
These are the changes made to the features described in the "DOM Event Architecture", "Basic Event Interfaces", "Mutation Events", and "Mutation Name Event Types" chapters of DOM Level 3 Events. The other chapters are defined by the UI Events specification. [UIEVENTS]
</p>

<ul>
	<li>
~eventは今や構築子を持つ。
◎
Events have constructors now.
</li>
	<li>
@MutationEvent,
@MutationNameEvent
は除去された。
◎
Removes MutationEvent, and MutationNameEvent.
</li>
	<li>
発火-（ fire ）は今や配送-（ dispatch ）の同義語ではなく，~eventの初期化も含む。
◎
Fire is no longer synonymous with dispatch, but includes initializing an event.
</li>
	<li>
`伝播停止$f（`伝播即停止$f）と`被取消$fは、配送-後ではなく，
$Event.initEvent()
を呼出した時に~OFF にされる。
◎
The propagation and canceled flags are unset when invoking initEvent() rather than after dispatch.
</li>
	<li>
$Event.timeStamp は、［
1970 年 1 月 1 日 00:00:00 UTC から経過したミリ秒数
］として~eventの作成~時刻を表現する
$DOMTimeStamp 型ではなく， $DOMHighResTimeStamp 型にされた。
◎
timeStamp is no longer a DOMTimeStamp representing creation time of event as the number of milliseconds that passed since 00:00:00 UTC on 1 January 1970, but instead a DOMHighResTimeStamp.
</li>

</ul>


		</section>
		<section id="dom-core-changes">
<h3>8.2. DOM Core</h3>

<p>
以下は
`DOM Level 3 Core^cite
で述べられた特色機能に加えられた変更点である。
◎
These are the changes made to the features described in DOM Level 3 Core.
</p>

<p>
$DOMString,
$DOMException,
$DOMTimeStamp
は、今や Web IDL にて定義される。
◎
DOMString, DOMException, and DOMTimeStamp are now defined in Web IDL.
</p>

<p>
$DOMStringList は、今や~HTMLにて定義される。
◎
DOMStringList is now defined in HTML. 
</p>

<p>
$Node は、今や $EventTarget を継承する。
◎
Node now inherits from EventTarget.
</p>

<p>
`~node$は、`文書$ 間を超えて暗黙的に`受入-$される。
◎
Nodes are implicitly adopted across document boundaries.
</p>

<p>
`~doctype$は、今や常に`~node文書$を持ち，`文書$ 間を超えて移動できる。
◎
Doctypes now always have a node document and can be moved across document boundaries.
</p>

<p>
$ProcessingInstruction は、今や $CharacterData を継承する。
◎
ProcessingInstruction now inherits from CharacterData.
</p>

<p>
<!-- @@Node -->
@hasAttributes(),
@attributes
は、
$Node から $Element へ移動された。
◎
hasAttributes() and attributes moved from Node to Element.
</p>

<p>
@namespaceURI,
@prefix,
@localName
は、
$Node から $Element, $Attr へ移動された。
◎
namespaceURI, prefix, and localName moved from Node to Element and Attr.
</p>

<p>
この節に挙げる，残りの~ifcと~ifc~memberは、~DOM~platformを単純化するために取除かれた。
この仕様に適合する実装が それらを~supportすることはない。
◎
The remainder of interfaces and interface members listed in this section were removed to simplify the DOM platform. Implementations conforming to this specification will not support them.
</p>

<p class="warning">
以下の特色機能がすべて取除かれても Web 互換性が保たれるかどうかは、はっきりしない部分もある。
これらの特色機能の一部について，再~導入されるべき~~根拠を示す~dataがあれば、編集者まで寄せられるよう願う。
◎
It is not yet clear if it would be web-compatible to remove all the following features. The editors welcome any data showing that some of these features should be reintroduced.
</p>

<p>
~ifc：
◎
Interfaces:
</p>

<ul ><li>@DOMConfiguration
</li><li>@DOMError
</li><li>@DOMErrorHandler
</li><li>@DOMImplementationList
</li><li>@DOMImplementationSource
</li><li>@DOMLocator
</li><li>@DOMObject
</li><li>@DOMUserData
</li><li>@Entity
</li><li>@EntityReference
</li><li>@NameList
</li><li>@Notation
</li><li>@TypeInfo
</li><li>@UserDataHandler
</li></ul>

<p>
~ifc~member：
◎
Interface members:
</p>

<dl>
	<dt>$@Node</dt>
	<dd>
<ul><li>@isSupported
</li><li>@getFeature()
</li><li>@getUserData()
</li><li>@setUserData()
</li></ul>

	</dd>
	<dt>$@Document</dt>
	<dd>
<ul><li>@createCDATASection()
</li><li>@createEntityReference()
</li><li>@xmlEncoding
</li><li>@xmlStandalone
</li><li>@xmlVersion
</li><li>@strictErrorChecking
</li><li>@domConfig
</li><li>@normalizeDocument()
</li><li>@renameNode()
</li></ul>

	</dd>
	<dt>$@DOMImplementation</dt>
	<dd>
		<ul>
<li>@getFeature()</li>
		</ul>

	</dd>
	<dt>$@Attr</dt>
	<dd>
<ul><li>@schemaTypeInfo
</li><li>@isId
</li></ul>
	</dd>

	<dt>$@Element</dt>
	<dd>
<ul><li>@schemaTypeInfo
</li><li>@setIdAttribute()
</li><li>@setIdAttributeNS()
</li><li>@setIdAttributeNode()
</li></ul>
	</dd>
	<dt>$@DocumentType</dt>
	<dd>
<ul><li>@entities
</li><li>@notations
</li><li>@internalSubset
</li></ul>

	</dd>
	<dt>$@Text</dt>
	<dd>
<ul><li>@isElementContentWhitespace
</li><li>@replaceWholeText()
</li></ul>
	</dd>
</dl>

		</section>
		<section id="dom-range-changes">
<h3>8.3. DOM Ranges （範囲o）</h3>

<p>
以下は
`DOM Level 2 Traversal and Range^cite.
の "Document Object Model Range"
章にて述べられている特色機能に加えられた変更点である。
◎
These are the changes made to the features described in the "Document Object Model Range" chapter of DOM Level 2 Traversal and Range.
</p>

<ul>
	<li>
@RangeException
は取除かれた。
◎
RangeException has been removed.
</li>
	<li>
$@Range ~objは今や`文書$ 間で移動でき，
`文書~木~内$にない`~node$にも利用できる。
◎
Range objects can now be moved between documents and used on nodes that are not in a document tree.
</li>
	<li>
~~素の $Range() 構築子が出現。
◎
A wild Range() constructor appeared.
</li>
	<li>
新たな~meth
$comparePoint(),
$intersectsNode(),
$isPointInRange()
が追加された。
◎
New methods comparePoint(), intersectsNode(), and isPointInRange() have been added.
</li>
	<li>
$detach は今や何もしない。
◎
detach() is now a no-op.
</li>
	<li>
<a href="#dom-range-stringifier">^toString</a>
は、今や~IDLを通して定義される。
◎
toString is now defined through IDL.
</li>
</ul>

		</section>
		<section id="dom-traversal-changes">
<h3>8.4. DOM Traversal （走査）</h3>

<p>
以下は
`DOM Level 2 Traversal and Range^cite
の "Document Object Model Traversal" 章にて述べられている
特色機能に加えられた変更点である。
◎
These are the changes made to the features described in the "Document Object Model Traversal" chapter of DOM Level 2 Traversal and Range.
</p>

<ul>
	<li>
$@Document の
$createNodeIterator(),
$createTreeWalker()
は、今や省略可の引数をとり，最早~DOMには決して取り込まれない実体参照を与える 4 個目の引数は除かれた。
◎
createNodeIterator() and createTreeWalker() now have optional arguments and lack a fourth argument which is no longer relevant given entity references never made it into the DOM.
</li>
	<li>
前述の理由により，
@NodeIterator.expandEntityReferences
属性は $NodeIterator および $TreeWalker ~ifcから除去された。
◎
The expandEntityReferences attribute has been removed from the NodeIterator and TreeWalker interfaces for the aforementioned reason.
</li>
	<li>
~proprietary拡張による実装に足並みを揃えるため、
$@NodeIterator ~objに
$referenceNode, $pointerBeforeReferenceNode
属性が追加された。
◎
The referenceNode and pointerBeforeReferenceNode attributes have been added to NodeIterator objects to align with proprietary extensions of implementations.
</li>
<li>
~UA に足並みを揃えるため、
$nextNode() と $previousNode() は今や
$NodeFilter から呼出されたときに例外を投出し得る。
◎
nextNode() and previousNode() now throw when invoked from a NodeFilter to align with user agents.
</li>
	<li>
$detach は今や何もしない。
◎
detach() is now a no-op.
</li>
</ul>

		</section>
	</section>
</main></div>
<!-- id="MAIN" -->

	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り、 DOM を相互運用可能にするために，たくさんの方々が助力され、この標準の目標へ近付けてきた。
同様に多くの方々の助力が，この標準を現在の姿に仕立て上げてきた。
<span lang="en">
There have been a lot of people that have helped make DOM more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</span></p>

<div lang="en-x-a0">

<p>
With that, many thanks to

Adam Klein,
Adrian Bateman,
Aleksey Shvayka,
Alex Komoroske,
Alex Russell,
Anthony Ramine,
Arkadiusz Michalski,
Arnaud Le Hors,
Arun Ranganathan,
Björn Höhrmann,
Boris Zbarsky,
Brandon Payton,
Brandon Slade,
Brandon Wallace,
Brian Kardell,
Cameron McCormack,
Chris Dumez,
Chris Paris,
Chris Rebert,
Cyrille Tuzi,
Daniel Glazman,
Darin Fisher,
David Bruant,
David Flanagan,
David Håsäther,
David Hyatt,
Deepak Sherveghar,
Dethe Elza,
Dimitri Glazkov,
Domenic Denicola,
Dominic Cooney,
Dominique Hazaël-Massieux,
Don Jordan,
Doug Schepers,
Edgar Chen,
Elisée Maurer
Elliott Sprehn,
Eric Bidelman,
Erik Arvidsson,
Gavin Nicol,
Geoffrey Sneddon,
Giorgio Liscio,
Glen Huang,
Glenn Adams,
Glenn Maynard,
Hajime Morrita,
Harald Alvestrand,
Hayato Ito,
Henri Sivonen,
Hunan Rostomyan,
Ian Hickson,
Igor Bukanov,
Jacob Rossi,
Jake Archibald,
Jake Verbaten,
James Graham,
James Greene,
James Robinson,
Jeffrey Yasskin,
Jens Lindström,
Jesse McCarthy,
João Eiras,
Joe Kesselman,
John Atkins,
John Dai,
Jonas Sicking,
Jonathan Robie,
Joris van der Wel,
Joshua Bell,
Jungkee Song,
Justin Summerlin,
呂康豪 (Kang-Hao Lu),
Kevin Sweeney,
Koji Ishii,
Kirill Topolyan,
Lachlan Hunt,
Lauren Wood,
Majid Valipour,
Malte Ubl,
Manish Goregaokar,
Manish Tripathi,
Marcos Caceres,
Mark Miller,
Mats Palmgren,
Mounir Lamouri,
Michael™ Smith,
Mike Champion,
Mike Taylor,
Mike West,
Ojan Vafai,
Oliver Nightingale,
Olli Pettay,
Ondřej Žára,
Peter Sharpe,
Philip Jägenstedt,
Philippe Le Hégaret,
Ra’Shaun Stovall (Snuggs),
Rafael Weinstein,
Richard Bradshaw,
Rick Byers,
Rick Waldron,
Robbert Broersma,
Robin Berjon,
Roland Steiner,
Rune <span title="Fabulous">F.</span> Halvorsen,
Russell Bicknell,
Ruud Steltenpool,
Ryosuke Niwa,
Sam Dutton,
Samuel Giles,
Sebastian Mayr,
Seo Sanghyeon,
Sergey G. Grekhov,
Shiki Okasaka,
Shinya Kawanaka,
Simon Pieters,
Stef Busking,
Steve Byrne,
Stig Halvorsen,
Tab Atkins,
Takashi Sakamoto,
Takayoshi Kochi,
Theresa O’Connor,
<i>timeless</i>,
Timo Tijhof,
Tobie Langel,
Tom Pixley,
Travis Leithead,
<i>triple-underscore</i>,
Veli Şenol,
Vidur Apparao,
Warren He,
Xidorn Quan,
Yehuda Katz,
Yoav Weiss,
Yoichi Osato,
Yoshinori Sano, and
Zack Weinberg

for being awesome!
</p>

<p>
This standard is written by
<a href="//annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="//www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>) with substantial contributions from
Aryeh Gregor (<a href="//www.mozilla.org/">Mozilla</a>,
<a href="mailto:ayg@aryeh.name">ayg@aryeh.name</a>)
and Ms2ger (<a href="//www.mozilla.org/">Mozilla</a>,
<a href="mailto:ms2ger@gmail.com">ms2ger@gmail.com</a>).
</p>

<p>
Part of the revision history of the integration points related to <a href="#concept-element-custom">custom</a> elements can be
found in <a href="https://github.com/w3c/webcomponents">the w3c/webcomponents repository</a>, which
is available under the <a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">W3C Permissive Document License</a>.
</p>

<p>
Per <a href="//creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>,
to
the extent possible under law, the editors have waived all copyright and related or neighboring rights to this work.
</p>

</div>


	</section>
	<section id="index">
<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>
	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>

<script type="text/plain" class="ref_data">
[DEVICE-ORIENTATION]
    Rich Tibbett; et al. DeviceOrientation Event Specification. URL: https://w3c.github.io/deviceorientation/spec-source-orientation.html 
[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[HR-TIME]
    Jatinder Mann. High Resolution Time. 17 December 2012. REC. URL: https://www.w3.org/TR/hr-time/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[SELECTORS4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 2 May 2013. WD. URL: https://www.w3.org/TR/selectors4/ 
[SERVICE-WORKERS]
    Alex Russell; et al. Service Workers 1. URL: https://w3c.github.io/ServiceWorker/ 
[TOUCH-EVENTS]
    Doug Schepers; et al. Touch Events. URL: http://dvcs.w3.org/hg/webevents/raw-file/v1/touchevents.html 
[UIEVENTS]
    Gary Kacmarcik; Travis Leithead. UI Events. URL: https://github.com/w3c/uievents/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml 
[XML-NAMES]
    Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names 
</script>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<script type="text/plain" class="ref_data">
[CSSOM-VIEW]
    Simon Pieters. CSSOM View Module. URL: https://drafts.csswg.org/cssom-view/ 
[DOM-Level-2-Traversal-Range]
    Joseph Kesselman; et al. Document Object Model (DOM) Level 2 Traversal and Range Specification. 13 November 2000. REC. URL: https://www.w3.org/TR/DOM-Level-2-Traversal-Range/ 
[DOM-Level-3-Core]
    Arnaud Le Hors; et al. Document Object Model (DOM) Level 3 Core Specification. 7 April 2004. REC. URL: https://www.w3.org/TR/DOM-Level-3-Core/ 
[DOM-Parsing]
    Travis Leithead. DOM Parsing and Serialization. URL: https://w3c.github.io/DOM-Parsing/ 
[ELEMENTTRAVERSAL]
    Doug Schepers; Robin Berjon. Element Traversal Specification. 22 December 2008. REC. URL: https://www.w3.org/TR/ElementTraversal/ 
[INDEXEDDB]
    Nikunj Mehta; et al. Indexed Database API. URL: http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html 
[PROMISES-GUIDE]
    Domenic Denicola. Writing Promise-Using Specifications. 16 February 2016. Finding of the W3C TAG. URL: https://www.w3.org/2001/tag/doc/promises-guide 
[SELECTORS-API2]
    Lachlan Hunt. Selectors API Level 2. URL: http://dev.w3.org/2006/webapi/selectors-api2/ 
[UIEVENTS-20031107]
    Philippe Le Hégaret; Tim Pixley. Document Object Model (DOM) Level 3 Events Specification. URL: https://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107 
</script>


		</section>
	</section>
	<section id="idl-index">
<h2 title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>


<!--% 他の語

	●仕様
出発点:starting point
広い:broader
参照文献:
謝辞:
~~原因:cause
~~目的:
様子:
略語:
言葉を代えれば:Phrased differently,
進路:future course
小論:essays
報告書:reports
本格的:fully-fledged
手品:magic
~~仕組:magic
出来上がる:comes out
十分:
不要:
類似:
的外れ:nonsensical
~~選択:-
名称:names
否決:vetoed
探求-:explore:~
編集:editing:~
事実:fact
~~言明:claim
ほど遠い:not nearly as reliable or granular
働き続けられる:don’t stop working
~~判明:proved
~~根拠を示す:showing
編集者:editors
~~制御:key off
便宜のため:For convenience 
簡便:convenience
区別:avoid confusion
非負:non-negative
足並みを揃える:align with
移行:moving
用語:term:~
用途
依然として:still:
存続
発生:occurrence
次に起きる出来事:what happens next
方式:style
~~無視:not pay attention
序論:introduction to
理由:mishap／because 
注意:Note that／notice that
賢く:wisely
記述
必要:need／has to／
注記:Note
意味-:mean
意味:meaning
揃わせ:Aligning
代わるもの:replacement
特に:in particular
節:section:~
~~特に:specificalに
~~強調:called out
働きかける:influence
誤った考え:wrong ideas
人:folks
~~起動するもの initiators
particular
不要にするreplaces the need
~~廃する:rid of
	あいにく:Unfortunately,
hairy
	何もしない:no-op
	消去~clear
論を交わしたければ:discussion
~F に:clear
割り当てられる:allocate
ごく限られた~~状況:very specific circumstances.
組:tuple
直面:in the face of
呼応して:in response to
尊守され:enshrined
弄り倒す:messes with 〜 extensively
により、:because of
今の所:for now,
知らせて:Let us know
満たす:meet／
気にする:worry about
あるとする:hypothetical
可能:possible／
可能な限り:as much as possible
例:example
~~意図され:meant
選べ:chose
~~伝える:convey
用法:using
に応じて:according to
べき:should
具体例として:for instance
利用-:use

	●訳注
増減操作
加減算
次節
部分集合
可視化
上下関係
階層
入子~階層
位置変化
無限増殖
ループ
反復対象
~~未定義
誤記
機能上
同等
括弧内
見立てて
~~例外
ドット
先掲
位置関係
算出
~~定義
区間
根元
対訳
広義
対称
整理統合
慣用表現
付記
簡単に
忠実
意義
不明
~~状態
ブロック
整合性
説明用
見通し
変形
否定
図左
カット
相当
機能的
削除-:delete:~
簡略化
不変
段階
全部的
概念的
開始地点
通過-
横線
太字
前順
優先
構成-
関係
固有
表記規約
表記
非公式
括弧内: 2
未策定: 2
総称: 2
何故:
仮想: 2
訳者: 2
実行後
相対位置
適宜
簡潔
最上層
参考
実行例: 3
濾過: 3
探索
見出し
~~厳密
~~無視
補足
補完
模式図
縦棒
横線: 6
記号: 7
赤色区間: 2
緑色区間: 5
青色区間: 7
原文

	●未分類
時点以降:
~~起動:
混在:
列挙:enumerate
~~素の:wild
出現:appeared
連続する:adjacent／a sequence of
全順序:linear
条件
一致
／除外-:exclude
存続-:continues to exist
基準点:this point
相対点:other point
存在-:exist:~
処理過程:
処理
内容
位置
表され:express
並び:sequence of
切り替える:toggle
された:got
-:lead
-:controller
すごいこと:amazing
すごい結果:amazingResult

	●指示語
初回:first time
ある種の:certain
唯一つ:
唯一の:the sole
すべて:all
ときには、:ocassionally
初めて:very first
永遠に forever
範囲:
この:this
これらの:these
すでに:already
その:that
それらの:their
それらを:them
もの:thing
上／上述:above
多くの:many
一環:part of
すべて:all
他所:elsewhere
他の:other
他の場合:otherwise
両方／両者／両:both
複数:
複数個:more than one
隙間:
開始-:start
終了:end
逆順:reverse
現時点:
番目:
挿入点:
差分:
隣接:
個以上:
以前:
個目:
図右:
上図:
下図:
下記:
開始:
末尾側:
末尾:
片方:
左端:
末端:
両端:
右端:
各種:
一連:
時点:
内縁:
外縁:
対象:
地点:
該当:
後続:
項目:
列目:
左側:
直上:
直下:
直前:
直後:
部分:
一部:
対応している:corresponding
対応:correspond
同様:
以外:
以下:
下位:
自身:
先頭:
個数:
最後:
最初:
場合:
結果:result／-41
任意:
有限個:
有限:
箇所:
今度:
各
各項:
度目:
現在:
余分:
合間:
最高:
後述:
一種:
二番目:
最早:
一対一:
一個一個:
一列:
一個:
本数:
各数字:
最下位:
逆向:
最早:
前述:
一例:
全体:
一方:
	前回:
自体:
次のように:as follows
次の:following
結果:result
通して:through
-->
