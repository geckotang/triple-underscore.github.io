<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8" />
<title>Intersection Observer 1（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

//COMMON_DATA.page_state_key = '***';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'ED',
		original_url: 'https://wicg.github.io/IntersectionObserver/',
		fill_text_link: '#_versions > dd, #references dd',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160707 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		jA: 'abstract',
		sl: 'js-slot',
		E: 'error',
		p: 'css',
		v: 'value',
		t: 'type',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code', // IDL interface
		E: 'code', // error
		m: 'code', // IDL member
		mb: 'code', // IDL dict member
		c: 'code',
		p: 'code',
		v: 'code',
		et: 'code', // event type
		sl: 'span', // JS internal slot
		t: 'var',
		V: 'var',
		i: 'i', // model constants
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 't': // typedef
	text = '&lt;' + key + '&gt;';
	break;
case 'm':
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl':
	text = '[[' + text + ']]';
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
</script>


<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">
	＊Constructor:#dom-intersectionobserver-intersectionobserver
Exposed:~WEBIDL#Exposed
I.DOMHighResTimeStamp:http://www.w3.org/TR/hr-time/#domhighrestimestamp
I.DOMRect:https://drafts.fxtf.org/geometry-1/#domrect
I.DOMRectInit:https://drafts.fxtf.org/geometry-1/#dictdef-domrectinit
I.DOMRectReadOnly:https://drafts.fxtf.org/geometry-1/#domrectreadonly
I.DOMString:~WEBIDL#idl-DOMString

I.Document:~HTMLdom#the-document-object
文書:#_document
	~HTMLdom#the-document-object
I.Element:~DOM4#element
要素:#_element

I.IntersectionObserver:#intersectionobserver
I.IntersectionObserverCallback:#callbackdef-intersectionobservercallback
I.IntersectionObserverEntry:#intersectionobserverentry
I.IntersectionObserverEntryInit:#dictdef-intersectionobserverentryinit
I.IntersectionObserverInit:#dictdef-intersectionobserverinit
I.MutationObserver:~DOM4#mutationobserver
I.MutationObserverInit:~DOM4#dictdef-mutationobserverinit
I.Node:~DOM4#node
E.RangeError:~WEBIDL#dfn-simple-exception
E.SyntaxError:~WEBIDL#syntaxerror
	~WEBIDL#dfn-simple-exception

交差~observer登録:#intersectionobserverregistration
m.IntersectionObserverEntry:#dom-intersectionobserverentry-intersectionobserverentry
m.IntersectionObserver:#dom-intersectionobserver-intersectionobserver
m.boundingClientRect:#dom-intersectionobserverentry-boundingclientrect
m.disconnect:#dom-intersectionobserver-disconnect
m.getBoundingClientRect:~CSSOMVIEW#dom-element-getboundingclientrect
m.intersectionRatio:#dom-intersectionobserverentry-intersectionratio
m.intersectionRect:#dom-intersectionobserverentry-intersectionrect
m.observe:#dom-intersectionobserver-observe
m.~observe0:~DOM4#dom-mutationobserver-observe
m.root:#dom-intersectionobserver-root
m.rootBounds:#dom-intersectionobserverentry-rootbounds
m.rootMargin:#dom-intersectionobserver-rootmargin
m.takeRecords:#dom-intersectionobserver-takerecords
m.target:#dom-intersectionobserverentry-target
m.thresholds:#dom-intersectionobserver-thresholds
m.time:#dom-intersectionobserverentry-time
m.unobserve:#dom-intersectionobserver-unobserve

mb.time:#dom-intersectionobserverentryinit-time
mb.rootBounds:#dom-intersectionobserverentryinit-rootbounds
mb.boundingClientRect:#dom-intersectionobserverentryinit-boundingclientrect
mb.intersectionRatio:#dom-intersectionobserverentryinit-intersectionratio
mb.target:#dom-intersectionobserverentryinit-target
mb.intersectionRect:#dom-intersectionobserverentryinit-intersectionrect

mb.root:#dom-intersectionobserverinit-root
mb.rootMargin:#dom-intersectionobserverinit-rootmargin
mb.threshold:#dom-intersectionobserverinit-threshold

sl.ObservationTargets:#dom-intersectionobserver-observationtargets-slot
sl.QueuedEntries:#dom-intersectionobserver-queuedentries-slot
sl.RegisteredIntersectionObservers:#dom-element-registeredintersectionobservers-slot
sl.callback:#dom-intersectionobserver-callback-slot
sl.rootMargin:#dom-intersectionobserver-rootmargin-slot

rp.observer:#dom-intersectionobserverregistration-observer
rp.previousThresholdIndex:#dom-intersectionobserverregistration-previousthresholdindex

	%entries:#dom-intersectionobservercallback-entries
	%observer:#dom-intersectionobservercallback-observer
	%callback:#dom-intersectionobserver-intersectionobserver-callback-options-callback
	%options:#dom-intersectionobserver-intersectionobserver-callback-options-options
	%%target:#dom-intersectionobserver-observe-target-target
	%target:#dom-intersectionobserver-unobserve-target-target
	%intersectionObserverEntryInit:#dom-intersectionobserverentry-intersectionobserverentry-intersectionobserverentryinit-intersectionobserverentryinit

交差~observer:#intersection-observer
交差~observer~task処理待ち~flag:#document-intersectionobservertaskqueued
	IntersectionObserverTaskQueued
交差~observer~taskを待入する:#queue-an-intersection-observer-task
交差~observationsの更新~手続きを走らす:#run-the-update-intersection-observations-steps
交差域を算出-:#compute-the-intersection
暗黙的な~root:#intersectionobserver-implicit-root
交差~root:#intersectionobserver-intersection-root
	＊intersection~root’s:#intersectionobserver-intersection-root
交差~observerたちに通知する:#notify-intersection-observers
~root~marginを構文解析-:#parse-a-root-margin
処理~model節:#intersection-observer-processing-model
~IntersectionObserverEntryを待入する:#queue-an-intersectionobserverentry
~root交差~矩形:#intersectionobserver-root-intersection-rectangle
~target:#intersectionobserver-target

	double:~WEBIDL#idl-double

	HTML Processing Model:https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model
		#processing-model-8
成分~値の~listを構文解析-:~CSSSYN#parse-a-list-of-component-values

~pinch-zoom:~CSSOMVIEW#pinch-zoom
p.margin:~CSS2BOX#propdef-margin
	https://drafts.csswg.org/css21/box.html#propdef-margin
p.clip-path:http://www.w3.org/TR/css-masking-1/#propdef-clip-path
t.percentage:~CSSVAL#percentage-value
絶対~長さ:~CSSVAL#absolute-length
t.dimension:~CSSVAL#typedef-dimension
	寸法:~CSSVAL#dimension
包含塊~連鎖:~CSSDISP#containing-block-chain

包含塊:~CSSDISP#containing-block
	包含塊:~CSS2VISUDET#containing-block-details
	包含塊:https://drafts.csswg.org/css-box/#containing-block
内容~区画:~CSS2BOX#content-area
	内容~区画:https://drafts.csswg.org/css-box/#content-area
表示域:~CSS2BOX#viewport
	表示域:https://drafts.csswg.org/css-box/#viewport

閲覧文脈~容器:~BROWSERS#browsing-context-container
閲覧文脈:~BROWSERS#browsing-context
全部的に作動中:~BROWSERS#fully-active
入子の閲覧文脈:~BROWSERS#nested-browsing-contexts
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
互いに関係するかつ生成元も類似する閲覧文脈~群:~BROWSERS#unit-of-related-similar-origin-browsing-contexts


待入する:~WAPI#queue-a-task
~event-loop:~WAPI#event-loop
例外を報告-:~WAPI#report-the-exception
~event-loop処理~model:~WAPI#event-loop-processing-model
~task源:~WAPI#task-source

~animation~frame~callbackを走らす:~HTMLGAPI#run-the-animation-frame-callbacks
~fullscreen描画~手続き:~WAPI#run-the-fullscreen-rendering-steps

~callback this 値:~WEBIDL#dfn-callback-this-value
	~callback this 値:~HTML5/infrastructure.html#dfn-callback-this-value
	投出:~WEBIDL#dfn-throw

起点時刻:~HRTIME#time-origin
	http://www.w3.org/TR/hr-time/#time-origin


	●補完
空白~token:~CSSSYN#typedef-whitespace-token
生成した~observer:#_notified-observer
~CSS成分~値として直列化-:~CSSOM#serialize-a-css-component-value
</script>

<!--% 語彙 -->
<script type="text/plain" id="words_table1">
此れ:<b>これ°</b>
observe0:observe
IntersectionObserverEntry:<code>IntersectionObserverEntry</code> 
</script>

<script type="text/plain" id="words_table">
DOM:
CSS:
HTML:
塊:block:::ブロック
block::::
call::::
callback::::
	clear::::
cost::::コスト
custom::::カスタム
data::::データ
dictionary::::ディクショナリ
entry::::エントリ
event-loop:event loop:::イベントループ
event::::イベント
loop:~:::ループ
filter::::フィルタ
絞込む:filter する::絞り込む
flag::::フラグ
frame::::フレーム
handler::::ハンドラ
index::::
instance::::インスタンス
interface::::インタフェース
list::::リスト
margin::::マージン
method::::メソッド
network::::ネットワーク
node::::ノード
obj:object:::オブジェクト
overhead::::オーバーヘッド
plugin::::プラグイン
prop:property:::プロパティ
	query::::
record::::レコード
schedule::::スケジュール
scripting::::
scroll::::スクロール
scrolling::::スクロール処理
site::::サイト
slot::::スロット
sort::::ソート
space::::スペース
	space区切りの:space-separated

task::::タスク
thread::::スレッド
	time::::
token::::トークン
top-level::::トップレベル
web::::
zero::::ゼロ
	:non-zero
pinch-zoom:pinch zoom:::ピンチズーム
fullscreen::::全スクリーン
横切った:cross した:~
監視-:watch:~
box::::ボックス
	-:size::::サイズ
overflow::::過フロー
offset::::オフセット
量:amount:~


	●仕様
API:
UA:user agent:UA
algo:algorithm:::アルゴリズム
app:application:::アプリ
browser::::ブラウザ
model::::モデル
option::::オプション
platform::::プラットフォーム
version::::バージョン
	V2:version
architecture::::アーキテクチャ
support::::サポート
	要因:source
仕様:spec:~
仕組み:mechanism:~
伝統的:traditional:~
依拠-:rely:~
保証:guarantee:~
共通する:common な:~
共通的な:common な:よくある
利用-:use:~
利用事例:use-case:~
労:effort:~
効率的:efficient:~
取組む:address する:取り組む
受動的:passive:~
定義:definition:~
定義-:define:~
実質的:effective:~
実施:practice:~
実装-:implement:~
実装:implementation:~
実質的:effective:~
実際:actual:~
将来:future:~
局面:scenario:~
影響-:affect:~
	影響されない:unaffected
性質:properties:~
情報:information:~
所与の:given:与えられた
手続き:steps:~
抑制-:reduce:~
挙動:behavior:ふるまい
方式:manner:~
既存の:existing:~
既知:known:~
明示的:explicit:~
	最初の:first:~
有意:significant:~
有用:useful:~
条件:condition:~
濫用-:abuse:~
特定の:specific:~
特色機能:feature:~
発展-:evolve:~
築く:build する:~
組合わせ:combination:組み合わせ
結付けら:associate さ:~
統合:integration:~
継続的:continuous:~
	し続ける:continue:~
自動的:automatic:~
表現-:represent:~
要旨:outline:~
要求-:require:~
記述-:describe:~
課題:issue:~
適用-:apply:~
開発者:developer:~
頻繁:frequent:~
高価:expensive:~
高性能な:high-performance:~
事例:case:~
仕事:work:~
処理:processing:~
処理能:performance:~
中心的:central:~
対話成句:interaction idiom::対話上の成句
携帯機器:mobile:~
	central mobile interaction idiom
収益集計:monetizing impressions:~
解決策:solution:~
束縛-:bind:~
	data-bound
主旨:intent:~
目標:goal:~
	目標とはされていないが注目すべき点として:notable non-goal
代償:penalty:~
余計な:extraordinary:~
類似する:similar な:~
類似的:similar:~
重い:critical な:~
規範的:normative:~
複雑:complex:~
序論:introduction:~
制御-:control:~
先送り:defer:~
検出-:detect:~

	不必要に:unnecessary:~
	厳しい刻限を課す:impose hard-latency requirements
	自身:itself
	より複雑になる:introduce more complexity
	生じた-:introduce
	つまり:that is to say
	複数の:multiple:~
	異なる:different:~
	節:section:~
	今や:now:~
	他の:other:~
	個々の:individual:~
	自体:body
	別の:another:~
	各:each:~
	同じ:same:~
	含-:include:~
	含めて:including:~
	-:due:~
	多くの:many:~
	対応-:correspond:~
	少しの:slight:~
	後:after:~
	得-:obtain:~
	必要:need:~
	〜に基づく:based:~
	ある種の:certain:~
	いくつかの:several:~
	この:this:~
	これらの:these:~
	しかしながら，:however:~
	すべての:all:~
	その:that:~
	それら:they:~
	べき:should:~
	一致:identical:~
	も含め:but not limited to
	にもかかわらず:despite
	乏しい:poorly
	極めて:quite
	難しい:difficult
	特に:in particular
	不要になる:eliminates the need 〜 removing the need for
	普及している:widespread use
	できるように:enableする
	と呼ばれる:referred to
	その逆:vice versa
	以上:greater than or equal
	未満:less than:~
	頼る:resorting
	生き残り続ける remain alive
	真の:true
	結果になって:has led to
	~~元の:~undilated
	則って:according to
	ことにある:consistent
	得-:understand
	行われる:take-place
	一部分:subset:~
	与-:give:~
	-:adjust
	NOT
	led
	causing
	見える:seem
	必要なもの:remaining ones
	拡がらず:without solving additional

	● CSS ／呈示／ UI
style::::スタイル
layout::::レイアウト
部位:portion:~
容器:container:::コンテナ
包含塊:containing block::包含 block:包含ブロック
連鎖:chain::~

包含-:contain:~
拡大鏡:magnifying glass:~
拡幅-:expand:~
描画-:render::~::レンダー
描画:rendering::~::レンダリング
	詰まる:jank

	●交差幾何
pixel::::ピクセル
	~pixel単位の:pixel-accurate
clip:
cliping:
	~clipされていない:unclipped
	切取られ:clip され::切り取られ
	切抜かれ:clip され::切り抜かれ
	切抜いた:clip した::切り抜いた
	切抜き:cliping::切り抜き
矩形:rectangle::~
	矩形:rect
辺:edge:~
	辺が接する:edge-adjacent

上端:top:~
下端:bottom:~
右端:right:~
左端:left:~

比率:ratio::~
可視:visible::~
可視率:visibility::~
座標空間:coordinate space:~
座標系:coordinate system:~
絶対:absolute:~
長さ:length:~
横幅:width:~
縦幅:height:~
	縦組み

百分率:percentage:~
算出-:compute:~
再計算:recalculation:~
表示-:display:~
表示域:viewport:~
写像-:map:~
位置:position:~

交差-:intersect::~
交差:intersection::~
交差域:intersection::~
区画:area::~
面積:area::~
	拡げる／狭める:growing or shrinking
	交差しているかどうか:against

	●観測
target:
threshold:
	しきい
root:
observe:
observer:
observations:
	観測-:observe::~::オブザーブ
	観測:observations::~::オブザベーション
	観測器:observer::~::オブザーバ
境界box:bounding box::境界 box:境界ボックス
境界:bounds::~
登録:registration::~
追跡-:track::~
非同期的:asynchronous:~
同期的:synchronous:~
誘発-:trigger:~
送達-:deliver:~
送達:delivery:~
通知-:notify::~
通知:notification::~
事前読込み:pre-loading::~
遅延読込み:deferred-loading::~
	lazy-loading
読込んで:load して::~
待行列:queue::待ち行列::キュー
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ
待入し:queue し::待ち行列に入れ::キューし
停止する:stop する:やめる
時刻:time:~
遅延:delay::~
	~~相対的な:with respect to
	基準に／〜の中での:relative:~

	●未分類（動詞
照会-:query::~::クエリ
空に:clear:~
記録-:record:~
付加-:append:~
作成-:create:~
保持-:hold:~
	満たされ:hold
初期化-:initialize:~
初期:initial:~
削除-:delete:~
動作-:act:~
反復:iteration:~
呼出され:invoke され:呼び出され
呼出して:invoke して:呼び出して
呼出す:invoke する:呼び出す
被呼出時:被 invoke 時:~
報告-:report:~
変化-:change:~
変化:changes:~
変更-:change:~
投出:throw:~
指示-:indicate:~
	供-:provide:~
更新:update:~
検査-:check:~
構築-:construct:~
生成-:generate:~
	-:produce:~
直列化-:serialize::~::シリアライズ
構文解析-:parse::~::パース
構築子:constructor::~::コンストラクタ
置換-:replace:~
複製:copy:~
複製-:duplicate:~
追加-:add:~
走らす:run する:走らせる
走らせ:run し:~
走り:run し:~
	返す:return:~
	-:choose:~
除去-:remove:~
再読取り:readback:再読み取り
変異:mutation::~

	●未分類
源:source::~::ソース
	CPU
	GPU
	WebGL:webgl
	IntersectionObserver
	Intersection Observer
animation::::アニメーション
loop::::ループ
暗黙的な:implicit:~
生成元:origin::~::オリジン

起点時刻:time origin:~
関係-:relate:~
閲覧文脈:browsing context::~
作動中:active::~::アクティブ
全部的:full:~
取得子:getter:~
型:type:~
既定:default:~:::デフォルト
子孫:descendant:~
先祖:ancestor:~
要素:element:~
木:tree::~::ツリー
polling::::ポーリング
energy::::エネルギー
script::::スクリプト

	昇順:ascending-order
	昇順:increasing numeric order
解決-:resolve:~
計算-:calculate:~
計算:calculation:~

不完全な:perfect でない:~
合成結果:compositing-result:~
入子の:nested:入れ子の
	入子に:nest:入れ子に

例外:exception:~
値:value:~
	入力:input:~

内側:inside:~
内容:content:~
内部:internal:~
内部的:internal:~
	別々の:separate:~
単独の:single:~
外方:outward:~
外部:external:~
大域:global::~::グローバル
大域的:global::~::グローバル
存続期間:lifetime:~
失敗:failure:~
有効:valid:~
属性:attribute:~
引数:argument:~
成分:component:~
	数:number:~
文字列:string:~
文書:document:~
参照:references:~
新たな:new:~
広告:ad:~
時刻印:timestamp:~
	正の:positive:~
段:step:~
状態:state:~
空:empty:~
空白:whitespace:~
等価:equivalent:~
範囲:range:~
集合:set:~
順序:order:~

	等し:equal:~
	渡-:pass:~
	生-:occur:~
	属する:belong
	-:unadjust
	rAF:requestAnimationFrame()
	数~値:numeric value
	inclusive
	~~外部~exotic
	ごとに:Per-
	-:consistent
	-:NOT
	残り:remaining ones
	-:inclusive
	remain
	間:during

	rootBound
	boundingClientRect
	intersectionRect
	intersectionObserver:#1
	marginString

</script>

<!--%style -->
<style>
.js-slot {
	color: green;
}

#_ex-margin td:nth-child(n+2),
#_ex-margin th:nth-child(n+2) {
	text-align: right;
}
</style>

</head>
<body >


<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>



<aside class="trans-meta">
<h1>Intersection Observer 1 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて
<strong>編集者草案</strong>として公開された
<a id="_SPEC_URL">Intersection Observer</a>
を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-12-21</time>
（公開：<time>2016-12-13</time> ）
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<div><a href="http://www.w3.org/" id="_W3C">W3C</a></div>

	<hgroup>
<h1>Intersection Observer 1</h1>
<h2 id="subtitle">2016 年 11 月 29 日付 編集者草案</h2>
	</hgroup>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dd>https://wicg.github.io/IntersectionObserver/</dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="https://github.com/WICG/IntersectionObserver/issues/">GitHub</a></dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="mailto:mpb@google.com">Michael Blain</a> (Google)</dd>
</dl>

<small class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</small>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、任意の~DOM要素 （ “~targetたち” ）の［
可視率, 位置
］
— 各~target［
を包含している要素／の~top-level表示域
］（ “~root” ）の中での それら —
を得るために利用できる~APIを記述する。
この位置は，非同期的に送達され、要素の可視率を得て，~DOM内容の事前読込み, 遅延読込みを実装するときに有用になる。
◎
This specification describes an API that can be used to understand the visibility and position of DOM elements ("targets") relative to a containing element or to the top-level viewport ("root"). The position is delivered asynchronously and is useful for understanding the visibility of elements and implementing pre-loading and deferred loading of DOM content.
</p>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>
	</section>


<main id="MAIN0">

	<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>


<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, 此れ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>


<ul>
	<li>
用語
`文書@
は、~HTML `Document$I ~interfaceを実装する~objの略記である。
同様に，
`要素@
は、 `Element$I ~interfaceを実装する~objの略記である。
</li>
	<li>
%target.`<var>xyz</var>^sl という表記は、［
%target の `<var>xyz</var>^sl 内部~slot
］の略記である。
</li>
</ul>

		</section>



	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
~webの伝統的な位置~計算の仕組みは、~DOM状態を明示的に照会することに依拠する。
それは、（高価な）~styleの再計算, および~layoutを生じさせることが既知である。
この情報の継続的な~pollingは、有意な処理能~overheadの要因になることは頻繁にある。
◎
The web’s traditional position calculation mechanisms rely on explicit queries of DOM state that are known to cause (expensive) style recalculation and layout and, frequently, are a source of significant performance overhead due to continuous polling for this information.
</p>


<p>
次に挙げるもの含め、上述の挙動に依拠するような共通的な実施~自体は発展したが：
◎
A body of common practice has evolved that relies on these behaviors, however, including (but not limited to):
</p>

<ul>
	<li>
~DOMや~dataに対する~customな事前読込み／遅延読込みを築くとき。
◎
Building custom pre- and deferred-loading of DOM and data.
</li>
	<li>
~data集合の一部分を読込んで描画するような，~dataに束縛された高性能な~scroll用~listを実装するとき。
これは、携帯機器において中心的な対話成句になっている。
◎
Implementing data-bound high-performance scrolling lists which load and render subsets of data sets. These lists are a central mobile interaction idiom.
</li>
	<li>
<p>
要素の可視率を計算するとき。
特に，広告~networkでは、今や
<a href="http://www.iab.net/iablog/2014/03/viewability-has-arrived-what-you-need-to-know-to-see-through-this-sea-change.html">収益集計のために広告の “可視率” を報告することが要求されている</a>。
その結果、多くの~siteが次のいずれかを用いている：
</p>
		<ul>
			<li>
~scroll~handlerを濫用する（その結果、~scroll時に詰まる（ “scroll jank” ））
</li>
			<li>
<a href="http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html">同期的~layoutを呼出すような再読取り</a>
（ `requestAnimationFrame()^m ~loop内で不必要に重い仕事をさせる）
`例えば、 getComputedStyle() で 最新の~layout情報を照会するなど。^tnote
</li>
			<li>
要素の  “真の” 可視率を算出するため，~~外部~pluginによる解決策に頼る（~plugin~architectureによる~overheadすべてが伴われる）
</li>
		</ul>
◎
Calculating element visibility. In particular, ad networks now require reporting of ad "visibility" for monetizing impressions. This has led to many sites abusing scroll handlers (causing jank on scroll), synchronous layout invoking readbacks (causing unnecessary critical work in rAF loops), and resorting to exotic plugin-based solutions for computing "true" element visibility (with all the associated overhead of the plugin architecture).
</li>

</ul>

<p>
これらの利用事例には、共通する性質がある：
◎
These use-cases have several common properties:
</p>

<ol>
	<li>
個々の要素の，他の要素（または大域的な表示域）に~~相対的な状態を、受動的に “照会するもの” として表現できる。
◎
They can be represented as passive "queries" about the state of individual elements with respect to some other element (or the global viewport).
</li>
	<li>
厳しい刻限を課すものではない。
つまり、情報は 代償なしに非同期的に送達できる（例えば別~threadから）。
◎
They do not impose hard latency requirements; that is to say, the information can be delivered asynchronously (e.g. from another thread) without penalty.
</li>
	<li>
既存の~web~platform特色機能の どの組合わせからも，ほぼ~supportに乏しいため、普及しているにもかかわらず，開発者は余計な労を要している。
◎
They are poorly supported by nearly all combinations of existing web platform features, requiring extraordinary developer effort despite their widespread use.
</li>
</ol>

<p>
目標とはされていないが注目すべき点として、実際に何が表示されているかについての，~pixel単位の情報もある（ある種の~browser~architectureにおいては、~filter, WebGL, その他の特色機能に面したとき，効率的にこれを得るのは極めて難しいこともある）。
この情報は、これらの局面すべてに有用になる
— たとえ、遅延が少しあって，送達される~dataが不完全な合成結果によるときでも。
◎
A notable non-goal is pixel-accurate information about what was actually displayed (which can be quite difficult to obtain efficiently in certain browser architectures in the face of filters, webgl, and other features). In all of these scenarios the information is useful even when delivered at a slight delay and without perfect compositing-result data.
</p>


<p>
交差~observer~APIは、［
他の要素や大域的な表示域に~~相対的な 要素の位置を，非同期的に照会する
］ための新たな~methodを，開発者に与えることにより、上述の課題に取組む。
非同期的な送達により，［
~costのかかる~DOMや~styleの照会- ／
継続的な~polling ／
~custom~pluginの利用
］は不要になるので、~appは［
CPU, GPU, ~energy~cost
］を有意に抑制できるようになる。
◎
The Intersection Observer API addresses the above issues by giving developers a new method to asynchronously query the position of an element with respect to other elements or the global viewport. The asynchronous delivery eliminates the need for costly DOM and style queries, continuous polling, and use of custom plugins. By removing the need for these methods it allows applications to significantly reduce their CPU, GPU and energy costs.
</p>

<div class="example">

<pre class="js-code">
var %observer = new IntersectionObserver(%changes =&gt; {
  for (const %change of %changes) {
    /* <span class="comment">
変化が生じた時点を表す時刻印：
</span> */
    console.log(%change.`time$m);

    /* <span class="comment">
`交差~root$の区画：
</span> */
    console.log(%change.`rootBounds$m);

    /* <span class="comment">
%target が占める区画（ `getBoundingClientRect()$m ）：
</span> */
    console.log(%change.`boundingClientRect$m);

    /* <span class="comment">
`交差~root$内の %target の可視~域（
`boundingClientRect^m を %target の包含塊である各 先祖で~clipして得られる区画と `rootBounds^m との交差域）：
</span> */
    console.log(%change.`intersectionRect$m);

    /* <span class="comment">
%target が占める区画~内の %target の可視~部分が占める比率（
`intersectionRect^m の面積 ~DIV `boundingClientRect^m の面積
）：
</span> */
    console.log(%change.`intersectionRatio$m);

    /* <span class="comment">
`~target$にされている要素（ %target ）：
</span> */
    console.log(%change.`target$m);
  }
}, {});

var %target = ... /* <span class="comment">`~target$にする要素</span> */ ;

/* <span class="comment">
特定の`~target$に対し，交差~eventを~observeし始める：
</span> */
%observer.`observe(target)$m;

/* <span class="comment">
特定の`~target$に対し，~observeするのを停止する：
</span> */
%observer.`unobserve(target)$m;

/* <span class="comment">
すべての`~target$に対し，~observeするのを停止する：
</span> */
%observer.`disconnect()$m;
</pre>

<div lang="en"><pre>
var observer = new IntersectionObserver(changes =&gt; {
  for (const change of changes) {
    console.log(change.time);               // Timestamp when the change occurred
    console.log(change.rootBounds);         // Unclipped area of root
    console.log(change.boundingClientRect); // target.boundingClientRect()
    console.log(change.intersectionRect);   // boundingClientRect, clipped by its containing block ancestors, and intersected with rootBounds
    console.log(change.intersectionRatio);  // Ratio of intersectionRect area to boundingClientRect area
    console.log(change.target);             // the Element target
  }
}, {});

// Watch for intersection events on a specific target Element.
observer.observe(target);

// Stop watching for intersection events on a specific target Element.
observer.unobserve(target);

// Stop observing threshold events on all target elements.
observer.disconnect();
</pre></div>

</div>



	</section>
	<section id="intersection-observer-api">
<h2 title="Intersection Observer">2. 交差~observer</h2>


<p>
`交差~observer@
~APIは、開発者が次を得れるようにする
⇒
`交差~root$の中での，［
`~target@
にされた~DOM要素
］の［
可視率, 位置
］
◎
The Intersection Observer API enables developers to understand the visibility and position of target DOM elements relative to an intersection root.
</p>



		<section id="intersection-observer-callback">
<h3 title="The IntersectionObserverCallback">2.1. `IntersectionObserverCallback^I</h3>


<pre class="idl">
callback `IntersectionObserverCallback@I = void (sequence&lt;`IntersectionObserverEntry$I&gt; %entries, `IntersectionObserver$I %observer)
</pre>

<p>
この~callbackは、`~target$と`交差~root$との交差に変化が生じたとき，`処理~model節$にしたがって呼出されることになる。
◎
This callback will be invoked when there are changes to target’s intersection with the intersection root, as per the processing model.
</p>

<p class="trans-note">【
見かけ上の交差が~UAからどう認識されるかは、~UAや処理能に依存するであろう
— 例えば，高速に~scrollしたとき、その途上で表示が “間引かれた” 箇所があれば，その箇所にある~targetとの交差は見過ごされることになる
— 交差が検出される時機は，~UAの<a href="#event-loop">各~描画~更新ごと</a>なので。
】</p>


		</section>
		<section id="intersection-observer-interface">
<h3 title="The IntersectionObserver interface">2.2. `IntersectionObserver^I ~interface</h3>


<p>
`IntersectionObserver$I ~interfaceを利用すれば、［
`交差~root$と, `~target$にされた各`要素$
］との交差における変化を~observeできる。
◎
The IntersectionObserver interface can be used to observe changes in the intersection of an intersection root and one or more target Elements.
</p>

<div >
<p>
`IntersectionObserver$I ~objが有効な`~target$として~observeできるのは：
◎
↓</p>

<ul>
	<li>
~objの `root$m ~EQ ~NULL の場合、自動的に`暗黙的な~root$との交差を~observeする。
すなわち、`~top-level閲覧文脈$内にある どの`要素$も~observeできる
— 内側の`入子の閲覧文脈$内も含め。
</li>
	<li>
他の場合、`包含塊~連鎖$において `root$m の子孫である`要素$に限られる。
</li>
</ul>

◎
An IntersectionObserver with a root Element can observe any target Element that is a descendant of the root in the containing block chain.
◎
An IntersectionObserver with no root Element will automatically observe intersections with the implicit root, and valid targets include any Element in the top-level browsing context, as well as any Element in any nested browsing contexts inside the top-level browsing context.
</div>


<p class="note">注記：
`MutationObserver$I においては，
`MutationObserverInit$I が各種~optionとして `~observe0()$m に渡される一方で、
`IntersectionObserver$I においては，各種~optionは構築子に渡される。
この違いは、 `MutationObserver$I においては，~observeする `Node$I ごとに
`変異の種類を^tnote
絞込むための属性の集合を違えれることによる。
`IntersectionObserver$I においては、開発者は，同じ~option集合を用いる単独の~observerを利用して複数の~targetを追跡するか，または追跡する各~targetごとに異なる~observerを利用できる。
◎
Note: In MutationObserver, the MutationObserverInit options are passed to observe() while in IntersectionObserver they are passed to the constructor. This is because for MutationObserver, each Node being observed could have a different set of attributes to filter for. For IntersectionObserver, developers may choose to use a single observer to track multiple targets using the same set of options; or they may use a different observer for each tracked target.
</p>


<p class="issue"><!--  class="issue" 追加＊ -->
各 `~target$ごとに［
`rootMargin$mb ／ `threshold$mb
］値を違えれるようにしても、利用事例は拡がらず，より複雑になるだけに見える。
その必要が将来に生じたときは、後の~versionで `observe()$m ごとに~optionを供することもあり得る。
◎
rootMargin or threshold values for each target seems to introduce more complexity without solving additional use-cases. Per-observe() options could be provided in the future if V2 introduces a need for it.
</p>


<pre class="idl">
[<a href="#dom-intersectionobserver-intersectionobserver" >Contructor</a>(`IntersectionObserverCallback$I %callback, optional `IntersectionObserverInit$I %options),
 `Exposed$=Window]
interface `IntersectionObserver@I {
  readonly attribute `Element$I? `root$m;
  readonly attribute DOMString `rootMargin$m;
  readonly attribute sequence&lt;double&gt; `thresholds$m;
  void `observe$m(`Element$I %target);
  void `unobserve$m(`Element$I %target);
  void `disconnect$m();
  sequence&lt;`IntersectionObserverEntry$I&gt; `takeRecords$m();
};
</pre>

<dl class="idl-def">
	<dt>`IntersectionObserver(callback, options)@m</dt>
	<dd>
<p>
被呼出時には、次を走らす：
◎
↓</p>
		<ol>
			<li>
%this ~LET 新たな `IntersectionObserver$I ~obj
◎
Let this be a new IntersectionObserver object
</li>
			<li>
%this.`callback$sl ~SET %callback
◎
Set this’s internal [[callback]] slot to callback.
</li>
			<li>
%this の `root$m  ~SET %options の `root$mb 値
◎
Set this.root to options.root.
</li>
			<li>
%~list ~LET %options の `rootMargin$mb 値から`~root~marginを構文解析-$した結果
◎
↓</li>
			<li>
~IF［
%~list ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
↓</li>
			<li>
%this.`rootMargin$sl ~SET %~list
◎
Attempt to parse a root margin from options.rootMargin. If a list is returned, set this’s internal [[rootMargin]] slot to that. Otherwise, throw a SyntaxError exception.
</li>
			<li>
%~threshold~list ~LET %options の `threshold$mb に等価な~list
◎
Let thresholds be a list equal to options.threshold.
</li>
			<li>
~IF［
%~threshold~list 内の値に { 0.0 〜 1.0 } に入らないものがある
］
⇒
~THROW `RangeError$E
◎
If any value in thresholds is less than 0.0 or greater than 1.0, throw a RangeError exception.
</li>
			<li>
%~threshold~list を昇順に~sortする
◎
Sort thresholds in ascending order.
</li>
			<li>
~IF［
%~threshold~list は空である
］
⇒
0 を %~threshold~list に付加する
◎
If thresholds is empty, append 0 to thresholds.
</li>
			<li>
%this の `thresholds$m ~SET %~threshold~list
◎
Set this.thresholds to thresholds.
</li>
			<li>
~RET %this
◎
Return this.
</li>
		</ol>
	</dd>

	<dt>`observe(target)@m</dt>
	<dd>
<p>
被呼出時には、次を走らす：
◎
↓</p>
		<ol>
			<li>
~IF［
%target ~IN 此れ.`ObservationTargets$sl
］
⇒
~RET
◎
If target is in this’s internal [[ObservationTargets]] slot, return.
</li>
			<li>
%交差~observer登録 ~LET 次のようにされた`交差~observer登録$
⇒
`observer$rp ~prop ~SET 此れ；<br>
`previousThresholdIndex$rp ~prop ~SET 0
◎
Let intersectionObserverRegistration be an IntersectionObserverRegistration record with an observer property set to this and a previousThresholdIndex property set to 0.
</li>
			<li>
%target.`RegisteredIntersectionObservers$sl に
%交差~observer登録 を付加する
◎
Append intersectionObserverRegistration to target’s internal [[RegisteredIntersectionObservers]] slot.
</li>
			<li>
此れ.`ObservationTargets$sl に %target を付加する
◎
Add target to this’s internal [[ObservationTargets]] slot.
</li>
			<li>
`root$m の`閲覧文脈$における`~event-loop$の反復を~scheduleする<!-- ＊ -->
◎
Schedule an iteration of the event loop in the root's browsing context.
</li>
		</ol>
	</dd>

	<dt>`unobserve(target)@m</dt>
	<dd>
<p>
被呼出時には、次を走らす：
◎
↓</p>
		<ol>
			<li>
%target.`RegisteredIntersectionObservers$sl から［
`observer$rp ~prop ~EQ 此れ
］なる `交差~observer登録$を除去する
◎
Remove the IntersectionObserverRegistration record whose observer property is equal to this from target’s internal [[RegisteredIntersectionObservers]] slot.
</li>
			<li>
此れ.`ObservationTargets$sl から
%target を除去する
◎
Remove target from this’s internal [[ObservationTargets]] slot.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`MutationObserver$I は `unobserve()$m を実装しない。
`unobserve()$m は、 `IntersectionObserver$I 用に，遅延読込みの利用事例に取組むためにある
— その事例では、 %target が可視になった時点で追跡する必要もなくなるので。
すべての`~target$を `disconnect()$m した上で，必要なものを `observe()$m するときや、各 `~target$ごとに別々の `IntersectionObserver$I を作成するときは、より仕事が要ることになる。
◎
Note: MutationObserver does not implement unobserve(). For IntersectionObserver, unobserve() addresses the lazy-loading use case. After target becomes visible, it does not need to be tracked. It would be more work to either disconnect() all targets and observe() the remaining ones, or create a separate IntersectionObserver for each target.
</dd>

	<dt>`disconnect()@m</dt>
	<dd>
<p>
被呼出時には、次を走らす：
◎
↓</p>
		<ol>
			<li>
此れ.`ObservationTargets$sl 内の ~EACH( %target ) に対し
⇒
%target.`RegisteredIntersectionObservers$sl から［
`observer$rp ~prop ~EQ 此れ
］なる`交差~observer登録$を除去する
</li>
			<li>
此れ.`ObservationTargets$sl を空にする
◎
↑</li>
		</ol>
◎
For each target in this’s internal [[ObservationTargets]] slot:
◎
Remove the IntersectionObserverRegistration record whose observer property is equal to this from target’s internal [[RegisteredIntersectionObservers]] slot.
◎
Remove target from this’s internal [[ObservationTargets]] slot.
</dd>

	<dt>`takeRecords()@m</dt>
	<dd>
<p>
被呼出時には、次を走らす：
◎
↓</p>
		<ol>
			<li>
%待行列 ~LET 此れ.`QueuedEntries$sl の複製
◎
Let queue be a copy of this’s internal [[QueuedEntries]] slot.
</li>
			<li>
此れ.`QueuedEntries$sl を空にする
◎
Clear this’s internal [[QueuedEntries]] slot.
</li>
			<li>
~RET %待行列
◎
Return queue.
</li>
		</ol>
	</dd>
</dl>

<dl class="idl-def">
	<dt>`root@m</dt>
	<dd>
取得子は、［
此れが`暗黙的な~root$を利用しているならば ~NULL ／
~ELSE_ 此れが`交差~root$として利用している`要素$
］を返す。
◎
The root Element to use for intersection, or null if the observer uses the implicit root.
</dd>

	<dt>`rootMargin@m</dt>
	<dd>
<p>
取得子は、此れの`交差~root$の境界boxの各~辺に適用される 一連の~offsetを，下に述べるように文字列に直列化した結果を返す。
これらの~offsetは：
</p>

<ul>
	<li>
交差域を計算する際に，その~boxを実質的に拡げる／狭めるために利用される。
</li>
	<li>
適用されるのは、`~target$が`交差~root$と同じ`互いに関係するかつ生成元も類似する閲覧文脈~群$に属する場合に限られる。
</li>
</ul>

◎
Offsets applied to the intersection root’s bounding box, effectively growing or shrinking the box that is used to calculate intersections. Note that rootMargin is only applied for targets which belong to the same unit of related similar-origin browsing contexts as the intersection root.
</dd>
	<dd>
<p>
一連の~offsetを直列化するときは、此れの `rootMargin$sl 値の各 成分を次にしたがって文字列~化した結果を，順に~space区切りで連結する：
</p>

<ul ><li>  ~pixel長さは［
成分の数†, `px^l
］の並びにする
</li><li>百分率は［
成分の数†, `%^l
］の並びにする
</li></ul>

<p class="trans-note">【†
その数を表現する 10 進記数法による文字列であろうが、詳細は規定されていない。
（`~CSS成分~値として直列化-$する手続きに従う？）
】</p>


<p>
結果と［
此れの構築-時に渡された %options の `rootMargin$mb
］とが一致することは、保証されないことに注意。
%options にて `rootMargin$mb を省略していた場合の結果は
`0px 0px 0px 0px^l になる。
</p>
◎
On getting, return the result of serializing the elements of [[rootMargin]] space-separated, where pixel lengths serialize as the numeric value followed by "px", and percentages serialize as the numeric value followed by "%". Note that this is not guaranteed to be identical to the options.rootMargin passed to the IntersectionObserver constructor. If no rootMargin was passed to the IntersectionObserver constructor, the value of this attribute is "0px 0px 0px 0px".
</dd>

	<dt>`thresholds@m</dt>
	<dd>
取得子は、此れの構築-時に渡された %options 引数の `threshold$mb 内の一連の~thresholdを昇順で~sortした結果の~listを返す
— `threshold$mb が供されていなかった場合、 1 個の 0 のみからなる~listになる。
各~thresholdは、此れが~observeしている~targetの境界box区画の交差~比率と比較され、ある~targetのそれが いずれかの~thresholdを横切ったとき，対する通知が生成される。
◎
A list of thresholds, sorted in increasing numeric order, where each threshold is a ratio of intersection area to bounding box area of an observed target. Notifications for a target are generated when any of the thresholds are crossed for that target. If no options.threshold was provided to the IntersectionObserver constructor, the value of this attribute will be [0].
</dd>
</dl>


<p>
`IntersectionObserver$I の
`交差~root@
は、その `root$m 属性の値 ~NEQ ~NULL ならば それ ／
~ELSE_ `~top-level閲覧文脈$の`文書$~nodeである。
後者の場合の文書~nodeは
`暗黙的な~root@
と呼ばれる。
◎
The intersection root for an IntersectionObserver is the value of its root attribute, or else the top-level browsing context’s document node (referred to as the implicit root) if the root attribute is null.
</p>

<p>
`IntersectionObserver$I の
`~root交差~矩形@
は、各~targetが交差しているかどうか検査するときに利用する矩形であり，次に従って与えられる：
◎
The root intersection rectangle for an IntersectionObserver is the rectangle we’ll use to check against the targets.
</p>

<ol>
	<li>
%~root ~LET `交差~root$
</li>
	<li>
<p>
%~root矩形 ~LET %~root に応じて，次で与えられる矩形：
</p>

		<dl class="switch">
			<dt>
`暗黙的な~root$である場合
◎
If the intersection root is the implicit root,
</dt>
			<dd>
%~root の表示域
◎
it’s the viewport’s size.
</dd>

			<dt>
%~root の~overflowが~clipされている場合
◎
If the intersection root has an overflow clip,
</dt>
			<dd>
%~root の`内容~区画$
◎
it’s the element’s content area.
</dd>

			<dt>
その他
◎
Otherwise,
</dt>
			<dd>
%~root 上で `getBoundingClientRect()$m ~algoを走らせた結果
◎
it’s the result of running the getBoundingClientRect() algorithm on the intersection root.
</dd>
		</dl>
	</li>
	<li>
<p>
~IF［
`~target$と %~rootは 同じ `互いに関係するかつ生成元も類似する閲覧文脈~群$に属する
］
⇒
%~root矩形 ~SET %~root矩形 の各~辺を
`IntersectionObserver$I.`rootMargin$sl 内の各~offsetに則って，~CSSの `margin$p ~propに類似する方式で拡幅した結果
— すなわち：
</p>

<ul><li>正の長さは外方への~offsetを指示する。
</li><li>4 個の値は順に，［
上端, 右端, 下端, 左端
］辺が~offsetされる量を指示する。
</li><li>百分率は、~~元の矩形の横幅†を基準に解決する。
`†~layoutが縦組みの場合は、縦幅？^tnote
</li></ul>
◎
For any target which belongs to the same unit of related similar-origin browsing contexts as the intersection root, the rectangle is then expanded according to the offsets in the IntersectionObserver’s [[rootMargin]] slot in a manner similar to CSS’s margin property, with the four values indicating the amount the top, right, bottom, and left edges, respectively, are offset by, with positive lengths indicating an outward offset. Percentages are resolved relative to the width of the undilated rectangle.
</li>
	<li>
~RET %~root矩形
</li>
</ol>



<p class="note">注記：
`rootMargin$m が適用されるのは、`交差~root$ 自身に限られる。
`~target$`要素$が`交差~root$以外の ある先祖の区画~内に~clipされる場合でも、その~clipingは
`rootMargin$m からは影響されない。
◎
Note: rootMargin only applies to the intersection root itself. If a target Element is clipped by an ancestor other than the intersection root, that clipping is unaffected by rootMargin.
</p>


<p class="note">注記：
`~root交差~矩形$は、`~pinch-zoom$からは影響されない
— ~pinch-zoomの主旨は、~layoutは<em>変えずに</em>，拡大鏡の様に動作することにあるので。
◎
Note: Root intersection rectangle is not affected by pinch zoom and will report the unadjusted viewport, consistent with the intent of pinch zooming (to act like a magnifying glass and NOT change layout.)
</p>

<p>
文字列 %~margin文字列 から
`~root~marginを構文解析-@
するときは、それぞれが［
~pixel長さ, または百分率
］のいずれかである 4 個の値からなる~list, または `失敗^i を返す：
◎
To parse a root margin from an input string marginString, returning either a list of 4 pixel lengths or percentages, or failure:
</p>

<ol>
	<li>
%~token~list ~LET %~margin文字列 から`成分~値の~listを構文解析-$した結果
◎
Parse a list of component values marginString, storing the result as tokens.
</li>
	<li>
%~token~list からすべての`空白~token$を除去する
◎
Remove all whitespace tokens from tokens.
</li>
	<li>
~IF［
%~token~list の長さ ~NIN { 1, 2, 3, 4 }
］
⇒
~RET `失敗^i
◎
If the length of tokens is 0 or greater than 4, return failure.
</li>
	<li>
%結果 ~LET 空~list
</li>
	<li>
<p>
%~token~list 内の ~EACH( %token ) に対し：
◎
Replace each token in tokens:
</p>
		<ol>
			<li>
~IF［
%token は`絶対~長さ$による `dimension$t ~tokenである
］
⇒
%結果 に %token に等価な~pixel長さを付加する
◎
If token is an absolute length dimension token, replace it with a an equivalent pixel length.
</li>
			<li>
~ELIF［
%token は `percentage$t ~tokenである
］
⇒
%結果 に %token に等価な百分率を付加する
◎
If token is a &lt;percentage&gt; token, replace it with an equivalent percentage.
</li>
			<li>
~ELSE
⇒
~RET `失敗^i
◎
Otherwise, return failure.
</li>
		</ol>
	</li>
	<li>
<p>
%結果 の長さに応じて：
</p>
		<dl class="switch">
			<dt>1</dt>
			<dd>
%結果 内の 1 個目の値を 3 個~複製して，それらを %結果 に付加する
</dd>

			<dt>2</dt>
			<dd>
%結果 内の［
1 個目の値, 2 個目の値
］を複製して，順に %結果 に付加する
</dd>

			<dt>3</dt>
			<dd>
%結果 内の 2 個目の値を複製して %結果 に付加する
</dd>
</dl>
◎
If there is one element in tokens, append three duplicates of that element to tokens. If there is two elements are tokens, append a duplicate of each element to tokens. If there are three elements in tokens, append a duplicate of the second element to tokens.
</li>
	<li>
~RET %結果
◎
Return tokens.
</li>

</ol>



		</section>
		<section id="intersection-observer-entry">
<h3 title="The IntersectionObserverEntry interface">2.3. `IntersectionObserverEntry^I ~interface</h3>


<pre class="idl">
[<dfn id="dom-intersectionobserverentry-intersectionobserverentry">Constructor</dfn>(`IntersectionObserverEntryInit$I %intersectionObserverEntryInit)]
interface `IntersectionObserverEntry@I {
  readonly attribute `DOMHighResTimeStamp$I `time$m;
  readonly attribute `DOMRectReadOnly$I `rootBounds$m;
  readonly attribute `DOMRectReadOnly$I `boundingClientRect$m;
  readonly attribute `DOMRectReadOnly$I `intersectionRect$m;
  readonly attribute double `intersectionRatio$m;
  readonly attribute `Element$I `target$m;
};

dictionary `IntersectionObserverEntryInit@I {
  required `DOMHighResTimeStamp$I `time@mb;
  required `DOMRectInit$I `rootBounds@mb;
  required `DOMRectInit$I `boundingClientRect@mb;
  required `DOMRectInit$I `intersectionRect@mb;
  required double `intersectionRatio@mb;
  required `Element$I `target@mb;
};
</pre>

<p class="trans-note">【
個々の交差~event通知は、この~interfaceが表現する。
】</p>

<p>
`IntersectionObserverEntry$I ~obj %~entry を
`生成した~observer@
とは、
%~entry が`~IntersectionObserverEntryを待入する$手続きにて構築されたならば，その手続きの入力に与えられている `IntersectionObserver$I ~objを指す。
他の場合は未定義とする。
</p>

<p class="trans-note">【
この用語は、明確化するためにこの訳に導入している。
`生成した~observer$が未定義の場合
— 例えば `IntersectionObserverEntry()$m 構築子を呼出して作成されるものなど —
の挙動は、この仕様には述べられていない。
】【
この節の “真の” 規範的な記述は、上述の手続きを含む`処理~model節$に定義される。
】</p>

<dl class="idl-def">
	<dt>`boundingClientRect@m</dt>
	<dd>
此れの `target$m 上で `getBoundingClientRect()$m ~algoを走らせた結果になる。
<!-- の DOMRectReadOnly -->
◎
A DOMRectReadOnly obtained by running the getBoundingClientRect() algorithm on the target.
</dd>

	<dt>`intersectionRect@m</dt>
	<dd>
<p>
次に挙げる矩形すべての交差域（共通域）になる：
</p>

<ul ><li>此れの `boundingClientRect$m
</li><li>次を満たす各~要素の~cliping矩形
⇒
此れを`生成した~observer$の`交差~root$の子孫である<!-- ＊root -->
~AND
此れの `target$m の先祖である
</li><li>此れを`生成した~observer$の`~root交差~矩形$
</li></ul>

<p>
この値は、此れを`生成した~observer$の`~root交差~矩形$内で実際に可視になる， `target$m の部位を表現する。
</p>
◎
boundingClientRect, intersected by each of target's ancestors' clip rects (up to but not including root), intersected with the root intersection rectangle. This value represents the portion of target actually visible within the root intersection rectangle.
</dd>

	<dt>`intersectionRatio@m</dt>
	<dd>
( 此れの `intersectionRect$m の面積 ~DIV 此れの `boundingClientRect$m の面積 )
になる。
◎
Ratio of intersectionRect area to boundingClientRect area.
</dd>

	<dt>`rootBounds@m</dt>
	<dd>
`target$m が［
此れを`生成した~observer$の`交差~root$
］と同じ `互いに関係するかつ生成元も類似する閲覧文脈~群$に属するならば、此れを`生成した~observer$の`~root交差~矩形$になる。
~ELSE_ ~NULL になる。
◎
If target belongs to the same unit of related similar-origin browsing contexts as the intersection root, this will be the root intersection rectangle. Otherwise, this will be null. Note that if the target is in a different browsing context than the intersection root, this will be in a different coordinate system than boundingClientRect and intersectionRect.
</dd>
	<dd class="note">
~targetが`交差~root$と異なる`閲覧文脈$内にある場合の結果は、
`boundingClientRect$m, `intersectionRect$m
とは異なる座標系に属することに注意。
◎
↑</dd>

	<dt>`target@m</dt>
	<dd>
此れを`生成した~observer$の`交差~root$との交差が変化した`要素$を返す。
◎
The Element whose intersection with the intersection root changed.
</dd>

	<dt>`time@m</dt>
	<dd>
交差が記録された時刻を，［
此れを`生成した~observer$に結付けらている大域~obj
］の`起点時刻$を基準にして表す `DOMHighResTimeStamp$I 型~値を返さ~MUST。
◎
The attribute must return a DOMHighResTimeStamp that corresponds to the time the intersection was recorded, relative to the time origin of the global object associated with the IntersectionObserver instance that generated the notification.
</dd>

</dl>


		</section>
		<section id="intersection-observer-init">
<h3 title="The IntersectionObserverInit dictionary">2.4. `IntersectionObserverInit^I ~dictionary</h3>

<pre class="idl">
dictionary `IntersectionObserverInit@I {
  `Element$I?  `root$mb = null;
  DOMString `rootMargin$mb = "0px";
  (double or sequence&lt;double&gt;) `threshold$mb = 0;
};
</pre>

<dl class="idl-def">
	<dt>`root@mb</dt>
	<dd>
利用する`交差~root$を与える。
省略時（ ~NULL ）には、`暗黙的な~root$が利用される。
◎
The root to use for intersection. If not provided, use the implicit root.
</dd>

	<dt>`rootMargin@mb</dt>
	<dd>
~CSS `margin$p ~propと類似的に、［
各 成分が`絶対~長さ$または百分率を表す
］ような 1 〜 4 個の成分からなる文字列として，`交差~root$に適用する~marginを与える。
◎
Similar to the CSS margin property, this is a string of 1-4 components, each either an absolute length or a percentage.
</dd>

	<dd class="example">
<table id="_ex-margin">
<caption>
値の例と 適用される~margin
</caption>
<thead><tr><th>値
<th>上端<th>右端<th>下端<th>左端
</thead>

<tbody><tr><td>`5px^l
<td>`5px^v<td>`5px^v<td>`5px^v<td>`5px^v

<tr><td>`5px 10px^l
<td>`5px^v<td>`10px^v<td>`5px^v<td>`10px^v

<tr><td>`-10px 5px 8px^l
<td>`-10px^v<td>`5px^v<td>`8px^v<td>`5px^v

<tr><td>`-10px -5px 5px 8px^l
<td>`-10px^v<td>`-5px^v<td>`5px^v<td>`8px^v

</tbody></table>


<pre lang="en">
"5px"                // all margins set to 5px
"5px 10px"           // top &amp; bottom = 5px, right &amp; left = 10px
"-10px 5px 8px"      // top = -10px, right &amp; left = 5px, bottom = 8px
"-10px -5px 5px 8px" // top = -10px, right = -5px, bottom = 5px, left = 8px
</pre>

	</dd>

	<dt>`threshold@mb</dt>
	<dd>
~callbackを誘発するための，一連の~thresholdからなる~listを与える。
`intersectionRect$m 区画の比率が［
いずれかの~threshold~以上から それ未満に変化した ／
その逆に変化した
］とき、~callbackが呼出されることになる。
◎
List of threshold(s) at which to trigger callback. callback will be invoked when intersectionRect’s area changes from greater than or equal to any threshold to less than that threshold, and vice versa.
	</dd>
	<dd>
どの~thresholdも範囲 { 0 〜 1.0 } に入ってい~MUST。
各 ~thresholdは、 `~target$上で `getBoundingClientRect()$m ~algoを走らせて得られる矩形~区画の可視率を表現する。
◎
Threshold values must be in the range of [0, 1.0] and represent a percentage of the area of the rectangle produced by running the getBoundingClientRect() algorithm on the target.
	</dd>
	<dd class="note">注記：
値 0.0 は、実質的に， “非~zero個の~pixel” を表す。
`すなわち、少しでも交差しているかどうか。^tnote
◎
Note: 0.0 is effectively "any non-zero number of pixels".
</dd>
</dl>

		</section>
	</section>
	<section id="intersection-observer-processing-model">
<h2 title="Processing Model">3. 処理~model</h2>

<p>
この節では、~UAが`交差~observer$ ~APIを実装するときに とら~MUST手続きを要旨する。
◎
This section outlines the steps the user agent must take when implementing the Intersection Observer API.
</p>


		<section id="defines">
<h3 title="Internal Slot Definitions">3.1. 各種 内部~slotの定義</h3>

			<section id="document-defines">
<h4 title="Document">3.1.1. 文書</h4>

<p>
各 `文書$には
`交差~observer~task処理待ち~flag@
（ IntersectionObserverTaskQueued flag ）
が結付けられ、初期~時は ~OFF にされる。
◎
Each Document has an IntersectionObserverTaskQueued flag which is initialized to false.
</p>

<p class="trans-note">【
この~flagは、いっときに生じた一連の交差が 1 回の通知に集約されるように処理を制御する。
交差が生じたとき（それは、<a href="#event-loop">~event-loop処理</a>の中で`交差~observationsの更新~手続きを走らす$ことにより検出される）、最終的に
<!-- 
~IntersectionObserverEntryを待入する$ → 交差~observer~taskを待入する$
 -->
`交差~observerたちに通知する$~taskが待入される。
その~task（それは、~observerの構築子に渡された %callback を呼出して~scriptに交差を通知する）が実際に走り始めるまで、この~flagは ~ON にされる。
その間に検出された新たな交差の通知は、新たな~taskを待入することなく留め置かれ，先送りされることになる。
言い換えれば、この~flagは，ある程度の最適化の裁量を~UAに与えるためにあるように見受けられる。
】</p>


			</section>
			<section id="element-private-slots">
<h4 title="Element">3.1.2. 要素</h4>

<div>
<p>
各 `要素$は、
`RegisteredIntersectionObservers@sl
内部~slotを持ち，初期~時は空~listにされ~MUST。
この~listは、
`交差~observer登録@
と呼ばれる~recordたちを保持する。
その各~recordは、次の~propからなる：
</p>

<dl>
	<dt>`observer@rp</dt>
	<dd>
`当の要素を~observeしている^tnote
`IntersectionObserver$I を保持する。
</dd>

	<dt>`previousThresholdIndex@rp</dt>
	<dd>
範囲
{ 0 〜 `observer$rp の `thresholds$m の長さ }
に入る整数を保持する。
</dd>
	<dd class="trans-note">【
要素の直近の交差~比率が， 一連の~thresholdで区切られる何番目の区間に入っているかを指示する。
0 は，最小の~threshold未満の区間に対応し、
`thresholds$m の長さは，最大~threshold以上の区間に対応する。
（最小の~thresholdが 0 のときの 0 は、要素が交差していないことを表す。）
】</dd>
</dl>

◎
Element objects have an internal [[RegisteredIntersectionObservers]] slot, which is initialized to an empty list. This list holds IntersectionObserverRegistration records, which have an observer property holding an IntersectionObserver and a previousThresholdIndex property holding a number between 0 and the length of the observer’s thresholds property (inclusive).
</div>



			</section>
			<section id="intersection-observer-private-slots">
<h4 title="IntersectionObserver">3.1.3. `IntersectionObserver^I</h4>

<div >
<p>
`IntersectionObserver$I ~obj %O は、次に挙げる内部~slotを持つ：
</p>

<dl class="def-list">
	<dt>`QueuedEntries@sl</dt>
	<dd>
初期~時は空~listとする。
</dd>
	<dd class="trans-note">【
%O が~observeしている~targetたちにおける交差の変化を表現する各 通知を，内部的に保持する。
】</dd>

	<dt>`ObservationTargets@sl</dt>
	<dd>
初期~時は空~listとする。
</dd>
	<dd class="trans-note">【
%O が~observeしている~targetたちを，内部的に保持する。
順序は、~targetを引数に %O の `observe()$m が~callされた順になる。
】</dd>

	<dt>`callback@sl</dt>
	<dd>
`IntersectionObserver()$m にて初期化される。
</dd>
	<dd class="trans-note">【
%O の構築-時に渡された %callback を内部的に保持する。
】</dd>

	<dt>`rootMargin@sl</dt>
	<dd>
4 個の~pixel長さまたは百分率からなる~list。
</dd>
	<dd class="trans-note">【
%O の `rootMargin$m が表現する 4 辺の~offsetを内部的に保持する。
】</dd>

</dl>
◎
IntersectionObserver objects have internal [[QueuedEntries]] and [[ObservationTargets]] slots, which are initialized to empty lists and an internal [[callback]] slot which is initialized by IntersectionObserver(callback, options). They also have an internal [[rootMargin]] slot which is a list of four pixel lengths or percentages.
</div>

<!-- ＊なぜ “thresholds^sl” はこの節で定義されない？ -->


			</section>
		</section>
		<section id="algorithms">
<h3 title="Algorithms">3.2. 各種~algo</h3>

			<section id="queue-intersection-observer-task">
<h4 title="Queue an Intersection Observer Task">3.2.1. 交差~observer~taskを待入する</h4>

<p>
`文書$ %文書 に対し
`交差~observer~taskを待入する@
ときは、次を走らす：
◎
To queue an intersection observer task for a Document document, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 の`交差~observer~task処理待ち~flag$ ~EQ ~ON
］
⇒
~RET
◎
If document’s IntersectionObserverTaskQueued flag is set to true, return.
</li>
	<li>
%文書 の`交差~observer~task処理待ち~flag$ ~SET ~ON
◎
Set document’s IntersectionObserverTaskQueued flag to true.
</li>
	<li>
%~task ~LET 次を走らす~task
⇒
%文書 に対する`交差~observerたちに通知する$
◎
↓</li>
	<li>
<p>
%文書 の`~event-loop$に %~task を`待入する$
</p>

<p class="trans-note">【
%文書 が属する閲覧文脈の~event-loop？
利用する`~task源$はどれ？
】</p>
◎
Queue a task to the document’s event loop to notify intersection observers.
</li>

</ol>



			</section>
			<section id="notify-intersection-observers-algo">
<h4 title="Notify Intersection Observers">3.2.2. 交差~observerたちに通知する</h4>


<p>
`文書$ %文書 に対する
`交差~observerたちに通知する@
ときは、次を走らす：
◎
To notify intersection observers for a Document document, run these steps:
</p>

<ol>
	<li>
%文書 の`交差~observer~task処理待ち~flag$ ~SET ~OFF
◎
Set document’s IntersectionObserverTaskQueued flag to false.
</li>
	<li>
%通知-~list ~LET
次を満たす `IntersectionObserver$I すべてからなる~list
⇒
その `root$m
<span class="trans-note">【
 `交差~root$？
】</span>
は %文書 の~DOM木内にある
◎
Let notify list be a list of all IntersectionObservers whose root is in the DOM tree of document.
</li>

	<li>
<p>
%通知-~list 内の ~EACH( %~observer ) に対し：
◎
For each IntersectionObserver object observer in notify list, run these steps:
</p>

		<ol>
			<li>
~IF［
%~observer.`QueuedEntries$sl は空である
］
⇒
~CONTINUE
◎
If observer’s internal [[QueuedEntries]] slot is empty, continue.
</li>
			<li>
%待行列 ~LET
%~observer.`QueuedEntries$sl の複製
◎
Let queue be a copy of observer’s internal [[QueuedEntries]] slot.
</li>
	<li>
%~observer.`QueuedEntries$sl を空にする
◎
Clear observer’s internal [[QueuedEntries]] slot.
</li>
	<li>
<p>
次を与える下で， %~observer.`callback$sl を呼出す：
</p>

<ul><li>`~callback this 値$ ~SET %~observer
</li><li>引数~list ~SET ( %待行列, %~observer )
</li></ul>


<p>
この段で例外が投出された場合は、その`例外を報告-$する
</p>

◎
Invoke callback with queue as the first argument and observer as the second argument and callback this value. If this throws an exception, report the exception.
</li>
		</ol>
	</li>
</ol>



			</section>
			<section id="queue-intersection-observer-entry-algo">
<h4 title="Queue an IntersectionObserverEntry">3.2.3. `IntersectionObserverEntry^I を待入する</h4>

<div>
<p>
`IntersectionObserver$I %~observer に対する
`~IntersectionObserverEntryを待入する@
ときは、所与の：
</p>

<ol><li>%文書 （`文書$ ）
</li><li>%time （ `DOMHighResTimeStamp$I ）
</li><li>%rootBounds （ `DOMRect$I ）
</li><li>%boundingClientRect （ `DOMRect$I ）
</li><li>%intersectionRect （ `DOMRect$I ）
</li><li>%target （ `要素$ ）
</li></ol>

<p>
に対し、次を走らす：
</p>
◎
To queue an IntersectionObserverEntry for an IntersectionObserver observer, given a Document document; DOMHighResTimeStamp time; DOMRects rootBounds, boundingClientRect, and intersectionRect; and an Element target; run these steps:
</div>

<ol>
	<li>
<p>
%entry ~LET 次のようにされた
`IntersectionObserverEntry$I を構築した結果：
</p>
<ul ><li>`time$m ~SET %time
</li><li>`rootBounds$m ~SET %rootBounds
</li><li>`boundingClientRect$m ~SET %boundingClientRect
</li><li>`intersectionRect$m ~SET %intersectionRect
</li><li>`target$m ~SET %target
</li></ul>

◎
Construct an IntersectionObserverEntry, passing in time, rootBounds, boundingClientRect, intersectionRect and target.
</li>
	<li>
%~observer.`QueuedEntries$sl に %entry を付加する
◎
Append it to observer’s internal [[QueuedEntries]] slot.
</li>
	<li>
%文書 に対し`交差~observer~taskを待入する$
◎
Queue an intersection observer task for document.
</li>

</ol>

			</section>
			<section id="calculate-intersection-rect-algo">
<h4 title="Compute the Intersection of a Target Element and the Root">3.2.4. ~target要素と~rootとの交差域を算出する</h4>

<p>
`~target$ %~target と~observerの`交差~root$ %~root との
`交差域を算出-@
するときは、次を走らす：
◎
To compute the intersection between a target and the observer’s intersection root, run these steps:
</p>

<ol>
	<li>
%交差~矩形 ~LET %~target 上で `getBoundingClientRect()$m ~algoを走らせた結果
◎
Let intersectionRect be the result of running the getBoundingClientRect() algorithm on the target.
</li>
	<li>
%容器 ~LET %~target の`包含塊$
◎
Let container be the containing block of the target.
</li>

	<li>
<p>
~WHILE［
%容器 ~NEQ %~root
］：
◎
While container is not the intersection root:
</p>

		<ol>
			<li>
%交差~矩形 ~SET %交差~矩形 を %容器 の座標空間に写像した結果
◎
Map intersectionRect to the coordinate space of container.
</li>
			<li>
~IF［
%容器 の~overflowは~clipされている
］~OR［
%容器 は~CSS `clip-path$p ~propにより~clipされている
］
⇒
%交差~矩形 ~SET %交差~矩形 を %容器 で~clipした結果
◎
If container has overflow clipping or a css clip-path property, update intersectionRect by applying container’s clip.
</li>
			<li>
<p>
~IF［
%容器 は ある`入子の閲覧文脈$ %C の~root要素である
］：
</p>
<ol><li>%容器 ~SET %容器 の`閲覧文脈~容器$
</li><li>%交差~矩形 ~SET %交差~矩形 を %C の`表示域$で~clipした結果
</li></ol>
◎
If container is the root element of a nested browsing context, update container to be the browsing context container of container, and update intersectionRect by clipping to the viewport of the nested browsing context. Otherwise, update container to be the containing block of container.
</li>
			<li>
~ELSE
⇒
%容器 ~SET %容器 の`包含塊$
◎
↑</li>
		</ol>
	</li>
	<li>
%交差~矩形 ~SET %交差~矩形 を %~root の座標空間に写像した結果
◎
Map intersectionRect to the coordinate space of the intersection root.
</li>
	<li>
%交差~矩形 ~SET %交差~矩形 と`~root交差~矩形$との交差域
◎
Update intersectionRect by intersecting it with the root intersection rectangle.
</li>
	<li>
%交差~矩形 ~SET %交差~矩形 を［
%~target を包含している`文書$の表示域の座標空間
］に写像した結果
◎
Map intersectionRect to the coordinate space of the viewport of the Document containing the target.
</li>

</ol>


			</section>
			<section id="update-intersection-observations-algo">
<h4 title="Run the Update Intersection Observations Steps">3.2.5. 交差~observationsを更新する手続き</h4>

<p>
`文書$ %文書 に対する
`交差~observationsの更新~手続きを走らす@
ときは、所与の時刻印 %時刻 に対し，次を走らす：
◎
To run the update intersection observations steps for a Document document given a timestamp time, run these steps:
</p>

<ol>
	<li>
%~observer~list ~LET 次を満たす `IntersectionObserver$I ~objすべてからなる~list
⇒
`root$m
<span class="trans-note">【
 `交差~root$？
】</span>
は %文書 の~DOM木内にある
◎
Let observer list be a list of all IntersectionObservers whose root is in the DOM tree of document.
</li>
	<li>
<p>
%~observer~list 内の ~EACH( %~observer ) に対し：
◎
For each observer in observer list:
</p>
		<ol>
			<li>
%~root境界 ~LET %~observer の`~root交差~矩形$
◎
Let rootBounds be observer’s root intersection rectangle.
</li>
			<li>
<p>
%~observer.`ObservationTargets$sl 内の ~EACH( %target ) に対し：
<!-- observe(target) が~callされた順に -->
◎
For each target in observer’s internal [[ObservationTargets]] slot, processed in the same order that observe() was called on each target:
</p>

				<ol>
					<li>
~IF［
%~root は`暗黙的な~root$でない
］~AND［［
%target は %~root と同じ`文書$ 内にない
］~OR［
%target は %~root の`包含塊~連鎖$内の子孫ではない
］］
⇒
~CONTINUE
◎
If the intersection root is not the implicit root and target is not a descendant of the intersection root in the containing block chain, skip further processing for target.
◎
If the intersection root is not the implicit root, and target is not in the same Document as the intersection root, skip further processing for target.
</li>
					<li>
%~target矩形 ~LET 
%target 上で `getBoundingClientRect()$m ~algoを走らせた結果
<!-- の DOMRectReadOnly -->
◎
Let targetRect be a DOMRectReadOnly obtained by running the getBoundingClientRect() algorithm on target.
</li>
					<li>
%交差~矩形 ~LET %target 上で`交差域を算出-$した結果
◎
Let intersectionRect be the result of running the compute the intersection algorithm on target.
</li>
					<li>
%交差~比率 ~LET 0
◎
↓</li>
					<li>
<p>
~IF［
%~target矩形 と %~root境界 は交差する†
］
⇒
%交差~比率 ~SET ［
%~target矩形 の面積 ~EQ 0 ならば 1 ／
~ELSE_ ( %交差~矩形 の面積 ~DIV %~target矩形 の面積 )
］
</p>

<p>†
辺どうしが接する場合も含め，互いの区画が重なるならば、交差域の面積が~zero（ %~root境界 や %~target矩形 の面積が~zeroの場合など）であっても交差するとする。
</p>
◎
Let targetArea be targetRect’s area.
◎
Let intersectionArea be intersectionRect’s area.
◎
Let doesIntersect be true if targetRect and rootBounds intersect or are edge-adjacent, even if the intersection has zero area (because rootBounds or targetRect have zero area); otherwise, let doesIntersect be false.
◎
If targetArea is non-zero, let intersectionRatio be intersectionArea divided by targetArea. Otherwise, let intersectionRatio be 1 if doesIntersect is true, or 0 if doesIntersect is false.
</li>
					<li>
%~threshold~index ~LET 
%~observer の `thresholds$m %T 内に［
値 ~GT %交差~比率
］なる~entryが［
あれば それらのうち 最初の~entryの %T 内における~index ／
なければ %T の長さ
］
◎
Let thresholdIndex be the index of the first entry in observer.thresholds whose value is greater than intersectionRatio, or the length of observer.thresholds if intersectionRatio is greater than the last entry in observer.thresholds.
</li>
					<li>
%交差~observer登録 ~LET 
%target.`RegisteredIntersectionObservers$sl 内の［
`observer$rp ~prop ~EQ %~observer
］なる`交差~observer登録$
◎
Let intersectionObserverRegistration be the IntersectionObserverRegistration record in target’s internal [[RegisteredIntersectionObservers]] slot whose observer property is equal to observer.
</li>
					<li>
`以前の~threshold~index^V ~LET 
%交差~observer登録 の `previousThresholdIndex$rp ~prop
◎
Let previousThresholdIndex be the intersectionObserverRegistration’s previousThresholdIndex property.
</li>
					<li>
~IF［
%~threshold~index ~NEQ `以前の~threshold~index^V
］
⇒
次を与える下で、
%~observer に対する`~IntersectionObserverEntryを待入する$
⇒
%時刻,
%~root境界,
%~target矩形<!-- ＊boundingClientRect -->,
%交差~矩形,
%target
◎
If thresholdIndex does not equal previousThresholdIndex, queue an IntersectionObserverEntry, passing in observer, time, rootBounds, boundingClientRect, intersectionRect and target.
</li>
					<li>
%交差~observer登録 の `previousThresholdIndex$rp
~prop ~SET %~threshold~index
<!-- ＊原文誤り threshold -->
◎
Assign threshold to intersectionObserverRegistration’s previousThresholdIndex property.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>



			</section>
		</section>
		<section id="lifetime">
<h3 title="IntersectionObserver Lifetime">3.3. `IntersectionObserver^I の存続期間</h3>


<p>
`IntersectionObserver$I %O は、次の両~条件とも満たされない限り，生き残り続ける：
◎
An IntersectionObserver will remain alive until both of these conditions hold:
</p>

<ul>
	<li>
どの~scriptも %O を参照していない。
◎
There are no scripting references to the observer.
</li>
	<li>
%O が~observeしている~targetはない。
◎
The observer is not observing any targets.
</li>
</ul>

<p>
`IntersectionObserver$I %O
は、次のいずれかが生じるまで， `~target$ %target を~observeし続ける：
◎
An IntersectionObserver will continue observing a target until any of the following occurs:
</p>

<ul>
	<li>
%O 上で `unobserve(target)$m が~callされたとき。
◎
unobserve(target) is called on the target.
</li>
	<li>
%O 上で `disconnect()$m が~callされたとき。
◎
disconnect() is called.
</li>
	<li>
%target が~DOMから削除されたとき。
◎
The target Element is deleted.
</li>
	<li>
%O の`交差~root$が~DOMから削除されたとき。
◎
The observer’s intersection root is deleted.
</li>
</ul>


		</section>
		<section id="external-spec-integrations">
<h3 title="External Spec Integrations">3.4. 外部 仕様との統合</h3>


			<section id="event-loop">
<h4 title="HTML Processing Model: Event Loop">3.4.1. ~HTMLの~event-loop処理~model</h4>

<p>
`交差~observer$ 処理~段は、~HTMLに規定される`~event-loop処理~model$における，`描画を更新する^i 段の中で行われるべきである
— その
`~fullscreen描画~手続き$を走らす段と
`~animation~frame~callbackを走らす$段の合間に。
◎
An Intersection Observer processing step should take place during the "Update the rendering" steps, after step 9, run the fullscreen rendering steps, and before step 10, run the animation frame callbacks, in the in the HTML Processing Model.
</p>

<p class="trans-note">【
~HTML仕様（ WHATWG ）には、すでに統合されている
— その仕様では、実際には ~animation~frame~callbackを走らす段の次にされている。
】</p>

<p>
この段は、次で与えられる：
◎
This step is:
</p>

<ol>
	<li>
`文書たち^V 内の ~EACH( `全部的に作動中$にある`文書$ %文書 ) に対し
⇒
%文書 に対する`交差~observationsの更新~手続きを走らす$
<!-- ＊？
の木~内にある ~EACH( IntersectionObserver root ) に対し
 -->
◎
For each fully active Document in docs, Run the update intersection observations steps for each IntersectionObserver whose root is in the DOMtree of that Document.
</li>
</ol>

			</section>
		</section>
	</section>

</main></div><!-- MAIN -->


	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>

<dl>
	<dt>[CSS-SYNTAX-3]</dt>
	<dd>Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3.</dd>
	<dd>http://dev.w3.org/csswg/css-syntax/</dd>

	<dt>[CSS-VALUES-3]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 29 September 2016. CR.</dd>
	<dd>https://www.w3.org/TR/css-values-3/</dd>

	<dt>[CSS2]</dt>
	<dd>Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC.</dd>
	<dd>https://www.w3.org/TR/CSS2</dd>

	<dt>[CSSOM-VIEW-1]</dt>
	<dd>Simon Pieters. CSSOM View Module.</dd>
	<dd>https://drafts.csswg.org/cssom-view/</dd>

	<dt>[GEOMETRY-1]</dt>
	<dd>Simon Pieters; Dirk Schulze; Rik Cabanier. Geometry Interfaces Module Level 1.</dd>
	<dd>http://dev.w3.org/fxtf/geometry/</dd>

	<dt>[WebIDL]</dt>
	<dd>Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL.</dd>
	<dd>https://heycam.github.io/webidl/</dd>

	<dt>[WHATWG-DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>

</dl>

</section>
<!-- 
<h3 title="Informative References">文献（参考）</h3>
 -->
	</section>
	<section id="index">
<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>

	</section>
	<section id="idl-index">
<h2 title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>

	</section>
