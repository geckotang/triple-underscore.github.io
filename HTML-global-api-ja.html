<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Scripting（ 8.2. 〜 ）（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/webappapis.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160707 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		sc: 'scheme',
		jA: 'abstract',
		sl: 'js-slot',
		h: 'header',
		E: 'error',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		E: 'code',
		m: 'code',
		hd: 'code',
		c: 'code',
		s: 'samp',
		e: 'code',
		a: 'code',
		sc: 'code',
		et: 'code',
		h: 'code',
		jA: 'span',
		sl: 'span',
		V: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
//	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN', '_toc_list0');


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		if(match[1]){
			in_idl = true;
			nesting += '</pre>';
			return '<pre class="idl">';
		} else {
			nesting += '</span>';
			return '：<span class="block">';
		}
	case '⇒！':
	}//◎
	if(in_idl) {
		result = nesting;
		in_idl = false;
	} else {
		result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	}
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
//var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	if(in_idl) tag = '';
	break;
case 'm': // IDL member
case 'hd': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	if(in_idl) tag = '';
	break;
case 'sc': // url scheme
	text += ':';
	break;
case 'sl': // JS internal slot
	text = '[[' + text + ']]';
	break;
case 'et': // event type
	break;
case 'i': // model constants
	break;
case 'v': // variables
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">

</script>
<!--% リンク置換データ -->

<script type="text/plain" id="_link_map">
	●
I.Document:~HTMLDOM#document
I.Function:~WEBIDL#common-Function
I.Window:~BROWSERS#window
I.WindowProxy:~BROWSERS#windowproxy
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.WindowOrWorkerGlobalScope:#windoworworkerglobalscope
I.TimerHandler:#timerhandler

I.ImageBitmap:~HTML5/scripting.html#imagebitmap
I.ImageBitmapOptions:~HTML5/scripting.html#imagebitmapoptions
I.ImageBitmapSource:~HTML5/scripting.html#imagebitmapsource

E.InvalidCharacterError:~WEBIDL#invalidcharactererror

jA.HostEnsureCanCompileStrings:~WAPI#hostensurecancompilestrings(callerrealm,-calleerealm)


et.afterprint:~HTML5/indices.html#event-afterprint
et.beforeprint:~HTML5/indices.html#event-beforeprint

m.atob:#dom-atob
m.btoa:#dom-btoa

m.alert:#dom-alert
m.confirm:#dom-confirm
m.print:#dom-print

m.cancelAnimationFrame:#dom-window-cancelanimationframe

m.clearInterval:#dom-clearinterval
m.clearTimeout:#dom-cleartimeout
m.setInterval:#dom-setinterval
m.setTimeout:#dom-settimeout

m.origin:#dom-origin
m.self.origin:#dom-origin
m.prompt:#dom-prompt
m.requestAnimationFrame:#dom-window-requestanimationframe

m.createImageBitmap:~HTML5/scripting.html#dom-createimagebitmap


~ASCII英数字:~HTMLINFRA#alphanumeric-ascii-characters
空白類:~HTMLINFRA#space-character
並列的:~HTMLINFRA#in-parallel

~animation~frame~callback識別子:#animation-frame-callback-identifier

~promptを示すかどうか決定-:#_determine-to-show-modal-prompt

作動中の~timer~list:#list-of-active-timers
~animation~frame~callback~list:#list-of-animation-frame-callbacks
任意選択で短縮-:#optionally-truncate-a-simple-dialog-string
読込み時に印刷する~flag:#print-when-loaded
印刷-時の手続き:#printing-steps
~animation~frame~callbackたちを走らす:#run-the-animation-frame-callbacks
~timer初期化~手続き:#timer-initialisation-steps
~timerの入子~level:#timer-nesting-level
~timer~task源:#timer-task-source
~task~source:~WAPI#task-source
~task:~WAPI#concept-task
関連する設定群~obj:~WAPI#relevant-settings-object
一時停止-:~WAPI#pause
待入する:~WAPI#queue-a-task
~classic~scriptを走らす:~WAPI#run-a-classic-script
~classic~scriptを作成-:~WAPI#creating-a-classic-script
環境~設定群~obj:~WAPI#environment-settings-object
極小task:~WAPI#microtask
例外を報告する:~WAPI#report-the-exception
~event-loop:~WAPI#event-loop
単純~eventを発火-:~WAPI#fire-a-simple-event

閲覧文脈:~BROWSERS#browsing-context
作動中の~sandbox用~flag集合:~BROWSERS#active-sandboxing-flag-set
結付けられている文書:~BROWSERS#concept-document-window
結付けている~window:~BROWSERS#concept-document-window
属する閲覧文脈:~BROWSERS#concept-document-bc
	属する~閲覧文脈:~BROWSERS#concept-document-window
全部的に作動中:~BROWSERS#fully-active
入子の閲覧文脈:~BROWSERS#nested-browsing-context
子孫~閲覧文脈~list:~BROWSERS#list-of-the-descendant-browsing-contexts
作動中の文書:~BROWSERS#active-document

~sandbox化( ~modal )~flag:~BROWSERS#sandboxed-modals-flag
生成元:~BROWSERS#concept-origin
~Unicode直列化-:~BROWSERS#unicode-serialisation-of-an-origin

~media~data:~HTML5/embedded-content.html#media-data
~media要素:~HTML5/embedded-content.html#media-element

物理形を得る:~HTML-RENDER#obtain-a-physical-form

	27864:https://www.w3.org/Bugs/Public/show_bug.cgi?id=27864
js.現在の~Realm~Record:~ES6#current-realm
js.~JS~realm:~ES6#sec-code-realms
x.呼出す:~WEBIDL#es-invoking-callback-functions
x.~callback this 値:~WEBIDL#dfn-callback-this-value


終了の入子~level:~HTML5/browsers.html#termination-nesting-level
読込み後~taskは準備済み:~HTML5/syntax.html#ready-for-post-load-tasks

</script>


<!--% 置換データ -->
<script type="text/plain" id="words_table1">
ES6:https://tc39.github.io/ecma262/
HTML-RENDER:HTML-rendering-ja.html
</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">

此れ:<b>これ°</b>

	CPU
	More
URL:
Web:::


	●JS／event／IDL／task／script／大域
window:
IDL:::
JS:JavaScript
Realm:
Record:

event::::イベント
event-loop:event loop:::イベントループ
task::::タスク
極小task:microtask:::極小タスク
call::::
callback::::
entry::::エントリ
mixin:
script::::スクリプト
obj:object:::オブジェクト
realm:
worker::::
code::::コード
classic:::::クラシック
compile::::コンパイル
method::::メソッド

取得子:getter:~
呼出:invocation:呼出し
呼出ing:invoking:呼出し
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
呼出す:invoke する:呼び出す
設定-:set:~
設定群:settings:~
投出:throw:~
発火-:fire:~
被呼出時:被 invoke 時:~
走らす:run する:~
走中の:running:走っている
遂行-:perform:~
完了-:complete:~
実行-:execute:~
報告-:report::~
閲覧文脈:browsing context::~
源:source::~::ソース
並列的:parallel:~
例外:exception:~
大域:global::~::グローバル
引数:argument:~
現在の:current:~
現在:currently:~
環境:environment:~
関数:function:~
関連する:relevant な:~
文脈:context:~
停滞-:stall:~
準備済み:ready:~
一時停止-:pause::~::ポーズ
中止-:abort:~
待入する:queue する::待ち行列に入れる::キューする
待機-:wait:~

	●btoa
Unicode:::
base64:
binary::::バイナリ
bit::::ビット
byte::::バイト
octet::::オクテット
data::::データ
復号-:decode:~
文字:character:~
文字列:string:~
出力:output:~
入力:input:~
空:empty:~
符号位置:code-point:~
符号化-:encode:~
符号化方式:encoding:~
変換-:convert:~
変換:conversion:~
変形-:transform:変換
範囲:range:~
	範囲~外:out-of-range
妥当:valid:~
空白類:space characters:~
ASCII:
英数字:alphanumerics:~
	語呂的には:mnemonic purposess

	●prompt／印刷
PDF:::
alert:
prompt:
	Cancel
	Click
	OK
modal::::モダール
message::::メッセージ
阻止-:block::~::ブロック
control::::コントロール
dialog::::ダイアログ
訊ねる:ask する:~
退ける:dismiss する:~
sandbox::::サンドボックス
click:::::クリック
clear::::
選択肢:option:~
	肯定か否定:positive／negative／negatively／positively
任意選択:option:~
kiosk:
短縮-:truncate:~
省かれ:elide され:~
黙って:silent に:~
保存:save:~
	何段階かにわたる手続きを踏むthrough the steps of applying for a home loan

印刷:print::~::プリント
印刷-:print::~::プリント
印刷ing:printing::印刷::プリント
印刷機:printer::~::プリンタ
取消す:cancel する::取り消す::キャンセルする
取消した:cancel した::取り消した::キャンセルした
機会:opportunity:~
機器:device:~
復帰-:revert:~
応答-:respond:~
応答:response:~
手入力-:enter:~
注釈-:annotate:~
注釈:annotation:~

	進める:advance
	部位:portion:~
物理形:physical form:~
	-:earlier
辞退-:decline:~



	●timer/animation
animation::::アニメーション
schedule::::スケジュール
time::::
timeout::::タイムアウト
timer::::タイマー
interval:
時刻印:timestamp::~::タイムスタンプ
milli::::ミリ
	milli秒:millisecond
	過ぎる:pass:~
	開始-:start:~
前回handle:previous handle:前回の handle
節電:low-power:~
電力消費:power usage:~
mode::::モード
入子:nesting:入れ子
入子に:nest:入れ子に
入子の:nested:入れ子の
負荷:load:~
	~UIに応じる余裕を与える:yielding back to avoid starving the user interface
	時間を得る:hogging
	強制終了:kill
遅延:delay:~
休止-:suspend:~
連続的:consecutively:~
識別子:identifier:~

	時間:length of time.
	~~延長 pad
	時点を過ぎて~pointを~past
	なることはない not 〜 one way or the other
	存続する限り:lifetime
繰返:repeat::繰返
繰返しの:repeating::繰返し続ける
	遅める＊ slow down
	間断なくback to back
	予め~schedule:preschedule
予期-:expect:~


	●仕様
API:
algo:algorithm:::アルゴリズム
UA:user agent:UA
UI:::
下位手続き:substeps:~
不自然:unnatural:~
理由:reason:~
仕方:way:~
作者:author:~
依存-:depend:~
依拠-:rely:~
	依拠し得る:reliable:~
	依然として:still:~
保証:guarantee:~
仕事:work:~
	利用-:use:~
利用者:user:~
制限-:limit:~
受容-:accept:~
問題0:matter:問題
奨励-:encourage:~
定義-:define:~
実施:practice:~
実装-:implement:~
容易:easy:~
強く:strong に:~
強制-:force:~
	必然:necessarily:~
	必要-:need:~
所与の:given:与えられた
手続き:steps:~
技術的:technical:~
抑える:reduce する:~
拡張-:extend:~
提供0-:offer:提供
既定の:default:~
	defaulted:~
標準の:standard:~
最適化-:optimise:~
正確0:accurate:正確
正確:exact:~
歴史的:historical:~
段:step:~
導出-:derive:~
有用:useful:~
濫用-:abuse:~
特定0の:particular:ある特定の
粒度:granularity:~
結付けら:associate さ:結び付けら
結付けた:associate した:結び付けた
結付けて:associate して:結び付けて
能力:capabilities:~
自動的:automatic:~
詳細:details:~
適切:appropriate:~
適用-:apply:~
避ける:avoid する:~
重要:important:~
開発者:developer:~
	考える:Imagine
	主に:primarily
	ある-:contain:~
	~~可能性:potential
	具体例として:for instance
	ばかげた:rather silly

	●未分類（動詞

初期化:initialisation:~
決定-:determine:~
処理-:process:~
初期:initial:~
参照-:reference:~
反復:iteration:~
付加-:append:~
作成-:create:~
公開-:expose:~
存在:existence:~
	認める:acknowledge:~
指示子:indicator:~
挿入:insertion:~
提供-:provide:~
改変:modification:~
検知-:detect:~
直列化-:serialise::~::シリアライズ
無視-:ignore:~
終了:termination:~
組合せ:combination:~
	継続-:continue:~
置換-:replace:~
表現-:represent:~
表現:representation:~
表示-:display:~
読込み:load:読み込み
	読込み後:post-load:~
読込んで:load:読み込んで
識別-:identify:~
追加-:add:~
除去-:remove:~

	●未分類
browser::::ブラウザ
flag::::フラグ
form::::フォーム
frame::::フレーム
level::::レベル
list::::リスト
logic::::ロジック
markup::::マークアップ
media::::メディア
mobile:::携帯
platform::::プラットフォーム
processor::::プロセッサ
proxy::::プロキシ
security::::セキュリティ
source::::ソース
system::::システム
text::::テキスト
zero::::ゼロ

生成元:origin::~::オリジン
要素:element:~
集合:set:~
子孫:descendant:~
一意:unique:~
値:value:~
全部的:full:~
内容:content:~
	再度:again:~
動的:dynamic:~
単純:simple:~
名:name:~
名前:name:~
安全:safe:~
属性:attribute:~
	後:after:~
整数:integer:~
文書:document:~
作動中の:active な::~::アクティブな
作動中:active::~::アクティブ

状態:state:~

画像:image:~

複製:copy:~
長さ:length:~
頁:page:::ページ

	order
	2 個目:second:~
	3 個目の:third:~
	4:four:~
	now:
	setting:設定
	~consisting
	~indeed
	~lot
	~part:
	~past:#1
	~point:#2
	~potential:#1
	~ready:#2
	~shorter:#1
	~u:#1
	~walking:#1
	〜の代わりに:instead:~
	いくつかの:several:~
	この:this:~
	これらの:these:~
	すべての:all:~
	その:that:~
	そのような:such:~
	それらの:their:~
	べき:should:~
	もっともらしい:trustworthy-looking:#1
	一つ:one:~
	与-:give:~
	両者:both:~
	中略して:replace the middle of
	二つ:two:~
	他の:other:~
	以降の:subsequent:~
	前:before:~
	前者:former:~
	各:each:~
	同じ:same:~
	在る:present:~
	対応-:correspond:~
	対応ing:corresponding:~
	巨大:large:~
	後続-／従う:follow:~
	後者:latter:~
	戻-:back:~
	数:number:~
	更なる:further:~
	最初の:first:~
	次回の:next:~
	求め:want:~
	渡-:pass:~
	用の便利:utility::::
	示す:show:~
	種:type:~
	終端:end:~
	結果:result:~
	自身:itself:~
	見なせ:consider:~
	起こる:happen:~
	近くに:in the vicinity
	返す:return:~
	通:through:~


</script>

<!--%style -->
<style type="text/css">

.js-slot {
	color: green;
}

.arg-list {
	display: block;
	padding-left: 2em;
	white-space: pre-line;
}
</style>


</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Standard — Scripting （ 8.2. 〜 8.9. ）日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Web application APIs</a>
の一部である
<cite>Scripting （ 8.2. 〜 8.9. 節）</cite>
を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-07-23</time>
（公開：<time>2016-07-23</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">

	<hgroup>
<h1>Scripting （ 8.2. 〜 ）</h1>
<h2>HTML Living Standard — 最終更新 2016 年 7 月 22 日</h2>
	</hgroup>

</header>


<nav class="toc" id="toc">
<h2>目次</h2>
<ol id="_toc_list0"></ol></nav>


<hr>

<main id="MAIN" style="display:none;">

		<section id="windoworworkerglobalscope-mixin">
<h3 title="The WindowOrWorkerGlobalScope mixin">8.2. `WindowOrWorkerGlobalScope^I ~mixin</h3>

<p>
`WindowOrWorkerGlobalScope$I ~mixinは、
`Window$I, `WorkerGlobalScope$I
両~obj上に公開されることになる~APIを利用するためにある。
◎
The WindowOrWorkerGlobalScope mixin is for use of APIs that are to be exposed on Window and WorkerGlobalScope objects.
</p>


<p class="note">
他の標準は、
<code>partial interface `WindowOrWorkerGlobalScope$I { … };</code>
を利用して，適切な参照-とともに更に拡張することが奨励される。
◎
Other standards are encouraged to further extend it using partial interface WindowOrWorkerGlobalScope { … }; along with an appropriate reference.
</p>

<pre class="idl">
typedef (DOMString or `Function$I) `TimerHandler@I;

[NoInterfaceObject, Exposed=(Window,Worker)]
interface `WindowOrWorkerGlobalScope@I {
  [Replaceable] readonly attribute USVString `origin$m;

  // base64 utility methods
  DOMString `btoa$m(DOMString %data);
  DOMString `atob$m(DOMString %data);

  // timers
  long `setTimeout$m(
      `TimerHandler$I %handler,
      optional long %timeout = 0,
      any... %arguments
  );
  void `clearTimeout$m(optional long %handle = 0);
  long `setInterval$m(
      `TimerHandler$I %handler,
      optional long %timeout = 0,
      any... %arguments
  );
  void `clearInterval$m(optional long %handle = 0);

  // ImageBitmap
  Promise&lt;`ImageBitmap$I&gt; `createImageBitmap$m(
      `ImageBitmapSource$I %image,
      optional `ImageBitmapOptions$I %options
  );
  Promise&lt;`ImageBitmap$I&gt; `createImageBitmap$m(
      `ImageBitmapSource$I %image,
      long %sx, long %sy, long %sw, long %sh,
      optional `ImageBitmapOptions$I %options
  );
};
`Window$I implements `WindowOrWorkerGlobalScope$I;
`WorkerGlobalScope$I implements `WindowOrWorkerGlobalScope$I;
</pre>

<dl class="domintro">
	<dt>%origin = self . `origin$m</dt>
	<dd>
当の大域~objの`生成元$を文字列に直列化した結果を返す。
◎
Returns the global object's origin, serialised as string.
</dd>
</dl>


<div class="example">
<p>
開発者には `location.origin^m より `self.origin$m を利用することが強く奨励される。
`self.origin^m は 環境の`生成元$を返す一方で、前者は 環境の~URLのそれを返す。
`https://stargate.example/^c 上の文書~内にて実行している次の~scriptを考える：
◎
Developers are strongly encouraged to use self.origin over location.origin. The former returns the origin of the environment, the latter of the URL of the environment. Imagine the following script executing in a document on https://stargate.example/:
</p>

<pre>
var %frame = document.createElement("iframe")
%frame.onload = function() {
  var %frameWin = %frame.contentWindow
  console.log(%frameWin.location.origin) // "null"
  console.log(%frameWin.origin) // "https://stargate.example"
}
document.body.appendChild(%frame)
</pre>


<p>
`self.origin$m は、より依拠し得る~security指示子である。
◎
self.origin is a more reliable security indicator.
</p>

</div>

<p>
`origin@m
属性の取得子は、此れに`関連する設定群~obj$の`生成元$を`~Unicode直列化-$した結果を返さ~MUST。
◎
The origin attribute's getter must return this object's relevant setting object's origin, serialised.
</p>


		</section>
		<section id="atob">
<h3 title="Base64 utility methods">8.3. ~base64用の便利~method</h3>

<p>
`atob()$m ／ `btoa()$m
~methodにより、内容~dataと~base64符号化方式との間で相互に変形できるようになる。
◎
The atob() and btoa() methods allow developers to transform content to and from the base64 encoding.
</p>


<p class="note">
これらの~method名は、語呂的には "b" は "binary", "a" は "ASCII" を表すと見なせるが、主に歴史的~理由から，実施においては入力, 出力のいずれも ~Unicode文字列である。
◎
In these APIs, for mnemonic purposes, the "b" can be considered to stand for "binary", and the "a" for "ASCII". In practice, though, for primarily historical reasons, both the input and output of these functions are Unicode strings.
</p>

<dl class="domintro">
	<dt>%result = self . `btoa( data )$m</dt>
	<dd>
［
各 文字が，範囲 { 0x00 〜 0xFF } の同じ値をとる~binary~byteを表現している
］ような，~Unicode文字列の形をとる［
範囲 { U+0000 〜 U+00FF } の文字のみからなる入力~data
］を，その~base64表現に変換した結果を返す。
◎
Takes the input data, in the form of a Unicode string containing only characters in the range U+0000 to U+00FF, each representing a binary byte with values 0x00 to 0xFF respectively, and converts it to its base64 representation, which it returns.
</dd>
	<dd>
入力~文字列~内に範囲~外の文字がある場合、
`InvalidCharacterError$E 例外が投出される。
◎
Throws an "InvalidCharacterError" DOMException exception if the input string contains any out-of-range characters.
</dd>

	<dt>%result = self . `atob( data )$m</dt>
	<dd>
~Unicode文字列の形をとる［
~base64に符号化された ~binary~data
］を包含する入力を，［
範囲 { U+0000 〜 U+00FF } の文字のみからなる~Unicode文字列
］に復号した結果を返す
— 各 文字が範囲 { 0x00 〜 0xFF } の同じ値をとる~binary~byteを表現しているような。
◎
Takes the input data, in the form of a Unicode string containing base64-encoded binary data, decodes it, and returns a string consisting of characters in the range U+0000 to U+00FF, each representing a binary byte with values 0x00 to 0xFF respectively, corresponding to that binary data.
</dd>
	<dd>
入力~文字列が妥当な~base64~dataでない場合、
`InvalidCharacterError$E 例外が投出される。
◎
Throws an "InvalidCharacterError" DOMException if the input string is not valid base64 data.
</dd>
</dl>

<div>
<p>
`btoa(data)@m
~methodの被呼出時には、次を走らせ~MUST：
</p>

<ol>
	<li>
~IF［
%data 内に［
符号位置 ~GT U+00FF
］なる文字がある
］
⇒
~THROW `InvalidCharacterError$E
</li>
	<li>
~RET ［
%data 内の各 文字を その符号位置を値とする 8 ~bit表現に変換して得られる~octet列
］に， `RFC4648$r による~base64~algoを適用した結果
</li>
</ol>

◎
The btoa(data) method must throw an "InvalidCharacterError" DOMException if data contains any character whose code point is greater than U+00FF. Otherwise, the user agent must convert data to a sequence of octets whose nth octet is the eight-bit representation of the code point of the nth character of data, and then must apply the base64 algorithm to that sequence of octets, and return the result. [RFC4648]
</div>

<p>
`atob(data)@m
~methodの被呼出時には、次を走らせ~MUST：
◎
The atob(data) method, when invoked, must run the following steps:
</p>

<ol>
	<li>
%data からすべての`空白類$を除去する
◎
Let position be a pointer into data, initially pointing at the start of the string.
◎
Remove all space characters from data.
</li>
	<li>
~IF［
%data の長さは 4 の倍数である
］
⇒
次を 2 回 繰り返す
⇒
~IF［
%data の最後の文字 ~EQ U+003D EQUALS SIGN (=)
］
⇒
%data から最後の文字を除去する
◎
If the length of data divides by 4 leaving no remainder, then: if data ends with one or two U+003D EQUALS SIGN (=) characters, remove them from data.
</li>
	<li>
%不足個数 ~LET 
( %data の長さを 4 の倍数に切り上げた結果 ) − %data の長さ
</li>
	<li>
~IF［
%不足個数 ~EQ 3
］
⇒
~THROW `InvalidCharacterError$E
◎
If the length of data divides by 4 leaving a remainder of 1, throw an "InvalidCharacterError" DOMException and abort these steps.
</li>
	<li>
<p>
~IF［
%data は次に挙げるもの以外の文字を包含する
］
⇒
~THROW `InvalidCharacterError$E
◎
If data contains a character that is not in the following list of characters and character ranges, throw an "InvalidCharacterError" DOMException and abort these steps:
</p>

<ul class="brief"><li>U+002B PLUS SIGN (+)
</li><li>U+002F SOLIDUS (/)
</li><li>`~ASCII英数字$
</li></ul>

	</li>
	<li>
%出力 ~LET 空~文字列
◎
Let output be a string, initially empty.
</li>
	<li>
( %buffer, %shift ) ~LET (0, ( 2 の 24 乗 ) )
◎
Let buffer be a buffer that can have bits appended to it, initially empty.
</li>
	<li>
%data の末尾に %不足個数 個の `A^l を付加する
</li>
	<li>
<p>
~FOR %data 内の ~EACH ( 文字 %char ) に対し，先頭から順に：
◎
While position does not point past the end of data, run these substeps:
</p>
		<ol>
			<li>
<p>
%n ~LET %char に応じて，次の表で与えられる %数
— 表~内の “CP( %x )” は %x の符号位置を表す数とする：
◎
Find the character pointed to by position in the first column of the following table. Let n be the number given in the second cell of the same row.
</p>

<div >
<table id="base64-table"><thead><tr><th>%char
</th><th>%数
</th></tr></thead>

<tbody><tr><td>`A^l 〜 `Z^l
</td><td>CP( %char ) − CP( `A^l )

</td></tr><tr><td>`a^l 〜 `z^l
</td><td>CP( %char ) − CP( `a^l ) + 26

</td></tr><tr><td>`0^l 〜 `9^l
</td><td>CP( %char ) − CP( `0^l ) + 52

</td></tr><tr><td>`+^l
</td><td>62

</td></tr><tr><td>`/^l
</td><td>63

</td></tr></tbody></table>

◎
Character 	Number
• A	0
• B	1
• C	2
• D	3
• E	4
• F	5
• G	6
• H	7
• I	8
• J	9
• K	10
• L	11
• M	12
• N	13
• O	14
• P	15
• Q	16
• R	17
• S	18
• T	19
• U	20
• V	21
• W	22
• X	23
• Y	24
• Z	25
• a	26
• b	27
• c	28
• d	29
• e	30
• f	31
• g	32
• h	33
• i	34
• j	35
• k	36
• l	37
• m	38
• n	39
• o	40
• p	41
• q	42
• r	43
• s	44
• t	45
• u	46
• v	47
• w	48
• x	49
• y	50
• z	51
• 0	52
• 1	53
• 2	54
• 3	55
• 4	56
• 5	57
• 6	58
• 7	59
• 8	60
• 9	61
• +	62
• /	63
</div>

	</li>
	<li>
%shift ~SET %shift ÷ ( 2 の 6 乗 )
</li>
	<li>
%buffer ~INCBY %shift × %n
◎
Append to buffer the six bits corresponding to number, most significant bit first.
</li>
	<li>
<p>
~IF［
%shift ~EQ 1
］：
</p>
		<ol>
			<li>
%shift ~SET ( 2 の 24 乗 )
</li>
			<li>
<p>
~WHILE ( %shift ~NEQ 1 )：
</p>
				<ol>
					<li>
%shift ~SET %shift ÷ ( 2 の 8 乗 )
</li>
					<li>
%octet ~LET %buffer ÷ %shift
（小数は切り捨てる）
</li>
					<li>
%出力 に［
%octet を値とする符号位置に対応する文字
］を付加する
</li>
					<li>
%buffer ~DECBY %octet × %shift
</li>
				</ol>
			</li>
			<li>
( %buffer, %shift ) ~SET (0, ( 2 の 24 乗 ) )
</li>
		</ol>

◎
If buffer has accumulated 24 bits, interpret them as three 8-bit big-endian numbers. Append the three characters with code points equal to those numbers to output, in the same order, and then empty buffer.
◎
Advance position by one character.
</li>
		</ol>
	</li>
	<li>
<p>
%出力 の末尾から %不足個数 個の文字を除去する
◎
If buffer is not empty, it contains either 12 or 18 bits. If it contains 12 bits, discard the last four and interpret the remaining eight as an 8-bit big-endian number. If it contains 18 bits, discard the last two and interpret the remaining 16 as two 8-bit big-endian numbers. Append the one or two characters with code points equal to those one or two numbers to output, in the same order.
</p>

<p class="note">
入力 %data は 1 文字あたり 6 ~bit, %出力 は 1 文字あたり 8 ~bit の~dataを表現するので、( %不足個数 × 2 ) 個の~bitが，入力の末尾から切り捨てられることになる。
例えば 2 つの入力
`YQ^l （ 6 ~bit表現 24, 16 ）, `YR^l （ 6 ~bit表現 24, 17 ）
に対する `atob()^m の結果はいずれも `a^l になる。
◎
The discarded bits mean that, for instance, atob("YQ") and atob("YR") both return "a".
</p>

   </li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

		</section>
		<section id="dynamic-markup-insertion">
<h3 title="Dynamic markup insertion">8.4. 動的~markup挿入</h3>

<p class="trans-note">【
この節の和訳は、当面の間 省略する
】</p>

		</section>
		<section id="timers">
<h3 title="Timers">8.5. ~timer</h3>

  
<p>
`setTimeout()$m ／
`setInterval()$m
~methodにより、作者は，~timerに基づく~callbackを~scheduleできるようになる。
◎
The setTimeout() and setInterval() methods allow authors to schedule timer-based callbacks.
</p>

<dl class="domintro">
	<dt>%handle = self . `setTimeout( handler [, timeout [, arguments... ] ] )$m</dt>
	<dd>
%timeout ~milli秒~後に
%handler を走らす~timeoutを~scheduleする。
%arguments は そのまま %handler に渡される。
◎
Schedules a timeout to run handler after timeout milliseconds. Any arguments are passed straight through to the handler.
</dd>

	<dt>%handle = self . `setTimeout( code [, timeout ] )$m</dt>
	<dd>
%timeout ~milli秒~後に
%code を~compileして走らす~timeoutを~scheduleする
◎
Schedules a timeout to compile and run code after timeout milliseconds.
</dd>
	<dt>self . `clearTimeout( handle )$m</dt>
	<dd>
［
`setTimeout()$m ／ `setInterval()$m
により設定された~timeout
］のうち， %handle で識別されるものを取消す。
◎
Cancels the timeout set with setTimeout() or setInterval() identified by handle.
</dd>

	<dt>%handle = self . `setInterval( handler [, timeout [, arguments... ] ] )$m</dt>
	<dd>
%timeout ~milli秒ごとに
%handler を走らす~timeoutを~scheduleする。
%arguments は そのまま %handler に渡される。
◎
Schedules a timeout to run handler every timeout milliseconds. Any arguments are passed straight through to the handler.
</dd>

	<dt>%handle = self . `setInterval( code [, timeout ] )$m</dt>
	<dd>
%timeout ~milli秒ごとに
%code を~compileしてを走らす~timeoutを~scheduleする。
◎
Schedules a timeout to compile and run code every timeout milliseconds.
</dd>

	<dt>self . `clearInterval( handle )$m</dt>
	<dd>
［
`setTimeout()$m ／ `setInterval()$m
により設定された~timeout
］のうち， %handle で識別されるものを取消す。
◎
Cancels the timeout set with setInterval() or setTimeout() identified by handle.
</dd>
</dl>

<p class="note">
~timerは、入子にできる。
ただし、そのような入子にされた~timerが 5 個を超えて以降は，~intervalは、 4 ~milli秒~以上に強制される。
◎
Timers can be nested; after five such nested timers, however, the interval is forced to be at least four milliseconds.
</p>

<p class="note">
この~APIは、~timerが正確に~schedule通りに走らすことは保証しない。
CPU 負荷, 他の~task, 等々に因る遅延が予期される。
◎
This API does not guarantee that timers will run exactly on schedule. Delays due to CPU load, other tasks, etc, are to be expected.
</p>

<p>
`WindowOrWorkerGlobalScope$I
~mixinを実装する~objは、
`作動中の~timer~list@
を持つ。
この~list内の各~entryは、
数で識別される。
それらの数は、~objが存続する限り，~listの中で一意で~MUST。
◎
Objects that implement the WindowOrWorkerGlobalScope mixin have a list of active timers. Each entry in this lists is identified by a number, which must be unique within the list for the lifetime of the object that implements the WindowOrWorkerGlobalScope mixin.
</p>

<hr>

<div>
<p>
`setTimeout()@m
~methodの被呼出時には、次を渡した下で
`~timer初期化~手続き$から返される値を返さ~MUST：
</p>

<ul ><li>%~method引数~list ~SET ~methodに渡された引数~list
</li><li>%~method文脈 ~SET 此れ
</li><li>%繰返~flag ~SET ~OFF
</li></ul>
◎
The setTimeout() method must return the value returned by the timer initialisation steps, passing them the method's arguments, the object on which the method for which the algorithm is running is implemented (a Window or WorkerGlobalScope object) as the method context, and the repeat flag set to false.
</div>


<div>
<p>
`setInterval()@m
~methodの被呼出時には、次を渡した下で，`~timer初期化~手続き$から返される値を返さ~MUST：
</p>

<ul ><li>%~method引数~list ~SET ~methodに渡された引数~list
</li><li>%~method文脈 ~SET 此れ
</li><li>%繰返~flag ~SET ~ON
</li></ul>
◎
The setInterval() method must return the value returned by the timer initialisation steps, passing them the method's arguments, the object on which the method for which the algorithm is running is implemented (a Window or WorkerGlobalScope object) as the method context, and the repeat flag set to true.
</div>


<p>
`clearTimeout(handle)@m
／
`clearInterval(handle)@m
~methodの被呼出時には、此れの`作動中の~timer~list$内に
%handle により識別される~entryがあれば、それを~clearし~MUST
（なければ何もしない）。
◎
The clearTimeout() and clearInterval() methods must clear the entry identified as handle from the list of active timers of the WindowOrWorkerGlobalScope object on which the method was invoked, if any, where handle is the argument passed to the method. (If handle does not identify an entry in the list of active timers of the WindowOrWorkerGlobalScope object on which the method was invoked, the method does nothing.)
</p>

<p class="note">
`clearTimeout()$m, `clearInterval()$m
のいずれも，同じ~listに属する~entryを~clearするので、両~methodとも
`setTimeout()$m ／ `setInterval()$m
で作成された~timerを~clearするのに利用できる。
◎
Because clearTimeout() and clearInterval() clear entries from the same list, either method can be used to clear timers created by setTimeout() or setInterval().
</p>

<hr>


<div >
<p>
`~timer初期化~手続き@
は、所与の：
</p>

<ul ><li>%~method引数~list
</li><li>%~method文脈
</li><li>%繰返~flag
</li><li>%前回handle（省略可，%繰返~flag ~EQ ~ON の場合のみ与え得る）
</li></ul>

<p>
に対し，次を走らす：
</p>
◎
The timer initialisation steps, which are invoked with some method arguments, a method context, a repeat flag which can be true or false, and optionally (and only if the repeat flag is true) a previous handle, are as follows:
</div>

<ol>
	<li>
%~method文脈~proxy ~LET ［
%~method文脈 は `WorkerGlobalScope$I ~objならば %~method文脈 ／
~ELSE_ %~method文脈 に`結付けられている文書$が`属する閲覧文脈$の `WindowProxy$I
］
◎
Let method context proxy be method context if that is a WorkerGlobalScope object, or else the WindowProxy that corresponds to method context.
</li>
	<li>
%handle ~LET %前回handle
</li>
	<li>
~IF［
%handle ~NEQ ε
］
⇒
%handle ~SET
~UA により定義される非負~整数であって，この~callにより`作動中の~timer~list$に設定される~timeoutを識別するもの
◎
If previous handle was provided, let handle be previous handle; otherwise, let handle be a user-agent-defined integer that is greater than zero that will identify the timeout to be set by this call in the list of active timers.
</li>
	<li>
~IF［
%前回handle ~EQ ε
］
⇒
%handle に対する~entryを
`作動中の~timer~list$に追加する
◎
If previous handle was not provided, add an entry to the list of active timers for handle.
</li>
	<li>
( %callerRealm, %calleeRealm ) ~LET
( `現在の~Realm~Record$js, %~method文脈 の`~JS~realm$js )
◎
Let callerRealm be the current Realm Record, and calleeRealm be method context's JavaScript realm.
</li>

	<li>
<p>
%~task ~LET 次の下位手続きを走らす`~task$：
◎
Let task be a task that runs the following substeps:
</p>
		<ol>
			<li>
~IF［
`作動中の~timer~list$内に
%handle に対応する~entryはない
］
⇒
~RET
◎
If the entry for handle in the list of active timers has been cleared, then abort this task's substeps.
</li>
			<li>
%S ~LET %~method引数~list の最初の引数
</li>
			<li>
~IF［
%S は `Function$I である
］
⇒
次を与える下で %S を`呼出す$x
⇒
引数~list： 3 個目~以降の引数（空にもなり得る）<br>
`~callback this 値$x： %~method文脈~proxy
◎
Run the appropriate set of steps from the following list:
◎
Invoke the Function. Use the third and subsequent method arguments (if any) as the arguments for invoking the Function. Use method context proxy as the callback this value.
</li>
			<li>
<p>
~ELSE
⇒
</p>
				<ol>
					<li>
`HostEnsureCanCompileStrings$jA( %callerRealm, %calleeRealm )
を遂行する
⇒
例外が投出された場合は、その`例外を報告する$；<br>
~RET `この ~RET は訳者による推定^tnote
◎
Perform HostEnsureCanCompileStrings(callerRealm, calleeRealm). If this throws an exception, report the exception.
</li>
					<li>
%~script ~LET
次を与える下で `~classic~scriptを作成-$した結果
⇒
( %S, %~method文脈 の`環境~設定群~obj$ )
◎
Let script source be the first method argument.
◎
Let settings object be method context's environment settings object.
◎
Let script be the result of creating a classic script using script source and settings object.
</li>
					<li>
%~script を与える下で`~classic~scriptを走らす$
◎
Run the classic script script.
</li>
				</ol>
			</li>
			<li>
~IF［
%繰返~flag ~EQ ~ON
］
⇒
次を与える下で，`~timer初期化~手続き$を再度~callする
⇒
%~method引数~list ~SET %~method引数~list,<br />
%~method文脈 ~SET %~method文脈,<br />
%繰返~flag ~SET ~ON,<br />
%前回handle ~SET %handle<!-- ＊handler 誤記 -->
◎
If the repeat flag is true, then call timer initialisation steps again, passing them the same method arguments, the same method context, with the repeat flag still set to true, and with the previous handle set to handler.
</li>

		</ol>
	</li>
	<li>
%timeout ~LET  %~method引数~list の 2 個目の引数
◎
Let timeout be the second method argument.
</li>
	<li>
<p>
%入子~level ~LET［
現在~走中の`~task$は，この~algoにより作成された`~task$ならば
その~taskの`~timerの入子~level$ ／
~ELSE_ ~zero
］
◎
If the currently running task is a task that was created by this algorithm, then let nesting level be the task's timer nesting level. Otherwise, let nesting level be zero.
</p>

<p class="note">
~taskの`~timerの入子~level$は、［
`setTimeout()$m に対する入子の~call，
`setInterval()$m により作成される繰返しの~timer
］のいずれに対しても利用される（この 2 つが混在する入子もあり得る）。
言い換えれば、特定0の~methodではなく，この~algoの入子の呼出を表現する。
◎
The task's timer nesting level is used both for nested calls to setTimeout(), and for the repeating timers created by setInterval(). (Or, indeed, for any combination of the two.) In other words, it represents nested invocations of this algorithm, not of a particular method.
</p>
   </li>
	<li>
~IF［
%入子~level ~GT 5
］~AND［
%timeout ~LT 4
］
⇒
%timeout ~SET 4
◎
If nesting level is greater than 5, and timeout is less than 4, then increase timeout to 4.
</li>
	<li>
%入子~level ~INCBY 1
◎
Increment nesting level by one.
</li>
	<li>
%~task の`~timerの入子~level@
~LET %入子~level
◎
Let task's timer nesting level be nesting level.
</li>
	<li>
~RET %handle
— ただし、この~algoの以降の部分も`並列的$に走らせる
◎
Return handle, and then continue running this algorithm in parallel.
</li>
	<li>
<p>
%~method文脈 に応じて：
</p>
		<dl class="switch">
			<dt>`Window$I ~objである場合：</dt>
			<dd>
%~method文脈 に`結付けられている文書$が`全部的に作動中$になるまで
更に %timeout ~milli秒~待機する（連続的でなくともよい `？^tnote ）。
</dd>

			<dt>`WorkerGlobalScope$I ~objである場合：</dt>
			<dd>
~workerを休止せずに %timeout ~milli秒~待機する（連続的でなくともよい）。
</dd>
		</dl>

◎
If method context is a Window object, wait until the Document associated with method context has been fully active for a further timeout milliseconds (not necessarily consecutively).
◎
Otherwise, method context is a WorkerGlobalScope object; wait until timeout milliseconds have passed with the worker not suspended (not necessarily consecutively).
</li>
	<li>
<div class="p">
<p>
この~algoのこの呼出 %A とは別のこの~algoの呼出 %B たちのうち，次をすべて満たすものがあれば，それらが完了するまで待機する：
</p>

<ul ><li>%B は完了していない
</li><li>( %B における %~method文脈 ) ~EQ ( %A における %~method文脈 )
</li><li>%B は %A より先に呼出された
</li><li>( %B における %timeout ) ~LTE ( %A における %timeout )
</li></ul>

<p class="trans-note">【
例えば ( %A, %B ) における %timeout が ( 1, 2 ) の場合、
%B が %A の 100 ~milli秒~先に呼出されていても，
%A が先に実行される余地があることになる。
】</p>

◎
Wait until any invocations of this algorithm that had the same method context, that started before this one, and whose timeout is equal to or less than this one's, have completed.
</div>


<p class="note">
Web IDL に定義されるように、引数の変換は，この~algoが呼出される前に Web IDL にて定義される~algo内で起こる
— 例えば、最初の引数として渡された ~obj上の `toString()^m ~methodを呼出すような：
◎
Argument conversion as defined by Web IDL (for example, invoking toString() methods on objects passed as the first argument) happens in the algorithms defined in Web IDL, before this algorithm is invoked.
</p>


<div class="example">

<p>
例えば、次のばかげた~codeによる結果の %log は
`ONE&nbsp;TWO&nbsp;^l
になる：
◎
So for example, the following rather silly code will result in the log containing "ONE TWO ":
</p>


<pre>
var %log = '';
function logger(%s) { %log += %s + ' '; }

setTimeout({ toString: function () {
  setTimeout("logger('ONE')", 100);
  return "logger('TWO')";
} }, 100);
</pre>

</div>

	</li>
	<li>
<p>
~UAの任意選択で
⇒
~UAにより定義される時間だけ待機する。
◎
Optionally, wait a further user-agent defined length of time.
</p>

<p class="note">
この段が意図する所は、~UAが機器の電力消費を最適化する必要に応じて，~timeoutを~~延長できるようにするためである。
例えば、~timerの粒度を抑えるような節電~modeを有する~processorも中にはあり、そのような~platform上では，~UAは，より正確0な非~節電~modeを利用することを要求する代わりに，この~scheduleに見合うように~timerを遅めれる。
◎
This is intended to allow user agents to pad timeouts as needed to optimise the power usage of the device. For example, some processors have a low-power mode where the granularity of timers is reduced; on such platforms, user agents can slow timers down to fit this schedule instead of requiring the processor to use the more accurate mode with its associated higher power usage.
</p>

	</li>
	<li>
<p>
`~task$ %~task を`待入する$
◎
Queue the task task.
</p>

<p class="note">
［
%繰返~flag ~EQ ~OFF
］の下では、~taskの処理-後に，`作動中の~timer~list$から %handle に対応する~entryを除去しても安全である（この時点を過ぎて以降，~entryの存在を検知する仕方はないので、技術的に問題0になることはない）。
◎
Once the task has been processed, if the repeat flag is false, it is safe to remove the entry for handle from the list of active timers (there is no way for the entry's existence to be detected past this point, so it does not technically matter one way or the other).
</p>
	</li>
</ol>
<p>
これらの`~task$に対する`~task~source$は、
`~timer~task源@
とする。
◎
The task source for these tasks is the timer task source.
</p>

<div class="example">

<p>
数~milli秒かかる~taskを間断なく遅延なしに走らせつつ，~browserにも~UIに応じる余裕を与える（および，~browserが CPU 時間を得るために~scriptを強制終了しないようにする）ためには、単純に仕事を遂行する前に次回の~timerを待入する：
◎
To run tasks of several milliseconds back to back without any delay, while still yielding back to the browser to avoid starving the user interface (and to avoid the browser killing the script for hogging the CPU), simply queue the next timer before performing work:
</p>

<pre>
function doExpensiveWork() {
  var %done = false;
  // ...
  /* <span class="comment">
この部分は、 %done を ~T に設定するまでに数~milli秒かかる
◎
this part of the function takes up to five milliseconds set done to true if we're done
</span> */
  // ...

  return %done;
}

function rescheduleWork() {
  var %handle = setTimeout(rescheduleWork, 0); /*
      <span class="comment">
次回の反復を予め~scheduleしておく
◎
preschedule next iteration
</span> */
  if (doExpensiveWork())
    clearTimeout(%handle); /*
      <span class="comment">
用済みになったら~timeoutを~clearする
◎
clear the timeout if we don't need it
</span> */
}

function scheduleWork() {
  setTimeout(rescheduleWork, 0);
}

scheduleWork(); /*
  <span class="comment">
たくさんの仕事を行う~taskを待入する
◎
queues a task to do lots of work
</span> */
</pre>

</div>



		</section>
		<section id="user-prompts">
<h3 title="User prompts">8.6. 利用者~向けの~prompt</h3>


			<section id="simple-dialogs">
<h4 title="Simple dialogs">8.6.1. 単純な~dialog</h4>

  <dl class="domintro">
	<dt>%window . `alert(message)$m</dt>
	<dd>
所与の~messageを伴う~modal~alertを表示した上で、利用者がそれを退けるまで待機する。
◎
Displays a modal alert with the given message, and waits for the user to dismiss it.
</dd>

	<dt>%result = %window . `confirm(message)$m</dt>
	<dd>
所与の~messageを伴う［
OK ／ Cancel
］~modal~promptを表示して、利用者が退けるまで待機する。
利用者が［
OK を~clickしたなら ~T ／
Cancel を~clickしたなら ~F
］を返す。
◎
Displays a modal OK/Cancel prompt with the given message, waits for the user to dismiss it, and returns true if the user clicks OK and false if the user clicks Cancel.
</dd>

	<dt>%result = %window . `prompt(message [, default] )$m</dt>
	<dd>
~text~control, および所与の~messageを伴う~modal~promptを表示して、利用者がそれを退けるまで待機する。
利用者が［
~promptを取消したなら ~NULL ／
~ELSE_ 利用者が手入力した値
］を返す。
%default 引数が在る場合、その値が既定の~~入力として利用される。
◎
Displays a modal text control prompt with the given message, waits for the user to dismiss it, and returns the value that the user entered. If the user cancels the prompt, then returns null instead. If the second argument is present, then the given value is used as a default.
</dd>

</dl>

<p class="note">
これらの~methodが呼出された場合、`~media~data$を読込んでいる`~media要素$などの
`~task$ ／ `極小task$
に依存する~logicは停滞する。
◎
Logic that depends on tasks or microtasks, such as media elements loading their media data, are stalled when these methods are invoked.
</p>

<p>
所与の文字列 %s を
`任意選択で短縮-@
するときは、［
%s をそのままか，または %s から導出されるより短い何らかの文字列
］を返す。
~UAは、 %s から省かれた部位を表示するための ~UIは提供するべきでない
— そうすると
“~securityに関する重要事項です。次を~clickして全部的な詳細を読んで下さい。”
のような類の~dialogを簡単に作成できてしまい，濫用され易くなるので。
◎
To optionally truncate a simple dialog string s, return either s itself or some string derived from s that is shorter. User agents should not provide UI for displaying the elided portion of s, as this makes it too easy for abusers to create dialogs of the form "Important security alert! Click 'Show More' for full details!".
</p>

<p class="note">
例えば~UAは、~messageの最初の 100文字のみを表示したり，文字列を "…" で中略するすることを求めるかもしれない。
この種の改変は、不自然に巨大な, もっともらしい~system~dialogに濫用される~~可能性を制限するのに有用になり得る。
◎
For example, a user agent might want to only display the first 100 characters of a message. Or, a user agent might replace the middle of the string with "…". These types of modifications can be useful in limiting the abuse potential of unnaturally large, trustworthy-looking system dialogs.
</p>

<div >
<p class="algo-head">
所与の %window 上で
`~promptを示すかどうか決定-@
するときは、次を走らす：
</p>

<p class="trans-note">【
この手続きは、共通のふるまいを集約するために，この訳に導入したものである。
】</p>

<ol>
	<li>
%文書 ~LET %window に`結付けられている文書$
</li>
	<li>
~IF［
%文書 が`属する閲覧文脈$の`~event-loop$の`終了の入子~level$ ~NEQ 0
］
⇒
~UAの任意選択で
⇒
~RET `示さない^i
</li>
	<li>
~IF［
`~sandbox化( ~modal )~flag$ ~IN ［
%文書 にて`作動中の~sandbox用~flag集合$
］］
⇒
~RET `示さない^i
</li>
	<li>
~UAの任意選択で
⇒
~RET `示さない^i
（例えば，~UAは、利用者に，以降の~alert／~promptすべてを無視する選択肢を供するかもしれない
— 利用者がその選択肢を選んだ場合、この手続きを呼出した~methodは，それ以降 呼出される度に，この段で中止されることになる。）
</li>
	<li>
~RET `示す^i
</li>
</ol>


◎
↓</div>

<p>
`alert(message)@m
~methodの被呼出時には、次を走らせ~MUST：
◎
The alert(message) method, when invoked, must run the following steps:
</p>

<ol>
	<li>
~IF［
此れ上で`~promptを示すかどうか決定-$した結果 ~EQ `示さない^i
］
⇒
~RET
◎
If the event loop's termination nesting level is non-zero, optionally abort these steps.
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then abort these steps.
◎
Optionally, abort these steps. (For example, the user agent might give the user the option to ignore all alerts, and would thus abort at this step whenever the method was invoked.)
</li>
	<li>
~IF［
%message は与えられていない
］
⇒
%message ~SET 空~文字列
◎
If the method was invoked with no arguments, then let message be the empty string; otherwise, let message be the method's first argument.
</li>
	<li>
%message ~SET %message を`任意選択で短縮-$した結果
◎
Set message to the result of optionally truncating message.
</li>
	<li>
%message を利用者に示す
◎
Show message to the user.
</li>
	<li>
~UAの任意選択で
⇒
利用者が~messageを認めるまで`一時停止-$する
◎
Optionally, pause while waiting for the user to acknowledge the message.
</li>
</ol>

<p>
`confirm(message)@m
~methodの被呼出時には、次を走らせ~MUST：
◎
The confirm(message) method, when invoked, must run the following steps:
</p>

<ol>
	<li>
~IF［
此れ上で`~promptを示すかどうか決定-$した結果 ~EQ `示さない^i
］
⇒
~RET ~F
◎
If the event loop's termination nesting level is non-zero, optionally abort these steps, returning false.
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then abort these steps.
◎
Optionally, return false and abort these steps. (For example, the user agent might give the user the option to ignore all prompts, and would thus abort at this step whenever the method was invoked.)
</li>
	<li>
%message ~SET %message を`任意選択で短縮-$した結果
◎
Set message to the result of optionally truncating message.
</li>
	<li>
%message を利用者に示して，利用者に肯定か否定か訊ねる
◎
Show message to the user, and ask the user to respond with a positive or negative response.
</li>
	<li>
利用者が応答するまで`一時停止-$する
◎
Pause until the user responds either positively or negatively.
</li>
	<li>
~RET 利用者の応答に応じて
⇒
肯定ならば ~T ／ 否定ならば ~F
◎
If the user responded positively, return true; otherwise, the user responded negatively: return false.
</li>
</ol>


<p>
`prompt(message, default)@m
~methodの被呼出時には、次を走らせ~MUST：
◎
The prompt(message, default) method, when invoked, must run the following steps:
</p>

<ol>
	<li>
~IF［
此れ上で`~promptを示すかどうか決定-$した結果 ~EQ `示さない^i
］
⇒
~RET ~NULL
◎
If the event loop's termination nesting level is non-zero, optionally abort these steps, returning null.
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then abort these steps.
◎
Optionally, return null and abort these steps. (For example, the user agent might give the user the option to ignore all prompts, and would thus abort at this step whenever the method was invoked.)
</li>
	<li>
%message ~SET %message を`任意選択で短縮-$した結果
◎
Set message to the result of optionally truncating message.
</li>
	<li>
%default ~SET %default を`任意選択で短縮-$した結果
◎
Set default to the result of optionally truncating default.
</li>
	<li>
%message を利用者に示し、既定の応答を %default 値にする下で，利用者に 文字列~値で応答するか中止するか訊ねる
◎
Show message to the user, and ask the user to either respond with a string value or abort. The response must be defaulted to the value given by default.
</li>
	<li>
利用者が応答するまで`一時停止-$する
◎
Pause while waiting for the user's response.
</li>
	<li>
~RET［
利用者が中止したならば ~NULL ／
~ELSE_  利用者が応答した文字列
］
◎
If the user aborts, then return null; otherwise, return the string that the user responded with.
</li>
</ol>


			</section>
			<section id="printing">
<h4 title="Printing">8.6.2. 印刷ing</h4>

<dl class="domintro">
	<dt>%window . `print()$m</dt>
	<dd>
利用者に頁を印刷する旨を~promptする。
◎
Prompts the user to print the page.
</dd>

</dl>

<div>
<p>
`print()@m
~methodの被呼出時には次を走らせ~MUST：
</p>

<ol>
	<li>
%文書 ~LET 此れに`結付けられている文書$
</li>
	<li>
~IF［
%文書 の`読込み後~taskは準備済み$である
］
⇒
%文書 の`印刷-時の手続き$を`並列的$に走らす
</li>
	<li>
~ELSE
⇒
%文書 の
`読込み時に印刷する~flag@
~SET ~ON
</li>
</ol>

◎
When the print() method is invoked, if the Document is ready for post-load tasks, then the user agent must run the printing steps in parallel. Otherwise, the user agent must only set the print when loaded flag on the Document.
</div>



<p>
~UAは、利用者から文書 %文書 の`物理形を得る$（例：印刷, あるいは ~PDF などの物理形の表現も含む）機会を請われたときも、`印刷-時の手続き$を走らすべきである。
◎
User agents should also run the printing steps whenever the user asks for the opportunity to obtain a physical form (e.g. printed copy), or the representation of a physical form (e.g. PDF copy), of a document.
</p>

<p>
所与の %文書 の
`印刷-時の手続き@
は、次に従う：
◎
The printing steps are as follows:
</p>

`27864$bug

<ol>
	<li>
<p>
~UAの任意選択で、次のいずれかまたは両方を行う：
◎
The user agent may display a message to the user or abort these steps (or both).
</p>

<ul ><li>利用者に~messageを表示する
</li><li>~RET
</li></ul>

<p class="example">
具体例として、~kiosk~browserは，
`print()$m ~methodに対する呼出すべてを黙って無視することもできる。
◎
For instance, a kiosk browser could silently ignore any invocations of the print() method.
</p>

<p class="example">
具体例として、~mobile機器~上の~browserは、近くに印刷機がないことを検知したなら，
“~PDFに保存”
の選択肢を提供0するに先立って その旨を述べる~messageを表示することもできる。
◎
For instance, a browser on a mobile device could detect that there are no printers in the vicinity and display a message saying so before continuing to offer a "save to PDF" option.
</p>
	</li>
	<li>
<p>
~IF［
`~sandbox化( ~modal )~flag$ ~IN
%文書 にて`作動中の~sandbox用~flag集合$
］
⇒
~RET
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then abort these steps.
</p>

<p class="note">
印刷ing~dialogが %文書 の~sandboxで阻止された場合、
`beforeprint$et ／ `afterprint$et
~eventは発火されない。
◎
If the printing dialog is blocked by a Document's sandbox, then neither the beforeprint nor afterprint events will be fired.
</p>
	</li>
	<li>
%文書~list ~LET  %文書, および［
%文書 の`子孫~閲覧文脈~list$内の各 `閲覧文脈$の`作動中の文書$
］からなる~list
◎
↓</li>
	<li>
<p>
%文書~list 内の ~EACH ( %D ) に対し
⇒
%D を`結付けている~window$に向けて，名前 `beforeprint$et の`単純~eventを発火-$する
◎
The user agent must fire a simple event named beforeprint at the Window object of the Document that is being printed, as well as any nested browsing contexts in it.
</p>

<p class="example">
`beforeprint$et ~eventは、
印刷される複製に注釈を加えるときに利用できる
— 具体例として，印刷された時刻を追加するなど。
◎
The beforeprint event can be used to annotate the printed copy, for instance adding the time at which the document was printed.
</p>

	</li>
	<li>
<p>
~UAは、利用者に %文書 の`物理形を得る$（または その表現を得る）機会を提供0するべきである
— そうする場合
⇒
利用者が受容するか辞退するまで待機してよい
— そうする場合
⇒
待機-中は`一時停止-$し~MUST。
</p>

<p>
待機するかどうかにかかわらず、当の物理形には，この~algoのこの時点における %文書 の状態を利用し~MUST。
</p>
◎
The user agent should offer the user the opportunity to obtain a physical form (or the representation of a physical form) of the document. The user agent may wait for the user to either accept or decline before returning; if so, the user agent must pause while the method is waiting. Even if the user agent doesn't wait at this point, the user agent must use the state of the relevant documents as they are at this point in the algorithm if and when it eventually creates the alternate form.
</li>
	<li>
<p>
%文書~list 内の ~EACH ( %D ) に対し
⇒
~IF［
%D が`属する閲覧文脈$はまだある
`この条件は訳者による補完^tnote
］
⇒
%D を`結付けている~window$に向けて，名前 `afterprint$et の`単純~eventを発火-$する
◎
The user agent must fire a simple event named afterprint at the Window object of the Document that is being printed, as well as any nested browsing contexts in it.
</p>

<p class="example">
`afterprint$et ~eventは、 `beforeprint$et ~event時に追加された注釈を復帰するため, あるいは 印刷ing後の~UIを示すためにも利用できる。
後者の具体例としては、利用者に 何段階かにわたる手続きを踏んでもらう頁があるとき、~scriptは，印刷-後に 自動的に次の段階へ進めることもできる。
◎
The afterprint event can be used to revert annotations added in the earlier event, as well as showing post-printing UI. For instance, if a page is walking the user through the steps of applying for a home loan, the script could automatically advance to the next step after having printed a form or other.
</p>

	</li>
</ol>



			</section>
		</section>
		<section id="system-state-and-capabilities">
<h3 title="System state and capabilities">8.7. ~systemの状態と能力</h3>

<p class="trans-note">【
この節の和訳は、当面の間 省略する
】</p>

		</section>
		<section id="images">
<h3 title="Images">8.8. 画像</h3>


<p class="trans-note">【
この節の和訳は、当面の間 省略する
】</p>

		</section>
		<section id="animation-frames">
<h3 title="Animation Frames">8.9. ~animation~frame</h3>

<div class="p">
<p>
各 `Document$I は、次のものを持つ：
</p>

<dl class="def-list">
	<dt>`~animation~frame~callback~list@</dt>
	<dd>
初期~時は空。
</dd>

	<dt>`~animation~frame~callback識別子@</dt>
	<dd>
整数（初期~時は~zero）。
</dd>
</dl>
◎
Each Document has a list of animation frame callbacks, which must be initially empty, and an animation frame callback identifier, which is a number which must initially be zero.
</div>


<p>
`requestAnimationFrame(callback)@m
~methodの被呼出時には、次を走らせ~MUST：
◎
When the requestAnimationFrame() method is called, the user agent must run the following steps:
</p>

<ol>
	<li>
%文書 ~LET 此れに`結付けられている文書$
◎
Let document be this Window object's associated Document.
</li>
	<li>
%文書 の`~animation~frame~callback識別子$ ~INCBY 1
</li>
	<li>
%識別子 ~LET %文書 の`~animation~frame~callback識別子$
◎
Increment document's animation frame callback identifier by one.
</li>
	<li>
%callback に %識別子 を結付けた上で，
%文書 の`~animation~frame~callback~list$に付加する
◎
Append the method's argument to document's list of animation frame callbacks, associated with document's animation frame callback identifier's current value.
</li>
	<li>
~RET %識別子
◎
Return document's animation frame callback identifier's current value.
</li>
</ol>

<p>
`cancelAnimationFrame(handle)@m
~methodの被呼出時には、次を走らせ~MUST：
◎
When the cancelAnimationFrame() method is called, the user agent must run the following steps:
</p>

<ol>
	<li>
~IF［
此れに`結付けられている文書$の`~animation~frame~callback~list$内に
%handle を結付けている~callbackはある
］
⇒
%文書 の`~animation~frame~callback~list$から その~callbackを除去する
◎
Let document be this Window object's associated Document.
◎
Find the entry in document's list of animation frame callbacks that is associated with the value given by the method's argument.
◎
If there is such an entry, remove it from document's list of animation frame callbacks.
</li>
</ol>

<p>
~UAは，
`~animation~frame~callbackたちを走らす@
ときは、所与の
( `Document$I %文書, 時刻印 %now )
に対し，次を走らせ~MUST：
◎
When the user agent is to run the animation frame callbacks for a Document doc with a timestamp now, it must run the following steps:
</p>

<ol>
	<li>
%~callback~list ~LET %文書 の`~animation~frame~callback~list$の複製
◎
Let callbacks be a list of the entries in doc's list of animation frame callbacks, in the order in which they were added to the list.
</li>
	<li>
%文書 の`~animation~frame~callback~list$を空にする
◎
Set doc's list of animation frame callbacks to the empty list.
</li>
	<li>
%~callback~list 内の~EACH ( %~callback ) に対し
⇒
%now を引数に渡して %~callback を`呼出す$x
`WEBIDL$r
— ただし
⇒
例外が投出された場合は、その`例外を報告する$
`反復は継続する^tnote
◎
For each entry in callbacks, in order: invoke the callback, passing now as the only argument, and if an exception is thrown, report the exception. [WEBIDL]
</li>
</ol>



		</section>
</main>
