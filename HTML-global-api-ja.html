<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Web application APIs（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/webappapis.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160707 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		sc: 'scheme',
		jA: 'abstract',
		sl: 'js-slot',
		h: 'header',
		E: 'error',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		E: 'code',
		m: 'code',
		hd: 'code',
		c: 'code',
		s: 'samp',
		e: 'code',
		a: 'code',
		sc: 'code',
		et: 'code',
		h: 'code',
		jA: 'span',
		sl: 'span',
		sub: 'sub',
		V: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
case 'hd': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text += ':';
	break;
case 'sl': // JS internal slot
	text = '[[' + text + ']]';
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">

</script>
<!--% リンク置換データ -->

<script type="text/plain" id="_link_map">


	●IDL
Serializable:~HTMLcloning#serializable
Transferable:~HTMLcloning#transferable

I.Document:~HTMLdom#document
I.Function:~WEBIDL#Function
I.Window:~BROWSERS#window
I.WindowProxy:~BROWSERS#windowproxy
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.WindowOrWorkerGlobalScope:#windoworworkerglobalscope
I.TimerHandler:#timerhandler
I.DOMException:~WEBIDL#idl-DOMException

E.InvalidCharacterError:~WEBIDL#invalidcharactererror
E.IndexSizeError:~WEBIDL#indexsizeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SecurityError:~WEBIDL#securityerror

jA.HostEnsureCanCompileStrings:~WAPI#hostensurecancompilestrings(callerrealm,-calleerealm)

et.afterprint:~HTMLindex#event-afterprint
et.beforeprint:~HTMLindex#event-beforeprint

m.atob:#dom-atob
m.btoa:#dom-btoa

m.alert:#dom-alert
m.confirm:#dom-confirm
m.print:#dom-print

m.cancelAnimationFrame:#dom-window-cancelanimationframe

m.clearInterval:#dom-clearinterval
m.clearTimeout:#dom-cleartimeout
m.setInterval:#dom-setinterval
m.setTimeout:#dom-settimeout

m.origin:#dom-origin
m.self.origin:#dom-origin
m.prompt:#dom-prompt
m.requestAnimationFrame:#dom-window-requestanimationframe

	■ImageBitmap
I.Blob:~FILEAPI#blob
I.CanvasImageSource:~HEcanvas#canvasimagesource
I.ColorSpaceConversion:#colorspaceconversion
I.ImageBitmap:#imagebitmap
I.ImageBitmapOptions:#imagebitmapoptions
I.ImageBitmapSource:#imagebitmapsource
I.ImageData:~HEcanvas#imagedata
I.ImageOrientation:#imageorientation
I.PremultiplyAlpha:#premultiplyalpha
I.ResizeQuality:#resizequality

m.HAVE_METADATA:~HTMLemb#dom-media-have_metadata
m.HAVE_NOTHING:~HTMLemb#dom-media-have_nothing
m.NETWORK_EMPTY:~HTMLemb#dom-media-network_empty
m.close:#dom-imagebitmap-close
m.colorSpaceConversion:#dom-imagebitmapoptions-colorspaceconversion
m.createImageBitmap:#dom-createimagebitmap
m.data:~HEcanvas#dom-imagedata-data
m.height:#dom-imagebitmap-height
m.imageOrientation:#dom-imagebitmapoptions-imageorientation
m.networkState:~HTMLemb#dom-media-networkstate
m.premultiplyAlpha:#dom-imagebitmapoptions-premultiplyalpha
m.readyState:~HTMLemb#dom-media-readystate
m.resizeWidth:#dom-imagebitmapoptions-resizewidth
m.resizeHeight:#dom-imagebitmapoptions-resizeheight
m.resizeQuality:#dom-imagebitmapoptions-resizequality
m.type:~FILEAPI#dfn-type
m.width:#dom-imagebitmap-width

e.canvas:~HEcanvas#the-canvas-element
e.img:~HEimages#the-img-element
e.video:~HEmedia#the-video-element
e.keygen:~HTML5/obsolete.html#keygen

l.default:#dom-premultiplyalpha-default
l.flipY:#dom-imageorientation-flipy
l.high:#dom-resizequality-high
l.low:#dom-resizequality-low
l.medium:#dom-resizequality-medium
l.pixelated:#dom-resizequality-pixelated
l.premultiply:#dom-premultiplyalpha-premultiply
l.~default0:#dom-colorspaceconversion-default
l.~none0:#dom-colorspaceconversion-none
l.~none1:#dom-imageorientation-none
l.none:#dom-premultiplyalpha-none

V.resizeWidth:#_resizewidth
V.resizeHeight:#_resizeheight



	●
~ASCII英数字:~INFRA#ascii-alphanumeric
~ASCII空白:~INFRA#ascii-whitespace
並列的:~HTMLINFRA#in-parallel

~animation~frame~callback識別子:#animation-frame-callback-identifier

~promptを示すかどうか決定-:#_determine-to-show-modal-prompt

作動中の~timer~list:#list-of-active-timers
~animation~frame~callback~list:#list-of-animation-frame-callbacks
任意選択で短縮-:#optionally-truncate-a-simple-dialog-string
読込み時に印刷する~flag:#print-when-loaded
印刷-時の手続き:#printing-steps
~animation~frame~callbackたちを走らす:#run-the-animation-frame-callbacks
~timer初期化~手続き:#timer-initialisation-steps
~timerの入子~level:#timer-nesting-level
~timer~task源:#timer-task-source
~task源:~WAPI#task-source
~task:~WAPI#concept-task
関連する設定群~obj:~WAPI#relevant-settings-object
入口~設定群~obj:~WAPI#entry-settings-object
一時停止-:~WAPI#pause
待入する:~WAPI#queue-a-task
~classic~scriptを走らす:~WAPI#run-a-classic-script
~classic~scriptを作成-:~WAPI#creating-a-classic-script
環境~設定群~obj:~WAPI#environment-settings-object
極小task:~WAPI#microtask
例外を報告する:~WAPI#report-the-exception
~event-loop:~WAPI#event-loop
sT.生成元:~WAPI#concept-settings-object-origin


閲覧文脈:~BROWSERS#browsing-context
作動中の~sandbox用~flag集合:~BROWSERS#active-sandboxing-flag-set
結付けられている文書:~BROWSERS#concept-document-window
結付けている~window:~BROWSERS#concept-document-window
属する閲覧文脈:~BROWSERS#concept-document-bc
	属する~閲覧文脈:~BROWSERS#concept-document-window
全部的に作動中:~BROWSERS#fully-active
入子の閲覧文脈:~BROWSERS#nested-browsing-context
子孫~閲覧文脈~list:~BROWSERS#list-of-the-descendant-browsing-contexts
作動中の文書:~BROWSERS#active-document

~sandbox化( ~modal )~flag:~BROWSERS#sandboxed-modals-flag
生成元:~BROWSERS#concept-origin
~Unicode直列化-:~BROWSERS#unicode-serialisation-of-an-origin

~media~data:~HTMLemb#media-data
~media要素:~HTMLemb#media-element

物理形を得る:~HTMLrendering#obtain-a-physical-form

	27864:https://www.w3.org/Bugs/Public/show_bug.cgi?id=27864
js.現在の~Realm~Record:~TC39#current-realm
js.~JS~realm:~TC39#sec-code-realms
x.呼出す:~WEBIDL#es-invoking-callback-functions
x.~callback this 値:~WEBIDL#dfn-callback-this-value


終了の入子~level:~NAVI#termination-nesting-level
読込み後~taskは準備済み:~HTMLsyntax#ready-for-post-load-tasks


	●ImageBitmap
~bitmap~dataを取得-:#_get-a-bitmap-data-from-image
代表する~bitmap~data:#_get-a-bitmap-data-from-animated-image

~bitmap~data:#concept-imagebitmap-bitmap-data
~source矩形に~cropして整形-:#cropped-to-the-source-rectangle-with-formatting
全部的に復号可能:#concept-imagebitmap-good

~CORS非同一生成元:~HTMLINFRA#cors-cross-origin
~CSS~pixel:~CSSVAL#px
転送可能:~HTMLcloning#transferable-objects
直列化可能:~HTMLcloning#serializable-objects
sl.Detached:~HTMLcloning#detached

~SVG-image:~SVG11/struct.html#ImageElement
完全に可用:~HEimages#img-all
現在の再生位置:~HTMLemb#current-playback-position
	error occurs during reading of the object:~HTMLconform#file-error-read
画像~sniff時の規則:~MIMESNIFF#rules-for-sniffing-images-specifically
内在的~寸法:~CSS2CONFORM#intrinsic
	https://drafts.csswg.org/css2/conform.html#intrinsic
内在的~横幅:~CSS2CONFORM#intrinsic
	~HTMLconform#intrinsic-width
内在的~縦幅:~CSS2CONFORM#intrinsic
	~HTMLconform#intrinsic-height

video.内在的~縦幅:~HEmedia#concept-video-intrinsic-height
video.内在的~横幅:~HEmedia#concept-video-intrinsic-width
	
~media資源:~HTMLemb#media-resource
生成元clean:~HEcanvas#concept-canvas-origin-clean
生成元:~BROWSERS#concept-origin
同一生成元:~BROWSERS#same-origin
sub.生成元:~BROWSERS#same-origin

~eventを発火-:~DOM4#concept-event-fire

で却下する:#_reject-for-imagebitmap
解決する:~PROMISES#resolve-promise
	却下する:~PROMISES#reject-promise
却下-:~PROMISES#reject-promise
新たな~promise:~PROMISES#a-new-promise
却下された~promise:~PROMISES#a-promise-rejected-with

転送-手続き:~HTMLcloning#transfer-steps
転送-受信-時の手続き:~HTMLcloning#transfer-receiving-steps
直列化~手続き:~HTMLcloning#serialization-steps
逆直列化~手続き:~HTMLcloning#deserialization-steps

</script>


<!--% 置換データ -->
<script type="text/plain" id="words_table1">
none0:none
none1:none
default0:default
this:<b>this</b>
SVG-image:SVG <code class="element">image</code>

</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">

此れ:<b>これ°</b>

	CPU
	More
URL:
Web:::


	●JS／event／IDL／task／script／大域
window:
IDL:::
JS:JavaScript
Realm:
Record:
event::::イベント
event-loop:event loop:::イベントループ
task::::タスク
極小task:microtask:::極小タスク
call::::
callback::::
入口:entry::~
entry::::エントリ
mixin:
script::::スクリプト
scripting::::スクリプト処理
obj:object:::オブジェクト
realm:
worker::::
code::::コード
classic:::::クラシック
compile::::コンパイル
method::::メソッド

取得子:getter:~
呼出:invocation:呼出し
呼出ing:invoking:呼出し
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
呼出す:invoke する:呼び出す
設定-:set:~
設定群:settings:~
投出:throw:~
発火-:fire:~
被呼出時:被 invoke 時:~
走らす:run する:~
走って:run して:~
遂行-:perform:~
完了-:complete:~
実行-:execute:~
報告-:report::~
閲覧文脈:browsing context::~
源:source::~::ソース
並列的:parallel:~
例外:exception:~
大域:global::~::グローバル
引数:argument:~
現在の:current:~
現在:currently:~
現在は:currently:~
環境:environment:~
関数:function:~
関連する:relevant な:~
文脈:context:~
停滞-:stall:~
準備済み:ready:~
一時停止-:pause::~::ポーズ
中止-:abort:~
待入する:queue する::待ち行列に入れる::キューする
待機-:wait:~

	●btoa
Unicode:::
base64:
binary::::バイナリ
bit::::ビット
shift::::シフト
byte::::バイト
octet::::オクテット
data::::データ
復号-:decode::~::デコード
文字:character:~
文字列:string:~
出力:output:~
入力:input:~
空:empty:~
符号位置:code-point:~
符号化-:encode:~
符号化方式:encoding:~
変換-:convert:~
変換:conversion:~
変形-:transform:変換
範囲:range:~
	範囲~外:out-of-range
妥当:valid:~
空白:whitespace:~
ASCII:
英数字:alphanumerics:~
	語呂的には:mnemonic purposess

	●prompt／印刷
PDF:::
alert:
prompt:
	Cancel
	Click
	OK
modal::::モーダル
message::::メッセージ
阻止-:block::~::ブロック
control::::コントロール
dialog::::ダイアログ
訊ねる:ask する:~
退ける:dismiss する:~
sandbox::::サンドボックス
click::::クリック
clear::::
選択肢:option:~
	肯定か否定:positive／negative／negatively／positively
任意選択:option:~
kiosk:
短縮-:truncate:~
省かれ:elide され:~
黙って:silent に:~
保存:save:~
	何段階かにわたる手続きを踏むthrough the steps of applying for a home loan

印刷:print::~::プリント
印刷-:print::~::プリント
印刷ing:printing::印刷::プリント
印刷機:printer::~::プリンタ
取消す:cancel する::取り消す::キャンセルする
取消した:cancel した::取り消した::キャンセルした
機会:opportunity:~
機器:device:~
復帰-:revert:~
応答-:respond:~
応答:response:~
手入力-:enter:~
注釈-:annotate:~
注釈:annotation:~

	進める:advance
	部位:portion:~
物理形:physical form:~
	-:earlier
辞退-:decline:~



	●timer/animation
animation::::アニメーション
schedule::::スケジュール
time::::
timeout::::タイムアウト
timer::::タイマー
interval:
時刻印:timestamp::~::タイムスタンプ
milli::::ミリ
	milli秒:millisecond
	過ぎる:pass:~
	開始-:start:~
前回handle:previous handle:前回の handle
節電:low-power:~
電力消費:power usage:~
mode::::モード
入子:nesting:入れ子
入子に:nest:入れ子に
入子の:nested:入れ子の
負荷:load:~
	~UIに応じる余裕を与える:yielding back to avoid starving the user interface
	時間を得る:hogging
	強制終了:kill
延期:delay:~
	遅延
休止-:suspend:~
連続的:consecutively:~
識別子:identifier:~

	時間:length of time.
	~~延長 pad
	時点を過ぎて~pointを~past
	なることはない not 〜 one way or the other
	存続する限り:lifetime
繰返:repeat::繰返
繰返しの:repeating::繰返し続ける
	遅める＊ slow down
	間断なくback to back
	予め~schedule:preschedule
予期-:expect:~


	●仕様
API:
algo:algorithm:::アルゴリズム
UA:user agent:UA
UI:::
support::::サポート
下位手続き:substeps:~
不自然:unnatural:~
理由:reason:~
仕方:way:~
作者:author:~
依存-:depend:~
依拠-:rely:~
	依拠し得る:reliable:~
	依然として:still:~
保証:guarantee:~
仕事:work:~
	利用-:use:~
利用者:user:~
制限-:limit:~
受容-:accept:~
問題0:matter:問題
奨励-:encourage:~
定義-:define:~
実施:practice:~
実装-:implement:~
容易:easy:~
強く:strong に:~
強制-:force:~
	必然:necessarily:~
	必要-:need:~
所与の:given:与えられた
手続き:steps:~
技術的:technical:~
抑える:reduce する:~
拡張-:extend:~
提供0-:offer:提供
既定の:default:~
	defaulted:~
標準の:standard:~
最適化-:optimize:~
正確0:accurate:正確
正確:exact:~
歴史的:historical:~
段:step:~
導出-:derive:~
有用:useful:~
濫用-:abuse:~
特定0の:particular:ある特定の
粒度:granularity:~
結付けら:associate さ:結び付けら
結付けた:associate した:結び付けた
結付けて:associate して:結び付けて
能力:capabilities:~
自動的:automatic:~
詳細:details:~
適切:appropriate:~
適用-:apply:~
避ける:avoid する:~
重要:important:~
開発者:developer:~
	考える:Imagine
	主に:primarily
	ある-:contain:~
	~~可能性:potential
	具体例として:for instance
	ちっぽけな:rather silly

	■ImageBitmap
一般:general:~
義務付けな:mandate しな:~
要求-:require:~
解釈-:interpret:~
許容-:allow:~
特有の:specific な:~
特有:-specific:~
特定の:specific な:~
予期-:expect:~
仕様:spec:~
判断:judgement:~
実装:implementation:~
実装者:implementer:~
実際:actual:~
意味-:mean:~
指定-:specify:~
	指定されていない:unspecified:~
指示-:indicate:~
挙動:behavior:ふるまい
最適:optimal:~
比較的:relative に:~
単純:simple:~


	●未分類（動詞

初期化:initialization:~
決定-:determine:~
処理-:process:~
初期:initial:~
参照-:reference:~
反復:iteration:~
付加-:append:~
作成-:create:~
公開-:expose:~
存在:existence:~
	認める:acknowledge:~
指示子:indicator:~
挿入:insertion:~
提供-:provide:~
改変:modification:~
改変-:modify:~
検出-:detect:~
無視-:ignore:~
終了の:termination:~
組合せ:combination:~
	継続-:continue:~
置換-:replace:~
表現-:represent:~
表現:representation:~
表示-:display:~
読込み:load:読み込み
	読込み後:post-load:~
読込んで:load して:読み込んで
読込まれ:load され:読み込まれ
識別-:identify:~
追加-:add:~
除去-:remove:~
継続-:continue:~

	●未分類
time-travel:time travel:::タイムトラベル
bug::::バグ
pin:
arrow:
browser::::ブラウザ
flag::::フラグ
form::::フォーム
frame::::フレーム
level::::レベル
list::::リスト
logic::::ロジック
markup::::マークアップ
media::::メディア
mobile:::携帯
platform::::プラットフォーム
processor::::プロセッサ
proxy::::プロキシ
source::::ソース
system::::システム
text::::テキスト
zero::::ゼロ
保安:security::~:セキュリティ

生成元:origin::~::オリジン
生成元clean:origin-clean::~::オリジン-clean
非同一生成元:cross-origin::~::クロスオリジン

要素:element:~
集合:set:~
子孫:descendant:~
一意:unique:~
値:value:~
全部的:full:~
内容:content:~
	再度:again:~
動的:dynamic:~
名:name:~
名前:name:~
安全:safe:~
属性:attribute:~
	後:after:~
整数:integer:~
文書:document:~
作動中の:active な::~::アクティブな
作動中:active::~::アクティブ

状態:state:~
複製:copy:~
長さ:length:~
頁:page:::ページ

	order
	2 個目:second:~
	3 個目の:third:~
	4:four:~
	now:
	setting:設定
	~consisting
	~indeed
	~lot
	~part:
	~past
	~point
	~potential
	~shorter
	踏んで:walking
	〜の代わりに:instead
	いくつかの:several
	この:this
	これらの:these
	すべての:all
	その:that
	そのような:such
	それらの:their
	べき:should
	もっともらしい:trustworthy-looking:#1
	:one
	与-:give
	両者:both
	中略して:replace the middle of
	:two
	他の:other
	以降の:subsequent
	前:before
	前者:former
	各:each
	同じ:same
	在る:present
	対応-:correspond
	対応ing:corresponding
	巨大:large
	:follow
	後者:latter
	戻-:back
	数:number
	更なる:further
	最初の:first
	次回の:next
	求め:want
	渡-:pass
	用の便利:utility
	示す:show
	種:type
	終端:end
	結果:result
	自身:itself
	見なせ:consider
	起こる:happen
	近くに:in the vicinity
	返す:return
	通:through


	●ImageBitmap
close:
CORS:
CSS:
	EXIF
	GPU
	Lanczos:
MIME:
	RAM
SVG:
access::::アクセス
alpha::::アルファ
animated::::アニメート化
bitmap::::ビットマップ
canvas:
	cell:
channel::::チャンネル
	計算量:computationally
	壊れている:corrupted
crop::::
denote::::
disk::::ディスク
error::::エラー
file::::ファイル
graphic::::グラフィック
local::::ローカル
member::::メンバ
metadata::::メタデータ
native::::ネイティブ
network::::ネットワーク
option::::オプション
pixel::::ピクセル
画素:pixel:~:::ピクセル
profile::::プロファイル
size::::サイズ
sniff::::
sprite-sheet:sprite sheet:::スプライトシート

promise::::
slot::::スロット
vector::::ベクター
worker::::
logic::::ロジック
規則:rule:~
完全:complete:~
可用:available:~
資源:resource::~:リソース
整形-:format:~
復号可能:decodable::~::デコード可能
転送-:transfer::~
転送可能:transferable::~
受信-:receive::~
直列化-:serialize::~::シリアライズ
直列形:serialized::~::シリアル形
直列化:serialization::~::シリアル化
直列化可能:serializable::~::シリアライズ可能
逆直列化:deserialization::~::逆シリアル化
保持体:holder::~::ホルダ

黒地透明:transparent black:~
再生位置:playback position:~
下層の:underlying:~
不能化-:disable:~
	積算済みにするかどうかpremultiplication behavior
位置:position:~
内在的:intrinsic:~
内部:internal:~
原点:origin:~
列挙型:enumeration:~
動作-:act:~
	占める:occupy する
却下-:reject:~
双三次:bicubic:~
双線形:bilinear:~
	受容し得る:acceptable:~
	上端:top:~
	右端:right:~
	左端:left:~
品質:quality:~
型:type:~
埋込まれ:embed され:埋め込まれ
塗れる:paint できる:~
	:transform
変更-:change:~
変化-:change:~
外観:appearance:~
	中間:medium:~
寸法:dimension:~
将来的:future:~
平面:plane:~
座標:coordinate:~
形式:format:~
成分:component:~
成功裡:successful:~
拡縮-:scale:~
拡縮:scaling:~
描く:draw する:~
描画-:render:~
新たな:new:~
方位:orientation:~
	:grid
構築-:construct:~
縦幅:height:~
横幅:width:~
縦:vertical:~
横:horizontal:~
準備-:prepare:~
無限の:infinite:~
生産-:produce:~
画像:image:~
矩形:rectangle:~
除算-:divide:~
積算-:multiply:~
積算済み:premultiplied:~
	積算済みにするかどうかpremultiplication behavior
空間:space:~
縦横比:aspect-ratio:~
	:place
色:color:~
表示:display:~
補正:correction:~
補間:interpolation:~
解放-:release:~
解決-:resolve:~
読取る:read する:読み取る
読取った:read した:読み取った
読取り:read:読み取り
遅延:latency:~
過度の:undue:~
選好:preference:~
高速:fast:~
裏返す:flip する:~

	無い:missing
	~~排他:blocking
	選ばれ:chosen
	clip
	考える:deem
	何もしない:no extra step is required
	fatal way
	four
	giving
	increasing
公式的な:official:~
	~point
	事前に切り分けて:precut:
	~tainted
	~taken
	左上隅:top-left corner
	ε:unset
	様々な種類の:variety of different
	~~無視:disregard
	efficient
滑らか:smooth:~
	滑らかに補間する-smoothing

	別の:another
	隅:corner:~
	多くexpensive:~
	異なる:different:~
	供-:provide:~
	最初の:first:~
	できるだけ保つ:maximize:~
	委ねられ:left up to
	一方で:whereas
	あり得る:possible
	指す:pointing at
	基づいて:guide
	利用時:making use
	おそらく:probably
	しかしながら，:however
	より低:lower
	より高:higher
	上:above
	低:low
	例:example
	元の:original
	各:each
	常に:always:~
	後:after:~
	得る:obtain:~
	色:color:~
	表す:express:~
	返す:return:~
	高:high:~


</script>

<!--%style -->
<style type="text/css">

.js-slot {
	color: green;
}

.arg-list {
	display: block;
	padding-left: 2em;
	white-space: pre-line;
}
</style>


</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Standard — Web application APIs 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Web application APIs</a>
の一部の節を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-04-01</time>
（公開：<time>2016-07-23</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">

	<hgroup>
<h1>Web application APIs</h1>
<h2>HTML Living Standard — 最終更新 2017 年 3 月 31 日</h2>
	</hgroup>

</header>

<main id="MAIN" style="display:none;">


		<section id="scripting">
<h2 title="Scripting">8.1. Scripting</h2>

<p class="trans-note">【
この節の和訳は、
<a href="~WAPI#scripting">別ページ</a>
にて。
】</p>
		</section>
		<section id="windoworworkerglobalscope-mixin">
<h2 title="The WindowOrWorkerGlobalScope mixin">8.2. `WindowOrWorkerGlobalScope^I ~mixin</h2>

<p>
`WindowOrWorkerGlobalScope$I ~mixinは、
`Window$I, `WorkerGlobalScope$I
両~obj上に公開されることになる~APIを利用するためにある。
◎
The WindowOrWorkerGlobalScope mixin is for use of APIs that are to be exposed on Window and WorkerGlobalScope objects.
</p>


<p class="note">
他の標準は、
<code>partial interface `WindowOrWorkerGlobalScope$I { … };</code>
を利用して，適切な参照-とともに更に拡張することが奨励される。
◎
Other standards are encouraged to further extend it using partial interface WindowOrWorkerGlobalScope { … }; along with an appropriate reference.
</p>

<pre class="idl">
typedef (DOMString or `Function$I) `TimerHandler@I;

[NoInterfaceObject, Exposed=(Window,Worker)]
interface `WindowOrWorkerGlobalScope@I {
  [Replaceable] readonly attribute USVString `origin$m;

  // base64 utility methods
  DOMString `btoa$m(DOMString %data);
  DOMString `atob$m(DOMString %data);

  // timers
  long `setTimeout$m(
      `TimerHandler$I %handler,
      optional long %timeout = 0,
      any... %arguments
  );
  void `clearTimeout$m(optional long %handle = 0);
  long `setInterval$m(
      `TimerHandler$I %handler,
      optional long %timeout = 0,
      any... %arguments
  );
  void `clearInterval$m(optional long %handle = 0);

  // ImageBitmap
  Promise&lt;`ImageBitmap$I&gt; `createImageBitmap$m(
      `ImageBitmapSource$I %image,
      optional `ImageBitmapOptions$I %options
  );
  Promise&lt;`ImageBitmap$I&gt; `createImageBitmap$m(
      `ImageBitmapSource$I %image,
      long %sx, long %sy, long %sw, long %sh,
      optional `ImageBitmapOptions$I %options
  );
};
`Window$I implements `WindowOrWorkerGlobalScope$I;
`WorkerGlobalScope$I implements `WindowOrWorkerGlobalScope$I;
</pre>

<dl class="domintro">
	<dt>%origin = self . `origin$m</dt>
	<dd>
当の大域~objの`生成元$を文字列に直列化した結果を返す。
◎
Returns the global object's origin, serialized as string.
</dd>
</dl>


<div class="example">
<p>
開発者には `location.origin^m より `self.origin$m を利用することが強く奨励される。
`self.origin^m は 環境の`生成元$を返す一方で、前者は 環境の~URLのそれを返す。
`https://stargate.example/^c 上の文書~内にて実行している次の~scriptを考える：
◎
Developers are strongly encouraged to use self.origin over location.origin. The former returns the origin of the environment, the latter of the URL of the environment. Imagine the following script executing in a document on https://stargate.example/:
</p>

<pre>
var %frame = document.createElement("iframe")
%frame.onload = function() {
  var %frameWin = %frame.contentWindow
  console.log(%frameWin.location.origin) // "null"
  console.log(%frameWin.origin) // "https://stargate.example"
}
document.body.appendChild(%frame)
</pre>


<p>
`self.origin$m は、より依拠し得る保安~指示子である。
◎
self.origin is a more reliable security indicator.
</p>

</div>

<dl class="idl-def">
	<dt>`origin@m</dt>
	<dd>
取得子は、此れに`関連する設定群~obj$の`生成元$sTを`~Unicode直列化-$した結果を返さ~MUST。
◎
The origin attribute's getter must return this object's relevant settings object's origin, serialized.
</dd>
</dl>


		</section>
		<section id="atob">
<h2 title="Base64 utility methods">8.3. ~base64用の便利~method</h2>

<p>
`atob()$m ／ `btoa()$m
~methodにより、内容~dataと~base64符号化方式との間で相互に変形できるようになる。
◎
The atob() and btoa() methods allow developers to transform content to and from the base64 encoding.
</p>


<p class="note">
これらの~method名は、語呂的には "b" は "binary", "a" は "ASCII" を表すと見なせるが、主に歴史的~理由から，実施においては入力, 出力のいずれも ~Unicode文字列である。
◎
In these APIs, for mnemonic purposes, the "b" can be considered to stand for "binary", and the "a" for "ASCII". In practice, though, for primarily historical reasons, both the input and output of these functions are Unicode strings.
</p>

<dl class="domintro">
	<dt>%result = self . `btoa( data )$m</dt>
	<dd>
［
各 文字が，範囲 { 0x00 〜 0xFF } の同じ値をとる~binary~byteを表現している
］ような，~Unicode文字列の形をとる［
範囲 { U+0000 〜 U+00FF } の文字のみからなる入力~data
］を，その~base64表現に変換した結果を返す。
◎
Takes the input data, in the form of a Unicode string containing only characters in the range U+0000 to U+00FF, each representing a binary byte with values 0x00 to 0xFF respectively, and converts it to its base64 representation, which it returns.
</dd>
	<dd>
入力~文字列~内に範囲~外の文字がある場合、
`InvalidCharacterError$E 例外が投出される。
◎
Throws an "InvalidCharacterError" DOMException exception if the input string contains any out-of-range characters.
</dd>

	<dt>%result = self . `atob( data )$m</dt>
	<dd>
~Unicode文字列の形をとる［
~base64に符号化された ~binary~data
］を包含する入力を，［
範囲 { U+0000 〜 U+00FF } の文字のみからなる~Unicode文字列
］に復号した結果を返す
— 各 文字が範囲 { 0x00 〜 0xFF } の同じ値をとる~binary~byteを表現しているような。
◎
Takes the input data, in the form of a Unicode string containing base64-encoded binary data, decodes it, and returns a string consisting of characters in the range U+0000 to U+00FF, each representing a binary byte with values 0x00 to 0xFF respectively, corresponding to that binary data.
</dd>
	<dd>
入力~文字列が妥当な~base64~dataでない場合、
`InvalidCharacterError$E 例外が投出される。
◎
Throws an "InvalidCharacterError" DOMException if the input string is not valid base64 data.
</dd>
</dl>


<dl class="idl-def">
	<dt>`btoa(data)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>

		<ol>
			<li>
~IF［
%data 内に［
符号位置 ~GT U+00FF
］なる文字がある
］
⇒
~THROW `InvalidCharacterError$E
</li>
			<li>
~RET ［
%data 内の各 文字を その符号位置を値とする 8 ~bit表現に変換して得られる~octet列
］に， `RFC4648$r による~base64~algoを適用した結果
</li>
		</ol>
◎
The btoa(data) method must throw an "InvalidCharacterError" DOMException if data contains any character whose code point is greater than U+00FF. Otherwise, the user agent must convert data to a sequence of octets whose nth octet is the eight-bit representation of the code point of the nth character of data, and then must apply the base64 algorithm to that sequence of octets, and return the result. [RFC4648]
</dd>

	<dt>`atob(data)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The atob(data) method, when invoked, must run the following steps:
</p>

		<ol>
			<li>
%data からすべての`~ASCII空白$を除去する
◎
Let position be a pointer into data, initially pointing at the start of the string.
◎
Remove all ASCII whitespace from data.
</li>
			<li>
~IF［
%data の長さは 4 の倍数である
］
⇒
次を 2 回 繰り返す
⇒
~IF［
%data の最後の文字 ~EQ U+003D EQUALS SIGN (=)
］
⇒
%data から最後の文字を除去する
◎
If the length of data divides by 4 leaving no remainder, then: if data ends with one or two U+003D EQUALS SIGN (=) characters, remove them from data.
</li>
			<li>
%不足個数 ~LET 
( %data の長さを 4 の倍数に切り上げた結果 ) − %data の長さ
</li>
			<li>
~IF［
%不足個数 ~EQ 3
］
⇒
~THROW `InvalidCharacterError$E
◎
If the length of data divides by 4 leaving a remainder of 1, throw an "InvalidCharacterError" DOMException and abort these steps.
</li>
			<li>
<p>
~IF［
%data 内に次に挙げるもの以外の文字がある
］
⇒
~THROW `InvalidCharacterError$E
◎
If data contains a character that is not in the following list of characters and character ranges, throw an "InvalidCharacterError" DOMException and abort these steps:
</p>

<ul class="brief"><li>U+002B PLUS SIGN (+)
</li><li>U+002F SOLIDUS (/)
</li><li>`~ASCII英数字$
</li></ul>

			</li>
			<li>
%出力 ~LET 空~文字列
◎
Let output be a string, initially empty.
</li>
			<li>
%buffer ~LET 空~list
◎
Let buffer be a buffer that can have bits appended to it, initially empty.
</li>
			<li>
%data の末尾に %不足個数 個の `A^l を付加する
</li>
			<li>
<p>
~FOR %data 内の ~EACH ( 文字 %char ) に対し，先頭から順に：
◎
While position does not point past the end of data, run these substeps:
</p>
				<ol>
					<li>
<p>
%n ~LET %char に応じて，次の表の右列に与えられる数
— 表~内の “CP( %x )” は 文字 %x の符号位置を表す数とする：
◎
Find the character pointed to by position in the first column of the following table. Let n be the number given in the second cell of the same row.
</p>

<div >
<table id="base64-table"><thead><tr><th>%char
<th>%n
</thead>

<tbody><tr><td>`A^l 〜 `Z^l
<td>CP( %char ) − CP( `A^l )

<tr><td>`a^l 〜 `z^l
<td>CP( %char ) − CP( `a^l ) + 26

<tr><td>`0^l 〜 `9^l
<td>CP( %char ) − CP( `0^l ) + 52

<tr><td>`+^l
<td>62

<tr><td>`/^l
<td>63

</tbody></table>

◎
Character 	Number
• A	0
• B	1
• C	2
• D	3
• E	4
• F	5
• G	6
• H	7
• I	8
• J	9
• K	10
• L	11
• M	12
• N	13
• O	14
• P	15
• Q	16
• R	17
• S	18
• T	19
• U	20
• V	21
• W	22
• X	23
• Y	24
• Z	25
• a	26
• b	27
• c	28
• d	29
• e	30
• f	31
• g	32
• h	33
• i	34
• j	35
• k	36
• l	37
• m	38
• n	39
• o	40
• p	41
• q	42
• r	43
• s	44
• t	45
• u	46
• v	47
• w	48
• x	49
• y	50
• z	51
• 0	52
• 1	53
• 2	54
• 3	55
• 4	56
• 5	57
• 6	58
• 7	59
• 8	60
• 9	61
• +	62
• /	63
</div>

				</li>
				<li>
%buffer に %n を付加する
◎
Append to buffer the six bits corresponding to number, most significant bit first.
</li>
					<li>
<p>
~IF［
%buffer の長さ ~EQ 4
］：
</p>
						<ol>
							<li>
( %n1, %n2, %n3, %n4 ) ~LET %buffer の先頭から順に 4 個の数
</li>
							<li>
<p >
( %m1, %m2, %m3 ) ~LET 次の等式を満たす 3 個の 範囲 { 0 〜 255 } に入る整数
⇒
P( %m1, 16 ) + P( %m2, 8 ) + %m3 ~EQ
P( %n1, 18 ) + P( %n2, 12 ) + P( %n3, 6 ) + %n4
</p>
<p>
この段の “P( %x, %y )” は、
( %x × ( 2 の %y 乗 ) )
を表す（すなわち，左~bit~shift演算）。
</p>
							</li>
							<li>
順に，［
%m1, %m2, %m3
］を値とする符号位置に対応する文字を %出力 に付加する
</li>
							<li>
%buffer を空にする
</li>
						</ol>

◎
If buffer has accumulated 24 bits, interpret them as three 8-bit big-endian numbers. Append the three characters with code points equal to those numbers to output, in the same order, and then empty buffer.
◎
Advance position by one character.
</li>
				</ol>
			</li>
			<li>
<p>
%出力 の末尾から %不足個数 個の文字を除去する
◎
If buffer is not empty, it contains either 12 or 18 bits. If it contains 12 bits, discard the last four and interpret the remaining eight as an 8-bit big-endian number. If it contains 18 bits, discard the last two and interpret the remaining 16 as two 8-bit big-endian numbers. Append the one or two characters with code points equal to those one or two numbers to output, in the same order.
</p>

<p class="note">
入力 %data は 1 文字あたり 6 ~bit, %出力 は 1 文字あたり 8 ~bit の~dataを表現するので、( %不足個数 × 2 ) 個の~bitが，入力の末尾から切り捨てられることになる。
例えば 2 つの入力
`YQ^l （ 6 ~bit表現 24, 16 ）, `YR^l （ 6 ~bit表現 24, 17 ）
に対する `atob()^m の結果はいずれも `a^l になる。
◎
The discarded bits mean that, for instance, atob("YQ") and atob("YR") both return "a".
</p>

		   </li>
			<li>
~RET %出力
◎
Return output.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="dynamic-markup-insertion">
<h2 title="Dynamic markup insertion">8.4. 動的~markup挿入</h2>

<p class="trans-note">【
この節の内容は、未訳。
】</p>

		</section>
		<section id="timers">
<h2 title="Timers and time travel">8.5. ~timerと~time-travel</h2>

<p>
`setTimeout()$m ／
`setInterval()$m
~methodにより、作者は，~timerに基づく~callbackを~scheduleできるようになる
— 過去の時点も含め。
◎
The setTimeout() and setInterval() methods allow authors to schedule timer-based callbacks, including in the past.
</p>

<dl class="domintro">
	<dt>%handle = self . `setTimeout( handler [, timeout [, arguments... ] ] )$m</dt>
	<dd>
%timeout ~milli秒~後に
— あるいは、 %timeout が負の場合は −%timeout ~milli秒~前に — 
%handler を走らす~timeoutを~scheduleする。
%arguments は そのまま %handler に渡される。
◎
Schedules a timeout to run handler after timeout milliseconds, or -timeout milliseconds in the past if timeout is negative. Any arguments are passed straight through to the handler.
</dd>

	<dt>%handle = self . `setTimeout( code [, timeout ] )$m</dt>
	<dd>
%timeout ~milli秒~後に
— あるいは、 %timeout が負の場合は −%timeout ~milli秒~前に — 
%code を~compileして走らす~timeoutを~scheduleする。
◎
Schedules a timeout to compile and run code after timeout milliseconds, or -timeout milliseconds in the past if timeout is negative.
</dd>
	<dt>self . `clearTimeout( handle )$m</dt>
	<dd>
［
`setTimeout()$m ／ `setInterval()$m
により設定された~timeout
］のうち， %handle で識別されるものを取消す。
◎
Cancels the timeout set with setTimeout() or setInterval() identified by handle.
</dd>

	<dt>%handle = self . `setInterval( handler [, timeout [, arguments... ] ] )$m</dt>
	<dd>
%timeout ~milli秒ごとに
%handler を走らす~timeoutを~scheduleする。
%arguments は そのまま %handler に渡される。
%timeout が負の場合、歴史を %timeout ~milli秒ずつ遡りながら
%handler を走らすことになる。
◎
Schedules a timeout to run handler every timeout milliseconds. Any arguments are passed straight through to the handler. If timeout is negative, this will run handler backward throughout history at an interval of timeout milliseconds.
</dd>

	<dt>%handle = self . `setInterval( code [, timeout ] )$m</dt>
	<dd>
%timeout ~milli秒ごとに
%code を~compileしてを走らす~timeoutを~scheduleする。
%timeout が負の場合、歴史を %timeout ~milli秒ずつ遡りながら走らすことになる。
◎
Schedules a timeout to compile and run code every timeout milliseconds. If timeout is negative, this will compile and run code backward throughout history at an interval of timeout milliseconds.
</dd>

	<dt>self . `clearInterval( handle )$m</dt>
	<dd>
［
`setTimeout()$m ／ `setInterval()$m
により設定された~timeout
］のうち， %handle で識別されるものを取消す。
◎
Cancels the timeout set with setInterval() or setTimeout() identified by handle.
</dd>
</dl>

<p class="note">
~timerは、入子にできる。
ただし、そのような入子にされた~timerが 5 個を超えて以降は，~intervalは、 4 ~milli秒~以上に強制される。
◎
Timers can be nested; after five such nested timers, however, the interval is forced to be at least four milliseconds.
</p>

<p class="note">
この~APIは、~timerが正確に~schedule通りに走らすことは保証しない。
［
CPU 負荷,
time travel paradoxes,
他の~task
］, 等々に因る延期が予期される。
◎
This API does not guarantee that timers will run exactly on schedule. Delays due to CPU load, time travel paradoxes, other tasks, etc, are to be expected.
</p>

<p>
`WindowOrWorkerGlobalScope$I
~mixinを実装する~objは、
`作動中の~timer~list@
を持つ。
この~list内の各~entryは、
数で識別される。
それらの数は、~objが存続する限り，~listの中で一意で~MUST。
◎
Objects that implement the WindowOrWorkerGlobalScope mixin have a list of active timers. Each entry in this lists is identified by a number, which must be unique within the list for the lifetime of the object that implements the WindowOrWorkerGlobalScope mixin.
</p>

<hr>

<dl class="idl-def">
	<dt>`setTimeout()@m</dt>
	<dd>
<p>
被呼出時には、［
次を渡した下で，`~timer初期化~手続き$から返される値
］を返さ~MUST：
</p>

<ul ><li>%~method引数~list ~SET ~methodに渡された引数~list
</li><li>%~method文脈 ~SET 此れ
</li><li>%繰返~flag ~SET ~OFF
</li></ul>
◎
The setTimeout() method must return the value returned by the timer initialization steps, passing them the method's arguments, the object on which the method for which the algorithm is running is implemented (a Window or WorkerGlobalScope object) as the method context, and the repeat flag set to false.
</dd>

	<dt>`setInterval()@m</dt>
	<dd>
<p>
被呼出時には、［
次を渡した下で，`~timer初期化~手続き$から返される値
］を返さ~MUST：
</p>

<ul ><li>%~method引数~list ~SET ~methodに渡された引数~list
</li><li>%~method文脈 ~SET 此れ
</li><li>%繰返~flag ~SET ~ON
</li></ul>
◎
The setInterval() method must return the value returned by the timer initialization steps, passing them the method's arguments, the object on which the method for which the algorithm is running is implemented (a Window or WorkerGlobalScope object) as the method context, and the repeat flag set to true.
</dd>

	<dt>`clearTimeout(handle)@m</dt>
	<dt>`clearInterval(handle)@m</dt>
	<dd>
これらのいずれも，被呼出時には、此れの`作動中の~timer~list$内に
%handle により識別される~entryがあれば、それを~clearし~MUST
（なければ何もしない）。
◎
The clearTimeout() and clearInterval() methods must clear the entry identified as handle from the list of active timers of the WindowOrWorkerGlobalScope object on which the method was invoked, if any, where handle is the argument passed to the method. (If handle does not identify an entry in the list of active timers of the WindowOrWorkerGlobalScope object on which the method was invoked, the method does nothing.)
</dd>
	<dd class="note">
両~methodとも，同じ~listに属する~entryを~clearするので、いずれも
`setTimeout()$m ／ `setInterval()$m
で作成された~timerを~clearするのに利用できる。
◎
Because clearTimeout() and clearInterval() clear entries from the same list, either method can be used to clear timers created by setTimeout() or setInterval().
</dd>
</dl>

<hr>


<div >
<p>
`~timer初期化~手続き@
は、所与の：
</p>

<ul ><li>%~method引数~list
</li><li>%~method文脈
</li><li>%繰返~flag
</li><li>%前回handle（省略時は ε，非 ε にされるのは %繰返~flag ~EQ ~ON の場合に限られる）
</li></ul>

<p>
に対し，次を走らす：
</p>
◎
The timer initialization steps, which are invoked with some method arguments, a method context, a repeat flag which can be true or false, and optionally (and only if the repeat flag is true) a previous handle, are as follows:
</div>

<ol>
	<li>
%~method文脈~proxy ~LET %~method文脈 に応じて
⇒
`WorkerGlobalScope$I ~objであるならば %~method文脈 ／
`Window$I ~objであるならば %~method文脈 に対応する `WindowProxy$I ~obj
◎
Let method context proxy be method context if that is a WorkerGlobalScope object, or else the WindowProxy that corresponds to method context.
</li>
	<li>
%handle ~LET %前回handle
</li>
	<li>
~IF［
%handle ~EQ ε
］
⇒
%handle ~SET
~UA により定義される非負~整数であって，この~callにより`作動中の~timer~list$に設定される~timeoutを識別するもの
◎
If previous handle was provided, let handle be previous handle; otherwise, let handle be a user-agent-defined integer that is greater than zero that will identify the timeout to be set by this call in the list of active timers.
</li>
	<li>
~IF［
%前回handle ~EQ ε
］
⇒
%handle に対する~entryを
`作動中の~timer~list$に追加する
◎
If previous handle was not provided, add an entry to the list of active timers for handle.
</li>
	<li>
( %callerRealm, %calleeRealm ) ~LET
( `現在の~Realm~Record$js, %~method文脈 の`~JS~realm$js )
◎
Let callerRealm be the current Realm Record, and calleeRealm be method context's JavaScript realm.
</li>
	<li>
<p>
%~task ~LET 次の下位手続きを走らす`~task$：
◎
Let task be a task that runs the following substeps:
</p>
		<ol>
			<li>
~IF［
`作動中の~timer~list$内に
%handle に対応する~entryはない
］
⇒
~RET
◎
If the entry for handle in the list of active timers has been cleared, then abort this task's substeps.
</li>
			<li>
%S ~LET %~method引数~list の最初の引数
</li>
			<li>
~IF［
%S は `Function$I である
］
⇒
次を与える下で %S を`呼出す$x
⇒
引数~list： 3 個目~以降の引数（空にもなり得る）<br>
`~callback this 値$x： %~method文脈~proxy
◎
Run the appropriate set of steps from the following list:
◎
Invoke the Function. Use the third and subsequent method arguments (if any) as the arguments for invoking the Function. Use method context proxy as the callback this value.
</li>
			<li>
<p>
~ELSE
⇒
</p>
				<ol>
					<li>
`HostEnsureCanCompileStrings$jA( %callerRealm, %calleeRealm )
を遂行する
⇒
例外が投出された場合は、その`例外を報告する$；<br>
~RET `この ~RET は訳者による推定^tnote
◎
Perform HostEnsureCanCompileStrings(callerRealm, calleeRealm). If this throws an exception, report the exception.
</li>
					<li>
%~script ~LET
次を与える下で `~classic~scriptを作成-$した結果
⇒
( %S, %~method文脈 の`環境~設定群~obj$ )
◎
Let script source be the first method argument.
◎
Let settings object be method context's environment settings object.
◎
Let script be the result of creating a classic script using script source and settings object.
</li>
					<li>
%~script を与える下で`~classic~scriptを走らす$
◎
Run the classic script script.
</li>
				</ol>
			</li>
			<li>
~IF［
%繰返~flag ~EQ ~ON
］
⇒
次を与える下で，`~timer初期化~手続き$を再度~callする
⇒
%~method引数~list ~SET %~method引数~list,<br />
%~method文脈 ~SET %~method文脈,<br />
%繰返~flag ~SET ~ON,<br />
%前回handle ~SET %handle<!-- ＊handler 誤記 -->
◎
If the repeat flag is true, then call timer initialization steps again, passing them the same method arguments, the same method context, with the repeat flag still set to true, and with the previous handle set to handler.
</li>
		</ol>
	</li>
	<li>
%timeout ~LET  %~method引数~list の 2 個目の引数
◎
Let timeout be the second method argument.
</li>
	<li>
<p>
%入子~level ~LET［
現在~走っている`~task$は，この~algoにより作成された`~task$ならば
その~taskの`~timerの入子~level$ ／
~ELSE_ ~zero
］
◎
If the currently running task is a task that was created by this algorithm, then let nesting level be the task's timer nesting level. Otherwise, let nesting level be zero.
</p>

<p class="note">
~taskの`~timerの入子~level$は、［
`setTimeout()$m に対する入子の~call，
`setInterval()$m により作成される繰返しの~timer
］のいずれに対しても利用される（この 2 つが混在する入子もあり得る）。
言い換えれば、特定0の~methodではなく，この~algoの入子の呼出を表現する。
◎
The task's timer nesting level is used both for nested calls to setTimeout(), and for the repeating timers created by setInterval(). (Or, indeed, for any combination of the two.) In other words, it represents nested invocations of this algorithm, not of a particular method.
</p>
   </li>
	<li>
~IF［
%入子~level ~GT 5
］~AND［
%timeout ~LT 4
］
⇒
%timeout ~SET 4
◎
If nesting level is greater than 5, and timeout is less than 4, then increase timeout to 4.
</li>
	<li>
%入子~level ~INCBY 1
◎
Increment nesting level by one.
</li>
	<li>
%~task の`~timerの入子~level@
~LET %入子~level
◎
Let task's timer nesting level be nesting level.
</li>
	<li>
~RET %handle
— ただし、この~algoの以降の部分も`並列的$に走らせる
◎
Return handle, and then continue running this algorithm in parallel.
</li>
	<li>
<p>
~IF［
%timeout ~GTE 0
］：
◎
If timeout is nonnegative:
</p>
		<ol>
			<li>
<p>
%~method文脈 に応じて：
</p>
				<dl class="switch">
					<dt>`Window$I ~objである場合：</dt>
					<dd>
%~method文脈 に`結付けられている文書$が`全部的に作動中$になるまで
更に %timeout ~milli秒~待機する（連続的でなくともよい `？^tnote ）。
</dd>

					<dt>`WorkerGlobalScope$I ~objである場合：</dt>
					<dd>
~workerを休止せずに %timeout ~milli秒~待機する（連続的でなくともよい）。
</dd>
				</dl>
◎
If method context is a Window object, wait until the Document associated with method context has been fully active for a further timeout milliseconds (not necessarily consecutively).
◎
Otherwise, method context is a WorkerGlobalScope object; wait until timeout milliseconds have passed with the worker not suspended (not necessarily consecutively).
</li>
			<li>
<div class="p">
<p>
この~algoのこの呼出 %A とは別の，この~algoの呼出 %B たちのうち，次をすべて満たすものがあれば，それらが完了するまで待機する：
</p>

<ul ><li>%B は完了していない
</li><li>( %B における %~method文脈 ) ~EQ ( %A における %~method文脈 )
</li><li>%B は %A より先に呼出された
</li><li>( %B における %timeout ) ~LTE ( %A における %timeout ) †
</li></ul>

<p class="trans-note">【†
例えば ( %A, %B ) における %timeout が ( 1, 2 ) の場合、
%B が %A の 100 ~milli秒~先に呼出されていても，
%A から先に実行される余地があることになる。
（ひょっとして、原文の %timeout は時間長そのままではなく，それが指す時点を意図している？）
】</p>

◎
Wait until any invocations of this algorithm that had the same method context, that started before this one, and whose timeout is equal to or less than this one's, have completed.
</div>


<p class="note">
Web IDL に定義されるように、引数の変換は，この~algoが呼出される前に Web IDL にて定義される~algo内で起こる
— 例えば、最初の引数として渡された ~obj上の `toString()^m ~methodを呼出すような：
◎
Argument conversion as defined by Web IDL (for example, invoking toString() methods on objects passed as the first argument) happens in the algorithms defined in Web IDL, before this algorithm is invoked.
</p>


<div class="example">

<p>
例えば、次のちっぽけな~codeによる結果の %log は
`ONE&nbsp;TWO&nbsp;^l
になる：
◎
So for example, the following rather silly code will result in the log containing "ONE TWO ":
</p>


<pre>
var %log = '';
function logger(%s) { %log += %s + ' '; }

setTimeout({ toString: function () {
  setTimeout("logger('ONE')", 100);
  return "logger('TWO')";
} }, 100);
</pre>

</div>

			</li>
			<li>
<p>
~UAの任意選択で
⇒
~UAにより定義される時間だけ待機する。
◎
Optionally, wait a further user-agent defined length of time.
</p>

<p class="note">
この段が意図する所は、~UAが機器の電力消費を最適化する必要に応じて，~timeoutを~~延長できるようにするためである。
例えば、~timerの粒度を抑えるような節電~modeを有する~processorも中にはあり、そのような~platform上では，~UAは，より正確0な非~節電~modeを利用することを要求する代わりに，この~scheduleに見合うように~timerを遅めれる。
◎
This is intended to allow user agents to pad timeouts as needed to optimize the power usage of the device. For example, some processors have a low-power mode where the granularity of timers is reduced; on such platforms, user agents can slow timers down to fit this schedule instead of requiring the processor to use the more accurate mode with its associated higher power usage.
</p>

			</li>
			<li>
<p>
`~task$ %~task を`待入する$
◎
Queue the task task.
</p>

<p class="note">
［
%繰返~flag ~EQ ~OFF
］の下では、~taskの処理-後に，`作動中の~timer~list$から %handle に対応する~entryを除去しても安全である（この時点を過ぎて以降，~entryの存在を検出する仕方はないので、技術的に問題0になることはない）。
◎
Once the task has been processed, if the repeat flag is false, it is safe to remove the entry for handle from the list of active timers (there is no way for the entry's existence to be detected past this point, so it does not technically matter one way or the other).
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ %timeout ~LT 0 ）
◎
Otherwise, timeout is negative:
</p>
		<ol>
			<li>
%過去~timeout ~LET −%timeout
◎
Let timeoutInThePast be -timeout.
</li>
			<li>
~UAを
<a href="https://www.youtube.com/watch?v=k0kswK2aI08">毎時 88 マイル</a>
加速する
◎
Accelerate the user agent to 88 miles per hour.
</li>
			<li>
%過去~timeout ~milli秒だけ過去へ遡る
◎
Travel backward in time by timeoutInThePast milliseconds.
</li>
			<li>
<p>
%~task を`待入する$
◎
Queue the task task.
</p>

<p class="note">
これは %過去~timeout が大きくなるほど難しくなる。
例えば、~UAの~bugは過去に遡るほど多いことは周知なので、開発者は，年／月単位の負の~timeoutを利用するときには、その頃には無かった特色機能や既知の~bugから回復できるよう注意深く~codeを書く必要がある。
我々は、彼らがこの特色機能を責任をもって利用することを確信している。
◎
This will become more difficult the larger timeoutInThePast gets. For example, user agents are known to be more buggy in the past, and so when using negative timeouts on the order of months or years, developers will need to take care to write code that is resilient to missing features or known bugs during that time. We have every confidence they will use this feature responsibly.
</p>
			</li>
		</ol>
	</li>
</ol>

<p>
これらの`~task$の`~task源$は、
`~timer~task源@
とする。
◎
The task source for these tasks is the timer task source.
</p>

<div class="example">

<p>
数~milli秒かかる~taskを間断なく延期なしに走らせつつ，~browserにも~UIに応じる余裕を与える（および，~browserが CPU 時間を得るために~scriptを強制終了しないようにする）ためには、単純に仕事を遂行する前に次回の~timerを待入する：
◎
To run tasks of several milliseconds back to back without any delay, while still yielding back to the browser to avoid starving the user interface (and to avoid the browser killing the script for hogging the CPU), simply queue the next timer before performing work:
</p>

<pre>
function doExpensiveWork() {
  var %done = false;
  // ...
  /* <span class="comment">
この部分は、 %done を ~T に設定するまでに数~milli秒かかる
◎
this part of the function takes up to five milliseconds set done to true if we're done
</span> */
  // ...

  return %done;
}

function rescheduleWork() {
  var %handle = setTimeout(rescheduleWork, 0); /*
      <span class="comment">
次回の反復を予め~scheduleしておく
◎
preschedule next iteration
</span> */
  if (doExpensiveWork())
    clearTimeout(%handle); /*
      <span class="comment">
用済みになったら~timeoutを~clearする
◎
clear the timeout if we don't need it
</span> */
}

function scheduleWork() {
  setTimeout(rescheduleWork, 0);
}

scheduleWork(); /*
  <span class="comment">
たくさんの仕事を行う~taskを待入する
◎
queues a task to do lots of work
</span> */
</pre>

</div>


<div class="example">
<p>
<a href="https://github.com/whatwg/html/issues/2079">今や除去された</a>
`keygen$e 要素を~pinしていたなら、 1999 年まで過去へ遡って用立てることもできる：
◎
If you have been pining after the now-removed keygen element, you can travel into the past and party like it's 1999:
</p>
<pre>setTimeout(function () {
  var %keygen = %document.createElement("keygen");
  // <span class="comment">%keygen を何か ... に利用する。</span>
}, new Date(1999, 0, 1) - Date.now());</pre>

<p>
（ 1999 年頃は、まだ~arrow関数や `let^c ／ `const^c 宣言の様な現代の~JS特色機能は利用できないので、 `keygen$e を甦らすには少し手間も要ることに注意。）
◎
(Note how in 1999 we cannot use modern JavaScript features like arrow functions or let/const declarations. A small price to pay for resurrecting keygen.)
</p>

</div>

<div class="example">

<p>
過去に遡って，この HTML 標準に負の~timeout特色機能が追加されないようにするには、次の様な~codeで行えるであろう：
◎
To travel back in time and prevent the negative-timeout feature from ever being added to the HTML Standard, code like the following might do the job:
</p>

<pre>const %dayAdded = new Date("2017-04-01");
const %dayBefore = %dayAdded - 24 * 60 * 60 * 1000;
const %timeOffset = %dayBefore - Date.now();

setTimeout(() =&gt; {
  openGitHubIssue(
    "whatwg/html", "やめてください！",
    "その革命的な特色機能を明日にでも追加したいと考えていることはわかってますが、それは運命を変えてしまうので絶対しないように。");
}, %timeOffset);
</pre>

<p>
しかしながら、利用されている実装に特有の~time-travel技術の詳細に依存して，これは危険になるかもしれない。
◎
However, depending on the specific implementation details of the time-travel technology used, this may be hazardous.
</p>
</div>


		</section>
		<section id="user-prompts">
<h2 title="User prompts">8.6. 利用者~向けの~prompt</h2>


			<section id="simple-dialogs">
<h3 title="Simple dialogs">8.6.1. 単純な~dialog</h3>

  <dl class="domintro">
	<dt>%window . `alert(message)$m</dt>
	<dd>
所与の~messageを伴う~modal~alertを表示した上で、利用者がそれを退けるまで待機する。
◎
Displays a modal alert with the given message, and waits for the user to dismiss it.
</dd>

	<dt>%result = %window . `confirm(message)$m</dt>
	<dd>
所与の~messageを伴う［
OK ／ Cancel
］~modal~promptを表示して、利用者が退けるまで待機する。
利用者が［
OK を~clickしたなら ~T ／
Cancel を~clickしたなら ~F
］を返す。
◎
Displays a modal OK/Cancel prompt with the given message, waits for the user to dismiss it, and returns true if the user clicks OK and false if the user clicks Cancel.
</dd>

	<dt>%result = %window . `prompt(message [, default] )$m</dt>
	<dd>
~text~control, および所与の~messageを伴う~modal~promptを表示して、利用者がそれを退けるまで待機する。
利用者が［
~promptを取消したなら ~NULL ／
~ELSE_ 利用者が手入力した値
］を返す。
%default 引数が在る場合、その値が既定の~~入力として利用される。
◎
Displays a modal text control prompt with the given message, waits for the user to dismiss it, and returns the value that the user entered. If the user cancels the prompt, then returns null instead. If the second argument is present, then the given value is used as a default.
</dd>

</dl>

<p class="note">
これらの~methodが呼出された場合、`~media~data$を読込んでいる`~media要素$などの
`~task$ ／ `極小task$
に依存する~logicは停滞する。
◎
Logic that depends on tasks or microtasks, such as media elements loading their media data, are stalled when these methods are invoked.
</p>

<p>
所与の文字列 %s を
`任意選択で短縮-@
するときは、［
%s そのままか，または %s から導出されるより短い何らかの文字列
］を返す。
~UAは、 %s から省かれた部位を表示するための ~UIは提供するべきでない
— そうすると
“保安に関する重要事項です。次を~clickして全部的な詳細を読んで下さい。”
のような類の~dialogを簡単に作成できてしまい，濫用され易くなるので。
◎
To optionally truncate a simple dialog string s, return either s itself or some string derived from s that is shorter. User agents should not provide UI for displaying the elided portion of s, as this makes it too easy for abusers to create dialogs of the form "Important security alert! Click 'Show More' for full details!".
</p>

<p class="note">
例えば~UAは、~messageの最初の 100 文字だけ表示したり，文字列を "…" で中略するよう求めるかもしれない。
この種の改変は、不自然に巨大な, もっともらしい~system~dialogに濫用される~~可能性を制限するのに有用になり得る。
◎
For example, a user agent might want to only display the first 100 characters of a message. Or, a user agent might replace the middle of the string with "…". These types of modifications can be useful in limiting the abuse potential of unnaturally large, trustworthy-looking system dialogs.
</p>

<div >
<p class="algo-head">
所与の %window 上で
`~promptを示すかどうか決定-@
するときは、次を走らす：
</p>

<p class="trans-note">【
この手続きは、この訳により，各種~methodに共通するふるまいを抜き出して集約したものである。
】</p>

<ol>
	<li>
%文書 ~LET %window に`結付けられている文書$
</li>
	<li>
~IF［
%文書 が`属する閲覧文脈$の`~event-loop$の`終了の入子~level$ ~NEQ 0
］
⇒
~UAの任意選択で
⇒
~RET `示さない^i
</li>
	<li>
~IF［
`~sandbox化( ~modal )~flag$ ~IN ［
%文書 にて`作動中の~sandbox用~flag集合$
］］
⇒
~RET `示さない^i
</li>
	<li>
~UAの任意選択で
⇒
~RET `示さない^i
（例えば，~UAは、利用者に，以降の~alert／~promptすべてを無視する選択肢を供することもできる
— 利用者がその選択肢を選んだ場合、この手続きを呼出した~methodは，それ以降 呼出される度に，この段で中止されることになる。）
</li>
	<li>
~RET `示す^i
</li>
</ol>


◎
↓</div>


<dl class="idl-def">
	<dt>`alert(message)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The alert(message) method, when invoked, must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れ上で`~promptを示すかどうか決定-$した結果 ~EQ `示さない^i
］
⇒
~RET
◎
If the event loop's termination nesting level is non-zero, optionally abort these steps.
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then abort these steps.
◎
Optionally, abort these steps. (For example, the user agent might give the user the option to ignore all alerts, and would thus abort at this step whenever the method was invoked.)
</li>
			<li>
~IF［
%message は与えられていない
］
⇒
%message ~SET 空~文字列
◎
If the method was invoked with no arguments, then let message be the empty string; otherwise, let message be the method's first argument.
</li>
			<li>
%message ~SET %message を`任意選択で短縮-$した結果
◎
Set message to the result of optionally truncating message.
</li>
			<li>
%message を利用者に示す
◎
Show message to the user.
</li>
			<li>
~UAの任意選択で
⇒
利用者が~messageを認めるまで`一時停止-$する
◎
Optionally, pause while waiting for the user to acknowledge the message.
</li>
		</ol>
	</dd>

	<dt>`confirm(message)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The confirm(message) method, when invoked, must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れ上で`~promptを示すかどうか決定-$した結果 ~EQ `示さない^i
］
⇒
~RET ~F
◎
If the event loop's termination nesting level is non-zero, optionally abort these steps, returning false.
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then abort these steps.
◎
Optionally, return false and abort these steps. (For example, the user agent might give the user the option to ignore all prompts, and would thus abort at this step whenever the method was invoked.)
</li>
			<li>
%message ~SET %message を`任意選択で短縮-$した結果
◎
Set message to the result of optionally truncating message.
</li>
			<li>
%message を利用者に示して，利用者に肯定か否定か訊ねる
◎
Show message to the user, and ask the user to respond with a positive or negative response.
</li>
			<li>
利用者が応答するまで`一時停止-$する
◎
Pause until the user responds either positively or negatively.
</li>
			<li>
~RET 利用者の応答に応じて
⇒
肯定ならば ~T ／ 否定ならば ~F
◎
If the user responded positively, return true; otherwise, the user responded negatively: return false.
</li>
		</ol>
	</dd>

	<dt>`prompt(message, default)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The prompt(message, default) method, when invoked, must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れ上で`~promptを示すかどうか決定-$した結果 ~EQ `示さない^i
］
⇒
~RET ~NULL
◎
If the event loop's termination nesting level is non-zero, optionally abort these steps, returning null.
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then abort these steps.
◎
Optionally, return null and abort these steps. (For example, the user agent might give the user the option to ignore all prompts, and would thus abort at this step whenever the method was invoked.)
</li>
			<li>
%message ~SET %message を`任意選択で短縮-$した結果
◎
Set message to the result of optionally truncating message.
</li>
			<li>
%default ~SET %default を`任意選択で短縮-$した結果
◎
Set default to the result of optionally truncating default.
</li>
			<li>
%message を利用者に示し、既定の応答を %default 値にする下で，利用者に 文字列~値で応答するか中止するか訊ねる
◎
Show message to the user, and ask the user to either respond with a string value or abort. The response must be defaulted to the value given by default.
</li>
			<li>
利用者が応答するまで`一時停止-$する
◎
Pause while waiting for the user's response.
</li>
			<li>
~RET［
利用者が中止したならば ~NULL ／
~ELSE_  利用者が応答した文字列
］
◎
If the user aborts, then return null; otherwise, return the string that the user responded with.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="printing">
<h3 title="Printing">8.6.2. 印刷ing</h3>

<dl class="domintro">
	<dt>%window . `print()$m</dt>
	<dd>
利用者に頁を印刷する旨を~promptする。
◎
Prompts the user to print the page.
</dd>

</dl>


<dl class="idl-def">
	<dt>`print()@m</dt>
	<dd>
<p>
被呼出時には次を走らせ~MUST：
</p>

		<ol>
			<li>
%文書 ~LET 此れに`結付けられている文書$
</li>
			<li>
~IF［
%文書 の`読込み後~taskは準備済み$である
］
⇒
%文書 の`印刷-時の手続き$を`並列的$に走らす
</li>
			<li>
~ELSE
⇒
%文書 の
`読込み時に印刷する~flag@
~SET ~ON
</li>
		</ol>

◎
When the print() method is invoked, if the Document is ready for post-load tasks, then the user agent must run the printing steps in parallel. Otherwise, the user agent must only set the print when loaded flag on the Document.
</dd>
</dl>




<p>
~UAは、利用者から文書 %文書 の`物理形を得る$（例：印刷, あるいは ~PDF などの物理形の表現も含む）機会を請われたときも、`印刷-時の手続き$を走らすべきである。
◎
User agents should also run the printing steps whenever the user asks for the opportunity to obtain a physical form (e.g. printed copy), or the representation of a physical form (e.g. PDF copy), of a document.
</p>

<p>
所与の %文書 の
`印刷-時の手続き@
は、次に従う：
◎
The printing steps are as follows:
</p>

`27864$bug

<ol>
	<li>
<p>
~UAの任意選択で、次のいずれかまたは両方を行う：
◎
The user agent may display a message to the user or abort these steps (or both).
</p>

<ul ><li>利用者に~messageを表示する
</li><li>~RET
</li></ul>

<p class="example">
具体例として，~kiosk~browserは、
`print()$m ~methodに対する呼出すべてを黙って無視することもできる。
◎
For instance, a kiosk browser could silently ignore any invocations of the print() method.
</p>

<p class="example">
具体例として，~mobile機器~上の~browserは、近くに印刷機がないことを検出したなら，
“~PDFに保存”
の選択肢を提供0するに先立って その旨を述べる~messageを表示することもできる。
◎
For instance, a browser on a mobile device could detect that there are no printers in the vicinity and display a message saying so before continuing to offer a "save to PDF" option.
</p>
	</li>
	<li>
<p>
~IF［
`~sandbox化( ~modal )~flag$ ~IN
%文書 にて`作動中の~sandbox用~flag集合$
］
⇒
~RET
◎
If the active sandboxing flag set of this Window object's associated Document has the sandboxed modals flag set, then abort these steps.
</p>

<p class="note">
印刷ing~dialogが %文書 の~sandboxで阻止された場合、
`beforeprint$et ／ `afterprint$et
~eventは発火されない。
◎
If the printing dialog is blocked by a Document's sandbox, then neither the beforeprint nor afterprint events will be fired.
</p>
	</li>
	<li>
%文書~list ~LET  %文書, および［
%文書 の`子孫~閲覧文脈~list$内の各 `閲覧文脈$にて`作動中の文書$
］からなる~list
◎
↓</li>
	<li>
<p>
%文書~list 内の ~EACH ( %D ) に対し
⇒
%D を`結付けている~window$に向けて，名前 `beforeprint$et の`~eventを発火-$する
◎
The user agent must fire an event named beforeprint at the Window object of the Document that is being printed, as well as any nested browsing contexts in it.
</p>

<p class="example">
`beforeprint$et ~eventは、
印刷される複製に注釈を加えるときに利用できる
— 具体例として，印刷した時刻を追加するなど。
◎
The beforeprint event can be used to annotate the printed copy, for instance adding the time at which the document was printed.
</p>

	</li>
	<li>
<p>
~UAは、利用者に %文書 の`物理形を得る$（または その表現を得る）機会を提供0するべきである
— そうする場合
⇒
利用者が受容するか辞退するまで待機してよい
— そうする場合
⇒
待機-中は`一時停止-$し~MUST。
</p>

<p>
待機するかどうかにかかわらず、当の物理形には，この~algoのこの時点における %文書 の状態を利用し~MUST。
</p>
◎
The user agent should offer the user the opportunity to obtain a physical form (or the representation of a physical form) of the document. The user agent may wait for the user to either accept or decline before returning; if so, the user agent must pause while the method is waiting. Even if the user agent doesn't wait at this point, the user agent must use the state of the relevant documents as they are at this point in the algorithm if and when it eventually creates the alternate form.
</li>
	<li>
<p>
%文書~list 内の ~EACH ( %D ) に対し
⇒
~IF［
%D が`属する閲覧文脈$はまだある
`この条件は訳者による補完^tnote
］
⇒
%D を`結付けている~window$に向けて，名前 `afterprint$et の`~eventを発火-$する
◎
The user agent must fire an event named afterprint at the Window object of the Document that is being printed, as well as any nested browsing contexts in it.
</p>

<p class="example">
`afterprint$et ~eventは、 `beforeprint$et ~event時に追加された注釈を復帰するため, あるいは 印刷ing後の~UIを示すためにも利用できる。
後者の具体例としては、利用者に 何段階かにわたる手続きを踏んでもらう頁があるとき、~scriptは，印刷-後に 自動的に次の段階へ進めることもできる。
◎
The afterprint event can be used to revert annotations added in the earlier event, as well as showing post-printing UI. For instance, if a page is walking the user through the steps of applying for a home loan, the script could automatically advance to the next step after having printed a form or other.
</p>

	</li>
</ol>



			</section>
		</section>
		<section id="system-state-and-capabilities">
<h2 title="System state and capabilities">8.7. ~systemの状態と能力</h2>

<p class="trans-note">【
この節の内容の和訳は、
<a href="~HTMLnavigator">別ページ</a>
にて。
】</p>

		</section>
		<section id="images-2">
<h2 title="Images">8.8. 画像</h2>

<pre class="idl">
[Exposed=(Window,Worker), `Serializable$, `Transferable$]
interface `ImageBitmap@I {
  readonly attribute unsigned long `width$m;
  readonly attribute unsigned long `height$m;
  void `close$m();
};

typedef (`CanvasImageSource$I or
         `Blob$I or
         `ImageData$I) `ImageBitmapSource@I;

enum `ImageOrientation@I { `~none1$l, `flipY$l };
enum `PremultiplyAlpha@I { `none$l, `premultiply$l, `default$l };
enum `ColorSpaceConversion@I { `~none0$l, `~default0$l };
enum `ResizeQuality@I { `pixelated$l, `low$l, `medium$l, `high$l };

dictionary `ImageBitmapOptions@I {
  `ImageOrientation$I `imageOrientation$m = `~none1$l;
  `PremultiplyAlpha$I `premultiplyAlpha$m = `default$l;
  `ColorSpaceConversion$I `colorSpaceConversion$m = `~default0$l;
  [EnforceRange] unsigned long `resizeWidth$m;
  [EnforceRange] unsigned long `resizeHeight$m;
  `ResizeQuality$I `resizeQuality$m = `low$l;
};
</pre>

 
<p>
`ImageBitmap$I ~objは、過度の遅延なく~canvasに塗れるような，~bitmap画像を表現する。
◎
An ImageBitmap object represents a bitmap image that can be painted to a canvas without undue latency.
</p>

 
<p class="note">
何を以って過度の遅延とするかの正確な判断は実装者に委ねられるが、一般に，~bitmapの利用~時に
~network I/O, や~local~disk I/O を要するならば，遅延はおそらく過度になる。
一方で GPU や~system RAM からの~~排他~読取りのみを要求するならば、遅延はおそらく受容し得る。
◎
The exact judgement of what is undue latency of this is left up to the implementer, but in general if making use of the bitmap requires network I/O, or even local disk I/O, then the latency is probably undue; whereas if it only requires a blocking read from a GPU or system RAM, the latency is probably acceptable.
</p>

<dl class="domintro">

	<dt>%promise = self . `createImageBitmap$m(%image [, %options ])</dt>
	<dt>%promise = self . `createImageBitmap$m(%image, %sx, %sy, %sw, %sh [, %options ])</dt>
	<dd>
所与の %image から新たな `ImageBitmap$I が作成された時点で解決される，~promiseを返す
— %image は次のいずれかをとり得る
⇒
`img$e 要素 ／
`~SVG-image$ 要素 ／
`video$e 要素 ／
`canvas$e 要素 ／
`Blob$I ~obj ／
`ImageData$I ~obj ／
別の `ImageBitmap$I ~obj
◎
Takes image, which can be an img element, an SVG image element, a video element, a canvas element, a Blob object, an ImageData object, or another ImageBitmap object, and returns a promise that is resolved when a new ImageBitmap is created.
</dd>
	<dd>
`ImageBitmap$I ~objを構築できなかった場合
— 例えば、供された %image ~dataが実際には画像でなかったなど —
~promiseは却下される。
◎
If no ImageBitmap object can be constructed, for example because the provided image data is not actually an image, then the promise is rejected instead.
</dd>
	<dd>
%sx, %sy, %sw, %sh
引数が供された場合、~source画像は，それらが成す矩形に~cropされる
— 元の画像に無い画素は、黒地透明に置換される。<!-- ＊ clip？ -->
これらの座標は、~source画像の~pixel座標~空間であり，`~CSS~pixel$単位<em>ではない</em>。
◎
If sx, sy, sw, and sh arguments are provided, the source image is cropped to the given pixels, with any pixels missing in the original replaced by transparent black. These coordinates are in the source image's pixel coordinate space, not in CSS pixels.
</dd>
	<dd>
%options が供された場合、
`ImageBitmap$I ~objの~bitmap~dataは， %options に則って改変される。
例えば［
%options の `premultiplyAlpha$m ~option ~EQ `premultiply$l
］ならば、`~bitmap~data$ の各~色~channelは その~alpha~channelにより積算済みにされる。
◎
If options is provided, the ImageBitmap object's bitmap data is modified according to options. For example, if the premultiplyAlpha option is set to "premultiply", the bitmap data's color channels are premultiplied by its alpha channel.
</dd>
	<dd>
<p>
~source画像の状態が妥当でない場合、~promiseは `InvalidStateError$E で却下される
— 例えば：
</p>

<ul ><li>成功裡に読込まれなかった `img$e 要素
</li><li>`ImageBitmap$I ~objであって［
`Detached$sl 内部~slot値 ~EQ ~T
］なるもの
</li><li>`ImageData$I ~objであって［
`data$m 属性~値の `Detached$sl 内部~slot値 ~EQ ~T
］なるもの
</li><li>`Blob$I であって その~dataを~bitmap画像に解釈できないもの
</li></ul>

◎
Rejects the promise with an "InvalidStateError" DOMException if the source image is not in a valid state (e.g. an img element that hasn't loaded successfully, an ImageBitmap object whose [[Detached]] internal slot value is true, an ImageData object whose data attribute value's [[Detached]] internal slot value is true, or a Blob whose data cannot be interpreted as a bitmap image).
</dd>
	<dd>
~scriptから~source画像の画像~dataへの~accessは許容されない場合、
~promiseは `SecurityError$E `DOMException$I で却下される（例：
`~CORS非同一生成元$の `video$e ／
別の`生成元$からの~worker内の~scriptにより描かれている `canvas$e
）。
◎
Rejects the promise with a "SecurityError" DOMException if the script is not allowed to access the image data of the source image (e.g. a video that is CORS-cross-origin, or a canvas being drawn on by a script in a worker from another origin).
</dd>

	<dt>%imageBitmap . `close$m()</dt>
	<dd>
%imageBitmap の下層の`~bitmap~data$を解放する。
◎
Releases imageBitmap's underlying bitmap data.
</dd>

	<dt>%imageBitmap . `width$m</dt>
	<dd>
画像の`内在的~横幅$を`~CSS~pixel$単位で返す。
◎
Returns the intrinsic width of the image, in CSS pixels.
</dd>

	<dt>%imageBitmap . `height$m</dt>
	<dd>
画像の`内在的~縦幅$を`~CSS~pixel$単位で返す。
◎
Returns the intrinsic height of the image, in CSS pixels.
</dd>

</dl>

<p>
各 `ImageBitmap$I %O は：
◎
↓</p>

<ul>
	<li>
［
%O の `Detached$sl 内部~slot値 ~EQ ~F
］ならば、常に
横幅, 縦幅を伴う
`~bitmap~data@
が結付けられる
`~T にされたときは、この~dataは解放される（ ε にされる）^tnote
。
しかしながら、この~dataは壊れていることもあり得る。
`ImageBitmap$I ~objは、その~media~dataが~errorなしに復号できるならば，
`全部的に復号可能@
と呼ばれる。
◎
An ImageBitmap object whose [[Detached]] internal slot value is false always has associated bitmap data, with a width and a height. However, it is possible for this data to be corrupted. If an ImageBitmap object's media data can be decoded without errors, it is said to be fully decodable.
</li>
<li>
%O の~bitmapは、`生成元clean$ ~flagを持つ
— それは、［
~bitmapが，異なる`生成元$からの内容に染まっている（ tainted ）かどうか
］を指示する。
この~flagは、初期~時には ~T に設定され（染まっていない），
`createImageBitmap()$m の手続きにより ~F に変化し得る。
◎
An ImageBitmap object's bitmap has an origin-clean flag, which indicates whether the bitmap is tainted by content from a different origin. The flag is initially set to true and may be changed to false by the steps of createImageBitmap().
</li>
</ul>

<p>
各 `ImageBitmap$I は、`直列化可能$かつ`転送可能$である：
◎
ImageBitmap objects are serializable objects and transferable objects.
</p>

<p>
その`直列化~手続き$は、所与の
( %値, %直列形 )
に対し，次を走らす：
◎
Their serialization steps, given value and serialized, are:
</p>

<ol>
	<li>
%直列形 . `BitmapData^sl ~SET %値 の`~bitmap~data$の複製
◎
Set serialized.[[BitmapData]] to a copy of value's bitmap data.
</li>
	<li>
%直列形 . `OriginClean^sl ~SET ［
%値 の`生成元clean$ ~flag ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］
◎
Set serialized.[[OriginClean]] to true if value's origin-clean flag is set, and false otherwise.
</li>
</ol>

<p>
その`逆直列化~手続き$は、所与の
( %直列形, %値 )
に対し，次を走らす：
◎
Their deserialization steps, given serialized and value, are:
</p>

<ol>
	<li>
%値 の`~bitmap~data$ ~SET  %直列形 . `BitmapData^sl
◎
Set value's bitmap data to serialized.[[BitmapData]].
</li>
	<li>
~IF［
%直列形 . `OriginClean^sl ~EQ ~T
］
⇒
%値 の`生成元clean$ ~flag ~SET ~T
◎
If serialized.[[OriginClean]] is true, set value's origin-clean flag.
</li>
</ol>

<p>
その`転送-手続き$は、所与の
( %値, %~data保持体 )
に対し，次を走らす：
◎
Their transfer steps, given value and dataHolder, are:
</p>

<ol>
	<li>
%~data保持体 . `BitmapData^sl ~SET %値 の`~bitmap~data$
◎
Set dataHolder.[[BitmapData]] to value's bitmap data.
</li>
	<li>
%~data保持体 . `OriginClean^sl  ~SET ［
%値 の`生成元clean$ ~flag ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］
◎
Set dataHolder.[[OriginClean]] to true if value's origin-clean flag is set, and false otherwise.
</li>
	<li>
%値 の`~bitmap~data$ ~SET ε
◎
Unset value's bitmap data.
</li>
</ol>

<p>
その`転送-受信-時の手続き$は、所与の
( %~data保持体, %値 )
に対し，次を走らす：
◎
Their transfer-receiving steps, given dataHolder and value, are:
</p>

<ol>
	<li>
%値 の`~bitmap~data$ ~SET %~data保持体 . `BitmapData^sl
◎
Set value's bitmap data to dataHolder.[[BitmapData]].
</li>
	<li>
~IF［
%~data保持体 . `OriginClean^sl ~EQ ~T
］
⇒
%値 の`生成元clean$ ~flag ~SET ~T
◎
If dataHolder.[[OriginClean]] is true, set value's origin-clean flag.
</li>
</ol>

<hr>


<p class="idl-def">
`createImageBitmap(image, options)@m ／
`createImageBitmap(image, sx, sy, sw, sh, options)^m
~methodを利用すれば、様々な種類の~objから
`ImageBitmap$I ~objを得ることができる。
この~methodの被呼出時には、次を走らせ~MUST：
◎
An ImageBitmap object can be obtained from a variety of different objects, using the createImageBitmap() method. When invoked, the method must act as follows:
</p>

<div>
<ol>
	<li>
%promise ~LET `新たな~promise$
</li>
	<li>
<p >
~RET %promise
— ただし：
</p>
		<ul>
			<li>
以降の手続きは、`並列的$に継続する。
</li>
			<li>
加えて、以降の手続き／それが呼出す下位手続きの中で
“%例外~名 `で却下する@”
と記された所では、
%例外~名 `DOMException$I で %promise を`却下-$した上で，この手続きも終えるとする。
</li>
		</ul>
	</li>
	<li>
~IF［
%sw, %sh 引数は指定されている
］
⇒
~IF［
%sw ~EQ 0
］~OR［
%sh ~EQ 0
］
⇒
`IndexSizeError$E `で却下する$
</li>
	<li>
`resizeWidth@V ~LET ［
%options の `resizeWidth@m が指定されていれば その値 ／
~ELSE_  ε
］
</li>
	<li>
`resizeHeight@V ~LET ［
%options の `resizeHeight@m が指定されていれば その値 ／
~ELSE_  ε
］
</li>
	<li>
( %~bitmap~data, %生成元clean ) ~LET
%image から`~bitmap~dataを取得-$した結果
</li>
	<li>
%O ~LET 新たな `ImageBitmap$I ~obj
<!-- 
Create a new ImageBitmap object.
 -->
</li>
	<li>
%O の~bitmapの`生成元clean$ ~flag ~SET %生成元clean
</li>
	<li>
%O の`~bitmap~data$ ~LET
%~bitmap~data を`~source矩形に~cropして整形-$した結果
</li>
	<li>
%O で %promise を`解決する$
</li>
</ol>

<p class="trans-note">【
この訳では、原文の~algoを再構成している
— その重複する~logicを上の手続きに集約し，重複しない部分は次の “`~bitmap~dataを取得-$” に抜き出している。
】</p>

◎
↓</div>


<p class="algo-head">
%image から
`~bitmap~dataを取得-@
するときは、 %image に応じて，次を走らす：
</p>

<dl class="switch">
	<dt>
%image は `img$e 要素である
◎
If image is an img element
</dt>
	<dt>
%image は `~SVG-image$ 要素である
◎
If image is an SVG image element
</dt>
	<dd>
		<ol>
			<li>
~IF［
%image は`完全に可用$ではない
］
⇒
`InvalidStateError$E `で却下する$
◎
If either the sw or sh arguments are specified but zero, return a promise rejected with an "IndexSizeError" DOMException and abort these steps.
◎
If image is not completely available, then return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
%寸法 ~LET %image の~media~dataの`内在的~寸法$
◎
↓</li>
			<li>
<p>
~IF［
%寸法 ~EQ ε（例：
内容~sizeが指定されていない~vector~graphic）
］：
</p>
				<ol>
					<li>
~IF［
`resizeWidth$V ~EQ ε
］~OR［
`resizeHeight$V ~EQ ε
］
⇒
`InvalidStateError$E `で却下する$
</li>
					<li>
~UAは、 %image を~size
( `resizeWidth$V, `resizeHeight$V )
の~bitmapに描画するべきである `？^tnote
</li>
				</ol>

◎
If image's media data has no intrinsic dimensions (e.g. it's a vector graphic with no specified content size), and both or either of the resizeWidth and resizeHeight options are not specified, then return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
◎
If image's media data has no intrinsic dimensions (e.g. it's a vector graphics with no specified content size), it should be rendered to a bitmap of the size specified by the resizeWidth and the resizeHeight options.
</li>
			<li>
~IF［
%sw 引数は指定されていない
］~AND［
%寸法 の横幅 ~EQ 0
］
⇒
`InvalidStateError$E `で却下する$
◎
↓</li>
			<li>
~IF［
%sh 引数は指定されていない
］~AND［
%寸法 の縦幅 ~EQ 0
］
⇒
`InvalidStateError$E `で却下する$
◎
If the sw and sh arguments are not specified and image's media data has both or either of its intrinsic width and intrinsic height values equal to 0, then return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
◎
If the sh argument is not specified and image's media data has an intrinsic height of 0, then return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
%~bitmap~data ~LET %image の~media~dataを`代表する~bitmap~data$の複製
◎
Create a new ImageBitmap object.
◎
Let the ImageBitmap object's bitmap data be a copy of image's media data, cropped to the source rectangle with formatting. If this is an animated image, the ImageBitmap object's bitmap data must only be taken from the default image of the animation (the one that the format defines is to be used when animation is not supported or is disabled), or, if there is no such image, the first frame of the animation.
</li>
			<li>
%生成元clean ~LET ［［
%image の画像の`生成元$
］ ~EQ`生成元$sub ［
`入口~設定群~obj$により指定される`生成元$sT
］ならば ~T ／
~ELSE_ ~F
］
◎
If the origin of image's image is not the same origin as the origin specified by the entry settings object, then set the origin-clean flag of the ImageBitmap object's bitmap to false.
</li>
			<li>
~RET ( %~bitmap~data, %生成元clean )
◎
Return a new promise, but continue running these steps in parallel.
◎
Resolve the promise with the new ImageBitmap object as the value.
</li>
		</ol>
	</dd>

	<dt>
%image は `video$e 要素である
◎
If image is a video element
</dt>
	<dd>
		<ol>
			<li>
~IF［
%image の `networkState$m 属性~値 ~EQ `NETWORK_EMPTY$m
］
⇒
`InvalidStateError$E `で却下する$
◎
If either the sw or sh arguments are specified but zero, return a promise rejected with an "IndexSizeError" DOMException and abort these steps.
◎
If the video element's networkState attribute is NETWORK_EMPTY, then return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
~IF［
%image の `readyState$m 属性~値 ~IN
{ `HAVE_NOTHING$m, `HAVE_METADATA$m }
］
⇒
`InvalidStateError$E `で却下する$
◎
If the video element's readyState attribute is either HAVE_NOTHING or HAVE_METADATA, then return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
%~bitmap~data ~LET `現在の再生位置$にある~frameの複製
— その~sizeは
`~media資源$の
( `内在的~横幅$video, `内在的~縦幅$video ) 
とする（すなわち，縦横比による補正は適用-済み）
◎
Create a new ImageBitmap object.
◎
Let the ImageBitmap object's bitmap data be a copy of the frame at the current playback position, at the media resource's intrinsic width and intrinsic height (i.e. after any aspect-ratio correction has been applied), cropped to the source rectangle with formatting.
</li>
			<li>
%生成元clean ~LET ［［
%image の`生成元$
］ ~EQ`生成元$sub ［
`入口~設定群~obj$により指定される`生成元$sT
］ならば ~T ／
~ELSE_ ~F
］
◎
If the origin of the video element is not the same origin as the origin specified by the entry settings object, then set the origin-clean flag of the ImageBitmap object's bitmap to false.
</li>
			<li>
~RET ( %~bitmap~data, %生成元clean )
◎
Return a new promise, but continue running these steps in parallel.
◎
Resolve the promise with the new ImageBitmap object as the value.
</li>
		</ol>
	</dd>

	<dt>
%image は `canvas$e 要素である
◎
If image is a canvas element
</dt>
	<dd>
		<ol>
			<li>
~IF［
%image の~bitmapの横幅 ~EQ 0
］~OR［
%image の~bitmapの縦幅 ~EQ 0
］
⇒
`InvalidStateError$E `で却下する$
◎
If either the sw or sh arguments are specified but zero, return a promise rejected with an "IndexSizeError" DOMException and abort these steps.
◎
If the canvas element's bitmap has either a horizontal dimension or a vertical dimension equal to zero, then return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
~RET ( %image の`~bitmap~data$の複製, %image の~bitmapの`生成元clean$ ~flag )
◎
Create a new ImageBitmap object.
◎
Let the ImageBitmap object's bitmap data be a copy of the canvas element's bitmap data, cropped to the source rectangle with formatting.
◎
Set the origin-clean flag of the ImageBitmap object's bitmap to the same value as the origin-clean flag of the canvas element's bitmap.
◎
Return a new promise, but continue running these steps in parallel.
◎
Resolve the promise with the new ImageBitmap object as the value.
</li>
</ol>

	</dd>

	<dt>
%image は `Blob$I ~objである
◎
If image is a Blob object
</dt>
	<dd>

		<ol>
			<li>
~IF［
`<a href="~FILEAPI#readOperationSection">読取り演算</a>により？^tnote
%image から~dataを
<a href="~FILEAPI#file-error-read">読取る間に~errorが生じた</a>
］
⇒
`InvalidStateError$E `で却下する$
◎
If either the sw or sh arguments are specified but zero, return a promise rejected with an "IndexSizeError" DOMException and abort these steps.
◎
If image is closed, then return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
◎
Return a new promise, but continue running these steps in parallel.
◎
Read the Blob object's data. If an error occurs during reading of the object, then reject the promise with an "InvalidStateError" DOMException, and abort these steps.
</li>
			<li>
%画像~data ~LET %image から~dataを読取った結果
◎
↑</li>
			<li>
%画像~data の公式的な型 ~LET ［
%image の `type$m 属性で与えられる~MIME型
］を与える下で，`画像~sniff時の規則$を適用して、
%画像~data の~file形式を決定した結果
◎
Apply the image sniffing rules to determine the file format of the image data, with MIME type of the Blob (as given by the Blob object's type attribute) giving the official type.
</li>
			<li>
<p >
~IF［
次のいずれかが満たされる
］
⇒
`InvalidStateError$E `で却下する$：
</p>

<ul ><li>%画像~data の公式的な型は~supportされる画像~file形式でない（例：画像でない）
</li><li>%画像~data は壊れている
</li><li>%画像~data から寸法を得られない（例： 内在的~sizeを伴わない~vector~graphic）
</li></ul>

◎
If the image data is not in a supported image file format (e.g. it's not an image at all), or if the image data is corrupted in some fatal way such that the image dimensions cannot be obtained (e.g. a vector graphic with no intrinsic size), then reject the promise with an "InvalidStateError" DOMException, and abort these steps.
</li>
			<li>
%~bitmap~data ~LET %画像~data を`代表する~bitmap~data$
◎
Create a new ImageBitmap object.
◎
Let the ImageBitmap object's bitmap data be the image data read from the Blob object, cropped to the source rectangle with formatting. If this is an animated image, the ImageBitmap object's bitmap data must only be taken from the default image of the animation (the one that the format defines is to be used when animation is not supported or is disabled), or, if there is no such image, the first frame of the animation.
</li>
			<li>
~RET ( %~bitmap~data, ~T )
◎
Resolve the promise with the new ImageBitmap object as the value.
</li>
</ol>

	</dd>

	<dt>
%image は `ImageData$I ~objである
◎
If image is an ImageData object
</dt>
	<dd>

		<ol>
			<li>
~IF［
%image の `data$m 属性~値の `Detached$sl 内部~slot値 ~EQ ~T
］
⇒
`InvalidStateError$E `で却下する$
◎
If either the sw or sh arguments are specified but zero, return a promise rejected with an "IndexSizeError" DOMException and abort these steps.
◎
If the image object's data attribute value's [[Detached]] internal slot value is true, return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
~RET ( %image が与える画像~data, ~T )
◎
Create a new ImageBitmap object.
◎
Let the ImageBitmap object's bitmap data be the image data given by the ImageData object, cropped to the source rectangle with formatting.
◎
Return a new promise, but continue running these steps in parallel.
◎
Resolve the promise with the new ImageBitmap object as the value.
</li>
</ol>

	</dd>

	<dt>
%image は `ImageBitmap$I ~objである
◎
If image is an ImageBitmap object
</dt>
	<dd>
		<ol>
			<li>
~IF［
%image の `Detached$sl 内部~slot値 ~EQ ~T
］
⇒
`InvalidStateError$E `で却下する$
◎
If either the sw or sh arguments are specified but zero, return a promise rejected with an "IndexSizeError" DOMException and abort these steps.
◎
If image's [[Detached]] internal slot value is true, return a promise rejected with an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
~RET ( %image の`~bitmap~data$の複製, %image の~bitmapの`生成元clean$ ~flag )
◎
Create a new ImageBitmap object.
◎
Let the ImageBitmap object's bitmap data be a copy of the image argument's bitmap data, cropped to the source rectangle with formatting.
◎
Set the origin-clean flag of the ImageBitmap object's bitmap to the same value as the origin-clean flag of the bitmap of the image argument.
◎
Return a new promise, but continue running these steps in parallel.
◎
Resolve the promise with the new ImageBitmap object as the value.
</li>
</ol>

	</dd>
</dl>


<div >
<p class="algo-head">
所与の %画像~data を
`代表する~bitmap~data@
は、次の結果を返す：
</p>

<ol>
	<li>
~IF［
%画像~data は~animated画像でない
］
⇒
~RET %画像~data
</li>
	<li>
~RET ［
%画像~data の形式にて［
~animationが ~supportされないか不能化されている
］ときに利用するものと定義されている既定の画像
］が［
あれば それ ／
なければ~animationの最初の~frame
］
</li>
</ol>

◎
↑</div>



<p class="algo-head">
所与の`~bitmap~data$ %入力 を
`~source矩形に~cropして整形-@
するときは、次の手続きを走らす：
◎
When the steps above require that the user agent crop bitmap data to the source rectangle with formatting, the user agent must run the following steps:
</p>

<ol>
	<li>
~IF［
`resizeWidth$V ~EQ 0 <!-- ＊~LTE -->
］~OR［
`resizeHeight$V ~EQ 0
］
⇒
`InvalidStateError$E `で却下する$
◎
Let input be the bitmap data being transformed.
◎
If either or both of resizeWidth and resizeHeight members of options are less than or equal to 0, then return a promise rejected with "InvalidStateError" DOMException and abort these steps.
</li>
	<li>
<p >
%~source矩形 ~LET
( 左端, 上端, 右端, 下端 ) が次で与えられる矩形：
</p>

		<dl class="switch">
			<dt>%sx, %sy, %sw, %sh は指定されている場合</dt>
			<dd>

<ul ><li>左端： max( min( %sx, %sx + %sw ), 0)
</li><li>上端： max( min( %sy, %sy + %sh ), 0)
</li><li>右端： min( max( %sx, %sx + %sw ), %入力 の横幅 )
</li><li>下端： min( max( %sy, %sy + %sh ), %入力 の縦幅 )
</li></ul>

<!-- 
［
%sw ／ %sh
］が負ならば、この矩形の左上隅は，点 ( %sx, %sy ) の 左／上になる。
-->

			</dd>

			<dt>他の場合</dt>
			<dd>
( 0, 0, %入力 の横幅, %入力 の縦幅 )
</dd>
		</dl>

◎
If sx, sy, sw and sh are specified, let sourceRectangle be a rectangle whose corners are the four points (sx, sy), (sx+sw, sy),(sx+sw, sy+sh), (sx,sy+sh). Otherwise let sourceRectangle be a rectangle whose corners are the four points (0,0), (width of input, 0), (width of input, height of input), (0, height of input).
◎
If either sw or sh are negative, then the top-left corner of this rectangle will be to the left or above the (sx, sy) point.
◎
Clip sourceRectangle to the dimensions of input.
</li>
	<li>
( %横幅, %縦幅 ) ~LET %~source矩形 の ( 横幅, 縦幅 )
</li>
	<li>

<p>
( %出力~横幅, %出力~縦幅 ) ~LET
(`resizeWidth$V, `resizeHeight$V )
に応じて，次の表で与えられる値を整数に切り上げた結果：
</p>

<table>
<thead><tr><th>`resizeWidth$V
<th>`resizeHeight$V
<th>%出力~横幅
<th>%出力~縦幅
</thead>

<tbody><tr><td>非ε
<td>非ε
<td>`resizeWidth$V
<td>`resizeHeight$V

<tr><td>非ε
<td>ε
<td>`resizeWidth$V
<td>%縦幅 × `resizeWidth$V ÷ %横幅

<tr><td>ε
<td>非ε
<td>%横幅 × `resizeHeight$V ÷ %縦幅
<td>`resizeHeight$V

<tr><td>ε
<td>ε
<td>%横幅
<td>%縦幅

</tbody></table>



◎
Let outputWidth be determined as follows:
• If the resizeWidth member of options is specified
•• the value of the resizeWidth member of options
• If the resizeWidth member of options is not specified, but the resizeHeight member is specified
•• the width of sourceRectangle, times the value of the resizeHeight member of options, divided by the height of sourceRectangle, rounded up to the nearest integer
• If neither resizeWidth nor resizeHeight are specified
•• the width of sourceRectangle
◎
Let outputHeight be determined as follows:
• If the resizeHeight member of options is specified
•• the value of the resizeHeight member of options
• If the resizeHeight member of options is not specified, but the resizeWidth member is specified
•• the height of sourceRectangle, times the value of the resizeWidth member of options, divided by the width of sourceRectangle, rounded up to the nearest integer
• If neither resizeWidth nor resizeHeight are specified
•• the height of sourceRectangle
</li>
	<li>
%平面 ~LET 
( x 軸は右向き, y 軸は下向き ) にされた, 広さ無限の, 黒地透明な平面
◎
↓</li>
	<li>
<p >
%入力 を，次に従うように %平面 に~~合成する：
</p>

<ul ><li>%入力 の左上隅は、 %平面 の原点に位置させる。
</li><li>%入力 画像~data内の各~画素は、 %平面 において 1 × 1 の正方形を占めるとする。
</li></ul>

◎
Place input on an infinite transparent black grid plane, positioned so that its top left corner is at the origin of the plane, with the x-coordinate increasing to the right, and the y-coordinate increasing down, and with each pixel in the input image data occupying a cell on the plane's grid.
</li>
	<li>
%出力 ~LET 
%平面 上の %~source矩形 が占める矩形~内の画像を，~size
( %出力~横幅, %出力~縦幅 )
に拡縮した結果
⇒
この拡縮に用いる~algoは、 `resizeQuality$m ~optionの値に基づくべきである
◎
Let output be the rectangle on the plane denoted by sourceRectangle.
◎
Scale output to the size specified by outputWidth and outputHeight. The user agent should use the value of the resizeQuality option to guide the choice of scaling algorithm.
</li>
	<li>
<p>
%options の
`imageOrientation@m
~memberの値に応じて：
</p>

		<dl class="switch">
			<dt>`flipY@l</dt>
			<dd>
%出力 を縦~方向に裏返す
— ~sourceの画像~方位~metadata（ `EXIF$r ~metadataなど）があっても~~無視する
◎
If the value of the imageOrientation member of options is "flipY", output must be flipped vertically, disregarding any image orientation metadata of the source (such as EXIF metadata), if any. [EXIF]
</dd>

			<dt>`~none1@l</dt>
			<dd>
何もしない
◎
If the value is "none", no extra step is required.
</dd>

		</dl>
	</li>
	<li>
<p>
~IF［
%image は `img$e 要素または `Blob$I ~objである
］
⇒
`colorSpaceConversion@m
~memberの値に応じて：
◎
If image is an img element or a Blob object, let val be the value of the colorSpaceConversion member of options, and then run these substeps:
</p>

		<dl class="switch">
			<dt>`~default0@l</dt>
			<dd>
色~空間の変換の挙動は，実装~特有である
— 実装は、画像を~canvasに描く際に利用する色~空間に則って選ぶべきである。
◎
If val is "default", the color space conversion behavior is implementation-specific, and should be chosen according to the color space that the implementation uses for drawing images onto the canvas.
</dd>

			<dt>`~none0@l</dt>
			<dd>
%出力 は、色~空間の変換を遂行することなく復号され~MUST。
これは、
画像を復号する~algoは［
~source~data内に埋込まれている色~profile~metadata,
表示~機器の色~profile
］のいずれも無視し~MUSTことを意味する。
◎
If val is "none", output must be decoded without performing any color space conversions. This means that the image decoding algorithm must ignore color profile metadata embedded in the source data as well as the display device color profile.
</dd>
			<dd class="note">
~canvasの~native色~空間は、現在は指定されていないが、将来的には変更されることが予期されている。
◎
The native color space of canvas is currently unspecified, but this is expected to change in the future.
</dd>

		</dl>
	</li>
	<li>
<p>
%options の
`premultiplyAlpha@m
~memberの値に応じて：
◎
Let val be the value of premultiplyAlpha member of options, and then run these substeps:
</p>

		<dl class="switch">
			<dt>`default@l</dt>
			<dd>
%出力 を~alphaにより積算済みにするかどうかは、実装~特有である
— 実装は、画像を~canvasに描くために最適と~~考えるものに則って選ぶべきである。
◎
If val is "default", the alpha premultiplication behavior is implementation-specific, and should be chosen according to implementation deems optimal for drawing images onto the canvas.
</dd>

			<dt>`premultiply@l</dt>
			<dd>
~IF［
%出力 は~alphaにより積算済みでない
］
⇒
%出力 のすべての 色~成分を~alphaで積算する
◎
If val is "premultiply", the output that is not premultiplied by alpha must have its color components multiplied by alpha and that is premultiplied by alpha must be left untouched.
</dd>

			<dt>`none@l</dt>
			<dd>
~IF［
%出力 は~alphaにより積算済みである
］
⇒
%出力 のすべての色~成分を~alphaで除算する
◎
If val is "none", the output that is not premultiplied by alpha must be left untouched and that is premultiplied by alpha must have its color components divided by alpha.
</dd>
		</dl>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>



<dl class="idl-def">
	<dt>`close()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the close() method is called, the user agent must run these steps:
</p>

		<ol>
			<li>
此れの `Detached$sl 内部~slot値 ~SET ~T
◎
Set this ImageBitmap object's [[Detached]] internal slot value to true.
</li>
			<li>
此れの`~bitmap~data$ ~SET ε
◎
Unset this ImageBitmap object's bitmap data.
</li>
		</ol>
	</dd>

	<dt>`width@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The width attribute's getter must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの `Detached$sl 内部~slotの値 ~EQ ~T
］
⇒
~RET 0
◎
If this ImageBitmap object's [[Detached]] internal slot's value is true, then return 0.
</li>
			<li>
~RET `~CSS~pixel$単位による，此れの横幅
◎
Return this ImageBitmap object's width, in CSS pixels.
</li>
		</ol>
	 </dd>

	<dt>`height@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The height attribute's getter must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの `Detached$sl 内部~slotの値 ~EQ ~T
］
⇒
~RET 0
◎
If this ImageBitmap object's [[Detached]] internal slot's value is true, then return 0.
</li>
			<li>
~RET `~CSS~pixel$単位による，此れの縦幅
◎
Return this ImageBitmap object's height, in CSS pixels.
</li>
		</ol>
	</dd>
</dl>

<p class="idl-def">
`ResizeQuality$I 列挙型の値
`resizeQuality@m
は、画像の拡縮-時に利用する補間~品質の選好を表すために利用される
— とり得る値の意味は：
◎
The ResizeQuality enumeration is used to express a preference for the interpolation quality to use when scaling images.
</p>

<dl class="def-list">
	<dt>`pixelated@l</dt>
	<dd>
画像の外観をできるだけ保つような選好を指示する。
双線形~補間など、色を “滑らかに” 拡縮する~algoは，受容し得る。
◎
The "pixelated" value indicates a preference to scale the image that maximizes the appearance. Scaling algorithms that "smooth" colors are acceptable, such as bilinear interpolation.
</dd>

	<dt>`low@l</dt>
	<dd>
低~品質な画像~補間の選好を指示する。
計算量は `high$l より少なく済み得る。
◎
The "low" value indicates a preference for a low level of image interpolation quality. Low-quality image interpolation may be more computationally efficient than higher settings.
</dd>

	<dt>`medium@l</dt>
	<dd>
中間~品質の画像~補間の選好を指示する。
◎
The "medium" value indicates a preference for a medium level of image interpolation quality.
</dd>

	<dt>`high@l</dt>
	<dd>
高~品質な画像~補間の選好を指示する。
計算量は `low$l より多くなり得る。
◎
The "high" value indicates a preference for a high level of image interpolation quality. High-quality image interpolation may be more computationally expensive than lower settings.
</dd>

</dl>


<p class="note">
双線形~拡縮は、比較的~高速で，より低~品質な画像を滑らかに補間する~algoの例である。
双三次 ／ Lanczos
拡縮は、より高~品質な出力を生産する画像~拡縮~algoの例である。
この仕様は、値 `pixelated$l を除いて，特定の補間~algoの利用を義務付けない。
◎
Bilinear scaling is an example of a relatively fast, lower-quality image-smoothing algorithm. Bicubic or Lanczos scaling are examples of image-scaling algorithms that produce higher-quality output. This specification does not mandate that specific interpolation algorithms be used unless the value is "pixelated".
</p>



<div class="example">
<p>
この~APIを利用して、~sprite-sheetを事前に切り分けて準備する例：
◎
Using this API, a sprite sheet can be precut and prepared:
</p>

<pre>var %sprites = {};
function loadMySprites() {
  var %image = new Image();
  %image.src = 'mysprites.png';
  var %resolver;
  var %promise = new Promise(function (%arg) { %resolver = %arg });
  %image.onload = function () {
    %resolver(Promise.all(
      createImageBitmap(%image,  0,  0, 40, 40)
        .then(function (%image) { %sprites.woman = %image }),
      createImageBitmap(%image, 40,  0, 40, 40)
        .then(function (%image) { %sprites.man   = %image }),
      createImageBitmap(%image, 80,  0, 40, 40)
        .then(function (%image) { %sprites.tree  = %image }),
      createImageBitmap(%image,  0, 40, 40, 40)
        .then(function (%image) { %sprites.hut   = %image }),
      createImageBitmap(%image, 40, 40, 40, 40)
        .then(function (%image) { %sprites.apple = %image }),
      createImageBitmap(%image, 80, 40, 40, 40)
        .then(function (%image) { %sprites.snake = %image }),
    ));
  };
  return %promise;
}

function runDemo() {
  var %canvas = document.querySelector('canvas#demo');
  var %context = %canvas.getContext('2d');
  %context.drawImage(%sprites.tree, 30, 10);
  %context.drawImage(%sprites.snake, 70, 10);
}

loadMySprites().then(runDemo);
</pre>

</div>

		</section>
		<section id="animation-frames">
<h2 title="Animation Frames">8.9. ~animation~frame</h2>

<div class="p">
<p>
各 `Document$I は、次のものを持つ：
</p>

<dl class="def-list">
	<dt>`~animation~frame~callback~list@</dt>
	<dd>
初期~時は空。
</dd>

	<dt>`~animation~frame~callback識別子@</dt>
	<dd>
整数（初期~時は~zero）。
</dd>
</dl>
◎
Each Document has a list of animation frame callbacks, which must be initially empty, and an animation frame callback identifier, which is a number which must initially be zero.
</div>


<dl class="idl-def">
	<dt>`requestAnimationFrame(callback)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the requestAnimationFrame() method is called, the user agent must run the following steps:
</p>

		<ol>
			<li>
%文書 ~LET 此れに`結付けられている文書$
◎
Let document be this Window object's associated Document.
</li>
			<li>
%文書 の`~animation~frame~callback識別子$ ~INCBY 1
</li>
			<li>
%識別子 ~LET %文書 の`~animation~frame~callback識別子$
◎
Increment document's animation frame callback identifier by one.
</li>
			<li>
%callback に %識別子 を結付けた上で，
%文書 の`~animation~frame~callback~list$に付加する
◎
Append the method's argument to document's list of animation frame callbacks, associated with document's animation frame callback identifier's current value.
</li>
			<li>
~RET %識別子
◎
Return document's animation frame callback identifier's current value.
</li>
		</ol>
	</dd>

	<dt>`cancelAnimationFrame(handle)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the cancelAnimationFrame() method is called, the user agent must run the following steps:
</p>

		<ol>
			<li>
~IF［
此れに`結付けられている文書$の`~animation~frame~callback~list$内に
%handle を結付けている~callbackはある
］
⇒
%文書 の`~animation~frame~callback~list$から その~callbackを除去する
◎
Let document be this Window object's associated Document.
◎
Find the entry in document's list of animation frame callbacks that is associated with the value given by the method's argument.
◎
If there is such an entry, remove it from document's list of animation frame callbacks.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
~UAは，
`~animation~frame~callbackたちを走らす@
ときは、所与の
( `Document$I %文書, 時刻印 %now )
に対し，次を走らせ~MUST：
◎
When the user agent is to run the animation frame callbacks for a Document doc with a timestamp now, it must run the following steps:
</p>

<ol>
	<li>
%~callback~list ~LET %文書 の`~animation~frame~callback~list$の複製
◎
Let callbacks be a list of the entries in doc's list of animation frame callbacks, in the order in which they were added to the list.
</li>
	<li>
%文書 の`~animation~frame~callback~list$を空にする
◎
Set doc's list of animation frame callbacks to the empty list.
</li>
	<li>
%~callback~list 内の~EACH ( %~callback ) に対し
⇒
%now を引数に渡して %~callback を`呼出す$x
`WEBIDL$r
— ただし
⇒
例外が投出された場合は、その`例外を報告する$
`反復は継続する^tnote
◎
For each entry in callbacks, in order: invoke the callback, passing now as the only argument, and if an exception is thrown, report the exception. [WEBIDL]
</li>
</ol>


		</section>
</main>
