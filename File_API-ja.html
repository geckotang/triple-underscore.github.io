<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>File API （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script >
var source_data;

// COMMON_DATA.page_state_key = ;
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://w3c.github.io/FileAPI/',
		//'https://w3c.github.io/FileAPI/',
		spec_status: 'ED',
		main: 'MAIN',
		alt_refs: 'references',
		fill_text_link: '#_versions > dd, #references dd',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true
	};


	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked 160325 spec

	return options;
}

function expand(mapping1){
	var nesting = '';
	var link_map = this.link_map;
	var unicode_map = this.unicode_map;
	var class_map = {
		FR: 'reason',
		e: 'element',
		a: 'attr',
		sc: 'scheme',
		h: 'header',
		E: 'error', // exception
		P: 'production',
		et: 'event-type',
		I: 'idl-interface',
		dm: 'idl-dictionary-member',
		U: 'code-point',
		V: 'arg',
		tnote: 'trans-note'
	};
	var tag_map = {
		samp: 'samp',
		FR: 'i', // file read error reason
		E: 'code',
		et: 'code', // event type
		e: 'code', // HTML element
		a: 'code',
		sc: 'code', // URL scheam
		h: 'code', // HTTP method/header names
		I: 'code', // idl type
		m: 'code', // idl member
		mS: 'code', // idl member ( FileReaderSync )
		dm: 'code', // idl dictionary member
		V: 'var', // idl args
		U: 'span', // Unicode code point
		P: 'var', // production
		c: 'code',
		tnote: 'span'
	}

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^`<◎]*|%[\w\u4E00-\u9FFF~]+|`(.*?)([$@^])(\w*)/g,
			create_html
		),
		mapping1
	);


	function create_html(match, key, indicator, klass){
if(!indicator) {
	switch(match.charAt(0)){
	case '%':
		return '<var>' + match.slice(1) + '</var>';
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	case '◎':
	default:
	}
	var result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'm':
case 'mS':
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l': // literal
	text = '"<code class="literal">' + key + '</code>"'
	break;
case 'U':
	text = 'U+' + key;
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default:
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}
</script>

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
dom-blob-blob:
dom-file-file:
dom-filereader-filereader:
dom-filereadersync-filereadersync:
</script>

<script type="text/plain" id="_link_map">
	●IDL
Exposed:~WEBIDL#Exposed
Clamp:~WEBIDL#Clamp

I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
	I.ArrayBufferView:~WEBIDL#

I.BufferSource:~WEBIDL#BufferSource
I.Blob:#dfn-Blob
I.BlobPart:#typedefdef-blobpart
I.BlobPropertyBag:#dfn-BlobPropertyBag
I.DOMString:~WEBIDL#idl-DOMString
I.USVString:~WEBIDL#idl-USVString
I.DataTransfer:~HTMLdnd#datatransfer
I.EventHandler:~WAPI#eventhandler
I.EventTarget:~DOM4#eventtarget
I.File:#dfn-file
I.FileList:#dfn-filelist
I.FilePropertyBag:#dfn-FilePropertyBag
I.HTMLInputElement:~HEinput#htmlinputelement
I.ProgressEvent:~XHR#progressevent
I.Window:~BROWSERS#window
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.Worker:~WORKERS#worker
I.XMLHttpRequest:~XHR#xmlhttprequest
I.URL:~URLSpec#url
I.FileReader:#dfn-filereader
I.FileReaderSync:#dfn-FileReaderSync

I.Array:~TC39#sec-array-constructor
I.Date:~TC39#sec-date-constructor

	unsigned long:~WEBIDL#idl-unsigned-long
	long long:~WEBIDL#idl-long-long
	unsigned long long:~WEBIDL#idl-unsigned-long-long
	boolean:~WEBIDL#idl-boolean


E.NotFoundError:~WEBIDL#notfounderror
E.NotReadableError:~WEBIDL#notreadableerror
E.SecurityError:~WEBIDL#securityerror
E.InvalidStateError:~WEBIDL#invalidstateerror
I.DOMException:~WEBIDL#idl-DOMException

	E.NotFoundError:#dfn-NotFoundError
	E.SecurityError:#dfn-SecurityError
	E.NotReadableError:#dfn-NotReadableError
	E.InvalidStateError:#InvalidStateError

	●contructor＊
m.Blob:#dom-blob-blob
	m.Blob:#dom-blob-blob-blobparts-options
m.File:#dom-file-file
	m.File(fileBits, fileName):#dom-file-file
	m.File(fileBits, fileName, options):#dom-file-file
m.FileReader:#dom-filereader-filereader
m.FileReaderSync:#dom-filereadersync-filereadersync
	m.Constructor:#dom-blob-blob
	m.Constructor:#dom-file-file
	m.Constructor:#dom-filereader-filereader
	m.Constructor:#dom-filereadersync-filereadersync

	■const
m.DONE:#dfn-done
m.EMPTY:#dfn-empty
m.LOADING:#dfn-loading

	■attrs/method
m.abort:#dfn-abort
m.createObjectURL:#dfn-createObjectURL
m.URL.createObjectURL:#dfn-createObjectURL
m.error:#dfn-error
m.getAllResponseHeaders:~XHR#dom-xmlhttprequest-getallresponseheaders
m.item:#dfn-item
m.lastModified:#dfn-lastModified
m.length:#dfn-length
m.name:#dfn-name

m.onabort:#dfn-onabort
m.onerror:#dfn-onerror
m.onload:#dfn-onload
m.onloadend:#dfn-onloadend
m.onloadstart:#dfn-onloadstart
m.onprogress:#dfn-onprogress

m.postMessage:~WORKERS#dom-worker-postmessage

m.readAsArrayBuffer:#dfn-readAsArrayBuffer
m.readAsBinaryString:#dfn-readAsBinaryString
m.readAsDataURL:#dfn-readAsDataURL
m.readAsText:#dfn-readAsText

mS.readAsArrayBuffer:#dfn-readAsArrayBufferSync
mS.readAsBinaryString:#dfn-readAsBinaryStringSync
mS.readAsDataURL:#dfn-readAsDataURLSync
mS.readAsText:#dfn-readAsTextSync

m.readyState:#dfn-readyState
m.result:#dfn-result
m.revokeObjectURL:#dfn-revokeObjectURL
m.URL.revokeObjectURL:#dfn-revokeObjectURL
m.send:~XHR#dom-xmlhttprequest-send
m.size:#dfn-size
m.slice:#dfn-slice
m.type:#dfn-type

	■variable
V.blobParts:#dfn-blobParts
V.options:#dfn-blobOptions
V.url:#dfn-urlarg
V.contentType:#dfn-contentTypeBlob
V.start:#dfn-start
V.end:#dfn-end
V.fileBits:#dfn-fileBits
V.fileName:#dfn-fileName
V.fileOptions:#dfn-fileOptions
V.index:#dfn-index
V.label:#dfn-label
V.blob:#dfn-fileBlob


	■idl-dictionary-member
dm.lastModified:#dfn-FPdate
dm.type:#dfn-BPtype

	■event
et.abort:#dfn-abort-event
et.error:#dfn-error-event
et.load:#dfn-load-event
et.loadend:#dfn-loadend-event
et.loadstart:#dfn-loadstart-event
et.progress:#dfn-progress-event


	■error
FR.FileLock:#FileLockFR
FR.NotFound:#NotFoundFR
FR.SnapshotState:#SnapshotStateFR
FR.TooManyReads:#TooManyReadsFR
FR.UnsafeFile:#UnsafeFileFR



	■element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.input:~HEinput#the-input-element
e.a:~HEtextlevel#the-a-element
e.form:~HEforms#the-form-element
e.canvas:~HEcanvas#the-canvas-element

	■content attr
a.download:~HTMLlinks#attr-hyperlink-download

	■HTTP header, mehod
h.Content-Length:~RFC7230#section-3.3.2
h.Content-Type:~RFC7231#section-3.1.1.5#HTTP-Content-Type
h.Content-Disposition:~IETF/rfc6266

h.GET:~RFC7231#section-4.3.1


200 OK:#TwoHundredOK


	●
参照~byte列:#_ref-bytes
~byte列を構築:#_build-a-sequence-of-bytes
~Blob:#_blob-object
~data_URL:#biblio-rfc2397
~error手続き:#dfn-error-steps

~Blob~URL~Store:#BlobURLStore
~Blob~URL~Storeに追加する:#add-an-entry
~Blob~URL~Storeから除去する:#removeTheEntry
~Blob~URL:#blob-url
~Blob~URLの生成元:#origin-of-a-blob-url

選択looping:#selection-looping
~systemに関わる~file:#sensitive-files

~Blob~URLの直列化:#unicodeBlobURL
Unix Epoch:#UnixEpoch
注釈付き~task読取り演算:#task-read-operation


参照取得:#dereference
符号化方式を決定-:#encoding-determination
読取り~error:#file-error-read
~error条態:#file-error-read
失敗事由:#failureReason
~file読取~task源:#fileReadingTaskSource
~file type 指針:#file-type-guidelines
進捗~eventを発火-:#fire-a-progress-event
存続期間:#lifeTime
	`Content-Type^h ~headerの構文解析:#processing-media-types

読取り演算:#readOperation
読取り完了:#process-read-EOF
	process read EOF
読取り~dataを処理する:#process-read-data
読取り~errorを処理する:#process-read-error
読取りを開始する:#process-read


読取り~method:#read-method
非同期~読取り~method:#asynchronous-read-methods
同期~読取り~method:#read-method-sync

~snapshot状態:#snapshot-state
同期~flag:#synchronousFlag

終了-:#terminate-an-algorithm


	●外部
~URL:~URLSpec#concept-url
url.素片:~URLSpec#concept-url-fragment
url.~host:~URLSpec#concept-url-host
url.~path:~URLSpec#concept-url-path
url.~scheme:~URLSpec#concept-url-scheme
url.~obj:~URLSpec#concept-url-object
url.生成元:~URLSpec#concept-url-origin

非同一生成元~要請:~FETCH#http-cors-protocol
本体:~FETCH#concept-body
~network~error:~FETCH#concept-network-error
要請:~FETCH#concept-request
応答:~FETCH#concept-response
伝送済み~byte数:~FETCH#concept-body-transmitted
総~byte数:~FETCH#concept-body-total-bytes
応答~header:~FETCH#concept-response-header-list

~byte:~INFRA#byte
~byte列:~INFRA#byte
復号-:~ENCODING#decode
符号化方式を取得-:~ENCODING#concept-encoding-get
符号化方式~label:~ENCODING#label
utf-8:~ENCODING#utf-8
utf-8 符号化-:~ENCODING#utf-8-encode

発火-:~DOM4#concept-event-fire
発火:~DOM4#concept-event-fire
	文脈~obj:~DOM4#context-object

解析可能な MIME 型:~MIMESNIFF#parsable-mime-type
MIME 型の構文解析:~MIMESNIFF#parse-a-mime-type
~parameterの辞書:~MIMESNIFF#parameters

被support~prop~index:~WEBIDL#dfn-supported-property-indices
投出:~WEBIDL#dfn-throw
在する:~WEBIDL#dfn-present
~byte列の複製を取得-:~WEBIDL#dfn-get-buffer-source-copy

~chunk:~STREAMS#chunk
	媒体型:#media-type

~ASCII小文字~化:~INFRA#ascii-lowercase
文書:~DOM4#concept-document

	●HTML
StructuredClone:~HTMLcloning#structuredclone
~event~handler内容~属性:~WAPI#event-handler-content-attributes
~event~handler ~event型:~WAPI#event-handler-event-type
現在の設定群~obj:~WAPI#current-settings-object
待入され:~WAPI#queue-a-task
待入する:~WAPI#queue-a-task
~taskを待入する:~WAPI#queue-a-task
~task源:~WAPI#task-source
~task:~WAPI#concept-task

生成元:~BROWSERS#concept-origin
同一生成元:~BROWSERS#same-origin
enV.生成元:~WAPI#concept-settings-object-origin
文書~unload時の片付け手続き:~NAVI#unloading-document-cleanup-steps
~ASCII直列化:~BROWSERS#ascii-serialisation-of-an-origin

</script>


<script type="text/plain" id="words_table1">

</script>

<!--%語彙 -->

<script type="text/plain" id="words_table">
此れ:<b>これ°</b>
method::::メソッド
byte::::バイト
index:
URL:
data_URL:Data URL
Unicode:
Blob:
HTML:
Web:
API:
UI:user interface:UI
UUID:
ABNF:
Store:
HTTP:
HTTPS:
JavaScript:

size::::サイズ
buffer::::バッファ
chunk::::チャンク
被support:supported::被 support:被サポート
data::::データ
file::::ファイル
member::::メンバ
code::::コード
push:
worker:
本体:body::~:ボディ
access::::アクセス
upload::::アップロード
unload::::
anchor::::アンカー
event::::イベント
target::::ターゲット
handler::::ハンドラ
model::::モデル
interface::::インタフェース
obj:object:::オブジェクト
error::::エラー
flag::::フラグ
	~error状況:error condition
entry::::エントリ

	一部subset::::サブセット
server::::サーバ
system::::システム
memory::::メモリ
scheme::::スキーム
	query::::クエリ
	host::::ホスト
	port::::ポート
	scope::::スコープ
script::::スクリプト
storage::::ストレージ
snapshot::::スナップショット
spreadsheet::::スプレッドシート
	status::::ステータス
main::::メイン
thread::::スレッド
保安:security::~:セキュリティ
privacy::::プライバシー

違反:violation::~
ダイアログ:dialog
選択ダイアログ:picker
task::::タスク
source::::ソース
源:source::~::ソース
chunk::::チャンク
	生データ:raw data
disk::::ディスク
directory::::ディレクトリ
辞書:dictionary::~::ディクショナリ
連列:sequence::~::シーケンス

text::::テキスト
	デコード:decode
transaction::::トランザクション
drive::::ドライブ
download::::ダウンロード
	
	~byte列:bytes:バイト列
stream::::ストリーム
binary::::バイナリ
metadata::::メタデータ
parameter::::パラメタ
permission::::パーミッション
	プロセス:process
code-block:code block::コードブロック
阻む:block する:~
fallback::::フォールバック
viewer::::ビューア
view::::ビュー
header::::ヘッダ
form::::フォーム
program::::プログラム
offline::::オフライン
protocol::::プロトコル
prop:property:::プロパティ
policy::::ポリシー
native::::ネイティブ
markup::::マークアップ
message::::メッセージ
label::::ラベル
list::::リスト
資源:resource::~:リソース
fetching:::fetch 処理
remote::::リモート
local::::ローカル
lock::::ロック
network::::ネットワーク

path::::パス
host::::ホスト
設定群:settings::~
取消:cancel::取消し
取消せ:cancel でき::~
取消され:cancel され::~

大域:global::~::グローバル
構築子:constructor::~::コンストラクタ
構築:construct::~
素の:plain::~::プレーン
処理能:performance::~::パフォーマンス
mount::::マウント
test::::テスト
sample::::見本コード
machine::::マシン
進捗bar:prog bar:進捗表示:::プログレスバー
Calendar::::カレンダー
browser::::ブラウザ
console::::コンソール
leak::::リーク

関数:function::~
garbage::::ガーベジ
収集-:collect:~
代用対:surrogate::~::サロゲート
	ビデオ:video
写真:photo:~
	ビデオ会議:video-conferencing

読取っ:read し::読み取っ
読取られ:read され::読み取られ
読取れ:read でき::読み取れ
読取る:read する::読み取る
読取り:read::読み取り
読取:reading::読み取り
	読取中:reading → read 中
読専:readonly::読み取り専用

読込まれ:load され::読み込まれ
読込み:load::読み込み

注釈付き:annotated::~

切出す:slice する::切り出す
切出し:slice::切り出し

浮上:bubble::~::バブル
静的:static::~
状態:state::~

返す:return する:~
返され:return され:~
返さな:return しな:~
返して:return して:~
返した:return した:~
繰返し:繰り返し
call:
	call

呼出:invocation:呼び出し
呼出され:invoke され:呼び出され
呼出す:invoke する:呼び出す
呼出せる:invoke できる:呼び出せる
	呼び出し元
	呼び出し
被呼出時:被 invoke 時:~

取得子:getter:~
取得-:get:~
検索取得:retrieval:~
検索取得-:retrieve:~
在する:present する:在る

待行列:queue::待ち行列::キュー
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ

言語束縛:binding::~::バインディング
応答:response::~::レスポンス
応答-:respond::~::レスポンド
要請:request::~::リクエスト

復号-:decode::~::デコード
媒体型:media type::~::メディア型
解析可能:parsable::~
符号単位:code unit::~
符号位置:code point::~::コードポイント
符号化方式:encoding::~::エンコーディング
符号化-:encode::~::エンコード
	~ASCII小文字に符号化された文字列:ASCII-encoded string in lower case
伝送済み:transmitted::~

型:type::~
形式:format::~::フォーマット
参照取得:dereference::~

処理-:process:~
処理:processing:~
処理命令:processing directive::~
生成元:origin::~::オリジン
同一生成元:same origin::~::同一オリジン
非同一生成元:cross-origin::~::クロスオリジン
進捗:progress::~
素片:fragment::~::フラグメント
識別子:identifier::~
投出:throw::~
属性:attribute::~
同期的:synchronous::~
同期:synchronous::~
同期~flag:synchronous flag::~
非同期:asynchronous::~
非同期の:asynchronous::~
非同期的:asynchronous::~
中止:abort::~
内容:content::~
発火-:fire::~
発火:firing::~
不透明:opaque::~
文書:document::~
例外:exception::~
成功:success::~
成功裡:successful::~
失敗:failure::~
失敗-:fail::~
失敗事由:failure reason::~
作成-:create::~
作成法:creating::~
作成:creatation::~
創出-:mint:~
破棄-:revoke::~
破棄:revocation::~
破棄法:revoking::~
	ストア:Store::~
存続期間:lifetime::~

選択looping:selection looping:選択ループ
下層:underlying:~
	結果:result::~

	●仕様
UA:user agent:UA
risk::::リスク
support::::サポート
	ウェブ:web
app:application:::アプリ
	アプリケーション
algo:algorithm:::アルゴリズム
platform::::プラットフォーム
条態:condition::~::コンディション
version::::バージョン
問題:problem:~
利用事例:use case::~::ユースケース
選択肢:option::~::オプション
省略可:optional::~::オプション
	省略可 任意選択
遂行-:perform:~
適合:conforming:~
適合-:conform:~
後方互換性:backwards compatibility:~
指針:guideline:~
要件:requirements:~
利用者:user:~
	例:example:~
意味論:semantics:~
自動的:automatic:~
閲覧:browse:~
防止:preventing:~
防止-:prevent:~
趨勢:general trend:~
公開-:expose:~
曝露-:expose:~
効率的:efficient:~
可用:available:~
定義-:define:~
定義:definition:~
未定義:undefined:~
実装-:implement:~
実装:implementation:~
一意的:unique:~
参考:informative:~
提供-:provide:~
ベース:base::~
考慮点:considerations:~
考慮-:consider:~
予定表:calendar:~
仕様:spec:~
	specification:~
依存-:depend:~
注記:Note:~
環境:environment:~
滞在-:reside:~
伝統的:traditional:~
選択攻撃:selection attacks:~
攻撃:attack:~
不変則:invariants:~
獲得-:acquire:~
設計:design:~
規約:convention:~
約定:stipulation:~
標識:labeling:~
適切:appropriate:~
無視-:ignore:~
統計的手法:statistical method:~
経験則:heuristic:~
feedback::::フィードバック
適用-:apply:~
解釈:interpretation:~
基本的:basic:~
無反応:freezing:~
多彩:rich:~
	内部的:internal:~
旧来の:legacy:~
	用法:usage:~
指定-:specify:~
安全:safe:~
	いくつもの:variation:~
特色機能:feature:~
指示-:indicate:~
提示-:present:~
維持管理-:maintain:~
認識-:recognize:~
汎用的:generic:~
汎用:generic:~
欠損:loss:~
統合-:integrate:~
併合-:merge:~
有用:useful:~
許容-:allow:~
論点:discussion:~
論拠:justification:~
重要:important:~
広範囲:wide:~
保護:guard:~
事例:case:~
制約-:restrict:~
局面:scenario:~
悪意的な:malicious:悪意のある
仕組み:mechanism:~
現在の:current:~
手続き:steps:~
下位手続き:substeps:~
段:step:~
提携の:affiliated:~
提携-:affiliate:~
義務付け:mandating:~
一貫性:consistency:~
明瞭性:clarity:~
馴染易さ:familiarity:馴染み易さ
不利:disadvantage:~
利点:advantage:~
多義性:ambiguity:~
状況:situation:~
	／scenario
能:ability:機能
整合する:consistent な:~
決定-:determine:~
	determination
決定法:determining:~
発行-:make:~
取扱う:handle する:~
実施:practice:~
既存の:existing:~
挙動:behavior:ふるまい
開発者:developer:~
明示的:explicit:~
保証:guarantee:~
予期-:expect:~
付録:Appendix:~
特定的:specific:~
追跡-:track:~
影響-:affect:~
概して:typical に:~
用語:term:~
各種用語:terminology:~
	~~理論的に:In theory,
見做して:assume して:~
仕方:way:~
実際:actual:~
柔軟性:flexibility:~
概念的:conceptual:~
直感的:intuitive:~
確立-:establish:~
自明:trivial:~
自由に:free:~
詳細:detail:~
黙って:silent に:~

	前例が無い:unprecedented
	努める:endeavor する
	取り組まな:address しな:~
	取り組まれ:address され:~
	取り組み:address
多目的化:repurpose:~
再利用:reuse:~
	普及の観点:broad consideration
	暫定的:provisional
	主として:chiefly
	混乱:confusing
	~~無分別:imprudent
	用例:Examples of
	用意されて:avail of
	由来:originally／originating
	由来の:に originate している
	草案:draft
	最終作業草案
	要約:summary／Abstract
	要覧:summary:~
	規定:normative／ 
	許可:permission
	説明:illustrate／ 6
	解る様に:meaningfully
	矛盾無く定義された:well-defined
	必然的に導かれ:corollary
	恩恵をもたらす:favor
	必要
	想定:
	意味:
	手引き:guidance:~
	~~経験を積んだ:owing to well-established practice
	ことさら:notably
	ある~~程度 場当たり的:in a more-or-less ad-hoc manner
	介在抜きに:without user intervention
	検討する価値のある妥協点:worthwhile compromise
	なぜ
	方法
	一貫
	不要
	主要
	今日
	注意
	特定
	目的:
	知り得ない:not known
	伴用
	利用

	●構文
ASCII:
正規化:normalize:~
構文解析-:parse::~::パース
構文解析:parse::~::パース
	構文解析器:parser:~::パーサ
直列化-:serialize::~::シリアライズ
直列化:serialization::~::シリアル化
行末:line endings:~

入力:input:~
出力:output:~
文字列:string:~
空文字列:empty string:~
文字:character:~
小文字:lowercase:~
置換文字:replacement character:replacement 文字:~

	●未分類


空:empty::~

	文字集合:character set／charset::~
	小文字: 1::~
	文字~並び:characters／sequence of character 9::~
名前:name:~
名:name:~

置換-:replace:~

構造:structure:~
無効:invalid:~
妥当:valid:~
有効:valid:~
要素:element:~
継承-:inherit:~

変更不可:immutable:~
完了-:complete:~
	読取り完了:process read EOF
完全:complete:~
	抽出-:extract:~

時刻印:time stamp::タイムスタンプ
時刻:time:~
生成-:generate:~
外部出力:export:~
等価:equivalent:~
識別-:identify:~
既定:default:~
既定の:default:~
誘発-:trigger:~
起動-:initiate::~
監視-:monitor:~
永続的:permanent:~

表現-:represent:~
表現:representation:~
変換-:convert:~
情報:information:~
演算:operation:~
	ミリ秒数:milliseconds 数:~
	ミリ秒:milliseconds:~
zero:::ゼロ
最終更新日:last modified date:~
改変-:modify:~
改変:modification:~
変化-:change:~
文脈:context:~
評価-:evaluate:~
画像:image:~
除去-:remove:~

送信-:send:~
保存:save:~
格納-:store:~
	引数:argument:~
	引数:parameter:~
値:value:~
種別:type:~
日時:date:~
共有-:share:~
付加-:append:~
表示:display:~
成分:component:~
解決:resolution:~
終了-:terminate:~
片付け:cleanup::~
真偽:boolean:~
削除-:delete:~
移動-:move:~

単位:unit:~
構文:syntax:~
継続-:continue:~
複製:copy:~


対話:interaction:~
直接的:direct:~
合致-:match:~
複製:copy:~
	負数:negative number 1:~
配列:array:~
保全-:preserve:~
整数:integer:~
引数:argument:~
	初期化:initially set to
	初期時:initial 時:~
新たな:new:~
動作-:act:~
同時並行的:concurrent:~
走らす:run する:走らせる
走らせ:run し:~
検査-:check:~
素描:drawing:~
絵描き:drawing:~

</script>




<!--%他の語彙



	~systemに関わる~file:system-sensitive file
一対一:one-to-one
一覧:table／list
代入:assignment
代理: 1
会社:company 2
位置:position／ 13
個人情報:personal info 1

別名で保存:Save As
利用回数
半分の位置:middle of
参照:reference／refer／ 37
参照先:- 3
	~~反映:set
取得:get／ 13
可能: 5
可能性: 3
名称:name
呼応: 1
喪失:lost
回数: 1
場合: 88
多忙:busy 1
始端:start 1
終端:end 1
存在: 9
実行可能:executable
実行中:it is on
対象: 5
巨大:large 1
成す:constitute
操作可能: 1
数値
数値比較:mathematical comparisons 1
数値演算:mathematical operation 1
集合
最大値:maximum 1
最小値:minimum 1
最終結果: 1
最長:- 1
期間:slots 1
末尾:end 2
楽曲:song 1
構成要素:elements:~
機能:
歌詞:lyrics 3
永続的でない:impermanence％

続行-:proceed
種類: 4
範囲: 6
から経過した:since
経験: 1
継続:process 4
継続的:Keep〜 1
編集注記: 1

自分用:his 1
見当たら:
記述: 1
設定: 7
追加-:add:~
通知を受ける:notify 2
連続する:consecutive
連鎖:chaining
進捗表示:
選択:
選択強制:must choose
選択後:
開始: 7
関連: 4
際限なく:loop
非常:very
頻度:frequent

	●指示語
ある種:certain
一部:
下記
両者
上述:
以上:
以下:
以外:
以降:
任意:
together
他所:elsewhere
後続:
手前
対応
自身
部分
重複
個
個数
番目
直前
直後
一度
主体:entity:~
各種
同上
時点
最初
時機:when
複数回
下位節:-
今日:today
現在
先頭:beginning of／start
全体
単一の:one

-->

<!--%style -->

<style type="text/css">

/* tables */
tr {
	border-bottom: solid 1px #DDDDDD;
}

thead > tr {
	border-bottom: double #333333 3px;
}

i {
	color: purple;
}

samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

.scheme {
	color: #006633;
}

.arg {
	font-family: monospace0, monospace;
}

.code-point {
	font-family: sans-serif0, sans-serif;
}

</style>
<!-- 
.idl-dictionary-member,
-->

</head>

<body>

<input style="display:none;" type="hidden" id="_page_config" value="" />

<aside class="trans-meta">
<h1>File API 仕様 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、<a href="http://www.w3.org/">W3C</a> により，副題の日付にて編集者草案として公開された
<a href="https://w3c.github.io/FileAPI/">File API</a>
<!-- 
<a href="http://www.w3.org/TR/FileAPI/">File API</a>
 -->
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他の Web 関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2017-02-12</time>
（公開：<time>2012-01-03</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>

<a href="https://www.w3.org/" id="_W3C">W3C</a>

	<hgroup>
<h1 id="title">File API</h1>
<h2 id="subtitle">2017 年 2 月 9 日付 W3C 編集者草案</h2>
	</hgroup>

<dl id="_versions">
	<dt title="This Version:">このバージョン</dt>
	<dd>https://w3c.github.io/FileAPI/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>http://www.w3.org/TR/FileAPI/</dd>

	<dt title="Previous Versions:">以前のバージョン</dt>
	<dd>http://www.w3.org/TR/2012/WD-FileAPI-20121025/</dd>
<!-- 
	<dd>http://www.w3.org/TR/2013/WD-FileAPI-20130912/</dd>

https://github.com/w3c/FileAPI/commits/gh-pages
-->

	<dt>Feedback:</dt>
	<dd><span><a href="mailto:public-webapps@w3.org?subject=%5Bfileapi%5D%20YOUR%20TOPIC%20HERE">public-webapps@w3.org</a> with subject line “<kbd>[fileapi] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-webapps/" rel="discussion">archives</a>)</span></dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="https://github.com/w3c/FileAPI/issues/">GitHub</a></dd>
	<dd><a href="#issues-index">仕様内</a></dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="http://arunranga.com/">Arun Ranganathan</a> (Mozilla Corporation) <a class="u-email email" href="mailto:arun@mozilla.com">arun@mozilla.com</a></dd>
	<dd><a href="mailto:mek@chromium.org">Marijn Kruisselbrink</a> (Google)</dd>

</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2017 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document" rel="license">permissive document license</a> rules apply.
</small>

</header>

<hr>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、~Web~appにおいて ~file~objを表現するための
<abbr title="Application Programming Interface">~API</abbr>
を提供する。
これにより、~programによる~fileの選択とその~dataへの~accessが可能になる。
これには次が含まれる：
◎
This specification provides an API for representing file objects in web applications, as well as programmatically selecting them and accessing their data.
This includes:
</p>

<dl>
	<dt>`FileList$I ~interface</dt>
	<dd>
下層~systemから個別に選択された~fileの配列を表現する。
選択~用の~UIは `&lt;input type="file"&gt;^c —
すなわち， <i>File Upload</i> に設定されている
`input$e 要素 `HTML$r
— を通して呼出すことができる。
◎
A FileList interface, which represents an array of individually selected files from the underlying system.
The user interface for selection can be invoked via &lt;input type="file"&gt;, i.e. when the input element is in the File Upload state [HTML].
</dd>

	<dt>`Blob$I ~interface</dt>
	<dd>
変更不可の生~binary~dataを表現する。
`Blob$I ~obj内の一定範囲の~byteに対する~accessも，別個の `Blob$I を通して可能にする。
◎
A Blob interface, which represents immutable raw binary data, and allows access to ranges of bytes within the Blob object as a separate Blob.
</dd>

	<dt>`File$I ~interface</dt>
	<dd>
~fileの名前や（~disk上の）更新日など，~fileについての情報を供する読専の属性を備える。
◎
A File interface, which includes readonly informational attributes about a file such as its name and the date of the last modification (on disk) of the file.
</dd>

	<dt>`FileReader$I ~interface</dt>
	<dd>
`File$I や `Blob$I を読取るための~method,
それらの読取った結果を取得するための~event~modelを提供する。
◎
A FileReader interface, which provides methods to read a File or a Blob, and an event model to obtain the results of these reads.
</dd>

	<dt><a href="#url">~URL~scheme</a></dt>
	<dd>
~fileなどの~binary~dataを~Web~appから参照する用途に利用できる。
◎
A URL scheme for use with binary data such as files, so that they can be referenced within web applications.
</dd>

</dl>

<p>
加えて、この仕様では、~thread化された~Web~appにおける，同期的な~file読取に利用できる~objを定義する。
◎
Additionally, this specification defines objects to be used within threaded web applications for the synchronous reading of files.
</p>

<p>
<a href="#requirements">要件と利用事例</a>
節では、この仕様の背後にある動機を説明する。
◎
§10 Requirements and Use Cases covers the motivation behind this specification.
</p>

<div >
<p>
この~APIは、他の~APIや~Web~platformの構成要素と伴用されるものとして設計されている。
特に、次に挙げるものからは，~programにより~fileの~listが得られるようになるべきである：
</p>

<ul ><li>`XMLHttpRequest$I `XHR$r （例えば
`File$I ／ `Blob$I
型の引数をとる，多重定義された `send()$m ~method）
</li><li>`postMessage()$m
</li><li>`DataTransfer$I （
`HTML$r に定義されている <em>ドラッグ＆ドロップ~API</em> の一部）
</li><li>Web Workers `WORKERS$r
</li><li><i>File Upload state</i> に設定されている `input$e 要素 `HTML$r
</li></ul>

<p>
これらの種類の挙動は、適切な提携の仕様にて定義される。
</p>
◎
This API is designed to be used in conjunction with other APIs and elements on the web platform, notably: XMLHttpRequest (e.g. with an overloaded send() method for File or Blob arguments), postMessage(), DataTransfer (part of the drag and drop API defined in [HTML]) and Web Workers. Additionally, it should be possible to programmatically obtain a list of files from the input element when it is in the File Upload state [HTML]. These kinds of behaviors are defined in the appropriate affiliated specifications.
</div>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<em>この節では、発行時点における…</em>
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>
に委譲
】</span>
◎
This is a public copy of the editors’ draft. It is provided for discussion only and may change at any moment. Its publication here does not imply endorsement of its contents by W3C. Don’t cite this document other than as work in progress.
</p>


<p>
この仕様に対する変更は、
<a href="https://github.com/w3c/FileAPI">https://github.com/w3c/FileAPI</a>
にて。
◎
Changes to this document may be tracked at https://github.com/w3c/FileAPI.
</p>

<p>
この仕様について論を交わす場としては、この仕様の
<a href="https://github.com/w3c/FileAPI">GitHub repository</a>,
公開のメーリングリスト
<a href="mailto:public-webapps@w3.org?Subject=%5Bfileapi%5D%20PUT%20SUBJECT%20HERE">public-webapps@w3.org</a>（
<a href="https://lists.w3.org/Archives/Public/public-webapps/">archive</a>,
）（
<a href="http://www.w3.org/Mail/Request">利用法</a>
）が選好されます。
メールを送る際は、件名の先頭に <kbd>[fileapi]</kbd> と記されるよう願います
— “[fileapi] <em>…summary of comment…</em>” の様に。
◎
If you wish to make comments regarding this document, please send them to this specification’s GitHub repository or (archived) public mailing list public-webapps@w3.org (see instructions). When sending e-mail, please put the text “fileapi” in the subject, preferably like this: “[fileapi] …summary of comment…. All comments are welcome.
</p>

<p>
この文書は
<a href="https://www.w3.org/WebPlatform/WG/">Web Platform Working Group</a>
により制作されました。
◎
This document was produced by the Web Platform Working Group.
◎
This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.
◎
This document is governed by the 1 September 2015 W3C Process Document.
◎
Previous discussion of this specification has taken place on two other mailing lists: public-webapps@w3.org (archive) and public-webapi@w3.org (archive). Ongoing discussion will be on the public-webapps@w3.org mailing list.
</p>

<p>
この草案には、前回の最終作業草案からの変更も含まれています。
コメントがあれば上述のメーリングリスト宛に。
W3C Wiki にて，その草案に対する~feedbackを見れます：
<a href="http://www.w3.org/wiki/Webapps/LCWD-FileAPI-20130912">http://www.w3.org/wiki/Webapps/LCWD-FileAPI-20130912</a>
◎
This draft consists of changes made to the previous Last Call Working Draft. Please send comments to the public-webapi@w3.org as described above. You can see Last Call Feedback on the W3C Wiki: http://www.w3.org/wiki/Webapps/LCWD-FileAPI-20130912
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~Web~appは、~fileを~remoteの~serverへ~uploadしたり, 多彩な~Web~appの中で扱うことも含め、利用者からの入力を可能な限り広範囲に扱えるようになっているべきである。
この仕様は、~file, ~fileの~list, ~fileに~accessする際の~error, ~fileを~program的に読取る仕方についての基本的な表現を定義する。
加えて、適合~UAの~main~threadと非同期に処理し得る “生~data” を表現する~interfaceも定義する。
仕様で定義される~interfaceと~APIは、
~Web~platformに公開されている他の~interfaceや~APIと伴用し得るものになる。
◎
Web applications should have the ability to manipulate as wide as possible a range of user input, including files that a user may wish to upload to a remote server or manipulate inside a rich web application.
This specification defines the basic representations for files, lists of files, errors raised by access to files, and programmatic ways to read files.
Additionally, this specification also defines an interface that represents "raw data" which can be asynchronously processed on the main thread of conforming user agents. The interfaces and API defined in this specification can be used with other interfaces and APIs exposed to the web platform.
</p>

<!-- ＊
“（~fileを）読取る”（ “read” ）：
“読み込む” としても意味は通るが、 “load” の対訳との区別を明確にするため， “read” の対訳には “読み取-” を用いている（一般的に “load” が “読取り” と訳されることは少ないであろうから —
一般概念的に “read” は “load” に対し，より低~level／部分的な，読み込みの処理そのものが（対し， “load” はその結果が）論の対象になる）。
 -->

<p>
`File$I ~interfaceは、概して，（利用者 環境の）下層の~file~systemから得られる~file~dataを表現する。
`Blob$I ~interface（ "Binary Large Object" — 元々は
<a href="#Blob-REF">Google Gears</a> の~Web~APIに由来する名称）は、変更不可の生~dataを表現する。
`File$I／`Blob$I
の読取は~main~threadと非同期に行われるべきものであり、~thread化された~Web~app
`~worker環境下^tnote
においては，同期的~APIを利用する選択肢もある。
非同期~APIによる~fileの読取りにより、~UAの~main~threadの~UIの “無反応” は防止される。
この仕様は
`File$I／`Blob$I
~dataの読取りと~accessのための、<em>~event~model</em> に基づく非同期~APIを定める。
`FileReader$I ~objは、~event~handler内容~属性と~eventの発火を通して ~file~dataへの~accessを行うための，`非同期~読取り~method$を提供する。
~eventと~event~handlerの利用により、<em>読取りの進捗</em>を監視するとき（~file~accessの処理能が~local~driveとは異なる，~remoteの~driveや~mountされた~driveに特に有用になる）と, ~file読取り中に起こり得る`~error条態$を監視するときとで，別々の~code-blockを利用できるようになる。
例で示す：
◎
The File interface represents file data typically obtained from the underlying file system, and the Blob interface ("Binary Large Object" - a name originally introduced to web APIs in Google Gears) represents immutable raw data. File or Blob reads should happen asynchronously on the main thread, with an optional synchronous API used within threaded web applications. An asynchronous API for reading files prevents blocking and UI "freezing" on a user agent’s main thread. This specification defines an asynchronous API based on an event model to read and access a File or Blob’s data. A FileReader object provides asynchronous read methods to access that file’s data through event handler content attributes and the firing of events. The use of events and event handlers allows separate code blocks the ability to monitor the progress of the read (which is particularly useful for remote drives or mounted drives, where file access performance may vary from local drives) and error conditions that may arise during reading of a file. An example will be illustrative.
</p>

<div class="example">
<p>
次の例では［
進捗, ~error, 成功
］の，それぞれの条態に応じて、別々の~code-blockが取扱う。
◎
In the example below, different code blocks handle progress, error, and success conditions.
</p>

<pre class="es-code">
function startRead() {
  /* <span class="comment">
`input$e 要素を DOM から得る
◎
obtain input element through DOM
</span> */

  var file = document.getElementById('file').files[0];
  if(file){
    getAsText(file);
  }
}

function getAsText(readFile) {

  var reader = new FileReader();

  /* <span class="comment">
UTF-16 として~fileを~memory内に読取る
◎
Read file into memory as UTF-16
</span> */
  reader.readAsText(readFile, "UTF-16");

  /* <span class="comment">
進捗, 成功, ~error を取扱う
◎
Handle progress, success, and errors
</span> */
  reader.onprogress = updateProgress;
  reader.onload = loaded;
  reader.onerror = errorHandler;
}

function updateProgress(evt) {
  if (evt.lengthComputable) {
    /* <span class="comment">
`evt.loaded^m および `evt.total^m は `ProgressEvent$I の~prop
◎
evt.loaded and evt.total are ProgressEvent properties
</span> */
    var loaded = (evt.loaded / evt.total);
    if (loaded &lt; 1) {
      /* <span class="comment">
進捗barの長さを増やす
◎
Increase the prog bar length
</span> */
      // style.width = (loaded * 200) + "px";
    }
  }
}

function loaded(evt) {
  /* <span class="comment">
読取られた~file~data（この事例では文字列）を得る
◎
Obtain the read file data
</span> */
  var fileString = evt.target.result;
  /* <span class="comment">
得られた~dataを取扱う
◎
Handle UTF-16 file dump
</span> */
  if(utils.regexp.isChinese(fileString)) {
    /* <span class="comment">
Chinese 文字集合の~~処理
◎
//Chinese Characters + Name validation
</span> */
  }
  else {
    /* <span class="comment">
他の文字集合についての~test
◎
run other charset test
</span> */
  }
  // xhr.send(fileString)
}

function errorHandler(evt) {
  if(evt.target.error.name == "NotReadableError") {
    /* <span class="comment">
~fileを読取れなかった
◎
The file could not be read
</span> */
  }
}
</pre>
</div>


	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>


<p>
この仕様における，~algoの
`終了-@
とは、~UAが実行中の段を終えた所で~algoを終了し~MUSTことを意味する。
この仕様で定義される`非同期~読取り~method$は、当の~algoが終了される前に呼び出し元に戻ることがあり、また， `abort()$m 呼び出しにより終了され得る。
◎
When this specification says to terminate an algorithm the user agent must terminate the algorithm after finishing the step it is on. Asynchronous read methods defined in this specification may return before the algorithm in question is terminated, and can be terminated by an abort() call.
</p>

<p>
max(a,b) ／ min(a,b) は
`WebIDL$r
の定義に従い，常に整数に対するものであり，a と b の最大値／最小値を返す。
例えば max(6,4) の結果は 6 になり，min(6,4) の結果は 4 になる。
この演算は `ECMA-262$r でも定義されている。
◎
The algorithms and steps in this specification use the following mathematical operations:
◎
max(a,b) returns the maximum of a and b, and is always performed on integers as they are defined in WebIDL [WebIDL]; in the case of max(6,4) the result is 6. This operation is also defined in ECMAScript [ECMA-262].
◎
min(a,b) returns the minimum of a and b, and is always performed on integers as they are defined in WebIDL [WebIDL]; in the case of min(6,4) the result is 4. This operation is also defined in ECMAScript [ECMA-262].
◎
Mathematical comparisons such as &lt; (less than), ≤ (less than or equal to), and &gt; (greater than) are as in ECMAScript [ECMA-262].
</p>


<!-- 
&lt; （小なり）, ≤ （以下）, &gt; （大なり）などの数値比較は
ECMA-262$r に従うものとする。
-->

<p>
この仕様に利用される語 
`Unix Epoch@
は、時刻
00:00:00 UTC 1970 年 1 月 1 日（ 1970-01-01T00:00:00Z ISO 8601 ）を指す。
これは、 `ECMA-262$r においては，概念的な 時刻 “0” と同じになる。
◎
The term Unix Epoch is used in this specification to refer to the time 00:00:00 UTC on January 1 1970 (or 1970-01-01T00:00:00Z ISO 8601); this is the same time that is conceptually "0" in ECMA-262 [ECMA-262].
</p>


	</section>
	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW, 此れ, 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
`~Blob@
とは、 `Blob$I ~interfaceを実装する~objの略記である（したがって， `File$I ~interfaceを実装する~objも含まれる）。
</p>

	</section>
	<section id="blob">
<h2 title="The Blob Interface and Binary Data">3. `Blob^I ~interfaceと~binary~data</h2>


<p>
各 `~Blob$は、次のものを内部的に持つ：
</p>

<dl>
	<dt>`参照~byte列@</dt>
	<dd>
~objが自身の~dataとして参照する`~byte列$。
~objの `size$m 属性は，`参照~byte列$の総~byte数を表現し、
`type$m 属性は，その~dataの媒体型を（~ASCII小文字に符号化された文字列として）表現する。
◎
A Blob object refers to a byte sequence, and has a size attribute which is the total number of bytes in the byte sequence, and a type attribute, which is an ASCII-encoded string in lower case representing the media type of the byte sequence.
</dd>

	<dt>`~snapshot状態@</dt>
	<dd>
`参照~byte列$が下層~storageから得られるものである場合にのみ，その~storageの状態を反映するものとして，持た~MUST。
これは、 `StructuredClone$ を経ても保全され~MUST。
`~snapshot状態$についての更なる規定は，
<a href="#file">`File^I ~interface</a>
節にて。
◎
Each Blob must have an internal snapshot state, which must be initially set to the state of the underlying storage, if any such underlying storage exists, and must be preserved through StructuredClone. Further normative definition of snapshot state can be found for Files.
</dd>

</dl>


<pre class="idl">
[<a href="#dom-blob-blob">Constructor</a>(optional sequence&lt;`BlobPart$I&gt; `blobParts$V, optional `BlobPropertyBag$I `options$V),
`Exposed$=(Window,Worker)]

interface `Blob@I {

  readonly attribute unsigned long long `size$m;
  readonly attribute DOMString `type$m;

  /* <span class="comment">
`Blob^I から~byte範囲の~chunkを切出す
◎
slice Blob into byte-ranged chunks
</span> */
  Blob <a href="#dfn-slice">slice</a>(
            [`Clamp$] optional long long `start$V,
            [`Clamp$] optional long long `end$V,
            optional DOMString `contentType$V
  );
};

dictionary `BlobPropertyBag@I {
  DOMString `type$dm = "";
};

typedef (`BufferSource$I or `Blob$I or USVString) `BlobPart@I;
</pre>

		<section id="constructorBlob">
<h3 title="Constructors">3.1. ~Blob構築子</h3>

<p>
`Blob()@m
構築子は、~zero個以上の引数を伴って呼出せる。
◎
The Blob() constructor can be invoked with zero or more parameters. When the Blob() constructor is invoked, user agents must run the following steps:
</p>


<dl class="idl-def">
	<dt>`Blob()^m</dt>
	<dd>
<p>
構築子が引数なしで呼出された場合、次の様に初期化された，新たな `Blob$I ~objを返さ~MUST：
</p>

<ul ><li>`参照~byte列$ ~SET 0 ~byteの~data
</li><li>`size$m ~SET 0
</li><li>`type$m ~SET 空文字列
</li></ul>

◎
If invoked with zero parameters, return a new Blob object consisting of 0 bytes, with size set to 0, and with type set to the empty string.
</dd>

	<dt>`Blob(blobParts, options)^m</dt>
	<dd>
<p>
構築子が引数を伴って呼出された場合、次を走らせ~MUST：
◎
Otherwise, the constructor is invoked with a blobParts sequence. Let a be that sequence.
</p>

		<ol>
			<li>
<p>
%~byte列 ~LET `blobParts$V から`~byte列を構築$した結果
◎
↑</p>

<p>
`BlobPart$I 型~値の連列 %S から
`~byte列を構築@
する手続きは、次で与えられる：
◎
↓</p>
				<ol>
					<li>
%~byte列 ~LET 空`~byte列$
◎
Let bytes be an empty sequence of bytes.
</li>
					<li>
<p>
~FOR
%S 内の~EACH ( %e ) に対し，順に
⇒
［
%e の型に応じて 次で与えられる~byte列
］を， %~byte列 に付加する：
◎
Let length be a’s length. For 0 ≤ i &lt; length, repeat the following steps:
◎
Let element be the ith element of a.
</p>

<dl class="switch">
	<dt>`USVString^I</dt>
	<dd>
%e を`utf-8 符号化-$した結果
◎
If element is a USVString, run the following substeps:
◎
Append the result of UTF-8 encoding s to bytes.
</dd>
	<dd class="note">注記：
<a href="~WEBIDL#dfn-obtain-unicode">~Unicode文字~並びに変換する~algo</a>
`WebIDL$r は、
utf-16 文字列の中の対になっていない（従って妥当でない）代用対を， `FFFD^U 置換文字に置換する。
そのため、 `Blob$I 構築子においては，文字~並びの喪失や並び替わりによる何らかの~data欠損も生じ得る。
◎
Note: The algorithm from WebIDL [WebIDL] replaces unmatched surrogates in an invalid utf-16 string with U+FFFD replacement characters. Scenarios exist when the Blob constructor may result in some data loss due to lost or scrambled character sequences.
</dd>

	<dt>`BufferSource$I</dt>
	<dd>
%e が保持している`~byte列の複製を取得-$した結果
◎
If element is a BufferSource, get a copy of the bytes held by the buffer source, and append those bytes to bytes.
</dd>

	<dt>`~Blob$</dt>
	<dd>
%e が表現する~byte列
— %e の `type$m 属性は無視され、返される `~Blob$ の `type$m には影響しない。
◎
If element is a Blob, append the bytes it represents to bytes. The type of the Blob array element is ignored and will not affect type of returned Blob object.
</dd>
</dl>

					</li>
					<li>
~RET %~byte列
</li>
				</ol>
			</li>
			<li>
%種別 ~SET 空文字列
</li>
			<li>
<p>
~IF［
`options$V 引数は供されている
］, かつ［
`options$V に `type$dm ~member %m は`在する$
］, かつ［
%m の値 %v は［
`0020^U 〜 `007E^U の範囲の文字のみからなる
］］
⇒
%種別 ~SET %v を `~ASCII小文字~化$した結果
</p>

		<div lang="en">
<p>
If the type member of the optional options argument is provided and is not the empty string, run the following sub-steps:
</p>
<ol>
			<li>
Let t be the type dictionary member. If t contains any characters outside the range U+0020 to U+007E, then set t to the empty string and return from these substeps.
</li>
			<li>
Convert every character in t to ASCII lowercase.
</li>
</ol>
		</div>
	</li>
			<li>
<p>
~RET 次の様に設定された，新たな `Blob$I ~obj：
</p>

<ul ><li>`参照~byte列$ ~SET %~byte列
</li><li>`size$m ~SET %~byte列 の長さ
</li><li>`type$m ~SET %種別
</li></ul>

◎
Return a Blob object referring to bytes as its associated byte sequence, with its size set to the length of bytes, and its type set to the value of t from the substeps above.
</li>
		</ol>
	</dd>
</dl>

			<section id="constructorParams">
<h4 title="Constructor Parameters">3.1.1. 構築子に渡す引数</h4>

<p>
`Blob()$m 構築子は、次を引数に呼出せる：
◎
The Blob() constructor can be invoked with the parameters below:
</p>

<dl class="idl-def">
	<dt>`blobParts@V</dt> 
	<dd>
<p>
任意の要素~数からなる IDL 連列~型の引数であって、その各~要素ごとに，次の いずれかの型の値をとり得る：
◎
which takes any number of the following types of elements, and in any order:
</p>

<ul ><li>`BufferSource$I
◎
BufferSource elements.
</li><li>`Blob$I
◎
Blob elements.
</li><li>`DOMString$I
◎
DOMString elements.
</li></ul>

	</dd>

	<dt title="An optional BlobPropertyBag">`options@V</dt>
	<dd>
<p>
この `BlobPropertyBag$I 辞書~型~引数（省略可）は、次の~memberを持つ：
◎
which takes one member:
</p>

		<dl id="dfn-BlobPropertyBagMembers">
			<dt>`type@dm</dt>
			<dd>
`~Blob$の媒体型を表現する，~ASCII小文字に符号化された文字列。
この~memberに対する規定は、
<a href="#constructorBlob">`Blob^I 構築子</a>
節にて与えられる。
◎
type, the ASCII-encoded string in lower case representing the media type of the Blob. Normative conditions for this member are provided in the §3.1 Constructors.
</dd>
		</dl>
	</dd>
	<dd class="trans-note">【
この引数が構築子を呼出す際に省略された場合、
`WebIDL$r に従って，空の辞書~値が渡されたものと見なされる
— `type^dm には，既定~値（空文字列）が与えられているので、
`{ type: "" }^c
が渡されたのと同じことになる。
】</dd>
</dl>


<div class="example">
<p>
構築子の用例：
◎
Examples of constructor usage follow.
</p>

<pre class="es-code">
/* <span class="comment">
新たな `Blob^I ~objを作成する
◎
Create a new Blob object
</span> */

var a = new Blob();

/* <span class="comment">
1024 ~byteの `ArrayBuffer^I を作成する
◎
Create a 1024-byte ArrayBuffer
</span> */
/* <span class="comment">
~bufferは `File^I 読取りからも得られる
◎
buffer could also come from reading a File
</span> */

var buffer = new ArrayBuffer(1024);

/* <span class="comment">
~bufferに基づく `ArrayBufferView^I ~objを作成する
◎
Create ArrayBufferView objects based on buffer
</span> */

var shorts = new Uint16Array(buffer, 512, 128);
var bytes = new Uint8Array(
  buffer,
  shorts.byteOffset + shorts.byteLength
);

var b = new Blob(
  ["foobarbazetcetc" + "birdiebirdieboo"],
  {type: "text/plain;charset=utf-8"}
);

var c = new Blob([b, shorts]);

var a = new Blob([b, c, bytes]);

var d = new Blob([buffer, b, c, bytes]);

</pre>

</div>

			</section>
		</section>
		<section id="attributes-blob">
<h3 title="Attributes">3.2. 属性</h3>

<dl class="idl-def">
	<dt>`size@m</dt>
	<dd>
`参照~byte列$の~sizeを~byte数で返す。
</dd>
	<dd>
取得子は、
`FileReader$I または `FileReaderSync$I ~objにより読取られた，総~byte数を返さ~MUST。
◎
size , of type unsigned long long, readonly
◎
Returns the size of the byte sequence in number of bytes. On getting, conforming user agents must return the total number of bytes that can be read by a FileReader or FileReaderSync object, or 0 if the Blob has no bytes to be read. 
</dd>

	<dt>`type@m</dt>
	<dd>
`~Blob$の媒体型を表現する，~ASCII小文字に符号化された文字列。
</dd>
	<dd>
取得子は、［［
~byte列に変換されたときに`解析可能な MIME 型$になる
］ような，~ASCII小文字に符号化された文字列
］として，返さ~MUST。
ただし，媒体型を決定できない場合（~byte列に変換されたときに 0 ~byteになる）は、空文字列を返さ~MUST。
◎
type , of type DOMString, readonly
◎
The ASCII-encoded string in lower case representing the media type of the Blob. On getting, user agents must return the type of a Blob as an ASCII-encoded string in lower case, such that when it is converted to a byte sequence, it is a parsable MIME type, or the empty string – 0 bytes – if the type cannot be determined.
</dd>
	<dd>
この属性は、~Web~app自身からも［
構築子／ `slice()$m
］の~callを通して設定し得る。
これらの場合に適用される更なる規定は、［
<a href="#constructorBlob">`Blob^I 構築子 節</a>,
<a href="#file-constructor">`File^I 構築子 節</a> ／
<a href="#slice-method-algo">`slice()^m ~method 節</a>
］にて与えられる。
</dd>
	<dd>
~UAは、 `~Blob$の `type$m を，とりわけ `参照~byte列$が~disk上の~file由来のものである場合に 決定できる。
この場合に この属性に適用される更なる規定は、`~file type 指針$にて与えられる。
◎
The type attribute can be set by the web application itself through constructor invocation and through the slice() call; in these cases, further normative conditions for this attribute are in §3.1 Constructors, §4.1 Constructor, and §3.3.1 The slice method respectively. User agents can also determine the type of a Blob, especially if the byte sequence is from an on-disk file; in this case, further normative conditions are in the file type guidelines.
</dd>

	<dd class="note">注記：
`~Blob$の `type$m は、それを表現している~ASCIIに符号化された文字列を~byte列に変換した結果を `MIME 型の構文解析$~algoに渡した結果が undefined でないとき，
`解析可能な MIME 型$であるものと見なされる。
◎
Note: The type t of a Blob is considered a parsable MIME type, if performing the parse a MIME type algorithm to a byte sequence converted from the ASCII-encoded string representing the Blob object’s type does not return undefined.
</dd>
	<dd class="note">注記：
`type$m 属性は、`符号化方式を決定-$するとき, および
`~Blob~URL$に対する`参照取得$の際の
<a href="#processing-media-types">`Content-Type^h ~headerの構文解析</a>
に利用される。<!--  -->
◎
Note: Use of the type attribute informs the encoding determination and parsing the Content-Type header when dereferencing Blob URLs.
</dd>
</dl>

		</section>
		<section id="methodsandparams-blob">
<h3 title="Methods and Parameters">3.3. ~methodと引数</h3>

<dl class="idl-def">
	<dt id="slice-method-algo">`slice(start, end, contentType)@m</dt>
	<dd>
<p>
この~methodは、次のようにされた，新たな `Blob$I ~objを返す：
</p>

<ul ><li>~objの`参照~byte列$は、此れの`参照~byte列$の中の［
`start@V 引数（省略可）から
`end@V 引数（省略可）の直前まで
］の範囲の~byteからなる。
`start$V, `end$V は、~zero番目が最初の~byteを表現する，~byte順の位置として扱われ~MUST。
</li><li>~objの `type$m 属性~値は `contentType@V 値に設定される。
</li></ul>

◎
The slice() method returns a new Blob object with bytes ranging from the optional start parameter up to but not including the optional end parameter, and with a type attribute that is the value of the optional contentType parameter. It must act as follows:
</dd>
	<dd>
<p>
被呼出時には、次に従って動作し~MUST：
◎
↑</p>
		<ol>
			<li>
%size ~LET 此れの `size$m 属性~値
◎
↓</li>
			<li>
<p>
%start ~SET `start$V に応じて，次で与えられる値：
</p>

<ol ><li>供されていない場合は 0
</li><li>負の場合は max( ( %size + `start$V ), 0)
</li><li>他の場合は min( `start$V, %size )
</li></ol>

◎
Let O be the Blob context object on which the slice() method is being called.
◎
The optional start parameter is a value for the start point of a slice() call, and must be treated as a byte-order position, with the zeroth position representing the first byte. User agents must process slice() with start normalized according to the following:
◎
If the optional start parameter is not used as a parameter when making this call, let relativeStart be 0.
◎
If start is negative, let relativeStart be max((size + start), 0).
◎
Else, let relativeStart be min(start, size).
</li>
			<li>
<p>
%end ~SET `end$V に応じて，次で与えられる値：
</p>

<ol ><li>供されていない場合は %size
</li><li>負の場合は max( ( %size + `end$V ), 0 )
</li><li>他の場合は min( `end$V, %size )
</li></ol> 

<!-- 
切出しの終端に対応する値：
 -->
◎
The optional end parameter is a value for the end point of a slice() call. User agents must process slice() with end normalized according to the following:
◎
If the optional end parameter is not used as a parameter when making this call, let relativeEnd be size.
◎
If end is negative, let relativeEnd be max((size + end), 0).
◎
Else, let relativeEnd be min(end, size).
</li>
			<li>
%内容~型 ~LET 空文字列
◎
↓</li>
			<li>
<!-- 
Blob の媒体型を表現する，~ASCII小文字に符号化された文字列：
 -->
~IF［
`contentType$V は供されている
］~AND［
`contentType$V を成すどの文字も `0020^U 〜 `007E^U の範囲に入る
］
⇒
%内容~型 ~SET `contentType$V を `~ASCII小文字~化$した結果
◎
The optional contentType parameter is used to set the ASCII-encoded string in lower case representing the media type of the Blob. User agents must process the slice with contentType normalized according to the following:
◎
If the contentType parameter is not provided, let relativeContentType be set to the empty string .
◎
Else let relativeContentType be set to contentType and run the substeps below:
◎
If relativeContentType contains any characters outside the range of U+0020 to U+007E, then set relativeContentType to the empty string and return from these substeps.
◎
Convert every character in relativeContentType to ASCII lowercase.
</li>
			<li>
%span ~LET max((%end − %start), 0)
◎
Let span be max((relativeEnd - relativeStart), 0).
</li>
			<li>
<p>
~RET 次の様に設定された，新たな `Blob$I ~obj：
◎
Return a new Blob object S with the following characteristics:
</p>

				<ul>
					<li>
`参照~byte列$ ~SET［
此れの`参照~byte列$の中の，~byte位置 %start から連続する %span 個の`~byte列$
］
◎
S refers to span consecutive bytes from O, beginning with the byte at byte-order position relativeStart.
</li>
					<li>
`size$m 属性 ~SET %span
◎
S.size = span.
</li>
					<li>
`type$m 属性 ~SET %内容~型
◎
S.type = relativeContentType.
</li>
				</ul>
			</li>
		</ol>
	</dd>
	<dd class="example">
<p>
下の例に種々の `slice()$m ~callを示す。
`File$I ~interfaceは `Blob$I ~interfaceを継承するので、例は `File$I ~interfaceの利用に基づくものである。
◎
The examples below illustrate the different types of slice() calls possible. Since the File interface inherits from the Blob interface, examples are based on the use of the File interface.
</p>

<pre class="es-code">
/* <span class="comment">
DOM から `input$e 要素を得る
◎
obtain input element through DOM
</span> */

var file = document.getElementById('file').files[0];
if(file) {
  /* <span class="comment">
%file を複製する
— 次の 2 つの~callは等価
◎
create an identical copy of file
the two calls below are equivalent
</span> */

  var fileClone = file.slice();
  var fileClone2 = file.slice(0, file.size);

  /* <span class="comment">
%file の 1/2 ~chunkを半分の位置から切出す
— 負数を用いていることに注意
◎
slice file into 1/2 chunk starting at middle of file
Note the use of negative number
</span> */

  var fileChunkFromEnd = file.slice(-(Math.round(file.size/2)));

  /* <span class="comment">
%file の 1/2 ~chunkを先頭から切出す
◎
slice file into 1/2 chunk starting at beginning of file
</span> */

  var fileChunkFromStart = file.slice(0, Math.round(file.size/2));

  /* <span class="comment">
%file の先頭から，末尾から 150 ~byte手前までの部分を切出す
◎
slice file from beginning till 150 bytes before end
</span> */

  var fileNoMetadata = file.slice(0, -150, "application/experimental");
}
</pre>

	</dd>
</dl>


		</section>
	</section>

	<section id="file">
<h2 title="The File Interface">4. `File^I ~interface</h2>

<p>
`File$I ~objは、［
文字列を値にとる `name$m 属性
］を伴う， `Blob$I ~objである。
それは、~Web~appの中で構築子を通して作成できる。
あるいは，下層の OS ~file~systemの~file由来の`~byte列$への参照である。
◎
A File object is a Blob object with a name attribute, which is a string; it can be created within the web application via a constructor, or is a reference to a byte sequence from a file from the underlying (OS) file system.
</p>

<p>
`File$I ~objの`参照~byte列$が~disk上の~file由来の`~byte列$である場合、その`~snapshot状態$は， `File$I ~objが作成された時点における~disk上の~fileの状態を~~反映するべきである。
◎
If a File object is a reference to a byte sequence originating from a file on disk, then its snapshot state should be set to the state of the file on disk at the time the File object is created.
</p>

<p class="note">注記：
これは~UAにとって実装するのは自明でない要件であるため、
“<em>〜し~MUST</em>” ではなく， “<em>〜すべき</em>”
とされている `RFC2119$r。
~UAは、 `File$I ~objの`~snapshot状態$が，参照が得られる時点における~disk上の下層~storageの状態に設定されるように、努めるべきである。
その時点より後に~disk上の~fileが改変された場合、`~snapshot状態$は，下層~storageの状態と異なるようになる。
~UAは、改変~時刻印その他の仕組みを利用して，`~snapshot状態$を管理してもよいが、それについては実装の詳細に委ねられる。
◎
Note: This is a non-trivial requirement to implement for user agents, and is thus not a must but a should [RFC2119]. User agents should endeavor to have a File object’s snapshot state set to the state of the underlying storage on disk at the time the reference is taken. If the file is modified on disk following the time a reference has been taken, the File's snapshot state will differ from the state of the underlying storage. User agents may use modification time stamps and other mechanisms to maintain snapshot state, but this is left as an implementation detail.
</p>

<p>
`File$I ~objが~disk上の~fileを参照している場合、~UAは，その `type$m 属性が媒体型を返すようにし~MUST。
それは、以下の
`~file type 指針@
に従わ~MUST：
◎
When a File object refers to a file on disk, user agents must return the type of that file, and must follow the file type guidelines below:
</p>

<ul>
	<li>
`type$m 属性の取得子は、~fileの媒体型を［［
対応する~byte列に変換されたときに`解析可能な MIME 型$になる
］ような，~ASCII小文字に符号化された文字列
］として，返さ~MUST。
ただし，媒体型を決定できない場合は、（~byte列に変換されたときに 0 ~byteになる）空文字列を返さ~MUST。
◎
User agents must return the type as an ASCII-encoded string in lower case, such that when it is converted to a corresponding byte sequence, it is a parsable MIME type, or the empty string – 0 bytes – if the type cannot be determined.
</li>
	<li>
`~Blob$の `type$m が `text/plain^c である場合、
~UAは，［
媒体型の［
`~parameterの辞書$の部分
］］に charset ~parameterを付加しては<em>~MUST_NOT</em>。
◎
When the file is of type text/plain user agents must NOT append a charset parameter to the dictionary of parameters portion of the media type [MIMESNIFF].
</li>
	<li>
~UAは，（統計的手法も含め）経験則により符号化方式を決定しようと試みては~MUST_NOT。
◎
User agents must not attempt heuristic determination of encoding, including statistical methods.
</li>
</ul>


<pre class="idl">
[<a href="#dom-file-file">Constructor</a>(
    sequence&lt;`BlobPart$I&gt; `fileBits$V,
    USVString `fileName$V,
    optional `FilePropertyBag$I `options$V
),
  `Exposed$=(`Window$I,`Worker$I)]
interface `File@I : `Blob$I {
  readonly attribute DOMString `name$m;
  readonly attribute long long `lastModified$m;
};

dictionary `FilePropertyBag@I : `BlobPropertyBag$I {
      long long `lastModified$dm;
};
</pre>

		<section id="file-constructor">
<h3 title="Constructor">4.1. `File^I の構築子</h3>

<p class="idl-def">
`File()@m
構築子は、辞書~引数（省略可）を利用するかどうかに応じて， 2 個ないし 3 個の引数で呼出される。
被呼出時には、次を走らせ~MUST：
◎
The File constructor is invoked with two or three parameters, depending on whether the optional dictionary parameter is used. When the File() constructor is invoked, user agents must run the following steps:
</p>


<ol>
	<li>
<p>
%~byte列 ~LET `fileBits$V から`~byte列を構築$した結果
</p>

		<div lang="en">
<p>
Let a be the fileBits sequence argument. Let bytes be an empty sequence of byte. Let length be a’s length. For 0 ≤ i &lt; length, repeat the following steps:
</p>

<ol>
	<li>
Let element be the i’th element of a.
</li>
	<li>
<p>
If element is a USVString, run the following substeps:
</p>
		<ol>
			<li>
<p>
Append the result of UTF-8 encoding s to bytes.
</p>

<p class="note">
Note: The algorithm from WebIDL [WebIDL] replaces unmatched surrogates in an invalid utf-16 string with U+FFFD replacement characters. Scenarios exist when the Blob constructor may result in some data loss due to lost or scrambled character sequences.
</p>
			</li>
		</ol>
	</li>
	<li>
If element is a BufferSource, get a copy of the bytes held by the buffer source, and append those bytes to bytes.
</li>
	<li>
If element is a Blob, append the bytes it represents to bytes. The type of the Blob argument must be ignored.
</li>
</ol>
		</div>
	</li>
	<li>
<p>
%名前 ~LET 
`fileName$V 引数を複製した上で，その中のすべての［
文字 `/^l (`002F^U SOLIDUS)
］を［
文字 `:^l (`003A^U COLON)
］に置換した結果
◎
Let n be a new string of the same size as the fileName argument to the constructor. Copy every character from fileName to n, replacing any "/" character (U+002F SOLIDUS) with a ":" (U+003A COLON).
</p>

<p class="note">注記：
~file名に用いられる規約は、下層の OS ~file~system間で異なる
— 構築された~fileに対する UTF-16 の義務付けは、~file名が`~byte列$に変換されたときの多義性を起こり難くする。
◎
Note: Underlying OS filesystems use differing conventions for file name; with constructed files, mandating UTF-16 lessens ambiquity when file names are converted to byte sequences.
</p>

	</li>
	<li>
%種別 ~LET 空文字列
◎
↓</li>
	<li>
%日時 ~LET `Unix Epoch$ から経過したミリ秒数（
`Date.now()^m `ECMA-262$r
と等価）
◎
↓</li>
	<li>
<p>
~IF［
`fileOptions$V 辞書~引数 %o は供されている
］：
◎
If the optional FilePropertyBag dictionary argument is used, then run the following substeps:
</p>
		<ol>
			<li>
~IF［
%o に
`type$dm ~member %m は`在する$
］, かつ［
%m の値 %v は［
`0020^U 〜 `007E^U の範囲の文字のみからなる
］］
⇒
%種別 ~SET %v を `~ASCII小文字~化$した結果
◎
If the type member is provided and is not the empty string, let t be set to the type dictionary member. If t contains any characters outside the range U+0020 to U+007E, then set t to the empty string and return from these substeps.
◎
Convert every character in t to ASCII lowercase.
</li>
			<li>
<p>
~IF［
%o に `lastModified$dm ~memberは`在する$
］
⇒
%日時 ~SET その値
◎
If the lastModified member is provided, let d be set to the lastModified dictionary member. If it is not provided, set d to the current date and time represented as the number of milliseconds since the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
</p>

<p class="note">注記：
`ECMA-262$r `Date$I ~objは， `Unix Epoch$ から経過したミリ秒数を表現する `long long^c 値に変換されるので、 `lastModified$dm ~member値に `Date^I ~objを供することもできる。
◎
Note: Since ECMA-262 Date objects convert to long long values representing the number of milliseconds since the Unix Epoch, the lastModified member could be a Date object [ECMA-262].
</p>

			</li>
		</ol>
	</li>
	<li>
<p>
~RET 各種 属性が次の様に設定された，新たな `File$I ~obj：
◎
Return a new File object F such that:
</p>

		<ul>
			<li>
`参照~byte列$ ~SET %~byte列
◎
F refers to the bytes byte sequence.
</li>
			<li>
`size$m ~SET %~byte列 の総~byte数
◎
F.size is set to the number of total bytes in bytes.
</li>
			<li>
`name$m ~SET %名前
◎
F.name is set to n.
</li>
			<li>
`type$m ~SET %種別
◎
F.type is set to t.
</li>
			<li>
`lastModified$m ~SET %日時
◎
F.lastModified is set to d.
</li>
		</ul>
	</li>
</ol>

			<section id="file-constructor-params">
<h4 title="Constructor Parameters">4.1.1. 構築子に渡す引数</h4>

<p>
`File()$m 構築子は次の引数を伴って呼出され得る：
◎
The File() constructor can be invoked with the parameters below:
</p>

<dl class="idl-def">
	<dt>`fileBits@V</dt>
	<dd>
`blobParts$V と同じ。
◎
A fileBits sequence which takes any number of the following elements, and in any order:
◎
BufferSource elements.
◎
Blob elements, which includes File elements.
◎
DOMString elements.
</dd>

	<dt>`fileName@V</dt>
	<dd>
~fileの名前を表現する `USVString$I 型の文字列。
この引数に対する規定は， 
<a href="#file-constructor">`File^I 構築子 節</a>
にて与えられる。
◎
A USVString parameter representing the name of the file; normative conditions for this constructor parameter can be found in §4.1 Constructor.
</dd>

	<dt>`fileOptions@V
◎
An optional FilePropertyBag dictionary
</dt>
	<dd>
<p>
この `FilePropertyBag$I 辞書~型~引数（省略可）は、
`BlobPropertyBag$I の~memberに加えて，次の~memberを持つ（いずれも省略可）：
◎
which in addition to the members of BlobPropertyBag takes one member:
</p>
		<dl>
			<dt>`lastModified@dm</dt>
			<dd>
~fileの更新日を表現する， `long long^c 型~値。
この~memberに対する規定は，
<a href="#file-constructor">`File^I 構築子 節</a>
にて与えられる。
◎
An optional lastModified member, which must be a long long; normative conditions for this member are provided in §4.1 Constructor.
</dd>
		</dl>
	</dd>
	<dd class="trans-note">【
`options$V と同様に、この引数も，構築子を呼出すときに省略された場合、空の辞書~値が渡されたものと見なされる。
】</dd>
</dl>


			</section>
		</section>
		<section id="file-attrs">
<h3 title="Attributes">4.2. 属性</h3>

<dl class="idl-def">
	<dt>`name@m</dt>
	<dd>
~fileの名前。
◎
name , of type DOMString, readonly
</dd>
	<dd>
取得子は、~fileの名前を文字列として返さ~MUST。
~file名には，下層の OS ~file~system間でいくつもの規約があるが、これは~path情報を持たない単なる~fileの名前である。
~UAは、取得-時に この情報を可用にできない場合は，空文字列を返さ~MUST。
◎
The name of the file. On getting, this must return the name of the file as a string. There are numerous file name variations and conventions used by different underlying OS file systems; this is merely the name of the file, without path information. On getting, if user agents cannot make this information available, they must return the empty string. If a File object is created using a constructor, further normative conditions for this attribute are found in §4.1 Constructor.
</dd>
	<dd>
構築子を用いて作成された `File$I ~objにおける，この属性に適用される更なる規定は、
<a href="#file-constructor">`File^I 構築子 節</a>
にて与えられる。
◎
↑</dd>

	<dt>`lastModified@m</dt>
	<dd>
~fileの最終更新日。
◎
lastModified , of type long long, readonly
</dd>
	<dd>
取得子は、［
この情報を可用にできるならば、 ~fileの最終更新日 ／
知り得ない場合は現在の日時（ `Date.now()^m `ECMA-262$r に等価）
］を［
`Unix Epoch$ から経過したミリ秒数による `long long^I 型の値
］として返さ~MUST。
◎
The last modified date of the file. On getting, if user agents can make this information available, this must return a long long set to the time the file was last modified as the number of milliseconds since the Unix Epoch. If the last modification date and time are not known, the attribute must return the current date and time as a long long representing the number of milliseconds since the Unix Epoch; this is equivalent to Date.now() [ECMA-262]. If a File object is created using a constructor, further normative conditions for this attribute are found in §4.1 Constructor.
</dd>
	<dd>
構築子を用いて作成された `File$I ~objにおける，この属性に適用される更なる規定は、
<a href="#file-constructor">`File^I 構築子 節</a>
にて与えられる。
◎
↑</dd>
</dl>

		</section>

<p>
`File$I ~interface`を実装する~obj^tnote
は `FileList$I 型の属性を公開する~objから得られる。
その種の~objは~HTML `HTML$r にて定義されている。
`File$I ~objは、 `Blob$I を継承する変更不可の~objであり，`読取り演算$が起動された時点で~memory内に読取り可能な~file~dataを表現する。
~UAは、読取り中に~fileが存在しなくなっていた場合には，`読取り~error$とし~MUST：
すなわち、（ Web Worker `WORKERS$r の下で） `FileReaderSync$I が用いられている場合は `NotFoundError$E 例外を`投出$し、他の場合は，［
`error$m 属性が `NotFoundError$E 例外を返す
］ようにした上で `error$et ~eventを`発火-$する。
◎
The File interface is available on objects that expose an attribute of type FileList; these objects are defined in HTML [HTML]. The File interface, which inherits from Blob, is immutable, and thus represents file data that can be read into memory at the time a read operation is initiated. User agents must process reads on files that no longer exist at the time of read as errors, throwing a NotFoundError exception if using a FileReaderSync on a Web Worker [Workers] or firing an error event with the error attribute returning a NotFoundError.
</p>


<div class="example">
<p>
下の例では、~file~objからの~metadataが解る様に表示された上で，名前と最終更新日が伴われた `File$I ~objが作成される：
◎
In the examples below, metadata from a file object is displayed meaningfully, and a file object is created with a name and a last modified date.
</p>

<pre class="es-code">
var file = document.getElementById("filePicker").files[0];
var date = new Date(file.lastModified);
println(
    "You selected the file " + file.name +
    " which was modified on " + date.toDateString() + "."
);

...

/* <span class="comment">
特定の最終更新日が伴われた~fileを生成する
◎
Generate a file with a specific last modified date
</span> */

var d = new Date(2013, 12, 5, 16, 23, 45, 600);
var generatedFile = new File(
    ["Rough Draft ...."],
    "Draft1.txt",
    {type: "text/plain", lastModified: d}
);

...</pre>

</div>


	</section>
	<section id="filelist-section">
<h2 title="The FileList Interface">5. `FileList^I ~interface</h2>

<p class="note">注記：
`FileList^I ~interfaceは “~risk下にある” ものと見なされるべきである。
~Web~platformでは、この種の~interfaceを
`ECMA-262$r における `Array$I platform ~objに置換するのが，趨勢なので。
特に、
`filelist.item(0)^c の類の構文は~risk下にある。
他のほとんどの［
~programにおける `FileList^I の利用
］については、最終的に `Array^I 型に移行されたとしても，およそ影響されないものと見込まれる。
◎
Note: The FileList interface should be considered "at risk" since the general trend on the Web Platform is to replace such interfaces with the Array platform object in ECMAScript [ECMA-262]. In particular, this means syntax of the sort filelist.item(0) is at risk; most other programmatic use of FileList is unlikely to be affected by the eventual migration to an Array type. 
</p>

<p>
この~interfaceは `File$I ~objの~listを表現する。
◎
This interface is a list of File objects.
</p>

<pre class="idl">
[`Exposed$=(`Window$I,`Worker$I)] interface `FileList@I {
  getter `File$I? <a href="#dfn-item">item</a>(unsigned long `index$V);
  readonly attribute unsigned long `length$m;
};
</pre>

<div class="example">
<p>
~sampleにおいては、概して，~form内の `&lt;input type="file"&gt;^e 要素への DOM ~access, および選択された~fileへの~accessが含められる。
◎
Sample usage typically involves DOM access to the &lt;input type="file"&gt; element within a form, and then accessing selected files.
</p>

<pre class="es-code">
/* <span class="comment">
`uploadData^c は `form$e 要素 ／
`fileChooser^c は `type='file'^c の `input$e 要素
◎
uploadData is a form element
fileChooser is input element of type 'file'
</span> */
var file = document.forms['uploadData']['fileChooser'].files[0];

/* <span class="comment">
等価な構文
◎
alternative syntax can be
</span> */
// var file = document.forms['uploadData']['fileChooser'].files.item(0);

if(file)
{
  /* <span class="comment">
~fileを開く
◎
Perform file ops
</span> */
}
</pre>
</div>



		<section id="attributes-filelist">
<h3 title="Attributes">5.1. 属性</h3>

<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
`FileList$I ~objに含まれる~file数（存在しなければ 0 ）を返さ~MUST。
◎
length , of type unsigned long, readonly
◎
must return the number of files in the FileList object. If there are no files, this attribute must return 0.
</dd>
</dl>


		</section>
		<section id="filelist-methods-params">
<h3 title="Methods and Parameters">5.2. ~methodと引数</h3>

<dl class="idl-def">
	<dt>`item(index)@m</dt>
	<dd>
`FileList$I の中から `index$V 番の `File$I ~objを返さ~MUST。
`index^V 番に~objが存在しない場合、 ~NULL を返さ~MUST。
◎
must return the indexth File object in the FileList. If there is no indexth File object in the FileList, then this method must return null.
</dd>
	<dd>
`index@V
引数は、 `FileList$I における `File$I ~objの位置を指し，値 0 が最初の~fileを指すものとする。
`FileList$I ~objの`被support~prop~index$は、
0 以上［
含まれる `File$I ~objの総数
］未満とする。
◎
index must be treated by user agents as value for the position of a File object in the FileList, with 0 representing the first file. Supported property indices are the numbers in the range zero to one less than the number of File objects represented by the FileList object. If there are no such File objects, then there are no supported property indices.
</dd>
</dl>


<p class="note">注記：
`HTML$r における `FileList^I 型の読専~属性を持つ~interfaceには、
`HTMLInputElement^I, `DataTransfer^I 
がある。
前者は，上の例でも~accessされている。
◎
Note: The HTMLInputElement interface has a readonly attribute of type FileList, which is what is being accessed in the above example. Other interfaces with a readonly attribute of type FileList include the DataTransfer interface.
</p>

		</section>
	</section>

	<section id="reading-data-section">
<h2 title="Reading Data">6. ~dataの読取</h2>

		<section id="readOperationSection">
<h3 title="The Read Operation">6.1. 読取り演算</h3>


<div class="p">
<p>
この節では、この仕様の~methodから呼出される`読取り演算$の~algoを定義する。
読取り演算には，次のものが渡され、~byte~streamとして読取られた`~byte列$を返すか，`失敗事由$を伴って失敗する：
</p>

<ul><li>`~Blob$
</li><li>`同期~flag@
— 演算は、この値に応じて［
~ON ならば同期的 ／
~OFF （既定）ならば非同期的
］に行われる。
</li></ul>

◎
The algorithm below defines a read operation, which takes a Blob and a synchronous flag as input, and reads bytes into a byte stream which is returned as the result of the read operation, or else fails along with a failure reason. Methods in this specification invoke the read operation with the synchronous flag either set or unset.
◎
The synchronous flag determines if a read operation is synchronous or asynchronous, and is unset by default. Methods may set it. If it is set, the read operation takes place synchronously. Otherwise, it takes place asynchronously.
</div>

<p>
`読取り演算@
を遂行するときは、所与の
( `~Blob$ %blob, `同期~flag$ %同期~flag )
に対し，次を走らす：
◎
To perform a read operation on a Blob and the synchronous flag, run the following steps:
</p>

<div>

<ol>
	<li>
%本体 ~LET 新たな `本体$
</li>
	<li>
%本体 の`総~byte数$ ~SET %blob の `size$m
</li>
	<li>
~IF［
%同期~flag ~EQ ~OFF
］
⇒
~RET
— ただし，この手続きは並列的に継続する
</li>
	<li>
<p>
~WHILE［
%blob からすべての~byteを読取り尽くしていない
］：
</p>

		<ol>
			<li>
%~byte列 ~LET %blob から`~chunk$の読取を試みた結果の~byte列
</li>
			<li>
<p>
~IF［
前~段にて`読取り~error$が生じた
］：
</p>

				<ul>
					<li>
%本体 の~error~flag ~SET ~ON
<span class="trans-note">【
この~flagは `Fetch$r 仕様から削除された
】</span>
</li>
					<li>
~RET
— `失敗事由$も伴わせて`終了-$する
</li>
				</ul>
			</li>
			<li>
%本体 に %~byte列 を~pushする
</li>
			<li>
%本体 の`伝送済み~byte数$に %~byte列 の~byte数を加算する
</li>
		</ol>
	</li>
	<li>
~IF［
%同期~flag ~EQ ~ON
］
⇒
~RET %本体
</li>
</ol>


<ol lang="en">
	<li>
<p>
Let s be a a new body, b be the Blob to be read from, and bytes initially set to an empty byte sequence. Set the length on s to the size of b. While there are still bytes to be read in b, perform the following substeps:
</p>

	</li>
	<li>
<p>
If the synchronous flag is set, follow the steps below:
</p>
		<ol>
			<li>
<p>
Let bytes be the byte sequence that results from reading a chunk from b. If a file read error occurs reading a chunk from b, return s with the error flag set, along with a failure reason, and terminate this algorithm.
</p>

<p>
Note: Along with returning failure, the synchronous part of this algorithm must return the failure reason that occurred for throwing an exception by synchronous methods that invoke this algorithm with the synchronous flag set.
</li>
			<li>
If there are no errors, push bytes to s, and increment s’s transmitted [Fetch] by the number of bytes in bytes. Reset bytes to the empty byte sequence and continue reading chunks as above.
</li>
			<li>
When all the bytes of b have been read into s, return s and terminate this algorithm.
</li>
		</ol>
	</li>
	<li>
Otherwise, the synchronous flag is unset. Return s and process the rest of this algorithm asynchronously.
</li>
	<li>
<p>
Let bytes be the byte sequence that results from reading a chunk from b. If a file read error occurs reading a chunk from b, set the error flag on s, and terminate this algorithm with a failure reason.
</p>

<p>
Note: The asynchronous part of this algorithm must signal the failure reason that occurred for asynchronous error reporting by methods expecting s and which invoke this algorithm with the synchronous flag unset.
</p>
	</li>
	<li>
If no file read error occurs, push bytes to s, and increment s’s transmitted [Fetch] by the number of bytes in bytes. Reset bytes to the empty byte sequence and continue reading chunks as above.
</li>
</ol>

</div>


<p>
所与の`~Blob$ %blob に対し，
`注釈付き~task読取り演算@
を遂行するときは、［
`同期~flag$ ~SET ~OFF
］の下で %blob に対する`読取り演算$ %演算 を遂行した上で，以下に従う：
◎
To perform an annotated task read operation on a Blob b, perform the steps below:
◎
Perform a read operation on b with the synchronous flag unset, along with the additional steps below.
</p>

<ul>
	<li>
%演算 が`失敗事由$を伴って終了したときは
⇒
その`失敗事由$で
`読取り~errorを処理する@
ための`~taskを待入する$
◎
If the read operation terminates with a failure reason, queue a task to process read error with the failure reason and terminate this algorithm.
</li>
	<li>
<p>
%演算 の間に最初の`~chunk$が %body に~pushされるとき†は
⇒
`読取りを開始する@
ための`~taskを待入する$。
◎
When the first chunk is being pushed to the body s during the read operation, queue a task to process read.
</p>

<p class="trans-note">【†
“being pushed”
— ~pushされる直前なのか？した直後なのか？。
原文の記述からは、`読取りを開始する$ための~task（ `loadstart$et ）抜きで`読取り~errorを処理する$ 可能性も排除できない。
】</p>
	</li>
	<li>
<p >
次に該当する各~時点に
`読取り~dataを処理する@
ための`~taskを待入する$：
</p>

<ul ><li>(A) 最初に %演算 により %body に 1 個以上の`~chunk$が読取られたとき
</li><li>%blob から読取る`~chunk$が尽きたとき
</li><li>(A) の時点から［
`~chunk$が読取られるごと, または毎 50ms ごとの, <em >少ない方の頻度</em>
］の各時点
</li></ul>

◎
Once the body s from the read operation has at least one chunk read into it, or there are no chunks left to read from b, queue a task to process read data. Keep queuing tasks to process read data for every chunk read or every 50ms, whichever is least frequent.
</li> 

	<li>
%演算 により， %blob からすべての`~chunk$が %body に読取られたときは
⇒
`読取り完了@
のための`~taskを待入する$。
◎
When all of the chunks from b are read into the body s from the read operation, queue a task to process read EOF.
</li>
</ul>

<p>
これらの~taskには，同じ`~file読取~task源$を利用すること。
◎
Use the file reading task source for all these tasks.
</p>


		</section>
		<section id="blobreader-task-source">
<h3 title="The File Reading Task Source">6.2. ~file読取~task源</h3>

<p>
この仕様は、
`~file読取~task源@
と呼ばれる，新たな汎用`~task源$を定義する。
それは、この仕様にて、`~Blob$に結び付けられている~byte列を読取るために，`待入され$る~task
］すべてから利用される。
それはまた、~binary~dataの非同期的な読取に呼応して誘発される特色機能
`~eventなど^tnote
のためにも利用される。
◎
This specification defines a new generic task source called the file reading task source, which is used for all tasks that are queued in this specification to read byte sequences associated with Blob and File objects. It is to be used for features that trigger in response to asynchronously reading binary data.
</p>

		</section>
		<section id="APIASynch">
<h3 title="The FileReader API">6.3. `FileReader^I ~API</h3>

<pre class="idl">
[<a href="#dom-filereader-filereader">Constructor</a>, `Exposed$=(`Window$I,`Worker$I)]
interface `FileReader@I: `EventTarget$I {

  /* <span class="comment">
`非同期~読取り~method$
◎
async read methods
</span> */
  void `readAsArrayBuffer$m(`Blob$I `blob$V);
  void `readAsBinaryString$m(`Blob$I `blob$V);
  void `readAsText$m(`Blob$I `blob$V, optional DOMString `label$V);
  void `readAsDataURL$m(`Blob$I `blob$V);
  void `abort()$m;

  /* <span class="comment">
状態
◎
states
</span> */
  const unsigned short `EMPTY$m = 0;
  const unsigned short `LOADING$m = 1;
  const unsigned short `DONE$m = 2;


  readonly attribute unsigned short `readyState$m;

  /* <span class="comment">
`File^I または `Blob^I ~data
◎
File or Blob data
</span> */
  readonly attribute (DOMString or `ArrayBuffer$I)? `result$m;

  readonly attribute `DOMException$I? `error$m;

  /* <span class="comment">
~event~handler内容~属性
◎
event handler content attributes
</span> */
  attribute `EventHandler$I `onloadstart$m;
  attribute `EventHandler$I `onprogress$m;
  attribute `EventHandler$I `onload$m;
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `onerror$m;
  attribute `EventHandler$I `onloadend$m;

};
</pre>


			<section id="filereaderConstrctr">
<h4 title="Constructors">6.3.1. 構築子</h4>

<p class="idl-def">
`FileReader()@m
構築子の被呼出時には、新たな `FileReader$I ~objを返さ~MUST。
◎
When the FileReader() constructor is invoked, the user agent must return a new FileReader object.
</p>

<p>
大域~objが［
`Window$I ／ `WorkerGlobalScope$I
］~objで表現される環境においては、
`FileReader()$m 構築子は，可用にされ~MUST。
◎
In environments where the global object is represented by a Window or a WorkerGlobalScope object, the FileReader constructor must be available.
</p>

			</section>
			<section id="event-handler-attributes-section">
<h4 title="Event Handler Content Attributes">6.3.2. ~event~handler内容~属性</h4>

<p>
~UAは、 `FileReader$I の DOM 属性として，次の`~event~handler内容~属性$（およびそれらに対応する`~event~handler ~event型$
）を~supportし~MUST：
◎
The following are the event handler content attributes (and their corresponding event handler event types) that user agents must support on FileReader as DOM attributes:
</p>

<table>
<thead><tr><th>`~event~handler内容~属性$
<th>`~event~handler ~event型$
</thead>

<tbody><tr><td>`onloadstart@m
<td>`loadstart$et

<tr><td>`onprogress@m
<td>`progress$et

<tr><td>`onabort@m
<td>`abort$et

<tr><td>`onerror@m
<td>`error$et

<tr><td>`onload@m
<td>`load$et

<tr><td>`onloadend@m
<td>`loadend$et

</tbody></table>

			</section>
			<section id="blobreader-state">
<h4 title="FileReader States">6.3.3. `FileReader^I の状態</h4>

<p>
`FileReader$I ~objは３種類の状態をとり得る。
`readyState@m 属性の取得子は、現在の状態が次のいずれかの値として返され~MUST：
◎
The FileReader object can be in one of 3 states. The readyState attribute, on getting, must return the current state, which must be one of the following values:
</p>

<dl class="idl-def">
	<dt>`EMPTY@m （数値 0 ）</dt>
	<dd>
`FileReader$I ~objは構築~済みであるが、まだ読取り待ちは生じていない。
`読取り~method$はまだ一度も~callされていない。
これが、いずれかの`読取り~method$が~callされるまでの，新たに創出された `FileReader$I ~objにおける既定の状態である。
◎
The FileReader object has been constructed, and there are no pending reads. None of the read methods have been called. This is the default state of a newly minted FileReader object, until one of the read methods have been called on it.
</dd>

	<dt>`LOADING@m （数値 1 ）</dt>
	<dd>
`~Blob$は読取り中の状態にある。
`読取り~method$のいずれかが処理されていて，読取りにまだ~errorは生じていない。
◎
A File or Blob is being read. One of the read methods is being processed, and no error has occurred during the read.
</dd>

	<dt>`DONE@m （数値 2 ）</dt>
	<dd>
`~Blob$の全体が~memory内に読取られたか,
<em >または</em> `読取り~error$が生じたか,
<em >または</em> 読取りが `abort()$m により中止されている。
`FileReader$I はそれ以上`~Blob$の読取を行わない。
`readyState$m ~EQ `DONE$m
の場合、少なくともいずれかの`読取り~method$がこの `FileReader$I 上で~callされている。
◎
The entire File or Blob has been read into memory, OR a file read error occurred, OR the read was aborted using abort(). The FileReader is no longer reading a File or Blob. If readyState is set to DONE it means at least one of the read methods have been called on this FileReader.
</dd>
</dl>

			</section>
			<section id="reading-a-file">
<h4 title="Reading a File or Blob">6.3.4. `File^I／`Blob^I の読取</h4>

<p>
`FileReader$I ~interfaceには、~fileを非同期的に~memory内に読取る数種の
`非同期~読取り~method@
— `readAsArrayBuffer()$m, `readAsBinaryString()$m, `readAsText()$m, `readAsDataURL()$m —
が可用にされている。
これらの読取り~methodが，同じ `FileReader$I ~objに対し同時並行的に重ねて~callされた場合、~UAは［
`readyState$m ~EQ `LOADING$m
］の間に生じたどの読取り~methodに対しても，
`InvalidStateError$E を`投出$し~MUST。
◎
The FileReader interface makes available several asynchronous read methods—readAsArrayBuffer(), readAsBinaryString(), readAsText() and readAsDataURL(), which read files into memory. If multiple concurrent read methods are called on the same FileReader object, user agents must throw an InvalidStateError on any of the read methods that occur when readyState = LOADING.
</p>

<p>
`FileReaderSync$I も，類似する数種の`同期~読取り~method$を可用にする。
これらの同期／非同期の読取り~methodは、併せて，
`読取り~method@
と総称される。
◎
(FileReaderSync makes available several synchronous read methods. Collectively, the sync and async read methods of FileReader and FileReaderSync are referred to as just read methods.)
</p>


				<section id="filedata-attr">
<h5 title="The result attribute">6.3.4.1. `result^m 属性</h5>

<dl class="idl-def">
	<dt>`result@m</dt>
	<dd>
`FileReader$I に対し~callされた`読取り~method$に応じて, および~errorが生じた場合はその~errorに応じて、［
`DOMString$I, `ArrayBuffer$I, ~NULL
］のいずれかになる。
◎
↓</dd>
	<dd>
<p>
取得子は、次の手続きの結果で与えられる`~Blob$の~dataを返さ~MUST：
◎
On getting, the result attribute returns a Blob's data as a DOMString, or as an ArrayBuffer, or null, depending on the read method that has been called on the FileReader, and any errors that may have occurred.
◎
The list below is normative for the result attribute and is the conformance criteria for this attribute:
</p>

		<ol>
			<li>
~IF［
此れの `readyState$m ~EQ `EMPTY$m （まだ此れ上に`読取り~method$は~callされていない）
］
⇒
~RET ~NULL
◎
On getting, if the readyState is EMPTY (no read method has been called) then the result attribute must return null.
</li>
			<li>
~IF［
`~Blob$の読取に~errorが生じていた
］
⇒
~RET ~NULL （利用されている`読取り~method$に<em >かかわらず</em>）
◎
On getting, if an error in reading the File or Blob has occurred (using any read method) then the result attribute must return null.
</li>
			<li>
<p>
~RET 此れ上で~callされた`読取り~method$に応じて，次で与えられる値：
◎
↓</p>

<dl class="switch">
	<dt>`readAsDataURL()$m</dt>
	<dd>
`~Blob$の~dataを`~data_URL$に符号化した結果の `DOMString$I
◎
On getting, if the readAsDataURL() read method is used, the result attribute must return a DOMString that is a Data URL [RFC2397] encoding of the File or Blob's data.
</dd>

	<dt>`readAsBinaryString()$m</dt>
	<dd>
`~Blob$の~dataを，［
その各~byteを等しい値の符号単位（範囲 0 〜 255 ）で表現する~binary文字列
］として表現する `DOMString$I
◎
On getting, if the readAsBinaryString() read method is called and no error in reading the File or Blob has occurred, then the result attribute must return a DOMString representing the File or Blob's data as a binary string, in which every byte is represented by a code unit of equal value [0...255].
</dd>

	<dt>`readAsText()$m</dt>
	<dd>
`~Blob$の~dataを表現する~text文字列。
この文字列は`符号化方式を決定-$した結果の形式の下で， `DOMString$I として~memory内に`復号-$されるべきである。
◎
On getting, if the readAsText() read method is called and no error in reading the File or Blob has occurred, then the result attribute must return a string representing the File or Blob's data as a text string, and should decode the string into memory in the format specified by the encoding determination as a DOMString.
</dd>

	<dt>`readAsArrayBuffer()$m</dt>
	<dd>
`~Blob$の~dataを表現する `ArrayBuffer$I ~obj。
◎
On getting, if the readAsArrayBuffer() read method is called and no error in reading the File or Blob has occurred, then the result attribute must return an ArrayBuffer object.
</dd>
</dl>
			</li>
		</ol>

	</dd>

<!-- ＊
読取り中（
`readyState$m が `LOADING$m
）の場合の記述が抜けている（ ~NULL を返す？）。
 -->

</dl>
				</section>
				<section id="_read-async-methods">
<h5>6.3.4.2 〜 5. 各種 非同期~読取り~method</h5>

<div >

<p class="trans-note">【
この訳では、各種 `非同期~読取り~method$の定義を，この節の中で一括して与える（原文では，~methodごとに個別に定義されているが、それらの大部分の記述は重複しているので）。
】</p>

	<div lang="en">

<h5>6.3.4.2. The readAsDataURL() method</h5>
<p>
When the readAsDataURL(blob) method is called, the user agent must run the steps below.
</p>

<ol>
	<li>
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
Otherwise set readyState to LOADING.
</li>
	<li>
Initiate an annotated task read operation using the blob argument as input and handle tasks queued on the file reading task source per below.
</li>
	<li>
To process read error with a failure reason, proceed to §6.3.4.6 Error Steps.
</li>
	<li>
To process read fire a progress event called loadstart at the context object.
</li>
	<li>
To process read data fire a progress event called progress at the context object.
</li>
	<li>
<p>
To process read EOF run these substeps:
</p>

		<ol>
			<li>
Set readyState to DONE.
</li>
			<li>
<p>
Set the result attribute to the body returned by the read operation as a DataURL [RFC2397]; on getting, the result attribute returns the blob as a Data URL [RFC2397].
</p>

				<ul>
					<li>
Use the blob’s type attribute as part of the Data URL if it is available in keeping with the Data URL specification [RFC2397].
</li>
					<li>
If the type attribute is not available on the blob return a Data URL without a media-type. [RFC2397]. Data URLs that do not have media-types [RFC2046] must be treated as plain text by conforming user agents. [RFC2397].
</li>
				</ul>
			</li>
			<li>
Fire a progress event called load at the context object.
</li>
			<li>
Unless readyState is LOADING fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</li>
		</ol>
	</li>
	<li>
Terminate this algorithm.
</li>
</ol>

<h5>6.3.4.3. The readAsText() method</h5>

<p>
The readAsText() method can be called with an optional parameter, label, which is a DOMString argument that represents the label of an encoding [Encoding]; if provided, it must be used as part of the encoding determination used when processing this method call.
</p>

<p>
When the readAsText(blob, label) method is called, the user agent must run the steps below.
</p>

<ol>
	<li>
If readyState = LOADING throw an InvalidStateError and terminate this algorithm.
</li>
	<li>
Otherwise set readyState to LOADING.
</li>
	<li>
Initiate an annotated task read operation using the blob argument as input and handle tasks queued on the file reading task source per below.
</li>
	<li>
To process read error with a failure reason, proceed to the §6.3.4.6 Error Steps.
</li>
	<li>
To process read fire a progress event called loadstart at the context object.
</li>
	<li>
To process read data fire a progress event called progress at the context object.
</li>
	<li>
<p>
To process read EOF run these substeps:
</p>

		<ol>
			<li>
Set readyState to DONE.
</li>
			<li>
Set the result attribute to the body returned by the read operation, represented as a string in a format determined by the encoding determination.
</li>
			<li>
Fire a progress event called load at the context object.
</li>
			<li>
Unless readyState is LOADING fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</li>
		</ol>
	</li>
	<li>
Terminate this algorithm.
</li>
</ol>

<h5>6.3.4.4. The readAsArrayBuffer() method</h5>

<p>
When the readAsArrayBuffer(blob) method is called, the user agent must run the steps below.
</p>

<ol>
	<li>
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
Otherwise set readyState to LOADING.
</li>
	<li>
<p>
Initiate an annotated task read operation using the blob argument as input and handle tasks queued on the file reading task source per below.
</p>

	<li>
To process read error with a failure reason, proceed to the §6.3.4.6 Error Steps.
</li>
	<li>
To process read fire a progress event called loadstart at the context object.
</li>
	<li>
To process read data fire a progress event called progress at the context object.
</li>
	<li>
<p>
To process read EOF run these substeps:
</p>

		<ol>
			<li>
Set readyState to DONE.
</li>
			<li>
Set the result attribute to the body returned by the read operation as an ArrayBuffer object.
</li>
			<li>
Fire a progress event called load at the context object.
</li>
			<li>
Unless readyState is LOADING fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</li>
		</ol>
	</li>
	<li>
Terminate this algorithm.
</li>
</ol>

<h5>6.3.4.5. The readAsBinaryString() method</h5>

<p>
When the readAsBinaryString(blob) method is called, the user agent must run the steps below.
</p>


<ol>
	<li>
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
Otherwise set readyState to LOADING.
</li>
	<li>
<p>
Initiate an annotated task read operation using the blob argument as input and handle tasks queued on the file reading task source per below.
</p>

	<li>
To process read error with a failure reason, proceed to the §6.3.4.6 Error Steps.
</li>
	<li>
To process read fire a progress event called loadstart at the context object.
</li>
	<li>
To process read data fire a progress event called progress at the context object.
</li>
	<li>
<p>
To process read EOF run these substeps:
</p>

		<ol>
			<li>
Set readyState to DONE
</li>
			<li>
Set the result attribute to the body returned by the read operation as a binary string.
</li>
			<li>
Fire a progress event called load at the context object.
</li>
			<li>
Unless readyState is LOADING fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</li>
		</ol>
	</li>
	<li>
Terminate this algorithm.
</li>
</ol>

	</div>
</div>


<dl class="idl-def">

	<dt id="readAsDataURL">`readAsDataURL(blob)@m</dt>
	<dt id="readAsDataText">`readAsText(blob, label)@m</dt>
	<dt id="readAsArrayBuffer">`readAsArrayBuffer(blob)@m</dt>
	<dt id="readAsBinaryString">`readAsBinaryString(blob)@m</dt>
	<dd>
<p>
これらの~methodの被呼出時には、次を走らせ~MUST：
</p>

<ol>
	<li>
~IF［
`readyState$m ~EQ `LOADING$m
］
⇒
~THROW `InvalidStateError$E
◎
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
`readyState$m ~SET `LOADING$m
◎
Otherwise set readyState to LOADING.
</li>
	<li>
<p>
`blob$V 引数に対する`注釈付き~task読取り演算$を起動する
— その演算により`~file読取~task源$から`待入され$た~taskは、以下に従って，取扱う：
◎
Initiate an annotated task read operation using the blob argument as input and handle tasks queued on the file reading task source per below.
</p>

		<ul>
			<li>
`読取り~errorを処理する$ときは
⇒
その`失敗事由$を与える下で，`~error手続き$を続行する
◎
To process read error with a failure reason, proceed to the §6.3.4.6 Error Steps.
</li>
			<li>
`読取りを開始する$ときは
⇒
此れに向けて `loadstart$et `進捗~eventを発火-$する
◎
To process read fire a progress event called loadstart at the context object.
</li>
			<li>
`読取り~dataを処理する$ときは
⇒
此れに向けて `progress$et `進捗~eventを発火-$する
◎
To process read data fire a progress event called progress at the context object.
</li>
			<li>
<p >
`読取り完了$時には：
◎
To process read EOF run these substeps:
</p>


				<ol>
					<li>
`readyState$m ~SET `DONE$m
◎
Set readyState to DONE.
</li>
					<li>
<p>
此れの `result$m 属性 ~SET ~methodの種類に応じて，
`読取り演算$による結果の`本体$を以下に与える表現にした結果：
</p>

<dl class="switch">
	<dt>`readAsDataURL()^m</dt>
	<dd>
<p>
次に従うような`~data_URL$による表現：
</p>

		<ul>
			<li>
`blob$V の `type$m 属性を`~data_URL$の媒体型の部分に利用できる場合は、~data_URL仕様 `RFC2397$r に従って，それを利用する。
</li>
			<li>
他の場合：
`~data_URL$は媒体型を伴わない。
~UAは、媒体型を伴わない`~data_URL$を，素の~text（ `text/plain^l ）として扱わ~MUST。
</li>
		</ul>
◎
Set the result attribute to the body returned by the read operation as a DataURL [RFC2397]; on getting, the result attribute returns the blob as a Data URL [RFC2397].
</dd>

	<dt>`readAsText()^m</dt>
	<dd>
`label$V 引数（省略可）から`符号化方式を決定-$して得られる形式の文字列†による表現
◎
Set the result attribute to the body returned by the read operation, represented as a string in a format determined by the encoding determination.
</dd>
	<dd class="trans-note">【†
`本体$を，その符号化方式を用いて`復号-$して得られる `DOMString$I
】</dd>

	<dt>`readAsArrayBuffer()^m</dt>
	<dd>
`ArrayBuffer$I ~objによる表現
◎
Set the result attribute to the body returned by the read operation as an ArrayBuffer object.
</dd>

	<dt>`readAsBinaryString()^m</dt>
	<dd>
~binary文字列による表現
◎
Set the result attribute to the body returned by the read operation as a binary string.
</dd>
</dl>
					</li>
					<li>
此れに向けて
`load$et `進捗~eventを発火-$する
◎
Fire a progress event called load at the context object.
</li>
					<li>
<p>
~IF［
`readyState$m ~NEQ `LOADING$m
］
⇒
此れに向けて
`loadend$et `進捗~eventを発火-$する
。
（
`readyState$m が `LOADING$m であるときは，
`loadend$et を<strong>発火しない</strong>こと）
◎
Unless readyState is LOADING fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</p>

<p class="trans-note">【
この下位手続きの最初の段で `DONE$m にされているにもかかわらず，
“`LOADING$m でない” の条件がある理由は、
`load$et の発火により呼出された~event~handlerにより，
`readyState$m が変更され得るため（<a href="#eventInvariants">~event不変則</a>節を参照）。
】</p>

					</li>
				</ol>
			</li>
		</ul>
	</li>
<!-- 
Terminate this algorithm.
 -->
</ol>

	</dd>
</dl>


<p class="note">注記：
`readAsArrayBuffer()$m を利用する方が `readAsBinaryString()$m より好ましい
— 後者は後方互換性のために提供されている。
◎
The use of readAsArrayBuffer() is preferred over readAsBinaryString(), which is provided for backwards compatibility.
</p>


				</section>
				<section id="dfn-error-steps">
<h5 title="Error Steps">6.3.4.6. ~error手続き</h5>

<p>
所与の `FileReader$I ~obj %reader に対し，`失敗事由$で`読取り~errorを処理する$手続きは、次で与えられる：
◎
These error steps are to process read error with a failure reason.
</p>


<ol>
	<li>
%reader の `readyState$m 属性 ~SET `DONE$m
◎
↓</li>
	<li>
%reader の `result$m 属性 ~SET ~NULL
◎
Set the context object’s readyState to DONE and result to null if it is not already set to null.
</li>
	<li>
%reader の `error$m 属性 ~SET `失敗事由$に対応する `DOMException$I ~obj
◎
↓</li>
	<li>
%reader に向けて `error$et `進捗~eventを発火-$する
◎
Set the error attribute on the context object; on getting, the error attribute must be a a DOMException object that corresponds to the failure reason. Fire a progress event called error at the context object.
</li>
	<li>
~IF
%reader の `readyState$m ~NEQ `LOADING$m
］
⇒
%reader に向けて `loadend$et `進捗~eventを発火-$する（
`LOADING$m のときには
`loadend$et を<strong>発火しない</strong>こと）
◎
Unless readyState is LOADING, fire a progress event called loadend at the context object. If readyState is LOADING do NOT fire loadend at the context object.
</li>
	<li>
（この~algoを呼び出した）`読取り~method$は，`終了-$させる<!-- ＊ -->
◎
Terminate the algorithm for any read method.
</li>
</ol>

				</section>
				<section id="abort">
<h5 title="The abort() method">6.3.4.7. `abort()^m ~method</h5>

<dl class="idl-def">
	<dt>`abort()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
When the abort() method is called, the user agent must run the steps below:
</p>

		<ol>
			<li>
~IF［
`readyState$m ~IN { `EMPTY$m, `DONE$m }
］
⇒
`result$m ~SET ~NULL；<br>
~RET
◎
If readyState = EMPTY or if readyState = DONE set result to null and terminate this algorithm.
</li>
			<li>
~IF［
`readyState$m ~EQ `LOADING$m
］
⇒
`readyState$m ~SET `DONE$m；<br />
`result$m  ~SET ~NULL
◎
If readyState = LOADING set readyState to DONE and result to null.
</li>
			<li>
此れに提携して`待入され$ている すべての`~task$を、`~file読取~task源$から除去する
◎
If there are any tasks from the context object on the file reading task source in an affiliated task queue, then remove those tasks from that task queue.
</li>
			<li>
`読取り~method$が処理-中であれば、それを`終了-$させる
◎
Terminate the algorithm for the read method being processed.
</li>
			<li>
`abort$et `進捗~eventを発火-$する
◎
Fire a progress event called abort.
</li>
			<li>
`loadend$et `進捗~eventを発火-$する
◎
Fire a progress event called loadend.
</li>
		</ol>
	</dd>
</dl>

				</section>
				<section id="blobAndFileParams">
<h5 title="Blob Parameters">6.3.4.8. `blob^V 引数</h5>

<p>
各種 `読取り~method$, および `URL.createObjectURL()$m
は、`~Blob$を引数にとる。
この節ではこの引数を定義する。
◎
The asynchronous read methods, the synchronous read methods, and URL.createObjectURL() take a Blob parameter. This section defines this parameter.
</p>

<dl>
	<dt>`blob@V</dt>
	<dd>
<p >
これは`~Blob$であり、次のいずれかへの参照で~MUST：
</p>
<ul ><li>`FileList$I ~objの中の，ある `File$I ~obj
</li><li>下層の OS ~file~systemから得られたものではない `Blob$I ~obj
</li></ul>

◎
This is a Blob argument and must be a reference to a single File in a FileList or a Blob argument not obtained from the underlying OS file system.
</dd>

</dl>

				</section>
			</section>
		</section>
		<section id="enctype">
<h3 title="Determining Encoding">6.4. 符号化方式の決定法</h3>

<p>
`readAsText()$m `読取り~method$を用いて`~Blob$を読取る際に、
`符号化方式を決定-@
するときは、次の手続きに従わ~MUST：
◎
When reading Blob objects using the readAsText() read method, the following encoding determination steps must be followed:
</p>

<ol>
	<li>
%符号化方式 ~SET `失敗^i
◎
Let encoding be null.
</li>
	<li>
~IF［
`label@V 引数は供されている
］
⇒
%符号化方式 ~SET `label$V 引数から`符号化方式を取得-$した結果
◎
If the label argument is present when calling the method, set encoding to the result of the getting an encoding from label.
◎
If the getting an encoding steps above return failure, then set encoding to null.
</li>
	<li>
<p>
~IF［
%符号化方式 ~EQ `失敗^i
］~AND［
`blob$V 引数に `type$m 属性は在る
］~AND［
その属性は Charset Parameter `RFC2046$r を利用している
］
⇒
%符号化方式 ~SET ［
Charset Parameter の中の`符号化方式~label$をなす部分
］から`符号化方式を取得-$した結果
</p>

<p class="example">
`blob$V の `type$m 属性の値が
`text/plain;charset=utf-8^samp ならば、結果の~labelは `utf-8^l になる。
<!-- ＊ -->
~UAは、 Charset Parameter を構文解析して，`符号化方式~label$を成す部分を取り出さ~MUSTことに注意。
</p>

◎
If encoding is null, and the blob argument’s type attribute is present, and it uses a Charset Parameter [RFC2046], set encoding to the result of getting an encoding for the portion of the Charset Parameter that is a label of an encoding.
◎
If blob has a type attribute of text/plain;charset=utf-8 then getting an encoding is run using "utf-8" as the label. Note that user agents must parse and extract the portion of the Charset Parameter that constitutes a label of an encoding.
◎
If the getting an encoding steps above return failure, then set encoding to null.
</li>
	<li>
~IF［
%符号化方式 ~EQ `失敗^i
］
⇒
%符号化方式 ~SET `utf-8$
◎
If encoding is null, then set encoding to utf-8.
</li>
	<li>
~RET %符号化方式 を~fallback符号化方式に用いて，この `blob$V を`復号-$した結果
— ［
`FileReader$I ~objの `result$m 属性の取得子
］, および［
`FileReaderSync$I ~objの同期的
<a href="#dfn-readAsTextSync">`readAsText^m</a> ~method
］においては、 %符号化方式 形式による文字列を返すようにする。
◎
Decode this blob using fallback encoding encoding, and return the result. On getting, the result attribute of the FileReader object returns a string in encoding format. The synchronous readAsText() method of the FileReaderSync object returns a string in encoding format.
</li>
</ol>

		</section>
		<section id="events">
<h3 title="Events">6.5. ~event</h3>

<p>
この仕様に定義される すべての~eventは，
`FileReader$I ~objをその~targetにし~MUST。
◎
The FileReader object must be the event target for all events in this specification.
</p>

<p>
所与の `FileReader$I ~obj %~target に向けて，
%e
`進捗~eventを発火-@
するときには、次が規定される（ %e は， `ProgressEvent$I ~objの~event名とする）：
◎
When this specification says to fire a progress event called e (for some ProgressEvent e at a given FileReader reader as the context object), the following are normative:
</p>

<ul>
	<li>
浮上しない
— ~eventの `bubbles^m 属性 `DOM$r は ~F にされ~MUST。
◎
The progress event e does not bubble. e.bubbles must be false [DOM]
</li>
	<li>
取消せない
— ~eventの `cancelable^m 属性 `DOM$r は ~F にされ~MUST。
◎
The progress event e is NOT cancelable. e.cancelable must be false [DOM]
</li>
</ul>
			<section id="event-summary">
<h4 title="Event Summary">6.5.1. ~event要覧</h4>

<p>
次の表に、 `FileReader$I ~objに向けて`発火-$される~eventを挙げる。
◎
The following are the events that are fired at FileReader objects.
</p>

<table id="event-summary-table">

<thead><tr><th>~event名
<th>~interface
<th>発火-時機
</thead>

<tbody><tr><td>`loadstart@et
<td>`ProgressEvent$I
<td>
読取りが開始されるとき。
◎
When the read starts.

<tr><td>`progress@et
<td>`ProgressEvent$I
<td>
`blob$V 読取り中（および復号-中）の間
◎
While reading (and decoding) blob

<tr><td>`abort@et
<td>`ProgressEvent$I
<td>
読取りが中止されたとき。
例えば `abort()$m ~methodが呼出されたとき。
◎
When the read has been aborted.
For instance, by invoking the abort() method.

<tr><td>`error@et
<td>`ProgressEvent$I
<td>
読取りが失敗したとき（`読取り~error$を見よ）。
◎
When the read has failed (see file read errors).

<tr><td>`load@et
<td>`ProgressEvent$I
<td>
読取りが成功裡に完了したとき。
◎
When the read has successfully completed.

<tr><td>`loadend@et
<td>`ProgressEvent$I
<td>
要請が完了したとき（成功／失敗のいずれでも）。
◎
When the request has completed (either in success or failure).

</tbody></table>

			</section>
			<section id="eventInvariants">
<h4 title="Summary of Event Invariants">6.5.2. ~event不変則の要約</h4>

~INFORMATIVE

<p>
この仕様で与えられる非同期`読取り~method$に対する~eventの発火には、次の不変則が成り立つ：
◎
The following are invariants applicable to event firing for a given asynchronous read method in this specification:
</p>

<ol>
	<li>
<p>
一度 `loadstart$et が発火された後、対応する `loadend$et が読取り完了~時に発火される。
<em >ただし</em>、次のいずれかに該当する場合を除く：
◎
Once a loadstart has been fired, a corresponding loadend fires at completion of the read, UNLESS any of the following are true:
</p>

		<ul>
			<li>
`abort()$m により`読取り~method$が取消され，新たに`読取り~method$が呼出された場合
◎
the read method has been cancelled using abort() and a new read method has been invoked
</li>
			<li>
`load$et ~eventに対する~event~handler関数が，新たな読取りを起動させた場合
◎
the event handler function for a load event initiates a new read
</li>
			<li>
`error$et ~eventに対する~event~handler関数が，新たな読取りを起動させた場合
◎
the event handler function for a error event initiates a new read.
</li>
		</ul>

<p class="note">注記：
2 つの~event `loadstart$et と `loadend$et は、一対一の組にされるわけではない。
◎
Note: The events loadstart and loadend are not coupled in a one-to-one manner.
</p>

<div class="example">
<p>
“読取りの連鎖”，すなわち “最初の” 読取り処理は継続しつつ，~event~handlerの中で別の読取りを起動する例を示す：
◎
This example showcases "read-chaining": initiating another read from within an event handler while the "first" read continues processing.
</p>

<pre class="es-code">
/* <span class="comment">
次の類いの~codeにおいて …
◎
In code of the sort...
</span> */
reader.readAsText(file);
reader.onload = function(){reader.readAsText(alternateFile);}

.....

/* <span class="comment">
… 最初の読取りに対しては `loadend^et ~eventは発火されては~MUST_NOT
◎
... the loadend event must not fire for the first read
</span> */

reader.readAsText(file);
reader.abort();
reader.onabort = function(){reader.readAsText(updatedFile);}

/* <span class="comment">
… 最初の読取りに対しては `loadend^et ~eventは発火されては~MUST_NOT
◎
... the loadend event must not fire for the first read
</span> */
</pre>

		</div>
	</li>
	<li>
`blob$V が~memory内に完全に読取られた時点で `progress$et ~eventが 1 回 発火されることになる。
◎
One progress event will fire when blob has been completely read into memory.
</li>
	<li>
`loadstart$et より前に `progress$et ~eventが発火されることはない。
◎
No progress event fires before loadstart.
</li>
	<li>
`abort$et,
`load$et,
`loadend$et
の，どの発火-後にも
`progress$et ~eventが発火されることはない。
与えられた読取りに対し，少なくとも
`abort$et,
`load$et,
`error$et
のいずれかが発火される。
◎
No progress event fires after any one of abort, load, and error have fired. At most one of abort, load, and error fire for a given read.
</li>
	<li>
`loadend$et の後に
`abort$et,
`load$et,
`error$et
~eventが発火されることはない。
◎
No abort, load, or error event fires after loadend.
</li>
</ol>
			</section>
		</section>
		<section id="readingOnThreads">
<h3 title="Reading on Threads">6.6. ~threadによる読取り</h3>

<p>
Web Workers `WORKERS$r においては
`~Blob$に対する
同期的な読取り~APIも利用できる。
その種の読取り~threadが~main~threadを阻むことはない。
この節では、~workerにて利用できる同期的~APIを定義する。
~workerには非同期~API（ `FileReader$I ~obj）
<em>および</em>
同期的~API（ `FileReaderSync$I ~obj）が用意されている。
◎
Web Workers allow for the use of synchronous File or Blob read APIs, since such reads on threads do not block the main thread. This section defines a synchronous API, which can be used within Workers [[Web Workers]]. Workers can avail of both the asynchronous API (the FileReader object) and the synchronous API (the FileReaderSync object).
</p>

			<section id="FileReaderSync">
<h3 title="The FileReaderSync API">6.6.1. `FileReaderSync^I ~API</h3>

<p>
この~interfaceは
`~Blob$を~memory内に同期的に読取るための
`同期~読取り~method@
を提供する。
◎
This interface provides methods to synchronously read File or Blob objects into memory.
</p>

<pre class="idl">
[<a href="#dom-filereadersync-filereadersync">Constructor</a>, `Exposed$=(DedicatedWorker,SharedWorker)]
interface `FileReaderSync@I {

  /* <span class="comment">
同期的に文字列を返す
◎
Synchronously return strings
</span> */

  `ArrayBuffer$I `readAsArrayBuffer$mS(`Blob$I `blob$V);
  DOMString `readAsBinaryString$mS(`Blob$I `blob$V);
  DOMString `readAsText$mS(`Blob$I `blob$V, optional DOMString `label$V);
  DOMString `readAsDataURL$mS(`Blob$I `blob$V);
};
</pre>

				<section id="filereadersyncConstrctr">
<h5 title="Constructors">6.6.1.1. 構築子</h5>

<p class="idl-def">
`FileReaderSync()@m
構築子の被呼出時には、新たな `FileReaderSync$I ~objを返さ~MUST。
◎
When the FileReaderSync() constructor is invoked, the user agent must return a new FileReaderSync object.
</p>

<p>
大域~objが `WorkerGlobalScope$I ~objで表現される環境においては、 `FileReaderSync$I の構築子が可用にされ~MUST。
◎
In environments where the global object is represented by a WorkerGlobalScope object, the FileReaderSync constructor must be available.
</p>

				</section>
				<section id="_read-sync-methods">
<h5>6.6.1.2 〜 5. 各種 同期~読取り~method</h5>

<div>

<p class="trans-note">【
この訳では、各種 `同期~読取り~method$の定義を，この節の中で一括して与える（原文では，~methodごとに個別に定義されているが、それらの大部分の記述は重複しているので）。
】</p>

	<div lang="en">
<h5>6.6.1.2. The readAsText() method</h5>
<p>
When the readAsText(blob, label) method is called, the following steps must be followed:
</p>

<ol>
	<li>
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
Otherwise, initiate a read operation using the blob argument, and with the synchronous flag set. If the read operation returns failure, throw the appropriate exception as defined in §7.1 Throwing an Exception or Returning an Error. Terminate this algorithm.
</li>
	<li>
If no error has occurred, return the result of the read operation represented as a string in a format determined through the encoding determination algorithm.
</li>
</ol>

<h5>6.6.1.3. The readAsDataURL() method</h5>

<p>
When the readAsDataURL(blob) method is called, the following steps must be followed:
</p>

<ol>
	<li>
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
Otherwise, initiate a read operation using the blob argument, and with the synchronous flag set. If the read operation returns failure, throw the appropriate exception as defined in §7.1 Throwing an Exception or Returning an Error. Terminate this algorithm.
</li>
	<li>
If no error has occurred, return the result of the read operation as a Data URL [RFC2397] subject to the considerations below:

		<ul>
			<li>
Use the blob’s type attribute as part of the Data URL if it is available in keeping with the Data URL specification [RFC2397].
</li>
			<li>
If the type attribute is not available on the blob return a Data URL without a media-type. [RFC2397]. Data URLs that do not have media-types [RFC2046] must be treated as plain text by conforming user agents. [RFC2397].
</li>
		</ul>
	</li>
</ol>

<h5>6.6.1.4. The readAsArrayBuffer() method</h5>

<p>
When the readAsArrayBuffer(blob) method is called, the following steps must be followed:
</p>

<ol>
	<li>
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
Otherwise, initiate a read operation using the blob argument, and with the synchronous flag set. If the read operation returns failure, throw the appropriate exception as defined in §7.1 Throwing an Exception or Returning an Error. Terminate this algorithm.
</li>
	<li>
◎
If no error has occurred, return the result of the read operation as an ArrayBuffer.
</li>
</ol>

<h5>6.6.1.5. The readAsBinaryString() method</h5>

<p>
When the readAsBinaryString(blob) method is called, the following steps must be followed:
</p>

<ol>
	<li>
If readyState = LOADING throw an InvalidStateError exception and terminate this algorithm.
</li>
	<li>
Otherwise, initiate a read operation using the blob argument, and with the synchronous flag set. If the read operation returns failure, throw the appropriate exception as defined in §7.1 Throwing an Exception or Returning an Error. Terminate this algorithm.
</li>
	<li>
If no error has occurred, return the result of the read operation as an binary string.
</li>
</ol>



	</div>
</div>


<dl class="idl-def">
	<dt id="readAsTextSync">`readAsDataURL(blob)@mS</dt>
	<dt id="readAsDataURLSync-section">`readAsText(blob, label)@mS</dt>
	<dt id="readAsArrayBufferSyncSection">`readAsArrayBuffer(blob)@mS</dt>
	<dt id="readAsBinaryStringSyncSection">`readAsBinaryString(blob)@mS</dt>


	<dd>
<p>
これらの~methodの被呼出時には、次を走らせ~MUST：
◎
When the readAsArrayBuffer(blob) method is called, the following steps must be followed:
</p>

<ol>
	<li>
~IF［
`readyState$m ~EQ `LOADING$m
］
⇒
~THROW `InvalidStateError$E
◎
If readyState = LOADING throw an InvalidStateError exception and terminate these steps.
</li>
	<li>
%本体 ~SET `blob$V を引数に［
`同期~flag$ ~SET ~ON
］の下で，`読取り演算$を行った結果
◎
Otherwise, initiate a read operation using the blob argument, and with the synchronous flag set. If the read operation returns failure, throw the appropriate exception as defined in §7.1 Throwing an Exception or Returning an Error. Terminate this algorithm.
</li>
	<li>
~IF［
前~段の`読取り演算$が`失敗事由$を伴って終了した
］
⇒
~THROW 失敗事由に<a href="#dfn-error-codes">適切な例外</a>
◎
↑</li>
	<li>
<p>
~RET ~methodの種類に応じて， %本体 を次で与えられる表現にした結果：
</p>

<dl class="switch">
	<dt>`readAsText()^m</dt>
	<dd>
`label$V 引数（省略可）から`符号化方式を決定-$して得られる形式による文字列
</dd>
	<dd class="trans-note">【
結果を，その符号化方式を用いて`復号-$して得られる `DOMString$I
】</dd>

	<dt>`readAsDataURL()^m</dt>
	<dd>
<p>
下記に従うような`~data_URL$
</p>

		<ul>
			<li>
~data_URL仕様 `RFC2397$r に従う形で，
`blob$V の `type$m 属性を`~data_URL$の媒体型の部分に利用できる場合は、そのようにする。
</li>
			<li>
他の場合：
`~data_URL$は媒体型を伴わないとする。
~UAは、媒体型を伴わない`~data_URL$を，素の~text（ `text/plain^l ）として扱わ~MUST。
<!-- ＊
`blob$V に `type$m 属性がない場合、媒体型を持たない~data_URLを返す
 -->
</li>
		</ul>
	</dd>

	<dt>`readAsArrayBuffer()^m</dt>
	<dd>
`ArrayBuffer$I ~obj
</dd>

	<dt>`readAsBinaryString()^m</dt>
	<dd>
~binary文字列
</dd>

</dl>

◎
↑</li>
		</ol>
	</dd>
</dl>

<p class="note">注記：
`readAsArrayBuffer()$mS を利用する方が `readAsBinaryString()$mS より好ましい
— 後者は後方互換性のために提供されている。
◎
The use of readAsArrayBuffer() is preferred over readAsBinaryString(), which is provided for backwards compatibility.
</p>


				</section>
			</section>
		</section>
	</section>
	<section id="ErrorAndException">
<h2 title="Errors and Exceptions">7. ~errorと例外</h2>

<p>
`読取り~error@
は下層の~file~systemから~fileを読取る際に生じ得る。
起こり得る~errorのいくつかを下に挙げる。
これらは <em>参考</em> である。
◎
File read errors can occur when reading files from the underlying filesystem. The list below of potential error conditions is informative.
</p>

<ul>
	<li>
~accessが試みられている `~Blob$
`の参照先の~data^tnote
は、`非同期~読取り~method$や`同期~読取り~method$が~callされた時点では，存在しない可能性がある。
これは、その参照が獲得された後に（例えば他の~appにより同時並行的に）移動されたか, または削除されたときに起こり得る。
`NotFoundError$E を見よ。
◎
The File or Blob being accessed may not exist at the time one of the asynchronous read methods or synchronous read methods are called. This may be due to it having been moved or deleted after a reference to it was acquired (e.g. concurrent modification with another application). See NotFoundError.
</li>
	<li>
`~Blob$は読取れない可能性もある。
これは、
`~Blob$への参照が獲得された後に~permissionの問題が生じたときに起こり得る（例えば他の~appにより同時並行的に~lockされたなど）。
加えて，`~snapshot状態$が変化した可能性もある。
`NotReadableError$E を見よ。
◎
A File or Blob may be unreadable. This may be due to permission problems that occur after a reference to a File or Blob has been acquired (e.g. concurrent lock with another application). Additionally, the snapshot state may have changed. See NotReadableError.
</li>
	<li>
~UAは，一部の~fileについて ~Web~app内での利用を安全でないものと定めても~MAY。
~disk上の~fileは 元々の~file選択から変化し得るので、読取り結果は無効なものになり得る。
加えて、一部の~fileや~directory構造は，下層の~file~systemにおいて制約されていることもある。
例えば それらからの読取りは，保安~違反と見なされ得る。
<a href="#security-discussion">保安~上の考慮点</a>,
`SecurityError$E を見よ。
◎
User agents MAY determine that some files are unsafe for use within Web applications. A file may change on disk since the original file selection, thus resulting in an invalid read. Additionally, some file and directory structures may be considered restricted by the underlying filesystem; attempts to read from them may be considered a security violation. See §9 Security and Privacy Considerations and SecurityError.
</li>
</ul>

		<section id="dfn-error-codes">
<h3 title="Throwing an Exception or Returning an Error">7.1. 例外の投出／返される~error</h3>

<p>
この節は規定とする。
◎
This section is normative.
</p>

<p>
`~error条態$は`~Blob$の読取り中に生じ得る。
◎
Error conditions can arise when reading a File or a Blob.
</p>

<p>
`読取り演算$は、`~Blob$の読取~中における`~error条態$により終了し得る。
`読取り演算$を失敗させる, あるいは
`読取り~errorを処理する$ための`~taskを待入する$ような，個々の`~error条態$は、
`失敗事由@
と呼ばれる。
◎
The read operation can terminate due to error conditions when reading a File or a Blob; the particular error condition that causes a read operation to return failure or queue a task to process read error is called a failure reason.
</p>

<ul>
	<li>
`同期~読取り~method$に対しては、ある`失敗事由$により~errorが生じた場合、下の一覧に挙げる型の例外が`投出$される。
◎
Synchronous read methods throw exceptions of the type in the table below if there has been an error owing to a particular failure reason.
</li>
	<li>
`非同期~読取り~method$に対しては、
`FileReader$I ~objの
`error@m
属性が利用される。
それは、［
ある`失敗事由$により~errorが生じた場合は，下の一覧の中で最も適切な名前の
`DOMException$I ~obj ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
Asynchronous read methods use the error attribute of the FileReader object, which must return a DOMException object of the most appropriate type from the table below if there has been an error owing to a particular failure reason, or otherwise return null.
</li>
</ul>

<table>
<thead><tr><th>~error名◎Type
<th>`失敗事由$とその説明◎Description and Failure Reason
</thead>

<tbody><tr><td>`NotFoundError$E
<td>
<p>
次に該当する`失敗事由$に対しては、この型の例外が利用され~MUST：
</p>

<dl>
	<dt>`NotFound@FR</dt>
	<dd>
読取りが処理された時点で`~Blob$の資源が見つからない。
</dd>
</dl>

◎
If the File or Blob resource could not be found at the time the read was processed, this is the NotFound failure reason.
◎
For asynchronous read methods the error attribute must return a NotFoundError exception and synchronous read methods must throw a NotFoundError exception.

<tr><td>`SecurityError$E
<td>

<p>
次に該当する`失敗事由$に対しては、この型の例外が利用されて~MAY：
</p>

<dl>
	<dt> `UnsafeFile@FR</dt>
	<dd>
ある種の~fileに対する ~Web~app内からの~accessが、安全でないものとされた。
</dd>

	<dt>`TooManyReads@FR</dt>
	<dd>
`~Blob$の資源に対する読取り~call回数が多すぎるものとされた。
</dd>

</dl>

<p>
これは、他の `失敗事由$に該当しない状況に利用される保安~上の~errorである。
</p>

◎
If:
it is determined that certain files are unsafe for access within a Web application, this is the UnsafeFile failure reason.
◎
it is determined that too many read calls are being made on File or Blob resources, this is the TooManyReads failure reason.
◎
For asynchronous read methods the error attribute may return a SecurityError exception and synchronous read methods may throw a SecurityError exception.
◎
This is a security error to be used in situations not covered by any other failure reason.

<tr><td>`NotReadableError$E
<td>

<p>
次に該当する`失敗事由$に対しては、この型の例外が利用され~MUST：
</p>

<dl>
	<dt>`SnapshotState@FR</dt>
	<dd>
`~Blob$の`~snapshot状態$が下層~storageの状態に合致しない。
</dd>

	<dt>`FileLock@FR</dt>
	<dd>
概して`~snapshot状態$の確立-後に生じた~permissionの問題により（例えば他の~appにより同時並行的に下層~storageが~lockされたなど）、`~Blob$を読取れない。
</dd>

</dl>

◎
If:
◎
the snapshot state of a File or a Blob does not match the state of the underlying storage, this is the SnapshotState failure reason.
◎
the File or Blob cannot be read, typically due due to permission problems that occur after a snapshot state has been established (e.g. concurrent lock on the underlying storage with another application) then this is the FileLock failure reason.
◎
For asynchronous read methods the error attribute must return a NotReadableError exception and synchronous read methods must throw a NotReadableError exception.

</tbody></table>

		</section>
	</section>
	<section id="url">
<h2 title="A URL for Blob and File reference">8. `Blob^I ／ `File^I への~URL参照</h2>

<p>
この節では`~Blob$への参照に利用される~URLの~schemeを定義する。
◎
This section defines a scheme for a URL used to refer to Blob objects (and File objects).
</p>

		<section id="use-cases-scheme">
<h3 title="Requirements for a New Scheme">8.1. 新たな~schemeに課される要件</h3>

<p>
この仕様では
`blob:550e8400-e29b-41d4-a716-446655440000#aboutABBA^samp
のような類いの~URLによる~schemeを定義する。
この節では要件の一部と参考となる論点を与える。
◎
This specification defines a scheme with URLs of the sort: blob:550e8400-e29b-41d4-a716-446655440000#aboutABBA.
This section provides some requirements and is an informative discussion.
</p>

<ul>
	<li>
<p>
この~schemeは， `XMLHttpRequest$I などの~Web~APIや,
`img$e 要素 `HTML$r
などの~HTTP~URLの利用が想定されている要素と伴用できるべきである。
一般に、この~schemeは，~Web上で~URLが利用できる所ならどこでも利用できるように設計されるべきである。
◎
This scheme should be able to be used with web APIs such as XMLHttpRequest, and with elements that are designed to be used with HTTP URLs, such as the img element. In general, this scheme should be designed to be used wherever URLs can be used on the web.
</p>

<p>
この~schemeには、資源が見当たらなかったり, ~errorが生じるような局面に対し ~Web~appが応答し得るようにするための，応答~codeが定義されるべきである。
◎
This scheme should have defined response codes, so that web applications can respond to scenarios where the resource is not found, or raises an error, etc.
</p>
	</li>
	<li>
<p>
この~schemeは、~Web~appから~binary~dataへの~accessが安全に行えるようにするための，`生成元$~policyと
`存続期間$の約定を備えているべきである。
◎
This scheme should have an origin policy and a lifetime stipulation, to allow safe access to binary data from web applications.
</p>

<p>
この~schemeの~URLは “~memory内” `~Blob$への参照として利用されるべきであり，~binary資源を参照するために他所でも再利用されるべきである（例えばビデオ会議 `WebRTC$r のため）。
それらは概して “~memory内” 資源への~accessに利用されるものなので、この~schemeの~URLは永続的でないものとして設計される。
◎
URLs in this scheme should be used as a references to "in-memory" Blobs, and also be re-used elsewhere on the platform to refer to binary resources (e.g. for video-conferencing [WebRTC]). URLs in this scheme are designed for impermanence, since they will be typically used to access "in memory" resources.
</p>
	</li>
	<li>
この~schemeの~URLは、それらが`~Blob$をそれ以上 参照する事が無いように、開発者が破棄できる能を有するべきである。
これには、~programが~fileへの参照や`~Blob$の他への利用をもう必要としなくなる局面も含まれる。
`canvas$e 要素とその~API `HTML$r を利用する絵描き~programから`~Blob$を外部出力させる局面を想定してみる。
素描の~snapshotは`~Blob$を外部出力して作成され得る。
この~schemeは、 `img$e 要素 `HTML$r にて~snapshotを表示させる目的に，利用され得る。
利用者が~snapshotを削除した場合、~URLを通した~memory内の~snapshotへのどの参照も無効になるべきであり，そのような~URLは破棄できるようにすべきである。
◎
Developers should have the ability to revoke URLs in this scheme, so that they no longer refer to Blob objects. This includes scenarios where file references are no longer needed by a program, but also other uses of Blob objects. Consider a scenario where a Blob object can be exported from a drawing program which uses the canvas element and API [HTML]. A snapshot of the drawing can be created by exporting a Blob. This scheme can be used with the img [HTML] element to display the snapshot; if the user deletes the snapshot, any reference to the snapshot in memory via a URL should be invalid, and hence the need to be able to revoke such a URL.
</li>
</ul>
		</section>
		<section id="alternative-schemas">
<h3 title="Discussion of Existing Schemes">8.2. 既存の~schemeについての論点</h3>

<p>
この節では 上述の~URLの利用事例に対し、仮に，既存の~schemeの 多目的化, または再利用 により対応した場合における論点を述べ、なぜ新たな~schemeが好ましいと見なされるかについての論拠を与える。
これらの~schemeには
`http:^sc `RFC7230$r,
`file:^sc `RFC1630$r `RFC1738$r,
`urn:uuid^sc `RFC4122$r
などの~schemeがある。
利用する~schemeの決定に際し，普及の観点から考慮すべきことは、~Web開発者~達に直感的に訴えかける何かを供することである。
◎
This section is an informative discussion of existing schemes that may have been repurposed or reused for the use cases for URLs above, and justification for why a new scheme is considered preferable. These schemes include HTTP [RFC7230], file [RFC1630][RFC1738], and a scheme such as urn:uuid [RFC4122].
One broad consideration in determining what scheme to use is providing something with intuitive appeal to web developers.
</p>

<ul>
	<li>
`http:^sc は上に示した利用事例に多目的化し得るであろう。
すでに~Web~appで利用されている、矛盾無く定義された 要請→応答 の意味論が備わっている。
しかし、 `~Blob$資源は概して “~memory内” に滞在するものであり（例えば~fileが~memory内に読取られた後）， DNS を通して参照取得される “伝統的な” ~HTTP資源とは異なる。
一部の~UAは~HTTP~serverを通して（例えば `http://localhost^samp の類いの~URL）自動的に~local~machineの下層の~file~systemを “代理” させることがあるが、 `http:^sc は伝統的に~local資源には利用されていない。
更に，これらの~URLの重要な利用事例として、~API~callにより破棄できることがある。
`http:^sc ~URLは伝統的に，より永続的な（かつ，~Web~appが読取れる~fileのような、主として~memoryに滞在するもの、ではない）資源に利用されている。
`http:^sc ~schemeの再利用は~~経験を積んだ~Web開発者~達を混乱させる事になるだろう。
◎
HTTP could be repurposed for the use cases mentioned above; it already comes with well-defined request-response semantics that are already used by web applications. But Blob resources are typically "in-memory" resident (e.g. after a file has been read into memory), and are thus unlike "traditional" HTTP resources that are dereferenced via DNS. While some user agents automatically "proxy" the underlying file system on the local machine via an HTTP server (e.g. with URLs of the sort http://localhost), HTTP is not traditionally used with local resources. Moreover, an important use case for these URLs are that they can be revoked with an API call. HTTP URLs have traditionally been used for resources that may be more permanent (and that are certainly not chiefly memory-resident, such as files that a web application can read). Reusing the HTTP scheme might be confusing for web developers owing to well-established practice.
</li>
	<li>
`file:^sc ~URLの再利用は、応答~codeの追加など，今日の `file:^sc ~URLの利用に対する変更も含む事になる。
それらは~Web~app間で一貫しない形で利用されているが、~URLの構造も変化し，既にある~~程度 場当たり的に働いている 要請→応答 の挙動に対する付け足しも加えられることになるであろう。
旧来の用法もある下で、先の利用事例のためにこれを変更するのは~~無分別である。
加えて、~Blob~URL~scheme呼び出し利用の利用事例においては，~file~systemの域を超えるものになる。<!--  -->
◎
The reuse of file URLs would involve changes to file URL use today, such as adding response codes.
While they are used inconsistently in web applications, the structure of the URLs would change, and request-response behavior would have to be superimposed on what already works in a more-or-less ad-hoc manner.
Modifying this for the use cases cited above is imprudent, given legacy usage.
Additionally, the use cases for a Blob URL scheme call for uses beyond the file system.
</li>
	<li>
`urn:uuid^sc `RFC4122$r
の類の~schemeは、~HTMLと~JavaScript~Web~appにおいての利用は前例が無いが，利用し得るものにはなるであろう。
`urn:uuid^sc ~schemeはごく汎用的である。
`urn:uuid^sc ~schemeの~URLは広く知れ渡っておらず，~Web~platform間での一貫性に欠く不利がある。
新しい~schemeには参照の対象が明示的になっている利点がある。
~~理論的に、~URLには それらが参照取得されたときにどのような種類の資源が得られるかの保証が無い。
その保証は内容の標識と媒体型に委ねられる。
しかし、実施においては，~schemeの名前であれば、資源, および 要請→応答 ~transactionの~protocolの両者について予期し得るものになる。
主要な利用事例 — すなわち、~memoryに滞在する`~Blob$資源への~access — が明らかになる名前の選択は、検討する価値のある妥協点であり，~Web~platform間における明瞭性, 馴染易さ, 一貫性の恩恵をもたらす。
◎
A scheme of the sort urn:uuid [RFC4122] could be used, though use of this scheme is unprecedented in HTML and JavaScript web applications. The urn:uuid scheme is very generic. URLs in the scheme urn:uuid have the disadvantage of unfamiliarity and inconsistency across the web platform. A new scheme has the advantage of being explicit about what is being referenced. In theory, URLs make no guarantee about what sort of resource is obtained when they are dereferenced; that is left to content labeling and media type. But in practice, the name of the scheme creates an expectation about both the resource and the protocol of the request-response transaction. Choosing a name that clarifies the primary use case—namely, access to memory-resident Blob resources—is a worthwhile compromise, and favors clarity, familiarity, and consistency across the web platform.
</li>
</ul>


		</section>
		<section id="DefinitionOfScheme">
<h3 title="The Blob URL">8.3. ~Blob~URL</h3>


<div class="p">
<p>
`~Blob~URL@
は、次のものを伴う`~URL$である：
</p>

<ul ><li>その`~scheme$urlは `blob:^sc
</li><li>その`~host$urlは `~Blob~URL$の`生成元$url
</li><li>その`~path$urlは~UUID `RFC4122$r （ <a href="#ABNFUUID">~UUIDの~ABNF</a> を見よ）である 1 個の~entryのみからなる
</li><li>その`~obj$urlは `~Blob$
</li></ul>

<p>
`~Blob~URL$には，`素片$urlも含められてよい（省略可）。
`~Blob~URL$は、`~Blob~URLの直列化$~algoに則って，文字列に直列化される。
</p>
◎
A Blob URL is a URL with a scheme of blob, a host of the origin of the Blob URL, a path with one entry comprised of a UUID [RFC4122] (see An ABNF for UUID), and an object of the associated Blob or File. A Blob URL may contain an optional fragment. The Blob URL is serialized as a string according to the Serialization of a Blob URL algorithm.
</div>

<p>
`素片$url（省略可）が利用された場合は、その解釈は，当の`~Blob$資源の媒体型に依存して異なる（
<a href="#fragmentDiscussion">素片~識別子に関する論点</a>
節を見よ
）。
◎
A fragment, if used, has a distinct interpretation depending on the media type of the Blob or File resource in question (see §8.3.3 Discussion of Fragment Identifier).
</p>

<div >
<pre class="ABNF">
  `blob^P = `scheme^P ":" `origin^P "/" `UUID^P [`fragIdentifier^P]
  `scheme^P = "blob"
</pre>

<p>
ここで：
</p>

<ul ><li>`scheme^P は常に `blob^l 。
</li><li>`origin^P は，`~Blob~URL$の`生成元$urlの文字列による表現。
</li><li>`UUID^P は， `RFC4122$r と  <a href="#ABNFUUID">~UUIDの~ABNF</a> にて定義される。
</li><li>`fragIdentifier^P （省略可）は， `RFC3986$r と
<a href="#ABNFFragment">素片~識別子の~ABNF</a>
にて定義される。
</li></ul>

<pre lang="en">
blob = scheme ":" origin "/" UUID [fragIdentifier]

scheme = "blob"

; scheme is always "blob"

; origin is a string representation of the Blob URL’s [=url/origin=].
; UUID is as defined in [RFC4122] and An ABNF for UUID
; fragIdentifier is optional and as defined in [RFC3986] and An ABNF for Fragment Identifiers
</pre>

</div>

<div class="example">
<pre>
blob:https://example.org/9115d58c-bcda-ff47-86e5-083e9a215304
</pre>
◎
An example of a Blob URL might be blob:https://example.org/9115d58c-bcda-ff47-86e5-083e9a215304.
</div>


			<section id="originOfBlobURL">
<h4 title="Origin of Blob URLs">8.3.1. ~Blob~URLの生成元</h4>

<p>
`~Blob~URL$は `URL.createObjectURL()$m を利用して作成され、
`URL.revokeObjectURL()$m を利用して破棄される。
`~Blob~URLの生成元@
は、 `createObjectURL()^m ~methodがそれを作成した時点における`現在の設定群~obj$により指定される`生成元$enVと同じで~MUST。
◎
Blob URLs are created using URL.createObjectURL(), and are revoked using URL.revokeObjectURL(). The origin of a Blob URL must be the same as the origin specified by the current settings object at the time the method that created it was called.
</p>

<p class="issue">
汎用的な［
~URLの`生成元$urlの定義
］と,
より特定的である［
`~Blob~URLの生成元$の定義
］との間には、ある取り違えが現在ある。
これについては
<a href="https://github.com/w3c/FileAPI/issues/63">issue #63</a>,
<a href="https://github.com/whatwg/url/issues/127">whatwg/url#127</a>
にて追跡されている。

◎
there is currently some confusion between the generic definition of the origin of a URL and the specific definition of the origin of a Blob URL. This is tracked in issue #63 and in whatwg/url#127.
 </p>

<p>
`~Blob~URL$に対する`非同一生成元~要請$は、`~network~error$を返さ~MUST。
◎
Cross-origin requests on Blob URLs must return a network error.
</p>



<p class="note">注記：
実施においては，これは、この仕様が対象にする，~Blob~URLに利用し得る妥当な生成元が、~HTTPか~HTTPSの`生成元$に限られることを意味する。
この仕様は、~HTTP／~HTTPS でない`生成元$には取り組まない。
例えば，
<samp >blob:file:///Users/arunranga/702efefb-c234-4988-a73b-6104f1b615ee</samp>
の挙動は、~UAがその種の~Blob~URLを妥当なものと扱い得るとしても，未定義になるであろう。
◎
Note: In practice this means that HTTP and HTTPS origins are covered by this specification as valid origins for use with Blob URLs. This specification does not address the case of non-HTTP and non-HTTPS origins. For instance blob:file:///Users/arunranga/702efefb-c234-4988-a73b-6104f1b615ee (which uses the "file:" origin) may have behavior that is undefined, even though user agents may treat such Blob URLs as valid.
</p>

			</section>
			<section id="unicodeSerializationOfBlobURL">
<h4 title="Serialization of a Blob URL">8.3.2. ~Blob~URLの直列化</h4>

<p>
`~Blob~URLの直列化@
とは、次に挙げる文字列を順に連結した結果である（これは， `URL.createObjectURL()$m から呼出される）：
◎
The Serialization of a Blob URL is the value returned by the following algorithm, which is invoked by URL.createObjectURL():
</p>

<ol>
	<li>
`blob:^l （ `0062^U, `006C^U, `006F^U, `0062^U, `003A^U COLON ）
◎
Let result be the empty string. Append the string "blob" (that is, the Unicode code point sequence U+0062, U+006C, U+006F, U+0062) to result.
◎
Append the ":" (U+003A COLON) character to result.
</li>
	<li>
［
`現在の設定群~obj$の`生成元$enVの`~ASCII直列化$
］ ~NEQ `null^l ならば それ ／
~ELSE_ 実装により定義される値
◎
Let settings be the current settings object
◎
Let origin be settings’s origin.
◎
Let serialized be the ASCII serialization of origin.
◎
If serialized is "null", set it to an implementation-defined value.
◎
Append serialized to result.
</li>
	<li>
`/^l （ `0024^U SOLIDUS)
◎
Append the "/" character (U+0024 SOLIDUS) to result.
</li> 
	<li>
~Unicode文字列として~UUID `RFC4122$r を生成した結果
◎
Generate a UUID [RFC4122] as a Unicode string and append it to result.
◎
Return result.
</li>
</ol>

			</section>
			<section id="fragmentDiscussion">
<h4 title="Discussion of Fragment Identifier">8.3.3. 素片~識別子に関する論点</h4>

<p>
`素片$urlの解決, および処理命令（ processing directive ）は、検索取得され得る媒体型の表現に依存する
—
そのような検索取得が，`~Blob~URL$の`参照取得$においてのみ遂行されるとしても。
例えば~HTML~file `HTML$r においては、素片は~file内の~anchorの参照にも利用され得る。
~UAが資源の媒体型を認識できない場合, <em >または</em> 素片が資源の中で意味を持たない場合、素片は無視され~MUST。
素片は、資源の識別-に利用されては~MUST_NOT
— `blob:^sc `~scheme$url, および`~URL$の［
`生成元$url, `~path$url
］のみが、妥当な資源~識別子を成す。
◎
The fragment’s resolution and processing directives depend on the media type [RFC2046] of a potentially retrieved representation, even though such a retrieval is only performed if the Blob URL is dereferenced. For example, in an HTML file [HTML] the fragment could be used to refer to an anchor within the file. If the user agent does not recognize the media type of the resource, OR if a fragment is not meaningful within the resource, it must ignore the fragment. The fragment must not be used to identify a resource; only the blob scheme and the origin/path of the URL constitute a valid resource identifier.
</p>

<p>
有効な~Blob~URL参照は次のようなものになる：
`blob:http://example.org:8080/550e8400-e29b-41d4-a716-446655440000#aboutABBA^samp
。
ここでの `#aboutABBA^l は、それを id 属性~値とする要素を 参照する，~HTML素片~識別子となることが想定されている。
◎
A valid Blob URL reference could look like: blob:http://example.org:8080/550e8400-e29b-41d4-a716-446655440000#aboutABBA where "#aboutABBA" might be an HTML fragment identifier referring to an element with an id attribute of "aboutABBA".
</p>

<p class="note">注記：
`素片$urlは、資源を識別するときには利用されない。
`URL.createObjectURL()$m ~methodは、`素片$urlを生成しない。
◎
Note: The fragment is not used to identify the resource. The URL.createObjectURL() method does not generate a fragment.
</p>


			</section>
		</section>
		<section id="requestResponseModel">
<h3 title="Dereferencing Model for Blob URLs">8.4. ~Blob~URLの参照取得~model</h3>


~INFORMATIVE

<p class="note">
`URL$r, `Fetch$r 仕様が，
`~Blob~URL$の構文解析と~fetchingのための規定を与えるものと見なされるべきである。
◎
Note: The [URL] and [Fetch] specifications should be considered normative for parsing and fetching Blob URLs.
</p>


<p>
~UAが`~Blob~URL$により識別される資源を検索取得して，要請している主体に返すことを、
`参照取得@
と呼ぶ。
この節では、［
`要請$／`応答$
］についての手引きを提供する。
◎
Blob URLs are dereferenced when the user agent retrieves the resource identified by the Blob URL and returns it to the requesting entity. This section provides guidance on requests and responses.
</p>

<p class="trans-note">【
参照取得（ dereference ）：
一般概念としては、（存在しているかどうか確定的でない）参照先の~dataを実際に~~取得して，参照をその実~dataに置換-／展開することを意味する。
「逆参照」「参照外し」等の訳も目にするが、当訳ではこの語を用いることにする。
】</p>

<p>
`要請$ については `GET$h のみが~supportされる。
`応答$は、以下の下位節にて与える，~HTTP `RFC7231$r に従うもの の一部のみに限られる：
◎
Only requests with GET [RFC7231] are supported. Specifically, responses are only a subset of the following from HTTP [RFC7231]:
</p>

			<section id="TwoHundredOK">
<h4 title="200 OK">8.4.1. 200 OK</h4>

<p>
`要請$が成功し, `~network~error$も生じなかった場合、この`応答$が利用される。
◎
This response is used if the request has succeeded, and no network errors are generated.
</p>

			</section>
			<section id="processing-media-types">
<h4 title="Response Headers">8.4.2. 応答~header</h4>


<p>
~UAは、 `200 OK$ 応答に対しては、
`~Blob$の `type$m 属性が空文字列でないならば，
`Content-Type$h ~headerを用いた上で，その値を `type$m 属性の値に等しくする。
◎
Along with 200 OK responses, user agents use a Content-Type header [RFC7231] that is equal to the value of the Blob's type attribute, if it is not the empty string.
</p>

<p>
~UAは、 `200 OK$ 応答に対しては，
`Content-Length$h ~headerを用いた上で，その値を `~Blob$の `size$m 属性~値に等しくする。
◎
Along with 200 OK responses, user agents use a Content-Length header [RFC7230] that is equal to the value of the Blob's size attribute.
</p>

<p>
~UAは、 `Content-Type$h ~headerが提供される場合、
`MIMESNIFF$r 仕様と整合する方法で媒体型を得た上で，それを処理する。
◎
If a Content-Type header [RFC7231] is provided, then user agents obtain and process that media type in a manner consistent with the Mime Sniffing specification [MIMESNIFF].
</p>

<p>
`~Blob~URL$により識別される資源が `File$I ~objである場合、~UAは，その`応答$は
`Content-Disposition$h ~headerを持っていて，その
filename parameter は `File$I ~objの `name$m 属性に設定されていたかのようにする。
◎
If a resource identified with a Blob URL is a File object, user agents use that file’s name attribute, as if the response had a Content-Disposition header with the filename parameter set to the File's name attribute [RFC6266].
</p>

<p class="note">注記：
実装に対する参考の指針：
このことから、~UAは， “~fileを保存…” （ “File Save As” ）において，その~fileを保存する際の既定の名前を提示する際には、
`File$I の `name$m 属性も織り込むことが必然的に導かれる。
◎
Note: A corollary to this is a non-normative implementation guideline: that the "File Save As" user interface in user agents takes into account the File's name attribute if presenting a default name to save the file as.
</p>


			</section>
			<section id="NetworkError">
<h4 title="Network Errors">8.4.3. ~network~error</h4>

<p>
［
<a href="#TwoHundredOK">200 OK</a> を伴う成功
］ではない，応答に対しては、`~network~error$が生じたかのように動作する。
~network~errorは、次のときに利用される：
◎
Responses that do not succeed with a 200 OK act as if a network error has occurred. Network errors are used when:
</p>

<ul>
	<li>
GET 以外の`要請$~methodが用いられている。
◎
Any request method other than GET is used.
</li>
	<li>
`~Blob~URL$に対応する~entryが`~Blob~URL~Store$内に無い。
◎
The Blob URL does not have an entry in the Blob URL Store.
</li>
	<li>
`~Blob~URL$に対し`非同一生成元~要請$が発行された。
◎
A cross-origin requests is made on a Blob URL.
</li>
	<li>
保安~上の~errorが生じた。
◎
A security error has occurred.
</li>
</ul>


			</section>
			<section id="ProtocolExamples">
<h4 title="Sample Request and Response Headers">8.4.4. 要請／応答 ~headerの例</h4>

~INFORMATIVE

<p>
この節では
`~Blob~URL$を用いたときの，~Web~appと~UAとの間のやり取りの例を与える。
`要請$は
`&lt;img src="blob:http://example.org:8080/550e8400-e29b-41d4-a716-446655440000"&gt;^samp
の類いの~HTML~markupの利用から誘発され得る。
これらの例は、単に`要請$と`応答$を説明するものに過ぎない。
`XMLHttpRequest$I の `getAllResponseHeaders()$m ~methodを除いて（この~methodが利用された場合、関連する`応答~header$が示される）、 Web 開発者~達が，~headerのすべてについてやりとりを要することはないであろう。
◎
This section provides sample exchanges between web applications and user agents using Blob URLs. A request can be triggered using HTML markup of the sort &lt;img src="blob:http://example.org:8080/550e8400-e29b-41d4-a716-446655440000"&gt;. These examples merely illustrate the request and response; web developers are not likely to interact with all the headers, but the getAllResponseHeaders() method of XMLHttpRequest, if used, will show relevant response headers.
</p>

<div class="example">
<p>
`要請$は次の様になる：
◎
Requests could look like this:
</p>

<pre class="headers-code">
GET http://example.org:8080/550e8400-e29b-41d4-a716-446655440000
</pre>

<p>
`~Blob$が，その `type$m 属性で表現される提携の媒体型を持つ場合、応答~messageは `Content-Type$h ~headerを含むべきである。
<a href="#processing-media-types">応答~header</a>
節を見よ。
◎
If the Blob has an affiliated media type [RFC2046] represented by its type attribute, then the response message should include the Content-Type header from RFC7231 [RFC7231]. See §8.4.2 Response Headers.
</p>

<p>
対する応答の例：
◎
Example response:
</p>

<pre class="headers-code">
200 OK
Content-Type: image/jpeg
Content-Length: 21897

....
</pre>

<p>
`~Blob$に`読取り~error$が生じた場合、~UAは，`~network~error$が生じたかのように動作する。
◎
If there is a file read error associated with the Blob, then a user agent acts as if a network error has occurred.
</p>

</div>

			</section>
		</section>
		<section id="creating-revoking">
<h3 title="Creating and Revoking a Blob URL">8.5. ~Blob~URLの作成法と破棄法</h3>

<p>
`~Blob~URL$は，
`URL$I ~objに公開される~methodを用いて作成され, 破棄される。
それらの~methodは、大域~obj［
`Window$I, および
`WorkerGlobalScope$I
］にて~supportされる。
`~Blob~URL$を破棄する（ revoke ）ことにより、それが参照する資源と`~Blob~URL$は切り離される。
破棄-後に`参照取得$が~~試みられた場合、~UAは`~network~error$が生じたかのように動作し~MUST。
この節では、
URL 仕様 `URL$r に対する追加の~interface, および
`~Blob~URL$を作成と破棄のための~methodについて述べる。
◎
Blob URLs are created and revoked using methods exposed on the URL object, supported by global objects Window [HTML] and WorkerGlobalScope [Web Workers]. Revocation of a Blob URL decouples the Blob URL from the resource it refers to, and if it is dereferenced after it is revoked, user agents must act as if a network error has occurred. This section describes a supplemental interface to the URL specification [URL] and presents methods for Blob URL creation and revocation.
</p>

<pre class="idl">
[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
partial interface `URL$I {
    static DOMString `createObjectURL$m(`Blob$I `blob$V);
    static void `revokeObjectURL$m(DOMString `url$V);
};

</pre>


<p>
この仕様に従う ECMAScript ~UAは、 URL 仕様 `URL$r も実装しない限り， `URL$I ~objの `prototype^c ~propを公開しては~MUST_NOT。
すなわち、~UAが URL 仕様を実装しているならば， `URL.prototype^c は ~T に評価されなければならず, そうでないならば ~T に評価されては~MUST_NOT。
◎
ECMAScript user agents of this specification must ensure that they do not expose a prototype property on the URL interface object unless the user agent also implements the URL [URL] specification. In other words, URL.prototype must evaluate to true if the user agent implements the URL [URL] specification, and must NOT evaluate to true otherwise.
</p>


			<section id="createRevokeMethodsParams">
<h4 title="Methods and Parameters">8.5.1. ~methodと引数</h4>

<dl class="idl-def">
	<dt>`createObjectURL(blob)@m</dt>
	<dd>
<p>
この静的~methodは、一意な`~Blob~URL$を返す。
</p>

<p class="trans-note">【
“一意” —
3 つの解釈が考えられる（ (1) ？）：
(1) 毎回，過去のどの呼び出しの結果とも異なる意味で一意になる, または
(2) 同じ`~Blob$引数から得られる結果の~URLは常に一意, または
(3) 結果の~URLから引数の`~Blob$が一意に決まる。
】</p>
◎
Returns a unique Blob URL. This method must act as follows:
</dd>
	<dd>
<p>
被呼出時には、次に従って動作し~MUST：
◎
↑</p>

		<ol>
			<li>
%url ~LET `~Blob~URLの直列化$
◎
Let url be the result of the Serialization of a Blob URL algorithm.
</li>
			<li>
組 ( %url, `blob$V ) を`~Blob~URL~Storeに追加する$
◎
Add an entry to the Blob URL Store for url and blob.
 </li>
			<li>
~RET %url
◎
Return url.
</li>
		</ol>
	</dd>

	<dt>`revokeObjectURL(url)@m</dt>
	<dd>
この静的~methodは、文字列 `url$V 引数で与えられる`~Blob~URL$を，対応する~entryを`~Blob~URL~Store$から除去することにより 破棄する。
◎
Revokes the Blob URL provided in the string url by removing the corresponding entry from the Blob URL Store. This method must act as follows:
</dd>
	<dd>
<p>
被呼出時には、次に従って動作し~MUST：
◎
↑</p>

		<ol>
			<li>
~IF［
`url$V は`~Blob~URL$でない
］~OR［
`~Blob~URL~Store$内に `url$V に対応する~entryはない
］
⇒
~RET
— ~UAは~error~consoleに~messageを表示してもよい。
◎
If the value provided for the url argument is not a Blob URL, OR if the value provided for the url argument does not have an entry in the Blob URL Store, this method call does nothing. User agents may display a message on the error console.
</li>
			<li>
<p>
`url$V 引数に対応する~entryを`~Blob~URL~Storeから除去する$
◎
Otherwise, user agents must remove the entry from the Blob URL Store for url.
</p>

<p class="note">注記：
~entryは除去されたので、この `url$V に対する後続の`参照取得$の試みに対しては，`~network~error$が返され~MUST。
◎
Note: Subsequent attemps to dereference url result in a network error, since the entry has been removed from the Blob URL Store.
</p>
			</li>
		</ol>
	</dd>
	<dd>
<p>
`revokeObjectURL()$m ~methodに対する
`url@V
引数は`~Blob~URL$文字列である。
◎
The url argument to the revokeObjectURL() method is a Blob URL string.
</p>

<div class="example">
<p>
下の例では、
`window1^samp と `window2^samp は別々であるが`同一生成元$であるとする
— `window2^samp は `window1^samp の中の `iframe$e `HTML$r になり得る。
◎
In the example below, window1 and window2 are separate, but in the same origin; window2 could be an iframe inside window1.
</p>

<pre class="es-code">
myurl = window1.URL.createObjectURL(myblob);
window2.URL.revokeObjectURL(myurl);
</pre>

<p>
`window1^samp と `window2^samp とは`同一生成元$であり，同じ`~Blob~URL~Store$を共有するので、 `URL.revokeObjectURL()$m が~callされた後の `myurl^samp の`参照取得$の結果，~UAは`~network~error$が生じたかのように動作することになる。
◎


Since window1 and window2 are in the same origin and share the same Blob URL Store, the URL.revokeObjectURL() call ensures that subsequent dereferencing of myurl results in a the user agent acting as if a network error has occurred.
</p>
</div>

	</dd>
</dl>
			</section>
			<section id="examplesOfCreationRevocation">
<h4 title="Examples of Blob URL Creation and Revocation">8.5.2. ~Blob~URLの作成と破棄の用例</h4>

<p>
`~Blob~URL$は`~Blob$を`参照取得$するために利用される文字列であり，それを `URL.createObjectURL()$m を用いて創出した元の`文書$に残り続け得る（ ~Blob~URLの`存続期間$を見よ）。
◎
Blob URLs are strings that are used to dereference Blob objects, and can persist for as long as the document from which they were minted using URL.createObjectURL()—see §8.6 Lifetime of Blob URLs.
</p>

<p>
この節では、説明を交えながら`~Blob~URL$の作成と破棄の用例を示す。
◎
This section gives sample usage of creation and revocation of Blob URLs with explanations.
</p>

<div class="example">
<p>
次の例では、 2 個の
`img$e 要素 `HTML$r
が，同じ`~Blob~URL$を参照する：
◎
In the example below, two img elements [HTML] refer to the same Blob URL:
</p>

<pre class="es-code">
url = URL.createObjectURL(blob);
img1.src = url;
img2.src = url;
</pre>

<p>
次の例では、 `URL.revokeObjectURL()$m が明示的に~callされる：
◎
In the example below, URL.revokeObjectURL() is explicitly called.
</p>

<pre class="es-code">
var blobURLref = URL.createObjectURL(file);
img1 = new Image();
img2 = new Image();

/* <span class="comment">
いずれの代入も予期される通りに機能する
◎
Both assignments below work as expected
</span> */
img1.src = blobURLref;
img2.src = blobURLref;

/* <span class="comment">
… body の読込みに後続して、画像が 2 つとも読込まれたかどうか検査する
◎
... Following body load
Check if both images have loaded
</span> */
if(img1.complete &amp;&amp; img2.complete)
{
  /* <span class="comment">
以降の参照では例外が投出されるようにする
◎
Ensure that subsequent refs throw an exception
</span> */
  URL.revokeObjectURL(blobURLref);
}
else {
  msg("Images cannot be previewed!");

  /* <span class="comment">
文字列による参照を破棄する
◎
revoke the string-based reference
</span> */
  URL.revokeObjectURL(blobURLref);
}</pre>

</div>

<p>
上の例では、 1 個の`~Blob~URL$に対する複数回の参照が可能になる。
`~Blob~URL$文字列は，画像~objがいずれも読込まれた後に破棄されている。
`~Blob~URL$の利用回数が制約されない分，柔軟性は得られるが、~leakももたらされ易くなる。
開発者は `URL.revokeObjectURL()$m の~callと対にするべきである。
◎
The example above allows multiple references to a single Blob URL, and the web developer then revokes the Blob URL string after both image objects have been loaded. While not restricting number of uses of the Blob URL offers more flexibility, it increases the likelihood of leaks; developers should pair it with a corresponding call to URL.revokeObjectURL().
</p>

			</section>
		</section>
		<section id="lifeTime">
<h3 title="Lifetime of Blob URLs">8.6. ~Blob~URLの存続期間</h3>

<p>
`URL.createObjectURL()$m を公開する大域~objは、
`~Blob~URL~Store@
を維持管理し~MUST。
それは，一連の組からなる~listであり、各~組は［
`URL.createObjectURL()$m ~methodを利用して作成された`~Blob~URL$
］, ［
その`~Blob~URL$が指している`~Blob$資源
］からなる。
◎
A global object which exposes URL.createObjectURL() must maintain a Blob URL Store which is a list of Blob URLs created by the URL.createObjectURL() method, and the Blob resource that each refers to.
</p>

<p>
与えられた
( `~Blob~URL$ %url, %url が指す`~Blob$ )
組を
`~Blob~URL~Storeに追加する@
とは、~UAがその組を`~Blob~URL~Store$に追加し~MUSTことを意味する。
◎
When this specification says to add an entry to the Blob URL Store for a Blob URL and a Blob input, the user-agent must add the Blob URL and a reference to the Blob it refers to to the Blob URL Store.
</p>

<p>
与えられた［
`~Blob~URL$ %url ／ `~Blob$ %Blob
］に対応する~entryを
`~Blob~URL~Storeから除去する@
とは、［
組 ( %url, %url が指す`~Blob$ ) ／
組 ( %Blob を指している`~Blob~URL$, %Blob )
］が`~Blob~URL~Store$内にあれば，それを~Storeから除去し~MUSTことを意味する。
除去された`~Blob~URL$に対する後続の`参照取得$の試みは、`~network~error$にされ~MUST。
◎
When this specification says to remove an entry from the Blob URL Store for a given Blob URL or for a given Blob, user agents must remove the Blob URL and the Blob it refers to from the Blob URL Store. Subsequent attempts to dereference this URL must result in a network error.
</p>

<p>
この仕様は、`文書~unload時の片付け手続き$に，次を追加する
⇒
~UAは、すべての`~Blob~URL$を`文書$内の`~Blob~URL~Store$から除去し~MUST。
◎
This specification adds an additional unloading document cleanup step: user agents must remove all Blob URLs from the Blob URL Store within that document.
</p>

<p class="note">注記：
`~Blob~URL~Store$から除去された資源に対しては、~UAは，自由に~garbage収集できる。
◎
Note: User agents are free to garbage collect resources removed from the Blob URL Store.
</p>


		</section>
	</section>
	<section id="security-discussion">
<h2 title="Security and Privacy Considerations">9. 保安と~privacy上の考慮点</h2>

~INFORMATIVE

<p>
この仕様では、~Web内容が 下層の~file~systemから~fileを読取ることを許容し，~fileが一意な識別子を通して~accessされることの意味を与えるが、その種のものは保安~上の考慮点になる。
この仕様は、利用者との対話が主に~HTML~formの
`&lt;input type="file"/&gt;^e 要素 `HTML$r
によるものであり、 `FileReader$I ~objから読取られるすべての~fileは，最初に利用者の手により選択されたものであると見做している。
重要な保安~上の考慮点には、悪意的な~file選択攻撃（選択looping）の防止, `~systemに関わる~file$への~accessの防止, 選択後に~disk上の~fileに対する改変からの保護がある。
◎
This specification allows web content to read files from the underlying file system, as well as provides a means for files to be accessed by unique identifiers, and as such is subject to some security considerations.
This specification also assumes that the primary user interaction is with the &lt;input type="file"/&gt; element of HTML forms [HTML], and that all files that are being read by FileReader objects have first been selected by the user.
Important security considerations include preventing malicious file selection attacks (selection looping), preventing access to system-sensitive files, and guarding against modifications of files on disk after a selection has taken place.
</p>

<ul>
	<li>
`選択looping@の防止：
~file選択の間、利用者は `&lt;input type="file"/&gt;^e に結びつけられた~file選択ダイアログにより攻撃され得る（選択しない限り，~file選択ダイアログが際限なく現れる “選択強制” ）。
~UAは、返される `FileList$I ~objの~sizeを 0 にすることにより，~file~accessを防止してもよい。
◎
Preventing selection looping.
During file selection, a user may be bombarded with the file picker associated with &lt;input type="file"/&gt; (in a "must choose" loop that forces selection before the file picker is dismissed) and a user agent may prevent file access to any selections by making the FileList object returned be of size 0.
</li>
	<li>
`~systemに関わる~file@：
（ system-sensitive files — 例えば /usr/bin の~file, password ~file, 他の OS ~nativeの実行可能~file）は、概して，~Web内容に曝露されるべきではなく，`~Blob~URL$を通して~accessされるべきではない。
~UAは、`同期~読取り~method$に対し `SecurityError$E 例外を`投出$してもよく, また `非同期~読取り~method$においては `SecurityError$E 例外を返してもよい。
◎
System-sensitive files (e.g. files in /usr/bin, password files, and other native operating system executables) typically should not be exposed to web content, and should not be accessed via Blob URLs. User agents may throw a SecurityError exception for synchronous read methods, or return a SecurityError exception for asynchronous reads.
</li>
</ul>

<p class="issue">課題：
この節は暫定的なものである。
後続の草案には、より多くの保安~上の考慮点が追加される事になる。
◎
This section is provisional; more security data may supplement this in subsequent drafts.
</p>

	</section>
	<section id="requirements">
<h2 title="Requirements and Use Cases">10. 要件と利用事例</h2>

<p>
この節では、この~APIに対しどのような要件が課されるかについて, および
一部の利用事例についての説明を与える。
この~versionの~APIは、すべての利用事例に応えるものではない。
それらへの取り組みは後続の~versionに委ねられる。
◎
This section covers what the requirements are for this API, as well as illustrates some use cases.
This version of the API does not satisfy all use cases; subsequent versions may elect to address these.
</p>

<ul>
	<li>
<p>
利用者からの許可を得たなら、~UAは，~local~fileに対する~dataを ~programから直接的に読取って構文解析できる能を提供すべきである。
◎
Once a user has given permission, user agents should provide the ability to read and parse data directly from a local file programmatically.
</p>

<p class="example">例：
歌詞~viewer。
利用者は自身の plist ~file
`プレイリスト^tnote
の楽曲の歌詞を読みたいとする。
利用者は plist ~fileを閲覧するとき、~fileは開かれ, 読取られ, 構文解析され, ~Web~app内で並び換えられ, 操作可能な一覧として利用者に示される。
利用者は曲を選択してその歌詞を閲覧できる。
利用者は “閲覧~file選択” ダイアログを利用する。
◎
A lyrics viewer. User wants to read song lyrics from songs in his plist file. User browses for plist file. File is opened, read, parsed, and presented to the user as a sortable, actionable list within a web application. User can select songs to fetch lyrics. User uses the "browse for file" dialog.
</p>
	</li>
	<li>
<p>
~dataは後の利用のために~localに格納できるべきである。
それは~Web~appにおける~offline~data~accessに有用になる。
◎
Data should be able to be stored locally so that it is available for later use, which is useful for offline data access for web applications.
</p>

<p class="example">例：
~Calendar~app。
利用者の会社には予定表があり、利用者は自身の~eventと会社の “多忙” 期間の印が付けられた予定表との~~同期を（個人情報が漏れないように）とりたいとする。
利用者は一覧から~fileを探して選択する。
text/calendar ~fileは~browserにより構文解析され、単一の予定表~viewに併合できるようになる。
利用者はそれを自分用の予定表~fileに保存したり（ “別名で保存…” を用いて）、統合された予定表~fileを非同期に送信して~serverに格納させることもできる。
◎
A Calendar App. User’s company has a calendar. User wants to sync local events to company calendar, marked as "busy" slots (without leaking personal info).
User browses for file and selects it. The text/calendar file is parsed in the browser, allowing the user to merge the files to one calendar view. The user wants to then save the file back to his local calendar file. (using "Save As" ?). The user can also send the integrated calendar file back to the server calendar store asynchronously.
</p>
	</li>
	<li>
<p>
~UAは、与えられた~dataと~file名から ~programにより~local~fileに保存する能を提供すべきである。
◎
User agents should provide the ability to save a local file programmatically given an amount of data and a file name.
</p>

<p class="note">注記：
この仕様は，~downloadを誘発させる明示的な~API~callは提供しないが、それは HTML5 仕様にて取り組まれている。
`a$e 要素の `download$a 属性 `HTML$r は、~downloadを起動させ，
`File$I を指定された名前で保存する。
この~APIと `a^e 要素の `download^a 属性との組み合せにより、~Web~appの中で~fileを作成して，~localに保存することが可能になる。
◎
Note: While this specification doesn’t provide an explicit API call to trigger downloads, the HTML5 specification has addressed this. The download attribute of the a element initiates a download, saving a File with the name specified. The combination of this API and the download attribute on a elements allows for the creation of files within web applications, and the ability to save them locally.
</p>


<p class="example">例：
~spreadsheet ~app。
利用者は~formを通して何らかの入力を生成する。
しかる後、~formから，~spreadsheetに組み入れられる CSV （ Comma Separated Variables ）出力が生成され，“保存…" が行われる。
生成された出力を直接的に~Webベースの~spreadsheetに統合させたり, 非同期に~uploadさせる事もできる。
◎
A Spreadsheet App. User interacts with a form, and generates some input. The form then generates a CSV (Comma Separated Variables) output for the user to import into a spreadsheet, and uses "Save...". The generated output can also be directly integrated into a web-based spreadsheet, and uploaded asynchronously.
</p>
	</li>
	<li>
<p>
~UAは、今日の~formを用いた~uploadよりも効率的に働くような，~fileから~remote~serverへ~dataを送信するための、効率的な~program的~能を提供すべきである。
◎
User agents should provide a streamlined programmatic ability to send data from a file to a remote server that works more efficiently than form-based uploads today.
</p>

<p class="example">例：
ビデオや写真の~upload~app。
利用者は~uploadに巨大な~fileを選択でき，~chunkごとに~serverに送信できる。
◎
A Video/Photo Upload App.
User is able to select large files for upload, which can then be "chunk-transfered" to the server.
</p>
	</li>
	<li>
~UAは、上述の特色機能を可能にする~APIを~scriptに公開するべきである。
利用者は、~file~systemとの対話に入ったときは，いつでも~transactionの取消／中止を常に行えるような形で，~UIから通知を受ける。
利用者は、いかなる~file選択においても通知を受けられ，それを取消せる。
これらの~APIに対する呼出は、利用者の介在抜きに黙って生じることはない。
◎
User agents should provide an API exposed to script that exposes the features above. The user is notified by UI anytime interaction with the file system takes place, giving the user full ability to cancel or abort the transaction. The user is notified of any file selections, and can cancel these. No invocations to these APIs occur silently without user intervention.
</li>
</ul>

	</section>
	<section id="AppendixA">
<h2 title="Appendix A: Blob URL Grammar">付録 A. ~Blob~URLの文法</h2>

<p>
この節では、`~Blob~URL$の各 成分を記述するため，
`RFC5234$r にて定義される~ABNF（ Augmented Backus-Naur Form ）を用いる。
◎
This section uses the Augmented Backus-Naur Form (ABNF), defined in [RFC5234], to describe components of blob: URLs.
</p>

		<section id="ABNFUUID">
<h3 title="An ABNF for UUID">A.1. ~UUIDの~ABNF</h3>

<div >

<p>
~UUIDの~ABNF `RFC5234$r は、以下に与えられる。
~UUID文字列は：
</p>
<ul>
	<li>
次の範囲の文字 `Unicode$r のみを利用し~MUST：
［
`002A^U,
`002B^U,
`002D^U,
`002E^U,
`0030^U 〜 `0039^U,
`0041^U 〜 `005A^U,
`005E^U 〜 `007E^U
］
<span class="trans-note">【 <span style="font-family: monospace, monospace">*+-.0…9A…Z^_`a…z{|}~</span> 】</span>
</li>
	<li>
少なくとも 36 文字 以上からなるべきである。
</li>
</ul>

◎
The following is an ABNF [RFC5234] for UUID. UUID strings must only use characters in the ranges U+002A to U+002B, U+002D to U+002E, U+0030 to U+0039, U+0041 to U+005A, U+005E to U+007E [Unicode], and should be at least 36 characters long.
</div>

<pre class="ABNF">
UUID                   = time-low "-" time-mid "-"
                         time-high-and-version "-"
                         clock-seq-and-reserved
                         clock-seq-low "-" node
time-low               = 4hexOctet
time-mid               = 2hexOctet
time-high-and-version  = 2hexOctet
clock-seq-and-reserved = hexOctet
clock-seq-low          = hexOctet
node                   = 6hexOctet
hexOctet               = hexDigit hexDigit
hexDigit =
    "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" /
    "a" / "b" / "c" / "d" / "e" / "f" /
    "A" / "B" / "C" / "D" / "E" / "F"
</pre>

		</section>
		<section id="ABNFFragment">
<h3 title="An ABNF for Fragment Identifiers">A.2. 素片~識別子の~ABNF</h3>

<pre class="ABNF">
fragIdentifier = "#" fragment

; <span class="comment" title="Fragment Identifiers depend on the media type of the Blob"
>素片~識別子（ fragment ）は `Blob^I の媒体型に依存する</span>
; <span class="comment" title="fragment is defined in [RFC3986]"
>素片~識別子は `RFC3986$r にて定義される</span>
; <span class="comment" title="fragment processing for HTML is defined in [HTML]"
>~HTMLの素片~識別子の処理は `HTML$r にて定義される</span>

fragment    = *( pchar / "/" / "?" )

pchar       = unreserved / pct-encoded / sub-delims / ":" / "@"

unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"

pct-encoded   = "%" HEXDIG HEXDIG

sub-delims    = "!" / "$" / "&amp;" / "'" / "(" / ")" /
                "*" / "+" / "," / ";" / "="
</pre>


<!-- 

; Fragment Identifiers depend on the media type of the Blob
; fragment is defined in [RFC3986]
; fragment processing for HTML is defined in [HTML]
-->


		</section>
	</section>

	<section id="acknowledgements-section">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕様は元々は SVG Working Group により開発された。
Mark Baker 氏と Anne van Kesteren 氏からの~feedbackに。
◎
This specification was originally developed by the SVG Working Group. Many thanks to Mark Baker and Anne van Kesteren for their feedback.
</p>

<p>
元々の仕様の編集を行った Robin Berjon, Jonas Sicking 両氏に。
◎
Thanks to Robin Berjon and Jonas Sicking for editing the original specification.
</p>

<p>次の方々に：</p>

<p>
Special thanks to Olli Pettay, Nikunj Mehta, Garrett Smith, Aaron Boodman, Michael Nordman, Jian Li, Dmitry Titov, Ian Hickson, Darin Fisher, Sam Weinig, Adrian Bateman and Julian Reschke.
</p>

<p>
W3C WebApps WG, および public-webapps@w3.org listserv の協力者達に。
◎
Thanks to the W3C WebApps WG, and to participants on the public-webapps@w3.org listserv
</p>

	</section>

</main></div><!-- id="MAIN" -->

	<section id="conformance">
<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この他の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative references">文献（規範）</h3>

<dl>
	<dt>[DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>

	<dt>[ECMA-262]</dt>
	<dd>ECMAScript Language Specification.</dd>
	<dd>https://tc39.github.io/ecma262/</dd>

	<dt>[Encoding]</dt>
	<dd>Anne van Kesteren. Encoding Standard. Living Standard.</dd>
	<dd>https://encoding.spec.whatwg.org/</dd>

	<dt>[Fetch]</dt>
	<dd>Anne van Kesteren. Fetch Standard. Living Standard.</dd>
	<dd>https://fetch.spec.whatwg.org/</dd>

	<dt>[HTML]</dt>
	<dd>Anne van Kesteren; et al. HTML Standard. Living Standard.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

	<dt>[INFRA]</dt>
	<dd>Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard.</dd>
	<dd>https://infra.spec.whatwg.org/</dd>

	<dt>[MIMESNIFF]</dt>
	<dd>Gordon P. Hemsley. MIME Sniffing Standard. Living Standard.</dd>
	<dd>https://mimesniff.spec.whatwg.org/</dd>

	<dt>[RFC2046]</dt>
	<dd>N. Freed; N. Borenstein. Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types. November 1996. Draft Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc2046</dd>

	<dt>[RFC2119]</dt>
	<dd>S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc2119</dd>

	<dt>[RFC2397]</dt>
	<dd>L. Masinter. The "data" URL scheme. August 1998. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc2397</dd>

	<dt>[RFC5234]</dt>
	<dd>D. Crocker, Ed.; P. Overell. Augmented BNF for Syntax Specifications: ABNF. January 2008. Internet Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc5234</dd>

	<dt>[RFC6266]</dt>
	<dd>J. Reschke. Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP). June 2011. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc6266</dd>

	<dt>[RFC7230]</dt>
	<dd>R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc7230</dd>

	<dt>[RFC7231]</dt>
	<dd>R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc7231</dd>

	<dt>[STREAMS]</dt>
	<dd>Domenic Denicola; 吉野剛史 (Takeshi Yoshino). Streams Standard. Living Standard.</dd>
	<dd>https://streams.spec.whatwg.org/</dd>

	<dt>[Unicode]</dt>
	<dd>The Unicode Standard.</dd>
	<dd>http://www.unicode.org/versions/latest/</dd>

	<dt>[URL]</dt>
	<dd>Anne van Kesteren. URL Standard. Living Standard.</dd>
	<dd>https://url.spec.whatwg.org/</dd>

	<dt>[WebIDL]</dt>
	<dd>Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL.</dd>
	<dd>https://heycam.github.io/webidl/</dd>

	<dt>[XHR]</dt>
	<dd>Anne van Kesteren. XMLHttpRequest Standard. Living Standard.</dd>
	<dd>https://xhr.spec.whatwg.org/</dd>
</dl>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<dl>
	<dt>[RFC1630]</dt>
	<dd>T. Berners-Lee. Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web. June 1994. Informational.</dd>
	<dd>https://tools.ietf.org/html/rfc1630</dd>

	<dt>[RFC1738]</dt>
	<dd>T. Berners-Lee; L. Masinter; M. McCahill. Uniform Resource Locators (URL). December 1994. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc1738</dd>

	<dt>[RFC3986]</dt>
	<dd>T. Berners-Lee; R. Fielding; L. Masinter. Uniform Resource Identifier (URI): Generic Syntax. January 2005. Internet Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc3986</dd>

	<dt>[RFC4122]</dt>
	<dd>P. Leach; M. Mealling; R. Salz. A Universally Unique IDentifier (UUID) URN Namespace. July 2005. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc4122</dd>

	<dt>[WebRTC]</dt>
	<dd>Adam Bergkvist; et al. WebRTC 1.0: Real-time Communication Between Browsers.</dd>
	<dd>https://w3c.github.io/webrtc-pc/</dd>

	<dt>[Workers]</dt>
	<dd>Ian Hickson. Web Workers.</dd>
	<dd>https://html.spec.whatwg.org/multipage/workers.html</dd>
</dl>


		</section>
	</section>
	<section>
<h2 id="index" title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>
	</section>

	<section>
<h2 id="idl-index" title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<h2 id="issues-index" title="Issues Index" data-cycling=".issue">課題索引</h2>

<p class="trans-note">【
これらの節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>

</body>
</html>
