<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Scripting（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/scripting.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160426 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		P: 'production',
		st: 'attr-state',
		v: 'value',
		E: 'error',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		st: 'span',
		P: 'code',
		s: 'samp',
		v: 'code',
		V: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
//	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|❝.|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN', '_toc_list0');


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '❝':
		return ( 'U+00'
			+ match[1].charCodeAt(0).toString(16).toUpperCase()
			+ ' ( "<code class="literal">' + match[1] + '</code>" )'
		);
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
//var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'mt': // media type
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a': // event type
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'et': // event type
	break;
case 'i': // model constants
	break;
case '0x': // ABNF char code %x escape
	return '%x' + key
	break;
case 'v': // attr value
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
	the-script-element:script
</script>


<!--% リンク置換データ 


`文脈~要素$V

-->
<script type="text/plain" id="_link_map">

	●e
e.script:#the-script-element
e.slot:#the-slot-element
e.template:#the-template-element
e.noscript:#the-noscript-element

e.p:~HTMLgrouping#the-p-element
e.figure:~HTMLgrouping#the-figure-element

e.head:~HTMLmetadata#the-head-element
e.link:~HTMLmetadata#the-link-element
e.meta:~HTMLmetadata#the-meta-element
e.style:~HTMLmetadata#the-style-element


e.colgroup:~HTML5/tables.html#the-colgroup-element
e.details:~HTML5/forms.html#the-details-element

	●attr
a.async:#attr-script-async
a.charset:#attr-script-charset
a.crossorigin:#attr-script-crossorigin
a.defer:#attr-script-defer
a.event:~HTML5/obsolete.html#attr-script-event
a.for:~HTML5/obsolete.html#attr-script-for
a.language:~HTML5/obsolete.html#attr-script-language
a.name:#attr-slot-name
a.nonce:#attr-script-nonce
a.span:~HTML5/tables.html#attr-colgroup-span
a.src:#attr-script-src
a.type:#attr-script-type


	●IDL 
I.AssignedNodesOptions:#assignednodesoptions
I.DOMParser:https://w3c.github.io/DOM-Parsing/#the-domparser-interface
I.Document:~HTMLdom#document
I.DocumentFragment:~DOM4#interface-documentfragment
I.HTMLElement:~HTMLdom#htmlelement
I.HTMLScriptElement:#htmlscriptelement
I.HTMLSlotElement:#htmlslotelement
I.HTMLTemplateElement:#htmltemplateelement
I.Text:~DOM4#interface-text
I.Window:~BROWSERS#window
I.XMLHttpRequest:~XHR#xmlhttprequest
I.XSLTProcessor:~HTMLconform#xsltprocessor

文書片:#_documentfragment
文書:#_document
CEReactions:~HTMLcustom#cereactions

	●m

m.XSLTProcessor.transformToDocument:~HTMLconform#dom-xsltprocessor-transformtodocument
m.XSLTProcessor.transformToFragment:~HTMLconform#dom-xsltprocessor-transformtofragment
m.appendChild:~DOM4#dom-node-appendchild
m.assignedNodes:#dom-slot-assignednodes

m.async:#dom-script-async
m.charset:#dom-script-charset
m.cloneNode:~DOM4#dom-node-clonenode
m.content:#dom-template-content
m.createDocument:~DOM4#dom-domimplementation-createdocument
m.crossOrigin:#dom-script-crossorigin
m.currentScript:~HTMLdom#dom-document-currentscript
m.defer:#dom-script-defer
m.document.createElementNS:~DOM4#dom-document-createelementns
m.document.importNode:~DOM4#dom-document-importnode
m.document.write:~WAPI#dom-document-write
m.innerHTML:https://w3c.github.io/DOM-Parsing/#widl-Element-innerHTML
m.name:#dom-slot-name
m.nonce:#dom-script-nonce
m.outerHTML:https://w3c.github.io/DOM-Parsing/#widl-Element-outerHTML
m.responseXML:~XHR#dom-xmlhttprequest-responsexml
m.src:#dom-script-src
m.text:#dom-script-text
m.textContent:~DOM4#dom-node-textcontent
m.transformToDocument:~HTMLconform#dom-xsltprocessor-transformtodocument
m.type:#dom-script-type

	●mime
mt.application/ecmascript:~HTML5/indices.html#application/ecmascript
mt.application/javascript:~HTML5/indices.html#application/javascript
mt.application/octet-stream:~IETF/rfc2046#section-4.5.1
mt.application/x-ecmascript:~HTML5/indices.html#application/x-ecmascript
mt.application/x-javascript:~HTML5/indices.html#application/x-javascript
mt.application/xml:~HTML5/indices.html#application/xml

mt.text/ecmascript:~HTML5/indices.html#text/ecmascript
mt.text/javascript1.0:~HTML5/indices.html#text/javascript1.0
mt.text/javascript1.1:~HTML5/indices.html#text/javascript1.1
mt.text/javascript1.2:~HTML5/indices.html#text/javascript1.2
mt.text/javascript1.3:~HTML5/indices.html#text/javascript1.3
mt.text/javascript1.4:~HTML5/indices.html#text/javascript1.4
mt.text/javascript1.5:~HTML5/indices.html#text/javascript1.5
mt.text/javascript:~HTML5/indices.html#text/javascript
mt.text/jscript:~HTML5/indices.html#text/jscript
mt.text/livescript:~HTML5/indices.html#text/livescript
mt.text/plain:~IETF/rfc2046#section-4.1.3
mt.text/x-ecmascript:~HTML5/indices.html#text/x-ecmascript
mt.text/x-javascript:~HTML5/indices.html#text/x-javascript
mt.text/xml:~HTML5/indices.html#text/xml

	●et
et.load:~HTML5/indices.html#event-load
et.error:~HTML5/indices.html#event-error

	●st
st.Anonymous:~HTMLINFRA#attr-crossorigin-anonymous
st.Use Credentials:~HTMLINFRA#attr-crossorigin-use-credentials
st.No CORS:~HTMLINFRA#attr-crossorigin-none
	誤？Use Credentials:~HTMLINFRA#attr-crossorigin-none

V.async:#_val-async
V.charset:#_val-charset
V.defer:#_val-defer
V.language:#_val-language
V.src:#_val-src
V.type:#_val-type

	●l
開始済み~flag:#already-started
	l.already started:#already-started
解析器挿入~flag:#parser-inserted
	l.parser-inserted:#parser-inserted
阻まず~flag:#non-blocking
	l.non-blocking:#non-blocking
解析器実行準備済み~flag:#ready-to-be-parser-executed
	l.ready to be parser-executed:#ready-to-be-parser-executed

外部~file~flag:#concept-script-external
外部~fileから:#concept-script-external


	●terms
~data~block:#data-block
~script種別:#concept-script-type
~script:#concept-script-script
~script0の~script:#concept-script-script

~scriptは準備済み:#the-script-is-ready
準備済み:#the-script-is-ready
~scriptを~prepare:#prepare-a-script
準備-:#prepare-a-script
~scriptを準備する:#prepare-a-script

文書を構文解析し終えたときに実行される~scriptの~list:#list-of-scripts-that-will-execute-when-the-document-has-finished-parsing
可及的すぐに順に実行される~scriptの~list:#list-of-scripts-that-will-execute-in-order-as-soon-as-possible
可及的すぐに実行される~scriptの集合:#set-of-scripts-that-will-execute-as-soon-as-possible

構文解析器を阻んでいる~script:#pending-parsing-blocking-script
~pending~parsing-blocking~script:#pending-parsing-blocking-script
~script~blockを実行する:#execute-the-script-block
~template内容:#template-contents
~template内容を所有する適切な文書:#appropriate-template-contents-owner-document
	適切な~template内容~所有者~文書
不活~template文書:#associated-inert-template-document
~JS~MIME型:#javascript-mime-type

適切な~template内容s~owner文書:#appropriate-template-contents-owner-document
~associated不活~template文書:#associated-inert-template-document
~data~block:#data-block
~script~blockを実行する:#execute-the-script-block
~form提出:~HTML5/forms.html#form-submission-2

~script内容~制約:#restrictions-for-contents-of-script-elements
~script文書化:#inline-documentation-for-external-scripts

	●terms DOM4
受入-:~DOM4#concept-node-adopt
~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document
	文書種別:~DOM4#concept-document-type
受入-時の手続き:~DOM4#concept-node-adopt-ext
割当されている~nodeたち:~DOM4#slot-assigned-nodes
~clone:~DOM4#concept-node-clone
~clone時の手続き:~DOM4#concept-node-clone-ext
	~cloning:~DOM4#concept-node-clone
平坦化された~slotableたちを見出-:~DOM4#find-flattened-slotables
~host:~DOM4#concept-documentfragment-host
文書~木~内:~DOM4#in-a-document-tree
接続済み:~DOM4#connected
~slot名:~DOM4#slot-name
~node文書:~DOM4#concept-node-document
~shadow木:~DOM4#concept-shadow-tree
~slot:~DOM4#concept-slot
doc.符号化方式:~DOM4#concept-document-encoding
木~順序:~DOM4#concept-tree-order
根:~DOM4#concept-tree-root
~shadow根:~DOM4#concept-shadow-root


	●HTMLINFRA
	~ACI:#_ascii-case-insensitive
~ASCII小文字~化:~HTMLINFRA#converted-to-ascii-lowercase
~ASCII大小無視:~HTMLINFRA#ascii-case-insensitive
~CORS設定群~属性:~HTMLINFRA#cors-settings-attribute
Content-Type ~metadata:~HTMLINFRA#content-type
即時:~HTMLINFRA#immediately
接続され:~HTMLINFRA#becomes-connected
~MIME型:~HTMLINFRA#mime-type
相対的に構文解析-:~HTMLINFRA#parse-a-url
頭部と尾部の空白を剥いだ:~HTMLINFRA#strip-leading-and-trailing-whitespace
Unicode 文字:~HTMLINFRA#unicode-character
真偽~属性:~HTMLINFRA#boolean-attribute
子~text内容:~HTMLINFRA#child-text-content
文書~基底~URL:~HTMLINFRA#document-base-url
並列的:~HTMLINFRA#in-parallel
文書の中に挿入され:~HTMLINFRA#insert-an-element-into-a-document
node.挿入され:~HTMLINFRA#nodes-are-inserted
反映-:~HTMLINFRA#reflect
結果の~URL~record:~HTMLINFRA#resulting-url-record
空白類:~HTMLINFRA#space-character
妥当な~MIME型:~HTMLINFRA#valid-mime-type
前後~空白~可の妥当かつ空でない~URL:~HTMLINFRA#valid-non-empty-url-potentially-surrounded-by-spaces



	●HTMLdom
HTMLConstructor:~HTMLdom#htmlconstructor
分類:~HTMLdom#concept-element-categories
内容~属性:~HTMLdom#concept-element-attributes
内容~model:~HTMLdom#concept-element-content-model
なし:~HTMLdom#concept-content-nothing
この要素を利用できる文脈:~HTMLdom#concept-element-contexts
~DOM~interface:~HTMLdom#concept-element-dom
~flow内容:~HTMLdom#flow-content-2
大域~属性:~HTMLdom#global-attributes
~metadata内容:~HTMLdom#metadata-content-2
句内容:~HTMLdom#phrasing-content-2
~scriptを~supportする要素:~HTMLdom#script-supporting-elements-2
text/html における~tag省略:~HTMLdom#concept-element-tag-omission
透過的:~HTMLdom#transparent
表現-:~HTMLdom#represents

	●WAPI
x.~script:~WAPI#concept-script
~classic~script:~WAPI#classic-script
~classic~scriptを~fetchする:~WAPI#fetch-a-classic-script
~classic~scriptを走らす:~WAPI#run-a-classic-script
~classic~scriptを作成-:~WAPI#creating-a-classic-script
~module~scriptを作成-:~WAPI#creating-a-module-script
子孫を~fetchする:~WAPI#fetch-the-descendants-of-a-module-script
大域~obj:~WAPI#global-object
破壊的書込無視~counter:~HTML5/webappapis.html#ignore-destructive-writes-counter
~module~script:~WAPI#module-script
~module~scriptを走らす:~WAPI#run-a-module-script
~module~script木を~fetchする:~WAPI#fetch-a-module-script-tree
~taskを待入する:~WAPI#queue-a-task
~scripting:~WAPI#scripting
0.~scriptingは不能化され:~WAPI#concept-bc-noscript
~scriptingは不能化され:~WAPI#concept-n-noscript
~scriptingは可能化され:~WAPI#concept-n-script
単純~eventを発火する:~WAPI#fire-a-simple-event
環境~設定群~obj:~WAPI#environment-settings-object

非同期に完了した:~WAPI#_asynchronously-complete


	●HTML5 
構文解析-~error:~HTML5/syntax.html#parse-error
~load~eventを遅延-:~HTML5/syntax.html#delay-the-load-event
~HTML素片~構文解析~algo:~HTML5/syntax.html#html-fragment-parsing-algorithm
~HTML構文解析器:~HTML5/syntax.html#html-parser
V.文脈~要素:~HTML5/syntax.html#concept-frag-parse-context
	~end:~HTML5/syntax.html#scriptEndTag
~script入子ing~level:~HTML5/syntax.html#script-nesting-level
	~in~foreign内容:~HTML5/syntax.html#scriptForeignEndTag
~scriptingは可能化されていたかどうか:~HTML5/syntax.html#scripting-flag

~XML構文解析器:~HTML5/xhtml.html#xml-parser
	~as~described~in~this~specification:~HTML5/xhtml.html#xml-parser

閲覧文脈:~BROWSERS#browsing-context
閲覧文脈に属さ:~BROWSERS#concept-document-bc
属する閲覧文脈:~BROWSERS#concept-document-bc
生成元:~BROWSERS#concept-origin

~scriptを阻んでいる~stylesheet:~HTMLmetadata#a-style-sheet-that-is-blocking-scripts
~scriptを阻んでいる~stylesheetがある:~HTMLmetadata#has-a-style-sheet-that-is-blocking-scripts

	~in~XML:~HTML5/xhtml.html#scriptTagXML
	~start:~HTML5/syntax.html#scriptTag
~HTML構文:~HTML5/syntax.html#syntax
~XHTML構文:~HTML5/xhtml.html#the-xhtml-syntax


	●others
~CORS~protocol:~FETCH#http-cors-protocol
資格証~mode:~FETCH#concept-request-credentials-mode

符号化方式:~ENCODING#encoding
符号化方式を取得-:~ENCODING#concept-encoding-get
符号化方式~label:~ENCODING#label

~URL:~URLSpec#concept-url

P.Module:~TC39#prod-Module
P.Script:~TC39#prod-Script

要素における~inline型の挙動は~CSPにより阻止されるべきか？:~CSP3#should-block-inline


</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
RXPbefore:`\\b${<var>before</var>}\\b`

type0:type
script0:<code class="element">script</code> 
</script>

<!-- 
ACI:<sub>大小無視</sub>

	ES6:https://tc39.github.io/ecma262/

-->
<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">
	●


API:::
ASCII:::
DOM:::
HTML:::
IDL:::
INFORMATIVE:::
JS:JavaScript
XHTML:
ABNF:
XML:
XSLT:
MIME:
XPath:
UA:::
CSP:
CORS:
	Unicode:::
URL:::
Web:::

browser::::ブラウザ
button::::ボタン
counter::::カウンタ
	cloned::::
	cloning::::
code::::コード
column::::カラム
control::::コントロール
comment::::コメント

data::::データ
entry::::エントリ
escape::::エスケープ

file::::ファイル
flow::::フロー
form::::フォーム
game::::ゲーム
header::見出し:::ヘッダ
host::::ホスト
	jump::::
label::::ラベル
level::::レベル
link::::リンク
list::::リスト

literal::::リテラル
license::::ライセンス
map::::マップ
	mark::::
markup::::マークアップ
member::::メンバ
menu::::メニュー
model::::モデル
option::::オプション
parameter::::パラメタ
popup::::ポップアップ
program::::プログラム
prop:property:::プロパティ
protocol::::プロトコル
sort::::ソート
strict:
source::::ソース
stylesheet:style sheet:::スタイルシート
template:

table::::テーブル
tag::::タグ
text::::テキスト
top-level::::トップレベル
video::::ビデオ
zero::::ゼロ



url::::
record::::レコード
server::::サーバ
site::::サイト
algo:algorithm:::アルゴリズム
app:application:::アプリ
address::::アドレス
custom::::カスタム
	custom化:customization
集合:set:~
関数:function:~

	●slot
shadow:
slot:
slotable:
	スロット
割当され:assign され::あてがわれ

	●処理
module::::モジュール
取込める:import できる:取り込める
取込む:import する:取り込む
取込まれ:import され:取り込まれ
非同期:asynchronous:~

flag::::フラグ
mode::::モード
node::::ノード
obj:object:::オブジェクト
task::::タスク
script::::スクリプト
scripting::::スクリプト処理
inline::::インライン
不活:inert::~
	import:
block::::ブロック
classic::::クラシック
error::::エラー
event::::イベント
単純:simple:~
発火-:fire::~
fall-back::::フォールバック
fallback::::フォールバック
clone::::クローン
method::::メソッド
instance::::インスタンス
interface::::インタフェース

阻止-:block::~::ブロック
阻止ed:Blocked::阻止される::ブロックされる
阻まれ:block され::~::ブロックされ
阻まず:non-blocking::~::非ブロッキング
阻んで:block して::~::ブロックして
阻み:block し::~::ブロックし
阻む:block する::~::ブロックする
阻まな:block しな::~::ブロックしな
	他を阻まないように:non-blocking fashion

開始済み:already started::~
準備済み:ready::~
準備-:prepare::~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
解析器:parser::~::パーサ

解析器挿入:parser-inserted::~::パーサ挿入
解析器実行準備済み:ready to be parser-executed::解析器実行 準備済み::パーサ実行 準備済み
破壊的書込無視:ignore-destructive-writes:破壊的な書き込み無視
待入する:queue する::待ち行列に入れる::キューする

実行-:execute:~
実行:execution:~
実行ing:executing:実行
中断-:interrupt:~
先送り:defer:~
完了-:complete:~
不能化-:disable:~
可能化-:enable:~

接続-:connect:~
依存-:depend:~
依存物:dependencies:~
受入-:adopt:~
受入:adopting:~
付加-:append:~
作成-:create:~
除去-:remove:~

呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
呼出す:invoke する:呼び出す
埋込まれ:embed され::埋め込まれ
埋込む:embed する::埋め込む
埋込める:embed できる::埋め込める
走らす:run する:走らせる
走らせ:run し:~
即時:immediate:~
並列的:parallel:~

可及的:possible な限り:可能な限り
外部:external:~
失敗-:fail:~
失敗:failure:~
成功:success:~
成功-:succeed:~
投出-:throw:~

設定-:set:~
設定:setting:~
設定群:settings:~
未設定:unset:~
評価-:evaluate:~
評価:evaluation:~

追加-:add:~
初期化-:initialize:~
初期:initial:~

入子に:nest:入れ子に
入子ing:nesting:入れ子
被呼出時:被 invoke 時:~
被取得時:被 get 時:
被設定時:被 set 時:

取得-:get:~
挿入-:insert:~
処理-:process:~
処理:processing:~
処理器:processor:~
例外:exception:~
開始-:start:~
言語:language:~


	●fetch
fetch::::
fetching:::fetch 処理
	事前~fetching:prefetching
nonce::::ナンス
load:
素片:fragment:~
要請:request:~
資源:resource::~:リソース
暗号用:cryptographic:~
読込まれ:load され::~::ロードされ
読込まれ:load され::~::ロードされ
読込み:load::~::ロード
資格証:credentials::資格証明情報::クレデンシャル
基底:base:~
環境:environment:~
非同一生成元:cross-origin::~::クロスオリジン
生成元:origin::~::オリジン
相対的:relative:~

	●内容model
metadata::::メタデータ
句内容:phrasing content:phrasing 内容:~::フレージング内容
内容:content:~
透過的:transparent::~
省略-:omit:~
省略:ommission:~
省略不可:omissible でない:~
分類:category:~
	categories
要素:element:~
木:tree::~::ツリー
根:root::~::ルート
子:child:~
子たち:children:~
先祖:ancestor:~
子孫:descendant:~
文書:document:~
文書片:document fragment:~
文書化:documentation:~
閲覧文脈:browsing context::~
属性:attribute:~
真偽:boolean::~
大域:global::~::グローバル
反映-:reflect:~
平坦化-:flatten:~
見出-:find:~

開始tag:start tag:開始 tag::開始タグ
終了tag:end tag:終了 tag::終了タグ

	●仕様
代理:proxy::~
support::::サポート
	未~supportの:unsupported
中核:core:~
事例:case:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
	代替する:alternative:~
作者:author:~
具現化:rendering:~
一般:general:~
上品:graceful:~
再利用:reuse:~
冗長:redundant:~
	利用-:use:~
利用者:user:~

制御-:control:~
制約:restriction:~
副作用:side-effect:~
効果:effect:~
	効果を及ぼ:effective:~
動作-:act:~
動作:action:~
動的:dynamic:~
単独の:single:~
取扱う:handle する:取り扱う
取扱い:handling:取り扱い
問題:problem:~
	問題になる:problematic
図式:schematic diagram:~
奨励-:encourage:~
孕む:involve する:~
定義-:define:~
定義:definition:~
実施:practice:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
実質的:effective:~
実際:actual:~
将来:future:~
導入-:introduce:~
干渉-:interfere:~
影響-:affect:~
	必要:need:~
情報:information:~
意味-:mean:~
意図-:intend:~
所与の:given:与えられた
手動:manual:~
手続き:steps:~
技法:technique:~

指定-:specify:~
指示-:indicate:~
	~~指示-:denote:~
指針:guideline:~
挙動:behavior:ふるまい
提供-:provide:~
提示-:present:~
有用:useful:~
期待-:expect:~
条件:condition:~
検分-:examine:~
検査-:check:~
概して:typical に:~
	機能-:function:~
正確:exact:~
歴史的:historical:~
注釈文:prose:~
段:step:~
無視-:ignore:~
特定0の:particular:ある特定の
特定の:specific:~
特色機能:feature:~
状況:situation:~
理由:reason:~
目的0:purpose:目的
直接的:direct:~
相互作用-:interact:~
相互作用:interaction:~
相違:difference:~
確保-:ensure:~
確立-:establish:~
等価:equivalent:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
	見な:consider:~
能:ability:機能
自明:trivial:~
要件:requirement:~
適合性:conformance:~
要求-:require:~
要約-:summarize:~
視野:scope:~
見本:sample:~
解釈-:interpret:~
解釈し直す-:reinterpret:~
陥穽:pitfall:~
設計-:design:~
許容-:allow:~
試行-:try:~
詳細:details:~
認識-:recognize:~
退行-:degrade:~
通常の:normal:~
追加:addition:~
追加の:additional:~
遂行-:perform:~
適合-:conform:~
適合:conforming:~
適用-:apply:~
関係-:relate:~
浪費-:waste:~
不用意:accidental:~
拘束-:constrain:~
述べる:describe する:~
本質的:essential:~
旧来の:legacy:~
明示的:explicit:~
整合する:consistent になる:~
奇妙:strange:~
自然:natural:~
衝突:collision:~
	言及-:mention:~
適切:appropriate:~
純粋な:pure:~
側面:aspect:~
局面:scenario:~

	accordingly
	ひねくれた取扱い:contortion
	まるごと:entirely
	風変わりな:exotic:
	得られる:gain
	強調表示:highlight
	~~説明illustrate
	hope
	interesting
	likely
	no longer
	modulo
	namely
	ざるを得なく:by necessity
	mostly
	nonetheles
	注目すべき:notable
	poorly-defined
	previously
	potential
	put
	本当の:real:~
	refer
	当面の間:meantime／meanwhile
	具体的には:for instance
	~~理解しがたい:weird
	その場で:on-the-fly
	容易:easy:~
	今:now
	冒頭:top
	散らばって:scattered
	直感に反する:unintuitive
	後で:later
	易く:help
	突然にsuddenly
	違い:distinction:
	部分もあるsomewhat:
	出くわした-:face:
	他所:other parts
	一部:part of
	従う:follow

	●未分類
call:
行先:destination:~

更新-:update:~
格納-:store:~
比較-:compare:~
決定-:determine:~
演算-:operate:~
移動-:move:~
生成-:generate:~
算出-:compute:~
築く:build する:~
終端-:terminate:~
維持管理-:maintain:~
置換-:replace:~
置換えて:substitute して:~
	substitution:~
表現-:represent:~
計算:calculation:~
計算-:calculate:~
誘発-:trigger:~
連結:concatenation:~
選択-:select:~
配置-:place:~
違反-:violate:~
働く:work する:~
複製:copy:~
複製済:copied:~
免れる:exempt する:~
合致-:match:~
包含-:contain:~
参照-:reference:~
公開-:expose:~
提出-:submit::~
提出:submission::~
所有-:own:~
所有者:owner:~
	増減
拡充-:populate:~


大小無視:case-insensitive:~
小文字:lowercase:~
剥いだ:strip した:~
空白:whitespace:~
頭部:leading:~
尾部:trailing:~
文字:character:~
	文字~並び:sequence:~
文字列:string:~
空:empty:~
符号化方式:encoding::~::エンコーディング
名:name:~
名前:name:~
型:type:~
種別:type:~
値:value:~
生成規則:production:~
規則:rule:~


処理能:performance:~
正規表現:regular expressions:~
処理命令:processing instruction:~

不在:absence:~
出力:output:~
入力:input:~

内側:inside:~
再帰的:recursive:~
	再度:again:~


可用:available:~
可能0:possible:可能

変形-:transform::変換
変形:transformation::変換

変更-:change:~
変異-:mutate:~


妥当な:valid:~
妥当:valid:~
安全:safe:~

宣言-:declare:~
宣言:declaration:~
宣言的:declarative:~
対話性:interactivity:~
導出-:derive:~
式:expression:~
形式:format:~
	数:number:~
文:statement:~
文脈:context:~
新たな:new:~
既存の:existing:~
既定の:default:~
既定:default:~
旧-:old:~
	更なる:further:~
検索engine:search engine:検索 engine::検索エンジン
構成子:construct:~
構文:syntax:~
構造:structure:~

	浮上-:bubble:~
状態:state:~

現在の:current:~
頁:page:::ページ


	~~問題:issue:~

	遭遇-:encounter:~
順序:order:~
ニュースサイト:news site::~
	UTF-8

	両者:both:~
	他の場合:otherwise:~
	依然として:still:~
	在る:present:~
	増分:increment:~

	〜の代わりに:instead:~
	いくつかの:several:~
	この:this:~
	これらの:these:~
	しかしながら，:however:~
	したがって:therefore:~
	したがって:thus:~
	すでに:already:~
	すべての:all:~
	その:that:~
	そのような:such:~
	その他:others:~
	それら:they:~
	それらの:their:~
	それらの:those:~
	それらを:them:~
	べき:should:~
	もの:thing:~
	上:above:~
	下:below:~
	与-:give:~
	主な／主の:main:~
	二つ:two:~
	他の:other:~
	何か:something:~
	例:example:~
	なくなる:stop:~
	別の:another:~
	則って:according:~
	前:before:~
	各:each:~
	同じ:same:~
	含-:include:~
	含めて:including:~
	多い:often:~
	多くの:many:~
	対応-:correspond:~
	対応ing:corresponding:~
	常に:always:~
	後:after:~
	得-:obtain:~
	戻-:back:~
	扱う:treat:~
	探してlook for
	書-:write:~
	最初の:first:~
	最後の:last:~
	決して:never:~
	現れ:appear:~
	生-:occur:~
	異なる:different:~
	示す:show:~
	節:section:~
	終え:finish:~
	結果:result:~
	結果の:resulting:~
	自身:itself:~
	表す:express:~
	見かけ／様に見える:look:~
	詳細に:detail:~
	返す:return:~
	通:through:~
	避け:avoid:~
	除-:except:~
	詳細表示を切り替える:show or hide
	amongst
	better
	より大きな:bigger
	calling
	chosen
	cloning
	counter:#2
	differently
	direct-to-DOM
	earlier
	end:#3
	entire
	ever
	fifth
	forth
	four-column
	go
	going
	having
	labeled
	left
	行:line
	made
	marked:
	maybe
	neither
	non-blocking
	non-empty
	note
	owning
	parser-executed
	parser-inserted
	parsing-blocking
	part:#4
	pending
	piece
	remain
	somehow
	sometime
	近過去:recent:~
	unblocked
	until:
	using:
	was-parser-inserted:#4
	~code片:snippet
	suppose
	になることもあるpotentially
	側:side
	記され~put
	切る:turning off
	~scriptなしを前提に:scriptless
	なまくら:blunt instrument
	尽きるまで，there are no 〜 left
	-外:outside#1
	最も:most#1
	ほぼ定義されていない~poorly-defined
	ふるまいact
	ちょっとしたことで抵触し易く:prone to triggering:
	閉じられた:closing
	対に:balance
	ここで起きていること:What is going on here 
	行く~go
	可及的すぐに as soon as possible
	末尾~the~end
	けったいな読み物に変えてしまうmore interesting reading experience

</script>


<!--%style -->
<style type="text/css">


</style>

</head>

<body>


<div style="display:none;">
</div>
<aside class="trans-meta">
<h1>HTML Living Standard — Scripting 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">4.12. Scripting 節</a>
の一部の節を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-09-27</time>
（公開：<time>2016-04-27</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">

	<hgroup>
<h1>スクリプトの利用 — Scripting</h1>
<h2>HTML Living Standard — 最終更新 2016 年 9 月 27 日</h2>
	</hgroup>

</header>

<nav class="toc" id="toc">
<h2>目次</h2>
<ol id="_toc_list0"></ol></nav>

<hr>

<main id="MAIN" style="display:none;">

	<section id="scripting-3">
<h2 title="Scripting">4.12. ~scriptの利用</h2>

<p>
~scriptにより、作者は，文書に対話性を追加できるようになる。
◎
Scripts allow authors to add interactivity to their documents.
</p>

<p>
作者には、可能0な所では，~scriptingを代替する宣言的な仕組みを利用することが奨励される
— そうした方が維持管理し易くなることが多く、また，~scriptingを不能化している利用者も多くいる。
◎
Authors are encouraged to use declarative alternatives to scripting where possible, as declarative mechanisms are often more maintainable, and many users disable scripting.
</p>

<div class="example">
<p>
例えば、~scriptを利用して，ある一節の詳細表示を切り替える代わりに，
`details$e 要素を利用することもできる。
◎
For example, instead of using script to show or hide a section to show more details, the details element could be used.
</p>

</div>

<p>
作者にはまた、~scripting~supportが不在の下では，自身の~appを上品に退行させることも奨励される。
◎
Authors are also encouraged to make their applications degrade gracefully in the absence of scripting support.
</p>

<div class="example">

<p>
例えば作者は、~tableの~header内に，~tableを動的に~sortし直すような~linkを提供している場合、~serverに~sort済みの~tableを要請することで，~scriptなしに~linkを機能させることもできる。
◎
For example, if an author provides a link in a table header to dynamically resort the table, the link could also be made to function without scripts by requesting the sorted table from the server.
</p>

</div>

		<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
［
`文書@ ／ `文書片@
］は、［
`Document$I ／ `DocumentFragment$I
］~objの略記である。
</p>


		</section>

		<section id="the-script-element">
<h3 title="The script element">4.12.1. `script^e 要素</h3>

`23156^bug

<dl class="element-def">
	<dt>`分類$：</dt>
	<dd>
`~metadata内容$ ／ `~flow内容$ ／ `句内容$ ／ `~scriptを~supportする要素$
◎
Metadata content.
◎
Flow content.
◎
Phrasing content.
◎
Script-supporting element.
</dd>

	<dt>`この要素を利用できる文脈$：</dt>
	<dd>
`~metadata内容$が期待される所。
◎
Where metadata content is expected.
</dd>
	<dd>
`句内容$が期待される所。
◎
Where phrasing content is expected.
</dd>
	<dd>
`~scriptを~supportする要素$が期待される所。
◎
Where script-supporting elements are expected.
</dd>

	<dt>`内容~model$：</dt>
	<dd>
`src$a 属性を有さない場合、 `type$a 属性の値にも依存するが，`~script内容~制約$に合致し~MUST。
◎
If there is no src attribute, depends on the value of the type attribute, but must match script content restrictions.
</dd>
	<dd>
`src$a 属性を有する場合、要素は空にされているか, または
`~script内容~制約$にも合致するような`~script文書化$のみを包含してい~MUST。
◎
If there is a src attribute, the element must be either empty or contain only script documentation that also matches script content restrictions.
</dd>

	<dt>`text/html における~tag省略$：</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$：</dt>
	<dd>`大域~属性$
◎
Global attributes
</dd>
	<dd>`src$a
— 資源の~address
◎
src — Address of the resource
</dd>
	<dd>`type$a
— 埋込まれる資源の型
◎
type — Type of embedded resource
</dd>
	<dd>`charset$a
— 外部~script資源の文字~符号化方式
◎
charset — Character encoding of the external script resource
</dd>
	<dd>`async$a
— 可用なときは他を阻むことなく，~scriptを実行する

◎
async — Execute script when available, without blocking
</dd>
	<dd>`defer$a
— ~script実行を先送りする
◎
defer — Defer script execution
</dd>
	<dd>`crossorigin$a
— 要素が非同一生成元 要請をどう取扱うか
◎
crossorigin — How the element handles crossorigin requests
</dd>
	<dd>`nonce$a
— 
<cite>Content Security Policy</cite> 検査-に利用される暗号用~nonce
`CSP$r
◎
nonce — Cryptographic nonce used in Content Security Policy checks [CSP]
</dd>

	<dt>`~DOM~interface$：</dt>
	<dd>
<pre class="idl">
[`HTMLConstructor$]
interface `HTMLScriptElement@I : `HTMLElement$I {
  [`CEReactions$] attribute USVString `src$m;
  [`CEReactions$] attribute DOMString `type$m;
  [`CEReactions$] attribute DOMString `charset$m;
  [`CEReactions$] attribute boolean `async$m;
  [`CEReactions$] attribute boolean `defer$m;
  [`CEReactions$] attribute DOMString? `crossOrigin$m;
  [`CEReactions$] attribute DOMString `text$m;
  [`CEReactions$] attribute DOMString `nonce$m;
};
</pre>
   </dd></dl>

<p>
`script$e 要素により、作者は，文書~内に［
動的~script ／ ~data~block
］を含ませることが可能になる。
この要素は、利用者~用の内容は`表現-$しない。
◎
The script element allows authors to include dynamic script and data blocks in their documents. The element does not represent content for the user.
</p>

<p>
`type@a
属性は、表現される~script種別を~custom化できるようにする：
◎
The type attribute allows customization of the type of script represented:
</p>

<ul>
	<li>
この属性を省略した場合, または `~JS~MIME型$に設定した場合、当の~scriptは`~classic~script$であるとされ，~JSの `Script$P ~top-level生成規則に則って解釈されることになる。
~classic~scriptは、［
`charset$a, `async$a, `defer$a
］属性に影響される。
この属性に`~JS~MIME型$を与えるのは冗長であり、作者は，そうする代わりに省略するべきである。
◎
Omitting the attribute, or setting it to a JavaScript MIME type, means that the script is a classic script, to be interpreted according to the JavaScript Script top-level production. Classic scripts are affected by the charset, async, and defer attributes. Authors should omit the attribute, instead of redundantly giving a JavaScript MIME type.
</li>
	<li>
この属性~値を［
`~ASCII大小無視$で `module^l に合致する文字列
］に設定した場合、当の~scriptは`~module~script$であるとされ，~JSの `Module$P ~top-level生成規則に則って解釈されることになる。
~module~scriptには、［
`charset$a, `defer$a
］属性は影響しない。
◎
Setting the attribute to an ASCII case-insensitive match for the string "module" means that the script is a module script, to be interpreted according to the JavaScript Module top-level production. Module scripts are not affected by the charset and defer attributes.
</li>
	<li>
この属性~値を他の値に設定した場合、~scriptは
`~data~block@
であるとされ，処理されなくなる。
どの `script$e 属性も，~data~blockに効果を及ぼすことはない（ `type$a 自身は除いて）。
作者は、~data~blockを~~指示するときは，`~JS~MIME型$でない`妥当な~MIME型$を利用し~MUST。
◎
Setting the attribute to any other value means that the script is a data block, which is not processed. None of the script attributes (except type itself) have any effect on data blocks. Authors must use a valid MIME type that is not a JavaScript MIME type to denote data blocks.
</li>

</ul>

<p class="note">注記：
`~data~block$に，`妥当な~MIME型$を利用し~MUSTとする要件は、将来に起こり得る衝突を避けるためにある。
さもなければ、この仕様が，いつか `script$e に対する追加の種別を追加した場合に、それらが
— 値 `module^l が`~module~script$を~~指示するのと同様に —
何かを誘発し得ることになる。
今，妥当な~MIME型を利用しておけば、~data~blockは，将来の~UAからも何か別の~script種別に解釈し直されないことを確保できる。
◎
The requirement that data blocks must be denoted using a valid MIME type is in place to avoid potential future collisions. If this specification ever adds additional types of script, they will be triggered by setting the type attribute to something which is not a MIME type, like how the "module" value denotes module scripts. By using a valid MIME type now, you ensure that your data block will not ever be reinterpreted as a different script type, even in future user agents.
</p>

<p>
［
`~classic~script$, `~module~script$
］のいずれも、~inlineにも埋込める。
あるいは、
`src@a
属性を指定して，外部~fileから取込める。
後者の場合の `src$a 属性~値は，利用する外部~script資源の`~URL$を与える
— この値は、`前後~空白~可の妥当かつ空でない~URL$で~MUST。
［
~inline `script$e 要素や外部~script資源
］の内容は、~JS仕様 `JAVASCRIPT$r の［
`Script$P （ `~classic~script$の場合）／
`Module$P （ `~module~script$の場合）
］生成規則による要件に適合し~MUST。
◎
Classic scripts and module scripts may either be embedded inline or may be imported from an external file using the src attribute, which if specified gives the URL of the external script resource to use. If src is specified, it must be a valid non-empty URL potentially surrounded by spaces. The contents of inline script elements, or the external script resource, must conform with the requirements of the JavaScript specification's Script or Module productions, for classic scripts and module scripts respectively. [JAVASCRIPT]
</p>

<div class="p">
<p>
`script$e 要素を，`~data~block$を含ませるために利用する場合：
</p>

<ul>
	<li>
~dataは、~inlineに埋込まれてい~MUST。
</li>

	<li>
`type$a 属性を利用して，~dataの形式も与えられ~MUST。
</li>
	<li>
要素の内容は、利用される形式に定義される要件に適合してい~MUST。
</li>
	<li>
［
`src$a, `charset$a, `async$a, `defer$a, `crossorigin$a, `nonce$a
］属性は、要素に指定されては~MUST_NOT。
</li>
</ul>

◎
When used to include data blocks, the data must be embedded inline, the format of the data must be given using the type attribute, and the contents of the script element must conform to the requirements defined for the format used. The src, charset, async, defer, crossorigin, and nonce attributes must not be specified.
</div>

<div class="p">
<p>
`charset@a
属性は、外部~script資源の文字~符号化方式を与える。
この属性は、次の場合には指定されては~MUST_NOT：
</p>

<ul>
	<li>
当の要素が `src$a 属性を有さない場合。
</li>
	<li>
当の~scriptが`~classic~script$でない場合（`~module~script$は、常に UTF-8 として解釈される）。
</li>
</ul>

<p>
この属性を指定する場合、その値は，いずれかの`符号化方式~label$に`~ASCII大小無視$で合致し~MUST。
また、外部~fileの場合には，［
その `Content-Type ~metadata$ の `charset^c ~parameterと同じ`符号化方式$
］を指定し~MUST。
`ENCODING$r
</p>
◎
The charset attribute gives the character encoding of the external script resource. The attribute must not be specified if the src attribute is not present, or if the script is not a classic script. (Module scripts are always interpreted as UTF-8.) If the attribute is set, its value must be an ASCII case-insensitive match for one of the labels of an encoding, and must specify the same encoding as the charset parameter of the Content-Type metadata of the external file, if any. [ENCODING]
</div>


<p>
`async@a ／
`defer@a
属性は，`真偽~属性$であり、当の~scriptがどう評価されるべきかを指示する。
`~classic~script$に対しては，［
`defer$a ／ `async$a
］属性を指定できる。
`~module~script$に対しては， `async$a 属性を指定できる。
◎
The async and defer attributes are boolean attributes that indicate how the script should be evaluated. Classic scripts may specify defer or async; module scripts may specify async.
</p>

<p>
これらの属性を利用して，選択され得る／できる~modeには、~script種別に依存して，いくつかのものがある：
◎
There are several possible modes that can be selected using these attributes, and depending on the script's type.
</p>



<ul>
	<li>
<p>
`~classic~script$に対しては：
</p>

		<ul>
			<li>
要素が `async$a 属性を有する場合：
~scriptは，頁の構文解析と`並列的$に~fetchされ、可用になり次第，評価されることになる（構文解析が完了する前にもなり得る）。
</li>
			<li>
要素が `async$a 属性を有さないが， `defer$a 属性は有する場合：
~scriptは`並列的$に~fetchされ，頁が構文解析を終えた時点で評価される。
</li>
			<li>
要素が両~属性とも有さない場合：
~scriptは，即時に~fetchされた上で評価され、両者とも完了するまで頁の構文解析を阻むことになる。
</li>
		</ul>

◎
For classic scripts, if the async attribute is present, then the classic script will be fetched in parallel to parsing and evaluated as soon as it is available (potentially before parsing completes). If the async attribute is not present but the defer attribute is present, then the classic script will be fetched in parallel and evaluated when the page has finished parsing. If neither attribute is present, then the script is fetched and evaluated immediately, blocking parsing until these are both complete.
</li>
	<li>
<p >
`~module~script$に対しては：
</p>

		<ul>
			<li>
要素が `async$a 属性を有する場合：
~scriptとそのすべての依存物
`~scriptが取込む他の~script^tnote
は，頁の構文解析と`並列的$に~fetchされ、可用になり次第，評価されることになる（構文解析が完了する前にもなり得る）。
</li>
			<li>
他の場合：
~scriptとその依存物は，構文解析と`並列的$に~fetchされ、頁が構文解析を終えた時点で評価されることになる。
</li>
		</ul>
<p>
（ `defer$a 属性の効果は、~module~scriptには及ばない。）
</p>

◎
For module scripts, if the async attribute is present, then the module script and all its dependencies will be fetched in parallel to parsing, and the module script will be evaluated as soon as it is available (potentially before parsing completes). Otherwise, the module script and its dependencies will be fetched in parallel to parsing and evaluated when the page has finished parsing. (The defer attribute has no effect on module scripts.)
</li>
</ul>

<p>
これらすべては、次の図式に要約される：
◎
This is all summarized in the following schematic diagram:
</p>

<figure>
<img
	src="HTML-scripting/asyncdefer.svg"
	alt=""
	style="min-width:720px; min-height:220px;"
>
<figcaption style="font-size:smaller;">
単に
`&lt;script&gt;^s
と記した場合（属性なし）、構文解析は~fetchingと実行により中断される。
`&lt;script defer&gt;^s
とした場合、構文解析と並列的に~fetchされ，すべての構文解析を終えた後に実行されることになる。
`&lt;script async&gt;^s
とした場合、~fetchingは構文解析と並列的になるが，構文解析は~scriptの実行により中断される。
`&lt;script type="module"&gt;^s
とした場合、
`&lt;script defer&gt;^s
とした場合と同様になるが，依存物も~fetchされる。
`&lt;script type="module" async&gt;^s
とした場合も，依存物の~fetchingを伴うことを除いて，
`&lt;script async&gt;^s
とした場合と同様になる。
◎
With &lt;script&gt;, parsing is interrupted by fetching and execution. With &lt;script defer&gt;, fetching is parallel to parsing and execution takes place after all parsing has finished. And with &lt;script async&gt;, fetching is parallel to parsing but once it finishes parsing is interrupted to execute the script. The story for &lt;script type=&amp;quot;module&amp;quot;&gt; is similar to &lt;script defer&gt;, but the dependencies will be fetched as well, and the story for &lt;script type=&amp;quot;module&amp;quot; async&gt; is similar to &lt;script async&gt; with the extra dependency fetching.
</figcaption></figure>


<p></p>

<div class="note">
<p>注記：
これらの属性に対する正確な処理の詳細のほとんどは、歴史的~理由によるものであり、自明でない部分もある，~HTMLのいくつもの側面が孕まれている。
したがって，実装の要件は、この仕様~全体に散らばらざるを得なくなっている。
（この節の）下に示す各種~algoは，この処理の中核を述べるが、それらの~algoと，次のものとは，相互に参照し合う：
</p>

<ul><li>
［
~HTML ／
<a href="~HTML5/syntax.html#scriptForeignEndTag">foreign 内容~内</a> ／
<a href="~HTML5/xhtml.html#scriptTagXML">XML 内</a>
］における `script$e の［
<a href="~HTML5/syntax.html#scriptTag">開始tag</a> ／
<a href="~HTML5/syntax.html#scriptEndTag">終了tag</a>
］に対する各種 構文解析~規則
</li><li>`document.write()$m ~methodの規則
</li><li>`~scripting$ の取扱い
</li><li>等々
</li></ul>
◎
The exact processing details for these attributes are, for mostly historical reasons, somewhat non-trivial, involving a number of aspects of HTML. The implementation requirements are therefore by necessity scattered throughout the specification. The algorithms below (in this section) describe the core of this processing, but these algorithms reference and are referenced by the parsing rules for script start and end tags in HTML, in foreign content, and in XML, the rules for the document.write() method, the handling of scripting, etc.
</div>

<p>
`async$a 属性が指定されている下でも， `defer$a 属性が指定されて~MAY
— そうすることで、［
`defer$a は~supportするが `async$a は~supportしないような，旧来の~Web~browser
］においても、既定の他を阻む挙動に代わって， `defer$a による挙動に~fall-backするようになる。
◎
The defer attribute may be specified even if the async attribute is specified, to cause legacy Web browsers that only support defer (and not async) to fall back to the defer behavior instead of the blocking behavior that is the default.
</p>

<p>
`crossorigin@a
属性は、`~CORS設定群~属性$である。
この属性は、`~classic~script$に対しては，［
他の`生成元$から得られた~scriptによる~error情報が公開されるかどうか
］を制御し、`~module~script$に対しては，［
非同一生成元 要請に利用される`資格証~mode$
］を制御する。
◎
The crossorigin attribute is a CORS settings attribute. For classic scripts, it controls whether error information will be exposed, when the script is obtained from other origins. For module scripts, it controls the credentials mode used for cross-origin requests.
</p>

<p class="note">注記：
`~classic~script$と違って，`~module~script$では、非同一生成元への~fetchingに際し，`~CORS~protocol$の利用が要求される。
◎
Unlike classic scripts, module scripts require the use of the CORS protocol for cross-origin fetching.
</p>


<p>
`nonce@a
属性は、暗号用~nonce（ “nonce ＝ number used once”
`使い捨ての番号^tnote
）を表現する
— それは、要素により指定される~scriptを 実行するかどうかを決定するために，
<cite>Content Security Policy</cite>
から利用され得る。
値は~textである。
`CSP$r
◎
The nonce attribute represents a cryptographic nonce ("number used once") which can be used by Content Security Policy to determine whether or not the script specified by an element will be executed. The value is text. [CSP]
</p>

<p>
［
`src$a／`type$a／`charset$a／`async$a／`defer$a／`crossorigin$a／`nonce$a
］内容~属性を動的に変更しても，直接的な効果はない。
これらの属性は、下に述べる特定の時点にのみ利用される。
◎
Changing the src, type, charset, async, defer, crossorigin, and nonce attributes dynamically has no direct effect; these attributes are only used at specific times described below.
</p>



<dl class="idle-def">
	<dt>`src@m</dt>
	<dt>`type@m</dt>
	<dt>`charset@m</dt>
	<dt>`defer@m</dt>
	<dt>`nonce@m</dt>
	<dd>
これらの~IDL属性は、それぞれ，対応する同じ名前の内容~属性を`反映-$し~MUST。
◎
The IDL attributes src, type, charset, defer, and nonce, must each reflect the respective content attributes of the same name.
</dd>

	<dt>`crossOrigin@m</dt>
	<dd>
この~IDL属性は、 `crossorigin$a 内容~属性を`反映-$し~MUST。
◎
The crossOrigin IDL attribute must reflect the crossorigin content attribute.
</dd>

	<dt>`async@m</dt>
	<dd>
この~IDL属性は、要素が，非同期に実行されるかどうかを制御する。
◎
↓</dd>
	<dd>
<p>
要素の`阻まず~flag$ ~EQ ~ON の下では：
</p>
		<ul>
			<li>
被取得時には、 ~T を返さ~MUST。
</li>
			<li>
<p >
被設定時には、次を走らせ~MUST：
</p>
				<ol>
					<li>
`阻まず~flag$ ~SET ~OFF
</li>
					<li>
~IF［
所与の値 ~EQ ~F
］
⇒
`async$a 内容~属性を除去する
</li>
					<li>
~ELSE
⇒
`async$a 内容~属性の値 ~SET 空~文字列
</li>
				</ol>
			</li>
		</ul>
<p >
要素の`阻まず~flag$ ~EQ ~OFF
の下では、この属性は， `async$a 内容~属性を`反映-$し~MUST。
</p>

◎
The async IDL attribute controls whether the element will execute asynchronously or not. If the element's "non-blocking" flag is set, then, on getting, the async IDL attribute must return true, and on setting, the "non-blocking" flag must first be unset, and then the content attribute must be removed if the IDL attribute's new value is false, and must be set to the empty string if the IDL attribute's new value is true. If the element's "non-blocking" flag is not set, the IDL attribute must reflect the async content attribute.
</dd>

</dl>



<dl class="domintro">

	<dt>%script . `text$m [ = %value ]</dt>
	<dd>
要素の`子~text内容$を返す。
◎
Returns the child text content of the element.
</dd>
	<dd>
設定して，要素の子たちを所与の値に置換できる。
◎
Can be set, to replace the element's children with the given value.
</dd>

</dl>


<dl class="idl-def">
	<dt>`text@m</dt>
	<dd>
この~IDL属性の被取得時には、この `script$e 要素の`子~text内容$を返さ~MUST。
被設定時には、 `textContent$m ~IDL属性と同じ仕方で動作し~MUST。
◎
The IDL attribute text must return the child text content of the script element. On setting, it must act the same way as the textContent IDL attribute.
</dd>

</dl>


<p class="note">注記：
`document.write()$m ~methodを利用して
挿入された `script$e 要素は，実行されるが（概して，その間は、更なる~script実行や~HTML構文解析は，阻まれる）、［
`innerHTML$m ／ `outerHTML$m
］属性を利用して挿入されたものは、全く実行されない。
◎
When inserted using the document.write() method, script elements execute (typically blocking further script execution or HTML parsing), but when inserted using innerHTML and outerHTML attributes, they do not execute at all.
</p>

<div class="example">

<p>
次の例には、 2 個の `script$e 要素
— 外部`~classic~script$を埋込むもの, および
`~data~block$として何らかの~dataを含むもの —
が利用されている。
◎
In this example, two script elements are used. One embeds an external classic script, and the other includes some data as a data block.
</p>

<pre>
&lt;script src="game-engine.js"&gt;&lt;/script&gt;
&lt;script type="text/x-game-map"&gt;
........U.........e
o............A....e
.....A.....AAA....e
.A..AAA...AAAAA...e
&lt;/script&gt;
</pre>

<p>
この事例における~dataは、その~scriptにより，~video~gameの~mapを生成するために利用されているであろう
— が、この仕方で利用する必要があるわけではない：
実際の~map~dataは頁の他所に埋込まれていて、この~data~blockは，単に利用者が ~game~mapの特定0の特色機能を探し易くするためとして，~siteの検索engine向けに~~用意されたものかもしれない。
◎
The data in this case might be used by the script to generate the map of a video game. The data doesn't have to be used that way, though; maybe the map data is actually embedded in other parts of the page's markup, and the data block here is just used by the site's search engine to help users who are looking for particular features in their game maps.
</p>

</div>

<div class="example">

<p>
次の見本に、 `script$e 要素を利用して、文書の他所から利用される関数を `~classic~script$の一部として定義する方法を示す。
同時に，別の `script$e 要素を利用して、文書が構文解析されている間に~scriptを呼出す方法も示す
— この事例では、~formの出力を初期化する。
◎
The following sample shows how a script element can be used to define a function that is then used by other parts of the document, as part of a classic script. It also shows how a script element can be used to invoke script while the document is being parsed, in this case to initialize the form's output.
</p>

<pre>
&lt;script&gt;
 function calculate(%form) {
   var %price = 832000;
   if (%form.elements.brakes.checked)
     %price += 160000;
   if (%form.elements.radio.checked)
     %price += 400000;
   if (%form.elements.turbo.checked)
     %price += 800000;
   if (%form.elements.sticker.checked)
     %price += 40000;
   %form.elements.result.value = %price;
 }
&lt;/script&gt;
&lt;form
   name="pricecalc"
   onsubmit="return false"
   onchange="calculate(this)"
&gt;
 &lt;fieldset&gt;
  &lt;legend&gt;車体価格を再計算する&lt;/legend&gt;
  &lt;p&gt;基本価格：83 万 2000 円&lt;/p&gt;
  &lt;p&gt;~~追加オプション：&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;&lt;label&gt;&lt;input type=checkbox name=brakes&gt;
      セラミックブレーキ（ 16 万円）&lt;/label&gt;&lt;/li&gt;
   &lt;li&gt;&lt;label&gt;&lt;input type=checkbox name=radio&gt;
      衛星ラジオ（ 40 万円）&lt;/label&gt;&lt;/li&gt;
   &lt;li&gt;&lt;label&gt;&lt;input type=checkbox name=turbo&gt;
      ターボチャージャー（ 80 万円）&lt;/label&gt;&lt;/li&gt;
   &lt;li&gt;&lt;label&gt;&lt;input type=checkbox name=sticker&gt;
      "XZ" ステッカー（ 4 万円）&lt;/label&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;p&gt;合計価格： &lt;output name=result&gt;&lt;/output&gt; 円&lt;/p&gt;
 &lt;/fieldset&gt;
 &lt;script&gt;
  calculate(document.forms.pricecalc);
 &lt;/script&gt;
&lt;/form&gt;
</pre>

</div>



<div id="script-type-module-example-1" class="example">

<p>
次の見本では、 `script$e 要素を利用して，外部`~module~script$を含ませる方法を示す。
◎
The following sample shows how a script element can be used to include an external module script.
</p>


<pre>
&lt;script type="module" src="app.js"&gt;&lt;/script&gt;
</pre>

<p>
この~module, およびそのすべての依存物（~source~file内の ~JS `import^c 文を通して表される）は、~fetchされることになる。
結果の~module木~全体が取込まれ，文書が構文解析を終えたなら、
`app.js^s の内容は評価されることになる。
◎
This module, and all its dependencies (expressed through JavaScript import statements in the source file), will be fetched. Once the entire resulting module tree has been imported, and the document has finished parsing, the contents of app.js will be evaluated.
</p>

<p>
加えて，同じ `Window$I 内の別の `script$e 要素からの~codeが
`app.js^s からの~moduleを取込む場合（例： `import "./app.js";^s を介して）、前者の `script$e 要素により作成された同じ`~module~script$が取込まれることになる。
◎
Additionally, if code from another script element in the same Window imports the module from app.js (e.g. via import "./app.js";), then the same module script created by the former script element will be imported.
</p>

</div>

<div id="script-type-module-example-2" class="example">

<p>
次の見本に、`script$e 要素を利用して、（例えば，ニュースサイト上の）文書~内のいくつかの~textを置換えて，けったいな読み物に変えてしまうような，~inline `~module~script$を書く方法を示す：
`XKCD1288$r
◎
The following sample shows how a script element can be used to write an inline module script that performs a number of substitutions on the document's text, in order to make for a more interesting reading experience (e.g. on a news site): [XKCD1288]
</p>

<pre>
&lt;script type="module"&gt;
 import { walkAllTextNodeDescendants } from "./dom-utils.js";

 const %substitutions = new Map([
   ["witnesses", "these dudes I know"]
   ["allegedly", "kinda probably"]
   ["new study", "Tumblr post"]
   ["rebuild", "avenge"]
   ["space", "spaaace"]
   ["Google glass", "Virtual Boy"]
   ["smartphone", "Pokédex"]
   ["electric", "atomic"]
   ["Senator", "Elf-Lord"]
   ["car", "cat"]
   ["election", "eating contest"]
   ["Congressional leaders", "river spirits"]
   ["homeland security", "Homestar Runner"]
   ["could not be reached for comment", "is guilty and everyone knows it"]
 ]);

 function substitute(%textNode) {
   for (const [%before, %after] of %substitutions.entries()) {
     %textNode.data = %textNode.data.replace(
       new RegExp(~RXPbefore, "ig"), %after
     );
   }
 }

 walkAllTextNodeDescendants(document.body, %substitute);
&lt;/script&gt;
</pre>


<div class="p">
<p>
~module~scriptを利用して得られる特色機能のうち，注目すべきものには、次が挙げられる：
</p>

<ul>
	<li>
他の~JS~moduleから関数を取込む能。
</li>
	<li>
既定で~strict~modeになる。
</li>
	<li>
~top-level宣言が`大域~obj$上に新たな~propを導入しない how `？^tnote。
</li>
</ul>

<p>
また、この `script$e 要素が文書~内のどこに現れようが、それは，文書~構文解析が完了して，なおかつ その依存物（ここでは `dom-utils.js^s ）が~fetchされ，評価されるまでは、評価されないことに注意。
</p>

◎
Some notable features gained by using a module script include the ability to import functions from other JavaScript modules, strict mode by default, and how top-level declarations do not introduce new properties onto the global object. Also note that no matter where this script element appears in the document, it will not be evaluated until both document parsing has complete and its dependency (dom-utils.js) has been fetched and evaluated.
</div>


</div>






			<section id="script-processing-model">
<h4 title="Processing model">4.12.1.1. 処理~model</h4>

<p>
`script$e 要素には、その各種 状態を~~保持するものとして，次に挙げるものが結付けられる
— 初期~時には、それぞれ，括弧内に示される値にされ~MUST：
◎
A script element has several associated pieces of state.
</p>

<dl>

	<dt>`開始済み~flag@ （ ~OFF ）</dt>
	<dd>
この~flagは、~script~blockの実行は，すでに開始されたかどうかを指示する。
（~script~blockの作成-時には “開始済み” でない）。
［
`script$e 要素に対する`~clone時の手続き$から得られる複製
］の`開始済み~flag$は、~clone元の要素のそれを引き継が~MUST。
◎
The first is a flag indicating whether or not the script block has been "already started". Initially, script elements must have this flag unset (script blocks, when created, are not "already started"). The cloning steps for script elements must set the "already started" flag on the copy if it is set on the element being cloned.
</dd>

	<dt>`解析器挿入~flag@ （ ~OFF ）</dt>
	<dd>
この~flagは、［
要素は，構文解析器により挿入されたものである
］かどうかを指示する。
この~flagは、［
`~HTML構文解析器$ ／ `~XML構文解析器$
］が挿入する `script$e 要素に対しては ~ON にされ，そのような要素の処理に影響する。
◎
The second is a flag indicating whether the element was "parser-inserted". Initially, script elements must have this flag unset. It is set by the HTML parser and the XML parser on script elements they insert and affects the processing of those elements.
</dd>

	<dt>`阻まず~flag@ （ ~ON ）</dt>
	<dd>
この~flagは、要素が， “互いに他を阻まない” ようになるかどうかを指示する。
［
`~HTML構文解析器$ ／ `~XML構文解析器$
］は、自身が挿入する `script$e 要素に対し，この~flagを ~OFF にする。
加えて、この~flagが ~ON にされた `script$e 要素に
`async$a 内容~属性が追加されたときは、その要素の`阻まず~flag$も~OFFにされ~MUST。
◎
The third is a flag indicating whether the element will be "non-blocking". Initially, script elements must have this flag set. It is unset by the HTML parser and the XML parser on script elements they insert. In addition, whenever a script element whose "non-blocking" flag is set has an async content attribute added, the element's "non-blocking" flag must be unset.
</dd>
	<dd class="trans-note">【
“阻まず（ non-blocking ）”
何が何を阻まないかが，多義的で、曖昧な用語でもある。
{ 当の~scriptの~fetching, 当の~scriptの実行ing } と
{ 頁の構文解析, 他の資源の~fetching, 他の~scriptの実行ing }
との間で種々の組み合わせが考えられる。
】</dd>


	<dt>`解析器実行準備済み~flag@ （ ~OFF ）</dt>
	<dd>
この~flagは、［
構文解析器により，~script~blockを実行する用意が整った
］かどうかを指示する。
（~script~blockの作成-時には、 “実行する用意は整って” いない）。
この~flagは，構文解析器が当の~scriptをいつ実行するか知れるようにするためにあり、［
`解析器挿入~flag$ ~EQ ~ON
］でもあるような要素に対してのみ，利用される。
◎
The fourth is a flag indicating whether or not the script block is "ready to be parser-executed". Initially, script elements must have this flag unset (script blocks, when created, are not "ready to be parser-executed"). This flag is used only for elements that are also "parser-inserted", to let the parser know when to execute the script.
</dd>

	<dt>`~script種別@</dt>
	<dd>
`classic^l ／ `module^l
のいずれか。
これは、`~scriptを準備する$ときに，要素の `type$a 属性に基づいて決定される。
◎
The fifth is the script's type, which is either "classic" or "module". It is determined when the script is prepared, based on the type attribute of the element at that time.
</dd>

	<dt>`外部~file~flag@</dt>
	<dd>
この~flagは、~scriptが外部~fileからのものかどうかを指示する。
この~flagは、`~scriptを準備する$ときに，要素の `src$a 属性に基づいて決定される。
◎
The sixth is a flag indicating whether or not the script is from an external file. It is determined when the script is prepared, based on the src attribute of the element at that time.
</dd>

	<dt>`~script@</dt>
	<dd>
`script$e 要素を`準備-$した結果の`~script$x。
これは、［
`~classic~script$／~module木
］が非同期に~fetchされた後に，それが［
成功した場合は `~script$x ／
失敗した場合は ~NULL
］に設定される。
その時点で、 `script^e は，~fetching~algoにより
`準備済み@
にされ、他の動作を誘発し得ることになる。
~UAは、 `script^e 要素が`準備済み$になるまで，その`~node文書$の`~load~eventを遅延-$し~MUST。
◎
Finally, a script element has the script's script, which is a script resulting from preparing the element. This is set asynchronously after the classic script or module tree is fetched. Once it is set, either to a script in the case of success or to null in the case of failure, the fetching algorithms will note that the script is ready, which can trigger other actions. The user agent must delay the load event of the element's node document until the script is ready.
</dd>
	<dd class="trans-note">【
原文では “script's script”
（ ~scriptの~script （おそらく， “`script$e 要素の`~script$x” の意）として定義されているが、和訳の都合により，ここでは単に “〜の~script” と表記する（常に， “〜の” が付与される）。
】</dd>

</dl>


<hr>

<p>
［
`解析器挿入~flag$ ~EQ ~OFF
］なる `script$e 要素 %S に対しては、次に挙げるいずれかが生じたときは，~UAは `即時$に %S を`準備-$し~MUST：
◎
When a script element that is not marked as being "parser-inserted" experiences one of the events listed in the following list, the user agent must immediately prepare the script element:
</p>

<ul>
	<li>
%S が`接続され$た時点。
◎
The script element becomes connected.
</li>
	<li>
%S は`接続済み$である下で、
%S の中に，何らかの~nodeか`文書片$が`挿入され$nodeた時点。
ただし，他の `script$e 要素が同時に`挿入され$nodeた場合は、それらより後の時点とする。
◎
The script element is connected and a node or document fragment is inserted into the script element, after any script elements inserted at that time.
</li>
	<li>
%S は`接続済み$である, かつ
%S は `src$a 属性を有していない下で、その属性が %S 上に設定された時点。
◎
The script element is connected and has a src attribute set where previously the element had no such attribute.
</li>

</ul>

<!--%準備 -->

<p class="algo-head">
`~scriptを準備する@
ときは、~UAは次に従って動作し~MUST：
◎
To prepare a script, the user agent must act as follows:
</p>

<ol>
	<li>
<p>
各種 変数：
</p>
		<ol>
			<li>
%S ~LET 当の `script$e 要素
</li>
			<li>
%文書 ~LET %S の`~node文書$
</li>
			<li>
`async@V ~LET ［
%S は `async$a 属性を有するならば ~T ／
~ELSE_ ~F
］
</li>
			<li>
`src@V ~LET ［
%S は `src$a 属性を有するならば その値 ／
~ELSE_ ε
］
</li>
		</ol>
	</li>


	<li>
~IF［
%S の`開始済み~flag$ ~SET ~ON
］
⇒
~RET
— ~scriptは実行されない
◎
If the script element is marked as having "already started", then abort these steps at this point. The script is not executed.
</li>
	<li>
`構文解析器により挿入された^V ~LET ~F
◎
↓</li>
	<li>
<div class="p">
<p>
~IF［
%S の`解析器挿入~flag$ ~EQ ~ON
］：
</p>
		<ol>
			<li>
`構文解析器により挿入された^V ~SET ~T
</li>
			<li>
%S の`解析器挿入~flag$ ~SET ~OFF
</li>
		</ol>

◎
If the element has its "parser-inserted" flag set, then set was-parser-inserted to true and unset the element's "parser-inserted" flag. Otherwise, set was-parser-inserted to false.
</div>

<p class="note">注記：
この段は、［
構文解析器が［
`解析器挿入~flag$が ~ON にされている `script$e 要素
］を走らせようと試行して失敗した場合（例： 空あるいは, 未~supportの~scripting言語を指定していた）
］に，後で［
別の~scriptがそれを変異させて再度~走らす
］ことを可能にするために行われる。
◎
This is done so that if parser-inserted script elements fail to run when the parser tries to run them, e.g. because they are empty or specify an unsupported scripting language, another script can later mutate them and cause them to run again.
</p>
	</li>
	<li>
<p>
~IF［
`構文解析器により挿入された^V ~EQ ~T
］~AND［
`async$V ~EQ ~F
］
⇒
%S の`阻まず~flag$ ~SET ~ON
◎
If was-parser-inserted is true and the element does not have an async attribute, then set the element's "non-blocking" flag to true.
</p>

<p class="note">注記：
この段は、［
構文解析器が［
`解析器挿入~flag$が ~ON にされている `script$e 要素
］を走らせようと試行して失敗したが、他の~scriptが動的にそれを更新した後に，後で実行された場合
］に、［
`async$a 属性が設定されていなくとも，
“互いに他を阻まない”
ように実行されるようにする
］ために行われる。
◎
This is done so that if a parser-inserted script element fails to run when the parser tries to run it, but it is later executed after a script dynamically updates it, it will execute in a non-blocking fashion even if the async attribute isn't set.
</p>

   </li>
	<li id="script-processing-empty">
~IF［
`src$V ~EQ ε
］~AND［
%S の どの子~nodeも［
~comment~nodeか 空 `Text$I ~node
］である
］
⇒
~RET
— ~scriptは実行されない
◎
If the element has no src attribute, and its child nodes, if any, consist only of comment nodes and empty Text nodes, then abort these steps at this point. The script is not executed.
</li>
	<li>
~IF［
%S は `接続済み$でない
］
⇒
~RET
— ~scriptは実行されない
◎
If the element is not connected, then abort these steps. The script is not executed.
</li>
	<li id="script-processing-prepare">

<p>
以下に従って， %S に対する
%~script~block型~文字列 を決定する：
◎
↓</p>
		<ol>
			<li>
%種別 ~LET ［
%S は `type$a 属性を有するならば その値 ／
~ELSE_ ε
］
</li>
			<li>
%言語 ~LET ［
%S は `language$a 属性を有するならば その値 ／
~ELSE_ ε
］
</li>
			<li>
~IF［
%種別 ~EQ 空~文字列
］~OR［［
%種別 ~EQ ε
］~AND［
%言語 ~IN { ε, 空~文字列 }
］］
⇒
%~script~block型~文字列 ~SET `text/javascript^l
◎
If either:
◎
the script element has a type attribute and its value is the empty string, or
◎
the script element has no type attribute but it has a language attribute and that attribute's value is the empty string, or
◎
the script element has neither a type attribute nor a language attribute, then
◎
...let the script block's type string for this script element be "text/javascript".
</li>
			<li>
~ELIF［
%種別 ~NEQ ε
］
⇒
%~script~block型~文字列 ~SET
%種別 から 頭部／尾部の`空白類$並びを除去した結果
◎
Otherwise, if the script element has a type attribute, let the script block's type string for this script element be the value of that attribute with any leading or trailing sequences of space characters removed.
</li>
			<li>
<p>
~ELSE（ %言語 ~NIN { 空~文字列, ε } ）
⇒
%~script~block型~文字列 ~SET ［
`text/^l, %言語
］を連結した結果
◎
Otherwise, the element has a non-empty language attribute; let the script block's type string for this script element be the concatenation of the string "text/" followed by the value of the language attribute.
</p>

<p class="note">注記：
`language$a 属性は、決して適合せず，
`type$a 属性が在るときは常に無視される。
◎
The language attribute is never conforming, and is always ignored if there is a type attribute present.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
以下に従って`~script種別$を決定する：
◎
Determine the script's type as follows:
</p>

		<ol>
			<li>
%~script~block型~文字列 ~SET %~script~block型~文字列 を`~ASCII小文字~化$した結果
</li>
			<li>
~IF［
%~script~block型~文字列 ~IN `~JS~MIME型$
］
⇒
%S の`~script種別$ ~SET `classic^l
◎
If the script block's type string is an ASCII case-insensitive match for any JavaScript MIME type, the script's type is "classic".
</li>
			<li>
~ELIF［
%~script~block型~文字列 ~EQ 文字列 `module^l
］
⇒
%S の`~script種別$ ~SET `module^l
◎
If the script block's type string is an ASCII case-insensitive match for the string "module", the script's type is "module".
</li>
	<li>
~ELSE
⇒
~RET
— 実行される~scriptはない
◎
If neither of the above conditions are true, then abort these steps at this point. No script is executed.
</li>

		</ol>
	</li>
	<li>
<p>
~IF［
`構文解析器により挿入された^V ~EQ ~T
］
⇒
%S の`解析器挿入~flag$ ~SET ~ON；<br>
%S の`阻まず~flag$ ~SET ~OFF
◎
If was-parser-inserted is true, then flag the element as "parser-inserted" again, and set the element's "non-blocking" flag to false.
</p>

   </li>
	<li id="script-processing-start">
要素の`開始済み~flag$ ~SET ~ON
◎
Set the element's "already started" flag.
</li>
	<li>
%構文解析器 ~LET %S を作成した構文解析器
◎
↓</li>
	<li>
%解析器~文書 ~LET %構文解析器 の`文書$
◎
↓</li>
	<li>
<p>
~IF［
%S の`解析器挿入~flag$ ~EQ ~ON
］~AND［
%文書 ~NEQ %解析器~文書
］
⇒
~RET
◎
If the element is flagged as "parser-inserted", but the element's node document is not the Document of the parser that created the element, then abort these steps.
</p></li>
	<li id="script-processing-noscript">
<p>
~IF［
%S に対する`~scriptingは不能化され$ている
］
⇒
~RET
— ~scriptは実行されない
◎
If scripting is disabled for the script element, then abort these steps at this point. The script is not executed.
</p>

<div class="note">

<p>注記：
`~scriptingは不能化され$ている，の定義により、次に該当する~scriptは，実行されない：
</p>

<ul>
	<li>
`XMLHttpRequest$I の `responseXML$m 文書~内の~script。
`XHR$r
</li>
	<li>
`DOMParser$I が作成した文書~内の~script。
`DOMPARSING$r
</li>
	<li>
`XSLTProcessor$I の `transformToDocument()$m 特色機能により作成された文書~内の~script。
`XSLTP$r
</li>
	<li>
［
`createDocument()$m ~APIを利用して作成された`文書$
］の中に，ある~scriptにより先ず挿入された~script。
`DOM$r
<!-- ＊先ず -->
</li>
</ul>

◎
The definition of scripting is disabled means that, amongst others, the following scripts will not execute: scripts in XMLHttpRequest's responseXML documents, scripts in DOMParser-created documents, scripts in documents created by XSLTProcessor's transformToDocument feature, and scripts that are first inserted by a script into a Document that was created using the createDocument() API. [XHR] [DOMPARSING] [XSLTP] [DOM]
</div>

	</li>

	<li id="script-processing-csp">
~IF［
`src$V ~EQ ε
］
⇒
~IF［
( %S , `script^l , %S の`子~text内容$ )
を与える下で，
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$
`CSP$r
を実行した結果 ~EQ `阻止ed^i
］
⇒
~RET
— ~scriptは実行されない
◎
If the script element does not have a src content attribute, and the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the script element, "script", and the script element's child text content, then abort these steps. The script is not executed. [CSP]
</li>
	<li id="script-processing-for">

<p>
~IF［
%S は `event$a 属性を有する
］~AND［
%S は `for$a 属性を有する
］~AND［
%S の`~script種別$ ~EQ `classic^l
］：
◎
If the script element has an event attribute and a for attribute, and the script's type is "classic", then run these substeps:
</p>

		<ol>
			<li>
( %for, %event ) ~LET 順に %S の
( `for$a, `event$a )
属性の値から`頭部と尾部の空白を剥いだ$結果を`~ASCII小文字~化$した結果
◎
Let for be the value of the for attribute.
◎
Let event be the value of the event attribute.
◎
Strip leading and trailing whitespace from event and for.
</li>
			<li>
~IF［
%for ~NEQ `window^l
］
⇒
~RET
— ~scriptは実行されない
◎
If for is not an ASCII case-insensitive match for the string "window", then abort these steps at this point. The script is not executed.
</li>
			<li>
~IF［
%event ~NIN { `onload^l, `onload()^l }
］
⇒
~RET
— ~scriptは実行されない
◎
If event is not an ASCII case-insensitive match for either the string "onload" or the string "onload()", then abort these steps at this point. The script is not executed.
</li>
		</ol>
	</li>
	<li id="script-processing-encoding">
<p>
%符号化方式 ~LET ［［
%S は `charset$a 属性を有していて，その値 から`符号化方式を取得-$した結果 ~NEQ `failure^i
］ならば その結果 ／
~ELSE_ %文書 の`符号化方式$doc
］
◎
If the script element has a charset attribute, then let encoding be the result of getting an encoding from the value of the charset attribute.
◎
If the script element does not have a charset attribute, or if getting an encoding failed, let encoding be the same as the encoding of the script element's node document.
</p>

<p class="note">注記：
［
%S の`~script種別$ ~EQ `module^l
］の場合、この符号化方式は無視されることになる。
◎
If the script's type is "module", this encoding will be ignored.
</p>
	</li>
	<li>
%~CORS設定 ~LET 
%S の `crossorigin$a 内容~属性の現在の状態
◎
Let CORS setting be the current state of the element's crossorigin content attribute.
</li>
	<li>
%~module~script資格証~mode ~LET %~CORS設定 に応じて［
`No CORS$st ならば `omit^l ／
`Anonymous$st ならば `same-origin^l ／
`Use Credentials$st ならば `include^l
］
◎
Let module script credentials mode be determined by switching on CORS setting:
◎
No CORS
◎
• "omit"
◎
Anonymous
◎
• "same-origin"
◎
Use Credentials
◎
• "include"
</li>
	<li>
%暗号用~nonce ~LET ［
%S は `nonce$a 属性を有するならば その値 ／
~ELSE_ 空~文字列
］
◎
If the script element has a nonce attribute, then let cryptographic nonce be that attribute's value.
◎
Otherwise, let cryptographic nonce be the empty string.
</li>
	<li>
%構文解析器~状態 ~LET 
%S の`解析器挿入~flag$に応じて［
~ON ならば `parser-inserted^l ／
~OFF ならば `not parser-inserted^l
］
◎
Let parser state be "parser-inserted" if the script element has been flagged as "parser-inserted", and "not parser-inserted" otherwise.
</li>
	<li>
%設定群 ~LET 
%文書 の `Window$I ~objの`環境~設定群~obj$
◎
Let settings be the element's node document's Window object's environment settings object.
</li>
	<li id="script-processing-src-prepare">
<p>
~IF［
`src$V ~NEQ ε
］：
◎
If the element has a src content attribute, run these substeps:
</p>
		<ol>
			<li>
<p>
~IF［
`src$V ~EQ 空~文字列
］：
</p>
				<ol>
					<li>
次を走らす`~taskを待入する$
⇒
%S に向けて，名前 `error$et の`単純~eventを発火する$
</li>
					<li>
~RET
</li>
				</ol>

◎
Let src be the value of the element's src attribute.
◎
If src is the empty string, queue a task to fire a simple event named error at the element, and abort these steps.
</li>
			<li>
%S の`外部~file~flag$ ~SET ~ON
◎
Set the element's from an external file flag.
</li>
			<li>
%~url ~LET 
`src$V を %文書 に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse src relative to the element's node document.
</li>
			<li>
~IF［
%~url ~EQ ~error
］：
				<ol>
					<li>
次を走らす`~taskを待入する$
⇒
%S に向けて，名前 `error$et の`単純~eventを発火する$
</li>
					<li>
~RET
</li>
				</ol>
◎
If the previous step failed, queue a task to fire a simple event named error at the element, and abort these steps. Otherwise, let url be the resulting URL record.
</li>
			<li>
<p>
%S の`~script種別$に応じて：
◎
Switch on the script's type:
</p>

				<dl class="switch">
					<dt>`classic^l</dt>
					<dd>
次を与える下で
`~classic~scriptを~fetchする$
⇒
(
%~url,
%設定群,
%暗号用~nonce,
%構文解析器~状態,
%~CORS設定,
%符号化方式
)
◎
Fetch a classic script given url, settings, cryptographic nonce, parser state, CORS setting, and encoding.
</dd>

					<dt>`module^l</dt>
					<dd>
次を与える下で，`~module~script木を~fetchする$
⇒
(
%~url,
%設定群,
`script^l,
%暗号用~nonce,
%構文解析器~状態,
%~module~script資格証~mode
)
◎
Fetch a module script tree given url, settings, "script", cryptographic nonce, parser state, and module script credentials mode.
</dd>
			</dl>

<div class="p">
<p>
~fetchする~algoが`非同期に完了した$ときは：
</p>

<ol ><li>%S の`~script$ ~SET その結果
</li><li>%S を`準備済み$にする
</li></ol>
◎
When the chosen algorithm asynchronously completes, set the script's script to the result. At that time, the script is ready.
</div>

<div class="p">
<p>
処理能~上の理由から、~UAは，
%S の `src$a 属性が設定され次第，すぐに（上に定義されるように）［
~classic~script／~module木
］の~fetchingを開始して~MAY
— ~~実際に %S が文書の中に挿入される（かつ，それまでは
%S の `crossorigin$a 属性の値は変更されない）のを待つことなく。
いずれにせよ，
%S が`文書の中に挿入され$たなら、この段に述べたように，読込みは開始され~MUST。
~UAが そのような事前~fetchingを遂行する下で，次のいずれかに該当する場合…：
</p>

<ul>
	<li>
%S は、~~実際には，文書~内に挿入されなかった
</li>
	<li>
%S は，文書~内に挿入されたが，それまでに %S の［
`src$a ／ `crossorigin$a
］属性が動的に変更された
</li>
</ul>

<p>
…場合、~UAは，そのように得られた~scriptを実行しないとする
— ~fetchする処理-は、実質的に浪費されることになる。
</p>

◎
For performance reasons, user agents may start fetching the classic script or module tree (as defined above) as soon as the src attribute is set, instead, in the hope that the element will be inserted into the document (and that the crossorigin attribute won't change value in the meantime). Either way, once the element is inserted into the document, the load must have started as described in this step. If the UA performs such prefetching, but the element is never inserted in the document, or the src attribute is dynamically changed, or the crossorigin attribute is dynamically changed, then the user agent will not execute the script so obtained, and the fetching process will have been effectively wasted.
</div>

			</li>
		</ol>
	</li>
	<li id="establish-script-block-source">
<p>
~ELSE （ `src$V ~EQ ε ）：
◎
If the element does not have a src content attribute, run these substeps:
</p>

		<ol>
			<li>
%~source~text ~LET %S の `text$m ~IDL属性~値
◎
Let source text be the value of the text IDL attribute.
</li>
	<li>
<p>
%S の`~script種別$に応じて：
◎
Switch on the script's type:
</p>

				<dl class="switch">

					<dt>`classic^l</dt>
					<dd>
						<ol>
							<li>
%S の`~script$ ~SET
次を与える下で，`~classic~scriptを作成-$した結果
⇒
( %~source~text, %設定群 )
◎
Let script be the result of creating a classic script using source text and settings.
◎
Set the script's script to script.
</li>
							<li>
%S を`準備済み$にする
◎
The script is ready.
</li>
						</ol>
					</dd>

					<dt>`module^l</dt>
					<dd>
						<ol>
							<li>
%~script ~LET
次を与える下で，`~module~scriptを作成-$した結果
⇒
(
%~source~text,
%設定群,
%文書 の`文書~基底~URL$,
%暗号用~nonce,
%構文解析器~状態,
%~module~script資格証~mode
)
◎
Let base URL be the script element's node document's document base URL.
◎
Let script be the result of creating a module script using source text, settings, base URL, cryptographic nonce, parser state, and module script credentials mode.
</li>
							<li>
<p>
~IF［
%~script ~EQ ~NULL
］：
</p>

<ol><li>%S の`~script$ ~SET ~NULL
</li><li>%S を`準備済み$にする
</li><li>~RET
</li></ol>

◎
If this returns null, set the script's script to null and abort these substeps; the script is ready.
</li>
							<li>
<p>
次を与える下で， %~script の`子孫を~fetchする$
⇒
( `script^l†, 空~list )

<span class="trans-note">【†
`script^l は、訳者による補完。
】</span>
</p>

<p>
これが`非同期に完了した$ときは：
</p>

<ol><li>%S の`~script$ ~SET その結果
</li><li>%S を`準備済み$にする
</li></ol>

◎
Fetch the descendants of script (using an empty ancestor list). When this asynchronously completes, set the script's script to the result. At that time, the script is ready.
</li>
						</ol>
					</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
%defer ~LET ［
%S は `defer$a 属性を有するならば ~T ／
~ELSE_ ~F
］
◎
↓</li>
	<li>
<p>
次の表において， %S が満たす各種条件に応じて、下において［
表の “ふるまい” 列（右端列）に与えられる~label
］が付与された段に従う：
◎
Then, follow the first of the following options that describes the situation:
</p>

<table>
<thead><tr><th>`~script種別$
</th><th>`src$V
</th><th>`async$V
</th><th>`解析器挿入~flag$
</th><th>`阻まず~flag$
</th><th>%defer
</th><th>ふるまい
</th></tr></thead>

<tbody><tr><td>`classic^l
</td><td>非 ε
</td><td>~F
</td><td>~ON
</td><td>任意
</td><td>~T
</td><td id="script-processing-defer">A0

</td></tr><tr><td>`classic^l
</td><td>非 ε
</td><td>~F
</td><td>~ON
</td><td>任意
</td><td>~F
</td><td id="script-processing-parser-inserted">A1

</td></tr><tr><td>`classic^l
</td><td>非 ε
</td><td>~F
</td><td>~OFF
</td><td>~OFF
</td><td>任意
</td><td id="script-processing-src-sync">A2

</td></tr><tr><td>`classic^l
</td><td>非 ε
</td><td>~F
</td><td>~OFF
</td><td>~ON
</td><td>任意
</td><td rowspan="2" id="script-processing-src">A3

</td></tr><tr><td>`classic^l
</td><td>非 ε
</td><td>~T
</td><td>任意
</td><td>任意
</td><td>任意

</td></tr><tr><td>`classic^l
</td><td>ε
</td><td>任意
</td><td>~ON
</td><td>任意
</td><td>任意
</td><td>A4

</td></tr><tr><td>`classic^l
</td><td>ε
</td><td>任意
</td><td>~OFF
</td><td>任意
</td><td>任意
</td><td>A5

</td></tr><tr><td>`module^l
</td><td>任意
</td><td>~F
</td><td>~ON
</td><td>任意
</td><td>任意
</td><td id="script-processing-module-noasync-parser-inserted">A0

</td></tr><tr><td>`module^l
</td><td>任意
</td><td>~F
</td><td>~OFF
</td><td>~OFF
</td><td>任意
</td><td id="script-processing-module-noasync">A2

</td></tr><tr><td>`module^l
</td><td>任意
</td><td>~F
</td><td>~OFF
</td><td>~ON
</td><td>任意
</td><td rowspan="2" id="script-processing-module-async">A3

</td></tr><tr><td>`module^l
</td><td>任意
</td><td>~T
</td><td>任意
</td><td>任意
</td><td>任意

</td></tr></tbody></table>

<p class="trans-note">【
原文の条件記述が煩雑なので、この和訳では，表の形に整理している。
】</p>


		<dl class="switch">
			<dt>A0
<!-- 
id="script-processing-defer"
id="script-processing-module-noasync-parser-inserted"
-->
◎
If the script's type is "classic", and the element has a src attribute, and the element has a defer attribute, and the element has been flagged as "parser-inserted", and the element does not have an async attribute
◎
If the script's type is "module", and the element has been flagged as "parser-inserted", and the element does not have an async attribute
</dt>
			<dd>
%解析器~文書 に結付けられている
`文書を構文解析し終えたときに実行される~scriptの~list@
の末尾に %S を追加する
◎
Add the element to the end of the list of scripts that will execute when the document has finished parsing associated with the Document of the parser that created the element.
</dd>
			<dd>
</dd>
			<dd>
<p>
%S が`準備済み$になったときは
⇒
%S の`解析器実行準備済み~flag$ ~SET ~ON
— %構文解析器 が，この~scriptの実行ingを取扱うことになる。
◎
When the script is ready, set the element's "ready to be parser-executed" flag. The parser will handle executing the script.
</dd>
			<dt>A1
<!-- id="script-processing-parser-inserted" -->
◎
If the script's type is "classic", and the element has a src attribute, and the element has been flagged as "parser-inserted", and the element does not have an async attribute
</dt>
			<dd>
%解析器~文書 の`構文解析器を阻んでいる~script$
~SET %S
◎
The element is the pending parsing-blocking script of the Document of the parser that created the element. (There can only be one such script per Document at a time.)
</dd>
			<dd>
%S が`準備済み$になったときは
⇒
%S の`解析器実行準備済み~flag$ ~SET ~ON
— %構文解析器 が，この~scriptの実行ingを取扱うことになる。
◎
When the script is ready, set the element's "ready to be parser-executed" flag. The parser will handle executing the script.
</dd>

<!-- 
id="script-processing-src-sync"
id="script-processing-module-noasync"
A2
-->
			<dt>A2
◎
If the script's type is "classic", and the element has a src attribute, and the element does not have an async attribute, and the element does not have the "non-blocking" flag set
◎
If the script's type is "module", and the element does not have an async attribute, and the element does not have the "non-blocking" flag set
</dt>
			<dd>
%文書 に結付けられている
`可及的すぐに順に実行される~scriptの~list@
— 以下，単に %~list と記す —
の末尾に %S を追加する
◎
Add the element to the end of the list of scripts that will execute in order as soon as possible associated with the node document of the script element at the time the prepare a script algorithm started.
</dd>
			<dd>
<p>
%S が`準備済み$になったときは、次の手続きを走らす：
</p>

				<ol>
<!-- 
If the element is not now the first element…
-->
					<li>
<p>
~WHILE %~list は空でない
</p>
						<ol>
							<li>
%~script要素 ~LET %~list 内の最初の `script^e 要素
</li>
							<li>
~IF［
%~script要素 は`準備済み$でない
］
⇒
~BREAK
</li>
							<li>
%~script要素 に対応する`~script~blockを実行する$
</li>
							<li>
%~list から %~script要素 を除去する
</li>
						</ol>
					</li>
				</ol>

◎
When the script is ready, run the following steps:
◎
If the element is not now the first element in the list of scripts that will execute in order as soon as possible to which it was added above, then mark the element as ready but abort these steps without executing the script yet.
◎
Execution: Execute the script block corresponding to the first script element in this list of scripts that will execute in order as soon as possible.
◎
Remove the first element from this list of scripts that will execute in order as soon as possible.
◎
If this list of scripts that will execute in order as soon as possible is still not empty and the first entry has already been marked as ready, then jump back to the step labeled execution.
</dd>
			<dt>A3
<!-- 
id="script-processing-src"
id="script-processing-module-async"
-->
◎
If the script's type is "classic", and the element has a src attribute
◎
If the script's type is "module"
</dt>
			<dd>
%文書 に結付けられている
`可及的すぐに実行される~scriptの集合@
— 以下，単に %集合 と記す —
に %S を追加する。
◎
The element must be added to the set of scripts that will execute as soon as possible of the node document of the script element at the time the prepare a script algorithm started.
</dd>
			<dd>
<p>
%S が`準備済み$になったときは：
</p>
<ol>
	<li>
`~script~blockを実行する$
</li>
	<li>
%集合 から %S を除去する
</li>
</ol>

◎
When the script is ready, execute the script block and then remove the element from the set of scripts that will execute as soon as possible.
</dd>

<!-- 
id="script-processing-style-delayed"
-->
			<dt>A4</dt>
			<dd>
				<ol>
					<li>
<div class="p">
<p>
~IF［
次のいずれも満たされる
］…：
</p>

<ul ><li>［
%構文解析器 は`~XML構文解析器$である
］~OR［
%構文解析器 は`~HTML構文解析器$であって，その
`~script入子ing~level$ ~LTE 1
］
</li><li>%解析器~文書 には`~scriptを阻んでいる~stylesheetがある$
</li></ul>
◎
If the element does not have a src attribute, and the element has been flagged as "parser-inserted", and either the parser that created the script is an XML parser or it's an HTML parser whose script nesting level is not greater than one, and the Document of the HTML parser or XML parser that created the script element has a style sheet that is blocking scripts
</div>

<p>
…ならば：
</p>

						<ol id="script-processing-style-delayed">
							<li>
%解析器~文書 の`構文解析器を阻んでいる~script$ ~SET %S
◎
The element is the pending parsing-blocking script of the Document of the parser that created the element. (There can only be one such script per Document at a time.)
</li>
							<li>
%S の`解析器実行準備済み~flag$ ~SET ~ON
— %構文解析器 が，この~scriptの実行ingを取扱うことになる。
◎
Set the element's "ready to be parser-executed" flag. The parser will handle executing the script.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
~GOTO A5
</li>
				</ol>
			</dd>

			<dt>A5</dt>
			<dd id="script-processing-inline">
`即時$に`~script~blockを実行する$
— 他の~scriptがすでに実行していても。
`他の~scriptは停止して後で再開させるのか？^tnote
◎
Otherwise
◎
Immediately execute the script block, even if other scripts are already executing.
</dd>
		</dl>
	</li>
</ol>


<p>
各 `文書$には，（高々一個の）
`構文解析器を阻んでいる~script@
が結付けられる（初期~時は `未設定^i ）。
それは、`文書$の構文解析器（たち）により利用される。
◎
The pending parsing-blocking script of a Document is used by the Document's parser(s).
</p>

<p class="note">注記：
構文解析器を阻んでいる `script$e 要素が
— 通常のようにその構文解析器を阻まなくなる前に —
別の`文書$へ移動された場合でも、［
構文解析器を阻んでいる条件が，それ以上~適用されなくなる
］まで，その構文解析器を阻み続ける（例：
`~scriptを阻んでいる~stylesheet$があるために，~scriptが構文解析-時に`構文解析器を阻んでいる~script$であった場合，［
~stylesheetが読込まれる前に ~scriptが別の`文書$へ移動された
］としても、~scriptは，それらの~stylesheetがすべて読込まれるまで，依然として構文解析器を阻む
— その時点で、~scriptは実行され，構文解析器を阻まなくなる）。
◎
If a script element that blocks a parser gets moved to another Document before it would normally have stopped blocking that parser, it nonetheless continues blocking that parser until the condition that causes it to be blocking the parser no longer applies (e.g. if the script is a pending parsing-blocking script because there was a style sheet that is blocking scripts when it was parsed, but then the script is moved to another Document before the style sheet loads, the script still blocks the parser until the style sheets are all loaded, at which time the script executes and the parser is unblocked).
</p>

<!--%~script~blockを実行する -->

<p class="algo-head">
~UAは、 `script$e 要素 %S に対応する
`~script~blockを実行する@
よう要求されたときは，次の手続きを走らせ~MUST：
◎
When the user agent is required to execute a script block, it must run the following steps.
</p>

<ol>
	<li>
%文書 ~LET %S の`~node文書$
◎
↓</li>
	<li>
~IF［
%S の`解析器挿入~flag$ ~EQ ~ON
］~AND［
%文書 ~NEQ %S を作成した構文解析器の`文書$
］
⇒
~RET
◎
If the element is flagged as "parser-inserted", but the element's node document is not the Document of the parser that created the element, then abort these steps.
</li>
	<li>
<p>
~IF［
%S の`~script$ ~EQ ~NULL
］：
</p>
				<ol>
					<li>
%S に向けて，名前 `error$et の`単純~eventを発火する$
</li>
					<li>
~RET
</li>
				</ol>

◎
If the script's script is null, fire a simple event named error at the element, and abort these steps.
</li>
	<li>
%~counter増減 ~LET ［［
%S の`外部~file~flag$ ~EQ ~ON
］~OR［
%S の`~script種別$ ~EQ `module^l
］ならば ~T ／
~ELSE_ ~F
］
◎
If the script is from an external file, or the script's type is "module", then increment the ignore-destructive-writes counter of the script element's node document. Let neutralized doc be that Document.
</li>
	<li>
~IF［
%~counter増減 ~EQ ~T
］
⇒
%文書 の`破壊的書込無視~counter$ ~INCBY 1
◎
↑</li>
	<li>
%旧-~script要素 ~LET 
%文書 の最も近過去に設定された `currentScript$m ~obj 値
◎
Let old script element be the value to which the script element's node document's currentScript object was most recently set.
</li>
	<li>
<p>
%S の`~script種別$に応じて：
◎
Switch on the script's type:
</p>
		<dl class="switch">
			<dt>`classic^l</dt>
			<dd>
				<ol>
					<li>
<p>
%文書 の`currentScript$m 属性 ~SET ［
%S の`根$は`~shadow根$でないならば %S ／
~ELSE_ ~NULL
］
◎
If the script element's root is not a shadow root, then set the script element's node document's currentScript attribute to the script element. Otherwise, set it to null.
</p>

<p class="note">
ここでは、 %S が`文書~木~内$にあるかどうかは検査しない
— `script$e 要素は、実行に先立って文書から除去されていることもあり、その局面でも依然として， `currentScript$m は それを指す必要があるので。
◎
This does not use the in a document tree check, as the script element could have been removed from the document prior to execution, and in that scenario currentScript still needs to point to it.
</p>
					</li>
					<li>
%S の`~script$を与える下で，`~classic~scriptを走らす$
◎
Run the classic script given by the script's script.
</li>
				</ol>
			</dd>

			<dt>`module^l</dt>
			<dd>
				<ol>
					<li>
%文書 の`currentScript$m 属性 ~SET ~NULL
◎
Set the script element's node document's currentScript attribute to null.
</li>
					<li>
%S の`~script$を与える下で，`~module~scriptを走らす$
◎
Run the module script given by the script's script.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
<p>
%文書 の`currentScript$m 属性 ~SET %旧-~script要素
◎
Set the script element's node document's currentScript attribute to old script element.
</p>

   </li>
	<li>
~IF［
%~counter増減 ~EQ ~T
］
⇒
%文書 の`破壊的書込無視~counter$ ~DECBY 1
◎
Decrement the ignore-destructive-writes counter of neutralized doc, if it was incremented in the earlier step.
</li>
	<li>
<p>
~IF［
%S の`外部~file~flag$ ~EQ ~ON
］
⇒
%S の`~script種別$に応じて：
</p>
		<dl class="switch">
			<dt>`classic^l</dt>
			<dd>
%S に向けて，名前 `load$et の`単純~eventを発火する$
◎
Fire a simple event named load at the script element.
</dd>
			<dt>`module^l</dt>
			<dd>
次を走らす`~taskを待入する$
⇒
%S に向けて，名前 `load$et の`単純~eventを発火する$
◎
Queue a task to fire a simple event named load at the script element.
</dd>
		</dl>
	</li>
</ol>


			</section>
			<section id="scriptingLanguages">
<h4 title="Scripting languages">4.12.1.2. ~scripting言語</h4>

<p>
次に挙げる`~MIME型$文字列は，
`~JS~MIME型@
とされ、~JSを指す：
`JAVASCRIPT$r
◎
A JavaScript MIME type is a MIME type string that is one of the following and refers to JavaScript: [JAVASCRIPT]
</p>

<ul class="brief"><li>`application/ecmascript$mt
</li><li>`application/javascript$mt
</li><li>`application/x-ecmascript$mt
</li><li>`application/x-javascript$mt
</li><li>`text/ecmascript$mt
</li><li>`text/javascript$mt
</li><li>`text/javascript1.0$mt
</li><li>`text/javascript1.1$mt
</li><li>`text/javascript1.2$mt
</li><li>`text/javascript1.3$mt
</li><li>`text/javascript1.4$mt
</li><li>`text/javascript1.5$mt
</li><li>`text/jscript$mt
</li><li>`text/livescript$mt
</li><li>`text/x-ecmascript$mt
</li><li>`text/x-javascript$mt
</li></ul>

<p>
~UAは、すべての`~JS~MIME型$を認識し~MUST。
◎
User agents must recognize all JavaScript MIME types.
</p>

<p>
~UAは，他の言語~用に他の`~MIME型$を~supportして~MAYが、上の~list内の言語に対しては，他の`~MIME型$を~supportしては~MUST_NOT。
~UAには、~JSを~supportすることは要求されない。
~JS以外の言語に対する処理~modelは、この仕様の視野~外である。
◎
User agents may support other MIME types for other languages, but must not support other MIME types for the languages in the list above. User agents are not required to support JavaScript. The processing model for languages other than JavaScript is outside the scope of this specification.
</p>

<p>
次に挙げる`~MIME型$は、（~parameterの有無にかかわらず，）
~scripting言語に解釈されては~MUST_NOT：
◎
The following MIME types (with or without parameters) must not be interpreted as scripting languages:
</p>

<ul class="brief"><li>`text/plain$mt
</li><li>`text/xml$mt
</li><li>`application/octet-stream$mt
</li><li>`application/xml$mt
</li></ul>

<p class="note">注記：
これらの型が明示的にここに挙げられるわけは、これらは型と称されてはいるが，~data~blockに対する形式として利用される可能性が高い，ほぼ定義されていない型であり、~UAがある日突然~scriptとして解釈することにしたなら，問題になるので。
◎
These types are explicitly listed here because they are poorly-defined types that are nonetheless likely to be used as formats for data blocks, and it would be problematic if they were suddenly to be interpreted as script by a user agent.
</p>

<p>
~UAは、所与の型を検分して，自身が~supportする言語を表現しているかどうか決定する際には、その~MIME~parameterを無視しては~MUST_NOT。
型は，~parameterすべても含めて比較されるとする。
◎
When examining types to determine if they represent supported languages, user agents must not ignore MIME parameters. Types are to be compared including all parameters.
</p> 

<p class="note">注記：
例えば、 `charset^c ~parameterを含む型は、上に挙げた どの~scripting言語も参照していないものと認識されることになる。
◎
For example, types that include the charset parameter will not be recognized as referencing any of the scripting languages listed above.
</p>


			</section>
			<section id="restrictions-for-contents-of-script-elements">
<h4 title="Restrictions for contents of script elements">4.12.1.3. `script^e 要素の内容に課される制約</h4>

<p class="note">注記：
この節に述べる奇妙な制約を避ける最も容易かつ安全な仕方は、~script内に（例えば 文字列, 正規表現, ~comment として）~literalで現れる［
`&lt;!--^l ／ `&lt;script^l ／ `&lt;/script^l
］は、常に［
`&lt;\!--^l ／ `&lt;\script^l ／ `&lt;\/script^l
］に~escapeし、式の中でそのような構成子を利用するような~codeを書くのは，避けることである。
この節における制約は，ちょっとしたことで抵触し易く、そうすることで，陥穽を避けれる。
すなわち、歴史的~理由から，~HTML内の `script$e ~blockの構文解析では、これらの文字~並びに出くわした際のふるまいが直感に反するような，奇妙で風変わりな実施になっている。
◎
The easiest and safest way to avoid the rather strange restrictions described in this section is to always escape "&lt;!--" as "&lt;\!--", "&lt;script" as "&lt;\script", and "&lt;/script" as "&lt;\/script" when these sequences appear in literals in scripts (e.g. in strings, regular expressions, or comments), and to avoid writing code that uses such constructs in expressions. Doing so avoids the pitfalls that the restrictions in this section are prone to triggering: namely, that, for historical reasons, parsing of script blocks in HTML is a strange and exotic practice that acts unintuitively in the face of these sequences.
</p>

<p>
`script$e 要素の `textContent$m は、次の~ABNFで与えられる `script^P 生成規則に合致し~MUST
— この ABNF の文字~集合は Unicode である `ABNF$r：
◎
The textContent of a script element must match the script production in the following ABNF, the character set for which is Unicode. [ABNF]
</p>

<!-- 
any string that doesn't contain a substring that matches
	not-in-outer|not-in-inner
-->

<pre class="ABNF">
script        = outer *( comment-open inner comment-close outer )

outer         = &lt; not-in-outer に合致する文字列は含まないような任意の文字列 &gt;
not-in-outer  = comment-open
inner         = &lt; not-in-inner に合致する文字列は含まないような任意の文字列 &gt;
not-in-inner  = comment-close / script-open

comment-open  = "&lt;!--"
comment-close = "--&gt;"
script-open   = "&lt;" s c r i p t tag-end

s             =  `0053^0x ; U+0053 LATIN CAPITAL LETTER S
s             =/ `0073^0x ; U+0073 LATIN SMALL LETTER S
c             =  `0043^0x ; U+0043 LATIN CAPITAL LETTER C
c             =/ `0063^0x ; U+0063 LATIN SMALL LETTER C
r             =  `0052^0x ; U+0052 LATIN CAPITAL LETTER R
r             =/ `0072^0x ; U+0072 LATIN SMALL LETTER R
i             =  `0049^0x ; U+0049 LATIN CAPITAL LETTER I
i             =/ `0069^0x ; U+0069 LATIN SMALL LETTER I
p             =  `0050^0x ; U+0050 LATIN CAPITAL LETTER P
p             =/ `0070^0x ; U+0070 LATIN SMALL LETTER P
t             =  `0054^0x ; U+0054 LATIN CAPITAL LETTER T
t             =/ `0074^0x ; U+0074 LATIN SMALL LETTER T

tag-end       =  `0009^0x ; U+0009 CHARACTER TABULATION (tab)
tag-end       =/ `000A^0x ; U+000A LINE FEED (LF)
tag-end       =/ `000C^0x ; U+000C FORM FEED (FF)
tag-end       =/ `0020^0x ; U+0020 SPACE
tag-end       =/ `002F^0x ; U+002F SOLIDUS (/)
tag-end       =/ `003E^0x ; U+003E GREATER-THAN SIGN (&gt;)
</pre>

<p>
`script$e 要素が`~script文書化$を包含する場合、要素の内容にも，下の節で述べる制約が更に課される。
◎
When a script element contains script documentation, there are further restrictions on the contents of the element, as described in the section below.
</p>

  <div class="example">

<p>
この~~問題を，次のような文字列を包含している~scriptで~~説明する：
◎
The following script illustrates this issue. Suppose you have a script that contains a string, as in:
</p>

<pre>
var example = 'Consider this string: &lt;!-- &lt;script&gt;';
console.log(example);
</pre>

<p>
仮に，この文字列が `script$e ~block内に直接的に記された場合、上の制約に違反することになる：
◎
If one were to put this string directly in a script block, it would violate the restrictions above:
</p>

<pre>
&lt;script&gt;
  var example = 'Consider this string: &lt;!-- &lt;script&gt;';
  console.log(example);
&lt;/script&gt;
</pre>

<p>
より大きな問題であり，なぜそれが制約に違反することになるかの理由は、上の~script~blockが，<em>実際には終端していない</em>点にある。
この~scriptに対する構文解析され方は~~理解しがたいものであり，終了tagの様に見える
`&lt;/script&gt;^l
は、実際には，依然として `script$e ~blockの一部になる。
~scriptは（終端していないので）実行されないが、どうにかして実行されるようになっていた場合
— 例えば~markupが次のようになっていた場合 —
~script（<mark>強調表示</mark>されている部分）は、妥当な~JSでないので，失敗することになる：
◎
The bigger problem, though, and the reason why it would violate those restrictions, is that actually the script would get parsed weirdly: the script block above is not terminated. That is, what looks like a "&lt;/script&gt;" end tag in this snippet is actually still part of the script block. The script doesn't execute (since it's not terminated); if it somehow were to execute, as it might if the markup looked as follows, it would fail because the script (highlighted here) is not valid JavaScript:
</p>

<pre>
&lt;script&gt;<mark>
  var example = 'Consider this string: &lt;!-- &lt;script&gt;';
  console.log(example);
&lt;/script&gt;
&lt;!-- 見かけに反し、実際には，ここも~scriptの一部になる。 --&gt;
&lt;script&gt;
 ... // ここもまだ同じ~script~block内にある...
</mark>&lt;/script&gt;
</pre>

<!-- 
  var example = 'Consider this string: ...';

despite appearances, this is actually part of the script still!

 ... // this is the same script block still...
 -->



<p>
ここで起きていることは、旧来の理由から，
`script$e 要素~内の文字列［
`&lt;!--^l ／ `&lt;script^l
］を対にしなければ、~HTMLの構文解析器からは，~blockが閉じたものと見なされるなくなることである。
◎
What is going on here is that for legacy reasons, "&lt;!--" and "&lt;script" strings in script elements in HTML need to be balanced in order for the parser to consider closing the block.
</p>

<p>
この節の冒頭で言及したように、問題になる文字列を~escapeすれば，この問題をまるごと避けれる：
◎
By escaping the problematic strings as mentioned at the top of this section, the problem is avoided entirely:
</p>

<pre>
&lt;script&gt;<mark>
  var example = 'Consider this string: &lt;\!-- &lt;\script&gt;';
  console.log(example);
</mark>&lt;/script&gt;
&lt;!-- ここは単に 2 つの~script~blockの合間にある~commentになる --&gt;
&lt;script&gt;<mark>
 ... // 新たな~script~block
</mark>&lt;/script&gt;
</pre>
<!-- 
this is just a comment between script blocks
 -->
<p>
これらの文字~並びが~scriptの式の中に自然に生じることもある
— 次の例のように：
◎
It is possible for these sequences to naturally occur in script expressions, as in the following examples:
</p>

<pre>
if (x&lt;!--y) { ... }
if ( player&lt;script ) { ... }
</pre>

<p>
このような事例では、文字たちは~escapeできないが、この式は，そのような文字~並びが生じないように書き直せる：
◎
In such cases the characters cannot be escaped, but the expressions can be rewritten so that the sequences don't occur, as in:
</p>

<pre>
if (x &lt; !--y) { ... }
if (!--y &gt; x) { ... }
if (!(--y) &gt; x) { ... }
if (player &lt; script) { ... }
if (script &gt; player) { ... }
</pre>

<p>
こうすることで，別の陥穽
— 歴史的~理由から、`~classic~script$内の文字列 
`&lt;!--^l
は，実際には
`//^l
と同じく，行~commentの開始として扱われること —
も避けれる。
◎
Doing this also avoids a different pitfall as well: for related historical reasons, the string "&lt;!--" in classic scripts is actually treated as a line comment start, just like "//".
</p>

</div>


			</section>
			<section id="inline-documentation-for-external-scripts">
<h4 title="Inline documentation for external scripts">4.12.1.4. 外部~scriptに対する~inline文書化</h4>

<p>
`src$a 属性を有する `script$e 要素に対しては、要素の内容から導出される `text$m ~IDL属性の値が，次の~ABNFによる `documentation^P 生成規則に合致してい~MUST
— この ABNF の文字~集合は Unicode である：
`ABNF$r
◎
If a script element's src attribute is specified, then the contents of the script element, if any, must be such that the value of the text IDL attribute, which is derived from the element's contents, matches the documentation production in the following ABNF, the character set for which is Unicode. [ABNF]
</p>

<pre class="ABNF">
documentation = *( *( space / tab / comment ) [ line-comment ] newline )
comment       = slash star *( not-star / star not-slash ) 1*star slash
line-comment  = slash slash *not-newline

; characters
tab           = `0009^0x ; U+0009 CHARACTER TABULATION (tab)
newline       = `000A^0x ; U+000A LINE FEED (LF)
space         = `0020^0x ; U+0020 SPACE
star          = `002A^0x ; U+002A ASTERISK (*)
slash         = `002F^0x ; U+002F SOLIDUS (/)
not-newline   = `0000-0009^0x / `000B-10FFFF^0x
                ; U+000A LINE FEED (LF) 以外の `Unicode 文字$
not-star      = `0000-0029^0x / `002B-10FFFF^0x
                ; U+002A ASTERISK (*) 以外の `Unicode 文字$
not-slash     = `0000-002E^0x / `0030-10FFFF^0x
                ; U+002F SOLIDUS (/) 以外の `Unicode 文字$
</pre>

<!-- 
a Unicode character other than
 -->

<p class="note">注記：
これは、要素の内容を ~JS~comment内に置くことに対応する。
◎
This corresponds to putting the contents of the element in JavaScript comments.
</p>

<p class="note">注記：
この要件は、前節に述べた `script$e 要素の内容の構文に課される制約に対する追加である。
◎
This requirement is in addition to the earlier restrictions on the syntax of contents of script elements.
</p>

<div class="example">

<p>
これにより，作者は、依然として外部~script~fileを指しつつ，文書の内側にも~license情報や~API情報などの文書化を含ませることも可能になる。
この構文では、 `src$a 属性も提供している作者が，不用意に妥当な~scriptの様に見える~dataを含めることがないように，拘束される。
◎
This allows authors to include documentation, such as license information or API information, inside their documents while still referring to external script files. The syntax is constrained so that authors don't accidentally include what looks like valid script while also providing a src attribute.
</p>

<pre>
&lt;script src="cool-effects.js"&gt;
 // 新たな~instanceを作成するときは、次を利用すること：
 //    var e = new Effect();
 // 効果を開始／停止するときは、 .play() ／ .stop() を利用すること：
 //    e.play();
 //    e.stop();
&lt;/script&gt;
</pre>

<!-- 
 // create new instances using:
 //    var e = new Effect();
 // start the effect using .play, stop using .stop:
-->

</div>


			</section>
			<section id="scriptTagXSLT">
<h4 title="Interaction of script elements and XSLT">4.12.1.5.  `script$e 要素と XSLT との相互作用</h4>

~INFORMATIVE

<p>
この仕様は、~XSLTと `script$e 要素とが，どう相互作用するかは定義しない。
しかしながら、これを実際に定義している別の仕様が不在の下での、既存の実装に基づく，実装者に対するいくつかの指針をここに述べる：
◎
This specification does not define how XSLT interacts with the script element. However, in the absence of another specification actually defining this, here are some guidelines for implementors, based on existing implementations:
</p>

<ul>
	<li>
~browserが~DOMへの直接的な変形を実装する下で，
`&lt;?xml-stylesheet?&gt;^c
処理命令により ~XSLT変形~programが誘発された場合、~XSLT処理器により作成される各 `script$e 要素は、その`解析器挿入~flag$は ~ON にした上で，変形が生じるに伴って，`即時$に, 文書~順序で（ただし， `defer$a ／ `async$a による順序は除く），走らす必要がある。
◎
When an XSLT transformation program is triggered by an &lt;?xml-stylesheet?&gt; processing instruction and the browser implements a direct-to-DOM transformation, script elements created by the XSLT processor need to be marked "parser-inserted" and run in document order (modulo scripts marked defer or async), immediately, as the transformation is occurring.
</li>
	<li>
<p >
`transformToDocument()$m
~methodは、`閲覧文脈に属さ$ない`文書$に要素を追加する。
それに則り、作成されるどの `script$e 要素も，次のようにされる必要がある：
</p>

		<ul>
			<li>
`~scriptを準備する$~algoの中で，その`開始済み~flag$を ~ON にして、決して実行されないようにする（`~scriptingは不能化され$0る）。
</li>
			<li>
`解析器挿入~flag$は、依然として ~ON にする。
</li>
			<li>
その `async$m ~IDL属性は、要素が `async$a 内容~属性を有さない下でも ~F を返すようにする。
</li>
		</ul>

◎
The XSLTProcessor.transformToDocument() method adds elements to a Document that does not have a browsing context, and, accordingly, any script elements they create need to have their "already started" flag set in the prepare a script algorithm and never get executed (scripting is disabled). Such script elements still need to be marked "parser-inserted", though, such that their async IDL attribute will return false in the absence of an async content attribute.
</li>
	<li>
`XSLTProcessor.transformToFragment()$m
~methodは、
`document.createElementNS()$m
を利用して作成された要素から，手動で築かれた`文書片$と等価なものを作成する必要がある。
具体的には、 `script$e 要素を作成する際には，［
`解析器挿入~flag$, `開始済み~flag$
］はともに ~OFF にして，その`文書片$が文書~内に挿入された時点で実行されるようにする必要がある。
◎
The XSLTProcessor.transformToFragment() method needs to create a fragment that is equivalent to one built manually by creating the elements using document.createElementNS(). For instance, it needs to create script elements that aren't "parser-inserted" and that don't have their "already started" flag set, so that they will execute when the fragment is inserted into a document.
</li></ul>

<p>
最初の 1, 2 番目の事例と， 3 番目の事例との間の主な違いは、前者は`文書$に対し演算する一方で，後者は`文書片$に対し演算する点にある。
◎
The main distinction between the first two cases and the last case is that the first two operate on Documents and the last operates on a fragment.
</p>


			</section>
		</section>
		<section id="the-noscript-element">
<h3 title="The noscript element">4.12.2. `noscript^e 要素</h3>

<dl class="element-def">

	<dt>`分類$：</dt>
	<dd>
`~metadata内容$ ／ `~flow内容$ ／ `句内容$
◎
Metadata content.
◎
Flow content.
◎
Phrasing content.
</dd>

	<dt>`この要素を利用できる文脈$：</dt>
	<dd>
`~HTML文書$の `head$e 要素~内, または
`~HTML文書$内の `句内容$が期待される所
— ただし、いずれにせよ，先祖に `noscript$e 要素がある所は除く。
◎
In a head element of an HTML document, if there are no ancestor noscript elements.
◎
Where phrasing content is expected in HTML documents, if there are no ancestor noscript elements.
</dd>

	<dt>`内容~model$：</dt>
	<dd>
<p>
要素に対する`~scriptingは不能化され$ている場合：
</p>
		<ul>
			<li>
要素が `head$e 要素~内にある場合、順序は問わず，それぞれが［
`link$e, `style$e, `meta$e
］のいずれかであるような，~zero個以上の要素。
</li>
			<li>
要素が `head$e 要素~外にある場合、`透過的$になる
— ただし、子孫に `noscript$e 要素があっては~MUST_NOT。
</li>
		</ul>

◎
When scripting is disabled, in a head element: in any order, zero or more link elements, zero or more style elements, and zero or more meta elements.
◎
When scripting is disabled, not in a head element: transparent, but there must be no noscript element descendants.
</dd>
	<dd>
他の場合、下の注釈文に与える要件に適合するような~text。
◎
Otherwise: text that conforms to the requirements given in the prose.
</dd>

	<dt>`text/html における~tag省略$：</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$：</dt>
	<dd>`大域~属性$
◎
Global attributes
</dd>

	<dt>`~DOM~interface$：</dt>
	<dd>
`HTMLElement$I を利用する
◎
Uses HTMLElement.
</dd></dl>

<p>
`noscript$e 要素は、`~scriptingは可能化され$ている場合は，何も`表現-$せず、`~scriptingは不能化され$ている場合は，その子たちを`表現-$する。
それは、文書の構文解析され方が，~UAが~scriptingを~supportするかどうかに応じて異なることにより、異なる~markupを提示するために利用される。
◎
The noscript element represents nothing if scripting is enabled, and represents its children if scripting is disabled. It is used to present different markup to user agents that support scripting and those that don't support scripting, by affecting how the document is parsed.
</p>

<p>
`noscript$e 要素 %noscript が
`~HTML文書$に利用される場合に許容される内容~modelは、次に従う：
◎
When used in HTML documents, the allowed content model is as follows:
</p>

<dl class="switch">
	<dt>%noscript は `head$e 要素~内にある場合：◎↓</dt>
	<dd>
		<dl class="switch">
			<dt>`~scriptingは不能化され$ている場合：
◎
In a head element, if scripting is disabled for the noscript element
</dt>
			<dd>
%noscript は［
`link$e, `style$e, `meta$e
］要素のみを包含してい~MUST。
◎
The noscript element must contain only link, style, and meta elements.
</dd>

			<dt>`~scriptingは可能化され$ている場合：
◎
In a head element, if scripting is enabled for the noscript element
</dt>
			<dd>
<p>
%noscript は、次のいずれかを満たさ~MUST：
</p>

				<ul>
					<li>
~textのみを包含している, または
</li>
					<li>
<p >
( `文脈~要素$V, %入力 )
として
( %noscript, %noscript の~text内容 )
を与える下で，`~HTML素片~構文解析~algo$を呼出したときに，次を満たす：
</p>

<ul ><li>`構文解析-~error$は生じない, かつ
</li><li>~algoの結果は［
`link$e, `style$e, `meta$e
］要素のみからなる~nodeの~listである, かつ
</li><li>その~listが %noscript の子たちであったとするとき，適合する
</li></ul>
					</li>
				</ul>


◎
The noscript element must contain only text, except that invoking the HTML fragment parsing algorithm with the noscript element as the context element and the text contents as the input must result in a list of nodes that consists only of link, style, and meta elements that would be conforming if they were children of the noscript element, and no parse errors.
</dd>

		</dl>
	</dd>

	<dt>%noscript は `head$e 要素~外にある場合：◎↓</dt>
	<dd>
		<dl class="switch">
			<dt>`~scriptingは不能化され$ている場合：
◎
Outside of head elements, if scripting is disabled for the noscript element
</dt>
			<dd>
%noscript の内容~modelは`透過的$になる
— ただし， %noscript の先祖に `noscript$e 要素があっては~MUST_NOT（すなわち，
`noscript$e は入子にできない）。
◎
The noscript element's content model is transparent, with the additional restriction that a noscript element must not have a noscript element as an ancestor (that is, noscript can't be nested).
<dd>

			<dt>`~scriptingは可能化され$ている場合：
◎
Outside of head elements, if scripting is enabled for the noscript element
</dt>
			<dd>
<p>
%noscript は、次のいずれかを満たさ~MUST：
</p>

				<ul>
					<li>
~textのみを包含している, または
</li>
					<li>
<p >
下の~algoを走らせたときに，次を満たす：
</p>

<ul><li>例外は投出されない, かつ
</li><li>
結果の文書は、［
`noscript$e, `script$e
］要素を含まない，適合~文書になる
</li><li>`~HTML構文解析器$において，`構文解析-~error$は生じない
</li></ul>
					</li>
				</ul>

◎
The noscript element must contain only text, except that the text must be such that running the following algorithm results in a conforming document with no noscript elements and no script elements, and such that no step in the algorithm throws an exception or causes an HTML parser to flag a parse error:
</dd>
			<dd>
<p>
~algoは、次で与えられる：
◎
↑</p>
				<ol>
					<li>
当の文書からすべての `script$e 要素を除去する
◎
Remove every script element from the document.
</li>
					<li>
<p>
~FOR 
当の文書~内の~EACH ( `noscript$e 要素 %E ) に対し：
◎
Make a list of every noscript element in the document. For every noscript element in that list, perform the following steps:
</p>

						<ol>
							<li>
%E の `outerHTML$m 属性 ~SET %E の`子~text内容$
（これによる副作用として， %E は当の文書から除去される。）
`DOMPARSING$r
◎
Let s be the child text content of the noscript element.
◎
Set the outerHTML attribute of the noscript element to the value of s. (This, as a side-effect, causes the noscript element to be removed from the document.) [DOMPARSING]
</li>
						</ol>
					</li>
				</ol>
			</dd>
		</dl>
	</dd>
</dl>





<p class="note">注記：
上述の ひねくれた取扱いすべてが要求される
— 歴史的~理由から，`~HTML構文解析器$による `noscript$e 要素に対する取扱いは、［
構文解析器が呼出されたときに，その要素の`~scriptingは可能化されていたかどうか$
］に応じて，異なるので。
◎
All these contortions are required because, for historical reasons, the noscript element is handled differently by the HTML parser based on whether scripting was enabled or not when the parser was invoked.
</p>

<p>
`~XML文書$には、
`noscript$e 要素は利用されては~MUST_NOT。
◎
The noscript element must not be used in XML documents.
</p>

<p class="note">注記：
`noscript$e 要素が効果を及ぼすのは，`~HTML構文$に限られる
— `~XHTML構文$には効果を及ぼさない。
このことは、~scriptが可能化されている下では、本質的に［
要素の内容を本当の要素としてではなく，純粋な~textとして扱う
］ように，構文解析器を “切る” ように働くためである。
~XMLには、これを行う仕組みは定義されていない。
◎
The noscript element is only effective in the HTML syntax, it has no effect in the XHTML syntax. This is because the way it works is by essentially "turning off" the parser when scripts are enabled, so that the contents of the element are treated as pure text and not as real elements. XML does not define a mechanism by which to do this.
</p>

<p>
`noscript$e 要素には、他の要件はない。
特に，要素に対し`~scriptingは可能化され$ているときでも、
`noscript$e 要素の子たちが
`~form提出$, ~scripting, 等々, から免れることはない。
◎
The noscript element has no other requirements. In particular, children of the noscript element are not exempt from form submission, scripting, and so forth, even when scripting is enabled for the element.
</p>


<div class="example">

<p>
次の例では、~scriptに対する~fallbackを提供するために
`noscript$e 要素が利用されている：
◎
In the following example, a noscript element is used to provide fallback for a script.
</p>

<pre>
&lt;form action="calcSquare.php"&gt;
 &lt;p&gt;
  &lt;label for=x&gt;数値&lt;/label&gt;:
  &lt;input id="x" name="x" type="number"&gt;
 &lt;/p&gt;
 &lt;script&gt;
  var %x = document.getElementById('x');
  var %output = document.createElement('p');
  %output.textContent = '数値を入れてください。二乗した結果が返されます。';
  %x.form.appendChild(%output);
  %x.form.onsubmit = function () { return false; }
  %x.oninput = function () {
    var %v = %x.valueAsNumber;
    %output.textContent = %v + ' の二乗は ' + %v * %v ' です。';
  };
 &lt;/script&gt;
 &lt;noscript&gt;
  &lt;input type=submit value="二乗を計算する"&gt;
 &lt;/noscript&gt;
&lt;/form&gt;
</pre>
<!-- 
Number
  output.textContent = 'Type a number; it will be squared right then!';
 -->

<p>
~scriptが不能化されている下では、~server側で計算を行わせるような~buttonが現れる。
一方で，~scriptが可能化されている下では、その場で値が算出される。
◎
When script is disabled, a button appears to do the calculation on the server side. When script is enabled, the value is computed on-the-fly instead.
</p>

<p>
`noscript$e 要素は、 “なまくら” である。
頁の~scriptが可能化されていても，何らかの理由で失敗することはある。
よって，一般に、 `noscript$e の利用は避ける方が良い
— 次の例のように、まず，~scriptなしが~~前提の頁にした上で、［
~scriptが成功したなら，その場で その結果を利用するように頁を変更する
］ように，設計することにより：
◎
The noscript element is a blunt instrument. Sometimes, scripts might be enabled, but for some reason the page's script might fail. For this reason, it's generally better to avoid using noscript, and to instead design the script to change the page from being a scriptless page to a scripted page on the fly, as in the next example:
</p>

<pre>
&lt;form action="calcSquare.php"&gt;
 &lt;p&gt;
  &lt;label for=x&gt;数値&lt;/label&gt;:
  &lt;input id="x" name="x" type="number"&gt;
 &lt;/p&gt;
 <strong>&lt;input id="submit" type=submit value="二乗を計算する"&gt;</strong>
 &lt;script&gt;
  var %x = document.getElementById('x');
  var %output = document.createElement('p');
  %output.textContent = '数値を入れてください。二乗した結果が返されます。';
  %x.form.appendChild(%output);
  %x.form.onsubmit = function () { return false; }
  %x.oninput = function () {
    var %v = %x.valueAsNumber;
    %output.textContent = %v + ' の二乗は ' + %v * %v ' です。';
  };
<strong>  var %submit = document.getElementById('submit');
  %submit.parentNode.removeChild(%submit);</strong>
 &lt;/script&gt;
&lt;/form&gt;
</pre>

<p>
この技法は、 `noscript$e を~supportしない`~XHTML構文$においても有用になる。
◎
The above technique is also useful in XHTML, since noscript is not supported in the XHTML syntax.
</p>

</div>





		</section>
		<section id="the-template-element">
<h3 title="The template element">4.12.3. `template^e 要素</h3>

<dl class="element-def">
	<dt>`分類$：</dt>
	<dd>
`~metadata内容$ ／ `~flow内容$ ／ `句内容$ ／ `~scriptを~supportする要素$
◎
Metadata content.
◎
Flow content.
◎
Phrasing content.
◎
Script-supporting element.
</dd>

	<dt>`この要素を利用できる文脈$：</dt>
	<dd>
`~metadata内容$が期待される所。
◎
Where metadata content is expected.
</dd>
	<dd>
`句内容$が期待される所。
◎
Where phrasing content is expected.
</dd>
	<dd>
`~scriptを~supportする要素$が期待される所。
◎
Where script-supporting elements are expected.
</dd>
	<dd>
`span$a 属性を有さない `colgroup$e 要素の子として。
◎
As a child of a colgroup element that doesn't have a span attribute.
</dd>

	<dt>`内容~model$：</dt>
	<dd>
`なし$
</dd>

	<dt>`text/html における~tag省略$：</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$：</dt>
	<dd>`大域~属性$
◎
Global attributes
</dd>

	<dt>`~DOM~interface$：</dt>
	<dd>
<pre class="idl">
[`HTMLConstructor$]
interface `HTMLTemplateElement@I : `HTMLElement$I {
  readonly attribute `DocumentFragment$I `content$m;
};
</pre>
</dd>

</dl>

<p>
`template$e 要素は、~scriptにより，~cloneしたり文書~内に挿入できるような，~HTML素片を宣言するために利用される。
◎
The template element is used to declare fragments of HTML that can be cloned and inserted in the document by script.
</p>

<p>
具現化においては、 `template$e 要素は何も`表現-$しない。
◎
In a rendering, the template element represents nothing.
</p>


<p>
`template$e 要素の`~template内容$は、要素~自身の子ではない。
この内容は、主の`文書$に干渉しないように，`閲覧文脈$に属さない異なる`文書$に結付けられた`文書片$に格納される（これにより、例えば ~form~controlが提出されたり，~scriptが実行される, 等々は避けられる）
`~template内容$には、
<a href="~HTMLdom#no-browsing-context">適合性~要件はない</a>
。
◎
The template contents of a template element are not children of the element itself. Instead, they are stored in a DocumentFragment associated with a different Document without a browsing context so as to avoid the template contents interfering with the main Document. (For example, this avoids form controls from being submitted, scripts from executing, and so forth.) The template contents have no conformance requirements.
</p>

<div class="example">

<p>
例えば、次の文書を考える：
◎
For example, consider the following document:
</p>

<pre>
&lt;!doctype html&gt;
&lt;html lang="ja"&gt;
 &lt;head&gt;
  &lt;title&gt;宿題&lt;/title&gt;
 &lt;body&gt;
  &lt;template id="template"&gt;&lt;p&gt;😀&lt;/p&gt;&lt;/template&gt;
  &lt;script&gt;
   let %num = 3;
   const %fragment =
      document.getElementById('template').content.cloneNode(true);
   while (%num -- &gt; 1) {
     %fragment.firstChild.before(%fragment.firstChild.cloneNode(true));
     %fragment.firstChild.textContent += %fragment.lastChild.textContent;
   }
   document.body.appendChild(%fragment);
  &lt;/script&gt;
&lt;/html&gt;
</pre>

<p>
`template$e 内の `p$e 要素は、
~DOM内では `template$e の子<em>ではない</em>
— それは、 `template$e 要素の `content$m ~IDL属性から返される`文書片$の子である。
◎
The p element in the template is not a child of the template in the DOM; it is a child of the DocumentFragment returned by the template element's content IDL attribute.
</p>

<p>
~scriptが `template$e 要素~上の `appendChild()$m を~callした場合、
（他の要素に対するときと同様に） `template$e 要素に子を追加することになる
— しかしながら，そうすると、
`template$e 要素の内容~modelに違反することになる。
◎
If the script were to call appendChild() on the template element, that would add a child to the template element (as for any other element); however, doing so is a violation of the template element's content model.
</p>

</div>



<dl class="domintro">
	<dt>%~template . `content$m</dt>
	<dd>
`~template内容$（ `文書片$ ）を返す。
◎
Returns the template contents (a DocumentFragment).
</dd>
</dl>

<p class="algo-head">
各 `template$e 要素には，`文書片$が結付けられ、それが 要素の
`~template内容@
になる。
~UAは、 `template$e 要素 %要素 を作成するときは，次の手続きを走らせて， %要素 の`~template内容$を確立し~MUST：
◎
Each template element has an associated DocumentFragment object that is its template contents. When a template element is created, the user agent must run the following steps to establish the template contents:
</p>

<ol>
	<li>
%文書 ~LET %要素 の`~node文書$の`~template内容を所有する適切な文書$
◎
Let doc be the template element's node document's appropriate template contents owner document.
</li>
	<li>
%文書片 ~LET 次のようにされた，新たな`文書片$
⇒
`~node文書$ ~SET %文書；<br>
`~host$ ~SET %要素
◎
Create a DocumentFragment object whose node document is doc and host is the template element.
</li>
	<li>
%要素 の`~template内容$ ~SET %文書片
◎
Set the template element's template contents to the newly created DocumentFragment object.
</li>
</ol>


<p class="algo-head">
`文書$ %文書 の
`~template内容を所有する適切な文書@
は、次の~algoから返される`文書$として定義される：
◎
A Document doc's appropriate template contents owner document is the Document returned by the following algorithm:
</p>

<ol>
	<li>
~IF［
%文書 は、ある`文書$の`不活~template文書$である
］
⇒
~RET %文書
◎
If doc is not a Document created by this algorithm, run these substeps:
</li>
	<li>
%不活~文書 ~LET %文書 の`不活~template文書$
◎
</li>
	<li>
~IF［
%不活~文書 ~NEQ ε
］
⇒
~RET %不活~文書
◎
If doc does not yet have an associated inert template document then run these substeps:
</li>
	<li>
%不活~文書 ~LET （`閲覧文脈に属さ$ない）新たな`文書$
◎
Let new doc be a new Document (that does not have a browsing context). This is "a Document created by this algorithm" for the purposes of the step above.
</li>
	<li>
~IF［
%文書 は`~HTML文書$である
］
⇒
%不活~文書 も`~HTML文書$にする
◎
If doc is an HTML document, mark new doc as an HTML document also.
</li>
	<li>
%文書 の`不活~template文書$ ~SET %不活~文書
◎
Let doc's associated inert template document be new doc.
</li>
	<li>
~RET %不活~文書
◎
Set doc to doc's associated inert template document.
</li>

</ol>

<p>
この~algoの目的においては、各 `文書$には，自身の`~template内容$を保持するための
`不活~template文書@
が結付けられる
— それは、`文書$か，または ε （存在しない）であり、必要に応じて作成される。
◎
↑</p>


<p class="note">注記：
したがって，この~algoにより作成されたものでない各 `文書$は、［
自身の `template$e 要素すべての`~template内容$
］を，［
それらが どの`閲覧文脈$にも属さず，不活であり続ける（例： ~scriptは走らせない）ようにする
］ために所有するための、代理として動作するような単独の`文書$
— `不活~template文書$ —
を取得する。
`不活~template文書$の内側にある `template$e 要素は、当面の間は`？^tnote
単に同じ`文書$を，その内容の所有者として再利用する。
◎
Each Document not created by this algorithm thus gets a single Document to act as its proxy for owning the template contents of all its template elements, so that they aren't in a browsing context and thus remain inert (e.g. scripts do not run). Meanwhile, template elements inside Document objects that are created by this algorithm just reuse the same Document owner for their contents.
◎
Return doc.
</p>


<p class="algo-head" id="template-adopting-steps">
`template$e 要素に対する`受入-時の手続き$は、所与の
( %~node, %旧-文書 )
に対し，次を走らす：
◎
The adopting steps (with node and oldDocument as parameters) for template elements are the following:
</p>

<ol>
	<li>
<p>
%文書 ~LET %~node の`~node文書$の`~template内容を所有する適切な文書$
◎
Let doc be node's node document's appropriate template contents owner document.
</p>

<p class="note">注記：
%~node の`~node文書$は、直前に %~node を受入した`文書$である。
<span class="trans-note">【
%旧-文書 ではなく（ %旧-文書 はこの手続きの中では利用されていない）。
】</span>
◎
node's node document is the Document object that node was just adopted into.
</p>

	</li>
	<li>
%~node の`~template内容$（ `文書片$ ）を
%文書 の中に`受入-$する
◎
Adopt node's template contents (a DocumentFragment object) into doc.
</li>

</ol>

<p>
`content@m
~IDL属性
`template$e 要素の`~template内容$を返さ~MUST。
◎
The content IDL attribute must return the template element's template contents.
</p>

<hr>


<p class="algo-head">
`template$e 要素 %~node に対する`~clone時の手続き$は、所与の
( %複製, %~node, %文書, %~clone子孫~flag )
に対し，次の手続きを走らせ~MUST：
◎
The cloning steps for a template element node being cloned to a copy copy must run the following steps:
</p>

  <ol>
	<li>
~IF［
%~clone子孫~flag ~NEQ ~ON
］
⇒
~RET
◎
If the clone children flag is not set in the calling clone algorithm, abort these steps.
</li>
	<li>
%~node の`~template内容$の ~EACH ( 子 %子 ) に対し
⇒
［
( %文書, %~clone子孫~flag )
として
( %複製 の`~template内容$の`~node文書$, ~ON )
を与える下で、
%子 を`~clone$した結果
］を，
%複製 の`~template内容$に付加する
◎
Let copied contents be the result of cloning all the children of node's template contents, with document set to copy's template contents's node document, and with the clone children flag set.
◎
Append copied contents to copy's template contents.
</li>
</ol>



<div class="example">

<p>
次の例の~scriptは、要素~構造を提供する `template$e を利用して，
4 ~columnからなる~tableを ある~data構造からの~dataで拡充する
— 手動で~markupして構造を生成する代わりに：
◎
In this example, a script populates a table four-column with data from a data structure, using a template to provide the element structure instead of manually generating the structure from markup.
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;html lang='en'&gt;
&lt;title&gt;Cat data&lt;/title&gt;
&lt;script&gt;
 // <span class="comment">
ここでは~dataを直に記しているが、~serverから得るようにすることもできる。
◎
Data is hard-coded here, but could come from the server
</span>
 var %data = [
   {
      name: 'Pillar',
      color: 'Ticked Tabby',
      sex: 'Female (neutered)',
      legs: 3
   },
   {
      name: 'Hedral',
      color: 'Tuxedo',
      sex: 'Male (neutered)',
      legs: 4
   },
 ];
&lt;/script&gt;
&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th&gt;Name &lt;th&gt;Colour &lt;th&gt;Sex &lt;th&gt;Legs
 &lt;tbody&gt;
  &lt;template id="row"&gt;
   &lt;tr&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;&lt;td&gt;
  &lt;/template&gt;
&lt;/table&gt;
&lt;script&gt;
 var %template = document.querySelector('#row');
 for (var %i = 0; %i &lt; %data.length; %i += 1) {
   var %cat = %data[i];
   var %clone = %template.content.cloneNode(true);
   var %cells = %clone.querySelectorAll('td');
   %cells[0].textContent = %cat.name;
   %cells[1].textContent = %cat.color;
   %cells[2].textContent = %cat.sex;
   %cells[3].textContent = %cat.legs;
   %template.parentNode.appendChild(%clone);
 }
&lt;/script&gt;
</pre>

<p>
この例では、
`template$e の内容~上で `cloneNode()$m を利用しているが，同じことを行う
`document.importNode()$m を利用しても等価になる。
これらの~APIの唯一の相違は、いつ`~node文書$が更新されるかになる：
`cloneNode()$m では， `appendChild()$m で~nodeが付加されるとき ／
`document.importNode()$m では，~nodeが~cloneされるときに更新される。
◎
This example uses cloneNode() on the template's contents; it could equivalently have used document.importNode(), which does the same thing. The only difference between these two APIs is when the node document is updated: with cloneNode() it is updated when the nodes are appended with appendChild(), with document.importNode() it is updated when the nodes are cloned.
</p>

</div>

			<section id="template-XSLT-XPath">
<h4 title="Interaction of template elements with XSLT and XPath">4.12.3.1. `template$e 要素と XSLT, XPath との相互作用</h4>

~INFORMATIVE

<p>
この仕様は、~XSLTと `template$e 要素とが，どう相互作用するかは定義しない。
しかしながら、これを実際に定義している別の仕様が不在の下での、既存の実装に基づく，実装者に対するいくつかの指針をここに述べる。
これらの指針は、この仕様に述べる他の処理と整合するように意図されている：
◎
This specification does not define how XSLT and XPath interact with the template element. However, in the absence of another specification actually defining this, here are some guidelines for implementors, which are intended to be consistent with other processing described in this specification:
</p>

  <ul>
	<li>
［
この仕様に述べるように動作する`~XML構文解析器$
］に基づく~XSLT処理器は、変形-の目的0においては，［
`template$e 要素が その`~template内容$の子孫を包含していた
］かのように動作する必要がある。
◎
An XSLT processor based on an XML parser that acts as described in this specification needs to act as if template elements contain as descendants their template contents for the purposes of the transform.
</li>
	<li>
~DOMを出力する~XSLT処理器は、［
`template$e 要素の中へ行く~nodeが，要素の`~template内容$の中に配置される
］ことを確保する必要がある。
◎
An XSLT processor that outputs a DOM needs to ensure that nodes that would go into a template element are instead placed into the element's template contents.
</li>
	<li>
~XPath~DOM~APIを利用する~XPath評価は，［
この仕様に述べる［
`~HTML構文解析器$ ／ `~XML構文解析器$
］を利用して構文解析された`文書$
］に適用されるときは、`~template内容$を無視する必要がある。
◎
XPath evaluation using the XPath DOM API when applied to a Document parsed using the HTML parser or the XML parser described in this specification needs to ignore template contents.
</li>

</ul>

			</section>
		</section>
		<section id="the-slot-element">
<h3 title="The slot element">4.12.4. `slot^e 要素</h3>

<dl class="element-def">

	<dt>`分類$：</dt>
	<dd>
`~flow内容$ ／ `句内容$
◎
Flow content.
◎
Phrasing content.
</dd>

	<dt>`この要素を利用できる文脈$：</dt>
	<dd>
`句内容$が期待される所。
◎
Where phrasing content is expected.
</dd>

	<dt>`内容~model$：</dt>
	<dd>`透過的$
◎
Transparent
</dd>

	<dt>`text/html における~tag省略$：</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$：</dt>
	<dd>`大域~属性$
◎
Global attributes
</dd>
	<dd>
`name$a
— `~shadow木$の`~slot$の`~slot名$
◎
name — Name of shadow tree slot
</dd>

	<dt>`~DOM~interface$：</dt>
	<dd>

<pre class="idl">
[`HTMLConstructor$]
interface `HTMLSlotElement@I : `HTMLElement$I {
  [`CEReactions$] attribute DOMString `name$m;
  sequence&lt;Node&gt; `assignedNodes$m(optional `AssignedNodesOptions$I %options);
};

dictionary `AssignedNodesOptions@I {
  boolean flatten = false;
};
</pre>
	</dd>
</dl>


<p>
`slot$e 要素は、`~slot$を定義する。
それは概して，`~shadow木$に利用される。
`slot$e 要素は、それに`割当されている~nodeたち$が［
あれば それら ／
なければ自身の内容
］を`表現-$する。
◎
The slot element defines a slot. It is typically used in a shadow tree. A slot element represents its assigned nodes, if any, and its contents otherwise.
</p>

<p>
`name@a
内容~属性が包含する値は、どのような文字列でも~MAY。
それは、`~slot$の`~slot名$を表現する。
◎
The name content attribute may contain any string value. It represents a slot's name.
</p>

<dl class="domintro">

	<dt>%~slot . `name$m</dt>
	<dd>
%~slot の`~slot名$を取得したり設定するために利用できる。
◎
Can be used to get and set slot's name.
</dd>

	<dt>%~slot . `assignedNodes(options)$m</dt>
	<dd>
<p>
%options の `flatten^m ~member値に応じて：
</p>
		<ul>
			<li>
~F ならば、
%~slot に`割当されている~nodeたち$を返す。
</li>
			<li>
~T ならば、
%~slot に`割当されている~nodeたち$が［
あれば それら ／
なければ %~slot の子たち
］に加えて、それらに含まれる各 `slot$e 要素に対しても，
`slot$e 要素が尽きるまで，再帰的に同じことをして得られる~nodeたちを返す。
</li>
		</ul>
◎
Returns slot's assigned nodes.
◎
slot . assignedNodes({ flatten: true })
◎
Returns slot's assigned nodes, if any, and slot's children otherwise, and does the same for any slot elements encountered therein, recursively, until there are no slot elements left.
</dd>

</dl>

<p>
`name@m
~IDL属性は、同じ名前の内容~属性を`反映-$し~MUST。
◎
The name IDL attribute must reflect the content attribute of the same name.
</p>

<p>
`assignedNodes(options)@m
~methodの被呼出時には、次の手続きを走らせ~MUST：
◎
The assignedNodes(options) method, when invoked, must run these steps:
</p>

  <ol>
	<li>
~IF［
%options の `flatten^m ~member値 ~EQ ~F
］
⇒
~RET この要素に`割当されている~nodeたち$
◎
If the value of options's flatten member is false, then return this element's assigned nodes.
</li>
	<li>
~RET この要素から`平坦化された~slotableたちを見出-$した結果
◎
Return the result of finding flattened slotables with this element.
</li>
</ol>



		</section>
		<section id="the-canvas-element">
<h3 title="The Canvas element">4.12.5. `canvas^e 要素</h3>

<p class="trans-note">【
この節の和訳は、当面の間，省略する。
】</p>

		</section>
	</section>
</main>


