<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>URL Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>
<!-- 

([^"#=\r\.:@\$-])utf-8
	$1UTF-8
 -->

<!--%script -->
<script>
var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://url.spec.whatwg.org/',
		main: 'MAIN',
		fill_text_link: '#references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //検証済 151012

	return options;
}

function expand(mapping1){

	var class_map = {
		E: 'error',
		st: 'parser-state',
		V: 'ref',
		U: 'code-point',
		X: 'hex-value',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		c: 'code',
		st: 'span',
		V: 'var',
		U: 'span',
		X: 'span',
		lb: 'i',
		i: 'i',
	};

	var link_map = this.link_map;
	var nesting = '';
	var context_ifc = '#dom-url-'

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
/[❝❛].|⇒|◎[^<◎]*|%[~\w\-一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>';
	case '❝':
		return '"<code class="literal" title="U+00'
			+ match.charCodeAt(1).toString(16).toUpperCase()
			+ '">' + match[1] + '</code>"';
	case '❛':
		return '`<code class="bytes">' + match[1] + '</code>`';
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}
	var result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'bl': // literal bytes
	text = '`<code class="bytes">' + text + '</code>`';
	break;
case 'U': // Unicode code point
	text = 'U+' + text;
	break;
case 'X': // byte value
	text = '0x' + text;
	break;
case 'st': // parser state
	text += ' <small>state</small>';
	break;
case 'I':
	if( indicator === '@' && key === 'URLSearchParams' ){
		context_ifc = '#dom-urlsearchparams-'
	}
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = context_ifc + key.toLowerCase();
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
dom-urlsearchparams-stringifier:urlsearchparams-stringification-behavior
dom-url-stringifier:url-stringification-behavior

	url-cannot-be-a-base-url-flag:non-relative-flag
	cannot-be-a-base-url-path-state:non-relative-path-state
	shorten-a-urls-path:pop-a-urls-path

ipv6piece:
	concept-urlencoded:application-x-www-form-urlencoded-0
</script>

<!--% リンク置換データ -->

<script type="text/plain" id="_link_map">

	●IDL
Exposed:~WEBIDL#Exposed
SameObject:~WEBIDL#SameObject
I.URL:#url
I.URLSearchParams:#urlsearchparams
	m.xxXx#dom-url-xxxx
	m.xxXx#dom-urlsearchparams-xxxx
I.EventSource:~HTML5/comms.html#eventsource
I.HashChangeEvent:~HTML5/browsers.html#hashchangeevent
I.Blob:~FILEAPI#blob
I.MediaSource:https://w3c.github.io/media-source/#idl-def-MediaSource
I.MediaStream:https://www.w3.org/TR/mediacapture-streams/#idl-def-MediaStream



	＊class="ref"
V.残部:#remaining
V.C:#c
V.~piece:#ipv6piece

~ASCII英字:#ascii-alpha
~ASCII英数字:#ascii-alphanumeric
~ASCII数字:#ascii-digits
~ASCII~hex数字:#ascii-hex-digits
~ASCII文字列:#ascii-string
~ASCII小文字化:#ascii-lowercase
~tabや改行:#tab-and-newline
~C0制御文字:#c0-controls
~C0制御文字や~space:#c0-controls-and-space
~drive_letter:#windows-drive-letter
正規化済み~drive_letter:#normalized-windows-drive-letter

直列化-:#serialize-an-integer
短縮-:#shorten-a-urls-path

	＊clear:#clear
絶対~URL:#concept-absolute-url
基底~URL:#concept-base-url

妥当な~domain:#valid-domain

~domain:#concept-domain
~ASCIIへ変換-:#concept-domain-to-ascii
~Unicodeへ変換-:#concept-domain-to-unicode

~host:#concept-host
~host構文解析器:#concept-host-parser
~host直列化器:#concept-host-serializer

~IPv4~address:#concept-ipv4
~IPv4構文解析器:#concept-ipv4-parser
~IPv4番号~構文解析器:#ipv4-number-parser
~IPv4直列化器:#concept-ipv4-serializer

~IPv6~address:#concept-ipv6
~IPv6構文解析器:#concept-ipv6-parser
~16-bit~piece:#concept-ipv6-piece
~IPv6直列化器:#concept-ipv6-serializer

相対~URL:#concept-relative-url
~scheme相対~URL:#concept-scheme-relative-url
局所~scheme:#local-scheme
局所的:#is-local

基本~URL構文解析器:#concept-basic-url-parser


~URL:#concept-url
~URL~record:#concept-url
url.~URL構文解析器:#concept-url-parser
url.生成元:#concept-url-origin
url.素片:#concept-url-fragment
url.~host:#concept-url-host
url.~username:#concept-url-username
url.~password:#concept-url-password
url.~path:#concept-url-path
url.~port:#concept-url-port
url.~query:#concept-url-query
url.~scheme:#concept-url-scheme
url.~URL直列化器:#concept-url-serializer
url.~obj:#concept-url-object
url.~url:#concept-url-url
url.~query~obj:#concept-url-query-object

syn.~URL:#syntax-url
~URL文字列:#syntax-url
syn.~host:#syntax-host
syn.~domain:#syntax-host-domain
syn.~IPv4~address:#syntax-host-ipv4
syn.~IPv6~address:#syntax-host-ipv6

syn.素片~付き絶対~URL:#syntax-url-absolute-with-fragment
syn.素片~付き相対~URL:#syntax-url-relative-with-fragment
syn.絶対~URL:#syntax-url-absolute
syn.~scheme:#syntax-url-scheme
syn.相対~URL:#syntax-url-relative
syn.~scheme相対~URL:#syntax-url-scheme-relative
syn.~scheme相対 file ~URL:#syntax-url-file-scheme-relative
syn.~path絶対 非 Windows file ~URL:#syntax-url-file-path-absolute
syn.~port:#syntax-url-port
syn.~path絶対~URL:#syntax-url-path-absolute
syn.~path相対~URL:#syntax-url-path-relative
syn.~path相対 ~schemeなし~URL:#syntax-url-path-relative-scheme-less
syn.~path区分:#syntax-url-path-segment
syn.二重dot~path区分:#syntax-url-path-segment-dotdot
syn.単dot~path区分:#syntax-url-path-segment-dot
syn.~query:#syntax-url-query
syn.素片:#syntax-url-fragment

host.等しい:#concept-host-equals
等しい:#concept-url-equals

~HTTP_S~scheme:#http-scheme
~network~scheme:#network-scheme
~fetch~scheme:#fetch-scheme
特別~scheme:#special-scheme
特別:#is-special

資格証明情報を含む:#include-credentials
~usernameを設定する:#set-the-username
~passwordを設定する:#set-the-password


更新~手続き:#concept-urlsearchparams-update
~url~obj:#concept-urlsearchparams-url-object
＊
新たな~URLSearchParams~objを作成-:#concept-urlsearchparams-new
名値~組~list:#concept-urlsearchparams-list

~FORMENC:#concept-urlencoded
~FORMENC文字列~構文解析器:#concept-urlencoded-string-parser
~FORMENC構文解析器:#concept-urlencoded-parser
~FORMENC直列化器:#concept-urlencoded-serializer
~FORMENC~byte直列化器:#concept-urlencoded-byte-serializer

構文違反:#syntax-violation

	●URL 構文解析器

st.~scheme開始-:#scheme-start-state
st.~scheme:#scheme-state
st.~schemeなし:#no-scheme-state
st.特別 相対/権限:#special-relative-or-authority-state
st.~path/権限:#path-or-authority-state
st.相対:#relative-state
st.相対~slash:#relative-slash-state
st.特別 権限~slash:#special-authority-slashes-state
st.特別 権限~slash無視:#special-authority-ignore-slashes-state
st.権限:#authority-state
st.~host:#host-state
st.~hostname:#hostname-state
st.~file~host:#file-host-state
st.~file:#file-state
st.~file~slash:#file-slash-state
st.~port:#port-state
st.~path開始-:#path-start-state
st.~path:#path-state
st.~cannot-be-a-base-URL~path:#cannot-be-a-base-url-path-state
st.~query:#query-state
st.素片:#fragment-state

i.EOF:#eof-code-point

既定の符号化集合:#default-encode-set
単純 符号化集合:#simple-encode-set
~userinfo 符号化集合:#userinfo-encode-set

既定~port:#default-port
~percent復号-:#percent-decode
~percent符号化:#percent-encode
~percent符号化済~byte:#percent-encoded-byte
~UTF-8~percent符号化:#utf-8-percent-encode

~cannot-be-a-base-URL~flag:#url-cannot-be-a-base-url-flag

~URL単位:#url-units
~URL~cp:#url-code-points

	• GOTO label
lb.Main:#concept-ipv6-parser-main
lb.IPv4:#concept-ipv6-parser-ipv4
lb.Finale:#concept-ipv6-parser-finale


	●ENCODING
~ASCII~byte:~ENCODING#ascii-byte
符号化方式を取得-:~ENCODING#concept-encoding-get
出力~符号化方式を取得-:~ENCODING#get-an-output-encoding
復号器:~ENCODING#decoder
復号-:~ENCODING#decode
符号化:~ENCODING#encode
符号化方式:~ENCODING#encoding
名前:~ENCODING#name
符号化器:~ENCODING#encoder
文字列:~ENCODING#string
~UTF-8:~ENCODING#utf-8
	~UTF-8復号器:~ENCODING#utf-8-decoder
	~UTF-8復号:~ENCODING#utf-8-decode
~BOMを取扱わずに~UTF-8復号-:~ENCODING#utf-8-decode-without-bom
~BOMも失敗-も取扱わずに~UTF-8復号-:~ENCODING#utf-8-decode-without-bom-or-fail
~UTF-8符号化:~ENCODING#utf-8-encode

	●他
~ASCII大小無視:~DOM4#ascii-case-insensitive
文脈~obj:~DOM4#context-object
生成元:~BROWSERS#concept-origin
不透明な生成元:~BROWSERS#concept-origin-opaque
同一生成元:~BROWSERS#same-origin
~Unicode直列化:~BROWSERS#unicode-serialisation-of-an-origin
blob ~URL store:~FILEAPI#BlobURLStore
StructuredClone:~HTMLcloning#structuredclone
反復される値の組たち:~WEBIDL#dfn-value-pairs-to-iterate-over
~Unicode ToASCII:http://www.unicode.org/reports/tr46/#ToASCII
~Unicode ToUnicode:http://www.unicode.org/reports/tr46/#ToUnicode


</script>


<!--% 置換データ -->

<script type="text/plain" id="words_table1">
URLSearchParams: <code>URLSearchParams</code> 
FORMENC:<code>application/x-www-form-urlencoded</code> 
APPEND: <span class="op">&lt;&lt;</span> 
BR:；<br>
此れ:<b>これ°</b>
</script>

<!--% 語彙置換データ

	U: ∪
-->

<script type="text/plain" id="words_table">
algo:algorithm:::アルゴリズム
obj:object:::オブジェクト
access::::アクセス
ifc:interface:::インタフェース
meth:method:::メソッド
member::::メンバ
list::::リスト
長th:length:長さ
_charset_:
buffer::::バッファ
URL:
ASCII:
HTML:
BOM:
UTF-8:
16-bit:
IPv6:
IPv4:
C0:
file:
url:
HTTP_S:HTTP(S)
Unicode:
filename::::ファイル名
link::::リンク

	失敗:failure
	成功:success
残部:remaining::~
	実行
属性:attribute::~
名前:name::~
名:name::~
値:value::~
名値:name-value: ( 名, 値 ) 
	組:pair／tuple
	pair::ペア
成分組:tuple::~
optional::オプション
省略可:optional:~::オプション

新たな:new::~
例外:exception::~
投出-:throw::~
構築子:constructor::~::コンストラクタ
取得-:get::~
取得子:getter::~
設定子:setter::~
被呼出時:被 invoke 時:~

付加-:append::~
追加-:add::~

	の先頭に~~付加:prepend:~
正準化:canonicalization::~
byte::::バイト
bytes::::バイト列
data::::データ
flag::::フラグ
address::::アドレス
hex::16 進
短縮-:shorten::~
変換-:convert::~
変換:conversion::~
順序付けら:order さ:~
圧縮:compress::~


cp:code point::符号位置::コードポイント
大小無視:case-insensitive::~
文字:character::~
空白類:whitespace::~
space::::スペース
tab::::タブ
改行:newline::~
制御文字:controls::~
英数字:alphanumeric::~
英字:alpha::~
数字:digits::~
基数:radix::~
番号:number::~
整数:integer::~
小文字化:lowercase 化::~
小文字:lowercase::~
大文字:uppercase::~
文字列:string::~
文字列化:stringification::~
部分文字列:substring::~
空:empty:~
正規化済み:normalized::~
	BOM-or-fail:fail

符号化:encode::~::エンコード
符号化済:encoded::符号化済み::エンコード済み
符号化方式:encoding::~::エンコーディング
符号化器:encoder::~::エンコーダ
上書符号化方式:encoding override::上書き符号化方式::上書きエンコーディング
上書state:state override::上書き state

符号化集合:encode set::~::エンコードセット
単純:simple::~
復号-:decode::~::デコード
復号器:decoder::~::デコーダ

基底:base::~
	ベース
cannot-be-a-base-URL:::基底 URL 不可用
record::::レコード
scheme::::スキーム
局所的:local::~::ローカル
局所:local::~::ローカル
userinfo::::ユーザ情報
username::::ユーザ名
password::::パスワード
domain::::ドメイン
label::::ラベル
host::::ホスト
hostname::::ホスト名
権限:authority::~
realm::::レルム
	authority:::権限
port::::ポート
query::::クエリ
path::::パス
素片:fragment::~::フラグメント
素片除外:exclude fragment:fragment 除外:~::フラグメント除外
除外-:exclude:~
dot:::ドット
単dot:single-dot::単 dot:単ドット
二重dot:double-dot::二重 dot:二重ドット
区分:segment::~
percent::::パーセント
drive_letter:Windows drive letter:::Windows ドライブレター

区切子:separator::~

解析済:parsed::解析済み::パース済み
構文解析器:parser::~::パーサ
構文解析:parse::~::パース
構文解析法:parsing::~::パース法
構文違反:syntax violation::~
違反:violation::~
	parsing:::構文解析
	parse:::構文解析
	parsed:::解析済み
直列化:serialization::~::シリアル化
直列化-:serialize::~::シリアライズ
	シリアル化
直列化器:serializer::~::シリアライザ
	直列化物:serialization::直列化::シリアライズ
直列化法:serializing::~::シリアライズ法
	serialized:::直列化
反復-:iterate over:~
絶対:absolute::~
相対:relative::~

既定:default::~::デフォルト
既定の:default::~::デフォルト
相対的:relative::~
単位:unit::~
特別:special::~

piece:::片
slash::::スラッシュ
stream::::ストリーム
pointer::::ポインタ
error::::エラー
input:::入力
入力:input:~
出力:output:~

更新:update::~
前更新:pre-update::前-更新
状態機械:state machine:~
state:

生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン
大域:global::~::グローバル
識別子:identifier::~
識別-:identify::~
大域一意:globally unique::~::グローバル一意
不透明な:opaque::~

form::::フォーム
web::::ウェブ
browser::::ブラウザ
server::::サーバ
secure::::セキュア
network::::ネットワーク
networking::::ネットワーク処理
client::::クライアント
fetch:
target:

種別:type::~
	更なる分岐処理:dispatch ... for further processing
成分:component:~
資格証明情報:credentials::~::クレデンシャル
階層的:hierarchical:~
所在:location::~
保持-:hold:~
	-ing
資源:resource::~::リソース
	残りの部分remainder
	可能性potentially
entry::::エントリ
item::::アイテム
有構造:structured::~
clone::::クローン
	有構造~clone
分割-:split::~
置換-:replace::~
交換-:swap::~
除去-:remove::~
作成-:create::~
設定-:set::~
再設定-:reset::~::リセット
合致-:match::~
文書:document::~
開始-:start::~

内部的:internal::~
公開-:expose::~
変異不可の:immutable な::~
構造:structure:~
変種:variant:~
	decidesものとする

複合的:compound:~
初期:initial::~
初期化-:initialize::~
妥当:valid::~
基本:basic::~

	終了-:terminate:~
文脈:context::~

等価性:equivalence::~
等しい:equals::~
同等性:equality::~
比較:comparison::~
比較-:compare::~
zero::::ゼロ
protocol::::プロトコル
入子に:nest::入れ子に
変換:conversion::~
構文:syntax::~
生成規則:production::~
読専:readonly::読み取り専用
要素:element::~
形式:format::~
型:type::~
引数:argument::~
	集合:set:~

渡す:pass する:~
渡され:pass され:~
受取って:recieve して:~

取扱わず:取り扱わず

	●仕様
UA:user agent:UA:::ユーザエージェント
hooks::::フック
model::::モデル
platform::::プラットフォーム
registry::::レジストリ
support::::サポート
Web::::ウェブ
主流:majority:~
特色機能:feature:~
統一的:universal:~
統一化:unified:~
予測可能:predictable:~
互換性:compatibility:~
仕方:way:~
仕様:spec:~
依存-:depend:~
側面0:facet:側面
全部的:full:~
全部的な:full:~
共有-:share:~
利用者:user:~:::ユーザ
概して:typical に:~
命名-:name:~
命名:naming:~
報告-:report:~
外部:external:~
奨励-:encourage:~
定義-:define:~
定義:definition:~
実施:practice:~
実装-:implement:~
実装:implementation:~
市場:market share:~
強化-:enhance:~
意図的:intentional:~
所与の:given:与えられた
手続き:steps:~
指名され:designate され:指定を受け
挙動:behavior:ふるまい
提供-:provide:~
操作-:manipulate:~
施行-:enforce:~
既存の:existing:~
旧来の:legacy:~
明示的:explicit:~
有用:useful:~
検査:check:~
検査器:checker:~
概念:concept:~
標準:standard:~
標準化-:standard 化:~
	standardize
推奨-:recommend:~
推奨:recommendation:~
決定-:determine:~
決断:decisions:決定
無視-:ignore:~
現今の:contemporary:~
環境:environment:~
目標:goal:~
目的:purpose:~
相互運用可能:interoperable:~
相互運用性:interoperability:~
確定的:solid:~
示唆:suggestion:~
結付けら:associate さ:結び付けら
背景情報:background information:~
致命的:fatal:~
表現-:represent:~
表現:representation:~
要件:requirements:~
要求-:require:~
規定-:規定
規定:normative:~
規約:conventions:~
視野:scope:~:::スコープ
解釈-:interpret:~
設計:design:~
詳細:details:~
課題:issue:~
走らす:run する:走らせる
走らせ:run し:~
通例的:usual:~
過去互換対処:quirk:~
適切:appropriate:~
適合-:conform:~
	conforming
適合性:conformance:~
適正:proper:~
開発用console:developer console:開発用 console::開発用コンソール
開発者:developer:~
	より高次の観点からはhigher-level notion
	不幸な巡り合わせ:accidents
	仮想の:conceptual
	入力:input:~
	好ましい:preferred
	妥協の産物:compromises leading
	完全



	●保安
security::::セキュリティ
font::::フォント
bar::::バー
text::::テキスト
証明書:certificate:~
予期-:expect:~
具現化-:render:~
描画-:render:~
描画:rendering:~
描画法:rendering:~
	音声化-:render:~
	allocatingあてがう
考慮-:consider:~
攻撃:attack:~
	考えて:~
最善:best:~
濫用-:abuse:~
	なりすましspoofing
主体:party:~
注意深く:carefulに:~
漏洩-:leak:~
受取って::receive して:受け取って
害する:harm する:害を及ぼす
動作:action:~
信用:trust:~
源:source:~
役務:function:~
~~誤認-:mistake:~
誤認-:confuse:~
	作用-:interact:~
素の:plain:~
	酷似:appear eerily similar
	~~最低でもat the very least
	意に反するnot want to leak
考慮点:considerations:~
	注意するCare is to be taken
双方向的:bidirectional:~
	左横書き埋込み left-to-right embedding
	特化された:specific
	見込みが薄い:unlikely
判別-:distinguish:~
重要:important:~
	広範にwide
採用-:adopt:~
製品化-:produce:~
	受け入れる:embrace:~
不可視:invisible:~
不可視の:invisible な:~
濫用:abuse:~



</script>

<!-- 
扱い方
特有の
~~領域realm
取り組むapproach
に見られる:exhibit
~~機能するserves
欠く:lack する:~
見做して:assume して:~
現実
揃わせalign
~~拡がるincrease
指定を受ける

-->

<!--%style  -->

<style>
.bytes, 
.literal {
	color: #DD1111;
}

.parser-state {
	font-family: sans-serif0, sans-serif;
}

var.ref {
	text-decoration: underline;
}
.code-point,
.hex-value {
	font-family: sans-serif0, sans-serif;
}

code > dfn {
	color: inherit;
}

</style>

</head>


<body>

<!--%UI -->
<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">

<h1>URL Standard 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付 時点の
<a href="https://url.spec.whatwg.org/">URL Standard</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-10-29</time> （公開： <time>2012-10-20</time>）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>



<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDUiIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzNjNzkwYSIgc3Ryb2tlLXdpZHRoPSIxMCIvPgo8cGF0aCBkPSJtNDUsMzFoMTB2MTBoLTEwem0wLDI4aDEwdjEwaC0xMCIgZmlsbD0iIzNjNzkwYSIvPgo8L3N2Zz4K"
></a>

	<hgroup>
<h1>URL</h1>
<h2>Living Standard — 最終更新 2016 年 10 月 28 日</h2>
	</hgroup>

<dl>
	<dt>Participate:</dt>
	<dd><a href="https://github.com/whatwg/url">GitHub whatwg/url</a> (<a href="https://github.com/whatwg/url/issues/new">new issue</a>, <a href="https://github.com/whatwg/url/issues">open issues</a>, <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WHATWG&amp;component=URL&amp;resolution=---">legacy open bugs</a>)</dd>
	<dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/url/commits">https://github.com/whatwg/url/commits</a></dd>
	<dd><a href="https://twitter.com/urlstandard">@urlstandard</a></dd>

	<dt>各国語翻訳（非規範的）</dt>
	<dd>日本語（このページ）</dd>

</dl>

</header>


<div id="MAIN" style="display:none;">



<h2 id="abstract">要約</h2>
<p>
URL 標準は、［
~URL, ~domain, IP ~address, ~FORMENC形式,
］および それらの API を定義する。
◎
The URL Standard defines URLs, domains, IP addresses, the application/x-www-form-urlencoded format, and their API.
</p>

<main id="MAIN0">

	<section id="goals">
<h2 title="Goals">目標</h2>

<p>
URL 標準は、次のように取り~~組むことにより，~URLを全部的に相互運用可能にすることを目指す：
◎
The URL standard takes the following approach towards making URLs fully interoperable:
</p>

<ul>
	<li>
RFC 3986 と RFC 3987 を現今の実装に揃わせて、その過程の中でそれらを過去のものにする。
（例えば、空白類, 他の “合法でない” ~cp, ~queryの符号化方式, 同等性, 正準化, などの概念は、どれも~~完全には共有-もしくは定義されていない。）
~URLの構文解析法は HTML の構文解析法と同程度に確定的になる必要がある。
`RFC3986$r
`RFC3987$r
◎
Align RFC 3986 and RFC 3987 with contemporary implementations and obsolete them in the process. (E.g., spaces, other "illegal" code points, query encoding, equality, canonicalization, are all concepts not entirely shared, or defined.) URL parsing needs to become as solid as HTML parsing. [RFC3986] [RFC3987]
</li>
	<li>
語~URLを標準化する。
URI と IRI は混同され易い。
実施においては，どちらに対しても同じ~algoが利用されるので、それらを区別する利点は無い。
<a href="http://www.googlefight.com/index.php?word1=url&amp;word2=uri">~Webの検索結果</a>
でも~URLの方が優位にある。
◎
Standardize on the term URL. URI and IRI are just confusing. In practice a single algorithm is used for both so keeping them distinct is not helping anyone. URL also easily wins the search result popularity contest.
</li>
	<li>
<a href="~IETF/rfc6454#section-4">URI [sic] の生成元</a>
`RFC6454$r
に取って代わる。
◎
Supplanting Origin of a URI [sic]. [RFC6454]
</li>
	<li>
~URLの既存の JavaScript API における全部的な詳細を定義し、より扱い易くなる様に~~機能を強化する。
また、~HTML要素を通さずに~URLを操作できるようにする（ JavaScript worker 環境からも有用にする）ため，
`URL$I ~objを新たに追加する。
◎
Define URL’s existing JavaScript API in full detail and add enhancements to make it easier to work with. Add a new URL object as well for URL manipulation without usage of HTML elements. (Useful for JavaScript worker environments.)
</li>
</ul>

<p class="note">注記：
編集者たちがこの~~主題に関しより多くを学ぶに連れ、目標となる視野は~~拡がるかもしれない。
◎
As the editors learn more about the subject matter the goals might increase in scope somewhat.
</p>

	</section>

	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（
~LET, 此れ, ε, ~INCBY, { <var>…</var> }, ~IF, ~THROW, 等々
）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<ul>
	<li>
記号 ~INCBY, ~DECBY は，~stream／配列~内の位置を指す~pointerの増減操作に特に用いられる。
</li>
	<li>
集合の表記（ { <var>…</var> } ）は、ほとんどが~cpの集合または~byte値の集合に用いられる。
</li>
	<li>
入子にされた集合については、和集合をとることを意味する。
例えば，~cpの集合 %S, ~cp %t に対する { %S, %t } は、 %S と { %t } の和集合を意味する。
</li>
</ul>

<p>
加えて、次の記法も用いる：
</p>

<dl>
	<dt>%s ~APPEND %a ~APPEND %b ~APPEND …</dt>
	<dd>
左辺の［
文字列／~byte列
］ %s の末尾に後続の［
文字列／~byte列
］ %a, %b, … を示された順に付加する演算を表す。
式として用いられた場合、結果の %s が式の値になる。
</dd>

	<dt>`failure^i</dt>
	<dd>
（この訳~固有の表記ではないが）
この仕様にて定義される種々の~algoにおいて，通常~期待されている値を返せないときに返される，~~特別な値（当の処理が失敗に終わったことを意味する）。
</dd>
</dl>

	</section>

	<section id="infrastructure">

<h2 title="Infrastructure">1. 基盤</h2>

<p>
この仕様に利用される一部の用語は、各種 標準：
DOM, Encoding, IDNA, WEBIDL
にて定義される。
`DOM$r
`ENCODING$r
`IDNA$r
`WEBIDL$r
◎
Some terms used in this specification are defined in the DOM, Encoding, IDNA, and Web IDL Standards. [DOM] [ENCODING] [IDNA] [WEBIDL]
</p>

<p>
次の各種 ~cpの集合が定義される：
</p>

<dl class="def-list">
	<dt>`~C0制御文字@</dt>
	<dd>
{ `0000^U 〜 `001F^U }
◎
The C0 controls are code points in the range U+0000 to U+001F, inclusive.
</dd>

	<dt>`~C0制御文字や~space@</dt>
	<dd>
{ `~C0制御文字$, `0020^U }
◎
The C0 controls and space
are C0 controls and code point U+0020.
</dd>

	<dt>`~tabや改行@</dt>
	<dd>
{ `0009^U, `000A^U, `000D^U }
◎
The tab and newline are code points U+0009, U+000A, and U+000D.
</dd>

	<dt>`~ASCII数字@</dt>
	<dd>
{ `0030^U 〜 `0039^U }
◎
The ASCII digits are code points in the range U+0030 to U+0039, inclusive.
<!-- XXX ref Encoding? -->
</dd>

	<dt>`~ASCII~hex数字@</dt>
	<dd>
{ `~ASCII数字$, `0041^U 〜 `0046^U , `0061^U 〜 `0066^U }
◎
The ASCII hex digits are ASCII digits, code points in the range U+0041 to U+0046, inclusive, and code points in the range U+0061 to U+0066, inclusive.
</dd>

	<dt>`~ASCII英字@</dt>
	<dd>
{ `0041^U 〜 `005A^U , `0061^U 〜 `007A^U }
◎
The ASCII alpha are code points in the range U+0041 to U+005A, inclusive, and in the range U+0061 to U+007A, inclusive.
</dd>

	<dt>`~ASCII英数字@</dt>
	<dd>
{ `~ASCII数字$, `~ASCII英字$ }
◎
The ASCII alphanumeric are ASCII digits and ASCII alpha.
</dd>
</dl>

<p>
`~ASCII文字列@
は、範囲 { `0000^U 〜 `007F^U } に入る~cpからなる文字列である。
◎
An ASCII string is a string in the range U+0000 to U+007F, inclusive.
</p>

<p class="algo-head">
`文字列$ %S を
`~ASCII小文字化@
するときは、 %S 内の各 ~cpのうち，範囲 { `0041^U 〜 `005A^U } に入るものを，範囲 { `0061^U 〜 `007A^U } の対応する~cpに置換する。
◎
To ASCII lowercase a string, replace all code points in the range U+0041 to U+005A, inclusive, with the corresponding code points in the range U+0061 to U+007A, inclusive.
</p>

<hr>

<p class="algo-head">
整数 %N を
`直列化-@
するときは、 %N を 10 進数で表現する最短の文字列を返す。
◎
To serialize an integer, represent it as the shortest possible decimal number.
</p>

<hr>

<p>
`~drive_letter@
とは、
2 個の~cp並び［
%C1, %C2
］であって，［［
%C1 ~IN `~ASCII英字$
］~AND［
%C2 ~IN { ❝:, ❝| }
］］なるものである。
◎
A Windows drive letter is two code points, of which the first is an ASCII alpha and the second is either ":" or "|".
</p>

<p>
`正規化済み~drive_letter@
とは、`~drive_letter$のうち，［
二番目の~cp ~EQ ❝:
］なるものである。
◎
A normalized Windows drive letter is a Windows drive letter of which the second code point is ":".
</p>


		<section id="parsers">

<h3 title="Parsers">1.1. 構文解析器</h3>

<p>
`EOF@i
とは、［
文字列~stream ／ ~cp~stream
］の終端を表す，
<span class="trans-note">【
自身以外のどの~cpにも等しくない
】</span>
仮想の~cpである。
◎
The EOF code point is a conceptual code point that signifies the end of a string or code point stream.
</p>

<p class="trans-note">【
“End Of File”
— この訳では、原文の “EOF ~cp” を単に “EOF” と略記する。
】</p>

<p>
記号
`C@V
は、（文字列~内の文字位置を指す） %~pointer 変数を利用する構文解析~algoの中で用いられ， %~pointer 変数が指している~cpを参照する。
◎
Within a parser algorithm that uses a pointer variable, c references the code point the pointer variable points to.
</p>

<p class="trans-note">【
日本語の字の大きさとの兼ね合いにより，この訳では、原文の小文字 "c" を大文字で記すことにする。
】</p>

<p>
また、記号
`残部@V
は、処理中の文字列の中の %~pointer より後の（ `C$V の次の~cp以降の）部分文字列を参照する。
◎
Within a string-based parser algorithm that uses a pointer variable, remaining references the substring after pointer in the string being processed.
</p>

<p class="example">
例えば、処理中の文字列が
"<code class="literal">mailto:username@example</code>"
で， %~pointer が ❝@ を指しているなら、
`C$V は ❝@ になり,
`残部$V は `example^l になる。
◎
If "mailto:username@example" is a string being processed and pointer points to "@", c is "@" and remaining is "example".
</p>

<p>
`構文違反@
とは、入力とそれに課される要件との間の，致命的でない不一致を意味する。
~UA，とりわけ適合性~検査器には、どこかへそれを報告することが奨励される。
◎
A syntax violation
indicates a non-fatal mismatch between input and syntax requirements. User agents, especially conformance checkers are encouraged to report them somewhere.
</p>

<p class="note">注記：
`構文違反$は、構文解析器を終了させるものではない。
構文解析器の終了は、常に，明示的にそう記される
— ~RET 文などにより。
◎
A syntax violation does not mean that the parser terminates. Termination of a parser is always stated explicitly. E.g., through a return statement.
</p>

		</section>
		<section id="percent-encoded-bytes">
<h2 title="Percent-encoded bytes">1.2. ~percent符号化済~byte</h2>

<p>
`~percent符号化済~byte@
とは、［
❝%, `~ASCII~hex数字$, `~ASCII~hex数字$
］の並びである。
［
`~percent符号化済~byte$を~byte列に変換した結果
］は、［
`~BOMも失敗-も取扱わずに~UTF-8復号-$したときに `failure^i が返される
］ことはない筈である。
◎
A percent-encoded byte is "%", followed by two ASCII hex digits. Sequences of percent-encoded bytes, after conversion to bytes, should not cause UTF-8 decode without BOM or fail to return failure.
</p>

<p class="algo-head">
1 個の~byte %~byte を，`~percent符号化済~byte$に
`~percent符号化@
するときは、次を返す
⇒
❝% ~APPEND ［
%~byte の 16 進~表現（２桁, 大文字を利用）
］
◎
To percent encode a byte into a percent-encoded byte, return a string consisting of "%", followed by a double-digit, uppercase, hexadecimal representation of byte.
</p>

<p class="algo-head">
~byte列 %入力 を
`~percent復号-@
するときは、次を走らす：
◎
To percent decode a byte sequence input, run these steps:
</p>

<p class="warning">警告：
［［
`~ASCII~byte$の以外の~byte
］が含まれ得るような %入力
］に対する
`~BOMを取扱わずに~UTF-8復号-$する以外の利用は，~secureでないこともあるので、推奨されない。
◎
Using anything but UTF-8 decode without BOM when the input contains bytes that are not ASCII bytes might be insecure and is not recommended. 
</p>

<ol>
	<li>
%出力 ~LET 空~byte列
◎
Let output be an empty byte sequence.
</li>
	<li>
<p>
~FOR
%入力 内の~EACH ( ~byte %~byte ) に対し：
</p>

		<ol>
			<li>
<p>
~IF［
次のいずれも満たされる
］ならば…：
</p>

<ul><li>%~byte ~EQ ❛%
</li><li>%入力 内に， %~byte に後続する~byteが 2 個~以上ある
— 以下、その 2 個の~byteが成す~byte列を %~byte列 と記す
</li><li>%~byte列 を成すどの~byteも，
{ `30^X 〜 `39^X, `41^X 〜 `46^X, `61^X 〜 `66^X }
に含まれる
</li></ul>

<p>
…ならば：
</p>

				<ol>
					<li>
%出力 ~APPEND ［
次で与えられる数を値とする~byte
］
⇒
［
%~byte列 を`~BOMを取扱わずに~UTF-8復号-$した結果
］の文字列を 16 進数として解釈した結果の数
</li>
					<li>
~CONTINUE — ただし， %~byte列 を成す各~byteの反復は飛ばす
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%出力 ~APPEND %~byte
</li>
		</ol>

<div lang="en">
<p>
For each byte byte in input, run these steps:
</p>
		<ol>
			<li>
If byte is not `%`, append byte to output.
</li>
			<li>
Otherwise, if byte is `%` and the next two bytes after byte in input are not in the ranges 0x30 to 0x39, 0x41 to 0x46, and 0x61 to 0x66, append byte to output.
</li>
			<li>
Otherwise, run these substeps:
				<ol>
					<li>
Let bytePoint be the two bytes after byte in input, decoded, and then interpreted as hexadecimal number.
					<!-- We should have a definition for this that is saner. -->
</li>
					<li>
Append a byte whose value is bytePoint to output.
</li>
					<li>
Skip the next two bytes in input.
</li>
				</ol>
			</li>
		</ol>
</div>

	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p>
`単純 符号化集合@
は、~cpの集合 { `~C0制御文字$, `007F^U 〜 `10FFFF^U } である。
◎
The simple encode set are C0 controls and all code points greater than U+007E.
</p>

<p>
`既定の符号化集合@
は、~cpの集合  {
`単純 符号化集合$,
`0020^U,
❝",<!-- 0x22 -->
❝#,<!-- 0x23 -->
`&lt;^l,<!-- 0x3C -->
`&gt;^l,<!-- 0x3E -->
❝?,<!-- 0x3F -->
❝`,<!-- 0x60 -->
❝},<!-- 0x7B -->
❝{<!-- 0x7D -->
} である。
◎
The default encode set is the simple encode set and code points U+0020, '"', "#", "&lt;", "&gt;", "?", "`", "{", and "}".
</p>

<p>
`~userinfo 符号化集合@
は、~cpの集合  {
`既定の符号化集合$,
❝/, <!-- 0x2F -->
❝:,
❝;,
❝=,
❝@, <!-- 0x40 -->
❝[,
❝\, <!-- 0x5C -->
❝],
❝^,
❝|
} である。
◎
The userinfo encode set is the default encode set and code points "/", ":", ";", "=", "@", "[", "\", "]", "^", and "|".
</p>

<p class="algo-head">
~cpの集合 %符号化集合 を用いて， 1 個の %~cp を
`~UTF-8~percent符号化@
するときは、次を走らす：
◎
To UTF-8 percent encode a codePoint, using an encode set, run these steps:
</p>

<ol>
	<li>
~IF［
%~cp ~NIN %符号化集合
］
⇒
~RET %~cp
◎
If codePoint is not in encode set, return codePoint.
</li>
	<li>
%~byte列 ~LET %~cp を`~UTF-8符号化$した結果
◎
Let bytes be the result of running UTF-8 encode on codePoint.
</li>
	<li>
%結果 ~LET 空~文字列
◎
↓</li>
	<li>
%~byte列 内の~EACH ( %~byte ) に対し
⇒
%結果 ~APPEND ［
%~byte を`~percent符号化$した結果
］
◎
↓</li>
	<li>
~RET %結果
◎
Percent encode each byte in bytes, and then return the results concatenated, in the same order.
</li>
</ol>


		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security considerations">2. ~security上の考慮点</h2>

<p>
`~URL$の~securityは、その環境の役務である。
`~URL$を，周りに向けて描画する／渡す, あるいは 周りのそれを解釈するときには、注意すること。
◎
The security of a URL is a function of its environment. Care is to be taken when rendering, interpreting, and passing URLs around.
</p>

<p>
新たな`~URL$を描画したり，あてがうときは、
“なりすまし（ spoofing ）”
について考慮する必要がある。
`~host$／`~URL$ による攻撃は、誰かを誤認させる可能性がある。
例えば、
1/l/I, m/rn/rri, 0/O, а/a
は，どれも酷似するものになり得る†。
`202A^U 等々のような，より~~問題になる不可視の††~cpすらある。
`UTS36$r
◎
When rendering and allocating new URLs "spoofing" needs to be considered. An attack whereby one host or URL can be confused for another. E.g., consider how 1/l/I, m/rn/rrn, 0/O, and а/a can all appear eerily similar. Or worse, consider how U+202A and similar code points are invisible. [UTS36]
</p>

<p class="trans-note">【
ここでの “描画（ rendering ）” には、音声化なども含まれる
— その場合、発音が似るものに対し，同様のことが該当することになる。
】【†
一般的には見かけがかなり異なる文字でも、例えば，その場の環境にて可用な~fontに依存して酷似するかもしれない。
】【
非 英語話者にとっては、綴りや字形が異なっていても発音が似るがため，錯覚し易いものもあるかもしれない
— 例えば “correction” と “collection” 。
】【††
空間すら占めない。
】【
参考：
<a href="http://unicode.org/faq/idn.html">IDN FAQ</a>
】</p>

<p>
主体 %A から主体 %B へ`~URL$が渡されるときは、いずれの側も，何が起きるか注意深く考慮する必要がある。
%A は、意に反して~dataを漏洩するはめになり得る。
%B は、自身が予期していない入力を受取って利用者に害する動作をとる可能性がある。
特に、 %B は，決して %A を信用するべきでない
— 渡される`~URL$は，常に信用できる源に~~由来するとは限らないので。
◎
When passing a URL from party A to B, both need to carefully consider what is happening. A might end up leaking data it does not want to leak. B might receive input it did not expect and take an action that harms the user. In particular, B should never trust A, as at some point URLs from A can come from untrusted sources.
</p>



	</section>
	<section id="hosts-(domains-and-ip-addresses)">
<h2 title="Hosts (domains and IP addresses)">3. ~host（~domainと IP ~address）</h2>

<!-- Punycode:
https://tools.ietf.org/html/rfc3492
http://mothereff.in/punycode -->

<p>
`~host@
とは、［
`~domain$ ／ `~IPv4~address$ ／ `~IPv6~address$
］のいずれかである。
`~host$は，概して~network~addressとして~~機能するが、~network~addressが必要とされない所では，`~URL$において，不透明な識別子として利用（または濫用）されるときもある。
◎
A host is a domain, an IPv4 address, or an IPv6 address. Typically a host serves as a network address, but it is sometimes (ab)used as opaque identifier in URLs where a network address is not necessary.
</p>

<p class="note">注記：
下の各 段落~内で参照されている RFC は、参考目的に限られる。
それらは、`~host$の構文, 構文解析法, 直列化には何ら波及しない。
以下の節にて他から定められない限り。
◎
The RFCs referenced in the paragraphs below are for informative purposes only. They have no influence on host syntax, parsing, and serialization. Unless stated otherwise in the sections that follow.
</p>


<p>
`~domain@
とは、~networkの中の~realmを識別するものである。
`RFC1034$r
◎
A domain identifies a realm within a network. [RFC1034]
</p>

<!-- 
<p class="trans-note">【
~realm — 認証における
<a href="https://tools.ietf.org/html/rfc7235#section-2.2">保護空間</a>
（ protection space ）を識別するもの（認証~~領域とも呼ばれる）。
】</p>
-->

<p>
`~IPv4~address@
は、 32-bit の識別子である。
`RFC791$r
◎
An IPv4 address is a 32-bit identifier. [RFC791]
</p>

<p>
`~IPv6~address@
は、 128-bit の識別子であり，この仕様の目的においては 8 個の
`~16-bit~piece@
の順序付けられた~listとして表現される。
`RFC4291$r
◎
An IPv6 address is a 128-bit identifier and for the purposes of this specification represented as an ordered list of eight 16-bit pieces. [RFC4291]
</p>

<p class="note">注記：
<code>&lt;zone_id&gt;</code> の~supportは、
<a href="~SPECBUGS?id=27234#c2">意図的に除かれている</a>。
◎
Support for &lt;zone_id&gt; is intentionally omitted.
</p>


		<section id="idna">
<h3 title="IDNA">3.1. IDNA</h3>

<p class="algo-head">
所与の`~domain$ %~domain を
`~ASCIIへ変換-@
するときは、次を走らす：
◎
The domain to ASCII given a domain domain, runs these steps:
</p>

<ol>
	<li>
%結果 ~LET 次を与える下で， `~Unicode ToASCII$ を走らせた結果
⇒
`domain_name^i ~SET %~domain ~BR
`UseSTD3ASCIIRules^i ~SET ~F ~BR
`processing_option^i ~SET `Transitional_Processing^i ~BR
`VerifyDnsLength^i ~SET ~F
◎
Let result be the result of running Unicode ToASCII with domain_name set to domain, UseSTD3ASCIIRules set to false, processing_option set to Transitional_Processing, and VerifyDnsLength set to false.
</li>
	<li>
~IF［
%結果 ~EQ `failure^i
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If result is a failure value, syntax violation, return failure.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="algo-head">
所与の`~domain$ %~domain を
`~Unicodeへ変換-@
するときは、次を走らす：
◎
The domain to Unicode given a domain domain, runs these steps:
</p>

<ol>
	<li>
%結果 ~LET 次を与える下で， `~Unicode ToUnicode$ を走らせた結果
⇒
`domain_name^i ~SET %~domain ~BR
`UseSTD3ASCIIRules^i ~SET ~F
◎
Let result be the result of running Unicode ToUnicode with domain_name set to domain, UseSTD3ASCIIRules set to false.
</li>
	<li>
~IF［
%結果 は~error
］
⇒
`構文違反$
◎
↓</li>
	<li>
<p>
~RET %結果
◎
Signify syntax violations for any returned errors, and then, return result.
</p>
	</li>
</ol>

		</section>
		<section id="host-syntax">
<h3 title="Host syntax">3.2. ~hostの構文</h3>

<div class="p">
<p>
<span class="trans-note">【
文字列としての
】</span>
`~host@syn
は、次のいずれかで~MUST：
</p>

<ul><li>`~domain$syn
</li><li>`~IPv4~address$syn
</li><li>
<p>
次の並び：
</p>
	<ol><li>❝[
	</li><li>`~IPv6~address$syn
	</li><li>❝]
	</li></ol>
</li></ul>

◎
A host must be a domain, an IPv4 address, or "[", followed by an IPv6 address, followed by "]".
</div>


<p class="algo-head">
次の手続きが `success^i を返すような %~domain は、
`妥当な~domain@
であるとされる：
◎
A domain is a valid domain if these steps return success:
</p>


<ol>
	<li>
%結果 ~LET 次を与える下で， `~Unicode ToASCII$ を走らせた結果
⇒
`domain_name^i ~SET %~domain ~BR
`UseSTD3ASCIIRules^i ~SET ~T ~BR
`processing_option^i ~SET `Nontransitional_Processing^i ~BR
`VerifyDnsLength^i ~SET ~T
◎
Let result be the result of running Unicode ToASCII with domain_name set to domain, UseSTD3ASCIIRules set to true, processing_option set to Nontransitional_Processing, and VerifyDnsLength set to true.
</li>
	<li>
~IF［
%結果 ~EQ `failure^i
］
⇒
~RET `failure^i
◎
If result is a failure value, return failure.
</li>
	<li>
%結果 ~SET 次を与える下で， `~Unicode ToUnicode$ を走らせた結果
⇒
`domain_name^i ~SET %結果 ~BR
`UseSTD3ASCIIRules^i ~SET ~T
◎
Set result to the result of running Unicode ToUnicode with domain_name set to result, UseSTD3ASCIIRules set to true.
</li>
	<li>
~IF［
%結果 に何らかの~errorがある
］
⇒
~RET `failure^i
◎
If result contains any errors, return failure.
</li>
	<li>
~RET `success^i
◎
Return success.
</li>
</ol>

<p class="XXX">課題：
理想的には、`妥当な~domain$を成す~cpの並びを通して定義したい所
— モグラ叩きのように定義するのではなく：
<a href="~SPECBUGS?id=25334">bug 25334</a>
◎
Ideally we define this in terms of a sequence of code points that make up a valid domain rather than through a whack-a-mole: bug 25334.
</p>

<p>
`~domain@syn
は、`妥当な~domain$である文字列で~MUST。
◎
A domain must be a string that is a valid domain.
</p>

<p>
`~IPv4~address@syn
は、 4 個の［
0 〜 255 の 10 進数を表現する［
3 個までの`~ASCII数字$からなる並び
］］を， ❝. で区切った並びで~MUST。
◎
An IPv4 address must be four sequences of up to three ASCII digits per sequence, each representing a decimal number no greater than 255, and separated from each other by ".".
</p>

<p>
`~IPv6~address@syn
は、 IP Version 6 Addressing Architecture の
<a href="~IETF/rfc4291#section-2.2">Text Representation of Addresses</a>
（ “~addressの~text表現” ）章にて定義される。
`RFC4291$r
◎
An IPv6 address is defined in the "Text Representation of Addresses" chapter of IP Version 6 Addressing Architecture. [RFC4291]
</p>

<!-- https://tools.ietf.org/html/rfc5952 updates that RFC, but it seems as
     far as what developers can do we should be liberal

     XXX should we define the format inline instead just like STD 66? -->

		</section>
		<section id="host-parsing">
<h3 title="Host parsing">3.3. ~hostの構文解析法</h3>


<p class="algo-head">
%~Unicode~flag（省略時は ~OFF ）が与えられた下で，文字列 %入力 を
`~host構文解析器@
にかけるときは、次を走らす：
◎
The host parser takes a string input and an optional Unicode flag (unset unless stated otherwise), and then runs these steps:
</p>

<ol>
	<li>
<p>
~IF［
%入力 の先頭 ~EQ ❝[
］：
◎
If input starts with "[", run these substeps:
</p>
		<ol>
			<li>
~IF［
%入力 の末尾 ~NEQ ❝]
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If input does not end with "]", syntax violation, return failure.
</li>
			<li>
~RET ［
%入力 から先頭の ❝[ と末尾の ❝] を除去した結果
］を`~IPv6構文解析器$にかけた結果
◎
Return the result of IPv6 parsing input with its leading "[" and trailing "]" removed.
</li>
		</ol>
	</li>
	<li>
%~domain ~LET ［［
%入力 を`~UTF-8符号化$した結果
］を`~percent復号-$した結果
］を`~BOMを取扱わずに~UTF-8復号-$した結果
<!-- https://bugzilla.mozilla.org/show_bug.cgi?id=309671 -->
◎
Let domain be the result of UTF-8 decode without BOM on the percent decoding of UTF-8 encode on input.
</li>
	<li>
%~ASCII~domain ~LET %~domain を`~ASCIIへ変換-$した結果
◎
Let asciiDomain be the result of running domain to ASCII on domain.
</li>
	<li>
~IF［
%~ASCII~domain ~EQ `failure^i
］
⇒
~RET `failure^i
◎
If asciiDomain is failure, return failure.
</li>
	<li>
<p>
~IF［
%~ASCII~domain の中に次のいずれかが含まれている
］ならば…：
</p>

<ul><li>
`0000^U,
`0009^U,
`000A^U,
`000D^U,
`0020^U,
</li><li>
❝#,<!-- 23 -->
❝%,<!-- 25 -->
❝/,<!-- 2F -->
❝:,<!-- 3A -->
❝?,<!-- 3F -->
❝@,<!-- 40 -->
❝[,<!-- 5B -->
❝\,<!-- 5C -->
❝]<!-- 5D -->
</li></ul>

<p>
…ならば
⇒
`構文違反$ ~BR
~RET `failure^i
</p>
◎
If asciiDomain contains U+0000, U+0009, U+000A, U+000D, U+0020, "#", "%", "/", ":", "?", "@", "[", "\", or "]", syntax violation, return failure.
</li>
	<li>
%ipv4~host ~LET %~ASCII~domain を`~IPv4構文解析器$にかけた結果
◎
Let ipv4Host be the result of IPv4 parsing asciiDomain.
</li>
	<li>
~IF［
%ipv4~host ~EQ `failure^i
］
⇒
~RET `failure^i
◎
↓</li>
	<li>
~IF［
%ipv4~host は`~IPv4~address$である
］
⇒
~RET %ipv4~host
◎
If ipv4Host is an IPv4 address or failure, return ipv4Host.
</li>
	<li>
~IF［
%~Unicode~flag ~EQ ~OFF
］
⇒
~RET %~ASCII~domain
◎
↓</li>
	<li>
~RET %~ASCII~domain を`~Unicodeへ変換-$した結果
◎
Return asciiDomain if the Unicode flag is unset, and the result of running domain to Unicode on asciiDomain otherwise.
</li>
</ol>


<p class="algo-head">
文字列 %入力 を
`~IPv4番号~構文解析器@
にかけるときは、次を走らす：
◎
The IPv4 number parser takes a string input and a syntaxViolationFlag pointer, and then runs these steps:
</p>

<ol>
	<li>
<p>
%違反 ~LET `無し^i
</p>

<p class="trans-note">【
和訳固有の既存の記号で表記する都合により、特にこの変数（原文 %syntaxViolationFlag ）に関して，この~algoには入出力の扱い方に手を加えている。
】</p>
</li>
	<li>
%R ~LET 10
◎
Let R be 10.
</li>
	<li>
<p>
~IF［
%入力 の長さ ~GTE 2
］~AND［
%入力 の最初の 2 個の~cp ~IN
{ `0x^l, `0X^l }
］：
◎
If input contains at least two code points and the first two code points are either "0x" or "0X", run these substeps:
</p>

		<ol>
			<li>
%違反 ~SET `有り^i
◎
Set syntaxViolationFlag.
</li>
			<li>
%入力 から最初の 2 個の~cpを除去する
◎
Remove the first two code points from input.
</li>
			<li>
%R ~SET 16
◎
Set R to 16.
</li>
		</ol>
	</li>
	<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒
~RET 0
◎
If input is the empty string, return zero.
</li>
	<li>
<p>
~IF［
%R ~NEQ 16†
］~AND［
%入力 の長さ ~GTE 2
］~AND［
%入力 の最初の~cp ~EQ ❝0 
］：
◎
Otherwise, if input contains at least two code points and the first code point is "0", run these substeps:
</p>

		<ol>
			<li>
%違反 ~SET `有り^i
◎
Set syntaxViolationFlag.
</li>
			<li>
%入力 から最初の~cpを除去する
◎
Remove the first code point from input.
</li>
			<li>
%R ~SET 8
◎
Set R to 8.
</li>
		</ol>

<p class="trans-note">【†
原文は、この条件が単に “Otherwise, …” としか記されていないが、この Otherwise は，おそらく 2 つ前の段の ~IF を受けたものと見られる。
そう解釈しないと，例えば `0x001^l は 8 進数に解釈されてしまう。
】</p>
	</li>
	<li>
~IF［
%入力 に基数 %R の数字でない~cpが含まれている
］
⇒
~RET ( `failure^i, `有り^i )
◎
If input contains a code point that is not a radix-R digit, and return failure.
</li>
	<li>
%結果 ~LET %入力 を（`~ASCII~hex数字$が値 0 〜 15 の数字に対応付けられた）基数 %R による表記と見なした下で，整数 値として解釈した結果
◎
Return the mathematical integer value that is represented by input in radix-R notation, using ASCII hex digits for digits with values 0 through 15. 
</li>
	<li>
~RET ( %結果, %違反 )
</li>
</ol>

<p class="trans-note">【
`0xAB.012.0X12.12^l
の様な~host名も IPv4 ~addressと見なされ、
`0xAB^l, `0X12^l は 16 進数,
`012^l は 8 進数,
`12^l は 10 進数
として解釈されることになる。
】</p>

<p class="algo-head">
`~IPv4構文解析器@
は、文字列 %入力 を入力にとり，次を走らす：
◎
The IPv4 parser takes a string input and then runs these steps:
</p>

<ol>
	<li>
~Assert：
%入力 ~NEQ 空~文字列
<span class="trans-note">【
この段は訳者による補完。
】</span>
</li>
	<li>
%構文違反~flag ~LET ~OFF
◎
Let syntaxViolationFlag be unset.
</li>
	<li>
%~~成分~list ~LET %入力 を ❝. で分割した結果
◎
Let parts be input split on ".".
</li>
	<li>
~IF［
%~~成分~list 内の最後の~item ~EQ 空~文字列
］
⇒
%構文違反~flag ~SET ~ON ~BR
%~~成分~list から最後の~itemを除去する
<span class="trans-note">【
最後に余計な ❝. があっても受容されることになる。
】</span>
◎
If the last item in parts is the empty string, set syntaxViolationFlag and remove the last item from parts.
</li>
	<li>
~IF［
%~~成分~list の~item数 ~GT 4
］
⇒
~RET %入力
<span class="trans-note">【
結果は`~IPv4~address$ではない。
】</span>
◎
If parts has more than four items, return input.
</li>
	<li>
%数~list ~LET 空~list
◎
Let numbers be the empty list.
</li>
	<li>
<p>
%~~成分~list 内の~EACH ( %~~成分 ) に対し：
◎
For each part in parts:
</p>

		<ol>
			<li>
<p>
~IF［
%~~成分 ~EQ 空~文字列
］
⇒
~RET %入力
◎
If part is the empty string, return input.
</p>

<p class="example">
`0..0x300^l は`~domain$であって，`~IPv4~address$ではない。
◎
0..0x300 is a domain, not an IPv4 address.
</p>
			</li>
			<li>
( %n, %違反 ) ~LET
%~~成分 を`~IPv4番号~構文解析器$にかけた結果
◎
Let n be the result of parsing part using syntaxViolationFlag.
</li>
			<li>
~IF［
%n ~EQ `failure^i
］
⇒
~RET %入力
◎
If n is failure, return input.
</li>
			<li>
%数~list に %n を付加する
◎
Append n to numbers.
</li>
			<li>
~IF［
%違反 ~EQ `有り^i
］
⇒
%構文違反~flag ~SET ~ON
◎
↑↑↑</li>
		</ol>
	</li>
	<li>
~IF［
%構文違反~flag ~EQ ~ON
］
⇒
`構文違反$
◎
If syntaxViolationFlag is set, syntax violation.
</li>
	<li>
~IF［
%数~list 内の ある~item ~GT 255
］
⇒
`構文違反$
◎
If any item in numbers is greater than 255, syntax violation.
</li>
	<li>
~IF［
%数~list 内の最後でない ある~item ~GT 255
］
⇒
~RET `failure^i
◎
If any but the last item in numbers is greater than 255, return failure.
</li>
	<li>
~IF［
%数~list の最後の~item† ~GTE
( 256 の ( 5 − ( %数~list の~item数 ) ) 乗 )
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If the last item in numbers is greater than or equal to 256(5 − the number of items in numbers), syntax violation, return failure.
</li>
	<li>
%ipv4 ~LET %数~list の最後の~item
◎
Let ipv4 be the last item in numbers.
</li>
	<li>
%数~list から最後の~itemを除去する††
◎
Remove the last item from numbers.
</li>
	<li>
%counter ~LET 0
◎
Let counter be zero.
</li>
	<li>
<p>
~FOR
%数~list 内の~EACH ( %n ) に対し：
◎
For each n in numbers:
</p>

		<ol>
			<li>
%ipv4 ~INCBY ( %n × ( 256 の (3 − %counter) 乗 ) )
◎
Increment ipv4 by n × 256(3 − counter).
</li>
			<li>
%counter ~INCBY 1
◎
Increment counter by one.
</li>
		</ol>
	</li>
	<li>
~RET %ipv4
◎
Return ipv4.
</li>
</ol>

<p class="trans-note">【†
最後の~itemだけ特別扱い：
例えば
`100.100.25600^l と `100.100.100.0^l
は等価になり，
`0xFFFFFFFF^l と `255.255.255.255^l
は等価になることになる。
】【††
ここでも、（ %数~list の項~数が 4 に満たない場合は）最後の~itemだけ特別扱い：
例えば `100.100^l は， `100.0.0.100^l と等価になる。
】</p>


<p class="algo-head">
文字列 %入力 を
`~IPv6構文解析器@
にかけるときは、次を走らす：
◎
The IPv6 parser takes a string input and then runs these steps:
</p>

<ol>
	<li>
%~address ~LET `~16-bit~piece$がすべて 0 に初期化された，新たな`~IPv6~address$
◎
Let address be a new IPv6 address with its 16-bit pieces initialized to 0.
</li>
	<li>
<p>
%~piece~pointer ~LET 0 （ %~address 内を指す~pointer, 初期~時は最初の`~16-bit~piece$を指す）
</p>
<p>
以下，記号
`~piece@V
は %~piece~pointer が指している`~16-bit~piece$への参照とする。
</p>

<p lang="en">
Let piece pointer be a pointer into address’s 16-bit pieces, initially zero (pointing to the first 16-bit piece), and let piece be the 16-bit piece it points to.
</p>

	</li>
	<li>
%圧縮~pointer ~LET ~NULL （ %~address 内の`~16-bit~piece$を指す別の~pointer, 初期~時はどこも指していない）
◎
Let compress pointer be another pointer into address’s 16-bit pieces, initially null and pointing to nothing.
</li>
	<li>
%~pointer ~LET 0 （ %入力 内を指す~pointer, 初期~時は最初の~cpを指す）
◎
Let pointer be a pointer into input, initially zero (pointing to the first code point).
</li>
	<li>
<p>
~IF［
`C$V ~EQ ❝:
］：
◎
If c is ":", run these substeps:
</p>
		<ol>
			<li>
~IF［
`残部$V の最初の~cp ~NEQ ❝:
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If remaining does not start with ":", syntax violation, return failure.
</li>
	<li>
%~pointer ~INCBY 2
◎
Increase pointer by two.
</li>
	<li>
%~piece~pointer ~INCBY 1 ~BR
%圧縮~pointer ~SET %~piece~pointer
◎
Increase piece pointer by one and then set compress pointer to piece pointer.
</li>
		</ol>
	</li>
	<li>`Main@lb：
<p>
~WHILE ［
`C$V ~NEQ `EOF$i
］：
◎
Main: While c is not the EOF code point, run these substeps:
</p>
		<ol>
			<li>
~IF［
%~piece~pointer ~EQ 8
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If piece pointer is eight, syntax violation, return failure.
</li>
			<li>
<p>
~IF［
`C$V ~EQ ❝:
］：
◎
If c is ":", run these inner substeps:
</p>
				<ol>
					<li>
~IF［
%圧縮~pointer ~NEQ ~NULL
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If compress pointer is non-null, syntax violation, return failure.
</li>
					<li>
%~piece~pointer ~INCBY 1 ~BR
%~pointer ~INCBY 1 ~BR
%圧縮~pointer ~SET %~piece~pointer ~BR
~GOTO `Main$lb
◎
Increase pointer and piece pointer by one, set compress pointer to piece pointer, and then jump to Main.
</li>
				</ol>
			</li>
			<li>
%値 ~LET 0 ~BR
%長th ~LET 0
◎
Let value and length be 0.
</li>
	<li>
~WHILE ［
%長th ~LT 4
］~AND［
`C$V ~IN `~ASCII~hex数字$
］
⇒
%値 ~SET
%値 ~MUL `10^X ~PLUS ［ `C$V を 16 進数として解釈した値 ］ ~BR
%~pointer ~INCBY 1 ~BR
%長th ~INCBY 1
◎
While length is less than 4 and c is an ASCII hex digit, set value to value × 0x10 + c interpreted as hexadecimal number, and increase pointer and length by one.
</li>
			<li>
<p>
`C$V に応じて：
◎
Switching on c:
</p>
				<dl class="switch">
					<dt>❝.</dt>
					<dd>
						<ol>
							<li>
~IF［
%長th ~EQ 0
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If length is 0, syntax violation, return failure.
</li>
							<li>
%~pointer ~DECBY %長th
◎
Decrease pointer by length.
</li>
							<li>
~GOTO `IPv4$lb
◎
Jump to IPv4.
</li>
							</ol>
					</dd>

					<dt>❝:</dt>
					<dd>
						<ol>
							<li>
%~pointer ~INCBY 1
◎
Increase pointer by one.
</li>
							<li>
~IF［
`C$V ~EQ `EOF$i
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If c is the EOF code point, syntax violation, return failure.
</li>
						</ol>
					</dd>

					<dt>`EOF$i 以外◎Anything but the EOF code point</dt>
					<dd>
`構文違反$ ~BR
~RET `failure^i
◎
Syntax violation, return failure.
</dd>
				</dl>

			</li>
			<li>
`~piece$V ~SET %値
◎
Set piece to value.
</li>
			<li>
%~piece~pointer ~INCBY 1
◎
Increase piece pointer by one.
</li>
		</ol>
	</li>
	<li>
~IF［
`C$V ~EQ `EOF$i
］
⇒
~GOTO `Finale$lb
◎
If c is the EOF code point, jump to Finale.
</li>
	<li>`IPv4@lb：
<p>
~IF［
%~piece~pointer ~GT 6
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
IPv4: If piece pointer is greater than six, syntax violation, return failure.
</p></li>
	<li>
%~dot数 ~LET 0
◎
Let dots seen be 0.
</li>
	<li>
<p>
~WHILE ［
`C$V ~NEQ `EOF$i
］：
◎
While c is not the EOF code point, run these substeps:
</p>
		<ol>
			<li>
%値 ~LET ~NULL
◎
Let value be null.
</li>
			<li>
~IF［
`C$V ~NIN `~ASCII数字$
］
⇒
`構文違反$ ~BR
~RET `failure^i
<!-- prevent the empty string -->
◎
If c is not an ASCII digit, syntax violation, return failure.
</li>
			<li>
<p>
~WHILE ［
`C$V ~IN `~ASCII数字$
］：
◎
While c is an ASCII digit, run these subsubsteps:
</p>
				<ol>
					<li>
%数 ~LET `C$V を 10 進数として解釈した値
◎
Let number be c interpreted as decimal number.
</li>
					<li>
<p>
~IF［
%値 ~EQ ~NULL
］
⇒
%値 ~SET %数
◎
If value is null, set value to number.
</p>

<p>
~ELIF［
%値 ~EQ 0
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
Otherwise, if value is 0, syntax violation, return failure.
</p>

<p>
~ELSE
⇒
%値 ~SET %値 ~MUL 10 + %数
◎
Otherwise, set value to value × 10 + number.
</p>
					</li>
					<li>
%~pointer ~INCBY 1
◎
Increase pointer by one.
</li>
					<li>
~IF［
%値 ~GT 255
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If value is greater than 255, syntax violation, return failure.
</li>
				</ol>
			</li>
			<li>
~IF［
%~dot数 ~LT 3
］~AND［
`C$V ~NEQ ❝.
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If dots seen is less than 3 and c is not a ".", syntax violation, return failure.
</li>
			<li>
`~piece$V ~SET `~piece$V ~MUL `100^X ~PLUS %値
◎
Set piece to piece × 0x100 + value.
</li>
			<li>
~IF［
%~dot数 ~IN { 1, 3 }
］
⇒
%~piece~pointer ~INCBY 1
◎
If dots seen is 1 or 3, increase piece pointer by one.
</li>
			<li>
~IF［
`C$V ~NEQ `EOF$i
］
⇒
%~pointer ~INCBY 1
◎
If c is not the EOF code point, increase pointer by one.
</li>
			<li>
~IF［
%~dot数 ~EQ 3
］~AND［
`C$V ~NEQ `EOF$i
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If dots seen is 3 and c is not the EOF code point, syntax violation, return failure.
</li>
			<li>
%~dot数 ~INCBY 1
◎
Increase dots seen by one.
</li>
		</ol>
	</li>
	<li>`Finale@lb：
<p>
~IF［
%圧縮~pointer ~NEQ ~NULL
］：
◎
Finale: If compress pointer is non-null, run these substeps:
</p>
		<ol>
			<li>
%swaps ~LET %~piece~pointer ~MINUS %圧縮~pointer
◎
Let swaps be piece pointer − compress pointer.
</li>
			<li>
%~piece~pointer ~SET 7
◎
Set piece pointer to seven.
</li>
			<li>
~WHILE ［
%~piece~pointer ~NEQ 0
］~AND［
%swaps ~GT 0
］
⇒
`~piece$V と ［ %圧縮~pointer ~PLUS %swaps ~MINUS 1 ］に位置する`~16-bit~piece$とを交換する ~BR
%~piece~pointer ~DECBY 1 ~BR
%swaps ~DECBY 1
◎
While piece pointer is not zero and swaps is greater than zero, swap piece with the piece at pointer compress pointer + swaps − 1, and then decrease both piece pointer and swaps by one.
</li>
		</ol>

	</li>
	<li>
~ELIF［
%圧縮~pointer ~EQ ~NULL
］~AND［
%~piece~pointer ~NEQ 8
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
Otherwise, if compress pointer is null and piece pointer is not eight, syntax violation, return failure.
</li>
	<li>
~RET %~address
◎
Return address.
</li>
</ol>


<p class="note">注記：
念のため —
`Main$lb, `IPv4$lb, `Finale$lb
は、単に~algoのジャンプ先を記すものであり，それ以外の~~意味は無い。
◎
To be clear, Main, IPv4, and Finale are simple markers. They serve no purpose other than being a location the algorithm can jump to.
</p>

		</section>
		<section id="host-serializing">
<h3 title="Host serializing">3.4. ~hostの直列化法</h3>

<p class="algo-head">
所与の`~host$ %~host を
`~host直列化器@
にかけるときは、 %~host の種別に応じて，次を返す：
◎
The host serializer takes a host host and then runs these steps:
</p>

<dl class="switch">
	<dt>`~IPv4~address$</dt>
	<dd>
%~host を`~IPv4直列化器$にかけた結果
◎
If host is an IPv4 address, return the result of running the IPv4 serializer on host.
</dd>

	<dt>`~IPv6~address$</dt>
	<dd>
❝[
~APPEND ［
%~host を`~IPv6直列化器$にかけた結果
］ ~APPEND ❝]
◎
Otherwise, if host is an IPv6 address, return "[", followed by the result of running the IPv6 serializer on host, followed by "]".
</dd>

	<dt>`~domain$</dt>
	<dd>
%~host
◎
Otherwise, host is a domain, return host.
</dd></dl>


<p class="algo-head">
所与の`~IPv4~address$ %~address を
`~IPv4直列化器@
にかけるときは、次を走らす：
◎
The IPv4 serializer takes an IPv4 address address and then runs these steps:
</p>

<ol>
<!-- ＊
	<li>
~RET ［
32-bit %~address を成す各 8-bit 成分の数
］を［
最短の`~ASCII数字$列で表現する文字列に変換した結果
］の 4 個の文字列を，上位 bit のものから順に
❝. で区切って連結した結果
</li>
 -->


	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
%n ~LET %~address
◎
Let n be the value of address.
</li>
	<li>
<p>
次を 4 回繰り返す：
◎
Repeat four times:
</p>

		<ol>
			<li>
［
%n を 256 で割った余り
］を`直列化-$した結果
］を %出力 の先頭に~~挿入する
◎
Prepend n % 256, serialized, to output.
</li>
			<li>
~IF［
この反復は 4 回目でない
］
⇒
❝. を %出力 の先頭に~~挿入する
◎
Unless this is the fourth time, prepend "." to output.
</li>
			<li>
%n ~SET floor( %n ÷ 256 )
◎
Set n to floor(n / 256).
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>


<p class="algo-head">
所与の`~IPv6~address$ %~address を
`~IPv6直列化器@
にかけるときは、次を走らす：
◎
The IPv6 serializer takes an IPv6 address address and then runs these steps:
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
%圧縮~pointer ~LET ~NULL
◎
↓</li>
	<li>
<p>
~IF［
%~address の中に，［
2 個以上~連続する，値 0 をとる`~16-bit~piece$からなる並び
］がある
］
⇒
%圧縮~pointer ~SET ［［
そのような並びのうち，最長である並び
］のうち，最初に来る並び
］の中の，最初の`~16-bit~piece$を指す~pointer
</p>

<p class="example">
例えば `0:f:0:0:f:f:0:0^l に対しては、二番目の 0 を指すことになる。
</p>

◎
Let compress pointer be a pointer to the first 16-bit piece in the first longest sequences of address’s 16-bit pieces that are 0.
◎
In 0:f:0:0:f:f:0:0 it would point to the second 0.
◎
If there is no sequence of address’s 16-bit pieces that are 0 longer than one, set compress pointer to null.
</li>
	<li>
<p>
~FOR
%~address の~EACH ( `~16-bit~piece$ %~piece ) に対し：
◎
For each piece in address’s pieces, run these substeps:
</p>
		<ol>
			<li>
~IF［
%圧縮~pointer は %~piece を指している
］
⇒
%出力 ~APPEND ［
%~piece が %~address の最初の`~16-bit~piece$ならば `::^l ／
~ELSE_ ❝:
］ ~BR
~CONTINUE
— ただし、 %~address 内で %~piece の直後から連続する［
値 0 の`~16-bit~piece$
］に対する反復は飛ばす
◎
If compress pointer points to piece, append "::" to output if piece is address’s first piece and append ":" otherwise, and then run these substeps again with all subsequent pieces in address’s pieces that are 0 skipped or go the next step in the overall set of steps if that leaves no pieces.
</li>
			<li>
%出力 ~APPEND ［
%~piece を小文字 16 進数で表現する最短の文字列
］
◎
Append piece, represented as the shortest possible lowercase hexadecimal number, to output.
</li>
			<li>
<!-- ~piece が ~address の最後の~16-bit~pieceでない -->
~IF［
この反復は最後の反復でない
］
⇒
%出力 ~APPEND ❝:
◎
If piece is not address’s last piece, append ":" to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
この~algoは
A Recommendation for IPv6 Address Text Representation
（ IPv6 ~addressの推奨~表記）への準拠を要求する。
`RFC5952$r
◎
This algorithm requires the recommendation from A Recommendation for IPv6 Address Text Representation. [RFC5952]
</p>

		</section>
		<section id="host-equivalence">

<h3 title="Host equivalence">3.5. ~hostの等価性</h3>

<p class="algo-head">
二つの`~host$［
%A, %B
］が
`等しい@host
かどうか決定するときは
⇒
［［
%A ~EQ %B
］ならば ~T ／
~ELSE_ ~F
］を返す。
◎
To determine whether a host A equals B, return true if A is B, and false otherwise.
</p>

<p class="XXX">課題：
証明書の比較には、［
~domainの尾部の~dotは無視する
］ような，~hostの等価性の検査が要求される。
しかしながら、それらの~hostには，ここでは施行されない DNS 長さなどの 他の種々の側面0も施行される
— ~URLはそれらを施行しないので。
これら二つを近づけるような, あるいは
統一化~modelとして何か良い示唆があれば，issue を file されたし。
◎
Certificate comparison requires a host equivalence check that ignores the trailing dot of a domain (if any). However, those hosts have also various other facets enforced, such as DNS length, that are not enforced here, as URLs do not enforce them. If anyone has a good suggestion for how to bring these two closer together, or what a good unified model would be, please file an issue.
</p>

		</section>
	</section>

	<section id="urls">
<h2 title="URLs">4. ~URL</h2>


<p>
`~URL@
とは、統一的†な識別子である。
`~URL文字列$と区別するため、`~URL~record$とも記される††。
◎
A URL is a universal identifier. To disambiguate from a URL string it can also be referred to as a URL record.
</p>

<p class="trans-note">【†
“universal” — 
（資源を一意的に識別するために，）~~普遍的に／広く~~一般から／広範の応用に渡って／共通して
利用し得るような
】【††
以下に定義される`~URL$の各種 構成子は、この，内部表現による~URL（ `~URL文字列$を構文解析して得られる`~URL~record$）の各種~成分を表す。
】</p>

<p>
`~URL$は、次の成分からなる：
</p>

<dl class="def-list">
	<dt>`~scheme@url（初期~値：空~文字列）</dt>
	<dd>
`~URL$の種別を識別する`~ASCII文字列$であって、`~URL構文解析器$urlにかけた後の，`~URL$の更なる分岐処理に利用し得るもの。
◎
A URL’s scheme is an ASCII string that identifies the type of URL and can be used to dispatch a URL for further processing after parsing. It is initially the empty string.
</dd>

	<dt>`~username@url（初期~値：空~文字列）</dt>
	<dd>
利用者を識別する`~ASCII文字列$。
◎
A URL’s username is an ASCII string identifying a user. It is initially the empty string.
</dd>

	<dt>`~password@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または
利用者の資格証明情報を識別する`~ASCII文字列$。
◎
A URL’s password is either null or an ASCII string identifying a user’s credentials. It is initially null.
</dd>

	<dt>`~host@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または
`~host$。
◎
A URL’s host is either null or a host. It is initially null.
</dd>

	<dt>`~port@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または
~networking~portを識別する 16-bit 非負~整数。
◎
A URL’s port is either null or a 16-bit unsigned integer that identifies a networking port. It is initially null.
</dd>

	<dt>`~path@url（初期~値：空~list）</dt>
	<dd>
~dataを保持している［
~zero個以上の`~ASCII文字列$からなる~list
］であり、通例的には，資源の所在を階層的に識別するものになる。
◎
A URL’s path is a list of zero or more ASCII string holding data, usually identifying a location in hierarchical form. It is initially the empty list.
</dd>

	<dt>`~query@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または ~dataを保持している`~ASCII文字列$。
◎
A URL’s query is either null or an ASCII string holding data. It is initially null.
</dd>

	<dt>`素片@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または［
~dataを保持している文字列であって，［
`~URL$の他の部分から識別される資源
］に対する更なる処理に利用し得るもの
］。
◎
A URL’s fragment is either null or a string holding data that can be used for further processing on the resource the URL’s other components identify. It is initially null.
</dd>
	<dd class="note">注記：
これは、その目的~上，`~ASCII文字列$でない。
◎
This is not an ASCII string on purpose.
</dd>
	<dd class="trans-note">【
（参考） HTTP の文脈では、素片は~target~URLの
<a href="~IETF/rfc7230#section-5.1">一部ではない</a>
（~client側の領分になる）。
】</dd>
</dl>


<!-- 
（参考）
典型的な URL の構成：
~scheme://~host:~port/~path?~query#素片
 -->



<p>
`~URL$には、次のものも結付けられる：
</p>

<dl class="def-list">
	<dt>`~cannot-be-a-base-URL~flag@（初期~値： ~OFF ）</dt>
	<dd>
~flag値
◎
A URL also has an associated cannot-be-a-base-URL flag. It is initially unset.
</dd>

	<dt>`~obj@url（初期~値： ~NULL ）</dt>
	<dd>
~NULL, または
次のいずれかの~obj
⇒
`Blob$I `FILEAPI$r ／
`MediaSource$I `MEDIA-SOURCE$r ／
`MediaStream$I `MEDIACAPTURE-STREAMS$r
◎
A URL also has an associated object that is null, a Blob object, a MediaSource object, or a MediaStream object. It is initially null. [FILEAPI] [MEDIA-SOURCE] [MEDIACAPTURE-STREAMS] 
</dd>
	<dd class="note">注記：
現時点では，これは主に `blob^l `~URL$を~supportするためのものであるが、他のものも追加され得るので，単に “~obj” と称する。
◎
At this point this is used primarily to support "blob" URLs, but others can be added going forward, hence "object".
</dd>

</dl>

<hr>

<p>
`特別~scheme@
とは、次の一覧の最初の列に挙げられている`~scheme$urlである。
`特別~scheme$の
`既定~port@
とは、一覧の同じ行の２列目に示されている`~port$urlである。
◎
A special scheme is a scheme listed in the first column of the following table. A default port is a special scheme’s optional corresponding port and is listed in the second column on the same row.
</p>

<table>
<thead><tr><th>`~scheme$url
</th><th>`~port$url
</th></tr></thead>

<tbody><tr><td>`ftp^l
</td><td>21

</td></tr><tr><td>`file^l
</td><td>（未定義）

</td></tr><tr><td>`gopher^l
</td><td>70

</td></tr><tr><td>`http^l
</td><td>80

</td></tr><tr><td>`https^l
</td><td>443

</td></tr><tr><td>`ws^l
</td><td>80

</td></tr><tr><td>`wss^l
</td><td>443

</td></tr></tbody></table>

<p>
`~scheme$urlが`特別~scheme$であるような`~URL$は，
`特別@
であるという。
◎
A URL is special if its scheme is a special scheme.
</p>

<p>
`~scheme$urlのうち，
`about^l, `blob^l, `data^l, `filesystem^l
を
`局所~scheme@
という。
◎
A local scheme is a scheme that is "about", "blob", "data", or "filesystem".
</p>

<p>
`~scheme$urlが`局所~scheme$であるような`~URL$は，
`局所的@
であるという。
◎
A URL is local if its scheme is a local scheme.
</p>

<p class="note">注記：
この定義は外部から利用される。
例えば
Fetch Standard `FETCH$r
や
Referrer Policy `REFERRER-POLICY$r
。
◎
This definition is used externally. E.g., by the Fetch Standard and Referrer Policy. [FETCH] [REFERRER-POLICY]
</p>

<p>
`~scheme$urlのうち，
`http^l, `https^l
を
`~HTTP_S~scheme@
という。
◎
An HTTP(S) scheme is a scheme that is "http" or "https".
</p>

<p>
`~scheme$urlのうち，
`ftp^l, `~HTTP_S~scheme$
を
`~network~scheme@
という。
◎
A network scheme is a scheme that is "ftp" or an HTTP(S) scheme.
</p>

<p>
`~scheme$urlのうち，
`about^l, `blob^l, `data^l, `file^l, `filesystem^l, `~network~scheme$
を
`~fetch~scheme@
という。
◎
A fetch scheme is a scheme that is "about", "blob", "data", "file", "filesystem", or a network scheme.
</p>

<p class="note">注記：
`~network~scheme$, `~HTTP_S~scheme$, `~fetch~scheme$
は~HTMLから利用される。
`HTML$r
◎
HTTP(S) scheme, network scheme, and fetch scheme are used by HTML. [HTML]
</p>

<p>
`~URL$が
`資格証明情報を含む@
とは、その［
`~username$urlは空~文字列でない, または
`~password$urlは ~NULL でない
］ことを意味する。
◎
A URL includes credentials if either its username is not the empty string or its password is non-null.
</p>

<p class="trans-note">【
（参考） HTTP 1.1 ~protocolの下では、改訂された HTTP 1.1 仕様（ RFC7230 ）により，~target~URL内での直接的な［
~password／~username
］の利用は~security上の問題から許容されなくなっている（参照：
RFC7230 の
<a href="~IETF/rfc7230#appendix-A.2">Appendix A</a>,
<a href="~IETF/rfc7230#section-2.7.1">2.7.1 節の userinfo の記述</a>
）。
そのため、これらの情報が伝達されるときは，~errorとして扱われるか, 削除されるか, より安全な手段を通すことになる（べき）であろう。
】</p>

<p>
`~URL$は
`基底~URL@
であるものと指名されることもある。
◎
A URL can be designated as base URL.
</p>

<p class="note">注記：
`基底~URL$は、`~URL構文解析器$urlにおいて，`相対~URL$synも入力にとり得るときに有用になる。
◎
A base URL is useful for the URL parser when the input might be a relative URL.
</p>

<hr>


<div class="p">
<p class="algo-head">
%url の`~path$url %path を
`短縮-@
するときは、次のいずれかが満たされる場合を除き，
%path から最後の~itemを除去する：
</p>

<ul><li>%path は空である
</li><li>［
%url の`~scheme$url ~EQ `file^l
］~AND［
%path の~item数 ~EQ 1
］~AND［
%path の最初の~itemは`正規化済み~drive_letter$である
］
</li></ul>

◎
To shorten a url’s path, if url’s scheme is not "file" or url’s path does not contain a single string that is a normalized Windows drive letter, remove url’s path’s last string, if any.
</div>





		<section id="url-syntax">
<h3 title="URL syntax">4.1. ~URLの構文</h3>

<div class="p">
<p>
文字列としての
`~URL@syn
は、［
`素片~付き相対~URL$syn,
`素片~付き絶対~URL$syn
］のいずれかで~MUST。
`~URL~record$と区別するため、`~URL文字列$とも記される。
</p>

<p class="trans-note">【
以下に定義される`~URL文字列$の各種 構成子は、 “生の~URL” の成分を表す
— `~URL~record$の構成子と同じ名前のものもあることに注意。
】</p>

<p>
以下において，“省略可” と記された部分は省略し得る／され得ることを意味する（すなわち， 0 個, または 1 個）。
</p>


◎
A URL must be either a relative URL with fragment or an absolute URL with fragment. To disambiguate from a URL record it can also be referred to as a URL string.
</div>


<div class="p">
<p>
`素片~付き絶対~URL@syn
は、次の並びで~MUST：
</p>

<ol><li>`絶対~URL$syn
</li><li>次の並び（省略可）：
	<ol><li>❝#
	</li><li>`素片$syn
	</li></ol>
</li></ol>

◎
An absolute URL with fragment must be an absolute URL, optionally followed by "#" and a fragment.
</div>

<p>
`絶対~URL@syn
は、次の並びで~MUST：
◎
An absolute URL must be one of the following
</p>

<ol>
	<li>
<p>
次のいずれか：
</p>

		<ul>
			<li>
<p>
次の並び：
</p>

<ol><li>`~scheme$synであって，［
`file^l 以外の`特別~scheme$
］に`~ASCII大小無視$で合致するもの
</li><li>❝:
</li><li>`~scheme相対~URL$syn
</li></ol>

◎
a scheme that is an ASCII case-insensitive match for a special scheme and not an ASCII case-insensitive match for "file", followed by ":" and a scheme-relative URL
</li>
			<li>
<p>
次の並び：
</p>

<ol><li>`~scheme$synであって，`特別~scheme$に`~ASCII大小無視$で<em>合致しない</em>もの
</li><li>❝:
</li><li>`相対~URL$syn
</li></ol>

◎
a scheme that is not an ASCII case-insensitive match for a special scheme, followed by ":" and a relative URL
</li>
			<li>
<p>
次の並び：
</p>
<ol><li>`~scheme$synであって， `file^l に`~ASCII大小無視$で合致するもの
</li><li>❝:
</li><li>`~scheme相対 file ~URL$syn
</li></ol>

◎
a scheme that is an ASCII case-insensitive match for "file", followed by ":" and a scheme-relative file URL
</li>
		</ul>
	</li>
	<li>
<p>
次の並び（省略可）：
</p>

<ol><li>❝?
</li><li>`~query$syn
</li></ol>

◎
any optionally followed by "?" and a query.
</li>
</ol>


<div class="p">
<p>
`~scheme@syn
は、次の並びで~MUST：
</p>

<ol><li>1 個の`~ASCII英字$
</li><li>0 個以上の { `~ASCII英数字$, ❝+, ❝-, ❝. } からなる並び
</li></ol>

<p>
`~scheme$syn
は、 <cite>IANA URI [sic] Schemes</cite> ~registryに登録されるべきである。
`IANA-URI-SCHEMES$r
`RFC7595$r
</p>

◎
A scheme must be one ASCII alpha, followed by zero or more of ASCII alphanumeric, "+", "-", and ".". Schemes should be registered in the IANA URI [sic] Schemes registry. [IANA-URI-SCHEMES] [RFC7595]
</div>


<div class="p">
<p>
`素片~付き相対~URL@syn
は、次の並びで~MUST：
</p>

<ol><li>`相対~URL$syn
</li><li>次の並び（省略可）：
	<ol><li>❝#
	</li><li>`素片$syn
	</li></ol>
</li></ol>

◎
A relative URL with fragment must be a relative URL, optionally followed by "#" and a fragment.
</div>

<p>
`相対~URL@syn
は、次の並びで~MUST：
◎
A relative URL must be one of the following, switching on base URL’s scheme:
</p>

<ol>
	<li>
<p>
`基底~URL$の`~scheme$urlに応じて：
◎
↑</p>

		<dl class="switch">
			<dt>`file^l 以外ならば，次のいずれか：</dt>
			<dd>
`~scheme相対~URL$syn
◎
a scheme-relative URL
</dd>
			<dd>
`~path絶対~URL$syn
◎
a path-absolute URL
</dd>
			<dd>
`~path相対 ~schemeなし~URL$syn
◎
a path-relative scheme-less URL
</dd>

			<dt>`file^l ならば，次のいずれか：</dt>
			<dd>
`~scheme相対 file ~URL$syn
◎
a scheme-relative file URL
</dd>
			<dd>
`~path絶対~URL$syn
— ただし、［
`基底~URL$の`~host$url ~NEQ ~NULL
］の場合に限る
◎
a path-absolute URL if base URL’s host is null
</dd>
			<dd>
`~path絶対 非 Windows file ~URL$syn
— ただし、［
`基底~URL$の`~host$url ~NEQ ~NULL
］の場合に限る
◎
a path-absolute non-Windows-file URL if base URL’s host is non-null
</dd>
			<dd>
`~path相対 ~schemeなし~URL$syn
◎
a path-relative scheme-less URL
</dd>

</dl>

	</li><li>
<p>
次の並び（省略可）：
</p>

<ol><li>❝?
</li><li>`~query$syn
</li></ol>

◎
any optionally followed by "?" and a query.
</li>
</ol>

<p class="note">注記：
`相対~URL$synを`~URL構文解析器$urlにかけるときは、非~NULLの`基底~URL$が必要とされる。
◎
A non-null base URL is necessary when parsing a relative URL. 
</p>

<div class="p">
<p>
`~scheme相対~URL@syn
は、次の並びで~MUST
</p>

<ol><li>`//^l
</li><li>`~host$syn
</li><li>
<p>
次の並び（省略可）：
</p>
	<ol><li>❝:
	</li><li>`~port$syn
	</li></ol>

</li><li>
`~path絶対~URL$syn（省略可）
</li></ol>

◎
A scheme-relative URL must be "//", followed by a host, optionally followed by ":" and a port, optionally followed by a path-absolute URL.
</div>

<p>
`~port@synは、［
0 個以上の`~ASCII数字$からなる並び
］で~MUST。
◎
A port must be zero or more ASCII digits.
</p>


<div class="p">

<p>
`~scheme相対 file ~URL@syn
は、次の並びで~MUST：
</p>

<ol><li>`//^l
</li><li>次のいずれか：
	<ul><li>`~path絶対~URL$syn
	</li><li>次の並び：
		<ol><li>`~host$syn
		</li><li>`~path絶対 非 Windows file ~URL$syn（省略可）
		</li></ol>
	</li></ul>
</li></ol>

◎
A scheme-relative file URL must be "//", followed by one of the following
◎
a host, optionally followed by a path-absolute non-Windows-file URL
◎
a path-absolute URL.
</div>

<div class="p">
<p>
`~path絶対~URL@syn
は、次の並びで~MUST：
</p>

<ol><li>❝/
</li><li>`~path相対~URL$syn
</li></ol>
◎
A path-absolute URL must be "/" followed by a path-relative URL. 
</div>

<div class="p">
<p>
`~path絶対 非 Windows file ~URL@syn
は、次の並びから開始されていない，`~path絶対~URL$synで~MUST：
</p>

<ol><li>❝/
</li><li>`~drive_letter$
</li><li>❝/
</li></ol>

◎
A path-absolute non-Windows-file URL must be a path-absolute URL that does not start with "/", followed by a Windows drive letter, followed by "/".
</div>

<div class="p">
<p>
`~path相対~URL@syn
は、次のいずれも満たす文字列で~MUST：
</p>

<ul><li>❝/ で区切られた［
0 個以上の`~path区分$syn
］からなる
</li><li>❝/ から開始されていない
</li></ul>

◎
A path-relative URL must be zero or more path segments, separated from each other by "/", and not start with "/".
</div>

<p>
`~path相対 ~schemeなし~URL@syn
は、次を満たす`~path相対~URL$synで~MUST
⇒
［
`~scheme$syn,
❝:
］の並びから開始されていない
◎
A path-relative scheme-less URL must be a path-relative URL that does not start with a scheme and ":".
</p>

<p>
`~path区分@syn
は、［
0 個以上の［
❝?, ❝/ を除く`~URL単位$
］からなる並び
］で~MUST。
次に挙げるものは、構文解析~時に~~特別に扱われる`~path区分$synである：
◎
A path segment must be one of the following
◎
zero or more URL units, excluding "/" and "?", that together are not a single-dot path segment or a double-dot path segment.
◎
a single-dot path segment
◎
a double-dot path segment.
</p>

<ul>
	<li>
<p>
`単dot~path区分@syn
は、次のいずれかで~MUST：
</p>

<ul><li>❝.
</li><li>`~ASCII大小無視$で `%2e^l に合致するもの
</li></ul>

◎
A single-dot path segment must be "." or an ASCII case-insensitive match for "%2e".
</li>
	<li>
`二重dot~path区分@syn
は、［
2 個の`単dot~path区分$syn（同じでなくてもよい）からなる並び
］で~MUST。
◎
A double-dot path segment must be ".." or an ASCII case-insensitive match for ".%2e", "%2e.", or "%2e%2e".
</li>
</ul>

<p>
`~query@syn
は、［
0 個以上の`~URL単位$からなる並び
］で~MUST。
◎
A query must be zero or more URL units.
</p>

<p>
`素片@syn
は、［
0 個以上の`~URL単位$からなる並び
］で~MUST。
◎
A fragment must be zero or more URL units.
</p>

<div class="p">
<p>
次のものが
`~URL~cp@
である：
</p>

<ul>
	<li>
`~ASCII英数字$
</li>
	<li>
<p>
❝!,<!-- 0x21, sub-delims -->
❝$,<!-- 0x24, sub-delims -->
`&amp;^l,<!-- 0x26, sub-delims -->
❝',<!-- 0x27, sub-delims -->
❝(,<!-- 0x28, sub-delims -->
❝),<!-- 0x29, sub-delims -->
❝*,<!-- 0x2A, sub-delims -->
❝+,<!-- 0x2B, sub-delims -->
❝,,<!-- 0x2C, sub-delims -->
❝-,<!-- 0x2D, iunreserved -->
❝.,<!-- 0x2E, iunreserved -->
❝/,<!-- 0x2F, iquery/ifragment -->
❝:,<!-- 0x3A, ipchar -->
❝;,<!-- 0x3B, sub-delims -->
❝=,<!-- 0x3D, sub-delims -->
❝?,<!-- 0x3F, iquery/ifragment -->
❝@,<!-- 0x40, ipchar -->
❝_,<!-- 0x5F, iunreserved -->
❝~<!-- 0x7E, iunreserved -->
</p>

<p class="trans-note">【
`0021^U, `0024^U, `0026^U 〜 `002F^U, `003A^U, `003B^U, `003D^U, `003F^U, `0040^U, `005F^U, `007E^U
】</p>

</li>
	<li>
~cp
⇒
`00A0^U 〜 `D7FF^U ~BR
`E000^U 〜 `FDCF^U ~BR
`FDF0^U 〜 `FFFD^U ~BR
`10000^U 〜 `1FFFD^U ~BR
`20000^U 〜 `2FFFD^U ~BR
`30000^U 〜 `3FFFD^U ~BR
`40000^U 〜 `4FFFD^U ~BR
`50000^U 〜 `5FFFD^U ~BR
`60000^U 〜 `6FFFD^U ~BR
`70000^U 〜 `7FFFD^U ~BR
`80000^U 〜 `8FFFD^U ~BR
`90000^U 〜 `9FFFD^U ~BR
`A0000^U 〜 `AFFFD^U ~BR
`B0000^U 〜 `BFFFD^U ~BR
`C0000^U 〜 `CFFFD^U ~BR
`D0000^U 〜 `DFFFD^U ~BR
`E0000^U 〜 `EFFFD^U ~BR
`F0000^U 〜 `FFFFD^U ~BR
`100000^U 〜 `10FFFD^U
</li>
</ul>

◎
The URL code points are ASCII alphanumeric, "!", "$", "&amp;", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "=", "?", "@", "_", "~", and code points in the ranges U+00A0 to U+D7FF, U+E000 to U+FDCF, U+FDF0 to U+FFFD, U+10000 to U+1FFFD, U+20000 to U+2FFFD, U+30000 to U+3FFFD, U+40000 to U+4FFFD, U+50000 to U+5FFFD, U+60000 to U+6FFFD, U+70000 to U+7FFFD, U+80000 to U+8FFFD, U+90000 to U+9FFFD, U+A0000 to U+AFFFD, U+B0000 to U+BFFFD, U+C0000 to U+CFFFD, U+D0000 to U+DFFFD, U+E0000 to U+EFFFD, U+F0000 to U+FFFFD, U+100000 to U+10FFFD.
</div>

<p class="note">注記：
`素片$url内に現れるものを除き、
`0080^U 以上の~cpは、`~URL構文解析器$urlにより`~percent符号化済~byte$に変換されることになる。
◎
Code points higher than U+007F will be converted to percent-encoded bytes by the URL parser, except for code points appearing in fragments. 
</p>

<p class="note">注記：
~HTMLにおいては、文書の符号化方式が旧来のものである場合，~query内の `0080^U 以上の~cpは、文書の符号化方式を用いて`~percent符号化済~byte$に変換される。
これは、ある文書で働く~URLが 異なる文書~符号化方式を利用する文書に複製されるときに，問題になり得る。
この問題は、あらゆる箇所に~UTF-8符号化方式を用いれば~~解消する。
◎
In HTML, when the document encoding is a legacy encoding, code points in the query that are higher than U+007F will be converted to percent-encoded bytes using the document’s encoding. This can cause problems if a URL that works in one document is copied to another document that uses a different document encoding. Using the UTF-8 encoding everywhere solves this problem.
</p>

<div class="example" id="query-encoding-example">
<p>
例えば、次の~HTML文書を考える：
◎
For example, consider this HTML document:
</p>

<pre>
&lt;!doctype html&gt;
&lt;meta charset="windows-1252"&gt;
&lt;a href="?sm&amp;ouml;rg&amp;aring;sbord"&gt;Test&lt;/a&gt;
</pre>

<p>
文書~符号化方式は windows-1252 なので、
~linkの `~URL$の`~query$urlは
`sm%F6rg%E5sbord^l
になる。
文書~符号化方式が UTF-8 であった場合、それは
`sm%C3%B6rg%C3%A5sbord^l
になる。
◎
Since the document encoding is windows-1252, the link’s URL’s query will be "sm%F6rg%E5sbord". If the document encoding had been UTF-8, it would instead be "sm%C3%B6rg%C3%A5sbord".
</p>
			</div>

<p>
次のものが
`~URL単位@
である
⇒
`~URL~cp$, `~percent符号化済~byte$
<span class="trans-note">【
従って，`~URL単位$がなす集合は文字列の集合になる。
】</span>
◎
The URL units are URL code points and percent-encoded bytes.
</p>


<p class="note">注記：
`~percent符号化済~byte$は、［
次を満たす~cp
］を符号化するときに，利用され得る／できる
⇒
［
`~URL~cp$でない
］~OR［
構文~生成規則から除外されている
］
◎
Percent-encoded bytes can be used to encode code points that are not URL code points or are excluded from a syntax production.
</p>

<hr>

<p class="note">注記：
`~URL文字列$の中で，`~URL~record$の［
`~username$url, `~password$url
］を適合するように表す仕方は無い。
◎
There is no conforming way to express a username or password of a URL record within a URL string.
</p>


		</section>
		<section id="url-parsing">
<h3 title="URL parsing">4.2. ~URLの構文解析法</h3>

<div class="p">
<p class="algo-head">
次が与えられた下で：
</p>

<ul><li>%基底 （`基底~URL$, 省略時は ε ）
</li><li>%上書符号化方式 （`符号化方式$, 省略時は ε  ）
</li></ul>

<p>
文字列 %入力 を
`~URL構文解析器@url
にかけるときは、次を走らす：
</p>
◎
The URL parser takes a string input, with an optional base URL base and an optional encoding encoding override, and then runs these steps:
</div>

<p class="note">注記：
非~web~browser実装は、`基本~URL構文解析器$のみ実装すれば~~十分である。
◎
Non-web-browser implementations only need to implement the basic URL parser.
</p>

<ol>
	<li>
%url ~LET
( `基底~URL$ %基底 , `符号化方式$ %上書符号化方式 )
を与える下で，
%入力 を`基本~URL構文解析器$にかけた結果
◎
Let url be the result of running the basic URL parser on input with base, and encoding override as provided.
</li>
	<li>
~IF［
%url ~EQ `failure^i
］
⇒
~RET `failure^i
◎
If url is failure, return failure.
</li>
	<li>
~IF［
%url の`~scheme$url ~NEQ `blob^l
］
⇒
~RET %url
◎
If url’s scheme is not "blob", return url.
</li>
	<li>
~IF［
`blob ~URL store$ `FILEAPI$r の中に，［
%url の`~path$url内の最初の文字列
］に対応する~entryが在る
］
⇒
%url の`~obj$url ~SET その~entryの `StructuredClone$ `HTML$r
◎
If the first string in url’s path is not in the blob URL store, return url. [FILEAPI]
◎
Set url’s object to a StructuredClone of the entry in the blob URL store corresponding to the first string in url’s path. [HTML]
</li>
	<li>
~RET %url
◎
Return url.
</li>
</ol>

<hr>

<div class="p">
<p class="algo-head">
次が与えられた下で：
</p>

<ul><li>%基底 （`基底~URL$, 省略時は ε ）
</li><li>%上書符号化方式 （`符号化方式$, 省略時は ε ）
</li><li>( %url, %上書state )
の組（`~URL$と上書stateの組, 省略時は ( ε, ε ) ）
</li></ul>

<p>
文字列 %入力 を
`基本~URL構文解析器@
にかけるときは、次を走らす：
</p>
◎
The basic URL parser takes a string input, optionally with a base URL base, optionally with an encoding encoding override, optionally with a URL url and a state override state override, and then runs these steps:
</div>


<div class="note">
<p>注記：</p>

<ul>
	<li>
引数 %上書符号化方式 は~HTMLの場合にのみ関わる，旧来の概念である。
`HTML$r
</li>
	<li>
引数 組
( %url, %上書state )
は，種々の API からのみ利用される。
この引数 組が渡されなかった場合、`基本~URL構文解析器$は，`~URL$または `failure^i を返す。
渡された場合、単に 渡された %url に変更を加えた上で，何も返さずに終了する。
</li>
</ul>

◎
The encoding override argument is a legacy concept only relevant for HTML. The url and state override arguments are only for use by various APIs. [HTML]
◎
When the url and state override arguments are not passed, the basic URL parser returns either a new URL or failure. If they are passed, the algorithm simply modifies the passed url and can terminate without returning anything.
</div>


<ol>
	<li>
<p>
~IF［
%url ~EQ ε
］：
◎
If url is not given:
</p>

		<ol>
			<li>
%url ~SET 新たな`~URL$
◎
Set url to a new URL.
</li>
			<li>
~IF［
%入力 の［
先頭または末尾
］の文字 ~IN `~C0制御文字や~space$
］
⇒
`構文違反$
◎
If input contains any leading or trailing C0 controls and space, syntax violation.
</li>
			<li>
%入力 から［［
頭部と尾部
］の，`~C0制御文字や~space$からなる並び
］を除去する
◎
Remove any leading and trailing C0 controls and space from input.
</li>
		</ol>
	</li>
	<li>
~IF［
%入力 に`~tabや改行$が含まれている
］
⇒
`構文違反$
◎
If input contains any tab and newline, syntax violation.
</li>
	<li>
%入力 からすべての`~tabや改行$を除去する
◎
Remove all tab and newline from input.
</li>
	<li>
%state ~LET ［
%上書state ~NEQ ε ならば %上書state ／
~ELSE_ `~scheme開始-$st
］
◎
Let state be state override if given, or scheme start state otherwise.
</li>
	<li>
~IF［
%基底 ~EQ ε
］
⇒
%基底 ~SET ~NULL
◎
If base is not given, set it to null.
</li>
	<li>
%符号化方式 ~LET `~UTF-8$
◎
Let encoding be UTF-8.
</li>
	<li>
~IF［
%上書符号化方式 ~NEQ ε
］
⇒
%符号化方式 ~SET %上書符号化方式 から`出力~符号化方式を取得-$した結果
◎
If encoding override is given, set encoding to the result of getting an output encoding from encoding override.
</li>
	<li>
%~buffer ~LET 空~文字列
◎
Let buffer be the empty string.
</li>
	<li>
<var>@ ~flag</var> ~LET ~OFF ~BR
<var>[] ~flag</var> ~LET ~OFF
◎
Let the @ flag and the [] flag be unset.
</li>
	<li id="_state-machine"><p>
%~pointer ~LET 0 （ %入力 内の最初の~cpを指す~pointer）
◎
Let pointer be a pointer to first code point in input.
</p></li>
	<li>
<p>
%state に応じて動作が切り替わる，次の状態機械を反復実行する。
各反復を終えた時点で、
%~pointer が `EOF$i を指しているならば，反復実行を終えて
<a href="#_the-last-step">次の段</a>
へ移行し、そうでなければ， %~pointer を 1 だけ増加させた上で 次の反復を継続する：
◎
Keep running the following state machine by switching on state. If after a run pointer points to EOF code point, go to the next step. Otherwise, increase pointer by one and continue with the state machine.
</p>

<p class="trans-note">【
この状態機械は、現在の `state^i からは常に，自身または自身より後に示されている `state^i へ遷移するように、整列して記されている。
】【
この状態機械における “~RET” は反復の終了ではなく，この~algo自身の終了を意味する（上述の注記のように，値を返さずに終了することもある）。
】</p>

<!-- 状態遷移の流れ（ “state” は省略）：
scheme start
	scheme
	no scheme
scheme
	no scheme
	special relative/authority
	path/authority
	relative
	special authority slash
	cannot-be-a-base-url path
	file-state
no scheme
	relative
	fragment
special relative/authority
	relative
	special authority ignore slash
path/authority
	authority
	path
relative
	relative slash
	path
	query
	fragment
relative slash
	special authority ignore slash
	file host
	path
special authority slash
	special authority ignore slash
special authority ignore slash
	authority
authority
	host
host = hostname
	port
	path start
port
	path start
file
	file slash
file slash
	file host
file host
	path start
	path
path start
	path
path
	query
	fragment
cannot-be-a-base-url path
	query
	fragment
query
	fragment
fragment
-->

		<dl class="switch">
<!--% scheme-start-state -->
			<dt>`~scheme開始-@st</dt>

			<dd>
				<ol>
					<li>
~IF［
`C$V ~IN `~ASCII英字$
］
⇒
%~buffer ~APPEND ［
`C$V を`~ASCII小文字化$した結果
］~BR
%state ~SET `~scheme$st
◎
If c is an ASCII alpha, append c, lowercased, to buffer, and set state to scheme state.
</li>
					<li>
~ELIF［
%上書state ~EQ ε
］
⇒
%state ~SET `~schemeなし$st ~BR
%~pointer ~DECBY 1
◎
Otherwise, if state override is not given, set state to no scheme state, and decrease pointer by one.
</li>
					<li>
~ELSE
⇒
`構文違反$ ~BR
~RET
◎
Otherwise, syntax violation, terminate this algorithm.
</li>
				</ol>
			</dd>

<!--% scheme-state -->
			<dt>`~scheme@st</dt>
			<dd>
				<ol>
					<li>
~IF［
`C$V ~IN { `~ASCII英数字$, ❝+, ❝-, ❝. }
］
⇒
%~buffer ~APPEND ［
`C$V を`~ASCII小文字化$した結果
］
◎
If c is an ASCII alphanumeric, "+", "-", or ".", append c, lowercased, to buffer.
</li>
					<li>
<p>
~ELIF［
`C$V ~EQ ❝:
］：
◎
Otherwise, if c is ":", run these substeps:
</p>

						<ol>
							<li>
<p>
~IF［
%上書state ~NEQ ε
］：
◎
If state override is given, run these subsubsteps:
</p>

								<ol>
									<li>
~IF［
%url の`~scheme$urlは`特別~scheme$である
］~AND［
%~buffer は`特別~scheme$でない
］
⇒
~RET
◎
If url’s scheme is a special scheme and buffer is not, terminate this algorithm.
</li>
									<li>
~IF［
%url の`~scheme$urlは`特別~scheme$でない
］~AND［
%~buffer は`特別~scheme$である
］
⇒
~RET
◎
If url’s scheme is not a special scheme and buffer is, terminate this algorithm.
</li>
								</ol>
							</li>
							<li>
%url の`~scheme$url ~SET %~buffer
◎
Set url’s scheme to buffer.
</li>
							<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
							<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, terminate this algorithm.
</li>
							<li>
<p>
~IF［
%url の`~scheme$url ~EQ `file^l
］：
◎
If url’s scheme is "file", run these subsubsteps:
</p>
								<ol>
									<li>
~IF［
`残部$V は `//^l から開始されていない
］
⇒
`構文違反$
◎
If remaining does not start with "//", syntax violation.
</li>
									<li>
%state ~SET `~file$st
◎
Set state to file state.
</li>
								</ol>
							</li>
							<li>
<p>
~ELIF［
%url は`特別$である
］~AND［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ %url の`~scheme$url
］
⇒
%state ~SET `特別 相対/権限$st
◎
Otherwise, if url is special, base is non-null, and base’s scheme is equal to url’s scheme, set state to special relative or authority state.
</p>

<p class="note">注記：
これは、`~cannot-be-a-base-URL~flag$は ~OFF にされていることを意味する。
◎
This means that base’s cannot-be-a-base-URL flag is unset.
</p>
							</li>
							<li>
~ELIF［
%url は`特別$である
］
⇒
%state ~SET `特別 権限~slash$st
◎
Otherwise, if url is special, set state to special authority slashes state.
</li>
							<li>
~ELIF［
`残部$V の最初の~cp ~EQ ❝/
］
⇒
%state ~SET `~path/権限$st ~BR
%~pointer ~INCBY 1
◎
Otherwise, if remaining starts with an "/", set state to path or authority state, and increase pointer by one.
</li>
							<li>
~ELSE
⇒
%url の`~cannot-be-a-base-URL~flag$ ~SET ~ON ~BR
%url の`~path$urlに空~文字列を付加する ~BR
%state ~SET `~cannot-be-a-base-URL~path$st
◎
Otherwise, set url’s cannot-be-a-base-URL flag, append an empty string to url’s path, and set state to cannot-be-a-base-URL path state.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%上書state ~NEQ ε
］
⇒
%~buffer ~SET 空~文字列 ~BR
%state ~SET `~schemeなし$st ~BR
%入力 の最初の~cpの所から、やり直す
<span class="trans-note">【
~GOTO この状態機械の<a href="#_state-machine">入り口</a>
】</span>
◎
Otherwise, if state override is not given, set buffer to the empty string, state to no scheme state, and start over (from the first code point in input).
</li>
					<li>
~ELSE
⇒
`構文違反$ ~BR
~RET
◎
Otherwise, syntax violation, terminate this algorithm.
</li>
				</ol>
			</dd>


<!--% no-scheme-state -->
			<dt>`~schemeなし@st</dt>
			<dd>
				<ol>
					<li>
~IF［
%基底 ~EQ ~NULL
］~OR［［
%基底 の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］~AND［
`C$V ~NEQ ❝#
］］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If base is null, or base’s cannot-be-a-base-URL flag is set and c is not "#", syntax violation, return failure.
</li>
					<li>
~ELIF［
%基底 の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］~AND［
`C$V ~EQ ❝#
］
⇒
%url の`~scheme$url ~SET %基底 の`~scheme$url ~BR
%url の`~path$url ~SET %基底 の`~path$url ~BR
%url の`~query$url ~SET %基底 の`~query$url ~BR
%url の`素片$url ~SET 空~文字列 ~BR
%url の`~cannot-be-a-base-URL~flag$ ~SET ~ON ~BR
%state ~SET `素片$st
◎
Otherwise, if base’s cannot-be-a-base-URL flag is set and c is "#", set url’s scheme to base’s scheme, url’s path to base’s path, url’s query to base’s query, url’s fragment to the empty string, set url’s cannot-be-a-base-URL flag, and set state to fragment state.
</li>
					<li>
~ELIF［
%基底 の`~scheme$url ~NEQ `file^l
］
⇒
%state ~SET `相対$st ~BR
%~pointer ~DECBY 1
◎
Otherwise, if base’s scheme is not "file", set state to relative state and decrease pointer by one.
</li>
					<li>
~ELSE
⇒
%state ~SET `~file$st ~BR
%~pointer ~DECBY 1
◎
Otherwise, set state to file state and decrease pointer by one.
</li>
				</ol>
			</dd>


<!--% special-relative-or-authority-state -->
			<dt>`特別 相対/権限@st</dt>
			<dd>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝/
］~AND［
`残部$V の最初の~cp ~EQ ❝/
］
⇒
%state ~SET `特別 権限~slash無視$st ~BR
%~pointer ~INCBY 1
◎
If c is "/" and remaining starts with "/", set state to special authority ignore slashes state and increase pointer by one.
</li>
					<li>
~ELSE
⇒
`構文違反$ ~BR
%state ~SET `相対$st ~BR
%~pointer ~DECBY 1
◎
Otherwise, syntax violation, set state to relative state and decrease pointer by one.
</li>
				</ol>
			</dd>

<!--% path-or-authority-state -->
			<dt>`~path/権限@st</dt>
			<dd>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝/
］
⇒
%state ~SET `権限$st
◎
If c is "/", set state to authority state.
</li>
					<li>
~ELSE
⇒
%state ~SET `~path$st ~BR
%~pointer ~DECBY 1
◎
Otherwise, set state to path state, and decrease pointer by one.
</li>
				</ol>
			</dd>

<!--% relative-state -->
			<dt>`相対@st</dt>
			<dd>
				<ol>
					<li>
%url の`~scheme$url ~SET %基底 の`~scheme$url
◎
↓</li>
					<li>
<p>
`C$V に応じて：
◎
Set url’s scheme to base’s scheme, and then, switching on c:
</p>

						<dl class="switch">
							<dt>`EOF$i</dt>
							<dd>
%url の`~username$url ~SET %基底 の`~username$url ~BR
%url の`~password$url ~SET %基底 の`~password$url ~BR
%url の`~host$url ~SET %基底 の`~host$url ~BR
%url の`~port$url ~SET %基底 の`~port$url ~BR
%url の`~path$url ~SET %基底 の`~path$url ~BR
%url の`~query$url ~SET %基底 の`~query$url
◎
Set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, url’s path to base’s path, and url’s query to base’s query.
</dd>

							<dt>❝/</dt>
							<dd>
%state ~SET `相対~slash$st
◎
Set state to relative slash state.
</dd>

							<dt>❝?</dt>
							<dd>
%url の`~username$url ~SET %基底 の`~username$url ~BR
%url の`~password$url ~SET %基底 の`~password$url ~BR
%url の`~host$url ~SET %基底 の`~host$url ~BR
%url の`~port$url ~SET %基底 の`~port$url ~BR
%url の`~path$url ~SET %基底 の`~path$url ~BR
%url の`~query$url ~SET 空~文字列 ~BR
%state ~SET `~query$st
◎
Set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, url’s path to base’s path, url’s query to the empty string, and state to query state.
</dd>

							<dt>❝#</dt>
							<dd>
%url の`~username$url ~SET %基底 の`~username$url ~BR
%url の`~password$url ~SET %基底 の`~password$url ~BR
%url の`~host$url ~SET %基底 の`~host$url ~BR
%url の`~port$url ~SET %基底 の`~port$url ~BR
%url の`~path$url ~SET %基底 の`~path$url ~BR
%url の`~query$url ~SET %基底 の`~query$url ~BR
%url の`素片$url ~SET 空~文字列 ~BR
%state ~SET `素片$st
◎
Set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, url’s path to base’s path, url’s query to base’s query, url’s fragment to the empty string, and state to fragment state.
</dd>

							<dt>~OTHER</dt>
							<dd>
								<ol>
									<li>
~IF［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
⇒
`構文違反$ ~BR
%state ~SET `相対~slash$st
◎
If url is special and c is "\", syntax violation, set state to relative slash state.
</li>
									<li>
<p>
~ELSE
：
◎
Otherwise, run these steps:
</p>

									<ol>
										<li>
%url の`~username$url ~SET %基底 の`~username$url ~BR
%url の`~password$url ~SET %基底 の`~password$url ~BR
%url の`~host$url ~SET %基底 の`~host$url ~BR
%url の`~port$url ~SET %基底 の`~port$url ~BR
%url の`~path$url ~SET %基底 の`~path$url ~BR
%url の`~path$urlから最後の文字列を除去する
◎
Set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, url’s path to base’s path, and then remove url’s path’s last entry, if any.
</li>
										<li>
%state ~SET `~path$st ~BR
%~pointer ~DECBY 1
◎
Set state to path state, and decrease pointer by one.
</li>
									</ol>
									</li>
								</ol>
							</dd>
						</dl>
					</li>
				</ol>
			</dd>

<!--% relative-slash-state -->
			<dt>`相対~slash@st</dt>
			<dd>
				<ol>
					<li>
<p>
~IF［
`C$V ~EQ ❝/
］~OR［［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］］：
◎
If either c is "/", or url is special and c is "\", run these substeps:
</p>
						<ol>
							<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`構文違反$
◎
If c is "\", syntax violation.
</li>
							<li>
%state ~SET `特別 権限~slash無視$st
◎
Set state to special authority ignore slashes state.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%url の`~username$url ~SET %基底 の`~username$url ~BR
%url の`~password$url ~SET %基底 の`~password$url ~BR
%url の`~host$url ~SET %基底 の`~host$url ~BR
%url の`~port$url ~SET %基底 の`~port$url ~BR
%state ~SET `~path$st ~BR
%~pointer ~DECBY 1
◎
Otherwise, set url’s username to base’s username, url’s password to base’s password, url’s host to base’s host, url’s port to base’s port, state to path state, and then, decrease pointer by one.
</li>
				</ol>
			</dd>

<!--% special-authority-slashes-state -->
			<dt>`特別 権限~slash@st</dt>
			<dd>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝/
］~AND［
`残部$V の最初の~cp ~EQ ❝/
］
⇒
%state ~SET `特別 権限~slash無視$st ~BR
%~pointer ~INCBY 1
◎
If c is "/" and remaining starts with "/", set state to special authority ignore slashes state, and increase pointer by one.
</li>
					<li>
~ELSE
⇒
`構文違反$ ~BR
%state ~SET `特別 権限~slash無視$st ~BR
%~pointer ~DECBY 1
◎
Otherwise, syntax violation, set state to special authority ignore slashes state, and decrease pointer by one.
</li>
				</ol>
			</dd>


<!--% special-authority-ignore-slashes-state -->
			<dt>`特別 権限~slash無視@st</dt>
			<dd>
				<ol>
					<li>
~IF［
`C$V ~NIN { ❝/, ❝\ }
］
⇒
%state ~SET `権限$st ~BR
%~pointer ~DECBY 1
◎
If c is neither "/" nor "\", set state to authority state, and decrease pointer by one.
</li>
					<li>
~ELSE
⇒
`構文違反$
◎
Otherwise, syntax violation.
</li>
				</ol>
			</dd>

<!--% authority-state -->
			<dt>`権限@st</dt>
			<dd>
				<ol>
					<li>
<p>
~IF［
`C$V ~EQ ❝@
］：
◎
If c is "@", run these substeps:
</p>
						<ol>
							<li>
`構文違反$
◎
Syntax violation.
</li>
							<li>
~IF［
<var>@ ~flag</var> ~EQ ~ON
］
⇒
%~buffer の先頭に `%40^l を~~挿入する
◎
If the @ flag is set, prepend "%40" to buffer.
</li>
							<li>
<var>@ ~flag</var> ~SET ~ON
◎
Set the @ flag.
</li>
							<li>
<p>
~FOR
%~buffer 内の~EACH ( %~cp ) に対し：
◎
For each codePoint in buffer, run these substeps:
</p>
								<ol>
									<li>
~IF［
%~cp ~EQ ❝:
］~AND［
`~password$url ~EQ ~NULL
］
⇒
`~password$url ~SET ~NULL ~BR
~CONTINUE
◎
If codePoint is ":" and url’s password is null, set url’s password to the empty string and run these substeps for the next code point.
</li>
									<li>
%符号化済~cp ~LET
`~userinfo 符号化集合$を用いて %~cp を`~UTF-8~percent符号化$した結果
◎
Let encodedCodePoints be the result of running UTF-8 percent encode codePoint using the userinfo encode set.
</li>
									<li>
~IF［
%url の`~password$url ~NEQ ~NULL
］
⇒
%url の`~password$url ~APPEND %符号化済~cp
◎
If url’s password is non-null, append encodedCodePoints to url’s password.
</li>
									<li>
~ELSE
⇒
%url の`~username$url ~APPEND %符号化済~cp
◎
Otherwise, append encodedCodePoints to url’s username.
</li>
								</ol>
							</li>
							<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
次のいずれかが満たされる
］…：
◎
Otherwise, if one of the following is true
</p>
						<ul>
							<li>
`C$V ~IN { `EOF$i, ❝/, ❝?, ❝# } 
◎
c is EOF code point, "/", "?", or "#"
</li>
							<li>
［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
◎
url is special and c is "\"
</li>
						</ul>

<p>
…ならば
⇒
%~pointer ~DECBY %~buffer に含まれる~cpの個数 ~PLUS 1 ~BR
%~buffer ~SET 空~文字列 ~BR
%state ~SET `~host$st
◎
then decrease pointer by the number of code points in buffer plus one, set buffer to the empty string, and set state to host state.
</p>
					</li>
					<li>
~ELSE
⇒
%~buffer ~APPEND `C$V
◎
Otherwise, append c to buffer.
</li>
				</ol>
			</dd>


<!--% host-state -->
			<dt>`~host@st</dt>
<!--% hostname-state -->
			<dt>`~hostname@st</dt>
			<dd>
				<ol>
					<li>
<p>
~IF［
`C$V ~EQ ❝:
］~AND［
<var>[] ~flag</var> ~EQ ~OFF
］：
◎
If c is ":" and the [] flag is unset, run these substeps:
</p>

						<ol>
							<li>
~IF［
%url は`特別$である
］~AND［
%~buffer ~EQ 空~文字列
］
⇒
~RET `failure^i
◎
If url is special and buffer is the empty string, return failure.
</li>
							<li>
%~host ~LET %~buffer を`~host構文解析器$にかけた結果
◎
Let host be the result of host parsing buffer.
</li>
							<li>
~IF［
%~host ~EQ `failure^i 
］
⇒
~RET `failure^i
◎
If host is failure, return failure.
</li>
							<li>
%url の`~host$url ~SET %~host ~BR
%~buffer ~SET 空~文字列 ~BR
%state ~SET `~port$st
◎
Set url’s host to host, buffer to the empty string, and state to port state.
</li>
							<li>
~IF［
%上書state ~EQ `~hostname$st
］
⇒
~RET
◎
If state override is hostname state, terminate this algorithm.
</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
次のいずれかが満たされる
］…：
◎
Otherwise, if one of the following is true
</p>
						<ul>
							<li>
`C$V ~IN { `EOF$i, ❝/, ❝?, ❝# } 
◎
c is EOF code point, "/", "?", or "#"
</li>
							<li>
［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
◎
url is special and c is "\"
</li>
						</ul>
<p>
…ならば：
◎
then decrease pointer by one, and run these substeps: 
</p>

						<ol>
							<li>
%~pointer ~DECBY 1
◎
↑</li>
							<li>
~IF［
%url は`特別$である
］~AND［
%~buffer ~EQ 空~文字列
］
⇒
~RET `failure^i
◎
If url is special and buffer is the empty string, return failure.
</li>
							<li>
%~host ~LET %~buffer を`~host構文解析器$にかけた結果
◎
Let host be the result of host parsing buffer.
</li>
							<li>
~IF［
%~host ~EQ `failure^i 
］
⇒
~RET `failure^i
◎
If host is failure, return failure.
</li>
							<li>
%url の`~host$url ~SET %~host ~BR
%~buffer ~SET 空~文字列 ~BR
%state ~SET `~path開始-$st
◎
Set url’s host to host, buffer to the empty string, and state to path start state.
</li>
							<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, terminate this algorithm.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE
：
◎
Otherwise, run these substeps:
</p>

						<ol>
							<li>
~IF［
`C$V ~EQ ❝[
］
⇒
<var>[] ~flag</var> ~SET ~ON
◎
If c is "[", set the [] flag.
</li>
							<li>
~IF［
`C$V ~EQ ❝]
］
⇒
<var>[] ~flag</var> ~SET ~OFF
◎
If c is "]", unset the [] flag.
</li>
							<li>
%~buffer ~APPEND `C$V
◎
Append c to buffer.
</li>
						</ol>
					</li>
				</ol>
			</dd>

<!--% port-state -->
			<dt>`~port@st</dt>
			<dd>
				<ol>
					<li>
~IF［
`C$V ~IN `~ASCII数字$
］
⇒
%~buffer ~APPEND `C$V
◎
If c is an ASCII digit, append c to buffer.
</li>
					<li>
<p>
~ELIF［
次のいずれかが満たされる
］…：
◎
Otherwise, if one of the following is true
</p>
						<ul>
							<li>
`C$V ~IN { `EOF$i, ❝/, ❝?, ❝# } 
◎
c is EOF code point, "/", "?", or "#"
</li>
							<li>
［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
◎
url is special and c is "\"
</li>
							<li>
%上書state ~NEQ ε
◎
state override is given
</li>
						</ul>
<p>
…ならば：
◎
run these substeps: 
</p>
						<ol>
							<li>
<p>
~IF［
%~buffer は空~文字列でない
］：
◎
If buffer is not the empty string, run these subsubsteps:
</p>
								<ol>
									<li>
%~port ~LET %~buffer を［
その各 `~ASCII数字$を基数 10 による値 0 〜 9 と解釈した
］下で表現される，数学的な整数~値
◎
Let port be the mathematical integer value that is represented by buffer in radix-10 using ASCII digits for digits with values 0 through 9.
</li>
									<li>
~IF［
%~port ~GTE ( 2 の 16 乗 )
］
⇒
`構文違反$ ~BR
~RET `failure^i
◎
If port is greater than 216 − 1, syntax violation, return failure.
</li>
									<li>
%url の`~port$url ~SET［
%~port ~EQ %url の`~scheme$urlの`既定~port$ならば ~NULL ／
~ELSE_ %~port
］
◎
Set url’s port to null, if port is url’s scheme’s default port, and to port otherwise.
</li>
									<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
								</ol>
							</li>
							<li>
~IF［
%上書state ~NEQ ε
］
⇒
~RET
◎
If state override is given, terminate this algorithm.
</li>
							<li>
%state ~SET `~path開始-$st ~BR
%~pointer ~DECBY 1
◎
Set state to path start state, and decrease pointer by one.
</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
`構文違反$ ~BR
~RET `failure^i
◎
Otherwise, syntax violation, return failure.
</li>
				</ol>
			</dd>


<!--% file-state -->
			<dt>`~file@st</dt>
			<dd>
				<ol>
					<li>
%url の`~scheme$url ~SET `file^l
◎
↓</li>
					<li>
<p>
`C$V に応じて：
◎
Set url’s scheme to "file", and then, switching on c:
</p>
						<dl class="switch">
							<dt>`EOF$i</dt>
							<dd>
~IF［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ `file^l
］
⇒
%url の`~host$url ~SET %基底 の`~host$url ~BR
%url の`~path$url ~SET %基底 の`~path$url ~BR
%url の`~query$url ~SET %基底 の`~query$url
◎
If base is non-null and base’s scheme is "file", set url’s host to base’s host, url’s path to base’s path, and url’s query to base’s query.
</dd>

							<dt>❝/</dt>
							<dt>❝\</dt>
							<dd>
								<ol>
									<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`構文違反$
◎
If c is "\", syntax violation.
</li>
									<li>
%state ~SET `~file~slash$st
◎
Set state to file slash state.
</li>
								</ol>
							</dd>

							<dt>❝?</dt>
							<dd>
~IF［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ `file^l
］
⇒
%url の`~host$url ~SET %基底 の`~host$url ~BR
%url の`~path$url ~SET %基底 の`~path$url ~BR
%url の`~query$url ~SET 空~文字列 ~BR
%state ~SET `~query$st
◎
If base is non-null and base’s scheme is "file", set url’s host to base’s host, url’s path to base’s path, url’s query to the empty string, and state to query state.
</dd>

							<dt>❝#</dt>
							<dd>
~IF［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ `file^l
］
⇒
%url の`~host$url ~SET %基底 の`~host$url ~BR
%url の`~path$url ~SET %基底 の`~path$url ~BR
%url の`~query$url ~SET %基底 の`~query$url ~BR
%url の`素片$url ~SET 空~文字列 ~BR
%state ~SET `素片$st
◎
If base is non-null and base’s scheme is "file", set url’s host to base’s host, url’s path to base’s path, url’s query to base’s query, url’s fragment to the empty string, and state to fragment state.
</dd>

							<dt>~OTHER</dt>
							<dd>
								<ol>
									<li>
<p>
~IF［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ `file^l
］~AND［
次のいずれかが満たされる
］…：
◎
If base is non-null, base’s scheme is "file", and at least one of the following is true
</p>
									<ul class="brief">
										<li>
並び［
`C$V, ［
`残部$V の最初の~cp
］］は、`~drive_letter$でない
◎
c and the first code point of remaining are not a Windows drive letter
</li>
										<li>
`残部$V の長さ ~EQ 1
◎
remaining consists of one code point
</li>
										<li>
`残部$V の二番目の~cp ~NIN { ❝/, ❝\, ❝?, ❝# }
◎
remaining’s second code point is not "/", "\", "?", or "#"
</li>
									</ul>
<p>
…ならば
⇒
%url の`~host$url ~SET %基底 の`~host$url ~BR
%url の`~path$url ~SET %基底 の`~path$url ~BR
%url の`~path$urlを`短縮-$する
◎
then set url’s host to base’s host, url’s path to base’s path, and then shorten url’s path.
</p>


<p class="note">注記：
これは~drive_letterのための（~platformに依存しない）過去互換対処である。
◎
This is a (platform-independent) Windows drive letter quirk.
</p>
									</li>
									<li>
~ELIF［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ `file^l
］
⇒
`構文違反$
◎
Otherwise, if base is non-null and base’s scheme is "file", syntax violation.
</li>
									<li>
%state ~SET `~path$st ~BR
%~pointer ~DECBY 1
◎
Set state to path state, and decrease pointer by one.
</li>
								</ol>
							</dd>
						</dl>
					</li>
				</ol>
			</dd>

<!--% file-slash-state -->
			<dt>`~file~slash@st</dt>
			<dd>
				<ol>
					<li>
<p>
~IF［
`C$V ~IN { ❝/, ❝\ }
］
⇒
◎
If c is "/" or "\", run these substeps:
</p>
						<ol>
							<li>
~IF［
`C$V ~EQ ❝\
］
⇒
`構文違反$
◎
If c is "\", syntax violation.
</li>
							<li>
%state ~SET `~file~host$st
◎
Set state to file host state.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE
：
◎
Otherwise, run these substeps:
</p>
						<ol>
							<li>
<p>
~IF［
%基底 ~NEQ ~NULL
］~AND［
%基底 の`~scheme$url ~EQ `file^l
］~AND［［
%基底 の`~path$url内の最初の文字列
］は `正規化済み~drive_letter$である
］
⇒
%url の`~path$urlに［
%基底 の`~path$url内の最初の文字列
］を付加する
◎
If base is non-null, base’s scheme is "file", and base’s path first string is a normalized Windows drive letter, append base’s path first string to url’s path.
</p>

<p class="note">注記：
これは~drive_letterのための（~platformに依存しない）過去互換対処である。
この条件の下では、 %url, %基底 いずれの`~host$urlも~NULLであり、したがって，複製されない。
◎
This is a (platform-independent) Windows drive letter quirk. Both url’s and base’s host are null under these conditions and therefore not copied.
</p>

							</li>
							<li>
%state ~SET `~path$st ~BR
%~pointer ~DECBY 1
◎
Set state to path state, and decrease pointer by one.
</li>
						</ol>
					</li>
				</ol>
			</dd>

<!--% file-host-state -->
			<dt>`~file~host@st</dt>
			<dd>
				<ol>
					<li>
<p>
~IF［
`C$V ~IN { `EOF$i, ❝/, ❝\, ❝?, ❝# }
］：
◎
If c is EOF code point, "/", "\", "?", or "#", decrease pointer by one, and run these substeps:
</p>


						<ol>
							<li>
%~pointer ~DECBY 1
◎
↑</li>
							<li>
<p>
~IF［
%~buffer は`~drive_letter$である
］
⇒
`構文違反$ ~BR
%state ~SET `~path$st
◎
If buffer is a Windows drive letter, syntax violation, set state to path state.
</p>

<p class="note">注記：
これは~drive_letterのための（~platformに依存しない）過去互換対処である。
ここでは %~buffer は再設定されず，代わりに`~path$stの中で利用される。
◎
This is a (platform-independent) Windows drive letter quirk. buffer is not reset here and instead used in the path state.
</p>
</li>
							<li>
~ELIF［
%~buffer ~EQ 空~文字列
］
⇒
%state ~SET `~path開始-$st
◎
Otherwise, if buffer is the empty string, set state to path start state.
</li>
							<li>
<p>
~ELSE
：
◎
Otherwise, run these steps:
</p>
								<ol>
									<li>
%~host ~LET %~buffer を`~host構文解析器$にかけた結果
◎
Let host be the result of host parsing buffer.
</li>
									<li>
~IF［
%~host ~EQ `failure^i 
］
⇒
~RET `failure^i
◎
If host is failure, return failure.
</li>
									<li>
~IF［
%~host ~NEQ `localhost^l
］
⇒
%url の`~host$url ~SET %~host
◎
If host is not "localhost", set url’s host to host.
</li>
									<li>
%~buffer ~SET 空~文字列 ~BR
%state ~SET `~path開始-$st
◎
Set buffer to the empty string and state to path start state.
</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
~ELSE
⇒
%~buffer ~APPEND `C$V
◎
Otherwise, append c to buffer.
</li>
				</ol>
			</dd>

<!--% path-start-state -->
			<dt>`~path開始-@st</dt>
			<dd>
				<ol>
					<li>
~IF［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
⇒
`構文違反$
◎
If url is special and c is "\", syntax violation.
</li>
					<li>
%state ~SET `~path$st ~BR
◎
↓</li>
					<li>
~IF［
`C$V ~NEQ ❝/
］~AND［［［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］］でない
］
⇒
%~pointer ~DECBY 1
◎
Set state to path state, and if neither c is "/", nor url is special and c is "\", decrease pointer by one.
</li>
				</ol>
			</dd>

<!--% path-state -->
			<dt>`~path@st</dt>
			<dd>
				<ol>
					<li>

<p>
~IF［
次のいずれかが満たされる
］…：
◎
If one of the following is true
</p>
						<ul>
							<li>
`C$V ~IN { `EOF$i, ❝/ }
◎
c is EOF code point or "/"
</li>
							<li>
［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
◎
url is special and c is "\"
</li>
							<li>
［
%上書state ~NEQ ε
］~AND［
`C$V ~IN { ❝?, ❝# }
］：
◎
state override is not given and c is "?" or "#"
</li>
						</ul>
<p>
…ならば：
◎
then run these substeps: 
</p>

						<ol>
							<li>
~IF［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\
］
⇒
`構文違反$
◎
If url is special and c is "\", syntax violation.
</li>
							<li>
<p>
~IF［
%~buffer は`二重dot~path区分$synである
］：
</p>
								<ol>
									<li>
%url の`~path$urlを`短縮-$する
</li>
									<li>
~IF［
`C$V ~NEQ ❝/ 
］~AND［［［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\ 
］］でない
］
⇒
%url の`~path$urlに空~文字列を付加する
</li>
								</ol>
◎
If buffer is a double-dot path segment, shorten url’s path, and then if neither c is "/", nor url is special and c is "\", append the empty string to url’s path.
</li>
							<li>
<p>
~ELIF［
%~buffer は`単dot~path区分$synである
］
</p>
								<ol>
									<li>
~IF［
`C$V ~NEQ ❝/ 
］~AND［［［
%url は`特別$である
］~AND［
`C$V ~EQ ❝\ 
］］でない
］
⇒
%url の`~path$urlに空~文字列を付加する
</li>
								</ol>
◎
Otherwise, if buffer is a single-dot path segment and if neither c is "/", nor url is special and c is "\", append the empty string to url’s path.
</li>
							<li>
<p>
~ELSE
：
◎
Otherwise, if buffer is not a single-dot path segment, run these subsubsteps:
</p>

								<ol>
									<li>
<p>
~IF［
%url の`~scheme$url ~EQ `file^l
］~AND［
%url の`~path$urlは空である
］~AND［
%~buffer は`~drive_letter$である
］：
◎
If url’s scheme is "file", url’s path is empty, and buffer is a Windows drive letter, run these subsubsubsteps:
</p>

									<ol>
										<li>
~IF［
%url の`~host$url ~NEQ ~NULL
］
⇒
`構文違反$
◎
If url’s host is non-null, syntax violation.
</li>
										<li>
%url の`~host$url ~SET ~NULL ~BR
%~buffer の二番目の~cpを ❝: に置換する
◎
Set url’s host to null and replace the second code point in buffer with ":".
</li>
									</ol>


<p class="note">注記：
これは~drive_letterのための（~platformに依存しない）過去互換対処である。
◎
This is a (platform-independent) Windows drive letter quirk.
</p>
									</li>
									<li>
%url の`~path$url ~APPEND %~buffer
◎
Append buffer to url’s path.
</li>
								</ol>
							</li>
							<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
							<li>
~IF［
`C$V ~EQ ❝?
］
⇒
%url の`~query$url ~SET 空~文字列 ~BR
%state ~SET `~query$st
◎
If c is "?", set url’s query to the empty string, and state to query state.
</li>
							<li>
~IF［
`C$V ~EQ ❝#
］
⇒
%url の`素片$url ~SET 空~文字列 ~BR
%state ~SET `素片$st
◎
If c is "#", set url’s fragment to the empty string, and state to fragment state.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE
：
◎
Otherwise, run these steps:
</p>
						<ol>
							<li>
~IF［
`C$V ~NIN { `~URL~cp$, ❝% }
］
⇒
`構文違反$
◎
If c is not a URL code point and not "%", syntax violation.
</li>
							<li>
~IF［
`C$V ~EQ ❝%
］~AND［
`残部$V は［
2 個の`~ASCII~hex数字$
］から開始されていない
］
⇒
`構文違反$
◎
If c is "%" and remaining does not start with two ASCII hex digits, syntax violation.
</li>
							<li>
~IF［
`C$V ~EQ ❝%
］~AND［
`残部$V の先頭の 2 文字を`~ASCII小文字化$した結果 ~EQ `2e^l
］
⇒
%~buffer ~APPEND ❝. ~BR
%~pointer ~INCBY 2
◎
If c is "%" and remaining, ASCII lowercased starts with "2e", append "." to buffer and increase pointer by two.
</li>
							<li>
~ELSE
⇒
%~buffer ~APPEND ［
`既定の符号化集合$を用いて `C$V を`~UTF-8~percent符号化$した結果
］
◎
Otherwise, UTF-8 percent encode c using the default encode set, and append the result to buffer..
</li>
						</ol>
					</li>
				</ol>
			</dd>


<!--% cannot-be-a-base-url-path-state -->
			<dt>`~cannot-be-a-base-URL~path@st</dt>
			<dd>
				<ol>
					<li>
~IF［
`C$V ~EQ ❝?
］
⇒ 
%url の`~query$url ~SET 空~文字列 ~BR
%state ~SET `~query$st
◎
If c is "?", set url’s query to the empty string and state to query state.
</li>
					<li>
~ELIF［
`C$V ~EQ ❝#
］
⇒
%url の`素片$url ~SET 空~文字列 ~BR
%state ~SET `素片$st
◎
Otherwise, if c is "#", set url’s fragment to the empty string and state to fragment state.
</li>
					<li>
<p>
~ELSE
：
◎
Otherwise, run these substeps:
</p>
						<ol>
							<li>
~IF［
`C$V ~NIN { `EOF$i, `~URL~cp$, ❝% }
］
⇒
`構文違反$
◎
If c is not EOF code point, not a URL code point, and not "%", syntax violation.
</li>
							<li>
~IF［
`C$V ~EQ ❝%
］~AND［
`残部$V は［
2 個の`~ASCII~hex数字$
］から開始されていない
］
⇒
`構文違反$
◎
If c is "%" and remaining does not start with two ASCII hex digits, syntax violation.
</li>
							<li>
~IF［
`C$V ~NIN { `EOF$i }
］
⇒
［
%url の`~path$url内の最初の文字列
］ ~APPEND ［
`単純 符号化集合$を用いて `C$V を`~UTF-8~percent符号化$した結果
］
◎
If c is not EOF code point, UTF-8 percent encode c using the simple encode set, and append the result to the first string in url’s path.
</li>
						</ol>
					</li>
				</ol>
			</dd>



<!--% query-state -->
			<dt>`~query@st</dt>
			<dd>
				<ol>
					<li>
<p>
~IF［
`C$V ~EQ `EOF$i
］~OR［［
%上書state ~NEQ ε
］~AND［
`C$V ~EQ ❝#
］］：
◎
If c is EOF code point, or state override is not given and c is "#", run these substeps:
</p>

						<ol>
							<li>
~IF［
%url は`特別$でない
］~OR［
%url の`~scheme$url ~IN { `ws^l, `wss^l }
］
⇒
%符号化方式 ~SET `~UTF-8$
◎
If url is not special or url’s scheme is either "ws" or "wss", set encoding to UTF-8.
</li>
							<li>
%~buffer ~SET
%符号化方式 を用いて %~buffer を`符号化$した結果
◎
Set buffer to the result of encoding buffer using encoding.
</li>
							<li>
<p>
~FOR
%~buffer 内の~EACH ( %~byte ) に対し：
◎
For each byte in buffer run these subsubsteps:
</p>
								<ol>
									<li>
~IF［
%~byte ~IN { 0 〜 `20^X, `22^X, `23^X, `3C^X, `3E^X, `7F^X 〜 `FF^X }
］
⇒
%url の`~query$url ~APPEND %~byte を`~percent符号化$した結果
◎
If byte is less than 0x21, greater than 0x7E, or is 0x22, 0x23, 0x3C, or 0x3E, append byte, percent encoded, to url’s query.
</li>
									<li>
~ELSE
⇒
%url の`~query$url ~APPEND %~byte を値とする~cp
◎
Otherwise, append a code point whose value is byte to url’s query.
</li>
								</ol>
							</li>
							<li>
%~buffer ~SET 空~文字列
◎
Set buffer to the empty string.
</li>
							<li>
~IF［
`C$V ~EQ ❝#
］
⇒
%url の`素片$url ~SET 空~文字列 ~BR
%state ~SET `素片$st
◎
If c is "#", set url’s fragment to the empty string, and state to fragment state.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE
：
◎
Otherwise, run these substeps:
</p>
						<ol>
							<li>
~IF［
`C$V ~NIN { `~URL~cp$, ❝% }
］
⇒
`構文違反$
◎
If c is not a URL code point and not "%", syntax violation.
</li>
							<li>
~IF［
`C$V ~EQ ❝%
］~AND［
`残部$V は［
2 個の`~ASCII~hex数字$
］から開始されていない
］
⇒
`構文違反$
◎
If c is "%" and remaining does not start with two ASCII hex digits, syntax violation.
</li>
							<li>
%~buffer ~APPEND `C$V
◎
Append c to buffer.
</li>
						</ol>
					</li>
				</ol>
			</dd>


<!--% fragment-state -->
			<dt>`素片@st</dt>
			<dd>
<p>
`C$V に応じて：
◎
Switching on c:
</p>
				<dl class="switch">
					<dt>`EOF$i</dt>
					<dd>
何もしない
◎
Do nothing.
</dd>

					<dt>`0000^U</dt>
					<dd>
`構文違反$
◎
Syntax violation.
</dd>

					<dt>~OTHER</dt>
					<dd>
						<ol>
							<li>
~IF［
`C$V ~NIN { `~URL~cp$, ❝% }
］
⇒
`構文違反$
◎
If c is not a URL code point and not "%", syntax violation.
</li>
							<li>
~IF［
`C$V ~EQ ❝%
］~AND［
`残部$V は［
2 個の`~ASCII~hex数字$
］から開始されていない
］
⇒
`構文違反$
◎
If c is "%" and remaining does not start with two ASCII hex digits, syntax violation.
</li>
							<li>
<p>
%url の`素片$url ~APPEND `C$V
◎
Append c to url’s fragment.
</p>

<p class="note">注記：
あいにく、`~percent符号化$を利用しないのは，意図的である
— それが市場の主流~実装に見られる挙動なので。
◎
Unfortunately not using percent-encoding is intentional as implementations with majority market share exhibit this behavior.
</p>
							</li>
						</ol>
					</dd>
				</dl>
			</dd>
		</dl>
	</li>
	<li id="_the-last-step"><p>
~RET %url
◎
Return url.
</p></li>
</ol>



<hr>

<p class="algo-head">
所与の %~username を用いて， %url の<!-- concept-url -->
`~usernameを設定する@
ときは、次を走らす：
◎
To set the username given a url and username, run these steps:
</p>

<ol>
	<li>
%url の`~username$url ~SET 空~文字列
◎
Set url’s username to the empty string.
</li>
	<li>
~FOR
%~username 内の
~EACH ( ~cp %C ) に対し
⇒
%url の`~username$url ~APPEND ［
`~userinfo 符号化集合$を用いて %C を`~UTF-8~percent符号化$した結果
］
◎
For each code point in username, UTF-8 percent encode it using the userinfo encode set, and append the result to url’s username.
</li>
</ol>


<p class="algo-head">
所与の %~password を用いて， %url の
`~passwordを設定する@
ときは、次を走らす：
◎
To set the password given a url and password, run these steps:
</p>

<ol>
	<li>
~IF［
%~password ~EQ 空~文字列
］
⇒
%url の`~password$url ~SET ~NULL
◎
If password is the empty string, set url’s password to null.
</li>
	<li>
		<p>
~ELSE
：
◎
Otherwise, run these substeps:
</p>

		<ol>
			<li>
%url の`~password$url ~SET 空~文字列
◎
Set url’s password to the empty string.
</li>
			<li>
~FOR
%~password 内の
~EACH ( ~cp %C ) に対し
⇒
%url の`~password$url ~APPEND ［
`~userinfo 符号化集合$を用いて %C を`~UTF-8~percent符号化$した結果
］
◎
For each code point in password, UTF-8 percent encode it using the userinfo encode set, and append the result to url’s password.
</li>
		</ol>
	</li>
</ol>


		</section>
		<section id="url-serializing">
<h3 title="URL serializing">4.3. ~URLの直列化法</h3>

<div class="p">
<p class="algo-head">
次が与えられた下で：
</p>

<ul><li>%素片除外~flag（省略時は ~OFF ）
</li></ul>

<p>
所与の`~URL$ %url を
`~URL直列化器@url
にかけるときは、次を走らす：
◎
The URL serializer takes a URL url, an optional exclude fragment flag, and then runs these steps: 
</p>
</div>

<ol>
	<li>
%出力 ~LET
空~文字列 ~APPEND %url の`~scheme$url ~APPEND ❝:
◎
Let output be url’s scheme and ":" concatenated.
</li>
	<li>
<p>
~IF［
%url の`~host$url ~NEQ ~NULL
］：
◎
If url’s host is non-null:
</p>
		<ol>
			<li>
%出力 ~APPEND `//^l
◎
Append "//" to output.
</li>
			<li>
<p>
~IF［
%url の`~username$url ~NEQ 空~文字列
］~OR［
%url の`~password$url ~NEQ ~NULL
］：
◎
If url’s username is not the empty string or url’s password is non-null, run these substeps:
</p>
				<ol>
					<li>
%出力 ~APPEND %url の`~username$url
◎
Append url’s username to output.
</li>
					<li>
~IF［
%url の`~password$url ~NEQ ~NULL
］
⇒
%出力 ~APPEND ❝:
~APPEND %url の`~password$url
◎
If url’s password is non-null, append ":", followed by url’s password, to output.
</li>
					<li>
%出力 ~APPEND ❝@
◎
Append "@" to output.
</li>
				</ol>

			</li>
			<li>
%出力 ~APPEND ［
%url の`~host$urlを `~host直列化器$にかけた結果
］
◎
Append url’s host, serialized, to output.
</li>
			<li>
~IF［
%url の`~port$url ~NEQ ~NULL
］
⇒
%出力 ~APPEND ❝:
~APPEND ［
%url の`~port$urlを`直列化-$した結果
］
◎
If url’s port is non-null, append ":" followed by url’s port, serialized, to output.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%url の`~host$url ~EQ ~NULL
］~AND［
%url の`~scheme$url ~EQ `file^l
］
⇒
%出力 ~APPEND `//^l
◎
Otherwise, if url’s host is null and url’s scheme is "file", append "//" to output.
</li>
	<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
%出力 ~APPEND ［
%url の`~path$url内の最初の文字列
］
◎
If url’s cannot-be-a-base-URL flag is set, append the first string in url’s path to output.
</li>
	<li>
~ELSE
⇒
%url の`~path$url内の ~EACH ( 文字列 %s （空~文字列も含む） ) に対し
⇒
%出力 ~APPEND ❝/ ~APPEND %s
◎
Otherwise, append "/", followed by the strings in url’s path (including empty strings), separated from each other by "/", to output.
</li>
	<li>
~IF［
%url の`~query$url ~NEQ ~NULL
］
⇒
%出力 ~APPEND ❝?
~APPEND %url の`~query$url
◎
If url’s query is non-null, append "?", followed by url’s query, to output.
</li>
	<li>
~IF［
%素片除外~flag ~EQ ~OFF
］~AND［
%url の`素片$url ~NEQ ~NULL
］
⇒
%出力 ~APPEND ❝#
~APPEND %url の`素片$url
◎
If the exclude fragment flag is unset and url’s fragment is non-null, append "#", followed by url’s fragment, to output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>


		</section>
		<section id="url-equivalence">
<h3 title="URL equivalence">4.4. ~URLの等価性</h3>

<p class="algo-head">
二つの`~URL$［
%A, %B
］は、次を走らせた結果が ~T ならば［
所与の %素片除外~flag の下で
`等しい@
］とされる：
◎
To determine whether a URL A equals B, optionally with an exclude fragments flag, run these steps:
</p>


<ol>
	<li>
( %A1, %B1 ) ~LET 順に，
%素片除外~flag をそのまま引き継いだ下で
( %A, %B ) を`~URL直列化器$urlにかけた結果
◎
Let serializedA be the result of serializing A, with the exclude fragment flag set if the exclude fragments flag is set.
◎
Let serializedB be the result of serializing B, with the exclude fragment flag set if the exclude fragments flag is set.
</li>
	<li>
<p>
~RET［
%A1 ~EQ %B1 ならば ~T ／
~ELSE_ ~F
］
◎
Return true if serializedA is serializedB, and false otherwise. 
</p></li></ol>

		</section>
		<section id="origin">
<h3 title="Origin">4.5. 生成元</h3>

<p class="note">注記：
必要な背景情報については，~HTMLによる`生成元$の定義を見よ。
`HTML$r
◎
See origin’s definition in HTML for the necessary background information. [HTML]
</p>

<p class="algo-head">
`~URL$の
`生成元@url
とは、`~URL$の`~scheme$urlに応じて，次の手続きから得られる`生成元$である：
◎
A URL’s origin is the origin returned by running these steps, switching on URL’s scheme:
</p>

<dl class="switch">

	<dt>`blob^l</dt>
	<dd>
<p>
%url ~LET ［
`~URL$の`~path$url内の最初の文字列
］を`基本~URL構文解析器$にかけた結果
◎
Let url be the result of parsing the first string in URL’s path.
</p>

<p>
~RET ［
%url ~EQ `failure^i ならば 新たな`不透明な生成元$ ／
~ELSE_ %url の`生成元$url
］
◎
Return a new opaque origin, if url is failure, and url’s origin otherwise.
</p>

<p class="example">
`blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f^l
の`生成元$urlは、成分組
( `https^c, `whatwg.org^c, `443^c, ~NULL )
である。
◎
The origin of blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f is the tuple (https, whatwg.org, 443, null).
</p>

	</dd>

	<dt>`ftp^l</dt>
	<dt>`gopher^l</dt>
	<dt>`http^l</dt>
	<dt>`https^l</dt>
	<dt>`ws^l</dt>
	<dt>`wss^l</dt>
	<dd>
~RET
`~URL$の
( `~scheme$url, `~host$url, `~port$url, ~NULL )
からなる成分組
◎
Return a tuple consisting of URL’s scheme, URL’s host, URL’s port, and null.
</dd>

	<dt>`file^l</dt>
	<dd>
あいにく、これについては，実装に委ねられる。
疑わしい場合は 新たな`不透明な生成元$を返すこと。
◎
Unfortunate as it is, this is left as an exercise to the reader. When in doubt, return a new opaque origin.
</dd>

	<dt>~OTHER</dt>
	<dd>
<p>
~RET 新たな`不透明な生成元$
◎
Return a new opaque origin.
</p>

<p class="note">注記：
これは~~実際に、これらの`~URL$は，それら自身と`同一生成元$になり得ないことを意味する。
<span class="trans-note">【
“それら自身” — 毎回，異なる結果が返される意味で、と思われる（ JavaScript の NaN のように，返される結果と <em>それ</em> 自身とを比較した結果が異なるものとされるのではなく）。
】</span>
◎
This does indeed mean that these URLs cannot be same-origin with themselves. </p>
	</dd>

</dl>

		</section>
		<section id="url-rendering">
<h3 title="URL rendering">4.6. ~URLの描画法</h3>

<p>
`~URL$の描画に際しては、`~URL直列化器$urlにかけた形を基に，以下の~~変更を加えるべきである：
◎
A URL should be rendered in its serialized form, with these modifications:
</p>

<ul>
	<li>
`~URL$の `~username$url, `~password$urlは、`~URL$の`~host$urlに~~誤認され易いので描画されるべきでない。
例えば，
<samp>https://examplecorp.com@attacker.example/</samp>
。
◎
A URL’s username and password should not be rendered as they can be mistaken for a URL’s host. E.g., consider https://examplecorp.com@attacker.example/.
</li>
	<li>
`~URL$の`~host$urlは、`~Unicodeへ変換-$した結果を用いて描画されるべきである。
◎
A URL’s host should be rendered using domain to Unicode.
</li>
	<li>
`~URL$synの他の部分における`~percent符号化済~byte$並びは、それを`~percent復号-$した結果の~byte列による~cpに置換されるべきである
— その結果が不可視になる場合は除いて。
◎
Other parts of the URL should have their sequences of percent-encoded bytes replaced with code points resulting from percent decoding those sequences converted to bytes, unless that renders those sequences invisible.
</li>
</ul>

<p class="trans-note">【
ここでの描画（ rendering ）には、音声化なども含まれる
— その場合の取り扱いは多少異なるものになるであろうが，同様の趣旨に従うことになる。
】</p>

<p>
双方向的~textの目的においては、左横書き埋込み（ left-to-right embedding ）であったかのように描画されるべきである。
`BIDI$r
◎
For the purposes of bidirectional text it should be rendered as if it were in a left-to-right embedding. [BIDI]
</p>

<p class="note">
あいにく、描画された`~URL$は，どこにでも現れるような単なる文字列であり、描画される`~URL$に特有の双方向的~algoがあっても，広範に採用される見込みは薄いであろう。
双方向的~textによる~URLの各部への~~作用は、ここでの~modelと異なる描画にさせ得る。
したがって，双方向的~言語の利用者は、特に，素の~text環境の下では，このことについて予期しておくよう注意されたし。
◎
Unfortunately, as rendered URLs are simply strings and can appear anywhere, a specific bidirectional algorithm for rendered URLs would not see wide adoption. Bidirectional text interacts with the parts of a URL in ways that can cause the rendering to be different from the model. Users of bidirectional languages are thus cautioned that this is to be expected, particularly in plain text environments.
</p>

<p>
双方向的~textにおいては、`~URL$の`~host$urlと`~path$urlが，誤認され易くなる。
そのため，~browserには、利用者が この二つを判別できることが重要になる所では，
`~URL$の`~host$urlのみを描画することが奨励される。
例えば利用者は、~address~bar内に描画された`~URL$の`~host$urlに基いて，信用に関する決断を下すものと予期されるので。
◎
Due to the confusion that can arise between a URL’s host and path with bidirectional text, browsers are encouraged to only render a URL’s host in places where it is important for users to distinguish between the two. E.g., users are expected to make trust decisions based on a URL’s host rendered in the address bar.
</p>

		</section>
	</section>
	<section id="application/x-www-form-urlencoded">
<h2 title="application/x-www-form-urlencoded">5. ~FORMENC</h2>


<p>
`~FORMENC@
形式は、［
名, 値がともに［
`~ASCII~byte$のみからなる~byte列
］で与えられるような，名値~組
］からなる並びを符号化する，単純な仕方を与える。
◎
The application/x-www-form-urlencoded format is a simple way to encode name-value pairs in a byte sequence where all bytes are ASCII bytes.
</p>


<p class="note">注記：
~FORMENC形式は、何年にもわたる実装の不幸な巡り合わせの結果，多くの面で奇異なものになっており、相互運用性のために必要とされる要件の集合からなる，妥協の産物である
— 良い設計の実施を表現する仕方は無い。
読者は特に、文字~符号化方式と~byte列との間で繰り返される（場合によっては入子にされた）変換のひねくれた詳細に，注意を払うように。
あいにく，この形式は~HTML~formに普及しているがため、広く利用されている。
`HTML$r
◎
The application/x-www-form-urlencoded format is in many ways an aberrant monstrosity, the result of many years of implementation accidents and compromises leading to a set of requirements necessary for interoperability, but in no way representing good design practices. In particular, readers are cautioned to pay close attention to the twisted details involving repeated (and in some cases nested) conversions between character encodings and byte sequences. Unfortunately the format is in widespread use due to the prevalence of HTML forms.[HTML]
</p>

		<section id="urlencoded-parsing">
<h3 title="application/x-www-form-urlencoded parsing">5.1. ~FORMENC構文解析法</h3>

<p class="note">注記：
`~FORMENC構文解析器$により提供される特色機能は、主に~server指向の実装に関連する。
~browserに基づく実装は、`~FORMENC文字列~構文解析器$から要求されるもののみを必要とする。
◎
The features provided by the application/x-www-form-urlencoded parser are mainly relevant for server-oriented implementations. A browser-based implementation only needs what the application/x-www-form-urlencoded string parser requires.
</p>

<div class="p">
<p class="algo-head">
次が与えられた下で：
</p>

<ul><li>%上書符号化方式（`符号化方式$, 省略時は ε ）
</li><li>%~_charset_利用~flag（省略時は ~OFF）
</li></ul>

<p>
~byte列 %入力 を
`~FORMENC構文解析器@
にかけるときは、次を走らす：
</p>
◎
The application/x-www-form-urlencoded parser takes a byte sequence input, optionally with an encoding encoding override, and optionally with a use _charset_ flag, and then runs these steps: 
</div>

<ol>
	<li>
%符号化方式 ~LET `~UTF-8$
◎
Let encoding be UTF-8.
</li>
	<li>
~IF［
%上書符号化方式 ~NEQ ε
］
⇒
%符号化方式 ~SET %上書符号化方式
◎
If encoding override is given, set encoding to encoding override.
</li>
	<li>
<p>
~IF［
%符号化方式 ~NEQ `~UTF-8$
］~AND［
%入力 内に［
`~ASCII~byte$でない~byte
］がある
］
⇒
~RET `failure^i
◎
If encoding is not UTF-8 and input contains bytes that are not ASCII bytes, return failure.
</p>

<p class="note">注記：
これは、 %入力 が［
`~FORMENC直列化器$や `URLSearchParams$I
］を通して生成されたものでない場合にのみ生じる。
◎
This can only happen if input was not generated through the serializer or URLSearchParams.
</p>

	</li><li>
%~byte列~list ~LET %入力 を `&amp;^bl で分割した結果
◎
Let sequences be the result of splitting input on `&amp;`.
</li>
	<li>
%組~list ~LET 空~list（名, 値のいずれも~byte列であるような，名値~組からなる~list）
◎
Let tuples be an empty list of name-value tuples where both name and value hold a byte sequence.
</li>
	<li>
<p>
~FOR
%~byte列~list 内の~EACH ( %~byte列 ) に対し：
◎
For each byte sequence bytes in sequences, run these substeps:
</p>

		<ol>
			<li>
~IF［
%~byte列 ~EQ 空~byte列
］
⇒
~CONTINUE
◎
If bytes is the empty byte sequence, run these substeps for the next byte sequence.
</li>
			<li>
~IF［
%~byte列 内に ❛= が含まれている
］
⇒
( %名, %値 ) ~LET  %~byte列 を最初の ❛= の所で 2 個の~byte列に分割した結果（その最初の ❛= は結果に含めない — したがって，いずれも空~byte列になり得る）
◎
If bytes contains a `=`, then let name be the bytes from the start of bytes up to but excluding its first `=`, and let value be the bytes, if any, after the first `=` up to the end of bytes. If `=` is the first byte, then name will be the empty byte sequence. If it is the last, then value will be the empty byte sequence.
</li>
			<li>
~ELSE
⇒
( %名, %値 ) ~LET ( %~byte列, 空~byte列 )
◎
Otherwise, let name have the value of bytes and let value be the empty byte sequence.
</li>
			<li>
［
%名, %値
］内のすべての ❛+ を `20^X に置換する
◎
Replace any `+` in name and value with 0x20.
</li>
			<li>
<p>
~IF［
%~_charset_利用~flag ~EQ ~ON
］~AND［
%名 ~EQ `_charset_^bl
］：
◎
If use _charset_ flag is set and name is `_charset_`, run these substeps:
</p>

				<ol>
					<li>
%結果 ~LET ［
%値 を`~BOMを取扱わずに~UTF-8復号-$した結果
］から，`符号化方式を取得-$した結果
◎
Let result be the result of getting an encoding for value, decoded.
</li>
					<li>
~IF［
%結果 ~NEQ `failure^i
］
⇒
%~_charset_利用~flag ~SET ~OFF ~BR
%符号化方式 ~SET %e
◎
If result is not failure, unset use _charset_ flag and set encoding to result.
</li>
	</ol>
			</li>
			<li>
%組~list に 組( %名 : %値 ) を追加する
◎
Add a tuple consisting of name and value to tuples.
</li>
		</ol>

	</li><li>
%出力 ~LET 空~list（名, 値のいずれも文字列であるような，名値~組からなる~list）
◎
Let output be an empty list of name-value tuples where both name and value hold a string.
</li>
	<li>
<p>
~FOR
%組~list 内の ~EACH ( 組( %名 : %値 ) ) に対し
：
</p>

		<ol>
			<li>
( %名, %値 ) ~LET ［
%名, %値
］のそれぞれに対し 順に，`~percent復号-$した結果を %符号化方式 を用いて`復号-$した結果
</li>
			<li>
%出力 に 組( %名 : %値 ) を追加する
</li>
</ol>

◎
For each name-value tuple in tuples, append a name-value tuple to output where the new name and value appended to output are the result of running decode on the percent decoding of the name and value from tuples, respectively, using encoding.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>


		</section>
		<section id="urlencoded-serializing">
<h3 title="application/x-www-form-urlencoded serializing">5.2. ~FORMENC直列化法</h3>

<p class="algo-head">
`~FORMENC~byte直列化器@
は、~byte列 %入力 を入力にとり，次を走らす：
◎
The application/x-www-form-urlencoded byte serializer takes a byte sequence input and then runs these steps:
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
<p>
%入力 内の~EACH ( %~byte ) に対し
⇒
%出力 ~APPEND ［
%~byte に応じて次で与えられる文字列
］：
◎
For each byte in input, depending on byte:
</p>

		<dl class="switch">
			<dt>`20^X</dt>
			<dd>
`002B^U
<span class="trans-note">【
❝+
】</span>
◎
Append U+002B to output.
</dd>

			<dt>`2A^X</dt>
			<dt>`2D^X</dt>
			<dt>`2E^X</dt>
			<dt>`30^X 〜 `39^X</dt>
			<dt>`41^X 〜 `5A^X</dt>
			<dt>`5F^X</dt>
			<dt>`61^X 〜 `7A^X</dt>
			<dd>
%~byte を値とする~cp
◎
Append a code point whose value is byte to output.
</dd>

			<dt>~OTHER</dt>
			<dd>
%~byte を`~percent符号化$した結果
◎
Append byte, percent encoded, to output.
</dd>

		</dl>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<div class="p">
<p class="algo-head">
次が与えられた下で：
</p>

<ul><li>%上書符号化方式（`符号化方式$, 省略時は ε ）
</li></ul>

<p>
［
名値 の組, または
( 名, 値, 型 ) の組
］からなる~list %組~list を
`~FORMENC直列化器@
にかけるときは、次を走らす：
</p>
◎
The application/x-www-form-urlencoded serializer takes a list of name-value or name-value-type tuples tuples, optionally with an encoding encoding override, and then runs these steps:
</div>

<ol>
	<li>
%符号化方式 ~LET `~UTF-8$
◎
Let encoding be UTF-8.
</li>
	<li>
~IF［
%上書符号化方式 ~NEQ ε
］
⇒
%符号化方式 ~SET %上書符号化方式 から`出力~符号化方式を取得-$した結果
◎
If encoding override is given, set encoding to the result of getting an output encoding from encoding override.
</li>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
<p>
~FOR
%組~list 内の~EACH ( %組 ) に対し：
◎
For each tuple in tuples, run these substeps:
</p>

		<ol>
			<li>
%出力~組 ~LET 新たな名値~組
◎
Let outputPair be a new name-value pair.
</li>
			<li>
%出力~組 の名 ~SET ［
%組 の名を %符号化方式 を用いて`符号化$した結果
］を`~FORMENC~byte直列化器$にかけた結果
◎
Set outputPair’s name to the result of serializing the result of encoding tuple’s name, using encoding.
</li>
			<li>
~IF［
%組 は型を有する
］~AND［
%組 の型 ~EQ `hidden^l
］~AND［
%出力~組 の名 ~EQ `_charset_^l
］
⇒
%出力~組 の値 ~SET %符号化方式 の`名前$
◎
If tuple has a type, tuple’s type is "hidden", and outputPair’s name is "_charset_", set outputPair’s value to encoding’s name.
</li>
			<li>
~ELIF［
%組 は型を有する
］~AND［
%組 の型 ~EQ `file^l
］⇒
%出力~組 の値 ~SET %組 の値（ ~filename ）
◎
Otherwise, if tuple has a type, and tuple’s type is "file", set outputPair’s value to tuple’s value’s filename.
</li>
			<li>
~ELSE
⇒
%出力~組 の値 ~SET %組 の値を［
%符号化方式 を用いて，`符号化$した結果
］を`~FORMENC~byte直列化器$にかけた結果
◎
Otherwise, set outputPair’s value to the result of serializing the result of encoding tuple’s value, using encoding.
</li>
			<li>
~IF［
%組 は %組~list 内の最初の組でない
］
⇒
%出力 ~APPEND `&amp;^l
◎
If tuple is not the first pair in tuples, then append "&amp;" to output.
</li>
			<li>
%出力
~APPEND %出力~組 の名
~APPEND ❝=
~APPEND %出力~組 の値
◎
Append outputPair’s name, followed by "=", followed by outputPair’s value, to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

<p class="note">注記：
`HTML$r は
( 名, 値, 型 )
の組からなる~listで この~algoを呼び出す。
◎
The HTML standard invokes this algorithm with name-value-type tuples. [HTML]
</p>


		</section>
		<section id="urlencoded-hooks">

<h3 title="Hooks">5.3. ~hooks</h3>

<p class="algo-head">
`~FORMENC文字列~構文解析器@
は、文字列 %入力 を入力にとり，それを`~UTF-8符号化$した結果を入力~byte列として，`~FORMENC構文解析器$にかけた結果を返す。
◎
The application/x-www-form-urlencoded string parser takes a string input, UTF-8 encodes it, and then returns the result of application/x-www-form-urlencoded parsing it.
</p>


		</section>
	</section>

	<section id="api">
<h2 title="API">6. API</h2>

<pre class="idl">[<a href="#dom-url-url">Constructor</a>(USVString %url, optional USVString %base),
`Exposed$=(Window,Worker)]
interface `URL@I {
  `stringifier@m attribute USVString `href$m;
  readonly attribute USVString `origin$m;

           attribute USVString `protocol$m;
           attribute USVString `username$m;
           attribute USVString `password$m;
           attribute USVString `host$m;
           attribute USVString `hostname$m;
           attribute USVString `port$m;
           attribute USVString `pathname$m;
           attribute USVString `search$m;
  [`SameObject$] readonly attribute `URLSearchParams$I `searchParams$m;
           attribute USVString `hash$m;
};</pre>


<div class="p">
<p>
各 `URL$I ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`~url@url</dt>
	<dd>
`~URL$
</dd>
	<dt>`~query~obj@url</dt>
	<dd>
`URLSearchParams$I ~obj
</dd>
</dl>

◎
A URL object has an associated url (a URL) and query object (a URLSearchParams object).
</div>

	<section id="constructors">
<h3 title="Constructors">6.1. 構築子</h3>

<p class="idl-def">
`URL(url, base)@m
構築子の被呼出時には、次を走らせ~MUST：
◎
The URL(url, base) constructor, when invoked, must run these steps:
</p>

<ol>
	<li>
%解析済~基底 ~LET ~NULL
◎
Let parsedBase be null.
</li>
	<li>
<p>
~IF［
%base は与えられている
］：
◎
If base is given, run these substeps:
</p>
		<ol>
			<li>
%解析済~基底 ~SET %base を`基本~URL構文解析器$にかけた結果
◎
Let parsedBase be the result of running the basic URL parser on base.
</li>
			<li>
~IF［
%解析済~基底 ~EQ `failure^i
］
⇒
~THROW `TypeError^E
◎
If parsedBase is failure, throw a TypeError exception.
</li>
		</ol>
	</li>
	<li>
%解析済~URL ~LET ［
`基底~URL$ : %解析済~基底
］を与える下で， %url を`基本~URL構文解析器$にかけた結果
◎
Let parsedURL be the result of running the basic URL parser on url with parsedBase.
</li>
	<li>
~IF［
%解析済~URL ~EQ `failure^i
］
⇒
~THROW `TypeError^E
◎
If parsedURL is failure, throw a TypeError exception.
</li>
	<li>
%~query ~LET ［
%解析済~URL の `~query$url ~NEQ ~NULL ならば それ ／
~ELSE_ 空~文字列
］
◎
Let query be parsedURL’s query, if that is non-null, and the empty string otherwise.
</li>
	<li>
%結果 ~LET 新たな `URL$I ~obj
<span class="trans-note">【
この段は、この訳による補完。
】</span>
</li>
	<li>
%結果 の`~url$url ~SET %解析済~URL
◎
Set result’s url to parsedURL.
</li>
	<li>
%~obj ~SET %~query から`新たな~URLSearchParams~objを作成-$した結果
◎
↓</li>
	<li>
%結果 の`~query~obj$url ~SET %~obj
◎
↓</li>
	<li>
%~obj の`~url~obj$ ~SET %結果
◎
Set result’s query object to a new URLSearchParams object using query, and then set that query object’s url object to result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<div class="example">

<p>
`基底~URL$を用いずに，文字列を<a href="#concept-basic-url-parser">構文解析して</a> `~URL$を得るときは、単独の引数で `URL$I 構築子を呼び出す：
◎
To parse a string into a URL without using a base URL, invoke the URL constructor with a single argument:
</p>

<pre>
var %input = "https://example.org/💩";
var %url = new URL(%input);
%url.pathname; // `/%F0%9F%92%A9^l
</pre>

<p>
次のものは、入力が`絶対~URL$synでない場合には，例外を投出する：
◎
This throws an exception if the input is not an absolute URL:
</p>

<pre>
try {
  var %url = new URL("/🍣🍺");
} catch(%e) {
  // <span class="comment" title="that happened">ここに来る</span>
}
</pre>

<p>
入力が`相対~URL$synの場合には、`基底~URL$が必要とされる：
◎
A base URL is necessary if the input is a relative URL:
</p>

<pre>
var %input = "/🍣🍺";
var %url = new URL(%input, document.baseURI);
%url.href; // `https://url.spec.whatwg.org/%F0%9F%8D%A3%F0%9F%8D%BA^l
</pre>

<p>
`URL$I ~objは`基底~URL$として利用できる（ IDL からは文字列を引数にとるよう要求されるが、 `URL$I ~objは，その `href$m 属性~値に文字列化される）：
◎
A URL object can be used as base URL (while IDL requires a string as argument, a URL object stringifies to its href attribute value):
</p>

<pre>
var %url = new URL("🏳🌈", new URL("https://pride.example/hello-world"))
%url.pathname // `/%F0%9F%8F%B3%EF%B8%8F%E2%80%8D%F0%9F%8C%88^l
</pre>

</div>

		</section>
		<section id="urlutils-members">
<h3 title="URL members">6.2. `URL^I の各種~member</h3>

<dl class="idl-def">
	<dt>`href@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>

		<ol>
			<li>
~RET 此れの`~url$urlを`~URL直列化器$urlにかけた結果
</li>
		</ol>
◎
The href attribute’s getter must return the serialization of context object’s url.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The href attribute’s setter must run these steps:
</p>

		<ol>
			<li>
%解析済~URL ~LET
所与の値を`基本~URL構文解析器$にかけた結果
◎
Let parsedURL be the result of running the basic URL parser on the given value.
</li>
			<li>
~IF［
%解析済~URL ~EQ `failure^i
］
⇒
~THROW `TypeError^E
◎
If parsedURL is failure, throw a TypeError exception.
</li>
			<li>
此れの`~url$url ~SET %解析済~URL
◎
Set context object’s url to parsedURL.
</li>
			<li>
此れの`~query~obj$urlの`名値~組~list$を空にする
◎
Empty context object’s query object’s list.
</li>
			<li>
%~query ~LET 此れの`~url$urlの`~query$url
◎
Let query be context object’s url’s query.
</li>
			<li>
~IF［
%~query ~NEQ ~NULL
］
⇒
此れの`~query~obj$urlの`名値~組~list$ ~SET
%~query を`~FORMENC文字列~構文解析器$にかけた結果
◎
If query is non-null, then set context object’s query object’s list to the result of parsing query.
</li>
		</ol>
	</dd>

	<dt>`origin@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>

		<ol>
			<li>
~RET 此れの`~url$urlの`生成元$urlの`~Unicode直列化$
`HTML$r
</li>
		</ol>
◎
The origin attribute’s getter must return the Unicode serialization of context object’s url’s origin. [HTML]
</dd>
	<dd class="note">注記：
~HTMLの `MessageEvent^I 特色機能との互換性をとるため、これは~ASCIIに直列化されたものではなく，~Unicodeによるものを返す。
`HTML$r
◎
It returns the Unicode rather than the ASCII serialization for compatibility with HTML’s MessageEvent feature. [HTML]
</dd>

	<dt>`protocol@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>

		<ol>
			<li>
~RET
空~文字列
~APPEND 此れの`~url$urlの`~scheme$url
~APPEND ❝:
</li>
		</ol>
◎
The protocol attribute’s getter must return context object url’s scheme, followed by ":".
</dd>
	<dd>
設定子は、次を走らせ~MUST
⇒
［
`~URL$と上書stateの組：
( 此れの`~url$url, `~scheme開始-$st )
］を与える下で，［
所与の値 ~APPEND
❝: 
］を`基本~URL構文解析器$にかける
◎
The protocol attribute’s setter must basic URL parse the given value, followed by ":", with context object’s url as url and scheme start state as state override.
</dd>

	<dt>`username@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>

		<ol>
			<li>
~RET 此れの`~url$urlの`~username$url
</li>
		</ol>
◎
The username attribute’s getter must return context object’s url’s username.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The username attribute’s setter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~host$url ~EQ ~NULL
］~OR［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If context object’s url’s host is null, or its cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
所与の値を用いて， %url の`~usernameを設定する$
◎
Set the username given context object’s url and the given value.
</li>
		</ol>
	</dd>

	<dt>`password@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The password attribute’s getter must run these steps:
</p>

		<ol>
			<li>
%~password ~LET 此れの`~url$urlの`~password$url
◎
↓</li>
			<li>
~IF［
%~password ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If context object’s url’s password is null, return the empty string.
</li>
			<li>
~RET %~password
◎
Return context object’s url’s password.
</li>
		</ol>
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The password attribute’s setter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~host$url ~EQ ~NULL
］~OR［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If context object’s url’s host is null, or its cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
所与の値を用いて， %url の`~passwordを設定する$
◎
Set the password given context object’s url and the given value.
</li>
		</ol>
	</dd>

	<dt>`host@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The host attribute’s getter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
Let url be context object’s url.
</li>
			<li>
~IF［
%url の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If url’s host is null, return the empty string.
</li>
			<li>
%~host ~LET `~host$urlを`~host直列化器$にかけた結果
◎
↓</li>
			<li>
~IF［
%url の`~port$url ~EQ ~NULL
］
⇒
~RET %~host
◎
If url’s port is null, return url’s host, serialized.
</li>
			<li>
~RET %~host ~APPEND ❝:
~APPEND ［
`~port$urlを`直列化-$した結果
］
◎
Return url’s host, serialized, followed by ":" and url’s port, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The host attribute’s setter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If context object’s url’s cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
［
`~URL$と上書stateの組：
( %url , `~host$st )
］を与える下で，所与の値を`基本~URL構文解析器$にかける
◎
Basic URL parse the given value with context object’s url as url and host state as state override.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`host$m 属性の設定子に与える値が，`~port$synを欠いている場合、
%url の`~port$urlは変化しないことになる。
<!-- ＊This can be unexpected -->
`host^c 属性の取得子が`~port$synを返さないために、設定子が常に両者を “再設定する” と見做してしまいそうだが。
◎
If the given value for the host attribute’s setter lacks a port, context object’s url’s port will not change. This can be unexpected as host attribute’s getter does return a port so one might have assumed the setter to always "reset" both.
</dd>

	<dt>`hostname@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The hostname attribute’s getter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~host$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If context object’s url’s host is null, return the empty string.
</li>
			<li>
~RET %url の`~host$urlを`~host直列化器$にかけた結果
◎
Return context object’s url’s host, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The hostname attribute’s setter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If context object’s url’s cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
［
`~URL$と上書stateの組：
( %url , `~hostname$st )
］を与える下で，所与の値を`基本~URL構文解析器$にかける
◎
Basic URL parse the given value with context object’s url as url and hostname state as state override.
</li>
		</ol>
	</dd>

	<dt>`port@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The port attribute’s getter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~port$url ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If context object’s url’s port is null, return the empty string.
</li>
			<li>
~RET %url の`~port$urlを`直列化-$した結果
◎
Return context object’s url’s port, serialized.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The port attribute’s setter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~host$url ~EQ ~NULL
］~OR［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］~OR［
%url の`~scheme$url ~EQ `file^l
］
⇒
~RET
◎
If context object’s url’s host is null, its cannot-be-a-base-URL flag is set, or its scheme is "file", terminate these steps.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%url の`~port$url ~SET ~NULL
◎
If the given value is the empty string, then set url’s port to null.
</li>
			<li>
~ELSE
⇒
［
`~URL$と上書stateの組：
( %url , `~port$st )
］を与える下で，所与の値を`基本~URL構文解析器$にかける
◎
Otherwise, basic URL parse the given value with context object’s url as url and port state as state override.
</li>
		</ol>
	</dd>

	<dt>`pathname@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The pathname attribute’s getter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET［
%url の`~path$url内の最初の文字列
］
◎
If context object’s url’s cannot-be-a-base-URL flag is set, return the first string in context object’s url’s path.
</li>
			<li>
%結果 ~LET 空~文字列
◎
↓</li>
			<li>
~FOR
%url の`~path$url内の
~EACH ( 文字列 %s （空~文字列も含む） ) に対し
⇒
%結果 ~APPEND ❝/ ~APPEND %s
◎
↓</li>
			<li>
~RET %結果
◎
Return "/", followed by the strings in context object’s url’s path (including empty strings), separated from each other by "/".
			</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The pathname attribute’s setter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~cannot-be-a-base-URL~flag$ ~EQ ~ON
］
⇒
~RET
◎
If context object’s url’s cannot-be-a-base-URL flag is set, terminate these steps.
</li>
			<li>
%url の`~path$urlを空にする
◎
Empty context object’s url’s path.
</li>
			<li>
［
`~URL$と上書stateの組：
( %url , `~path開始-$st )
］を与える下で，所与の値を`基本~URL構文解析器$にかける
◎
Basic URL parse the given value with context object’s url as url and path start state as state override.
</li>
		</ol>
	</dd>

	<dt>`search@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The search attribute’s getter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~query$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If context object’s url’s query is either null or the empty string, return the empty string.
</li>
			<li>
~RET ［
❝? ~APPEND %url の`~query$url
］
◎
Return "?", followed by context object’s url’s query.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The search attribute’s setter must run these steps:
</p>

		<ol>
<li>
%url ~LET 此れの`~url$url
◎
Let url be context object’s url.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
%url の`~query$url ~SET ~NULL ~BR
此れの`~query~obj$urlの`名値~組~list$を空にする ~BR
~RET
◎
If the given value is the empty string, set url’s query to null, empty context object’s query object’s list, and terminate these steps.
</li>
			<li>
%入力 ~LET 所与の値 — ただし，先頭 1 個の ❝? は（もし在れば）除去する
◎
Let input be the given value with a single leading "?" removed, if any.
</li>
			<li>
%url の`~query$url ~SET 空~文字列
◎
Set url’s query to the empty string.
</li>
			<li>
［
`~URL$と上書stateの組：
( %url, `~query$st )
］を与える下で， %入力 を`基本~URL構文解析器$にかける
◎
Basic URL parse input with url as url and query state as state override.
</li>
			<li>
此れの`~query~obj$urlの`名値~組~list$ ~SET %入力 を`~FORMENC文字列~構文解析器$にかけた結果
◎
Set context object’s query object’s list to the result of parsing input.
</li>
		</ol>
	</dd>

	<dt>`searchParams@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>

		<ol>
			<li>
~RET 此れの`~query~obj$url
</li>
		</ol>
◎
The searchParams attribute’s getter must return context object’s query object.
</dd>

	<dt>`hash@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The hash attribute’s getter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`素片$url ~IN { ~NULL, 空~文字列 }
］
⇒
~RET 空~文字列
◎
If context object’s url’s fragment is either null or the empty string, return the empty string.
</li>
			<li>
~RET ［
❝# ~APPEND %url の`素片$url
］
◎
Return "#", followed by context object’s url’s fragment.
</li>
		</ol>
	</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
The hash attribute’s setter must run these steps:
</p>

		<ol>
			<li>
%url ~LET 此れの`~url$url
◎
↓</li>
			<li>
~IF［
%url の`~scheme$url ~EQ `javascript^l
］
⇒
~RET
◎
If context object’s url’s scheme is "javascript", terminate these steps.
</li>
			<li>
%入力 ~LET 所与の値
◎
↓</li>
			<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒
%url の`素片$url ~SET ~NULL ~BR
~RET
◎
If the given value is the empty string, set context object’s url’s fragment to null and terminate these steps.
</li>
			<li>
~IF［
%入力 の先頭の文字 ~EQ ❝#
］
⇒
%入力 から先頭の文字を除去する
◎
Let input be the given value with a single leading "#" removed, if any.
</li>
			<li>
%url の`素片$url ~SET 空~文字列
◎
Set context object’s url’s fragment to the empty string.
</li>
			<li>
［
`~URL$と上書stateの組：
( %url , `素片$st )
］を与える下で， %入力 を`基本~URL構文解析器$にかける
◎
Basic URL parse input with context object’s url as url and fragment state as state override.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="interface-urlsearchparams">
<h3 title="Interface URLSearchParams">6.3. ~ifc `URLSearchParams^I</h3>

<pre class="idl">[<a href="#dom-urlsearchparams-urlsearchparams">Constructor</a>(optional (USVString or `URLSearchParams$I) %init = ""),
`Exposed$=(Window,Worker)]
interface `URLSearchParams@I {
  void `append$m(USVString %name, USVString %value);
  void `delete$m(USVString %name);
  USVString? `get$m(USVString %name);
  sequence&lt;USVString&gt; `getAll$m(USVString %name);
  boolean `has$m(USVString %name);
  void `set$m(USVString %name, USVString %value);
  iterable&lt;USVString, USVString&gt;;
  `stringifier$m;
};</pre>


<p>
各 `URLSearchParams$I ~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`名値~組~list@</dt>
	<dd>
0 個以上の名値~組からなる~list（初期~時は空）
◎
A URLSearchParams object has an associated list of name-value pairs, which is initially empty.
</dd>
	<dt>`~url~obj@</dt>
	<dd>
（初期~時は ~NULL ）
◎
A URLSearchParams object has an associated url object, which is initially null.
</dd>
</dl>

<p class="algo-head">
所与の %init （省略時は ε ）から
`新たな~URLSearchParams~objを作成-@
するときは、次を走らす：
◎
To create a new URLSearchParams object, optionally using init, run these steps:
</p>


		<ol>
			<li>
%~query ~LET 新たな `URLSearchParams$I ~obj
◎
Let query be a new URLSearchParams object.
</li>
			<li>
~IF［
%init は文字列である
］
⇒
%~query の`名値~組~list$ ~SET %init を`~FORMENC文字列~構文解析器$にかけた結果
◎
If init is a string, set query’s list to the result of parsing init.
</li>
			<li>
~ELIF［
%init は `URLSearchParams$I ~objである
］
⇒
%~query の`名値~組~list$ ~SET %init の`名値~組~list$の複製
◎
If init is a URLSearchParams object, set query’s list to a copy of init’s list.
</li>
			<li>
~RET %~query
◎
Return query.
</li>
		</ol>
<div>
<p class="algo-head">
`URLSearchParams$I ~obj %O の
`更新~手続き@
は、次を走らす：
</p>

		<ol>
			<li>
%O の`~url~obj$の`~query$url ~SET
%O の`名値~組~list$を`~FORMENC直列化器$にかけた結果
</li>
		</ol>
◎
A URLSearchParams object’s update steps are to set url object’s url’s query to the serialization of URLSearchParams object’s list.
</div>


<dl class="idl-def">
	<dt>`URLSearchParams(init)@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
The URLSearchParams(init) constructor, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
%init は与えられていない
］
⇒
%init ~SET ε
</li>
			<li>
~ELIF［
%init の最初の~cp ~EQ ❝?
］
⇒
%init から最初の~cpを除去する
◎
If init is given, is a string, and starts with "?", remove the first code point from init.
</li>
			<li>
~RET %init から`新たな~URLSearchParams~objを作成-$した結果
◎
Return a new URLSearchParams object, using init if given.
</li>
		</ol>
	</dd>

	<dt>`append(name, value)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The append(name, value) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
此れの`名値~組~list$に，新たな組( %name, %value ) を付加する
◎
Append a new name-value pair whose name is name and value is value, to list.
</li>
			<li>
`更新~手続き$を走らす
◎
Run the update steps.
</li>
		</ol>
	</dd>

	<dt>`delete(name)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The delete(name) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
此れの`名値~組~list$から［
名 ~EQ %name
］なるすべての組を除去する
◎
Remove all name-value pairs whose name is name from list.
</li>
			<li>
`更新~手続き$を走らす
◎
Run the update steps.
</li>
		</ol>
	</dd>

	<dt>`get(name)@m</dt>
	<dd>
被呼出時には、次を返さ~MUST
⇒
此れの`名値~組~list$内に［
名 ~EQ %name
］なる組が［
在れば それらのうちの最初の組の値 ／
無ければ ~NULL
］
◎
The get(name) method, when invoked, must return the value of the first name-value pair whose name is name in list, if there is such a pair, and null otherwise.
</dd>

	<dt>`getAll(name)@m</dt>
	<dd>
被呼出時には、次を返さ~MUST
⇒
此れの`名値~組~list$内の［
名 ~EQ %name
］なる組すべてからなる，~list順による sequence（空にもなり得る）
◎
The getAll(name) method, when invoked, must return the values of all name-value pairs whose name is name, in list, in list order, and the empty sequence otherwise.
</dd>

	<dt>`set(name, value)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The set(name, value) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
此れの`名値~組~list$内に［
名 ~EQ %name
］なる組が在する
］
⇒
それらのうちの
⇒
最初の組の値 ~SET %value ~BR
最初でない組はすべて此れの`名値~組~list$から除去する
◎
If there are any name-value pairs whose name is name, in list, set the value of the first such name-value pair to value and remove the others.
</li>
			<li>
~ELSE
⇒
此れの`名値~組~list$に，新たな組 ( %name, %value ) を付加する
◎
Otherwise, append a new name-value pair whose name is name and value is value, to list.
</li>
			<li>
`更新~手続き$を走らす
◎
Run the update steps.
</li>
		</ol>
	</dd>

	<dt>`has(name)@m</dt>
	<dd>
被呼出時には、次を返さ~MUST
⇒
此れの`名値~組~list$内に［
名 ~EQ %name
］なる組が［
在れば ~T ／
無ければ ~F
］
◎
The has(name) method, when invoked, must return true if there is a name-value pair whose name is name in list, and false otherwise.
</dd>

</dl>


<p>
`URLSearchParams$I ~obj %O の`反復される値の組たち$は、%O の`名値~組~list$である
— その各
( 名, 値 )
が，順に 反復される値の
( key, value )
に対応する。
◎
The value pairs to iterate over are the list name-value pairs with the key being the name and the value being the value.
</p>

<p>
`URLSearchParams$I ~obj %O の文字列化の挙動（ `stringifier@m ）は、次を返さ~MUST
⇒
%O の`名値~組~list$を`~FORMENC直列化器$にかけた結果
◎
The stringification behavior must return the serialization of the URLSearchParams object’s list.
</p>

		</section>
		<section id="url-apis-elsewhere">
<h3 title="URL APIs elsewhere">6.4. 他の仕様における URL API</h3>

<p>
`~URL$を公開する標準は、`~URL$を（内部的な`~URL$は`~URL直列化器$urlにかけるなどして）文字列として公開するべきである。
標準は、`URL$I ~objを用いて`~URL$を公開するべきでない。
`URL$I ~objは、`~URL$を操作するためのものである。
IDL においては、 `USVString^I 型が利用されるべきである。
◎
A standard that exposes URLs, should expose the URL as a string (by serializing an internal URL). A standard should not expose a URL using a URL object. URL objects are meant for URL manipulation. In IDL the USVString type should be used.
</p>

<p class="note">注記：
より高次の観点からは、それらの値は，変異不可の~data構造として公開されるものになる。
◎
The higher-level notion here is that values are to be exposed as immutable data structures.
</p>

<p>
標準が，それが定義する特色機能に "URL" という名前の変種を用いるものとする場合、その種の特色機能には "url" （すなわち，小文字, 末尾は “エル” ）と命名するべきであり、 "URL", "URI", "IRI" などの名前は用いられるべきでない。
しかしながら，その名前が複合的なものである場合は、大文字の "URL" が好ましい
— "newURL" や "oldURL" など。
◎
If a standard decides to use a variant of the name "URL" for a feature it defines, it should name such a feature "url" (i.e., lowercase and with an "l" at the end). Names such as "URL", "URI", and "IRI" should not be used. However, if the name is a compound, "URL" (i.e., uppercase) is preferred, e.g., "newURL" and "oldURL".
</p>

<p class="note">注記：
適正な命名~例としては、~HTMLの `EventSource$I や HashChangeEvent$I ~ifcが挙げられる。
`HTML$r
◎
The EventSource and HashChangeEvent interfaces in HTML are examples of proper naming. [HTML]
</p>



		</section>
	</section>

</main></div><!-- id="MAIN" -->

	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
年月に渡り，たくさんの方々が
<a href="#concept-url">URL</a>
を相互運用可能にするために助力され、この標準の目標へ近付けてきた。
同様に多くの方々からの助力により，この標準は現在の姿に仕立て上げられてきた：
<span lang="en">
There have been a lot of people that have helped make URLs more interoperable over the years and thereby furthered the goals of this standard. Likewise many people have helped making this standard what it is today.
</span></p>

<div>
With that, many thanks to

100の人,
Adam Barth,
Addison Phillips,
Albert Wiersch,
Alex Christensen,
Alexandre Morgaut,
Andrew Sullivan,
Arkadiusz Michalski,
Behnam Esfahbod,
Bobby Holley,
Boris Zbarsky,
Brad Hill,
Brandon Ross,
Chris Dumez,
Chris Rebert,
Dan Appelquist,
Daniel Bratell,
David Burns,
David Håsäther,
David Sheets,
David Singer,
David Walp,
Domenic Denicola,
Erik Arvidsson,
Gavin Carothers,
Geoff Richards,
Glenn Maynard,
Henri Sivonen,
Ian Hickson,
Jakub Gieryluk,
James Graham,
James Manger,
James Ross,
Joshua Bell,
Jxck,
Kevin Grandon,
Larry Masinter,
Leif Halvard Silli,
Mark Davis,
Marcos Cáceres,
Martin Dürst,
Mathias Bynens,
Michael Peick,
Michael™ Smith,
Michel Suignard,
Peter Occil,
Philip Jägenstedt,
Prayag Verma,
Rodney Rehm,
Roy Fielding,
Ryan Sleevi,
Santiago M. Mola,
Sam Ruby,
Sebastian Mayr,
Simon Pieters,
Simon Sapin,
Stuart Cook,
Sven Uhlig,
吉野剛史 (Takeshi Yoshino),
Tab Atkins,
Tantek Çelik,
Tim Berners-Lee,
Titi_Alone,
Tomek Wytrębowicz,
Valentin Gosu,
Vyacheslav Matva,
Wei Wang,
山岸和利 (Yamagishi Kazutoshi), and
成瀬ゆい (Yui Naruse)

for being awesome!
</div>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>

<p>
Per <a href="//creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>, to the extent possible under law, the editors have waived all copyright and related or neighboring rights to this work.
</p>

<!-- 
This standard is written by Anne van Kesteren (Mozilla, annevk@annevk.nl).

Per CC0, to the extent possible under law, the editors have waived all copyright and related or neighboring rights to this work. 
-->

	</section>
	<section id="conformance">
<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>
	</section>


	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>


<dl>

	<dt>[BIDI]</dt>
	<dd>Mark Davis; Aharon Lanin; Andrew Glass. Unicode Bidirectional Algorithm. 5 June 2014. Unicode Standard Annex #9.</dd>
	<dd>http://www.unicode.org/reports/tr9/</dd>

	<dt>[DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>

	<dt>[ENCODING]</dt>
	<dd>Anne van Kesteren. Encoding Standard. Living Standard.</dd>
	<dd>https://encoding.spec.whatwg.org/</dd>

	<dt>[FILEAPI]</dt>
	<dd>Arun Ranganathan; Jonas Sicking. File API.</dd>
	<dd>https://w3c.github.io/FileAPI/</dd>

	<dt>[HTML]</dt>
	<dd>Ian Hickson. HTML Standard. Living Standard.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

	<dt>[IANA-URI-SCHEMES]</dt>
	<dd>Uniform Resource Identifier (URI) Schemes.</dd>
	<dd>http://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml</dd>

	<dt>[IDNA]</dt>
	<dd>Mark Davis; Michel Suignard. Unicode IDNA Compatibility Processing.</dd>
	<dd>http://www.unicode.org/reports/tr46/</dd>

	<dt>[MEDIA-SOURCE]</dt>
	<dd>Matthew Wolenetz; et al. Media Source Extensions™.</dd>
	<dd>https://w3c.github.io/media-source/</dd>

	<dt>[MEDIACAPTURE-STREAMS]</dt>
	<dd>Daniel Burnett; et al. Media Capture and Streams.</dd>
	<dd>https://w3c.github.io/mediacapture-main/</dd>

	<dt>[RFC2119]</dt>
	<dd>S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc2119</dd>

	<dt>[RFC4291]</dt>
	<dd>R. Hinden; S. Deering. IP Version 6 Addressing Architecture. February 2006. Draft Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc4291</dd>

	<dt>[UTS36]</dt>
	<dd>Mark Davis; Michel Suignard. Unicode Security Considerations.</dd>
	<dd>http://unicode.org/reports/tr36/</dd>

	<dt>[WEBIDL]</dt>
	<dd>Cameron McCormack; Boris Zbarsky; Tobie Langel. WebIDL.</dd>
	<dd>https://heycam.github.io/webidl/</dd>

</dl>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<dl>

	<dt>[FETCH]</dt>
	<dd>Anne van Kesteren. Fetch Standard. Living Standard.</dd>
	<dd>https://fetch.spec.whatwg.org/</dd>

	<dt>[REFERRER-POLICY]</dt>
	<dd>Jochen Eisinger; Mike West. Referrer Policy.</dd>
	<dd>https://w3c.github.io/webappsec-referrer-policy/</dd>

	<dt>[RFC1034]</dt>
	<dd>P.V. Mockapetris. Domain names - concepts and facilities. November 1987. Internet Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc1034</dd>

	<dt>[RFC3986]</dt>
	<dd>T. Berners-Lee; R. Fielding; L. Masinter. Uniform Resource Identifier (URI): Generic Syntax. January 2005. Internet Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc3986</dd>

	<dt>[RFC3987]</dt>
	<dd>M. Duerst; M. Suignard. Internationalized Resource Identifiers (IRIs). January 2005. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc3987</dd>

	<dt>[RFC5952]</dt>
	<dd>S. Kawamura; M. Kawashima. A Recommendation for IPv6 Address Text Representation. August 2010. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc5952</dd>
	<dd class="trans-ja-refs">参考：
<a href="http://www.nic.ad.jp/ja/newsletter/No46/0800.html" >IPv6アドレス表記の柔軟性が起こす問題と RFC5952 の解説</a>
</dd>

	<dt>[RFC6454]</dt>
	<dd>A. Barth. The Web Origin Concept. December 2011. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc6454</dd>

	<dt>[RFC7595]</dt>
	<dd>D. Thaler, Ed.; T. Hansen; T. Hardie. Guidelines and Registration Procedures for URI Schemes. June 2015. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc7595</dd>

	<dt>[RFC791]</dt>
	<dd>J. Postel. Internet Protocol. September 1981. Internet Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc791</dd>

</dl>



		</section>
	</section>

	<section id="index">
<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>
	</section>

	<section id="idl-index">
<h2 title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>

	</section>

</body>
