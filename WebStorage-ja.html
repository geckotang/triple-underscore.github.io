<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Web Storage（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

COMMON_DATA.page_state_key = '___HTML';

var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/webstorage.html',
		main: 'MAIN',
	};


	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'webstorage',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170608 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		E: 'error',
		et: 'event-type',
		h: 'header',
		bug: 'spec-bug',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		c: 'code',
		s: 'samp',
		e: 'code',
		a: 'code',
		et: 'code',
		h: 'code',
		v: 'var',
		i: 'i',
		bug: 'div',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|%[\w~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
//	switch(match){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		if(match[1]){
			in_idl = true;
			nesting += '</pre>';
			return '<pre class="idl">';
		} else {
			nesting += '</span>';
			return '：<span class="block">';
		}
	case '⇒！':
	}//◎
	if(in_idl) {
		result = nesting;
		in_idl = false;
	} else {
		result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	}
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	if(indicator === '@'){
		idl_ifc = key;
	}
	href = '#' + key.toLowerCase();
	if(in_idl) tag = '';
	break;
case 'm': // IDL member
	ifc = idl_ifc;
	break;
case 'i': // model constants
	break;
case 'v': // variables
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(ifc){
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	if(in_idl) tag = '';
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		if(ifc){
			href =
				(key.slice(0, 2) === 'on' ? '#handler-' : '#dom-') +
				(
					(key === ifc) ? ifc : (ifc + '-' + key)
				).toLowerCase();
		} else {
			console.log(match); // check error
			return match;
		}
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
references:
item-list:
item:
key:
value:
</script>

<!--% リンク置換データ


P:#localStorageEvent
P:#localStorageMutex
P:#sessionStorageEvent
-->
<script type="text/plain" id="_link_map">
~item~list:#item-list
~item:#item
~key:#key
~value:#value

I.Window:~WINDOW#window
I.Document:~HTMLdom#document
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
	I.Node:~DOM4#node
I.Storage:#storage-2
I.StorageEvent:#storageevent
I.StorageEventInit:#storageeventinit
I.WindowSessionStorage:#windowsessionstorage
I.WindowLocalStorage:#windowlocalstorage

E.QuotaExceededError:~WEBIDL#quotaexceedederror
E.SecurityError:~WEBIDL#securityerror

m.localStorage:#dom-localstorage
m.sessionStorage:#dom-sessionstorage
	Storage
m.length:#dom-storage-length
	m.key():#dom-storage-key — #dom-storageevent-key と衝突
m.getItem:#dom-storage-getitem
m.setItem:#dom-storage-setitem
m.removeItem:#dom-storage-removeitem
m.clear:#dom-storage-clear

	StorageEvent
	m.key:#dom-storageevent-key
	m.oldValue:#dom-storageevent-oldvalue
	m.newValue:#dom-storageevent-newvalue
	m.url:#dom-storageevent-url
	m.storageArea:#dom-storageevent-storagearea

et.storage:~HTMLindex#event-storage

文書:~HTMLdom#the-document-object
~window:~WINDOW#the-window-object

~storage通知を送信する:#send-a-storage-notification

~DOM操作~task源:~WAPI#dom-manipulation-task-source
~event~loop:~WAPI#event-loop
待入し:~WAPI#queue-a-task
~script:~WAPI#concept-script
~task源:~WAPI#task-source

	＊新たな~session~storageの開始:~BROWSERS#a-new-start-for-session-storage
閲覧文脈:~BROWSERS#browsing-context
全部的に作動中:~BROWSERS#fully-active
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
作動中の文書:~BROWSERS#active-document

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque

e.iframe:~HEembed#the-iframe-element
被~support~property名たち:~WEBIDL#dfn-supported-property-names
~eventを発火-:~DOM4#concept-event-fire
文書の~URL:~DOM4#concept-document-url
</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">

</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">

	●storage
item:
key:
value:
URL:
storage::::ストレージ
session::::セッション
local::::ローカル
session::::セッション
quata::::クォータ
clone::::クローン
access::::アクセス
data::::データ
transaction::::トランザクション
disk::::ディスク
区画:area::~::エリア
共有-:share::~::シェア
容量:space::~::スペース
持続的:persistent:~
持続-:persist:~
格納-:store::~::ストア
格納済み:stored::~::ストア済み
	格納~data:stored data:~
破棄-:discard:~
追加-:add:~
追加:adding:~
除去-:remove:~
除去:removing:~
削除-:delete:~

下層の:underlying:~
存続期間:lifetime:~
不可分:atomic::~
複製:copy:~
制限-:limit:~
状態:state:~
lock::::ロック
相互作用:interaction:~
破壊的な:disastrous:~
	複数~pageを同時に処理する:multiprocess


	●
DOM:
閲覧文脈:browsing context::~
top-level::::トップレベル
入子に:nest:入れ子に
作動中の:active::~::アクティブ
作動中:active::~::アクティブ
全部的:full:~
文書:document::~
window:
	:::ウィンドウ
破壊-:destroy:~
復帰:resuming:~
再起動:restart:~

	●network
site::::サイト
page::::ページ
内容:content:~
cookie::::クッキー
client::::クライアント
address::::アドレス
domain::::ドメイン
host::::ホスト
生成元:origin::~::オリジン
不透明な:opaque::~
path::::パス
pathname::::パス名
伝送-:transmit:~
読込んだ:load した:読み込んだ
待機-:wait:~

	●event
event::::イベント
発火-:fire:~
配送-:dispatch::~::ディスパッチ
task::::タスク
源:source::~::ソース
送信-:send:~
loop::::ループ
待入し:queue し::待ち行列に入れ::キューし
通知:notification::~
検出-:detect:~
変更-:change:~
変更:changes:~
変化-:change:~
操作:manipulation:~

	●idl
interface::::インタフェース
method::::メソッド
obj:object:::オブジェクト
在する:present する:在る
list::::リスト
属性:attribute:~
例外:exception:~
投出:throw:~
作成-:create:~
作成:creation:~
被呼出時:被 invoke 時:~
取得子:getter:~
呼出され:invoke され:呼び出され
呼出:invocation:呼び出し
初期化-:initialize:~
初期化:initialization:~
	初期化-時
新たな:new:~
値:value:~
property::::プロパティ
表現-:represent:~

	●
識別子:identifier:~
文字列:string:~
空:empty:~

script::::スクリプト
scripting::::スクリプティング

一意な:unique:~
物理的:physical:~
処理能:performance:~
移動-:move:~
名前:name:~
名:name:~
自前の:own:~
現在の:current:~
妥当:valid:~

	●仕様
UA:user agent:UA
web-app:Web application::ウェブアプリ
algo:algorithm:::アルゴリズム
support::::サポート
仕様:spec:~
作者:author:~
特色機能:feature:~:::フィーチャ
仕組み:mechanism:~:::メカニズム
model::::モデル
利用者:user:~:::ユーザ
実装-:implement:~
実装:implementation:~
導入-:intorduce:~
取組む:address する:取り組む
要求-:require:~
整合性:consistency:~
要請:request:~

	ウェブ:web
事例:case:~
手続き:steps:~
設計-:design:~
feedback::::フィードバック
将来的:future:~
更新:update:~
特定の:specific:~
見なさ:consider さ:~
見做す:assume する:~
奨励-:encourage:~
効果:effect:~
督促-:urge:~
示唆:suggestion:~
示唆-:suggest:~

提供-:provide:~
既存の:existing:~
結付けら:associate さ:結び付けら
特有の:-specific な:~
影響-:affect:~
理由:reason:~
違反-:violate:~
関係-:relate:~

	●例
code::::コード
link::::リンク
main::::メイン
checkbox::::チェックボックス
check::::チェック
表示-:display:~
mailbox::::メールボックス

	航空機の:plane:~
	搭乗券:ticket:~
	便:flight:~
	保険:insurance:~

	●保安
UI:
cross-directory::::クロスディレクトリ
privacy::::プライバシー
sensitive::::センシティブ
risk::::リスク
保安:security::~:セキュリティ
profile::::プロファイル
施策決定:policy decisions::~::ポリシー決定

	即座に:promptly:~
証明書:certificate::~
敵対的:hostile:~
失効-:expire:~
失効:expiration:~
第三者主体:third-party::~::サードパーティ
主体:entity::~::エンティティ
追跡-:track::~::トラック
追跡:tracking::~::トラッキング
軽減-:mitigate:~
攻撃:attack::~
偽装:spoofing::~
spoofing:::なりすまし
不能化-:disable:~
超過-:exceed:~
	可能化-:enable:~
情報:information:~
漏洩:leakage:~
阻止-:block::~::ブロック
阻止list:blocklist::阻止 list:阻止リスト:ブロックリスト
安全list:safelisting::安全 listing:安全リスト

community::::コミュニティ
環境設定:configuration:~
環境設定-:configure:~
訪問者:visitor:~
防止-:prevent:~
関心:interests:~
流布-:distribute:~
広告主:advertiser:~
広告:advertising:~
	~~高度な:highly
	絞り込み:targeted
電子商取引:e-commerce:~
認証情報:authenticated credentials::~
認証-:authenticate::~
不当な:oppressive:~
団体:group:~
匿名:anonymous:~
	精度:greater accuracy
	個人:individuals:~
標的に:target:~
許容-:allow:~
本当の:real:~
身元:identity:~
制約-:restrict:~
制約:restriction:~
抑制-:reduce:~
有用性:usefulness:~
理解-:understand:~
	迂回:defeat
	打破
	迂回:circumventing
記録-:record:~
転用-:repurpose:~
技法:technique:~
既知の:known:~
被害者:victim:~
厳格:strict:~
危険:dangerous:~
自明:trivial:~
作業中の:work-in-progress:~
文書作成:word-processing:~
秘匿文書:confidential documents:~
競合企業:competing company:~
wishlist::::購入希望リスト
予測可能性:predictability:~
枯渇-:exhaust:~
保護:protection:~
	protect
防護-:guard
	限界:limit
恣意的:arbitrary:~
無圧縮時の:uncompressed:~
読取り:read:読み取り
読取って:read して:読み取って
読取った:read した:読み取った
書込まれ:write され:書き込まれ
書込み:write:書き込み
書戻す:write back する:書き戻す

上書き:overwrite:~
避ける:avoid する:~
size::::サイズ
自動的:automatic:~
	もたらす~~影響:implications
閉じた:close した:~
冗長backup:redundant backup:冗長 backup::冗長バックアップ
	許可:authorize/denying/white-
	~~判断材料になる:make informed decisions
信用-:trust:~
	~~協同:act together
個人識別情報:identifying information:~
	（名前, カード番号, 住所など） (names, credit card numbers, addresses
協同-:cooperate:~
協同:cooperation:~
	過去に遡ってretroactively
潜在的:potential:~
	秘匿文書:~
	確証sure
保証-:guarantee:~
主張-:claim:~
software:::ソフトウェア
	代理するon behalf of
	害の無いinnocuous
header::::ヘッダ
service::::サービス
log-in::::ログイン
	購入予約:making a purchase
重要:important:~
提携:affiliated:~
想定:suppose:~
組合せて:combine して:組み合せて
一貫した:coherent な:~
	:仕立て上げる
消去-:clear:~

	●未分類
~~変更increment
単独の:single:~
browser::::ブラウザ
megabyte::::メガバイト
出自に:originate:~
設定-:set:~
追う:follow する:~
	購入 buy
	促して prompt
	~~閲覧:click
	築き上げ:build
走らせ:run し:~
</script>

<!--%style -->
<style type="text/css">



</style>

<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>


<aside class="trans-meta">
<h1>HTML Standard — Web Storage 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における
HTML 仕様の
<a id="_SPEC_URL">Web Storage 章</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p >
更新：<time>2017-06-24</time>
（公開：<time>2013-04-20</time> （ W3C 版））
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

	<hgroup>
<h1>Web Storage</h1>
<h2>HTML Living Standard — 最終更新 2017 年 6 月 8 日</h2>
	</hgroup>

<main id="MAIN" style="display:none;">

<section id="webstorage">
<h1>11. Web Storage</h1>

	<section id="introduction-15">

<h2 title="Introduction">11.1. 序論</h2>

~INFORMATIVE

<p>
この仕様は、 HTTP ~session~cookie `COOKIES$r と類似する，~client側に
( 名前, 値 )
の組たちを格納するための，関係する２つの仕組みを導入する。
◎
This specification introduces two related mechanisms, similar to HTTP session cookies, for storing name-value pairs on the client side. [COOKIES]
</p>

<p>
最初の仕組みは、利用者が単独の~transactionで~dataをやりとりする局面を~~想定して設計されているが、異なる~window間で並行する複数の~transactionにも運び得る。
◎
The first is designed for scenarios where the user is carrying out a single transaction, but could be carrying out multiple transactions in different windows at the same time.
</p>

<p>
~cookieは、この事例を上手く取り扱えない。
例えば、利用者は，同じ~siteの２つの異なる~windowで航空機の搭乗券の購入を検討するかもしれない。
~siteが，購入中の搭乗券の情報を~cookieに保ち続けている場合、利用者が両方の~windowで~pageから~pageへ~~閲覧を続けたときに，それらの搭乗券の情報が一方の~windowから他方へ “漏れ出す” 結果、同じ便の搭乗券を気付かないうちに重複して購入する羽目に陥り得る。
◎
Cookies don't really handle this case well. For example, a user could be buying plane tickets in two different windows, using the same site. If the site used cookies to keep track of which ticket the user was buying, then as the user clicked from page to page in both windows, the ticket currently being purchased would "leak" from one window to the other, potentially causing the user to buy two tickets for the same flight without really noticing.
</p>

<p>
これに取組むため、この仕様は
`sessionStorage$m
IDL 属性を導入する。
~siteは~session~storageに~dataを追加でき，同じ~siteで開かれているどの~pageからも~access可能になる。
◎
To address this, this specification introduces the sessionStorage IDL attribute. Sites can add data to the session storage, and it will be accessible to any page from the same site opened in that window.
</p> 

<div class="example">

<p>
例えば、~pageは，利用者が保険を希望する旨を指示する~checkboxを持ち得る：
◎
For example, a page could have a checkbox that the user ticks to indicate that they want insurance:
</p>

<pre>
&lt;label&gt;
 &lt;input
   type="checkbox"
   onchange="sessionStorage.insurance = checked ? 'true' : ''"
 &gt;
 <span class="comment">
この旅行に保険を掛ける
◎
I want insurance on this trip.
</span>
&lt;/label&gt;
</pre>

<p>
その~pageは後の時点で、利用者がその~checkboxに~checkを入れているかどうかを，~scriptを使って調べられる：
◎
A later page could then check, from script, whether the user had checked the checkbox or not:
</p>

<pre>
if (sessionStorage.insurance) { ... }
</pre>

<p>
利用者がその~siteの複数の~windowを開いたとき、それぞれの~windowは，自前の~session~storage~objの複製を持つ。
◎
If the user had multiple windows opened on the site, each one would have its own individual copy of the session storage object.
</p>

</div>


<p>
~storageの二番目の仕組みは、複数~windowに渡り，複数の~sessionに渡って残り続ける~storageのために設計されている。
特に、 ~web-appは、処理能の理由から，例えば 利用者により作成された文書~全体や利用者の~mailboxなど，~megabyte~~単位の利用者~dataには ~client側での保存を要し得る。
◎
The second storage mechanism is designed for storage that spans multiple windows, and lasts beyond the current session. In particular, Web applications may wish to store megabytes of user data, such as entire user-authored documents or a user's mailbox, on the client side for performance reasons.
</p>

<p>
この場合も、~cookieは要請の度に伝送されるので，このような用途には適さない。
◎
Again, cookies do not handle this case well, because they are transmitted with every request.
</p>

<p>
`localStorage$m
IDL 属性は、~pageの~local~storage区画への~accessに利用される。
◎
The localStorage IDL attribute is used to access a page's local storage area.
</p>

<div class="example">

<p>
`example.com^s の~siteは、~pageの末尾に次のような~codeを置くことにより，利用者が~pageを読込んだ回数を表示させられる：
◎
The site at example.com can display a count of how many times the user has loaded its page by putting the following at the bottom of its page:
</p>

<pre>
&lt;p&gt;
  あなたがこのページを見たのは
  &lt;span id="count"&gt;〜&lt;/span&gt;回目です。
&lt;/p&gt;
&lt;script&gt;
  if (!localStorage.pageLoadCount)
    localStorage.pageLoadCount = 0;
  localStorage.pageLoadCount
      = parseInt(localStorage.pageLoadCount) + 1;
  document.getElementById('count').textContent
      = localStorage.pageLoadCount;
&lt;/script&gt;
</pre>

</div>

<p>
各~siteには，それぞれに自前の~storage区画があてがわれる。
◎
Each site has its own separate storage area.
</p>

	</section>

	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>

	<section id="storage">

<h2 title="The API">11.2. API</h2>

		<section id="the-storage-interface">

<h3 title="The Storage interface">11.2.1. `Storage^I ~interface</h3>

⇒！
interface `Storage@I {
  readonly attribute unsigned long `length$m;
  DOMString? <a href="#dom-storage-key">key</a>(unsigned long %index);
  getter DOMString? `getItem$m(DOMString %key);
  setter void `setItem$m(DOMString %key, DOMString %value);
  deleter void `removeItem$m(DOMString %key);
  void `clear$m();
};
◎

<!-- REC diff
DOMString? getItem → DOMString getItem
 -->

<p>
各 `Storage$I ~objは、いくつかの［
`~item@ とも呼ばれる，［
`~key@
とそれに対応する
`~value@
］の組
］からなる~listへの~accessを提供する。
`~key$は文字列であり、（空~文字列も含め）どのような文字列も，`~key$として妥当である。
`~value$も同様に文字列である。
◎
Each Storage object provides access to a list of key/value pairs, which are sometimes called items. Keys are strings. Any string (including the empty string) is a valid key. Values are similarly strings.
</p>



<p>
各 `Storage$I ~objには、その作成-時に，`~item$の~list
— 以下、
`~item~list@
と記す —
が結付けられる（詳細は
`sessionStorage$m 属性, `localStorage$m 属性
各~節にて規定される）。
`Storage$I ~interfaceを実装する複数の別個の~objすべてに、同時に，同じ`~item~list$が結付けられ得る。
◎
Each Storage object is associated with a list of key/value pairs when it is created, as defined in the sections on the sessionStorage and localStorage attributes. Multiple separate objects implementing the Storage interface can all be associated with the same list of key/value pairs simultaneously.
</p>


<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
取得子は、その時点で`~item~list$内に在する`~item$数を返さ~MUST。
◎
The length attribute must return the number of key/value pairs currently present in the list associated with the object.
</dd>

	<dt>`key(n)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
</p>

		<ol>
			<li>
~IF［
%n ~GTE ~list内の`~item$の総数
］
⇒
~RET ~NULL
</li>
			<li>
~RET `~item~list$の %n 番の~itemの`~key$
` 0 番が最初の~item^tnote
</li>
		</ol>

<p>
`この目的における^tnote
`~item$の順序は，~UAにより定義されるが、`~item$の総数が変化しない限り，返される結果は~objにおいて一定で~MUST（したがって，`~item$の順序は、
<a href="#dom-storage-setitem">追加</a>
や
<a href="#dom-storage-removeitem">除去</a>
により変化し得るが、既存の`~item$に対する`~value$の変更により変化しては~MUST_NOT）。
</p>

◎
The key(n) method must return the name of the nth key in the list. The order of keys is user-agent defined, but must be consistent within an object so long as the number of keys doesn't change. (Thus, adding or removing a key may change the order of the keys, but merely changing the value of an existing key must not.) If n is greater than or equal to the number of key/value pairs in the object, then this method must return null.
</dd>
</dl>


<div>
<p>
`Storage$I ~objの`被~support~property名たち$は、次で与えられる`有順序^tnote 集合として定義される：
</p>
		<ul>
			<li>
~accessされた時点で，その`~item~list$内に在する`~item$すべての`~key$からなる。
</li>
			<li>
順序は、当の~storage区画に`~key$が追加された順による。
</li>
		</ul>
◎
The supported property names on a Storage object are the keys of each key/value pair currently present in the list associated with the object, in the order that the keys were last added to the storage area.
</div>


<dl class="idl-def">

	<dt>`getItem(key)@m</dt>
	<dd>
被呼出時には、`~item~list$内に［
`~key$ ~EQ %key
］なる`~item$が［
存在するならば その`~item$の現在の`~value$ ／
存在しないならば ~NULL
］を返さ~MUST。
◎
The getItem(key) method must return the current value associated with the given key. If the given key does not exist in the list associated with the object then this method must return null.
</dd>

	<dt>`setItem(key, value)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setItem(key, value) method must first check if a key/value pair with the given key already exists in the list associated with the object.
</p>

		<ol>
			<li>
%item ~LET
`~item~list$内の［
`~key$ ~EQ %key
］なる`~item$
◎
↓</li>
			<li>
~IF［
%item は存在しない
］
⇒
次のようにされた新たな`~item$を`~item~list$に追加する
⇒
( `~key$, `~value$ ) ~SET ( %key, %value )
◎
If it does not, then a new key/value pair must be added to the list, with the given key and with its value set to value.
</li>
			<li>
~ELIF［
%item の`~value$ ~NEQ %value
］
⇒
%item の`~value$ ~SET %value
◎
If the given key does exist in the list, and its value is not equal to value, then it must have its value updated to value. If its previous value is equal to value, then the method must do nothing.
</li>
			<li>
~ELSE
⇒
何もしては~MUST_NOT
`下の注記を見よ^tnote
◎
↑</li>
		</ol>
	</dd>

	<dd>
新たな`~value$を設定できなかった場合、この~methodは `QuotaExceededError$E 例外を投出し~MUST（そのような状況は、例えば，利用者が~siteに対する~storageを不能化した場合や, ~quata~~上限を超過した場合に起こり得る）。
◎
If it couldn't set the new value, the method must throw a "QuotaExceededError" DOMException exception. (Setting could fail if, e.g., the user has disabled storage for the site, or if the quota has been exceeded.)
</dd>

	<dt>`removeItem(key)@m</dt>
	<dd>
被呼出時には
⇒
`~item~list$内に［
`~key$ ~EQ %key
］なる`~item$が存在するならば，それを`~item~list$から除去し~MUST
— 存在しない場合、何もしては~MUST_NOT
`下の注記を見よ^tnote
。
◎
The removeItem(key) method must cause the key/value pair with the given key to be removed from the list associated with the object, if it exists. If no item with that key exists, the method must do nothing.
◎
↓↓The setItem() and removeItem() methods must be atomic with respect to failure. In the case of failure, the method does nothing. That is, changes to the data storage area must either be successful, or the data storage area must not be changed at all.
</dd>

	<dt>`clear()@m</dt>
	<dd>
被呼出時には、`~item~list$が空でないならば，それを空にし~MUST
— 元々空であった場合、何もしては~MUST_NOT
`下の注記を見よ^tnote
。
◎
The clear() method must atomically cause the list associated with the object to be emptied of all key/value pairs, if there are any. If there are none, then the method must do nothing.
</dd>

</dl>

<p>
［
`setItem()$m ／ `removeItem()$m ／ `clear()$m
］~methodは
⇒
その履行の失敗に関して不可分な~~操作で~MUST。
失敗する場合、これらの~methodは何もしない。
すなわち、~data~storage区画に対する変更は成功裡に完了するか, または
~data~storage区画は全く変更されないかの，いずれかで~MUST。
◎
↑↑</p>


<p class="note">注記：
［
`setItem()$m ／
`removeItem()$m ／
`clear()$m
］~methodが呼出されたときは、
`~storage区画に変更が加えられた場合に限り^tnote
新たに格納-／除去された~dataに~access可能な他の`文書$の`~window$に向けて，~eventが発火される（詳細は［
`sessionStorage$m ／ `localStorage$m
］属性の節にて規定される）。
◎
When the setItem(), removeItem(), and clear() methods are invoked, events are fired on the Window objects of other Documents that can access the newly stored or removed data, as defined in the sections on the sessionStorage and localStorage attributes.
</p>

<p class="note">注記：
この仕様は、上述の~methodが，~dataが物理的に~diskに書込まれるまで待機することを要求しない。
同じ下層の`~item~list$へ~accessする 異なる~script間で、整合性が保たれることのみが要求される。
◎
This specification does not require that the above methods wait until the data has been physically written to disk. Only consistency in what different scripts accessing the same underlying list of key/value pairs see is required.
</p>

		</section>
		<section id="the-sessionstorage-attribute">

<h3 title="The sessionStorage attribute">11.2.2. `sessionStorage^m 属性</h3>

⇒！
[NoInterfaceObject]
interface `WindowSessionStorage@I {
  readonly attribute `Storage$I `sessionStorage$m;
};
`Window$I implements `WindowSessionStorage$I;
◎


<p>
`sessionStorage@m
属性は、現在の`~top-level閲覧文脈$特有の，~storage区画の集合を表現する。
◎
The sessionStorage attribute represents the set of storage areas specific to the current top-level browsing context.
</p>

<p>
それぞれの`~top-level閲覧文脈$は、各`生成元$ごとに，別々の~session~storage区画をあてがう。
◎
Each top-level browsing context has a unique set of session storage areas, one for each origin.
</p>

<div>
<p>
~UAは、閲覧文脈の~session~storage区画の~dataが失効しないようにするべきであるが、次のいずれかの場合は失効させてもよい：
</p>

<ul ><li>利用者からその種の~dataを削除するよう要請されたとき。
</li><li>~UAが~storage容量の限界を検出したとき。
</li><li>保安~上の理由があるとき。
</li></ul>

<p>
~UAは、また~session~storage区画に格納されている~dataに対し：
</p>

<ul ><li>~dataに~accessし得る~scriptを走らせている間は，失効させないべきである。
</li><li>`~top-level閲覧文脈$が破壊されたときは（したがって，それ以上~利用者から~accessされない），破棄できる
— この仕様に述べる API は，当の~dataに対する後続の取得手段を提供しないので。
</li></ul>

◎
User agents should not expire data from a browsing context's session storage areas, but may do so when the user requests that such data be deleted, or when the UA detects that it has limited storage space, or for security reasons. User agents should always avoid deleting data while a script that could access that data is running. When a top-level browsing context is destroyed (and therefore permanently inaccessible to the user) the data stored in its session storage areas can be discarded with it, as the API described in this specification provides no way for that data to ever be subsequently retrieved.
</div>

<p class="note">注記：
~UAは，再起動~後の~sessionの復帰を~supportできるので、閲覧文脈の存続期間と, ~UAによる実際の その処理の存続期間とは，必ずしも一致しない。
◎
The lifetime of a browsing context can be unrelated to the lifetime of the actual user agent process itself, as the user agent can support resuming sessions after a restart.
</p>

<div class="p">
<p>
~UAは、新たな`文書$ %文書 を作成したときは、 %文書 が属する`閲覧文脈$の
`~top-level閲覧文脈$ %T があるならば，次で与えられる~session~storage区画を %文書 にあてがわ~MUST：
</p>

<ul ><li>%T が［
%文書 の`生成元$ %O
］に対する~session~storage区画をすでに有しているならば、それ。
</li><li>他の場合、 %O に対する新たな~storage区画を作成した結果。
</li></ul>

<p>
%文書 が存続する限り、 %文書 に他の~storage区画があてがわれることはない。
</p>

◎
When a new Document is created in a browsing context which has a top-level browsing context, the user agent must check to see if that top-level browsing context has a session storage area for that document's origin. If it does, then that is the Document's assigned session storage area. If it does not, a new storage area for that document's origin must be created, and then that is the Document's assigned session storage area. A Document's assigned storage area does not change during the lifetime of a Document.
</div>

<p class="note">注記：
`iframe$e が他の`文書$下に移動された場合、
`iframe$e を通して入子にされている閲覧文脈は破壊され，新たなものが作成される。
◎
In the case of an iframe being moved to another Document, the nested browsing context is destroyed and a new one created.
</p>

<p>
`sessionStorage$m 属性の取得子は、［
`文書$にあてがわれている ~session~storage区画
］に属する `Storage$I ~objがあれば それ ／
無ければ ~NULL
］を返さ~MUST。
各 `文書$は、それぞれが別個の，その`~window$の `sessionStorage$m 属性に対応する~objを持た~MUST。
◎
The sessionStorage attribute must return a Storage object associated with the Document's assigned session storage area, if any, or null if there isn't one. Each Document object must have a separate object for its Window's sessionStorage attribute.
</p>

<p>
新たな`~top-level閲覧文脈$ %T が作成されたときは：
</p>

<ul>
	<li>
%T は，既存の`閲覧文脈$を~cloneして作成されたならば
⇒
%T の~session~storage区画は，元のそれと同じものから開始され~MUSTが、その時点から，この２つは互いに影響しないように，別個のものと見なされ~MUST。
◎
When a new top-level browsing context is created by cloning an existing browsing context, the new browsing context must start with the same session storage areas as the original, but the two sets must from that point on be considered separate, not affecting each other in any way.
</li>
	<li>
<p>
%T は，次のいずれかにより作成されたならば…：
</p>

<ul>
	<li>
既存の`閲覧文脈$の`~script$により, または
</li>
	<li>
利用者が既存の閲覧文脈から~linkを追うことにより, または
</li>
	<li>
特定の`文書$に関係する何らかの別の方法で
</li>
</ul>

<p>
…ならば
⇒
その作成が新たな~session~storageの開始でないならば、その`文書$の`生成元$に属する~session~storage区画が，
%T に複製され~MUST。
しかしながら，その時点から、この２つの区画は互いに影響しないように，別個のものと見なされ~MUST。
</p>

◎
When a new top-level browsing context is created by a script in an existing browsing context, or by the user following a link in an existing browsing context, or in some other way related to a specific Document, and the creation is not a new start for session storage, then the session storage area of the origin of that Document must be copied into the new browsing context when it is created. From that point on, however, the two session storage areas must be considered separate, not affecting each other in any way.
</li>
</ul>


<p id="sessionStorageEvent">
~session~storage区画 %A に属する
`Storage$I ~obj %S に対し［
`setItem()$m ／ `removeItem()$m ／ `clear()$m
］~methodが呼出されたときは、その~methodにおいて［
例外が投出された, あるいは上述の “何もしては~MUST_NOT” と規定されている
］ときを除き
⇒
次を満たすような各 `文書$ %文書 に対し，`~storage通知を送信する$
⇒
［［
%文書 の`~window$の `sessionStorage$m 属性
］が返す `Storage$I ~obj
］は、［
%A に属する, かつ %S でない
］
<!-- 実際の~eventの配送先は Window -->
◎
When the setItem(), removeItem(), and clear() methods are called on a Storage object x that is associated with a session storage area, if the methods did not throw an exception or "do nothing" as defined above, then for every Document object whose Window object's sessionStorage attribute's Storage object is associated with the same storage area, other than x, send a storage notification.
</p>

		</section>
		<section id="the-localstorage-attribute">

<h3 title="The localStorage attribute">11.2.3. `localStorage^m 属性</h3>

⇒！
[NoInterfaceObject]
interface `WindowLocalStorage@I {
  readonly attribute `Storage$I `localStorage$m;
};
`Window$I implements `WindowLocalStorage$I;
◎


<p>
`localStorage@m
~objは、`生成元$ごとに
`Storage$I
~objを提供する。
~FINGERPRINTING
◎
The localStorage object provides a Storage object for an origin.
◎
(This is a fingerprinting vector.)
</p>

<p>
~UAは、それぞれの`生成元$ごとに，専属の~local~storage区画をあてがわ~MUST。
◎
User agents must have a set of local storage areas, one for each origin.
</p>

<p>
~UAが~local~storage区画の~dataを失効させるのは、保安~上の理由があるか, または利用者から要請された場合に限られるべきである。
~UAは、~dataに~accessし得る~scriptが走らせている間は，~dataを失効させないべきである。
◎
User agents should expire data from the local storage areas only for security reasons or when requested to do so by the user. User agents should always avoid deleting data while a script that could access that data is running.
</p>

<p>
`localStorage$m
属性に~accessされた際には、~UAは，以下に与える
<dfn id="storage-object-initialisation-steps">`Storage^I ~objの初期化~手続き</dfn>
を走らせ~MUST：
◎
When the localStorage attribute is accessed, the user agent must run the following steps, which are known as the Storage object initialization steps:
</p> 

<ol>
	<li>
~UAの任意選択で
⇒
~IF［
その要請は施策決定に違反している（例えば~UAの環境設定により，その~pageでは~dataの持続-は許容されていないなど）
］
⇒
~THROW `SecurityError$E
◎
The user agent may throw a "SecurityError" DOMException and abort these steps instead of returning a Storage object if the request violates a policy decisions (e.g. if the user agent is configured to not allow the page to persist data).
</li>
	<li>
%O ~LET 属性が~accessされている`~window$の`文書$の`生成元$
◎
↓</li>
	<li>
~IF［
%O は`不透明な生成元$である
］
⇒
~THROW `SecurityError$E
◎
If the Document's origin is an opaque origin, then throw a "SecurityError" DOMException and abort these steps.
</li>
	<li>
~IF［
%O には，~local~storage区画はあてがわれていない
］
⇒
新たな~storage区画を作成した上で，それを %O にあてがう。
◎
Check to see if the user agent has allocated a local storage area for the origin of the Document of the Window object on which the attribute was accessed. If it has not, create a new storage area for that origin.
</li>
	<li>
~RET ［
%O にあてがわれている~local~storage区画
］に属する `Storage$I ~obj
— 各 `文書$は、それぞれが別個の，その`~window$の `localStorage$m 属性に対応する `Storage$I ~objを持た~MUST。
◎
Return the Storage object associated with that origin's local storage area. Each Document object must have a separate object for its Window's localStorage attribute.
</li>
</ol>

<p id="localStorageEvent">
~local~storage区画 %A に属する
`Storage$I ~obj %S に対し［
`setItem()$m ／ `removeItem()$m ／ `clear()$m
］~methodが呼出されたときは、その~methodにおいて［
例外が投出された, あるいは上述の “何もしては~MUST_NOT” と規定されている
］ときを除き
⇒
次を満たすような各 `文書$ %文書 に対し，`~storage通知を送信する$
⇒
［［
%文書 の`~window$の `sessionStorage$m 属性
］が返す `Storage$I ~obj
］は、［
%A に属する, かつ %S でない
］。
◎
When the setItem(), removeItem(), and clear() methods are called on a Storage object x that is associated with a local storage area, if the methods did not throw an exception or "do nothing" as defined above, then for every Document object whose Window object's localStorage attribute's Storage object is associated with the same storage area, other than x, send a storage notification.
</p>

<p id="localStorageMutex">
`localStorage$m 属性は、共有されている状態への~accessを提供する。
この仕様は、複数の閲覧文脈を同時に処理する~UAにおける，閲覧文脈~間の相互作用は定義しない。
よって，作者には、~lockする類の仕組みはないものと見做すことが奨励される。
例えばある~siteが、`~key$に対する`~value$を読取って, それを~~変更した結果の新たな`~value$を，当の~sessionに対する一意な識別子として書戻すとするとき、これが異なる二つの~browser~windowで同時に行われた場合、両~sessionに対し同じ “一意な” 識別子を利用する結果，破壊的な効果をもたらし得ることになる。
◎
The localStorage attribute provides access to shared state. This specification does not define the interaction with other browsing contexts in a multiprocess user agent, and authors are encouraged to assume that there is no locking mechanism. A site could, for instance, try to read the value of a key, increment its value, then write it back out, using the new value as a unique identifier for the session; if the site does this twice in two different browser windows at the same time, it might end up using the same "unique" identifier for both sessions, with potentially disastrous effects.
</p>

		</section>
		<section id="the-storage-event">

<h3 title="The storage event">11.2.4. `storage^et ~event</h3>

<!-- `StorageEvent@I -->
<p>
上の
<a href="#sessionStorageEvent">~session~storage節</a>,
<a href="#localStorageEvent">~local~storage節</a>
に述べたように，~storage区画`の内容^tnoteが変化した際には、`文書$の`~window$に向けて， `storage$et ~eventが発火される。
◎
The storage event is fired on a Document's Window object when a storage area changes, as described in the previous two sections (for session storage, for local storage).
</p>

<p>
~UAは，`文書$ %文書 に対し
`~storage通知を送信する@
ときは、次を行う~taskを`待入し$~MUST
⇒
%文書 の`~window$に向けて， `StorageEvent$I ~interfaceを利用する 名前 `storage$et の`~eventを発火-$する
◎
When a user agent is to send a storage notification for a Document, the user agent must queue a task to fire an event named storage at the Document object's Window object, using StorageEvent.
</p>

<p class="note">注記：
%文書 は `全部的に作動中$であることは必要とされないが、 %文書 に向けて発火される~eventは， %文書 が再び `全部的に作動中$になるまでは、`~event~loop$からは無視される。
◎
Such a Document object is not necessarily fully active, but events fired on such objects are ignored by the event loop until the Document becomes fully active again.
</p>

<p>
上述の~taskの`~task源$は、 `~DOM操作~task源$とする。
◎
The task source for these tasks is the DOM manipulation task source.
</p>

<div class="p">

<p>
`setItem()$m ~methodの呼出により `~item$ %~item が追加-または更新され，それに応じて~eventが発火される場合、その~eventの各種 属性は，次のように初期化され~MUST：
</p>

<ul><li>`key$m 属性 ~SET %~item の`~key$
</li><li>`oldValue$m 属性 ~SET 
%~item は新たに追加されたならば ~NULL ／
他の場合は %~item の元の`~value$
</li><li>`newValue$m 属性 ~SET %~item の新たな`~value$
</li></ul>

<p class="trans-note">【
呼出の回数に応じて，相応する個数の~eventが配送されることになるが、例えば同じ`~item$の値が複数回更新された場合に１個の~eventに集約されることは，あるかもしれない。
】</p>


<p>
`removeItem()$m ~methodの呼出により `~item$ %~item が除去され，それに応じて~eventが発火される場合、その~eventの各種 属性は，次のように初期化され~MUST：
</p>

<ul><li>`key$m 属性 ~SET %~item の`~key$
</li><li>`oldValue$m 属性 ~SET %~item の`~value$
</li><li>`newValue$m 属性 ~SET ~NULL
</li></ul>


◎
If the event is being fired due to an invocation of the setItem() or removeItem() methods, the event must have its key attribute initialized to the name of the key in question, its oldValue attribute initialized to the old value of the key in question, or null if the key is newly added, and its newValue attribute initialized to the new value of the key in question, or null if the key was removed.
</div>



<div>
<p>
`clear()$m ~methodの呼出に応じて~eventが発火される場合、その~eventの各種 属性は，次のように初期化され~MUST：
</p>

<ul>
	<li>
［
`key$m,
`oldValue$m,
`newValue$m
］属性 ~SET ~NULL
</li>
	<li>
`url$m 属性 ~SET ［
影響された `Storage$I ~objが属する`文書の~URL$
］
</li>
	<li>
`storageArea$m 属性 ~SET ［
対象の`文書$の`~window$のそれと同種の（すなわち~sessionか~localか） `Storage$I 区画を表現する `Storage$I ~obj
］
</li>
</ul>

◎
Otherwise, if the event is being fired due to an invocation of the clear() method, the event must have its key, oldValue, and newValue attributes initialized to null.
◎
In addition, the event must have its url attribute initialized to the URL of the document whose Storage object was affected; and its storageArea attribute initialized to the Storage object from the Window object of the target Document that represents the same kind of Storage area as was affected (i.e. session or local).
</div>


			<section id="the-storageevent-interface">

<h4 title="The StorageEvent interface">11.2.4.1. `StorageEvent^I ~interface</h4>

⇒！
[Constructor(DOMString type, optional `StorageEventInit$I eventInitDict)]
interface `StorageEvent@I : `Event$I {
  readonly attribute DOMString? `key$m;
  readonly attribute DOMString? `oldValue$m;
  readonly attribute DOMString? `newValue$m;
  readonly attribute USVString `url$m;
  readonly attribute `Storage$I? `storageArea$m;
};

dictionary `StorageEventInit@I : `EventInit$I {
  DOMString? key = null;
  DOMString? oldValue = null;
  DOMString? newValue = null;
  USVString url = "";
  `Storage$I? storageArea = null;
};
◎

<!-- `StorageEvent@I -->

<dl class="idl-def">
	<dt>`key@m</dt>
	<dd>
変更された`~item$の`~key$を表現する。
◎
↓</dd>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The key attribute must return the value it was initialized to. It represents the key being changed.
</dd>

	<dt>`oldValue@m</dt>
	<dd>
変更された`~item$の前の`~value$を表現する。
◎
↓</dd>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The oldValue attribute must return the value it was initialized to. It represents the old value of the key being changed.
</dd>

	<dt>`newValue@m</dt>
	<dd>
変更された`~item$の新たな`~value$を表現する。
◎
↓</dd>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The newValue attribute must return the value it was initialized to. It represents the new value of the key being changed.
</dd>

	<dt>`url@m</dt>
	<dd>
変更された`~item$を持つ~storageが属する`文書の~URL$を表現する。
◎
↓</dd>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The url attribute must return the value it was initialized to. It represents the URL of the document whose key changed.
</dd>

	<dt>`storageArea@m</dt>
	<dd>
影響された `Storage$I ~objを表現する。
◎
↓</dd>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The storageArea attribute must return the value it was initialized to. It represents the Storage object that was affected.
</dd>

</dl>


			</section>
		</section>
	</section>
	<section id="disk-space-2">

<h2 title="Disk space">11.3. ~disk容量</h2>

<p>
~UAは、~storage区画に許容される総量を制限するべきである。
さもなければ、敵対的~作者が，この特色機能を利用して 利用者の~disk容量を枯渇させることが可能になるので。
◎
User agents should limit the total amount of space allowed for storage areas, because hostile authors could otherwise use this feature to exhaust the user's available disk space.
</p>

<p>
~UAは、~siteが，その生成元の他の提携~siteの下で~dataを格納することからも，利用者を防護するべきである。
さもなければ、例えば
`a1.example.com^s,
`a2.example.com^s,
`a3.example.com^s,
等々 に許容される限界まで~dataを格納することにより，~mainの
`example.com^s
の~storage制限を迂回することが可能になるので。
◎
User agents should guard against sites storing data under their origin's other affiliated sites, e.g. storing up to the limit in a1.example.com, a2.example.com, a3.example.com, etc, circumventing the main example.com storage limit.
</p>

<p>
~UAは、~quata~~上限に到達した際に、利用者がより多くの容量を~siteにあてがえるよう，利用者に促してもよい。
これにより，~siteは、例えば，利用者が作成した多数の文書~dataを，利用者のコンピュータ上に格納できるようになる。
◎
User agents may prompt the user when quotas are reached, allowing the user to grant a site more space. This enables sites to store many user-created documents on the user's computer, for instance.
</p>

<p>
~UAは、それぞれの~domainが占めている容量を，利用者が見れるようにするべきである。
◎
User agents should allow users to see how much space each domain is using.
</p>

  

<p>
`生成元$ごとに，ほぼ恣意的な 5 ~megabyte程度を上限にすることが示唆される。
実装からの~feedbackを歓迎する。
その際には，この示唆は将来的に更新されることになる。
◎
A mostly arbitrary limit of five megabytes per origin is suggested. Implementation feedback is welcome and will be used to update this suggestion in the future.
</p>

<p>
予測可能性のため，~quataは格納済み~dataの無圧縮時の~sizeに基づくべきである。
◎
For predictability, quotas should be based on the uncompressed size of data stored.
</p>


	</section>
	<section id="privacy">

<h2 title="Privacy">11.4. ~privacy</h2>

		<section id="user-tracking">

<h3 title="User tracking">11.4.1. 利用者の追跡</h3>

<p>
第三者主体の広告主（あるいは，複数の~siteに内容を流布し得る任意の主体）は、利用者の関心~profileを築き上げ，より~~高度な絞り込み広告を可能にする目的で、~local~storage区画に一意な識別子を格納することにより，複数の~sessionに渡って利用者を追跡し得る。
利用者の本当の身元を知っている~site（例えば認証情報を要する電子商取引~site）と~~連携した場合、不当な団体が，匿名 Web 利用よりも高い精度で個人を標的にすることも許容されてしまう。
◎
A third-party advertiser (or any entity capable of getting content distributed to multiple sites) could use a unique identifier stored in its local storage area to track a user across multiple sessions, building a profile of the user's interests to allow for highly targeted advertising. In conjunction with a site that is aware of the user's real identity (for example an e-commerce site that requires authenticated credentials), this could allow oppressive groups to target individuals with greater accuracy than in a world with purely anonymous Web usage.
</p>

<p>
利用者~追跡の~riskを軽減するために利用し得る、いくつもの技法がある：
◎
There are a number of techniques that can be used to mitigate the risk of user tracking:
</p>

<dl>
	<dt>
第三者主体による~storage利用を阻止する
◎
Blocking third-party storage
</dt>
	<dd>
~UAは、 `localStorage$m ~objへの~accessを，`~top-level閲覧文脈$にて`作動中の文書$の~domainを出自にしている~scriptに制約してもよい。
例えば、 `iframe$e の中で走らせている 他の~domainからの~pageに対しては、 API への~accessを~~許可しないなど。
◎
User agents may restrict access to the localStorage objects to scripts originating at the domain of the active document of the top-level browsing context, for instance denying access to the API for pages from other domains running in iframes.
</dd>

	<dt>
格納済み~dataを失効させる
◎
Expiring stored data
</dt>
	<dd>
~UAは、場合によっては，利用者による環境設定に従って，一定期間が経過した格納済み~dataは自動的に削除されるようにしてもよい。
◎
User agents may, possibly in a manner configured by the user, automatically delete stored data after a period of time.
</dd>
	<dd>
例えば~UAは、その環境設定にて、第三者主体による~local~storage区画を~session用途のみと見なし，利用者がその~storageへ~accessし得るすべての`閲覧文脈$を閉じた時点で ~dataが削除されるように，環境設定することもできる。
◎
For example, a user agent could be configured to treat third-party local storage areas as session-only storage, deleting the data once the user had closed all the browsing contexts that could access it.
</dd>
	<dd>
これにより、~siteが複数の~sessionに渡って利用者を追跡できるのは，利用者が~site自身にて認証される場合（例えば購入予約や~serviceへの~log-inなど）に限られることになるため、~siteが利用者を追跡する~~能力を制約し得るものになる。
◎
This can restrict the ability of a site to track a user, as the site would then only be able to track the user across multiple sessions when they authenticate with the site itself (e.g. by making a purchase or logging in to a service).
</dd>
	<dd>
しかしながら これは、持続的~storageの仕組みから得られる API の有用性も抑制する。
それはまた、利用者が~dataの失効がもたらす~~影響について全部的に理解していない場合に、利用者の~dataを~riskにさらすことになる。
◎
However, this also reduces the usefulness of the API as a long-term storage mechanism. It can also put the user's data at risk, if the user does not fully understand the implications of data expiration.
</dd>

	<dt>
持続的~storageを~cookie同様に扱う
◎
Treating persistent storage as cookies
</dt>
	<dd>
利用者が~local~storage区画に格納されている~dataは残しつつ，~cookieを消去することで自身の~privacy保護を行う試みに対しては、~site側は，両者の特色機能を利用して相互に冗長backupすることで、迂回し得る。
~UAは、利用者に，この可能性について理解することを支援し、持続的~storageを供するすべての特色機能について，同時に~dataを削除し得るような、~UIを備えるべきである。
`COOKIES$r
◎
If users attempt to protect their privacy by clearing cookies without also clearing data stored in the local storage area, sites can defeat those attempts by using the two features as redundant backup for each other. User agents should present the interfaces for clearing these in a way that helps users to understand this possibility and enables them to delete data in all persistent storage features simultaneously. [COOKIES]
</dd>

	<dt>
~local~storage ~accessのための~site別 安全list
◎
Site-specific safelisting of access to local storage areas
</dt>
	<dd>
~UAは、~siteによる~session~storage区画への~accessは制約しない一方で，~local~storage区画への~accessについては 利用者からの~~許可を要するようにしてもよい。
◎
User agents may allow sites to access session storage areas in an unrestricted manner, but require the user to authorize access to local storage areas.
</dd>

	<dt>
格納済み~dataからの生成元の追跡
◎
Origin-tracking of stored data
</dt>
	<dd>
~UAは、~dataを格納させた第三者主体の生成元からの内容を含んでいる~siteの`生成元$を記録してよい。
◎
User agents may record the origins of sites that contained content from third-party origins that caused data to be stored.
</dd>
	<dd>
この情報を 持続的~storageに存在する~dataの表示に利用すれば、利用者が持続的~storageのどの部分を取り除くかの~~判断材料になる。
阻止listとの併用により（ “この~dataを削除して、この~domainが再び~dataを格納しないようにする” 等）、利用者は，持続的~storageの利用を 信用できる~siteのみに制約できるようになる。
◎
If this information is then used to present the view of data currently in persistent storage, it would allow the user to make informed decisions about which parts of the persistent storage to prune. Combined with a blocklist ("delete this data and prevent this domain from ever storing data again"), the user can restrict the use of persistent storage to sites that they trust.
</dd>

	<dt>
阻止listの共有-
◎
Shared blocklists
</dt>
	<dd>
~UAは、利用者~間で持続的~storageに関する~domainの阻止listを共有できるようにしてもよい。
◎
User agents may allow users to share their persistent storage domain blocklists.
</dd>
	<dd>
これにより、~communityは~privacy保護に向けて~~協同できるようになる。
◎
This would allow communities to act together to protect their privacy.
</dd>
</dl>

<p>
これらの示唆は、利用者を追跡するための，この API の自明な利用は防止するが、まとめて阻止するものではない。
~siteは、単独の~domain内では~sessionに渡って利用者を追跡し続けられ，その情報を~siteが取得した個人識別情報（~~名前, カード番号, 住所など）と伴に第三者主体に渡すことは可能である。
第三者主体が，複数の~siteで協同してその種の情報を得れば、依然として，~profileは作成され得る。
◎
While these suggestions prevent trivial use of this API for user tracking, they do not block it altogether. Within a single domain, a site can continue to track the user during a session, and can then pass all this information to the third party along with any identifying information (names, credit card numbers, addresses) obtained by the site. If a third party cooperates with multiple sites to obtain such information, a profile can still be created.
</p>

<p>
しかしながら，利用者の追跡は、~UAとの協同が一切なくても
— 例えば、 URL に~session識別子を埋め込むことにより —
ある範囲において（過去に遡ってすら）可能である。
これは、害の無い目的で，すでに広く利用されてはいるが、利用者の追跡に容易に転用し得る技法でもある。
この情報は、他~siteと共有し得るものになる
— 訪問者の IP ~addressその他の 利用者~特有の~data（例えば `User-Agent^h ~headerや環境設定など）を利用して，個別の~sessionを組合せて、一貫した利用者~profileに仕立て上げることにより。
◎
However, user tracking is to some extent possible even with no cooperation from the user agent whatsoever, for instance by using session identifiers in URLs, a technique already commonly used for innocuous purposes but easily repurposed for user tracking (even retroactively). This information can then be shared with other sites, using visitors' IP addresses and other user-specific data (e.g. user-agent headers and configuration settings) to combine separate sessions into coherent user profiles.
</p>

		</section>
		<section id="sensitivity-of-data">

<h3 title="Sensitivity of data">11.4.2. ~dataの取り扱い</h3>

<p>
~UAは、持続的に格納された~dataを，潜在的に~sensitiveなものと見なすべきである。
メール, 予定表, 診断記録, その他の秘匿文書が，この仕組みを通して格納されることは、ごく普通にあり得る。
◎
User agents should treat persistently stored data as potentially sensitive; it's quite possible for e-mails, calendar appointments, health records, or other confidential documents to be stored in this mechanism.
</p>

<p>
最後に、~UAは，~dataを削除する際には、必ず，下層の~storageからも即座に削除されるようにすべきである。
◎
To this end, user agents should ensure that when deleting data, it is promptly deleted from the underlying storage.
</p>

		</section>
	</section>
	<section id="security-storage">

<h2 title="Security">11.5. 保安</h2>

		<section id="dns-spoofing-attacks">

<h3 title="DNS spoofing attacks">11.5.1. DNS 偽装~攻撃</h3>

<p>
DNS 偽装~攻撃の下では、一定の~domainに属すると主張する~hostが本当にその~domainからのものであるかどうか，保証できなくなる可能性がある。
TLS を利用すれば，これを軽減できる。
TLS を利用する~pageは、［
利用者, 利用者を~~代理する~software, ［
証明書を伴う TLS を利用していて, 同じ~domainからであるものと識別される，他の~page
］］のみが，それらの~storage区画に~access可能であることの、確証を得られる。
◎
Because of the potential for DNS spoofing attacks, one cannot guarantee that a host claiming to be in a certain domain really is from that domain. To mitigate this, pages can use TLS. Pages using TLS can be sure that only the user, software working on behalf of the user, and other pages using TLS that have certificates identifying them as being from the same domain, can access their storage areas.
</p>

		</section>
		<section id="cross-directory-attacks">

<h3 title="Cross-directory attacks">11.5.2. ~cross-directory攻撃</h3>

<p>
同じ~host名を共有している作者たちは（例えば（今や~~機能しなくなったが） `geocities.com^s で内容を~hostしている作者たちなど）、全員が１個の~local~storage~objを共有することになる。
~pathnameにより~accessを制約する特色機能はないので、彼らのうち誰もが他の作者の~dataを読取ったり, 上書きすることが可能になる。
したがって，他者と~hostを共有している作者には、これらの特色機能の利用を避けることが督促される。
◎
Different authors sharing one host name, for example users hosting content on the now defunct geocities.com, all share one local storage object. There is no feature to restrict the access by pathname. Authors on shared hosts are therefore urged to avoid using these features, as it would be trivial for other authors to read the data and overwrite it.
</p>

<p class="note">注記：
仮に~path制約の特色機能が利用できたとしても、通常の~DOM~scripting 保安~modelから、この保護を迂回して，任意の~pathからの~dataへ~accessすることは自明になる。
◎
Even if a path-restriction feature was made available, the usual DOM scripting security model would make it trivial to bypass this protection and access the data from any path.
</p>

		</section>
		<section id="implementation-risks">

<h3 title="Implementation risks">11.5.3. 実装にあたって考慮すべき~risk</h3>

<div >
<p>
これらの持続的な~storage特色機能を実装するにあたっては、２つの主要な~riskがある：
</p>

<ul ><li>敵対的~siteによる他の~domainの情報の読取り
</li><li>敵対的~siteによる情報の書込み後の他~siteからの情報の読取り
</li></ul>

◎
The two primary risks when implementing these persistent storage features are letting hostile sites read information from other domains, and letting hostile sites write information that is then read from other domains.
</div>

<p>
第三者主体~siteの~domainからの読取りは想定されていない~dataに，そのような読取りを許した場合、<em>情報~漏洩</em>になる。
例えば、ある~domainの利用者の~wishlistは，他の~domainによる絞り込み広告に利用され得る。
あるいは文書作成~siteにより格納された，利用者の作業中の秘匿文書が競合企業の~siteに読まれてしまうなど。
◎
Letting third-party sites read data that is not supposed to be read from their domain causes information leakage, For example, a user's shopping wishlist on one domain could be used by another domain for targeted advertising; or a user's work-in-progress confidential documents stored by a word-processing site could be examined by the site of a competing company.
</p>

<p>
第三者主体~siteによる，他の~domainの持続的~storageへの~dataの書込みを許した場合、同等に危険な，<em>情報~spoofing</em>が生じる。
例えば、敵対的~siteが利用者の~wishlistに “item” を付け加えるなど。
あるいは、敵対的~siteにより利用者の~session識別子が既知の ID に設定された場合，その ID は被害者~siteにおける利用者の追跡に利用され得る。
◎
Letting third-party sites write data to the persistent storage of other domains can result in information spoofing, which is equally dangerous. For example, a hostile site could add items to a user's wishlist; or a hostile site could set a user's session identifier to a known ID that the hostile site can then use to track the user's actions on the victim site.
</p>

<p>
したがって，この仕様に述べた`生成元$~modelを厳格に守ることは、利用者の保安にとり，重要になる。
◎
Thus, strictly following the origin model described in this specification is important for user security.
</p>


		</section>
	</section>
</section>
</main><!-- id="MAIN" -->

</body>
</html>


