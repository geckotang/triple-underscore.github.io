<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Custom elements（日本語訳）</title>

<link rel="stylesheet" href="../../..WEB/common-css.css" type="text/css" />

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/scripting.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160502 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		P: 'production',
		st: 'attr-state',
		v: 'value',
		E: 'error',
		js: 'es',
		jc: 'js-code',
		jA: 'abstract',
		ps: 'pseudo',
		css: 'css',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		st: 'span',
		ps: 'code',
		js: 'span',
		jc: 'code',
		jA: 'span',
		h: 'code',
		P: 'code',
		s: 'samp',
		css: 'code',
		v: 'code',
		V: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
//	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|❝.|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN', '_toc_list0');


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '❝':
		return ( 'U+00'
			+ match[1].charCodeAt(0).toString(16).toUpperCase()
			+ ' ( "<code class="literal">' + match[1] + '</code>" )'
		);
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
//var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'mt': // media type
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a': // event type
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'et': // event type
	break;
case 'ps': // css pseudo class
	text = ':' + key;
	break;
case 'i': // model constants
	break;
case 'h': // http header
	text = '<code class="header">' + text + '</code>';
	break;
case 'v': // attr value
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">

</script>


<!--% リンク置換データ -->


<!--% 置換データ -->
<script type="text/plain" id="words_table1">
TC39:https://tc39.github.io/ecma262/
	ES6
ARIASpec:https://w3c.github.io/aria/aria/aria.html
HTML-SELECTORS:selectors-html-ja.html
PROMISES:promises-guide-ja.html

此れ:<b>これ°</b>
Window: <code>Window</code> 
</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">
API:
ASCII:
ARIA:
MathML:
SVG:
XML:
DOM:
HTML:
IDL:
JS:JavaScript
UA:user agent:UA
Web:
article:
access::::アクセス
accessibility::::アクセス容易性:アクセシビリティ
algo:algorithm:::アルゴリズム
app:application:::アプリ
approach::::アプローチ
browser::::ブラウザ
button::::ボタン
call:
callback:
class::::クラス
click::::クリック
code::::コード
collection::::コレクション
	contrast:
control::::コントロール

custom::::カスタム
encapsulate::::カプセル化

entry::::エントリ
event::::イベント
fetching:
filter::::フィルタ
flow::::フロー
focus::::フォーカス
form::::フォーム
	forward:
handler::::ハンドラ
hook::::フック
hyphen::::ハイフン
instance::::インスタンス
	instance化:instantiate#1
interface::::インタフェース
item::::アイテム
key:
	キー
keyboard::::キーボード
list::::リスト
listener::::リスナ
main::::メイン
map:
	マップ
marker::::マーカ
markup::::マークアップ
member::::メンバ
method::::メソッド
model::::モデル
node::::ノード
obj:object:::オブジェクト
option::::オプション
parameter::::パラメタ
platform::::プラットフォーム

promise:
prototype:
push:
pop:
registry::::レジストリ

script::::スクリプト
scripting::::スクリプト処理
software::::ソフトウェア
stack::::スタック
stylesheet::::スタイルシート
system::::システム
tag::::タグ
text::::テキスト
tool::::ツール
window::::ウィンドウ

chain:
shadow:
clone::::クローン
lifecycle:
	:::ライフサイクル
icon::::アイコン
install::::インストール
	installation
program::::プログラム
	~program的に:programmatic
animation::::アニメーション
styling::::スタイル付け
iterable:


	●仕様
一意:unique:~
一般:general:~
中核:core:~
事例:case:~
仕方:way:~
仕様:spec:~
作者:author:~
共通的:common:~

前方互換性:forward compatibility:~
可能0:possible:可能
意味論:semantics:~
	機能, 意味論の両面で:both functionally and semantically
機能:function:~
	機能~面:functional:~

	意図:intention:~
	意図:intent:~
技法:technique:~
技術:technology:~

制約:restriction:~
制限:limitation:~
意味-:mean:~
意味:meaning:~
利用:use:~
利用者:user:~
再利用:reuse:~
予約-:reserve:~
使役-:employ:~
依拠-:rely:~
保証-:guarantee:~
取扱う:handle する:取り扱う
孕む:involve する:~
実施:practice:~
実装-:implement:~
実装:implementation:~
実装者:implementer:~
入-:introduce:~
指定-:specify:~
指示-:indicate:~
挙動:behaviour:ふるまい
挙動する:behave:ふるまう
提供-:provide:~
期待-:expect:~
期待:expectation:~
確保-:ensure:~
確立-:establish:~
管理-:manage:~
適用-:apply:~
開発-:develop:~
関与-:participate:~
記述-:describe:~
示唆-:allude:~
合理化-:rationalise:~
公開-:expose:~
働かな:work しな:~
働く:work する:~
許容-:allow:~
説明-:explain:~
違反-:violate:~
検分-:inspect:~

隔たり:gap:~

実質的:effective:~
将来:future:~
	~~用法:scenario:~
	序論:introduction:~
導
既存の:existing:~
既定:default:~
既定の:default:~
明示的:explicit:~
本質的:essential:~
未知の:unknown:~
標準:standard:~
機能性:functionality:~
正しい:correct な:~
正確:exact:~
歴史的:historical:~
注釈文:prose:~
特別な:special:~
特有の:-specific:~
特色機能:feature:~
目標:goal:~
目的0:purpose:目的
直接的:direct:~
間接的:indirect:~
相互作用:interaction:~
相互運用可能:interoperable:~
能:ability:機能
能力:capabilities:~
適切:appropriate:~
達成-:accomplish:~
適合:conforming:~
適合性:conformance:~
適正:proper:~
重要:important:~
関連する:relevant な:~
演習:exercise:~
出来事:occurrences:~
今日:today:~
読者:reader:~
不可欠:crucial:~
効果:effect:~
図式:schematic diagram:~
自明:trivial:~
著作-:author:~
要件:requirements:~
要求-:require:~
要約-:summarise:~
要約:summary:~
規則:rule:~
不精確:imprecise:~
	imprecision:~
念頭:mind:~
再現-:duplicate:~
増強-:enhance:~
増強:enhancement:~
増補-:supplement:~
最適化-:optimize:~
消費-:consume:使用
消費者:consumer:使用者
期待0:hope:期待
全装備の:full-featured:~
		fully-featured
非公式:informal:~
概念:concept:~
関係-:relate:~
所与の:given:与えられた
手動:manual:~
特別:special:~
care::::ケア
決着-:settle:~
正式:formal:~
柔軟:flexibile:~
	flexibility
通例の:usual:~
通例的に:usual に:~
通常の:normal な:~
欲-:desire:~
求めら:want さ:~
強いら:force さ:~
	forcing
防護-:guard:~

	●custom
反応-:react::~::リアクト
反応:reaction::~::リアクション
応答-:respond:~
拡張-:extend:~
拡張元の:extended:~
拡張属性:extended attribute:~
拡張可能点:extensibility points:拡張可能な箇所
待行列:queue::待ち行列::キュー
待入され:queue され::待ち行列に入れられ::キューされ
待入れる:enqueue する::待ち行列に入れる::エンキューする
昇格:upgrade::~::アップグレード
	昇格-
昇格処理:upgrading::~::アップグレーディング
昇格法:upgrading::~::アップグレーディング
接続-:connect::~
切断-:disconnect::~
自律的:autonomous::~
継承-:inherit:~
構成子:construct:~
構築子:constructor::~::コンストラクタ
構築-:construct::~::コンストラクト
構築済み:constructed::~::コンストラクト済み
構築:construction::~::コンストラクション
定義-:define:~
定義:definition:~
定義済み:defined:~
未定義の:undefined:~
定義済時:when-defined::定義済み時
観測ed:observed::観測先の
観測-:observe::観測
対応付け:mapping::~
対応付ける:map する::~
対応付けら:map さ::~

	●未分類
反映-:reflect::~
上書き:override:~
可能化-:enable:~
不能化-:disable:~
不能化:disabled:~
付加-:append:~
代理-:proxy:~
作動化-:activate:~
置換-:replace:~
作成-:create:~
作成:creation:~
作成法:creating:~
表現-:represent:~
先送り:defer:~
報告-:report:~
共有-:share:~
具現化:rendering:~
描画:rendering:~
処理-:process:~
処理:processing:~
変換-:convert:~
再投出-:rethrow:~
例外:exception:~
例外投出あり:rethrow any exceptions:~
投出-:throw:~
中途完了:abrupt completion:~
呼出す:invoke する:呼び出す
呼出され:invoke され:呼び出され
被呼出時:被 invoke 時:~
	入力:input:~
出力-:output:~
初期:initial:~
初期化:initialization:~
	初期~時:initiallly
包含-:contain:~
	内容とする:contain:~
内容:content:~
合致-:match:~:::マッチ


解決-:resolve::~::リゾルブ
充足-:fulfill::~
却下-:reject::~::リジェクト

挿入-:insert:~
操作-:manipulate:~
操作:manipulation:~
変化-:change:~
変更-:change:~
変更:changes:~
変化:changes:~
失敗-:fail:~
実行-:execute:~
宣言-:declare:~

注釈-:annotate:~
注釈付き:annotated:~
注釈:annotation:~
存在-:exist:~
完了-:complete:~
完了:completion:~

設定-:set:~
設定子:setter:~
削除-:delete:~
削除子:deleter:~

移動-:move:~
登録-:register::~
検索-:look up:~
検索取得-:retrieve:~
比較-:compare:~
決定-:determine:~
築かれ:build され:~
築く:build する:~
組合せて:combine して:組み合せて
検査-:check::~::チェック
試行-:try:~
誘発-:trigger:~
誘発:triggering:~
読込まれ:load され::読み込まれ::ロードされ
読込んで:load して::読み込んで::ロードして
識別-:identify:~
走らす:run する:走らせる
走らせ:run し:~
走る:run する:~
走らな:run しな:~
動作:action::~::アクション
走査-:traverse:~
	::トラバース
追加-:add:~
追加:addition:~
遂行-:perform:~
除去-:remove:~
隠す:hide する:~
格納-:store:~
供給-:supply:~
変異:mutation:~
発声-:announce:~
追跡-:track:~
送信0:submission::送信
伝達-:convey:~

本体:body:~
読専:readonly::~

	類:class
妥当:valid:~
一定の:certain:~
全部的:full:~
対話的:interactive:~
	やりとり:interact:~
	内:inside:~
内部:internal:~
範囲:range:~
動的:dynamic:~
単独の:single:~
単純:simple:~
即時:immediate:~
参照:reference:~

同期的:synchronous:~

値:value:~
名:name:~
名前:name:~
名前空間:namespace:~
名前空間付け:namespacing:~

	両者:both:~
	別種の:distinct kind
型:type:~
種別:type:~

透過的:transparent::~
句内容:phrasing content:phrasing 内容:~::フレージング内容
palpable:

大域:global::~::グローバル
大域的:global::~::グローバル
局所:local::~::ローカル
局所的:local::~::ローカル

子:child:~
子たち:children:~
木:tree::~::ツリー
根:root::~::ルート
要素:element:~
属性:attribute:~


	localName

引数:argument:~
強い:strong な:~
手続き:steps:~
段:step:~

擬似類:pseudo-class::擬似 class:擬似クラス

文:statement:~
文書:document:~
文書内:inDocument
文書外:outOfDocument
文脈:context:~

新たな:new:~

更新-:update:~:::アップデート
検索engine:search engine:検索 engine::検索エンジン

構文:syntax:~
構文解析器:parser::~::パーサ
文字:character:~
大文字:uppercase:~
小文字:lowercase:~
互換:compatible:~
文字列:string:~


演算:operation:~

状態:state:~
現在の:current:~
生成規則:production:~
画像:image:~
生成元:origin::~::オリジン
自前の:own:~

	種類:kind:~
空:empty:~
等価:equivalent:~
精確:precise:~
純粋:pure:~

組込みの:built-in:~
結付けら:associate さ:結び付けら
	結果:result:~
	結果の:resulting:~
背後:behind:~
自動的:automatic:~
維持管理-:maintain:~
視覚的:visual:~
論理的:logical:~
資源:resource::~::リソース

	置-:place:~
関数:function:~
閲覧文脈:browsing context:~
遅延:delay:~

集合:set:~
非同期的:asynchronous:~
頁:page:::ページ
順序:order:~
順序付け:ordering:~

国旗:country flag:~
上層:top of:~
仕事:work:~
低level:lower-level:低 level::低レベル
	-:allocate
外観:appearance:~
	多様な:large variety of
形:form:~
文字大小無視:case-insensitive:~
有修飾:qualified:~
欠点:drawbacks:~
漸進的:progressive:~


	残す:left
	少しばかり:slightly
	あいにく:unfortunately
	今の所~as of now
	対照的に:in contrast,
	いつでも:at any time
	好ましい:preferable
	すなわち:namely
	超える:go beyond
	備える:possess
	総称して:collectively
	途中で:during the middle
	直前:just before
	複雑に複合された~complicated~composite
	加えて:additionally
	いくつかの:number of
	着目:zooming in
	forget to:し忘れる
	time:
	-:successful#1
	ある:particular#2
	依存-:depend#1
	必ずしも:necessarily#1
	2 つ:two:~
	3:three:~
	〜に基づく:based:~
	〜の代わりに:instead:~
	いくつかの:several:~
	この:this:~
	これらの:these:~
	しかしながら，:however:~
	したがって:thus:~
	しないよう／できなくする:prevent:~
	すでに:already:~
	すべての:all:~
	その:that:~
	そのような:such:~
	それら:they:~
	それらの:their:~
	それらを:them:~
	とりわけ:especially:~
	べき:should:~
	より大きい:larger:~
	上:above:~
	下:below:~
	不必要な:unnecessary:~
	与-:give:~
	並び:sequence:~
	介:via:~
	他の:other:~
	任意の:arbitrary:~
	伝える:inform／
	何か:something
	例:example:~
	依然として:still:~
	元の:original:~
	別の:another:~
	別個の:distinct:~
	前:before:~
	各:each:~
	同じ:same:~
	含-:include:~
	含めて:including:~
	在-:present:~
	場合によっては:possibly:~
	多くの:many:~
	大きい:large:~
	始-:start:~
	対応ing:corresponding:~
	小さな:small:~
	常に:always:~
	後:after:~
	必要:need:~
	必要とされ:necessary:~
	扱う:treat:~
	数:number:~
	更なる:further:~
	最初の:first:~
	most:ほとんどの
	渡-:pass:~
	現れ:appear:~
	生-:occur:~
	異なる:different:~
	示す:show:~
	種々の:various:~
	等し:equal:~
	自身:itself:~
	複数の:multiple:~
	見よ:see:~
	起きた:fact:~
	返す:return:~
	述べ:describe:~
	追加の:additional:~
	通して:in terms of
	避け:avoid:~
	除-:except:~
	similar
	~~一括して:together as a batch
	~author-exposed
	~become
	他から~~干渉されると困る:delicate
	早期 return:early-return
	~end
	持たせる:gain
	例で~~説明する:illustrate
	非公式に言えば:informally
	~~機能~functioning
	を超える:go beyond
	一助:help／helping
	構築-結果:constructResult
	~later
	so long as
	mix-in:mixing in
	観測ed属性~list:observedAttributes
	観測ed属性~terable:observedAttributesIterable
	~part
	特筆:notably
	楽でない:not a pleasure
	見分け~pinpoint
	~point
	~say
	不断に生やし続ける continually "sprouting"
	そいつの意志:its own volition
	stack-of-queue
	~sure
	~took
	おそらく:probably
	今:now
	呼ばれ:called
	~~想定されているpresumably
	~~活動:effort
	~~真に一度限りのtruly one-time
	〜で:key off
	いくぶん複雑な:somewhat-complicated
	かなり~very
	〜しかねない:lead
	一環:part of
	一番上:the top of
	不足:not very
	伝えてtell:#1
	作者に公開される:author-exposed
	保ち続ける:retain
	別として:apart from
	利用し難く:less usable
	同様~just like before
	囲む:surround する
	外す~away
	容易:easy／easily
	微妙な所がある:somewhat subtle
	時を経るうちに:over time
	埋められ:shrink
	可能な限り give maximum
	最後に:finally
	様々な:variety of
	それなりに複雑な:rather-complicated
	気の利いた:fancy
	満たす:meet
	種々の~variety
	要件に従わないfailing to follow
	課される:bound:#1
	責を負う:responsibility
	重ねて:twice
	に備わる特別なふるまい:the ways in which 〜 is special
</script>



<!--% リンク置換データ 

-->
<script type="text/plain" id="_link_map">
c.[CEReactions]:#cereactions

ps.defined:~HTML-SELECTORS#selector-defined

	●IDL 
E.SyntaxError:~WEBIDL#syntaxerror
E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotSupportedError:~WEBIDL#notsupportederror

I.CustomElementsRegistry:#customelementsregistry
I.Document:~HTMLDOM#document
I.ElementDefinitionOptions:#elementdefinitionoptions
I.HTMLButtonElement:~HTML5/forms.html#htmlbuttonelement
I.HTMLElement:~HTMLDOM#htmlelement
I.HTMLQuoteElement:~HTML5/semantics.html#htmlquoteelement
I.HTMLUnknownElement:~HTMLDOM#htmlunknownelement
I.Window:~HTML5/browsers.html#window

	●m
m.HTMLElement:~HTMLDOM#dom-htmlelement
m.createElement:~DOM4#dom-document-createelement
m.createElementNS:~DOM4#dom-document-createelementns
m.customElements:#dom-window-customelements
m.define:#dom-customelementsregistry-define
m.get:#dom-customelementsregistry-get
m.whenDefined:#dom-customelementsregistry-whendefined

	[CEReactions]:#cereactions

	●attr
a.aria-*:~HTMLCONFORM#attr-aria-*
a.aria-disabled:~ARIASpec#aria-disabled
a.aria-label:~ARIASpec#aria-label
a.async:#attr-script-async
a.data-*:~HTMLDOM#attr-data-*
a.disabled:~HTML5/forms.html#attr-fe-disabled
a.is:#attr-is
a.role:~HTMLCONFORM#attr-aria-role
a.tabindex:~HTML5/interaction.html#attr-tabindex
ddde

	●e
e.blockquote:~HTML5/semantics.html#the-blockquote-element
e.button:~HTML5/forms.html#the-button-element
e.q:~HTML5/semantics.html#the-q-element
e.script:~HTMLSCRIPT#the-script-element
e.span:~HTML5/semantics.html#the-span-element

	●et
et.click:~UIEVENTS#event-type-click
et.keydown:~UIEVENTS#event-type-keydown

	●jA
jA.Construct:~TC39#sec-construct
jA.Get:~TC39#sec-get-o-p
jA.IsCallable:~TC39#sec-iscallable
jA.IsConstructor:~TC39#sec-isconstructor
jA.SameValue:~TC39#sec-samevalue
jA.Type:~TC39#sec-ecmascript-data-types-and-values


l.button:~ARIASpec#button

	●P
P.PCENChar:#prod-pcenchar
P.PotentialCustomElementName:#prod-potentialcustomelementname

	●terms
分類:~HTMLDOM#concept-element-categories
内容~属性:~HTMLDOM#concept-element-attributes
内容~model:~HTMLDOM#concept-element-content-model
この要素を利用できる文脈:~HTMLDOM#concept-element-contexts
~DOM~interface:~HTMLDOM#concept-element-dom
~flow内容:~HTMLDOM#flow-content-2
大域~属性:~HTMLDOM#global-attributes
~palpable内容:~HTMLDOM#palpable-content-2
句内容:~HTMLDOM#phrasing-content-2
対話的~内容:~HTMLDOM#interactive-content-2
透過的:~HTMLDOM#transparent

EBNF 記法:https://www.w3.org/TR/xml/#sec-notation


~ASCII大文字:~HTMLINFRA#uppercase-ascii-letters
~ASCII小文字:~HTMLINFRA#lowercase-ascii-letters
~HTML名前空間:~HTMLINFRA#html-namespace-2
	＊
~XML互換:~HTMLINFRA#xml-compatible
~access可能な名前:~ARIASpec#dfn-accessible-name
~callback this 値:~WEBIDL#dfn-callback-this-value
~callback反応:#callback-reaction

~custom化された組込みの要素:#customized-built-in-element
~custom要素:#custom-element
~custom要素~定義:#custom-element-definition
~custom要素~定義を検索-:#look-up-a-custom-element-definition
~custom要素~構築子:#custom-element-constructor
	構築子:#custom-element-constructor

~custom要素~反応:#concept-custom-element-reaction
~custom要素~反応たちの~stack:#custom-element-reactions-stack
~custom要素~反応~待行列:#custom-element-reaction-queue

~custom要素~反応たちを呼出す:#invoke-custom-element-reactions
~custom要素を昇格する反応を待入れる:#enqueue-a-custom-element-upgrade-reaction
~custom要素~callback反応を待入れる:#enqueue-a-custom-element-callback-reaction

~cloneする:~DOM4#concept-node-clone
~customである:~DOM4#concept-element-custom
~custom要素~状態:~DOM4#concept-element-custom-element-state

cD.~lifecycle~callback~map:#concept-custom-element-definition-lifecycle-callbacks
cD.観測ed属性~list:#concept-custom-element-definition-observed-attributes
cD.~prototype:#concept-custom-element-definition-prototype
cD.名前:#concept-custom-element-definition-name
	定義済み名:#concept-custom-element-definition-name
cD.局所~名:#concept-custom-element-definition-local-name
cD.構築~stack:#concept-custom-element-definition-construction-stack
cD.構築子:#concept-custom-element-definition-constructor
定義済み:~DOM4#concept-element-defined

定義済時~promise~map:#when-defined-promise-map
すでに構築済みを表す~marker:#concept-already-constructed-marker
昇格~反応:#upgrade-reaction
妥当な~custom要素~名:#valid-custom-element-name
	定義:#custom-element-definition
定義-:#element-definition
要素~定義:#element-definition
	~defining:#element-definition

昇格:#upgrades
現在の要素~待行列:#current-element-queue
自律的~custom要素:#autonomous-custom-element
要素~待行列:#element-queue
昇格しようと試行-:#concept-try-upgrade
要素を昇格:#concept-upgrade-an-element
	昇格:#concept-upgrade-an-element

~node文書:~DOM4#concept-node-document
範囲:~DOM4#concept-range
~shadowも含む文書~内:~DOM4#in-a-shadow-including-document
属性~list:~DOM4#concept-element-attribute
要素~interface:~DOM4#concept-element-interface

A.置換-:~DOM4#concept-element-attributes-replace
A.除去-:~DOM4#concept-element-attributes-remove
A.変更-:~DOM4#concept-element-attributes-change
A.付加-:~DOM4#concept-element-attributes-append
除去-:~DOM4#concept-node-remove
作成-:~DOM4#concept-create-element
挿入-:~DOM4#concept-node-insert
要素を作成-:~DOM4#concept-create-element

~shadow根:~DOM4#concept-shadow-root

接続-時:~HTMLINFRA#node-is-connected
切断-時:~HTMLINFRA#node-is-disconnected

互いに関係するかつ生成元も類似する閲覧文脈~群:~HTML5/browsers.html#unit-of-related-similar-origin-browsing-contexts
例外を報告する:~WAPI#report-the-exception

呼出す:~WEBIDL#es-invoking-callback-functions
値に変換-:~WEBIDL#es-type-mapping
拡張属性

~focus可能:~HTML5/interaction.html#focusable-area
~form送信0:~HTML5/forms.html#concept-form-submit
結付けられている~Window:~HTML5/browsers.html#concept-document-window
適用し得る仕様:~HTMLCONFORM#other-applicable-specifications
属する閲覧文脈:~HTML5/browsers.html#concept-document-bc
表現-:~HTMLDOM#represents
要素~型:~HTMLINFRA#element-type

却下された新たな~promise:~PROMISES#a-promise-rejected-with
却下された~promise:~PROMISES#a-promise-rejected-with
解決された新たな~promise:~PROMISES#a-promise-resolved-with
新たな~promise:~PROMISES#a-new-promise
解決-:~PROMISES#resolve-promise

</script>


<!--%style -->
<style type="text/css">

.element-def {
	background: #EEFFEE;
	padding: 0.5em 0.5em 0.5em 1em;
}

code.ABNF {
	display: block;
}
.js-code {
	color: gray;
}

.es {
	font-family: sans-serif0 sans-serif;
	color: #041;
}

</style>

</head>

<body>

<aside class="trans-meta">
<h1>HTML Living Standard — Custom elements 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Scripting</a>
章の一部である
<a href="https://html.spec.whatwg.org/multipage/scripting.html#custom-elements">Custom elements</a>
節を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-05-06</time>
（公開：<time>2016-05-04</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header id="head" class="head with-buttons">

	<hgroup>
<h1>HTML — Custom elements</h1>
<h2>Living Standard — 最終更新 2016 年 5 月 9 日</h2>
	</hgroup>
</header>


<nav class="toc" id="toc">
<h2>目次</h2>
<ol id="_toc_list0"></ol></nav>

<hr>

<main id="MAIN" style="display:none;">

	<section id="custom-elements">
<h2 title="Custom elements">4.13. ~custom要素</h2>

		<section id="custom-elements-intro">
<h3 title="Introduction">4.13.1. 序論</h3>

~INFORMATIVE

<p>
`~custom要素$は、作者に， “全装備の” ~DOM要素を自前で築く仕方を提供する。
作者は常に自身の文書に非~標準の要素を利用して，~scripting等が起きた後に~app特有の挙動を追加することもできるが、そのような要素は，歴史的に非~適合とされてきており，また 機能~面でも不足である。
~custom要素を`定義-$することにより、作者は，構文解析器に要素を適正に構築する方法, および その類の要素が変化に対しどう反応すべきか，を伝えれるようになる。
◎
Custom elements provide a way for authors to build their own fully-featured DOM elements. Although authors could always use non-standard elements in their documents, with application-specific behaviour added after the fact by scripting or similar, such elements have historically been non-conforming and not very functional. By defining a custom element, authors can inform the parser how to properly construct an element and how elements of that class should react to changes.
</p>


<p>
~custom要素は、（~HTMLの要素の様な）既存の~platform特色機能を［
低levelの，作者~向けに公開される拡張可能点（~custom要素~定義の様な）
］を通して説明することにより、より大きな，
“~platformを合理化する”
~~活動の一環を成す。
今日の~custom要素の能力には制限がまだ多く、~HTMLの既存の要素の挙動を
— 機能, 意味論の両面で —
全部的には説明できないが、この隔たりは，時を経るうちに埋められるものと期待0されている。
◎
Custom elements are part of a larger effort to "rationalise the platform", by explaining existing platform features (like the elements of HTML) in terms of lower-level author-exposed extensibility points (like custom element definition). Although today there are many limitations on the capabilities of custom elements—both functionally and semantically—that prevent them from fully explaining the behaviours of HTML's existing elements, we hope to shrink this gap over time.
</p>


			<section id="custom-elements-autonomous-example">
<h4 title="Creating an autonomous custom element">4.13.1.1. 自律的~custom要素の作成法</h4>

~INFORMATIVE

<p>
`自律的~custom要素$を作成-法を例で~~説明するため、ここでは，小さな国旗~icon（ `flag-icon^e ）の描画を~encapsulateする~custom要素を定義してみる。
目標は、次の様な利用を可能にすることである：
◎
For the purposes of illustrating how to create an autonomous custom element, let's define a custom element that encapsulates rendering a small icon for a country flag. Our goal is to be able to use it like so:
</p>


<pre>
&lt;flag-icon country="nl"&gt;&lt;/flag-icon&gt;
</pre>


<p>
これを行うため、先ず，~custom要素~用に
`HTMLElement$I を拡張する~classを宣言する：
◎
To do this, we first declare a class for the custom element, extending HTMLElement:
</p>


<pre>
class FlagIcon extends HTMLElement {
  constructor() {
    super();
    this._countryCode = null;
  }

  static get observedAttributes() { return ["country"]; }

  attributeChangedCallback(%name, %oldValue, %newValue) {
    /* <span class="comment">
%name は常に， `observedAttributes^jc が返す結果のどれか（ここでは `country^l のみ）
◎
name will always be "country" due to observedAttributes
</span> */
    this._countryCode = %newValue;
    this._updateRendering();
  }
  connectedCallback() {
    this._updateRendering();
  }

  get country() {
    return this._countryCode;
  }
  set country(%v) {
    this.setAttribute("country", %v);
  }

  _updateRendering() {
/* <span class="comment">
読者への演習に残しておく。
が，おそらく、
`this.ownerDocument.defaultView^m で，挿入-先の文書が`属する閲覧文脈$があるかどうか検査して、ないなら何もしないことが求められるであろう。
◎
Left as an exercise for the reader. But, you'll probably want to check this.ownerDocument.defaultView to see if we've been inserted into a document with a browsing context, and avoid doing any work if not.
</span> */
  }
}</pre>


<p>
次に，この~classを利用して要素を定義する必要がある：
◎
We then need to use this class to define the element:
</p>


<pre>
`customElements$m.define("flag-icon", FlagIcon);
</pre>


<p>
この時点で、上の~codeは働くことになる！
構文解析器は、 `flag-icon^e ~tagに出会う度に，
`FlagIcon^jc ~classの新たな~instanceを構築して，その新たな `country^jc 属性について上の~codeに伝えてくることになり、~codeは，それを利用して，当の要素の内部~状態を設定し, （適切なときは）その描画も更新する。
◎
At this point, our above code will work! The parser, whenever it sees the flag-icon tag, will construct a new instance of our FlagIcon class, and tell our code about its new country attribute, which we then use to set the element's internal state and update its rendering (when appropriate).
</p>


<p>
`flag-icon^e 要素を ~DOM~APIを利用して作成することもできる：
◎
You can also create flag-icon elements using the DOM API:
</p>


<pre>
const %flagIcon = document.createElement("flag-icon")
%flagIcon.country = "jp"
document.body.appendChild(%flagIcon)
</pre>

<p>
最後に、`~custom要素~構築子$自身を利用することもできる。
すなわち、上の~codeは次に等価になる：
◎
Finally, we can also use the custom element constructor itself. That is, the above code is equivalent to:
</p>


<pre>
const %flagIcon = new FlagIcon()
%flagIcon.country = "jp"
document.body.appendChild(%flagIcon)
</pre>

  


			</section>
			<section id="custom-elements-customized-builtin-example">
<h4 title="Creating a customized built-in element">4.13.1.2. ~custom化された組込みの要素の作成法</h4>

~INFORMATIVE


<p>
`~custom化された組込みの要素$は、別種の`~custom要素$であり，その定義は少しばかり異なる。
また、その利用は，`自律的~custom要素$に比較してかなり異なる。
それは、既存の~HTML要素の挙動を，新たな~custom機能性で拡張して，再利用できるようにするものである。
この再利用は重要になる
— あいにく、~HTML要素の既存の挙動の多くは，純粋に`自律的~custom要素$だけでは~~再現できないので。
代わりに，`~custom化された組込みの要素$では、［
構築~時に~customな挙動を~installすること,
~lifecycle~hook,<!-- ＊ -->
既存の要素への~prototype~chain
］が許容され、本質的に，これらの能力を既存の要素の上層に “mix-in” する。
◎
Customized built-in elements are a distinct kind of custom element, which are defined slightly differently and used very differently compared to autonomous custom elements. They exist to allow reuse of behaviours from the existing elements of HTML, by extending those elements with new custom functionality. This is important since many of the existing behaviours of HTML elements can unfortunately not be duplicated by using purely autonomous custom elements. Instead, customized built-in elements allow the installation of custom construction behaviour, lifecycle hooks, and prototype chain onto existing elements, essentially "mixing in" these capabilities on top of the already-existing element.
</p>


<p>
`~custom化された組込みの要素$には、`自律的~custom要素$とは別個の構文が要求される
— ~UAや他の~softwareは、要素の局所~名で，当の要素の意味論と挙動を識別しているので。
すなわち、既存の挙動の上層に，`~custom化された組込みの要素$の概念を築くためには、拡張元の要素が自身の元の局所~名を保ち続けることが不可欠になる。
◎
Customized built-in elements require a distinct syntax from autonomous custom elements because user agents and other software key off an element's local name in order to identify the element's semantics and behaviour. That is, the concept of customized built-in elements building on top of existing behaviour depends crucially on the extended elements retaining their original local name.
</p>


<p>
次の例では、 `plastic-button^jc という名前の`~custom化された組込みの要素$を作成する。
それは，通常の~buttonの様に挙動するが、~click時には気の利いた~animation効果が追加される。
前と同様，~classを定義する所から始めるが、今度は， `HTMLElement$I でなく `HTMLButtonElement$I を拡張する：
◎
In this example, we'll be creating a customized built-in element named plastic-button, which behaves like a normal button but gets fancy animation effects added whenever you click on it. We start by defining a class, just like before, although this time we extend HTMLButtonElement instead of HTMLElement:
</p>


<pre>
class PlasticButton extends HTMLButtonElement {
  constructor() {
    super();

    this.addEventListener("click", () =&gt; {
      /* <span class="comment">
何か気の利いた~animation効果を描く
◎
Draw some fancy animation effects!
</span> */
    });
  }
}</pre>


<p>
上のような~custom要素を定義するときには、
`extends^jc ~optionも指定する必要がある：
◎
When defining our custom element, we have to also specify the extends option:
</p>


<pre>
`customElements$m.define("plastic-button", PlasticButton, { extends: "button" });
</pre>


<p>
一般に，どの名前の要素を拡張しているかは、どの要素~interfaceを拡張しているか見るだけでは決定できない。
多くの要素は、同じ~interfaceを共有しているので（例えば、
`q$e と `blockquote$e は `HTMLQuoteElement$I を共有している）。
◎
In general, the name of the element being extended cannot be determined simply by looking at what element interface it extends, as many elements share the same interface (such as q and blockquote both sharing HTMLQuoteElement).
</p>


<p>
なので，`~custom化された組込みの要素$を利用するためには、
`button$e 要素~上の `is$a 属性を利用する：
◎
To use our customized built-in element, we use the is attribute on a button element:
</p>


<pre>
&lt;button `is$a="plastic-button"&gt;Click Me!&lt;/button&gt;
</pre>


<p>
`~custom化された組込みの要素$を`自律的~custom要素$として利用しようと試行しても、<em>働かない</em>。
すなわち、
`&lt;plastic-button&gt;Click me?&lt;/plastic-button&gt;^s
は、
単純に
特別な挙動を何も伴わない `HTMLElement$I を作成することになる。
◎
Trying to use a customized built-in element as an autonomous custom element will not work; that is, &lt;plastic-button&gt;Click me?&lt;/plastic-button&gt; will simply create an HTMLElement with no special behaviour.
</p>

<p>
型~拡張された要素を~program的に作成する必要がある場合、次の形による `createElement()$m を利用できる：
◎
If you need to create a type-extended element programmatically, you can use the following form of createElement():
</p>

<pre>
const %plasticButton = document.createElement("button", { is: "plastic-button" });
%plasticButton.textContent = "Click me!";</pre>

<p>
前のように，構築子も働くことになる：
◎
And as before, the constructor will also work:
</p>

<pre>
const %plasticButton2 = new PlasticButton();
console.log(%plasticButton2.localName);          /* <span class="comment">
`button^l と出力される
◎
will output "button"
</span> */
console.log(%plasticButton2.getAttribute("is")); /* <span class="comment">
`plastic-button^l と出力される
◎
will output "plastic-button"
</span> */
</pre>

<p>
特筆すべき点として、 `button$e に備わる特別なふるまい
— その ~focus挙動, `~form送信0$に関与する能, `disabled$a 属性, 等々 —
すべては，この種の “plastic ~button” にも適用される。
◎
Notably, all the of the ways in which button is special apply to such "plastic buttons" as well: their focus behaviour, ability to participate in form submission, the disabled attribute, and so on.
</p>

  


			</section>
			<section id="custom-elements-autonomous-drawbacks">
<h4 title="Drawbacks of autonomous custom elements">4.13.1.3. 自律的~custom要素の欠点</h4>

~INFORMATIVE

<p>
下に指定されるように，および上に示唆されたように、単純に `taco-button^e と称される要素を定義した上で利用しても，その種の要素が~buttonを`表現-$することにはならない。
すなわち、［
~Web~browser, 検索engine, ~accessibility技術
］などの~toolは、結果の要素を，単に定義された名前に基づいて自動的に~buttonとして扱うわけではない。
◎
As specified below, and alluded to above, simply defining and using an element called taco-button does not mean that such elements represent buttons. That is, tools such as Web browsers, search engines, or accessibility technology will not automatically treat the resulting element as a button just based on its defined name.
</p>

<p>
`自律的~custom要素$を利用しつつ，［
様々な利用者から欲される，~buttonの意味論
］を伝達するためには、いくつかの技法を使役する必要がある：
◎
To convey the desired button semantics to a variety of users, while still using an autonomous custom element, a number of techniques would need to be employed:
</p>

<ul>
	<li>
`tabindex$a 属性を追加すれば、
`taco-button^e を`対話的~内容$にし，その結果，要素は`~focus可能$になる。
この場合、 `taco-button^e が論理的に不能化されたときには， `tabindex$a 属性も除去する必要があることに注意。
◎
The addition of the tabindex attribute would make the taco-button interactive content, thus making it focusable. Note that if the taco-button were to become logically disabled, the tabindex attribute would need to be removed.
</li>
	<li>
種々の ARIA 属性を追加すれば、意味論を~accessibility技術に伝達する一助になる。
例えば、 `role$a 属性を `button$l に設定すれば、
“要素は~buttonである”
という意味論を伝達することになり、利用者は自身の~accessibility技術の下で，通例の~buttonの様に，その~controlとやりとり可能になる。
また， `aria-label$a 属性を設定して、当の~buttonに`~access可能な名前$を与えることも必要とされる
— さもなければ、~accessibility技術は，子~text~nodeを走査して，それらを発声することになる。
また，~buttonが論理的に不能化されたときには、 `aria-disabled$a を `true^l に設定すれば，その状態は~accessibility技術へ伝達される。
◎
The addition of various ARIA attributes helps convey semantics to accessibility technology. For example, setting the role attribute to "button" will convey the semantics that this is a button, enabling users to successfully interact with the control using usual button-like interactions in their accessibility technology. Setting the aria-label attribute is necessary to give the button an accessible name, instead of having accessibility technology traverse its child text nodes and announce them. And setting aria-disabled to "true" when the button is logically disabled conveys to accessibility technology the button's disabled state.
</li>
	<li>
~buttonに共通的に期待される挙動を取扱うために ~event~handlerを追加することも、
~Web~browser利用者に~buttonの意味論を伝達する一助になる。
この事例で最も関連する~event~handlerは、適切な `keydown$et ~eventを代理して， `click$et ~event化するものになるであろう
— そうすれば、~buttonは，~keyboardでも~clickでも作動化できるようになるので。
◎
The addition of event handlers to handle commonly-expected button behaviours helps convey the semantics of the button to Web browser users. In this case, the most relevant event handler would be one that proxies appropriate keydown events to become click events, so that you can activate the button both with keyboard and by clicking.
</li>
	<li>
既定で提供される視覚的~stylingの他に、 `taco-button^e 要素は，［
不能化されるなどの，論理的な状態~変化
］を反映するときにも更新される必要がある。
すなわち、 `taco-button^e に対する~stylesheet規則が何であれ，
`taco-button[disabled]^css に対する規則も必要になる。
◎
In addition to any default visual styling provided for taco-button elements, the visual styling will also need to be updated to reflect changes in logical state, such as becoming disabled; that is, whatever stylesheet has rules for taco-button will also need to have rules for taco-button[disabled].
</li></ul>

<p>
これらの点を念頭に、~buttonの意味論を伝達する責を負う，全装備の `taco-button^e （不能化させる能も含む）は、次の様な~~形をとるであろう：
◎
With these points in mind, a full-featured taco-button that took on the responsibility of conveying button semantics (including the ability to be disabled) might look something like this:
</p>

<pre>
class TacoButton extends HTMLElement {
  static get observedAttributes() { return ["disabled"]; }

  constructor() {
    super();

    this.addEventListener("keydown", %e =&gt; {
      if (%e.keyCode === 32 || %e.keyCode === 13) {
        this.dispatchEvent(new MouseEvent("click", {
          bubbles: true,
          cancelable: true
        }));
      }
    });

    this.addEventListener("click", %e =&gt; {
      if (this.disabled) {
        %e.preventDefault();
        %e.stopPropagation();
      }
    });

    this._observer = new MutationObserver(() =&gt; {
      this.setAttribute("aria-label", this.textContent);
    });
  }

  connectedCallback() {
    this.setAttribute("role", "button");
    this.setAttribute("tabindex", "0");

    this._observer.observe(this, {
      childList: true,
      characterData: true,
      subtree: true
    });
  }

  disconnectedCallback() {
    this._observer.disconnect();
  }

  get disabled() {
    return this.hasAttribute("disabled");
  }

  set disabled(%v) {
    if (%v) {
      this.setAttribute("disabled", "");
    } else {
      this.removeAttribute("disabled");
    }
  }

  attributeChangedCallback() {
/* <span class="comment">
`observedAttributes^jc に因り
`disabled^a 属性に対してのみ~callされる
◎
only is called for the disabled attribute due to observedAttributes
</span> */
    if (this.disabled) {
      this.removeAttribute("tabindex");
      this.setAttribute("aria-disabled", "true");
    } else {
      this.setAttribute("tabindex", "0");
      this.setAttribute("aria-disabled", "false");
    }
  }
}</pre>

<p>
このそれなりに複雑な要素~定義をもってしても、要素は，消費者にとって利用するのは楽でない：
それは、そいつの意志で `tabindex$a や `aria-*$a 属性を
“不断に生やし続ける”
ことになる。
このことは、今の所~custom要素に対しては、既定の［
~accessibility意味論や, ~focus時の挙動
］を指定する仕方がなく、そうするためには，（それらは，通例的には、消費者が既定の挙動を上書きするために予約されているが）これらの属性の利用を強いられるからである。
◎
Even with this rather-complicated element definition, the element is not a pleasure to use for consumers: it will be continually "sprouting" tabindex and aria-* attributes of its own volition. This is because as of now there is no way to specify default accessibility semantics or focus behaviour for custom elements, forcing the use of these attributes to do so (even though they are usually reserved for allowing the consumer to override default behaviour).
</p>

<p>
対照的に，前~節に示した，単純な`~custom化された組込みの要素$は、
`button$e 要素の意味論と挙動を自動的に継承することになり、これらの挙動を手動で実装する必要はない。
一般に、［
自明でない挙動と意味論を伴うような，~HTMLの既存の要素
］の上層に築かれる どの要素についても、`~custom化された組込みの要素$の方が［
開発する／維持管理する／消費する
］のは容易になる。
◎
In contrast, a simple customized built-in element, as shown in the previous section, would automatically inherit the semantics and behaviour of the button element, with no need to implement these behaviours manually. In general, for any elements with nontrivial behaviour and semantics that build on top of existing elements of HTML, customized built-in elements will be easier to develop, maintain, and consume.
</p>


			</section>
			<section id="custom-elements-upgrades-examples">
<h4 title="Upgrading elements after their creation">4.13.1.4. 要素の作成~後の昇格法</h4>

~INFORMATIVE

<p>
`要素~定義$は，いつでも生じさせ得る
— ~customでない要素が`作成-$された後，適切な`~custom要素~定義$を登録した後に、それを`~custom要素$にすることもできる。
この処理-は、通常の要素から~custom要素への “昇格処理” と呼ばれる。
◎
Because element definition can occur at any time, a non-custom element could be created, and then later become a custom element after an appropriate definition is registered. We call this process "upgrading" the element, from a normal element into a custom element.
</p>

<p>
構文解析器などにより，関連する要素が初期~時に作成された後、`~custom要素~定義$を登録する方が好ましいこともある。
`昇格$は、そのような~~用法を可能化し、~custom要素の内容を漸進的に増強できるようにする。
例えば、次の~HTML文書と `img-viewer^e に対する要素~定義は，非同期的に読込まれる：
◎
Upgrades enable scenarios where it may be preferable for custom element definitions to be registered after relevant elements has been initially created, such as by the parser. They allow progressive enhancement of the content in the custom element. For example, in the following HTML document the element definition for img-viewer is loaded asynchronously:
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;画像ビューアの例&lt;/title&gt;

&lt;img-viewer filter="Kelvin"&gt;
  &lt;img src="images/tree.jpg" alt="何もないサバンナにそびえる美しい~~木"&gt;
&lt;/img-viewer&gt;

&lt;script src="js/elements/img-viewer.js" async&gt;&lt;/script&gt;</pre>

<!-- 
Image viewer example
A beautiful tree towering over an empty savannah
 -->
<p>
ここでの `img-viewer^e 要素に対する定義は、~markup内の `&lt;img-viewer&gt;^s ~tagの後に置かれた， `async$a 属性~付きの `script$e 要素を利用して読込まれる。
~scriptを読込んでいる間、
`img-viewer^e 要素は， `span$e に似た未定義の要素として扱われることになる。
~scriptが読込まれ，それが `img-viewer^e 要素を定義したとき、頁~上の既存の `img-viewer^e 要素は，その~custom要素~定義が適用されて昇格されることになる（それは、文字列 `Kelvin^l で識別される画像~filterを適用して画像の視覚的な外観を増強することが~~想定されている）。
◎
The definition for the img-viewer element here is loaded using a script element marked with the async attribute, placed after the &lt;img-viewer&gt; tag in the markup. While the script is loading, the img-viewer element will be treated as an undefined element, similar to a span. Once the script loads, it will define the img-viewer element, and the existing img-viewer element on the page will be upgraded, applying the custom element's definition (which presumably includes applying an image filter identified by the string "Kelvin", enhancing the image's visual appearance).
</p>

<hr>

<p>
`昇格$が適用されるのは、文書~木~内（正式には，`~shadowも含む文書~内$）にある要素に限られることに注意。
文書に挿入されていない要素は、昇格されないままになる。
この点について例で~~説明すると：
◎
Note that upgrades only apply to elements in the document tree. (Formally, elements in a shadow-including document.) An element that is not inserted into a document will stay un-upgraded. An example illustrates this point:
</p>

<!-- 
Upgrade edge-cases example
-->
<pre>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;title&gt;昇格のきわどい事例&lt;/title&gt;

&lt;example-element&gt;&lt;/example-element&gt;

&lt;script&gt;
  "use strict";

  const %文書内 = document.querySelector("example-element");
  const %文書外 = document.createElement("example-element");

  /* <span class="comment">
要素~定義の前：
両者とも `HTMLElement^I ：
◎
Before the element definition, both are HTMLElement:
</span> */
  console.assert(%文書内 instanceof HTMLElement);
  console.assert(%文書外 instanceof HTMLElement);

  class ExampleElement extends HTMLElement {}
  `customElements$m.define("example-element", ExampleElement);

  /* <span class="comment">
要素~定義の後：
文書~内にあった方の要素は，この時点で昇格されている：
◎
After element definition, the in-document element was upgraded:
</span> */
  console.assert(%文書内 instanceof ExampleElement);
  console.assert(!(%文書外 instanceof ExampleElement));

  document.body.appendChild(%文書外);

  /* <span class="comment">
そうでない方の要素を文書の中に移動した後には，それも昇格される：
◎
Now that we've moved the element into the document, it too was upgraded:
</span> */
  console.assert(%文書外 instanceof ExampleElement);
&lt;/script&gt;
</pre>

  


		</section>
		<section id="custom-element-conformance">
<h3 title="Requirements for custom element constructors">4.13.2. ~custom要素の構築子に課される要件</h3>

<p>
`~custom要素~構築子$を著作する際には、作者には，次の適合性~要件が課される：
◎
When authoring custom element constructors, authors are bound by the following conformance requirements:
</p>

<ul>
	<li>
正しい~prototype~chain および <b>this</b> 値を確立するため、
`super()^jc に対する~parameterを伴わない~callは，他のすべての~codeが走る前
— 構築子の本体において最初の文 —
にされ~MUST。
◎
A parameter-less call to super() must be the first statement in the constructor body, to establish the correct prototype chain and this value before any further code is run.
</li>
	<li>
`return^jc 文は、単純な早期 return （ `return^jc ／ `return this^jc ）でない限り，構築子の本体に現れては~MUST_NOT。
◎
A return statement must not appear anywhere inside the constructor body, unless it is a simple early-return (return or return this).
</li>
	<li>
要素の どの［
属性／子
］であれ，検分されては~MUST_NOT
— `昇格$がない場合には何も無く、昇格に依拠することは，要素を利用し難いものにするので。
`？^tnote
◎
The element's attributes and children must not be inspected, as in the non-upgrade case none will be present, and relying on upgrades makes the element less usable.
</li>
	<li>
どの［
属性／子
］であれ，要素に持たせては~MUST_NOT
— それは、［
`createElement()$m ／ `createElementNS()$m
］~methodを用いる消費者の期待に違反するので。
◎
The element must not gain any attributes or children, as this violates the expectations of consumers who use the createElement or createElementNS methods.
</li>
	<li>
一般に、可能0な限り，仕事は
— とりわけ，資源の~fetchingや具現化を孕むものは —
`connectedCallback()^jc へ先送りされるべきである。
しかしながら， `connectedCallback()^jc は複数回~callされ得ることに注意
— 初期化を行うような~~真に一度限りの仕事は、重ねて走らないよう，防護する必要がある。
◎
In general, work should be deferred to connectedCallback as much as possible—especially work involving fetching resources or rendering. However, note that connectedCallback can be called more than once, so any initialization work that is truly one-time will need a guard to prevent it from running twice.
</li>
	<li>
一般に，構築子は、［
初期~状態や既定の値，あるいは~event~listener，場合によっては`~shadow根$
］を設定しておくために利用されるべきである。
◎
In general, the constructor should be used to set up initial state and default values, and to set up event listeners and possibly a shadow root.
</li></ul>

<p>
これらの要件のうちいくつかは、`要素を作成-$する間に
直接的／間接的
に検査される。
要件に従わない場合、~custom要素は，構文解析器や~DOM~APIにより~instance化できなくなる。
◎
Several of these requirements are checked during element creation, either directly or indirectly, and failing to follow them will result in a custom element that cannot be instantiated by the parser or DOM APIs.
</p>


			</section>
		</section>
		<section id="custom-elements-core-concepts">
<h3 title="Core concepts">4.13.3. 中核~概念</h3>

<p>
`~custom要素@
は、`~customである$要素である†。
これは，非公式に言えば、その構築子と~prototypeが，~UAに代わって 作者により定義されることを意味する。
この，作者により供給される構築子~関数は
`~custom要素~構築子@
と呼ばれる。
◎
A custom element is an element that is custom. Informally, this means that its constructor and prototype are defined by the author, instead of by the user agent. This author-supplied constructor function is called the custom element constructor.
</p>

<p class="trans-note">【†
すなわち，昇格される前は、まだ “~customでない”
】</p>

<p>
次の 2 つの別個の種別の，`~custom要素$を定義できる：
◎
Two distinct types of custom elements can be defined:
</p>

<ol>
	<li>
`自律的~custom要素@
は、 `extends^jc ~optionを伴わずに定義されるものである。
この種別の~custom要素の局所~名は、それに定義された`名前$cDに等しくなる。
◎
An autonomous custom element, which is defined with no extends option. These types of custom elements have a local name equal to their defined name.
</li>
	<li>
`~custom化された組込みの要素@
は、 `extends^jc ~optionを伴って定義されるものである。
この種別の~custom要素の局所~名は，その `extends^jc ~optionに渡される値に等しくなり、それに定義された`名前$cDは
`is@a
属性の値として利用される。
◎
A customized built-in element, which is defined with an extends option. These types of custom elements have local name equal to the value passed in their extends option, and their defined name is used as the value of the is attribute.
</li>

</ol>

<p>
`~custom要素$が`作成-$された後に
`is$a 属性の値を変更しても，要素の挙動は変化しない。
◎
After a custom element is created, changing the value of the is attribute does not change the element's behaviour.
</p>

<p>
`自律的~custom要素$の
<a href="~HTMLDOM#element-definitions">要素~定義</a>
は、次で与えられる：
◎
Autonomous custom elements have the following element definition:
</p>

<dl class="element-def">
	<dt>`分類$：</dt>
	<dd>
`~flow内容$／`句内容$／`~palpable内容$
◎
Flow content.
◎
Phrasing content.
◎
Palpable content.
</dd>
	<dt>`この要素を利用できる文脈$：</dt>
	<dd>
`句内容$が期待される所。
◎
Where phrasing content is expected.
</dd>

	<dt>`内容~model$：</dt>
	<dd>
`透過的$。
◎
Transparent.
</dd>
	<dt>`内容~属性$：</dt>
	<dd>
`大域~属性$
— ただし、 `is$a 属性は除く。
◎
Global attributes, except the is attribute
</dd>
	<dd>
他の，どの名前空間にも属さない任意の属性（注釈文を見よ）。
◎
Any other attribute that has no namespace (see prose).
</dd>
	<dt>`~DOM~interface$：</dt>
	<dd>
要素の作者により供給される（ `HTMLElement$I を継承する）。
◎
Supplied by the element's author (inherits from HTMLElement)
</dd></dl>


<p>
`自律的~custom要素$は、特別な意味を有さず，その子たちを`表現-$する。
`~custom化された組込みの要素$は、それが拡張する要素の意味論を継承する。
◎
An autonomous custom element does not have any special meaning: it represents its children. A customized built-in element inherits the semantics of the element that it extends.
</p>

<div class="p">
<p>
作者は、`自律的~custom要素$に，その機能に関連するものと決定した任意の属性を指定できる
— その属性が次を満たす限り：
</p>

<ul><li>どの名前空間にも属さない。
</li><li>その名前は、`~XML互換$, かつ`~ASCII大文字$を包含しない。
</li></ul>

<p>
ただし例外として、
`is$a 属性は，`自律的~custom要素$に指定されては~MUST_NOT（また、指定されても効果はない）。
</p>
◎
Any namespace-less attribute that is relevant to the element's functioning, as determined by the element's author, may be specified on an autonomous custom element, so long as the attribute name is XML-compatible and contains no uppercase ASCII letters. The exception is the is attribute, which must not be specified on an autonomous custom element (and which will have no effect if it is).
</div>

<p>
`~custom化された組込みの要素$の属性は、それが拡張する要素に基づく通常の要件に従う。
~custom属性に基づく挙動を追加するためには、 `data-*$a 属性を利用する。
◎
Customized built-in elements follow the normal requirements for attributes, based on the elements they extend. To add custom attribute-based behavior, use data-* attributes.
</p>

<hr>

<p>
`妥当な~custom要素~名@
は、次の両~要件を満たす文字~並びである：
◎
A valid custom element name is a sequence of characters name that meets all of the following requirements:
</p>

<ul>
	<li>
<p>
`PotentialCustomElementName$P 生成規則に合致し~MUST：
◎
name must match the PotentialCustomElementName production:
</p>

<dl>
	<dt><code class="ABNF">`PotentialCustomElementName@P ::=</code></dt>
	<dd>
<code class="ABNF">[a-z] (`PCENChar$P)* '-' (`PCENChar$P)*</code>
</dd>

	<dt><code class="ABNF">`PCENChar@P ::=</code></dt>
	<dd><code class="ABNF">
"-" | "." | [0-9] | "_" | [a-z] | #xB7
| [#xC0-#xD6]     | [#xD8-#xF6]     | [#xF8-#x37D]
| [#x37F-#x1FFF]  | [#x200C-#x200D] | [#x203F-#x2040]
| [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF]
| [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
</code></dd>
</dl>

<p>
この生成規則は、 `XML$r 仕様の `EBNF 記法$を利用している。
◎
This uses the EBNF notation from the XML specification. [XML]
</p>
   </li>
	<li>
<p>
次のいずれにも該当しては~MUST_NOT：
◎
name must not be any of the following:
</p>

<ul ><li>`annotation-xml^l
</li><li>`color-profile^l
</li><li>`font-face^l
</li><li>`font-face-src^l
</li><li>`font-face-uri^l
</li><li>`font-face-format^l
</li><li>`font-face-name^l
</li><li>`missing-glyph^l
</li></ul>

<p class="note">注記：
上に挙げた名前は、`適用し得る仕様$
— すなわちここでは `SVG$r, `MATHML$r —
に定義される要素のうち，~hyphenを包含するものすべてを要約したものである。
◎
The list of names above is the summary of all hyphen-containing element names from the applicable specifications, namely SVG and MathML. [SVG] [MATHML]
</p>
</li>
</ul>


<div class="note">
<p>注記：
これらの要件は、`妥当な~custom要素~名$に求められる いくつかの目標を確保するためにある：
◎
These requirements ensure a number of goals for valid custom element names:
</p>

<ul>
	<li>
`~ASCII小文字$から始まる
— ~HTML構文解析器が，それを~textではなく~tagとして扱うことを確保するため。
◎
They start with a lowercase ASCII letter, ensuring that the HTML parser will treat them as tags instead of as text.
</li>
	<li>
`~ASCII大文字$は一切~包含しない
— ~UAが ~HTML要素を 常に ~ASCII文字大小無視に扱えることを確保するため。
◎
They do not contain any uppercase ASCII letters, ensuring that the user agent can always treat HTML elements ASCII-case-insensitively.
</li>
	<li>
~hyphenを包含する
— 名前空間付けの利用，および 前方互換性を確保するため（将来において、~hyphenを包含するような局所~名を伴う要素が
~HTML, ~SVG, ~MathML
に追加されることはないので）。
◎
They contain a hyphen, used for namespacing and to ensure forward compatibility (since no elements will be added to HTML, SVG, or MathML with hyphen-containing local names in the future).
</li>
	<li>
構文解析器による制約を超えるそれがある
`createElement()$m ／ `createElementNS()$m
でも，常に作成できるようにする。
◎
They can always be created with createElement() and createElementNS(), which have restrictions that go beyond the parser's.
</li></ul>

<p>
これらの制約は別として、可能な限り柔軟にするため，多様な名前が許容される
— `&lt;math-α&gt;^s や `&lt;emotion-😍&gt;^s
の様な利用~事例のために。
◎
Apart from these restrictions, a large variety of names is allowed, to give maximum flexibility for use cases like &lt;math-α&gt; or &lt;emotion-😍&gt;.
</p>
  </div>

<p>
`~custom要素~定義@
は、`~custom要素$を記述し，次のものからなる：
◎
A custom element definition describes a custom element and consists of:
</p>

<dl class="def-list">
	<dt>`名前@cD
◎
A name
</dt>
  	<dd>
`妥当な~custom要素~名$
◎
A valid custom element name
</dd>

	<dt>
`局所~名@cD
◎
A local name
</dt>
  	<dd>
局所~名
◎
A local name
</dd>

	<dt>
`構築子@cD
◎
A constructor
</dt>
  	<dd>
`~custom要素~構築子$
◎
A custom element constructor
</dd>
	<dt>
`~prototype@cD
◎
A prototype
</dt>
  	<dd>
~JS~obj
◎
A JavaScript object
</dd>
	<dt>
`観測ed属性~list@cD
◎
A list of observed attributes
</dt>
  	<dd>
`sequence&lt;DOMString&gt;^jc 型~値
◎
A sequence&lt;DOMString&gt;
</dd>
	<dd class="trans-note">【
観測-対象にする内容~属性たちの名前を~~保持する。
】</dd>

	<dt>
`~lifecycle~callback~map@cD
◎
A collection of lifecycle callbacks
</dt>
	  <dd>
3 個の~key
—
`connectedCallback^l,
`disconnectedCallback^l,
`attributeChangedCallback^l
—
を有する~map。
いずれも、［
~JS関数~obj, `undefined^js （既定~値）
］のいずれかを値にとる。
◎
A map, whose three keys are the strings "connectedCallback", "disconnectedCallback", and "attributeChangedCallback". The corresponding values are either a JavaScript function object, or undefined. By default the value of each entry is undefined.
</dd>
	<dd class="trans-note">【
順に、［
`接続-時$, `切断-時$, 属性~変更-時
］に呼ばれる~callback。
】</dd>

	<dt>
`構築~stack@cD
◎
A construction stack
</dt>
  	<dd>
初期~時は空~list。
この~listは、`要素を昇格$する~algo, および
`HTMLElement()$m 構築子により操作される。
~list内の各~entryは、要素, または
`すでに構築済みを表す~marker@
のいずれかになる。
◎
A list, initially empty, that is manipulated by the upgrade an element algorithm and the HTMLElement constructor. Each entry in the list will be either an element or an already constructed marker.
</dd>

</dl>

<p>
`~custom要素~定義を検索-@
する手続きは、所与の
( %文書, %名前空間, %局所~名, %is )
に対し［
`~custom要素~定義$, ~NULL
］のいずれかを返す：
◎
To look up a custom element definition, given a document, namespace, localName, and is, perform the following steps. They will return either a custom element definition or null:
</p>

<ol>
	<li>
~IF［
%名前空間 ~NEQ `~HTML名前空間$
］
⇒
~RET ~NULL
◎
If namespace is not the HTML namespace, return null.
</li>
	<li>
~IF［
%文書 が`属する閲覧文脈$はない
］
⇒
~RET ~NULL
◎
If document does not have a browsing context, return null.
</li>
	<li>
%~registry ~LET
%文書 に`結付けられている~Window$の `CustomElementsRegistry$I ~obj
◎
Let registry be document's associated Window's CustomElementsRegistry object.
</li>
	<li>
~IF［
%~registry 内に［
( `名前$cD, `局所~名$cD ) ~EQ ( %局所~名, %局所~名 )
］なる`~custom要素~定義$はある
］
⇒
~RET その`~custom要素~定義$
◎
If there is custom element definition in registry with name and local name both equal to localName, return that custom element definition.
</li>
	<li>
~IF［
%~registry 内に［
( `名前$cD, `局所~名$cD ) ~EQ ( %is, %局所~名 )
］なる`~custom要素~定義$はある
⇒
~RET その`~custom要素~定義$
◎
If there is a custom element definition in registry with name equal to is and local name equal to localName, return that custom element definition.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>

</ol>


		</section>
		<section id="custom-elements-api">
<h3 title="The CustomElementsRegistry interface">4.13.4. `CustomElementsRegistry^I ~interface</h3>

<p>
各 `Window$I ~objの作成-時には、一意な `CustomElementsRegistry$I ~objの~instanceが結付けられる。
◎
Each Window object is associated with a unique instance of a CustomElementsRegistry object, allocated when the Window object is created.
</p>

<p class="note">注記：
~custom要素~registryが結付けられるのは，
`Document$I ~objではなく， `Window$I ~objである
— 各 `~custom要素~構築子$は `HTMLElement$I ~interfaceを継承し，
`HTMLElement$I ~interfaceは `Window$I ~objごとに正確に 1 個あるので。
◎
Custom element registries are associated with Window objects, instead of Document objects, since each custom element constructor inherits from the HTMLElement interface, and there is exactly one HTMLElement interface per Window object.
</p>

<p>
`Window$I ~interfaceの
`customElements@m
属性は、その `Window$I ~objに対する `CustomElementsRegistry$I ~objを返さ~MUST。
◎
The customElements attribute of the Window interface must return the CustomElementsRegistry object for that Window object.
</p>

<pre class="idl">
interface `CustomElementsRegistry@I {
  void `define$m(
       DOMString %name,
       Function %constructor,
       optional `ElementDefinitionOptions$I %options
  );
  any `get$m(DOMString name);
  [NewObject] Promise&lt;void&gt; `whenDefined$m(DOMString %name);
};

dictionary `ElementDefinitionOptions@I {
  DOMString `extends^m;
};</pre>

<p>
各 `CustomElementsRegistry$I は、初期~時には空の，`~custom要素~定義$の集合を持つ。
一般に、この仕様の各種~algoは、~registry内の要素を［
`名前$cD, `局所~名$cD, `構築子$cD
］で検索する。
◎
Every CustomElementsRegistry has a set of custom element definitions, initially empty. In general, algorithms in this specification look up elements in the registry by any of name, local name, or constructor.
</p>

<p>
各 `CustomElementsRegistry$I は、
`定義済時~promise~map@
も持つ。
それは、`妥当な~custom要素~名$から~promise~listへの対応付けを与え、
`whenDefined()$m ~methodを実装するために利用される。
`定義済時~promise~map$内に格納される~promiseへは、強い参照が作成されては~MUST_NOT。
◎
Every CustomElementsRegistry also has a when-defined promise map, mapping valid custom element names to lists of promises. It is used to implement the whenDefined() method. Storing a promise in the when-defined promise map must not create a strong reference to that promise.
</p>

<p class="trans-note">【
これらの~promiseは、`定義済み$になったとき`解決-$される。
】</p>


<dl class="domintro">
	<dt>%window . `customElements$m . `define(name, constructor)$m</dt>
	<dd>
`名前$cD %name の新たな`~custom要素$
— `自律的~custom要素$ —
を定義する。
%constructor が その構築子を与え、
%name はその構築子に対応付けられる。
◎
Defines a new custom element, mapping the given name to the given constructor as an autonomous custom element.
</dd>

	<dt>%window . `customElements$m . `define$m(%name, %constructor, { extends: %baseLocalName })</dt>
  	<dd>
`名前$cD %name の新たな`~custom要素$
— `~custom化された組込みの要素$ —
を定義する。
%constructor が その構築子を与え、
%name はその構築子に対応付けられる。
拡張される`要素~型$は、 %baseLocalName 値で識別される。
［
`~custom要素$／未知の要素
］を拡張しようと試行した場合、
`NotSupportedError$E が投出される。
◎
Defines a new custom element, mapping the given name to the given constructor as a customized built-in element for the element type identified by the supplied baseLocalName. A NotSupportedError will be thrown upon trying to extend a custom element or an unknown element.
</dd>

	<dt>%window . `customElements$m . `get(name)$m</dt>
	<dd>
所与の`名前$cD（ %name ）に対し定義されている`~custom要素~構築子$を検索取得する。
そのような`~custom要素~定義$が見つからない場合は、 `undefined^js を返す。
◎
Retrieves the custom element constructor defined for the given name. Returns undefined if there is no custom element definition with the given name.
</dd>

	<dt>%window . `customElements$m . `whenDefined(name)$m</dt>
  	<dd>
所与の`名前$cD（ %name ）の`~custom要素$が`定義済み$になったとき充足されることになる，~promiseを返す（すでに定義済みであれば、充足-済みの~promiseが即時に返されることになる）。
%name が`妥当な~custom要素~名$でない場合、
`SyntaxError$E で`却下された~promise$を返す。
◎
Returns a promise that will be fulfilled when a custom element becomes defined with the given name. (If such a custom element is already defined, the returned promise will be immediately fulfilled.) Returns a promise rejected with a SyntaxError if not given a valid custom element name.
</dd>

</dl>

<p>
`要素~定義@
は、`~custom要素~定義$を `CustomElementsRegistry$I に追加する処理-である。
これは、 `define()$m ~methodにより達成される。
◎
Element definition is a process of adding a custom element definition to the CustomElementsRegistry. This is accomplished by the define() method. When invoked, the define(name, constructor, options) method must run these steps:
</p>


<p>
`define(name, constructor, options)@m
の~methodの被呼出時には、次の手続きを走らせ~MUST：
◎
↑</p>

<ol>
	<li>
~IF［
`IsConstructor$jA( %constructor ) ~EQ ~F
］
⇒
~THROW `TypeError$E
◎
If IsConstructor(constructor) is false, then throw a TypeError exception and abort these steps.
</li>
	<li>
~IF［
%name は`妥当な~custom要素~名$でない
］
⇒
~THROW `SyntaxError$E
◎
If name is not a valid custom element name, then throw a "SyntaxError" DOMException and abort these steps.
</li>
	<li>
~IF［
此れ内に［
`名前$cD ~EQ %name
］なる~entryがある
］
⇒
~THROW `NotSupportedError$E
◎
If this CustomElementsRegistry contains an entry with name name, then throw a "NotSupportedError" DOMException and abort these steps.
</li>
	<li>
~IF［
此れ内に［
`構築子$cD ~EQ %constructor
］なる~entryがある
］
⇒
~THROW `NotSupportedError$E
◎
If this CustomElementsRegistry contains an entry with constructor constructor, then throw a "NotSupportedError" DOMException and abort these steps.
</li>
	<li>
%局所~名 ~LET %name
◎
Let localName be name.
</li>
	<li>
%extends ~LET %options に `extends^jc ~memberが［
あれば その値 ／
なければ ~NULL
］
◎
Let extends be the value of the extends member of options, or null if no such member exists.
</li>
	<li>
<p>
~IF［
%extends ~NEQ ~NULL
］：
◎
If extends is not null, then:
</p>
		<ol>
			<li>
~IF［
%extends は`妥当な~custom要素~名$である
］
⇒
~THROW `NotSupportedError$E
◎
If extends is a valid custom element name, then throw a "NotSupportedError" DOMException.
</li>
			<li>
~IF［
( %extends, `~HTML名前空間$ )
に対する`要素~interface$ ~EQ `HTMLUnknownElement$I
（例えば， %extends がこの仕様~内の要素~定義を指示していないとき）
］
⇒
~THROW `NotSupportedError$E
◎
If the element interface for extends and the HTML namespace is HTMLUnknownElement (e.g., if extends does not indicate an element definition in this specification), then throw a "NotSupportedError" DOMException.
</li>
			<li>
%局所~名 ~SET %extends
◎
Set localName to extends.
</li>
		</ol>
	</li>
	<li>
%観測ed属性~iterable ~LET `Get$jA( %constructor, `observedAttributes^l )
（例外投出あり）
◎
Let observedAttributesIterable be Get(constructor, "observedAttributes"). Rethrow any exceptions.
</li>
	<li>
%観測ed属性~list ~LET ［
%観測ed属性~iterable ~EQ `undefined^js ならば
空の `sequence&lt;DOMString&gt;^jc 型~値／
~ELSE_ %観測ed属性~iterable を `sequence&lt;DOMString&gt;^jc 型`値に変換-$した結果
］
（例外投出あり）
◎
If observedAttributesIterable is undefined, then let observedAttributes be an empty sequence&lt;DOMString&gt;. Otherwise, let observedAttributes be the result of converting observedAttributesIterable to a sequence&lt;DOMString&gt;. Rethrow any exceptions.
</li>
	<li>
%~prototype ~LET
`Get$jA( %constructor, `prototype^l)
（例外投出あり）
◎
Let prototype be Get(constructor, "prototype"). Rethrow any exceptions.
</li>
	<li>
~IF［
`Type$jA( %~prototype ) ~NEQ `Object^js
］
⇒
~THROW `TypeError$E
◎
If Type(prototype) is not Object, then throw a TypeError exception.
</li>
	<li>
%接続-時~callback ~LET 
`Get$jA( %~prototype, `connectedCallback^l)
（例外投出あり）
◎
Let connectedCallback be Get(prototype, "connectedCallback"). Rethrow any exceptions.
</li>
	<li>
~IF［
%接続-時~callback ~NEQ `undefined^js
］~AND［
`IsCallable$jA( %接続-時~callback ) ~EQ ~F
］
⇒
~THROW `TypeError$E
◎
If connectedCallback is not undefined, and IsCallable(connectedCallback) is false, then throw a TypeError exception.
</li>
	<li>
%切断-時~callback ~LET
`Get$jA( %~prototype, `disconnectedCallback^l )
（例外投出あり）
◎
Let disconnectedCallback be Get(prototype, "disconnectedCallback"). Rethrow any exceptions.
</li>
	<li>
~IF［
%切断-時~callback ~NEQ `undefined^js
］~AND［
`IsCallable$jA( %切断-時~callback ) ~EQ ~F
］
⇒
~THROW `TypeError$E
◎
If disconnectedCallback is not undefined, and IsCallable(disconnectedCallback) is false, then throw a TypeError exception.
</li>
	<li>
%属性~変更-時~callback ~LET
`Get$jA( %~prototype, `attributeChangedCallback^l)
（例外投出あり）
◎
Let attributeChangedCallback be Get(prototype, "attributeChangedCallback"). Rethrow any exceptions.
</li>
	<li>
~IF［
%属性~変更-時~callback ~NEQ `undefined^js
］~AND［
`IsCallable$jA( %属性~変更-時~callback ) ~EQ ~F
］
⇒
~THROW `TypeError$E
◎
If attributeChangedCallback is not undefined, and IsCallable(attributeChangedCallback) is false, then throw a TypeError exception.
</li>
	<li>
<p>
%定義 ~LET 次のようにされた，新たな `~custom要素~定義$：
</p>

<ul ><li>`名前$cD ~SET %name
</li><li>`局所~名$cD ~SET %局所~名
</li><li>`構築子$cD ~SET %constructor
</li><li>`~prototype$cD ~SET %~prototype
</li><li>`観測ed属性~list$cD ~SET %観測ed属性~list
</li><li>
<p>
`~lifecycle~callback~map$cD ~SET 次の［
~key: 値
］からなる新たな~map：
</p>
	<ul ><li>`connectedCallback^jc: %接続-時~callback
	</li><li>`disconnectedCallback^jc: %切断-時~callback
	</li><li>`attributeChangedCallback^jc: %属性~変更-時~callback
	</li></ul>
</li></ul>

◎
Let definition be a new custom element definition with name name, local name localName, constructor constructor, prototype prototype, observed attributes observedAttributes, and lifecycle callbacks connectedCallback, disconnectedCallback, and attributeChangedCallback (stored by their corresponding name).
</li>
	<li>
此れに %定義 を追加する
◎
Add definition to this CustomElementsRegistry.
</li>
	<li>
<p>
~IF［
此れの`定義済時~promise~map$内に［
~key ~EQ  %name
］なる~entryがある
］：
◎
If this CustomElementsRegistry's when-defined promise map contains an entry with key name:
</p>

		<ol>
			<li>
%~promise~list ~LET その~entryの値
◎
Let promiseList be the value of that entry.
</li>
			<li>
~FOR
%~promise~list 内の ~EACH ( %~promise ) に対し
⇒
`undefined^js で %~promise を`解決-$する
◎
For each promise in promiseList, resolve promise with undefined.
</li>
			<li>
此れの`定義済時~promise~map$から［
~key ~EQ %name
］なる~entryを削除する
◎
Delete the entry with key name from this CustomElementsRegistry's when-defined promise map.
</li>
		</ol>
	</li>
</ol>

<p>
`get(name)@m ~methodの被呼出時には、次の手続きを走らせ~MUST：
◎
When invoked, the get(name) method must run these steps:
</p>

<ol>
	<li>
~IF［
此れ内に［
`名前$cD ~EQ %name
］なる~entryがある
］
⇒
~RET その~entryの`構築子$cD
◎
If this CustomElementsRegistry contains an entry with name name, then return that entry's constructor.
</li>
	<li>
~RET `undefined^js
◎
Otherwise, return undefined.
</li>
</ol>

<p>
`whenDefined(name)@m
~methodの被呼出時には、次の手続きを走らせ~MUST：
◎
When invoked, the whenDefined(name) method must run these steps:
</p>

  <ol>
	<li>
~IF［
%name は`妥当な~custom要素~名$でない
］
⇒
~RET
`SyntaxError$E 例外で`却下された新たな~promise$
◎
If name is not a valid custom element name, then return a new promise rejected with a SyntaxError exception and abort these steps.
</li>
	<li>
~IF［
此れ内に［
`名前$cD ~EQ %name
］なる~entryがある
］
⇒
~RET `undefined^js で`解決された新たな~promise$
◎
If this CustomElementsRegistry contains an entry with name name, then return a new promise resolved with undefined and abort these steps.
</li>
	<li>
%~map ~LET 此れの`定義済時~promise~map$
◎
Let map be this CustomElementsRegistry's when-defined promise map.
</li>
	<li>
~IF［
%~map 内に［
~key ~EQ %name
］なる~entryはない
］
⇒
%~map 内に［
(~key, 値 ) ~SET ( %name, 空~list )
］にされた~entryを作成する
◎
If map does not contain an entry with key name, create an entry in map with key name and whose value is an empty list.
</li>
	<li>
%~promise~list ~LET 
%~map 内の［
~key ~EQ %name
］なる~entryの値
◎
Let promiseList be the value of the entry in map with key name.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
↓</li>
	<li>
%~promise~list に %~promise を付加する
◎
Let promise be a new promise, and append promise to promiseList.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>

</ol>

<div class="example">
<p>
`whenDefined()$m
~methodは、適切な`~custom要素$がすべて`定義済み$になるまで、動作が遂行されるのを避けるために利用できる。
この例では、 `defined$ps 擬似類と組合せて，利用する`自律的~custom要素$のすべてが定義済みになるまで、動的に読込まれる~articleの内容を隠す。
◎
The whenDefined() method can be used to avoid performing an action until all appropriate custom elements are defined. In this example, we combine it with the :defined pseudo-class to hide a dynamically-loaded article's contents until we're sure that all of the autonomous custom elements it uses are defined.
</p>


<pre>
%articleContainer.hidden = true;

fetch(%articleURL)
  .then(%response =&gt; %response.text())
  .then(%text =&gt; {
    %articleContainer.innerHTML = %text;

    return Promise.all(
      [...%articleContainer.querySelectorAll(":not(:defined)")]
        .map(%el =&gt; customElements.whenDefined(%el.localName))
    );
  })
  .then(() =&gt; {
    %articleContainer.hidden = false;
  });
</pre>

</div>

		</section>
		<section id="upgrades">
<h3 title="Upgrades">4.13.5. 昇格</h3>

<p>
`要素を昇格@
する手続きは、所与の
( `~custom要素~定義$ %定義, 要素 %要素 )
に対し，次を走らす：
◎
To upgrade an element, given as input a custom element definition definition and an element element, run the following steps:
</p>

<ol>
	<li>
%定義 の`構築~stack$cDの末尾に %要素 を追加する
◎
Add element to the end of definition's construction stack.
</li>
	<li>
%C ~LET %定義 の`構築子$cD
◎
Let C be definition's constructor.
</li>
	<li>
%構築-結果 ~LET `Construct$jA( %C )
◎
Let constructResult be Construct(C).
</li>
	<li>
%定義 の`構築~stack$cDの末尾から %要素 を除去する
◎
Remove element from the end of definition's construction stack.
</li>
	<li>
~IF［
%構築-結果 は中途完了である
］
⇒
~RET %構築-結果 （すなわち，例外は再投出される）。
◎
If constructResult is an abrupt completion, then return constructResult (i.e., rethrow the exception).
</li>
	<li>
<p>
~IF［
`SameValue$jA( %構築-結果 . [[value]], %要素 ) ~EQ ~F
］
⇒
~THROW `InvalidStateError$E
◎
If SameValue(constructResult.[[value]], element) is false, then throw an "InvalidStateError" DOMException and terminate these steps.
</p>

<p class="note">注記：
これは、次の場合に生じ得る：
%C が［
`super()^jc を~callする前に，同じ~custom要素の別の~instanceを構築している
］場合、あるいは
%C が［
構築子から任意の~objを返すような，~JS による `return^jc を上書きする特色機能を利用している
］場合。
◎
This can occur if C constructs another instance of the same custom element before calling super(), or if C uses JavaScript's return-override feature to return an arbitrary object from the constructor.
</p>
	</li>

	<li>
%要素 の`~custom要素~状態$ ~SET `customized^l
◎
Set element's custom element state to "customized".
</li>
	<li>
~FOR
%要素 の`属性~list$ 内の ~EACH ( %属性 ) に対し，順に
⇒
次を与える下で，`~custom要素~callback反応を待入れる$
⇒
( %要素, ~callback名 `attributeChangedCallback^l,
引数~list
( %属性 の局所~名, ~NULL, %属性 の値, %属性 の名前空間 ) )
◎
For each attribute in element's attribute list, in order, enqueue a custom element callback reaction with element, callback name "attributeChangedCallback", and an argument list containing attribute's local name, null, attribute's value, and attribute's namespace.
</li>
	<li>
~IF［
%要素 は現在`~shadowも含む文書~内$にある
］
⇒
次を与える下で，`~custom要素~callback反応を待入れる$
⇒
( %要素,
~callback名 `connectedCallback^l,
引数~list 空 )
◎
If element is currently in a shadow-including document, then enqueue a custom element callback reaction with element, callback name "connectedCallback", and an empty argument list.
</li>
</ol>

<p>
所与の要素 %要素 を
`昇格しようと試行-@
するときは、次の手続きを走らす：
◎
To try to upgrade an element, given as input an element element, run the following steps:
</p>

<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be element's node document.
</li>
	<li>
%is ~LET %要素 の`属性~list$内に［
有修飾~名 ~EQ "`is$a"
］なる属性が［
あれば その値 ／
なければ ~NULL
］
◎
Let is be the value of the attribute in element's attribute list whose qualified name is "is", if any such attribute exists, or null otherwise.
</li>
	<li>
%定義 ~LET 
次を与える下で，`~custom要素~定義を検索-$した結果
⇒
( %文書, %要素 の名前空間, %要素 の局所~名, %is )
◎
Let definition be the result of looking up a custom element definition given document, element's namespace, element's local name, and is.
</li>
	<li>
~IF［
%定義 ~NEQ ~NULL
］
⇒
次を与える下で，`~custom要素を昇格する反応を待入れる$
⇒
( %要素, %定義 )
◎
If definition is not null, then enqueue a custom element upgrade reaction given element and definition.
</li>

</ol>

		</section>
		<section id="custom-element-reactions">
<h3 title="Custom element reactions">4.13.6. ~custom要素~反応</h3>

<p>
`~custom要素$は、作者~codeを走らすことにより，一定の出来事に応答する能を備える：
◎
A custom element possesses the ability to respond to certain occurrences by running author code:
</p>

<ul>
	<li>
要素の`昇格$時には、`~custom要素~構築子$を走らす。
◎
When upgraded, its constructor is run.
</li>
	<li>
要素が`~shadowも含む文書~内$に`挿入-$されたときには、その
`connectedCallback()^jc を走らす。
◎
When it is inserted in a shadow-including document, its connectedCallback is run.
</li>
	<li>
`~shadowも含む文書~内$にある要素が`除去-$されたときは、その
`disconnectedCallback()^jc
を走らす。
◎
When it is in a shadow-including document and removed, its disconnectedCallback is run.
</li>
	<li>
要素のいずれかの属性が［
`変更-$A ／ `付加-$A ／ `除去-$A ／ `置換-$A
］されたときは、その
`attributeChangedCallback()^jc
を走らす。
◎
When any of its attributes are changed, appended, removed, or replaced, its attributeChangedCallback is run.
</li>

</ul>

<p>
これらの反応は，
`~custom要素~反応@
と総称される。
◎
We call these reactions collectively custom element reactions.
</p>

<p>
`~custom要素~反応$は、他から~~干渉されると困る演算の途中で 作者~codeが走らないように，特別に~careされる下で呼出される。
それらの反応は、実質的に
“利用者~scriptに~~制御が返される直前まで”
遅延される。
このことは、ほとんどの目的0においては，それらは同期的に実行するように現れるが、いくつかの演算（`~cloneする$, `範囲$を操作するなど）が複雑に複合された事例では、関連する~UA処理~手続きすべてが完了した後まで遅延されてから，~~一括して走らすことを意味する。
◎
The way in which custom element reactions are invoked is done with special care, to avoid running author code during the middle of delicate operations. Effectively, they are delayed until "just before returning to user script". This means that for most purposes they appear to execute synchronously, but in the case of complicated composite operations (like cloning, or range manipulation), they will instead be delayed until after all the relevant user agent processing steps have completed, and then run together as a batch.
</p>

<p>
加えて，これらの反応の精確な順序付けは、下に述べる，待行列たちの~stackが成す，いくぶん複雑な~systemを介して管理される。
この~systemの背後にある意図は、少なくとも単独の`~custom要素$における局所的な文脈~下では、各`~custom要素~反応$は，常に，それらを誘発した動作たちの順序と同じ順序で呼出されることを保証することである。
（`~custom要素~反応$の~codeは，自前で`他の要素に対する^tnote変異を遂行できるので、複数の要素にわたる大域的な順序付けを保証することは，可能0でない）
◎
Additionally, the precise ordering of these reactions is managed via a somewhat-complicated stack-of-queues system, described below. The intention behind this system is to guarantee that custom element reactions always are invoked in the same order as their triggering actions, at least within the local context of a single custom element. (Because custom element reaction code can perform its own mutations, it is not possible to give a global ordering guarantee across multiple elements.)
</p>

<hr>

<p>
各 `互いに関係するかつ生成元も類似する閲覧文脈~群$は、初期~時は空の，
`~custom要素~反応たちの~stack@
を有する。
~stack内の各~itemもまた，初期~時は空の，
`要素~待行列@
である。
~stackの一番上に積まれた`要素~待行列$は、
`現在の要素~待行列@
と呼ばれる。
`要素~待行列$内の各~itemは、要素である（この待行列は，`昇格$時にも利用されるので、各~要素は，この時点では必ずしも`~customである$とは限らない。）
◎
Each unit of related similar-origin browsing contexts has a custom element reactions stack, which is initially empty. Each item in the stack is an element queue, which is initially empty as well; the element queue at the top of the stack is called the current element queue. Each item in an element queue is an element. (The elements are not necessarily custom yet, since this queue is used for upgrades as well.)
</p>

<p>
各 要素には、初期~時は空の，
`~custom要素~反応~待行列@
が結付けられる。
`~custom要素~反応~待行列$内の各~itemは、次の 2 種いずれかになる：
◎
All elements have an associated custom element reaction queue, initially empty. Each item in the custom element reaction queue is of one of two types:
</p>

<ul>
	<li>
~custom要素を`昇格$することになる，
`昇格~反応@
。
その内容は、`~custom要素~定義$である。
◎
An upgrade reaction, which will upgrade the custom element and contains a custom element definition; or
</li>
	<li>
~lifecycle~callbackを~callすることになる，
`~callback反応@
。
その内容は、［
~callback関数, および それに対する引数の~list
］からなる。
◎
A callback reaction, which will call a lifecycle callback, and contains a callback function as well as a list of arguments.
</li>
</ul>

<p>
これらすべては、次の図式に要約される：
◎
This is all summarised in the following schematic diagram:
</p>

<figure>
<img src="HTML-custom/custom-element-reactions.svg" alt="" style="width: 80%; max-width: 560px;"><figcaption><small>
~custom要素~反応~stackは、いくつかの要素~待行列からなる~stackである。
図のある待行列に着目すると，いくつかの要素（この例では,
&lt;x-a&gt;, &lt;x-b&gt;, &lt;x-c&gt;
）を包含していることが見てとれる。
待行列~内のどの要素も、~custom要素~反応~待行列を持つ。
ある~custom要素~反応~待行列に着目すれば，待入された種々の反応を包含していることが見てとれる（この例では、［
昇格~時, 属性~変更-時, もう一つの属性~変更-時, 接続-時
］に反応するもの）。
</small>
◎
A custom elements reaction stack consists of a stack of element queues. Zooming in on a particular queue, we see that it contains a number of elements (in our example, &lt;x-a&gt;, then &lt;x-b&gt;, then &lt;x-c&gt;). Any particular element in the queue then has a custom element reaction queue. Zooming in on the custom element reaction queue, we see that it contains a variety of queued-up reactions (in our example, upgrade, then attribute changed, then another attribute changed, then connected).
</figcaption></figure>

<p>
`~custom要素~callback反応を待入れる@
手続きは、所与の
( `~custom要素$ %要素, ~callback名 %~callback名, 引数~list %引数~list )
に対し，次を走らす：
◎
To enqueue a custom element callback reaction, given a custom element element, a callback name callbackName, and a list of arguments args, run the following steps:
</p>

<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be element's node document.
</li>
	<li>
~IF［
%文書 が`属する閲覧文脈$はない
］
⇒
~RET
◎
If document does not have a browsing context, then abort these steps.
</li>
	<li>
%~registry ~LET 
%文書 に`結付けられている~Window$の `CustomElementsRegistry$I ~obj
◎
Let registry be document's associated Window's CustomElementsRegistry object.
</li>
	<li>
   
<p>
%定義 ~LET %~registry 内の［
`名前$cD ~EQ %要素 の局所~名
］なる~entry
◎
Let definition be the entry in registry with name equal to element's local name.
</p>

<p class="note">注記：
この~algoが~callされるのは、そのような定義が存在するときに限られる。
◎
This algorithm can only be called when such a definition exists.
</p>
	</li>

	<li>
%~callback ~LET 
%定義 の`~lifecycle~callback~map$cD内の［
~key ~EQ %~callback名
］なる~entryの値
◎
Let callback be the value of the entry in definition's lifecycle callbacks with key callbackName.
</li>
	<li>
~IF［
%~callback ~EQ `undefined^js
］
⇒
~RET
◎
If callback is undefined, then abort these steps.
</li>
	<li>
<p>
~IF［
%~callback名 ~EQ  `attributeChangedCallback^l
］：
◎
If callbackName is "attributeChangedCallback", then:
</p>

		<ol>
			<li>
%属性~名 ~LET %引数~list 内の最初の引数
◎
Let attributeName be the first element of args.
</li>
	<li>
~IF［
%定義 の`観測ed属性~list$cDは %属性~名 を包含しない
］
⇒
~RET
◎
If definition's observed attributes does not contain attributeName, then abort these steps.
</li>
		</ol>
	</li>
	<li>
( ~callback関数, 引数~list ) として
( %~callback, %引数~list ) を伴う新たな`~callback反応$を，
%要素 の`~custom要素~反応~待行列$に追加する
◎
Add a new callback reaction to element's custom element reaction queue, with callback function callback and arguments args.
</li>
	<li>
`現在の要素~待行列$に
%要素 を追加する
◎
Add element to the current element queue.
</li></ol>

<p>
`~custom要素を昇格する反応を待入れる@
手続きは、所与の
( 要素 %要素, `~custom要素~定義$ %定義 )
に対し，次を走らす：
◎
To enqueue a custom element upgrade reaction, given an element element and custom element definition definition, run the following steps:
</p>

<ol>
	<li>
`~custom要素~定義$として %定義 を伴う新たな`昇格~反応$を，
%要素 の`~custom要素~反応~待行列$に追加する
◎
Add a new upgrade reaction to element's custom element reaction queue, with custom element definition definition.
</li>
	<li>
`現在の要素~待行列$に
%要素 を追加する
◎
Add element to the current element queue.
</li></ol>

<p>
`要素~待行列$ %待行列 内の
`~custom要素~反応たちを呼出す@
ときは、次の手続きを走らす：
◎
To invoke custom element reactions in an element queue queue, run the following steps:
</p>

<ol>
	<li>
<p>
~FOR
%待行列 内の ~EACH ( `~custom要素$ %要素 ) に対し：
◎
For each custom element element in queue:
</p>

		<ol>
			<li>
%反応~待行列 ~LET %要素 の`~custom要素~反応~待行列$
◎
Let reactions be element's custom element reaction queue.
</li>
			<li>
<p>
~WHILE［
%反応~待行列 は空でない
］：
◎
Repeat until reactions is empty:
</p>

				<ol>
					<li>
%反応~待行列 から最初の~itemを除去する
◎
↓</li>
					<li>
%反応 ~LET 前~段で除去した~item
◎
↓</li>
					<li>
<p>
%反応 の種別に応じて：
◎
Remove the first element of reactions, and let reaction be that element. Switch on reaction's type:
</p>

<dl class="switch">
	<dt>`昇格~反応$</dt>
  	<dd>
%反応 の`~custom要素~定義$を利用して
%要素 `要素を昇格$する
◎
Upgrade element using reaction's custom element definition.
</dd>

	<dt>`~callback反応$</dt>
  	<dd>
( `~callback this 値$, 引数~list )
に次を与える下で， %反応 の~callback関数を`呼出す$
⇒
( %要素, %反応 の引数~list )
◎
Invoke reaction's callback function with reaction's arguments, and with element as the callback this value.
</dd>
</dl>

<p>
~IF［
この段で例外が投出された
］
⇒
その`例外を報告する$
◎
If this throws any exception, then report the exception.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<hr>

<p>
`~custom要素~反応$が適切に誘発されることを確保するため、この仕様は，
`[CEReactions]@c
~IDL 拡張属性を導入する。
それは、`~custom要素~反応$を適切に追跡して呼出すため，関連する~algoに追加の手続きを増補することを指示する。
◎
To ensure custom element reactions are triggered appropriately, we introduce the [CEReactions] IDL extended attribute. It indicates that the relevant algorithm is to be supplemented with additional steps in order to appropriately track and invoke custom element reactions.
</p>

<div>
<p>
`[CEReactions]$c 拡張属性は：
</p>

<ul><li>引数をとっては~MUST_NOT。
</li><li>［
演算, 属性, 設定子, 削除子
］以外のものに現れては~MUST_NOT。
</li><li>読専~属性~上には、 `[PutForwards]^c 注釈付きでない限り，現れては~MUST_NOT。
</li></ul>

◎
The [CEReactions] extended attribute must take no arguments, and must not appear on anything other than an operation, attribute, setter, or deleter. Additionally, it must not appear on readonly attributes, unless the readonly attribute is also annotated with [PutForwards].
</div>


<p>
`[CEReactions]$c
拡張属性 注釈付きの［
演算, 属性, 設定子, 削除子
］に対しては、その［
演算 ／ 設定子 ／ 削除子 ／ 属性の設定子
］に指定されている~main~algoを囲むように次の手続きを走らせ~MUST：
◎
Operations, attributes, setters, or deleters annotated with the [CEReactions] extended attribute must run the following steps surrounding the main algorithm specified for the operation, setter, deleter, or for the attribute's setter:
</p>

<dl>
	<dt>
当の~algoの手続きを実行する前に：
◎
Before executing the algorithm's steps
</dt>
  	<dd>
`~custom要素~反応たちの~stack$に新たな`要素~待行列$を~pushする
◎
Push a new element queue onto the custom element reactions stack.
</dd>

	<dt>
当の~algoの手続きを実行した後に：
◎
After executing the algorithm's steps
</dt>
  	<dd>
`~custom要素~反応たちの~stack$から`要素~待行列$を~popした上で，その待行列~内の`~custom要素~反応たちを呼出す$
◎
Pop the element queue from the custom element reactions stack, and invoke custom element reactions in that queue.
</dd>

</dl>


<div class="note">
<div class="p">
<p>注記：
この拡張属性を~~導入した背後にある意図には、微妙な所がある。
その目標を達成するためには、~~導入しない代わりに，次を記しておくことも一つではあるが…：
</p>

<ul ><li>~platform上のどの［
演算, 属性, 設定子, 削除子
］にも，上述の手続きが挿入されるべきである。
</li><li>実装者には、不必要な事例については最適化して外すことも許容される（そこでは、`~custom要素~反応$を生じさせるような~DOM変異は，可能0でない）。
</li></ul>

◎
The intent behind this extended attribute is somewhat subtle. One way of accomplishing its goals would be to say that every operation, attribute, setter, and deleter on the platform should have these steps inserted, and to allow implementers to optimize away unnecessary cases (where no DOM mutation is possible that could cause custom element reactions to occur).
</div>

<p>
…が、このような不精確な~~指定では、`~custom要素~反応$の実装は，実施において相互運用可能でなくなりかねない
— ある実装は，一部の事例でこの手続きを呼び出し忘れるかもしれない。
代わりに，相互運用可能な挙動を確保するため、この手続きが必要とされる事例すべてを，実装~側が容易に見分けられるように、関連するすべての~IDL構成子に注釈を明示的に付与する~approachをとって，決着させることにする。
◎
However, in practice this imprecision could lead to non-interoperable implementations of custom element reactions, as some implementations might forget to invoke these steps in some cases. Instead, we settled on the approach of explicitly annotating all relevant IDL constructs, as a way of ensuring interoperable behavior and helping implementations easily pinpoint all cases where these steps are necessary.
</p>
</div>
		</section>
	</section>

</main>
