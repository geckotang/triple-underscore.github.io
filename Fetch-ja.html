<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Fetch Standard （日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://fetch.spec.whatwg.org/',
		main: 'MAIN',
		ref_data: '.ref_data',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 170222 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		E: 'error',
		et: 'event-type',
		h: 'header',
		hm: 'method',
		st: 'status',
		dir: 'directive',
		p: 'protocol',
		css: 'css',
		l: 'literal',
		bl: 'literal',
		X: 'hex-value',
		A: 'abstract', // 抽象演算
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		mF: 'code',
		et: 'code',
		RqI: 'code',
		RsI: 'code',
		E: 'code',
		h: 'code',
		hm: 'code',
		l: 'code',
		bl: 'code',
		c: 'code',
		css: 'code',
		e: 'code',
		a: 'code',
		p: 'var',
		st: 'code',
		dir: 'code',
		s: 'samp',
		V: 'var',
		i: 'i',
		X: 'span',
		A: 'span',
		cite: 'cite',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|%[~\w\-一-鿆あ-ん]+|!(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);


	function create_html(match, key, indicator, klass){

if(!key) {
//	var t = match.charAt(0);
	switch(match){
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	case '⇒！':
		in_idl = true;
		nesting += '</pre>';
		return '<pre class="idl">';
	default:
		if(match[0] === '%'){
			return '<var>' + match.slice(1) +'</var>';
		}
		if(in_idl) {
			result = nesting;
			in_idl = false;
		} else {
			result =
				nesting +
				'<span lang="en">'
				+ match.slice(1) + '</span>';
		}
		nesting = '';
		return result;
	}
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
var quote = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'h': // http header
	quote = '`';
	break;
case 'hm': // http method
	quote = '`';
	break;
case 'bl': // byte sequence literal
	quote = '`';
	break;
case 'l': // literal
	quote = '"';
	break;
case 'I': // IDL interface
	if(indicator === '@'){
		idl_ifc = key;
	}
	href = '#' + key.toLowerCase();
	if(in_idl) tag = '';
	break;
case 'RqI': // RequestInit member
	href = '#dom-requestinit-' + key.toLowerCase();
	break;
case 'RsI': // ResponseInit member
	href = '#dom-responseinit-' + key.toLowerCase();
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = '#dom-' + (
		(key === idl_ifc) ? idl_ifc : (idl_ifc + '-' + key)
	).toLowerCase();
	if(in_idl) tag = '';
	break;
case 'dir': // CSP directive
	href = '~CSP3#' + key;
	break;
case 'e': // element
	text = '&lt;' + text + '&gt;';
	break;
case 'X': // byte value
	text = '0x' + key;
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
case 'mF': // IDL member (File)
case 'st': // http responce status code
case 'E': // error name
case 'i': // model constants
case 'A': // abstract opration
case 'V': // variables
case 'p': // protocol element
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}
return (
	quote + text + quote
);


	}
}

</script>

<!--%id → 原文 id -->
<script type="text/plain" id="_original_id_map">
dom-headers-iterable:
refsWSP-Compression:refsWSP
	cors-safelisted-request-header:simple-header
	cors-safelisted-method:simple-method
	response-url:fetch-url
	process-response-end-of-body:process-response-end-of-file
	process-request-end-of-body:process-request-end-of-file
	extract-header-list-values:concept-header-parse
</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">
	●HTTP header/methods
h.Access-Control-Allow-Credentials:#http-access-control-allow-credentials
h.Access-Control-Allow-Headers:#http-access-control-allow-headers
h.Access-Control-Allow-Methods:#http-access-control-allow-methods
h.Access-Control-Allow-Origin:#http-access-control-allow-origin
h.Access-Control-Expose-Headers:#http-access-control-expose-headers
h.Access-Control-Max-Age:#http-access-control-Max-age
h.Access-Control-Request-Headers:#http-access-control-request-headers
h.Access-Control-Request-Method:#http-access-control-request-method
h.Origin:#http-origin
h.X-Content-Type-Options:#http-x-content-type-options

h.Accept-Charset:~7231#section-5.3.3
h.Accept-Encoding:~7231#section-5.3.4
h.Accept-Language:~7231#section-5.3.5
h.Accept:~7231#section-5.3.2
h.Allow:~7231#section-7.4.1
h.Authorization:~7235#section-4.2
h.Cache-Control:~7234#section-5.2
h.Connection:~7230#section-6.1
h.Content-Encoding:~7231#section-3.1.2.2
h.Content-Language:~7231#section-3.1.3.2
h.Content-Length:~7230#section-3.3.2
h.Content-Type:~7231#section-3.1.1.5
h.Date:~7231#section-7.1.1.2
h.ETag:~7232#section-2.3
h.Expect:~7231#section-5.1.1
h.Expires:~7234#section-5.3
h.Host:~7230#section-5.4
h.If-Match:~7232#section-3.1
h.If-Modified-Since:~7232#section-3.3
h.If-None-Match:~7232#section-3.2
h.If-Range:~7233#section-3.2
h.If-Unmodified-Since:~7232#section-3.4
h.Keep-Alive:~7230#appendix-A.1.2
h.Last-Modified:~7232#section-2.2
h.Location:~7231#section-7.1.2
h.Pragma:~7234#section-5.4
h.Proxy-Authenticate:~7235#section-4.3
h.Referer:~7231#section-5.5.2
h.TE:~7230#section-4.3
h.Trailer:~7230#section-4.4
h.Transfer-Encoding:~7230#section-3.3.1
h.Upgrade:~7230#section-6.7
h.User-Agent:~7231#section-5.5.3
h.Vary:~7231#section-7.1.4
h.Via:~7230#section-5.7.1
h.WWW-Authenticate:~7235#section-4.1
h.Set-Cookie:~6265#section-4.1
h.Cookie:~6265#section-4.2
	h.Sec-WebSocket-Key:~6455#
	h.Sec-WebSocket-Version:~6455#
	h.Sec-WebSocket-Protocol:~6455#

h.DPR:~CLIENTHINTS#dpr
h.Downlink:~CLIENTHINTS#downlink
h.Save-Data:~CLIENTHINTS#save-data
h.Viewport-Width:~CLIENTHINTS#viewport-width
h.Width:~CLIENTHINTS#width

Content-Security-Policy:~CSP3#header-content-security-policy
Strict-Transport-Security

	Do Not Track HTTP header
	h.DNT:~IETF/draft-mayer-do-not-track-00

	//未使用
	h.Accept-Ranges:~7233#section-2.3
	h.Age:~7234#section-5.1
	h.Close:~7230#section-8.1
	h.Content-Location:~7231#section-3.1.4.2
	h.Content-Range:~7233#section-4.2
	h.ETag:~7232#section-2.3
	h.From:~7231#section-5.5.1
	h.MIME-Version:~7231#appendix-A.1
	h.Max-Forwards:~7231#section-5.1.2
	h.Proxy-Authorization:~7235#section-4.4
	h.Range:~7233#section-3.1
	h.Retry-After:~7231#section-7.1.3
	h.Server:~7231#section-7.4.2
	h.Warning:~7234#section-5.5

	●mehods
hm.CONNECT:~7231#section-4.3.6
hm.DELETE:~7231#section-4.3.5
hm.GET:~7231#section-4.3.1
hm.HEAD:~7231#section-4.3.2
hm.OPTIONS:~7231#section-4.3.7
hm.POST:~7231#section-4.3.3
hm.PUT:~7231#section-4.3.4
hm.TRACE:~7231#section-4.3.8
hm.TRACK:#biblio-httpverbsec2

	p.wildcard
	p.field-name-or-wildcard
	p.origin-or-null
p.field-name:~7230#section-3.2
	p.field-content:~7230#section-3.2
	p.field-value:~7230#section-3.2
p.method:~7230#section-3.1.1
p.delta-seconds:~7234#section-1.2.1
p.reason-phrase:~7230#section-3.1.2

	●status code
st.101:~7231#section-6.2.2
st.200:~7231#section-6.3.1
st.204:~7231#section-6.3.5
st.205:~7231#section-6.3.6
st.301:~7231#section-6.4.2
st.302:~7231#section-6.4.3
st.303:~7231#section-6.4.4
st.304:~7232#section-4.1
st.307:~7231#section-6.4.7
st.308:~IETF/rfc7238#section-3
st.401:~7235#section-3.1
st.407:~7235#section-3.2

	●HTML 要素
e.head:~HEmetadata#the-head-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
e.style:~HEmetadata#the-style-element
e.script:~HEscripting#the-script-element
e.a:~HEtextlevel#the-a-element
e.picture:~HEimages#the-picture-element
e.audio:~HTMLemb#the-audio-element
e.embed:~HEembed#the-embed-element
e.form:~HEforms#the-form-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.input:~HEinput#the-input-element
e.object:~HEembed#the-object-element
e.source:~HEimages#the-source-element
e.track:~HTMLemb#the-track-element
e.video:~HTMLemb#the-video-element
e.frame:~HTML5/obsolete.html#frame
e.svg:~SVG11/struct.html#SVGElement
	~SVG2/struct.html#elementdef-svg
e.image:~SVG11/struct.html#ImageElement

a.nonce:~HEscripting#attr-script-nonce

	●idl interface／type
I.Blob:~FILEAPI#blob
I.File:~FILEAPI#dfn-file
I.FormData:~XHR#formdata
I.XMLHttpRequest:~XHR#xmlhttprequest
I.WebSocket:~WEBSOCKET#websocket
I.URLSearchParams:~URLSpec#dom-urlsearchparams
I.Window:~BROWSERS#window
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.ServiceWorkerGlobalScope:~SW#serviceworkerglobalscope
I.ReferrerPolicy:~REFERRER-POLICY#enumdef-referrerpolicy

I.BufferSource:~WEBIDL#BufferSource
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.USVString:~WEBIDL#idl-USVString
I.ByteString:~WEBIDL#idl-ByteString
I.DOMString:~WEBIDL#idl-DOMString
	I.Promise:~WEBIDL#idl-promise
	I.boolean:~WEBIDL#idl-boolean
	I.unsigned short:~WEBIDL#idl-unsigned-short


I.ReadableStream:#concept-readablestream
I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope
I.URL:~URLSpec#url
I.HeadersInit:#typedefdef-headersinit

	ResponseInit
		status
		statusText
		headers
	RequestInit
		method
		headers
		body
		referrer
		referrerPolicy
		mode
		credentials
		cache
		redirect
		integrity
		keepalive
		window

m.fetch:#dom-global-fetch
m.response.ok:#dom-response-ok
m.navigator.sendBeacon:~BEACON#sec-sendBeacon-method

mF.size:~FILEAPI#dfn-size
mF.type:~FILEAPI#dfn-type
mF.name:~FILEAPI#dfn-name

et.fetch:~SW#service-worker-global-scope-fetch-event
et.foreignfetch:~SW#service-worker-global-scope-foreignfetch-event

	●URL
~HTTP_S~scheme:#http-scheme
~network~scheme:#network-scheme
~fetch~scheme:#fetch-scheme
局所~scheme:#local-scheme
局所的:#is-local

	●message 構成子
認証~entry:#authentication-entry
~proxy認証~entry:#proxy-authentication-entry

~HTTP空白~byte列:#http-whitespace-bytes
~HTTPS状態~値:#concept-https-state-value
資格証:#credentials

~ABNF:#abnf

	●~header~list
~header~list:#concept-header-list
hl.付加-:#concept-header-list-append
hl.削除-:#concept-header-list-delete
hl.設定-:#concept-header-list-set
hl.結合-:#concept-header-list-combine
hl.整列して結合-:#concept-header-list-sort-and-combine

	●~header
~header:#concept-header
新たな~header:#_new-header
名前に持つ~header:#_headers-of-name
包含-:#header-list-contains

hd.名前:#concept-header-name
hd.~header値を抽出-:#extract-header-values
hd.~header~list値を抽出-:#extract-header-list-values
hd.値:#concept-header-value
hd.結合済みの値:#concept-header-value-combined
hd.正規化-:#concept-header-value-normalize
hd.~MIME型を抽出-:#concept-header-extract-mime-type

~CORS安全な要請~header:#cors-safelisted-request-header
~CORS非~wildcard要請~header名:#cors-non-wildcard-request-header-name
禁止~header名:#forbidden-header-name
禁止~応答~header名:#forbidden-response-header-name
~CORS安全な応答~header名:#cors-safelisted-response-header-name

既定の User-Agent 値:#default-user-agent-value
	●~method
~method:#concept-method
md.正規化-:#concept-method-normalize
禁止~method:#forbidden-method
~CORS安全な~method:#cors-safelisted-method

	●~status
~status:#concept-status
~null本体~status:#null-body-status
~ok~status:#ok-status
~redirect~status:#redirect-status

	●本体
本体:#concept-body
bd.伝送済み~byte数:#concept-body-transmitted
bd.総~byte数:#concept-body-total-bytes
bd.~source:#concept-body-source
bd.~clone:#concept-body-clone
bd.~stream:#concept-body-stream
bd.待機-:#concept-body-wait
bd.~done:#concept-body-done

	●要請
要請:#concept-request
rq.本体:#concept-request-body
rq.~header~list:#concept-request-header-list
rq.非安全-要請~flag:#unsafe-request-flag
rq.~redirect~mode:#concept-request-redirect-mode
rq.完全性~metadata:#concept-request-integrity-metadata
rq.暗号用~nonce~metadata:#concept-request-nonce-metadata
rq.構文解析器~metadata:#concept-request-parser-metadata
rq.~method:#concept-request-method
rq.~mode:#concept-request-mode
rq.~CORS予行~利用~flag:#use-cors-preflight-flag
rq.資格証~mode:#concept-request-credentials-mode
rq.~redirect数:#concept-request-redirect-count
rq.~referrer:#concept-request-referrer
rq.~referrer施策:#concept-request-referrer-policy
rq.~client~hint~list:#concept-request-client-hints-list
rq.同期~flag:#synchronous-flag
rq.予約済み~client:#concept-request-reserved-client
rq.~target~client~id:#concept-request-target-client-id
rq.~url:#concept-request-url
rq.~url~list:#concept-request-url-list
rq.現在の~url:#concept-request-current-url
rq.資格証利用URL~flag:#concept-request-use-url-credentials-flag
rq.~cache~mode:#concept-request-cache-mode
rq.応答~tainting:#concept-request-response-tainting
rq.~client:#concept-request-client
rq.~window:#concept-request-window
rq.~service-worker~mode:#request-service-workers-mode
rq.起動元:#concept-request-initiator
rq.種別:#concept-request-type
rq.行先:#concept-request-destination
rq.優先度:#concept-request-priority
rq.生成元:#concept-request-origin
rq.~keepalive~flag:#request-keepalive-flag
rq.~done~flag:#done-flag
rq.~clone:#concept-request-clone

本体を伝送する:#concept-request-transmit-body

~sandboxed-storage-area-URLs~flag:#sandboxed-storage-area-urls-flag
局所URLonly~flag:#local-urls-only-flag

下位資源~要請:#subresource-request
非~下位資源~要請:#non-subresource-request
［~naviまたは下位資源］のいずれかになり得る要請:#potential-navigation-or-subresource-request
~navi要請:#navigation-request

	●応答
応答:#concept-response
rs.~url:#concept-response-url
rs.~url~list:#concept-response-url-list
rs.本体:#concept-response-body
rs.~trailer:#concept-response-trailer
rs.~header~list:#concept-response-header-list
rs.~status~message:#concept-response-status-message
rs.~status:#concept-response-status
rs.種別:#concept-response-type
rs.終了~事由:#concept-response-termination-reason
rs.~HTTPS状態:#concept-response-https-state
rs.~CSP~list:#concept-response-csp-list
rs.~clone:#concept-response-clone
rs.~CORSに公開される~header名~list:#concept-response-cors-exposed-header-name-list
rs.所在~URL:#concept-response-location-url


~fetch~group:#concept-fetch-group
~fetch記録:#concept-fetch-record
fg.要請:#concept-fetch-record-request
fg.~fetch:#concept-fetch-record-fetch
fg.終了-:#concept-fetch-group-terminate

~network~error:#concept-network-error

絞込み応答:#concept-filtered-response
不透明redirect絞込み応答:#concept-filtered-response-opaque-redirect
内的~応答:#concept-internal-response
基本~絞込み応答:#concept-filtered-response-basic
~CORS絞込み応答:#concept-filtered-response-cors
不透明な絞込み応答:#concept-filtered-response-opaque

	●fetch処理／予行／cache／CORS

応答~URL:#response-url
基本~fetch:#concept-basic-fetch
~main~fetch:#concept-main-fetch
~fetch:#concept-fetch
~fetching:#concept-fetch
~HTTP~fetch:#concept-http-fetch
~HTTP~redirect~fetch:#concept-http-redirect-fetch
~HTTP~network~fetch:#concept-http-network-fetch
~HTTP~network-or-cache~fetch:#concept-http-network-or-cache-fetch
終了-:#concept-fetch-terminate
休止-:#concept-fetch-suspend
再開-:#concept-fetch-resume

応答を処理する:#process-response
応答の本体終端を処理する:#process-response-end-of-body
要請の本体を処理する:#process-request-body
要請の本体終端を処理する:#process-request-end-of-body
応答の~doneを処理する:#process-response-done
内容~符号法sを取扱う:#handle-content-codings
内容~符号法sを取扱った:#handle-content-codings


~fetch~taskを待入する:#queue-a-fetch-task
~fetch要請~done~taskを待入する:#queue-a-fetch-request-done-task

cc.~CORS予行~cache:#concept-cache
cc.予行~cacheの~entryを消去する:#concept-cache-clear
cc.資格証の有無:#concept-cache-credentials
cc.~header名:#concept-cache-header-name
cc.~cache合致:#concept-cache-match
ccm.~cacheに合致:#concept-cache-match-method
cch.~cacheに合致:#concept-cache-match-header
cc.寿命:#concept-cache-max-age
cc.~method:#concept-cache-method
cc.生成元:#concept-cache-origin
cc.~url:#concept-cache-url
新たな~cache~entryを作成-:#concept-cache-create-entry

~CORS予行~fetch:#cors-preflight-fetch-0
~CORS検査:#concept-cors-check
~CORS非同一生成元:#cors-cross-origin
~CORS~protocol:#cors-protocol
~CORS同一生成元:#cors-same-origin
~CORS要請:#cors-request
~CORS予行~要請:#cors-preflight-request

接続~pool:#concept-connection-pool
接続を得る:#concept-connection-obtain
接続を得た:#concept-connection-obtain
接続:#concept-connection
不良~port:#bad-port
~fetchingは，不良~portに因り阻止されるべきか？:#block-bad-port

	●他
~HTTP~redirectの不可分的な取扱い:#atomic-http-redirect-handling
srI.合致:~SRI1#does-response-match-metadatalist
	https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
	does-varresponsevar-match-varmetadatalistvar

却下され:#_reject-promise
却下する:#_reject-promise
解決する:#_resolve-promise
新たな~promise:#_new-promise
充足~時には:#_upon-fulfillment
却下~時には:#_upon-rejection
変形-:#_transforming-by
変形する:#_transforming-by

新鮮:~7234#section-4.2
非新鮮:~7234#section-4.2
条件付き要請:~7232#section-1
部分的~内容:~7233#section-4.1

~client~hint~list:#concept-client-hints-list

	●Stream
A.AcquireReadableStreamDefaultReader:~STREAMS#acquire-readable-stream-reader
A.ReadableStreamDefaultControllerClose:~STREAMS#readable-stream-default-controller-close
A.ReadableStreamDefaultControllerEnqueue:~STREAMS#readable-stream-default-controller-enqueue
A.ReadableStreamDefaultControllerGetDesiredSize:~STREAMS#readable-stream-default-controller-get-desired-size
A.IsReadableStreamDisturbed:~STREAMS#is-readable-stream-disturbed
A.IsReadableStreamLocked:~STREAMS#is-readable-stream-locked
A.ReadableStreamDefaultReaderRead:~STREAMS#readable-stream-default-reader-read
A.ReadableStreamCancel:~STREAMS#readable-stream-cancel
A.ReadableStreamTee:~STREAMS#readable-stream-tee
A.ReadableStreamDefaultControllerError:~STREAMS#readable-stream-default-controller-error

~ReadableStream:#concept-readablestream
空の~ReadableStream~obj:#concept-empty-readablestream
RS.~enqueue:#concept-enqueue-readablestream
RS.~closeする:#concept-close-readablestream
RS.~errorにする:#concept-error-readablestream
RS.~ReadableStream~objを構築-:#concept-construct-readablestream
RS.固定的な~ReadableStream~objを構築-:#concept-construct-fixed-readablestream
RS.読取器を取得-:#concept-get-reader
RS.~chunkを読取る:#concept-read-chunk-from-readablestream
RS.~chunkを読取った:#concept-read-chunk-from-readablestream
RS.すべての~byte列を読取る:#concept-read-all-bytes-from-readablestream
RS.すべての~byte列を読取った:#concept-read-all-bytes-from-readablestream
RS.二叉化:#concept-tee-readablestream
RS.読取可:#concept-readablestream-readable
RS.~closeされた:#concept-readablestream-closed
RS.~errorした:#concept-readablestream-errored
RS.~errorが生じ:#concept-readablestream-errored
RS.妨げられている:#concept-readablestream-disturbed
RS.~lockされている:#concept-readablestream-locked
RS.もっと~dataが必要:#concept-readablestream-need-more-data
	RS.妨げる:#concept-readablestream-disturbed
RS.~dataの~stream:~STREAMS#rs-class
RS.取消す:#concept-cancel-readablestream


	●Fetch API
本体と内容~型を抽出-:#concept-bodyinit-extract
検査:#_check-name-value-pair

新たな~Headers:#_new-headers

Hl.~header~list:#concept-headers-header-list
Hl.付加-:#concept-headers-append
Hl.~guard:#concept-headers-guard
Hl.埋める:#concept-headers-fill

Rq.要請:#concept-request-request
Rs.応答:#concept-response-response
Rs.~trailer~promise:#concept-response-trailer-promise

Bd.妨げられている:#concept-body-disturbed
Bd.~lockされている:#concept-body-locked
Bd.本体:#concept-body-body
Bd.~MIME型:#concept-body-mime-type
Bd.本体を消費-:#concept-body-consume-body
Bd.~dataを梱包-:#concept-body-package-data

	外部リンク
~byte列:~INFRA#byte-sequence
~byte小文字~化:~INFRA#byte-lowercase
~byte大文字~化:~INFRA#byte-uppercase
空:~INFRA#list-is-empty
~list:~INFRA#list
	~EACH:~INFRA#list-iterate
	~EACH:~INFRA#map-iterate
~byte大小無視:~INFRA#byte-case-insensitive


enc.~UTF-8:~ENCODING#utf-8
enc.~UTF-8復号器:~ENCODING#utf-8-decoder
enc.~UTF-8符号化-:~ENCODING#utf-8-encode
enc.~UTF-8復号-:~ENCODING#utf-8-decode


~URL:~URLSpec#concept-url
url.~url構文解析器:~URLSpec#concept-url-parser
url.~url直列化器:~URLSpec#concept-url-serializer
url.~domain:~URLSpec#concept-domain
url.~scheme:~URLSpec#concept-url-scheme
url.素片:~URLSpec#concept-url-fragment
url.~cannot-be-a-base-URL~flag:~URLSpec#url-cannot-be-a-base-url-flag
url.生成元:~URLSpec#concept-url-origin
url.~path:~URLSpec#concept-url-path
url.~host:~URLSpec#concept-url-host
url.~port:~URLSpec#concept-url-port
url.~username:~URLSpec#concept-url-username
url.~password:~URLSpec#concept-url-password
url.~obj:~URLSpec#concept-url-object
url.資格証を含む:~URLSpec#include-credentials

url.~form_urlencoded 直列化器:~URLSpec#concept-urlencoded-serializer
url.~form_urlencoded 構文解析器:~URLSpec#concept-urlencoded-parser
url.名値~組~list:~URLSpec#concept-urlsearchparams-list

url.~usernameを設定する:~URLSpec#set-the-username
url.~passwordを設定する:~URLSpec#set-the-password

xhr.~entry:~XHR#concept-formdata-entry
	xhr.~entryを作成する:~XHR#create-an-entry

~task:~WAPI#concept-task
~taskを待入する:~WAPI#queue-a-task
待入され:~WAPI#queue-a-task
~network用~task源:~WAPI#networking-task-source
現在の設定群~obj:~WAPI#current-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
環境:~WAPI#environment
enV.担当の~event-loop:~WAPI#responsible-event-loop
enV.担当の閲覧文脈:~WAPI#responsible-browsing-context
enV.~API基底~URL:~WAPI#api-base-url
enV.~HTTPS状態:~WAPI#https-state
enV.~id:~WAPI#concept-environment-id
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
enV.大域~obj:~WAPI#concept-settings-object-global
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.作成時の~URL:~WAPI#concept-environment-creation-url

html.生成元:~BROWSERS#origin
同一生成元:~BROWSERS#same-origin
不透明な生成元:~BROWSERS#concept-origin-opaque
~ASCII直列化-:~BROWSERS#ascii-serialisation-of-an-origin
	origin.origin:生成元
閲覧文脈:~BROWSERS#browsing-context
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
作動中の文書:~BROWSERS#active-document
入子の閲覧文脈:~BROWSERS#nested-browsing-context

html.並列的:~HTMLINFRA#in-parallel
html.~form_data 境界~文字列:~HTMLforms#multipart/form-data-boundary-string
html.~form_data として符号化-:~HTMLforms#multipart/form-data-encoding-algorithm


idl.~promise型:~WEBIDL#idl-promise
idl.連列~型:~WEBIDL#idl-sequence
idl.~record型:~WEBIDL#idl-record
idl.複製:~WEBIDL#dfn-get-buffer-source-copy
idl.反復される値~pair:~WEBIDL#dfn-value-pairs-to-iterate-over
	idl.es-ByteString:IDL <code>ByteString</code> 型に変換
idl.在する:~WEBIDL#dfn-present

x.読取り演算:~FILEAPI#readOperation

~CSP指令:~CSP3#csp-directives
応答の~CSP~listを設定する:~CSP3#set-response-csp-list

~WebSocket~protocol~handshakeを確立する:#concept-websocket-establish
~WebSocket接続を得た:#concept-websocket-connection-obtain
~WebSocket接続を得る:#concept-websocket-connection-obtain

~WebSocket接続を失敗させる:#fail-the-websocket-connection
~WebSocket接続は確立される:#the-websocket-connection-is-established

~referrer施策:~REFERRER-POLICY#referrer-policy
	#concept-referrer-policy
~referrerを決定-:~REFERRER-POLICY#determine-requests-referrer
~referrer施策を設定する:~REFERRER-POLICY#set-requests-referrer-policy-on-redirect

~navi:~NAVI#navigate
~navigate:~NAVI#navigate

ランダムオラクル:https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%B3%E3%83%80%E3%83%A0%E3%82%AA%E3%83%A9%E3%82%AF%E3%83%AB

open HTTP redirector:https://wiki.suikawiki.org/n/open%20redirector
</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
ReadableStream: <code>ReadableStream</code> 
SRI1:webappsec-subresource-integrity-ja.html
BEACON:beacon-ja.html

6265:RFC6265-ja.html
6455:RFC6455-ja.html
7230:RFC7230-ja.html
7231:RFC7231-ja.html
7232:RFC7232-ja.html
7233:RFC7233-ja.html
7234:RFC7234-ja.html
7235:RFC7235-ja.html
CLIENTHINTS:http://httpwg.org/http-extensions/client-hints.html

Headers: <code>Headers</code> 

form_data:<code>multipart/form-data</code>
form_urlencoded:<code>application/x-www-form-urlencoded</code>
	Origin:<code class="header">Origin</code>

P_TRUE:%x74.72.75.65
P_NULL:%x6E.75.6C.6C
tee_command:<a href="http://ja.wikipedia.org/wiki/Tee_%28UNIX%29">tee コマンド</a>
at-import:@import
</script>

<!--% ■語彙置換データ-->
<script type="text/plain" id="words_table">


HTML:
CSS:
JS:JavaScript
ABNF:
API:
	＊
	~header名:header-name cache match
	new-header
fallback:
worker:
service-worker:service worker
skip-service-worker:
done:
fetch-done:
link::::リンク
main:
hint::::ヒント
group::::グループ
registry::::レジストリ
	登録簿
	組:tuple
keepalive:
payload::::ペイロード
	cross:::クロス
data::::データ
entry::::エントリ
entries::::エントリたち
error::::エラー
flag::::フラグ
debugging::::デバッグ
logging::::ログ取り
	debugging and logging
field::::フィールド
mode::::モード
node::::ノード
script::::スクリプト
code::::コード

記録:record::~::レコード
所在:location::~
早期:early::~
	~potentially
既定:default:~:::デフォルト
既定の:default:~:::デフォルト
消去-:clear::~::クリア

付加-:append:~
	追加-:add:~
削除-:delete:~
結合-:combine:~
結合済みの:combined:~
設定群:settings::~
	待行列:queue::待ち行列
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ
共有-:share:~
共有:sharing:~
文脈:context::~
絞込み:filtered::絞り込み::フィルタ済み
	はじく:filter out
内的:internal::内部
内部:internal:~

source::::ソース
源:source::~::ソース
status::::ステータス
ok:
web::::ウェブ
現在の:current::~
処理-:process::~
処理:processing::~
進行中の:ongoing:~
請われ:ask され:~
請う:ask する:~
基本:basic::~
検査:check::~::チェック
同期:synchronous::~

手動:manual::~
上書き:override::~

frame::::フレーム
dialog::::ダイアログ

大域:global::~::グローバル
環境:environment::~

省略-:omit::~
先祖:ancestor::~
閲覧文脈:browsing context::~
入子の:nested:入れ子の

優先度:priority::~
文書:document::~
中止:abort::~
終了-:terminate::~
終了:termination::~
休止-:suspend::~
休止:suspension::~
再開-:resume::~
事由:reason::~
理由:reason:~
upload::::アップロード
view::::ビュー
要素:element:~

	●syntax
UTF-8:
literal::::リテラル
wildcard:
byte::::バイト
大小無視:case-insensitive:~
大小区別:case-sensitive:~
文字大小:casing:~
解析済:parsed::解析済み::パース済み
構文解析-:parse::構文解析::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
直列化-:serialize::~::シリアライズ
直列化器:serializer::~::シリアライザ
再解析:reparsing::~
抽出-:extract::~
符号化:encoded::~::エンコードされた
符号化-:encode::~::エンコード
符号化処理:encoding::~::エンコード処理
符号化方式:encoding::~
復号器:decoder::~::デコーダ
復号-:decode::復号::デコード
文字列:string:~
token::::トークン
生成規則:production:~
長さ:length:~
小文字:lowercase:~
大文字:uppercase:~
字句順:lexicographic:~
整列-:sort:~
正規化-:normalize::~
合致:match:~:::マッチ
空白:whitespace::~
部位:part:~
失敗-:fail::~
失敗:failure::~
成功-:succeed:~
成功:success::~
成功裡:successful:~

	●URL
基底:base::~
非相対:non-relative::~
cannot-be-a-base-URL:::基底 URL 不可用

query::::クエリ
host::::ホスト
hostname::::ホスト名
username::::ユーザ名
password::::パスワード
path::::パス
port::::ポート
domain::::ドメイン
scheme::::スキーム
素片:fragment::~::フラグメント
素片除外:exclude-fragment:fragment 除外:素片除外::フラグメント除外

	location:::ロケーション
不良:bad:~
	期限

	●ネットワーク／HTTP(S)
WebSocket:
MIME:
data-URL:
URL:
http:
HTTP:
HTTPS:
HTTP_S:HTTP(S) 
network-or-cache::::ネットワーク-or-キャッシュ
url:
fetch:
fetching:::fetch 処理
network::::ネットワーク
networking::::ネットワーク処理
service::::サービス
protocol::::プロトコル
下位protocol:subprotocol::下位 protocol:下位プロトコル
	~protocol~list:protocols
target:
navi:navigation:::ナビ
navigate::::ナビゲート
form::::フォーム
提出:submission::~
redirect::::リダイレクト
message::::メッセージ
method::::メソッド
methods::::メソッドたち
meth:method:::メソッド
client::::クライアント
potential-client::::potential-クライアント 
server::::サーバ
proxy::::プロキシ
referrer::::リファラ
	参照元
header_name:header name:header 名::ヘッダ名
header::::ヘッダ
cache::::キャッシュ
caching::::キャッシュ処理
cookie::::クッキー
dispatch:
opening:
handshake::::ハンドシェイク
pool:::プール
trailer::::トレイラ
内容形式:format::~::フォーマット
伝送-:transmit:~
伝送済み:transmitted:~
伝送:transmission:~
局所的:local::~::ローカル
局所:local::~::ローカル
局所URLonly:local-URLs-only::局所-URL-限定 ::ローカル-URL-限定 
起動元:initiator::~
種別:type::~
行先:destination::~
発行-:make::~

禁止-:forbid::~
禁止:forbidden::~
保管庫:store::~::ストア
本体:body::~:ボディ
本体終端:end-of-body:body 終端:~:ボディ終端
状態:state::~

資源:resource::~:リソース
下位資源:subresource::~:下位リソース

要請:request::~::リクエスト
非安全-:unsafe-::~::非安全
応答:response::~::レスポンス
	応答header:response-header::応答 header:応答ヘッダ:レスポンスヘッダ
生成元:origin::~::オリジン
単純:simple::~
同一生成元:same-origin::~::同一オリジン
非同一生成元:cross-origin::~::クロスオリジン
検証:validation::~
検証-:validate::~
無効化:invalidate::~
無効化:invalidation::~
再検証:revalidation::~
新鮮化-:fresh::~
	新鮮化-法:freshening
新鮮:fresh::~
非新鮮:stale::~
寿命:max-age:::~
完全:complete::~
部分的:partial::~

内容:content:~
符号法:coding::符号法::コーディング
符号法s:codings::符号法たち::コーディングたち
昇格-:upgrade::~::アップグレード
接続-:connect::~
接続:connection::~
環境設定:configuration::~
環境設定-:configure:~

依存関係:dependency::~
重み:weight::~

通信:communicating::~
通信-:communicate::~
確立-:establish::~
確立:establishing::~
受信-:receive::~
送信-:send::~
送達-:deliver::~
条件付き:conditional::~
失効-:expire::~
追随-:follow:~
	“最終”:final
転送-:transfer:~


	●HTTPS／保安／認証／CSP／CORS／MIX
	CORS-preflight
	~proxy認証:proxy-authentication entry
Fetch:
TLS:
CSP:
CORS:
tainting:
nonce::::ナンス
sensitive::::センシティブ
session::::セッション
firewall::::ファイアウォール
intranet::::イントラネット
metadata::::メタデータ
guard::::ガード
realm:
sandbox:
sandboxed-storage-area-URLs::sandbox化-storage域-URL::サンドボックス化ストレージ域-URL
施策:policy:::~:ポリシー
追跡:tracking:~
阻止ed:blocked::阻止される::ブロックされる
許容ed:allowed::許容される
阻止-:block::~::ブロック
阻止法:blocking::~::ブロッキング
完全性:integrity::~

XSS:cross-site scripting: XSS :::クロスサイト スクリプティング
指令:directive::~::ディレクティブ
資格証:credentials::資格証明情報::クレデンシャル
資格証利用URL:use-URL-credentials::URL資格証明情報-利用::URLクレデンシャル利用
認証:authentication::~
認証-:authenticate::~
権限付与:authorization::~
権限:authority::~
証明書:certificate::~
hash::::ハッシュ
弱い:weak:~
暗号suite:cypher suite::暗号 suites:暗号スイート
有効期間:validity period:~
保安:security::~:セキュリティ
強固:strong:~
報告:report:~
	違反報告
秘匿情報:secret:~
漏洩:leak:~
攻撃:attack:~
攻撃者:attacker:~
保護:protect:~
安全:safe:~

inflight:::伝送中の
予行:preflight::~::プリフライト
不透明:opaque::~
不透明な:opaque::~
不透明redirect:opaque-redirect::不透明-redirect:不透明リダイレクト

信用-:trust:~
騙す:trick する:~
深刻な:serious:~
無作為:random::~::ランダム
承認-:acknowledge:~
暗号用:cryptographic::~
混在:mixed::~
悪用:exploits:~


	●仕様（動詞
support::::サポート
opt-in::::オプトイン
利用者:user:~:::ユーザ
末端利用者:end-user:~::エンドユーザ
	※作者:author::~
開発-:develop:~
開発者:developer:~
実装-:implement:~
実装:implementation:~
公開-:expose:~
許容-:allow:~
指示-:indicate:~
提供-:provide:~
対応関係:mapping:~
拡張:extension:~
除外-:exclude:~
結付けら:associate さ:結び付けら
標準化-:standardize:~
決定-:determine:~
決定:determination:~
拘束-:constrain:~
拘束:constraints:~
所与の:与えられた
要件:requirements:~
要求-:require:~
無視-:ignore:~
違反-:violate:~
違反:violation:~
依存-:depend:~
依存の:-dependent:~
定義-:define:~
定義:definition:~
影響-:affect:~
影響0:impact:影響
	関係:relationship／relevant
	どの〜から利用されるか:relationship:~
関係-:relate:~
奨励-:encourage:~
	外で残存:outlive
想定-:suppose:~
見做され:assume され:~
見做す:assume する:~
前提:assumption:~
試みて:attempt して:~
受容-:accept:~
受容可能:acceptable:~
統一化-:unify:~
統一化:unifying:~
導入-:introduce:~
	もたらす
定めら:state さ:~
	他が定められない限り:Unless stated otherwise
避ける:avoid する:~
依拠-:rely:~
	〜できreliable
統合-:integrate:~
表現-:represent:~
意味-:mean:~
発展-:evolve:~
説明-:explain:~
明確化:clarify:~
再利用:reuse:~
予約-:reserve:~
	創出-:mint:~
義務付けら:mandate され:~
改め:alteration:~
制約-:restrict:~
制約:restriction:~
確保-:ensure:~
決める:decide する:~
組合わせ:combination:組み合わせ
検証0-:verify:検証
一時対処:workaround:一時的な対処
適用-:apply:~
制御:control:~
抽象化:abstraction:~
	abstract 化:~
観測-:observe:~
観測可能:observable:~
特化-:specialize:~
最小化-:minimize:~
解-:understand:~
考慮-:consider:~
	該当-:pertain
判別-:distinguish:~
	判別できない:indistinguishable
関与-:participate:~
求める:want する:~
求めて:want して:~
求めた:want した:~
孕む:involve する:~
孕まれ:involve され:~

	●仕様
UA:user agent::UA::ユーザエージェント
version::::バージョン
platform::::プラットフォーム
algo:algorithm:::アルゴリズム
有用:useful:~
内部状態管理:bookkeeping details:~
特色機能:feature:~
機能性:functionality:~
情報:information:~
互換:compatible:~
互換性:compatibility:~
後方互換性:backwards compatibility:~
	強く:strong に:~
一貫性:consistency:~
一貫する:consistent になる:~
一貫した:consistent な:~
	一貫性をとる／備える:consistent
課題:issue:~
仕様:spec:~
目的:purpose:~
標準:standard:~
意味論:semantics:~
構文:syntax:~
概念:concept:~
概して:typical に:~
明示的:explicit:~
手段:means:~
単独の:single:~
下位手続き:substeps:~
手続き:steps:~
段:step:~
不用意:accidental:~
特定0の:particular:ある特定の
	~~特有のもの:particulars
特別:special:~
場合分け:casing:~
可用:available:~
仕組み:mechanism:~
正確:exact:~
一時的:temporary:~
関連する:relevant な:~
正しい:correct な:~
正しく:correct に:~
適切な:appropriate:~
適切:appropriate:~
能:ability:~
注意深く:careful に:~
詳細な:detailed:~
詳細:details:~
詳細に:detail に:~
簡便:convenient:~
	都合が良い:convenient:~
無害:harmless:~
困難さ:difficulty:~
基盤的部分:ground:~
側面:aspect:~
過渡期:transition period:~
省略可:optional:~
option::::オプション
選択余地:options:選択の余地
追加の:additional:~
意図的:intentional:~
共通する:common な:~
直接的:direct:~
曖昧:vague:~
真偽値:boolean:~
明白:clear:~
全部的:full:~
実質的:effective:~

	細分化:granular に:~
	細かい点~finer~points
重要:important:~
普通の:ordinary:~
一般:general:~
一般的:general:~
一般論:general:~
代表的な:typical:~
community::::コミュニティ
歴史的な:historical:~
仕方:way:~
旧来の:legacy:~
遺物:artefact:~
便宜:convenience:~
合法:legal:~
	〜でない:illegal
厳格:strict:~
透過的:transparent:~
相違:difference:~
相互運用可能:interoperable:~
条項:caveats:~
	最終的に:eventual
通常の:normal:~
正常:normal:~
実際:actual:~
実際の:actual:~
自動:automatic:~
一時:temporary:仮の
仮の:hypothetical:~
	用語:term
	~~用語:device
今後の:future:~
	未策定の:future
本質的:essential:~
相応しい:suitable な:~
率直:straightforward:~
規範的:normative:~

	●stream/js/IDL/promise/primitives
此れ:<b>これ°</b>
IDL:
list::::リスト
obj:object:::オブジェクト
連列:sequence::~
配列:array::~
promise:
class:
record::::レコード
map::::マップ
stream::::ストリーム
pipe::::パイプ
	pipe法:piping
形式変換:transform::~
enqueue:
close:
handler::::ハンドラ
chunk:
clone:
queuing:
call:
lock::::ロック
tee:
二叉化:tee::~
function:
新たな:new:~
task::::タスク
pull:
cancel:
取消す:cancel する:取り消す
instance::::インスタンス
window:::::ウィンドウ
parameter::::パラメタ
null:
key:
multimap:
	( ~key: 値 ):key-value
	value:
mixin:
名前:name:~
名:name:~
名s:names:名たち
値:value:~
名値:name-value: ( 名, 値 ) 
prop:property:::プロパティ
型:type:~
在する:present する:在る
提示-:present:~
排他的:exclusive:~
妨げら:disturb さ::~
	妨げる:disturb する::~
動作:action::~
固定的な:fixed:~

不可分的:atomic:~
静的:static:~
静的な:static:~

hook::::フック

読取られ:read され::読み取られ
読取り:read::読み取り
読取る:read する::読み取る
読取れる:read できる::読み取れる
読取った:read した::読み取った
読取器:reader::読み取り器::リーダ
読取可:readable::読み取り可能

呼出-:invoke:呼び出
	呼出され／呼出した／呼出して
呼出す:invoke する:呼び出す
被呼出時:被 invoke 時:~

返す:return する:~
	返すか
返され:return され:~
返さ:return し:~
返-:return:~
返値:return value:返り値

却下-:reject::~
解決-:resolve::~
充足:fulfillment::~
却下:rejection::~
変形-:transform::~

策:strategy::~::ストラテジー

属性:attribute:~
待機-:wait:~
構成子:construct:~
構築子:constructor:~:::コンストラクタ
構築-:construct:~
構築:construction:~
	構築-法:constructing
初期:initial:~
	初期~時:initially

取得子:getter:~
取得-:get:~
設定子:setter:~
設定-:set:~
	設定しておく:set up:~
	end-of-stream:stream 終端
member::::メンバ
例外:exception:~
投出:throw:~
再投出:rethrow:~
例外投出あり:rethrow any exception:~
引数:argument:~
演算:operation:~
演算-:operate:~

並列的:parallel:~
反復-:iterate:~
担当の:responsible::~
event-loop:event loop:::イベントループ

埋める:fill する:~
有構造cloning:structured cloning:有構造 clone 法
登録-:register:~
複製:copy:~
言語:language:~

	●未分類（動詞
push::::プッシュ
log::::ログ
access::::アクセス
置換-:replace:~
関数:function:~

走らす:run する:走らせる
走らせ:run し:~
走らさ:run さ:走らさ
走って:run して:~
遂行-:perform:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
取扱える:handle できる:取り扱える
取扱われ:handle され:取り扱われ
取扱った:handle した:取り扱った
挙動する:behave する:ふるまう
挙動:behavior:ふるまい
見出せな:find できな:~
受取る:receive する:受け取る

誘発:triggering:~
生成-:generate:~
消費-:consume:~
消費:consumption:~
変換-:convert:変換
作成-:create:~
作成:creation:~
作成時の:creation:~
更新:update:~
格納-:store:~
格納済み:stored:~
選定-:select:~
解放-:release:~
検索取得-:retrieve:~
	連結-:concatenate:~
選んで:choose して:~
梱包-:package::~
包装-:wrap::~
露出-:reveal:~
捕捉-:capture:~
防止-:prevent:~
除去-:remove:~
識別-:identify::~
保持-:hold:~
	対象にする:cover
捕える:catch する:~
	重複し得る:potentially duplicate

浪費-:waste:~
拡充-:populate:~
改変:modification:~
改変-:modify:~
予約済み:reserved:~
配備-:deploy:~
抑制-:reduce:~
変化-:change:~
変更-:change:~
変更:changes:~
包含-:contain:~

	●未分類
ASCII:
id:
外来の:foreign::~
外来:foreign::~
迂回-:bypass:~
forward::最新
event::::イベント
callback:
architecture::::アーキテクチャ
plugin::::プラグイン
memory:::メモリ
stylesheet::::スタイルシート
level::::レベル
pair::::ペア
size::::サイズ
browser::::ブラウザ
	redirector::::リダイレクタ
	今日の:today:~
internet::::インターネット
flow::::フロー
slash::::スラッシュ

作動中の:active な::~::アクティブな
実0:actual:実

不定期:indefinite:~
境界:boundary::~
合成:synthetic:~
進捗:progression:~
漸進的:progressive:~

画像:image:~
	非同期的:asynchronous:~

一意識別子:unique identifier::~
一意:unique:~
識別子:identifier::~
再帰的:recursive:~
再帰:recursive:~
空:empty:~
空の:empty:~
層:layer:~

機器:device:~
	文:statement:~
有順序:ordered:~
等価:equivalent:~

元の:original:~

利用者中止:end-user abort::末端利用者による中止::エンドユーザによる中止
致命的:fatal::~
時間切れ:timeout::~
garbage::::ガーベジ
収集:collection:~
最大:maximum:~
即時:immediate:~
精確:precise:~


</script>


<!--%style
-->
<style>

code {
	white-space:nowrap;
}

.hex-value {
	font-family: sans-serif0, sans-serif;
}

/* flag, 定数 */
i {
	text-decoration: underline;
	font-weight: normal;
	color: black;
}

._narrow-cell {
	position:relative;
}

._narrow-cell > * {
	position: absolute;
	top: -3em;
	left: 0;
}

._narrow-cell > *::before {
	position: absolute;
	top: 1.5em;
	left: 1em;
	color: gray;
	content: "↓";
}

</style>
</head>

<body>


<!--%UI -->
<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">

<h1>Fetch Standard 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付時点の
<a id="_SPEC_URL">Fetch Standard</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-03-24</time>
（公開： <time>2013-04-27</time>）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDUiIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzNjNzkwYSIgc3Ryb2tlLXdpZHRoPSIxMCIvPgo8cGF0aCBkPSJtMzQsNTVhNjAsNjAsMCwwLDAsMjAsLTIwYTYsMTAsMCwwLDEsMTMsLTFhMTAsNiwwLDAsMSwtMSwxM2E2MCw2MCwwLDAsMCwtMjAsMjBhNiwxMCwwLDAsMSwtMTMsMWExMCw2LDAsMCwxLDEsLTEzIiBmaWxsPSIjM2M3OTBhIi8+Cjwvc3ZnPgo="
></a>
	<hgroup>
<h1>Fetch</h1>
<h2>Living Standard — 最終更新 2017 年 3 月 23 日</h2>
	</hgroup>

<dl>
	<dt>Participate:</dt>
	<dd><a href="https://github.com/whatwg/fetch">GitHub whatwg/fetch</a>
(<a href="https://github.com/whatwg/fetch/issues/new">file an issue</a>,
<a href="https://github.com/whatwg/fetch/issues">open issues</a>)
</dd>
	<dd>
<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>
</dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/fetch/commits">GitHub whatwg/fetch/commits</a></dd>
	<dd><a href="https://fetch.spec.whatwg.org/commit-snapshots/cbca2c2f3a37084e336e14348de683f8ffa0fed9/" id="commit-snapshot-link">Snapshot as of this commit</a></dd>
	<dd><a href="https://twitter.com/fetchstandard">@fetchstandard</a></dd>

	<dt>Tests:</dt>
	<dd><a href="https://github.com/w3c/web-platform-tests/tree/master/fetch">web-platform-tests fetch/</a> (<a href="https://github.com/w3c/web-platform-tests/labels/fetch">ongoing work</a>)</dd>

	<dt>各国語翻訳（非規範的）</dt>
	<dd>日本語（このページ）</dd>
</dl>


</header>

	<section id="abstract">

<h2 title="Abstract">要約</h2>

<p>
Fetch 標準は、要請（ request ）, 応答（ response ）, および
この２つを束縛する処理
— fetching （リソース取得 処理） —
を定義する。
<span lang="en">
The Fetch standard defines requests, responses, and the process that binds them: fetching.
</span></p>

<p class="trans-note">【
“fetch” — 一般英語の語義としては（どこか離れた所から） “取って来る”。
ネット上のリソース取得アクセスには、伝統的にこの語が利用されているようだ（とは言え、この仕様の文脈においては， HTTP GET のみに限られるわけではない）。
単なる “取得” では語義が広過ぎるので（ “get”, “obtain”, “retrieve” 等々）、訳語としては “<em>リソース取得</em>” , 動詞的用法であれば “<em >取得をかける</em>” が相応しく感じられるが、この訳では原語のままとする。
】【
この仕様のカタカナで記されていない多くの用語は、定訳が存在しない訳者による造語である。
】</p>

	</section>

<main id="MAIN" style="display:none;">

	<section id="goals">

<h2 title="Goals">目標</h2>

<p>
~web~platformにおける~fetchingを統一化するため、この仕様は，いくつかの~algoと仕様に取って代わる：
◎
To unify fetching across the web platform this specification supplants a number of algorithms and specifications:
</p>

<ul>
	<li>
~HTML標準の［
fetch, および
potentially CORS-enabled fetch
］~algo
!HTML$r

!<a href="~TR/html5/infrastructure.html#fetch">fetch</a>, <a href="~TR/html5/infrastructure.html#potentially-cors-enabled-fetch">potentially CORS-enabled fetch</a>^tnote
◎
HTML Standard’s fetch and potentially CORS-enabled fetch algorithms [HTML]
</li>
	<li>
CORS
!CORS$r
!Cross-Origin Resource Sharing — “生成元~間をまたがる資源の共有”^tnote
◎
CORS [CORS]
</li>
	<li>
~HTTP !Origin$h ~headerの意味論
!ORIGIN$r
◎
HTTP `Origin` header semantics [ORIGIN]
</li>
</ul>

<p>
~fetchingの統一化は、次に対する，一貫した取扱いを提供する：
◎
Unifying fetching provides consistent handling of:
</p>

<ul>
	<li>
種々の~URL~scheme
◎
URL schemes
	</li>
	<li>
~redirect
◎
Redirects
</li>
	<li>
非同一生成元（ cross-origin †）の意味論
<p class="trans-note">【
† “生成元~間をまたがる”
— この訳では，この語の対訳に “非同一生成元” を用いる（字義通り，同一生成元（ same-origin ）の否定の意味でもあるので）。
<small>馴染みが悪ければ，ウィンドウ下端のボタンで対訳を切り替えられたし。</small>
】</p>
◎
Cross-origin semantics
</li>
	<li>CSP !CSP$r</li>
	<li>Service workers !SW$r</li>
	<li>Mixed Content !MIX$r</li>
	<li>!Referer$h !REFERRER$r</li>
</ul>

	</section>
	<section id="preface">
<h2 title="Preface">1. 序</h2>

<p>
資源の~fetchingは、高~levelから見れば，それなりに単純な演算である
— 要請を送って，応答が返ってくる。
<!--You can’t explain that! -->
しかしながら，その演算の詳細は、様々なものと~~複雑に入り組んでいるため 注意深く書き下ろされていなかったのが常であり，~APIの~~世代ごとに異なっている。
◎
At a high level, fetching a resource is a fairly simple operation. A request goes in, a response comes out. The details of that operation are however quite involved and used to not be written down carefully and differ from one API to the next.
</p>

<p>
数多くの~APIが資源を~fetchする能を提供する
— 例えば、
~HTMLの !img^e, !script^e 要素 ／
~CSSの !cursor^css, !list-style-image^css ／
~JS~APIの !navigator.sendBeacon()$m, !self.importScripts()^m
など。
~Fetch標準は、これらの特色機能のための統一化された~architectureを提供する
— それらすべてが、~redirectや CORS ~protocolなど，~fetchingの種々の側面に関して一貫するように。
◎
Numerous APIs provide the ability to fetch a resource, e.g. HTML’s img and script element, CSS' cursor and list-style-image, the navigator.sendBeacon() and self.importScripts() JavaScript APIs. The Fetch Standard provides a unified architecture for these features so they are all consistent when it comes to various aspects of fetching, such as redirects and the CORS protocol.
</p>

<p>
~Fetch標準は、 !fetch()$m ~JS~APIも定義する。
それは、~networkingの機能性のほとんどを，~~適度に低~levelな抽象化の下で公開する。
◎
The Fetch Standard also defines the fetch() JavaScript API, which exposes most of the networking functionality at a fairly low level of abstraction.
</p>

	</section>
	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ε, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
手続きの中で括弧に括られて現れる句
“（例外投出あり）”
は、その段の演算において例外が投出され得ることを意味する（例外は再投出され、手続きはそこで終わる）。
</p>

<p>
~CSPは、 “Content Security Policy” !CSP$r （ “内容保安施策” ）の略語である。
</p>

<p>
便宜のため、この仕様にて定義されていない，ほとんどの［
~HTTP~header名 ／ ~HTTP~method名 ／ ~HTTP応答~status~code／ !~CSP指令$
］には、それを規定する仕様（和訳）へのリンクを追加している（これらのリンクは、原文~仕様にはあてがわれていない）。
</p>

<p>
!~promise型$idl ~objに対する次の句は、
<a href="~PROMISES">Writing Promise-Using Specifications</a>
にて定義されている：
</p>

<ul ><li>!解決する@（
<a href="~PROMISES#resolve-promise">resolve</a>
）
</li><li>!却下する@（
<a href="~PROMISES#reject-promise">reject</a>
）
</li><li>!新たな~promise@（
<a href="~PROMISES#a-new-promise">a new promise</a>
）
</li><li>!充足~時には@（
<a href="~PROMISES#upon-fulfillment">upon fulfillment</a>
）
</li><li>!却下~時には@（
<a href="~PROMISES#upon-rejection">upon rejection</a>
）
</li><li>!変形する@（
<a href="~PROMISES#transforming-by">transforming</a>
）
</li></ul>


	</section>
	<section id="terminology">

<h2 title="Infrastructure">2. 基盤</h2>

<p>
この仕様は Infra Standard に依存する。
!INFRA$r
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様は、各種~標準
!ABNF$r
!ENCODING$r
!HTML$r
!HTTP$r
!WEBIDL$r
!STREAMS$r
!URL$r
からの用語を流用する。
◎
This specification uses terminology from the ABNF, Encoding, HTML, HTTP, IDL, Streams, and URL Standards. [ABNF] [ENCODING] [HTML] [HTTP] [WEBIDL] [STREAMS] [URL]
</p>

<p>
!~ABNF@
は、~HTTPにより改変された~ABNFを意味する（特に， # の追加
!† RFC7230, <a href="~7230#section-7">7 節</a>^tnote
）。
◎
ABNF means ABNF as modified by HTTP (in particular the addition #).
</p>

<hr>


<p>
!資格証@
は、［
~HTTP~cookie, ~TLS~client証明書, !認証~entry$
］である。
◎
Credentials are HTTP cookies, TLS client certificates, and authentication entries.
</p>

<hr>


<p>
この標準により!待入され$る!~task$は、次のいずれかとして，~~記される：
<!-- annotated -->
◎
Tasks that are queued by this standard are annotated as one of:
</p>

<ul>
	<li>
!要請の本体を処理する@
◎
process request body
</li>
	<li>
!要請の本体終端を処理する@
◎
process request end-of-body
</li>
	<li>
!応答を処理する@
◎
process response
</li>
	<li>
!応答の本体終端を処理する@
◎
process response end-of-body
</li>
	<li>
!応答の~doneを処理する@
◎
process response done
</li>
</ul>

<p class="trans-note">【
これらの~task（ “〜を処理する” ）は、この仕様に定義される~fetchingを利用する他の仕様（例えば !XHR$r ）が，個々の必要に応じて それぞれに定義するものになる（一種の callback ）。
】</p>


<p class="algo-head">
!要請$ %要請 上で［
所与の %演算 を走らす
］ための
!~fetch~taskを待入する@
ときは、次を走らす：
◎
To queue a fetch task on request request to run an operation, run these steps:
</p>

<ol>
	<li>
~IF［
%要請 の!~client$rq ~NEQ ~NULL
］
⇒
~RET
◎
If request’s client is null, terminate these steps.
</li>
	<li>
!~network用~task源$を用いて，
%要請 の!~client$rqの!担当の~event-loop$enV上に，
%演算 を走らすための!~taskを待入する$。
◎
Queue a task to run an operation on request’s client’s responsible event loop using the networking task source.
</li>
</ol>


<p class="algo-head">
所与の %要請 に対する
!~fetch要請~done~taskを待入する@
ときは、［
%要請 上で!要請の本体終端を処理する$
］ための!~fetch~taskを待入する$。
◎
To queue a fetch-request-done task, given a request, queue a fetch task on request to process request end-of-body for request.
</p>

		<section id="url">
<h3 title="URL">2.1. ~URL</h3>

<p>
!~scheme$urlのうち，
!about^l, !blob^l, !data^l, !filesystem^l
を
!局所~scheme@
という。
◎
A local scheme is a scheme that is "about", "blob", "data", or "filesystem".
</p>

<p>
!~scheme$urlが!局所~scheme$であるような!~URL$は，
!局所的@
であるという。
◎
A URL is local if its scheme is a local scheme.
</p>

<p class="note">注記：
この定義は
!Referrer Policy^cite !REFERRER$r
からも利用される。
◎
This definition is also used by Referrer Policy. [REFERRER]
</p>


<p>
!~scheme$urlのうち，
!http^l, !https^l
を
!~HTTP_S~scheme@
という。
◎
An HTTP(S) scheme is a scheme that is "http" or "https".
</p>


<p>
!~scheme$urlのうち，
!ftp^l, !~HTTP_S~scheme$
を
!~network~scheme@
という。
◎
A network scheme is a scheme that is "ftp" or an HTTP(S) scheme.
</p>


<p>
!~scheme$urlのうち，
!about^l, !blob^l, !data^l, !file^l, !filesystem^l, !~network~scheme$
を
!~fetch~scheme@
という。
◎
A fetch scheme is a scheme that is "about", "blob", "data", "file", "filesystem", or a network scheme.
</p>


<p class="note">注記：
!~network~scheme$, !~HTTP_S~scheme$, !~fetch~scheme$
は~HTMLからも利用される。
!HTML$r
◎
HTTP(S) scheme, network scheme, and fetch scheme are also used by HTML. [HTML]
</p>


<hr>

<p>
!応答~URL@
は、実装は!素片$urlを格納する必要はないような，!~URL$である
— それは、決して~APIに公開されないので。
!~url直列化器$urlにかけられるときには、 %素片除外~flag は ~ON にされる†
— すなわち実装は、それにかまわず，!素片$urlを格納できる。
<span class="trans-note">【†
具体的には、 !Response$I ~objの !url^m 属性を取得するとき。
】</span>
◎
A response URL is a URL for which implementations need not store the fragment as it is never exposed. When serialized, the exclude fragment flag is set, meaning implementations can store the fragment nonetheless.
</p>

		</section>
		<section id="http">
<h3 title="HTTP">2.2. ~HTTP</h3>

<p>
!~fetching$は，単なる~HTTP以上の範囲を対象にするが、~HTTPからいくつかの概念を流用し，それらを他の手段（例えば !data^c ~URL）を通して得られた資源に対してもあてはめる。
◎
While fetching encompasses more than just HTTP, it borrows a number of concepts from HTTP and applies these to resources obtained via other means (e.g., data URLs).
</p>

<p>
!~HTTP空白~byte列@
は、それを成す どの~byte %byte も次を満たす~byte列である
⇒
%byte ~IN { !09^X, !0A^X, !0D^X, !20^X }
◎
The HTTP whitespace bytes are 0x09, 0x0A, 0x0D, and 0x20.
</p>

<p>
!~HTTPS状態~値@
は、［
!none^l, !deprecated^l, !modern^l
］のいずれかをとる。
◎
An HTTPS state value is "none", "deprecated", or "modern".
</p>

<p class="note">注記：
~HTTPSを通じて送達される!応答$の!~HTTPS状態$rsは、概して， !modern^l に設定される。
~UAは、過渡期においては !deprecated^l を利用できる。
例えば［
~hash関数 ／
弱い暗号suite ／
"Internal Name" 用の証明書 ／
有効期間が長過ぎる証明書
］の~supportを除去するまでの間など。
~UAが，正確にどの~~程度まで !deprecated^l を利用できるかは、この仕様では定義されない。
!環境~設定群~obj$は、概して!応答$から その!~HTTPS状態$enVを送達する。
<!-- ＊どこへ？ -->
◎
A response delivered over HTTPS will typically have its HTTPS state set to "modern". A user agent can use "deprecated" in a transition period. E.g., while removing support for a hash function, weak cypher suites, certificates for an "Internal Name", or certificates with an overly long validity period. How exactly a user agent can use "deprecated" is not defined by this specification. An environment settings object typically derives its HTTPS state from a response.
</p>


			<section id="methods">
<h4 title="Methods">2.2.1. ~method</h4>

<p>
!~method@
は、 !method$p ~token生成規則に合致する~byte列である。
!HTTP の文脈では， <a href="~7231#section-4">要請~method</a> を表現する。^tnote
◎
A method is a byte sequence that matches the method token production.
</p>

<p>
!~CORS安全な~method@
は、次のいずれかの!~method$である
⇒
!GET$hm, !HEAD$hm, !POST$hm
◎
A CORS-safelisted method is a method that is `GET`, `HEAD`, or `POST`.
</p>

<p>
!禁止~method@
は、次のいずれかに!~byte大小無視$で合致する!~method$である
⇒
!CONNECT$hm, !TRACE$hm, !TRACK$hm

!HTTPVERBSEC1$r
!HTTPVERBSEC2$r
!HTTPVERBSEC3$r
◎
A forbidden method is a method that is a byte-case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`. [HTTPVERBSEC1], [HTTPVERBSEC2], [HTTPVERBSEC3] 
</p>


<p class="algo-head">
!~method$ %M を
!正規化-@md
するときは、［
%M が次のいずれかに!~byte大小無視$で合致する
］ならば， %M を!~byte大文字~化$する
⇒
!DELETE$hm, !GET$hm, !HEAD$hm, !OPTIONS$hm, !POST$hm, !PUT$hm
◎
To normalize a method, if it is a byte-case-insensitive match for `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST`, or `PUT`, byte-uppercase it.
</p>

<p class="note">注記：
!~method$は実際には “大小区別” であるが、各種~API間の 後方互換性と一貫性をとるため，!正規化-$mdが行われる。
◎
Normalization is done for backwards compatibility and consistency across APIs as methods are actually "case-sensitive".
</p>

<p class="example" id="example-normalization">
!patch^hm を利用した結果は、ほぼ間違いなく
!405 Method Not Allowed^bl になるであろう。
!PATCH^hm の方がずっと成功する見込みが高い。
◎
Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.
</p>

<p class="note">注記：
!~method$に制約はない。
!CHICKEN^hm （ !CHECKIN^hm の誤記ではない）でも，まったく受容可能である。
!正規化-$mdされるものを除き、文字大小についての制約もない。
一貫性のため，大文字が奨励されるが、 !Egg^hm や !eGg^hm でもかまわない。
◎
There are no restrictions on methods. `CHICKEN` is perfectly acceptable (and not a misspelling of `CHECKIN`). Other than those that are normalized there are no casing restrictions either. `Egg` or `eGg` would be fine, though uppercase is encouraged for consistency.
</p>


			</section>
			<section id="terminology-headers">
<h4 title="Headers">2.2.2. ~header</h4>

<p>
!~header~list@
は、ゼロ個以上の!~header$からなる。

!~HTTPの文脈では，~messageの<a href="~7230#section-3">~header節</a>を表現する。^tnote
◎
A header list consists of zero or more headers.
</p>

<p class="note">注記：
!~header~list$は、本質的には特化された ~multimap
— すなわち，何個かの ( ~key: 値 ) ~pairからなる有順序~listであって，~keyが重複し得るものである。
◎
A header list is essentially a specialized multimap. An ordered list of key-value pairs with potentially duplicate keys.
</p>

<p>
所与の!名前$hd（または!~byte列$） %名前 を
!名前に持つ~header@
とは、!~header$であって，その!名前$hdが［
!~byte大小無視$で %名前 に合致する
］ものを指す。
</p>

<p class="trans-note">【
言い換えれば、!~header$の!名前$hdは，常に!~byte大小無視$で比較される
— 元々の~HTTP~protocolが，~header名の文字大小を区別しないので。
】</p>


<p>
!~header~list$ %~list が所与の!名前$hd %名前 を
!包含-@
するとは、
%~list 内に %名前 を!名前に持つ~header$が在ることをいう。
◎
A header list (list) contains a name (name) if list contains a header whose name is a byte-case-insensitive match for name.
</p>

<p class="trans-note">【
日本語表現の都合により、この訳では，この用語は利用せず、もっぱら
“!名前に持つ~header$”
を用いて等価に記すことにする。
】</p>

<p class="algo-head">
!~header~list$ %~list に
( !名前$hd %name / !値$hd %value )
の組を
!付加-@hl
するときは、次を走らす：
◎
To append a name/value (name/value) pair to a header list (list), run these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~list 内に［
%name を!名前に持つ~header$
］は在る
］
⇒
%name ~SET そのような!~header$のうち最初のものの!名前$hd
◎
If list contains name, then set name to the first such header’s name.
</p>

<p class="note">
これは、!~header~list$内に該当する!~header$がすでにあれば，その!名前$hdの文字大小を再利用させる。
該当する~headerが複数あれば、それらすべての名前は同じ文字大小にされることになる。
◎
This reuses the casing of the name of the header already in the header list, if any. If there are multiple matched headers their names will all be identical.
</p>
	</li>
	<li>
!新たな~header$( %name / %value )
を， %~list に付加する
◎
Append a new header whose name is name and value is value to list.
</li>
</ol>


<p class="algo-head">
!~header~list$ %~list から
!名前$hd %name を
!削除-@hl
するときは、
%~list から［
%name を!名前に持つ~header$
］をすべて除去する。
◎
To delete a name (name) from a header list (list), remove all headers whose name is a byte-case-insensitive match for name from list.
</p>


<p class="algo-head">
!~header~list$ %~list の中で
( !名前$hd %name / !値$hd %value )
の組を
!設定-@hl
するときは、次を走らす：
◎
To set a name/value (name/value) pair in a header list (list), run these steps:
</p>


<ol>
	<li>
~IF［
%~list 内に［
%name を!名前に持つ~header$
］は在る
］
⇒
そのような!~header$のうち
⇒
最初のものに対しては，その!値$hd ~SET %value；<br>
他のものは， %~list から除去する
◎
If list contains name, then set the value of the first such header to value and remove the others.
</li>
	<li>
~ELSE
⇒
!新たな~header$( %name / %value )
を， %~list に付加する
◎
Otherwise, append a new header whose name is name and value is value to list.
</li>
</ol>

<p class="algo-head">
!~header~list$ %~list の中で
( !名前$hd %name / !値$hd %value )
の組を
!結合-@hl
するときは、次を走らす：
◎
To combine a name/value (name/value) pair in a header list (list), run these steps:
</p>



<ol>
	<li>
~IF［
%~list 内に［
%name を!名前に持つ~header$
］は在る
］
⇒
そのような!~header$のうち，最初のものに対し
⇒
その!値$hdの末尾に［
!2C^X, !20^X, %value
］を順に付加する
◎
If list contains name, then set the value of the first such header to its value, followed by 0x2C 0x20, followed by value.
</li>
	<li>
~ELSE
⇒
!新たな~header$( %name / %value )
を， %~list に付加する
◎
Otherwise, append a new header whose name is name and value is value, to list. 
</li>
</ol>

<p class="note">注記：
!結合-$hlは、もっぱら［
!XMLHttpRequest$I ／
!~WebSocket~protocol~handshakeを確立する$
］のためにある。
◎
Combine is used by XMLHttpRequest and the WebSocket protocol handshake.
</p>

<p class="algo-head">
!~header~list$ %~header~list を
!整列して結合-@hl
するときは、次を走らす：
◎
To sort and combine a header list (list), run these steps:
</p>

<ol>
	<li>
%結果~list ~LET 空~list
◎
Let headers be an empty list of name-value pairs with the key being the name and value the value.
</li>
	<li>
%名前~list ~LET ［［［
%~header~list 内の!~header$すべての!名前$hd
］を，それぞれ!~byte小文字~化$した結果
］から，重複する名前は除去した結果
］を字句順に整列した結果
◎
Let names be all the names of the headers in list, byte-lowercased, with duplicates removed, and finally sorted lexicographically.
</li>
	<li>
<p>
~FOR
%名前~list 内の ~EACH ( %名前 ) に対し：
◎
For each name in names, run these substeps:
</p>

		<ol>
			<li>
%値 ~LET %~header~list 内の %名前 に対する!結合済みの値$hd
◎
Let value be the combined value given name and list.
</li>
			<li>
%結果~list に 次のようにされた~pairを付加する
⇒
( ~key, 値 ) ~SET ( %名前, %値 )
◎
Append name-value to headers.
</li>
		</ol>

	<li>
~RET %結果~list
◎
Return headers.
</li>
</ol>

<hr>

<p>
!~header@
は、
!名前@hd
および
!値@hd
からなる：
◎
A header consists of a name and value.
</p>

<p class="trans-note">【
この仕様を通して、!~header$の［
!名前$hd, !値$hd
］の組, あるいは それを意図して与えられる値の組は、
“( %名前 / %値 )”
のように，スラッシュで区切った上で丸括弧で括られて記される。
】</p>

<ul>
	<li>
<p>
!名前$hdは、 !field-name$p ~token生成規則に合致する!~byte列$である。
</p>

<p class="trans-note">【
ある!名前$hdに!~byte大小無視$で合致する どの!~byte列$も、!名前$hdになる。
】</p>
◎
A name is a byte sequence that matches the field-name token production.
</li>
	<li>
<p>
!値$hdは、次の両~条件に合致する!~byte列$である：
◎
A value is a byte sequence that matches the following conditions:
</p>
		<ul>
			<li>
頭部にも尾部にも !~HTTP空白~byte列$はない。
◎
Has no leading or trailing HTTP whitespace bytes.
</li>
			<li>
~byte !00^X, !0A^X, !0D^X は包含しない。
◎
Contains no 0x00, 0x0A or 0x0D bytes.
</li>
		</ul>

<p class="note">注記：
!値$hdの定義は、~HTTP~token生成規則を通しては定義されていない
— <a href="https://github.com/httpwg/http11bis/issues/19">それは壊れている</a>
。
◎
The definition of value is not defined in terms of an HTTP token production as it is broken.
</p>

	</li>
</ul>

<p>
!新たな~header@( %名前 / %値 )
という表記は、
( !名前$hd / !値$hd ) ~SET ( %名前 / %値 )
にされた，新たな!~header$を意味する。
!この表記は、この訳による追加。^tnote
</p>


<p class="algo-head">
所与の!~byte列$ %値 を
!正規化-@hd
するときは、 %値 から頭部と尾部の!~HTTP空白~byte列$を除去する。
◎
To normalize a potentialValue, remove any leading and trailing HTTP whitespace bytes from potentialValue.
</p>

<p class="algo-head">
!~header~list$ %~header~list 内の
所与の!名前$hd %名前
に対する
!結合済みの値@hd
とは、 %~header~list 内の［
%名前 を!名前に持つ~header$
］すべての!値$hdを互いに［
!2C^X !20^X
］並びで区切って順に連結したものである。
◎
A combined value, given a name (name) and header list (list), is the values of all headers in list whose name is a byte-case-insensitive match for name, separated from each other by 0x2C 0x20, in order.
</p>

<hr>

<p>
!~CORS安全な要請~header@
とは、次のいずれかを満たす!~header$である：
◎
A CORS-safelisted request-header is a header whose name is a byte-case-insensitive match for one of
</p>

<ul>
	<li>
［
!Accept$h ／ !Accept-Language$h ／ !Content-Language$h
］を!名前に持つ~header$
◎
• `Accept`
• `Accept-Language`
• `Content-Language`
</li>
	<li>
!Content-Type$h を!名前に持つ~header$であって，その!~header値を抽出-$hdした結果の~MIME型は（~parameterは無視して）［
!application/x-www-form-urlencoded^bl,
!multipart/form-data^bl,
!text/plain^bl
］のいずれかになるもの
］
◎
`Content-Type` and whose value, once extracted, has a MIME type (ignoring parameters) that is `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain`
</li>
	<li>
［
!DPR$h ／
!Downlink$h ／
!Save-Data$h ／
!Viewport-Width$h ／
!Width$h
］を!名前に持つ~header$であって，［
その!~header値を抽出-$hdした結果 ~NEQ !失敗^i
］なるもの
◎
or whose name is a byte-case-insensitive match for one of
• `DPR`
• `Downlink`
• `Save-Data`
• `Viewport-Width`
• `Width` 
and whose value, once extracted, is not failure.
</li>
</ul>

<p>
!~CORS非~wildcard要請~header名@
は、［
!Authorization^bl に!~byte大小無視$で合致する!名前$hd
］である。
◎
A CORS non-wildcard request-header name is a byte-case-insensitive match for `Authorization`.
</p>

<p>
所与の!~CORSに公開される~header名~list$rs
%~list 内の
!~CORS安全な応答~header名@
とは、［
次に挙げるいずれかの!名前$hdに!~byte大小無視$で合致する!名前$hd
］である：
◎
A CORS-safelisted response-header name, given a CORS-exposed header-name list list, is a header name that is a byte-case-insensitive match for one of
</p>

<ul ><li>!Cache-Control$h
</li><li>!Content-Language$h
</li><li>!Content-Type$h
</li><li>!Expires$h
</li><li>!Last-Modified$h
</li><li>!Pragma$h
</li><li>%~list 内の!禁止~応答~header名$でない!値$hd
◎
Any value in list that is not a forbidden response-header name.
</li></ul>

<p>
次に挙げる!名前$hdは、
!禁止~header名@
とされる：
◎
A forbidden header name is a header name that is a byte-case-insensitive match for one of
</p>

<ul>
	<li>
<p>
次に挙げるいずれかの!名前$hdに!~byte大小無視$で合致するもの：
</p>

<ul ><li>!Accept-Charset$h
</li><li>!Accept-Encoding$h
</li><li>!Access-Control-Request-Headers$h
</li><li>!Access-Control-Request-Method$h
</li><li>!Connection$h
</li><li>!Content-Length$h
</li><li>!Cookie$h
</li><li>!Cookie2^h
</li><li>!Date$h
</li><li>!DNT^h
!<a href="~IETF/draft-mayer-do-not-track-00">Do Not Track</a>^tnote
</li><li>!Expect$h
</li><li>!Host$h
</li><li>!Keep-Alive$h
</li><li>!Origin$h
</li><li>!Referer$h
</li><li>!TE$h
</li><li>!Trailer$h
</li><li>!Transfer-Encoding$h
</li><li>!Upgrade$h
</li><li>!Via$h
</li></ul>

	<li>
頭部が［
!Proxy-^h, !Sec-^h
］のいずれかに!~byte大小無視$で合致するもの（合致する頭部が全体であるものも含む）。
◎
or a header name that starts with a byte-case-insensitive match for `Proxy-` or `Sec-` (including being a byte-case-insensitive match for just `Proxy-` or `Sec-`).
</li>
</ul>

<p class="note">注記：
これらは、全部的に~UAの制御~下に留め置くため，禁止される。
!Sec-^h で始まる!名前$hdは、~APIから安全に［
!XMLHttpRequest$I
などの，開発者による制御が許容される!~header$が含まれた!~fetch$
］を行えるような，新種の!~header$を創出できるようにするため、予約されている。
!XHR$r
◎
These are forbidden so the user agent remains in full control over them. Names starting with `Sec-` are reserved to allow new headers to be minted that are safe from APIs using fetch that allow control over headers by developers, such as XMLHttpRequest. [XHR]
</p>


<p>
［
次に挙げるいずれかの!名前$hdに!~byte大小無視$で合致するもの
］は、
!禁止~応答~header名@
とされる：
◎
A forbidden response-header name is a header name that is a byte-case-insensitive match for one of:
</p>

<ul ><li>!Set-Cookie$h
</li><li>!Set-Cookie2^h
</li></ul>


<hr>

<p class="algo-head">
所与の!~header$ %~header から
!~header値を抽出-@hd
するときは、次を走らす：
◎
To extract header values given a header header, run these steps:
</p>

<ol>
	<li>
%~header の!値$hdを［
%~header の!名前$hdに対する!~ABNF$
］に従って構文解析する
! RFC7230, <a href="~7230#section-3.2.4">2.2.4 節</a>^tnote
◎
If parsing header’s value, per the ABNF for header’s name, fails, then return failure.
</li>
	<li>
~RET［
前~段に失敗したならば !失敗^i ／
~ELSE_ 前~段による結果の 1 個以上の!値$hd
］
◎
Return one or more values resulting from parsing header’s value, per the ABNF for header’s name.
</li>
</ol>


<p class="algo-head">
所与の!~header~list$ %~header~list から
!名前$hd %名前 に対する
!~header~list値を抽出-@hd
するときは、次を走らす：
◎
To extract header list values given a name (name) and a header list (list), run these steps:
</p>

<ol>
	<li>
%~list ~LET %~header~list 内の［
%名前 を!名前に持つ~header$
］すべてからなる~list
◎
↓</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET ~NULL
◎
If list does not contain name, then return null.
</li>
	<li>
<p>
~IF ［［
%名前 に対する!~ABNF$
］にて許容されている!~header$の個数 は 1 個†
］~AND［
%~list 内に複数の!~header$がある
］
⇒
~RET !失敗^i
◎
If the ABNF for name allows a single header and list contains more than one, then return failure.
</p>


<p class="note">注記：
異なる~errorの取扱いが必要な場合†2、事前に~~目的の!~header$を抽出すること。
◎
If different error handling is needed, extract the desired header first.
</p>

<p class="trans-note">【†1
— RFC7230, <a href="~7230#section-3.2.2">2.2.2 節</a>
】【†2
— 同じ 2.2.2 節の注記を指しているようにも思われるが、他にも該当する事例はあるかもしれない。
】</p>

	</li>
	<li>
%値~list ~LET 空!~list$
◎
Let values be an empty list.
</li>
	<li>
<p>
%~list 内の ~EACH ( !~header$ %~header ) に対し：
◎
For each header header list contains whose name is name, run these substeps:
</p>
		<ol>
			<li>
%抽出- ~LET
%~header から!~header値を抽出-$hdした結果
◎
Let extract be the result of extracting header values from header.
</li>
			<li>
~IF［
%抽出- ~EQ !失敗^i
］
⇒
~RET !失敗^i
◎
If extract is failure, then return failure.
</li>
			<li>
%抽出- 内の各 !値$hdを順に， %値~list に付加する
◎
Append each value in extract, in order, to values.
</li>
		</ol>
	</li>
	<li>
~RET %値~list†
◎
Return values.
</li>
</ol>

<p class="trans-note">【†
%名前 に対する!~ABNF$が複数個の値を許容しない, かつ
%名前 を!名前に持つ~header$は!~header~list$内に複数~存在できない場合、この手続きを呼出している箇所では，結果の %値~list は暗黙的に その最初の値と同一視されている。
】</p>


<p class="algo-head">
!~header~list$ %~header~list から
!~MIME型を抽出-@hd
するときは、次を走らす：
◎
To extract a MIME type from a header list (headers), run these steps:
</p>

<ol>
	<li>
%~MIME型 ~LET
%~header~list から
!Content-Type$h
に対する!~header~list値を抽出-$hdした結果
◎
Let mimeType be the result of extracting header list values given `Content-Type` and headers.
</li>
	<li>
~IF［
%~MIME型 ~IN { ~NULL, !失敗^i }
］
⇒
~RET 空~byte列
◎
If mimeType is null or failure, then return the empty byte sequence.
</li>
	<li>
~RET %~MIME型 を!~byte小文字~化$した結果
◎
Return mimeType, byte-lowercased.
</li>
</ol>


<hr>

<p>
!既定の User-Agent 値@
とは、~UAが !User-Agent$h !~header$用に定義する!値$hdである。
◎
A default `User-Agent` value is a user-agent-defined value for the `User-Agent` header.
</p>


			</section>
			<section id="statuses">
<h4 title="Statuses">2.2.3. ~status</h4>



<p>
!~status@
は~codeである。
◎
A status is a code.
</p>

<p>
次の!~status$は、
!~null本体~status@
であるとされる
⇒
!101$st ／ !204$st ／ !205$st ／ !304$st
◎
A null body status is a status that is 101, 204, 205, or 304.
</p>

<p>
次の範囲の!~status$は、
!~ok~status@
であるとされる
⇒
!200^st 〜 !299^st
◎
An ok status is any status in the range 200 to 299, inclusive.
</p>

<p>
次の!~status$は、
!~redirect~status@
であるとされる
⇒
!301$st ／ !302$st ／ !303$st ／ !307$st ／ !308$st
◎
A redirect status is a status that is 301, 302, 303, 307, or 308. 
</p>


			</section>
			<section id="bodies">
<h4 title="Bodies">2.2.4. 本体</h4>

<p>
!本体@
（ body ）は、次のものからなる：
◎
A body consists of:
</p>

<dl class="def-list">
	<dt>!~stream@bd</dt>
	<dd>
~NULL または !~ReadableStream$ ~obj。
◎
A stream (null or a ReadableStream object).
</dd>

	<dt>!伝送済み~byte数@bd</dt>
	<dd>
整数
— 初期~時は 0 。
◎
A transmitted bytes (an integer), initially 0.
</dd>

	<dt>!総~byte数@bd</dt>
	<dd>
整数
— 初期~時は 0 。
◎
A total bytes (an integer), initially 0.
</dd>

	<dt>!~source@bd</dt>
	<dd>
初期~時は ~NULL 。
◎
A source, initially null.
</dd>

</dl>

<p class="trans-note">【
~HTTPの文脈では、本体は，~messageの<a href="~7230#section-3.3">~payload本体</a>を表現する。
】</p>


<div class="p">
<p>
!本体$ %本体 は、次のいずれかであるとき，
!~done@bd
であるという：
</p>

<ul>
	<li>
%本体 ~EQ ~NULL
</li>
	<li>
%本体 の!~stream$bd は，［
!~closeされた$RSか, !~errorが生じ$RSた
］
</li>
</ul>

◎
A body body is said to be done if body is null or body’s stream is closed or errored.
</div>

<p class="algo-head">
!本体$ %本体 を
!待機-@bd
するときは、 %本体 が!~done$bdになるまで，待機する
◎
To wait for a body body, wait for body to be done.
</p>

<p class="algo-head">
!本体$ %本体 を
!~clone@bd
するときは、次を走らす：
◎
To clone a body body, run these steps:
</p>

<ol>
	<li>
«%out1, %out2» ~LET
%本体 の!~stream$bdを!二叉化$RSした結果（例外投出あり）
◎
Let «out1, out2» be the result of teeing body’s stream. Rethrow any exceptions.
</li>
	<li>
%本体 の!~stream$bd ~SET %out1
◎
Set body’s stream to out1.
</li>
	<li>
~RET 次のようにされた新たな!本体$
⇒
!~stream$bd ~SET %out2；<br>
他の~memberは %本体 から複製する
◎
Return a body whose stream is out2 and other members are copied from body.
</li>
</ol>


<p class="algo-head">
( 内容~符号法s† %符号法s, ~byte列 %~byte列 )
が与えられた下で，
!内容~符号法sを取扱う@
ときは、次を走らす
!†<a href="~7231#section-3.1.2.1">content codings</a> — 複数の内容~符号法が重ねて適用されることもあり得る^tnote
：
◎
To handle content codings given codings and bytes, run these substeps:
</p>

<ol>
	<li>
~IF［
%符号法s  !内のいずれかの符号法^tnote は~supportされていない
］
⇒
~RET %~byte列
◎
If codings are not supported, return bytes.
</li>
	<li>
~RET ~HTTPに従って， %~byte列 を %符号法s で復号した結果
!HTTP$r
!HTTP-SEMANTICS$r
!HTTP-COND$r
!HTTP-CACHING$r
!HTTP-AUTH$r
◎
Return the result of decoding bytes with the given codings as explained in HTTP. [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]
</li>
</ol>

<!-- XXX no hook in HTTP -->

			</section>
			<section id="requests">

<h3 title="Requests">2.2.5. 要請</h3>

<p>
!要請@
（ request ）とは、!~fetch$ に対する入力である。
◎
The input to fetch is a request.
</p>

<p>
!要請$には、以下に挙げるものが結付けられる。
各~項には，それがとり得る値の種類を示す。
他が定められない限り、［
見出しの括弧内に与える値
］を既定~値としてとるものとする：
◎
↓</p>

<dl class="def-list">
	<dt>!~method@rq（ !GET$hm ）</dt>
	<dd>
!~method$。
◎
A request has an associated method (a method). Unless stated otherwise it is `GET`.
</dd>
	<dd class="note">注記：
これは、!~HTTP~fetch$にて述べるように，~redirectの間に !GET$hm に更新され得る。
◎
This can be updated during redirects to `GET` as described in HTTP fetch.
</dd>

	<dt>!~url@rq</dt>
	<dd>
!~URL$。
◎
A request has an associated url (a URL).
</dd>
	<dd class="note">注記：
実装には、これが!要請$の!~url~list$rq内の最初の!~URL$を指すようにすることが奨励される。
これはもっぱら、~Fetchの中へ~hookする他の標準の便宜のため，別個の~fieldとして提供されている。
◎
Implementations are encouraged to make this a pointer to the first URL in request’s url list. It is provided as a distinct field solely for the convenience of other standards hooking into Fetch.
</dd>
	<dd class="trans-note">【
資源の~fetch先
— ~HTTPの文脈では， <a href="~7230#section-5.3">要請 target</a> に対応する。
】</dd>

	<dt>!局所URLonly~flag@（ ~OFF ）</dt>
	<dd>
~flag値。
◎
A request has an associated local-URLs-only flag. Unless stated otherwise it is unset.
</dd>

	<dt>!~sandboxed-storage-area-URLs~flag@（ ~OFF ）</dt>
	<dd>
~flag値。
◎
A request has an associated sandboxed-storage-area-URLs flag. Unless stated otherwise it is unset. 
</dd>

	<dt>!~header~list@rq（ 空~list ）</dt>
	<dd>
!~header~list$。
◎
A request has an associated header list (a header list). Unless stated otherwise it is empty.
</dd>

	<dt>!非安全-要請~flag@rq（ ~OFF ）</dt>
	<dd>
~flag値。
◎
A request has an associated unsafe-request flag. Unless stated otherwise it is unset.
</dd>
	<dd class="note">注記：
!非安全-要請~flag$rqは、供された!~method$rqと!~header~list$rqに基づいて !~CORS予行~fetch$が行われるようにするために，
!fetch()$m や
!XMLHttpRequest$I
などの~APIにより ~ON にされる。
これは、~APIにおいて!禁止~method$や!禁止~header名$を~~合法にするものではない。
◎
The unsafe-request flag is set by APIs such as fetch() and XMLHttpRequest to ensure a CORS-preflight fetch is done based on the supplied method and header list. It does not free an API from outlawing forbidden methods and forbidden header names.
</dd>

	<dt>!本体@rq（ ~NULL ）</dt>
	<dd>
~NULL または!本体$。
◎
A request has an associated body (null or a body). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
これは、!~HTTP~fetch$にて述べるように，~redirectの間に ~NULL に更新され得る。
◎
This can be updated during redirects to null as described in HTTP fetch.
</dd>

	<dt>!~client@rq</dt>
	<dd>
~NULL または!環境~設定群~obj$。
◎
A request has an associated client (null or an environment settings object).
</dd>

	<dt>!予約済み~client@rq （ ~NULL ）</dt>
	<dd>
~NULL または !環境$ または !環境~設定群~obj$。
◎
A request has an associated reserved client (null, an environment, or an environment settings object). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
これが利用されるのは、~navi要請, ~worker要請に限られ，~service-worker要請には利用されない。
それは
!~navi要請$に対しては!環境$ ／
~worker要請に対しては !環境~設定群~obj$
を参照する。
◎
This is only used by navigation requests and worker requests, but not service worker requests. It references an environment for a navigation request and an environment settings object for a worker request.
</dd>

	<dt>!~target~client~id@rq （ 空~文字列 ）</dt>
	<dd>
文字列。
◎
A request has an associated target client id (a string). Unless stated otherwise it is the empty string.
</dd>
	<dd class="note">注記：
これが利用されるのは、~navi要請に限られる。
それは、!~target閲覧文脈$enVの!作動中の文書$の!環境~設定群~obj$の!~id$enVになる。
◎
This is only used by navigation requests. It is the id of the target browsing context’s active document’s environment settings object.
</dd>

	<dt>!~window@rq（ !client^l ）</dt>
	<dd>
次のいずれか
⇒
!no-window^l ／
!client^l ／ ［
!大域~obj$enVは !Window$I である
］ような!環境~設定群~obj$
◎
A request has an associated window ("no-window", "client", or an environment settings object whose global object is a Window object). Unless stated otherwise it is "client".
</dd>
	<dd class="note">注記：
!client^l 値は、!~fetching$の間に［
!no-window^l ／ !要請$の!~client$rq
］に変更される。
この値は、各種~標準が!要請$の!~window$rqを明示的に設定せずに~fetchingを簡便に利用できるようにするためにある。
◎
The "client" value is changed to "no-window" or request’s client during fetching. It provides a convenient way for standards to not have to explicitly set request’s window.
</dd>

	<dt>!~keepalive~flag@rq（ ~OFF ）</dt>
	<dd>
~flag値。
◎
A request has an associated keepalive flag. Unless stated otherwise it is unset.
</dd>
	<dd class="note">注記：
これを利用すれば、要請は!環境~設定群~obj$の外で残存できるようになる
— 例えば［
!navigator.sendBeacon()$m ~meth／~HTML !img$e 要素 ／
!~CSPの<a href="~CSP3#report-violation">違反~報告</a>^tnote
］は、この~flagを ~ON にする。
この~flagが ~ON にされた要請には、追加の処理~要件が課される。
◎
This can be used to allow the request to outlive the environment settings object, e.g., navigator.sendBeacon and the HTML img element set this flag. Requests with this flag set are subject to additional processing requirements. 
</dd>

	<dt>!~service-worker~mode@rq （ !all^l ）</dt>
	<dd>
次のいずれか
⇒
!all^l ／
!foreign^l ／
!none^l
◎
A request has an associated service-workers mode, that is "all", "foreign", or "none". Unless stated otherwise it is "all".
</dd>
	<dd class="note">
<p>注記：
これは、どの~service-workerが，この~fetchに対し !fetch$et ~eventを受取るかを決定する：
◎
This determines which service workers will receive a fetch event for this fetch.
</p>
		<dl>
			<dt>!all^l</dt>
			<dd>
関連する［
局所的 ／ 外来の（ foreign ）
］~service-workerは、この~fetchに対し［
!fetch$et や !foreignfetch$et
］~eventを取得することになる。
◎
Relevant local and foreign service workers will get a fetch or foreignfetch event for this fetch.
</dd>

			<dt>!foreign^l</dt>
			<dd>
関連する外来の~service-workerのみが，この~fetchに対し !foreignfetch$et ~eventを取得することになる。
!fetch(input)$m は、大域~objが !ServiceWorkerGlobalScope$I である場合に，これを利用して現在の~service-workerを迂回する。
◎
Only relevant foreign service workers will get a foreignfetch event for this fetch. fetch(input) uses this to bypass the current service worker if the global is a ServiceWorkerGlobalScope.
</dd>

			<dt>!none^l</dt>
			<dd>
［
局所的 ／ 外来の
］~service-workerは、この~fetchに対する~eventを取得しない。
◎
Neither local nor foreign service workers will get events for this fetch.
</dd>
		</dl>
	</dd>

	<dt>!起動元@rq（ 空~文字列 ）</dt>
	<dd>
次のいずれか
⇒
空~文字列 ／
!download^l ／
!imageset^l ／
!manifest^l ／
!xslt^l
◎
A request has an associated initiator, which is the empty string, "download", "imageset", "manifest", or "xslt". Unless stated otherwise it is the empty string.
</dd>

<dd class="note">注記：
!要請$の!起動元$rqは、さしあたり 特に細分化されてはいない
— 他の仕様からそう要求されてはいないので。
これは~~主に， !CSP$r ／ !MIX$r を定義し易くするために~~導入された~~用語であり、~JSには公開されない。
◎
A request’s initiator is not particularly granular for the time being as other specifications do not require it to. It is primarily a specification device to assist defining CSP and Mixed Content. It is not exposed to JavaScript. [CSP] [MIX]
</dd>


	<dt>!種別@rq（ 空~文字列 ）</dt>
	<dd>
次のいずれか
⇒
空~文字列 ／
!audio^l ／
!font^l ／
!image^l ／
!script^l ／
!style^l ／
!track^l ／
!video^l
◎
A request has an associated type, which is the empty string, "audio", "font", "image", "script", "style", "track", or "video". Unless stated otherwise it is the empty string.
</dd>


	<dt>!行先@rq（ 空~文字列 ）</dt>
	<dd>
次のいずれか
⇒
空~文字列 ／
!audio^l ／
!document^l ／
!embed^l ／
!font^l ／
!image^l ／
!manifest^l ／
!object^l ／
!report^l ／
!script^l ／
!serviceworker^l ／
!sharedworker^l ／
!style^l ／
!track^l ／
!video^l ／
!worker^l ／
!xslt^l
◎
A request has an associated destination, which is the empty string, "audio", "document", "embed", "font", "image", "manifest", "object", "report", "script", "serviceworker", "sharedworker", "style", "track", "video", "worker", or "xslt". Unless stated otherwise it is the empty string.
</dd>

	<dd class="note">
<p>
次の一覧は、!要請$の各種［
!起動元$rq,
!種別$rq,
!行先$rq
］が，どの［
~CSP指令, 特色機能
］から利用されるかを描き出したものである：
◎
The following table illustrates the relationship between a request’s initiator, type, destination, CSP directives, and features.
</p>


<div style="overflow:auto;"><table>
<thead><tr><th>!起動元$rq◎Initiator
<th>!種別$rq◎Type
<th>!行先$rq◎Destination
<th>!~CSP指令$◎CSP directive
<th>特色機能◎Features
</thead>

<tbody>

<tr><td rowspan="16">""
<td rowspan="6">""
<td>!report^l
<td rowspan="2">?
<td>CSP, NEL による報告

<tr><td>!document^l
<td>~HTMLの~navigate~algo

<tr><td>!document^l
<td>!child-src$dir
<td>~HTMLの !iframe$e, !frame$e 要素

<tr><td>""
<td>!connect-src$dir
<td>
!navigator.sendBeacon()^m,
!EventSource^I,
~HTMLの !ping=""^a,
!fetch()$m,
!XMLHttpRequest$I,
!WebSocket$I,
Cache ~API?

<tr><td>!object^l
<td>!object-src$dir
<td>~HTMLの !object$e 要素

<tr><td>!embed^l
<td>!object-src$dir
<td>~HTMLの !embed$e 要素

<tr><td>!audio^l
<td>!audio^l
<td>!media-src$dir
<td>~HTMLの !audio$e 要素

<tr><td>!font^l
<td>!font^l
<td>!font-src$dir
<td>~CSSの <code>@<!-- -->font-face</code>

<tr><td>!image^l
<td>!image^l
<td>!img-src$dir
<td>
~HTMLの !img src^e, !/favicon.ico^c 資源,
SVG の !image^e 要素, ~CSSの［
!background-image^css, !cursor^css, !list-style-image^css
］, …

<tr><td rowspan="4">!script^l
<td>!script^l
<td>!script-src$dir
<td>~HTMLの !script$e 要素, !importScripts()^m

<tr><td>!serviceworker^l
<td>?
<td>!navigator.serviceWorker.register()^m

<tr><td>!sharedworker^l
<td>!child-src$dir
<td>!SharedWorker^I

<tr><td>!worker^l
<td>!child-src$dir
<td>!Worker^I

<tr><td>!style^l
<td>!style^l
<td>!style-src$dir
<td>
~HTMLの !link rel=stylesheet^e,
~CSSの !~at-import^css 規則

<tr><td>!track^l
<td>!track^l
<td>!media-src$dir
<td>~HTMLの !track$e 要素

<tr><td>!video^l
<td>!video^l
<td>!media-src$dir
<td>~HTMLの !video$e 要素

<tr><td>!download^l
<td>""
<td>""
<td>?
<td>~HTMLの !download=""^a, “~link先を保存…” UI

<tr><td>!imageset^l
<td>!image^l
<td>!image^l
<td>!img-src$dir
<td>~HTMLの !img srcset^e, !picture$e 要素

<tr><td>!manifest^l
<td>""
<td>!manifest^l
<td>!manifest-src$dir
<td>~HTMLの !link rel=manifest^e 要素

<tr><td>!xslt^l
<td>""
<td>!xslt^l
<td>!script-src$dir
<td>!&lt;?xml-stylesheet&gt;^c

</tbody></table></div>

<p>
~CSPの !form-action$dir 指令は、直接的に ~HTMLの［
~navigate／~form提出
］~algoに~hookする必要がある。
◎
CSP’s form-action needs to be a hook directly in HTML’s navigate or form submission algorithm.
</p>

<p>
~CSPでは、種々の~CSP指令に対し，［
!要請$の!~client$rqの!担当の閲覧文脈$enV
］の各 !先祖~閲覧文脈$についても検査する必要がある。
◎
CSP will also need to check request’s client’s responsible browsing context’s ancestor browsing contexts for various CSP directives.
</p>

	</dd>


	<dt>!優先度@rq（ ~NULL ）</dt>
	<dd>
~NULL または~UAにより定義される~obj。
!<a href="#_stream-priority">説明</a>^tnote
◎
A request has an associated priority (null or a user-agent-defined object). Unless otherwise stated it is null.
</dd>

	<dt>!生成元@rq（ !client^l ）</dt>
	<dd>
<p>
!client^l, または
!生成元$html。
◎
A request has an associated origin, which is "client" or an origin. Unless stated otherwise it is "client".
</dd>
	<dd class="note">注記：
!client^l は、!~fetching$の間に!生成元$htmlに変化する。
この値は、各種~標準が，!要請$の!生成元$rqを設定せずに~fetchingを簡便に利用できるようにするためにある。
!要請$の!生成元$rqも~redirectの間に変化し得る
◎
"client" is changed to an origin during fetching. It provides a convenient way for standards to not have to set request’s origin. Request’s origin can be changed during redirects too.
</dd>

	<dt>!~referrer@rq（ !client^l ）</dt>
	<dd>
次のいずれか
⇒
!no-referrer^l ／
!client^l ／
!~URL$
◎
A request has an associated referrer, which is "no-referrer", "client", or a URL. Unless stated otherwise it is "client".
</dd>
	<dd class="note">注記：
!client^l は、!~fetching$の間に［
!no-referrer^l ／ !~URL$
］に変化する。
この値は、各種~標準が，!要請$の!~referrer$rqを設定せずに~fetchingを簡便に利用できるようにするためにある。
◎
"client" is changed to "no-referrer" or a URL during fetching. It provides a convenient way for standards to not have to set request’s referrer.
</dd>

	<dt>!~referrer施策@rq（ 空~文字列 ）</dt>
	<dd>
!~referrer施策$。
!REFERRER$r
◎
A request has an associated referrer policy, which is a referrer policy. Unless stated otherwise it is the empty string. [REFERRER]
</dd>
	<dd class="note">注記：
これは、!環境~設定群~obj$に結付けられている~referrer施策を上書きするときに利用できる。
!REFERRER$r
◎
This can be used to override a referrer policy associated with an environment settings object.
</dd>

	<dt>!~client~hint~list@rq（ 空~list ）</dt>
	<dd>
!~client~hint~list$。
◎
A request has an associated client hints list, which is a client-hints list. Unless stated otherwise, it is the empty list.
</dd>
	<dd class="note">注記：
これは、［
!環境~設定群~obj$に結付けられている~client~hint~list
］を上書きするために利用される。
!CLIENT-HINTS$r
◎
This will be used to override a client hints list associated with an environment settings object. [CLIENT-HINTS]
</dd>

	<dt>!同期~flag@rq（ ~OFF ）</dt>
	<dd>
~flag値。
◎
A request has an associated synchronous flag. Unless stated otherwise it is unset.
</dd>

	<dt>!~mode@rq（ !no-cors^l ）</dt>
	<dd>
次のいずれか
⇒
!same-origin^l ／
!cors^l ／
!no-cors^l ／
!navigate^l ／
!websocket^l
◎
A request has an associated mode, which is "same-origin", "cors", "no-cors", "navigate", or "websocket". Unless stated otherwise, it is "no-cors".
</dd>
	<dd class="note">注記：
!要請$の既定の!~mode$rqが !no-cors^l であっても，それを新たな特色機能に利用するのはとりわけ奨励されないのが標準である。
それはむしろ安全でない。
!navigate^l, !websocket^l
は !HTML$r 用の特別な値である。
◎
Even though the default request mode is "no-cors", standards are highly discouraged from using it for new features. It is rather unsafe. "navigate" and "websocket" are special values for the HTML Standard. [HTML]
</dd>

	<dt>!~CORS予行~利用~flag@rq（ ~OFF ）</dt>
	<dd>
~flag値。
◎
A request has an associated use-CORS-preflight flag. Unless stated otherwise, it is unset.
</dd>


	<dt>!資格証~mode@rq（ !omit^l ）</dt>
	<dd>
次のいずれか
⇒
!omit^l ／
!same-origin^l ／
!include^l
◎
A request has an associated credentials mode, which is "omit", "same-origin", or "include". Unless stated otherwise, it is "omit".
</dd>
	<dd class="note">注記：
!要請$の!資格証~mode$rqは、!~fetch$の間，!資格証$の~flowを制御する。
!要請$の!~mode$rq が !navigate^l のときは、その!資格証~mode$rqは !include^l と見做される
— !~fetch$は現在~他の値を織り込んでいない。
!~HTML^cite がここの所で変更された場合、この標準も対応する変更が必要になる。
◎
Request’s credentials mode controls the flow of credentials during a fetch. When request’s mode is "navigate", its credentials mode is assumed to be "include" and fetch does not currently account for other values. If HTML changes here, this standard will need corresponding changes.
</dd>


	<dt>!資格証利用URL~flag@rq（ ~OFF ）</dt>
	<dd>
~flag値。
◎
A request has an associated use-URL-credentials flag. Unless stated otherwise, it is unset.
</dd>

	<dt>!~cache~mode@rq（ !default^l ）</dt>
	<dd>
次のいずれか
⇒
!default^l ／
!no-store^l ／
!reload^l ／
!no-cache^l ／
!force-cache^l ／
!only-if-cached^l
◎
A request has an associated cache mode, which is "default", "no-store", "reload", "no-cache", "force-cache", or "only-if-cached". Unless stated otherwise, it is "default".
</dd>
	<dd class="note">注記：
		<dl>
			<dt>!default^l</dt>
			<dd>
!~fetch$は、~networkへ向かうに先立ち，~HTTP~cacheを調べる。
~cache内に［
要請に合致する!新鮮$な応答
］が在れば、それが利用されることになる。
他の場合、!非新鮮$な応答が［
在れば !条件付き要請$ ／ 無ければ 通常の要請
］を作成した上で，対する応答で~HTTP~cacheを更新する。
!HTTP$r
!HTTP-SEMANTICS$r
!HTTP-COND$r
!HTTP-CACHING$r
!HTTP-AUTH$r
◎
Fetch will inspect the HTTP cache on the way to the network. If there is a fresh response it will be used. If there is a stale response a conditional request will be created, and a normal request otherwise. It then updates the HTTP cache with the response. [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]
</dd>

			<dt>!no-store^l</dt>
			<dd>
~fetchは、~HTTP~cacheが全く無かったかのように挙動する。
◎
Fetch behaves as if there is no HTTP cache at all. 
</dd>

			<dt>!reload^l</dt>
			<dd>
~fetchは、~networkへ向かう際に，~HTTP~cacheが全く無かったかのように挙動する。
それがため、通常の要請を作成して，対する応答で~HTTP~cacheを更新する。
◎
Fetch behaves as if there is no HTTP cache on the way to the network. Ergo, it creates a normal request and updates the HTTP cache with the response.
</dd>

			<dt>!no-cache^l</dt>
			<dd>
~fetchは、~HTTP~cache内に要請に合致する応答が［
在れば !条件付き要請$ ／ 無ければ 通常の要請
］を作成した上で、対する応答で~HTTP~cacheを更新する。
◎
Fetch creates a conditional request if there is a response in the HTTP cache and a normal request otherwise. It then updates the HTTP cache with the response.
</dd>

			<dt>!force-cache^l</dt>
			<dd>
~fetchは、~HTTP~cache内に要請に合致する応答が在れば，それが!非新鮮$であっても利用する。
応答が無ければ、通常の要請を作成して，対する応答で~HTTP~cacheを更新する。
◎
Fetch uses any response in the HTTP cache matching the request, not paying attention to staleness. If there was no response, it creates a normal request and updates the HTTP cache with the response.
</dd>

			<dt>!only-if-cached^l</dt>
			<dd>
~fetchは、~HTTP~cache要請に合致している応答があれば，それが!非新鮮$であっても利用する。
応答が無ければ、~network~errorを返す。
（利用できるのは、［
!要請$の!~mode$rq ~EQ !same-origin^l
］の場合に限られる。
~cacheされた~redirectは、［
!要請$の!~redirect~mode$rq ~EQ !follow^l
］~AND［
どの~redirectも!要請$の!~mode$rqに違反しない
］と見做す下で，追随することになる。）
◎
Fetch uses any response in the HTTP cache matching the request, not paying attention to staleness. If there was no response, it returns a network error. (Can only be used when request’s mode is "same-origin". Any cached redirects will be followed assuming request’s redirect mode is "follow" and the redirects do not violate request’s mode.)
</dd>
		</dl>

<p>
!~cache~mode$rqが !default^l の場合、!~header~list$rq内に［
次のいずれかを!名前に持つ~header$
］が在るならば，!~fetch$により !no-store^l に設定される
⇒
!If-Modified-Since$h,<br>
!If-None-Match$h,<br>
!If-Unmodified-Since$h,<br>
!If-Match$h,<br>
!If-Range$h
◎
If header list contains `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, or `If-Range`, fetch will set cache mode to "no-store" if it is "default".
</p>
	</dd>

	<dt>!~redirect~mode@rq（ !follow^l ）</dt>
	<dd>
次のいずれか
⇒
!follow^l ／
!error^l ／
!manual^l
◎
A request has an associated redirect mode, which is "follow", "error", or "manual". Unless stated otherwise, it is "follow".
</dd>

	<dt>!完全性~metadata@rq（空~文字列）</dt>
	<dd>
文字列。
◎
A request has associated integrity metadata (a string). Unless stated otherwise, it is the empty string.
</dd>
	<dd class="trans-note">【
~fetchした結果の~dataが，要請する側が期待する~dataと正確に一致するかどうか検証するための~data。
!SRI$r
】</dd>

	<dt>!暗号用~nonce~metadata@rq（空~文字列）</dt>
	<dd>
文字列。
◎
A request has associated cryptographic nonce metadata (a string). Unless stated otherwise, it is the empty string.
</dd>

	<dt>!構文解析器~metadata@rq（空~文字列）</dt>
	<dd>
次のいずれか
⇒
空~文字列 ／
!parser-inserted^l ／
!not-parser-inserted^l
◎
A request has associated parser metadata which is the empty string, "parser-inserted", or "not-parser-inserted". Unless otherwise stated, it is the empty string.
</dd>
	<dd class="trans-note">【
~script／~stylesheet
が
<a href="~HEscripting#parser-inserted">構文解析-時に挿入されたものかどうか</a>
を表す。
】</dd>

	<dd class="note">注記：
!要請$の［
!暗号用~nonce~metadata$rq,
!構文解析器~metadata$rq
］は，一般に、~fetchの誘発に責を負う~HTML要素~上の各種［
属性, ~flag
］から拡充される。
これらは， !CSP$r において、所与の文脈の下で［
要請, または応答
］を阻止するかどうか決定するために，種々の~algoから利用される。
◎
A request’s cryptographic nonce metadata and parser metadata are generally populated from attributes and flags on the HTML element responsible for triggering a fetch. They are used by various algorithms in [CSP] to determine whether requests or responses should be blocked in a given context.
</dd>


	<dt>!~url~list@rq（!要請$の!~url$rqの複製のみからなる~list ）</dt>
	<dd>
一個~以上の!~URL$からなる~list
◎
A request has an associated url list (a list of one or more URLs). Unless stated otherwise, it is a list containing a copy of request’s url.
</dd>

	<dt>!現在の~url@rq</dt>
	<dd>
!~url~list$rq内の最後の!~URL$を指す。
◎
A request has an associated current url. It is a pointer to the last URL in request’s url list.
</dd>

	<dt>!~redirect数@rq（ 0 ）</dt>
	<dd>
非負~整数。
!~redirectが生じた回数^tnote
◎
A request has an associated redirect count. Unless stated otherwise, it is zero.
</dd>

	<dt>!応答~tainting@rq（ !basic^l ）</dt>
	<dd>
次のいずれか
⇒
!basic^l ／
!cors^l ／
!opaque^l
◎
A request has an associated response tainting, which is "basic", "cors", or "opaque". Unless stated otherwise, it is "basic".
</dd>

	<dt>!~done~flag@rq（ ~OFF ）</dt>
	<dd>
~flag値。
◎
A request has an associated done flag. Unless stated otherwise, it is unset.
</dd>
</dl>

<hr>

<p class="note">注記：
!要請$の［
!~url~list$rq,
!現在の~url$rq,
!~redirect数$rq,
!応答~tainting$rq,
!~done~flag$rq
］は，!~fetch$ ~algoの内部状態管理に利用される。
◎
A request’s url list, current url, redirect count, response tainting, and done flag are used as bookkeeping details by the fetch algorithm.
</p>

<hr>


<p>

!下位資源~要請@
とは、次を満たす!要請$である
⇒
!行先$rq ~IN { !audio^l, !font^l, !image^l, !manifest^l, !script^l, !style^l, !track^l, !video^l, !xslt^l, 空~文字列 }
◎
A subresource request is a request whose destination is "audio", "font", "image", "manifest", "script", "style", "track", "video", "xslt", or the empty string. 
</p>

<p>
!［~naviまたは下位資源］のいずれかになり得る要請@
とは、次を満たす!要請$である
⇒
!行先$rq ~IN { !object^l, !embed^l }
◎
A potential-navigation-or-subresource request is a request whose destination is "object" or "embed".

</p>

<p>
!非~下位資源~要請@
とは、次を満たす!要請$である
⇒
!行先$rq ~IN { !document^l, !report^l, !serviceworker^l, !sharedworker^l, !worker^l }
◎
A non-subresource request is a request whose destination is "document", "report", "serviceworker", "sharedworker", or "worker".
</p>

<p>
!~navi要請@
とは、次を満たす!要請$である
⇒
!行先$rq ~IN { !document^l }
◎
A navigation request is a request whose destination is "document".
</p>

<p class="note">注記：
これらの用語の用法については
<a href="~SW#handle-fetch">handle fetch</a>
を見よ。
!SW$r
◎
See handle fetch for usage of these terms. [SW]
</p>

<p class="algo-head">
!要請$ %要請 を
!~clone@rq
するときは、次を走らす：
◎
To clone a request request, run these steps:
</p>

<ol>
	<li>
%新~要請 ~LET
%要請 の!本体$rqを除いた部分の複製
◎
Let newRequest be a copy of request, except for its body.
</li>
	<li>
~IF［
%要請 の!本体$rq ~NEQ ~NULL
］
⇒
%新~要請 の!本体$rq ~SET %要請 の!本体$rqを!~clone$bdした結果（例外投出あり）
◎
If request’s body is non-null, set newRequest’s body to the result of cloning request’s body. Rethrow any exceptions.
</li>
	<li>
~RET %新~要請
◎
Return newRequest.
</li>
</ol>

<hr>

<p>
!要請$ %要請 に対する
!本体を伝送する@
ときは、次を走らす：
◎
To transmit body for a request request, run these steps:
</p>

<ol>
	<li>
%本体 ~LET %要請 の!本体$rq
◎
Let body be request’s body.
</li>
	<li>
~IF［
%本体 ~EQ ~NULL
］
⇒
%要請 上で!要請の本体終端を処理する$ための!~fetch~taskを待入する$；<br>
~RET
◎
If body is null, then queue a fetch task on request to process request end-of-body for request and abort these steps.
</li>
	<li>
!(A)^i：
<p>
%読取り ~LET %本体 の!~stream$bdから!~chunkを読取った$RS結果
◎
Let read be the result of reading a chunk from body’s stream.
</p>

		<ul>
			<li>
<p>
値 %値 による %読取り の!充足~時には$：
◎
↓</p>
				<ul>
					<li>
<p>
~IF［
%値 は~objである
］~AND［
%値 の !done^c ~prop ~EQ ~F
］~AND［
%値 の !value^c ~propは !Uint8Array$I ~objである
］：
◎
When read is fulfilled with an object whose done property is false and whose value property is a Uint8Array object, run these substeps:
</p>
						<ol>
							<li>
%~byte列 ~LET %値 の !value^c ~propが表現する!~byte列$
◎
Let bytes be the byte sequence represented by the Uint8Array object.
</li>
							<li>
%~byte列 を伝送する
◎
Transmit bytes.
</li>
							<li>
%本体 の!伝送済み~byte数$bd ~INCBY %~byte列 の長さ
◎
Increase body’s transmitted bytes by bytes’s length.
</li>
							<li>
~GOTO !(A)^i
◎
Run the above step again.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%値 は~objである
］~AND［
%値 の !done^c ~prop ~EQ ~T
］
⇒
%要請 上で!要請の本体終端を処理する$ための!~fetch~taskを待入する$
◎
When read is fulfilled with an object whose done property is true, queue a fetch task on request to process request end-of-body for request.
</li>
					<li>
~ELSE
⇒
進行中の~fetchを事由 !致命的^i で!終了-$させる
◎
When read is fulfilled with a value that matches with neither of the above patterns, or read is rejected, terminate the ongoing fetch with reason fatal.
</li>
				</ul>
			</li>
			<li>
%読取り の!却下~時には$
⇒
進行中の~fetchを事由 !致命的^i で!終了-$させる
◎
↑</li>
		</ul>
	</li>
</ol>


			</section>
			<section id="responses">

<h3 title="Responses">2.2.6. 応答</h3>

<p>
!応答@
（ response ）とは、!~fetch$の結果である。
!応答$は、処理過程の中で徐々に~~築かれていくものであり，その各種~fieldすべてが直ぐに可用になるわけではない。
◎
The result of fetch is a response. A response evolves over time. That is, not all its fields are available straight away.
</p>

<p>
!応答$には、以下に挙げるものが結付けられる。
各~項には，それがとり得る値の種類を示す。
他が定められない限り、［
見出しの括弧内に与える値
］を既定~値としてとるものとする：
◎
↓</p>

<dl class="def-list">
	<dt>!種別@rs（ !default^l ）</dt>
	<dd>
次のいずれか
⇒
!basic^l ／ !cors^l ／ !default^l ／ !error^l ／ !opaque^l ／ !opaqueredirect^l
◎
A response has an associated type which is "basic", "cors", "default", "error", "opaque", or "opaqueredirect". Unless stated otherwise, it is "default".
</dd>

	<dt>!終了~事由@rs （ ε †）</dt>
	<dd>
次のいずれか
⇒
ε（値なし） ／ !利用者中止^i ／ !致命的^i ／ !時間切れ^i
◎
A response can have an associated termination reason which is end-user abort, fatal, or timeout.
</dd>
	<dd class="trans-note">【†
原文では
“does not have”
という句として記されているが、この訳では値 ε で表すことにする（非 ε になるのは、何らかの~errorが生じた場合に限られる）。
】</dd>

	<dt>!~url@rs</dt>
	<dd>
!~url~list$rsの最後の!応答~URL$を指す
— !~url~list$rsが空ならば ~NULL
◎
A response has an associated url. It is a pointer to the last response URL in response’s url list and null if response’s url list is the empty list.
</dd>

	<dt>!~url~list@rs（ 空~list ）</dt>
	<dd>
0 個~以上の!応答~URL$からなる~list。
◎
A response has an associated url list (a list of zero or more response URLs). Unless stated otherwise, it is the empty list.
</dd>
	<dd class="note">注記：
最後の!応答~URL$を除いて，この~listは~scriptには公開されない。
そうすると
!~HTTP~redirectの不可分的な取扱い$に違反するので。
◎
Except for the last response URL, if any, a response’s url list cannot be exposed to script. That would violate atomic HTTP redirect handling.
</dd>

	<dt>!~status@rs（ !200$st ）</dt>
	<dd>
!~status$。
◎
A response has an associated status, which is a status. Unless stated otherwise it is 200.
</dd>
	<dd class="trans-note">【
~HTTPの文脈では，応答の <a href="~7231#section-6">status code</a> を表現する。
】</dd>

	<dt>!~status~message@rs（ !OK^bl ）</dt>
	<dd>
!~byte列$。
◎
A response has an associated status message. Unless stated otherwise it is `OK`.
</dd>
	<dd class="trans-note">【
~HTTPの文脈では，応答の <a href="~7231#section-6.1">reason phrase</a> を表現する。
】</dd>

	<dt>!~header~list@rs（空~list）</dt>
	<dd>
!~header~list$。
◎
A response has an associated header list (a header list). Unless stated otherwise it is empty.
</dd>

	<dt>!本体@rs（ ~NULL ）</dt>
	<dd>
~NULL または!本体$。
◎
A response has an associated body (null or a body). Unless stated otherwise it is null.
</dd>

	<dt>!~trailer@rs（空~list）</dt>
	<dd>
!~header~list$。
◎
A response has an associated trailer (a header list). Unless stated otherwise it is empty.
</dd>

	<dt>!~HTTPS状態@rs（ !none^l ）</dt>
	<dd>
!~HTTPS状態~値$。
◎
A response has an associated HTTPS state (an HTTPS state value). Unless stated otherwise, it is "none".
</dd>

	<dt>!~CSP~list@rs（空~list）</dt>
	<dd>
!応答$に対する
<a href="~CSP3#policy">~CSP~obj</a>
の~list。
!CSP$r
◎
A response has an associated CSP list, which is a list of Content Security Policy objects for the response. The list is empty unless otherwise specified. [CSP]
</dd>

	<dt>!~CORSに公開される~header名~list@rs（空~list）</dt>
	<dd>
0 個以上の!~header$の!名前$hdからなる~list。
◎
A response has an associated CORS-exposed header-name list (a list of zero or more header names). The list is empty unless otherwise specified.
</dd>
	<dd class="note">注記：
!応答$の!~CORSに公開される~header名~list$rsは、概して
!Access-Control-Expose-Headers$h ~headerから!~header値を抽出-$hdした結果に設定されることになる。
この~listは、!~CORS絞込み応答$において公開する~headerを決定するときに利用される。
◎
A response will typically get its CORS-exposed header-name list set by extracting header values from the `Access-Control-Expose-Headers` header. This list is used by a CORS filtered response to determine which headers to expose.
</dd>

	<dt>!所在~URL@rs （ ε †）</dt>
	<dd>
次のいずれか
⇒
ε（値なし） ／
~NULL ／
!失敗^i ／
!~URL$
◎
A response can have an associated location URL (null, failure, or a URL). Unless specified otherwise, response has no location URL.
</dd>
	<dd class="note">注記：
この概念は、~Fetchおよび~HTMLの~navigate~algoにて，~redirectを取扱うために利用される。
それは、 !Location^h から，一度だけ, かつ一貫するように!~header値を抽出-$hdすることを確保する。
!HTML$r
◎
This concept is used for redirect handling in Fetch and in HTML’s navigate algorithm. It ensures `Location` has its value extracted consistently and only once. [HTML]
</dd>
	<dd class="trans-note">【†
原文では
“has no location URL （所在~URLを持たない）”
という句として記されているが、この訳では値 ε で表すことにする。
<small>（原文は ~NULL を暗に指しているようにも解釈できそうだが、~HTMLの!~navi$~algoを精査してみないと，はっきりしない。）</small>
】</dd>
</dl>


<hr>

<p>
［
!種別$rs ~EQ !error^l
］なる!応答$は、
!~network~error@
と呼ばれる。
◎
A response whose type is "error" is known as a network error.
</p>

<div class="p">
<p>
!~network~error$は，常に次を満たすようにされる：
</p>

<ul>
	<li>!~status$rs ~EQ 0</li>
	<li>!~status~message$rs ~EQ 空~byte列</li>
	<li>!~header~list$rs ~EQ 空</li>
	<li>!本体$rs ~EQ ~NULL</li>
	<li>!~trailer$rs ~EQ 空</li>
</ul>

◎
A network error is a response whose status is always 0, status message is always the empty byte sequence, header list is always empty, body is always null, and trailer is always empty.
</div>


<hr>

<p>
!絞込み応答@
とは、!~network~error$でないような ある!応答$を，その一部分のみに限定して公開する~viewである。
その応答を指して，!絞込み応答$の
!内的~応答@
という。
◎
A filtered response is a limited view on a response that is not a network error. This response is referred to as the filtered response’s associated internal response.
</p>

<p class="note">注記：
!~fetch$ ~algoは、~APIが不用意に情報を漏洩させなくするために，その種の~viewを返す。
旧来の理由から情報を公開させる必要がある
— 例：画像~dataを復号器に渡すときなど —
場合は、結付けられている!内的~応答$を利用できる。
それは、仕様の内部~algoからのみ “~access” でき，決して!絞込み応答$自身にはならない。
◎
The fetch algorithm returns such a view to ensure APIs do not accidentally leak information. If the information needs to be exposed for legacy reasons, e.g., to feed image data to a decoder, the associated internal response can be used, which is only "accessible" to internal specification algorithms and is never a filtered response itself.
</p>

<div class="p">
<p>
!基本~絞込み応答@
とは、次を満たすようにされた!絞込み応答$である：
</p>

<ul ><li>!種別$rs ~EQ !basic^l
</li><li>!~header~list$rs ~EQ
その!内的~応答$の!~header~list$rsから［
!名前$hdが!禁止~応答~header名$である!~header$
］は除外したもの
</li></ul>

◎
A basic filtered response is a filtered response whose type is "basic" and header list excludes any headers in internal response’s header list whose name is a forbidden response-header name.
</div>


<div class="p">
<p>
!~CORS絞込み応答@
とは、次を満たすようにされた!絞込み応答$である：
</p>

<ul ><li>!種別$rs ~EQ !cors^l
</li><li>!~header~list$rs ~EQ
その!内的~応答$の!~CORSに公開される~header名~list$rsから［
!名前$hdが!~CORS安全な応答~header名$でない，!~header$
］は除外したもの
</li><li>!~trailer$rs ~EQ 空
</li></ul>

◎
A CORS filtered response is a filtered response whose type is "cors", header list excludes any headers in internal response’s header list whose name is not a CORS-safelisted response-header name, given internal response’s CORS-exposed header-name list, and trailer is empty.
</div>

<div>
<p>
!不透明な絞込み応答@
とは、次を満たすようにされた!絞込み応答$である：
</p>

<ul ><li>!種別$rs ~EQ !opaque^l
</li><li>!~url~list$rs ~EQ 空
</li><li>!~status$rs ~EQ 0
</li><li>!~status~message$rs ~EQ 空~byte列
</li><li>!~header~list$rs ~EQ 空
</li><li>!本体$rs ~EQ ~NULL
</li><li>!~trailer$rs ~EQ 空
</li></ul>

◎
An opaque filtered response is a filtered response whose type is "opaque", url list is the empty list, status is 0, status message is the empty byte sequence, header list is empty, body is null, and trailer is empty.
</div>



<div>
<p>
!不透明redirect絞込み応答@
とは、次を満たすようにされた!絞込み応答$である：
</p>

<ul ><li>!種別$rs ~EQ !opaqueredirect^l
</li><li>!~status$rs ~EQ 0
</li><li>!~status~message$rs ~EQ 空~byte列
</li><li>!~header~list$rs ~EQ 空
</li><li>!本体$rs ~EQ ~NULL
</li><li>!~trailer$rs ~EQ 空
</li></ul>

◎
An opaque-redirect filtered response is a filtered response whose type is "opaqueredirect", status is 0, status message is the empty byte sequence, header list is empty, body is null, and trailer is empty.
</div>

<div class="note">注記：

<p>
!不透明redirect絞込み応答$に対しては、~redirectは後続しないので，!~url~list$rsが公開されても無害である。
◎
Exposing the url list for opaque-redirect filtered responses is harmless since no redirects are followed.
</p>

<p>
言い換えれば、［
!不透明な絞込み応答$, !不透明redirect絞込み応答$
］と!~network~error$とは，ほとんど判別できない。
新たな~APIを導入する際には、情報を漏洩させなくするため，仕様の内部~algoには
!内的~応答$を利用しないこと。
◎
In other words, an opaque filtered response and an opaque-redirect filtered response are nearly indistinguishable from a network error. When introducing new APIs, do not use the internal response for internal specification algorithms as that will leak information.
</p>

<p>
これはまた、 !response.ok$m などの~JS~APIが返す結果は，およそ役に立たないことを意味する。
◎
This also means that JavaScript APIs, such as response.ok, will return rather useless results.
</p>

</div>


<p class="algo-head">
!応答$ %応答 を
!~clone@rs
するときは、次を走らす：
◎
To clone a response response, run these steps:
</p>

<ol>
	<li>
~IF［
%応答 は!絞込み応答$である
］
⇒
~RET 次のようにされた絞込み応答
⇒
!内的~応答$ ~SET %応答 の!内的~応答$を!~clone$rsした結果（例外投出あり）；<br>
他の部分は %応答 と同一
◎
If response is a filtered response, return a new identical filtered response whose internal response is a clone of response’s internal response. Rethrow any exceptions.
</li>
	<li>
%新~応答 ~LET %応答 の!本体$rsを除いた部分の複製
◎
Let newResponse be a copy of response, except for its body.
</li>
	<li>
~IF［
%応答 の!本体$rs ~NEQ ~NULL
］
⇒
%新~応答 の!本体$rs ~SET
%応答 の!本体$rsを!~clone$bdした結果（例外投出あり）
◎
If response’s body is non-null, set newResponse’s body to the result of cloning response’s body. Rethrow any exceptions.
</li>
	<li>
~RET %新~応答
◎
Return newResponse.
</li>
</ol>



			</section>
		</section>
		<section id="authentication-entries">
<h3 title="Authentication entries">2.3. 認証~entry</h3>

<p>
!認証~entry@
／
!~proxy認証~entry@
は、［
~username, ~password, ~realm†
］の組であり，1 つ以上の!要請$に結付けられる。
!† “認証領域” — RFC7235 <a href="~7235#section-2.2">2.2 節</a> ~~参照。^tnote
◎
An authentication entry and a proxy-authentication entry are tuples of username, password, and realm, associated with one or more requests.
</p>

<p>
~UAは、［
~HTTP~cookieと, それに類する追跡~機能性
］が一緒に消去されることを，許容するべきである。
<!-- fingerprinting -->
◎
User agents should allow both to be cleared together with HTTP cookies and similar tracking functionality.
</p>

<p>
更なる詳細は~HTTPにて定義される。
!HTTP$r
!HTTP-SEMANTICS$r
!HTTP-COND$r
!HTTP-CACHING$r
!HTTP-AUTH$r
◎
Further details are defined by HTTP. [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]
</p>
		</section>
		<section id="fetch-groups">

<h3 title="Fetch groups">2.4. ~fetch~group</h3>

<p>
各 !環境~設定群~obj$には、
!~fetch~group@
が結付けられる。
◎
Each environment settings object has an associated fetch group.
</p>

<p>
各!~fetch~group$は、いくつかの
!~fetch記録@
からなる，有順序~listを保持する。
◎
A fetch group holds an ordered list of fetch records.
</p>

<p>
各!~fetch記録$には、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>!要請@fg</dt>
	<dd>
!要請$。
◎
A fetch record has an associated request (a request).
</dd>

	<dt>!~fetch@fg</dt>
	<dd>
!~fetch$~algoの~instance,
または ~NULL 。
◎
A fetch record has an associated fetch (a fetch algorithm or null).
</dd>

</dl>

<hr>

<p class="algo-head">
!~fetch~group$ %G が
!終了-@fg
されたときは
⇒
~FOR
%G 内の ~EACH ( !~fetch記録$ %記録 ) に対し
⇒
%記録 の!要請$fgの［
!~done~flag$rq ~EQ ~OFF ~OR
!~keepalive~flag$rq ~EQ ~OFF
］ならば
⇒
%記録 の!~fetch$fgを，事由 !致命的^i で!終了-$させる。
◎
When a fetch group is terminated, for each associated fetch record whose request’s done flag or keepalive flag is unset, terminate the fetch record’s fetch with reason fatal.
</p>


		</section>
		<section id="connections">
<h3 title="Connections">2.5. 接続</h3>

<p>
~UAには
!接続~pool@
が結付けられる。
!接続~pool$は，ゼロ個以上の
!接続@
からなる。
各 !接続$は，［
<b>origin</b> （!生成元$html）,
<b>credentials</b>（真偽値）
］から識別される。
◎
A user agent has an associated connection pool. A connection pool consists of zero or more connections. Each connection is identified by an origin (an origin) and credentials (a boolean).
</p>

<p class="algo-head">
!接続を得る@
ときは、所与の
( %生成元, %資格証 )
に対し，次を走らす：
◎
To obtain a connection, given an origin and credentials, run these steps:
</p>

<ol>
	<li>
~IF［
!接続~pool$内に，［
<b>origin</b> ~EQ %生成元 
］~AND［
<b>credentials</b> ~EQ %資格証
］なる!接続$がある
］
⇒
~RET その!接続$
◎
If connection pool contains a connection whose origin is origin and credentials is credentials, return that connection.
</li>
	<li>
<p>
%接続 ~LET %生成元 への~HTTP接続を確立した結果
!HTTP$r
!HTTP-SEMANTICS$r
!HTTP-COND$r
!HTTP-CACHING$r
!HTTP-AUTH$r
!TLS$r
— ここで：
◎
Let connection be the result of establishing an HTTP connection to origin. [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH] [TLS]
</p>

<ul>
	<li>
%資格証 ~EQ ~F の場合
⇒
~TLS~client証明書は<em>送信しない</em>こと。
◎
If credentials is false, do not send a TLS client certificate.
</li>
	<li>
接続の確立に成功しなかったときは（例： DNS／TCP／TLS の~error）
⇒
~RET !失敗^i
◎
If establishing a connection does not succeed (e.g., a DNS, TCP, or TLS error), return failure.
</li>
</ul>

	</li>
	<li>
!接続~pool$に，次のようにされた %接続 を追加する
⇒
<b>origin</b> ~SET %生成元；<br>
<b>credentials</b> ~SET %資格証 
◎
Add connection to the connection pool with origin being origin and credentials being credentials.
</li>
	<li>
~RET %接続 
◎
Return connection.
</li>
</ol>

<p class="note">注記：
これは，意図的にやや曖昧にされている
— 細かい点で，まだ発展し続けているので。
これを述べることは、
!link rel=preconnect^e
による特色機能を説明する助けになり、また，
!接続$は <b>credentials</b> を~keyに~~分別されることを明白に~~規定する。
後者は、例えば~TLS~session識別子が［
<b>credentials</b> ~EQ ~F の!接続$
］と［
~EQ ~T のそれ
］とにまたがって再利用されないことを明確化する。
◎
This is intentionally a little vague as the finer points are still evolving. Describing this helps explain the &lt;link rel=preconnect&gt; feature and clearly stipulates that connections are keyed on credentials. The latter clarifies that e.g., TLS session identifiers are not reused across connections whose credentials are false with connections whose credentials are true.
</p>
<!-- See https://github.com/whatwg/fetch/issues/114#issuecomment-143500095 for when we make
     WebSocket saner -->

		</section>
		<section id="port-blocking">
<h3 title="Port blocking">2.6. ~portの阻止法</h3>

<p class="algo-head">
!要請$ %要請 の
!~fetchingは，不良~portに因り阻止されるべきか？@
どうか決定するときは、次を走らす：
◎
To determine whether fetching a request request should be blocked due to a bad port, run these steps:
</p>

<ol>
	<li>
%~url ~LET %要請 の!現在の~url$rq
◎
Let url be request’s current url.
</li>
	<li>
%~scheme ~LET %~url の!~scheme$url
◎
Let scheme be url’s scheme.
</li>
	<li>
%~port ~LET %~url の!~port$url
◎
Let port be url’s port.
</li>
	<li>
~IF［
%~scheme ~EQ !ftp^l
］~AND［
%~port ~IN { 20, 21 }
］
⇒
~RET !許容ed^i
◎
If scheme is "ftp" and port is 20 or 21, then return allowed.
</li>
	<li>
~IF［
%~scheme ~IN !~network~scheme$
］~AND［
%~port は!不良~port$である
］
⇒
~RET !阻止ed^i
◎
Otherwise, if scheme is a network scheme and port is a bad port, then return blocked.
</li>
	<li>
~RET !許容ed^i
◎
Return allowed.
</li>
</ol>

<p>
次の表の一列目に挙げられる!~port$urlは、
!不良~port@
であるとされる：
◎
A port is a bad port if it is listed in the first column of the following table.
</p>

<div style="column-width:10em; column-gap:1em;">
<table><thead><tr><th>~port
<th>代表的な~service
</thead>

<tbody><tr><td>1<td>tcpmux
<tr><td>7<td>echo
<tr><td>9<td>discard
<tr><td>11<td>systat
<tr><td>13<td>daytime
<tr><td>15<td>netstat
<tr><td>17<td>qotd
<tr><td>19<td>chargen
<tr><td>20<td>ftp-data
<tr><td>21<td>ftp
<tr><td>22<td>ssh
<tr><td>23<td>telnet
<tr><td>25<td>smtp
<tr><td>37<td>time
<tr><td>42<td>name
<tr><td>43<td>nicname
<tr><td>53<td>domain
<tr><td>77<td>priv-rjs
<tr><td>79<td>finger
<tr><td>87<td>ttylink
<tr><td>95<td>supdup
<tr><td>101<td>hostriame
<tr><td>102<td>iso-tsap
<tr><td>103<td>gppitnp
<tr><td>104<td>acr-nema
<tr><td>109<td>pop2
<tr><td>110<td>pop3
<tr><td>111<td>sunrpc
<tr><td>113<td>auth
<tr><td>115<td>sftp
<tr><td>117<td>uucp-path
<tr><td>119<td>nntp
<tr><td>123<td>ntp
<tr><td>135<td>loc-srv / epmap
<tr><td>139<td>netbios
<tr><td>143<td>imap2
<tr><td>179<td>bgp
<tr><td>389<td>ldap
<tr><td>465<td>smtp+ssl
<tr><td>512<td>print / exec
<tr><td>513<td>login
<tr><td>514<td>shell
<tr><td>515<td>printer
<tr><td>526<td>tempo
<tr><td>530<td>courier
<tr><td>531<td>chat
<tr><td>532<td>netnews
<tr><td>540<td>uucp
<tr><td>556<td>remotefs
<tr><td>563<td>nntp+ssl
<tr><td>587<td>smtp
<tr><td>601<td>syslog-conn
<tr><td>636<td>ldap+ssl
<tr><td>993<td>ldap+ssl
<tr><td>995<td>pop3+ssl
<tr><td>2049<td>nfs
<tr><td>3659<td>apple-sasl<!-- X -->
<tr><td>4045<td>lockd
<tr><td>6000<td>x11
<tr><td>6665<td>irc (alternate)<!-- X -->
<tr><td>6666<td>irc (alternate)<!-- X -->
<tr><td>6667<td>irc (default)<!-- X -->
<tr><td>6668<td>irc (alternate)<!-- X -->
<tr><td>6669<td>irc (alternate)<!-- X -->
</tbody></table>
</div>

<!--
X = not in Gecko, Apple addition adopted by Chrome
http://www-archive.mozilla.org/projects/netlib/PortBanning.html
-->



		</section>
		<section id="should-response-to-request-be-blocked-due-to-mime-type?">
<h3 title="Should response to request be blocked due to its MIME type?">2.7. %要請 に対する %内的~応答 は，~MIME型に因り阻止されるべきか？</h3>

<p>
次の手続きを走らす：
◎
Run these steps:
</p>

<ol>
	<li>
%~MIME型 ~LET %応答 の!~header~list$rsから!~MIME型を抽出-$hdした結果
◎
Let mimeType be the result of extracting a MIME type from response’s header list.
</li>
	<li>
%種別 ~LET %要請 の!種別$rq
◎
Let type be request’s type.
</li>
	<li>
<p>
~IF［
%種別 ~EQ  !script^l
］
⇒
~IF［［
%~MIME型 の頭部は［
!audio/^bl, !image/^bl, !video/^bl
］のいずれかに合致する
］~OR［
%~MIME型 ~EQ !text/csv^bl
］］
⇒
~RET !阻止ed^i：
◎
If type is "script" and one of the following is true, then return blocked:
◎
• mimeType starts with `audio/`, `image/`, or `video/`.
◎
• mimeType is `text/csv`.
</li>
	<li>
~RET !許容ed^i
◎
Return allowed.
</li>
</ol>

		</section>
		<section id="client-hints-list">
<h3 title="Client hints list">2.8. ~client~hint~list</h3>

<p class="note">注記：
この節は HTTP Client Hints !CLIENT-HINTS$r に統合されることになる。
◎
This section will be integrated into HTTP Client Hints. [CLIENT-HINTS]
</p>
<!-- XXX -->

<p>
!~client~hint~list@
は、どの~tokenも次を満たすような，
<a href="~CLIENTHINTS#accept-ch">~client~hint~token</a>
の~listである
⇒
~token ~IN { !dpr^bl, !save-data^bl, !viewport-width^bl, !width^bl }
◎
A client hints list is a list of Client hint tokens, each of which is one of `dpr`, `save-data`, `viewport-width`, or `width`.
</p>

		</section>
		<section id="streams">

<h3 title="Streams">2.9. ~stream</h3>

<p class="note">注記：
この節は、~IDLなどの他の標準に統合されるかもしれない。
◎
This section might be integrated into other standards, such as IDL.
</p>

			<section id="readablestream">

<h4 title="ReadableStream">2.9.1 ~ReadableStream</h4>

<p>
!~ReadableStream@
~objは、!~dataの~stream$RSを表現する。
この節では、!~ReadableStream$~objに共通する演算を定義する。
!STREAMS$r
◎
A ReadableStream object represents a stream of data. In this section, we define common operations for ReadableStream objects. [STREAMS]
</p>


<p class="algo-head">
%~chunk を !~ReadableStream$~obj %stream の中へ
!~enqueue@RS
するときは、次を走らす：
◎
To enqueue chunk into a ReadableStream object stream, run these steps:
</p>

<ol>
	<li>
!ReadableStreamDefaultControllerEnqueue$A( %stream.[[readableStreamController]], %~chunk )
を~callする（例外投出あり）
◎
Call ReadableStreamDefaultControllerEnqueue(stream.[[readableStreamController]], chunk). Rethrow any exceptions. 
</li>
</ol>

<p class="algo-head">
!~ReadableStream$~obj %stream を
!~closeする@RS
ときは、次を走らす：
◎
To close a ReadableStream object stream, run these steps:
</p>

<ol>
	<li>
!ReadableStreamDefaultControllerClose$A( %stream.[[readableStreamController]] )
を~callする（例外投出あり）
◎
Call ReadableStreamDefaultControllerClose(stream.[[readableStreamController]]). Rethrow any exceptions.
</li>
</ol>

<p class="algo-head">
所与の %事由 で !~ReadableStream$ ~obj %~stream を
!~errorにする@RS
ときは、次を走らす：
◎
To error a ReadableStream object stream with given reason, run these steps:
</p>

<ol>
	<li>
!ReadableStreamDefaultControllerError$A( %~stream.[[readableStreamController]], %事由 )
を~callする（例外投出あり）
◎
Call ReadableStreamDefaultControllerError(stream.[[readableStreamController]]). reason). Rethrow any exceptions. 
</li>
</ol>


<p class="algo-head">
所与の ( %策, %~pull動作, %~cancel動作 ) （いずれも省略時は ε ）から
!~ReadableStream~objを構築-@RS
するときは、次を走らす：
◎
To construct a ReadableStream object with given strategy, pull action and cancel action, all of which are optional, run these steps:
</p>

<ol>
	<li>
%init ~LET 新たな object
◎
Let init be a new object.
</li>
	<li>
~IF［
%~pull動作 ~NEQ  ε
］
⇒
%init[!pull^l] ~SET %~pull動作 を走らす~function
◎
Set init["pull"] to a function that runs pull if pull is given.
</li>
	<li>
~IF［
%~cancel動作 ~NEQ  ε
］
⇒
%init[!cancel^l] ~SET %~cancel動作 を走らす~function
◎
Set init["cancel"] to a function that runs cancel if cancel is given.
</li>
	<li>
%stream ~LET
( %init, %策 )
を与える下で，［
!~ReadableStream$の初期~値
］を構築子として~callした結果（例外投出あり）
◎
Let stream be the result of calling the initial value of ReadableStream as constructor with init and strategy if given. Rethrow any exceptions.
</li>
	<li>
~RET %stream
◎
Return stream.
</li>
</ol>


<p class="algo-head">
所与の %~chunk列 から
!固定的な~ReadableStream~objを構築-@RS
するときは、次を走らす：
◎
To construct a fixed ReadableStream object with given chunks, run these steps:
</p>

<ol>
	<li>
%stream ~LET
!~ReadableStream~objを構築-$RSした結果（例外投出あり）
◎
Let stream be the result of constructing a ReadableStream object. Rethrow any exceptions.
</li>
	<li>
~FOR
%~chunk列 内の ~EACH ( %~chunk ) に対し
⇒
%stream に %~chunk を!~enqueue$RSする（例外投出あり）
◎
For each chunk in chunks, enqueue chunk into stream. Rethrow any exceptions.
</li>
	<li>
%stream を!~closeする$RS（例外投出あり）
◎
Close stream. Rethrow any exceptions.
</li>
	<li>
~RET %stream
◎
Return stream.
</li>
</ol>

<p class="algo-head">
!~ReadableStream$~obj %stream から
!読取器を取得-@RS
するときは、次を走らす：
◎
To get a reader from a ReadableStream object stream, run these steps:
</p>

<ol>
	<li>
%読取器 ~LET
!AcquireReadableStreamDefaultReader$A( %stream )
を~callした結果（例外投出あり）
◎
Let reader be the result of calling AcquireReadableStreamDefaultReader(stream). Rethrow any exceptions.
</li>
	<li>
~RET %読取器
◎
Return reader.
</li>
</ol>

<div class="p">
<p class="algo-head">
!~ReadableStream$ ~obj %読取器 から
!~chunkを読取る@RS
ときは、次を走らす：
</p>

<ol>
	<li>
~RET
!ReadableStreamDefaultReaderRead$A( %読取器 )
を~callした結果
</li>
</ol>
◎
To read a chunk from a ReadableStream object with reader, return the result of calling ReadableStreamDefaultReaderRead(reader).
</div>


<p class="algo-head">
%読取器 を用いて，所与の!~ReadableStream$~objから
!すべての~byte列を読取る@RS
ときは、次を走らす：
◎
To read all bytes from a ReadableStream object with reader, run these steps:
</p>

<ol>
	<li>
%promise ~LET !新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~byte列 ~LET 空の~byte列
◎
Let bytes be an empty byte sequence.
</li>
	<li>
<p>!(A)^i： !この段は並列的に走らす^tnote</p>
<p>
%読取り ~LET
!ReadableStreamDefaultReaderRead$A( %読取器 )
を~callした結果
◎
Let read be the result of calling ReadableStreamDefaultReaderRead(reader).
</p>

		<ul>
			<li>
<p>
値 %値 による %読取り の!充足~時には$：
</p>
				<ol>
					<li>
~IF［
%値 は~objである
］~AND［
%値 の !done^c ~prop ~EQ ~F
］~AND［
%値 の !value^c ~propは !Uint8Array$I ~objである
］
⇒
%~byte列 に !value^c ~propを付加する；<br>
~GOTO !(A)^i
◎
When read is fulfilled with an object whose done property is false and whose value property is a Uint8Array object, append the value property to bytes and run the above step again.
</li>
					<li>
~ELIF［
%値 は~objである
］~AND［
%値 の !done^c ~prop ~EQ ~T
］
⇒
%~byte列 で %promise を!解決する$
◎
When read is fulfilled with an object whose done property is true, resolve promise with bytes.
</li>
					<li>
~ELSE
⇒
!TypeError^E で %promise を!却下する$
◎
When read is fulfilled with a value that matches with neither of the above patterns, reject promise with a TypeError.
</li>
				</ol>
			</li>
			<li>
~errorによる %読取り の!却下~時には$
⇒
その~errorで %promise を!却下する$
◎
When read is rejected with an error, reject promise with that error.
			</li>
		</ul>
	</li>
	<li>
~RET %promise
◎
Return promise.
</li>
</ol>


<p class="algo-head">
!~ReadableStream$ ~objを
( %読取器, %事由 )
で
!取消す@RS
ときは、
!ReadableStreamCancel$A( %読取器, %事由 )
を~callした結果を返す。
◎
To cancel a ReadableStream object with reader and reason, return the result of calling ReadableStreamCancel(reader, reason).
</p>


<p class="note">注記：
読取器への~accessは排他的になるので、読取りの実際の仕組みは，
!~script側からは^tnote
観測し得ない。
実装は、自身に都合が良い より直接的な仕組みも利用できる。
◎
Because the reader grants exclusive access, the actual mechanism of how to read cannot be observed. Implementations could use more direct mechanism if convenient.
</p>

<p class="algo-head">
!~ReadableStream$~obj %stream を
!二叉化@RS
するときは、次を走らす：
◎
To tee a ReadableStream object stream, run these steps:
</p>

<ol>
	<li>
~RET
!ReadableStreamTee$A( %stream, ~T )
を~callした結果（例外投出あり）
◎
Return the result of calling ReadableStreamTee(stream, true). Rethrow any exception.
</li>
</ol>

<p class="trans-note">【
二叉化（ ~tee ）
— 元の~streamを同じに挙動する二つの~streamに分岐する（ ~tee_command, T 字路の “tee”）。
】</p>

<p>
!空の~ReadableStream~obj@
とは、空~listから!固定的な~ReadableStream~objを構築-$RSした結果である。
◎
An empty ReadableStream object is the result of constructing a fixed ReadableStream object with an empty list.
</p>

<p class="note">注記：
!空の~ReadableStream~obj$を構築する際には、例外は投出されない。
◎
Constructing an empty ReadableStream object will not throw an exception.
</p>

<p>
!~ReadableStream$~obj %stream は：
◎
↓</p>

<ul>
	<li>
［
%stream.[[state]] ~EQ !readable^l
］ならば，
!読取可@RS
（ readable ）という。
◎
A ReadableStream object stream is said to be readable if stream.[[state]] is "readable".
</li>
	<li>
［
%stream.[[state]] ~EQ !closed^l
］ならば，
!~closeされた@RS
（ closed ）という。
◎
A ReadableStream object stream is said to be closed if stream.[[state]] is "closed".
</li>
	<li>
［
%stream.[[state]] ~EQ !errored^l
］ならば，
!~errorした@RS
（ errored ）という。
◎
A ReadableStream object stream is said to be errored if stream.[[state]] is "errored".
</li>
	<li>
［
!IsReadableStreamLocked$A( %stream )
を~callした結果 ~EQ ~T
］ならば，
!~lockされている@Bd
（ locked ）という。
◎
A ReadableStream object stream is said to be locked if the result of calling IsReadableStreamLocked(stream) is true.
</li>
	<li>
<p>
次の両~条件を満たすならば，
!もっと~dataが必要@RS
（ need more data ）という：
◎
A ReadableStream object stream is said to need more data if the following conditions hold:
</p>

		<ul>
			<li>
%stream は!読取可$RSである。
◎
stream is readable.
</li>
			<li>
!ReadableStreamDefaultControllerGetDesiredSize$A( %stream.[[readableStreamController]] )
を~callした結果 ~GT 0
◎
The result of calling ReadableStreamDefaultControllerGetDesiredSize(stream.[[readableStreamController]]). is positive.
</li>
		</ul>
	</li>
	<li>
［
!IsReadableStreamDisturbed$A( %stream )
を~callした結果 ~EQ ~T
］ならば，
!妨げられている@RS
（ disturbed ）という。
◎
A ReadableStream object stream is said to be disturbed if the result of calling IsReadableStreamDisturbed(stream) is true.
</li>
</ul>


			</section>
		</section>
	</section>
	<section id="http-extensions">
<h2 title="HTTP extensions">3. ~HTTP拡張</h2>

		<section id="origin-header">
<h3 title="Origin header">3.1. !Origin^h ~header</h3>

<p>
!Origin@h
要請!~header$は、!~fetch$ が出自にしている生成元を指示する。
◎
The `Origin` request header indicates where a fetch originates from.
</p>


<p class="note">注記：
!Origin$h ~headerは、 !Referer$h ~headerの!~path$url情報を露出させなくした~versionである<small>（この~header名は、本来の英語の綴り “Referrer” と異なることに注意）</small>。
これは、!~HTTP~fetch$のうち，［
%~CORS~flag が ~ON の下に行われるもの,
および !要請$の!~method$rqに［
!GET$hm, !HEAD$hm
］以外のものを利用するもの
］すべてに利用される。
互換性の拘束から、すべての!~fetch$に含まれることはない。
◎
The `Origin` header is a version of the `Referer` [sic] header that does not reveal a path. It is used for all HTTP fetches whose CORS flag is set as well as those where request’s method is neither `GET` nor `HEAD`. Due to compatibility constraints it is not included in all fetches.
</p>

<p>
その!値$hdに対する!~ABNF$は、次で与えられる：
◎
Its value ABNF:
</p>

<pre class="ABNF">
Origin               = origin-or-null

origin-or-null       = origin / ~P_NULL ; <span class="comment">!null^bl, 大小区別</span>
origin               = !~scheme$url "://" !~host$url [ ":" !~port$url ]</pre>

<p class="note">注記：
これは !ORIGIN$r による
<a href="~IETF/rfc6454#section-7">!Origin^h</a>
!~header$を置き換える。
!値に複数個の生成元を含められないようにされている。^tnote
◎
This supplants the `Origin` header. [ORIGIN]
</p>

		</section>
		<section id="http-cors-protocol">
<h3 title="CORS protocol">3.2. ~CORS~protocol</h3>

<p>
!~CORS~protocol@
は、非同一生成元 間での応答の共有, および
~HTMLの!form$e 要素で可能なものより多用途の!~fetch$を可能にするためにある。
それは，~HTTPの上層にあり、それにより，応答は［
自身が他の!生成元$htmlと共有し得る
］ことを宣言できるようになる。
◎
To allow sharing responses cross-origin and allow for more versatile fetches than possible with HTML’s form element, the CORS protocol exists. It is layered on top of HTTP and allows responses to declare they can be shared with other origin.
</p>

<p class="note">注記：
これには、~firewallの背後（~intranet）からの応答による~data漏洩を防止するために，~opt-inの仕組みが必要になる。
加えて，!資格証$を含む!要請$にも、~sensitiveになり得る~dataの漏洩を防止するため，~opt-inが必要になる。
◎
It needs to be an opt-in mechanism to prevent leaking data from responses behind a firewall (intranets). Additionally, for requests including credentials it needs to be opt-in to prevent leaking potentially-sensitive data.
</p>

<p>
この節では、!~CORS~protocol$の，~server開発者に該当する部分について説明する。
~UA側に課される要件は、
<a href="#http-new-header-syntax">［ その新たな~HTTP~header ］の構文</a>
を除き，!~fetch$ ~algoの一部として与えられる。
◎
This section explains the CORS protocol as it pertains to server developers. Requirements for user agents are part of the fetch algorithm, except for the new HTTP header syntax. 
</p>

			<section id="general">
<h4 title="General">3.2.1. 一般論</h4>

<p>
!~CORS~protocol$は、応答が 非同一生成元の下でも共有し得るものになるかどうかを指示する，一連の~headerからなる。
◎
The CORS protocol consists of a set of headers that indicates whether a response can be shared cross-origin.
</p>

<p>
［
~HTMLの !form$e 要素で可能なものを超えるもの
］を孕む!要請$においては、［
!要請$の!現在の~url$rqが !~CORS~protocol$を~supportする
］ことを確保する必要があるので，!~CORS予行~要請$が遂行される。
◎
For requests that are more involved than what is possible with HTML’s form element, a CORS-preflight request is performed, to ensure request’s current url supports the CORS protocol.
</p>


			</section>
			<section id="http-requests">
<h4 title="HTTP requests">3.2.2. ~HTTP要請</h4>

<p>
!~CORS要請@
とは、 !Origin$h ~headerを含んでいる~HTTP要請である。
が、そのような要請が!~CORS~protocol$に関与しているとは限らない
— !Origin$h ~headerは，［
!GET$hm, !HEAD$hm
］以外の!~method$rqを用いる すべての!要請$にも含められるので。
◎
A CORS request is an HTTP request that includes an `Origin` header. It cannot be reliably identified as participating in the CORS protocol as the `Origin` header is also included for all requests whose method is neither `GET` nor `HEAD`.
</p>


<p>
!~CORS予行~要請@
とは、!~CORS~protocol$が解されるかどうか検査するための!~CORS要請$である。
それは、!~method$に !OPTIONS$hm を利用し，次の!~header$を中に含む：
◎
A CORS-preflight request is a CORS request that checks to see if the CORS protocol is understood. It uses `OPTIONS` as method and includes these headers:
</p>

<dl class="def-list">
	<dt>!Access-Control-Request-Method@h</dt>
	<dd>
同じ資源に対する今後の!~CORS要請$に利用され得る
!要請~側が希望する^tnote
!~method$を指示する。
◎
Indicates which method a future CORS request to the same resource might use.
</dd>

	<dt>!Access-Control-Request-Headers@h</dt>
	<dd>
同じ資源に対する今後の!~CORS要請$に利用され得る
!要請~側が希望する^tnote
!~header$を指示する。
◎
Indicates which headers a future CORS request to the same resource might use.
</dd>
</dl>


			</section>
			<section id="http-responses">
<h4 title="HTTP responses">3.2.3. ~HTTP応答</h4>

<p>
!~CORS要請$に対する~HTTP応答には、次の!~header$を含ませることができる：
◎
An HTTP response to a CORS request can include the following headers:
</p>

<dl class="def-list">
	<dt>!Access-Control-Allow-Origin@h</dt>
	<dd>
応答に［
!Origin$h 要請!~header$の~literal!値$hd（ !null^bl もとり得る）
］または［
!*^bl
］のいずれを返すかを通して，応答が共有し得るものになるかどうかを指示する。
◎
Indicates whether the response can be shared, via returning the literal value of the `Origin` request header (which can be `null`) or `*` in a response.
</dd>

	<dt>!Access-Control-Allow-Credentials@h</dt>
	<dd>
!要請$の!資格証~mode$rq が !include^l であるときに，応答が共有し得るものになるかどうかを指示する。
◎
Indicates whether the response can be shared when request’s credentials mode is "include".
</dd>
	<dd class="note">注記：
!~CORS予行~要請$の際には，!要請$の!資格証~mode$rqは常に !omit^l であるが、後続の!~CORS要請$はそうでないこともある。
したがって、!~CORS予行~要請$に対する~HTTP応答の中でも，~supportの有無が指示される必要がある。
◎
For a CORS-preflight request, request’s credentials mode is always "omit", but for any subsequent CORS requests it might not be. Support therefore needs to be indicated as part of the HTTP response to the CORS-preflight request as well.
</dd>

</dl>

<p>
!~CORS予行~要請$に対する~HTTP応答には、次の!~header$を含ませ得る：
◎
An HTTP response to a CORS-preflight request can include the following headers:
</p>

<dl class="def-list">
	<dt>!Access-Control-Allow-Methods@h</dt>
	<dd>
!~CORS~protocol$の目的において，!応答$の!~url$rsが~supportする!~method$を指示する。
◎
Indicates which methods are supported by the response’s url for the purposes of the CORS protocol.
</dd>
	<dd class="note">注記：
!Allow$h !~header$は!~CORS~protocol$の目的とは関連しない。
◎
The `Allow` header is not relevant for the purposes of the CORS protocol.
</dd>

	<dt>!Access-Control-Allow-Headers@h</dt>
	<dd>
!~CORS~protocol$の目的において，!応答$の!~url$rsが~supportする!~header$を指示する。
◎
Indicates which headers are supported by the response’s url for the purposes of the CORS protocol.
</dd>

	<dt>!Access-Control-Max-Age@h</dt>
	<dd>
!Access-Control-Allow-Methods$h
!~header$, および
!Access-Control-Allow-Headers$h
!~header$から供される情報が~cacheされ得る期間
!~UA側が~cacheを保持してもよい最長の期間^tnote
を指示する。
◎
Indicates how long the information provided by the `Access-Control-Allow-Methods` and `Access-Control-Allow-Headers` headers can be cached.
</dd>
</dl>

<p>
!~CORS予行~要請$でない!~CORS要請$に対する~HTTP応答にも，次の!~header$を含ませることができる：
◎
An HTTP response to a CORS request that is not a CORS-preflight request can also include the following header:
</p>

<dl class="def-list">
	<dt>!Access-Control-Expose-Headers@h</dt>
	<dd>
応答の一部として公開し得る
!~UA側の~script~APIに公開-を許可する^tnote
!~header$を，!名前$hdの~listにより指示する。
◎
Indicates which headers can be exposed as part of the response by listing their names.
</dd>
</dl>


			</section>
			<section id="http-new-header-syntax">
<h4 title="HTTP new-header syntax">3.2.4. ［ 新たな~HTTP~header ］の構文</h4>

<p>

!~CORS~protocol$に利用される!~header$の!値$hdに対する!~ABNF$は、次で与えられる：
◎
ABNF for the values of the headers used by the CORS protocol:
</p>

<pre class="ABNF">
Access-Control-Request-Method    = !method$p
Access-Control-Request-Headers   = 1#!field-name$p

wildcard                         = "*"
Access-Control-Allow-Origin      = origin-or-null / wildcard
Access-Control-Allow-Credentials = ~P_TRUE ; <span class="comment">!true^bl, 大小区別</span>
Access-Control-Expose-Headers    = #!field-name$p / wildcard
Access-Control-Max-Age           = !delta-seconds$p
Access-Control-Allow-Methods     = #!method$p / wildcard
Access-Control-Allow-Headers     = #field-name-or-wildcard
field-name-or-wildcard           = !field-name$p / wildcard
</pre>


<p class="note">注記：
生成規則
!Access-Control-Expose-Headers^p
と
!Access-Control-Allow-Headers^p
の唯一の相違は、後者は~header値として !*, Authorization^bl を取扱える必要がある一方で，前者はそうでない点にある。
◎
The difference between the Access-Control-Expose-Headers and Access-Control-Allow-Headers production is that the latter needs to be able to handle `*, Authorization` as header value whereas the former does not.
</p>



			</section>
			<section id="cors-protocol-and-credentials">
<h4 title="CORS protocol and credentials">3.2.5. ~CORS~protocolと資格証</h4>

<!-- non-normative -->

<p>
!要請$の!資格証~mode$rq ~EQ !include^l のときには、
!~fetching$の際に!資格証$を含ませること以外にも，
!~CORS~protocol$の~~働きに影響0がある。
◎
When request’s credentials mode is "include" it has an impact on the functioning of the CORS protocol other than including credentials in the fetch.
</p>

<div class="example" id="example-xhr-credentials">

<p>
昔から、 !XMLHttpRequest$I を利用して，!要請$の!資格証~mode$rqを !include^l に設定できていたが：
◎
In the old days, XMLHttpRequest could be used to set request’s credentials mode to "include":
</p>

<pre>
var %client = new XMLHttpRequest()
%client.open("GET", "./")
%client.withCredentials = true
/* … */
</pre>

<div class="p">
<p>
今では次で足りる：
</p>

<pre>
fetch("./", { credentials:"include" }).then(/* … */)
</pre>

◎
Nowadays, fetch("./", { credentials:"include" }).then(/* … */) suffices.
</div>

</div>

<p>
!要請$の!資格証~mode$rqが~serverから観測可能になることは、必要とされない。
!要請$に!資格証$が存在するときに限り、そのことから観測できる。
そうであっても、!~CORS予行~要請$が!資格証$を含むことは，決してないことに注意。
◎
A request’s credentials mode is not necessarily observable on the server; only when credentials exist for a request can it be observed by virtue of the credentials being included. Note that even so, a CORS-preflight request never includes credentials.
</p>

<p>
したがって~server開発者は、［
!資格証$で “染められた（ tainted ）” 応答を，共有させ得るかどうか
］を決める必要がある。
また、［
!~CORS予行~要請$を要している!要請$に，!資格証$を含めれるかどうか
］も決める必要がある。
一般的に言えば、［
応答を共有させる ／
!資格証$を伴う要請を許容する
］ことは安全でなくする方へ~~働くので、慎重に事を~~運んで，
<a href="https://en.wikipedia.org/wiki/Confused_deputy_problem">confused deputy problem</a>
（混乱した使節の問題）を避ける必要がある。
<!-- Turn into a reference? Meh. -->
◎
The server developer therefore needs to decide whether or not responses "tainted" with credentials can be shared. And also needs to decide if requests necessitating a CORS-preflight request can include credentials. Generally speaking, both sharing responses and allowing requests with credentials is rather unsafe, and extreme care has to be taken to avoid the confused deputy problem.
</p>

<p>
!資格証$を伴う応答を共有させるためには、［
!Access-Control-Allow-Origin$h,
!Access-Control-Allow-Credentials$h
］!~header$が重要になる。
次の表に、
!https://rabbit.invalid/^s
へ向けた要請に対する種々の
合法／合法でない
組合わせを~~説明する：
◎
To share responses with credentials, the `Access-Control-Allow-Origin` and `Access-Control-Allow-Credentials` headers are important. The following table serves to illustrate the various legal and illegal combinations for a request to https://rabbit.invalid/:
</p>

<table style="margin-top: 5em;">
<tbody><tr>
<th>要請の資格証~mode◎Request’s credentials mode
<th><div class="_narrow-cell"><span style="top:-4.5em;">
!Access-Control-Allow-Origin$h
</span></div>
<th><div class="_narrow-cell"><span>
!Access-Control-Allow-Credentials$h
</span></div>
<th>共有される？◎Shared?
<th>備考◎Notes
<tr>
<td>!omit^l
<td>!*^bl
<td>なし
<td>✅
<td>—

<tr><td>!omit^l
<td>!*^bl
<td>!true^bl
<td>✅
<td>
資格証~mode ~NEQ !include^l の場合、
!Access-Control-Allow-Credentials$h は無視される。
◎
If credentials mode is not "include", then `Access-Control-Allow-Credentials` is ignored.

<tr><td>!omit^l
<td>!https://rabbit.invalid/^bl
<td>なし
<td>❌
<td>
生成元を直列化した結果の末尾は、~slashではない。
◎
A serialized origin has no trailing slash.

<tr><td>!omit^l
<td>!https://rabbit.invalid^bl
<td>なし
<td>✅
<td>—

<tr><td>!include^l
<td>!*^bl
<td>!true^bl
<td>❌
<td>
資格証~mode ~EQ !include^l の場合、
!Access-Control-Allow-Origin$h は !*^bl にできない。
◎
If credentials mode is "include", then `Access-Control-Allow-Origin` cannot be `*`.

<tr><td>!include^l
<td>!https://rabbit.invalid^bl
<td>!true^bl
<td>✅
<td>—

<tr><td>!include^l
<td>!https://rabbit.invalid^bl
<td>!True^bl
<td>❌
<td>
!true^bl は（~byte）大小区別。
◎
`true` is (byte) case-sensitive.
</tbody></table>

<p>
同様に、応答~header［
!Access-Control-Expose-Headers$h ／
!Access-Control-Allow-Methods$h ／
!Access-Control-Allow-Headers$h
］の値として !*^bl を利用できるのは、［
!要請$の!資格証~mode$rq ~NEQ !include^l
］のときに限られる。
◎
Similarly, `Access-Control-Expose-Headers`, `Access-Control-Allow-Methods`, and `Access-Control-Allow-Headers` response headers can only use `*` as value when request’s credentials mode is not "include".
</p>

			</section>
			<section id="cors-protocol-examples">
<h4 title="Examples">3.2.6. 例</h4>

<div class="example" id="example-simple-cors">

<p>
!https://foo.invalid/^s にある~scriptは、
!https://bar.invalid/^s から，何か~dataを~fetchしたいと求めているとする（!資格証$も応答~headerへの~accessも重要でないとする）：
◎
A script at https://foo.invalid/ wants to fetch some data from https://bar.invalid/. (Neither credentials nor response header access is important.)
</p>

<pre id="unicorn">
var %url = "https://bar.invalid/api?key=\
730d67a37d7f3d802e96396d00280768773813fbe726d116944d814422fc1a45\
&amp;data=about:unicorn";
fetch(%url).then(%success, %failure)
</pre>


<p>
!foo.invalid^s の開発者からはまったく透過的になるが、これには，!~CORS~protocol$が利用される
— ~UAは、!~CORS~protocol$の一環として，要請~内に !Origin$h ~headerを含ませることになる：
◎
This will use the CORS protocol, though this is entirely transparent to the developer from foo.invalid. As part of the CORS protocol, the user agent will include the `Origin` header in the request:
</p>

<pre>
Origin: https://foo.invalid
</pre>

<p>
~UAは、 !bar.invalid^s からの応答の受信-時に，
!Access-Control-Allow-Origin$h 応答~headerを検証0することになる。
その値が［
!https://foo.invalid^bl, !*^bl
］のいずれかならば， %success ~callbackが呼出され、
他の値, あるいは~headerがない場合には， %failure ~callbackが呼出されることになる。
◎
Upon receiving a response from bar.invalid, the user agent will verify the `Access-Control-Allow-Origin` response header. If its value is either `https://foo.invalid` or `*`, the user agent will invoke the success callback. If it has any other value, or is missing, the user agent will invoke the failure callback.
</p>

</div>

<div class="example" id="example-cors-with-response-header">

<p>
!foo.invalid^s の開発者が，今度は、応答~headerにも~accessしつつ，
!bar.invalid^s から何か~dataを~fetchしようと求めたとする：
◎
The developer of foo.invalid is back, and now wants to fetch some data from bar.invalid while also accessing a response header.
</p>

<pre>
fetch(%url).then(%response =&gt; {
  var %hsts = %response.headers.get("strict-transport-security"),
      %csp = %response.headers.get("content-security-policy")
  log(%hsts, %csp)
})
</pre>

<p>
!bar.invalid^s は、先の例と同じく，正しい !Access-Control-Allow-Origin$h 応答~headerを提供したとする。
%hsts, %csp の値は、
!Access-Control-Expose-Headers$h 応答~headerに依存することになる。
例えば、応答に次の~headerが含まれていたとする：
◎
bar.invalid provides a correct `Access-Control-Allow-Origin` response header per the earlier example. The values of hsts and csp will depend on the `Access-Control-Expose-Headers` response header. For example, if the response included the following headers
</p>


<pre>
!Content-Security-Policy$: !default-src$dir 'self'
Strict-Transport-Security: max-age=31536000; includeSubdomains; preload
Access-Control-Expose-Headers: Content-Security-Policy
</pre>

<p>
この場合，応答が両~headerとも含んでいようが、
%hsts は ~NULL になり， %csp は !default-src 'self'^l になる。
何故なら、 !bar.invalid^s は， !Access-Control-Expose-Headers$h 応答~header内にそれらの~header名を~listすることで，各~headerごとに明示的に共有させる必要があるからである。
◎
then hsts would be null and csp would be "default-src 'self'", even though the response did include both headers. This is because bar.invalid needs to explicitly share each header by listing their names in the `Access-Control-Expose-Headers` response header.
</p>


<p>
別法として，
!bar.invalid^s は、!資格証$を含まない要請に対し，自身による応答~headerすべてを共有させたいと求めるなら、
!Access-Control-Expose-Headers$h 応答~headerの値に !*^bl を利用することもできる。
!資格証$を含む要請に対しては、応答~header名は明示的に~listされる必要があり，
!*^bl は利用できない。
◎
Alternatively, if bar.invalid wanted to share all its response headers, for requests that do not include credentials, it could use `*` as value for the `Access-Control-Expose-Headers` response header. If the request would have included credentials, the response header names would have to be listed explicitly and `*` could not be used.
</p>

</div>

<div class="example" id="example-cors-with-credentials">

<p>
!foo.invalid^s の開発者が今度は、!資格証$も含ませつつ， !bar.invalid^s から何か~dataを~fetchしようとしたとする。
!資格証$には明示的な~opt-inが要求されるので、最早，開発者にとっては，
!~CORS~protocol$周りで透過的でなくなる：
◎
The developer of foo.invalid returns, now fetching some data from bar.invalid while including credentials. This time around the CORS protocol is no longer transparent to the developer as credentials require an explicit opt-in:
</p>

<pre>
fetch(%url, { credentials:"include" }).then(%success, %failure)
</pre>


<p>
これもまた、 !bar.invalid^s が含ませた !Set-Cookie$h 応答~headerを，全部的に~~機能させる（さもなければ無視される）。
◎
This also makes any `Set-Cookie` response headers bar.invalid includes fully functional (they are ignored otherwise).
</p>

<p>
~UAは、要請~内に関連する!資格証$があれば，それも必ず含ませることになる。
また、応答にも，より厳格な要件を課す
— !bar.invalid^s には、 !Access-Control-Allow-Origin$h 値に !https://foo.invalid^bl を~listすることに加え（!資格証$が孕まれる下では !*^bl は許容されない），
!Access-Control-Allow-Credentials$h を提示することも要求される：
◎
The user agent will make sure to include any relevant credentials in the request. It will also put stricter requirements on the response. Not only will bar.invalid be required to list `https://foo.invalid` as value for `Access-Control-Allow-Origin` (`*` is not allowed when credentials are involved), the `Access-Control-Allow-Credentials` has to be present too:
</p>

<pre>
Access-Control-Allow-Origin: https://foo.invalid
Access-Control-Allow-Credentials: true
</pre>


<p>
応答が これらの値を伴うこれら 2 つの~headerを含んでいない場合，
%failure ~callbackが呼出され、その結果， !Set-Cookie$h 応答~headerは無視されることになる。
◎
If the response does not include those two headers with those values, the failure callback will be invoked and any `Set-Cookie` response headers will end up being ignored.
</p>

</div>


			</section>
		</section>
		<section id="x-content-type-options-header">
<h3 title="`X-Content-Type-Options` header">3.3 !X-Content-Type-Options^h ~header</h3>

<p>
!X-Content-Type-Options@h
応答!~header$を利用して、［
!応答$の !Content-Type$h !~header$を，!要請$の!種別$rqに対し検査する
］ことを要求できる。
◎
The `X-Content-Type-Options` response header can be used to require checking of a response’s `Content-Type` header against the type of a request.
</p>

<p>
その!値$hdに対する!~ABNF$は：
◎
Its value ABNF:
</p>

<pre class="ABNF">
X-Content-Type-Options           = "nosniff" ; <span class="comment">大小無視</span>
</pre>



			<section id="should-response-to-request-be-blocked-due-to-nosniff?">

<h4 title="Should response to request be blocked due to nosniff?">3.3.1 %要請 に対する %応答 は， nosniff に因り阻止されるべきか？</h4>

<p>
次の手続きを走らす：
◎
Run these steps:
</p>

<ol>
	<li>
%sniff ~LET
%応答 の!~header~list$rs内の［
!X-Content-Type-Options$h を!名前に持つ~header$
］からなる同順の~list
◎
↓</li>
	<li>
~IF［
%sniff は空である
］
⇒
~RET !許容ed^i
◎
If response’s header list does not contain `X-Content-Type-Options`, then return allowed.
</li>
	<li>
~IF ［［
%sniff 内の<em>最初の!~header$</em>
］から!~header値を抽出-$hdした結果 ~EQ !失敗^i
］
⇒
~RET !許容ed^i
◎
Let nosniff be the result of extracting header values from the first header whose name is a byte-case-insensitive match for `X-Content-Type-Options` in response’s header list.
◎
If nosniff is failure, then return allowed.
</li>
	<li>
%~MIME型 ~LET
%応答 の!~header~list$rsから !~MIME型を抽出-$hdした結果
◎
Let mimeType be the result of extracting a MIME type from response’s header list.
</li>
	<li>
<p>
%要請 の!種別$rqに応じて：
◎
Let type be request’s type.
</p>

		<dl class="switch">
			<dt>!script^l</dt>
			<dd>
~IF［
%~MIME型 は（~parameterは無視して）
<a href="~HEscripting#javascript-mime-type">~JS~MIME型</a>
<em>でない</em>
］
⇒
~RET !阻止ed^i
◎
If type is "script", and mimeType (ignoring parameters) is not a JavaScript MIME type, then return blocked.
</dd>

			<dt>!style^l</dt>
			<dd>
~IF［
%~MIME型 は（~parameterは無視して）
!text/css^bl
<em>でない</em>
］
⇒
~RET !阻止ed^i
◎
If type is "style" and mimeType (ignoring parameters) is not `text/css`, then return blocked.
</dd>
		</dl>
	</li>
<li>
~RET !許容ed^i
◎
Return allowed.
</li>
</ol>


<p class="note">注記：
ここでは !script^l, !style^l のみ考慮される
— どの悪用も これらの!種別$rqに該当するので。
また、ここで !image^l を考慮すると，配備-済みの内容と互換にならなくなる。
◎
Only "script" and "style" are considered as any exploits pertain to those types. Also, considering "image" was not compatible with deployed content.
</p>

			</section>
		</section>
	</section>

	<section id="fetching">

<h2 title="Fetching">4. ~fetching</h2>


<div class="note">

<p>注記：
下の~algoは、!~fetching$を定義する。
大雑把に言えば、それは!要請$を入力にとり，!応答$を出力する。
◎
The algorithm below defines fetching. In broad strokes, it takes a request and outputs a response.
</p>

<p>
すなわち，［
!要請$の!同期~flag$rq ~EQ ~ON
］であれば!応答$を返し，そうでなければ，［
以下において［
!応答を処理する$ ／
!応答の本体終端を処理する$ ／
!応答の~doneを処理する$
］と記される，!応答$に対する演算
］を行うための!~fetch~taskを待入する$。
◎
That is, it either returns a response if request’s synchronous flag is set, or it queues tasks annotated process response, process response end-of-body, and process response done for the response.
</p>

<p>
~uploadを捕捉するため、［
!要請$の!同期~flag$rq ~EQ ~OFF
］の場合は、!要請$上で，［
以下において［
!要請の本体を処理する$ ／
!要請の本体終端を処理する$
］と記される演算
］を行うための!~fetch~taskを待入する$こともある。
◎
To capture uploads, if request’s synchronous flag is unset, tasks annotated process request body and process request end-of-body for the request can be queued.
</p>

</div>


<p class="algo-head">
!要請$ %要請 を用いて
!~fetch@
を遂行するときは、下の~algoを走らす。
進行中の!~fetch$は，終了~事由 %事由 を伴って
!終了-@
され得る。
%事由 は［
!利用者中止^i,
!致命的^i,
!時間切れ^i,
!~garbage収集^i
］のいずれかで~MUST。
◎
To perform a fetch using request, run the steps below. An ongoing fetch can be terminated with reason reason, which must be end-user abort, fatal, timeout, or garbage collection.
</p>

<p>
~UAは、進行中の~fetchを
!休止-@
するよう，請われることもある。
~UAは、その休止~要請を受容しても無視しても~MAY。
休止された~fetchは、
!再開-@
できる。
~UAは、［
進行中の~fetchが，要請に対する~HTTP~cache内の応答を更新している場合
］には，休止~要請を無視する~SHOULDである。
◎
The user agent may be asked to suspend the ongoing fetch. The user agent may either accept or ignore the suspension request. The suspended fetch can be resumed. The user agent should ignore the suspension request if the ongoing fetch is updating the response in the HTTP cache for the request.
</p>

<div class="note">
<p>注記：
次のいずれかの場合、~UAは，!要請$に対する~HTTP~cache内の~entryを更新しない：
</p>

<ul>
	<li>
要請の!~cache~mode$rq ~EQ !no-store^l
</li>
	<li>
応答の !Cache-Control$h ~header値は !no-store^dir を含む
!HTTP-CACHING$r
</li>
</ul>

◎
The user agent does not update the entry in the HTTP cache for a request if request’s cache mode is "no-store" or a `Cache-Control: no-store` header appears in the response. [HTTP-CACHING]
</div>


<ol>
	<li>
~IF［
%要請 の!~window$rq ~EQ !client^l
］
⇒
%要請 の!~window$rq ~SET ［［
%要請 の!~client$rqの!大域~obj$enVは !Window$I ~objである
］ならば %要請 の!~client$rq ／
~ELSE_ !no-window^l
］
◎
If request’s window is "client", set request’s window to request’s client, if request’s client’s global object is a Window object, and to "no-window" otherwise.
</li>
	<li>
~IF［
%要請 の!生成元$rq ~EQ !client^l
］
⇒
%要請 の!生成元$rq ~SET %要請 の!~client$rqの!生成元$html
◎
If request’s origin is "client", set request’s origin to request’s client’s origin.
</li>
	<li>
<p>
~IF［
%要請 の!~header~list$rq内に［
!Accept$h を!名前に持つ~header$
］は無い
］：
◎
If request’s header list does not contain `Accept`, then:
</p>

		<ol>
			<li>
%value ~LET !*/*^bl
◎
Let value be `*/*`.
</li>
			<li>
<p>
~UAは， %value を次で与えられる値に設定する~SHOULDである：
◎
↓</p>
				<ul>
					<li>
%要請 は!~navi要請$であるならば
⇒
!text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8^bl
◎
If request is a navigation request, a user agent should set value to `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`.
</li>
					<li>
<p>
他の場合， %要請 の!種別$rqに応じて：
◎
Otherwise, a user agent should set value to the first matching statement, if any, switching on request’s type:
</p>
						<dl class="switch">
							<dt>!image^l</dt>
							<dd>
!image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5^bl
</dd>

							<dt>!style^l</dt>
							<dd>
!text/css,*/*;q=0.1^bl
</dd>
							<dt>その他</dt>
							<dd>
（何もせず、 %value はそのまま）
</dd>
						</dl>
					</li>
				</ul>
			</li>
			<li>
%要請 の!~header~list$rqに
( !Accept$h / %value )
を!付加-$hlする。
◎
Append `Accept`/value to request’s header list.
</li>
		</ol>

	<li>
~IF［
%要請 の!~header~list$rq内に［
!Accept-Language$h を!名前に持つ~header$
］は無い
］
⇒
~UAは、 %要請 の!~header~list$rqに
( !Accept-Language$h / 適切な!値$hd )
を!付加-$hlするべきである。
◎
If request’s header list does not contain `Accept-Language`, user agents should append `Accept-Language`/an appropriate value to request’s header list.
</li>
	<li>
<p>
~IF［
%要請 の!優先度$rq ~EQ ~NULL
］
⇒
!優先度$rq ~SET
%要請 の［
!起動元$rq, !種別$rq, !行先$rq
］を適切に用いて得られる，~UAにより定義される~obj
◎
If request’s priority is null, use request’s initiator, type, and destination appropriately in setting it to a user-agent-defined object.
</p>

<div class="note" id="_stream-priority">
<p>
注記：
~UAにより定義される~objが含み得るのは、次のいずれかである：
</p>

<ul><li>HTTP/2 のための，~streamの［
重みと依存関係
］
</li><li>HTTP/1 ~fetchにおける［
~dispatchと処理
］に優先度を与えるために利用される，前項と等価な情報
</li></ul>

◎
The user-agent-defined object could encompass stream weight and dependency for HTTP/2, and equivalent information used to prioritize dispatch and processing of HTTP/1 fetches.
</div>
	</li>
	<li>

<div class="p">
<p>
~IF［
%要請 は!~navi要請$である
］
⇒
~UAは、次を行うべきである
⇒
~FOR
下の表の ~EACH ( 行の ( !名前$hd %~hint名, !値$hd %~hint値 ) 組 ) に対し
⇒
~IF［
%要請 の!~header~list$rq内に［
%~hint名 を!名前に持つ~header$
］は無い
］
⇒
%要請 の!~header~list$rqに
( %~hint名 / %~hint値 )
を!付加-$hlする
</p>
◎
If request is a navigation request, a user agent should, for each header name (hintName) in the first column of the following table, if request’s header list does not contain hintName, then append hintName/the value given in the same row on the second column, to request’s header list.
</div>

<table>
<thead><tr><th>!名前$hd
<th>!値$hd
</thead>

<tbody><tr><td>!dpr^bl
<td>相応しい !DPR$h 値
◎
a suitable dpr value
<tr><td>!save-data^bl
<td>相応しい !Save-Data$h 値
◎
a suitable save-data value
<tr><td>!viewport-width^bl
<td>相応しい !Viewport-Width$h 値
◎
a suitable viewport-width value
</tbody></table>

	</li>
	<li>
<p>
~IF［
%要請 は!下位資源~要請$である
］：
◎
If request is a subresource request, run these substeps:
</p>

		<ol>
			<li>
<p>
~IF［
%要請 の!~client~hint~list$rqは空でない
］
⇒
~FOR
~list内の ~EACH ( %~hint名 ) に対し：
◎
If request’s client hints list is not empty, then run these substeps for each hintName in the list:
</p>
				<ol>
					<li>
<p>
%値 ~SET %~hint名 に応じて，次で与えられる値
◎
Set value to the first matching statement, if any, switching on hintName:
</p>
						<dl class="switch">
							<dt>!dpr^l</dt>
							<dd>
相応しい !DPR$h 値
◎
a suitable dpr value
</dd>
							<dt>!save-data^l</dt>
							<dd>
相応しい !Save-Data$h 値
◎
a suitable save-data value
</dd>
							<dt>!viewport-width^l</dt>
							<dd>
相応しい !Viewport-Width$h 値
◎
a suitable viewport-width value
</dd>
							<dt>!width^l</dt>
							<dd>
相応しい !Width$h 値
◎
a suitable width value
</dd>
						</dl>
					</li>
					<li>
%要請 の!~header~list$rqに
( %~hint名 / %値 )
を!付加-$hlする
◎
Append hintName/value to request’s header list.
</li>
				</ol>
			</li>
			<li>
%記録 ~LET 次のようにされた，新たな!~fetch記録$
⇒
!要請$fg ~SET %要請；<br>
!~fetch$fg ~SET この!~fetch$~algoの~instance
◎
Let record be a new fetch record consisting of request and this instance of the fetch algorithm.
</li>
			<li>
%記録 を［
%要請 の!~client$rqの!~fetch~group$を成す，!~fetch記録$たちの~list
］に付加する
◎
Append record to request’s client’s fetch group list of fetch records. 
</li>
		</ol>
	</li>
	<li>
~RET %要請 を用いて!~main~fetch$を遂行した結果
◎
Return the result of performing a main fetch using request.
</li>
</ol>

		<section id="main-fetch">
<h3 title="Main fetch">4.1. ~main~fetch</h3>

<p class="algo-head">
( %~CORS~flag（省略時は ~OFF ）, %再帰~flag（省略時は ~OFF ） )
が与えられた下で，
要請 %要請 を用いて
!~main~fetch@
を遂行するときは、下の~algoを走らす。
◎
To perform a main fetch using request, optionally with a CORS flag and recursive flag, run these steps:
</p>

<p class="note">注記：
!~main~fetch$が再帰的に呼出されるときには，
%再帰~flag は ~ON にされる。
%~CORS~flag は、~redirectを取扱うための内部状態管理に用いられる。
◎
When main fetch is invoked recursively recursive flag is set. CORS flag is a bookkeeping detail for handling redirects.
</p>

<ol>

	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
~IF［
%要請 の!局所URLonly~flag$ ~EQ ~ON
］~AND［
%要請 の!現在の~url$rqは!局所的$でない
］
⇒
%応答 ~SET !~network~error$
◎
If request’s local-URLs-only flag is set and request’s current url is not local, set response to a network error.
</li>
	<li>
%要請 に対し
<a href="~CSP3#report-for-request">~CSP違反を報告する</a>
!CSP$r
◎
Execute Report Content Security Policy violations for request. [CSP]
</li>
	<li>
<a href="https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request">適切になるなら %要請 を potentially secure URL に昇格する</a>。
!UPGRADE$r
◎
Upgrade request to a potentially secure URL, if appropriate. [UPGRADE]
</li>
	<li>
<p>
~IF ［
次のいずれかの結果 ~EQ !阻止ed^i
］…：
</p>

<ul>
	<li>
%要請 の!~fetchingは，不良~portに因り阻止されるべきか？$
</li>
	<li>
<a href="~MIXED-CONTENT#should-block-fetch">%要請 の~fetchingは，混在~内容として阻止されるべきか？</a>
!MIX$r
</li>
	<li>
<a href="~CSP3#should-block-request">%要請 の~fetchingは，~CSPにより阻止されるべきか？</a>
!CSP$r
</li>
</ul>

<p>
…ならば
⇒
%応答 ~SET !~network~error$
</p>

◎
If should fetching request be blocked due to a bad port, should fetching request be blocked as mixed content, or should fetching request be blocked by Content Security Policy returns blocked, set response to a network error. [MIX] [CSP]
</li>
	<li>
~IF［
%要請 の!~referrer施策$rq ~EQ 空~文字列
］~AND［
%要請 の!~client$rq ~NEQ ~NULL
］
⇒
%要請 の!~referrer施策$rq ~SET %要請 の!~client$rqの!~referrer施策$enV
!REFERRER$r
◎
If request’s referrer policy is the empty string and request’s client is non-null, then set request’s referrer policy to request’s client’s referrer policy. [REFERRER]
</li>
	<li>
<p>
~IF［
%要請 の!~referrer施策$rq ~EQ 空~文字列
］
⇒
%要請 の!~referrer施策$rq ~SET !no-referrer-when-downgrade^l
◎
If request’s referrer policy is the empty string, then set request’s referrer policy to "no-referrer-when-downgrade".
</p>

<p class="note">注記：
ここでは
!no-referrer-when-downgrade^l
を利用する
— それが、歴史的な既定なので。
◎
We use "no-referrer-when-downgrade" because it is the historical default.
</p>
	</li>
	<li>
<p>
~IF［
%要請 の!~referrer$rq ~NEQ !no-referrer^l
］
⇒
%要請 の!~referrer$rq ~SET
%要請 の!~referrerを決定-$した結果
!REFERRER$r
◎
If request’s referrer is not "no-referrer", set request’s referrer to the result of invoking determine request’s referrer. [REFERRER]
</p>

<p class="note">注記：
!Referrer Policy^cite 仕様に定められている様に、~UAは，末端利用者に対し，
%要請 の!~referrer$rqを常に !no-referrer^l で上書きするような選択余地, または
より~sensitiveでない情報を公開するような選択余地を与えることができる。
◎
As stated in Referrer Policy, user agents can provide the end user with options to override request’s referrer to "no-referrer" or have it expose less sensitive information.
</p>
	</li>
	<li>
~IF［
%要請 の!現在の~url$rqの!~scheme$url ~EQ !ftp^l
］~AND［
%要請 の!~client$rqの!作成時の~URL$enVの!~scheme$url ~NEQ !ftp^l
］~AND［
%要請 の!予約済み~client$rqは［
~NULL, または［
!環境$であって，その!~target閲覧文脈$enVは!入子の閲覧文脈$である
］］］
⇒
%応答 ~SET !~network~error$
◎
If request’s current URL’s scheme is "ftp", request’s client’s creation URL’s scheme is not "ftp", and request’s reserved client is either null or an environment whose target browsing context is a nested browsing context, then set response to a network error.
</li>
	<li>
<p>
~IF［
次のいずれの条件も満たされる
］…：
◎
Set request’s current url’s scheme to "https" if all of the following conditions are true:
</p>

		<ul>
			<li>
%要請 の!現在の~url$rqの!~scheme$url ~EQ !http^l
◎
request’s current url’s scheme is "http"
</li>
			<li>
%要請 の!現在の~url$rqの!~host$urlは!~domain$urlである
◎
request’s current url’s host is a domain
</li>
			<li>
<p>
%要請 の!現在の~url$rqの!~host$urlを
<a href="~IETF/rfc6797#section-8.2">Known HSTS Host Domain Name Matching</a>
!HSTS$r
に従って match した結果は、次のいずれかである：
</p>

<ul ><li>superdomain match with an asserted !includeSubDomains^dir directive
</li><li>congruent match (with or without an asserted !includeSubDomains^dir directive)
</li></ul>

◎
Matching request’s current url’s host per Known HSTS Host Domain Name Matching results in either a superdomain match with an asserted includeSubDomains directive or a congruent match (with or without an asserted includeSubDomains directive) [HSTS]
</li></ul>

<p>
…ならば
⇒
%要請 の!現在の~url$rqの!~scheme$url ~SET !https^l
◎
↑</p>

	</li>
	<!-- Per Mike West HSTS happens "probably after" Referrer -->

	<li>
~IF［
%要請 の!同期~flag$rq ~EQ ~OFF
］~AND［
%再帰~flag ~EQ ~OFF
］
⇒
~RET — ただし，この手続きの残りの部分は、!並列的$htmlに走らす。
◎
If request’s synchronous flag is unset and recursive flag is unset, run the remaining steps in parallel.
</li>
	<li>
<p>
~IF［
%応答 ~EQ ~NULL
］
⇒
%応答 ~SET 次のうち，最初に合致する条件に対応する下位手続きを走らせた結果：
◎
If response is null, then set response to the result of running the substeps corresponding to the first matching statement:
</p>

		<dl class="switch">
			<dt>
［
( %要請 の!現在の~url$rqの!生成元$html, %要請 の!生成元$rq )
は，!同一生成元$である
］~AND［
%~CORS~flag ~EQ ~OFF
］
◎
request’s current url’s origin is same origin with request’s origin and CORS flag is unset
</dt>
			<dt>
%要請 の!現在の~url$rqの!~scheme$url ~EQ !data^l
◎
request’s current url’s scheme is "data"
</dt>
			<dt>
%要請 の!~mode$rq ~IN { !navigate^l, !websocket^l }
◎
request’s mode is "navigate" or "websocket"
</dt>
			<dd>
				<ol>
					<li>
%要請 の!応答~tainting$rq ~SET !basic^l
◎
Set request’s response tainting to "basic".
</li>
					<li>
~RET %要請 を用いて!基本~fetch$を遂行した結果
◎
Return the result of performing a basic fetch using request.
</li>
				</ol>

<p class="note">注記：
~HTMLは、［
!~scheme$url ~EQ !data^l
］なる!~URL$から作成された どの［
文書 ／ ~worker
］に対しても，一意かつ!不透明な生成元$をあてがう。
~service-workerは、［
!~scheme$url ~IN !~HTTP_S~scheme$
］なる!~URL$からのみ作成される。
!HTML$r
!SW$r
◎
HTML assigns any documents and workers created from URLs whose scheme is "data" a unique opaque origin. Service workers can only be created from URLs whose scheme is an HTTP(S) scheme. [HTML] [SW]
</p>
			</dd>

			<dt>
%要請 の!~mode$rq ~EQ !same-origin^l
◎
request’s mode is "same-origin"
</dt>
			<dd>
				<ol>
					<li>
~RET !~network~error$
◎
Return a network error.
</li>
				</ol>
			</dd>

			<dt>
%要請 の!~mode$rq ~EQ !no-cors^l
◎
request’s mode is "no-cors"
</dt>
			<dd>
				<ol>
					<li>
%要請 の!応答~tainting$rq ~SET !opaque^l
◎
Set request’s response tainting to "opaque".
</li>
					<li>
~RET %要請 を用いて!基本~fetch$を遂行した結果
<!-- file URLs end up here as they are not same-origin typically. -->
◎
Return the result of performing a basic fetch using request.
</li>
				</ol>
			</dd>

			<dt>
%要請 の!現在の~url$rqの!~scheme$url ~NIN !~HTTP_S~scheme$
◎
request’s current url’s scheme is not an HTTP(S) scheme
</dt>
			<dd>
				<ol>
					<li>
~RET !~network~error$
◎
Return a network error.
</li>
					</ol>
				</dd>

			<dt>
%要請 の!~CORS予行~利用~flag$rq ~EQ ~ON
◎
request’s use-CORS-preflight flag is set
</dt>
			<dt>
［
%要請 の!非安全-要請~flag$rq ~EQ ~ON
］~AND［［
%要請 の!~method$rqは !~CORS安全な~method$でない
］~OR［
%要請 の!~header~list$rq内に!~CORS安全な要請~header$でない!~header$は在る
］］
◎
request’s unsafe-request flag is set and either request’s method is not a CORS-safelisted method or a header in request’s header list is not a CORS-safelisted request-header
</dt>
			<dd>
				<ol>
					<li>
%要請 の!応答~tainting$rq ~SET !cors^l
◎
Set request’s response tainting to "cors".
</li>
					<li>
%~CORS予行~付き応答 ~LET
( %~CORS~flag ~SET ~ON, %~CORS予行~flag ~SET ~ON )
を与える下で， %要請 を用いて!~HTTP~fetch$を遂行した結果
◎
Let corsWithPreflightResponse be the result of performing an HTTP fetch using request with CORS flag and CORS-preflight flag set.
</li>
					<li>
~IF［
%~CORS予行~付き応答 は!~network~error$である
］
⇒
%要請 を用いて!予行~cacheの~entryを消去する$cc
◎
If corsWithPreflightResponse is a network error, then clear cache entries using request.
</li>
					<li>
~RET %~CORS予行~付き応答
◎
Return corsWithPreflightResponse.
</li>
				</ol>
			</dd>

			<dt>
~OTHER
◎
Otherwise
</dt>
			<dd>
				<ol>
					<li>
%要請 の!応答~tainting$rq ~SET !cors^l
◎
Set request’s response tainting to "cors".
</li>
					<li>
~RET
( %~CORS~flag ~SET ~ON )
を与える下で，
%要請 を用いて!~HTTP~fetch$を遂行した結果
◎
Return the result of performing an HTTP fetch using request with CORS flag set.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~IF［
%再帰~flag ~EQ ~ON
］
⇒
~RET %応答
◎
If the recursive flag is set, return response.
</li>
	<li>
<p>
~IF［
%応答 は!~network~error$でない
］~AND［
%応答 は!絞込み応答$でない
］：
◎
If response is not a network error and response is not a filtered response, then run these substeps:
</p>
		<ol>
			<li>
<p>
~IF［
%要請 の!応答~tainting$rq ~EQ !cors^l
］：
◎
If request’s response tainting is "cors", then run these substeps:
</p>
				<ol>
					<li>
%~header名s ~LET
%応答 の!~header~list$rsから
!Access-Control-Expose-Headers$h
に対する!~header~list値を抽出-$hdした結果
◎
Let headerNames be the result of extracting header list values given `Access-Control-Expose-Headers` and response’s header list.
</li>
					<li>
~IF［
%~header名s は !*^bl のみからなる
］
⇒
~IF［
%要請 の!資格証~mode$rq ~NEQ !include^l
］
⇒
%応答 の!~CORSに公開される~header名~list$rs ~SET
%応答 の!~header~list$rs内の各!~header$の!名前$hdからなる~list
— ここで、各~名前は，~list内で一意にする
◎
If headerNames is `*` and request’s credentials mode is not "include", then set response’s CORS-exposed header-name list to all unique header names in response’s header list.
</li>
					<li>
~ELIF［
%~header名s ~NIN { ~NULL, !失敗^i }
］
⇒
%応答 の!~CORSに公開される~header名~list$rs ~SET %~header名s
◎
Otherwise, if headerNames is not null, failure, or `*`, then set response’s CORS-exposed header-name list to headerNames.
</li>
				</ol>
			</li>
			<li>
<p>
%応答 ~SET
%応答 を!内的~応答$とする!絞込み応答$であって，
%要請 の!応答~tainting$rqに応じて 次で与えられるもの：
◎
Set response to the following filtered response with response as its internal response, depending on request’s response tainting:
</p>

				<dl class="switch compact">
					<dt>!basic^l</dt>
					<dd>
!基本~絞込み応答$
◎
basic filtered response
</dd>

					<dt>!cors^l</dt>
					<dd>
!~CORS絞込み応答$
◎
CORS filtered response
</dd>

					<dt>!opaque^l</dt>
					<dd>
!不透明な絞込み応答$
◎
opaque filtered response
</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
%内的~応答 ~LET ［
%応答 は!~network~error$ならば %応答 ／
~ELSE_ %応答 の!内的~応答$
］
◎
Let internalResponse be response, if response is a network error, and response’s internal response otherwise.
</li>
	<li>
<p>
~IF［
%内的~応答 の!~url~list$rs は空である
］
⇒
%内的~応答 の!~url~list$rs ~SET %要請 の!~url~list$rqの複製
◎
If internalResponse’s url list is empty, then set it to a copy of request’s url list.
</p>

<p class="note">注記：
!応答$の!~url~list$rsは、この時点では概して空である
— ただし，~service-workerから来た応答については、空になるのは
<a href="#dom-response">!new Response()^m</a>
を通して作成されたものに限られる。
<!-- If you are ever tempted to move this around, carefully consider responses from about URLs,
      blob URLs, service workers, HTTP cache, HTTP network, etc. -->
◎
A response’s url list will typically be empty at this point, unless it came from a service worker, in which case it will only be empty if it was created through new Response().
</p>
	</li>
	<li>
<p>
~IF ［
%応答 は!~network~error$でない
］~AND［
次のいずれかの結果 ~EQ !阻止ed^i
］…：
◎
If response is not a network error and any of the following algorithms returns blocked, then set response and internalResponse to a network error:
</p>

		<ul>
			<li>
<a href="~MIXED-CONTENT#should-block-response">%要請 に対する %内的~応答 は，混在~内容として阻止されるべきか？</a>
!MIX$r
◎
should internalResponse to request be blocked as mixed content [MIX]
</li>
			<li>
<a href="~CSP3#should-block-response">%要請 に対する %内的~応答 は，~CSPにより阻止されるべきか？</a>
!CSP$r
◎
should internalResponse to request be blocked by Content Security Policy [CSP]
</li>
			<li>
<a href="#should-response-to-request-be-blocked-due-to-mime-type?">%要請 に対する %内的~応答 は，~MIME型に因り阻止されるべきか？</a>
◎
should internalResponse to request be blocked due to its MIME type
</li>
			<li>
<a href="#should-response-to-request-be-blocked-due-to-nosniff?">%要請 に対する %内的~応答 は， nosniff に因り阻止されるべきか？</a>
◎
should internalResponse to request be blocked due to nosniff 
</li>
		</ul>

<p>
…ならば
⇒
( %応答, %内的~応答 ) ~SET ( !~network~error$, !~network~error$ )
<!-- ＊同一の個？ -->
◎
↑</p>

	</li>
	<li>
<p>
~IF［
%応答 は!~network~error$でない
］~AND［［
%要請 の!~method$rq ~IN { !HEAD$hm, !CONNECT$hm }
］~OR［
%内的~応答 の!~status$rs
は !~null本体~status$である
］］
⇒
%内的~応答 の!本体$rs ~SET ~NULL
— 以降、本体への~enqueueはすべて~~無視する
◎
If response is not a network error and either request’s method is `HEAD` or `CONNECT`, or internalResponse’s status is a null body status, set internalResponse’s body to null and disregard any enqueuing toward it (if any).
</p>

<p class="note">注記：
これは、~HTTPに違反する~serverに対する~errorの取扱いを標準化する。
◎
This standardizes the error handling for servers that violate HTTP.
</p>
	</li>
	<li>
<p>
~IF ［
%応答 は!~network~error$でない
］~AND［
%要請 の!完全性~metadata$rq ~NEQ 空~文字列
］：
◎
If response is not a network error and request’s integrity metadata is not the empty string, run these substeps:
</p>

		<ol>
			<li>
%応答 の!本体$rsを!待機-$bdする
◎
Wait for response’s body.
</li>
			<li>
~IF ［
%応答 の!終了~事由$rs ~EQ ε
］~AND［
%応答 は %要請 の!完全性~metadata$rqに!合致$srIしない !SRI$r
］
⇒
( %応答, %内的~応答 ) ~SET ( !~network~error$, !~network~error$ )
◎
If response does not have a termination reason and response does not match request’s integrity metadata, set response and internalResponse to a network error. [SRI]
</li>
		</ol>

<p class="note">注記：
これは %応答 上で演算する
— この~algoは %内的~応答 を観測するように想定されていないので。
それを許容すると、攻撃者が~hashを神託機械†（ oracle ）として利用できるようになる。
<span class="trans-note">【†
— 参考：
<a href="http://security.stackexchange.com/questions/10617/what-is-a-cryptographic-oracle">cryptographic oracle</a>,
<a href="https://en.wikipedia.org/wiki/Padding_oracle_attack">padding oracle attack</a>,
!ランダムオラクル$
】</span>
◎
This operates on response as this algorithm is not supposed to observe internalResponse. That would allow an attacker to use hashes as an oracle.
</p>
	</li>
	<li>
<div class="p">
<p>
~IF［
%要請 の!同期~flag$rq ~EQ ~ON
］：
</p>

<ol><li>%内的~応答 の!本体$rsを!待機-$bdする
</li><li>~RET %応答
</li></ol>

◎
If request’s synchronous flag is set, wait for internalResponse’s body, and then return response.
</div>

<p class="note">注記：
これは!~fetch$を終了させる。
◎
This terminates fetch.
</p>
	</li>
	<li>
<p>
~IF［
%要請 の!現在の~url$rqの!~scheme$url ~IN !~HTTP_S~scheme$
］：
◎
If request’s current url’s scheme is an HTTP(S) scheme, then run these substeps:
</p>

		<ol>
			<li>
~IF［
%要請 の!本体$rqは!~done$bdでない
］
⇒
%要請 の!本体$rqを!並列的$htmlに!待機-$bdする
◎
↓</li>
			<li>
%要請 に対する!~fetch要請~done~taskを待入する$
◎
If request’s body is done, queue a fetch-request-done task for request.
◎
Otherwise, in parallel, wait for request’s body, and then queue a fetch-request-done task for request. 
</li>
		</ol>
	</li>
	<li>
%要請 上で［
%応答 に対し!応答を処理する$
］ための!~fetch~taskを待入する$
◎
Queue a fetch task on request to process response for response.
</li>
	<li>
%内的~応答 の!本体$rsを!待機-$bdする
◎
Wait for internalResponse’s body.
</li>
	<li>
%要請 上で［
%応答 に対し!応答の本体終端を処理する$
］ための!~fetch~taskを待入する$
◎
Queue a fetch task on request to process response end-of-body for response.
</li>
	<li>
%内的~応答 の!~trailer$rsがあれば、それを待機する
<span class="note">
!HTTP$r <a href="~7230#section-4.1.2">4.1.2 節</a> を見よ。
</span>
◎
Wait for internalResponse’s trailer, if any. See section 4.1.2 of [HTTP]. 
</li>
	<li>
%要請 の!~done~flag$rq ~SET ~ON
◎
Set request’s done flag.
</li>
	<li>
%要請 上で［
%応答 に対し!応答の~doneを処理する$
］ための!~fetch~taskを待入する$
◎
Queue a fetch task on request to process response done for response.
</li>
</ol>


		</section>
		<section id="basic-fetch">

<h3 title="Basic fetch">4.2. 基本~fetch</h3>

<p class="algo-head">
要請 %要請 を用いて
!基本~fetch@
を遂行するときは、
%要請 の!現在の~url$rq の!~scheme$urlに応じて，次の中から 対応する手続きを走らす：
◎
To perform a basic fetch using request, switch on request’s current url’s scheme, and run the associated steps:
</p>

<dl class="switch">
	<dt>!about^l</dt>
	<dd>
		<ol>
			<li>
%~url ~LET %要請 の!現在の~url$rq
◎
↓</li>
			<li>
<p>
~IF［
%~url の!~cannot-be-a-base-URL~flag$url ~EQ ~ON
］~AND［
%~url の!~path$urlは 単独の文字列 !blank^l からなる
］
⇒
~RET 各種~fieldが次のように設定された，新たな!応答$：
</p>

<ul ><li>!~header~list$rs ~SET
!新たな~header$( !Content-Type$h / !text/html;charset=utf-8^bl )
のみからなる~list
</li><li>!本体$rs ~SET 空~byte列
</li><li>!~HTTPS状態$rs ~SET ［
%要請 の!~client$rq ~NEQ ~NULL ならば それの!~HTTPS状態$enV ／
~ELSE_ 既定~値のまま
］
</li></ul>

◎
If request’s current url’s cannot-be-a-base-URL flag is set and path contains a single string "blank", return a response whose header list consist of a single header whose name is `Content-Type` and value is `text/html;charset=utf-8`, body is the empty byte sequence, and HTTPS state is request’s client’s HTTPS state if request’s client is non-null.
</li>
			<li>
~RET !~network~error$
◎
Otherwise, return a network error.
</li>
		</ol>

<p class="note">注記：
!about:config^l の類いの!~URL$は、!~navi$の間に取扱われ，!~fetch$の文脈~下では!~network~error$になる。
◎
URLs such as "about:config" are handled during navigation and result in a network error in the context of fetching.
</p>

	</dd>

	<dt>!blob^l</dt>
	<dd>
		<ol>
			<li>
%blob ~LET %要請 の!現在の~url$rqの!~obj$url
◎
Let blob be request’s current url’s object.
</li>
			<li>
<p >
~IF［
%要請 の!~method$rq ~NEQ !GET$hm
］~OR［
%blob ~EQ ~NULL
］
⇒
~RET !~network~error$
◎
If request’s method is not `GET` or blob is null, then return a network error.
</p>


<p class="note">注記：
!GET^hm !~method$の制約には、相互運用可能にする以外に有用な目的はない。
◎
The `GET` method restriction serves no useful purpose other than being interoperable.
</p>

			</li>
			<li>
%応答 ~LET 新たな!応答$
◎
Let response be a new response.
</li>
			<li>
%応答 の!~header~list$rsに
( !Content-Length$h / %blob の !size$mF 属性~値 )
を!付加-$hlする
◎
Append `Content-Length`/blob’s size attribute value to response’s header list.
</li>
			<li>
%応答 の!~header~list$rsに
( !Content-Type$h / %blob の !type$mF 属性~値)
を!付加-$hlする
◎
Append `Content-Type`/blob’s type attribute value to response’s header list.
</li>
			<li>
~IF［
%要請 の!~client$rq ~NEQ ~NULL
］
⇒
%応答 の!~HTTPS状態$rs ~SET
%要請 の!~client$rqの!~HTTPS状態$enV
◎
Set response’s HTTPS state to request’s client’s HTTPS state if request’s client is non-null.
</li>
			<li>
%応答 の!本体$rs ~SET
%blob に対し!読取り演算$xを遂行した結果
			<!-- This takes care of setting length, transmitted, and error flag as well -->
◎
Set response’s body to the result of performing the read operation on blob.
</li>
			<li>
~RET %応答
◎
Return response. 
</li>
		</ol>
	</dd>

	<dt>!data^l</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
%要請 の!現在の~url$rqから~~成功裡に
<a href="https://simonsapin.github.io/data-urls/">資源を獲得</a>
できた
］：
</p>

				<ol>
					<li>
%結果 ~SET その獲得結果
!DATAURL$r
</li>
					<li>
<p>
~RET 各種~fieldが次のように設定された，新たな!応答$：
</p>

<ul ><li>!~header~list$rs ~SET
!新たな~header$( !Content-Type$h / %結果 の［
~MIME型と~parameter
］)
のみからなる~list
</li><li>!本体$rs ~SET %結果 の~data
</li><li>~IF［
%要請 の!~client$rq ~NEQ ~NULL
］
⇒
!~HTTPS状態$rs ~SET %要請 の!~client$rqの!~HTTPS状態$enV
</li></ul>

<!-- XXX "obtaining a resource" needs a better reference -->
					</li>
				</ol>
◎
If obtaining a resource from request’s current url does not return failure, then return a response whose header list consist of a single header whose name is `Content-Type` and value is the MIME type and parameters returned from obtaining a resource, body is the data returned from obtaining a resource, and HTTPS state is request’s client’s HTTPS state if request’s client is non-null. [DATAURL]
</li>
			<li>

~RET !~network~error$
◎
Otherwise, return a network error.
</li>
		</ol>
	</dd>

	<dt>!file^l</dt>
	<dt>!ftp^l</dt>
	<dd>
現時点では、あいにく，［
file ／ ftp
］!~URL$については、~~実装者に向けての~~課題とする。
◎
For now, unfortunate as it is, file and ftp URLs are left as an exercise for the reader.
</dd>
	<dd>
疑わしい場合は!~network~error$を返すこと。
◎
When in doubt, return a network error.
</dd>

	<dt>!filesystem^l</dt> <!-- flag below also applies to "indexeddb" -->
	<dd>
<p>
~IF［
%要請 の!~sandboxed-storage-area-URLs~flag$ ~EQ ~ON
］
⇒
~RET !~network~error$
◎
If request’s sandboxed-storage-area-URLs flag is set, return a network error.
</p>

<p>
~ELSE
⇒
<span class="XXX">課題：
… この~schemeは、依然，定義される必要がある。
</span>
◎
Otherwise, … this scheme still needs to be defined.
</p>
	</dd>

	<dt>!~HTTP_S~scheme$</dt>
	<dd>
~RET %要請 を用いて!~HTTP~fetch$を遂行した結果
◎
Return the result of performing an HTTP fetch using request.
</dd>

	<dt>
~OTHER
◎
Otherwise
	</dt>
	<dd>
~RET !~network~error$
◎
Return a network error.
</dd>

</dl>


		</section>
		<section id="http-fetch">
<h3 title="HTTP fetch">4.3. ~HTTP~fetch</h3>

<p class="algo-head">
( %~CORS~flag（省略時は ~OFF ）, %~CORS予行~flag（省略時は ~OFF ） )
が与えられた下で， %要請 を用いて
!~HTTP~fetch@
を遂行するときは、次を走らす：
◎
To perform an HTTP fetch using request with an optional CORS flag and CORS-preflight flag, run these steps:
</p>

<p class="note">注記：
%~CORS~flag は、ここでも内部状態管理に用いられる。
%~CORS予行~flag も同様であり、!~CORS予行~要請$が必要になることを指示する。
◎
CORS flag is still a bookkeeping detail. As is CORS-preflight flag; it indicates a CORS-preflight request is needed.
</p>

<ol>
	<!-- Making a "request" -->

	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%実0応答 ~LET ~NULL
◎
Let actualResponse be null.
</li>
	<li>
<p>
~IF［
%要請 の!~service-worker~mode$rq ~NEQ !none^l
］：
◎
If request’s service-workers mode is not "none", then run these substeps: 
</p>

		<ol>
			<li>
~IF［
%要請 の!~service-worker~mode$rq ~EQ !all^l
］
⇒
%応答 ~SET %要請 に対し
<a href="~SW#handle-fetch">~fetchを取扱った</a>
結果
!HTML$r
!SW$r
◎
If request’s service-workers mode is "all", then set response to the result of invoking handle fetch for request. [HTML] [SW]
</li>
			<li>
<p>
~IF［
%応答 ~EQ ~NULL
］~AND［
%要請 は!下位資源~要請$である
］~AND［
( %要請 の!生成元$rq, %要請 の!~url$rqの!生成元$url )
は，!同一生成元$でない
］
⇒
%応答 ~SET %要請 に対し
<a href="~SW#handle-foreign-fetch">外来の~fetchを取扱った</a>
結果
!SW$r
◎
If response is null, request is a subresource request, and request’s origin is not same origin with request’s url’s origin, then set response to the result of invoking handle foreign fetch for request. [SW]
</li>
			<li>
<p>
~IF［
%応答 ~NEQ ~NULL
］：
◎
If response is not null, then run these substeps:
</p>
				<ol>
					<li>
%要請 に対する!本体を伝送する$
◎
Transmit body for request.
</li>
					<li>
%実0応答 ~SET ［
%応答 は!絞込み応答$でないならば %応答 ／
~ELSE_ %応答 の!内的~応答$
］
◎
Set actualResponse to response, if response is not a filtered response, and to response’s internal response otherwise.
</li>
					<li>
<p>
~IF［
次のいずれかの条件が満たされる
］
⇒
~RET !~network~error$：
◎
If one of the following conditions is true, then return a network error: 
</p>
						<ul>
							<li>
%応答 の!種別$rs ~EQ !error^l
◎
response’s type is "error".
</li>
							<li>
［
%要請 の!~mode$rq ~NEQ !no-cors^l
］~AND［
%応答 の!種別$rs ~EQ !opaque^l
］
◎
request’s mode is not "no-cors" and response’s type is "opaque".
</li>
							<li>
［
%要請 の!~redirect~mode$rq ~NEQ !manual^l
］~AND［
%応答 の!種別$rs ~EQ !opaqueredirect^l
］
◎
request’s redirect mode is not "manual" and response’s type is "opaqueredirect".
</li>
							<li>
［
%要請 の!~redirect~mode$rq ~NEQ !follow^l
］~AND［
%応答 の!~url~list$rs 内に複数の項がある
］
◎
request’s redirect mode is not "follow" and response’s url list has more than one item.
</li>
						</ul>
					</li>
					<li>
%実0応答 上で!応答の~CSP~listを設定する$
!CSP$r
<!-- リンク先誤記
~CSP3/#set-response-policy-list
 -->
◎
Execute set response’s CSP list on actualResponse. [CSP]
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%応答 ~EQ ~NULL
］：
◎
If response is null, run these substeps:
</p>

		<ol>
			<li>
<p>
~IF［
%~CORS予行~flag ~EQ ~ON
］~AND［
%要請 は、次のいずれかを満たす
］…：
◎
If the CORS-preflight flag is set and one of these conditions is true:
</p>

				<ul>
					<li>
<p>
%要請 は、次の両者とも満たす：
</p>

<ul>
	<li>
%要請 の!~method$rqは， %要請 の下で!~cacheに合致$ccmしない
</li>
	<li>
<p>
%要請 は、次のいずれかを満たす：
</p>
<ul ><li>%要請 の!~method$rqは !~CORS安全な~method$でない
</li><li>%要請 の!~CORS予行~利用~flag$rq ~EQ ~ON
</li></ul>

	</li>
</ul>

◎
There is no method cache match for request’s method using request, and either request’s method is a not a CORS-safelisted method or request’s use-CORS-preflight flag is set.
</li>
					<li>
<p>
%要請 の!~header~list$rq内に，次の両者とも満たす!~header$は在る：
</p>

<ul ><li>~headerの!名前$hdは， %要請 の下で!~cacheに合致$cchしない
</li><li>~headerは!~CORS安全な要請~header$でない
</li></ul>

◎
There is at least one header in request’s header list for whose name there is no header-name cache match using request and which is not a CORS-safelisted request-header.
</li>
				</ul>

<p>
…ならば：
◎
Then run these subsubsteps:
</p>

				<ol>
					<li>
%予行~応答 ~LET %要請 を用いて!~CORS予行~fetch$を遂行した結果
◎
Let preflightResponse be the result of performing a CORS-preflight fetch using request.
</li>
					<li>
~IF［
%予行~応答 は!~network~error$である
］
⇒
~RET %予行~応答
◎
If preflightResponse is a network error, return preflightResponse.
</li>
				</ol>

<p class="note">注記：
この段は、!~CORS予行~cache$ccを検査した上で，相応しい~entryがなければ!~CORS予行~fetch$を遂行し、成功裡であれば この~cacheを拡充する。
!~CORS予行~fetch$の目的は、!~fetch$された資源が!~CORS~protocol$下に~~置かれることを確保することである。
この~cacheは、!~CORS予行~fetch$の回数を最小化するためにある。
◎
This step checks the CORS-preflight cache and if there is no suitable entry it performs a CORS-preflight fetch which, if successful, populates the cache. The purpose of the CORS-preflight fetch is to ensure the fetched resource is familiar with the CORS protocol. The cache is there to minimize the number of CORS-preflight fetches.
</p>

			</li>
			<li>
<p>
~IF［
%要請 の!~redirect~mode$rq ~EQ !follow^l
］
⇒
%要請 の!~service-worker~mode$rq ~SET !foreign^l
◎
If request’s redirect mode is "follow", then set request’s service-workers mode to "foreign".
</p>

<p class="note">注記：
（~service-workerとは~~対照的に）~networkから来る~redirectは、~service-workerには公開されない。
◎
Redirects coming from the network (as opposed to from a service worker) are not to be exposed to a service worker.
<p>
			</li>
			<li>
%実0応答 ~SET
( %~CORS~flag )
をそのまま与える下で，
%要請 を用いて!~HTTP~network-or-cache~fetch$を遂行した結果
◎
Set response and actualResponse to the result of performing an HTTP-network-or-cache fetch using request with CORS flag if set.
</li>
			<li>
%応答 ~SET %実0応答
◎
↑</li>
			<li>
<p>
~IF［
%~CORS~flag ~EQ ~ON
］~AND［
( %要請, %応答 )
に対する!~CORS検査$の結果 ~EQ !失敗^i
］
⇒
~RET !~network~error$
◎
If CORS flag is set and a CORS check for request and response returns failure, then return a network error.
</p>

<p class="note">注記：
!~CORS検査$は、［
!~status$rs ~IN { !304$st, !407$st } なる!応答$ ／
それが~~懸案になる~service-workerからの!応答$
］には適用されないので、ここで適用される。
◎
As the CORS check is not to be applied to responses whose status is 304 or 407, or responses from a service worker for that matter, it is applied here.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%実0応答 の!~status$rsは!~redirect~status$である
］：
◎
If actualResponse’s status is a redirect status, then run these substeps:
</p>

		<ol>
			<li>
<p>
~IF［
%実0応答 の!~status$rs ~NEQ !303$st
］~AND［
%要請 の!本体$rqは!~done$bdでない
］~AND［
!接続$は HTTP/2 を利用している
］
⇒
~UAは !RST_STREAM^c ~frameを伝送して~MAY
— また，そうすることが奨励される。
◎
If actualResponse’s status is not 303, request’s body is not done, and the connection uses HTTP/2, then user agents may, and are even encouraged to, transmit an RST_STREAM frame.
</p>

<p class="note">注記：
ある種の~communityにおいては、
!303$st は特別な~statusに帰するとみなされ，除外される。
◎
303 is excluded as certain communities ascribe special status to it.
</p>

			</li>
			<li>
%所在 ~LET
%実0応答 の!~header~list$rsから
!Location$h
に対する!~header~list値を抽出-$hdした結果
◎
Let location be the result of extracting header list values given `Location` and actualResponse’s header list.
</li>
			<li>
~IF［
%所在 は!値$hdである
］
⇒
%所在 ~SET
( 基底~URL: %実0応答 の!~url$rs )
を与える下で，
%所在 を!~url構文解析器$urlにかけた結果
◎
If location is a value, then set location to the result of parsing location with actualResponse’s url.
</li>
			<li>
%実0応答 の!所在~URL$rs ~SET %所在
◎
Set actualResponse’s location URL to location.
</li>
			<li>
<p>
%要請 の!~redirect~mode$rq に応じて：
◎
Switch on request’s redirect mode:
</p>


				<dl class="switch">
					<dt>!error^l</dt>
					<dd>
%応答 ~SET !~network~error$
◎
Set response to a network error.
</dd>

					<dt>!manual^l</dt>
					<dd>
%応答 ~SET !内的~応答$が %実0応答 にされた，!不透明redirect絞込み応答$
◎
Set response to an opaque-redirect filtered response whose internal response is actualResponse.
</dd>

					<dt>!follow^l</dt>
					<dd>
%応答 ~SET
( %~CORS~flag )
をそのまま与える下で，
( %要請, %応答 )
を用いて!~HTTP~redirect~fetch$を遂行した結果
◎
Set response to the result of performing HTTP-redirect fetch using request and response with CORS flag if set.
</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
~RET %応答
<span class="note">注記：
手続きはここで終わるが，その後も概して、
%実0応答 の!本体$rsの!~stream$bdには，~byte列が~enqueueされ続ける。
</span>
◎
Return response. Typically actualResponse’s body’s stream is still being enqueued to after returning.
</li>
</ol>


		</section>
		<section id="http-redirect-fetch">
<h3 title="HTTP-redirect fetch">4.4. ~HTTP~redirect~fetch</h3>

<p class="note">注記：
この~algoは、上述の!~HTTP~fetch$に加えて，
~HTML仕様の “~navigate” ~algoからも利用されることになる。
!HTML$r
◎
This algorithm will be used by HTML’s "navigate" algorithm in addition to HTTP fetch above. [HTML]
</p>

<p class="algo-head">
%~CORS~flag（省略時は ~OFF ）が与えられた下で，
( %要請, %応答 )
を用いて
!~HTTP~redirect~fetch@
を遂行するときは、次を走らす：
◎
To perform an HTTP-redirect fetch using request and response, with an optional CORS flag, run these steps:
</p>

<ol>
	<li>
%実0応答 ~LET ［
%応答 は!絞込み応答$でないならば %応答 ／
~ELSE_ %応答 の!内的~応答$
］
◎
Let actualResponse be response, if response is not a filtered response, and response’s internal response otherwise.
</li>
	<li>
%所在 ~LET %実0応答 の!所在~URL$rs
◎
↓</li>
	<li>
~IF［
%所在 ~EQ ~NULL
］
⇒
~RET %応答
◎
If actualResponse’s location URL is null, then return response.
</li>
	<li>
~IF［
%所在 ~EQ !失敗^i
］
⇒
~RET !~network~error$
<!-- only Gecko does this; and even that is currently more complicated -->
◎
If actualResponse’s location URL is failure, then return a network error.
</li>
	<li>
~IF［
%所在 の!~scheme$url ~NIN !~HTTP_S~scheme$
］
⇒
~RET !~network~error$
◎
If actualResponse’s location URL’s scheme is not an HTTP(S) scheme, then return a network error.
</li>
	<li>
~IF［
%要請 の!~redirect数$rq ~EQ 20
］
⇒
~RET !~network~error$
◎
If request’s redirect count is twenty, return a network error.
</li>
	<li>
%要請 の!~redirect数$rq ~INCBY 1
◎
Increase request’s redirect count by one.
</li>
	<li>
~IF［
%要請 の!~mode$rq ~EQ !cors^l
］~AND［
( %要請 の!生成元$rq, %所在 の!生成元$url )
は，!同一生成元$<em>でない</em>
］~AND［
%所在 は!資格証を含む$url
］
⇒
~RET !~network~error$
◎
If request’s mode is "cors", request’s origin is not same origin with actualResponse’s location URL’s origin, and actualResponse’s location URL includes credentials, then return a network error.
</li>
	<li>
<p>
~IF［
%~CORS~flag ~EQ ~ON
］~AND［
%所在 は!資格証を含む$url
］
⇒
~RET !~network~error$
◎
If CORS flag is set and actualResponse’s location URL includes credentials, then return a network error.
</p>

<p class="note">注記：
これは、非同一生成元~資源による同一生成元~URLへの~redirectを捕える。
◎
This catches a cross-origin resource redirecting to a same-origin URL.
</p>
	</li>
	<li>
~IF［
%実0応答 の!~status$rs ~NEQ !303$st
］~AND［
%要請 の!本体$rq ~NEQ ~NULL
］~AND［
%要請 の!本体$rqの!~source$bd ~EQ ~NULL
］
⇒
~RET !~network~error$
◎
If actualResponse’s status is not 303, request’s body is non-null, and request’s body’s source is null, then return a network error.
</li>
	<li>
~IF［
%~CORS~flag ~EQ ~ON
］~AND［
( %所在 の!生成元$url, %要請 の!現在の~url$rqの!生成元$rq )
は，!同一生成元$<em>でない</em>
］
⇒
%要請 の!生成元$rq ~SET 一意かつ!不透明な生成元$
◎
If CORS flag is set and actualResponse’s location URL’s origin is not same origin with request’s current url’s origin, then set request’s origin to a unique opaque origin.
</li>
	<li>
~IF［［
%実0応答 の!~status$rs ~IN { !301$st, !302$st }
］~AND［
%要請 の!~method$rq ~EQ !POST$hm
］］~OR［
%実0応答 の!~status$rs ~EQ !303$st
］
⇒
%要請 の!~method$rq ~SET !GET$hm；<br>
%要請 の!本体$rq ~SET ~NULL
◎
If either actualResponse’s status is 301 or 302 and request’s method is `POST`, or actualResponse’s status is 303, set request’s method to `GET` and request’s body to null.
</li>
	<li>
<p>
~IF［
%要請 の!本体$rq ~NEQ ~NULL
］
⇒
%要請 の!本体$rq ~SET %要請 の!本体$rqの!~source$bdから
!本体と内容~型を抽出-$した結果の!本体$
◎
If request’s body is non-null, then set request’s body to the first part of extracting request’s body’s source.
</p>

<p class="note">注記：
!~source$bdが ~NULL でないことは、すでに検査~済み。
また、!本体と内容~型を抽出-$する演算から例外が投出されることはない
— 前に同じ!~source$bdで~callされているので。
◎
request’s body’s source’s nullity has already been checked. The extracting operation cannot throw as it was called for the same source before.
</p>
	</li>
	<li>
%所在 を %要請 の!~url~list$rqに付加する
◎
Append actualResponse’s location URL to request’s url list.
</li>
	<li>
( %要請, %実0応答 )
を与える下で %要請 の!~referrer施策を設定する$
!REFERRER$r
◎
Invoke set request’s referrer policy on redirect on request and actualResponse. [REFERRER]
</li>
	<li>
<p>
~RET 次を与える下で，
%要請 を用いて!~main~fetch$を遂行した結果：
◎
Return the result of performing a main fetch using request with
</p>
		<ul>
			<li>
%~CORS~flag ~SET %~CORS~flag
◎
CORS flag if set and
</li>
			<li>
<p>
%再帰~flag ~SET ［
%要請 の!~redirect~mode$rq ~NEQ !manual^l ならば ~ON ／
~ELSE_ ~OFF
］
◎
recursive flag set if request’s redirect mode is not "manual".
</p>

<p class="note">注記：
!manual^l になるのは、 !~HTML^cite の “~navigate” ~algoから直接的に呼出されたときに限られる。
◎
It can only be "manual" when invoked directly from HTML’s "navigate" algorithm.
</p>
			</li>
		</ul>

<p class="note">注記：
!応答~tainting$rqが正しくなるように!~main~fetch$を呼出す必要がある。
◎
This has to invoke main fetch to get response tainting correct.
</p>
	</li>
</ol>

		</section>
		<section id="http-network-or-cache-fetch">
<h3 title="HTTP-network-or-cache fetch">4.5. ~HTTP~network-or-cache~fetch</h3>

<p class="algo-head">
( %~CORS~flag（省略時は ~OFF ）, %認証~fetch~flag（省略時は ~OFF ） )
が与えられた下で， %要請 を用いて
!~HTTP~network-or-cache~fetch@
を遂行するときは、次を走らす：
◎
To perform an HTTP-network-or-cache fetch using request with an optional CORS flag and authentication-fetch flag, run these steps:
</p>

<p class="note">注記：
%~CORS~flag, %認証~fetch~flag
は、ここでも内部状態管理に用いられる。
◎
CORS flag is still a bookkeeping detail. As is authentication-fetch flag.
</p>

<p class="note">注記：
!HTTP Range Requests^cite !HTTP-RANGE$r
にしたがって，!部分的~内容$の~cachingも~supportする実装もあるが、~browser~cacheからは広く~supportされていない。

◎
Some implementations might support caching of partial content, as per HTTP Range Requests. [HTTP-RANGE] However, this is not widely supported by browser caches.
</p>

<ol>
	<li>
%~http要請 ~LET ~NULL
◎
Let httpRequest be null.
</li>
	<li>
~IF［
%要請 の!~window$rq ~EQ !no-window^l
］~AND［
%要請 の!~redirect~mode$rq ~EQ !error^l
］
⇒
%~http要請 ~SET %要請
◎
If request’s window is "no-window" and request’s redirect mode is "error", then set httpRequest to request.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise, run these substeps:
</p>
		<ol>
			<li>
%~http要請 ~SET %要請 の!本体$rqを除いた部分の複製
◎
Set httpRequest to a copy of request except for its body.
</li>
			<li>
%本体 ~LET %要請 の!本体$rq
◎
Let body be request’s body.
</li>
			<li>
%~http要請 の!本体$rq ~SET %本体
◎
Set httpRequest’s body to body.
</li>
			<li>
~IF［
%本体 ~NEQ ~NULL
］
⇒
%要請 の!本体$rq ~SET 次のようにされた新たな!本体$
⇒
!~stream$bd ~SET ~NULL；<br />
!~source$bd ~SET %本体 の!~source$bd
◎
If body is non-null, then set request’s body to a new body whose stream is null and whose source is body’s source.
</li>
		</ol>

<p class="note">注記：
%要請 は複製される
— ここでの %~http要請 は、 %要請 に影響させずに， ~headerを追加できたり, その!本体$rqを読取れるようにする必要があるので。
すなわち、 %要請 は［
~redirect ／ 認証 ／ ~proxy認証
］にて再利用できる。
また，~memory消費を抑制するため、~cloneせずに複製する。
［
%要請 の!本体$rqの!~source$bd ~EQ ~NULL
］の事例で［
~redirect ／ 認証
］が生じた場合、~fetchは失敗することになる。
◎
request is copied as httpRequest here as we need to be able to add headers to httpRequest and read its body without affecting request. Namely, request can be reused with redirects, authentication, and proxy authentication. We copy rather than clone in order to reduce memory consumption. In case request’s body’s source is null, redirects and authentication will end up failing the fetch.
</p>
	</li>
	<li>
<p>
%資格証~flag ~LET ［
次のいずれかが満たされるならば ~ON ／
~ELSE_ ~OFF
］：
◎
Let credentials flag be set if one of
</p>

		<ul>
			<li>
%要請 の!資格証~mode$rq ~EQ !include^l
◎
request’s credentials mode is "include"
</li>
			<li>
［
%要請 の!資格証~mode$rq ~EQ !same-origin^l
］~AND［
!応答~tainting$rq ~EQ !basic^l
］
◎
request’s credentials mode is "same-origin" and request’s response tainting is "basic"
</li>
		</ul>
<p>　
◎
is true, and unset otherwise.
</p>
	</li>
	<li>
%Content-Length値 ~LET ~NULL
◎
Let contentLengthValue be null.
</li>
	<li>
~IF［
%~http要請 の!本体$rq ~EQ ~NULL
］~AND［
%~http要請 の!~method$rq ~IN
{ !POST$hm, !PUT$hm }
］
⇒
%Content-Length値 ~SET !0^bl
◎
If httpRequest’s body is null and httpRequest’s method is `POST` or `PUT`, then set contentLengthValue to `0`.
</li>
	<li>
~IF［
%~http要請 の!本体$rq ~NEQ ~NULL
］~AND［
%~http要請 の!本体$rqの!~source$bd ~NEQ ~NULL
］
⇒
%Content-Length値 ~SET ［
%~http要請 の!本体$rqの!総~byte数$bd
］を!~UTF-8符号化-$encした結果
◎
If httpRequest’s body is non-null and httpRequest’s body’s source is non-null, then set contentLengthValue to httpRequest’s body’s total bytes, UTF-8 encoded.
</li>
	<li>
~IF［
%Content-Length値 ~NEQ ~NULL
］
⇒
%~http要請 の!~header~list$rqに
( !Content-Length$h / %Content-Length値 )
を!付加-$hlする
◎
If contentLengthValue is non-null, append `Content-Length`/contentLengthValue to httpRequest’s header list.
</li>
	<li>
<p>
~IF［
%Content-Length値 ~NEQ ~NULL
~AND
%~http要請 の!~keepalive~flag$rq ~EQ ~ON
］：
◎
If contentLengthValue is non-null and httpRequest’s keepalive flag is set, then:
</p>
		<ol>
			<li>
%~inflight~keepalive~byte数 ~LET 0
◎
Let inflightKeepaliveBytes be zero.
</li>
			<li>
%~group ~LET %~http要請 の!~client$rqの!~fetch~group$
◎
Let group be httpRequest’s client’s fetch group.
</li>
			<li>
%~inflight記録~list ~LET 
%~group 内の!~fetch記録$のうち［
その!要請$fgの［
!~keepalive~flag$rq ~EQ ~ON
~AND
!~done~flag$rq ~EQ ~OFF
］なるもの
］からなる同順の~list
◎
Let inflightRecords be the set of fetch records in group whose request has its keepalive flag set and done flag unset.
</li>
			<li>
<p>
%~inflight記録~list 内の ~EACH ( %~fetch記録 ) に対し：
◎
For each fetchRecord in inflightRecords:
</p>
				<ol>
					<li>
%~inflight要請 ~LET %~fetch記録 の!要請$fg
◎
Let inflightRequest be fetchRecord’s request.
</li>
					<li>
%~inflight~keepalive~byte数 ~INCBY
%~inflight要請 の!本体$rqの!総~byte数$bd
◎
Increment inflightKeepaliveBytes by inflightRequest’s body’s total bytes.
</li>
				</ol>
			</li>
			<li>
~IF［
( %Content-Length値 ~PLUS %~inflight~keepalive~byte数 ) ~GT 64 KiB †
］
⇒
~RET !~network~error$
◎
If the sum of contentLengthValue and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
</li>
		</ol>

<p class="note">注記†：
上の~~上限 64 KiB
!KiB は kibibyte — 1024 ~byte単位^tnote
は、［
!環境~設定群~obj$の外で残存することが許容され, 本体を包含する要請
］に対し、その~sizeには上限があり，要請が不定期に残り続けないことを確保するためにある。
◎
The above limit ensures that requests that are allowed to outlive the environment settings object and contain a body, have a bounded size and are not allowed to stay alive indefinitely.
</p>
	</li>
	<li>
~IF［
%~http要請 の!~referrer$rqは!~URL$である
］
⇒
%~http要請 の!~header~list$rqに
( !Referer$h / 次で与えられる値 )
を!付加-$hlする
⇒
［
%~http要請 の!~referrer$rqを!~url直列化器$urlにかけた結果
］を!~UTF-8符号化-$encした結果
◎
If httpRequest’s referrer is a URL, then append `Referer`/httpRequest’s referrer, serialized and UTF-8 encoded, to httpRequest’s header list.
</li>
	<li>
~IF［
%~CORS~flag ~EQ ~ON
］~OR［
%~http要請 の!~method$rq ~NIN { !GET$hm, !HEAD$hm }
］
⇒
%~http要請 の!~header~list$rqに
( !Origin$h / 次で与えられる値 )
を!付加-$hlする
⇒
［
%~http要請 の!生成元$rqを!~ASCII直列化-$した結果
］を!~UTF-8符号化-$encした結果
◎
If the CORS flag is set or httpRequest’s method is neither `GET` nor `HEAD`, then append `Origin`/httpRequest’s origin, serialized and UTF-8 encoded, to httpRequest’s header list.
</li>
	<li>
~IF［
%~http要請 の!~header~list$rq内に［
!User-Agent$h を!名前に持つ~header$
］は無い
］
⇒
~UAは、
%~http要請 の!~header~list$rqに
( !User-Agent$h / !既定の User-Agent 値$ )
を!付加-$hlする~SHOULDである
◎
If httpRequest’s header list does not contain `User-Agent`, then user agents should append `User-Agent`/default `User-Agent` value to httpRequest’s header list.
</li>
			<li>
~IF ［
%~http要請 の!~cache~mode$rq ~EQ !default^l
］~AND［
%~http要請 の!~header~list$rq内に［
!If-Modified-Since$h ／
!If-None-Match$h ／
!If-Unmodified-Since$h ／
!If-Match$h ／
!If-Range$h
］を!名前に持つ~header$は在る
］
⇒
%要請 の!~cache~mode$rq ~SET !no-store^l
◎
If httpRequest’s cache mode is "default" and httpRequest’s header list contains `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set httpRequest’s cache mode to "no-store".
</li>
	<li>
~IF［
%~http要請 の!~cache~mode$rq ~EQ !no-cache^l
］~AND［
%~http要請 の!~header~list$rq内に［
!Cache-Control$h を!名前に持つ~header$
］は無い
］
⇒
%~http要請 の!~header~list$rqに
( !Cache-Control$h / !max-age=0^bl )
を!付加-$hlする
◎
If httpRequest’s cache mode is "no-cache" and httpRequest’s header list does not contain `Cache-Control`, then append `Cache-Control`/`max-age=0` to httpRequest’s header list.
</li>
	<li>
<p>
~IF［
%~http要請 の!~cache~mode$rq ~IN
{ !no-store^l, !reload^l }
］：
◎
If httpRequest’s cache mode is "no-store" or "reload", run these substeps:
</p>

		<ol>
			<li>
~IF［
%~http要請 の!~header~list$rq内に［
!Pragma$h を!名前に持つ~header$
］は無い
］
⇒
%~http要請 の!~header~list$rqに
( !Pragma$h / !no-cache^bl )
を!付加-$hlする
◎
If httpRequest’s header list does not contain `Pragma`, then append `Pragma`/`no-cache` to httpRequest’s header list.
</li>
			<li>
~IF［
%~http要請 の!~header~list$rq内に［
!Cache-Control$h を!名前に持つ~header$
］は無い
］
⇒
%~http要請 の!~header~list$rqに
( !Cache-Control$h / !no-cache^bl )
を!付加-$hlする
◎
If httpRequest’s header list does not contain `Cache-Control`, then append `Cache-Control`/`no-cache` to httpRequest’s header list.
</li>
		</ol>
	</li>
	<li>
<p>
~HTTPに則って %~http要請 の!~header~list$rqを改変する
◎
Modify httpRequest’s header list per HTTP.
</p>


<p class="note">注記：
この段は、何かもっと規範的な形にしたい。
!Accept-Encoding$h,
!Connection$h,
!DNT^h,
!Host$h
などの!~header$は、この時点で必要に応じて!付加-$hlされる。
◎
It would be great if we could make this more normative somehow. At this point headers such as `Accept-Encoding`, `Connection`, `DNT`, and `Host`, are to be appended if necessary.
</p>

<p>
この時点では、［
!Accept$h, !Accept-Charset$h, !Accept-Language$h
］は，含められては~MUST_NOT。
◎
`Accept`, `Accept-Charset`, and `Accept-Language` must not be included at this point.
</p>

<p class="note">注記：
!Accept$h, !Accept-Language$h は、すでに含められている（
!fetch()$m が利用されていない限り
— それは、既定では後者を含めない）。
また、 !Accept-Charset$h を含めても，~byte列を浪費するだけである。
詳細は、
<a href="#http-header-layer-division">~HTTP~header層の区分</a>
を見よ。
◎
`Accept` and `Accept-Language` are already included (unless fetch() is used, which does not include the latter by default), and `Accept-Charset` is a waste of bytes. See HTTP header layer division for more details.
</p>

	</li>
	<li>
<p>
~IF［
%資格証~flag ~EQ ~ON
］：
◎
If credentials flag is set, run these substeps:
</p>

		<ol>
			<li>
<p>
~IF［
~UAは %~http要請 に対する~cookieを阻止するように環境設定されていない（
!COOKIES$r の
<a href="~6265#section-7">7 節</a>
を見よ）
］：
◎
If the user agent is not configured to block cookies for httpRequest (see section 7 of [COOKIES]), then run these substeps:
</p>
				<ol>
					<li>
%~cookie ~LET
( ~UAの~cookie保管庫, %~http要請 の!現在の~url$rq )
を与える下で
"cookie-string" ~algo（
!COOKIES$r の
<a href="~6265#section-5.4">5.4 節</a>
）を走らせた結果
◎
Let cookies be the result of running the "cookie-string" algorithm (see section 5.4 of [COOKIES]) with the user agent’s cookie store and httpRequest’s current url.
</li>
					<li>
~IF［
%~cookie ~NEQ 空~文字列
］
⇒
%~http要請 の!~header~list$rqに
( !Cookie$h / %~cookie )
を!付加-$hlする
◎
If cookies is not the empty string, append `Cookie`/cookies to httpRequest’s header list.
</li>
				</ol>
			</li>
			<li>
~IF［
%~http要請 の!~header~list$rq内に［
!Authorization$h を!名前に持つ~header$
］は在る
］
⇒
~GOTO !(A)^i
◎
If httpRequest’s header list contains `Authorization`, then terminate these substeps.
</li>
			<li>
%権限付与~値 ~LET ~NULL
◎
Let authorizationValue be null.
</li>
			<li>
~IF［
%~http要請 に対する!認証~entry$は在る
］~AND［［
%~http要請 の!資格証利用URL~flag$rq ~EQ ~OFF
］~OR［
%~http要請 の!現在の~url$rqに
<a href="~URLSpec#include-credentials">資格証は含まれて</a>いない
］］
⇒
%権限付与~値 ~SET !認証~entry$
<!-- need to define the cache concept -->
◎
If there’s an authentication entry for httpRequest and either httpRequest’s use-URL-credentials flag is unset or httpRequest’s current url does not include credentials, set authorizationValue to authentication entry.
</li>
			<li>
~ELIF［
%~http要請 の!現在の~url$rqに
<a href="~URLSpec#include-credentials">資格証は含まれて</a>いる
］~AND［
%認証~fetch~flag ~EQ ~ON
］
⇒
%権限付与~値 ~SET %~http要請 の!現在の~url$rqを
<span class="XXX">!Authorization$h 値に変換</span>
した結果
◎
Otherwise, if httpRequest’s current url does include credentials and authentication-fetch flag is set, then set authorizationValue to httpRequest’s current url, converted to an `Authorization` value.
</li>
			<li>
~IF［
%権限付与~値 ~NEQ ~NULL
］
⇒
%~http要請 の!~header~list$rqに
( !Authorization$h / %権限付与~値 )
を!付加-$hlする
<!-- XXX header list set -->
◎
If authorizationValue is non-null, append `Authorization`/authorizationValue to httpRequest’s header list.
</li>
		</ol>
	</li>
	<li>
<p>
!(A)^i
!~proxy認証~entry$がある場合、それを適切に利用する
◎
If there’s a proxy-authentication entry, use it as appropriate.
</p>

<p class="note">注記：
ここでは意図的に %~http要請 の!資格証~mode$rqに依存しないようにされている。
◎
This intentionally does not depend on httpRequest’s credentials mode.
</p>
	</li>
	<li>
( %応答, %格納済み応答 ) ~LET ( ~NULL, ~NULL )
◎
Let response and storedResponse be null.
</li>
	<li>
%再検証~flag ~LET ~OFF
◎
Let the revalidatingFlag be unset.
</li>
	<li>
<p>
~IF［
%~http要請 の!~cache~mode$rq ~NIN { !no-store^l, !reload^l }
］：
◎
If httpRequest’s cache mode is neither "no-store" nor "reload", run these substeps:
</p>
		<ol>
			<li>
<p>
%格納済み応答 ~SET ~HTTP~cacheから応答を選定した結果
⇒
~IF［
該当する応答はない
］
⇒
~GOTO !(B)^i
</p>

<p>
!HTTP Caching^cite による
<a href="~7234#section-4">~cacheからの応答の構築-法</a>にしたがって，場合によっては検証が必要になる。
!HTTP-CACHING$r
</p>
◎
Set storedResponse to the result of selecting a response from the HTTP cache, possibly needing validation, as per the "Constructing Responses from Caches" chapter of HTTP Caching [HTTP-CACHING], if any.
◎
If storedResponse is null, then abort these substeps.
</li>
			<li>
~IF［
%格納済み応答 には検証が要求される（すなわち，新鮮でない）
］
⇒
%再検証~flag ~SET ~ON
◎
If storedResponse requires validation (i.e., it is not fresh), then set the revalidatingFlag.
</li>
			<li>
<p>
~IF［
%~http要請 の!~cache~mode$rq ~IN { !force-cache^l, !only-if-cached^l }
］
⇒
%応答 ~SET %格納済み応答；<br>
~GOTO !(B)^i
◎
If httpRequest’s cache mode is "force-cache" or "only-if-cached", then set response to storedResponse and abort these substeps.
</p>

<p class="note">注記：
~HTTPにより義務付けられているように、これには，依然として !Vary$h !~header$も織り込まれる。
◎
As mandated by HTTP, this still takes the `Vary` header into account.
</p>
			</li>
			<li>
<p>
~IF［
%再検証~flag ~EQ ~ON
］：
◎
If the revalidatingFlag is set, then:
</p>
				<ol>
					<li>
~IF［
%格納済み応答 の!~header~list$rs内に［
!ETag$h を!名前に持つ~header$
］は在る
］
⇒
%~http要請 の!~header~list$rqに その~headerの
( 名前 / 値 )
を!付加-$hlする
◎
If storedResponse’s header list contains `ETag`, then append `If-None-Match` with its value to httpRequest’s header list.
</li>
					<li>
~IF［
%格納済み応答 の!~header~list$rs内に［
!Last-Modified$h を!名前に持つ~header$
］は在る
］
⇒
%~http要請 の!~header~list$rqに その~headerの
( 名前 / 値 )
を!付加-$hlする
◎
If storedResponse’s header list contains `Last-Modified`, then append `If-Modified-Since` with its value to httpRequest’s header list.
</li>
			</ol>

<p class="note">注記：
!HTTP Caching^cite の
<a href="~7234#section-4.3.4">検証~要請の送信-法</a>
も見よ。
!HTTP-CACHING$r
◎
See also the "Sending a Validation Request" chapter of HTTP Caching [HTTP-CACHING].
</p>
			</li>
			<li>
~ELSE
⇒
%応答 ~SET %格納済み応答
◎
Otherwise, if the revalidatingFlag is unset, then set response to storedResponse.
</li>
		</ol>
	</li>
	<li>!(B)^i：
<p>
~IF［
%応答 ~EQ ~NULL
］：
◎
If response is null, then run these substeps:
</p>
		<ol>
			<li>
~IF［
%~http要請 の!~cache~mode$rq ~EQ !only-if-cached^l
］
⇒
~RET !~network~error$
◎
If httpRequest’s cache mode is "only-if-cached", then return a network error.
</li>
			<li>
%~forward応答 ~LET
%資格証~flag をそのまま与える下で，
%~http要請 を用いて!~HTTP~network~fetch$を発行した結果
◎
Set forwardResponse to the result of making an HTTP-network fetch using httpRequest with credentials flag if set.
</li>
			<li>
~IF［
%~http要請 の %~method は
<a href="~7231#safe.methods">安全でない</a>
］~AND［
%~forward応答 の!~status$rs ~IN { !200^st 〜 !399^st }
］
⇒
!HTTP Caching^cite による
<a href="~7234#section-4.4">無効化</a>にしたがって，~HTTP~cache内の適切な格納済み応答たちを無効化する !HTTP-CACHING$r；<br>
%格納済み応答 ~SET ~NULL
◎
If httpRequest’s method is unsafe and forwardResponse’s status is in the range 200 to 399, inclusive, invalidate appropriate stored responses in the HTTP cache, as per the "Invalidation" chapter of HTTP Caching, and set storedResponse to null. [HTTP-CACHING]
</li>
			<li>
<p>
~IF［
%再検証~flag ~EQ ~ON
］~AND［
%~forward応答 の!~status$rs ~EQ !304$st
］：
◎
If the revalidatingFlag is set and forwardResponse’s status is 304, then:
</p>
				<ol>
					<li>
<p>
!HTTP Caching^cite による
<a href="~7234#section-4.3.4">検証にあたっての，格納済み応答の新鮮化-法</a>
にしたがって，
%~forward応答 の!~header~list$rsを用いて
%格納済み応答 の!~header~list$rsを更新する
!HTTP-CACHING$r
◎
Update storedResponse’s header list using forwardResponse’s header list, as per the "Freshening Stored Responses upon Validation" chapter of HTTP Caching. [HTTP-CACHING]
</p>

<p class="note">注記：
これは、~cache内の格納済み応答も更新する。
◎
This updates the stored response in cache as well.
</li>
					<li>
%応答 ~SET %格納済み応答
◎
Set response to storedResponse.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%応答 ~EQ ~NULL
］：
◎
If response is null, then:
</p>
				<ol>
					<li>
%応答 ~SET %~forward応答
◎
Set response to forwardResponse.
</li>
					<li>
<p>
!HTTP Caching^cite による
<a href="~7234#section-3">~cache内への応答の格納-法</a>
にしたがって，~HTTP~cache内に［
%~http要請, %~forward応答 
］を格納する
!HTTP-CACHING$r
◎
Store httpRequest and forwardResponse in the HTTP cache, as per the "Storing Responses in Caches" chapter of HTTP Caching. [HTTP-CACHING]
</p>

<p class="note">注記：
%~forward応答 が!~network~error$である場合、これは実質的に，その~network~errorを~cacheする
— それは
“負の~caching（ negative caching ）”
と称されることもある。
◎
If forwardResponse is a network error, this effectively caches the network error, which is sometimes known as "negative caching".
</p>
					</li>
		 		</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%応答 の!~status$rs ~EQ !401$st !Unauthorized^tnote
］~AND［
%資格証~flag ~EQ ~ON
］~AND［
%要請 の!~window$rqは!環境~設定群~obj$である
］：
◎
If response’s status is 401, CORS flag is unset, credentials flag is set, and request’s window is an environment settings object, then run these substeps:
</p>

		<ol>
			<li class="XXX">課題：
!WWW-Authenticate$h ~header
が複数個ある場合, 与えられていない場合, その構文解析,
についてのテスト
◎
Needs testing: multiple `WWW-Authenticate` headers, missing, parsing issues.
</li>
			<li>
<p>
~IF［
%要請 の!本体$rq ~NEQ ~NULL
］：
◎
If request’s body is non-null, then run these subsubsteps:
</p>
				<ol>
					<li>
~IF［
%要請 の!本体$rqの!~source$bd ~EQ ~NULL
］
⇒
~RET !~network~error$
◎
If request’s body’s source is null, then return a network error.
</li>
					<li>
<p>
%要請 の!本体$rq ~SET %要請 の!本体$rqの!~source$bdから
!本体と内容~型を抽出-$した結果の!本体$
◎
Set request’s body to the first part of extracting request’s body’s source.
</p>

<p class="note">注記：
!本体と内容~型を抽出-$する演算から例外が投出されることはない
— 前に同じ!~source$bdで~callされているので。
◎
The extracting operation cannot throw as it was called for the same source before.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%要請 の!資格証利用URL~flag$rq ~EQ ~OFF
］~OR［
%認証~fetch~flag ~EQ ~ON
］：
◎
If request’s use-URL-credentials flag is unset or authentication-fetch flag is set, then run these subsubsteps:
</p>

				<ol>
					<li>
( %~username, %~password ) ~LET
%要請 の
!~window$rq
において，末端利用者に
( ~username, ~password )
の入力を促して得られた結果†
◎
Let username and password be the result of prompting the end user for a username and password, respectively, in request’s window.
</li>
					<li>
%~username を用いて，
%要請 の!現在の~url$rqの!~usernameを設定する$url
◎
Set the username given request’s current url and username.
</li>
					<li>
%~password を用いて，
%要請 の!現在の~url$rqの!~passwordを設定する$url
◎
Set the password given request’s current url and password.
</li>
				</ol>

<p class="trans-note">【†
入力が拒否された場合について言及されていない。
終了~事由 !利用者中止^i と伴に!終了-$？
】</p>

			</li>
			<li>
%応答 ~SET
( %認証~fetch~flag ~SET ~ON )
を与える下で，
%要請 を用いて!~HTTP~network-or-cache~fetch$を遂行した結果
◎
Set response to the result of performing an HTTP-network-or-cache fetch using request with authentication-fetch flag set.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%応答 の!~status$rs ~EQ !407$st !Proxy Authentication Required^tnote
］：
◎
If response’s status is 407, then run these substeps:
</p>

		<ol>
			<li>
~IF［
%要請 の!~window$rq ~EQ !no-window^l
］
⇒
~RET !~network~error$
◎
If request’s window is "no-window", then return a network error.
</li>
			<li class="XXX">課題：
!Proxy-Authenticate$h ~header
が複数個ある場合, 与えられていない場合, その構文解析,
についてのテスト
◎
Needs testing: multiple `Proxy-Authenticate` headers, missing, parsing issues.
</li>
			<li>
<p>
%要請 の!~window$rqにおいて、末端利用者に対し，適切に
!認証に関する手続きを^tnote
促し，その結果を!~proxy認証~entry$として保存する
!HTTP-AUTH$r
◎
Prompt the end user as appropriate in request’s window and store the result as a proxy-authentication entry. [HTTP-AUTH]
</p>

<p class="note">注記：
~proxy認証~周辺の詳細は~HTTPにて規定される。
◎
Remaining details surrounding proxy authentication are defined by HTTP.
</p>
			</li>
			<li>
%応答 ~SET 
( %~CORS~flag )
をそのまま与える下で，
%要請 を用いて!~HTTP~network-or-cache~fetch$を遂行した結果
◎
Set response to the result of performing an HTTP-network-or-cache fetch using request with CORS flag if set.
</li>
		</ol>
	</li>
	<li>
~IF［
%認証~fetch~flag ~EQ ~ON
］
⇒
［
%要請, および所与の~realm
］に対する!認証~entry$を作成する
◎
If authentication-fetch flag is set, then create an authentication entry for request and the given realm.
</li>
	<li>
~RET %応答
<span class="note">注記：
手続きはここで終わるが、その後も概して，
%応答 の!本体$rsの!~stream$bdには~enqueueされ続ける。
</span>
◎
Return response. Typically response’s body’s stream is still being enqueued to after returning.
</li>
</ol>

		</section>
		<section id="http-network-fetch">
<h3 title="HTTP-network fetch">4.6. ~HTTP~network~fetch</h3>

<p class="algo-head">
( %資格証~flag（省略時は ~OFF ） )
が与えられた下で, %要請 を用いて
!~HTTP~network~fetch@
を遂行するときは、次を走らす：
◎
To perform an HTTP-network fetch using request with an optional credentials flag, run these steps:
</p>

<ol>
	<li>
%資格証 ~LET ［
%資格証~flag ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］
◎
Let credentials be true if credentials flag is set, and false otherwise.
</li>
	<li>
<p>
%接続 ~LET %要請 の!~mode$rqに応じて，次で得られる結果：
◎
Switch on request’s mode:
</p>

		<dl>
			<dt>!websocket^l</dt>
			<dd>
( %要請 の!現在の~url$rq )
を与える下で，!~WebSocket接続を得た$結果
◎
Let connection be the result of obtaining a WebSocket connection, given request’s current url. 
</dd>

			<dt>その他</dt>
			<dd>
( %要請 の!現在の~url$rqの!生成元$url, %資格証 )
を与える下で，!接続を得た$結果
◎
Let connection be the result of obtaining a connection, given request’s current url’s origin and credentials. 
</dd>
		</dl>
	</li>
	<li>
~IF［
%接続 ~EQ !失敗^i
］
⇒
~RET !~network~error$
◎
If connection is failure, return a network error.
</li>
	<li>
~IF［
%接続 は HTTP/2 接続でない
］~AND［
%要請 の!本体$rq ~NEQ ~NULL
］~AND［
%要請 の!本体$rqの!~source$bd ~EQ ~NULL
］
⇒
%要請 の!~header~list$rqに
( !Transfer-Encoding$h / !chunked^bl )
を!付加-$hlする
◎
If connection is not an HTTP/2 connection, request’s body is non-null, and request’s body’s source is null, then append `Transfer-Encoding`/`chunked` to request’s header list.
</li>
	<li>

<p>
%応答 ~LET 次の各~条項に従う下で、
%要請 を用いて, %接続 を通じて，~HTTP要請を発行した結果：
◎
Let response be the result of making an HTTP request over connection using request with the following caveats:
</p>

		<ul>
			<li>
~HTTPによる関連する要件に従うこと。
!HTTP$r
!HTTP-SEMANTICS$r
!HTTP-COND$r
!HTTP-CACHING$r
!HTTP-AUTH$r
◎
Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]
</li>
			<li>
!~header$すべてが伝送されるか, または
!この手続きを呼出している^tnote
!~fetching$が事由 %事由 で!終了-$させられるまで，待機した上で、後者により終了された場合は［
%応答 の!終了~事由$rs ~SET %事由
］とすること。
◎
Wait until all the headers are transmitted or fetch is being terminated with reason reason. If fetch is being terminated, then set response’s termination reason to reason.
</li>
			<li>
<p>
!応答$のうち，［
!~status$rs ~IN { !100^st, !102^st 〜 !199^st }
］なるものは無視すること。
◎
Any responses whose status is in the range 100 to 199, inclusive, and is not 101, are to be ignored.
</p>

<p class="note">注記：
この種の!応答$には、最終的に， “最終” !応答$が後続する。
◎
These kind of responses are eventually followed by a "final" response.
</p>
			</li>
</ul>

<p class="note">注記：
~Fetchと~HTTPとの間の正確な重ね方は、依然として~~整理される必要がある。
したがって、ここでの %応答 は，!応答$と~HTTP応答の両者を表現する。
◎
The exact layering between Fetch and HTTP still needs to be sorted through and therefore response represents both a response and an HTTP response here. 
</p>

<p>
%要請 の!~header~list$rqが
( !Transfer-Encoding$h / !chunked^bl )
を包含する場合は
⇒
~IF［
%応答 は HTTP/1.0 以下の~versionを介して転送されている
］
⇒
~RET !~network~error$
◎
If request’s header list contains `Transfer-Encoding`/`chunked` and response is transferred via HTTP/1.0 or older, then return a network error.
</p>

<p>
~HTTP要請による結果，~TLS~client証明書~dialogになるときは：
◎
If the HTTP request results in a TLS client certificate dialog, run these substeps:
</p>

		<ol>
			<li>
~IF［
%要請 の!~window$rqは!環境~設定群~obj$である
］
⇒
%要請 の!~window$rqにて~dialogを可用にする
◎
If request’s window is an environment settings object, make the dialog available in request’s window.
</li>
			<li>
~ELSE
⇒
~RET !~network~error$
◎
Otherwise, return a network error.
</li>
		</ol>

<p>
~IF［
%応答 は~HTTPSを通じて検索取得されている
］
⇒
その!~HTTPS状態$rs ~SET ［
!deprecated^l または !modern^l
］
!TLS$r
◎
If response was retrieved over HTTPS, set its HTTPS state to either "deprecated" or "modern". [TLS]
</p>

<p class="note">注記：
ここでの正確な決定は、現時点では~UAに委ねられる。
~UAには、保安が強固な~TLS接続についてのみ成功し，他の場合は!~network~error$を返すことが、強く奨励される。
!deprecated^l 状態~値の利用は一時的とされるべきであり，最後の~~手段の類の~optionである。
◎
The exact determination here is up to user agents for the time being. User agents are strongly encouraged to only succeed HTTPS connections with strong security properties and return network errors otherwise. Using the "deprecated" state value ought to be a temporary and last resort kind of option.
</p>

<p>
%要請 に対する!本体を伝送する$
◎
Transmit body for request.
</p>

	</li>
	<li>
<p>
%策 ~LET ~obj
— ~UAは、どのような~objを選んでもよい。
◎
Let strategy be an object. The user agent may choose any object.
</p>

<p class="note">注記：
%策 は、［［
下で構築される %~stream
］の~queuing策
］を制御するために利用される。
◎
strategy is used to control the queuing strategy of stream constructed below.
</li>
	<li>
%~pull ~LET
進行中の~fetchが!休止-$しているならば，それを!再開-$する動作
◎
Let pull be an action that resumes the ongoing fetch if it is suspended.
</li>
	<li>
%~cancel ~LET
進行中の~fetchを 事由 !利用者中止^i で!終了-$させる動作
◎
Let cancel be an action that terminates the ongoing fetch with reason end-user abort.
</li>
	<li>
<p>
%~stream ~LET 
( %策, %~pull, %~cancel )
を与える下で，
!~ReadableStream~objを構築-$RSした結果
◎
Let stream be the result of constructing a ReadableStream object with strategy, pull and cancel.
</p>

<p class="note">注記：
この構築~演算からは、例外は投出されない。
◎
This construction operation will not throw an exception.
</p>
	</li>
	<li>
%応答 の!本体$rs ~SET 次のようにされた新たな!本体$
⇒
!~stream$bd ~SET %~stream 
◎
Set response’s body to a new body whose stream is stream.
</li>
	<li>
~IF［
%応答 には~payload本体~長さ %L がある
］
⇒
%応答 の!本体$rsの!総~byte数$bd ~SET %L
	<!-- XXX xref payload body -->
◎
If response has a payload body length, then set response’s body’s total bytes to that payload body length.
</li>
	<li>
<p>
~IF［
次の下位手続きを走らせた結果 ~EQ ~T
］
⇒
%~list から !Content-Encoding$h を!削除-$hlする
：
◎
Delete `Content-Encoding` from response’s header list if one of the following conditions is true:
</p>

<div>
		<ol>
			<li>
%~list ~LET %応答 の!~header~list$rs
</li>
			<li>
%符号法s ~LET
%~list から
!Content-Encoding$h
に対する!~header~list値を抽出-$hdした結果
</li>
			<li>
%型 ~LET
%~list から
!Content-Type$h
に対する!~header~list値を抽出-$hdした結果
</li>
			<li>
~IF［
%符号法s は !gzip^bl のみからなる
］~AND［
%型 ~IN {
!application/gzip^bl,
!application/x-gunzip^bl,
!application/x-gzip^bl
} ］
⇒
~RET ~T
</li>
			<li>
~IF［
%符号法s は !compress^bl のみからなる
］~AND［
%型 ~IN {
!application/compress^bl,
!application/x-compress^bl
} ］
⇒
~RET ~T
</li>
			<li>
~RET ~F
</li>
		</ol>

◎
Extracting header list values given `Content-Encoding` and response’s header list returns `gzip`, and extracting header list values given `Content-Type` and response’s header list returns `application/gzip`, `application/x-gunzip`, or `application/x-gzip`.
◎
Extracting header list values given `Content-Encoding` and response’s header list returns `compress`, and extracting header list values given `Content-Type` and response’s header list returns `application/compress` or `application/x-compress.
</div>

<p class="note">注記：
この段は、壊れた Apache 環境設定のための対処である。
<!-- ＊ -->
~HTTPにて定義されるのが理想だが。
<!-- https://wiki.whatwg.org/wiki/HTTP -->
◎
This deals with broken Apache configurations. Ideally HTTP would define this.
</p>

<p class="XXX">課題：
この quirk （過去互換）は，除去できるか？
~~詳細は Gecko
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1030660">bug 1030660</a>
に。
◎
Gecko bug 1030660 looks into whether this quirk can be removed.
</p>
	</li>
	<li>
%応答 上で!応答の~CSP~listを設定する$
!CSP$r
◎
Execute set response’s CSP list on response. [CSP]
</li>
	<li>
~IF［
%応答 は!~network~error$でない
］~AND［
%要請 の!~cache~mode$rq ~NEQ !no-store^l
］
⇒
~HTTP~cache内の［
%要請 に対する %応答
］を更新する
	<!-- XXX xref HTTP cache -->
◎
If response is not a network error and request’s cache mode is not "no-store", update response in the HTTP cache for request.
</li>
	<li>
<p>
~IF［
%資格証~flag ~EQ ~ON
］~AND［
~UAは %要請 に対する~cookieを阻止するように環境設定されていない（
!COOKIES$r の
<a href="~6265#section-7">7 節</a>
を見よ）
］
⇒
~FOR
%応答 の!~header~list$rs内の
~EACH (
!Set-Cookie$h を!名前に持つ~header$ %~header
) に対し
⇒
( %~header の!値$hd, %要請 の!現在の~url$rq )
を与える下で，
"set-cookie-string" 構文解析~algo（
!COOKIES$r の
<a href="~6265#section-5.2">5.2 節</a>
を見よ）を走らす
◎
If credentials flag is set and the user agent is not configured to block cookies for request (see section 7 of [COOKIES]), then run the "set-cookie-string" parsing algorithm (see section 5.2 of [COOKIES]) on the value of each header whose name is a byte-case-insensitive match for `Set-Cookie` in response’s header list, if any, and request’s current url.
</p>

<p class="note">注記：
これは、利用者の追跡に利用され得る機能性である。
~FINGERPRINTING
◎
This is a fingerprinting vector.
</p>
	</li>
	<li>
<p>
以下の下位手続きは、!並列的$htmlに走らす：
◎
Run these substeps in parallel:
</p>

		<ul>
			<li>
<p>
%応答 の~message本体に対し 1 個 以上の~byteが伝送される度に、それらからなる~byte列 %~byte列 に対し，次を走らす：
◎
Whenever one or more bytes are transmitted from response’s message body, let bytes be the transmitted bytes and run these subsubsteps:
</p>

				<ol>
	 <li>
［
%応答 の!本体$rsの!伝送済み~byte数$bd
］ ~INCBY ［
%~byte列 の長さ
］
◎
Increase response’s body’s transmitted bytes with bytes’ length.
</li>
					<li>
%符号法s ~LET
%応答 の!~header~list$rsから
!Content-Encoding$h
に対する!~header~list値を抽出-$hdした結果
◎
Let codings be the result of extracting header list values given `Content-Encoding` and response’s header list.
</li>
					<li>
<p>
%~byte列 ~SET
( %符号法s, %~byte列 )
を与える下で，!内容~符号法sを取扱った$結果
◎
Set bytes to the result of handling content codings given codings and bytes.
</p>

<p class="note">注記：
これは、依拠し得ていた
!Content-Length^h !~header$を依拠できないものにする。
<!-- ＊ -->
◎
This makes the `Content-Length` header unreliable to the extent that it was reliable to begin with.
</p>
					</li>
					<li>
<p >
［
%~byte列 を包含している !ArrayBuffer$I
］を包装している !Uint8Array$I ~objを，
%~stream に!~enqueue$RSする
</p>

<p>
例外が投出されたときは
⇒
進行中の~fetchは 事由 !致命的^i で!終了-$させる；<br>
%~stream は その例外で!~errorにする$RS；<br>
~RET
</p>
◎
Enqueue a Uint8Array object wrapping an ArrayBuffer containing bytes to stream. If that threw an exception, terminate the ongoing fetch with fatal, error stream with that exception and abort these subsubsteps.
</li>
					<li>
~IF［
%~stream は!もっと~dataが必要$RSではない
］~AND［
%要請 の!同期~flag$rq ~EQ ~OFF
]
⇒
進行中の~fetchを!休止-$するよう，~UAに請う
◎
If stream doesn’t need more data and request’s synchronous flag is unset, ask the user agent to suspend the ongoing fetch.
</li>
				</ol>
			</li>
			<li>
%応答 の~message本体に対する~byte列の伝送が，正常に終えられた時点で
			<!-- XXX xref message body -->
⇒
~IF［
%~stream は!読取可$RSである
］
⇒
%~stream を!~closeする$RS
◎
If at any point the bytes transmission for response’s message body is done normally and stream is readable, then close stream.
</li>
			<li>
<p>
!~fetching$が事由 %事由 で!終了-$された時点で、次を走らす：
◎
If at any point fetch is terminated with reason reason, run these subsubsteps:
</p>
				<ol>
					<li>
%応答 の!終了~事由$rs ~SET %事由
◎
Set response’s termination reason to reason.
</li>
					<li>
~IF［
%~stream は!読取可$RSである
］
⇒
!TypeError^E で %~stream を!~errorにする$RS
◎
If stream is readable, error stream with a TypeError.
</li>
				</ol>
			</li>
		</ul>

<p class="note">注記：
この時点では， %応答 の!本体$rsに関連するのかどうかはっきりしない（ %応答 は~redirectかもしれない）ため、この段は!並列的$htmlに走らされる。
◎
These are run in parallel as at this point it is unclear whether response’s body is relevant (response might be a redirect).
</p>

	</li>
	<li>
~RET %応答
<span class="note">注記：
手続きはここで終わるが、その後も概して，
%応答 の!本体$rsの!~stream$bdには~enqueueされ続ける。
</span>
◎
Return response. Typically response’s body’s stream is still being enqueued to after returning.
</li>
</ol>

		</section>
		<section id="cors-preflight-fetch">

<h3 title="CORS-preflight fetch">4.7. ~CORS予行~fetch</h3>


<p class="note">注記：
これは、実質的には，!~CORS~protocol$が解されるかどうか見るための~UA実装であり、!~CORS予行~要請$と呼ばれている。
成功裡であれば、!~CORS予行~fetch$の回数を最小化するために，!~CORS予行~cache$ccを拡充する。
◎
This is effectively the user agent implementation of the check to see if the CORS protocol is understood. The so-called CORS-preflight request. If successful it populates the CORS-preflight cache to minimize the number of these fetches.
</p>


<p class="algo-head">
要請 %要請 を用いて
!~CORS予行~fetch@
を遂行するときは、次を走らす：
◎
To perform a CORS-preflight fetch using request, run these steps:
</p>

<ol>
	<li>
<p>
%予行 ~LET 各種~fieldが次のように設定された，新たな!要請$：
</p>

<ul><li>!~method$rq ~SET !OPTIONS$hm
</li><li>!~url$rq ~SET %要請 の!現在の~url$rq
</li><li>!起動元$rq ~SET %要請 の!起動元$rq
</li><li>!種別$rq ~SET %要請 の!種別$rq
</li><li>!行先$rq ~SET %要請 の!行先$rq
</li><li>!生成元$rq ~SET %要請 の!生成元$rq
</li><li>!~referrer$rq ~SET %要請 の!~referrer$rq
</li><li>!~referrer施策$rq ~SET %要請 の!~referrer施策$rq
</li></ul>

◎
Let preflight be a new request whose method is `OPTIONS`, url is request’s current url, initiator is request’s initiator, type is request’s type, destination is request’s destination, origin is request’s origin, referrer is request’s referrer, and referrer policy is request’s referrer policy.
</li>
	<li>
%予行 の!~header~list$rqの中で
( !Access-Control-Request-Method$h / %要請 の!~method$rq )
を!設定-$hlする
◎
Set `Access-Control-Request-Method` to request’s method in preflight’s header list.
</li>
	<li>
%~header~list ~LET
%要請 の!~header~list$rqに含まれる［
!~CORS安全な要請~header$を除く，すべての!~header$
］の各!名前$hdを［
重複は排除し, 字句順に整列し, !~byte小文字~化$した結果
］からなる~list
◎
Let headers be the names of request’s header list’s headers, excluding CORS-safelisted request-headers and duplicates, sorted lexicographically, and byte-lowercased.
</li>
	<li>
<p>
~IF［
%~header~list は!空$でない
］：
◎
If headers is not empty, then:
</p>
		<ol>
			<li>
%値 ~LET %~header~list 内の各項を順に， !,^bl で区切って連結した結果
◎
Let value be the items in headers separated from each other by `,`.
</li>
			<li>
%予行 の!~header~list$rqの中で
( !Access-Control-Request-Headers$h / %値 )
を!設定-$hlする
◎
Set `Access-Control-Request-Headers` to value in preflight’s header list.
</li>
		</ol>
<p class="note">注記：
ここで!結合-$hlを利用しないのは意図的である。
これは［
!2C^X !20^X
］並びによる仕方で実装されてはいないので
— 功罪はあれど。
◎
This intentionally does not use combine, as 0x20 following 0x2C is not the way this was implemented, for better or worse
</p>
	</li>
	<li>
%応答 ~LET
%予行 を用いて!~HTTP~network-or-cache~fetch$を遂行した結果
◎
Let response be the result of performing an HTTP-network-or-cache fetch using preflight.
</li>
	<li>
<p>
~IF ［
( %要請, %応答 )
に対する!~CORS検査$の結果 ~EQ !成功^i
］~AND［
%応答 の!~status$rs は!~ok~status$である
］：

<!-- CORS said 200 here but nobody implemented that:
       https://lists.w3.org/Archives/Public/public-webappsec/2013Feb/0078.html -->
◎
If a CORS check for request and response returns success and response’s status is an ok status, run these substeps:
</p>

<p class="note">注記：
正しい!資格証~mode$rqの利用を確保するため、
!~CORS検査$は， %予行 ではなく %要請 に対して行う。
◎
The CORS check is done on request rather than preflight to ensure the correct credentials mode is used.
</p>

		<ol>
			<li>
%~methods ~LET
%応答 の!~header~list$rsから
!Access-Control-Allow-Methods$h
に対する!~header~list値を抽出-$hdした結果
◎
Let methods be the result of extracting header list values given `Access-Control-Allow-Methods` and response’s header list.
◎
If methods is `*`, then set methods to a new list containing `*`.
<!-- 不要 -->
</li>
			<li>
%~header名s ~LET
%応答 の!~header~list$rsから
!Access-Control-Allow-Headers$h
に対する!~header~list値を抽出-$hdした結果
◎
Let headerNames be the result of extracting header list values given `Access-Control-Allow-Headers` and response’s header list.
</li>
			<li>
~IF［
%~methods ~EQ !失敗^i
］~OR［
%~header名s ~EQ !失敗^i
］
⇒
~RET !~network~error$
◎
If either methods or headerNames is failure, return a network error.
</li>
			<li>
~IF［［
!*^bl ~IN %~methods
］~OR［
!*^bl ~IN %~header名s
］］~AND［
%要請 の!資格証~mode$rq ~EQ !include^l
］
⇒
~RET !~network~error$
◎
If methods or headerNames contains `*`, and request’s credentials mode is "include", then return a network error.
</li>
			<li>
<p>
~IF［
%~methods ~EQ ~NULL
］~AND［
!~CORS予行~利用~flag$rq ~EQ ~ON
］
⇒
%~methods ~SET %要請 の!~method$rqのみからなる新たな~list
◎
If methods is null and request’s use-CORS-preflight flag is set, then set methods to a new list containing request’s method.
</p>

<p class="note">注記：
これにより、単に［
%要請 の!~CORS予行~利用~flag$rq ~EQ ~ON
］であることに因り生じる!~CORS予行~fetch$も，<a href="#concept-cache">~cache</a>される。
◎
This ensures that a CORS-preflight fetch that happened due to request’s use-CORS-preflight flag being set is cached.
</p>
			</li>
			<li>
~IF［
%要請 の!~method$rq ~NIN %~methods
］~AND［
%要請 の!~method$rqは!~CORS安全な~method$でない
］~AND［
!*^bl ~NIN %~methods
］
⇒
~RET !~network~error$
◎
If request’s method is not in methods, is not a CORS-safelisted method, and methods does not contain `*`, then return a network error.
</li>
			<li>
~IF［
%要請 の!~header~list$rq内に［
%~header名s 内のある名前を!名前に持つ~header$でない, かつ
!~CORS非~wildcard要請~header名$を!名前に持つ~header$
］は在る
］
⇒
~RET !~network~error$
◎
If one of request’s header list’s names is a CORS non-wildcard request-header name and is not a byte-case-insensitive match for an item in headerNames, then return a network error.
</li>
			<li>
~IF［
%要請 の!~header~list$rq内に［
%~header名s 内のある名前を!名前に持つ~header$でない, かつ
!~CORS安全な要請~header$
］は在る
］~AND［
!*^bl ~NIN %~header名s
］
⇒
~RET !~network~error$
◎
If one of request’s header list' names is not a byte-case-insensitive match for an item in headerNames, its corresponding header is not a CORS-safelisted request-header, and headerNames does not contain `*`, then return a network error.
</li>
			<li>
%寿命 ~LET
%応答 の!~header~list$rsから
!Access-Control-Max-Age$h
に対する!~header~list値を抽出-$hdした結果
◎
Let max-age be the result of extracting header list values given `Access-Control-Max-Age` and response’s header list.
</li>
			<li>
~IF［
%寿命 ~IN { !失敗^i, ~NULL }
］
⇒
%寿命 ~SET 0
◎
If max-age is failure or null, then set max-age to zero.
</li>
			<li>
~IF［
%寿命 ~LT 環境により課される!寿命$ccの上限
］
⇒
%寿命 ~SET その上限
◎
If max-age is greater than an imposed limit on max-age, then set max-age to the imposed limit.
</li>
			<li>
~IF［
~UAは!~CORS予行~cache$ccを提供していない
］
⇒
~RET %応答
◎
If the user agent does not provide for a cache, then return response.
</li>
			<li>
<p>
~FOR
%~methods 内の ~EACH ( %~method ) に対し：
◎
↓</p>
				<ol>
					<li>
~IF［
%~method は %要請 の下で!~cacheに合致$ccmする
］
⇒
合致した~entryの!寿命$cc ~SET %寿命
◎
For each method in methods for which there is a method cache match using request, set matching entry’s max-age to max-age.
</li>
					<li>
~ELSE
⇒
次を与える下で，!新たな~cache~entryを作成-$する
⇒
( %要請, %寿命, %~method, ~NULL )
◎
For each method in methods for which there is no method cache match using request, create a new entry with request, max-age, method, and null.
</li>
				</ol>
			</li>
			<li>
<p>
~FOR
%~header名s 内の ~EACH ( %~header名 ) に対し：
◎
↓</p>
				<ol>
					<li>
~IF［
%~header名 は %要請 の下で!~cacheに合致$cchする
］
⇒
合致した~entryの!寿命$cc ~SET %寿命
◎
For each headerName in headerNames for which there is a header-name cache match using request, set matching entry’s max-age to max-age.
</li>
					<li>
<p>
~ELSE
⇒
次を与える下で，!新たな~cache~entryを作成-$する
⇒
( %要請, %寿命, ~NULL, %~header名 )
◎
For each headerName in headerNames for which there is no header-name cache match using request, create a new entry with request, max-age, null, and headerName.
</li>
					<li>
~RET %応答
◎
Return response.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
~RET !~network~error$
◎
Otherwise, return a network error.
</li>
</ol>

		</section>
		<section id="cors-preflight-cache">

<h3 title="CORS-preflight cache">4.8. ~CORS予行~cache</h3>


<p>
!~CORS予行~cache@cc
とは、各~entryが次の~fieldを有する，~entryたちからなる集合である：
◎
A CORS-preflight cache consists of a collection of entries where each entry has these fields:
</p>

<div>

<dl class="def-list">
	<dt>!生成元@cc</dt>
	<dd>
!生成元$html。
</dd>

	<dt>!~url@cc</dt>
	<dd>
!~URL$。
</dd>

	<dt>!寿命@cc</dt>
	<dd>
秒数。
</dd>

	<dt>!資格証の有無@cc</dt>
	<dd>
真偽値。
</dd>

	<dt>!~method@cc</dt>
	<dd>
次のいずれか
⇒
~NULL ／ !*^bl ／ !~method$
</dd>

	<dt>!~header名@cc</dt>
	<dd>
次のいずれか
⇒
~NULL ／ !*^bl ／ !~header$の!名前$hd
</dd>
</dl>


◎
origin (an origin)
◎
url (a URL)
◎
max-age (a number of seconds)
◎
credentials (a boolean)
◎
method (null, `*`, or a method)
◎
header name (null, `*`, or a header name)
</div>

<p class="trans-note">【
!~method$ccと!~header名$ccは，互いに排他的な~fieldであり、一方は必ず ~NULL, 他方は必ず非 ~NULL にされる。
】</p>


<p>
各~entryは、!~CORS予行~cache$ccに~~追加された時点から，その!寿命$cc ~fieldに指定された秒数が経過するまでに、除去され~MUST。
経過する前に除去されてもよい。
◎
Entries must be removed after the seconds specified in the max-age field have passed since storing the entry. Entries may be removed before that moment arrives.
</p>

<p class="algo-head">
!新たな~cache~entryを作成-@
するときは、所与の
( %要請, %寿命, %~method, %~header名 )
に対し，次のように設定された~entryを!~CORS予行~cache$cc内に作成する：
◎
To create a new entry in the CORS-preflight cache, given request, max-age, method, and headerName, do so as follows:
</p>

<div>
<ul><li>!生成元$cc ~SET %要請 の!生成元$rq
</li><li>!~url$cc ~SET %要請 の!現在の~url$rq
</li><li>!寿命$cc ~SET %寿命
</li><li>!資格証の有無$cc ~SET %要請 の!資格証~mode$rq ~EQ !include^l ならば !有り^i ／
~ELSE_ !無し^i
</li><li>!~method$cc ~SET %~method
</li><li>!~header名$cc ~SET %~header名
</li></ul>

<div lang="en" style="white-space:pre-wrap;">
origin
    request’s origin 
url
    request’s current url 
max-age
    max-age 
credentials
    True if request’s credentials mode is "include", and false otherwise 
method
    method 
header name
    headerName 
</div>
</div>



<p class="algo-head">
所与の %要請 を用いて
!予行~cacheの~entryを消去する@cc
ときは
⇒
!~CORS予行~cache$ccから，次を満たす~entryたちを除去する
⇒
［
~entryの!生成元$cc ~EQ %要請 の!生成元$rq
］~AND［
~entryの!~url$cc ~EQ %要請 の!現在の~url$rq
］
◎
To clear cache entries, given a request, remove any entries in the CORS-preflight cache whose origin is request’s origin and whose url is request’s current url.
</p>


<div>
<p>
次のすべてを満たす~entryは、 %要請 に
!~cache合致@cc
するとされる：
</p>

<ul><li>その!生成元$cc ~EQ %要請 の!生成元$rq
</li><li>その!~url$cc ~EQ %要請 の!現在の~url$rq
</li><li>次のいずれかを満たす：

	<ul><li>その!資格証の有無$cc ~EQ !有り^i
	</li><li>［
その!資格証の有無$cc ~EQ !無し^i
］~AND［
%要請 の!資格証~mode$rq ~NEQ !include^l
］
	</li></ul>
</li></ul>

◎
There is a cache match for request if origin is request’s origin, url is request’s current url, and one of
◎
credentials is true
◎
credentials is false and request’s credentials mode is not "include"
◎
is true.
</div>


<div>

<p>
~method %~method は、次を満たす~entryが!~CORS予行~cache$ccに在るとき，
%要請 の下で
!~cacheに合致@ccm
するとされる（このときの~entryを，“合致した~entry” と呼ぶ）：
</p>

<ul>
	<li>
~entryは %要請 に!~cache合致$ccする, かつ
</li>
	<li>
~entryの!~method$cc ~IN { %~method, !*^bl }
</li>
</ul>
◎
There is a method cache match for method using request when there is an entry in CORS-preflight cache for which there is a cache match for request and its method is method or `*`.
</div>


<div class="p">
<p>
~header名 %~header名 は、次を満たす~entryが!~CORS予行~cache$ccに在るとき，
%要請 の下で
!~cacheに合致@cch
するとされる（このときの~entryを，“合致した~entry” と呼ぶ）：
</p>

<ul><li>~entryは %要請 に!~cache合致$ccする, かつ
</li><li>
<p>
次のいずれかが満たされる：
</p>

	<ul><li>~entryの!~header名$ccは %~header名 に!~byte大小無視$で合致する
	</li><li>［
~entryの!~header名$cc ~EQ !*^bl
］~AND［
%~header名 は!~CORS非~wildcard要請~header名$でない
］
	</li></ul>
</li></ul>

◎
There is a header-name cache match for headerName using request when there is an entry in CORS-preflight cache for which there is a cache match for request and one of
◎
header name is a byte-case-insensitive match for headerName
◎
header name is `*` and headerName is not a CORS non-wildcard request-header name 
◎
is true.
</div>



		</section>
		<section id="cors-check">

<h3 title="CORS check">4.9. ~CORS検査</h3>

<p class="algo-head">
( %要請, %応答 )
に対し
!~CORS検査@
を遂行するときは、次を走らす：
◎
To perform a CORS check for a request and response, run these steps:
</p>

<ol>
	<li>
%生成元 ~LET
%応答 の!~header~list$rsから
!Access-Control-Allow-Origin$h
に対する!~header~list値を抽出-$hdした結果
◎
Let origin be the result of extracting header list values given `Access-Control-Allow-Origin` and response’s header list.
</li>
	<li>
<p>
~IF［
%生成元 ~IN { ~NULL, !失敗^i }
］
⇒
~RET !失敗^i
◎
If origin is null or failure, return failure.
</p>

<p class="note">注記：
~NULL は !null^bl でないことに注意。
◎
Null is not `null`.
</p>
	</li>
	<li>
~IF［
%要請 の!資格証~mode$rq ~NEQ !include^l
］~AND［
%生成元 ~EQ !*^bl
］
⇒
~RET !成功^i
◎
If request’s credentials mode is not "include" and origin is `*`, return success.
</li>
	<li>
~IF ［［
%要請 の!生成元$rqを!~ASCII直列化-$した結果
］を!~UTF-8符号化-$encした結果
］ ~NEQ %生成元
⇒
~RET !失敗^i
◎
If request’s origin, serialized and UTF-8 encoded, is not origin, return failure.
</li>
	<li>
~IF［
%要請 の!資格証~mode$rq ~NEQ !include^l
］
⇒
~RET !成功^i
◎
If request’s credentials mode is not "include", return success.
</li>
	<li>
%資格証 ~LET
%応答 の!~header~list$rsから
!Access-Control-Allow-Credentials$h
に対する!~header~list値を抽出-$hdした結果
◎
Let credentials be the result of extracting header list values given `Access-Control-Allow-Credentials` and response’s header list.
</li>
	<li>
<p>
~IF［
%資格証 ~EQ !true^bl
］
⇒
~RET !成功^i
◎
If credentials is `true`, return success.
</p>

<p class="XXX">課題：
%生成元 が ~NULL でないことを，この段で検査することも示唆されている
— ~NULL ならば，［
資格証や !*^bl を許容すること
］に等しくなり、それも禁止されるので。
◎
It has been suggested to check for origin not being `null` here as that would be equal to allowing credentials and `*` which is also forbidden.
</p>
	</li>
	<li>
~RET !失敗^i
◎
Return failure.
</li>
</ol>


		</section>
	</section>
	<section id="fetch-api">

<h2 title="Fetch API">5. ~fetch~API</h2>

<p>
!fetch()$m ~methは、資源を!~fetch$するための，比較的 低~levelの~APIである。
!XMLHttpRequest$I より少しばかり基盤的部分を対象にする
— 現時点では、いつ要請の進捗（応答の進捗ではなく）が来たかを報告する機能を欠いているが。
◎
The fetch() method is relatively low-level API for fetching resources. It covers slightly more ground than XMLHttpRequest, although it is currently lacking when it comes to request progression (not response progression).
</p>

<div class="example" id="fetch-blob-example">
<p>
!fetch()$m ~methは、ごく率直に，資源を!~fetch$した上で その内容を !Blob$I として抽出する：
◎
The fetch() method makes it quite straightforward to fetch a resource and extract its contents as a Blob:
</p>

<pre>
fetch(!/music/pk/altes-kamuffel.flac^l)
  .then(%res =&gt; %res.blob()).then(%playBlob);
</pre>

<p class="trans-note">【
記法
"<code class="literal">%args =&gt; %code</code>"
は、 %args を入力に %code を走らす無名~関数（
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/arrow_functions">arrow function</a>
）。
】</p>

<p>
特定0の応答~headerの~logをとりたいだけなら：
◎
If you just care to log a particular response header:
</p>

<pre>
fetch(!/^l, {method:!HEAD^l})
  .then(%res =&gt; log(%res.headers.get(!strict-transport-security^l)));
</pre>

<p>
特定0の応答~headerを検査して，非同一生成元の資源に対する応答を処理したいなら：
◎
If you want to check a particular response header and then process the response of a cross-origin resources:
</p>

<pre>
fetch(!https://pk.example/berlin-calling.json^l, {mode:!cors^l})
  .then(%res =&gt; {
    if(%res.headers.get(!content-type^l) && (
       %res.headers.get(!content-type^l)
         .toLowerCase()
         .indexOf(!application/json^l) &gt;= 0
      )
    ) {
      return %res.json();
    } else {
      throw new TypeError();
    }
  }).then(processJSON);
</pre>

<p>
URL ~query~parameterを~~利用したいなら：
◎
If you want to work with URL query parameters:
</p>

<pre>
var %url = new URL(!https://geo.example.org/api^l),
    %params = {lat:35.696233, long:139.570431};
Object.keys(%params).forEach(
    %key =&gt; %url.searchParams.append(%key, params[%key])
);
fetch(%url).then(/* … */);
</pre>


<p>
本体~dataを漸進的に受信したいなら：
◎
If you want to receive the body data progressively:
</p>

<pre>
function consume(%reader) {
  var %total = 0
  return pump();

  function pump() {
    return %reader.read().then(({%done, %value}) =&gt; {
      if (%done) {
        return;
      }
      %total += %value.byteLength;
      log(
`受信された~byte数 ${%value.byteLength} （総~byte数 ${%total} ）`
      );
      return pump();
    })
  }
}

fetch(!/music/pk/altes-kamuffel.flac^l)
  .then(%res =&gt; consume(%res.body.getReader()))
  .then( () =&gt; log(
    !~memory内に全部~~貯めこむことなく，本体~全体を消費できました！^l
  ))
  .catch(%e =&gt; log(!何かまずいことが起きました： ^l + %e))
</pre>
<!-- 
received ${value.byteLength} bytes (${total} bytes in total)
"consumed the entire body without keeping the whole thing in memory!"
"something went wrong: "
-->

</div>


		<section id="headers-class">
<h3 title="Headers class">5.1. !Headers^I ~class</h3>

⇒！
typedef (
   sequence&lt;sequence&lt;!ByteString$I&gt;&gt;
   or record&lt;!ByteString$I, !ByteString$I&gt;
) !HeadersInit@I;

[<a href="#dom-headers">Constructor</a>(optional !HeadersInit$I %init),
 Exposed=(Window,Worker)]
interface !Headers@I {
  void !append$m(!ByteString$I %name, !ByteString$I %value);
  void !delete$m(!ByteString$I %name);
  !ByteString$I? !get$m(!ByteString$I %name);
  boolean !has$m(!ByteString$I %name);
  void !set$m(!ByteString$I %name, !ByteString$I %value);
  !iterable$m&lt;!ByteString$I, !ByteString$I&gt;;
};
◎



<div class="example" id="example-headers-class">
<p>
!Headers$I ~objを構築するのは、元になる［
~header~hash~map ／ 有順序~pair配列
］を表現する~JS~objを渡すだけでできる：
◎
Constructing a Headers object from scratch is fairly straightforward. You could pass in a JavaScript object representing a header hash map, or an array of ordered pairs:
</p>

<pre>
/* <span class="comment">
次の~codeは：
</span> */
var %meta = { "Content-Type": "text/xml", "Breaking-Bad": "&lt;3" }
new Headers(%meta)

/* <span class="comment">
次と等価になる：
◎
The above is equivalent to
</span> */
var %meta = [
[ "Content-Type", "text/xml" ],
[ "Breaking-Bad", "&lt;3" ]
]
new Headers(%meta)
</pre>

</div>

<p>
!Headers$I ~objには，次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>!~header~list@Hl（初期~時は空）</dt>
	<dd>
!~header~list$。
◎
A Headers object has an associated header list (a header list), which is initially empty. This can be a pointer to the header list of something else, e.g., of a request as demonstrated by Request objects.
</dd>
	<dd class="note">注記：
これは、何か他の~objの!~header~list$を指すこともある。
例えば !Request$I ~objの!要請$のそれを指すなど。
◎
↑</dd>

	<dt>!~guard@Hl（初期~時は !none^l ）</dt>
	<dd>
次のいずれか
⇒
!immutable^l ／
!request^l ／
!request-no-cors^l ／
!response^l ／
!none^l
◎
A Headers object also has an associated guard, which is "immutable", "request", "request-no-cors", "response" or "none".
</dd>
	<dd class="note">注記：
!immutable^l は~service-workerのために在る。
!SW$r
◎
"immutable" exists for service workers. [SW]
</dd>

</dl>


<p>
!新たな~Headers@( %G, %~list )
という表記は、次のようにされた，新たな !Headers$I ~objを表すとする：
</p>

<ol>
	<li>
!~guard$Hl ~SET %G
</li>
	<li>
%~list が省略されていない場合は、前項に加えて
⇒
!~header~list$Hl ~SET %~list
</li>
</ol>

<p class="trans-note">【
この表記は、翻訳として表現を明確化するために，この訳に導入したものである。
】</p>


<p class="algo-head">
所与の
( %name / %value )
組を，所与の !~guard$Hl %~guard で
!検査@
するときは、次を走らす：
</p>

<p class="trans-note">【
この~algoは、共通の記述を集約するため，この訳に導入したものである。
】</p>


<ol>
	<li>
~IF［
%name は!名前$hdでない
］~OR［
%value は!値$hdでない
］
⇒
~THROW !TypeError^E
</li>
	<li>
<p>
%~guard に応じて：
</p>

		<dl class="switch">
			<dt>!immutable^l</dt>
			<dd>
~THROW !TypeError^E
</dd>

			<dt>!request^l</dt>
			<dd>
~IF［
%name は!禁止~header名$である
］
⇒
~RET !不合格^i
</dd>

			<dt>!request-no-cors^l</dt>
			<dd>
~IF［
( %name / %value )
は!~CORS安全な要請~header$でない
］
⇒
~RET !不合格^i
</dd>

			<dt>!response^l</dt>
			<dd>
~IF［
%name は!禁止~応答~header名$である
］
⇒
~RET !不合格^i
</dd>
		</dl>
	</li>
	<li>
~RET !合格^i
</li>
</ol>
<!-- 
If name is not a name( or value is not a value)?, then throw a TypeError.
If guard is "immutable", then throw a TypeError.
Otherwise, if guard is request and name is a forbidden header name, return.
Otherwise, if guard is "request-no-cors" and name/(value|`invalid`) is not a CORS-safelisted request-header, return.
Otherwise, if guard is "response" and name is a forbidden response-header name, return.
-->


<p class="algo-head">
!Headers$I ~obj %headers に
( !名前$hd %name / !値$hd %value )
の組を
!付加-@Hl
するときは、次を走らす：
◎
To append a name/value (name/value) pair to a Headers object (headers), run these steps:
</p>

<ol>
	<li>
%value ~SET %value を!正規化-$hdした結果
◎
Normalize value.
</li>
	<li>
~IF［
( %name / %value )
を， %headers の!~guard$Hlで!検査$した結果 ~EQ !合格^i
］
⇒
%headers の!~header~list$Hlに
( %name / %value )
を!付加-$hlする
◎
If name is not a name or value is not a value, then throw a TypeError.
◎
If guard is "immutable", then throw a TypeError.
◎
Otherwise, if guard is "request" and name is a forbidden header name, return.
◎
Otherwise, if guard is "request-no-cors" and name/value is not a CORS-safelisted request-header, return.
◎
Otherwise, if guard is "response" and name is a forbidden response-header name, return.
◎
Append name/value to header list.
</li>
</ol>

<p class="algo-head">
!Headers$I ~obj %headers を，所与の~obj %~obj で
!埋める@Hl
ときは、次を走らす：
◎
To fill a Headers object (headers) with a given object (object), run these steps:
</p>

<ol>
	<li>
<p>
~IF［
%~obj は~IDL!連列~型$idlである
］：
◎
↓</p>
		<ol>
			<li>
<p>
~FOR
%~obj 内の ~EACH ( %~header ) に対し：
◎
If object is a sequence, then for each header in object, run these substeps:
</p>
				<ol>
					<li>
~IF［
%~header 内の項数 ~NEQ 2
］
⇒
~THROW !TypeError^E
◎
If header does not contain exactly two items, then throw a TypeError.
</li>
					<li>
%headers に
( %~header の最初の項 / %~header の２番目の項 )
を!付加-$Hlする（例外投出あり）
◎
Append header’s first item/header’s second item to headers. Rethrow any exception.
</li>
				</ol>
			</li>
		</ol>
	<li>
~ELSE（ %~obj は~IDL!~record型$idlである ）
⇒
%~obj 内の ~EACH ( %~key → %値 ) に対し
⇒
%headers に
( %~key / %値 )
を!付加-$Hlする（例外投出あり）
◎
Otherwise, object is a record, then for each key → value in object, append key/value to headers. Rethrow any exception.
</li>
</ol>

<dl class="idl-def">
	<dt>!Headers(init)@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
The Headers(init) constructor, when invoked, must run these steps:
</p>

		<ol>
			<li>
%headers ~LET !新たな~Headers$( !none^l )
◎
Let headers be a new Headers object whose guard is "none".
</li>
					<li>
~IF［
%init は与えられている
］
⇒
%headers を %init で!埋める$Hl（例外投出あり）
◎
If init is given, fill headers with init. Rethrow any exception.
</li>
					<li>
~RET %headers
◎
Return headers.
</li>
		</ol>
	</dd>

	<dt>!append(name, value)@m</dt>
	<dd>
被呼出時には、此れに
( %name / %value )
を!付加-$Hlし~MUST
（例外投出あり）
◎
The append(name, value) method, when invoked, must append name/value to context object and rethrow any exception.
</dd>

	<dt>!delete(name)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The delete(name) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
<p>
~IF［
( %name / !invalid^bl )
を，此れの!~guard$Hlで!検査$した結果 ~EQ !合格^i
］
⇒
此れの!~header~list$Hlから %name を!削除-$hlする
</p>

<p class="note">注記：
!invalid^bl を利用するのは、 !delete()^m の引数に %value が渡されないためである。
</p>

◎
If name is not a name, then throw a TypeError.
◎
If guard is "immutable", then throw a TypeError.
◎
Otherwise, if guard is "request" and name is a forbidden header name, return.
◎
Otherwise, if guard is "request-no-cors" and name/`invalid` is not a CORS-safelisted request-header, then return.
◎
`invalid` is used because delete() is not passed a value as argument. 
◎
Otherwise, if guard is "response" and name is a forbidden response-header name, return.
◎
Delete name from header list.
</li>
		</ol>
	</dd>

	<dt>!get(name)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The get(name) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
%name は!名前$hdでない
］
⇒
~THROW !TypeError^E
◎
If name is not a name, then throw a TypeError.
</li>
			<li>
~IF［
此れの!~header~list$Hl内に［
%name を!名前に持つ~header$
］は無い
］
⇒
~RET ~NULL
◎
If header list does not contain name, then return null.
</li>
			<li>
~RET 此れの!~header~list$Hl 内の %name に対する!結合済みの値$hd
◎
Return the combined value given name and header list.
↑</li>
		</ol>
	</dd>

	<dt>!has(name)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The has(name) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
%name は!名前$hdでない
］
⇒
~THROW !TypeError^E
◎
If name is not a name, then throw a TypeError.
</li>
			<li>
~RET
此れの!~header~list$Hl内に［
%name を!名前に持つ~header$
］は［
在るならば ~T ／
無いならば ~F
］
◎
Return true if header list contains name, and false otherwise.
</li>
		</ol>
	</dd>

	<dt>!set(name, value)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The set(name, value) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%value ~SET %value を!正規化-$hdした結果
◎
Normalize value.
</li>
			<li>
~IF［
( %name / %value )
を，此れの!~guard$Hlで!検査$した結果 ~EQ !合格^i
］
⇒
此れの!~header~list$Hlの中で
( %name / %value )
を!設定-$hlする
◎
If name is not a name or value is not a value, then throw a TypeError.
◎
If guard is "immutable", then throw a TypeError.
◎
Otherwise, if guard is "request" and name is a forbidden header name, return.
◎
Otherwise, if guard is "request-no-cors" and name/value is not a CORS-safelisted request-header, return.
◎
Otherwise, if guard is "response" and name is a forbidden response-header name, return.
◎
Set name/value in header list.
</li>
		</ol>
	</dd>

	<dt>!iterable@m</dt>
	<dd>
!反復される値~pair$idlは、!~header~list$Hlを!整列して結合-$hlした結果で与えられる。
◎
The value pairs to iterate over are the return value of running sort and combine with the header list.
</dd>
</dl>

		</section>
		<section id="body-mixin">
<h3 title="Body mixin">5.2. !Body^I ~mixin</h3>

⇒！
typedef (
  !Blob$I or
  !BufferSource$I or
  !FormData$I or
  !URLSearchParams$I or
  !ReadableStream$I or
  !USVString$I
) !BodyInit@I;
◎


<p class="algo-head">
%~obj から
!本体と内容~型を抽出-@
するときは、次を走らす
— この手続きは
%~keepalive~flag （省略時は ~OFF ）
も入力にとり，
( !本体$, !Content-Type$h !値$hd )
の組を返す：
◎
To extract a body and a `Content-Type` value from object, with an optional keepalive flag, run these steps:
</p>

<ol>
	<li>
%~stream ~LET
!~ReadableStream~objを構築-$RSした結果
◎
Let stream be the result of constructing a ReadableStream object.
</li>
	<li>
%内容~型 ~LET ~NULL
◎
Let Content-Type be null.
</li>
	<li>
%動作 ~LET ~NULL
◎
Let action be null.
</li>
	<li>
%~source ~LET ~NULL
◎
Let source be null.
</li>
	<li>
<p>
%~obj の型に応じて：
◎
Switch on object’s type:
</p>
		<dl class="switch">
			<dt>!Blob$I</dt>
			<dd>
				<ol>
					<li>
%動作 ~SET %~obj を読取る動作
◎
Set action to an action that reads object.
</li>
					<li>
~IF［
%~obj の !type$mF 属性 ~NEQ 空~byte列
］
⇒
%内容~型 ~SET その属性~値
◎
If object’s type attribute is not the empty byte sequence, set Content-Type to its value.
</li>
					<li>
%~source ~SET %~obj
◎
Set source to object.
</li>
				</ol>
			</dd>

			<dt>!BufferSource$I</dt>
			<dd>
				<ol>
					<li>
%~stream に［［［
%~obj に保持されている~byte列の複製
］を包含している !ArrayBuffer$I
］を包装している !Uint8Array$I ~obj
］を!~enqueue$RSする
</li>
					<li>
%~stream を!~closeする$RS
</li>
					<li>
%~source ~SET %~obj
</li>
				</ol>

<p>
例外が投出されたときは
⇒
その例外で %~stream を!~errorにする$RS
</p>

◎
Enqueue a Uint8Array object wrapping an ArrayBuffer containing a copy of the bytes held by object to stream and close stream. If that threw an exception, error stream with that exception.
◎
Set source to object.
</dd>

			<dt>!FormData$I</dt>
			<dd>
				<ol>
					<li>
%動作 ~SET 次を走らす動作
⇒
［
%符号化方式 ~SET !~UTF-8$enc
］を与える下で， %~obj を!~form_data として符号化-$htmlする
<!-- need to provide explicit character encoding because otherwise the encoding of the document is used -->
◎
Set action to an action that runs the multipart/form-data encoding algorithm, with object as form data set and with UTF-8 as the explicit character encoding.
</li>
					<li>
<p>
%内容~型 ~SET 次の連結
</p>

<ol ><li>!multipart/form-data; boundary=^bl
</li><li>%動作 により生成されることになる !~form_data 境界~文字列$html
</li></ol>

◎
Set Content-Type to `multipart/form-data; boundary=`, followed by the multipart/form-data boundary string generated by the multipart/form-data encoding algorithm.
</li>
					<li>
%~source ~SET %~obj
◎
Set source to object.
</li>
				</ol>
			</dd>

			<dt>!URLSearchParams$I</dt>
			<dd>
				<ol>
					<li>
%動作 ~SET 次を走らす動作
⇒
%~obj の!名値~組~list$urlを，!~form_urlencoded 直列化器$urlにかける
<!-- UTF-8 implied -->
◎
Set action to an action that runs the application/x-www-form-urlencoded serializer with object’s list.
</li>
					<li>
%内容~型 ~SET !application/x-www-form-urlencoded;charset=UTF-8^bl
◎
Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.
</li>
					<li>
%~source ~SET %~obj
◎
Set source to object.
</li>
				</ol>
			</dd>

			<dt>!USVString$I</dt>
			<dd>
				<ol>
					<li>
%動作 ~SET 次を走らす動作
⇒
%~obj を!~UTF-8符号化-$encする
◎
Set action to an action that runs UTF-8 encode on object.
</li>
					<li>
%内容~型 ~SET !text/plain;charset=UTF-8^bl
◎
Set Content-Type to `text/plain;charset=UTF-8`.
</li>
					<li>
%~source ~SET %~obj
◎
Set source to object.
</li>
				</ol>
			</dd>

			<dt>!ReadableStream$I</dt>
			<dd>
%~stream ~SET %~obj
◎
Set stream to object. 
</dd>

		</dl>
	</li>
	<li>
~IF［
%~keepalive~flag ~EQ ~ON
］~AND［
%~obj は !ReadableStream$I 型である
］
⇒
~THROW !TypeError^E 
◎
If keepalive flag is set and object’s type is a ReadableStream object, then throw a TypeError. 
</li>
	<li>
<p>
~IF［
%動作 ~NEQ ~NULL
］
⇒
%動作 を!並列的$htmlに走らす：
◎
If action is non-null, run action in parallel:
</p>

		<ul>
			<li>
1 個以上の~byte %~byte列 が可用になる度に
⇒
［［
%~byte列 を包含している !ArrayBuffer$I
］を包装している !Uint8Array$I ~obj
］を %~stream に!~enqueue$RSする
⇒
!ArrayBuffer$I の作成-時に例外が投出されたときは
⇒
その例外で %~stream を!~errorにする$RS；<br>
走っている %動作 を取消す
◎
Whenever one or more bytes are available, let bytes be the bytes and enqueue a Uint8Array object wrapping an ArrayBuffer containing bytes to stream. If creating the ArrayBuffer threw an exception, error stream with that exception and cancel running action.
</li>
			<li>
%動作 を走らせ終えたときは
⇒
%~stream を!~closeする$RS
◎
When running action is done, close stream.
</li>
		</ul>
	</li>
	<li>
%本体 ~LET 次のようにされた新たな!本体$
⇒
!~stream$bd ~SET %~stream；<br>
!~source$bd ~SET %~source
◎
Let body be a body whose stream is stream and whose source is source.
</li>
	<li>
~RET
( %本体, %内容~型 )
◎
Return body and Content-Type.
</li>
</ol>


⇒！
[NoInterfaceObject,
 Exposed=(Window,Worker)]
interface !Body@I {
  readonly attribute !ReadableStream$I? !body$m;
  readonly attribute boolean !bodyUsed$m;
  [NewObject] Promise&lt;!ArrayBuffer$I&gt; !arrayBuffer$m();
  [NewObject] Promise&lt;!Blob$I&gt; !blob$m();
  [NewObject] Promise&lt;!FormData$I&gt; !formData$m();
  [NewObject] Promise&lt;any&gt; !json$m();
  [NewObject] Promise&lt;!USVString$I&gt; !text$m();
};
◎


<p class="note">注記：
~HTMLなど，~network層に依存させたくない内容形式が、ここで公開されることにはならないであろう。
むしろ、~HTML構文解析器~APIが，~streamを受容するようになるであろう。
【<a href="https://lists.w3.org/Archives/Public/public-whatwg-archive/2014Jun/thread.html#msg72">参考</a>】
<!-- https://lists.w3.org/Archives/Public/public-whatwg-archive/2014Jun/thread.html#msg72 -->
◎
Formats you would not want a network layer to be dependent upon, such as HTML, will likely not be exposed here. Rather, an HTML parser API might accept a stream in due course.
</p>


<div class="p">
<p>
!Body$I ~mixinを実装している各~objには、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>!本体@Bd</dt>
	<dd>
~NULL または !本体$。
</dd>

	<dt>!~MIME型@Bd</dt>
	<dd>
初期~時は 空~byte列。
</dd>

</dl>
◎
Objects implementing the Body mixin gain an associated body (null or a body) and a MIME type (initially the empty byte sequence).
</div>

<p>
!Body$I ~mixinを実装している~objは、その!本体$Bd %本体 が：
◎
↓</p>

<ul>
	<li>
［
%本体 ~NEQ ~NULL
］~AND［
%本体 の!~stream$bdは!妨げられている$RS
］とき，
!妨げられている@Bd
という。
◎
An object implementing the Body mixin is said to be disturbed if body is non-null and its stream is disturbed.
</li>
	<li>
［
%本体 ~NEQ ~NULL
］~AND［
%本体 の!~stream$bdは!~lockされている$Bd
］とき，
!~lockされている@Bd
という。
◎
An object implementing the Body mixin is said to be locked if body is non-null and its stream is locked.
</li>
</ul>

<dl class="idl-def">
	<dt>!body@m</dt>
	<dd>
取得子は、［
此れの!本体$Bd ~NEQ ~NULL ならば その!~stream$bd ／
~ELSE_  ~NULL
］を返さ~MUST。
◎
The body attribute’s getter must return null if body is null and body’s stream otherwise.
</dd>

	<dt>!bodyUsed@m</dt>
	<dd>
取得子は、［
此れは!妨げられている$Bdならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The bodyUsed attribute’s getter must return true if disturbed, and false otherwise.
</dd>
</dl>


<p class="algo-head">
!Body$I ~mixinを実装している各~objには、
!~dataを梱包-@Bd
する~algoも結付けられる。
それは、所与の
( %~byte列, %型, %~MIME型 )
に対し， %型 に応じて次を走らす：
◎
Objects implementing the Body mixin also have an associated package data algorithm, given bytes, a type and a mimeType, switches on type, and runs the associated steps:
</p>


<dl class="switch">
	<dt>!ArrayBuffer^i</dt>
	<dd>
~RET %~byte列 を内容とする !ArrayBuffer$I （例外投出あり）
◎
Return an ArrayBuffer whose contents are bytes. Rethrow any exceptions.
</dd>

	<dt>!Blob^i</dt>
	<dd>
~RET %~byte列 を内容とする, ［
!type$mF 属性 ~SET %~MIME型
］にされた !Blob$I
◎
Return a Blob whose contents are bytes and type attribute is mimeType.
</dd>

	<dt>!FormData^i</dt>
	<dd>
<p>
%~MIME型 の~parameterを除いた部分に応じて：
◎
↓</p>

		<dl class="switch">
			<dt>
!multipart/form-data^bl
◎
If mimeType (ignoring parameters) is `multipart/form-data`, run these substeps:
</dt>
			<dd>
				<ol>
					<li>
<p>
!Returning Values from Forms: multipart/form-data^cite
!RFC7578$r
に則って、
( %~MIME型 の !boundary^bl ~parameterの値 )
を与える下で，
%~byte列 を構文解析する
— それにより得られた各 部位 %部位 に対しては、［
%部位 の中の !Content-Disposition^h ~headerが !filename^bl ~parameterを包含するかどうかに応じて，次で与えられる値
］を値とする!~entry$xhrに構文解析され~MUST：
◎
Parse bytes, using the value of the `boundary` parameter from mimeType, per the rules set forth in Returning Values from Forms: multipart/form-data. [RFC7578]
</p>
						<dl class="switch">
							<dt>包含する場合</dt>
							<dd>
<p>
次のようにされた !File$I ~obj：
</p>
<ul ><li>その内容 ~SET %部位 の内容
</li><li>!name$mF 属性の値 ~SET !filename^bl ~parameterの値
</li><li>!type$mF 属性の値 ~SET %部位 内に !Content-Type$h ~headerが［
あれば その~header値 ／
なければ !text/plain^bl （ !RFC7578$r 4.4 節に定義される既定）
］
</li></ul>

◎
Each part whose `Content-Disposition` header contains a `filename` parameter must be parsed into an entry whose value is a File whose content is the content of the part. The name attribute of the File must have the value of the `filename` parameter of the part. The type attribute of the File must have the value of the `Content-Type` header of the part if the part has such header, and `text/plain` (the default defined by [RFC7578] section 4.4) otherwise.
</dd>

							<dt>包含しない場合</dt>
							<dd>
%部位 の内容を!~UTF-8復号-$encした結果
<span class="note">
これは、［
!Content-Type$h ~header ／ !charset^bl ~parameter
］の有無やその値に関わらず行われる。
</span>
◎
Each part whose `Content-Disposition` header does not contain a `filename` parameter must be parsed into an entry whose value is the UTF-8 decoded content of the part. This is done regardless of the presence or the value of a `Content-Type` header and regardless of the presence or the value of a `charset` parameter.
</dd>
						</dl>

<p class="note">注記：
［
!Content-Disposition^h ~headerが !name^bl ~parameterを包含していて,
その値は !_charset_^bl である
］ような部位も、他の部位と同様に構文解析される。
それは符号化方式を変更することはない。
◎
A part whose `Content-Disposition` header contains a `name` parameter whose value is `_charset_` is parsed like any other part. It does not change the encoding.
</p>
					</li>
					<li>
~IF［
何らかの事由で，前~段が失敗した
］
⇒
~THROW !TypeError^E
◎
If that fails for some reason, then throw a TypeError.
</li>
					<li>
~RET ［
!~entry$xhrの~list ~SET 構文解析した結果の!~entry$xhrたち
］にされた，新たな !FormData$I ~obj
◎
Return a new FormData object, appending each entry, resulting from the parsing operation, to entries.
</li>
				</ol>

<p class="XXX">課題：
上述は、 !multipart/form-data^bl に必要なものを大まかに述べたものである。
構文解析の より詳細な仕様が書かれることになる。
協力を歓迎する。
◎
The above is a rough approximation of what is needed for `multipart/form-data`, a more detailed parsing specification is to be written. Volunteers welcome.
</p>

			</dd>

			<dt>
!application/x-www-form-urlencoded^bl
◎
Otherwise, if mimeType (ignoring parameters) is `application/x-www-form-urlencoded`, run these substeps:
</dt>
			<dd>
				<ol>
					<li>
%~entries ~LET
%~byte列 を!~form_urlencoded 構文解析器$urlにかけた結果
◎
Let entries be the result of parsing bytes.
</li>
					<li>
~IF［
%~entries ~EQ !失敗^i
］
⇒
~THROW !TypeError^E
◎
If entries is failure, then throw a TypeError.
</li>
					<li>
~ELSE
⇒
~RET ［
!~entry$xhrの~list ~SET %~entries
］にされた，新たな !FormData$I ~obj
◎
Return a new FormData object whose entries are entries. 
</li>
				</ol>
			</dd>

			<dt>その他</dt>
			<dd>
~THROW !TypeError^E
◎
Otherwise, throw a TypeError.
</dd>
		</dl>
	</dd>

	<dt>!JSON^i</dt>
	<dd>
~RET ［
%~byte列 を!~UTF-8復号-$encした結果
］を引数に［
!JSON^I ~objの !parse^c ~propの初期~値
］を呼出した結果（例外投出あり）
◎
Return the result of invoking the initial value of the parse property of the JSON object with the result of running UTF-8 decode on bytes as argument. Rethrow any exceptions.
</dd>

	<dt>!text^i</dt>
	<dd>
~RET［
%~byte列 を!~UTF-8復号-$encした結果
］
◎
Return the result of running UTF-8 decode on bytes.
</dd>

</dl>



<p class="algo-head">
!Body$I ~mixinを実装している各~obj %O には、
!本体を消費-@Bd
する~algoも結付けられる
— それは、所与の %型 に対し，次を走らす：
◎
Objects implementing the Body mixin also have an associated consume body algorithm, given a type, runs these steps:
</p>


<ol>
	<li>
~IF［
%O は［
!妨げられている$Bd, または
!~lockされている$Bd
］］
⇒
~RET !TypeError^E で!却下され$た新たな~promise
◎
If this object is disturbed or locked, return a new promise rejected with a TypeError.
</li>
	<li>
%~stream ~LET ［
%O の!本体$Bd ~NEQ ~NULL ならば その!~stream$bd ／
~ELSE_ !空の~ReadableStream~obj$
］
◎
Let stream be body’s stream if body is non-null, or an empty ReadableStream object otherwise.
</li>
	<li>
%読取器 ~LET %~stream から!読取器を取得-$RSした結果
⇒
例外が投出されたときは
⇒
~RET その例外で!却下され$た新たな~promise
◎
Let reader be the result of getting a reader from stream. If that threw an exception, return a new promise rejected with that exception.
</li>
	<li>
%~promise ~LET
%読取器 を用いて， %~stream から!すべての~byte列を読取った$RS結果
◎
Let promise be the result of reading all bytes from stream with reader.
</li>
	<li>
<p>
~RET ［
次を走らす充足~handler
］で %~promise を!変形-$した結果：
</p>
		<ol>
			<li>
~RET
( ~handlerの最初の引数, %型, %O の!~MIME型$Bd )
に対し，!~dataを梱包-$Bdした結果
</li>
		</ol>
<!-- XXX IDL really needs to define "transforming". For now it is defined in
          https://www.w3.org/2001/tag/doc/promises-guide -->
◎
Return the result of transforming promise by a fulfillment handler that returns the result of the package data algorithm with its first argument, type and this object’s MIME type.
</li>
</ol>

<dl class="idl-def">
	<dt>!arrayBuffer()@m</dt>
	<dd>
被呼出時には、
!ArrayBuffer^i に対し
!本体を消費-$Bdした結果を返さ~MUST。
◎
The arrayBuffer() method, when invoked, must return the result of running consume body with ArrayBuffer.
</dd>

	<dt>!blob()@m</dt>
	<dd>
被呼出時には、
!Blob^i に対し
!本体を消費-$Bdした結果を返さ~MUST。
◎
The blob() method, when invoked, must return the result of running consume body with Blob.
</dd>

	<dt>!formData()@m</dt>
	<dd>
被呼出時には、
!FormData^i に対し
!本体を消費-$Bdした結果を返さ~MUST。
◎
The formData() method, when invoked, must return the result of running consume body with FormData.
</dd>

	<dt>!json()@m</dt>
	<dd>
被呼出時には、
!JSON^i に対し
!本体を消費-$Bdした結果を返さ~MUST。
◎
The json() method, when invoked, must return the result of running consume body with JSON.
</dd>

	<dt>!text()@m</dt>
	<dd>
被呼出時には、
!text^i に対し
!本体を消費-$Bdした結果を返さ~MUST。
◎
The text() method, when invoked, must return the result of running consume body with text.
</dd>
</dl>

		</section>
		<section id="request-class">
<h3 title="Request class">5.3. !Request^I ~class</h3>

<!-- No client member, see
  https://github.com/slightlyoff/ServiceWorker/issues/318
  https://github.com/slightlyoff/ServiceWorker/issues/575 -->

⇒！
typedef (!Request$I or !USVString$I) !RequestInfo@I;

[<a href="#dom-request">Constructor</a>(
    !RequestInfo$I %input,
    optional !RequestInit$I %init
), Exposed=(Window,Worker)]
interface !Request@I {
  readonly attribute !ByteString$I !method$m;
  readonly attribute !USVString$I !url$m;
  [SameObject] readonly attribute !Headers$I !headers$m;


  readonly attribute !RequestType$I !type$m;
  readonly attribute !RequestDestination$I !destination$m;
  readonly attribute !USVString$I !referrer$m;
  readonly attribute !ReferrerPolicy$I !referrerPolicy$m;
  readonly attribute !RequestMode$I !mode$m;
  readonly attribute !RequestCredentials$I !credentials$m;
  readonly attribute !RequestCache$I !cache$m;
  readonly attribute !RequestRedirect$I !redirect$m;
  readonly attribute !DOMString$I !integrity$m;
  readonly attribute boolean !keepalive$m;

  [NewObject] !Request$I !clone$m();
};
!Request$I implements !Body$I;

<!--
  Careful: defaults can only be set in prose, otherwise the Request() constructor algorithm breaks down.
-->dictionary !RequestInit@I {
  !ByteString$I !method@RqI;
  !HeadersInit$I !headers@RqI;
  !BodyInit$I? !body@RqI;
  !USVString$I !referrer@RqI;
  !ReferrerPolicy$I !referrerPolicy@RqI;
  !RequestMode$I !mode@RqI;
  !RequestCredentials$I !credentials@RqI;
  !RequestCache$I !cache@RqI;
  !RequestRedirect$I !redirect@RqI;
  !DOMString$I !integrity@RqI;
  boolean !keepalive@RqI;
  any !window@RqI; // <span class="comment"
	title="can only be set to null"
  >設定できるのは ~NULL にのみ。</span>
 };

enum !RequestType@I {
  "", "audio", "font", "image", "script", "style", "track", "video"
};
enum !RequestDestination@I {
  "", "audio", "document", "embed", "font", "image", "manifest", "object", "report", "script", "serviceworker", "sharedworker", "style",  "track", "video", "worker", "xslt"
};
enum !RequestMode@I {
  "navigate", "same-origin", "no-cors", "cors"
};
enum !RequestCredentials@I {
  "omit", "same-origin", "include"
};
enum !RequestCache@I {
  "default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"
};
enum !RequestRedirect@I {
  "follow", "error", "manual"
};
◎

<p class="note">注記：
!serviceworker^l が !RequestDestination$I から省略されているのは、~JSからは観測し得ないためである。
それでも，実装は、!行先$rqとして それを~supportする必要がある。
!websocket^l が !RequestMode$I から省略されているのは、~JSからは観測し得ないためである。
◎
"serviceworker" is omitted from RequestDestination as it cannot be observed from JavaScript. Implementations will still need to support it as a destination. "websocket" is omitted from RequestMode as it cannot be used nor observed from JavaScript.
</p>

<p>
!Request$I ~objには、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>!要請@Rq</dt>
	<dd>
!要請$。
◎
A Request object has an associated request (a request).
</dd>

	<dt>!Headers$I ~obj</dt>
	<dd>
この~objには，!要請$Rqの!~header~list$rqが結付けられる。
!すなわち，同じ~header~listを前項の要請と共有する。^tnote
◎
A Request object also has an associated Headers object which is itself associated with request’s header list.
</dd>

</dl>

<p>
!Request$I ~objの!本体$Bdは、その!要請$Rqの!本体$rqである。
◎
A Request object’s body is its request’s body.
</p>

<hr>

<!-- 
!Request@I
-->

<p class="idl-def">
!Request(input, init)@m
構築子は、次を走らせ~MUST：
◎
The Request(input, init) constructor must run these steps:
</p>

<ol>
	<li>
%要請 ~LET ~NULL
◎
Let request be null.
</li>
	<li>
%~fallback~mode ~LET ~NULL
◎
Let fallbackMode be null.
</li>
	<li>
%~fallback資格証 ~LET ~NULL
◎
Let fallbackCredentials be null.
</li>
	<li>
%基底~URL ~LET !現在の設定群~obj$の!~API基底~URL$enV
◎
Let baseURL be current settings object’s API base URL.
</li>
	<li>
<p>
~IF［
%input は文字列である
］：
◎
If input is a string, then run these substeps:
</p>

		<ol>
			<li>
%解析済~URL ~LET
( 基底~URL: %基底~URL )
を与える下で，
%input を!~url構文解析器$urlにかけた結果
◎
Let parsedURL be the result of parsing input with baseURL.
</li>
			<li>
~IF［
%解析済~URL ~EQ !失敗^i
］
⇒
~THROW !TypeError^E
◎
If parsedURL is failure, then throw a TypeError.
</li>
			<li>
~IF［
%解析済~URL は!資格証を含む$url
］
⇒
~THROW !TypeError^E
◎
If parsedURL includes credentials, then throw a TypeError.
</li>
			<li>
%要請 ~SET 次のようにされた，新たな!要請$
⇒
!~url$rq ~SET %解析済~URL
◎
Set request to a new request whose url is parsedURL.
</li>
			<li>
%~fallback~mode ~SET !cors^l
◎
Set fallbackMode to "cors".
</li>
			<li>
%~fallback資格証 ~SET !omit^l
◎
Set fallbackCredentials to "omit".
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE （ %input は !Request$I ~objである ）
：
◎
Otherwise (input is a Request object), run these substeps:
</p>
		<ol>
			<li>
~IF［
%input は!妨げられている$Bd
］~OR［
%input は!~lockされている$Bd
］
⇒
~THROW !TypeError^E
◎
If input is disturbed or locked, then throw a TypeError.
</li>
			<li>
%要請 ~SET %input の!要請$Rq
◎
Set request to input’s request. 
</li>
		</ol>
	</li>
	<li>
%生成元 ~LET !現在の設定群~obj$の!生成元$html
◎
Let origin be current settings object’s origin.
</li>
	<li>
%~window ~LET !client^l
◎
Let window be "client".
</li>
	<li>
~IF［
%要請 の!~window$rqは!環境~設定群~obj$である
］~AND［
( %要請 の!~window$rqの!生成元$html, %生成元 )
は，!同一生成元$である
］
⇒
%~window ~SET %要請 の!~window$rq
◎
If request’s window is an environment settings object and its origin is same origin with origin, set window to request’s window.
</li>
	<li>
~IF［
%init に !window$RqI ~memberは!在する$idl
］~AND［
その~member値 ~NEQ ~NULL
］
⇒
~THROW !TypeError^E
◎
If init’s window member is present and it is non-null, then throw a TypeError.
</li>
	<li>
~IF［
%init に !window$RqI ~memberは!在する$idl
］
⇒
%~window ~SET !no-window^l
◎
If init’s window member is present, set window to "no-window".
</li>
	<li>
<p>
%要請 ~SET 次のように設定された，新たな!要請$：
</p>

<ul ><li>!~url$rq ~SET %要請 の!現在の~url$rq
</li><li>!~method$rq ~SET %要請 の!~method$rq
</li><li>!~header~list$rq ~SET %要請 の!~header~list$rqの複製
</li><li>!非安全-要請~flag$rq ~SET ~ON
</li><li>!~client$rq ~SET !現在の設定群~obj$
</li><li>!~window$rq ~SET %~window
</li><li>!生成元$rq ~SET !client^l
</li><li>!~referrer$rq ~SET %要請 の!~referrer$rq
</li><li>!~referrer施策$rq ~SET %要請 の!~referrer施策$rq
</li><li>!~mode$rq ~SET %要請 の!~mode$rq
</li><li>!資格証~mode$rq ~SET %要請 の!資格証~mode$rq
</li><li>!~cache~mode$rq ~SET %要請 の!~cache~mode$rq
</li><li>!~redirect~mode$rq ~SET %要請 の!~redirect~mode$rq
</li><li>!完全性~metadata$rq ~SET %要請 の!完全性~metadata$rq
</li><li>!~keepalive~flag$rq ~SET %要請 の!~keepalive~flag$rq
</li></ul>

◎
Set request to a new request whose url is request’s current url, method is request’s method, header list is a copy of request’s header list, unsafe-request flag is set, client is current settings object, window is window, origin is "client", referrer is request’s referrer, referrer policy is request’s referrer policy, mode is request’s mode, credentials mode is request’s credentials mode, cache mode is request’s cache mode, redirect mode is request’s redirect mode, integrity metadata is request’s integrity metadata, and keepalive flag is request’s keepalive flag.
</li>
	<li>
<p>
~IF［
%init には，いずれかの
<span class="trans-note">【
!RequestInit$I
】</span>
~memberは!在する$idl
］：
◎
If any of init’s members are present, run these substeps:
</p>

		<ol>
			<li>
~IF［
%要請 の!~mode$rq ~EQ !navigate^l
］
⇒
%要請 の!~mode$rq ~SET !same-origin^l
◎
If request’s mode is "navigate", then set it to "same-origin".
</li>
			<li>
%要請 の!~referrer$rq ~SET !client^l
◎
Set request’s referrer to "client"
</li>
			<li>
%要請 の!~referrer施策$rq ~SET 空~文字列
◎
Set request’s referrer policy to the empty string. 
			</li>
		</ol>

<p class="note">注記：
これは、~service-workerが要請
— 例えば非同一生成元~stylesheetからの画像 —
を “~redirectして” 改変を加えたときに、元の~source（すなわち，非同一生成元~stylesheet）から来たのでなく，その~service-workerから来たように現れることを確保するために行われる。
このことは、元の~sourceは，~service-workerと同じ種類の要請すら生成できないかもしれないので，重要である。
元の~sourceを信用する~serviceは、
could therefore be exploited were this not done, although that is somewhat farfetched.
!？^tnote
◎
This is done to ensure that when a service worker "redirects" a request, .e.g., from an image in a cross-origin stylesheet, and makes modifications, it no longer appears to come from the original source (i.e., the cross-origin stylesheet), but instead from the service worker that "redirected" the request. This is important as the original source might not even be able to generate the same kind of requests as the service worker. Services that trust the original source could therefore be exploited were this not done, although that is somewhat farfetched.
</p>

	</li>
	<li>
<p>
~IF［
%init に !referrer$RqI ~memberは!在する$idl
］：
◎
If init’s referrer member is present, run these substeps:
</p>

		<ol>
			<li>
%~referrer ~LET %init の !referrer$RqI ~memberの値
◎
Let referrer be init’s referrer member.
</li>
			<li>
~IF［
%~referrer ~EQ 空~文字列
］
⇒
%要請 の!~referrer$rq ~SET !no-referrer^l；<br>
~GOTO !(A)^i
◎
If referrer is the empty string, set request’s referrer to "no-referrer" and terminate these substeps.
</li>
			<li>
%解析済~referrer ~LET
( 基底~URL: %基底~URL )
を与える下で，
%~referrer を!~url構文解析器$urlにかけた結果
◎
Let parsedReferrer be the result of parsing referrer with baseURL.
</li>
			<li>
~IF［
%解析済~referrer ~EQ !失敗^i
］
⇒
~THROW !TypeError^E
◎
If parsedReferrer is failure, then throw a TypeError.
</li>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If one of the following conditions is true, then set request’s referrer to "client":
</p>

			<ul>
				<li>
<p>
%解析済~referrer は次をいずれも満たす
</p>

<ul><li>その!~cannot-be-a-base-URL~flag$url ~EQ ~ON
</li><li>その!~scheme$url ~EQ !about^l
</li><li>その!~path$url は 単独の文字列 !client^l からなる
</li></ul>
◎
parsedReferrer’s cannot-be-a-base-URL flag is set, scheme is "about", and path contains a single string "client".
</li>
				<li>
( %解析済~referrer の!生成元$url, %生成元 )
は，!同一生成元$でない
◎
parsedReferrer’s origin is not same origin with origin 
</li>
			</ul>
				<!-- This can happen when you create a fresh request with values from an older request. Throwing
         would be rather hostile as preventing it requires implementing the same-origin check in
         developer space. -->

<p>
…ならば
⇒
%要請 の!~referrer$rq ~SET !client^l
◎
↑</p>

	</li>
			<li>
~ELSE
⇒
%要請 の!~referrer$rq ~SET %解析済~referrer
◎
Otherwise, set request’s referrer to parsedReferrer. 
</li>
		</ol>

	<li>
!(A)^i：
<p>
~IF［
%init に !referrerPolicy$RqI ~memberは!在する$idl
］
⇒
%要請 の!~referrer施策$rq ~SET その~member値
◎
If init’s referrerPolicy member is present, set request’s referrer policy to it.
</li>
	<li>
%~mode ~LET ［
%init に !mode$RqI ~memberは!在する$idlならば その~member値 ／
~ELSE_ %~fallback~mode
］
◎
Let mode be init’s mode member if it is present, and fallbackMode otherwise.
</li>
	<li>
~IF［
%~mode ~EQ !navigate^l
］
⇒
~THROW !TypeError^E
◎
If mode is "navigate", then throw a TypeError.
</li>
	<li>
~IF［
%~mode ~NEQ ~NULL
］
⇒
%要請 の!~mode$rq ~SET %~mode
◎
If mode is non-null, set request’s mode to mode.
</li>
	<li>
%資格証 ~LET ［
%init に !credentials$RqI ~memberは!在する$idlならば その~member値 ／
~ELSE_ %~fallback資格証
］
◎
Let credentials be init’s credentials member if it is present, and fallbackCredentials otherwise.
</li>
	<li>
~IF［
%資格証 ~NEQ ~NULL
］
⇒
%要請 の!資格証~mode$rq ~SET %資格証
◎
If credentials is non-null, set request’s credentials mode to credentials.
</li>
	<li>
~IF［
%init に !cache$RqI ~memberは!在する$idl
］
⇒
%要請 の!~cache~mode$rq ~SET その~member値
◎
If init’s cache member is present, set request’s cache mode to it.
</li>
	<li>
~IF［
%要請 の!~cache~mode$rq ~EQ !only-if-cached^l
~AND
%要請 の!~mode$rq ~NEQ !same-origin^l
］
⇒
~THROW !TypeError^E
◎
If request’s cache mode is "only-if-cached" and request’s mode is not "same-origin", then throw a TypeError.
</li>
	<li>
~IF［
%init に !redirect$RqI ~memberは!在する$idl
］
⇒
%要請 の!~redirect~mode$rq ~SET その~member値
◎
If init’s redirect member is present, set request’s redirect mode to it.
</li>
	<li>
~IF［
%init に !integrity$RqI ~memberは!在する$idl
］
⇒
%要請 の!完全性~metadata$rq ~SET その~member値
◎
If init’s integrity member is present, set request’s integrity metadata to it.
</li>
	<li>
%要請 の!~keepalive~flag$rq ~SET ［［
%init に !keepalive$RqI ~memberは!在する$idl ~AND
その~member値 ~EQ ~T
］ならば ~ON ／
~ELSE_ ~OFF
］
◎
If init’s keepalive member is present, then set request’s keepalive flag if init’s keepalive member is true, and unset it otherwise. 
</li>
	<li>
<p>
~IF［
%init に !method$RqI ~memberは!在する$idl
］：
◎
If init’s method member is present, let method be it and run these substeps:
</p>

		<ol>
			<li>
%~method ~LET その~member値
</li>
			<li>
~IF［
%~method は!~method$でない
］~OR［
%~method は!禁止~method$である
］
⇒
~THROW !TypeError^E
◎
If method is not a method or method is a forbidden method, then throw a TypeError.
</li>
			<li>
%~method を!正規化-$mdする
◎
Normalize method.
</li>
			<li>
%要請 の!~method$rq  ~SET %~method
◎
Set request’s method to method.
</li>
		</ol>
	</li>
	<li>
%R ~LET 次が結付けられた，新たな !Request$I ~obj
⇒
!要請$Rq ~SET %要請；<br>
!Headers$I ~obj ~SET !新たな~Headers$( !request^l, %要請 の!~header~list$rq )
◎
Let r be a new Request object associated with request and a new associated Headers object whose guard is "request".
</li>
	<li>
%headers ~LET %R の !Headers$I ~objの複製
— !~header~list$Hl も含めて複製する
<!-- it might contain a header that is no longer allowed per the mode change -->
◎
Let headers be a copy of r’s Headers object and its associated header list.
</li>
	<li>
~IF［
%init に !headers$RqI ~memberは!在する$idl
］
⇒
%headers ~SET %init の !headers$RqI ~member
◎
If init’s headers member is present, set headers to init’s headers member.
</li>
	<li>
%R の !Headers$I ~objの!~header~list$Hlを空にする
◎
Empty r’s Headers object’s header list.
</li>
	<li>
<p>
~IF［
%R の!要請$Rqの!~mode$rq ~EQ !no-cors^l
］：
◎
If r’s request’s mode is "no-cors", run these substeps:
</p>

		<ol>
			<li>
~IF［
%R の!要請$Rqの!~method$rqは !~CORS安全な~method$でない
］
⇒
~THROW !TypeError^E
◎
If r’s request’s method is not a CORS-safelisted method, then throw a TypeError.
</li>
			<li>
~IF［
%要請 の!完全性~metadata$rq ~NEQ 空~文字列
］
⇒
~THROW !TypeError^E
◎
If request’s integrity metadata is not the empty string, then throw a TypeError.
</li>
	<li>
%R の !Headers$I ~objの!~guard$Hl  ~SET !request-no-cors^l
◎
Set r’s Headers object’s guard to "request-no-cors".
</li>
		</ol>
	</li>
	<li>
%R の !Headers$I ~objを %headers で!埋める$Hl（例外投出あり）
◎
Fill r’s Headers object with headers. Rethrow any exceptions.
</li>
	<li>
%入力~本体 ~LET［
%input は !Request$I ~objであるならば %input の!要請$Rqの!本体$rq ／
~ELSE_ ~NULL
］
◎
Let inputBody be input’s request’s body if input is a Request object, and null otherwise.
</li>
	<li>
%本体~member ~LET ［
%init に !body$RqI ~memberは!在する$idl ならば その~member値 ／
~ELSE_ ~NULL
］
◎
↓</li>
	<li>
~IF［［
%本体~member ~NEQ ~NULL
］~OR［
%入力~本体 ~NEQ ~NULL
］］~AND［
%要請 の!~method$rq ~IN { !GET$hm, !HEAD$hm }
］
⇒
~THROW !TypeError^E
◎
If either init’s body member is present and is non-null or inputBody is non-null, and request’s method is `GET` or `HEAD`, then throw a TypeError. 
</li>
	<li>
%本体 ~LET %入力~本体
◎
Let body be inputBody.
</li>
	<li>
<p>
~IF［
%本体~member ~NEQ ~NULL
］：
◎
If init’s body member is present and is non-null, run these substeps:
</p>

		<ol>
			<li>
%内容~型 ~LET ~NULL
◎
Let Content-Type be null.
</li>
			<li>
~IF［
%init に !keepalive$RqI ~memberは!在する$idl ~AND
その~member値 ~EQ ~T
］
⇒
( %本体, %内容~型 ) ~SET
［
~keepalive~flag ~SET ~ON
］の下で， %本体~member から!本体と内容~型を抽出-$した結果
（例外投出あり）
◎
If init’s keepalive member is present and is true, then set body and Content-Type to the result of extracting init’s body member, with keepalive flag set. Rethrow any exceptions.
</li>
			<li>
~ELSE
⇒
( %本体, %内容~型 ) ~SET
%本体~member から!本体と内容~型を抽出-$した結果（例外投出あり）
◎
Otherwise, set body and Content-Type to the result of extracting init’s body member. Rethrow any exceptions.
</li>
			<li>
~IF ［
%内容~型 ~NEQ ~NULL
］~AND［［
%R の !Headers$I ~objの!~header~list$Hl
］内に［
!Content-Type$h を!名前に持つ~header$
］は無い
］
⇒
%R の !Headers$I ~objに
( !Content-Type$h / %内容~型 )
を!付加-$Hlする（例外投出あり）
◎
If Content-Type is non-null and r’s Headers object’s header list does not contain `Content-Type`, then append `Content-Type`/Content-Type to r’s Headers object. Rethrow any exception.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%本体 ~NEQ ~NULL
~AND
%本体 の!~source$bd ~EQ ~NULL
］：
◎
If body is non-null and body’s source is null, then run these substeps:
</p>
		<ol>
			<li>
~IF［
%R の!要請$Rqの!~mode$rq ~NIN { !same-origin^l, !cors^l }
］
⇒
~THROW !TypeError^E
◎
If r’s request’s mode is neither "same-origin" nor "cors", then throw a TypeError.
</li>
			<li>
%R の!要請$Rqの!~CORS予行~利用~flag$rq ~SET ~ON
◎
Set r’s request’s use-CORS-preflight flag.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%入力~本体 ~NEQ ~NULL
］：
◎
If inputBody is non-null, then run these substeps:
</p>
		<ol>
			<li>
<p>
%RS ~LET %入力~本体 の!~stream$bdと正確に同じ~dataを読取れるような !ReadableStream$I ~obj
◎
Let rs bs a ReadableStream object from which one can read the exactly same data as one could read from inputBody’s stream.
</p>

<p class="XXX">
これは、
<a href="~STREAMS#ts-model">形式変換~stream</a>
と
<a href="~STREAMS#pipe-chains">~pipe法</a>
が精確に定義されたなら，より精確に指定されることになる。
<a href="https://github.com/whatwg/fetch/issues/463">この課題</a>
を見よ。
◎
This will be specified more precisely once transform stream and piping are precisely defined. See the issue.
</p>

<p class="note">注記：
これは %入力~本体 の!~stream$bdが，即時に［
!~lockされている$RS, かつ
!妨げられている$RS
］ようにする。
◎
This makes inputBody’s stream locked and disturbed immediately.
</p>
			</li>
			<li>
~IF［
%入力~本体 ~EQ %本体
］
⇒
%本体 ~SET 次のようにされた，新たな!本体$
⇒
!~stream$bd ~SET %RS；<br>
!~source$bd ~SET %入力~本体 の!~source$bd；<br>
!総~byte数$bd ~SET %入力~本体 の!総~byte数$bd
◎
If inputBody is body, then set body to a new body whose stream is rs, whose source is inputBody’s source and whose total bytes is inputBody’s total bytes.
</li>
		</ol>
	</li>
	<li>
%R の!要請$Rqの!本体$rq ~SET %本体 
◎
Set r’s request’s body to body.
</li>
	<li>
%R の!~MIME型$Bd ~SET
%R の!要請$Rqの!~header~list$rqから
!~MIME型を抽出-$hdした結果
◎
Set r’s MIME type to the result of extracting a MIME type from r’s request’s header list.
</li>
	<li>
~RET %R
◎
Return r.
</li>
</ol>


<dl class="idl-def">
	<dt>!method@m</dt>
	<dd>
取得子は、此れの!要請$Rqの!~method$rqを返さ~MUST。
◎
The method attribute’s getter must return request’s method.
</dd>

	<dt>!url@m</dt>
	<dd>
取得子は、此れの!要請$Rqの!~url$rqを!~url直列化器$urlにかけた結果を返さ~MUST。
◎
The url attribute’s getter must return request’s url, serialized.
</dd>

	<dt>!headers@m</dt>
	<dd>
取得子は、此れの !Headers$I ~objを返さ~MUST。
◎
The headers attribute’s getter must return the associated Headers object.
</dd>

	<dt>!type@m</dt>
	<dd>
取得子は、此れの!要請$Rqの!種別$rqを返さ~MUST。
◎
The type attribute’s getter must return request’s type.
</dd>

	<dt>!destination@m</dt>
	<dd>
取得子は、此れの!要請$Rqの!行先$rqを返さ~MUST。
◎
The destination attribute’s getter must return request’s destination.
</dd>

	<dt>!referrer@m</dt>
	<dd>
<p>
取得子は、此れの!要請$Rqの!~referrer$rqに応じて，次を返さ~MUST：
</p>

		<dl class="switch">
			<dt>!no-referrer^l</dt>
			<dd>空~文字列</dd>

			<dt>!client^l</dt>
			<dd>!about:client^l</dd>

			<dt>その他</dt>
			<dd>!~referrer$rqを!~url直列化器$urlにかけた結果</dd>
		</dl>
◎
The referrer attribute’s getter must return the empty string if request’s referrer is "no-referrer", "about:client" if request’s referrer is "client", and request’s referrer, serialized, otherwise.
</dd>

	<dt>!referrerpolicy@m</dt>
	<dd>
取得子は、此れの!要請$Rqの!~referrer施策$rqを返さ~MUST。
◎
The referrerPolicy attribute’s getter must return request’s referrer policy.
</dd>

	<dt>!mode@m</dt>
	<dd>
取得子は、此れの!要請$Rqの!~mode$rqを返さ~MUST。
◎
The mode attribute’s getter must return request’s mode.
</dd>

	<dt>!credentials@m</dt>
	<dd>
取得子は、此れの!要請$Rqの!資格証~mode$rqを返さ~MUST。
◎
The credentials attribute’s getter must return request’s credentials mode.
</dd>

	<dt>!cache@m</dt>
	<dd>
取得子は、此れの!要請$Rqの!~cache~mode$rqを返さ~MUST。
◎
The cache attribute’s getter must return request’s cache mode.
</dd>

	<dt>!redirect@m</dt>
	<dd>
取得子は、此れの!要請$Rqの!~redirect~mode$rqを返さ~MUST。
◎
The redirect attribute’s getter must return request’s redirect mode. 
</dd>

	<dt>!integrity@m</dt>
	<dd>
取得子は、此れの!要請$Rqの!完全性~metadata$rqを返さ~MUST。
◎
The integrity attribute’s getter must return request’s integrity metadata.
</dd>

	<dt>!keepalive@m</dt>
	<dd>
取得子は、［
此れの!要請$Rqの!~keepalive~flag$rq ~EQ ~ON ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The keepalive attribute’s getter must return true if request’s keepalive flag is set, and false otherwise.
</dd>

	<dt>!clone()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The clone() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
此れは!妨げられている$Bd
］~OR［
此れは!~lockされている$Bd
］
⇒
~THROW !TypeError^E
◎
If this Request object is disturbed or locked, then throw a TypeError.
</li>
			<li>
%要請 ~LET 此れの!要請$Rqを!~clone$rqした結果
◎
↓</li>
			<li>
~RET 次が結付けられた，新たな !Request$I ~obj
⇒
!要請$Rq ~SET %要請；<br>
!Headers$I ~obj ~SET !新たな~Headers$( 此れの !Headers$I ~objの!~guard$Hl, %要請 の!~header~list$rq )
◎
Return a new Request object associated with the result of cloning request and a new associated Headers object whose guard is context object’s Headers object’s guard.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="response-class">
<h3 title="Response class">5.4. !Response^I ~class</h3>

⇒！
[<a href="#dom-response">Constructor</a>(
    optional !BodyInit$I? %body = null,
    optional !ResponseInit$I %init
), Exposed=(Window,Worker)]
interface !Response@I {
  [NewObject] static !Response$I !error$m();
  [NewObject] static !Response$I !redirect$m(
      !USVString$I %url,
      optional unsigned short %status = 302
  );

  readonly attribute !ResponseType$I !type$m;

  readonly attribute !USVString$I !url$m;
  readonly attribute boolean !redirected$m;
  readonly attribute unsigned short !status$m;
  readonly attribute boolean !ok$m;
  readonly attribute !ByteString$I !statusText$m;
  [SameObject] readonly attribute !Headers$I !headers$m;
  readonly attribute Promise&lt;!Headers$I&gt; !trailer$m;

  [NewObject] !Response$I !clone$m();
};
!Response$I implements !Body$I;

dictionary !ResponseInit@I {
  unsigned short !status@RsI = 200;
  !ByteString$I !statusText@RsI = "OK";
  !HeadersInit$I !headers@RsI;
};

enum !ResponseType@I {
  "basic",  "cors",   "default",
  "error",  "opaque", "opaqueredirect"
};
◎

<p>
!Response$I ~objには、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>!応答@Rs</dt>
	<dd>
!応答$。
◎
A Response object has an associated response (a response).
</dd>

	<dt>!Headers$I ~obj</dt>
	<dd>
この~objには，!応答$Rsの!~header~list$rsが結付けられる。
!すなわち，同じ~header~listを前項の応答と共有する。^tnote
◎
A Response object also has an associated Headers object which is itself associated with response’s header list.
</dd>

	<dt>!~trailer~promise@Rs</dt>
	<dd>
~promise。
<span class="note">
!trailer$m 属性から利用される。
</span>
◎
A Response object also has an associated trailer promise (a promise). Used for the trailer attribute.
</dd>

</dl>


<p>
!Response$I ~objの!本体$Bdは、その!応答$Rsの!本体$rsである。
◎
A Response object’s body is its response’s body.
</p>

<!-- 
!Response@I
-->
<p class="idl-def">
!Response(body, init)@m
構築子の被呼出時には、次を走らせ~MUST：
◎
The Response(body, init) constructor, when invoked, must run these steps:
</p>


<ol>
	<li>
~IF［
%init の !status$RsI ~member ~NIN { !200^st 〜 !599^st }
］
⇒
~THROW !RangeError^E
◎
If init’s status member is not in the range 200 to 599, inclusive, then throw a RangeError.
</li>
	<li>
~IF［
%init の !statusText$RsI ~memberは
!reason-phrase$p ~token生成規則に合致しない
］
⇒
~THROW !TypeError^E
◎
If init’s statusText member does not match the reason-phrase token production, then throw a TypeError.
</li>
	<li>
%応答 ~LET 新たな!応答$
◎
↓</li>
	<li>
%R ~LET 次が結付けられた，新たな !Response$I ~obj
⇒
!応答$Rs ~SET %応答；<br>
!Headers$I ~obj ~SET !新たな~Headers$( !response^l, %応答 の!~header~list$rs )
◎
Let r be a new Response object, associated with a new response and a new associated Headers object whose guard is "response".
</li>
	<li>
%R の!応答$Rsの!~status$rs ~SET
%init の !status$RsI ~member
◎
Set r’s response’s status to init’s status member.
</li>
	<li>
%R の!応答$Rsの!~status~message$rs ~SET
%init の !statusText$RsI ~member
◎
Set r’s response’s status message to init’s statusText member.
</li>
	<li>
~IF［
%init に !headers$RsI ~memberは!在する$idl
］
⇒
%R の !Headers$I ~objを %init の !headers$RsI ~memberで!埋める$Hl（例外投出あり）
◎
If init’s headers member is present, then fill r’s Headers object with init’s headers member. Rethrow any exceptions.
</li>
	<li>
<p>
~IF［
%body ~NEQ ~NULL
］：
◎
If body is non-null, run these substeps:
</p>

		<ol>
			<li>
<p>
~IF［
%init の !status$RsI ~member は!~null本体~status$である
］
⇒
~THROW !TypeError^E
◎
If init’s status member is a null body status, then throw a TypeError.
</p>

<p class="note">注記：
!101$st は、他所におけるその利用に因り，!~null本体~status$に含まれているので、この段には影響しない。
◎
101 is included in null body status due to its use elsewhere. It does not affect this step.
</p>
			</li>
			<li>
%内容~型 ~LET ~NULL
◎
Let Content-Type be null.
</li>
			<li>
( %R の!応答$Rsの!本体$rs, %内容~型 ) ~SET %body から!本体と内容~型を抽出-$した結果（例外投出あり）
◎
Set r’s response’s body and Content-Type to the result of extracting body. Rethrow any exceptions.
</li>
	<li>
~IF［
%内容~型 ~NEQ ~NULL
］~AND［
%R の!応答$Rsの!~header~list$rs内に［
!Content-Type$h を!名前に持つ~header$
］は無い
］
⇒
%R の!応答$Rsの!~header~list$rsに
( !Content-Type$h / %内容~型 )
を!付加-$hlする
◎
If Content-Type is non-null and r’s response’s header list does not contain `Content-Type`, then append `Content-Type`/Content-Type to r’s response’s header list.
</li>
		</ol>
	</li>
	<li>
%R の!~MIME型$Bd ~SET
%R の!応答$Rsの!~header~list$rsから
!~MIME型を抽出-$hdした結果
◎
Set r’s MIME type to the result of extracting a MIME type from r’s response’s header list.
</li>
	<li>
%R の!応答$Rsの!~HTTPS状態$rs ~SET
!現在の設定群~obj$の!~HTTPS状態$enV
◎
Set r’s response’s HTTPS state to current settings object’s HTTPS state.
</li>
	<li>
!新たな~Headers$( !immutable^l )
で %R の!~trailer~promise$Rsを!解決する$
◎
Resolve r’s trailer promise with a new Headers object whose guard is "immutable".
</li>
	<li>
~RET %R
◎
Return r.
</li>
</ol>

<dl class="idl-def">
	<dt>!error()@m</dt>
	<dd>
<p>
この静的~methの被呼出時には、次を走らせ~MUST：
</p>

		<ol>
			<li>
%応答 ~LET 新たな!~network~error$
</li>
			<li>
~RET 次が結付けられた，新たな !Response$I ~obj
⇒
!応答$Rs ~SET %応答；<br>
!Headers$I ~obj ~SET !新たな~Headers$( !immutable^l, %応答 の!~header~list$rs )
</li>
		</ol>
◎
The static error() method, when invoked, must return a new Response object, associated with a new network error and a new associated Headers object whose guard is "immutable".
</dd>

	<dt>!redirect(url, status)@m</dt>
	<dd>
<p>
この静的~methの被呼出時には、次を走らせ~MUST：
◎
The static redirect(url, status) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%解析済~URL ~LET
( 基底~URL: !現在の設定群~obj$の!~API基底~URL$enV )
を与える下で，
%url を!~url構文解析器$urlにかけた結果
◎
Let parsedURL be the result of parsing url with current settings object’s API base URL.
</li>
			<li>
~IF［
%解析済~URL ~EQ !失敗^i
］
⇒
~THROW !TypeError^E
◎
If parsedURL is failure, then throw a TypeError.
</li>
			<li>
~IF［
%status は !~redirect~status$でない
］
⇒
~THROW !RangeError^E
◎
If status is not a redirect status, then throw a RangeError.
</li>
			<li>
%応答 ~LET 新たな!応答$
◎
↓</li>
			<li>
%R ~LET 次が結付けられた，新たな !Response$I ~obj
⇒
!応答$Rs ~SET %応答；<br>
!Headers$I ~obj ~SET !新たな~Headers$( !immutable^l, %応答 の!~header~list$rs )
◎
Let r be a new Response object, associated with a new response and a new associated Headers object whose guard is "immutable".
</li>
			<li>
%R の!応答$Rsの!~status$rs ~SET %status
◎
Set r’s response’s status to status.
</li>
			<li>
%R の!応答$Rsの!~header~list$rsの中で
( !Location$h / ［
%解析済~URL を!~url直列化器$urlにかけた結果
］を!~UTF-8符号化-$encした結果
) を!設定-$hlする
◎
Set `Location` to parsedURL, serialized and UTF-8 encoded, in r’s response’s header list.
</li>
			<li>
~RET %R
◎
Return r.
</li>
		</ol>
	</dd>

	<dt>!type@m</dt>
	<dd>
取得子は、此れの!応答$Rsの!種別$rsを返さ~MUST。
◎
The type attribute’s getter must return response’s type.
</dd>

	<dt>!url@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
</p>

		<ol>
			<li>
%~url ~LET 此れの!応答$Rs の!~url$rs
</li>
			<li>
~IF［
%~url ~EQ ~NULL
］
⇒
~RET 空~文字列
</li>
			<li>
~RET
( %素片除外~flag ~SET ~ON )
を与える下で， %~url を!~url直列化器$urlにかけた結果
!URL$r
</li>
		</ol>
◎
The url attribute’s getter must return the empty string if response’s url is null and response’s url, serialized with the exclude-fragment flag set, otherwise. [URL]
</dd>

	<dt>!redirected@m</dt>
	<dd>
取得子は、［
此れの!応答$Rsの!~url~list$rs内に複数の項があるならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The redirected attribute’s getter must return true if response’s url list has more than one item, and false otherwise.
</dd>
	<dd class="note">注記：
~redirectの結果による!応答$をはじくときは、~APIを通して直接的に行う
— 例えば
!fetch(url, { redirect:"error" })^c
のように。
こうすれば、安全でないかもしれない!応答$が不用意に漏洩されるのを~~防げる。
◎
To filter out responses that are the result of a redirect, do this directly through the API, e.g., fetch(url, { redirect:"error" }). This way a potentially unsafe response cannot accidentally leak.
</dd>

	<dt>!status@m</dt>
	<dd>
取得子は、此れの!応答$Rsの!~status$rsを返さ~MUST。
◎
The status attribute’s getter must return response’s status.
</dd>

	<dt>!ok@m</dt>
	<dd>
取得子は、［
此れの!応答$Rsの!~status$rsは !~ok~status$である
ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The ok attribute’s getter must return true if response’s status is an ok status, and false otherwise.
</dd>

	<dt>!statusText@m</dt>
	<dd>
取得子は、此れの!応答$Rsの!~status~message$rsを返さ~MUST。
◎
The statusText attribute’s getter must return response’s status message.
</dd>

	<dt>!headers@m</dt>
	<dd>
取得子は、此れの !Headers$I ~objを返さ~MUST。
◎
The headers attribute’s getter must return the associated Headers object.
</dd>

	<dt>!trailer@m</dt>
	<dd>
取得子は、此れの!~trailer~promise$Rsを返さ~MUST。
◎
The trailer attribute’s getter must return the associated trailer promise.
</dd>

	<dt>!clone()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The clone() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
此れは!妨げられている$Bd
］~OR［
此れは!~lockされている$Bd
］
⇒
~THROW !TypeError^E
◎
If context object is disturbed or locked, then throw a TypeError.
</li>
			<li>
%応答 ~LET 此れの!応答$Rsを!~clone$rsした結果
◎
↓</li>
			<li>
%R ~LET 次が結付けられた，新たな !Response$I ~obj
⇒
!応答$Rs ~SET %応答；<br>
!Headers$I ~obj ~SET !新たな~Headers$( 此れの !Headers$I ~objの!~guard$Hl, %応答 の!~header~list$rs )
◎
Let clonedResponse be a new Response object associated with the result of cloning context object’s response and a new associated Headers object whose guard is context object’s Headers object’s guard.
</li>
			<li>
此れの!~trailer~promise$Rsの!充足~時には$
⇒
!新たな~Headers$( !immutable^l, %応答 の!~trailer$rs )
で %R の!~trailer~promise$Rsを!解決する$
◎
Upon fulfillment of context object’s trailer promise, resolve clonedResponse’s trailer promise with a new Headers object whose guard is "immutable" that is associated with clonedResponse’s trailer.
</li>
			<li>
~RET %R
◎
Return clonedResponse.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="fetch-method">
<h3 title="Fetch method">5.5. !fetch^m ~meth</h3>

⇒！
partial interface !WindowOrWorkerGlobalScope$I {
  [NewObject] Promise&lt;!Response$I&gt; !fetch$m(
      !RequestInfo$I %input,
      optional !RequestInit$I %init
  );
};
◎

<p class="idl-def">
!fetch(input, init)@m
~methの被呼出時には、次を走らせ~MUST：
◎
The fetch(input, init) method, must run these steps:
</p>

<ol>
	<li>
%p ~LET !新たな~promise$
◎
Let p be a new promise.
</li>
	<li>

<p>
%要請 ~LET ［
( %input, %init )
を引数に［
!Request$I の<a href="#dom-request">構築子</a>の初期~値
］を呼出した結果
］に結付けられている，!要請$Rq<!-- ＊Rq -->
— ただし、構築子から例外が投出された場合は：
</p>

		<ol>
			<li>
その例外で %p を!却下する$
</li>
			<li>
~RET %p
</li>
		</ol>
◎
Let request be the associated request of the result of invoking the initial value of Request as constructor with input and init as arguments. If this throws an exception, reject p with it and return p.
</li>
	<li>
~IF［
%要請 の!~client$rqの!大域~obj$enVは !ServiceWorkerGlobalScope$I ~objである
］
⇒
%要請 の!~service-worker~mode$rq ~SET !foreign^l
◎
If request’s client’s global object is a ServiceWorkerGlobalScope object, set request’s service-workers mode to "foreign".
</li>
	<li>
<p>
この段は!並列的$htmlに走らす：
◎
↓↓
Let responseObject be a new Response object and a new associated Headers object whose guard is "immutable".
◎
Run the following in parallel:
</p>

<p>
%要請 を用いて!~fetch$する
— その結果の %応答 に対し：
◎
Fetch request.
</p>

		<ul>
			<li>
<p>
!応答を処理する$ときは：
◎
To process response for response, run these substeps:
</p>
				<ol>
					<li>
~IF［
%応答 の!種別$rs ~EQ !error^l
］
⇒
!TypeError^E で %p を!却下する$；<br>
~RET
◎
If response’s type is "error", reject p with a TypeError and terminate these substeps.
</li>
					<li>
%R ~LET 次が結付けられた，新たな !Response$I ~obj
⇒
!応答$Rs ~SET %応答；<br>
!Headers$I ~obj ~SET !新たな~Headers$( !immutable^l, %応答 の!~header~list$rs )
◎
↑
◎
Associate responseObject with response.
</li>
					<li>
%R で %p を!解決する$
◎
Resolve p with responseObject. 
</li>
				</ol>
			</li>
			<li>
<p>
!応答の~doneを処理する$ときは：
◎
To process response done for response, run these substeps:
</p>
				<ol>
					<li>
%~trailer~obj ~LET !新たな~Headers$( !immutable^l, %応答 の!~trailer$rs )
◎
Let trailerObject be a new Headers object whose guard is "immutable".
◎
Associate trailerObject with response’s trailer.
</li>
					<li>
%~trailer~obj で %R の!~trailer~promise$Rsを!解決する$
◎
Resolve responseObject’s trailer promise with trailerObject.
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>


		</section>
		<section id="garbage-collection">
<h3 title="Garbage collection">5.6 ~garbage収集</h3>

<p>
~UAは、進行中の~fetchを，その終了が~scriptを通して観測可能でないならば，事由 !~garbage収集^i で!終了-$させて~MAY。
◎
The user agent may terminate an ongoing fetch with reason garbage collection if that termination is not observable through script.
</p>

<p class="note">注記：
“~scriptを通して観測可能でない”
とは、［
!fetch()$m の引数や返値を通して観測可能でない
］ことを意味する。
~serverとの別の通信を通して可能になるものなどの，他の仕方は含まれない。
◎
"Observable through script" means observable through fetch()’s arguments and return value. Other ways, such as communicating with the server through a side-channel are not included.
</p>

<p class="note">注記：
~serverは、~garbage収集が~~起きたことを観測できる
— 例えば［
!WebSocket$I ／ !XMLHttpRequest$I 
］~objを通してなど。
◎
The server being able to observe garbage collection has precedent, e.g., with WebSocket and XMLHttpRequest objects.
</p>

<div class="example" id="terminate-examples">

<p>
終了は観測され得ないので、~UAは，~fetchを終了させれる：
◎
The user agent can terminate the fetch because the termination cannot be observed.
</p>


<pre>
fetch(!https://www.example.com/^l)
</pre>

<p>
終了は，~promiseを通して観測され得るので、~UAは~fetchを終了させれない：
◎
The user agent cannot terminate the fetch because the termination can be observed through the promise.
</p>

<pre>
window.promise = fetch(!https://www.example.com/^l)
</pre>

<p>
結付けられている本体は観測可能でないので、~UAは~fetchを終了させれる：
◎
The user agent can terminate the fetch because the associated body is not observable.
</p>

<pre>
window.promise = fetch(!https://www.example.com/^l)
  .then( %res =&gt; %res.headers )
</pre>

<p>
終了は観測され得ないので、~UAは~fetchを終了させれる：
◎
The user agent can terminate the fetch because the termination cannot be observed.
</p>

<pre>
fetch(!https://www.example.com/^l)
  .then( %res =&gt; %res.body.getReader().closed )
</pre>

<p>
~promise~objに対する~handlerを登録すれば，終了を観測できるので、~UAは~fetchを終了させれない：
◎
The user agent cannot terminate the fetch because one can observe the termination by registering a handler for the promise object.
</p>

<pre>
window.promise = fetch(!https://www.example.com/^l)
  .then( %res =&gt; %res.body.getReader().closed )
</pre>

<p>
登録された~handlerを介して終了が観測可能になるので、~UAは~fetchを終了させれない：
◎
The user agent cannot terminate the fetch as termination would be observable via the registered handler.
</p>

<pre>
fetch(!https://www.example.com/^l)
  .then( %res =&gt; {
    %res.body.getReader().closed
      .then(() =&gt; console.log(!~streamは~closeされた！^l))
  })
</pre>
<!-- 
stream closed!
-->

</div>

		</section>
	</section>
	<section id="websocket-protocol">
<h2 title="WebSocket protocol alterations">6. ~WebSocket~protocolの改め</h2>

<div class="note">
<p>注記：
この節は、~WebSocket~protocol~opening~handshake~client要件の一部を，~Fetchにて定義される~algoに統合するために置換する。
~CSP, ~cookie, HSTS, その他， Fetch に関係する~protocolは、この仕方で，一箇所に集約して取扱われるようになる。
RFC がこの言語とともに更新されるのが理想だが、それは決して容易にはならない。
~HTML標準に定義される~WebSocket~APIは、この言語を利用するように更新された。
!WSP$r !HTML$r
◎
This section replaces part of the WebSocket protocol opening handshake client requirement to integrate it with algorithms defined in Fetch. This way CSP, cookies, HSTS, and other Fetch-related protocols are handled in a single location. Ideally the RFC would be updated with this language, but it is never that easy. The WebSocket API, defined in the HTML Standard, has been updated to use this language. [WSP] [HTML]
</p>

<p>
これは、
WebSocket Protocol の
“~WebSocket接続を確立する” ~algoを
~Fetchに統合する， 3 つの~algo
— 接続を設定しておく ／
~handshake要請を作成して伝送する ／
~handshake応答を検証する —
に置換するような仕方で働く。
その重ね方は、~Fetchによる［
先ず~handshakeを作成し, 次に接続を設定しておいてから、~handshakeを伝送し, ~~最後に応答を検証する
］のとは，異なる。
この改めを読むときは、そのことを念頭に置くこと。
◎
The way this works is by replacing The WebSocket Protocol’s "establish a WebSocket connection" algorithm with a new one that integrates with Fetch. "Establish a WebSocket connection" consists of three algorithms: setting up a connection, creating and transmiting a handshake request, and validating the handshake response. That layering is different from Fetch, which first creates a handshake, then sets up a connection and transmits the handshake, and finally validates the response. Keep that in mind while reading these alterations.
</p>

</div>

		<section id="websocket-connections">
<h3 title="Connections">6.1. 接続</h3>

<p class="algo-head">
!~WebSocket接続を得る@
ときは、所与の
( %~url )
に対し，次の手続きを走らす：
◎
To obtain a WebSocket connection, given a url, run these steps:
</p>

<ol>
	<li>
%host ~LET %~url の!~host$url
◎
Let host be url’s host.
</li>
	<li>
%port ~LET %~url の!~port$url
◎
Let port be url’s port.
</li>
	<li>
%secure ~LET ［
%~url の!~scheme$url ~EQ !http^l ならば ~F ／
~ELSE_ ~T
］
◎
Let secure be false, if url’s scheme is "http", and true otherwise.
</li>
	<li>
( %host, %port, %secure )
を与える下で，
WebSocket Protocol <a href="~6455#section-4.1">4.1 節</a>
の
<a href="~6455#dfn-to-establish">前半の手続き</a>
の段 2 〜 5 に定められている要件に従って
<span title="concept-websocket-connection">~WebSocket接続</span>
を確立する
<!-- ＊？#concept-websocket-connection-obtain -->
!WSP$r
◎
Follow the requirements stated in step 2 to 5, inclusive, of the first set of steps in section 4.1 of The WebSocket Protocol to establish a WebSocket connection. [WSP]
</li>
	<li>
~RET［
接続は確立されたなら それ ／
~ELSE_ !失敗^i
］
◎
If that established a connection, return it, and return failure otherwise.
</li>
</ol>

<p class="note">注記：
~WebSocket接続は、異なる~propを運ぶ少し異なる~~構成なので，共有できないが、
“普通の” !接続$にごく近いものである。
◎
Although structured a little differently, carrying different properties, and therefore not shareable, a WebSocket connection is very close to identical to an "ordinary" connection.
</p>

		</section>
		<section id="websocket-opening-handshake">
<h3 title="Opening handshake">6.2. ~opening~handshake</h3>

<p class="algo-head">
!~WebSocket~protocol~handshakeを確立する@
ときは、所与の
( %~url, %~protocol~list, %~client )
に対し，次の手続きを走らす:
◎
To establish a WebSocket connection, given a url, protocols, and client, run these steps:
</p>

<ol>
	<li>
%要請~URL ~LET %~url の複製
◎
↓</li>
	<li>
<p >
%要請~URL の!~scheme$url ~SET ［
%~url の!~scheme$url ~EQ !ws^l ならば !http^l ／
~ELSE_ !https^l
］
◎
Let requestURL be a copy of url, with its scheme set to "http", if url’s scheme is "ws", and to "https" otherwise.
</p>

<p class="note">注記：
この~schemeの変更-は、!~fetching$に上手く統合するために本質的になる。
例えば HSTS は、こうしないと働かなくなる。
これは、旧来の遺物である
— ~WebSocketを別の~schemeにする~~本当の理由はない。
!HSTS$r
◎
This change of scheme is essential to integrate well with fetching. E.g., HSTS would not work without it. There is no real reason for WebSocket to have distinct schemes, it’s a legacy artefact. [HSTS]
</p>
</li>
	<li>
<p>
%要請 ~LET 次のようにされた新たな!要請$：
</p>

<ul ><li>!~url$rq ~SET %要請~URL
</li><li>!~client$rq ~SET %~client 
</li><li>!~service-worker~mode$rq ~SET !none^l
</li><li>!同期~flag$rq ~SET ~ON
</li><li>!~mode$rq ~SET !websocket^l
</li><li>!資格証~mode$rq ~SET !include^l
</li><li>!~cache~mode$rq ~SET !no-store^l
</li><li>!~redirect~mode$rq ~SET !error^l
</li></ul>

◎
Let request be a new request, whose url is requestURL, client is client, service-workers mode is "none", synchronous flag is set, mode is "websocket", credentials mode is "include", cache mode is "no-store", and redirect mode is "error".
</li>
	<li>
%要請 の!~header~list$rqに
( !Upgrade$h / !websocket^bl )
を!付加-$hlする
◎
Append `Upgrade`/`websocket` to request’s header list.
</li>
	<li>
%要請 の!~header~list$rqに
( !Connection$h / !Upgrade^bl )
を!付加-$hlする
◎
Append `Connection`/`Upgrade` to request’s header list.
</li>
	<li>
<p>
%~key値 ~LET
無作為に選定された 16 ~byteの値を，
base64 に符号化した結果からなる~nonce（
!RFC4648$r の <a href="~IETF/rfc4648#section-4">4 節</a>
を見よ）
◎
Let keyValue be a nonce consisting of a randomly selected 16-byte value that has been base64-encoded (see section 4 of [RFC4648]).
</p>

<p class="example" id="example-random-value">
例えば，無作為に選定された値が~byte列［
!01^X !02^X !03^X !04^X !05^X !06^X !07^X !08^X !09^X !0a^X !0b^X !0c^X !0d^X !0e^X !0f^X !10^X
］ならば、 %~key値 は
!AQIDBAUGBwgJCgsMDQ4PEC==^bl
になる。
◎
If the randomly selected value was the byte sequence 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, keyValue would be `AQIDBAUGBwgJCgsMDQ4PEC==`.
</li>
	<li>
%要請 の!~header~list$rqに
( !Sec-WebSocket-Key^h / %~key値 )
を!付加-$hlする
◎
Append `Sec-WebSocket-Key`/keyValue to request’s header list.
</li>
	<li>
%要請 の!~header~list$rqに
( !Sec-WebSocket-Version^h / !13^bl )
を!付加-$hlする
◎
Append `Sec-WebSocket-Version`/`13` to request’s header list.
</li>
	<li>
~FOR
%~protocol~list 内の ~EACH ( %~protocol )
に対し
⇒
%要請 の!~header~list$rqの中で
( !Sec-WebSocket-Protocol^h / %~protocol )
を!結合-$hlする
◎
For each protocol in protocols, combine `Sec-WebSocket-Protocol`/protocol in request’s header list.
</li>
	<li>
<p>
%permessageDeflate ~LET ~UAにより定義される !permessage-deflate^l 拡張 !~header$!値$hd
!WSP-Compression$r
◎
Let permessageDeflate be a user-agent defined "permessage-deflate" extension header value. [WSP]
</p>

<div class="example" id="example-permessage-deflate">
!permessage-deflate; client_max_window_bits^bl
</div>
	</li>
	<li>
%要請 の!~header~list$rqに
( !Sec-WebSocket-Extensions^h / %permessageDeflate )
を!付加-$hlする
◎
Append `Sec-WebSocket-Extensions`/permessageDeflate to request’s header list.
</li>
	<li>
%応答 ~LET %要請 を!~fetch$した結果
◎
Let response be the result of fetching request.
</li>
	<li>
~IF［
%応答 は!~network~error$である
］~OR［
%応答 の!~status$rs ~NEQ !101$st
］
⇒
!~WebSocket接続を失敗させる$
◎
If response is a network error or its status is not 101, fail the WebSocket connection.
</li>
	<li>
<p>
~IF［
%~protocol~list は空でない
］~AND［
%応答 の!~header~list$rsから
!Sec-WebSocket-Protocol^h
に対する!~header~list値を抽出-$hdした結果 ~IN 
{ ~NULL, !失敗^i, 空~byte列 }
］
⇒
!~WebSocket接続を失敗させる$
◎
If protocols is not the empty list and extracting header list values given `Sec-WebSocket-Protocol` and response’s header list results in null, failure, or the empty byte sequence, then fail the WebSocket connection.
</p>

<p class="note">注記：
これは、WebSocket Protocol にて定義される，この~headerに対する検査と異なる。
そこでは、~clientから要請されていない下位protocolがある場合についてのみふるいにかけていた。
ここでは、~clientから要請された下位protocolが~serverから承認されていない場合もふるいにかける。
◎
This is different from the check on this header defined by The WebSocket Protocol. That only covers a subprotocol not requested by the client. This covers a subprotocol requested by the client, but not acknowledged by the server.
</p>
	</li>
	<li>
WebSocket Protocol <a href="~6455#section-4.1">4.1 節</a>
の後半の手続きの段 2 〜 6 に定められている要件に従って，
%応答 を検証する
— これは、!~WebSocket接続を失敗させる$か, !~WebSocket接続は確立される$ことになる。
◎
Follow the requirements stated step 2 to step 6, inclusive, of the last set of steps in section 4.1 of The WebSocket Protocol to validate response. This either results in fail the WebSocket connection or the WebSocket connection is established.
</li>
</ol>

<p>
!~WebSocket接続を失敗させる@
!<a href="~6455#dfn-to-fail">参照先</a>^tnote ／
!~WebSocket接続は確立される@
!<a href="~6455#dfn-established">参照先</a>^tnote
は、 WebSocket Protocol にて定義される。
!WSP$r
◎
Fail the WebSocket connection and the WebSocket connection is established are defined by The WebSocket Protocol. [WSP]
</p>

<p class="warning">警告：
~redirectを追わない理由は、~HTTP認証が~~機能せず，~web~browser文脈に深刻な保安~問題をもたらすからである。
そのため、この~handshakeは，一般に制約される。
例えば、ある~hostが ある~pathに~WebSocket~serverを有していたとする。
その~hostが，別の~pathにも
!open HTTP redirector$
を有するようになった時点で、~WebSocket~URLを与え得るような どの~scriptも，その~URLの~hostnameが~~正しいことを検査したとしても，~internet上の~~任意の~hostと通信する（したがって秘匿情報を共有し得る）ように騙すことが可能になる。
<!-- https://www.ietf.org/mail-archive/web/hybi/current/msg06951.html -->
◎
The reason redirects are not followed, HTTP authentication will not function, and this handshake is generally restricted is because that could introduce serious security problems in a web browser context. For example, consider a host with a WebSocket server at one path and an open HTTP redirector at another. Suddenly, any script that can be given a particular WebSocket URL can be tricked into communicating to (and potentially sharing secrets with) any host on the internet, even if the script checks that the URL has the right hostname.
</p>

		</section>
	</section>
	<section id="background-reading">

<h2 title="Background reading">背景情報</h2>

<p>
<em>この節（および その下位節）は参考である。</em>
◎
This section and its subsections are informative only.
</p>

		<section id="http-header-layer-division">
<h3 title="HTTP header layer division">~HTTP~header層の区分<!-- dfn --></h3>

<div class="p">
<p>
~fetchingの目的においては、次の層がある：
</p>

<ol>
	<li>
~API層
⇒
開発者は、この層において~headerを設定できる（概して， !Request$I ~objを通して）。
</li>
	<li>
早期~fetch層（~HTMLの !img^e 要素, ~CSSの !background-image^css ~propなど）
⇒
!Accept$h, !Accept-Language$h は、（概して，~UAにより）この層にて設定される。
</li>
	<li>
~service-worker層
⇒
~API層と同様に，開発者は、この層において~headerを設定できる。
</li>
	<li>
~network＆~cache層
⇒
!Accept-Encoding$h, !Host$h, !Referer$h など，~UAにより制御される他のほとんどの~headerは、この層において設定される。
</li>
</ol>

<p>
!禁止~header名$については、開発者が制御できる部分はほとんどないが，
!Accept$h を制御したり, !Referer$h を拘束する／省略させる手段はある。
</p>

◎
For the purposes of fetching, there is an API layer (HTML’s img, CSS' background-image), early fetch layer, service worker layer, and network &amp; cache layer. `Accept` and `Accept-Language` are set in the early fetch layer (typically by the user agent). Most other headers controlled by the user agent, such as `Accept-Encoding`, `Host`, and `Referer`, are set in the network &amp; cache layer. Developers can set headers either at the API layer or in the service worker layer (typically through a Request object). Developers have almost no control over forbidden headers, but can control `Accept` and have the means to constrain and omit `Referer` for instance.
</div>


		</section>
		<section id="atomic-http-redirect-handling">
<h3 title="Atomic HTTP redirect handling">~HTTP~redirectの不可分的な取扱い</h3>

<p>
~redirect（!応答$のうち，［
その!~status$rs, または
その!内的~応答$の!~status$rs
］が !~redirect~status$であるもの）は、~APIには公開されない。
仮に~redirectを公開したなら，~XSS攻撃を通して情報が漏洩されることになる。
◎
Redirects (a response whose status or internal response’s (if any) status is a redirect status) are not exposed to APIs. Exposing redirects might leak information not otherwise available through a cross-site scripting attack.
</p>

<p class="example" id="example-xss-redirect">
［
!HttpOnly^bl 付きの !Cookie$h
］が含まれる~URL（例えば
!https://example.org/auth^s
）への~fetchが，秘匿情報を包含する~URL（例えば
!https://other-origin.invalid/<em>4af955781ea1c84a3b11</em>^s
）への~redirectになることもある。
仮に~redirectが公開されたなら、この秘匿情報は，~XSS攻撃により入手されることになる。
◎
A fetch to https://example.org/auth that includes a Cookie marked HttpOnly could result in a redirect to https://other-origin.invalid/4af955781ea1c84a3b11. This new URL contains a secret. If we expose redirects that secret would be available through a cross-site scripting attack.
</p>

		</section>
		<section id="basic-safe-cors-protocol-setup">
<h3 title="Basic safe CORS protocol setup">安全な~CORS~protocolを設定しておくための基本</h3>

<p>
IP 認証や~firewallを通して~dataが保護されている資源（不幸なことに，未だに ありふれている）に対する!~CORS~protocol$の利用は、<strong>安全でない</strong>。
（それがために，!~CORS~protocol$を開発する必要が生じたのである。）
◎
For resources where data is protected through IP authentication or a firewall (unfortunately relatively common still), using the CORS protocol is unsafe. (This is the reason why the CORS protocol had to be invented.)
</p>

<p>
しかしながら、次の!~header$を利用している場合は<strong>安全である</strong>：
<!-- ＊otherwise -->
◎
However, otherwise using the following header is safe:
</p>

<pre>Access-Control-Allow-Origin: *</pre>

<p>
資源が~cookieや~HTTP認証に基づく追加の情報を公開するときでも、上の!~header$の利用は，それを露出させない。
これは、 curl や wget などにより すでに共有されているかのごとく，資源を
!XMLHttpRequest$I
などの~APIと共有する。
◎
Even if a resource exposes additional information based on cookie or HTTP authentication, using the above header will not reveal it. It will share the resource with APIs such as XMLHttpRequest, much like it is already shared with curl and wget.
</p>

<p>
したがって，言い換えれば、（ curl や wget などを利用して）~webに接続している任意の機器からは~accessし得ないような資源においては、上述の!~header$は含まれない。
~accessし得る場合については，その様にすること<!-- ＊？ -->は全く妥当である。
◎
Thus in other words, if a resource cannot be accessed from a random device connected to the web using curl and wget the aforementioned header is not to be included. If it can be accessed however, it is perfectly fine to do so.
</p>

		</section>
		<section id="cors-protocol-and-http-caches">
<h3 title="CORS protocol and HTTP caches">~CORS~protocolと~HTTP~cache</h3>

<p>
!~CORS~protocol$の要件が，［
!Access-Control-Allow-Origin$hを［
!*^bl または静的な!生成元$html
］に設定する
］より複雑なものである場合、
!Vary$h が用いられることになる。
!HTML$r
!HTTP$r
!HTTP-SEMANTICS$r
!HTTP-COND$r
!HTTP-CACHING$r
!HTTP-AUTH$r
◎
If CORS protocol requirements are more complicated than setting `Access-Control-Allow-Origin` to * or a static origin, `Vary` is to be used. [HTML] [HTTP] [HTTP-SEMANTICS] [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]
</p>

<pre class="example" id="example-vary-origin">Vary: Origin</pre>

		</section>
	</section>

</main><!-- id="MAIN" -->

	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p >
この仕様の策定に寄与された次の方々に感謝する：
</p>

<p>
Thanks to

Adam Barth,
Adam Lavin,
Alan Jeffrey,
Alexey Proskuryakov,
Andrés Gutiérrez,
Andrew Sutherland,
Ángel González,
Anssi Kostiainen,
Arkadiusz Michalski,
Arne Johannessen,
Arthur Barstow,
Axel Rauschmayer,
Ben Kelly,
Benjamin Hawkes-Lewis,
Bert Bos,
Björn Höhrmann,
Boris Zbarsky,
Brad Hill,
Brad Porter,
Bryan Smith,
Caitlin Potter,
Cameron McCormack,
Clement Pellerin,
Collin Jackson,
Daniel Robertson,
Daniel Veditz,
David Håsäther,
David Orchard,
Dean Jackson,
Domenic Denicola,
Dominique Hazaël-Massieux,
Doug Turner,
Eero Häkkinen,
Ehsan Akhgari,
Emily Stark,
Eric Lawrence,
François Marier,
Frank Ellerman,
Frederick Hirsch,
Gavin Carothers,
Glenn Maynard,
Graham Klyne,
Hal Lockhart,
Hallvord R. M. Steen,
Henri Sivonen,
Henry Story,
Hiroshige Hayashizaki,
Honza Bambas,
Ian Hickson,
Ilya Grigorik,
isonmad,
Jake Archibald,
James Graham,
Janusz Majnert,
Jeena Lee,
Jeff Carpenter,
Jeff Hodges,
Jeffrey Yasskin,
Jesse M. Heines,
Jochen Eisinger,
Jonas Sicking,
Jonathan Kingston,
Jonathan Watt,
최종찬 (Jongchan Choi),
Jörn Zaefferer,
Joseph Pecoraro,
Josh Matthews,
Julian Krispel-Samsel,
Julian Reschke,
송정기 (Jungkee Song),
Jussi Kalliokoski,
Jxck,
Keith Yeung,
Kenji Baheux,
Lachlan Hunt,
Liam Brummitt,
Louis Ryan,
Lucas Gonze,
呂康豪 (Kang-Hao Lu),
Maciej Stachowiak,
Malisa,
Manfred Stock,
Manish Goregaokar,
Marc Silbey,
Marcos Caceres,
Marijn Kruisselbrink,
Mark Nottingham,
Mark S. Miller,
Martin Dürst,
Matt Andrews,
Matt Falkenhagen,
Matt Oshry,
Matt Seddon,
Matt Womer,
Mhano Harkness,
Michael Kohler,
Michael™ Smith,
Mike West,
Mohamed Zergaoui,
Ms2ger,
Nico Schlömer,
Nikhil Marathe,
Nikki Bee,
Nikunj Mehta,
Odin Hørthe Omdal,
Ondřej Žára,
Philip Jägenstedt,
R. Auburn,
Raphael Kubo da Costa,
Ryan Sleevi,
Rory Hewitt,
Sébastien Cevey,
Sendil Kumar N,
Shao-xuan Kang,
Sharath Udupa,
Shivakumar Jagalur Matt,
Sigbjørn Finne,
Simon Pieters,
Srirama Chandra Sekhar Mogali,
Steven Salat,
Sunava Dutta,
Surya Ismail,
吉野剛史 (Takeshi Yoshino),
Thomas Roessler,
Thomas Wisniewski,
Tiancheng "Timothy" Gu,
Tobie Langel,
Tom Schuster,
Tomás Aparicio,
保呂毅 (Tsuyoshi Horo),
Tyler Close,
Vignesh Shanmugam,
Vladimir Dzhuvinov,
Wayne Carr,
Xabier Rodríguez,
Yoav Weiss,
Youenn Fablet,
平野裕 (Yutaka Hirano), and
Zhenbin Xu

for being awesome.
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>

<p>
Per <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>, to
the extent possible under law, the editor has waived all copyright and related or
neighboring rights to this work.
</p>
	</section>
	<section id="references">

<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>

<script type="text/plain" class="ref_data">

[ABNF]
    D. Crocker, Ed.; P. Overell. Augmented BNF for Syntax Specifications: ABNF. January 2008. Internet Standard. URL: https://tools.ietf.org/html/rfc5234 
[CLIENT-HINTS]
    Ilya Grigorik. HTTP Client Hints. URL: https://tools.ietf.org/html/draft-ietf-httpbis-client-hints 
[COOKIES]
    A. Barth. HTTP State Management Mechanism. April 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6265 
[CSP]
    Mike West. Content Security Policy Level 3. URL: https://w3c.github.io/webappsec-csp/ 
[DATAURL]
    Simon Sapin. The data URL scheme. URL: https://simonsapin.github.io/data-urls/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[FileAPI]
    Arun Ranganathan; Jonas Sicking. File API. URL: https://www.w3.org/TR/FileAPI/ 
[HSTS]
    J. Hodges; C. Jackson; A. Barth. HTTP Strict Transport Security (HSTS). November 2012. Proposed Standard. URL: https://tools.ietf.org/html/rfc6797 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[HTTP]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7230 
[HTTP-AUTH]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Authentication. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7235 
[HTTP-CACHING]
    R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Caching. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7234 
[HTTP-COND]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7232 
[HTTP-SEMANTICS]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7231 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MIX]
    Mike West. Mixed Content. URL: https://w3c.github.io/webappsec-mixed-content/ 
[REFERRER]
    Jochen Eisinger; Emily Stark. Referrer Policy. URL: https://www.w3.org/TR/referrer-policy/ 
[RFC4648]
    S. Josefsson. The Base16, Base32, and Base64 Data Encodings. October 2006. Proposed Standard. URL: https://tools.ietf.org/html/rfc4648 
[RFC7578]
    L. Masinter. Returning Values from Forms: multipart/form-data. July 2015. Proposed Standard. URL: https://tools.ietf.org/html/rfc7578 
[SRI]
    Devdatta Akhawe; et al. Subresource Integrity. URL: https://w3c.github.io/webappsec-subresource-integrity/ 
[STREAMS]
    Domenic Denicola; 吉野剛史 (Takeshi Yoshino). Streams Standard. Living Standard. URL: https://streams.spec.whatwg.org/ 
[SW]
    Alex Russell; et al. Service Workers 1. URL: https://www.w3.org/TR/service-workers-1/ 
[TLS]
    T. Dierks; E. Rescorla. The Transport Layer Security (TLS) Protocol Version 1.2. August 2008. Proposed Standard. URL: https://tools.ietf.org/html/rfc5246 
[UPGRADE]
    Mike West. Upgrade Insecure Requests. URL: https://w3c.github.io/webappsec-upgrade-insecure-requests/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://www.w3.org/TR/WebIDL-1/ 
[WSP]
    C. Holmberg, S. Hakansson, G. Eriksson. The WebSocket protocol. URL: https://tools.ietf.org/id/draft-ietf-hybi-thewebsocketprotocol-09.txt 
[XHR]
    Anne van Kesteren. XMLHttpRequest Standard. Living Standard. URL: https://xhr.spec.whatwg.org/ 
</script>

		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<script type="text/plain" class="ref_data">
[CORS]
    Anne van Kesteren. Cross-Origin Resource Sharing. 16 January 2014. REC. URL: https://www.w3.org/TR/cors/ 
[HTTP-RANGE]
    R. Fielding, Ed.; Y. Lafon, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Range Requests. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7233 
[HTTPVERBSEC1]
    Multiple vendors’ web servers enable HTTP TRACE method by default.. URL: https://www.kb.cert.org/vuls/id/867593 
[HTTPVERBSEC2]
    Microsoft Internet Information Server (IIS) vulnerable to cross-site scripting via HTTP TRACK method.. URL: https://www.kb.cert.org/vuls/id/288308 
[HTTPVERBSEC3]
    HTTP proxy default configurations allow arbitrary TCP connections.. URL: https://www.kb.cert.org/vuls/id/150227 
[ORIGIN]
    A. Barth. The Web Origin Concept. December 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6454 
</script>



		</section>
	</section>


</body></html>

<!-- 他の語
range:〜
OFF:unset
obtained:得られ
:mark
optionally:optionの
corresponding:
与-:given
:consist
~IN:contain
含-:include
次の:the following
zero:
一部／一環:part of
結果:result
限定して:limited
only flag:限定~flag
feed 渡す
service
壊れた:broken
はっきりしない:unclear
~INCBY:increase
対処deals with
取って代わる／置き換える:supplants
大雑把に言えば:In broad strokes
区分:division
用途:usage
背景情報:background reading:~
比較的:relatively
低~level:low-level
高~levelから見れば At a high level, 
現時点では:currently
場合分け:casing
全般に渡り:Throughout
徐々に~~築かれ:evolves over time
統一化-:unified 
それなりに／~~適度に:fairly
書き下ろされ:written down
世代ごとに:to the next.
常でand used to
ほとんど:most
様々なものと~~複雑に入り組んでいる:quite involved
現時点では:currently
~~暗黙の前提:underlying assumption
種類／類の:kind:~
最後の~~手段:last resort:~
別の:side-channel
~~起きた:has precedent
助け:help
~~規定する:stipulates
やめた stop
項:item
調べる:inspect
	検分-:inspect:~
~~無視してnot paying attention
向けの／に向かうに先立ち，on the way
一箇所に集約:in a single location
理想だが:ideally
念頭に置く:Keep that in mind
~~構成-structure
運ぶ:carry する
~~機能:function
~~正しい:right
追-:follow
問題:problem:~
~~最後に:finally
重ね方:layering
時点で:Suddenly
~~本当の:real
ほぼ間違いなく:highly likely
見込みが高い:more likely
まったく:perfectly
誤記:misspelling
かまわない:fine
別個の:distinct:~
ascribe:帰するとみなされ
該当する:pertains
足りる:suffices
今では、:nowadays
要している:necessitating
昔から:the old days
上層:top of
~~働き~functioning
慎重に事を~~運ぶ:extreme care
今度:now
でなくする方へ~~働くrather
必ず:make sure
~~機能:functional
染め:taint
同様に:similarly
別法として:alternatively
在る:there are any
無い:does not contain
およそ役に立たない:rather useless
~~懸案になる:matter
~~整理:sorted through
~~対照的に:as opposed
指す:pointer
課される:subject to
残り続ける:stay alive
上限がある:bound
~NULL でないこと:nullity
すなわち:Namely,
功罪:for better or worse
広く widely

TODO: 各 enum 定数にも id を付与する
-->
