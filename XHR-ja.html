<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>XMLHttpRequest Standard （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
var source_data;

COMMON_DATA.init = function(expanded){

	var options = {
		spec_status: 'LS',
		original_url: 'https://xhr.spec.whatwg.org/',
		main: 'MAIN',
		ref_data: '.ref_data',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true
	};

	if(expanded) return options;


	source_data = {
		html: E('MAIN').innerHTML,
		prefix_map: Util.getMapping('_prefix_map'),
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked 170908 spec

	return options;
}


function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		E: 'error',
		sc: 'scheme',
		AO: 'abstract',
		bug: 'bug-link',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		mb: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		E: 'code',
		v: 'var',
		i: 'i',
		AO: 'span',
		bug: 'span',
	};

	var link_map = this.link_map;
	E('MAIN').innerHTML = Util.generateSource(this, mapping1, function(source){
		return source.replace(
			/%[\w~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		);
	});
	return;

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'h': // 
	text = '`<code class="header">' + text + '</code>`';
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'lb': // literal bytes
	text = '`<code class="literal">' + text + '</code>`';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<!-- 語彙 -->

<script type="text/plain" id="words_table">

	●DOM／IDL
引数:argument:~
属性:attribute:~
meth:method:::メソッド
obj:object:::オブジェクト
promise:
値:value:~
返値:return value:返り値
初期:initial:~
初期化-:initialize:~
数値:numeric value:~
新たな:new:~
ツリー:tree:~
構築子:constructor::~::コンストラクタ
内容:content:~
要素:element:~
文書:document::~
例外:exception:~
投出:throw:~
公開-:expose:~

関数:function:~
garbage::::ガーベジ
収集-:collect:~
収集:collection:~
大域:global::~::グローバル
環境:environment:~
大域環境:global environment:global 環境:~::グローバル環境
文書環境:document environment:document 環境:~
型:type:~
多重定義:overload:~
構築-:construct:~
継承-:inherit:~
反復-:iterate:~

	●event process

event::::イベント
発火:fire:~
handler::::ハンドラ
interface::::インタフェース
list::::リスト
listener::::リスナ

進捗:progress::~::プログレス
task::::タスク
source::::ソース
源:source::~::ソース
待行列:queue::待ち行列::キュー
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ

	段:step:~
下位手続き:substeps:~
手続き:steps:~
取扱う:handle する:取り扱う
処理-:process:~

省略-:omit:~

同期的:synchronous:~
同期:synchronous:~
worker:

取得子:getter:~
取得-:get:~
設定子:setter:~
設定-:set:~

設定群:settings::~
関連する:relevant な::~
担当の:responsible::~
並列的:parallel:~
	●
URL:
MIME:
JSON:
arraybuffer::::配列バッファ
blob:
API:
backtick::::バッククォート
prescan:
data::::データ
charset:
	charset:::文字集合:文字セット
基底:base::~
byte::::バイト
文字大小無視:case-insensitive:~
文字:character:~
復号-:decode::~::デコード
配送-:dispatch:~
空:empty:~
文字列:string:~
符号化-:encode::~::エンコード
符号化器:encoder::~::エンコーダ
符号化方式:encoding::~::エンコーディング
	符号化法:encoding::~::エンコーディング
確定的:definite:~
直列化-:serialize::~::シリアル化
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
	構文解析できる:parsable
解析済み:parsed::~::パース済み
生成規則:production:~
妥当:valid:~
名前空間整形式:namespace well formedness:名前空間 整形式
	settings object
規則:rule:~
literal::::リテラル

parameter::::パラメタ
entry::::エントリ
error::::エラー


	●状態値
unsent:
opened:
headers-received:headers received
loading:
done:

	●XHR
CORS:
header::::ヘッダ
	headers::::ヘッダリスト
method::::メソッド
	対::ペア
要請:request::~::リクエスト
応答:response::~::レスポンス
資源:resource::~:リソース
fetch:
fetching:::fetch 処理
種別:type:~

認証:authentication::~
client::::クライアント
proxy::::プロキシ
server::::サーバ
cookie::::クッキー

form_data_set:form data set::form data 集合:フォームデータ集合
status::::ステータス
message::::メッセージ
文脈:context::~

失敗-:fail::~
失敗:failure::~
成功:success::~
取消す:cancel する::~:キャンセルする

合致:match::~::マッチ
名前:name::~
名:name::~
network::::ネットワーク
	ネットワーク処理:networking
生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン
非同一生成元:cross-origin::同一生成元でない::クロスオリジン
上書き:override::~
素片除外:exclude fragment:fragment 除外:~::フラグメント除外
予行:preflight::~::プリフライト
	生成元省略:omit-<code>Origin</code>-header::<code>Origin</code> ヘッダ省略
行先:destination::~
redirect::::リダイレクト
referrer::::リファラ
受信-:receive::~
受信済み:received::~
送信-:send::~
状態:state::~

転送:transfer::~
伝送-:transmit::~
伝送量:transmitted::~
伝送済み:transmitted::~
伝送:transmission::~
更新:update:~
	発行:make:~

匿名:anonymous:~
本体:body::~::ボディ
本体終端:end-of-body:body 終端:~::ボディ終端
通知:notification:~

upload:::::アップロード
host::::ホスト
username::::ユーザ名
password::::パスワード
stream::::ストリーム
chunk::::チャンク
code::::コード
protocol::::プロトコル
活動:activity::~
資格証:credentials::資格証明情報::クレデンシャル
資格証省略:omit credentials:credentials 省略:資格証明情報 省略::クレデンシャル省略
非安全:unsafe::~
登録-:register:~
	破棄:discard:~
指示-:indicate:~
結合-:combine::~
最終:final::~
fallback::::フォールバック
既定:default:~
省略可:optional:~
	＊optional:::オプション

filename:::file 名:ファイル名

長さ:length:~

flag::::フラグ
mode::::モード
相対:relative::~
完了-:complete:~
内容型:content type::~

終了-:terminate:~
停止-:stop:~
時間切れ:timed out::~
	時間~切れ:preset time expiring
時間:time:~

接続:connection:~
証明書:certificate:~
禁止:forbidden:~

起動-:initiate:~
	着手

	load:::
読込まれ:load され:読み込まれ
結付けら:associate さ:結び付けら
有順序:ordered:~
被呼出時:被 invoke 時:~
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
呼出し:invoking:呼び出し
呼出せば:invoke すれば:呼び出せば

充足-:fulfill::~
却下-:reject::~
読取った:read した::読み取った
読取る:read する::読み取る
読取:read::読み取り
読取器:reader::読み取り器::リーダ

全部的:full::~
作動中:active::~::アクティブ


	●仕様
opt-in::::オプトイン
support::::サポート
UA:user agent::UA::ユーザエージェント
platform::::プラットフォーム
community::::コミュニティ
algo:algorithm:::アルゴリズム
tool::::ツール
仕様:spec:~
	specification
標準:standard:~
利用者:user::~::ユーザ
作者:author::~
末端利用者:end user::~::エンドユーザ
旧来:legacy:旧来の
非旧来:non-legacy:旧来のものでない
歴史的:historical:~
歴史:history:~
考慮点:considerations:~
特色機能:feature:~
拡張性:extensibility:~
拡張:extension:~
適合性:conformance:~
意図的:intentional:~
節:section:~
要覧:summary:~
規約:conventions:~
実装-:implement:~
実装:implementation:~
	バージョン:version:~
機能性:functionality:~
中止-:abort::~
	中止-済み:aborted
局面:scenario:~
推挙-:suggest:~

定めら:state さ:~
	他が定められない限り:Unless stated otherwise
壊さな:break しな:~
強く:strong に:~
奨励-:encourage:~
保障-:guarantee:~
概念:concept:~
互換性:compatibility:~
開発-:develop:~
開発者:developer:~
編集者:editor:~
移管-:move:~
併合-:merge:~
観点:perspective:~
解釈-:interpret:~
草案:draft:~
明示的:explicit:~
暗黙的:implicit:~
定義-:define:~
定義:definition:~
提供-:provide:~
決定-:determine:~
制御:control:~
目的:purpose:~
一貫性:consistency:~
	序論:introduction
	~~機能:working
単純:simple:~
	簡単:simple:~
可読性:readability:~
試験的:experimental:~
	experiment
過程:process:~
警告-:warn:~
組合わさ:combine さ:組み合わさ
	あいにく:unfortunate
	用例:example
	用法:usage
	用語:trem／terminology
	注記:
	あいにく:unfortunate
	用例:example
	用法:usage
	用語:trem／terminology
	自由:free
	引用:
	当初:
	必要:
	意味:
	成果:
	関心のある主体:interested parties
	図式:diagram
	固有の仔細:specific scenarios
	何の効果もない:has no effect
	例:example:~
	全般:Throughout
	不具合が生じた:went wrong
	~~互換性:
	仔細
	調べる:check
	~~調整:tune
	~~説明:description
	問題に馴染みのある人達の意見を汲む:ensure input from people familiar with the subject

	●未分類（動詞
作成-:create:~
無視-:ignore:~
表現-:represent:~
終端-:end:~
解放-:release:~
置換-:replace:~
適用-:apply:~
参照:reference:~
参照先:referenced:~
	割り当てる:allocate
制約-:restrict:~
付加-:append:~
変換-:convert:~
経過-:pass:~
除外-:exclude:~
	継続:continue:~
抽出-:extract:~
正規化-:normalize:~
信頼-:rely:~
既知の:known:~
走らす:run する:走らせる
走らせ:run し:走らせ
除去-:remove:~
変更-:change:~
変化-:change:~
不能化-:disable:~
要約-:summarize:~
絞込まれ:filter され:絞り込まれ
表示:display:~
整列-:sort::~::ソート
動作-:act:~
演算-:operate:~
進行中の:ongoing:~
	所与の:given
	やりとりする:interaction
	~~収集:gather
	含-:include
	壊-:breaking
	露わになる:reveal
	返す:return
	追跡~済:have been followed
	過ぎた:passed

	●未分類
utf-8:
Unicode:
現在の:current:~
HTML:
script::::スクリプト
text::::テキスト
成功裡:successfull:~

	可用:available:~
	相対的:relative:~

精巧:elaborate:~
変数:variable:~
情報:information:~
保安:security::~:セキュリティ
prop:property:::プロパティ
	typographic::
理由:reason:~
size::::サイズ
排他的:mutually exclusive:~
milli::::ミリ

</script>

<!--%他の単語


ミリ秒:millisecond:~ #2
	単位/数
キーワード
メーリングリスト
リンク付きで:cross-linked
一覧:table

〜の後:after
すべての:all
一連:
一部:
他の場合:otherwise
以下:
以上
各種:
唯一:
何年:
全体:
回
個
時点:
最初の:first
最後の:last
最終的
時機:when
出現: 1
可能:
同様: 2
同類: 1
回数:times #1
場合: 49
存在: 2

対応
括弧内: 1
単位: 1
範囲:range #1
	経緯
	利用:use

結果:result #26
	規定
計測:measure #1
通常: 1
進行:be ongoing #1
重複:twice #1
開始:start, initiate, begin: #2
際限のない:infinite
非:non
 -->


<!--% 置換データ -->
<script type="text/plain" id="words_table1">
US:unsigned short
RA:readonly attribute
open_async:open
type0:type
send:<code>send()</code> 
form_urlencoded:<code>application/x-www-form-urlencoded</code>

</script>

<!--%id → 原文 id -->
<script type="text/plain" id="_original_id_map">
	handle-response-end-of-body:handle-response-end-of-file

</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">

Exposed:~WEBIDL#Exposed
SameObject:~WEBIDL#SameObject

I.Document:~DOM4#document
I.Event:~DOM4#event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.FormData:#formdata
I.FormDataEntryValue:#formdataentryvalue
I.ProgressEvent:#progressevent
I.ProgressEventInit:#progresseventinit
I.XMLHttpRequest:#xmlhttprequest
I.XMLHttpRequestEventTarget:#xmlhttprequesteventtarget
I.XMLHttpRequestResponseType:#xmlhttprequestresponsetype
I.XMLHttpRequestUpload:#xmlhttprequestupload
I.BodyInit:~FETCH#bodyinit
I.Window:~WINDOW#window
I.HTMLFormElement:~HEforms#htmlformelement


I.Blob:~FILEAPI#blob
I.File:~FILEAPI#dfn-file
	~FILEAPI#file
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array
I.USVString:~WEBIDL#idl-USVString
I.ByteString:~WEBIDL#idl-ByteString
I.DOMString:~WEBIDL#idl-DOMString

	Constructor:#dom-formdata
	Constructor:#dom-xmlhttprequest

m.XMLHttpRequest:#dom-xmlhttprequest
m.FormData:#dom-formdata

m.DONE:#dom-xmlhttprequest-done
m.HEADERS_RECEIVED:#dom-xmlhttprequest-headers_received
m.LOADING:#dom-xmlhttprequest-loading
m.OPENED:#dom-xmlhttprequest-opened
m.UNSENT:#dom-xmlhttprequest-unsent

m.onabort:#handler-xhr-ononabort
m.onerror:#handler-xhr-ononerror
m.onload:#handler-xhr-ononload
m.onloadend:#handler-xhr-ononloadend
m.onloadstart:#handler-xhr-ononloadstart
m.onprogress:#handler-xhr-ononprogress
m.onreadystatechange:#handler-xhr-ononreadystatechange
m.ontimeout:#handler-xhr-onontimeout

m.abort:#dom-xmlhttprequest-abort
m.timeout:#dom-xmlhttprequest-timeout
m.type:~DOM4#dom-event-type
m.~type0:~FILEAPI#dfn-type
m.append:#dom-formdata-append
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.delete:#dom-formdata-delete
m.get:#dom-formdata-get
m.getAll:#dom-formdata-getall
m.getAllResponseHeaders:#dom-xmlhttprequest-getallresponseheaders
m.getResponseHeader:#dom-xmlhttprequest-getresponseheader
m.has:#dom-formdata-has
m.lengthComputable:#dom-progressevent-lengthcomputable
m.loaded:#dom-progressevent-loaded
m.name:~FILEAPI#dfn-name
m.open:#dom-xmlhttprequest-open
m.~open_async:#dom-xmlhttprequest-open-method-url-async-username-password
m.overrideMimeType:#dom-xmlhttprequest-overridemimetype
m.prescan:~HTMLparsing#prescan-a-byte-stream-to-determine-its-encoding
m.readyState:#dom-xmlhttprequest-readystate
m.response:#dom-xmlhttprequest-response
m.responseText:#dom-xmlhttprequest-responsetext
m.responseType:#dom-xmlhttprequest-responsetype
m.responseURL:#dom-xmlhttprequest-responseurl
m.responseXML:#dom-xmlhttprequest-responsexml
m.send:#dom-xmlhttprequest-send
m.set:#dom-formdata-set
m.setRequestHeader:#dom-xmlhttprequest-setrequestheader
m.status:#dom-xmlhttprequest-status
m.statusText:#dom-xmlhttprequest-statustext
m.total:#dom-progressevent-total
m.upload:#dom-xmlhttprequest-upload
m.withCredentials:#dom-xmlhttprequest-withcredentials

mb.lengthComputable:#dom-progresseventinit-lengthcomputable
mb.loaded:#dom-progresseventinit-loaded
mb.total:#dom-progresseventinit-total

	l.#dom-xmlhttprequestresponsetype
l.arraybuffer:#dom-xmlhttprequestresponsetype-arraybuffer
l.blob:#dom-xmlhttprequestresponsetype-blob
l.document:#dom-xmlhttprequestresponsetype-document
l.json:#dom-xmlhttprequestresponsetype-json
l.text:#dom-xmlhttprequestresponsetype-text

et.abort:#event-xhr-abort
et.progress:#event-xhr-progress
et.error:#event-xhr-error
et.load:#event-xhr-load
et.loadend:#event-xhr-loadend
et.loadstart:#event-xhr-loadstart
et.readystatechange:#event-xhr-readystatechange
et.timeout:#event-xhr-timeout

e.progress:~HEforms#the-progress-element
h.Content-Type:~RFC7231#section-3.1.1.5

	XHR obj prop:
利用者~資格証:#user-credentials
要請~method:#request-method
要請~URL:#request-url
作者~要請~header~list:#author-request-headers
要請~本体:#request-body
同期~flag:#synchronous-flag
~upload完了-~flag:#upload-complete-flag
~upload~listener~flag:#upload-listener-flag
時間切れ~flag:#timed-out-flag
応答~obj:#response-object
応答:#response
要請:#request
受信済み~byte列:#received-bytes


応答~MIME型:#response-mime-type
上書き~MIME型:#override-mime-type
最終~MIME型:#final-mime-type
応答~charset:#response-charset
上書き~charset:#override-charset
最終~charset:#final-charset

~JSON応答:#json-response
~arraybuffer応答:#arraybuffer-response
~blob応答:#blob-response
文書~応答:#document-response
~text応答:#text-response

進捗~eventを発火する:#concept-event-fire-progress

~entry:#concept-formdata-entry
~entry~list:#concept-formdata-entry
fe.名前:#concept-formdata-entry-name
fe.値:#concept-formdata-entry-value
~entryを作成する:#create-an-entry

要請~error手続き:#request-error-steps
~errorを取扱う:#handle-errors
本体終端を取扱う:#handle-response-end-of-body

~upload~obj:#_concept-xmlhttprequest-upload-object
状態:#concept-xmlhttprequest-state
~send~flag:#send-flag

応答を処理する:~FETCH#process-response
要請の本体を処理する:~FETCH#process-request-body
要請の本体終端を処理する:~FETCH#process-request-end-of-body
読取器を取得-:~FETCH#concept-get-reader
すべての~byte列を読取る:~FETCH#concept-read-all-bytes-from-readablestream
~chunkを読取った:~FETCH#concept-read-chunk-from-readablestream
~CORS予行~要請:~FETCH#cors-preflight-request

~fetchを終了-:~FETCH#concept-fetch-terminate
~fetching:~FETCH#concept-fetch
抽出-:~FETCH#concept-bodyinit-extract
~MIME型を抽出-:~FETCH#concept-header-extract-mime-type
~method:~FETCH#concept-method
禁止~method:~FETCH#forbidden-method
禁止~header名:~FETCH#forbidden-header-name
名前:~FETCH#concept-header-name
値:~FETCH#concept-header-value
正規化-:~FETCH#concept-header-value-normalize
結合済みの値:~FETCH#concept-header-value-combined
~header:~FETCH#concept-header
~header~list:~FETCH#concept-header-list
付加-:~FETCH#concept-header-list-append
結合-:~FETCH#concept-header-list-combine
整列して結合-:~FETCH#concept-header-list-sort-and-combine
~network~error:~FETCH#concept-network-error

rq.要請:~FETCH#concept-request
rq.~header~list:~FETCH#concept-request-header-list
rq.本体:~FETCH#concept-request-body
rq.~method:~FETCH#concept-request-method
rq.~mode:~FETCH#concept-request-mode
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.生成元:~FETCH#concept-request-origin
rq.~referrer:~FETCH#concept-request-referrer
rq.url:~FETCH#concept-request-url
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.~client:~FETCH#concept-request-client
rq.行先:~FETCH#concept-request-destination
rq.同期~flag:~FETCH#synchronous-flag
rq.非安全~要請~flag:~FETCH#unsafe-request-flag
rq.正規化-:~FETCH#concept-method-normalize
rq.~CORS予行~利用~flag:~FETCH#use-cors-preflight-flag
rq.~done~flag:~FETCH#done-flag

rs.応答:~FETCH#concept-response
rs.url:~FETCH#concept-response-url
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.~status:~FETCH#concept-response-status
rs.~status~message:~FETCH#concept-response-status-message

名前に持つ~header:~FETCH#_headers-of-name
	#header-list-contains
~CORS~protocol:~FETCH#cors-protocol
~stream:~FETCH#concept-body-stream
伝送済み~byte数:~FETCH#concept-body-transmitted
総~byte数:~FETCH#concept-body-total-bytes
~errorした:~FETCH#concept-readablestream-errored

~byte文字大小無視:~INFRA#byte-case-insensitive

~event:~DOM4#concept-event
~event~listener:~DOM4#concept-event-listener
~eventを発火する:~DOM4#concept-event-fire
内容型:~DOM4#concept-document-content-type
~URL:~DOM4#concept-document-url
投出:~DOM4#concept-throw
配送-:~DOM4#concept-event-dispatch
符号化方式:~DOM4#concept-document-encoding
文書:~DOM4#concept-document
~HTML文書:~DOM4#html-document
doc.種別:~DOM4#concept-document-type
doc.生成元:~DOM4#concept-document-origin

符号化-:~ENCODING#encode
	encoder-error
~error:~ENCODING#error
復号-:~ENCODING#decode

~utf-8:~ENCODING#utf-8
~utf-8復号-:~ENCODING#utf-8-decode
~utf-8符号化-:~ENCODING#utf-8-encode

~Unicodeに変換-:~WEBIDL#dfn-obtain-unicode
	title="convert a DOMString to a sequence of Unicode characters"
反復される値ペア:~WEBIDL#dfn-value-pairs-to-iterate-over
~interface~obj:~WEBIDL#dfn-interface-object

~URLを直列化する:~URLSpec#concept-url-serializer
~URL構文解析する:~URLSpec#concept-url-parser
~host:~URLSpec#concept-url-host
~username:~URLSpec#concept-url-username
~password:~URLSpec#concept-url-password
	I.URL:~URLSpec#url
~URLの~usernameを設定する:~URLSpec#set-the-username
~URLの~passwordを設定する:~URLSpec#set-the-password


	HTML5

enV.生成元:~WAPI#concept-settings-object-origin
~task:~WAPI#concept-task
~task源:~WAPI#task-source
~task待行列:~WAPI#task-queue
~taskを待入する:~WAPI#queue-a-task
待入され:~WAPI#queue-a-task
~event~handler:~WAPI#event-handlers
~event~handler ~event型:~WAPI#event-handler-event-type
~network用~task源:~WAPI#networking-task-source
関連する設定群~obj:~WAPI#relevant-settings-object-for-a-global-object
担当の文書:~WAPI#responsible-document
~API基底~URL:~WAPI#api-base-url
~referrer~source:~WAPI#referrer-source
現在の大域~obj:~WAPI#current-global-object

全部的に作動中:~BROWSERS#fully-active
生成元:~ORIGIN#origin
同一生成元:~ORIGIN#same-origin

~form_data_setを構築-:~HTMLforms#constructing-form-data-set
並列的:~HTMLINFRA#in-parallel

妥当な~MIME型:~MIMESNIFF#valid-mime-type
構文解析できる~MIME型:~MIMESNIFF#parsable-mime-type
~MIME型~~成分:~MIMESNIFF#mime-type-portion

</script>


<!--%style -->
<style>
.critical {
    margin: 1em;
    border: thick double #F00;
    padding: 1em;
    background: none repeat scroll 0% 0% #FFC;
}

</style>

<style>
i {
	text-decoration: underline;
}
</style>

</head>

<body>

<!--%UI -->
<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">

<h1>XMLHttpRequest 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://www.whatwg.org/" >WHATWG</a>
による，副題の日付時点の
<a id="_SPEC_URL">XMLHttpRequest Standard</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-09-09</time>
（公開： <time>2012-10-25</time>）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>


<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBzdHJva2U9IiMzYzc5MGEiPgo8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIgc3Ryb2tlLXdpZHRoPSIxMCIgZmlsbD0iI2ZmZiIvPgo8cGF0aCBzdHJva2Utd2lkdGg9IjEuNSIgZmlsbD0ibm9uZSIgZD0iTTE3LDY2QzIxLDYzLDQzLDc2LDM3LDY4TTMzLDc1YTgsOCwwLDAsMTYsOE01MCw4NEM2OCw0OSw1Nyw5MCw2Myw3Nyw2Niw1OCw3NSw4Nyw3MSw2OSw2OCw2Miw3NCw2NSw3OCw2Nk02NSw2MkM1Nyw2NCw2NCw3MSw2Nyw2NE00Nyw2MEw0Myw2OSw0NCw2OSw1MSw2Nk01MCw1MkM0Nyw2MCw1Myw1NCw1Miw2MCw1MCw2OCw2Miw2MCw1Nyw2Miw1OCw1NCw2NSw2MCw1OSw1NCw0OCw0MiwyMCwyNSwyOSwzN00yOSw0MEMyMyw1MCwyNyw0NywyOSw0OE0zMywzN0MyOCw0MiwzNywzOCwzNSw0MiwzNCw0NCwzMCwzOCwzMiw0OCwzMSw1MCwzNiw1MiwyOCw1ME0zMiw1M0wyOCw1Mk0zMCw1M0MyOCw1NSwyNSw1NywzMCw2MSwzMiw2MiwzMiw2NSwzOCw2Miw0MCw2MSw0Myw2Myw0NCw1Nyw0NCw1Niw0OCw1Miw0NCw0OEw0NSw0NSw0MSw0Miw0MCw0Myw0MSw0NywzOSw1MCwzNSw1MU0zMiwzMUM0MywzMCw1MCwxNiw2NCwyM000MywzN0M1NCwyOCw0OSw1Niw2OSw0OCw4Miw0MCw3OCwyMSw2OCwyMEw2OCwyNkM3MiwyOSw3MiwyOSw3MiwzMyIvPgo8L3N2Zz4K"
></a>
	<hgroup>
<h1 id="title">XMLHttpRequest</h1>
<h2>Living Standard — 最終更新 2017 年 9 月 8 日</h2>
	</hgroup>
<dl>
	<dt>Participate:</dt>
	<dd><a href="https://github.com/whatwg/xhr">GitHub whatwg/xhr</a>
(<a href="https://github.com/whatwg/xhr/issues/new">file an issue</a>,
<a href="https://github.com/whatwg/xhr/issues">open issues</a>)</dd>
	<dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/xhr/commits">GitHub whatwg/xhr/commits</a></dd>
	<dd><a href="https://xhr.spec.whatwg.org/commit-snapshots/1a8f6910dfc1bf4edc46b23076380cf4cedeaca0/" id="commit-snapshot-link">Snapshot as of this commit</a></dd>
	<dd><a href="https://twitter.com/xhrstandard">@xhrstandard</a></dd>

	<dt id="xmlhttprequest-tests">Tests:</dt>
	<dd><a href="https://github.com/w3c/web-platform-tests/tree/master/XMLHttpRequest">web-platform-tests XMLHttpRequest/</a> (<a href="https://github.com/w3c/web-platform-tests/labels/xhr">ongoing work</a>)</dd>

	<dt>各国語翻訳（非規範的）</dt>
	<dd>日本語（このページ）</dd>

</dl>


</header>

<div id="MAIN" style="display:none;">



	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
XMLHttpRequest Standard は、~clientと~server間の~data転送のための，~client側の~script機能性を提供する~APIを定義する。
◎
The XMLHttpRequest Standard defines an API that provides scripted client functionality for transferring data between a client and a server.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
`XMLHttpRequest$I ~objは、`~fetching$（~~資源取得）のための~APIである。
◎
The XMLHttpRequest object is an API for fetching resources.
</p>

<p>
`XMLHttpRequest$I という名前は歴史的なものであり、
【 “XML” の部分は】
その機能性と何ら関わりは無い。
◎
The name XMLHttpRequest is historical and has no bearing on its functionality.
</p>

<div class="example" id="example-xhr">

<p>
~networkを通した~fetchで得られた XML 文書の~dataに対して何かを行う，簡単な~code：
◎
Some simple code to do something with data from an XML document fetched over the network:
</p>

<pre>
function processData(%data) {
  /* <span class="comment">
~dataを~~処理する
◎
taking care of data
</span> */
}

function handler() {
  if(this.status == 200 &amp;&amp;
    this.responseXML != null &amp;&amp;
    this.responseXML.getElementById('test').textContent) {
    /* <span class="comment">成功！◎success!</span> */
    processData(this.responseXML.getElementById('test').textContent);
  } else {
    /* <span class="comment">
何らかの不具合が生じている
◎
something went wrong
</span> */
    …
  }
}

var %client = new XMLHttpRequest();
%client.onload = handler;
%client.open("GET", "unicorn.xml");
%client.send();
</pre>

<p>
単に~serverに~messageを残す：
◎
If you just want to log a message to the server:
</p>

<pre>
function log(message) {
  var %client = new XMLHttpRequest();
  %client.open("POST", "/log");
  %client.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
  %client.send(message);
}
</pre>

<p>
あるいは、~serverにある文書の~statusを調べる：
◎
Or if you want to check the status of a document on the server:
</p>

<pre>
function fetchStatus(%address) {
  var %client = new XMLHttpRequest();
  %client.onload = function() {
    /* <span class="comment">
~network~errorが生じている場合の結果は信頼できないことがある。
◎
in case of network errors this might not give reliable results
</span> */
    returnStatus(this.status);
  }
  %client.open("HEAD", %address);
  %client.send();
}
</pre>

</div>


		<section id="specification-history">
<h3 title="Specification history">1.1. 仕様の歴史</h3>

<p>
`XMLHttpRequest$I ~objは、当初は WHATWG による， HTML の（何年も前の、 Microsoft による実装に基づく）成果として定義された。
それは 2006 年には W3C に移管された。
`XMLHttpRequest$I に対する拡張（すなわち、進捗~eventと非同一生成元（ cross-origin ）要請）は、 2011 年の終わりまでは別の草案（ XMLHttpRequest Level 2 ）の下で開発されていたが、その時点でこの 2 つの草案は `XMLHttpRequest$I に併合され，標準の観点から再び一つになった。
2012 年の終わりに，また WHATWG の下に移管されることとなった。
◎
The XMLHttpRequest object was initially defined as part of the WHATWG’s HTML effort. (Based on Microsoft’s implementation many years prior.) It moved to the W3C in 2006. Extensions (e.g. progress events and cross-origin requests) to XMLHttpRequest were developed in a separate draft (XMLHttpRequest Level 2) until end of 2011, at which point the two drafts were merged and XMLHttpRequest became a single entity again from a standards perspective. End of 2012 it moved back to the WHATWG.
</p>

<p>
現在の草案までに至る経緯は、次のメーリングリストにて見られる：
◎
Discussion that led to the current draft can be found in the following mailing list
archives:
</p>

<ul><li><a href="https://lists.w3.org/Archives/Public/public-whatwg-archive/">whatwg@whatwg.org</a>
</li><li><a href="https://lists.w3.org/Archives/Public/public-webapps/">public-webapps@w3.org</a>
</li><li><a href="https://lists.w3.org/Archives/Public/public-webapi/">public-webapi@w3.org</a>
</li><li><a href="https://lists.w3.org/Archives/Public/public-appformats/">public-appformats@w3.org</a>
</li></ul>



		</section>
	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>

<p>
明示的に “規定でない” と記された節に加え，この仕様~内のすべての 図式, 例, 注記は、規定ではない。
他のすべては規定である。
◎
All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
</p>

<p>
この仕様におけるキーワード：
「〜しなければ（〜しては）<em class="rfc2119">ならない</em>」 = “MUST (NOT)”,
「〜す<em class="rfc2119">べき</em>である（でない）」 = “SHOULD (NOT)”,
「〜しても<em class="rfc2119">よい</em>」 = “MAY”,
<!-- 
「<em class="rfc2119">要求される</em>」= REQUIRED,
「<em class="rfc2119" title="recommended">推奨される</em>」 = “RECOMMENDED”,
「<em class="rfc2119" title="optional">任意選択</em> 」 = “OPTIONAL”,
 -->
は、 RFC2119 に則って解釈されるものとする。
可読性のため、この仕様ではこれらの語が大文字~化されて出現することはない。
`RFC2119$r
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this specification are to be interpreted as described in RFC2119. For readability, these words do not appear in all uppercase letters in this specification. [RFC2119]
</p>

		<section id="extensibility">
<h3 title="Extensibility">2.1. 拡張性</h3>

<p>
~UA, Working Group, その他の関心のある主体には、新たな特色機能について， WHATWG ~communityの場で論を交わすことが<em>強く奨励される</em>。
◎
User agents, Working Groups, and other interested parties are strongly encouraged to discuss new features with the WHATWG community.
</p>

		</section>
	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p>
この仕様は、全体を通して，次に挙げる仕様による各種用語を利用し, リンク付きで引用する
⇒
`DOM$r
`DOMPS$r
`FETCH$r
`ENCODING$r
`FILEAPI$r
`HTML$r
`HTTP$r
`URL$r
`WEBIDL$r
`XML$r
`XMLNS$r
◎
This specification uses terminology, cross-linked throughout, from DOM, DOM Parsing and Serialization, Encoding, Fetch, File API, HTML, HTTP, URL, Web IDL, and XML.
◎
[DOM] [DOMPS] [ENCODING] [FETCH] [FILEAPI] [HTML] [HTTP] [URL] [WEBIDL] [XML] [XMLNS]
</p>

<p>
また、 `HTML$r と同じ typographic 規約を利用する。
◎
It uses the typographic conventions from HTML. [HTML]
</p>

<p>
この仕様の目的における語
`利用者~資格証@
は、~cookie, HTTP 認証, TLS ~client証明書を意味する。
特に、それは~proxy認証や `Origin^h ~headerを指すものではない。
`COOKIES$r
<!-- XXX ref? -->
◎
The term user credentials for the purposes of this specification means cookies, HTTP authentication, and TLS client certificates. Specifically it does not refer to proxy authentication or the Origin header. [COOKIES]
</p>

	</section>

	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
~backtick（ "<code>`</code>" ）で括られた~literalは、文字列ではなく，
<a href="~INFRA#byte-sequence">~byte列</a>を表現する。
</p>

	</section>
	<section id="interface-xmlhttprequest">
<h2 title="Interface XMLHttpRequest">4. ~interface `XMLHttpRequest^I</h2>

<pre class="idl">
[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequestEventTarget@I : `EventTarget$I {
  // <span class="comment"><a href="#event-handlers">~event~handler</a></span>
  attribute `EventHandler$I `onloadstart$m;
  attribute `EventHandler$I `onprogress$m;
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `onerror$m;
  attribute `EventHandler$I `onload$m;
  attribute `EventHandler$I `ontimeout$m;
  attribute `EventHandler$I `onloadend$m;
};

[`Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequestUpload@I : `XMLHttpRequestEventTarget$I {
};

enum `XMLHttpRequestResponseType@I {
  <dfn id="#dom-xmlhttprequestresponsetype">""</dfn>,
  `arraybuffer@l,
  `blob@l,
  `document@l,
  `json@l,
  `text@l
};

[<a href="#dom-xmlhttprequest">Constructor</a>,
 `Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequest@I : `XMLHttpRequestEventTarget$I {
  // <span class="comment"><a href="#event-handlers">~event~handler</a></span>
  attribute `EventHandler$I `onreadystatechange$m;

  // <span class="comment">`状態$</span>
  const ~US `UNSENT$m = 0;
  const ~US `OPENED$m = 1;
  const ~US `HEADERS_RECEIVED$m = 2;
  const ~US `LOADING$m = 3;
  const ~US `DONE$m = 4;
  ~RA ~US `readyState$m;

  // <span class="comment">`要請$</span>
  void `open$m(`ByteString$I %method, `USVString$I %url);
  void `~open_async$m(
      `ByteString$I %method,
      `USVString$I %url,
      boolean %async,
      optional `USVString$I? %username = null,
      optional `USVString$I? %password = null
  );
  void `setRequestHeader$m(`ByteString$I %name, `ByteString$I %value);
           attribute unsigned long `timeout$m;
           attribute boolean `withCredentials$m;
  [`SameObject$] ~RA `XMLHttpRequestUpload$I `upload$m;
  void `send$m(optional (`Document$I or `BodyInit$I)? %body = null);
  void `abort$m();

  // <span class="comment">`応答$</span>
  ~RA `USVString$I `responseURL$m;
  ~RA ~US `status$m;
  ~RA `ByteString$I `statusText$m;
  `ByteString$I? `getResponseHeader$m(`ByteString$I %name);
  `ByteString$I `getAllResponseHeaders$m();
  void `overrideMimeType$m(`DOMString$I %mime);
           attribute `XMLHttpRequestResponseType$I `responseType$m;
  ~RA any `response$m;
  ~RA `USVString$I `responseText$m;
  [`Exposed$=Window] ~RA `Document$I? `responseXML$m;
};
</pre>

<p>
各 `XMLHttpRequest$I ~objには、次のものが結付けられる：
◎
↓</p>

<dl class="def-list">
	<dt>`~upload~obj@</dt>
	<dd>
`XMLHttpRequestUpload$I ~obj
◎
An XMLHttpRequest object has an associated XMLHttpRequestUpload object.
</dd>
	<dd class="trans-note">【
この用語は、~~参照を明確化するために，この訳に導入したものである。
（原文では、単に “`XMLHttpRequestUpload^I ~obj”）
】</dd>

	<dt>`状態@</dt>
	<dd>
次のいずれか
⇒
`~unsent^i （初期~値）,
`~opened^i,
`~headers-received^i,
`~loading^i,
`~done^i
◎
An XMLHttpRequest object has an associated state, which is one of unsent, opened, headers received, loading, and done. Unless stated otherwise it is unsent.
</dd>

	<dt>`~send~flag@</dt>
	<dd>
他が定められない限り， ~OFF をとる。
◎
An XMLHttpRequest object has an associated send() flag. Unless stated otherwise it is unset.
</dd>

</dl>

		<section id="constructors">
<h3 title="Constructors">4.1. 構築子</h3>

<dl class="domintro">
	<dt>%client = new `XMLHttpRequest()$m</dt>
	<dd>
新たな `XMLHttpRequest$I ~objを返す。
◎
Returns a new XMLHttpRequest object.
</dd>

</dl>

<dl class="idl-def">
	<dt>`XMLHttpRequest()@m</dt>
	<dd>
この構築子は、新たな `XMLHttpRequest$I ~objを返さ~MUST。
◎
The XMLHttpRequest() constructor, when invoked, must return a new XMLHttpRequest object.
</dd>
</dl>

		</section>
		<section id="garbage-collection">
<h3 title="Garbage collection">4.2. ~garbage収集</h3>

<p>
`XMLHttpRequest$I ~objは、その［［
`状態$ ~EQ `~opened^i, かつ
`~send~flag$ ~EQ ~ON
］, または［
`状態$ ~EQ `~headers-received^i
］, または［
`状態$ ~EQ `~loading^i
］］, かつ†［
<b>type</b> ~IN {
`readystatechange$et,
`progress$et,
`abort$et,
`error$et,
`load$et,
`timeout$et,
`loadend$et
} なる`~event~listener$が登録されている
］ときは、~garbage収集されては~MUST_NOT。
【† “［［ `状態$ ~EQ `~loading^i ］, かつ［ type ~IN 〜 ］］” かも？】
◎
An XMLHttpRequest object must not be garbage collected if its state is either opened with the send() flag set, headers received, or loading, and it has one or more event listeners registered whose type is one of readystatechange, progress, abort, error, load, timeout, and loadend.
</p>

<p>
`XMLHttpRequest$I ~objが，その接続がまだ開いているにも関わらず~garbage収集された場合、~UAは，~objにより演算されている進行中の`~fetchを終了-$させ~MUST。
◎
If an XMLHttpRequest object is garbage collected while its connection is still open, the user agent must terminate the ongoing fetch operated by the XMLHttpRequest object. 
</p>

		</section>
		<section id="event-handlers">
<h3 title="Event handlers">4.3. ~event~handler</h3>

<p>
`XMLHttpRequestEventTarget$I を継承する~interfaceを実装する~objは、次の`~event~handler$（およびそれらに対応する`~event~handler ~event型$）を属性として~supportし~MUST。
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported on objects implementing an interface that inherits from XMLHttpRequestEventTarget as attributes:
</p>

<table>

<thead><tr><th>`~event~handler$◎event handler
<th>`~event~handler ~event型$◎event handler event type
</thead>

<tbody><tr><td>`onloadstart@m
<td>`loadstart$et

<tr><td>`onprogress@m
<td>`progress$et

<tr><td>`onabort@m
<td>`abort$et

<tr><td>`onerror@m
<td>`error$et

<tr><td>`onload@m
<td>`load$et

<tr><td>`ontimeout@m
<td>`timeout$et

<tr><td>`onloadend@m
<td>`loadend$et

</tbody></table>


<p>
`XMLHttpRequest$I ~objにおいては、次の`~event~handler$（および対応する
`~event~handler ~event型$）も属性として~supportし~MUST：
◎
The following is the event handler (and its corresponding event handler event type) that must be supported as attribute solely by the XMLHttpRequest object:
</p>

<table><thead>
<tr><th>`~event~handler$◎event handler
<th>`~event~handler ~event型$◎event handler event type
</thead>

<tbody><tr><td>`onreadystatechange@m
<td>`readystatechange$et

</tbody></table>


		</section>
		<section id="states">
<h3 title="States">4.4. 状態</h3>

<dl class="domintro">
	<dt>%client . `readyState$m</dt>
	<dd>
`状態$を返す。
◎
Returns client’s state.
</dd>
</dl>

<dl class="idl-def">
	<dt>`readyState@m</dt>
	<dd>
<p>
取得子は、此れの`状態$が下の表の 1 列目のいずれであるかに応じて，同じ行の 2 列目に示される値を返さ~MUST：
◎
The readyState attribute’s getter must return the value from the table below in the cell of the second column, from the row where the value in the cell in the first column is context object’s state:
</p>

<table>
<thead><tr><th>`状態$
<th>値（数値）
<th>~~説明
</thead>

<tbody><tr><td>`~unsent^i
<td>`UNSENT@m （ 0 ）
<td>
~objは構築-済みである。
◎
The object has been constructed.

<tr><td>`~opened^i
<td>`OPENED@m （ 1 ）
<td>
`open$m ~methは成功裡に呼出された。
この状態~下では、
`setRequestHeader$m を用いて要請~headerを設定することができ，
`send$m ~methを用いて~fetchを起動させられる。
◎
The open() method has been successfully invoked. During this state request headers can be set using setRequestHeader() and the fetch can be initiated using the send() method.

<tr><td>`~headers-received^i
<td>`HEADERS_RECEIVED@m （ 2 ）
<td>
すべての~redirect（もしあれば）は追跡~済みであり，かつ
`応答$のすべての HTTP ~headerは受信-済みである。
◎
All redirects (if any) have been followed and all HTTP headers of the response have been received.

<tr><td>`~loading^i
<td>`LOADING@m （ 3 ）
<td>
`応答$の`本体$rsの受信-中にある。
◎
The response’s body is being received.

<tr><td>`~done^i
<td>`DONE@m （ 4 ）
<td>
~data転送が完了しているか, または転送~中に何らかの不具合が生じた（例えば，際限のない~redirect）。
◎
The data transfer has been completed or something went wrong during the transfer (e.g. infinite redirects).

</tbody></table>

	</dd>
</dl>

		</section>
		<section id="request">
<h3 title="Request">4.5. 要請</h3>

<div>

<p>
各 `XMLHttpRequest$I ~objの要請には、次の概念が結付けられる（括弧内は初期~値）：
</p>

<ul ><li>`要請~method@<!-- FETCH.concept-method -->
</li><li>`要請~URL@<!-- .concept-url？ -->
</li><li>`~header~list$である，`作者~要請~header~list@（空）
</li><li>`要請~本体@（ ~NULL ）
</li><li>`同期~flag@（ ~OFF ）
</li><li>`~upload完了-~flag@（ ~OFF ）
</li><li>`~upload~listener~flag@（ ~OFF ）
</li><li>`時間切れ~flag@（ ~OFF ）
</li></ul>

◎
Each XMLHttpRequest object has the following request-associated concepts: request method, request URL, author request headers, request body, synchronous flag, upload complete flag, upload listener flag, and timed out flag. 
◎
The author request headers is an initially empty header list.
◎
The request body is initially null.
◎
The synchronous flag, upload complete flag, upload listener flag and timed out flag are initially unset.
</div>

<p class="note" id="event-listeners-and-preflight">注記：
`XMLHttpRequestUpload$I ~obj上に 1 個~以上の~event~listenerを登録すると，`~CORS予行~要請$が発行されることになる。
（~event~listenerが登録されると`~upload~listener~flag$は ~ON になり，それにより`~CORS予行~利用~flag$rqも ~ON になるので。）
◎
Registering one or more event listeners on an XMLHttpRequestUpload object will result in a CORS-preflight request. (That is because registering an event listener causes the upload listener flag to be set, which in turn causes the use-CORS-preflight flag to be set.)
</p>

			<section id="the-open()-method">
<h4 title="The open() method">4.5.1. `open()^m ~meth</h4>

<dl class="domintro">
	<dt>%client . `open$m(%method, %url [, %async = true [, %username = null [, %password = null]]])</dt>
	<dd>
`要請~method$, `要請~URL$, `同期~flag$
を設定する。
◎
Sets the request method, request URL, and synchronous flag.
</dd>
	<dd>
%method が妥当な HTTP ~methodでない，あるいは %url を構文解析できない場合、 `SyntaxError^E 例外が投出される。
◎
Throws a SyntaxError exception if either method is not a valid HTTP method or url cannot be parsed.
</dd>
	<dd>
%method が
`CONNECT^h, `TRACE^h, `TRACK^h
のいずれかに文字大小無視で合致する場合、 `SecurityError^E 例外が投出される。
◎
Throws a SecurityError exception if method is a case-insensitive match for `CONNECT`, `TRACE` or `TRACK`.
</dd>
	<dd>
<p>
次がいずれも満たされる場合、 `InvalidAccessError^E 例外が投出される：
</p>

<ul ><li>%async ~EQ ~F
</li><li>`現在の大域~obj$は `Window$I ~objである
</li><li>［
`timeout$m 属性 ~NEQ 0
］~OR［
`responseType$m 属性 ~NEQ 空~文字列
］
</li></ul>

◎
Throws an InvalidAccessError exception if async is false, current global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.
</dd>

</dl>

<p class="critical" id="sync-warning">
~worker以外での同期的 `XMLHttpRequest$I は、末端利用者をひどく待たせることになりかねないので， Web ~platformから除去されつつある過程にある（何年もかかるであろう）。
開発者は、［
`現在の大域~obj$は `Window$I ~objである
］場合には， %async 引数に ~F を渡しては~MUST_NOT。
~UA には、開発者~用~toolにおいて，その種の用法に対し警告することが強く奨励される
— 
それが生じたときに，
`InvalidAccessError^E 例外を`投出$するように、試験的に実装してもよい。
◎
Synchronous XMLHttpRequest outside of workers is in the process of being removed from the web platform as it has detrimental effects to the end user’s experience. (This is a long process that takes many years.) Developers must not pass false for the async argument when current global object is a Window object. User agents are strongly encouraged to warn about such usage in developer tools and may experiment with throwing an InvalidAccessError exception when it occurs.
</p>

<p class="idl-def">
`open(method, url)@m
／
`~open_async(method, url, async, username, password)@m
~methの被呼出時には、次を走らせ~MUST：
◎
The open(method, url) and open(method, url, async, username, password) methods, when invoked, must run these steps: 
</p>

<ol>
	<li>
~IF［
此れに`関連する設定群~obj$は `担当の文書$を持っていて，それは`全部的に作動中$ではない
］
⇒
~THROW `InvalidStateError^E
◎
If context object’s relevant settings object has a responsible document and it is not fully active, throw an InvalidStateError exception.
</li>
	<li>
~IF［
%method は`~method$でない
］
⇒
~THROW `SyntaxError^E
◎
If method is not a method, throw a SyntaxError exception.
</li>
	<li>
~IF［
%method は`禁止~method$である
］
⇒
~THROW `SecurityError^E
◎
If method is a forbidden method, throw a SecurityError exception.
</li>
	<li>
%method を`正規化-$rqする
◎
Normalize method.
</li>
	<li>
%解析済み~URL ~LET `~URL構文解析する$( %url, 此れに`関連する設定群~obj$の`~API基底~URL$ )
◎
Let parsedURL be the result of parsing url with context object’s relevant settings object’s API base URL.
</li>
	<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError^E
◎
If parsedURL is failure, throw a SyntaxError exception.
</li>
	<li>
<p>
~IF［
%async 引数は省略されている
］
⇒
( %async, %username, %password ) ~SET ( true, ~NULL, ~NULL )
◎
If the async argument is omitted, set async to true, and set username and password to null.
</p>

<p class="note">注記：
あいにく，旧来~内容と~~互換性をとるため、 %async 引数に `undefined^c が渡された場合と省略された場合とを，同じに扱うわけにはいかない。
◎
Unfortunately legacy content prevents treating the async argument being undefined identical from it being omitted.
</p>
	</li>
	<li>
<p>
~IF［
%解析済み~URL の`~host$ ~NEQ ~NULL
］：
◎
If parsedURL’s host is non-null, run these substeps: 
</p>
		<ol>
			<li>
~IF［
%username ~NEQ ~NULL
］
⇒
`~URLの~usernameを設定する$( %解析済み~URL, %username )
◎
If the username argument is not null, set the username given parsedURL and username.
</li>
			<li>
~IF［
%password ~NEQ ~NULL
］
⇒
`~URLの~passwordを設定する$( %解析済み~URL, %password )
◎
If the password argument is not null, set the password given parsedURL and password.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次がいずれも満たされる
］…：
</p>

<ul ><li>%async ~EQ ~F
</li><li>`現在の大域~obj$は `Window$I ~objである
</li><li>［
`timeout$m 属性 ~NEQ 0
］~OR［
`responseType$m 属性 ~NEQ 空~文字列
］
</li></ul>

<p>
…ならば
⇒
~THROW `InvalidAccessError^E
</p>

◎
If async is false, current global object is a Window object, and the timeout attribute value is not zero or the responseType attribute value is not the empty string, then throw an InvalidAccessError exception.
</li>
			<li>
<p>
此れが演算している進行中の`~fetchを終了-$させる
◎
Terminate the ongoing fetch operated by the XMLHttpRequest object. 
</p>

<p class="note">注記：
この時点から，`~fetching$を進行させられるようになる。
◎
A fetch can be ongoing at this point.
</p>
			</li>
			<li>
<p>
此れに結付けられている各種~変数を次の様に設定する：
◎
Set variables associated with the object as follows:
</p>

				<ul>
					<li>
`~send~flag$ ~SET ~OFF
◎
Unset the send() flag and upload listener flag.
</li>
					<li>
`~upload~listener~flag$ ~SET ~OFF
◎
↑</li>
					<li>
`要請~method$ ~SET %method
◎
Set request method to method.
</li>
					<li>
`要請~URL$ ~SET %解析済み~URL
◎
Set request URL to parsedURL.
</li>
					<li>
`同期~flag$ ~SET ［
%async ~EQ ~F ならば ~ON ／
~ELSE_ ~OFF
］
◎
Set the synchronous flag, if async is false, and unset the synchronous flag otherwise.
</li>
					<li>
`作者~要請~header~list$を空にする
◎
Empty author request headers.
</li>
					<li>
`応答$ ~SET `~network~error$
◎
Set response to a network error.
</li>
					<li>
`受信済み~byte列$ ~SET 空~byte列
◎
Set received bytes to the empty byte sequence.
</li>
					<li>
`応答~obj$ ~SET ~NULL
◎
Set response object to null.
</li>
				</ul>
			</li>
			<li>
<p>
~IF［
此れの`状態$ ~NEQ `~opened^i
］：
◎
If the state is not opened, run these substeps:
</p>

				<ol>
					<li>
此れの`状態$ ~SET `~opened^i
◎
Set state to opened.
</li>
					<li>
此れに向けて，名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange.
</li>
				</ol>
			</li>
		</ol>

<p>
◎
The reason there are two open() methods defined is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</p>

			</section>
			<section id="the-setrequestheader()-method">
<h4 title="The setRequestHeader() method">4.5.2. `setRequestHeader()^m ~meth</h4>

<dl class="domintro">
	<dt>%client . `setRequestHeader(name, value)$m</dt>
	<dd>
<p>
`作者~要請~header~list$の中で，所与の %name の`~header$に %value を結合する
◎
Combines a header in author request headers.
</dd>
	<dd>
`状態$ ~NEQ `~opened^i, または
`~send~flag$ ~EQ ~ON
の場合、 `InvalidStateError^E 例外が投出される。
◎
Throws an InvalidStateError exception if either state is not opened or the send() flag is set.
</dd>
	<dd>
%name が~header名でなかったり,
%value が~header値でなかった場合、
`SyntaxError^E 例外が投出される。
◎
Throws a SyntaxError exception if name is not a header name or if value is not a header value.
</dd>
</dl>

<p class="note">注記：
下の~algoにて指示されるように、一部の~headerは，設定し得ない。
それらの設定-は~UAに委ねられる。
加えて、 `send$m ~meth節の最後に示されている様に，作者から設定されなかった他の一部の~headerについても、~UA の制御~下に置かれることになる。
◎
As indicated in the algorithm below certain headers cannot be set and are left up to the user agent. In addition there are certain other headers the user agent will take control of if they are not set by the author as indicated at the end of the send() method section.
</p>

<dl class="idl-def">
	<dt>`setRequestHeader(name, value)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The setRequestHeader(name, value) method must run these steps:
</p>

		<ol>
			<li>
~IF［
`状態$ ~NEQ `~opened^i
］
⇒
~THROW `InvalidStateError^E
◎
If state is not opened, throw an InvalidStateError exception.
</li>
			<li>
~IF［
`~send~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidStateError^E
◎
If the send() flag is set, throw an InvalidStateError exception.
</li>
			<li>
%value ~SET %value を`正規化-$した結果
◎
Normalize value.
</li>
			<li>
<p>
~IF［
%name は`名前$でない
］~OR［
%value は`値$でない
］
⇒
~THROW `SyntaxError^E
◎
If name is not a name or value is not a value, throw a SyntaxError exception.
</p>

<p class="note">注記：
空~byte列は空の`~header$ `値$を表現する。
◎
An empty byte sequence represents an empty header value.
</p>
	</li>
			<li>
~IF［
%name は`禁止~header名$である
］
⇒
~RET
◎
Terminate these steps if name is a forbidden header name.
</li>
			<li>
`作者~要請~header~list$の中で，
( %name / %value )
を`結合-$する
◎
Combine name/value in author request headers.
</li>
		</ol>
	</dd>
</dl>

<div class="example" id="example-setting-header-twice">

<p>
同じ~headerを重複して設定した場合の~~動作を示すための，単純な~code。
次の~script：
◎
Some simple code demonstrating what happens when setting the same header twice:
◎
// The following script:
</p>

<pre>
var %client = new XMLHttpRequest();
%client.open('GET', 'demo.cgi');
%client.setRequestHeader('X-Test', 'one');
%client.setRequestHeader('X-Test', 'two');
%client.send();
</pre>

<p>
による結果、次の~headerが送信される：
◎
// …results in the following header being sent:
</p>

<pre>
X-Test: one, two
</pre>
</div>

			</section>
			<section id="the-timeout-attribute">
<h4 title="The timeout attribute">4.5.3. `timeout^m 属性</h4>

<dl class="domintro">
	<dt>%client . `timeout$m</dt>
	<dd>
時間を~milli秒~単位で設定できる。
0 でない値に設定された場合、所与の時間が経過した時点で，`~fetching$は終了させられる。
その時点で要請がまだ完了していない場合、`同期~flag$が ~OFF の下では，
`timeout$et ~eventが`配送-$され、他の場合（ ~ON の下での `send()$m ~methに対しては），
`TimeoutError^E 例外が`投出$されることになる。
◎
Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the request has not yet completed, and the synchronous flag is unset, a timeout event will then be dispatched, or a TimeoutError exception will be thrown otherwise (for the send() method).
</dd>
	<dd>
設定子は、［
`同期~flag$ ~EQ ~ON
］, かつ［
`現在の大域~obj$は `Window$I ~objである
］ならば，
`InvalidAccessError^E 例外が投出される。
◎
When set: throws an InvalidAccessError exception if the synchronous flag is set and current global object is a Window object.
</dd>
</dl>

<dl class="idl-def">
	<dt>`timeout@m</dt>
	<dd>
取得子は、最後に設定された値を返さ~MUST。
初期~時には 0 に設定され~MUST。
◎
The timeout attribute must return its value. Initially its value must be zero.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
Setting the timeout attribute must run these steps:
</p>

		<ol>
			<li>
~IF［
`現在の大域~obj$は `Window$I ~objである
］~AND［
`同期~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidAccessError^E
◎
If current global object is a Window object and the synchronous flag is set, throw an InvalidAccessError exception.
</li>
			<li>
この属性の値 ~SET 新たな値
◎
Set its value to the new value.
</li>
		</ol>

<p class="note">注記：
これにより，`~fetching$が進捗~中にある間でも、 `timeout$m 属性を設定-可能になる。
設定しても、計測の起点（ `~fetching$が開始された時点）が改められることはない。
◎
This implies that the timeout attribute can be set while fetching is in progress. If that occurs it will still be measured relative to the start of fetching.
</p>
	</dd>
</dl>

			</section>
			<section id="the-withcredentials-attribute">
<h4 title="The withCredentials attribute">4.5.4. `withCredentials^m 属性</h4>

<dl class="domintro">
	<dt>%client . `withCredentials$m</dt>
	<dd>
`利用者~資格証$が、非同一生成元~要請に含められることになるときは ~T。
非同一生成元~要請から除外され, その応答における~cookieが無視されることになるときは ~F。
初期~時は ~F 。
◎
True when user credentials are to be included in a cross-origin request. False when they are to be excluded in a cross-origin request and when cookies are to be ignored in its response. Initially false.
</dd>
	<dd>
設定子は、`状態$が `~unsent^i でも `~opened^i でもない, または
`~send~flag$ ~EQ ~ON
ならば， `InvalidStateError^E 例外が投出される。
◎
When set: throws an InvalidStateError exception if state is not unsent or opened, or if the send() flag is set.
</dd>
</dl>

<dl class="idl-def">
	<dt>`withCredentials@m</dt>
	<dd>
取得子は、最後に設定された値を返さ~MUST。
初期~時には ~F に設定され~MUST。
◎
The withCredentials attribute must return its value. Initially its value must be false.
</dd>
	<dd>
<p>
設定子は、次を走らせ~MUST：
◎
Setting the withCredentials attribute must run these steps:
</p>

		<ol>
			<li>
~IF［
`状態$ ~NIN
{ `~unsent^i, `~opened^i }
］
⇒
~THROW `InvalidStateError^E
◎
If state is not unsent or opened, throw an InvalidStateError exception.
</li>
			<li>
~IF［
`~send~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidStateError^E
◎
If the send() flag is set, throw an InvalidStateError exception.
</li>
			<li>
この属性の値 ~SET 所与の値
◎
Set the withCredentials attribute’s value to the given value.
</li>
		</ol>
	</dd>
</dl>

<p class="note">注記：
`withCredentials$m 属性は、`同一生成元$の`~fetching$においては、何の効果もない。
◎
The withCredentials attribute has no effect when fetching same-origin resources.
</p>


			</section>
			<section id="the-upload-attribute">
<h4 title="The upload attribute">4.5.5. `upload^m 属性</h4>

<dl class="domintro">
	<dt>%client . `upload$m</dt>
	<dd>
結付けられている `XMLHttpRequestUpload$I ~objを返す。
~dataが~serverへ向けて転送されている間の伝送~情報の~~収集に，これを利用できる。
◎
Returns the associated XMLHttpRequestUpload object. It can be used to gather transmission information when data is transferred to a server.
</dd>

</dl>

<dl class="idl-def">
	<dt>`upload@m</dt>
	<dd>
取得子は、此れの`~upload~obj$を返さ~MUST。
◎
The upload attribute must return the associated XMLHttpRequestUpload object.
◎
As indicated earlier, each XMLHttpRequest object has an associated XMLHttpRequestUpload object.
</dd>
</dl>

			</section>
			<section id="the-send()-method">
<h4 title="The send() method">4.5.6. `send()^m ~meth</h4>

<dl class="domintro">
	<dt>%client . `send$m([%body = null])</dt>
	<dd>
要請を起動させる。
引数（省略可）は`要請~本体$を与える。
`要請~method$が `GET^c や `HEAD^c の場合、この引数は無視される。
◎
Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD.
</dd>
	<dd>
`状態$ ~NEQ `~opened^i, または
`~send~flag$ ~EQ ~ON
の場合、 `InvalidStateError^E 例外が投出される。
◎
Throws an InvalidStateError exception if either state is not opened or the send() flag is set.
</dd>
</dl>


<p class="idl-def">
`send(body)@m
~methの被呼出時には、次を走らせ~MUST：
◎
The send(body) method must run these steps:
</p>

<ol>
	<li>
~IF［
`状態$ ~NEQ `~opened^i
］
⇒
~THROW `InvalidStateError^E
◎
If state is not opened, throw an InvalidStateError exception.
</li>
	<li><!-- copy -->
~IF［
`~send~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidStateError^E
◎
If the send() flag is set, throw an InvalidStateError exception.
</li>
	<li>
~IF［
`要請~method$ ~IN
{ `GET^c, `HEAD^c }
］
⇒
%body ~SET ~NULL
◎
If the request method is GET or HEAD, set body to null.
</li>
	<li>
<p>
~IF［
%body ~NEQ ~NULL
］：
◎
If body is null, go to the next step.
</p>
		<ol>
			<li>
( %符号化方式, %~MIME型 ) ~LET ( ~NULL, ~NULL )
◎
Otherwise, let encoding and mimeType be null, and then follow these rules, switching on body:
</li>
			<li>
<p>
%body に応じて：
◎
↑</p>

				<dl class="switch">
					<dt id="dom-xmlhttprequest-send-document">`Document$I</dt>
					<dd>

						<ol>
							<li>
%符号化方式 ~SET `UTF-8^lb
◎
Set encoding to `UTF-8`.
</li>
							<li>
%~MIME型 ~SET ［
%body は`~HTML文書$であるならば `text/html^lb ／
~ELSE_ `application/xml^lb
］ 
◎
Set mimeType to `text/html` if body is an HTML document, and to `application/xml` otherwise. Then append `;charset=UTF-8` to mimeType. 
</li>
							<li>
%~MIME型 に `;charset=UTF-8^lb を付加する
◎
↑</li>
							<li>
`要請~本体$ ~SET ［［
%body を
<a href="~DOM-Parsing#dfn-fragment-serializing-algorithm">直列化-</a>した結果
］を`~Unicodeに変換-$した結果
］を`~utf-8符号化-$した結果
◎
Set request body to body, serialized, converted to Unicode, and utf-8 encoded.
</li>
						</ol>
					</dd>

					<dt id="dom-xmlhttprequest-send-bodyinit">`BodyInit$I</dt>
					<dd>
						<ol>
							<li>
~IF［
%body は文字列である
］
⇒
%符号化方式 ~SET `UTF-8^lb
◎
If body is a string, set encoding to `UTF-8`.
</li>
							<li>
( `要請~本体$, %~MIME型 ) ~SET %body を`抽出-$した結果
◎
Set request body and mimeType to the result of extracting body.
</li>
						</ol>
					</dd>
				</dl>
			</li>
			<li>
%ContentType ~LET `作者~要請~header~list$内に `Content-Type$h を`名前に持つ~header$は［
あるならば それ ／
なければ ε
］
◎
↓</li>
			<li>
~IF［
%ContentType ~EQ ε
］
⇒
~IF［
%~MIME型 ~NEQ ~NULL
］
⇒
`作者~要請~header~list$に
( `Content-Type$h / %~MIME型 )
を`付加-$する
◎
If mimeType is non-null and author request headers does not contain `Content-Type`, then append `Content-Type`/mimeType to author request headers. 
</li>
			<li>
~ELIF［
%ContentType の`値$は `妥当な~MIME型$である
］~AND［
%符号化方式 ~NEQ ~NULL
］
⇒
［
%ContentType の`値$の中の `charset^lb ~parameterのうち，
%符号化方式 に`~byte文字大小無視$で合致しないもの
］すべてを %符号化方式 に~~置換する
◎
Otherwise, if the header whose name is a byte-case-insensitive match for `Content-Type` in author request headers has a value that is a valid MIME type, which has a `charset` parameter whose value is not a byte-case-insensitive match for encoding, and encoding is not null, then set all the `charset` parameters whose value is not a byte-case-insensitive match for encoding of that header’s value to encoding.
</li>
		</ol>
	</li>
	<li>
~IF［
此れの`~upload~obj$に登録されている~event~listenerがある
］
⇒
`~upload~listener~flag$ ~SET ~ON
◎
If one or more event listeners are registered on the associated XMLHttpRequestUpload object, then set upload listener flag.
</li>
	<li>
<p>
%要請 ~LET 次の様に初期化された新たな`要請$rq：
◎
Let req be a new request, initialized as follows:
</p>

		<dl class="leaf-parent">

			<dt>`~method$rq◎method</dt>
			<dd>
`要請~method$
◎
request method
</dd>

			<dt>`url$rq◎url</dt>
			<dd>
`要請~URL$
◎
request URL
</dd>

			<dt>`~header~list$rq◎header list</dt>
			<dd>
`作者~要請~header~list$
◎
author request headers
</dd>

			<dt>`非安全~要請~flag$rq◎unsafe-request flag</dt>
			<dd>
~ON
◎
Set.
</dd>

			<dt>`本体$rq◎body</dt>
			<dd>
`要請~本体$
◎
request body
</dd>

			<dt>`~client$rq◎client</dt>
			<dd>
此れに`関連する設定群~obj$
◎
context object’s relevant settings object
</dd>

			<dt>`同期~flag$rq◎synchronous flag</dt>
			<dd>
`同期~flag$ ~EQ ~ON ならば ~ON ／
~ELSE_ ~OFF
◎
Set if the synchronous flag is set.
</dd>

			<dt>`~mode$rq◎mode</dt>
			<dd>
`cors^l
◎
"cors"
</dd>
			<dt>`~CORS予行~利用~flag$rq◎use-CORS-preflight flag</dt>
			<dd>
`~upload~listener~flag$ ~EQ ~ON ならば ~ON ／
~ELSE_ ~OFF
◎
Set if upload listener flag is set.
</dd>


			<dt>`資格証~mode$rq◎credentials mode</dt>
			<dd>
`withCredentials$m 属性 ~EQ ~T
ならば `include^l ／
~ELSE_ `same-origin^l
◎
If the withCredentials attribute value is true, "include", and "same-origin" otherwise.
</dd>

			<dt>`~URL資格証~利用~flag$rq◎use-URL-credentials flag</dt>
			<dd>
［
`要請~URL$の`~username$ ~NEQ 空~文字列
］~OR［
`要請~URL$の`~password$ ~NEQ 空~文字列†
］ならば ~ON ／
~ELSE_ ~OFF
◎
Set if either request URL’s username is not the empty string or request URL’s password is non-null.
</dd>
			<dd class="trans-note">【†
原文は ~NULL だが、更新漏れと見受けられる。
】</dd>
		</dl>
	</li>
	<li>
`~upload完了-~flag$ ~SET %要請 の`本体$rqに応じて
⇒
~NULL ならば ~ON ／
~ELSE_ ~OFF
◎
Unset the upload complete flag.
◎
Unset the timed out flag.
◎
If req’s body is null, set the upload complete flag.
</li>
	<li>
`時間切れ~flag$ ~SET ~OFF
◎
↑</li>
	<li>
`~send~flag$ ~SET ~ON
◎
Set the send() flag.
</li>
	<li>
<p>
~IF［
`同期~flag$ ~EQ ~OFF
］：
◎
If the synchronous flag is unset, run these substeps:
</p>

		<ol>
			<li>
( 0, 0 )
を与える下で，名前 `loadstart$et の`進捗~eventを発火する$
◎
Fire a progress event named loadstart with 0 and 0.
</li>
			<li>
~IF［
`~upload完了-~flag$ ~EQ ~OFF
］~AND［
`~upload~listener~flag$ ~EQ ~ON
］
⇒
( 0, %要請 の`本体$rqの`総~byte数$ )
を与える下で，
`~upload~obj$に向けて，名前 `loadstart$et の`進捗~eventを発火する$
◎
If the upload complete flag is unset and upload listener flag is set, then fire a progress event named loadstart on the XMLHttpRequestUpload object with 0 and req’s body’s total bytes.
</li>
			<li>
~IF［
`状態$ ~NEQ `~opened^i
］~OR［
`~send~flag$ ~EQ ~OFF
］
⇒
~RET
◎
If state is not opened or the send() flag is unset, then return.
</li>
			<li>
<p>
%要請 を用いて`~fetching$に取り掛かる
—
以下に従って，`~network用~task源$から`待入され$た`~task$を取扱う
◎
Fetch req. Handle the tasks queued on the networking task source per below.
</p>

<p>
次の下位手続きを`並列的$に走らす：
◎
Run these subsubsteps in parallel:
</p>

				<ol>
					<li>
<p>
次のいずれかが満たされるまで待機する：
◎
↓</p>
						<ul>
							<li>
%要請 の`~done~flag$rq ~EQ ~ON
◎
Wait until either req’s done flag is set or
</li>
							<li>
この下位手続きを開始してから経過した秒数 ~GT `timeout$m 属性~値 ~GT 0
◎
the timeout attribute value number of milliseconds has passed since these subsubsteps started
◎
while timeout attribute value is not zero.
</li>
						</ul>
					</li>
					<li>
<p>
~IF［
%要請 の`~done~flag$rq ~EQ ~OFF
］：
</p>
<ol><li>`時間切れ~flag$ ~SET ~ON
</li><li>この`~fetchを終了-$させる
</li></ol>
◎
If req’s done flag is unset, then set the timed out flag and terminate fetching.
</li>
				</ol>


<p>
【以下に定義される各種 下位手続き（ “〜を処理する” ）は、`~fetching$の中で待入される~taskになる（これらは，非同期的に呼出される callback である）。】
</p>


<p class="algo-head">
%要請 に対し，`要請の本体を処理する$ときは、次の下位手続きを走らす：
◎
To process request body for request, run these subsubsteps:
</p>

<ol>
	<li>
~IF［
この手続きが最後に呼出されたときから，まだ およそ 50ms 以上 経過していない
］
⇒
~RET
◎
If not roughly 50ms have passed since these subsubsteps were last invoked, terminate these subsubsteps.
</li>
	<li>
~IF［
`~upload~listener~flag$ ~EQ ~ON
］
⇒
%要請 の`本体$rqの
( `伝送済み~byte数$, `総~byte数$ )
を与える下で，
`~upload~obj$に向けて，名前 `progress$et の`進捗~eventを発火する$。
◎
If upload listener flag is set, then fire a progress event named progress on the XMLHttpRequestUpload object with request’s body’s transmitted bytes and request’s body’s total bytes.
</li>
</ol>

<p class="note">注記：
この下位手続きは、新たな~byteが伝送されたときに限り，呼出される。
◎
These subsubsteps are only invoked when new bytes are transmitted.
</p>

<p class="algo-head">
%要請 に対し，`要請の本体終端を処理する$ときは、次の下位手続きを走らす：
◎
To process request end-of-body for request, run these subsubsteps:
</p>

				<ol>
					<li>
`~upload完了-~flag$ ~SET ~ON
◎
Set the upload complete flag.
</li>
					<li>
~IF［
`~upload~listener~flag$ ~EQ ~ON
］
⇒
~RET
◎
If upload listener flag is unset, then terminate these subsubsteps.
</li>
					<li>
%伝送量 ~LET
%要請 の`本体$rqの`伝送済み~byte数$ 
◎
Let transmitted be request’s body’s transmitted bytes.
</li>
					<li>
%長さ ~LET
%要請 の`本体$rqの`総~byte数$
◎
Let length be request’s body’s total bytes.
</li>
					<li>
( %伝送量, %長さ )
を与える下で，
`~upload~obj$に向けて，名前 `progress$et の`進捗~eventを発火する$
◎
Fire a progress event named progress on the XMLHttpRequestUpload object with transmitted and length.
</li>
					<li>
( %伝送量, %長さ )
を与える下で，
`~upload~obj$に向けて，名前 `load$et の`進捗~eventを発火する$
◎
Fire a progress event named load on the XMLHttpRequestUpload object with transmitted and length.
</li>
					<li>
( %伝送量, %長さ )
を与える下で，
`~upload~obj$に向けて，名前 `loadend$et の`進捗~eventを発火する$
◎
Fire a progress event named loadend on the XMLHttpRequestUpload object with transmitted and length.
</li>
				</ol>

<p class="algo-head">
%応答 に対し，`応答を処理する$ときは、次の下位手続きを走らす：
◎
To process response for response, run these subsubsteps:
</p>

				<ol>
					<li>
`応答$ ~SET %応答
◎
Set response to response.
</li>
					<li>
%応答 に対し，`~errorを取扱う$
◎
Handle errors for response.
</li>
					<li>
~IF［
`応答$ は`~network~error$である
］
⇒
~RET
◎
If response is a network error, return.
</li>
					<li>
`状態$ ~SET `~headers-received^i
◎
Set state to headers received.
</li>
					<li>
名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange.
</li>
					<li>
~IF［
`状態$ ~NEQ `~headers-received^i
］
⇒
~RET
◎
If state is not headers received, then return.
</li>
					<li>
%本体 ~LET %応答 の`本体$rs
◎
↓</li>
					<li>
<p>
~IF［
%本体 ~EQ ~NULL
］：
</p>
<ol><li>%応答 の`本体終端を取扱う$
</li><li>~RET
</li></ol>
◎
If response’s body is null, then run handle response end-of-body and return.
</li>
					<li>
<p>
%読取器 ~LET %本体 の`~stream$から`読取器を取得-$した結果
◎
Let reader be the result of getting a reader from response’s body’s stream.
</p>

<p class="note">注記：
この演算が例外を投出することはない。
◎
This operation will not throw an exception.
</p>
					</li>
					<li>
<p>
%読取 ~LET %本体 の`~stream$から %読取器 で`~chunkを読取った$結果
◎
Let read be the result of reading a chunk from response’s body’s stream with reader.
</p>

<ul>
	<li>

<div class="p">
<p>
%読取 が次の両者を満たす~obj：
</p>

<ul ><li>`done^c ~prop ~EQ ~F
</li><li>`value^c ~propは `Uint8Array$I ~objである
</li></ul>

<p>
で充足されたときは
⇒
次の下位手続き(A) を走らせた上で、［
この，`応答を処理する$手続き
］を再度~走らす
</p>

◎
When read is fulfilled with an object whose done property is false and whose value property is a Uint8Array object, run these subsubsubsteps and then run the above subsubstep again:
</div>

<p>
下位手続き(A)：
</p>

						<ol>
							<li>
`受信済み~byte列$に `value^c ~propを付加する
◎
Append the value property to received bytes.
</li>
							<li>
~IF［
下位手続き(A) が前回に呼出されたときから，まだ およそ 50ms 以上 経過していない
］
⇒
~RET
◎
If not roughly 50ms have passed since these subsubsubsteps were last invoked, then terminate these subsubsubsteps.
</li>
							<li>
~IF［
`状態$ ~EQ `~headers-received^i
］
⇒
`状態$ ~SET `~loading^i
◎
If state is headers received, then set state to loading.
</li>
							<li>
<p>
名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange.
</p>
<p class="note">注記：
`readystatechange$et が状態~変化なしでも余分に発火されるのは、
Web 互換性の理由による。
◎
Web compatibility is the reason readystatechange fires more often than state changes.
</p>
							</li>
							<li>
%本体 の
( `伝送済み~byte数$, `総~byte数$ )
を与える下で，名前 `progress$et の`進捗~eventを発火する$
◎
Fire a progress event named progress with response’s body’s transmitted bytes and response’s body’s total bytes.
</li>
						</ol>
<p class="note">注記：
下位手続き(A) は、新たな~byte列が伝送されたときに限り，呼出される。
◎
These subsubsubsteps are only invoked when new bytes are transmitted.
</p>
					</li>
					<li>
%読取 が［
`done^c ~prop ~EQ ~T
］なる~objで充足されたときは
⇒
%応答 の`本体終端を取扱う$
◎
When read is fulfilled with an object whose done property is true, run handle response end-of-body for response.
</li>
	<li>
%読取 が例外で却下されたときは
⇒
%応答 の`~errorを取扱う$
◎
When read is rejected with an exception, run handle errors for response.
</li>
</ul>

				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
（ `同期~flag$ ~EQ ~ON ）：
◎
Otherwise, if the synchronous flag is set, run these substeps:
</p>

		<ol>
			<li>
<p>
%応答 ~LET %要請 を用いて`~fetching$を遂行した結果
◎
Let response be the result of fetching req.
</p>

<div class="p">
<p>
~IF［
`timeout$m 属性~値 %timeout ~NEQ 0
］~AND［
この`~fetching$は %timeout ~milli秒内に返らなかった
］：
</p>
<ol><li>`時間切れ~flag$ ~SET ~ON
</li><li>この`~fetchを終了-$させる
</li></ol>

◎
If the timeout attribute value is not zero, then set the timed out flag and terminate fetching if it has not returned within the amount of milliseconds from the timeout.
</div>

			</li>
			<li>
<p >
~IF［
%応答 の`本体$rs ~NEQ ~NULL
］
◎
If response’s body is null, then run handle response end-of-body and return.
</p>
				<ol>
					<li>
<p>
%読取器 ~LET %応答 の`本体$rsの`~stream$から`読取器を取得-$した結果
◎
Let reader be the result of getting a reader from response’s body’s stream.
</p>

<p class="note">注記：
この演算が例外を投出することはない。
◎
This operation will not throw an exception.
</p>
			</li>
					<li>
%promise ~LET ［
%応答 の`本体$rsの`~stream$から， %読取器 を用いて`すべての~byte列を読取る$
］ような~promise
◎
Let promise be the result of reading all bytes from response’s body’s stream with reader.
</li>
					<li>
%promise が充足されるか却下されるまで待機する
⇒
%promise が %~byte列 で充足されたときは
⇒
`受信済み~byte列$に %~byte列 を付加する
◎
Wait for promise to be fulfilled or rejected.
◎
• If promise is fulfilled with bytes, then append bytes to received bytes.
</li>
				</ol>
			</li>
			<li>
%応答 の`本体終端を取扱う$
◎
Run handle response end-of-body for response.
</li>
		</ol>
	</li>
</ol>

<p class="algo-head">
%応答 の
`本体終端を取扱う@
ときは、次を走らす：
◎
To handle response end-of-body for response, run these steps:
</p>

<ol>
	<li>
~IF［
`同期~flag$ ~EQ ~ON
］
⇒
`応答$ ~SET %応答
◎
If the synchronous flag is set, set response to response.
</li>
	<li>
%応答 に対し，`~errorを取扱う$
◎
Handle errors for response.
</li>
	<li>
~IF［
`応答$ は`~network~error$である
］
⇒
~RET
◎
If response is a network error, return.
</li>
	<li>
~IF［
`同期~flag$ ~EQ ~OFF
］
⇒
%応答 を用いて`応答$の`本体$rsを更新する
◎
If the synchronous flag is unset, update response’s body using response.
</li>
	<li>
%伝送量 ~LET %応答 の`本体$rsの`伝送済み~byte数$
◎
Let transmitted be response’s body’s transmitted bytes.
</li>
	<li>
%長さ ~LET %応答 の`本体$rsの`総~byte数$
◎
Let length be response’s body’s total bytes.
</li>
	<li>
( %伝送量, %長さ )
を与える下で，名前 `progress$et の`進捗~eventを発火する$
◎
Fire a progress event named progress with transmitted and length.
</li>
	<li>
`状態$ ~SET `~done^i
◎
Set state to done.
</li>
	<li>
`~send~flag$ ~SET ~OFF
◎
Unset the send() flag.
</li>
	<li>
名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange.
</li>
	<li>
( %伝送量, %長さ )
を与える下で，名前 `load$et の`進捗~eventを発火する$
◎
Fire a progress event named load with transmitted and length.
</li>
	<li>
( %伝送量, %長さ )
を与える下で，名前 `loadend$et の`進捗~eventを発火する$
◎
Fire a progress event named loadend with transmitted and length.
</li>
</ol>


<p class="algo-head">
%応答 に対し，
`~errorを取扱う@
ときは、次を走らす：
◎
To handle errors for response run these steps:
</p>

<ol>
	<li>
~IF［
`~send~flag$ ~EQ ~OFF
］
⇒
~RET
◎
If the send() flag is unset, return.
</li>
	<li>
~IF［
%応答 は`~network~error$である
］
⇒
`要請~error手続き$を走らす( `error$et, `NetworkError^E )
◎
If response is a network error, run the request error steps for event error and exception NetworkError.
</li>
	<li>
~IF［
`時間切れ~flag$ ~EQ ~ON
］
⇒
`要請~error手続き$を走らす( `timeout$et, `TimeoutError^E )
◎
If the timed out flag is set, then run the request error steps for event timeout and exception TimeoutError.
</li>
	<li>
<p>
~ELIF［
%応答 の`本体$rsの`~stream$は`~errorした$
］：
◎
Otherwise, if response’s body’s stream is errored, then:
</p>
		<ol>
			<li>
`状態$ ~SET `~done^i
◎
Set state to done.
</li>
			<li>
`~send~flag$ ~SET ~OFF
◎
Unset the send() flag.
</li>
			<li>
`応答$ ~SET `~network~error$
◎
Set response to a network error.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%応答 の `中止-済み~flag^i ~EQ ~ON
］
⇒
`要請~error手続き$を走らす( `abort$et, `AbortError^E )
◎
Otherwise, if response’s aborted flag is set, then run the request error steps for event abort and exception AbortError.
</li>
</ol>

<p class="algo-head">
`要請~error手続き@
を走らすときは、所与の
( %~event名 , %例外 （省略可）)
に対し，次を走らす：
◎
The request error steps for event event and optionally an exception exception are:
</p>

<ol>
	<li>
`状態$ ~SET `~done^i
◎
Set state to done.
</li>
	<li>
`~send~flag$ ~SET ~OFF
◎
Unset the send() flag.
</li>
	<li>
`応答$ ~SET `~network~error$
◎
Set response to a network error.
</li>
	<li>
~IF［
`同期~flag$ ~EQ ~ON
］
⇒
~THROW %例外
◎
If the synchronous flag is set, throw an exception exception.

<p class="trans-note">【
この場合に、 %例外 が省略されて呼出されることはない。
】</p>
	</li>
	<li>
<p>
名前 `readystatechange$et の`~eventを発火する$ 
◎
Fire an event named readystatechange.
</p>

<p class="note">注記：
この時点で明らかに
`同期~flag$ ~EQ ~OFF
◎
At this point it is clear that the synchronous flag is unset.
</p>
	</li>
	<li>
<p>
~IF［
`~upload完了-~flag$ ~EQ ~OFF
］：
◎
If the upload complete flag is unset, follow these substeps:
</p>
		<ol>
			<li>
`~upload完了-~flag$ ~SET ~ON
◎
Set the upload complete flag.
</li>
			<li>
<p>
~IF［
`~upload~listener~flag$ ~EQ ~ON
］：
◎
If upload listener flag is unset, then terminate these substeps.
</p>
				<ol>
					<li>
( 0, 0 )
を与える下で，
`~upload~obj$に向けて，名前 %~event名 の`進捗~eventを発火する$
◎
Fire a progress event named event on the XMLHttpRequestUpload object with 0 and 0.
</li>
					<li>
( 0, 0 )
を与える下で，
`~upload~obj$に向けて，名前 `loadend$et の`進捗~eventを発火する$
◎
Fire a progress event named loadend on the XMLHttpRequestUpload object with 0 and 0. 
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
( 0, 0 )
を与える下で，名前 %~event名 の`進捗~eventを発火する$
◎
Fire a progress event named event with 0 and 0.
</li>
	<li>
( 0, 0 )
を与える下で，名前 `loadend$et の`進捗~eventを発火する$
◎
Fire a progress event named loadend with 0 and 0. 
</li>
</ol>

			</section>
			<section id="the-abort()-method">
<h4 title="The abort() method">4.5.7. `abort()^m ~meth</h4>

<dl class="domintro">
	<dt>%client . `abort()$m</dt>
	<dd>
~network活動をすべて取消す。
◎
Cancels any network activity.
</dd>
</dl>

<dl class="idl-def">
	<dt>`abort()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The abort() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
［
`中止-済み~flag^i ~SET ~ON
］の下で，進行中の`~fetchを終了-$させる
◎
Terminate the ongoing fetch with the aborted flag set.
</li>
			<li>
~IF［［
`状態$ ~EQ `~opened^i
］~AND［
`~send~flag$ ~EQ ~ON
］］~OR［
`状態$ ~IN
{ `~headers-received^i, `~loading^i }
］
⇒
`要請~error手続き$を走らす( `abort$et )
◎
If state is either opened with the send() flag set, headers received, or loading, run the request error steps for event abort.
</li>
			<li>
<div class="p">
<p>
~IF［
`状態$ ~EQ `~done^i
］：
</p>

<ol><li>`状態$ ~SET `~unsent^i
</li><li>`応答$ ~SET `~network~error$
</li></ol>
◎
If state is done, then set state to unsent and response to a network error.
</div>

<p class="note">注記：
いかなる `readystatechange$et ~eventも配送されない。
◎
No readystatechange event is dispatched.
</p>
			</li>
		</ol>
	</dd>
</dl>

			</section>
		</section>
		<section id="xmlhttprequest-response">
<h3 title="Response">4.6. 応答</h3>

<p>
各 `XMLHttpRequest$I には，次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`応答@</dt>
	<dd>
`応答$rs。
他が定められない限り，`~network~error$とする。
◎
An XMLHttpRequest has an associated response. Unless stated otherwise it is a network error.
</dd>

	<dt>`受信済み~byte列@</dt>
	<dd>
~byte列。
他が定められない限り，空~byte列とする。
◎
An XMLHttpRequest also has an associated received bytes (a byte sequence). Unless stated otherwise it is the empty byte sequence.
</dd>
</dl>

			<section id="the-responseurl-attribute">
<h4 title="The responseURL attribute">4.6.1. `responseURL^m 属性</h4>

<dl class="idl-def">
	<dt>`responseURL@m</dt>
	<dd>
取得子は、次を返さ~MUST
⇒
`応答$の`url$rs ~EQ ~NULL ならば空~文字列／
~ELSE_ `~URLを直列化する$( `応答$の`url$rs, `素片除外~flag^i ~SET ~ON )
◎
The responseURL attribute must return the empty string if response’s url is null and its serialization with the exclude fragment flag set otherwise.
</dd>
</dl>

			</section>
			<section id="the-status-attribute">
<h4 title="The status attribute">4.6.2. `status^m 属性</h4>

<dl class="idl-def">
	<dt>`status@m</dt>
	<dd>
取得子は、`応答$の`~status$rsを返さ~MUST。
◎
The status attribute must return the response’s status.
</dd>
</dl>

			</section>
			<section id="the-statustext-attribute">
<h4 title="The statusText attribute">4.6.3. `statusText^m 属性</h4>

<dl class="idl-def">
	<dt>`statusText@m</dt>
	<dd>
取得子は、`応答$の`~status~message$rsを返さ~MUST。
◎
The statusText attribute must return the response’s status message.
</dd>
</dl>

			</section>
			<section id="the-getresponseheader()-method">
<h4 title="The getResponseHeader() method">4.6.4. `getResponseHeader()^m ~meth</h4>

<dl class="idl-def">
	<dt>`getResponseHeader(name)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getResponseHeader(name) method must run these steps:
</p>

<ol>
	<li>
`応答$の`~header~list$rs内に［
%name を`名前に持つ~header$
］はない
］
⇒
~RET ~NULL
◎
If response’s header list does not contain name, then return null.
</li>
	<li>
~RET `応答$の`~header~list$rs内の %名前 に対する`結合済みの値$
◎
Return the combined value given name and response’s header list.
</li>
</ol>

<p class="note">注記：
`応答$に公開される`~header~list$rsは、 Fetch 標準に従って，絞込まれる。
`FETCH$r
◎
The Fetch Standard filters response’s header list. [FETCH]
</p>

	</dd>
</dl>


<div class="example" id="example-getresponseheader">

<p>
次の~scriptにおいては：
◎
For the following script:
</p>

<pre>
var %client = new XMLHttpRequest();
%client.open("GET", "unicorns-are-teh-awesome.txt", true);
%client.send();
%client.onreadystatechange = function() {
  if(this.readyState == this.HEADERS_RECEIVED) {
    print(client.getResponseHeader("Content-Type"));
  }
}
</pre>

<p>
`print()^c 関数は、次と同様の結果を得ることになる：
◎
The print() function will get to process something like:
</p>

<pre>
text/plain; charset=UTF-8
</pre>

</div>

			</section>
			<section id="the-getallresponseheaders()-method">
<h4 title="The getAllResponseHeaders() method">4.6.5. `getAllResponseHeaders()^m ~meth</h4>

<dl class="idl-def">
	<dt>`getAllResponseHeaders()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getAllResponseHeaders() method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%出力 ~LET 空~byte列
◎
Let output be an empty byte sequence.
</li>
			<li>
%~header~list ~LET `応答$の`~header~list$rsを`整列して結合-$した結果
◎
Let headers be the result of running sort and combine with response’s header list.
</li>
			<li>
<p>
~FOR
%~header~list 内の~EACH( %~header ) に対し
⇒
%出力 に次の並びを付加する：
</p>

<ol ><li>%~header の`名前$
</li><li>~byte対 0x3A 0x20
</li><li>%~header の`値$
</li><li>~byte対 0x0D 0x0A
</li></ol>
◎
For each header in headers, append header’s name, followed by a 0x3A 0x20 byte pair, followed by header’s value, followed by a 0x0D 0x0A byte pair, to output.
</li>
			<li>
~RET %出力
◎
Return output.
</li>
		</ol>

<p class="note">注記：
`応答$に公開される`~header~list$rsは、 Fetch 標準に従って，絞込まれる。
`FETCH$r
◎
The Fetch Standard filters response’s header list. [FETCH]
</p>

	</dd>
</dl>

<div class="example" id="example-getresponseheaders">

<p>
次の~scriptに対し：
◎
For the following script:
</p>

<pre>
var %client = new XMLHttpRequest();
%client.open("GET", "narwhals-too.txt", true);
%client.send();
%client.onreadystatechange = function() {
  if(this.readyState == this.HEADERS_RECEIVED) {
    print(this.getAllResponseHeaders());
  }
}
</pre>

<p><!-- copy -->
`print()^c 関数は、次と同類の結果を得ることになる：
◎
The print() function will get to process something like:
</p>

<pre>
connection: Keep-Alive
content-type: text/plain; charset=utf-8
date: Sun, 24 Oct 2004 04:58:38 GMT
keep-alive: timeout=15, max=99
server: Apache/1.3.31 (Unix)
transfer-encoding: chunked
</pre>

</div>

			</section>
			<section id="response-body">
<h4 title="Response body">4.6.6. 応答~本体</h4>

<p class="algo-head">
`応答~MIME型@
は、次を走らせた結果で与えられる：
◎
The response MIME type is the result of running these steps:
</p>

<ol>
	<li>
%~MIME型 ~LET
`応答$の`~header~list$rsから`~MIME型を抽出-$した結果
◎
Let mimeType be the result of extracting a MIME type from response’s header list.
</li>
	<li>
~RET ［
%~MIME型 ~NEQ 空~byte列 ならば %~MIME型 ／
~ELSE_ `text/xml^lb
］
◎
If mimeType is the empty byte sequence, then set mimeType to `text/xml`.
◎
Return mimeType.
</li>
</ol>

<p>
`上書き~MIME型@
は、初期~時は ~NULL であり，その値は `overrideMimeType()$m を呼出せば得られる。
`最終~MIME型@
は、`上書き~MIME型$が［
非 ~NULL ならばその値 ／
~NULL ならば`応答~MIME型$
］とする。
◎
The override MIME type is initially null and can get a value if overrideMimeType() is invoked. Final MIME type is the override MIME type unless that is null in which case it is the response MIME type.
</p>


<p>
`応答~charset@
は、 `Content-Type$h ~headerの ~charset~parameterの値である。
ただし、 ~charset~parameterが存在しない場合，あるいは
~headerが
構文解析できない／省略されている
場合は ~NULL になる。
`上書き~charset@
の初期~時は ~NULL であり，その値は `overrideMimeType()$m を呼出せば得られる。
`最終~charset@
は、`上書き~charset$が［
非 ~NULL ならばその値 ／
~NULL ならば`応答~charset$
］とする。
◎
The response charset is the value of the charset parameter of the `Content-Type` header or null if there was no `charset` parameter or the header could not be parsed or was omitted. The override charset is initially null and can get a value if overrideMimeType() is invoked. Final charset is the override charset unless that is null in which case it is the response charset.
</p>

<hr>

<p>
各 `XMLHttpRequest$I ~objには、
`応答~obj@
が結付けられる
— それは、［
~obj, `失敗^i, ~NULL
］のいずれかをとり，他が定められない限り ~NULL とする。
◎
An XMLHttpRequest object has an associated response object (an object, failure, or null). Unless stated otherwise it is null.
</p>

<hr>

<p class="algo-head">
`~arraybuffer応答@
は、次の手続きが返す値である：
◎
An arraybuffer response is the return value of these steps:
</p>

<ol>
	<li>
<div class="p">
<p>
`応答~obj$ ~SET `受信済み~byte列$を表現する，新たな `ArrayBuffer$I ~obj
— ただし、例外が投出された場合は：
</p>

<ol ><li>`応答~obj$ ~SET `失敗^i
</li><li>~RET ~NULL
</li></ol>

◎
Set response object to a new ArrayBuffer object representing received bytes. If this throws an exception, then set response object to failure and return null. 
</div>

<p class="note">注記：
`ArrayBuffer$I ~objを割り当てることの成功-は保障されない。
`ECMASCRIPT$r
◎
Allocating an ArrayBuffer object is not guaranteed to succeed. [ECMASCRIPT]
</p>
	</li>
	<li>
~RET `応答~obj$
◎
Return response object.
</li>
</ol>


<p class="algo-head">
`~blob応答@
は、次の手続きが返す値である：
◎
A blob response is the return value of these steps:
</p>

<ol>
	<li>
`応答~obj$ ~SET `受信済み~byte列$を表現する，新たな `Blob$I ~obj
◎
Set response object to a new Blob object representing received bytes＼
</li>
	<li>
`応答~obj$の `~type0$m ~SET `最終~MIME型$
◎
with type final MIME type.
</li>
	<li>
~RET `応答~obj$
◎
Return response object.
</li>
</ol>

<p class="algo-head">
`文書~応答@
は、次の手続きが返す値（`文書$, または ~NULL ）である：
◎
A document response is the return value of these steps:
</p>


<ol>
	<li>
~IF［
`応答$の`本体$rs ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If response’s body is null, then return null.
</li>
	<li>
~IF［
`最終~MIME型$ ~NIN
{ `text/html^lb, `text/xml^lb, `application/xml^lb }
］~OR［
`最終~MIME型$は `+xml^lb で終端していない
］
⇒
~RET ~NULL
◎
If final MIME type is not `text/html`, `text/xml`, `application/xml`, or does not end in `+xml`, then return null.
</li>
	<li>
<p>
~IF［
`responseType$m ~EQ 空~文字列
］~AND［
`最終~MIME型$ ~EQ `text/html^lb
］
⇒
~RET ~NULL
◎
If responseType is the empty string and final MIME type is `text/html`, then return null.
</p>

<p class="note">注記：
旧来~内容を壊さないようにするため、ここでは
`responseType$m は `document^l に制約される。
◎
This is restricted to responseType being "document" in order to prevent breaking legacy content.
</p>
	</li>
	<li>
<p>
~IF［
`最終~MIME型$ ~EQ `text/html^lb
］：
◎
If final MIME type is `text/html`, then run these substeps:
</p>

		<ol>
			<li>
%charset ~LET ［
`最終~charset$ ~NEQ ~NULL ならば それ ／
~ELSE_ ［
`受信済み~byte列$の最初の 1024 ~byteを
<a href="~HTMLparsing#prescan-a-byte-stream-to-determine-its-encoding">~prescan</a>
して 成功裡に結果を得られた
］ならば その結果 ／ 
~ELSE_ `~utf-8$
］
◎
Let charset be the final charset.
◎
If charset is null, prescan the first 1024 bytes of received bytes and if that does not terminate unsuccessfully then let charset be the return value.
◎
If charset is null, set charset to utf-8.
</li>
			<li>
%文書 ~LET 次の結果を表現する`文書$
⇒
~HTML標準の~HTML構文解析に~~定められた規則に従って，［
~scriptは不能化し, 
<a href="~HTMLparsing#a-known-definite-encoding">既知の確定的な符号化方式</a> 
%charset
］の下で，`受信済み~byte列$を構文解析した結果
`HTML$r
◎
Let document be a document that represents the result parsing received bytes following the rules set forth in the HTML Standard for an HTML parser with scripting disabled and a known definite encoding charset. [HTML]
</li>
			<li>
%文書 の`種別$doc ~SET `html^l
◎
Flag document as an HTML document.
</li>
		</ol>
	</li>
	<li>
<div>
<p>
~ELSE：
</p>
		<ol>
			<li>
%文書 ~LET 次の結果を表現する`文書$
⇒
<a href="~HTMLxml#xml-scripting-support-disabled">XML ~script~supportを不能化-</a>した下で，`受信済み~byte列$を
<a href="~HTMLxml#xml-parser">XML 構文解析器</a>
にかけた結果
`HTML$r
</li>
			<li>
~IF［
前~段にて
構文解析に失敗した（未~supportの文字~符号化方式, 名前空間整形式~error, 等々）
］
⇒
~RET ~NULL
</li>
		</ol>
◎
Otherwise, let document be a document that represents the result of running the XML parser with XML scripting support disabled on received bytes. If that fails (unsupported character encoding, namespace well-formedness error, etc.), then return null. [HTML]
</div>

<p class="note">注記：
文書から参照されている資源は読込まれず,
文書に結付けられている XSLT は適用されない。
◎
Resources referenced will not be loaded and no associated XSLT will be applied.
</p>
	</li>
	<li>
~IF［
%charset ~EQ ~NULL
］
⇒
%charset ~SET `~utf-8$
◎
If charset is null, set charset to utf-8.
</li>
	<li>
%文書 の`符号化方式$ ~SET %charset
◎
Set document’s encoding to charset.
</li>
	<li>
%文書 の`内容型$ ~SET `最終~MIME型$
◎
Set document’s content type to final MIME type.
</li>
	<li>
%文書 の`~URL$ ~SET `応答$の`url$rs
◎
Set document’s URL to response’s url.
</li>
	<li>
%文書 の`生成元$doc ~SET
此れに`関連する設定群~obj$の`生成元$enV
◎
Set document’s origin to context object’s relevant settings object’s origin.
</li>
	<li>
`応答~obj$ ~SET %文書
◎
Set response object to document and return it.
</li>
	<li>
~RET %文書
◎
↑</li>
</ol>


<p class="algo-head">
`~JSON応答@
は、次の手続きが返す値である：
◎
A JSON response is the return value of these steps:
</p>

<ol>
	<li>
~IF［
`応答$の`本体$rs ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If response’s body is null, then return null.
</li>
	<li>
%~JSON~text ~LET
`受信済み~byte列$を`~utf-8復号-$した結果
◎
Let JSON text be the result of running utf-8 decode on received bytes.
</li>
	<li>

<p>
%~JSON~obj ~LET
`JSON^c ~objの `parse^c ~propの初期~値【である関数】
を，その唯一の引数に %~JSON~text を渡して呼出した結果
`ECMASCRIPT$r
</p>

<p>
~IF［
`parse^c 関数から例外が投出された
］
⇒
~RET ~NULL
</p>

◎
Let JSON object be the result of invoking the initial value of the parse property of the JSON object, with JSON text as its only argument. If that threw an exception, return null. [ECMASCRIPT]
</li>
	<li>
`応答~obj$ ~SET %~JSON~obj
◎
Set response object to JSON object and return it.
</li>
	<li>
~RET %~JSON~obj
◎
↑</li>
</ol>

<p class="algo-head">
`~text応答@
は、次の手続きが返す値である：
◎
A text response is the return value of these steps:
</p>

<ol>
	<li>
~IF［
`応答$の`本体$rs ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If response’s body is null, then return the empty string.
</li>
	<li>
%charset ~LET
`最終~charset$
◎
Let charset be the final charset.
</li>
	<li>
<p>
~IF［
`responseType$m ~EQ 空~文字列
］~AND［
%charset ~EQ ~NULL
］~AND［［
`最終~MIME型$ ~IN
{ `text/xml^lb, `application/xml^lb }
］~OR［
`最終~MIME型$ は `+xml^lb で終端する
］］
⇒
%charset ~LET
XML 仕様に規定される規則に従って決定される符号化方式
`XML$r
`XMLNS$r
◎
If responseType is the empty string, charset is null, and final MIME type is `text/xml`, `application/xml`, or ends in `+xml`, then use the rules set forth in the XML specifications to determine the encoding. Let charset be the determined encoding. [XML] [XMLNS]
</p>

<p class="note">注記：
非旧来 `responseType$m 値 `text^l を単純なままに保つため、ここでは `responseType$m は空~文字列に制約される。
◎
This is restricted to responseType being the empty string to keep the non-legacy responseType value "text" simple.
</p>
	</li>
	<li>
~IF［
%charset ~EQ ~NULL 
］
⇒
%charset ~SET `~utf-8$
◎
If charset is null, set charset to utf-8.
</li>
	<li>
~RET ~fallback符号化方式に %charset を用いて，`受信済み~byte列$を`復号-$した結果
◎
Return the result of running decode on received bytes using fallback encoding charset.
</li>
</ol>

<p class="note">注記：
作者には、資源を符号化する際には，常に`~utf-8$ を用いることが強く奨励される。
◎
Authors are strongly encouraged to always encode their resources using utf-8.
</p>

			</section>
			<section id="the-overridemimetype()-method">
<h4 title="The overrideMimeType() method">4.6.7. `overrideMimeType()^m ~meth</h4>

<dl class="domintro">
	<dt>%client . `overrideMimeType(mime)$m</dt>
	<dd>
`応答$の `Content-Type$h ~headerが %mime であったかのように動作する。
◎
Acts as if the `Content-Type` header for response is mime.
</dd>
	<dd>
`状態$ ~IN { `~loading^i, `~done^i } の場合、
`InvalidStateError^E 例外が投出される。
◎
Throws an InvalidStateError exception if state is loading or done.
</dd>
</dl>

<dl class="idl-def">
	<dt>`overrideMimeType(mime)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The overrideMimeType(mime) method must run these steps:
</p>

		<ol>
			<li>
~IF［
`状態$ ~IN
{ `~loading^i, `~done^i }
］
⇒
~THROW `InvalidStateError^E
◎
If state is loading or done, throw an InvalidStateError exception.
</li>
			<li>
`上書き~MIME型$ ~SET `application/octet-stream^lb
◎
Set override MIME type to `application/octet-stream`.
</li>
			<li>
~IF［
%mime は`構文解析できる~MIME型$である
］
⇒
`上書き~MIME型$ ~SET %mime 内の`~MIME型~~成分$
◎
If mime is a parsable MIME type, then set override MIME type to its MIME type portion.
</li>
			<li>
~IF［
`上書き~MIME型$には `charset^c ~parameterはある
］
⇒
`上書き~charset$ ~SET その `charset^c ~parameter
◎
If override MIME type has a `charset` parameter, then set override charset to its value.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="the-responsetype-attribute">
<h4 title="The responseType attribute">4.6.8. `responseType^m 属性</h4>

<dl class="domintro">

	<dt>%client . `responseType$m [ = %value ]</dt>
	<dd>
応答の種別を返す。
◎
Returns the response type.
</dd>
	<dd>
設定して、応答の種別を変更できる。
値は次のいずれか
⇒
空~文字列 （既定）,
`arraybuffer^l,
`blob^l,
`document^l,
`json^l,
`text^l
◎
Can be set to change the response type. Values are: the empty string (default), "arraybuffer", "blob", "document", "json", and "text".
</dd>
	<dd>
<p>
設定子においては：
◎
↓</p>

		<ul>
			<li>
`現在の大域~obj$は `Window$I ~objでない場合、
`document^l に設定しても無視される。
◎
When set: setting to "document" is ignored if current global object is not a Window object.
</li>
			<li>
`状態$ ~IN { `~loading^i, `~done^i } の場合、
`InvalidStateError^E 例外が投出される。
◎
When set: throws an InvalidStateError exception if state is loading or done.
</li>
			<li>
`同期~flag$ ~EQ ~ON, かつ
`現在の大域~obj$は `Window$I ~objである場合、
`InvalidAccessError^E 例外が投出される。
◎
When set: throws an InvalidAccessError exception if the synchronous flag is set and current global object is a Window object.
</li>
		</ul>
	</dd>
</dl>


<dl class="idl-def">
	<dt>`responseType@m</dt>
	<dd>
取得子は、最後に設定された値を返さ~MUST。
初期~時には空~文字列に設定され~MUST。
◎
The responseType attribute must return its value. Initially its value must be the empty string.
</dd>
	<dd>
<p>
属性の設定子は、次を走らせ~MUST：
◎
Setting the responseType attribute must run these steps:
</p>

		<ol>
			<li>
%W ~LET ［
`現在の大域~obj$は `Window$I ~objであるならば ~T ／
~ELSE_ ~F
］
◎
↓</li>
			<li>
~IF［
%W ~EQ ~F
］~AND［
所与の値 ~EQ `document^l
］
⇒
~RET
◎
If current global object is not a Window object and the given value is "document", terminate these steps.
</li>
			<li>
~IF［
`状態$ ~IN
{ `~loading^i, `~done^i }
］
⇒
~THROW `InvalidStateError^E
◎
If state is loading or done, throw an InvalidStateError exception.
</li>
			<li>
~IF［
%W ~EQ ~T
］~AND［
`同期~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidAccessError^E
◎
If current global object is a Window object and the synchronous flag is set, throw an InvalidAccessError exception.
</li>
			<li>
この属性の値 ~SET 所与の値
◎
Set the responseType attribute’s value to the given value.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="the-response-attribute">
<h4 title="The response attribute">4.6.9. `response^m 属性</h4>

<dl class="domintro">
	<dt>%client . `response$m</dt>
	<dd>
`応答$の`本体$rsを返す。
◎
Returns the response’s body.
</dd>
</dl>

<dl class="idl-def">
	<dt>`response@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The response attribute must return the result of running these steps:
</p>
		<ol>
			<li>
%応答~種別 ~LET 此れの `responseType$m の値
◎
↓</li>
			<li>
~IF［
%応答~種別 ~IN { 空~文字列, `text^l }
］
⇒
~RET［
`状態$ ~NIN { `~loading^i, `~done^i } ならば空~文字列 ／
~ELSE_ `~text応答$
］
◎
If responseType is the empty string or "text"
◎
• If state is not loading or done, return the empty string.
◎
• Return the text response.
</li>
			<li>
~IF［
`状態$ ~NEQ `~done^i
］
⇒
~RET ~NULL
◎
Otherwise
◎
If state is not done, return null.
</li>
			<li>
~IF［
`応答~obj$ ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If response object is failure, then return null.
</li>
			<li>
~IF［
`応答~obj$ ~NEQ ~NULL
］
⇒
~RET `応答~obj$
◎
If response object is non-null, then return it.
</li>
			<li>
<p>
~RET %応答~種別 に応じて，次で与えられる値：
</p>
				<dl class="switch">
					<dt>`arraybuffer^l</dt>
					<dd>
`~arraybuffer応答$
</dd>

					<dt>`blob^l</dt>
					<dd>
`~blob応答$
</dd>

					<dt>`document^l</dt>
					<dd>
`文書~応答$
</dd>

					<dt>`json^l</dt>
					<dd>
`~JSON応答$
</dd>
				</dl>

◎
If responseType is "arraybuffer"
• Return the arraybuffer response.
If responseType is "blob"
• Return the blob response.
If responseType is "document"
• Return the document response.
If responseType is "json"
• Return the JSON response.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="the-responsetext-attribute">
<h4 title="The responseText attribute">4.6.10. `responseText^m 属性</h4>

<dl class="domintro">
	<dt>%client . `responseText$m</dt>
	<dd>
`~text応答$を返す。
◎
Returns the text response.
</dd>
	<dd>
`responseType$m ~NEQ 空~文字列, かつ ~NEQ `text^l の場合、
`InvalidStateError^E 例外が投出される。
◎
Throws an InvalidStateError exception if responseType is not the empty string or "text".
</dd>
</dl>

<dl class="idl-def">
	<dt>`responseText@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The responseText attribute must return the result of running these steps:
</p>
		<ol>
			<li>
~IF［
此れの `responseType$m の値 ~NIN { 空~文字列, `text^l }
］
⇒
~THROW `InvalidStateError^E
◎
If responseType is not the empty string or "text", throw an InvalidStateError exception.
</li>
			<li>
~RET［
`状態$ ~NIN { `~loading^i, `~done^i } ならば空~文字列 ／
~ELSE_ `~text応答$
］
◎
If state is not loading or done, return the empty string.
◎
Return the text response.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="the-responsexml-attribute">
<h4 title="The responseXML attribute">4.6.11. `responseXML^m 属性</h4>

<dl class="domintro">
	<dt>%client . `responseXML$m</dt>
	<dd>
`文書~応答$
を返す。
◎
Returns the document response.
</dd>
	<dd>
`responseType$m 値が
空~文字列でも `document^l でもない場合、
`InvalidStateError^E 例外が投出される。
◎
Throws an InvalidStateError exception if responseType is not the empty string or "document".
</dd>
</dl>

<dl class="idl-def">
	<dt>`responseXML@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
The responseXML attribute must return the result of running these steps:
</p>
		<ol>
			<li>
~IF［
此れの `responseType$m 値 ~NIN  { 空~文字列, `document^l }
］
⇒
~THROW `InvalidStateError^E
◎
If responseType is not the empty string or "document", throw an InvalidStateError exception.
</li>
			<li>
~IF［
`状態$ ~NEQ `~done^i
］
⇒
~RET ~NULL
◎
If state is not done, return null.
</li>
			<li>
~IF［
`応答~obj$ ~NEQ ~NULL
］
⇒
~RET `応答~obj$
◎
If response object is non-null, then return it.
</li>
			<li>
~RET `文書~応答$
◎
Return the document response.
</li>
		</ol>
	</dd>
</dl>

<p class="note">注記：
`responseXML$m 属性の名が “XML” を含んでいるのは、歴史的な理由による。
それはまた、~HTML資源を `文書$として返す。
◎
The responseXML attribute has XML in its name for historical reasons. It also returns HTML resources as documents.
</p>

			</section>
		</section>
		<section id="events">
<h3 title="Events summary">4.7. ~event要覧</h3>

~INFORMATIVE

<p>
以下の~eventが［
`XMLHttpRequest$I ／ `XMLHttpRequestUpload$I
］~objに向けて配送される：
◎
The following events are dispatched on XMLHttpRequest and/or XMLHttpRequestUpload objects:
</p>

<table>

<thead><tr><th>~event名◎Event name
<th>~interface◎Interface
<th>配送-時機◎Dispatched when…
</thead>

	<tbody>
<tr><td>`readystatechange@et
<td>`Event$I
<td>
`readyState$m 属性の値が変化したとき。
ただし， `UNSENT$m に変化したときは除く。
◎
The readyState attribute changes value, except when it changes to UNSENT.

<tr><td>`loadstart@et
<td>`ProgressEvent$I
<td>
~fetchが起動されたとき。
◎
The fetch initiates.

<tr><td>`progress@et
<td>`ProgressEvent$I
<td>
~dataを伝送-中のとき。
◎
Transmitting data.

<tr><td>`abort@et
<td>`ProgressEvent$I
<td>
~fetchが中止されたとき。
例えば， `abort()$m ~methの呼出しなど。
◎
When the fetch has been aborted. For instance, by invoking the abort() method.

<tr><td>`error@et
<td>`ProgressEvent$I
<td>
~fetchに失敗したとき。
◎
The fetch failed.

<tr><td>`load@et
<td>`ProgressEvent$I
<td>
~fetchを成功裡に終えたとき。
◎
The fetch succeeded.

<tr><td>`timeout@et
<td>`ProgressEvent$I
<td>
~fetchが完了する前に `timeout$m に指定される時間を過ぎたとき。
◎
The author specified timeout has passed before the fetch completed.

<tr><td>`loadend@et
<td>`ProgressEvent$I
<td>
~fetchが完了したとき（成功, 失敗, いずれに関わらず）。
◎
The fetch completed (success or failure).

</tbody>
</table>



		</section>
	</section>
	<section id="interface-formdata">
<h2 title="Interface FormData">5. ~interface `FormData^I</h2>

<pre class="idl">
typedef (`File$I or `USVString$I) `FormDataEntryValue@I;

[<a href="#dom-formdata">Constructor</a>(optional `HTMLFormElement$I %form),
 `Exposed$=(Window,Worker)]
interface `FormData@I {
  void `append$m(`USVString$I %name, `USVString$I %value);
  void `append$m(`USVString$I %name, `Blob$I %value, optional `USVString$I %filename);
  void `delete$m(`USVString$I %name);
  `FormDataEntryValue$I? `get$m(`USVString$I %name);
  sequence&lt;`FormDataEntryValue$I&gt; `getAll$m(`USVString$I %name);
  boolean `has$m(`USVString$I %name);
  void `set$m(`USVString$I %name, `USVString$I %value);
  void `set$m(`USVString$I %name, `Blob$I %value, optional `USVString$I %filename);
  iterable&lt;`USVString$I, `FormDataEntryValue$I&gt;;
};</pre>

<p>
`FormData$I ~objは、一連の
`~entry@
からなる有順序~listを表現する。
~list内の各`~entry$は、
`名前@fe,
`値@fe
を持つ。
◎
The FormData object represents an ordered list of entries. Each entry consists of a name and a value.
</p>

<p>
他の~algoとやりとりする目的においては、`~entry$の型は［
その`値$feが文字列であるならば `string^l ／
~ELSE_ `file^l
］とする。
`~entry$の型が `file^l の場合、その~filenameは［
~entryが `File$I ~objであるならば `~entry$の`値$feの `name$m 属性~値 ／
~ELSE_ 空~文字列
］で与えられる。
◎
For the purposes of interaction with other algorithms, an entry’s type is "string" if its value is a string and "file" otherwise. If an entry’s type is "file", its filename is the empty string if value is not a File object, and otherwise its filename is the value of entry’s value’s name attribute.
</p>

<p class="algo-head">
`~entryを作成する@
ときは、所与の
( %名前, %値, %~filename （省略-時は ε ）)
に対し，次を走らす：
◎
To create an entry for name, value, and optionally a filename, run these steps:
</p>

<ol>
	<li>
%~entry ~LET 新たな`~entry$
◎
Let entry be a new entry.
</li>
	<li>
%~entry の`名前$fe ~SET %名前
◎
Set entry’s name to name.
</li>
	<li>
<p>
~IF［
%値 は `Blob$I ~objである
］~AND［［
%値 は `File$I ~objでない
］~OR［
%~filename ~NEQ ε
］］：
</p>
		<ol>
			<li>
%値 ~SET  %値 と同じ~byte列を表現する新たな `File$I ~obj
</li>
			<li>
%値 の `name$m 属性~値 ~SET ［
%~filename ~NEQ ε ならば %~filename ／
~ELSE_ `blob^l
］
</li>
		</ol>

◎
If value is a Blob object and not a File object, then set value to a new File object, representing the same bytes, whose name attribute value is "blob".
◎
If value is (now) a File object and filename is given, then set value to a new File object, representing the same bytes, whose name attribute value is filename.
</li>
	<li>
%~entry の`値$fe ~SET %値
◎
Set entry’s value to value.
</li>
	<li>
~RET %~entry
◎
Return entry.
</li>
</ol>


<dl class="idl-def">
	<dt>`FormData(form)@m</dt>
	<dd>
<p>
この構築子は、次を走らせ~MUST：
◎
The FormData(form) constructor must run these steps:
</p>

	<ol>
			<li>
%fd ~LET 新たな `FormData$I ~obj
◎
Let fd be a new FormData object.
</li>
			<li>
~IF［
%form 引数は与えられている
］
⇒
%fd の`~entry~list$ ~SET
%form に対し`~form_data_setを構築-$した結果
◎
If form is given, set fd’s entries to the result of constructing the form data set for form.
</li>
			<li>
~RET %fd
◎
Return fd.
</li>
		</ol>
	</dd>

	<dt>`append(name, value, filename)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The append(name, value) and append(name, blobValue, filename) methods, when invoked, must run these steps: 
◎
Let value be value if given, and blobValue otherwise.
</p>

		<ol>
			<li>
%~entry ~LET `~entryを作成する$( %name, %value, %filename )
— %filename は与えられていない場合は省略する
◎
Let entry be the result of creating an entry with name, value, and filename if given.
</li>
			<li>
此れの`~entry~list$に %~entry を付加する
◎
Append entry to context object’s list of entries.
</li>
		</ol>
	</dd>
	<dd>
◎
The reason there is an argument named value as well as blobValue is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</dd>

	<dt>`delete(name)@m</dt>
	<dd>
被呼出時には、此れの`~entry~list$から［
`名前$fe ~EQ %name
］なる`~entry$すべてを除去し~MUST。 
◎
The delete(name) method, when invoked, must remove all entries whose name is name.
</dd>

	<dt>`get(name)@m</dt>
	<dd>
被呼出時には、此れの`~entry~list$内に［
`名前$fe ~EQ %name
］なる`~entry$は［
在るならば それらのうち最初の~entryの`値$fe ／
無いならば ~NULL
］を返さ~MUST。
◎
The get(name) method, when invoked, must return the value of the first entry whose name is name, and null otherwise.
</dd>

	<dt>`getAll(name)@m</dt>
	<dd>
被呼出時には、［
此れの`~entry~list$内の［
`名前$fe ~EQ %name
］なる`~entry$すべての`値$fe
］からなる同順の~list（存在しなければ空~list）を返さ~MUST。
◎
The getAll(name) method, when invoked, must return the values of all entries whose name is name, in list order, and the empty sequence otherwise.
</dd>

	<dt>`has(name)@m</dt>
	<dd>
被呼出時には、此れの`~entry~list$内に［
`名前$fe ~EQ %name
］なる`~entry$は［
在るならば ~T ／
無いならば ~F
］を返さ~MUST。
◎
The has(name) method, when invoked, must return true if there is an entry whose name is name, and false otherwise.

	<dt>`set(name, value, filename)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The set(name, value) and set(name, blobValue, filename) methods, when invoked, must run these steps:
◎
Let value be value if given, and blobValue otherwise.
</p>

		<ol>
			<li>
%~entry ~LET `~entryを作成する$( %name, %value, %filename )
— %filename は与えられていない場合は省略する
◎
Let entry be the result of creating an entry with name, value, and filename if given.
</li>
			<li>
~IF［
此れの`~entry~list$内に［
`名前$fe ~EQ %name
］なる`~entry$は在る
］
⇒
それらの`~entry$のうち，最初のものを %~entry で置換し, 他はすべて除去する
◎
If there are any entries in context object’s list of entries whose name is name, then replace the first such entry with entry and remove the others.
</li>
			<li>
~ELSE
⇒
此れの`~entry~list$に %~entry を付加する
◎
Otherwise, append entry to context object’s list of entries.
</li>
		</ol>
	</dd>
	<dd>
◎
The reason there is an argument named value as well as blobValue is due to a limitation of the editing software used to write the XMLHttpRequest Standard.
</dd>
</dl>

<p>
`反復される値ペア$の
( key, value )
は、`~entry~list$内の各`~entry$の
( `名前$fe, `値$fe )
とする。
◎
The value pairs to iterate over are the entries with the key being the name and the value the value.
</p>


	</section>
	<section id="interface-progressevent">
<h2 title="Interface ProgressEvent">6. ~interface `ProgressEvent^I</h2>

<pre class="idl">
[<dfn id="dom-progressevent-progressevent">Constructor</dfn>(`DOMString$I %type, optional `ProgressEventInit$I %eventInitDict),
 `Exposed$=(Window,DedicatedWorker,SharedWorker)]
interface <dfn id="progressevent">ProgressEvent</dfn> : `Event$I {
  ~RA boolean `lengthComputable$m;
  ~RA unsigned long long `loaded$m;
  ~RA unsigned long long `total$m;
};

dictionary `ProgressEventInit@I : `EventInit$I {
  boolean `lengthComputable@mb = false;
  unsigned long long `loaded@mb = 0;
  unsigned long long `total@mb = 0;
};</pre>


<p>
`ProgressEvent$I ~interfaceを利用する`~event$は、何らかの進捗を指示する。
◎
Events using the ProgressEvent interface indicate some kind of progression.
</p>

<dl class="idl-def">
	<dt>`lengthComputable@m</dt>
	<dt>`loaded@m</dt>
	<dt>`total@m</dt>
	<dd>
これらのいずれも，取得子は、それぞれの初期化-時の値を返さ~MUST。
◎
The lengthComputable, loaded, and total attributes must return the value they were initialized to.
</dd>
</dl>


		<section id="firing-events-using-the-progressevent-interface">
<h3 title="Firing events using the ProgressEvent interface">6.1. `ProgressEvent^I ~interfaceを利用する~eventの発火</h3>

<div class="p">
<p>
%target に向けて，名前 %e の
`進捗~eventを発火する@
ときは、所与の
( %伝送量, %長さ )
に対し，
%target に向けて次の様に初期化された`~eventを発火する$：
</p>

<ul ><li>`ProgressEvent$I を利用する
</li><li>~event名 %e
</li><li>`loaded$m 属性~値 ~SET %伝送量
</li><li>`lengthComputable$m 属性~値 ~SET ［
%長さ ~NEQ 0 ならば ~T ／
~ELSE_ ~F
］
</li><li>`total$m 属性~値 ~SET %長さ
</li></ul>

<p class="trans-note">【
%target を省略してこの手続きを呼出している所では、暗黙的に，その文脈における
`XMLHttpRequest$I ~objを与えていると見受けられる。
】</p>

◎
To fire a progress event named e at target, given transmitted and length, means to fire an event named e at target, using ProgressEvent, with the loaded attribute initialized to transmitted, and if length is not 0, with the lengthComputable attribute initialized to true and the total attribute initialized to length.
</div>

		</section>
		<section id="suggested-names-for-events-using-the-progressevent-interface">
<h3 title="Suggested names for events using the ProgressEvent interface">6.2. `ProgressEvent^I ~interfaceを利用する~eventに推挙される名前</h3>

~INFORMATIVE

<p>
`ProgressEvent$I ~interfaceを利用する`~event$に推挙される， `type$m 属性の値を、下の一覧に要約する。
仕様の編集者が，その仕様に固有の仔細に応じて~~調整することは自由であるが、問題に馴染みのある人達からの~~意見を汲むために，その用法について WHATWG ~communityにて論をかわすことが強く奨励される。
◎
The suggested type attribute values for use with events using the ProgressEvent interface are summarized in the table below. Specification editors are free to tune the details to their specific scenarios, though are strongly encouraged to discuss their usage with the WHATWG community to ensure input from people familiar with the subject.
</p>

<table>

<thead><tr><th>`type$m 属性~値◎type attribute value
<th>~~説明◎Description
<th>回数◎Times
<th>時機◎When
</thead>

<tbody><tr><th>`loadstart$et
<td>
進捗が開始された。
◎
Progress has begun.
<td>1 回◎Once.
<td>最初。◎First.

<tr><th>`progress$et
<td>
進捗~中。
◎
In progress.
<td>1 回以上◎Once or more.
<td>
`loadstart$et が`配送-$された後。
◎
After loadstart has been dispatched.

<tr><th>`error$et
<td>進捗に失敗した。◎Progression failed.
<td rowspan="4" style="min-width:6em;">
高々 1 回<br>
（排他的）
◎
Zero or once (mutually exclusive).
<td rowspan="4">
最後の `progress$et が`配送-$された後。
◎
After the last progress has been dispatched.

<tr><th>`abort$et
<td>進捗は終了された。◎Progression is terminated.

<tr><th>`timeout$et
<td>
進捗は時間~切れのため終了された。
◎
Progression is terminated due to preset time expiring.

<tr><th>`load$et
<td>進捗は成功裡に終わった。◎Progression is successful.

<tr><th>`loadend$et
<td>進捗は停止された。◎Progress has stopped.
<td>1 回◎Once.
<td>
`error$et, `abort$et, `timeout$et, `load$et のいずれかが`配送-$された後。
◎
After one of error, abort, timeout or load has been dispatched.

</tbody></table>




<p>
~event型
`error$et, `abort$et, `timeout$et, `load$et
は、互いに排他的である。
<!-- 
【これら 4 種のいずれかは 1 回 生じる】
 -->
◎
The error, abort, timeout, and load event types are mutually exclusive.
</p>

<p>
Web ~platform全般に渡り，~event型
`error$et, `abort$et, `timeout$et, `load$et
の `bubbles$m および `cancelable$m 属性は、 ~F に初期化される。
従って，一貫性を保つため、 `ProgressEvent$I ~interfaceを利用するすべての`~event$も同様にすることが推挙される。
◎
Throughout the web platform the error, abort, timeout and load event types have their bubbles and cancelable attributes initialized to false, so it is suggested that for consistency all events using the ProgressEvent interface do the same.
</p>

		</section>
		<section id="security-considerations">
<h3 title="Security Considerations">6.3. 保安~上の考慮点</h3>

<p>
非同一生成元~要請に対しては、例えば 
Fetch 標準にて定義される`~CORS~protocol$
などの，ある種の~opt-inが、 `ProgressEvent$I ~interfaceを利用する`~event$が`配送-$される前に利用される必要がある。
さもなければ、通常は得られる筈の無い情報（例えば~sizeなど）まで，露わになるので。
`FETCH$r
◎
For cross-origin requests some kind of opt-in, e.g. the CORS protocol defined in the Fetch Standard, has to be used before events using the ProgressEvent interface are dispatched as information (e.g. size) would be revealed that cannot be obtained otherwise. [FETCH]
</p>

		</section>
		<section id="example">
<h3 title="Example">6.4. 用例</h3>

<div class="example" id="example-progress-events">

<p>
次の例では、 `XMLHttpRequest$I に，前~節にて定義された概念が組合わされ、`~fetching$の過程の表示に~HTML `progress$e 要素が利用される。
◎
In this example XMLHttpRequest, combined with concepts defined in the sections before, and the HTML progress element are used together to display the process of fetching a resource.
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;title&gt;Waiting for Magical Unicorns&lt;/title&gt;
&lt;progress id=p&gt;&lt;/progress&gt;
&lt;script&gt;
  var %progressBar = document.getElementById("p"),
      %client = new XMLHttpRequest()
  %client.open("GET", "magical-unicorns")
  %client.onprogress = function(%pe) {
    if(%pe.lengthComputable) {
      %progressBar.max = %pe.total
      %progressBar.value = %pe.loaded
    }
  }
  %client.onloadend = function(%pe) {
    %progressBar.value = %pe.loaded
  }
  %client.send()
&lt;/script&gt;
</pre>

<p>
もちろん，全部的に~~機能する~codeは、より精巧かつ，~network~errorや末端利用者からの終了-要請など，より多くの局面に対応するものになるだろうが。
◎
Fully working code would of course be more elaborate and deal with more scenarios, such as network errors or the end user terminating the request.
</p>

</div>



		</section>
	</section>

</main></div><!-- MAIN0/MAIN -->

	<section id="references">
<h2>参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>

<script type="text/plain" class="ref_data">
[COOKIES]
    A. Barth. HTTP State Management Mechanism. April 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6265 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[DOMPS]
    Travis Leithead. DOM Parsing and Serialization. URL: https://w3c.github.io/DOM-Parsing/ 
[ECMASCRIPT]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[FILEAPI]
    Arun Ranganathan; Jonas Sicking. File API. URL: https://w3c.github.io/FileAPI/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[HTTP]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7230 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MIMESNIFF]
    Gordon P. Hemsley. MIME Sniffing Standard. Living Standard. URL: https://mimesniff.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. URL: https://heycam.github.io/webidl/ 
[XML]
    Tim Bray; et al. Extensible Markup Language (XML) 1.0 (Fifth Edition). 26 November 2008. REC. URL: https://www.w3.org/TR/xml 
[XMLNS]
    Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names 
</script>


		</section>
	</section>
	<section id="acknowledgments">
<h2>謝辞</h2>

<p>
この標準に協力された、次の方々に感謝する：
</p>

<p lang="en-x-a0">
Thanks to

Addison Phillips,
Adrian Bateman,
Ahmed Kamel,
Alan Thomas,
Alex Hopmann,
Alex Vincent,
Alexey Proskuryakov,
Ali Alabbas,
Andrea Marchesini,
Asbjørn Ulsberg,
Bertrand Guay-Paquet,
Björn Höhrmann,
Boris Zbarsky,
Caitlin Potter,
Cameron McCormack,
Chris Marrin,
Christophe Jolif,
Charles McCathieNevile,
Dan Winship,
David Andersson,
David Flanagan,
David Håsäther,
David Levin,
Dean Jackson,
Denis Sureau,
Domenic Denicola,
Dominik Röttsches,
Doug Schepers,
Douglas Livingstone,
Elliott Sprehn,
Elliotte Harold,
Eric Lawrence,
Eric Uhrhane,
Erik Arvidsson,
Erik Dahlström,
Feras Moussa,
Geoffrey Sneddon,
Gideon Cohn,
Glenn Adams,
Gorm Haug Eriksen,
Håkon Wium Lie,
Hallvord R. M. Steen,
Henri Sivonen,
Hiroshige Hayashizaki,
Huub Schaeks,
Ian Davis,
Ian Hickson,
Ivan Herman,
Jake Archibald,
Jared Jacobs,
Jarred Nicholls,
Jeff Walden,
Jens Lindström,
Jim Deegan,
Jim Ley,
Joe Farro,
Jonas Sicking,
Julian Reschke,
송정기 (Jungkee Song),
呂康豪 (Kang-Hao Lu),
Karl Dubost,
Keith Yeung,
Lachlan Hunt,
Maciej Stachowiak,
Magnus Kristiansen,
Manish Goregaokar,
Marc Hadley,
Marcos Caceres,
Mark Baker,
Mark Birbeck,
Mark Nottingham,
Mark S. Miller,
Martin Hassman,
Mohamed Zergaoui,
Ms2ger,
Odin Hørthe Omdal,
Olli Pettay,
Pawel Glowacki,
Peter Michaux,
Philip Jägenstedt,
Philip Taylor,
Robin Berjon,
Rune <span title="Fabulous">F.</span> Halvorsen,
Ruud Steltenpool,
Sergiu Dumitriu,
Shivakumar Jagalur Matt,
Sigbjørn Finne,
Simon Pieters,
Stewart Brodie,
Sunava Dutta,
Takeshi Kurosawa,
Takeshi Yoshino,
Thomas Roessler,
Thomas Wisniewski,
Tom Magliery,
Travis Leithead,
triple-underscore,
Yehuda Katz,
Youenn Fablet, and
Zhenbin Xu

for their contributions to this standard.
</p>

<p>
Windows Internet Explorer にて初めて実装し、 <code >XMLHttpRequest</code> インタフェースを最初に広めた Microsoft の開発者たちに特別な謝意を。
<span lang="en"
>Special thanks to the Microsoft employees who first implemented the XMLHttpRequest interface, which was first widely deployed by the Windows Internet Explorer browser.
</span></p>

<p>
HTML Standard （ Web Applications 1.0 ）にて、この仕様の初期バージョンを草案化された Ian Hickson 氏に特別な謝意を。
<a href="refsHTML">[HTML]</a>
<span lang="en"
>Special thanks to Ian Hickson for drafting an initial version of this specification in
the HTML Standard (then Web Applications 1.0). [HTML]
</span></p>

<p>
<a href="https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/svgudom.html">SVG Micro DOM</a>
の一部として、元々の <code >ProgressEvent</code> クラスの草案を作成した W3C SVG WG に特別な謝意を。
<span lang="en"
>Special thanks to the W3C SVG WG for drafting the original ProgressEvent class as part of the SVG Micro DOM.
</span></p>

<p lang="en-x-a0">
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>

<p lang="en-x-a0">
Per <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>, to
the extent possible under law, the editor has waived all copyright and related or neighboring rights to this work.
</p>

	</section>
	<section id="index">
<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>
	</section>
	<section id="idl-index">
<h2 title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>
