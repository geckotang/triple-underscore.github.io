<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>XMLHttpRequest Standard （日本語訳）</title>
<meta name="keywords" content="XMLHttpRequest,XHR,HTML5,仕様,WHATWG">

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
var source_data;

COMMON_DATA.init = function(expanded){

	var options = {
		spec_status: 'LS',
		original_url: 'https://xhr.spec.whatwg.org/',
		main: 'MAIN',
		alt_refs: 'references',
		ref_id_prefix: 'refs'
	};

	if(expanded) return options;


	source_data = {
		html: E('MAIN').innerHTML,
		prefix_map: Util.getMapping('_prefix_map'),
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked 160325 spec

	return options;
}


function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		E: 'error',
		sc: 'scheme',
		AO: 'abstract',
		bug: 'bug-link',
		h: 'header',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		E: 'code',
		h: 'code',
		v: 'var',
		i: 'i',
		AO: 'span',
		bug: 'span',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
//	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|%[\w~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN0', '_toc_list0');


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
//	switch(match){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		if(match[1]){
			in_idl = true;
			nesting += '</pre>';
			return '<pre class="idl">';
		} else {
			nesting += '</span>';
			return '：<span class="block">';
		}
	case '⇒！':
	}//◎
	if(in_idl) {
		result = nesting;
		in_idl = false;
	} else {
		result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	}
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
//var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'lb': // literal
	text = '`<code class="literal">' + text + '</code>`';
	break;
case 'I': // IDL interface
	if(in_idl) tag = '';
	break;
case 'm': // IDL member
//case 'hd': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	if(in_idl) tag = '';
	break;
case 'et': // event type
//	href = '~HTML-IND#event-' + key;
	break;
case 'h': // HTTP header
	break;
case 'i': // model constants
	break;
case 'v': // variables
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}
/*
if(ifc){
	if(in_idl) tag = '';
}
*/
if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>

<!-- 語彙 -->

<script type="text/plain" id="words_table">

	●DOM／IDL
引数:argument:~
属性:attribute:~
meth:method:::メソッド
obj:object:::オブジェクト
値:value:~
返値:return value:返り値
初期化-:initialize:~
初期時:initial 時:~
初期値:initial value:~
属性値:attribute value:~
数値:numeric value:~
新たな:new:~
ツリー:tree:~
構築子:constructor::~::コンストラクタ
内容:content:~
要素:element:~
文書:document::~
例外:exception:~
投出:throw:~
公開-:expose:~

関数:function:~
garbage-collect:garbage collect:::ガーベジコレクト
大域:global::~::グローバル
環境:environment:~
大域環境:global environment:global 環境:~::グローバル環境
文書環境:document environment:document 環境:~
型:type:~
多重定義:overload:~
構築-:construct:~
継承-:inherit:~

JSON:
	●event process

event::::イベント
発火:fire:~
handler::::ハンドラ
interface::::インタフェース
list::::リスト
listener::::リスナ

進捗:progress::~::プログレス
task::::タスク
極小task:microtask:::極小タスク:マイクロタスク
source::::ソース
源:source::~::ソース
待行列:queue::待ち行列::キュー
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ

	段:step:~
下位手続き:substeps:~
手続き:steps:~
取扱う:handle する:取り扱う

処理:process:~

付加-:append:~
省略-:omit:~

同期的:synchronous:~
同期:synchronous:~
worker:::ワーカ

取得子:getter:~
取得-:get:~
設定-:set:~
被設定時:被 set 時:~
	設定子:setter:~

設定群:settings::~
関連する:relevant な::~
担当の:responsible::~

	●
URL:
	JSON
	API
backtick::::バッククォート
prescan:
eof:end-of-file:file 終端::ファイル終端
data::::データ
charset:
	charset:::文字集合:文字セット
基底:base::~
byte::::バイト
文字大小無視:case-insensitive:~
文字:character:~
復号-:decode::~::デコード
配送-:dispatch:~
空:empty:~
空文字列:empty string:~
文字列:string:~
小文字化:lowercase 化:~
符号化-:encode::~::エンコード
符号化器:encoder::~::エンコーダ
符号化方式:encoding::~::エンコーディング
	符号化法:encoding::~::エンコーディング
確定的:definite:~
直列化:serialize::~::シリアライズ
直列化器:serializer::~::シリアライザ
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
生成規則:production:~
解析済URL:parsedURL:解析済み URL
妥当:valid:~
名前空間整形式:namespace well formedness:名前空間 整形式
	settings object
規則:rule:~
literal::::リテラル

parameter::::パラメタ
entry::::エントリ
error::::エラー


	●状態値
unsent:
opened:
headers-received:headers received
loading:
done:

	●XHR
header::::ヘッダ
	headers::::ヘッダリスト
method::::メソッド
	対::ペア
要請:request::~::リクエスト
応答:response::~::レスポンス
資源:resource::~:リソース
fetch:
fetching:::fetch 処理
種別:type:~

認証:authentication::~
client::::クライアント
proxy::::プロキシ
server::::サーバ
cookie::::クッキー

form_data_set:form data set::form data 集合:フォームデータ集合
status::::ステータス
message::::メッセージ
文脈:context::~

失敗-:fail::~
失敗:failure::~
成功:success::~
取消す:cancel する::~:キャンセルする

合致:match::~::マッチ
名前:name::~
名:name::~
network::::ネットワーク
	ネットワーク処理:networking
生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン
非同一生成元:cross-origin::~::クロスオリジン
上書き:override::~
予行:preflight::~::プリフライト
	生成元省略:omit-<code>Origin</code>-header::<code>Origin</code> ヘッダ省略
行先:destination::~
redirect::::リダイレクト
referrer::::リファラ
受信-:receive:~
送信-:send:~
状態:state::~

転送:transfer::~
伝送-:transmit::~
伝送量:transmitted::~
伝送済み:transmitted::~
伝送:transmission::~
更新:update:~
	発行:make:~

匿名:anonymous:~
本体:body::~::ボディ
通知:notification:~

upload:::::アップロード
host::::ホスト
username::::ユーザ名
password::::パスワード
stream::::ストリーム
code::::コード
protocol::::プロトコル
活動:activity::~
資格証:credentials::資格証明情報::クレデンシャル
資格証省略:omit credentials:credentials 省略:資格証明情報 省略::クレデンシャル省略
非安全:unsafe::~
登録-:register:~
	破棄:discard:~
指示-:indicate:~
結合-:combine::~
最終:final::~
fallback::::フォールバック
既定:default:~
省略可:optional:~
	＊optional:::オプション

filename:::file 名:ファイル名

長th:length:長さ

flag::::フラグ
mode::::モード
相対:relative::~
完了-:complete:~
内容型:content type::~

終了-:terminate:~
終了事由:termination reason:~
停止:stop:~
致命的:fatal:~
時間切れ:timeout::~
	制限時間:timeout:~
時間:time:~

接続:connection:~
証明書:certificate:~
省略不可:never:~
禁止:forbidden:~

arraybuffer::::配列バッファ

起動-:initiate:~
	着手

	load:::
読込まれ:load され:読み込まれ
結付けら:associate さ:結び付けら
所与の:given:与えられた
順序付けら:order さ:~
被呼出時:被 invoke 時:~
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
呼出し:invoking:呼び出し
呼出せば:invoke すれば:呼び出せば

充足-:fulfill::~
却下-:reject::~
	読取った:read した::読み取った
読取る:read する::読み取る
読取:read::読み取り
call:
読取器:reader::読み取り器::リーダ

全部的:full::~
作動中:active::~::アクティブ


	●仕様
仕様:spec:~
	specification
標準:standard:~
support::::サポート
UA:user agent::UA::ユーザエージェント
利用者:user::~::ユーザ
作者:author::~
末端利用者:end user::~::エンドユーザ
platform::::プラットフォーム
旧来:legacy:旧来の
非旧来:non-legacy:旧来のものでない
歴史的:historical:~
歴史:history:~
考慮点:considerations:~
community::::コミュニティ
特色機能:feature:~
拡張性:extensibility:~
拡張:extension:~
適合性:conformance:~
意図的:intentional:~
節:section:~
要覧:summary:~
規約:conventions:~
実装-:implement:~
実装:implementation:~
	バージョン:version:~
機能性:functionality:~
中止:abort::~
algo:algorithm:::アルゴリズム
局面:scenario:~
推挙-:suggest:~
	＊
定めら:state さ:~
壊さな:break しな:~
強く:strong に:~
奨励-:encourage:~
保障-:guarantee:~
概念:concept:~

	●
	割り当てる:allocate
script::::スクリプト
text::::テキスト
成功裡:successfull:~

	作成-:create:~
無視:ignore:~
	可用:available:~
表現-:represent:~
終端-:end:~
	相対的:relative:~
解放-:release:~
明示的:explicit:~
置換-:replace:~
適用-:apply:~
参照:reference:~
参照先:referenced:~

精巧:elaborate:~
制約-:restrict:~
追加-:append:~
変数:variable:~
変換-:convert:~
	継続:continue:~
経過-:pass:~
除外-:exclude:~
素片除外:exclude fragment:fragment 除外:~::フラグメント除外
情報:information:~
除去-:remove:~

単純:simple:~
	簡単:simple:~
保安:security::~::セキュリティ
opt-in::::オプトイン
property::::プロパティ
prop:property:::プロパティ
buffer::::バッファ
	typographic::
変更-:change:~
変化-:change:~
決定-:determine:~
理由:reason:~
ゼロ:zero:~
制御:control:~
定義-:define:~
定義:definition:~
不能化-:disable:~
目的:purpose:~
提供-:provide:~
一貫性:consistency:~

抽出-:extract:~
size::::サイズ
排他的:mutually exclusive:~
正規化-:normalize:~
信頼-:rely:~
既知の:known:~
走らす:run する:走らせる
走らせ:run し:走らせ

</script>

<!--%他の単語
	指定-:specify:~
〜の後:after
あてがわれ:assigned
すべての:all
やりとり:interaction
キーワード: 1
ミリ秒:millisecond:~ #2
	単位/数
メーリングリスト: 1
リンク付きで:cross-linked 1
一覧:table:~ #1

	#1
要約:summarize:~
一連: 1
一部: 2
不具合が生じた:went wrong #2
~~互換性: 1
仔細: 1
他の場合:otherwise
以下: 1

何年: 1
併合: 1
例:example:~
個~以上: 1
入力: 4
全体:
全般:Throughout #1
共通:shared 1
処理中:operate #1
出現: 1
利用:use #15
何の効果もない:has no effect #1
勧める:encouraged
区切-:separate #3
単独: 2
~~収集:gather #1
可能: 1
可読性: 1
各種: 2
同様: 2
同類: 1
含-:include
呼び出す:invoke
唯一: 1
回以上: 1
回数:times #1
関心のある主体:interested parties
図式:diagram 1
固有の仔細:specific scenarios #1
場合: 49
壊-:breaking
大文字化: 1
存在: 2
完全に機能:fully working #1
対応: 3
序論:introduction
引用: 1

当初: 1
必要: 1
意味: 2
成果: 1
括弧内: 1
~~指定: 1

時機:when #2
時点: 5
最初の:first #4
最後の:last #2
最終的: 2
機能: 2
あいにく:unfortunate #1
注記: 1
他が定められない限り:Unless stated otherwise
現在の:current #3
用例:example #2
用法:usage #2
用語:trem／terminology 3
目次: 1

単位: 1
移管:move 2
範囲:range #1
簡単: 1
経緯: 1

結果:result #26
編集者:editor:~ #1
自由:free #1
草案:draft 3
表示:display #1
複数個:multiple #1
要約:summary／summarize #2
見えてしまう:reveal
規定: 3
観点: 1
解釈: 1
計測:measure #1
説明:description #1
調べる:check
調整:tune #1
警告: 1
起点: 1
返す:return
追跡~済:have been followed #1
通常: 1
連結: 4
進行:ongoing #1
過程:process #1
重複:twice #1
開始:start, initiate, begin: #2
開発:develop 2
開発ツール:development tool
開発者: 1
際限のない:infinite #1
非:non
類似: 1
問題に馴染みのある人達の意見を汲む:ensure input from people familiar with the subject #1
絞り込-:filter
 -->


<!--% 置換データ -->
<script type="text/plain" id="words_table1">
U16:[EnsureUTF16] DOMString
USVS:USVString
DS:DOMString
US:unsigned short
RA:readonly attribute

BROWSERS:https://html.spec.whatwg.org/multipage/browsers.html
Content-Type:<var>Content-Type</var>

send:<code>send()</code> 
form_urlencoded:<code>application/x-www-form-urlencoded</code>

</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">

I.Document:~DOM4#document
I.Event:~DOM4#event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#eventinit
I.EventTarget:~DOM4#eventtarget
I.File:~FILEAPI#file
I.FormData:#formdata
I.FormDataEntryValue:#formdataentryvalue
I.ProgressEvent:#progressevent
I.ProgressEventInit:#progresseventinit
I.XMLHttpRequest:#xmlhttprequest
I.XMLHttpRequestEventTarget:#xmlhttprequesteventtarget
I.XMLHttpRequestResponseType:#xmlhttprequestresponsetype
I.XMLHttpRequestUpload:#xmlhttprequestupload
I.BodyInit:~FETCH#bodyinit
I.Window:~BROWSERS#window
I.HTMLFormElement:~HTML5/forms.html#htmlformelement
I.Blob:~FILEAPI#blob
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer

	Constructor:#dom-formdata
	Constructor:#dom-xmlhttprequest
	Constructor:https://dom.spec.whatwg.org/#concept-event-constructor

m.XMLHttpRequest:#dom-xmlhttprequest
m.FormData:#dom-formdata

m.DONE:#dom-xmlhttprequest-done
m.HEADERS_RECEIVED:#dom-xmlhttprequest-headers_received
m.LOADING:#dom-xmlhttprequest-loading
m.OPENED:#dom-xmlhttprequest-opened
m.UNSENT:#dom-xmlhttprequest-unsent

m.onabort:#handler-xhr-ononabort
m.onerror:#handler-xhr-ononerror
m.onload:#handler-xhr-ononload
m.onloadend:#handler-xhr-ononloadend
m.onloadstart:#handler-xhr-ononloadstart
m.onprogress:#handler-xhr-ononprogress
m.onreadystatechange:#handler-xhr-ononreadystatechange
m.ontimeout:#handler-xhr-onontimeout

m.abort:#dom-xmlhttprequest-abort
m.timeout:#dom-xmlhttprequest-timeout
m.type:~DOM4#dom-event-type
	＊m.type:~FILEAPI#dfn-type
m.append:#dom-formdata-append
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.delete:#dom-formdata-delete
m.get:#dom-formdata-get
m.getAll:#dom-formdata-getall
m.getAllResponseHeaders:#dom-xmlhttprequest-getallresponseheaders
m.getResponseHeader:#dom-xmlhttprequest-getresponseheader
m.has:#dom-formdata-has
m.lengthComputable:#dom-progressevent-lengthcomputable
m.loaded:#dom-progressevent-loaded
m.name:~FILEAPI#dfn-name
m.open:#dom-xmlhttprequest-open
m.overrideMimeType:#dom-xmlhttprequest-overridemimetype
m.prescan:~HTML5/syntax.html#prescan-a-byte-stream-to-determine-its-encoding
m.readyState:#dom-xmlhttprequest-readystate
m.response:#dom-xmlhttprequest-response
m.responseText:#dom-xmlhttprequest-responsetext
m.responseType:#dom-xmlhttprequest-responsetype
m.responseURL:#dom-xmlhttprequest-responseurl
m.responseXML:#dom-xmlhttprequest-responsexml
m.send:#dom-xmlhttprequest-send
m.set:#dom-formdata-set
m.setRequestHeader:#dom-xmlhttprequest-setrequestheader
m.status:#dom-xmlhttprequest-status
m.statusText:#dom-xmlhttprequest-statustext
m.total:#dom-progressevent-total
m.upload:#dom-xmlhttprequest-upload
m.withCredentials:#dom-xmlhttprequest-withcredentials

et.abort:#event-xhr-abort
et.progress:#event-xhr-progress
et.error:#event-xhr-error
et.load:#event-xhr-load
et.loadend:#event-xhr-loadend
et.loadstart:#event-xhr-loadstart
et.readystatechange:#event-xhr-readystatechange
et.timeout:#event-xhr-timeout

e.progress:~HTML5/forms.html#the-progress-element

AO.ReadFromReadableStreamReader:~STREAMS#read-from-readable-stream-reader

利用者 資格証:#user-credentials
匿名~flag:#anonymous-flag
時間切れ停止~flag:#stop-timeout-flag

要請~method:#request-method
要請~URL:#request-url
作者による要請~header:#author-request-headers
要請~本体:#request-body
要請を終了-:#terminate-the-request
同期~flag:#synchronous-flag
~upload完了-~flag:#upload-complete-flag

応答 MIME 型:#response-mime-type
上書き MIME 型:#override-mime-type
最終 MIME 型:#final-mime-type
応答~charset:#response-charset
上書き~charset:#override-charset
最終~charset:#final-charset

応答 ArrayBuffer ~obj:#response-arraybuffer-object
応答 Blob ~obj:#response-blob-object
応答 Document ~obj:#response-document-object
応答 JSON ~obj:#response-json-object

JSON 応答:#json-response
~arraybuffer応答:#arraybuffer-response
blob 応答:#blob-response
文書~応答:#document-response
~text応答:#text-response


進捗~eventを発火する:#concept-event-fire-progress

応答~header:#concept-response-header
応答:#response
要請:#request
	＊
受信済み~byte列:#received-bytes

~send~flag:#send-flag
~entry:#concept-formdata-entry
fe.名前:#concept-formdata-entry-name
fe.値:#concept-formdata-entry-value

要請~error手続き:#request-error-steps
~errorを取扱う:#handle-errors
~eofを取扱う:#handle-response-end-of-file

状態:#concept-xmlhttprequest-state

応答を処理:~FETCH#process-response
要請の本体を処理:~FETCH#process-request-body
要請の~eofを処理:~FETCH#process-request-end-of-file

読取器を取得-:~FETCH#concept-get-reader
すべての~byte列を読取る:~FETCH#concept-read-all-bytes-from-readablestream

終了-:~FETCH#concept-fetch-terminate
~fetching:~FETCH#concept-fetch
抽出-:~FETCH#concept-bodyinit-extract
禁止~method:~FETCH#forbidden-method
禁止~header名:~FETCH#forbidden-header-name
名前:~FETCH#concept-header-name
値:~FETCH#concept-header-value
正規化-:~FETCH#concept-header-value-normalize
結合済みの値:~FETCH#concept-header-value-combined
~header:~FETCH#concept-header
~header~list:~FETCH#concept-header-list
追加-:~FETCH#concept-header-list-append
結合-:~FETCH#concept-header-list-combine
整列して結合-:~FETCH#concept-header-list-sort-and-combine
~network~error:~FETCH#concept-network-error

rq.要請:~FETCH#concept-request
rq.~header~list:~FETCH#concept-request-header-list
rq.本体:~FETCH#concept-request-body
rq.~method:~FETCH#concept-request-method
rq.~mode:~FETCH#concept-request-mode
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.生成元:~FETCH#concept-request-origin
rq.~referrer:~FETCH#concept-request-referrer
rq.url:~FETCH#concept-request-url
rq.URL 資格証 利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.~client:~FETCH#concept-request-client
rq.行先:~FETCH#concept-request-destination
rq.~method:~FETCH#concept-method
rq.同一生成元 data-URL ~flag:~FETCH#same-origin-data-url-flag
rq.同期~flag:~FETCH#synchronous-flag
rq.非安全~要請~flag:~FETCH#unsafe-request-flag
rq.正規化-:~FETCH#concept-method-normalize
rq.CORS予行~利用~flag:~FETCH#use-cors-preflight-flag


rs.応答:~FETCH#concept-response
rs.url:~FETCH#concept-response-url
rs.本体:~FETCH#concept-response-body
rs.終了事由:~FETCH#concept-response-termination-reason
rs.~header~list:~FETCH#concept-response-header-list
rs.~status:~FETCH#concept-response-status
rs.~status~message:~FETCH#concept-response-status-message

	FETCH.force-origin-header-flag:生成元省略~flag

文字大小無視~byte列:~FETCH#case-insensitive-byte-sequence
CORS ~protocol:~FETCH#cors-protocol

~stream:~FETCH#concept-body-stream
伝送済み~byte数:~FETCH#concept-body-transmitted
総~byte数:~FETCH#concept-body-total-bytes

	DOM. → -DOM
文書:~DOM4#concept-document
内容型:~DOM4#concept-document-content-type
~URL:~DOM4#concept-document-url
~event~listener:~DOM4#concept-event-listener
投出:~DOM4#concept-throw
~eventを発火する:~DOM4#concept-event-fire
配送-:~DOM4#concept-event-dispatch
符号化方式:~DOM4#concept-document-encoding
HTML 文書:~DOM4#html-document
doc.種別:~DOM4#concept-document-type
ASCII 小文字化:~DOM4#converted-to-ascii-lowercase
~event:~DOM4#concept-event
文脈~obj:~DOM4#context-object

	utf-16:~ENCODING#utf-16
	utf-16be:~ENCODING#utf-16be
utf-8:~ENCODING#utf-8
符号化-:~ENCODING#encode
	encoder-error
~error:~ENCODING#error
復号-:~ENCODING#decode
utf-8 復号-:~ENCODING#utf-8-decode
utf-8 符号化-:~ENCODING#utf-8-encode

Unicode に変換-:~WEBIDL#dfn-obtain-unicode
	title="convert a DOMString to a sequence of Unicode characters"
反復される値ペア:~WEBIDL#dfn-value-pairs-to-iterate-over
~interface~obj:~WEBIDL#dfn-interface-object

直列化-:~URLSpec#concept-url-serializer
構文解析-:~URLSpec#concept-url-parser
~host:~URLSpec#concept-url-host
~username:~URLSpec#concept-url-username
~password:~URLSpec#concept-url-password
	I.URL:~URLSpec#url
~form_urlencoded 直列化器:~URLSpec#concept-urlencoded-serializer
~usernameを設定する:~URLSpec#set-the-username
~passwordを設定する:~URLSpec#set-the-password


	HTML5

~task:~WAPI#concept-task
~task源:~WAPI#task-source
~task待行列:~WAPI#task-queue
~taskを待入する:~WAPI#queue-a-task
極小taskを待入する:~WAPI#queue-a-microtask
~event~handler:~WAPI#event-handlers
~event~handler ~event型:~WAPI#event-handler-event-type
~network用~task源:~WAPI#networking-task-source
関連する設定群~obj:~WAPI#relevant-settings-object-for-a-global-object
大域~obj:~WAPI#global-object
担当の文書:~WAPI#responsible-document
API 基底~URL:~WAPI#api-base-url
~referrer~source:~WAPI#referrer-source
~entry設定群~obj:~WAPI#entry-settings-object



全部的に作動中:~BROWSERS#fully-active
生成元:~BROWSERS#origin
同一生成元:~BROWSERS#same-origin

~form_data_setを構築-:~HTML5/forms.html#constructing-form-data-set
妥当な MIME 型:~HTMLINFRA#valid-mime-type
並列的:~HTMLINFRA#in-parallel

</script>


<!-- 
	h. → handler-xhr-
	h.onloadstart:onloadstart
	h.onprogress:onprogress
	h.onabort:onabort
	h.onerror:onerror
	h.onload:onload
	h.ontimeout:ontimeout
	h.onloadend:onloadend
	h.onreadystatechange:onreadystatechange
	ev. → event-xhr-
	ev.readystatechange:readystatechange
	ev.loadstart:loadstart
	ev.progress:progress
	ev.abort:abort
	ev.error:error
	ev.load:load
	ev.timeout:timeout
	ev.loadend:loadend
	DOM. → -DOM
	DOM.eventtarget:EventTarget
	DOM.document:Document
	DOM.syntaxerror:SyntaxError
	DOM.securityerror:SecurityError
	DOM.invalidaccesserror:InvalidAccessError
	DOM.invalidstateerror:InvalidStateError
	DOM.syntaxerror:SyntaxError
	DOM.timeouterror:TimeoutError
	DOM.networkerror:NetworkError
	DOM.aborterror:AbortError
	DOM.event:Event
	DOM.eventinit:EventInit
	DOM.dom-event-type" title="dom-Event-type:type
	DOM.dom-event-bubbles" title="dom-Event-bubbles:bubbles
	DOM.dom-event-cancelable" title="dom-Event-cancelable:cancelable

<code title="http-origin">Origin</code>
	<code title="http-authorization">Authorization</code>
	:<a href="http://dvcs.w3.org/hg/streams-api/raw-file/tip/Overview.htm#widl-Stream-type">type</a>
	:<a href="http://html5.org/specs/dom-parsing.html#concept-serialize">直列化</a>

-->





<!--%style -->

<!-- removed
-->
<style>
.critical {
    margin: 1em;
    border: thick double #F00;
    padding: 1em;
    background: none repeat scroll 0% 0% #FFC;
}

</style>

<style>

ul.brief > li {
	margin:0;
}

i {
	text-decoration: underline;
}


</style>

<!-- 
ol {
	border-left: solid 3px #CCDFED;
}
.algodef {
	background: #FEE;
}

 -->

</head>

<body>

<!--%UI -->
<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">

<h1>XMLHttpRequest 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://www.whatwg.org/" >WHATWG</a>
による，副題の日付時点の
<a href="https://xhr.spec.whatwg.org/" >XMLHttpRequest Standard</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p id="_dates">
更新： <time>2016-06-10</time>
（公開： <time>2012-10-25</time>）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>


<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,
PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9
IjAgMCAxMDAgMTAwIiBzdHJva2U9IiMzYzc5MGEiPgo8Y2lyY2xlIGN4PSI1MCIg
Y3k9IjUwIiByPSI0NSIgc3Ryb2tlLXdpZHRoPSIxMCIgZmlsbD0iI2ZmZiIvPgo8
cGF0aCBzdHJva2Utd2lkdGg9IjEuNSIgZmlsbD0ibm9uZSIgZD0iTTE3LDY2QzIx
LDYzLDQzLDc2LDM3LDY4TTMzLDc1YTgsOCwwLDAsMTYsOE01MCw4NEM2OCw0OSw1
Nyw5MCw2Myw3Nyw2Niw1OCw3NSw4Nyw3MSw2OSw2OCw2Miw3NCw2NSw3OCw2Nk02
NSw2MkM1Nyw2NCw2NCw3MSw2Nyw2NE00Nyw2MEw0Myw2OSw0NCw2OSw1MSw2Nk01
MCw1MkM0Nyw2MCw1Myw1NCw1Miw2MCw1MCw2OCw2Miw2MCw1Nyw2Miw1OCw1NCw2
NSw2MCw1OSw1NCw0OCw0MiwyMCwyNSwyOSwzN00yOSw0MEMyMyw1MCwyNyw0Nywy
OSw0OE0zMywzN0MyOCw0MiwzNywzOCwzNSw0MiwzNCw0NCwzMCwzOCwzMiw0OCwz
MSw1MCwzNiw1MiwyOCw1ME0zMiw1M0wyOCw1Mk0zMCw1M0MyOCw1NSwyNSw1Nywz
MCw2MSwzMiw2MiwzMiw2NSwzOCw2Miw0MCw2MSw0Myw2Myw0NCw1Nyw0NCw1Niw0
OCw1Miw0NCw0OEw0NSw0NSw0MSw0Miw0MCw0Myw0MSw0NywzOSw1MCwzNSw1MU0z
MiwzMUM0MywzMCw1MCwxNiw2NCwyM000MywzN0M1NCwyOCw0OSw1Niw2OSw0OCw4
Miw0MCw3OCwyMSw2OCwyMEw2OCwyNkM3MiwyOSw3MiwyOSw3MiwzMyIvPgo8L3N2
Zz4K"
></a>

<h1 id="xmlhttprequest-ls">XMLHttpRequest</h1>
<h2>Living Standard — 最終更新 2016 年 6 月 7 日</h2>

<dl>
	<dt>Participate:</dt>
	<dd><a href="https://github.com/whatwg/xhr">GitHub whatwg/xhr</a>
 (<a href="https://github.com/whatwg/xhr/issues/new">file an issue</a>,
 <a href="https://github.com/whatwg/xhr/issues">open issues</a>,
 <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WebAppsWG&amp;component=XHR&amp;resolution=---">legacy open bugs</a>)
	<dd><a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a></dd>

	<dt>Commits:</dt>
	<dd><a href="https://github.com/whatwg/xhr/commits">GitHub whatwg/xhr/commits</a></dd>
	<dd><a href="https://twitter.com/xhrstandard">@xhrstandard</a></dd>


	<dt id="xmlhttprequest-tests">Tests:</dt>
	<dd>
<a href="https://w3c-test.org/XMLHttpRequest/">XMLHttpRequest tests</a> are hosted in
the <a href="https://github.com/w3c/web-platform-tests/">W3C Web platform testsuite</a>
— contributions welcome!</dd>

	<dt>各国語翻訳（非規範的）</dt>
	<dd>日本語（このページ）</dd>

</dl>


</header>

<div id="MAIN" style="display:none;">



	<section id="specabstract">
<h2>要約</h2>

<p>
XMLHttpRequest は、~clientと~server間の~data転送のための，~client側の~script機能を提供する API を定義する。
<span lang="en">
XMLHttpRequest defines an API that provides scripted client functionality for transferring data between a client and a server.
</span></p>

	</section>

<nav class="toc" id="toc">
<h2 title="Table of Contents">目次</h2>
<ol id="_toc_list0"></ol>
</nav>

<main id="MAIN0">

	<section id="introduction">

<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
`XMLHttpRequest$I ~objは、`~fetching$（~~資源取得）のための API である。
◎
The XMLHttpRequest object is an API for fetching resources.
</p>

<p>
`XMLHttpRequest$I という名前は歴史的なものであり、
<span class="trans-note">【 “XML” の部分は】</span>
その機能性と何ら関わりは無い。
◎
The name XMLHttpRequest is historical and has no bearing on its functionality.
</p>
  <!-- XXX need to improve point 2 -->

  <div class="example">
<p>
~networkを通した~fetchで得られた XML 文書の~dataに対して何かを行う，簡単な~code：
◎
Some simple code to do something with data from an XML document fetched over the network:
</p>

<pre>function processData(%data) {
  /* <span class="comment">
~dataを~~処理する
◎
taking care of data
</span> */
}

function handler() {
  if(this.status == 200 &amp;&amp;
    this.responseXML != null &amp;&amp;
    this.responseXML.getElementById('test').textContent) {
    /* <span class="comment">成功！◎success!</span> */
    processData(this.responseXML.getElementById('test').textContent);
  } else {
    /* <span class="comment">
何らかの不具合が生じている
◎
something went wrong
</span> */
    …
  }
}

var %client = new XMLHttpRequest();
%client.onload = handler;
%client.open("GET", "unicorn.xml");
%client.send();
</pre>

<p>
単に~serverに~messageを残す：
◎
If you just want to log a message to the server:
</p>

<pre>function log(message) {
  var %client = new XMLHttpRequest();
  %client.open("POST", "/log");
  %client.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
  %client.send(message);
}
</pre>

<p>
あるいは、~serverにある文書の~statusを調べる：
◎
Or if you want to check the status of a document on the server:
</p>

<pre>function fetchStatus(%address) {
  var %client = new XMLHttpRequest();
  %client.onload = function() {
    /* <span class="comment">
~network~errorが生じている場合の結果は信頼できないことがある。
◎
in case of network errors this might not give reliable results
</span> */
    returnStatus(this.status);
  }
  %client.open("HEAD", %address);
  %client.send();
}
</pre>
  </div>


		<section id="specification-history">

<h3 title="Specification history">1.1. 仕様の歴史</h3>

<p>
`XMLHttpRequest$I ~objは、当初は WHATWG による， HTML の（何年も前の、 Microsoft による実装に基づく）成果として定義された。
それは 2006 年には W3C に移管された。
`XMLHttpRequest$I に対する拡張（すなわち、進捗~eventと非同一生成元~要請）は、 2011 年の終わりまでは別の草案（ XMLHttpRequest Level 2 ）の下で開発されていたが、その時点でこの２つの草案は `XMLHttpRequest$I に併合され，標準の観点から再び一つになった。
2012 年の終わりに，また WHATWG の下に移管されることとなった。
◎
The XMLHttpRequest object was initially defined as part of the WHATWG's HTML effort. (Based on Microsoft's implementation many years prior.) It moved to the W3C in 2006. Extensions (e.g. progress events and cross-origin requests) to XMLHttpRequest were developed in a separate draft (XMLHttpRequest Level 2) until end of 2011, at which point the two drafts were merged and XMLHttpRequest became a single entity again from a standards perspective. End of 2012 it moved back to the WHATWG.
</p>

<p>
現在の草案までに至る経緯は、次のメーリングリストにて見られる：
◎
Discussion that led to the current draft can be found in the following mailing list
archives:
</p>

<ul>
 <li><a href="https://lists.w3.org/Archives/Public/public-whatwg-archive/">whatwg@whatwg.org</a></li>
 <li><a href="https://lists.w3.org/Archives/Public/public-webapps/">public-webapps@w3.org</a></li>
 <li><a href="https://lists.w3.org/Archives/Public/public-webapi/">public-webapi@w3.org</a></li>
 <li><a href="https://lists.w3.org/Archives/Public/public-appformats/">public-appformats@w3.org</a></li>
</ul>



		</section>
	</section>
	<section id="conformance">

<h2 title="Conformance">2. 適合性</h2>

<p>
明示的に “規定でない” と記された節に加え，この仕様~内のすべての 図式, 例, 注記は、規定ではない。
他のすべては規定である。
◎
All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.
</p>

<p>
この仕様におけるキーワード：
「〜しなければ（〜しては）<em class="rfc2119">ならない</em>」 = “MUST (NOT)”,
「〜す<em class="rfc2119">べき</em>である（でない）」 = “SHOULD (NOT)”,
「〜しても<em class="rfc2119">よい</em>」 = “MAY”,
<!-- 
「<em class="rfc2119">要求される</em>」= REQUIRED,
「<em class="rfc2119" title="recommended">推奨される</em>」 = “RECOMMENDED”,
「<em class="rfc2119" title="optional">任意選択</em> 」 = “OPTIONAL”,
 -->
は、 RFC2119 に則って解釈されるものとする。
可読性のため、この仕様ではこれらの語が大文字化されて出現することはない。
`RFC2119$r
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this specification are to be interpreted as described in RFC2119. For readability, these words do not appear in all uppercase letters in this specification. [RFC2119]
</p>

		<section id="extensibility">

<h3 title="Extensibility">2.1. 拡張性</h3>

<p>
~UA, Working Group, その他の関心のある主体には、新たな特色機能について， WHATWG ~communityの場で論を交わすことが<em>強く奨励される</em>。
◎
User agents, Working Groups, and other interested parties are strongly encouraged to discuss new features with the WHATWG community.
</p>

		</section>
	</section>
	<section id="terminology">

<h2 title="Terminology">3. 各種用語</h2>

<p>
この仕様を通して，［
DOM, DOM Parsing and Serialization, Encoding, Fetch, File API, HTML, HTTP, URL, Web IDL, XML
］からの用語がリンク付きで引用される。
`DOM$r
`DOMPS$r
`FETCH$r
`ENCODING$r
`FILEAPI$r
`HTML$r
`HTTP$r
`URL$r
`WEBIDL$r
`XML$r
`XMLNS$r
◎
This specification uses terminology, cross-linked throughout, from DOM, DOM Parsing and Serialization, Encoding, Fetch, File API, HTML, HTTP, URL, Web IDL, and XML. [DOM] [DOMPS] [ENCODING] [FETCH] [FILEAPI] [HTML] [HTTP] [URL] [WEBIDL] [XML] [XMLNS]
</p>

<p>
また、
HTML `HTML$r
と同じ typographic 規約を利用する。
◎
It uses the typographic conventions from HTML. [HTML]
</p>

<p>
この仕様の目的における語
`利用者 資格証@
は、~cookie, HTTP 認証, TLS ~client証明書を意味する。
特に、それは~proxy認証や `Origin^h ~headerを指すものではない。
`COOKIES$r
<!-- XXX ref? -->
◎
The term user credentials for the purposes of this specification means cookies, HTTP authentication, and TLS client certificates. Specifically it does not refer to proxy authentication or the Origin header. [COOKIES]
</p>

	</section>

	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳では，~algoの記述に次の記号を用いる：
</p>

<div style="margin-left:2em">
~LET （~~初期化）, ~SET （代入）, ~EQ, ~NEQ （比較）, ~ON／~OFF （~flag値）,<br>
〜 （~~範囲）, { <var>…</var> } （集合）, ~IN／~NIN （集合への所属）,<br>
~IF, ~ELSE, ~ELIF, ~RET, ~THROW （実行制御）
</div>
<!-- , WHILE, FOR EACH (…), CONTINUE -->

<p>
これらの意味や定義の詳細は，~SYMBOL_DEF_REFを見よ。
</p>

<p>
~backtick（ "<code>`</code>" ）で括られた~literalは、
`FETCH$r と同様に，文字列ではなく，
<a href="https://fetch.spec.whatwg.org/#terminology">~byte列</a>を表現する。
</p>

<p>
`~header$の`名前$は，（その定義により）`文字大小無視~byte列$なので、それらの名前に対する記号 ~EQ, ~NEQ による比較（あるいは ~IN, ~NIN の定義）も，文字大小無視~byte列の同等性の定義に従うことになる。
</p>

	</section>
	<section id="interface-xmlhttprequest">

<h2 title="Interface XMLHttpRequest">4. ~interface `XMLHttpRequest^I</h2>

<pre class="idl">
[Exposed=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequestEventTarget@I : `EventTarget$I {
  // <span class="comment"><a href="#event-handlers">~event~handler</a></span>
  attribute `EventHandler$I `onloadstart$m;
  attribute `EventHandler$I `onprogress$m;
  attribute `EventHandler$I `onabort$m;
  attribute `EventHandler$I `onerror$m;
  attribute `EventHandler$I `onload$m;
  attribute `EventHandler$I `ontimeout$m;
  attribute `EventHandler$I `onloadend$m;
};

[Exposed=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequestUpload@I : `XMLHttpRequestEventTarget$I {
};

enum `XMLHttpRequestResponseType@I {
  "",
  "arraybuffer",
  "blob",
  "document",
  "json",
  "text"
};

[<a href="#dom-xmlhttprequest">Constructor</a>,
 Exposed=(Window,DedicatedWorker,SharedWorker)]
interface `XMLHttpRequest@I : `XMLHttpRequestEventTarget$I {
  // <span class="comment"><a href="#event-handlers">~event~handler</a></span>
  attribute `EventHandler$I `onreadystatechange$m;

  // <span class="comment">`状態$</span>
  const ~US `UNSENT$m = 0;
  const ~US `OPENED$m = 1;
  const ~US `HEADERS_RECEIVED$m = 2;
  const ~US `LOADING$m = 3;
  const ~US `DONE$m = 4;
  ~RA ~US `readyState$m;

  // <span class="comment"><a href="#request">要請</a></span>
  void `open$m(ByteString %method, ~USVS %url);
  void `open$m(
      ByteString %method,
      ~USVS %url,
      boolean %async,
      optional ~USVS? %username = null,
      optional ~USVS? %password = null
  );
  void `setRequestHeader$m(ByteString %name, ByteString %value);
           attribute unsigned long `timeout$m;
           attribute boolean `withCredentials$m;
  ~RA `XMLHttpRequestUpload$I `upload$m;
  void `send$m(optional (`Document$I or `BodyInit$I)? %body = null);
  void `abort$m();

  // <span class="comment">`応答$</span>
  ~RA ~USVS `responseURL$m;
  ~RA ~US `status$m;
  ~RA ByteString `statusText$m;
  ByteString? `getResponseHeader$m(ByteString %name);
  ByteString `getAllResponseHeaders$m();
  void `overrideMimeType$m(~DS %mime);
           attribute `XMLHttpRequestResponseType$I `responseType$m;
  ~RA any `response$m;
  ~RA ~USVS `responseText$m;
  [Exposed=Window] ~RA `Document$I? `responseXML$m;
};
</pre>

<p>
`XMLHttpRequest$I ~objには、次に挙げるものが結付けられる。
他が定められない限り，括弧内に示された値をとる：
</p>

<ul>
	<li>
`XMLHttpRequestUpload$I ~obj
◎
An XMLHttpRequest object has an associated XMLHttpRequestUpload object.
</li>

	<li>
次のいずれかを値にとる
`状態@（ `~unsent^i ）
⇒
`~unsent^i,
`~opened^i,
`~headers-received^i,
`~loading^i,
`~done^i
◎
An XMLHttpRequest object has an associated state, which is one of unsent, opened, headers received, loading, and done. Unless stated otherwise it is unsent.
</li>

	<li>
`~send~flag@（ ~OFF ）
◎
An XMLHttpRequest object has an associated send() flag. Unless stated otherwise it is unset.
</li>

	<li>
`時間切れ停止~flag@（ ~OFF ）
◎
An XMLHttpRequest object has an associated stop timeout flag. Unless stated otherwise it is unset.
</li>

</ul>


		<section id="constructors">

<h3 title="Constructors">4.1. 構築子</h3>

<dl class="domintro">
 <dt>%client = new `XMLHttpRequest()$m</dt>
 <dd>
新たな `XMLHttpRequest$I ~objを返す。
◎
Returns a new XMLHttpRequest object.
</dd>

</dl>

<p>
`XMLHttpRequest()@m
構築子は、新たな `XMLHttpRequest$I ~objを返さ~MUST。
◎
The XMLHttpRequest() constructor, when invoked, must return a new XMLHttpRequest object.
</p>

		</section>
		<section id="garbage-collection">

<h3 title="Garbage collection">4.2. ~garbage-collect</h3>

<!-- Based on EventSource and WebSocket. Not sure what I am doing. -->

<p>
`XMLHttpRequest$I ~objは、その［［
`状態$ ~EQ `~opened^i, かつ
`~send~flag$ ~EQ ~ON
］, または［
`状態$ ~EQ `~headers-received^i
］, または［
`状態$ ~EQ `~loading^i
］］, かつ†［
<b>type</b> が［
`readystatechange$et,
`progress$et,
`abort$et,
`error$et,
`load$et,
`timeout$et,
`loadend$et
］のいずれかであるような，`~event~listener$が登録されている
］ときは、~garbage-collectされては~MUST_NOT。
<span class="trans-note">【†
“［［ `状態$ ~EQ `~loading^i ］, かつ［ type が 〜 ］］”
かも？
】</span>
<!-- No need to mention upload event listeners as they happen during /opened/. -->
◎
An XMLHttpRequest object must not be garbage collected if its state is either opened with the send() flag set, headers received, or loading, and it has one or more event listeners registered whose type is one of readystatechange, progress, abort, error, load, timeout, and loadend.
</p>


<p>
`XMLHttpRequest$I ~objが，その接続がまだ開いているにも関わらず~garbage-collectされた場合、
~UAは，`要請を終了-$させ~MUST。
◎
If an XMLHttpRequest object is garbage collected while its connection is still open, the user agent must terminate the request.
</p>

		</section>
		<section id="event-handlers">

<h3 title="Event handlers">4.3. ~event~handler</h3>


<p>
`XMLHttpRequestEventTarget$I を継承する~interfaceを実装する~objは、次の`~event~handler$（およびそれらに対応する`~event~handler ~event型$）を属性として~supportし~MUST。
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported on objects implementing an interface that inherits from XMLHttpRequestEventTarget as attributes:
</p>

<table>

<thead><tr><th>`~event~handler$◎event handler
</th><th>`~event~handler ~event型$◎event handler event type
</th></tr></thead>

<tbody><tr><td>`onloadstart@m
</td><td>`loadstart$et

</td></tr><tr><td>`onprogress@m
</td><td>`progress$et

</td></tr><tr><td>`onabort@m
</td><td>`abort$et

</td></tr><tr><td>`onerror@m
</td><td>`error$et

</td></tr><tr><td>`onload@m
</td><td>`load$et

</td></tr><tr><td>`ontimeout@m
</td><td>`timeout$et

</td></tr><tr><td>`onloadend@m
</td><td>`loadend$et

</td></tr></tbody></table>


<p>
`XMLHttpRequest$I ~objにおいては、次の`~event~handler$（および対応する
`~event~handler ~event型$）も属性として~supportし~MUST：
◎
The following is the event handler (and its corresponding event handler event type) that must be supported as attribute solely by the XMLHttpRequest object:
</p>

<table><thead>
<tr><th>`~event~handler$◎event handler
</th><th>`~event~handler ~event型$◎event handler event type
</th></tr></thead>

<tbody><tr><td>`onreadystatechange@m
</td><td>`readystatechange$et

</td></tr></tbody></table>


		</section>
		<section id="states">

<h3 title="States">4.4. 状態</h3>

<dl class="domintro">
 <dt><code>%client . `readyState$m</code></dt>
 <dd>
`状態$を返す。
◎
Returns client's state.
</dd>
</dl>

<p>
`readyState@m
属性の取得子は、`文脈~obj$の`状態$が下の表の１列目のいずれであるかに応じて，同じ行の２列目に示される値を返さ~MUST：
◎
The readyState attribute's getter must return the value from the table below in the cell of the second column, from the row where the value in the cell in the first column is context object's state:
</p>


<table><tbody><tr><td>`~unsent^i
</td><td>`UNSENT@m （数値 0 ）
</td><td>
~objは構築-済みである。
◎
The object has been constructed.

</td></tr><tr><td>`~opened^i
</td><td>`OPENED@m （数値 1 ）
</td><td>
`open$m ~methは成功裡に呼出された。
この状態~下では、
`setRequestHeader$m を用いて要請~headerを設定することができ，
`send$m ~methを用いて~fetchを起動させられる。
◎
The open() method has been successfully invoked. During this state request headers can be set using setRequestHeader() and the fetch can be initiated using the send() method.

</td></tr><tr><td>`~headers-received^i
</td><td>`HEADERS_RECEIVED@m （数値 2 ）
</td><td>
すべての~redirect（もしあれば）は追跡~済みであり，かつ
`応答$のすべての HTTP ~headerは受信-済みである。
◎
All redirects (if any) have been followed and all HTTP headers of the response have been received.

</td></tr><tr><td>`~loading^i
</td><td>`LOADING@m （数値 3 ）
</td><td>
`応答$の`本体$rsの受信-中にある。
◎
The response's body is being received.

</td></tr><tr><td>`~done^i
</td><td>`DONE@m （数値 4 ）
</td><td>
~data転送が完了しているか, または転送~中に何らかの不具合が生じた（例えば，際限のない~redirect）。
◎
The data transfer has been completed or something went wrong during the transfer (e.g. infinite redirects).

</td></tr></tbody></table>

		</section>
		<section id="request">

<h3 title="Request">4.5. 要請</h3>

<div>

<p>
それぞれの `XMLHttpRequest$I ~objには、次の概念が要請に結付けられる（括弧内は初期値）：
</p>

<ul>
	<li>`要請~method@</li><!-- FETCH.concept-method -->
	<li>`要請~URL@</li><!-- .concept-url？ -->
	<li>`~header~list$である，`作者による要請~header@（空）</li>
	<li>`要請~本体@（ ~NULL ）</li>
	<li>`同期~flag@（ ~OFF ）</li>
	<li>`~upload完了-~flag@（ ~OFF ）</li>
</ul>

◎
Each XMLHttpRequest object has the following request-associated concepts: request method, request URL, author request headers, request body, synchronous flag, and upload complete flag.
◎
The author request headers is an initially empty header list.
◎
The request body is initially null.
◎
The synchronous flag and upload complete flag are initially unset.
</div>


<hr>

<p class="algo-head">
`要請を終了-@させるときは、
`XMLHttpRequest$I ~objにより処理中の`~fetching$ ~algoを，終了事由  `致命的^i と伴に`終了-$させる。
◎
To terminate the request, terminate the fetch algorithm operated by the XMLHttpRequest object with reason fatal.
</p>

			<section id="the-open()-method">

<h4 title="The open() method">4.5.1. `open()^m ~meth</h4>

<dl class="domintro">
 <dt><code>%client . `open$m(%method, %url [, %async = true [, %username = null [, %password = null]]])</code></dt>
 <dd>
`要請~method$, `要請~URL$, `同期~flag$
を設定する。
◎
Sets the request method, request URL, and synchronous flag.
</dd>
 <dd>
%method が妥当な HTTP ~methodでない，あるいは %url を構文解析できない場合、 `SyntaxError^E 例外が投出される。
◎
Throws a SyntaxError exception if either method is not a valid HTTP method or url cannot be parsed.
</dd>
 <dd>
%method が
`CONNECT^h, `TRACE^h, `TRACK^h
のいずれかに文字大小無視で合致する場合、 `SecurityError^E 例外が投出される。
◎
Throws a SecurityError exception if method is a case-insensitive match for `CONNECT`, `TRACE` or `TRACK`.
</dd>
 <dd>
<p>
次がいずれも満たされる場合、 `InvalidAccessError^E 例外が投出される：
</p>

<ul ><li>%async ~EQ ~F
</li><li>`~entry設定群~obj$の`大域~obj$は `Window$I ~objである
</li><li>［
`timeout$m 属性 ~NEQ 0
］~OR［
`responseType$m 属性 ~NEQ 空文字列
］
</li></ul>

◎
Throws an InvalidAccessError exception if async is false, entry settings object's global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.
</dd>

</dl>

<p class="critical" id="sync-warning">
worker 以外での同期的 `XMLHttpRequest$I は、末端利用者をひどく待たせることになりかねないので， Web ~platformから除去されつつある過程にある（何年もかかるであろう）。
開発者は、［
`~entry設定群~obj$の`大域~obj$は
`Window$I ~objである
］場合には， %async 引数に ~F を渡しては~MUST_NOT。
~UA には、開発ツールにおいて，その種の用法に対し警告を発することが強く奨励される
— 
それが生じたときに，
`InvalidAccessError^E 例外を`投出$するように、試験的に実装してもよい。
◎
Synchronous XMLHttpRequest outside of workers is in the process of being removed from the web platform as it has detrimental effects to the end user's experience. (This is a long process that takes many years.) Developers must not pass false for the async argument when entry settings object's global object is a Window object. User agents are strongly encouraged to warn about such usage in developer tools and may experiment with throwing an InvalidAccessError exception when it occurs.
</p>

<p>
`open(method, url, async, username, password)@m
~methの被呼出時には、次を走らせ~MUST：
◎
The open(method, url, async, username, password) method, when invoked, must run these steps:
</p>


<ol>
	<li>
~IF［
`文脈~obj$に`関連する設定群~obj$は `担当の文書$を持っていて，それは`全部的に作動中$ではない
］
⇒
~THROW `InvalidStateError^E
◎
If context object's relevant settings object has a responsible document and it is not fully active, throw an InvalidStateError exception.
</li>

	<li>
~IF［
%method は`~method$rqでない
］
⇒
~THROW `SyntaxError^E
◎
If method is not a method, throw a SyntaxError exception.
</li>

	<li>
~IF［
%method は`禁止~method$である
］
⇒
~THROW `SecurityError^E
◎
If method is a forbidden method, throw a SecurityError exception.
</li>

	<li>
%method を`正規化-$rqする
◎
Normalize method.
</li>

	<li>
%解析済URL ~LET ［
基底~URL： `文脈~obj$に`関連する設定群~obj$の`API 基底~URL$
］の下に， %url を`構文解析-$した結果
◎
Let parsedURL be the result of parsing url with context object's relevant settings object's API base URL.
</li>

	<li>
~IF［
%解析済URL ~EQ <b>failure</b>
］
⇒
~THROW `SyntaxError^E
◎
If parsedURL is failure, throw a SyntaxError exception.
</li>

	<li>
<p>
~IF［
%async 引数は省略されている
］
⇒
%async ~SET true；<br>
%username ~SET ~NULL；<br>
%password ~SET ~NULL
◎
If the async argument is omitted, set async to true, and set username and password to null.
</p>

<p class="note">注記：
あいにく，旧来~内容と~~互換性をとるため、 %async 引数に `undefined^c が渡された場合と省略された場合とを，同じに扱うわけにはいかない。
◎
Unfortunately legacy content prevents treating the async argument being undefined identical from it being omitted.
</p>
	</li>

	<li>
<p>
~IF［
%解析済URL の`~host$ ~NEQ ~NULL
］：
◎
If parsedURL's host is non-null, run these substeps: 
</p>
		<ol>
			<li>
~IF［
%username ~NEQ ~NULL
］
⇒
%username を用いて， %解析済URL の`~usernameを設定する$
◎
If the username argument is not null, set the username given parsedURL and username.
</li>
			<li>
~IF［
%password ~NEQ ~NULL
］
⇒
%password を用いて， %解析済URL の`~passwordを設定する$
◎
If the password argument is not null, set the password given parsedURL and password.
</li>
		</ol>
	</li>

	<li>
<p>
~IF［
次がいずれも満たされる
］…：
</p>

<ul ><li>%async ~EQ ~F
</li><li>`~entry設定群~obj$の`大域~obj$は `Window$I ~objである
</li><li>［
`timeout$m 属性 ~NEQ 0
］~OR［
`responseType$m 属性 ~NEQ 空文字列
］
</li></ul>

<p>
…ならば
⇒
~THROW `InvalidAccessError^E
</p>

◎
If async is false, entry settings object's global object is a Window object, and the timeout attribute value is not zero or the responseType attribute value is not the empty string, then throw an InvalidAccessError exception.
</li>

   <li>
<p><!-- copy -->
`要請を終了-$させる
◎
Terminate the request.
</p>

<p class="note">注記：
この時点から，`~fetching$を進行させられるようになる。
◎
A fetch can be ongoing at this point.
</p>


  <!-- also unsets the send() flag -->


   </li>

   <li>
<p>
~objに結付けられている各種~変数を次の様に設定する：
◎
Set variables associated with the object as follows:
</p>

    <ul>

 <li>
`時間切れ停止~flag$ ~SET ~OFF
◎
Unset the stop timeout flag.
</li>

     <li>
`要請~method$ ~SET %method
◎
Set request method to method.
</li>

     <li>
`要請~URL$ ~SET %解析済URL
◎
Set request URL to parsedURL.
</li>

     <li>
`同期~flag$ ~SET ［
%async ~EQ ~F ならば ~ON ／
~ELSE_ ~OFF
］
◎
Set the synchronous flag, if async is false, and unset the synchronous flag otherwise.
</li>

     <li>
`作者による要請~header$ を空にする
◎
Empty author request headers.
</li>

     <li>
`応答$ ~SET `~network~error$
◎
Set response to a network error.
</li>

     <li>
`受信済み~byte列$ ~SET 空~byte列
◎
Set received bytes to the empty byte sequence. 
</li>

	 <li>
`応答 ArrayBuffer ~obj$ ~SET ~NULL
◎
Set response ArrayBuffer object to null.
</li>

     <li>
`応答 Blob ~obj$ ~SET ~NULL
◎
Set response Blob object to null.
</li>

     <li>
`応答 Document ~obj$ ~SET ~NULL
◎
Set response Document object to null.
</li>

     <li>
`応答 JSON ~obj$ ~SET ~NULL
◎
Set response JSON object to null.
</li>
    </ul>
   </li>

   <li>
<p>
~IF［
`状態$ ~NEQ `~opened^i
］：
◎
If the state is not opened, run these substeps:
</p>

    <ol>
     <li>
`状態$ ~SET `~opened^i
◎
Set state to opened.
</li>

     <li>
名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange.
</li>
    </ol>
   </li>

  </ol>



			</section>
			<section id="the-setrequestheader()-method">

<h4 title="The setRequestHeader() method">4.5.2. `setRequestHeader()^m ~meth</h4>

<dl class="domintro">
 <dt><code>%client . `setRequestHeader$m(%name, %value)</code></dt>
 <dd>
<p>
`作者による要請~header$の中で，所与の %name の`~header$に %value を結合する
◎
Combines a header in author request headers.
</dd>
 <dd>
`状態$ ~NEQ `~opened^i, または
`~send~flag$ ~EQ ~ON
の場合、 `InvalidStateError^E 例外が投出される。
◎
Throws an InvalidStateError exception if either state is not opened or the send() flag is set.
</dd>
 <dd>
%name が~header名でなかったり,
%value が~header値でなかった場合、
`SyntaxError^E 例外が投出される。
◎
Throws a SyntaxError exception if name is not a header name or if value is not a header value.
</dd>
</dl>

<p class="note">注記：
下の~algoにて指示されるように、一部の~headerは，設定し得ない。
それらの設定-は~UAに委ねられる。
加えて、 `send$m ~meth節の最後に示されている様に，作者から設定されなかった他の一部の~headerについても、~UA の制御~下に置かれることになる。
◎
As indicated in the algorithm below certain headers cannot be set and are left up to the user agent. In addition there are certain other headers the user agent will take control of if they are not set by the author as indicated at the end of the send() method section.
</p>

<p>
`setRequestHeader(name, value)@m
~methの被呼出時には、次を走らせ~MUST：
◎
The setRequestHeader(name, value) method must run these steps:
</p>

<ol>
 <li>
~IF［
`状態$ ~NEQ `~opened^i
］
⇒
~THROW `InvalidStateError^E
◎
If state is not opened, throw an InvalidStateError exception.
</li>

 <li>
~IF［
`~send~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidStateError^E
◎
If the send() flag is set, throw an InvalidStateError exception.
</li>

 <li>
%value ~SET %value を`正規化-$した結果
◎
Normalize value.
</li>

 <li>
<p>
~IF［
%name は`名前$でない
］~OR［
%value は`値$でない
］
⇒
~THROW `SyntaxError^E
◎
If name is not a name or value is not a value, throw a SyntaxError exception.
</p>

<p class="note">注記：
空~byte列は空の`~header$ `値$を表現する。
◎
An empty byte sequence represents an empty header value.
</p>
 </li>

 <li>
~IF［
%name は`禁止~header名$である
］
⇒
~RET
◎
Terminate these steps if name is a forbidden header name.
</li>

 <li>
`作者による要請~header$の中で，
( %name / %value)
を`結合-$する
◎
Combine name/value in author request headers.
</li>

</ol>

<div class="example">
<p>
同じ~headerを重複して設定した場合の~~動作を示すための，単純な~code。
次の~script：
◎
Some simple code demonstrating what happens when setting the same header twice:
◎
// The following script:
</p>

<pre>
var %client = new XMLHttpRequest();
%client.open('GET', 'demo.cgi');
%client.setRequestHeader('X-Test', 'one');
%client.setRequestHeader('X-Test', 'two');
%client.send();
</pre>

<p>
による結果、次の~headerが送信される：
◎
// …results in the following header being sent:
</p>

<pre>
X-Test: one, two
</pre>
</div>


			</section>
			<section id="the-timeout-attribute">

<h4 title="The timeout attribute">4.5.3. `timeout^m 属性</h4>

<dl class="domintro">
 <dt><code>%client . `timeout$m</code></dt>
 <dd>
時間をミリ秒~単位で設定できる。
非ゼロ値に設定された場合、所与の時間が経過した時点で，`~fetching$は終了させられる。
その時点で要請がまだ完了していない場合、`同期~flag$が ~OFF の下では，
`timeout$et ~eventが`配送-$され、他の場合（ ~ON の下での `send()$m ~methに対しては），
`TimeoutError^E 例外が`投出$されることになる。
◎
Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the request has not yet completed, and the synchronous flag is unset, a timeout event will then be dispatched, or a TimeoutError exception will be thrown otherwise (for the send() method).
</dd>
 <dd>
被設定時には、［
`同期~flag$ ~EQ ~ON
］, かつ［
`~entry設定群~obj$の`大域~obj$は
`Window$I ~objである
］ならば，
`InvalidAccessError^E 例外が投出される。
◎
When set: throws an InvalidAccessError exception if the synchronous flag is set and entry settings object's global object is a Window object.
</dd>
</dl>

<p>
`timeout@m 属性は、その値を返さ~MUST。
その初期値はゼロで~MUST。
◎
The timeout attribute must return its value. Initially its value must be zero.
</p>

<p>
`timeout$m 属性の被設定時には、次を走らせ~MUST：
◎
Setting the timeout attribute must run these steps:
</p>

  <ol>
   <li>
~IF［
`~entry設定群~obj$の`大域~obj$は `Window$I ~objである
］~AND［
`同期~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidAccessError^E
◎
If entry settings object's global object is a Window object and the synchronous flag is set, throw an InvalidAccessError exception.
</li>

   <li>
その値 ~SET 新たな値
◎
Set its value to the new value.
</li>

</ol>

<p class="note">注記：
これにより，`~fetching$が進捗~中の間でも、 `timeout$m 属性を設定-可能になる。
その場合でも、計測の起点は`~fetching$の開始からのまま，変わらない。
◎
This implies that the timeout attribute can be set while fetching is in progress. If that occurs it will still be measured relative to the start of fetching.
</p>

			</section>
			<section id="the-withcredentials-attribute">

<h4 title="The withCredentials attribute">4.5.4. `withCredentials^m 属性</h4>

<dl class="domintro">
 <dt><code>%client . `withCredentials$m</code></dt>
 <dd>
`利用者 資格証$が、非同一生成元~要請に含められることになるときは ~T。
非同一生成元~要請から除外され, その応答における~cookieが無視されることになるときは ~F。
初期値は ~F 。
◎
True when user credentials are to be included in a cross-origin request. False when they are to be excluded in a cross-origin request and when cookies are to be ignored in its response. Initially false.
</dd>
 <dd>
被設定時には、`状態$が `~unsent^i でも `~opened^i でもない, または
`~send~flag$ ~EQ ~ON
ならば， `InvalidStateError^E 例外が投出される。
◎
When set: throws an InvalidStateError exception if state is not unsent or opened, or if the send() flag is set.
</dd>
</dl>

<p>
`withCredentials@m
属性は、その値を返さ~MUST。
その初期値は ~F で~MUST。
◎
The withCredentials attribute must return its value. Initially its value must be false.
</p>

<p>
`withCredentials$m 属性の被設定時には、次を走らせ~MUST：
◎
Setting the withCredentials attribute must run these steps:
</p>

<ol>
 <li>
~IF［
`状態$ ~NIN
{ `~unsent^i, `~opened^i }
］
⇒
~THROW `InvalidStateError^E
◎
If state is not unsent or opened, throw an InvalidStateError exception.
</li>

 <li>
~IF［
`~send~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidStateError^E
◎
If the send() flag is set, throw an InvalidStateError exception.
</li>

 <li>
`withCredentials$m 属性の値 ~SET 所与の値
◎
Set the withCredentials attribute's value to the given value.
</li>
</ol>

<p class="note">注記：
`withCredentials$m 属性は、`同一生成元$の`~fetching$においては、何の効果もない。
◎
The withCredentials attribute has no effect when fetching same-origin resources.
</p>


			</section>
			<section id="the-upload-attribute">

<h4 title="The upload attribute">4.5.5. `upload^m 属性</h4>

<dl class="domintro">
 <dt><code>%client . `upload$m</code></dt>
 <dd>
結付けられている `XMLHttpRequestUpload$I ~objを返す。
~dataが~serverへ向けて転送されている間の伝送~情報の~~収集に，これを利用できる。
◎
Returns the associated XMLHttpRequestUpload object. It can be used to gather transmission information when data is transferred to a server.
</dd>

</dl>

<p>
`upload@m
属性は、結付けられている `XMLHttpRequestUpload$I ~objを返さ~MUST。
◎
The upload attribute must return the associated XMLHttpRequestUpload object.
</p>

<p class="note">注記：
前に示した様に、それぞれの `XMLHttpRequest$I ~objには， `XMLHttpRequestUpload$I ~objが結付けられる。
◎
As indicated earlier, each XMLHttpRequest object has an associated XMLHttpRequestUpload object.
</p>

			</section>
			<section id="the-send()-method">

<h4 title="The send() method">4.5.6. `send()^m ~meth</h4>

<dl class="domintro">
 <dt><code>%client . `send$m([%body = null])</code></dt>
 <dd>
要請を起動させる。
引数（省略可）は`要請~本体$を与える。
`要請~method$が `GET^c や `HEAD^c の場合、この引数は無視される。
◎
Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD.
</dd>
 <dd>
`状態$ ~NEQ `~opened^i, または
`~send~flag$ ~EQ ~ON
の場合、 `InvalidStateError^E 例外が投出される。
◎
Throws an InvalidStateError exception if either state is not opened or the send() flag is set.
</dd>
</dl>

<p>
`send(body)@m
~methの被呼出時には、次を走らせ~MUST：
◎
The send(body) method must run these steps:
</p>

<ol>
 <li>
~IF［
`状態$ ~NEQ `~opened^i
］
⇒
~THROW `InvalidStateError^E
◎
If state is not opened, throw an InvalidStateError exception.
</li>

 <li><!-- copy -->
~IF［
`~send~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidStateError^E
◎
If the send() flag is set, throw an InvalidStateError exception.
</li>

 <li>
~IF［
`要請~method$ ~IN
{ `GET^c, `HEAD^c }
］
⇒
%body ~SET ~NULL
◎
If the request method is GET or HEAD, set body to null.
</li>

 <li>
<p>
~IF［
%body ~NEQ ~NULL
］：
◎
If body is null, go to the next step.
◎
Otherwise, let encoding be null, Content-Type be null, and then follow these rules, depending on body:
</p>

  <ol>
   <li>
%符号化方式 ~LET ~NULL；<br>
~Content-Type ~LET ~NULL
◎
↑</li>

   <li>
<p>
%body に応じて：
◎
↑</p>


    <dl class="switch">

     <dt id="dom-xmlhttprequest-send-document">`Document$I</dt>
     <dd>
<p>
%符号化方式 ~SET `UTF-8^lb
◎
Set encoding to `UTF-8`.
</p>

<p>
~Content-Type ~SET ［
%body が`HTML 文書$であるならば `text/html^lb ／
~ELSE_ `application/xml^lb
］に， `;charset=UTF-8^lb を連結した結果
◎
If body is an HTML document, set Content-Type to `text/html`, and set Content-Type to `application/xml` otherwise. Then append `;charset=UTF-8` to Content-Type.
</p>

<p>
`要請~本体$ ~SET ［［
%body を［
`require well-formed flag^i ~SET ON
］の下に
<a href="https://w3c.github.io/DOM-Parsing/#dfn-concept-fragment-serializing-algorithm">直列化-</a>した結果（例外が投出された場合は，そのまま再~投出）
］を`Unicode に変換-$した結果
］を`utf-8 符号化-$した結果
◎
Set request body to body, serialized with the require well-formed flag set, converted to Unicode, and utf-8 encoded. Rethrow any exceptions.
</p>

<p class="note">注記：
%body を直列化できない場合、 `InvalidStateError^E 例外が投出される。
◎
If body cannot be serialized, an InvalidStateError exception is thrown.
</p>
     </dd>

     <dt id="dom-xmlhttprequest-send-bodyinit">`BodyInit$I</dt>
     <dd>
<p>
~IF［
%body は文字列である
］
⇒
%符号化方式 ~SET `UTF-8^lb
◎
If body is a string, set encoding to `UTF-8`.
</p>

<p>
［
`要請~本体$, ~Content-Type
］ ~SET %body を`抽出-$した結果
◎
Set request body and Content-Type to the result of extracting body.
</p>
     </dd>
    </dl>
   </li>

   <li>
~IF［
~Content-Type ~NEQ ~NULL
］~AND［
`作者による要請~header$に，［
`名前$ ~EQ `Content-Type^h
］なる`~header$は含まれていない
］
⇒
`作者による要請~header$に
( `Content-Type^h / ~Content-Type)
を`追加-$する
◎
If Content-Type is non-null and author request headers contains no header named `Content-Type`, append `Content-Type`/Content-Type to author request headers.
</li>

   <li>
~ELIF［
%符号化方式 ~NEQ ~NULL
］
⇒
~FOR
`作者による要請~header$内の ~EACH (
［
`名前$ ~EQ `Content-Type^h
］なる`~header$
) に対し
⇒
~IF［
その~headerの`値$ %V は，［
`妥当な MIME 型$である
］~AND［
%V の中の `charset^lb ~parameterの値は %符号化方式 に文字大小無視で合致しない
］］
⇒
その `charset^lb ~parameterの値 ~SET %符号化方式
<!-- XXX could still be better with case-insensitive and parameter cross-ref -->

<!-- reminder: if we ever change this to always include charset it has
  to be included as the first parameter for compatibility reasons -->
◎
Otherwise, if the header named `Content-Type` in author request headers has a value that is a valid MIME type, which has a `charset` parameter whose value is not a case-insensitive match for encoding, and encoding is not null, then set all the `charset` parameters whose value is not a case-insensitive match for encoding of that `Content-Type` header's value to encoding.
</li>
  </ol>

 </li>

 <li>
<p>
%要請 ~LET 次の様に初期化された新たな`要請$rq：
◎
Let req be a new request, initialized as follows:
</p>

  <dl class="leaf-parent">

   <dt>`~method$rq◎method</dt>
   <dd>
`要請~method$
◎
request method
</dd>

   <dt>`url$rq◎url</dt>
   <dd>
`要請~URL$
◎
request URL
</dd>

   <dt>`~header~list$rq◎header list</dt>
   <dd>
`作者による要請~header$
◎
author request headers
</dd>

   <dt>`非安全~要請~flag$rq◎unsafe-request flag</dt>
   <dd>
~ON
◎
Set.
</dd>

   <dt>`同一生成元 data-URL ~flag$rq◎same-origin data-URL flag</dt>
   <dd>
~ON
◎
Set.
</dd>

   <dt>`本体$rq◎body</dt>
   <dd>
`要請~本体$
◎
request body
</dd>

   <dt>`~client$rq◎client</dt>
   <dd>
`文脈~obj$に`関連する設定群~obj$
◎
settings object
</dd>

   <dt>`同期~flag$rq◎synchronous flag</dt>
   <dd>
`同期~flag$ ~EQ ~ON ならば ~ON ／
~ELSE_ ~OFF
◎
Set if the synchronous flag is set.
</dd>

   <dt>`~mode$rq◎mode</dt>
   <dd>
`cors^l
◎
"cors"
</dd>
   <dt>`CORS予行~利用~flag$rq◎use-CORS-preflight flag</dt>
   <dd>
`XMLHttpRequestUpload$I ~obj上に 1 個以上の~event~listenerが登録されているならば ~ON ／
~ELSE_ ~OFF
◎
Set if one or more event listeners are registered on the associated XMLHttpRequestUpload object.
</dd>


   <dt>`資格証~mode$rq◎credentials mode</dt>
   <dd>
`withCredentials$m 属性 ~EQ ~T
ならば `include^l ／
~ELSE_ `same-origin^l
◎
If the withCredentials attribute value is true, "include", and "same-origin" otherwise.
</dd>

   <dt>`URL 資格証 利用~flag$rq◎use URL credentials flag</dt>
   <dd>
`要請~URL$の`~username$ ~NEQ 空文字列 ~OR
`要請~URL$の`~password$ ~NEQ ~NULL
ならば ~ON ／
~ELSE_ ~OFF
◎
Set if either request URL's username is not the empty string or request URL's password is non-null.
</dd></dl>

 </li>

 <li>
`~upload完了-~flag$ ~SET ［
%要請 の`本体$rq ~EQ ~NULL
ならば ~ON ／
~ELSE_ ~OFF
］
◎
Unset the upload complete flag.
◎
If req's body is null, set the upload complete flag.
</li>

 <li>
`~send~flag$ ~SET ~ON
◎
Set the send() flag.
</li>

 <li>
<p>
~IF［
`同期~flag$ ~EQ ~OFF
］：
◎
If the synchronous flag is unset, run these substeps:
</p>

  <ol>
   <li>
( 0, 0 )
を与える下で，名前 `loadstart$et の`進捗~eventを発火する$
◎
Fire a progress event named loadstart with 0 and 0.
</li>

   <li>
~IF［
`~upload完了-~flag$ ~EQ ~OFF
］
⇒
( 0, %要請 の`本体$rqの`総~byte数$ )
を与える下で，
`XMLHttpRequestUpload$I ~objに向けて，名前 `loadstart$et の`進捗~eventを発火する$
◎
If the upload complete flag is unset, fire a progress event named loadstart on the XMLHttpRequestUpload object with 0 and req's body's total bytes.
</li>

   <li>
<p>
%要請 を用いて`~fetching$に取り掛かる
—
下に従って，`~network用~task源$上の
<a href="~WAPI#queue-a-task">待入された</a>
`~task$
を取扱う
◎
Fetch req. Handle the tasks queued on the networking task source per below.
</p>

<p>
次の下位手続きを`並列的$に走らす：
◎
Run these subsubsteps in parallel:
</p>

    <ol>
     <li>
%milliseconds ~LET ゼロ
◎
Let milliseconds be zero.
</li>

     <li>
<p>
`時間切れ停止~flag$ ~EQ ~OFF である限り、毎ミリ秒ごとに，次を走らす`極小taskを待入する$：
◎
Every millisecond, as long as the stop timeout flag is unset, queue a microtask to run these subsubsubsteps:
</p>

      <ol>
       <li>
%milliseconds ~SET %milliseconds ~PLUS 1
◎
Increase milliseconds by one.
</li>

       <li>
~IF［
%milliseconds ~GTE `timeout$m 属性値
］~AND［
`timeout$m 属性値 ~NEQ ゼロ
］
⇒
終了事由 `時間切れ^i と伴に `~fetching$を`終了-$させる
◎
If milliseconds is equal or greater than the timeout attribute value and the timeout attribute value is not zero, terminate fetching with reason timeout.
</li>
      </ol>
     </li>
    </ol>


<p><span class="trans-note">【
以下に定義される各種 下位手続き（ “〜を処理” ）は、`~fetching$の中で待入される~taskになる（これらは，非同期的に呼出される callback である）。
】</span></p>


<p class="algo-head">
%要請 に対し，
`要請の本体を処理$
するときは、次の下位手続きを走らす：
◎
To process request body for request, run these subsubsteps:
</p>

<ol>
 <li>
~IF［
この手続きが最後に呼出されたときから，まだ およそ 50ms 以上 経過していない
］
⇒
~RET
◎
If not roughly 50ms have passed since these subsubsteps were last invoked, terminate these subsubsteps.
</li>

 <li>
%要請 の`本体$rqの
( `伝送済み~byte数$, `総~byte数$ )
を与える下で，
`XMLHttpRequestUpload$I ~objに向けて，名前 `progress$et の`進捗~eventを発火する$。
<!-- upload complete flag can never be set here I hope -->
◎
Fire a progress event named progress on the XMLHttpRequestUpload object with request's body's transmitted bytes and request's body's total bytes.
</li>

</ol>


<p class="algo-head">
%要請 に対し，
`要請の~eofを処理$
するときは、次の下位手続きを走らす：
◎
To process request end-of-file for request, run these subsubsteps:
</p>

    <ol>
     <li>
`~upload完了-~flag$ ~SET ~ON
◎
Set the upload complete flag.
</li>

     <li>
%伝送量 ~LET
%要請 の`本体$rqの`伝送済み~byte数$ 
◎
Let transmitted be request's body's transmitted bytes.
</li>

     <li>
%長th ~LET
%要請 の`本体$rqの`総~byte数$
◎
Let length be request's body's total bytes.
</li>

     <li>
( %伝送量, %長th )
を与える下で，
`XMLHttpRequestUpload$I ~objに向けて，名前 `progress$et の`進捗~eventを発火する$
◎
Fire a progress event named progress on the XMLHttpRequestUpload object with transmitted and length.
</li>

     <li>
( %伝送量, %長th )
を与える下で，
`XMLHttpRequestUpload$I ~objに向けて，名前 `load$et の`進捗~eventを発火する$
◎
Fire a progress event named load on the XMLHttpRequestUpload object with transmitted and length.
</li>

     <li>
( %伝送量, %長th )
を与える下で，
`XMLHttpRequestUpload$I ~objに向けて，名前 `loadend$et の`進捗~eventを発火する$
◎
Fire a progress event named loadend on the XMLHttpRequestUpload object with transmitted and length.
</li>

    </ol>
<!-- upload complete flag can never be set here I hope -->

<p class="algo-head">
%応答 に対し，
`応答を処理$
するときは、次の下位手続きを走らす：
◎
To process response for response, run these subsubsteps:
</p>

    <ol>
     <li>
~IF［
`時間切れ停止~flag$ ~EQ ~OFF
］
⇒
`時間切れ停止~flag$ ~SET ~ON
◎
If the stop timeout flag is unset, set the stop timeout flag.
</li>

     <li>
`応答$ ~SET %応答
◎
Set response to response.
</li>

     <li>
%応答 に対し，`~errorを取扱う$
◎
Handle errors for response.
</li>

     <li>
~IF［
`応答$ は`~network~error$である
］
⇒
~RET
◎
If response is a network error, return.
</li>

     <li>
`状態$ ~SET `~headers-received^i
◎
Set state to headers received.
</li>

     <li>
名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange.
</li>

     <li>
~IF［
`状態$ ~NEQ `~headers-received^i
］
⇒
~RET
◎
If state is not headers received, then return.
</li>

     <li>
~IF［
%応答 の`本体$rs ~EQ ~NULL
］
⇒
%応答 に対する`~eofを取扱う$；<br />
~RET
◎
If response's body is null, then run handle response end-of-file and return.
</li>

     <li>
<p>
%読取器 ~LET %応答 の`本体$rsの`~stream$から`読取器を取得-$した結果
◎
Let reader be the result of getting a reader from response's body's stream.
</p>

<p class="note">注記：
この演算が例外を投出することはない。
◎
This operation will not throw an exception.
</p>
     </li>

     <li>
<p>
%読取 ~LET
`ReadFromReadableStreamReader$AO( %読取器 ) を~callした結果：
◎
Let read be the result of calling ReadFromReadableStreamReader(reader).
</p>

<ul>
	<li>

<div class="p">
<p>
%読取 が次を満たす~obj：
</p>

<ul ><li>`done^c ~prop ~EQ ~F
</li><li>`value^c ~propは `Uint8Array^c ~objである
</li></ul>

<p>
で充足されたときは：
</p>

<ol>
	<li>
下に与える手続き(A) を走らす
</li>
	<li>
この下位手続きを再度~走らす
</li>
</ol>

<p>
手続き(A) は、次を走らす：
</p>

◎
When read is fulfilled with an object whose done property is false and whose value property is a Uint8Array object, run these subsubsubsteps and then run the above subsubstep again:
</div>

      <ol>
       <li>
`受信済み~byte列$に `value^c ~propを付加する
◎
Append the value property to received bytes.
</li>
       <li>
~IF［
手続き(A) が前回に呼出されたときから，まだ およそ 50ms 以上 経過していない
］
⇒
~RET
◎
If not roughly 50ms have passed since these subsubsubsteps were last invoked, then terminate these subsubsubsteps.
</li>
       <li>
~IF［
`状態$ ~EQ `~headers-received^i
］
⇒
`状態$ ~SET `~loading^i；<br>
名前 `readystatechange$et の`~eventを発火する$
◎
If state is headers received, then set state to loading and fire an event named readystatechange.
</li>

       <li>
%応答 の`本体$rsの
( `伝送済み~byte数$, `総~byte数$ )
を与える下で，名前 `progress$et の`進捗~eventを発火する$
◎
Fire a progress event named progress with response's body's transmitted bytes and response's body's total bytes.
</li>
      </ol>

	</li>
	<li>
%読取 が［
`done^c ~prop ~EQ ~T
］なる~objで充足されたときは
⇒
%応答 に対する`~eofを取扱う$
◎
When read is fulfilled with an object whose done property is true, run handle response end-of-file for response.
</li>
	<li>
%読取 が例外で却下されたときは
⇒
%応答 の`~errorを取扱う$
◎
When read is rejected with an exception, run handle errors for response.
</li>
</ul>

    </ol>
   </li>
  </ol>
 </li>

 <li>
<p>
~ELSE
（ `同期~flag$ ~EQ ~ON ）：
◎
Otherwise, if the synchronous flag is set, run these substeps:
</p>

  <ol>
   <li>
<p>
%応答 ~LET %要請 を用いて`~fetching$を遂行した結果
◎
Let response be the result of fetching req.
</p>

<p>
~IF［
`timeout$m 属性値 ~NEQ ゼロ
］~AND［
この`~fetching$は `timeout$m 属性値のミリ秒の間に返らなかった
］
⇒
終了事由 `時間切れ^i と伴に `~fetching$を`終了-$させる
◎
If the timeout attribute value is not zero, terminate this fetch if it has not returned within the amount of milliseconds from the timeout attribute value with reason timeout.
</p>
   </li>

   <li>
~IF［
%応答 の`本体$rs ~EQ ~NULL
］
⇒
%応答 に対する`~eofを取扱う$；<br />
~RET
◎
If response's body is null, then run handle response end-of-file and return.
</li>

   <li>
<p>
%読取器 ~LET %応答 の`本体$rsの`~stream$から`読取器を取得-$した結果
◎
Let reader be the result of getting a reader from response's body's stream.
</p>

<p class="note">注記：
この演算が例外を投出することはない。
◎
This operation will not throw an exception.
</p>
   </li>

   <li>
%promise ~LET
%応答 の`本体$rsの`~stream$から， %読取器 を用いて`すべての~byte列を読取る$
◎
Let promise be the result of reading all bytes from response's body's stream with reader.
</li>

   <li>
%promise が充足されるか却下されるまで待機する
◎
Wait for promise to be fulfilled or rejected.
</li>

   <li>
~IF［
%promise は %~byte列 で充足された
］
⇒
`受信済み~byte列$に %~byte列 を付加する
◎
If promise is fulfilled with bytes, then append bytes to received bytes.
</li>
   <li>
%応答 に対する`~eofを取扱う$
◎
Run handle response end-of-file for response.
</li>
  </ol>
 </li>
</ol>

<p class="algo-head">
%応答 に対する
`~eofを取扱う@
ときは、次を走らす：
◎
To handle response end-of-file for response, run these steps:
</p>

<ol>
 <li>
~IF［
`同期~flag$ ~EQ ~ON
］
⇒
`応答$ ~SET %応答
◎
If the synchronous flag is set, set response to response.
</li>

 <li>
%応答 に対し，`~errorを取扱う$
◎
Handle errors for response.
</li>

 <li>
~IF［
`応答$ は`~network~error$である
］
⇒
~RET
◎
If response is a network error, return.
</li>

  <li>
~IF［
`同期~flag$ ~EQ ~OFF
］
⇒
%応答 を用いて`応答$の`本体$rsを更新する
◎
If the synchronous flag is unset, update response's body using response.
</li>

 <li>
`状態$ ~SET `~done^i
◎
Set state to done.
</li>

 <li>
`~send~flag$ ~SET ~OFF
◎
Unset the send() flag.
</li>

 <li>
名前 `readystatechange$et の`~eventを発火する$
◎
Fire an event named readystatechange.
</li>

 <li>
%伝送量 ~LET
%応答 の`本体$rsの`伝送済み~byte数$
◎
Let transmitted be response's body's transmitted bytes.
</li>

 <li>
%長th ~LET
%応答 の`本体$rsの`総~byte数$
◎
Let length be response's body's total bytes.
</li>

 <li>
( %伝送量, %長th )
を与える下で，名前 `progress$et の`進捗~eventを発火する$
◎
Fire a progress event named progress with transmitted and length.
</li>

 <li>
( %伝送量, %長th )
を与える下で，名前 `load$et の`進捗~eventを発火する$
◎
Fire a progress event named load with transmitted and length.
</li>

 <li>
( %伝送量, %長th )
を与える下で，名前 `loadend$et の`進捗~eventを発火する$
◎
Fire a progress event named loadend with transmitted and length.
</li>

</ol>


<p class="algo-head">
%応答 に対し，
`~errorを取扱う@
ときは、次を走らす：
◎
To handle errors for response run these steps:
</p>

<ol>
  <li>
~IF［
`~send~flag$ ~EQ ~OFF
］
⇒
~RET
◎
If the send() flag is unset, return.
</li>

 <li>
~IF［
%応答 は`~network~error$である
］
⇒
( ~event `error$et, 例外  `NetworkError^E )
を与える下で，`要請~error手続き$を走らす
◎
If response is a network error, run the request error steps for event error and exception NetworkError.
</li>

 <li>
  <p>
~ELIF［
%応答 に`終了事由$rsがある
］
⇒
終了事由に応じて：
◎
Otherwise, if response has a termination reason:
</p>

  <dl class="switch">
   <dt>`末端利用者による中止^i （ end-user abort ）</dt>
   <dd>
( ~event `abort$et, 例外  `AbortError^E )
を与える下で，`要請~error手続き$を走らす
◎
Run the request error steps for event abort and exception AbortError.
</dd>

   <dt>`致命的^i （ fatal ）</dt>
   <dd>
    <ol>
     <li>
`状態$ ~SET `~done^i
◎
Set state to done.
</li>

     <li>
`~send~flag$ ~SET ~OFF
◎
Unset the send() flag.
</li>

     <li>
`応答$ ~SET `~network~error$
◎
Set response to a network error.
</li>
    </ol>
   </dd>

   <dt>`時間切れ^i （ timeout ）</dt>
   <dd>
( ~event `timeout$et, 例外  `TimeoutError^E )
を与える下で，`要請~error手続き$を走らす
◎
Run the request error steps for event timeout and exception TimeoutError.
</dd>
  </dl>
 </li>
</ol>

<p class="algo-head">
`要請~error手続き@
を走らすときは、所与の
( ~event %event , 例外 %exception （省略可）)
に対し：
◎
The request error steps for event event and optionally an exception exception are:
</p>

<ol>
 <li>
`状態$ ~SET `~done^i
◎
Set state to done.
</li>

 <li>
`~send~flag$ ~SET ~OFF
◎
Unset the send() flag.
</li>

 <li>
`応答$ ~SET `~network~error$
◎
Set response to a network error.
</li>

 <li>
~IF［
`同期~flag$ ~EQ ~ON
］
⇒
~THROW %exception
◎
If the synchronous flag is set, throw an exception exception.
</li>

 <li>
<p>
名前 `readystatechange$et の`~eventを発火する$ 
◎
Fire an event named readystatechange.
</p>

<p class="note">注記：
この時点で明らかに
`同期~flag$ ~EQ ~OFF
◎
At this point it is clear that the synchronous flag is unset.
</p></li>

 <li>
  <p>
~IF［
`~upload完了-~flag$ ~EQ ~OFF
］：
◎
If the upload complete flag is unset, follow these substeps:
</p><ol>
   <li>
`~upload完了-~flag$ ~SET ~ON
◎
Set the upload complete flag.
</li>

 <li>
( 0, 0 )
を与える下で，
`XMLHttpRequestUpload$I ~objに向けて，名前 `progress$et の`進捗~eventを発火する$
◎
Fire a progress event named progress on the XMLHttpRequestUpload object with 0 and 0.
</li>

 <li>
( 0, 0 )
を与える下で，
`XMLHttpRequestUpload$I ~objに向けて，名前 %event の`進捗~eventを発火する$
◎
Fire a progress event named event on the XMLHttpRequestUpload object with 0 and 0.
</li>

 <li>
( 0, 0 )
を与える下で，
`XMLHttpRequestUpload$I ~objに向けて，名前 `loadend$et の`進捗~eventを発火する$
◎
Fire a progress event named loadend on the XMLHttpRequestUpload object with 0 and 0. 
</li>
  </ol>

 </li>

 <li>
( 0, 0 )
を与える下で，名前 `progress$et の`進捗~eventを発火する$
◎
Fire a progress event named progress with 0 and 0.
</li>

 <li>
( 0, 0 )
を与える下で，名前 %event の`進捗~eventを発火する$
◎
Fire a progress event named event with 0 and 0.
</li>

 <li>
( 0, 0 )
を与える下で，名前 `loadend$et の`進捗~eventを発火する$
◎
Fire a progress event named loadend with 0 and 0. 
</li>

</ol>


			</section>
			<section id="the-abort()-method">

<h4 title="The abort() method">4.5.7. `abort()^m ~meth</h4>


<dl class="domintro">
 <dt><code>%client . `abort$m()</code></dt>
 <dd>
~network活動をすべて取消す。
◎
Cancels any network activity.
</dd>
</dl>

<p>
`abort()@m
~methの被呼出時には、次を走らせ~MUST：
◎
The abort() method, when invoked, must run these steps:
</p>

<ol>
 <li><!-- copy -->
`要請を終了-$させる
◎
Terminate the request.
</li>

 <li>
~IF［［
`状態$ ~EQ `~opened^i
］~AND［
`~send~flag$ ~EQ ~ON
］］~OR［
`状態$ ~IN
{ `~headers-received^i, `~loading^i }
］
⇒
( ~event `abort$et )
を与える下で，`要請~error手続き$を走らす
◎
If state is either opened with the send() flag set, headers received, or loading, run the request error steps for event abort.
</li>

 <li>
<p>
~IF［
`状態$ ~EQ `~done^i
］
⇒
`状態$ ~SET `~unsent^i
◎
If state is done, set state to unsent. 
</p>

<p class="note">注記：
いかなる `readystatechange$et ~eventも配送されない。
◎
No readystatechange event is dispatched.
</p>
 </li>
</ol>



			</section>
		</section>
		<section id="xmlhttprequest-response">

<h3 title="Response">4.6. 応答</h3>


<p>
`XMLHttpRequest$I には，
`応答@
が結付けられる。
他が定められない限り，それは`~network~error$である。
◎
An XMLHttpRequest has an associated response. Unless stated otherwise it is a network error.
</p>

<p>
`XMLHttpRequest$I ~objには、
`受信済み~byte列@
（~byte列）も結付けられる。
他が定められない限り，空~byte列とする。
◎
An XMLHttpRequest also has an associated received bytes (a byte sequence). Unless stated otherwise it is the empty byte sequence.
</p>

			<section id="the-responseurl-attribute">
<h4 title="The responseURL attribute">4.6.1. `responseURL^m 属性</h4>

<p>
`responseURL@m
属性は、［
`応答$の`url$rs ~NEQ ~NULL ならば それを［
`素片除外~flag^i ~SET ~ON
］の下に `直列化-$した結果
／
~ELSE_ 空文字列
］を返さ~MUST。
◎
The responseURL attribute must return the empty string if response's url is null and its serialization with the exclude fragment flag set otherwise.
</p>


			</section>
			<section id="the-status-attribute">

<h4 title="The status attribute">4.6.2. `status^m 属性</h4>

<p>
`status@m
属性は、`応答$の`~status$rsを返さ~MUST。
◎
The status attribute must return the response's status.
</p>

			</section>
			<section id="the-statustext-attribute">

<h4 title="The statusText attribute">4.6.3. `statusText^m 属性</h4>

<p>
`statusText@m
属性は、`応答$の`~status~message$rsを返さ~MUST。
◎
The statusText attribute must return the response's status message.
</p>

			</section>
			<section id="the-getresponseheader()-method">

<h4 title="The getResponseHeader() method">4.6.4. `getResponseHeader()^m ~meth</h4>

<p>
`getResponseHeader(name)@m
~methの被呼出時には、次を走らせ~MUST：
◎
The getResponseHeader(name) method must run these steps:
</p>

<ol>
 <li>
`応答$の`~header~list$rs内に［
`名前$ ~EQ %name なる`~header$
］はない
］
⇒
~RET ~NULL
◎
If response's header list has no header whose name is name, then return null.
</li>
 <li>
~RET
( %名前, `応答$の`~header~list$rs )
に対する`結合済みの値$
◎
Return the combined value given name and response's header list.
</li>

</ol>

<p class="note">注記：
`応答$に公開される`~header~list$rsは、 Fetch 標準に従って，絞り込まれる。
`FETCH$r
◎
The Fetch Standard filters response's header list. [FETCH]
</p>


<div class="example">

<p>
次の~scriptにおいては：
◎
For the following script:
</p>

<pre>
var %client = new XMLHttpRequest();
%client.open("GET", "unicorns-are-teh-awesome.txt", true);
%client.send();
%client.onreadystatechange = function() {
  if(this.readyState == this.HEADERS_RECEIVED) {
    print(client.getResponseHeader("Content-Type"));
  }
}
</pre>

<p>
`print()^c 関数は、次と同様の結果を得ることになる：
◎
The print() function will get to process something like:
</p>

<pre>text/plain; charset=UTF-8
</pre>

</div>


			</section>
			<section id="the-getallresponseheaders()-method">

<h4 title="The getAllResponseHeaders() method">4.6.5. `getAllResponseHeaders()^m ~meth</h4>


<p>
`getAllResponseHeaders()@m
~methの被呼出時には、次を走らせ~MUST：
◎
The getAllResponseHeaders() method, when invoked, must run these steps:
</p>

<ol>
 <li>
%出力 ~LET 空~byte列
◎
Let output be an empty byte sequence.
</li>

 <li>
%~header~list ~LET `応答$の`~header~list$rsを`整列して結合-$した結果
◎
Let headers be the result of running sort and combine with response's header list.
</li>

 <li>
<p>
~FOR
%~header~list 内の~EACH( %~header ) に対し：
◎
For each header in headers, run these substeps:
</p>

  <ol>
   <li>
<p>
%出力 に次の並びを付加する：
</p>

<ol ><li>%~header の`名前$
</li><li>~byte対 0x3A 0x20
</li><li>%~header の`値$
</li></ol>

◎
Append header's name, followed by a 0x3A 0x20 byte pair, followed by header's value, to output.
</li>

   <li>
~IF［
この回の~~反復は最後でない
］
⇒
%出力 に~byte対 0x0D 0x0A を付加する
◎
If header is not the last pair in headers, then append a 0x0D 0x0A byte pair, to output.
</li>
  </ol>

 <li>
~RET %出力
◎
Return output.
</li>
</ol>


<p class="note">注記：
`応答$に公開される`~header~list$rsは、 Fetch 標準に従って，絞り込まれる。
`FETCH$r
◎
The Fetch Standard filters response's header list. [FETCH]
</p>

<div class="example">
<p>
次の~scriptに対し：
◎
For the following script:
</p>

<pre>
var %client = new XMLHttpRequest();
%client.open("GET", "narwhals-too.txt", true);
%client.send();
%client.onreadystatechange = function() {
  if(this.readyState == this.HEADERS_RECEIVED) {
    print(this.getAllResponseHeaders());
  }
}
</pre>

<p><!-- copy -->
`print()^c 関数は、次と同類の結果を得ることになる：
◎
The print() function will get to process something like:
</p>

<pre>
Date: Sun, 24 Oct 2004 04:58:38 GMT
Server: Apache/1.3.31 (Unix)
Keep-Alive: timeout=15, max=99
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/plain; charset=utf-8
</pre>

</div>



			</section>
			<section id="response-body">

<h4 title="Response body">4.6.6. 応答~本体</h4>

<p>
`応答 MIME 型@
とは、
`Content-Type^h ~headerに含まれている MIME 型（各種~parameterは除外する）の
`ASCII 小文字化$
である。
ただし、その応答~headerが［
構文解析できない／省略されている
］場合は ~NULL とする。
`上書き MIME 型@
の初期値は ~NULL であり，その値は `overrideMimeType()$m を呼出せば得られる。
`最終 MIME 型@
は、 `上書き MIME 型$が［
非 ~NULL ならばその値 ／
~NULL ならば`応答 MIME 型$
］とする。
◎
The response MIME type is the MIME type the `Content-Type` header contains excluding any parameters and converted to ASCII lowercase, or null if the response header can not be parsed or was omitted. The override MIME type is initially null and can get a value if overrideMimeType() is invoked. Final MIME type is the override MIME type unless that is null in which case it is the response MIME type.
</p>

<p>
`応答~charset@
は、 `Content-Type^h ~headerの ~charset~parameterの値とする。
ただし、 ~charset~parameterが存在しない場合，あるいは
~headerが
構文解析できない／省略されている
場合は ~NULL とする。
`上書き~charset@
の初期値は ~NULL であり，その値は `overrideMimeType()$m を呼出せば得られる。
`最終~charset@
は、`上書き~charset$が［
非 ~NULL ならばその値 ／
~NULL ならば`応答~charset$
］とする。
◎
The response charset is the value of the charset parameter of the `Content-Type` header or null if there was no `charset` parameter or the header could not be parsed or was omitted. The override charset is initially null and can get a value if overrideMimeType() is invoked. Final charset is the override charset unless that is null in which case it is the response charset.
</p>

<hr>

<p>
`XMLHttpRequest$I ~objには、［
`応答 ArrayBuffer ~obj@,
`応答 Blob ~obj@,
`応答 Document ~obj@,
`応答 JSON ~obj@
］が結付けられる。
それらの共通の初期値は ~NULL とする。
<span class="trans-note">【
これらのうち実際に有効になるのは、高々一つだけになる（共用体とふるまいが似る）。
】</span>
◎
An XMLHttpRequest object has an associated response ArrayBuffer object, response Blob object, response Document object, and a response JSON object. Their shared initial value is null.
</p>

<hr>

<p class="algo-head">
`~arraybuffer応答@
は、次の手続きが返す値である：
◎
An arraybuffer response is the return value of these steps:
</p>

<ol>
 <li>
~IF［
`応答 ArrayBuffer ~obj$ ~NEQ ~NULL
］
⇒
~RET それ
◎
If response ArrayBuffer object is non-null, return it.
</li>

 <li>
<p>
`応答 ArrayBuffer ~obj$ ~SET `受信済み~byte列$を表現する新たな `ArrayBuffer$I ~obj
— ただし、例外が投出された場合は
⇒
`応答 ArrayBuffer ~obj$ ~SET ~NULL；<br>
`受信済み~byte列$ ~SET 空~byte列
◎
Set response ArrayBuffer object to a new ArrayBuffer object representing received bytes. If this throws an exception, then set response ArrayBuffer object to null and set received bytes to the empty byte sequence.
</p>

<p class="note">注記：
`ArrayBuffer^I に~bufferを割り当てることの成功-は保障されない。
`ECMASCRIPT$r
◎
Allocating an ArrayBuffer buffer is not guaranteed to succeed. [ECMASCRIPT]
</p>
</li>

<li>
~RET `応答 ArrayBuffer ~obj$
◎
Return response ArrayBuffer object.
</li>

</ol>


<p class="algo-head">
`blob 応答@
は、次の手続きが返す値である：
◎
A blob response is the return value of these steps:
</p>

<ol>
 <li>
~IF［
`応答 Blob ~obj$ ~NEQ ~NULL
］
⇒
~RET それ
◎
If response Blob object is non-null, return it.
</li>

 <li>
%型 ~LET ［
`最終 MIME 型$ ~NEQ ~NULL ならば それ ／
~ELSE_ 空文字列
］
◎
Let type be the empty string, if final MIME type is null, and final MIME type otherwise.
</li>

 <li>
<p>
`応答 Blob ~obj$ ~SET 次のようにされた，新たな `Blob$I ~obj
⇒
`受信済み~byte列$を表現する；<br>
<a href="~FILEAPI#dfn-type">`type^m</a> ~SET %型
</p>

<p>
~RET `応答 Blob ~obj$
</p>

◎
Set response Blob object to a new Blob object representing received bytes with type type and return it.
</li>

</ol>

<p class="algo-head">
`文書~応答@
は、次の手続きが返す値である：
◎
A document response is the return value of these steps:
</p>


<ol>
 <li>
~IF［
`応答 Document ~obj$ ~NEQ ~NULL
］
⇒
~RET それ
◎
If response Document object is non-null, return it.
</li>

 <li>
~IF［
`応答$の`本体$rs ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If response's body is null, then return null.
</li>

 <li>
~IF［
`最終 MIME 型$ ~NIN
{ ~NULL, `text/html^l, `text/xml^l, `application/xml^l }
］~AND［
`最終 MIME 型$は `+xml^l で終端していない
］
⇒
~RET ~NULL
◎
If final MIME type is not null, text/html, text/xml, application/xml, or does not end in +xml, return null.
</li>

 <li>
<p>
~IF［
`responseType$m ~EQ 空文字列
］~AND［
`最終 MIME 型$ ~EQ `text/html^l
］
⇒
~RET ~NULL
◎
If responseType is the empty string and final MIME type is text/html, return null.
</p>

<p class="note">注記：
旧来~内容を壊さないようにするため、ここでは
`responseType$m は `document^l に制約される。
◎
This is restricted to responseType being "document" in order to prevent breaking legacy content.
</p>
 </li>

 <li>
<p>
~IF［
`最終 MIME 型$ ~EQ `text/html^l
］：
◎
If final MIME type is text/html, run these substeps:
</p>

  <ol>
   <li>
%charset ~LET ［
`最終~charset$ ~NEQ ~NULL ならば それ ／
~ELSE_ ［
`受信済み~byte列$の最初の 1024 ~byteを
<a href="~HTML5/syntax.html#prescan-a-byte-stream-to-determine-its-encoding">~prescan</a>
して 成功裡に結果を得られた
］ならば その結果 ／ 
~ELSE_ `utf-8$
］
◎
Let charset be the final charset.
◎
If charset is null, prescan the first 1024 bytes of received bytes and if that does not terminate unsuccessfully then let charset be the return value.
◎
If charset is null, set charset to utf-8.
</li>

   <li>
%文書 ~LET ［
HTML 標準の HTML 構文解析に~~定められた規則に従って，［
~scriptは不能化し, 
<a href="~HTML5/syntax.html#a-known-definite-encoding">既知の確定的な符号化方式</a> 
%charset
］の下で，`受信済み~byte列$を構文解析した結果
］を表現する `文書$
`HTML$r
◎
Let document be a document that represents the result parsing received bytes following the rules set forth in the HTML Standard for an HTML parser with scripting disabled and a known definite encoding charset. [HTML]
</li>

   <li>
%文書 の`種別$doc ~SET `html^l
◎
Flag document as an HTML document.
</li>

  </ol>
 </li>

 <li>
<p>
~ELSE：
</p>

<div>
  <ol>
   <li>
%文書 ~LET 
<a href="~HTML5/xhtml.html#xml-scripting-support-disabled">XML ~script~supportを不能化-</a>した下で，`受信済み~byte列$を
<a href="~HTML5/xhtml.html#xml-parser">XML 構文解析器</a>
`HTML$r にかけた結果を表現する，`文書$
</li>

   <li>
~IF［
構文解析に失敗した（未~supportの文字~符号化方式, 名前空間整形式~error, 等々）
］
⇒
~RET ~NULL
</li>
  </ol>
◎
Otherwise, let document be a document that represents the result of running the XML parser with XML scripting support disabled on received bytes. If that fails (unsupported character encoding, namespace well-formedness error, etc.), then return null. [HTML]
</div>

<p class="note">注記：
文書から参照されている資源は読込まれず,
文書に結付けられている XSLT は適用されない。
◎
Resources referenced will not be loaded and no associated XSLT will be applied.
<!-- XXX more formally?! -->
</p>
 </li>

 <li>
~IF［
%charset ~EQ ~NULL
］
⇒
%charset ~SET `utf-8$
◎
If charset is null, set charset to utf-8.
</li>

 <li>
%文書 の`符号化方式$ ~SET %charset
◎
Set document's encoding to charset.
</li>

 <li>
%文書 の
`内容型$ ~SET `最終 MIME 型$
◎
Set document's content type to final MIME type.
</li>

 <li>
%文書 の`~URL$ ~SET `応答$の`url$rs
◎
Set document's URL to response's url.
</li>

 <li>
%文書 の`生成元$ ~SET
`文脈~obj$に`関連する設定群~obj$の`生成元$
◎
Set document's origin to context object's relevant settings object's origin.
</li>

 <li>
<p>
`応答 Document ~obj$ ~SET %文書
</p>

<p>
~RET %文書
</p>

◎
Set response Document object to document and return it.
</li>
</ol>


<p class="algo-head">
`JSON 応答@
は、次の手続きが返す値である：
◎
A JSON response is the return value of these steps:
</p>

<ol>
 <li>
~IF［
`応答 JSON ~obj$ ~NEQ ~NULL
］
⇒
~RET それ
◎
If response JSON object is non-null, return it.
</li>

 <li>
~IF［
`応答$の`本体$rs ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If response's body is null, then return null.
</li>

 <li>
%~JSON~text ~LET
`受信済み~byte列$を`utf-8 復号-$した結果
◎
Let JSON text be the result of running utf-8 decode on received bytes.
</li>

 <li>

<p>
%~JSON~obj ~LET
`JSON^c ~objの `parse^c ~propの初期値
<span class="trans-note">【である関数】</span>
を，その唯一の引数に %~JSON~text を渡して呼出した結果
`ECMASCRIPT$r
</p>

<p>
~IF［
`parse^c 関数から例外が投出された
］
⇒
~RET ~NULL
</p>

◎
Let JSON object be the result of invoking the initial value of the parse property of the JSON object, with JSON text as its only argument. If that threw an exception, return null. [ECMASCRIPT]
</li>

 <li>
<p>
`応答 JSON ~obj$ ~SET %~JSON~obj
</p>

<p>
~RET %~JSON~obj
</p>

◎
Set response JSON object to JSON object and return it.
</li>

</ol>

<p class="algo-head">
`~text応答@
は、次の手続きが返す値である：
◎
A text response is the return value of these steps:
</p>

<ol>

 <li>
~IF［
`応答$の`本体$rs ~EQ ~NULL
］
⇒
~RET 空文字列
◎
If response's body is null, then return the empty string.
</li>

 <li>
%charset ~LET
`最終~charset$
◎
Let charset be the final charset.
</li>

 <li>
<p>
~IF［
`responseType$m ~EQ 空文字列
］~AND［
%charset ~EQ ~NULL
］~AND［［
`最終 MIME 型$ ~IN
{ ~NULL, `text/xml^l, `application/xml^l }
］~OR［
`最終 MIME 型$ は `+xml^l で終端する
］］
⇒
%charset ~LET
XML 仕様に規定される規則に従って決定される符号化方式
`XML$r
`XMLNS$r
◎
If responseType is the empty string, charset is null, and final MIME type is either null, text/xml, application/xml or ends in +xml, use the rules set forth in the XML specifications to determine the encoding. Let charset be the determined encoding. [XML] [XMLNS]
</p>

<p class="note">注記：
非旧来 `responseType$m 値 `text^l を単純なままに保つため、ここでは `responseType$m は空文字列に制約される。
◎
This is restricted to responseType being the empty string to keep the non-legacy responseType value "text" simple.
</p>
 </li>

 <li>
~IF［
%charset ~EQ ~NULL 
］
⇒
%charset ~SET `utf-8$
◎
If charset is null, set charset to utf-8.
</li>

 <li>
~RET ~fallback符号化方式に %charset を用いて，`受信済み~byte列$を`復号-$した結果
◎
Return the result of running decode on received bytes using fallback encoding charset.
</li>

</ol>

<p class="note">注記：
作者には、資源を符号化する際には，常に`utf-8$ を用いることが強く奨励される。
◎
Authors are strongly encouraged to always encode their resources using utf-8.
</p>



			</section>
			<section id="the-overridemimetype()-method">

<h4 title="The overrideMimeType() method">4.6.7. `overrideMimeType()^m ~meth</h4>

<dl class="domintro">
 <dt><code>%client . `overrideMimeType$m(%mime)</code></dt>
 <dd>
`応答$の `Content-Type^h ~headerを %mime にする。
◎
Sets the `Content-Type` header for response to mime.
</dd>
 <dd>
`状態$ ~EQ `~loading^i ／ `~done^i の場合、
`InvalidStateError^E 例外が投出される。
◎
Throws an InvalidStateError exception if state is loading or done.
</dd>
 <dd>
%mime が妥当な MIME 型でない場合、 `SyntaxError^E 例外が投出される。
◎
Throws a SyntaxError exception if mime is not a valid MIME type.
</dd>
</dl>

<p>
`overrideMimeType(mime)@m
~methの被呼出時には、次を走らせ~MUST：
◎
The overrideMimeType(mime) method must run these steps:
</p>

<ol>
 <li>
~IF［
`状態$ ~IN
{ `~loading^i, `~done^i }
］
⇒
~THROW `InvalidStateError^E
◎
If state is loading or done, throw an InvalidStateError exception.
</li>

 <li>
~IF［
`Content-Type^h ~headerの値のときと類似の構文解析による，
%mime の構文解析に失敗した
］
⇒
~THROW `SyntaxError^E
◎
If parsing mime analogously to the value of the `Content-Type` header fails, throw a SyntaxError exception.
</li>

 <li>
~IF［
%mime は成功裡に構文解析された
］
⇒
`上書き MIME 型$ ~SET （~parameterを除外した）その MIME 型の`ASCII 小文字化$
◎
If mime is successfully parsed, set override MIME type to its MIME type, excluding any parameters, and converted to ASCII lowercase.
</li>

 <li>
~IF［
`charset^c ~parameterは成功裡に構文解析された
］
⇒
`上書き~charset$ ~SET その値
◎
If a `charset` parameter is successfully parsed, set override charset to its value.
</li>
</ol>

			</section>
			<section id="the-responsetype-attribute">

<h4 title="The responseType attribute">4.6.8. `responseType^m 属性</h4>


<dl class="domintro">

 <dt><code>%client . `responseType$m</code> [ = %value ]</dt>
 <dd>
応答の種別を返す。
◎
Returns the response type.
</dd>
 <dd>
設定して、応答の種別を変更できる。
値は次のいずれか
⇒
空文字列 （既定）,
`arraybuffer^l,
`blob^l,
`document^l,
`json^l,
`text^l
◎
Can be set to change the response type. Values are: the empty string (default), "arraybuffer", "blob", "document", "json", and "text".
</dd>
 <dd>
<p>
被設定時には：
◎
↓</p>

  <ul>
   <li>
`~entry設定群~obj$の`大域~obj$は
`Window$I ~objでない場合、
`document^l に設定しても無視される。
◎
When set: setting to "document" is ignored if entry settings object's global object is not a Window object.
</li>

   <li>
`状態$ ~EQ `~loading^i ／ `~done^i の場合、
`InvalidStateError^E 例外が投出される。
◎
When set: throws an InvalidStateError exception if state is loading or done.
</li>

   <li>
`同期~flag$ ~EQ ~ON, かつ
`~entry設定群~obj$の`大域~obj$は
`Window$I ~objである場合、
`InvalidAccessError^E 例外が投出される。
◎
When set: throws an InvalidAccessError exception if the synchronous flag is set and entry settings object's global object is a Window object.
</li>

  </ul>
 </dd>
</dl>


<p>
`responseType@m
属性は、その値を返さ~MUST。
その初期値は空文字列で~MUST。
◎
The responseType attribute must return its value. Initially its value must be the empty string.
</p>

<p>
`responseType$m
属性の被設定時には、次を走らせ~MUST：
◎
Setting the responseType attribute must run these steps:
</p>

<ol>

 <li>
~IF［
`~entry設定群~obj$の`大域~obj$は
`Window$I ~objでない
］~AND［
所与の値 ~EQ `document^l
］
⇒
~RET
◎
If entry settings object's global object is not a Window object and the given value is "document", terminate these steps.
</li>

 <li>
~IF［
`状態$ ~IN
{ `~loading^i, `~done^i }
］
⇒
~THROW `InvalidStateError^E
◎
If state is loading or done, throw an InvalidStateError exception.
</li>

 <li><!-- copy -->
~IF［
`~entry設定群~obj$の`大域~obj$は `Window$I ~objである
］~AND［
`同期~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidAccessError^E
◎
If entry settings object's global object is a Window object and the synchronous flag is set, throw an InvalidAccessError exception.
</li>

 <li>
`responseType$m
属性の値 ~SET 所与の値
◎
Set the responseType attribute's value to the given value.
</li>
</ol>




			</section>
			<section id="the-response-attribute">

<h4 title="The response attribute">4.6.9. `response^m 属性</h4>

<dl class="domintro">
 <dt><code>%client . `response$m</code></dt>
 <dd>
`応答$の`本体$rsを返す。
◎
Returns the response's body.
</dd>
</dl>

<p>
`response@m
属性は、次の手続きの結果を返さ~MUST：
◎
The response attribute must return the result of running these steps:
</p>

<ol>
 <li>
<p>
~IF［
`responseType$m ~IN
{ 空文字列, `text^l }
］：
◎
If responseType is the empty string or "text"
</p>
  <ol>
   <li>
~IF［
`状態$ ~NIN
{ `~loading^i, `~done^i }
］
⇒
~RET 空文字列
◎
If state is not loading or done, return the empty string.
</li>

   <li>
~RET `~text応答$
◎
Return the text response.
</li>
  </ol>
 </li>

 <li>
<p>
~ELSE：
◎
Otherwise
</p>

  <ol>
   <li>
~IF［
`状態$ ~NEQ `~done^i
］
⇒
~RET ~NULL
◎
If state is not done, return null.
</li>

   <li>
<p>
`responseType$m に応じて：
</p>
    <dl class="switch">
     <dt>
`arraybuffer^l
◎
If responseType is "arraybuffer"
</dt>
     <dd>
~RET `~arraybuffer応答$
◎
Return the arraybuffer response.
</dd>

     <dt>
`blob^l
◎
If responseType is "blob"
</dt>
     <dd>
~RET `blob 応答$
◎
Return the blob response.
</dd>

     <dt>
`document^l
◎
If responseType is "document"
</dt>

     <dd>
~RET `文書~応答$
◎
Return the document response.
</dd>

     <dt>
`json^l
◎
If responseType is "json"
</dt>

     <dd>
~RET `JSON 応答$
◎
Return the JSON response.
</dd>
    </dl>
   </li>
  </ol>
 </li>
</ol>



			</section>
			<section id="the-responsetext-attribute">

<h4 title="The responseText attribute">4.6.10. `responseText^m 属性</h4>

<dl class="domintro">
 <dt><code>%client . `responseText$m</code></dt>
 <dd>
`~text応答$を返す。
◎
Returns the text response.
</dd>
 <dd>
`responseType$m ~NEQ 空文字列, かつ ~NEQ `text^l の場合、
`InvalidStateError^E 例外が投出される。
◎
Throws an InvalidStateError exception if responseType is not the empty string or "text".
</dd>
</dl>

<p>
`responseText@m
属性は、次の手続きの結果を返さ~MUST：
◎
The responseText attribute must return the result of running these steps:
</p>

<ol>

 <li>
~IF［
`responseType$m ~NIN
{ 空文字列, `text^l }
］
⇒
~THROW `InvalidStateError^E
◎
If responseType is not the empty string or "text", throw an InvalidStateError exception.
</li>

 <li>
~IF［
`状態$ ~NIN
{ `~loading^i, `~done^i }
］
⇒
~RET 空文字列
◎
If state is not loading or done, return the empty string.
</li>

 <li>
~RET `~text応答$
◎
Return the text response.
</li>
</ol>


			</section>
			<section id="the-responsexml-attribute">

<h4 title="The responseXML attribute">4.6.11. `responseXML^m 属性</h4>

<dl class="domintro">
 <dt><code>%client . `responseXML$m</code></dt>
 <dd>
`文書~応答$
を返す。
◎
Returns the document response.
</dd>
 <dd>
`responseType$m 値が
空文字列でも `document^l でもない場合、
`InvalidStateError^E 例外が投出される。
◎
Throws an InvalidStateError exception if responseType is not the empty string or "document".
</dd>
</dl>

<p>
`responseXML@m
属性は、次の手続きの結果を返さ~MUST：
◎
The responseXML attribute must return the result of running these steps:
</p>

<ol>

 <li>
~IF［
`responseType$m ~NIN
{ 空文字列, `document^l }
］
⇒
~THROW `InvalidStateError^E
◎
If responseType is not the empty string or "document", throw an InvalidStateError exception.
</li>


 <li>
~IF［
`状態$ ~NEQ `~done^i
］
⇒
~RET ~NULL
◎
If state is not done, return null.
</li>

 <li>
~RET `文書~応答$
◎
Return the document response.
</li>
</ol>


<p class="note">注記：
歴史的な理由から， `responseXML$m 属性はその名に “XML” を含んでいる。
それはまた、HTML 資源を `文書$として返す。
◎
The responseXML attribute has XML in its name for historical reasons. It also returns HTML resources as documents.
</p>


			</section>
		</section>
		<section id="events">

<h3 title="Events summary">4.7. ~event要覧</h3>

~INFORMATIVE

<p>
以下の~eventが `XMLHttpRequest$I や `XMLHttpRequestUpload$I  ~objに向けて配送される：
◎
The following events are dispatched on XMLHttpRequest and/or XMLHttpRequestUpload objects:
</p>

<table>

<thead><tr><th>~event名◎Event name
</th><th>~interface◎Interface
</th><th>配送-時機◎Dispatched when…
</th></tr></thead>

 <tbody>
<tr><td>`readystatechange@et
</td><td>`Event$I
</td><td>
`readyState$m 属性の値が変化したとき。
ただし， `UNSENT$m に変化したときは除く。
◎
The readyState attribute changes value, except when it changes to UNSENT.

</td></tr><tr><td>`loadstart@et
</td><td>`ProgressEvent$I
</td><td>
~fetchが起動されたとき。
◎
The fetch initiates.

</td></tr><tr><td>`progress@et
</td><td>`ProgressEvent$I
</td><td>
~dataを伝送-中のとき。
◎
Transmitting data.

</td></tr><tr><td>`abort@et
</td><td>`ProgressEvent$I
</td><td>
~fetchが中止されたとき。
例えば， `abort()$m ~methの呼出しなど。
◎
When the fetch has been aborted. For instance, by invoking the abort() method.

</td></tr><tr><td>`error@et
</td><td>`ProgressEvent$I
</td><td>
~fetchに失敗したとき。
◎
The fetch failed.

</td></tr><tr><td>`load@et
</td><td>`ProgressEvent$I
</td><td>
~fetchを成功裡に終えたとき。
◎
The fetch succeeded.

</td></tr><tr><td>`timeout@et
</td><td>`ProgressEvent$I
</td><td>
~fetchが完了する前に時間切れになったとき。
◎
The author specified timeout has passed before the fetch completed.

</td></tr><tr><td>`loadend@et
</td><td>`ProgressEvent$I
</td><td>
~fetchが完了したとき（成功, 失敗, いずれに関わらず）。
◎
The fetch completed (success or failure).

</td></tr></tbody>
</table>



		</section>
	</section>
	<section id="interface-formdata">

<h2 title="Interface FormData">5. ~interface `FormData^I</h2>

<pre class="idl">
typedef (`Blob$I or ~USVS) `FormDataEntryValue@I;

[<a href="#dom-formdata">Constructor</a>(optional `HTMLFormElement$I %form),
 Exposed=(Window,Worker)]
interface `FormData@I {
  void `append$m(~USVS %name, ~USVS %value);
  void `append$m(~USVS %name, `Blob$I %value, optional ~USVS %filename);
  void `delete$m(~USVS %name);
  `FormDataEntryValue$I? `get$m(~USVS %name);
  sequence&lt;`FormDataEntryValue$I&gt; `getAll$m(~USVS %name);
  boolean `has$m(~USVS %name);
  void `set$m(~USVS %name, ~USVS %value);
  void `set$m(~USVS %name, `Blob$I %value, optional ~USVS %filename);
  iterable&lt;~USVS, `FormDataEntryValue$I&gt;;
};</pre>

<p>
`FormData$I ~objは、順序付けられた
`~entry@
の~listを表現する。
それぞれの`~entry$は，
`名前$fe
と
`値$fe
を持つ。
◎
The FormData object represents an ordered list of entries. Each entry consists of a name and a value.
</p>

<p>
他の~algoとのやりとりの目的においては、`~entry$の型は［
その`値$feが文字列であるならば `string^l ／
~ELSE_ `file^l
］とする。
`~entry$の型が `file^l の場合、その~filenameは［
~entryが `File$I ~objでないならば 空文字列 ／
~ELSE_ `~entry$の`値$feの `name$m 属性値
］で与えられる。
◎
For the purposes of interaction with other algorithms, an entry's type is "string" if its value is a string and "file" otherwise. If an entry's type is "file", its filename is the empty string if value is not a File object, and otherwise its filename is the value of entry's value's name attribute.
</p>


<p>
`FormData(form)@m
構築子は、次を走らせ~MUST：
◎
The FormData(form) constructor must run these steps:
</p>

<ol>
 <li>
%fd ~LET 新たな `FormData$I ~obj
◎
Let fd be a new FormData object.
</li>

 <li>
~IF［
%form 引数は与えられている
］
⇒
%fd の一連の`~entry$ ~SET
%form に対し`~form_data_setを構築-$した結果
◎
If form is given, set fd's entries to the result of constructing the form data set for form.
</li>

 <li>
~RET %fd
◎
Return fd.
</li>
</ol>

<p>
`append(name, value, filename)@m
~methの被呼出時には、次を走らせ~MUST：
◎
The append(name, value, filename) method, when invoked, must run these steps:
</p>


<ol>
 <li>
~IF［
%filename 引数は与えられている
］
⇒
%value ~SET 
次のようにされた，新たな `File$I ~obj
⇒
内容 ~SET %value；<br>
`name$m ~SET %filename
 <!-- XXX at some point File API should get internal slots for this -->
◎
If the filename argument is given, set value to a new File object whose contents are value and name is filename.
</li>

 <li>
`文脈~obj$の`~entry$の~listに，次のようにされた新たな`~entry$を付加する
⇒
`名前$fe ~SET %name；<br>
`値$fe ~SET %value
◎
Append a new entry whose name is name, and value is value, to context object's list of entries. 
</li>
</ol>

<p>
`delete(name)@m
~methの被呼出時には、［
`名前$fe ~EQ %name
］なる すべての`~entry$を除去し~MUST。 
◎
The delete(name) method, when invoked, must remove all entries whose name is name.
</p>

<p>
`get(name)@m
~methの被呼出時には、［［
`名前$fe ~EQ %name
］なる`~entry$が在れば，その最初の~entryの`値$fe ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The get(name) method, when invoked, must return the value of the first entry whose name is name, and null otherwise.
</p>

<p>
`getAll(name)@m
~methの被呼出時には、~list順による，［［
`名前$fe ~EQ %name
］なる すべての`~entry$
］の`値$feからなる~list（存在しなければ空~list）を返さ~MUST。
◎
The getAll(name) method, when invoked, must return the values of all entries whose name is name, in list order, and the empty sequence otherwise.
</p>


<p>
`has(name)@m
~methの被呼出時には、［［
`名前$fe ~EQ %name
］なる `~entry$が在るならば~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The has(name) method, when invoked, must return true if there is an entry whose name is name, and false otherwise.
</p>


<p>
`set(name, value, filename)@m
~methの被呼出時には、次を走らせ~MUST：
◎
The set(name, value, filename) method, when invoked, must run these steps:
</p>

<ol>
 <li>
~IF［
%filename 引数は与えられている
］
⇒
%value ~SET 
次のようにされた，新たな `File$I ~obj
⇒
内容 ~SET %value；<br>
`name$m ~SET %filename
 <!-- XXX at some point File API should get internal slots for this -->
◎
If the filename argument is given, set value to a new File object whose contents are value and name is filename.
</li>

 <li>
%entry ~LET 次のようにされた，新たな `~entry$
⇒
`名前$fe ~SET %name；<br>
`値$fe ~SET %value
◎
Let entry be a new entry whose name is name, and value is value.
</li>

 <li>
~IF［
`文脈~obj$の`~entry$の~list内に［
`名前$fe ~EQ %name
］なる `~entry$が在る
］
⇒
それらの`~entry$のうち，最初のものを
%entry で置換し, 残りのそれらはすべて除去する
◎
If there are any entries in context object's list of entries whose name is name, replace the first such entry with entry and remove the others.
</li>

 <li>
~ELSE
⇒
`文脈~obj$の`~entry$の~listに %entry を付加する
◎
Otherwise, append entry to context object's list of entries.
</li>

</ol>



<p>
`反復される値ペア$の［
key, value
］は、順に
`~entry$の［
`名前$fe,
`値$fe
］である。
◎
The value pairs to iterate over are the entries with the key being the name and the value the value.
</p>


	</section>
	<section id="interface-progressevent">

<h2 title="Interface ProgressEvent">6. ~interface `ProgressEvent^I</h2>

<pre class="idl">
[<a href="https://dom.spec.whatwg.org/#concept-event-constructor">Constructor</a>(~DS %type, optional `ProgressEventInit$I %eventInitDict),
 Exposed=(Window,DedicatedWorker,SharedWorker)]
interface <dfn id="progressevent">ProgressEvent</dfn> : `Event$I {
  ~RA boolean `lengthComputable$m;
  ~RA unsigned long long `loaded$m;
  ~RA unsigned long long `total$m;
};

dictionary `ProgressEventInit@I : `EventInit$I {
  boolean <span title="dom-ProgressEventInit-lengthComputable">lengthComputable</span> = false;
  unsigned long long <span title="dom-ProgressEventInit-loaded">loaded</span> = 0;
  unsigned long long <span title="dom-ProgressEventInit-total">total</span> = 0;
};</pre>

<p>
`ProgressEvent$I ~interfaceを利用する`~event$は、何らかの進捗を指示する。
◎
Events using the ProgressEvent interface indicate some kind of progression.
</p>

<p>
`lengthComputable@m,
`loaded@m,
`total@m
属性は、初期化-時の値を返さ~MUST。
◎
The lengthComputable, loaded, and total attributes must return the value they were initialized to.
</p>


		<section id="firing-events-using-the-progressevent-interface">
<h3 title="Firing events using the ProgressEvent interface">6.1. `ProgressEvent^I ~interfaceを利用する~eventの発火</h3>


<p>
名前 %e の
`進捗~eventを発火する@
ときは、所与の
( %伝送量, %長th )
に対し，次の様にされた 名前 %e の`~eventを発火する$：
◎
To fire a progress event named e given transmitted and length, fire an event named e with an event using the ProgressEvent interface that also meets these conditions:
</p>

<ul>
 <li>
~eventは `ProgressEvent$I ~interfaceを利用する
◎
↑</li>
 <li>
`loaded$m 属性~値 ~SET %伝送量
◎
Set the loaded attribute value to transmitted.
</li>

 <li>
~IF［
%長th ~NEQ 0
］
⇒
`lengthComputable$m 属性~値 ~SET ~T；<br>
`total$m 属性~値 ~SET %長th
◎
If length is not 0, set the lengthComputable attribute value to true and the total attribute value to length. 
</li>
</ul>

		</section>
		<section id="suggested-names-for-events-using-the-progressevent-interface">

<h3 title="Suggested names for events using the ProgressEvent interface">6.2. `ProgressEvent^I ~interfaceを利用する~eventに推挙される名前</h3>

~INFORMATIVE

<p>
`ProgressEvent$I ~interfaceを利用する`~event$に推挙される， `type$m 属性の値を、下の一覧に要約する。
仕様の編集者が，その仕様に固有の仔細に応じて調整することは自由であるが、問題に馴染みのある人達からの~~意見を汲むために，その用法について WHATWG ~communityにて論をかわすことが強く奨励される。
◎
The suggested type attribute values for use with events using the ProgressEvent interface are summarized in the table below. Specification editors are free to tune the details to their specific scenarios, though are strongly encouraged to discuss their usage with the WHATWG community to ensure input from people familiar with the subject.
</p>

<table>

<thead><tr><th>`type$m 属性値◎type attribute value
</th><th>説明◎Description
</th><th>回数◎Times
</th><th>時機◎When
</th></tr></thead>

<tbody><tr><th>`loadstart$et
</th><td>
進捗が開始された。
◎
Progress has begun.
</td><td>1 回◎Once.
</td><td>最初。◎First.

</td></tr><tr><th>`progress$et
</th><td>
進捗~中。
◎
In progress.
</td><td>1 回以上◎Once or more.
</td><td>
`loadstart$et が`配送-$された後。
◎
After loadstart has been dispatched.

</td></tr><tr><th>`error$et
</th><td>進捗に失敗した。◎Progression failed.
</td><td rowspan="4" style="min-width:6em;">
高々 1 回<br>
（排他的）
◎
Zero or once (mutually exclusive).
</td><td rowspan="4">
最後の `progress$et が`配送-$された後。
◎
After the last progress has been dispatched.

</td></tr><tr><th>`abort$et
</th><td>進捗は終了された。◎Progression is terminated.

</td></tr><tr><th>`timeout$et
</th><td>
進捗は時間切れのため終了された。
◎
Progression is terminated due to preset time expiring.

</td></tr><tr><th>`load$et
</th><td>進捗は成功裡に終わった。◎Progression is successful.

</td></tr><tr><th>`loadend$et
</th><td>進捗は停止された。◎Progress has stopped.
</td><td>1 回◎Once.</td><td>
`error$et, `abort$et, `timeout$et, `load$et のいずれかが`配送-$された後。
◎
After one of error, abort, timeout or load has been dispatched.

</td></tr></tbody></table>




<p>
~event型
`error$et, `abort$et, `timeout$et, `load$et
は、互いに排他的である。
<!-- 
【これら 4 種のいずれかは 1 回 生じる】
 -->
◎
The error, abort, timeout, and load event types are mutually exclusive.
</p>

<p>
Web ~platform全般に渡り，~event型
`error$et, `abort$et, `timeout$et, `load$et
の `bubbles$m および `cancelable$m 属性は、 ~F に初期化される。
従って，一貫性を保つため、 `ProgressEvent$I ~interfaceを利用するすべての`~event$も同様にすることが推挙される。
◎
Throughout the web platform the error, abort, timeout and load event types have their bubbles and cancelable attributes initialized to false, so it is suggested that for consistency all events using the ProgressEvent interface do the same.
</p>

		</section>
		<section id="security-considerations">

<h3 title="Security Considerations">6.3. 保安~上の考慮点</h3>

<p>
非同一生成元~要請に対しては、例えば 
Fetch 標準にて定義される`CORS ~protocol$
などの，ある種の~opt-inが、 `ProgressEvent$I ~interfaceを利用する`~event$が`配送-$される前に利用される必要がある。
さもなければ、通常は得られる筈の無い情報（例えば~sizeなど）まで，見えてしまうことになるので。
`Fetch$r
◎
For cross-origin requests some kind of opt-in, e.g. the CORS protocol defined in the Fetch Standard, has to be used before events using the ProgressEvent interface are dispatched as information (e.g. size) would be revealed that cannot be obtained otherwise. [FETCH]
</p>

		</section>
		<section id="example">

<h3 title="Example">6.4. 用例</h3>

<div class="example">

<p>
次の例では、 `XMLHttpRequest$I に，前~節にて定義された概念が組み合わされ、`~fetching$の過程の表示に HTML `progress$e 要素が利用される。
◎
In this example XMLHttpRequest, combined with concepts defined in the sections before, and the HTML progress element are used together to display the process of fetching a resource.
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;title&gt;Waiting for Magical Unicorns&lt;/title&gt;
&lt;progress id=p&gt;&lt;/progress&gt;
&lt;script&gt;
  var %progressBar = document.getElementById("p"),
      %client = new XMLHttpRequest()
  %client.open("GET", "magical-unicorns")
  %client.onprogress = function(%pe) {
    if(%pe.lengthComputable) {
      %progressBar.max = %pe.total
      %progressBar.value = %pe.loaded
    }
  }
  %client.onloadend = function(%pe) {
    %progressBar.value = %pe.loaded
  }
  %client.send()
&lt;/script&gt;
</pre>

<p>
もちろん，~~完全に機能する~codeは、より精巧かつ，~network~errorや末端利用者からの終了-要請など，より多くの局面に対応するものになるだろうが。
◎
Fully working code would of course be more elaborate and deal with more scenarios, such as network errors or the end user terminating the request.
</p></div>



		</section>
	</section>

</main></div><!-- MAIN0/MAIN -->


<hr />

	<section id="references">

<h2>参照文献</h2>

<dl>
	<dt>[COOKIES]</dt>
	<dd><cite><a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a></cite>, Adam Barth. IETF.</dd>

	<dt>[DOM]</dt>
	<dd><cite><a href="https://dom.spec.whatwg.org/">DOM</a></cite>,
Anne van Kesteren, Aryeh Gregor and Ms2ger. WHATWG.</dd>

	<dt>[DOMPS]</dt>
	<dd><cite><a href="https://dvcs.w3.org/hg/innerhtml/raw-file/tip/index.html">DOM Parsing and Serialization</a></cite>,
Travis Leithead. W3C.</dd>

	<dt>[ECMASCRIPT]</dt>
	<dd><cite><a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript Language Specification</a></cite>. ECMA.</dd>

	<dt>[ENCODING]</dt>
	<dd><cite><a href="https://encoding.spec.whatwg.org/">Encoding</a></cite>,
Anne van Kesteren. WHATWG.</dd>

	<dt>[FETCH]</dt>
	<dd><cite><a href="https://fetch.spec.whatwg.org/">Fetch</a></cite>, Anne van Kesteren. WHATWG.</dd>

	<dt>[FILEAPI]</dt>
	<dd><cite><a href="https://w3c.github.io/FileAPI/">File API</a></cite>,
Arun Ranganathan and Jonas Sicking. W3C.</dd>

	<dt>[HTML]</dt>
	<dd><cite><a href="https://html.spec.whatwg.org/multipage/">HTML</a></cite>,
Ian Hickson. WHATWG.</dd>

	<dt>[HTTP]</dt>
	<dd><cite><a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a></cite>, Roy Fielding and Julian Reschke. IETF.</dd>

	<dd><cite><a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a></cite>, Roy Fielding and Julian Reschke. IETF.</dd>

	<dd><cite><a href="https://tools.ietf.org/html/rfc7232">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a></cite>, Roy Fielding and Julian Reschke. IETF.</dd>

	<dd><cite><a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a></cite>, Roy Fielding and Julian Reschke. IETF.</dd>

	<dd><cite><a href="https://tools.ietf.org/html/rfc7235">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a></cite>, Roy Fielding and Julian Reschke. IETF.</dd>

	<dt>[RFC2119]</dt>
	<dd><cite><a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
Scott Bradner. IETF.</dd>

	<dt>[URL]</dt>
	<dd><cite><a href="https://url.spec.whatwg.org/">URL</a></cite>,
Anne van Kesteren. WHATWG.</dd>

	<dt>[WEBIDL]</dt>
	<dd><cite><a href="https://heycam.github.io/webidl/">Web IDL</a></cite>,
Cameron McCormack. W3C.</dd>

	<dt>[XML]</dt>
	<dd><cite><a href="https://www.w3.org/TR/xml/">Extensible Markup Language</a></cite>,
Tim Bray, Jean Paoli, C. M. Sperberg-McQueen et al.. W3C.</dd>

	<dt>[XMLNS]</dt>
	<dd><cite><a href="https://www.w3.org/TR/xml-names/">Namespaces in XML</a></cite>,
Tim Bray, Dave Hollander, Andrew Layman et al.. W3C.</dd>

</dl>

	</section>
	<section id="acknowledgments">

<h2>謝辞</h2>

<p>
次の方々に感謝する：
</p>

<p>
Thanks to

Addison Phillips,
Adrian Bateman,
Ahmed Kamel,
Alan Thomas,
Alex Hopmann,
Alex Vincent,
Alexey Proskuryakov,
Andrea Marchesini,
Asbjørn Ulsberg,
Boris Zbarsky,
Björn Höhrmann,
Caitlin Potter,
Cameron McCormack,
Chris Marrin,
Christophe Jolif,
Charles McCathieNevile,
Dan Winship,
David Andersson,
David Flanagan,
David Håsäther,
David Levin,
Dean Jackson,
Denis Sureau,
Domenic Denicola,
Dominik Röttsches,
Doug Schepers,
Douglas Livingstone,
Elliott Sprehn,
Elliotte Harold,
Eric Lawrence,
Eric Uhrhane,
Erik Arvidsson,
Erik Dahlström,
Feras Moussa,
Geoffrey Sneddon,
Gideon Cohn,
Glenn Adams,
Gorm Haug Eriksen,
Håkon Wium Lie,
Hallvord R. M. Steen,
Henri Sivonen,
Hiroshige Hayashizaki,
Huub Schaeks,
Ian Davis,
Ian Hickson,
Ivan Herman,
Jake Archibald,
Jared Jacobs,
Jarred Nicholls,
Jeff Walden,
Jens Lindström,
Jim Deegan,
Jim Ley,
Joe Farro,
Jonas Sicking,
Julian Reschke,
송정기 (Jungkee Song),
呂康豪 (Kang-Hao Lu),
Karl Dubost,
Keith Yeung,
Lachlan Hunt,
Maciej Stachowiak,
Magnus Kristiansen,
Manish Goregaokar,
Marc Hadley,
Marcos Caceres,
Mark Baker,
Mark Birbeck,
Mark Nottingham,
Mark S. Miller,
Martin Hassman,
Mohamed Zergaoui,
Ms2ger,
Odin Hørthe Omdal,
Olli Pettay,
Pawel Glowacki,
Peter Michaux,
Philip Jägenstedt,
Philip Taylor,
Robin Berjon,
Rune <span title="Fabulous">F.</span> Halvorsen,
Ruud Steltenpool,
Sergiu Dumitriu,
Shivakumar Jagalur Matt,
Sigbjørn Finne,
Simon Pieters,
Stewart Brodie,
Sunava Dutta,
Takeshi Kurosawa,
Takeshi Yoshino,
Thomas Roessler,
Tom Magliery,
Travis Leithead,
Yehuda Katz,
Youenn Fablet, and
Zhenbin Xu

for their contributions to this standard.
</p>

<p>
Windows Internet Explorer にて初めて実装し、 <code >XMLHttpRequest</code> インタフェースを最初に広めた Microsoft の開発者たちに特別な謝意を。
<span lang="en">
Special thanks to the Microsoft employees who first implemented the XMLHttpRequest interface, which was first widely deployed by the Windows Internet Explorer browser.
</span></p>

<p>
HTML Standard （ Web Applications 1.0 ）にて、この仕様の初期バージョンを草案化された Ian Hickson 氏に特別な謝意を。
<a href="refsHTML">[HTML]</a>
<span lang="en">
Special thanks to Ian Hickson for drafting an initial version of this specification in
the HTML Standard (then Web Applications 1.0). [HTML]
</span></p>

<p>
<a href="https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/svgudom.html">SVG Micro DOM</a>
の一部として、元々の <code >ProgressEvent</code> クラスの草案を作成した W3C SVG WG に特別な謝意を。
<span lang="en">
Special thanks to the W3C SVG WG for drafting the original ProgressEvent class as part of the SVG Micro DOM.
</span></p>

	</section>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>

<p>
Per <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>, to
the extent possible under law, the editor has waived all copyright and related or
neighboring rights to this work.
</p>


</body>
