<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Conditional Rules Module Level 3 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
var source_data;

COMMON_DATA.page_state_key = '___CSS';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://drafts.csswg.org/css-conditional-3/',
		spec_status: 'ED',
		main: 'MAIN',
		fill_text_link: '#_versions > dd, #references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};


	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked 160112 spec

	return options;
}

function expand(mapping1){
	var link_map = this.link_map;
	var class_map = {
		p: 'property', // prop
		at: 'at-rule',
		css: 'css',
//		pe: 'pseudo',
		e: 'element',
		a: 'attr',
		v: 'value',
		t: 'type',
		E: 'error',
		P: 'production',
	};
	var tag_map = {
		p: 'code',
		t: 'var',
		P: 'code',
		css: 'code',
		pe: 'code',
		e: 'code',
		a: 'code',
		at: 'code',
		v: 'code',
		I: 'code',
		E: 'code',
		m: 'code',
		c: 'code',
		V: 'var',
	}

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/◎[^`<◎]*|【.*?】|%\w+|`(.*?)([$@^])(\w*)/g,
			create_html
		),
		mapping1
	);


	function create_html(match, key, indicator, klass){
if(!indicator) {
	switch(match.charAt(0)){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '◎':
	default:
	}
	return '<span lang="en">' + match.slice(1) + '</span>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'ps': 
	text = ':' + key;
	break;
case 'at': 
	text = '@' + key;
	break;
case 't': // typedef
	text = '&lt;' + key + '&gt;';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
}


if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
</script>

<!--%links -->
<script type="text/plain" id="_link_map">

I.CSSGroupingRule:#cssgroupingrule
I.CSSConditionRule:#cssconditionrule
I.CSSMediaRule:#cssmediarule
I.CSSSupportsRule:#csssupportsrule
I.CSS:~CSSOM#css
I.CSSRuleList:~CSSOM#cssrulelist
I.MediaList:~CSSOM#medialist

m.SUPPORTS_RULE:#dom-cssrule-supports_rule
m.cssRules:#dom-cssgroupingrule-cssrules
m.insertRule:#dom-cssgroupingrule-insertrule
m.deleteRule:#dom-cssgroupingrule-deleterule
m.conditionText:#dom-cssconditionrule-conditiontext
m.media:#dom-cssmediarule-media
m.supports:#dom-css-supports
m.~supports0:#dom-css-supports-conditiontext


P.nested_statement:#nested_statement
P.group_rule_body:#group_rule_body
P.media:#media
P.SUPPORTS_SYM:#supports_sym
P.OR:#or
P.supports_rule:#supports_rule
P.supports_condition:#supports_condition
P.supports_condition_in_parens:#supports_condition_in_parens
P.supports_negation:#supports_negation
P.supports_conjunction:#supports_conjunction
P.supports_disjunction:#supports_disjunction
P.supports_declaration_condition:#supports_declaration_condition
P.general_enclosed:#general_enclosed
P.AND:~TR/css3-mediaqueries/#syntax
P.NOT:~TR/css3-mediaqueries/#syntax
P.media_query_list:https://www.w3.org/TR/css3-mediaqueries/#syntax

P.any:~CSS21/syndata.html#tokenization
P.declaration:~CSS21/syndata.html#tokenization
P.FUNCTION:~CSS21/syndata.html#tokenization
P.unused:~CSS21/syndata.html#tokenization
P.MEDIA_SYM:~CSS21/grammar.html#grammar
P.S:~CSS21/grammar.html#scanner

t.supports-condition:#typedef-supports-condition

p.display:~CSSDISP#propdef-display
p.width:~CSS2VISUDET#propdef-width

at.media:#at-ruledef-media
at.supports:#at-ruledef-supports
at.import:~CASCADE#at-ruledef-import

css.or:#or
css.not:~MQ4#valdef-media-not

CSS 2.1 の文法:~CSS21/grammar.html
媒体~query:~MQ4#media-query
媒体~query~list:~MQ4#media-query-list
条件付き~group規則:#conditional-group-rule
~group規則の本体:#group-rule-body
~support:#dfn-support


	~MQ4#typedef-media-query-list



</script>
<!-- 
CSS2CONFORM:css-common-ja.html


	CSS:#CSS-interface
	4.1.1 節 （トークン化）:https://www.w3.org/TR/CSS21/syndata.html#tokenization
	4.1.5 節:https://www.w3.org/TR/CSS21/syndata.html#at-rules
	4.1.7 節:https://www.w3.org/TR/CSS21/syndata.html#rule-sets
	4.1.8 節:https://www.w3.org/TR/CSS21/syndata.html#declaration
	4.2 節:https://www.w3.org/TR/CSS21/syndata.html#parsing-errors
	付録 G:https://www.w3.org/TR/CSS21/grammar.html
	UA:css-common-ja.html#user-agent
	サポート:#support-definition
	条件付きグループ規則の処理:#processing
	接頭辞構文:https://www.w3.org/TR/CSS2/syndata.html#vendor-keywords
	CSS スタイルシート:css-common-ja.html
	https://www.w3.org/TR/CSS21/conform.html#style-sheet

type="text/plain" id="_class_map">
or:css
AND:production
NOT:production
any:production
media_query_list:production
declaration:production
FUNCTION:production
unused:production
S:production
MEDIA_SYM:production


 -->


<!--%置換語 -->
<script type="text/plain" id="words_table1">
supports0:supports
</script>

<script type="text/plain" id="words_table">

	●CSS
CSS:
stylesheet:style sheet::スタイルシート
処理器:processor::~:プロセッサ
screen:::スクリーン
発話:speech::~:スピーチ
紙:paper:~
page:::ページ
style:::スタイル
prop:property::プロパティ
layout:::レイアウト
model:::モデル
flow:::フロー
font:::フォント
size:::サイズ
box:::ボックス
選択子:selector:~::セレクタ
flex:
媒体:media::~:メディア
宣言:declaration:~
内容:content:~
印刷:print:~
文書:document:~
呈示-:present:~
規則:rule:~
要素:element:~
算出値:computed value:~
表示域:viewport:~
横幅:width:~
具現化法:rendering:~
区画:area:~
表示:display:~


	●構文
block:::ブロック
comma:::カンマ
space:::スペース
top-level:::トップレベル
scanner:::スキャナ
literal:::リテラル
escape:::エスケープ
keyword:::キーワード
token:::トークン
minimizer:
	~token化:tokenization
comment:::コメント

文法:grammar:~
文法記号:terms:~
中核:core:~
簡約:simplification:~
検査:check:~
検証器:validator:~
構文:syntax:~
構文解析:parse:~::パース
	構文解析エラー:parse error:~
	構文解析できない:unparseable:~
実用:usable:~
直列化-:serialize:~::シリアライズ

生成規則:production:~
接頭辞:prefix:~
	接頭辞付き:prefixed:~
字句:lexical:~
式:expression:~
空白:whitespace:~
丸括弧:parenthesis:~
名前:name:~
名:name:~
値:value:~
文字列:string:~
関数:function:~
関数式:function:~
括弧:parentheses:~
構成子:constructs:~
空:empty:~
処理:processing:~
処理-:process:~
分離-:separate:~
妥当:valid:~
	妥当でない:invalid:~
妥当性:validity:~
無視:ignore:~
集合:set:~
禁止-:forbid:~
緩い:loose な:~
緩く:loose に:~
本体:body:~
優先順位:precedence:~
	開き:opening


	●条件
group:::グループ
	~group化:grouping
support:::サポート
	unsupported
query:::クエリ
fallback:::フォールバック
上品:graceful:~
退行-:degrade:~
	degradation
破棄:discard:~
	グループ規則:group rule
条件:condition::~
条件付き:conditional::~
条件付けら:condition さ::~
真偽値:boolean::~
真:true::~
偽:false::~
真偽:true/false::~

論理積:conjunction::~
論理和:disjunction::~
否定:negation::~
複合的:compound:~
評価-:evaluate:~
評価結果:evaluating 結果
論理的な:logical:~

	●仕様（動詞
選好:preference:~
適合:conforming:~
適合-:conform:~
	conformant:~
適合性:conformance:~
実装:implementation:~
実装-:implement:~
受理-:accept:~
適用-:apply:~
	適用し得る:applicable:~
許容-:allow:~
	許容される場所:placement:~
依存:depend:~
依存関係:dependency:~
解釈-:interpret:~
定義:definition:~
定義-:define:~
提供-:provide:~
制約:restriction:~
順守:obey:~
挙動:behavior:ふるまい
取扱い:handling:取り扱い
取扱われ:handle され:取り扱われ
取扱う:handle する:取り扱う
改変-:modify:~
改変:modifications:~
統合-:incorporate:~
指定-:specify:~
関係-:relate:~
取組む:address する:取り組む
要求-:require:~
影響-:affect:~
働く:work する:~
遂行-:perform:~
記述:description:~
記述-:describe:~
見なさ:consider さ:~
	見なす:consider:~
結付けら:associate さ:結び付けら
結付ける:associate する:結び付けた
導入-:introduce:~
主張-:claim:~
築かれ:build され:~
避ける:avoid する:~
拡張:extension:~
拡張-:extend:~
拡張性:extensibility:~
孕む:involve する:~
強いら:force さ:~
意味-:mean:~
	扱-:treat:~
	束ねる:tied:~
	述べた:describe した:~
	進行-:advance:~

	●仕様
UA:user agent:UA
module:::モジュール
level:::レベル
risk:::リスク
test:::テスト
system:::システム
vendor:::ベンダ
tool:::ツール
version:::バージョン
意味論:semantics:~
相互運用可能:interoperable:~
相互運用性:interoperability:~
存続期間:lifetime:~
試験的:experimental:~
付録:Appendix:~
作者:author:~
著作:authoring:~
編集者草案:Editor’s Draft:~
勧告:Recommendation:~
勧告候補:Candidate Recommendation:~
勧告案:Proposed Recommendation:~
相互作用:interactions:~
要件:requirements:~
特色機能:feature:~
演算子:operator:~
互換性:compatibility:~
前方互換性:forwards-compatibility:~
前方互換:forward-compatible:~
仕様:spec:~
	specification:~

変更点:changes:~
適切:appropriate:~
融通性:flexibility:~
能力:capabilities:~
将来:future:~
明示的:explicit:~
効果:effect:~
有用:useful:~
利用者:user:~
規範的:normative:~
能:ability:機能
混同:confusion:~
開発者:developer:~
	developer-facing
一般:general:~

機能性:functionality:~
仕組み:mechanism:~
重要:important:~
考慮点:considerations:~
正しく:correct に:~
可用:available:~
理由:reason:~

類似性:similarities:~
既存の:existing:~
特定0の:particular:ある特定の
特有の:-specific な:~

側面:aspects:~
	一貫させ:consistency:~
拘束-:constrain:~
依拠-:rely:~
各種用語:terminology
	謎めいた:arcane
暗黙の:implied:~
	-:purpose
	~~意味:sense
	〜に則って:according:~
	したがって，:therefore:~
	ときどき:sometimes:~
	とりわけ:especially:~
	他に:elsewhere:~
	任意に:arbitrary:~
	例:example:~
	共通する:share common
	前提に:assumption:~
	利用:use:~
	加えて:additionally:~
	同様に:Likewise:~
	基づいて:based
	害を及ぼし:harmful:~
	少しばかり:slightly:~
	~~意図的に:purposely
	格段に〜し易く:much easier:~
	次の:the following:~
	特に:particularly:~
	相応のもの:substantial:~
	節:section:~
	複雑に:complicated:~
	言い換えれば:In other word:~
	足る〜でない:not sufficient:~
	advancement


	●未分類
code:::コード
link:::リンク
navi-control:navigation control::ナビ コントロール
error:::エラー
list:::リスト

contrast:::コントラスト
mode:::モード
interface:::インタフェース
obj:object::オブジェクト
parameter:::パラメタ
stream:::ストリーム
method:::メソッド
privacy:::プライバシー
保安:security::~:セキュリティ
window:::ウィンドウ
click:::クリック

派生:derived:~
例外:exception:~
構造:structure:~
	high-contrast mode
演算:operation:~
状態:state:~
基底:base:~
投出:throw:~
属性:attribute:~

代替:alternative:~
部分的:partial:~
合致:match:~
内側:inside:~
挿入-:insert:~

不能化-:disable:~
可能化-:enable:~

初期:initial:~
保持-:hold:~
削られ:strip され:~
	等価:equivalent:~
等価性:equivalence:~
成功裡:successful:~

反映-:reflect:~
表現-:represent:~
変更-:change:~
置換-:replace:~
除去-:remove:~
除去:removal:~
設定-:set:~
被取得時:被 get 時:~
被設定時:被 set 時:~
被呼出時:被 invoke 時:~
上書き:override:~

入子の:nested:~
入子に:nest:~

縮約:reduce:~
子:child:~

現在の:current:~
色:color:~
新たな:new:~
組合わす:combine する:組み合わす
走らせ:run し:~
省略-:omit:~
先頭:leading:~
末尾:trailing:~

言語:language:~
包含-:contain:~
単独の:single:~
持続-:persist:~
正確a:accurate:正確
混在-:mix:~
追加-:add:~
追加:addition:~
追加の:additional:~
実質的に:effectively:~


	semicolon:::セミコロン
	出力:output
	semicolon:::セミコロン
	単純
	一部分:parts of
	不要な:unneeded:~
	必要になる:needed:~
	余分な:extra 〜 not needed
	並び:sequence:~
	前の／以前に:previously:~
	取り除く:Trim:~
	同じ:same:~
	含-:include:~
	在る:present:~
	型:type:~
	所:location:~
	残り続ける:remain:~
	生じる:occur:~
	異なる:different:~
	種:type:~
	等しい:equal:~
	結果:result:~
	置かれ:place され:~
	複数の:multiple:~
	返-:return:~
	逆になる:reversed
	過ぎて:past して:~
	開始部分:beginning:~
	除-:except:~
	随時:at any time:~
	不在:absence:~
	部分:part:~
	与えられた:given:~
	要する:require する:~
		従って:as follows
	より速い:faster:~
	より大きい:greater:~
	-:invisible:~
	apart: 2
	consists
	contrast
	followed by
	見当たら:found
	高:high-
	-:inclusion
	index
	instead
	倍:times
	以上:at least

</script>


<!--% style-->

<style>

dl.idl > dt {
	font-family: monospace0, monospace;
}

.error {
	color: green;
}

</style>




</head>

<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>


<aside class="trans-meta">
<h1>CSS Conditional Rules Module Level 3 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">CSS Conditional Rules Module Level 3</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2016-07-21</time>
（公開：<time>2012-07-09</time> ）
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>

<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1>CSS 条件付き規則 — CSS Conditional Rules Module Level 3</h1>
<h2>2016 年 10 月 13 日付 編集者草案</h2>
	</hgroup>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dt title="Editor’s Draft:">編集者草案</dt>
	<dd>https://drafts.csswg.org/css3-conditional/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>https://www.w3.org/TR/css3-conditional/</dd>

	<dt title="Previous Versions:">以前のバージョン</dt>
	<dd>https://www.w3.org/TR/2013/CR-css3-conditional-20130404/</dd>

	<dt title="Test Suite:">テスト一式</dt>
	<dd>http://test.csswg.org/suites/css3-conditional/nightly-unstable/</dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="https://dbaron.org/">L. David Baron</a> (Mozilla)</dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="https://github.com/w3c/csswg-drafts/labels/css3-conditional-3">GitHub Issues</a></dd>

</dl>

<small class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright" rel="license">Copyright</a> © 2016 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
<a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</small>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この~moduleには、~stylesheetの一部分を，処理器の能力や~stylesheetが適用される文書など, 一定の条件に基づいて処理するための~CSS特色機能が含まれている。
これは、~CSS~level 1 `CSS1$r の上に築かれた ~CSS~level 2 `CSS21$r の機能性を包含し，それを拡張する。
~level 2 に対する主な拡張には、
`media$at の内側に 一定の at-規則を入子にできるようにすること，および
条件付き処理のための `supports$at 規則の追加がある。
◎
This module contains the features of CSS for conditional processing of parts of style sheets, conditioned on capabilities of the processor or the document the style sheet is being applied to. It includes and extends the functionality of CSS level 2 [CSS21], which builds on CSS level 1 [CSS1]. The main extensions compared to level 2 are allowing nesting of certain at-rules inside '@media', and the addition of the '@supports' rule for conditional processing.
</p>

<p>
~CSSは、（ HTML や XML などの）構造を備える文書から，
~screen, 紙, 発話, 等々
の媒体への具現化法を記述するための言語である。
◎
CSS is a language for describing the rendering of structured documents (such as HTML and XML) on screen, on paper, in speech, etc.
</p>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<span class="trans-note">【
以下，この節の他の内容は
<a href="css-common-ja.html#status" >CSS 日本語訳 共通~page</a>
に委譲
】</span></p>

<!--end-status-->

<p>
次の特色機能は
<a href="css-common-ja.html#at-risk">~risk下</a>
にあり，勧告候補の期間中に取り下げられるかもしれません：
◎
The following features are at-risk, and may be dropped during the CR period:
</p>

<ul>
	<li>
単に仕様~策定の進捗状況に相対的な理由によるものですが、この仕様が与える すべての at-規則の中で許容される［
`font-face^at ／ `keyframes^at
］規則の包含は~risk下にあります。
この仕様の策定が、これらの規則を定義する仕様より速やかに進行したならば、これらの規則の包含は、この仕様から これらの規則を定義する仕様に移動されることになります。
◎
The inclusion of @font-face rules and @keyframes rules as allowed within all of the @-rules in this specification is at risk, though only because of the relative rates of advancement of specifications. If this specification is able to advance faster than one or both of the specifications defining those rules, then the inclusion of those rules will move from this specification to the specification defining those rules.
</li>

	<li>
［
条件付き~group化~規則の内側の at-規則
］の~supportは、~risk下にあります。
相互運用可能な実装が見当たらなければ、この仕様の中の他の特色機能を勧告案の段階に進めるため，除去される可能性があります。
◎
The addition of support for @-rules inside of conditional grouping rules is at risk; if interoperable implementations are not found, it may be removed to advance the other features in this specification to Proposed Recommendation.
</li>

	<li>
`supports$at 規則は
~risk下にあります。
相互運用可能な実装が見当たらなければ、この仕様の中の他の特色機能を勧告案の段階に進めるため，除去される可能性があります。
◎
The @supports rule is at risk; if interoperable implementations are not found, it may be removed to advance the other features in this specification to Proposed Recommendation.
</li>

</ul>
	</section>
  <!--

  Things to go in level 4:

  * Create some way to put these new conditional things on an @import.
  * The @document rule (commented out, down below).

-->


<main id="MAIN0">
	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

		<section id="context">
<h3 title="Background">1.1. 背景</h3>

~INFORMATIVE

<p>
`CSS21$r では、`条件付き~group規則$の一種として
`media$at 規則が定義されており，その内側には（他の at-規則でない）~style規則のみが許容されている。
`media$at 規則は、媒体~特有の~stylesheetを持つ能を提供する。
それは、
`import^at や
<code class="html">&lt;link&gt;</code>
などの，~stylesheetへ~linkする特色機能でも提供されている。
しかしながら， `media$at 規則の内容に課せられている制約のため、媒体~特有の~stylesheetの中で at-規則を孕む~CSS特色機能の利用が望まれる場合、各~媒体ごとに別々の~stylesheetを利用することを強いられる。
◎
[CSS21] defines one type of conditional group rule, the '@media' rule, and allows only style rules (not other @-rules) inside of it. The '@media' rule provides the ability to have media-specific style sheets, which is also provided by style sheet linking features such as '@import' and &lt;link&gt;. The restrictions on the contents of '@media' rules made them less useful; they have forced authors using CSS features involving @-rules in media-specific style sheets to use separate style sheets for each medium.
</p>

<p>
この仕様は、`条件付き~group規則$を，その内容として 他の at-規則も許容するように拡張する。
これにより，作者は、単独の~stylesheetの中で， at-規則を孕む~CSS特色機能と, 媒体~特有の~stylesheetとを組合わすことが可能になる。
◎
This specification extends the rules for the contents of conditional group rules to allow other @-rules, which enables authors to combine CSS features involving @-rules with media specific style sheets within a single style sheet.
</p>

<p>
この仕様は、作者と利用者からの要件に取組むための，別種の`条件付き~group規則$
— `supports$at —
も定義する。
◎
This specification also defines an additional type of conditional group rule, '@supports', to address author and user requirements.
</p>

<p>
`supports$at
規則により，
~CSS~propとその値に対する実装~supportの有無についての条件が加味された~CSSが可能になる。
この規則は、新たな~CSS特色機能を 作者にとり格段に利用し易くし，それらの特色機能を~supportしない実装のための良好な~fallbackを提供する。
これは特に、新たな~layoutの仕組みを提供する~CSS特色機能，あるいは
関係する~styleの集合が~propの~supportの有無に基づいて条件付けられる必要があるような状況において、重要になる。
◎
The '@supports' rule allows CSS to be conditioned on implementation support for CSS properties and values. This rule makes it much easier for authors to use new CSS features and provide good fallback for implementations that do not support those features. This is particularly important for CSS features that provide new layout mechanisms, and for other cases where a set of related styles needs to be conditioned on property support.
</p>
		</section>
		<section id="placement">
<h3 title="Module Interactions">1.2. ~module間の相互作用</h3>

<p>
この~moduleは、
`CSS21$r 7.2.1 節
にて定義される `media$at 規則の特色機能を置換し，それを拡張する。
また、以前に `MEDIAQ$r 1 節による非~規範的な改変を統合する。
◎
This module replaces and extends the '@media' rule feature defined in [CSS21] section 7.2.1 and incorporates the modifications previously made non-normatively by [MEDIAQ] section 1.
</p>

<p>
現在の定義は，
`CSS3-FONTS$r および `CSS3-ANIMATIONS$r
にて定義されている at-規則に依存しているが、この依存関係は，これらの~moduleの策定がこの仕様よりも速やかに進行することが前提にある。
この~moduleの策定がより速やかに進行した場合、この依存関係は逆になる。
◎
Its current definition depends on @-rules defined in [CSS3-FONTS] and [CSS3-ANIMATIONS], but that dependency is only on the assumption that those modules will advance ahead of this one. If this module advances faster, then the dependency will be reversed.
</p>

<p>
~CSS~stylesheetの中で これらの新たな at-規則が許容されるようにするため、この仕様は，
`CSS21$r の <a href="~CSS21/grammar.html">付録 G</a>
による `stylesheet^P 生成規則を改変する。
`CSS21$r にて定義される `media^P 生成規則をこの仕様に定義される
`media$P 生成規則に置換した上で，
"`ruleset | media | page^c"
の後に
"` | supports_rule^c"
を付加する。
◎
In order to allow these new @-rules in CSS style sheets, this specification modifies the stylesheet production in the Appendix G grammar of [CSS21] by replacing the media production defined in [CSS21] with the media production defined in this one, and additionally inserting | supports_rule alongside ruleset | media | page.
</p>

		</section>
	</section>
	<section id="processing">
<h2 title="Processing of conditional group rules">2. 条件付き~group規則の処理</h2>

<p>
この仕様は、
`条件付き~group規則@
と呼ばれる~CSS at-規則を定義する。
それは、いくつかの~CSS規則からなる~groupとしての規則に，ある条件を結付ける。
~testする条件には種々のものが許容されるが、条件の真偽に基づいて 内容をどう利用するかについての挙動は，共通する。
◎
This specification defines some CSS @-rules, called conditional group rules, that associate a condition with a group of other CSS rules. These different rules allow testing different types of conditions, but share common behavior for how their contents are used when the condition is true and when the condition is false.
</p>

<div class="example">
<p>
例えば次の規則：
◎
For example, this rule:
</p>

<pre>
@media print {
  /* <span class="comment">
印刷~時には~navi-controlを隠す
◎
hide navigation controls when printing
</span> */
  #navigation { display: none }
}</pre>

<p>
では、特定0の~CSS規則が，~stylesheetが印刷~媒体に利用されるときにのみ，適用されるようにする（ここでは ID "<samp>navigation</samp>" の要素を
<code class="css">`display$p: `none^v</code>
にする）。
◎
causes a particular CSS rule (making elements with ID “navigation” be display:none) apply only when the style sheet is used for a print medium.
</p></div>

<p>
それぞれの`条件付き~group規則$は、随時, 真または偽に評価される条件を持つ。
条件が真のとき、~CSS処理器は，~group規則の内側の規則を それらが~group規則の所に在ったかのように 適用し~MUST。
条件が偽のとき、~CSS処理器は，~group規則の内側のどの規則も 適用しては~MUST_NOT。
条件の現在の状態が ~CSS~obj~modelに影響することはない — ~group規則の内容は常に~group規則の中に残り続ける。
◎
Each conditional group rule has a condition, which at any time evaluates to true or false. When the condition is true, CSS processors must apply the rules inside the group rule as though they were at the group rule’s location; when the condition is false, CSS processors must not apply any of rules inside the group rule. The current state of the condition does not affect the CSS object model, in which the contents of the group rule always remain within the group rule.
</p>

<p>
これは，`条件付き~group規則$が複数段にわたって入子にされているときは、その末端の内側の規則が，それらの~group規則の条件すべてが真であるときにのみ 適用されることを意味する。
◎
This means that when multiple conditional group rules are nested, a rule inside of both of them applies only when all of the rules' conditions are true.
</p>

<div class="example"><p>
例えば，規則の集合が 次の様に入子にされている場合：
◎
For example, with this set of nested rules:
</p>

<pre>
@media print { // 規則 (1)
  /* <span class="comment">
印刷~時には~navi-controlを隠す
◎
hide navigation controls when printing
</span> */
  #navigation { display: none }
  @media (max-width: 12cm) { // 規則 (2)
    /* <span class="comment">
狭い~pageに印刷するときの note は，通常の~flow
◎
keep notes in flow when printing to narrow pages
</span> */
    .note { float: none }
  }
}</pre>

<p>
規則 (1) の条件は印刷~媒体に対しては真であり，
規則 (2) の条件は表示~区画（印刷~媒体の場合は~page~box）の横幅が 12 cm 以下のときに真になる。
したがって、規則
<samp class="css">#navigation { `display$p: `none^v }</samp>
は，この~stylesheetが印刷~媒体に適用されているときに適用され、規則
<samp class="css">.note { `float^p: `none^v }</samp>
は，~stylesheetが印刷~媒体に適用されていて, <em>かつ</em> ~page~boxの横幅が 12 cm 以下のときにのみ適用される。
◎
the condition of the rule marked (1) is true for print media, and the condition of the rule marked (2) is true when the width of the display area (which for print media is the page box) is less than or equal to 12cm. Thus the rule #navigation { display: none } applies whenever this style sheet is applied to print media, and the rule .note { float: none } is applied only when the style sheet is applied to print media and the width of the page box is less than or equal to 12 centimeters.
</p>
</div>

<p>
`条件付き~group規則$の条件が変更されたときは、~CSS処理器は、その真偽に応じて，その規則の適用-の可否を反映し~MUST。
ただし、その~propが，その算出値の効果がその値の存続期間を過ぎても持続するものと定義されている場合は除く（例えば
`CSS3-TRANSITIONS$r や `CSS3-ANIMATIONS$r
の一部の~prop）。
◎
When the condition for a conditional group rule changes, CSS processors must reflect that the rules now apply or no longer apply, except for properties whose definitions define effects of computed values that persist past the lifetime of that value (such as for some properties in [CSS3-TRANSITIONS] and [CSS3-ANIMATIONS]).
</p>
	</section>
	<section id="contents-of">
<h2 title="Contents of conditional group rules">3. 条件付き~group規則の内容</h2>

<div class="p">
<p>
それぞれの`条件付き~group規則$の構文は、次の並びからなる：
</p>

<ol>
	<li>
その種別の規則~特有の，何らかの構文, および
</li>
	<li>
規則の並びを包含している~block（括弧に括られた部分）を成す，
`~group規則の本体@
</li>
</ol>

◎
The syntax of each conditional group rule consists of some syntax specific to the type of rule followed by a group rule body, which is a block (pair of braces) containing a sequence of rules.
</div>


<p>
`~group規則の本体$には、任意の~style規則, および［
~stylesheetの~top-levelにて~style規則の前後いずれの側にも許容されるような，任意の at-規則
］を包含させれる。
すなわち，~stylesheetの開始部分に存在し~MUST at-規則（
`charset^at, `import^at, `namespace^at
規則など）は、`条件付き~group規則$の内側には許容されない。
`条件付き~group規則$は、入子にもできる。
◎
A group rule body is allowed to contain style rules and any @-rules that are allowed at the top level of a style sheet before and after a style rule. This means that @-rules that must occur at the beginning of the style sheet (such as '@charset', '@import', and '@namespace' rules) are not allowed inside of conditional group rules. Conditional group rules can be nested.
</p>

<p>
文法においては、`条件付き~group規則$の文法に利用するための，次の生成規則が定義される。
◎
In terms of the grammar, this specification defines the following productions for use in the grammar of conditional group rules:
</p>

<p class="note">
注記：
~style規則は `ruleset^P 生成規則の文法の中で定義される。
◎
Note: Style rules are defined in grammars by the ruleset production.
</p>

<pre class="proddef">
`nested_statement@P
  : `ruleset^P | `media$P | `page^P | `font_face_rule^P | `keyframes_rule^P |
    `supports_rule$P
  ;

`group_rule_body@P
  : '{' S* `nested_statement$P* '}' S*
  ;</pre>

<p>
`font_face_rule^P は `CSS3-FONTS$r にて定義される。
`keyframes_rule^P は `CSS3-ANIMATIONS$r にて定義される。
`media$P と
`supports_rule$P
はこの仕様にて定義される。
他の生成規則は CSS21 の文法の中で定義される。
◎
in which all the productions are defined in that grammar with the exception of font_face_rule defined in [CSS3-FONTS], keyframes_rule defined in [CSS3-ANIMATIONS], and media and supports_rule defined in this specification.
</p>

<p>
一般に、将来の~CSS仕様が，［
何らかの他~種の規則の後に生じることが禁止されないような，新たな at-規則
］を追加するために，この `nested_statement$P 生成規則を改変するときは、この文法が正確aであり続けられるようにするべきである。
◎
In general, future CSS specifications that add new @-rules that are not forbidden to occur after some other types of rules should modify this nested_statement production to keep the grammar accurate.
</p>

<p>
~stylesheetは、`条件付き~group規則$の内側にて，許容されるもの以外の規則を利用しては~MUST_NOT。
◎
Style sheets must not use rules other than the allowed ones inside conditional group rules.
</p>

<p>
~CSS処理器は、条件付き~group規則の内側にて，許容されない規則があれば、それらを無視し~MUST。
また，~group規則の内側の妥当でない規則については、
`CSS21$rの
<a href="~CSS21/syndata.html#parsing-errors">4.2 節</a>
（構文解析~errorの取扱い規則）,
<a href="~CSS21/syndata.html#at-rules">4.1.5 節</a>
（at-規則）,
<a href="~CSS21/syndata.html#rule-sets">4.1.7 節</a>
（規則~集合, 宣言~block, 選択子）
の記述に従って，取扱うことが要求される。
◎
CSS processors must ignore rules that are not allowed within a group rule, and must handle invalid rules inside of group rules as described in section 4.2 (Rules for handling parsing errors), section 4.1.5 (At-rules), and section 4.1.7 (Rule sets, declaration blocks, and selectors) of [CSS21].
</p>
	</section>
	<section id="use">
<h2 title="Placement of conditional group rules">4. 条件付き~group規則が許容される場所</h2>

<p>
`条件付き~group規則$は、~stylesheetの~top-level, および
他の`条件付き~group規則$の内側にて許容される。
~CSS処理器は、それらを２節
<a href="#processing">条件付き~group規則の処理</a>
に従って処理し~MUST。
◎
Conditional group rules are allowed at the top-level of a style sheet, and inside other conditional group rules. CSS processors must process such rules as described above.
</p>

<p>
~style規則より後の位置には許容されない規則（例えば
`charset^at, 
`import^at,
`namespace^at
規則など）は、`条件付き~group規則$の後でも許容されない。
したがって、~stylesheetの中では，そのような規則が`条件付き~group規則$の後に置かれては~MUST_NOT。
また、~CSS処理器は，そのような規則を無視し~MUST。
◎
Any rules that are not allowed after a style rule (e.g., @charset, @import, or @namespace rules) are also not allowed after a conditional group rule. Therefore, style sheets must not place such rules after a conditional group rules, and CSS processors must ignore such rules.
</p>

	</section>
	<section id="at-media">
<h2 title="Media-specific style sheets: the '@media' rule">5. 媒体~特有の~stylesheet： `media^at 規則</h2>

<p>
`media@at
規則は、条件が`媒体~query$であるような `条件付き~group規則$であり，［
at-~keyword `media$at,
（空もとり得る）`媒体~query~list$（ `MEDIAQ$r にて定義される）,
`~group規則の本体$
］の並びからなる。
規則の条件は，`媒体~query$の結果で与えられる。
◎
The @media rule is a conditional group rule whose condition is a media query. It consists of the at-keyword '@media' followed by a (possibly empty) media query list (as defined in [MEDIAQ]), followed by a group rule body. The condition of the rule is the result of the media query.
</p>

<div class="example">
<p>
次の `media$at 規則：
◎
This '@media' rule:
</p>

<pre>
@media screen and (min-width: 35em),
       print and (min-width: 40em) {
  #section_navigation { float: left; width: 10em; }
}</pre>

<p>
は、［
~screen表示であって, かつ その表示域の横幅が初期~font~sizeの 35 倍以上である
］, または［
印刷~表示であって, かつ その表示域の横幅が初期~font~sizeの 40 倍以上である
］ときに、真になる条件
<samp class="css">screen and (`min-width^p: `35em^v), print and (`min-width^p: `40em^v)</samp>
を持つ。
これらのいずれかが成立するとき，規則の条件は真になり、規則
<samp class="css">#section_navigation { `float^p: `left^v; `width^p: `10em^v; }</samp>
が適用される。
◎
has the condition screen and (min-width: 35em), print and (min-width: 40em), which is true for screen displays whose viewport is at least 35 times the initial font size and for print displays whose viewport is at least 40 times the initial font size. When either of these is true, the condition of the rule is true, and the rule #section_navigation { float: left; width: 10em; } is applied.
</p>

</div>

<p>
文法においては、`CSS 2.1 の文法$（ `CSS21$r, 付録 G ）の
`media^P 生成規則が，次の様に拡張される：
◎
In terms of the grammar, this specification extends the media production in the Grammar of CSS 2.1 ([CSS21], Appendix G) into:
</p>

<pre class="proddef">
`media@P
  : MEDIA_SYM S* `media_query_list$P `group_rule_body$P
  ;</pre>

<p>
`group_rule_body$P 生成規則は この仕様にて定義される。
`media_query_list$P 生成規則は `MEDIAQ$r にて定義される。
他のものは `CSS 2.1 の文法$にて定義される。
<span class="trans-note">【
参考：
<a href="~MQ4#typedef-media-query-list">Media Queries Level 4 による構文</a>
】</span>

◎
where the group_rule_body production is defined in this specification, the media_query_list production is defined in [MEDIAQ], and the others are defined in the Grammar of CSS 2.1 ([CSS21], Appendix G).
</p>

	</section>
	<section id="at-supports">
<h2 title="Feature queries: the '@supports' rule">6. 特色機能~query： `supports^at 規則</h2>

<p>
`supports@at
規則は、~UAが ［ ~CSS~prop: その値 ］の組を`~support$するかどうかを~testする，`条件付き~group規則$である。
これを，［
新たな特色機能が~supportされていて可用なときは それを利用し，そうでなければ 上品に退行する
］ような~stylesheetを記すときに、利用できる。
~CSSには、未~supportの［
~prop／~propの値
］を無視するなど，上品に退行するための既存の仕組みも備わっているが、［
新たな~layout~systemによる特色機能
］を利用するときなど，［
~styleの巨大な~groupを，一定の特色機能の~supportに束ねる
］に足るものではない。
◎
The @supports rule is a conditional group rule whose condition tests whether the user agent supports CSS property:value pairs. Authors can use it to write style sheets that use new features when available but degrade gracefully when those features are not supported. CSS has existing mechanisms for graceful degradation, such as ignoring unsupported properties or values, but these are not always sufficient when large groups of styles need to be tied to the support for certain features, as is the case for use of new layout system features.
</p>

<p>
`supports$at 規則の中の条件の構文は、（`媒体~query$と多少の類似性はあるが）他の`条件付き~group規則$に対するものより少しばかり複雑になる。
何故なら：
◎
The syntax of the condition in the '@supports' rule is slightly more complicated than for the other conditional group rules (though has some similarities to media queries) since:
</p>

<ul>
	<li>
新たな特色機能による~styleと, ~fallbackの~styleを，［
（ at-規則の構文のための前方互換な文法の規則の中で）分離できるようにする
］ため, および［
互いが相手を上書きしないようにする
］ためには、否定（
negation — `not^css
）が必要になる。
◎
negation is needed so that the new-feature styles and the fallback styles can be separated (within the forward-compatible grammar’s rules for the syntax of @-rules), and not required to override each other
</li>

	<li>
複数の特色機能が要求されるときに，それを~testするためには、論理積（
conjunction — `and^css
）が必要になる。
◎
conjunction (and) is needed so that multiple required features can be tested
</li>

	<li>
~styleの集合のための，代替の特色機能が複数あるときには、論理和（
disjunction — `or^css
）が必要になる。
特に、それらの代替の一部が，~vendor接頭辞~付きの~prop名／値であるとき。
◎
disjunction (or) is needed when there are multiple alternative features for a set of styles, particularly when some of those alternatives are vendor-prefixed properties or values
</li>

</ul>

<p>
したがって， `supports$at 規則の構文では、~propの［名前:値］の組, および
それらを［
論理積（ `and^css ）, 論理和（ `or^css ）, 否定（ `not^css ）
］により任意に組み合わせる~testが許容されている。
◎
Therefore, the syntax of the '@supports' rule allows testing for property:value pairs, and arbitrary conjunctions (and), disjunctions (or), and negations (not) of them.
</p>

<p>
これは、次を追加して， `CSS 2.1 の文法$（ `CSS21$r, 付録 G ）の字句~scannerを拡張する：
◎
This extends the lexical scanner in the Grammar of CSS 2.1 ([CSS21], Appendix G) by adding:
</p>

<pre class="proddef">
@{S}{U}{P}{P}{O}{R}{T}{S} {return `SUPPORTS_SYM@P;}
{O}{R}                    {return `OR@P;}
</pre>

<div class="p">
<p>
次に、この字句~scannerに次のもの：

<ul>
	<li>
Media Queries 仕様 `MEDIAQ$r にて定義される［
`AND$P, `NOT$P
］~token
</li>
	<li>
上で定義された［
`OR$P, `SUPPORTS_SYM$P
］~token
</li>
	<li>
［
`declaration$P, `any$P, `unused$P
］生成規則
</li>
	<li>
`CSS21$r の
<a href="~CSS21/syndata.html#tokenization">4.1.1 節 （~token化）</a>
にて定義される~CSSの中核~構文から採られた
`FUNCTION$P ~token
</li>
</ul>

<p>
を追加した上で，次を追加することにより、
`CSS 2.1 の文法$を拡張する：
</p>
◎
This then extends the grammar in the Grammar of CSS 2.1, using the lexical scanner there, with the additions of AND and NOT tokens defined in the Media Queries specification [MEDIAQ] and the OR and SUPPORTS_SYM tokens defined above, and with declaration, any, and unused productions and the FUNCTION token taken from the core syntax of CSS defined in section 4.1.1 (Tokenization) of [CSS21], by adding:
</div>


<pre class="proddef">
`supports_rule@P
  : `SUPPORTS_SYM$P `S$P* `supports_condition$P `S$P* `group_rule_body$P
  ;

`supports_condition@P
  : `supports_negation$P | `supports_conjunction$P | `supports_disjunction$P |
    `supports_condition_in_parens$P
  ;

`supports_condition_in_parens@P
  : ( '(' `S$P* `supports_condition$P `S$P* ')' ) | `supports_declaration_condition$P |
    `general_enclosed$P
  ;

`supports_negation@P
  : `NOT$P `S$P* `supports_condition_in_parens$P
  ;

`supports_conjunction@P
  : `supports_condition_in_parens$P ( `S$P* `AND$P `S$P* `supports_condition_in_parens$P )+
  ;

`supports_disjunction@P
  : `supports_condition_in_parens$P ( `S$P* `OR$P `S$P* `supports_condition_in_parens$P )+
  ;

`supports_declaration_condition@P
  : '(' `S$P* `declaration$P ')'
  ;

`general_enclosed@P
  : ( `FUNCTION$P | '(' ) ( `any$P | `unused$P )* ')'
  ;
</pre>


<p>
`supports-condition@t
生成規則は `supports_condition$P 文法に合致するものとして定義される。
◎
The &lt;supports-condition&gt; production is defined as matching the supports_condition grammar, defined above.
</p>

<p>
実装は、上の文法に基づいて
`supports$at
規則を構文解析し~MUST。
上の文法を解釈する際には、演算子 "<code class="css">|</code>" の前に位置する生成規則を，後に位置するものより先に合致させ~MUST。
◎
Implementations must parse @supports rules based on the above grammar, and when interpreting the above grammar, must match the production before an | operator in preference to the one after it.
</p>

<p>
上の文法は、前方互換性の理由から~~意図的に緩くされている。
`general_enclosed$P 生成規則が，将来の拡張性のために相応のものを許容しているので。
上の文法に則って構文解析できない `supports$at 規則（すなわち `general_enclosed$P 生成規則を含みつつ，この緩い文法に合致しない規則）は、妥当でない。
~stylesheetは、そのような規則を用いては~MUST_NOT。
処理器は、そのような規則を（そのすべての内容も含め）無視し~MUST。
◎
The above grammar is purposely very loose for forwards-compatibility reasons, since the general_enclosed production allows for substantial future extensibility. Any @supports rule that does not parse according to the grammar above (that is, a rule that does not match this loose grammar which includes the general_enclosed production) is invalid. Style sheets must not use such a rule and processors must ignore such a rule (including all of its contents).
</p>

<p>
これらの文法記号のそれぞれが、次に従って真偽値による結果に結付けられる：
◎
Each of these grammar terms is associated with a boolean result, as follows:
</p>

<dl>
	<dt>`supports_condition$P</dt>
	<dd>
結果は、子のいずれかの文法記号の結果になる。
◎
The result is the result of the single child term.
</dd>

	<dt>`supports_condition_in_parens$P</dt>
	<dd>
結果は、子の
`supports_condition$P
または
`supports_declaration_condition$P 
文法記号の結果になる。
◎
The result is the result of the single supports_condition or supports_declaration_condition child term.
</dd>

	<dt>`supports_negation$P</dt>
	<dd>
結果は、子の
`supports_condition_in_parens$P
文法記号の結果の <em>否定</em> になる。
◎
The result is the negation of the result of the supports_condition_in_parens child term.
</dd>

	<dt>`supports_conjunction$P</dt>
	<dd>
結果は、子の <em>すべて</em> の
`supports_condition_in_parens$P
文法記号の結果が真であれば真, 他の場合は偽になる。
◎
The result is true if the result of all of the supports_condition_in_parens child terms is true; otherwise it is false.
</dd>

	<dt>`supports_disjunction$P</dt>
	<dd>
結果は、子の <em>いずれか</em> の
`supports_condition_in_parens$P
文法記号の結果が真であれば真, 他の場合は偽になる。
◎
The result is true if the result of any of the supports_condition_in_parens child terms is true; otherwise it is false.
</dd>

	<dt>`supports_declaration_condition$P</dt>
	<dd>
結果は、~CSS処理器が 括弧~内の宣言を<a href="#support-definition">~support</a>するならば真, 他の場合は偽になる。
◎
The result is whether the CSS processor supports the declaration within the parentheses.
</dd>

	<dt>`general_enclosed$P</dt>
	<dd>
結果は常に偽になる。
加えて，~stylesheetには、この文法~生成規則に合致する
`supports$at
規則が書かれては~MUST_NOT。
（言い換えれば、この生成規則は，将来の拡張性のためのみに存在するものであり、現~levelの仕様の下では，妥当な~stylesheetの記述の一部にはならない）。
◎
The result is always false. Additionally, style sheets must not write @supports rules that match this grammar production. (In other words, this production exists only for future extensibility, and is not part of the description of a valid style sheet in this level of the specification.) Note that future levels may define functions or other parenthesized expressions that can evaluate to true.
</dd>

	<dd class="note">注記：
将来の~levelにて、真に評価され得るような，［
関数式, あるいは括弧で括られる他の式
］が、定義され得る。
◎
↑</dd>

</dl>

<p>
`supports$at 規則の条件は、
`supports_rule$P 文法記号の子である `supports_condition$P 文法記号の結果で与えられる。
◎
The condition of the '@supports' rule is the result of the supports_condition term that is a child of the supports_rule term.
</p>

<div class="example">
<p>
例えば，次の規則：
◎
For example, the following rule
</p>

<pre>
@supports ( display: flex ) {
  body, #navigation, #content { display: flex; }
  #navigation { background: blue; color: white; }
  #article { background: white; color: black; }
}</pre>

<p>
は、
<samp class="css">`display$p: `flex^v</samp>
が`~support$されるときにのみ，
`supports$at 規則の内側の規則を適用する。
◎
applies the rules inside the '@supports' rule only when display: flex is supported.
</p>

</div>

<div class="example">
<p>
次の例に
<samp class="css">`display$p: `flex^v</samp>
が`~support$されないときの代替を提供する，追加の `supports$at 規則を示す：
◎
The following example shows an additional '@supports' rule that can be used to provide an alternative for when display: flex is not supported:
</p>

<pre>
@supports not ( display: flex ) {
  body { width: 100%; height: 100%; background: white; color: black; }
  #navigation { width: 25%; }
  #article { width: 75%; }
}</pre>

<p>
`width$p 宣言は、~flexに基づく~layoutには害を及ぼし得るので、非~flex~styleのときにのみ呈示されることが重要であることに注意。
◎
Note that the width declarations may be harmful to the flex-based layout, so it is important that they be present only in the non-flex styles.
</p>

</div>

<div class="example">
<p>
次の例では、 `box-shadow^p ~propの`~support$の有無を，その~vendor接頭辞（ `-foo-^css ）付き~versionも含め，検査する。
それは、（接頭辞~付きの~versionも含め）`~support$されるときには，~boxの
`border^p に代わって影（ `box-shadow^p ）が見えるように指定する。
◎
The following example checks for support for the box-shadow property, including checking for support for vendor-prefixed versions of it. When the support is present, it specifies both box-shadow (with the prefixed versions) and border in a way what would cause the box to become invisible were box-shadow not supported.
</p>

<pre>
.noticebox {
  border: 1px solid black;
  padding: 1px;
}
@supports ( box-shadow: 0 0 2px black inset ) or
          ( -foo-box-shadow: 0 0 2px black inset ) {
  .noticebox {
    -foo-box-shadow: 0 0 2px black inset;
    box-shadow: 0 0 2px black inset;
    /* <span class="comment">
上の規則を `supports$at 規則の中で上書きする
◎
override the rule above the @supports rule
</span> */
    border: none;
    padding: 2px;
  }
}</pre>

</div>

<p>
構文においては、混同を避けるため，
`and^css と `or$css の両者とも，明示的な指定が要求される（~commaや~spaceで代用するのではなく）。
同様に、優先順位の混同を避けるため，［
`and^css, `or$css, `not^css
］演算子が混在する際には 括弧の利用が要求される。
◎
To avoid confusion between and and or, the syntax requires that both and and or be specified explicitly (rather than, say, using commas or spaces for one of them). Likewise, to avoid confusion caused by precedence rules, the syntax does not allow and, or, and not operators to be mixed without a layer of parentheses.
</p>

<div class="example">
<p>
例えば，次の規則は妥当でない：
◎
For example, the following rule is not valid:
</p>

<pre class="illegal">
@supports (transition-property: color) or
          (animation-name: foo) and
          (transform: rotate(10deg)) {
  // ...
}</pre>

<p>
代わりに，次の様に書かれ~MUST：
◎
Instead, authors must write one of the following:
</p>

<pre>
@supports ((transition-property: color) or
           (animation-name: foo)) and
          (transform: rotate(10deg)) {
  // ...
}</pre>

<p >あるいは</p>

<pre>
@supports (transition-property: color) or
          ((animation-name: foo) and
           (transform: rotate(10deg))) {
  // ...
}</pre>

</div>

<p>
~testされている宣言が，式の中の唯一の成分であるときは、括弧で括られ~MUST。
◎
The declaration being tested must always occur within parentheses, when it is the only thing in the expression.
</p>

<div class="example">
<p>
例えば，次の規則は妥当でない：
◎
For example, the following rule is not valid:
</p>

<pre class="illegal">
@supports display: flex {
  // ...
}</pre>

<p>
代わりに次の様に書かれ~MUST：
◎
Instead, authors must write:
</p>

<pre>
@supports (display: flex) {
  // ...
}</pre>

</div>

<p>
構文では、余分な括弧も許容される。
この融通性は、作者にとりときどき有用になる（例えば，式の一部分を~commentで外すとき）。
また、著作~toolにとっても有用になる。
◎
The syntax allows extra parentheses when they are not needed. This flexibility is sometimes useful for authors (for example, when commenting out parts of an expression) and may also be useful for authoring tools.
</p>

<div class="example">
<p>
例えば，次の様に書かれてもよい：
◎
For example, authors may write:
</p>

<pre>
@supports ((display: flex)) {
  // ...
}</pre>

</div>

<p>
~testされる宣言の末尾の `!important^css は許容される。
宣言の妥当性には影響しないが。
◎
A trailing !important on a declaration being tested is allowed, though it won’t change the validity of the declaration.
</p>

<div class="example">
<p>
例えば，次の規則は妥当である：
◎
For example, the following rule is valid:
</p>

<pre>
@supports (display: flex !important) {
  // ...
}</pre>

</div>

		<section id="support-definition">
<h3 title="Definition of support">6.1. ~supportの定義</h3>

<p>
前方互換性のため、
`CSS21$r <a href="~CSS21/syndata.html#declaration">4.1.8 節</a>
（宣言と~prop）には，~propや値が妥当でないときの取扱い規則が規定されている。
仕様を実装しない あるいは部分的に実装する~CSS処理器は、自身が実装しない, あるいは実用~levelで~supportしない値のどの部分も，この［
~propや値が妥当でないときの取扱い規則
］に則って妥当でないものとして扱わ~MUST
— したがって，その宣言を構文解析~errorとして破棄し~MUST。
◎
For forward-compatibility, section 4.1.8 (Declarations and properties) of [CSS21] defines rules for handling invalid properties and values. CSS processors that do not implement or partially implement a specification must treat any part of a value that they do not implement, or do not have a usable level of support for, as invalid according to this rule for handling invalid properties and values, and therefore must discard the declaration as a parse error.
</p>

<p>
~CSS処理器は、（~propと値からなる）宣言を（構文解析~errorとして破棄せずに）受理するとき，その宣言を
`~support@
するとされる。
与えられた値を実装しない, あるいは実用~levelで~supportしない処理器は、その宣言を受理したり, それを~supportすると主張しては~MUST_NOT。
◎
A CSS processor is considered to support a declaration (consisting of a property and value) if it accepts that declaration (rather than discarding it as a parse error). If a processor does not implement, with a usable level of support, the value given, then it must not accept the declaration or claim support for it.
</p>

<p class="note">
注記：
利用者の選好により~supportが実質的に不能化された~propや値は、依然として，この定義の下では`~support$するものと見なされることに注意。
例えば利用者が，色を上書きする高~contrast~modeを可能化したために
`color^p ~propの宣言の効果が失われたとしても、依然として，~CSS処理器はその~propを`~support$するものと見なされる。
他方、試験的な~CSS特色機能の~supportを可能化-／不能化するような，開発者~用の選好は、この`~support$の定義に影響する。
◎
Note that properties or values whose support is effectively disabled by user preferences are still considered as supported by this definition. For example, if a user has enabled a high-contrast mode that causes colors to be overridden, the CSS processor is still considered to support the color property even though declarations of the color property may have no effect. On the other hand, a developer-facing preference whose purpose is to enable or disable support for an experimental CSS feature does affect this definition of support.
</p>

<p>
これらの規則（およびそれらの間の等価性）により、（
先に現れた宣言を後の宣言で上書きする
`CSS1$r 宣言の~~意味においても，あるいは
この仕様の
`supports$at
規則により提供される新たな能力が伴われている状況においても）実装されている特色機能が正しく働くような，作者による~fallbackの利用が可能になる。
このことは、とりわけ，複合的な値にも適用される — すなわち，［
~style規則の内側, あるいは
`supports$at
規則の宣言~条件の中
］の宣言が`~support$されると見なされるためには、その値のすべての部分が実装されてい~MUST。
◎
These rules (and the equivalence between them) allow authors to use fallback (either in the [CSS1] sense of declarations that are overridden by later declarations or with the new capabilities provided by the @supports rule in this specification) that works correctly for the features implemented. This applies especially to compound values; implementations must implement all parts of the value in order to consider the declaration supported, either inside a style rule or in the declaration condition of an @supports rule.
</p>

		</section>
	</section>
	<section id="apis">
<h2 title="APIs">7. API</h2>

		<section id="extentions-to-cssrule-interface">
<h3 title="Extensions to the CSSRule interface">7.1. `CSSRule^I ~interfaceに対する拡張</h3>

<p>
`CSSRule^I
~interfaceは次に従って拡張される：
◎
The CSSRule interface is extended as follows:
</p>

<pre class="idl">
partial interface CSSRule {
    const unsigned short `SUPPORTS_RULE@m = 12;
    <!--
    const unsigned short DOCUMENT_RULE = 13;
    -->
};</pre>


		</section>
		<section id="the-cssgroupingrule-interface">
<h3 title="The CSSGroupingRule interface">7.2. `CSSGroupingRule^I ~interface</h3>

<p>
`CSSGroupingRule$I
~interfaceは、他の規則を入子にして包含する at-規則を表現する。
◎
The CSSGroupingRule interface represents an at-rule that contains other rules nested inside itself.
</p>

<pre class="idl">
interface `CSSGroupingRule@I : CSSRule {
    readonly attribute `CSSRuleList$I `cssRules$m;
    unsigned long `insertRule$m(DOMString rule, unsigned long %index);
    void `deleteRule$m(unsigned long %index);
};</pre>

<dl class="idl-def">
	<dt>`cssRules@m</dt>
	<dd>
被取得時には、~group化~規則の内側に入子にされた~CSS規則の~listを表現する
`CSSRuleList^I<!-- CSSOM -->
~objを返さ~MUST。
◎
The cssRules attribute must return a CSSRuleList object for the list of CSS rules nested inside the grouping rule.
</dd>

	<dt>`insertRule(rule, index)@m</dt>
	<dd>
<p >
被呼出時には、~CSS規則 %rule を，
`cssRules^m から返される~CSS規則~listの中の
%index の位置に挿入し~MUST。
%index 以降の規則は，一つずつ後にずらされることになる。
次に該当する場合は、例外が投出され~MUST：
</p>
		<ul>
			<li>
%index が `cssRules.length^m より大きい場合は
`IndexSizeError^E 。
</li>
			<li>
規則に構文~errorがあって構文解析できない場合は `SyntaxError^E
— これには、規則の内側の構成子における~error取扱い規則により取扱われる構文~errorは含まれないが、与えられた文字列が単独の~CSS規則に構文解析されない場合（例えば文字列が空のとき）や, その単独の~CSS規則の後に 空白でも~commentでもないものが来る場合は含まれる。
</li>
			<li>
指定された所に規則を挿入できない場合は `HierarchyRequestError^E
— 例えば、 `import^at 規則が~group規則の内側に挿入された場合など。
</li>
		</ul>
◎
The insertRule operation must insert a CSS rule rule into the CSS rule list returned by cssRules, such that the inserted rule will be at position index, and any rules previously at index or higher will increase their index by one. It must throw INDEX_SIZE_ERR if index is greater than cssRules.length. It must throw SYNTAX_ERR if rule has a syntax error and is unparseable; this does not include syntax errors handled by error handling rules for constructs inside of the rule, but this does include cases where the string given does not parse into a single CSS rule (such as when the string is empty) or where there is anything other than whitespace or comments after that single CSS rule. It must throw HIERARCHY_REQUEST_ERR if the rule cannot be inserted at the location specified, for example, if an @import rule is inserted inside a group rule.
</dd>
	<dd>
これは、 %index ~parameterをそのまま返す。
◎
The return value is the index parameter.
</dd>

	<dt>`deleteRule(index)@m</dt>
	<dd>
<p>
被呼出時には、
`cssRules$m から返される~CSS規則~listから，
%index に位置する~CSS規則を除去し~MUST。
</p>
		<ul>
			<li>
［
%index ~GTE `cssRules.length^m
］の場合、 `IndexSizeError^E を投出し~MUST。
</li>
		</ul>
◎
The deleteRule operation must remove a CSS rule from the CSS rule list returned by cssRules at index. It must throw INDEX_SIZE_ERR if index is greater than or equal to cssRules.length.
</dd>

	</dl>

  
		</section>
		<section id="the-cssconditionrule-interface">
<h3 title="The CSSConditionRule interface">7.3. `CSSConditionRule^I ~interface</h3>

<p>
`CSSConditionRule$I ~interfaceは、条件と［文の~block］からなる，すべての種類の “条件付き” at-規則を表現する<span class="trans-note">【基底~interfaceである】</span>。
◎
The CSSConditionRule interface represents all the “conditional” at-rules, which consist of a condition and a statement block.
</p>

<pre class="idl">
interface `CSSConditionRule@I : `CSSGroupingRule$I {
    attribute DOMString `conditionText$m;
};</pre>

<dl class="idl-def">
	<dt>`conditionText@m</dt>
	<dd>
この属性は、規則の条件を表現する。
この条件は `CSSConditionRule$I の派生~interfaceによって様々であり、それらの派生~interfaceはこの属性に対し，異なる挙動を指定し得る（例えば，下の `CSSMediaRule$I ）。
その種の規則~特有の挙動が不在の下では、次の規則が適用される：
◎
The conditionText attribute represents the condition of the rule. Since what this condition does varies between the derived interfaces of CSSConditionRule, those derived interfaces may specify different behavior for this attribute (see, for example, CSSMediaRule below). In the absence of such rule-specific behavior, the following rules apply:
</dd>
	<dd>
被取得時には、結付けられている条件を直列化した結果を返さ~MUST。
◎
The conditionText attribute, on getting, must return the result of serializing the associated condition.
</dd>
	<dd>
<p>
被設定時には、次を走らせ~MUST。
◎
On setting the conditionText attribute these steps must be run:
</p>

		<ol>
			<li>
与えられた値の前後の空白 並びを取り除く。
◎
Trim the given value of white space.
</li>

			<li>
与えられた値が、与えられた規則に対する適切な条件 生成規則の文法に合致する場合、結付けられている~CSS条件を与えられた値で置換する。
◎
If the given value matches the grammar of the appropriate condition production for the given rule, replace the associated CSS condition with the given value.
</li>

			<li>
他の場合、何もしない。
◎
Otherwise, do nothing.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="the-cssmediarule-interface">
<h3 title="The CSSMediaRule interface">7.4. `CSSMediaRule^I ~interface</h3>

<p>
`CSSMediaRule$I ~interfaceは `media$at 規則を表現する：
◎
The CSSMediaRule interface represents a @media rule:
</p>

<pre class="idl">
interface `CSSMediaRule@I : `CSSConditionRule$I {
    readonly attribute `MediaList$I `media$m;
};</pre>

<dl class="idl-def">
	<dt>`media@m</dt>
	<dd>
被取得時には、 `media$at 規則により指定された
`媒体~query$の~listに対する
`MediaList$I ~objを返さ~MUST。
◎
The media attribute must return a MediaList object for the list of media queries specified with the '@media' rule.
</dd>

	<dt>`conditionText$m</dt>
<!-- 
(CSSMediaRule-specific definition for attribute on CSSConditionRule) 
-->
	<dd>
基底~interface `CSSConditionRule$I にて定義される，この属性には、この~interface特有の挙動が定義される：
</dd>
	<dd>
被取得時には， `media.mediaText^m 規則~上の値を返さ~MUST。
◎
The conditionText attribute (defined on the CSSConditionRule parent rule), on getting, must return the value of media.mediaText on the rule.
</dd>
	<dd>
被設定時には、この規則の `media.mediaText^m 属性を新たな値に設定し~MUST。
◎
Setting the conditionText attribute must set the media.mediaText attribute on the rule.
</dd>

</dl>

		</section>
		<section id="the-csssupportsrule-interface">
<h3 title="The CSSSupportsRule interface">7.5. `CSSSupportsRule^I ~interface</h3>

<p>
`CSSSupportsRule$I ~interfaceは `supports$at 規則を表現する。
◎
The CSSSupportsRule interface represents a @supports rule.
</p>

<pre class="idl">
interface `CSSSupportsRule@I : `CSSConditionRule$I {
};</pre>

<dl class="idl-def">
	<dt>`conditionText$m</dt>
	<dd>
基底~interface `CSSConditionRule$I にて定義される，この属性には、この~interface特有の挙動が定義される。
◎
↓</dd>
	<dd>
被取得時には、指定されている条件を返さ~MUST。
指定されている条件が、この仕様に適合するどの実装の下でも同じ結果に評価されるようにするため、返される条件には，いかなる論理的な簡約も施されてはならない（この仕様の
`general_enclosed$P
拡張性の仕組みにより許容される将来の拡張を実装する実装も含め）。
言い換えれば、~token~streamの簡約は許容されるが（空白を， 1 個の~spaceに縮約したり, 省略できる所では省略するなど）、論理的な簡約（不要な括弧の除去や, 評価結果に基づく，簡約など）は許容されない。
◎
The conditionText attribute (defined on the CSSConditionRule parent rule), on getting, must return the condition that was specified, without any logical simplifications, so that the returned condition will evaluate to the same result as the specified condition in any conformant implementation of this specification (including implementations that implement future extensions allowed by the general_enclosed exensibility mechanism in this specification). In other words, token stream simplifications are allowed (such as reducing whitespace to a single space or omitting it in cases where it is known to be optional), but logical simplifications (such as removal of unneeded parentheses, or simplification based on evaluating results) are not allowed.
</dd>

	</dl>
  <!--
<h3 id="the-cssdocumentrule-interface">
The `CSSDocumentRule^I interface</h3>

<p>The <dfn>`CSSDocumentRule^I</dfn> interface represents a @document rule.</p>

<pre class='idl'>interface CSSDocumentRule : CSSConditionRule {
};</pre>
-->

  
		</section>
		<section id="the-css-interface">
<h3 title="The CSS interface, and the supports() function">7.6. `CSS^I ~interfaceと `supports()^m 関数</h3>

<p>
`CSS$I ~interfaceは、他に属さない有用な~CSSに関係する関数を保持する。
◎
The CSS interface holds useful CSS-related functions that do not belong elsewhere.
</p>

<pre class="idl">
interface `CSS$I {
  static boolean `supports$m(DOMString %property, DOMString %value);
  static boolean `~supports0$m(DOMString %conditionText);
};</pre>

<dl class="idl-def">
	<dt>`supports(property, value)@m</dt>
	<dd>
被呼出時には、［
%property が~UAが`~support$する~CSS~propの名前に~literalとして合致する, かつ
%value がその~propで~supportされる値として成功裡に構文解析される場合は ~T ／
他の場合は ~F
］を返さ~MUST。
（~literalとして合致とは、~CSS~escape処理は遂行されず, 先頭や末尾の空白も削られないことを意味する。
したがって，
%property の先頭や末尾に空白があったり,
%property に~CSS~escapeが含まれていても、
~F が返される。）
◎
When the supports() method is invoked with two arguments property and value, it must return true if property is a literal match for the name of a CSS property that the UA supports, and value would be successfully parsed as a supported value for that property. (Literal match means that no CSS escape processing is performed, and leading and trailing whitespace are not stripped, so any leading whitespace, trailing whitespace, or CSS escapes equivalent to the name of a property would cause the method to return false.) Otherwise, it must return false.
</dd>

	<dt>`~supports0(conditionText)@m</dt>
	<dd>
<p>
被呼出時には、
%conditionText に対し次のいずれかを行った結果が真ならば ~T ／
他の場合は ~F
］を返さ~MUST：
</p>

<ul ><li>`supports_condition$P として構文解析して, 評価した結果 
</li><li>`declaration$P として構文解析した結果を暗黙の丸括弧で括って, 
`supports_condition$P として評価した結果
</li></ul>

◎
When invoked with a single conditionText argument, it must return true if conditionText, when either parsed and evaluated as a supports_condition or parsed as a declaration, wrapped in implied parentheses, and evaluated as a supports_condition, would return true. Otherwise, it must return false. 
</dd>
</dl>

	</section>
	<section id="changes">
<h2 title="Changes">8. 変更点</h2>

<p>
この仕様に加えられた
<a href="https://www.w3.org/TR/2013/CR-css3-conditional-20130404/">2013 年 4月 4 日 勧告候補</a>
からの主要な変更点は：
◎
The following (non-editorial) changes were made to this specification since the 13 December 2012 Working Draft:
</p>

<ul>
	<li>
<a href="http://www.w3.org/TR/css3-mediaqueries/">Media Queries</a>
と一貫させるため、
`and^css ／ `or$css ／ `not$css
~keywordの前後に空白を要求する要件を外した。
（それら自体は CSS の~token化における より謎めいたある側面に依拠する，ある CSS ~minimizerの出力との互換性により拘束される）。
空白（または~comment）は、これらの~keywordの<em >後には</em>，依然として要求されることに注意
— さもなければ、それらの~keywordと それに続く開き丸括弧は，関数の~~開始~tokenに~token化されることになるので。
◎
Drop requirement for spaces around and, or, and not keywords for consistency with Media Queries (which are themselves constrained by compatibility with the output of some CSS minimizers that rely on some of the more arcane aspects of CSS tokenization). Note that white space--or a comment--is still required after these keywords, since without it they and the ensuing opening parenthesis will be tokenized as a function opening token.
</li>
	<li>
`~supports0()$m ~methodにおいて、単純な宣言に対する暗黙の丸括弧も許容した
— `import$at 規則の `supports()^css 関数と一貫させるため。
◎
Allow the supports() method to imply parentheses for simple declarations, for consistency with the @import rule’s supports() function.
</li>
	<li>
IDL ~codeに抜けていたセミコロンを修正した。
◎
Fixed missing semicolons in IDL code.
</li>
	<li>
他の~moduleの変更に呼応して，~link, 各種用語, 例示~codeを変更した。
◎
Updated links, terminology, and example code in response to changes to other modules.
</li>
</ul>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<div>
Thanks to the ideas and feedback from Tab Atkins, Arthur Barstow, Ben
Callahan, <span lang="tr">Tantek Çelik</span>, Alex Danilo, Elika Etemad,
Pascal Germroth, <span lang="de">Björn Höhrmann</span>, Paul Irish, Brad
Kemper, <span lang="nl">Anne van Kesteren</span>, Vitor Menezes, Alex
Mogilevsky, Chris Moschini, James Nurthen, Simon Pieters, <span lang="fr">Florian Rivoal</span>, <span lang="fr">Simon Sapin</span>, Nicholas
Shanks, Ben Ward, Zack Weinberg, Estelle Weyl, Boris Zbarsky, and all the
rest of the <a href="https://lists.w3.org/Archives/Public/www-style/">www-style</a>
community.
</div>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">~privacy／保安~上の考慮点</h2>

<p>
この仕様が，保安~上の新たな考慮点を導入することはない。
◎
This spec introduces no new security considerations.
</p>

<p>
この仕様は、［
ある~privacy上の考慮点がある `media$at 規則
］の定義を改変するが、その改変は，新たな~privacy上の考慮点を導入するものではない。
この仕様の他の特色機能にも~privacy上の考慮点はない。
◎
While this spec does modify the definition of the @media rule, which does have some privacy considerations, the modifications defined here do not have any effect on the privacy considerations for @media. No other feature in this spec has any privacy considerations.
</p>

	</section>

</main></div><!-- MAIN -->

	<section id="conformance">
<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="css-common-ja.html#conformance">CSS 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>




<dl>

	<dt>[CSS-CASCADE-4]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-cascade/</dd>

	<dt>[CSS-CONDITIONAL-3]</dt>
	<dd>CSS Conditional Rules Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-conditional-3/</dd>

	<dt>[CSS-SYNTAX-3]</dt>
	<dd>Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-syntax/</dd>

	<dt>[CSS21]</dt>
	<dd>Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC.</dd>
	<dd>https://www.w3.org/TR/CSS2</dd>

	<dt>[CSS3-ANIMATIONS]</dt>
	<dd>Dean Jackson; et al. CSS Animations. 19 February 2013. WD.</dd>
	<dd>https://www.w3.org/TR/css3-animations/</dd>

	<dt>[CSS3-FONTS]</dt>
	<dd>John Daggett. CSS Fonts Module Level 3. 3 October 2013. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-fonts/</dd>

	<dt>[CSSOM-1]</dt>
	<dd>Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD.</dd>
	<dd>https://drafts.csswg.org/cssom/</dd>

	<dt>[MEDIAQ]</dt>
	<dd>Florian Rivoal; et al. Media Queries. 19 June 2012. REC.</dd>
	<dd>https://www.w3.org/TR/css3-mediaqueries/</dd>

	<dt>[MEDIAQUERIES-4]</dt>
	<dd>Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4. 6 July 2016. WD.</dd>
	<dd>https://drafts.csswg.org/mediaqueries-4/</dd>


<!-- 
	<dt>[RFC2119]</dt>
 -->
</dl>

		</section>
		<section id="informative">
<h3 title="Other References">文献（参考）</h3>


<dl>

	<dt>[CSS-BACKGROUNDS-3]</dt>
	<dd>CSS Backgrounds and Borders Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-backgrounds-3/</dd>

	<dt>[CSS-COLOR-3]</dt>
	<dd>CSS Color Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-color-3/</dd>

	<dt>[CSS-DISPLAY-3]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 15 October 2015. WD.</dd>
	<dd>http://dev.w3.org/csswg/css-display/</a></dd>

	<dt>[CSS1]</dt>
	<dd>Håkon Wium Lie; Bert Bos. Cascading Style Sheets (CSS1) Level 1 Specification. 11 April 2008. REC.</dd>
	<dd>https://www.w3.org/TR/CSS1/</dd>

	<dt>[CSS3-TRANSITIONS]</dt>
	<dd>Dean Jackson; et al. CSS Transitions. 19 November 2013. WD.</dd>
	<dd>http://dev.w3.org/csswg/css-transitions/</dd>
</dl>



		</section>
	</section>
	<section id="index">
<h2 title="Index">索引</h2>

<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>

	</section>

	<section>

<h2 id="idl-index" title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<!-- 
<h2 id="property-index" title="Property index" data-cycling=".propdef">プロパティ索引</h2>
<h2 id="issues-index" title="Issues Index" data-cycling=".issue">課題索引</h2>
 -->

<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>

</html>

