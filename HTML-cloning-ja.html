<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Safe passing of structured data（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/infrastructure.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 151224 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		E: 'error',
		sl: 'js-slot',
		js: 'js',
		jA: 'abstract',
		jM: 'js-method',
		jC: 'js-class',
		jV: 'js-value',
		jI: 'js-intrinsic',
		t: 'type',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		c: 'code',
		sl: 'span',
		js: 'span',
		jA: 'span',
		jI: 'span',
		jC: 'code',
		jM: 'code',
		jV: 'code',
		V: 'var',
		t: 'var',
		i: 'i', // model constants
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|❝.|◎[^<◎]*|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '❝':
		return ( 'U+00'
			+ match[1].charCodeAt(0).toString(16).toUpperCase()
			+ ' ( "<code class="literal">' + match[1] + '</code>" )'
		);
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl': // JS internal slot
	text = '[[' + key + ']]';
	break;
case 'jI': // JS intrinsic objects
	text = '%' + key + '%';
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
</script>

<!--% リンク置換データ -->

<script type="text/plain" id="_link_map">
	●idl
I.Blob:~FILEAPI#dfn-Blob
I.File:~FILEAPI#dfn-file
I.FileList:~FILEAPI#dfn-filelist

E.DataCloneError:~WEBIDL#datacloneerror

m.MessagePort.postMessage:~HTML-COMMS#dom-messageport-postmessage
m.Window.postMessage:~HTML-COMMS#dom-window-postmessage
m.postMessage:~HTML-COMMS#dom-messageport-postmessage

	●js clone／転送
sl.Clone:#clone
sl.Detached:#detached
sl.Transfer:#transfer

jI.ArrayBuffer:~TC39#sec-arraybuffer-constructor
jI.ArrayPrototype:~TC39#sec-properties-of-the-array-prototype-object

	jA.ToString:~TC39#sec-tostring
jA.IsTransferable:#istransferable
jA.StructuredClone:#structuredclone
jA.StructuredCloneWithTransfer:#structuredclonewithtransfer
jA.Transfer:#transfer-abstract-op
jA.ArrayCreate:~TC39#sec-arraycreate
jA.CloneArrayBuffer:~TC39#sec-clonearraybuffer
jA.CreateDataProperty:~TC39#sec-createdataproperty
jA.DetachArrayBuffer:~TC39#sec-detacharraybuffer
jA.IsCallable:~TC39#sec-iscallable
jA.HasOwnProperty:~TC39#sec-hasownproperty
jA.IsDetachedBuffer:~TC39#sec-isdetachedbuffer
jA.OrdinaryGetOwnProperty:~TC39#sec-ordinarygetownproperty
jA.Type:~TC39#sec-ecmascript-data-types-and-values
jA.TypedArrayCreate:~TC39#typedarray-create
jA.EnumerableOwnProperties:~TC39#sec-enumerableownproperties

js.List:~TC39#sec-list-and-record-specification-type
js.Record:~TC39#sec-list-and-record-specification-type
	The TypedArray Constructors:~TC39#table-49

転送可能:#transferable-objects
転送可能な~obj:#transferable-objects
~cloneable:#cloneable-objects
~cloneable~obj:#cloneable-objects

x.marshalling:https://en.wikipedia.org/wiki/Marshalling_%28computer_science%29
x.~JS値への変換:~WEBIDL#es-type-mapping
x.~URLの構文解析:~URLSpec#concept-url-parser


~scriptを走らすために準備する:~WAPI#prepare-to-run-script
~callbackを走らすために準備する:~WAPI#prepare-to-run-a-callback
~entry〜:~WAPI#concept-entry-everything
~incumbent〜:~WAPI#concept-incumbent-everything
~event-loop:~WAPI#event-loop
~realm実行文脈:~WAPI#realm-execution-context
~task:~WAPI#concept-task
生成元:~BROWSERS#concept-origin

x.~closeされ:~FILEAPI#closed
x.~platform~obj:~WEBIDL#dfn-platform-object

</script>


<!--% 置換データ -->
<script type="text/plain" id="words_table1">
HTML-COMMS:https://html.spec.whatwg.org/multipage/comms.html

this:<b class="js">this</b>
Foo:<var>Foo</var>
</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">

	●処理
task::::タスク
event-loop:event loop:::イベントループ
instance::::インスタンス
class::::クラス
code::::コード
interface::::インタフェース
key::::
error::::エラー
list::::リスト
obj:object:::オブジェクト
	primitive
slot::::スロット
algo:algorithm:::アルゴリズム
call::::
callback::::
script::::スクリプト


処理-:process:~
処理:processing:~
出力:output:~
入力:input:~
内部:internal:~
同期して:synchronous に:~
同期的:synchronous:~

変換-:convert:~
変換:conversion:~
即時に:immediate に:~

例外:exception:~
呼出す:invoke する:呼び出す
呼出した:invoke した:呼び出した
呼出して:invoke して:呼び出して
呼出され:invoke され:呼び出され

設定-:set:~
走らせ:run し:~
走らす:run する:走らせる
遂行-:perform:~
	返す:return:~
新たな:new:~
	新たに:newly:~
投出:throw:~
演算-:operate:~
演算:operation:~

	●有構造~clone
clone::::クローン
cloning::::クローン
cloneable::::クローン可能
deep::深い
entry::::エントリ
incumbent:
exotic:
intrinsic:
buffer::::バッファ
prototype:
detach:
realm:
実行文脈:execution context:~
入物:placeholder
抽象演算:abstract operation:~
	~~精確には:technically

長th:length:長さ
	~cloned::::
転送可能な:transferable::~
	monkey patch
	そのうち:in due course
転送可能:transferable::~
転送対象:transferable::~
	targetRealm::~
転送-:transfer::~
	転送list:transfer list::転送 list:転送リスト
転送:transferring::~
不可逆:irreversible:~
循環参照:cycle:~
graph::::グラフ
複製:copy:~
複製済:copied:複製済み
記述子:descriptor:~
	Desc:
有構造:structured::~
低levelの:low-level:低 level の::低レベルの
冪等:idempotent:~

	●仕様
API:
UA:user agent:UA
care::::ケア
	利用-:use:~
一般:general:~
不正:incorrect:~
仕様:spec:~
作者:author:~
依拠-:rely:~
保全-:preserve:~
保持-:hold:~
側面:aspect:~
危険で:danger で:~
取扱われ:handle され:取り扱われ
各種用語:terminology:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
意味-:mean:~
意味:meaning:~
所与の:given:与えられた
手続き:steps:~
指定-:specify:~
既定:default:~
暗黙的:implicit:~
概念:concept:~
注意深く:careful に:~
無視-:ignore:~
目的0:purpose:目的
表記規約:conventions:~
適切:appropriate:~
適用-:apply:~
高価:expensive:~
有用:useful:~
実質的:effective:~
適正:proper:~
通例的:usual:~
準備-:prepare:~
準備:preparation:~
	解され:understood
	対照的に:in contrast
	現時点では:As of this time
	あるとするなら、:hypothetical
	する側:sites
	一部:part of
	規定-
	表-
	表記
	明らか
	必要
	必要とされ
	意図
	記され
	記号
	課題
	通例でないunusual
	利用-
	可能
	大雑把に言えば
	委ねられ
	容易:ease:~
	事前に
	今や:now:~
	〜の代わりに:instead:~
	今や
	以前
	以外
	任意の:arbitrary:~
	具体的には:for instance
	供され


	●未分類
JS:JavaScript
URL:
WebIDL:Web IDL

close:
data::::データ
field::::フィールド
map::::
method::::メソッド
platform::::プラットフォーム
support::::サポート
worker::::
access::::アクセス
accessor::::アクセサ
除去-:remove:~
置換-:replace:~
境界:boundary:~
文書:document:~
可列挙:enumerable:~
	列挙:enumeration:~


構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
直列化-:serialize::~::シリアライズ
直列化:serialization::~::シリアル化

生成元:origin::~::オリジン
資源:resource::~:リソース

下層の:underlying:~
作成-:create:~
作成:creation:~
値:value:~
公開-:expose:~
共有-:share:~
内側:inside:~
単純:simple:~
参照:reference:~
名前:name:~
安全:safe:~
引数:argument:~
所有権:ownership:~
構築子:constructor::~::コンストラクタ
直接的:direct:~
空:empty:~
識別-:identify:~
追加-:add:~
部位:portion:~
配列:array:~
重複:duplicate:~

並替える:reorder する:並び替える
未指定の:unspecified:~
方式:manner:~
決定的:deterministic:~
提供-:provide:~
順序付け:ordering:~
収集:collection:~
	何らか
	何
	側
	元
	内
	再び
	再度
	前に
	右辺
	各
	同じ
	向けに
	否定を
	含め
	場合
	対応
	属する
	当の
	得る
	所では
	持つ
	挙げられ
	方
	時
	時点
	~~最終的~final
	末尾
	次の
	次を
	比較式に
	決して
	渡し
	現れる
	生じ
	異なる
	種
	節
	結果
	自身
	見よ
	見られ
	知られ
	越えて
	間
	限らない
	限り
	類の
</script>


<!--%style -->
<style type="text/css">
*[lang="en"] {
	white-space: pre-line;
}

.js, .js-slot, .js-value, .js-intrinsic, .js-symbol, .js-class, .js-method {
	color: green;
}


</style>

</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Standard — Safe passing of structured data 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Common infrastructure</a>
章の
<a href="https://html.spec.whatwg.org/multipage/infrastructure.html#safe-passing-of-structured-data">Safe passing of structured data</a>
節を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2016-11-23</time>
（公開：<time>2016-01-28</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">

	<hgroup>
<h1>有構造データの安全な渡し方 — Safe passing of structured data</h1>
<h2>HTML Living Standard — 最終更新 2016 年 11 月 17 日</h2>
	</hgroup>

</header>

<hr>

<main id="MAIN" style="display:none;">

	<section id="safe-passing-of-structured-data">
<h2 title="Safe passing of structured data">2.7. 有構造~dataの安全な渡し方</h2>

<p>
この節では、~JS仕様による，各種用語と表記規約を利用する。
`JAVASCRIPT$r
◎
This section uses the terminology and typographic conventions from the JavaScript specification. [JAVASCRIPT]
</p>


<ul class="trans-note">
	<li>
~algo内の抽象演算の前に現れる記号［
"?", "!"
］の意味は、その仕様にて定義される。
（大雑把に言えば、 "?" は 例外が投出され得ることを表し， "!" は 例外は決して投出されないことを表す）。
</li>
	<li>
`~Foo^sl という表記は、名前 "~Foo" の［
内部~slot／内部~method／~field
］（~JS~code向けに直接~公開されることはない内部~data）を表す。
</li>
</ul>

<p class="trans-note">【
加えて、この訳では次のような略記法を導入する：
】</p>

<ul>
	<li>
“%O.`~Foo^sl”
のような表記は、［
~JS~obj ／ ~JS `Record$js
］ %O 上の 名前 `~Foo^l の［［
内部~slot または 内部~method
］／ ~field
］を表すとする。
%O が明らかな所では、単に “.`~Foo^sl” のようにも記される。
</li>
	<li>
代入の右辺や比較式に現れる
“%O.`~Foo^sl”
のような表記は、 ~Foo［
内部~slot ／ ~field
］の値を表す。
同様に，
“%O.`~Foo^sl(…)”
は、 ~Foo 内部~methodを~callした結果の値を表す。
</li>
	<li>
“%O.`~Foo^sl ~NEQ ε”
という表記は、
%O は，名前 `~Foo^l の［
内部~slot／内部~method／~field
］を持つことを意味する。
“%O.`~Foo^sl ~EQ ε”
はその否定を意味する。
</li>
</ul>


		<section id="cloneable-objects">
<h3 title="Cloneable objects">2.7.1. ~cloneable~obj</h3>

<p>
`~cloneable~obj$は、`~event-loop$間をまたぐ~cloningを~supportする~objである。
すなわち，それらは、異なる`生成元$に属する文書~間も含め，文書や~workerの境界を越えて~cloneし得る。
~objには`~cloneable$でないものもある。
`~cloneable$であっても，そのすべての側面が~clone時に保全されるとは限らない。
◎
Cloneable objects support being cloned across event loops. That is, they support being cloned across document and worker boundaries, including across documents of different origins. Not all objects are cloneable objects and not all aspects of objects that are cloneable objects are necessarily preserved when cloned.
</p>

<p>
`~platform~obj$xは、次の内部~methodを持つ：
◎
Platform objects have the following internal method:
</p>

<ul><li>`Clone@sl( %targetRealm, %memory ) 
</li></ul>

<p>
他から指定されない限り、 `Clone$sl 内部~methodが呼出されたときは， `DataCloneError$E 例外を投出し~MUST（すなわち，既定においては、`~cloneable$でない）。
◎
Unless specified otherwise, invoking the [[Clone]] internal method must throw a "DataCloneError" DOMException. (By default, platform objects are not cloneable objects.)
</p>

<p class="trans-note">【
%targetRealm は、おそらく，`~realm実行文脈$の~realmを意図していると見られる。
】</p>

<p>
`~cloneable$である`~platform~obj$xの `Clone$sl 内部~methodは、ある手続きを走らすものと指定される。
この手続きは、例外を投出するか，または［
%targetRealm 内にて作成される， ~this の~clone
］を返さ~MUST。
~cloningが何を意味するかは、当の~obj自身の定義に委ねられる。
◎
Platform objects that are cloneable objects have a [[Clone]] internal method which is specified to run a series of steps. The result of running those steps must be a thrown exception or a clone of this, created in targetRealm. It is up such objects to define what cloning means for them.
</p>

<p>
~JS仕様にて定義される~objは、
`StructuredClone$jA 抽象演算により直接的に取扱われる。
◎
Objects defined in the JavaScript specification are handled by the StructuredClone abstract operation directly.
</p>


		</section>
		<section id="transferable-objects">
<h3 title="Transferable objects">2.7.2. 転送可能な~obj</h3>

<p>
`転送可能な~obj$は、`~event-loop$間をまたぐ転送を~supportする。
転送は、実質的に，~objを再度~作成することである
— その下層の~dataへの参照は共有しつつ，転送されている~objは~detachするような。
これは、高価な資源の所有権を転送するときに，有用になる。
~objには`転送可能$でないものもある。
~objが`転送可能$であっても，そのすべての側面が転送-時に保全されるとは限らない。
◎
Transferable objects support being transferred across event loops. Transferring is effectively recreating the object while sharing a reference to the underlying data and then detaching the object being transferred. This is useful to transfer ownership of expensive resources. Not all objects are transferable objects and not all aspects of objects that are transferable objects are necessarily preserved when transferred.
</p>

<p class="note">
転送は、不可逆であり，`転送する側にとっては^tnote冪等でない演算である。
~objを転送した側は、それを再び 転送する／利用することはできなくなる。
◎
Transferring is an irreversible and non-idempotent operation. Once an object has been transferred, it cannot be transferred, or indeed used, again.
</p>

<div class="p">
<p>
`転送可能$である`~platform~obj$xは、次のものを持つ：
</p>

<ul ><li>`Detached@sl 内部~slot
</li><li>`Transfer@sl( %targetRealm ) 内部~method
</li></ul>

◎
Platform objects that are transferable objects have a [[Detached]] internal slot and the following internal method:
◎
[[Transfer]] ( targetRealm )
</div>

<p class="note">
すべての`~platform~obj$xは `Clone$sl 内部~methodを持つが，［
`Detached$sl 内部~slot ／ `Transfer$sl 内部~method
］を持つとは限らない。
◎
Whereas all platform objects have a [[Clone]] internal method, not all have a [[Detached]] internal slot and a [[Transfer]] internal method.
</p>



<div class="p">
<p>
`転送可能$である`~platform~obj$xの `Transfer$sl 内部~methodは、次のように定義され~MUST：
</p>

		<ul>
			<li>
例外を投出するか, または
%targetRealm 内にて作成される，
~this の~cloneを返す。
</li>
			<li>
返り値は ~this の下層の~dataを共有する。
</li>
			<li>
~this.`Detached$sl を ~T に設定する。
</li>
		</ul>

<p>
~objの転送が何を意味するかは、当の~obj自身の定義に委ねられる。
</p>

◎
Platform objects that are transferable objects must define the [[Transfer]] internal method such that it either throws an exception or returns a clone of this, created in targetRealm, with this's underlying data shared with the return value, and this's [[Detached]] internal slot value set to true. It is up to such objects to define what transferring means for them.
</div>

<p>
~JS仕様にて定義される~objは、
`StructuredCloneWithTransfer$jA 抽象演算により直接的に取扱われる（~~精確には，
`IsTransferable$jA, `Transfer$jA
により）。
◎
Objects defined in the JavaScript specification are handled by the StructuredCloneWithTransfer abstract operation directly. (Technically, by IsTransferable and Transfer.)
</p>


		</section>
		<section id="structuredclonewithtransfer">
<h3>2.7.3. `StructuredCloneWithTransfer^jA( %入力, %転送-~list, %targetRealm )</h3>

<ol>
	<li>
<p>
%memory ~LET 空~map
◎
Let memory be an empty map.
</p>

<p class="note">
`StructuredClone$jA 抽象演算における %memory ~mapの目的0は、~objが重ねて~cloneされないようにすることである。
これには、循環参照を保全して，~graphにおける~objの重複を識別することが必要になる。
◎
The purpose of the memory map, both here and in the StructuredClone abstract operation, is to avoid cloning objects twice. This ends up preserving cycles and the identity of duplicate objects in graphs.
</p>
	</li>
	<li>
<p>
~FOR
%転送-~list 内の~EACH ( ~obj %転送対象 ) に対し：
◎
For each object transferable in transferList:
</p>
		<ol>
			<li>
~IF［
`IsTransferable$jA( %転送対象 ) ~EQ ~F
］
⇒
~THROW `DataCloneError$E
◎
If IsTransferable(transferable) is false, then throw a "DataCloneError" DOMException.
</li>
			<li>
%入物 ~LET ~UAにより定義される入物~obj
◎
Let placeholder be a user-agent-defined placeholder object.
</li>
			<li>
%memory 内に，新たな~entry ( ~key %転送対象, 値 %入物 ) を作成する
◎
Create an entry in memory with key transferable and value placeholder.
</li>
		</ol>
	</li>
	<li>
%~clone ~LET
? `StructuredClone$jA( %入力, %targetRealm, %memory )
◎
Let clone be the result of ? StructuredClone(input, targetRealm, memory).
</li>
	<li>
%出力~転送-~list ~LET 新たな空 `List$js
◎
Let outputTransferList be a new empty List.
</li>
	<li>
<p>
~FOR
%転送-~list 内の~EACH ( ~obj %転送対象 ) に対し：
◎
For each object transferable in transferList:
</p>

		<ol>
			<li>
%入物~結果 ~LET %memory 内の［
~key ~EQ %転送対象
］なる~entryの値
◎
Let placeholderResult be the value of the entry in memory whose key is transferable.
</li>
			<li>
%転送-結果 ~LET
? `Transfer$jA( %転送対象, %targetRealm )
◎
Let transferResult be ? Transfer(transferable, targetRealm).
</li>
			<li>
<p>
%~clone の中で、 %入物~結果 への参照を %転送-結果 で置換する
—
%入物~結果 への参照を保持している あらゆるものは、
%転送-結果 への参照を保持させるように。
◎
Within clone, replace references to placeholderResult with transferResult, such that everything holding a reference to placeholderResult, now holds a reference to transferResult.
</p>

<p class="note">
これは、~JSに規定されていない，通例でない低levelの演算である。
◎
This is a rather unusual low-level operation for which no primitives are defined by JavaScript.
</p>
			</li>
			<li>
%出力~転送-~list の末尾に %転送-結果 を追加する
◎
Add transferResult as the last element of outputTransferList.
</li>
		</ol>
	</li>
	<li>
~RET { `Clone^sl: %~clone, `TransferList^sl: %出力~転送-~list }
◎
Return { [[Clone]]: clone, [[TransferList]]: outputTransferList }.
</li>
</ol>

  
<p class="note">
`StructuredCloneWithTransfer$jA ／ `StructuredClone$jA
抽象演算は、元々は，［
“有構造~clone”, “内部~有構造~clone”
］~algoとして知られていた。
~objの転送は、今や `StructuredCloneWithTransfer$jA 抽象演算により取扱われる
— それは、以前までは［
`Window.postMessage()$m, `MessagePort.postMessage()$m 
］~methodの~algoの一部により取扱われていたものである。
◎
Originally the StructuredCloneWithTransfer abstract operation was known as the "structured clone" algorithm. The StructuredClone abstract operation was known as the "internal structured clone" algorithm. Transferring objects, now handled by the StructuredCloneWithTransfer abstract operation, were formerly handled by parts of the algorithm of the postMessage() method on the Window object and the postMessage() method on the MessagePort object.
</p>

		</section>
		<section id="structuredclone">
<h3>2.7.4. `StructuredClone^jA( %入力, %targetRealm [ , %memory ] )</h3>

<span id="structured-clone"></span>

<ol>
	<li>
~IF［
%memory は与えられていない
］
⇒
%memory ~LET 空~map
◎
If memory was not supplied, let memory be an empty map.
</li>
	<li>
~IF［
%memory 内に［
~key ~EQ %入力
］なる~entryがある
］
⇒
~RET その~entryの値
◎
If memory contains an entry with key input, then return that entry's value.
</li>
	<li>
~IF［
`Type$jA( %入力 ) ~IN
{ `Undefined^jC, `Null^jC, `Boolean^jC, `String^jC, `Number^jC }
］
⇒
~RET %入力
◎
If Type(input) is Undefined, Null, Boolean, String, or Number, then return input.
</li>
	<li>
~IF［
`Type$jA( %入力 )  ~EQ `Symbol^jC
］
⇒
~THROW `DataCloneError$E
◎
If Type(input) is Symbol, then throw a "DataCloneError" DOMException.
</li>
	<li>
%~deep~clone ~LET ~F；<br />
%出力 ~LET ε
◎
Let deepClone be false.
</li>
	<li>
~IF［
%入力.`BooleanData^sl ~NEQ ε
］
⇒
%出力 ~SET 次のようにされた， %targetRealm 内の新たな `Boolean^jC ~obj
⇒
.`BooleanData^sl ~SET %入力.`BooleanData^sl
◎
If input has a [[BooleanData]] internal slot, then let output be a new Boolean object in targetRealm whose [[BooleanData]] internal slot value is the [[BooleanData]] internal slot value of input.
</li>
	<li>
~ELIF［
%入力.`NumberData^sl ~NEQ ε
］
⇒
%出力 ~SET 次のようにされた， %targetRealm 内の新たな `Number^jC ~obj
⇒
.`NumberData^sl ~SET %入力.`NumberData^sl
◎
Otherwise, if input has a [[NumberData]] internal slot, then let output be a new Number object in targetRealm whose [[NumberData]] internal slot value is the [[NumberData]] internal slot value of input.
</li>
	<li>
~ELIF［
%入力.`StringData^sl ~NEQ ε
］
⇒
%出力 ~SET 次のようにされた， %targetRealm 内の新たな `String^jC ~obj
⇒
.`StringData^sl ~SET %入力.`StringData^sl
◎
Otherwise, if input has a [[StringData]] internal slot, then let output be a new String object in targetRealm whose [[StringData]] internal slot value is the [[StringData]] internal slot value of input.
</li>
	<li>
~ELIF［
%入力.`DateValue^sl ~NEQ ε
］
⇒
%出力 ~SET 次のようにされた， %targetRealm 内の新たな `Date^jC ~obj
⇒
.`DateValue^sl ~SET %入力.`DateValue^sl
◎
Otherwise, if input has a [[DateValue]] internal slot, then let output be a new Date object in targetRealm whose [[DateValue]] internal slot value is the [[DateValue]] internal slot value of input.
</li>
	<li>
~ELIF［
%入力.`RegExpMatcher^sl ~NEQ ε
］
⇒
%出力 ~SET 次のようにされた， %targetRealm 内の新たな `RegExp^jC ~obj
⇒
.`RegExpMatcher^sl ~SET %入力.`RegExpMatcher^sl；<br>
.`OriginalSource^sl ~SET %入力.`OriginalSource^sl；<br>
.`OriginalFlags^sl ~SET %入力.`OriginalFlags^sl；<br>
◎
Otherwise, if input has a [[RegExpMatcher]] internal slot, then let output be a new RegExp object in targetRealm whose [[RegExpMatcher]] internal slot value is the [[RegExpMatcher]] internal slot value of input, whose [[OriginalSource]] internal slot value is the [[OriginalSource]] internal slot value of input, and whose whose [[OriginalFlags]] internal slot value is the [[OriginalFlags]] internal slot value of input.
</li>
	<li>
<p>
~ELIF［
%入力.`ArrayBufferData^sl ~NEQ ε
］：
◎
Otherwise, if input has an [[ArrayBufferData]] internal slot, then:
</p>

		<ol>
			<li>
~IF［
`IsDetachedBuffer$jA( %入力 ) ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
If IsDetachedBuffer(input) is true, then throw a "DataCloneError" DOMException.
</li>
			<li>
%出力~配列~buffer ~LET %targetRealm 内の `ArrayBuffer$jI ~intrinsic~obj
◎
Let outputArrayBuffer be the %ArrayBuffer% intrinsic object in targetRealm.
</li>
			<li>
%出力 ~SET
? `CloneArrayBuffer$jA( %入力, `0^jV, %出力~配列~buffer )
◎
Let output be ? CloneArrayBuffer(input, 0, outputArrayBuffer).
</li>
		</ol>
	</li>
	<li>
    
<p>
~ELIF［
%入力.`ViewedArrayBuffer^sl ~NEQ ε
］：
◎
Otherwise, if input has a [[ViewedArrayBuffer]] internal slot, then:
</p>

		<ol>
			<li>
%~buffer ~LET %入力.`ViewedArrayBuffer^sl
◎
Let buffer be the value of input's [[ViewedArrayBuffer]] internal slot.
</li>
			<li>
%~buffer~clone ~LET
? `StructuredClone$jA( %~buffer, %targetRealm, %memory )
◎
Let bufferClone be ? StructuredClone(buffer, targetRealm, memory).
</li>
			<li>
~IF［
%入力.`DataView^sl ~NEQ ε
］
⇒
%出力 ~SET 次のようにされた， %targetRealm 内の新たな `DataView^jC ~obj
⇒
.`DataView^sl ~SET ~T；<br>
.`ViewedArrayBuffer^sl ~SET %~buffer~clone；<br>
.`ByteLength^sl ~SET %入力.`ByteLength^sl；<br>
.`ByteOffset^sl ~SET %入力.`ByteOffset^sl
◎
If input has a [[DataView]] internal slot, then let output be a new DataView object in targetRealm whose [[DataView]] internal slot value is true, whose [[ViewedArrayBuffer]] internal slot value is bufferClone, whose [[ByteLength]] internal slot value is the [[ByteLength]] internal slot value of input, and whose [[ByteOffset]] internal slot value is the [[ByteOffset]] internal slot value of input.
</li>
			<li>

<p>
~ELSE：
◎
Otherwise:
</p>

				<ol>
					<li>
~Assert：
%入力.`TypedArrayName^sl ~NEQ ε
◎
Assert: input has a [[TypedArrayName]] internal slot.
</li>
					<li>
%構築子 ~LET ［
<a href="~TC39#table-49">TypedArray Constructors table</a>
の一列目に挙げられている~intrinsic~obj
］ for ［
%入力.`TypedArrayName^sl
］ in ［
%targetRealm
］
◎
Let constructor be the intrinsic object listed in column one of The TypedArray Constructors table for the value of input's [[TypedArrayName]] internal slot in targetRealm.
</li>
					<li>
%byteOffset ~LET %入力.`ByteOffset^sl
◎
Let byteOffset be input's [[ByteOffset]] internal slot value.
</li>
					<li>
%長th ~LET %入力.`ArrayLength^sl
◎
Let length be input's [[ArrayLength]] internal slot value.
</li>
					<li>
%出力 ~SET
? `TypedArrayCreate$jA( %構築子, «%~buffer~clone, %byteOffset, %長th» )
◎
Let output be ? TypedArrayCreate(constructor, « bufferClone, byteOffset, length »).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%入力.`MapData^sl ~NEQ ε
］：
◎
Otherwise, if input has [[MapData]] internal slot, then:
</p>

		<ol>
			<li>
%出力 ~SET 次のようにされた， %targetRealm 内の新たな `Map^jC ~obj
⇒
.`MapData^sl ~SET 新たな空 `List$js
◎
Let output be a new Map object in targetRealm whose [[MapData]] internal slot value is a new empty List.
</li>
			<li>
%~deep~clone ~SET ~T
◎
Set deepClone to true.
</li>
		</ol>
	</li>
	<li>
    
<p>
~ELIF［
%入力.`SetData^sl ~NEQ ε
］：
◎
Otherwise, if input has [[SetData]] internal slot, then:
</p>

		<ol>
			<li>
%出力 ~SET 次のようにされた， %targetRealm 内の新たな `Set^jC ~obj
⇒
.`SetData^sl ~SET 新たな空 `List$js
◎
Let output be a new Set object in targetRealm whose [[SetData]] internal slot value is a new empty List.
</li>
			<li>
%~deep~clone ~SET ~T
◎
Set deepClone to true.
</li>
		</ol>
	</li>
	<li>
    
<p>
~ELIF［
%入力 は `Array^jC ~exotic~objである
］：
◎
Otherwise, if input is an Array exotic object, then:
</p>
    

		<ol>
			<li>
%入力~長th ~LET
`OrdinaryGetOwnProperty$jA( %入力, `length^l ).`Value^sl
◎
Let inputLen be OrdinaryGetOwnProperty(input, "length").[[Value]].
</li>
			<li>
%出力~prototype ~LET %targetRealm 内の
`ArrayPrototype$jI ~intrinsic~obj
◎
Let outputProto be the %ArrayPrototype% intrinsic object in targetRealm.
</li>
			<li>
%出力 ~SET ! `ArrayCreate$jA( %入力~長th, %出力~prototype )
◎
Let output be ! ArrayCreate(inputLen, outputProto).
</li>
			<li>
%~deep~clone ~SET ~T
◎
Set deepClone to true.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%入力.`Clone$sl ~NEQ ε
］
⇒
%出力 ~SET
? %入力 .`Clone$sl( %targetRealm, %memory )
◎
Otherwise, if input has a [[Clone]] internal method, then let output be ? input.[[Clone]](targetRealm, memory).
</li>
	<li>
~ELIF［
`IsCallable$jA( %入力 ) ~EQ ~T
］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if IsCallable(input) is true, then throw a "DataCloneError" DOMException.
</li>
	<li>
<p>
~ELIF［
%入力 は［
.`Prototype^sl, .`Extensible^sl
］以外の内部~slotを持つ
］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if input has any internal slot other than [[Prototype]] or [[Extensible]], then throw a "DataCloneError" DOMException.
</p>

<p class="example">
具体的には、
.`PromiseState^sl や .`WeakMapData^sl
など。
◎
For instance, a [[PromiseState]] or [[WeakMapData]] internal slot.
</p>
	</li>
	<li>
<p>
~ELIF［
%入力 は~exotic~objである
］
⇒
~THROW `DataCloneError$E
◎
Otherwise, if input is an exotic object, then throw a "DataCloneError" DOMException.
</p>

<p class="example">
具体的には、 proxy ~obj。
◎
For instance, a [[PromiseState]] or [[WeakMapData]] internal slot.
</p>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>

		<ol>
			<li>
%出力 ~SET %targetRealm 内の新たな `Object^jC
◎
Let output be a new Object in targetRealm.
</li>
			<li>
%~deep~clone ~SET ~T
◎
Set deepClone to true.
</li>
		</ol>
	</li>
	<li>
%memory 内に，新たな~entry ( ~key %入力, 値 %出力 ) を作成する
◎
Create an entry in memory whose key is input and value is output.
</li>
	<li>
~IF［
%~deep~clone ~EQ ~F
］
⇒
~RET %出力
◎
If deepClone is true, then:
</li>
	<li>
<p>
~IF［
%入力.`MapData^sl ~NEQ ε
］
⇒
◎
If input has a [[MapData]] internal slot, then:
</p>
		<ol>
			<li>
%入力~list ~LET %入力.`MapData^sl
◎
Let inputList the value of input's [[MapData]] internal slot.
</li>
			<li>
%複製済~list ~LET 新たな空 `List$js
◎
Let copiedList be a new empty List.
</li>
			<li>
<p>
~FOR
%入力~list 内の
~EACH ( `Record$js {`Key^sl, `Value^sl} %~entry ) に対し：
◎
Repeat for each Record {[[Key]], [[Value]]} entry that is an element of inputList,
</p>

				<ol>
					<li>
%複製済~entry ~LET 新たな `Record$js
{ `Key^sl: %~entry.`Key^sl, `Value^sl: %~entry.`Value^sl }
◎
Let copiedEntry be a new Record { [[Key]]: entry.[[Key]], [[Value]]: entry.[[Value]] }.
</li>
					<li>
~IF［
%複製済~entry.`Key^sl は空でない
］
⇒
%複製済~list の末尾に %複製済~entry を~~追加する
◎
If copiedEntry.[[Key]] is not empty, append copiedEntry as the last element of copiedList.
</li>
				</ol>
			</li>
			<li>
%出力~list ~LET %出力.`MapData^sl
◎
Let outputList be the value of output's [[MapData]] internal slot.
</li>
			<li>
<p>
~FOR
%複製済~list 内の
~EACH ( `Record$js {`Key^sl, `Value^sl} %~entry ) に対し：
◎
For each Record {[[Key]], [[Value]]} entry that is an element of copiedList,
</p>

				<ol>
					<li>
%出力~key ~LET
? `StructuredClone$jA( %~entry.`Key^sl, %targetRealm, %memory )
◎
Let outputKey be ? StructuredClone(entry.[[Key]], targetRealm, memory).
</li>
					<li>
%出力~値 ~LET
? `StructuredClone$jA( %~entry.`Value^sl, %targetRealm, %memory )
◎
Let outputValue be ? StructuredClone(entry.[[Value]], targetRealm, memory).
</li>
					<li>
%出力~list の末尾に
{ `Key^sl: %出力~key, `Value^sl: %出力~値 }
を追加する
◎
Add { [[Key]]: outputKey, [[Value]]: outputValue } as the last element of outputList.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%入力.`SetData^sl ~NEQ ε
］
⇒
◎
Otherwise, if input has a [[SetData]] internal slot, then:
</p>

		<ol>
			<li>
%複製済~list ~LET %入力.`SetData^sl の複製
◎
Let copiedList be a copy of the value of input's [[SetData]] internal slot.
</li>
			<li>
%出力~list ~LET %出力.`SetData^sl
◎
Let outputList be the value of output's [[SetData]] internal slot.
</li>
			<li>
<p>
~FOR
%複製済~list 内の空でない
~EACH ( %~entry ) に対し：
◎
For each entry that is an element of copiedList that is not empty,
</p>

				<ol>
					<li>
%出力~entry ~LET
? `StructuredClone$jA( %~entry, %targetRealm, %memory )
<!-- ＊？targetResult -->
◎
Let outputEntry be ? StructuredClone(entry, targetResult, memory).
</li>
			<li>
%出力~list の末尾に %出力~entry を追加する
◎
Add outputEntry as the last element of outputList.
</li>
				</ol>
			</li>
		</ol>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>

		<ol>
			<li>
%可列挙~key~list ~LET 新たな空~list
◎
Let enumerableKeys be a new empty List.
</li>
			<li>
<p>
~FOR
! %入力.`OwnPropertyKeys^sl() 内の ~EACH ( %~key ) に対し：
◎
For each key in ! input.[[OwnPropertyKeys]]():
</p>
				<ol>
					<li>
<p>
~IF［
`Type$jA( %~key ) ~EQ `String^jC
］：
◎
If Type(key) is String, then:
</p>

						<ol>
							<li>
%入力~記述子 ~LET
! %入力.`GetOwnProperty^sl( %~key )
◎
Let inputDesc be ! input.[[GetOwnProperty]](key).
</li>
							<li>
~IF［
%入力~記述子.`Enumerable^sl ~EQ ~T
］
⇒
%可列挙~key~list の末尾に %~key を追加する
◎
If inputDesc.[[Enumerable]] is true, then add key as the last element of enumerableKeys.
</li>
						</ol>
					</li>
					<li>

<p>
%可列挙~key~list 内の~EACH( %~key ) に対し：
◎
For each key in enumerableKeys:
</p>
						<ol>
							<li>

<p>
~IF［
! `HasOwnProperty$jA( %入力, %~key ) ~EQ ~T
］：
◎
If ! HasOwnProperty(input, key) is true, then:
</p>
								<ol>
									<li>
%入力~値 ~LET
? %入力.`Get^sl( %~key, %入力 )
◎
Let inputValue be ? input.[[Get]](key, input).
</li>
									<li>
%出力~値 ~LET
? `StructuredClone$jA( %入力~値, %targetRealm, %memory )
◎
Let outputValue be ? StructuredClone(inputValue, targetRealm, memory).
</li>
									<li>
? `CreateDataProperty$jA( %出力, %~key, %出力~値 ) を遂行する
◎
Perform ? CreateDataProperty(output, key, outputValue).
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
<p class="note">注記：
上で遂行される~key収集は，~JS仕様の `EnumerableOwnProperties$jA 演算によく似ているが、その演算のように~keyたちを未指定の方式で並替えることなく，
`OwnPropertyKeys^sl 内部~methodが提供する決定的な順序付けを利用する。
`JAVASCRIPT$r
◎
The key collection performed above is very similar to the JavaScript specification's EnumerableOwnProperties operation, but crucially it uses the deterministic ordering provided by the [[OwnPropertyKeys]] internal method, instead of reordering the keys in an unspecified manner as EnumerableOwnProperties does. [JAVASCRIPT]
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

  
<p class="note">
一般に実装は、 %targetRealm における~objの作成を実装するために，何らかの類の直列化と `marshalling$x を利用する必要がある
— %targetRealm は，異なる`~event-loop$内にあって、［
`StructuredCloneWithTransfer$jA ／ `StructuredClone$jA
］を呼出す~codeからは容易に~access可能でないかもしれないので。
◎
In general implementations will need to use some kind of serialization and marshalling to implement the creation of objects in targetRealm, as targetRealm could be in a different event loop and not easily accessible to the code that invokes StructuredCloneWithTransfer or StructuredClone.
</p>

		</section>
		<section id="istransferable">
<h3>2.7.5. `IsTransferable^jA( %O )</h3>

<ol>
	<li>
~Assert：
`Type$jA( %O ) ~EQ `Object^jC
◎
Assert: Type(O) is Object.
</li>
	<li>
<p>
~IF［
%O.`ArrayBufferData^sl ~NEQ ε
］：
◎
If O has an [[ArrayBufferData]] internal slot, then:
</p>

		<ol>
			<li>
~IF［
`IsDetachedBuffer$jA( %O ) ~EQ ~T
］
⇒
~RET ~F
◎
If IsDetachedBuffer(O) is true, then return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</li>
	<li>
    
<p>
~ELIF［
%O.`Detached$sl ~NEQ ε
］：
◎
Otherwise, if O has a [[Detached]] internal slot, then:
</p>

		<ol>
			<li>
~IF［
%O.`Detached$sl ~EQ ~T 
］
⇒
~RET ~F
◎
If O's [[Detached]] internal slot value is true, then return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>

  

		</section>
		<section id="transfer-abstract-op">
<h3>2.7.6. `Transfer^jA( %入力, %targetRealm )</h3>

<ol>
	<li>
<p>
~IF［
%入力.`ArrayBufferData^sl ~NEQ ε
］：
◎
If input has an [[ArrayBufferData]] internal slot, then:
</p>

		<ol>
			<li>
%出力 ~LET 次のようにされた， %targetRealm 内の新たな `ArrayBuffer^jC ~obj
⇒
.`ArrayBufferByteLength^sl ~SET %入力.`ArrayBufferByteLength^sl；<br>
.`ArrayBufferData^sl ~SET %入力.`ArrayBufferData^sl
◎
Let output be a new ArrayBuffer object in targetRealm whose [[ArrayBufferByteLength]] internal slot value is the [[ArrayBufferByteLength]] internal slot value of input, and whose [[ArrayBufferData]] internal slot value is the [[ArrayBufferData]] internal slot value of input.
</li>
			<li>
! `DetachArrayBuffer$jA( %入力 ) を遂行する
◎
Perform ! DetachArrayBuffer(input).
</li>
			<li>
~RET %出力
◎
Return output.
</li>
		</ol>
	</li>
	<li>
~RET
? %入力.`Transfer$sl( %targetRealm )
◎
Return ? input.[[Transfer]](targetRealm).
</li>
</ol>




		</section>
		<section id="performing-structured-clones-from-other-specifications">
<h3 title="Performing structured clones from other specifications">2.7.7. 他の仕様から有構造~cloneを遂行するとき</h3>

<p>
他の仕様は［
`StructuredClone$jA,
`StructuredCloneWithTransfer$jA,
`IsTransferable$jA,
`Transfer$jA
］抽象演算を利用してよい。
◎
Other specifications may use the StructuredClone, StructuredCloneWithTransfer, IsTransferable, and Transfer abstract operations.
</p>

<p>
一般に、~callする側は，~JS値の代わりに~WebIDL値を渡してもよい
— これは、これらの~algoを呼出す前に，暗黙的な`~JS値への変換$xを遂行するものと解される。
◎
In general, call sites may pass in Web IDL values instead of JavaScript values; this is to be understood to perform an implicit conversion to the JavaScript value before invoking these algorithms.
</p>

<p>
~callする側が［
作者~codeが~UA~methodの中へ~callした結果として同期的に呼出されてはいない
］場合、それが任意の~obj上で遂行されている場合には，これらの抽象演算を呼出す前に，適正に［
`~scriptを走らすために準備する$ ／ `~callbackを走らすために準備する$
］よう~careし~MUST。
このことは、必要とされる
— `StructuredClone$jA 演算は、その~~最終的な~deep~cloning手続きの一部として，作者により定義される~accessorを呼出すこともあり、その~accessorは［［
`~entry〜$／`~incumbent〜$
の概念が 適正に設定してある
］ことに依拠するような演算
］の中へ~callすることもあるので。
◎
Call sites that are not invoked as a result of author code synchronously calling into a user agent method must take care to properly prepare to run script and prepare to run a callback before invoking these abstract operations, if they are being performed on arbitrary objects. This is necessary because the StructuredClone operation can invoke author-defined accessors as part of its final deep-cloning steps, and these accessors could call into operations that rely on the entry and incumbent concepts being properly set up.
</p>

<p class="example">
`postMessage()$m は、その引数に対し `StructuredCloneWithTransfer$jA を遂行するが、注意深く，その~algoの同期的~部位の内側で即時にそうする。
したがって、［
`~scriptを走らすために準備する$ ／ `~callbackを走らすために準備する$
］必要なく，有構造~cloning~algoを利用できる。
◎
postMessage performs StructuredCloneWithTransfer on its arguments, but is careful to do so immediately, inside the synchronous portion of its algorithm. Thus it is able to use the structured cloning algorithms without needing to prepare to run script and prepare to run a callback.
</p>

<p class="example">
`~URLの構文解析$xは、作者~codeと同期的でない種々の時点で生じ得る。
しかしながら、~URL構文解析器が `StructuredClone$jA を適用するのは `Blob$I ~objのみなので、作者~codeを不正な［
`~entry〜$ ／ `~incumbent〜$
］値で走らせるのは危険でない。
よって，それについても、これらの準備~手続きを遂行する必要はない。
◎
Parsing URLs can happen at a variety of times that are not the synchronous result of author code. However, the URL parser only applies StructuredClone to Blob objects, so it is not in danger of running author code with incorrect entry and incumbent values, and thus it too does not need to perform these preparation steps.
</p>

<p class="example">
対照的に、 `StructuredClone$jA を利用して，［
作者から供された何らかの~objを，`~event-loop$上の`~task$から直接的に 毎回~直列化する
］ような ~APIがあるとするなら、それは［
有構造~clone~algoの中へ~callする前に適切な準備が遂行される
］ことを確保する必要がある。
現時点では、~platform上に そのような~APIはないことが知られている
— 通例的には， `postMessage()$m の様に、作者~codeに同期して，事前に~cloneを遂行しておく方が単純になる。
◎
In contrast, a hypothetical API that used StructuredClone to serialize some author-supplied object periodically, directly from a task on the event loop, would need to ensure it performs the appropriate preparations before calling into the structured clone algorithms. As of this time, we know of no such APIs on the platform; usually it is simpler to perform the clone ahead of time, as a synchronous consequence of author code, like postMessage.
</p>


		</section>
		<section id="monkey-patch-for-blob-and-filelist-objects">
<h3 title="Monkey patch for Blob and FileList objects">2.7.8. `Blob^I ／ `FileList^I ~objに対する monkey patch</h3>


<p class="XXX">課題：
この monkey patch は、そのうち除去されることになる。
<a href="https://github.com/w3c/FileAPI/issues/32">w3c/FileAPI issue 32</a>
を見よ。
◎
This monkey patch will be removed in due course. See w3c/FileAPI issue 32.
</p>


<p>
`Blob$I ~objは、`~cloneable~obj$である。
◎
Blob objects are cloneable objects.
</p>

<p class="algo-head">
各 `Blob$I ~objの `Clone$sl 内部~methodは、所与の
( %targetRealm, %memory )
に対し，次を走らせ~MUST（ %memory は無視される）：
◎
Each Blob object's [[Clone]] internal method, given targetRealm and ignoring memory, must run these steps:
</p>

<ol>
	<li>
~IF［
~this はすでに`~closeされ$xている
］
⇒
~THROW `DataCloneError$E
◎
If this is closed, then throw a "DataCloneError" DOMException.
</li>
	<li>
~RET 同じ下層の~dataに対応するような，
%targetRealm における ~this の新たな~instance
◎
Return a new instance of this in targetRealm, corresponding to the same underlying data.
</li>
</ol>

<p>
`FileList$I ~objは`~cloneable~obj$である。
◎
FileList objects are cloneable objects.
</p>

<p>
各 `FileList$I ~objの `Clone$sl 内部~methodは、所与の
( %targetRealm, %memory )
に対し，次を走らせ~MUST：
◎
Each FileList object's [[Clone]] internal method, given targetRealm and memory, must run these steps:
</p>

<ol>
	<li>
%出力 ~LET %targetRealm 内の新たな `FileList$I ~obj
◎
Let output be a new FileList object in targetRealm.
</li>
	<li>
~FOR
~this 内の~EACH ( %file ) に対し：
⇒
%出力 の［
`File$I ~objの~list
］の末尾に［
? `StructuredClone$jA( %file, %targetRealm, %memory )
］を追加する
◎
For each file in this, add ? StructuredClone(file, targetRealm, memory) to the end of the list of File objects of output.
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

		</section>
	</section>
</main><!-- id="MAIN" -->
