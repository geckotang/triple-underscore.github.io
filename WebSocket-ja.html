<!DOCTYPE html>
<html lang="ja"><head><meta charset="UTF-8">
<title>HTML Standard — WebSocket（日本語訳）</title>
<meta name="keywords" content="WebSocket,プロトコル,クライアント,HTML5,仕様">

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/comms.html',
		//original_url: 'http://www.w3.org/TR/websockets/',
		main: 'MAIN',
//		alt_refs: 'references',
//		ref_id_prefix: 'refs',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 160122 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		sc: 'scheme',
		E: 'error',
		h: 'header',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		hd: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		sc: 'code',
		et: 'code',
		h: 'code',
		E: 'code',
		v: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
//	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|%[\w~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('network', '_toc_list0');


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		if(match[1]){
			in_idl = true;
			nesting += '</pre>';
			return '<pre class="idl">';
		} else {
			nesting += '</span>';
			return '：<span class="block">';
		}
	case '⇒！':
	}//◎
	if(in_idl) {
		result = nesting;
		in_idl = false;
	} else {
		result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	}
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];
//var ifc = '';

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'I': // IDL interface
	if(in_idl) tag = '';
	break;
case 'm': // IDL member
case 'hd': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	if(in_idl) tag = '';
	break;
case 'sc': // url scheme
	text += ':';
	break;
case 'et': // event type
	break;
case 'i': // model constants
	break;
case 'v': // variables
	break;
case 'bug':
	return (
'<div class="spec-bug"><a href="~SPECBUGS?id=' + key + '">' + 'Spec bugs: ' + text + '</a></div>'
);
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">
</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">
	●IDL
I.WebSocket:#websocket
I.CloseEvent:#closeevent
I.CloseEventInit:#closeeventinit
I.BinaryType:#binarytype

I.EventHandler:~WAPI#eventhandler
I.Window:~BROWSERS#window
I.MessageEvent:~HTML5/comms.html#messageevent
I.Document:~HTMLDOM#document
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#interface-eventtarget
I.Blob:~FILEAPI#dfn-Blob
I.URL:~URLSpec#dom-url
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.ArrayBufferView:~WEBIDL#common-ArrayBufferView
I.USVString:~WEBIDL#idl-USVString


m.wasClean:#dom-closeevent-wasclean
m.code:#dom-closeevent-code
m.reason:#dom-closeevent-reason

m.onclose:#handler-websocket-onclose
m.onerror:#handler-websocket-onerror
m.onmessage:#handler-websocket-onmessage
m.onopen:#handler-websocket-onopen

m.WebSocket:#dom-websocket
m.binaryType:#dom-websocket-binarytype
m.bufferedAmount:#dom-websocket-bufferedamount
m.close:#dom-websocket-close
m.extensions:#dom-websocket-extensions
m.protocol:#dom-websocket-protocol
m.readyState:#dom-websocket-readystate
m.send:#dom-websocket-send
m.url:#dom-websocket-url
m.CLOSED:#dom-websocket-closed
m.CLOSING:#dom-websocket-closing
m.CONNECTING:#dom-websocket-connecting
m.OPEN:#dom-websocket-open

et.open:#event-open
et.message:#event-message
et.error:#event-error
et.close:#event-close


	●scheme
	●要素
	●HTTP header
	●RFC6455
~url:#concept-websocket-url
後述のように:#closeWebSocket
~WebSocket~task源:#websocket-task-source
消滅させる:#make-disappear
満杯~flag:#concept-websocket-close-fail
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler:~WAPI#event-handlers
~event~handler IDL 属性:~WAPI#event-handler-idl-attributes
~event-loop:~WAPI#event-loop
最初の段:#step-1
~event-loopの処理~model:~WAPI#processing-model-8
~task源:~WAPI#task-source
待入され:~WAPI#queue-a-task
待入し:~WAPI#queue-a-task
~task待行列:~WAPI#task-queue
~task:~WAPI#concept-task
単純~eventを発火する:~WAPI#fire-a-simple-event
~entry設定群~obj:~WAPI#entry-settings-object
並列的:~HTMLINFRA#in-parallel

生成元:~BROWSERS#concept-origin
url.生成元:~BROWSERS#origin

Unicode 直列化-:~BROWSERS#unicode-serialisation-of-an-origin
ASCII 直列化-:~BROWSERS#ascii-serialisation-of-an-origin
ASCII 小文字化-:~HTMLINFRA#converted-to-ascii-lowercase
~trusted:~HTMLINFRA#concept-events-trusted

BOM を取扱わずに UTF-8 復号-:~ENCODING#utf-8-decode-without-bom
UTF-8 符号化-:~ENCODING#utf-8-encode
	UTF-8 復号-:~ENCODING#utf-8-decode

	( ~HTMLINFRA#utf-8-decoder )
~URL構文解析器:~URLSpec#concept-url-parser
~URL直列化器:~URLSpec#concept-url-serializer

~URL:~URLSpec#concept-url
~URL~record:~URLSpec#concept-url
素片:~URLSpec#concept-url-fragment
~port:~URLSpec#concept-url-port
~scheme:~URLSpec#concept-url-scheme

	RFC6455
ws.~status~code:#_ws-status-code
開始済み
ws.~WebSocket~closing~handshakeは開始され:#_ws-closing-handshake-started
ws.~WebSocket~closing~handshakeが開始され:#_ws-closing-handshake-started
ws.~WebSocket~closing~handshakeを開始-:#_ws-to-start-closing-handshake
ws.~WebSocket~closing~handshakeを開始する:#_ws-to-start-closing-handshake


~WebSocket接続を確立する:~FETCH#concept-websocket-establish

ws.確立済み:#_ws-established
ws.確立され:#_ws-established
ws.~WebSocket接続を~closeする:#_ws-to-close
ws.~WebSocket~messageを送信する:#_ws-to-send
ws.~WebSocket~messageを受信した:#_ws-received
ws.~closeされ:#_ws-closed
ws.~WebSocket接続は~closed:#_ws-closed
ws.~closed:#_ws-closed
ws.~WebSocket接続を失敗させる:#_ws-to-fail
ws.~WebSocket接続~close~code:#_ws-close-code
ws.~WebSocket接続~close事由:#_ws-close-reason
ws.~cleanに~closeされた:#_ws-closed-cleanly
ws.下位protocol:#_ws-subprotocol
ws.下位protocol名:#_ws-subprotocol-name
ws.利用中の下位protocol:#_ws-subprotocol-in-use
ws.利用中の拡張:#_ws-extensions-in-use
ws.Close ~frame:#_ws-frame-type-Close
ws.Close ~message:#_ws-frame-type-Close
ws.Ping ~frame:#_ws-frame-type-Ping
ws.Pong ~frame:#_ws-frame-type-Pong
ws.~opcode:#_ws-data-opcode
ws.~payload~data:#_ws-data-Payload
ws.~text~data:#_ws-data-Text
ws.~binary~data:#_ws-data-Binary
ws.~frame種別:#_ws-frame-type

h.Sec-WebSocket-Protocol:#_ws-Sec-WebSocket-Protocol
“非 HTTP” API:#dfn-non-HTTP

	取消可能:~UIEVENTS#event-flow-default-cancel
	取消不可:~UIEVENTS#event-flow-default-cancel
	浮上-:~UIEVENTS#
	x.配送-:~DOM4#concept-event-dispatch
	x.配送する:~DOM4#concept-event-dispatch

</script>


<!--% 置換データ -->
<script type="text/plain" id="words_table1">
RFC6455:RFC6455-ja.html
HTML-IND:https://html.spec.whatwg.org/multipage/indices.html
</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">
WebSocket:
URL:
url:
record::::レコード
UA:user agent:UA


	●
close:
closed::::close 済み
open:
closing:
	~closeするための
opening:
	~openするための
ping:
pong:
opcode:

clean:
body::::ボディ
接続:connection::~
接続-:connect::~
	接続-先
開始-:start::~
開始済み:started::~
事由:reason::~
拡張:extensions:~
確立-:establish:~
確立済み:established:~
secure::::セキュア
data::::データ
text::::テキスト
折衝:negotiation::~
network::::ネットワーク
検証-:verify:~
解決-:resolve:~
byte::::バイト
binary::::バイナリ
handshake::::ハンドシェイク
framing::::フレーミング
frame::::フレーム
下位protocol:subprotocol:::下位プロトコル
protocol::::プロトコル
payload::::ペイロード
header::::ヘッダ
message::::メッセージ
redirector::::リダイレクタ
redirect::::リダイレクト
local::::ローカル
buffer::::バッファ
buffering::::バッファリング
packet::::パケット
route:

	要請:request::~::リクエスト
応答:response::~::レスポンス
失敗-:fail:~
失敗:failure:~
種別:type:~
受信:receive:~
証明書:certificate:~
状態探針:status probing:~
生成元:origin::~::オリジン
送信:send:~
代理送信:proxying:~
解析済:parsed:解析済み
接続維持:keep-alive:~
伝送:transmit:~
中止-:abort:~
転送-:transmit:~
状態:state:~
成功裡:successful:~
双方向:bidirectional:~
通信:communication:~
通信-:communicate:~
遅延計測:latency instrumentation:~
遅延測定:latency metric:~

	●
call:
error::::エラー
entry::::エントリ

走らす:run する:走らせる
走らせ:run し:~
呼出-:invoke:呼び出
呼出す:invoke する:呼び出す


client::::クライアント
server::::サーバ
status::::ステータス
素片:fragment::~::フラグメント
port::::ポート
host::::ホスト
scheme::::スキーム
overhead::::オーバーヘッド
	キーワード:
	クラス:
access::::アクセス
app:application:::アプリ
algo:algorithm:::アルゴリズム
support::::サポート
model::::モデル


trusted:
event::::イベント
単純:simple:~
handler::::ハンドラ
listener::::リスナ
event-loop:event loop:::イベントループ
源:source::~::ソース
task::::タスク
queue::::待ち行列
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ
待入し:queue し::待ち行列に入れ::キューし
待行列:queue::待ち行列::キュー
配送-:dispatch:~
発火-:fire:~
浮上-:bubble:~
取消可能:cancelable:~
取消不可:cancelable でない:~
既定動作:default action:~


設定群:settings::~
internet::::インターネット
interface::::インタフェース
Web::::ウェブ
browser::::ブラウザ
obj:object:::オブジェクト
option::::オプション
garbage-collection:garbage collection:::ガベージコレクション
garbage-collect:garbage collect:::ガベージコレクト
code::::コード
構築子:constructor::~::コンストラクタ
script::::スクリプト
背後:background:~
停滞-:stall:~
被呼出時:被 invoke 時:~
被取得時:被 get 時:~
被設定時:被 set 時:~
設定-:set:~
再設定-:reset:~

遂行-:perform:~
実行-:execute:~
実行:execution:~

spool::::スプール
zero::::ゼロ
検査-:check:~
disk::::ディスク
hardware::::ハードウェア
	ヒント:hint

feedback::::フィードバック
process::::プロセス
mapping::::マッピング
flag::::フラグ

main-thread:main thread:::メインスレッド
method::::メソッド
memory::::メモリ
list::::リスト
公開-:expose:~

構文解析器:parser::~::パーサ
直列化器:serializer::~::シリアライザ
直列化-:serialize::~::シリアライズ
符号化-:encode::~::エンコード
復号-:decode::~::デコード

新たな:new:~
初期化-:initialise:~
初期化時:initialise 時:~
	※initialize:~
初期時:initial 時:~
未請求の:unsolicited:請求されていない

投出:throw:~
属性:attribute:~
値:value:~
配列:array:~
引数:argument:~
例外:exception:~

文書:document:~
作成:create:~
作成時:create 時:~
表現-:represent:~
攻撃:attack:~

情報:information:~
整数:integer:~
登録-:register:~
等価:equivalent:~
到着時:arrive 時:~
保護-:protect:~
保護:protection:~
正しい:correct に:~
正しく:correct に:~
保持-:keep:~
格納-:store:~
要素:element:~
完了-:complete:~

拒否:refuse:~
空:empty:~
型:type:~
形式:form:~
軽減-:mitigate:~
消滅-:disappear:~
安全:safe:~
維持-:maintain:~
調査-:probe:~
共有-:share:~
検知-:detect:~
変換-:convert:~
変更-:change:~
満杯:full:~
不能化-:disable:~
可能化-:enable:~
付加-:append:~
名前:name:~
名:name:~
更新:updates:~
構成-:comprise:~
合致-:match:~
繊細:subtle:~
選択-:select:~
省略-:omit:~
頻度:rate:~
並列的:parallel:~
下層の:underlying:~
鼓動:heart-beats:単方向の鼓動

判別-:distinguish:~
監視-:monitor:~
手続き:steps:~
段:step:~
継続-:continue:~
現在の:current:~
生の:raw:~
特定0の:particular:ある特定の
表示-:display:~
問題:problem:~
突如:abruptly:~
成功裡:successful:~
競合:race condition:~

	●
仕様:spec:~
指示-:indicate:~
指定-:specify:~
推奨-:recommend:~
制限:limit:~
制御:control:~
制約-:constrain:~
要件:requirements:~
利用者:user:~
適合性:conformance:~
作者:author:~
文字:character:~
内容:content:~
文字列:string:~
文脈:context:~
小文字化-:lowercase 化:~
効率的:efficient:~
意味論:semantics:~
実装-:implement:~
立脚-:rely:~
理由:reason:~
概念:concept:~
許容-:allow:~
適切:appropriate:~
適用-:apply:~
基礎的:fundamental:~
経験則:heuristics:~
定義-:define:~
定義:definition:~
導入-:introduce:~
導入:introduction:~
独自:custom:~
意味-:mean:~
	要求-:require:~
	支援目的:aid
	消失-:go away
側面:aspect:~
重要:important:~
切替えた:switch した:切り替えた

	二番目の:second:~
	最初の:first:~
</script>
<!-- 他
在る:
処理:
起因:incurred by
結果:
現時点:currently
後者:
後述:
最終的:eventually
最後:
最初:
参照:
時点:
自体:
数値:number
注意:
注記:
直前:
~~通常:
任意:
必要:
利用:
利用中:in use
時機

 -->

<!--%style -->
<style type="text/css">
</style>

</head>
<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>HTML Standard — WebSocket 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Communication</a>
章の一部である
<a href="https://html.spec.whatwg.org/multipage/comms.html#network">Web sockets</a>
節を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2016-07-06</time>,
（公開：<time>2012-06-14</time> （ <a href="https://www.w3.org/TR/websockets/">W3C 版</a> として））
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>
	<hgroup>
<h1 title="The WebSocket API">WebSocket</h1>
<h2>HTML Living Standard — 最終更新 2016 年 7 月 5 日</h2>
	</hgroup>
</header>


<nav class="toc" id="toc">
<h2>目次</h2>
<ol id="_toc_list0"></ol></nav>


<hr>

<main id="MAIN" style="display:none;">

<!-- ＊
9.1 The MessageEvent interfaces
9.2 Server-sent events
 -->

	<section id="network">
<h2 title="Web sockets">9.3. Web sockets</h2>

		<section id="network-intro">
<h3 title="Introduction">9.3.1. 序論</h3>

~INFORMATIVE

<p>
この仕様は、~Web~appが~server側~processとの双方向~通信を可能化するための,
`WebSocket$I ~interfaceを導入する。 
◎
To enable Web applications to maintain bidirectional communications with server-side processes, this specification introduces the WebSocket interface.
</p>

<p class="note">注記：
この~interfaceは、下層の~networkへの生の~accessを許容するものではない。
例えば，独自~serverを介した~messageの代理送信を用いない限り、この~interfaceを IRC ~clientの実装に利用することはできない。
◎
This interface does not allow for raw access to the underlying network. For example, this interface could not be used to implement an IRC client without proxying messages through a custom server.
</p>

		</section>
		<section id="_conventions">
<h3 class="trans-note">【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
以下の用語は、 ~WebSocket~protocol仕様 `WSP$r にて定義される（この訳では、日本語訳への直接リンクを “参照” として与える）：
</p>

<ul><li>`~status~code@ws（<a href="~RFC6455#section-7.4">参照</a>）（ HTTP 応答~status~codeではないことに注意）
</li><li>~WebSocket接続は`確立され@wsた（<a href="~RFC6455#dfn-established">参照</a>）
</li><li>`~WebSocket~messageを送信する@ws（<a href="~RFC6455#dfn-to-send">参照</a>）
</li><li>`~WebSocket~messageを受信した@ws（<a href="~RFC6455#dfn-received">参照</a>）
</li><li>`~WebSocket接続を失敗させる@ws（<a href="~RFC6455#dfn-to-fail">参照</a>）
</li><li>`~WebSocket接続を~closeする@ws（<a href="~RFC6455#dfn-to-close">参照</a>）
</li><li>`~WebSocket~closing~handshakeを開始する@ws（<a href="~RFC6455#dfn-to-start-closing-handshake">参照</a>）
</li><li>`~WebSocket~closing~handshakeは開始され@wsた（<a href="~RFC6455#dfn-closing-handshake-started">参照</a>）
</li><li>~WebSocket接続は`~closeされ@wsた（<a href="~RFC6455#dfn-closed">参照</a>）
</li><li>`~cleanに~closeされた@ws（<a href="~RFC6455#dfn-closed-cleanly">参照</a>）
</li><li>`~WebSocket接続~close~code@ws（<a href="~RFC6455#dfn-close-code">参照</a>）
</li><li>`~WebSocket接続~close事由@ws（<a href="~RFC6455#dfn-close-reason">参照</a>）
</li><li>`下位protocol@ws（<a href="~RFC6455#section-1.9">参照</a>）
</li><li>`下位protocol名@ws（<a href="~RFC6455#section-11.5">参照</a>）
</li><li>`利用中の下位protocol@ws（<a href="~RFC6455#dfn-subprotocol-in-use">参照</a>）
</li><li>`利用中の拡張@ws（<a href="~RFC6455#dfn-extensions-in-use">参照</a>）
</li><li>`Sec-WebSocket-Protocol@h ~header（<a href="~RFC6455#section-11.3.4">参照</a>）
</li><li>`Close ~frame@ws（<a href="~RFC6455#section-5.5.1">参照</a>）
</li><li>`Ping ~frame@ws（<a href="~RFC6455#section-5.5.2">参照</a>）
</li><li>`Pong ~frame@ws（<a href="~RFC6455#section-5.5.3">参照</a>）
</li><li>`~opcode@ws（<a href="~RFC6455#data-opcode">参照</a>）
</li><li>`~payload~data@ws（<a href="~RFC6455#data-Payload">参照</a>）
</li><li>`~text~data@ws（<a href="~RFC6455#data-Text">参照</a>）
</li><li>`~binary~data@ws（<a href="~RFC6455#data-Binary">参照</a>）
</li><li>`~frame種別@ws（<a href="~RFC6455#frame-type">参照</a>）
</li></ul>

		</section>
		<section id="the-websocket-interface">

<h3 title="The WebSocket interface">9.3.2. `WebSocket^I ~interface</h3>

<pre class="idl">
enum `BinaryType@I { `blob^l, `arraybuffer^l };
[<a href="#dom-websocket">Constructor</a>(
    USVString %url,
    optional (DOMString or sequence&lt;DOMString&gt;) %protocols = []
), Exposed=(Window,Worker)]

interface `WebSocket@I : `EventTarget$I {
  readonly attribute USVString `url$m;

  // ready state
  const unsigned short `CONNECTING$m = 0;
  const unsigned short `OPEN$m = 1;
  const unsigned short `CLOSING$m = 2;
  const unsigned short `CLOSED$m = 3;
  readonly attribute unsigned short `readyState$m;
  readonly attribute unsigned long long `bufferedAmount$m;

  // networking
           attribute `EventHandler$I `onopen$m;
           attribute `EventHandler$I `onerror$m;
           attribute `EventHandler$I `onclose$m;
  readonly attribute DOMString `extensions$m;
  readonly attribute DOMString `protocol$m;
  void `close$m([Clamp] optional unsigned short %code, optional `USVString$I %reason);

  // messaging
           attribute `EventHandler$I `onmessage$m;
           attribute `BinaryType$I `binaryType$m;
  void `send$m(`USVString$I %data);
  void `send$m(`Blob$I %data);
  void `send$m(`ArrayBuffer$I %data);
  void `send$m(`ArrayBufferView$I %data);
};</pre>


<p>
各 `WebSocket$I ~objには、
`~url@
（`~URL~record$）が結付けられる
◎
Each WebSocket object has an associated url (a URL record).
</p>

<dl class="idl-def">
	<dt>`WebSocket(url, protocols)@m</dt>
	<dd>
構築子の最初の引数 %url は、接続-先の`~URL$を指定する。
二番目の引数 %protocols （省略可）は、文字列, または 文字列の配列をとる。
%protocols 引数は、［
省略-時は空の配列 ／
文字列ならば，その文字列のみからなる配列
］に等価になる。
配列~内の各 文字列は`下位protocol名$wsを表す。
接続が`確立され$wsるのは、~serverが，これらの`下位protocol$wsの一つを応答に選択して返したときに限られることになる。
どの下位protocol名も、~WebSocket~protocol仕様による定義に従って，
`Sec-WebSocket-Protocol$h ~header値を構成する一連の~protocol要素に課される要件に合致し~MUST。
◎
The WebSocket(url, protocols) constructor takes one or two arguments. The first argument, url, specifies the URL to which to connect. The second, protocols, if present, is either a string or an array of strings. If it is a string, it is equivalent to an array consisting of just that string; if it is omitted, it is equivalent to the empty array. Each string in the array is a subprotocol name. The connection will only be established if the server reports that it has selected one of these subprotocols. The subprotocol names must all be strings that match the requirements for elements that comprise the value of Sec-WebSocket-Protocol fields as defined by the WebSocket protocol specification. [WSP]
</dd>
	<dd>
<p>
この構築子の被呼出時には、次の手続きを走らせ~MUST： 
◎
The WebSocket(url, protocols) constructor, when invoked, must run these steps:
</p>

		<ol>
			<li>
%~url~record ~LET %url を`~URL構文解析器$にかけた結果
◎
Let urlRecord be the result of applying the URL parser to url.
</li>
			<li>
~IF［
%~url~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError^E
◎
If urlRecord is failure, then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%~url~record の`~scheme$ ~NIN { `ws^l, `wss^l}
］
⇒
~THROW `SyntaxError^E
◎
If urlRecord's scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%~url~record の`素片$ ~NEQ ~NULL
］
⇒
~THROW `SyntaxError^E
◎
If urlRecord's fragment is non-null, then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%protocols は文字列である
］
⇒
%protocols ~SET その文字列 1 個からなる配列
◎
If protocols is a string, set protocols to a sequence consisting of just that string.
</li>
			<li>
~IF［
%protocols 内に重複する値がある
］~OR［
%protocols 内の値に，［
~WebSocket~protocol仕様の定義による
`Sec-WebSocket-Protocol$h ~header値を構成する~protocol要素に課される要件
］を満たさないものがある
］
⇒
~THROW `SyntaxError^E
◎
If any of the values in protocols occur more than once or otherwise fail to match the requirements for elements that comprise the value of Sec-WebSocket-Protocol fields as defined by the WebSocket protocol specification, then throw a "SyntaxError" DOMException and abort these steps. [WSP]
</li>
			<li>
~RET ［
`~url$ ~SET %~url~record
］にされた，新たな `WebSocket$I ~obj
— ただし、この手続きは`並列的$に継続する
◎
Return a new WebSocket object whose url is urlRecord, but continue these steps in parallel.
</li>
			<li>
<p>
( %~url~record, %protocols, `~entry設定群~obj$ )
を与える下で、`~WebSocket接続を確立する$
`FETCH$r
◎
Establish a WebSocket connection given urlRecord, protocols, and the entry settings object. [FETCH]
</p>

<p class="note">注記：
`~WebSocket接続を確立する$のに失敗した場合
⇒
それにより，`~WebSocket接続を失敗させる$ws~algoが誘発され
⇒
それにより，`~WebSocket接続を~closeする$ws~algoが呼出され
⇒
それにより，~WebSocket接続は`~closed$wsにされ
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
If the establish a WebSocket connection algorithm fails, it triggers the fail the WebSocket connection algorithm, which then invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.
</p>
			</li>
		</ol>
	</dd>

	<dt>`url@m</dt>
	<dd>
被取得時には、この `WebSocket$I ~objの`~url$を`~URL直列化器$にかけた結果を返さ~MUST。
◎
The url attribute's getter must return this WebSocket object's url, serialised.
</dd>

	<dt>`readyState@m</dt>
	<dd>
<p>
この属性は、接続の状態を表し、次の値をとり得る： 
◎
The readyState attribute represents the state of the connection. It can have the following values:
</p>


		<dl>
			<dt>`CONNECTING@m （数値 0 ）</dt>
			<dd>
接続はまだ`確立済み$wsでない。
◎
The connection has not yet been established.
</dd>

			<dt>`OPEN@m （数値 1 ）</dt>
			<dd>
~WebSocket接続は`確立済み$wsで，通信は可能である。
◎
The WebSocket connection is established and communication is possible.
</dd>

			<dt>`CLOSING@m （数値 2 ）</dt>
			<dd>
接続は~handshakeの~close中にあるか、または
`close()$m ~methodが呼出されている。
◎
The connection is going through the closing handshake, or the close() method has been invoked.
</dd>

			<dt>`CLOSED@m （数値 3 ）</dt>
			<dd>
接続はすでに`~closeされ$wsたか, または~openできなかった。
◎
The connection has been closed or could not be opened.
</dd>
		</dl>
	</dd>
	<dd>
~objの作成時には、この属性は `CONNECTING$m に設定され~MUST。
◎
When the object is created its readyState must be set to CONNECTING (0).
</dd>

	<dt>`extensions@m</dt>
	<dd>
この属性は、初期時には空~文字列を返さ~MUST。
その値は、~WebSocket接続が`確立され$wsた後に，
<a href="#feedback-from-the-protocol">~protocolからの~feedback節</a>
にて定義されるように，変更され得る。
◎
The extensions attribute must initially return the empty string. After the WebSocket connection is established, its value might change, as defined below.
</dd>
	<dd class="note">注記：
この属性は、~serverにより選択された拡張があれば，それを返す。
◎
The extensions attribute returns the extensions selected by the server, if any.
</dd>

	<dt>`protocol@m</dt>
	<dd>
この属性は、初期時には空~文字列を返さ~MUST。
その値は、~WebSocket接続が`確立され$wsた後に，
<a href="#feedback-from-the-protocol">~protocolからの~feedback節</a>
にて定義されるように，変更され得る。
◎
The protocol attribute must initially return the empty string. After the WebSocket connection is established, its value might change, as defined below.
</dd>
	<dd class="note">注記：
`protocol$m
属性は、~serverにより選択された`下位protocol$wsを（もしあれば）返す。
これは、下位protocolの折衝を遂行するために，構築子の（配列の形にされた）二番目の引数に伴って利用され得るものになる。
◎
The protocol attribute returns the subprotocol selected by the server, if any. It can be used in conjunction with the array form of the constructor's second argument to perform subprotocol negotiation.
</dd>

	<dt>`close(code, reason)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The close(code, reason) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
%code は与えられている
］~AND［
%code ~NIN { 1000, 3000 ～ 4999 }
］
⇒
~THROW `InvalidAccessError^E
◎
If code is present, but is neither an integer equal to 1000 nor an integer in the range 3000 to 4999, inclusive, throw an "InvalidAccessError" DOMException.
</li>
			<li>
<p>
~IF［
%reason は与えられている
］：
◎
If reason is present, then run these substeps:
</p>

				<ol>
					<li>
%reason ~LET %reason を`UTF-8 符号化-$した結果
◎
Let reasonBytes be the result of encoding reason.
</li>
					<li>
~IF［
%reason は 123 ~byteを超える
］
⇒
~THROW `SyntaxError^E
◎
If reasonBytes is longer than 123 bytes, then throw a "SyntaxError" DOMException.
</li>
				</ol>
			</li>
			<li>
<p>
以下の項目のうち，最初に該当する段を走らす：
◎
Run the first matching steps from the following list:
</p>

<dl class="switch">
	<dt>
`readyState$m ~IN { `CLOSING$m, `CLOSED$m }
の場合：
◎
If the readyState attribute is in the CLOSING (2) or CLOSED (3) state
</dt>

	<dd>
何もしない。
◎
Do nothing.
</dd>
	<dd class="note">注記：
接続は、~closeしつつあるか, すでに~closedである。
~closedでない場合、最終的には，`後述のように$ `close$et ~eventが発火されることになる。
◎
The connection is already closing or is already closed. If it has not already, a close event will eventually fire as described below.
</dd>

	<dt>
~WebSocket接続は まだ`確立済み$wsでない場合：
◎
If the WebSocket connection is not yet established [WSP]
</dt>
	<dd>
`~WebSocket接続を失敗させる$ws；<br />
`readyState$m 属性~値 ~SET `CLOSING$m
◎
Fail the WebSocket connection and set the readyState attribute's value to CLOSING (2). [WSP]
</dd>
	<dd class="note">注記：
`~WebSocket接続を失敗させる$ws~algoは
⇒
`~WebSocket接続を~closeする$ws~algoを呼出す
⇒
それにより，~WebSocket接続は~closedになる
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
The fail the WebSocket connection algorithm invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.
</dd>
	<dt>
まだ `~WebSocket~closing~handshakeは開始され$wsていない場合
◎
If the WebSocket closing handshake has not yet been started [WSP]
</dt>
	<dd>
<p>
`~WebSocket~closing~handshakeを開始する$ws：
◎
Start the WebSocket closing handshake and set the readyState attribute's value to CLOSING (2). [WSP]
</p>

		<ul>
			<li>
<p>
%code, %reason いずれの引数も与えられていない場合、
`Close ~message$wsは，~bodyを持っては~MUST_NOT。
◎
If neither code nor reason is present, the WebSocket Close message must not have a body.
</p>

<p class="note">
~WebSocket~protocol仕様は、`~WebSocket~closing~handshakeを開始する$ws~algoに~status~codeが要求されるものと，誤って定めている。
◎
The WebSocket Protocol specification erroneously states that the status code is required for the start the WebSocket closing handshake algorithm.
</p>
			</li>
			<li>
%code 引数が与えられている場合：
`Close ~message$wsに利用する`~status~code$wsは、その引数に与えられた整数にし~MUST。
◎
If code is present, then the status code to use in the WebSocket Close message must be the integer given by close. [WSP]
</li>
			<li>
%reason 引数も与えられている場合：
`Close ~message$wsには，`~status~code$wsに加えて %reason も供され~MUST。
◎
If reason is also present, then reasonBytes must be provided in the Close message after the status code. [WSP]
</li>

		</ul>
	</dd>
	<dd>
`readyState$m 属性~値 ~SET `CLOSING$m
◎
↑</dd>
	<dd class="note">注記：
`~WebSocket~closing~handshakeを開始する$ws~algoは
⇒
最終的には`~WebSocket接続を~closeする$ws~algoを呼出すことになる
⇒
それにより、~WebSocket接続は`~closed$wsになる
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
The start the WebSocket closing handshake algorithm eventually invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.
</dd>

	<dt>他の場合
◎
Otherwise
</dt>

	<dd>
`readyState$m 属性~値 ~SET `CLOSING$m
◎
Set the readyState attribute's value to CLOSING (2).
</dd>
	<dd class="note">注記：
`~WebSocket~closing~handshakeは開始され$wsており
⇒
最終的には`~WebSocket接続を~closeする$ws~algoを呼出すことになる
⇒
それにより~WebSocket接続は`~closed$wsになる
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
The WebSocket closing handshake is started, and will eventually invoke the close the WebSocket connection algorithm, which will establish that the WebSocket connection is closed, and thus the close event will fire, as described below.
</dd>
</dl>
			</li>
		</ol>

	</dd>
	<dd class="note">注記：
`close()$m ~methodは、`~WebSocket~closing~handshakeを開始する$ws以前に送信した~messageを破棄するものではない
— 仮に，~UAがそのような~messageをまだ送信-中であったとしても、~handshakeは，その~messageが送信された後にのみ開始されることになる。
◎
The close() method does not discard previously sent messages before starting the WebSocket closing handshake — even if, in practice, the user agent is still busy sending those messages, the handshake will only start after the messages are sent.
</dd>

	<dt>`bufferedAmount@m</dt>
	<dd>
この属性は、 `send()$m により待入されているが，`~event-loop$がその`最初の段$†に最後に到達した時点では，~networkにまだ伝送されていない、~app~data（UTF-8 `~text~data$wsか, または`~binary~data$ws）の~byte数を返さ~MUST。
（したがって これは、現在の~taskの実行-中に伝送された~textを含む
— ~UAが~script実行と`並列的$に，背後で~textを転送できるかどうかにかかわらず。）
これには、~protocolに起因する~framingの~overheadや, OS や~network~hardwareによる~bufferingは含まれない。
接続が`~closeされ$wsている場合、この属性の値は
`send()$m ~methodが~callされる度に増えることになる（この数値は、接続が`~closeされ$wsても~zeroに再設定されない）。 
◎
The bufferedAmount attribute must return the number of bytes of application data (UTF-8 text and binary data) that have been queued using send() but that, as of the last time the event loop reached step 1, had not yet been transmitted to the network. (This thus includes any text sent during the execution of the current task, regardless of whether the user agent is able to transmit text in the background in parallel with script execution.) This does not include framing overhead incurred by the protocol, or buffering done by the operating system or network hardware. If the connection is closed, this attribute's value will only increase with each call to the send() method (the number does not reset to zero once the connection closes).
</dd>
	<dd class="trans-note" id="step-1">【
“最初の段（ step 1 ）” ：
`~event-loopの処理~model$に示されている手続きの，最初の段と見られる。
】</dd>
	<dd class="example">
<p>
次の簡単な例では、 `bufferedAmount$m 属性を用いて、毎 50ms ごとに一回の頻度で（あるいは~network~~処理が追いつかない場合は追いつける頻度で）更新を送信させる。
◎
In this simple example, the bufferedAmount attribute is used to ensure that updates are sent either at the rate of one update every 50ms, if the network can handle that rate, or at whatever rate the network can handle, if that is too fast.
</p>

<pre>
var %socket = new WebSocket('ws://game.example.com:12010/updates');
%socket.onopen = function () {
  setInterval(function() {
    if (%socket.bufferedAmount == 0) {
      %socket.send(getUpdateData());
    }
  }, 50);
};</pre>
<p>
`bufferedAmount$m 属性の利用により、~networkが追いつかない頻度で~dataを送信しなくとも，~networkを使い切れるようになる（その属性の値を常時より注意して監視する必要はあるが）。
◎
The bufferedAmount attribute can also be used to saturate the network without sending the data at a higher rate than the network can handle, though this requires more careful monitoring of the value of the attribute over time.
</p>
	</dd>

	<dt>`binaryType@m</dt>
	<dd>
この属性は、 `WebSocket$I ~objの作成時には、文字列 `blob^l に設定され~MUST。
被取得時には、最後に設定された値を返さ~MUST。
被設定時には、新たな値をこの属性に設定し~MUST。
◎
When a WebSocket object is created, its binaryType IDL attribute must be set to the string "blob". On getting, it must return the last value it was set to. On setting, the user agent must set the IDL attribute to the new value.
</dd>
	<dd class="note">注記：
この属性は、~binary~dataの~scriptへの公開され方を，作者が制御できるようにする。
この属性を `blob^l にした場合，~binary~dataは `Blob$I 形式で返され、
`arraybuffer^l にした場合，`ArrayBuffer$I 形式で返される。
~UAは、受信される~binary~dataの扱い方のヒントに，これを用いることができる：
この属性が `blob^l にされている場合、~dataは~diskへ安全に~spoolするに適するものになる。
`arraybuffer^l にされている場合、より効率的に~memory内に保持するに適するものになる。
もちろん，~UAには、受信された~dataを~memory内に保持するかどうかの決定に，より繊細な経験則を用いることが推奨される：
例えば、~data量，あるいは
直前における, ~scriptによるこの属性に対する変更の頻度を基準にするなど。
この後者の側面は特に重要になる。
何故なら、~UAが~dataを受信した後, かつ それに対する~eventを発火する前に、この属性が変更される可能性も少なからずあるので。 
◎
This attribute allows authors to control how binary data is exposed to scripts. By setting the attribute to "blob", binary data is returned in Blob form; by setting it to "arraybuffer", it is returned in ArrayBuffer form. User agents can use this as a hint for how to handle incoming binary data: if the attribute is set to "blob", it is safe to spool it to disk, and if it is set to "arraybuffer", it is likely more efficient to keep the data in memory. Naturally, user agents are encouraged to use more subtle heuristics to decide whether to keep incoming data in memory or not, e.g. based on how big the data is or how common it is for a script to change the attribute at the last minute. This latter aspect is important in particular because it is quite possible for the attribute to be changed after the user agent has received the data but before the user agent has fired the event for it.
</dd>

	<dt>`send(data)@m</dt>
	<dd>
<p>
この~methodは、接続を用いて~dataを伝送する。
被呼出時には、次の手続きを走らせ~MUST：
<!-- 他の場合、~UAは，次の~listの中から適切な手続きを走らせ~MUST： -->
◎
The send(data) method transmits data using the connection. If the readyState attribute is CONNECTING, it must throw an "InvalidStateError" DOMException. Otherwise, the user agent must run the appropriate set of steps from the following list:
</p>

		<ol>
			<li>
~IF［
`readyState$m 属性 ~EQ `CONNECTING$m
］
⇒
~THROW `InvalidStateError^E
◎
↑</li>
			<li>
<p>
~IF［
~WebSocket接続は`確立済み$wsである
］~AND［
まだ `~WebSocket~closing~handshakeは開始され$wsていない
<span class="trans-note">【
すなわち `readyState$m 属性は `OPEN$m
】</span>
］
⇒
%data 引数の型に応じて，下の表に与えられる［
`~opcode$ws, および`~payload~data$ws
］から構成される`~WebSocket~messageを送信する$ws
— ~bufferを要する所で~bufferが満杯になっているなどの理由で，~dataを送信できない場合、この接続の`満杯~flag$を ON にした上で， `~WebSocket接続を~closeする$ws。
◎
↓</p>

<table><thead><tr><th>引数の型
</th><th>`~opcode$ws
</th><th>`~payload~data$ws
</th></tr></thead>

<tbody><tr><th><code>DOMString</code>
◎
If the argument is a string
</th><td>~text~frame（数値 1 ）
</td><td>
%data を `UTF-8 符号化-$した結果。
`UNICODE$r
`ENCODING$r
◎
If the WebSocket connection is established and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of the data argument using a text frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. Any invocation of this method with a string argument that does not throw an exception must increase the bufferedAmount attribute by the number of bytes needed to express the argument as UTF-8. [UNICODE] [ENCODING] [WSP]
</td></tr>

<tr><th>`Blob$I
◎
If the argument is a Blob object
</th><td rowspan="3">~binary~frame（数値 2 ）
</td><td>
%data が表現する生~data。
`FILEAPI$r
◎
If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the raw data represented by the Blob object. Any invocation of this method with a Blob argument that does not throw an exception must increase the bufferedAmount attribute by the size of the Blob object's raw data, in bytes. [WSP] [FILEAPI]
</td></tr>

<tr><th>`ArrayBuffer$I
◎
If the argument is an ArrayBuffer object
</th><td>
%data が表現する~bufferに格納されている~data。
◎
If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the data stored in the buffer described by the ArrayBuffer object. Any invocation of this method with an ArrayBuffer argument that does not throw an exception must increase the bufferedAmount attribute by the length of the ArrayBuffer in bytes. [WSP]
</td></tr>

<tr><th>`ArrayBufferView$I
◎
If the argument is an object that matches the ArrayBufferView type definition
</th><td>
%data が参照している，下層の `ArrayBuffer$I ~objが格納する~bufferの中の一区分。
◎
If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the data stored in the section of the buffer described by the ArrayBuffer object that data references. Any invocation of this method with this kind of argument that does not throw an exception must increase the bufferedAmount attribute by the length of data's buffer in bytes. [WSP]
</td></tr></tbody></table>

<p class="trans-note">【
ここの訳は、原文の同じ文言の繰り返しを集約して再構成している。
】</p>

</li>
			<li>
この~methodの被呼出時に，例外を投出しない場合は、`~payload~data$wsに要する~byte数だけ `bufferedAmount$m 属性を増やす
<!-- 
最後の文については、
`readyState$m
属性が
`CLOSING$m,
`CLOSED$m
の場合にも，適用されることになる？
 -->
◎
↑
</li>
		</ol>
	</dd>
</dl>


<p>
`WebSocket$I ~interfaceを実装する~objは、次の表に与える［
`~event~handler$, および
対応する `~event~handler~event型$
］を，`~event~handler IDL 属性$として~supportし~MUST ：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the WebSocket interface:
</p>

<table><thead><tr><th>`~event~handler$
</th><th>`~event~handler~event型$
</th></tr></thead>

<tbody><tr><td>`onopen@m
</td><td>`open@et（<a href="~HTML-IND#event-open">参照</a>）

</td></tr><tr><td>`onmessage@m
</td><td>`message@et（<a href="~HTML-IND#event-message">参照</a>）

</td></tr><tr><td>`onerror@m
</td><td>`error@et（<a href="~HTML-IND#event-error">参照</a>）

</td></tr><tr><td>`onclose@m
</td><td>`close@et（<a href="~HTML-IND#event-close">参照</a>）

</td></tr></tbody></table>

		</section>
		<section id="feedback-from-the-protocol">
<h3 title="Feedback from the protocol">9.3.3. ~protocolからの~feedback</h3>

<p>
~UAは、~WebSocket接続が`確立され$wsたときは，次の手続きを走らす~taskを`待入し$~MUST：
◎
When the WebSocket connection is established, the user agent must queue a task to run these steps:
</p>


<ol>
	<li>
`readyState$m 属性~値 ~SET `OPEN$m
◎
Change the readyState attribute's value to OPEN (1).
</li>
	<li>
~IF［
`利用中の拡張$ws ~NEQ ~NULL 値
］
⇒
`extensions$m 属性~値 ~SET その値
◎
Change the extensions attribute's value to the extensions in use, if is not the null value. [WSP]
</li>
	<li>
~IF［
`利用中の下位protocol$ws ~NEQ ~NULL 値
］
⇒
`protocol$m 属性~値 ~SET その値
◎
Change the protocol attribute's value to the subprotocol in use, if is not the null value. [WSP]
</li>
	<li>
`WebSocket$I ~objに向けて，名前 `open$et の`単純~eventを発火する$
◎
Fire a simple event named open at the WebSocket object.
</li>
</ol>

<p class="note">注記：
上の~algoは、~taskとして`待入され$るので、`確立され$wsている~WebSocket接続と,
`open$et ~eventのために~event~listenerを設定しておく~scriptとの間で競合が生じることはない。
<span class="trans-note">【
すなわち、 `WebSocket()$m を呼出した<em>後に</em> 同期的に登録された~event~listenerが，~serverからの初期~messageを受け取り損ねることはない。
】</span>
◎
Since the algorithm above is queued as a task, there is no race condition between the WebSocket connection being established and the script setting up an event listener for the open event.
</p>


<hr>

<p>
~UAは、［
`~frame種別$ws %type の~data %data
］を伴う，`~WebSocket~messageを受信した$wsときは、次の手続きを走らす~taskを`待入し$~MUST：
◎
When a WebSocket message has been received with type type and data data, the user agent must queue a task to follow these steps: [WSP]
</p>

<ol>
	<li>
~IF［
`readyState$m 属性~値 ~NEQ `OPEN$m
］
⇒
~RET
◎
If the readyState attribute's value is not OPEN (1), then abort these steps.
</li>

	<li>
<p >
%event ~LET 次のようにされた新たな~event
</p>

<ul><li>`MessageEvent$I ~interfaceを利用する
</li><li>~event名 `message$et
</li><li>`~trusted$である
</li><li>浮上しない
</li><li>取消不可
</li><li>既定動作なし
</li></ul>

◎
Let event be a newly created trusted event that uses the MessageEvent interface, with the event type message, which does not bubble, is not cancelable, and has no default action. [HTML]
</li>
	<li>
<p>
%event の各種~属性は、次のように初期化する：
◎
↓</p>
		<ul>
			<li>
`origin^m 属性 ~SET ［
`WebSocket$I ~objの構築子に渡された`~URL$の`生成元$
］を `Unicode 直列化-$した結果
］
◎
Initialize event's origin attribute to the Unicode serialisation of the origin of the URL that was passed to the WebSocket object's constructor.
</li>
			<li>
<p>
`data^m 属性 ~SET %type が指示する~dataの種別に応じて、次で与えられる値：
</p>

<dl class="switch">
	<dt>`Text^i</dt>
	<dd>
%data
</dd>

	<dt>`Binary^i</dt>
	<dd>
<p>
`binaryType$m
の値に応じて次で与えられる値：
◎
If type indicates that the data is Text, then initialise event's data attribute to data.
</p>

		<dl class="switch">
			<dt>`blob^l</dt>
			<dd>
生~dataが %data を表現する様な，新たな `Blob$I ~obj。
`FILEAPI$r
◎
If type indicates that the data is Binary, and binaryType is set to "blob", then initialise event's data attribute to a new Blob object that represents data as its raw data. [FILEAPI]
</dd>

			<dt>`arraybuffer^l</dt>
			<dd>
%data を内容とする，新たな `ArrayBuffer$I ~obj。
◎
If type indicates that the data is Binary, and binaryType is set to "arraybuffer", then initialise event's data attribute to a new ArrayBuffer object whose contents are data.
</dd>

		</dl>
	</dd>
</dl>
			</li>
		</ul>
	</li>

	<li>
`WebSocket$I ~objに向けて %event を配送する
◎
Dispatch event at the WebSocket object.
</li>

</ol>

<p class="note">注記：
~UAには、前述の手続きによる~taskを走らす前に，それが効率的に遂行できるかどうか検査しておくことが推奨される。
効率的に遂行できないなら、~bufferを準備している間に，他の`~task待行列$から~taskを取り出す等。<!--  -->
例えば、~dataの到着時には
`binaryType$m
属性が `blob^l に設定されていて,
~UAがすべての~dataを~diskへ~spoolしている状況で、その~messageに対し前述の`~task$を走らす直前に，~scriptが
`binaryType$m
を `arraybuffer^l に切替えた場合、~UAは，~main-threadが停滞しないよう，この`~task$を走らす前に~dataを RAM に戻して,
`ArrayBuffer$I ~objを作成する，などが考えられる。 
◎
User agents are encouraged to check if they can perform the above steps efficiently before they run the task, picking tasks from other task queues while they prepare the buffers if not. For example, if the binaryType attribute was set to "blob" when the data arrived, and the user agent spooled all the data to disk, but just before running the above task for this particular message the script switched binaryType to "arraybuffer", the user agent would want to page the data back to RAM before running this task so as to avoid stalling the main thread while it created the ArrayBuffer object.
</p>

<div class="example">
<p>
~text~frameの場合に
`message$et ~eventのための~handlerを定義する例：
◎
Here is an example of how to define a handler for the message event in the case of text frames:
</p>

<pre>
mysocket.onmessage = function (event) {
  if (event.data == 'on') {
    turnLampOn();
  } else if (event.data == 'off') {
    turnLampOff();
  }
};</pre>

<p>
ここでの~protocolは、~serverが "on" または "off" ~messageを送信するだけの単純なものとする。
◎
The protocol here is a trivial one, with the server just sending "on" or "off" messages.
</p>
</div>

<hr>

<div class="p">
<p>
~UAは、`~WebSocket~closing~handshakeが開始され$wsたときは，次を走らす~taskを`待入し$~MUST：
</p>

<ol>
	<li>
`readyState$m 属性~値 ~SET `CLOSING$m 
</li>
</ol>

<p>
（
`close()$m ~methodが~callされていた場合、
`readyState$m 属性~値は，この~taskを走らす時点で，すでに `CLOSING$m に設定されていることになる。）
</p>

◎
When the WebSocket closing handshake is started, the user agent must queue a task to change the readyState attribute's value to CLOSING (2). (If the close() method was called, the readyState attribute's value will already be set to CLOSING (2) when this task runs.) [WSP]
</div>


<hr>
<p id="closeWebSocket">
~UAは、`~WebSocket接続を~closeする$wsときは（`~cleanに~closeされた$ws場合も含め），次の手続きを走らす~taskを`待入し$~MUST：
◎
When the WebSocket connection is closed, possibly cleanly, the user agent must queue a task to run the following substeps:
</p>


<ol>
	<li>
`readyState$m 属性~値 ~SET `CLOSED$m
◎
Change the readyState attribute's value to CLOSED (3).
</li>

	<li>
~IF［
~UAは`~WebSocket接続を失敗させる$ws必要がある
］~OR［
~WebSocket接続は その
`満杯~flag@
が ON にされた上で`~closeされ$wsた
］
⇒
`WebSocket$I ~objに向けて，名前 `error$et の`単純~eventを発火する$
◎
If the user agent was required to fail the WebSocket connection, or if the the WebSocket connection was closed after being flagged as full, fire a simple event named error at the WebSocket object. [WSP]
</li>

	<li>
<p>
`WebSocket$I ~objに向けて，次のようにされた新たな~eventを配送する：
</p>

<ul><li>`CloseEvent$I ~interfaceを利用する
</li><li>`~trusted$である
</li><li>~event型は `close$et
</li><li>浮上しない
</li><li>既定動作なし
</li><li>~eventの各種~属性は次のように初期化する：
	<ul><li> `wasClean$m 属性 ~SET ［
接続は`~cleanに~closeされた$wsならば ~T ／
~ELSE_ ~F
］
	</li><li>`code$m 属性 ~SET `~WebSocket接続~close~code$ws
	</li><li>`reason$m 属性 ~SET `~WebSocket接続~close事由$wsを `BOM を取扱わずに UTF-8 復号-$した結果
	</li></ul>
</li></ul>

◎
Create a trusted event that uses the CloseEvent interface, with the event type close, which does not bubble, is not cancelable, has no default action, whose wasClean attribute is initialised to true if the connection closed cleanly and false otherwise, whose code attribute is initialised to the WebSocket connection close code, and whose reason attribute is initialised to the result of applying UTF-8 decode without BOM to the WebSocket connection close reason, and dispatch the event at the WebSocket object. [WSP]
</li>

</ol>

<div class="warning">

<p>警告：
~UAは、失敗に際し，次の状況を判別し得るような情報を~script側に伝えてはならない。
◎
User agents must not convey any failure information to scripts in a way that would allow a script to distinguish the following situations:
</p>

<ul>
	<li>
~serverの~host名を解決できなかった。
◎
A server whose host name could not be resolved.
</li>

	<li>
~serverへ~packetを成功裡に~routeできなかった。
◎
A server to which packets could not successfully be routed.
</li>

	<li>
指定された~portへの接続を~serverが拒否した。
◎
A server that refused the connection on the specified port.
</li>

	<li>
~serverとの TLS ~handshakeを正しく遂行できなかった（例えば，~serverの証明書を検証できなかったなど）。
◎
A server that failed to correctly perform a TLS handshake (e.g., the server certificate can't be verified).
</li>

	<li>
~serverが~opening~handshakeを完了しなかった（例えば，~serverが~WebSocket~serverではなかったなど）。
◎
A server that did not complete the opening handshake (e.g. because it was not a WebSocket server).
</li>

	<li>
~WebSocket~serverは正しい~opening~handshakeを送信したが、それが指定する~optionにより，~clientは接続を解除した（例えば~serverは~clientが求めなかった`下位protocol$wsを指定してきたなど）。
◎
A WebSocket server that sent a correct opening handshake, but that specified options that caused the client to drop the connection (e.g. the server specified a subprotocol that the client did not offer).
</li>

	<li>
~WebSocket~serverは~opening~handshakeを成功裡に完了した後に突如，接続を~closeした。
◎
A WebSocket server that abruptly closed the connection after successfully completing the opening handshake.
</li>
</ul>

<p>
これらすべての場合において，
`~WebSocket接続~close~code$wsは、~WebSocket~protocol仕様の要求に従って， 1006 になる。
◎
In all of these cases, the the WebSocket connection close code would be 1006, as required by the WebSocket Protocol specification. [WSP]
</p>

<p>
~scriptがこれらの場合を判別できるようになると、攻撃の前準備として，~scriptに利用者の~local~networkの調査を可能にさせ得ることになる。
◎
Allowing a script to distinguish these cases would allow a script to probe the user's local network in preparation for an
attack.

</p>

<p class="note">注記：
特に，このことは、~code 1015 が~UAからは利用されないことを意味する（もちろん、~serverが `Close ~frame$wsに誤って利用した場合は除く）。
◎
In particular, this means the code 1015 is not used by the user agent (unless the server erroneously uses it in its close frame, of course).

</p>

</div>


<p>
この節において、`待入され$る，すべての`~task$に対する`~task源$は
`~WebSocket~task源@
である。
◎
The task source for all tasks queued in this section is the WebSocket task source.
</p>

		</section>
		<section id="ping-and-pong-frames">

<h3 title="Ping and Pong frames">9.3.4. Ping および Pong ~frame</h3>

<p>
~WebSocket~protocol仕様は、接続維持, 鼓動, ~network状態探針, 遅延計測, 等々に利用し得る、`Ping ~frame$wsおよび `Pong ~frame$wsを定義する。
これらは現時点では API に公開されていない。
◎
The WebSocket protocol specification defines Ping and Pong frames that can be used for keep-alive, heart-beats, network status probing, latency instrumentation, and so forth. These are not currently exposed in the API.
</p>

<p>
~UAは、必要に応じて［
`Ping ~frame$ws ／ 未請求の`Pong ~frame$ws
］を送信してよい（例えば：
~local~network NAT ~mappingを維持する,
接続を検知する,
利用者に遅延測定を表示する，などのために）。
~UAは、これらの~frameを~serverへの支援目的に用いてはならない。
~serverは必要に応じて適切な時機に~pongするものとされているので。
◎
User agents may send ping and unsolicited pong frames as desired, for example in an attempt to maintain local network NAT mappings, to detect failed connections, or to display latency metrics to the user. User agents must not use pings or unsolicited pongs to aid the server; it is assumed that servers will solicit pongs whenever appropriate for the server's needs.
</p>

		</section>
		<section id="the-closeevent-interfaces">

<h3 title="The CloseEvent interface">9.3.5. <code>CloseEvent</code> ~interface</h3>

<pre class="idl">
[Constructor(DOMString %type, optional `CloseEventInit$I %eventInitDict),
Exposed=(Window,Worker)]
interface `CloseEvent@I : `Event$I {
  readonly attribute boolean `wasClean$m;
  readonly attribute unsigned short `code$m;
  readonly attribute USVString `reason$m;
};

dictionary `CloseEventInit@I : `EventInit$I {
  boolean wasClean = false;
  unsigned short code = 0;
  USVString reason = "";
};

</pre>

<dl class="idl-def">
	<dt>`wasClean@m</dt>
	<dd>
この属性は、接続が`~cleanに~closeされた$wsかどうかを表現する。
◎
↓</dd>
	<dd>
被取得時には、初期化時の値を返さ~MUST。
<!-- term-closed-cleanly -->
◎
The wasClean attribute must return the value it was initialised to. It represents whether the connection closed cleanly or not.
</dd>

	<dt>`code@m</dt>
	<dd>
この属性は、~serverから供された `~WebSocket接続~close~code$wsを表現する。
◎
↓</dd>
	<dd>
被取得時には、初期化時の値を返さ~MUST。
◎
The code attribute must return the value it was initialised to. It represents the WebSocket connection close code provided by the server.
</dd>

	<dt>`reason@m</dt>
	<dd>
この属性は、~serverから供された`~WebSocket接続~close事由$wsを表現する。
◎
↓</dd>
	<dd>
被取得時には、初期化時の値を返さ~MUST。
~obj作成時には、この属性は空~文字列に初期化され~MUST。
◎
The reason attribute must return the value it was initialised to. It represents the WebSocket connection close reason provided by the server.
</dd>

</dl>

		</section>
		<section id="garbage-collection">

<h3 title="Garbage collection">9.3.6. ~garbage-collection</h3>


<div >
<p>
`~event-loop$がその`最初の段$に最後に到達した時点で、
`readyState$m
属性が，［
次の表の最初の列の値
］にされていた `WebSocket$I ~objは、［
同じ行の２列目に示される~event型
］に対し登録されている~event~listenerが在る場合には，~garbage-collectされてはならない。
◎
↓</p>


<table>
<thead><tr><th>`readyState$m
</th><th>`~event~handler~event型$
</th></tr></thead>

<tbody><tr><td>`CONNECTING$m (0)
</td><td>`open$et, `message$et, `error$et, `close$et

</td></tr><tr><td>`OPEN$m (1)
</td><td>`message$et, `error$et, `close$et

</td></tr><tr><td>`CLOSING$m (2)
</td><td>`error$et, `close$et

</td></tr></tbody></table>

◎
A WebSocket object whose readyState attribute's value was set to CONNECTING (0) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for open events, message events, error events, or close events.
◎
A WebSocket object whose readyState attribute's value was set to OPEN (1) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for message events, error, or close events.
◎
A WebSocket object whose readyState attribute's value was set to CLOSING (2) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for error or close events.
</div>

<p>
［
接続が`確立済み$wsであり，~network伝送のために~dataが待入されている
］ような `WebSocket$I ~objは、~garbage-collectされてはならない。
◎
A WebSocket object with an established connection that has data queued to be transmitted to the network must not be garbage collected. [WSP]
</p>

<p>
接続が~openしているにもかかわらず， `WebSocket$I ~objが~garbage-collectされた場合、~UAには，`~WebSocket~closing~handshakeを開始する$wsことが要求される。
このときの `Close ~message$wsは、`~status~code$wsを伴わないものとする。
◎
If a WebSocket object is garbage collected while its connection is still open, the user agent must start the WebSocket closing handshake, with no status code for the Close message. [WSP]
</p>

<hr>
<p>
~UAは、 `WebSocket$I ~objを
`消滅させる@
必要が生じた場合には（これは `Document$I ~objが消失した時に起こる）、次のうち最初に該当する手続きを走らせ~MUST：
◎
If a user agent is to make disappear a WebSocket object (this happens when a Document object goes away), the user agent must follow the first appropriate set of steps from the following list:
</p>

<dl class="switch">
	<dt>
~WebSocket接続はまだ`確立済み$wsでない場合
◎
If the WebSocket connection is not yet established [WSP]
</dt>

	<dd>
`~WebSocket接続を失敗させる$ws
◎
Fail the WebSocket connection. [WSP]
</dd>


	<dt>
まだ `~WebSocket~closing~handshakeは開始され$wsていない場合
◎
If the WebSocket closing handshake has not yet been started [WSP]
</dt>
	<dd>
`~WebSocket~closing~handshakeを開始する$ws
— `Close ~message$wsに用いる`~status~code$wsは 1001 とする。
◎
Start the WebSocket closing handshake, with the status code to use in the WebSocket Close message being 1001. [WSP]
</dd>

	<dt>他の場合
◎
Otherwise
</dt>

	<dd>
何もしない。
◎
Do nothing.
</dd>

  </dl>

		</section>
	</section>

</main><!-- id="MAIN" -->

</body></html>

