<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Resource Timing — リソース計時（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'http://www.w3.org/TR/resource-timing/',
//		original_url: 'https://w3c.github.io/resource-timing/',
		spec_status: 'WD',
		main: 'MAIN',
		fill_text_link: '#_versions > dd, #references dd',
		hash_case_modified: 'dfn',
		alt_refs: 'references',
		ref_id_prefix: 'bib-',
//		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	_reorder0(); Util.del_j(); // checked: 151125-WD

	return options;
}

function expand(mapping1){

	var class_map = {
		h: 'header',
		e: 'element',
		a: 'attr',
//		l: 'literal',
		st: 'status-code',
		et: 'event-type',
		css: 'css',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		c: 'code',
		h: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		st: 'code',
		css: 'code',
//		l: 'code',
		v: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|%\w+|`(.+?)([$@!\^])(\w*)/g,
			create_html
		),
		mapping1
	);
	// 目次構築
	Util.rebuildToc('MAIN0', '_toc_list0');

	function create_html(match, key, indicator, klass){


if(!key) {
	switch(match[0]){
	case '⇒':
		if(match.charAt(1) === '！'){
			in_idl = true;
			nesting += '</pre>';
			return '<pre class="idl">';
		} else {
			nesting += '</span>';
			return '：<span class="block">';
		}
/*
	case '【':
return '<span class="trans-note">' + match + '</span>'
*/
	case '%':
		return '<var>' + match.slice(1) + '</var>';
	}//◎
	if(in_idl) {
		result = nesting;
		in_idl = false;
	} else {
		result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	}
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"'
	break;
case 'I': // IDL interface
	href = '#' + key;
	if(in_idl) tag = '';
	break;
case 'm': // IDL member
	href = '#widl-PerformanceResourceTiming-' + key;
	if(in_idl) tag = '';
	break;
case 'et': // event-type
	break;
case 'v': // variables
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

function _reorder0(){ // for del_j
	var ids = [];
	repeat('#_reorder0 dfn[id^="widl-PerformanceResourceTiming-"]',
	function(e){
		ids.push(e.id);
	});
	ids.sort();
	var dl = E('_reorder0');
	ids.forEach(function(id){
		var dt = E(id).parentNode;
		var dd = dt.nextElementSibling;
		dl.appendChild(dt);
		while(dd && dd.tagName === 'DD'){
			dt = dd.nextElementSibling;
			dl.appendChild(dd);
			dd = dt;
		}
	});
}


</script>


<!-- 

function _reorder0(){ // for del_j
	var ids = [];
	repeat('#_reorder0 dfn[id^="widl-PerformanceResourceTiming-"]',
	function(e){
		ids.push(e.id);
	});
	ids.sort();
	var dl = E('_reorder0');
	ids.forEach(function(id){
		var dt = E(id).parentNode;
		var dd = dt.nextElementSibling;
		dl.appendChild(dt);
		dl.appendChild(dd);
	});
}

function get_timing_data(){
	var resourceList = window.performance.getEntriesByType("resource");
	for (var i = 0; i < resourceList.length; i++) {
		var item = resourceList[i];
		if (item.initiatorType == "img") {
			alert(item.responseEnd - item.startTime);
		}
	}
}

-->


<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
cache-or-local:
full:
redirect-or-equivalents:
cache-or-local:

PerformanceResourceTiming:idl-def-PerformanceResourceTiming
Performance:idl-def-performance-partial-1
	Performance:idl-def-performance

</script>

<!--%links -->
<script type="text/plain" id="_link_map">

	h.Origin:https://tools.ietf.org/html/rfc6454#section-4

h.Timing-Allow-Origin:#http-timing-allow-origin

資源:#dfn-resource
現在の文書:#dfn-current-document
現在の時刻:#dfn-current-time

~redirect等:#redirect-or-equivalents
計時~許可検査:#timing-allow-check
非同一生成元:#dfn-cross-origin
局所~cache等:#cache-or-local
満杯:#full

資源~計時~buffer~size上限:#dfn-resource-timing-buffer-size-limit
資源~計時~buffer現size:#dfn-resource-timing-buffer-current-size
資源~計時~buffer満杯~flag:#dfn-resource-timing-buffer-full-flag
追加する:#dfn-add-a-performanceresourcetiming-entry


i.~fetch開始:#step-fetch-start
i.~object作成:#step-create-object
i.収集~開始:#step-collection-start
i.接続-開始:#step-connect-start
i.要請~開始:#step-request-start
i.応答~開始:#step-response-start
i.応答~終了0:#step-response-end

I.DOMHighResTimeStamp:~HRTIME#idl-def-DOMHighResTimeStamp
	~TR/hr-time/#domhighrestimestamp

	I.Performance:#Performance
	~HRTIME#Performance
	I.PerformanceResourceTiming:#idl-def-PerformanceResourceTiming
I.PerformanceEntry:~TIMELINE#PerformanceEntry
I.PerformanceEntryList:~TIMELINE#PerformanceEntryList

I.XMLHttpRequest:~TR/XMLHttpRequest/#interface-xmlhttprequest
I.Window:~HTML50/browsers.html#create-a-document-object
I.Worker:~TR/workers/#worker
	I.EventHandler
I.DOMString:~TR/WebIDL/#idl-DOMString
	I.Document

m.clearResourceTimings:#dom-Performance-clearResourceTimings
m.setResourceTimingBufferSize:#dom-Performance-setResourceTimingBufferSize
m.setResourceTimingBufferSize():#dom-Performance-setResourceTimingBufferSize
m.onresourcetimingbufferfull:#dom-Performance-onresourcetimingbufferfull
et.resourcetimingbufferfull:#dom-Performance-onresourcetimingbufferfull

x.処理能~entry~buffer:~TIMELINE#dfn-performance-entry-buffer

x.生成元の ASCII 直列化:https://tools.ietf.org/html/rfc6454#section-6.2
x.HTTP ~cache:https://tools.ietf.org/html/rfc7234
x.HTTP/2:https://tools.ietf.org/html/draft-ietf-httpbis-http2-16

x.ECMAScript 大域~環境:https://heycam.github.io/webidl/#es-environment
x.処理能時系列線:~TIMELINE#performance-timeline
	sec-performance-timeline
	x.Performance:~TR/navigation-timing-2/#performance
待入する:~TIMELINE#dfn-queue-a-performanceentry

Worker:~TR/workers/#processing-model

x.HTTP-network ~fetch:~FETCH#http-network-fetch
x.HTTP-network-or-cache ~fetch:~FETCH#http-network-or-cache-fetch

e.embed:~HTML50/embedded-content-0.html#the-embed-element
e.iframe:~HTML50/embedded-content-0.html#the-iframe-element
e.img:~HTML50/embedded-content-0.html#the-img-element
e.link:~HTML50/document-metadata.html#the-link-element
e.script:~HTML50/scripting-1.html#the-script-element
e.object:~HTML50/embedded-content-0.html#the-object-element
e.svg:~TR/SVG11/struct.html#SVGElement


x.閲覧文脈:~HTML50/browsers.html#browsing-context
x.文字大小区別:~HTML50/infrastructure.html#case-sensitive
	またはそれに等価なもの:~HTML50/infrastructure.html#concept-http-equivalent-codes

x.取得:~HTML50/infrastructure.html#fetch
x.~fetch:~HTML50/infrastructure.html#fetch
x.~fetching:~HTML50/infrastructure.html#fetch
	fetching process:~HTML50/infrastructure.html#fetch
x.関連の~app~cache:~HTML50/browsers.html#relevant-application-cache
x.解決済み URL:~HTML50/infrastructure.html#resolve-a-url
	＊

c.stylesheet:~HTML50/links.html#link-type-stylesheet

	data: URI:~IETF/rfc2397
p.origin-list-or-null:~IETF/rfc6454#section-7.1
x.生成元:~IETF/rfc6454#section-4
x.同一生成元:~IETF/rfc6454#section-5

	~IETF
	~HTTPWG=http://httpwg.github.io/specs
x.内容~符号法:~IETF/rfc7231#section-3.1.2
	~HTTPWG/rfc7231.html#data.encoding
x.転送~符号法:~IETF/rfc7230#section-4
x.持続的~接続:~IETF/rfc7230#section-6.3
x.非同期に~close:~IETF/rfc7230#section-6.5
x.~message本体:~IETF/rfc7230#section-3.3
x.~payload本体:~IETF/rfc7230#section-3.3
	~HTTPWG/rfc7230.html#message.body
x.~chunked符号法:~IETF/rfc7230#section-4.1
	~HTTPWG/rfc7230.html#chunked.encoding


x.要素:~TR/dom/#concept-element
m.localName:~TR/dom/#concept-element-local-name

x.~scheme:~TR/url/#concept-url-scheme
css.url():~TR/css-syntax-3/#consume-a-url-token

x.単純~eventを発火:~WAPI#fire-a-simple-event
	＊？
x.~workerを走らす:~TR/service-workers/#service-worker-concept
x.run a worker:https://html.spec.whatwg.org/multipage/workers.html#run-a-worker
x.~active~worker:~TR/service-workers/#dfn-active-worker
x.合致する~active~worker:~TR/service-workers/#dfn-containing-service-worker-registration
x.名前~fetch_evの~eventを発火する:~TR/service-workers/#on-fetch-request-algorithm
x.~service~worker登録:~TR/service-workers/#dfn-service-worker-registration

</script>

<!--%置換語 -->
<script type="text/plain" id="words_table1">
IETF:https://tools.ietf.org/html
HRTIME:hr-time-2-ja.html
	https://w3c.github.io/hr-time-2/
	http://www.w3.org/TR/hr-time/
TIMELINE:performance-timeline-2-ja.html
	http://www.w3.org/TR/performance-timeline-2/

fetch_ev: <code class="event-type">fetch</code> 
</script>

<!--%words -->
<script type="text/plain" id="words_table">

UA:user agent:UA
access:::アクセス
app:application::アプリ

web:::ウェブ
site:::サイト
page:::ページ
cache:::キャッシュ
	~app~cache:application cache
hit:::ヒット
miss:::ミス

	再~open:reopen
system:::システム
size:::サイズ
script:::スクリプト
ゼロ:zero::~
source:::ソース
download:::ダウンロード
data:::データ
名前:name:~
名:name:~
情報:information:~

navigation:::ナビゲーション
navigate:::ナビゲート
parameter:::パラメタ
環境設定-:configure:~
process:::プロセス
benchmark:::ベンチマーク
page:::ページ
host:::ホスト
markup:::マークアップ
method:::メソッド
list:::リスト
link:::リンク
service:::サービス

	●fetch／HTTP
open:
close:
client:::クライアント
server:::サーバ
scheme:::スキーム
資源:resource::リソース
下位資源:subresources::下位リソース
redirect:::リダイレクト
transport:::トランスポート
domain:::ドメイン
lookup::検索
proxy:::プロキシ
tunnel:::トンネル
handshake:::ハンドシェイク
chunked::チャンク化
端点間:end-to-end::~:エンドツーエンド
符号法:coding:~
符号化方式:encoding:~
network:::ネットワーク
error:::エラー
protocol:::プロトコル
header:::ヘッダ
field:::フィールド
payload:::ペイロード
message:::メッセージ
本体:body:~
stylesheet:::スタイルシート

要請:request:~
応答:response:~
収集-:collect:~
収集:collection:~
	取得:fetch:~
fetch:
fetching:::fetch 処理
受信-:receive:~
受信:receiving:~
再送信:resend:~
送信-:send:~
送信:sending:~
持続的:persistent:~
接続:connection:~
接続-:connect:~
確立-:establish:~
確立:establishing:~
事由:reason:~
生成-:generate:~
生成元:origin:~
同一生成元:same origin:~
非同一生成元:cross-origin:~
検索取得:retrieval:~
検索取得-:retrieve:~
折衝-:negotiate:~
非同期:asynchronous:~
低層の:lower-layer:~
層:layer:~
encapsulation:::カプセル化
起動-:initiate:~
起動元:initiator:~
種別:type:~
転送:transfer:~
事前条件:precondition:~
時刻印:timestamp::~:タイムスタンプ
出自に:originate:~
待入する:queue する::待ち行列に入れる:キューする
再検証-:revalidate:~
再検証:revalidation:~

	●計時
処理能時系列線:Performance Timeline::~:パフォーマンスタイムライン
milliseconds:::ミリ秒数
clock:::クロック
skew:::スキュー
buffer:::バッファ
主buffer:primary buffer:~
entry:::エントリ
時刻:time:~
時区間:interval:~
	時点::3
	時系列順::1
所要時間:time interval:~
経過時間:time elapsed:~
時間:time:~
	経過時間:time elapsed:~
計時:timing:~
時機:timing:~
	属性:timing attribute:~
	情報:timing information:~
	測定:timing measurement:~

開始時刻:starting time:~
開始:start:~
終了0:end:終了
遅延:latency:~
計測:measurement:~
計測-:measure:~
測定:measurement:~
測定-:measure:~

満杯:full:~
格納-:store:~
格納:store:~
検査:check:~
許可検査:allow check:~
差分:difference:~
感知:perceive:~
知覚:perceive:~
記録-:record:~
単調増加:monotonic:~
	即時:immediate:~
処理能:performance:~

	●syntax
解決済み:resolved:~
byte:::バイト
特有の:-specific:~

接頭辞:prefix:~
octet:::オクテット
percent:::パーセント
token:::トークン
overhead:::オーバーヘッド
frame:::フレーム
stream:::ストリーム
生成規則:production:~
直列化:serialization:~::シリアル化
直列化-:serialize:~::シリアライズ
直列化子:serializer:~::シリアライザ
命名規約:naming convention:~
規約:convention:~
不合格:fail:~
合格:pass:~

合致:match:~
	合間:between:~
大文字:uppercase:~
文字:character:~
space:::スペース
区切りの:-separated:~
空白:whitespace:~
改行:newline:~
文字列:string:~
非大文字:non-capitalized:~
	文字大小も区別::1
符号化-:encode:~
符号化:encoding:~
構文:syntax:~
正準的:canonical:~
	正準形
桁:digit:~

	●仕様
version:::バージョン
proprietary:::プロプライエタリ
header:::ヘッダ
vendor:::ベンダ
support:::サポート
仕様:spec:~
仕組み:mechanism:~
任意選択:optional:~
利用者:user:~
制約:restriction:~
拘束:constraints:~
拘束-:constrain:~
制限:limit:~
上限:limit:~
定義-:define:~
定義:definition:~
実施:practice:~
	容易:easily:~
	手助け:facilitate:~
	手法::1
手続き:steps:~
段:step:~
既定:default:~
明示的:explicit:~
拡張:extension:~
指定-:specify:~
指示-:indicate:~
推奨-:recommend:~
提供-:provide:~
提供側:provider:~
	概要／序論:Introduction:~
包括的な:comprehensive:~
	手段:instrumentation:~
試験的:experimental:~
試験-:experiment:~
参考:non-normative:~
導入-:introduce:~
要件:requirements:~
非標準:non-normative:~
可能化-:enable:~
可用:available:~
各種用語:terminology:~
適合性:conformance:~
適用-:apply:~

中止-:abort:~
algo:algorithm::アルゴリズム
model:::モデル
処理:processing:~
処理-:process:~
処理過程:process:~
内部:internal:~
精確:precise:~
実際:actual:~
実際の:actual:~
意図-:intend:~
結付けら:associate さ:結び付けら

	●
secure:::セキュア
security:::セキュリティ
privacy:::プライバシー
policy:::ポリシー
transport:::トランスポート
	施策:
悪意的な:malicious:悪意のある
	悪化:worse:~
懸念:concern:~
	問題:problem:~
統計上の痕跡:statistical fingerprinting:~
第三者:third-party:~
訪問-:visit:~

	●DOM
worker:
active:
interface:::インタフェース
event:::イベント
handler:::ハンドラ
object:::オブジェクト
例外:exception:~
被取得時:被 get 時:~
要素:element:~

浮上:bubble:~
発火:fire:~
待行列:queue:待ち行列
文書:document:~
根元:root:~
単純:simple:~
取消:cancel:~
親:parent:~
継承:inherited:~

関連の:relevant:~
閲覧文脈:browsing context:~
文脈:context:~
除去-:remove:~
要素:element:~
内容:content:~
登録:registration:~

大域:global:~
環境:environment:~
初期:initial:~
追加:add:~
初期化-:initialize:~
新たな:new:~
被呼出時:被 invoke 時:~

	●
cost:::コスト
flag:::フラグ
埋込み:embedded:埋め込み
	呼び出:invoke／call
返され:return され:~
返さ:return し:~
返す:return する:~
返り:return:~
値:value:~
被った:incur された:~

消費-:consume:~
作成-:create:~
作成:creation:~
公開-:expose:~
共有-:share:~
下位:sub-:~
pattern:::パタン
概して:typical に:~

再利用:reuse:~
利用:use:~
体験:experience:~
動的:dynamic:~
関与-:participate:~

品質:quality:~
変化:change:~
変更-:change:~
失敗-:fail:~
失敗:failure:~

完了-:complete:~
完了:completion:~
完全な:complete:~
局所:local:~
属性:attribute:~
成功裡:successful:~
新たな:new:~
	方法::1
既存の:existing:~
動作:action:~
報告-:report:~
code:::コード

	読み込み:load し／load

	現在:current:~
現在の:current:~
現size:current size:現 size:現サイズ

最後の:last:~
最初の:first:~
二番目の:second:~
様相:picture:~
機能-:function:~
決定-:determine:~

破棄-:discard:~
等価:equivalent:~
終了-:terminate:~
表現-:represent:~
必要性:need:~
計算-:calculate:~
記述-:describe:~
設定:set:~
許容-:allow:~
試行-:try:~
	attempt:~
再試行:retry:~

認証:authentication:~
調整:adjustment:~
識別-:identify:~
関数:function:~
関係-:relate:~
妥当:valid:~

	含める:include する:~
	含めら:include さ:~
	含まれ:include さ:~

	表面化-:surface:~
	復号:remove:~
	一方::1
	一部::2
	下線:underline
	不要::1
	今日::1
	仕立::1
	以下::1
	何故::1
	個数::1
	値:value:~
	内訳::1
	前提::1
	可能::2
	各段階::2

	同じ:same:~
	図式:graph:~
	型:type:~
	場合::74
	対応:corresponding:~
	対象::1
	対象:subject
	対象外::1
	事例:case:~
	当該::1
	後続::1
	必要::3
	情報取得::1
	意味::1
	起点::2
	該当::1
	最大で:maximum:~
	最大数::2
	最小個数::1
	次第::1
	番目::1
	目的::2
	直前::14
	直後::10
	immediately:~
	空にする:clear:~
	範囲::1
	経過::1
	結果:result:~
	複数::3
	複数個::1
	見込::1
	部分::1
	重要:important:~

	開始時点:at the beginning:~
	開始段::1
</script>



<!--%style  -->

<style type="text/css">
.event-type,
.handler {
	color: purple;
}

</style>

</head>

<body>


<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">
<h1>Resource Timing 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題に日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">Resource Timing</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新： <time>2016-02-07</time>
（公開：<time>2013-01-23</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>



<header>

<div><a href="http://www.w3.org/" id="_W3C">W3C</a></div>

<h1>Resource Timing — リソースの計時</h1>
<h2>2016 年 2 月 25 日付 作業草案</h2>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dd>http://www.w3.org/TR/2016/WD-resource-timing-20160225/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>http://www.w3.org/TR/resource-timing/</dd>

	<dt title="Latest Editor’s Draft:">最新の編集者草案</dt>
	<dd>https://w3c.github.io/resource-timing/</dd>

	<dt title="Previous version:">以前のバージョン</dt>
	<dd>http://www.w3.org/TR/2016/WD-resource-timing-20160204/</dd>
<!-- 
http://www.w3.org/TR/2015/WD-resource-timing-20151029/
http://www.w3.org/TR/2014/WD-resource-timing-20141216/
http://www.w3.org/TR/2014/CR-resource-timing-20140624/
http://www.w3.org/TR/2014/CR-resource-timing-20140325/
-->

	<dt title="Editors:">編集</dt>
	<dd>Arvind Jain, Google Inc., arvind@google.com </dd>
	<dd>Todd Reifsteck, Microsoft Corp., toddreif@microsoft.com</dd>
	<dd>Jatinder Mann, Microsoft Corp., jmann@microsoft.com <i>(Until February 2014)</i></dd>
	<dd>Zhiheng Wang, Google Inc. <i>(Until July 2012)</i></dd>
	<dd>Anderson Quach, Microsoft Corp. <i>(Until March 2011)</i></dd>

	<dt>Repository:</dt>
	<dd><a href="https://github.com/w3c/resource-timing/">We are on Github.</a><dd>
	<dd><a href="https://github.com/w3c/resource-timing/issues">File a bug.</a><dd>
	<dd><a href="https://github.com/w3c/resource-timing/commits/gh-pages/index.html">Commit history.</a><dd>

	<dt>Mailing list:</dt>
	<dd><a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a></dd>

	<dt>Implementation:</dt>
	<dd><a href="http://caniuse.com/#feat=resource-timing">Can I use Resource Timing?</a></dd>
	<dd><a href="http://w3c-test.org/resource-timing/">Test Suite</a></dd>
	<dd><a href="https://github.com/w3c/web-platform-tests/tree/master/resource-timing">Test Suite repository</a></dd>

</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
© 2016
<a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
<a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
<a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>).
W3C
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and
<a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a>
rules apply.
</small>
</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>
<p>
この仕様は、~web~appが文書~内の資源に関する完全な計時~情報に~accessするための~interfaceを定義する。
◎
This specification defines an interface for web applications to access the complete timing information for resources in a document.
</p>
	</section>
	<section id="sotd">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<em>この節では、発行時点における…</em>
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>
に委譲
】</span>
</p>

<!-- 
his section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at http://www.w3.org/TR/.

This is a work in progress and may change without any notices.

Please send comments to public-web-perf@w3.org (archived) with [ResourceTiming] at the start of the subject line.

Implementers SHOULD be aware that this document is not stable. Implementers who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways. Vendors interested in implementing this document before it eventually reaches the Candidate Recommendation stage SHOULD join the aforementioned mailing lists and take part in the discussions.

This document was published by the Web Performance Working Group as a Working Draft. This document is intended to become a W3C Recommendation. If you wish to make comments regarding this document, please send them to public-web-perf@w3.org (subscribe, archives). All comments are welcome.

Publication as a Working Draft does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.

This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.

This document is governed by the 1 September 2015 W3C Process Document. 
-->

<p>
この文書は
<a href="http://www.w3.org/2010/webperf/">Web Performance Working Group</a>
により，作業草案として制作されました。
これは W3C 勧告になるものと意図されています。
コメントを歓迎します。
<a href="mailto:public-web-perf@w3.org?subject=%ResourceTiming%5D">public-web-perf@w3.org</a>
（
<a href="mailto:public-web-perf-request@w3.org?subject=subscribe">subscribe</a>,
<a href="http://lists.w3.org/Archives/Public/public-web-perf/">archives</a>
）
宛まで送られるよう願います。
◎
This document was published by the Web Performance Working Group as a Working Draft. This document is intended to become a W3C Recommendation. If you wish to make comments regarding this document, please send them to public-web-perf@w3.org (subscribe, archives). All comments are welcome.
</p>

	</section>

<nav class="toc" id="table-of-contents">
<h2 title="Table of Contents">目次</h2>
<ol id="_toc_list0"></ol>
</nav>

<main id="MAIN0">

	<section id="introduction" class="informative">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
利用者が知覚し得る遅延は Web ~appにとり重要な品質~benchmarkである。
JavaScript に基づく仕組みは、~app内における利用者~遅延を測定するための包括的な~~手段を提供し得るが、多くの事例で，それらは端点間における遅延の完全な様相を提供できない。
この問題は、~navigationに結付けられた計時~情報については，
`NAVIGATION-TIMING-2$r にて取り組まれている。
この仕様は、文書の資源に関係する完全な計時~情報を収集するための
JavaScript おける仕組み
`PerformanceResourceTiming$I ~interfaceを導入する。
◎
User latency is an important quality benchmark for Web Applications. While JavaScript-based mechanisms can provide comprehensive instrumentation for user latency measurements within an application, in many cases, they are unable to provide a complete end-to-end latency picture. While Navigation Timing 2 [NAVIGATION-TIMING-2] addresses part of the problem by providing timing information associated with a navigation, this document introduces the PerformanceResourceTiming interface to allow JavaScript mechanisms to collect complete timing information related to resources on a document.
</p>


<div class="example">
<p>
例えば、次の~scriptは単純な方法により，資源の~fetchに要した時間の計測-を試行する：<!-- 測定 -->
◎
For example, the following JavaScript shows a simple attempt to measure the time it takes to fetch a resource:
</p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var start = new Date().getTime();
   var image1 = new Image();
   var resourceTiming = function() {
       var now = new Date().getTime();
       var latency = now - start;
       alert("End to end resource fetch: " + latency);
   };

   image1.onload = resourceTiming;
   image1.src = 'http://www.w3.org/Icons/w3c_main.png';
}
    &lt;/script&gt;
    &lt;img src="http://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<p>
この~scriptは，資源の~fetchに要した時間は計測できるが、その内訳の各段階に費やされた時間は計測できない。
更に、~markupにより記述された資源に費やされた時間を，この~scriptで計測することは容易でない。
◎
Though this script can measure the time it takes to fetch a resource, it cannot break down the time spent in various phases. Further, the script cannot easily measure the time it takes to fetch resources described in markup.
</p>

<p>
利用者~体験に関する完全な情報の必要性に応えるため、この文書は
`PerformanceResourceTiming$I ~interfaceを導入する。
この~interfaceは、~client側~appにおける完全な遅延~計測を可能にする， JavaScript による仕組みを提供する。
この~interfaceにより、前の例は，利用者が感知する資源の読み込み時間を計測-可能なものに仕立て上げられる。
◎
To address the need for complete information on user experience, this document introduces the PerformanceResourceTiming interface. This interface allows JavaScript mechanisms to provide complete client-side latency measurements within applications. With this interface, the previous example can be modified to measure a user's perceived load time of a resource.
</p>

<div class="example">
<p>
次の~scriptは、~markupにより定義されたものまで含め，~page内のそれぞれの資源の~fetchに要した時間の長さを計算する。
この例は、~pageが
<samp >http://www.w3.org</samp>
下に~hostされていることを前提にしている。
その気になれば
`PerformanceResourceTiming$I
~interfaceを利用して、資源~fetchingの各段階ごとに要した時間も計測できる。
◎
The following script calculates the amount of time it takes to fetch every resource in the page, even those defined in markup. This example assumes that this page is hosted on http://www.w3.org. One could further measure the amount of time it takes in every phase of fetching a resource with the PerformanceResourceTiming interface.
</p>
<pre>
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var image1 = new Image();
   image1.onload = resourceTiming;
   image1.src = 'http://www.w3.org/Icons/w3c_main.png';
}

function resourceTiming() {
    var resourceList = window.performance.getEntriesByType("resource");
    for (i = 0; i &lt; resourceList.length; i++) {
       if (resourceList[i].initiatorType == "img") {
          alert(
            "End to end resource fetch: "+ 
            ( resourceList[i].responseEnd  - resourceList[i].startTime )
          );
       }
    }
}
    &lt;/script&gt;
    &lt;img id="image0" src="http://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

	</section>

	<section id="conformance-requirements">
<h2 title="Conformance requirements">2. 適合性の要件</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>
<!-- 
Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("MUST", "SHOULD", "MAY", etc) used in introducing the algorithm.

Some conformance requirements are phrased as requirements on attributes, methods or objects. Such requirements are to be interpreted as requirements on user agents.

Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant.)

The IDL fragments in this specification must be interpreted as required for conforming IDL fragments, as described in the Web IDL specification. [WebIDL]

-->
	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#terminology" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

<!-- 
The construction "a Foo object", where Foo is actually an interface, is sometimes used instead of the more accurate "an object implementing the interface Foo".

The term DOM is used to refer to the API set made available to scripts in Web applications, and does not necessarily imply the existence of an actual Document object or of any other Node objects as defined in the DOM specification. [DOM]

A DOM attribute is said to be getting when its value is being retrieved (such as by author script), and is said to be setting when a new value is assigned to it.

The term JavaScript is used to refer to ECMA262, rather than the official term ECMAScript, since the term JavaScript is more widely known. [ECMA-262]
-->


<p>
この仕様を通して、以下の用語が用いられる：
</p>

<dl>
	<dt>`資源@（ resource ）</dt>
	<dd>
要素その他 利用者により起動される~fetchを指す。
例えば資源は、次に挙げるものを出自にし得る：
`XMLHttpRequest$I ~object `XMLHttpRequest$r,
［
`iframe^e, `img^e, `script^e, `object^e, `embed^e,
~link型 `stylesheet$c の `link^e
］などの HTML 要素 `HTML5$r,
`svg^e などの SVG 要素 `SVG11$r
◎
The term resource is used to refer to elements and any other user-initiated fetches throughout this specification. For example, a resource could originate from XMLHttpRequest objects [[XMLHttpRequest], HTML elements [HTML5] such as iframe, img, script, object, embed, and link with the link type of stylesheet, and SVG elements [SVG11] such as svg.
</dd>

	<dt>`非同一生成元@（ cross origin ）</dt>
	<dd>
`同一生成元$xでないことを意味する。
◎
The term cross-origin is used to mean non same origin.
</dd>

	<dt>`現在の文書@（ current document ）</dt>
	<dd>
<a href="~HTML50/browsers.html#dom-document-0">`Window^I ~objectの最新の `Document^I ~object</a>
に結付けられている文書を指す。
◎
The term current document refers to the document associated with the Window object's newest Document object.
</dd>

	<dt>`現在の時刻@（ current time ）</dt>
	<dd id="_measured-since">
時刻~値は，
<a href="https://w3c.github.io/navigation-timing/#widl-PerformanceNavigationTiming-startTime">文書の~navigationの開始</a>
を起点としてミリ秒~単位で計測されるものとする
`HR-TIME-2$r
。
例えば，文書の~navigationの開始は、時刻 0 で生じる。
◎
Throughout this work, all time values are measured in milliseconds since the start of navigation of the document [HR-TIME-2]. For example, the start of navigation of the document occurs at time 0.
</dd>
	<dd>
`現在の時刻$は、文書の~navigationの開始から その時点までに経過した，ミリ秒数による時刻を指す。
◎
The term current time refers to the number of milliseconds since the start of navigation of the document until the current moment in time.
</dd>
	<dd class="note">注記：
この，時刻の定義は、 High Resolution Time 仕様 `HR-TIME-2$r に基づくものであり、
1970 年 1 月 1 日 0 時 0 分 0 秒 (UTC) を起点としていた，
Navigation Timing 仕様 `NAVIGATION-TIMING$r による定義とは異なる。
◎
Note
◎
This definition of time is based on the High Resolution Time specification [HR-TIME-2] and is different from the definition of time used in the Navigation Timing specification [NAVIGATION-TIMING], where time is measured in milliseconds since midnight of January 1, 1970 (UTC).
</dd>
</dl>

<p class="trans-note">【
簡潔に記すため、この訳では，次の非公式な用語も導入する：
】</p>

<dl>
	<dt>`~redirect等@</dt>
	<dd>
HTTP ~redirectまたは（他の~protocolにおける）
<a href="~HTML50/infrastructure.html#concept-http-equivalent-codes">それに等価なもの</a>
を指す総称。
</dd>

	<dt>`局所~cache等@</dt>
	<dd>
［
`関連の~app~cache$x, または局所~資源
］を指す総称。
</dd>

</dl>


	</section>
	<section id="resource-timing">
<h2 title="Resource Timing">4. 資源~計時</h2>


		<section id="introduction-1">
<h3 title="Introduction">4.1. 概要</h3>

~INFORMATIVE

<p>
`PerformanceResourceTiming$I
~interfaceは、~download可能な資源の計時~測定を手助けする。
例えば，この~interfaceは、
`XMLHttpRequest$I ~object `XMLHttpRequest$r
や，
`iframe$e, `img$e, `script$e, `object$e, `embed$e, ［
~link型 `stylesheet$c の `link$e
］などの HTML 要素 `HTML5$r，あるいは
`svg$e などの SVG 要素 `SVG11$r において利用できる。
◎
The PerformanceResourceTiming interface facilitates timing measurement of downloadable resources. For example, this interface is available for XMLHttpRequest objects [XMLHttpRequest], HTML elements [HTML5] such as iframe, img, script, object, embed, and link with the link type of stylesheet, and SVG elements [SVG11] such as svg.
</p>

<!-- ＊
<p>
この仕様を通して、語 “資源”は，これらの要素や
利用者により起動される他の~fetchを指すときに利用される。
◎
The term "resource" is used to refer to these elements and any other user-initiated fetches throughout this specification.
</p>
 -->

		</section>
		<section id="resources-included">
<h3 title="Resources Included in the PerformanceResourceTiming Interface">4.2. `PerformanceResourceTiming^I ~interfaceが対象にする資源の範囲</h3>

<p>
現在の［
`閲覧文脈$x `HTML5$r ／
~worker文脈 `WORKERS$r
］により`~fetch$xされたすべての資源は、
`PerformanceResourceTiming$I ~objectとして，関連の文脈の`処理能時系列線$xに含められ~MUST。
`局所~cache等$から検索取得された資源は、
`PerformanceResourceTiming$I ~objectとして`処理能時系列線$xに含められ~MUST。
~fetchにより起動されたが，（~network~errorなどに因り）後で中止された資源は、 `PerformanceResourceTiming$I ~objectとして
— その属性~値を処理~modelによる手続き（後述）の中で初期化した上で —
`処理能時系列線$x内に含められ~MUST。
◎
All resources fetched by the current browsing [HTML5] or worker [WORKERS] context's MUST be included as PerformanceResourceTiming objects in the Performance Timeline of the relevant context. Resources that are retrieved from relevant application caches or local resources MUST be included as PerformanceResourceTiming objects in the Performance Timeline ([PERFORMANCE-TIMELINE-2]). Resources for which the fetch was initiated, but was later aborted (e.g. due to a network error) MUST be included as PerformanceResourceTiming objects in the Performance Timeline and MUST contain initialized attribute values for processed substeps of the processing model.
</p>

<p>
この節の残りの部分は参考である。
◎
The rest of this section is non-normative.
</p>


<p>
例：
◎
Examples:
</p>

<ul>
	<li>
２つの HTML `img$e 要素の `src^a 属性に，同じ正準的 URL （ canonical URL ）が利用されている場合、［
資源の`~fetch$xを起動させた，最初の `img^e 要素
］の方が
`PerformanceResourceTiming$I ~objectとして`処理能時系列線$xに含められる~SHOULDである。
~UAは、二番目の `img^e 要素の URL については、再~要請は行わない代わりに，最初の `img^e 要素に対し起動された既存の~downloadを利用すると見込まれる。
この場合、`処理能時系列線$xの中には、最初の `img^e 要素による資源`~fetch$xによるもののみが現れることになる。
◎
If the same canonical URL is used as the src attribute of two HTML IMG elements, the fetch of the resource initiated by the first HTML IMG element SHOULD be included as a PerformanceResourceTiming object in the Performance Timeline. The user agent might not re-request the URL for the second HTML IMG element, instead using the existing download it initiated for the first HTML IMG element. In this case, the fetch of the resource by the first IMG element would be the only occurrence in the Performance Timeline.
</li>
	<li>
HTML `img$e 要素の `src^a 属性が~scriptから変更された場合、元々の資源の`~fetch$xのみならず，新たな URL の`~fetch$xも，
`PerformanceResourceTiming$I
~objectとして`処理能時系列線$xに含められることになる。
◎
If the src attribute of a HTML IMG element is changed via script, both the fetch of the original resource as well as the fetch of the new URL would be included as PerformanceResourceTiming objects in the Performance Timeline.
</li>
		<li>
HTML `iframe$e 要素が `src^a 属性を指定しない~markupにより追加された場合、~UAは
`iframe^e に対する `about:blank^c 文書を読み込み得る。
後の時点で `src^a 属性が~scriptから動的に変更された場合、~UAはその `iframe^e に対するその新たな URL 資源を`~fetch$xし得る。
この場合、新たな URL の`~fetch$xのみが，
`PerformanceResourceTiming$I
~objectとして`処理能時系列線$xに含められることになる。
◎
If an HTML IFRAME element is added via markup without specifying a src attribute, the user agent may load the about:blank document for the IFRAME. If at a later time the src attribute is changed dynamically via script, the user agent may fetch the new URL resource for the IFRAME. In this case, only the fetch of the new URL would be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
	<li>
同じ正準的 URL に対し,
`XMLHttpRequest$I が２度~生成された場合、
いずれの資源の`~fetch$xも
`PerformanceResourceTiming$I
~objectとして`処理能時系列線$xに含められることになる。
何故なら、 2 度目の資源~fetchに対する要請には，最初の要請による~downloadを再利用できないからである。
◎
If an XMLHttpRequest is generated twice for the same canonical URL, both fetches of the resource would be included as a PerformanceResourceTiming object in the Performance Timeline. This is because the fetch of the resource for the second XMLHttpRequest cannot reuse the download issued for the first XMLHttpRequest.
</li>
	<li>
HTML `iframe$e 要素が~pageに含められている場合、 `iframe^e `src^a 属性により要請される資源のみが，
`PerformanceResourceTiming$I
~objectとして`処理能時系列線$xに含められることになる。
`iframe^e 文書により要請される下位~資源は、親~文書の`処理能時系列線$xではなく， `iframe^e 文書の`処理能時系列線$xに含められることになる。
◎
If an HTML IFRAME element is included on the page, then only the resource requested by IFRAME src attribute is included as a PerformanceResourceTiming object in the Performance Timeline. Sub-resources requested by the IFRAME document will be included in the IFRAME document's Performance Timeline and not the parent document's Performance Timeline.
</li>
	<li>
HTML `img$e 要素が~sourceとして
<a href="~IETF/rfc2397">data: URI</a> `RFC2397$r
を持つ場合、その資源は
`PerformanceResourceTiming$I ~objectとして`処理能時系列線$xに含められることはない。
<a href="~IETF/rfc2397">data: URI</a>
は埋込み~dataであり、`~fetch$xを要しないものと定義されているので。
◎
If an HTML IMG element has a data: URI as its source [RFC2397], then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline. By definition data: URI contains embedded data and does not require a fetch.
</li>

	<li>
資源の`~fetch$xが~network~error（ DNS, TCP, TLS ~errorなど）に因り中止された場合、その~fetchは，失敗~時点までの属性~値で初期化された
`PerformanceResourceTiming$I ~objectとして`処理能時系列線$xに含められることになる
— 例えば TCP ~handshake~errorは、 要請に対する DNS 時刻印を報告するべきである, 等々。
◎
If a resource fetch was aborted due to a networking error (e.g. DNS, TCP, or TLS error), then the fetch would be included as a PerformanceResourceTiming object in the Performance Timeline with initialized attribute values up to the point of failure - e.g. a TCP handshake error should report DNS timestamps for the request, and so on.
</li>

	<li>
資源の`~fetch$xが，その事前条件（例： 混成内容（ mixed content ）, CORS 制約, CSP ~policy, など）に失敗したために中止された場合、その資源は
`PerformanceResourceTiming$I ~objectとして`処理能時系列線$xに含められることはない。
◎
If a resource fetch is aborted because it failed a fetch precondition (e.g. mixed content, CORS restriction, CSP policy, etc), then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>

</ul>

<p>
~UAは、
`PerformanceResourceTiming$I
~objectとして`処理能時系列線$xに含み得る資源の個数を制限できる。
推奨される
`PerformanceResourceTiming$I
~objectの最小個数は 150 である
— ~UAはこれを変更してもよいが。
この制限は、
`setResourceTimingBufferSize()$m を呼び出すことにより，変更を要請できる。
◎
The user agent MAY choose to limit how many resources are included as PerformanceResourceTiming objects in the Performance Timeline. The recommended minimum number of PerformanceResourceTiming objects is 150, though this may be changed by the user agent. setResourceTimingBufferSize can be called to request a change to this limit.
</p>

		</section>
		<section id="performanceresourcetiming">
<h3 title="The PerformanceResourceTiming Interface">4.3. `PerformanceResourceTiming^I ~interface</h3>


<p>
`PerformanceResourceTiming$I
~interfaceは`処理能時系列線$xに関与し，<!--  -->
`PerformanceEntry$I
~interfaceの次の属性を拡張する：
◎
The PerformanceResourceTiming interface participates in the Performance Timeline and extends the following attributes of the PerformanceEntry interface:
</p>


<dl class="idl-defs">
	<dt>readonly attribute DOMString `name@m</dt>
    <dd>
被取得時には、要請された資源の`解決済み URL$x を返さ~MUST。
この属性は、`~fetch$x先が異なる URL に~redirectされても，変化しては~MUST_NOT。
◎
This attribute MUST return the resolved URL of the requested resource. This attribute MUST NOT change even if the fetch redirected to a different URL.
</dd>

	<dt>readonly attribute DOMString `entryType@m</dt>
	<dd>
被取得時には、 `resource^l を返さ~MUST。
◎
The entryType attribute MUST return the DOMString "resource".
</dd>

	<dt>readonly attribute DOMHighResTimeStamp `startTime@m</dt>
	<dd>
被取得時には、［
~UAが資源の`~fetching$xを待行列に入れる直前の時刻
］を表す，
`DOMHighResTimeStamp$I `HR-TIME-2$r
を返さ~MUST。
資源の~fetchの間に`~redirect等$が生じたときは、すべての`~redirect等$について，［
`現在の文書$と`同一生成元$xであるか, または`計時~許可検査$に合格する
］ならば、この属性は
`redirectStart$m と同じ値を返さ~MUST。
他の場合、この属性は `fetchStart$m と同じ値を返さ~MUST。
◎
The startTime attribute MUST return a DOMHighResTimeStamp [HR-TIME-2] with the time immediately before the user agent starts to queue the resource for fetching. If there are HTTP redirects or equivalent when fetching the resource, and if all the redirects or equivalent are from the same origin as the current document or the timing allow check algorithm passes, this attribute MUST return the same value as redirectStart. Otherwise, this attribute MUST return the same value as fetchStart.
</dd>

	<dt>readonly attribute DOMHighResTimeStamp `duration@m</dt>
	<dd>
被取得時には、
`responseEnd$m の， `startTime$m からの差分を表す
`DOMHighResTimeStamp$I
を返さ~MUST
<!-- ＊,respectively -->
◎
The duration attribute MUST return a DOMHighResTimeStamp equal to the difference between responseEnd and startTime, respectively.
</dd>
</dl>




⇒！
[Exposed=(Window,Worker)]
interface `PerformanceResourceTiming@I : `PerformanceEntry$I {
  readonly attribute DOMString `initiatorType$m;
  readonly attribute DOMString `nextHopProtocol$m;
  readonly attribute `DOMHighResTimeStamp$I `workerStart$m;
  readonly attribute `DOMHighResTimeStamp$I `redirectStart$m;
  readonly attribute `DOMHighResTimeStamp$I `redirectEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `fetchStart$m;
  readonly attribute `DOMHighResTimeStamp$I `domainLookupStart$m;
  readonly attribute `DOMHighResTimeStamp$I `domainLookupEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `connectStart$m;
  readonly attribute `DOMHighResTimeStamp$I `connectEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `secureConnectionStart$m;
  readonly attribute `DOMHighResTimeStamp$I `requestStart$m;
  readonly attribute `DOMHighResTimeStamp$I `responseStart$m;
  readonly attribute `DOMHighResTimeStamp$I `responseEnd$m;
  readonly attribute unsigned long long `transferSize$m;
  readonly attribute unsigned long long `encodedBodySize$m;
  readonly attribute unsigned long long `decodedBodySize$m;
  <a href="#serializer">serializer</a> = {inherit, attribute};
};
◎


			<section id="attributes">
<h3 title="Attributes">4.3.1 属性</h3>

<p class="trans-note">【
この訳では、各~属性~定義を原文による字句順でなく， IDL に示された順（時系列順）に挙げる。
<input
	type="button"
	value="字句順に切り替える（不可逆）"
	onclick="_reorder0()"
/>
】</p>

<dl class="idl-defs" id="_reorder0">
	<dt>readonly attribute DOMString `initiatorType@m</dt>
	<dd>
<p>
被取得時には、資源~fetchの起動元に応じて，次を返さ~MUST：
◎
↓</p>

		<ul>
			<li>
`要素$xから起動された場合
⇒
その`要素$xの `localName$m
`DOM$r
◎
If the initiator is an element, on getting, the initiatorType attribute MUST return a DOMString with the same value as the localName of that element [DOM].
</li>
			<li>
`url()$css 構文 `CSS-SYNTAX-3$r （
`@import url()^css や `background: url()^css
など）により~downloadされる CSS 資源から起動された場合
⇒
`css^l
◎
If the initiator is a CSS resource downloaded by the url() syntax [CSS-SYNTAX-3], such as @import url() or background: url(), on getting, the initiatorType attribute MUST return the DOMString "css".
</li>
			<li>
`XMLHttpRequest$I ~object
`XMLHttpRequest$r
から起動された場合
⇒
`xmlhttprequest^l
◎
If the initiator is an XMLHttpRequest object [XMLHttpRequest], on getting, the initiatorType attribute MUST return the DOMString "xmlhttprequest".
</li>
		</ul>
	</dd>


	<dt>readonly attribute DOMString `nextHopProtocol@m</dt>
	<dd>
<div class="p">
<p>
この属性は、
ALPN Protocol ID `RFC7301$r
として識別される，資源の~fetchに利用された~network~protocolを返さ~MUST。
~proxyが環境設定されている下では、次を返さ~MUST：
</p>
		<ul>
			<li>
~tunnel接続が確立された場合
⇒
その~tunnelされた~protocolの ALPN Protocol ID
</li>
			<li>
他の場合
⇒
~proxyへの最初の hop の ALPN Protocol ID
</li>
		</ul>
◎
This attribute MUST return the network protocol used to fetch the resource, as identified by the ALPN Protocol ID [RFC7301]. When a proxy is configured, if a tunnel connection is established then this attribute MUST return the ALPN Protocol ID of the tunneled protocol, otherwise it MUST return the ALPN Protocol ID of the first hop to the proxy.
</div>

<div class="p">
<p>
ALPN Protocol ID を精確に表現するため、次の拘束が追加で適用される：
</p>
		<ul>
			<li>
ALPN ~protocol内の~octetのうち， `%^l を除く妥当な~token文字は~percent符号化されては~MUST_NOT。
</li>
			<li>
また、~percent符号化には，大文字の 16 進~桁を用い~MUST。
</li>
		</ul>
◎
In order to have precisely one way to represent any ALPN protocol ID, the following additional constraints apply: octets in the ALPN protocol MUST NOT be percent-encoded if they are valid token characters except "%", and when using percent-encoding, uppercase hex digits MUST be used.
</div>

<p>
この属性は、実際に折衝された方法に関わらず，~fetchのために利用~中の~network~protocolを識別するためとして意図されていることに注意。
すなわち、~network~protocolを折衝するために ALPN が利用されていなくても、この属性は，依然として，ALPN Protocol ID を利用して利用~中の~protocolを指示する。
◎
Note that this attribute is intended to identify the network protocol in use for the fetch regardless of how it was actually negotiated; that is, even if ALPN is not used to negotiate the network protocol, this attribute still uses the ALPN Protocol ID's to indicate the protocol in use.
</p>
	</dd>


	<dt>readonly attribute DOMHighResTimeStamp `workerStart@m</dt>
	<dd>
<p>
この属性は、次を返さ~MUST：
</p>
		<ul>
			<li>
<p>
現在の［
`閲覧文脈$x `HTML5$r ／ ~worker文脈 `WORKERS$r
］が，要請を~serviceするために要求されるような，`合致する~active~worker$x
`SERVICE-WORKERS$r
を持つ場合：
</p>
				<ul>
					<li>
その~workerがすでに可用である場合
⇒
~UAがその`~active~worker$xに向けて，`名前~fetch_evの~eventを発火する$x直前の時刻。
</li>
					<li>
~UAが，その`~workerを走らす$x直前の時刻。
<span class="trans-note">【
~link先が変？ `run a worker$x ？
】</span>
</li>
				</ul>
			</li>

			<li>
他の場合
⇒
ゼロ
</li>
		</ul>
◎
If the current browsing or worker context's have an active worker ([SERVICE-WORKERS]), this attribute MUST return the time immediately before the user agent runs the worker required to service the request, or if the worker is available, the time immediately before the user agent fires an event named `fetch` at the active worker. Otherwise, if there is no active worker this attribute MUST return zero.
</dd>

	<dt>readonly attribute DOMHighResTimeStamp `redirectStart@m</dt>
	<dd>

<p>
この属性は、次を返さ~MUST：
</p>

		<ul>
			<li>
<p >
資源`~fetching$xの際に`~redirect等$が生じていて, かつ
次のいずれかの条件：
</p>
				<ul>
					<li>
すべての`~redirect等$は `現在の文書$と`同一生成元$xからのものである，または
</li>
					<li>
（同一生成元からのものでない`~redirect等$もあるが）
~redirectされた どの資源
`の応答^tnote
も`計時~許可検査$に合格する。
</li>
				</ul>
<p>
が満たされるならば
⇒
~redirectを起動させた`~fetch$xの開始時刻（
`fetchStart$m
と同じ値）
</p>
</li>
			<li>
他の場合
⇒
ゼロ
</li>
		</ul>

<div lang="en">
<p>
If there are HTTP redirects or equivalent when fetching the resource and if all the redirects or equivalent are from the same origin as the current document, this attribute MUST return the starting time of the fetch that initiates the redirect.
</p>
<p>
If there are HTTP redirects or equivalent when fetching the resource and if any of the redirects are not from the same origin as the current document, but the timing allow check algorithm passes for each redirected resource, this attribute MUST return the starting time of the fetch that initiates the redirect. Otherwise, this attribute MUST return zero.
</p>
</div>

	</dd>


	<dt>readonly attribute DOMHighResTimeStamp `redirectEnd@m</dt>
	<dd>
<p>
この属性は、次を返さ~MUST：
</p>

		<ul>
			<li>
<p >
資源`~fetching$xの際に`~redirect等$が生じていて, かつ
次のいずれかの条件：
</p>
				<ul>
					<li>
すべての`~redirect等$は `現在の文書$と`同一生成元$xからのものである，または
</li>
					<li>
（同一生成元からのものでない`~redirect等$もあるが）
~redirectされた どの資源
`の応答^tnote
も`計時~許可検査$に合格する。
</li>
				</ul>
<p>
が満たされるならば
⇒
最後の~redirectに対する応答の最後の~byteを受信した直後の時刻。
</p>
</li>
			<li>
他の場合
⇒
ゼロ。
</li>
		</ul>

<div lang="en">
<p>
If there are HTTP redirects or equivalent when fetching the resource and if all the redirects or equivalent are from the same origin as the current document, this attribute MUST return the time immediately after receiving the last byte of the response of the last redirect.
</p>
<p>
If there are HTTP redirects or equivalent when fetching the resource and if any of the redirects are not from the same origin as the current document, but the timing allow check algorithm passes for each redirected resource, this attribute MUST return the time immediately after receiving the last byte of the response of the last redirect. Otherwise, this attribute MUST return zero.
</p>
</div>
	</dd>


	<dt>readonly attribute DOMHighResTimeStamp `fetchStart@m</dt>
	<dd>
`~redirect等$が生じていない場合、この属性は，~UAが資源の`~fetch$xを開始する直前の時刻を返さ~MUST。
◎
If there are no HTTP redirects or equivalent, this attribute MUST return the time immediately before the user agent starts to fetch the resource.
</dd>
	<dd>
`~redirect等$が生じている場合、この属性は，~UAが資源の~redirectの中の最後の資源の`~fetch$xを開始する直前の時刻を返さ~MUST。
◎
If there are HTTP redirects or equivalent, this attribute MUST return the time immediately before the user agent starts to fetch the final resource in the redirection.
</dd>


	<dt>readonly attribute DOMHighResTimeStamp `domainLookupStart@m</dt>
	<dd>
この属性は、~UAが資源に対する~domain名~lookupを開始する直前の時刻を返さ~MUST。
`持続的~接続$x `RFC7230$r
が利用されている，または
資源が`局所~cache等$から検索取得されている場合、この属性は，
`fetchStart$m
と同じ値を返さ~MUST。
◎
This attribute MUST return the time immediately before the user agent starts the domain name lookup for the resource. If a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources, this attribute MUST return the same value as fetchStart.
</dd>
	<dd>
~redirectされなかった最後の資源`~fetch$xの生成元が，`現在の文書$のそれ同じでない場合、`計時~許可検査$に合格しない限り，この属性はゼロを返さ~MUST。
◎
If the last non-redirected fetch of the resource is not the same origin as the current document, domainLookupStart MUST return zero unless the timing allow check algorithm passes.
</dd>


	<dt>readonly attribute DOMHighResTimeStamp `domainLookupEnd@m</dt>
	<dd>
この属性は、~UAが資源に対する~domain名~lookupを終えた直後の時刻を返さ~MUST。
`持続的~接続$x `RFC7230$r
が利用されている，または
資源が`局所~cache等$から検索取得されている場合、この属性は，
`fetchStart$m
と同じ値を返さ~MUST。
◎
This attribute MUST return the time immediately after the user agent finishes the domain name lookup for the resource. If a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources, this attribute MUST return the same value as fetchStart.
</dd>
	<dd>
~domain情報が~UAの~cacheに残っている場合、［
`domainLookupStart$m ／ `domainLookupEnd$m
］は，~UAが~cacheからの~domain~dataの検索取得を［
開始した時刻／終えた時刻
］を表現する。
◎
If the user agent has the domain information in cache, domainLookupStart and domainLookupEnd represent the times when the user agent starts and ends the domain data retrieval from the cache.
</dd>
	<dd>
~redirectされなかった最後の資源`~fetch$xの生成元が，`現在の文書$のそれ同じでない場合、`計時~許可検査$に合格しない限り，この属性はゼロを返さ~MUST。
◎
If the last non-redirected fetch of the resource is not the same origin as the current document, domainLookupEnd MUST return zero unless the timing allow check algorithm passes.
</dd>


	<dt>readonly attribute DOMHighResTimeStamp `connectStart@m</dt>
	<dd>
この属性は、~UAが資源を検索取得するために，~serverとの接続の確立を開始する直前の時刻を返さ~MUST。
`持続的~接続$x `RFC7230$r
が利用されている，または
資源が`局所~cache等$から検索取得されている場合、この属性は，
`domainLookupEnd$m
の値を返さ~MUST。
◎
This attribute MUST return the time immediately before the user agent start establishing the connection to the server to retrieve the resource. If a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources, this attribute MUST return value of domainLookupEnd.
</dd>

	<dd>
~redirectされなかった最後の資源`~fetch$xの生成元が，`現在の文書$のそれ同じでない場合、`計時~許可検査$に合格しない限り，この属性はゼロを返さ~MUST。
◎
If the last non-redirected fetch of the resource is not the same origin as the current document, connectStart MUST return zero unless timing allow check algorithm passes.
</dd>


	<dt>readonly attribute DOMHighResTimeStamp `connectEnd@m</dt>
	<dd>
この属性は、~UAが資源を検索取得するために，~serverとの接続を確立した直後の時刻を返さ~MUST。
`持続的~接続$x `RFC7230$r が利用されている，または
資源が`局所~cache等$から検索取得されている場合、この属性は，
`domainLookupEnd$m
の値を返さ~MUST。
◎
This attribute MUST return the time immediately after the user agent finishes establishing the connection to the server to retrieve the resource. If a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources, this attribute MUST return the value of domainLookupEnd.
</dd>
	<dd>
~transport接続が失敗して，~UAが接続を再~openした場合、
`connectStart$m ／ `connectEnd$m
は、新たな接続に対応する値を返す~SHOULDである。
◎
If the transport connection fails and the user agent reopens a connection, connectStart and connectEnd SHOULD return the corresponding values of the new connection.
</dd>
	<dd>
`connectEnd$m には、SSL ~handshakeや SOCKS 認証などの他の所要時間も含む、~transport接続の確立に要した時間も含まれ~MUST。
◎
connectEnd MUST include the time interval to establish the transport connection, as well as other time intervals such as SSL handshake and SOCKS authentication.
</dd>
	<dd>
~redirectされなかった最後の資源`~fetch$xの生成元が，`現在の文書$のそれ同じでない場合、`計時~許可検査$に合格しない限り，この属性はゼロを返さ~MUST。
◎
If the last non-redirected fetch of the resource is not the same origin as the current document, connectEnd MUST return zero unless the timing allow check algorithm passes.
</dd>

	<dt>readonly attribute DOMHighResTimeStamp `secureConnectionStart@m</dt>
	<dd>
~secure~transportが利用されている場合、この属性は
~UAが現在の接続を~secureにする~handshake処理を開始する直前の時刻を返さ~MUST。 
他の場合はゼロを返さ~MUST。
`持続的~接続$x `RFC7230$r が利用されている, または
資源が`局所~cache等$から検索取得されている場合、この属性は，
`domainLookupEnd$m の値を返さ~MUST。
◎
When a secure transport is used, this attribute MUST return the time immediately before the user agent starts the handshake process to secure the current connection. If a secure transport is not used, this attribute MUST return zero. If a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources, this attribute MUST return value of domainLookupEnd.
</dd>
	<dd>
~redirectされなかった最後の資源`~fetch$xの生成元が，`現在の文書$のそれ同じでない場合、`計時~許可検査$に合格しない限り，この属性はゼロを返さ~MUST。
◎
If the last non-redirected fetch of the resource is not the same origin as the current document, secureConnectionStart MUST return zero unless the timing allow check algorithm passes.
</dd>


	<dt>readonly attribute DOMHighResTimeStamp `requestStart@m</dt>
	<dd>
この属性は、~UAが［
~serverから, または`局所~cache等$から
］の，資源への要請を開始する直前の時刻を返さ~MUST。
◎
This attribute MUST return the time immediately before the user agent starts requesting the resource from the server, or from relevant application caches or from local resources.
</dd>
	<dd>
要請の送信-後に~transport接続が失敗して，~UAが接続を再~openして要請を再送信した場合、その新たな要請に対応する値を返さ~MUST。
◎
If the transport connection fails after a request is sent and the user agent reopens a connection and resend the request, requestStart MUST return the corresponding values of the new request.
</dd>
	<dd>
~redirectされなかった最後の資源`~fetch$xの生成元が，`現在の文書$のそれ同じでない場合、`計時~許可検査$に合格しない限り，この属性はゼロを返さ~MUST。
◎
If the last non-redirected fetch of the resource is not the same origin as the current document, requestStart MUST return zero unless the timing allow check algorithm passes.
</dd>


	<dd class="note">
<p>注記：
この~interfaceは、要請の送信~完了を表現する
“`requestEnd^m” の類の属性は含まない。
◎
This interface does not include an attribute to represent the completion of sending the request, e.g., requestEnd.
</p>

<ul>
	<li>
~UAからの要請の送信~完了は、［
その種の属性が最も役立つ，~network~transportにおける 対応する完了~時刻
］を常に指示するものではない。
◎
Completion of sending the request from the user agent does not always indicate the corresponding completion time in the network transport, which brings most of the benefit of having such an attribute.
</li>

	<li>
一部の~UAは、HTTP 層の~encapsulationに因り，実際の完了~時刻を決定する~costが高くつく。
◎
Some user agents have high cost to determine the actual completion time of sending the request due to the HTTP layer encapsulation.
</li>
</ul>

	</dd>

	<dt>readonly attribute DOMHighResTimeStamp `responseStart@m</dt>
	<dd>
この属性は、~UAが，~serverから, または`局所~cache等$から，応答の最初の~byteを受信した直後の時刻を返さ~MUST。
◎
This attribute MUST return the time immediately after the user agent receives the first byte of the response from the server, or from relevant application caches or from local resources.
</dd>
	<dd>
~redirectされなかった最後の資源`~fetch$xの生成元が，`現在の文書$のそれ同じでない場合、`計時~許可検査$に合格しない限り，この属性はゼロを返さ~MUST。
◎
If the last non-redirected fetch of the resource is not the same origin as the current document, responseStart MUST return zero unless the timing allow check algorithm passes.
</dd>


	<dt>readonly attribute DOMHighResTimeStamp `responseEnd@m</dt>
	<dd>
この属性は、［
~UAが，~serverから, または`局所~cache等$から資源の最後の~byteを受信した直後の時刻
］, または［
~transport接続が~closeされた直前の時刻
］のうち，早い方を返さ~MUST。
◎
This attribute MUST return the time immediately after the user agent receives the last byte of the resource or immediately before the transport connection is closed, whichever comes first. The resource here can be received either from the server, relevant application caches or from local resources.
</dd>


	<dt>readonly attribute unsigned long long `transferSize@m</dt>
	<dd>
<p>
この属性は、［
`HTTP-network ~fetch$xから受信された，応答の［
一連の~header, および
`~payload本体$x
］に消費された~size
］を，~octet数で返さ~MUST
`RFC7230$r ：
◎
This attribute MUST return the size, in octets received from a HTTP-network fetch, consumed by the response header fields and the response payload body [RFC7230]:
</p>

		<ul>
			<li>
資源が`局所~cache等$から検索取得された場合、ゼロを返さ~MUST。
◎
If the resource is retrieved from relevant application caches or from local resources, it must return zero.
</li>
			<li>
~navigateするときに`~redirect等$があって，すべての`~redirect等$が同じ`生成元$x `RFC6454$r
からである場合、それらの~redirectにより被った HTTP ~overheadも含まれる~SHOULDである。
◎
If there are HTTP redirects or equivalent when navigating and if all the redirects or equivalent are from the same origin [RFC6454], this attribute SHOULD include the HTTP overhead of incurred redirects.
</li>
			<li>
資源に対する最後の非~redirect`~fetch$xが，`現在の文書$と同一生成元でない場合、`計時~許可検査$に合格しない限り，ゼロを返さ~MUST。
◎
If the last non-redirected fetch of the resource is not the same origin as the current document, transferSize MUST return zero unless the timing allow check algorithm passes.
</li>
		</ul>

	</dd>
	<dd>
この属性は、 HTTP ~overhead（
HTTP/1.1 `~chunked符号法$xや~headerの前後の空白（改行も含む）,
同じ~stream上の 他の［
~server→~client
］~frameに伴う
`HTTP/2$x
~frameによる~overhead）を含める~SHOULDである。
一方で、低層の~protocol ~overhead（ TLS や TCP によるものなど）は，含める~SHOULDでない。
◎
This attribute SHOULD include HTTP overhead (such as HTTP/1.1 chunked encoding and whitespace around header fields, including newlines, and HTTP/2 frame overhead, along with other server-to-client frames on the same stream), but SHOULD NOT include lower-layer protocol overhead (such as TLS or TCP).
</dd>
	<dd class="note">注記：
`transferSize$m 値が `encodedBodySize$m より低くなることもある：
~cacheされた応答が成功裡に再検証されとき、
`transferSize$m は，再検証の間に被った応答 HTTP ~headerたちの~sizeを報告し、
`encodedBodySize$m は，以前に検索取得された~payload本体の~sizeを報告する。
◎
Note
◎
It is possible for transferSize value to be lower than encodedBodySize: when a cached response is successfully revalidated the transferSize reports the size of the response HTTP headers incurred during the revalidation, and encodedBodySize reports the size of the previously retrieved payload body.
</dd>

	<dt>readonly attribute unsigned long long `encodedBodySize@m</dt>
	<dd>
<p>
この属性は、 `HTTP-network-or-cache ~fetch$xから受信された
`~payload本体$x `RFC7230$r の
— 適用されている
`内容~符号法$x `RFC7231$r
たちを復号する前の —
~octet数による~sizeを返さ~MUST：
◎
This attribute MUST return the size, in octets received from a HTTP-network-or-cache fetch, of the payload body [RFC7230], prior to removing any applied content-codings [RFC7231]:
</p>

		<ul>
			<li>
資源が`局所~cache等$から検索取得された場合、適用されている内容~符号法たちがあれば それを復号する前の，~payload本体の~sizeを返さ~MUST
◎
If the resource is retrieved from relevant application caches or from local resources, it must return the size of the payload body prior to removing any applied content-codings.
</li>
	<li>
資源に対する最後の非~redirect`~fetch$xが，`現在の文書$と同一生成元でない場合、`計時~許可検査$に合格しない限り，ゼロを返さ~MUST。
◎
If the last non-redirected fetch of the resource is not the same origin as the current document, encodedBodySize MUST return zero unless the timing allow check algorithm passes.
</li>
		</ul>
	</dd>
	<dd class="note">注記：
`encodedBodySize^m は、応答~codeに依存してゼロにもなることもある
— 例えば HTTP 204 (No Content), 3XX, 等々。
◎
The encodedBodySize may be zero depending on the response code - e.g. HTTP 204 (No Content), 3XX, etc.
</dd>


	<dt>readonly attribute unsigned long long `decodedBodySize@m</dt>
	<dd>
<p>
この属性は、`HTTP-network-or-cache ~fetch$xから受信された`~message本体$x† `RFC7230$r の
— 適用されている`内容~符号法$xたち `RFC7231$r を復号した後の —
~octet数による~sizeを返さ~MUST：
<span class="trans-note">【†
厳密には，`~payload本体$xであろう（`転送~符号法$xも復号される必要がある筈なので）
】</span>
◎
This attribute MUST return the size, in octets received from a HTTP-network-or-cache fetch, of the message body [RFC7230], after removing any applied content-codings [RFC7231]:
</p>

		<ul>
			<li>
資源が`局所~cache等$から検索取得された場合、適用されている内容~符号法たちがあればそれを復号した後の，~payloadの~sizeを返さ~MUST
◎
If the resource is retrieved from relevant application caches or from local resources, it must return the size of the payload after removing any applied content-codings.
</li>
	<li>
資源に対する最後の非~redirect`~fetch$xが，`現在の文書$と同一生成元でない場合、この属性は，`計時~許可検査$に合格しない限り，ゼロを返さ~MUST。
◎
If the last non-redirected fetch of the resource is not the same origin as the current document, decodedBodySize MUST return zero unless the timing allow check algorithm passes.
</li>
		</ul>
	</dd>
</dl>

			</section>
			<section id="serializer">
<h3 title="Serializer">4.3.2 直列化子</h3>

<dl class="idl-defs">
	<dt>serializer = { inherit, attribute }</dt>
	<dd>
最も近い継承~interfaceの~entry, および各 直列化-可能な属性からなる map として直列化される。
`WebIDL の <a href="WebIDL-ja.html#dfn-serialization-pattern">直列化~pattern</a>の記述を~~参照。^tnote
◎
Instances of this interface are serialized as a map with entries from the closest inherited interface and with entries for each of the serializable attributes.
</dd>

</dl>
			</section>
		</section>
		<section id="extensions-performance-interface">

<h3 title="Extensions to the Performance Interface">4.4. `Performance^I ~interfaceに対する拡張</h3>


<p>
各 `ECMAScript 大域~環境$xは、次のものを持つ：
◎
Each ECMAScript global environment has:
</p>

<ul>
	<li>
`資源~計時~buffer~size上限@
— 初期~時は 150 以上。
`上限の程度は~UAに委ねられる。^tnote
◎
a resource timing buffer size limit which should initially be 150 or greater.
</li>

	<li>
`資源~計時~buffer現size@
— 初期~時は 0 。
◎
a resource timing buffer current size which is initially 0.
</li>

	<li>
`資源~計時~buffer満杯~flag@
— 初期~時は ~OFF 。
◎
a resource timing buffer full flag which is initially false.
</li>

</ul>

<!-- 
`Performance@I
-->

⇒！
partial interface `Performance@I {
  void `clearResourceTimings$m();
  void `setResourceTimingBufferSize$m(unsigned long %maxSize);

  attribute EventHandler `onresourcetimingbufferfull$m;
};
◎



<dl class="idl-defs">

	<dt>void `clearResourceTimings@m()</dt>
	<dd>
<p>
被呼出時には、次を実行し~MUST：
◎
The method clearResourceTimings runs the following steps:
</p>
		<ol>
			<li>
`処理能~entry~buffer$x内から
すべての `PerformanceResourceTiming$I ~objectを除去する
◎
remove all PerformanceResourceTiming objects in the performance entry buffer.
</li>
			<li>
`資源~計時~buffer現size$ ~SET 0
◎
set resource timing buffer current size to 0.
</li>
			<li>
`資源~計時~buffer満杯~flag$ ~SET ~OFF
◎
set resource timing buffer full flag to false.
</li>
		</ol>
	</dd>

	<dt>void `setResourceTimingBufferSize@m(unsigned long %maxSize)</dt>
	<dd>
<p>
被呼出時には、次を実行し~MUST：
◎
The setResourceTimingBufferSize method runs the following steps:
</p>

		<ol>
			<li>
<p>
`資源~計時~buffer~size上限$ ~SET `maxSize^v
</p>
<p>
［
`maxSize^v ~LT `資源~計時~buffer現size$
］であっても，`処理能~entry~buffer$xからは
`PerformanceResourceTiming$I ~objectを除去しない。
</p>
◎
Set resource timing buffer size limit to the maxSize parameter. If the maxSize parameter is less than resource timing buffer current size, no PerformanceResourceTiming objects are to be removed from the performance entry buffer.
</li>
			<li>
`資源~計時~buffer満杯~flag$ ~SET ~OFF
◎
Set resource timing buffer full flag to false.
</li>
		</ol>
	</dd>

	<dt>`EventHandler^I `onresourcetimingbufferfull@m</dt>
	<dd>
`resourcetimingbufferfull^et ~eventに対する~event~handler。
◎
The attribute onresourcetimingbufferfull is the event handler for the resourcetimingbufferfull event.
</dd>

</dl>


<p>
`処理能~entry~buffer$xに新たな
`PerformanceResourceTiming$I ~entry `~entry^v を
`追加する@
ときは、次の手続きを実行する：
◎
To add a PerformanceResourceTiming entry (new entry) in the performance entry buffer, run the following steps:
</p>

<ol>
	<li>
<p>
~IF［
`資源~計時~buffer現size$ ~LT `資源~計時~buffer~size上限$
］：
◎
If resource timing buffer current size is less than resource timing buffer size limit, run the following substeps:
</p>
		<ol>
			<li>
`処理能~entry~buffer$xに `~entry^v を追加する
◎
Add new entry to the performance entry buffer.
</li>
			<li>
`資源~計時~buffer現size$ ~INCBY 1
◎
increase resource timing buffer current size by 1.
</li>
		</ol>
	</li>

	<li>
<p>
~IF［
`資源~計時~buffer現size$ ~EQ `資源~計時~buffer~size上限$
］~AND［
`資源~計時~buffer満杯~flag$ ~EQ ~OFF
］：
◎
If resource timing buffer current size is equal to resource timing buffer size limit and resource timing buffer full flag is false, run the following substeps:
</p>
		<ol>
			<li>
`Document^I に向けて，次のようにされた`単純~eventを発火$xする
⇒
名前 `resourcetimingbufferfull$et,<br>
`bubbles^a 属性 ~SET ~T に初期化-,<br>
既定~動作なし
◎
fire a simple event named resourcetimingbufferfull at the Document, with its bubbles attribute initialized to true, and has no default action.
</li>
			<li>
`資源~計時~buffer満杯~flag$ ~SET ~ON
◎
set the resource timing buffer full flag to true.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="cross-origin-resources">
<h3>4.5. 非同一生成元~資源</h3>

<p>
`非同一生成元$資源は、
`PerformanceResourceTiming$I ~objectとして
`処理能時系列線$xに含められ~MUST。
`非同一生成元$資源に対する`計時~許可検査$に合格しなかった場合、その
`PerformanceResourceTiming$I
~objectの属性のうち，次のものは、ゼロにされ~MUST：
`redirectStart$m,
`redirectEnd$m,
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m,
`requestStart$m,
`responseStart$m,
`secureConnectionStart$m
◎
Cross-origin resources MUST be included as PerformanceResourceTiming objects in the Performance Timeline. If the timing allow check algorithm fails for a cross-origin resource, these attributes of its PerformanceResourceTiming object MUST be set to zero: redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart and secureConnectionStart.
</p>

<p>
~server側~appは、この節で前に指定された，［
さもなければ`非同一生成元$の制約から値がゼロにされる属性
］の，~UAにおける公開を許容するために、当該の文書~生成元を値とする
`Timing-Allow-Origin$h HTTP 応答~header返してもよい。
◎
Server-side applications may return the Timing-Allow-Origin HTTP response header to allow the User Agent to fully expose, to the document origin(s) specified, the values of attributes that would have been zero due to the cross-origin restrictions previously specified in this section.
</p>

			<section id="timing-allow-origin">
<h4>4.5.1. `Timing-Allow-Origin^h 応答~header</h4>


<p>
`Timing-Allow-Origin@h
~headerは、［
応答の中に `Origin^h 要請~headerの値を返すかどうか
］に基づいて，資源の計時を共有し得るかどうかを指示する。
◎
The header indicates whether a resource's timing can be shared based by returning the value of the Origin request header in the response.
</p>

<p>
その ABNF は次で与えられる：
◎
ABNF:
</p>

<pre class="ABNF">
Timing-Allow-Origin = "Timing-Allow-Origin" ":" `origin-list-or-null$p | "*"
</pre>

<p>
`計時~許可検査@
~algoは、資源の計時~情報が`現在の文書$と共有し得るかどうかを，以下に従って検査する：
◎
The timing allow check algorithm, which checks whether a resource's timing information can be shared with the current document, is as follows:
</p>

<ol>
	<li>
資源が`非同一生成元$でなければ、 `合格^i を返す
◎
If the resource is not cross-origin, return pass.
</li>

	<li>
<p>
HTTP 応答がゼロ個，または複数個の
`Timing-Allow-Origin$h
~header値たち†を含むならば、 `不合格^i を返す
◎
If the HTTP response includes zero or more than one Timing-Allow-Origin header values, return fail and terminate this algorithm.
</p>

<p class="trans-note">【
原文には “header” でなく， “header <em>values</em>” と記されている。
下の注記から、この~header自体は 1 個であっても，その `origin-list-or-null$p が複数個の成分値からなる場合も `不合格^i にされると考えられる。
】</p>
	</li>

	<li>
他の場合、［
`Timing-Allow-Origin$h の~header値が［
文字 `*^l であるか, または
`現在の文書$の`生成元$xに合致する（`文字大小区別$x）
］ならば，`合格^i ／
そうでなければ，`不合格^i
］を返す
◎
If the Timing-Allow-Origin header value is the "*" character, return pass and terminate this algorithm.
◎
If the value of Timing-Allow-Origin is not a case-sensitive match for the value of the origin of the current document, return fail and terminate this algorithm.
◎
Return pass.
</li>
</ol>


<p class="note">注記：
上の~algoは、`生成元の ASCII 直列化$xが文字列 `null^l であっても機能する。
これは，概して、複数の~redirectがあって,
`XMLHttpRequest$I ~objectから起動された場合に該当する。
◎
The above algorithm also functions when the ASCII serialization of an origin is the string "null". Typically, this is the case when there are multiple redirects and the initiator is an XMLHttpRequest object.
</p>

<p class="note">注記：
実施においては、
`origin-list-or-null$p
生成規則は，より拘束されたものにされている。
`生成元$xの~space区切りの~listではなく，１個の`生成元$xであるか, または文字列 `null^l である。
◎
In practice the origin-list-or-null production is more constrained. Rather than allowing a space-separated list of origins, it is either a single origin or the string "null".
</p>


			</section>
		</section>
	</section>
	<section id="process">
<h2 title="Process">5. 処理過程</h2>

		<section id="processing-model">
<h3 title="Processing Model">5.1. 処理~model</h3>

<p>
`PerformanceResourceTiming$I
~interfaceに定義される計時~属性を次の図式に示す。
下線がひかれている属性については、資源が異なる<a href="#same-origin">生成元</a>から`~fetch$xされている下では，可用でない。
~UAは、非標準の時区間を許容するために，２つの計時の合間に内部~処理を行ってもよい。
◎
The following graph illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes underlined may not be available when fetching resources from different origins. User agents may perform internal processing in between timings, which allow for non-normative intervals between timings.
</p>

<figure style="overflow:auto;min-height:372px;"><img
	src="resource-timing/resource-timing-overview-1.png"
	alt="Resource Timing attributes"
></figure>


<p class="trans-note">【
以下の~algoの記述に利用されている各種記号（
~LET （初期化-）, ~SET （代入）,
~IF, ~ELSE（実行制御）, 等々
）の詳細は，~SYMBOL_DEF_REFを~~参照。
】</p>


<p>
現在の`閲覧文脈$xにおいて
<a href="~FETCH#concept-fetch">~fetch</a>
される
~EACH ( 資源 ) に対し：
◎
For each resource fetched by the current browsing context, excluding resources fetched by cross-origin stylesheets fetched with no-cors policy, perform the following steps:
</p>


<ol>
	<li>
<p>
~IF［
資源は
`no-cors^i ~policyの下で~fetchされる
非同一生成元~stylesheetである
］
⇒
~CONTINUE
◎
↑</p>

<p class="issue">
この非同一生成元の除外は、
Fetch registry を介して定義されるべきである：
CSS については、 Fetch の用語, および［
no-CORS CSS 下位資源に対し
何らかの “不透明な要請~flag” のような類の~flagを ~ON にすること
］を通して定義される必要がある。
しかる後、 Resource Timing において，資源~fetch~eventを表面化させるために
Fetch registry と~interfaceするべきである。
◎
Issue 1
◎
Above cross-origin exclusion should be defined via Fetch registry: CSS needs to be defined in terms of Fetch and set some kind of "opaque request flag" for no-CORS CSS subresources. In turn, Resource Timing should interface with Fetch registry to surface resource fetch events.
</p>
	</li>

	<li>
`~object作成@i：

<p>
%object ~SET 新たな `PerformanceResourceTiming$I ~object
</p>

<p>
%object の `entryType$m ~SET `resource^l
</p>
◎
Create a new PerformanceResourceTiming object and set entryType to the DOMString resource.
</li>

	<li>
資源の検索取得を待行列に入れる直前に
⇒
%object の `startTime$m に`現在の時刻$を記録する；<br />
%object の `nextHopProtocol$m ~SET 空 `DOMString^I
◎
Immediately before the user agent starts to queue the resource for retrieval, record the current time in startTime, and set nextHopProtocol to the empty DOMString.
</li>

	<li>
%object の `initiatorType$m ~SET 資源の起動元
◎
Record the initiator of the resource in initiatorType.
</li>


	<li>
		<ol>
			<li>
%object の `name$m ~SET 要請した資源の`解決済み URL$x
</li>
			<li>
<p>
~IF
現在の［
`閲覧文脈$x `HTML5$r ／ ~worker文脈 `WORKERS$r
］に`合致する~active~worker$x
`SERVICE-WORKERS$r
がある：
</p>
				<ol>
					<li>
~IF
~workerがすでに可用である
⇒
その`~active~worker$xに向けて`名前~fetch_evの~eventを発火する$x直前に
⇒
%object の `workerStart$m に`現在の時刻$を記録する
</li>
					<li>
~ELSE
⇒
その`~workerを走らす$x†直前に
⇒
%object の `workerStart$m に`現在の時刻$を記録する
</li>
				</ol>
<p class="trans-note">【†
~link先が変？ `run a worker$x ？
】</p>
			</li>

			<li>
~ELSE（合致する`~service~worker登録$xがない）
⇒
%object の `workerStart$m ~SET 0
</li>
		</ol>

◎
Record the resolved URL of the requested resource in name. If there is an active worker ([SERVICE-WORKERS]) matching the current browsing or worker context's, immediately before the user agent runs the worker record the time as workerStart, or if the worker is already available, immediately before the event named `fetch` is fired at the active worker record the time as workerStart. Otherwise, if there is no matching service worker registration, set workerStart value to zero.
</li>

	<li id="step-fetch-start">
`~fetch開始@i：
<p>
`~fetching$x を開始する直前に
⇒
%object の `fetchStart$m に`現在の時刻$を記録する；<br />
%object の［
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m
］ ~SET %object の `fetchStart$m と同じ値
</p>

◎
Immediately before a user agent starts the fetching process, record the current time as fetchStart. Let domainLookupStart, domainLookupEnd, connectStart and connectEnd be the same value as fetchStart.
</li>

	<li>
`収集~開始@i：
<p>
~IF ［
別の既存の~data, あるいは すでに完了した［
`現在の文書$から起動された`~fetch$x
］による~dataを再利用する
］
⇒
残りの手続きを中止-
</p>
◎
If the user agent is to reuse the data from another existing or completed fetch initiated from the current document, abort the remaining steps.
</li>

	<li>
~IF
`~fetch$xが何らかの事由で中止された
⇒
残りの手続きを中止-
◎
If fetching the resource is aborted for any reason, abort the remaining steps.
</li>

	<li>
<p>
~IF ［
~redirectされなかった最後の資源`~fetch$xの生成元が`現在の文書$とそれと同じでない
］~AND ［
`計時~許可検査$にも合格しなかった
］：
</p>
		<ol>
			<li>
%object の［
`redirectStart$m,
`redirectEnd$m,
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m,
`requestStart$m,
`responseStart$m,
`secureConnectionStart$m
］属性 ~SET ゼロ
</li>
			<li>
~GOTO `応答~終了0$i
</li>
		</ol>

◎
If the last non-redirected fetch of the resource is not the same origin as the current document and the timing allow check algorithm fails, the user agent MUST set redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart and secureConnectionStart to zero and go to step 3.17.
</li>

	<li>
%object の［
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m
］属性 ~SET %object の `fetchStart$m と同じ値
◎
Let domainLookupStart, domainLookupEnd, connectStart and connectEnd be the same value as fetchStart.
</li>

	<li>
~IF 資源は`局所~cache等$（ `HTTP ~cache$x `RFC7234$r も含む）から~fetchされている
⇒
~GOTO `要請~開始$i
◎
If the resource is fetched from the relevant application cache or local resources, including the HTTP cache [RFC7234], go to step 3.15.
</li>

	<li>
<p>
~IF ~domain~lookupは不要
⇒
~GOTO `接続-開始$i
</p>

<p>
~domain名~lookupを開始する直前に
⇒
%object の `domainLookupStart$m に`現在の時刻$を記録する
</p>
◎
If no domain lookup is required, go to step 3.13. Otherwise, immediately before a user agent starts the domain name lookup, record the time as domainLookupStart.
</li>

	<li>
<p>
~IF
~domain~lookupに失敗した
⇒
残りの手続きを中止-
</p>

<p>
~domain名~lookupを成功裡に終えた†直後に
⇒
%object の `domainLookupEnd$m に`現在の時刻$を記録する
</p>

<p>†
~UAは、その前に複数の再試行を要し得る。
</p>

◎
Record the time as domainLookupEnd immediately after the domain name lookup is successfully done. A user agent may need multiple retries before that. If the domain lookup fails, abort the remaining steps.
</li>

	<li>
`接続-開始@i：

<p>
~IF
資源の`~fetch$xに持続的~transport接続が利用されている
⇒
%object の［
`connectStart$m, `connectEnd$m
］ ~SET %object の `domainLookupEnd$m と同じ値
</p>

<p>
~ELSE：
</p>
		<ol>
			<li>
~serverへの接続を起動する直前に
⇒
%object の `connectStart$m に`現在の時刻$を記録する
</li>
			<li>
~IF
接続を確立できなかった
⇒
残りの手続きを中止-
</li>
			<li>
~serverまたは~proxyとの接続が確立された†直後に
⇒
%object の `connectEnd$m に`現在の時刻$を記録する；<br />
%object の `nextHopProtocol$m 値 ~SET 接続に利用されている ALPN ID
</li>
		</ol>
<p>
†~UAは、この時点より前に複数の再試行を要し得る。
</p>
◎
If a persistent transport connection is used to fetch the resource, let connectStart and connectEnd be the same value of domainLookupEnd. Otherwise, record the time as connectStart immediately before initiating the connection to the server and record the time as connectEnd immediately after the connection to the server or the proxy is established. A user agent may need multiple retries before this time. Once connection is established set the value of nextHopProtocol to the ALPN ID used by the connection. If a connection can not be established, abort the remaining steps.
</li>
	<li>
~IF
~secure~transportが利用されている
⇒
接続を~secureにする~handshake処理-の直前に
⇒
%object の `secureConnectionStart$m に`現在の時刻$を記録する
◎
The user agent MUST set the secureConnectionStart attribute as follows:
◎
When a secure transport is used, the user agent MUST record the time as secureConnectionStart immediately before the handshake process to secure the connection.
</li>

	<li>
~ELSE
⇒
%object の `secureConnectionStart$m ~SET 0
◎
When a secure transport is not used, the user agent MUST set the value of secureConnectionStart to 0.
</li>

	<li>
`要請~開始@i：

<p>
資源に対する要請の送信を開始する直前に
⇒
%object の `requestStart$m に`現在の時刻$を記録する
◎
Immediately before a user agent starts sending the request for the resource, record the current time as requestStart.
</li>

	<li>
`応答~開始@i：
<p>
応答の最初の~byteを受信した直後に
⇒
%object の `responseStart$m に`現在の時刻$を記録する
◎
Record the time as responseStart immediately after the user agent receives the first byte of the response.
</li>

	<li>
`応答~終了0@i：

<p>
応答の最後の~byteを受信した直後に
⇒
%object の `responseEnd$m に`現在の時刻$を記録する
◎
Record the time as responseEnd immediately after receiving the last byte of the response.
</p>
		<ol>
			<li>
<p>
~IF
要請の送信-, または応答~全体の受信-に失敗し，接続を再~openする必要がある
⇒
~GOTO `接続-開始$i
◎
Return to step 3.13 if the user agent fails to send the request or receive the entire response, and needs to reopen the connection.
</p>

<div class="example">
<p>
例えば，`持続的~接続$x `RFC7230$r が可能化されているときは、まず最初に，要請を送信するための~open接続の再利用を（その接続は`非同期に~close$xされ得るが）試行してよい。
そのような場合、［
`connectStart$m,
`connectEnd$m,
`requestStart$m
］は，再~open接続において収集された計時~情報を表現するべきである。
◎
When persistent connection [RFC7230] is enabled, a user agent may first try to re-use an open connect to send the request while the connection can be asynchronously closed. In such case, connectStart, connectEnd and requestStart SHOULD represent timing information collected over the re-open connection.
</p>
</div>
			</li>
			<li>
%object の［
`transferSize$m,
`encodedBodySize$m, 
`decodedBodySize$m
］ ~SET それぞれの属性の定義に従う値
— これらは、`計時~許可検査$の対象になる。
◎
Set the value of transferSize, encodedBodySize, decodedBodySize to corresponding values, subject to timing allow check algorithm.
</li>
		</ol>
	</li>

	<li>
%object の `duration$m ~SET
%object の［
`responseEnd$m と `startTime$m
］の差分
◎
Record the difference between responseEnd and startTime in duration.
</li>

	<li>
<p>
~IF
資源が~fetchされた結果が`~redirect等$になった：
◎
If the fetched resource results in an HTTP redirect or equivalent, then
</p>

		<ol style="list-style-type:lower-alpha;">
			<li>
`新たな資源^v ~SET ~redirect先の資源
</li>

			<li>
~IF ［
現在の資源と `新たな資源^v が`現在の文書$と`同一生成元$xからのものでない
］~AND［
いずれの資源も`計時~許可検査$に合格しない
］
⇒
%object の［
`redirectStart$m, `redirectEnd$m
］~SET 0
◎
If the current resource and the redirected resource are not from the same origin as the current document, and the timing allow check algorithm fails for either resource, set redirectStart and redirectEnd to 0. Then, return to step 3.5 with the new resource.
</li>
			<li>
<p >
~ELSE：
</p>
				<ol>
					<li>
~IF
%object の `redirectStart$m の値がまだ設定されていない
⇒
%object の `redirectStart$m ~SET %object の `fetchStart$m の値
◎
If the value of redirectStart is not set, let it be the value of fetchStart.
</li>
					<li>
%object の `redirectEnd$m ~SET %object の `responseEnd$m の値
◎
Let redirectEnd be the value of responseEnd.
</li>
					<li>
［［
`startTime$m,
`redirectStart$m,
`redirectEnd$m,
`initiatorType$m
］を除く，
%object のすべての属性
］ ~SET 0 
◎
Set all the attributes in the PerformanceResourceTiming object to 0 except startTime, redirectStart, redirectEnd, and initiatorType.
</li>
				</ol>
			</li>

			<li>
資源 ~SET `新たな資源^v
</li>
			<li>
~GOTO `~fetch開始$i
◎
Return to step 3.5 with the new resource.
</li>
		</ol>
	</li>

	<li>
`PerformanceResourceTiming$I ~objectを`待入する$。
◎
Queue the PerformanceResourceTiming object.
</li>

	<li>
`PerformanceResourceTiming$I ~objectを`追加する$
◎
Add the PerformanceResourceTiming object.
</li>

</ol>

		</section>
		<section id="monotonic-clock">
<h3 title="Monotonic Clock">5.2. 単調増加~clock</h3>
<p>
計時~属性の値は、資源`~fetch$xの間，計時~属性が~system~clock調整により~skewされないように、単調増加で~MUST。
時系列順に記録された２つの計時~属性の差分は決して負であっては~MUST_NOT。
文書の下位~資源も含めた，すべての資源において、~UAは根元の文書~navigationの開始時点の~system~clockを記録し，後続の計時~属性は、~navigationの開始からの経過時間を測定する単調増加~clockの下で定義され~MUST。
◎
The value of the timing attributes MUST monotonically increase to ensure timing attributes are not skewed by adjustments to the system clock while fetching the resource. The difference between any two chronologically recorded timing attributes MUST never be negative. For all resources, including subdocument resources, the user agent MUST record the system clock at the beginning of the root document navigation and define subsequent timing attributes in terms of a monotonic clock measuring time elapsed from the beginning of the navigation.
</p>

		</section>
	</section>
	<section id="privacy-security">
<h2 title="Privacy and Security">6. ~privacyと~security</h2>

~INFORMATIVE

<p>
`PerformanceResourceTiming$I
~interfaceは、資源を要請した［
~web~page／~worker
］に，その資源の計時~情報を公開する。
`PerformanceResourceTiming$I ~interfaceへの~accessを制限するため、既定では`同一生成元$x~policyが課せられ，
<a href="#cross-origin-resources">非同一生成元~資源</a>
節にて述べたように，一部の属性はゼロに設定される。
資源の提供側は、 `Timing-Allow-Origin$h HTTP 応答~headerを追加して，その値に
計時~情報への~accessを許容する~domainを指定することにより，資源に対するすべての計時~情報の収集を明示的に許容できる。
◎
The PerformanceResourceTiming interface exposes timing information for a resource to any web page or worker that has requested that resource. To limit the access to the PerformanceResourceTiming interface, the same origin policy is enforced by default and certain attributes are set to zero, as described in 4.5 Cross-origin Resources. Resource providers can explicitly allow all timing information to be collected for a resource by adding the Timing-Allow-Origin HTTP response header, which specifies the domains that are allowed to access the timing information.
</p>

<p>
統計上の痕跡（ statistical fingerprinting ）は、悪意的な~web~siteが、第三者~web~site内の資源に対する~cacheの~hit／~missの時機を測定することにより、利用者が第三者~web~siteを訪問したかどうかを決定し得る点で、~privacyに関わる問題になる。
`PerformanceResourceTiming$I
~interfaceは，文書~内の資源の計時~情報を供するが、
<a href="#cross-origin-resources">非同一生成元の制約</a>
があるため、この~privacyの懸念を，［
今日すでにある，資源に対する load ~eventから時機を測定して~cacheの~hit／~missを決定する手法
］より，悪化させるものにはならない。
◎
Statistical fingerprinting is a privacy concern where a malicious web site may determine whether a user has visited a third-party web site by measuring the timing of cache hits and misses of resources in the third-party web site. Though the PerformanceResourceTiming interface gives timing information for resources in a document, the cross-origin restrictions prevent making this privacy concern any worse than it is today using the load event on resources to measure timing to determine cache hits and misses.
</p>

	</section>

</main></div><!-- id="MAIN"／MAIN0 -->

	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕事に寄与された次の方々に謝意を表したい：
</p>

<p>
We would like to sincerely thank Karen Anderson, Darin Fisher, Tony Gentilcore, Nic Jansma, Kyle Scholz, Jonas Sicking, James Simonsen, Steve Souders, Annie Sullivan, Sigbjørn Vik, Jason Weber to acknowledge their contributions to this work.
</p>

	</section>
	<section id="references">
<h2 title="References">参照文献</h2>


		<section id="normative-references">
<h3 title="Normative References">文献（規範）</h3>

<dl>

	<dt>[CSS-SYNTAX-3]</dt>
	<dd>Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. W3C Candidate Recommendation.</dd>
	<dd>http://www.w3.org/TR/css-syntax-3/</dd>

	<dt>[DOM]</dt>
	<dd>Anne van Kesteren; Aryeh Gregor; Ms2ger; Alex Russell; Robin Berjon. W3C DOM4. 19 November 2015. W3C Recommendation.</dd>
	<dd>http://www.w3.org/TR/dom/</dd>

	<dt>[HR-TIME-2]</dt>
	<dd>Ilya Grigorik; James Simonsen; Jatinder Mann. High Resolution Time Level 2. 4 February 2016. W3C Working Draft.</dd>
	<dd>http://www.w3.org/TR/hr-time-2/</dd>

	<dt>[HTML5]</dt>
	<dd>Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Edward O'Connor; Silvia Pfeiffer. HTML5. 28 October 2014. W3C Recommendation.</dd>
	<dd>http://www.w3.org/TR/html5/</dd>

	<dt>[PERFORMANCE-TIMELINE-2]</dt>
	<dd>Ilya Grigorik. Performance Timeline Level 2. 7 December 2015. W3C Working Draft.</dd>
	<dd>http://www.w3.org/TR/performance-timeline-2/</dd>

	<dt>[RFC2119]</dt>
	<dd>S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc2119</dd>

	<dt>[RFC2397]</dt>
	<dd>L. Masinter. The "data" URL scheme. August 1998. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc2397</dd>

	<dt>[RFC6454]</dt>
	<dd>A. Barth. The Web Origin Concept. December 2011. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc6454</dd>

	<dt>[RFC7230]</dt>
	<dd>R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc7230</dd>

	<dt>[RFC7231]</dt>
	<dd>R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc7231</dd>

	<dt>[RFC7234]</dt>
	<dd>R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Caching. June 2014. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc7234</dd>

	<dt>[RFC7301]</dt>
	<dd>S. Friedl; A. Popov; A. Langley; E. Stephan. Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension. July 2014. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc7301</dd>

	<dt>[SERVICE-WORKERS]</dt>
	<dd>Alex Russell; Jungkee Song; Jake Archibald. Service Workers. 25 June 2015. W3C Working Draft.</dd>
	<dd>http://www.w3.org/TR/service-workers/</dd>

	<dt>[WORKERS]</dt>
	<dd>Ian Hickson. Web Workers. 24 September 2015. W3C Working Draft.</dd>
	<dd>http://www.w3.org/TR/workers/</dd>

	<dt>[WebIDL]</dt>
	<dd>Cameron McCormack; Boris Zbarsky. WebIDL Level 1. 4 August 2015. W3C Working Draft.</dd>
	<dd>http://www.w3.org/TR/WebIDL-1/</dd>

	<dt>[XMLHttpRequest]</dt>
	<dd>Anne van Kesteren; Julian Aubourg; Jungkee Song; Hallvord Steen et al. XMLHttpRequest Level 1. 30 January 2014. W3C Working Draft.</dd>
	<dd>http://www.w3.org/TR/XMLHttpRequest/</dd>
</dl>

		</section>
		<section id="informative-references">
<h3 title="Informative References">文献（参考）</h3>

<dl>
	<dt>[ECMA-262]</dt>
	<dd>ECMAScript Language Specification.</dd>
	<dd>https://tc39.github.io/ecma262/</dd>

	<dt>[NAVIGATION-TIMING]</dt>
	<dd>Zhiheng Wang. Navigation Timing. 17 December 2012. W3C Recommendation.</dd>
	<dd>http://www.w3.org/TR/navigation-timing/</dd>

	<dt>[NAVIGATION-TIMING-2]</dt>
	<dd>Tobin Titus; Jatinder Mann; Arvind Jain. Navigation Timing Level 2. 5 February 2016. W3C Working Draft.</dd>
	<dd>http://www.w3.org/TR/navigation-timing-2/</dd>

	<dt>[SVG11]</dt>
	<dd>Erik Dahlström; Patrick Dengler; Anthony Grasso; Chris Lilley; Cameron McCormack; Doug Schepers; Jonathan Watt; Jon Ferraiolo; Jun Fujisawa; Dean Jackson et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. W3C Recommendation.</dd>
	<dd>http://www.w3.org/TR/SVG11/</dd>

</dl>


		</section>
	</section>


</body></html>

