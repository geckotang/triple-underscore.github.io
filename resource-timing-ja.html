<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Resource Timing Level 2 — リソース計時（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
var source_data;

COMMON_DATA.page_state_key = '___TIMING';
COMMON_DATA.init = function(expanded){
	var options = {
//		original_url: 'https://www.w3.org/TR/resource-timing/',
		original_url: 'https://w3c.github.io/resource-timing/',
		spec_status: 'ED',
		main: 'MAIN',
		fill_text_link: '#_versions > dd',
		ref_data: '.ref_data',
		ref_id_prefix: 'bib-',
//		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

// Util.del_j(); // checked: 151125-WD

	return options;
}

function expand(mapping1){

	var class_map = {
		h: 'header',
		e: 'element',
		a: 'attr',
//		l: 'literal',
		st: 'status-code',
		et: 'event-type',
		P: 'production',
		css: 'css',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		c: 'code',
		h: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		st: 'code',
		P: 'code',
		css: 'code',
//		l: 'code',
		v: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
	var idl_ifc = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒！?|◎[^<◎]*|%\w+|`(.+?)([$@!\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){


if(!key) {
	switch(match[0]){
	case '⇒':
		if(match.charAt(1) === '！'){
			in_idl = true;
			nesting += '</pre>';
			return '<pre class="idl">';
		} else {
			nesting += '</span>';
			return '：<span class="block">';
		}
/*
	case '【':
return '<span class="trans-note">' + match + '</span>'
*/
	case '%':
		return '<var>' + match.slice(1) + '</var>';
	}//◎
	if(in_idl) {
		result = nesting;
		in_idl = false;
	} else {
		result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	}
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"'
	break;
case 'I': // IDL interface
//＊	href = '#' + key;
	if(in_idl) tag = '';
	break;
case 'm': // IDL member
//＊	href = '#widl-PerformanceResourceTiming-' + key;
	if(in_idl) tag = '';
	break;
case 'et': // event-type
	break;
case 'v': // variables
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
default: //
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;


	}
}

</script>



<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
cache-or-local:
full:
redirect-or-equivalents:
cache-or-local:

	PerformanceResourceTiming:idl-def-PerformanceResourceTiming
	Performance:idl-def-performance-partial-1
	Performance:idl-def-performance

</script>

<!--%links 

"css":#css-resource
"xmlhttprequest":#xhr-resource

3XX:http://httpwg.org/specs/rfc7231.html#rfc.section.6.4
DOM:#dfn-dom
HTTP 204 (No Content):http://httpwg.org/specs/rfc7231.html#status.204
HTTP cache:~IETF/rfc7234

JavaScript:#dfn-javascript
Performance Timeline:~TIMELINE#sec-performance-timeline
Queue:~TIMELINE#dfn-queue-a-performanceentry
	Surfacing failed fetches:https://github.com/w3c/resource-timing/pull/19/commits/0eb0f6997fc3f8a70a556212b45fa9ce5cfe7631
	Window object's newest Document object:~HTML50/browsers.html#dom-document-0
	'

	conforming IDL fragments:~WEBIDL#dfn-conforming-idl-fragment
content-codings:http://httpwg.org/specs/rfc7231.html#data.encoding
data: URI:~IETF/rfc2397

element:https://www.w3.org/TR/dom/#concept-element

equivalent:~HTML50/infrastructure.html#concept-http-equivalent-codes
event named `fetch` is fired:~SW#on-fetch-request-algorithm
fetch:~HTML50/infrastructure.html#fetch
fetched:~FETCH#concept-fetch
fetched:~HTML50/infrastructure.html#fetch
fetches:~HTML50/infrastructure.html#fetch
fetching process:~HTML50/infrastructure.html#fetch
fetching:~HTML50/infrastructure.html#fetch
fire a simple event:~HTML50/webappapis.html#fire-a-simple-event
fires an event named `fetch`:~SW#on-fetch-request-algorithm
getting:#dfn-getting

	localName:https://www.w3.org/TR/dom/#concept-element-local-name
message body:http://httpwg.org/specs/rfc7230.html#message.body

payload body:http://httpwg.org/specs/rfc7230.html#message.body
payload:http://httpwg.org/specs/rfc7230.html#message.body

processing model:#processing-model
requestEnd:#dfn-requestend
resolved URL:~HTML50/infrastructure.html#resolve-a-url
response code:http://httpwg.org/specs/rfc7231.html#status.codes

setting:#dfn-setting
start of navigation of the document:https://w3c.github.io/navigation-timing/#widl-PerformanceNavigationTiming-startTime



-->
<script type="text/plain" id="_link_map">

	●IDL
I.PerformanceResourceTiming:#idl-def-performanceresourcetiming
I.XMLHttpRequest:~XHR#interface-xmlhttprequest
	~TR/XMLHttpRequest/#interface-xmlhttprequest
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
	idl-def-DOMHighResTimeStamp
	~TR/hr-time/#domhighrestimestamp
	~HRTIME#Performance
I.Performance:~TIMELINE#extensions-to-the-performance-interface
	#dom-performance
I.PerformanceEntry:~TIMELINE#performanceentry
I.PerformanceObserver:~TIMELINE#the-performanceobserver-interface

	I.EventHandler
	I.DOMString:~TR/WebIDL/#idl-DOMString
	I.Document


	m.clearResourceTimings:#dom-performance-clearresourcetimings
m.clearResourceTimings():#dom-performance-clearresourcetimings
m.connectEnd:#dom-performanceresourcetiming-connectend
m.connectStart:#dom-performanceresourcetiming-connectstart
m.decodedBodySize:#dom-performanceresourcetiming-decodedbodysize
m.domainLookupEnd:#dom-performanceresourcetiming-domainlookupend
m.domainLookupStart:#dom-performanceresourcetiming-domainlookupstart
m.encodedBodySize:#dom-performanceresourcetiming-encodedbodysize
m.fetchStart:#dom-performanceresourcetiming-fetchstart
m.initiatorType:#dom-performanceresourcetiming-initiatortype
m.nextHopProtocol:#dom-performanceresourcetiming-nexthopprotocol
m.onresourcetimingbufferfull:#dom-performance-onresourcetimingbufferfull
m.redirectEnd:#dom-performanceresourcetiming-redirectend
m.redirectStart:#dom-performanceresourcetiming-redirectstart
m.requestStart:#dom-performanceresourcetiming-requeststart
m.responseEnd:#dom-performanceresourcetiming-responseend
m.responseStart:#dom-performanceresourcetiming-responsestart
m.secureConnectionStart:#dom-performanceresourcetiming-secureconnectionstart
m.setResourceTimingBufferSize:#dom-performance-setresourcetimingbuffersize
m.setResourceTimingBufferSize():#dom-performance-setresourcetimingbuffersize
m.transferSize:#dom-performanceresourcetiming-transfersize
m.workerStart:#dom-performanceresourcetiming-workerstart

m.duration:#duration-attribute
m.entryType:#entryType-attribute
m.startTime:#startTime-attribute
m.name:#widl-PerformanceResourceTiming-name


	●e
e.embed:~HTML50/embedded-content-0.html#the-embed-element
e.iframe:~HTML50/embedded-content-0.html#the-iframe-element
e.img:~HTML50/embedded-content-0.html#the-img-element
e.link:~HEmetadata#the-link-element
	~HTML50/document-metadata.html
e.script:~HEscripting#the-script-element
	~HTML50/scripting-1.html#the-script-element
e.object:~HTML50/embedded-content-0.html#the-object-element
e.svg:~SVG11/struct.html#SVGElement

et.resourcetimingbufferfull:#dom-performance-onresourcetimingbufferfull
h.Timing-Allow-Origin:#http-timing-allow-origin
	h.Origin:~IETF/rfc6454#section-4
css.url():~CSSSYN#consume-a-url-token

P.origin-or-null:~FETCH#origin-header
P.wildcard:~FETCH#http-new-header-syntax

	●
資源:#dfn-resource
現在の文書:#dfn-current-document
現在の時刻:#dfn-current-time

~redirect等:#redirect-or-equivalents
計時~許可検査:#timing-allow-check
非同一生成元:#dfn-cross-origin
局所~cache等:#cache-or-local
満杯:#full

資源~計時~buffer~size上限:#dfn-resource-timing-buffer-size-limit
資源~計時~buffer現size:#dfn-resource-timing-buffer-current-size
資源~計時~buffer満杯~flag:#dfn-resource-timing-buffer-full-flag
追加する:#dfn-add-a-performanceresourcetiming-entry


i.~fetch開始:#step-fetch-start
i.~obj作成:#step-create-object
i.収集~開始:#step-collection-start
i.接続-開始:#step-connect-start
i.要請~開始:#step-request-start
i.応答~開始:#step-response-start
i.応答~終了0:#step-response-end
i.最終~記録-:#step-final-record


x.処理能~entry~buffer:~TIMELINE#dfn-performance-entry-buffer
x.~HTTP~cache:~RFC7234#section-1
x.HTTP/2:~IETF/draft-ietf-httpbis-http2-16
x.ECMAScript 大域~環境:https://heycam.github.io/webidl/#es-environment
x.処理能時系列線:~TIMELINE#performance-timeline
	sec-performance-timeline
	x.Performance:~TR/navigation-timing-2/#performance
待入する:~TIMELINE#dfn-queue-a-performanceentry

x.HTTP-network ~fetch:~FETCH#http-network-fetch
x.HTTP-network-or-cache ~fetch:~FETCH#http-network-or-cache-fetch

x.閲覧文脈:~BROWSERS#browsing-context
	~HTML50/browsers.html#browsing-context
x.文字大小区別:~HTMLINFRA#case-sensitive
	~HTML50/infrastructure.html#case-sensitive
	またはそれに等価なもの:~HTML50/infrastructure.html#concept-http-equivalent-codes

x.取得:~HTML50/infrastructure.html#fetch
x.~fetch:~HTML50/infrastructure.html#fetch
x.~fetching:~HTML50/infrastructure.html#fetch
	fetching process:~HTML50/infrastructure.html#fetch
x.関連の~app~cache:~HTML50/browsers.html#relevant-application-cache
x.解決済み URL:~HTML50/infrastructure.html#resolve-a-url
	＊

c.stylesheet:~HTML50/links.html#link-type-stylesheet

	data: URI:~IETF/rfc2397
x.生成元:~IETF/rfc6454#section-4
x.同一生成元:~IETF/rfc6454#section-5

	~IETF
	~HTTPWG=http://httpwg.github.io/specs
x.内容~符号法たち:~RFC7231#section-3.1.2
	~HTTPWG/rfc7231.html#data.encoding
x.転送~符号法:~RFC7230#section-4
x.持続的~接続:~RFC7230#section-6.3
x.非同期に~close:~RFC7230#section-6.5
x.~message本体:~RFC7230#section-3.3
x.~payload本体:~RFC7230#section-3.3
x.~chunked符号法:~RFC7230#section-4.1

x.要素:~DOM4#concept-element
x.局所~名:~DOM4#concept-element-local-name
	m.localName:~DOM4#concept-element-local-name
x.~eventを発火する:~DOM4#concept-event-fire

	＊？
x.~workerを走らす:~SW#service-worker-concept
x.走らす:~SW#service-worker-concept
x.run a worker:~HTML5/workers.html#run-a-worker
x.作動中の~worker:~SW#dfn-active-worker
x.合致する作動中の~worker:~SW#dfn-containing-service-worker-registration
x.名前~fetch_evの~eventを発火する:~SW#on-fetch-request-algorithm
x.~service~worker登録:~SW#dfn-service-worker-registration

</script>

<!--%置換語 -->
<script type="text/plain" id="words_table1">
	HRTIME
	https://w3c.github.io/hr-time-2/
	http://www.w3.org/TR/hr-time/
TIMELINE:performance-timeline-2-ja.html
	http://www.w3.org/TR/performance-timeline-2/
SW:https://www.w3.org/TR/service-workers/

fetch_ev: <code class="event-type">fetch</code> 
</script>

<!--%words -->
<script type="text/plain" id="words_table">

UA:user agent:UA
access:::アクセス
app:application::アプリ

web:::ウェブ
site:::サイト
page:::ページ
cache:::キャッシュ
	~app~cache:application cache
hit:::ヒット
miss:::ミス

system:::システム
size:::サイズ
script:::スクリプト
ゼロ:zero::~
source:::ソース
download:::ダウンロード
data:::データ
名前:name:~
名:name:~
情報:information:~

navi:navigation::ナビ
navigate:::ナビゲート
parameter:::パラメタ
環境設定-:configure:~
process:::プロセス
benchmark:::ベンチマーク
page:::ページ
host:::ホスト
markup:::マークアップ
method:::メソッド
list:::リスト
link:::リンク
service:::サービス

	●fetch／HTTP
HTTP:
open:
	再~open:reopen
close:
fetch:
fetching:::fetch 処理
client:::クライアント
server:::サーバ
scheme:::スキーム
資源:resource::~:リソース
下位資源:subresources::下位リソース
redirect:::リダイレクト
transport:::トランスポート
domain:::ドメイン
検索:lookup::~
proxy:::プロキシ
tunnel:::トンネル
handshake:::ハンドシェイク
chunked::チャンク化
端点間:end-to-end::~:エンドツーエンド
符号法:coding::~:コーディング
符号化方式:encoding::~:エンコーディング
network:::ネットワーク
error:::エラー
protocol:::プロトコル
header:::ヘッダ
field:::フィールド
payload:::ペイロード
message:::メッセージ
本体:body::~:ボディ
stylesheet:::スタイルシート

要請:request::~:リクエスト
応答:response::~:レスポンス
収集-:collect:~
収集:collection:~
受信-:receive:~
受信:receiving:~
受信者:recipient:~
再送信:resend:~
送信-:send:~
送信者:sender:~
送信:sending:~
持続的:persistent::~
接続:connection::~:コネクション
接続-:connect::~:コネクト
確立-:establish:~
確立:establishing:~
事由:reason::~
生成-:generate:~
生成元:origin::~:オリジン
同一生成元:same origin::~:同一オリジン
非同一生成元:cross-origin::~:クロスオリジン
検索取得:retrieval::~
検索取得-:retrieve::~
折衝-:negotiate::~:ネゴシエート
非同期:asynchronous:~
低層の:lower-layer:~
層:layer:~
encapsulation:::カプセル化
起動-:initiate::~
起動元:initiator::~
種別:type:~
転送:transfer::~
事前条件:precondition::~
時刻印:timestamp::~:タイムスタンプ
出自に:originate:~
待入する:queue する::待ち行列に入れる:キューする
再検証-:revalidate::~
再検証:revalidation::~
結合-:combine:~

	●計時
処理能時系列線:Performance Timeline::~:パフォーマンスタイムライン
処理能:performance::~:パフォーマンス
時系列線:timeline::~:タイムライン
	時系列順:
milliseconds:::ミリ秒数
clock:::クロック
skew:::スキュー
buffer:::バッファ
主buffer:primary buffer:~
entry:::エントリ
時刻:time:~
時区間:interval:~

	時点::3

所要時間:time interval:~
経過時間:time elapsed:~
時間:time:~
	経過時間:time elapsed:~
計時:timing::~:タイミング
時機:timing::~:タイミング
	属性:timing attribute:~
	情報:timing information:~
	測定:timing measurement:~

開始時刻:starting time:~
開始:start:~
終了0:end:終了
遅延:latency:~
計測:measurement:~
計測-:measure:~
測定:measurement:~
測定-:measure:~

満杯:full::~:フル
格納-:store:~
格納:store:~
検査:check:~
許可検査:allow check:~
記録-:record::~
単調増加:monotonic::~


差分:difference:~
感知:perceive:~
知覚:perceive:~
	即時:immediate:~

	●syntax
解決済み:resolved:~
byte:::バイト
特有の:-specific:~

接頭辞:prefix:~
octet:::オクテット
percent:::パーセント
token:::トークン
overhead:::オーバーヘッド
frame:::フレーム
stream:::ストリーム
comma:::カンマ
命名規約:naming convention:~
規約:convention:~
不合格:fail:~
合格:pass:~

合致:match:~
	合間:between:~
大文字:uppercase:~
文字:character:~
区切りの:-separated:~
空白:whitespace:~
改行:newline:~
文字列:string:~
非大文字:non-capitalized:~
	文字大小も区別::1
符号化-:encode:~
符号化:encoding:~
	~~復号:remove:~
構文:syntax:~
	正準的:canonical:~
	正準形
桁:digit:~

	●仕様
version:::バージョン
proprietary:::プロプライエタリ
header:::ヘッダ
vendor:::ベンダ
support:::サポート
risk:::リスク
仕様:spec:~
仕組み:mechanism:~
任意選択:optional:~
利用者:user:~
制約:restriction:~
拘束:constraints:~
拘束-:constrain:~
制限:limit:~
上限:limit:~
定義-:define:~
定義:definition:~
	容易:easily:~
	手助け:facilitate:~
	手法::1
手続き:steps:~
段:step:~
既定:default:~::デフォルト
明示的:explicit:~
拡張:extension:~
指定-:specify:~
指示-:indicate:~
推奨-:recommend:~
提供-:provide:~
提供側:provider:~
	概要／序論:Introduction:~
包括的な:comprehensive:~
	手段:instrumentation:~
試験的:experimental:~
試験-:experiment:~
参考:non-normative:~
導入-:introduce:~
要件:requirements:~
非標準:non-normative:~
可能化-:enable:~
可用:available:~
各種用語:terminology:~
適合性:conformance:~
適用-:apply:~

中止-:abort:~
algo:algorithm::アルゴリズム
model:::モデル
処理:processing:~
処理-:process:~
処理過程:process:処理
内部:internal:~
精確:precise:~
実際:actual:~
実際の:actual:~
意図-:intend:~
結付けら:associate さ:結び付けら
特色機能:feature:~
考査:review:~
release:::リリース
表面化-:surface:~
依存関係:dependency:~
精緻化:refining:~
作業草案:Working Draft:~

	●
保安的:secure::~:セキュア
保安化-:secure に::~:セキュアに
保安:security::~:セキュリティ
privacy:::プライバシー
policy:::ポリシー
transport:::トランスポート
	施策:
悪意的な:malicious:悪意のある
	悪化:worse:~
懸念:concern:~
	問題:problem:~
統計上の痕跡:statistical fingerprinting:~
第三者:third-party:~
訪問-:visit:~

	●DOM ／ 
worker:
作動中の:active な::~:アクティブな
interface:::インタフェース
event:::イベント
handler:::ハンドラ
obj:object::オブジェクト
例外:exception:~
要素:element:~

浮上:bubble:~
発火-:fire:~
待行列:queue::待ち行列:キュー
文書:document:~
根元:root:~
単純:simple:~
取消:cancel:~
親:parent:~
継承:inherited:~

関連の:relevant:~
閲覧文脈:browsing context:~
文脈:context:~
除去-:remove:~
要素:element:~
内容:content:~
登録:registration:~

大域:global::~:グローバル
環境:environment:~
初期:initial:~
追加:add:~
初期化-:initialize:~
新たな:new:~
被呼出時:被 invoke 時:~
取得子:getter:~

	●
cost:::コスト
flag:::フラグ
埋込み:embedded:埋め込み
	呼び出:invoke／call
返され:return され:~
返さ:return し:~
返す:return する:~
返り:return:~
値:value:~
被った:incur された:~

消費-:consume:~
作成-:create:~
作成:creation:~
公開-:expose:~
共有-:share:~
下位:sub-:~
pattern:::パタン
概して:typical に:~

再利用:reuse:~
利用:use:~
体験:experience:~
動的:dynamic:~
関与-:participate:~

品質:quality:~
変化:change:~
変更-:change:~
失敗-:fail:~
失敗:failure:~

完了-:complete:~
完了:completion:~
完全な:complete:~
局所:local::~:ローカル
属性:attribute:~
成功裡:successful:~
新たな:new:~
	方法::1
既存の:existing:~
動作:action:~
報告-:report:~
code:::コード
読込み:load::読み込み:ロード
読込む:load する::読み込む:ロードする

	現在:current:~
現在の:current:~
現size:current size:現 size:現サイズ

最後の:last:~
最初の:first:~
	二番目の:second:~
様相:picture:~
機能-:function:~
決定-:determine:~

破棄-:discard:~
等価:equivalent:~
終了-:terminate:~
表現-:represent:~
必要性:need:~
計算-:calculate:~
記述-:describe:~
設定:set:~
許容-:allow:~
試行-:try:~
	attempt:~
再試行:retry:~

認証:authentication:~
調整:adjustment:~
識別-:identify:~
関数:function:~
関係-:relate:~
妥当:valid:~

	含める:include する:~
	含めら:include さ:~
	含まれ:include さ:~
	一方::1
	一部::2
	下線:underline
	不要::1
	今日::1
	仕立::1
	以下::1
	何故::1
	個数::1
	値:value:~
	内訳::1
	前提::1
	可能::2
	各段階::2

	同じ:same:~
	図式:graph:~
	型:type:~
	場合::74
	対応:corresponding:~
	対象::1
	対象:subject
	対象外::1
	事例:case:~
	当該::1
	後続::1
	必要::3
	情報取得::1
	意味::1
	起点::2
	該当::1
	最大で:maximum:~
	最大数::2
	最小個数::1
	次第::1
	番目::1
	目的::2
	直前::14
	直後::10
	immediately:~
	空にする:clear:~
	範囲::1
	経過::1
	結果:result:~
	複数::3
	複数個::1
	見込::1
	部分::1
	重要:important:~

	開始時点:at the beginning:~
	開始段::1
</script>



<!--%style  -->

<style type="text/css">
.event-type,
.handler {
	color: purple;
}


#_time-table {
	background: #eef1fc;
	padding: 0.5em;
	font-size: smaller;
}
#_time-table > div {
	border: solid gray 1px;
	position: relative;
	padding: 0.5em;
	height: 3em;
	width: 10em;
	margin: 1em 0;
}
#_time-table > div > div {
	position: absolute;
	left: 11.5em;
	min-width: 20em;
	white-space: nowrap;
}


</style>

</head>

<body>


<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>

<aside class="trans-meta">
<h1>Resource Timing Level 3 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://www.w3.org/">W3C</a> により，副題に日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">Resource Timing Level 3</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新： <time>2017-02-26</time>
（公開：<time>2013-01-23</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>



<header>

<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1>リソースの計時 — Resource Timing Level 3</h1>
<h2>2017 年 3 月 6 日付 編集者草案</h2>
	</hgroup>
<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dt title="Latest Editor’s Draft:">最新の編集者草案</dt>
	<dd>https://w3c.github.io/resource-timing/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>https://www.w3.org/TR/resource-timing/</dd>

	<dt title="Editors:">編集</dt>
	<dd>Todd Reifsteck, Microsoft Corp., toddreif@microsoft.com</dd>
	<dd>Ilya Grigorik, Google, igrigorik@gmail.com</dd>
	<dd>Arvind Jain, Google Inc., arvind@google.com (Until December 2014)</dd>
	<dd>Jatinder Mann, Microsoft Corp., jmann@microsoft.com <i>(Until February 2014)</i></dd>
	<dd>Zhiheng Wang, Google Inc. <i>(Until July 2012)</i></dd>
	<dd>Anderson Quach, Microsoft Corp. <i>(Until March 2011)</i></dd>

	<dt>Repository:</dt>
	<dd><a href="https://github.com/w3c/resource-timing/">We are on Github.</a><dd>
	<dd><a href="https://github.com/w3c/resource-timing/issues">File a bug.</a><dd>
	<dd><a href="https://github.com/w3c/resource-timing/commits/gh-pages/index.html">Commit history.</a><dd>

	<dt>Mailing list:</dt>
	<dd><a href="https://lists.w3.org/Archives/Public/public-web-perf/">public-web-perf@w3.org</a></dd>

	<dt>Implementation:</dt>
	<dd><a href="http://caniuse.com/#feat=resource-timing">Can I use Resource Timing?</a></dd>
	<dd><a href="http://w3c-test.org/resource-timing/">Test Suite</a></dd>
	<dd><a href="https://github.com/w3c/web-platform-tests/tree/master/resource-timing">Test Suite repository</a></dd>

</dl>

<small class="copyright">
<a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> ©
2017
<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup>
(<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
<a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
<a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). 
<abbr title="World Wide Web Consortium">W3C</abbr> <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
<a rel="license" href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">permissive document license</a>
rules apply.
</small>
</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>
<p>
この仕様は、~web~appが文書~内の資源に関する完全な計時~情報に~accessするための~interfaceを定義する。
◎
This specification defines an interface for web applications to access the complete timing information for resources in a document.
</p>
	</section>
	<section id="sotd">
<h2 title="Status of This Document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<!-- 
この節では、発行時点における…
-->
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>
に委譲
】</span>
</p>

<p class="warning">
<strong>
実装者は、この仕様が安定的ではないことに留意すべきです。
</strong>
議論に加わっていない実装者は、仕様が互換でない形に変更されていく~~状況に直面するかもしれません。
この仕様の実装に関心のある~vendorは、この仕様が最終的に勧告案に達する前に，下記のメーリングリストに加入して 議論に加わるべきです。
◎
Implementers SHOULD be aware that this document is not stable. Implementers who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways. Vendors interested in implementing this document before it eventually reaches the Candidate Recommendation stage SHOULD join the aforementioned mailing lists and take part in the discussions.
</p>

<p>
この文書は
<a href="https://www.w3.org/2010/webperf/">Web Performance Working Group</a>
により，作業草案として制作されました。
これは W3C 勧告になるものと意図されています。
コメントを歓迎します。
<a href="mailto:public-web-perf@w3.org">public-web-perf@w3.org</a>
（
<a href="mailto:public-web-perf-request@w3.org?subject=subscribe">subscribe</a>,
<a href="https://lists.w3.org/Archives/Public/public-web-perf/">archives</a>
）
宛まで，件名の先頭に [ResourceTiming] と記した上で，送られるよう願います。
◎
This document was published by the Web Performance Working Group as a Working Draft. This document is intended to become a W3C Recommendation. If you wish to make comments regarding this document, please send them to public-web-perf@w3.org (subscribe, archives) with [ResourceTiming] at the start of your email's subject. All comments are welcome.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction" class="informative">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
利用者が知覚し得る遅延は Web ~appにとり重要な品質~benchmarkである。
JavaScript に基づく仕組みは、~appにおける利用者~側の遅延を測定するための包括的な~~手段を提供できるが、端点間の遅延については，多くの事例で，完全な様相を提供できない。
この仕様は、 `PerformanceResourceTiming$I ~interfaceを導入する。
それは、 JavaScript により，文書~上の資源に関係する完全な計時~情報を収集するための仕組みである。
`NAVIGATION-TIMING-2$r は、この仕様を拡張して，~naviに関わる追加の計時~情報を提供する。
◎
User latency is an important quality benchmark for Web Applications. While JavaScript-based mechanisms can provide comprehensive instrumentation for user latency measurements within an application, in many cases, they are unable to provide a complete end-to-end latency picture. This document introduces the PerformanceResourceTiming interface to allow JavaScript mechanisms to collect complete timing information related to resources on a document. Navigation Timing 2 [NAVIGATION-TIMING-2] extends this specification to provide additional timing information associated with a navigation.
</p>


<div class="example">
<p>
例えば、次の~scriptは単純な方法により，資源~fetchに要した時間の計測-を試行する：<!-- 測定 -->
◎
For example, the following JavaScript shows a simple attempt to measure the time it takes to fetch a resource:
</p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %start = new Date().getTime();
   var %image1 = new Image();
   var %resourceTiming = function() {
       var %now = new Date().getTime();
       var %latency = %now - %start;
       alert("End to end resource fetch: " + %latency);
   };

   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}
    &lt;/script&gt;
    &lt;img src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

<p>
この~scriptは，資源~fetchに要した時間は計測できるが、その内訳の各段階に費やされた時間は計測できない。
更に、~markupにより記述された資源に費やされた時間を，この~scriptで計測することは容易でない。
◎
Though this script can measure the time it takes to fetch a resource, it cannot break down the time spent in various phases. Further, the script cannot easily measure the time it takes to fetch resources described in markup.
</p>

<p>
利用者~体験に関する完全な情報の必要性に応えるため、この文書は
`PerformanceResourceTiming$I ~interfaceを導入する。
この~interfaceは、~client側~appにおける完全な遅延~計測を可能にする， JavaScript による仕組みを提供する。
この~interfaceにより、前の例は，利用者が感知する資源の読込み時間を計測-可能なものに仕立て上げられる。
◎
To address the need for complete information on user experience, this document introduces the PerformanceResourceTiming interface. This interface allows JavaScript mechanisms to provide complete client-side latency measurements within applications. With this interface, the previous example can be modified to measure a user's perceived load time of a resource.
</p>

<div class="example">
<p>
次の~scriptは、~markupにより定義されたものまで含め，~page内のそれぞれの資源~fetchに要した時間の長さを計算する。
この例は、~pageが
<samp >https://www.w3.org</samp>
下に~hostされていることを前提にしている。
その気になれば
`PerformanceResourceTiming$I
~interfaceを利用して、資源~fetchingの各段階ごとに要した時間も計測できる。
◎
The following script calculates the amount of time it takes to fetch every resource in the page, even those defined in markup. This example assumes that this page is hosted on https://www.w3.org. One could further measure the amount of time it takes in every phase of fetching a resource with the PerformanceResourceTiming interface.
</p>
<pre>
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body onload="loadResources()"&gt;
    &lt;script&gt;
function loadResources() {
   var %image1 = new Image();
   %image1.onload = resourceTiming;
   %image1.src = 'https://www.w3.org/Icons/w3c_main.png';
}

function resourceTiming() {
    var %resourceList = window.performance.getEntriesByType("resource");
    for (%i = 0; %i &lt; %resourceList.length; i++) {
       if (%resourceList[i].initiatorType == "img") {
          alert(
            "End to end resource fetch: "+ 
            ( %resourceList[i].responseEnd  - %resourceList[i].startTime )
          );
       }
    }
}
    &lt;/script&gt;
    &lt;img id="image0" src="https://www.w3.org/Icons/w3c_home.png"&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

	</section>

	<section id="conformance-requirements">
<h2 title="Conformance requirements">2. 適合性の要件</h2>

<p class="trans-note">【
この節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
	<section id="terminology">
<h2 title="Terminology">3. 各種用語</h2>

<p class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#terminology" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

<p>
この仕様を通して、以下の用語が用いられる：
</p>

<dl>
	<dt>`資源@（ resource ）</dt>
	<dd>
要素その他 利用者により起動される~fetchを指す。
例えば資源は、次に挙げるものを出自にし得る：
`XMLHttpRequest$I ~obj `XMLHttpRequest$r,
［
`iframe^e, `img^e, `script^e, `object^e, `embed^e,
~link型 `stylesheet$c の `link^e
］などの HTML 要素 `HTML5$r,
`svg^e などの SVG 要素 `SVG11$r
◎
The term resource is used to refer to elements and any other user-initiated fetches throughout this specification. For example, a resource could originate from XMLHttpRequest objects [XMLHttpRequest], HTML elements [HTML5] such as iframe, img, script, object, embed, and link with the link type of stylesheet, and SVG elements [SVG11] such as svg.
</dd>

	<dt>`非同一生成元@（ cross origin ）</dt>
	<dd>
`同一生成元$xでないことを意味する。
◎
The term cross-origin is used to mean non same origin.
</dd>

	<dt>`現在の文書@（ current document ）</dt>
	<dd>
<a href="~HTML50/browsers.html#dom-document-0">`Window^I ~objの最新の `Document^I ~obj</a>
に結付けられている文書を指す。
◎
The term current document refers to the document associated with the Window object's newest Document object.
</dd>

	<dt>`現在の時刻@（ current time ）</dt>
	<dd id="_measured-since">
時刻~値は，
<a href="https://w3c.github.io/navigation-timing/#widl-PerformanceNavigationTiming-startTime">文書の~naviの開始</a>
を起点としてミリ秒~単位で計測されるものとする
`HR-TIME-2$r
。
例えば，文書の~naviの開始は、時刻 0 で生じる。
◎
Throughout this work, all time values are measured in milliseconds since the start of navigation of the document [HR-TIME-2]. For example, the start of navigation of the document occurs at time 0.
</dd>
	<dd>
`現在の時刻$は、文書の~naviの開始から その時点までに経過した，ミリ秒数による時刻を指す。
◎
The term current time refers to the number of milliseconds since the start of navigation of the document until the current moment in time.
</dd>
	<dd class="note">注記：
この，時刻の定義は、 High Resolution Time 仕様 `HR-TIME-2$r に基づくものであり、
1970 年 1 月 1 日 0 時 0 分 0 秒 (UTC) を起点としていた，
Navigation Timing 仕様 `NAVIGATION-TIMING$r による定義とは異なる。
◎
Note
◎
This definition of time is based on the High Resolution Time specification [HR-TIME-2] and is different from the definition of time used in the Navigation Timing specification [NAVIGATION-TIMING], where time is measured in milliseconds since midnight of January 1, 1970 (UTC).
</dd>
</dl>


		<section id="_conventions">
<h3 class="trans-note">【日本語訳に固有の表記規約】</h3>
<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, ~EACH (…), ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
簡潔に記すため、次の非公式な用語も導入する：
</p>

<dl>
	<dt>`~redirect等@</dt>
	<dd>
~HTTP~redirectまたは（他の~protocolにおける）
<a href="~HTML50/infrastructure.html#concept-http-equivalent-codes">それに等価なもの</a>
を指す総称。
</dd>

	<dt>`局所~cache等@</dt>
	<dd>
［
`関連の~app~cache$x, または局所~資源
］を指す総称。
</dd>

</dl>

		</section>
	</section>
	<section id="resource-timing">
<h2 title="Resource Timing">4. 資源~計時</h2>


		<section id="introduction-1">
<h3 title="Introduction">4.1. 序論</h3>

~INFORMATIVE

<div class="p">
<p>
`PerformanceResourceTiming$I
~interfaceは、~download可能な資源の計時~測定を手助けする。
例えば、次のものに利用できる：
</p>

<ul ><li>`XMLHttpRequest$I ~obj `XMLHttpRequest$r
</li><li>`iframe$e, `img$e, `script$e, `object$e, `embed$e, ［
~link型が `stylesheet$c にされている `link$e
］などの， HTML 要素 `HTML5$r
</li><li>`svg$e などの SVG 要素 `SVG11$r
</li></ul>

◎
The PerformanceResourceTiming interface facilitates timing measurement of downloadable resources. For example, this interface is available for XMLHttpRequest objects [XMLHttpRequest], HTML elements [HTML5] such as iframe, img, script, object, embed, and link with the link type of stylesheet, and SVG elements [SVG11] such as svg.
</div>


		</section>
		<section id="resources-included">
<h3 title="Resources Included in the PerformanceResourceTiming Interface">4.2. `PerformanceResourceTiming^I ~interfaceが対象にする資源の範囲</h3>

<div >
<p>
次に挙げる資源は、 `PerformanceResourceTiming$I ~objとして，`処理能時系列線$xに含められ~MUST：
</p>

<ul ><li>現在の［
`閲覧文脈$x `HTML5$r ／
~worker文脈 `WORKERS$r
］下で`~fetch$xされたすべての資源
— 関連する文脈の`処理能時系列線$x内に。
</li><li>`局所~cache等$から検索取得された資源
</li><li>~fetchにより起動されたが，（~network~errorなどに因り）後で中止された資源
— この場合の各種~属性の値は、処理~modelによる手続き（後述）の中で初期化され~MUST。
</li></ul>

◎
All resources fetched by the current browsing [HTML5] or worker [WORKERS] context's MUST be included as PerformanceResourceTiming objects in the Performance Timeline of the relevant context. Resources that are retrieved from relevant application caches or local resources MUST be included as PerformanceResourceTiming objects in the Performance Timeline [PERFORMANCE-TIMELINE-2]. Resources for which the fetch was initiated, but was later aborted (e.g. due to a network error) MUST be included as PerformanceResourceTiming objects in the Performance Timeline and MUST contain initialized attribute values for processed substeps of the processing model.
</div>


<p>
この節の残りの部分は参考である。
◎
The rest of this section is non-normative.
</p>


<p>
例：
◎
Examples:
</p>

<ul>
	<li>
複数の HTML `img$e 要素の `src^a 属性に，正準形が同じになる URL （ the same canonical URL 
`すなわち，同じ資源を指す URL^tnote
）が利用されている場合、［
最初に資源`~fetch$xを起動させた `img^e 要素
］の方が `PerformanceResourceTiming$I ~objとして`処理能時系列線$xに含められる~SHOULDである。
~UAは、二番目以降の `img^e 要素の URL に対しては、再~要請は行わずに，最初に起動された方による既存の~downloadを利用すると見込まれるので。
この場合，`処理能時系列線$x内には、最初に起動された， `img^e 要素に対する資源`~fetch$xによる結果のみが現れることになる。
◎
If the same canonical URL is used as the src attribute of two HTML IMG elements, the fetch of the resource initiated by the first HTML IMG element SHOULD be included as a PerformanceResourceTiming object in the Performance Timeline. The user agent might not re-request the URL for the second HTML IMG element, instead using the existing download it initiated for the first HTML IMG element. In this case, the fetch of the resource by the first IMG element would be the only occurrence in the Performance Timeline.
</li>
	<li>
HTML `img$e 要素の `src^a 属性が~scriptから変更された場合、元々の資源`~fetch$xのみならず，新たな URL への`~fetch$xも， `PerformanceResourceTiming$I ~objとして`処理能時系列線$xに含められることになる。
◎
If the src attribute of a HTML IMG element is changed via script, both the fetch of the original resource as well as the fetch of the new URL would be included as PerformanceResourceTiming objects in the Performance Timeline.
</li>
		<li>
HTML `iframe$e の~markupに `src^a 属性が指定されていない場合、~UAは `about:blank^c 文書を読込むことになる。
後で~scriptから `src^a 属性が動的に変更された場合，その新たな URL の資源へ`~fetch$xされることになる。
この場合、新たな URL による`~fetch$xのみが， `PerformanceResourceTiming$I ~objとして`処理能時系列線$xに含められることになる。
◎
If an HTML IFRAME element is added via markup without specifying a src attribute, the user agent may load the about:blank document for the IFRAME. If at a later time the src attribute is changed dynamically via script, the user agent may fetch the new URL resource for the IFRAME. In this case, only the fetch of the new URL would be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
	<li>
正準形が同じになる URL に対し，複数の `XMLHttpRequest$I が生成された場合、いずれの資源`~fetch$xも， `PerformanceResourceTiming$I ~objとして`処理能時系列線$xに含められることになる
— 後続する資源~fetch要請には、先行する要請による~downloadを再利用できないので。
◎
If an XMLHttpRequest is generated twice for the same canonical URL, both fetches of the resource would be included as a PerformanceResourceTiming object in the Performance Timeline. This is because the fetch of the resource for the second XMLHttpRequest cannot reuse the download issued for the first XMLHttpRequest.
</li>
	<li>
~page内の HTML `iframe$e 要素~内に入れ子にされた文書により要請される下位~資源は、親~文書の`処理能時系列線$xではなく，入れ子にされた文書の`処理能時系列線$xに含められる。
`iframe^e に対し`処理能時系列線$xに含められるのは、その `src^a 属性により要請される資源に限られる。
◎
If an HTML IFRAME element is included on the page, then only the resource requested by IFRAME src attribute is included as a PerformanceResourceTiming object in the Performance Timeline. Sub-resources requested by the IFRAME document will be included in the IFRAME document's Performance Timeline and not the parent document's Performance Timeline.
</li>
	<li>
HTML `img$e 要素が~sourceとして
<a href="~IETF/rfc2397">data: URI</a> `RFC2397$r
を持つ場合、その資源は，`処理能時系列線$xには含められない。
data: URI は埋込み~dataであり、`~fetch$xを要しないものと定義されているので。
◎
If an HTML IMG element has a data: URI as its source [RFC2397], then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline. By definition data: URI contains embedded data and does not require a fetch.
</li>
	<li>
資源`~fetch$xが~network~error（ DNS, TCP, TLS ~errorなど）に因り中止された場合、その~fetchは，失敗した時点までの属性~値で初期化された
`PerformanceResourceTiming$I ~objとして`処理能時系列線$xに含められることになる
— 例えば TCP ~handshake~errorは、 要請に対する DNS 時刻印を報告するべきである, 等々。
◎
If a resource fetch was aborted due to a networking error (e.g. DNS, TCP, or TLS error), then the fetch would be included as a PerformanceResourceTiming object in the Performance Timeline with initialized attribute values up to the point of failure - e.g. a TCP handshake error should report DNS timestamps for the request, and so on.
</li>
	<li>
資源`~fetch$xが，事前条件（例： 混成内容（ mixed content ）, CORS 制約, CSP ~policy, など）に失敗したことにより中止された場合、その資源については，`処理能時系列線$xには含められない。
◎
If a resource fetch is aborted because it failed a fetch precondition (e.g. mixed content, CORS restriction, CSP policy, etc), then this resource will not be included as a PerformanceResourceTiming object in the Performance Timeline.
</li>
</ul>


		</section>
		<section id="performanceresourcetiming">
<h3 title="The PerformanceResourceTiming Interface">4.3. `PerformanceResourceTiming^I ~interface</h3>


<p>
`PerformanceResourceTiming$I ~interfaceは`処理能時系列線$xに関与し，
`PerformanceEntry$I ~interfaceの次の属性を拡張する：
◎
The PerformanceResourceTiming interface participates in the Performance Timeline and extends the following attributes of the PerformanceEntry interface:
</p>


<dl class="idl-defs">
	<dt>`name@m</dt>
    <dd>
取得子は、要請された資源の`解決済み URL$x を返さ~MUST。
この属性は、`~fetch$x先が異なる URL に~redirectされても，変化しては~MUST_NOT。
◎
This attribute MUST return the resolved URL of the requested resource. This attribute MUST NOT change even if the fetch redirected to a different URL.
</dd>

	<dt>`entryType@m</dt>
	<dd>
取得子は、 `resource^l を返さ~MUST。
◎
The entryType attribute MUST return the DOMString "resource".
</dd>

	<dt>`startTime@m</dt>
	<dd>
<p >
取得子は、［
~UAが資源`~fetching$xを待行列に入れる直前の時刻
］を表す，［
`DOMHighResTimeStamp$I 型 `HR-TIME-2$r の値
］を返さ~MUST。
資源~fetchの間に`~redirect等$が生じたときは、次で与えられる値を返さ~MUST：
</p>

<ul ><li>どの`~redirect等$に対しても、［
`現在の文書$と`同一生成元$xであるか, または`計時~許可検査$に合格する
］ならば、 `redirectStart$m と同じ値。
</li><li>他の場合、 `fetchStart$m と同じ値。
</li></ul>


◎
The startTime attribute MUST return a DOMHighResTimeStamp [HR-TIME-2] with the time immediately before the user agent starts to queue the resource for fetching. If there are HTTP redirects or equivalent when fetching the resource, and if all the redirects or equivalent are from the same origin as the current document or the timing allow check algorithm passes, this attribute MUST return the same value as redirectStart. Otherwise, this attribute MUST return the same value as fetchStart.
</dd>

	<dt>`duration@m</dt>
	<dd>
取得子は、
`responseEnd$m の， `startTime$m からの差分を表す
`DOMHighResTimeStamp$I
を返さ~MUST
<!-- ＊,respectively -->
◎
The duration attribute MUST return a DOMHighResTimeStamp equal to the difference between responseEnd and startTime, respectively.
</dd>
</dl>


⇒！
[Exposed=(Window,Worker)]
interface `PerformanceResourceTiming@I : `PerformanceEntry$I {
  readonly attribute DOMString `initiatorType$m;
  readonly attribute DOMString `nextHopProtocol$m;
  readonly attribute `DOMHighResTimeStamp$I `workerStart$m;
  readonly attribute `DOMHighResTimeStamp$I `redirectStart$m;
  readonly attribute `DOMHighResTimeStamp$I `redirectEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `fetchStart$m;
  readonly attribute `DOMHighResTimeStamp$I `domainLookupStart$m;
  readonly attribute `DOMHighResTimeStamp$I `domainLookupEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `connectStart$m;
  readonly attribute `DOMHighResTimeStamp$I `connectEnd$m;
  readonly attribute `DOMHighResTimeStamp$I `secureConnectionStart$m;
  readonly attribute `DOMHighResTimeStamp$I `requestStart$m;
  readonly attribute `DOMHighResTimeStamp$I `responseStart$m;
  readonly attribute `DOMHighResTimeStamp$I `responseEnd$m;
  readonly attribute unsigned long long `transferSize$m;
  readonly attribute unsigned long long `encodedBodySize$m;
  readonly attribute unsigned long long `decodedBodySize$m;
  <a href="#serializer">serializer</a> = {inherit, attribute};
};
◎


<dl class="idl-defs">
	<dt>`initiatorType@m</dt>
	<dd>
<p>
取得子は、資源~fetchの起動元に応じて，次を返さ~MUST：
◎
On getting, the initiatorType attribute MUST return one of the following DOMString:
</p>

		<ul>
			<li>
`要素$xから起動された場合
⇒
その`要素$xの`局所~名$x
`DOM$r
◎
The same value as the localName of that element [DOM], if the initiator is an element.
</li>
			<li>
`url()$css 構文 `CSS-SYNTAX-3$r （
`@import url()^css や `background: url()^css
など）により~downloadされる CSS 資源から起動された場合
⇒
`css^l
◎
"css", if the initiator is a CSS resource downloaded by the url() syntax [CSS-SYNTAX-3], such as @import url() or background: url().
</li>
			<li>
`XMLHttpRequest$I ~obj
`XMLHttpRequest$r
から起動された場合
⇒
`xmlhttprequest^l
◎
"xmlhttprequest", if the initiator is an XMLHttpRequest object [XMLHttpRequest].
</li>
		</ul>
	</dd>

	<dt>`nextHopProtocol@m</dt>
	<dd>
<p>
取得子は、
ALPN Protocol ID `RFC7301$r
として識別される，資源~fetchに利用された~network~protocolを返さ~MUST。
~proxyが環境設定されている下では、次を返さ~MUST：
</p>
		<ul>
			<li>
~tunnel接続が確立された場合
⇒
その~tunnelされた~protocolの ALPN Protocol ID
</li>
			<li>
他の場合
⇒
~proxyへの最初の hop の ALPN Protocol ID
</li>
		</ul>

<p>
ALPN Protocol ID を精確に表現するため、次の拘束が追加で適用される：
</p>
		<ul>
			<li>
ALPN ~protocol内の~octetのうち， `%^l を除く妥当な~token文字は~percent符号化されては~MUST_NOT。
</li>
			<li>
~percent符号化には，大文字の 16 進~桁を用い~MUST。
</li>
		</ul>
◎
On getting, the attribute nextHopProtocol returns the network protocol used to fetch the resource, as identified by the ALPN Protocol ID [RFC7301]. When a proxy is configured, if a tunnel connection is established then this attribute MUST return the ALPN Protocol ID of the tunneled protocol, otherwise it MUST return the ALPN Protocol ID of the first hop to the proxy. In order to have precisely one way to represent any ALPN protocol ID, the following additional constraints apply: octets in the ALPN protocol MUST NOT be percent-encoded if they are valid token characters except "%", and when using percent-encoding, uppercase hex digits MUST be used.
</dd>

	<dd>
この属性は、実際に折衝された方法に関わらず，~fetchのために利用~中の~network~protocolを識別するためとして意図されていることに注意。
すなわち、~network~protocolを折衝するために ALPN が利用されていなくても、この属性は，依然として，ALPN Protocol ID を利用して利用~中の~protocolを指示する。
◎
Note that the nextHopProtocol attribute is intended to identify the network protocol in use for the fetch regardless of how it was actually negotiated; that is, even if ALPN is not used to negotiate the network protocol, this attribute still uses the ALPN Protocol ID's to indicate the protocol in use.
</dd>


	<dt>`workerStart@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the workerStart attribute MUST return as follows:
</p>
		<ol>
			<li>
<p>
~IF［
現在の［
`閲覧文脈$x ／ ~worker文脈
］は、要請を~serviceするために要求されるような，`合致する作動中の~worker$x
%worker
`SERVICE-WORKERS$r
を持つ
］：
◎
If the current browsing or worker context's have an active worker [SERVICE-WORKERS]:
</p>
				<ol>
					<li>
~IF［
%worker はすでに可用である
］
⇒
~RET ~UAが［
 %worker に向けて，`名前~fetch_evの~eventを発火する$x
］直前の時刻
◎
the time immediately before the user agent fires an event named `fetch` at the active worker if the worker is available.
</li>
					<li>
~RET ~UAが［
%worker を`走らす$x
］直前の時刻
<span class="trans-note">【
~link先が変？ `run a worker$x ？<!-- ＊ -->
】</span>
◎
the time immediately before the user agent runs the worker required to service the request.
</li>
				</ol>
			</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>
	</dd>

	<dt>`redirectStart@m</dt>
	<dd>

<p>
取得子は、次を走らせ~MUST：
◎
On getting, the redirectStart attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
資源`~fetching$xにおいて`~redirect等$が生じている
］~AND［
それらの`~redirect等$すべてが，`計時~許可検査$に合格した
］
⇒
~RET ［
~redirectを起動させた`~fetch$xを開始した
］直前の時刻
◎
The time immediately before the user agent starts to fetch the resource that initiates the redirect, if there are HTTP redirects or equivalent when fetching the resource and all the redirects or equivalent pass the timing allow check algorithm.
</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>
	</dd>


	<dt>`redirectEnd@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the redirectEnd attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
資源`~fetching$xにおいて`~redirect等$が生じている
］~AND［
それらの`~redirect等$すべてが，`計時~許可検査$に合格した
］
⇒
~RET ［
最後の~redirectに対する応答の最後の~byteを受信した
］直後の時刻
◎
The time immediately after receiving the last byte of the response of the last redirect, if there are HTTP redirects or equivalent when fetching the resource and all the redirects or equivalent pass the timing allow check algorithm.
</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>
	</dd>


	<dt>`fetchStart@m</dt>
	<dd>

<p>
取得子は、次を走らせ~MUST：
◎
On getting, the fetchStart attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
`~redirect等$が生じている
］
⇒
~RET ~UAが［
~redirectされなかった最後の資源`~fetch$xを開始した
］直前の時刻
◎
The time immediately before the user agent starts to fetch the final resource in the redirection, if there are HTTP redirects or equivalent.
</li>
			<li>
~RET ~UAが［
資源`~fetch$xを開始した
］直前の時刻
◎
The time immediately before the user agent starts to fetch the resource otherwise.
</li>
		</ol>
	</dd>

	<dt>`domainLookupStart@m</dt>
	<dd>
<p >
取得子は、次を走らせ~MUST：
◎
On getting, the domainLookupStart attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
`持続的~接続$x `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
~IF［
~UAの~cache内に~domain情報がある
］
⇒
~RET ~UAが［
~domain情報~cacheから~domain~dataを検索取得し始めた
］直前の時刻
<!-- ＊immediately after the user agent before？？ -->
◎
The time immediately after the user agent before the domain data retrieval from the domain information cache, if the user agent has the domain information in cache.
</li>
			<li>
~IF［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格した
］
⇒
~RET ~UAが［
資源に対する~domain名~検索を開始した
］直前の時刻
◎
The time immediately before the user agent starts the domain name lookup for the resource, if the last non-redirected fetch of the resource passes the timing allow check algorithm.
</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>
	</dd>

	<dt>`domainLookupEnd@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the domainLookupEnd attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
`持続的~接続$x `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
~IF［
~UAの~cache内に~domain情報がある
］
⇒
~RET ~UAが［
~domain情報~cacheからの~domain~dataを検索取得し終えた
］直後の時刻
◎
The time immediately after the user agent ends the domain data retrieval from the domain information cache, if the user agent has the domain information in cache.
</li>
			<li>
~IF［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格した
］
⇒
~RET ~UAが［
資源に対する~domain名~検索を終えた
］直前の時刻
◎
The time immediately before the user agent finishes the domain name lookup for the resource, if the last non-redirected fetch of the resource passes the timing allow check algorithm.
</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>
	</dd>

	<dt>`connectStart@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the connectStart attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
`持続的~接続$x `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値。
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
<p >
~IF［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格した
］
⇒
~RET ~UAが［
資源を検索取得するために，~serverとの接続の確立を開始した
］直前の時刻
◎
The time immediately before the user agent start establishing the connection to the server to retrieve the resource, if the last non-redirected fetch of the resource passes the timing allow check algorithm.
</p>

<p>
~transport接続が失敗して，~UAが接続を再~openした場合、
`connectStart$m は、新たな接続に対応する値を返す~SHOULDである。
◎
If the transport connection fails and the user agent reopens a connection, connectStart SHOULD return the corresponding value of the new connection.
</p>

</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>
	</dd>


	<dt>`connectEnd@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the connectEnd attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
`持続的~接続$x `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値。
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
<p>
~IF［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格した
］
⇒
~RET ~UAが［
資源を検索取得するために，~serverとの接続の確立を開始した
`終えた？^tnote
］直後の時刻
◎
The time immediately after the user agent start establishing the connection to the server to retrieve the resource, if the last non-redirected fetch of the resource passes the timing allow check algorithm.
</p>

<p>
返される値には、SSL ~handshakeや SOCKS 認証などの他の所要時間も含む、~transport接続の確立に要した時間も含まれ~MUST。
◎
The returned time MUST include the time interval to establish the transport connection, as well as other time intervals such as SSL handshake and SOCKS authentication.
</p>

<p>
~transport接続が失敗して，~UAが接続を再~openした場合、
`connectEnd$m は、新たな接続に対応する値を返す~SHOULDである。
◎
If the transport connection fails and the user agent reopens a connection, connectEnd SHOULD return the corresponding value of the new connection.
</p>
			</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>

	</dd>

	<dt>`secureConnectionStart@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the secureConnectionStart attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
`持続的~接続$x `RFC7230$r が利用されている
］~OR［
資源は`局所~cache等$から検索取得されている
］
⇒
~RET `fetchStart$m と同じ値。
◎
The same value as fetchStart, if a persistent connection [RFC7230] is used or the resource is retrieved from relevant application caches or local resources.
</li>
			<li>
~IF［
保安的~transportが利用されている
］~AND［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格した
］
⇒
~RET ~UAが［
現在の接続を保安化する~handshake処理を開始した
］直前の時刻
◎
The time immediately before the user agent starts the handshake process to secure the current connection, if a secure transport is used and the last non-redirected fetch of the resource passes the timing allow check algorithm.
</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>
	</dd>

	<dt>`requestStart@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the requestStart attribute MUST return as follows:
</p>

		<ol>
			<li>
<p >
~IF［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格した
］
⇒
~UAが［［
`局所~cache等$, または ~server
］に向けて，その資源~要請を開始した
］直前の時刻
◎
The time immediately before the user agent starts requesting the resource from the server, or from relevant application caches or from local resources, if the last non-redirected fetch of the resource passes the timing allow check algorithm.
</p>

<p >
要請の送信-後に~transport接続が失敗して，~UAが接続を再~openして要請を再送信した場合、その新たな要請に対応する値を返さ~MUST。
◎
If the transport connection fails after a request is sent and the user agent reopens a connection and resend the request, requestStart MUST return the corresponding values of the new request.
</p>
			</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>
	</dd>

	<dd class="note">
<p>注記：
この~interfaceは、要請の送信~完了を表現する
“`requestEnd^m” の類の属性は含まない。
◎
This interface does not include an attribute to represent the completion of sending the request, e.g. requestEnd.
</p>

<ul>
	<li>
~UAからの要請の送信~完了は、［
その種の属性が最も役立つ，~network~transportにおける 対応する完了~時刻
］を常に指示するものではない。
◎
Completion of sending the request from the user agent does not always indicate the corresponding completion time in the network transport, which brings most of the benefit of having such an attribute.
</li>
	<li>
一部の~UAは、~HTTP層の~encapsulationに因り，実際の完了~時刻を決定する~costが高くつく。
◎
Some user agents have high cost to determine the actual completion time of sending the request due to the HTTP layer encapsulation.
</li>
</ul>

	</dd>



	<dt>`responseStart@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the responseStart attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格した
］
⇒
~RET ~UAが［
［
`局所~cache等$, または~server
］から，応答の最初の~byteを受信した
］直後の時刻
◎
The time immediately after the user agent receives the first byte of the response from relevant application caches, or from local resources or from the server if the last non-redirected fetch of the resource passes the timing allow check algorithm.
</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>

	</dd>

	<dt>`responseEnd@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the responseEnd attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
~UAは~network~errorにより~fetchを中止した
］
⇒
~RET 中止した時刻
◎
↓</li>
			<li>
<p>
~RET 次のうち，早い方の時刻
</p>

<ul><li>~UAが［［
`局所~cache等$, または~server
］から資源の最後の~byteを受信した
］直後の時刻
</li><li>~transport接続が~closeされる直前の時刻
</li></ul>

◎
The time immediately after the user agent receives the last byte of the response or immediately before the transport connection is closed, whichever comes first. The resource here can be received either from relevant application caches, local resources, or from the server.
◎
The time immediately before the user agent aborts the fetch due to a network error.
</li>
		</ol>
	</dd>

	<dt>`transferSize@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the transferSize attribute MUST return as follows:
</p>

		<ol>
			<li>
<p>
~IF［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格した
］
⇒
~RET ［
`HTTP-network ~fetch$xから受信された，応答の［
一連の~header, および`~payload本体$x `RFC7230$r
］に消費された~size
］
◎
the size, in octets received from a HTTP-network fetch, consumed by the response header fields and the response payload body [RFC7230] if the last non-redirected fetch of the resource passes the timing allow check algorithm.
</p>

<p>
~navigateするときに`~redirect等$があって，すべての`~redirect等$が同じ`生成元$x `RFC6454$r
からである場合、それらの~redirectにより被った~HTTP~overheadも含まれる~SHOULDである。
◎
If there are HTTP redirects or equivalent when navigating and if all the redirects or equivalent are from the same origin [RFC6454], this attribute SHOULD include the HTTP overhead of incurred redirects.
</p>

<p>
この属性は、~HTTP~overhead（
HTTP/1.1 `~chunked符号法$xや~headerの前後の空白（改行も含む）,
同じ~stream上の 他の［
~server→~client
］~frameに伴う
`HTTP/2$x
~frameによる~overhead）を含める~SHOULDである。
一方で、低層の~protocol ~overhead（ TLS `RFC5246$r や TCP によるものなど）は，含める~SHOULDでない。
◎
This attribute SHOULD include HTTP overhead (such as HTTP/1.1 chunked encoding and whitespace around header fields, including newlines, and HTTP/2 frame overhead, along with other server-to-client frames on the same stream), but SHOULD NOT include lower-layer protocol overhead (such as TLS [RFC5246]or TCP).
</p>

<p class="note">注記：
`transferSize$m 値が `encodedBodySize$m より低くなることもある：
~cacheされた応答が成功裡に再検証されとき、
`transferSize$m は，再検証の間に被った~HTTP応答~headerたちの~sizeを報告し、
`encodedBodySize$m は，以前に検索取得された~payload本体の~sizeを報告する。
◎
Note
It is possible for transferSize value to be lower than encodedBodySize: when a cached response is successfully revalidated the transferSize reports the size of the response HTTP headers incurred during the revalidation, and encodedBodySize reports the size of the previously retrieved payload body.
</li>
			<li>
~RET ゼロ
— 資源が`局所~cache等$から検索取得された場合も含め
◎
zero otherwise, including for resources retrieved from relevant application caches or from local resources.
</li>
		</ol>

	</dd>


	<dt>`encodedBodySize@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the encodedBodySize attribute MUST return as follows:
</p>

		<ol>
			<li>
~IF［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格した
］
⇒
`HTTP-network-or-cache ~fetch$xから受信された
`~payload本体$x `RFC7230$r の
— 適用されている`内容~符号法たち$x `RFC7231$r を~~復号する前の —
~octet数による~size
◎
The size, in octets, received from a HTTP-network-or-cache fetch, of the payload body [RFC7230], prior to removing any applied content-codings [RFC7231], if the last non-redirected fetch of the resource passes the timing allow check algorithm.
</li>
			<li>
~IF［
資源は`局所~cache等$から検索取得されている
］
⇒
適用されている`内容~符号法たち$xがあれば それを~~復号する前の，~payload本体の
octet数による~size
◎
The size, in octets, of the payload body prior to removing any applied content-codings if the resource is retrieved from relevant application caches or from local resources.
</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>

	</dd>
	<dd class="note">注記：
`encodedBodySize^m は、応答~codeに依存してゼロにもなることもある
— 例えば~HTTP 204 (No Content), 3XX, 等々。
◎
The encodedBodySize may be zero depending on the response code - e.g. HTTP 204 (No Content), 3XX, etc.
</dd>

	<dt>`decodedBodySize@m</dt>
	<dd>
<p>
取得子は、次を走らせ~MUST：
◎
On getting, the decodedBodySize attribute MUST return as follows:
</p>
		<ol>
			<li>
<p>
~IF［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格した
］
⇒
`HTTP-network-or-cache ~fetch$xから受信された`~message本体$x† `RFC7230$r の
— 適用されている`内容~符号法たち$x `RFC7231$r を~~復号した後の —
~octet数による~size
</p>

<p class="trans-note">【†
厳密には，`~payload本体$xであろう（それ以前に`転送~符号法$xも~~復号される必要がある筈なので）
】</p>

◎
The size, in octets, received from a HTTP-network-or-cache fetch, of the message body [RFC7230], after removing any applied content-codings [RFC7231], if the last non-redirected fetch of the resource passes the timing allow check algorithm.
</li>
			<li>
~IF［
資源は`局所~cache等$から検索取得された
］
⇒
~RET
適用されている`内容~符号法たち$xがあればそれを~~復号した後の，~payloadの~size
◎
The size, in octets, of the payload after removing any applied content-codings, if the resource is retrieved from relevant application caches or from local resources.
</li>
			<li>
~RET ゼロ
◎
zero, otherwise.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="extensions-performance-interface">

<h3 title="Extensions to the Performance Interface">4.4. `Performance^I ~interfaceに対する拡張</h3>


<p>
~UAは、 `PerformanceResourceTiming$I ~objとして`処理能時系列線$x `PERFORMANCE-TIMELINE-2$r に含み得る資源の個数を制限できる。
この節では、 `Performance$I ~interfaceを拡張して，格納される `PerformanceResourceTiming$I ~objの個数について制御できるようにする。
◎
The user agent MAY choose to limit how many resources are included as PerformanceResourceTiming objects in the Performance Timeline [PERFORMANCE-TIMELINE-2]. This section extends the Performance interface to allow controls over the number of PerformanceResourceTiming objects stored.
</p>

<p>
推奨される `PerformanceResourceTiming$I ~objの最小個数は 150 である
— ~UAはこれを変更してもよいが。
この制限は、
`setResourceTimingBufferSize()$m を呼び出すことにより，変更を要請できる。
◎
The recommended minimum number of PerformanceResourceTiming objects is 150, though this may be changed by the user agent. setResourceTimingBufferSize can be called to request a change to this limit.
</p>


<p>
各 `ECMAScript 大域~環境$xは、次のものを持つ：
◎
Each ECMAScript global environment has:
</p>

<ul>
	<li>
`資源~計時~buffer~size上限@
— 初期~時は 150 以上。
`上限の程度は~UAに委ねられる。^tnote
◎
a resource timing buffer size limit which should initially be 150 or greater.
</li>
	<li>
`資源~計時~buffer現size@
— 初期~時は 0 。
◎
a resource timing buffer current size which is initially 0.
</li>
	<li>
`資源~計時~buffer満杯~flag@
— 初期~時は ~OFF 。
◎
a resource timing buffer full flag which is initially false.
</li>
</ul>


⇒！
partial interface `Performance$I {
  void `clearResourceTimings()$m;
  void `setResourceTimingBufferSize$m(unsigned long %maxSize);

  attribute EventHandler `onresourcetimingbufferfull$m;
};
◎



<dl class="idl-defs">

	<dt>`clearResourceTimings()@m</dt>
	<dd>
<p>
被呼出時には、次を実行し~MUST：
◎
The method clearResourceTimings runs the following steps:
</p>
		<ol>
			<li>
`処理能~entry~buffer$x内から
すべての `PerformanceResourceTiming$I ~objを除去する
◎
remove all PerformanceResourceTiming objects in the performance entry buffer.
</li>
			<li>
`資源~計時~buffer現size$ ~SET 0
◎
set resource timing buffer current size to 0.
</li>
			<li>
`資源~計時~buffer満杯~flag$ ~SET ~OFF
◎
set resource timing buffer full flag to false.
</li>
		</ol>
	</dd>

	<dt>`setResourceTimingBufferSize@m(%maxSize)</dt>
	<dd>
<p>
被呼出時には、次を実行し~MUST：
◎
The setResourceTimingBufferSize method runs the following steps:
</p>

		<ol>
			<li>
<p>
`資源~計時~buffer~size上限$ ~SET `maxSize^v
</p>
<p>
［
`maxSize^v ~LT `資源~計時~buffer現size$
］であっても，`処理能~entry~buffer$xからは
`PerformanceResourceTiming$I ~objを除去しない。
</p>
◎
Set resource timing buffer size limit to the maxSize parameter. If the maxSize parameter is less than resource timing buffer current size, no PerformanceResourceTiming objects are to be removed from the performance entry buffer.
</li>
			<li>
`資源~計時~buffer満杯~flag$ ~SET ~OFF
◎
Set resource timing buffer full flag to false.
</li>
		</ol>
	</dd>

	<dt>`onresourcetimingbufferfull@m</dt>
	<dd>
`resourcetimingbufferfull^et ~eventに対する~event~handler。
◎
The attribute onresourcetimingbufferfull is the event handler for the resourcetimingbufferfull event.
</dd>

</dl>


<p>
`処理能~entry~buffer$xに新たな
`PerformanceResourceTiming$I ~obj `~entry^v を
`追加する@
ときは、次の手続きを実行する：
◎
To add a PerformanceResourceTiming entry (new entry) in the performance entry buffer, run the following steps:
</p>

<ol>
	<li>
<p>
~IF［
`資源~計時~buffer現size$ ~LT `資源~計時~buffer~size上限$
］：
◎
If resource timing buffer current size is less than resource timing buffer size limit, run the following substeps:
</p>
		<ol>
			<li>
`処理能~entry~buffer$xに `~entry^v を追加する
◎
Add new entry to the performance entry buffer.
</li>
			<li>
`資源~計時~buffer現size$ ~INCBY 1
◎
increase resource timing buffer current size by 1.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
`資源~計時~buffer満杯~flag$ ~EQ ~OFF
］：
◎
Otherwise, if the resource timing buffer full flag is false, run the following substeps:
</p>
		<ol>
			<li>
`Document^I に向けて，次のようにされた
名前 `resourcetimingbufferfull$et の`~eventを発火する$x
⇒
`bubbles^a 属性 ~SET ~T<br>
既定~動作なし
◎
fire a simple event named resourcetimingbufferfull at the Document, with its bubbles attribute initialized to true, and has no default action.
</li>
			<li>
`資源~計時~buffer満杯~flag$ ~SET ~ON
◎
set the resource timing buffer full flag to true.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="cross-origin-resources">
<h3 title="Cross-origin Resources">4.5. 非同一生成元~資源</h3>

<div class="p">
<p>
`非同一生成元$資源は、
`PerformanceResourceTiming$I ~objとして
`処理能時系列線$xに含められ~MUST。
`非同一生成元$資源に対する~fetchが`計時~許可検査$に合格しなかった場合、その
`PerformanceResourceTiming$I
~objの属性のうち，次のものは、ゼロにされ~MUST：
</p>

<ul>
<li>`redirectStart$m
<li>`redirectEnd$m
<li>`domainLookupStart$m
<li>`domainLookupEnd$m
<li>`connectStart$m
<li>`connectEnd$m
<li>`requestStart$m
<li>`responseStart$m
<li>`secureConnectionStart$m
<li>`transferSize$m
<li>`encodedBodySize$m
<li>`decodedBodySize$m
</ul>

◎
Cross-origin resources MUST be included as PerformanceResourceTiming objects in the Performance Timeline. If the timing allow check algorithm fails for a cross-origin resource, these attributes of its PerformanceResourceTiming object MUST be set to zero: redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart, secureConnectionStart, transferSize, encodedBodySize and decodedBodySize.
</div>

<p>
~server側~appは、この節で前に指定された，［
さもなければ`非同一生成元$の制約から値がゼロにされる属性
］の，~UAにおける公開を許容するために、当該の文書~生成元を値とする
`Timing-Allow-Origin$h ~HTTP応答~header返してもよい。
◎
Server-side applications may return the Timing-Allow-Origin HTTP response header to allow the User Agent to fully expose, to the document origin(s) specified, the values of attributes that would have been zero due to the cross-origin restrictions previously specified in this section.
</p>

			<section id="timing-allow-origin">
<h4 title="Timing-Allow-Origin Response Header">4.5.1. `Timing-Allow-Origin^h 応答~header</h4>

<p>
`Timing-Allow-Origin@h
~HTTP応答~headerを利用すれば、［［
非同一生成元の制約に因り 0 にされていた属性
］の値を見ることが許容される生成元（たち）
］を指示する~policyを通信できる。
この~headerの値は、次の ABNF `RFC5234$r で表現される：
◎
The Timing-Allow-Origin HTTP response header field can be used to communicate a policy indicating origin(s) that are allowed to see values of attributes that would have been zero due to the cross-origin restrictions. The header's value is represented by the following ABNF [RFC5234]:
</p>

<pre class="ABNF">
Timing-Allow-Origin = 1#( `origin-or-null$P / `wildcard$P )
</pre>

<p>
送信者は、複数個の `Timing-Allow-Origin$h ~headerを生成して~MAY。
受信者は、複数個の `Timing-Allow-Origin$h ~headerに対しては、それらの~headerの値を順に~commaで区切って連結して， 1 つの~headerに結合して~MAY。
◎
The sender MAY generate multiple Timing-Allow-Origin header fields. The recipient MAY combine multiple Timing-Allow-Origin header fields by appending each subsequent field value to the combined field value in order, separated by a comma.
</p>

<p>
`計時~許可検査@
~algoは、資源の計時~情報が`現在の文書$と共有し得るかどうかを，以下に従って検査する
— 結果が `合格^i ならば、 “合格した” とされる：
◎
The timing allow check algorithm, which checks whether a resource's timing information can be shared with the current document, is as follows:
</p>

<ol>
	<li>
~IF［
資源は`同一生成元$x
］
⇒
~RET `合格^i
◎
If the resource is same origin, return pass.
</li>
	<li>
%V ~LET `Timing-Allow-Origin$h の~header値
◎
↓</li>
	<li>
~IF［
%V ~EQ `wildcard$P （ `*^l ）
］
⇒
~RET `合格^i
◎
↓</li>
	<li>
~IF［
`現在の文書$の`生成元$xの値 ~EQ %V 内のある `origin-or-null$P 成分
］
⇒
~RET `合格^i
◎
If the Timing-Allow-Origin header value list contains a case-sensitive match for the value of the origin of the current document, or a wildcard ("*"), return pass.
</li>
	<li>
~RET `不合格^i
◎
Return fail. 
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="process">
<h2 title="Process">5. 処理過程</h2>

		<section id="processing-model">
<h3 title="Processing Model">5.1. 処理~model</h3>

<p>
`PerformanceResourceTiming$I
~interfaceに定義される計時~属性を次の図式に示す。
括弧内の属性は、資源が`非同一生成元$から`~fetch$xされている下では，可用でない。
~UAは、非標準の時区間を許容するために，２つの計時の合間に内部~処理を行ってもよい。
◎
The following graph illustrates the timing attributes defined by the PerformanceResourceTiming interface. Attributes underlined may not be available when fetching resources from different origins. User agents may perform internal processing in between timings, which allow for non-normative intervals between timings.
</p>

<figure>
<div id="_time-table">
（時間は下に向かって進行する。）
	<div>
<div style="top:-0.5em">← `startTime$m ／  ( `redirectStart$m )</div>
~redirect
<div style="bottom:-0.5em">← ( `redirectEnd$m )</div>
	</div>
	<div>
<div style="top:-0.5em">← `fetchStart$m</div>
~app~cache
	</div>
	<div>
<div style="top:-0.5em">← `domainLookupStart$m</div>
DNS
<div style="bottom:-0.5em">← `domainLookupEnd$m</div>
	</div>
	<div>
<div style="top:-0.5em">← `connectStart$m</div>
<div style="top:0.5em">← `secureConnectionStart$m</div>
TCP
<div style="bottom:-0.5em">← `connectEnd$m</div>
	</div>
	<div style="margin-bottom:0">
<div style="top:-0.5em">← `requestStart$m</div>
要請
	</div>
	<div style="margin-top:0">
<div style="top:-0.5em">← `responseStart$m</div>
応答
<div style="bottom:-0.5em">← `responseEnd$m</div>
	</div>
</div>
<!-- resource-timing-overview-1.png >
 -->
</figure>

<p>
現在の`閲覧文脈$xにおいて
<a href="~FETCH#concept-fetch">~fetch</a>
される
~EACH ( 資源 ) に対し：
◎
For each resource fetched by the current browsing context, excluding resources fetched by cross-origin stylesheets fetched with no-cors policy, perform the following steps:
</p>


<ol>
	<li>
<p>
~IF［
資源は
`no-cors^i ~policyの下で~fetchされる
非同一生成元~stylesheetである
］
⇒
~CONTINUE
◎
↑</p>

<p class="issue">
この非同一生成元の除外は、
Fetch registry を介して定義されるべきである：
CSS については、 Fetch の用語, および［
no-CORS CSS 下位資源に対し
何らかの “不透明な要請~flag” のような類の~flagを ~ON にすること
］を通して定義される必要がある。
しかる後、 Resource Timing において，資源~fetch~eventを表面化させるために
Fetch registry と~interfaceするべきである。
◎
Issue 1
◎
Above cross-origin exclusion should be defined via Fetch registry: CSS needs to be defined in terms of Fetch and set some kind of "opaque request flag" for no-CORS CSS subresources. In turn, Resource Timing should interface with Fetch registry to surface resource fetch events.
</p>
	</li>
	<li>
<p >
`~obj作成@i：
</p>
		<ol>
			<li>
%object ~SET 新たな `PerformanceResourceTiming$I ~obj
◎
↓</li>
			<li>
%object の `entryType$m ~SET `resource^l
◎
Create a new PerformanceResourceTiming object and set entryType to the DOMString resource.
</li>
			<li>
資源の検索取得を待行列に入れる直前に
⇒
%object の `startTime$m ~SET `現在の時刻$；<br />
%object の `nextHopProtocol$m ~SET 空~文字列
◎
Immediately before the user agent starts to queue the resource for retrieval, record the current time in startTime, and set nextHopProtocol to the empty DOMString.
</li>
			<li>
%object の `initiatorType$m ~SET 資源の起動元
◎
Record the initiator of the resource in initiatorType.
</li>
			<li>
%object の `name$m ~SET 要請した資源の`解決済み URL$x
</li>
			<li>
<p>
~IF［
現在の［
`閲覧文脈$x `HTML5$r ／ ~worker文脈 `WORKERS$r
］に`合致する作動中の~worker$x %worker はある
`SERVICE-WORKERS$r
］：
</p>
				<ol>
					<li>
~IF［
%worker はすでに可用である
］
⇒
%worker に向けて`名前~fetch_evの~eventを発火する$x直前に
⇒
%object の `workerStart$m ~SET `現在の時刻$
</li>
					<li>
~ELSE
⇒
その %worker を`走らす$x直前に
⇒
%object の `workerStart$m ~SET `現在の時刻$
</li>
				</ol>
<!-- ＊
~link先が変？ `run a worker$x ？
 -->
◎
Record the resolved URL of the requested resource in name. If there is an active worker ([SERVICE-WORKERS]) matching the current browsing or worker context's, immediately before the user agent runs the worker record the time as workerStart, or if the worker is already available, immediately before the event named `fetch` is fired at the active worker record the time as workerStart. Otherwise, if there is no matching service worker registration, set workerStart value to zero.
</li>
			<li>
~ELSE（合致する`~service~worker登録$xはない）
⇒
%object の `workerStart$m ~SET 0
◎
↑</li>
		</ol>
	</li>
	<li>
<p>
`~fetch開始@i：
</p>
		<ol>
			<li>
%fetchStart ~LET `現在の時刻$
</li>
			<li>
%object の `fetchStart$m ~SET %fetchStart
</li>
			<li>
`~fetching$xを開始する直前に
⇒
%object の［
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m
］ ~SET %fetchStart
</li>
		</ol>

<p>
</p>

◎
Immediately before a user agent starts the fetching process, record the current time as fetchStart. Let domainLookupStart, domainLookupEnd, connectStart and connectEnd be the same value as fetchStart.
</li>
	<li>
<p>
`収集~開始@i：
</p>
		<ol>
			<li>
~IF［
別の既存の~data, あるいは すでに完了した［
`現在の文書$から起動された`~fetch$x
］による~dataを再利用する
］
⇒
~RET
◎
If the user agent is to reuse the data from another existing or completed fetch initiated from the current document, abort the remaining steps.
</li>
			<li>
<p>
~IF［
~redirectされなかった最後の資源`~fetch$xは，`計時~許可検査$に合格しなかった
］：
</p>
				<ol>
					<li>
%object の［
`redirectStart$m,
`redirectEnd$m,
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m,
`requestStart$m,
`responseStart$m,
`secureConnectionStart$m
］属性 ~SET ゼロ
</li>
					<li>
~GOTO `応答~終了0$i
</li>
				</ol>

◎
If the last non-redirected fetch of the resource fails the timing allow check, the user agent MUST set redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, connectEnd, requestStart, responseStart and secureConnectionStart to zero and go to step 16.
</li>
			<li>
%object の［
`domainLookupStart$m,
`domainLookupEnd$m,
`connectStart$m,
`connectEnd$m
］属性 ~SET %fetchStart
◎
Let domainLookupStart, domainLookupEnd, connectStart and connectEnd be the same value as fetchStart.
</li>
			<li>
~IF［
資源は`局所~cache等$（ `~HTTP~cache$x `RFC7234$r も含む）から~fetchされている
］
⇒
~GOTO `要請~開始$i
◎
If the resource is fetched from the relevant application cache or local resources, including the HTTP cache [RFC7234], go to step 14.
</li>
			<li>
~IF［
~domain~検索は不要
］
⇒
~GOTO `接続-開始$i
◎
↓</li>
			<li>
~domain名~検索を開始する直前に
⇒
%object の `domainLookupStart$m ~SET `現在の時刻$
◎
If no domain lookup is required, go to step 12. Otherwise, immediately before a user agent starts the domain name lookup, record the time as domainLookupStart.
</li>
			<li>
<p>
~domain名~検索を終えた直後に（~UAは、その前に複数の再試行を要し得る）：
</p>
				<ol>
					<li>
~IF［
検索は成功した
］~OR［
資源は `計時~許可検査$に合格した
］
⇒
%object の `domainLookupEnd$m ~SET `現在の時刻$
</li>
					<li>
~IF［
検索は失敗した
］
⇒
~GOTO `最終~記録-$i
</li>
				</ol>
◎
Record the time as domainLookupEnd immediately after the domain name lookup is successfully done. A user agent may need multiple retries before that. If the domain name lookup fails and resource passes the timing allow check record the time as domainLookupEnd and go to step 17.
</li>
		</ol>
	</li>
	<li>
<p >
`接続-開始@i：
</p>
		<ol>
			<li>
~IF［
資源`~fetch$xに持続的~transport接続が利用されている
］
⇒
%object の［
`connectStart$m, `connectEnd$m
］ ~SET %object の `domainLookupEnd$m と同じ値
◎
↓</li>
			<li>
<p>
~ELSE：
</p>
				<ol>
					<li>
~serverへの接続を起動する直前に
⇒
%object の `connectStart$m ~SET `現在の時刻$
</li>
					<li>
接続-処理-を終えた時点で（~UAは、この時点より前に複数の再試行を要し得る）
⇒
%object の `connectEnd$m ~SET `現在の時刻$
</li>
					<li>
~IF［
~serverまたは~proxyへの接続を確立できた
］
⇒
%object の `nextHopProtocol$m 値 ~SET 接続に利用されている ALPN ID
</li>
					<li>
~ELSE（接続を確立できなかった）
⇒
~GOTO `最終~記録-$i
</li>
				</ol>

◎
If a persistent transport connection is used to fetch the resource, let connectStart and connectEnd be the same value of domainLookupEnd. Otherwise, record the time as connectStart immediately before initiating the connection to the server and record the time as connectEnd immediately after the connection to the server or the proxy is established. A user agent may need multiple retries before this time. Once connection is established set the value of nextHopProtocol to the ALPN ID used by the connection. If a connection can not be established, record the time up to the connection failure as connectEnd and go to step 17.
</li>
			<li>
~IF［
保安的~transportが利用されている
］
⇒
接続を保安化する~handshake処理-の直前に
⇒
%object の `secureConnectionStart$m ~SET `現在の時刻$
◎
The user agent MUST set the secureConnectionStart attribute as follows:
◎
When a secure transport is used, the user agent MUST record the time as secureConnectionStart immediately before the handshake process to secure the connection.
</li>
			<li>
~ELSE
⇒
%object の `secureConnectionStart$m ~SET 0
◎
When a secure transport is not used, the user agent MUST set the value of secureConnectionStart to 0.
</li>
		</ol>
	</li>
	<li>
`要請~開始@i
⇒
資源に対する要請の送信を開始する直前に
⇒
%object の `requestStart$m ~SET `現在の時刻$
◎
Immediately before a user agent starts sending the request for the resource, record the current time as requestStart.
</li>
	<li>
`応答~開始@i
⇒
応答の最初の~byteを受信した直後に
⇒
%object の `responseStart$m ~SET `現在の時刻$
◎
Record the time as responseStart immediately after the user agent receives the first byte of the response.
</li>
	<li>
<p>
`応答~終了0@i：
</p>
		<ol>
			<li>
<p>
~IF［
要請の送信-, または応答~全体の受信-に失敗したため，接続を再~openする必要がある
］
⇒
~GOTO `接続-開始$i
◎
Record the time as responseEnd immediately after receiving the last byte of the response.↓
◎
Return to step 12 if the user agent fails to send the request or receive the entire response, and needs to reopen the connection.
</p>

<p class="example">
例えば，`持続的~接続$x `RFC7230$r が可能化されているときは、まず最初に，要請を送信するための~open接続の再利用を（その接続は`非同期に~close$xされ得るが）試行してよい。
そのような場合、［
`connectStart$m,
`connectEnd$m,
`requestStart$m
］は，再~open接続において収集された計時~情報を表現するべきである。
◎
When persistent connection [RFC7230] is enabled, a user agent may first try to re-use an open connect to send the request while the connection can be asynchronously closed. In such case, connectStart, connectEnd and requestStart SHOULD represent timing information collected over the re-open connection.
</p>
			</li>
			<li>
応答の最後の~byteを受信した直後に
⇒
%object の `responseEnd$m ~SET `現在の時刻$
◎
↑</li>
			<li>
%object の［
`transferSize$m,
`encodedBodySize$m, 
`decodedBodySize$m
］ ~SET それぞれの属性の定義に従う値
— これらは、`計時~許可検査$の対象になる。
◎
Set the value of transferSize, encodedBodySize, decodedBodySize to corresponding values, subject to timing allow check algorithm.
</li>
		</ol>
	</li>
	<li>
<p>
`最終~記録-@i：
</p>
		<ol>
			<li>
~IF［
%object の `responseEnd$m はまだ設定されていない
］
⇒
%object の `responseEnd$m ~SET `現在の時刻$
</li>
			<li>
%object の `duration$m ~SET
( %object の `responseEnd$m ) − ( %object の `startTime$m )
</li>
		</ol>
◎
If responseEnd is not set, set it to the current time. Record the difference between responseEnd and startTime in duration.
</li>
	<li>
<p>
~IF［
資源が~fetchされた結果が`~redirect等$になった
］：
◎
If the fetched resource results in an HTTP redirect or equivalent, then
</p>

		<ol style="list-style-type:lower-alpha;">
			<li>
`新たな資源^v ~SET ~redirect先の資源
◎
↓</li>
			<li>
~IF［
現在の資源と `新たな資源^v は，いずれも［［
`現在の文書$と`同一生成元$xからのものでない
］~AND［
`計時~許可検査$の結果 ~EQ `不合格^i
］］］
⇒
%object の［
`redirectStart$m, `redirectEnd$m
］~SET 0
◎
If the current resource and the redirected resource are not from the same origin as the current document, and the timing allow check algorithm fails for either resource, set redirectStart and redirectEnd to 0. Then, return to step 5 with the new resource.
</li>
			<li>
<p >
~ELSE：
</p>
				<ol>
					<li>
~IF［
%object の `redirectStart$m の値はまだ設定されていない
］
⇒
%object の `redirectStart$m ~SET %fetchStart
◎
If the value of redirectStart is not set, let it be the value of fetchStart.
</li>
					<li>
%object の `redirectEnd$m ~SET %object の `responseEnd$m の値
◎
Let redirectEnd be the value of responseEnd.
</li>
					<li>
［［
`startTime$m,
`redirectStart$m,
`redirectEnd$m,
`initiatorType$m
］を除く，
%object のすべての属性
］ ~SET 0 
◎
Set all the attributes in the PerformanceResourceTiming object to 0 except startTime, redirectStart, redirectEnd, and initiatorType.
</li>
				</ol>
			</li>
			<li>
資源 ~SET `新たな資源^v
◎
↓</li>
			<li>
~GOTO `~fetch開始$i
◎
Return to step 5 with the new resource.
</li>
		</ol>
	</li>
	<li id="step-final-queue">
%object を`待入する$
◎
Queue the PerformanceResourceTiming object.
</li>
	<li>
%object を`追加する$
◎
Add the PerformanceResourceTiming object.
</li>
</ol>

		</section>
		<section id="monotonic-clock">
<h3 title="Monotonic Clock">5.2. 単調増加~clock</h3>
<p>
計時~属性の値は、資源`~fetch$xの間，計時~属性が~system~clock調整により~skewされないように、単調増加で~MUST。
時系列順に記録された２つの計時~属性の差分は決して負であっては~MUST_NOT。
文書の下位~資源も含めた，すべての資源において、~UAは根元の文書~naviの開始時点の~system~clockを記録し，後続の計時~属性は、~naviの開始からの経過時間を測定する単調増加~clockの下で定義され~MUST。
◎
The value of the timing attributes MUST monotonically increase to ensure timing attributes are not skewed by adjustments to the system clock while fetching the resource. The difference between any two chronologically recorded timing attributes MUST never be negative. For all resources, including subdocument resources, the user agent MUST record the system clock at the beginning of the root document navigation and define subsequent timing attributes in terms of a monotonic clock measuring time elapsed from the beginning of the navigation.
</p>

		</section>
	</section>
	<section id="privacy-security">
<h2 title="Privacy and Security">6. ~privacyと保安</h2>

~INFORMATIVE

<p>
`PerformanceResourceTiming$I
~interfaceは、資源を要請した［
~web~page／~worker
］に，その資源の計時~情報を公開する。
`PerformanceResourceTiming$I ~interfaceへの~accessを制限するため、既定では`同一生成元$x~policyが課せられ，
<a href="#cross-origin-resources">非同一生成元~資源</a>
節にて述べたように，一部の属性はゼロに設定される。
資源の提供側は、 `Timing-Allow-Origin$h ~HTTP応答~headerを追加して，その値に
計時~情報への~accessを許容する~domainを指定することにより，資源に対するすべての計時~情報の収集を明示的に許容できる。
◎
The PerformanceResourceTiming interface exposes timing information for a resource to any web page or worker that has requested that resource. To limit the access to the PerformanceResourceTiming interface, the same origin policy is enforced by default and certain attributes are set to zero, as described in 4.5 Cross-origin Resources. Resource providers can explicitly allow all timing information to be collected for a resource by adding the Timing-Allow-Origin HTTP response header, which specifies the domains that are allowed to access the timing information.
</p>

<p>
統計上の痕跡（ statistical fingerprinting ）は、悪意的な~web~siteが、第三者~web~site内の資源に対する~cacheの~hit／~missの時機を測定することにより、利用者が第三者~web~siteを訪問したかどうかを決定し得る点で、~privacyに関わる問題になる。
`PerformanceResourceTiming$I
~interfaceは，文書~内の資源の計時~情報を供するが、
<a href="#cross-origin-resources">非同一生成元の制約</a>
があるため、この~privacyの懸念を，［
今日すでにある，資源に対する load ~eventから時機を測定して~cacheの~hit／~missを決定する手法
］より，悪化させるものにはならない。
◎
Statistical fingerprinting is a privacy concern where a malicious web site may determine whether a user has visited a third-party web site by measuring the timing of cache hits and misses of resources in the third-party web site. Though the PerformanceResourceTiming interface gives timing information for resources in a document, the cross-origin restrictions prevent making this privacy concern any worse than it is today using the load event on resources to measure timing to determine cache hits and misses.
</p>

	</section>

</main></div><!-- id="MAIN"／MAIN0 -->

	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
この仕事に協力された次の方々に謝意を：
</p>

<p>
We would like to sincerely thank Karen Anderson, Darin Fisher, Tony Gentilcore, Nic Jansma, Kyle Scholz, Jonas Sicking, James Simonsen, Steve Souders, Annie Sullivan, Sigbjørn Vik, Jason Weber to acknowledge their contributions to this work.
</p>

	</section>
	<section id="references">
<h2 title="References">参照文献</h2>


		<section id="normative-references">
<h3 title="Normative References">文献（規範）</h3>

<script type="text/plain" class="ref_data">
[CSS-SYNTAX-3]
    CSS Syntax Module Level 3. Tab Atkins Jr.; Simon Sapin. W3C. 20 February 2014. W3C Candidate Recommendation. URL: https://www.w3.org/TR/css-syntax-3/ 
[DOM]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HR-TIME-2]
    High Resolution Time Level 2. Ilya Grigorik; James Simonsen; Jatinder Mann. W3C. 1 November 2016. W3C Candidate Recommendation. URL: https://www.w3.org/TR/hr-time-2/ 
[HTML5]
    HTML5. Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Theresa O’Connor; Silvia Pfeiffer. W3C. 28 October 2014. W3C Recommendation. URL: https://www.w3.org/TR/html5/ 
[PERFORMANCE-TIMELINE-2]
    Performance Timeline Level 2. Ilya Grigorik; Jatinder Mann; Zhiheng Wang. W3C. 8 December 2016. W3C Candidate Recommendation. URL: https://www.w3.org/TR/performance-timeline-2/ 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC2397]
    The "data" URL scheme. L. Masinter. IETF. August 1998. Proposed Standard. URL: https://tools.ietf.org/html/rfc2397 
[RFC5234]
    Augmented BNF for Syntax Specifications: ABNF. D. Crocker, Ed.; P. Overell. IETF. January 2008. Internet Standard. URL: https://tools.ietf.org/html/rfc5234 
[RFC6454]
    The Web Origin Concept. A. Barth. IETF. December 2011. Proposed Standard. URL: https://tools.ietf.org/html/rfc6454 
[RFC7230]
    Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7230 
[RFC7231]
    Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7231 
[RFC7234]
    Hypertext Transfer Protocol (HTTP/1.1): Caching. R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7234 
[RFC7301]
    Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension. S. Friedl; A. Popov; A. Langley; E. Stephan. IETF. July 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7301 
[SERVICE-WORKERS]
    Service Workers 1. Alex Russell; Jungkee Song; Jake Archibald; Marijn Kruisselbrink. W3C. 11 October 2016. W3C Working Draft. URL: https://www.w3.org/TR/service-workers-1/ 
[WORKERS]
    Web Workers. Ian Hickson. W3C. 24 September 2015. W3C Working Draft. URL: https://www.w3.org/TR/workers/ 
[WebIDL]
    Web IDL. Cameron McCormack; Boris Zbarsky; Tobie Langel. W3C. 15 December 2016. W3C Working Draft. URL: https://www.w3.org/TR/WebIDL-1/ 
[XMLHttpRequest]
    XMLHttpRequest Level 1. Anne van Kesteren; Julian Aubourg; Jungkee Song; Hallvord Steen et al. W3C. 6 October 2016. W3C Note. URL: https://www.w3.org/TR/XMLHttpRequest/ 
</script>




		</section>
		<section id="informative-references">
<h3 title="Informative References">文献（参考）</h3>

<script type="text/plain" class="ref_data">
[ECMA-262]
    ECMAScript Language Specification. Ecma International. URL: https://tc39.github.io/ecma262/ 
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[NAVIGATION-TIMING]
    Navigation Timing. Zhiheng Wang. W3C. 17 December 2012. W3C Recommendation. URL: https://www.w3.org/TR/navigation-timing/ 
[NAVIGATION-TIMING-2]
    Navigation Timing Level 2. Ilya Grigorik; Tobin Titus; Jatinder Mann; Arvind Jain. W3C. 6 March 2017. W3C Working Draft. URL: https://www.w3.org/TR/navigation-timing-2/ 
[RFC5246]
    The Transport Layer Security (TLS) Protocol Version 1.2. T. Dierks; E. Rescorla. IETF. August 2008. Proposed Standard. URL: https://tools.ietf.org/html/rfc5246 
[SVG11]
    Scalable Vector Graphics (SVG) 1.1 (Second Edition). Erik Dahlström; Patrick Dengler; Anthony Grasso; Chris Lilley; Cameron McCormack; Doug Schepers; Jonathan Watt; Jon Ferraiolo; Jun Fujisawa; Dean Jackson et al. W3C. 16 August 2011. W3C Recommendation. URL: https://www.w3.org/TR/SVG11/ 
[WEBIDL]
    Web IDL. Cameron McCormack; Boris Zbarsky; Tobie Langel. W3C. 15 December 2016. W3C Working Draft. URL: https://www.w3.org/TR/WebIDL-1/
</script>


		</section>
	</section>


</body></html>

