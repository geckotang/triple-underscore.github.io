<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Communication（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

var source_data;

COMMON_DATA.page_state_key = '___HTML';
COMMON_DATA.init = function(expanded){
	var options = {
		spec_status: 'LS',
		original_url: 'https://html.spec.whatwg.org/multipage/comms.html',
		main: 'MAIN',
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'comms',
		collectParts: Util.collectParts,
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 161202 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		E: 'error',
		P: 'production',
		et: 'event-type',
		st: 'attr-state',
		sl: 'js-slot',
		jT: 'js-type',
		jA: 'abstract',
		v: 'value',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code', // IDL
		m: 'code', // IDL
		E: 'code', // err
		c: 'code', 
		e: 'code', // elem
		a: 'code', // attr
		et: 'code',
		st: 'span',
		sl: 'span',
		jA: 'span',
		jT: 'code',
		P: 'code',
		v: 'code', // attr value
		t: 'var',
		i: 'i',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var context = '';
	
	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^<◎]*|%[\w\-~一-鿆あ-ん]+|``?(.+?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);


	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}//◎
	result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'bl': // byte literal
	text = '`<code class="literal">' + key + '</code>`';
	break;
case 'h': // HTTP header
	text = '`<code class="header">' + key + '</code>`';
	break;
case 'sl': // js slot
	text = '[[' + key + ']]';
	break;
case 'P': // production
	href = '#_p.' + key;
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case '0x': // escape '%'
	return '%x' + key;
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
}

if(match[1] === '`') {
	if(indicator === '^'){
		context = key;
	} else {
		klass = klass + '!' + context;
	}
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_original_id_map">

</script>

<!--% 置換データ -->
<script type="text/plain" id="words_table1">
此れ:<b>これ°</b>
BroadcastChannel:<code>BroadcastChannel</code> 
MessagePort:<code>MessagePort</code> 

</script>

<script type="text/plain" id="words_table">

	●仕様（動詞
協調-:coordinate:~
協調:coordination:~
取扱う:handle する:取り扱う
取扱い:handling:取り扱い
不許可に:disallow:~
依存-:depend:~
依拠-:rely:~
保証:guarantee:~
切替えれ:switch でき:~
切替える:switch する:~
判別-:distinguish:~
	判別できない:distinguishableでない
受容-:accept:~
無視-:ignore:~
	生-:occur:~
発展:evolution:~
拘束:constraint:~
結付けて:associate して:結び付けて
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
要求-:require:~
解釈-:interpret:~
述べる:describe する:~
述べた:describe した:~
督促-:urge:~
確保-:ensure:~
計算:computation:~
見做して:assume して:~
設計:design:~
許容-:allow:~
試み:attempt:~
試みら:attempt さ:~
試みな:attempt しな:~
試行-:try:~
論じら:discuss さ:~
開発:development:~
開発者:developer:~
関係-:relate:~
関係性:relationship:~
防止-:prevent:~
遂行-:perform:~
運用者:operator:~
適用-:apply:~
避ける:avoid する:~
存在-:exist:~
使役-:employ:~
達-:reach:~
到達-:reach:~
	到達でき:reachable:~
制約-:restrict:~
制限-:limit:~
	制限-法:limiting
制限:limitation:~
	利用-:use:~
利用者:user:~
被呼出時:被 invoke 時:~
呼出す::invoke する:呼び出す
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
呼出して:invoke して:呼び出して
報告-:report:~
奨励-:encourage:~
孕まれ:involve され:~
定義-:define:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
完了-:complete:~
尊守-:honor:~
導入-:introduce:~
影響-:affect:~
意味-:mean:~
意図-:intend:~
所与の:given:与えられた
抑制-:reduce:~
指定-:specify:~
指示-:indicate:~
支援-:aid:~
模倣-:emulate:~
望む:wish する:~
予期-:expect:~
期待-:expect:~
	予期されずに:unexpected
検証0-:verify:検証
求めた:want した:~
求めて:want して:~
求めな:want しな:~
求める:want する:~
相互作用-:interact:やりとり
走って:run して:~
走る:run する:~
走らす:run する:走らせる
走らせ:run し:~
制御:control:~
抽象:abstract:~
	抽象~化:abstracting out
勧める:advise する:~
	放置-:forgot
働かな:work しな:~
	ことにした-:decide
	using:
	consist:
	told:
	know:
	警戒:cautioned
	もたらす:lead
	〜とする:suppose


	●仕様
API:
Web:
OS:operating system:OS
UA:user agent:UA
model::::モデル
browser::::ブラウザ
bug::::バグ
library::::ライブラリ
software::::ソフトウェア
web::::
support::::サポート
	未~supportの:unsupported:~
system::::システム
advice::::アドバイス
debug::::デバッグ
panel::::パネル
	一定の:certain:~
	ある種の:certain:~

不完全:incomplete:~
事例:case:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
任意の:arbitrary:~
余分の:extra:~
作者:author:~
便益:benefits:~
原則的:principle:~
可用:available:~
	可能性:possibility:~
	見込みが高い:likely
問題:problem:~
完全:complete:~
実用的:practical:~
	実用的でなくなるimpractical
実際:actual:~
対称:symmetric:~
専用の:dedicated:~
手動:manual:~
手続き:steps:~
技術:technology:~
方式:manner:~
既存の:existing:~
既定の:default:~
既知の:known:~
旧来の:legacy:~
明示的:explicit:~
暗黙的:implicit:~
含意:implications:~
含意-:imply:~
有意:significant:~
本質的:essential:~
条態:condition:~
概して:typical に:~
機会:chance:~
機能性:functionality:~
正しい:correct な:~
注意深く:careful に:~
注意-:care:~
	格別に注意する:extra care
特定0の:particular:ある特定の
特定の:specific:~
特色機能:feature:~
状況:situation:~
独立:independent:~
理由:reason:~
目的:purpose:~
直接的:direct:~
相似的:analogous:~
相違:difference:~
便利用:convenient:~
著作:authoring:~
複雑:complex:~
複雑さ:complexity:~
要件:requirements:~
規則:rule:~
診断:diagnostic:~
詳細な:detailed:~
通常の:normal な:~
通常は:normal には:~
適切:appropriate:~
適合性:conformance:~
	大げさすぎるunreasonable overhead
重要:important:~
高価:expensive:~
考慮-:consider:~
見なさ:consider さ:~
考える:consider する:~
無益:futile:~
特定的:specific:~
的意味:sense:の意味
難点:difficulties:~
解決策:solution:~
基礎:basis:~
簡易的:naïve:~
効果:effect:~
black-box::::ブラックボックス
仮想の:virtual:~

	任意選択:may／optional
	具体例として:for instance
	呼応:in response to／
	~~消費:usage
	~~等価:
	~~要請:ask
	不要:no longer needed
	-:criteria
	似た命名の:similarly-named
	例:example
	依然として:still
	個々の:individual
	別の:another
	十分:enough
	するに足るだけ:only enough to
	~~主な違い:key difference
	各:each
	合間:between
	同じ:same
	含-:include
	場合によっては:possibly
	多数の:many
	常に:always
	序論:introduction
	後:after
	得-:obtain
	必然:necessarily
	必要-:need
	更なる:further
	最初の:first
	最後の:last
	決して:never
	渡-:pass
	現時点では:currently
	異なる:different
	種々の:various
	等々:etc
	節:section
	結果:result
	自身:itself／
	複数の:multiple
	関わらず:regardless
	言い換えれば:In other words
	特に、:in particular
	類似する:similar
	最小限，:at a minimum
	束ねられ:tied
	できないことinability
	利用できなく:unusable／usable
	逆も同様／互いに:vice-versa
	抗して:against
	〜に因り:due
	少ししか:little to no
	更には、:furthermore
	当の:in question
	より高度に:advance
	おそらく，:probably
	~~相当:considerable
	手の込んだ:elaborate
	目に見える:apparent
	amongst:
	optionally:
	potentially
	あるいはalternatively
	無論:of course
	ばかりの:just been
	こっち:over here
	そっち:your
	委ねる:opening up
	確かめる:make sure
	引き継いで:continuing
	司る:take over
	することもあり得るpossibility of 〜 trying to
	困らされる:run into trouble
	関知しない:unaware
	経過を辿る:timeline
	〜に基づく:based／-based
	〜の代わりに:instead
	しかしながら，:however
	したがって:therefore／thus
	とりわけ:especially
	まったくin the slightest
	より良い:better
	単に:merely
	何か anything
	これら二者:together
	特に:most particularly
	自らに利する:on its behalf
	困った:rather unfortunate
	要は:key

	●network / messaging
DNS:
CORS:
HTTP:
MIME:
URL:
TCP:
chunking::::チャンク処理
redirect::::リダイレクト
scheme::::スキーム
url:
	url~record:urlRecord
address::::アドレス
address-book:address book::address 帳:アドレス帳
e-mail::::メール
メールアドレス:contact:::~
social::::ソーシャル

IP:
cache::::キャッシュ
client::::クライアント
domain::::ドメイン
fetch:
fetching:::fetch 処理
navigate::::ナビゲート
network::::ネットワーク
port::::ポート
protocol::::プロトコル
proxy::::プロキシ
record::::レコード
server::::サーバ
	~server単位の:per-server
server-sent::::サーバ送信
	server側:server-side
	server-push
service::::サービス
serve::::サービス供与
site::::サイト
web-socket:web socket
header::::ヘッダ
host::::ホスト
hostname::::ホスト名
path::::パス
rate::::レート
	rate-limiting

push::::プッシュ
投函-:post::~::ポスト
	投函~法:posting
投函済み:posted::~::ポスト済み
broadcast::::ブロードキャスト
access::::アクセス
文書間:cross-document:~
channel::::チャンネル
close::::
	~close済み:closed

message::::メッセージ
messaging:::message 法:メッセージ法
open::::
opening::::
pipe::::パイプ
remote::::リモート
session::::セッション
source::::ソース
	source設定群:sourceSettings#3
status::::ステータス
listen::::リッスン
listener::::リスナ

受信-:receive::~
受信器:receiver::~
受信者:recipient::~
返信-:send back::~
送信-:send::~
送達-:deliver::~
応答-:respond::~
応答:response::~
成功裡:successful::~
通信-:communicate::~
通信:communication::~
切断-:disconnect::~
再接続-:reconnect::~
再接続:reconnection::~
接続-:connect::~
接続:connection::~
	接続できない:no network connectivity:~
無接続:connectionless::~
確立-:establish::~
再確立-:reestablish::~
伝送路:wire::~
	切れた:died

	負荷を加える:overloading:~
負荷移譲:offload::~
資格証:credentials::資格証明情報::クレデンシャル
資源:resource::~:リソース
連絡-:entangle::~
連絡:entangle::~
	連絡を解く:disentangle:~
伝送-:transmit::~
framing::::フレーミング
添付-:attach:~
主体:entity:~
宛先:target::~
流通:traffic:~
素片:fragment::~
過負荷に:overloaded:~
動作-:act:~
活動:activity:~
接触-:contact:~
運ぶ:convey する:~
消去っ:go away し:消え去っ

	●保安
DoS:denial-of-service:DoS
XSS:cross-site scripting:XSS
privacy::::プライバシー
risk::::リスク
保安:security::~:セキュリティ
log-in:log in:::ログイン
log-out:log out:::ログアウト
同一生成元:same-origin::~::同一オリジン
生成元:origin::~::オリジン
攻撃:attack:~
攻撃者:attacker:~
能力:capability:~
	~obj能力:object-capability
安全:safe:~
悪用-:exploite:~
完全性:integrity:~
敵対的:hostile:~
機密的:confidential:~
濫用-:abuse:~
漏洩-:leak:~
漏洩:leakage:~
特権:privilege:~
上品:graceful:~
保護-:protect:~
信用-:trust:~
信用済み:trusted:~
信頼性:reliability:~
未検査の:unchecked:~
検査-:check:~
欠陥:flaw:~
是認-:grant:~
動作者:actor:~
提供-:provide:~
提供者:provider:~
消費者:consumer:~
	大容量:high volume:~
増殖-:multiply:~

	●処理model
comment::::コメント
handler::::ハンドラ
現任の:incumbent:~
mark::::マーク
call::::
algo:algorithm:::アルゴリズム
locking::::ロック処理
阻む:block する::~::ブロックする
console::::コンソール
clone::::
	clone~record:cloneRecord
error::::エラー
flag::::フラグ
flow::::フロー
garbage::::ガーベジ
script::::スクリプト
scripting::::スクリプト処理
code::::コード
task::::タスク
event-loop:event loop:::イベントループ
event::::イベント
源:source::~::ソース
cross-process::::プロセス間
搬送済み:shipped::~
未搬送の:unshipped::~

待行列:queue::待ち行列::キュー
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ
待入し:queue し::待ち行列に入れ::キューし
公告-:announce::~
転送-:transfer::~
転送可能:transferable::~
保持体:holder::~::ホルダ
通知:notification::~
遅延:delay::~
一時停止-:pause::~
所有者:owner::~
待機-:wait::~
取消した:cancel した::取り消した::キャンセルした
	cancelation
破棄-:discard:~
伝播-:propagate::~
可能化-:enable::~
不能化-:disable::~
不能化:disabled::~
中断-:interrupt::~
中止-:abort::~
再収集-:recollect::~
停止-:stop::~
公開-:expose:~
共有-:share::~
共用:shared::~
再設定-:reset::~::リセット
再試行-:retry::~
処理-:process:~
処理:processing:~
回送-:forward::~
強く:strong に:~
強い:strong な:~
弱い:weak な:~
環境:environment:~
検出-:detect:~
同時的:simultaneous:~
同期:synchronization:~
作動中の:active な::~::アクティブな
作動中:active::~::アクティブ
作成-:create:~
作成:creation:~
保つ:keep する:~
保たれ:keep され:~
保って:keep して:~
強制的:forcible:~

致命的:fatal:~
再投出:rethrow:~
投出:throw:~
例外:exception:~
例外投出あり:rethrow any exceptions:~
	用意が整った旨:readiness:~
状態:state:~
永続的:permanent:~
操作-:manipulate:~
操作:manipulation:~
構築:construction:~
構築-:construct:~
構築子:constructor::~::コンストラクタ
発火-:fire::~
登録-:register::~
行先:destination::~
要請:request::~::リクエスト
設置-:place:~
誘発-:trigger::~
配送-:dispatch::~
並列的:parallel::~
休止可能:suspendable::~
即座:prompt::~
認知-:acknowledge:~
継続-:continue:~
保守-:maintain:~
	短い:short
	二重化された:two-ways
破棄予定:doomed:~
	古いものから順:oldest first
	最早／それ以降:no longer
	最初の~~段階in the first place 
	~~寿命:life
	生きた:live な:~
	長く生き残る:long-lived
	~~維持し続ける:keeping alive
	生き残り続け:continue to live
	中途:in the middle of
	残り続ける:remain
	最終的:final
	最終:final
不定期:occasional:~
分散的:distributed:~
遊休:idle:~
	間:during
exponential-backoff::ベキ乗打ち切り待機法
	分:minute:~
	失われ:lost:~
代理-:proxy::~
timing::::タイミング
sleep::::スリープ
時間:time:~
一定時間:certain amount of time:~
目覚め-:wake:~
timeout::::タイムアウト
milli:::ミリ
	milli秒:millisecond
	数秒:few seconds
	秒単位
	毎分

	●構文／stream
ASCII:
ABNF:
	LF:
	CR:
	COLON
	space
	BOM
scalar::::スカラー
data::::データ
frame::::フレーム
field::::フィールド
file::::ファイル
stream::::ストリーム
buffer::::バッファ
buffering:::buffer 方式:バッファ方式
block::::ブロック
UTF-8:
Unicode:
行0:line:行
合致-:match:~
形式:format::~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
解析済み:parsed::~::パース済み
直列化:serialization::~::シリアル化
直列化-:serialize::~::シリアライズ
直列形:serialized::~::シリアル形
逆直列化-:deserialize::~::逆シリアライズ

復号-:decode::~::デコード
符号化-:encode::~::エンコード
符号化方式:encoding::~::エンコーディング
文字:character:~
文字列:string:~
	数:number:~
整数:integer:~
生成規則:production:~
	重複:duplicate:~
順序:order:~
順序付け:ordering:~
識別子:identifier:~
行0:line:~
空行:blank line:~
改行文字:newline:~
	改行
	剥ぎ取る:strip する:~
収集-:collect:~
収集:collection:~
名前:name:~
名:name:~
型:type:~
基底:base:~
基数:base:~
数字:digits:~
先行-:precede:~
後続-:follow:~
終端-:end:~
	終端-法:ending
	先頭:leading:
読取る:read する:読み取る


	●未分類（動詞
付加-:append:~
入子に:nest:入れ子に
入子の:nested:入れ子の
出自に:originate:~
分離-:separate:~
	~~分類:separate
初期:initial:~
初期化-:initialize:~
削除-:delete:~
包含-:contain:~
参照-:reference:~
反復-:iterate:~
取得-:get:~
変化-:change:~
変更-:change:~
失敗-:fail:~
失敗:failure:~
移動-:move:~
節約-:save:~
表現-:represent:~
表示-:display:~
見出され:find され:~
見出す:find する:~
設定-:set:~
追加-:add:~
追加の:additional:~
開始-:start:~
除去-:remove:~
埋込んで:embed して:埋め込んで
形成-:form:~
	伝える:tell
	~~要請:ask

	●未分類
UI:
closing:
fallback::::フォールバック
OMA:
DOM:
IDL:
JS:JavaScript
Realm:
interface::::インタフェース
凍結:frozen:~
取得子:getter:~

cookie:
clear:

	affectされない:unaffected
	落とす:drop
	form::::
game::::ゲーム
instance::::インスタンス
	instance化:instantiate#1
list::::リスト
配列:array:~
関数:function:~
member::::メンバ
memory::::メモリ
method::::メソッド
obj:object:::オブジェクト
pair::::ペア
parameter::::パラメタ
property::::プロパティ
mode::::モード

	reasonableでない:unreasonable
resize::::リサイズ
ID:
slot::::スロット
sort::::ソート
tab::::タブ
	target::::ターゲット
	time::::
	捉える:viewed as a
wildcard-keyword:wildcard keyword:::ワイルドカード
window::::
worker::::
全部的:full::~
大域:global::~::グローバル
局所:local::~::ローカル
担当の:responsible::~
設定群:settings::~
関連する:relevant な::~
閲覧文脈:browsing context::~
文書:document:~
子:child:~
要素:element:~
親:parent:~
文脈:context::~
属性:attribute:~

電力:power:~
battery::::バッテリ
carrier::::キャリア
	携帯機:mobile handset ／ mobile device ／ portable device
単独:single:~
集合:set:~
一意:unique:~
個人名:person:~
値:value:~
側:side:~
内側:inside:~
内容:content:~
単純:simple:~
	直ぐには明らかに:immediately obvious
層:layer:~
引数:argument:~
情報:information:~
新たな:new:~
有構造:structured:~
	比較的／より:relative:~
空:empty:~
	等し:equal
管理-:manage:~
管理:management:~
carrier::::キャリア
	自前の／利己:own:~
	見かけ:look:~
負の:negative:~
	返す:return:~
	除-:except:~
頁:page:::ページ

	同様
	場合
	必要
	方法
	注意
	注記
	を超えない~~範囲-:region
	あてがう:assign#1
	介:via
	新たに:newly
	起こる:happen
	通:through
	始-:begin
	対応:corresponding
	戻-:back
	入って来る:incoming
	現れるすべて:everything
	どこか:floor
	片:piece
	等々:so forth
	後で:later
	相手~側~port:twin
	note
	-:causing
	respective
	instantaneous
	leaving
	seen:
	starting
	first-class
	passing
	amount
	long
	sometime

	altogether
	part
	aforementioned
	-:fashion
	came
	pending
	形:form
	同順の maintaining their relative order


	可能
	数値
	規定
	~~回復:
	一時的に多量の:high transient
	総~data使用量:total data usage
	-:outer:~
	~~見出された~seen

	新~port~list:newPorts
	targetOrigin
	targetWindow
	targetRealm
	serialized
	finalTargetPort
	deserializeRecord
	parsedURL
	messageClone
	port1
	port2
	doomed
	transfer
	messagePort
	targetPort
	broadcastChannel
	sourceChannel
	clonedMessage
	BroadcastChannel
	MessagePort
	corsAttributeState
	eventSourceInitDict

	●指示語
	元の:original
	番目／個目:second／third
	いくつかの:several
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	それら:they／their／those／them／themselves
	一つ／もの:one
	-:whereby
	下:below:~
	両者／両:both
	-:identical
	two
	他の:other
	他の場合:otherwise
	再度／再び:again
	単独の／ 1 個の／同じ:single
	:earlier
	前:before
	次:next
	nothing
	now
	一部:part of
	前回:the previous
	一方
	一連
	両端:each end
	今度:now
	他方
	以下
	以前
	以外
	以降
	個
	以上
	個目
	全体
	初回
	前回
	前節
	各種
	唯一
	対応
	次回
	次第
	段階
	直後
	第三
	自体
	時点
	片方
	部位
	重複

</script>

<!--%link  -->

<script type="text/plain" id="_link_map">

	●IDL
Transferable:~HTMLcloning#transferable

E.DataCloneError:~WEBIDL#datacloneerror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SyntaxError:~WEBIDL#syntaxerror
I.DOMException:~WEBIDL#idl-DOMException
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Blob:~FILEAPI#blob
I.BroadcastChannel:#broadcastchannel
I.Document:~HTMLdom#document
I.Event:~DOM4#interface-event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventSource:#eventsource
I.EventSourceInit:#eventsourceinit
I.EventTarget:~DOM4#interface-eventtarget
I.File:~FILEAPI#file
I.FileList:~FILEAPI#filelist-section
I.MessageChannel:#messagechannel
I.MessageEvent:#messageevent
I.MessageEventInit:#messageeventinit
I.MessageEventSource:#messageeventsource
I.MessagePort:#messageport
I.ServiceWorker:~SW#serviceworker
I.SharedWorkerGlobalScope:~WORKERS#sharedworkerglobalscope
I.WebSocket:~WEBSOCKET#websocket
I.Window:~BROWSERS#window
	＊
I.WindowProxy:~BROWSERS#windowproxy
I.Worker:~WORKERS#worker
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.XMLHttpRequest:~XHR#xmlhttprequest
I.object:~WEBIDL#idl-object

jT.Date:~TC39#sec-date-objects

	9.2.X
m.EventSource:#dom-eventsource
m!EventSource.Constructor:#dom-eventsource
m!EventSource.close:#dom-eventsource-close
m!EventSource.withCredentials:#dom-eventsource-withcredentials
m!EventSource.CLOSED:#dom-eventsource-closed
m!EventSource.CONNECTING:#dom-eventsource-connecting
m!EventSource.OPEN:#dom-eventsource-open
m!EventSource.readyState:#dom-eventsource-readystate
m!EventSource.url:#dom-eventsource-url
m!EventSource.onmessage:#handler-eventsource-onmessage
m!EventSource.onerror:#handler-eventsource-onerror
m!EventSource.onopen:#handler-eventsource-onopen


	9.5
m!MessagePort.close:#dom-messageport-close
m!MessagePort.postMessage:#dom-messageport-postmessage
m!MessagePort.start:#dom-messageport-start
m!MessagePort.onmessage:#handler-messageport-onmessage
m!MessagePort.onmessageerror:#handler-messageport-onmessageerror


	9.6
m.BroadcastChannel:#dom-broadcastchannel
m!BroadcastChannel.Constructor:#dom-broadcastchannel
m!BroadcastChannel.postMessage:#dom-broadcastchannel-postmessage
m!BroadcastChannel.name:#dom-broadcastchannel-name
m!BroadcastChannel.close:#dom-broadcastchannel-close
m!BroadcastChannel.onmessage:#handler-broadcastchannel-onmessage
m!BroadcastChannel.onmessageerror:#handler-broadcastchannel-onmessageerror

	9.5.2
	m.Constructor:#dom-messagechannel
m.MessageChannel:#dom-messagechannel
m.port1:#dom-messagechannel-port1
m.port2:#dom-messagechannel-port2



m.postMessage:#dom-window-postmessage
m.window.postMessage:#dom-window-postmessage
m.withCredentials:#dom-eventsourceinit-withcredentials

m.initMessageEvent:#dom-messageevent-initmessageevent
m.lastEventId:#dom-messageevent-lasteventid
m.origin:#dom-messageevent-origin
m.ports:#dom-messageevent-ports
m.source:#dom-messageevent-source
m.data:#dom-messageevent-data

m.addEventListener:~DOM4#dom-eventtarget-addeventlistener
~closing~flag:~WORKERS#dom-workerglobalscope-closing
m.initEvent:~DOM4#dom-event-initevent
m.type:~DOM4#dom-event-type
	＊
m.window.stop:browsers.html#dom-window-stop

bl.text/event-stream:~HTML5/iana.html#text/event-stream
c.text/event-stream:~HTML5/iana.html#text/event-stream
e.iframe:~HEembed#the-iframe-element
et.connect:~HTMLindex#event-workerglobalscope-connect
et.error:~HTMLindex#event-error
et.hashchange:~HTMLindex#event-hashchange
et.message:~HTMLindex#event-message
et.messageerror:~HTMLindex#event-messageerror
et.open:~HTMLindex#event-open
et.resize:~CSSOMVIEW#eventdef-window-resize

h.Last-Event-ID:~HTML5/iana.html#last-event-id
h.Accept:~RFC7231#section-5.3.2
h.Content-Type:~HTMLINFRA#content-type


P.lf:#_p.line-feed
P.cr:#_p.carriage-return
P.bom:#_p.byte-order-mark

	●

~BroadcastChannel設定群~obj:#broadcastchannel-settings-object
~broadcast~channel:#broadcasting-to-other-browsing-contexts
~channel~messaging:#channel-messaging
~channel名:#channel-name
~close済み~flag:#concept-broadcastchannel-closed
文書間~messaging:#web-messaging
~eventを配送-:#dispatchMessage
強制的に~closeする:#concept-eventsource-forcibly-close
~fieldを処理する:#processField

eS.~url:#concept-eventsource-url
eS.再接続~時間:#concept-event-stream-reconnection-time
eS.最後の~event~ID文字列:#concept-event-stream-last-event-id
eS.要請:#concept-event-stream-request

~port~message待行列:#port-message-queue
未搬送の~port~message待行列:#unshipped-port-message-queue
投函済み~message~task源:#posted-message-task-source
~remote~event~task源:#remote-event-task-source
~server-sent~event:#server-sent-events
搬送済み~flag:#has-been-shipped
所有者:#concept-port-owner
無接続~push:#eventsource-push
接続を公告-:#announce-the-connection
接続を再確立-:#reestablish-the-connection
接続を失敗させ:#fail-the-connection
新たな~MessagePort~objを作成-:#create-a-new-messageport-object
連絡-:#entangle


	as described below:#event-stream-interpretation
	~web-socket:#network
	ある~privacy上の含意がある:introduction.html#fingerprint-postMessage

~ASCII数字:~INFRA#ascii-digit
~scalar値:~INFRA#scalar-value

st.Anonymous:~HTMLINFRA#attr-crossorigin-anonymous
st.Use Credentials:~HTMLINFRA#attr-crossorigin-use-credentials
	case-sensitive:~HTMLINFRA#case-sensitive

jA.StructuredSerialize:~HTMLcloning#structuredserialize
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
jA.StructuredSerializeWithTransfer:~HTMLcloning#structuredserializewithtransfer
jA.StructuredDeserializeWithTransfer:~HTMLcloning#structureddeserializewithtransfer
転送可能~obj:~HTMLcloning#transferable-objects
転送-手続き:~HTMLcloning#transfer-steps
転送-受信-時の手続き:~HTMLcloning#transfer-receiving-steps


並列的:~HTMLINFRA#in-parallel
~CORSになり得る要請を作成-:~HTMLINFRA#create-a-potential-cors-request
適用し得る仕様:~HTMLconform#other-applicable-specifications
enV.大域~obj:~WAPI#concept-settings-object-global
enV.生成元:~WAPI#concept-settings-object-origin
~API基底~URL:~WAPI#api-base-url
~API~URL文字~符号化方式:~WAPI#api-url-character-encoding
~Realm:~WAPI#concept-global-object-realm
現任の設定群~obj:~WAPI#incumbent-settings-object

~event-loop:~WAPI#event-loop
閲覧文脈~event-loop:~WAPI#_browsing-context-event-loop
~event~handler:~WAPI#event-handlers
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~task:~WAPI#concept-task
~network用~task源:~WAPI#networking-task-source
~taskを待入する:~WAPI#queue-a-task
~taskを待入し:~WAPI#queue-a-task
待入され:~WAPI#queue-a-task
~task待行列:~WAPI#task-queue
~task源:~WAPI#task-source
~DOM操作~task源:~WAPI#dom-manipulation-task-source
担当の~event-loop:~WAPI#responsible-event-loop
担当の文書:~WAPI#responsible-document
環境~設定群~obj:~WAPI#environment-settings-object
設定群~obj:~WAPI#settings-object
関連する~Realm:~WAPI#concept-relevant-realm
関連する設定群~obj:~WAPI#relevant-settings-object




	same:~BROWSERS#same-origin
~Unicode直列化:~BROWSERS#unicode-serialisation-of-an-origin
全部的に作動中:~BROWSERS#fully-active
同一生成元:~BROWSERS#same-origin
生成元:~BROWSERS#concept-origin
結付けられている文書:~BROWSERS#concept-document-window
閲覧文脈:~BROWSERS#browsing-context


~navigate:~NAVI#navigate
休止可能:~WORKERS#suspendable-worker
~worker:~WORKERS#worker
共用~worker:~WORKERS#sharedworker
共用~worker内:~WORKERS#sharedworkerglobalscope

凍結~配列:~WEBIDL#dfn-frozen-array-type


~MIME型:~MIMESNIFF#mime-type

~eventを作成-:~DOM4#concept-event-create
~eventを発火-:~DOM4#concept-event-fire
配送-:~DOM4#concept-event-dispatch

rq.~cache~mode:~FETCH#concept-request-cache-mode
rq.~client:~FETCH#concept-request-client
rq.~header~list:~FETCH#concept-request-header-list
hL.設定-:~FETCH#concept-header-list-set
~fetch:~FETCH#concept-fetch
要請:~FETCH#concept-request

url.生成元:~URLSpec#concept-url-origin
url.素片:~URLSpec#concept-url-fragment
~URL:~URLSpec#concept-url
~URL~record:~URLSpec#concept-url
~URL直列化器:~URLSpec#concept-url-serializer
~URL構文解析器:~URLSpec#concept-url-parser

~UTF-8復号-:~ENCODING#utf-8-decode


</script>

<!--%style -->
<style type="text/css">
.js-slot, .js-type {
	color: green;
}



</style>

</head>
<body>



<div style="display:none;">
	<input type="hidden" id="_page_config" value="" />

</div>

<aside class="trans-meta">
<h1>HTML — Communication 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における HTML 仕様の一部である
<a id="_SPEC_URL">Communication</a>
章を日本語に翻訳したものです。
<strong>この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語訳は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新： <time>2017-04-27</time>
（公開：<time>2016-12-06</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header id="head">
	<hgroup>
<h1>通信 — Communication</h1>
<h2>HTML Living Standard — 最終更新 2017 年 4 月 26 日</h2>
	</hgroup>
</header>

<main id="MAIN" style="display:none;">

	<section id="comms">
<h1 title="Communication">9 通信</h1>

		<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="the-messageevent-interfaces">
<h2 title="The MessageEvent interfaces">9.1. `MessageEvent$I ~interface</h2>

  
<p>
`~server-sent~event$における~message,
<a href="#network">~web-socket</a>,
`文書間~messaging$,
`~channel~messaging$,
`~broadcast~channel$
では、各 `message$et ~eventに `MessageEvent$I ~interfaceを利用する：
◎
Messages in server-sent events, Web sockets, cross-document messaging, channel messaging, and broadcast channels use the MessageEvent interface for their message events:
</p>


<pre class="idl">
[Constructor(DOMString type, optional `MessageEventInit$I eventInitDict), Exposed=(Window,Worker)]
interface `MessageEvent@I : `Event$I {
  readonly attribute any `data$m;
  readonly attribute USVString `origin$m;
  readonly attribute DOMString `lastEventId$m;
  readonly attribute `MessageEventSource$I? `source$m;
  readonly attribute FrozenArray&lt;`MessagePort$I&gt; `ports$m;

 void `initMessageEvent$m(DOMString %type, optional boolean %bubbles = false, optional boolean %cancelable = false, optional any %data = null, optional USVString %origin = "", optional DOMString %lastEventId = "", optional `MessageEventSource$I? %source = null, optional sequence&lt;`MessagePort$I&gt; %ports = []);
};

dictionary `MessageEventInit@I : `EventInit$I {
  any data = null;
  USVString origin = "";
  DOMString lastEventId = "";
  `MessageEventSource$I? source = null;
  sequence&lt;`MessagePort$I&gt; ports = [];
};

typedef (`WindowProxy$I or `MessagePort$I or `ServiceWorker$I) `MessageEventSource@I;
</pre>

<dl class="domintro">

	<dt>%event . `data$m</dt>
	<dd>
~messageの~dataを返す。
◎
Returns the data of the message.
</dd>

	<dt>%event . `origin$m</dt>
	<dd>
［
`~server-sent~event$ ／
`文書間~messaging$
］の下では、~messageの生成元を返す。
◎
Returns the origin of the message, for server-sent events and cross-document messaging.
</dd>

	<dt>%event . `lastEventId$m</dt>
	<dd>
`~server-sent~event$の下では、`最後の~event~ID文字列$eSを返す。
◎
Returns the last event ID string, for server-sent events.
</dd>

	<dt>%event . `source$m</dt>
	<dd>
`文書間~messaging$の下では、~source~window
`送信-元~window^tnote
の `WindowProxy$I を返す。
`SharedWorkerGlobalScope$I ~objに向けて発火された `connect$et ~eventにおいては、添付されている `MessagePort$Iを返す。
◎
Returns the WindowProxy of the source window, for cross-document messaging, and the MessagePort being attached, in the connect event fired at SharedWorkerGlobalScope objects.
</dd>

	<dt>%event . `ports$m</dt>
	<dd>
［
`文書間~messaging$ ／ `~channel~messaging$
］の下では、~messageに伴われて送信された `MessagePort$I 配列を返す。
◎
Returns the MessagePort array sent with the message, for cross-document messaging and channel messaging.
</dd>

</dl>


<dl class="idl-def">
	<dt>`data@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
送信されてきた~messageを表現する。
◎
The data attribute must return the value it was initialized to. It represents the message being sent.
</dd>

	<dt>`origin@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
これは、［
`~server-sent~event$ ／
`文書間~messaging$
］の下では、~messageを送信した文書の`生成元$を表現する（概して 当の文書の［
~scheme, ~hostname, ~port
］からなるなるが、その［
~path／`素片$url
］は含まない
)。
◎
The origin attribute must return the value it was initialized to. It represents, in server-sent events and cross-document messaging, the origin of the document that sent the message (typically the scheme, hostname, and port of the document, but not its path or fragment).
</dd>

	<dt>`lastEventId@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
これは、`~server-sent~event$の下では、
`EventSource$I ~objの`最後の~event~ID文字列$eSを表現する。
◎
The lastEventId attribute must return the value it was initialized to. It represents, in server-sent events, the last event ID string of the event source.
</dd>

	<dt>`source@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
これは、`文書間~messaging$の下では、~messageを送ってきた
`Window$I ~objの`閲覧文脈$の `WindowProxy$I を表現する。
`共用~worker内$で利用される `connect$et ~eventにおいては、新たに接続している `MessagePort$I になる。
◎
The source attribute must return the value it was initialized to. It represents, in cross-document messaging, the WindowProxy of the browsing context of the Window object from which the message came; and in the connect events used by shared workers, the newly connecting MessagePort.
</dd>

	<dt>`ports@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
これは、［
`文書間~messaging$ ／ `~channel~messaging$
］の下では、~messageに伴って送信される `MessagePort$I 配列を表現する。
◎
The ports attribute must return the value it was initialized to. It represents, in cross-document messaging and channel messaging, the MessagePort array being sent.
</dd>

	<dt>`initMessageEvent()@m</dt>
	<dd>
被呼出時には、似た命名の `initEvent()$m ~methodに相似的な方式で~eventを初期化し~MUST。
`DOM$r
◎
The initMessageEvent() method must initialize the event in a manner analogous to the similarly-named initEvent() method. [DOM]
</dd>
</dl>

<p class="note">注記：
種々の~API（例： `WebSocket$I や `EventSource$I ）は、
`MessagePort$I ~APIを利用せずに，
`MessageEvent$I ~interfaceを `message$et ~eventに利用する。
◎
Various APIs (e.g., WebSocket, EventSource) use the MessageEvent interface for their message event without using the MessagePort API.
</p>


		</section>
		<section id="server-sent-events">
<h2 title="Server-sent events">9.2. ~server-sent~event</h2>


			<section id="server-sent-events-intro">
<h3 title="Introduction">9.2.1. 序論</h3>

~INFORMATIVE

<p>
~serverが~Web頁に向けて，~HTTPを通じて, あるいは
専用の［
“server-push” ~protocol
］を利用して
~dataを~pushできるようにするため、この仕様は
`EventSource$I ~interfaceを導入する。
◎
To enable servers to push data to Web pages over HTTP or using dedicated server-push protocols, this specification introduces the EventSource interface.
</p>

<p>
この~APIの用法は、 `EventSource$I ~objを作成して，~event~listenerを登録するだけである。
◎
Using this API consists of creating an EventSource object and registering an event listener.
</p>

<pre class="js-code">
var %source = new EventSource('updates.cgi');
%source.onmessage = function (%event) {
  alert(%event.data);
};
</pre>

<p>
~server側の~script（この事例では `updates.cgi^l ）は、~MIME型に `text/event-stream$c を伴う~messageを，次の形で送信する：
◎
On the server-side, the script ("updates.cgi" in this case) sends messages in the following form, with the text/event-stream MIME type:
</p>

<pre>
data: 第一~message

data: 第二~message
data: この~messageは 2 行0からなる

data: 第三~message
</pre>
<!-- 
data: This is the first message.

data: This is the second message, it
data: has two lines.

data: This is the third message.
 -->

<p class="trans-note">【
各~messageは、空行（言い換えれば，連続する 2 個以上の改行（ `end-of-line$P ））で終端する。
】【
このページの各~stream例は、特に断らない限り，暗黙的に空行で終端されている。
】</p>

<hr>

<p>
作者は、異なる~event型を利用することにより，各~eventを~~分類できる。
ここに  2 種の~event型,  `add^l, `remove^l が含まれた~streamがあるとする：
◎
Authors can separate events by using different event types. Here is a stream that has two event types, "add" and "remove":
</p>

<pre>
event: add
data: 73857293

event: remove
data: 2153

event: add
data: 113411
</pre>

<p>
そのような~streamを取扱う~scriptは、次の様になるであろう（
%addHandler, %removeHandler
は、 1 個の~event引数をとる関数とする）：
◎
The script to handle such a stream would look like this (where addHandler and removeHandler are functions that take one argument, the event):
</p>

<pre class="js-code">
var %source = new EventSource('updates.cgi');
source.addEventListener('add', %addHandler, false);
source.addEventListener('remove', %removeHandler, false);
</pre>

<p>
既定の~event型は `message^l である。
`すなわち、最初の例のように "event:" 行0が省略されている場合^tnote
◎
The default event type is "message".
</p>

<p>
~event~streamは、常に~UTF-8として復号される。
別の文字~符号化方式を指定する仕方はない。
◎
Event streams are always decoded as UTF-8. There is no way to specify another character encoding.
</p>

<hr>

<p>
~event~stream要請は、通常の~HTTP要請と同様に，~HTTP `301^st／ `307^st 応答~codeにより~redirectされ得る（できる）。
接続が~closeされた場合、~clientは 再接続することになる。
~serverは、~HTTP `204^st  "No Content" 応答~codeを用いて，~clientにこの再接続を停止するよう伝えれる。
◎
Event stream requests can be redirected using HTTP 301 and 307 redirects as with normal HTTP requests. Clients will reconnect if the connection is closed; a client can be told to stop reconnecting using the HTTP 204 No Content response code.
</p>

<p>
この~APIを用いれば
— `XMLHttpRequest$I や `iframe$e を用いてそれを模倣せずに —
~UAは、~UAの実装者と~network運用者が より高度に協調できる事例においては，~network資源をより良く利用できるようになる。
これには、携帯機の~battery~~寿命を有意に節約できる便益もある
— それについては、`無接続~push$節にて更に論じられる。
◎
Using this API rather than emulating it using XMLHttpRequest or an iframe allows the user agent to make better use of network resources in cases where the user agent implementor and the network operator are able to coordinate in advance. Amongst other benefits, this can result in significant savings in battery life on portable devices. This is discussed further in the section below on connectionless push.
</p>


			</section>
			<section id="the-eventsource-interface">
<h3 title="The EventSource interface">9.2.2. ``EventSource^I ~interface</h3>

<pre class="idl">
[``Constructor$m(USVString %url, optional `EventSourceInit$I %eventSourceInitDict), Exposed=(Window,Worker)]
interface `EventSource@I : `EventTarget$I {
  readonly attribute USVString ``url$m;
  readonly attribute boolean ``withCredentials$m;

  // ready state
  const unsigned short ``CONNECTING$m = 0;
  const unsigned short ``OPEN$m = 1;
  const unsigned short ``CLOSED$m = 2;
  readonly attribute unsigned short ``readyState$m;

  // networking
  attribute `EventHandler$I ``onopen$m;
  attribute `EventHandler$I ``onmessage$m;
  attribute `EventHandler$I ``onerror$m;
  void ``close$m();
};

dictionary `EventSourceInit@I {
  boolean `withCredentials@m = false;
};
</pre>

<p>
各 `EventSource$I ~objには、次のものが結付けられる：
◎
Each EventSource object has the following associated with it:
</p>

<dl class="def-list">
	<dt>`~url@eS</dt>
	<dd>
`~URL~record$。
構築-時に設定される。
◎
A url (a URL record). Set during construction.
</dd>

	<dt>`要請@eS</dt>
	<dd>
初期~時には ~NULL にされ~MUST。
◎
A request. This must initially be null.
</dd>
	<dd class="trans-note">【
これもまた、構築-時に`要請$に設定される。
】</dd>

	<dt>`再接続~時間@eS</dt>
	<dd>
~milli秒単位。
初期~時には ~UAにより定義される値
— おそらく，数秒を超えない~~範囲 —
にされ~MUST。
◎
A reconnection time, in milliseconds. This must initially be a user-agent-defined value, probably in the region of a few seconds.
</dd>

	<dt>`最後の~event~ID文字列@eS</dt>
	<dd>
初期~時には空~文字列にされ~MUST。
◎
A last event ID string. This must initially be the empty string.
</dd>

</dl>

<p>
`~url$eS を除き，これらは、現時点では `EventSource$I ~objに公開されていない。
◎
Apart from url these are not currently exposed on the EventSource object.
</p>


<dl class="idl-def">
	<dt>`EventSource(url, eventSourceInitDict)@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
The EventSource(url, eventSourceInitDict) constructor, when invoked, must run these steps:
</p>

		<ol>
			<li>
%event ~LET 新たな `EventSource$I ~obj
◎
Let ev be a new EventSource object.
</li>
			<li>
%設定群 ~LET %event に`関連する設定群~obj$
◎
Let settings be ev's relevant settings object.
</li>
			<li>
%~url~record ~LET 次を与える下で，
%~url を`~URL構文解析器$にかけた結果
⇒
( %設定群 の`~API基底~URL$, %設定群 の`~API~URL文字~符号化方式$ )
◎
Let urlRecord be the result of parsing url with settings's API base URL and settings's API URL character encoding.
</li>
			<li>
~IF［
%~url~record ~EQ 失敗
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord is failure, then throw a "SyntaxError" DOMException.
</li>
			<li>
%event の`~url$eS ~SET %~url~record
◎
Set ev's url to urlRecord.
</li>
			<li>
%~CORS属性~状態 ~LET `Anonymous$st
◎
Let corsAttributeState be Anonymous.
</li>
			<li>
~IF［
%evententSourceInitDict の `withCredentials$m ~memberの値 ~EQ ~T
］
⇒
%~CORS属性~状態 ~SET `Use Credentials$st；<br>
%event の ``withCredentials$m 属性  ~SET ~T
◎
If the value of eventSourceInitDict's withCredentials member is true, then set corsAttributeState to Use Credentials and set ev's withCredentials attribute to true.
</li>
			<li>
%要請 ~LET 
次を与える下で，`~CORSになり得る要請を作成-$した結果
⇒
( %~url~record, 空~文字列, %~CORS属性~状態, `同一生成元~fallback~flag^i ~ON )
◎
Let request be the result of creating a potential-CORS request given urlRecord, the empty string, and corsAttributeState, and with the same-origin fallback flag set.
</li>
			<li>
%要請 の`~client$rq ~SET %設定群
◎
Set request's client to settings.
</li>
			<li>
~UAの任意選択で
⇒
%要請 の`~header~list$rq内で
( `Accept$h / `text/event-stream$bl )
を`設定-$hLする
◎
User agents may set `Accept`/`text/event-stream` in request's header list.
</li>
			<li>
%要請 の`~cache~mode$rq ~SET `no-store^l
◎
Set request's cache mode to "no-store".
</li>
			<li>
%event の`要請$eS ~SET %要請
◎
Set ev's request to request.
</li>
			<li>
~RET %event
— ただし、以降の手続きは`並列的$に継続する
◎
Return ev, but continue these steps in parallel.
</li>
			<li>
%要請 を`~fetch$する
◎
Fetch request.
</li>
		</ol>
	</dd>

	<dt>``url@m</dt>
	<dd>
取得子は、此れの`~url$eSを`~URL直列化器$にかけた結果を返さ~MUST。
◎
The url attribute's getter must return the serialization of this EventSource object's url.
</dd>

	<dt>``withCredentials@m</dt>
	<dd>
取得子は、最後に初期化された値を返さ~MUST。
此れの作成-時には、 ~F に初期化され~MUST。
◎
The withCredentials attribute must return the value to which it was last initialized. When the object is created, it must be initialized to false.
</dd>

	<dt>``readyState@m</dt>
	<dd>
<p>
この属性は、当の接続の状態を表現する。
次のいずれかの値をとり得る：
◎
The readyState attribute represents the state of the connection. It can have the following values:
</p>

		<dl>
			<dt>``CONNECTING@m （数値 0 ）</dt>
			<dd>
接続は、まだ確立されていないか，または
~closeされていて~UAは再接続している。
◎
The connection has not yet been established, or it was closed and the user agent is reconnecting.
</dd>

			<dt>``OPEN@m  （数値 1 ）</dt>
			<dd>
~UAは，~open接続を有していて、~eventが受信され次第 それを配送している。
◎
The user agent has an open connection and is dispatching events as it receives them.
</dd>

			<dt>``CLOSED@m  （数値 2 ）</dt>
			<dd>
接続は~openしておらず，~UAは再接続しようと試行していない。
何らかの致命的~errorがあったか， ``close()$m ~methodが呼出された。
◎
The connection is not open, and the user agent is not trying to reconnect. Either there was a fatal error or the close() method was invoked.
</dd>
		</dl>
	</dd>
	<dd>
此れの作成-時には、その ``readyState$m は ``CONNECTING$m （ 0 ）に設定され~MUST。
値がいつ変化するかは、下に与える，接続を取扱うための規則にて定義される。
◎
When the object is created its readyState must be set to CONNECTING (0). The rules given below for handling the connection define when the value changes.
</dd>

	<dt>``close()@m</dt>
	<dd>
被呼出時には、此れのために開始された`~fetch$ ~algoがあれば すべて中止した上で、
此れの ``readyState$m 属性を ``CLOSED$m に設定し~MUST。
◎
The close() method must abort any instances of the fetch algorithm started for this EventSource object, and must set the readyState attribute to CLOSED.
</dd>
</dl>

<p>
`EventSource$I ~interfaceを実装している~すべての~objは、以下に挙げる各種`~event~handler$, および対応する各種`~event~handler~event型$を，`~event~handler~IDL属性$として~supportし~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the EventSource interface:
</p>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>``onopen@m
<td>`open$et
<tr><td>``onmessage@m
<td>`message$et
<tr><td>``onerror@m
<td>`error$et

</tbody></table>


			</section>
			<section id="sse-processing-model">
<h3 title="Processing model">9.2.3. 処理~model</h3>

<span id="processing-model-9"></span>
<p>
`EventSource()$m 構築子の引数にて指示される資源は、その構築子が走るときに~fetchされる。
◎
The resource indicated in the argument to the EventSource constructor is fetched when the constructor is run.
</p>

<p>
~dataが受信されるに伴い，それを取扱うために `~network用~task源$により待入される`~task$は、以下に従って動作し~MUST：
◎
As data is received, the tasks queued by the networking task source to handle the data must act as follows.
</p>

<p>
~HTTP `200^st "OK" 応答に対しては、
`Content-Type$h ~header値は 型 `text/event-stream$bl を指定している
— `~MIME型$ ~parameterは無視して —
ならば，
<a href="#event-stream-interpretation">~event~streamの解釈-法</a>
に従って 行0ごとに処理され~MUST。
◎
HTTP 200 OK responses with a `Content-Type` header specifying the type `text/event-stream`, ignoring any MIME type parameters, must be processed line by line as described below.
</p>

<p>
~UAは、自身が~supportする`~MIME型$を伴う応答が成功裡に受信されたときは、~streamの内容を構文解析し始めるときに，`接続を公告-$し~MUST。
◎
When a successful response with a supported MIME type is received, such that the user agent begins parsing the contents of the stream, the user agent must announce the connection.
</p>

<p>
`~network用~task源$から`~task待行列$に設置した`~task$が，そのような（正しい`~MIME型$を伴う）資源に対する~fetchingを完了したなら、~UAは，`並列的$に`接続を再確立-$し~MUST。
これは、接続が上品に~closeされようが 予期せず~closeされようが，適用される（が、~UAが ~fetchingを取消したとき（例えば `window.stop()$m に呼応して）には適用されない
— そのような事例では `~task$は最終的に実際に破棄されるので）。
ただし、下に挙げる~error条態に対しては、明示的に指定されない限り，適用されない。
◎
The task that the networking task source places on the task queue once fetching for such a resource (with the correct MIME type) has completed must cause the user agent to reestablish the connection in parallel. This applies whether the connection is closed gracefully or unexpectedly (but does not apply when fetching is canceled by the user agent, e.g., in response to window.stop(), since in those cases the final task is actually discarded). It doesn't apply for the error conditions listed below except where explicitly specified.
</p>

<p>
~HTTP `200^st "OK" 応答に対しては、応答の `Content-Type$h が［
伴われていない ／ 未~supportの型を指定している
］場合、~UAは`接続を失敗させ$~MUST。
◎
HTTP 200 OK responses that have a Content-Type specifying an unsupported type, or that have no Content-Type at all, must cause the user agent to fail the connection.
</p> 

<p id="event-source-network-errors-reconnect">
最初の~~段階で接続を確立できなくするような，~network~error（例： ~DNS~error）に対しては、~UAは`並列的$に`接続を再確立-$するべきである
— ただし，~UAは、そうしても無益なことを知っている場合は，`接続を失敗させ$てよい。
◎
Network errors that prevents the connection from being established in the first place (e.g. DNS errors), should cause the user agent to reestablish the connection in parallel, unless the user agent knows that to be futile, in which case the user agent may fail the connection.
</p>

<p id="event-source-fail-reasons">
ここに挙げなかった他の~HTTP応答~codeに対しては, および
~UAが~fetch~algoを取消した場合は（例えば `window.stop()$m に呼応して, あるいは 利用者が~network接続を手動で取消した）、~UAは`接続を失敗させ$~MUST。
◎
Any other HTTP response code not listed here, as well as the cancelation of the fetch algorithm by the user agent (e.g. in response to window.stop() or the user canceling the network connection manually) must cause the user agent to fail the connection.
</p>

<hr>

<div class="p">
<p class="algo-head">
~UAは，
`接続を公告-@
するときは、次を走らす`~taskを待入し$~MUST：
</p>

<ol>
	<li>
%O ~LET 当の `EventSource$I ~obj
</li>
	<li>
~IF［
%O の ``readyState$m 属性~値 ~EQ ``CLOSED$m
］
⇒
~RET
</li>
	<li>
%O の ``readyState$m 属性 ~SET ``OPEN$m
</li>
	<li>
%O に向けて，名前 `open$et の`~eventを発火-$する
</li>
</ol>

◎
When a user agent is to announce the connection, the user agent must queue a task which, if the readyState attribute is set to a value other than CLOSED, sets the readyState attribute to OPEN and fires an event named open at the EventSource object.
</div>

<p class="algo-head">
~UAは、
`接続を再確立-@
するときは、次の手続きを走らせ~MUST：
◎
When a user agent is to reestablish the connection, the user agent must run the following steps. These steps are run in parallel, not as part of a task. (The tasks that it queues, of course, are run like normal tasks and not themselves in parallel.)
</p>


<ol>
	<li>
~RET
— ただし、以降の手続きは`並列的$に継続する
◎
↑</li>
	<li>
%O ~LET 当の `EventSource$I ~obj
◎
↓</li>
	<li>
<p>
次の手続きを走らす`~taskを待入する$：
◎
Queue a task to run the following steps:
</p>
		<ol>
			<li>
~IF［
%O の ``readyState$m 属性 ~NEQ ``CLOSED$m
］
⇒
~RET
◎
If the readyState attribute is set to CLOSED, abort the task.
</li>
			<li>
%O の ``readyState$m 属性 ~SET ``CONNECTING$m
◎
Set the readyState attribute to CONNECTING.
</li>
			<li>
%O に向けて，名前 `error$et の`~eventを発火-$する
◎
Fire an event named error at the EventSource object.
</li>
		</ol>
	</li>
	<li>
%O の`再接続~時間$eSだけ待機する
◎
Wait a delay equal to the reconnection time of the event source.
</li>
	<li>
~UAの任意選択で
⇒
更にいくばくか待機する。
特に、前回の試みが失敗した場合，~serverはすでに過負荷にあるかもしれないので、~UAは ベキ乗打ち切り待機法（ exponential backoff ）による遅延を導入することもできる。
あるいは，~OSから~network接続できないと報告された場合には、~OSから その~~回復が公告されるまで待機する。
◎
Optionally, wait some more. In particular, if the previous attempt failed, then user agents might introduce an exponential backoff delay to avoid overloading a potentially already overloaded server. Alternatively, if the operating system has reported that there is no network connectivity, user agents might wait for the operating system to announce that the network connection has returned before retrying.
</li>
			<li>
上で待入した~taskがまだ走っていないならば，走るまで待機する
<!-- 走り終える？ -->
◎
Wait until the aforementioned task has run, if it has not yet run.
</li>
			<li>
<p>
次の手続きを走らす`~taskを待入する$：
◎
Queue a task to run the following steps:
</p>
				<ol>
					<li>
~IF［
%O の ``readyState$m 属性 ~NEQ ``CONNECTING$m
］
⇒
~RET
◎
If the EventSource object's readyState attribute is not set to CONNECTING, abort these steps.
</li>
			<li>
%要請 ~LET %O の`要請$eS
◎
Let request be the EventSource object's request.
</li>
			<li>
~IF［
%O の`最後の~event~ID文字列$eS ~NEQ 空~文字列
］
⇒
%要請 の`~header~list$rq内で
( `Last-Event-ID$h / `最後の~event~ID文字列$eS
を~UTF-8に符号化した結果
) を`設定-$hLする
◎
If the EventSource object's last event ID string is not the empty string, set `Last-Event-ID`/last event ID string, encoded as UTF-8, in request's header list.
</li>
			<li>
%要請 を`~fetch$する
⇒
この~fetchに対する応答は、この節の最初あたりで述べたように処理する
◎
Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.
</li>
		</ol>
	</li>
</ol>


<div class="p">
<p class="algo-head">
~UAは，
`接続を失敗させ@
るときは、次を走らす`~taskを待入し$~MUST：
</p>

<ol>
	<li>
%O ~LET 当の `EventSource$I ~obj
◎
↓</li>
	<li>
~IF［
%O の ``readyState$m 属性 ~EQ ``CLOSED$m
］
⇒
~RET
</li>
	<li>
%O の ``readyState$m 属性 ~SET ``CLOSED$m
</li>
	<li>
%O に向けて，名前 `error$et の`~eventを発火-$する
</li>
</ol>

<p>
<strong>
~UAは、`接続を失敗させ$たときは，再接続しようと <em>試みないこと</em>。
</strong>
</p>
◎
When a user agent is to fail the connection, the user agent must queue a task which, if the readyState attribute is set to a value other than CLOSED, sets the readyState attribute to CLOSED and fires an event named error at the EventSource object. Once the user agent has failed the connection, it does not attempt to reconnect!
</div>

<hr>

<p>
`EventSource$I ~objにより`待入され$るどの`~task$に対しても，その`~task源$は
`~remote~event~task源@
とする。
◎
The task source for any tasks that are queued by EventSource objects is the remote event task source.
</p>


			</section>
			<section id="parsing-an-event-stream">
<h3 title="Parsing an event stream">9.2.4. ~event~streamの構文解析</h3>

<p>
この~event~stream形式の`~MIME型$は、
`text/event-stream$c
である。
◎
This event stream format's MIME type is text/event-stream.
</p>

<p>
~event~stream形式は、次の `ABNF$r における `stream$P 生成規則で与えられる
— この~ABNFの文字~集合は~Unicodeとする：
◎
The event stream format is as described by the stream production of the following ABNF, the character set for which is Unicode. [ABNF]
</p>

<pre class="ABNF">
`stream@P        = [ `bom$P ] *`event$P
`event@P         = *( `comment$P / `field$P ) `end-of-line$P
`comment@P       = `colon$P *`any-char$P `end-of-line$P
`field@P         = 1*`name-char$P [ `colon$P [ `space$P ] *`any-char$P ] `end-of-line$P
`end-of-line@P   = ( `cr$P `lf$P / `cr$P / `lf$P )

; <span class="comment">各種~文字</span>
`lf@P            = `000A^0x ; U+000A LINE FEED (LF)
`cr@P            = `000D^0x ; U+000D CARRIAGE RETURN (CR)
`space@P         = `0020^0x ; U+0020 SPACE
`colon@P         = `003A^0x ; U+003A COLON (:)
`bom@P           = `FEFF^0x ; U+FEFF BYTE ORDER MARK
`name-char@P     = `0000-0009^0x / `000B-000C^0x / `000E-0039^0x / `003B-10FFFF^0x
                ; <span class="comment">
`lf$P, `cr$P, `colon$P 以外の`~scalar値$
◎
; a scalar value other than U+000A LINE FEED (LF), U+000D CARRIAGE RETURN (CR), or U+003A COLON (:)
</span>
`any-char@P      = `0000-0009^0x / `000B-000C^0x / `000E-10FFFF^0x
                ; <span class="comment">
`lf$P, `cr$P 以外の`~scalar値$
◎
; a scalar value other than U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR)
</span>
</pre>


<p>
この形式による~event~streamは、常に ~UTF-8に符号化され~MUST。
`ENCODING$r
◎
Event streams in this format must always be encoded as UTF-8. [ENCODING]
</p>

<p>
各 行0どうしは、 `end-of-line$P（
`cr$P +`lf$P, `lf$P, `cr$P
のいずれか）で分離され~MUST。
◎
Lines must be separated by either a U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair, a single U+000A LINE FEED (LF) character, or a single U+000D CARRIAGE RETURN (CR) character.
</p>

<p>
そのような資源のために確立された~remote~serverへの接続は，長く生き残るものと予期されるので、~UAは
適切な~bufferingが利用されることを確保するべきである。
特に，各 行0が 1 個の `lf$P で終端するように定義される~bufferingは安全である一方で、~block~bufferingや, 異なる行0終端-法を期待する行0~bufferingは，~event配送-を遅延させ得る。
◎
Since connections established to remote servers for such resources are expected to be long-lived, UAs should ensure that appropriate buffering is used. In particular, while line buffering with lines are defined to end with a single U+000A LINE FEED (LF) character is safe, block buffering or line buffering with different expected line endings can cause delays in event dispatch.
</p>




			</section>
			<section id="event-stream-interpretation">
<h3 title="Interpreting an event stream">9.2.5. ~event~streamの解釈-法</h3>

<p>
~streamは、`~UTF-8復号-$~algoで復号され~MUST。
◎
Streams must be decoded using the UTF-8 decode algorithm.
</p>

<p class="note">注記：
`~UTF-8復号-$~algoは、先頭に~UTF-8 Byte Order Mark （ `bom$P ）があれば それを剥ぎ取る。
◎
The UTF-8 decode algorithm strips one leading UTF-8 Byte Order Mark (BOM), if any.
</p>

<div class="p">
<p>
~streamは、行0ごとに そこに現れるすべてを読取ることにより，構文解析され~MUST。
行0が終端するのは、次のいずれか（ “改行” ）が現れる所に限られるとする：
</p>

<ul ><li>`cr$P + `lf$P 文字~pair
</li><li>`cr$P が先行しない 1 個の `lf$P
</li><li>`lf$P が後続しない 1 個の `cr$P
</li></ul>

`改行~自身は行0には含まれない。^tnote

◎
The stream must then be parsed by reading everything line by line, with a U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair, a single U+000A LINE FEED (LF) character not preceded by a U+000D CARRIAGE RETURN (CR) character, and a single U+000D CARRIAGE RETURN (CR) character not followed by a U+000A LINE FEED (LF) character being the ways in which a line can end.
</div>

<p>
~streamを構文解析する~algoの各~instanceには，変数［
%~data~buffer,
%~event型~buffer,
%最後の~event~ID~buffer
］が結付けられ、いずれも空~文字列に初期化され~MUST。
◎
When a stream is parsed, a data buffer, an event type buffer, and a last event ID buffer must be associated with it. They must be initialized to the empty string
</p>

<p>
それは、~EACH ( 行0 %行0 ) に対し，受信された順序で、次を走らす：
◎
Lines must be processed, in the order they are received, as follows:
</p>

<ol>
	<li>
~IF［
%行0 は空である（空行）
］
⇒
下に定義されるように`~eventを配送-$する
◎
If the line is empty (a blank line)
◎
• Dispatch the event, as defined below.
</li>
	<li>
~ELIF［
%行0 の先頭の文字 ~EQ `colon$P
］
⇒
~CONTINUE
◎
If the line starts with a U+003A COLON character (:)
◎
• Ignore the line.
</li>
	<li>
<p>
~IF［
%行0 は `colon$P を包含する
］：
◎
If the line contains a U+003A COLON character (:)
</p>
		<ol>
			<li>
( %名, %値 ) ~LET  %行0 内の最初の `colon$P より
( 前の部分の文字列, 後の部分の文字列 )
◎
Collect the characters on the line before the first U+003A COLON character (:), and let field be that string.
◎
Collect the characters on the line after the first U+003A COLON character (:), and let value be that string. If value starts with a U+0020 SPACE character, remove it from value.
</li>
			<li>
~IF［
%値 の先頭の文字 ~EQ `space$P
］
⇒
%値 から先頭の文字を除去する
◎
↑</li>
			<li>
( %名, %値 )
に対し`~fieldを処理する$ 
◎
Process the field using the steps described below, using field as the field name and value as the field value.
</li>
		</ol>
	</li>
	<li>
~ELSE（文字列は空でないが `colon$P を包含しない）
⇒
( %行0, 空~文字列 )
に対し`~fieldを処理する$
◎
Otherwise, the string is not empty but does not contain a U+003A COLON character (:)

◎
Process the field using the steps described below, using the whole line as the field name, and the empty string as the field value.
</li>
</ol>

<p>
~streamの終端-に達したときの最後の~blockが，空行で終端されていない場合、その~blockの~dataは破棄され~MUST。
（そのような~blockに対しては、~eventは配送されない。）
（~blockとは、空行で互いに分離されていない，一連の行0を意味する。）
◎
Once the end of the file is reached, any pending data must be discarded. (If the file ends in the middle of an event, before the final empty line, the incomplete event is not dispatched.)
</p>

<hr>

<p class="algo-haed">
`~fieldを処理する@
手続きは、所与の
( %名, %値 )
に対し
<!-- 
Field names must be compared literally, with no case folding performed.
 -->
%名 に応じて：
◎
The steps to process the field given a field name and a field value depend on the field name, as given in the following list. Field names must be compared literally, with no case folding performed.
</p>

<dl class="switch">
	<dt>`event^l
◎
If the field name is "event"
</dt>
	<dd>
%~event型~buffer ~SET %値
◎
Set the event type buffer to field value.
</dd>

	<dt>`data^l
◎
If the field name is "data"
</dt>
	<dd>
［
%値, 1 個の `lf$P
］を，順に %~data~buffer に付加する
◎
Append the field value to the data buffer, then append a single U+000A LINE FEED (LF) character to the data buffer.
</dd>

	<dt>`id^l
◎
If the field name is "id"
</dt>
	<dd>
%最後の~event~ID~buffer  ~SET %値
◎
Set the last event ID buffer to the field value.
</dd>

	<dt>`retry^l
◎
If the field name is "retry"
</dt>
	<dd>
<p>
~IF［
%値 は`~ASCII数字$のみからなる
］
⇒
~event~streamの`再接続~時間$eS ~SET %値 を基数 10 の整数に解釈した結果
</p>
<p>
（他の場合、この~fieldは無視する。）
</p>
◎
If the field value consists of only ASCII digits, then interpret the field value as an integer in base ten, and set the event stream's reconnection time to that integer. Otherwise, ignore the field.
</dd>

	<dt>
他の場合
◎
Otherwise
</dt>
	<dd>
何もしない（この~fieldは無視する。）
◎
The field is ignored.
</dd>
</dl>

<div class="example">
`この例は、訳者による補足。^tnote

<p>
したがって、次の例の様に，同じ~block内に複数の `event^l 行0が含まれている場合、最後に現れたものが、他を上書きすることになる（ `id^l についても同様になる）：
</p>

<pre>
event: add
event: remove
data: 1234
</pre>

<p>
対照的に， `data^l 行0は、行0ごとに~data + `lf$P を付加する。
ただし，~block内の最後の `lf$P は除かれる（下に述べる~eventを配送する手続きの中で除去される）。
</p>

</div>


<p class="algo-head">
~UAは、
`~eventを配送-@
するよう要求されたときは、
( %~data~buffer, %~event型~buffer, %最後の~event~ID~buffer )
を~UAに適切な手続きを用いて処理し~MUST。
◎
When the user agent is required to dispatch the event, the user agent must process the data buffer, the event type buffer, and the last event ID buffer using steps appropriate for the user agent.
</p>

<p class="algo-head">
~Web~browserに対しては、`~eventを配送-$する適切な手続きは，次に従うとする：
◎
For Web browsers, the appropriate steps to dispatch the event are as follows:
</p>

<ol>
	<li>
%O ~LET 当の `EventSource$I ~obj
◎
↓</li>
	<li>
<p>
%O の`最後の~event~ID文字列$eS ~SET %最後の~event~ID~buffer
</p>

<p>
この~bufferは，
`他の~bufferと違って ~eventが生じるごとに^tnote
再設定されないので、
%O の`最後の~event~ID文字列$eSは，この~bufferが次回に~serverにより設定されるまで残り続ける。
</p>
◎
Set the last event ID string of the event source to the value of the last event ID buffer. The buffer does not get reset, so the last event ID string of the event source remains set to this value until the next time it is set by the server.
</li>
	<li>
~IF［
%~data~buffer ~EQ 空~文字列
］
⇒
( %~data~buffer, %~event型~buffer ) ~SET ( 空~文字列, 空~文字列 )；<br>
~RET
◎
If the data buffer is an empty string, set the data buffer and the event type buffer to the empty string and abort these steps.
</li>
	<li>
~IF［
%~data~buffer の最後の文字 ~EQ `lf$P
］
⇒
%~data~buffer から最後の文字を除去する
◎
If the data buffer's last character is a U+000A LINE FEED (LF) character, then remove the last character from the data buffer.
</li>
	<li>
%~event ~LET 次を与える下で，`~eventを作成-$した結果
⇒
( %O に`関連する~Realm$, `MessageEvent$I ~interface )
◎
Let event be the result of creating an event using MessageEvent, in the relevant Realm of the EventSource object.
</li>
	<li>
<p>
%~event の各種~属性を次のように初期化する：
</p>

<ul ><li>`type$m ~SET `message$et
</li><li>`data$m ~SET %~data
</li><li>`origin$m ~SET 当の~event~streamの最終的な~URL（すなわち~redirect後の~URL）の`生成元$の`~Unicode直列化$
</li><li>`lastEventId$m ~SET %O の`最後の~event~ID文字列$eS
</li></ul>

◎
Initialize event's type attribute to message, its data attribute to data, its origin attribute to the Unicode serialization of the origin of the event stream's final URL (i.e. the URL after redirects), and its lastEventId attribute to the last event ID string of the event source.
</li>
	<li>
~IF［
%~event型~buffer ~NEQ 空~文字列
］
⇒
%~event の `type$m ~SET %~event型~buffer
◎
If the event type buffer has a value other than the empty string, change the type of the newly created event to equal the value of the event type buffer.
</li>
	<li>
( %~data~buffer, %~event型~buffer ) ~SET ( 空~文字列, 空~文字列 )
◎
Set the data buffer and the event type buffer to the empty string.
</li>
	<li>
<p>
次を走らす`~taskを待入する$：
</p>
		<ol>
			<li>
~IF［
%O の ``readyState$m 属性~値 ~NEQ ``CLOSED$m
］
⇒
%O に向けて %~event を`配送-$する
</li>
		</ol>
◎
Queue a task which, if the readyState attribute is set to a value other than CLOSED, dispatches the newly created event at the EventSource object.
</li>

</ol>

<p class="note">注記：
~event（ `event$P ）に `id^l ~fieldが伴われていない場合、その~eventから生じる `MessageEvent$I ~event の `lastEventId$m ~fieldは、最後に~~見出された `id^l ~fieldの値
— すなわち，その前の~eventにより設定された`最後の~event~ID文字列$eS
<span class="trans-note">【
`id^l がまだ見出されていなければ，空~文字列（ %最後の~event~ID~buffer の初期~値）
】</span>
—
に設定されることになる。
◎
If an event doesn't have an "id" field, but an earlier event did set the event source's last event ID string, then the event's lastEventId field will be set to the value of whatever the last seen "id" field was.
</p>

<p>
他の~UAに対しては、`~eventを配送-$する適切な手続きは 実装に依存するが、最小限，手続きを終える前に［
%~data~buffer, %~event型~buffer
］を空~文字列に設定し~MUST。
◎
For other user agents, the appropriate steps to dispatch the event are implementation dependent, but at a minimum they must set the data and event type buffers to the empty string before returning.
</p>

<div class="example">

<p>
次の~event~stream（空行で終端されている）に対しては：
◎
The following event stream, once followed by a blank line:
</p>

<pre>
data: YHOO
data: +2
data: 10
</pre>

<p>
`EventSource$I ~objに向けて，
`MessageEvent$I ~interfaceを利用する `message$et ~eventを配送させることになる。
~eventの `data$m 属性は、文字列
`YHOO\n+2\n10^l
を包含することになる（ `\n^l は改行文字（ `lf$P ）を表現する）。
◎
...would cause an event message with the interface MessageEvent to be dispatched on the EventSource object. The event's data attribute would contain the string "YHOO\n+2\n10" (where "\n" represents a newline).
</p>


<p>
これは、次のように利用できる：
◎
This could be used as follows:
</p>

<pre class="js-code">
var %stocks = new EventSource("https://stocks.example.com/ticker.php");
stocks.onmessage = function (%event) {
  var %data = %event.data.split('\n');
  updateStocks(%data[0], %data[1], %data[2]);
};
</pre>

<p>
（ `updateStocks()^c は、~data処理用の何らかの関数。）
◎
...where updateStocks() is a function defined as:
◎
function updateStocks(symbol, delta, value) { ... }
◎
...or some such.
</p>

</div>

<div class="example">

<p>
次の~streamは、 4 個の~blockを包含する。
1 個目の~blockは、~commentなので，~eventは発火されない。
2 個目の~blockに対しては、~eventが発火されることになる
— そこには、名前 `data^l の~field（値に `first event^l を伴う）に加え，名前
`id^l の~fieldもあり、`最後の~event~ID文字列$eS を `1^l に設定することになる。
この~blockと次の~blockの合間で接続が切れた場合、再接続-時に，~serverに向けて値 `1^l を伴う `Last-Event-ID$h ~headerが送信されることになる。
3 個目の~blockも~eventを発火し， `data^l の値に `second event^l を伴うが、
`id^l ~fieldには値は伴われていない
— それは、`最後の~event~ID文字列$eS を空~文字列に再設定する（今度は、再接続が試みられる場合には， `Last-Event-ID$h ~headerは送信されないことを意味する）。
最後の 4 個目の~blockは、単に~dataに ` third event^l （先頭の文字は `space$P ）を伴わせた~eventを発火する。
最後の~blockであっても，空行で終端させる必要があることに注意
— ~streamが終端するだけでは，最後の~blockに対する~event配送を誘発するには十分でない。
◎
The following stream contains four blocks. The first block has just a comment, and will fire nothing. The second block has two fields with names "data" and "id" respectively; an event will be fired for this block, with the data "first event", and will then set the last event ID to "1" so that if the connection died between this block and the next, the server would be sent a `Last-Event-ID` header with the value "1". The third block fires an event with data "second event", and also has an "id" field, this time with no value, which resets the last event ID to the empty string (meaning no `Last-Event-ID` header will now be sent in the event of a reconnection being attempted). Finally, the last block just fires an event with the data " third event" (with a single leading space character). Note that the last still has to end with a blank line, the end of the stream is not enough to trigger the dispatch of the last event.
</p>

<pre>
: test stream

data: first event
id: 1

data:second event
id

data:&nbsp;&nbsp;third event
</pre>

</div>

<div class="example">

<p>
次の~streamは、最後の~blockは空行で終端されていないならば， 2 個の~eventを発火する：
◎
The following stream fires two events:
</p>


<pre>
data

data
data

data:
</pre>

<p>
1 個目の~blockは、~data が空~文字列にされた~eventを発火する。
2 個目の~blockは、~dataを 1 個の改行文字に設定した上で，~eventを発火する。
3 個目の~blockは、空行が後続していないので，破棄される。
◎
The first block fires events with the data set to the empty string, as would the last block if it was followed by a blank line. The middle block fires an event with the data set to a single newline character. The last block is discarded because it is not followed by a blank line.
</p>

</div>

<div class="example">

<p>
次の~streamは、 2 個の~~等価な~eventを発火する：
◎
The following stream fires two identical events:
</p>

<pre>
data:test

data:&nbsp;test
</pre>

<p>
`colon$P の直後にある 1 個の `space$P は、無視されるので。
◎
This is because the space after the colon is ignored if present.
</p>

</div>




			</section>
			<section id="authoring-notes">
<h3 title="Authoring notes">9.2.6. 著作~上の注記</h3>

<p>
旧来の~proxy~serverは、ある種の事例では、短い~timeout後に~HTTP接続を落とすことが知られている。
作者は、およそ毎 15 秒ごとに，~comment行0（`colon$P から開始される行0）を含ませることにより，そのような~proxy~serverに抗して保護できる。
◎
Legacy proxy servers are known to, in certain cases, drop HTTP connections after a short timeout. To protect against such proxy servers, authors can include a comment line (one starting with a ':' character) every 15 seconds or so.
</p>

<p>
~event~source接続を［
互いに, あるいは以前に~serveされた特定の文書
］に関係させたいと望む作者は、~IP~addressに依拠するのでは，うまく働かないことを見出すであろう
— （複数の~proxy~serverを通すことに因り）同じ~clientが 複数の~IP~addressから接続することもあれば、（~proxy~serverを共有していることに因り）複数の~clientが 同じ~IP~addressから接続することもあるので。
文書を~serveするときに，その文書~内に一意な識別子を含ませておいて、接続の確立-時に その識別子を~URLの一部として渡す方が良い。
◎
Authors wishing to relate event source connections to each other or to specific documents previously served might find that relying on IP addresses doesn't work, as individual clients can have multiple IP addresses (due to having multiple proxy servers) and individual IP addresses can have multiple clients (due to sharing a proxy server). It is better to include a unique identifier in the document when it is served and then pass that identifier as part of the URL when the connection is established.
</p>

<p>
作者は，また、~HTTPが規定する~chunkingは，この~protocolの信頼性に 予期されない負の効果をもたらし得ることにも警戒すること
— 特に、~chunkingが~timing要件に関知しない層で行われている場合には。
これが問題になる場合、~event~streamの~serveに対しては，~chunkingを不能化できる。
◎
Authors are also cautioned that HTTP chunking can have unexpected negative effects on the reliability of this protocol, in particular if the chunking is done by a different layer unaware of the timing requirements. If this is a problem, chunking can be disabled for serving event streams.
</p> 

<p class="trans-note">【
~chunking（ chunking ）
— おそらく，
<a href="~RFC7230#section-4.1">chunked transfer coding</a>
を指す。
】</p>


<div class="p">
<p>
~HTTPによる~server単位の接続~数~制限を~supportする~clientは、ある~siteから複数の頁を~openしたとき，その各~頁に同じ~domainへの `EventSource$I がある場合に 困らされることもある。
作者がこれを避ける方法には、次が挙げられる：
</p>

<ul><li>より複雑な仕組みを用いる
</li><li>接続ごとに一意な~domain名を用いる
</li><li>利用者が頁ごとに `EventSource$I の機能性を可能化したり不能化できるようにする
</li><li>単独の `EventSource$I ~objを`共用~worker内$で共有する
</li></ul>

<p class="trans-note">【
接続~数~制限
— おそらく，
<a href="~RFC7230#section-6.4">RFC7230, 6.4 節</a>
を指す。
】</p>

◎
Clients that support HTTP's per-server connection limitation might run into trouble when opening multiple pages from a site if each page has an EventSource to the same domain. Authors can avoid this using the relatively complex mechanism of using unique domain names per connection, or by allowing the user to enable or disable the EventSource functionality on a per-page basis, or by sharing a single EventSource object using a shared worker.
</div>


			</section>
			<section id="eventsource-push">
<h3 title="Connectionless push and other features">9.2.7. 無接続~pushと他の特色機能</h3>

<p>
制御~下にある環境で走っている~UA
— 例えば，特定の~carrierに束ねられている携帯機の~browser —
は、接続の管理を~network上の~proxyに負荷移譲してよい。
適合性の目的においては、そのような状況における~UAは，その携帯機~softwareと~network~proxyの両者を含むものと見なされる。
◎
User agents running in controlled environments, e.g. browsers on mobile handsets tied to specific carriers, may offload the management of the connection to a proxy on the network. In such a situation, the user agent for the purposes of conformance is considered to include both the handset software and the network proxy.
</p>

<div class="example">

<p>
例えば，携帯機の~browserは、接続を確立した後に、その接続は `~proxyが^tnote
~supportしている~networkであることを検出して，その~network上の~proxy~serverに接続の管理を司るよう要請するかもしれない。
そのような状況においては、次のような経過を辿ることになる：
◎
For example, a browser on a mobile device, after having established a connection, might detect that it is on a supporting network and request that a proxy server on the network take over the management of the connection. The timeline for such a situation might be as follows:
</p>

<ol>
	<li>
~browserは、作者が `EventSource()$m 構築子にて指定した資源を，~remote~HTTP~serverへ接続して要請する。
◎
Browser connects to a remote HTTP server and requests the resource specified by the author in the EventSource constructor.
</li>
	<li>
~serverは、各~messageを不定期に送信する。
◎
The server sends occasional messages.
</li>
	<li>
~browserは、ある 2 つの~messageの合間に，［
~TCP接続を~~維持し続けるための~network活動を除き，自身は遊休~中にある
］ことを検出したので、電力を節約するため，~sleep~modeへ切替えることにした。
◎
In between two messages, the browser detects that it is idle except for the network activity involved in keeping the TCP connection alive, and decides to switch to sleep mode to save power.
</li>
	<li>
~browserは、~serverから切断される。
◎
The browser disconnects from the server.
</li>
	<li>
~browserは、当の接続を保守する代わりに，上述した~network上の~serviceに接触して “~push~proxy” ~serviceを要請する。
◎
The browser contacts a service on the network, and requests that the service, a "push proxy", maintain the connection instead.
</li>
	<li>
“~push~proxy” ~serviceは、~remote~HTTP~serverに接触して，作者が `EventSource()$m 構築子にて指定した資源を要請する（場合によっては， `Last-Event-ID$h ~HTTP~header, 等々が含まれる）。
◎
The "push proxy" service contacts the remote HTTP server and requests the resource specified by the author in the EventSource constructor (possibly including a `Last-Event-ID` HTTP header, etc).
</li>
	<li>
~browserは、携帯機に~sleepすることを許容する。
◎
The browser allows the mobile device to go to sleep.
</li>
	<li>
~serverは、別の~messageを送信する。
◎
The server sends another message.
</li>
	<li>
“~push~proxy” ~serviceは、~eventを携帯機に運ぶため，~OMA~pushなどの技術を利用する
— それは、~eventを処理するに足るだけ携帯機を目覚めさせてから，~sleepに戻す。
`OMA = おそらく、 Open Mobile Alliance（携帯電話の規格を策定する組織）を指す。^tnote
◎
The "push proxy" service uses a technology such as OMA push to convey the event to the mobile device, which wakes only enough to process the event and then returns to sleep.
</li>
</ol>

</div>

<p>
これは，総~data使用量を抑制する結果、~~相当に電力を節約する。
◎
This can reduce the total data usage, and can therefore result in considerable power savings.
</p>

<p>
［
既存の~API, および
`text/event-stream$c 伝送路~形式
］を［
この仕様により定義されるように, および
上に述べたような より分散的な仕方
］で実装することに加え、`適用し得る仕様$により定義される~event~framingの形式も~supportされてよい。
この仕様は、それがどう構文解析され, 処理されるかは，定義しない。
◎
As well as implementing the existing API and text/event-stream wire format as defined by this specification and in more distributed ways as described above, formats of event framing defined by other applicable specifications may be supported. This specification does not define how they are to be parsed or processed.
</p>


			</section>
			<section id="garbage-collection-2">
<h3 title="Garbage collection">9.2.8. ~garbage収集</h3>

<p>
［
`Window$I ／ `WorkerGlobalScope$I
］~obj %G 内の構築子を呼出して作成された `EventSource$I ~obj %O
に対しては、次のいずれかが満たされている間は，
%G から %O への強い参照-が~MUST：
◎
↓</p>

<ul>
	<li>
［
%O の ``readyState$m ~EQ ``CONNECTING$m
］~AND［
%O には［
`open$et ／ `message$et ／`error$et
］~eventに対する~event~listenerが 1 個~以上~登録されている
］
◎
While an EventSource object's readyState is CONNECTING, and the object has one or more event listeners registered for open, message or error events, there must be a strong reference from the Window or WorkerGlobalScope object that the EventSource object's constructor was invoked from to the EventSource object itself.
</li>
	<li>
［
%O の ``readyState$m ~EQ ``OPEN$m
］~AND［
%O には［
`message$et ／ `error$et
］~eventに対する~event~listenerが 1 個~以上~登録されている
］
◎
While an EventSource object's readyState is OPEN, and the object has one or more event listeners registered for message or error events, there must be a strong reference from the Window or WorkerGlobalScope object that the EventSource object's constructor was invoked from to the EventSource object itself.
</li>
	<li>
%O により`~remote~event~task源$から待入された~taskがある
◎
While there is a task queued by an EventSource object on the remote event task source, there must be a strong reference from the Window or WorkerGlobalScope object that the EventSource object's constructor was invoked from to that EventSource object.
</li>
</ul>


<div class="p">
<p class="algo-head">
~UAは、 `EventSource$I ~obj %O を
`強制的に~closeする@
ときは（これは `Document$I ~objが永続的に消去ったときに起こる），次を走らせ~MUST：
</p> 

<ol ><li>%O のために開始された すべての`~fetch$~algoを中止する
</li><li>%O の ``readyState$m 属性 ~SET ``CLOSED$m 
</li></ol>

◎
If a user agent is to forcibly close an EventSource object (this happens when a Document object goes away permanently), the user agent must abort any instances of the fetch algorithm started for this EventSource object, and must set the readyState attribute to CLOSED.
</div>

<p>
`EventSource$I ~obj %O が，接続が依然として~openしている間に~garbage収集された場合、
~UAは， %O のために開始された すべての`~fetch$~algoを中止し~MUST。
◎
If an EventSource object is garbage collected while its connection is still open, the user agent must abort any instance of the fetch algorithm opened by this EventSource.
</p> 




			</section>
			<section id="implementation-advice">
<h3 title="Implementation advice">9.2.9. 実装への~advice</h3>

~INFORMATIVE

<p>
この~APIを利用している作者による~codeの~debugを支援するため、~UAには，［
`EventSource$I ~obj, および それに関係する~network接続
］についての詳細な診断~情報を，開発~console内に提供することが強く督促される。
◎
User agents are strongly urged to provide detailed diagnostic information about EventSource objects and their related network connections in their development consoles, to aid authors in debugging code using this API.
</p>

<div class="p">
<p>
例えば~UAは、頁が作成した すべての `EventSource$I ~objのそれぞれについて 次を表示するような~panelを備えることもできる：
</p>

<ul><li>構築子の引数
</li><li>~network~errorが生じたかどうか
</li><li>接続の~CORS~statusは何であるか
</li><li>その~statusに導いた（~clientが送信した／ ~serverから受信された）~headerたち
</li><li>受信された~message
</li><li>その~messageはどう構文解析されたか, 等々。
</li></ul>
◎
For example, a user agent could have a panel displaying all the EventSource objects a page has created, each listing the constructor's arguments, whether there was a network error, what the CORS status of the connection is and what headers were sent by the client and received from the server to lead to that status, the messages that were received and how they were parsed, and so forth.
</div>

<p>
とりわけ， `error$et ~eventが発火されたときには、実装には，詳細な情報を自身の開発~consoleに報告することが奨励される
— ~event自体から可用になる情報は少ししかないので。
◎
Implementations are especially encouraged to report detailed information to their development consoles whenever an error event is fired, since little to no information can be made available in the events themselves.
</p>

			</section>
		</section>
		<section id="network">
<h2 title="Web sockets">9.3. ~web-socket</h2>

<p class="trans-note">【
この節の内容の和訳は、<a href="~WEBSOCKET#network">別ページ</a>にて。
】</p>

		</section>
		<section id="web-messaging">
<h2 title="Cross-document messaging">9.4. 文書間~messaging</h2>
<a id="crossDocumentMessages"></a>


<p>
保安や~privacyの理由から、~web~browserは，異なる~domainに属する文書どうしが互いに影響しあうのを防止する
— すなわち、~XSSは不許可にされる。
◎
Web browsers, for security and privacy reasons, prevent documents in different domains from affecting each other; that is, cross-site scripting is disallowed.
</p>

<p>
これは重要な保安~用の特色機能であるが、異なる~domainに属する頁との通信は，その頁が敵対的でなくとも防止される。
この節では、~source~domainに関わらず，文書どうしが互いに~messageを通信しあえるようにする~systemを、~XSS攻撃を可能化しないように設計される仕方で導入する。
◎
While this is an important security feature, it prevents pages from different domains from communicating even when those pages are not hostile. This section introduces a messaging system that allows documents to communicate with each other regardless of their source domain, in a way designed to not enable cross-site scripting attacks.
</p>

<p class="note">注記：
この~APIには、直ぐには明らかにならないかもしれない
<a href="~HTML5/introduction.html#fingerprint-postMessage">ある~privacy上の含意がある</a>。
◎
This API has some privacy implications that might not be immediately obvious.
</p>


<p>
`投函済み~message~task源@
が、`文書間~messaging$における`~task$の`~task源$になる。
◎
The task source for the tasks in cross-document messaging is the posted message task source.
</p>

			<section id="introduction-12">
<h3 title="Introduction">9.4.1. 序論</h3>

~INFORMATIVE

<div class="example">

<p>
例えば，ある文書 %A が
`iframe$e 要素を包含していて,
その要素は 別の文書 %B を包含している下で，
%A 内の~scriptが %B の `Window$I ~objの
`window.postMessage()$m を~callした場合、~message~eventは，その~objに向けて発火される
— %A の `Window$I を出自にしているよう~markされた上で。
%A 内の~scriptは次の様になるであろう：
◎
For example, if document A contains an iframe element that contains document B, and script in document A calls postMessage() on the Window object of document B, then a message event will be fired on that object, marked as originating from the Window of document A. The script in document A might look like:
</p>

<pre class="js-code">
var %o = document.getElementsByTagName('iframe')[0];
%o.contentWindow.postMessage('Hello world', 'https://b.example.org/');
</pre>

<p>
%B 内の~scriptは、入って来る~eventに対する~event~handlerを登録するため、
`addEventListener()^m （または類似する仕組み）を利用することになる。
例えば，次の様になるであろう：
◎
To register an event handler for incoming events, the script would use addEventListener() (or similar mechanisms). For example, the script in document B might look like:
</p>

<pre class="js-code">
window.addEventListener('message', receiver, false);
function receiver(%e) {
  if (%e.origin == 'https://example.com') {
    if (%e.data == 'Hello world') {
      %e.source.postMessage('Hello', %e.origin);
    } else {
      alert(%e.data);
    }
  }
}
</pre>

<p>
この~scriptは、まず，~domainが期待されるものかどうか検査する。
次に，~messageの中身に応じて、利用者に表示するか，または
~message送信してきた文書に ~messageを返信して応答する。
◎
This script first checks the domain is the expected domain, and then looks at the message, which it either displays to the user, or responds to by sending a message back to the document which sent the message in the first place.
</p>

  </div>





			</section>
			<section id="security-postmsg">
<h3 title="Security">9.4.2. 保安</h3>

				<section id="authors">
<h4 title="Authors">9.4.2.1. 作者</h4>


<p id="security-4" class="warning">
利己~目的で~siteを濫用する敵対的~主体から 利用者を保護するため、この~APIの利用にあたっては，格別に注意することが要求される。
◎
Use of this API requires extra care to protect users from hostile entities abusing a site for their own purposes.
</p>

<p>
作者は、 `origin$m 属性を検査して，受容する~messageを，自身が期待する~domainから受信されるものに限ることを確保するべきである。
作者の~message取扱い~code内に~bugがある場合、敵対的~siteにより悪用され得ることになる。
◎
Authors should check the origin attribute to ensure that messages are only accepted from domains that they expect to receive messages from. Otherwise, bugs in the author's message handling code could be exploited by hostile sites.
</p>

<p>
加えて， `origin$m 属性を検査した後でも、作者は，当の~dataが期待される形式であるかどうか検査するべきある。
さもなければ、~eventの~sourceが~XSSに対する欠陥を突いて攻撃されていた場合に、
`window.postMessage()$m ~methodで送信された情報は，攻撃により受信器にまで伝播されることになる。
◎
Furthermore, even after checking the origin attribute, authors should also check that the data in question is of the expected format. Otherwise, if the source of the event has been attacked using a cross-site scripting flaw, further unchecked processing of information sent using the postMessage() method could result in the attack being propagated into the receiver.
</p>

<p>
作者は、機密的~情報を包含するような~messageに対しては，生成元~引数（ %targetOrigin ）に~wildcard-keyword （ `*^l ）を渡すべきでない。
そうしない以外に、~messageの送達-先を意図された受信者のみに限るよう保証する仕方はない。
◎
Authors should not use the wildcard keyword (*) in the targetOrigin argument in messages that contain any confidential information, as otherwise there is no way to guarantee that the message is only delivered to the recipient to which it was intended.
</p>

<hr>

<p>
どの生成元からの~messageも受容する作者には、~DoS攻撃の~riskを考慮することが奨励される。
攻撃者は大容量の~messageを送信することもできる。
受信-中の頁が高価な計算を遂行したり，そのような各~messageごとに 送信-による~network流通が生じる場合、攻撃者の~messageは，~DoS攻撃~用に増殖される。
作者には、そのような攻撃が実用的でなくなるよう，~rate制限-法を使役することが奨励される（毎分あたりの~message数を一定に抑えるなど）。
◎
Authors who accept messages from any origin are encouraged to consider the risks of a denial-of-service attack. An attacker could send a high volume of messages; if the receiving page performs expensive computation or causes network traffic to be sent for each such message, the attacker's message could be multiplied into a denial-of-service attack. Authors are encouraged to employ rate limiting (only accepting a certain number of messages per minute) to make such attacks impractical.
</p>


				</section>
				<section id="user-agents">
<h4 title="User agents">9.4.2.2. ~UA</h4>

<p>
この~API
`による~message^tnote
の完全性は、ある`生成元$の~scriptが，任意の~eventを（`同一生成元$でない）他の生成元に属する~objへ（ `dispatchEvent()^m などを用いて）投函できないことに基づいている。
◎
The integrity of this API is based on the inability for scripts of one origin to post arbitrary events (using dispatchEvent() or otherwise) to objects in other origins (those that are not the same).
</p>

<p class="note">注記：
実装者には、この特色機能を実装するにあたり，格別に注意することが督促される。
この特色機能は、作者がある~domainから別の~domainへ情報を伝送できるようにする
— 通常は 保安の理由から不許可にされるような。
また，~UAには、ある種の~propertyへの~accessを，一方には許容しつつ, 他方には許容しないよう注意深くなることが要求される。
◎
Implementors are urged to take extra care in the implementation of this feature. It allows authors to transmit information from one domain to another domain, which is normally disallowed for security reasons. It also requires that UAs be careful to allow access to certain properties but not others.
</p>

<hr>

<p>
簡易的な~siteを~DoS攻撃から保護するため、~UAには，異なる`生成元$の間での~message流通~rateの制限-法を考慮することが奨励される。
◎
User agents are also encouraged to consider rate-limiting message traffic between different origins, to protect naïve sites from denial-of-service attacks.
</p>


				</section>
			</section>
			<section id="posting-messages">
<h3 title="Posting messages">9.4.3. ~messageの投函-法</h3>

<dl class="domintro">

	<dt>%window . `postMessage(message, targetOrigin [, transfer ] )$m</dt>
	<dd>
<p>
%message を %window へ投函する。
%message は有構造~objにもなり得る。
例えば次のものを包含できる：
</p>

<ul><li>入子にされた~objや配列
</li><li>~JS値（ `string^jT, `number^jT, `Date$jT ~obj, 等々）
</li><li>`File$I, `Blob$I, `FileList$I, `ArrayBuffer$I などの，ある種の~data~obj
</li></ul>
◎
Posts a message to the given window. Messages can be structured objects, e.g. nested objects and arrays, can contain JavaScript values (strings, numbers, Date objects, etc), and can contain certain data objects such as File Blob, FileList, and ArrayBuffer objects.
</dd>
	<dd>
%transfer 内に~listされた~objは、~cloneされるのみならず転送される
— すなわち，送信-側からは、それ以降，それらを利用できなくなる。
◎
Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.
</dd>
	<dd>
宛先 %window の生成元が，生成元 %targetOrigin に合致しない場合、情報~漏洩を避けるため，~messageは 破棄される。
生成元に関わらず，~messageを宛先に送信したければ、
%targetOrigin に `*^l を与える。
生成元を明示的に与えずに ~messageを同一生成元の宛先のみに制約したければ、
%targetOrigin に `/^l を与える。
◎
If the origin of the target window doesn't match the given origin, the message is discarded, to avoid information leakage. To send the message to the target regardless of origin, set the target origin to "*". To restrict the message to same-origin targets only, without needing to explicitly state the origin, set the target origin to "/".
</dd>
	<dd>
次の場合は `DataCloneError$E が投出される
⇒
%transfer 配列が同じ~objを重複して包含する場合／
%message を~cloneできなかった場合
◎
Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or if message could not be cloned.
</dd>

</dl>

<p class="note">注記：
~navigateされたばかりの`閲覧文脈$に属する新たな `Document$I の `Window$I に，~messageを投函した場合、その~messageは，意図された受信者に受信されない見込みが高い
— 宛先 `閲覧文脈$内の~scriptは、~messageに対する~listenerを設定しておく時間を要するので。
したがって，具体例として、~messageが 新たに作成された子 `iframe$e の `Window$I に送信される状況においては、作者には、子 `Document$I から先に，受信する用意が整った旨を親~宛に公告する~messageを投函させ、親は，この~messageを待機してから~messageを投函し始めるようにすることを勧める。
◎
When posting a message to a Window of a browsing context that has just been navigated to a new Document is likely to result in the message not receiving its intended recipient: the scripts in the target browsing context have to have had time to set up listeners for the messages. Thus, for instance, in situations where a message is to be sent to the Window of newly created child iframe, authors are advised to have the child Document post a message to their parent announcing their readiness to receive messages, and for the parent to wait for this message before beginning posting messages.
</p>


<p class="idl-def">
`Window$I ~obj上の
`postMessage( message, targetOrigin, transfer )@m
の被呼出時には、次の手続きを走らせ~MUST：
◎
The postMessage(message, targetOrigin, transfer) method, when invoked on a Window object must run the following steps:
</p>

<ol>
	<li>
%宛先~window ~LET 此れ
◎
Let targetWindow be this Window object.
</li>
	<li>
%宛先~Realm ~LET %宛先~window の`~Realm$
◎
Let targetRealm be targetWindow's Realm.
</li>
	<li>
%現任の設定群 ~LET `現任の設定群~obj$
◎
Let incumbentSettings be the incumbent settings object.
</li>
	<li>
%宛先~生成元 ~LET ε
◎
↓</li>
	<li>
~IF［
%targetOrigin ~EQ U+002F （ `/^l ）
］
⇒
%宛先~生成元 ~SET %現任の設定群 の`生成元$enV
◎
If targetOrigin is a single U+002F SOLIDUS character (/), then set targetOrigin to incumbentSettings's origin.
</li>
	<li>
<p>
~ELIF［
%targetOrigin ~NEQ U+002A （ `*^l ）
］：
◎
Otherwise, if targetOrigin is not a single U+002A ASTERISK character (*), then:
</p>

		<ol>
			<li>
%解析済み~URL ~LET 
%targetOrigin を`~URL構文解析器$にかけた結果
◎
Let parsedURL be the result of running the URL parser on targetOrigin.
</li>
			<li>
~IF［
%解析済み~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL is failure, then throw a "SyntaxError" DOMException.
</li>
			<li>
%宛先~生成元 ~SET %解析済み~URL の`生成元$url
◎
Set targetOrigin to parsedURL's origin.
</li>
		</ol>
	</li>
	<li>
%転送-を伴う直列化-結果 ~LET `StructuredSerializeWithTransfer$jA( %message, %transfer )
（例外投出あり）
◎
Let serializeWithTransferResult be StructuredSerializeWithTransfer(message, transfer). Rethrow any exceptions.
</li>
	<li>
<p>
`投函済み~message~task源$から，次を走らす`~taskを待入する$：
◎
Queue a task on the posted message task source to run the following steps:
</p>
		<ol>
			<li>
~IF［
%宛先~生成元 ~NEQ ε
］~AND［
( %宛先~window に`結付けられている文書$の`生成元$,  %宛先~生成元 )
は`同一生成元$でない
］
⇒
~RET
◎
If the targetOrigin argument is not a single literal U+002A ASTERISK character (*) and targetWindow's associated Document's origin is not same origin with targetOrigin, then abort these steps.
</li>
			<li>
%生成元 ~LET %現任の設定群 の`生成元$enVの`~Unicode直列化$
◎
Let origin be the Unicode serialization of incumbentSettings's origin.
</li>
			<li>
%~source ~LET
`WindowProxy$I ~objの対応している`？^tnote
%現任の設定群 の`大域~obj$enV （ `Window$I ~obj）
◎
Let source be the WindowProxy object's corresponding to incumbentSettings's global object (a Window object).
</li>
			<li>
%逆直列化-~record ~LET `StructuredDeserializeWithTransfer$jA( %転送-を伴う直列化-結果, %宛先~Realm )
◎
Let deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, targetRealm).
</li>
			<li>
<p>
~IF［
前~段にて例外が投出された
］：
</p>
				<ol>
					<li>
<p>
%宛先~window に向けて，次のように初期化された名前 `messageerror$et の`~eventを発火-$する：
</p>

<ul ><li>`MessageEvent$I を利用する
</li><li>`origin$m 属性 ~SET %生成元
</li><li>`source$m 属性 ~SET %~source
</li></ul>
					</li>
					<li>
~RET
</li>
				</ol>
◎
If this throws an exception, fire an event named messageerror at targetWindow, using MessageEvent, with the origin attribute initialized to origin and the source attribute initialized to source, and then abort these steps.
</li>
			<li>
%~message~clone ~LET %逆直列化-~record . `Deserialized^sl
◎
Let messageClone be deserializeRecord.[[Deserialized]].
</li>
			<li>
%新~port~list ~LET
%逆直列化-~record . `TransferredValues^sl 内の すべての `MessagePort$I ~objからなる，同順の新たな`凍結~配列$
◎
Let newPorts be a new frozen array consisting of all MessagePort objects in deserializeRecord.[[TransferredValues]], if any, maintaining their relative order.
</li>
			<li>
<p>
%宛先~window に向けて，次のように初期化された名前 `message$et の`~eventを発火-$する：
</p>

<ul ><li>`MessageEvent$I を利用する
</li><li>`origin$m 属性 ~SET %生成元
</li><li>`source$m 属性 ~SET %~source
</li><li>`data$m 属性 ~SET  %~message~clone
</li><li>`ports$m 属性 ~SET %新~port~list
</li></ul>

◎
Fire an event named message at targetWindow, using MessageEvent, with the origin attribute initialized to origin, the source attribute initialized to source, the data attribute initialized to messageClone, and the ports attribute initialized to newPorts.
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="channel-messaging">
<h2 title="Channel messaging">9.5. ~channel~messaging</h2>

<!-- ``MessagePort^I -->

			<section id="introduction-13">
<h3 title="Introduction">9.5.1. 序論</h3>

~INFORMATIVE

<p>
`~channel~messaging$
`channel messaging （ “~channelを介した~messageの送信-法” ）^tnote
を利用すれば、作者は，独立な~code片どうし（例えば，異なる`閲覧文脈$内で走っているもの）を 直接的に通信させれる。
◎
To enable independent pieces of code (e.g. running in different browsing contexts) to communicate directly, authors can use channel messaging.
</p>

<p>
この仕組みにおける通信~channelは、両端に~portを伴う，二重化された~pipeとして実装される。
一方の~portに送信される~messageは，他方の~portに送達され、逆も同様になる。
各~messageは、走っている`~task$を中断したり阻むことなく，~DOM~eventとして送達される。
◎
Communication channels in this mechanism are implemented as two-ways pipes, with a port at each end. Messages sent in one port are delivered at the other port, and vice-versa. Messages are delivered as DOM events, without interrupting or blocking running tasks.
</p>

<p>
接続（ “連絡された”  2 個の~port）を作成するためには、
`MessageChannel()$m 構築子を~callする：
◎
To create a connection (two "entangled" ports), the MessageChannel() constructor is called:
</p>

<pre class="js-code">
var %channel = new MessageChannel();
</pre>

<p>
一方の~portは 局所~portとして保たれ、他方の~portは ~remote~codeへ送信される
— 例えば `window.postMessage()$m を用いて：
◎
One of the ports is kept as the local port, and the other port is sent to the remote code, e.g. using postMessage():
</p>

<pre class="js-code">
%otherWindow.postMessage('hello', 'https://example.com', [%channel.port2]);
</pre>

<p>
~messageを送信するためには、局所~port上の ``postMessage()$m ~methodを利用する：
◎
To send messages, the postMessage() method on the port is used:
</p>

<pre class="js-code">
%channel.port1.postMessage('hello');
</pre>

<p>
~messageを受信するためには、 `message$et ~eventを~listenする：
◎
To receive messages, one listens to message events:
</p>

<pre class="js-code">
%channel.port1.onmessage = handleMessage;
function handleMessage(%event) {
  /* <span class="comment">
~messageは %event の`data$m 属性~内にある
◎
message is in event.data
</span> */
  // ...
}
</pre>

<p>
~portに送信する~dataは、有構造~dataも可能である。
例えば，次では、一連の文字列からなる配列が `MessagePort$I に渡される：
◎
Data sent on a port can be structured data; for example here an array of strings is passed on a MessagePort:
</p>

<pre class="js-code">
%channel.port1.postMessage(['hello', 'world']);
</pre>




				<section id="examples-5">
<h4 title="Examples">9.5.1.1. 例</h4>

~INFORMATIVE

<div class="example">

<p>
この例では、  2 つの~JS~libraryが `MessagePort$I を用いて互いに接続される。
これにより，~libraryは、~APIを何ら変更することなく，後で［
`~worker$ ~obj／異なる~frame
］内に~hostすることも可能になる。
◎
In this example, two JavaScript libraries are connected to each other using MessagePorts. This allows the libraries to later be hosted in different frames, or in Worker objects, without any change to the APIs.
</p>

<pre>
&lt;script src="contacts.js"&gt;&lt;/script&gt; &lt;!-- <span class="comment">
%contacts ~objを公開する
◎
exposes a contacts object
</span> --&gt;
&lt;script src="compose-mail.js"&gt;&lt;/script&gt; &lt;!-- <span class="comment">
%composer ~objを公開する
◎
exposes a composer object
</span> --&gt;
&lt;script&gt;
 var %channel = new MessageChannel();
 %composer.addContactsProvider(%channel.port1);
 %contacts.registerConsumer(%channel.port2);
&lt;/script&gt;
</pre>

<p>
`addContactsProvider()^c 関数の実装は、次の様になる：
◎
Here's what the "addContactsProvider()" function's implementation could look like:
</p>

<pre class="js-code">
function addContactsProvider(%port) {
  %port.onmessage = function (%event) {
    switch (%event.data.messageType) {
      'search-result': handleSearchResult(%event.data.results); break;
      'search-done': handleSearchDone(); break;
      'search-error': handleSearchError(%event.data.message); break;
      // ...
    }
  };
};
</pre>

<p>
あるいは、次の様に実装することもできる：
◎
Alternatively, it could be implemented as follows:
</p>

<pre class="js-code">
function addContactsProvider(%port) {
  %port.addEventListener('message', function (%event) {
    if (%event.data.messageType == 'search-result')
      handleSearchResult(%event.data.results);
  });
  %port.addEventListener('message', function (%event) {
    if (%event.data.messageType == 'search-done')
      handleSearchDone();
  });
  %port.addEventListener('message', function (%event) {
    if (%event.data.messageType == 'search-error')
      handleSearchError(%event.data.message);
  });
  // ...
  %port.start();
};
</pre>

<p>
上の 2 つの~codeにおける~~主な違いは、
`addEventListener()$m を利用した場合，
``start()$m ~methodも呼出す必要がある点にある。
``onmessage$m を利用した場合，暗黙的に ``start()$m も~callされる。
◎
The key difference is that when using addEventListener(), the start() method must also be invoked. When using onmessage, the call to start() is implied.
</p>

<p>
``start()$m ~methodは、明示的に~callされようが，（ ``onmessage$m を設定することにより）暗黙的に~callされようが，~messageの~flowを開始する。
その前の初期~時においては、~message~portに投函された~messageは，~scriptが自身による~handlerを設定しておく機会を得る前に どこかへ落とされないよう，一時停止される。
◎
The start() method, whether called explicitly or implicitly (by setting onmessage), starts the flow of messages: messages posted on message ports are initially paused, so that they don't get dropped on the floor before the script has had a chance to set up its handlers.
</p>

</div>


				</section>
				<section id="ports-as-the-basis-of-an-object-capability-model-on-the-web">
<h4 title="Ports as the basis of an object-capability model on the Web">9.5.1.2. ~web上の~obj能力~modelの基礎としての~port</h4>

~INFORMATIVE

<p class="trans-note">【
<a href="https://en.wikipedia.org/wiki/Object-capability_model">~obj能力~model</a>
】</p>

<p>
~portは、［
~system内の他の動作者に，制限された能力を公開する仕方
］と捉えることもできる（~obj能力~model的意味で）。
これは、弱い能力~systemにも、強い能力~modelにもなり得る。
弱い能力~systemにおける~portは、単に同じ生成元の中で便利用~modelとして利用される。
強い能力~systemにおける~portは、ある生成元に属する %提供者 （ provider ）から 別の生成元に属する %消費者 （ consumer ）に向けて， %消費者 が［
%提供者 に効果を及ぼせる ／
%提供者 からの情報を得る
］ような唯一の仕組みとして，提供される。
◎
Ports can be viewed as a way to expose limited capabilities (in the object-capability model sense) to other actors in the system. This can either be a weak capability system, where the ports are merely used as a convenient model within a particular origin, or as a strong capability model, where they are provided by one origin provider as the only mechanism by which another origin consumer can effect change in or obtain information from provider.
</p>

<div class="p">
<p>
例えば、ある %~social~site の頁が，次のような 2 個の `iframe$e を埋込んでいる状況を考える：
</p>

<ul>
	<li>
%提供者~frame は、（ %~social~site とは別の生成元に属する） %提供者
— ここでは，利用者の~address-bookを提供している~serviceとする —
からの内容を含んでいる
</li>
	<li>
%消費者~frame は、（また別の生成元に属する）
%消費者
— 例えば，ある~game~siteなど —
からの内容を含んでいる
</li>
</ul>

<p>
%~social~site 頁, および %消費者~frame 内からは、
%提供者~frame の内側にあるものには~accessできない
— これら二者が %提供者~frame の内側に何か及ぼせるのは、次に限られる：
</p>
◎
For example, consider a situation in which a social Web site embeds in one iframe the user's e-mail contacts provider (an address book site, from a second origin), and in a second iframe a game (from a third origin). The outer social site and the game in the second iframe cannot access anything inside the first iframe; together they can only:
</div>

<ul>
	<li>
%提供者~frame を［
%提供者~frame の~URLと`素片$urlだけ異なる`~URL$
］へ`~navigate$する
—  %提供者~frame 内の `Window$I は `hashchange$et ~eventを受信することになる。
◎
Navigate the iframe to a new URL, such as the same URL but with a different fragment, causing the Window in the iframe to receive a hashchange event.
</li>
	<li>
%提供者~frame を~resizeする
— %提供者~frame 内の `Window$I は `resize$et ~eventを受信することになる。
◎
Resize the iframe, causing the Window in the iframe to receive a resize event.
</li>
	<li>
`window.postMessage()$m ~APIを用いて， %提供者~frame 内の `Window$I へ `message$et ~eventを送信する。
◎
Send a message event to the Window in the iframe using the window.postMessage() API.
</li>
</ul>

<p>
%提供者 は、これらのうち，特に 3 番目の~method
— `message$et ~event —
を利用して、他の生成元から~accessできるような，利用者の~address-bookを操作するための~APIを提供する。
例えば、~message
"<code class="literal">add-contact: Guillaume Tell &lt;tell@pomme.example.net&gt;</code>"
に対し、それが与える個人名とその~e-mail~addressを 利用者の~address-bookに追加することにより，応答することもできる。
◎
The contacts provider can use these methods, most particularly the third one, to provide an API that can be accessed by other origins to manipulate the user's address book. For example, it could respond to a message "add-contact Guillaume Tell &lt;tell@pomme.example.net&gt;" by adding the given person and e-mail address to the user's address book.
</p>

<p>
~Web上の どの~siteも利用者の~address-bookを操作できては困るので、
%提供者 は，当の %~social~site など, 一定の信用済み~siteに限って，これを許容するであろう。
◎
To avoid any site on the Web being able to manipulate the user's contacts, the contacts provider might only allow certain trusted sites, such as the social site, to do this.
</p>

<div class="p">
<p>
ここで、 %消費者 は，利用者の~address-bookにメールアドレス（例えば、~gameの対戦相手の）を追加したいと求めていて、 %~social~site は，自らに利するため それを許容するつもりにあるとする
— それは，本質的には、 %提供者 が %~social~site と信用-を “共有すること” に等しい。
これを行う仕方にはいくつかあり、最も単純なのは， %~social~site が %消費者 ~siteと %提供者  ~siteとの間の~messageを代理することであろう。
しかしながら、この解決策には 難点がある：
</p>

<ul>
	<li>
%~social~site は、［
%消費者 ~siteが特権を濫用しないこと
］を完全に信用するか，あるいは 許容したくない要請（メールアドレスを［
複数~追加する ／ 読取る ／ 削除する
］など）ではないことを確かめるため，各~要請を検証0することが要求される。
</li>
	<li>
他にもいくつかの %消費者 が居て，同時的に %提供者 と相互作用することもあり得る場合、複雑さが増す。
</li>
</ul>
◎
Now suppose the game wanted to add a contact to the user's address book, and that the social site was willing to allow it to do so on its behalf, essentially "sharing" the trust that the contacts provider had with the social site. There are several ways it could do this; most simply, it could just proxy messages between the game site and the contacts site. However, this solution has a number of difficulties: it requires the social site to either completely trust the game site not to abuse the privilege, or it requires that the social site verify each request to make sure it's not a request that it doesn't want to allow (such as adding multiple contacts, reading the contacts, or deleting them); it also requires some additional complexity if there's ever the possibility of multiple games simultaneously trying to interact with the contacts provider.
</div>

<p>
~message~channelと `MessagePort$I ~objを用いれば、これらの問題すべてを消し去れる。
%消費者 がメールアドレスを追加したいと求める旨を %~social~site に伝えたとき、 %~social~site は、メールアドレスを追加することではなく，［
1 個のメールアドレスを追加する<em>能力</em>
］について， %提供者 に~~要請できる。
それに対し， %提供者 は、
`MessagePort$I ~objの~pairを作成して，その片方を %~social~site に返信する。
%~social~site は、受信したそれを %消費者 に回送する。
それにより、 %消費者 と %提供者 は，直接的に接続されることになり、
%提供者 は， “1 個のメールアドレスを追加する” 要請のみ尊守すればよいことを知る。
言い換えれば、 %消費者 には， 1 個のメールアドレスを追加する能力が是認されたことになる。
◎
Using message channels and MessagePort objects, however, all of these problems can go away. When the game tells the social site that it wants to add a contact, the social site can ask the contacts provider not for it to add a contact, but for the capability to add a single contact. The contacts provider then creates a pair of MessagePort objects, and sends one of them back to the social site, who forwards it on to the game. The game and the contacts provider then have a direct connection, and the contacts provider knows to only honor a single "add contact" request, nothing else. In other words, the game has been granted the capability to add a single contact.
</p>




				</section>
				<section id="ports-as-the-basis-of-abstracting-out-service-implementations">
<h4 title="Ports as the basis of abstracting out service implementations">9.5.1.3. ~service実装を抽象~化する基礎としての~port</h4>

~INFORMATIVE

<p>
前~節からの例を引き継いで、特に， %提供者 側を考える。
初期~実装では、単純に~serviceの `iframe$e 内で `XMLHttpRequest$I ~objを利用していたが、~serviceの発展に伴い，単独の `WebSocket$I 接続を備える`共用~worker$の利用に代えたいと求めることもあろう。
◎
Continuing the example from the previous section, consider the contacts provider in particular. While an initial implementation might have simply used XMLHttpRequest objects in the service's iframe, an evolution of the service might instead want to use a shared worker with a single WebSocket connection.
</p>

<p>
初期~設計の段階で， `MessagePort$I ~objを［
能力を是認するため／
または単に複数の同時的な独立~sessionを許容するため
］に利用していたなら、~service実装は，~APIに全く手を加えずに［
各 `iframe$e ごとに `XMLHttpRequest$I を用いる~model
］から［
`WebSocket$I を共有する~model
］へ切替えれるようになる
— ~service提供者~側のすべての~portは、~APIの利用者にまったく影響することなく，共用~workerに回送できる。
◎
If the initial design used MessagePort objects to grant capabilities, or even just to allow multiple simultaneous independent sessions, the service implementation can switch from the XMLHttpRequests-in-each-iframe model to the shared-WebSocket model without changing the API at all: the ports on the service provider side can all be forwarded to the shared worker without it affecting the users of the API in the slightest.
</p>





				</section>
			</section>
			<section id="message-channels">
<h3 title="Message channels">9.5.2. ~message~channel</h3>

<pre class="idl">
[<a href="#dom-messagechannel">Constructor</a>, Exposed=(Window,Worker)]
interface `MessageChannel@I {
  readonly attribute `MessagePort$I `port1$m;
  readonly attribute `MessagePort$I `port2$m;
};
</pre>

<dl class="domintro">

	<dt>%channel = new `MessageChannel()$m</dt>
	<dd>
2 個の新たな `MessagePort$I ~objが伴われた，新たな `MessageChannel$I ~objを返す。
◎
Returns a new MessageChannel object with two new MessagePort objects.
</dd>

	<dt>%channel . `port1$m</dt>
	<dd>
1 個目の `MessagePort$I ~objを返す。
◎
Returns the first MessagePort object.
</dd>

	<dt>%channel . `port2$m</dt>
	<dd>
2 個目の `MessagePort$I ~objを返す。
◎
Returns the second MessagePort object.
</dd>
</dl>

<dl class="idl-def">
	<dt>`MessageChannel()@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
When the MessageChannel() constructor is called, it must run the following algorithm:
</p>

		<ol>
			<li>
%port1 ~LET
`現任の設定群~obj$から`新たな~MessagePort~objを作成-$した結果
◎
Create a new MessagePort object whose owner is the incumbent settings object, and let port1 be that object.
</li>
			<li>
%port2 ~LET
`現任の設定群~obj$から`新たな~MessagePort~objを作成-$した結果
◎
Create a new MessagePort object whose owner is the incumbent settings object, and let port2 be that object.
</li>
			<li>
( %port1, %port2 )
を`連絡-$する
◎
Entangle the port1 and port2 objects.
</li>
			<li>
%~channel ~LET 新たな `MessageChannel$I ~obj
◎
Instantiate a new MessageChannel object, and let channel be that object.
</li>
			<li>
%~channel の `port1$m 属性 ~SET %port1
◎
Let the port1 attribute of the channel object be port1.
</li>
			<li>
%~channel の `port2$m 属性 ~SET %port2
◎
Let the port2 attribute of the channel object be port2.
</li>
			<li>
~RET %~channel
◎
Return channel.
</li>
		</ol>
	</dd>

	<dt>`port1@m</dt>
	<dt>`port2@m</dt>
	<dd>
いずれの取得子も、此れの作成-時にあてがわれた値を返さ~MUST。
◎
The port1 and port2 attributes must return the values they were assigned when the MessageChannel object was created.
</dd>
</dl>

			</section>
			<section id="message-ports">
<h3 title="Message ports">9.5.3. ~message~port</h3>

<p>
各~channelは、 2 個の~message~portを持つ。
一方の~portから送信された~dataは，他方の~portに受信され、逆も同様になる。
◎
Each channel has two message ports. Data sent through one port is received by the other port, and vice versa.
</p>

<pre class="idl">
[Exposed=(Window,Worker) `Transferable$]
interface `MessagePort@I : `EventTarget$I {
  void ``postMessage$m(any %message, optional sequence&lt;`object$I&gt; %transfer = []);
  void ``start$m();
  void ``close$m();

  // event handlers
  attribute `EventHandler$I ``onmessage$m;
  attribute `EventHandler$I ``onmessageerror$m;
};
</pre>

<dl class="domintro">

	<dt>%port . ``postMessage( message [, transfer] )$m</dt>
	<dd>
~channelを通して~messageを投函する。
%transfer 内に~listされた~objは、~cloneされるのみならず転送される
— すなわち，送信-側からは、それ以降，それらを利用できなくなる。
◎
Posts a message through the channel. Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.
</dd>
	<dd>
次の場合は `DataCloneError$E が投出される
⇒
%transfer 配列が 同じ~objを重複して包含する場合 ／
%transfer 配列が この~port自身や宛先~portを包含する場合 ／
%message を~cloneできなかった場合
◎
Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or the source or target ports, or if message could not be cloned.
</dd>

	<dt>%port . ``start()$m</dt>
	<dd>
この~portに受信される／された~messageを配送させ始める。
◎
Begins dispatching messages received on the port.
</dd>

	<dt>%port . ``close()$m</dt>
	<dd>
この~portを切断する。
以降、この~portは 作動中でなくなる。
◎
Disconnects the port, so that it is no longer active.
</dd>

</dl>

<div class="p">
<p>
各 `MessagePort$I ~objは、別のそれと連絡され得る（その関係性は対称になる）。
</p>

<p class="trans-note">【
`port1$m, `port2$m のどちらを手元において もう片方を転送しようがかまわない。
】</p>

<p>
各 `MessagePort$I ~objは、次のものを持つ：
</p>

<dl class="def-list">
	<dt>`~port~message待行列@</dt>
	<dd>
`~task源$†。
初期~時には空とする。
`~port~message待行列$は、初期~時には不能化されており，ある時点で可能化され得る。
可能化された後，再び不能化されることは決してない（待行列~内の~messageたちは、別の待行列へ移動されたり，すべて除去されることもあるが
— それは、不能化されるのとほぼ同じ効果になる）。
</dd>
	<dd class="trans-note">【†
ここでは、個々の`~task源$と 個々の`~task待行列$としての`~port~message待行列$とが，同一視されている。
】</dd>

	<dt>`搬送済み~flag@</dt>
	<dd>
初期~時には ~OFF にされ~MUST
</dd>

	<dt>`所有者@</dt>
	<dd>
~objの作成-時に 下に述べるように設定される，`設定群~obj$。
</dd>

</dl>
◎
Each MessagePort object can be entangled with another (a symmetric relationship). Each MessagePort object also has a task source called the port message queue, initially empty. A port message queue can be enabled or disabled, and is initially disabled. Once enabled, a port can never be disabled again (though messages in the queue can get moved to another queue or removed altogether, which has much the same effect). A MessagePort also has a has been shipped flag, which must initially be false, and an owner, which is a settings object set when the object is created, as described below.
</div>

<p>
ある~port %P の`~port~message待行列$ %Q が可能化されたときは、
`~event-loop$は， %Q をその`~task源$の一つとして利用し~MUST。
%P の`所有者$が指定する`担当の~event-loop$が`閲覧文脈~event-loop$である場合、
<!-- ＊待入された -->
%Q に入れられた`~task$に結付けられる文書は，［
%P の`所有者$が指定する`担当の文書$
］にされ~MUST。
◎
When a port's port message queue is enabled, the event loop must use it as one of its task sources. When a port's owner specifies a responsible event loop that is a browsing context event loop, all tasks queued on its port message queue must be associated with the responsible document specified by the port's owner.
</p>

<p class="note">注記：
~portの`所有者$が指定する`担当の文書$が`全部的に作動中$であって、~portに登録されたすべての~event~listenerの~scriptは，［
その`設定群~obj$が `全部的に作動中$でない`担当の文書$を指定する
］場合、待入された~messageたちは，失われることになる。
◎
If the port's owner specifies a responsible document that is fully active, but the event listeners all have scripts whose settings objects specify responsible documents that are not fully active, then the messages will be lost.
</p> 


<div class="p">
<p>
各 `~event-loop$は、
`未搬送の~port~message待行列@
と呼ばれる`~task源$を持つ。
これは， “仮想の†” 待行列であり、［
下の条件を満たす各 `MessagePort$I %P の`~port~message待行列$
］内の~taskすべてを，~taskが待入された順序††で包含しているかのように動作し~MUST
— ~taskが`未搬送の~port~message待行列$から除去されるときは、代わりに，それが実際に属する`~port~message待行列$から除去され~MUST。
</p>

<p>
ここで、各 %P は，次をすべて満たすとする：
</p>

<ul><li>%P の`搬送済み~flag$ ~EQ ~OFF
</li><li>%P の`~port~message待行列$は可能化されている
</li><li>%P の`所有者$が指定する`担当の~event-loop$ ~EQ 当の`~event-loop$
</li></ul>

<p class="trans-note">【†
“仮想の” — すなわち、いくつかの待行列を包装するだけの，それ自身は実体を持たない待行列。
】【††
異なる`~port~message待行列$に属する~taskどうしの，`未搬送の~port~message待行列$の中での順序がどう定義されるのかは、明確に述べられていない（単に時系列順？）。
】</p>

◎
Each event loop has a task source called the unshipped port message queue. This is a virtual task source: it must act as if it contained the tasks of each port message queue of each MessagePort whose has been shipped flag is false, whose port message queue is enabled, and whose owner specifies that event loop as the responsible event loop, in the order in which they were added to their respective task source. When a task would be removed from the unshipped port message queue, it must instead be removed from its port message queue.
</div>

<p>
［
`MessagePort$I の`搬送済み~flag$ ~EQ ~OFF
］の下では、その`~port~message待行列$は，`~event-loop$の目的においては無視され~MUST（代わりに，`未搬送の~port~message待行列$が利用される）。
◎
When a MessagePort's has been shipped flag is false, its port message queue must be ignored for the purposes of the event loop. (The unshipped port message queue is used instead.)
</p>

<p class="note">注記：
`MessagePort$I ~obj %P の`搬送済み~flag$は、［
%P, %P の相手~側~port, %P の~clone元~obj
］のいずれかが，転送されるか, すでにされている
］ときに ~ON にされる。
%P の`搬送済み~flag$が ~ON にされて以降は、
%P の`~port~message待行列$は first-class `~task源$
`すなわち， “通常の，独立な” ~task源^tnote
として動作し，`未搬送の~port~message待行列$には影響しなくなる
`その一部を成さなくなる^tnote。
◎
The has been shipped flag is set to true when a port, its twin, or the object it was cloned from, is or has been transferred. When a MessagePort's has been shipped flag is true, its port message queue acts as a first-class task source, unaffected to any unshipped port message queue.
</p>

<p class="algo-head">
~UAは，所与の`環境~設定群~obj$ %所有者 から
`新たな~MessagePort~objを作成-@
するときは、新たな `MessagePort$I ~objを，［
その`所有者$ ~SET %所有者
］にした上で 返さ~MUST。
◎
When the user agent is to create a new MessagePort object with a particular environment settings object as its owner, it must instantiate a new MessagePort object, and let its owner be owner.
</p>

<p class="algo-head">
~UAは， 2 個の `MessagePort$I ~obj %A, %B を
`連絡-@
するときは、次の手続きを走らせ~MUST：
◎
When the user agent is to entangle two MessagePort objects, it must run the following steps:
</p>

<ol>
	<li>
<p>
~FOR
~EACH ( %P ~IN { %A, %B } ) に対し
⇒
~IF［
%P に連絡されている別の `MessagePort$I ~obj %Q がある
］
⇒
%P と %Q との連絡を解く
◎
If one of the ports is already entangled, then disentangle it and the port that it was entangled with.
</p>

<p class="note">注記：
%P, %Q が，ある `MessageChannel$I ~obj %C の 2 個の~portであった場合、
%C は最早~実際の~channelを表現しなくなる
— それ以降、 %P と %Q が連絡されることはない。
◎
If those two previously entangled ports were the two ports of a MessageChannel object, then that MessageChannel object no longer represents an actual channel: the two ports in that object are no longer entangled.
</p>

	</li>
	<li>
<p>
%A, %B を連絡されるように結付ける
— ある新たな~channelの 2 個の部位を形成するように（その~channelを表現する `MessageChannel$I ~objは，まだない）
◎
Associate the two ports to be entangled, so that they form the two parts of a new channel. (There is no MessageChannel object that represents this channel.)
</p>

<p>
この時点で %A, %B は 互いに連絡されたことになる
◎
Two ports A and B that have gone through this step are now said to be entangled; one is entangled to the other, and vice versa.
</p>

<p class="note">注記：
この仕様は，この処理-を instantaneous として述べるが、実装は，~message passing を介して実装する見込みが高い`？^tnote。
要は、他の~algoと同様，その最終的な結果が、~black-box的意味で “単に” 仕様が定めるものと判別できなければよい。
◎
While this specification describes this process as instantaneous, implementations are more likely to implement it via message passing. As with all algorithms, the key is "merely" that the end result be indistinguishable, in a black-box sense, from the specification.
</p>

	</li>
</ol>

<hr>

<p id="transferMessagePort">
`MessagePort$I ~objは`転送可能~obj$である。
◎
MessagePort objects are transferable objects. Their transfer steps, given value and dataHolder, are:
</p>

<p>
その`転送-手続き$は、所与の
( %値, %~data保持体 )
に対し，次を走らす：
◎
↑</p>

<ol>
	<li>
%値 の`搬送済み~flag$ ~SET ~ON
◎
Set value's has been shipped flag to true.
</li>
	<li>
%~data保持体 . `PortMessageQueue^sl ~SET %値 の`~port~message待行列$
◎
Set dataHolder.[[PortMessageQueue]] to value's port message queue.
</li>
	<li>
<p>
~IF［
ある別~port %~remote~port が %値 に連絡されている
］：
◎
If value is entangled with another port remotePort, then:
</p>

		<ol>
			<li>
%~remote~port の`搬送済み~flag$ ~SET ~ON
◎
Set remotePort's has been shipped flag to true.
</li>
	<li>
<p>
%~data保持体 . `RemotePort^sl ~SET %~remote~port
◎
Set dataHolder.[[RemotePort]] to remotePort.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
⇒
%~data保持体 . `RemotePort^sl ~SET ~NULL
◎
Otherwise, set dataHolder.[[RemotePort]] to null.
</li>
</ol>

<p>
その`転送-受信-時の手続き$は、所与の
( %~data保持体, %値 )
に対し，次を走らす：
◎
Their transfer-receiving steps, given dataHolder and value, are:
</p>

<ol>
	<li>
%値 の`搬送済み~flag$ ~SET ~ON
◎
Set value's has been shipped flag to true.
</li>
	<li>
%所有者 ~LET %値 に`関連する設定群~obj$
◎
↓</li>
	<li>
%値 の`所有者$ ~SET %所有者
◎
Set value's owner to value's relevant settings object.
</li>
	<li>
<p>
%~data保持体 . `PortMessageQueue^sl 内の［
`message$et ~eventを発火する`~task$
］すべてを
%値 の`~port~message待行列$に移動する
— その際には：
</p>

<ul ><li>%値 の`~port~message待行列$は，（初期~時の）不能化~状態のまま変えない
</li><li>［
%所有者 が指定する`担当の~event-loop$は `閲覧文脈~event-loop$である
］場合、移動された`~task$に， %所有者 が指定する`担当の文書$を結付ける
</li></ul>

◎
Move all the tasks that are to fire message events in dataHolder.[[PortMessageQueue]] to the port message queue of value, if any, leaving value's port message queue in its initial disabled state, and, if value's owner specifies a responsible event loop that is a browsing context event loop, associating the moved tasks with the responsible document specified by value's owner.
</li>
	<li>
~IF［
%~data保持体 . `RemotePort^sl ~NEQ ~NULL
］
⇒
( %~data保持体 . `RemotePort^sl, %値 )
を`連絡-$する
（これは、元の転送された~portと %~data保持体 . `RemotePort^sl との連絡を解くことになる。）
◎
If dataHolder.[[RemotePort]] is not null, then entangle dataHolder.[[RemotePort]] and value. (This will disentangle dataHolder.[[RemotePort]] from the original port that was transferred.)
</li>
</ol>

<hr>

<dl class="idl-def">
	<dt>``postMessage( message, transfer )@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The postMessage(message, transfer) method, when invoked on a MessagePort object, must run the following steps:
</p>

<ol>
	<li>
%宛先~port ~LET  此れに連絡されている~portが［
あれば それ ／
なければ ~NULL
］
◎
Let targetPort be the port with which this MessagePort is entangled, if any; otherwise let it be null.
</li>
			<li>
<p>
~IF［
%transfer 内に此れがある†
］
⇒
~THROW `DataCloneError$E
◎
If any of the objects in transfer are this MessagePort, then throw a "DataCloneError" DOMException and abort these steps.
</p>
<p class="trans-note">【†
“内にある” が、 “配列~内に直接的に含まれている” ことを意味するのか，深く入子にされて含まれている場合も含めるのか、はっきりしない。
】</p>
			</li>
			<li>
%破棄予定 ~LET ~F
◎
Let doomed be false.
</li>
			<li>
<p>
~IF［
%宛先~port ~NEQ ~NULL
］~AND［
%transfer 内に %宛先~port はある
］：
</p>

<ol><li>
%破棄予定 ~SET ~T
</li><li>任意選択で
⇒
%宛先~port が自身に向けて投函された結果，通信~channelは失われることを、~UAの開発者~consoleに報告する
</li></ol>

◎
If targetPort is not null and any of the objects in transfer are targetPort, then set doomed to true, and optionally report to a developer console that the target port was posted to itself, causing the communication channel to be lost.
</li>
			<li>
%転送-を伴う直列化-結果 ~LET `StructuredSerializeWithTransfer$jA( %message, %transfer )
（例外投出あり）
◎
Let serializeWithTransferResult be StructuredSerializeWithTransfer(message, transfer). Rethrow any exceptions.
</li>
			<li>
~IF［
%宛先~port ~EQ ~NULL
］~OR［
%破棄予定 ~EQ ~T
］
⇒
~RET
◎
If there is no targetPort (i.e. if this MessagePort is not entangled), or if doomed is true, then abort these steps.
</li>
			<li>
<p>
次の手続きを走らす`~task$を
%宛先~port の`~port~message待行列$に追加する：
◎
Add a task that runs the following steps to the port message queue of targetPort:
</p>
				<ol>
					<li>
<p>
%最終~宛先~port ~LET この~taskが見出される`~port~message待行列$を持つ `MessagePort$I ~obj
◎
Let finalTargetPort be the MessagePort in whose port message queue the task now finds itself.
</p>
<p class="note">
これは %宛先~port と異なり得る
— %宛先~port 自身が転送されるに伴い，その~taskすべても移動された場合には。
◎
This can be different from targetPort, if targetPort itself was transferred and thus all its tasks moved along with it.
</p>
					</li>
					<li>
%宛先~Realm ~LET %最終~宛先~port に`関連する~Realm$
◎
Let targetRealm be finalTargetPort's relevant Realm.
</li>
					<li>
%逆直列化-~record ~LET `StructuredDeserializeWithTransfer$jA( %転送-を伴う直列化-結果, %宛先~Realm )
◎
Let deserializeRecord be StructuredDeserializeWithTransfer(serializeWithTransferResult, targetRealm).
</li>
					<li>
<p>
~IF［
前~段にて例外が投出された
］：
</p>
				<ol>
					<li>
%最終~宛先~port に向けて，名前 `messageerror$et の,
`MessageEvent$I を利用する`~eventを発火-$する
</li>
					<li>
~RET
</li>
				</ol>
◎
If this throws an exception, fire an event named messageerror at finalTargetPort, using MessageEvent, and then abort these steps. 
</li>
					<li>
%~message~clone ~LET %逆直列化-~record . `Deserialized^sl
◎
Let messageClone be deserializeRecord.[[Deserialized]].
</li>
					<li>
%新~port~list ~LET
%逆直列化-~record . `TransferredValues^sl 内の すべての `MessagePort$I ~objからなる，同順の新たな`凍結~配列$
◎
Let newPorts be a new frozen array consisting of all MessagePort objects in deserializeRecord.[[TransferredValues]], if any, maintaining their relative order.
</li>
					<li>
<p>
%最終~宛先~port に向けて，次のように初期化された名前 `message$et の`~eventを発火-$する：
</p>

<ul ><li>`MessageEvent$I を利用する
</li><li>`data$m 属性 ~SET  %~message~clone
</li><li>`ports$m 属性 ~SET %新~port~list
</li></ul>

◎
Fire an event named message at finalTargetPort, using MessageEvent, with the data attribute initialized to messageClone and the ports attribute initialized to newPorts.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>``start()@m</dt>
	<dd>
被呼出時には、まだ可能化されていなければ，此れの`~port~message待行列$を可能化し~MUST。
◎
The start() method must enable its port's port message queue, if it is not already enabled.
</dd>

	<dt>``close()@m</dt>
	<dd>
被呼出時には、此れに別~portが連絡されていれば，それを解か~MUST。
◎
The close() method, when called on a port local port that is entangled with another port, must cause the user agent to disentangle the two ports. If the method is called on a port that is not entangled, then the method must do nothing.
</dd>
</dl>


<hr>

<p>
`MessagePort$I ~interfaceを実装している~すべての~objは、以下に挙げる`~event~handler$, および対応する`~event~handler~event型$を，`~event~handler~IDL属性$として~supportし~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the MessagePort interface:
</p>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>``onmessage@m
<td>`message$et

<tr><td>``onmessageerror@m
<td>`messageerror$et

</tbody></table>

<p>
%P の`~port~message待行列$は、
`MessagePort$I ~obj %P の ``onmessage$m ~IDL属性が初回に設定された時点で，
%P の ``start()$m ~methodが~callされたかのように可能化され~MUST。
◎
The first time a MessagePort object's onmessage IDL attribute is set, the port's port message queue must be enabled, as if the start() method had been called.
</p>


			</section>
			<section id="broadcasting-to-many-ports">
<h3 title="Broadcasting to many ports">9.5.4. 多数の~portへの~broadcast法</h3>

~INFORMATIVE

<p>
多数の~portへ~broadcastすることは、原則的には，比較的~単純であり、~messageを送信-用の `MessagePort$I ~objからなる配列を保っておいて，配列~内を反復して, ~messageを送信すればよい。
しかしながら、相手~側が消去っても それらの~portを~garbage収集できなくなるという，困った効果もある。
この問題を避けるには、相手~側から自身の存在を認知させるような，単純な~protocolを実装するとよい
— 一定時間そうしなかったなら，消去ったと見做して、 `MessagePort$I ~objを~closeすることにより，~garbage収集に任せるような。
◎
Broadcasting to many ports is in principle relatively simple: keep an array of MessagePort objects to send messages to, and iterate through the array to send a message. However, this has one rather unfortunate effect: it prevents the ports from being garbage collected, even if the other side has gone away. To avoid this problem, implement a simple protocol whereby the other side acknowledges it still exists. If it doesn't do so after a certain amount of time, assume it's gone, close the MessagePort object, and let it be garbage collected.
</p>


			</section>
			<section id="ports-and-garbage-collection">
<h3 title="Ports and garbage collection">9.5.5. ~portと~garbage収集</h3>

<div class="p">
<p>
`MessagePort$I ~obj %O が連絡されたときは、~UAは，次のいずれかから %O への強い参照-があるかのように動作し~MUST：
</p>

<ul><li>%O に連絡されている `MessagePort$I ~obj
</li><li>%O の`所有者$が指定する`大域~obj$enV
</li></ul>
◎
When a MessagePort object o is entangled, user agents must either act as if o's entangled MessagePort object has a strong reference to o, or as if the global object specified by o's owner has a strong reference to o.
</div>

<div class="note">

<p>注記：
したがって，~message~portは、受信して~event~listenerをあてがった後は，放置しておくこともできる
— その~event~listenerが~messageを受信できる限り，~channelは保守される。
◎
Thus, a message port can be received, given an event listener, and then forgotten, and so long as that event listener could receive a message, the channel will be maintained.
</p>

<p>
無論，これが当の~channelの両~側に生じた場合、両~portとも~garbage収集され得る
— それらは、互いに強い参照-があるとしても，生きた~codeからは到達できなくなるので。
◎
Of course, if this was to occur on both sides of the channel, then both ports could be garbage collected, since they would not be reachable from live code, despite having a strong reference to each other.
</p>

</div>

<div class="p">
<p>
更には， `MessagePort$I ~obj %O は、次のいずれかが満たされている間は，~garbage収集されては~MUST_NOT：
</p> 

<ul><li>ある`~task待行列$内の ある`~task$が、 %O に向けて配送される~eventを参照している
</li><li>%O の`~port~message待行列$は、空でない, かつ 可能化されている
</li></ul>
◎
Furthermore, a MessagePort object must not be garbage collected while there exists an event referenced by a task in a task queue that is to be dispatched on that MessagePort object, or while the MessagePort object's port message queue is enabled and not empty.
</div>

<p class="note">注記：
作者には、 `MessagePort$I ~objを明示的に~closeして，それらの連絡を解くことが強く奨励される
— そうすれば、それらの資源は再収集できるようになる。
多数の `MessagePort$I ~objを作成して，それらを~closeすることなく破棄することは、一時的に多量の~memoryを~~消費させ得る
— ~garbage収集は、とりわけ， `MessagePort$I に対する~garbage収集に~cross-processの協調も孕まれ得る所では、即座に遂行されるとは限らないので。
◎
Authors are strongly encouraged to explicitly close MessagePort objects to disentangle them, so that their resources can be recollected. Creating many MessagePort objects and discarding them without closing them can lead to high transient memory usage since garbage collection is not necessarily performed promptly, especially for MessagePorts where garbage collection can involve cross-process coordination.
</p>


			</section>
		</section>
		<section id="broadcasting-to-other-browsing-contexts">
<h2 title="Broadcasting to other browsing contexts">9.6. 他の閲覧文脈への~broadcast法</h2>

<!-- ``BroadcastChannel^I -->

<p>
ときには、［
同じ~UA内で同じ利用者により~openされているが，互いに関係しない異なる`閲覧文脈$内にある
］ような，同じ`生成元$に属する複数の頁どうしが、互いに通知を送信しあう必要が生じることもある。
例えば、
“利用者がこっちに~log-inしたから、そっちでも資格証を再度~検査してくれ”
。
◎
Pages on a single origin opened by the same user in the same user agent but in different unrelated browsing contexts sometimes need to send notifications to each other, for example "hey, the user logged in over here, check your credentials again".
</p>

<p>
もっと手の込んだ事例においては、`共用~worker$が最も適切な解決策になる
— 例えば：
共有されている状態の~lockingを管理する ／
~serverと複数の局所~clientとの間で 資源の同期を管理する ／
`WebSocket$I 接続を~remote~hostと共有する，等々。
◎
For elaborate cases, e.g. to manage locking of shared state, to manage synchronization of resources between a server and multiple local clients, to share a WebSocket connection with a remote host, and so forth, shared workers are the most appropriate solution.
</p>

<p>
共用~workerでは大げさにすぎるような単純な事例では、作者は，この節に述べる 単純な~channelに基づく~broadcastの仕組みを利用できる。
◎
For simple cases, though, where a shared worker would be an unreasonable overhead, authors can use the simple channel-based broadcast mechanism described in this section.
</p>

<pre class="idl">
[``Constructor$m(DOMString %name), Exposed=(Window,Worker)]
interface `BroadcastChannel@I : `EventTarget$I {
  readonly attribute DOMString ``name$m;
  void ``postMessage$m(any %message);
  void ``close$m();
  attribute `EventHandler$I ``onmessage$m;
  attribute `EventHandler$I ``onmessageerror$m;
};
</pre>

<dl class="domintro">

	<dt>%broadcastChannel = new `BroadcastChannel(name)$m</dt>
	<dd>
~channel名 %name の~channelを介して~messageを［
送信できる／受信できる
］ような，新たな `BroadcastChannel$I ~objを返す。
◎
Returns a new BroadcastChannel object via which messages for the given channel name can be sent and received.
</dd>

	<dt>%broadcastChannel . ``name$m</dt>
	<dd>
（構築子に渡された）~channel名を返す。
◎
Returns the channel name (as passed to the constructor).
</dd>

	<dt>%broadcastChannel . ``postMessage( message )$m</dt>
	<dd>
所与の~messageを，この~channelに設定しておかれた 他の `BroadcastChannel$I ~objへ送信する。
~messageは、入子の~objや配列など，有構造~dataも可能である。
◎
Sends the given message to other BroadcastChannel objects set up for this channel. Messages can be structured objects, e.g. nested objects and arrays.
</dd>

	<dt>%broadcastChannel . ``close()$m</dt>
	<dd>
`BroadcastChannel$I ~objを~closeして，~garbage収集に委ねる。
◎
Closes the BroadcastChannel object, opening it up to garbage collection.
</dd>
</dl>

<div class="p">
<p>
`BroadcastChannel$I ~objは、次のものを持つ：
</p>

<dl class="def-list">
	<dt>`~channel名@</dt>
	<dd>
共有する通信~channelを識別する文字列。
</dd>

	<dt>`~BroadcastChannel設定群~obj@</dt>
	<dd>
`環境~設定群~obj$。
</dd>

	<dt>`~close済み~flag@</dt>
	<dd>
~ON ならば、通信は~closeされたことを指示する。
</dd>
</dl>

◎
A BroadcastChannel object has a channel name, a BroadcastChannel settings object, and a closed flag.
</div>


<dl class="idl-def">
	<dt>`BroadcastChannel( name )@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次のように設定された新たな
`BroadcastChannel$I ~objを返さ~MUST：
</p>

<ul><li>`~channel名$ ~SET %name
</li><li>`~BroadcastChannel設定群~obj$ ~SET `現任の設定群~obj$
</li><li>`~close済み~flag$ ~SET ~OFF
</li></ul>

◎
The BroadcastChannel() constructor, when invoked, must create and return a BroadcastChannel object whose channel name is the constructor's first argument, whose BroadcastChannel settings object is the incumbent settings object, and whose closed flag is false.
</dd>

	<dt>``name@m</dt>
	<dd>
取得子は、此れの`~channel名$を返さ~MUST。
◎
The name attribute must return the channel name.
</dd>

	<dt>``postMessage( message )@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The postMessage(message) method, when invoked on a BroadcastChannel object, must run the following steps:
</p>

		<ol>
			<li>
%~source設定群 ~LET 
此れの`~BroadcastChannel設定群~obj$
◎
Let source be this BroadcastChannel.
◎
Let sourceSettings be source's BroadcastChannel settings object.
</li>
			<li>
~IF［
此れの`~close済み~flag$ ~EQ ~ON
］
⇒
~THROW `InvalidStateError$E
◎
If source's closed flag is true, then throw an "InvalidStateError" DOMException and abort these steps.
</li>
			<li>
%~source~channel ~LET 此れの`~channel名$
◎
Let sourceChannel be source's channel name.
</li>
			<li>
%宛先~Realm ~LET ~UAにより定義される~Realm
◎
Let targetRealm be a user-agent defined Realm.
</li>
			<li>
%直列形 ~LET  `StructuredSerialize$jA( %~message, %宛先~Realm )
（例外投出あり）
◎
Let serialized be StructuredSerialize(message). Rethrow any exceptions.
</li>
			<li>
<p>
%行先~list ~LET 次をすべて満たす `BroadcastChannel$I ~obj %O すべてからなる~list：
◎
Let destinations be a list of BroadcastChannel objects that match the following criteria:
</p>

				<ul>
					<li>
<p>
%O の`~BroadcastChannel設定群~obj$を %設定群, 
%設定群 が指定する`大域~obj$enV を %G とするとき：
◎
Their BroadcastChannel settings object specifies either:
</p>
						<ul>
							<li>
<p>
次のいずれかが満たされる：
</p>
								 <ul>
									 <li>
［
%G は `Window$I ~objである
］~AND［
%設定群 の`担当の文書$は`全部的に作動中$である
］
◎
a global object that is a Window object and a responsible document that is fully active, or
</li>
			<li>
［
%G は `WorkerGlobalScope$I ~objである
］~AND［
%G の `~closing~flag$ ~EQ ~F
］~AND［
%G の`~worker$は`休止可能$でない
］
◎
a global object that is a WorkerGlobalScope object whose closing flag is false and whose worker is not a suspendable worker.
</li>
								</ul>
							</li>
							<li>
( %設定群 の`生成元$enV, %~source設定群 の`生成元$enV )
は`同一生成元$である
◎
Their BroadcastChannel settings object's origin is same origin with sourceSettings's origin.
</li>
						</ul>
					<li>
%O の`~channel名$ ~EQ %~source~channel
◎
Their channel name is a case-sensitive match for sourceChannel.
</li>
					<li>
%O の`~close済み~flag$ ~EQ ~OFF
◎
Their closed flag is false.
</li>
				</ul>
			</li>
			<li>
%行先~list から此れを除去する
◎
Remove source from destinations.
</li>
			<li>
%行先~list を，次が満たされるように~sortする
⇒
%行先~list 内の `BroadcastChannel$I ~objのうち，［
その`~BroadcastChannel設定群~obj$が同じ`担当の~event-loop$を指定するもの
］どうしは、古いものから，作成した順に並ぶ
（これは、完全な順序付けは定義しない。~UAは、この拘束の下で，自身が定義する方式で更に~sortしてよい。）
◎
Sort destinations such that all BroadcastChannel objects whose BroadcastChannel settings objects specify the same responsible event loop are sorted in creation order, oldest first. (This does not define a complete ordering. Within this constraint, user agents may sort the list in any user-agent defined manner.)
</li>
			<li>
<p>
%行先~list 内の ~EACH( `BroadcastChannel$I ~obj %行先 ) に対し
⇒
次の手続きを走らす`~taskを待入する$：
◎
For each BroadcastChannel object destination in destinations, queue a task that runs the following steps:
</p>
				<ol>
					<li>
%宛先~Realm ~LET %行先 に`関連する~Realm$
◎
Let targetRealm be destination's relevant Realm.
</li>
					<li>
%生成元 ~LET %~source設定群 の`生成元$enVの`~Unicode直列化$
◎
↓</li>
					<li>
%~data ~LET `StructuredDeserialize$jA( %直列形, %宛先~Realm )
◎
Let data be StructuredDeserialize(serialized, targetRealm).
</li>
			<li>
<p>
~IF［
前~段にて例外が投出された
］：
</p>
				<ol>
					<li>
<p>
%行先 に向けて，次のように初期化された名前 `messageerror$et の`~eventを発火-$する：
</p>

<ul ><li>`MessageEvent$I を利用する
</li><li>`origin$m 属性 ~SET %生成元
</li></ul>
					</li>
					<li>
~RET
</li>
				</ol>
◎
If this throws an exception, then fire an event named messageerror at destination, using MessageEvent, with the origin attribute initialized to the Unicode serialization of sourceSettings's origin, and then abort these steps.
</li>
					<li>
<p>
%行先 に向けて，次のように初期化された 名前 `message$et の`~eventを発火-$する
</p>

<ul ><li>`MessageEvent$I ~interfaceを利用する
</li><li>`data$m 属性 ~SET %~data
</li><li>`origin$m 属性 ~SET %生成元
</li></ul>

◎
Fire an event named message at destination, using MessageEvent, with the data attribute initialized to data and the origin attribute initialized to the Unicode serialization of sourceSettings's origin.
</li>
				</ol>

<div class="p">
<p>
この段の`~task$に対しては、次が要求される：
</p>

<ul><li>`~DOM操作~task源$を利用する
</li><li>%行先 の`~BroadcastChannel設定群~obj$ %O が指定する`~event-loop$が`閲覧文脈~event-loop$である場合、~taskに結付けられる文書は， %O が指定する`担当の文書$とする
</li></ul>

◎
The tasks must use the DOM manipulation task source, and, for those where the event loop specified by the target BroadcastChannel object's BroadcastChannel settings object is a browsing context event loop, must be associated with the responsible document specified by that target BroadcastChannel object's BroadcastChannel settings object.
</div>
			</li>
		</ol>
	</dd>
</dl>


<div class="p">
<p>
`BroadcastChannel$I ~obj %O に対しては、次がいずれも満たされている間は，［
%O の`~BroadcastChannel設定群~obj$が指定する`大域~obj$enV
］から %O への強い参照-が~MUST：
</p>

<ul><li>%O の`~close済み~flag$ ~EQ ~OFF
</li><li>%O 向けの `message$et ~eventに対し登録されている~event~listenerがある
</li></ul>

◎
While a BroadcastChannel object whose closed flag is false has an event listener registered for message events, there must be a strong reference from global object specified by the BroadcastChannel object's BroadcastChannel settings object to the BroadcastChannel object itself.
</div>

<dl class="idl-def">
	<dt>``close()@m</dt>
	<dd>
被呼出時には、［
此れの`~close済み~flag$ ~SET ~ON
］にし~MUST
◎
The close() method must set the closed flag of the BroadcastChannel object on which it was invoked to true.
</dd>
</dl>

<p class="note">注記：
作者には、 `BroadcastChannel$I ~objが不要になり次第，~UAが~garbage収集できるように
明示的に~closeすることが強く奨励される。
多数の `BroadcastChannel$I ~objを作成して，~event~listenerを伴わせたまま ~closeすることなく破棄した場合、目に見える~memory漏洩-をもたらす
— それらの~objは、~event~listenerがある限り（または、それらが属する［
頁／~worker
］が~closeされるまで），生き残り続けようとするので。
◎
Authors are strongly encouraged to explicitly close BroadcastChannel objects when they are no longer needed, so that they can be garbage collected. Creating many BroadcastChannel objects and discarding them while leaving them with an event listener and without closing them can lead to an apparent memory leak, since the objects will continue to live for as long as they have an event listener (or until their page or worker is closed).
</p>

<hr>

<p>
`BroadcastChannel$I ~interfaceを実装している~すべての~objは、以下に挙げる`~event~handler$, および対応する`~event~handler~event型$を，`~event~handler~IDL属性$として~supportし~MUST：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the BroadcastChannel interface:
</p>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>``onmessage@m
<td>`message$et

<tr><td>``onmessageerror@m
<td>`messageerror$et

</tbody></table>



<div class="example">
<p>
ある頁が利用者が，いつ~log-outしたか知りたいと求めているとする
— 同じ~siteに属する別の~tabの頁から利用者がそうしたときでも：
◎
Suppose a page wants to know when the user logs out, even when the user does so from another tab at the same site:
</p>

<pre class="js-code">
var %authChannel = new BroadcastChannel('auth');
%authChannel.onmessage = function (%event) {
  if (%event.data == 'logout')
    showLogout();
}

function logoutRequested() {
  /* <span class="comment">
利用者から~log-outを請われたとき，~callされる
◎
called when the user asks us to log them out
</span> */
  doLogout();
  showLogout();
  %authChannel.postMessage('logout');
}

function doLogout() {
  /* <span class="comment">
利用者は実際に~log-outした（例： ~cookieを~clearするなど）
◎
actually log the user out (e.g. clearing cookies)
</span> */
  // ...
}

function showLogout() {
  /* <span class="comment">
~log-outしたことを指示するように，~UIを更新する
◎
update the UI to indicate we're logged out
</span> */
  // ...
}
</pre>

  </div>


		</section>
	</section>

</main>
